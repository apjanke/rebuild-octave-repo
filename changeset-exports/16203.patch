# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1362598579 18000
#      Wed Mar 06 14:36:19 2013 -0500
# Node ID 127cccb037bf2dcf138442050bfab41da0e33656
# Parent  7ce484126bb2ca93d944ad8600a9e63923107f90
move more global parser and lexer variables to classes

* pt-check.h, pt-check.cc (tree_checker::file_name): New data member.
(tree_checker::gripe): Use it instead of curr_fcn_file_name.

* input.h, input.cc, octave.cc (input_from_command_line_file):
Delete global variable and all uses.

* parse.h, oct-parse.in.yy (input_from_startup_file): Delete global
variable and all uses.

* input.h, input.cc, lex.h, lex.ll (curr_fcn_file_name,
curr_fcn_file_full_name): Declare as members of lexical_feedback
class.  Rename to fcn_file_name and fcn_file_full_name.  Change all
uses.
* oct-parse.in.yy (parse_fcn_file): New arg, file.  Set
curr_lexer->fcn_file_name and curr_lexer->fcn_file_full_name here.
(load_fcn_from_file): Pass short file name to parse_fcn_file.
* octave.cc (execute_command_line_file): Not here.

* lex.h, lex.ll (lexical_feedback::force_script): New data member.
* oct-parse.in.yy (parse_fcn_file): Set it here.

* lex.h, lex.ll (lexical_feedback::input_from_terminal,
lexical_feedback::input_from_file): New functions.

* lex.ll (octave_lexer::handle_keyword): Set reading_fcn_file,
reading_classdef_file, and reading_script_file.

* lex.h, lex.ll (lexical_feedback::token_count): New variable.
(COUNT_TOK_AND_RETURN): Increment it here.  Don't count '\n' as a
token.

* lex.h, lex.ll (lexical_feedback::help_text):
New variable.
* parse.h, parse.in.yy (help_buf): Delete global variable and all uses.
(octave_parser::frob_function, octave_parser::make_script): Use help_text.
* lex.ll (octave_lexer::process_comment): Cache doc string directly in
help_text variable.
(looks_like_copyright): Move here from parse.in.yy.

* lex.h, lex.ll (octave_lexer::prep_for_file): New function.
(octave_lexer::prep_for_function_file,
octave_lexer::prep_for_script_file): Delete.

* parse.in.yy (INPUT_FILE_BEGIN): New start state.  Delete
SCRIPT_FILE_BEGIN and FCN_FILE_BEGIN.  Tentatively set
curr_lexer->reading_script_file to true.
(parse_fcn_file): Call curr_lexer->prep_for_file.
Don't call gobble_leading_whitespace.  Don't attempt to determine
function script, or classdef file status here.

* parse.in.yy (INPUT_FILE): New token.
(SCRIPT_FILE, FUNCTION_FILE): Delete.
* lex.ll (octave_lexer::display_token): Update.

* parse.in.yy (nl, opt_nl): New non-terminals.
(function_file): Delete rule.
(file): Rename from script_file.  Allow opt_nl before opt_list.
Don't make script if reading fcn file.

* parse.in.yy (text_getc, class stdio_stream_reader, skip_white_space,
looking_at_classdef_keyword, gobble_leading_white_space,
looking_at_function_keyword): Delete.
(get_help_from_file): Parse file to get help instead of calling
gobble_leading_white_space

diff --git a/libinterp/interpfcn/input.cc b/libinterp/interpfcn/input.cc
--- a/libinterp/interpfcn/input.cc
+++ b/libinterp/interpfcn/input.cc
@@ -89,29 +89,19 @@ std::string VPS4 = "+ ";
 int Vecho_executing_commands = ECHO_OFF;
 
 // The time we last printed a prompt.
 octave_time Vlast_prompt_time = 0.0;
 
 // Character to append after successful command-line completion attempts.
 static char Vcompletion_append_char = ' ';
 
-// TRUE means that input is coming from a file that was named on
-// the command line.
-bool input_from_command_line_file = false;
-
 // TRUE means that stdin is a terminal, not a pipe or redirected file.
 bool stdin_is_tty = false;
 
-// Simple name of function file we are reading.
-std::string curr_fcn_file_name;
-
-// Full name of file we are reading.
-std::string curr_fcn_file_full_name;
-
 // TRUE means this is an interactive shell.
 bool interactive = false;
 
 // TRUE means the user forced this shell to be interactive (-i).
 bool forced_interactive = false;
 
 // Should we issue a prompt?
 int promptflag = 1;
@@ -513,31 +503,23 @@ get_debug_input (const std::string& prom
     std::cerr << msg << std::endl;
 
   unwind_protect frame;
 
   frame.protect_var (VPS1);
   VPS1 = prompt;
 
   if (! (interactive || forced_interactive)
-      || (CURR_LEXER->reading_fcn_file
-          || CURR_LEXER->reading_classdef_file
-          || CURR_LEXER->reading_script_file
-          || CURR_LEXER->input_from_eval_string ()
-          || input_from_startup_file
-          || input_from_command_line_file))
+      || CURR_LEXER->reading_fcn_file
+      || CURR_LEXER->reading_classdef_file
+      || CURR_LEXER->reading_script_file
+      || CURR_LEXER->input_from_eval_string ())
     {
       frame.protect_var (forced_interactive);
       forced_interactive = true;
-
-      frame.protect_var (input_from_startup_file);
-      input_from_startup_file = false;
-
-      frame.protect_var (input_from_command_line_file);
-      input_from_command_line_file = false;
     }
 
   // octave_parser constructor sets this for us.
   frame.protect_var (CURR_LEXER);
 
   octave_parser curr_parser;
 
   while (Vdebugging)
@@ -656,19 +638,16 @@ get_user_input (const octave_value_list&
   octave_diary << prompt;
 
   bool eof = false;
 
   std::string input_buf = interactive_input (prompt.c_str (), eof);
 
   if (! (error_state || input_buf.empty ()))
     {
-      if (! input_from_startup_file)
-        command_history::add (input_buf);
-
       size_t len = input_buf.length ();
 
       octave_diary << input_buf;
 
       if (input_buf[len - 1] != '\n')
         octave_diary << "\n";
 
       if (len < 1)
diff --git a/libinterp/interpfcn/input.h b/libinterp/interpfcn/input.h
--- a/libinterp/interpfcn/input.h
+++ b/libinterp/interpfcn/input.h
@@ -32,29 +32,19 @@ along with Octave; see the file COPYING.
 #include "oct-time.h"
 #include "oct-obj.h"
 #include "pager.h"
 
 class octave_value;
 
 extern OCTINTERP_API FILE *get_input_from_stdin (void);
 
-// TRUE means that input is coming from a file that was named on
-// the command line.
-extern bool input_from_command_line_file;
-
 // TRUE means that stdin is a terminal, not a pipe or redirected file.
 extern bool stdin_is_tty;
 
-// Simple name of function file we are reading.
-extern std::string curr_fcn_file_name;
-
-// Full name of file we are reading.
-extern std::string curr_fcn_file_full_name;
-
 // TRUE means this is an interactive shell.
 extern bool interactive;
 
 // TRUE means the user forced this shell to be interactive (-i).
 extern bool forced_interactive;
 
 // Should we issue a prompt?
 extern int promptflag;
diff --git a/libinterp/interpfcn/load-path.cc b/libinterp/interpfcn/load-path.cc
--- a/libinterp/interpfcn/load-path.cc
+++ b/libinterp/interpfcn/load-path.cc
@@ -1951,20 +1951,16 @@ static void
 execute_pkg_add_or_del (const std::string& dir,
                         const std::string& script_file)
 {
   if (! octave_interpreter_ready)
     return;
 
   unwind_protect frame;
 
-  frame.protect_var (input_from_startup_file);
-
-  input_from_startup_file = true;
-
   std::string file = file_ops::concat (dir, script_file);
 
   file_stat fs (file);
 
   if (fs.exists ())
     source_file (file, "base");
 }
 
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -350,20 +350,16 @@ safe_source_file (const std::string& fil
 
 // Initialize by reading startup files.
 
 static void
 execute_startup_files (void)
 {
   unwind_protect frame;
 
-  frame.protect_var (input_from_startup_file);
-
-  input_from_startup_file = true;
-
   std::string context;
 
   bool verbose = (verbose_flag && ! inhibit_startup_message);
 
   bool require_file = false;
 
   if (read_site_files)
     {
@@ -483,38 +479,28 @@ execute_command_line_file (const std::st
   octave_interrupt_hook = 0;
   octave_bad_alloc_hook = 0;
 
   octave_catch_interrupts ();
 
   octave_initialized = true;
 
   frame.protect_var (interactive);
-  frame.protect_var (input_from_command_line_file);
-
-  frame.protect_var (curr_fcn_file_name);
-  frame.protect_var (curr_fcn_file_full_name);
 
   frame.protect_var (octave_program_invocation_name);
   frame.protect_var (octave_program_name);
 
   interactive = false;
-  input_from_command_line_file = true;
 
-  curr_fcn_file_name = fname;
-  curr_fcn_file_full_name = curr_fcn_file_name;
-
-  octave_program_invocation_name = curr_fcn_file_name;
+  octave_program_invocation_name = fname;
 
-  size_t pos = curr_fcn_file_name.find_last_of (file_ops::dir_sep_chars ());
+  size_t pos = fname.find_last_of (file_ops::dir_sep_chars ());
 
-  std::string tmp = (pos != std::string::npos)
-    ? curr_fcn_file_name.substr (pos+1) : curr_fcn_file_name;
-
-  octave_program_name = tmp;
+  octave_program_name
+    = (pos != std::string::npos) ? fname.substr (pos+1) : fname;
 
   std::string context;
   bool verbose = false;
   bool require_file = true;
 
   safe_source_file (fname, context, verbose, require_file, "octave");
 }
 
diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -165,22 +165,24 @@ public:
       do_comma_insert (false), at_beginning_of_statement (true),
       looking_at_anon_fcn_args (false), looking_at_return_list (false),
       looking_at_parameter_list (false), looking_at_decl_list (false),
       looking_at_initializer_expression (false),
       looking_at_matrix_or_assign_lhs (false),
       looking_for_object_index (false), 
       looking_at_indirect_ref (false), parsing_class_method (false),
       maybe_classdef_get_set_method (false), parsing_classdef (false),
-      quote_is_transpose (false), reading_fcn_file (false),
-      reading_script_file (false), reading_classdef_file (false),
+      quote_is_transpose (false), force_script (false),
+      reading_fcn_file (false), reading_script_file (false),
+      reading_classdef_file (false),
       input_line_number (1), current_input_column (1),
       bracketflag (0), braceflag (0),
       looping (0), defining_func (0), looking_at_function_handle (0),
-      block_comment_nesting_level (0),
+      block_comment_nesting_level (0), token_count (0),
+      help_text (), fcn_file_name (), fcn_file_full_name (),
       looking_at_object_index (), parsed_function_name (),
       pending_local_variables (), nesting_level (), token_stack ()
   {
     init ();
   }
 
   ~lexical_feedback (void);
 
@@ -239,16 +241,20 @@ public:
   bool maybe_classdef_get_set_method;
 
   // true means we are parsing a classdef file
   bool parsing_classdef;
 
   // return transpose or start a string?
   bool quote_is_transpose;
 
+  // TRUE means treat the current file as a script even if the first
+  // token is "function" or "classdef".
+  bool force_script;
+
   // TRUE means we're parsing a function file.
   bool reading_fcn_file;
 
   // TRUE means we're parsing a script file.
   bool reading_script_file;
 
   // TRUE means we're parsing a classdef file.
   bool reading_classdef_file;
@@ -272,16 +278,29 @@ public:
   int defining_func;
 
   // nonzero means we are parsing a function handle.
   int looking_at_function_handle;
 
   // nestng level for blcok comments.
   int block_comment_nesting_level;
 
+  // Count of tokens recognized by this lexer since initialized or
+  // since the last reset.
+  size_t token_count;
+
+  // The current help text.
+  std::string help_text;
+
+  // Simple name of function file we are reading.
+  std::string fcn_file_name;
+
+  // Full name of file we are reading.
+  std::string fcn_file_full_name;
+
   // if the front of the list is true, the closest paren, brace, or
   // bracket nesting is an index for an object.
   std::list<bool> looking_at_object_index;
 
   // if the top of the stack is true, then we've already seen the name
   // of the current function.  should only matter if
   // current_function_level > 0
   std::stack<bool> parsed_function_name;
@@ -367,19 +386,17 @@ public:
   }
 
   ~octave_lexer (void);
 
   void init (void);
 
   void reset (void);
 
-  void prep_for_script_file (void);
-
-  void prep_for_function_file (void);
+  void prep_for_file (void);
 
   int read (char *buf, unsigned int max_size);
 
   int handle_end_of_input (void);
 
   char *flex_yytext (void);
 
   int flex_yyleng (void);
@@ -475,16 +492,26 @@ public:
 
   octave_input_reader input_reader;
 
   std::string input_source (void) const
   {
     return input_reader.input_source ();
   }
 
+  bool input_from_terminal (void) const
+  {
+    return input_source () == "terminal";
+  }
+
+  bool input_from_file (void) const
+  {
+    return input_source () == "file";
+  }
+
   bool input_from_eval_string (void) const
   {
     return input_source () == "eval_string";
   }
 
   // For unwind protect.
   static void cleanup (octave_lexer *lexer) { delete lexer; }
 
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -41,18 +41,17 @@ object) relevant global values before an
 #include <config.h>
 #endif
 
 }
 
 %s COMMAND_START
 %s MATRIX_START
 
-%x SCRIPT_FILE_BEGIN
-%x FUNCTION_FILE_BEGIN
+%x INPUT_FILE_BEGIN
 
 %{
 
 #include <cctype>
 #include <cstring>
 
 #include <iostream>
 #include <set>
@@ -142,17 +141,21 @@ object) relevant global values before an
         } \
       return tok_val; \
     } \
   while (0)
 
 #define COUNT_TOK_AND_RETURN(tok) \
   do \
     { \
-      Vtoken_count++; \
+      if (tok != '\n') \
+        { \
+          Vtoken_count++; \
+          curr_lexer->token_count++; \
+        } \
       DISPLAY_TOK_AND_RETURN (tok); \
     } \
   while (0)
 
 #define TOK_RETURN(tok) \
   do \
     { \
       curr_lexer->current_input_column += yyleng; \
@@ -251,30 +254,27 @@ EXPON   ([DdEe][+-]?{D}+)
 NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{EXPON}?)|(0[xX][0-9a-fA-F]+))
 %%
 
 %{
 // Make script and function files start with a bogus token. This makes
 // the parser go down a special path.
 %}
 
-<SCRIPT_FILE_BEGIN>. {
-    LEXER_DEBUG ("<SCRIPT_FILE_BEGIN>.");
+<INPUT_FILE_BEGIN>. {
+    LEXER_DEBUG ("<INPUT_FILE_BEGIN>.");
 
     BEGIN (INITIAL);
     curr_lexer->xunput (yytext[0]);
-    COUNT_TOK_AND_RETURN (SCRIPT_FILE);
-  }
-
-<FUNCTION_FILE_BEGIN>. {
-    LEXER_DEBUG ("<FUNCTION_FILE_BEGIN>.");
-
-    BEGIN (INITIAL);
-    curr_lexer->xunput (yytext[0]);
-    COUNT_TOK_AND_RETURN (FUNCTION_FILE);
+
+    // May be reset later if we see "function" or "classdef" appears
+    // as the first token.
+    curr_lexer->reading_script_file = true;
+
+    DISPLAY_TOK_AND_RETURN (INPUT_FILE);
   }
 
 %{
 // Help and other command-style functions.
 %}
 
 <COMMAND_START>{NL} {
     LEXER_DEBUG ("<COMMAND_START>{NL}");
@@ -1319,28 +1319,32 @@ lexical_feedback::reset (void)
   looking_at_initializer_expression = false;
   looking_at_matrix_or_assign_lhs = false;
   looking_for_object_index = false; 
   looking_at_indirect_ref = false;
   parsing_class_method = false;
   maybe_classdef_get_set_method = false;
   parsing_classdef = false;
   quote_is_transpose = false;
+  force_script = false;
   reading_fcn_file = false;
   reading_script_file = false;
   reading_classdef_file = false;
   input_line_number = 1;
   current_input_column = 1;
   bracketflag = 0;
   braceflag = 0;
   looping = 0;
   defining_func = 0;
   looking_at_function_handle = 0;
   block_comment_nesting_level = 0;
-
+  token_count = 0;
+  help_text = "";
+  fcn_file_name = "";
+  fcn_file_full_name = "";
   looking_at_object_index.clear ();
   looking_at_object_index.push_front (false);
 
   while (! parsed_function_name.empty ())
     parsed_function_name.pop ();
 
   pending_local_variables.clear ();
 
@@ -1446,41 +1450,30 @@ octave_lexer::reset (void)
   // Only ask for input from stdin if we are expecting interactive
   // input.
 
   if (! quitting_gracefully
       && (interactive || forced_interactive)
       && ! (reading_fcn_file
             || reading_classdef_file
             || reading_script_file
-            || input_from_eval_string ()
-            || input_from_startup_file))
+            || input_from_eval_string ()))
     yyrestart (stdin, scanner);
 
-  // Clear the buffer for help text.
-  while (! help_buf.empty ())
-    help_buf.pop ();
-
   lexical_feedback::reset ();
 }
 
 void
-octave_lexer::prep_for_script_file (void)
+octave_lexer::prep_for_file (void)
 {
   OCTAVE_YYG;
 
-  BEGIN (SCRIPT_FILE_BEGIN);
-}
-
-void
-octave_lexer::prep_for_function_file (void)
-{
-  OCTAVE_YYG;
-
-  BEGIN (FUNCTION_FILE_BEGIN);
+  reading_script_file = true;
+
+  BEGIN (INPUT_FILE_BEGIN);
 }
 
 int
 octave_lexer::read (char *buf, unsigned max_size)
 {
   int status = 0;
 
   if (input_buf.empty ())
@@ -1512,19 +1505,19 @@ octave_lexer::handle_end_of_input (void)
 
   LEXER_DEBUG ("<<EOF>>");
 
   if (block_comment_nesting_level != 0)
     {
       warning ("block comment open at end of input");
 
       if ((reading_fcn_file || reading_script_file || reading_classdef_file)
-          && ! curr_fcn_file_name.empty ())
+          && ! fcn_file_name.empty ())
         warning ("near line %d of file '%s.m'",
-                 input_line_number, curr_fcn_file_name.c_str ());
+                 input_line_number, fcn_file_name.c_str ());
     }
 
   TOK_RETURN (END_OF_INPUT);
 }
 
 char *
 octave_lexer::flex_yytext (void)
 {
@@ -1686,21 +1679,21 @@ octave_lexer::is_keyword_token (const st
         case return_kw:
         case unwind_protect_cleanup_kw:
           at_beginning_of_statement = true;
           break;
 
         case static_kw:
           if ((reading_fcn_file || reading_script_file
                || reading_classdef_file)
-              && ! curr_fcn_file_full_name.empty ())
+              && ! fcn_file_full_name.empty ())
             warning_with_id ("Octave:deprecated-keyword",
                              "the 'static' keyword is obsolete and will be removed from a future version of Octave; please use 'persistent' instead; near line %d of file '%s'",
                              input_line_number,
-                             curr_fcn_file_full_name.c_str ());
+                             fcn_file_full_name.c_str ());
           else
             warning_with_id ("Octave:deprecated-keyword",
                              "the 'static' keyword is obsolete and will be removed from a future version of Octave; please use 'persistent' instead; near line %d",
                              input_line_number);
           // fall through ...
 
         case persistent_kw:
           break;
@@ -1829,35 +1822,47 @@ octave_lexer::is_keyword_token (const st
           // classdef blocks.
           if (! parsing_classdef)
             return 0;
           // fall through ...
 
         case classdef_kw:
           // 'classdef' is always a keyword.
           promptflag--;
+
+          if (! force_script && token_count == 0 && input_from_file ())
+            {
+              reading_classdef_file = true;
+              reading_script_file = false;
+            }
           break;
 
         case function_kw:
           promptflag--;
 
           defining_func++;
           parsed_function_name.push (false);
 
+          if (! force_script && token_count == 0 && input_from_file ())
+            {
+              reading_fcn_file = true;
+              reading_script_file = false;
+            }
+
           if (! (reading_fcn_file || reading_script_file
                  || reading_classdef_file))
             input_line_number = 1;
           break;
 
         case magic_file_kw:
           {
             if ((reading_fcn_file || reading_script_file
                  || reading_classdef_file)
-                && ! curr_fcn_file_full_name.empty ())
-              tok_val = new token (curr_fcn_file_full_name, l, c);
+                && ! fcn_file_full_name.empty ())
+              tok_val = new token (fcn_file_full_name, l, c);
             else
               tok_val = new token ("stdin", l, c);
           }
           break;
 
         case magic_line_kw:
           tok_val = new token (static_cast<double> (l), "", l, c);
           break;
@@ -2126,48 +2131,54 @@ octave_lexer::grab_comment_block (stream
  done:
 
   if (c == EOF)
     eof = true;
 
   return buf;
 }
 
+static bool
+looks_like_copyright (const std::string& s)
+{
+  bool retval = false;
+
+  if (! s.empty ())
+    {
+      size_t offset = s.find_first_not_of (" \t");
+
+      retval = (s.substr (offset, 9) == "Copyright" || s.substr (offset, 6) == "Author");
+    }
+
+  return retval;
+}
+
 int
 octave_lexer::process_comment (bool start_in_block, bool& eof)
 {
   OCTAVE_YYG;
 
   eof = false;
 
-  std::string help_txt;
-
-  if (! help_buf.empty ())
-    help_txt = help_buf.top ();
-
   char *yytxt = flex_yytext ();
   flex_stream_reader flex_reader (this, yytxt);
 
   // process_comment is only supposed to be called when we are not
   // initially looking at a block comment.
 
   std::string txt = start_in_block
     ? grab_block_comment (flex_reader, eof)
     : grab_comment_block (flex_reader, false, eof);
 
   if (lexer_debug_flag)
     std::cerr << "C: " << txt << std::endl;
 
-  if (help_txt.empty () && nesting_level.none ())
-    {
-      if (! help_buf.empty ())
-        help_buf.pop ();
-
-      help_buf.push (txt);
-    }
+  if (nesting_level.none () && help_text.empty () && ! txt.empty ()
+      && ! looks_like_copyright (txt))
+    help_text = txt;
 
   octave_comment_buffer::append (txt);
 
   current_input_column = 1;
   quote_is_transpose = false;
   convert_spaces_to_comma = true;
   at_beginning_of_statement = true;
 
@@ -3508,47 +3519,47 @@ octave_lexer::handle_identifier (void)
     looking_for_object_index = true;
 
   return NAME;
 }
 
 void
 octave_lexer::maybe_warn_separator_insert (char sep)
 {
-  std::string nm = curr_fcn_file_full_name;
+  std::string nm = fcn_file_full_name;
 
   if (nm.empty ())
     warning_with_id ("Octave:separator-insert",
                      "potential auto-insertion of '%c' near line %d",
                      sep, input_line_number);
   else
     warning_with_id ("Octave:separator-insert",
                      "potential auto-insertion of '%c' near line %d of file %s",
                      sep, input_line_number, nm.c_str ());
 }
 
 void
 octave_lexer::gripe_single_quote_string (void)
 {
-  std::string nm = curr_fcn_file_full_name;
+  std::string nm = fcn_file_full_name;
 
   if (nm.empty ())
     warning_with_id ("Octave:single-quote-string",
                      "single quote delimited string near line %d",
                      input_line_number);
   else
     warning_with_id ("Octave:single-quote-string",
                      "single quote delimited string near line %d of file %s",
                      input_line_number, nm.c_str ());
 }
 
 void
 octave_lexer::gripe_matlab_incompatible (const std::string& msg)
 {
-  std::string nm = curr_fcn_file_full_name;
+  std::string nm = fcn_file_full_name;
 
   if (nm.empty ())
     warning_with_id ("Octave:matlab-incompatible",
                      "potential Matlab compatibility problem: %s",
                      msg.c_str ());
   else
     warning_with_id ("Octave:matlab-incompatible",
                      "potential Matlab compatibility problem: %s near line %d offile %s",
@@ -3702,18 +3713,17 @@ octave_lexer::display_token (int tok)
     case CATCH: std::cerr << "CATCH\n"; break;
     case GLOBAL: std::cerr << "GLOBAL\n"; break;
     case PERSISTENT: std::cerr << "PERSISTENT\n"; break;
     case FCN_HANDLE: std::cerr << "FCN_HANDLE\n"; break;
     case END_OF_INPUT: std::cerr << "END_OF_INPUT\n\n"; break;
     case LEXICAL_ERROR: std::cerr << "LEXICAL_ERROR\n\n"; break;
     case FCN: std::cerr << "FCN\n"; break;
     case CLOSE_BRACE: std::cerr << "CLOSE_BRACE\n"; break;
-    case SCRIPT_FILE: std::cerr << "SCRIPT_FILE\n"; break;
-    case FUNCTION_FILE: std::cerr << "FUNCTION_FILE\n"; break;
+    case INPUT_FILE: std::cerr << "INPUT_FILE\n"; break;
     case SUPERCLASSREF: std::cerr << "SUPERCLASSREF\n"; break;
     case METAQUERY: std::cerr << "METAQUERY\n"; break;
     case GET: std::cerr << "GET\n"; break;
     case SET: std::cerr << "SET\n"; break;
     case PROPERTIES: std::cerr << "PROPERTIES\n"; break;
     case METHODS: std::cerr << "METHODS\n"; break;
     case EVENTS: std::cerr << "EVENTS\n"; break;
     case CLASSDEF: std::cerr << "CLASSDEF\n"; break;
@@ -3745,22 +3755,18 @@ display_state (int state)
     case COMMAND_START:
       std::cerr << "COMMAND_START" << std::endl;
       break;
 
     case MATRIX_START:
       std::cerr << "MATRIX_START" << std::endl;
       break;
 
-    case SCRIPT_FILE_BEGIN:
-      std::cerr << "SCRIPT_FILE_BEGIN" << std::endl;
-      break;
-
-    case FUNCTION_FILE_BEGIN:
-      std::cerr << "FUNCTION_FILE_BEGIN" << std::endl;
+    case INPUT_FILE_BEGIN:
+      std::cerr << "INPUT_FILE_BEGIN" << std::endl;
       break;
 
     default:
       std::cerr << "UNKNOWN START STATE!" << std::endl;
       break;
     }
 }
 
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -90,29 +90,23 @@ octave_lexer *CURR_LEXER = 0;
 // Calls to the following functions appear in the generated output from
 // Bison without the namespace tag.  Redefine them so we will use them
 // via the gnulib namespace.
 #define fclose GNULIB_NAMESPACE::fclose
 #define fprintf GNULIB_NAMESPACE::fprintf
 #define malloc GNULIB_NAMESPACE::malloc
 #endif
 
-// Buffer for help text snagged from function files.
-std::stack<std::string> help_buf;
-
 // TRUE means we are using readline.
 // (--no-line-editing)
 bool line_editing = true;
 
 // TRUE means we printed messages about reading startup files.
 bool reading_startup_message_printed = false;
 
-// TRUE means input is coming from startup file.
-bool input_from_startup_file = false;
-
 // Keep track of symbol table information when parsing functions.
 symtab_context parser_symtab_context;
 
 // List of autoloads (function -> file mapping).
 static std::map<std::string, std::string> autoload_map;
 
 // Forward declarations for some functions defined at the bottom of
 // the file.
@@ -233,24 +227,24 @@ make_statement (T *arg)
 %token <tok_val> FCN_HANDLE
 %token <tok_val> PROPERTIES METHODS EVENTS ENUMERATION
 %token <tok_val> METAQUERY
 %token <tok_val> SUPERCLASSREF
 %token <tok_val> GET SET
 
 // Other tokens.
 %token END_OF_INPUT LEXICAL_ERROR
-%token FCN SCRIPT_FILE FUNCTION_FILE CLASSDEF
+%token FCN INPUT_FILE CLASSDEF
 // %token VARARGIN VARARGOUT
 %token CLOSE_BRACE
 
 // Nonterminals we construct.
 %type <comment_type> stash_comment function_beg classdef_beg
 %type <comment_type> properties_beg methods_beg events_beg enum_beg
-%type <sep_type> sep_no_nl opt_sep_no_nl sep opt_sep opt_comma
+%type <sep_type> sep_no_nl opt_sep_no_nl nl opt_nl sep opt_sep opt_comma
 %type <tree_type> input
 %type <tree_constant_type> string constant magic_colon
 %type <tree_anon_fcn_handle_type> anon_fcn_handle
 %type <tree_fcn_handle_type> fcn_handle
 %type <tree_matrix_type> matrix_rows matrix_rows1
 %type <tree_cell_type> cell_rows cell_rows1
 %type <tree_expression_type> matrix cell
 %type <tree_expression_type> primary_expr oper_expr
@@ -262,18 +256,17 @@ make_statement (T *arg)
 %type <tree_colon_expression_type> colon_expr1
 %type <tree_argument_list_type> arg_list word_list assign_lhs
 %type <tree_argument_list_type> cell_or_matrix_row
 %type <tree_parameter_list_type> param_list param_list1 param_list2
 %type <tree_parameter_list_type> return_list return_list1
 %type <tree_parameter_list_type> superclasses opt_superclasses
 %type <tree_command_type> command select_command loop_command
 %type <tree_command_type> jump_command except_command function
-%type <tree_command_type> script_file classdef
-%type <tree_command_type> function_file function_list
+%type <tree_command_type> file classdef
 %type <tree_if_command_type> if_command
 %type <tree_if_clause_type> elseif_clause else_clause
 %type <tree_if_command_list_type> if_cmd_list1 if_cmd_list
 %type <tree_switch_command_type> switch_command
 %type <tree_switch_case_type> switch_case default_case
 %type <tree_switch_case_list_type> case_list1 case_list
 %type <tree_decl_elt_type> decl2
 %type <tree_decl_init_list_type> decl1
@@ -324,18 +317,16 @@ make_statement (T *arg)
 // ==============================
 
 input           : input1
                   {
                     curr_parser.stmt_list = $1;
                     promptflag = 1;
                     YYACCEPT;
                   }
-                | function_file
-                  { YYACCEPT; }
                 | simple_list parse_error
                   { ABORT_PARSE; }
                 | parse_error
                   { ABORT_PARSE; }
                 ;
 
 input1          : '\n'
                   { $$ = 0; }
@@ -756,17 +747,17 @@ command         : declaration
                 | loop_command
                   { $$ = $1; }
                 | jump_command
                   { $$ = $1; }
                 | except_command
                   { $$ = $1; }
                 | function
                   { $$ = $1; }
-                | script_file
+                | file
                   { $$ = $1; }
                 | classdef
                   { $$ = $1; }
                 ;
 
 // =====================
 // Declaration statemnts
 // =====================
@@ -839,30 +830,30 @@ if_cmd_list     : if_cmd_list1
                   {
                     $1->append ($2);
                     $$ = $1;
                   }
                 ;
 
 if_cmd_list1    : expression opt_sep opt_list
                   {
-                    $1->mark_braindead_shortcircuit (curr_fcn_file_full_name);
+                    $1->mark_braindead_shortcircuit (curr_lexer->fcn_file_full_name);
 
                     $$ = curr_parser.start_if_command ($1, $3);
                   }
                 | if_cmd_list1 elseif_clause
                   {
                     $1->append ($2);
                     $$ = $1;
                   }
                 ;
 
 elseif_clause   : ELSEIF stash_comment opt_sep expression opt_sep opt_list
                   {
-                    $4->mark_braindead_shortcircuit (curr_fcn_file_full_name);
+                    $4->mark_braindead_shortcircuit (curr_lexer->fcn_file_full_name);
 
                     $$ = curr_parser.make_elseif_clause ($1, $4, $6, $2);
                   }
                 ;
 
 else_clause     : ELSE stash_comment opt_sep opt_list
                   { $$ = new tree_if_clause ($4, $2); }
                 ;
@@ -911,17 +902,17 @@ default_case    : OTHERWISE stash_commen
                 ;
 
 // =======
 // Looping
 // =======
 
 loop_command    : WHILE stash_comment expression opt_sep opt_list END
                   {
-                    $3->mark_braindead_shortcircuit (curr_fcn_file_full_name);
+                    $3->mark_braindead_shortcircuit (curr_lexer->fcn_file_full_name);
 
                     if (! ($$ = curr_parser.make_while_command ($1, $3, $5, $6, $2)))
                       ABORT_PARSE;
                   }
                 | DO stash_comment opt_sep opt_list UNTIL expression
                   {
                     if (! ($$ = curr_parser.make_do_until_command ($5, $4, $6, $2)))
                       ABORT_PARSE;
@@ -1008,21 +999,23 @@ push_fcn_symtab : // empty
                       curr_parser.max_fcn_depth = curr_parser.curr_fcn_depth;
 
                     parser_symtab_context.push ();
 
                     symbol_table::set_scope (symbol_table::alloc_scope ());
 
                     curr_parser.function_scopes.push_back (symbol_table::current_scope ());
 
-                    if (! curr_lexer->reading_script_file && curr_parser.curr_fcn_depth == 1
+                    if (! curr_lexer->reading_script_file
+                        && curr_parser.curr_fcn_depth == 1
                         && ! curr_parser.parsing_subfunctions)
                       curr_parser.primary_fcn_scope = symbol_table::current_scope ();
 
-                    if (curr_lexer->reading_script_file && curr_parser.curr_fcn_depth > 1)
+                    if (curr_lexer->reading_script_file
+                        && curr_parser.curr_fcn_depth > 1)
                       curr_parser.bison_error ("nested functions not implemented in this context");
                   }
                 ;
 
 // ===========================
 // List of function parameters
 // ===========================
 
@@ -1112,54 +1105,45 @@ return_list1    : identifier
                   { $$ = new tree_parameter_list (new tree_decl_elt ($1)); }
                 | return_list1 ',' identifier
                   {
                     $1->append (new tree_decl_elt ($3));
                     $$ = $1;
                   }
                 ;
 
-// ===========
-// Script file
-// ===========
-
-script_file     : SCRIPT_FILE opt_list END_OF_INPUT
+// =======================
+// Script or function file
+// =======================
+
+file            : INPUT_FILE opt_nl opt_list END_OF_INPUT
                   {
-                    tree_statement *end_of_script
-                      = curr_parser.make_end ("endscript",
-                                               curr_lexer->input_line_number,
-                                               curr_lexer->current_input_column);
-
-                    curr_parser.make_script ($2, end_of_script);
+                    if (! curr_lexer->reading_fcn_file)
+                      {
+                        tree_statement *end_of_script
+                          = curr_parser.make_end ("endscript",
+                                                  curr_lexer->input_line_number,
+                                                  curr_lexer->current_input_column);
+
+                        curr_parser.make_script ($3, end_of_script);
+                      }
 
                     $$ = 0;
                   }
                 ;
 
-// =============
-// Function file
-// =============
-
-function_file   : FUNCTION_FILE function_list opt_sep END_OF_INPUT
-                  { $$ = 0; }
-                ;
-
-function_list   : function
-                | function_list sep function
-                ;
-
 // ===================
 // Function definition
 // ===================
 
 function_beg    : push_fcn_symtab FCN stash_comment
                   {
                     $$ = $3;
-
-                    if (curr_lexer->reading_classdef_file || curr_lexer->parsing_classdef)
+                    if (curr_lexer->reading_classdef_file
+                        || curr_lexer->parsing_classdef)
                       curr_lexer->maybe_classdef_get_set_method = true;
                   }
                 ;
 
 function        : function_beg function1
                   {
                     $$ = curr_parser.finish_function (0, $2, $1);
                     curr_parser.recover_from_parsing_function ();
@@ -1436,16 +1420,28 @@ sep_no_nl       : ','
                 ;
 
 opt_sep_no_nl   : // empty
                   { $$ = 0; }
                 | sep_no_nl
                   { $$ = $1; }
                 ;
 
+opt_nl          : // empty
+                  { $$ = 0; }
+                | nl
+                  { $$ = $1; }
+                ;
+
+nl              : '\n'
+                  { $$ = '\n'; }
+                | nl '\n'
+                  { $$ = $1; }
+                ;
+
 sep             : ','
                   { $$ = ','; }
                 | ';'
                   { $$ = ';'; }
                 | '\n'
                   { $$ = '\n'; }
                 | sep ','
                   { $$ = $1; }
@@ -1662,43 +1658,43 @@ octave_parser::end_token_ok (token *tok,
 // test in a logical expression.
 
 void
 octave_parser::maybe_warn_assign_as_truth_value (tree_expression *expr)
 {
   if (expr->is_assignment_expression ()
       && expr->paren_count () < 2)
     {
-      if (curr_fcn_file_full_name.empty ())
+      if (curr_lexer->fcn_file_full_name.empty ())
         warning_with_id
           ("Octave:assign-as-truth-value",
            "suggest parenthesis around assignment used as truth value");
       else
         warning_with_id
           ("Octave:assign-as-truth-value",
            "suggest parenthesis around assignment used as truth value near line %d, column %d in file '%s'",
-           expr->line (), expr->column (), curr_fcn_file_full_name.c_str ());
+           expr->line (), expr->column (), curr_lexer->fcn_file_full_name.c_str ());
     }
 }
 
 // Maybe print a warning about switch labels that aren't constants.
 
 void
 octave_parser::maybe_warn_variable_switch_label (tree_expression *expr)
 {
   if (! expr->is_constant ())
     {
-      if (curr_fcn_file_full_name.empty ())
+      if (curr_lexer->fcn_file_full_name.empty ())
         warning_with_id ("Octave:variable-switch-label",
                          "variable switch label");
       else
         warning_with_id
           ("Octave:variable-switch-label",
            "variable switch label near line %d, column %d in file '%s'",
-           expr->line (), expr->column (), curr_fcn_file_full_name.c_str ());
+           expr->line (), expr->column (), curr_lexer->fcn_file_full_name.c_str ());
     }
 }
 
 static tree_expression *
 fold (tree_binary_expression *e)
 {
   tree_expression *retval = e;
 
@@ -1950,17 +1946,17 @@ octave_parser::make_anon_fcn_handle (tre
   tree_statement_list *body = new tree_statement_list (stmt);
 
   body->mark_as_anon_function_body ();
 
   tree_anon_fcn_handle *retval
     = new tree_anon_fcn_handle (param_list, ret_list, body, fcn_scope, l, c);
   // FIXME: Stash the filename.  This does not work and produces
   // errors when executed.
-  //retval->stash_file_name (curr_fcn_file_name);
+  //retval->stash_file_name (curr_lexer->fcn_file_name);
 
   return retval;
 }
 
 // Build a binary expression.
 
 tree_expression *
 octave_parser::make_binary_op (int op, tree_expression *op1, token *tok_val,
@@ -2574,32 +2570,27 @@ octave_parser::make_assign_op (int op, t
 }
 
 // Define a script.
 
 void
 octave_parser::make_script (tree_statement_list *cmds,
                             tree_statement *end_script)
 {
-  std::string doc_string;
-
-  if (! help_buf.empty ())
-    {
-      doc_string = help_buf.top ();
-      help_buf.pop ();
-    }
-
   if (! cmds)
     cmds = new tree_statement_list ();
 
   cmds->append (end_script);
 
   octave_user_script *script
-    = new octave_user_script (curr_fcn_file_full_name, curr_fcn_file_name,
-                              cmds, doc_string);
+    = new octave_user_script (curr_lexer->fcn_file_full_name,
+                              curr_lexer->fcn_file_name,
+                              cmds, curr_lexer->help_text);
+
+  curr_lexer->help_text = "";
 
   octave_time now;
 
   script->stash_fcn_file_time (now);
 
   primary_fcn_ptr = script;
 
   // Unmark any symbols that may have been tagged as local variables
@@ -2652,52 +2643,52 @@ octave_parser::frob_function (const std:
 
   // If input is coming from a file, issue a warning if the name of
   // the file does not match the name of the function stated in the
   // file.  Matlab doesn't provide a diagnostic (it ignores the stated
   // name).
   if (! autoloading && curr_lexer->reading_fcn_file
       && curr_fcn_depth == 1 && ! parsing_subfunctions)
   {
-    // FIXME -- should curr_fcn_file_name already be
+    // FIXME -- should curr_lexer->fcn_file_name already be
     // preprocessed when we get here?  It seems to only be a
     // problem with relative file names.
 
-    std::string nm = curr_fcn_file_name;
+    std::string nm = curr_lexer->fcn_file_name;
 
     size_t pos = nm.find_last_of (file_ops::dir_sep_chars ());
 
     if (pos != std::string::npos)
-      nm = curr_fcn_file_name.substr (pos+1);
+      nm = curr_lexer->fcn_file_name.substr (pos+1);
 
     if (nm != id_name)
       {
         warning_with_id
           ("Octave:function-name-clash",
            "function name '%s' does not agree with function file name '%s'",
-           id_name.c_str (), curr_fcn_file_full_name.c_str ());
+           id_name.c_str (), curr_lexer->fcn_file_full_name.c_str ());
 
         id_name = nm;
       }
   }
 
   if (curr_lexer->reading_fcn_file || curr_lexer->reading_classdef_file || autoloading)
     {
       octave_time now;
 
-      fcn->stash_fcn_file_name (curr_fcn_file_full_name);
+      fcn->stash_fcn_file_name (curr_lexer->fcn_file_full_name);
       fcn->stash_fcn_file_time (now);
       fcn->mark_as_system_fcn_file ();
 
       if (fcn_file_from_relative_lookup)
         fcn->mark_relative ();
 
       if (curr_fcn_depth > 1 || parsing_subfunctions)
         {
-          fcn->stash_parent_fcn_name (curr_fcn_file_name);
+          fcn->stash_parent_fcn_name (curr_lexer->fcn_file_name);
 
           if (curr_fcn_depth > 1)
             fcn->stash_parent_fcn_scope (function_scopes[function_scopes.size ()-2]);
           else
             fcn->stash_parent_fcn_scope (primary_fcn_scope);
         }
 
       if (curr_lexer->parsing_class_method)
@@ -2713,34 +2704,35 @@ octave_parser::frob_function (const std:
       std::string nm = fcn->fcn_file_name ();
 
       file_stat fs (nm);
 
       if (fs && fs.is_newer (now))
         warning_with_id ("Octave:future-time-stamp",
                          "time stamp for '%s' is in the future", nm.c_str ());
     }
-  else if (! (input_from_tmp_history_file || input_from_startup_file)
+  else if (! input_from_tmp_history_file
+           && ! curr_lexer->force_script
            && curr_lexer->reading_script_file
-           && curr_fcn_file_name == id_name)
+           && curr_lexer->fcn_file_name == id_name)
     {
       warning ("function '%s' defined within script file '%s'",
-               id_name.c_str (), curr_fcn_file_full_name.c_str ());
+               id_name.c_str (), curr_lexer->fcn_file_full_name.c_str ());
     }
 
   fcn->stash_function_name (id_name);
   fcn->stash_fcn_location (curr_lexer->input_line_number,
                            curr_lexer->current_input_column);
 
-  if (! help_buf.empty () && curr_fcn_depth == 1
+  if (! curr_lexer->help_text.empty () && curr_fcn_depth == 1
       && ! parsing_subfunctions)
     {
-      fcn->document (help_buf.top ());
-
-      help_buf.pop ();
+      fcn->document (curr_lexer->help_text);
+
+      curr_lexer->help_text = "";
     }
 
   if (curr_lexer->reading_fcn_file && curr_fcn_depth == 1
       && ! parsing_subfunctions)
     primary_fcn_ptr = fcn;
 
   return fcn;
 }
@@ -2942,17 +2934,17 @@ octave_parser::make_decl_command (int to
 
     case PERSISTENT:
       if (curr_fcn_depth > 0)
         retval = new tree_persistent_command (lst, l, c);
       else
         {
           if (curr_lexer->reading_script_file)
             warning ("ignoring persistent declaration near line %d of file '%s'",
-                     l, curr_fcn_file_full_name.c_str ());
+                     l, curr_lexer->fcn_file_full_name.c_str ());
           else
             warning ("ignoring persistent declaration near line %d", l);
         }
       break;
 
     default:
       panic_impossible ();
       break;
@@ -3027,17 +3019,17 @@ octave_parser::maybe_warn_missing_semi (
   if (curr_fcn_depth > 0)
     {
       tree_statement *tmp = t->back ();
 
       if (tmp->is_expression ())
         warning_with_id
           ("Octave:missing-semicolon",
            "missing semicolon near line %d, column %d in file '%s'",
-            tmp->line (), tmp->column (), curr_fcn_file_full_name.c_str ());
+            tmp->line (), tmp->column (), curr_lexer->fcn_file_full_name.c_str ());
     }
 }
 
 tree_statement_list *
 octave_parser::set_stmt_print_flag (tree_statement_list *list, char sep,
                                     bool warn_missing_semi)
 {
   tree_statement *tmp = list->back ();
@@ -3095,17 +3087,17 @@ void
 octave_parser::bison_error (const char *s)
 {
   int err_col = curr_lexer->current_input_column - 1;
 
   std::ostringstream output_buf;
 
   if (curr_lexer->reading_fcn_file || curr_lexer->reading_script_file || curr_lexer->reading_classdef_file)
     output_buf << "parse error near line " << curr_lexer->input_line_number
-               << " of file " << curr_fcn_file_full_name;
+               << " of file " << curr_lexer->fcn_file_full_name;
   else
     output_buf << "parse error:";
 
   if (s && strcmp (s, "parse error") != 0)
     output_buf << "\n\n  " << s;
 
   output_buf << "\n\n";
 
@@ -3147,226 +3139,19 @@ safe_fclose (FILE *f)
   octave_comment_list *tc = octave_comment_buffer::get_comment ();
 
   delete tc;
 
   if (f)
     fclose (static_cast<FILE *> (f));
 }
 
-static bool
-looks_like_copyright (const std::string& s)
-{
-  bool retval = false;
-
-  if (! s.empty ())
-    {
-      size_t offset = s.find_first_not_of (" \t");
-
-      retval = (s.substr (offset, 9) == "Copyright" || s.substr (offset, 6) == "Author");
-    }
-
-  return retval;
-}
-
-static int
-text_getc (FILE *f)
-{
-  int c = gnulib::getc (f);
-
-  // Convert CRLF into just LF and single CR into LF.
-
-  if (c == '\r')
-    {
-      c = gnulib::getc (f);
-
-      if (c != '\n')
-        {
-          ungetc (c, f);
-          c = '\n';
-        }
-    }
-
-  return c;
-}
-
-class
-stdio_stream_reader : public stream_reader
-{
-public:
-
-  stdio_stream_reader (FILE *f_arg, int& l, int& c)
-    : stream_reader (), f (f_arg), line_num (l), column_num (c)
-  { }
-
-  int getc (void)
-  {
-    char c = ::text_getc (f);
-
-    if (c == '\n')
-      {
-        line_num++;
-        column_num = 0;
-      }
-    else
-      {
-        // FIXME -- try to be smarter about tabs?
-        column_num++;
-      }
-        
-    return c;
-  }
-
-  int ungetc (int c)
-  {
-    if (c == '\n')
-      {   
-        line_num--;
-        column_num = 0;
-      }
-    else
-      {
-        // FIXME -- try to be smarter about tabs?
-        column_num--;
-      }
-
-    return ::ungetc (c, f);
-  }
-
-private:
-
-  FILE *f;
-
-  int& line_num;
-
-  int& column_num;
-
-  // No copying!
-
-  stdio_stream_reader (const  stdio_stream_reader&);
-
-  stdio_stream_reader & operator = (const  stdio_stream_reader&);
-};
-
-static bool
-skip_white_space (stream_reader& reader)
-{
-  int c = 0;
-
-  while ((c = reader.getc ()) != EOF)
-    {
-      switch (c)
-        {
-        case ' ':
-        case '\t':
-        case '\n':
-          break;
-
-        default:
-          reader.ungetc (c);
-          goto done;
-        }
-    }
-
- done:
-
-  return (c == EOF);
-}
-
-static bool
-looking_at_classdef_keyword (FILE *ffile)
-{
-  bool status = false;
-
-  long pos = gnulib::ftell (ffile);
-
-  char buf [10];
-  gnulib::fgets (buf, 10, ffile);
-  size_t len = strlen (buf);
-  if (len > 8 && strncmp (buf, "classdef", 8) == 0
-      && ! (isalnum (buf[8]) || buf[8] == '_'))
-    status = true;
-
-  gnulib::fseek (ffile, pos, SEEK_SET);
-
-  return status;
- }
-
-static std::string
-gobble_leading_white_space (FILE *ffile, bool& eof, int& line_num,
-                            int& column_num)
-{
-  std::string help_txt;
-
-  eof = false;
-
-  // TRUE means we have already cached the help text.
-  bool have_help_text = false;
-
-  std::string txt;
-
-  stdio_stream_reader stdio_reader (ffile, line_num, column_num);
-
-  while (true)
-    {
-      eof = skip_white_space (stdio_reader);
-
-      if (eof)
-        break;
-
-      txt = CURR_LEXER->grab_comment_block (stdio_reader, true, eof);
-
-      if (txt.empty ())
-        break;
-
-      if (! (have_help_text || looks_like_copyright (txt)))
-        {
-          help_txt = txt;
-          have_help_text = true;
-        }
-
-      octave_comment_buffer::append (txt);
-
-      if (eof)
-        break;
-    }
-
-  return help_txt;
-}
-
-static std::string
-gobble_leading_white_space (FILE *ffile, bool& eof)
-{
-  int line_num = 1;
-  int column_num = 1;
-
-  return gobble_leading_white_space (ffile, eof, line_num, column_num);
-}
-
-static bool
-looking_at_function_keyword (FILE *ffile)
-{
-  bool status = false;
-
-  long pos = gnulib::ftell (ffile);
-
-  char buf [10];
-  gnulib::fgets (buf, 10, ffile);
-  size_t len = strlen (buf);
-  if (len > 8 && strncmp (buf, "function", 8) == 0
-      && ! (isalnum (buf[8]) || buf[8] == '_'))
-    status = true;
-
-  gnulib::fseek (ffile, pos, SEEK_SET);
-
-  return status;
-}
-
 static octave_function *
-parse_fcn_file (const std::string& ff, const std::string& dispatch_type,
+parse_fcn_file (const std::string& full_file, const std::string& file,
+                const std::string& dispatch_type,
                 bool require_file, bool force_script, bool autoload,    
                 bool relative_lookup, const std::string& warn_for)
 {
   unwind_protect frame;
 
   octave_function *fcn_ptr = 0;
 
   // Open function file and parse.
@@ -3381,161 +3166,99 @@ parse_fcn_file (const std::string& ff, c
 
   frame.add_fcn (command_history::ignore_entries,
                  command_history::ignoring_entries ());
 
   command_history::ignore_entries ();
 
   FILE *ffile = 0;
 
-  if (! ff.empty ())
-    ffile = gnulib::fopen (ff.c_str (), "rb");
+  if (! full_file.empty ())
+    ffile = gnulib::fopen (full_file.c_str (), "rb");
 
   frame.add_fcn (safe_fclose, ffile);
 
   if (ffile)
     {
       bool eof;
 
       // octave_parser constructor sets this for us.
       frame.protect_var (CURR_LEXER);
 
       octave_parser curr_parser (ffile);
 
-      curr_parser.curr_lexer->reading_fcn_file = true;
-
       curr_parser.curr_class_name = dispatch_type;
       curr_parser.autoloading = autoload;
       curr_parser.fcn_file_from_relative_lookup = relative_lookup;
 
-      std::string help_txt
-        = gobble_leading_white_space
-            (ffile, eof,
-             curr_parser.curr_lexer->input_line_number,
-             curr_parser.curr_lexer->current_input_column);
-
-      if (! help_txt.empty ())
-        help_buf.push (help_txt);
-
-      if (! eof)
-        {
-          std::string file_type;
-
-          frame.protect_var (Vecho_executing_commands);
-
-          Vecho_executing_commands = ECHO_OFF;
-
-          if (! force_script && looking_at_function_keyword (ffile))
-            {
-              file_type = "function";
-            }
-          else
-            {
-              curr_parser.curr_lexer->reading_fcn_file = false;
-
-              if (! force_script && looking_at_classdef_keyword (ffile))
-                {
-                  file_type = "classdef";
-
-                  curr_parser.curr_lexer->reading_classdef_file = true;
-
-                  // FIXME -- Should classdef files be handled as
-                  // scripts or separately?  Currently, without
-                  // setting up for reading script files, parsing
-                  // classdef files fails.
-                  curr_parser.curr_lexer->reading_script_file = true;
-                }
-              else
-                {
-                  file_type = "script";
-
-                  curr_parser.curr_lexer->reading_script_file = true;
-                }
-            }
-
-          // Do this with an unwind-protect cleanup function so that
-          // the forced variables will be unmarked in the event of an
-          // interrupt.
-          symbol_table::scope_id scope = symbol_table::top_scope ();
-          frame.add_fcn (symbol_table::unmark_forced_variables, scope);
-
-          if (! help_txt.empty ())
-            help_buf.push (help_txt);
-
-          if (curr_parser.curr_lexer->reading_script_file)
-            curr_parser.curr_lexer->prep_for_script_file ();
-          else
-            curr_parser.curr_lexer->prep_for_function_file ();
-
-          curr_parser.curr_lexer->parsing_class_method = ! dispatch_type.empty ();
-
-          int status = curr_parser.run ();
-
-          fcn_ptr = curr_parser.primary_fcn_ptr;
-
-          if (status != 0)
-            error ("parse error while reading %s file %s",
-                   file_type.c_str (), ff.c_str ());
-        }
-      else
-        {
-          int l = curr_parser.curr_lexer->input_line_number;
-          int c = curr_parser.curr_lexer->current_input_column;
-
-          tree_statement *end_of_script
-            = curr_parser.make_end ("endscript", l, c);
-
-          curr_parser.make_script (0, end_of_script);
-
-          fcn_ptr = curr_parser.primary_fcn_ptr;
-        }
+      // Do this with an unwind-protect cleanup function so that
+      // the forced variables will be unmarked in the event of an
+      // interrupt.
+      symbol_table::scope_id scope = symbol_table::top_scope ();
+      frame.add_fcn (symbol_table::unmark_forced_variables, scope);
+
+      curr_parser.curr_lexer->force_script = force_script;
+      curr_parser.curr_lexer->prep_for_file ();
+      curr_parser.curr_lexer->parsing_class_method = ! dispatch_type.empty ();
+
+      curr_parser.curr_lexer->fcn_file_name = file;
+      curr_parser.curr_lexer->fcn_file_full_name = full_file;
+
+      int status = curr_parser.run ();
+
+      fcn_ptr = curr_parser.primary_fcn_ptr;
+
+      if (status != 0)
+        error ("parse error while reading file %s", full_file.c_str ());
     }
   else if (require_file)
-    error ("no such file, '%s'", ff.c_str ());
+    error ("no such file, '%s'", full_file.c_str ());
   else if (! warn_for.empty ())
-    error ("%s: unable to open file '%s'", warn_for.c_str (), ff.c_str ());
+    error ("%s: unable to open file '%s'", warn_for.c_str (),
+           full_file.c_str ());
 
   return fcn_ptr;
 }
 
 std::string
 get_help_from_file (const std::string& nm, bool& symbol_found,
-                    std::string& file)
+                    std::string& full_file)
 {
   std::string retval;
 
-  file = fcn_file_in_path (nm);
+  full_file = fcn_file_in_path (nm);
+
+  std::string file = full_file;
+
+  size_t file_len = file.length ();
+
+  if ((file_len > 4 && file.substr (file_len-4) == ".oct")
+      || (file_len > 4 && file.substr (file_len-4) == ".mex")
+      || (file_len > 2 && file.substr (file_len-2) == ".m"))
+    {
+      file = octave_env::base_pathname (file);
+      file = file.substr (0, file.find_last_of ('.'));
+
+      size_t pos = file.find_last_of (file_ops::dir_sep_str ());
+      if (pos != std::string::npos)
+        file = file.substr (pos+1);
+    }
 
   if (! file.empty ())
     {
       symbol_found = true;
 
-      FILE *fptr = gnulib::fopen (file.c_str (), "r");
-
-      if (fptr)
+      octave_function *fcn
+        = parse_fcn_file (full_file, file, "", true, false, false, false, "");
+
+      if (fcn)
         {
-          unwind_protect frame;
-          frame.add_fcn (safe_fclose, fptr);
-
-          bool eof;
-          retval = gobble_leading_white_space (fptr, eof);
-
-          if (retval.empty ())
-            {
-              octave_function *fcn = parse_fcn_file (file, "", true,
-                                                     false, false,
-                                                     false, "");
-
-              if (fcn)
-                {
-                  retval = fcn->doc_string ();
-
-                  delete fcn;
-                }
-            }
+          retval = fcn->doc_string ();
+
+          delete fcn;
         }
     }
 
   return retval;
 }
 
 std::string
 get_help_from_file (const std::string& nm, bool& symbol_found)
@@ -3628,44 +3351,31 @@ load_fcn_from_file (const std::string& f
         nm = fcn_name;
 
       retval = octave_dynamic_loader::load_oct (nm, file, relative_lookup);
     }
   else if (len > 4 && file.substr (len-4, len-1) == ".mex")
     {
       // Temporarily load m-file version of mex-file, if it exists,
       // to get the help-string to use.
-      frame.protect_var (curr_fcn_file_name);
-      frame.protect_var (curr_fcn_file_full_name);
-
-      curr_fcn_file_name = nm;
-      curr_fcn_file_full_name = file.substr (0, len - 2);
 
       octave_function *tmpfcn = parse_fcn_file (file.substr (0, len - 2),
-                                                dispatch_type, false,
+                                                nm, dispatch_type, false,
                                                 autoload, autoload,
                                                 relative_lookup, "");
 
       retval = octave_dynamic_loader::load_mex (nm, file, relative_lookup);
 
       if (tmpfcn)
         retval->document (tmpfcn->doc_string ());
       delete tmpfcn;
     }
   else if (len > 2)
     {
-      // These are needed by yyparse.
-
-      frame.protect_var (curr_fcn_file_name);
-      frame.protect_var (curr_fcn_file_full_name);
-
-      curr_fcn_file_name = nm;
-      curr_fcn_file_full_name = file;
-
-      retval = parse_fcn_file (file, dispatch_type, true, autoload,
+      retval = parse_fcn_file (file, nm, dispatch_type, true, autoload,
                                autoload, relative_lookup, "");
     }
 
   if (retval)
     {
       retval->stash_dir_name (dir_name);
 
       if (retval->is_user_function ())
@@ -3825,22 +3535,16 @@ source_file (const std::string& file_nam
   static std::map<std::string, int> source_call_depth;
 
   std::string file_full_name = file_ops::tilde_expand (file_name);
 
   file_full_name = octave_env::make_absolute (file_full_name);
 
   unwind_protect frame;
 
-  frame.protect_var (curr_fcn_file_name);
-  frame.protect_var (curr_fcn_file_full_name);
-
-  curr_fcn_file_name = file_name;
-  curr_fcn_file_full_name = file_full_name;
-
   if (source_call_depth.find (file_full_name) == source_call_depth.end ())
     source_call_depth[file_full_name] = -1;
 
   frame.protect_var (source_call_depth[file_full_name]);
 
   source_call_depth[file_full_name]++;
 
   if (source_call_depth[file_full_name] >= Vmax_recursion_depth)
@@ -3859,19 +3563,19 @@ source_file (const std::string& file_nam
         error ("source: context must be \"caller\" or \"base\"");
 
       if (! error_state)
         frame.add_fcn (octave_call_stack::pop);
     }
 
   if (! error_state)
     {
-      octave_function *fcn = parse_fcn_file (file_full_name, "",
-                                             require_file, true, false,
-                                             false, warn_for);
+      octave_function *fcn = parse_fcn_file (file_full_name, file_name,
+                                             "", require_file, true,
+                                             false, false, warn_for);
 
       if (! error_state)
         {
           if (fcn && fcn->is_user_script ())
             {
               octave_value_list args;
 
               if (verbose)
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -65,28 +65,22 @@ class tree_switch_case;
 class tree_switch_case_list;
 class tree_switch_command;
 
 #include "oct-obj.h"
 
 // Nonzero means print parser debugging info (-d).
 extern int octave_debug;
 
-// Buffer for help text snagged from function files.
-extern std::stack<std::string> help_buf;
-
 // TRUE means we are using readline.
 extern bool line_editing;
 
 // TRUE means we printed messages about reading startup files.
 extern bool reading_startup_message_printed;
 
-// TRUE means input is coming from startup file.
-extern bool input_from_startup_file;
-
 extern OCTINTERP_API std::string
 get_help_from_file (const std::string& nm, bool& symbol_found,
                     std::string& file);
 
 extern OCTINTERP_API std::string
 get_help_from_file (const std::string& nm, bool& symbol_found);
 
 extern OCTINTERP_API std::string lookup_autoload (const std::string& nm);
diff --git a/libinterp/parse-tree/pt-check.cc b/libinterp/parse-tree/pt-check.cc
--- a/libinterp/parse-tree/pt-check.cc
+++ b/libinterp/parse-tree/pt-check.cc
@@ -549,13 +549,13 @@ tree_checker::visit_do_until_command (tr
 
   if (expr)
     expr->accept (*this);
 }
 
 void
 tree_checker::gripe (const std::string& msg, int line)
 {
-  if (curr_fcn_file_name.empty ())
+  if (file_name.empty ())
     error ("%s", msg.c_str ());
   else
-    error ("%s: %d: %s", curr_fcn_file_name.c_str (), line, msg.c_str ());
+    error ("%s: %d: %s", file_name.c_str (), line, msg.c_str ());
 }
diff --git a/libinterp/parse-tree/pt-check.h b/libinterp/parse-tree/pt-check.h
--- a/libinterp/parse-tree/pt-check.h
+++ b/libinterp/parse-tree/pt-check.h
@@ -30,17 +30,17 @@ class tree_decl_command;
 // How to check the semantics of the code that the parse trees represent.
 
 class
 tree_checker : public tree_walker
 {
 public:
 
   tree_checker (void)
-    : do_lvalue_check (false) { }
+    : do_lvalue_check (false), file_name () { }
 
   ~tree_checker (void) { }
 
   void visit_argument_list (tree_argument_list&);
 
   void visit_binary_expression (tree_binary_expression&);
 
   void visit_break_command (tree_break_command&);
@@ -120,16 +120,18 @@ public:
   void visit_while_command (tree_while_command&);
 
   void visit_do_until_command (tree_do_until_command&);
 
 private:
 
   bool do_lvalue_check;
 
+  std::string file_name;
+
   void do_decl_command (tree_decl_command&);
 
   void gripe (const std::string& msg, int line);
 
   // No copying!
 
   tree_checker (const tree_checker&);
 
