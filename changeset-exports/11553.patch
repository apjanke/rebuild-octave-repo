# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1295244803 28800
#      Sun Jan 16 22:13:23 2011 -0800
# Node ID 01f703952eff485cfa6ae98cd951d75ee33dcdbf
# Parent  6b6e9051ecb857cc4c736dc2f2ef1ed10c643b18
Improve docstrings for functions in DLD-FUNCTIONS directory.
Use same variable names in error() strings and in documentation.

diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -3,16 +3,41 @@ 2011-01-16  John W. Eaton  <jwe@octave.o
 	* mkgendoc: Write function name along with file name in comment.
 
 2011-01-15  Jordi GutiÃ©rrez Hermoso  <jordigh@gmail.com>
 
 	* symtab.h (do_clear_global_pattern): Reword so as to not
 	invalidate iterators when calling std::map::erase().
 	* DLD-FUNCTIONS/urwlwrite.cc (~curl_handles): Ditto.
 
+	DLD-FUNCTIONS/conv2.cc, DLD-FUNCTIONS/convhulln.cc,
+	DLD-FUNCTIONS/cquad.cc, DLD-FUNCTIONS/dasrt.cc, DLD-FUNCTIONS/det.cc,
+	DLD-FUNCTIONS/dlmread.cc, DLD-FUNCTIONS/dmperm.cc,
+	DLD-FUNCTIONS/dot.cc, DLD-FUNCTIONS/eig.cc, DLD-FUNCTIONS/eigs.cc,
+	DLD-FUNCTIONS/fft.cc, DLD-FUNCTIONS/fft2.cc, DLD-FUNCTIONS/fftn.cc,
+	DLD-FUNCTIONS/fftw.cc, DLD-FUNCTIONS/filter.cc, DLD-FUNCTIONS/find.cc,
+	DLD-FUNCTIONS/fltk_backend.cc, DLD-FUNCTIONS/gammainc.cc,
+	DLD-FUNCTIONS/gcd.cc, DLD-FUNCTIONS/getgrent.cc,
+	DLD-FUNCTIONS/getpwent.cc, DLD-FUNCTIONS/hess.cc,
+	DLD-FUNCTIONS/hex2num.cc, DLD-FUNCTIONS/inv.cc, DLD-FUNCTIONS/kron.cc,
+	DLD-FUNCTIONS/lookup.cc, DLD-FUNCTIONS/lsode.cc, DLD-FUNCTIONS/lu.cc,
+	DLD-FUNCTIONS/luinc.cc, DLD-FUNCTIONS/matrix_type.cc,
+	DLD-FUNCTIONS/max.cc, DLD-FUNCTIONS/md5sum.cc,
+	DLD-FUNCTIONS/onCleanup.cc, DLD-FUNCTIONS/pinv.cc, DLD-FUNCTIONS/qr.cc,
+	DLD-FUNCTIONS/quad.cc, DLD-FUNCTIONS/qz.cc, DLD-FUNCTIONS/rand.cc,
+	DLD-FUNCTIONS/rcond.cc, DLD-FUNCTIONS/regexp.cc,
+	DLD-FUNCTIONS/schur.cc, DLD-FUNCTIONS/spparms.cc,
+	DLD-FUNCTIONS/sqrtm.cc, DLD-FUNCTIONS/str2double.cc,
+	DLD-FUNCTIONS/strfind.cc, DLD-FUNCTIONS/sub2ind.cc,
+	DLD-FUNCTIONS/svd.cc, DLD-FUNCTIONS/syl.cc, DLD-FUNCTIONS/symbfact.cc,
+	DLD-FUNCTIONS/symrcm.cc, DLD-FUNCTIONS/time.cc, DLD-FUNCTIONS/tril.cc,
+	DLD-FUNCTIONS/tsearch.cc, DLD-FUNCTIONS/typecast.cc,
+	DLD-FUNCTIONS/urlwrite.cc: Improve docstrings.  Use same variable names
+	in error() strings and docstrings.
+
 2011-01-15  Rik  <octave@nomad.inbox5.com>
 
 	* src/dirfns.cc, src/help.cc, src/input.cc, src/load-save.cc,
 	src/oct-hist.cc, src/pager.cc, src/pr-output.cc, src/variables.cc:
 	Eliminate @deffn macros.
 
 2011-01-15  John W. Eaton  <jwe@octave.org>
 
diff --git a/src/DLD-FUNCTIONS/__delaunayn__.cc b/src/DLD-FUNCTIONS/__delaunayn__.cc
--- a/src/DLD-FUNCTIONS/__delaunayn__.cc
+++ b/src/DLD-FUNCTIONS/__delaunayn__.cc
@@ -57,17 +57,18 @@ extern "C" {
 
 #ifdef NEED_QHULL_VERSION
 char qh_version[] = "__delaunayn__.oct 2007-08-21";
 #endif
 #endif
 
 DEFUN_DLD (__delaunayn__, args, ,
            "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{T} =} __delaunayn__ (@var{P}[, @var{opt}])\n\
+@deftypefn  {Loadable Function} {@var{T} =} __delaunayn__ (@var{P})\n\
+@deftypefnx {Loadable Function} {@var{T} =} __delaunayn__ (@var{P}, @var{opt})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 
 {
   octave_value_list retval;
 
 #ifdef HAVE_QHULL
 
@@ -117,17 +118,17 @@ Undocumented internal function.\n\
                 return retval;
               }
 
             options = options + c.elem(i).string_value () + " ";
           }
       }
     else 
       {
-        error ("__delaunayn__: second argument must be a string, cell of stringsor empty");
+        error ("__delaunayn__: OPT argument must be a string, cell array of strings, or empty");
         return retval;
       }
     } 
 
   //octave_stdout << "options " << options << std::endl;
 
   if (n > dim + 1) 
     {
diff --git a/src/DLD-FUNCTIONS/__dispatch__.cc b/src/DLD-FUNCTIONS/__dispatch__.cc
--- a/src/DLD-FUNCTIONS/__dispatch__.cc
+++ b/src/DLD-FUNCTIONS/__dispatch__.cc
@@ -51,39 +51,39 @@ DEFUN_DLD (__dispatch__, args, nargout,
   if (nargin > 0 && nargin < 4)
     {
       if (nargin > 0)
         {
           f = args(0).string_value ();
 
           if (error_state)
             {
-              error ("__dispatch__: expecting first argument to be function name");
+              error ("__dispatch__: first argument must be a function name");
               return retval;
             }
         }
 
       if (nargin > 1)
         {
           r = args(1).string_value ();
 
           if (error_state)
             {
-              error ("__dispatch__: expecting second argument to be function name");
+              error ("__dispatch__: second argument must be a function name");
               return retval;
             }
         }
 
       if (nargin > 2)
         {
           t = args(2).string_value ();
 
           if (error_state)
             {
-              error ("__dispatch__: expecting third argument to be type name");
+              error ("__dispatch__: third argument must be a type name");
               return retval;
             }
         }
 
       if (nargin == 1)
         {
           if (nargout > 0)
             {
diff --git a/src/DLD-FUNCTIONS/__dsearchn__.cc b/src/DLD-FUNCTIONS/__dsearchn__.cc
--- a/src/DLD-FUNCTIONS/__dsearchn__.cc
+++ b/src/DLD-FUNCTIONS/__dsearchn__.cc
@@ -50,17 +50,17 @@ Undocumented internal function.\n\
     }
 
   Matrix x = args(0).matrix_value().transpose ();
   Matrix xi = args(1).matrix_value().transpose ();
 
   if (! error_state)
     {
       if (x.rows() != xi.rows() || x.columns() < 1)
-        error ("__dsearch__: dimensional mismatch");
+        error ("__dsearch__: number of rows of X and XI must match");
       else
         {
           octave_idx_type n = x.rows();
           octave_idx_type nx = x.columns();
           octave_idx_type nxi = xi.columns();
 
           ColumnVector idx (nxi);
           double *pidx = idx.fortran_vec ();
diff --git a/src/DLD-FUNCTIONS/__glpk__.cc b/src/DLD-FUNCTIONS/__glpk__.cc
--- a/src/DLD-FUNCTIONS/__glpk__.cc
+++ b/src/DLD-FUNCTIONS/__glpk__.cc
@@ -423,23 +423,23 @@ glpk (int sense, int n, int m, double *c
       if (tmp.is_defined ()) \
         { \
           if (! tmp.is_empty ()) \
             { \
               lpxRealParam[IDX] = tmp.scalar_value (); \
  \
               if (error_state) \
                 { \
-                  error ("glpk: invalid value in param." NAME); \
+                  error ("glpk: invalid value in PARAM." NAME); \
                   return retval; \
                 } \
             } \
           else \
             { \
-              error ("glpk: invalid value in param." NAME); \
+              error ("glpk: invalid value in PARAM." NAME); \
               return retval; \
             } \
         } \
     } \
   while (0)
 
 #define OCTAVE_GLPK_GET_INT_PARAM(NAME, VAL) \
   do \
@@ -449,23 +449,23 @@ glpk (int sense, int n, int m, double *c
       if (tmp.is_defined ()) \
         { \
           if (! tmp.is_empty ()) \
             { \
               VAL = tmp.int_value (); \
  \
               if (error_state) \
                 { \
-                  error ("glpk: invalid value in param." NAME); \
+                  error ("glpk: invalid value in PARAM." NAME); \
                   return retval; \
                 } \
             } \
           else \
             { \
-              error ("glpk: invalid value in param." NAME); \
+              error ("glpk: invalid value in PARAM." NAME); \
               return retval; \
             } \
         } \
     } \
   while (0)
 
 DEFUN_DLD (__glpk__, args, ,
   "-*- texinfo -*-\n\
@@ -571,29 +571,29 @@ Undocumented internal function.\n\
     }
 
   //-- 3rd Input. A column array containing the right-hand side value
   //               for each constraint in the constraint matrix.
   Matrix B (args(2).matrix_value ());
 
   if (error_state)
     {
-      error ("__glpk__: invalid value of b");
+      error ("__glpk__: invalid value of B");
       return retval;
     }
 
   double *b = B.fortran_vec ();
 
   //-- 4th Input. An array of length mrowsc containing the lower
   //--            bound on each of the variables.
   Matrix LB (args(3).matrix_value ());
 
   if (error_state || LB.length () < mrowsc)
     {
-      error ("__glpk__: invalid value of lb");
+      error ("__glpk__: invalid value of LB");
       return retval;
     }
 
   double *lb = LB.fortran_vec ();
 
   //-- LB argument, default: Free
   Array<int> freeLB (mrowsc, 1);
   for (int i = 0; i < mrowsc; i++)
@@ -608,17 +608,17 @@ Undocumented internal function.\n\
      }
 
   //-- 5th Input. An array of at least length numcols containing the upper
   //--            bound on each of the variables.
   Matrix UB (args(4).matrix_value ());
 
   if (error_state || UB.length () < mrowsc)
     {
-      error ("__glpk__: invalid value of ub");
+      error ("__glpk__: invalid value of UB");
       return retval;
     }
 
   double *ub = UB.fortran_vec ();
 
   Array<int> freeUB (mrowsc, 1);
   for (int i = 0; i < mrowsc; i++)
     {
@@ -632,28 +632,28 @@ Undocumented internal function.\n\
     }
 
   //-- 6th Input. A column array containing the sense of each constraint
   //--            in the constraint matrix.
   charMatrix CTYPE (args(5).char_matrix_value ());
 
   if (error_state)
     {
-      error ("__glpk__: invalid value of ctype");
+      error ("__glpk__: invalid value of CTYPE");
       return retval;
     }
 
   char *ctype = CTYPE.fortran_vec ();
 
   //-- 7th Input. A column array containing the types of the variables.
   charMatrix VTYPE (args(6).char_matrix_value ());
 
   if (error_state)
     {
-      error ("__glpk__: invalid value of vtype");
+      error ("__glpk__: invalid value of VARTYPE");
       return retval;
     }
 
   Array<int> vartype (mrowsc, 1);
   volatile int isMIP = 0;
   for (int i = 0; i < mrowsc ; i++)
     {
       if (VTYPE(i,0) == 'I')
@@ -666,117 +666,117 @@ Undocumented internal function.\n\
     }
 
   //-- 8th Input. Sense of optimization.
   volatile int sense;
   double SENSE = args(7).scalar_value ();
 
   if (error_state)
     {
-      error ("__glpk__: invalid value of sense");
+      error ("__glpk__: invalid value of SENSE");
       return retval;
     }
 
   if (SENSE >= 0)
     sense = 1;
   else
     sense = -1;
 
   //-- 9th Input. A structure containing the control parameters.
   octave_scalar_map PARAM = args(8).scalar_map_value ();
 
   if (error_state)
     {
-      error ("__glpk__: invalid value of param");
+      error ("__glpk__: invalid value of PARAM");
       return retval;
     }
 
   //-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   //-- Integer parameters
   //-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 
   //-- Level of messages output by the solver
   OCTAVE_GLPK_GET_INT_PARAM ("msglev", lpxIntParam[0]);
   if (lpxIntParam[0] < 0 || lpxIntParam[0] > 3)
     {
-      error ("__glpk__: param.msglev must be 0 (no output [default]) or 1 (error messages only) or 2 (normal output) or 3 (full output)");
+      error ("__glpk__: PARAM.msglev must be 0 (no output [default]) or 1 (error messages only) or 2 (normal output) or 3 (full output)");
       return retval;
     }
 
   //-- scaling option
   OCTAVE_GLPK_GET_INT_PARAM ("scale", lpxIntParam[1]);
   if (lpxIntParam[1] < 0 || lpxIntParam[1] > 2)
     {
-      error ("__glpk__: param.scale must be 0 (no scaling) or 1 (equilibration scaling [default]) or 2 (geometric mean scaling)");
+      error ("__glpk__: PARAM.scale must be 0 (no scaling) or 1 (equilibration scaling [default]) or 2 (geometric mean scaling)");
       return retval;
     }
 
   //-- Dual dimplex option
   OCTAVE_GLPK_GET_INT_PARAM ("dual", lpxIntParam[2]);
   if (lpxIntParam[2] < 0 || lpxIntParam[2] > 1)
     {
-      error ("__glpk__: param.dual must be 0 (do NOT use dual simplex [default]) or 1 (use dual simplex)");
+      error ("__glpk__: PARAM.dual must be 0 (do NOT use dual simplex [default]) or 1 (use dual simplex)");
       return retval;
     }
 
   //-- Pricing option
   OCTAVE_GLPK_GET_INT_PARAM ("price", lpxIntParam[3]);
   if (lpxIntParam[3] < 0 || lpxIntParam[3] > 1)
     {
-      error ("__glpk__: param.price must be 0 (textbook pricing) or 1 (steepest edge pricing [default])");
+      error ("__glpk__: PARAM.price must be 0 (textbook pricing) or 1 (steepest edge pricing [default])");
       return retval;
     }
 
   //-- Solution rounding option
   OCTAVE_GLPK_GET_INT_PARAM ("round", lpxIntParam[4]);
   if (lpxIntParam[4] < 0 || lpxIntParam[4] > 1)
     {
-      error ("__glpk__: param.round must be 0 (report all primal and dual values [default]) or 1 (replace tiny primal and dual values by exact zero)");
+      error ("__glpk__: PARAM.round must be 0 (report all primal and dual values [default]) or 1 (replace tiny primal and dual values by exact zero)");
       return retval;
     }
 
   //-- Simplex iterations limit
   OCTAVE_GLPK_GET_INT_PARAM ("itlim", lpxIntParam[5]);
 
   //-- Simplex iterations count
   OCTAVE_GLPK_GET_INT_PARAM ("itcnt", lpxIntParam[6]);
 
   //-- Output frequency, in iterations
   OCTAVE_GLPK_GET_INT_PARAM ("outfrq", lpxIntParam[7]);
 
   //-- Branching heuristic option
   OCTAVE_GLPK_GET_INT_PARAM ("branch", lpxIntParam[14]);
   if (lpxIntParam[14] < 0 || lpxIntParam[14] > 2)
     {
-      error ("__glpk__: param.branch must be (MIP only) 0 (branch on first variable) or 1 (branch on last variable) or 2 (branch using a heuristic by Driebeck and Tomlin [default]");
+      error ("__glpk__: PARAM.branch must be (MIP only) 0 (branch on first variable) or 1 (branch on last variable) or 2 (branch using a heuristic by Driebeck and Tomlin [default]");
       return retval;
     }
 
   //-- Backtracking heuristic option
   OCTAVE_GLPK_GET_INT_PARAM ("btrack", lpxIntParam[15]);
   if (lpxIntParam[15] < 0 || lpxIntParam[15] > 2)
     {
-      error ("__glpk__: param.btrack must be (MIP only) 0 (depth first search) or 1 (breadth first search) or 2 (backtrack using the best projection heuristic [default]");
+      error ("__glpk__: PARAM.btrack must be (MIP only) 0 (depth first search) or 1 (breadth first search) or 2 (backtrack using the best projection heuristic [default]");
       return retval;
     }
 
   //-- Presolver option
   OCTAVE_GLPK_GET_INT_PARAM ("presol", lpxIntParam[16]);
   if (lpxIntParam[16] < 0 || lpxIntParam[16] > 1)
     {
-      error ("__glpk__: param.presol must be 0 (do NOT use LP presolver) or 1 (use LP presolver [default])");
+      error ("__glpk__: PARAM.presol must be 0 (do NOT use LP presolver) or 1 (use LP presolver [default])");
       return retval;
     }
 
   //-- LPsolver option
   volatile int lpsolver = 1;
   OCTAVE_GLPK_GET_INT_PARAM ("lpsolver", lpsolver);
   if (lpsolver < 1 || lpsolver > 2)
     {
-      error ("__glpk__: param.lpsolver must be 1 (simplex method) or 2 (interior point method)");
+      error ("__glpk__: PARAM.lpsolver must be 1 (simplex method) or 2 (interior point method)");
       return retval;
     }
 
   //-- Save option
   volatile int save_pb = 0;
   OCTAVE_GLPK_GET_INT_PARAM ("save", save_pb);
   save_pb = save_pb != 0;
 
diff --git a/src/DLD-FUNCTIONS/__magick_read__.cc b/src/DLD-FUNCTIONS/__magick_read__.cc
--- a/src/DLD-FUNCTIONS/__magick_read__.cc
+++ b/src/DLD-FUNCTIONS/__magick_read__.cc
@@ -134,17 +134,17 @@ read_indexed_images (std::vector<Magick:
               }
           }
 
         output(0) = octave_value (im);
       }
       break;
 
     default:
-      error ("__magic_read__: index depths bigger than 16-bit not supported");
+      error ("__magic_read__: index depths greater than 16-bit are not supported");
       return octave_value_list ();
     }
 
   Matrix map = Matrix (mapsize, 3);
   Matrix alpha;
 
   switch (type)
     {
@@ -401,17 +401,17 @@ maybe_initialize_magick (void)
 }
 
 DEFUN_DLD (__magick_read__, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Function File} {@var{m} =} __magick_read__(@var{fname}, @var{index})\n\
 @deftypefnx {Function File} {[@var{m}, @var{colormap}] =} __magick_read__(@var{fname}, @var{index})\n\
 @deftypefnx {Function File} {[@var{m}, @var{colormap}, @var{alpha}] =} __magick_read__(@var{fname}, @var{index})\n\
 Read images with ImageMagick++.  In general you should not be using this\n\
-function.  Instead you should use @code{imread}.\n\
+function.  Instead use @code{imread}.\n\
 @seealso{imread}\n\
 @end deftypefn")
 {
   octave_value_list output;
 
 #ifdef HAVE_MAGICK
 
   maybe_initialize_magick ();
@@ -473,17 +473,17 @@ function.  Instead you should use @code{
   else
     {
       for (int i = 0; i < frameidx.length (); i++)
         {
           frameidx(i) = frameidx(i) - 1;
 
           if (frameidx(i) >= nframes || frameidx(i) < 0)
             {
-              error ("__magick_read__: invalid index vector");
+              error ("__magick_read__: invalid INDEX vector");
               return output;
             }
         }
     }
 
   Magick::ClassType klass = imvec[0].classType ();
 
   if (klass == Magick::PseudoClass && nargout > 1)
@@ -514,17 +514,17 @@ function.  Instead you should use @code{
 
         case 16:
           output = read_images<uint16NDArray> (imvec, frameidx, depth);
           break;
 
         case 32:
         case 64:
         default:
-          error ("__magick_read__: image depths bigger than 16-bit not supported");
+          error ("__magick_read__: image depths greater than 16-bit are not supported");
         }
     }
 #else
 
   error ("imread: this installation of Octave does not support reading images."
 	 " Image reading capabilities were disabled when this installation was compiled.");
 
 #endif
@@ -865,17 +865,17 @@ write_image (const std::string& filename
 
 #endif
 
 DEFUN_DLD (__magick_write__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Function File} {} __magick_write__(@var{fname}, @var{fmt}, @var{img})\n\
 @deftypefnx {Function File} {} __magick_write__(@var{fname}, @var{fmt}, @var{img}, @var{map})\n\
 Write images with ImageMagick++.  In general you should not be using this\n\
-function.  Instead you should use @code{imwrite}.\n\
+function.  Instead use @code{imwrite}.\n\
 @seealso{imread}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
 #ifdef HAVE_MAGICK
   maybe_initialize_magick ();
 
@@ -897,20 +897,20 @@ function.  Instead you should use @code{
                 if (args(3).is_real_type ())
                   write_image (filename, fmt, args(2), args(3));
                 else
                   write_image (filename, fmt, args(2), octave_value(), args(3));
               else
                 write_image (filename, fmt, args(2));
             }
           else
-            error ("__magick_write__: expecting format as second argument");
+            error ("__magick_write__: FMT must be string");
         }
       else
-        error ("__magick_write__: expecting filename as first argument");
+        error ("__magick_write__: FNAME must be a string");
     }
   else
     print_usage ();
 #else
 
   error ("__magick_write__: not available in this version of Octave");
 
 #endif
@@ -993,19 +993,19 @@ magick_to_octave_value (const Magick::Im
   catch (Magick::Warning& w) \
     { \
     }
 
 #endif
 
 DEFUN_DLD (__magick_finfo__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable File} {} __magick_finfo__(@var{fname})\n\
+@deftypefn {Loadable Function} {} __magick_finfo__(@var{fname})\n\
 Read image information with GraphicsMagick++.  In general you should\n\
-not be using this function.  Instead you should use @code{imfinfo}.\n\
+not be using this function.  Instead use @code{imfinfo}.\n\
 @seealso{imfinfo, imread}\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_MAGICK
 
   maybe_initialize_magick ();
@@ -1140,17 +1140,17 @@ not be using this function.  Instead you
 
 // Determine the file formats supported by GraphicsMagick.  This is
 // called once at the beginning of imread or imwrite to determine
 // exactly which file formats are supported, so error messages can be
 // displayed properly.
 
 DEFUN_DLD (__magick_format_list__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Function File} {} __magick_format_list__ (@var{formats})\n\
+@deftypefn {Function File} {} __magick_format_list__ (@var{formats})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_MAGICK
   maybe_initialize_magick ();
 
diff --git a/src/DLD-FUNCTIONS/__pchip_deriv__.cc b/src/DLD-FUNCTIONS/__pchip_deriv__.cc
--- a/src/DLD-FUNCTIONS/__pchip_deriv__.cc
+++ b/src/DLD-FUNCTIONS/__pchip_deriv__.cc
@@ -69,17 +69,17 @@ Undocumented internal function.\n\
           FloatMatrix ymat (args(1).float_matrix_value ());
 
           octave_idx_type nx = xvec.length ();
           octave_idx_type nyr = ymat.rows ();
           octave_idx_type nyc = ymat.columns ();
 
           if (nx != (rows ? nyc : nyr))
             {
-              error ("__pchip_deriv__: dimension mismatch");
+              error ("__pchip_deriv__: X and Y dimension mismatch");
               return retval;
             }
 
           const float *yvec = ymat.data ();
           FloatMatrix dmat (nyr, nyc);
           float *dvec = dmat.fortran_vec ();
 
           octave_idx_type ierr;
@@ -91,17 +91,17 @@ Undocumented internal function.\n\
               F77_FUNC (pchim, PCHIM) (nx, xvec.data (), 
                                        yvec, dvec, incfd, &ierr);
 
               yvec += inc;
               dvec += inc;
 
               if (ierr < 0)
                 {
-                  error ("PCHIM error: %i\n", ierr);
+                  error ("PCHIM: error: %i\n", ierr);
                   return retval;
                 }
             }
 
           retval = dmat;
         }
       else
         {
@@ -109,17 +109,17 @@ Undocumented internal function.\n\
           Matrix ymat (args(1).matrix_value ());
 
           octave_idx_type nx = xvec.length ();
           octave_idx_type nyr = ymat.rows ();
           octave_idx_type nyc = ymat.columns ();
 
           if (nx != (rows ? nyc : nyr))
             {
-              error ("__pchip_deriv__: dimension mismatch");
+              error ("__pchip_deriv__: X and Y dimension mismatch");
               return retval;
             }
 
           const double *yvec = ymat.data ();
           Matrix dmat (nyr, nyc);
           double *dvec = dmat.fortran_vec ();
 
           octave_idx_type ierr;
@@ -131,17 +131,17 @@ Undocumented internal function.\n\
               F77_FUNC (dpchim, DPCHIM) (nx, xvec.data (), 
                                          yvec, dvec, incfd, &ierr);
 
               yvec += inc;
               dvec += inc;
 
               if (ierr < 0)
                 {
-                  error ("DPCHIM error: %i\n", ierr);
+                  error ("DPCHIM: error: %i\n", ierr);
                   return retval;
                 }
             }
 
           retval = dmat;
         }
     }
 
diff --git a/src/DLD-FUNCTIONS/__voronoi__.cc b/src/DLD-FUNCTIONS/__voronoi__.cc
--- a/src/DLD-FUNCTIONS/__voronoi__.cc
+++ b/src/DLD-FUNCTIONS/__voronoi__.cc
@@ -74,17 +74,17 @@ Undocumented internal function.\n\
     }
 
   const char *options;
 
   if (nargin == 2) 
     {
       if (! args (1).is_string ()) 
         {
-          error ("__voronoi__: second argument must be a string");
+          error ("__voronoi__: OPTIONS argument must be a string");
           return retval;
         }
 
       options = args (1).string_value().c_str ();
     }
   else
     options = "";
 
diff --git a/src/DLD-FUNCTIONS/amd.cc b/src/DLD-FUNCTIONS/amd.cc
--- a/src/DLD-FUNCTIONS/amd.cc
+++ b/src/DLD-FUNCTIONS/amd.cc
@@ -47,37 +47,37 @@ along with Octave; see the file COPYING.
 #ifdef IDX_TYPE_LONG
 #define AMD_NAME(name) amd_l ## name
 #else
 #define AMD_NAME(name) amd ## name
 #endif
 
 DEFUN_DLD (amd, args, nargout,
     "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{p} =} amd (@var{s})\n\
-@deftypefnx {Loadable Function} {@var{p} =} amd (@var{s}, @var{opts})\n\
+@deftypefn  {Loadable Function} {@var{p} =} amd (@var{S})\n\
+@deftypefnx {Loadable Function} {@var{p} =} amd (@var{S}, @var{opts})\n\
 \n\
 Returns the approximate minimum degree permutation of a matrix.  This\n\
-permutation such that the Cholesky factorization of @code{@var{s} (@var{p},\n\
-@var{p})} tends to be sparser than the Cholesky factorization of @var{s}\n\
-itself.  @code{amd} is typically faster than @code{symamd} but serves a\n\
-similar purpose.\n\
+permutation such that the Cholesky@tie{}factorization of @code{@var{S}\n\
+(@var{p}, @var{p})} tends to be sparser than the Cholesky@tie{}factorization\n\
+of @var{S} itself.  @code{amd} is typically faster than @code{symamd} but\n\
+serves a similar purpose.\n\
 \n\
 The optional parameter @var{opts} is a structure that controls the\n\
-behavior of @code{amd}.  The fields of these structure are\n\
+behavior of @code{amd}.  The fields of the structure are\n\
 \n\
 @table @asis\n\
-@item opts.dense\n\
+@item @var{opts}.dense\n\
 Determines what @code{amd} considers to be a dense row or column of the\n\
 input matrix.  Rows or columns with more than @code{max(16, (dense *\n\
-sqrt (@var{n})} entries, where @var{n} is the order of the matrix @var{s},\n\
+sqrt (@var{n})} entries, where @var{n} is the order of the matrix @var{S},\n\
 are ignored by @code{amd} during the calculation of the permutation\n\
 The value of dense must be a positive scalar and its default value is 10.0\n\
 \n\
-@item opts.aggressive\n\
+@item @var{opts}.aggressive\n\
 If this value is a non zero scalar, then @code{amd} performs aggressive\n\
 absorption.  The default is not to perform aggressive absorption.\n\
 @end table\n\
 \n\
 The author of the code itself is Timothy A. Davis\n\
 @email{davis@@cise.ufl.edu}, University of Florida (see\n\
 @url{http://www.cise.ufl.edu/research/sparse/amd}).\n\
 @seealso{symamd, colamd}\n\
@@ -125,17 +125,17 @@ The author of the code itself is Timothy
           
           n_row = sm.rows ();
           n_col = sm.cols ();
           ridx = sm.xridx ();
           cidx = sm.xcidx ();
         }
 
       if (!error_state && n_row != n_col)
-        error ("amd: input matrix must be square");
+        error ("amd: matrix S must be square");
 
       if (!error_state)
         {
           OCTAVE_LOCAL_BUFFER (double, Control, AMD_CONTROL);
           AMD_NAME (_defaults) (Control) ;
           if (nargin > 1)
             {
               octave_scalar_map arg1 = args(1).scalar_map_value ();
@@ -148,17 +148,17 @@ The author of the code itself is Timothy
                   if (tmp.is_defined ())
                     Control[AMD_DENSE] = tmp.double_value ();
 
                   tmp = arg1.getfield ("aggressive");
                   if (tmp.is_defined ())
                     Control[AMD_AGGRESSIVE] = tmp.double_value ();
                 }
               else
-                error ("amd: options argument must be a scalar structure");
+                error ("amd: OPTS argument must be a scalar structure");
             }
 
           if (!error_state)
             {
               OCTAVE_LOCAL_BUFFER (octave_idx_type, P, n_col);
               Matrix xinfo (AMD_INFO, 1);
               double *Info = xinfo.fortran_vec ();
 
@@ -174,17 +174,17 @@ The author of the code itself is Timothy
                                                           Control, Info);
 
               switch (result)
                 {
                 case AMD_OUT_OF_MEMORY:
                   error ("amd: out of memory");
                   break;
                 case AMD_INVALID:
-                  error ("amd: input matrix is corrupted");
+                  error ("amd: matrix S is corrupted");
                   break;
                 default:
                   {
                     if (nargout > 1)
                       retval(1) = xinfo;
 
                     Matrix Pout (1, n_col);
                     for (octave_idx_type i = 0; i < n_col; i++)
diff --git a/src/DLD-FUNCTIONS/balance.cc b/src/DLD-FUNCTIONS/balance.cc
--- a/src/DLD-FUNCTIONS/balance.cc
+++ b/src/DLD-FUNCTIONS/balance.cc
@@ -43,46 +43,47 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "f77-fcn.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN_DLD (balance, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{aa} =} balance (@var{a}, @var{opt})\n\
-@deftypefnx {Loadable Function} {[@var{dd}, @var{aa}] =} balance (@var{a}, @var{opt})\n\
-@deftypefnx {Loadable Function} {[@var{d}, @var{p}, @var{aa}] =} balance (@var{a}, @var{opt})\n\
-@deftypefnx {Loadable Function} {[@var{cc}, @var{dd}, @var{aa}, @var{bb}] =} balance (@var{a}, @var{b}, @var{opt})\n\
+@deftypefn  {Loadable Function} {@var{AA} =} balance (@var{A})\n\
+@deftypefnx {Loadable Function} {@var{AA} =} balance (@var{A}, @var{opt})\n\
+@deftypefnx {Loadable Function} {[@var{DD}, @var{AA}] =} balance (@var{A}, @var{opt})\n\
+@deftypefnx {Loadable Function} {[@var{D}, @var{P}, @var{AA}] =} balance (@var{A}, @var{opt})\n\
+@deftypefnx {Loadable Function} {[@var{CC}, @var{DD}, @var{AA}, @var{BB}] =} balance (@var{A}, @var{B}, @var{opt})\n\
 \n\
-Compute @code{aa = dd \\ a * dd} in which @code{aa} is a matrix whose\n\
-row and column norms are roughly equal in magnitude, and\n\
-@code{dd} = @code{p * d}, in which @code{p} is a permutation\n\
-matrix and @code{d} is a diagonal matrix of powers of two.  This allows\n\
-the equilibration to be computed without round-off.  Results of\n\
-eigenvalue calculation are typically improved by balancing first.\n\
+Compute @code{@var{AA} = @var{DD} \\ @var{A} * @var{DD}} in which @var{AA}\n\
+is a matrix whose row and column norms are roughly equal in magnitude, and\n\
+@code{@var{DD} = @var{P} * @var{D}}, in which @var{P} is a permutation\n\
+matrix and @var{D} is a diagonal matrix of powers of two.  This allows the\n\
+equilibration to be computed without round-off.  Results of eigenvalue\n\
+calculation are typically improved by balancing first.\n\
 \n\
 If two output values are requested, @code{balance} returns \n\
-the diagonal @code{d} and the permutation @code{p} separately as vectors.  \n\
-In this case, @code{dd = eye(n)(:,p) * diag (d)}, where @code{n} is the\n\
-matrix size.  \n\
+the diagonal @var{D} and the permutation @var{P} separately as vectors.  \n\
+In this case, @code{@var{DD} = eye(n)(:,@var{P}) * diag (@var{D})}, where n\n\
+@t{n} is the matrix size.  \n\
 \n\
-If four output values are requested, compute @code{aa = cc*a*dd} and\n\
-@code{bb = cc*b*dd)}, in which @code{aa} and @code{bb} have non-zero\n\
-elements of approximately the same magnitude and @code{cc} and @code{dd}\n\
-are permuted diagonal matrices as in @code{dd} for the algebraic\n\
-eigenvalue problem.\n\
+If four output values are requested, compute @code{@var{AA} =\n\
+@var{CC}*@var{A}*@var{DD}} and @code{@var{BB} = @var{CC}*@var{B}*@var{DD}},\n\
+in which @var{AA} and @var{BB} have non-zero elements of approximately the\n\
+same magnitude and @var{CC} and @var{DD} are permuted diagonal matrices as\n\
+in @var{DD} for the algebraic eigenvalue problem.\n\
 \n\
-The eigenvalue balancing option @code{opt} may be one of:\n\
+The eigenvalue balancing option @var{opt} may be one of:\n\
 \n\
 @table @asis\n\
-@item @code{\"noperm\"}, @code{\"S\"}\n\
+@item \"noperm\", \"S\"\n\
 Scale only; do not permute.\n\
 \n\
-@item @code{\"noscal\"}, @code{\"P\"}\n\
+@item \"noscal\", \"P\"\n\
 Permute only; do not scale.\n\
 @end table\n\
 \n\
 Algebraic eigenvalue balancing uses standard @sc{lapack} routines.\n\
 \n\
 Generalized eigenvalue problem balancing uses Ward's algorithm\n\
 (SIAM Journal on Scientific and Statistical Computing, 1981).\n\
 @end deftypefn")
@@ -240,17 +241,17 @@ Generalized eigenvalue problem balancing
 
       // Generalized eigenvalue problem.
       if (nargin == 2)
         bal_job = "B";
       else if (args(2).is_string ())
         bal_job = args(2).string_value ();
       else
         {
-          error ("balance: GEP argument 3 must be a string");
+          error ("balance: OPT argument must be a string");
           return retval;
         }
 
       if ((nn != args(1).columns ()) || (nn != args(1).rows ()))
         {
           gripe_nonconformant ();
           return retval;
         }
diff --git a/src/DLD-FUNCTIONS/besselj.cc b/src/DLD-FUNCTIONS/besselj.cc
--- a/src/DLD-FUNCTIONS/besselj.cc
+++ b/src/DLD-FUNCTIONS/besselj.cc
@@ -383,31 +383,31 @@ DEFUN_DLD (besselj, args, nargout,
 @deftypefnx {Loadable Function} {[@var{i}, @var{ierr}] =} besseli (@var{alpha}, @var{x}, @var{opt})\n\
 @deftypefnx {Loadable Function} {[@var{k}, @var{ierr}] =} besselk (@var{alpha}, @var{x}, @var{opt})\n\
 @deftypefnx {Loadable Function} {[@var{h}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})\n\
 Compute Bessel or Hankel functions of various kinds:\n\
 \n\
 @table @code\n\
 @item besselj\n\
 Bessel functions of the first kind.  If the argument @var{opt} is supplied, \n\
-the result is multiplied by @code{exp(-abs(imag(x)))}.\n\
+the result is multiplied by @code{exp(-abs(imag(@var{x})))}.\n\
 \n\
 @item bessely\n\
 Bessel functions of the second kind.  If the argument @var{opt} is supplied,\n\
-the result is multiplied by @code{exp(-abs(imag(x)))}.\n\
+the result is multiplied by @code{exp(-abs(imag(@var{x})))}.\n\
 \n\
 @item besseli\n\
 \n\
 Modified Bessel functions of the first kind.  If the argument @var{opt} is\n\
-supplied, the result is multiplied by @code{exp(-abs(real(x)))}.\n\
+supplied, the result is multiplied by @code{exp(-abs(real(@var{x})))}.\n\
 \n\
 @item besselk\n\
 \n\
 Modified Bessel functions of the second kind.  If the argument @var{opt} is\n\
-supplied, the result is multiplied by @code{exp(x)}.\n\
+supplied, the result is multiplied by @code{exp(@var{x})}.\n\
 \n\
 @item besselh\n\
 Compute Hankel functions of the first (@var{k} = 1) or second (@var{k}\n\
 = 2) kind.  If the argument @var{opt} is supplied, the result is multiplied\n\
 by @code{exp (-I*@var{x})} for @var{k} = 1 or @code{exp (I*@var{x})} for\n\
 @var{k} = 2.\n\
 @end table\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/bsxfun.cc b/src/DLD-FUNCTIONS/bsxfun.cc
--- a/src/DLD-FUNCTIONS/bsxfun.cc
+++ b/src/DLD-FUNCTIONS/bsxfun.cc
@@ -306,26 +306,25 @@ update_index (Array<int>& idx, const dim
     {
       idx (j) = i % dv (j);
       i = i / dv (j);
     }
 }
 
 DEFUN_DLD (bsxfun, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} bsxfun (@var{f}, @var{a}, @var{b})\n\
-Applies a binary function @var{f} element-by-element to two matrix arguments\n\
-@var{a} and @var{b}.  The function @var{f} must be capable of accepting\n\
-two column vector arguments of equal length, or one column vector\n\
+@deftypefn {Loadable Function} {} bsxfun (@var{f}, @var{A}, @var{B})\n\
+Apply a binary function @var{f} element-by-element to two matrix arguments\n\
+@var{A} and @var{B}.  The function @var{f} must be capable of accepting\n\
+two column-vector arguments of equal length, or one column vector\n\
 argument and a scalar.\n\
 \n\
-The dimensions of @var{a} and @var{b} must be equal or singleton.  The\n\
+The dimensions of @var{A} and @var{B} must be equal or singleton.  The\n\
 singleton dimensions of the matrices will be expanded to the same\n\
 dimensionality as the other matrix.\n\
-\n\
 @seealso{arrayfun, cellfun}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value_list retval;
 
   if (nargin != 3)
     print_usage ();
@@ -336,17 +335,17 @@ dimensionality as the other matrix.\n\
       if (func.is_string ())
         {
           std::string name = func.string_value ();
           func = symbol_table::find_function (name);
           if (func.is_undefined ())
             error ("bsxfun: invalid function name: %s", name.c_str ());
         }
       else if (! (args(0).is_function_handle () || args(0).is_inline_function ()))
-        error ("bsxfun: first argument must be a string or function handle");
+        error ("bsxfun: F must be a string or function handle");
 
       const octave_value A = args (1);
       const octave_value B = args (2);
 
       if (func.is_builtin_function () 
           || (func.is_function_handle () && ! A.is_object () && ! B.is_object ()))
         {
           // This may break if the default behavior is overriden. But if you override
@@ -376,17 +375,17 @@ dimensionality as the other matrix.\n\
             {
               dva.resize (ndb, 1);
               nd = ndb;
             }
 
           for (octave_idx_type i = 0; i < nd; i++)
             if (dva (i) != dvb (i) && dva (i) != 1 && dvb (i) != 1)
               {
-                error ("bsxfun: dimensions don't match");
+                error ("bsxfun: dimensions of A and B must match");
                 break;
               }
 
           if (!error_state)
             {
               // Find the size of the output
               dim_vector dvc;
               dvc.resize (nd);
diff --git a/src/DLD-FUNCTIONS/ccolamd.cc b/src/DLD-FUNCTIONS/ccolamd.cc
--- a/src/DLD-FUNCTIONS/ccolamd.cc
+++ b/src/DLD-FUNCTIONS/ccolamd.cc
@@ -48,93 +48,94 @@ along with Octave; see the file COPYING.
 #define CSYMAMD_NAME(name) csymamd_l ## name
 #else
 #define CCOLAMD_NAME(name) ccolamd ## name
 #define CSYMAMD_NAME(name) csymamd ## name
 #endif
 
 DEFUN_DLD (ccolamd, args, nargout,
     "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{p} =} ccolamd (@var{s})\n\
-@deftypefnx {Loadable Function} {@var{p} =} ccolamd (@var{s}, @var{knobs})\n\
-@deftypefnx {Loadable Function} {@var{p} =} ccolamd (@var{s}, @var{knobs}, @var{cmember})\n\
+@deftypefn  {Loadable Function} {@var{p} =} ccolamd (@var{S})\n\
+@deftypefnx {Loadable Function} {@var{p} =} ccolamd (@var{S}, @var{knobs})\n\
+@deftypefnx {Loadable Function} {@var{p} =} ccolamd (@var{S}, @var{knobs}, @var{cmember})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} ccolamd (@dots{})\n\
 \n\
 Constrained column approximate minimum degree permutation.\n\
-@code{@var{p} = ccolamd (@var{s})} returns the column approximate minimum\n\
-degree permutation vector for the sparse matrix @var{s}.  For a non-symmetric\n\
+@code{@var{p} = ccolamd (@var{S})} returns the column approximate minimum\n\
+degree permutation vector for the sparse matrix @var{S}.  For a non-symmetric\n\
 matrix\n\
-@var{s},\n\
-@code{@var{s} (:, @var{p})} tends to have sparser LU factors than @var{s}.\n\
-@code{chol (@var{s} (:, @var{p})' * @var{s} (:, @var{p}))} also tends to be\n\
-sparser than @code{chol (@var{s}' * @var{s})}.\n\
-@code{@var{p} = ccolamd\n\
-(@var{s}, 1)} optimizes the ordering for @code{lu (@var{s} (:, @var{p}))}.\n\
-The ordering is followed by a column elimination tree post-ordering.\n\
+@var{S},\n\
+@code{@var{S}(:, @var{p})} tends to have sparser LU@tie{}factors than\n\
+@var{S}.  @code{chol (@var{S}(:, @var{p})' * @var{S}(:, @var{p}))} also\n\
+tends to be sparser than @code{chol (@var{S}' * @var{S})}.  @code{@var{p} =\n\
+ccolamd (@var{S}, 1)} optimizes the ordering for @code{lu (@var{S}(:,\n\
+@var{p}))}.  The ordering is followed by a column elimination tree\n\
+post-ordering.\n\
 \n\
-@var{knobs} is an optional one- to five-element input vector, with a default\n\
-value of @code{[0 10 10 1 0]} if not present or empty.  Entries not present\n\
-are set to their defaults.\n\
+@var{knobs} is an optional 1-element to 5-element input vector, with a\n\
+default value of @code{[0 10 10 1 0]} if not present or empty.  Entries not\n\
+present are set to their defaults.\n\
 \n\
 @table @code\n\
 @item @var{knobs}(1)\n\
-if nonzero, the ordering is optimized for @code{lu (S (:, p))}.  It will be a\n\
-poor ordering for @code{chol (@var{s} (:, @var{p})' * @var{s} (:,\n\
+if nonzero, the ordering is optimized for @code{lu (S(:, p))}.  It will be a\n\
+poor ordering for @code{chol (@var{S}(:, @var{p})' * @var{S}(:,\n\
 @var{p}))}.  This is the most important knob for ccolamd.\n\
 \n\
-@item @var{knob}(2)\n\
-if @var{s} is m-by-n, rows with more than @code{max (16, @var{knobs} (2) *\n\
+@item @var{knobs}(2)\n\
+if @var{S} is m-by-n, rows with more than @code{max (16, @var{knobs}(2) *\n\
 sqrt (n))} entries are ignored.\n\
 \n\
-@item @var{knob}(3)\n\
-columns with more than @code{max (16, @var{knobs} (3) * sqrt (min (@var{m},\n\
+@item @var{knobs}(3)\n\
+columns with more than @code{max (16, @var{knobs}(3) * sqrt (min (@var{m},\n\
 @var{n})))} entries are ignored and ordered last in the output permutation\n\
 (subject to the cmember constraints).\n\
 \n\
-@item @var{knob}(4)\n\
+@item @var{knobs}(4)\n\
 if nonzero, aggressive absorption is performed.\n\
 \n\
-@item @var{knob}(5)\n\
+@item @var{knobs}(5)\n\
 if nonzero, statistics and knobs are printed.\n\
 \n\
 @end table\n\
 \n\
-@var{cmember} is an optional vector of length n.  It defines the constraints\n\
-on the column ordering.  If @code{@var{cmember} (j) = @var{c}}, then column\n\
-@var{j} is in constraint set @var{c} (@var{c} must be in the range 1 to\n\
-@var{n}).  In the output permutation @var{p}, all columns in set 1 appear\n\
+@var{cmember} is an optional vector of length @math{n}.  It defines the\n\
+constraints on the column ordering.  If @code{@var{cmember}(j) = @var{c}},\n\
+then column @var{j} is in constraint set @var{c} (@var{c} must be in the\n\
+range 1 to\n\
+n).  In the output permutation @var{p}, all columns in set 1 appear\n\
 first, followed by all columns in set 2, and so on.  @code{@var{cmember} =\n\
 ones(1,n)} if not present or empty.\n\
-@code{ccolamd (@var{s}, [], 1 : @var{n})} returns @code{1 : @var{n}}\n\
+@code{ccolamd (@var{S}, [], 1 : n)} returns @code{1 : n}\n\
 \n\
-@code{@var{p} = ccolamd (@var{s})} is about the same as\n\
-@code{@var{p} = colamd (@var{s})}.  @var{knobs} and its default values\n\
+@code{@var{p} = ccolamd (@var{S})} is about the same as\n\
+@code{@var{p} = colamd (@var{S})}.  @var{knobs} and its default values\n\
 differ.  @code{colamd} always does aggressive absorption, and it finds an\n\
-ordering suitable for both @code{lu (@var{s} (:, @var{p}))} and @code{chol\n\
-(@var{S} (:, @var{p})' * @var{s} (:, @var{p}))}; it cannot optimize its\n\
-ordering for @code{lu (@var{s} (:, @var{p}))} to the extent that\n\
-@code{ccolamd (@var{s}, 1)} can.\n\
+ordering suitable for both @code{lu (@var{S}(:, @var{p}))} and @code{chol\n\
+(@var{S}(:, @var{p})' * @var{S}(:, @var{p}))}; it cannot optimize its\n\
+ordering for @code{lu (@var{S}(:, @var{p}))} to the extent that\n\
+@code{ccolamd (@var{S}, 1)} can.\n\
 \n\
 @var{stats} is an optional 20-element output vector that provides data\n\
-about the ordering and the validity of the input matrix @var{s}.  Ordering\n\
-statistics are in @code{@var{stats} (1 : 3)}.  @code{@var{stats} (1)} and\n\
-@code{@var{stats} (2)} are the number of dense or empty rows and columns\n\
-ignored by @sc{ccolamd} and @code{@var{stats} (3)} is the number of garbage\n\
+about the ordering and the validity of the input matrix @var{S}.  Ordering\n\
+statistics are in @code{@var{stats}(1 : 3)}.  @code{@var{stats}(1)} and\n\
+@code{@var{stats}(2)} are the number of dense or empty rows and columns\n\
+ignored by @sc{ccolamd} and @code{@var{stats}(3)} is the number of garbage\n\
 collections performed on the internal data structure used by @sc{ccolamd}\n\
-(roughly of size @code{2.2 * nnz (@var{s}) + 4 * @var{m} + 7 * @var{n}}\n\
+(roughly of size @code{2.2 * nnz (@var{S}) + 4 * @var{m} + 7 * @var{n}}\n\
 integers).\n\
 \n\
-@code{@var{stats} (4 : 7)} provide information if CCOLAMD was able to\n\
-continue.  The matrix is OK if @code{@var{stats} (4)} is zero, or 1 if\n\
-invalid.  @code{@var{stats} (5)} is the rightmost column index that is\n\
+@code{@var{stats}(4 : 7)} provide information if CCOLAMD was able to\n\
+continue.  The matrix is OK if @code{@var{stats}(4)} is zero, or 1 if\n\
+invalid.  @code{@var{stats}(5)} is the rightmost column index that is\n\
 unsorted or contains duplicate entries, or zero if no such column exists.\n\
-@code{@var{stats} (6)} is the last seen duplicate or out-of-order row\n\
-index in the column index given by @code{@var{stats} (5)}, or zero if no\n\
-such row index exists.  @code{@var{stats} (7)} is the number of duplicate\n\
-or out-of-order row indices.  @code{@var{stats} (8 : 20)} is always zero in\n\
+@code{@var{stats}(6)} is the last seen duplicate or out-of-order row\n\
+index in the column index given by @code{@var{stats}(5)}, or zero if no\n\
+such row index exists.  @code{@var{stats}(7)} is the number of duplicate\n\
+or out-of-order row indices.  @code{@var{stats}(8 : 20)} is always zero in\n\
 the current version of @sc{ccolamd} (reserved for future use).\n\
 \n\
 The authors of the code itself are S. Larimore, T. Davis (Univ. of Florida)\n\
 and S. Rajamanickam in collaboration with J. Bilbert and E. Ng.  Supported\n\
 by the National Science Foundation (DMS-9504974, DMS-9803599, CCR-0203270),\n\
 and a grant from Sandia National Lab.  See\n\
 @url{http://www.cise.ufl.edu/research/sparse} for ccolamd, csymamd, amd,\n\
 colamd, symamd, and other related orderings.\n\
@@ -272,17 +273,17 @@ colamd, symamd, and other related orderi
           NDArray in_cmember = args(2).array_value();
           octave_idx_type cslen = in_cmember.length();
           OCTAVE_LOCAL_BUFFER (octave_idx_type, cmember, cslen);
           for (octave_idx_type i = 0; i < cslen; i++)
             // convert cmember from 1-based to 0-based
             cmember[i] = static_cast<octave_idx_type>(in_cmember(i) - 1);
           
           if (cslen != n_col)
-            error ("ccolamd: cmember must be of length equal to #cols of A");
+            error ("ccolamd: CMEMBER must be of length equal to #cols of A");
           else
             // Order the columns (destroys A)
             if (! CCOLAMD_NAME () (n_row, n_col, Alen, A, p, knobs, stats, cmember))
               {
                 CCOLAMD_NAME (_report) (stats) ;
                 error ("ccolamd: internal error!");
                 return retval;
               }
@@ -331,65 +332,65 @@ colamd, symamd, and other related orderi
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (csymamd, args, nargout,
     "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{p} =} csymamd (@var{s})\n\
-@deftypefnx {Loadable Function} {@var{p} =} csymamd (@var{s}, @var{knobs})\n\
-@deftypefnx {Loadable Function} {@var{p} =} csymamd (@var{s}, @var{knobs}, @var{cmember})\n\
+@deftypefn  {Loadable Function} {@var{p} =} csymamd (@var{S})\n\
+@deftypefnx {Loadable Function} {@var{p} =} csymamd (@var{S}, @var{knobs})\n\
+@deftypefnx {Loadable Function} {@var{p} =} csymamd (@var{S}, @var{knobs}, @var{cmember})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} csymamd (@dots{})\n\
 \n\
-For a symmetric positive definite matrix @var{s}, returns the permutation\n\
-vector @var{p} such that @code{@var{s}(@var{p},@var{p})} tends to have a\n\
-sparser Cholesky factor than @var{s}.  Sometimes @code{csymamd} works well\n\
-for symmetric indefinite matrices too.  The matrix @var{s} is assumed to\n\
-be symmetric; only the strictly lower triangular part is referenced.\n\
-@var{s} must be square.  The ordering is followed by an elimination tree\n\
+For a symmetric positive definite matrix @var{S}, returns the permutation\n\
+vector @var{p} such that @code{@var{S}(@var{p},@var{p})} tends to have a\n\
+sparser Cholesky@tie{}factor than @var{S}.  Sometimes @code{csymamd} works\n\
+well for symmetric indefinite matrices too.  The matrix @var{S} is assumed\n\
+to be symmetric; only the strictly lower triangular part is referenced.\n\
+@var{S} must be square.  The ordering is followed by an elimination tree\n\
 post-ordering.\n\
 \n\
-@var{knobs} is an optional one- to three-element input vector, with a\n\
+@var{knobs} is an optional 1-element to 3-element input vector, with a\n\
 default value of @code{[10 1 0]} if present or empty.  Entries not\n\
 present are set to their defaults.\n\
 \n\
 @table @code\n\
 @item @var{knobs}(1)\n\
-If @var{s} is n-by-n, then rows and columns with more than\n\
+If @var{S} is n-by-n, then rows and columns with more than\n\
 @code{max(16,@var{knobs}(1)*sqrt(n))} entries are ignored, and ordered\n\
 last in the output permutation (subject to the cmember constraints).\n\
 \n\
 @item @var{knobs}(2)\n\
 If nonzero, aggressive absorption is performed.\n\
 \n\
 @item @var{knobs}(3)\n\
 If nonzero, statistics and knobs are printed.\n\
 \n\
 @end table\n\
 \n\
 @var{cmember} is an optional vector of length n. It defines the constraints\n\
-on the ordering.  If @code{@var{cmember}(j) = @var{s}}, then row/column j is\n\
+on the ordering.  If @code{@var{cmember}(j) = @var{S}}, then row/column j is\n\
 in constraint set @var{c} (@var{c} must be in the range 1 to n).  In the\n\
 output permutation @var{p}, rows/columns in set 1 appear first, followed\n\
 by all rows/columns in set 2, and so on.  @code{@var{cmember} = ones(1,n)}\n\
-if not present or empty.  @code{csymamd(@var{s},[],1:n)} returns @code{1:n}.\n\
+if not present or empty.  @code{csymamd(@var{S},[],1:n)} returns @code{1:n}.\n\
 \n\
-@code{@var{p} = csymamd(@var{s})} is about the same as @code{@var{p} =\n\
-symamd(@var{s})}.  @var{knobs} and its default values differ.\n\
+@code{@var{p} = csymamd(@var{S})} is about the same as @code{@var{p} =\n\
+symamd(@var{S})}.  @var{knobs} and its default values differ.\n\
 \n\
-@code{@var{stats} (4:7)} provide information if CCOLAMD was able to\n\
-continue.  The matrix is OK if @code{@var{stats} (4)} is zero, or 1 if\n\
-invalid.  @code{@var{stats} (5)} is the rightmost column index that is\n\
+@code{@var{stats}(4:7)} provide information if CCOLAMD was able to\n\
+continue.  The matrix is OK if @code{@var{stats}(4)} is zero, or 1 if\n\
+invalid.  @code{@var{stats}(5)} is the rightmost column index that is\n\
 unsorted or contains duplicate entries, or zero if no such column exists.\n\
-@code{@var{stats} (6)} is the last seen duplicate or out-of-order row\n\
-index in the column index given by @code{@var{stats} (5)}, or zero if no\n\
-such row index exists.  @code{@var{stats} (7)} is the number of duplicate\n\
-or out-of-order row indices.  @code{@var{stats} (8:20)} is always zero in\n\
+@code{@var{stats}(6)} is the last seen duplicate or out-of-order row\n\
+index in the column index given by @code{@var{stats}(5)}, or zero if no\n\
+such row index exists.  @code{@var{stats}(7)} is the number of duplicate\n\
+or out-of-order row indices.  @code{@var{stats}(8:20)} is always zero in\n\
 the current version of @sc{ccolamd} (reserved for future use).\n\
 \n\
 The authors of the code itself are S. Larimore, T. Davis (Uni of Florida)\n\
 and S. Rajamanickam in collaboration with J. Bilbert and E. Ng.  Supported\n\
 by the National Science Foundation (DMS-9504974, DMS-9803599, CCR-0203270),\n\
 and a grant from Sandia National Lab.  See\n\
 @url{http://www.cise.ufl.edu/research/sparse} for ccolamd, csymamd, amd,\n\
 colamd, symamd, and other related orderings.\n\
@@ -489,17 +490,17 @@ colamd, symamd, and other related orderi
           n_col = sm.cols ();
           nnz = sm.nnz ();
           ridx = sm.xridx ();
           cidx = sm.xcidx ();
         }
 
       if (n_row != n_col)
         {
-          error ("symamd: matrix must be square");
+          error ("csymamd: matrix S must be square");
           return retval;
         }
 
       // Allocate workspace for symamd
       OCTAVE_LOCAL_BUFFER (octave_idx_type, perm, n_col+1);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, CCOLAMD_STATS);
 
       if (nargin > 2)
@@ -507,33 +508,33 @@ colamd, symamd, and other related orderi
           NDArray in_cmember = args(2).array_value();
           octave_idx_type cslen = in_cmember.length();
           OCTAVE_LOCAL_BUFFER (octave_idx_type, cmember, cslen);
           for (octave_idx_type i = 0; i < cslen; i++)
             // convert cmember from 1-based to 0-based
             cmember[i] = static_cast<octave_idx_type>(in_cmember(i) - 1);
           
           if (cslen != n_col)
-            error ("ccolamd: cmember must be of length equal to #cols of A");
+            error ("csymamd: CMEMBER must be of length equal to #cols of A");
           else
             if (!CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats, 
                                   &calloc, &free, cmember, -1))
               {
                 CSYMAMD_NAME (_report) (stats) ;
-                error ("symamd: internal error!") ;
+                error ("csymamd: internal error!") ;
                 return retval;
               }
         }
       else
         {
           if (!CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats, 
                                 &calloc, &free, 0, -1))
             {
               CSYMAMD_NAME (_report) (stats) ;
-              error ("symamd: internal error!") ;
+              error ("csymamd: internal error!") ;
               return retval;
             }
         }
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
         out_perm(i) = perm [i] + 1;
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -88,27 +88,27 @@ get_output_list (octave_idx_type count, 
         tmp.clear ();
     }
 
   return tmp;
 }
 
 DEFUN_DLD (cellfun, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} cellfun (@var{name}, @var{c})\n\
-@deftypefnx {Loadable Function} {} cellfun (\"size\", @var{c}, @var{k})\n\
-@deftypefnx {Loadable Function} {} cellfun (\"isclass\", @var{c}, @var{class})\n\
-@deftypefnx {Loadable Function} {} cellfun (@var{func}, @var{c})\n\
-@deftypefnx {Loadable Function} {} cellfun (@var{func}, @var{c}, @var{d})\n\
+@deftypefn  {Loadable Function} {} cellfun (@var{name}, @var{C})\n\
+@deftypefnx {Loadable Function} {} cellfun (\"size\", @var{C}, @var{k})\n\
+@deftypefnx {Loadable Function} {} cellfun (\"isclass\", @var{C}, @var{class})\n\
+@deftypefnx {Loadable Function} {} cellfun (@var{func}, @var{C})\n\
+@deftypefnx {Loadable Function} {} cellfun (@var{func}, @var{C}, @var{D})\n\
 @deftypefnx {Loadable Function} {[@var{a}, @dots{}] =} cellfun (@dots{})\n\
 @deftypefnx {Loadable Function} {} cellfun (@dots{}, 'ErrorHandler', @var{errfunc})\n\
 @deftypefnx {Loadable Function} {} cellfun (@dots{}, 'UniformOutput', @var{val})\n\
 \n\
 Evaluate the function named @var{name} on the elements of the cell array\n\
-@var{c}.  Elements in @var{c} are passed on to the named function\n\
+@var{C}.  Elements in @var{C} are passed on to the named function\n\
 individually.  The function @var{name} can be one of the functions\n\
 \n\
 @table @code\n\
 @item isempty\n\
 Return 1 for empty elements.\n\
 \n\
 @item islogical\n\
 Return 1 for logical elements.\n\
@@ -132,17 +132,17 @@ Return the size along the @var{k}-th dim
 Return 1 for elements of @var{class}.\n\
 @end table\n\
 \n\
 Additionally, @code{cellfun} accepts an arbitrary function @var{func}\n\
 in the form of an inline function, function handle, or the name of a\n\
 function (in a character string).  In the case of a character string\n\
 argument, the function must accept a single argument named @var{x}, and\n\
 it must return a string value.  The function can take one or more arguments,\n\
-with the inputs arguments given by @var{c}, @var{d}, etc.  Equally the\n\
+with the inputs arguments given by @var{C}, @var{D}, etc.  Equally the\n\
 function can return one or more output arguments.  For example:\n\
 \n\
 @example\n\
 @group\n\
 cellfun (@@atan2, @{1, 0@}, @{0, 1@})\n\
      @result{}ans = [1.57080   0.00000]\n\
 @end group\n\
 @end example\n\
@@ -218,17 +218,17 @@ cellfun (@@factorial, @{-1,2@},'ErrorHan
       print_usage ();
       return retval;
     }
 
   octave_value func = args(0);
 
   if (! args(1).is_cell ())
     {
-      error ("cellfun: second argument must be a cell array");
+      error ("cellfun: C must be a cell array");
 
       return retval;
     }
   
   if (func.is_string ())
     {
       const Cell f_args = args(1).cell_value ();
 
@@ -280,48 +280,48 @@ cellfun (@@factorial, @{-1,2@},'ErrorHan
         }
       else if (name == "size")
         {
           if (nargin == 3)
             {
               int d = args(2).nint_value () - 1;
 
               if (d < 0)
-                error ("cellfun: third argument must be a positive integer");
+                error ("cellfun: K must be a positive integer");
 
               if (! error_state)
                 {
                   NDArray result (f_args.dims ());
                   for (octave_idx_type count = 0; count < k ; count++)
                     {
                       dim_vector dv = f_args.elem(count).dims ();
                       if (d < dv.length ())
                         result(count) = static_cast<double> (dv(d));
                       else
                         result(count) = 1.0;
                     }
                   retval(0) = result;
                 }
             }
           else
-            error ("not enough arguments for `size'");
+            error ("cellfun: not enough arguments for \"size\"");
         }
       else if (name == "isclass")
         {
           if (nargin == 3)
             {
               std::string class_name = args(2).string_value();
               boolNDArray result (f_args.dims ());
               for (octave_idx_type count = 0; count < k ; count++)
                 result(count) = (f_args.elem(count).class_name() == class_name);
 
               retval(0) = result;
             }
           else
-            error ("not enough arguments for `isclass'");
+            error ("cellfun: not enough arguments for \"isclass\"");
         }
       else
         {
           if (! valid_identifier (name))
             {
 
               std::string fcn_name = unique_symbol_name ("__cellfun_fcn_");
               std::string fname = "function y = ";
@@ -331,17 +331,17 @@ cellfun (@@factorial, @{-1,2@},'ErrorHan
                                                             fcn_name, fname, "; endfunction");
               if (ptr_func && ! error_state)
                 func = octave_value (ptr_func, true);
             }
           else
             {
               func = symbol_table::find_function (name);
               if (func.is_undefined ())
-                error ("cellfun: invalid function name: %s", name.c_str ());
+                error ("cellfun: invalid function NAME: %s", name.c_str ());
             }
         }
     }
 
   if (error_state || ! retval.empty ())
     return retval;
 
   if (func.is_function_handle () || func.is_inline_function ()
@@ -370,23 +370,23 @@ cellfun (@@factorial, @{-1,2@},'ErrorHan
                   error_handler = args(nargin-1);
                 }
               else if (args(nargin-1).is_string ())
                 {
                   std::string err_name = args(nargin-1).string_value ();
                   error_handler = symbol_table::find_function (err_name);
                   if (error_handler.is_undefined ())
                     {
-                      error ("cellfun: invalid function name: %s", err_name.c_str ());
+                      error ("cellfun: invalid function NAME: %s", err_name.c_str ());
                       break;
                     }
                 }
               else
                 {
-                  error ("invalid errorhandler value");
+                  error ("cellfun: invalid value for 'ErrorHandler' function");
                   break;
                 }
             }
           else
             {
               error ("cellfun: unrecognized parameter %s", 
                      arg.c_str());
               break;
@@ -485,17 +485,17 @@ cellfun (@@factorial, @{-1,2@},'ErrorHan
                   for (int j = 0; j < nargout1; j++)
                     {
                       octave_value val = tmp(j);
 
                       if (val.numel () == 1)
                         retv[j] = val.resize (fdims);
                       else
                         {
-                          error ("cellfun: expecting all values to be scalars for UniformOutput = true");
+                          error ("cellfun: all values must be scalars when UniformOutput = true");
                           break;
                         }
                     }
                 }
               else
                 {
                   for (int j = 0; j < nargout1; j++)
                     {
@@ -509,17 +509,17 @@ cellfun (@@factorial, @{-1,2@},'ErrorHan
                               retv[j].assign (octave_value::op_asn_eq,
                                               idx_type, idx_list, val);
 
                               if (error_state)
                                 break;
                             }
                           else
                             {
-                              error ("cellfun: expecting all values to be scalars for UniformOutput = true");
+                              error ("cellfun: all values must be scalars when UniformOutput = true");
                               break;
                             }
                         }
                     }
                 }
 
               if (error_state)
                 break;
@@ -571,17 +571,17 @@ cellfun (@@factorial, @{-1,2@},'ErrorHan
             }
 
           retval.resize(nargout1);
           for (int j = 0; j < nargout1; j++)
             retval(j) = results[j];
         }
     }
   else
-    error ("cellfun: first argument must be a string or function handle");
+    error ("cellfun: argument NAME must be a string or function handle");
 
   return retval;
 }
 
 /*
 
 %!test
 %!  [a,b] = cellfun (@(x) x, cell (2, 0));
@@ -943,21 +943,21 @@ do_num2cell (const NDA& array, const Arr
 
       return retval;
     }
 }
 
 
 DEFUN_DLD (num2cell, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{c} =} num2cell (@var{m})\n\
-@deftypefnx {Loadable Function} {@var{c} =} num2cell (@var{m}, @var{dim})\n\
-Convert the matrix @var{m} to a cell array.  If @var{dim} is defined, the\n\
-value @var{c} is of dimension 1 in this dimension and the elements of\n\
-@var{m} are placed into @var{c} in slices.  For example:\n\
+@deftypefn  {Loadable Function} {@var{C} =} num2cell (@var{A})\n\
+@deftypefnx {Loadable Function} {@var{C} =} num2cell (@var{A}, @var{dim})\n\
+Convert the numeric matrix @var{A} to a cell array.  If @var{dim} is\n\
+defined, the value @var{C} is of dimension 1 in this dimension and the\n\
+elements of @var{A} are placed into @var{C} in slices.  For example:\n\
 \n\
 @example\n\
 @group\n\
 num2cell([1,2;3,4])\n\
      @result{} ans =\n\
         @{\n\
           [1,1] =  1\n\
           [2,1] =  3\n\
@@ -1270,28 +1270,28 @@ do_mat2cell (octave_value& a, const Arra
       rdv.increment_index (ridx);
     }
 
   return retval;
 }
 
 DEFUN_DLD (mat2cell, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{b} =} mat2cell (@var{a}, @var{m}, @var{n})\n\
-@deftypefnx {Loadable Function} {@var{b} =} mat2cell (@var{a}, @var{d1}, @var{d2}, @dots{})\n\
-@deftypefnx {Loadable Function} {@var{b} =} mat2cell (@var{a}, @var{r})\n\
-Convert the matrix @var{a} to a cell array.  If @var{a} is 2-D, then\n\
-it is required that @code{sum (@var{m}) == size (@var{a}, 1)} and\n\
-@code{sum (@var{n}) == size (@var{a}, 2)}.  Similarly, if @var{a} is\n\
-a multi-dimensional and the number of dimensional arguments is equal\n\
-to the dimensions of @var{a}, then it is required that @code{sum (@var{di})\n\
-== size (@var{a}, i)}.\n\
+@deftypefn  {Loadable Function} {@var{C} =} mat2cell (@var{A}, @var{m}, @var{n})\n\
+@deftypefnx {Loadable Function} {@var{C} =} mat2cell (@var{A}, @var{d1}, @var{d2}, @dots{})\n\
+@deftypefnx {Loadable Function} {@var{C} =} mat2cell (@var{A}, @var{r})\n\
+Convert the matrix @var{A} to a cell array.  If @var{A} is 2-D, then\n\
+it is required that @code{sum (@var{m}) == size (@var{A}, 1)} and\n\
+@code{sum (@var{n}) == size (@var{A}, 2)}.  Similarly, if @var{A} is\n\
+multi-dimensional and the number of dimensional arguments is equal\n\
+to the dimensions of @var{A}, then it is required that @code{sum (@var{di})\n\
+== size (@var{A}, i)}.\n\
 \n\
 Given a single dimensional argument @var{r}, the other dimensional\n\
-arguments are assumed to equal @code{size (@var{a},@var{i})}.\n\
+arguments are assumed to equal @code{size (@var{A},@var{i})}.\n\
 \n\
 An example of the use of mat2cell is\n\
 \n\
 @example\n\
 mat2cell (reshape(1:16,4,4),[3,1],[3,1])\n\
 @result{} @{\n\
   [1,1] =\n\
 \n\
@@ -1473,23 +1473,23 @@ slicing is done along the first non-sing
       octave_value x = args(0);
       Array<octave_idx_type> lb = args(1).octave_idx_type_vector_value ();
       Array<octave_idx_type> ub = args(2).octave_idx_type_vector_value ();
       int dim = -1;
       if (nargin == 4)
         {
           dim = args(3).int_value () - 1;
           if (dim < 0)
-            error ("cellslices: dim must be a valid dimension");
+            error ("cellslices: DIM must be a valid dimension");
         }
 
       if (! error_state)
         {
           if (lb.length () != ub.length ())
-            error ("cellslices: the lengths of lb and ub must match");
+            error ("cellslices: the lengths of LB and UB must match");
           else
             {
               Cell retcell;
               if (! x.is_sparse_type () && x.is_matrix_type ())
                 {
                   // specialize for some dense arrays.
                   if (x.is_bool_type ())
                     retcell = do_cellslices_nda (x.bool_array_value (), lb, ub, dim);
@@ -1563,21 +1563,24 @@ slicing is done along the first non-sing
 %! c = cellslices (m, [1, 2], [2, 3], 2);
 %! assert (c, {[1, 2; 5, 6; 9, 10], [2, 3; 6, 7; 10, 11]});
 */
 
 DEFUN_DLD (cellindexmat, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{y} =} cellindexmat (@var{x}, @var{varargin})\n\
 Given a cell array of matrices @var{x}, this function computes\n\
+\n\
 @example\n\
+@group\n\
   Y = cell (size (X));\n\
   for i = 1:numel (X)\n\
     Y@{i@} = X@{i@}(varargin@{:@});\n\
   endfor\n\
+@end group\n\
 @end example\n\
 @seealso{cellfun, cellslices}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () >= 1)
     {
       if (args(0).is_cell ())
@@ -1594,15 +1597,15 @@ Given a cell array of matrices @var{x}, 
               y(i) = tmp.do_index_op (idx);
               if (error_state)
                 break;
             }
 
           retval = y;
         }
       else
-        error ("cellindexmat: first argument must be a cell");
+        error ("cellindexmat: X must be a cell");
     }
   else
     print_usage ();
 
   return retval;
 }
diff --git a/src/DLD-FUNCTIONS/chol.cc b/src/DLD-FUNCTIONS/chol.cc
--- a/src/DLD-FUNCTIONS/chol.cc
+++ b/src/DLD-FUNCTIONS/chol.cc
@@ -57,78 +57,78 @@ static octave_value
 get_chol_l (const CHOLT& fact)
 {
   return octave_value (fact.chol_matrix ().transpose (), 
                        MatrixType (MatrixType::Lower));
 }
 
 DEFUN_DLD (chol, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{r} =} chol (@var{a})\n\
-@deftypefnx {Loadable Function} {[@var{r}, @var{p}] =} chol (@var{a})\n\
-@deftypefnx {Loadable Function} {[@var{r}, @var{p}, @var{q}] =} chol (@var{s})\n\
-@deftypefnx {Loadable Function} {[@var{r}, @var{p}, @var{q}] =} chol (@var{s}, 'vector')\n\
-@deftypefnx {Loadable Function} {[@var{l}, @dots{}] =} chol (@dots{}, 'lower')\n\
+@deftypefn  {Loadable Function} {@var{R} =} chol (@var{A})\n\
+@deftypefnx {Loadable Function} {[@var{R}, @var{p}] =} chol (@var{A})\n\
+@deftypefnx {Loadable Function} {[@var{R}, @var{p}, @var{Q}] =} chol (@var{S})\n\
+@deftypefnx {Loadable Function} {[@var{R}, @var{p}, @var{Q}] =} chol (@var{S}, 'vector')\n\
+@deftypefnx {Loadable Function} {[@var{L}, @dots{}] =} chol (@dots{}, 'lower')\n\
 @cindex Cholesky factorization\n\
-Compute the Cholesky factor, @var{r}, of the symmetric positive definite\n\
-matrix @var{a}, where\n\
+Compute the Cholesky factor, @var{R}, of the symmetric positive definite\n\
+matrix @var{A}, where\n\
 @tex\n\
 $ R^T R = A $.\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
-@var{r}' * @var{r} = @var{a}.\n\
+@var{R}' * @var{R} = @var{A}.\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 \n\
-Called with one output argument @code{chol} fails if @var{a} or @var{s} is\n\
+Called with one output argument @code{chol} fails if @var{A} or @var{S} is\n\
 not positive definite.  With two or more output arguments @var{p} flags\n\
 whether the matrix was positive definite and @code{chol} does not fail.  A\n\
-zero value indicated that the matrix was positive definite and the @var{r}\n\
+zero value indicated that the matrix was positive definite and the @var{R}\n\
 gives the factorization, and @var{p} will have a positive value otherwise.\n\
 \n\
 If called with 3 outputs then a sparsity preserving row/column permutation\n\
-is applied to @var{a} prior to the factorization.  That is @var{r}\n\
-is the factorization of @code{@var{a}(@var{q},@var{q})} such that\n\
+is applied to @var{A} prior to the factorization.  That is @var{R}\n\
+is the factorization of @code{@var{A}(@var{Q},@var{Q})} such that\n\
 @tex\n\
 $ R^T R = Q^T A Q$.\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
-@var{r}' * @var{r} = @var{q}' * @var{a} * @var{q}.\n\
+@var{R}' * @var{R} = @var{Q}' * @var{A} * @var{Q}.\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 \n\
 The sparsity preserving permutation is generally returned as a matrix.\n\
-However, given the flag 'vector', @var{q} will be returned as a vector\n\
+However, given the flag 'vector', @var{Q} will be returned as a vector\n\
 such that\n\
 @tex\n\
 $ R^T R = A (Q, Q)$.\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
-@var{r}' * @var{r} = a (@var{q}, @var{q}).\n\
+@var{R}' * @var{R} = @var{A}(@var{Q}, @var{Q}).\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 \n\
 Called with either a sparse or full matrix and using the 'lower' flag,\n\
 @code{chol} returns the lower triangular factorization such that\n\
 @tex\n\
 $ L L^T = A $.\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
-@var{l} * @var{l}' = @var{a}.\n\
+@var{L} * @var{L}' = @var{A}.\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 \n\
 In general the lower triangular factorization is significantly faster for\n\
 sparse matrices.\n\
 @seealso{cholinv, chol2inv}\n\
 @end deftypefn")
@@ -202,17 +202,17 @@ sparse matrices.\n\
                     {
                       retval(1) = fact.P();
                       if (LLt)
                         retval(0) = fact.L();
                       else
                         retval(0) = fact.R();
                     }
                   else
-                    error ("chol: matrix not positive definite");
+                    error ("chol: input matrix must be positive definite");
                 }
             }
           else if (arg.is_complex_type ())
             {
               SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
               if (! error_state)
                 {
@@ -231,17 +231,17 @@ sparse matrices.\n\
                     {
                       retval(1) = fact.P();
                       if (LLt)
                         retval(0) = fact.L();
                       else
                         retval(0) = fact.R();
                     }
                   else
-                    error ("chol: matrix not positive definite");
+                    error ("chol: input matrix must be positive definite");
                 }
             }
           else
             gripe_wrong_type_arg ("chol", arg);
         }
       else if (arg.is_single_type ())
         {
           if (arg.is_real_type ())
@@ -256,17 +256,17 @@ sparse matrices.\n\
                     {
                       retval(1) = info;
                       if (LLt)
                         retval(0) = get_chol_l (fact);
                       else
                         retval(0) = get_chol_r (fact);
                     }
                   else
-                    error ("chol: matrix not positive definite");
+                    error ("chol: input matrix must be positive definite");
                 }
             }
           else if (arg.is_complex_type ())
             {
               FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
               if (! error_state)
                 {
@@ -276,17 +276,17 @@ sparse matrices.\n\
                     {
                       retval(1) = info;
                       if (LLt)
                         retval(0) = get_chol_l (fact);
                       else
                         retval(0) = get_chol_r (fact);
                     }
                   else
-                    error ("chol: matrix not positive definite");
+                    error ("chol: input matrix must be positive definite");
                 }
             }
           else
             gripe_wrong_type_arg ("chol", arg);
         }
       else
         {
           if (arg.is_real_type ())
@@ -301,17 +301,17 @@ sparse matrices.\n\
                     {
                       retval(1) = info;
                       if (LLt)
                         retval(0) = get_chol_l (fact);
                       else
                         retval(0) = get_chol_r (fact);
                     }
                   else
-                    error ("chol: matrix not positive definite");
+                    error ("chol: input matrix must be positive definite");
                 }
             }
           else if (arg.is_complex_type ())
             {
               ComplexMatrix m = arg.complex_matrix_value ();
 
               if (! error_state)
                 {
@@ -321,17 +321,17 @@ sparse matrices.\n\
                     {
                       retval(1) = info;
                       if (LLt)
                         retval(0) = get_chol_l (fact);
                       else
                         retval(0) = get_chol_r (fact);
                     }
                   else
-                    error ("chol: matrix not positive definite");
+                    error ("chol: input matrix must be positive definite");
                 }
             }
           else
             gripe_wrong_type_arg ("chol", arg);
         }
     }
 
   return retval;
@@ -346,20 +346,20 @@ sparse matrices.\n\
 %!error chol ([1, 2; 3, 4; 5, 6]);
 %!error <Invalid call to chol.*> chol ();
 %!error <unexpected second or third input.*> chol (1, 2);
 
  */
 
 DEFUN_DLD (cholinv, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} cholinv (@var{a})\n\
-Use the Cholesky factorization to compute the inverse of the\n\
-symmetric positive definite matrix @var{a}.\n\
-@seealso{chol, chol2inv}\n\
+@deftypefn {Loadable Function} {} cholinv (@var{A})\n\
+Use the Cholesky@tie{}factorization to compute the inverse of the\n\
+symmetric positive definite matrix @var{A}.\n\
+@seealso{chol, chol2inv, inv}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
@@ -380,31 +380,31 @@ symmetric positive definite matrix @var{
 
                   if (! error_state)
                     {
                       octave_idx_type info;
                       SparseCHOL chol (m, info);
                       if (info == 0)
                         retval = chol.inverse ();
                       else
-                        error ("cholinv: matrix not positive definite");
+                        error ("cholinv: A must be positive definite");
                     }
                 }
               else if (arg.is_complex_type ())
                 {
                   SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
                   if (! error_state)
                     {
                       octave_idx_type info;
                       SparseComplexCHOL chol (m, info);
                       if (info == 0)
                         retval = chol.inverse ();
                       else
-                        error ("cholinv: matrix not positive definite");
+                        error ("cholinv: A must be positive definite");
                     }
                 }
               else
                 gripe_wrong_type_arg ("cholinv", arg);
             }
           else if (arg.is_single_type ())
             {
               if (arg.is_real_type ())
@@ -413,31 +413,31 @@ symmetric positive definite matrix @var{
 
                   if (! error_state)
                     {
                       octave_idx_type info;
                       FloatCHOL chol (m, info);
                       if (info == 0)
                         retval = chol.inverse ();
                       else
-                        error ("cholinv: matrix not positive definite");
+                        error ("cholinv: A must be positive definite");
                     }
                 }
               else if (arg.is_complex_type ())
                 {
                   FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
                   if (! error_state)
                     {
                       octave_idx_type info;
                       FloatComplexCHOL chol (m, info);
                       if (info == 0)
                         retval = chol.inverse ();
                       else
-                        error ("cholinv: matrix not positive definite");
+                        error ("cholinv: A must be positive definite");
                     }
                 }
               else
                 gripe_wrong_type_arg ("chol", arg);
             }
           else
             {
               if (arg.is_real_type ())
@@ -446,31 +446,31 @@ symmetric positive definite matrix @var{
 
                   if (! error_state)
                     {
                       octave_idx_type info;
                       CHOL chol (m, info);
                       if (info == 0)
                         retval = chol.inverse ();
                       else
-                        error ("cholinv: matrix not positive definite");
+                        error ("cholinv: A must be positive definite");
                     }
                 }
               else if (arg.is_complex_type ())
                 {
                   ComplexMatrix m = arg.complex_matrix_value ();
 
                   if (! error_state)
                     {
                       octave_idx_type info;
                       ComplexCHOL chol (m, info);
                       if (info == 0)
                         retval = chol.inverse ();
                       else
-                        error ("cholinv: matrix not positive definite");
+                        error ("cholinv: A must be positive definite");
                     }
                 }
               else
                 gripe_wrong_type_arg ("chol", arg);
             }
         }
     }
   else
@@ -496,23 +496,23 @@ symmetric positive definite matrix @var{
 %!testif HAVE_CHOLMOD
 %! Ainv4 = spcholinv(sparse(A));
 %! assert (norm(Ainv-Ainv4),0,1e-10)
 
 */
 
 DEFUN_DLD (chol2inv, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} chol2inv (@var{u})\n\
+@deftypefn {Loadable Function} {} chol2inv (@var{U})\n\
 Invert a symmetric, positive definite square matrix from its Cholesky\n\
-decomposition, @var{u}.  Note that @var{u} should be an upper-triangular\n\
-matrix with positive diagonal elements.  @code{chol2inv (@var{u})}\n\
-provides @code{inv (@var{u}'*@var{u})} but it is much faster than\n\
+decomposition, @var{U}.  Note that @var{U} should be an upper-triangular\n\
+matrix with positive diagonal elements.  @code{chol2inv (@var{U})}\n\
+provides @code{inv (@var{U}'*@var{U})} but it is much faster than\n\
 using @code{inv}.\n\
-@seealso{chol, cholinv}\n\
+@seealso{chol, cholinv, inv}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
@@ -589,17 +589,17 @@ using @code{inv}.\n\
     print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (cholupdate, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{R1}, @var{info}] =} cholupdate (@var{R}, @var{u}, @var{op})\n\
-Update or downdate a Cholesky factorization.  Given an upper triangular\n\
+Update or downdate a Cholesky@tie{}factorization.  Given an upper triangular\n\
 matrix @var{R} and a column vector @var{u}, attempt to determine another\n\
 upper triangular matrix @var{R1} such that\n\
 @itemize @bullet\n\
 @item\n\
 @var{R1}'*@var{R1} = @var{R}'*@var{R} + @var{u}*@var{u}'\n\
 if @var{op} is \"+\"\n\
 \n\
 @item\n\
@@ -720,19 +720,19 @@ If @var{info} is not present, an error m
             if (nargout > 1)
               retval(1) = err;
             else if (err == 1)
               error ("cholupdate: downdate violates positiveness");
             else if (err == 2)
               error ("cholupdate: singular matrix");
           }
         else
-          error ("cholupdate: dimension mismatch");
+          error ("cholupdate: dimension mismatch between R and U");
       else
-        error ("cholupdate: op must be \"+\" or \"-\"");
+        error ("cholupdate: OP must be \"+\" or \"-\"");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -808,17 +808,18 @@ If @var{info} is not present, an error m
 %! R1 = cholupdate(R1,single(uc),"-");
 %! 
 %! assert(norm(triu(R1)-R1,Inf) == 0)
 %! assert(norm(R1 - R,Inf) < 2e1*eps('single'))
 */
 
 DEFUN_DLD (cholinsert, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{R1}, @var{info}] =} cholinsert (@var{R}, @var{j}, @var{u})\n\
+@deftypefn  {Loadable Function} {@var{R1} =} cholinsert (@var{R}, @var{j}, @var{u})\n\
+@deftypefnx {Loadable Function} {[@var{R1}, @var{info}] =} cholinsert (@var{R}, @var{j}, @var{u})\n\
 Given a Cholesky@tie{}factorization of a real symmetric or complex Hermitian\n\
 positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper\n\
 triangular, return the Cholesky@tie{}factorization of\n\
 @var{A1}, where @w{A1(p,p) = A}, @w{A1(:,j) = A1(j,:)' = u} and\n\
 @w{p = [1:j-1,j+1:n+1]}.  @w{u(j)} should be positive.\n\
 On return, @var{info} is set to\n\
 @itemize\n\
 @item 0 if the insertion was successful,\n\
@@ -917,20 +918,20 @@ If @var{info} is not present, an error m
               else if (err == 1)
                 error ("cholinsert: insertion violates positiveness");
               else if (err == 2)
                 error ("cholinsert: singular matrix");
               else if (err == 3)
                 error ("cholinsert: diagonal element must be real");
             }
           else
-            error ("cholinsert: index out of range");
+            error ("cholinsert: index J out of range");
         }
       else
-        error ("cholinsert: dimension mismatch");
+        error ("cholinsert: dimension mismatch between R and U");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -1076,20 +1077,20 @@ triangular, return the Cholesky@tie{}fac
                       fact.set (R);
                       fact.delete_sym (j-1);
 
                       retval(0) = get_chol_r (fact);
                     }
                 }
             }
           else
-            error ("choldelete: index out of range");
+            error ("choldelete: index J out of range");
         }
       else
-        error ("choldelete: dimension mismatch");
+        error ("choldelete: matrix R must be square");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -1217,20 +1218,20 @@ triangular, return the Cholesky@tie{}fac
                       fact.set (R);
                       fact.shift_sym (i-1, j-1);
 
                       retval(0) = get_chol_r (fact);
                     }
                 }
             }
           else
-            error ("cholshift: index out of range");
+            error ("cholshift: index I or J is out of range");
         }
       else
-        error ("cholshift: dimension mismatch");
+        error ("cholshift: R must be a square matrix");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/src/DLD-FUNCTIONS/colamd.cc b/src/DLD-FUNCTIONS/colamd.cc
--- a/src/DLD-FUNCTIONS/colamd.cc
+++ b/src/DLD-FUNCTIONS/colamd.cc
@@ -205,81 +205,81 @@ coletree (const octave_idx_type *ridx, c
               root[cset] = col;
             }
         }
     }
 }
 
 DEFUN_DLD (colamd, args, nargout,
     "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{p} =} colamd (@var{s})\n\
-@deftypefnx {Loadable Function} {@var{p} =} colamd (@var{s}, @var{knobs})\n\
-@deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} colamd (@var{s})\n\
-@deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} colamd (@var{s}, @var{knobs})\n\
+@deftypefn  {Loadable Function} {@var{p} =} colamd (@var{S})\n\
+@deftypefnx {Loadable Function} {@var{p} =} colamd (@var{S}, @var{knobs})\n\
+@deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} colamd (@var{S})\n\
+@deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} colamd (@var{S}, @var{knobs})\n\
 \n\
 Column approximate minimum degree permutation.\n\
-@code{@var{p} = colamd (@var{s})} returns the column approximate minimum\n\
-degree permutation vector for the sparse matrix @var{s}.  For a\n\
-non-symmetric matrix @var{s}, @code{@var{s} (:,@var{p})} tends to have\n\
-sparser LU factors than @var{s}.  The Cholesky factorization of\n\
-@code{@var{s}(:,@var{p})' * @var{s} (:,@var{p})} also tends to be sparser\n\
-than that of @code{@var{s}' * @var{s}}.\n\
+@code{@var{p} = colamd (@var{S})} returns the column approximate minimum\n\
+degree permutation vector for the sparse matrix @var{S}.  For a\n\
+non-symmetric matrix @var{S}, @code{@var{S}(:,@var{p})} tends to have\n\
+sparser LU@tie{}factors than @var{S}.  The Cholesky@tie{}factorization of\n\
+@code{@var{S}(:,@var{p})' * @var{S}(:,@var{p})} also tends to be sparser\n\
+than that of @code{@var{S}' * @var{S}}.\n\
 \n\
-@var{knobs} is an optional one- to three-element input vector.  If @var{s} is\n\
+@var{knobs} is an optional one- to three-element input vector.  If @var{S} is\n\
 m-by-n, then rows with more than @code{max(16,@var{knobs}(1)*sqrt(n))}\n\
 entries are ignored.  Columns with more than\n\
-@code{max(16,knobs(2)*sqrt(min(m,n)))} entries are removed prior to\n\
+@code{max(16,@var{knobs}(2)*sqrt(min(m,n)))} entries are removed prior to\n\
 ordering, and ordered last in the output permutation @var{p}.  Only\n\
-completely dense rows or columns are removed if @code{@var{knobs} (1)} and\n\
-@code{@var{knobs} (2)} are < 0, respectively.  If @code{@var{knobs} (3)} is\n\
+completely dense rows or columns are removed if @code{@var{knobs}(1)} and\n\
+@code{@var{knobs}(2)} are < 0, respectively.  If @code{@var{knobs}(3)} is\n\
 nonzero, @var{stats} and @var{knobs} are printed.  The default is\n\
 @code{@var{knobs} = [10 10 0]}.  Note that @var{knobs} differs from earlier\n\
 versions of colamd\n\
 \n\
 @var{stats} is an optional 20-element output vector that provides data\n\
-about the ordering and the validity of the input matrix @var{s}.  Ordering\n\
-statistics are in @code{@var{stats} (1:3)}.  @code{@var{stats} (1)} and\n\
-@code{@var{stats} (2)} are the number of dense or empty rows and columns\n\
-ignored by @sc{colamd} and @code{@var{stats} (3)} is the number of garbage\n\
+about the ordering and the validity of the input matrix @var{S}.  Ordering\n\
+statistics are in @code{@var{stats}(1:3)}.  @code{@var{stats}(1)} and\n\
+@code{@var{stats}(2)} are the number of dense or empty rows and columns\n\
+ignored by @sc{colamd} and @code{@var{stats}(3)} is the number of garbage\n\
 collections performed on the internal data structure used by @sc{colamd}\n\
-(roughly of size @code{2.2 * nnz(@var{s}) + 4 * @var{m} + 7 * @var{n}}\n\
+(roughly of size @code{2.2 * nnz(@var{S}) + 4 * @var{m} + 7 * @var{n}}\n\
 integers).\n\
 \n\
 Octave built-in functions are intended to generate valid sparse matrices,\n\
 with no duplicate entries, with ascending row indices of the nonzeros\n\
 in each column, with a non-negative number of entries in each column (!)\n\
 and so on.  If a matrix is invalid, then @sc{colamd} may or may not be able\n\
 to continue.  If there are duplicate entries (a row index appears two or\n\
 more times in the same column) or if the row indices in a column are out\n\
 of order, then @sc{colamd} can correct these errors by ignoring the duplicate\n\
 entries and sorting each column of its internal copy of the matrix\n\
-@var{s} (the input matrix @var{s} is not repaired, however).  If a matrix\n\
+@var{S} (the input matrix @var{S} is not repaired, however).  If a matrix\n\
 is invalid in other ways then @sc{colamd} cannot continue, an error message\n\
 is printed, and no output arguments (@var{p} or @var{stats}) are returned.\n\
 @sc{colamd} is thus a simple way to check a sparse matrix to see if it's\n\
 valid.\n\
 \n\
-@code{@var{stats} (4:7)} provide information if COLAMD was able to\n\
-continue.  The matrix is OK if @code{@var{stats} (4)} is zero, or 1 if\n\
-invalid.  @code{@var{stats} (5)} is the rightmost column index that is\n\
+@code{@var{stats}(4:7)} provide information if COLAMD was able to\n\
+continue.  The matrix is OK if @code{@var{stats}(4)} is zero, or 1 if\n\
+invalid.  @code{@var{stats}(5)} is the rightmost column index that is\n\
 unsorted or contains duplicate entries, or zero if no such column exists.\n\
-@code{@var{stats} (6)} is the last seen duplicate or out-of-order row\n\
-index in the column index given by @code{@var{stats} (5)}, or zero if no\n\
-such row index exists.  @code{@var{stats} (7)} is the number of duplicate\n\
-or out-of-order row indices.  @code{@var{stats} (8:20)} is always zero in\n\
+@code{@var{stats}(6)} is the last seen duplicate or out-of-order row\n\
+index in the column index given by @code{@var{stats}(5)}, or zero if no\n\
+such row index exists.  @code{@var{stats}(7)} is the number of duplicate\n\
+or out-of-order row indices.  @code{@var{stats}(8:20)} is always zero in\n\
 the current version of @sc{colamd} (reserved for future use).\n\
 \n\
 The ordering is followed by a column elimination tree post-ordering.\n\
 \n\
 The authors of the code itself are Stefan I. Larimore and Timothy A.\n\
 Davis @email{davis@@cise.ufl.edu}, University of Florida.  The algorithm was\n\
 developed in collaboration with John Gilbert, Xerox PARC, and Esmond\n\
 Ng, Oak Ridge National Laboratory.  (see\n\
 @url{http://www.cise.ufl.edu/research/sparse/colamd})\n\
-@seealso{colperm, symamd}\n\
+@seealso{colperm, symamd, ccolamd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
 #ifdef HAVE_COLAMD
 
   int nargin = args.length ();
   int spumoni = 0;
@@ -445,71 +445,70 @@ Ng, Oak Ridge National Laboratory.  (see
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (symamd, args, nargout,
     "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{p} =} symamd (@var{s})\n\
-@deftypefnx {Loadable Function} {@var{p} =} symamd (@var{s}, @var{knobs})\n\
-@deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} symamd (@var{s})\n\
-@deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} symamd (@var{s}, @var{knobs})\n\
+@deftypefn  {Loadable Function} {@var{p} =} symamd (@var{S})\n\
+@deftypefnx {Loadable Function} {@var{p} =} symamd (@var{S}, @var{knobs})\n\
+@deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} symamd (@var{S})\n\
+@deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} symamd (@var{S}, @var{knobs})\n\
 \n\
-For a symmetric positive definite matrix @var{s}, returns the permutation\n\
-vector p such that @code{@var{s} (@var{p}, @var{p})} tends to have a\n\
-sparser Cholesky factor than @var{s}.  Sometimes SYMAMD works well for\n\
-symmetric indefinite matrices too.  The matrix @var{s} is assumed to be\n\
-symmetric; only the strictly lower triangular part is referenced.  @var{s}\n\
-must be square.\n\
+For a symmetric positive definite matrix @var{S}, returns the permutation\n\
+vector p such that @code{@var{S}(@var{p}, @var{p})} tends to have a\n\
+sparser Cholesky@tie{}factor than @var{S}.  Sometimes @code{symamd} works\n\
+well for symmetric indefinite matrices too.  The matrix @var{S} is assumed\n\
+to be symmetric; only the strictly lower triangular part is referenced.  \n\
+@var{S} must be square.\n\
 \n\
-@var{knobs} is an optional one- to two-element input vector.  If @var{s} is\n\
+@var{knobs} is an optional one- to two-element input vector.  If @var{S} is\n\
 n-by-n, then rows and columns with more than\n\
 @code{max(16,@var{knobs}(1)*sqrt(n))} entries are removed prior to ordering,\n\
 and ordered last in the output permutation @var{p}.  No rows/columns are\n\
 removed if @code{@var{knobs}(1) < 0}.  If @code{@var{knobs} (2)} is nonzero,\n\
 @code{stats} and @var{knobs} are printed.  The default is @code{@var{knobs} \n\
 = [10 0]}.  Note that @var{knobs} differs from earlier versions of symamd.\n\
 \n\
 @var{stats} is an optional 20-element output vector that provides data\n\
-about the ordering and the validity of the input matrix @var{s}.  Ordering\n\
-statistics are in @code{@var{stats} (1:3)}.  @code{@var{stats} (1) =\n\
-@var{stats} (2)} is the number of dense or empty rows and columns\n\
-ignored by SYMAMD and @code{@var{stats} (3)} is the number of garbage\n\
+about the ordering and the validity of the input matrix @var{S}.  Ordering\n\
+statistics are in @code{@var{stats}(1:3)}.  @code{@var{stats}(1) =\n\
+@var{stats}(2)} is the number of dense or empty rows and columns\n\
+ignored by SYMAMD and @code{@var{stats}(3)} is the number of garbage\n\
 collections performed on the internal data structure used by SYMAMD\n\
-(roughly of size @code{8.4 * nnz (tril (@var{s}, -1)) + 9 * @var{n}}\n\
+(roughly of size @code{8.4 * nnz (tril (@var{S}, -1)) + 9 * @var{n}}\n\
 integers).\n\
 \n\
 Octave built-in functions are intended to generate valid sparse matrices,\n\
 with no duplicate entries, with ascending row indices of the nonzeros\n\
 in each column, with a non-negative number of entries in each column (!)\n\
 and so on.  If a matrix is invalid, then SYMAMD may or may not be able\n\
 to continue.  If there are duplicate entries (a row index appears two or\n\
 more times in the same column) or if the row indices in a column are out\n\
 of order, then SYMAMD can correct these errors by ignoring the duplicate\n\
 entries and sorting each column of its internal copy of the matrix S (the\n\
 input matrix S is not repaired, however).  If a matrix is invalid in\n\
 other ways then SYMAMD cannot continue, an error message is printed, and\n\
 no output arguments (@var{p} or @var{stats}) are returned.  SYMAMD is\n\
 thus a simple way to check a sparse matrix to see if it's valid.\n\
 \n\
-@code{@var{stats} (4:7)} provide information if SYMAMD was able to\n\
+@code{@var{stats}(4:7)} provide information if SYMAMD was able to\n\
 continue.  The matrix is OK if @code{@var{stats} (4)} is zero, or 1\n\
-if invalid.  @code{@var{stats} (5)} is the rightmost column index that\n\
+if invalid.  @code{@var{stats}(5)} is the rightmost column index that\n\
 is unsorted or contains duplicate entries, or zero if no such column\n\
-exists.  @code{@var{stats} (6)} is the last seen duplicate or out-of-order\n\
-row index in the column index given by @code{@var{stats} (5)}, or zero\n\
-if no such row index exists.  @code{@var{stats} (7)} is the number of\n\
-duplicate or out-of-order row indices.  @code{@var{stats} (8:20)} is\n\
+exists.  @code{@var{stats}(6)} is the last seen duplicate or out-of-order\n\
+row index in the column index given by @code{@var{stats}(5)}, or zero\n\
+if no such row index exists.  @code{@var{stats}(7)} is the number of\n\
+duplicate or out-of-order row indices.  @code{@var{stats}(8:20)} is\n\
 always zero in the current version of SYMAMD (reserved for future use).\n\
 \n\
 The ordering is followed by a column elimination tree post-ordering.\n\
 \n\
-\n\
 The authors of the code itself are Stefan I. Larimore and Timothy A.\n\
 Davis @email{davis@@cise.ufl.edu}, University of Florida.  The algorithm was\n\
 developed in collaboration with John Gilbert, Xerox PARC, and Esmond\n\
 Ng, Oak Ridge National Laboratory.  (see\n\
 @url{http://www.cise.ufl.edu/research/sparse/colamd})\n\
 @seealso{colperm, colamd}\n\
 @end deftypefn")
 {
@@ -582,17 +581,17 @@ Ng, Oak Ridge National Laboratory.  (see
           n_col = sm.cols ();
           nnz = sm.nnz ();
           ridx = sm.xridx ();
           cidx = sm.xcidx ();
         }
 
       if (n_row != n_col)
         {
-          error ("symamd: matrix must be square");
+          error ("symamd: matrix S must be square");
           return retval;
         }
 
       // Allocate workspace for symamd
       OCTAVE_LOCAL_BUFFER (octave_idx_type, perm, n_col+1);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, COLAMD_STATS);
       if (!SYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats, &calloc, &free))
         {
@@ -642,27 +641,27 @@ Ng, Oak Ridge National Laboratory.  (see
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (etree, args, nargout,
     "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{p} =} etree (@var{s})\n\
-@deftypefnx {Loadable Function} {@var{p} =} etree (@var{s}, @var{typ})\n\
-@deftypefnx {Loadable Function} {[@var{p}, @var{q}] =} etree (@var{s}, @var{typ})\n\
+@deftypefn  {Loadable Function} {@var{p} =} etree (@var{S})\n\
+@deftypefnx {Loadable Function} {@var{p} =} etree (@var{S}, @var{typ})\n\
+@deftypefnx {Loadable Function} {[@var{p}, @var{q}] =} etree (@var{S}, @var{typ})\n\
 \n\
-Returns the elimination tree for the matrix @var{s}.  By default @var{s}\n\
+Returns the elimination tree for the matrix @var{S}.  By default @var{S}\n\
 is assumed to be symmetric and the symmetric elimination tree is\n\
 returned.  The argument @var{typ} controls whether a symmetric or\n\
 column elimination tree is returned.  Valid values of @var{typ} are\n\
 'sym' or 'col', for symmetric or column elimination tree respectively\n\
 \n\
-Called with a second argument, @dfn{etree} also returns the postorder\n\
+Called with a second argument, @code{etree} also returns the postorder\n\
 permutations on the tree.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargout > 2 || nargin < 1 || nargin > 2)
@@ -694,43 +693,43 @@ permutations on the tree.\n\
               nnz = sm.nnz ();
               ridx = sm.xridx ();
               cidx = sm.xcidx ();
             }
 
         }
       else
         {
-          error ("etree: must be called with a sparse matrix");
+          error ("etree: S must be a sparse matrix");
           return retval;
         }
 
       if (nargin == 2)
         {
           if (args(1).is_string ())
             {
               std::string str = args(1).string_value ();
               if (str.find ("C") == 0 || str.find ("c") == 0)
                 is_sym = false;
             }
           else
             {
-              error ("etree: second argument must be a string");
+              error ("etree: TYP must be a string");
               return retval;
             }
         }
 
       // column elimination tree post-ordering (reuse variables)
       OCTAVE_LOCAL_BUFFER (octave_idx_type, etree, n_col + 1);
 
       if (is_sym)
         {
           if (n_row != n_col)
             {
-              error ("etree: matrix is marked as symmetric, but not square");
+              error ("etree: S is marked as symmetric, but is not square");
               return retval;
             }
 
           symetree (ridx, cidx, etree, 0, n_col);
         }
       else
         {
           OCTAVE_LOCAL_BUFFER (octave_idx_type, colbeg, n_col);
diff --git a/src/DLD-FUNCTIONS/colloc.cc b/src/DLD-FUNCTIONS/colloc.cc
--- a/src/DLD-FUNCTIONS/colloc.cc
+++ b/src/DLD-FUNCTIONS/colloc.cc
@@ -50,49 +50,49 @@ Polynomial Approximation}.\n\
   if (nargin < 1 || nargin > 3)
     {
       print_usage ();
       return retval;
     }
 
   if (! args(0).is_scalar_type ())
     {
-      error ("colloc: first argument must be a scalar");
+      error ("colloc: N must be a scalar");
       return retval;
     }
 
   double tmp = args(0).double_value ();
 
   if (error_state)
     return retval;
 
   if (xisnan (tmp))
     {
-      error ("colloc: NaN is invalid as NCOL");
+      error ("colloc: N cannot be NaN");
       return retval;
     }
 
   octave_idx_type ncol = NINTbig (tmp);
   if (ncol < 0)
     {
-      error ("colloc: first argument must be non-negative");
+      error ("colloc: N must be positive");
       return retval;
     }
 
   octave_idx_type ntot = ncol;
   octave_idx_type left = 0;
   octave_idx_type right = 0;
 
   for (int i = 1; i < nargin; i++)
     {
       if (args(i).is_defined ())
         {
           if (! args(i).is_string ())
             {
-              error ("colloc: expecting string argument");
+              error ("colloc: expecting string argument \"left\" or \"right\"");
               return retval;
             }
 
           std::string s = args(i).string_value ();
 
           if ((s.length () == 1 && (s[0] == 'R' || s[0] == 'r'))
               || s == "right")
             {
diff --git a/src/DLD-FUNCTIONS/conv2.cc b/src/DLD-FUNCTIONS/conv2.cc
--- a/src/DLD-FUNCTIONS/conv2.cc
+++ b/src/DLD-FUNCTIONS/conv2.cc
@@ -49,38 +49,38 @@ enum Shape { SHAPE_FULL, SHAPE_SAME, SHA
 %!assert (conv2 (1:3, 1:2, [1,2;3,4;5,6], "full"),
 %!        conv2 (1:3, 1:2, [1,2;3,4;5,6]));
 
 */
 
 
 DEFUN_DLD (conv2, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} conv2 (@var{a}, @var{b})\n\
+@deftypefn  {Loadable Function} {} conv2 (@var{A}, @var{B})\n\
 @deftypefnx {Loadable Function} {} conv2 (@var{v1}, @var{v2}, @var{m})\n\
 @deftypefnx {Loadable Function} {} conv2 (@dots{}, @var{shape})\n\
-Return the 2-D convolution of @var{a} and @var{b}.  The size of the result\n\
+Return the 2-D convolution of @var{A} and @var{B}.  The size of the result\n\
 is determined by the optional @var{shape} argument which takes the following\n\
 values\n\
 \n\
 @table @asis\n\
 @item @var{shape} = \"full\"\n\
 Return the full convolution.  (default)\n\
 \n\
 @item @var{shape} = \"same\"\n\
-Return the central part of the convolution with the same size as @var{a}.\n\
+Return the central part of the convolution with the same size as @var{A}.\n\
 \n\
 @item @var{shape} = \"valid\"\n\
 Return only the parts which do not include zero-padded edges.\n\
 @end table\n\
 \n\
-When the third argument\n\
-is a matrix, return the convolution of the matrix @var{m} by the vector\n\
-@var{v1} in the column direction and by vector @var{v2} in the row direction\n\
-@seealso{conv, fftconv}\n\
+When the third argument is a matrix, return the convolution of the matrix\n\
+@var{m} by the vector @var{v1} in the column direction and by the vector\n\
+@var{v2} in the row direction\n\
+@seealso{conv, convn}\n\
 @end deftypefn")
 {
   octave_value retval;
   octave_value tmp;
   int nargin = args.length ();
   std::string shape = "full"; //default
   bool separable = false;
   convn_type ct;
@@ -106,17 +106,17 @@ is a matrix, return the convolution of t
   if (shape == "full")
     ct = convn_full;
   else if (shape == "same")
     ct = convn_same;
   else if (shape == "valid")
     ct = convn_valid;
   else
     {
-      error ("conv2: shape type not valid");
+      error ("conv2: SHAPE type not valid");
       print_usage ();
       return retval;
     }
 
    if (separable)
      {
       // If user requests separable, check first two params are vectors
 
@@ -234,32 +234,33 @@ is a matrix, return the convolution of t
 
      } // if (separable)
 
    return retval;
 }
 
 DEFUN_DLD (convn, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {y =} conv2 (@var{a}, @var{b}, @var{shape})\n\
-Return the n-D convolution of @var{a} and @var{b} where the size\n\
-of @var{c} is given by\n\
+@deftypefn {Loadable Function} {@var{C} =} convn (@var{A}, @var{B}, @var{shape})\n\
+Return the n-D convolution of @var{A} and @var{B} where the size\n\
+of @var{C} is given by\n\
 \n\
 @table @asis\n\
 @item @var{shape} = \"full\"\n\
 Return the full convolution.\n\
 \n\
 @item @var{shape} = \"same\"\n\
-Return central part of the convolution with the same size as @var{a}.\n\
+Return central part of the convolution with the same size as @var{A}.\n\
 \n\
 @item @var{shape} = \"valid\"\n\
 Return only the parts which do not include zero-padded edges.\n\
 @end table\n\
 \n\
 By default @var{shape} is @samp{\"full\"}.\n\
+@seealso{conv2, conv}\n\
 @end deftypefn")
 {
   octave_value retval;
   octave_value tmp;
   int nargin = args.length ();
   std::string shape = "full"; //default
   bool separable = false;
   convn_type ct;
@@ -280,17 +281,17 @@ By default @var{shape} is @samp{\"full\"
   if (shape == "full")
     ct = convn_full;
   else if (shape == "same")
     ct = convn_same;
   else if (shape == "valid")
     ct = convn_valid;
   else
     {
-      error ("convn: shape type not valid");
+      error ("convn: SHAPE type not valid");
       print_usage ();
       return retval;
     }
 
   if (args(0).is_single_type () || args(1).is_single_type ())
     {
       if (args(0).is_complex_type () || args(1).is_complex_type ())
         {
diff --git a/src/DLD-FUNCTIONS/convhulln.cc b/src/DLD-FUNCTIONS/convhulln.cc
--- a/src/DLD-FUNCTIONS/convhulln.cc
+++ b/src/DLD-FUNCTIONS/convhulln.cc
@@ -57,17 +57,17 @@ DEFUN_DLD (convhulln, args, nargout,
 @deftypefnx {Loadable Function} {@var{h} =} convhulln (@var{p}, @var{opt})\n\
 @deftypefnx {Loadable Function} {[@var{h}, @var{v}] =} convhulln (@dots{})\n\
 Return an index vector to the points of the enclosing convex hull.\n\
 The input matrix of size [n, dim] contains n points of dimension dim.\n\n\
 If a second optional argument is given, it must be a string or cell array\n\
 of strings containing options for the underlying qhull command.  (See\n\
 the Qhull documentation for the available options.)  The default options\n\
 are \"s Qci Tcv\".\n\
-If the second output @var{V} is requested the volume of the convex hull is\n\
+If the second output @var{v} is requested the volume of the convex hull is\n\
 calculated.\n\n\
 @seealso{convhull, delaunayn}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
 #ifdef HAVE_QHULL
   std::string options;
@@ -86,26 +86,26 @@ calculated.\n\n\
       else if (args(1).is_cell ())
         {
           Cell c = args(1).cell_value ();
           options = "";
           for (octave_idx_type i = 0; i < c.numel (); i++)
             {
               if (! c.elem(i).is_string ())
                 {
-                  error ("convhulln: second argument must be a string or cell array of strings");
+                  error ("convhulln: OPT must be a string or cell array of strings");
                   return retval;
                 }
 
               options = options + c.elem(i).string_value() + " ";
             }
         }
       else
         {
-          error ("convhulln: second argument must be a string or cell array of strings");
+          error ("convhulln: OPT must be a string or cell array of strings");
           return retval;
         }
     }
   else
     // turn on some consistency checks
     options = "s Qci Tcv";
 
   Matrix p (args(0).matrix_value ());
diff --git a/src/DLD-FUNCTIONS/cquad.cc b/src/DLD-FUNCTIONS/cquad.cc
--- a/src/DLD-FUNCTIONS/cquad.cc
+++ b/src/DLD-FUNCTIONS/cquad.cc
@@ -1474,80 +1474,81 @@ downdate (double *c, int n, int d, int *
 
 
 
 /* The actual integration routine.
     */
 
 DEFUN_DLD (cquad, args, nargout, 
 "-*- texinfo -*-\n\
-@deftypefn {Function File} {[@var{int}, @var{err}, @var{nr_points}] =} cquad (@var{f}, @var{a}, @var{b}, @var{tol})\n\
+@deftypefn  {Function File} {[@var{int}, @var{err}, @var{nr_points}] =} cquad (@var{f}, @var{a}, @var{b}, @var{tol})\n\
 @deftypefnx {Function File} {[@var{int}, @var{err}, @var{nr_points}] =} cquad (@var{f}, @var{a}, @var{b}, @var{tol}, @var{sing})\n\
 Numerically evaluates an integral using the doubly-adaptive\n\
-quadrature described by P. Gonnet in @cite{\"Increasing the\n\
-Reliability of Adaptive Quadrature Using Explicit Interpolants\",\n\
-ACM Transactions on Mathematical Software, in Press, 2010}.\n\
+quadrature described by P. Gonnet in @cite{Increasing the\n\
+Reliability of Adaptive Quadrature Using Explicit Interpolants,\n\
+ACM Transactions on Mathematical Software, in Press, 2010.\n\
 The algorithm uses Clenshaw-Curtis quadrature rules of increasing\n\
 degree in each interval and bisects the interval if either the\n\
 function does not appear to be smooth or a rule of maximum\n\
 degree has been reached. The error estimate is computed from the\n\
 L2-norm of the difference between two successive interpolations\n\
 of the integrand over the nodes of the respective quadrature rules.\n\
 \n\
 For example,\n\
 \n\
 @example\n\
-   int = cquad ( f , a , b , 1.0e-6 );\n\
+   int = cquad (f, a, b, 1.0e-6);\n\
 @end example\n\
 \n\
-@noindent computes the integral of a function @var{f} in the interval\n\
-[@var{a},@var{b}] to the relative precision of six\n\
+@noindent\n\
+computes the integral of a function @var{f} in the interval\n\
+[@var{a}, @var{b}] to the relative precision of six\n\
 decimal digits.\n\
 The integrand @var{f} should accept a vector argument and return a vector\n\
 result containing the integrand evaluated at each element of the\n\
-argument, for example\n\
+argument, for example:\n\
 \n\
 @example\n\
-   f = @@(x) x .* sin ( 1 ./ x ) .* sqrt ( abs ( 1 - x ) );\n\
+   f = @@(x) x .* sin (1 ./ x) .* sqrt (abs (1 - x));\n\
 @end example\n\
 \n\
-If the integrand has known singularieites or discontinuities\n\
+If the integrand has known singularities or discontinuities\n\
 in any of its derivatives inside the interval,\n\
 as does the above example at x=1, these can be specified in\n\
 the additional argument @var{sing} as follows\n\
 \n\
 @example\n\
-   int = cquad ( f , a , b , 1.0e-6 , [ 1 ] );\n\
+   int = cquad (f, a, b, 1.0e-6, [ 1 ]);\n\
 @end example\n\
 \n\
 The two additional output variables @var{err} and @var{nr_points}\n\
 return an estimate of the absolute integration error and\n\
 the number of points at which the integrand was evaluated\n\
 respectively.\n\
 If the adaptive integration did not converge, the value of\n\
-@var{err} will be larger than the requested tolerance. It is\n\
+@var{err} will be larger than the requested tolerance.  It is\n\
 therefore recommended to verify this value for difficult\n\
 integrands.\n\
 \n\
 If either @var{a} or @var{b} are @code{+/-Inf}, @code{cquad}\n\
 integrates @var{f} by substituting the variable of integration\n\
 with @code{x=tan(pi/2*u)}.\n\
 \n\
-@code{cquad} is capable of dealing with non-numerical\n\
+@code{cquad} is capable of dealing with non-numeric\n\
 values of the integrand such as @code{NaN}, @code{Inf}\n\
-or @code{-Inf}, as the above example at x=0.\n\
+or @code{-Inf}, as in the above example at x=0.\n\
 If the integral diverges and @code{cquad} detects this, \n\
 a warning is issued and @code{Inf} or @code{-Inf} is returned.\n\
 \n\
 Note that @code{cquad} is a general purpose quadrature algorithm\n\
 and as such may be less efficient for smooth or otherwise\n\
 well-behaved integrand than other methods such as\n\
 @code{quadgk} or @code{trapz}.\n\
 \n\
-@seealso{triplequad, dblquad, quadgk, quadl, quadv, trapz}\n\
+@seealso{quad,quadv,quadl,quadgk,trapz}\n\
 @end deftypefn")
 {
 
   /* Some constants that we will need. */
   static const int n[4] = { 4, 8, 16, 32 };
   static const int skip[4] = { 8, 4, 2, 1 };
   static const int idx[4] = { 0, 5, 14, 31 };
   static const double w = M_SQRT2 / 2;
diff --git a/src/DLD-FUNCTIONS/dasrt.cc b/src/DLD-FUNCTIONS/dasrt.cc
--- a/src/DLD-FUNCTIONS/dasrt.cc
+++ b/src/DLD-FUNCTIONS/dasrt.cc
@@ -203,17 +203,20 @@ dasrt_user_j (const ColumnVector& x, con
     { \
       ::error ("dasrt: " fmt, arg); \
       DASRT_ABORT; \
     } \
   while (0)
 
 DEFUN_DLD (dasrt, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{x}, @var{xdot}, @var{t_out}, @var{istat}, @var{msg}] =} dasrt (@var{fcn} [, @var{g}], @var{x_0}, @var{xdot_0}, @var{t} [, @var{t_crit}])\n\
+@deftypefn  {Loadable Function} {[@var{x}, @var{xdot}, @var{t_out}, @var{istat}, @var{msg}] =} dasrt (@var{fcn}, [], @var{x_0}, @var{xdot_0}, @var{t})\n\
+@deftypefnx {Loadable Function} {@dots{} =} dasrt (@var{fcn}, @var{g}, @var{x_0}, @var{xdot_0}, @var{t})\n\
+@deftypefnx {Loadable Function} {@dots{} =} dasrt (@var{fcn}, [], @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
+@deftypefnx {Loadable Function} {@dots{} =} dasrt (@var{fcn}, @var{g}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
 Solve the set of differential-algebraic equations\n\
 @tex\n\
 $$ 0 = f (x, \\dot{x}, t) $$\n\
 with\n\
 $$ x(t_0) = x_0, \\dot{x}(t_0) = \\dot{x}_0 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
@@ -336,17 +339,17 @@ discontinuity in the derivative.\n\
 After a successful computation, the value of @var{istate} will be\n\
 greater than zero (consistent with the Fortran version of @sc{dassl}).\n\
 \n\
 If the computation is not successful, the value of @var{istate} will be\n\
 less than zero and @var{msg} will contain additional information.\n\
 \n\
 You can use the function @code{dasrt_options} to set optional\n\
 parameters for @code{dasrt}.\n\
-@seealso{daspk, dasrt, lsode}\n\
+@seealso{dasrt_options, daspk, dasrt, lsode}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   warned_fcn_imaginary = false;
   warned_jac_imaginary = false;
   warned_cf_imaginary = false;
 
diff --git a/src/DLD-FUNCTIONS/det.cc b/src/DLD-FUNCTIONS/det.cc
--- a/src/DLD-FUNCTIONS/det.cc
+++ b/src/DLD-FUNCTIONS/det.cc
@@ -44,24 +44,29 @@ along with Octave; see the file COPYING.
 #include "ov-perm.h"
 
 #define MAYBE_CAST(VAR, CLASS) \
   const CLASS *VAR = arg.type_id () == CLASS::static_type_id () ? \
    dynamic_cast<const CLASS *> (&arg.get_rep ()) : 0
 
 DEFUN_DLD (det, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} det (@var{a})\n\
-@deftypefnx {Loadable Function} {[@var{d}, @var{rcond}] =} det (@var{a})\n\
-Compute the determinant of @var{a}.\n\
+@deftypefn  {Loadable Function} {} det (@var{A})\n\
+@deftypefnx {Loadable Function} {[@var{d}, @var{rcond}] =} det (@var{A})\n\
+Compute the determinant of @var{A}.\n\
+\n\
+Return an estimate of the reciprocal condition number if requested.\n\
 \n\
 Routines from @sc{lapack} are used for full matrices and code from\n\
 @sc{umfpack} is used for sparse matrices.\n\
 \n\
-Return an estimate of the reciprocal condition number if requested.\n\
+The determinant should not be used to check a matrix for singularity.\n\
+For that, use any of the condition number functions: @code{cond},\n\
+@code{condest}, @code{rcond}.\n\
+@seealso{cond, condest, rcond}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
diff --git a/src/DLD-FUNCTIONS/dlmread.cc b/src/DLD-FUNCTIONS/dlmread.cc
--- a/src/DLD-FUNCTIONS/dlmread.cc
+++ b/src/DLD-FUNCTIONS/dlmread.cc
@@ -165,28 +165,28 @@ DEFUN_DLD (dlmread, args, ,
 Read the matrix @var{data} from a text file.  If not defined the separator\n\
 between fields is determined from the file itself.  Otherwise the\n\
 separation character is defined by @var{sep}.\n\
 \n\
 Given two scalar arguments @var{r0} and @var{c0}, these define the starting\n\
 row and column of the data to be read.  These values are indexed from zero,\n\
 such that the first row corresponds to an index of zero.\n\
 \n\
-The @var{range} parameter may be a 4 element vector containing the upper\n\
+The @var{range} parameter may be a 4-element vector containing the upper\n\
 left and lower right corner @code{[@var{R0},@var{C0},@var{R1},@var{C1}]}\n\
 where the lowest index value is zero.  Alternatively, a spreadsheet style\n\
 range such as 'A2..Q15' or 'T1:AA5' can be used.  The lowest alphabetical\n\
 index 'A' refers to the first column.  The lowest row index is 1.\n\
 \n\
-@var{file} should be a file name or file id given by @code{fopen}. In the\n\
+@var{file} should be a file name or file id given by @code{fopen}.  In the\n\
 latter case, the file is read until end of file is reached.\n\
 \n\
 The \"emptyvalue\" option may be used to specify the value used to fill empty\n\
-fields. Default is zero.\n\
-@seealso{csvread,dlmwrite,fopen}\n\
+fields.  The default is zero.\n\
+@seealso{csvread,textscan,textread,dlmwrite}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   double empty_value = 0.0;
 
@@ -233,23 +233,23 @@ fields. Default is zero.\n\
 
       if (error_state)
          return retval;
 
       input = is.input_stream ();
 
       if (! input)
         {
-          error ("dlmread: stream not open for input");
+          error ("dlmread: stream FILE not open for input");
           return retval;
         }
     }
   else
     {
-      error ("dlmread: 1st argument must be a string or file id");
+      error ("dlmread: FILE argument must be a string or file id");
       return retval;
     }
 
   // Set default separator.
   std::string sep;
   if (nargin > 1)
     {
       if (args(1).is_sq_string ())
@@ -263,29 +263,29 @@ fields. Default is zero.\n\
   
   // Take a subset if a range was given.
   octave_idx_type r0 = 0, c0 = 0, r1 = idx_max-1, c1 = idx_max-1;
   if (nargin > 2)
     {
       if (nargin == 3)
         {
           if (!parse_range_spec (args (2), r0, c0, r1, c1))
-            error ("dlmread: error parsing range");
+            error ("dlmread: error parsing RANGE");
         } 
       else if (nargin == 4) 
         {
           r0 = args(2).idx_type_value ();
           c0 = args(3).idx_type_value ();
 
           if (error_state)
             return retval;
         }
 
       if (r0 < 0 || c0 < 0)
-        error ("dlmread: left & top must not be negative");
+        error ("dlmread: left & top must be positive");
     }
 
   if (!error_state)
     {
       octave_idx_type i = 0, j = 0, r = 1, c = 1, rmax = 0, cmax = 0;
 
       Matrix rdata;
       ComplexMatrix cdata;
diff --git a/src/DLD-FUNCTIONS/dmperm.cc b/src/DLD-FUNCTIONS/dmperm.cc
--- a/src/DLD-FUNCTIONS/dmperm.cc
+++ b/src/DLD-FUNCTIONS/dmperm.cc
@@ -128,29 +128,29 @@ dmperm_internal (bool rank, const octave
         }
     }
   return retval;
 }
 #endif
 
 DEFUN_DLD (dmperm, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{p} =} dmperm (@var{s})\n\
-@deftypefnx {Loadable Function} {[@var{p}, @var{q}, @var{r}, @var{s}] =} dmperm (@var{s})\n\
+@deftypefn  {Loadable Function} {@var{p} =} dmperm (@var{S})\n\
+@deftypefnx {Loadable Function} {[@var{p}, @var{q}, @var{r}, @var{S}] =} dmperm (@var{S})\n\
 \n\
 @cindex Dulmage-Mendelsohn decomposition\n\
-Perform a Dulmage-Mendelsohn permutation on the sparse matrix @var{s}.\n\
-With a single output argument @dfn{dmperm} performs the row permutations\n\
-@var{p} such that @code{@var{s} (@var{p},:)} has no zero elements on the\n\
+Perform a Dulmage-Mendelsohn permutation of the sparse matrix @var{S}.\n\
+With a single output argument @code{dmperm} performs the row permutations\n\
+@var{p} such that @code{@var{S}(@var{p},:)} has no zero elements on the\n\
 diagonal.\n\
 \n\
 Called with two or more output arguments, returns the row and column\n\
-permutations, such that @code{@var{s} (@var{p}, @var{q})} is in block\n\
-triangular form.  The values of @var{r} and @var{s} define the boundaries\n\
-of the blocks.  If @var{s} is square then @code{@var{r} == @var{s}}.\n\
+permutations, such that @code{@var{S}(@var{p}, @var{q})} is in block\n\
+triangular form.  The values of @var{r} and @var{S} define the boundaries\n\
+of the blocks.  If @var{S} is square then @code{@var{r} == @var{S}}.\n\
 \n\
 The method used is described in: A. Pothen & C.-J. Fan. @cite{Computing the\n\
 Block Triangular Form of a Sparse Matrix}. ACM Trans. Math. Software,\n\
 16(4):303-324, 1990.\n\
 @seealso{colamd, ccolamd}\n\
 @end deftypefn")
 {
   int nargin = args.length();
@@ -185,25 +185,25 @@ 16(4):303-324, 1990.\n\
 %! a=a(randperm(n),randperm(n));
 %! [p,q,r,s]=dmperm(a);
 %! assert(tril(a(p,q),-1),sparse(n,n))
 
 */
 
 DEFUN_DLD (sprank, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{p} =} sprank (@var{s})\n\
+@deftypefn {Loadable Function} {@var{p} =} sprank (@var{S})\n\
+@cindex Structural Rank\n\
 \n\
-@cindex Structural Rank\n\
-Calculates the structural rank of a sparse matrix @var{s}.  Note that\n\
+Calculate the structural rank of the sparse matrix @var{S}.  Note that\n\
 only the structure of the matrix is used in this calculation based on\n\
 a Dulmage-Mendelsohn permutation to block triangular form.  As such the\n\
-numerical rank of the matrix @var{s} is bounded by\n\
-@code{sprank (@var{s}) >= rank (@var{s})}.  Ignoring floating point errors\n\
-@code{sprank (@var{s}) == rank (@var{s})}.\n\
+numerical rank of the matrix @var{S} is bounded by\n\
+@code{sprank (@var{S}) >= rank (@var{S})}.  Ignoring floating point errors\n\
+@code{sprank (@var{S}) == rank (@var{S})}.\n\
 @seealso{dmperm}\n\
 @end deftypefn")
 {
   int nargin = args.length();
   octave_value_list retval;
   
   if (nargin != 1)
     {
diff --git a/src/DLD-FUNCTIONS/dot.cc b/src/DLD-FUNCTIONS/dot.cc
--- a/src/DLD-FUNCTIONS/dot.cc
+++ b/src/DLD-FUNCTIONS/dot.cc
@@ -101,26 +101,27 @@ get_red_dims (const dim_vector& x, const
           z(i) = 1;
         }
     }
 }
 
 DEFUN_DLD (dot, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} dot (@var{x}, @var{y}, @var{dim})\n\
-Computes the dot product of two vectors.  If @var{x} and @var{y}\n\
+Compute the dot product of two vectors.  If @var{x} and @var{y}\n\
 are matrices, calculate the dot products along the first \n\
 non-singleton dimension.  If the optional argument @var{dim} is\n\
 given, calculate the dot products along this dimension.\n\
 \n\
-This is equivalent to doing\n\
+This is equivalent to\n\
 @code{sum (conj (@var{X}) .* @var{Y}, @var{dim})},\n\
 but avoids forming a temporary array and is faster.  When @var{X} and\n\
 @var{Y} are column vectors, the result is equivalent to\n\
-@code{ @var{X}'*@var{Y} }.\n\
+@code{@var{X}' * @var{Y}}.\n\
+@seealso{cross}\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     {
       print_usage ();
@@ -150,17 +151,17 @@ but avoids forming a temporary array and
           if (nargin == 2)
             dim = dimx.first_non_singleton ();
           else
             dim = args(2).int_value (true) - 1;
 
           if (error_state)
             ;
           else if (dim < 0)
-            error ("dot: dim must be a valid dimension");
+            error ("dot: DIM must be a valid dimension");
           else
             {
               octave_idx_type m, n, k;
               dim_vector dimz;
               if (argx.is_complex_type () || argy.is_complex_type ())
                 {
                   if (argx.is_single_type () || argy.is_single_type ())
                     {
@@ -221,33 +222,33 @@ but avoids forming a temporary array and
                       tmp = feval ("sum", tmp, 1);
                       if (! tmp.empty ())
                         retval = tmp(0);
                     }
                 }
             }
         }
       else
-        error ("dot: sizes of x,y must match");
+        error ("dot: sizes of X and Y must match");
 
     }
   else
-    error ("dot: needs numeric arguments");
+    error ("dot: X and Y must be numeric");
 
   return retval;
 }
 
 /*
 
 */
 
 DEFUN_DLD (blkmm, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} blkmm (@var{x}, @var{y})\n\
-Computes products of matrix blocks.  The blocks are given as\n\
+Compute products of matrix blocks.  The blocks are given as\n\
 2-dimensional subarrays of the arrays @var{x}, @var{y}.\n\
 The size of @var{x} must have the form @code{[m,k,@dots{}]} and\n\
 size of @var{y} must be @code{[k,n,@dots{}]}.  The result is\n\
 then of size @code{[m,n,@dots{}]} and is computed as follows:\n\
 \n\
 @example\n\
 @group\n\
   for i = 1:prod (size (@var{x})(3:end))\n\
@@ -329,17 +330,17 @@ then of size @code{[m,n,@dots{}]} and is
                   if (! error_state)
                     F77_XFCN (dmatm3, DMATM3, (m, n, k, np, x.data (), y.data (),
                                                z.fortran_vec ()));
                   retval = z;
                 }
             }
         }
       else
-        error ("blkmm: dimensions don't match: (%s) and (%s)",
+        error ("blkmm: X and Y dimensions don't match: (%s) and (%s)",
                dimx.str ().c_str (), dimy.str ().c_str ());
 
     }
   else
-    error ("blkmm: needs numeric arguments");
+    error ("blkmm: X and Y must be numeric");
 
   return retval;
 }
diff --git a/src/DLD-FUNCTIONS/eig.cc b/src/DLD-FUNCTIONS/eig.cc
--- a/src/DLD-FUNCTIONS/eig.cc
+++ b/src/DLD-FUNCTIONS/eig.cc
@@ -30,28 +30,28 @@ along with Octave; see the file COPYING.
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN_DLD (eig, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{lambda} =} eig (@var{a})\n\
-@deftypefnx {Loadable Function} {@var{lambda} =} eig (@var{a}, @var{b})\n\
-@deftypefnx {Loadable Function} {[@var{v}, @var{lambda}] =} eig (@var{a})\n\
-@deftypefnx {Loadable Function} {[@var{v}, @var{lambda}] =} eig (@var{a}, @var{b})\n\
+@deftypefn  {Loadable Function} {@var{lambda} =} eig (@var{A})\n\
+@deftypefnx {Loadable Function} {@var{lambda} =} eig (@var{A}, @var{B})\n\
+@deftypefnx {Loadable Function} {[@var{V}, @var{lambda}] =} eig (@var{A})\n\
+@deftypefnx {Loadable Function} {[@var{V}, @var{lambda}] =} eig (@var{A}, @var{B})\n\
 The eigenvalues (and eigenvectors) of a matrix are computed in a several\n\
 step process which begins with a Hessenberg decomposition, followed by a\n\
-Schur decomposition, from which the eigenvalues are apparent.  The\n\
+Schur@tie{}decomposition, from which the eigenvalues are apparent.  The\n\
 eigenvectors, when desired, are computed by further manipulations of the\n\
-Schur decomposition.\n\
+Schur@tie{}decomposition.\n\
 \n\
 The eigenvalues returned by @code{eig} are not ordered.\n\
-@seealso{eigs}\n\
+@seealso{eigs, svd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 2 || nargin == 0 || nargout > 2)
     {
diff --git a/src/DLD-FUNCTIONS/eigs.cc b/src/DLD-FUNCTIONS/eigs.cc
--- a/src/DLD-FUNCTIONS/eigs.cc
+++ b/src/DLD-FUNCTIONS/eigs.cc
@@ -126,37 +126,37 @@ eigs_complex_func (const ComplexColumnVe
         }
     }
 
   return retval;
 }
 
 DEFUN_DLD (eigs, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{d} =} eigs (@var{a})\n\
-@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{a}, @var{k})\n\
-@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{a}, @var{k}, @var{sigma})\n\
-@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{a}, @var{k}, @var{sigma},@var{opts})\n\
-@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{a}, @var{b})\n\
-@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{a}, @var{b}, @var{k})\n\
-@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{a}, @var{b}, @var{k}, @var{sigma})\n\
-@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{a}, @var{b}, @var{k}, @var{sigma}, @var{opts})\n\
+@deftypefn  {Loadable Function} {@var{d} =} eigs (@var{A})\n\
+@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{A}, @var{k})\n\
+@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{A}, @var{k}, @var{sigma})\n\
+@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{A}, @var{k}, @var{sigma}, @var{opts})\n\
+@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{A}, @var{B})\n\
+@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{A}, @var{B}, @var{k})\n\
+@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{A}, @var{B}, @var{k}, @var{sigma})\n\
+@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{A}, @var{B}, @var{k}, @var{sigma}, @var{opts})\n\
 @deftypefnx {Loadable Function} {@var{d} =} eigs (@var{af}, @var{n})\n\
-@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{af}, @var{n}, @var{b})\n\
+@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{af}, @var{n}, @var{B})\n\
 @deftypefnx {Loadable Function} {@var{d} =} eigs (@var{af}, @var{n}, @var{k})\n\
-@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{af}, @var{n}, @var{b}, @var{k})\n\
+@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{af}, @var{n}, @var{B}, @var{k})\n\
 @deftypefnx {Loadable Function} {@var{d} =} eigs (@var{af}, @var{n}, @var{k}, @var{sigma})\n\
-@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{af}, @var{n}, @var{b}, @var{k}, @var{sigma})\n\
+@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{af}, @var{n}, @var{B}, @var{k}, @var{sigma})\n\
 @deftypefnx {Loadable Function} {@var{d} =} eigs (@var{af}, @var{n}, @var{k}, @var{sigma}, @var{opts})\n\
-@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{af}, @var{n}, @var{b}, @var{k}, @var{sigma}, @var{opts})\n\
-@deftypefnx {Loadable Function} {[@var{v}, @var{d}] =} eigs (@var{a}, @dots{})\n\
-@deftypefnx {Loadable Function} {[@var{v}, @var{d}] =} eigs (@var{af}, @var{n}, @dots{})\n\
-@deftypefnx {Loadable Function} {[@var{v}, @var{d}, @var{flag}] =} eigs (@var{a}, @dots{})\n\
-@deftypefnx {Loadable Function} {[@var{v}, @var{d}, @var{flag}] =} eigs (@var{af}, @var{n}, @dots{})\n\
-Calculate a limited number of eigenvalues and eigenvectors of @var{a},\n\
+@deftypefnx {Loadable Function} {@var{d} =} eigs (@var{af}, @var{n}, @var{B}, @var{k}, @var{sigma}, @var{opts})\n\
+@deftypefnx {Loadable Function} {[@var{V}, @var{d}] =} eigs (@var{A}, @dots{})\n\
+@deftypefnx {Loadable Function} {[@var{V}, @var{d}] =} eigs (@var{af}, @var{n}, @dots{})\n\
+@deftypefnx {Loadable Function} {[@var{V}, @var{d}, @var{flag}] =} eigs (@var{A}, @dots{})\n\
+@deftypefnx {Loadable Function} {[@var{V}, @var{d}, @var{flag}] =} eigs (@var{af}, @var{n}, @dots{})\n\
+Calculate a limited number of eigenvalues and eigenvectors of @var{A},\n\
 based on a selection criteria.  The number of eigenvalues and eigenvectors to\n\
 calculate is given by @var{k} and defaults to 6.\n\
 \n\
 By default, @code{eigs} solve the equation\n\
 @tex\n\
 $A \\nu = \\lambda \\nu$,\n\
 @end tex\n\
 @ifinfo\n\
@@ -214,21 +214,21 @@ Smallest Imaginary part (valid only for 
 @end table\n\
 \n\
 If @var{opts} is given, it is a structure defining possible options that\n\
 @code{eigs} should use.  The fields of the @var{opts} structure are:\n\
 \n\
 @table @code\n\
 @item issym\n\
 If @var{af} is given, then flags whether the function @var{af} defines a\n\
-symmetric problem.  It is ignored if @var{a} is given.  The default is false.\n\
+symmetric problem.  It is ignored if @var{A} is given.  The default is false.\n\
 \n\
 @item isreal\n\
 If @var{af} is given, then flags whether the function @var{af} defines a\n\
-real problem.  It is ignored if @var{a} is given.  The default is true.\n\
+real problem.  It is ignored if @var{A} is given.  The default is true.\n\
 \n\
 @item tol\n\
 Defines the required convergence tolerance, calculated as\n\
 @code{tol * norm (A)}.  The default is @code{eps}.\n\
 \n\
 @item maxit\n\
 The maximum number of iterations.  The default is 300.\n\
 \n\
@@ -237,33 +237,33 @@ The number of Lanzcos basis vectors to u
 faster convergence, but a greater use of memory.  The optimal value of\n\
 @code{p} is problem dependent and should be in the range @var{k} to @var{n}.\n\
 The default value is @code{2 * @var{k}}.\n\
 \n\
 @item v0\n\
 The starting vector for the algorithm.  An initial vector close to the\n\
 final vector will speed up convergence.  The default is for @sc{arpack}\n\
 to randomly generate a starting vector.  If specified, @code{v0} must be\n\
-an @var{n}-by-1 vector where @code{@var{n} = rows (@var{a})}\n\
+an @var{n}-by-1 vector where @code{@var{n} = rows (@var{A})}\n\
 \n\
 @item disp\n\
 The level of diagnostic printout (0|1|2).  If @code{disp} is 0 then\n\
 diagnostics are disabled.  The default value is 0.\n\
 \n\
 @item cholB\n\
-Flag if @code{chol (@var{b})} is passed rather than @var{b}.  The default is\n\
+Flag if @code{chol (@var{B})} is passed rather than @var{B}.  The default is\n\
 false.\n\
 \n\
 @item permB\n\
-The permutation vector of the Cholesky factorization of @var{b} if\n\
-@code{cholB} is true.  That is @code{chol (@var{b}(permB, permB))}.  The\n\
+The permutation vector of the Cholesky@tie{}factorization of @var{B} if\n\
+@code{cholB} is true.  That is @code{chol (@var{B}(permB, permB))}.  The\n\
 default is @code{1:@var{n}}.\n\
 \n\
 @end table\n\
-It is also possible to represent @var{a} by a function denoted @var{af}.\n\
+It is also possible to represent @var{A} by a function denoted @var{af}.\n\
 @var{af} must be followed by a scalar argument @var{n} defining the length\n\
 of the vector argument accepted by @var{af}.  @var{af} can be \n\
 a function handle, an inline function, or a string.  When @var{af} is a\n\
 string it holds the name of the function to use.\n\
 \n\
 @var{af} is a function of the form @code{y = af (x)}\n\
 where the required return value of @var{af} is determined by\n\
 the value of @var{sigma}.  The four possible forms are\n\
@@ -281,17 +281,17 @@ the same size as @var{A}.\n\
 \n\
 @item (A - sigma * B) \\ x\n\
 for the general eigenvalue problem.\n\
 @end table\n\
 \n\
 The return arguments of @code{eigs} depend on the number of return arguments\n\
 requested.  With a single return argument, a vector @var{d} of length @var{k}\n\
 is returned containing the @var{k} eigenvalues that have been found.  With\n\
-two return arguments, @var{v} is a @var{n}-by-@var{k} matrix whose columns\n\
+two return arguments, @var{V} is a @var{n}-by-@var{k} matrix whose columns\n\
 are the @var{k} eigenvectors corresponding to the returned eigenvalues.  The\n\
 eigenvalues themselves are returned in @var{d} in the form of a\n\
 @var{n}-by-@var{k} matrix, where the elements on the diagonal are the\n\
 eigenvalues.\n\
 \n\
 Given a third return argument @var{flag}, @code{eigs} returns the status\n\
 of the convergence.  If @var{flag} is 0 then all eigenvalues have converged.\n\
 Any other value indicates a failure to converge.\n\
@@ -457,17 +457,17 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
       else
         {
           sigma = args(2+arg_offset).complex_value ();
 
           if (! error_state)
             have_sigma = true;
           else
             {
-              error ("eigs: sigma must be a scalar or a string");
+              error ("eigs: SIGMA must be a scalar or a string");
               return retval;
             }
         }
     }
 
   sigmar = std::real (sigma);
   sigmai = std::imag (sigma);
 
@@ -521,23 +521,23 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
                 cholB = tmp.double_value () != 0.;
 
               tmp = map.getfield ("permB");
               if (tmp.is_defined ())
                 permB = ColumnVector (tmp.vector_value ()) - 1.0;
             }
           else
             {
-              error ("eigs: options argument must be a scalar structure");
+              error ("eigs: OPTS argument must be a scalar structure");
               return retval;
             }
         }
       else
         {
-          error ("eigs: options argument must be a structure");
+          error ("eigs: OPTS argument must be a structure");
           return retval;
         }
     }
 
   if (nargin > (4+arg_offset))
     {
       error ("eigs: incorrect number of arguments");
       return retval;
diff --git a/src/DLD-FUNCTIONS/fft.cc b/src/DLD-FUNCTIONS/fft.cc
--- a/src/DLD-FUNCTIONS/fft.cc
+++ b/src/DLD-FUNCTIONS/fft.cc
@@ -58,36 +58,36 @@ do_fft (const octave_value_list &args, c
   int dim = -1;
   
   if (nargin > 1)
     {
       if (! args(1).is_empty ())
         {
           double dval = args(1).double_value ();
           if (xisnan (dval))
-            error ("%s: NaN is invalid as the N_POINTS", fcn);
+            error ("%s: number of points (N) cannot be NaN", fcn);
           else
             {
               n_points = NINTbig (dval);
               if (n_points < 0)
-                error ("%s: number of points must be greater than zero", fcn);
+                error ("%s: number of points (N) must be greater than zero", fcn);
             }
         }
     }
 
   if (error_state)
     return retval;
 
   if (nargin > 2)
     {
       double dval = args(2).double_value ();
       if (xisnan (dval))
-        error ("%s: NaN is invalid as the N_POINTS", fcn);
+        error ("%s: DIM cannot be NaN", fcn);
       else if (dval < 1 || dval > dims.length ())
-        error ("%s: invalid dimension along which to perform fft", fcn);
+        error ("%s: DIM must be a valid dimension along which to perform FFT", fcn);
       else
         // to be safe, cast it back to int since dim is an int
         dim = NINT (dval) - 1;
     }
 
   if (error_state)
     return retval;
 
@@ -195,56 +195,60 @@ do_fft (const octave_value_list &args, c
 %!assert(fft(ones(2,2,'single')), single([2,2; 0,0]))
 %!assert(fft(eye(2,2,'single')), single([1,1; 1,-1]))
 
 */
 
 
 DEFUN_DLD (fft, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} fft (@var{a}, @var{n}, @var{dim})\n\
-Compute the FFT of @var{a} using subroutines from\n"
+@deftypefn  {Loadable Function} {} fft (@var{x})\n\
+@deftypefnx {Loadable Function} {} fft (@var{x}, @var{n})\n\
+@deftypefnx {Loadable Function} {} fft (@var{x}, @var{n}, @var{dim})\n\
+Compute the FFT of @var{x} using subroutines from\n"
 FFTSRC
 ".  The FFT is calculated along the first non-singleton dimension of the\n\
-array.  Thus if @var{a} is a matrix, @code{fft (@var{a})} computes the\n\
-FFT for each column of @var{a}.\n\
+array.  Thus if @var{x} is a matrix, @code{fft (@var{x})} computes the\n\
+FFT for each column of @var{x}.\n\
 \n\
 If called with two arguments, @var{n} is expected to be an integer\n\
-specifying the number of elements of @var{a} to use, or an empty\n\
+specifying the number of elements of @var{x} to use, or an empty\n\
 matrix to specify that its value should be ignored.  If @var{n} is\n\
 larger than the dimension along which the FFT is calculated, then\n\
-@var{a} is resized and padded with zeros.  Otherwise, if @var{n} is\n\
+@var{x} is resized and padded with zeros.  Otherwise, if @var{n} is\n\
 smaller than the dimension along which the FFT is calculated, then\n\
-@var{a} is truncated.\n\
+@var{x} is truncated.\n\
 \n\
 If called with three arguments, @var{dim} is an integer specifying the\n\
 dimension of the matrix along which the FFT is performed\n\
 @seealso{ifft, fft2, fftn, fftw}\n\
 @end deftypefn")
 {
   return do_fft (args, "fft", 0);
 }
 
 
 DEFUN_DLD (ifft, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} ifft (@var{a}, @var{n}, @var{dim})\n\
-Compute the inverse FFT of @var{a} using subroutines from\n"
+@deftypefn  {Loadable Function} {} ifft (@var{x})\n\
+@deftypefnx {Loadable Function} {} ifft (@var{x}, @var{n})\n\
+@deftypefnx {Loadable Function} {} ifft (@var{x}, @var{n}, @var{dim})\n\
+Compute the inverse FFT of @var{x} using subroutines from\n"
 FFTSRC
 ".  The inverse FFT is calculated along the first non-singleton dimension\n\
-of the array.  Thus if @var{a} is a matrix, @code{fft (@var{a})} computes\n\
-the inverse FFT for each column of @var{a}.\n\
+of the array.  Thus if @var{x} is a matrix, @code{fft (@var{x})} computes\n\
+the inverse FFT for each column of @var{x}.\n\
 \n\
 If called with two arguments, @var{n} is expected to be an integer\n\
-specifying the number of elements of @var{a} to use, or an empty\n\
+specifying the number of elements of @var{x} to use, or an empty\n\
 matrix to specify that its value should be ignored.  If @var{n} is\n\
 larger than the dimension along which the inverse FFT is calculated, then\n\
-@var{a} is resized and padded with zeros.  Otherwise, if@var{n} is\n\
+@var{x} is resized and padded with zeros.  Otherwise, if @var{n} is\n\
 smaller than the dimension along which the inverse FFT is calculated,\n\
-then @var{a} is truncated.\n\
+then @var{x} is truncated.\n\
 \n\
 If called with three arguments, @var{dim} is an integer specifying the\n\
 dimension of the matrix along which the inverse FFT is performed\n\
 @seealso{fft, ifft2, ifftn, fftw}\n\
 @end deftypefn")
 {
   return do_fft (args, "ifft", 1);
 }
diff --git a/src/DLD-FUNCTIONS/fft2.cc b/src/DLD-FUNCTIONS/fft2.cc
--- a/src/DLD-FUNCTIONS/fft2.cc
+++ b/src/DLD-FUNCTIONS/fft2.cc
@@ -57,39 +57,39 @@ do_fft2 (const octave_value_list &args, 
   octave_value arg = args(0);
   dim_vector dims = arg.dims ();
   octave_idx_type n_rows = -1;
   
   if (nargin > 1)
     {
       double dval = args(1).double_value ();
       if (xisnan (dval))
-        error ("%s: NaN is invalid as the N_ROWS", fcn);
+        error ("%s: number of rows (N) cannot be NaN", fcn);
       else
         {
           n_rows = NINTbig (dval);
           if (n_rows < 0)
-            error ("%s: number of rows must be greater than zero", fcn);
+            error ("%s: number of rows (N) must be greater than zero", fcn);
         }
     }
 
   if (error_state)
     return retval;
 
   octave_idx_type n_cols = -1;
   if (nargin > 2)
     {
       double dval = args(2).double_value ();
       if (xisnan (dval))
-        error ("%s: NaN is invalid as the N_COLS", fcn);
+        error ("%s: number of columns (M) cannot be NaN", fcn);
       else
         {
           n_cols = NINTbig (dval);
           if (n_cols < 0)
-            error ("%s: number of columns must be greater than zero", fcn);
+            error ("%s: number of columns (M) must be greater than zero", fcn);
         }
     }
 
   if (error_state)
     return retval;
 
   for (int i = 0; i < dims.length (); i++)
     if (dims(i) < 0)
@@ -164,45 +164,47 @@ do_fft2 (const octave_value_list &args, 
         }
     }
 
   return retval;
 }
 
 DEFUN_DLD (fft2, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} fft2 (@var{a}, @var{n}, @var{m})\n\
-Compute the two-dimensional FFT of @var{a} using subroutines from\n"
+@deftypefn  {Loadable Function} {} fft2 (@var{A})\n\
+@deftypefnx {Loadable Function} {} fft2 (@var{A}, @var{m}, @var{n})\n\
+Compute the two-dimensional FFT of @var{A} using subroutines from\n"
 FFTSRC
-".  The optional arguments @var{n} and @var{m} may be used specify the\n\
-number of rows and columns of @var{a} to use.  If either of these is\n\
-larger than the size of @var{a}, @var{a} is resized and padded with\n\
+".  The optional arguments @var{m} and @var{n} may be used specify the\n\
+number of rows and columns of @var{A} to use.  If either of these is\n\
+larger than the size of @var{A}, @var{A} is resized and padded with\n\
 zeros.\n\
 \n\
-If @var{a} is a multi-dimensional matrix, each two-dimensional sub-matrix\n\
-of @var{a} is treated separately\n\
+If @var{A} is a multi-dimensional matrix, each two-dimensional sub-matrix\n\
+of @var{A} is treated separately\n\
 @seealso {ifft2, fft, fftn, fftw}\n\
 @end deftypefn")
 {
   return do_fft2 (args, "fft2", 0);
 }
 
 
 DEFUN_DLD (ifft2, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} ifft2 (@var{a}, @var{n}, @var{m})\n\
-Compute the inverse two-dimensional FFT of @var{a} using subroutines from\n"
+@deftypefn  {Loadable Function} {} ifft2 (@var{A})\n\
+@deftypefnx {Loadable Function} {} ifft2 (@var{A}, @var{m}, @var{n})\n\
+Compute the inverse two-dimensional FFT of @var{A} using subroutines from\n"
 FFTSRC
-".  The optional arguments @var{n} and @var{m} may be used specify the\n\
-number of rows and columns of @var{a} to use.  If either of these is\n\
-larger than the size of @var{a}, @var{a} is resized and padded with\n\
+".  The optional arguments @var{m} and @var{n} may be used specify the\n\
+number of rows and columns of @var{A} to use.  If either of these is\n\
+larger than the size of @var{A}, @var{A} is resized and padded with\n\
 zeros.\n\
 \n\
-If @var{a} is a multi-dimensional matrix, each two-dimensional sub-matrix\n\
-of @var{a} is treated separately\n\
+If @var{A} is a multi-dimensional matrix, each two-dimensional sub-matrix\n\
+of @var{A} is treated separately\n\
 @seealso {fft2, ifft, ifftn, fftw}\n\
 @end deftypefn")
 {
   return do_fft2 (args, "ifft2", 1);
 }
 
 /*
 
diff --git a/src/DLD-FUNCTIONS/fftn.cc b/src/DLD-FUNCTIONS/fftn.cc
--- a/src/DLD-FUNCTIONS/fftn.cc
+++ b/src/DLD-FUNCTIONS/fftn.cc
@@ -62,25 +62,25 @@ do_fftn (const octave_value_list &args, 
 
   if (nargin > 1)
     {
       Matrix val = args(1).matrix_value ();
       if (val.rows () > val.columns ())
         val = val.transpose ();
 
       if (error_state || val.columns () != dims.length () || val.rows () != 1)
-        error ("%s: second argument must be a vector of length dim", fcn);
+        error ("%s: SIZE must be a vector of length dim", fcn);
       else
         {
           for (int i = 0; i < dims.length (); i++)
             {
               if (xisnan (val(i,0)))
-                error ("%s: NaN is invalid as a dimension", fcn);
+                error ("%s: SIZE has invalid NaN entries", fcn);
               else if (NINTbig (val(i,0)) < 0)
-                error ("%s: all dimension must be greater than zero", fcn);
+                error ("%s: all dimensions in SIZE must be greater than zero", fcn);
               else
                 {
                   dims(i) = NINTbig(val(i,0));
                 }
             }
         }
     }
 
@@ -146,39 +146,41 @@ do_fftn (const octave_value_list &args, 
         }
     }
 
   return retval;
 }
 
 DEFUN_DLD (fftn, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} fftn (@var{a}, @var{size})\n\
-Compute the N-dimensional FFT of @var{a} using subroutines from\n"
+@deftypefn  {Loadable Function} {} fftn (@var{A})\n\
+@deftypefnx {Loadable Function} {} fftn (@var{A}, @var{size})\n\
+Compute the N-dimensional FFT of @var{A} using subroutines from\n"
 FFTSRC
 ".  The optional vector argument @var{size} may be used specify the\n\
 dimensions of the array to be used.  If an element of @var{size} is\n\
 smaller than the corresponding dimension, then the dimension is\n\
 truncated prior to performing the FFT@.  Otherwise if an element\n\
-of @var{size} is larger than the corresponding dimension @var{a}\n\
+of @var{size} is larger than the corresponding dimension @var{A}\n\
 is resized and padded with zeros.\n\
-@seealso {ifftn, fft, fft2, fftw}\n\
+@seealso{ifftn, fft, fft2, fftw}\n\
 @end deftypefn")
 {
   return do_fftn (args, "fftn", 0);
 }
 
 DEFUN_DLD (ifftn, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} ifftn (@var{a}, @var{size})\n\
-Compute the inverse N-dimensional FFT of @var{a} using subroutines from\n"
+@deftypefn  {Loadable Function} {} ifftn (@var{A})\n\
+@deftypefnx {Loadable Function} {} ifftn (@var{A}, @var{size})\n\
+Compute the inverse N-dimensional FFT of @var{A} using subroutines from\n"
 FFTSRC
 ".  The optional vector argument @var{size} may be used specify the\n\
 dimensions of the array to be used.  If an element of @var{size} is\n\
 smaller than the corresponding dimension, then the dimension is\n\
 truncated prior to performing the inverse FFT@.  Otherwise if an element\n\
-of @var{size} is larger than the corresponding dimension @var{a}\n\
+of @var{size} is larger than the corresponding dimension @var{A}\n\
 is resized and padded with zeros.\n\
-@seealso {fftn, ifft, ifft2, fftw}\n\
+@seealso{fftn, ifft, ifft2, fftw}\n\
 @end deftypefn")
 {
   return do_fftn (args, "ifftn", 1);
 }
diff --git a/src/DLD-FUNCTIONS/fftw.cc b/src/DLD-FUNCTIONS/fftw.cc
--- a/src/DLD-FUNCTIONS/fftw.cc
+++ b/src/DLD-FUNCTIONS/fftw.cc
@@ -32,20 +32,20 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "ov.h"
 
 DEFUN_DLD (fftw, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{method} =} fftw ('planner')\n\
 @deftypefnx {Loadable Function} {} fftw ('planner', @var{method})\n\
 @deftypefnx {Loadable Function} {@var{wisdom} =} fftw ('dwisdom')\n\
-@deftypefnx {Loadable Function} {@var{wisdom} =} fftw ('dwisdom', @var{wisdom})\n\
+@deftypefnx {Loadable Function} {} fftw ('dwisdom', @var{wisdom})\n\
 \n\
 Manage @sc{fftw} wisdom data.  Wisdom data can be used to significantly\n\
-accelerate the calculation of the FFTs but implies an initial cost\n\
+accelerate the calculation of the FFTs, but implies an initial cost\n\
 in its calculation.  When the @sc{fftw} libraries are initialized, they read\n\
 a system wide wisdom file (typically in @file{/etc/fftw/wisdom}), allowing\n\
 wisdom to be shared between applications other than Octave.  Alternatively,\n\
 the @code{fftw} function can be used to import wisdom.  For example,\n\
 \n\
 @example\n\
 @var{wisdom} = fftw ('dwisdom')\n\
 @end example\n\
@@ -58,54 +58,54 @@ reimported as follows\n\
 \n\
 @example\n\
 fftw ('dwisdom', @var{wisdom})\n\
 @end example \n\
 \n\
 If @var{wisdom} is an empty matrix, then the wisdom used is cleared.\n\
 \n\
 During the calculation of Fourier transforms further wisdom is generated.\n\
-The fashion in which this wisdom is generated is equally controlled by\n\
+The fashion in which this wisdom is generated is also controlled by\n\
 the @code{fftw} function.  There are five different manners in which the\n\
-wisdom can be treated, these being\n\
+wisdom can be treated:\n\
 \n\
 @table @asis\n\
 @item 'estimate'\n\
-This specifies that no run-time measurement of the optimal means of\n\
+Specifies that no run-time measurement of the optimal means of\n\
 calculating a particular is performed, and a simple heuristic is used\n\
 to pick a (probably sub-optimal) plan.  The advantage of this method is\n\
 that there is little or no overhead in the generation of the plan, which\n\
 is appropriate for a Fourier transform that will be calculated once.\n\
 \n\
 @item 'measure'\n\
 In this case a range of algorithms to perform the transform is considered\n\
 and the best is selected based on their execution time.\n\
 \n\
 @item 'patient'\n\
-This is like 'measure', but a wider range of algorithms is considered.\n\
+Similar to 'measure', but a wider range of algorithms is considered.\n\
 \n\
 @item 'exhaustive'\n\
-This is like 'measure', but all possible algorithms that may be used to\n\
+Like 'measure', but all possible algorithms that may be used to\n\
 treat the transform are considered.\n\
 \n\
 @item 'hybrid'\n\
 As run-time measurement of the algorithm can be expensive, this is a\n\
 compromise where 'measure' is used for transforms up to the size of 8192\n\
 and beyond that the 'estimate' method is used.\n\
 @end table\n\
 \n\
-The default method is 'estimate', and the method currently being used can\n\
-be probed with\n\
+The default method is 'estimate'.  The current method can\n\
+be queried with\n\
 \n\
 @example\n\
 @var{method} = fftw ('planner')\n\
 @end example\n\
 \n\
 @noindent\n\
-and the method used can be set using\n\
+or set by using\n\
 \n\
 @example\n\
 fftw ('planner', @var{method})\n\
 @end example\n\
 \n\
 Note that calculated wisdom will be lost when restarting Octave.  However,\n\
 the wisdom data can be reloaded if it is saved to a file as described\n\
 above.  Saved wisdom files should not be used on different platforms since\n\
@@ -168,17 +168,17 @@ they will not be efficient and the point
                           methf = octave_float_fftw_planner::EXHAUSTIVE;
                         }
                       else if (arg1 == "hybrid")
                         {
                           meth = octave_fftw_planner::HYBRID;
                           methf = octave_float_fftw_planner::HYBRID;
                         }
                       else
-                        error ("unrecognized planner method");
+                        error ("unrecognized planner METHOD");
 
                       if (!error_state)
                         {
                           meth = octave_fftw_planner::method (meth);
                           octave_float_fftw_planner::method (methf);
 
                           if (meth == octave_fftw_planner::MEASURE)
                             retval = octave_value ("measure");
@@ -194,31 +194,31 @@ they will not be efficient and the point
                     }
                   else if (arg0 == "dwisdom")
                     {
                       char *str = fftw_export_wisdom_to_string ();
 
                       if (arg1.length() < 1)
                         fftw_forget_wisdom ();
                       else if (! fftw_import_wisdom_from_string (arg1.c_str()))
-                        error ("could not import supplied wisdom");
+                        error ("could not import supplied WISDOM");
 
                       if (!error_state)
                         retval = octave_value (std::string (str));
 
                       free (str);
                     }
                   else if (arg0 == "swisdom")
                     {
                       char *str = fftwf_export_wisdom_to_string ();
 
                       if (arg1.length() < 1)
                         fftwf_forget_wisdom ();
                       else if (! fftwf_import_wisdom_from_string (arg1.c_str()))
-                        error ("could not import supplied wisdom");
+                        error ("could not import supplied WISDOM");
 
                       if (!error_state)
                         retval = octave_value (std::string (str));
 
                       free (str);
                     }
                   else
                     error ("unrecognized argument");
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -67,17 +67,17 @@ filter (MArray<T>& b, MArray<T>& a, MArr
   b.resize (ab_len, 1, 0.0);
   if (a_len > 1)
     a.resize (ab_len, 1, 0.0);
 
   T norm = a (0);
 
   if (norm == static_cast<T>(0.0))
     {
-      error ("filter: the first element of a must be non-zero");
+      error ("filter: the first element of A must be non-zero");
       return y;
     }
 
   dim_vector x_dims = x.dims ();
   if (dim < 0 || dim > x_dims.length ())
     {
       error ("filter: filtering over invalid dimension");
       return y;
@@ -85,38 +85,38 @@ filter (MArray<T>& b, MArray<T>& a, MArr
 
   octave_idx_type x_len = x_dims(dim);
 
   dim_vector si_dims = si.dims ();
   octave_idx_type si_len = si_dims(0);
 
   if (si_len != ab_len - 1)
     {
-      error ("filter: first dimension of si must be of length max (length (a), length (b)) - 1");
+      error ("filter: first dimension of SI must be of length max (length (a), length (b)) - 1");
       return y;
     }
 
   if (si_dims.length () != x_dims.length ())
     {
-      error ("filter: dimensionality of si and x must agree");
+      error ("filter: dimensionality of SI and X must agree");
       return y;
     }
 
   octave_idx_type si_dim = 0;
   for (octave_idx_type i = 0; i < x_dims.length (); i++)
     {
       if (i == dim)
         continue;
      
       if (x_dims(i) == 1)
         continue;
  
       if (si_dims(++si_dim) != x_dims(i))
         {
-          error ("filter: dimensionality of si and x must agree");
+          error ("filter: dimensionality of SI and X must agree");
           return y;
         }
     }
 
   if (x_len == 0)
     return x;
 
   if (norm != static_cast<T>(1.0))
@@ -347,17 +347,17 @@ where\n\
 \n\
 If the fourth argument @var{si} is provided, it is taken as the\n\
 initial state of the system and the final state is returned as\n\
 @var{sf}.  The state vector is a column vector whose length is\n\
 equal to the length of the longest coefficient vector minus one.\n\
 If @var{si} is not supplied, the initial state vector is set to all\n\
 zeros.\n\
 \n\
-In terms of the z-transform, y is the result of passing the discrete-\n\
+In terms of the Z Transform, y is the result of passing the discrete-\n\
 time signal x through a system characterized by the following rational\n\
 system function:\n\
 @tex\n\
 $$\n\
 H(z) = {\\displaystyle\\sum_{k=0}^M d_{k+1} z^{-k}\n\
         \\over 1 + \\displaystyle\\sum_{k+1}^N c_{k+1} z^{-k}}\n\
 $$\n\
 @end tex\n\
@@ -371,16 +371,17 @@ H(z) = {\\displaystyle\\sum_{k=0}^M d_{k
   H(z) = ----------------------\n\
                N\n\
           1 + SUM c(k+1) z^(-k)\n\
               k=1\n\
 @end group\n\
 @end example\n\
 \n\
 @end ifnottex\n\
+@seealso{filter2,fftfilt,freqz}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin  = args.length ();
 
   if (nargin < 3 || nargin > 5)
     {
diff --git a/src/DLD-FUNCTIONS/find.cc b/src/DLD-FUNCTIONS/find.cc
--- a/src/DLD-FUNCTIONS/find.cc
+++ b/src/DLD-FUNCTIONS/find.cc
@@ -332,19 +332,21 @@ find_nonzero_elem_idx (const PermMatrix&
       break;
     }
 
   return retval;
 }
 
 DEFUN_DLD (find, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} find (@var{x})\n\
-@deftypefnx {Loadable Function} {} find (@var{x}, @var{n})\n\
-@deftypefnx {Loadable Function} {} find (@var{x}, @var{n}, @var{direction})\n\
+@deftypefn  {Loadable Function} {@var{idx} =} find (@var{x})\n\
+@deftypefnx {Loadable Function} {@var{idx} =} find (@var{x}, @var{n})\n\
+@deftypefnx {Loadable Function} {@var{idx} =} find (@var{x}, @var{n}, @var{direction})\n\
+@deftypefnx {Loadable Function} {[i, j] =} find (@dots{})\n\
+@deftypefnx {Loadable Function} {[i, j, v]] =} find (@dots{})\n\
 Return a vector of indices of nonzero elements of a matrix, as a row if\n\
 @var{x} is a row or as a column otherwise.  To obtain a single index for\n\
 each matrix element, Octave pretends that the columns of a matrix form one\n\
 long vector (like Fortran arrays are stored).  For example:\n\
 \n\
 @example\n\
 @group\n\
 find (eye (2))\n\
@@ -388,17 +390,17 @@ create the original matrix.  For example
 \n\
 @example\n\
 @group\n\
 sz = size(a);\n\
 [i, j, v] = find (a);\n\
 b = sparse(i, j, v, sz(1), sz(2));\n\
 @end group\n\
 @end example\n\
-@seealso{sparse}\n\
+@seealso{nonzeros}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 3 || nargin < 1)
     {
@@ -409,17 +411,17 @@ b = sparse(i, j, v, sz(1), sz(2));\n\
   // Setup the default options.
   octave_idx_type n_to_find = -1;
   if (nargin > 1)
     {
       double val = args(1).scalar_value ();
 
       if (error_state || (val < 0 || (! xisinf (val) && val != xround (val))))
         {
-          error ("find: expecting second argument to be a nonnegative integer");
+          error ("find: N must be a nonnegative integer");
           return retval;
         }
       else if (! xisinf (val))
         n_to_find = val;
     }
 
   // Direction to do the searching (1 == forward, -1 == reverse).
   int direction = 1;
@@ -434,17 +436,17 @@ b = sparse(i, j, v, sz(1), sz(2));\n\
           if (s_arg == "first")
             direction = 1;
           else if (s_arg == "last")
             direction = -1;
         }
 
       if (direction == 0)
         {
-          error ("find: expecting third argument to be \"first\" or \"last\"");
+          error ("find: DIRECTION must be \"first\" or \"last\"");
           return retval;
         }
     }
 
   octave_value arg = args(0);
 
   if (arg.is_bool_type ())
     {
diff --git a/src/DLD-FUNCTIONS/fltk_backend.cc b/src/DLD-FUNCTIONS/fltk_backend.cc
--- a/src/DLD-FUNCTIONS/fltk_backend.cc
+++ b/src/DLD-FUNCTIONS/fltk_backend.cc
@@ -1690,17 +1690,17 @@ private:
   {
     graphics_object fobj = gh_manager::get_object (h);
     if (fobj &&  fobj.isa ("figure"))
       {
         figure::properties& fp =
           dynamic_cast<figure::properties&> (fobj.get_properties ());
         return figprops2idx (fp);
       }
-    error ("fltk_backend:: not a figure");
+    error ("fltk_backend:: H is not a figure");
     return -1;
   }
 
   static int hnd2idx (const graphics_handle& fh)
   {
     return hnd2idx (fh.value ());
   }
 };
@@ -1942,48 +1942,48 @@ DEFUN_DLD (__fltk_maxtime__, args, ,"")
         error ("argument must be a real scalar");
     }
 
   return retval;
 }
 
 DEFUN_DLD (fltk_mouse_wheel_zoom, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} fltk_mouse_wheel_zoom ([@var{speed}])\n\
-Returns the current mouse wheel zoom factor in the fltk backend.  If\n\
-the @var{speed} argument is given, set the mouse zoom factor to this\n\
-value.\n\
+@deftypefn  {Built-in Function} {@var{speed} =} fltk_mouse_wheel_zoom ()\n\
+@deftypefnx {Built-in Function} {} fltk_mouse_wheel_zoom (@var{speed})\n\
+Query or set the mouse wheel zoom factor in the fltk backend.\n\
 @end deftypefn")
 {
   octave_value retval = wheel_zoom_speed;
 
   if (args.length () == 1)
     {
       if (args(0).is_real_scalar ())
         wheel_zoom_speed = args(0).double_value ();
       else
-        error ("argument must be a real scalar");
+        error ("fltk_mouse_wheel_zoom: SPEED must be a real scalar");
     }
 
   return retval;
 }
 
 DEFUN_DLD (fltk_gui_mode, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {@var{mode} =} fltk_gui_mode\n\
+@deftypefn  {Built-in Function} {@var{mode} =} fltk_gui_mode ()\n\
 @deftypefnx {Built-in Function} {} fltk_gui_mode (@var{mode})\n\
-Returns the current GUI mode string for the fltk backend. If\n\
-the @var{mode} argument is given the GUI mode is set to this\n\
-value. It can be one of the following strings:\n\
-@table @code\n\
-@item 2d\n\
+Query or set the GUI mode for the fltk backend.\n\
+The @var{mode} argument can be one of the following strings:\n\
+@table @asis\n\
+@item '2d'\n\
 Allows panning and zooming of current axes.\n\
-@item 3d\n\
+\n\
+@item '3d'\n\
 Allows rotating and zooming of current axes.\n\
-@item none\n\
+\n\
+@item 'none'\n\
 Mouse inputs have no effect.\n\
 @end table\n\
 @end deftypefn")
 {
   caseless_str mode_str;
 
   if (gui_mode == pan_zoom)
     mode_str = "2d";
@@ -2010,29 +2010,27 @@ Mouse inputs have no effect.\n\
           else
             failed = true;
         }
       else
         failed = true;
     }
     
   if (failed)
-    error ("argument must be one of the strings: ""2D"", ""3D"", or ""None"".");
+    error ("MODE must be one of the strings: ""2D"", ""3D"", or ""None"".");
   
   
   return octave_value(mode_str);
 }
 
 #include "file-ops.h"
 DEFUN_DLD (__fltk_uigetfile__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __fltk_uigetfile__ ([@var{...}])\n\
-Internal Function.\n\
-\n\
-\n\
+@deftypefn {Built-in Function} {} __fltk_uigetfile__ (@dots{})\n\
+Undocumented internal function.\n\
 @end deftypefn")
 {
   // This function should be called by uigetfile.m
   // Error checking should be done in uigetfile.m!
   //
   // Expected argument list
   // args(0) ... FileFilter in fltk format
   // args(1) ... Title
diff --git a/src/DLD-FUNCTIONS/gammainc.cc b/src/DLD-FUNCTIONS/gammainc.cc
--- a/src/DLD-FUNCTIONS/gammainc.cc
+++ b/src/DLD-FUNCTIONS/gammainc.cc
@@ -84,20 +84,20 @@ gammainc (@var{x}, @var{a}) @equiv{} 1 -
     {
       if (args(2).is_string ())
         {
           std::string s = args(2).string_value ();
           std::transform (s.begin (), s.end (), s.begin (), tolower);
           if (s == "upper")
             lower = false;
           else if (s != "lower")
-            error ("expecting third argument to be \"lower\" or \"upper\"");
+            error ("gammainc: third argument must be \"lower\" or \"upper\"");
         }
       else
-        error ("expecting third argument to be \"lower\" or \"upper\"");
+        error ("gammainc: third argument must be \"lower\" or \"upper\"");
 
     }
 
   if (!error_state && nargin >= 2  && nargin <= 3)
     {
       octave_value x_arg = args(0);
       octave_value a_arg = args(1);
 
diff --git a/src/DLD-FUNCTIONS/gcd.cc b/src/DLD-FUNCTIONS/gcd.cc
--- a/src/DLD-FUNCTIONS/gcd.cc
+++ b/src/DLD-FUNCTIONS/gcd.cc
@@ -429,26 +429,26 @@ do_extended_gcd (const octave_value& a, 
       y = y.float_array_value ();
     }
 
   return retval;
 }
 
 DEFUN_DLD (gcd, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{g} =} gcd (@var{a1}, @var{a2}, @dots{})\n\
+@deftypefn  {Loadable Function} {@var{g} =} gcd (@var{a1}, @var{a2}, @dots{})\n\
 @deftypefnx {Loadable Function} {[@var{g}, @var{v1}, @dots{}] =} gcd (@var{a1}, @var{a2}, @dots{})\n\
 \n\
-Compute the greatest common divisor of @var{a1}, @var{a2}, @dots{}. If more\n\
+Compute the greatest common divisor of @var{a1}, @var{a2}, @dots{}.  If more\n\
 than one argument is given all arguments must be the same size or scalar.\n\
-  In this case the greatest common divisor is calculated for each element\n\
+In this case the greatest common divisor is calculated for each element\n\
 individually.  All elements must be ordinary or Gaussian (complex)\n\
-integers. Note that for Gaussian integers, the gcd is not unique up to\n\
+integers.  Note that for Gaussian integers, the gcd is not unique up to\n\
 units (multiplication by 1, -1, @var{i} or -@var{i}), so an arbitrary\n\
-greatest common divisor amongst four possible is returned. For example,\n\
+greatest common divisor amongst four possible is returned.  For example,\n\
 \n\
 @noindent\n\
 and\n\
 \n\
 @example\n\
 @group\n\
 gcd ([15, 9], [20, 18])\n\
     @result{}  5  9\n\
diff --git a/src/DLD-FUNCTIONS/getgrent.cc b/src/DLD-FUNCTIONS/getgrent.cc
--- a/src/DLD-FUNCTIONS/getgrent.cc
+++ b/src/DLD-FUNCTIONS/getgrent.cc
@@ -61,17 +61,17 @@ mk_gr_map (const octave_group& gr)
 
   return retval;
 }
 
 DEFUN_DLD (getgrent, args, ,
  "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{grp_struct} =} getgrent ()\n\
 Return an entry from the group database, opening it if necessary.\n\
-Once the end of the data has been reached, @code{getgrent} returns 0.\n\
+Once the end of data has been reached, @code{getgrent} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = 0;
 
   int nargin = args.length ();
@@ -115,17 +115,17 @@ Return the first entry from the group da
               gid_t gid = static_cast<gid_t> (dval);
 
               std::string msg;
 
               retval(0) = mk_gr_map (octave_group::getgrgid (gid, msg));
               retval(1) = msg;
             }
           else
-            error ("getgrgid: argument must be an integer");
+            error ("getgrgid: GID must be an integer");
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
diff --git a/src/DLD-FUNCTIONS/getpwent.cc b/src/DLD-FUNCTIONS/getpwent.cc
--- a/src/DLD-FUNCTIONS/getpwent.cc
+++ b/src/DLD-FUNCTIONS/getpwent.cc
@@ -119,17 +119,17 @@ database, @code{getpwuid} returns 0.\n\
               uid_t uid = static_cast<uid_t> (dval);
 
               std::string msg;
 
               retval(0) = mk_pw_map (octave_passwd::getpwuid (uid, msg));
               retval(1) = msg;
             }
           else
-            error ("getpwuid: argument must be an integer");
+            error ("getpwuid: UID must be an integer");
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
diff --git a/src/DLD-FUNCTIONS/hess.cc b/src/DLD-FUNCTIONS/hess.cc
--- a/src/DLD-FUNCTIONS/hess.cc
+++ b/src/DLD-FUNCTIONS/hess.cc
@@ -32,37 +32,39 @@ along with Octave; see the file COPYING.
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN_DLD (hess, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{h} =} hess (@var{a})\n\
-@deftypefnx {Loadable Function} {[@var{p}, @var{h}] =} hess (@var{a})\n\
+@deftypefn  {Loadable Function} {@var{h} =} hess (@var{A})\n\
+@deftypefnx {Loadable Function} {[@var{p}, @var{h}] =} hess (@var{A})\n\
 @cindex Hessenberg decomposition\n\
-Compute the Hessenberg decomposition of the matrix @var{a}.\n\
+Compute the Hessenberg decomposition of the matrix @var{A}.\n\
 \n\
-The Hessenberg decomposition is usually used as the first step in an\n\
-eigenvalue computation, but has other applications as well (see Golub,\n\
-Nash, and Van Loan, IEEE Transactions on Automatic Control, 1979).  The\n\
-Hessenberg decomposition is\n\
+The Hessenberg decomposition is\n\
 @tex\n\
 $$\n\
 A = PHP^T\n\
 $$\n\
-where $P$ is a square unitary matrix ($P^HP = I$), and $H$\n\
+where $P$ is a square unitary matrix ($P^TP = I$), and $H$\n\
 is upper Hessenberg ($H_{i,j} = 0, \\forall i \\ge j+1$).\n\
 @end tex\n\
 @ifnottex\n\
-@code{p * h * p' = a} where @code{p} is a square unitary matrix\n\
-(@code{p' * p = I}, using complex-conjugate transposition) and @code{h}\n\
-is upper Hessenberg (@code{i >= j+1 => h (i, j) = 0}).\n\
+@code{@var{P} * @var{H} * @var{P}' = @var{A}} where @var{p} is a square\n\
+unitary matrix (@code{@var{p}' * @var{p} = I}, using complex-conjugate\n\
+transposition) and @var{H} is upper Hessenberg\n\
+(@code{@var{H}(i, j) = 0 forall i >= j+1)}.\n\
 @end ifnottex\n\
+\n\
+The Hessenberg decomposition is usually used as the first step in an\n\
+eigenvalue computation, but has other applications as well (see Golub,\n\
+Nash, and Van Loan, IEEE Transactions on Automatic Control, 1979).\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 || nargout > 2)
     {
diff --git a/src/DLD-FUNCTIONS/hex2num.cc b/src/DLD-FUNCTIONS/hex2num.cc
--- a/src/DLD-FUNCTIONS/hex2num.cc
+++ b/src/DLD-FUNCTIONS/hex2num.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN_DLD (hex2num, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{n} =} hex2num (@var{s})\n\
-Typecast the 16 character hexadecimal character matrix to an IEEE 754\n\
+Typecast the 16 character hexadecimal character string to an IEEE 754\n\
 double precision number.  If fewer than 16 characters are given the\n\
 strings are right padded with '0' characters.\n\
 \n\
 Given a string matrix, @code{hex2num} treats each row as a separate\n\
 number.\n\
 \n\
 @example\n\
 @group\n\
@@ -56,17 +56,17 @@ hex2num ([\"4005bf0a8b145769\";\"4024000
 
   if (nargin != 1)
     print_usage ();
   else
     {
       const charMatrix cmat = args(0).char_matrix_value ();
 
       if (cmat.columns () > 16)
-        error ("hex2num: expecting no more than a 16 character string");
+        error ("hex2num: S must be no more than 16 characters");
       else if (! error_state)
         {
           octave_idx_type nr = cmat.rows ();
           octave_idx_type nc = cmat.columns ();
           ColumnVector m (nr);
 
           for (octave_idx_type i = 0; i < nr; i++)
             {
@@ -87,17 +87,17 @@ hex2num ([\"4005bf0a8b145769\";\"4024000
                         num.ival += static_cast<uint64_t> (ch - 'a' + 10);
                       else if (ch >= 'A')
                         num.ival += static_cast<uint64_t> (ch - 'A' + 10);
                       else
                         num.ival += static_cast<uint64_t> (ch - '0');
                     }
                   else
                     {
-                      error ("hex2num: illegal character found in string");
+                      error ("hex2num: illegal character found in string S");
                       break;
                     }
                 }
 
               if (error_state)
                 break;
               else
                 {
diff --git a/src/DLD-FUNCTIONS/inv.cc b/src/DLD-FUNCTIONS/inv.cc
--- a/src/DLD-FUNCTIONS/inv.cc
+++ b/src/DLD-FUNCTIONS/inv.cc
@@ -33,27 +33,32 @@ along with Octave; see the file COPYING.
 #include "ov-cx-diag.h"
 #include "ov-flt-re-diag.h"
 #include "ov-flt-cx-diag.h"
 #include "ov-perm.h"
 #include "utils.h"
 
 DEFUN_DLD (inv, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {[@var{x}, @var{rcond}] =} inv (@var{a})\n\
-@deftypefnx {Loadable Function} {[@var{x}, @var{rcond}] =} inverse (@var{a})\n\
-Compute the inverse of the square matrix @var{a}.  Return an estimate\n\
+@deftypefn  {Loadable Function} {[@var{x} =} inv (@var{A})\n\
+@deftypefnx {Loadable Function} {[@var{x}, @var{rcond}] =} inv (@var{A})\n\
+Compute the inverse of the square matrix @var{A}.  Return an estimate\n\
 of the reciprocal condition number if requested, otherwise warn of an\n\
 ill-conditioned matrix if the reciprocal condition number is small.\n\
 \n\
+In general it is best to avoid calculating the inverse of a matrix\n\
+directly.  For example, it is both faster and more accurate to solve\n\
+systems of equations (@var{A}*@math{x} = @math{b}) with\n\
+@code{@var{y} = @var{A} \\ @math{b}}, rather than\n\
+@code{@var{y} = inv (@var{A}) * @math{b}}.\n\
+\n\
 If called with a sparse matrix, then in general @var{x} will be a full\n\
-matrix, and so if possible forming the inverse of a sparse matrix should\n\
-be avoided.  It is significantly more accurate and faster to do\n\
-@code{@var{y} = @var{a} \\ @var{b}}, rather than\n\
-@code{@var{y} = inv (@var{a}) * @var{b}}.\n\
+matrix requiring significantly more storage.  Avoid forming the inverse\n\
+of a sparse matrix if possible.\n\
+@seealso{ldivide,rdivide}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
@@ -230,14 +235,16 @@ be avoided.  It is significantly more ac
  */
 
 // FIXME -- this should really be done with an alias, but
 // alias_builtin() won't do the right thing if we are actually using
 // dynamic linking.
 
 DEFUN_DLD (inverse, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} inverse (@var{a})\n\
-See inv.\n\
+@deftypefn  {Loadable Function} {[@var{x} =} inverse (@var{A})\n\
+@deftypefnx {Loadable Function} {[@var{x}, @var{rcond}] =} inverse (@var{A})\n\
+This in an alias for @code{inv}.\n\
+@seealso{inv}\n\
 @end deftypefn")
 {
   return Finv (args, nargout);
 }
diff --git a/src/DLD-FUNCTIONS/kron.cc b/src/DLD-FUNCTIONS/kron.cc
--- a/src/DLD-FUNCTIONS/kron.cc
+++ b/src/DLD-FUNCTIONS/kron.cc
@@ -171,17 +171,17 @@ do_kron (const octave_value& a, const oc
   MTB bm = octave_value_extract<MTB> (b);
   return octave_value (kron (am, bm));
 }
 
 #define ALL_TYPES(AMT, BMT) \
   } while (0) \
 
 DEFUN_DLD (kron, args, , "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} kron (@var{a}, @var{b})\n\
+@deftypefn {Loadable Function} {} kron (@var{A}, @var{B})\n\
 Form the Kronecker product of two matrices, defined block by block as\n\
 \n\
 @example\n\
 x = [a(i, j) b]\n\
 @end example\n\
 \n\
 For example:\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/lookup.cc b/src/DLD-FUNCTIONS/lookup.cc
--- a/src/DLD-FUNCTIONS/lookup.cc
+++ b/src/DLD-FUNCTIONS/lookup.cc
@@ -264,19 +264,19 @@ at most n-1).\n\
       right_inf = contains_char (opt, 'r');
       match_idx = contains_char (opt, 'm');
       match_bool = contains_char (opt, 'b');
     }
 
   if ((match_idx || match_bool) && (left_inf || right_inf))
     error ("lookup: m, b cannot be specified with l or r");
   else if (match_idx && match_bool)
-    error ("lookup: only one of m, b can be specified");
+    error ("lookup: only one of m or b can be specified");
   else if (str_case && (left_inf || right_inf))
-    error ("lookup: l,r not recognized for string lookups");
+    error ("lookup: l, r are not recognized for string lookups");
 
   if (error_state)
     return retval;
 
   if (num_case) 
     {
 
       // In the case of a complex array, absolute values will be used for compatibility
diff --git a/src/DLD-FUNCTIONS/lsode.cc b/src/DLD-FUNCTIONS/lsode.cc
--- a/src/DLD-FUNCTIONS/lsode.cc
+++ b/src/DLD-FUNCTIONS/lsode.cc
@@ -153,17 +153,18 @@ lsode_user_jacobian (const ColumnVector&
     { \
       ::error ("lsode: " fmt, arg); \
       LSODE_ABORT (); \
     } \
   while (0)
 
 DEFUN_DLD (lsode, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{x}, @var{istate}, @var{msg}] =} lsode (@var{fcn}, @var{x_0}, @var{t}, @var{t_crit})\n\
+@deftypefn  {Loadable Function} {[@var{x}, @var{istate}, @var{msg}] =} lsode (@var{fcn}, @var{x_0}, @var{t})\n\
+@deftypefnx {Loadable Function} {[@var{x}, @var{istate}, @var{msg}] =} lsode (@var{fcn}, @var{x_0}, @var{t}, @var{t_crit})\n\
 Solve the set of differential equations\n\
 @tex\n\
 $$ {dx \\over dt} = f (x, t) $$\n\
 with\n\
 $$ x(t_0) = x_0 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/lu.cc b/src/DLD-FUNCTIONS/lu.cc
--- a/src/DLD-FUNCTIONS/lu.cc
+++ b/src/DLD-FUNCTIONS/lu.cc
@@ -58,31 +58,32 @@ get_lu_u (const base_lu<MT>& fact)
   if (U.is_square () && fact.regular ())
     return octave_value (U, MatrixType (MatrixType::Upper));
   else
     return U;
 }
 
 DEFUN_DLD (lu, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {[@var{l}, @var{u}] =} lu (@var{a})\n\
-@deftypefnx {Loadable Function} {[@var{l}, @var{u}, @var{p}] =} lu (@var{a})\n\
-@deftypefnx {Loadable Function} {[@var{l}, @var{u}, @var{p}, @var{q}] =} lu (@var{s})\n\
-@deftypefnx {Loadable Function} {[@var{l}, @var{u}, @var{p}, @var{q}, @var{r}] =} lu (@var{s})\n\
-@deftypefnx {Loadable Function} {[@dots{}] =} lu (@var{s}, @var{thres})\n\
+@deftypefn  {Loadable Function} {[@var{L}, @var{U}] =} lu (@var{A})\n\
+@deftypefnx {Loadable Function} {[@var{L}, @var{U}, @var{P}] =} lu (@var{A})\n\
+@deftypefnx {Loadable Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} lu (@var{S})\n\
+@deftypefnx {Loadable Function} {[@var{L}, @var{U}, @var{P}, @var{Q}, @var{R}] =} lu (@var{S})\n\
+@deftypefnx {Loadable Function} {[@dots{}] =} lu (@var{S}, @var{thres})\n\
 @deftypefnx {Loadable Function} {@var{y} =} lu (@dots{})\n\
 @deftypefnx {Loadable Function} {[@dots{}] =} lu (@dots{}, 'vector')\n\
 @cindex LU decomposition\n\
-Compute the LU decomposition of @var{a}.  If @var{a} is full subroutines from\n\
-@sc{lapack} are used and if @var{a} is sparse then @sc{umfpack} is used.  The\n\
+Compute the LU@tie{}decomposition of @var{A}.  If @var{A} is full\n\
+subroutines from\n\
+@sc{lapack} are used and if @var{A} is sparse then @sc{umfpack} is used.  The\n\
 result is returned in a permuted form, according to the optional return\n\
-value @var{p}.  For example, given the matrix @code{a = [1, 2; 3, 4]},\n\
+value @var{P}.  For example, given the matrix @code{a = [1, 2; 3, 4]},\n\
 \n\
 @example\n\
-[l, u, p] = lu (a)\n\
+[l, u, p] = lu (@var{a})\n\
 @end example\n\
 \n\
 @noindent\n\
 returns\n\
 \n\
 @example\n\
 @group\n\
 l =\n\
@@ -99,47 +100,47 @@ p =\n\
 \n\
   0  1\n\
   1  0\n\
 @end group\n\
 @end example\n\
 \n\
 The matrix is not required to be square.\n\
 \n\
-Called with two or three output arguments and a spare input matrix,\n\
-then @dfn{lu} does not attempt to perform sparsity preserving column\n\
+When called with two or three output arguments and a spare input matrix,\n\
+@code{lu} does not attempt to perform sparsity preserving column\n\
 permutations.  Called with a fourth output argument, the sparsity\n\
 preserving column transformation @var{Q} is returned, such that\n\
-@code{@var{p} * @var{a} * @var{q} = @var{l} * @var{u}}.\n\
+@code{@var{P} * @var{A} * @var{Q} = @var{L} * @var{U}}.\n\
 \n\
-Called with a fifth output argument and a sparse input matrix, then\n\
-@dfn{lu} attempts to use a scaling factor @var{r} on the input matrix\n\
+Called with a fifth output argument and a sparse input matrix,\n\
+@code{lu} attempts to use a scaling factor @var{R} on the input matrix\n\
 such that\n\
-@code{@var{p} * (@var{r} \\ @var{a}) * @var{q} = @var{l} * @var{u}}.\n\
+@code{@var{P} * (@var{R} \\ @var{A}) * @var{Q} = @var{L} * @var{U}}.\n\
 This typically leads to a sparser and more stable factorization.\n\
 \n\
 An additional input argument @var{thres}, that defines the pivoting\n\
 threshold can be given.  @var{thres} can be a scalar, in which case\n\
-it defines @sc{umfpack} pivoting tolerance for both symmetric and unsymmetric\n\
-cases.  If @var{thres} is a two element vector, then the first element\n\
-defines the pivoting tolerance for the unsymmetric @sc{umfpack} pivoting\n\
-strategy and the second the symmetric strategy.  By default, the values\n\
-defined by @code{spparms} are used and are by default @code{[0.1, 0.001]}.\n\
+it defines the @sc{umfpack} pivoting tolerance for both symmetric and\n\
+unsymmetric cases.  If @var{thres} is a 2-element vector, then the first\n\
+element defines the pivoting tolerance for the unsymmetric @sc{umfpack}\n\
+pivoting strategy and the second for the symmetric strategy.  By default,\n\
+the values defined by @code{spparms} are used ([0.1, 0.001]).\n\
 \n\
-Given the string argument 'vector', @dfn{lu} returns the values of @var{p}\n\
-@var{q} as vector values, such that for full matrix, @code{@var{a}\n\
-(@var{p},:) = @var{l} * @var{u}}, and @code{@var{r}(@var{p},:) * @var{a}\n\
-(:, @var{q}) = @var{l} * @var{u}}.\n\
+Given the string argument 'vector', @code{lu} returns the values of @var{P}\n\
+and @var{Q} as vector values, such that for full matrix, @code{@var{A}\n\
+(@var{P},:) = @var{L} * @var{U}}, and @code{@var{R}(@var{P},:) * @var{A}\n\
+(:, @var{Q}) = @var{L} * @var{U}}.\n\
 \n\
 With two output arguments, returns the permuted forms of the upper and\n\
-lower triangular matrices, such that @code{@var{a} = @var{l} * @var{u}}.\n\
+lower triangular matrices, such that @code{@var{A} = @var{L} * @var{U}}.\n\
 With one output argument @var{y}, then the matrix returned by the @sc{lapack}\n\
-routines is returned.  If the input matrix is sparse then the matrix @var{l}\n\
-is embedded into @var{u} to give a return value similar to the full case.\n\
-For both full and sparse matrices, @dfn{lu} loses the permutation\n\
+routines is returned.  If the input matrix is sparse then the matrix @var{L}\n\
+is embedded into @var{U} to give a return value similar to the full case.\n\
+For both full and sparse matrices, @code{lu} loses the permutation\n\
 information.\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
   bool issparse = (nargin > 0 && args(0).is_sparse_type ());
   bool scale = (nargout  == 5);
 
@@ -170,27 +171,27 @@ information.\n\
         }
       else
         {
           Matrix tmp = args(n++).matrix_value ();
 
           if (! error_state )
             {
               if (!issparse)
-                error ("lu: can not define pivoting threshold for full matrices");
+                error ("lu: can not define pivoting threshold THRES for full matrices");
               else if (tmp.nelem () == 1)
                 {
                   thres.resize(1,2);
                   thres(0) = tmp(0);
                   thres(1) = tmp(0);
                 }
               else if (tmp.nelem () == 2)
                 thres = tmp;
               else
-                error ("lu: expecting 2 element vector for thres");
+                error ("lu: expecting 2-element vector for THRES");
             }
         }
     }
 
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
@@ -591,17 +592,17 @@ bool check_lu_dims (const octave_value& 
   octave_idx_type m = l.rows (), k = u.rows (), n = u.columns ();
   return ((l.ndims () == 2 && u.ndims () == 2 && k == l.columns ())
             && k == std::min (m, n) &&
             (p.is_undefined () || p.rows () == m));
 }
 
 DEFUN_DLD (luupdate, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {[@var{L}, @var{U}] =} luupdate (@var{l}, @var{u}, @var{x}, @var{y})\n\
+@deftypefn  {Loadable Function} {[@var{L}, @var{U}] =} luupdate (@var{L}, @var{U}, @var{x}, @var{y})\n\
 @deftypefnx {Loadable Function} {[@var{L}, @var{U}, @var{P}] =} luupdate (@var{L}, @var{U}, @var{P}, @var{x}, @var{y})\n\
 Given an LU@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{L}*@var{U}}, @var{L}@tie{}lower unit trapezoidal and\n\
 @var{U}@tie{}upper trapezoidal, return the LU@tie{}factorization\n\
 of @w{@var{A} + @var{x}*@var{y}.'}, where @var{x} and @var{y} are\n\
 column vectors (rank-1 update) or matrices with equal number of columns\n\
 (rank-k update).\n\
 Optionally, row-pivoted updating can be used by supplying\n\
@@ -610,36 +611,37 @@ in that case, an updated permutation mat
 Note that if @var{L}, @var{U}, @var{P} is a pivoted LU@tie{}factorization\n\
 as obtained by @code{lu}:\n\
 \n\
 @example\n\
   [@var{L}, @var{U}, @var{P}] = lu (@var{A});\n\
 @end example\n\
 \n\
 @noindent\n\
-then a factorization of @code{@var{a}+@var{x}*@var{y}.'} can be obtained either\n\
-as\n\
+then a factorization of @code{@var{A}+@var{x}*@var{y}.'} can be obtained\n\
+either as\n\
 \n\
 @example\n\
   [@var{L1}, @var{U1}] = lu (@var{L}, @var{U}, @var{P}*@var{x}, @var{y})\n\
 @end example\n\
 \n\
 @noindent\n\
 or\n\
 \n\
 @example\n\
   [@var{L1}, @var{U1}, @var{P1}] = lu (@var{L}, @var{U}, @var{P}, @var{x}, @var{y})\n\
 @end example\n\
 \n\
-The first form uses the unpivoted algorithm, which is faster, but less stable.\n\
-The second form uses a slower pivoted algorithm, which is more stable.\n\
+The first form uses the unpivoted algorithm, which is faster, but less\n\
+stable.  The second form uses a slower pivoted algorithm, which is more\n\
+stable.\n\
 \n\
-Note that the matrix case is done as a sequence of rank-1 updates;\n\
-thus, for k large enough, it will be both faster and more accurate to recompute\n\
-the factorization from scratch.\n\
+The matrix case is done as a sequence of rank-1 updates;\n\
+thus, for large enough k, it will be both faster and more accurate to\n\
+recompute the factorization from scratch.\n\
 @seealso{lu,qrupdate,cholupdate}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
   octave_value_list retval;
 
   bool pivoted = nargin == 5;
 
@@ -751,20 +753,20 @@ the factorization from scratch.\n\
                   if (pivoted)
                     retval(2) = fact.P ();
                   retval(1) = get_lu_u (fact);
                   retval(0) = get_lu_l (fact);
                 }
             }
         }
       else
-        error ("luupdate: dimensions mismatch");
+        error ("luupdate: dimension mismatch");
     }
   else
-    error ("luupdate: expecting numeric arguments");
+    error ("luupdate: L, U, X, and Y must be numeric");
 
   return retval;
 }
 
 /*
 %!shared A, u, v, Ac, uc, vc
 %! A = [0.091364  0.613038  0.999083;
 %!      0.594638  0.425302  0.603537;
diff --git a/src/DLD-FUNCTIONS/luinc.cc b/src/DLD-FUNCTIONS/luinc.cc
--- a/src/DLD-FUNCTIONS/luinc.cc
+++ b/src/DLD-FUNCTIONS/luinc.cc
@@ -34,70 +34,70 @@ along with Octave; see the file COPYING.
 #include "MatrixType.h"
 #include "SparseCmplxLU.h"
 #include "SparsedbleLU.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
 DEFUN_DLD (luinc, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {[@var{l}, @var{u}, @var{p}, @var{q}] =} luinc (@var{a}, '0')\n\
-@deftypefnx {Loadable Function} {[@var{l}, @var{u}, @var{p}, @var{q}] =} luinc (@var{a}, @var{droptol})\n\
-@deftypefnx {Loadable Function} {[@var{l}, @var{u}, @var{p}, @var{q}] =} luinc (@var{a}, @var{opts})\n\
+@deftypefn  {Loadable Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, '0')\n\
+@deftypefnx {Loadable Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, @var{droptol})\n\
+@deftypefnx {Loadable Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, @var{opts})\n\
 @cindex LU decomposition\n\
-Produce the incomplete LU factorization of the sparse matrix @var{a}.\n\
+Produce the incomplete LU factorization of the sparse matrix @var{A}.\n\
 Two types of incomplete factorization are possible, and the type\n\
-is determined by the second argument to @dfn{luinc}.\n\
+is determined by the second argument to @code{luinc}.\n\
 \n\
 Called with a second argument of '0', the zero-level incomplete\n\
-LU factorization is produced.  This creates a factorization of @var{a}\n\
+LU@tie{}factorization is produced.  This creates a factorization of @var{A}\n\
 where the position of the non-zero arguments correspond to the same\n\
-positions as in the matrix @var{a}.\n\
+positions as in the matrix @var{A}.\n\
 \n\
-Alternatively, the fill-in of the incomplete LU factorization can\n\
+Alternatively, the fill-in of the incomplete LU@tie{}factorization can\n\
 be controlled through the variable @var{droptol} or the structure\n\
 @var{opts}.  The @sc{umfpack} multifrontal factorization code by Tim A.\n\
-Davis is used for the incomplete LU factorization, (availability\n\
+Davis is used for the incomplete LU@tie{}factorization, (availability\n\
 @url{http://www.cise.ufl.edu/research/sparse/umfpack/})\n\
 \n\
-@var{droptol} determines the values below which the values in the LU\n\
-factorization are dropped and replaced by zero.  It must be a positive\n\
-scalar, and any values in the factorization whose absolute value are\n\
-less than this value are dropped, expect if leaving them increase the\n\
-sparsity of the matrix.  Setting @var{droptol} to zero results in a\n\
-complete LU factorization which is the default.\n\
+@var{droptol} determines the values below which the values in the\n\
+LU@tie{} factorization are dropped and replaced by zero.  It must be a\n\
+positive scalar, and any values in the factorization whose absolute value\n\
+are less than this value are dropped, expect if leaving them increase the\n\
+sparsity of the matrix.  Setting @var{droptol} to zero results in a complete\n\
+LU@tie{}factorization which is the default.\n\
 \n\
 @var{opts} is a structure containing one or more of the fields\n\
 \n\
 @table @code\n\
 @item droptol\n\
 The drop tolerance as above.  If @var{opts} only contains @code{droptol}\n\
 then this is equivalent to using the variable @var{droptol}.\n\
 \n\
 @item milu\n\
-A logical variable flagging whether to use the modified incomplete LU\n\
-factorization.  In the case that @code{milu} is true, the dropped values\n\
-are subtracted from the diagonal of the matrix U of the factorization.\n\
-The default is @code{false}.\n\
+A logical variable flagging whether to use the modified incomplete\n\
+LU@tie{} factorization.  In the case that @code{milu} is true, the dropped\n\
+values are subtracted from the diagonal of the matrix @var{U} of the\n\
+factorization.  The default is @code{false}.\n\
 \n\
 @item udiag\n\
-A logical variable that flags whether zero elements on the diagonal of U\n\
-should be replaced with @var{droptol} to attempt to avoid singular\n\
+A logical variable that flags whether zero elements on the diagonal of\n\
+@var{U} should be replaced with @var{droptol} to attempt to avoid singular\n\
 factors.  The default is @code{false}.\n\
 \n\
 @item thresh\n\
 Defines the pivot threshold in the interval [0,1].  Values outside that\n\
 range are ignored.\n\
 @end table\n\
 \n\
-All other fields in @var{opts} are ignored.  The outputs from @dfn{luinc}\n\
-are the same as for @dfn{lu}.\n\
+All other fields in @var{opts} are ignored.  The outputs from @code{luinc}\n\
+are the same as for @code{lu}.\n\
 \n\
-Given the string argument 'vector', @dfn{luinc} returns the values of @var{p}\n\
-@var{q} as vector values.\n\
+Given the string argument 'vector', @code{luinc} returns the values of\n\
+@var{p} @var{q} as vector values.\n\
 @seealso{sparse, lu}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value_list retval;
 
   if (nargin == 0)
     print_usage ();
@@ -154,24 +154,24 @@ Given the string argument 'vector', @dfn
 
                   if (thresh.nelem () == 1)
                     {
                       thresh.resize(1,2);
                       thresh(1) = thresh(0);
                     }
                   else if (thresh.nelem () != 2)
                     {
-                      error ("luinc: expecting 2 element vector for thresh");
+                      error ("luinc: expecting 2-element vector for thresh");
                       return retval;
                     }
                 }
             }
           else
             {
-              error ("luinc: options argument must be a scalar structure");
+              error ("luinc: OPTS must be a scalar structure");
               return retval;
             }
         }
       else
         droptol = args(1).double_value ();
 
       if (nargin == 3)
         {
@@ -352,17 +352,17 @@ Given the string argument 'vector', @dfn
                                                       MatrixType (MatrixType::Lower));
                           }
                       }
                       break;
                     }
                 }
             }
           else
-            error ("luinc: first argument must be sparse");
+            error ("luinc: matrix A must be sparse");
         }
     }
 
   return retval;
 }
 
 /*
 
diff --git a/src/DLD-FUNCTIONS/matrix_type.cc b/src/DLD-FUNCTIONS/matrix_type.cc
--- a/src/DLD-FUNCTIONS/matrix_type.cc
+++ b/src/DLD-FUNCTIONS/matrix_type.cc
@@ -33,46 +33,46 @@ along with Octave; see the file COPYING.
 #include "ov-cx-mat.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "MatrixType.h"
 #include "oct-locbuf.h"
 
 DEFUN_DLD (matrix_type, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{type} =} matrix_type (@var{a})\n\
-@deftypefnx {Loadable Function} {@var{type} =} matrix_type (@var{a}, 'nocompute')\n\
-@deftypefnx {Loadable Function} {@var{a} =} matrix_type (@var{a}, @var{type})\n\
-@deftypefnx {Loadable Function} {@var{a} =} matrix_type (@var{a}, 'upper', @var{perm})\n\
-@deftypefnx {Loadable Function} {@var{a} =} matrix_type (@var{a}, 'lower', @var{perm})\n\
-@deftypefnx {Loadable Function} {@var{a} =} matrix_type (@var{a}, 'banded', @var{nl}, @var{nu})\n\
+@deftypefn  {Loadable Function} {@var{type} =} matrix_type (@var{A})\n\
+@deftypefnx {Loadable Function} {@var{type} =} matrix_type (@var{A}, 'nocompute')\n\
+@deftypefnx {Loadable Function} {@var{A} =} matrix_type (@var{A}, @var{type})\n\
+@deftypefnx {Loadable Function} {@var{A} =} matrix_type (@var{A}, 'upper', @var{perm})\n\
+@deftypefnx {Loadable Function} {@var{A} =} matrix_type (@var{A}, 'lower', @var{perm})\n\
+@deftypefnx {Loadable Function} {@var{A} =} matrix_type (@var{A}, 'banded', @var{nl}, @var{nu})\n\
 Identify the matrix type or mark a matrix as a particular type.  This allows\n\
-rapid for solutions of linear equations involving @var{a} to be performed.  \n\
+more rapid solutions of linear equations involving @var{A} to be performed.  \n\
 Called with a single argument, @code{matrix_type} returns the type of the\n\
 matrix and caches it for future use.  Called with more than one argument,\n\
 @code{matrix_type} allows the type of the matrix to be defined.\n\
 \n\
 If the option 'nocompute' is given, the function will not attempt to guess\n\
 the type if it is still unknown.  This is useful for debugging purposes.\n\
 \n\
 The possible matrix types depend on whether the matrix is full or sparse, and\n\
 can be one of the following\n\
 \n\
 @table @asis\n\
 @item 'unknown'\n\
-Remove any previously cached matrix type, and mark type as unknown\n\
+Remove any previously cached matrix type, and mark type as unknown.\n\
 \n\
 @item 'full'\n\
 Mark the matrix as full.\n\
 \n\
 @item 'positive definite'\n\
 Probable full positive definite matrix.\n\
 \n\
 @item 'diagonal'\n\
-Diagonal Matrix.  (Sparse matrices only)\n\
+Diagonal matrix.  (Sparse matrices only)\n\
 \n\
 @item 'permuted diagonal'\n\
 Permuted Diagonal matrix.  The permutation does not need to be specifically\n\
 indicated, as the structure of the matrix explicitly gives this.  (Sparse\n\
 matrices only)\n\
 \n\
 @item 'upper'\n\
 Upper triangular.  If the optional third argument @var{perm} is given, the\n\
@@ -84,38 +84,38 @@ Lower triangular.  If the optional third
 matrix is assumed to be a permuted lower triangular with the permutations\n\
 defined by the vector @var{perm}.\n\
 \n\
 @item 'banded'\n\
 @itemx 'banded positive definite'\n\
 Banded matrix with the band size of @var{nl} below the diagonal and @var{nu}\n\
 above it.  If @var{nl} and @var{nu} are 1, then the matrix is tridiagonal and\n\
 treated with specialized code.  In addition the matrix can be marked as\n\
-probably a positive definite (Sparse matrices only)\n\
+probably a positive definite.  (Sparse matrices only)\n\
 \n\
 @item 'singular'\n\
 The matrix is assumed to be singular and will be treated with a minimum norm\n\
-solution\n\
+solution.\n\
 \n\
 @end table\n\
 \n\
 Note that the matrix type will be discovered automatically on the first\n\
-attempt to solve a linear equation involving @var{a}.  Therefore\n\
+attempt to solve a linear equation involving @var{A}.  Therefore\n\
 @code{matrix_type} is only useful to give Octave hints of the matrix type.  \n\
 Incorrectly defining the matrix type will result in incorrect results from\n\
-solutions of linear equations, and so it is entirely the responsibility of\n\
-the user to correctly identify the matrix type.\n\
+solutions of linear equations; it is entirely @strong{the responsibility of\n\
+the user} to correctly identify the matrix type.\n\
 \n\
-Also the test for positive definiteness is a low-cost test for a Hermitian\n\
+Also, the test for positive definiteness is a low-cost test for a Hermitian\n\
 matrix with a real positive diagonal.  This does not guarantee that the\n\
 matrix is positive definite, but only that it is a probable candidate.  When\n\
-such a matrix is factorized, a Cholesky factorization is first attempted,\n\
-and if that fails the matrix is then treated with an LU factorization.  Once\n\
-the matrix has been factorized, @code{matrix_type} will return the correct\n\
-classification of the matrix.\n\
+such a matrix is factorized, a Cholesky@tie{}factorization is first\n\
+attempted, and if that fails the matrix is then treated with an\n\
+LU@tie{}factorization.  Once the matrix has been factorized,\n\
+@code{matrix_type} will return the correct classification of the matrix.\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin == 0)
     print_usage ();
   else if (nargin > 4)
@@ -215,17 +215,17 @@ classification of the matrix.\n\
 
               // FIXME -- why do I have to explicitly call the constructor?
               MatrixType mattyp = MatrixType ();
 
               octave_idx_type nl = 0;
               octave_idx_type nu = 0;
               
               if (error_state)
-                error ("Matrix type must be a string");
+                error ("matrix_type: TYPE must be a string");
               else
                 {
                   // Use STL function to convert to lower case
                   std::transform (str_typ.begin (), str_typ.end (),
                                   str_typ.begin (), tolower);
 
                   if (str_typ == "diagonal")
                     mattyp.mark_as_diagonal ();
@@ -275,24 +275,24 @@ classification of the matrix.\n\
                   if (! error_state)
                     {
                       if (nargin == 3 && (str_typ == "upper" || str_typ == "lower"))
                         {
                           const ColumnVector perm = 
                             ColumnVector (args (2).vector_value ());
 
                           if (error_state)
-                            error ("matrix_type: Invalid permutation vector");
+                            error ("matrix_type: Invalid permutation vector PERM");
                           else
                             {
                               octave_idx_type len = perm.length ();
                               dim_vector dv = args(0).dims ();
                               
                               if (len != dv(0))
-                                error ("matrix_type: Invalid permutation vector");
+                                error ("matrix_type: Invalid permutation vector PERM");
                               else
                                 {
                                   OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
 
                                   for (octave_idx_type i = 0; i < len; i++)
                                     p[i] = static_cast<octave_idx_type> (perm (i)) - 1; 
 
                                   if (str_typ == "upper")
@@ -408,17 +408,17 @@ classification of the matrix.\n\
             {
               // Ok, we're changing the matrix type
               std::string str_typ = args(1).string_value ();
 
               // FIXME -- why do I have to explicitly call the constructor?
               MatrixType mattyp = MatrixType (MatrixType::Unknown, true);
 
               if (error_state)
-                error ("Matrix type must be a string");
+                error ("matrix_type: TYPE must be a string");
               else
                 {
                   // Use STL function to convert to lower case
                   std::transform (str_typ.begin (), str_typ.end (),
                                   str_typ.begin (), tolower);
 
                   if (str_typ == "upper")
                     mattyp.mark_as_upper_triangular ();
@@ -442,24 +442,24 @@ classification of the matrix.\n\
                     {
                       if (nargin == 3 && (str_typ == "upper" 
                                           || str_typ == "lower"))
                         {
                           const ColumnVector perm = 
                             ColumnVector (args (2).vector_value ());
 
                           if (error_state)
-                            error ("matrix_type: Invalid permutation vector");
+                            error ("matrix_type: Invalid permutation vector PERM");
                           else
                             {
                               octave_idx_type len = perm.length ();
                               dim_vector dv = args(0).dims ();
                               
                               if (len != dv(0))
-                                error ("matrix_type: Invalid permutation vector");
+                                error ("matrix_type: Invalid permutation vector PERM");
                               else
                                 {
                                   OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
 
                                   for (octave_idx_type i = 0; i < len; i++)
                                     p[i] = static_cast<octave_idx_type> (perm (i)) - 1; 
 
                                   if (str_typ == "upper")
diff --git a/src/DLD-FUNCTIONS/max.cc b/src/DLD-FUNCTIONS/max.cc
--- a/src/DLD-FUNCTIONS/max.cc
+++ b/src/DLD-FUNCTIONS/max.cc
@@ -168,17 +168,17 @@ do_minmax_body (const octave_value_list&
     {
       octave_value arg = args(0);
       int dim = -1;
       if (nargin == 3)
         {
           dim = args(2).int_value (true) - 1;
           if (error_state || dim < 0)
             {
-              error ("%s: invalid dimension", func);
+              error ("%s: DIM must be a valid dimension", func);
               return retval;
             }
 
           if (! args(1).is_empty ())
             warning ("%s: second argument is ignored");
         }
 
       switch (arg.builtin_type ())
@@ -507,17 +507,17 @@ do_cumminmax_body (const octave_value_li
     {
       octave_value arg = args(0);
       int dim = -1;
       if (nargin == 2)
         {
           dim = args(1).int_value (true) - 1;
           if (error_state || dim < 0)
             {
-              error ("%s: invalid dimension", func);
+              error ("%s: DIM must be a valid dimension", func);
               return retval;
             }
         }
 
       switch (arg.builtin_type ())
         {
         case btyp_double:
           retval = do_cumminmax_red_op<NDArray> (arg, nargout, dim, ismin);
diff --git a/src/DLD-FUNCTIONS/md5sum.cc b/src/DLD-FUNCTIONS/md5sum.cc
--- a/src/DLD-FUNCTIONS/md5sum.cc
+++ b/src/DLD-FUNCTIONS/md5sum.cc
@@ -35,17 +35,17 @@ along with Octave; see the file COPYING.
 #include "load-path.h"
 #include "oct-env.h"
 #include "oct-md5.h"
 
 DEFUN_DLD (md5sum, args, ,
    "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} md5sum (@var{file})\n\
 @deftypefnx {Loadable Function} {} md5sum (@var{str}, @var{opt})\n\
-Calculates the MD5 sum of the file @var{file}.  If the second parameter\n\
+Calculate the MD5 sum of the file @var{file}.  If the second parameter\n\
 @var{opt} exists and is true, then calculate the MD5 sum of the\n\
 string @var{str}.\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
   if (nargin != 1 && nargin != 2)
diff --git a/src/DLD-FUNCTIONS/onCleanup.cc b/src/DLD-FUNCTIONS/onCleanup.cc
--- a/src/DLD-FUNCTIONS/onCleanup.cc
+++ b/src/DLD-FUNCTIONS/onCleanup.cc
@@ -247,17 +247,17 @@ octave_oncleanup::print_raw (std::ostrea
   if (fcn.is_defined ())
     fcn.print_raw (os, pr_as_read_syntax);
   os << ")";
 }
 
 DEFUN_DLD (onCleanup, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{c} =} onCleanup (@var{action})\n\
-Creates a special object that executes a given function upon destruction.\n\
+Create a special object that executes a given function upon destruction.\n\
 If the object is copied to multiple variables (or cell or struct array\n\
 elements) or returned from a function, @var{action} will be executed after\n\
 clearing the last copy of the object.  Note that if multiple local onCleanup\n\
 variables are created, the order in which they are called is unspecified.\n\
 @seealso{unwind_protect}\n\
 @end deftypefn")
 {
   octave_value retval;
diff --git a/src/DLD-FUNCTIONS/pinv.cc b/src/DLD-FUNCTIONS/pinv.cc
--- a/src/DLD-FUNCTIONS/pinv.cc
+++ b/src/DLD-FUNCTIONS/pinv.cc
@@ -33,17 +33,18 @@ along with Octave; see the file COPYING.
 #include "ov-re-diag.h"
 #include "ov-cx-diag.h"
 #include "ov-flt-re-diag.h"
 #include "ov-flt-cx-diag.h"
 #include "ov-perm.h"
 
 DEFUN_DLD (pinv, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} pinv (@var{x}, @var{tol})\n\
+@deftypefn  {Loadable Function} {} pinv (@var{x})\n\
+@deftypefnx {Loadable Function} {} pinv (@var{x}, @var{tol})\n\
 Return the pseudoinverse of @var{x}.  Singular values less than\n\
 @var{tol} are ignored.  \n\
 \n\
 If the second argument is omitted, it is assumed that\n\
 \n\
 @example\n\
 tol = max (size (@var{x})) * sigma_max (@var{x}) * eps,\n\
 @end example\n\
@@ -103,17 +104,17 @@ where @code{sigma_max (@var{x})} is the 
       if (nargin == 2)
         tol = args(1).float_value ();
 
       if (error_state)
         return retval;
 
       if (tol < 0.0)
         {
-          error ("pinv: tol must be greater than zero");
+          error ("pinv: TOL must be greater than zero");
           return retval;
         }
 
       if (arg.is_real_type ())
         {
           FloatMatrix m = arg.float_matrix_value ();
 
           if (! error_state)
@@ -137,17 +138,17 @@ where @code{sigma_max (@var{x})} is the 
       if (nargin == 2)
         tol = args(1).double_value ();
 
       if (error_state)
         return retval;
 
       if (tol < 0.0)
         {
-          error ("pinv: tol must be greater than zero");
+          error ("pinv: TOL must be greater than zero");
           return retval;
         }
 
       if (arg.is_real_type ())
         {
           Matrix m = arg.matrix_value ();
 
           if (! error_state)
diff --git a/src/DLD-FUNCTIONS/qr.cc b/src/DLD-FUNCTIONS/qr.cc
--- a/src/DLD-FUNCTIONS/qr.cc
+++ b/src/DLD-FUNCTIONS/qr.cc
@@ -69,37 +69,37 @@ get_qr_r (const base_qr<MT>& fact)
 // [Q, R, P] = qr (X, 0): form the economy decomposition with
 //                        permutation vector P such that Q * R = X (:, P)
 //
 // qr (X) alone returns the output of the LAPACK routine dgeqrf, such
 // that R = triu (qr (X))
 
 DEFUN_DLD (qr, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {[@var{q}, @var{r}, @var{p}] =} qr (@var{a})\n\
-@deftypefnx {Loadable Function} {[@var{q}, @var{r}, @var{p}] =} qr (@var{a}, '0')\n\
+@deftypefn  {Loadable Function} {[@var{Q}, @var{R}, @var{P}] =} qr (@var{A})\n\
+@deftypefnx {Loadable Function} {[@var{Q}, @var{R}, @var{P}] =} qr (@var{A}, '0')\n\
 @cindex QR factorization\n\
-Compute the QR factorization of @var{a}, using standard @sc{lapack}\n\
-subroutines.  For example, given the matrix @code{a = [1, 2; 3, 4]},\n\
+Compute the QR@tie{}factorization of @var{A}, using standard @sc{lapack}\n\
+subroutines.  For example, given the matrix @code{@var{A} = [1, 2; 3, 4]},\n\
 \n\
 @example\n\
-[q, r] = qr (a)\n\
+[@var{Q}, @var{R}] = qr (@var{A})\n\
 @end example\n\
 \n\
 @noindent\n\
 returns\n\
 \n\
 @example\n\
 @group\n\
-q =\n\
+@var{Q} =\n\
 \n\
   -0.31623  -0.94868\n\
   -0.94868   0.31623\n\
 \n\
-r =\n\
+@var{R} =\n\
 \n\
   -3.16228  -4.42719\n\
    0.00000  -0.63246\n\
 @end group\n\
 @end example\n\
 \n\
 The @code{qr} factorization has applications in the solution of least\n\
 squares problems\n\
@@ -115,84 +115,86 @@ squares problems\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 for overdetermined systems of equations (i.e.,\n\
 @tex\n\
 $A$\n\
 @end tex\n\
 @ifnottex\n\
-@code{a}\n\
+@var{A}\n\
 @end ifnottex\n\
- is a tall, thin matrix).  The QR factorization is\n\
+ is a tall, thin matrix).  The QR@tie{}factorization is\n\
 @tex\n\
 $QR = A$ where $Q$ is an orthogonal matrix and $R$ is upper triangular.\n\
 @end tex\n\
 @ifnottex\n\
-@code{q * r = a} where @code{q} is an orthogonal matrix and @code{r} is\n\
-upper triangular.\n\
+@code{@var{Q} * @var{Q} = @var{A}} where @var{Q} is an orthogonal matrix and\n\
+@var{R} is upper triangular.\n\
 @end ifnottex\n\
 \n\
 If given a second argument of '0', @code{qr} returns an economy-sized\n\
-QR factorization, omitting zero rows of @var{R} and the corresponding\n\
+QR@tie{}factorization, omitting zero rows of @var{R} and the corresponding\n\
 columns of @var{Q}.\n\
 \n\
-If the matrix @var{a} is full, the permuted QR factorization\n\
-@code{[@var{q}, @var{r}, @var{p}] = qr (@var{a})} forms the QR factorization\n\
-such that the diagonal entries of @code{r} are decreasing in magnitude\n\
-order.  For example,given the matrix @code{a = [1, 2; 3, 4]},\n\
+If the matrix @var{A} is full, the permuted QR@tie{}factorization\n\
+@code{[@var{Q}, @var{R}, @var{P}] = qr (@var{A})} forms the\n\
+QR@tie{}factorization such that the diagonal entries of @var{R} are\n\
+decreasing in magnitude order.  For example, given the matrix @code{a = [1,\n\
+2; 3, 4]},\n\
 \n\
 @example\n\
-[q, r, p] = qr(a)\n\
+[@var{Q}, @var{R}, @var{P}] = qr (@var{A})\n\
 @end example\n\
 \n\
 @noindent\n\
 returns\n\
 \n\
 @example\n\
 @group\n\
-q = \n\
+@var{Q} = \n\
 \n\
   -0.44721  -0.89443\n\
   -0.89443   0.44721\n\
 \n\
-r =\n\
+@var{R} =\n\
 \n\
   -4.47214  -3.13050\n\
    0.00000   0.44721\n\
 \n\
-p =\n\
+@var{P} =\n\
 \n\
    0  1\n\
    1  0\n\
 @end group\n\
 @end example\n\
 \n\
-The permuted @code{qr} factorization @code{[q, r, p] = qr (a)}\n\
-factorization allows the construction of an orthogonal basis of\n\
-@code{span (a)}.\n\
+The permuted @code{qr} factorization @code{[@var{Q}, @var{R}, @var{P}] = qr\n\
+(@var{A})} factorization allows the construction of an orthogonal basis of\n\
+@code{span (A)}.\n\
 \n\
-If the matrix @var{a} is sparse, then compute the sparse QR factorization\n\
-of @var{a}, using @sc{CSparse}.  As the matrix @var{Q} is in general a full\n\
-matrix, this function returns the @var{Q}-less factorization @var{r} of\n\
-@var{a}, such that @code{@var{r} = chol (@var{a}' * @var{a})}.\n\
+If the matrix @var{A} is sparse, then compute the sparse\n\
+QR@tie{}factorization of @var{A}, using @sc{CSparse}.  As the matrix @var{Q}\n\
+is in general a full matrix, this function returns the @var{Q}-less\n\
+factorization @var{R} of @var{A}, such that @code{@var{R} = chol (@var{A}' *\n\
+@var{A})}.\n\
 \n\
 If the final argument is the scalar @code{0} and the number of rows is\n\
 larger than the number of columns, then an economy factorization is\n\
-returned.  That is @var{r} will have only @code{size (@var{a},1)} rows.\n\
+returned.  That is @var{R} will have only @code{size (@var{A},1)} rows.\n\
 \n\
-If an additional matrix @var{b} is supplied, then @code{qr} returns\n\
-@var{c}, where @code{@var{c} = @var{q}' * @var{b}}.  This allows the\n\
-least squares approximation of @code{@var{a} \\ @var{b}} to be calculated\n\
+If an additional matrix @var{B} is supplied, then @code{qr} returns\n\
+@var{C}, where @code{@var{C} = @var{Q}' * @var{B}}.  This allows the\n\
+least squares approximation of @code{@var{A} \\ @var{B}} to be calculated\n\
 as\n\
 \n\
 @example\n\
 @group\n\
-[@var{c},@var{r}] = spqr (@var{a},@var{b})\n\
-@var{x} = @var{r} \\ @var{c}\n\
+[@var{C},@var{R}] = spqr (@var{A},@var{B})\n\
+x = @var{R} \\ @var{C}\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
@@ -771,17 +773,17 @@ Given a QR@tie{}factorization of a real 
 @w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and\n\
 @var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization\n\
 of @w{@var{A} + @var{u}*@var{v}'}, where @var{u} and @var{v} are\n\
 column vectors (rank-1 update) or matrices with equal number of columns\n\
 (rank-k update).  Notice that the latter case is done as a sequence of rank-1\n\
 updates; thus, for k large enough, it will be both faster and more accurate\n\
 to recompute the factorization from scratch.\n\
 \n\
-The QR factorization supplied may be either full\n\
+The QR@tie{}factorization supplied may be either full\n\
 (Q is square) or economized (R is square).\n\
 \n\
 @seealso{qr, qrinsert, qrdelete}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
   octave_value_list retval;
 
@@ -867,20 +869,20 @@ The QR factorization supplied may be eit
                   fact.update (u, v);
               
                   retval(1) = get_qr_r (fact);
                   retval(0) = fact.Q ();
                 }
             }
         }
       else
-        error ("qrupdate: dimensions mismatch");
+        error ("qrupdate: Q and R dimensions don't match");
     }
   else
-    error ("qrupdate: expecting numeric arguments");
+    error ("qrupdate: Q, R, U, and V must be numeric");
 
   return retval;
 }
 /*
 %!shared A, u, v, Ac, uc, vc
 %! A = [0.091364  0.613038  0.999083;
 %!      0.594638  0.425302  0.603537;
 %!      0.383594  0.291238  0.085574;
@@ -960,17 +962,17 @@ If @var{orient} is @code{\"col\"},\n\
 @var{u} may be a matrix and @var{j} an index vector\n\
 resulting in the QR@tie{}factorization of a matrix @var{B} such that\n\
 @w{B(:,@var{j})} gives @var{u} and @w{B(:,@var{j}) = []} gives @var{A}.\n\
 Notice that the latter case is done as a sequence of k insertions;\n\
 thus, for k large enough, it will be both faster and more accurate to\n\
 recompute the factorization from scratch.\n\
 \n\
 If @var{orient} is @code{\"col\"},\n\
-the QR factorization supplied may be either full\n\
+the QR@tie{}factorization supplied may be either full\n\
 (Q is square) or economized (R is square).\n\
 \n\
 If @var{orient} is @code{\"row\"}, full factorization is needed.\n\
 @seealso{qr, qrupdate, qrdelete}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
   octave_value_list retval;
@@ -1083,23 +1085,23 @@ If @var{orient} is @code{\"row\"}, full 
 
                         retval(1) = get_qr_r (fact);
                         retval(0) = fact.Q ();
                       }
                   }
 
               }
             else
-              error ("qrinsert: invalid index");
+              error ("qrinsert: invalid index J");
           }
         else
           error ("qrinsert: dimension mismatch");
 
       else
-        error ("qrinsert: orient must be \"col\" or \"row\"");
+        error ("qrinsert: ORIENT must be \"col\" or \"row\"");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -1179,17 +1181,17 @@ If @var{orient} is @code{\"col\"},\n\
 @var{j} may be an index vector\n\
 resulting in the QR@tie{}factorization of a matrix @var{B} such that\n\
 @w{A(:,@var{j}) = []} gives @var{B}.\n\
 Notice that the latter case is done as a sequence of k deletions;\n\
 thus, for k large enough, it will be both faster and more accurate to\n\
 recompute the factorization from scratch.\n\
 \n\
 If @var{orient} is @code{\"col\"},\n\
-the QR factorization supplied may be either full\n\
+the QR@tie{}factorization supplied may be either full\n\
 (Q is square) or economized (R is square).\n\
 \n\
 If @var{orient} is @code{\"row\"}, full factorization is needed.\n\
 @seealso{qr, qrinsert, qrupdate}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
   octave_value_list retval;
@@ -1289,23 +1291,23 @@ If @var{orient} is @code{\"row\"}, full 
                           fact.delete_row (j(0)-one);
 
                         retval(1) = get_qr_r (fact);
                         retval(0) = fact.Q ();
                       }
                   }
               }
             else
-              error ("qrdelete: invalid index");
+              error ("qrdelete: invalid index J");
           }
         else
           error ("qrdelete: dimension mismatch");
 
       else
-        error ("qrdelete: orient must be \"col\" or \"row\"");
+        error ("qrdelete: ORIENT must be \"col\" or \"row\"");
     }
   else
     print_usage ();
 
   return retval;
 }
  
 /*
@@ -1516,23 +1518,23 @@ of @w{@var{A}(:,p)}, where @w{p} is the 
                       fact.shift_cols (i-1, j-1);
                   
                       retval(1) = get_qr_r (fact);
                       retval(0) = fact.Q ();
                     }
                 }
             }
           else
-            error ("qrshift: invalid index");
+            error ("qrshift: invalid index I or J");
         }
       else
         error ("qrshift: dimensions mismatch");
     }
   else
-    error ("qrshift: expecting numeric arguments");
+    error ("qrshift: Q and R must be numeric");
 
   return retval;
 }
 /*
 %!test
 %! AA = A.';
 %! i = 2; j = 4; p = [1:i-1, shift(i:j,-1), j+1:5];
 %!
diff --git a/src/DLD-FUNCTIONS/quad.cc b/src/DLD-FUNCTIONS/quad.cc
--- a/src/DLD-FUNCTIONS/quad.cc
+++ b/src/DLD-FUNCTIONS/quad.cc
@@ -169,19 +169,22 @@ quad_float_user_function (float x)
     { \
       ::error ("quad: " fmt, arg); \
       QUAD_ABORT (); \
     } \
   while (0)
 
 DEFUN_DLD (quad, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{v}, @var{ier}, @var{nfun}, @var{err}] =} quad (@var{f}, @var{a}, @var{b}, @var{tol}, @var{sing})\n\
+@deftypefn  {Loadable Function} {@var{v} =} quad (@var{f}, @var{a}, @var{b})\n\
+@deftypefnx {Loadable Function} {@var{v} =} quad (@var{f}, @var{a}, @var{b}, @var{tol})\n\
+@deftypefnx {Loadable Function} {@var{v} =} quad (@var{f}, @var{a}, @var{b}, @var{tol}, @var{sing})\n\
+@deftypefnx {Loadable Function} {[@var{v}, @var{ier}, @var{nfun}, @var{err}] =} quad (@dots{})\n\
 Integrate a nonlinear function of one variable using @sc{quadpack}.\n\
-The first argument is the name of the function, the function handle or\n\
+The first argument is the name of the function, the function handle, or\n\
 the inline function to call to compute the value of the integrand.  It\n\
 must have the form\n\
 \n\
 @example\n\
 y = f (x)\n\
 @end example\n\
 \n\
 @noindent\n\
@@ -190,32 +193,33 @@ where @var{y} and @var{x} are scalars.\n
 The second and third arguments are limits of integration.  Either or\n\
 both may be infinite.\n\
 \n\
 The optional argument @var{tol} is a vector that specifies the desired\n\
 accuracy of the result.  The first element of the vector is the desired\n\
 absolute tolerance, and the second element is the desired relative\n\
 tolerance.  To choose a relative test only, set the absolute\n\
 tolerance to zero.  To choose an absolute test only, set the relative\n\
-tolerance to zero.  \n\
+tolerance to zero.\n\
 \n\
 The optional argument @var{sing} is a vector of values at which the\n\
 integrand is known to be singular.\n\
 \n\
-The result of the integration is returned in @var{v} and @var{ier}\n\
+The result of the integration is returned in @var{v}.  @var{ier}\n\
 contains an integer error code (0 indicates a successful integration).\n\
-The value of @var{nfun} indicates how many function evaluations were\n\
-required, and @var{err} contains an estimate of the error in the\n\
+@var{nfun} indicates the number of function evaluations that were\n\
+made, and @var{err} contains an estimate of the error in the\n\
 solution.\n\
 \n\
-You can use the function @code{quad_options} to set optional\n\
+The function @code{quad_options} can set other optional\n\
 parameters for @code{quad}.\n\
 \n\
-It should be noted that since @code{quad} is written in Fortran it\n\
+Note: because @code{quad} is written in Fortran it\n\
 cannot be called recursively.\n\
+@seealso{quad_options,quadv,quadl,quadgk,trapz}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   std::string fcn_name;
 
   warned_imaginary = false;
 
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -284,68 +284,69 @@ fout (const octave_idx_type& lsize, cons
   if (lsize == 1)
     return (fabs (alpha) >= fabs (beta) ? 1 : -1);
   else
     return (fabs (p) >= 1 ? 1 : -1);
 }
 
 DEFUN_DLD (qz, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{lambda} =} qz (@var{a}, @var{b})\n\
-Generalized eigenvalue problem @math{A x = s B x},\n\
-QZ decomposition.  There are three ways to call this function:\n\
+@deftypefn  {Loadable Function} {@var{lambda} =} qz (@var{A}, @var{B})\n\
+@deftypefnx {Loadable Function} {@var{lambda} =} qz (@var{A}, @var{B}, @var{opt})\n\
+QZ decomposition of the generalized eigenvalue problem (@math{A x = s B x}).\n\
+There are three ways to call this function:\n\
 @enumerate\n\
-@item @code{lambda = qz(A,B)}\n\
+@item @code{@var{lambda} = qz (@var{A}, @var{B})}\n\
 \n\
 Computes the generalized eigenvalues\n\
 @tex\n\
 $\\lambda$\n\
 @end tex\n\
 @ifnottex\n\
 @var{lambda}\n\
 @end ifnottex\n\
 of @math{(A - s B)}.\n\
 \n\
-@item @code{[AA, BB, Q, Z, V, W, lambda] = qz (A, B)}\n\
+@item @code{[AA, BB, Q, Z, V, W, @var{lambda}] = qz (@var{A}, @var{B})}\n\
 \n\
-Computes qz decomposition, generalized eigenvectors, and \n\
-generalized eigenvalues of @math{(A - sB)}\n\
+Computes QZ decomposition, generalized eigenvectors, and \n\
+generalized eigenvalues of @math{(A - s B)}\n\
 @tex\n\
 $$ AV = BV{ \\rm diag }(\\lambda) $$\n\
 $$ W^T A = { \\rm diag }(\\lambda)W^T B $$\n\
 $$ AA = Q^T AZ, BB = Q^T BZ $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @group\n\
 \n\
-    A * V = B * V * diag (lambda)\n\
-    W' * A = diag (lambda) * W' * B\n\
+    A * V = B * V * diag (@var{lambda})\n\
+    W' * A = diag (@var{lambda}) * W' * B\n\
     AA = Q * A * Z, BB = Q * B * Z\n\
 \n\
 @end group\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 with @var{Q} and @var{Z} orthogonal (unitary)= @var{I}\n\
 \n\
-@item @code{[AA,BB,Z@{, lambda@}] = qz(A,B,opt)}\n\
+@item @code{[AA,BB,Z@{, @var{lambda}@}] = qz (@var{A}, @var{B}, @var{opt})}\n\
 \n\
 As in form [2], but allows ordering of generalized eigenpairs\n\
 for (e.g.) solution of discrete time algebraic Riccati equations.\n\
 Form 3 is not available for complex matrices, and does not compute\n\
 the generalized eigenvectors @var{V}, @var{W}, nor the orthogonal matrix\n\
 @var{Q}.\n\
 \n\
 @table @var\n\
 @item opt\n\
 for ordering eigenvalues of the GEP pencil.  The leading block\n\
 of the revised pencil contains all eigenvalues that satisfy:\n\
-@table @code\n\
+@table @asis\n\
 @item \"N\"\n\
 = unordered (default) \n\
 \n\
 @item \"S\"\n\
 = small: leading block has all |lambda| @leq{} 1 \n\
 \n\
 @item \"B\"\n\
 = big: leading block has all |lambda| @geq{} 1 \n\
@@ -356,19 +357,19 @@ in the open left half-plane\n\
 \n\
 @item \"+\"\n\
 = non-negative real part: leading block has all eigenvalues\n\
 in the closed right half-plane\n\
 @end table\n\
 @end table\n\
 @end enumerate\n\
 \n\
-Note: qz performs permutation balancing, but not scaling (see balance).\n\
-The order of output arguments was selected for compatibility with @sc{matlab}\n\
-\n\
+Note: @code{qz} performs permutation balancing, but not scaling\n\
+(@pxref{doc-balance}).  The order of output arguments was selected for\n\
+compatibility with @sc{matlab}.\n\
 @seealso{balance, eig, schur}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
 
 #ifdef DEBUG
   std::cout << "qz: nargin = " << nargin << ", nargout = " << nargout << std::endl;
@@ -392,17 +393,17 @@ The order of output arguments was select
   // Determine ordering option.
   volatile char ord_job = 0;
   static double safmin;
 
   if (nargin == 2)
     ord_job = 'N';
   else if (!args(2).is_string ())
     {
-      error ("qz: argument 3 must be a string");
+      error ("qz: OPT must be a string");
       return retval;
     }
   else
     {
       std::string tmp = args(2).string_value ();
 
       if (! tmp.empty ())
         ord_job = tmp[0];
@@ -513,17 +514,17 @@ The order of output arguments was select
   // declared volatile to avoid compiler warnings about long jumps,
   // vforks.
 
   volatile int complex_case
     = (args(0).is_complex_type () || args(1).is_complex_type ());
 
   if (nargin == 3 && complex_case)
     {
-      error ("qz: cannot re-order complex qz decomposition.");
+      error ("qz: cannot re-order complex qz decomposition");
       return retval;
     }
 
   // First, declare variables used in both the real and complex case.
   Matrix QQ(nn,nn), ZZ(nn,nn), VR(nn,nn), VL(nn,nn);
   RowVector alphar(nn), alphai(nn), betar(nn);
   ComplexRowVector xalpha(nn), xbeta(nn);
   ComplexMatrix CQ(nn,nn), CZ(nn,nn), CVR(nn,nn), CVL(nn,nn);
@@ -790,17 +791,17 @@ The order of output arguments was select
     }
 
   // Order the QZ decomposition?
   if (! (ord_job == 'N' || ord_job == 'n'))
     {
       if (complex_case)
         {
           // Probably not needed, but better be safe.
-          error ("qz: cannot re-order complex qz decomposition.");
+          error ("qz: cannot re-order complex qz decomposition");
           return retval;
         }
       else
         {
 #ifdef DEBUG_SORT
           std::cout << "qz: ordering eigenvalues: ord_job = "
                     << ord_job << std::endl;
 #endif
@@ -1220,17 +1221,17 @@ The order of output arguments was select
     case 0:
 #ifdef DEBUG
       std::cout << "qz: retval(0) = gev = " << gev << std::endl;
 #endif
       retval(0) = gev;
       break;
 
     default:
-      error ("qz: too many return arguments.");
+      error ("qz: too many return arguments");
       break;
   }
 
 #ifdef DEBUG
   std::cout << "qz: exiting (at long last)" << std::endl;
 #endif
 
   return retval;
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -147,17 +147,17 @@ do_rand (const octave_value_list& args, 
               error ("%s: unrecognized string argument", fcn);
           }
         else if (tmp.is_scalar_type ())
           {
             double dval = tmp.double_value ();
 
             if (xisnan (dval))
               {
-                error ("%s: NaN is invalid a matrix dimension", fcn);
+                error ("%s: NaN is invalid matrix dimension", fcn);
               }
             else
               {
                 dims.resize (2);
 
                 dims(0) = NINTbig (tmp.double_value ());
                 dims(1) = NINTbig (tmp.double_value ());
 
@@ -175,30 +175,30 @@ do_rand (const octave_value_list& args, 
 
                 dims.resize (n);
 
                 octave_idx_type base = NINTbig (r.base ());
                 octave_idx_type incr = NINTbig (r.inc ());
                 octave_idx_type lim = NINTbig (r.limit ());
 
                 if (base < 0 || lim < 0)
-                  error ("%s: all dimensions must be nonnegative", fcn);
+                  error ("%s: all dimensions must be positive", fcn);
                 else
                   {
                     for (octave_idx_type i = 0; i < n; i++)
                       {
                         dims(i) = base;
                         base += incr;
                       }
 
                     goto gen_matrix;
                   }
               }
             else
-              error ("%s: expecting all elements of range to be integers",
+              error ("%s: all elements of range must be integers",
                      fcn);
           }
         else if (tmp.is_matrix_type ())
           {
             Array<int> iv = tmp.int_vector_value (true);
 
             if (! error_state)
               {
@@ -207,17 +207,17 @@ do_rand (const octave_value_list& args, 
                 dims.resize (len);
 
                 for (octave_idx_type i = 0; i < len; i++)
                   {
                     octave_idx_type elt = iv(i);
 
                     if (elt < 0)
                       {
-                        error ("%s: all dimensions must be nonnegative", fcn);
+                        error ("%s: all dimensions must be positive", fcn);
                         goto done;
                       }
 
                     dims(i) = iv(i);
                   }
 
                 goto gen_matrix;
               }
@@ -323,19 +323,21 @@ do_rand (const octave_value_list& args, 
   else
     return octave_rand::nd_array (dims);
 }
 
 DEFUN_DLD (rand, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} rand (@var{x})\n\
 @deftypefnx {Loadable Function} {} rand (@var{n}, @var{m})\n\
-@deftypefnx {Loadable Function} {} rand (\"state\", @var{x})\n\
+@deftypefnx {Loadable Function} {@var{v} =} rand (\"state\")\n\
+@deftypefnx {Loadable Function} {} rand (\"state\", @var{v})\n\
 @deftypefnx {Loadable Function} {} rand (\"state\", \"reset\")\n\
-@deftypefnx {Loadable Function} {} rand (\"seed\", @var{x})\n\
+@deftypefnx {Loadable Function} {@var{v} =} rand (\"seed\")\n\
+@deftypefnx {Loadable Function} {} rand (\"seed\", @var{v})\n\
 @deftypefnx {Loadable Function} {} rand (\"seed\", \"reset\")\n\
 Return a matrix with random elements uniformly distributed on the\n\
 interval (0, 1).  The arguments are handled the same as the arguments\n\
 for @code{eye}.\n\
 \n\
 You can query the state of the random number generator using the\n\
 form\n\
 \n\
@@ -485,19 +487,21 @@ using the \"reset\" keyword.\n\
 
 
 static std::string current_distribution = octave_rand::distribution ();
 
 DEFUN_DLD (randn, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} randn (@var{x})\n\
 @deftypefnx {Loadable Function} {} randn (@var{n}, @var{m})\n\
-@deftypefnx {Loadable Function} {} randn (\"state\", @var{x})\n\
+@deftypefnx {Loadable Function} {@var{v} =} randn (\"state\")\n\
+@deftypefnx {Loadable Function} {} randn (\"state\", @var{v})\n\
 @deftypefnx {Loadable Function} {} randn (\"state\", \"reset\")\n\
-@deftypefnx {Loadable Function} {} randn (\"seed\", @var{x})\n\
+@deftypefnx {Loadable Function} {@var{v} =} randn (\"seed\")\n\
+@deftypefnx {Loadable Function} {} randn (\"seed\", @var{v})\n\
 @deftypefnx {Loadable Function} {} randn (\"seed\", \"reset\")\n\
 Return a matrix with normally distributed random\n\
 elements having zero mean and variance one.  The arguments are\n\
 handled the same as the arguments for @code{rand}.\n\
 \n\
 By default, @code{randn} uses the Marsaglia and Tsang ``Ziggurat technique''\n\
 to transform from a uniform to a normal distribution.\n\
 \n\
@@ -548,25 +552,27 @@ J. Statistical Software, vol 5, 2000,\n\
 %!   assert(kurtosis(x),0,0.04);
 %! endif
 */
 
 DEFUN_DLD (rande, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} rande (@var{x})\n\
 @deftypefnx {Loadable Function} {} rande (@var{n}, @var{m})\n\
-@deftypefnx {Loadable Function} {} rande (\"state\", @var{x})\n\
+@deftypefnx {Loadable Function} {@var{v} =} rande (\"state\")\n\
+@deftypefnx {Loadable Function} {} rande (\"state\", @var{v})\n\
 @deftypefnx {Loadable Function} {} rande (\"state\", \"reset\")\n\
-@deftypefnx {Loadable Function} {} rande (\"seed\", @var{x})\n\
+@deftypefnx {Loadable Function} {@var{v} =} rande (\"seed\")\n\
+@deftypefnx {Loadable Function} {} rande (\"seed\", @var{v})\n\
 @deftypefnx {Loadable Function} {} rande (\"seed\", \"reset\")\n\
 Return a matrix with exponentially distributed random elements.  The\n\
 arguments are handled the same as the arguments for @code{rand}.\n\
 \n\
 By default, @code{randn} uses the Marsaglia and Tsang ``Ziggurat technique''\n\
-to transform from a uniform to a exponential distribution.\n\
+to transform from a uniform to an exponential distribution.\n\
 \n\
 Reference: G. Marsaglia and W.W. Tsang,\n\
 @cite{Ziggurat Method for Generating Random Variables},\n\
 J. Statistical Software, vol 5, 2000,\n\
 @url{http://www.jstatsoft.org/v05/i08/})\n\
 \n\
 @seealso{rand, randn, randg, randp}\n\
 @end deftypefn")
@@ -612,19 +618,21 @@ J. Statistical Software, vol 5, 2000,\n\
 %!   assert(kurtosis(x),6,0.7);
 %! endif
 */
 
 DEFUN_DLD (randg, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} randg (@var{a}, @var{x})\n\
 @deftypefnx {Loadable Function} {} randg (@var{a}, @var{n}, @var{m})\n\
-@deftypefnx {Loadable Function} {} randg (\"state\", @var{x})\n\
+@deftypefnx {Loadable Function} {@var{v} =} randg (\"state\")\n\
+@deftypefnx {Loadable Function} {} randg (\"state\", @var{v})\n\
 @deftypefnx {Loadable Function} {} randg (\"state\", \"reset\")\n\
-@deftypefnx {Loadable Function} {} randg (\"seed\", @var{x})\n\
+@deftypefnx {Loadable Function} {@var{v} =} randg (\"seed\")\n\
+@deftypefnx {Loadable Function} {} randg (\"seed\", @var{v})\n\
 @deftypefnx {Loadable Function} {} randg (\"seed\", \"reset\")\n\
 Return a matrix with @code{gamma(@var{a},1)} distributed random elements.\n\
 The arguments are handled the same as the arguments for @code{rand},\n\
 except for the argument @var{a}.\n\
 \n\
 This can be used to generate many distributions:\n\
 \n\
 @table @asis\n\
@@ -866,19 +874,21 @@ r = r / sum (r)\n\
 %! endif
 */
 
 
 DEFUN_DLD (randp, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} randp (@var{l}, @var{x})\n\
 @deftypefnx {Loadable Function} {} randp (@var{l}, @var{n}, @var{m})\n\
-@deftypefnx {Loadable Function} {} randp (\"state\", @var{x})\n\
+@deftypefnx {Loadable Function} {@var{v} =} randp (\"state\")\n\
+@deftypefnx {Loadable Function} {} randp (\"state\", @var{v})\n\
 @deftypefnx {Loadable Function} {} randp (\"state\", \"reset\")\n\
-@deftypefnx {Loadable Function} {} randp (\"seed\", @var{x})\n\
+@deftypefnx {Loadable Function} {@var{v} =} randp (\"seed\")\n\
+@deftypefnx {Loadable Function} {} randp (\"seed\", @var{v})\n\
 @deftypefnx {Loadable Function} {} randp (\"seed\", \"reset\")\n\
 Return a matrix with Poisson distributed random elements with mean value\n\
 parameter given by the first argument, @var{l}.  The arguments\n\
 are handled the same as the arguments for @code{rand}, except for the\n\
 argument @var{l}.\n\
 \n\
 Five different algorithms are used depending on the range of @var{l}\n\
 and whether or not @var{l} is a scalar or a matrix.\n\
@@ -1007,17 +1017,17 @@ D 50 p1284, 1994.\n\
 */
 
 DEFUN_DLD (randperm, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} randperm (@var{n})\n\
 @deftypefnx {Loadable Function} {} randperm (@var{n}, @var{m})\n\
 Return a row vector containing a random permutation of @code{1:@var{n}}.\n\
 If @var{m} is supplied, return @var{m} permutations,\n\
-one in each row of a @nospell{NxM} matrix.  The complexity is O(M*N) in both\n\
+one in each row of an @nospell{NxM} matrix.  The complexity is O(M*N) in both\n\
 time and memory.  The randomization is performed using rand().\n\
 All permutations are equally likely.\n\
 @seealso{perms}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
@@ -1028,17 +1038,17 @@ All permutations are equally likely.\n\
       if (nargin == 2)
         m = args(1).idx_type_value (true);
       else
         m = 1;
 
       n = args(0).idx_type_value (true);
 
       if (m < 0 || n < 0)
-        error ("randperm: m and n must be non-negative");
+        error ("randperm: M and N must be non-negative");
 
       if (! error_state)
         {
           // Generate random numbers.
           NDArray r = octave_rand::nd_array (dim_vector (m, n));
 
           // Create transposed to allow faster access.
           Array<octave_idx_type> idx (dim_vector (n, m));
diff --git a/src/DLD-FUNCTIONS/rcond.cc b/src/DLD-FUNCTIONS/rcond.cc
--- a/src/DLD-FUNCTIONS/rcond.cc
+++ b/src/DLD-FUNCTIONS/rcond.cc
@@ -27,25 +27,25 @@ along with Octave; see the file COPYING.
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN_DLD (rcond, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{c} =} rcond (@var{a})\n\
-Compute the 1-norm estimate of the reciprocal condition as returned\n\
+@deftypefn {Loadable Function} {@var{c} =} rcond (@var{A})\n\
+Compute the 1-norm estimate of the reciprocal condition number as returned\n\
 by @sc{lapack}.  If the matrix is well-conditioned then @var{c} will be near\n\
 1 and if the matrix is poorly conditioned it will be close to zero.\n\
 \n\
-The matrix @var{a} must not be sparse.  If the matrix is sparse then\n\
-@code{condest (@var{a})} or @code{rcond (full (@var{a}))} should be used\n\
+The matrix @var{A} must not be sparse.  If the matrix is sparse then\n\
+@code{condest (@var{A})} or @code{rcond (full (@var{A}))} should be used\n\
 instead.\n\
-@seealso{inv}\n\
+@seealso{cond,condest}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     print_usage ();
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -221,17 +221,17 @@ octregexp_list (const octave_value_list 
               // named token name on both sides of the alternative. Also fix
               // that here by replacing name tokens by dummy names, and dealing
               // with the dummy names later.
 
               size_t tmp_pos = pattern.find_first_of ('>',new_pos);
 
               if (tmp_pos == std::string::npos)
                 {
-                  error ("syntax error in pattern");
+                  error ("regexp: syntax error in pattern");
                   break;
                 }
 
               std::string tmp_name = 
                 pattern.substr(new_pos+3,tmp_pos-new_pos-3);
               bool found = false;
 
               for (int i = 0; i < nnames; i++)
diff --git a/src/DLD-FUNCTIONS/schur.cc b/src/DLD-FUNCTIONS/schur.cc
--- a/src/DLD-FUNCTIONS/schur.cc
+++ b/src/DLD-FUNCTIONS/schur.cc
@@ -54,180 +54,180 @@ mark_upper_triangular (const Matrix& a)
 
   retval.matrix_type (MatrixType::Upper);
 
   return retval;
 }
 
 DEFUN_DLD (schur, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{s} =} schur (@var{a})\n\
-@deftypefnx {Loadable Function} {@var{s} =} schur (@var{a}, \"complex\")\n\
-@deftypefnx {Loadable Function} {[@var{u}, @var{s}] =} schur (@var{a}, @var{opt})\n\
+@deftypefn  {Loadable Function} {@var{S} =} schur (@var{A})\n\
+@deftypefnx {Loadable Function} {@var{S} =} schur (@var{A}, \"complex\")\n\
+@deftypefnx {Loadable Function} {[@var{U}, @var{S}] =} schur (@var{A}, @var{opt})\n\
 @cindex Schur decomposition\n\
-The Schur decomposition is used to compute eigenvalues of a\n\
+The Schur@tie{}decomposition is used to compute eigenvalues of a\n\
 square matrix, and has applications in the solution of algebraic\n\
 Riccati equations in control (see @code{are} and @code{dare}).\n\
 @code{schur} always returns\n\
 @tex\n\
 $S = U^T A U$\n\
 @end tex\n\
 @ifnottex\n\
-@code{s = u' * a * u}\n\
+@code{@var{S} = @var{U}' * @var{A} * @var{U}}\n\
 @end ifnottex\n\
 where\n\
 @tex\n\
 $U$\n\
 @end tex\n\
 @ifnottex\n\
-@code{u}\n\
+@var{U}\n\
 @end ifnottex\n\
  is a unitary matrix\n\
 @tex\n\
 ($U^T U$ is identity)\n\
 @end tex\n\
 @ifnottex\n\
-(@code{u'* u} is identity)\n\
+(@code{@var{U}'* @var{U}} is identity)\n\
 @end ifnottex\n\
 and\n\
 @tex\n\
 $S$\n\
 @end tex\n\
 @ifnottex\n\
-@code{s}\n\
+@var{S}\n\
 @end ifnottex\n\
 is upper triangular.  The eigenvalues of\n\
 @tex\n\
 $A$ (and $S$)\n\
 @end tex\n\
 @ifnottex\n\
-@code{a} (and @code{s})\n\
+@var{A} (and @var{S})\n\
 @end ifnottex\n\
 are the diagonal elements of\n\
 @tex\n\
 $S$.\n\
 @end tex\n\
 @ifnottex\n\
-@code{s}.\n\
+@var{S}.\n\
 @end ifnottex\n\
 If the matrix\n\
 @tex\n\
 $A$\n\
 @end tex\n\
 @ifnottex\n\
-@code{a}\n\
+@var{A}\n\
 @end ifnottex\n\
-is real, then the real Schur decomposition is computed, in which the\n\
+is real, then the real Schur@tie{}decomposition is computed, in which the\n\
 matrix\n\
 @tex\n\
 $U$\n\
 @end tex\n\
 @ifnottex\n\
-@code{u}\n\
+@var{U}\n\
 @end ifnottex\n\
 is orthogonal and\n\
 @tex\n\
 $S$\n\
 @end tex\n\
 @ifnottex\n\
-@code{s}\n\
+@var{S}\n\
 @end ifnottex\n\
 is block upper triangular\n\
 with blocks of size at most\n\
 @tex\n\
 $2\\times 2$\n\
 @end tex\n\
 @ifnottex\n\
 @code{2 x 2}\n\
 @end ifnottex\n\
 along the diagonal.  The diagonal elements of\n\
 @tex\n\
 $S$\n\
 @end tex\n\
 @ifnottex\n\
-@code{s}\n\
+@var{S}\n\
 @end ifnottex\n\
 (or the eigenvalues of the\n\
 @tex\n\
 $2\\times 2$\n\
 @end tex\n\
 @ifnottex\n\
 @code{2 x 2}\n\
 @end ifnottex\n\
 blocks, when\n\
 appropriate) are the eigenvalues of\n\
 @tex\n\
 $A$\n\
 @end tex\n\
 @ifnottex\n\
-@code{a}\n\
+@var{A}\n\
 @end ifnottex\n\
 and\n\
 @tex\n\
 $S$.\n\
 @end tex\n\
 @ifnottex\n\
-@code{s}.\n\
+@var{S}.\n\
 @end ifnottex\n\
 \n\
 A complex decomposition may be forced by passing \"complex\" as @var{opt}.\n\
 \n\
 The eigenvalues are optionally ordered along the diagonal according to\n\
-the value of @code{opt}.  @code{opt = \"a\"} indicates that all\n\
+the value of @var{opt}.  @code{@var{opt} = \"a\"} indicates that all\n\
 eigenvalues with negative real parts should be moved to the leading\n\
 block of\n\
 @tex\n\
 $S$\n\
 @end tex\n\
 @ifnottex\n\
-@code{s}\n\
+@var{S}\n\
 @end ifnottex\n\
-(used in @code{are}), @code{opt = \"d\"} indicates that all eigenvalues\n\
+(used in @code{are}), @code{@var{opt} = \"d\"} indicates that all eigenvalues\n\
 with magnitude less than one should be moved to the leading block of\n\
 @tex\n\
 $S$\n\
 @end tex\n\
 @ifnottex\n\
-@code{s}\n\
+@var{S}\n\
 @end ifnottex\n\
-(used in @code{dare}), and @code{opt = \"u\"}, the default, indicates that\n\
-no ordering of eigenvalues should occur.  The leading\n\
+(used in @code{dare}), and @code{@var{opt} = \"u\"}, the default, indicates\n\
+that no ordering of eigenvalues should occur.  The leading\n\
 @tex\n\
 $k$\n\
 @end tex\n\
 @ifnottex\n\
-@code{k}\n\
+@var{k}\n\
 @end ifnottex\n\
 columns of\n\
 @tex\n\
 $U$\n\
 @end tex\n\
 @ifnottex\n\
-@code{u}\n\
+@var{U}\n\
 @end ifnottex\n\
 always span the\n\
 @tex\n\
 $A$-invariant\n\
 @end tex\n\
 @ifnottex\n\
-@code{a}-invariant\n\
+@var{A}-invariant\n\
 @end ifnottex\n\
 subspace corresponding to the\n\
 @tex\n\
 $k$\n\
 @end tex\n\
 @ifnottex\n\
-@code{k}\n\
+@var{k}\n\
 @end ifnottex\n\
 leading eigenvalues of\n\
 @tex\n\
 $S$.\n\
 @end tex\n\
 @ifnottex\n\
-@code{s}.\n\
+@var{S}.\n\
 @end ifnottex\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2 || nargout > 2)
@@ -241,17 +241,17 @@ leading eigenvalues of\n\
   std::string ord;
 
   if (nargin == 2)
     {
       ord = args(1).string_value (); 
 
       if (error_state)
         {
-          error ("schur: expecting string as second argument");
+          error ("schur: second argument must be a string");
           return retval;
         }
     }
 
   bool force_complex = false;
 
   if (ord == "complex")
     {
@@ -388,38 +388,38 @@ leading eigenvalues of\n\
 %!error <Invalid call to schur.*> schur ();
 %!error schur ([1, 2, 3; 4, 5, 6]);
 
 */
 
 DEFUN_DLD (rsf2csf, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Function File} {[@var{U}, @var{T}] =} rsf2csf (@var{UR}, @var{TR})\n\
-Convert a real, upper quasi-triangular Schur form @var{TR} to a complex,\n\
-upper triangular Schur form @var{T}.\n\
+Convert a real, upper quasi-triangular Schur@tie{}form @var{TR} to a complex,\n\
+upper triangular Schur@tie{}form @var{T}.\n\
 \n\
 Note that the following relations hold: \n\
 \n\
 @code{@var{UR} * @var{TR} * @var{UR}' = @var{U} * @var{T} * @var{U}'} and\n\
-@code{@var{U}' * @var{U}} is the identity matrix.\n\
+@code{@var{U}' * @var{U}} is the identity matrix I.\n\
 \n\
-Note also that U and T are not unique.\n\
-\n\
+Note also that @var{U} and @var{T} are not unique.\n\
+@seealso{schur}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 2 && nargout <= 2)
     {
       if (! args(0).is_numeric_type ())
         gripe_wrong_type_arg ("rsf2csf", args(0));
       else if (! args(1).is_numeric_type ())
         gripe_wrong_type_arg ("rsf2csf", args(1));
       else if (args(0).is_complex_type () || args(1).is_complex_type ())
-        error ("rsf2csf: both matrices must be real");
+        error ("rsf2csf: UR and TR must be real matrices");
       else
         {
 
           if (args(0).is_single_type () || args(1).is_single_type ())
             {
               FloatMatrix u = args(0).float_matrix_value ();
               FloatMatrix t = args(1).float_matrix_value ();
               if (! error_state)
diff --git a/src/DLD-FUNCTIONS/spparms.cc b/src/DLD-FUNCTIONS/spparms.cc
--- a/src/DLD-FUNCTIONS/spparms.cc
+++ b/src/DLD-FUNCTIONS/spparms.cc
@@ -38,23 +38,23 @@ DEFUN_DLD (spparms, args, nargout,
 @deftypefn  {Loadable Function} { } spparms ()\n\
 @deftypefnx {Loadable Function} {@var{vals} =} spparms ()\n\
 @deftypefnx {Loadable Function} {[@var{keys}, @var{vals}] =} spparms ()\n\
 @deftypefnx {Loadable Function} {@var{val} =} spparms (@var{key})\n\
 @deftypefnx {Loadable Function} { } spparms (@var{vals})\n\
 @deftypefnx {Loadable Function} { } spparms ('defaults')\n\
 @deftypefnx {Loadable Function} { } spparms ('tight')\n\
 @deftypefnx {Loadable Function} { } spparms (@var{key}, @var{val})\n\
-Sets or displays the parameters used by the sparse solvers and factorization\n\
+Query or set the parameters used by the sparse solvers and factorization\n\
 functions.  The first four calls above get information about the current\n\
 settings, while the others change the current settings.  The parameters are\n\
 stored as pairs of keys and values, where the values are all floats and the\n\
 keys are one of the following strings:\n\
 \n\
-@table @code\n\
+@table @samp\n\
 @item spumoni\n\
 Printing level of debugging information of the solvers (default 0)\n\
 \n\
 @item ths_rel\n\
 Included for compatibility.  Not used.  (default 1)\n\
 \n\
 @item ths_abs\n\
 Included for compatibility.  Not used.  (default 1)\n\
@@ -89,20 +89,21 @@ The pivot tolerance of the @sc{umfpack} 
 The density of non-zero elements in a banded matrix before it is treated\n\
 by the @sc{lapack} banded solvers (default 0.5)\n\
 \n\
 @item umfpack\n\
 Flag whether the @sc{umfpack} or mmd solvers are used for the LU, '\\' and\n\
 '/' operations (default 1)\n\
 @end table\n\
 \n\
-The value of individual keys can be set with @code{spparms (@var{key},\n\
-@var{val})}.  The default values can be restored with the special keyword\n\
+The value of individual keys can be set with\n\
+@code{spparms (@var{key}, @var{val})}.\n\
+The default values can be restored with the special keyword\n\
 'defaults'.  The special keyword 'tight' can be used to set the mmd solvers\n\
-to attempt for a sparser solution at the potential cost of longer running\n\
+to attempt a sparser solution at the potential cost of longer running\n\
 time.\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
 
   if (nargin == 0)
     {
@@ -130,29 +131,29 @@ time.\n\
           if (str == "defaults")
             octave_sparse_params::defaults ();
           else if (str == "tight")
             octave_sparse_params::tight ();
           else
             {
               double val = octave_sparse_params::get_key (str);
               if (xisnan (val))
-                error ("spparams: unrecognized key");
+                error ("spparams: KEY not recognized");
               else
                 retval (0) = val;
             }
         }
       else
         {
           NDArray vals = args(0).array_value ();
 
           if (error_state)
             error ("spparms: input must be a string or a vector");
           else if (vals.numel () > OCTAVE_SPARSE_CONTROLS_SIZE)
-            error ("spparams: too many elements in values vector");
+            error ("spparams: too many elements in vector VALS");
           else
             octave_sparse_params::set_vals (vals);
         }
     }
   else if (nargin == 2)
     {
       if (args(0).is_string ())
         {
@@ -160,17 +161,17 @@ time.\n\
           
           double val = args(1).double_value ();
 
           if (error_state)
             error ("spparms: second argument must be a real scalar");
           else if (str == "umfpack")
             warning ("spparms: request to disable umfpack solvers ignored");
           else if (!octave_sparse_params::set_key (str, val))
-            error ("spparms: key not found");
+            error ("spparms: KEY not found");
         }
       else
         error ("spparms: first argument must be a string");
     }
   else
     error ("spparms: too many input arguments");
 
   return retval;
diff --git a/src/DLD-FUNCTIONS/sqrtm.cc b/src/DLD-FUNCTIONS/sqrtm.cc
--- a/src/DLD-FUNCTIONS/sqrtm.cc
+++ b/src/DLD-FUNCTIONS/sqrtm.cc
@@ -209,18 +209,18 @@ do_sqrtm (const octave_value& arg)
         }
     }
 
   return retval;
 }
 
 DEFUN_DLD (sqrtm, args, nargout,
  "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{result}, @var{error_estimate}] =} sqrtm (@var{a})\n\
-Compute the matrix square root of the square matrix @var{a}.\n\
+@deftypefn {Loadable Function} {[@var{result}, @var{error_estimate}] =} sqrtm (@var{A})\n\
+Compute the matrix square root of the square matrix @var{A}.\n\
 \n\
 Ref: N.J. Higham.  @cite{A New sqrtm for @sc{matlab}}.  Numerical\n\
 Analysis Report No. 336, Manchester @nospell{Centre} for Computational\n\
 Mathematics, Manchester, England, January 1999.\n\
 @seealso{expm, logm}\n\
 @end deftypefn")
 {
   octave_value_list retval;
diff --git a/src/DLD-FUNCTIONS/str2double.cc b/src/DLD-FUNCTIONS/str2double.cc
--- a/src/DLD-FUNCTIONS/str2double.cc
+++ b/src/DLD-FUNCTIONS/str2double.cc
@@ -239,17 +239,17 @@ brackets indicate optional arguments and
 digits.  The special input values @code{Inf}, @code{NaN}, and @code{NA} are\n\
 also accepted.\n\
 \n\
 @var{s} may also be a character matrix, in which case the conversion is\n\
 repeated for each row.  Or @var{s} may be a cell array of strings, in which\n\
 case each element is converted and an array of the same dimensions is\n\
 returned.\n\
 \n\
-@code{str2double} can replace @code{str2num}, but avoids the use of\n\
+@code{str2double} can replace @code{str2num}, and it avoids the use of\n\
 @code{eval} on unknown data.\n\
 @seealso{str2num}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
diff --git a/src/DLD-FUNCTIONS/strfind.cc b/src/DLD-FUNCTIONS/strfind.cc
--- a/src/DLD-FUNCTIONS/strfind.cc
+++ b/src/DLD-FUNCTIONS/strfind.cc
@@ -149,18 +149,18 @@ DEFUN_DLD (strfind, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{idx} =} strfind (@var{str}, @var{pattern})\n\
 @deftypefnx {Loadable Function} {@var{idx} =} strfind (@var{cellstr}, @var{pattern})\n\
 Search for @var{pattern} in the string @var{str} and return the\n\
 starting index of every such occurrence in the vector @var{idx}.\n\
 If there is no such occurrence, or if @var{pattern} is longer\n\
 than @var{str}, then @var{idx} is the empty array @code{[]}.\n\
 \n\
-If the cell array of strings @var{cellstr} is specified instead of the\n\
-string @var{str}, then @var{idx} is a cell array of vectors, as specified\n\
+If a cell array of strings @var{cellstr} is specified\n\
+then @var{idx} is a cell array of vectors, as specified\n\
 above.  Examples:\n\
 \n\
 @example\n\
 @group\n\
 strfind (\"abababa\", \"aba\")\n\
      @result{} [1, 3, 5]\n\
 \n\
 strfind (@{\"abababa\", \"bebebe\", \"ab\"@}, \"aba\")\n\
@@ -170,17 +170,17 @@ strfind (@{\"abababa\", \"bebebe\", \"ab
 \n\
              1   3   5\n\
 \n\
           [1,2] = [](1x0)\n\
           [1,3] = [](1x0)\n\
         @}\n\
 @end group\n\
 @end example\n\
-@seealso{findstr, strmatch, strcmp, strncmp, strcmpi, strncmpi, find}\n\
+@seealso{findstr,strmatch,regexp,regexpi,find}\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
   bool overlaps = true;
 
   if (nargin == 4 && args(2).is_string () && args(3).is_scalar_type ())
     {
@@ -220,30 +220,30 @@ strfind (@{\"abababa\", \"bebebe\", \"ab
                 {
                   octave_value argse = argsc(i);
                   if (argse.is_string ())
                     retc(i) = octave_value (qs_search (needle, argse.char_array_value (), 
                                                        table, overlaps), 
                                             true, true);
                   else
                     {
-                      error ("strfind: each cell element must be a string");
+                      error ("strfind: each element of CELLSTR must be a string");
                       break;
                     }
                 }
 
               retval = retc;
             }
           else
             error ("strfind: first argument must be a string or cell array of strings");
         }
       else if (argpat.is_cell ())
         retval = do_simple_cellfun (Fstrfind, "strfind", args);
       else
-        error ("strfind: pattern must be a string or cell array of strings");
+        error ("strfind: PATTERN must be a string or cell array of strings");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -318,20 +318,20 @@ qs_replace (const Array<char>& str, cons
         }
     }
 
   return ret;
 }
 
 DEFUN_DLD (strrep, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {} strrep (@var{s}, @var{x}, @var{y})\n\
-@deftypefnx {Loadable Function} {} strrep (@var{s}, @var{x}, @var{y}, \"overlaps\", @var{o})\n\
-Replace all occurrences of the substring @var{x} of the string @var{s}\n\
-with the string @var{y} and return the result.  For example:\n\
+@deftypefn  {Loadable Function} {} strrep (@var{s}, @var{ptn}, @var{rep})\n\
+@deftypefnx {Loadable Function} {} strrep (@var{s}, @var{ptn}, @var{rep}, \"overlaps\", @var{o})\n\
+Replace all occurrences of the substring @var{ptn} in the string @var{s}\n\
+with the string @var{rep} and return the result.  For example:\n\
 \n\
 @example\n\
 @group\n\
 strrep (\"This is a test string\", \"is\", \"&%$\")\n\
      @result{} \"Th&%$ &%$ a test string\"\n\
 @end group\n\
 @end example\n\
 \n\
@@ -380,30 +380,30 @@ done for each element and a cell array i
 
               for (octave_idx_type i = 0; i < ns; i++)
                 {
                   octave_value argse = argsc(i);
                   if (argse.is_string ())
                     retc(i) = qs_replace (argse.char_array_value (), pat, rep, table, overlaps);
                   else
                     {
-                      error ("strrep: each cell element must be a string");
+                      error ("strrep: each element of S must be a string");
                       break;
                     }
                 }
 
               retval = retc;
             }
           else
             error ("strrep: first argument must be a string or cell array of strings");
         }
       else if (argpat.is_cell () || argrep.is_cell ())
         retval = do_simple_cellfun (Fstrrep, "strrep", args);
       else
-        error ("strrep: x and y arguments must be strings or cell arrays of strings");
+        error ("strrep: X and Y arguments must be strings or cell arrays of strings");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/src/DLD-FUNCTIONS/sub2ind.cc b/src/DLD-FUNCTIONS/sub2ind.cc
--- a/src/DLD-FUNCTIONS/sub2ind.cc
+++ b/src/DLD-FUNCTIONS/sub2ind.cc
@@ -60,17 +60,17 @@ get_dim_vector (const octave_value& val,
 
   return dv;
 }
 
 DEFUN_DLD (sub2ind, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Function File} {@var{ind} =} sub2ind (@var{dims}, @var{i}, @var{j})\n\
 @deftypefnx {Function File} {@var{ind} =} sub2ind (@var{dims}, @var{s1}, @var{s2}, @dots{}, @var{sN})\n\
-Convert subscripts into a linear index.\n\
+Convert subscripts to a linear index.\n\
 \n\
 The following example shows how to convert the two-dimensional\n\
 index @code{(2,3)} of a 3-by-3 matrix to a linear index.  The matrix\n\
 is linearly indexed moving from one column to next, filling up\n\
 all rows in each column.\n\
 \n\
 @example\n\
 @group\n\
@@ -168,27 +168,27 @@ linear_index = sub2ind ([3, 3], 2, 3)\n\
 %!error <sub2ind: all subscripts .* same size> sub2ind([10 10], ones(1,2), ones(1,3));
 %!error <sub2ind: all subscripts .* same size> sub2ind([10 10], ones(1,2), ones(2,1));
 
 */
 
 DEFUN_DLD (ind2sub, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Function File} {[@var{s1}, @var{s2}, @dots{}, @var{sN}] =} ind2sub (@var{dims}, @var{ind})\n\
-Convert a linear index into subscripts.\n\
+Convert a linear index to subscripts.\n\
 \n\
 The following example shows how to convert the linear index @code{8}\n\
 in a 3-by-3 matrix into a subscript.  The matrix is linearly indexed\n\
 moving from one column to next, filling up all rows in each column.\n\
 \n\
 @example\n\
 @group\n\
 [r, c] = ind2sub ([3, 3], 8)\n\
 @result{} r =  2\n\
-c =  3\n\
+   c =  3\n\
 @end group\n\
 @end example\n\
 @seealso{sub2ind}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value_list retval;
 
diff --git a/src/DLD-FUNCTIONS/svd.cc b/src/DLD-FUNCTIONS/svd.cc
--- a/src/DLD-FUNCTIONS/svd.cc
+++ b/src/DLD-FUNCTIONS/svd.cc
@@ -36,21 +36,21 @@ along with Octave; see the file COPYING.
 #include "pr-output.h"
 #include "utils.h"
 #include "variables.h"
 
 static int Vsvd_driver = SVD::GESVD;
 
 DEFUN_DLD (svd, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Loadable Function} {@var{s} =} svd (@var{a})\n\
-@deftypefnx {Loadable Function} {[@var{u}, @var{s}, @var{v}] =} svd (@var{a})\n\
-@deftypefnx {Loadable Function} {[@var{u}, @var{s}, @var{v}] =} svd (@var{a}, @var{econ})\n\
+@deftypefn  {Loadable Function} {@var{s} =} svd (@var{A})\n\
+@deftypefnx {Loadable Function} {[@var{U}, @var{S}, @var{V}] =} svd (@var{A})\n\
+@deftypefnx {Loadable Function} {[@var{U}, @var{S}, @var{V}] =} svd (@var{A}, @var{econ})\n\
 @cindex singular value decomposition\n\
-Compute the singular value decomposition of @var{a}\n\
+Compute the singular value decomposition of @var{A}\n\
 @tex\n\
 $$\n\
  A = U S V^H\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
@@ -60,17 +60,17 @@ A = U*S*V'\n\
 @end ifnottex\n\
 \n\
 The function @code{svd} normally returns only the vector of singular values.\n\
 When called with three return values, it computes\n\
 @tex\n\
 $U$, $S$, and $V$.\n\
 @end tex\n\
 @ifnottex\n\
-U, S, and V.\n\
+@var{U}, @var{S}, and @var{V}.\n\
 @end ifnottex\n\
 For example,\n\
 \n\
 @example\n\
 svd (hilb (3))\n\
 @end example\n\
 \n\
 @noindent\n\
@@ -114,18 +114,18 @@ v =\n\
 \n\
   -0.82704   0.54745   0.12766\n\
   -0.45986  -0.52829  -0.71375\n\
   -0.32330  -0.64901   0.68867\n\
 @end group\n\
 @end example\n\
 \n\
 If given a second argument, @code{svd} returns an economy-sized\n\
-decomposition, eliminating the unnecessary rows or columns of @var{u} or\n\
-@var{v}.\n\
+decomposition, eliminating the unnecessary rows or columns of @var{U} or\n\
+@var{V}.\n\
 @seealso{svd_driver, svds, eig}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2 || nargout == 2 || nargout > 3)
@@ -136,17 +136,17 @@ decomposition, eliminating the unnecessa
 
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   if (arg.ndims () != 2)
     {
-      error ("svd: only valid for matrices");
+      error ("svd: A must be a 2-D matrix");
       return retval;
     }
 
   bool isfloat = arg.is_single_type ();
 
   SVD::type type = ((nargout == 0 || nargout == 1)
                     ? SVD::sigma_only
                     : (nargin == 2) ? SVD::economy : SVD::std);
diff --git a/src/DLD-FUNCTIONS/syl.cc b/src/DLD-FUNCTIONS/syl.cc
--- a/src/DLD-FUNCTIONS/syl.cc
+++ b/src/DLD-FUNCTIONS/syl.cc
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN_DLD (syl, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {@var{x} =} syl (@var{a}, @var{b}, @var{c})\n\
+@deftypefn {Loadable Function} {@var{x} =} syl (@var{A}, @var{B}, @var{C})\n\
 Solve the Sylvester equation\n\
 @tex\n\
 $$\n\
  A X + X B + C = 0\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/symbfact.cc b/src/DLD-FUNCTIONS/symbfact.cc
--- a/src/DLD-FUNCTIONS/symbfact.cc
+++ b/src/DLD-FUNCTIONS/symbfact.cc
@@ -36,63 +36,65 @@ along with Octave; see the file COPYING.
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN_DLD (symbfact, args, nargout,
     "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {[@var{count}, @var{h}, @var{parent}, @var{post}, @var{r}] =} symbfact (@var{s}, @var{typ}, @var{mode})\n\
+@deftypefn  {Loadable Function} {[@var{count}, @var{h}, @var{parent}, @var{post}, @var{r}] =} symbfact (@var{S})\n\
+@deftypefnx {Loadable Function} {[@dots{}] =} symbfact (@var{S}, @var{typ})\n\
+@deftypefnx {Loadable Function} {[@dots{}] =} symbfact (@var{S}, @var{typ}, @var{mode})\n\
 \n\
-Performs a symbolic factorization analysis on the sparse matrix @var{s}.\n\
+Perform a symbolic factorization analysis on the sparse matrix @var{S}.\n\
 Where\n\
 \n\
-@table @asis\n\
-@item @var{s}\n\
-@var{s} is a complex or real sparse matrix.\n\
+@table @var\n\
+@item S\n\
+@var{S} is a complex or real sparse matrix.\n\
 \n\
-@item @var{typ}\n\
+@item typ\n\
 Is the type of the factorization and can be one of\n\
 \n\
-@table @code\n\
+@table @samp\n\
 @item sym\n\
-Factorize @var{s}.  This is the default.\n\
+Factorize @var{S}.  This is the default.\n\
 \n\
 @item col\n\
-Factorize @code{@var{s}' * @var{s}}.\n\
+Factorize @code{@var{S}' * @var{S}}.\n\
 \n\
 @item row\n\
-Factorize @code{@var{s} * @var{s}'}.\n\
+Factorize @code{@var{S} * @var{S}'}.\n\
 \n\
 @item lo\n\
-Factorize @code{@var{s}'}\n\
+Factorize @code{@var{S}'}\n\
 @end table\n\
 \n\
-@item @var{mode}\n\
-The default is to return the Cholesky factorization for @var{r}, and if\n\
-@var{mode} is 'L', the conjugate transpose of the Cholesky factorization\n\
+@item mode\n\
+The default is to return the Cholesky@tie{}factorization for @var{r}, and if\n\
+@var{mode} is 'L', the conjugate transpose of the Cholesky@tie{}factorization\n\
 is returned.  The conjugate transpose version is faster and uses less\n\
 memory, but returns the same values for @var{count}, @var{h}, @var{parent}\n\
 and @var{post} outputs.\n\
 @end table\n\
 \n\
 The output variables are\n\
 \n\
-@table @asis\n\
-@item @var{count}\n\
-The row counts of the Cholesky factorization as determined by @var{typ}.\n\
+@table @var\n\
+@item count\n\
+The row counts of the Cholesky@tie{}factorization as determined by @var{typ}.\n\
 \n\
-@item @var{h}\n\
+@item h\n\
 The height of the elimination tree.\n\
 \n\
-@item @var{parent}\n\
+@item parent\n\
 The elimination tree itself.\n\
 \n\
-@item @var{post}\n\
+@item post\n\
 A sparse boolean matrix whose structure is that of the Cholesky\n\
 factorization as determined by @var{typ}.\n\
 @end table\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
 
@@ -184,21 +186,21 @@ factorization as determined by @var{typ}
           coletree = true;
           A->stype = 0;
         }
       else if (ch == 's')
         A->stype = 1;
       else if (ch == 's')
         A->stype = -1;
       else
-        error ("Unrecognized typ in symbolic factorization");
+        error ("symbfact: unrecognized TYP in symbolic factorization");
     }
 
   if (A->stype && A->nrow != A->ncol)
-    error ("Matrix must be square");
+    error ("symbfact: S must be a square matrix");
 
   if (!error_state)
     {
       OCTAVE_LOCAL_BUFFER (octave_idx_type, Parent, n);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, Post, n);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, ColCount, n);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, First, n);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, Level, n);
diff --git a/src/DLD-FUNCTIONS/symrcm.cc b/src/DLD-FUNCTIONS/symrcm.cc
--- a/src/DLD-FUNCTIONS/symrcm.cc
+++ b/src/DLD-FUNCTIONS/symrcm.cc
@@ -413,21 +413,21 @@ transpose (octave_idx_type N, const octa
         ridx2[q] = j;
       }
 }
 
 // An implementation of the Cuthill-McKee algorithm.
 DEFUN_DLD (symrcm, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{p} =} symrcm (@var{S})\n\
-Symmetric reverse Cuthill-McKee permutation of @var{S}.\n\
-Return a permutation vector @var{p} such that\n\
-@code{@var{S} (@var{p}, @var{p})} tends to have its diagonal elements\n\
+Return the symmetric reverse Cuthill-McKee permutation of @var{S}.\n\
+@var{p} is a permutation vector such that\n\
+@code{@var{S}(@var{p}, @var{p})} tends to have its diagonal elements\n\
 closer to the diagonal than @var{S}.  This is a good preordering for LU\n\
-or Cholesky factorization of matrices that come from 'long, skinny'\n\
+or Cholesky@tie{}factorization of matrices that come from 'long, skinny'\n\
 problems.  It works for both symmetric and asymmetric @var{S}.\n\
 \n\
 The algorithm represents a heuristic approach to the NP-complete\n\
 bandwidth minimization problem.  The implementation is based in the\n\
 descriptions found in\n\
 \n\
 E. Cuthill, J. McKee. @cite{Reducing the Bandwidth of Sparse Symmetric\n\
 Matrices}. Proceedings of the 24th ACM National Conference, 157--172\n\
diff --git a/src/DLD-FUNCTIONS/time.cc b/src/DLD-FUNCTIONS/time.cc
--- a/src/DLD-FUNCTIONS/time.cc
+++ b/src/DLD-FUNCTIONS/time.cc
@@ -98,17 +98,17 @@ extract_tm (const octave_scalar_map& m)
   tm.isdst (intfield (m, "isdst"));
   tm.zone (stringfield (m, "zone"));
 
   return tm;
 }
 
 DEFUN_DLD (time, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} time ()\n\
+@deftypefn {Loadable Function} {@var{seconds} =} time ()\n\
 Return the current time as the number of seconds since the epoch.  The\n\
 epoch is referenced to 00:00:00 CUT (Coordinated Universal Time) 1 Jan\n\
 1970.  For example, on Monday February 17, 1997 at 07:15:06 CUT, the\n\
 value returned by @code{time} was 856163706.\n\
 @seealso{strftime, strptime, localtime, gmtime, mktime, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -124,35 +124,36 @@ value returned by @code{time} was 856163
 /*
 
 %!assert(time () > 0);
 
 */
 
 DEFUN_DLD (gmtime, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} gmtime (@var{t})\n\
-Given a value returned from time (or any non-negative integer),\n\
-return a time structure corresponding to CUT@.  For example:\n\
+@deftypefn {Loadable Function} {@var{tm_struct} =} gmtime (@var{t})\n\
+Given a value returned from @code{time}, or any non-negative integer,\n\
+return a time structure corresponding to CUT (Coordinated Universal Time).  \n\
+For example:\n\
 \n\
 @example\n\
 @group\n\
 gmtime (time ())\n\
      @result{} @{\n\
            usec = 0\n\
-           year = 97\n\
+           sec = 6\n\
+           min = 15\n\
+           hour = 7\n\
+           mday = 17\n\
            mon = 1\n\
-           mday = 17\n\
-           sec = 6\n\
+           year = 97\n\
+           wday = 1\n\
+           yday = 47\n\
+           isdst = 0\n\
            zone = CST\n\
-           min = 15\n\
-           wday = 1\n\
-           hour = 7\n\
-           isdst = 0\n\
-           yday = 47\n\
          @}\n\
 @end group\n\
 @end example\n\
 @seealso{strftime, strptime, localtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   octave_value retval;
 
@@ -188,35 +189,35 @@ gmtime (time ())\n\
 %!error <Invalid call to gmtime.*> gmtime ();
 
 %!error <Invalid call to gmtime.*> gmtime (1, 2);
 
 */
 
 DEFUN_DLD (localtime, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} localtime (@var{t})\n\
-Given a value returned from time (or any non-negative integer),\n\
+@deftypefn {Loadable Function} {@var{tm_struct} =} localtime (@var{t})\n\
+Given a value returned from @code{time}, or any non-negative integer,\n\
 return a time structure corresponding to the local time zone.\n\
 \n\
 @example\n\
 @group\n\
 localtime (time ())\n\
      @result{} @{\n\
            usec = 0\n\
-           year = 97\n\
+           sec = 6\n\
+           min = 15\n\
+           hour = 1\n\
+           mday = 17\n\
            mon = 1\n\
-           mday = 17\n\
-           sec = 6\n\
+           year = 97\n\
+           wday = 1\n\
+           yday = 47\n\
+           isdst = 0\n\
            zone = CST\n\
-           min = 15\n\
-           wday = 1\n\
-           hour = 1\n\
-           isdst = 0\n\
-           yday = 47\n\
          @}\n\
 @end group\n\
 @end example\n\
 @seealso{strftime, strptime, gmtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   octave_value retval;
 
@@ -252,17 +253,17 @@ localtime (time ())\n\
 %!error <Invalid call to localtime.*> localtime ();
 
 %!error <Invalid call to localtime.*> localtime (1, 2);
 
 */
 
 DEFUN_DLD (mktime, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} mktime (@var{tm_struct})\n\
+@deftypefn {Loadable Function} {@var{seconds} =} mktime (@var{tm_struct})\n\
 Convert a time structure corresponding to the local time to the number\n\
 of seconds since the epoch.  For example:\n\
 \n\
 @example\n\
 @group\n\
 mktime (localtime (time ()))\n\
      @result{} 856163706\n\
 @end group\n\
@@ -278,20 +279,20 @@ mktime (localtime (time ()))\n\
 
       if (! error_state)
         {
           octave_base_tm tm = extract_tm (map);
 
           if (! error_state)
             retval = octave_time (tm);
           else
-            error ("mktime: invalid TMSTRUCT argument");
+            error ("mktime: invalid TM_STRUCT argument");
         }
       else
-        error ("mktime: expecting structure argument");
+        error ("mktime: TM_STRUCT argument must be a structure");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -477,23 +478,23 @@ Year (1970-).\n\
 
           if (! error_state)
             {
               octave_base_tm tm = extract_tm (map);
 
               if (! error_state)
                 retval = tm.strftime (fmt);
               else
-                error ("strftime: invalid TMSTRUCT argument");
+                error ("strftime: invalid TM_STRUCT argument");
             }
           else
-            error ("strftime: expecting structure as second argument");
+            error ("strftime: TM_STRUCT must be a structure");
         }
       else
-        error ("strftime: expecting format string as first argument");
+        error ("strftime: FMT must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -511,17 +512,17 @@ Year (1970-).\n\
 */
 
 DEFUN_DLD (strptime, args, ,
  "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{tm_struct}, @var{nchars}] =} strptime (@var{str}, @var{fmt})\n\
 Convert the string @var{str} to the time structure @var{tm_struct} under\n\
 the control of the format string @var{fmt}.\n\
 \n\
-If @var{fmt} fails to match, @var{nchars} is 0; otherwise it is set to the\n\
+If @var{fmt} fails to match, @var{nchars} is 0; otherwise, it is set to the\n\
 position of last matched character plus 1. Always check for this unless\n\
 you're absolutely sure the date string will be parsed correctly.\n\
 @seealso{strftime, localtime, gmtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 2)
@@ -535,18 +536,18 @@ you're absolutely sure the date string w
           if (! error_state)
             {
               octave_strptime t (str, fmt);
 
               retval(1) = t.characters_converted ();
               retval(0) = octave_value (mk_tm_map (t));
             }
           else
-            error ("strptime: expecting format string as second argument");
+            error ("strptime: FMT must be a string");
         }
       else
-        error ("strptime: expecting string as first argument");
+        error ("strptime: argument STR must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
diff --git a/src/DLD-FUNCTIONS/tril.cc b/src/DLD-FUNCTIONS/tril.cc
--- a/src/DLD-FUNCTIONS/tril.cc
+++ b/src/DLD-FUNCTIONS/tril.cc
@@ -209,17 +209,17 @@ do_trilu (const std::string& name,
   if (nargin < 1 || nargin > 2)
     print_usage ();
   else
     {
       octave_value arg = args (0);
 
       dim_vector dims = arg.dims ();
       if (dims.length () != 2)
-        error ("%s: needs a 2D matrix", name.c_str ());
+        error ("%s: need a 2-D matrix", name.c_str ());
       else if (k < -dims (0) || k > dims(1))
         error ("%s: requested diagonal out of range", name.c_str ());
       else
         {
           switch (arg.builtin_type ())
             {
             case btyp_double:
               if (arg.is_sparse_type ())
@@ -336,38 +336,37 @@ do_trilu (const std::string& name,
         }
     }
 
   return retval;
 }
 
 DEFUN_DLD (tril, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Function File} {} tril (@var{a})\n\
-@deftypefnx {Function File} {} tril (@var{a}, @var{k})\n\
-@deftypefnx {Function File} {} tril (@var{a}, @var{k}, @var{pack})\n\
-@deftypefnx {Function File} {} triu (@var{a})\n\
-@deftypefnx {Function File} {} triu (@var{a}, @var{k})\n\
-@deftypefnx {Function File} {} triu (@var{a}, @var{k}, @var{pack})\n\
+@deftypefn  {Function File} {} tril (@var{A})\n\
+@deftypefnx {Function File} {} tril (@var{A}, @var{k})\n\
+@deftypefnx {Function File} {} tril (@var{A}, @var{k}, @var{pack})\n\
+@deftypefnx {Function File} {} triu (@var{A})\n\
+@deftypefnx {Function File} {} triu (@var{A}, @var{k})\n\
+@deftypefnx {Function File} {} triu (@var{A}, @var{k}, @var{pack})\n\
 Return a new matrix formed by extracting the lower (@code{tril})\n\
-or upper (@code{triu}) triangular part of the matrix @var{a}, and\n\
+or upper (@code{triu}) triangular part of the matrix @var{A}, and\n\
 setting all other elements to zero.  The second argument is optional,\n\
 and specifies how many diagonals above or below the main diagonal should\n\
 also be set to zero.\n\
 \n\
 The default value of @var{k} is zero, so that @code{triu} and\n\
-@code{tril} normally include the main diagonal as part of the result\n\
-matrix.\n\
+@code{tril} normally include the main diagonal as part of the result.\n\
 \n\
 If the value of @var{k} is negative, additional elements above (for\n\
 @code{tril}) or below (for @code{triu}) the main diagonal are also\n\
 selected.\n\
 \n\
 The absolute value of @var{k} must not be greater than the number of\n\
-sub- or super-diagonals.\n\
+sub-diagonals or super-diagonals.\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 tril (ones (3), -1)\n\
      @result{}  0  0  0\n\
          1  0  0\n\
@@ -393,18 +392,20 @@ other.\n\
 @seealso{triu, diag}\n\
 @end deftypefn")
 {
   return do_trilu ("tril", args);
 }
 
 DEFUN_DLD (triu, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Function File} {} triu (@var{a}, @var{k})\n\
-See tril.\n\
+@deftypefn  {Function File} {} triu (@var{A})\n\
+@deftypefnx {Function File} {} triu (@var{A}, @var{k})\n\
+@deftypefnx {Function File} {} triu (@var{A}, @var{k}, @var{pack})\n\
+@xref{tril}.\n\
 @end deftypefn")
 {
   return do_trilu ("triu", args);
 }
 
 /*
 
 %!test
diff --git a/src/DLD-FUNCTIONS/tsearch.cc b/src/DLD-FUNCTIONS/tsearch.cc
--- a/src/DLD-FUNCTIONS/tsearch.cc
+++ b/src/DLD-FUNCTIONS/tsearch.cc
@@ -62,17 +62,17 @@ inline double min (double a, double b, d
 // given point 
 
 // e.g., build up a neighbouring triangle structure and use a simplex-like
 // method to traverse it
 
 DEFUN_DLD (tsearch, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{idx} =} tsearch (@var{x}, @var{y}, @var{t}, @var{xi}, @var{yi})\n\
-Searches for the enclosing Delaunay convex hull.  For @code{@var{t} =\n\
+Search for the enclosing Delaunay convex hull.  For @code{@var{t} =\n\
 delaunay (@var{x}, @var{y})}, finds the index in @var{t} containing the\n\
 points @code{(@var{xi}, @var{yi})}.  For points outside the convex hull,\n\
 @var{idx} is NaN.\n\
 @seealso{delaunay, delaunayn}\n\
 @end deftypefn")
 {
   const double eps=1.0e-12;
 
diff --git a/src/DLD-FUNCTIONS/typecast.cc b/src/DLD-FUNCTIONS/typecast.cc
--- a/src/DLD-FUNCTIONS/typecast.cc
+++ b/src/DLD-FUNCTIONS/typecast.cc
@@ -84,17 +84,17 @@ reinterpret_copy (const void *data, octa
       return ArrayType ();
     }
 }
 
 
 DEFUN_DLD (typecast, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} typecast (@var{x}, @var{class})\n\
-Returns a new array @var{y} resulting from interpreting the data of\n\
+Return a new array @var{y} resulting from interpreting the data of\n\
 @var{x} in memory as data of the numeric class @var{class}.  Both the class\n\
 of @var{x} and @var{class} must be one of the built-in numeric classes:\n\
 \n\
 @example\n\
 @group\n\
   \"logical\"\n\
   \"char\"\n\
   \"int8\"\n\
@@ -269,18 +269,18 @@ do_bitpack (const boolNDArray& bitp)
       error ("bitpack: incorrect number of bits to make up output value");
       return ArrayType ();
     }
 }
 
 DEFUN_DLD (bitpack, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{y} =} bitpack (@var{x}, @var{class})\n\
-Returns a new array @var{y} resulting from interpreting a logical array\n\
-@var{x} as raw bit pattern for data of the numeric class @var{class}.  \n\
+Return a new array @var{y} resulting from interpreting an array\n\
+@var{x} as raw bit patterns for data of the numeric class @var{class}.\n\
 @var{class} must be one of the built-in numeric classes:\n\
 \n\
 @example\n\
 @group\n\
   \"char\"\n\
   \"int8\"\n\
   \"int16\"\n\
   \"int32\"\n\
@@ -291,20 +291,20 @@ Returns a new array @var{y} resulting fr
   \"uint64\"\n\
   \"double\"\n\
   \"single\"\n\
 @end group\n\
 @end example\n\
 \n\
 The number of elements of @var{x} should be divisible by the bit length of\n\
 @var{class}.  If it is not, excess bits are discarded.  Bits come in\n\
-increasing order of significance, i.e. @code{x(1)} is bit 0, @code{x(2)} is\n\
+increasing order of significance, i.e., @code{x(1)} is bit 0, @code{x(2)} is\n\
 bit 1, etc.  The result is a row vector if @var{x} is a row vector, otherwise\n\
 it is a column vector.\n\
-@seealso{bitunpack,typecast,bitget,bitset}\n\
+@seealso{bitunpack,typecast}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 2 && args(0).is_bool_type ())
     {
       boolNDArray bitp = args(0).bool_array_value ();
 
@@ -378,17 +378,17 @@ do_bitunpack (const ArrayType& array)
     }
 
   return retval;
 }
 
 DEFUN_DLD (bitunpack, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{y} =} bitpack (@var{x})\n\
-Returns a logical array @var{y} corresponding to the raw bit pattern of\n\
+Return an array @var{y} corresponding to the raw bit patterns of\n\
 @var{x}.  @var{x} must belong to one of the built-in numeric classes:\n\
 \n\
 @example\n\
 @group\n\
   \"char\"\n\
   \"int8\"\n\
   \"int16\"\n\
   \"int32\"\n\
@@ -397,19 +397,19 @@ Returns a logical array @var{y} correspo
   \"uint16\"\n\
   \"uint32\"\n\
   \"uint64\"\n\
   \"double\"\n\
   \"single\"\n\
 @end group\n\
 @end example\n\
 \n\
-The result is a row vector if @var{x} is a row vector, otherwise it is a\n\
+The result is a row vector if @var{x} is a row vector; otherwise, it is a\n\
 column vector.\n\
-@seealso{bitpack,typecast,bitget,bitset}\n\
+@seealso{bitpack,typecast}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1 && (args(0).is_numeric_type () || args(0).is_string ()))
     {
       octave_value array = args(0);
 
diff --git a/src/DLD-FUNCTIONS/urlwrite.cc b/src/DLD-FUNCTIONS/urlwrite.cc
--- a/src/DLD-FUNCTIONS/urlwrite.cc
+++ b/src/DLD-FUNCTIONS/urlwrite.cc
@@ -693,17 +693,17 @@ Download a remote file specified by its 
 urlwrite (\"ftp://ftp.octave.org/pub/octave/README\", \n\
           \"README.txt\");\n\
 @end group\n\
 @end example\n\
 \n\
 The full path of the downloaded file is returned in @var{f}.  The\n\
 variable @var{success} is 1 if the download was successful,\n\
 otherwise it is 0 in which case @var{message} contains an error\n\
-message.  If no output argument is specified and if an error occurs,\n\
+message.  If no output argument is specified and an error occurs,\n\
 then the error is signaled through Octave's error handling mechanism.\n\
 \n\
 This function uses libcurl.  Curl supports, among others, the HTTP,\n\
 FTP and FILE protocols.  Username and password may be specified in\n\
 the URL, for example:\n\
 \n\
 @example\n\
 @group\n\
@@ -738,60 +738,60 @@ urlwrite (\"http://www.google.com/search
       print_usage ();
       return retval;
     }
 
   std::string url = args(0).string_value();
 
   if (error_state)
     {
-      error ("urlwrite: url must be a character string");
+      error ("urlwrite: URL must be a character string");
       return retval;
     }
 
   // name to store the file if download is succesful
   std::string filename = args(1).string_value();
 
   if (error_state)
     {
-      error ("urlwrite: localfile must be a character string");
+      error ("urlwrite: LOCALFILE must be a character string");
       return retval;
     }
 
   std::string method;
   Cell param; // empty cell array
 
   if (nargin == 4)
     {
       method = args(2).string_value();
 
       if (error_state)
         {
-          error ("urlwrite: method can only be \"get\" or \"post\"");
+          error ("urlwrite: METHOD must be \"get\" or \"post\"");
           return retval;
         }
 
       if (method != "get" && method != "post")
         {
-          error ("urlwrite: method can only be \"get\" or \"post\"");
+          error ("urlwrite: METHOD must be \"get\" or \"post\"");
           return retval;
         }
 
       param = args(3).cell_value();
 
       if (error_state)
         {
-          error ("urlwrite: parameters for get and post requests must be given as a cell");
+          error ("urlwrite: parameters (PARAM) for get and post requests must be given as a cell");
           return retval;
         }
 
 
       if (param.numel () % 2 == 1 )
         {
-          error ("urlwrite: number of elements in param must be even");
+          error ("urlwrite: number of elements in PARAM must be even");
           return retval;
         }
     }
 
   // The file should only be deleted if it doesn't initially exist, we
   // create it, and the download fails.  We use unwind_protect to do
   // it so that the deletion happens no matter how we exit the function.
 
@@ -855,17 +855,17 @@ Download a remote file specified by its 
 in string @var{s}.  For example:\n\
 \n\
 @example\n\
 s = urlread (\"ftp://ftp.octave.org/pub/octave/README\");\n\
 @end example\n\
 \n\
 The variable @var{success} is 1 if the download was successful,\n\
 otherwise it is 0 in which case @var{message} contains an error\n\
-message.  If no output argument is specified and if an error occurs,\n\
+message.  If no output argument is specified and an error occurs,\n\
 then the error is signaled through Octave's error handling mechanism.\n\
 \n\
 This function uses libcurl.  Curl supports, among others, the HTTP,\n\
 FTP and FILE protocols.  Username and password may be specified in the\n\
 URL@.  For example:\n\
 \n\
 @example\n\
 s = urlread (\"http://user:password@@example.com/file.txt\");\n\
@@ -898,50 +898,50 @@ s = urlread (\"http://www.google.com/sea
       print_usage ();
       return retval;
     }
 
   std::string url = args(0).string_value();
 
   if (error_state)
     {
-      error ("urlread: url must be a character string");
+      error ("urlread: URL must be a character string");
       return retval;
     }
 
   std::string method;
   Cell param; // empty cell array
 
   if (nargin == 3)
     {
       method = args(1).string_value();
 
       if (error_state)
         {
-          error ("urlread: method can only be \"get\" or \"post\"");
+          error ("urlread: METHOD must be \"get\" or \"post\"");
           return retval;
         }
 
       if (method != "get" && method != "post")
         {
-          error ("urlread: method can only be \"get\" or \"post\"");
+          error ("urlread: METHOD must be \"get\" or \"post\"");
           return retval;
         }
 
       param = args(2).cell_value();
 
       if (error_state)
         {
-          error ("urlread: parameters for get and post requests must be given as a cell");
+          error ("urlread: parameters (PARAM) for get and post requests must be given as a cell");
           return retval;
         }
 
       if (param.numel () % 2 == 1 )
         {
-          error ("urlread: number of elements in param must be even");
+          error ("urlread: number of elements in PARAM must be even");
           return retval;
         }
     }
 
   std::ostringstream buf;
 
   bool res;
   curl_handle curl = curl_handle (url, method, param, buf, res);
@@ -1012,17 +1012,17 @@ DEFUN_DLD (__ftp_pwd__, args, ,
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_CURL
   int nargin = args.length ();
 
   if (nargin != 1)
-    error ("incorrect number of arguments");
+    error ("__ftp_pwd__: incorrect number of arguments");
   else
     {
       std::string handle = args(0).string_value ();
 
       if (!error_state)
         {
           const curl_handle curl = handles.contents (handle);
 
@@ -1044,17 +1044,17 @@ DEFUN_DLD (__ftp_cwd__, args, ,
 @deftypefn {Loadable Function} {} __ftp_cwd__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
 #ifdef HAVE_CURL
   int nargin = args.length ();
 
   if (nargin != 1 && nargin != 2)
-    error ("incorrect number of arguments");
+    error ("__ftp_cwd__: incorrect number of arguments");
   else
     {
       std::string handle = args(0).string_value ();
       std::string path = "";
 
       if (nargin > 1)
         path  = args(1).string_value ();
 
@@ -1081,17 +1081,17 @@ DEFUN_DLD (__ftp_dir__, args, nargout,
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_CURL
   int nargin = args.length ();
 
   if (nargin != 1)
-    error ("incorrect number of arguments");
+    error ("__ftp_dir__: incorrect number of arguments");
   else
     {
       std::string handle = args(0).string_value ();
 
       if (!error_state)
         {
           const curl_handle curl = handles.contents (handle);
 
@@ -1160,17 +1160,17 @@ DEFUN_DLD (__ftp_ascii__, args, ,
 @deftypefn {Loadable Function} {} __ftp_ascii__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
 #ifdef HAVE_CURL
   int nargin = args.length ();
 
   if (nargin != 1)
-    error ("incorrect number of arguments");
+    error ("__ftp_ascii__: incorrect number of arguments");
   else
     {
       std::string handle = args(0).string_value ();
 
       if (!error_state)
         {
           const curl_handle curl = handles.contents (handle);
 
@@ -1192,17 +1192,17 @@ DEFUN_DLD (__ftp_binary__, args, ,
 @deftypefn {Loadable Function} {} __ftp_binary__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
 #ifdef HAVE_CURL
   int nargin = args.length ();
 
   if (nargin != 1)
-    error ("incorrect number of arguments");
+    error ("__ftp_binary__: incorrect number of arguments");
   else
     {
       std::string handle = args(0).string_value ();
 
       if (!error_state)
         {
           const curl_handle curl = handles.contents (handle);
 
@@ -1224,17 +1224,17 @@ DEFUN_DLD (__ftp_close__, args, ,
 @deftypefn {Loadable Function} {} __ftp_close__ (@var{handle})\n\
  Undocumented internal function\n\
  @end deftypefn")
  {
  #ifdef HAVE_CURL
    int nargin = args.length ();
 
    if (nargin != 1)
-     error ("incorrect number of arguments");
+     error ("__ftp_close__: incorrect number of arguments");
    else
      {
        std::string handle = args(0).string_value ();
 
        if (!error_state)
          handles.del (handle);
      }
  #else
@@ -1250,17 +1250,17 @@ DEFUN_DLD (__ftp_mode__, args, ,
  Undocumented internal function\n\
  @end deftypefn")
  {
    octave_value retval;
  #ifdef HAVE_CURL
    int nargin = args.length ();
 
    if (nargin != 1)
-     error ("incorrect number of arguments");
+     error ("__ftp_mode__: incorrect number of arguments");
    else
      {
        std::string handle = args(0).string_value ();
 
 
       if (!error_state)
         {
           const curl_handle curl = handles.contents (handle);
@@ -1283,17 +1283,17 @@ DEFUN_DLD (__ftp_delete__, args, ,
 @deftypefn {Loadable Function} {} __ftp_delete__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
 #ifdef HAVE_CURL
   int nargin = args.length ();
 
   if (nargin != 2)
-    error ("incorrect number of arguments");
+    error ("__ftp_delete__: incorrect number of arguments");
   else
     {
       std::string handle = args(0).string_value ();
       std::string file = args(1).string_value ();
 
       if (!error_state)
         {
           const curl_handle curl = handles.contents (handle);
@@ -1316,17 +1316,17 @@ DEFUN_DLD (__ftp_rmdir__, args, ,
 @deftypefn {Loadable Function} {} __ftp_rmdir__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
 #ifdef HAVE_CURL
   int nargin = args.length ();
 
   if (nargin != 2)
-    error ("incorrect number of arguments");
+    error ("__ftp_rmdir__: incorrect number of arguments");
   else
     {
       std::string handle = args(0).string_value ();
       std::string dir = args(1).string_value ();
 
       if (!error_state)
         {
           const curl_handle curl = handles.contents (handle);
@@ -1349,17 +1349,17 @@ DEFUN_DLD (__ftp_mkdir__, args, ,
 @deftypefn {Loadable Function} {} __ftp_mkdir__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
 #ifdef HAVE_CURL
   int nargin = args.length ();
 
   if (nargin != 2)
-    error ("incorrect number of arguments");
+    error ("__ftp_mkdir__: incorrect number of arguments");
   else
     {
       std::string handle = args(0).string_value ();
       std::string dir = args(1).string_value ();
 
       if (!error_state)
         {
           const curl_handle curl = handles.contents (handle);
@@ -1382,17 +1382,17 @@ DEFUN_DLD (__ftp_rename__, args, ,
 @deftypefn {Loadable Function} {} __ftp_rename__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
 #ifdef HAVE_CURL
   int nargin = args.length ();
 
   if (nargin != 3)
-    error ("incorrect number of arguments");
+    error ("__ftp_rename__: incorrect number of arguments");
   else
     {
       std::string handle = args(0).string_value ();
       std::string oldname = args(1).string_value ();
       std::string newname = args(2).string_value ();
 
       if (!error_state)
         {
@@ -1504,17 +1504,17 @@ Undocumented internal function\n\
 @end deftypefn")
 {
   string_vector retval;
 
 #ifdef HAVE_CURL
   int nargin = args.length ();
 
   if (nargin != 2)
-    error ("incorrect number of arguments");
+    error ("__ftp_mput__: incorrect number of arguments");
   else
     {
       std::string handle = args(0).string_value ();
       std::string pat = args(1).string_value ();
 
       if (!error_state)
         {
           const curl_handle curl = handles.contents (handle);
@@ -1656,17 +1656,17 @@ DEFUN_DLD (__ftp_mget__, args, ,
 @deftypefn {Loadable Function} {} __ftp_mget__ (@var{handle}, @var{files})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
 #ifdef HAVE_CURL
   int nargin = args.length ();
 
   if (nargin != 2 && nargin != 3)
-    error ("incorrect number of arguments");
+    error ("__ftp_mget__: incorrect number of arguments");
   else
     {
       std::string handle = args(0).string_value ();
       std::string file = args(1).string_value ();
       std::string target;
 
       if (nargin == 3)
         target = args(2).string_value () + file_ops::dir_sep_str ();
