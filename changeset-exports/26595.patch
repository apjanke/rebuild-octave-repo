# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1548162475 18000
#      Tue Jan 22 08:07:55 2019 -0500
# Node ID a7d56e0a5c8c93e30044de2e682f64d7fdc72621
# Parent  ec3c4f31823bac27fb3c7df1eed90b03cd5b5948
# Parent  088b8a2dcb0672a230fe760d4fc6092ad257dbf2
maint: Merge stable to default.

diff --git a/doc/interpreter/geometry.txi b/doc/interpreter/geometry.txi
--- a/doc/interpreter/geometry.txi
+++ b/doc/interpreter/geometry.txi
@@ -308,17 +308,18 @@ plot (vx, vy, "r");
 @noindent
 The result of which can be seen in @ref{fig:voronoi}.  Note that the
 circum-circle of one of the triangles has been added to this figure, to
 make the relationship between the Delaunay tessellation and the Voronoi
 diagram clearer.
 
 @float Figure,fig:voronoi
 @center @image{voronoi,4in}
-@caption{Delaunay triangulation and Voronoi diagram of a random set of points}
+@caption{Delaunay triangulation (blue lines) and Voronoi diagram (red lines)
+of a random set of points}
 @end float
 @end ifnotinfo
 
 Additional information about the size of the facets of a Voronoi
 diagram, and which points of a set of points is in a polygon can be had
 with the @code{polyarea} and @code{inpolygon} functions respectively.
 
 @DOCSTRING(polyarea)
diff --git a/doc/interpreter/geometryimages.m b/doc/interpreter/geometryimages.m
--- a/doc/interpreter/geometryimages.m
+++ b/doc/interpreter/geometryimages.m
@@ -46,17 +46,18 @@ function geometryimages (d, nm, typ)
     hold on;
     plot (vx, vy, "r");
     [r, c] = tri2circ (tri(end,:), x, y);
     pc = [-1:0.01:1];
     xc = r * sin (pi*pc) + c(1);
     yc = r * cos (pi*pc) + c(2);
     plot (xc, yc, "g-", "LineWidth", 3);
     axis ([0, 1, 0, 1]);
-    legend ("Delaunay Triangulation", "Voronoi Diagram");
+    set (gca, "dataaspectratio", [1, 1, 1],
+              "plotboxaspectratio", [1, 1, 1]);
     print (outfile, d_typ);
   elseif (strcmp (nm, "triplot"))
     rand ("state", 2)
     x = rand (20, 1);
     y = rand (20, 1);
     tri = delaunay (x, y);
     triplot (tri, x, y);
     print (outfile, d_typ);
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -1066,18 +1066,19 @@ A complete example showing the capabilit
 @example
 @group
 x = 0:0.01:3;
 hf = figure ();
 plot (x, erf (x));
 hold on;
 plot (x, x, "r");
 axis ([0, 3, 0, 1]);
-text (0.65, 0.6175, ['$\displaystyle\leftarrow x = @{2 \over \sqrt@{\pi@}@}'...
-                     '\int_@{0@}^@{x@} e^@{-t^2@} dt = 0.6175$'],
+text (0.65, 0.6175, ...
+      ['$\displaystyle\leftarrow x = @{2 \over \sqrt@{\pi@}@}'...
+       '\int_@{0@}^@{x@} e^@{-t^2@} dt = 0.6175$'],
       "interpreter", "latex");
 xlabel ("x");
 ylabel ("erf (x)");
 title ("erf (x) with text annotation");
 print (hf, "plot15_7.pdf", "-dpdflatexstandalone");
 system ("pdflatex plot15_7");
 open plot15_7.pdf
 @end group
diff --git a/doc/interpreter/strings.txi b/doc/interpreter/strings.txi
--- a/doc/interpreter/strings.txi
+++ b/doc/interpreter/strings.txi
@@ -251,26 +251,31 @@ function.
 Nevertheless, there are several other functions for concatenating string
 objects which can be useful in specific circumstances: @code{char},
 @code{strvcat}, @code{strcat}, and @code{cstrcat}.  Finally, the general
 purpose concatenation functions can be used: see @ref{XREFcat,,cat},
 @ref{XREFhorzcat,,horzcat}, and @ref{XREFvertcat,,vertcat}.
 
 @itemize @bullet
 @item All string concatenation functions except @code{cstrcat}
-convert numerical input into character data by taking the corresponding ASCII
-character for each element, as in the following example:
+convert numerical input into character data by taking the corresponding UTF-8
+character for each element (or multi-byte sequence), as in the following
+example:
 
 @example
 @group
 char ([98, 97, 110, 97, 110, 97])
    @result{} banana
 @end group
 @end example
 
+For conversion between locale encodings and UTF-8, see
+@ref{XREFunicode2native,,unicode2native} and
+@ref{XREFnative2unicode,,native2unicode}.
+
 @item
 @code{char} and @code{strvcat}
 concatenate vertically, while @code{strcat} and @code{cstrcat} concatenate
 horizontally.  For example:
 
 @example
 @group
 char ("an apple", "two pears")
@@ -358,23 +363,23 @@ from the internal representation of the 
 
 @DOCSTRING(strcat)
 
 @DOCSTRING(cstrcat)
 
 @node Converting Numerical Data to Strings
 @subsection Converting Numerical Data to Strings
 Apart from the string concatenation functions (@pxref{Concatenating Strings})
-which cast numerical data to the corresponding ASCII characters, there are
-several functions that format numerical data as strings.  @code{mat2str} and
-@code{num2str} convert real or complex matrices, while @code{int2str} converts
-integer matrices.  @code{int2str} takes the real part of complex values and
-round fractional values to integer.  A more flexible way to format numerical
-data as strings is the @code{sprintf} function (@pxref{Formatted Output},
-@ref{XREFsprintf,,sprintf}).
+which cast numerical data to the corresponding UTF-8 encoded characters, there
+are several functions that format numerical data as strings.  @code{mat2str}
+and @code{num2str} convert real or complex matrices, while @code{int2str}
+converts integer matrices.  @code{int2str} takes the real part of complex
+values and round fractional values to integer.  A more flexible way to format
+numerical data as strings is the @code{sprintf} function
+(@pxref{Formatted Output}, @ref{XREFsprintf,,sprintf}).
 
 @DOCSTRING(mat2str)
 
 @DOCSTRING(num2str)
 
 @DOCSTRING(int2str)
 
 @node Comparing Strings
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -1803,17 +1803,18 @@ num2cell (x, 1)
 num2cell (x, 2)
    @result{}
       @{
         [1,1] =
            1   2
         [2,1] =
            3   4
       @}
-## all rows and cols appear in each element of C (hence, only 1 output)
+## all rows and cols appear in each element of C
+## (hence, only 1 output)
 num2cell (x, [1, 2])
    @result{}
       @{
         [1,1] =
            1   2
            3   4
       @}
 @end example
@@ -2131,18 +2132,20 @@ Examples
 x = reshape (1:12, [3, 4])'
 @result{}
     1    2    3
     4    5    6
     7    8    9
    10   11   12
 
 @group
-## The 4 rows (dim1) are divided in to two cell elements with 2 rows each.
-## The 3 cols (dim2) are divided in to three cell elements with 1 col each.
+## The 4 rows (dim1) are divided in to two cell elements
+## with 2 rows each.
+## The 3 cols (dim2) are divided in to three cell elements
+## with 1 col each.
 mat2cell (x, [2,2], [1,1,1])
 @result{}
 @{
   [1,1] =
 
      1
      4
 
@@ -2167,17 +2170,18 @@ mat2cell (x, [2,2], [1,1,1])
 
   [2,3] =
       9
      12
 @}
 @end group
 
 @group
-## The 4 rows (dim1) are divided in to two cell elements with a 3/1 split.
+## The 4 rows (dim1) are divided in to two cell elements
+## with a 3/1 split.
 ## All columns appear in each output element.
 mat2cell (x, [3,1])
 @result{}
 @{
   [1,1] =
 
      1   2   3
      4   5   6
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -5077,17 +5077,17 @@ axes::properties::sync_positions (void)
   update_transform ();
   if (activepositionproperty.is ("position"))
     update_position ();
   else
     update_outerposition ();
 }
 
 /*
-%!testif HAVE_OPENGL, HAVE_FLTK; have_window_system
+%!testif HAVE_OPENGL, HAVE_FLTK; have_window_system () && any (strcmp ("fltk", available_graphics_toolkits ()))
 %! hf = figure ("visible", "off");
 %! graphics_toolkit (hf, "fltk");
 %! unwind_protect
 %!   subplot(2,1,1); plot(rand(10,1)); subplot(2,1,2); plot(rand(10,1));
 %!   hax = findall (gcf (), "type", "axes");
 %!   positions = cell2mat (get (hax, "position"));
 %!   outerpositions = cell2mat (get (hax, "outerposition"));
 %!   looseinsets = cell2mat (get (hax, "looseinset"));
@@ -5097,17 +5097,17 @@ axes::properties::sync_positions (void)
 %!   assert (cell2mat (get (hax, "position")), positions, 1e-4);
 %!   assert (cell2mat (get (hax, "outerposition")), outerpositions, 1e-4);
 %!   assert (cell2mat (get (hax, "looseinset")), looseinsets, 1e-4);
 %!   assert (cell2mat (get (hax, "tightinset")), tightinsets, 1e-4);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
-%!testif HAVE_OPENGL, HAVE_FLTK; have_window_system
+%!testif HAVE_OPENGL, HAVE_FLTK; have_window_system () && any (strcmp ("fltk", available_graphics_toolkits ()))
 %! hf = figure ("visible", "off");
 %! graphics_toolkit (hf, "fltk");
 %! fpos = get (hf, "position");
 %! unwind_protect
 %!   plot (rand (3));
 %!   position = get (gca, "position");
 %!   outerposition = get (gca, "outerposition");
 %!   looseinset = get (gca, "looseinset");
@@ -5117,17 +5117,17 @@ axes::properties::sync_positions (void)
 %!   assert (get (gca, "outerposition"), outerposition, 0.001);
 %!   assert (get (gca, "position"), position, 0.001);
 %!   assert (get (gca, "looseinset"), looseinset, 0.001);
 %!   assert (get (gca, "tightinset"), tightinset, 0.001);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
-%!testif HAVE_OPENGL, HAVE_FLTK; have_window_system
+%!testif HAVE_OPENGL, HAVE_FLTK; have_window_system () && any (strcmp ("fltk", available_graphics_toolkits ()))
 %! hf = figure ("visible", "off");
 %! graphics_toolkit (hf, "fltk");
 %! fpos = get (hf, "position");
 %! set (gca, "activepositionproperty", "position");
 %! unwind_protect
 %!   plot (rand (3));
 %!   position = get (gca, "position");
 %!   outerposition = get (gca, "outerposition");
@@ -11827,17 +11827,17 @@ gh_manager::do_process_events (bool forc
 /*
 ## Test interruptible/busyaction properties
 %!function cb (h)
 %! setappdata (gcbf (), "cb_exec", [getappdata(gcbf (), "cb_exec") h]);
 %! drawnow ();
 %! setappdata (gcbf (), "cb_exec", [getappdata(gcbf (), "cb_exec") h]);
 %!endfunction
 %!
-%!testif HAVE_OPENGL, HAVE_FLTK; have_window_system
+%!testif HAVE_OPENGL, HAVE_FLTK; have_window_system () && any (strcmp ("fltk", available_graphics_toolkits ()))
 %! hf = figure ("visible", "off", "resizefcn", @cb);
 %! unwind_protect
 %!   ## Default
 %!   hui1 = uicontrol ("parent", hf, "interruptible", "on", "callback", @cb);
 %!   hui2 = uicontrol ("parent", hf, "busyaction", "queue", "callback", @cb);
 %!   hui3 = uicontrol ("parent", hf, "busyaction", "queue", "callback", @cb);
 %!   __go_post_callback__ (hui1, "callback");
 %!   __go_post_callback__ (hui2, "callback");
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -232,24 +232,27 @@ namespace octave
     return h;
   }
 
   std::string help_system::which (const std::string& name,
                                   std::string& type) const
   {
     std::string file;
 
-    type = "";
+    if (name.empty ())
+      return file;
 
-    symbol_table& symtab = m_interpreter.get_symbol_table ();
-
-    octave_value val = symtab.find_function (name);
+    type = "";
 
     if (name.find_first_of ('.') == std::string::npos)
       {
+        symbol_table& symtab = m_interpreter.get_symbol_table ();
+
+        octave_value val = symtab.find_function (name);
+
         if (val.is_defined ())
           {
             octave_function *fcn = val.function_value ();
 
             if (fcn)
               {
                 file = fcn->fcn_file_name ();
 
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -3382,22 +3382,36 @@ of properly displaying the object's name
   if (print_newlines)
     octave_stdout << std::endl;
 
   return ovl ();
 }
 
 /*
 %!test
-%! str = evalc ("x = 1.1; display (x)");
-%! assert (str, "x =  1.1000\n");
+%! [old_fmt, old_spacing] = format ();
+%! unwind_protect
+%!   format short;
+%!   str = evalc ("x = 1.1; display (x)");
+%!   assert (str, "x =  1.1000\n");
+%! unwind_protect_cleanup
+%!   format (old_fmt);
+%!   format (old_spacing);
+%! end_unwind_protect
 
 %!test
-%! str = evalc ("display (1.1)");
-%! assert (str, " 1.1000\n");
+%! [old_fmt, old_spacing] = format ();
+%! unwind_protect
+%!   format short;
+%!   str = evalc ("display (1.1)");
+%!   assert (str, " 1.1000\n");
+%! unwind_protect_cleanup
+%!   format (old_fmt);
+%!   format (old_spacing);
+%! end_unwind_protect
 
 ## Test input validation
 %!error display ()
 %!error display (1,2)
 */
 
 static inline void
 init_format_state (void)
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -396,16 +396,37 @@ namespace octave
           m_fcn_table[name] = finfo;
 
         return fcn;
       }
 
     return octave_value ();
   }
 
+  octave_value symbol_table::find_function (const std::string& name)
+  {
+    if (name.empty ())
+      return octave_value ();
+
+    if (name[0] == '@')
+      {
+        size_t pos = name.find_first_of ('/');
+
+        if (pos == std::string::npos)
+          return octave_value ();
+
+        std::string method = name.substr (pos+1);
+        std::string dispatch_type = name.substr (1, pos-1);
+
+        return find_method (method, dispatch_type);
+      }
+    else
+      return find_function (name, ovl ());
+  }
+
   octave_value
   symbol_table::find_function (const std::string& name,
                                const octave_value_list& args)
   {
     octave_value fcn;
 
     if (m_current_scope)
       {
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -207,19 +207,31 @@ namespace octave
     }
 
     octave_value builtin_find (const std::string& name);
 
     octave_value
     fcn_table_find (const std::string& name,
                     const octave_value_list& args = octave_value_list ());
 
+    // If NAME is of the form @CLASS/FUNCTION, call
+    //
+    //   find_method (FUNCTION, CLASS)
+    //
+    // otherwise call
+    //
+    //   function_function (NAME, ovl ())
+
+    octave_value find_function (const std::string& name);
+
+    // NAME should just be function name; dispatch type determined
+    // from types of ARGS.
+
     octave_value
-    find_function (const std::string& name,
-                   const octave_value_list& args = octave_value_list ());
+    find_function (const std::string& name, const octave_value_list& args);
 
     octave_value find_user_function (const std::string& name)
     {
       auto p = m_fcn_table.find (name);
 
       return (p != m_fcn_table.end ()
               ? p->second.find_user_function () : octave_value ());
     }
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -25,17 +25,17 @@ along with Octave; see the file COPYING.
 
 To initialize:
 
   graphics_toolkit ("fltk");
   plot (randn (1e3, 1));
 
 */
 
-// PKG_ADD: if (__have_feature__ ("FLTK") && __have_feature__ ("OPENGL") && have_window_system ()) register_graphics_toolkit ("fltk"); endif
+// PKG_ADD: if (__have_feature__ ("FLTK") && __have_feature__ ("OPENGL") && have_window_system () && ! (ismac () && __octave_link_enabled__ ())) register_graphics_toolkit ("fltk"); endif
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "defun-dld.h"
 #include "error.h"
 #include "errwarn.h"
diff --git a/libinterp/op-kw-docs b/libinterp/op-kw-docs
--- a/libinterp/op-kw-docs
+++ b/libinterp/op-kw-docs
@@ -668,16 +668,28 @@ case statements match the input.
 @end deftypefn
 parfor
 @c libinterp/parse-tree/oct-parse.yy
 -*- texinfo -*-
 @deftypefn  {} {} parfor @var{i} = @var{range}
 @deftypefnx {} {} parfor (@var{i} = @var{range}, @var{maxproc})
 Begin a for loop that may execute in parallel.
 
+A @code{parfor} loop has the same syntax as a @code{for} loop.  If your Octave
+session has a parallel processing pool enabled, the iterations of the
+@code{parfor} loop will be executed in parallel across the pool's workers.
+Otherwise, @code{parfor} will behave exactly as @code{for}.
+
+When operating in parallel mode, a @code{parfor} loop's iterations are not
+guaranteed to occur sequentially, and there are additional restrictions about
+the data access operations you can do inside the loop body.
+
+@strong{Warning:} parallel processing pools are currently unimplemented in
+Octave; @code{parfor} currently behaves exactly as a normal @code{for} loop.
+
 @example
 @group
 parfor i = 1:10
   i
 endparfor
 @end group
 @end example
 @seealso{for, do, while}
diff --git a/libinterp/parse-tree/oct-parse.yy b/libinterp/parse-tree/oct-parse.yy
--- a/libinterp/parse-tree/oct-parse.yy
+++ b/libinterp/parse-tree/oct-parse.yy
@@ -5794,20 +5794,27 @@ s = evalc ("t = 42"), t
 %!function [a, b] = __f_evalc ()
 %!  printf ("foo");
 %!  fprintf (stdout, "bar");
 %!  disp (pi);
 %!  a = 1;
 %!  b = 2;
 %!endfunction
 %!test
-%! [s, a, b] = evalc ("__f_evalc ()");
-%! assert (s, "foobar 3.1416\n");
-%! assert (a, 1);
-%! assert (b, 2);
+%! [old_fmt, old_spacing] = format ();
+%! unwind_protect
+%!   format short;
+%!   [s, a, b] = evalc ("__f_evalc ()");
+%!   assert (s, "foobar 3.1416\n");
+%!   assert (a, 1);
+%!   assert (b, 2);
+%! unwind_protect_cleanup
+%!   format (old_fmt);
+%!   format (old_spacing);
+%! end_unwind_protect
 
 %!error <foo> (evalc ("error ('foo')"))
 %!error <bar> (evalc ("error ('foo')", "error ('bar')"))
 
 %!test
 %! warning ("off", "quiet", "local");
 %! assert (evalc ("warning ('foo')"), "warning: foo\n");
 
diff --git a/scripts/general/circshift.m b/scripts/general/circshift.m
--- a/scripts/general/circshift.m
+++ b/scripts/general/circshift.m
@@ -32,29 +32,33 @@
 ## In this case @var{n} must be a scalar as well.
 ##
 ## Examples:
 ##
 ## @example
 ## x = [1, 2, 3;
 ##      4, 5, 6;
 ##      7, 8, 9];
-## circshift (x, 1)      # positive shift on rows (1st non-singular dim)
+## ## positive shift on rows (1st non-singular dim)
+## circshift (x, 1)
 ##  @result{}  7, 8, 9
 ##      1, 2, 3
 ##      4, 5, 6
-## circshift (x, -2)     # negative shift on rows (1st non-singular dim)
+## ## negative shift on rows (1st non-singular dim)
+## circshift (x, -2)
 ##  @result{}  7, 8, 9
 ##      1, 2, 3
 ##      4, 5, 6
-## circshift (x, [0,1])  # no shift of rows, shift columns by 1 (2nd dimension)
+## ## no shift of rows, shift columns by 1 (2nd dimension)
+## circshift (x, [0,1])
 ##  @result{}  3, 1, 2
 ##      6, 4, 5
 ##      9, 7, 8
-## circshift (x, 1, 2)   # shift columns (2nd dimension)
+## ## shift columns (2nd dimension)
+## circshift (x, 1, 2)
 ##  @result{}  3, 1, 2
 ##      6, 4, 5
 ##      9, 7, 8
 ## @end example
 ## @seealso{permute, ipermute, shiftdim}
 ## @end deftypefn
 
 function y = circshift (x, n, dim)
diff --git a/scripts/gui/inputdlg.m b/scripts/gui/inputdlg.m
--- a/scripts/gui/inputdlg.m
+++ b/scripts/gui/inputdlg.m
@@ -62,17 +62,18 @@
 ##
 ## Example:
 ##
 ## @example
 ## @group
 ## prompt = @{"Width", "Height", "Depth"@};
 ## defaults = @{"1.10", "2.20", "3.30"@};
 ## rowscols = [1,10; 2,20; 3,30];
-## dims = inputdlg (prompt, "Enter Box Dimensions", rowscols, defaults);
+## dims = inputdlg (prompt, "Enter Box Dimensions", ...
+##                  rowscols, defaults);
 ## @end group
 ## @end example
 ##
 ## @seealso{errordlg, helpdlg, listdlg, msgbox, questdlg, warndlg}
 ## @end deftypefn
 
 function cstr = inputdlg (prompt, varargin)
 
diff --git a/scripts/gui/questdlg.m b/scripts/gui/questdlg.m
--- a/scripts/gui/questdlg.m
+++ b/scripts/gui/questdlg.m
@@ -42,17 +42,18 @@
 ##
 ## If only two button captions, @var{btn1} and @var{btn2}, are specified the
 ## dialog will have only these two buttons.
 ##
 ## Examples:
 ##
 ## @example
 ## @group
-## btn = questdlg ("Close Octave?", "Some fancy title", "Yes", "No", "No");
+## btn = questdlg ("Close Octave?", "Some fancy title", ...
+##                 "Yes", "No", "No");
 ## if (strcmp (btn, "Yes"))
 ##   exit ();
 ## endif
 ## @end group
 ## @end example
 ##
 ## @seealso{errordlg, helpdlg, inputdlg, listdlg, msgbox, warndlg}
 ## @end deftypefn
diff --git a/scripts/gui/uicontextmenu.m b/scripts/gui/uicontextmenu.m
--- a/scripts/gui/uicontextmenu.m
+++ b/scripts/gui/uicontextmenu.m
@@ -31,25 +31,27 @@
 ## created uicontextmenu object.
 ##
 ## Uicontextmenu properties are documented at @ref{Uicontextmenu Properties}.
 ##
 ## Examples:
 ##
 ## @example
 ## @group
-## % create figure and uicontextmenu
-## f = figure;
+## ## create figure and uicontextmenu
+## f = figure ();
 ## c = uicontextmenu (f);
 ##
-## % create menus in the context menu
-## m1 = uimenu ("parent",c,"label","Menu item 1","callback","disp('menu item 1')");
-## m2 = uimenu ("parent",c,"label","Menu item 2","callback","disp('menu item 2')");
+## ## create menus in the context menu
+## m1 = uimenu ("parent", c, "label", "Menu item 1", ...
+##              "callback", "disp('menu item 1')");
+## m2 = uimenu ("parent", c, "label", "Menu item 2", ...
+##              "callback", "disp('menu item 2')");
 ##
-## % set the context menu for the figure
+## ## set the context menu for the figure
 ## set (f, "uicontextmenu", c);
 ## @end group
 ## @end example
 ## @seealso{figure, uimenu}
 ## @end deftypefn
 
 ## Author: goffioul
 
diff --git a/scripts/gui/uicontrol.m b/scripts/gui/uicontrol.m
--- a/scripts/gui/uicontrol.m
+++ b/scripts/gui/uicontrol.m
@@ -81,17 +81,18 @@
 ##
 ## Examples:
 ##
 ## @example
 ## @group
 ## ## Create figure and panel on it
 ## f = figure;
 ## ## Create a button (default style)
-## b1 = uicontrol (f, "string", "A Button", "position", [10 10 150 40]);
+## b1 = uicontrol (f, "string", "A Button", ...
+##                    "position", [10 10 150 40]);
 ## ## Create an edit control
 ## e1 = uicontrol (f, "style", "edit", "string", "editable text", ...
 ##                    "position", [10 60 300 40]);
 ## ## Create a checkbox
 ## c1 = uicontrol (f, "style", "checkbox", "string", "a checkbox", ...
 ##                    "position", [10 120 150 40]);
 ## @end group
 ## @end example
diff --git a/scripts/gui/uimenu.m b/scripts/gui/uimenu.m
--- a/scripts/gui/uimenu.m
+++ b/scripts/gui/uimenu.m
@@ -101,47 +101,47 @@ endfunction
 %! surfl (peaks);
 %! colormap (copper (64));
 %! shading ('interp');
 %! f = uimenu ('label', '&File', 'accelerator', 'f');
 %! e = uimenu ('label', '&Edit', 'accelerator', 'e');
 %! uimenu (f, 'label', 'Close', 'accelerator', 'q', 'callback', 'close (gcf)');
 %! uimenu (e, 'label', 'Toggle &Grid', 'accelerator', 'g', 'callback', 'grid (gca)');
 
-%!testif HAVE_OPENGL, HAVE_FLTK; have_window_system ()
+%!testif HAVE_OPENGL, HAVE_FLTK; have_window_system () && any (strcmp ("fltk", available_graphics_toolkits ()))
 %! toolkit = graphics_toolkit ("fltk");
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   ui = uimenu ("label", "mylabel");
 %!   assert (findobj (hf, "type", "uimenu"), ui);
 %!   assert (get (ui, "label"), "mylabel");
 %!   assert (get (ui, "checked"), "off");
 %!   assert (get (ui, "separator"), "off");
 %!   assert (get (ui, "enable"), "on");
 %!   assert (get (ui, "position"), 0);
 %! unwind_protect_cleanup
 %!   close (hf);
 %!   graphics_toolkit (toolkit);
 %! end_unwind_protect
 
 ## check for top level menus file and edit
-%!testif HAVE_OPENGL, HAVE_FLTK; have_window_system ()
+%!testif HAVE_OPENGL, HAVE_FLTK; have_window_system () && any (strcmp ("fltk", available_graphics_toolkits ()))
 %! toolkit = graphics_toolkit ("fltk");
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   uif = findall (hf, "label", "&file");
 %!   assert (ishghandle (uif));
 %!   uie = findall (hf, "label", "&edit");
 %!   assert (ishghandle (uie));
 %! unwind_protect_cleanup
 %!   close (hf);
 %!   graphics_toolkit (toolkit);
 %! end_unwind_protect
 
-%!testif HAVE_OPENGL, HAVE_FLTK; have_window_system ()
+%!testif HAVE_OPENGL, HAVE_FLTK; have_window_system () && any (strcmp ("fltk", available_graphics_toolkits ()))
 %! toolkit = graphics_toolkit ("fltk");
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   uie = findall (hf, "label", "&edit");
 %!   myui = uimenu (uie, "label", "mylabel");
 %!   assert (ancestor (myui, "uimenu", "toplevel"), uie);
 %! unwind_protect_cleanup
 %!   close (hf);
diff --git a/scripts/gui/uipanel.m b/scripts/gui/uipanel.m
--- a/scripts/gui/uipanel.m
+++ b/scripts/gui/uipanel.m
@@ -13,17 +13,17 @@
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <https://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {} {} uipanel (@var{property}, @var{value}, @dots{})
-## @deftypefnx {} {} uipanel (@var{parent}, "@var{property}, @var{value}, @dots{})
+## @deftypefnx {} {} uipanel (@var{parent}, @var{property}, @var{value}, @dots{})
 ## @deftypefnx {} {@var{hui} =} uipanel (@dots{})
 ##
 ## Create a uipanel object.
 ##
 ## uipanels are used as containers to group other uicontrol objects.
 ##
 ## If @var{parent} is omitted then a uipanel for the current figure is
 ## created.  If no figure is available, a new figure is created first.
@@ -37,23 +37,25 @@
 ##
 ## The optional return value @var{hui} is a graphics handle to the created
 ## uipanel object.
 ##
 ## Examples:
 ##
 ## @example
 ## @group
-## % create figure and panel on it
+## ## create figure and panel on it
 ## f = figure;
 ## p = uipanel ("title", "Panel Title", "position", [.25 .25 .5 .5]);
 ##
-## % add two buttons to the panel
-## b1 = uicontrol ("parent", p, "string", "A Button", "position",[18 10 150 36]);
-## b2 = uicontrol ("parent", p, "string", "Another Button", "position",[18 60 150 36]);
+## ## add two buttons to the panel
+## b1 = uicontrol ("parent", p, "string", "A Button", ...
+##                 "position", [18 10 150 36]);
+## b2 = uicontrol ("parent", p, "string", "Another Button", ...
+##                 "position",[18 60 150 36]);
 ##
 ## @end group
 ## @end example
 ## @seealso{figure, uicontrol}
 ## @end deftypefn
 
 ## Author: goffioul
 
diff --git a/scripts/gui/uitable.m b/scripts/gui/uitable.m
--- a/scripts/gui/uitable.m
+++ b/scripts/gui/uitable.m
@@ -77,19 +77,21 @@
 ##         "uint16" , uint16 (32768);
 ##         "int32"  , int32 (-2147483648);
 ##         "uint32" , uint32 (2147483648);
 ##         "int64"  , int64 (-2147483649);
 ##         "uint64" , uint64 (2147843649)@};
 ##
 ##   popup_options = @{"A", "B", "C", "D", "E"@};
 ##
-##   columnformat_options = @{ "[]", "char", "pop-up", "numeric", "short", "short e", ...
-##                   "short eng", "short g", "long", "long e", "long eng", ...
-##                   "long g", "bank", "+", "rat", "logical"@};
+##   columnformat_options = @{ "[]", "char", "pop-up", "numeric", ...
+##                            "short", "short e", "short eng", ...
+##                            "short g", "long", "long e", ...
+##                            "long eng", "long g", "bank", "+", ...
+##                            "rat", "logical"@};
 ##   columnformat_values = columnformat_options;
 ##   columnformat_values@{1@} = "";
 ##   columnformat_values@{3@} = popup_options;
 ##
 ##   default_data = repmat (d(:,2), 1, columns (columnformat_options));
 ##   b_add = uicontrol (f, "Position", [285 630 600 50], ...
 ##             "UserData", [rows(d), 1], ...
 ##             "Style", "pushbutton", ...
@@ -112,55 +114,66 @@
 ##       "RowName", [], ...
 ##       "ColumnName", @{"x", "y"@}, ...
 ##       "Data", [ 1, 1 ], ...
 ##       "ColumnEditable", true);
 ##
 ##   l_editable_table = uicontrol (f, "Position", [ 0 502 200 25 ], ...
 ##       "Style", "text", ...
 ##       "String", "Set Data Columns Editable:");
-##   t_editable_table = uitable (f, "Position", [ 0 434 1000 65 ], ...
-##                              "Data", repmat (false, 1, columns (default_data)), ...
-##                              "ColumnEditable", true);
+##   t_editable_table = ...
+##     uitable (f, "Position", [ 0 434 1000 65 ], ...
+##                 "Data", repmat (false, 1, columns (default_data)), ...
+##                 "ColumnEditable", true);
 ##
 ##   l_format_table = uicontrol (f, "Position", [ 0 406 200 25 ], ...
 ##       "Style", "text", ...
 ##       "String", "Set Data Column Format:");
-##   t_format_table = uitable (f, "Position", [ 0 338 1000 65 ], ...
-##       "Data", columnformat_options, ...
-##       "ColumnEditable", true, ...
-##       "ColumnFormat", arrayfun (@@(x) @{columnformat_options@}, 1:columns (columnformat_options)));
+##   t_format_table = ...
+##     uitable (f, "Position", [ 0 338 1000 65 ], ...
+##                 "Data", columnformat_options, ...
+##                 "ColumnEditable", true, ...
+##                 "ColumnFormat", arrayfun (@@(x) @{columnformat_options@}, ...
+##                                           1:columns (columnformat_options)));
 ##
-##   l_data_table = uicontrol (f, "Style", "text", "String", "Data:", "Position", [ 0 310 60 25 ]);
+##   l_data_table = uicontrol (f, "Style", "text", ...
+##                                "String", "Data:", ...
+##                                "Position", [ 0 310 60 25 ]);
 ##   t_data_table = uitable (f, "Position", [ 0 15 1000 290 ], ...
 ##       "Data", default_data, ...
 ##       "ColumnFormat", columnformat_values);
 ##
-##   set (t_format_table, "CellEditCallback", ...
-##       @@(x, y) update_column_format (y.NewData, y.Indices, t_data_table, popup_options));
+##   set (t_format_table, ...
+##        "CellEditCallback", ...
+##        @@(x, y) update_column_format (y.NewData, y.Indices, ...
+##                                       t_data_table, popup_options));
 ##   set (t_point_table, "CellEditCallback", ...
-##      @@(x, y) validate_point_table (x, y, t_data_table));
-##   set (t_editable_table, "CellEditCallback", @@(x,y) set (t_data_table, ...
-##           "ColumnEditable", get (t_editable_table, "Data")));
-##   set (b_add, "Callback", @@(x, y) ...
-##           update_data (b_add, t_point_table, t_type_table, t_data_table));
-##   set (t_data_table, "cellselectioncallback", @@(x, y) update_point_table (y.Indices, t_point_table));
+##        @@(x, y) validate_point_table (x, y, t_data_table));
+##   set (t_editable_table, "CellEditCallback", ...
+##        @@(x,y) set (t_data_table, ...
+##                     "ColumnEditable", get (t_editable_table, "Data")));
+##   set (b_add, ...
+##        "Callback", @@(x, y) update_data (b_add, t_point_table, ...
+##                                          t_type_table, t_data_table));
+##   set (t_data_table, "CellSelectionCallback", ...
+##        @@(x, y) update_point_table (y.Indices, t_point_table));
 ## endfunction
 ##
 ## function validate_point_table (h, dat, t_data_table)
 ##   if (! (dat.NewData > 0 && ...
 ##     dat.NewData < size (get (t_data_table, "Data"), dat.Indices(1, 1)) + 1))
 ##
 ##     d = get (h, "Data");
 ##     d(dat.Indices) = 1;
 ##     set (h, "Data", d);
 ##   endif
 ## endfunction
 ##
-## function update_column_format (format, indices, t_data_table, popup_options)
+## function update_column_format (format, indices, t_data_table, ...
+##                                popup_options)
 ##   cf = get (t_data_table, "ColumnFormat");
 ##   if (strcmp (format, "[]"))
 ##     format = "";
 ##   elseif (strcmp (format, "pop-up"))
 ##     format = popup_options;
 ##   endif
 ##   cf@{indices(1,2)@} = format;
 ##   set (t_data_table, "ColumnFormat", cf);
@@ -168,17 +181,18 @@
 ##
 ## function update_point_table (indices, t_point_table)
 ##   if (isempty (indices))
 ##     indices = [1, 1];
 ##   endif
 ##   set (t_point_table, "Data", indices(1,:));
 ## endfunction
 ##
-## function update_data (b_add, t_point_table, t_type_table, t_data_table)
+## function update_data (b_add, t_point_table, t_type_table, ...
+##                       t_data_table)
 ##   indices = get (b_add, "UserData");
 ##   if (isempty (indices))
 ##     indices = [1, 1];
 ##   endif
 ##   d = get (t_data_table, "Data");
 ##   t_type_table_data = get (t_type_table, "Data");
 ##   p = get (t_point_table, "Data");
 ##   d(p(1,2), p(1,1)) = t_type_table_data(indices(1,2));
diff --git a/scripts/help/warning_ids.m b/scripts/help/warning_ids.m
--- a/scripts/help/warning_ids.m
+++ b/scripts/help/warning_ids.m
@@ -242,16 +242,17 @@
 ##
 ## @item Octave:mixed-string-concat
 ## If the @code{Octave:mixed-string-concat} warning is enabled, print a
 ## warning when concatenating a mixture of double and single quoted strings.
 ## By default, the @code{Octave:mixed-string-concat} warning is disabled.
 ##
 ## @item  Octave:nearly-singular-matrix
 ## @itemx Octave:singular-matrix
+## These warnings are emitted if a (nearly) singular matrix is inverted.
 ## By default, the @code{Octave:nearly-singular-matrix} and
 ## @code{Octave:singular-matrix} warnings are enabled.
 ##
 ## @item Octave:neg-dim-as-zero
 ## If the @code{Octave:neg-dim-as-zero} warning is enabled, print a warning
 ## for expressions like
 ##
 ## @example
@@ -264,17 +265,17 @@
 ## @item Octave:nested-functions-coerced
 ## By default, the @code{Octave:nested-functions-coerced} warning is enabled.
 ##
 ## @item Octave:noninteger-range-as-index
 ## By default, the @code{Octave:noninteger-range-as-index} warning is enabled.
 ##
 ## @item Octave:num-to-str
 ## If the @code{Octave:num-to-str} warning is enable, a warning is
-## printed for implicit conversions of numbers to their ASCII character
+## printed for implicit conversions of numbers to their UTF-8 encoded character
 ## equivalents when strings are constructed using a mixture of strings and
 ## numbers in matrix notation.  For example,
 ##
 ## @example
 ## @group
 ## [ "f", 111, 111 ]
 ## @result{} "foo"
 ## @end group
@@ -339,18 +340,18 @@
 ## string constant.
 ## By default, the @code{Octave:single-quote-string} warning is disabled.
 ##
 ## @item Octave:sqrtm:SingularMatrix
 ## By default, the @code{Octave:sqrtm:SingularMatrix} warning is enabled.
 ##
 ## @item Octave:str-to-num
 ## If the @code{Octave:str-to-num} warning is enabled, a warning is printed
-## for implicit conversions of strings to their numeric ASCII equivalents.
-## For example,
+## for implicit conversions of strings to their numeric UTF-8 encoded byte
+## sequences.  For example,
 ##
 ## @example
 ## @group
 ## "abc" + 0
 ## @result{} 97 98 99
 ## @end group
 ## @end example
 ##
diff --git a/scripts/miscellaneous/mkdir.m b/scripts/miscellaneous/mkdir.m
--- a/scripts/miscellaneous/mkdir.m
+++ b/scripts/miscellaneous/mkdir.m
@@ -19,25 +19,26 @@
 ## @deftypefn  {} {} mkdir @var{dirname}
 ## @deftypefnx {} {} mkdir @var{parent} @var{dirname}
 ## @deftypefnx {} {} mkdir (@var{dirname})
 ## @deftypefnx {} {} mkdir (@var{parent}, @var{dirname})
 ## @deftypefnx {} {[@var{status}, @var{msg}, @var{msgid}] =} mkdir (@dots{})
 ## Create a directory named @var{dirname} in the directory @var{parent},
 ## creating any intermediate directories if necessary.
 ##
-## If @var{dir} is a relative path, and no @var{parent} directory is specified,
-## then the present working directory is used.
+## If @var{dirname} is a relative path, and no @var{parent} directory is
+## specified, then the present working directory is used.
 ##
 ## If successful, @var{status} is 1, and @var{msg} and @var{msgid} are empty
 ## strings ("").  Otherwise, @var{status} is 0, @var{msg} contains a
 ## system-dependent error message, and @var{msgid} contains a unique message
 ## identifier.
 ##
-## When creating a directory permissions will be set to @code{0777 - UMASK}.
+## When creating a directory permissions will be set to
+## @w{@code{0777 - UMASK}}.
 ##
 ## @seealso{rmdir, pwd, cd, umask}
 ## @end deftypefn
 
 ## There is/was a bug in gnulib's mkdir-p module under Windows.
 ## This file is a workaround until that is fixed and the fix incorporated
 ## into Octave.
 
@@ -66,16 +67,20 @@ function [status, msg, msgid] = mkdir (p
 
 endfunction
 
 ## Recursively make directories until parent/dirname can be created.
 function [status, msg, msgid] = mkdir_recur (parent, dirname)
 
   status = 1;
 
+  if (isempty (parent))
+    error ("mkdir: invalid PARENT");
+  endif
+
   if (! isfolder (parent))
     [grandparent, name, ext] = fileparts (parent);
     [status, msg, msgid] = mkdir_recur (grandparent, [name, ext]);
   endif
 
   if (status)
     [status, msg, msgid] = __mkdir__ (parent, dirname);
   endif
@@ -110,11 +115,14 @@ endfunction
 %!   rmdir (tmp_dir);
 %!   if (isempty (HOME))
 %!     unsetenv ("HOME");
 %!   else
 %!     setenv ("HOME", HOME);
 %!   endif
 %! end_unwind_protect
 
+%!test <*55540>
+%! fail ('mkdir ("__%hello%__", "world")', "invalid PARENT");
+
 ## Test input validation
 %!error mkdir ()
 %!error mkdir ("a", "b", "c")
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -181,17 +181,18 @@
 ## pkg describe -verbose
 ## @end example
 ##
 ## @noindent
 ## will describe all installed packages and the functions they provide.
 ## Display can be limited to a set of packages:
 ##
 ## @example
-## pkg describe control signal # describe control and signal packages
+## ## describe control and signal packages
+## pkg describe control signal
 ## @end example
 ##
 ## If one output is requested a cell of structure containing the
 ## description and list of functions of each package is returned as
 ## output rather than printed on screen:
 ##
 ## @example
 ## desc = pkg ("describe", "secs1d", "image")
diff --git a/scripts/plot/util/allchild.m b/scripts/plot/util/allchild.m
--- a/scripts/plot/util/allchild.m
+++ b/scripts/plot/util/allchild.m
@@ -43,17 +43,17 @@ function h = allchild (handles)
     h = get (handles, "children");
   unwind_protect_cleanup
     set (0, "showhiddenhandles", shh);
   end_unwind_protect
 
 endfunction
 
 
-%!testif HAVE_OPENGL, HAVE_FLTK; have_window_system ()
+%!testif HAVE_OPENGL, HAVE_FLTK; have_window_system () && any (strcmp ("fltk", available_graphics_toolkits ()))
 %! toolkit = graphics_toolkit ("fltk");
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   l = line;
 %!   kids = allchild (hf);
 %!   assert (get (kids, "type"), {"axes"; "uimenu"; "uimenu"; "uimenu"});
 %! unwind_protect_cleanup
 %!   close (hf);
diff --git a/scripts/plot/util/findall.m b/scripts/plot/util/findall.m
--- a/scripts/plot/util/findall.m
+++ b/scripts/plot/util/findall.m
@@ -45,17 +45,17 @@ function h = findall (varargin)
     h = findobj (varargin{:});
   unwind_protect_cleanup
     set (0, "showhiddenhandles", shh);
   end_unwind_protect
 
 endfunction
 
 
-%!testif HAVE_OPENGL, HAVE_FLTK; have_window_system ()
+%!testif HAVE_OPENGL, HAVE_FLTK; have_window_system () && any (strcmp ("fltk", available_graphics_toolkits ()))
 %! toolkit = graphics_toolkit ("fltk");
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h = findall (hf);
 %!   all_handles(1) = {"figure"};
 %!   all_handles(2:24,1) = {"uimenu"};
 %!   assert (get (h, "type"), all_handles);
 %! unwind_protect_cleanup
diff --git a/scripts/plot/util/graphics_toolkit.m b/scripts/plot/util/graphics_toolkit.m
--- a/scripts/plot/util/graphics_toolkit.m
+++ b/scripts/plot/util/graphics_toolkit.m
@@ -98,28 +98,28 @@ function retval = graphics_toolkit (name
     set (0, "defaultfigure__graphics_toolkit__", name);
   else
     set (hlist, "__graphics_toolkit__", name);
   endif
 
 endfunction
 
 
-%!testif HAVE_OPENGL, HAVE_FLTK; have_window_system ()
+%!testif HAVE_OPENGL, HAVE_FLTK; have_window_system () && any (strcmp ("fltk", available_graphics_toolkits ()))
 %! unwind_protect
 %!   hf = figure ("visible", "off");
 %!   toolkit = graphics_toolkit ();
 %!   assert (get (0, "defaultfigure__graphics_toolkit__"), toolkit);
 %!   graphics_toolkit (hf, "fltk");
 %!   assert (graphics_toolkit (hf), "fltk");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
-%!testif HAVE_OPENGL, HAVE_FLTK; have_window_system () && any (strcmp ("gnuplot", available_graphics_toolkits ()))
+%!testif HAVE_OPENGL, HAVE_FLTK; have_window_system () && any (strcmp ("gnuplot", available_graphics_toolkits ())) && any (strcmp ("fltk", available_graphics_toolkits ()))
 %! old_toolkit = graphics_toolkit ();
 %! switch (old_toolkit)
 %!   case {"gnuplot"}
 %!     new_toolkit = "fltk";
 %!   otherwise
 %!     new_toolkit = "gnuplot";
 %! endswitch
 %! assert (graphics_toolkit (new_toolkit), old_toolkit);
diff --git a/scripts/statistics/movmin.m b/scripts/statistics/movmin.m
--- a/scripts/statistics/movmin.m
+++ b/scripts/statistics/movmin.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2018-2019 Rik Wehbring
+## Copyright (C) 2018-2019 Juan Pablo Carbajal
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software: you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation, either version 3 of the License, or
 ## (at your option) any later version.
 ##
diff --git a/scripts/strings/erase.m b/scripts/strings/erase.m
--- a/scripts/strings/erase.m
+++ b/scripts/strings/erase.m
@@ -31,21 +31,23 @@
 ## erase ("Hello World!", " World")
 ##     @result{} "Hello!"
 ##
 ## ## cellstr, single pattern
 ## erase (@{"Hello", "World!"@}, "World")
 ##     @result{} @{"Hello", "!"@}
 ##
 ## ## string, multiple patterns
-## erase ("The Octave interpreter is fabulous", @{"interpreter ", "The "@})
+## erase ("The Octave interpreter is fabulous", ...
+##        @{"interpreter ", "The "@})
 ##     @result{} "Octave is fabulous"
 ##
 ## ## cellstr, multiple patterns
-## erase (@{"The ", "Octave interpreter ", "is fabulous"@}, @{"interpreter ", "The "@})
+## erase (@{"The ", "Octave interpreter ", "is fabulous"@}, ...
+##        @{"interpreter ", "The "@})
 ##     @result{} @{"", "Octave ", "is fabulous"@}
 ## @end group
 ## @end example
 ##
 ## Programming Note: @code{erase} deletes the first instance of a pattern in a
 ## string when there are overlapping occurrences.  For example:
 ##
 ## @example
diff --git a/scripts/strings/strsplit.m b/scripts/strings/strsplit.m
--- a/scripts/strings/strsplit.m
+++ b/scripts/strings/strsplit.m
@@ -82,25 +82,27 @@
 ##             [1,5] = c
 ##           @}
 ##
 ## @end example
 ##
 ## Examples with @nospell{regularexpression} delimiters:
 ##
 ## @smallexample
-## strsplit ("a foo b,bar c", ',|\s|foo|bar', "delimitertype", "regularexpression")
+## strsplit ("a foo b,bar c", ',|\s|foo|bar', ...
+##           "delimitertype", "regularexpression")
 ##       @result{}
 ##           @{
 ##             [1,1] = a
 ##             [1,2] = b
 ##             [1,3] = c
 ##           @}
 ##
-## strsplit ("a,,b, c", '[, ]', "collapsedelimiters", false, "delimitertype", "regularexpression")
+## strsplit ("a,,b, c", '[, ]', "collapsedelimiters", false, ...
+##           "delimitertype", "regularexpression")
 ##       @result{}
 ##           @{
 ##             [1,1] = a
 ##             [1,2] =
 ##             [1,3] = b
 ##             [1,4] =
 ##             [1,5] = c
 ##           @}
