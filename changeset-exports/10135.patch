# HG changeset patch
# User David Bateman <dbateman@free.fr>
# Date 1263952342 -3600
#      Wed Jan 20 02:52:22 2010 +0100
# Node ID 4516a0c97ced3b0037a8403dfa587e49c60ce0e1
# Parent  be13fa20656a7f332f237a3f480e1f0f24baca3d
Handle linestyleorder. Remove @ markers. Treat edgecolor, markeredgecolor and markerfacecolor correctly in scatter.

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,31 @@
+2010-01-20  David Bateman  <dbateman@free.fr>
+
+	* plot/__go_draw_axes__.m (next_marker):  Remove and all uses of
+	this function.
+	Partially respect the markeredgecolor and markerfacecolor properties.
+	* plot/private/__color__str_rgb__.m: New function
+	* plot/module.mk: Add it here.
+	* plot/__next_line_style__.m: New function selected next line style
+	using the axes linestyleorder property.
+	* plot/__next_line_color.m: Increment next line style here.
+	* plot/newplot.m: Reset next line style here.
+	* plot/module.mk: Add __next_line_style__.m here.
+	* plot/plot3.m: Use __next_line_style__ here.
+	* plot/private/plt.m: And here.
+	* plot/private/stem.m: And here.
+	* plot/private/scatter.m: And here. Correctly handle nargin == 3. Use
+	matlab compatible edgecolor, markeredgecolor and markerfacecolor
+	property values.
+	* plot/private/pltopt.m: Remove "@" marker as an option.
+	* plot/private/__default_plot_options__.m: Default plot options
+	are empty signalling that __next_line_color__ and
+	__next_line_style should be used.
+
 2010-01-19  Jaroslav Hajek  <highegg@gmail.com>
 
 	* general/structfun.m: Error when invalid options are specified.
 
 2010-01-19  Jaroslav Hajek  <highegg@gmail.com>, Thorsten Meyer <thorsten.meyier@gmx.de>
 
 	* general/structfun.m: Correctly support multiple arguments with
 	non-uniform output. Correct test for non-uniform output.
diff --git a/scripts/plot/__go_draw_axes__.m b/scripts/plot/__go_draw_axes__.m
--- a/scripts/plot/__go_draw_axes__.m
+++ b/scripts/plot/__go_draw_axes__.m
@@ -85,20 +85,16 @@ function __go_draw_axes__ (h, plot_strea
     ##         Presently, this is dispersed in this function.
     fputs (plot_stream, "unset label;\n");
     fputs (plot_stream, "unset xtics;\n");
     fputs (plot_stream, "unset ytics;\n");
     fputs (plot_stream, "unset ztics;\n");
     fputs (plot_stream, "unset x2tics;\n");
     fputs (plot_stream, "unset x2tics;\n");
 
-    # Reset next marker calculation
-    markerorder = axis_obj.markerorder;
-    next_marker (0);
-
     if (! isempty (axis_obj.title))
       t = get (axis_obj.title);
       if (isempty (t.string))
 	fputs (plot_stream, "unset title;\n");
       else
 	[tt, f, s] = __maybe_munge_text__ (enhanced, t, "string");
 	fontspec = create_fontspec (f, s, gnuplot_term);
 	fprintf (plot_stream, "set title \"%s\" %s %s",
@@ -522,17 +518,17 @@ function __go_draw_axes__ (h, plot_strea
 	    else
 	      data{data_idx} = [xdat, ydat]';
 	      usingclause{data_idx} = sprintf ("record=%d using ($1):($2) axes %s%s",
 					      rows(xdat), xaxisloc_using, yaxisloc_using);
 	    endif
 	  endif
 
 	  style = do_linestyle_command (obj, obj.color, data_idx, mono, 
-					plot_stream, markerorder, errbars);
+					plot_stream, errbars);
 
           withclause{data_idx} = sprintf ("with %s linestyle %d",
 					  style{1}, data_idx);
 
 	  if (length (style) > 1)
 	    data_idx++;
 	    is_image_data(data_idx) = is_image_data(data_idx - 1); 
 	    parametric(data_idx) = parametric(data_idx - 1);
@@ -723,51 +719,67 @@ function __go_draw_axes__ (h, plot_strea
              titlespec{data_idx} = "title \"\"";
 	     usingclause{data_idx} = sprintf ("record=%d", numel (obj.xdata));
 
 	     if (isfield (obj, "markersize"))
 	       mdat = obj.markersize / 3;
 	     endif
 
              if (isfield (obj, "edgecolor"))
-	       if ((strncmp (obj.edgecolor, "flat", 4)
-		    || strncmp (obj.edgecolor, "interp", 6))
+               ## FIXME
+               ## This is the wrong thing to do as edgecolor, markeredgecolor
+               ## and markerfacecolor can have different values and we should
+               ## treat them seperately. However, the below allow the scatter
+               ## functions to work as expected, where only one of these values
+               ## is set
+	       if (strncmp (obj.edgecolor, "none", 4))
+                 if (strncmp (obj.markeredgecolor, "none", 4))
+                   ec = obj.markerfacecolor;
+                 else
+                   ec = obj.markeredgecolor;
+                 endif
+               else
+                 ec = obj.edgecolor;
+               endif
+
+	       if ((strncmp (ec, "flat", 4)
+		    || strncmp (ec, "interp", 6))
 		   && isfield (obj, "cdata"))
 		 if (ndims (obj.cdata) == 2
 		     && (size (obj.cdata, 2) == nc
 			 && (size (obj.cdata, 1) == 1
 			     || size (obj.cdata, 1) == 3)))
 		   ccol = cdat (:, i);
 		 elseif (ndims (obj.cdata) == 2
 			 && (size (obj.cdata, 1) == nc
 			     && (size (obj.cdata, 2) == 1
 				 || size (obj.cdata, 2) == 3)))
 		   ccol = cdat (i, :);
 		 elseif (ndims (obj.cdata) == 3)
 		   ccol = permute (cdat (:, i, :), [1, 3, 2]);
 		 else
 		   ccol = cdat;
 		 endif
-		 if (strncmp (obj.edgecolor, "flat", 4))
+		 if (strncmp (ec, "flat", 4))
 		   if (numel(ccol) == 3)
 		     color = ccol;
 		   else
 		     r = 1 + round ((size (cmap, 1) - 1)
 				    * (ccol - clim(1))/(clim(2) - clim(1)));
 		     r = max (1, min (r, size (cmap, 1)));
 		     color = cmap(r, :);
 		   endif
-		 elseif (strncmp (obj.edgecolor, "interp", 6))
+		 elseif (strncmp (ec, "interp", 6))
 		   warning ("\"interp\" not supported, using 1st entry of cdata");
 		   r = 1 + round ((size (cmap, 1) - 1) * ccol(1));
 		   r = max (1, min (r, size (cmap, 1)));
 		   color = cmap(r,:);
 		 endif
-	       elseif (isnumeric (obj.edgecolor))
-		 color = obj.edgecolor;
+	       elseif (isnumeric (ec))
+		 color = ec;
 	       else
 		 color = [0, 0, 0];
 	       endif
              else
 	       color = [0, 0, 0];
              endif
 
 	     if (isfield (obj, "linestyle"))
@@ -793,18 +805,16 @@ function __go_draw_axes__ (h, plot_strea
 	       lw = sprintf("linewidth %f", obj.linewidth);
 	     else
 	       lw  = "";
 	     endif
 
 	     if (isfield (obj, "marker"))
 	       if (isfield (obj, "marker"))
 		 switch (obj.marker)
-                   case "@"
-                     [pt, pt2] = next_marker (markerorder);
 		   case "+"
 		     pt = pt2 = "pt 1";
 		   case "o"
 		     pt = "pt 6";
                      pt2 = "pt 7";
 		   case "*"
 		     pt = pt2 = "pt 3";
 		   case "."
@@ -838,17 +848,17 @@ function __go_draw_axes__ (h, plot_strea
 		     pt = pt2 = "pt 3";
 		   case "none"
 		     pt = pt2 = "";
 		   otherwise
 		     pt = pt2 = "";
 		 endswitch
 	       endif
 	     else
-	       pt = "";
+	       pt = pt2 = "";
 	     endif
 
 	     if (mono)
 	       colorspec = "";
 	     else
 	       colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
 				    round (255*color));
 	     endif
@@ -1026,17 +1036,17 @@ function __go_draw_axes__ (h, plot_strea
 		 && strncmp (obj.facecolor, "none", 4)))
 	    data_idx++;
 	    is_image_data(data_idx) = false;
 	    parametric(data_idx) = false;
 	    have_cdata(data_idx) = true;
 	    have_3d_patch(data_idx) = false;
 	    style = do_linestyle_command (obj, obj.edgecolor,
 					  data_idx, mono, 
-					  plot_stream, markerorder);
+					  plot_stream);
 	    if (isempty (obj.keylabel))
 	      titlespec{data_idx} = "title \"\"";
 	    else
 	      tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "keylabel"));
 	      titlespec{data_idx} = cstrcat ("title \"", tmp, "\"");
 	    endif
 	    withclause{data_idx} = sprintf ("with pm3d linestyle %d",
 		           		    data_idx);
@@ -1568,17 +1578,17 @@ function fontspec = create_fontspec (f, 
   if (strcmp (f, "*") || strcmp (gp_term, "tikz"))
     fontspec = sprintf ("font \",%d\"", s);
   else
     fontspec = sprintf ("font \"%s,%d\"", f, s);
   endif
 endfunction
 
 function style = do_linestyle_command (obj, linecolor, idx, mono,
-				       plot_stream, markerorder, errbars = "")
+				       plot_stream, errbars = "")
   style = {};
 
   fprintf (plot_stream, "set style line %d default;\n", idx);
   fprintf (plot_stream, "set style line %d", idx);
 
   found_style = false;
   if (isnumeric (linecolor))
     color = linecolor;
@@ -1628,18 +1638,16 @@ function style = do_linestyle_command (o
 
   if (isfield (obj, "linewidth"))
     fprintf (plot_stream, " linewidth %f", obj.linewidth);
     found_style = true;
   endif
 
   if (isfield (obj, "marker"))
     switch (obj.marker)
-      case "@"
-        [pt, pt2] = next_marker (markerorder);
       case "+"
 	pt = pt2 = "1";
       case "o"
 	pt = "6";
 	pt2 = "7";
       case "*"
 	pt = pt2 = "3";
       case "."
@@ -1694,19 +1702,19 @@ function style = do_linestyle_command (o
     
     facesame = true;
     if (! isequal (pt, pt2) && isfield (obj, "markerfacecolor") 
 	&& !strncmp (obj.markerfacecolor, "none", 4))
       if (strncmp (obj.markerfacecolor, "auto", 4)
 	  || ! isnumeric (obj.markerfacecolor) 
 	  || (isnumeric (obj.markerfacecolor) 
 	      && isequal (color, obj.markerfacecolor)))
-	style {sidx} = strcat (style{sidx}, "points");
 	if (! isempty (pt2))
 	  fprintf (plot_stream, " pointtype %s", pt2);
+	  style {sidx} = strcat (style{sidx}, "points");
 	endif
 	if (isfield (obj, "markersize"))
 	  fprintf (plot_stream, " pointsize %f", obj.markersize / 3);
 	endif
       else
 	facesame = false;
 	if (! found_style)
 	  fputs (plot_stream, " default");
@@ -1719,35 +1727,35 @@ function style = do_linestyle_command (o
 	  fputs (plot_stream, ";\n");
 	endif
 	fprintf (plot_stream, "set style line %d default;\n", idx);
 	fprintf (plot_stream, "set style line %d", idx);
 	if (isnumeric (obj.markerfacecolor) && ! mono)
 	  fprintf (plot_stream, " linecolor rgb \"#%02x%02x%02x\"",
 		   round (255*obj.markerfacecolor));
 	endif
-	style {sidx} = "points";
 	if (! isempty (pt2))
+	  style {sidx} = "points";
 	  fprintf (plot_stream, " pointtype %s", pt2);
 	endif
 	if (isfield (obj, "markersize"))
 	  fprintf (plot_stream, " pointsize %f", obj.markersize / 3);
 	endif
       endif
     endif
     if (isfield (obj, "markeredgecolor") 
 	&& !strncmp (obj.markeredgecolor, "none", 4))
       if (facesame && (strncmp (obj.markeredgecolor, "auto", 4)
 		       || ! isnumeric (obj.markeredgecolor) 
 		       || (isnumeric (obj.markeredgecolor) 
 			   && isequal (color, obj.markeredgecolor))))
 	if (sidx == 1 && ((length (style {sidx}) == 5 
 	    && strncmp (style {sidx}, "lines", 5)) || isempty (style {sidx})))
-	  style {sidx} = strcat (style{sidx}, "points");
 	  if (! isempty (pt))
+	    style {sidx} = strcat (style{sidx}, "points");
 	    fprintf (plot_stream, " pointtype %s", pt);
 	  endif
 	  if (isfield (obj, "markersize"))
 	    fprintf (plot_stream, " pointsize %f", obj.markersize / 3);
 	  endif
 	endif
       else
 	if (! found_style)
@@ -1766,18 +1774,18 @@ function style = do_linestyle_command (o
 	  if (strncmp (obj.markeredgecolor, "auto", 4))
 	    fprintf (plot_stream, " linecolor rgb \"#%02x%02x%02x\"",
 		     round (255*color));
 	  elseif (isnumeric (obj.markeredgecolor) && ! mono)
 	    fprintf (plot_stream, " linecolor rgb \"#%02x%02x%02x\"",
 		     round (255*obj.markeredgecolor));
 	  endif
 	endif
-	style {sidx} = "points";
 	if (! isempty (pt))
+	  style {sidx} = "points";
 	  fprintf (plot_stream, " pointtype %s", pt);
 	endif
 	if (isfield (obj, "markersize"))
 	  fprintf (plot_stream, " pointsize %f", obj.markersize / 3);
 	endif
       endif
     endif
   else
@@ -1787,67 +1795,16 @@ function style = do_linestyle_command (o
   if (! found_style && isempty (style {1}))
     fputs (plot_stream, " default");
   endif
 
   fputs (plot_stream, ";\n");
 
 endfunction
 
-function [pt, pt2] = next_marker (__set__)
-  persistent __next_marker__ = 0;
-
-  if (isnumeric (__set__))
-    __next_marker__ = __set__;
-  else
-
-    __marker__ = __set__ (rem (__next_marker__ ++, length (__set__)) + 1);
-    switch (__marker__)
-      case "+"
-	pt = pt2 = "1";
-      case "o"
-	pt = "6";
-	pt2 = "7";
-      case "*"
-	pt = pt2 = "3";
-      case "."
-	pt = pt2 = "0";
-      case "x"
-	pt = pt2 = "2";
-      case "s"
-	pt = "4";
-	pt2 = "5";
-      case "d"
-	pt = "13";
-	pt2 = "14";
-      case "^"
-	pt = "8";
-	pt2 = "9";
-      case "v"
-	pt = "10";
-	pt2 = "11";
-      case ">"
-	## FIXME missing point type 
-	pt = "8";
-	pt2 = "9";
-      case "<"
-	## FIXME missing point type 
-	pt = "10";
-	pt2 = "11";
-      case "p"
-	## FIXME missing point type 
-	pt = pt2 = "3";
-      case "h"
-	pt = pt2 = "3";
-      otherwise
-	pt = pt2 = "";
-    endswitch
-  endif
-endfunction
-
 function nd = __calc_dimensions__ (obj)
   kids = obj.children;
   nd = 2;
   for i = 1:length (kids)
     obj = get (kids(i));
     switch (obj.type)
       case {"image", "text"}
 	## ignore as they 
diff --git a/scripts/plot/__next_line_color__.m b/scripts/plot/__next_line_color__.m
--- a/scripts/plot/__next_line_color__.m
+++ b/scripts/plot/__next_line_color__.m
@@ -35,16 +35,17 @@ function rgb = __next_line_color__ (rese
     if (nargin == 1 && reset)
       color_rotation = get (gca (), "colororder");
       num_colors = rows (color_rotation);
       color_index = 1;
     elseif (! isempty (color_rotation))
       rgb = color_rotation(color_index,:);
       if (++color_index > num_colors)
 	color_index = 1;
+        __next_line_style__ ("incr");
       endif
     else
       error ("__next_line_color__: color_rotation not initialized");
     endif
   else
     print_usage ();
   endif
 
diff --git a/scripts/plot/__next_line_style__.m b/scripts/plot/__next_line_style__.m
new file mode 100644
--- /dev/null
+++ b/scripts/plot/__next_line_style__.m
@@ -0,0 +1,58 @@
+## Copyright (C) 2010 David Bateman
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {@var{style} =} __next_line_style__ (@var{reset})
+## Undocumented internal function.
+## @end deftypefn
+
+## Return the next line style in the rotation.
+
+
+function [linestyle, marker] = __next_line_style__ (reset)
+
+  persistent style_rotation;
+  persistent num_styles;
+  persistent style_index;
+
+  if (nargin < 2)
+    if (nargin == 1)
+      if (ischar (reset) && strncmp (reset, "incr", 4))
+        if (isempty (style_rotation))
+          error ("__next_line_style__: style_rotation not initialized");
+        elseif (++style_index > num_styles)
+	  style_index = 1;
+        endif
+      elseif (reset)
+        style_rotation = strsplit (get (gca (), "linestyleorder"), "|");
+        num_styles = length (style_rotation);
+        style_index = 1;
+      endif
+    elseif (! isempty (style_rotation))
+      options = __pltopt__ ("__next_line_style__", 
+                            style_rotation (style_index));
+      linestyle = options.linestyle;
+      marker = options.marker;   
+    else
+      error ("__next_line_style__: style_rotation not initialized");
+    endif
+  else
+    print_usage ();
+  endif
+
+endfunction
diff --git a/scripts/plot/module.mk b/scripts/plot/module.mk
--- a/scripts/plot/module.mk
+++ b/scripts/plot/module.mk
@@ -7,16 +7,17 @@ GEN_FCN_FILES += $(plot_GEN_FCN_FILES)
 
 plot_PRIVATE_FCN_FILES = \
   plot/private/__actual_axis_position__.m \
   plot/private/__add_datasource__.m \
   plot/private/__axes_limits__.m \
   plot/private/__axis_label__.m \
   plot/private/__bar__.m \
   plot/private/__clabel__.m \
+  plot/private/__color_str_rgb__.m \
   plot/private/__contour__.m \
   plot/private/__default_plot_options__.m \
   plot/private/__errcomm__.m \
   plot/private/__errplot__.m \
   plot/private/__ezplot__.m \
   plot/private/__interp_cube__.m \
   plot/private/__line__.m \
   plot/private/__patch__.m \
@@ -32,16 +33,17 @@ plot_FCN_FILES = \
   plot/__gnuplot_has_feature__.m \
   plot/__gnuplot_open_stream__.m \
   plot/__gnuplot_version__.m \
   plot/__go_close_all__.m \
   plot/__go_draw_axes__.m \
   plot/__go_draw_figure__.m \
   plot/__marching_cube__.m \
   plot/__next_line_color__.m \
+  plot/__next_line_style__.m \
   plot/__plt_get_axis_arg__.m \
   plot/allchild.m \
   plot/ancestor.m \
   plot/area.m \
   plot/axes.m \
   plot/axis.m \
   plot/backend.m \
   plot/bar.m \
diff --git a/scripts/plot/newplot.m b/scripts/plot/newplot.m
--- a/scripts/plot/newplot.m
+++ b/scripts/plot/newplot.m
@@ -22,16 +22,17 @@
 ## called at the beginning of all high-level plotting functions.
 ## It is not normally required in user programs.
 ## @end deftypefn
 
 function newplot ()
 
   if (nargin == 0)
     __next_line_color__ (true);
+    __next_line_style__ (true);
     cf = gcf ();
     fnp = get (cf, "nextplot");
     switch (fnp)
       ## FIXME -- probably we should do more than validate the nextplot
       ## property value...
       case "new"
       case "add"
       case "replacechildren"
diff --git a/scripts/plot/plot3.m b/scripts/plot/plot3.m
--- a/scripts/plot/plot3.m
+++ b/scripts/plot/plot3.m
@@ -172,25 +172,29 @@ function retval = plot3 (varargin)
       endif
 
       key = options.key;
       if (! isempty (key))
 	set (gca (), "key", "on");
       endif
 
       for i = 1 : columns (x)
+        linestyle = options.linestyle;
+        marker = options.marker;
+	if (isempty (marker) && isempty (linestyle))
+	   [linestyle, marker] = __next_line_style__ ();
+	endif
 	color = options.color;
 	if (isempty (options.color))
 	  color = __next_line_color__ ();
 	endif
 
 	tmp(++idx) = line (x(:, i), y(:, i), z(:, i),  "keylabel", key,
-			   "color", color,
-			   "linestyle", options.linestyle,
-			   "marker", options.marker, properties{:});
+			   "color", color, "linestyle", linestyle,
+			   "marker", marker, properties{:});
       endfor
 
       x_set = 0;
       y_set = 0;
       z_set = 0;
       fmt_set = 0;
       properties = {};
     elseif (! x_set)
@@ -221,25 +225,29 @@ function retval = plot3 (varargin)
 
       options =  __default_plot_options__ ();
       key = options.key;
       if (! isempty (key))
 	set (gca (), "key", "on");
       endif
 
       for i = 1 : columns (x)
+        linestyle = options.linestyle;
+        marker = options.marker;
+	if (isempty (marker) && isempty (linestyle))
+	   [linestyle, marker] = __next_line_style__ ();
+	endif
 	color = options.color;
 	if (isempty (color))
 	  color = __next_line_color__ ();
 	endif
 
 	tmp(++idx) = line (x(:, i), y(:, i), z(:, i),  "keylabel", key,
-			   "color", color,
-			   "linestyle", options.linestyle,
-			   "marker", options.marker, properties{:});
+			   "color", color, "linestyle", linestyle,
+			   "marker", marker, properties{:});
       endfor
 
       x = new;
       y_set = 0;
       z_set = 0;
       fmt_set = 0;
       properties = {};
     endif
@@ -289,25 +297,29 @@ function retval = plot3 (varargin)
 
     options =  __default_plot_options__ ();
     key = options.key;
     if (! isempty (key))
       set (gca (), "key", "on");
     endif
 
     for i = 1 : columns (x)
+      linestyle = options.linestyle;
+      marker = options.marker;
+      if (isempty (marker) && isempty (linestyle))
+	[linestyle, marker] = __next_line_style__ ();
+      endif
       color = options.color;
       if (isempty (color))
 	color = __next_line_color__ ();
       endif
 
       tmp(++idx) = line (x(:, i), y(:, i), z(:, i),  "keylabel", key, 
-			 "color", color,
-			 "linestyle", options.linestyle,
-			 "marker", options.marker, properties{:});
+			 "color", color, "linestyle", linestyle,
+			 "marker", marker, properties{:});
     endfor
   endif
 
   set (gca (), "view", [-37.5, 30]);
 
   if (nargout > 0 && idx > 0)
     retval = tmp;
   endif
diff --git a/scripts/plot/private/__color_str_rgb__.m b/scripts/plot/private/__color_str_rgb__.m
new file mode 100644
--- /dev/null
+++ b/scripts/plot/private/__color_str_rgb__.m
@@ -0,0 +1,50 @@
+## Copyright (C) 2010 David Bateman
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {@var{rgb} =} __scatter__ (@var{str})
+## Undocumented internal function.
+## @end deftypefn
+
+function rgb = __color_str_rgb__ (str)
+
+  if (ischar (str))
+    if (strncmpi (str, "black", 5))
+      rgb = [0, 0, 0];
+    elseif (strncmpi (str, "red", 3))
+      rgb = [1, 0, 0];
+    elseif (strncmpi (str, "green", 5))
+      rgb = [0, 1, 0];
+    elseif (strncmpi (str, "blue", 4))
+      rgb = [0, 0, 1];
+
+    elseif (strncmpi (str, "yellow", 6))
+      rgb = [1, 1, 0];
+    elseif (strncmpi (str, "magenta", 7))
+      rgb = [1, 0, 1];
+    elseif (strncmpi (str, "cyan", 4))
+      rgb = [0, 1, 1];
+    elseif (strncmpi (str, "white", 5))
+      rgb = [1, 1, 1];
+    else
+      rgb = [0, 0, 0];
+    endif
+  else
+    error ("expecting a string argument");
+  endif
+endfunction
diff --git a/scripts/plot/private/__default_plot_options__.m b/scripts/plot/private/__default_plot_options__.m
--- a/scripts/plot/private/__default_plot_options__.m
+++ b/scripts/plot/private/__default_plot_options__.m
@@ -22,12 +22,12 @@
 ## @end deftypefn
 
 ## Author: jwe
 
 function options = __default_plot_options__ ()
 
   options.key = "";
   options.color = [];
-  options.linestyle = "-";
-  options.marker = "none";
+  options.linestyle = [];
+  options.marker = [];
 
 endfunction
diff --git a/scripts/plot/private/__plt__.m b/scripts/plot/private/__plt__.m
--- a/scripts/plot/private/__plt__.m
+++ b/scripts/plot/private/__plt__.m
@@ -241,24 +241,29 @@ function retval = __plt2mm__ (h, x, y, o
 	options = repmat (options(:), x_nc, 1);
       endif
       retval = zeros (x_nc, 1);
       for i = 1:x_nc
 	tkey = options(i).key;
 	if (! isempty (tkey))
 	  set (h, "key", "on");
 	endif
+        linestyle = options(i).linestyle;
+        marker = options(i).marker;
+	if (isempty (marker) && isempty (linestyle))
+	   [linestyle, marker] = __next_line_style__ ();
+	endif
 	color = options(i).color;
 	if (isempty (color))
 	  color = __next_line_color__ ();
 	endif
 
 	retval(i) = line (x(:,i), y(:,i), "keylabel", tkey, "color", color,
-			  "linestyle", options(i).linestyle,
-			  "marker", options(i).marker, properties{:});
+			  "linestyle", linestyle,
+			  "marker", marker, properties{:});
       endfor
     else
       error ("__plt2mm__: arguments must be a matrices");
     endif
   else
     error ("__plt2mm__: matrix dimensions must match");
   endif
 
@@ -304,24 +309,29 @@ function retval = __plt2mv__ (h, x, y, o
       options = repmat (options(:), x_nc, 1);
     endif
     retval = zeros (x_nc, 1);
     for i = 1:x_nc
       tkey = options(i).key;
       if (! isempty (tkey))
 	set (h, "key", "on");
       endif
+      linestyle = options(i).linestyle;
+      marker = options(i).marker;
+      if (isempty (marker) && isempty (linestyle))
+	[linestyle, marker] = __next_line_style__ ();
+      endif
       color = options(i).color;
       if (isempty (color))
 	color = __next_line_color__ ();
       endif
 
       retval(i) = line (x(:,i), y, "keylabel", tkey, "color", color,
-			"linestyle", options(i).linestyle,
-			"marker", options(i).marker, properties{:});
+			"linestyle", linestyle,
+			"marker", marker, properties{:});
     endfor
   else
     error ("__plt2mv__: arguments must be a matrices");
   endif
 
 endfunction
 
 function retval = __plt2ss__ (h, x, y, options, properties)
@@ -345,24 +355,29 @@ function retval = __plt2ss__ (h, x, y, o
   [x_nr, x_nc] = size (x);
   [y_nr, y_nc] = size (y);
 
   if (x_nr == 1 && x_nr == y_nr && x_nc == 1 && x_nc == y_nc)
     key = options.key;
     if (! isempty (key))
       set (h, "key", "on");
     endif
+    linestyle = options.linestyle;
+    marker = options.marker;
+    if (isempty (marker) && isempty (linestyle))
+      [linestyle, marker] = __next_line_style__ ();
+    endif
     color = options.color;
     if (isempty (color))
       color = __next_line_color__ ();
     endif
 
     retval = line (x, y, "keylabel", key, "color", color,
-		   "linestyle", options.linestyle,
-		   "marker", options.marker, properties{:});
+		   "linestyle", linestyle,
+		   "marker", marker, properties{:});
   else
     error ("__plt2ss__: arguments must be scalars");
   endif
 
 endfunction
 
 function retval = __plt2sv__ (h, x, y, options, properties)
 
@@ -384,24 +399,29 @@ function retval = __plt2sv__ (h, x, y, o
       options = repmat (options(:), len, 1);
     endif
     retval = zeros (len, 1);
     for i = 1:len
       tkey = options(i).key;
       if (! isempty (tkey))
 	set (h, "key", "on");
       endif
+      linestyle = options(i).linestyle;
+      marker = options(i).marker;
+      if (isempty (marker) && isempty (linestyle))
+        [linestyle, marker] = __next_line_style__ ();
+      endif
       color = options(i).color;
       if (isempty (color))
 	color = __next_line_color__ ();
       endif
 
       retval(i) = line (x, y(i), "keylabel", tkey, "color", color,
-			"linestyle", options(i).linestyle,
-			"marker", options(i).marker, properties{:});
+			"linestyle", linestyle,
+			"marker", marker, properties{:});
     endfor
   else
     error ("__plt2sv__: first arg must be scalar, second arg must be vector");
   endif
 
 endfunction
 
 function retval = __plt2vm__ (h, x, y, options, properties)
@@ -444,24 +464,29 @@ function retval = __plt2vm__ (h, x, y, o
       options = repmat (options(:), y_nc, 1);
     endif
     retval = zeros (y_nc, 1);
     for i = 1:y_nc
       tkey = options(i).key;
       if (! isempty (tkey))
 	set (h, "key", "on");
       endif
+      linestyle = options(i).linestyle;
+      marker = options(i).marker;
+      if (isempty (marker) && isempty (linestyle))
+        [linestyle, marker] = __next_line_style__ ();
+      endif
       color = options(i).color;
       if (isempty (color))
 	color = __next_line_color__ ();
       endif
 
       retval(i) = line (x, y(:,i), "keylabel", tkey, "color", color,
-			"linestyle", options(i).linestyle,
-			"marker", options(i).marker, properties{:});
+			"linestyle", linestyle,
+			"marker", marker, properties{:});
     endfor
   else
     error ("__plt2vm__: arguments must be a matrices");
   endif
 
 endfunction
 
 function retval = __plt2vs__ (h, x, y, options, properties)
@@ -484,24 +509,29 @@ function retval = __plt2vs__ (h, x, y, o
       options = repmat (options(:), len, 1);
     endif
     retval = zeros (len, 1);
     for i = 1:len
       tkey = options(i).key;
       if (! isempty (tkey))
 	set (h, "key", "on");
       endif
+      linestyle = options(i).linestyle;
+      marker = options(i).marker;
+      if (isempty (marker) && isempty (linestyle))
+        [linestyle, marker] = __next_line_style__ ();
+      endif
       color = options(i).color;
       if (isempty (color))
 	color = __next_line_color__ ();
       endif
 
       retval(i) = line (x(i), y, "keylabel", tkey, "color", color,
-			"linestyle", options(i).linestyle,
-			"marker", options(i).marker, properties{:});
+			"linestyle", linestyle,
+			"marker", marker, properties{:});
     endfor
   else
     error ("__plt2vs__: first arg must be vector, second arg must be scalar");
   endif
 
 endfunction
 
 function retval = __plt2vv__ (h, x, y, options, properties)
@@ -539,21 +569,26 @@ function retval = __plt2vv__ (h, x, y, o
     y_nc = tmp;
   endif
 
   if (x_nr == y_nr)
     key = options.key;
     if (! isempty (key))
       set (h, "key", "on");
     endif
+    linestyle = options.linestyle;
+    marker = options.marker;
+    if (isempty (marker) && isempty (linestyle))
+      [linestyle, marker] = __next_line_style__ ();
+    endif
     color = options.color;
     if (isempty (color))
       color = __next_line_color__ ();
     endif
 
     retval = line (x, y, "keylabel", key, "color", color,
-	      "linestyle", options.linestyle,
-	      "marker", options.marker, properties{:});
+	      "linestyle", linestyle,
+	      "marker", marker, properties{:});
   else
     error ("__plt2vv__: vector lengths must match");
   endif
 
 endfunction
diff --git a/scripts/plot/private/__pltopt__.m b/scripts/plot/private/__pltopt__.m
--- a/scripts/plot/private/__pltopt__.m
+++ b/scripts/plot/private/__pltopt__.m
@@ -150,19 +150,19 @@ function [options, valid] = __pltopt1__ 
     if (strncmp (opt, "#~>", 3))
       n = 3;
     elseif (strncmp (opt, "#~", 2) || strncmp (opt, "~>", 2))
       n = 2;
     elseif (strncmp (opt, "~", 1) || strncmp (opt, ">", 1) 
 	    || strncmp (opt, "#", 1))
       n = 1;
     endif
-      options.linestyle = opt(1:n);
-      opt(1:n) = [];
-      have_linestyle = true;
+    options.linestyle = opt(1:n);
+    opt(1:n) = [];
+    have_linestyle = true;
   endif
 
   while (! isempty (opt))
     if (strncmp (opt, "--", 2) || strncmp (opt, "-.", 2))
       options.linestyle = opt(1:2);
       have_linestyle = true;
       n = 2;
     else
@@ -172,16 +172,20 @@ function [options, valid] = __pltopt1__ 
 	have_linestyle = true;
 	options.linestyle = topt;
       elseif (topt == "+" || topt == "o" || topt == "*"
 	      || topt == "." || topt == "x" || topt == "s"
 	      || topt == "d" || topt == "^" || topt == "v"
 	      || topt == ">" || topt == "<" || topt == "p"
 	      || topt == "h" || topt == "@")
 	have_marker = true;
+        ## Backward compatibility.  Leave undocumented.
+	if (topt == "@")
+	  topt = "+";
+	endif
 	options.marker = topt;
 ### Numeric color specs for backward compatibility.  Leave undocumented.
       elseif (topt == "k" || topt == "0")
 	options.color = [0, 0, 0];
       elseif (topt == "r" || topt == "1")
 	options.color = [1, 0, 0];
       elseif (topt == "g" || topt == "2")
 	options.color = [0, 1, 0];
@@ -219,13 +223,17 @@ function [options, valid] = __pltopt1__ 
 	  options = __default_plot_options__ ();
 	  return;
 	endif
       endif
     endif
     opt(1:n) = [];
   endwhile
 
-  if (have_marker && ! have_linestyle)
+  if (! have_linestyle && have_marker)
     options.linestyle = "none";
   endif
 
+  if (have_linestyle && ! have_marker)
+    options.marker = "none";
+  endif
+
 endfunction
diff --git a/scripts/plot/private/__scatter__.m b/scripts/plot/private/__scatter__.m
--- a/scripts/plot/private/__scatter__.m
+++ b/scripts/plot/private/__scatter__.m
@@ -47,39 +47,37 @@ function hg = __scatter__ (varargin)
   firstnonnumeric = Inf;
   for i = istart:nargin
     if (! isnumeric (varargin{i}))
       firstnonnumeric = i;
       break;
     endif
   endfor
 
-  if (istart < nargin && firstnonnumeric > istart)
+  if (istart <= nargin)
     s = varargin{istart};
     if (isempty (s))
       s = 6;
     endif
   else
     s = 6;
   endif
 
   if (istart < nargin && firstnonnumeric > istart + 1)
     c = varargin{istart + 1};
     if (isvector (c))
       if (columns (c) != 3)
 	c = c(:);
       endif
-    elseif (isempty (c))
-      c = __next_line_color__();
     endif
   elseif (firstnonnumeric == istart + 1 && ischar (varargin{istart + 1}))
     c = varargin{istart + 1};
     firstnonnumeric++;
   else
-    c = __next_line_color__();
+    c = [];
   endif
 
   newargs = {};
   filled = false;
   have_marker = false;
   marker = "o";
   iarg = firstnonnumeric;
   while (iarg <= nargin)
@@ -88,124 +86,155 @@ function hg = __scatter__ (varargin)
       filled = true;
     elseif ((ischar (arg) || iscell (arg)) && ! have_marker)
       [linespec, valid] = __pltopt__ (fcn, arg, false);
       if (valid)
 	have_marker = true;
 	marker = linespec.marker;
 	if (strncmp (marker, "none", 4))
 	  marker = "o";
+        elseif (isempty (marker))
+          [dummy, marker] = __next_line_style__ ();
 	endif
       else
 	error ("%s: invalid linespec", fcn);
       endif
     else
       newargs{end+1} = arg;
       if (iarg <= nargin)
 	newargs{end+1} = varagin{iarg++};
       endif
     endif
   endwhile
 
+  if (isempty (c))
+    c = __next_line_color__();
+  endif
+
   hg = hggroup ();
   newargs = __add_datasource__ (fcn, hg, {"x", "y", "z", "c", "size"}, 
 			     newargs{:});
 
   addproperty ("xdata", hg, "data", x);
   addproperty ("ydata", hg, "data", y);
   addproperty ("zdata", hg, "data", z);
-  addproperty ("cdata", hg, "data", c);
+  if (ischar (c))
+    addproperty ("cdata", hg, "data", __color_str_rgb__ (c));
+  else
+    addproperty ("cdata", hg, "data", c);
+  endif
   addproperty ("sizedata", hg, "data", s);
   addlistener (hg, "xdata", @update_data);
   addlistener (hg, "ydata", @update_data);
   addlistener (hg, "zdata", @update_data);
   addlistener (hg, "cdata", @update_data);
   addlistener (hg, "sizedata", @update_data);
 
   if (numel (x) <= 100)
 
     ## For small number of points, we'll construct an object for each point.
 
     if (numel (s) == 1)
       s = repmat (s, numel(x), 1);
     endif
 
-    if (ischar (c))
+    if (ischar (c) || rows(c) == 1)
       for i = 1 : numel (x)
-        h = __go_patch__ (hg, "xdata", x(i), "ydata", y(i), "zdata", z(i,:),
-                          "faces", 1, "vertices", [x(i), y(i), z(i,:)], 
-                          "facecolor", "none", "edgecolor", c, "marker", marker, 
-                          "markersize", s(i), "linestyle", "none");
         if (filled)
-          set(h, "markerfacecolor", c); 
+          h = __go_patch__ (hg, "xdata", x(i), "ydata", y(i), "zdata", z(i,:),
+                            "faces", 1, "vertices", [x(i), y(i), z(i,:)], 
+                            "facecolor", "none", "edgecolor", "none", 
+                            "marker", marker,  "markersize", s(i), 
+                            "markeredgecolor", none, "markerfacecolor", c,
+                            "linestyle", "none");
+        else
+          h = __go_patch__ (hg, "xdata", x(i), "ydata", y(i), "zdata", z(i,:),
+                            "faces", 1, "vertices", [x(i), y(i), z(i,:)], 
+                            "facecolor", "none", "edgecolor", "none", 
+                            "marker", marker,  "markersize", s(i), 
+                            "markeredgecolor", c, "markerfacecolor", "none",
+                            "linestyle", "none");
         endif
       endfor
     else
-      if (rows (c) == 1)
-        c = repmat (c, numel (x), 1);
-      endif
+      for i = 1 : numel (x)
+        if (filled)
+          h = __go_patch__ (hg, "xdata", x(i), "ydata", y(i), "zdata", z(i,:),
+                            "faces", 1, "vertices", [x(i), y(i), z(i,:)], 
+                            "facecolor", "none", "edgecolor", "none", 
+                            "marker", marker, "markersize", s(i), 
+                            "markeredgecolor", "none", 
+                            "markerfacecolor", "flat",
+                            "cdata", c(i,:), "linestyle", "none");
+        else
+          h = __go_patch__ (hg, "xdata", x(i), "ydata", y(i), "zdata", z(i,:),
+                            "faces", 1, "vertices", [x(i), y(i), z(i,:)], 
+                            "facecolor", "none", "edgecolor", "none", 
+                            "marker", marker, "markersize", s(i), 
+                            "markeredgecolor", "flat", 
+                            "markerfacecolor", "none",
+                            "cdata", c(i,:), "linestyle", "none");
 
-      for i = 1 : numel (x)
-        h = __go_patch__ (hg, "xdata", x(i), "ydata", y(i), "zdata", z(i,:),
-                          "faces", 1, "vertices", [x(i), y(i), z(i,:)], 
-                          "facecolor", "none", "edgecolor", "flat", 
-                          "cdata", c(i,:), 
-                          "marker", marker, "markersize", s(i), 
-                          "linestyle", "none");
-        if (filled)
-          set(h, "markerfacecolor", "flat"); 
         endif
       endfor
     endif
 
   else
 
     ## For larger numbers of points, we split the points by common color.
 
     vert = [x, y, z];
 
     if (ischar (c) || rows (c) == 1)
-      h = render_size_color (hg, vert, s, c, marker, filled); 
+      h = render_size_color (hg, vert, s, c, marker, filled, false); 
     else
       [cc, idx] = unique_idx (c, "rows");
       if (isscalar (s))
         for i = 1:rows (x)
-          h = render_size_color (hg, vert(idx{i},:), s, cc(i,:), marker, filled);
+          h = render_size_color (hg, vert(idx{i},:), s, cc(i,:), 
+                                 marker, filled, true);
         endfor
       else
         for i = 1:rows (x)
-          h = render_size_color (hg, vert(idx{i},:), s(idx{i}), cc(i,:), marker, filled);
+          h = render_size_color (hg, vert(idx{i},:), s(idx{i}), cc(i,:), 
+                                 marker, filled, true);
         endfor
       endif
     endif
 
   endif
 
-    if (! ischar (c))
-      ax = get (hg, "parent");
-      clim = get (ax, "clim");
-      if (min(c(:)) < clim(1))
-        clim(1) = min(c(:));
-        set (ax, "clim", clim);
-      endif
-      if (max(c(:)) > clim(2))
-        set (ax, "clim", [clim(1), max(c(:))]);
-      endif
+  if (! ischar (c) && rows (c) > 1)
+    ax = get (hg, "parent");
+    clim = get (ax, "clim");
+    if (min(c(:)) < clim(1))
+      clim(1) = min(c(:));
+      set (ax, "clim", clim);
     endif
+    if (max(c(:)) > clim(2))
+      set (ax, "clim", [clim(1), max(c(:))]);
+    endif
+  endif
 
   addproperty ("linewidth", hg, "patchlinewidth", 0.5);
   addproperty ("marker", hg, "patchmarker", marker);
-  if (numel (x) > 0)
-    addproperty ("markerfacecolor", hg, "patchmarkerfacecolor", "none");
+  if (filled)
     addproperty ("markeredgecolor", hg, "patchmarkeredgecolor", "none");
+    if (ischar (c) || rows (c) == 1)
+      addproperty ("markerfacecolor", hg, "patchmarkerfacecolor", c);
+    else
+      addproperty ("markerfacecolor", hg, "patchmarkerfacecolor", "flat");
+    endif
   else
-    addproperty ("markerfacecolor", hg, "patchmarkerfacecolor", 
-		 get (h, "markerfacecolor"));
-    addproperty ("markeredgecolor", hg, "patchmarkeredgecolor",
-		 get (h, "color"));
+    addproperty ("markerfacecolor", hg, "patchmarkerfacecolor", "none");
+    if (ischar (c) || rows (c) == 1)
+      addproperty ("markeredgecolor", hg, "patchmarkeredgecolor", c);
+    else
+      addproperty ("markeredgecolor", hg, "patchmarkeredgecolor", "flat");
+    endif
   endif
   addlistener (hg, "linewidth", @update_props); 
   addlistener (hg, "marker", @update_props); 
   addlistener (hg, "markerfacecolor", @update_props); 
   addlistener (hg, "markeredgecolor", @update_props);
 
   if (! isempty (newargs))
     set (hg, newargs{:})
@@ -230,45 +259,64 @@ function [y, idx] =  unique_idx (x, byro
 
   if (nargin == 2 || columns (x) == 1)
     idx = mat2cell (idx, diff ([0; jdx]), 1);
   else
     idx = mat2cell (idx, 1, diff ([0, jdx]));
   endif
 endfunction
 
-function h = render_size_color(hg, vert, s, c, marker, filled)
+function h = render_size_color(hg, vert, s, c, marker, filled, isflat)
   if (isscalar (s))
     x = vert(:,1);
     y = vert(:,2);
     z = vert(:,3:end);
-    if (ischar (c))
-      h = __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
-                        "faces", 1, "vertices", vert, 
-                        "facecolor", "none", "edgecolor", c, "marker", marker, 
-                        "markersize", s, "linestyle", "none");
+    if (ischar (c) || !isflat)
       if (filled)
-        set(h, "markerfacecolor", c); 
+        h = __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
+                          "faces", 1, "vertices", vert, 
+                          "facecolor", "none", "edgecolor", "none", 
+                          "marker", marker, 
+                          "markeredgecolor", "none", 
+                          "markerfacecolor", c,
+                          "markersize", s, "linestyle", "none");
+      else
+        h = __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
+                          "faces", 1, "vertices", vert, 
+                          "facecolor", "none", "edgecolor", "none", 
+                          "marker", marker, 
+                          "markeredgecolor", c, 
+                          "markerfacecolor", "none",
+                          "markersize", s, "linestyle", "none");
       endif
     else
-      h = __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
-                        "faces", 1, "vertices", vert, 
-                        "facecolor", "none", "edgecolor", "flat", 
-                        "cdata", c, 
-                        "marker", marker, "markersize", s, 
-                        "linestyle", "none");
       if (filled)
-        set(h, "markerfacecolor", "flat"); 
+        h = __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
+                          "faces", 1, "vertices", vert,
+                          "facecolor", "none", "edgecolor", "none", 
+                          "marker", marker, "markersize", s, 
+                          "markeredgecolor", "none", 
+                          "markerfacecolor", "flat",
+                          "cdata", c, "linestyle", "none");
+      else
+        h = __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
+                          "faces", 1, "vertices", vert,
+                          "facecolor", "none", "edgecolor", "none", 
+                          "marker", marker, "markersize", s, 
+                          "markeredgecolor", "flat", 
+                          "markerfacecolor", "none",
+                          "cdata", c, "linestyle", "none");
       endif
     endif
   else
     ## FIXME: round the size to one decimal place. It's not quite right, though.
     [ss, idx] = unique_idx (ceil (s*10) / 10);
     for i = 1:rows (ss)
-      h = render_size_color (hg, vert(idx{i},:), ss(i), c, marker, filled);
+      h = render_size_color (hg, vert(idx{i},:), ss(i), c, 
+                             marker, filled, isflat);
     endfor
   endif
 endfunction
 
 function update_props (h, d)
   lw = get (h, "linewidth");
   m = get (h, "marker");
   fc = get (h, "markerfacecolor");
diff --git a/scripts/plot/private/__stem__.m b/scripts/plot/private/__stem__.m
--- a/scripts/plot/private/__stem__.m
+++ b/scripts/plot/private/__stem__.m
@@ -438,18 +438,24 @@ function [lc, ls, mc, ms] = stem_line_sp
   [lc, ls, mc, ms] = set_default_values ();
   ## Parse the line specifier string.
   cur_props = __pltopt__ ("stem", str, false);
   for i = 1:length(cur_props)
     if (isfield (cur_props(i), "color") && ! isempty (cur_props(i).color)); # means line color
       mc = lc = cur_props(i).color;
     elseif (isfield (cur_props(i), "linestyle"))
       ls = cur_props(i).linestyle;
+      if (isempty (ls))
+        ls = __next_line_style__ ();
+      endif
     elseif (isfield (cur_props(i), "marker") && ! strcmpi (cur_props(i).marker, "none"))
       ms = cur_props(i).marker;
+      if (isempty (ms))
+        [dummy, ms] = __next_line_style__ ();
+      endif
     endif
   endfor
 endfunction
 
 function [lc, ls, mc, ms] = set_default_values ()
   ## set default values
   mc = [];
   lc = [];
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,15 @@
+2010-01-20  David Bateman  <dbateman@free.fr>
+
+	* graphics.h.in (string_array_property): New property.
+	(axes::properties): Use it here for the linestyleorder property.
+	Remove the markerorder property.
+	* genprops.awk: Emit string_array_property
+
 2010-01-19  Jaroslav Hajek  <highegg@gmail.com>
 
 	* DLD-FUNCTIONS/strfind.cc: Optimize searching for 1 or 2 characters.
 
 2010-01-18  John W. Eaton  <jwe@octave.org>
 
 	* oct-parse.yy (fcn_end): Allow EOF as end of function if
 	reading from eval string.
diff --git a/src/genprops.awk b/src/genprops.awk
--- a/src/genprops.awk
+++ b/src/genprops.awk
@@ -295,16 +295,18 @@ function emit_declarations ()
     if (emit_get[i])
     {
       if (type[i] == "any_property")
         emit_get_accessor(i, "octave_value", "get");
       else if (type[i] == "handle_property")
         emit_get_accessor(i, "graphics_handle", "handle_value");
       else if (type[i] == "string_property")
         emit_get_accessor(i, "std::string", "string_value");
+      else if (type[i] == "string_array_property")
+          emit_get_accessor(i, "octave_value", "get");
       else if (type[i] == "double_property")
         emit_get_accessor(i, "double", "double_value");
       else if (type[i] == "double_radio_property")
         emit_get_double_radio(i);
       else if (type[i] == "array_property" \
 	       || type[i] == "row_vector_property")
         emit_get_array(i);
       else if (type[i] == "bool_property")
diff --git a/src/graphics.h.in b/src/graphics.h.in
--- a/src/graphics.h.in
+++ b/src/graphics.h.in
@@ -509,16 +509,176 @@ protected:
     }
 
 private:
   std::string str;
 };
 
 // ---------------------------------------------------------------------
 
+class string_array_property : public base_property
+{
+public:
+  enum desired_enum { string_t, cell_t };
+
+  string_array_property (const std::string& s, const graphics_handle& h,
+		  const std::string& val = "", const char& sep = '|', 
+		  const desired_enum& typ = string_t)
+    : base_property (s, h), desired_type (typ), separator (sep)
+    { 
+      size_t pos = 0;
+
+      while (true)
+	{
+	  size_t new_pos = val.find_first_of (separator, pos);
+
+	  if (new_pos == std::string::npos)
+	    {
+	      str.append (val.substr (pos));
+	      break;
+	    }
+	  else
+	    str.append (val.substr (pos, new_pos - pos));
+
+	  pos = new_pos + 1;
+	}
+    }
+
+  string_array_property (const std::string& s, const graphics_handle& h, 
+		  const Cell& c, const char& sep = '|', 
+		  const desired_enum& typ = string_t)
+    : base_property (s, h), desired_type (typ), separator (sep)
+    { 
+      if (c.is_cellstr ())
+	{
+	  string_vector strings (c.numel ());
+
+	  for (octave_idx_type i = 0; i < c.numel (); i++)
+	    strings (i) = c(i).string_value ();
+
+	  str = strings;
+	}
+      else
+        error ("set: invalid order property value for \"%s\"",
+               get_name ().c_str ());
+    }
+
+  string_array_property (const string_array_property& p)
+    : base_property (p), desired_type (p.desired_type),
+      separator (p.separator), str (p.str) { }
+
+  octave_value get (void) const
+    { 
+      if (desired_type == string_t)
+	return octave_value (string_value ());
+      else
+	return octave_value (cell_value ());
+    }
+
+  std::string string_value (void) const 
+    { 
+      std::string _str;
+
+      for (octave_idx_type i = 0; i < str.length (); i++)
+	{
+	  _str += str(i);
+	  if (i != str.length() - 1)
+	    _str += separator;
+	}
+
+      return _str;
+    }
+
+  Cell cell_value (void) const {return Cell (str);}
+
+  string_array_property& operator = (const octave_value& val)
+    {
+      set (val);
+      return *this;
+    }
+
+  base_property* clone (void) const { return new string_array_property (*this); }
+
+protected:
+  bool do_set (const octave_value& val)
+    {
+      if (val.is_string ())
+	{
+	  bool replace = false;
+	  std::string new_str = val.string_value ();
+	  string_vector strings;
+	  size_t pos = 0;
+
+	  while (pos != std::string::npos)
+	    {
+	      size_t new_pos = new_str.find_first_of (separator, pos);
+
+	      if (new_pos == std::string::npos)
+		{
+		  strings.append (new_str.substr (pos));
+		  break;
+		}
+	      else
+		strings.append (new_str.substr (pos, new_pos - pos));
+
+	      pos = new_pos + 1;
+	    }
+
+	  if (str.numel () == strings.numel ())
+	    {
+	      for (octave_idx_type i = 0; i < str.numel (); i++)
+		if (strings (i) != str(i))
+		  {
+		    replace = true;
+		    break;
+		  }
+	    }
+	  else
+	    replace = true;
+
+	  if (replace)
+	    {
+	      str = strings;
+	      return true;
+	    }
+	}
+      else if (val.is_cellstr ())
+	{
+	  bool replace = false;
+	  Cell new_cell = val.cell_value ();
+
+	  string_vector strings (new_cell.numel ());
+
+	  for (octave_idx_type i = 0; i < new_cell.numel (); i++)
+	    {
+	      strings (i) = new_cell(i).string_value ();
+	      if (strings (i) != str (i))
+		replace = true;
+	    }
+
+	  if (replace)
+	    {
+	      str = strings;
+	      return true;
+	    }
+	}
+      else
+        error ("set: invalid string property value for \"%s\"",
+               get_name ().c_str ());
+      return false;
+    }
+
+private:
+  desired_enum desired_type;
+  char separator;
+  string_vector str;
+};
+
+// ---------------------------------------------------------------------
+
 class radio_values
 {
 public:
   OCTINTERP_API radio_values (const std::string& opt_string = std::string ());
 
   radio_values (const radio_values& a)
     : default_val (a.default_val), possible_vals (a.possible_vals) { }
 
@@ -2756,21 +2916,18 @@ public:
       array_property currentpoint , Matrix (2, 3, 0.0)
       radio_property drawmode , "{normal}|fast"
       radio_property fontangle , "{normal}|italic|oblique"
       string_property fontname , OCTAVE_DEFAULT_FONTNAME
       double_property fontsize , 12
       radio_property fontunits , "{points}|normalized|inches|centimeters|pixels"
       radio_property fontweight , "{normal}|light|demi|bold"
       radio_property gridlinestyle , "-|--|{:}|-.|none"
-      // FIXME -- should be kind of string array.
-      string_property linestyleorder , "-"
+      string_array_property linestyleorder , "-"
       double_property linewidth , 0.5
-      // FIXME -- should be kind of string array.
-      string_property markerorder , "+o*xsd^vh."
       radio_property minorgridlinestyle , "-|--|{:}|-.|none"
       array_property plotboxaspectratio m , Matrix (1, 3, 1.0)
       radio_property plotboxaspectratiomode , "{auto}|manual"
       radio_property projection , "{orthographic}|perpective"
       radio_property tickdir m , "{in}|out"
       radio_property tickdirmode , "{auto}|manual"
       array_property ticklength , default_axes_ticklength ()
       array_property tightinset r , Matrix (1, 4, 0.0)
