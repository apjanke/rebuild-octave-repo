# HG changeset patch
# User jwe
# Date 1029613113 0
#      Sat Aug 17 19:38:33 2002 +0000
# Node ID b79da8779a0ed7050ba18187dec491f12c0ca585
# Parent  6481f41a79f36f04d82093fb8785b180e3d64945
[project @ 2002-08-17 19:38:32 by jwe]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,12 @@
+2002-08-17  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* configure.in: Check for sstream.
+
 2002-08-16  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Makeconf.in (%.d : %.cc): Add $*.df to LHS of dependency list.
 
 2002-08-15  Paul Kienzle <pkienzle@users.sf.net>
 
 	* mk-opts.pl: Add support for INCLUDE = "...".
 
diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -17,17 +17,17 @@ dnl Copyright (C) 1996, 1997 John W. Eat
 ### for more details.
 ### 
 ### You should have received a copy of the GNU General Public License
 ### along with Octave; see the file COPYING.  If not, write to the Free
 ### Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ### 02111-1307, USA. 
 
 AC_INIT
-AC_REVISION($Revision: 1.363 $)
+AC_REVISION($Revision: 1.364 $)
 AC_PREREQ(2.52)
 AC_CONFIG_SRCDIR([src/octave.cc])
 AC_CONFIG_HEADER(config.h)
 
 AC_DEFINE(OCTAVE_SOURCE, 1, [Define if this is Octave.])
   
 OCTAVE_HOST_TYPE
 
@@ -785,23 +785,31 @@ OCTAVE_STRING_NPOS
 
 ### Checks for header files.
 
 AC_HEADER_STDC
 AC_HEADER_DIRENT
 AC_HEADER_TIME
 AC_HEADER_SYS_WAIT
 
+### C headers
+
 AC_CHECK_HEADERS(assert.h curses.h dlfcn.h fcntl.h float.h \
-  floatingpoint.h grp.h ieeefp.h limits.h memory.h \
-  nan.h ncurses.h poll.h pwd.h stdlib.h string.h sys/ioctl.h \
+  floatingpoint.h grp.h ieeefp.h limits.h memory.h nan.h \
+  ncurses.h poll.h pwd.h stdlib.h string.h sys/ioctl.h \
   sys/param.h sys/poll.h sys/resource.h sys/select.h sys/stat.h \
   sys/time.h sys/times.h sys/types.h sys/utsname.h termcap.h \
   unistd.h varargs.h)
 
+### C++ headers
+
+AC_LANG_PUSH(C++)
+AC_CHECK_HEADERS(sstream)
+AC_LANG_POP(C++)
+
 have_termios_h=no
 AC_CHECK_HEADERS($TERMIOS_H, have_termios_h=yes)
 AC_CHECK_HEADERS(termio.h, have_termio_h=yes, have_termio_h=no)
 AC_CHECK_HEADERS(sgtty.h, have_sgtty_h=yes, have_sgtty_h=no)
 AC_CHECK_HEADERS(glob.h, have_glob_h=yes, have_glob_h=no)
 AC_CHECK_HEADERS(fnmatch.h, have_fnmatch_h=yes, have_fnmatch_h=no)
 
 ### I'm told that termios.h is broken on NeXT systems.
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,22 @@
+2002-08-17  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* DASPK.cc: Include lo-sstream.h and use macros instead of using
+	strstream classes directly.
+	* DASRT.cc: Likewise.
+	* DASSL.cc: Likewise.
+	* LSODE.cc: Likewise.
+	* ODESSA.cc: Likewise.
+
+	* cmd-hist.cc: Don't include <strstream>.
+	* oct-shlib.cc: Likewise.
+
+	* lo-sstream.h: New file.
+
 2002-08-16  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* LSODE.h (rel_tol, abs_tol, px, pabs_tol, piwork, prwork, itol):
 	New data members.
 	(LSODE::sanity_checked): Delete unused data member.
 
 	* DASPKL.h (initialized, abs_tol, rel_tol, px, pxdot, pabs_tol,
 	prel_tol, pinfo, piwork, prwork): New data members.
diff --git a/liboctave/DASPK.cc b/liboctave/DASPK.cc
--- a/liboctave/DASPK.cc
+++ b/liboctave/DASPK.cc
@@ -26,21 +26,20 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cfloat>
 #include <cmath>
 
-#include <strstream>
-
 #include "DASPK.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
+#include "lo-sstream.h"
 
 typedef int (*daspk_fcn_ptr) (const double&, const double*,
 			      const double*, const double&,
 			      double*, int&, double*, int*);
 
 typedef int (*daspk_jac_ptr) (const double&, const double*,
 			      const double*, double*,
 			      const double&, double*, int*);
@@ -667,21 +666,20 @@ DASPK::integrate (const ColumnVector& to
   return retval;
 }
 
 std::string
 DASPK::error_message (void) const
 {
   std::string retval;
 
-  std::ostrstream buf;
-  buf << t << ends;
-  const char *t = buf.str ();
-  std::string t_curr = t;
-  delete [] t;
+  OSSTREAM buf;
+  buf << t << OSSTREAM_ENDS;
+  std::string t_curr = OSSTREAM_STR (buf);
+  OSSTREAM_FREEZE (buf);
 
   switch (istate)
     {
     case 1:
       retval = "a step was successfully taken in intermediate-output mode.";
       break;
 
     case 2:
diff --git a/liboctave/DASRT.cc b/liboctave/DASRT.cc
--- a/liboctave/DASRT.cc
+++ b/liboctave/DASRT.cc
@@ -23,35 +23,23 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <strstream.h>
-
-#include <cstdlib>
 #include <cfloat>
 #include <cmath>
-#include "defun-dld.h"
-#include "error.h"
-#include "gripes.h"
-#include "oct-obj.h"
-#include "ov-fcn.h"
-#include "pager.h"
-#include "parse.h"
-#include "unwind-prot.h"
-#include "utils.h"
-#include "variables.h"
 
 #include "DASRT.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
+#include "lo-sstream.h"
 
 typedef int (*dasrt_fcn_ptr) (const double&, const double*, const double*,
 			      double*, int&, double*, int*);
 
 typedef int (*dasrt_jac_ptr) (const double&, const double*, const double*,
 			      double*, const double&, double*, int*);
 
 typedef int (*dasrt_constr_ptr) (const int&, const double&, const double*,
@@ -558,21 +546,20 @@ DASRT::integrate (const ColumnVector& to
   return retval;
 }
 
 std::string
 DASRT::error_message (void) const
 {
   std::string retval;
 
-  std::ostrstream buf;
-  buf << t << ends;
-  const char *t = buf.str ();
-  std::string t_curr = t;
-  delete [] t;
+  OSSTREAM buf;
+  buf << t << OSSTREAM_ENDS;
+  std::string t_curr = OSSTREAM_STR (buf);
+  OSSTREAM_FREEZE (buf);
 
   switch (istate)
     {
     case 1:
       retval = "a step was successfully taken in intermediate-output mode.";
       break;
 
     case 2:
diff --git a/liboctave/DASSL-opts.in b/liboctave/DASSL-opts.in
--- a/liboctave/DASSL-opts.in
+++ b/liboctave/DASSL-opts.in
@@ -31,16 +31,17 @@ END_OPTION
 OPTION
   NAME = "relative tolerance"
   DOC_ITEM
 Relative tolerance.  May be either vector or scalar.  If a vector, it
 must match the dimension of the state vector, and the absolute
 tolerance must also be a vector of the same length.
 
 The local error test applied at each integration step is
+
 @example
   abs (local error in x(i)) <= rtol(i) * abs (Y(i)) + atol(i)
 @end example
   END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
     $OPTVAR.resize (1);
@@ -57,17 +58,17 @@ The local error test applied at each int
     void set_$OPT (const $TYPE& val)
       { $OPTVAR = val; reset = true; }
   END_SET_CODE
 END_OPTION
 
 OPTION
   NAME = "compute consistent initial condition"
   DOC_ITEM
-If nonzero, dassl will attempt to compute a consistent set of intial
+If nonzero, @code{dassl} will attempt to compute a consistent set of intial
 conditions.  This is generally not reliable, so it is best to provide
 a consistent set and leave this option set to zero.
   END_DOC_ITEM
   TYPE = "int"
   INIT_VALUE = "0"
   SET_EXPR = "val"
 END_OPTION
 
@@ -108,14 +109,14 @@ be between 1 and 5, inclusive.
   INIT_VALUE = "-1"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "maximum step size"
   DOC_ITEM
 Setting the maximum stepsize will avoid passing over very large
-regions.
+regions  (default is not specified).
   END_DOC_ITEM
   TYPE = "double"
   INIT_VALUE = "-1.0"
   SET_EXPR = "(val >= 0.0) ? val : -1.0"
 END_OPTION
diff --git a/liboctave/DASSL.cc b/liboctave/DASSL.cc
--- a/liboctave/DASSL.cc
+++ b/liboctave/DASSL.cc
@@ -26,21 +26,20 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cfloat>
 #include <cmath>
 
-#include <strstream>
-
 #include "DASSL.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
+#include "lo-sstream.h"
 
 typedef int (*dassl_fcn_ptr) (const double&, const double*, const double*,
 			      double*, int&, double*, int*);
 
 typedef int (*dassl_jac_ptr) (const double&, const double*, const double*,
 			      double*, const double&, double*, int*);
 
 extern "C"
@@ -482,21 +481,20 @@ DASSL::integrate (const ColumnVector& to
   return retval;
 }
 
 std::string
 DASSL::error_message (void) const
 {
   std::string retval;
 
-  std::ostrstream buf;
-  buf << t << ends;
-  const char *t = buf.str ();
-  std::string t_curr = t;
-  delete [] t;
+  OSSTREAM buf;
+  buf << t << OSSTREAM_ENDS;
+  std::string t_curr = OSSTREAM_STR (buf);
+  OSSTREAM_FREEZE (buf);
 
   switch (istate)
     {
     case 1:
       retval = "a step was successfully taken in intermediate-output mode.";
       break;
 
     case 2:
diff --git a/liboctave/LSODE-opts.in b/liboctave/LSODE-opts.in
--- a/liboctave/LSODE-opts.in
+++ b/liboctave/LSODE-opts.in
@@ -1,14 +1,18 @@
 CLASS = "LSODE"
 
 INCLUDE = "ODE.h"
 
 OPTION
   NAME = "absolute tolerance"
+  DOC_ITEM
+Absolute tolerance.  May be either vector or scalar.  If a vector, it
+must match the dimension of the state vector.
+  END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
     $OPTVAR.resize (1);
     $OPTVAR(0) = ::sqrt (DBL_EPSILON);
   END_INIT_BODY
   SET_CODE
     void set_$OPT (double val)
@@ -19,57 +23,96 @@ OPTION
       }
 
     void set_$OPT (const $TYPE& val)
       { $OPTVAR = val; reset = true; }
   END_SET_CODE
 END_OPTION
 
 OPTION
+  NAME = "relative tolerance"
+  DOC_ITEM
+Relative tolerance parameter.  Unlike the absolute tolerance, this
+parameter may only be a scalar.
+
+The local error test applied at each integration step is
+
+@example
+  abs (local error in x(i)) <= rtol * abs (y(i)) + atol(i)
+@end example
+  END_DOC_ITEM
+  TYPE = "double"
+  INIT_VALUE = "::sqrt (DBL_EPSILON)"
+  SET_EXPR = "(val > 0.0) ? val : ::sqrt (DBL_EPSILON)"
+END_OPTION
+
+OPTION
   NAME = "integration method"
+A string specifing the method of integration to use to solve the ODE
+system.  Valid values are
+
+@table @asis
+@item \"adams\"
+@itemx \"non-stiff\"
+No Jacobian used (even if it is available).
+@item \"bdf\"
+@item \"stiff\"
+Use stiff backward differentiation formula (BDF) method.  If a
+function to compute the Jacobian is not supplied, @code{lsode} will
+compute a finite difference approximation of the Jacobian matrix.
+@end table
+  DOC_ITEM
+  END_DOC_ITEM
   TYPE = "std::string"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_VALUE = ""stiff""
   SET_BODY
     if (val == "stiff" || val == "bdf")
       $OPTVAR = "stiff";
     else if (val == "non-stiff" || val == "adams")
       $OPTVAR = "non-stiff";
     else
       (*current_liboctave_error_handler)
         ("lsode_options: method must be \"stiff\", \"bdf\", \"non-stiff\", or \"adams\"");
   END_SET_BODY
 END_OPTION
 
 OPTION
   NAME = "initial step size"
+  DOC_ITEM
+The step size to be attempted on the first step (default is determined
+automatically).
+  END_DOC_ITEM
   TYPE = "double"
   INIT_VALUE = "-1.0"
   SET_EXPR = "(val >= 0.0) ? val : -1.0"
 END_OPTION
 
 OPTION
   NAME = "maximum step size"
+  DOC_ITEM
+Setting the maximum stepsize will avoid passing over very large
+regions  (default is not specified).
+  END_DOC_ITEM
   TYPE = "double"
   INIT_VALUE = "-1.0"
   SET_EXPR = "(val >= 0.0) ? val : -1.0"
 END_OPTION
 
 OPTION
   NAME = "minimum step size"
+  DOC_ITEM
+The minimum absolute step size allowed (default is 0).
+  END_DOC_ITEM
   TYPE = "double"
   INIT_VALUE = "0.0"
   SET_EXPR = "(val >= 0.0) ? val : 0.0"
 END_OPTION
 
 OPTION
-  NAME = "relative tolerance"
-  TYPE = "double"
-  INIT_VALUE = "::sqrt (DBL_EPSILON)"
-  SET_EXPR = "(val > 0.0) ? val : ::sqrt (DBL_EPSILON)"
-END_OPTION
-
-OPTION
   NAME = "step limit"
+  DOC_ITEM
+Maximum number of steps allowed (default is 100000).
+  END_DOC_ITEM
   TYPE = "int"
   INIT_VALUE = "100000"
   SET_EXPR = "val"
 END_OPTION
diff --git a/liboctave/LSODE.cc b/liboctave/LSODE.cc
--- a/liboctave/LSODE.cc
+++ b/liboctave/LSODE.cc
@@ -26,21 +26,20 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cfloat>
 #include <cmath>
 
-#include <strstream>
-
 #include "LSODE.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
+#include "lo-sstream.h"
 
 typedef int (*lsode_fcn_ptr) (const int&, const double&, double*,
 			      double*, int&);
 
 typedef int (*lsode_jac_ptr) (const int&, const double&, double*,
 			      const int&, const int&, double*, const
 			      int&);
 
@@ -281,21 +280,20 @@ LSODE::do_integrate (double tout)
   return retval;
 }
 
 std::string
 LSODE::error_message (void) const
 {
   std::string retval;
 
-  std::ostrstream buf;
-  buf << t << ends;
-  const char *t = buf.str ();
-  std::string t_curr = t;
-  delete [] t;
+  OSSTREAM buf;
+  buf << t << OSSTREAM_ENDS;
+  std::string t_curr = OSSTREAM_STR (buf);
+  OSSTREAM_FREEZE (buf);
 
   switch (istate)
     {
     case 1:
       retval = "prior to initial integration step";
       break;
 
     case 2:
diff --git a/liboctave/ODESSA-opts.in b/liboctave/ODESSA-opts.in
--- a/liboctave/ODESSA-opts.in
+++ b/liboctave/ODESSA-opts.in
@@ -1,14 +1,18 @@
 CLASS = "ODESSA"
 
 INCLUDE = "ODES.h"
 
 OPTION
   NAME = "absolute tolerance"
+  DOC_ITEM
+Absolute tolerance.  May be either vector or scalar.  If a vector, it
+must match the dimension of the state vector.
+  END_DOC_ITEM
   TYPE = "Array<double>"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_BODY
     $OPTVAR.resize (1);
     $OPTVAR(0) = ::sqrt (DBL_EPSILON);
   END_INIT_BODY
   SET_CODE
     void set_$OPT (double val)
@@ -19,58 +23,82 @@ OPTION
       }
 
     void set_$OPT (const $TYPE& val)
       { $OPTVAR = val; reset = true; }
   END_SET_CODE
 END_OPTION
 
 OPTION
+  NAME = "relative tolerance"
+  TYPE = "double"
+  INIT_VALUE = "::sqrt (DBL_EPSILON)"
+  SET_EXPR = "(val > 0.0) ? val : ::sqrt (DBL_EPSILON)"
+END_OPTION
+
+OPTION
   NAME = "integration method"
+  DOC_ITEM
+Relative tolerance parameter.  Unlike the absolute tolerance, this
+parameter may only be a scalar.
+
+The local error test applied at each integration step is
+
+@example
+  abs (local error in x(i)) <= rtol * abs (y(i)) + atol(i)
+@end example
+  END_DOC_ITEM
   TYPE = "std::string"
   SET_ARG_TYPE = "const $TYPE&"
   INIT_VALUE = {"stiff"}
   SET_BODY
     if (val == "stiff" || val == "bdf")
       $OPTVAR = "stiff";
     else if (val == "non-stiff" || val == "adams")
       $OPTVAR = "non-stiff";
     else
       (*current_liboctave_error_handler)
         ("lsode_options: method must be \"stiff\", \"bdf\", \"non-stiff\", or \"adams\"");
   END_SET_BODY
 END_OPTION
 
 OPTION
   NAME = "initial step size"
+  DOC_ITEM
+The step size to be attempted on the first step (default is determined
+automatically).
+  END_DOC_ITEM
   TYPE = "double"
   INIT_VALUE = "-1.0"
   SET_EXPR = "(val >= 0.0) ? val : -1.0"
 END_OPTION
 
 OPTION
   NAME = "maximum step size"
+  DOC_ITEM
+Setting the maximum stepsize will avoid passing over very large
+regions  (default is not specified).
+  END_DOC_ITEM
   TYPE = "double"
   INIT_VALUE = "-1.0"
   SET_EXPR = "(val >= 0.0) ? val : -1.0"
 END_OPTION
 
 OPTION
   NAME = "minimum step size"
+  DOC_ITEM
+The minimum absolute step size allowed (default is 0).
+  END_DOC_ITEM
   TYPE = "double"
   INIT_VALUE = "0.0"
   SET_EXPR = "(val >= 0.0) ? val : 0.0"
 END_OPTION
 
 OPTION
-  NAME = "relative tolerance"
-  TYPE = "double"
-  INIT_VALUE = "::sqrt (DBL_EPSILON)"
-  SET_EXPR = "(val > 0.0) ? val : ::sqrt (DBL_EPSILON)"
-END_OPTION
-
-OPTION
   NAME = "step limit"
+  DOC_ITEM
+Maximum number of steps allowed (default is 100000).
+  END_DOC_ITEM
   TYPE = "int"
   INIT_VALUE = "100000"
   SET_EXPR = "val"
 END_OPTION
 
diff --git a/liboctave/ODESSA.cc b/liboctave/ODESSA.cc
--- a/liboctave/ODESSA.cc
+++ b/liboctave/ODESSA.cc
@@ -23,38 +23,27 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <cstdlib>
 #include <cfloat>
 #include <cmath>
 
-#include <strstream>
-
 // For instantiating the Array<Matrix> object.
 #include "Array.h"
 #include "Array.cc"
 
 #include "ODESSA.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
-#include "error.h"
-#include "gripes.h"
-#include "oct-obj.h"
-#include "ov-fcn.h"
-#include "pager.h"
-#include "parse.h"
-#include "unwind-prot.h"
-#include "utils.h"
-#include "variables.h"
+#include "lo-sstream.h"
 
 typedef int (*odessa_fcn_ptr) (int*, const double&, double*,
 			       double*, double*);
 
 typedef int (*odessa_jac_ptr) (int*, const double&, double*,
 			       double*, const int&, const int&,
 			       double*, const int&);
 
@@ -452,21 +441,20 @@ ODESSA::integrate (double tout)
     }
 }
 
 std::string
 ODESSA::error_message (void) const
 {
   std::string retval;
 
-  std::ostrstream buf;
-  buf << t << ends;
-  const char *t = buf.str ();
-  std::string t_curr = t;
-  delete [] t;
+  OSSTREAM buf;
+  buf << t << OSSTREAM_ENDS;
+  std::string t_curr = OSSTREAM_STR (buf);
+  OSSTREAM_FREEZE (buf);
 
   switch (istate)
     {
     case 1:
       retval = "prior to initial integration step";
       break;
 
     case 2:
diff --git a/liboctave/Quad-opts.in b/liboctave/Quad-opts.in
--- a/liboctave/Quad-opts.in
+++ b/liboctave/Quad-opts.in
@@ -1,15 +1,23 @@
 CLASS = "Quad"
 
 OPTION
   NAME = "absolute tolerance"
+  DOC_ITEM
+Absolute tolerance; may be zero for pure relative error test.
+  END_DOC_ITEM
   TYPE = "double"
   INIT_VALUE = "::sqrt (DBL_EPSILON)"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "relative tolerance"
+  DOC_ITEM
+Nonnegative relative tolerance.  If the absolute tolerance is zero,
+the relative tolerance must be greater than or equal to 
+@code{max (50*eps, 0.5e-28)}.
+  END_DOC_ITEM
   TYPE = "double"
   INIT_VALUE = "::sqrt (DBL_EPSILON)"
   SET_EXPR = "val"
 END_OPTION
diff --git a/liboctave/cmd-hist.cc b/liboctave/cmd-hist.cc
--- a/liboctave/cmd-hist.cc
+++ b/liboctave/cmd-hist.cc
@@ -22,32 +22,29 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cstring>
 
 #include <iostream>
-#include <strstream>
 #include <string>
 
 #include "cmd-edit.h"
 #include "cmd-hist.h"
 #include "lo-error.h"
 #include "str-vec.h"
 
 command_history *command_history::instance = 0;
 
 #if defined (USE_READLINE)
 
 #include <cstdlib>
 
-#include <strstream>
-
 #ifdef HAVE_FCNTL_H
 #include <fcntl.h>
 #endif
 
 #ifdef HAVE_UNISTD_H
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
diff --git a/liboctave/lo-sstream.h b/liboctave/lo-sstream.h
new file mode 100644
--- /dev/null
+++ b/liboctave/lo-sstream.h
@@ -0,0 +1,62 @@
+/*
+
+Copyright (C) 2002 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if !defined (octave_liboctave_sstream_h)
+#define octave_liboctave_sstream_h 1
+
+#ifdef HAVE_SSTREAM
+
+#include <sstream>
+
+#define STRINGSTREAMBUF std::stringbuf
+
+#define ISSTREAM std::istringstream
+
+#define OSSTREAM std::ostringstream
+#define OSSTREAM_STR(os) (os).str ()
+#define OSSTREAM_C_STR(os) (os).str () . c_str ()
+#define OSSTREAM_ENDS ""
+#define OSSTREAM_FREEZE(os) do { } while (0)
+
+#else
+
+#include <strstream>
+
+#define STRINGSTREAMBUF std::strstreambuf
+
+#define ISSTREAM std::istrstream
+
+#define OSSTREAM std::ostrstream
+#define OSSTREAM_STR(os) std::string ((os).str ())
+#define OSSTREAM_C_STR(os) (os).str ()
+#define OSSTREAM_ENDS std::ends
+#define OSSTREAM_FREEZE(os) do { (os).freeze (false); } while (0)
+
+#endif
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/oct-shlib.cc b/liboctave/oct-shlib.cc
--- a/liboctave/oct-shlib.cc
+++ b/liboctave/oct-shlib.cc
@@ -24,18 +24,16 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #if defined (WITH_SHL)
 #include <cerrno>
 #include <cstring>
 #endif
 
-#include <strstream>
-
 extern "C"
 {
 #if defined (WITH_DL)
 #if defined (HAVE_DLFCN_H)
 #include <dlfcn.h>
 #else
 extern void *dlopen (const char *, int);
 extern const char *dlerror (void);
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,40 @@
+2002-08-17  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* pager.h: Include lo-sstream.h and use macros instead of using
+	strstreambuf class directly.
+
+	* load-save.cc (read_mat_ascii_data): Handle istrstream here too.
+
+	* procstream.h (procstream::procstream): Also accept std::string arg.
+	(iprocstream::iprocstream, iprocstream::open): Likewise.
+	(oprocstream::oprocstream, oprocstream::open): Likewise.
+	(procstreambase::procstreambase, procstreambase::open): Likewise.
+
+	* pt-plot.cc (gnuplot_terminal_type): Now std::string&, not char*.
+	(send_to_plot_stream): Likewise, for cmd arg.
+
+	* pt-plot.h, pt-plot.cc: Include lo-sstream.h and use macros
+	instead of using strstream classes directly.
+	* oct-strstrm.h: Likewise.
+	* error.h, error.cc: Likewise.
+	* oct-stream.h, oct-stream.cc: Likewise.
+	* lex.l: Likewise.
+	* toplev.cc: Likewise.
+	* utils.cc: Likewise.
+	* pt.cc: Likewise.
+	* pr-output.cc: Likewise.
+	* ov-list.cc: Likewise.
+	* ov-cs-list.cc: Likewise.
+	* ov-cell.cc: Likewise.
+	* load-save.cc: Likewise.
+	* help.cc: Likewise.
+	* dirfns.cc: Likewise.
+
 2002-08-15  Paul Kienzle <pkienzle@jazz.ncnr.nist.gov>
 
 	* input.cc (octave_read): Do a better job of buffering.
 
 2002-08-15  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Makefile.in (DLD_DEF_FILES): New macro.
 	(DEF_5): Delete.
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -26,21 +26,20 @@ Software Foundation, 59 Temple Place - S
 
 #undef DEBUG
 #undef DEBUG_SORT
 #undef DEBUG_EIG
 
 #include "config.h"
 
 #include <cfloat>
+#include <cmath>
+
 #include <iostream>
-#include <iomanip.h>
-#include <math.h>
-#include <string.h>
-#include <strstream.h>
+#include <iomanip>
 
 #include "CmplxQRP.h"
 #include "dbleQR.h"
 #include "defun-dld.h"
 #include "error.h"
 #include "f77-fcn.h"
 #include "gripes.h"
 #include "oct-obj.h"
diff --git a/src/debug.cc b/src/debug.cc
--- a/src/debug.cc
+++ b/src/debug.cc
@@ -21,17 +21,16 @@ Software Foundation, 59 Temple Place - S
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
 #include <fstream>
-#include <strstream>
 #include <string>
 
 #include "defun.h"
 #include "error.h"
 #include "input.h"
 #include "pager.h"
 #include "oct-obj.h"
 #include "utils.h"
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -25,29 +25,29 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include <cerrno>
 #include <cstdio>
 #include <cstddef>
 #include <cstdlib>
 #include <cstring>
 
-#include <strstream>
 #include <string>
 
 #ifdef HAVE_UNISTD_H
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 #include <unistd.h>
 #endif
 
 #include "file-ops.h"
 #include "file-stat.h"
 #include "glob-match.h"
+#include "lo-sstream.h"
 #include "oct-env.h"
 #include "str-vec.h"
 
 #include "defun.h"
 #include "dir-ops.h"
 #include "dirfns.h"
 #include "error.h"
 #include "gripes.h"
@@ -162,28 +162,27 @@ from system to system.\n\
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("ls");
 
   if (error_state)
     return retval;
 
-  std::ostrstream ls_buf;
+  OSSTREAM ls_buf;
 
   ls_buf << "ls -C ";
   for (int i = 1; i < argc; i++)
     ls_buf << file_ops::tilde_expand (argv[i]) << " ";
 
-  ls_buf << std::ends;
-  char *ls_command = ls_buf.str ();
+  ls_buf << OSSTREAM_ENDS;
 
-  iprocstream *cmd = new iprocstream (ls_command);
+  iprocstream *cmd = new iprocstream (OSSTREAM_STR (ls_buf));
 
-  delete [] ls_command;
+  OSSTREAM_FREEZE (ls_buf);
 
   unwind_protect::add (cleanup_iprocstream, cmd);
 
   // XXX FIXME XXX -- sometimes, the subprocess hasn't written
   // anything before we try to read from the procstream.  The kluge
   // below (simply waiting and trying again) is ugly, but it seems to
   // work, at least most of the time.  It could probably still fail if
   // the subprocess hasn't started writing after the snooze.  Isn't
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -22,19 +22,20 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cstdarg>
 #include <cstring>
 
-#include <strstream>
 #include <string>
 
+#include "lo-sstream.h"
+
 #include "defun.h"
 #include "error.h"
 #include "input.h"
 #include "pager.h"
 #include "oct-obj.h"
 #include "utils.h"
 #include "ov.h"
 #include "ov-usr-fcn.h"
@@ -95,43 +96,41 @@ int warning_state = 0;
 // them for later.  Used for handling errors in eval() and
 // the `unwind_protect' statement.
 bool buffer_error_messages = false;
 
 // TRUE means error messages are turned off.
 bool discard_error_messages = false;
 
 // The message buffer.
-static std::ostrstream *error_message_buffer = 0;
+static OSSTREAM *error_message_buffer = 0;
 
 // Warning messages are never buffered.
 
 static void
 vwarning (const char *name, const char *fmt, va_list args)
 {
   flush_octave_stdout ();
 
-  std::ostrstream output_buf;
+  OSSTREAM output_buf;
 
   if (name)
     output_buf << name << ": ";
 
   octave_vformat (output_buf, fmt, args);
 
-  output_buf << std::endl << std::ends;
-
-  char *msg = output_buf.str ();
+  output_buf << std::endl << OSSTREAM_ENDS;
 
   // XXX FIXME XXX -- we really want to capture the message before it
   // has all the formatting goop attached to it.  We probably also
   // want just the message, not the traceback information.
 
-  std::string msg_string = msg;
+  std::string msg_string = OSSTREAM_STR (output_buf);
 
-  delete [] msg;
+  OSSTREAM_FREEZE (output_buf);
 
   if (! warning_state)
     {
       // This is the first warning in a possible series.
       Vlast_warning_message = msg_string;
     }
 
   octave_diary << msg_string;
@@ -145,51 +144,49 @@ verror (const char *name, const char *fm
   if (discard_error_messages)
     return;
 
   if (! buffer_error_messages)
     flush_octave_stdout ();
 
   bool to_beep_or_not_to_beep_p = Vbeep_on_error && ! error_state;
 
-  std::ostrstream output_buf;
+  OSSTREAM output_buf;
 
   if (to_beep_or_not_to_beep_p)
     output_buf << "\a";
 
   if (name)
     output_buf << name << ": ";
 
   octave_vformat (output_buf, fmt, args);
 
-  output_buf << std::endl << std::ends;
-
-  char *msg = output_buf.str ();
+  output_buf << std::endl << OSSTREAM_ENDS;
 
   // XXX FIXME XXX -- we really want to capture the message before it
   // has all the formatting goop attached to it.  We probably also
   // want just the message, not the traceback information.
 
-  std::string msg_string = msg;
+  std::string msg_string = OSSTREAM_STR (output_buf);
 
-  delete [] msg;
+  OSSTREAM_FREEZE (output_buf);
 
   if (! error_state && name && ! strcmp (name, "error"))
     {
       // This is the first error in a possible series.
       Vlast_error_message = msg_string;
     }
 
   if (buffer_error_messages)
     {
       std::string tmp = msg_string;
 
       if (! error_message_buffer)
 	{
-	  error_message_buffer = new std::ostrstream;
+	  error_message_buffer = new OSSTREAM;
 
 	  // XXX FIXME XXX -- this is ugly, but it prevents
 	  //
 	  //   eval ("error (\"msg\")", "error (__error_text__)");
 	  //
 	  // from printing `error: ' twice.  Assumes that the NAME we
 	  // have been given doesn't contain `:'.
 
@@ -324,31 +321,29 @@ pr_where (const char *name)
 	pr_where_1 ("%s: near line %d, column %d:", name, l, c);
 
       // XXX FIXME XXX -- Note that the column number is probably not
       // going to mean much here since the code is being reproduced
       // from the parse tree, and we are only showing one statement
       // even if there were multiple statements on the original source
       // line.
 
-      std::ostrstream output_buf;
+      OSSTREAM output_buf;
 
       output_buf << std::endl;
 
       tree_print_code tpc (output_buf, ">>> ");
 
       curr_statement->accept (tpc);
 
-      output_buf << std::endl << std::ends;
-
-      char *msg = output_buf.str ();
+      output_buf << std::endl << OSSTREAM_ENDS;
 
-      pr_where_1 ("%s", msg);
+      pr_where_1 ("%s", OSSTREAM_C_STR (output_buf));
 
-      delete [] msg;
+      OSSTREAM_FREEZE (output_buf);
     }
 }
 
 void
 warning (const char *fmt, ...)
 {
   if (Vwarning_option != "off")
     {
@@ -716,23 +711,23 @@ to check for the proper number of argume
   return retval;
 }
 
 void
 bind_global_error_variable (void)
 {
   if (error_message_buffer)
     {
-      *error_message_buffer << std::ends;
-
-      char *error_text = error_message_buffer->str ();
+      *error_message_buffer << OSSTREAM_ENDS;
 
-      bind_builtin_variable ("__error_text__", error_text, true);
+      bind_builtin_variable ("__error_text__",
+			     OSSTREAM_STR (*error_message_buffer),
+			     true);
 
-      delete [] error_text;
+      OSSTREAM_FREEZE (*error_message_buffer);
 
       delete error_message_buffer;
 
       error_message_buffer = 0;
     }
   else
     bind_builtin_variable ("__error_text__", "", true);
 }
diff --git a/src/error.h b/src/error.h
--- a/src/error.h
+++ b/src/error.h
@@ -19,17 +19,16 @@ along with Octave; see the file COPYING.
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #if !defined (octave_error_h)
 #define octave_error_h 1
 
 #include <string>
-#include <strstream>
 
 #define panic_impossible() \
   panic ("impossible state reached in file `%s' at line %d", \
 	 __FILE__, __LINE__)
 
 extern void message (const char *name, const char *fmt, ...);
 extern void usage (const char *fmt, ...);
 extern void warning (const char *fmt, ...);
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -24,28 +24,28 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include <cstdlib>
 #include <cstring>
 
 #include <iostream>
 #include <fstream>
-#include <strstream>
 #include <string>
 
 #ifdef HAVE_UNISTD_H
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 #include <unistd.h>
 #endif
 
 #include "cmd-edit.h"
 #include "file-ops.h"
+#include "lo-sstream.h"
 #include "oct-env.h"
 #include "str-vec.h"
 
 #include <defaults.h>
 #include "defun.h"
 #include "dirfns.h"
 #include "error.h"
 #include "fn-cache.h"
@@ -502,45 +502,40 @@ simple_help (void)
     }
 }
 
 static int
 try_info (const std::string& nm)
 {
   int status = 0;
 
-  static char *cmd_str = 0;
-
-  delete [] cmd_str;
-  cmd_str = 0;
-
-  std::ostrstream cmd_buf;
+  OSSTREAM cmd_buf;
 
   cmd_buf << Vinfo_prog << " --file " << Vinfo_file;
 
   std::string directory_name = Vinfo_file;
   size_t pos = directory_name.rfind ('/');
 
   if (pos != NPOS)
     {
       directory_name.resize (pos + 1);
       cmd_buf << " --directory " << directory_name;
     }
 
   if (nm.length () > 0)
     cmd_buf << " --index-search " << nm;
 
-  cmd_buf << std::ends;
-
-  cmd_str = cmd_buf.str ();
+  cmd_buf << OSSTREAM_ENDS;
 
   volatile octave_interrupt_handler old_interrupt_handler
     = octave_ignore_interrupts ();
 
-  status = system (cmd_str);
+  status = system (OSSTREAM_C_STR (cmd_buf));
+
+  OSSTREAM_FREEZE (cmd_buf);
 
   octave_set_interrupt_handler (old_interrupt_handler);
 
   if (WIFEXITED (status))
     status = WEXITSTATUS (status);
   else
     status = 127;
 
@@ -611,36 +606,35 @@ display_help_text (std::ostream& os, con
 	cols--;
 
       if (cols > 64)
 	cols -= 7;
 
       if (cols > 80)
 	cols = 72;
 
-      std::ostrstream buf;
+      OSSTREAM buf;
+
       buf << "sed -e 's/^[#%]+ *//' -e 's/^ *@/@/' | "
 	  << Vmakeinfo_prog
 	  << " -D \"VERSION " << OCTAVE_VERSION << "\""
 	  << " -D \"OCTAVEHOME " << OCTAVE_PREFIX << "\""
 	  << " -D \"TARGETHOSTTYPE " << OCTAVE_CANONICAL_HOST_TYPE << "\""
 	  << " --fill-column " << cols
 	  << " --no-warn"
 	  << " --no-validate"
 	  << " --no-headers"
 	  << " --force"
 	  << " --output " << tmp_file_name
 	  << " > /dev/null 2>&1"
-	  << std::ends;
-
-      char *cmd = buf.str ();
+	  << OSSTREAM_ENDS;
 
-      oprocstream filter (cmd);
+      oprocstream filter (OSSTREAM_STR (buf));
 
-      delete [] cmd;
+      OSSTREAM_FREEZE (buf);
 
       if (filter && filter.is_open ())
 	{
 	  filter << "@macro seealso {args}\n"
 		 << "\n"
 		 << "@noindent\n"
 		 << "See also: \\args\\.\n"
                  << "@end macro\n";
@@ -893,40 +887,38 @@ representation.  This problem may be fix
 	      else if (argv[idx] == "-t" || argv[idx] == "-transformed")
 		pr_orig_txt = false;
 	      else
 		break;
 	    }
 
 	  if (idx < argc)
 	    {
-	      std::ostrstream output_buf;
+	      OSSTREAM output_buf;
 
 	      for (int i = idx; i < argc; i++)
 		{
 		  std::string id = argv[i];
 
 		  if (nargout == 0)
 		    do_type (octave_stdout, id, true, quiet, pr_orig_txt);
 		  else
 		    do_type (output_buf, id, false, quiet, pr_orig_txt);
 
 		  if (error_state)
 		    goto abort;
 		}
 
 	      if (nargout != 0)
 		{
-		  output_buf << std::ends;
-
-		  char *s = output_buf.str ();
+		  output_buf << OSSTREAM_ENDS;
 
-		  retval = s;
+		  retval = OSSTREAM_STR (output_buf);
 
-		  delete [] s;
+		  OSSTREAM_FREEZE (output_buf);
 		}
 	    }
 	  else
 	    print_usage ("type");
 	}
       else
 	print_usage ("type");
     }
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -26,22 +26,22 @@ Software Foundation, 59 Temple Place - S
 %{
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cctype>
 #include <cstring>
 
-#include <strstream>
 #include <string>
 
 #include "SLStack.h"
 
 #include "cmd-edit.h"
+#include "lo-sstream.h"
 
 // These would be alphabetical, but y.tab.h must be included before
 // oct-gperf.h and y.tab.h must be included after token.h and the tree
 // class declarations.  We can't include y.tab.h in oct-gperf.h
 // because it may not be protected to allow it to be included multiple
 // times.
 
 #include "comment-list.h"
@@ -1782,17 +1782,17 @@ handle_number (void)
 // Match whitespace only, followed by a comment character or newline.
 // Once a comment character is found, discard all input until newline.
 // If non-whitespace characters are found before comment
 // characters, return 0.  Otherwise, return 1.
 
 static bool
 have_continuation (bool trailing_comments_ok)
 {
-  std::ostrstream buf;
+  OSSTREAM buf;
 
   std::string comment_buf;
 
   bool in_comment = false;
   bool beginning_of_comment = false;
 
   int c = 0;
 
@@ -1874,25 +1874,24 @@ have_continuation (bool trailing_comment
 	  break;
 	}
     }
 
   unput (c);
   return false;
 
 cleanup:
-  buf << std::ends;
-  char *s = buf.str ();
-  if (s)
-    {
-      int len = strlen (s);
-      while (len--)
-	unput (s[len]);
-    }
-  delete [] s;
+
+  buf << OSSTREAM_ENDS;
+  std::string s = OSSTREAM_STR (buf);
+  OSSTREAM_FREEZE (buf);
+
+  int len = s.length ();
+  while (len--)
+    unput (s[len]);
 
   return false;
 }
 
 // We have seen a `.' and need to see if it is the start of a
 // continuation.  If so, this eats it, up to and including the new
 // line character.
 
@@ -1936,17 +1935,17 @@ eat_continuation (void)
     unput (c);
 
   return retval;
 }
 
 static int
 handle_string (char delim, int text_style)
 {
-  std::ostrstream buf;
+  OSSTREAM buf;
 
   int bos_line = input_line_number;
   int bos_col = current_input_column;
 
   int c;
   int escape_pending = 0;
 
   while ((c = yyinput ()) != EOF)
@@ -1989,20 +1988,19 @@ handle_string (char delim, int text_styl
 	  else
 	    {
 	      c = yyinput ();
 	      if (c == delim)
 		buf << static_cast<char> (c);
 	      else
 		{
 		  unput (c);
-		  buf << std::ends;
-		  char *t = buf.str ();
-		  std::string s = do_string_escapes (t);
-		  delete [] t;
+		  buf << OSSTREAM_ENDS;
+		  std::string s = do_string_escapes (OSSTREAM_STR (buf));
+		  OSSTREAM_FREEZE (buf);
 
 		  if (text_style && lexer_flags.doing_set)
 		    {
 		      s = std::string (1, delim) + s + std::string (1, delim);
 		    }
 		  else
 		    {
 		      lexer_flags.quote_is_transpose = true;
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -30,28 +30,28 @@ Software Foundation, 59 Temple Place - S
 
 #include <cfloat>
 #include <cstring>
 #include <cctype>
 
 #include <iomanip>
 #include <iostream>
 #include <fstream>
-#include <strstream>
 #include <string>
 
 #ifdef HAVE_HDF5
 #include <hdf5.h>
 #endif
 
 #include "byte-swap.h"
 #include "data-conv.h"
 #include "file-ops.h"
 #include "glob-match.h"
 #include "lo-mappers.h"
+#include "lo-sstream.h"
 #include "mach-info.h"
 #include "oct-env.h"
 #include "oct-time.h"
 #include "str-vec.h"
 
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
@@ -353,46 +353,47 @@ extract_keyword (std::istream& is, const
 {
   char *retval = 0;
 
   char c;
   while (is.get (c))
     {
       if (c == '%' || c == '#')
 	{
-	  std::ostrstream buf;
+	  OSSTREAM buf;
 	
 	  while (is.get (c) && (c == ' ' || c == '\t' || c == '%' || c == '#'))
 	    ; // Skip whitespace and comment characters.
 
 	  if (isalpha (c))
 	    buf << c;
 
 	  while (is.get (c) && isalpha (c))
 	    buf << c;
 
-	  buf << std::ends;
-	  char *tmp = buf.str ();
+	  buf << OSSTREAM_ENDS;
+	  const char *tmp = OSSTREAM_C_STR (buf);
+	  OSSTREAM_FREEZE (buf);
 	  int match = (strncmp (tmp, keyword, strlen (keyword)) == 0);
-	  delete [] tmp;
 
 	  if (match)
 	    {
-	      std::ostrstream value;
+	      OSSTREAM value;
 	      while (is.get (c) && (c == ' ' || c == '\t' || c == ':'))
 		; // Skip whitespace and the colon.
 
 	      if (c != '\n')
 		{
 		  value << c;
 		  while (is.get (c) && c != '\n')
 		    value << c;
 		}
-	      value << std::ends;
-	      retval = value.str ();
+	      value << OSSTREAM_ENDS;
+	      retval = strsave (OSSTREAM_C_STR (value));
+	      OSSTREAM_FREEZE (value);
 	      break;
 	    }
 	}
     }
 
   if (retval)
     {
       int len = strlen (retval);
@@ -421,31 +422,31 @@ extract_keyword (std::istream& is, const
   bool status = false;
   value = 0;
 
   char c;
   while (is.get (c))
     {
       if (c == '%' || c == '#')
 	{
-	  std::ostrstream buf;
+	  OSSTREAM buf;
 
 	  while (is.get (c) && (c == ' ' || c == '\t' || c == '%' || c == '#'))
 	    ; // Skip whitespace and comment characters.
 
 	  if (isalpha (c))
 	    buf << c;
 
 	  while (is.get (c) && isalpha (c))
 	    buf << c;
 
-	  buf << std::ends;
-	  char *tmp = buf.str ();
+	  buf << OSSTREAM_ENDS;
+	  const char *tmp = OSSTREAM_C_STR (buf);
 	  int match = (strncmp (tmp, keyword, strlen (keyword)) == 0);
-	  delete [] tmp;
+	  OSSTREAM_FREEZE (buf);
 
 	  if (match)
 	    {
 	      while (is.get (c) && (c == ' ' || c == '\t' || c == ':'))
 		; // Skip whitespace and the colon.
 
 	      is.putback (c);
 	      if (c != '\n')
@@ -2018,17 +2019,21 @@ read_mat_ascii_data (std::istream& is, c
 	    is.clear (std::ios::badbit);
 	  else
 	    {
 	      double d;
 	      for (int i = 0; i < nr; i++)
 		{
 		  std::string buf = get_mat_data_input_line (is);
 
+#ifdef HAVE_SSTREAM
+		  std::istringstream tmp_stream (buf);
+#else
 		  std::istrstream tmp_stream (buf.c_str ());
+#endif
 
 		  for (int j = 0; j < nc; j++)
 		    {
 		      tmp_stream >> d;
 
 		      if (tmp_stream)
 			tmp.elem (i, j) = d;
 		      else
@@ -2934,18 +2939,20 @@ do_load (std::istream& stream, const std
 	 load_save_format format, oct_mach_info::float_format flt_fmt,
 	 bool list_only, bool swap, bool verbose, bool import,
 	 const string_vector& argv, int argv_idx, int argc, int nargout)
 {
   octave_value retval;
 
   Octave_map retstruct;
 
-  std::ostrstream output_buf;
+  OSSTREAM output_buf;
+
   int count = 0;
+
   for (;;)
     {
       bool global = false;
       octave_value tc;
 
       char *name = 0;
       char *doc = 0;
 
@@ -3059,26 +3066,24 @@ do_load (std::istream& stream, const std
 	  delete [] doc;
 
 	  break;
 	}
     }
 
   if (list_only && count)
     {
-      output_buf << std::ends;
-
-      char *msg = output_buf.str ();
+      output_buf << OSSTREAM_ENDS;
+      std::string msg = OSSTREAM_STR (output_buf);
+      OSSTREAM_FREEZE (output_buf);
 
       if (nargout > 0)
 	retval = msg;
       else
 	octave_stdout << msg;
-
-      delete [] msg;
     }
   else if (! retstruct.empty ())
     retval = retstruct;
 
   return retval;
 }
 
 // HDF5 load/save documentation is included in the Octave manual
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -23,22 +23,22 @@ Software Foundation, 59 Temple Place - S
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cassert>
 #include <cstring>
 
 #include <iomanip>
-#include <strstream>
 #include <fstream>
 #include <string>
 
 #include "lo-ieee.h"
 #include "lo-mappers.h"
+#include "lo-sstream.h"
 #include "lo-utils.h"
 #include "str-vec.h"
 
 #include "error.h"
 #include "input.h"
 #include "oct-stdstrm.h"
 #include "oct-stream.h"
 #include "oct-obj.h"
@@ -161,17 +161,17 @@ scanf_format_list::scanf_format_list (co
 
   bool have_more = true;
 
   while (i < n)
     {
       have_more = true;
 
       if (! buf)
-	buf = new std::ostrstream ();
+	buf = new OSSTREAM ();
 
       if (s[i] == '%')
 	{
 	  // Process percent-escape conversion type.
 
 	  process_conversion (s, i, n, width, discard, type, modifier,
 			      num_elts);
 	  have_more = (buf != 0);
@@ -236,35 +236,32 @@ scanf_format_list::~scanf_format_list (v
 
 void
 scanf_format_list::add_elt_to_list (int width, bool discard, char type,
 				    char modifier, int& num_elts,
 				    const std::string& char_class)
 {
   if (buf)
     {
-      *buf << std::ends;
-
-      char *text = buf->str ();
-
-      if (text)
+      *buf << OSSTREAM_ENDS;
+
+      std::string text = OSSTREAM_STR (*buf);
+
+      OSSTREAM_FREEZE (*buf);
+
+      if (! text.empty ())
 	{
-	  if (*text)
-	    {
-	      scanf_format_elt *elt
-		= new scanf_format_elt (text, width, discard, type,
-					modifier, char_class);
-
-	      if (num_elts == list.length ())
-		list.resize (2 * num_elts);
-
-	      list(num_elts++) = elt;
-	    }
-
-	  delete [] text;
+	  scanf_format_elt *elt
+	    = new scanf_format_elt (text.c_str (), width, discard, type,
+				    modifier, char_class);
+
+	  if (num_elts == list.length ())
+	    list.resize (2 * num_elts);
+
+	  list(num_elts++) = elt;
 	}
 
       delete buf;
       buf = 0;
     }
 }
 
 static std::string
@@ -589,17 +586,17 @@ printf_format_list::printf_format_list (
   bool empty_buf = true;
 
   while (i < n)
     {
       have_more = true;
 
       if (! buf)
 	{
-	  buf = new std::ostrstream ();
+	  buf = new OSSTREAM ();
 	  empty_buf = true;
 	}
 
       switch (s[i])
 	{
 	case '%':
 	  {
 	    if (empty_buf)
@@ -657,35 +654,32 @@ printf_format_list::~printf_format_list 
 
 void
 printf_format_list::add_elt_to_list (int args, const std::string& flags,
 				     int fw, int prec, char type,
 				     char modifier, int& num_elts)
 {
   if (buf)
     {
-      *buf << std::ends;
-
-      char *text = buf->str ();
-
-      if (text)
+      *buf << OSSTREAM_ENDS;
+
+      std::string text = OSSTREAM_STR (*buf);
+
+      OSSTREAM_FREEZE (*buf);
+
+      if (! text.empty ())
 	{
-	  if (*text)
-	    {
-	      printf_format_elt *elt
-		= new printf_format_elt (text, args, fw, prec, flags,
-					 type, modifier);
-
-	      if (num_elts == list.length ())
-		list.resize (2 * num_elts);
-
-	      list(num_elts++) = elt;
-	    }
-
-	  delete [] text;
+	  printf_format_elt *elt
+	    = new printf_format_elt (text.c_str (), args, fw, prec, flags,
+				     type, modifier);
+
+	  if (num_elts == list.length ())
+	    list.resize (2 * num_elts);
+
+	  list(num_elts++) = elt;
 	}
 
       delete buf;
       buf = 0;
     }
 }
 
 void
@@ -936,19 +930,17 @@ octave_base_stream::do_gets (int max_len
   err = false;
 
   std::istream *isp = input_stream ();
 
   if (isp)
     {
       std::istream& is = *isp;
 
-      // XXX FIXME XXX -- this should probably be converted to use
-      // sstream when that is available.
-      std::ostrstream buf;
+      OSSTREAM buf;
 
       int c = 0;
       int char_count = 0;
       int newline_stripped = 0;
 
       while (is && (c = is.get ()) != EOF)
 	{
 	  char_count++;
@@ -980,20 +972,19 @@ octave_base_stream::do_gets (int max_len
 	{
 	  err = true;
 	  std::string msg = fcn;
 	  msg.append (": at end of file");
 	  error (msg);
 	}
       else
 	{
-	  buf << std::ends;
-	  char *tmp = buf.str ();
-	  retval = tmp;
-	  delete [] tmp;
+	  buf << OSSTREAM_ENDS;
+	  retval = OSSTREAM_STR (buf);
+	  OSSTREAM_FREEZE (buf);
 	}
     }
   else
     {
       err = true;
       invalid_operation (fcn, "reading");
     }
 
@@ -1224,71 +1215,77 @@ do_scanf_conv (std::istream&, const scan
     } \
   while (0)
 
 #define BEGIN_C_CONVERSION() \
   is.unsetf (std::ios::skipws); \
  \
   int width = elt->width ? elt->width : 1; \
  \
-  char *tmp = new char[width + 1]; \
+  char *tbuf = new char[width + 1]; \
  \
   int c = EOF; \
   int n = 0; \
  \
   while (is && n < width && (c = is.get ()) != EOF) \
-    tmp[n++] = (char) c; \
+    tbuf[n++] = (char) c; \
+ \
+  tbuf[n] = '\0'; \
  \
-  tmp[n] = '\0'
+  std::string tmp = tbuf; \
+ \
+  delete [] tbuf
 
 // For a `%s' format, skip initial whitespace and then read until the
 // next whitespace character.
 #define BEGIN_S_CONVERSION() \
   int width = elt->width; \
  \
-  char *tmp = 0; \
+  std::string tmp; \
  \
   do \
     { \
       if (width) \
 	{ \
-	  tmp = new char [width+1]; \
+	  char *tbuf = new char [width+1]; \
+ \
+	  OCTAVE_SCAN (is, *elt, tbuf); \
  \
-	  OCTAVE_SCAN (is, *elt, tmp); \
- \
-	  tmp[width] = '\0'; \
+	  tbuf[width] = '\0'; \
+          tmp = tbuf; \
+          delete [] tbuf; \
 	} \
       else \
 	{ \
-	  std::string buf; \
-	  is >> std::ws >> buf; \
-	  tmp = strsave (buf.c_str()); \
+	  is >> std::ws >> tmp; \
 	} \
     } \
   while (0)
 
 // This format must match a nonempty sequence of characters.
 #define BEGIN_CHAR_CLASS_CONVERSION() \
   int width = elt->width; \
  \
-  char *tmp = 0; \
+  std::string tmp; \
  \
   do \
     { \
       if (width) \
 	{ \
-	  tmp = new char[width+1]; \
+	  char *tbuf = new char[width+1]; \
+ \
+	  OCTAVE_SCAN (is, *elt, tbuf); \
  \
-	  OCTAVE_SCAN (is, *elt, tmp); \
- \
-	  tmp[width] = '\0'; \
+	  tbuf[width] = '\0'; \
+          tmp = tbuf; \
+          delete [] tbuf; \
 	} \
       else \
 	{ \
-	  std::ostrstream buf; \
+	  OSSTREAM buf; \
  \
 	  std::string char_class = elt->char_class; \
  \
 	  int c = EOF; \
  \
 	  if (elt->type == '[') \
 	    { \
 	      while (is && (c = is.get ()) != EOF \
@@ -1300,30 +1297,30 @@ do_scanf_conv (std::istream&, const scan
 	      while (is && (c = is.get ()) != EOF \
 		     && char_class.find (c) == NPOS) \
 		buf << (char) c; \
 	    } \
  \
 	  if (c != EOF) \
 	    is.putback (c); \
  \
-	  buf << std::ends; \
+	  buf << OSSTREAM_ENDS; \
+	  tmp = OSSTREAM_STR (buf); \
+	  OSSTREAM_FREEZE (buf); \
  \
-	  tmp = buf.str (); \
- \
-	  if (strlen (tmp) == 0) \
+	  if (tmp.empty ()) \
 	    is.setstate (std::ios::failbit); \
 	} \
     } \
   while (0)
 
 #define FINISH_CHARACTER_CONVERSION() \
   do \
     { \
-      width = strlen (tmp); \
+      width = tmp.length (); \
  \
       if (is) \
 	{ \
 	  int i = 0; \
  \
 	  if (! discard) \
 	    { \
 	      conversion_count++; \
@@ -1346,18 +1343,16 @@ do_scanf_conv (std::istream&, const scan
  \
 		      data = mval.fortran_vec (); \
 		    } \
  \
 		  data[data_index++] = tmp[i++]; \
 		} \
 	    } \
 	} \
- \
-      delete [] tmp; \
     } \
   while (0)
 
 octave_value
 octave_base_stream::do_scanf (scanf_format_list& fmt_list,
 			      int nr, int nc, bool one_elt_size_spec,
 			      int& conversion_count)
 {
@@ -1813,48 +1808,42 @@ octave_base_stream::do_oscanf (const sca
 
 	    case 'c':
 	      {
 		BEGIN_C_CONVERSION ();
 
 		if (! discard)
 		  retval = tmp;
 
-		delete [] tmp;
-
 		if (! is)
 		  quit = true;
 
 		is.setf (flags);
 	      }
 	      break;
 
 	    case 's':
 	      {
 		BEGIN_S_CONVERSION ();
 
 		if (! discard)
 		  retval = tmp;
 
-		delete [] tmp;
-
 		if (! is)
 		  quit = true;
 	      }
 	      break;
 
 	    case '[': case '^':
 	      {
 		BEGIN_CHAR_CLASS_CONVERSION ();
 
 		if (! discard)
 		  retval = tmp;
 
-		delete [] tmp;
-
 		if (! is)
 		  quit = true;
 	      }
 	      break;
 
 	    case 'p':
 	      error ("fscanf: unsupported format specifier");
 	      break;
@@ -3128,17 +3117,17 @@ octave_stream_list::do_get_info (const o
 
 std::string
 octave_stream_list::do_list_open_files (void) const
 {
   std::string retval;
 
   // XXX FIXME XXX -- this should probably be converted to use sstream
   // when that is available.
-  std::ostrstream buf;
+  OSSTREAM buf;
 
   buf << "\n"
       << "  number  mode  arch       name\n"
       << "  ------  ----  ----       ----\n";
 
   for (int i = 0; i < curr_len; i++)
     {
       octave_stream os = list(i);
@@ -3157,23 +3146,21 @@ octave_stream_list::do_list_open_files (
 	      << std::setw (4) << i << "     "
 	      << std::setiosflags (std::ios::left)
 	      << std::setw (3) << mode.c_str () << "  "
 	      << std::setw (9) << arch.c_str () << "  "
 	      << name << "\n";
 	}
     }
 
-  buf << "\n" << std::ends;
-
-  char *tmp = buf.str ();
-
-  retval = tmp;
-
-  delete [] tmp;
+  buf << "\n" << OSSTREAM_ENDS;
+
+  retval = OSSTREAM_STR (buf);
+
+  OSSTREAM_FREEZE (buf);
 
   return retval;
 }
 
 octave_value
 octave_stream_list::do_open_file_numbers (void) const
 {
   Matrix retval (1, curr_len, 0.0);
diff --git a/src/oct-stream.h b/src/oct-stream.h
--- a/src/oct-stream.h
+++ b/src/oct-stream.h
@@ -24,21 +24,21 @@ Software Foundation, 59 Temple Place - S
 #define octave_octave_stream_h 1
 
 class Matrix;
 class string_vector;
 class octave_value;
 class octave_value_list;
 
 #include <iostream>
-#include <strstream>
 #include <string>
 
 #include "Array.h"
 #include "data-conv.h"
+#include "lo-sstream.h"
 #include "lo-utils.h"
 #include "mach-info.h"
 
 class
 scanf_format_elt
 {
 public:
 
@@ -154,17 +154,17 @@ private:
 
   // Index to current element;
   int curr_idx;
 
   // List of format elements.
   Array<scanf_format_elt*> list;
 
   // Temporary buffer.
-  std::ostrstream *buf;
+  OSSTREAM *buf;
 
   void add_elt_to_list (int width, bool discard, char type, char modifier,
 			int& num_elts,
 			const std::string& char_class = std::string ()); 
 
   void process_conversion (const std::string& s, int& i, int n, int& width,
 			   bool& discard, char& type, char& modifier,
 			   int& num_elts);
@@ -286,17 +286,17 @@ private:
 
   // Index to current element;
   int curr_idx;
 
   // List of format elements.
   Array<printf_format_elt*> list;
 
   // Temporary buffer.
-  std::ostrstream *buf;
+  OSSTREAM *buf;
 
   void add_elt_to_list (int args, const std::string& flags, int fw,
 			int prec, char type, char modifier,
  			int& num_elts);
  
   void process_conversion (const std::string& s, int& i, int n,
 			   int& args, std::string& flags, int& fw,
 			   int& prec, char& modifier, char& type,
diff --git a/src/oct-strstrm.h b/src/oct-strstrm.h
--- a/src/oct-strstrm.h
+++ b/src/oct-strstrm.h
@@ -18,19 +18,20 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #if !defined (octave_octave_strstream_h)
 #define octave_octave_strstream_h 1
 
-#include <strstream>
 #include <string>
 
+#include "lo-sstream.h"
+
 #include "oct-stream.h"
 
 class
 octave_base_strstream : public octave_base_stream
 {
 public:
 
   octave_base_strstream (std::ios::openmode arg_md = std::ios::out,
@@ -109,17 +110,17 @@ public:
   void clear (void) { is.clear (); }
 
 protected:
 
   ~octave_istrstream (void) { }
 
 private:
 
-  std::istrstream is;
+  ISSTREAM is;
 
   // No copying!
 
   octave_istrstream (const octave_istrstream&);
 
   octave_istrstream& operator = (const octave_istrstream&);
 };
 
@@ -142,36 +143,35 @@ public:
   bool eof (void) const { return os.eof (); }
 
   std::istream *input_stream (void) { return 0; }
 
   std::ostream *output_stream (void) { return &os; }
 
   std::string str (void)
     {
-      os << std::ends;
-      char *tmp = os.str ();
-      std::string retval = tmp;
-      delete [] tmp;
+      os << OSSTREAM_ENDS;
+      std::string retval = OSSTREAM_STR (os);
+      OSSTREAM_FREEZE (os);
       return retval;
     }
 
   std::streambuf *rdbuf (void) { return os ? os.rdbuf () : 0; }
 
   bool bad (void) const { return os.bad (); }
 
   void clear (void) { os.clear (); }
 
 protected:
 
   ~octave_ostrstream (void) { }
 
 private:
 
-  std::ostrstream os;
+  OSSTREAM os;
 
   // No copying!
 
   octave_ostrstream (const octave_ostrstream&);
 
   octave_ostrstream& operator = (const octave_ostrstream&);
 };
 
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -28,17 +28,16 @@ Software Foundation, 59 Temple Place - S
 
 #include <cassert>
 #include <cstdlib>
 #include <cstring>
 #include <ctime>
 
 #include <fstream>
 #include <iostream>
-#include <strstream>
 
 #ifdef HAVE_UNISTD_H
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 #include <unistd.h>
 #endif
 
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -24,18 +24,18 @@ Software Foundation, 59 Temple Place - S
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
-#include <strstream>
 
+#include "lo-sstream.h"
 #include "lo-utils.h"
 
 #include "defun.h"
 #include "error.h"
 #include "ov-cell.h"
 #include "oct-obj.h"
 #include "unwind-prot.h"
 #include "utils.h"
@@ -263,25 +263,24 @@ octave_cell::print_raw (std::ostream& os
       newline (os);
 
       increment_indent_level ();
 
       for (int j = 0; j < nc; j++)
 	{
 	  for (int i = 0; i < nr; i++)
 	    {
-	      std::ostrstream buf;
-	      buf << "[" << i+1 << "," << j+1 << "]" << std::ends;
-	      const char *nm = buf.str ();
+	      OSSTREAM buf;
+	      buf << "[" << i+1 << "," << j+1 << "]" << OSSTREAM_ENDS;
 
 	      octave_value val = matrix(i,j);
 
-	      val.print_with_name (os, nm);
+	      val.print_with_name (os, OSSTREAM_STR (buf));
 
-	      delete [] nm;
+	      OSSTREAM_FREEZE (buf);
 	    }
 	}
 
       decrement_indent_level ();
 
       indent (os);
       os << "}";
       newline (os);
diff --git a/src/ov-cs-list.cc b/src/ov-cs-list.cc
--- a/src/ov-cs-list.cc
+++ b/src/ov-cs-list.cc
@@ -24,18 +24,18 @@ Software Foundation, 59 Temple Place - S
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
-#include <strstream>
 
+#include "lo-sstream.h"
 #include "lo-utils.h"
 
 #include "defun.h"
 #include "error.h"
 #include "ov-cs-list.h"
 #include "unwind-prot.h"
 
 DEFINE_OCTAVE_ALLOCATOR (octave_cs_list);
@@ -233,25 +233,24 @@ octave_list::print_raw (std::ostream& os
       indent (os);
       os << "(";
       newline (os);
 
       increment_indent_level ();
 
       for (int i = 0; i < n; i++)
 	{
-	  std::ostrstream buf;
-	  buf << "[" << i+1 << "]" << std::ends;
-	  const char *nm = buf.str ();
+	  OSSTREAM buf;
+	  buf << "[" << i+1 << "]" << OSSTREAM_ENDS;
 
 	  octave_value val = lst(i);
 
-	  val.print_with_name (os, nm);
+	  val.print_with_name (os, OSSTREAM_STR (buf));
 
-	  delete [] nm;
+	  OSSTREAM_FREEZE (buf);
 	}
 
       decrement_indent_level ();
 
       indent (os);
       os << ")";
     }
   else
diff --git a/src/ov-list.cc b/src/ov-list.cc
--- a/src/ov-list.cc
+++ b/src/ov-list.cc
@@ -24,18 +24,18 @@ Software Foundation, 59 Temple Place - S
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
-#include <strstream>
 
+#include "lo-sstream.h"
 #include "lo-utils.h"
 
 #include "defun.h"
 #include "error.h"
 #include "ov-list.h"
 #include "unwind-prot.h"
 
 DEFINE_OCTAVE_ALLOCATOR (octave_list);
@@ -231,25 +231,25 @@ octave_list::print_raw (std::ostream& os
       indent (os);
       os << "(";
       newline (os);
 
       increment_indent_level ();
 
       for (int i = 0; i < n; i++)
 	{
-	  std::ostrstream buf;
-	  buf << "[" << i+1 << "]" << std::ends;
-	  const char *nm = buf.str ();
+	  OSSTREAM buf;
+
+	  buf << "[" << i+1 << "]" << OSSTREAM_ENDS;
 
 	  octave_value val = lst(i);
 
-	  val.print_with_name (os, nm);
+	  val.print_with_name (os, OSSTREAM_STR (buf));
 
-	  delete [] nm;
+	  OSSTREAM_FREEZE (buf);
 	}
 
       decrement_indent_level ();
 
       indent (os);
       os << ")";
     }
   else
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -283,17 +283,17 @@ octave_diary_buf::sync (void)
 
   return 0;
 }
 
 octave_pager_stream *octave_pager_stream::instance = 0;
 
 octave_pager_stream::octave_pager_stream (void) : std::ostream (0), pb (0)
 {
-  pb = new octave_pager_buf;
+  pb = new octave_pager_buf ();
   rdbuf (pb);
   setf (unitbuf);
 }
 
 octave_pager_stream::~octave_pager_stream (void)
 {
   flush ();
   delete pb;
@@ -321,17 +321,17 @@ octave_pager_stream::set_diary_skip (voi
   if (pb)
     pb->set_diary_skip ();
 }
 
 octave_diary_stream *octave_diary_stream::instance = 0;
 
 octave_diary_stream::octave_diary_stream (void) : std::ostream (0), db (0)
 {
-  db = new octave_diary_buf;
+  db = new octave_diary_buf ();
   rdbuf (db);
   setf (unitbuf);
 }
 
 octave_diary_stream::~octave_diary_stream (void)
 {
   flush ();
   delete db;
diff --git a/src/pager.h b/src/pager.h
--- a/src/pager.h
+++ b/src/pager.h
@@ -19,30 +19,31 @@ along with Octave; see the file COPYING.
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #if !defined (octave_pager_h)
 #define octave_pager_h 1
 
 #include <iostream>
-#include <strstream>
 #include <string>
 
+#include "lo-sstream.h"
+
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 
 class
-octave_pager_buf : public std::strstreambuf
+octave_pager_buf : public STRINGSTREAMBUF
 {
 public:
 
-  octave_pager_buf (int size = 0)
-    : std::strstreambuf (size), diary_skip (0) { }
+  octave_pager_buf (void)
+    : STRINGSTREAMBUF (), diary_skip (0) { }
 
   void flush_current_contents_to_diary (void);
 
   void set_diary_skip (void);
 
 protected:
 
   int sync (void);
@@ -78,21 +79,21 @@ private:
   // No copying!
 
   octave_pager_stream (const octave_pager_stream&);
 
   octave_pager_stream& operator = (const octave_pager_stream&);
 };
 
 class
-octave_diary_buf : public std::strstreambuf
+octave_diary_buf : public STRINGSTREAMBUF
 {
 public:
 
-  octave_diary_buf (int size = 0) : std::strstreambuf (size) { }
+  octave_diary_buf (void) : STRINGSTREAMBUF () { }
 
 protected:
 
   int sync (void);
 };
 
 class
 octave_diary_stream : public std::ostream
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -33,25 +33,24 @@ Software Foundation, 59 Temple Place - S
 
 #include <cassert>
 #include <cstdio>
 
 #ifdef YYBYACC
 #include <cstdlib>
 #endif
 
-#include <strstream.h>
-
 #include "Cell.h"
 #include "Matrix.h"
 #include "cmd-edit.h"
 #include "cmd-hist.h"
 #include "file-ops.h"
 #include "file-stat.h"
 #include "oct-time.h"
+#include "lo-sstream.h"
 
 #include "comment-list.h"
 #include "defun.h"
 #include "dynamic-ld.h"
 #include "error.h"
 #include "input.h"
 #include "lex.h"
 #include "oct-hist.h"
@@ -1478,17 +1477,17 @@ opt_sep		: // empty
 
 // Generic error messages.
 
 static void
 yyerror (const char *s)
 {
   int err_col = current_input_column - 1;
 
-  std::ostrstream output_buf;
+  OSSTREAM output_buf;
 
   if (reading_fcn_file || reading_script_file)
     output_buf << "parse error near line " << input_line_number
 	       << " of file " << curr_fcn_file_full_name;
   else
     output_buf << "parse error:";
 
   if (s && strcmp (s, "parse error") != 0)
@@ -1498,36 +1497,34 @@ yyerror (const char *s)
 
   if (! current_input_line.empty ())
     {
       size_t len = current_input_line.length ();
 
       if (current_input_line[len-1] == '\n')
         current_input_line.resize (len-1);
 
-// Print the line, maybe with a pointer near the error token.
+      // Print the line, maybe with a pointer near the error token.
 
       output_buf << ">>> " << current_input_line << "\n";
 
       if (err_col == 0)
 	err_col = len;
 
       for (int i = 0; i < err_col + 3; i++)
 	output_buf << " ";
 
       output_buf << "^";
     }
 
-  output_buf << "\n" << std::ends;
-
-  char *msg = output_buf.str ();
-
-  parse_error ("%s", msg);
-
-  delete [] msg;
+  output_buf << "\n" << OSSTREAM_ENDS;
+
+  parse_error ("%s", OSSTREAM_C_STR (output_buf));
+
+  OSSTREAM_FREEZE (output_buf);
 }
 
 // Error mesages for mismatched end tokens.
 
 static void
 end_error (const char *type, token::end_tok_type ettype, int l, int c)
 {
   static const char *fmt
@@ -1697,29 +1694,27 @@ fold (tree_binary_expression *e)
   if (op1->is_constant () && op2->is_constant ())
     {
       octave_value tmp = e->rvalue ();
 
       if (! (error_state || warning_state))
 	{
 	  tree_constant *tc_retval = new tree_constant (tmp);
 
-	  std::ostrstream buf;
+	  OSSTREAM buf;
 
 	  tree_print_code tpc (buf);
 
 	  e->accept (tpc);
 
-	  buf << std::ends;
-
-	  char *s = buf.str ();
-
-	  tc_retval->stash_original_text (s);
-
-	  delete [] s;
+	  buf << OSSTREAM_ENDS;
+
+	  tc_retval->stash_original_text (OSSTREAM_STR (buf));
+
+	  OSSTREAM_FREEZE (buf);
 
 	  delete e;
 
 	  retval = tc_retval;
 	}
     }
 
   unwind_protect::run_frame ("fold_binary_expression");
@@ -1744,29 +1739,27 @@ fold (tree_unary_expression *e)
   if (op->is_constant ())
     {
       octave_value tmp = e->rvalue ();
 
       if (! (error_state || warning_state))
 	{
 	  tree_constant *tc_retval = new tree_constant (tmp);
 
-	  std::ostrstream buf;
+	  OSSTREAM buf;
 
 	  tree_print_code tpc (buf);
 
 	  e->accept (tpc);
 
-	  buf << std::ends;
-
-	  char *s = buf.str ();
-
-	  tc_retval->stash_original_text (s);
-
-	  delete [] s;
+	  buf << OSSTREAM_ENDS;
+
+	  tc_retval->stash_original_text (OSSTREAM_STR (buf));
+
+	  OSSTREAM_FREEZE (buf);
 
 	  delete e;
 
 	  retval = tc_retval;
 	}
     }
 
   unwind_protect::run_frame ("fold_unary_expression");
@@ -1800,29 +1793,27 @@ finish_colon_expression (tree_colon_expr
 	      && (! incr || (incr && incr->is_constant ())))
 	    {
 	      octave_value tmp = e->rvalue ();
 
 	      if (! (error_state || warning_state))
 		{
 		  tree_constant *tc_retval = new tree_constant (tmp);
 
-		  std::ostrstream buf;
+		  OSSTREAM buf;
 
 		  tree_print_code tpc (buf);
 
 		  e->accept (tpc);
 
-		  buf << std::ends;
-
-		  char *s = buf.str ();
-
-		  tc_retval->stash_original_text (s);
-
-		  delete [] s;
+		  buf << OSSTREAM_ENDS;
+
+		  tc_retval->stash_original_text (OSSTREAM_STR (buf));
+
+		  OSSTREAM_FREEZE (buf);
 
 		  delete e;
 
 		  retval = tc_retval;
 		}
 	    }
 	}
       else
@@ -2719,29 +2710,27 @@ finish_matrix (tree_matrix *m)
   if (m->all_elements_are_constant ())
     {
       octave_value tmp = m->rvalue ();
 
       if (! (error_state || warning_state))
 	{
 	  tree_constant *tc_retval = new tree_constant (tmp);
 
-	  std::ostrstream buf;
+	  OSSTREAM buf;
 
 	  tree_print_code tpc (buf);
 
 	  m->accept (tpc);
 
-	  buf << std::ends;
-
-	  char *s = buf.str ();
-
-	  tc_retval->stash_original_text (s);
-
-	  delete [] s;
+	  buf << OSSTREAM_ENDS;
+
+	  tc_retval->stash_original_text (OSSTREAM_STR (buf));
+
+	  OSSTREAM_FREEZE (buf);
 
 	  delete m;
 
 	  retval = tc_retval;
 	}
     }
 
   unwind_protect::run_frame ("finish_matrix");
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -26,24 +26,24 @@ Software Foundation, 59 Temple Place - S
 
 #include <cfloat>
 #include <cmath>
 #include <cstdio>
 #include <cstring>
 
 #include <iomanip>
 #include <iostream>
-#include <strstream>
 #include <string>
 
 #include "CMatrix.h"
 #include "Range.h"
 #include "cmd-edit.h"
 #include "dMatrix.h"
 #include "lo-mappers.h"
+#include "lo-sstream.h"
 #include "mach-info.h"
 #include "oct-cmplx.h"
 #include "str-vec.h"
 
 #include "Cell.h"
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
@@ -1784,22 +1784,21 @@ returns the formatted output in a string
   int nargin = args.length ();
 
   if (nargin == 1 && nargout < 2)
     {
       if (nargout == 0)
 	args(0).print (octave_stdout);
       else
 	{
-	  std::ostrstream buf;
+	  OSSTREAM buf;
 	  args(0).print (buf);
-	  buf << std::ends;
-	  char *tmp = buf.str ();
-	  retval = tmp;
-	  delete [] tmp;
+	  buf << OSSTREAM_ENDS;
+	  retval = OSSTREAM_STR (buf);
+	  OSSTREAM_FREEZE (buf);
 	}
     }
   else
     print_usage ("disp");
 
   return retval;
 }
 
diff --git a/src/procstream.cc b/src/procstream.cc
--- a/src/procstream.cc
+++ b/src/procstream.cc
@@ -25,16 +25,24 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "procstream.h"
 
+procstreambase::procstreambase (const std::string& command, int mode)
+{
+  pb_init ();
+
+  if (! pb.open (command.c_str (), mode))
+    std::ios::setstate (std::ios::badbit);
+}
+
 procstreambase::procstreambase (const char *command, int mode)
 {
   pb_init ();
 
   if (! pb.open (command, mode))
     std::ios::setstate (std::ios::badbit);
 }
 
diff --git a/src/procstream.h b/src/procstream.h
--- a/src/procstream.h
+++ b/src/procstream.h
@@ -23,34 +23,40 @@ Software Foundation, 59 Temple Place - S
 #if !defined (octave_procstream_h)
 #define octave_procstream_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 #include <iostream>
+#include <string>
 
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 
 #include "oct-procbuf.h"
 
 class
 procstreambase : virtual public std::ios
 {
 public:
 
   procstreambase (void) { pb_init (); }
 
+  procstreambase (const std::string& name, int mode);
+
   procstreambase (const char *name, int mode);
 
   ~procstreambase (void) { close (); }
 
+  void open (const std::string& name, int mode)
+    { open (name.c_str (), mode); }
+
   void open (const char *name, int mode);
 
   int is_open (void) const { return pb.is_open (); }
 
   int close (void);
 
   pid_t pid (void) { return pb.pid (); }
 
@@ -68,21 +74,27 @@ private:
 class
 iprocstream : public std::istream, public procstreambase
 // iprocstream : public procstreambase, public std::istream
 {
 public:
 
   iprocstream (void) : std::istream (0), procstreambase () { }
 
+  iprocstream (const std::string& name, int mode = std::ios::in)
+    : std::istream (0), procstreambase (name, mode) { }
+
   iprocstream (const char *name, int mode = std::ios::in)
     : std::istream (0), procstreambase (name, mode) { }
 
   ~iprocstream (void) { }
 
+  void open (const std::string& name, int mode = std::ios::in)
+    { procstreambase::open (name, mode); }
+
   void open (const char *name, int mode = std::ios::in)
     { procstreambase::open (name, mode); }
 
 private:
 
   iprocstream (const iprocstream&);
 
   iprocstream& operator = (const iprocstream&);
@@ -91,21 +103,27 @@ private:
 class
 oprocstream : public std::ostream, public procstreambase
 // oprocstream : public procstreambase, public std::ostream
 {
 public:
  
   oprocstream (void) : std::ostream (0), procstreambase () { }
 
+  oprocstream (const std::string& name, int mode = std::ios::out)
+    : std::ostream (0), procstreambase(name, mode) { }
+
   oprocstream (const char *name, int mode = std::ios::out)
     : std::ostream (0), procstreambase(name, mode) { }
 
   ~oprocstream (void) { }
 
+  void open (const std::string& name, int mode = std::ios::out)
+    { procstreambase::open (name, mode); }
+
   void open (const char *name, int mode = std::ios::out)
     { procstreambase::open (name, mode); }
 
 private:
 
   oprocstream (const oprocstream&);
 
   oprocstream& operator = (const oprocstream&);
@@ -114,21 +132,27 @@ private:
 class
 procstream : public std::iostream, public procstreambase
 // procstream : public procstreambase, public std::iostream
 {
 public:
 
   procstream (void) : std::iostream (0), procstreambase () { }
 
+  procstream (const std::string& name, int mode)
+    : std::iostream (0), procstreambase (name, mode) { }
+
   procstream (const char *name, int mode)
     : std::iostream (0), procstreambase (name, mode) { }
 
   ~procstream (void) { }
 
+  void open (const std::string& name, int mode)
+    { procstreambase::open (name, mode); }
+
   void open (const char *name, int mode)
     { procstreambase::open (name, mode); }
 
 private:
 
   procstream (const procstream&);
 
   procstream& operator = (const procstream&);
diff --git a/src/pt-arg-list.cc b/src/pt-arg-list.cc
--- a/src/pt-arg-list.cc
+++ b/src/pt-arg-list.cc
@@ -24,17 +24,16 @@ Software Foundation, 59 Temple Place - S
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
-#include <strstream>
 #include <string>
 
 #include "str-vec.h"
 
 #include "error.h"
 #include "oct-obj.h"
 #include "ov.h"
 #include "ov-usr-fcn.h"
diff --git a/src/pt-assign.cc b/src/pt-assign.cc
--- a/src/pt-assign.cc
+++ b/src/pt-assign.cc
@@ -24,17 +24,16 @@ Software Foundation, 59 Temple Place - S
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
-#include <strstream>
 
 #include "defun.h"
 #include "error.h"
 #include "input.h"
 #include "oct-obj.h"
 #include "oct-lvalue.h"
 #include "pager.h"
 #include "ov.h"
diff --git a/src/pt-cell.cc b/src/pt-cell.cc
--- a/src/pt-cell.cc
+++ b/src/pt-cell.cc
@@ -24,17 +24,16 @@ Software Foundation, 59 Temple Place - S
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
-#include <strstream>
 
 #include "Cell.h"
 #include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 #include "pt-arg-list.h"
 #include "pt-bp.h"
 #include "pt-exp.h"
diff --git a/src/pt-exp.cc b/src/pt-exp.cc
--- a/src/pt-exp.cc
+++ b/src/pt-exp.cc
@@ -24,17 +24,16 @@ Software Foundation, 59 Temple Place - S
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
-#include <strstream>
 #include <string>
 
 #include "error.h"
 #include "pager.h"
 #include "oct-lvalue.h"
 #include "ov.h"
 #include "pt-exp.h"
 
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -24,17 +24,16 @@ Software Foundation, 59 Temple Place - S
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
-#include <strstream>
 
 #include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 #include "pt-arg-list.h"
 #include "pt-bp.h"
 #include "pt-exp.h"
 #include "pt-mat.h"
diff --git a/src/pt-plot.cc b/src/pt-plot.cc
--- a/src/pt-plot.cc
+++ b/src/pt-plot.cc
@@ -27,17 +27,16 @@ Software Foundation, 59 Temple Place - S
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cstring>
 
 #include <fstream>
 #include <iostream>
-#include <strstream>
 #include <string>
 
 #ifdef HAVE_UNISTD_H
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 #include <unistd.h>
 #endif
@@ -78,17 +77,17 @@ static bool Vgnuplot_has_multiplot;
 
 // The number of lines we've plotted so far.
 static int plot_line_count = 0;
 
 // Is this a parametric plot?  Makes a difference for 3D plotting.
 static bool parametric_plot = false;
 
 // The gnuplot terminal type.
-static char *gnuplot_terminal_type = 0;
+static std::string gnuplot_terminal_type;
 
 // Should the graph window be cleared before plotting the next line?
 static bool clear_before_plotting = true;
 
 // List of files to delete when we exit or crash.
 //
 // XXX FIXME XXX -- this should really be static, but that causes
 // problems on some systems.
@@ -182,42 +181,40 @@ open_plot_stream (void)
 #endif
     }
 
   if (! error_state && plot_stream && *plot_stream && ! initialized)
     {
       initialized = true;
       *plot_stream << "set data style lines\n";
 
-      if (gnuplot_terminal_type)
+      if (! gnuplot_terminal_type.empty ())
 	*plot_stream << "set term " << gnuplot_terminal_type
 		     << Vgnuplot_command_end; 
     }
 }
 
 static int
-send_to_plot_stream (const char *cmd)
+send_to_plot_stream (const std::string& cmd)
 {
   if (! (plot_stream && *plot_stream))
     {
       open_plot_stream ();
 
       if (error_state)
 	return -1;
     }
 
   int replot_len = Vgnuplot_command_replot.length ();
   int splot_len = Vgnuplot_command_splot.length ();
   int plot_len = Vgnuplot_command_plot.length ();
 
-  std::string s = cmd;
-
-  bool is_replot = (Vgnuplot_command_replot == s.substr (0, replot_len));
-  bool is_splot = (Vgnuplot_command_splot == s.substr (0, splot_len));
-  bool is_plot = (Vgnuplot_command_plot == s.substr (0, plot_len));
+  bool is_replot = (Vgnuplot_command_replot == cmd.substr (0, replot_len));
+  bool is_splot = (Vgnuplot_command_splot == cmd.substr (0, splot_len));
+  bool is_plot = (Vgnuplot_command_plot == cmd.substr (0, plot_len));
 
   if (plot_line_count == 0 && is_replot)
     error ("replot: no previous plot");
   else
     {
       *plot_stream << cmd;
 
       if (! (is_replot || is_splot || is_plot)
@@ -242,17 +239,17 @@ tree_plot_command::~tree_plot_command (v
 void
 tree_plot_command::eval (void)
 {
   if (error_state)
     return;
 
   open_plot_stream ();
 
-  std::ostrstream plot_buf;
+  OSSTREAM plot_buf;
 
   switch (ndim)
     {
     case 1:
       if (plot_line_count == 0)
 	{
 	  if (plot_list)
 	    plot_buf << Vgnuplot_command_plot;
@@ -306,54 +303,52 @@ tree_plot_command::eval (void)
   if (plot_list)
     {
       int status = plot_list->print (ndim, plot_buf);
 
       if (error_state || status < 0)
 	return;
     }
 
-  plot_buf << Vgnuplot_command_end << std::ends;
+  plot_buf << Vgnuplot_command_end << OSSTREAM_ENDS;
 
   // Just testing...
   //  char *message = plot_buf.str ();
   //  std::cout << "[*]" << message << "[*]\n";
 
+  std::string message = OSSTREAM_STR (plot_buf);
+
   if (parametric_plot && ndim == 2)
     {
       warning ("can't make 2D parametric plot -- setting noparametric...");
       send_to_plot_stream ("set noparametric\n");
-      char *message = plot_buf.str ();
       send_to_plot_stream (message);
-      delete [] message;
       send_to_plot_stream ("set parametric\n");
     }
   else
-    {
-      char *message = plot_buf.str ();
-      send_to_plot_stream (message);
-      delete [] message;
-    }
+    send_to_plot_stream (message);
+
+  OSSTREAM_FREEZE (plot_buf);
 }
 
 void
 tree_plot_command::accept (tree_walker& tw)
 {
   tw.visit_plot_command (*this);
 }
 
 plot_limits::~plot_limits (void)
 {
   delete x_range;
   delete y_range;
   delete z_range;
 }
 
 void
-plot_limits::print (int ndim, std::ostrstream& plot_buf)
+plot_limits::print (int ndim, OSSTREAM& plot_buf)
 {
   if (ndim  == 2 || ndim == 3)
     {
       if (x_range)
 	x_range->print (plot_buf);
       else
 	return;
 
@@ -375,17 +370,17 @@ plot_limits::accept (tree_walker& tw)
 
 plot_range::~plot_range (void)
 {
   delete lower;
   delete upper;
 }
 
 void
-plot_range::print (std::ostrstream& plot_buf)
+plot_range::print (OSSTREAM& plot_buf)
 {
   plot_buf << " [";
 
   if (lower)
     {
       octave_value lower_val = lower->rvalue ();
 
       if (error_state)
@@ -499,17 +494,17 @@ subplot_using::values (int ndim, int n_m
   // XXX FIXME XXX -- is the following really right?
   if (status < 0)
     return ColumnVector (1, -1.0);
 
   return val;
 }
 
 int
-subplot_using::print (int ndim, int n_max, std::ostrstream& plot_buf)
+subplot_using::print (int ndim, int n_max, OSSTREAM& plot_buf)
 {
   int status = eval (ndim, n_max);
 
   if (status < 0)
     return -1;
 
   for (int i = 0; i < qual_count; i++)
     {
@@ -532,17 +527,17 @@ subplot_using::accept (tree_walker& tw)
 
 subplot_style::~subplot_style (void)
 {
   delete sp_linetype;
   delete sp_pointtype;
 }
 
 int
-subplot_style::print (std::ostrstream& plot_buf)
+subplot_style::print (OSSTREAM& plot_buf)
 {
   if (! sp_style.empty ())
     {
       plot_buf << " " << Vgnuplot_command_with << " " << sp_style;
 
       if (sp_linetype)
 	{
 	  octave_value tmp = sp_linetype->rvalue ();
@@ -624,17 +619,17 @@ subplot_style::columns_ok (int nc)
 
 void
 subplot_style::accept (tree_walker& tw)
 {
   tw.visit_subplot_style (*this);
 }
 
 int
-subplot_axes::print (std::ostrstream& plot_buf)
+subplot_axes::print (OSSTREAM& plot_buf)
 {
   if (! sp_axes.empty ())
     plot_buf << " " << Vgnuplot_command_axes << " " << sp_axes;
 
   return 0;
 }
 
 void
@@ -680,17 +675,17 @@ subplot::extract_plot_data (int ndim, oc
 
   if (ndim == 2 && sp_style_clause && ! sp_style_clause->columns_ok (nc))
     return octave_value ();
 
   return retval;
 }
 
 int
-subplot::handle_plot_data (int ndim, std::ostrstream& plot_buf)
+subplot::handle_plot_data (int ndim, OSSTREAM& plot_buf)
 {
   if (sp_plot_data)
     {
       octave_value data = sp_plot_data->rvalue ();
 
       if (! error_state && data.is_defined ())
 	{
 	  std::string file;
@@ -767,17 +762,17 @@ subplot::handle_plot_data (int ndim, std
     }
   else
     return -1;
 
   return 0;
 }
 
 int
-subplot::print (int ndim, std::ostrstream& plot_buf)
+subplot::print (int ndim, OSSTREAM& plot_buf)
 {
   int status = handle_plot_data (ndim, plot_buf);
 
   if (status < 0)
     return -1;
 
   if (sp_axes_clause)
     {
@@ -825,17 +820,17 @@ subplot_list::~subplot_list (void)
   while (! empty ())
     {
       subplot *t = remove_front ();
       delete t;
     }
 }
 
 int
-subplot_list::print (int ndim, std::ostrstream& plot_buf)
+subplot_list::print (int ndim, OSSTREAM& plot_buf)
 {
   int status = 0;
 
   for (Pix p = first (); p != 0; next (p))
     {
       subplot *elt = this->operator () (p);
 
       plot_line_count++;
@@ -925,21 +920,21 @@ close_plot_stream (void)
   plot_line_count = 0;
 }
 
 void
 do_external_plotter_cd (const std::string& newdir)
 {
   if (plot_stream && *plot_stream)
     {
-      std::ostrstream plot_buf;
-      plot_buf << "cd \"" << newdir << "\"" << Vgnuplot_command_end << std::ends;
-      char *message = plot_buf.str ();
-      send_to_plot_stream (message);
-      delete [] message;
+      OSSTREAM plot_buf;
+      plot_buf << "cd \"" << newdir << "\"" << Vgnuplot_command_end
+	       << OSSTREAM_ENDS;
+      send_to_plot_stream (OSSTREAM_STR (plot_buf));
+      OSSTREAM_FREEZE (plot_buf);
     }
 }
 
 DEFUN (clearplot, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} clearplot\n\
 @deftypefnx {Built-in Function} {} clg\n\
 Clear the plot window and any titles or axis labels.  The name\n\
@@ -1105,51 +1100,51 @@ Set plotting options for gnuplot\n\
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("set");
 
   if (error_state)
     return retval;
 
-  std::ostrstream plot_buf;
+  OSSTREAM plot_buf;
 
   if (argc > 1)
     {
       if (almost_match ("parametric", argv[1], 3))
 	parametric_plot = true;
       else if (almost_match ("noparametric", argv[1], 5))
 	parametric_plot = false;
       else if (almost_match ("term", argv[1], 1))
 	{
-	  delete [] gnuplot_terminal_type;
-	  std::ostrstream buf;
+	  gnuplot_terminal_type = "";
+	  OSSTREAM buf;
 	  int i;
 	  for (i = 2; i < argc-1; i++)
 	    buf << argv[i] << " ";
 	  if (i < argc)
 	    buf << argv[i];
-	  buf << Vgnuplot_command_end << std::ends;
-	  gnuplot_terminal_type = buf.str ();
+	  buf << Vgnuplot_command_end << OSSTREAM_ENDS;
+	  gnuplot_terminal_type = OSSTREAM_STR (buf);
+	  OSSTREAM_FREEZE (buf);
 	}
     }
 
   int i;
   for (i = 0; i < argc-1; i++)
     plot_buf << argv[i] << " ";
 
   if (i < argc)
     plot_buf << argv[i];
 
-  plot_buf << Vgnuplot_command_end << std::ends;
+  plot_buf << Vgnuplot_command_end << OSSTREAM_ENDS;
 
-  char *plot_command = plot_buf.str ();
-  send_to_plot_stream (plot_command);
+  send_to_plot_stream (OSSTREAM_STR (plot_buf));
 
-  delete [] plot_command;
+  OSSTREAM_FREEZE (plot_buf);
 
   return retval;
 }
 
 DEFUN_TEXT (set, args, nargout,
   "-*- texinfo -*-\n\
 This command is has been replaced by @code{gset}.")
 {
@@ -1167,30 +1162,29 @@ Show plotting options.\n\
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("show");
 
   if (error_state)
     return retval;
 
-  std::ostrstream plot_buf;
+  OSSTREAM plot_buf;
 
   int i;
   for (i = 0; i < argc-1; i++)
     plot_buf << argv[i] << " ";
   if (i < argc)
     plot_buf << argv[i];
 
-  plot_buf << Vgnuplot_command_end << std::ends;
+  plot_buf << Vgnuplot_command_end << OSSTREAM_ENDS;
 
-  char *plot_command = plot_buf.str ();
-  send_to_plot_stream (plot_command);
+  send_to_plot_stream (OSSTREAM_STR (plot_buf));
 
-  delete [] plot_command;
+  OSSTREAM_FREEZE (plot_buf);
 
   return retval;
 }
 
 DEFUN_TEXT (show, args, nargout,
   "-*- texinfo -*-\n\
 This command is has been replaced by @code{gshow}.")
 {
diff --git a/src/pt-plot.h b/src/pt-plot.h
--- a/src/pt-plot.h
+++ b/src/pt-plot.h
@@ -23,17 +23,18 @@ Software Foundation, 59 Temple Place - S
 #if !defined (octave_tree_plot_h)
 #define octave_tree_plot_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 #include <iostream>
-#include <strstream>
+
+#include "lo-sstream.h"
 
 class tree_expression;
 class tree_plot_command;
 class plot_limits;
 class plot_range;
 class subplot_using;
 class subplot_style;
 class subplot_axes;
@@ -95,17 +96,17 @@ plot_limits
 public:
 
   plot_limits (plot_range *xlim = 0, plot_range *ylim = 0,
 	       plot_range *zlim = 0)
     : x_range (xlim), y_range (ylim), z_range (zlim) { }
 
   ~plot_limits (void);
 
-  void print (int ndim, std::ostrstream& plot_buf);
+  void print (int ndim, OSSTREAM& plot_buf);
 
   plot_range *x_limits (void) { return x_range; }
   plot_range *y_limits (void) { return y_range; }
   plot_range *z_limits (void) { return z_range; }
 
   void accept (tree_walker& tw);
 
 private:
@@ -128,17 +129,17 @@ plot_range
 {
 public:
 
   plot_range (tree_expression *l = 0, tree_expression *u = 0)
     : lower (l), upper (u) { }
 
   ~plot_range (void);
 
-  void print (std::ostrstream& plot_buf);
+  void print (OSSTREAM& plot_buf);
 
   tree_expression *lower_bound (void) { return lower; }
 
   tree_expression *upper_bound (void) { return upper; }
 
   void accept (tree_walker& tw);
 
 private:
@@ -183,17 +184,17 @@ public:
 
       return this;
     }
 
   int eval (int ndim, int n_max);
 
   ColumnVector values (int ndim, int n_max = 0);
 
-  int print (int ndim, int n_max, std::ostrstream& plot_buf);
+  int print (int ndim, int n_max, OSSTREAM& plot_buf);
 
   int qualifier_count (void) { return qual_count; }
 
   tree_expression **qualifiers (void) { return x; }
 
   tree_expression *scanf_format (void) { return scanf_fmt; }
 
   void accept (tree_walker& tw);
@@ -228,17 +229,17 @@ subplot_style
 public:
 
   subplot_style (const std::string& s = std::string (),
 		 tree_expression *lt = 0, tree_expression *pt = 0)
     : sp_style (s), sp_linetype (lt), sp_pointtype (pt) { }
 
   ~subplot_style (void);
 
-  int print (std::ostrstream& plot_buf);
+  int print (OSSTREAM& plot_buf);
 
   bool columns_ok (int nc);
 
   std::string style (void) { return sp_style; }
 
   tree_expression *linetype (void) { return sp_linetype; }
 
   tree_expression *pointtype (void) { return sp_pointtype; }
@@ -268,17 +269,17 @@ subplot_axes
 {
 public:
 
   subplot_axes (const std::string& s = std::string ())
     : sp_axes (s) { }
 
   ~subplot_axes (void) { }
 
-  int print (std::ostrstream& plot_buf);
+  int print (OSSTREAM& plot_buf);
 
   std::string axes (void) { return sp_axes; }
 
   void accept (tree_walker& tw);
 
 private:
 
   // The axes we are using: `x1y1', `x1y2', etc.
@@ -349,19 +350,19 @@ public:
 	  return this;
 	}
       else
 	return 0;
     }
 
   octave_value extract_plot_data (int ndim, octave_value& data);
 
-  int handle_plot_data (int ndim, std::ostrstream& plot_buf);
+  int handle_plot_data (int ndim, OSSTREAM& plot_buf);
 
-  int print (int ndim, std::ostrstream& plot_buf);
+  int print (int ndim, OSSTREAM& plot_buf);
 
   tree_expression *plot_data (void) { return sp_plot_data; }
 
   subplot_using *using_clause (void) { return sp_using_clause; }
 
   tree_expression *title_clause (void) { return sp_title_clause; }
 
   subplot_style *style_clause (void) { return sp_style_clause; }
@@ -402,17 +403,17 @@ public:
   subplot_list (void)
     : SLList<subplot *> () { }
 
   subplot_list (subplot *t)
     : SLList<subplot *> () { append (t); }
 
   ~subplot_list (void);
 
-  int print (int ndim, std::ostrstream& plot_buf);
+  int print (int ndim, OSSTREAM& plot_buf);
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   subplot_list (const subplot_list&);
diff --git a/src/pt.cc b/src/pt.cc
--- a/src/pt.cc
+++ b/src/pt.cc
@@ -24,19 +24,20 @@ Software Foundation, 59 Temple Place - S
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
-#include <strstream>
 #include <string>
 
+#include "lo-sstream.h"
+
 #include "pt.h"
 #include "pt-pr-code.h"
 
 // If true, stop executing at the next possible point.
 bool tree::break_next = false;
 
 // The line where dbg_next was executed.
 int tree::last_line = 0;
@@ -48,29 +49,27 @@ const octave_user_function *tree::break_
 const tree *tree::break_statement = 0;
 
 // Hide the details of the string buffer so that we are less likely to
 // create a memory leak.
 
 std::string
 tree::str_print_code (void)
 {
-  std::ostrstream buf;
+  OSSTREAM buf;
 
   tree_print_code tpc (buf);
 
   accept (tpc);
 
-  buf << std::ends;
-
-  const char *s = buf.str ();
+  buf << OSSTREAM_ENDS;
 
-  std::string retval = s;
+  std::string retval = OSSTREAM_STR (buf);
 
-  delete [] s;
+  OSSTREAM_FREEZE (buf);
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -25,17 +25,16 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include <cassert>
 #include <cstdlib>
 #include <cstring>
 
 #include <fstream>
 #include <iostream>
-#include <strstream>
 #include <string>
 
 #ifdef HAVE_UNISTD_H
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 #include <unistd.h>
 #endif
@@ -44,16 +43,17 @@ Software Foundation, 59 Temple Place - S
 // the ANSI standard C interface.
 
 #include <setjmp.h>
 
 #include "cmd-edit.h"
 #include "file-ops.h"
 #include "lo-error.h"
 #include "lo-mappers.h"
+#include "lo-sstream.h"
 #include "oct-env.h"
 #include "str-vec.h"
 
 #include <defaults.h>
 #include "defun.h"
 #include "error.h"
 #include "file-io.h"
 #include "input.h"
@@ -336,17 +336,17 @@ run_command_and_return_output (const std
   iprocstream *cmd = new iprocstream (cmd_str.c_str ());
 
   if (cmd)
     {
       unwind_protect::add (cleanup_iprocstream, cmd);
 
       if (*cmd)
 	{
-	  std::ostrstream output_buf;
+	  OSSTREAM output_buf;
 
 	  // XXX FIXME XXX -- sometimes, the subprocess hasn't written
 	  // anything before we try to read from the procstream.  The
 	  // kluge below (simply waiting and trying again) is ugly,
 	  // but it seems to work, at least most of the time.  It
 	  // could probably still fail if the subprocess hasn't
 	  // started writing after the snooze.  Isn't there a better
 	  // way?  If there is, you should also fix the code for the
@@ -368,24 +368,22 @@ run_command_and_return_output (const std
 
 	  int cmd_status = cmd->close ();
 
 	  if (WIFEXITED (cmd_status))
 	    cmd_status = WEXITSTATUS (cmd_status);
 	  else
 	    cmd_status = 127;
 
-	  output_buf << std::ends;
-
-	  char *msg = output_buf.str ();
+	  output_buf << OSSTREAM_ENDS;
 
 	  retval(1) = (double) cmd_status;
-	  retval(0) = msg;
+	  retval(0) = OSSTREAM_STR (output_buf);
 
-	  delete [] msg;
+	  OSSTREAM_FREEZE (output_buf);
 	}
 
       unwind_protect::run ();
     }
   else
     error ("unable to start subprocess for `%s'", cmd_str.c_str ());
 
   return retval;
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -25,17 +25,16 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include <cerrno>
 #include <climits>
 #include <cstring>
 
 #include <fstream>
 #include <iostream>
-#include <strstream>
 #include <string>
 
 #ifdef HAVE_UNISTD_H
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 #include <unistd.h>
 #endif
@@ -55,16 +54,17 @@ Software Foundation, 59 Temple Place - S
 LOSE! LOSE!
 #endif
 
 #include "SLStack.h"
 
 #include "dir-ops.h"
 #include "file-ops.h"
 #include "file-stat.h"
+#include "lo-sstream.h"
 #include "oct-cmplx.h"
 #include "oct-env.h"
 #include "pathsearch.h"
 #include "str-vec.h"
 
 #include <defaults.h>
 #include "defun.h"
 #include "dirfns.h"
@@ -722,29 +722,29 @@ octave_format (std::ostream& os, const c
 
 extern int
 octave_vformat (std::ostream& os, const char *fmt, va_list args)
 {
   int retval = -1;
 
 #if defined (__GNUG__) && !CXX_ISO_COMPLIANT_LIBRARY
 
-  std::ostrstream buf;
+  OSSTREAM buf;
 
   buf.vform (fmt, args);
 
-  buf << std::ends;
+  buf << OSSTREAM_ENDS;
 
-  char *s = buf.str ();
+  std::string s = OSSTREAM_STR (buf);
+
+  OSSTREAM_FREEZE (buf);
 
   os << s;
 
-  retval = strlen (s);
-
-  delete [] s;
+  retval = s.length ();
 
 #else
 
   char *s = octave_vsnprintf (fmt, args);
 
   if (s)
     {
       os << s;
