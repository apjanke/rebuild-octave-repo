# HG changeset patch
# User Rik <rik@octave.org>
# Date 1375654294 25200
#      Sun Aug 04 15:11:34 2013 -0700
# Node ID c3c1ebfaa7dc588bf8a23378fbd3c08eb7fcd16a
# Parent  3a23cbde59d5fa1682cc161bf26efdf387529089
maint: Use common indentation for switch statement.

* scripts/general/interp1.m, scripts/geometry/delaunay.m,
scripts/help/__unimplemented__.m, scripts/image/cmunique.m,
scripts/miscellaneous/edit.m, scripts/optimization/fzero.m,
scripts/optimization/sqp.m, scripts/plot/__gnuplot_drawnow__.m,
scripts/plot/hidden.m, scripts/plot/legend.m, scripts/plot/print.m,
scripts/plot/printd.m, scripts/plot/private/__contour__.m,
scripts/plot/private/__fltk_print__.m,
scripts/plot/private/__gnuplot_print__.m,
scripts/plot/private/__go_draw_axes__.m,
scripts/plot/private/__print_parse_opts__.m, scripts/signal/periodogram.m,
scripts/sparse/bicg.m, test/slice.tst, test/switch.tst:
Use common indentation for switch statement.

diff --git a/scripts/general/interp1.m b/scripts/general/interp1.m
--- a/scripts/general/interp1.m
+++ b/scripts/general/interp1.m
@@ -211,101 +211,103 @@ function yi = interp1 (x, y, varargin)
       else
         error ("interp1: discontinuities not supported for method '%s'", method);
       endif
     endif
   endif
 
   ## Proceed with interpolating by all methods.
   switch (method)
-  case "nearest"
-    pp = mkpp ([x(1); (x(1:nx-1)+x(2:nx))/2; x(nx)], shiftdim (y, 1), szy(2:end));
-    pp.orient = "first";
+    case "nearest"
+      pp = mkpp ([x(1); (x(1:nx-1)+x(2:nx))/2; x(nx)],
+                 shiftdim (y, 1), szy(2:end));
+      pp.orient = "first";
 
-    if (ispp)
-      yi = pp;
-    else
-      yi = ppval (pp, reshape (xi, szx));
-    endif
-  case "*nearest"
-    pp = mkpp ([x(1), x(1)+[0.5:(nx-1)]*dx, x(nx)], shiftdim (y, 1), szy(2:end));
-    pp.orient = "first";
-    if (ispp)
-      yi = pp;
-    else
-      yi = ppval (pp, reshape (xi, szx));
-    endif
-  case "linear"
-    dy = diff (y);
-    dx = diff (x);
-    dx = repmat (dx, [1 size(dy)(2:end)]);
-    coefs = [(dy./dx).'(:), y(1:nx-1, :).'(:)];
-    xx = x;
+      if (ispp)
+        yi = pp;
+      else
+        yi = ppval (pp, reshape (xi, szx));
+      endif
+    case "*nearest"
+      pp = mkpp ([x(1), x(1)+[0.5:(nx-1)]*dx, x(nx)],
+                 shiftdim (y, 1), szy(2:end));
+      pp.orient = "first";
+      if (ispp)
+        yi = pp;
+      else
+        yi = ppval (pp, reshape (xi, szx));
+      endif
+    case "linear"
+      dy = diff (y);
+      dx = diff (x);
+      dx = repmat (dx, [1 size(dy)(2:end)]);
+      coefs = [(dy./dx).'(:), y(1:nx-1, :).'(:)];
+      xx = x;
 
-    if (have_jumps)
-      ## Omit zero-size intervals.
-      coefs(jumps, :) = [];
-      xx(jumps) = [];
-    endif
+      if (have_jumps)
+        ## Omit zero-size intervals.
+        coefs(jumps, :) = [];
+        xx(jumps) = [];
+      endif
 
-    pp = mkpp (xx, coefs, szy(2:end));
-    pp.orient = "first";
+      pp = mkpp (xx, coefs, szy(2:end));
+      pp.orient = "first";
 
-    if (ispp)
-      yi = pp;
-    else
-      yi = ppval (pp, reshape (xi, szx));
-    endif
+      if (ispp)
+        yi = pp;
+      else
+        yi = ppval (pp, reshape (xi, szx));
+      endif
 
-  case "*linear"
-    dy = diff (y);
-    coefs = [(dy/dx).'(:), y(1:nx-1, :).'(:)];
-    pp = mkpp (x, coefs, szy(2:end));
-    pp.orient = "first";
+    case "*linear"
+      dy = diff (y);
+      coefs = [(dy/dx).'(:), y(1:nx-1, :).'(:)];
+      pp = mkpp (x, coefs, szy(2:end));
+      pp.orient = "first";
 
-    if (ispp)
-      yi = pp;
-    else
-      yi = ppval (pp, reshape (xi, szx));
-    endif
+      if (ispp)
+        yi = pp;
+      else
+        yi = ppval (pp, reshape (xi, szx));
+      endif
 
-  case {"pchip", "*pchip", "cubic", "*cubic"}
-    if (nx == 2 || starmethod)
-      x = linspace (x(1), x(nx), ny);
-    endif
+    case {"pchip", "*pchip", "cubic", "*cubic"}
+      if (nx == 2 || starmethod)
+        x = linspace (x(1), x(nx), ny);
+      endif
 
-    if (ispp)
-      y = shiftdim (reshape (y, szy), 1);
-      yi = pchip (x, y);
-      yi.orient = "first";
-    else
-      y = shiftdim (y, 1);
-      yi = pchip (x, y, reshape (xi, szx));
-      if (! isvector (y))
-        yi = shiftdim (yi, 1);
+      if (ispp)
+        y = shiftdim (reshape (y, szy), 1);
+        yi = pchip (x, y);
+        yi.orient = "first";
+      else
+        y = shiftdim (y, 1);
+        yi = pchip (x, y, reshape (xi, szx));
+        if (! isvector (y))
+          yi = shiftdim (yi, 1);
+        endif
+      endif
+    case {"spline", "*spline"}
+      if (nx == 2 || starmethod)
+        x = linspace (x(1), x(nx), ny);
       endif
-    endif
-  case {"spline", "*spline"}
-    if (nx == 2 || starmethod)
-      x = linspace (x(1), x(nx), ny);
-    endif
 
-    if (ispp)
-      y = shiftdim (reshape (y, szy), 1);
-      yi = spline (x, y);
-      yi.orient = "first";
-    else
-      y = shiftdim (y, 1);
-      yi = spline (x, y, reshape (xi, szx));
-      if (! isvector (y))
-        yi = shiftdim (yi, 1);
+      if (ispp)
+        y = shiftdim (reshape (y, szy), 1);
+        yi = spline (x, y);
+        yi.orient = "first";
+      else
+        y = shiftdim (y, 1);
+        yi = spline (x, y, reshape (xi, szx));
+        if (! isvector (y))
+          yi = shiftdim (yi, 1);
+        endif
       endif
-    endif
-  otherwise
-    error ("interp1: invalid method '%s'", method);
+    otherwise
+      error ("interp1: invalid method '%s'", method);
   endswitch
 
   if (! ispp)
     if (! ischar (extrap))
       ## determine which values are out of range and set them to extrap,
       ## unless extrap == "extrap".
       minx = min (x(1), x(nx));
       maxx = max (x(1), x(nx));
diff --git a/scripts/geometry/delaunay.m b/scripts/geometry/delaunay.m
--- a/scripts/geometry/delaunay.m
+++ b/scripts/geometry/delaunay.m
@@ -69,48 +69,48 @@ function tri = delaunay (varargin)
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
   options = [];
 
   switch (nargin)
 
-  case 1
-    if (! ismatrix (varargin{1}) || columns (varargin{1}) != 2)
-        error ("delaunay: X must be a matrix with 2 columns");
-    else
-      x = varargin{1}(:,1);
-      y = varargin{1}(:,2);
-    endif
-  
-  case 2
-    if (isnumeric (varargin{2}))
-      x = varargin{1};
-      y = varargin{2};
-    elseif (ischar (varargin{2}) || iscellstr (varargin{2}))
-      options = varargin{2};
-      if (! ismatrix (varargin{1}) && columns (varargin{1}) != 2)
+    case 1
+      if (! ismatrix (varargin{1}) || columns (varargin{1}) != 2)
           error ("delaunay: X must be a matrix with 2 columns");
       else
         x = varargin{1}(:,1);
         y = varargin{1}(:,2);
       endif
-    else
-      error ("delaunay: OPTIONS must be a string or cell array of strings");
-    endif
+    
+    case 2
+      if (isnumeric (varargin{2}))
+        x = varargin{1};
+        y = varargin{2};
+      elseif (ischar (varargin{2}) || iscellstr (varargin{2}))
+        options = varargin{2};
+        if (! ismatrix (varargin{1}) && columns (varargin{1}) != 2)
+            error ("delaunay: X must be a matrix with 2 columns");
+        else
+          x = varargin{1}(:,1);
+          y = varargin{1}(:,2);
+        endif
+      else
+        error ("delaunay: OPTIONS must be a string or cell array of strings");
+      endif
 
-  case 3
-    x = varargin{1};
-    y = varargin{2};
-    options = varargin{3};
+    case 3
+      x = varargin{1};
+      y = varargin{2};
+      options = varargin{3};
 
-    if (! (ischar (options) || iscellstr (options)))
-      error ("delaunay: OPTIONS must be a string or cell array of strings");
-    endif
+      if (! (ischar (options) || iscellstr (options)))
+        error ("delaunay: OPTIONS must be a string or cell array of strings");
+      endif
 
   endswitch
 
   if (! (isequal(size(x),size(y))))
     error ("delaunay: X and Y must be the same size");
   endif
 
   T = delaunayn ([x(:), y(:)], options);
diff --git a/scripts/help/__unimplemented__.m b/scripts/help/__unimplemented__.m
--- a/scripts/help/__unimplemented__.m
+++ b/scripts/help/__unimplemented__.m
@@ -35,82 +35,85 @@ function txt = __unimplemented__ (fcn)
   if (nargin != 1)
     print_usage ();
   endif
 
   is_matlab_function = true;
 
   ## Some smarter cases, add more as needed.
   switch (fcn)
-
-  case {"avifile", "aviinfo", "aviread"}
-    txt = ["Basic video file support is provided in the video package. ",...
-    "See @url{http://octave.sf.net/video/}."];
+    case {"avifile", "aviinfo", "aviread"}
+      txt = ["Basic video file support is provided in the video package.  ", \
+             "See @url{http://octave.sf.net/video/}."];
 
-  case "gsvd"
-    txt = ["gsvd is not currently part of core Octave.  See the ",...
-    "linear-algebra package at ",...
-    "@url{http://octave.sourceforge.net/linear-algebra/}."];
+    case "gsvd"
+      txt = ["gsvd is not currently part of core Octave.  ", \
+             "See the linear-algebra package at ", \
+             "@url{http://octave.sourceforge.net/linear-algebra/}."];
+
+    case "funm"
+      txt = ["funm is not currently part of core Octave.  ", \
+             "See the linear-algebra package at ", \
+             "@url{http://octave.sourceforge.net/linear-algebra/}."];
 
-  case "funm"
-    txt = ["funm is not currently part of core Octave.  See the ",...
-    "linear-algebra package at @url{http://octave.sf.net/linear-algebra/}."];
-
-  case "griddedInterpolant"
-    txt = ["griddedInterpolant is not implemented.  Consider using griddata."];
+    case "griddedInterpolant"
+      txt = ["griddedInterpolant is not implemented.  ", \
+             "Consider using griddata."];
 
-  case "integral"
-    txt = ["Octave provides many routines for 1-D numerical integration.  ",...
-    "Consider quadcc, quad, quadv, quadl, quadgk."];
+    case "integral"
+      txt = ["Octave provides many routines for 1-D numerical integration.  ", \
+             "Consider quadcc, quad, quadv, quadl, quadgk."];
 
-  case "integral2"
-    txt = ["integral2 is not implemented.  Consider using dblquad."];
+    case "integral2"
+      txt = ["integral2 is not implemented.  Consider using dblquad."];
 
-  case "integral3"
-    txt = ["integral3 is not implemented.  Consider using triplequad"];
+    case "integral3"
+      txt = ["integral3 is not implemented.  Consider using triplequad"];
 
-  case "linprog"
-    txt = ["Octave does not currently provide linprog.  ",...
-    "Linear programming problems may be solved using @code{glpk}.  ",...
-    "Try @code{help glpk} for more info."];
+    case "linprog"
+      txt = ["Octave does not currently provide linprog.  ", \
+             "Linear programming problems may be solved using @code{glpk}.  ",\
+             "Try @code{help glpk} for more info."];
 
-  case "matlabrc"
-    txt = ["matlabrc is not implemented.  ",...
-           'Octave uses the file ".octaverc" instead.'];
+    case "matlabrc"
+      txt = ["matlabrc is not implemented.  ", \
+             'Octave uses the file ".octaverc" instead.'];
 
-  case {"ode113", "ode15i", "ode15s", "ode23", "ode23s", "ode23t", "ode23tb", "ode45", "odeget", "odeset"}
-    txt = ["Octave provides lsode for solving differential equations.  ",...
-    "For more information try @code{help lsode}.  ",...
-    "Matlab-compatible ODE functions are provided by the odepkg package.  ",...
-    "See @url{http://octave.sourceforge.net/odepkg/}."];
+    case {"ode113", "ode15i", "ode15s", "ode23", "ode23s", "ode23t", \
+          "ode23tb", "ode45", "odeget", "odeset"}
+      txt = ["Octave provides lsode for solving differential equations.  ", \
+             "For more information try @code{help lsode}.  ", \
+             "Matlab-compatible ODE functions are provided by the odepkg ", \
+             "package.  See @url{http://octave.sourceforge.net/odepkg/}."];
 
-  case "startup"
-    txt = ["startup is not implemented.  ",...
-           'Octave uses the file ".octaverc" instead.'];
+    case "startup"
+      txt = ["startup is not implemented.  ", \
+             'Octave uses the file ".octaverc" instead.'];
 
-  case "quad2d"
-    txt = ["quad2d is not implemented.  Consider using dblquad."];
+    case "quad2d"
+      txt = ["quad2d is not implemented.  Consider using dblquad."];
 
-  case {"xlsread", "xlsfinfo", "xlswrite", "wk1read", "wk1finfo", "wk1write"}
-    txt = ["Functions for spreadsheet style I/O (.xls .xlsx .sxc .ods .dbf .wk1 etc.) " , ...
-    "are provided in the io package. ",...
-    "See @url{http://octave.sf.net/io/}."];
+    case {"xlsread", "xlsfinfo", "xlswrite", "wk1read", "wk1finfo", "wk1write"}
+      txt = ["Functions for spreadsheet style I/O ", \
+             "(.xls .xlsx .sxc .ods .dbf .wk1 etc.) " ,  \
+             "are provided in the io package. ", \
+             "See @url{http://octave.sf.net/io/}."];
 
-  otherwise
-    if (ismember (fcn, missing_functions ()))
-      txt = sprintf ("the '%s' function is not yet implemented in Octave", fcn);
-    else
-      is_matlab_function = false;
-      txt = "";
-    endif
+    otherwise
+      if (ismember (fcn, missing_functions ()))
+        txt = ["the '" fcn "' function is not yet implemented in Octave"];
+      else
+        is_matlab_function = false;
+        txt = "";
+      endif
   endswitch
 
   if (is_matlab_function)
-    txt = [txt, "\n\n@noindent\nPlease read ",...
-           "@url{http://www.octave.org/missing.html} to learn how ",...
+    txt = [txt, "\n\n@noindent\nPlease read ", \
+           "@url{http://www.octave.org/missing.html} to learn how ", \
            "you can contribute missing functionality."];
     txt = __makeinfo__ (txt);
   endif
 
   if (nargout == 0)
     warning ("Octave:missing-function", "%s", txt);
   endif
 
diff --git a/scripts/image/cmunique.m b/scripts/image/cmunique.m
--- a/scripts/image/cmunique.m
+++ b/scripts/image/cmunique.m
@@ -73,22 +73,22 @@ function [Y, newmap] = cmunique (X, map)
     [newmap,i,j] = unique (map, "rows");  # calculate unique colormap
     if (isfloat (X))
       Y = j(X);               # find new indices
     else
       Y = j(double (X) + 1);  # find new indices, switch to 1-based index
     endif
   else
     switch (size (X,3))
-      case (1)
+      case 1
         ## I case
         [newmap,i,j] = unique (X);               # calculate unique colormap
         newmap = repmat (newmap,1,3);            # get a RGB colormap
         Y = reshape (j, rows (X), columns (X));  # Y is j reshaped
-      case (3)
+      case 3
         ## RGB case
         ## build a map with all values
         map = [X(:,:,1)(:), X(:,:,2)(:), X(:,:,3)(:)];
         [newmap,i,j] = unique (map, "rows");     # calculate unique colormap
         Y = reshape (j, rows (X), columns (X));  # Y is j reshaped
       otherwise
         error ("cmunique: X is not a valid image");
     endswitch
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -177,64 +177,64 @@ function ret = edit (varargin)
     endif
   elseif (nargin == 2)
     ## User has supplied two arguments, these could be two file names,
     ## or a combination of editor state name and new value for that state,
     ## so first check for the various states
     statevar = varargin{1};
     stateval = varargin{2};
     switch (toupper (statevar))
-    case "EDITOR"
-      FUNCTION.EDITOR = stateval;
-      return;
-    case "HOME"
-      if (! isempty (stateval) && stateval(1) == "~")
-        stateval = [ default_home, stateval(2:end) ];
-      endif
-      FUNCTION.HOME = stateval;
-      return;
-    case "AUTHOR"
-      FUNCTION.AUTHOR = stateval;
-      return;
-    case "EMAIL"
-      FUNCTION.EMAIL = stateval;
-      return;
-    case "LICENSE"
-      FUNCTION.LICENSE = stateval;
-      return;
-    case "MODE"
-      if (strcmp (stateval, "sync") || strcmp (stateval, "async"))
-        FUNCTION.MODE = stateval;
-      else
-        error ('edit: expected "edit MODE sync|async"');
-      endif
-      return
-    case "EDITINPLACE"
-      if (ischar (stateval))
-        if (strcmpi (stateval, "true"))
-          stateval = true;
-        elseif (strcmpi (stateval, "false"))
-          stateval = false;
+      case "EDITOR"
+        FUNCTION.EDITOR = stateval;
+        return;
+      case "HOME"
+        if (! isempty (stateval) && stateval(1) == "~")
+          stateval = [ default_home, stateval(2:end) ];
+        endif
+        FUNCTION.HOME = stateval;
+        return;
+      case "AUTHOR"
+        FUNCTION.AUTHOR = stateval;
+        return;
+      case "EMAIL"
+        FUNCTION.EMAIL = stateval;
+        return;
+      case "LICENSE"
+        FUNCTION.LICENSE = stateval;
+        return;
+      case "MODE"
+        if (strcmp (stateval, "sync") || strcmp (stateval, "async"))
+          FUNCTION.MODE = stateval;
         else
-          stateval = eval (stateval);
+          error ('edit: expected "edit MODE sync|async"');
+        endif
+        return
+      case "EDITINPLACE"
+        if (ischar (stateval))
+          if (strcmpi (stateval, "true"))
+            stateval = true;
+          elseif (strcmpi (stateval, "false"))
+            stateval = false;
+          else
+            stateval = eval (stateval);
+          endif
         endif
-      endif
-      FUNCTION.EDITINPLACE = stateval;
-      return
-    case "GET"
-      if (isfield (FUNCTION, toupper (stateval)))
-        ret = FUNCTION.(toupper (stateval));
-      else
-        ret = FUNCTION;
-      endif
-      return
-    otherwise
-      ## If none of the states match, assume both inputs are
-      ## actually both file names to be opened
-      editfilelist = varargin;
+        FUNCTION.EDITINPLACE = stateval;
+        return
+      case "GET"
+        if (isfield (FUNCTION, toupper (stateval)))
+          ret = FUNCTION.(toupper (stateval));
+        else
+          ret = FUNCTION;
+        endif
+        return
+      otherwise
+        ## If none of the states match, assume both inputs are
+        ## actually both file names to be opened
+        editfilelist = varargin;
     endswitch
   elseif (nargin > 2)
     if (iscellstr (varargin))
       editfilelist = varargin;
     else
       error ("edit: if supplying more than one input all inputs must be strings containing field names to open.");
     endif
   endif
diff --git a/scripts/optimization/fzero.m b/scripts/optimization/fzero.m
--- a/scripts/optimization/fzero.m
+++ b/scripts/optimization/fzero.m
@@ -191,80 +191,80 @@ function [x, fval, info, output] = fzero
     u = b; fu = fb;
   endif
 
   d = e = u;
   fd = fe = fu;
   mba = mu*(b - a);
   while (niter < maxiter && nfev < maxfev)
     switch (itype)
-    case 1
-      ## The initial test.
-      if (b - a <= 2*(2 * abs (u) * eps + tolx))
-        x = u; fval = fu;
-        info = 1;
-        break;
-      endif
-      if (abs (fa) <= 1e3*abs (fb) && abs (fb) <= 1e3*abs (fa))
-        ## Secant step.
-        c = u - (a - b) / (fa - fb) * fu;
-      else
+      case 1
+        ## The initial test.
+        if (b - a <= 2*(2 * abs (u) * eps + tolx))
+          x = u; fval = fu;
+          info = 1;
+          break;
+        endif
+        if (abs (fa) <= 1e3*abs (fb) && abs (fb) <= 1e3*abs (fa))
+          ## Secant step.
+          c = u - (a - b) / (fa - fb) * fu;
+        else
+          ## Bisection step.
+          c = 0.5*(a + b);
+        endif
+        d = u; fd = fu;
+        itype = 5;
+      case {2, 3}
+        l = length (unique ([fa, fb, fd, fe]));
+        if (l == 4)
+          ## Inverse cubic interpolation.
+          q11 = (d - e) * fd / (fe - fd);
+          q21 = (b - d) * fb / (fd - fb);
+          q31 = (a - b) * fa / (fb - fa);
+          d21 = (b - d) * fd / (fd - fb);
+          d31 = (a - b) * fb / (fb - fa);
+          q22 = (d21 - q11) * fb / (fe - fb);
+          q32 = (d31 - q21) * fa / (fd - fa);
+          d32 = (d31 - q21) * fd / (fd - fa);
+          q33 = (d32 - q22) * fa / (fe - fa);
+          c = a + q31 + q32 + q33;
+        endif
+        if (l < 4 || sign (c - a) * sign (c - b) > 0)
+          ## Quadratic interpolation + newton.
+          a0 = fa;
+          a1 = (fb - fa)/(b - a);
+          a2 = ((fd - fb)/(d - b) - a1) / (d - a);
+          ## Modification 1: this is simpler and does not seem to be worse.
+          c = a - a0/a1;
+          if (a2 != 0)
+            c = a - a0/a1;
+            for i = 1:itype
+              pc = a0 + (a1 + a2*(c - b))*(c - a);
+              pdc = a1 + a2*(2*c - a - b);
+              if (pdc == 0)
+                c = a - a0/a1;
+                break;
+              endif
+              c -= pc/pdc;
+            endfor
+          endif
+        endif
+        itype += 1;
+      case 4
+        ## Double secant step.
+        c = u - 2*(b - a)/(fb - fa)*fu;
+        ## Bisect if too far.
+        if (abs (c - u) > 0.5*(b - a))
+          c = 0.5 * (b + a);
+        endif
+        itype = 5;
+      case 5
         ## Bisection step.
-        c = 0.5*(a + b);
-      endif
-      d = u; fd = fu;
-      itype = 5;
-    case {2, 3}
-      l = length (unique ([fa, fb, fd, fe]));
-      if (l == 4)
-        ## Inverse cubic interpolation.
-        q11 = (d - e) * fd / (fe - fd);
-        q21 = (b - d) * fb / (fd - fb);
-        q31 = (a - b) * fa / (fb - fa);
-        d21 = (b - d) * fd / (fd - fb);
-        d31 = (a - b) * fb / (fb - fa);
-        q22 = (d21 - q11) * fb / (fe - fb);
-        q32 = (d31 - q21) * fa / (fd - fa);
-        d32 = (d31 - q21) * fd / (fd - fa);
-        q33 = (d32 - q22) * fa / (fe - fa);
-        c = a + q31 + q32 + q33;
-      endif
-      if (l < 4 || sign (c - a) * sign (c - b) > 0)
-        ## Quadratic interpolation + newton.
-        a0 = fa;
-        a1 = (fb - fa)/(b - a);
-        a2 = ((fd - fb)/(d - b) - a1) / (d - a);
-        ## Modification 1: this is simpler and does not seem to be worse.
-        c = a - a0/a1;
-        if (a2 != 0)
-          c = a - a0/a1;
-          for i = 1:itype
-            pc = a0 + (a1 + a2*(c - b))*(c - a);
-            pdc = a1 + a2*(2*c - a - b);
-            if (pdc == 0)
-              c = a - a0/a1;
-              break;
-            endif
-            c -= pc/pdc;
-          endfor
-        endif
-      endif
-      itype += 1;
-    case 4
-      ## Double secant step.
-      c = u - 2*(b - a)/(fb - fa)*fu;
-      ## Bisect if too far.
-      if (abs (c - u) > 0.5*(b - a))
         c = 0.5 * (b + a);
-      endif
-      itype = 5;
-    case 5
-      ## Bisection step.
-      c = 0.5 * (b + a);
-      itype = 2;
+        itype = 2;
     endswitch
 
     ## Don't let c come too close to a or b.
     delta = 2*0.7*(2 * abs (u) * eps + tolx);
     if ((b - a) <= 2*delta)
       c = (a + b)/2;
     else
       c = max (a + delta, min (b - delta, c));
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -198,48 +198,48 @@ function [x, obj, info, iter, nf, lambda
   endif
   if (rows (x0) == 1)
     x0 = x0';
   endif
 
   have_hess = 0;
   if (iscell (objf))
     switch (numel (objf))
-     case 1
-       obj_fun = objf{1};
-       obj_grd = @ (x) fd_obj_grd (x, obj_fun);
-     case 2
-       obj_fun = objf{1};
-       obj_grd = objf{2};
-     case 3
-       obj_fun = objf{1};
-       obj_grd = objf{2};
-       obj_hess = objf{3};
-       have_hess = 1;
-     otherwise
-      error ("sqp: invalid objective function specification");
+      case 1
+        obj_fun = objf{1};
+        obj_grd = @ (x) fd_obj_grd (x, obj_fun);
+      case 2
+        obj_fun = objf{1};
+        obj_grd = objf{2};
+      case 3
+        obj_fun = objf{1};
+        obj_grd = objf{2};
+        obj_hess = objf{3};
+        have_hess = 1;
+      otherwise
+        error ("sqp: invalid objective function specification");
     endswitch
   else
     obj_fun = objf;   # No cell array, only obj_fun set
     obj_grd = @ (x) fd_obj_grd (x, obj_fun);
   endif
 
   ce_fun = @empty_cf;
   ce_grd = @empty_jac;
   if (nargin > 2)
     if (iscell (cef))
       switch (numel (cef))
-       case 1
-         ce_fun = cef{1};
-         ce_grd = @ (x) fd_ce_jac (x, ce_fun);
-       case 2
-         ce_fun = cef{1};
-         ce_grd = cef{2};
-       otherwise
-         error ("sqp: invalid equality constraint function specification");
+        case 1
+          ce_fun = cef{1};
+          ce_grd = @ (x) fd_ce_jac (x, ce_fun);
+        case 2
+          ce_fun = cef{1};
+          ce_grd = cef{2};
+        otherwise
+          error ("sqp: invalid equality constraint function specification");
       endswitch
     elseif (! isempty (cef))
       ce_fun = cef;   # No cell array, only constraint equality function set
       ce_grd = @ (x) fd_ce_jac (x, ce_fun);
     endif
   endif
 
   ci_fun = @empty_cf;
@@ -257,23 +257,23 @@ function [x, obj, info, iter, nf, lambda
       globals.cifcn = cif;
     endif
 
     if (nargin < 5 || (nargin > 5 && isempty (lb) && isempty (ub)))
       ## constraint inequality function only without any bounds
       ci_grd = @ (x) fd_ci_jac (x, globals.cifcn);
       if (iscell (cif))
         switch (length (cif))
-         case {1}
-           ci_fun = cif{1};
-         case {2}
-           ci_fun = cif{1};
-           ci_grd = cif{2};
-        otherwise
-          error ("sqp: invalid inequality constraint function specification");
+          case 1
+            ci_fun = cif{1};
+          case 2
+            ci_fun = cif{1};
+            ci_grd = cif{2};
+          otherwise
+           error ("sqp: invalid inequality constraint function specification");
         endswitch
       elseif (! isempty (cif))
         ci_fun = cif;   # No cell array, only constraint inequality function set
       endif
     else
       ## constraint inequality function with bounds present
       lb_idx = ub_idx = true (size (x0));
       ub_grad = - (lb_grad = eye (rows (x0)));
diff --git a/scripts/plot/__gnuplot_drawnow__.m b/scripts/plot/__gnuplot_drawnow__.m
--- a/scripts/plot/__gnuplot_drawnow__.m
+++ b/scripts/plot/__gnuplot_drawnow__.m
@@ -204,21 +204,21 @@ function enhanced = gnuplot_set_term (pl
           endif
           switch (term)
             case terminals_with_size
               size_str = sprintf ("size %.12g,%.12g", gnuplot_size);
             case "tikz"
               size_str = sprintf ("size %gin,%gin", gnuplot_size);
             case "dumb"
               new_stream = 1;
-              if (! isempty (getenv ("COLUMNS")) && ! isempty (getenv ("LINES")))
+              if (!isempty (getenv ("COLUMNS")) && !isempty (getenv ("LINES")))
                 ## Let dumb use full text screen size (minus prompt lines).
                 n = sprintf ("%i", -2 - length (find (sprintf ("%s", PS1) == "\n")));
                 ## n = the number of times \n appears in PS1
-                size_str = ["size ", getenv("COLUMNS"), ",", getenv("LINES"), n];
+                size_str = ["size " getenv("COLUMNS") "," getenv("LINES") n];
               else
                 ## Use the gnuplot default.
                 size_str = "";
               endif
             case {"aqua", "fig", "corel"}
               size_str = sprintf ("size %g %g", gnuplot_size);
             case "dxf"
               size_str = "";
diff --git a/scripts/plot/hidden.m b/scripts/plot/hidden.m
--- a/scripts/plot/hidden.m
+++ b/scripts/plot/hidden.m
@@ -51,28 +51,28 @@ function state = hidden (mode = "toggle"
 
   for h = (get (gca (), "children")).';
     htype = get (h, "type");
     if (strcmp (htype, "surface"))
       fc = get (h, "facecolor");
       if ((! ischar (fc) && is_white (fc))
           || (ischar (fc) && strcmp (fc, "none")))
         switch (mode)
-        case "on"
-          set (h, "facecolor", "w");
-        case "off"
-          set (h, "facecolor", "none");
-        case "toggle"
-          if (ischar (fc))
+          case "on"
             set (h, "facecolor", "w");
-            mode = "on";
-          else
+          case "off"
             set (h, "facecolor", "none");
-            mode = "off";
-          endif
+          case "toggle"
+            if (ischar (fc))
+              set (h, "facecolor", "w");
+              mode = "on";
+            else
+              set (h, "facecolor", "none");
+              mode = "off";
+            endif
         endswitch
       endif
     endif
   endfor
 
   if (nargout > 0)
     state = mode;
   endif
diff --git a/scripts/plot/legend.m b/scripts/plot/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/legend.m
@@ -823,66 +823,66 @@ function [hlegend2, hobjects2, hplot2, t
         end_unwind_protect
 
         ## Now write the line segments and place the text objects correctly
         xk = 0;
         yk = 0;
         for k = 1 : numel (hplots)
           hobjects = [hobjects, texthandle(k)];
           switch (get (hplots(k), "type"))
-          case "line"
-            color = get (hplots(k), "color");
-            style = get (hplots(k), "linestyle");
-            if (! strcmp (style, "none"))
-              l1 = line ("xdata", ([xoffset, xoffset + linelength] + xk * xstep) / lpos(3),
-                         "ydata", [1, 1] .* (lpos(4) - yoffset - yk * ystep) / lpos(4),
-                         "color", color, "linestyle", style, "marker", "none",
-                         "userdata", hplots (k));
-              hobjects = [hobjects, l1];
-            endif
-            marker = get (hplots(k), "marker");
-            if (! strcmp (marker, "none"))
-              l1 = line ("xdata", (xoffset + 0.5 * linelength  + xk * xstep) / lpos(3),
-                         "ydata", (lpos(4) - yoffset - yk * ystep) / lpos(4),
-                         "color", color, "linestyle", "none", "marker", marker,
-                         "markeredgecolor", get (hplots (k), "markeredgecolor"),
-                         "markerfacecolor", get (hplots (k), "markerfacecolor"),
-                         "markersize", get (hplots (k), "markersize"),
-                         "userdata", hplots (k));
-              hobjects = [hobjects, l1];
-            endif
+            case "line"
+              color = get (hplots(k), "color");
+              style = get (hplots(k), "linestyle");
+              if (! strcmp (style, "none"))
+                l1 = line ("xdata", ([xoffset, xoffset + linelength] + xk * xstep) / lpos(3),
+                           "ydata", [1, 1] .* (lpos(4) - yoffset - yk * ystep) / lpos(4),
+                           "color", color, "linestyle", style, "marker", "none",
+                           "userdata", hplots (k));
+                hobjects = [hobjects, l1];
+              endif
+              marker = get (hplots(k), "marker");
+              if (! strcmp (marker, "none"))
+                l1 = line ("xdata", (xoffset + 0.5 * linelength  + xk * xstep) / lpos(3),
+                           "ydata", (lpos(4) - yoffset - yk * ystep) / lpos(4),
+                           "color", color, "linestyle", "none", "marker", marker,
+                           "markeredgecolor", get (hplots (k), "markeredgecolor"),
+                           "markerfacecolor", get (hplots (k), "markerfacecolor"),
+                           "markersize", get (hplots (k), "markersize"),
+                           "userdata", hplots (k));
+                hobjects = [hobjects, l1];
+              endif
 
-            addlistener (hplots(k), "color",
-                         {@updateline, hlegend, linelength});
-            addlistener (hplots(k), "linestyle",
-                         {@updateline, hlegend, linelength});
-            addlistener (hplots(k), "marker",
-                         {@updateline, hlegend, linelength});
-            addlistener (hplots(k), "markeredgecolor",
-                         {@updateline, hlegend, linelength});
-            addlistener (hplots(k), "markerfacecolor",
-                         {@updateline, hlegend, linelength});
-            addlistener (hplots(k), "markersize",
-                         {@updateline, hlegend, linelength});
-            addlistener (hplots(k), "displayname",
-                         {@updateline, hlegend, linelength});
-          case "patch"
-            facecolor = get (hplots(k), "facecolor");
-            edgecolor = get (hplots(k), "edgecolor");
-            cdata = get (hplots(k), "cdata");
-            if (! strcmp (facecolor, "none") || ! strcmp (edgecolor, "none"))
-              p1 = patch ("xdata", ([0, linelength, linelength, 0] +
-                                   xoffset + xk * xstep) / lpos(3),
-                         "ydata", (lpos(4) - yoffset -
-                                   [yk-0.3, yk-0.3, yk+0.3, yk+0.3] .* ystep) / lpos(4),
-                         "facecolor", facecolor, "edgecolor", edgecolor,
-                         "cdata", cdata, "userdata", hplots(k));
-              hobjects = [hobjects, p1];
-            endif
-          case "surface"
+              addlistener (hplots(k), "color",
+                           {@updateline, hlegend, linelength});
+              addlistener (hplots(k), "linestyle",
+                           {@updateline, hlegend, linelength});
+              addlistener (hplots(k), "marker",
+                           {@updateline, hlegend, linelength});
+              addlistener (hplots(k), "markeredgecolor",
+                           {@updateline, hlegend, linelength});
+              addlistener (hplots(k), "markerfacecolor",
+                           {@updateline, hlegend, linelength});
+              addlistener (hplots(k), "markersize",
+                           {@updateline, hlegend, linelength});
+              addlistener (hplots(k), "displayname",
+                           {@updateline, hlegend, linelength});
+            case "patch"
+              facecolor = get (hplots(k), "facecolor");
+              edgecolor = get (hplots(k), "edgecolor");
+              cdata = get (hplots(k), "cdata");
+              if (! strcmp (facecolor, "none") || ! strcmp (edgecolor, "none"))
+                p1 = patch ("xdata", ([0, linelength, linelength, 0] +
+                                     xoffset + xk * xstep) / lpos(3),
+                           "ydata", (lpos(4) - yoffset -
+                                     [yk-0.3, yk-0.3, yk+0.3, yk+0.3] .* ystep) / lpos(4),
+                           "facecolor", facecolor, "edgecolor", edgecolor,
+                           "cdata", cdata, "userdata", hplots(k));
+                hobjects = [hobjects, p1];
+              endif
+            case "surface"
           endswitch
           set (texthandle (k), "position", [(txoffset + xk * xstep) / lpos(3), ...
                                             (lpos(4) - yoffset - yk * ystep) / lpos(4)]);
           if (strcmp (orientation, "vertical"))
             yk++;
             if (yk > num1)
               yk = 0;
               xk++;
@@ -1013,22 +1013,22 @@ function updatelegend (h, d)
     unwind_protect
       hax = getfield (get (h, "userdata"), "handle");
       [hplots, text_strings] = __getlegenddata__ (h);
       position = get (h, "unmodified_axes_position");
       outerposition = get (h, "unmodified_axes_outerposition");
       units = get (hax, "units");
       set (hax, "units", "points");
       switch (get (hax, "activepositionproperty"))
-      case "position"
-        set (hax, "outerposition", outerposition);
-        set (hax, "position", position);
-      case "outerposition"
-        set (hax, "position", position);
-        set (hax, "outerposition", outerposition);
+        case "position"
+          set (hax, "outerposition", outerposition);
+          set (hax, "position", position);
+        case "outerposition"
+          set (hax, "position", position);
+          set (hax, "outerposition", outerposition);
       endswitch
       set (hax, "units", units);
       h = legend (hax, hplots, get (h, "string"));
     unwind_protect_cleanup
       recursive = false;
     end_unwind_protect
   endif
 
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -406,20 +406,20 @@ function print (varargin)
           fontsize = fontsize * opts.scalefontsize;
         endif
         set (h(ishandle (h)), "fontsize", fontsize);
       endif
     endif
 
     ## call the graphcis toolkit print script
     switch (get (opts.figure, "__graphics_toolkit__"))
-    case "gnuplot"
-      opts = __gnuplot_print__ (opts);
-    otherwise
-      opts = __fltk_print__ (opts);
+      case "gnuplot"
+        opts = __gnuplot_print__ (opts);
+      otherwise
+        opts = __fltk_print__ (opts);
     endswitch
 
   unwind_protect_cleanup
     ## restore modified properties
     if (isstruct (props))
       for n = numel (props):-1:1
         if (ishandle (props(n).h))
           set (props(n).h, props(n).name, props(n).value{1});
@@ -492,28 +492,28 @@ function cmd = epstool (opts, filein, fi
              "print.m: eps preview may not be combined with -tight");
   endif
   if (! isempty (opts.preview) || opts.tight_flag)
     if (! isempty (opts.epstool_binary))
       if (opts.tight_flag)
         cmd = "--copy --bbox";
       elseif (! isempty (opts.preview))
         switch (opts.preview)
-        case "tiff"
-          cmd = sprintf ("--add-%s-preview --device tiffg3", opts.preview);
-        case {"tiff6u", "tiff6p", "metafile"}
-          cmd = sprintf ("--add-%s-preview --device bmpgray", opts.preview);
-        case {"tiff4", "interchange"}
-          cmd = sprintf ("--add-%s-preview", opts.preview);
-        case "pict"
-          cmd = sprintf ("--add-%s-preview --mac-single", opts.preview);
-        otherwise
-          error ("print:invalidpreview",
-                 "print.m: epstool cannot include preview for format '%s'",
-                 opts.preview);
+          case "tiff"
+            cmd = sprintf ("--add-%s-preview --device tiffg3", opts.preview);
+          case {"tiff6u", "tiff6p", "metafile"}
+            cmd = sprintf ("--add-%s-preview --device bmpgray", opts.preview);
+          case {"tiff4", "interchange"}
+            cmd = sprintf ("--add-%s-preview", opts.preview);
+          case "pict"
+            cmd = sprintf ("--add-%s-preview --mac-single", opts.preview);
+          otherwise
+            error ("print:invalidpreview",
+                   "print.m: epstool cannot include preview for format '%s'",
+                   opts.preview);
         endswitch
         if (! isempty (opts.ghostscript.resolution))
           cmd = sprintf ("%s --dpi %d", cmd, opts.ghostscript.resolution);
         endif
       else
         cmd = "";
       endif
       if (! isempty (cmd))
@@ -614,25 +614,25 @@ endfunction
 
 function latex_standalone (opts)
   n = find (opts.name == ".", 1, "last");
   if (! isempty (n))
     opts.name = opts.name(1:n-1);
   endif
   latexfile = strcat (opts.name, ".tex");
   switch (opts.devopt)
-  case {"pdflatexstandalone"}
-    packages = "\\usepackage{graphicx,color}";
-    graphicsfile = strcat (opts.name, "-inc.pdf");
-  case {"pslatexstandalone"}
-    packages = "\\usepackage{epsfig,color}";
-    graphicsfile = strcat (opts.name, "-inc.ps");
-  otherwise
-    packages = "\\usepackage{epsfig,color}";
-    graphicsfile = strcat (opts.name, "-inc.eps");
+    case {"pdflatexstandalone"}
+      packages = "\\usepackage{graphicx,color}";
+      graphicsfile = strcat (opts.name, "-inc.pdf");
+    case {"pslatexstandalone"}
+      packages = "\\usepackage{epsfig,color}";
+      graphicsfile = strcat (opts.name, "-inc.ps");
+    otherwise
+      packages = "\\usepackage{epsfig,color}";
+      graphicsfile = strcat (opts.name, "-inc.eps");
   endswitch
   papersize = sprintf ("\\usepackage[papersize={%.2fbp,%.2fbp},text={%.2fbp,%.2fbp}]{geometry}",
                        opts.canvas_size, opts.canvas_size);
   prepend = {"\\documentclass{minimal}";
              packages;
              papersize;
              "\\begin{document}";
              "\\centering"};
diff --git a/scripts/plot/printd.m b/scripts/plot/printd.m
--- a/scripts/plot/printd.m
+++ b/scripts/plot/printd.m
@@ -47,35 +47,35 @@ function pr_out = printd (obj, filename)
   [pf, tempf, mag] = mkstemp ("oct-XXXXXX", 1);  # Safe version of tmpnam()
   fprintf (pf, "%s", disp (obj));
   frewind (pf);
 
   ## It seems best to only use convert for image output.  Its ps and pdf
   ## are badly rendered.
   opt = lower (opt);
   switch (opt)
-    case {"pdf"}
+    case "pdf"
       enscr = sprintf (
                        "enscript --no-header -o %s.ps %s ; ps2pdf %s.ps %s.pdf; mv %s.pdf %s;exit",...
                        tempf, tempf, tempf, tempf, tempf, filename);
       system (enscr);
       delete ([tempf ".ps"]);
-    case {"ps"}
+    case "ps"
       enscr = sprintf ("enscript --no-header -o %s %s ; exit", filename, tempf);
       system (enscr);
-    case {"eps"}
+    case "eps"
       enscr = sprintf (
                        "enscript --no-header -o %s.ps %s ; ps2eps --ignoreBB %s.ps; mv %s.eps %s; exit",...
                        tempf, tempf, tempf, tempf, filename);
       system (enscr);
       delete ([tempf ".ps"]);
-    case {"txt"}
+    case "txt"
       enscr = sprintf ("cp %s %s", tempf, filename);
       system (enscr);
-    case {"jpg" "jpeg"}
+    case {"jpg", "jpeg"}
       enscr = sprintf ("convert -trim txt:%s  jpg:%s", tempf, filename);
       system (enscr);
     otherwise
       fclose (pf);
       delete (tempf);
       error ("Unknown conversion type: %s.\nOptions are: pdf ps eps txt jpg jpeg", opt);
 
   endswitch
diff --git a/scripts/plot/private/__contour__.m b/scripts/plot/private/__contour__.m
--- a/scripts/plot/private/__contour__.m
+++ b/scripts/plot/private/__contour__.m
@@ -445,20 +445,20 @@ function update_data (h, d, prop = "")
   persistent recursive = false;
 
   if (!recursive)
     recursive = true;
 
     delete (get (h, "children"));
 
     switch (prop)
-    case "levellist"
-      set (h, "levellistmode", "manual")
-    case "levelstep"
-      set (h, "levelstepmode", "manual")
+      case "levellist"
+        set (h, "levellistmode", "manual")
+      case "levelstep"
+        set (h, "levelstepmode", "manual")
     endswitch
 
     if (strcmpi (get (h, "levellistmode"), "manual")
         && ! strcmp (prop, "levelstep"))
       lvl = get (h, "levellist");
     elseif (strcmpi (get (h, "levelstepmode"), "manual"))
       z = get (h, "zdata");
       lvs = get (h, "levelstep");
diff --git a/scripts/plot/private/__fltk_print__.m b/scripts/plot/private/__fltk_print__.m
--- a/scripts/plot/private/__fltk_print__.m
+++ b/scripts/plot/private/__fltk_print__.m
@@ -34,121 +34,121 @@ function opts = __fltk_print__ (opts)
     fig2dev_devices = {"pstex", "mf", "emf"};
   else
     fig2dev_devices = {"pstex", "mf"};
   endif
 
   gl2ps_device = {};
   pipeline = {};
   switch (lower (opts.devopt))
-  case {"eps", "eps2", "epsc", "epsc2"}
-    ## format GL2PS_EPS
-    gl2ps_device = {"eps"};
-    ## FIXME - use epstool to tighten bbox and provide preview.
-    pipeline = {opts.epstool_cmd(opts, "-", opts.name)};
-  case {"epslatex", "pslatex", "pdflatex", "epslatexstandalone", ...
-        "pslatexstandalone", "pdflatexstandalone"}
-    ## format GL2PS_TEX
-    n = find (opts.devopt == "l", 1);
-    suffix = opts.devopt(1:n-1);
-    dot = find (opts.name == ".", 1, "last");
-    if ((! isempty (dot))
-        && any (strcmpi (opts.name(dot:end), ...
-                {strcat(".", suffix), ".tex", "."})))
-      name = opts.name(1:dot-1);
-      if (dot < numel (opts.name)
-          && any (strcmpi (opts.name(dot+1:end), {"eps", "ps", "pdf"})))
-        ## If user provides eps/ps/pdf suffix, use it.
-        suffix = opts.name(dot+1:end);
+    case {"eps", "eps2", "epsc", "epsc2"}
+      ## format GL2PS_EPS
+      gl2ps_device = {"eps"};
+      ## FIXME - use epstool to tighten bbox and provide preview.
+      pipeline = {opts.epstool_cmd(opts, "-", opts.name)};
+    case {"epslatex", "pslatex", "pdflatex", "epslatexstandalone", ...
+          "pslatexstandalone", "pdflatexstandalone"}
+      ## format GL2PS_TEX
+      n = find (opts.devopt == "l", 1);
+      suffix = opts.devopt(1:n-1);
+      dot = find (opts.name == ".", 1, "last");
+      if ((! isempty (dot))
+          && any (strcmpi (opts.name(dot:end), ...
+                  {strcat(".", suffix), ".tex", "."})))
+        name = opts.name(1:dot-1);
+        if (dot < numel (opts.name)
+            && any (strcmpi (opts.name(dot+1:end), {"eps", "ps", "pdf"})))
+          ## If user provides eps/ps/pdf suffix, use it.
+          suffix = opts.name(dot+1:end);
+        endif
+      else
+        error ("print:invalid-suffix", 
+               "invalid suffix '%s' for device '%s'.",
+               opts.name(dot:end), lower (opts.devopt));
       endif
-    else
-      error ("print:invalid-suffix", 
-             "invalid suffix '%s' for device '%s'.",
-             opts.name(dot:end), lower (opts.devopt));
-    endif
-    gl2ps_device = {sprintf("%snotxt", lower (suffix))};
-    gl2ps_device{2} = "tex";
-    if (dos_shell)
-      ## FIXME - this will only work on MinGW with the MSYS shell
-      pipeline = {sprintf("cat > %s-inc.%s", name, suffix)};
-      pipeline{2} = sprintf ("cat > %s.tex", name);
-    else
-      pipeline = {sprintf("cat > %s-inc.%s", name, suffix)};
-      pipeline{2} = sprintf ("cat > %s.tex", name);
-    endif
-  case "tikz"
-    ## format GL2PS_PGF
-    gl2ps_device = {"pgf"};
-    pipeline = {sprintf("cat > %s", opts.name)};
-  case "svg"
-    ## format GL2PS_SVG
-    gl2ps_device = {"svg"};
-    pipeline = {sprintf("cat > %s", opts.name)};
-  case fig2dev_devices
-    cmd_pstoedit = opts.pstoedit_cmd (opts, "fig");
-    cmd_fig2dev = opts.fig2dev_cmd (opts, opts.devopt);
-    if (strcmp (opts.devopt, "pstex"))
-      [~, ~, ext] = fileparts (opts.name);
-      if (any (strcmpi (ext, {".ps", ".tex", "."})))
-        opts.name = opts.name(1:end-numel(ext));
+      gl2ps_device = {sprintf("%snotxt", lower (suffix))};
+      gl2ps_device{2} = "tex";
+      if (dos_shell)
+        ## FIXME - this will only work on MinGW with the MSYS shell
+        pipeline = {sprintf("cat > %s-inc.%s", name, suffix)};
+        pipeline{2} = sprintf ("cat > %s.tex", name);
+      else
+        pipeline = {sprintf("cat > %s-inc.%s", name, suffix)};
+        pipeline{2} = sprintf ("cat > %s.tex", name);
       endif
-      opts.name = strcat (opts.name, ".ps");
-      cmd = sprintf ("%s | %s > %s", cmd_pstoedit, cmd_fig2dev, opts.name);
-      gl2ps_device = {"eps"};
-      pipeline = {cmd};
-      cmd_fig2dev = opts.fig2dev_cmd (opts, "pstex_t");
-      gl2ps_device{2} = "eps";
-      pipeline{2} = sprintf ("%s | %s > %s", cmd_pstoedit,
-                             cmd_fig2dev, strrep(opts.name, ".ps", ".tex"));
-    else
-      cmd = sprintf ("%s | %s > %s", cmd_pstoedit, cmd_fig2dev, opts.name);
+    case "tikz"
+      ## format GL2PS_PGF
+      gl2ps_device = {"pgf"};
+      pipeline = {sprintf("cat > %s", opts.name)};
+    case "svg"
+      ## format GL2PS_SVG
+      gl2ps_device = {"svg"};
+      pipeline = {sprintf("cat > %s", opts.name)};
+    case fig2dev_devices
+      cmd_pstoedit = opts.pstoedit_cmd (opts, "fig");
+      cmd_fig2dev = opts.fig2dev_cmd (opts, opts.devopt);
+      if (strcmp (opts.devopt, "pstex"))
+        [~, ~, ext] = fileparts (opts.name);
+        if (any (strcmpi (ext, {".ps", ".tex", "."})))
+          opts.name = opts.name(1:end-numel(ext));
+        endif
+        opts.name = strcat (opts.name, ".ps");
+        cmd = sprintf ("%s | %s > %s", cmd_pstoedit, cmd_fig2dev, opts.name);
+        gl2ps_device = {"eps"};
+        pipeline = {cmd};
+        cmd_fig2dev = opts.fig2dev_cmd (opts, "pstex_t");
+        gl2ps_device{2} = "eps";
+        pipeline{2} = sprintf ("%s | %s > %s", cmd_pstoedit,
+                               cmd_fig2dev, strrep(opts.name, ".ps", ".tex"));
+      else
+        cmd = sprintf ("%s | %s > %s", cmd_pstoedit, cmd_fig2dev, opts.name);
+        gl2ps_device = {"eps"};
+        pipeline = {cmd};
+      endif
+    case "aifm"
+      cmd = opts.pstoedit_cmd (opts, "ps2ai");
       gl2ps_device = {"eps"};
-      pipeline = {cmd};
-    endif
-  case "aifm"
-    cmd = opts.pstoedit_cmd (opts, "ps2ai");
-    gl2ps_device = {"eps"};
-    pipeline = {sprintf("%s > %s", cmd, opts.name)};
-  case {"dxf", "emf", "fig", "hpgl"}
-    cmd = opts.pstoedit_cmd (opts);
-    gl2ps_device = {"eps"};
-    pipeline = {sprintf("%s > %s", cmd, opts.name)};
-  case {"corel", "gif"}
-    error ("print:unsupporteddevice",
-           "print.m: %s output is not available for the FLTK graphics toolkit",
-           upper (opts.devopt));
-  case opts.ghostscript.device
-    opts.ghostscript.source = "-";
-    opts.ghostscript.output = opts.name;
-    if (opts.send_to_printer)
-      opts.unlink(strcmp (opts.unlink, opts.ghostscript.output)) = [];
-      opts.ghostscript.output = "-";
-    endif
-    [cmd_gs, cmd_cleanup] = __ghostscript__ (opts.ghostscript);
-    if (opts.send_to_printer || isempty (opts.name))
-      cmd_lpr = opts.lpr_cmd (opts);
-      cmd = sprintf ("%s | %s", cmd_gs, cmd_lpr);
-    else
-      cmd = sprintf ("%s", cmd_gs);
-    endif
-    if (! isempty (cmd_cleanup))
+      pipeline = {sprintf("%s > %s", cmd, opts.name)};
+    case {"dxf", "emf", "fig", "hpgl"}
+      cmd = opts.pstoedit_cmd (opts);
       gl2ps_device = {"eps"};
-      if (dos_shell)
-        pipeline = {sprintf("%s & %s", cmd, cmd_cleanup)};
-      else
-        pipeline = {sprintf("%s ; %s", cmd, cmd_cleanup)};
+      pipeline = {sprintf("%s > %s", cmd, opts.name)};
+    case {"corel", "gif"}
+      error ("print:unsupporteddevice",
+             "print.m: %s output is not available for the FLTK graphics toolkit",
+             upper (opts.devopt));
+    case opts.ghostscript.device
+      opts.ghostscript.source = "-";
+      opts.ghostscript.output = opts.name;
+      if (opts.send_to_printer)
+        opts.unlink(strcmp (opts.unlink, opts.ghostscript.output)) = [];
+        opts.ghostscript.output = "-";
       endif
-    else
-      gl2ps_device = {"eps"};
-      pipeline = {cmd};
-    endif
-  otherwise
-    error (sprintf ("print:no%soutput", opts.devopt),
-           "print.m: %s output is not available for GL2PS output",
-           upper (opts.devopt));
+      [cmd_gs, cmd_cleanup] = __ghostscript__ (opts.ghostscript);
+      if (opts.send_to_printer || isempty (opts.name))
+        cmd_lpr = opts.lpr_cmd (opts);
+        cmd = sprintf ("%s | %s", cmd_gs, cmd_lpr);
+      else
+        cmd = sprintf ("%s", cmd_gs);
+      endif
+      if (! isempty (cmd_cleanup))
+        gl2ps_device = {"eps"};
+        if (dos_shell)
+          pipeline = {sprintf("%s & %s", cmd, cmd_cleanup)};
+        else
+          pipeline = {sprintf("%s ; %s", cmd, cmd_cleanup)};
+        endif
+      else
+        gl2ps_device = {"eps"};
+        pipeline = {cmd};
+      endif
+    otherwise
+      error (sprintf ("print:no%soutput", opts.devopt),
+             "print.m: %s output is not available for GL2PS output",
+             upper (opts.devopt));
   endswitch
 
   opts.pipeline = pipeline;
 
   ## Tell gl2ps to use different rendering options for 2D plots
   haxes = findall (opts.figure, "type", "axes");
   vw = get (haxes, "view");
   if (iscell (vw))
diff --git a/scripts/plot/private/__gnuplot_print__.m b/scripts/plot/private/__gnuplot_print__.m
--- a/scripts/plot/private/__gnuplot_print__.m
+++ b/scripts/plot/private/__gnuplot_print__.m
@@ -44,113 +44,114 @@ function opts = __gnuplot_print__ (opts)
   endif
   ## The axes-label and tick-label spacing is determined by
   ## the font spec given in "set terminal ..."
   gp_opts = font_spec (opts);
 
   pipeline = "";
 
   switch (lower (opts.devopt))
-  case {"eps", "eps2", "epsc", "epsc2"}
-    if (any (strcmp (opts.devopt, {"eps", "epsc"})))
-      gp_opts = [gp_opts " level1"];
-    endif
-    if (opts.tight_flag || ! isempty (opts.preview))
-      tmp_file = strcat (tmpnam (), ".eps");
-      eps_drawnow (opts, tmp_file, gp_opts);
-      if (dos_shell)
-        cleanup = [" & del " strrep(tmp_file, '/', '\')];
+    case {"eps", "eps2", "epsc", "epsc2"}
+      if (any (strcmp (opts.devopt, {"eps", "epsc"})))
+        gp_opts = [gp_opts " level1"];
+      endif
+      if (opts.tight_flag || ! isempty (opts.preview))
+        tmp_file = strcat (tmpnam (), ".eps");
+        eps_drawnow (opts, tmp_file, gp_opts);
+        if (dos_shell)
+          cleanup = [" & del " strrep(tmp_file, '/', '\')];
+        else
+          cleanup = [" ; rm " tmp_file];
+        endif
+        pipeline = {sprintf("%s %s",
+                            opts.epstool_cmd (opts, tmp_file, opts.name),
+                            cleanup)};
       else
-        cleanup = [" ; rm " tmp_file];
+        eps_drawnow (opts, opts.name, gp_opts);
       endif
-      pipeline = {sprintf("%s %s",
-                          opts.epstool_cmd (opts, tmp_file, opts.name),
-                          cleanup)};
-    else
-      eps_drawnow (opts, opts.name, gp_opts);
-    endif
-  case {"epslatex", "pslatex", "pstex", "epslatexstandalone"}
-    dot = find (opts.name == ".", 1, "last");
-    n = find (opts.devopt == "l", 1);
-    suffix = opts.devopt(1:n-1);
-    if (! isempty (dot))
-      if (any (strcmpi (opts.name(dot:end), {strcat(".", suffix), ".tex", "."})))
-        name = opts.name(1:dot-1);
+    case {"epslatex", "pslatex", "pstex", "epslatexstandalone"}
+      dot = find (opts.name == ".", 1, "last");
+      n = find (opts.devopt == "l", 1);
+      suffix = opts.devopt(1:n-1);
+      if (! isempty (dot))
+        if (any (strcmpi (opts.name(dot:end), {["." suffix], ".tex", "."})))
+          name = opts.name(1:dot-1);
+        else
+          error ("print:invalid-suffix", 
+                 "invalid suffix '%s' for device '%s'.",
+                 opts.name(dot:end), lower (opts.devopt));
+        endif
+      endif
+      if (strfind (opts.devopt, "standalone"))
+        term = sprintf ("%s ",
+                        strrep (opts.devopt, "standalone", " standalone"));
       else
-        error ("print:invalid-suffix", 
-               "invalid suffix '%s' for device '%s'.",
-               opts.name(dot:end), lower (opts.devopt));
+        term = sprintf ("%s ", opts.devopt);
+      endif
+      if (__gnuplot_has_feature__ ("epslatex_implies_eps_filesuffix"))
+        suffix = "tex";
+      else
+        ## Gnuplot 4.0 wants a ".eps" suffix.
+        suffix = "eps";
       endif
-    endif
-    if (strfind (opts.devopt, "standalone"))
-      term = sprintf ("%s ",
-                      strrep (opts.devopt, "standalone", " standalone"));
-    else
-      term = sprintf ("%s ", opts.devopt);
-    endif
-    if (__gnuplot_has_feature__ ("epslatex_implies_eps_filesuffix"))
-      suffix = "tex";
-    else
-      ## Gnuplot 4.0 wants a ".eps" suffix.
-      suffix = "eps";
-    endif
-    local_drawnow ([term " " gp_opts],
-                   strcat (name, ".", suffix), opts);
-  case "tikz"
-    if (__gnuplot_has_terminal__ ("tikz"))
-      local_drawnow (["lua tikz " gp_opts], opts.name, opts);
-    else
-      error (sprintf ("print:no%soutput", opts.devopt),
-             "print.m: '%s' output is not available for gnuplot-%s",
-             upper (opts.devopt), __gnuplot_version__ ());
-    endif
-  case "svg"
-    local_drawnow (["svg dynamic " gp_opts], opts.name, opts);
-  case {"aifm", "corel", "eepic", "emf", "fig"}
-    local_drawnow ([opts.devopt " " gp_opts], opts.name, opts);
-  case {"pdfcairo", "pngcairo"}
-    if (__gnuplot_has_terminal__ (opts.devopt))
+      local_drawnow ([term " " gp_opts],
+                     strcat (name, ".", suffix), opts);
+    case "tikz"
+      if (__gnuplot_has_terminal__ ("tikz"))
+        local_drawnow (["lua tikz " gp_opts], opts.name, opts);
+      else
+        error (sprintf ("print:no%soutput", opts.devopt),
+               "print.m: '%s' output is not available for gnuplot-%s",
+               upper (opts.devopt), __gnuplot_version__ ());
+      endif
+    case "svg"
+      local_drawnow (["svg dynamic " gp_opts], opts.name, opts);
+    case {"aifm", "corel", "eepic", "emf", "fig"}
+      local_drawnow ([opts.devopt " " gp_opts], opts.name, opts);
+    case {"pdfcairo", "pngcairo"}
+      if (__gnuplot_has_terminal__ (opts.devopt))
+        local_drawnow ([opts.devopt " " gp_opts], opts.name, opts);
+      else
+        error (sprintf ("print:no%soutput", opts.devopt),
+               "print.m: '%s' output is not available for gnuplot-%s",
+               upper (opts.devopt), __gnuplot_version__ ());
+      endif
+    case {"canvas", "dxf", "hpgl", "mf", "gif", "pstricks", "texdraw"}
       local_drawnow ([opts.devopt " " gp_opts], opts.name, opts);
-    else
+    case opts.ghostscript.device
+      gp_opts = font_spec (opts, "devopt", "eps");
+      opts.ghostscript.output = opts.name;
+      opts.ghostscript.source = strcat (tmpnam (), ".eps");
+      eps_drawnow (opts, opts.ghostscript.source, gp_opts);
+      [cmd_gs, cmd_cleanup] = __ghostscript__ (opts.ghostscript);
+      if (opts.send_to_printer || isempty (opts.name))
+        cmd_lpr = opts.lpr_cmd (opts);
+        cmd = [cmd_gs " | " cmd_lpr];
+      else
+        cmd = cmd_gs;
+      endif
+      if (dos_shell)
+        cmd = sprintf ("%s & del %s", cmd,
+                       strrep (opts.ghostscript.source, '/', '\'));
+      else
+        cmd = sprintf ("%s ; rm %s", cmd, opts.ghostscript.source);
+      endif
+      if (! isempty (cmd_cleanup))
+        if (dos_shell)
+          pipeline = {[cmd " & " cmd_cleanup]};
+        else
+          pipeline = {[cmd " ; " cmd_cleanup]};
+        endif
+      else
+        pipeline = {cmd};
+      endif
+    otherwise
       error (sprintf ("print:no%soutput", opts.devopt),
-             "print.m: '%s' output is not available for gnuplot-%s",
-             upper (opts.devopt), __gnuplot_version__ ());
-    endif
-  case {"canvas", "dxf", "hpgl", "mf", "gif", "pstricks", "texdraw"}
-    local_drawnow ([opts.devopt " " gp_opts], opts.name, opts);
-  case opts.ghostscript.device
-    gp_opts = font_spec (opts, "devopt", "eps");
-    opts.ghostscript.output = opts.name;
-    opts.ghostscript.source = strcat (tmpnam (), ".eps");
-    eps_drawnow (opts, opts.ghostscript.source, gp_opts);
-    [cmd_gs, cmd_cleanup] = __ghostscript__ (opts.ghostscript);
-    if (opts.send_to_printer || isempty (opts.name))
-      cmd_lpr = opts.lpr_cmd (opts);
-      cmd = [cmd_gs " | " cmd_lpr];
-    else
-      cmd = cmd_gs;
-    endif
-    if (dos_shell)
-      cmd = sprintf ("%s & del %s", cmd, strrep (opts.ghostscript.source, '/', '\'));
-    else
-      cmd = sprintf ("%s ; rm %s", cmd, opts.ghostscript.source);
-    endif
-    if (! isempty (cmd_cleanup))
-      if (dos_shell)
-        pipeline = {[cmd " & " cmd_cleanup]};
-      else
-        pipeline = {[cmd " ; " cmd_cleanup]};
-      endif
-    else
-      pipeline = {cmd};
-    endif
-  otherwise
-    error (sprintf ("print:no%soutput", opts.devopt),
-           "print.m: %s output is not available for the Gnuplot graphics toolkit",
-           upper (opts.devopt));
+             "print.m: %s output is not available for the Gnuplot graphics toolkit",
+             upper (opts.devopt));
   endswitch
 
 
   opts.pipeline = pipeline;
 
   for n = 1:numel (pipeline)
     if (opts.debug)
       fprintf ("gnuplot-pipeline: '%s'\n", pipeline{n});
@@ -193,106 +194,106 @@ function local_drawnow (term, file, opts
 endfunction
 
 function f = font_spec (opts, varargin)
   for n = 1:2:numel (varargin)
     opts.(varargin{n}) = varargin{n+1};
   endfor
   f = "";
   switch (opts.devopt)
-  case "cgm"
-    if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ('font "%s,%d"', opts.font, opts.fontsize);
-    elseif (! isempty (opts.font))
-      f = sprintf ('font "%s"', opts.font);
-    elseif (! isempty (opts.fontsize))
-      f = sprintf ("%d", opts.fontsize);
-    endif
-  case {"eps", "eps2", "epsc", "epsc2"}
-    ## Gnuplot renders fonts as half their specification, which
-    ## results in a tight spacing for the axes-labels and tick-labels.
-    ## Compensate for the half scale. This will produce the proper
-    ## spacing for the requested fontsize.
-    if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ('font "%s,%d"', opts.font, 2 * opts.fontsize);
-    elseif (! isempty (opts.font))
-      f = sprintf ('font "%s"', opts.font);
-    elseif (! isempty (opts.fontsize))
-      f = sprintf ("%d", 2 * opts.fontsize);
-    endif
-  case "svg"
-    if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      fontsize = round (opts.fontsize * 0.75);
-      f = sprintf ('fname "%s" fsize %d', opts.font, fontsize);
-    elseif (! isempty (opts.font))
-      f = sprintf ('fname "%s"', opts.font);
-    elseif (! isempty (opts.fontsize))
-      fontsize = round (opts.fontsize * 0.75);
-      f = sprintf ("%s fsize %d", f, fontsize);
-    endif
-  case "pdf"
-    if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ('font "%s,%d"', opts.font, opts.fontsize);
-    elseif (! isempty (opts.font))
-      f = sprintf ('font "%s"', opts.font);
-    elseif (! isempty (opts.fontsize))
-      f = sprintf ("fsize %d", f, opts.fontsize);
-    endif
-  case {"pdfcairo", "pngcairo"}
-    if (! isempty (opts.font))
-      f = sprintf ('font "%s"', opts.font);
-    endif
-  case {"epslatex", "epslatexstandalone"}
-    if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ('font "%s,%d"', opts.font, opts.fontsize);
-    elseif (! isempty (opts.font))
-      f = sprintf ('font "%s"', opts.font);
-    elseif (! isempty (opts.fontsize))
-      f = sprintf ("%d", opts.fontsize);
-    endif
-  case "pslatex"
-    if (! isempty (opts.fontsize))
-      f = sprintf ("%d", opts.fontsize);
-    endif
-  case {"gif", "jpeg", "png"}
-    if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ('font "%s ,%d"', opts.font, opts.fontsize);
-    elseif (! isempty (opts.font))
-      f = sprintf ('font "%s"', opts.font);
-    elseif (! isempty (opts.fontsize))
-      f = sprintf ('font "%d"', opts.fontsize);
-    endif
-  case "emf"
-    if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ('"%s" %d', opts.font, opts.fontsize);
-    elseif (! isempty (opts.font))
-      f = sprintf ('"%s"', opts.font);
-    elseif (! isempty (opts.fontsize))
-      f = sprintf ("%d", opts.fontsize);
-    endif
-  case "canvas"
-    if (! isempty (opts.fontsize))
-      f = sprintf ("fsize %d", opts.fontsize);
-    endif
-  case {"aifm", "corel"}
-    if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ("%s %d", opts.font, opts.fontsize);
-    elseif (! isempty (opts.font))
-      f = sprintf ("%s", opts.font);
-    elseif (! isempty (opts.fontsize))
-      f = sprintf ("%d", opts.fontsize);
-    endif
-  case "fig"
-    if (! isempty (opts.font) && ! isempty (opts.fontsize))
-      f = sprintf ("font %s fontsize %d", opts.font, opts.fontsize);
-    elseif (! isempty (opts.font))
-      f = sprintf ("font %s", opts.font);
-    elseif (! isempty (opts.fontsize))
-      f = sprintf ("fontsize %d", opts.fontsize);
-    endif
+    case "cgm"
+      if (! isempty (opts.font) && ! isempty (opts.fontsize))
+        f = sprintf ('font "%s,%d"', opts.font, opts.fontsize);
+      elseif (! isempty (opts.font))
+        f = sprintf ('font "%s"', opts.font);
+      elseif (! isempty (opts.fontsize))
+        f = sprintf ("%d", opts.fontsize);
+      endif
+    case {"eps", "eps2", "epsc", "epsc2"}
+      ## Gnuplot renders fonts as half their specification, which
+      ## results in a tight spacing for the axes-labels and tick-labels.
+      ## Compensate for the half scale. This will produce the proper
+      ## spacing for the requested fontsize.
+      if (! isempty (opts.font) && ! isempty (opts.fontsize))
+        f = sprintf ('font "%s,%d"', opts.font, 2 * opts.fontsize);
+      elseif (! isempty (opts.font))
+        f = sprintf ('font "%s"', opts.font);
+      elseif (! isempty (opts.fontsize))
+        f = sprintf ("%d", 2 * opts.fontsize);
+      endif
+    case "svg"
+      if (! isempty (opts.font) && ! isempty (opts.fontsize))
+        fontsize = round (opts.fontsize * 0.75);
+        f = sprintf ('fname "%s" fsize %d', opts.font, fontsize);
+      elseif (! isempty (opts.font))
+        f = sprintf ('fname "%s"', opts.font);
+      elseif (! isempty (opts.fontsize))
+        fontsize = round (opts.fontsize * 0.75);
+        f = sprintf ("%s fsize %d", f, fontsize);
+      endif
+    case "pdf"
+      if (! isempty (opts.font) && ! isempty (opts.fontsize))
+        f = sprintf ('font "%s,%d"', opts.font, opts.fontsize);
+      elseif (! isempty (opts.font))
+        f = sprintf ('font "%s"', opts.font);
+      elseif (! isempty (opts.fontsize))
+        f = sprintf ("fsize %d", f, opts.fontsize);
+      endif
+    case {"pdfcairo", "pngcairo"}
+      if (! isempty (opts.font))
+        f = sprintf ('font "%s"', opts.font);
+      endif
+    case {"epslatex", "epslatexstandalone"}
+      if (! isempty (opts.font) && ! isempty (opts.fontsize))
+        f = sprintf ('font "%s,%d"', opts.font, opts.fontsize);
+      elseif (! isempty (opts.font))
+        f = sprintf ('font "%s"', opts.font);
+      elseif (! isempty (opts.fontsize))
+        f = sprintf ("%d", opts.fontsize);
+      endif
+    case "pslatex"
+      if (! isempty (opts.fontsize))
+        f = sprintf ("%d", opts.fontsize);
+      endif
+    case {"gif", "jpeg", "png"}
+      if (! isempty (opts.font) && ! isempty (opts.fontsize))
+        f = sprintf ('font "%s ,%d"', opts.font, opts.fontsize);
+      elseif (! isempty (opts.font))
+        f = sprintf ('font "%s"', opts.font);
+      elseif (! isempty (opts.fontsize))
+        f = sprintf ('font "%d"', opts.fontsize);
+      endif
+    case "emf"
+      if (! isempty (opts.font) && ! isempty (opts.fontsize))
+        f = sprintf ('"%s" %d', opts.font, opts.fontsize);
+      elseif (! isempty (opts.font))
+        f = sprintf ('"%s"', opts.font);
+      elseif (! isempty (opts.fontsize))
+        f = sprintf ("%d", opts.fontsize);
+      endif
+    case "canvas"
+      if (! isempty (opts.fontsize))
+        f = sprintf ("fsize %d", opts.fontsize);
+      endif
+    case {"aifm", "corel"}
+      if (! isempty (opts.font) && ! isempty (opts.fontsize))
+        f = sprintf ("%s %d", opts.font, opts.fontsize);
+      elseif (! isempty (opts.font))
+        f = sprintf ("%s", opts.font);
+      elseif (! isempty (opts.fontsize))
+        f = sprintf ("%d", opts.fontsize);
+      endif
+    case "fig"
+      if (! isempty (opts.font) && ! isempty (opts.fontsize))
+        f = sprintf ("font %s fontsize %d", opts.font, opts.fontsize);
+      elseif (! isempty (opts.font))
+        f = sprintf ("font %s", opts.font);
+      elseif (! isempty (opts.fontsize))
+        f = sprintf ("fontsize %d", opts.fontsize);
+      endif
   endswitch
 endfunction
 
 function [h, fontsize] = get_figure_text_objs (opts)
   h = findall (opts.figure, "-property", "fontsize");
   hp = get (h, "parent");
   if (iscell (hp))
     hp = cell2mat (hp);
@@ -301,14 +302,14 @@ function [h, fontsize] = get_figure_text
   ## legend axes.  These will be handled by the fontsize listener.
   is_legend_key_string = strcmp (get (hp, "tag"), "legend") ...
                        & isprop (hp, "string") ...
                        & isprop (hp, "location") ...
                        & strcmp (get (hp, "type"), "axes");
   h(is_legend_key_string) = [];
   fontsize = get (h, "fontsize");
   switch (numel (fontsize))
-  case 0
-    fontsize = {};
-  case 1
-    fontsize = {fontsize};
+    case 0
+      fontsize = {};
+    case 1
+      fontsize = {fontsize};
   endswitch
 endfunction
diff --git a/scripts/plot/private/__go_draw_axes__.m b/scripts/plot/private/__go_draw_axes__.m
--- a/scripts/plot/private/__go_draw_axes__.m
+++ b/scripts/plot/private/__go_draw_axes__.m
@@ -1325,34 +1325,36 @@ function __go_draw_axes__ (h, plot_strea
           endif
 
           if (ischar (obj.string))
             num_lines = rows (obj.string);
           else
             num_lines = numel (obj.string);
           endif
           switch (valign)
-            ## Text offset in characters. This relies on gnuplot for font metrics.
+            ## Text offset in characters. Relies on gnuplot for font metrics.
             case "top"
               dy = -0.5;
             case "cap"
               dy = -0.5;
             case "middle"
               dy = 0.5 * (num_lines - 1);
             case "baseline"
               dy = 0.5 + (num_lines - 1);
             case "bottom"
               dy = 0.5 + (num_lines - 1);
           endswitch
-          ## Gnuplot's Character units are different for x/y and vary with fontsize. The aspect ratio
-          ## of 1:1.7 was determined by experiment to work for eps/ps/etc. For the MacOS aqua terminal
-          ## a value of 2.5 is needed. However, the difference is barely noticable.
+          ## Gnuplot's Character units are different for x/y and vary with
+          ## fontsize. The aspect ratio of 1:1.7 was determined by experiment
+          ## to work for eps/ps/etc. For the MacOS aqua terminal a value of 2.5
+          ## is needed. However, the difference is barely noticable.
           dx_and_dy = [(-dy * sind (angle)), (dy * cosd (angle))] .* [1.7 1];
 
-          ## FIXME - Multiline text produced the gnuplot "warning: ft_render: skipping glyph"
+          ## FIXME: Multiline text produced the gnuplot
+          ##        "warning: ft_render: skipping glyph"
           if (nd == 3)
             ## This produces the desired vertical alignment in 3D.
             fprintf (plot_stream,
                      "set label \"%s\" at %s %.15e,%.15e,%.15e %s rotate by %f offset character %f,%f %s %s front %s;\n",
                      undo_string_escapes (label), units, lpos(1),
                      lpos(2), lpos(3), halign, angle, dx_and_dy, fontspec,
                      __do_enhanced_option__ (enhanced, obj), colorspec);
           else
@@ -1967,29 +1969,29 @@ function [pt, pt2, obj] = gnuplot_pointt
         pt2 = "13";
       case "^"
         pt = "8";
         pt2 = "9";
       case "v"
         pt = "10";
         pt2 = "11";
       case ">"
-        ## FIXME -- should be triangle pointing right, use triangle pointing up
+        ## FIXME: should be triangle pointing right, use triangle pointing up
         pt = "8";
         pt2 = "9";
       case "<"
-        ## FIXME -- should be triangle pointing left, use triangle pointing down
+        ## FIXME: should be triangle pointing left, use triangle pointing down
         pt = "10";
         pt2 = "11";
       case {"pentagram", "p"}
-        ## FIXME -- should be pentagram, using pentagon
+        ## FIXME: should be pentagram, using pentagon
         pt = "14";
         pt2 = "15";
       case {"hexagram", "h"}
-        ## FIXME -- should be 6 pt start, using "*" instead
+        ## FIXME: should be 6 pt start, using "*" instead
         pt = pt2 = "3";
       case "none"
         pt = pt2 = "";
       otherwise
         pt = pt2 = "";
     endswitch
   else
     pt = pt2 = "";
diff --git a/scripts/plot/private/__print_parse_opts__.m b/scripts/plot/private/__print_parse_opts__.m
--- a/scripts/plot/private/__print_parse_opts__.m
+++ b/scripts/plot/private/__print_parse_opts__.m
@@ -574,40 +574,40 @@ function [papersize, paperposition] = gs
   endif
 
   if ((! strcmp (papertype, "<custom>")) && (strcmp (paperorientation, "portrait")))
     ## For portrait use the ghostscript name
     papersize = papertype;
     papersize(papersize=="-") = "";
     papersize = strrep (papersize, "us", "");
     switch (papersize)
-    case "a"
-      papersize = "letter";
-    case {"b", "tabloid"}
-      papersize = "11x17";
-    case {"c", "d", "e"}
-      papersize = strcat ("arch", papersize);
+      case "a"
+        papersize = "letter";
+      case {"b", "tabloid"}
+        papersize = "11x17";
+      case {"c", "d", "e"}
+        papersize = strcat ("arch", papersize);
     endswitch
     if (strncmp (papersize, "arch", 4))
       papersize(end) = upper (papersize(end));
     endif
   endif
 
 endfunction
 
 function value = convert2points (value, units)
-    switch (units)
+  switch (units)
     case "inches"
       value = value * 72;
     case "centimeters"
       value = value * 72 / 2.54;
     case "normalized"
       error ("print:customnormalized",
              "print.m: papersize=='<custom>' and paperunits='normalized' may not be combined");
-    endswitch
+  endswitch
 endfunction
 
 function device_list = gs_device_list ();
   ## Graphics formats/languages, not priners.
   device_list = {"bmp16"; "bmp16m"; "bmp256"; "bmp32b"; "bmpgray"; ...
                  "epswrite"; "jpeg"; "jpegcymk"; "jpeggray"; "pbm"; ...
                  "pbmraw"; "pcx16"; "pcx24b"; "pcx256"; "pcx2up"; ...
                  "pcxcmyk"; "pcxgray"; "pcxmono"; "pdfwrite"; "pgm"; ...
diff --git a/scripts/signal/periodogram.m b/scripts/signal/periodogram.m
--- a/scripts/signal/periodogram.m
+++ b/scripts/signal/periodogram.m
@@ -69,24 +69,24 @@ function [pxx, f] = periodogram (x, vara
 
   nfft = []; fs = []; range = []; window = [];
   j = 1;
   for k = 1:length (varargin)
     if (ischar (varargin{k}))
       range = varargin{k};
     else
       switch (j)
-      case 1
-        window = varargin{k};
-      case 2
-        nfft   = varargin{k};
-      case 3
-        fs     = varargin{k};
-      case 4
-        range  = varargin{k};
+        case 1
+          window = varargin{k};
+        case 2
+          nfft   = varargin{k};
+        case 3
+          fs     = varargin{k};
+        case 4
+          range  = varargin{k};
       endswitch
       j++;
     endif
   endfor
 
   [r, c] = size (x);
   if (r == 1)
     r = c;
diff --git a/scripts/sparse/bicg.m b/scripts/sparse/bicg.m
--- a/scripts/sparse/bicg.m
+++ b/scripts/sparse/bicg.m
@@ -229,20 +229,20 @@ endfunction;
 %! maxit = 15;
 %! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n);
 %! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n);
 %! [x, flag, relres, iter, resvec] = bicg (A, b, tol, maxit, M1, M2);
 %! assert (x, ones (size (b)), 1e-7);
 
 %!function y = afun (x, t, a)
 %!  switch (t)
-%!   case "notransp"
-%!     y = a * x;
-%!   case "transp"
-%!     y = a' * x;
+%!    case "notransp"
+%!      y = a * x;
+%!    case "transp"
+%!      y = a' * x;
 %!  endswitch
 %!endfunction
 %!
 %!test
 %! n = 100;
 %! A = spdiags ([-2*ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
 %! b = sum (A, 2);
 %! tol = 1e-8;
diff --git a/test/slice.tst b/test/slice.tst
--- a/test/slice.tst
+++ b/test/slice.tst
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %!function x = set_slice (size, dim, slice)
 %!  x = ones (size);
-%!  switch dim
+%!  switch (dim)
 %!    case 11
 %!      x(slice) = 2;
 %!    case 21
 %!      x(slice, :) = 2;
 %!    case 22
 %!      x(:, slice) = 2;
 %!    case 31
 %!      x(slice, :, :) = 2;
diff --git a/test/switch.tst b/test/switch.tst
--- a/test/switch.tst
+++ b/test/switch.tst
@@ -16,40 +16,40 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 %!test
 %! a = 1;
 %! b = 2;
 %! c = 3;
 %!
-%! switch 0 case 1 x = a; case 2 x = b; otherwise x = c; endswitch
-%! switch 1 case 1 y = a; case 2 y = b; otherwise y = c; endswitch
-%! switch 2 case 1 z = a; case 2 z = b; otherwise z = c; endswitch
-%! switch 3 case 1 p = a; case 2 p = b; otherwise p = c; endswitch
+%! switch (0) case 1 x = a; case 2 x = b; otherwise x = c; endswitch
+%! switch (1) case 1 y = a; case 2 y = b; otherwise y = c; endswitch
+%! switch (2) case 1 z = a; case 2 z = b; otherwise z = c; endswitch
+%! switch (3) case 1 p = a; case 2 p = b; otherwise p = c; endswitch
 %!
 %! assert (x == c && y == a && z == b && p == c);
 
 %!test
 %! a = 1;
 %! b = 2;
 %! c = 3;
 %!
 %! x = zeros (1, 4);
 %!
 %! k = 1;
 %!
 %! for i = 0:3
 %! switch (i)
 %!   case a
-%!    x(k) = a;
+%!     x(k) = a;
 %!   case b
-%!    x(k) = b;
+%!     x(k) = b;
 %!   otherwise
-%!    x(k) = c;
+%!     x(k) = c;
 %!   endswitch
 %!   k++;
 %! endfor
 %!
 %! assert (all (x == [3, 1, 2, 3]));
 
 %!test
 %! a = 1;
@@ -57,30 +57,30 @@
 %! c = 3;
 %!
 %! x = zeros (1, 4);
 %!
 %! k = 1;
 %!
 %! for i = 0:3
 %!   switch (i)
-%!   case a
-%!    x(k) = a;
+%!     case a
+%!       x(k) = a;
 %!   endswitch
 %!   k++;
 %! endfor
 %!
 %! assert (all (x == [0, 1, 0, 0]));
 
 %!test
 %! a = 1;
 %!
-%! switch 1
-%! otherwise
-%!   a = 2;
+%! switch (1)
+%!   otherwise
+%!     a = 2;
 %! endswitch
 %!
 %! assert (a == 2);
 
 
 %!error <syntax error> eval ("switch endswitch")
 
 %!error <syntax error> eval ("switch case endswitch")
