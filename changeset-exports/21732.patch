# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1463597909 14400
#      Wed May 18 14:58:29 2016 -0400
# Node ID 6a1eded903559e4f813d2c5ed5ac60dc4554f785
# Parent  3dfec4c1eb8bdfa9f19172176915fabee3b3797f
use namespace for system env class

* oct-env.h, oct-env.cc: Put env class in octave::sys namespace.
Change all uses.

diff --git a/libgui/src/files-dock-widget.cc b/libgui/src/files-dock-widget.cc
--- a/libgui/src/files-dock-widget.cc
+++ b/libgui/src/files-dock-widget.cc
@@ -818,17 +818,17 @@ files_dock_widget::notice_settings (cons
   if (_sync_octave_dir)
     display_directory (_octave_dir);  // sync browser to octave dir
 
 }
 
 void
 files_dock_widget::popdownmenu_home (bool)
 {
-  QString dir = QString::fromStdString (octave_env::get_home_directory ());
+  QString dir = QString::fromStdString (octave::sys::env::get_home_directory ());
 
   if (dir.isEmpty ())
     dir = QDir::homePath ();
 
   set_current_directory (dir);
 }
 
 void
diff --git a/libgui/src/octave-gui.cc b/libgui/src/octave-gui.cc
--- a/libgui/src/octave-gui.cc
+++ b/libgui/src/octave-gui.cc
@@ -102,17 +102,17 @@ message_handler (QtMsgType, const char *
 // If START_GUI is false, we still set up the QApplication so that we
 // can use Qt widgets for plot windows.
 
 int
 octave_start_gui (int argc, char *argv[], bool start_gui)
 {
   octave_thread_manager::block_interrupt_signal ();
 
-  std::string show_gui_msgs = octave_env::getenv ("OCTAVE_SHOW_GUI_MESSAGES");
+  std::string show_gui_msgs = octave::sys::env::getenv ("OCTAVE_SHOW_GUI_MESSAGES");
 
   // Installing our handler suppresses the messages.
   if (show_gui_msgs.empty ())
     qInstallMsgHandler (message_handler);
 
 #if defined (HAVE_QT_GRAPHICS)
   install___init_qt___functions ();
 
@@ -158,19 +158,19 @@ octave_start_gui (int argc, char *argv[]
   if (start_gui)
     {
       // update network-settings
       resource_manager::update_network_settings ();
 
       // We provide specific terminal capabilities, so ensure that TERM is
       // always set appropriately
 #if defined (__WIN32__) && ! defined (__CYGWIN__)
-      octave_env::putenv ("TERM", "cygwin");
+      octave::sys::env::putenv ("TERM", "cygwin");
 #else
-      octave_env::putenv ("TERM", "xterm");
+      octave::sys::env::putenv ("TERM", "xterm");
 #endif
 
       // shortcut manager
       shortcut_manager::init_data ();
     }
 
   // Force left-to-right alignment (see bug #46204)
   application.setLayoutDirection (Qt::LeftToRight);
diff --git a/libgui/src/octave-qt-link.cc b/libgui/src/octave-qt-link.cc
--- a/libgui/src/octave-qt-link.cc
+++ b/libgui/src/octave-qt-link.cc
@@ -584,28 +584,28 @@ octave_qt_link::do_delete_debugger_point
 
 bool
 octave_qt_link::file_in_path (const std::string& file, const std::string& dir)
 {
 
   bool ok = false;
   bool addpath_option = true;
 
-  std::string curr_dir = octave_env::get_current_directory ();
+  std::string curr_dir = octave::sys::env::get_current_directory ();
 
   if (same_file (curr_dir, dir))
     ok = true;
   else
     {
       bool dir_in_load_path = load_path::contains_canonical (dir);
 
       // get base name, allowing "@class/method.m" (bug #41514)
       std::string base_file = (file.length () > dir.length ())
                               ? file.substr (dir.length () + 1)
-                              : octave_env::base_pathname (file);
+                              : octave::sys::env::base_pathname (file);
 
       std::string lp_file = load_path::find_file (base_file);
 
       if (dir_in_load_path)
         {
           if (same_file (lp_file, file))
             ok = true;
         }
diff --git a/libgui/src/resource-manager.cc b/libgui/src/resource-manager.cc
--- a/libgui/src/resource-manager.cc
+++ b/libgui/src/resource-manager.cc
@@ -45,17 +45,17 @@ along with Octave; see the file COPYING.
 #include "workspace-model.h"
 #include "resource-manager.h"
 
 resource_manager *resource_manager::instance = 0;
 
 static QString
 default_qt_settings_file (void)
 {
-  std::string dsf = octave_env::getenv ("OCTAVE_DEFAULT_QT_SETTINGS");
+  std::string dsf = octave::sys::env::getenv ("OCTAVE_DEFAULT_QT_SETTINGS");
 
   if (dsf.empty ())
     dsf = Voct_etc_dir + file_ops::dir_sep_str () + "default-qt-settings";
 
   return QString::fromStdString (dsf);
 }
 
 resource_manager::resource_manager (void)
@@ -80,17 +80,17 @@ resource_manager::~resource_manager (voi
   delete settings;
   delete default_settings;
 }
 
 QString
 resource_manager::get_gui_translation_dir (void)
 {
   // get environment variable for the locale dir (e.g. from run-octave)
-  std::string dldir = octave_env::getenv ("OCTAVE_LOCALE_DIR");
+  std::string dldir = octave::sys::env::getenv ("OCTAVE_LOCALE_DIR");
   if (dldir.empty ())
     dldir = Voct_locale_dir; // env-var empty, load the default location
   return QString::fromStdString (dldir);
 }
 
 void
 resource_manager::config_translators (QTranslator *qt_tr,
                                       QTranslator *qsci_tr,
diff --git a/libinterp/corefcn/__magick_read__.cc b/libinterp/corefcn/__magick_read__.cc
--- a/libinterp/corefcn/__magick_read__.cc
+++ b/libinterp/corefcn/__magick_read__.cc
@@ -702,17 +702,17 @@ maybe_initialize_magick (void)
   if (! initialized)
     {
       // Save locale as GraphicsMagick might change this (fixed in
       // GraphicsMagick since version 1.3.13 released on December 24, 2011)
       const char *static_locale = setlocale (LC_ALL, NULL);
       const std::string locale (static_locale);
 
       const std::string program_name
-        = octave_env::get_program_invocation_name ();
+        = octave::sys::env::get_program_invocation_name ();
       Magick::InitializeMagick (program_name.c_str ());
 
       // Restore locale from before GraphicsMagick initialisation
       setlocale (LC_ALL, locale.c_str ());
 
       // Why should we give a warning?
       // Magick does not tell us the real bitdepth of the image in file.
       // The best we can have is the minimum between the bitdepth of the
diff --git a/libinterp/corefcn/defaults.cc b/libinterp/corefcn/defaults.cc
--- a/libinterp/corefcn/defaults.cc
+++ b/libinterp/corefcn/defaults.cc
@@ -119,17 +119,17 @@ subst_octave_home (const std::string& s)
                   file_ops::dir_sep_char ());
 
   return retval;
 }
 
 static void
 set_octave_home (void)
 {
-  std::string oh = octave_env::getenv ("OCTAVE_HOME");
+  std::string oh = octave::sys::env::getenv ("OCTAVE_HOME");
 
   Voctave_home = oh.empty () ? std::string (OCTAVE_PREFIX) : oh;
 }
 
 static void
 set_default_info_dir (void)
 {
   Vinfo_dir = subst_octave_home (OCTAVE_INFODIR);
@@ -250,17 +250,17 @@ set_default_bin_dir (void)
 }
 
 void
 set_exec_path (const std::string& path_arg)
 {
   std::string tpath = path_arg;
 
   if (tpath.empty ())
-    tpath = octave_env::getenv ("OCTAVE_EXEC_PATH");
+    tpath = octave::sys::env::getenv ("OCTAVE_EXEC_PATH");
 
   if (tpath.empty ())
     tpath = Vlocal_ver_arch_lib_dir + dir_path::path_sep_str ()
             + Vlocal_api_arch_lib_dir + dir_path::path_sep_str ()
             + Vlocal_arch_lib_dir + dir_path::path_sep_str ()
             + Varch_lib_dir + dir_path::path_sep_str ()
             + Vbin_dir;
 
@@ -275,33 +275,33 @@ set_exec_path (const std::string& path_a
   // To fix this, I think Octave should be searching the combination of
   // PATH and EXEC_PATH for programs that it executes instead of setting
   // the PATH in the environment and relying on the shell to do the
   // searching.
 
   // This is static so that even if set_exec_path is called more than
   // once, shell_path is the original PATH from the environment,
   // before we start modifying it.
-  static std::string shell_path = octave_env::getenv ("PATH");
+  static std::string shell_path = octave::sys::env::getenv ("PATH");
 
   if (! shell_path.empty ())
     tpath = shell_path + dir_path::path_sep_str () + tpath;
 
-  octave_env::putenv ("PATH", tpath);
+  octave::sys::env::putenv ("PATH", tpath);
 }
 
 void
 set_image_path (const std::string& path)
 {
   VIMAGE_PATH = ".";
 
   std::string tpath = path;
 
   if (tpath.empty ())
-    tpath = octave_env::getenv ("OCTAVE_IMAGE_PATH");
+    tpath = octave::sys::env::getenv ("OCTAVE_IMAGE_PATH");
 
   if (! tpath.empty ())
     VIMAGE_PATH += dir_path::path_sep_str () + tpath;
 
   tpath = genpath (Vimage_dir, "");
 
   if (! tpath.empty ())
     VIMAGE_PATH += dir_path::path_sep_str () + tpath;
@@ -309,108 +309,108 @@ set_image_path (const std::string& path)
 
 static void
 set_default_doc_cache_file (void)
 {
   if (Vdoc_cache_file.empty ())
     {
       std::string def_file = subst_octave_home (OCTAVE_DOC_CACHE_FILE);
 
-      std::string env_file = octave_env::getenv ("OCTAVE_DOC_CACHE_FILE");
+      std::string env_file = octave::sys::env::getenv ("OCTAVE_DOC_CACHE_FILE");
 
       Vdoc_cache_file = env_file.empty () ? def_file : env_file;
     }
 }
 
 static void
 set_default_texi_macros_file (void)
 {
   if (Vtexi_macros_file.empty ())
     {
       std::string def_file = subst_octave_home (OCTAVE_TEXI_MACROS_FILE);
 
-      std::string env_file = octave_env::getenv ("OCTAVE_TEXI_MACROS_FILE");
+      std::string env_file = octave::sys::env::getenv ("OCTAVE_TEXI_MACROS_FILE");
 
       Vtexi_macros_file = env_file.empty () ? def_file : env_file;
     }
 }
 
 static void
 set_default_info_file (void)
 {
   if (Vinfo_file.empty ())
     {
       std::string std_info_file = subst_octave_home (OCTAVE_INFOFILE);
 
-      std::string oct_info_file = octave_env::getenv ("OCTAVE_INFO_FILE");
+      std::string oct_info_file = octave::sys::env::getenv ("OCTAVE_INFO_FILE");
 
       Vinfo_file = oct_info_file.empty () ? std_info_file : oct_info_file;
     }
 }
 
 static void
 set_default_info_prog (void)
 {
   if (Vinfo_program.empty ())
     {
-      std::string oct_info_prog = octave_env::getenv ("OCTAVE_INFO_PROGRAM");
+      std::string oct_info_prog = octave::sys::env::getenv ("OCTAVE_INFO_PROGRAM");
 
       if (oct_info_prog.empty ())
         Vinfo_program = "info";
       else
         Vinfo_program = std::string (oct_info_prog);
     }
 }
 
 static void
 set_default_editor (void)
 {
   VEDITOR = "emacs";
 
-  std::string env_editor = octave_env::getenv ("EDITOR");
+  std::string env_editor = octave::sys::env::getenv ("EDITOR");
 
   if (! env_editor.empty ())
     VEDITOR = env_editor;
 }
 
 static void
 set_local_site_defaults_file (void)
 {
-  std::string lsf = octave_env::getenv ("OCTAVE_SITE_INITFILE");
+  std::string lsf = octave::sys::env::getenv ("OCTAVE_SITE_INITFILE");
 
   if (lsf.empty ())
     {
       Vlocal_site_defaults_file
         = subst_octave_home (OCTAVE_LOCALSTARTUPFILEDIR);
       Vlocal_site_defaults_file.append ("/octaverc");
     }
   else
     Vlocal_site_defaults_file = lsf;
 }
 
 static void
 set_site_defaults_file (void)
 {
-  std::string sf = octave_env::getenv ("OCTAVE_VERSION_INITFILE");
+  std::string sf = octave::sys::env::getenv ("OCTAVE_VERSION_INITFILE");
 
   if (sf.empty ())
     {
       Vsite_defaults_file = subst_octave_home (OCTAVE_STARTUPFILEDIR);
       Vsite_defaults_file.append ("/octaverc");
     }
   else
     Vsite_defaults_file = sf;
 }
 
 static void
 set_built_in_docstrings_file (void)
 {
   if (Vbuilt_in_docstrings_file.empty ())
     {
-      std::string df = octave_env::getenv ("OCTAVE_BUILT_IN_DOCSTRINGS_FILE");
+      std::string df = octave::sys::env::getenv ("OCTAVE_BUILT_IN_DOCSTRINGS_FILE");
 
       if (df.empty ())
         Vbuilt_in_docstrings_file
           = Voct_etc_dir + file_ops::dir_sep_str () + "built-in-docstrings";
       else
         Vbuilt_in_docstrings_file = df;
     }
 }
diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -68,29 +68,29 @@ static bool Vconfirm_recursive_rmdir = t
 // The time we last time we changed directories.
 octave::sys::time Vlast_chdir_time = 0.0;
 
 static int
 octave_change_to_directory (const std::string& newdir)
 {
   std::string xdir = file_ops::tilde_expand (newdir);
 
-  int cd_ok = octave_env::chdir (xdir);
+  int cd_ok = octave::sys::env::chdir (xdir);
 
   if (! cd_ok)
     error ("%s: %s", newdir.c_str (), gnulib::strerror (errno));
 
   Vlast_chdir_time.stamp ();
 
   // FIXME: should these actions be handled as a list of functions
   // to call so users can add their own chdir handlers?
 
   load_path::update ();
 
-  octave_link::change_directory (octave_env::get_current_directory ());
+  octave_link::change_directory (octave::sys::env::get_current_directory ());
 
   return cd_ok;
 }
 
 DEFUN (cd, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} cd @var{dir}\n\
 @deftypefnx {} {} cd\n\
@@ -123,28 +123,28 @@ present working directory rather than ch
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
   octave_value_list retval;
 
   if (nargout > 0)
-    retval = octave_value (octave_env::get_current_directory ());
+    retval = octave_value (octave::sys::env::get_current_directory ());
 
   if (nargin == 1)
     {
       std::string dirname = args(0).xstring_value ("cd: DIR must be a string");
 
       if (! dirname.empty ())
         octave_change_to_directory (dirname);
     }
   else
     {
-      std::string home_dir = octave_env::get_home_directory ();
+      std::string home_dir = octave::sys::env::get_home_directory ();
 
       if (! home_dir.empty ())
         octave_change_to_directory (home_dir);
     }
 
   return retval;
 }
 
@@ -153,17 +153,17 @@ DEFALIAS (chdir, cd);
 DEFUN (pwd, , ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} pwd ()\n\
 @deftypefnx {} {@var{dir} =} pwd ()\n\
 Return the current working directory.\n\
 @seealso{cd, dir, ls, mkdir, rmdir}\n\
 @end deftypefn")
 {
-  return ovl (octave_env::get_current_directory ());
+  return ovl (octave::sys::env::get_current_directory ());
 }
 
 DEFUN (readdir, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{files} =} readdir (@var{dir})\n\
 @deftypefnx {} {[@var{files}, @var{err}, @var{msg}] =} readdir (@var{dir})\n\
 Return the names of files in the directory @var{dir} as a cell array of\n\
 strings.\n\
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -1242,17 +1242,17 @@ do_which (const std::string& name, std::
       // File query.
 
       // For compatibility: "file." queries "file".
       if (name.size () > 1 && name[name.size () - 1] == '.')
         file = load_path::find_file (name.substr (0, name.size () - 1));
       else
         file = load_path::find_file (name);
 
-      file = octave_env::make_absolute (file);
+      file = octave::sys::env::make_absolute (file);
     }
 
 
   return file;
 }
 
 std::string
 do_which (const std::string& name)
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -58,17 +58,17 @@ load_path::dir_info::update (void)
   file_stat fs (dir_name);
 
   if (fs)
     {
       if (is_relative)
         {
           try
             {
-              std::string abs_name = octave_env::make_absolute (dir_name);
+              std::string abs_name = octave::sys::env::make_absolute (dir_name);
 
               abs_dir_cache_iterator p = abs_dir_cache.find (abs_name);
 
               if (p != abs_dir_cache.end ())
                 {
                   // The directory is in the cache of all directories
                   // we have visited (indexed by its absolute name).
                   // If it is out of date, initialize it.  Otherwise,
@@ -128,17 +128,17 @@ load_path::dir_info::is_package (const s
       else
         return false;
     }
 }
 
 void
 load_path::dir_info::initialize (void)
 {
-  is_relative = ! octave_env::absolute_pathname (dir_name);
+  is_relative = ! octave::sys::env::absolute_pathname (dir_name);
 
   dir_time_last_checked = octave::sys::time (static_cast<time_t> (0));
 
   file_stat fs (dir_name);
 
   if (fs)
     {
       method_file_map.clear ();
@@ -146,17 +146,17 @@ load_path::dir_info::initialize (void)
 
       dir_mtime = fs.mtime ();
       dir_time_last_checked = octave::sys::time ();
 
       get_file_list (dir_name);
 
       try
         {
-          std::string abs_name = octave_env::make_absolute (dir_name);
+          std::string abs_name = octave::sys::env::make_absolute (dir_name);
 
           // FIXME: nothing is ever removed from this cache of
           // directory information, so there could be some resource
           // problems.  Perhaps it should be pruned from time to time.
 
           abs_dir_cache[abs_name] = *this;
         }
       catch (const octave_execution_exception&)
@@ -588,17 +588,17 @@ load_path::do_initialize (bool set_initi
       maybe_add_path_elts (sys_path, Voct_file_dir);
       maybe_add_path_elts (sys_path, Vfcn_file_dir);
       maybe_add_path_elts (sys_path, Voct_data_dir);
     }
 
   std::string tpath = load_path::command_line_path;
 
   if (tpath.empty ())
-    tpath = octave_env::getenv ("OCTAVE_PATH");
+    tpath = octave::sys::env::getenv ("OCTAVE_PATH");
 
   std::string xpath;
 
   if (! tpath.empty ())
     {
       xpath = tpath;
 
       if (! sys_path.empty ())
@@ -1320,18 +1320,18 @@ find_private_file (const std::string& fn
   return retval;
 }
 
 std::string
 load_path::do_find_file (const std::string& file) const
 {
   std::string retval;
 
-  if (octave_env::absolute_pathname (file)
-      || octave_env::rooted_relative_pathname (file))
+  if (octave::sys::env::absolute_pathname (file)
+      || octave::sys::env::rooted_relative_pathname (file))
     {
       file_stat fs (file);
 
       return fs.exists () ? file : retval;
     }
   else
     {
       std::string tfile = find_private_file (file);
@@ -1381,31 +1381,31 @@ load_path::do_find_file (const std::stri
 }
 
 std::string
 load_path::do_find_dir (const std::string& dir) const
 {
   std::string retval;
 
   if (dir.find_first_of (file_ops::dir_sep_chars ()) != std::string::npos
-      && (octave_env::absolute_pathname (dir)
-          || octave_env::rooted_relative_pathname (dir)))
+      && (octave::sys::env::absolute_pathname (dir)
+          || octave::sys::env::rooted_relative_pathname (dir)))
     {
       file_stat fs (dir);
 
       if (fs.exists () && fs.is_dir ())
         return dir;
     }
   else
     {
       for (const_dir_info_list_iterator p = dir_info_list.begin ();
            p != dir_info_list.end ();
            p++)
         {
-          std::string dname = octave_env::make_absolute (p->dir_name);
+          std::string dname = octave::sys::env::make_absolute (p->dir_name);
 
           size_t dname_len = dname.length ();
 
           if (dname.substr (dname_len - 1) == file_ops::dir_sep_str ())
             {
               dname = dname.substr (0, dname_len - 1);
               dname_len--;
             }
@@ -1428,31 +1428,31 @@ load_path::do_find_dir (const std::strin
 }
 
 string_vector
 load_path::do_find_matching_dirs (const std::string& dir) const
 {
   std::list<std::string> retlist;
 
   if (dir.find_first_of (file_ops::dir_sep_chars ()) != std::string::npos
-      && (octave_env::absolute_pathname (dir)
-          || octave_env::rooted_relative_pathname (dir)))
+      && (octave::sys::env::absolute_pathname (dir)
+          || octave::sys::env::rooted_relative_pathname (dir)))
     {
       file_stat fs (dir);
 
       if (fs.exists () && fs.is_dir ())
         retlist.push_back (dir);
     }
   else
     {
       for (const_dir_info_list_iterator p = dir_info_list.begin ();
            p != dir_info_list.end ();
            p++)
         {
-          std::string dname = octave_env::make_absolute (p->dir_name);
+          std::string dname = octave::sys::env::make_absolute (p->dir_name);
 
           size_t dname_len = dname.length ();
 
           if (dname.substr (dname_len - 1) == file_ops::dir_sep_str ())
             {
               dname = dname.substr (0, dname_len - 1);
               dname_len--;
             }
@@ -1488,18 +1488,18 @@ load_path::do_find_first_of (const strin
   string_vector rel_flist (flen);
 
   for (octave_idx_type i = 0; i < flen; i++)
     {
       std::string file = flist[i];
 
       if (file.find_first_of (file_ops::dir_sep_chars ()) != std::string::npos)
         {
-          if (octave_env::absolute_pathname (file)
-              || octave_env::rooted_relative_pathname (file))
+          if (octave::sys::env::absolute_pathname (file)
+              || octave::sys::env::rooted_relative_pathname (file))
             {
               file_stat fs (file);
 
               if (fs.exists ())
                 return file;
             }
           else
             {
@@ -1567,18 +1567,18 @@ load_path::do_find_all_first_of (const s
   string_vector rel_flist (flen);
 
   for (octave_idx_type i = 0; i < flen; i++)
     {
       std::string file = flist[i];
 
       if (file.find_first_of (file_ops::dir_sep_chars ()) != std::string::npos)
         {
-          if (octave_env::absolute_pathname (file)
-              || octave_env::rooted_relative_pathname (file))
+          if (octave::sys::env::absolute_pathname (file)
+              || octave::sys::env::rooted_relative_pathname (file))
             {
               file_stat fs (file);
 
               if (fs.exists ())
                 retlist.push_back (file);
             }
           else
             {
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -110,19 +110,19 @@ static std::string Vsave_default_options
 static std::string Voctave_core_file_options = "-binary";
 
 static std::string
 default_save_header_format (void)
 {
   return
     std::string ("# Created by Octave " OCTAVE_VERSION
                  ", %a %b %d %H:%M:%S %Y %Z <")
-    + octave_env::get_user_name ()
+    + octave::sys::env::get_user_name ()
     + std::string ("@")
-    + octave_env::get_host_name ()
+    + octave::sys::env::get_host_name ()
     + std::string (">");
 }
 
 // The format string for the comment line at the top of text-format
 // save files.  Passed to strftime.  Should begin with '#' and contain
 // no newline characters.
 static std::string Vsave_header_format_string = default_save_header_format ();
 
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -902,17 +902,17 @@ read_mat5_binary_element (std::istream& 
                         string_vector names(3);
                         names(0) = fname + ".oct";
                         names(1) = fname + ".mex";
                         names(2) = fname + ".m";
 
                         dir_path p (load_path::system_path ());
 
                         str =
-                          octave_env::make_absolute (p.find_first_of (names));
+                          octave::sys::env::make_absolute (p.find_first_of (names));
 
                         size_t xpos
                           = str.find_last_of (file_ops::dir_sep_chars ());
 
                         std::string dir_name = str.substr (0, xpos);
 
                         octave_function *fcn
                           = load_fcn_from_file (str, dir_name, "", "", fname);
diff --git a/libinterp/corefcn/oct-hist.cc b/libinterp/corefcn/oct-hist.cc
--- a/libinterp/corefcn/oct-hist.cc
+++ b/libinterp/corefcn/oct-hist.cc
@@ -72,34 +72,34 @@ Software Foundation, Inc.
 // TRUE means input is coming from temporary history file.
 bool input_from_tmp_history_file = false;
 
 static std::string
 default_history_file (void)
 {
   std::string file;
 
-  std::string env_file = octave_env::getenv ("OCTAVE_HISTFILE");
+  std::string env_file = octave::sys::env::getenv ("OCTAVE_HISTFILE");
 
   if (! env_file.empty ())
     file = env_file;
 
   if (file.empty ())
-    file = file_ops::concat (octave_env::get_home_directory (),
+    file = file_ops::concat (octave::sys::env::get_home_directory (),
                              ".octave_hist");
 
   return file;
 }
 
 static int
 default_history_size (void)
 {
   int size = 1000;
 
-  std::string env_size = octave_env::getenv ("OCTAVE_HISTSIZE");
+  std::string env_size = octave::sys::env::getenv ("OCTAVE_HISTSIZE");
 
   if (! env_size.empty ())
     {
       int val;
 
       if (sscanf (env_size.c_str (), "%d", &val) == 1)
         size = val > 0 ? val : 0;
     }
@@ -107,19 +107,19 @@ default_history_size (void)
   return size;
 }
 
 static std::string
 default_history_timestamp_format (void)
 {
   return
     std::string ("# Octave " OCTAVE_VERSION ", %a %b %d %H:%M:%S %Y %Z <")
-    + octave_env::get_user_name ()
+    + octave::sys::env::get_user_name ()
     + std::string ("@")
-    + octave_env::get_host_name ()
+    + octave::sys::env::get_host_name ()
     + std::string (">");
 }
 
 // The format of the timestamp marker written to the history file when
 // Octave exits.
 static std::string Vhistory_timestamp_format_string
   = default_history_timestamp_format ();
 
@@ -531,17 +531,17 @@ do_run_history (const octave_value_list&
 }
 
 void
 initialize_history (bool read_history_file)
 {
   command_history::initialize (read_history_file,
                                default_history_file (),
                                default_history_size (),
-                               octave_env::getenv ("OCTAVE_HISTCONTROL"));
+                               octave::sys::env::getenv ("OCTAVE_HISTCONTROL"));
 
   octave_link::set_history (command_history::list ());
 }
 
 void
 octave_history_write_timestamp (void)
 {
   octave::sys::localtime now;
diff --git a/libinterp/corefcn/pager.cc b/libinterp/corefcn/pager.cc
--- a/libinterp/corefcn/pager.cc
+++ b/libinterp/corefcn/pager.cc
@@ -55,17 +55,17 @@ static bool write_to_diary_file = false;
 static std::string diary_file ("diary");
 
 // The diary file.
 static std::ofstream external_diary_file;
 
 static std::string
 default_pager (void)
 {
-  std::string pager_binary = octave_env::getenv ("PAGER");
+  std::string pager_binary = octave::sys::env::getenv ("PAGER");
 
 #if defined (OCTAVE_DEFAULT_PAGER)
   if (pager_binary.empty ())
     pager_binary = OCTAVE_DEFAULT_PAGER;
 #endif
 
   return pager_binary;
 }
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -244,17 +244,17 @@ out_of_date_check (octave_value& functio
 
                   std::string file;
                   std::string dir_name;
 
                   if (check_relative)
                     {
                       int nm_len = nm.length ();
 
-                      if (octave_env::absolute_pathname (nm)
+                      if (octave::sys::env::absolute_pathname (nm)
                           && ((nm_len > 4
                                && (nm.substr (nm_len-4) == ".oct"
                                    || nm.substr (nm_len-4) == ".mex"))
                               || (nm_len > 2
                                   && nm.substr (nm_len-2) == ".m")))
                         file = nm;
                       else
                         {
diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -998,17 +998,17 @@ DEFUN (gethostname, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} gethostname ()\n\
 Return the hostname of the system where Octave is running.\n\
 @end deftypefn")
 {
   if (args.length () != 0)
     print_usage ();
 
-  return ovl (octave_env::get_host_name ());
+  return ovl (octave::sys::env::get_host_name ());
 }
 
 DEFUN (uname, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {[@var{uts}, @var{err}, @var{msg}] =} uname ()\n\
 Return system information in the structure.\n\
 \n\
 For example:\n\
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -151,17 +151,17 @@ w32_set_octave_home (void)
       CloseHandle (h);
     }
 
   if (! bin_dir.empty ())
     {
       size_t pos = bin_dir.rfind ("\\bin\\");
 
       if (pos != std::string::npos)
-        octave_env::putenv ("OCTAVE_HOME", bin_dir.substr (0, pos));
+        octave::sys::env::putenv ("OCTAVE_HOME", bin_dir.substr (0, pos));
     }
 }
 
 void
 w32_set_quiet_shutdown (void)
 {
   // Let the user close the console window or shutdown without the
   // pesky dialog.
@@ -571,20 +571,20 @@ get_P_tmpdir (void)
 #endif
 
   // Apparently some versions of MinGW and MSVC either don't define
   // P_tmpdir, or they define it to a single backslash, neither of which
   // is particularly helpful.
 
   if (retval.empty () || retval == "\\")
     {
-      retval = octave_env::getenv ("TEMP");
+      retval = octave::sys::env::getenv ("TEMP");
 
       if (retval.empty ())
-        retval = octave_env::getenv ("TMP");
+        retval = octave::sys::env::getenv ("TMP");
 
       if (retval.empty ())
         retval = "c:\\temp";
     }
 
   return retval;
 
 #elif defined (P_tmpdir)
@@ -630,17 +630,17 @@ returns a string containing the value of
 @seealso{setenv, unsetenv}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   std::string name = args(0).string_value ();
 
-  return ovl (octave_env::getenv (name));
+  return ovl (octave::sys::env::getenv (name));
 }
 
 /*
 %!assert (ischar (getenv ("OCTAVE_HOME")))
 */
 
 DEFUN (setenv, args, ,
        "-*- texinfo -*-\n\
@@ -660,17 +660,17 @@ string.\n\
     print_usage ();
 
   std::string var = args(0).xstring_value ("setenv: VAR must be a string");
 
   std::string val = (nargin == 2
                      ? args(1).xstring_value ("setenv: VALUE must be a string")
                      : "");
 
-  octave_env::putenv (var, val);
+  octave::sys::env::putenv (var, val);
 
   return ovl ();
 }
 
 DEFALIAS (putenv, setenv);
 
 /*
 %!test
@@ -922,17 +922,17 @@ Return the current home directory.\n\
 \n\
 On most systems, this is equivalent to @code{getenv (\"HOME\")}.  On Windows\n\
 systems, if the environment variable @env{HOME} is not set then it is\n\
 equivalent to\n\
 @code{fullfile (getenv (\"HOMEDRIVE\"), getenv (\"HOMEPATH\"))}\n\
 @seealso{getenv}\n\
 @end deftypefn")
 {
-  return ovl (octave_env::get_home_directory ());
+  return ovl (octave::sys::env::get_home_directory ());
 }
 
 /*
 %!test
 %! if (! ispc ())
 %!   assert (get_home_directory (), getenv ("HOME"));
 %! endif
 */
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -382,17 +382,17 @@ urlwrite (\"http://www.google.com/search
   ofile.close ();
 
   if (curl.good ())
     frame.discard ();
 
   if (nargout > 0)
     {
       if (curl.good ())
-        retval = ovl (octave_env::make_absolute (filename), true, "");
+        retval = ovl (octave::sys::env::make_absolute (filename), true, "");
       else
         retval = ovl ("", false, curl.lasterror ());
     }
 
   if (nargout < 2 && ! curl.good ())
     error ("urlwrite: %s", curl.lasterror ().c_str ());
 
   return retval;
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -250,45 +250,45 @@ empty_arg (const char * /* name */, octa
 
 // See if the given file is in the path.
 
 std::string
 search_path_for_file (const std::string& path, const string_vector& names)
 {
   dir_path p (path);
 
-  return octave_env::make_absolute (p.find_first_of (names));
+  return octave::sys::env::make_absolute (p.find_first_of (names));
 }
 
 // Find all locations of the given file in the path.
 
 string_vector
 search_path_for_all_files (const std::string& path, const string_vector& names)
 {
   dir_path p (path);
 
   string_vector sv = p.find_all_first_of (names);
 
   octave_idx_type len = sv.numel ();
 
   for (octave_idx_type i = 0; i < len; i++)
-    sv[i] = octave_env::make_absolute (sv[i]);
+    sv[i] = octave::sys::env::make_absolute (sv[i]);
 
   return sv;
 }
 
 static string_vector
 make_absolute (const string_vector& sv)
 {
   octave_idx_type len = sv.numel ();
 
   string_vector retval (len);
 
   for (octave_idx_type i = 0; i < len; i++)
-    retval[i] = octave_env::make_absolute (sv[i]);
+    retval[i] = octave::sys::env::make_absolute (sv[i]);
 
   return retval;
 }
 
 DEFUN (file_in_loadpath, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} file_in_loadpath (@var{file})\n\
 @deftypefnx {} {} file_in_loadpath (@var{file}, \"all\")\n\
@@ -314,17 +314,17 @@ If no files are found, return an empty c
     print_usage ();
 
   string_vector names = args(0).xstring_vector_value ("file_in_loadpath: FILE argument must be a string");
 
   if (names.empty ())
     error ("file_in_loadpath: FILE argument must not be empty");
 
   if (nargin == 1)
-    return ovl (octave_env::make_absolute (load_path::find_first_of (names)));
+    return ovl (octave::sys::env::make_absolute (load_path::find_first_of (names)));
   else
     {
       std::string opt = args(1).xstring_value ("file_in_loadpath: optional second argument must be a string");
 
       if (opt != "all")
         error ("file_in_loadpath: \"all\" is only valid second argument");
 
       return ovl (Cell (make_absolute (load_path::find_all_first_of (names))));
@@ -427,42 +427,42 @@ If no files are found, return an empty c
 std::string
 file_in_path (const std::string& name, const std::string& suffix)
 {
   std::string nm = name;
 
   if (! suffix.empty ())
     nm.append (suffix);
 
-  return octave_env::make_absolute (load_path::find_file (nm));
+  return octave::sys::env::make_absolute (load_path::find_file (nm));
 }
 
 std::string
 find_data_file_in_load_path  (const std::string& fcn,
                               const std::string& file,
                               bool require_regular_file)
 {
   std::string fname = file;
 
-  if (! (octave_env::absolute_pathname (fname)
-         || octave_env::rooted_relative_pathname (fname)))
+  if (! (octave::sys::env::absolute_pathname (fname)
+         || octave::sys::env::rooted_relative_pathname (fname)))
     {
       // Load path will also search "." first, but we don't want to
       // issue a warning if the file is found in the current directory,
       // so do an explicit check for that.
       file_stat fs (fname);
 
       bool local_file_ok
         = fs.exists () && (fs.is_reg () || ! require_regular_file);
 
       if (! local_file_ok)
         {
           // Not directly found; search load path.
           std::string tmp
-            = octave_env::make_absolute (load_path::find_file (fname));
+            = octave::sys::env::make_absolute (load_path::find_file (fname));
 
           if (! tmp.empty ())
             {
               warn_data_file_in_path (fcn, tmp);
 
               fname = tmp;
             }
         }
@@ -478,17 +478,17 @@ std::string
 fcn_file_in_path (const std::string& name)
 {
   std::string retval;
 
   int len = name.length ();
 
   if (len > 0)
     {
-      if (octave_env::absolute_pathname (name))
+      if (octave::sys::env::absolute_pathname (name))
         {
           file_stat fs (name);
 
           if (fs.exists () && ! fs.is_dir ())
             retval = name;
         }
       else if (len > 2 && name[len - 2] == '.' && name[len - 1] == 'm')
         retval = load_path::find_fcn_file (name.substr (0, len-2));
@@ -517,17 +517,17 @@ contents_file_in_path (const std::string
   if (dir.length () > 0)
     {
       std::string tcontents = file_ops::concat (load_path::find_dir (dir),
                                                 std::string ("Contents.m"));
 
       file_stat fs (tcontents);
 
       if (fs.exists ())
-        retval = octave_env::make_absolute (tcontents);
+        retval = octave::sys::env::make_absolute (tcontents);
     }
 
   return retval;
 }
 
 // Deprecated in 4.2, remove in 4.6.
 // See if there is a .oct file in the path.
 // If so, return the full path to the file.
@@ -536,17 +536,17 @@ std::string
 oct_file_in_path (const std::string& name)
 {
   std::string retval;
 
   int len = name.length ();
 
   if (len > 0)
     {
-      if (octave_env::absolute_pathname (name))
+      if (octave::sys::env::absolute_pathname (name))
         {
           file_stat fs (name);
 
           if (fs.exists ())
             retval = name;
         }
       else if (len > 4 && name.find (".oct", len-5))
         retval = load_path::find_oct_file (name.substr (0, len-4));
@@ -565,17 +565,17 @@ std::string
 mex_file_in_path (const std::string& name)
 {
   std::string retval;
 
   int len = name.length ();
 
   if (len > 0)
     {
-      if (octave_env::absolute_pathname (name))
+      if (octave::sys::env::absolute_pathname (name))
         {
           file_stat fs (name);
 
           if (fs.exists ())
             retval = name;
         }
       else if (len > 4 && name.find (".mex", len-5))
         retval = load_path::find_mex_file (name.substr (0, len-4));
@@ -898,17 +898,17 @@ DEFUN (is_absolute_filename, args, ,
 Return true if @var{file} is an absolute filename.\n\
 @seealso{is_rooted_relative_filename, make_absolute_filename, isdir}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   return ovl (args(0).is_string ()
-              && octave_env::absolute_pathname (args(0).string_value ()));
+              && octave::sys::env::absolute_pathname (args(0).string_value ()));
 }
 
 /*
 ## FIXME: We need system-dependent tests here.
 
 %!error is_absolute_filename ()
 %!error is_absolute_filename ("foo", "bar")
 */
@@ -919,17 +919,17 @@ DEFUN (is_rooted_relative_filename, args
 Return true if @var{file} is a rooted-relative filename.\n\
 @seealso{is_absolute_filename, make_absolute_filename, isdir}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   return ovl (args(0).is_string ()
-              && octave_env::rooted_relative_pathname (args(0).string_value ()));
+              && octave::sys::env::rooted_relative_pathname (args(0).string_value ()));
 }
 
 /*
 ## FIXME: We need system-dependent tests here.
 
 %!error is_rooted_relative_filename ()
 %!error is_rooted_relative_filename ("foo", "bar")
 */
@@ -944,17 +944,17 @@ No check is done for the existence of @v
 @seealso{canonicalize_file_name, is_absolute_filename, is_rooted_relative_filename, isdir}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   std::string nm = args(0).xstring_value ("make_absolute_filename: FILE argument must be a filename");
 
-  return ovl (octave_env::make_absolute (nm));
+  return ovl (octave::sys::env::make_absolute (nm));
 }
 
 /*
 ## FIXME: We need system-dependent tests here.
 
 %!error make_absolute_filename ()
 %!error make_absolute_filename ("foo", "bar")
 */
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -836,17 +836,17 @@ public:
         // Set WM_CLASS which allows window managers to properly group
         // related windows.  Otherwise, the class is just "FLTK"
         xclass ("Octave");
 
         show ();
 
 #if defined (HAVE_X_WINDOWS)
         std::string show_gui_msgs
-          = octave_env::getenv ("OCTAVE_SHOW_GUI_MESSAGES");
+          = octave::sys::env::getenv ("OCTAVE_SHOW_GUI_MESSAGES");
 
         // Installing our handler suppresses the messages.
         if (show_gui_msgs.empty ())
           XSetErrorHandler (xerror_handler);
 #endif
 
         if (fp.get_currentaxes ().ok ())
           show_canvas ();
diff --git a/libinterp/dldfcn/__init_gnuplot__.cc b/libinterp/dldfcn/__init_gnuplot__.cc
--- a/libinterp/dldfcn/__init_gnuplot__.cc
+++ b/libinterp/dldfcn/__init_gnuplot__.cc
@@ -165,17 +165,17 @@ private:
       }
   }
 };
 
 static bool
 have_gnuplot_binary (void)
 {
   const std::string exeext = octave::build_env::EXEEXT;
-  const std::string path = octave_env::getenv ("PATH");
+  const std::string path = octave::sys::env::getenv ("PATH");
 
   octave_value_list tmp = feval ("gnuplot_binary", octave_value_list ());
   std::string gnuplot_binary = tmp(0).string_value ();
 
   string_vector args (gnuplot_binary);
   std::string gnuplot_path = search_path_for_file (path, args);
 
   file_stat fs (gnuplot_path);
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -289,17 +289,17 @@ octave_fcn_handle::set_fcn (const std::s
           // Next just search for it anywhere in the system path
           string_vector names(3);
           names(0) = nm + ".oct";
           names(1) = nm + ".mex";
           names(2) = nm + ".m";
 
           dir_path p (load_path::system_path ());
 
-          str = octave_env::make_absolute (p.find_first_of (names));
+          str = octave::sys::env::make_absolute (p.find_first_of (names));
 
           size_t xpos = str.find_last_of (file_ops::dir_sep_chars ());
 
           std::string dir_name = str.substr (0, xpos);
 
           octave_function *xfcn = load_fcn_from_file (str, dir_name, "", "", nm);
 
           if (! xfcn)
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -358,17 +358,17 @@ set_dll_directory (const std::string& di
 
 static std::string
 initial_java_dir (void)
 {
   static std::string java_dir;
 
   if (java_dir.empty ())
     {
-      java_dir = octave_env::getenv ("OCTAVE_JAVA_DIR");
+      java_dir = octave::sys::env::getenv ("OCTAVE_JAVA_DIR");
 
       if (java_dir.empty ())
         java_dir = Vfcn_file_dir + file_ops::dir_sep_str () + "java";
     }
 
   return java_dir;
 }
 
@@ -441,18 +441,18 @@ initial_class_path (void)
           retval = jar_file;
 
           // The base classpath has been set.
           // Try to find an optional file specifying classpaths in 3 places.
           // 1) Current directory
           // 2) User's home directory
           // 3) Octave installation directory where octave.jar resides
 
-          std::string cwd = octave_env::get_current_directory ();
-          std::string home_dir = octave_env::get_home_directory ();
+          std::string cwd = octave::sys::env::get_current_directory ();
+          std::string home_dir = octave::sys::env::get_home_directory ();
 
           // The filename is "javaclasspath.txt", but historically
           // has been "classpath.txt" so both are supported.
           std::string cp_list[] = {"javaclasspath.txt", "classpath.txt"};
 
           for (int i=0; i<2; i++)
             {
               std::string filename = cp_list[i];
@@ -554,17 +554,17 @@ initialize_jvm (void)
   else
     {
       // In windows, find the location of the JRE from the registry
       // and load the symbol from the dll.
       std::string key, value;
 
       key = "software\\javasoft\\java runtime environment";
 
-      value = octave_env::getenv ("JAVA_VERSION");
+      value = octave::sys::env::getenv ("JAVA_VERSION");
       if (value.empty ())
         {
           value = "Currentversion";
           std::string regval = read_registry_string (key,value);
 
           if (regval.empty ())
             error ("unable to find Java Runtime Environment: %s::%s",
                    key.c_str (), value.c_str ());
@@ -583,20 +583,20 @@ initialize_jvm (void)
       std::string jvm_bin_path;
 
       value = "JavaHome";
       jvm_bin_path = read_registry_string (key, value);
       if (! jvm_bin_path.empty ())
         {
           jvm_bin_path = (jvm_bin_path + std::string ("\\bin"));
 
-          old_cwd = octave_env::get_current_directory ();
+          old_cwd = octave::sys::env::get_current_directory ();
 
           set_dll_directory (jvm_bin_path);
-          octave_env::chdir (jvm_bin_path);
+          octave::sys::env::chdir (jvm_bin_path);
         }
     }
 
 #else
 
   // JAVA_LDPATH determined by configure and set in config.h
 #  if defined (__APPLE__)
   std::string jvm_lib_path = JAVA_LDPATH + std::string ("/libjvm.dylib");
@@ -616,17 +616,17 @@ initialize_jvm (void)
     error ("unable to load Java Runtime Environment from %s",
            jvm_lib_path.c_str ());
 
 #if defined (__WIN32__)
 
   set_dll_directory ();
 
   if (! old_cwd.empty ())
-    octave_env::chdir (old_cwd);
+    octave::sys::env::chdir (old_cwd);
 
 #endif
 
   JNI_CreateJavaVM_t create_vm =
     reinterpret_cast<JNI_CreateJavaVM_t> (lib.search ("JNI_CreateJavaVM"));
   JNI_GetCreatedJavaVMs_t get_vm =
     reinterpret_cast<JNI_GetCreatedJavaVMs_t> (lib.search ("JNI_GetCreatedJavaVMs"));
 
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -374,50 +374,50 @@ execute_startup_files (void)
   if (read_init_files)
     {
       // Try to execute commands from $HOME/$OCTAVE_INITFILE and
       // $OCTAVE_INITFILE.  If $OCTAVE_INITFILE is not set,
       // .octaverc is assumed.
 
       bool home_rc_already_executed = false;
 
-      std::string initfile = octave_env::getenv ("OCTAVE_INITFILE");
+      std::string initfile = octave::sys::env::getenv ("OCTAVE_INITFILE");
 
       if (initfile.empty ())
         initfile = ".octaverc";
 
-      std::string home_dir = octave_env::get_home_directory ();
+      std::string home_dir = octave::sys::env::get_home_directory ();
 
-      std::string home_rc = octave_env::make_absolute (initfile, home_dir);
+      std::string home_rc = octave::sys::env::make_absolute (initfile, home_dir);
 
       std::string local_rc;
 
       if (! home_rc.empty ())
         {
           safe_source_file (home_rc, context, verbose, require_file);
 
           // Names alone are not enough.
 
           file_stat fs_home_rc (home_rc);
 
           if (fs_home_rc)
             {
               // We want to check for curr_dir after executing home_rc
               // because doing that may change the working directory.
 
-              local_rc = octave_env::make_absolute (initfile);
+              local_rc = octave::sys::env::make_absolute (initfile);
 
               home_rc_already_executed = same_file (home_rc, local_rc);
             }
         }
 
       if (! home_rc_already_executed)
         {
           if (local_rc.empty ())
-            local_rc = octave_env::make_absolute (initfile);
+            local_rc = octave::sys::env::make_absolute (initfile);
 
           safe_source_file (local_rc, context, verbose, require_file);
         }
     }
 }
 
 static int
 execute_eval_option_code (const std::string& code)
@@ -776,25 +776,25 @@ octave_process_command_line (int argc, c
 // declared extern "C".
 
 void
 octave_initialize_interpreter (int argc, char **argv, int embedded)
 {
   // Matlab uses "C" locale for LC_NUMERIC class regardless of local setting
   setlocale (LC_NUMERIC, "C");
   setlocale (LC_TIME, "C");
-  octave_env::putenv ("LC_NUMERIC", "C");
-  octave_env::putenv ("LC_TIME", "C");
+  octave::sys::env::putenv ("LC_NUMERIC", "C");
+  octave::sys::env::putenv ("LC_TIME", "C");
 
   octave_embedded = embedded;
 
-  octave_env::set_program_name (argv[0]);
+  octave::sys::env::set_program_name (argv[0]);
 
-  octave_program_invocation_name = octave_env::get_program_invocation_name ();
-  octave_program_name = octave_env::get_program_name ();
+  octave_program_invocation_name = octave::sys::env::get_program_invocation_name ();
+  octave_program_name = octave::sys::env::get_program_name ();
 
   octave_thread::init ();
 
   set_default_prompts ();
 
   // Initialize default warning state before --traditional option
   // that may reset them.
 
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -4242,17 +4242,17 @@ get_help_from_file (const std::string& n
   std::string file = full_file;
 
   size_t file_len = file.length ();
 
   if ((file_len > 4 && file.substr (file_len-4) == ".oct")
       || (file_len > 4 && file.substr (file_len-4) == ".mex")
       || (file_len > 2 && file.substr (file_len-2) == ".m"))
     {
-      file = octave_env::base_pathname (file);
+      file = octave::sys::env::base_pathname (file);
       file = file.substr (0, file.find_last_of ('.'));
 
       size_t pos = file.find_last_of (file_ops::dir_sep_str ());
       if (pos != std::string::npos)
         file = file.substr (pos+1);
     }
 
   if (! file.empty ())
@@ -4341,27 +4341,27 @@ load_fcn_from_file (const std::string& f
   bool relative_lookup = false;
 
   file = nm;
 
   if ((nm_len > 4 && nm.substr (nm_len-4) == ".oct")
       || (nm_len > 4 && nm.substr (nm_len-4) == ".mex")
       || (nm_len > 2 && nm.substr (nm_len-2) == ".m"))
     {
-      nm = octave_env::base_pathname (file);
+      nm = octave::sys::env::base_pathname (file);
       nm = nm.substr (0, nm.find_last_of ('.'));
 
       size_t pos = nm.find_last_of (file_ops::dir_sep_str ());
       if (pos != std::string::npos)
         nm = nm.substr (pos+1);
     }
 
-  relative_lookup = ! octave_env::absolute_pathname (file);
-
-  file = octave_env::make_absolute (file);
+  relative_lookup = ! octave::sys::env::absolute_pathname (file);
+
+  file = octave::sys::env::make_absolute (file);
 
   int len = file.length ();
 
   if (len > 4 && file.substr (len-4, len-1) == ".oct")
     {
       if (autoload && ! fcn_name.empty ())
         nm = fcn_name;
 
@@ -4476,29 +4476,29 @@ not loaded anymore during the current Oc
       retval = m;
     }
   else
     {
       string_vector argv = args.make_argv ("autoload");
 
       std::string nm = argv[2];
 
-      if (! octave_env::absolute_pathname (nm))
+      if (! octave::sys::env::absolute_pathname (nm))
         {
           octave_user_code *fcn = octave_call_stack::caller_user_code ();
 
           bool found = false;
 
           if (fcn)
             {
               std::string fname = fcn->fcn_file_name ();
 
               if (! fname.empty ())
                 {
-                  fname = octave_env::make_absolute (fname);
+                  fname = octave::sys::env::make_absolute (fname);
                   fname = fname.substr (0, fname.find_last_of (file_ops::dir_sep_str ()) + 1);
 
                   file_stat fs (fname + nm);
 
                   if (fs.exists ())
                     {
                       nm = fname + nm;
                       found = true;
@@ -4563,17 +4563,17 @@ source_file (const std::string& file_nam
   //   source ("foo1.m")
   //
   // (for example).
 
   static std::map<std::string, int> source_call_depth;
 
   std::string file_full_name = file_ops::tilde_expand (file_name);
 
-  file_full_name = octave_env::make_absolute (file_full_name);
+  file_full_name = octave::sys::env::make_absolute (file_full_name);
 
   unwind_protect frame;
 
   if (source_call_depth.find (file_full_name) == source_call_depth.end ())
     source_call_depth[file_full_name] = -1;
 
   frame.protect_var (source_call_depth[file_full_name]);
 
@@ -5479,25 +5479,25 @@ Undocumented internal function.\n\
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   std::string file = args(0).xstring_value ("__parse_file__: expecting filename as argument");
 
-  std::string full_file = octave_env::make_absolute (file);
+  std::string full_file = octave::sys::env::make_absolute (file);
 
   size_t file_len = file.length ();
 
   if ((file_len > 4 && file.substr (file_len-4) == ".oct")
       || (file_len > 4 && file.substr (file_len-4) == ".mex")
       || (file_len > 2 && file.substr (file_len-2) == ".m"))
     {
-      file = octave_env::base_pathname (file);
+      file = octave::sys::env::base_pathname (file);
       file = file.substr (0, file.find_last_of ('.'));
 
       size_t pos = file.find_last_of (file_ops::dir_sep_str ());
       if (pos != std::string::npos)
         file = file.substr (pos+1);
     }
 
   if (nargin == 2)
diff --git a/liboctave/system/file-ops.cc b/liboctave/system/file-ops.cc
--- a/liboctave/system/file-ops.cc
+++ b/liboctave/system/file-ops.cc
@@ -226,17 +226,17 @@ tilde_expand_word (const std::string& fi
   if (f_len == 0 || filename[0] != '~')
     return filename;
 
   // A leading '~/' or a bare '~' is *always* translated to the value
   // of $HOME or the home directory of the current user, regardless of
   // any preexpansion hook.
 
   if (f_len == 1 || file_ops::is_dir_sep (filename[1]))
-    return octave_env::get_home_directory () + filename.substr (1);
+    return octave::sys::env::get_home_directory () + filename.substr (1);
 
   std::string username = isolate_tilde_prefix (filename);
 
   size_t user_len = username.length ();
 
   std::string dirname;
 
   if (file_ops::tilde_expansion_preexpansion_hook)
@@ -680,19 +680,19 @@ octave_tempnam (const std::string& dir, 
 {
   msg = "";
 
   std::string retval;
 
   // get dir path to use for template
   std::string templatename;
   if (dir.empty ())
-    templatename = octave_env::get_temp_directory ();
+    templatename = octave::sys::env::get_temp_directory ();
   else if (! file_stat (dir, false).is_dir ())
-    templatename = octave_env::get_temp_directory ();
+    templatename = octave::sys::env::get_temp_directory ();
   else
     templatename = dir;
 
   // add dir sep char if it is not there
   if (*templatename.rbegin () != file_ops::dir_sep_char ())
     templatename += file_ops::dir_sep_char ();
 
   if (pfx.empty ())
diff --git a/liboctave/system/oct-env.cc b/liboctave/system/oct-env.cc
--- a/liboctave/system/oct-env.cc
+++ b/liboctave/system/oct-env.cc
@@ -21,23 +21,23 @@ along with Octave; see the file COPYING.
 */
 
 /*
 
 The functions listed below were adapted from a similar functions
 from GNU Bash, the Bourne Again SHell, copyright (C) 1987, 1989, 1991
 Free Software Foundation, Inc.
 
-  octave_env::do_absolute_pathname
-  octave_env::do_base_pathname
-  octave_env::do_chdir
-  octave_env::do_getcwd
-  octave_env::do_make_absolute
-  octave_env::do_polite_directory_format
-  octave_env::pathname_backup
+  octave::sys::env::do_absolute_pathname
+  octave::sys:env::do_base_pathname
+  octave::sys:env::do_chdir
+  octave::sys:env::do_getcwd
+  octave::sys:env::do_make_absolute
+  octave::sys:env::do_polite_directory_format
+  octave::sys:env::pathname_backup
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include <cctype>
@@ -55,548 +55,556 @@ Free Software Foundation, Inc.
 #include "lo-error.h"
 #include "lo-sysdep.h"
 #include "lo-utils.h"
 #include "oct-env.h"
 #include "oct-passwd.h"
 #include "oct-syscalls.h"
 #include "singleton-cleanup.h"
 
-octave_env::octave_env (void)
-  : follow_symbolic_links (true), verbatim_pwd (true),
-    current_directory (), prog_name (), prog_invocation_name (),
-    user_name (), host_name ()
+namespace
+octave
 {
-  // Get a real value for the current directory.
-  do_getcwd ();
+  namespace
+  sys
+  {
+    env::env (void)
+      : follow_symbolic_links (true), verbatim_pwd (true),
+        current_directory (), prog_name (), prog_invocation_name (),
+        user_name (), host_name ()
+    {
+      // Get a real value for the current directory.
+      do_getcwd ();
+
+      // Etc.
+      do_get_user_name ();
 
-  // Etc.
-  do_get_user_name ();
+      do_get_host_name ();
+    }
+
+    env *env::instance = 0;
 
-  do_get_host_name ();
-}
+    bool
+    env::instance_ok (void)
+    {
+      bool retval = true;
+
+      if (! instance)
+        {
+          instance = new env ();
 
-octave_env *octave_env::instance = 0;
+          if (instance)
+            singleton_cleanup_list::add (cleanup_instance);
+        }
 
-bool
-octave_env::instance_ok (void)
-{
-  bool retval = true;
+      if (! instance)
+        (*current_liboctave_error_handler)
+          ("unable to create current working directory object!");
+
+      return retval;
+    }
 
-  if (! instance)
+    std::string
+    env::polite_directory_format (const std::string& name)
+    {
+      return (instance_ok ())
+        ? instance->do_polite_directory_format (name) : "";
+    }
+
+    bool
+    env::absolute_pathname (const std::string& s)
     {
-      instance = new octave_env ();
+      return (instance_ok ())
+        ? instance->do_absolute_pathname (s) : false;
+    }
 
-      if (instance)
-        singleton_cleanup_list::add (cleanup_instance);
+    bool
+    env::rooted_relative_pathname (const std::string& s)
+    {
+      return (instance_ok ())
+        ? instance->do_rooted_relative_pathname (s) : false;
     }
 
-  if (! instance)
-    (*current_liboctave_error_handler)
-      ("unable to create current working directory object!");
-
-  return retval;
-}
+    std::string
+    env::base_pathname (const std::string& s)
+    {
+      return (instance_ok ())
+        ? instance->do_base_pathname (s) : "";
+    }
 
-std::string
-octave_env::polite_directory_format (const std::string& name)
-{
-  return (instance_ok ())
-         ? instance->do_polite_directory_format (name) : "";
-}
-
-bool
-octave_env::absolute_pathname (const std::string& s)
-{
-  return (instance_ok ())
-         ? instance->do_absolute_pathname (s) : false;
-}
+    std::string
+    env::make_absolute (const std::string& s, const std::string& dot_path)
+    {
+      return (instance_ok ())
+        ? instance->do_make_absolute (s, dot_path) : "";
+    }
 
-bool
-octave_env::rooted_relative_pathname (const std::string& s)
-{
-  return (instance_ok ())
-         ? instance->do_rooted_relative_pathname (s) : false;
-}
-
-std::string
-octave_env::base_pathname (const std::string& s)
-{
-  return (instance_ok ())
-         ? instance->do_base_pathname (s) : "";
-}
+    std::string
+    env::get_current_directory ()
+    {
+      return (instance_ok ())
+        ? instance->do_getcwd () : "";
+    }
 
-std::string
-octave_env::make_absolute (const std::string& s, const std::string& dot_path)
-{
-  return (instance_ok ())
-         ? instance->do_make_absolute (s, dot_path) : "";
-}
+    std::string
+    env::get_home_directory ()
+    {
+      return (instance_ok ())
+        ? instance->do_get_home_directory () : "";
+    }
 
-std::string
-octave_env::get_current_directory ()
-{
-  return (instance_ok ())
-         ? instance->do_getcwd () : "";
-}
+    std::string
+    env::get_temp_directory ()
+    {
+      return (instance_ok ())
+        ? instance->do_get_temp_directory () : "";
+    }
 
-std::string
-octave_env::get_home_directory ()
-{
-  return (instance_ok ())
-         ? instance->do_get_home_directory () : "";
-}
+    std::string
+    env::get_program_name (void)
+    {
+      return (instance_ok ())
+        ? instance->prog_name : "";
+    }
 
-std::string
-octave_env::get_temp_directory ()
-{
-  return (instance_ok ())
-         ? instance->do_get_temp_directory () : "";
-}
-
-std::string
-octave_env::get_program_name (void)
-{
-  return (instance_ok ())
-         ? instance->prog_name : "";
-}
+    std::string
+    env::get_program_invocation_name (void)
+    {
+      return (instance_ok ())
+        ? instance->prog_invocation_name : "";
+    }
 
-std::string
-octave_env::get_program_invocation_name (void)
-{
-  return (instance_ok ())
-         ? instance->prog_invocation_name : "";
-}
-
-void
-octave_env::set_program_name (const std::string& s)
-{
-  if (instance_ok ())
-    instance->do_set_program_name (s);
-}
+    void
+    env::set_program_name (const std::string& s)
+    {
+      if (instance_ok ())
+        instance->do_set_program_name (s);
+    }
 
-std::string
-octave_env::get_user_name (void)
-{
-  return (instance_ok ())
-         ? instance->do_get_user_name () : "";
-}
+    std::string
+    env::get_user_name (void)
+    {
+      return (instance_ok ())
+        ? instance->do_get_user_name () : "";
+    }
 
-std::string
-octave_env::get_host_name (void)
-{
-  return (instance_ok ())
-         ? instance->do_get_host_name () : "";
-}
+    std::string
+    env::get_host_name (void)
+    {
+      return (instance_ok ())
+        ? instance->do_get_host_name () : "";
+    }
 
-std::string
-octave_env::do_get_temp_directory (void) const
-{
-  std::string tempd;
+    std::string
+    env::do_get_temp_directory (void) const
+    {
+      std::string tempd;
 
 #if defined (__MINGW32__) || defined (_MSC_VER)
 
-  tempd = do_getenv ("TEMP");
+      tempd = do_getenv ("TEMP");
 
-  if (tempd.empty ())
-    tempd = do_getenv ("TMP");
+      if (tempd.empty ())
+        tempd = do_getenv ("TMP");
 
-  #if defined (P_tmpdir)
-  if (tempd.empty ())
-    tempd = P_tmpdir;
-  #endif
+#if defined (P_tmpdir)
+      if (tempd.empty ())
+        tempd = P_tmpdir;
+#endif
 
-  // Some versions of MinGW and MSVC either don't define P_tmpdir, or
-  // define it to a single backslash.  In such cases just use C:\temp.
-  if (tempd.empty () || tempd == "\\")
-    tempd = "c:\\temp";
+      // Some versions of MinGW and MSVC either don't define P_tmpdir, or
+      // define it to a single backslash.  In such cases just use C:\temp.
+      if (tempd.empty () || tempd == "\\")
+        tempd = "c:\\temp";
 
 #else
 
-  tempd = do_getenv ("TMP");
+      tempd = do_getenv ("TMP");
 
-  #if defined (P_tmpdir)
-  if (tempd.empty ())
-    tempd = P_tmpdir;
-  #else
-  if (tempd.empty ())
-    tempd = "/tmp";
-  #endif
+#if defined (P_tmpdir)
+      if (tempd.empty ())
+        tempd = P_tmpdir;
+#else
+      if (tempd.empty ())
+        tempd = "/tmp";
+#endif
 
 #endif
 
-  return tempd;
-}
+      return tempd;
+    }
 
-// FIXME: this leaves no way to distinguish between a
-// variable that is not set and one that is set to the empty string.
-// Is this a problem?
+    // FIXME: this leaves no way to distinguish between a
+    // variable that is not set and one that is set to the empty string.
+    // Is this a problem?
 
-std::string
-octave_env::getenv (const std::string& name)
-{
-  return (instance_ok ())
-         ? instance->do_getenv (name) : "";
-}
+    std::string
+    env::getenv (const std::string& name)
+    {
+      return (instance_ok ())
+        ? instance->do_getenv (name) : "";
+    }
 
-void
-octave_env::putenv (const std::string& name, const std::string& value)
-{
-  octave_putenv (name, value);
-}
+    void
+    env::putenv (const std::string& name, const std::string& value)
+    {
+      octave_putenv (name, value);
+    }
 
-bool
-octave_env::have_x11_display (void)
-{
-  std::string display = getenv ("DISPLAY");
+    bool
+    env::have_x11_display (void)
+    {
+      std::string display = getenv ("DISPLAY");
 
-  return ! display.empty ();
-}
+      return ! display.empty ();
+    }
 
-bool
-octave_env::chdir (const std::string& newdir)
-{
-  return (instance_ok ())
-         ? instance->do_chdir (newdir) : false;
-}
+    bool
+    env::chdir (const std::string& newdir)
+    {
+      return (instance_ok ())
+        ? instance->do_chdir (newdir) : false;
+    }
 
-void
-octave_env::do_set_program_name (const std::string& s) const
-{
-  static bool initialized = false;
-
-  if (! initialized)
+    void
+    env::do_set_program_name (const std::string& s) const
     {
-      // The string passed to gnulib's ::set_program_name function must
-      // exist for the duration of the program so allocate a copy here
-      // instead of passing S.c_str () which only exists as long as the
-      // string object S.
+      static bool initialized = false;
 
-      // For gnulib.
-      ::set_program_name (strsave (s.c_str ()));
+      if (! initialized)
+        {
+          // The string passed to gnulib's ::set_program_name function must
+          // exist for the duration of the program so allocate a copy here
+          // instead of passing S.c_str () which only exists as long as the
+          // string object S.
+
+          // For gnulib.
+          ::set_program_name (strsave (s.c_str ()));
 
-      // Let gnulib strip off things like the "lt-" prefix from libtool.
-      prog_invocation_name = program_name;
+          // Let gnulib strip off things like the "lt-" prefix from libtool.
+          prog_invocation_name = program_name;
 
-      size_t pos
-        = prog_invocation_name.find_last_of (file_ops::dir_sep_chars ());
+          size_t pos
+            = prog_invocation_name.find_last_of (file_ops::dir_sep_chars ());
 
-      // Also keep a shortened version of the program name.
-      prog_name = (pos == std::string::npos
-                   ? prog_invocation_name
-                   : prog_invocation_name.substr (pos+1));
+          // Also keep a shortened version of the program name.
+          prog_name = (pos == std::string::npos
+                       ? prog_invocation_name
+                       : prog_invocation_name.substr (pos+1));
 
-      initialized = true;
+          initialized = true;
+        }
     }
-}
 
-// Return a pretty pathname.  If the first part of the pathname is the
-// same as $HOME, then replace that with '~'.
+    // Return a pretty pathname.  If the first part of the pathname is the
+    // same as $HOME, then replace that with '~'.
 
-std::string
-octave_env::do_polite_directory_format (const std::string& name) const
-{
-  std::string retval;
+    std::string
+    env::do_polite_directory_format (const std::string& name) const
+    {
+      std::string retval;
 
-  std::string home_dir = do_get_home_directory ();
+      std::string home_dir = do_get_home_directory ();
 
-  size_t len = home_dir.length ();
+      size_t len = home_dir.length ();
 
-  if (len > 1 && home_dir == name.substr (0, len)
-      && (name.length () == len || file_ops::is_dir_sep (name[len])))
-    {
-      retval = "~";
-      retval.append (name.substr (len));
-    }
-  else
-    retval = name;
+      if (len > 1 && home_dir == name.substr (0, len)
+          && (name.length () == len || file_ops::is_dir_sep (name[len])))
+        {
+          retval = "~";
+          retval.append (name.substr (len));
+        }
+      else
+        retval = name;
 
-  return retval;
-}
+      return retval;
+    }
 
-bool
-octave_env::do_absolute_pathname (const std::string& s) const
-{
-  size_t len = s.length ();
+    bool
+    env::do_absolute_pathname (const std::string& s) const
+    {
+      size_t len = s.length ();
 
-  if (len == 0)
-    return false;
+      if (len == 0)
+        return false;
 
-  if (file_ops::is_dir_sep (s[0]))
-    return true;
+      if (file_ops::is_dir_sep (s[0]))
+        return true;
 
 #if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM)
-  if ((len == 2 && isalpha (s[0]) && s[1] == ':')
-      || (len > 2 && isalpha (s[0]) && s[1] == ':'
-          && file_ops::is_dir_sep (s[2])))
-    return true;
+      if ((len == 2 && isalpha (s[0]) && s[1] == ':')
+          || (len > 2 && isalpha (s[0]) && s[1] == ':'
+              && file_ops::is_dir_sep (s[2])))
+        return true;
 #endif
 
-  return false;
-}
+      return false;
+    }
 
-bool
-octave_env::do_rooted_relative_pathname (const std::string& s) const
-{
-  size_t len = s.length ();
+    bool
+    env::do_rooted_relative_pathname (const std::string& s) const
+    {
+      size_t len = s.length ();
+
+      if (len == 0)
+        return false;
 
-  if (len == 0)
-    return false;
+      if (len == 1 && s[0] == '.')
+        return true;
+
+      if (len > 1 && s[0] == '.' && file_ops::is_dir_sep (s[1]))
+        return true;
 
-  if (len == 1 && s[0] == '.')
-    return true;
+      if (len == 2 && s[0] == '.' && s[1] == '.')
+        return true;
 
-  if (len > 1 && s[0] == '.' && file_ops::is_dir_sep (s[1]))
-    return true;
+      if (len > 2 && s[0] == '.' && s[1] == '.' && file_ops::is_dir_sep (s[2]))
+        return true;
 
-  if (len == 2 && s[0] == '.' && s[1] == '.')
-    return true;
+      return false;
+    }
 
-  if (len > 2 && s[0] == '.' && s[1] == '.' && file_ops::is_dir_sep (s[2]))
-    return true;
-
-  return false;
-}
+    // Return the 'basename' of the pathname in STRING (the stuff after
+    // the last directory separator).  If STRING is not a full pathname,
+    // simply return it.
 
-// Return the 'basename' of the pathname in STRING (the stuff after
-// the last directory separator).  If STRING is not a full pathname,
-// simply return it.
+    std::string
+    env::do_base_pathname (const std::string& s) const
+    {
+      if (! (do_absolute_pathname (s) || do_rooted_relative_pathname (s)))
+        return s;
+
+      size_t pos = s.find_last_of (file_ops::dir_sep_chars ());
 
-std::string
-octave_env::do_base_pathname (const std::string& s) const
-{
-  if (! (do_absolute_pathname (s) || do_rooted_relative_pathname (s)))
-    return s;
+      if (pos == std::string::npos)
+        return s;
+      else
+        return s.substr (pos+1);
+    }
 
-  size_t pos = s.find_last_of (file_ops::dir_sep_chars ());
+    // Turn STRING (a pathname) into an absolute pathname, assuming that
+    // DOT_PATH contains the symbolic location of the current directory.
 
-  if (pos == std::string::npos)
-    return s;
-  else
-    return s.substr (pos+1);
-}
+    std::string
+    env::do_make_absolute (const std::string& s,
+                           const std::string& dot_path) const
+    {
+      if (dot_path.empty () || s.empty () || do_absolute_pathname (s))
+        return s;
 
-// Turn STRING (a pathname) into an absolute pathname, assuming that
-// DOT_PATH contains the symbolic location of the current directory.
+      std::string current_dir = dot_path;
 
-std::string
-octave_env::do_make_absolute (const std::string& s,
-                              const std::string& dot_path) const
-{
-  if (dot_path.empty () || s.empty () || do_absolute_pathname (s))
-    return s;
+      if (current_dir.empty ())
+        current_dir = do_getcwd ();
+
+      size_t pos = current_dir.length () - 1;
 
-  std::string current_dir = dot_path;
+      if (! file_ops::is_dir_sep (current_dir[pos]))
+        current_dir.append (file_ops::dir_sep_str ());
 
-  if (current_dir.empty ())
-    current_dir = do_getcwd ();
+      // FIXME: this is probably not correct for all systems.
+
+      size_t i = 0;
+      size_t slen = s.length ();
 
-  size_t pos = current_dir.length () - 1;
-
-  if (! file_ops::is_dir_sep (current_dir[pos]))
-    current_dir.append (file_ops::dir_sep_str ());
+      while (i < slen)
+        {
+          if (s[i] == '.')
+            {
+              if (i + 1 == slen)
+                return current_dir;
 
-  // FIXME: this is probably not correct for all systems.
-
-  size_t i = 0;
-  size_t slen = s.length ();
+              if (file_ops::is_dir_sep (s[i+1]))
+                {
+                  i += 2;
+                  continue;
+                }
 
-  while (i < slen)
-    {
-      if (s[i] == '.')
-        {
-          if (i + 1 == slen)
-            return current_dir;
+              if (s[i+1] == '.'
+                  && (i + 2 == slen || file_ops::is_dir_sep (s[i+2])))
+                {
+                  i += 2;
 
-          if (file_ops::is_dir_sep (s[i+1]))
-            {
-              i += 2;
-              continue;
+                  if (i != slen)
+                    i++;
+
+                  pathname_backup (current_dir, 1);
+
+                  continue;
+                }
             }
 
-          if (s[i+1] == '.'
-              && (i + 2 == slen || file_ops::is_dir_sep (s[i+2])))
-            {
-              i += 2;
+          size_t tmp = s.find_first_of (file_ops::dir_sep_chars (), i);
 
-              if (i != slen)
-                i++;
-
-              pathname_backup (current_dir, 1);
-
-              continue;
+          if (tmp == std::string::npos)
+            {
+              current_dir.append (s, i, tmp-i);
+              break;
+            }
+          else
+            {
+              current_dir.append (s, i, tmp-i+1);
+              i = tmp + 1;
             }
         }
 
-      size_t tmp = s.find_first_of (file_ops::dir_sep_chars (), i);
-
-      if (tmp == std::string::npos)
-        {
-          current_dir.append (s, i, tmp-i);
-          break;
-        }
-      else
-        {
-          current_dir.append (s, i, tmp-i+1);
-          i = tmp + 1;
-        }
+      return current_dir;
     }
 
-  return current_dir;
-}
-
-// Return a string which is the current working directory.
+    // Return a string which is the current working directory.
 
-std::string
-octave_env::do_getcwd () const
-{
-  if (! follow_symbolic_links)
-    current_directory = "";
+    std::string
+    env::do_getcwd () const
+    {
+      if (! follow_symbolic_links)
+        current_directory = "";
+
+      if (verbatim_pwd || current_directory.empty ())
+        current_directory = ::octave_getcwd ();
 
-  if (verbatim_pwd || current_directory.empty ())
-    current_directory = ::octave_getcwd ();
-
-  return current_directory;
-}
+      return current_directory;
+    }
 
-// This value is not cached because it can change while Octave is
-// running.
+    // This value is not cached because it can change while Octave is
+    // running.
 
-std::string
-octave_env::do_get_home_directory (void) const
-{
-  std::string hd = do_getenv ("HOME");
+    std::string
+    env::do_get_home_directory (void) const
+    {
+      std::string hd = do_getenv ("HOME");
 
 #if defined (__MINGW32__) || defined (_MSC_VER)
-  // Maybe we are started directly from cmd.exe.
-  if (hd.empty ())
-    {
-      std::string drv = do_getenv ("HOMEDRIVE");
-      if (drv.empty ())
-        hd = do_getenv ("HOMEPATH");
-      else
-        hd = drv + do_getenv ("HOMEPATH");
-    }
+      // Maybe we are started directly from cmd.exe.
+      if (hd.empty ())
+        {
+          std::string drv = do_getenv ("HOMEDRIVE");
+          if (drv.empty ())
+            hd = do_getenv ("HOMEPATH");
+          else
+            hd = drv + do_getenv ("HOMEPATH");
+        }
 #endif
 
-  if (hd.empty ())
-    {
-      octave::sys::password pw = octave::sys::password::getpwuid (octave::sys::getuid ());
+      if (hd.empty ())
+        {
+          octave::sys::password pw = octave::sys::password::getpwuid (octave::sys::getuid ());
 
-      hd = pw ? pw.dir () : std::string (file_ops::dir_sep_str ());
+          hd = pw ? pw.dir () : std::string (file_ops::dir_sep_str ());
+        }
+
+      return hd;
     }
 
-  return hd;
-}
+    std::string
+    env::do_get_user_name (void) const
+    {
+      if (user_name.empty ())
+        {
+          octave::sys::password pw = octave::sys::password::getpwuid (octave::sys::getuid ());
 
-std::string
-octave_env::do_get_user_name (void) const
-{
-  if (user_name.empty ())
-    {
-      octave::sys::password pw = octave::sys::password::getpwuid (octave::sys::getuid ());
+          user_name = pw ? pw.name () : std::string ("unknown");
+        }
 
-      user_name = pw ? pw.name () : std::string ("unknown");
+      return user_name;
     }
 
-  return user_name;
-}
+    std::string
+    env::do_get_host_name (void) const
+    {
+      if (host_name.empty ())
+        {
+          char hostname[1024];
 
-std::string
-octave_env::do_get_host_name (void) const
-{
-  if (host_name.empty ())
-    {
-      char hostname[1024];
+          int status = gnulib::gethostname (hostname, 1023);
 
-      int status = gnulib::gethostname (hostname, 1023);
+          host_name = (status < 0) ? "unknown" : hostname;
+        }
 
-      host_name = (status < 0) ? "unknown" : hostname;
+      return host_name;
     }
 
-  return host_name;
-}
+    std::string
+    env::do_getenv (const std::string& name) const
+    {
+      char *value = ::getenv (name.c_str ());
+
+      return value ? value : "";
+    }
 
-std::string
-octave_env::do_getenv (const std::string& name) const
-{
-  char *value = ::getenv (name.c_str ());
+    // Do the work of changing to the directory NEWDIR.  Handle symbolic
+    // link following, etc.
+
+    bool
+    env::do_chdir (const std::string& newdir)
+    {
+      bool retval = false;
 
-  return value ? value : "";
-}
+      std::string tmp;
+
+      if (follow_symbolic_links)
+        {
+          if (current_directory.empty ())
+            do_getcwd ();
 
-// Do the work of changing to the directory NEWDIR.  Handle symbolic
-// link following, etc.
+          if (current_directory.empty ())
+            tmp = newdir;
+          else
+            tmp = do_make_absolute (newdir, current_directory);
 
-bool
-octave_env::do_chdir (const std::string& newdir)
-{
-  bool retval = false;
+          // Get rid of trailing directory separator.
+
+          size_t len = tmp.length ();
 
-  std::string tmp;
+          if (len > 1)
+            {
+              if (file_ops::is_dir_sep (tmp[--len]))
+                tmp.resize (len);
+            }
 
-  if (follow_symbolic_links)
-    {
-      if (current_directory.empty ())
-        do_getcwd ();
-
-      if (current_directory.empty ())
-        tmp = newdir;
+          if (! ::octave_chdir (tmp))
+            {
+              current_directory = tmp;
+              retval = true;
+            }
+        }
       else
-        tmp = do_make_absolute (newdir, current_directory);
+        retval = (! ::octave_chdir (newdir));
 
-      // Get rid of trailing directory separator.
+      return retval;
+    }
+
+    // Remove the last N directories from PATH.
 
-      size_t len = tmp.length ();
+    void
+    env::pathname_backup (std::string& path, int n) const
+    {
+      if (path.empty ())
+        return;
+
+      size_t i = path.length () - 1;
 
-      if (len > 1)
+      while (n--)
         {
-          if (file_ops::is_dir_sep (tmp[--len]))
-            tmp.resize (len);
+          while (file_ops::is_dir_sep (path[i]) && i > 0)
+            i--;
+
+          while (! file_ops::is_dir_sep (path[i]) && i > 0)
+            i--;
+
+          i++;
         }
 
-      if (! ::octave_chdir (tmp))
-        {
-          current_directory = tmp;
-          retval = true;
-        }
-    }
-  else
-    retval = (! ::octave_chdir (newdir));
-
-  return retval;
-}
-
-// Remove the last N directories from PATH.
-
-void
-octave_env::pathname_backup (std::string& path, int n) const
-{
-  if (path.empty ())
-    return;
-
-  size_t i = path.length () - 1;
-
-  while (n--)
-    {
-      while (file_ops::is_dir_sep (path[i]) && i > 0)
-        i--;
-
-      while (! file_ops::is_dir_sep (path[i]) && i > 0)
-        i--;
-
-      i++;
+      path.resize (i);
     }
 
-  path.resize (i);
-}
+    void
+    env::error (int err_num) const
+    {
+      (*current_liboctave_error_handler) ("%s", gnulib::strerror (err_num));
+    }
 
-void
-octave_env::error (int err_num) const
-{
-  (*current_liboctave_error_handler) ("%s", gnulib::strerror (err_num));
+    void
+    env::error (const std::string& s) const
+    {
+      (*current_liboctave_error_handler) ("%s", s.c_str ());
+    }
+  }
 }
-
-void
-octave_env::error (const std::string& s) const
-{
-  (*current_liboctave_error_handler) ("%s", s.c_str ());
-}
diff --git a/liboctave/system/oct-env.h b/liboctave/system/oct-env.h
--- a/liboctave/system/oct-env.h
+++ b/liboctave/system/oct-env.h
@@ -22,127 +22,142 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_oct_env_h)
 #define octave_oct_env_h 1
 
 #include "octave-config.h"
 
 #include <string>
 
-class
-OCTAVE_API
-octave_env
+namespace
+octave
 {
-protected:
-
-  octave_env (void);
-
-public:
+  namespace
+  sys
+  {
+    class
+    OCTAVE_API
+    env
+    {
+    protected:
 
-  static std::string polite_directory_format (const std::string& name);
+      env (void);
 
-  static bool absolute_pathname (const std::string& s);
+    public:
 
-  static bool rooted_relative_pathname (const std::string& s);
+      static std::string polite_directory_format (const std::string& name);
 
-  static std::string base_pathname (const std::string& s);
+      static bool absolute_pathname (const std::string& s);
 
-  static std::string
-  make_absolute (const std::string& s,
-                 const std::string& dot_path = get_current_directory ());
+      static bool rooted_relative_pathname (const std::string& s);
+
+      static std::string base_pathname (const std::string& s);
 
-  static std::string get_current_directory (void);
+      static std::string
+        make_absolute (const std::string& s,
+                       const std::string& dot_path = get_current_directory ());
 
-  static std::string get_home_directory (void);
-
-  static std::string get_temp_directory (void);
+      static std::string get_current_directory (void);
 
-  static std::string get_program_name (void);
+      static std::string get_home_directory (void);
 
-  static std::string get_program_invocation_name (void);
+      static std::string get_temp_directory (void);
 
-  static std::string get_user_name (void);
+      static std::string get_program_name (void);
 
-  static std::string get_host_name (void);
+      static std::string get_program_invocation_name (void);
 
-  static std::string getenv (const std::string& name);
+      static std::string get_user_name (void);
 
-  static void putenv (const std::string& name, const std::string& value);
+      static std::string get_host_name (void);
 
-  static bool have_x11_display (void);
+      static std::string getenv (const std::string& name);
+
+      static void putenv (const std::string& name, const std::string& value);
 
-  static bool chdir (const std::string& newdir);
+      static bool have_x11_display (void);
 
-  static void set_program_name (const std::string& s);
+      static bool chdir (const std::string& newdir);
 
-private:
+      static void set_program_name (const std::string& s);
 
-  static bool instance_ok (void);
+    private:
+
+      static bool instance_ok (void);
 
-  std::string do_polite_directory_format (const std::string& name) const;
+      std::string do_polite_directory_format (const std::string& name) const;
 
-  bool do_absolute_pathname (const std::string& s) const;
+      bool do_absolute_pathname (const std::string& s) const;
 
-  bool do_rooted_relative_pathname (const std::string& s) const;
+      bool do_rooted_relative_pathname (const std::string& s) const;
 
-  std::string do_base_pathname (const std::string& s) const;
+      std::string do_base_pathname (const std::string& s) const;
 
-  std::string do_make_absolute (const std::string& s,
-                                const std::string& dot_path) const;
+      std::string do_make_absolute (const std::string& s,
+                                    const std::string& dot_path) const;
 
-  std::string do_getcwd (void) const;
+      std::string do_getcwd (void) const;
 
-  std::string do_get_home_directory (void) const;
+      std::string do_get_home_directory (void) const;
 
-  std::string do_get_temp_directory (void) const;
+      std::string do_get_temp_directory (void) const;
 
-  std::string do_get_user_name (void) const;
+      std::string do_get_user_name (void) const;
 
-  std::string do_get_host_name (void) const;
+      std::string do_get_host_name (void) const;
 
-  std::string do_getenv (const std::string& name) const;
+      std::string do_getenv (const std::string& name) const;
 
-  void do_putenv (const std::string& name, const std::string& value) const;
+      void do_putenv (const std::string& name, const std::string& value) const;
 
-  bool do_chdir (const std::string& newdir);
+      bool do_chdir (const std::string& newdir);
 
-  void do_set_program_name (const std::string& s) const;
+      void do_set_program_name (const std::string& s) const;
 
-  void pathname_backup (std::string& path, int n) const;
+      void pathname_backup (std::string& path, int n) const;
 
-  void error (int) const;
+      void error (int) const;
 
-  void error (const std::string&) const;
+      void error (const std::string&) const;
 
-  // No copying!
+      // No copying!
 
-  octave_env (const octave_env&);
+      env (const env&);
 
-  octave_env& operator = (const octave_env&);
+      env& operator = (const env&);
 
-  // The real thing.
-  static octave_env *instance;
+      // The real thing.
+      static env *instance;
 
 
-  static void cleanup_instance (void) { delete instance; instance = 0; }
+      static void cleanup_instance (void) { delete instance; instance = 0; }
+
+      // TRUE means follow symbolic links that point to directories just
+      // as if they are real directories.
+      bool follow_symbolic_links;
 
-  // TRUE means follow symbolic links that point to directories just
-  // as if they are real directories.
-  bool follow_symbolic_links;
+      // TRUE means that pwd always give verbatim directory, regardless
+      // of symbolic link following.
+      bool verbatim_pwd;
 
-  // TRUE means that pwd always give verbatim directory, regardless
-  // of symbolic link following.
-  bool verbatim_pwd;
+      // Where are we?
+      mutable std::string current_directory;
 
-  // Where are we?
-  mutable std::string current_directory;
+      // Etc.
+      mutable std::string prog_name;
 
-  // Etc.
-  mutable std::string prog_name;
+      mutable std::string prog_invocation_name;
+
+      mutable std::string user_name;
 
-  mutable std::string prog_invocation_name;
+      mutable std::string host_name;
+    };
+  }
+}
 
-  mutable std::string user_name;
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  mutable std::string host_name;
-};
+OCTAVE_DEPRECATED ("use octave::sys::env instead")
+typedef octave::sys::env octave_env;
 
 #endif
+
+#endif
diff --git a/liboctave/util/cmd-edit.cc b/liboctave/util/cmd-edit.cc
--- a/liboctave/util/cmd-edit.cc
+++ b/liboctave/util/cmd-edit.cc
@@ -230,17 +230,17 @@ gnu_readline::gnu_readline ()
     previous_pre_input_hook (0),
     previous_event_hook (0), completion_function (0),
     quoting_function (0), dequoting_function (0),
     char_is_quoted_function (0), user_accept_line_function (0)
 {
   // FIXME: need interface to rl_add_defun, rl_initialize, and
   // a function to set rl_terminal_name
 
-  std::string term = octave_env::getenv ("TERM");
+  std::string term = octave::sys::env::getenv ("TERM");
 
   octave_rl_set_terminal_name (term.c_str ());
 
   octave_rl_initialize ();
 
   do_blink_matching_paren (true);
 
   // Bind operate-and-get-next.
@@ -1631,29 +1631,29 @@ command_editor::do_decode_prompt_string 
               {
                 tmpstr = '\033';
 
                 break;
               }
 
             case 'h':
               {
-                tmpstr = octave_env::get_host_name ();
+                tmpstr = octave::sys::env::get_host_name ();
 
                 size_t pos = tmpstr.find ('.');
 
                 if (pos != std::string::npos)
                   tmpstr.resize (pos);
 
                 break;
               }
 
             case 'H':
               {
-                tmpstr = octave_env::get_host_name ();
+                tmpstr = octave::sys::env::get_host_name ();
 
                 break;
               }
 
             case 'n':
               {
                 tmpstr = newline_chars ();
 
@@ -1664,55 +1664,55 @@ command_editor::do_decode_prompt_string 
               {
                 tmpstr = '\r';
 
                 break;
               }
 
             case 's':
               {
-                tmpstr = octave_env::get_program_name ();
-                tmpstr = octave_env::base_pathname (tmpstr);
+                tmpstr = octave::sys::env::get_program_name ();
+                tmpstr = octave::sys::env::base_pathname (tmpstr);
 
                 break;
               }
 
             case 'u':
               {
-                tmpstr = octave_env::get_user_name ();
+                tmpstr = octave::sys::env::get_user_name ();
 
                 break;
               }
 
             case 'w':
             case 'W':
               {
                 try
                   {
-                    tmpstr = octave_env::get_current_directory ();
+                    tmpstr = octave::sys::env::get_current_directory ();
                   }
                 catch (const octave_execution_exception&)
                   {
                     tmpstr = "";
                   }
 
-                std::string home_dir = octave_env::get_home_directory ();
+                std::string home_dir = octave::sys::env::get_home_directory ();
 
                 if (c == 'W' && (home_dir.empty () || tmpstr != home_dir))
                   {
                     if (tmpstr != "/" && tmpstr != "//")
                       {
                         size_t pos = tmpstr.rfind ('/');
 
                         if (pos != std::string::npos && pos != 0)
                           tmpstr = tmpstr.substr (pos + 1);
                       }
                   }
                 else
-                  tmpstr = octave_env::polite_directory_format (tmpstr);
+                  tmpstr = octave::sys::env::polite_directory_format (tmpstr);
 
                 break;
               }
 
             case '!':
               {
                 char number_buffer[32];
                 int num = command_history::current_number ();
diff --git a/liboctave/util/kpse.cc b/liboctave/util/kpse.cc
--- a/liboctave/util/kpse.cc
+++ b/liboctave/util/kpse.cc
@@ -511,17 +511,17 @@ private:
 
 /* Here's the simple one, when a program just wants a value.  */
 
 static std::string
 kpse_var_value (const std::string& var)
 {
   std::string ret;
 
-  std::string tmp = octave_env::getenv (var);
+  std::string tmp = octave::sys::env::getenv (var);
 
   if (! tmp.empty ())
     ret = kpse_var_expand (tmp);
 
 #if defined (KPSE_DEBUG)
   if (KPSE_DEBUG_P (KPSE_DEBUG_VARS))
     DEBUGF2 ("variable: %s = %s\n", var.c_str (),
              tmp.empty () ? "(nil)" :  tmp.c_str ());
@@ -1195,28 +1195,28 @@ kpse_tilde_expand (const std::string& na
       expansion = name;
 
       /* If a bare tilde, return the home directory or '.'.  (Very
          unlikely that the directory name will do anyone any good, but
          ...  */
     }
   else if (name.length () == 1)
     {
-      expansion = octave_env::get_home_directory ();
+      expansion = octave::sys::env::get_home_directory ();
 
       if (expansion.empty ())
         expansion = ".";
 
       /* If '~/', remove any trailing / or replace leading // in $HOME.
          Should really check for doubled intermediate slashes, too.  */
     }
   else if (IS_DIR_SEP (name[1]))
     {
       unsigned c = 1;
-      std::string home = octave_env::get_home_directory ();
+      std::string home = octave::sys::env::get_home_directory ();
 
       if (home.empty ())
         home = ".";
 
       size_t home_len = home.length ();
 
       /* handle leading // */
       if (home_len > 1 && IS_DIR_SEP (home[0]) && IS_DIR_SEP (home[1]))
@@ -1287,17 +1287,17 @@ static string_vector brace_expand (const
 
 /* If $KPSE_DOT is defined in the environment, prepend it to any relative
    path components. */
 
 static std::string
 kpse_expand_kpse_dot (const std::string& path)
 {
   std::string ret;
-  std::string kpse_dot = octave_env::getenv ("KPSE_DOT");
+  std::string kpse_dot = octave::sys::env::getenv ("KPSE_DOT");
 
   if (kpse_dot.empty ())
     return path;
 
   for (kpse_path_iterator pi (path); pi != std::string::npos; pi++)
     {
       std::string elt = *pi;
 
@@ -2548,17 +2548,17 @@ expand (std::string &expansion, const st
       (*current_liboctave_warning_with_id_handler)
         ("Octave:pathsearch-syntax",
          "kpathsea: variable '%s' references itself (eventually)",
          var.c_str ());
     }
   else
     {
       /* Check for an environment variable.  */
-      std::string value = octave_env::getenv (var);
+      std::string value = octave::sys::env::getenv (var);
 
       if (! value.empty ())
         {
           expanding (var, true);
           std::string tmp = kpse_var_expand (value);
           expanding (var, false);
           expansion += tmp;
         }
diff --git a/liboctave/util/pathsearch.cc b/liboctave/util/pathsearch.cc
--- a/liboctave/util/pathsearch.cc
+++ b/liboctave/util/pathsearch.cc
@@ -140,17 +140,17 @@ dir_path::find_all_first_of (const strin
 
 void
 dir_path::init (void)
 {
   static bool octave_kpathsea_initialized = false;
 
   if (! octave_kpathsea_initialized)
     {
-      std::string val = octave_env::getenv ("KPATHSEA_DEBUG");
+      std::string val = octave::sys::env::getenv ("KPATHSEA_DEBUG");
 
       if (! val.empty ())
         kpathsea_debug |= atoi (val.c_str ());
 
       octave_kpathsea_initialized = true;
     }
 
   p = kpse_path_expand (p_default.empty ()
