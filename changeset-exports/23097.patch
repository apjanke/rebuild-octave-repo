# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1485490785 18000
#      Thu Jan 26 23:19:45 2017 -0500
# Node ID 0c5f04b9dca1124bf08d26dbc51f06bd3802b9ce
# Parent  b7a24a734c37a85d671128dc9d19a6a994d141e5
style fixes

* __init_fltk__.cc: Use m_ prefix for class data members.  Use
constructor initialization lists where practical.

diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -115,45 +115,46 @@ left drag - pan\n\
 mouse wheel - zoom\n\
 right drag - rectangle zoom\n\
 left double click - autoscale\n\
 ";
 
 class OpenGL_fltk : public Fl_Gl_Window
 {
 public:
+
   OpenGL_fltk (int xx, int yy, int ww, int hh, double num)
-    : Fl_Gl_Window (xx, yy, ww, hh, 0), number (num), renderer (),
-      in_zoom (false), zoom_box ()
+    : Fl_Gl_Window (xx, yy, ww, hh, 0), m_number (num), m_renderer (),
+      m_in_zoom (false), m_zoom_box ()
   {
 #if defined (HAVE_OPENGL)
     // Ask for double buffering and a depth buffer.
     mode (FL_DEPTH | FL_DOUBLE | FL_MULTISAMPLE);
 #else
     err_disabled_feature ("OpenGL_fltk", "OpenGL");
 #endif
   }
 
   ~OpenGL_fltk (void) = default;
 
   void zoom (bool z)
   {
-    in_zoom = z;
-    if (! in_zoom)
+    m_in_zoom = z;
+    if (! m_in_zoom)
       hide_overlay ();
   }
 
-  bool zoom (void) { return in_zoom; }
-  void set_zoom_box (const Matrix& zb) { zoom_box = zb; }
+  bool zoom (void) { return m_in_zoom; }
+  void set_zoom_box (const Matrix& zb) { m_zoom_box = zb; }
 
   void print (const std::string& cmd, const std::string& term)
   {
     //std::cout << "OpenGL_fltk::print(cmd=" << cmd << ", term=" << term << ") canvas size = " << w () << "x" << h () << std::endl;
 
-    gl2ps_print (gh_manager::get_object (number), cmd, term);
+    gl2ps_print (gh_manager::get_object (m_number), cmd, term);
   }
 
   void resize (int xx, int yy, int ww, int hh)
   {
 #if defined (HAVE_OPENGL)
 
     Fl_Gl_Window::resize (xx, yy, ww, hh);
 
@@ -164,65 +165,69 @@ public:
     panic_impossible ();
 #endif
   }
 
   bool renumber (double new_number)
   {
     bool retval = false;
 
-    if (number != new_number)
+    if (m_number != new_number)
       {
-        number = new_number;
+        m_number = new_number;
         retval = true;
       }
 
     return retval;
   }
 
 private:
-  double number;
-  octave::opengl_renderer renderer;
-  bool in_zoom;
+
+  double m_number;
+
+  octave::opengl_renderer m_renderer;
+
+  bool m_in_zoom;
+
   // (x1,y1,x2,y2)
-  Matrix zoom_box;
+  Matrix m_zoom_box;
 
   void draw (void)
   {
 #if defined (HAVE_OPENGL)
 
     if (! valid ())
       {
         glMatrixMode (GL_PROJECTION);
         glLoadIdentity ();
         glViewport (0, 0, w (), h ());
       }
 
-    renderer.draw (gh_manager::get_object (number));
+    m_renderer.draw (gh_manager::get_object (m_number));
 
     if (zoom ())
       overlay ();
 
 #else
     // This shouldn't happen because construction of Opengl_fltk
     // objects is supposed to be impossible if OpenGL is not available.
 
     panic_impossible ();
 #endif
   }
 
   void zoom_box_vertex (void)
   {
 #if defined (HAVE_OPENGL)
 
-    glVertex2d (zoom_box(0), h () - zoom_box(1));
-    glVertex2d (zoom_box(0), h () - zoom_box(3));
-    glVertex2d (zoom_box(2), h () - zoom_box(3));
-    glVertex2d (zoom_box(2), h () - zoom_box(1));
-    glVertex2d (zoom_box(0), h () - zoom_box(1));
+    glVertex2d (m_zoom_box(0), h () - m_zoom_box(1));
+    glVertex2d (m_zoom_box(0), h () - m_zoom_box(3));
+    glVertex2d (m_zoom_box(2), h () - m_zoom_box(3));
+    glVertex2d (m_zoom_box(2), h () - m_zoom_box(1));
+    glVertex2d (m_zoom_box(0), h () - m_zoom_box(1));
 
 #else
     // This shouldn't happen because construction of Opengl_fltk
     // objects is supposed to be impossible if OpenGL is not available.
 
     panic_impossible ();
 #endif
   }
@@ -291,70 +296,70 @@ private:
   }
 };
 
 void script_cb (Fl_Widget*, void* data)
 {
   static_cast<uimenu::properties*> (data)->execute_callback ();
 }
 
-
 class fltk_uimenu
 {
 public:
+
   fltk_uimenu (int xx, int yy, int ww, int hh)
-  {
-    menubar = new Fl_Menu_Bar (xx, yy, ww, hh);
-  }
+    : m_menubar (new Fl_Menu_Bar (xx, yy, ww, hh))
+  { }
 
   int items_to_show (void)
   {
     //returns the number of visible menu items
-    int len = menubar->size ();
+    int len = m_menubar->size ();
     int n = 0;
     for (int t = 0; t < len; t++)
       {
-        const Fl_Menu_Item *m = static_cast<const Fl_Menu_Item*> (&
-                                (menubar->menu ()[t]));
+        const Fl_Menu_Item *m
+          = static_cast<const Fl_Menu_Item*> (&(m_menubar->menu ()[t]));
+
         if (m->label () && m->visible ())
           n++;
       }
 
     return n;
   }
 
   void show (void)
   {
-    menubar->show ();
-    menubar->redraw ();
+    m_menubar->show ();
+    m_menubar->redraw ();
   }
 
   void hide (void)
   {
-    menubar->hide ();
-    menubar->redraw ();
+    m_menubar->hide ();
+    m_menubar->redraw ();
   }
 
   bool is_visible (void)
   {
-    return menubar->visible ();
+    return m_menubar->visible ();
   }
 
   int find_index_by_name (const std::string& findname)
   {
     // This function is derived from Greg Ercolano's function
     // int GetIndexByName(...), see:
     // http://seriss.com/people/erco/fltk/#Menu_ChangeLabel
     // He agreed via PM that it can be included in octave using GPLv3
     // Kai Habel (14.10.2010)
 
     std::string menupath;
-    for (int t = 0; t < menubar->size (); t++)
+    for (int t = 0; t < m_menubar->size (); t++)
       {
-        Fl_Menu_Item *m = const_cast<Fl_Menu_Item*> (&(menubar->menu ()[t]));
+        Fl_Menu_Item *m = const_cast<Fl_Menu_Item*> (&(m_menubar->menu ()[t]));
         if (m->submenu ())
           {
             // item has submenu
             if (! menupath.empty ())
               menupath += "/";
             menupath += m->label ();
 
             if (menupath == findname)
@@ -431,26 +436,26 @@ public:
   }
 
   void delete_entry (uimenu::properties& uimenup)
   {
     std::string fltk_label = uimenup.get___fltk_label__ ();
     int idx = find_index_by_name (fltk_label.c_str ());
 
     if (idx >= 0)
-      menubar->remove (idx);
+      m_menubar->remove (idx);
   }
 
   void update_accelerator (uimenu::properties& uimenup)
   {
     std::string fltk_label = uimenup.get___fltk_label__ ();
     if (! fltk_label.empty ())
       {
-        Fl_Menu_Item* item = const_cast<Fl_Menu_Item*> (menubar->find_item (
-                               fltk_label.c_str ()));
+        Fl_Menu_Item* item =
+          const_cast<Fl_Menu_Item*> (m_menubar->find_item (fltk_label.c_str ()));
         if (item)
           {
             std::string acc = uimenup.get_accelerator ();
             if (acc.length () > 0)
               {
                 int key = FL_CTRL + acc[0];
                 item->shortcut (key);
               }
@@ -458,53 +463,53 @@ public:
       }
   }
 
   void update_callback (uimenu::properties& uimenup)
   {
     std::string fltk_label = uimenup.get___fltk_label__ ();
     if (! fltk_label.empty ())
       {
-        Fl_Menu_Item* item = const_cast<Fl_Menu_Item*> (menubar->find_item (
-                               fltk_label.c_str ()));
+        Fl_Menu_Item* item
+          = const_cast<Fl_Menu_Item*> (m_menubar->find_item (fltk_label.c_str ()));
         if (item)
           {
             if (! uimenup.get_callback ().is_empty ())
               item->callback (static_cast<Fl_Callback*> (script_cb),
                               static_cast<void*> (&uimenup));
             else
               item->callback (0, static_cast<void*> (0));
           }
       }
   }
 
   void update_enable (uimenu::properties& uimenup)
   {
     std::string fltk_label = uimenup.get___fltk_label__ ();
     if (! fltk_label.empty ())
       {
-        Fl_Menu_Item* item = const_cast<Fl_Menu_Item*> (menubar->find_item (
-                               fltk_label.c_str ()));
+        Fl_Menu_Item* item
+          = const_cast<Fl_Menu_Item*> (m_menubar->find_item (fltk_label.c_str ()));
         if (item)
           {
             if (uimenup.is_enable ())
               item->activate ();
             else
               item->deactivate ();
           }
       }
   }
 
   void update_foregroundcolor (uimenu::properties& uimenup)
   {
     std::string fltk_label = uimenup.get___fltk_label__ ();
     if (! fltk_label.empty ())
       {
-        Fl_Menu_Item* item = const_cast<Fl_Menu_Item*> (menubar->find_item (
-                               fltk_label.c_str ()));
+        Fl_Menu_Item* item
+          = const_cast<Fl_Menu_Item*> (m_menubar->find_item (fltk_label.c_str ()));
         if (item)
           {
             Matrix rgb = uimenup.get_foregroundcolor_rgb ();
 
             uchar r = static_cast<uchar> (std::floor (rgb (0) * 255));
             uchar g = static_cast<uchar> (std::floor (rgb (1) * 255));
             uchar b = static_cast<uchar> (std::floor (rgb (2) * 255));
 
@@ -522,42 +527,42 @@ public:
     if (! fltk_label.empty ())
       {
         int itemflags = 0, idx;
         int curr_idx = find_index_by_name (fltk_label.c_str ());
 
         for (idx = curr_idx - 1; idx >= 0; idx--)
           {
             Fl_Menu_Item* item
-              = const_cast<Fl_Menu_Item*> (&menubar->menu () [idx]);
+              = const_cast<Fl_Menu_Item*> (&m_menubar->menu () [idx]);
             itemflags = item->flags;
             if (item->label ())
               break;
           }
 
-        if (idx >= 0 && idx < menubar->size ())
+        if (idx >= 0 && idx < m_menubar->size ())
           {
             if (uimenup.is_separator ())
               {
                 if (idx >= 0 && !(itemflags & FL_SUBMENU))
-                  menubar->mode (idx, itemflags | FL_MENU_DIVIDER);
+                  m_menubar->mode (idx, itemflags | FL_MENU_DIVIDER);
               }
             else
-              menubar->mode (idx, itemflags & (~FL_MENU_DIVIDER));
+              m_menubar->mode (idx, itemflags & (~FL_MENU_DIVIDER));
           }
       }
   }
 
   void update_visible (uimenu::properties& uimenup)
   {
     std::string fltk_label = uimenup.get___fltk_label__ ();
     if (! fltk_label.empty ())
       {
         Fl_Menu_Item* item
-          = const_cast<Fl_Menu_Item*> (menubar->find_item (fltk_label.c_str ()));
+          = const_cast<Fl_Menu_Item*> (m_menubar->find_item (fltk_label.c_str ()));
         if (item)
           {
             if (uimenup.is_visible ())
               item->show ();
             else
               item->hide ();
           }
       }
@@ -575,17 +580,17 @@ public:
     std::string fltk_label = uimenup.get___fltk_label__ ();
 
     if (! fltk_label.empty ())
       {
         bool item_added = false;
         do
           {
             const Fl_Menu_Item* item
-              = menubar->find_item (fltk_label.c_str ());
+              = m_menubar->find_item (fltk_label.c_str ());
 
             if (item)
               {
                 //avoid duplicate menulabels
                 size_t idx1 = fltk_label.find_last_of ("(");
                 size_t idx2 = fltk_label.find_last_of (")");
                 int len = idx2 - idx1;
                 int val = 1;
@@ -605,17 +610,17 @@ public:
               {
                 Matrix uimenu_ch = find_uimenu_children (uimenup);
                 int len = uimenu_ch.numel ();
                 int flags = 0;
                 if (len > 0)
                   flags = FL_SUBMENU;
                 if (len == 0 && uimenup.is_checked ())
                   flags += FL_MENU_TOGGLE + FL_MENU_VALUE;
-                menubar->add (fltk_label.c_str (), 0, 0, 0, flags);
+                m_menubar->add (fltk_label.c_str (), 0, 0, 0, flags);
                 item_added = true;
               }
           }
         while (! item_added);
         uimenup.set___fltk_label__ (fltk_label);
       }
   }
 
@@ -670,17 +675,17 @@ public:
   }
 
   void add_to_menu (figure::properties& figp)
   {
     std::vector<int> delayed_menus;
     Matrix kids = find_uimenu_children (figp);
     int len = kids.numel ();
     int count = 0;
-    menubar->clear ();
+    m_menubar->clear ();
     for (octave_idx_type ii = 0; ii < len; ii++)
       {
         graphics_object kgo = gh_manager::get_object (kids (len - (ii + 1)));
 
         if (kgo.valid_object ())
           {
             uimenu::properties& kprop = dynamic_cast<uimenu::properties&>
                                         (kgo.get_properties ());
@@ -730,118 +735,123 @@ public:
                                        (kgo.get_properties ());
             remove_from_menu (kprop);
           }
       }
 
     if (type == "uimenu")
       delete_entry (dynamic_cast<uimenu::properties&> (prop));
     else if (type == "figure")
-      menubar->clear ();
+      m_menubar->clear ();
   }
 
   // No copying!
 
   fltk_uimenu (const fltk_uimenu&) = delete;
 
   fltk_uimenu operator = (const fltk_uimenu&) = delete;
 
   ~fltk_uimenu (void)
   {
-    delete menubar;
+    delete m_menubar;
   }
 
 private:
 
-  Fl_Menu_Bar* menubar;
+  Fl_Menu_Bar* m_menubar;
 };
 
 #if defined (HAVE_X_WINDOWS)
 static int
 xerror_handler (Display *, XErrorEvent *)
 {
   return 0;
 }
 #endif
 
 class plot_window : public Fl_Window
 {
   friend class fltk_uimenu;
+
 public:
+
   plot_window (int xx, int yy, int ww, int hh, figure::properties& xfp,
                bool internal)
-    : Fl_Window (xx, yy, ww, hh + menu_h + status_h + 2, "octave"),
-      window_label (), fp (xfp), canvas (0),
-      autoscale (0), togglegrid (0), panzoom (0), rotate (0), help (0),
-      status (0), resize_dummy (0), ax_obj (), pos_x (0), pos_y (0)
+    : Fl_Window (xx, yy, ww, hh + m_menu_h + m_status_h + 2, "octave"),
+      m_window_label (), m_fp (xfp), m_uimenu (0), m_canvas (0),
+      m_autoscale (0), m_togglegrid (0), m_panzoom (0), m_rotate (0),
+      m_help (0), m_status (0), m_resize_dummy (0), m_ax_obj (),
+      m_pos_x (0), m_pos_y (0)
   {
     callback (window_close, static_cast<void*> (this));
 
-    // The size of the resize_dummy box also determines the minimum window size
-    resize_dummy = new Fl_Box (5 * status_h, menu_h,
-                               ww - 5 * status_h, hh);
+    // The size of the resize_dummy box also determines the minimum
+    // window size.
+    m_resize_dummy = new Fl_Box (5 * m_status_h, m_menu_h,
+                                 ww - 5 * m_status_h, hh);
+
     // See http://fltk.org/articles.php?L415+I0+T+M1000+P1
     // for how resizable works
-    resizable (resize_dummy);
+    resizable (m_resize_dummy);
 
     // FIXME: The function below is only available in FLTK >= 1.3
     // At some point support for FLTK 1.1 will be dropped in Octave.
     // At that point this function should be uncommented.
     // The current solution is to call xclass() before show() for each window.
     // Set WM_CLASS which allows window managers to properly group related
     // windows.  Otherwise, the class is just "FLTK"
     //default_xclass ("Octave");
 
-    uimenu = new fltk_uimenu (0, 0, ww, menu_h);
-    canvas = new OpenGL_fltk (0, menu_h, ww, hh, number ());
+    m_uimenu = new fltk_uimenu (0, 0, ww, m_menu_h);
+    m_canvas = new OpenGL_fltk (0, m_menu_h, ww, hh, number ());
 
     // The bottom toolbar is a composite of "autoscale", "togglegrid",
     // "panzoom", "rotate", "help", and "status".
     // Only "status" should be resized.
 
-    int toolbar_y = menu_h + hh + 1;
-    status = new Fl_Output (5 * status_h, toolbar_y,
-                            ww - 5 * status_h, status_h, "");
-
-    status->textcolor (FL_BLACK);
-    status->color (FL_GRAY);
-    status->textfont (FL_COURIER);
-    status->textsize (10);
-    status->box (FL_ENGRAVED_BOX);
-
-    autoscale = new Fl_Button (0, toolbar_y, status_h, status_h, "A");
-    autoscale->callback (button_callback, static_cast<void*> (this));
-    autoscale->tooltip ("Autoscale");
-
-    togglegrid = new Fl_Button (status_h, toolbar_y, status_h, status_h, "G");
-    togglegrid->callback (button_callback, static_cast<void*> (this));
-    togglegrid->tooltip ("Toggle Grid");
-
-    panzoom = new Fl_Button (2* status_h, toolbar_y, status_h, status_h, "P");
-    panzoom->callback (button_callback, static_cast<void*> (this));
-    panzoom->tooltip ("Mouse Pan/Zoom");
-
-    rotate = new Fl_Button (3 * status_h, toolbar_y, status_h, status_h, "R");
-    rotate->callback (button_callback, static_cast<void*> (this));
-    rotate->tooltip ("Mouse Rotate");
-
-    help = new Fl_Button (4 * status_h, toolbar_y, status_h, status_h, "?");
-    help->callback (button_callback, static_cast<void*> (this));
-    help->tooltip ("Help");
+    int toolbar_y = m_menu_h + hh + 1;
+    m_status = new Fl_Output (5 * m_status_h, toolbar_y,
+                            ww - 5 * m_status_h, m_status_h, "");
+
+    m_status->textcolor (FL_BLACK);
+    m_status->color (FL_GRAY);
+    m_status->textfont (FL_COURIER);
+    m_status->textsize (10);
+    m_status->box (FL_ENGRAVED_BOX);
+
+    m_autoscale = new Fl_Button (0, toolbar_y, m_status_h, m_status_h, "A");
+    m_autoscale->callback (button_callback, static_cast<void*> (this));
+    m_autoscale->tooltip ("Autoscale");
+
+    m_togglegrid = new Fl_Button (m_status_h, toolbar_y, m_status_h, m_status_h, "G");
+    m_togglegrid->callback (button_callback, static_cast<void*> (this));
+    m_togglegrid->tooltip ("Toggle Grid");
+
+    m_panzoom = new Fl_Button (2* m_status_h, toolbar_y, m_status_h, m_status_h, "P");
+    m_panzoom->callback (button_callback, static_cast<void*> (this));
+    m_panzoom->tooltip ("Mouse Pan/Zoom");
+
+    m_rotate = new Fl_Button (3 * m_status_h, toolbar_y, m_status_h, m_status_h, "R");
+    m_rotate->callback (button_callback, static_cast<void*> (this));
+    m_rotate->tooltip ("Mouse Rotate");
+
+    m_help = new Fl_Button (4 * m_status_h, toolbar_y, m_status_h, m_status_h, "?");
+    m_help->callback (button_callback, static_cast<void*> (this));
+    m_help->tooltip ("Help");
 
     end ();
 
     set_name ();
-    uimenu->add_to_menu (fp);
-    if (fp.menubar_is ("none") || ! uimenu->items_to_show ())
+    m_uimenu->add_to_menu (m_fp);
+    if (m_fp.menubar_is ("none") || ! m_uimenu->items_to_show ())
       hide_menubar ();
 
     update_boundingbox (internal);
 
-    if (fp.is_visible ())
+    if (m_fp.is_visible ())
       {
         // FIXME: This code should be removed when Octave drops support
         // for FLTK 1.1.  Search for default_xclass in this file to find
         // code that should be uncommented to take its place.
         //
         // Set WM_CLASS which allows window managers to properly group
         // related windows.  Otherwise, the class is just "FLTK"
         xclass ("Octave");
@@ -852,17 +862,17 @@ public:
         std::string show_gui_msgs
           = octave::sys::env::getenv ("OCTAVE_SHOW_GUI_MESSAGES");
 
         // Installing our handler suppresses the messages.
         if (show_gui_msgs.empty ())
           XSetErrorHandler (xerror_handler);
 #endif
 
-        if (fp.get_currentaxes ().ok ())
+        if (m_fp.get_currentaxes ().ok ())
           show_canvas ();
         else
           hide_canvas ();
       }
   }
 
   // No copying!
 
@@ -871,41 +881,41 @@ public:
   plot_window& operator = (const plot_window&) = delete;
 
   ~plot_window (void)
   {
     this->hide ();
     Fl::check ();
   }
 
-  double number (void) { return fp.get___myhandle__ ().value (); }
+  double number (void) { return m_fp.get___myhandle__ ().value (); }
 
   void renumber (double new_number)
   {
-    if (! canvas)
+    if (! m_canvas)
       error ("unable to renumber figure");
 
-    if (canvas->renumber (new_number))
+    if (m_canvas->renumber (new_number))
       mark_modified ();
   }
 
   void print (const std::string& cmd, const std::string& term)
   {
-    canvas->print (cmd, term);
+    m_canvas->print (cmd, term);
   }
 
   void show_menubar (void)
   {
-    uimenu->show ();
+    m_uimenu->show ();
     update_toolbar_position ();
   }
 
   void hide_menubar (void)
   {
-    uimenu->hide ();
+    m_uimenu->hide ();
     update_toolbar_position ();
   }
 
   void uimenu_update (const graphics_handle& gh, int id)
   {
     graphics_object uimenu_obj = gh_manager::get_object (gh);
 
     if (uimenu_obj.valid_object () && uimenu_obj.isa ("uimenu"))
@@ -915,157 +925,175 @@ public:
         std::string fltk_label = uimenup.get___fltk_label__ ();
         graphics_object fig = uimenu_obj.get_ancestor ("figure");
         figure::properties& figp =
           dynamic_cast<figure::properties&> (fig.get_properties ());
 
         switch (id)
           {
           case base_properties::ID_BEINGDELETED:
-            uimenu->remove_from_menu (uimenup);
+            m_uimenu->remove_from_menu (uimenup);
             break;
 
           case base_properties::ID_VISIBLE:
-            uimenu->update_visible (uimenup);
+            m_uimenu->update_visible (uimenup);
             break;
 
           case uimenu::properties::ID_ACCELERATOR:
-            uimenu->update_accelerator (uimenup);
+            m_uimenu->update_accelerator (uimenup);
             break;
 
           case uimenu::properties::ID_CALLBACK:
-            uimenu->update_callback (uimenup);
+            m_uimenu->update_callback (uimenup);
             break;
 
           case uimenu::properties::ID_CHECKED:
-            uimenu->add_to_menu (figp);//rebuilding entire menu
+            m_uimenu->add_to_menu (figp);//rebuilding entire menu
             break;
 
           case uimenu::properties::ID_ENABLE:
-            uimenu->update_enable (uimenup);
+            m_uimenu->update_enable (uimenup);
             break;
 
           case uimenu::properties::ID_FOREGROUNDCOLOR:
-            uimenu->update_foregroundcolor (uimenup);
+            m_uimenu->update_foregroundcolor (uimenup);
             break;
 
           case uimenu::properties::ID_LABEL:
-            uimenu->add_to_menu (figp);//rebuilding entire menu
+            m_uimenu->add_to_menu (figp);//rebuilding entire menu
             break;
 
           case uimenu::properties::ID_POSITION:
-            uimenu->add_to_menu (figp);//rebuilding entire menu
+            m_uimenu->add_to_menu (figp);//rebuilding entire menu
             break;
 
           case uimenu::properties::ID_SEPARATOR:
-            uimenu->update_seperator (uimenup);
+            m_uimenu->update_seperator (uimenup);
             break;
           }
 
-        if (uimenu->items_to_show ())
+        if (m_uimenu->items_to_show ())
           show_menubar ();
         else
           hide_menubar ();
       }
   }
 
   void show_canvas (void)
   {
-    if (! canvas->can_do ())
+    if (! m_canvas->can_do ())
       error ("unable to plot due to insufficient OpenGL support");
-    else if (fp.is_visible ())
+    else if (m_fp.is_visible ())
       {
-        canvas->show ();
-        canvas->make_current ();
+        m_canvas->show ();
+        m_canvas->make_current ();
       }
   }
 
   void hide_canvas (void)
   {
-    canvas->hide ();
+    m_canvas->hide ();
   }
 
   // Move the toolbar at the bottom of the plot_window.
   // The only reason for moving the toolbar is hiding and
   // showing the menubar.  All other resizing is done by fltk.
 
   void update_toolbar_position ()
   {
-    int old_canvas_h = canvas->h ();
+    int old_canvas_h = m_canvas->h ();
 
     // keep position fix, change outerposition accordingly
     update_boundingbox (true);
-    canvas->resize (0, menu_dy (), w (), old_canvas_h);
-
-    int toolbar_y = canvas->h () + menu_dy () + 1;
-    autoscale->position (0, toolbar_y);
-    togglegrid->position (status_h, toolbar_y);
-    panzoom->position (2 * status_h, toolbar_y);
-    rotate->position (3 * status_h, toolbar_y);
-    help->position (4 * status_h, toolbar_y);
-    status->resize (5 * status_h, toolbar_y,
-                    w () - 5 * status_h, status_h);
+    m_canvas->resize (0, menu_dy (), w (), old_canvas_h);
+
+    int toolbar_y = m_canvas->h () + menu_dy () + 1;
+    m_autoscale->position (0, toolbar_y);
+    m_togglegrid->position (m_status_h, toolbar_y);
+    m_panzoom->position (2 * m_status_h, toolbar_y);
+    m_rotate->position (3 * m_status_h, toolbar_y);
+    m_help->position (4 * m_status_h, toolbar_y);
+    m_status->resize (5 * m_status_h, toolbar_y,
+                    w () - 5 * m_status_h, m_status_h);
     init_sizes ();
     redraw ();
   }
 
   Matrix outerposition2position (const Matrix& outerpos)
   {
     Matrix pos = outerpos;
     pos(1) += menu_dy ();
-    pos(3) -= menu_dy () + status_h + 2;
+    pos(3) -= menu_dy () + m_status_h + 2;
     return pos;
   }
 
   Matrix position2outerposition (const Matrix& pos)
   {
     Matrix outerpos = pos;
     outerpos(1) -= menu_dy ();
-    outerpos(3) += menu_dy () + status_h + 2;
+    outerpos(3) += menu_dy () + m_status_h + 2;
     return outerpos;
   }
 
   // Called from figure::properties::ID_POSITION if internal = true
   // or ID_OUTERPOSITION if false.
   // (someone has requested a position change with set (h, "position", [...])
   // or set (h, "outerposition", [...])
 
   void update_boundingbox (bool internal)
   {
-    Matrix bb = fp.get_boundingbox (internal);
+    Matrix bb = m_fp.get_boundingbox (internal);
     if (internal)
       bb = position2outerposition (bb);
     resize (bb(0), bb(1), bb(2), bb(3));
   }
 
   void mark_modified (void)
   {
-    canvas->redraw ();
+    m_canvas->redraw ();
   }
 
   void set_name (void)
   {
-    window_label = fp.get_title ();
-    label (window_label.c_str ());
+    m_window_label = m_fp.get_title ();
+    label (m_window_label.c_str ());
   }
 
 private:
 
   // window name -- this must exists for the duration of the window's
   // life
-  std::string window_label;
+  std::string m_window_label;
 
   // Figure properties.
-  figure::properties& fp;
+  figure::properties& m_fp;
 
   // Status area height.
-  static const int status_h = 20;
+  static const int m_status_h = 20;
 
   // Menu height
-  static const int menu_h = 25;
+  static const int m_menu_h = 25;
+
+  fltk_uimenu* m_uimenu;
+
+  OpenGL_fltk* m_canvas;
+
+  Fl_Button* m_autoscale;
+  Fl_Button* m_togglegrid;
+  Fl_Button* m_panzoom;
+  Fl_Button* m_rotate;
+  Fl_Button* m_help;
+  Fl_Output* m_status;
+
+  Fl_Box* m_resize_dummy;
+
+  graphics_object m_ax_obj;
+
+  int m_pos_x;
+  int m_pos_y;
 
   // Window callback.
   static void window_close (Fl_Widget*, void* data)
   {
     octave_value_list args;
     args(0) = static_cast<plot_window*> (data)->number ();
     octave::feval ("close", args);
   }
@@ -1073,82 +1101,69 @@ private:
   // Button callbacks.
   static void button_callback (Fl_Widget* ww, void* data)
   {
     static_cast<plot_window*> (data)->button_press (ww, data);
   }
 
   void button_press (Fl_Widget* widg, void*)
   {
-    if (widg == autoscale)
+    if (widg == m_autoscale)
       axis_auto ();
-    else if (widg == togglegrid)
+    else if (widg == m_togglegrid)
       toggle_grid ();
-    else if (widg == panzoom)
-      fp.set___mouse_mode__ ("pan");
-    else if (widg == rotate)
-      fp.set___mouse_mode__ ("rotate");
-    else if (widg == help)
+    else if (widg == m_panzoom)
+      m_fp.set___mouse_mode__ ("pan");
+    else if (widg == m_rotate)
+      m_fp.set___mouse_mode__ ("rotate");
+    else if (widg == m_help)
       fl_message ("%s", help_text);
   }
 
   void set_on_ax_obj (const std::string& name, const std::string& value)
   {
     // ax_obj is the last clicked axes object
-    if (ax_obj && ax_obj.isa ("axes")
-        && ax_obj.get_properties ().get_tag () != "legend"
-        && ax_obj.get_properties ().get_tag () != "colorbar")
+    if (m_ax_obj && m_ax_obj.isa ("axes")
+        && m_ax_obj.get_properties ().get_tag () != "legend"
+        && m_ax_obj.get_properties ().get_tag () != "colorbar")
       {
         axes::properties& ap =
-          dynamic_cast<axes::properties&>(ax_obj.get_properties ());
+          dynamic_cast<axes::properties&>(m_ax_obj.get_properties ());
         ap.set (name, value);
       }
     else // no axes object clicked so far, take currentaxes
       {
-        graphics_handle gh = fp.get_currentaxes ();
+        graphics_handle gh = m_fp.get_currentaxes ();
         if (gh.ok ())
           {
             graphics_object go = gh_manager::get_object (gh);
             axes::properties& ap =
               dynamic_cast<axes::properties&>(go.get_properties ());
             ap.set (name, value);
           }
       }
   }
 
-  fltk_uimenu* uimenu;
-  OpenGL_fltk* canvas;
-  Fl_Button* autoscale;
-  Fl_Button* togglegrid;
-  Fl_Button* panzoom;
-  Fl_Button* rotate;
-  Fl_Button* help;
-  Fl_Output* status;
-  Fl_Box* resize_dummy;
-  graphics_object ax_obj;
-  int pos_x;
-  int pos_y;
-
   void axis_auto (void)
   {
     octave_value_list args;
-    if (fp.get_currentaxes ().ok ())
+    if (m_fp.get_currentaxes ().ok ())
       {
-        args(0) = fp.get_currentaxes ().as_octave_value ();
+        args(0) = m_fp.get_currentaxes ().as_octave_value ();
         args(1) = "auto";
         octave::feval ("axis", args);
         mark_modified ();
       }
   }
 
   void toggle_grid (void)
   {
     octave_value_list args;
-    if (fp.get_currentaxes ().ok ())
-      args(0) = fp.get_currentaxes ().as_octave_value ();
+    if (m_fp.get_currentaxes ().ok ())
+      args(0) = m_fp.get_currentaxes ().as_octave_value ();
 
     octave::feval ("grid", args);
     mark_modified ();
   }
 
   void pixel2pos (const graphics_handle& ax, int px, int py, double& xx,
                   double& yy) const
   {
@@ -1165,17 +1180,17 @@ private:
         ColumnVector pp = ap.pixel2coord (px, py);
         xx = pp(0);
         yy = pp(1);
       }
   }
 
   graphics_handle pixel2axes_or_ca (int px, int py)
   {
-    Matrix kids = fp.get_children ();
+    Matrix kids = m_fp.get_children ();
     int len = kids.numel ();
 
     for (int k = 0; k < len; k++)
       {
         graphics_handle hnd = gh_manager::lookup (kids(k));
 
         if (hnd.ok ())
           {
@@ -1188,17 +1203,17 @@ private:
                 if (bb(0) <= px && px < (bb(0)+bb(2))
                     && bb(1) <= py && py < (bb(1)+bb(3)))
                   {
                     return hnd;
                   }
               }
           }
       }
-    return fp.get_currentaxes ();
+    return m_fp.get_currentaxes ();
   }
 
   void pixel2status (const graphics_handle& ax, int px0, int py0,
                      int px1 = -1, int py1 = -1)
   {
     pixel2status (gh_manager::get_object (ax), px0, py0, px1, py1);
   }
 
@@ -1213,46 +1228,46 @@ private:
     pixel2pos (ax, px0, py0, x0, y0);
     cbuf << "[" << x0 << ", " << y0 << "]";
     if (px1 >= 0)
       {
         pixel2pos (ax, px1, py1, x1, y1);
         cbuf << " -> ["<< x1 << ", " << y1 << "]";
       }
 
-    status->value (cbuf.str ().c_str ());
+    m_status->value (cbuf.str ().c_str ());
   }
 
   void view2status (graphics_object ax)
   {
     if (ax && ax.isa ("axes"))
       {
         axes::properties& ap =
           dynamic_cast<axes::properties&> (ax.get_properties ());
         std::stringstream cbuf;
         cbuf.precision (4);
         cbuf.width (6);
         Matrix v (1,2,0);
         v = ap.get ("view").matrix_value ();
         cbuf << "[azimuth: " << v(0) << ", elevation: " << v(1) << "]";
 
-        status->value (cbuf.str ().c_str ());
+        m_status->value (cbuf.str ().c_str ());
       }
   }
 
   void set_currentpoint (int px, int py)
   {
-    if (! fp.is_beingdeleted ())
+    if (! m_fp.is_beingdeleted ())
       {
-        Matrix pos = fp.map_from_boundingbox (px, py);
-        fp.set_currentpoint (pos);
-        graphics_object robj = gh_manager::get_object (fp.get_parent ());
+        Matrix pos = m_fp.map_from_boundingbox (px, py);
+        m_fp.set_currentpoint (pos);
+        graphics_object robj = gh_manager::get_object (m_fp.get_parent ());
         root_figure::properties& rp =
           dynamic_cast<root_figure::properties&> (robj.get_properties ());
-        rp.set_currentfigure (fp.get___myhandle__ ().value ());
+        rp.set_currentfigure (m_fp.get___myhandle__ ().value ());
       }
   }
 
   void set_axes_currentpoint (graphics_object ax, int px, int py)
   {
     if (ax.valid_object () && ax.isa ("axes"))
       {
         axes::properties& ap =
@@ -1270,24 +1285,24 @@ private:
         // back point (furthest from the viewer)
         tmp = ap.get_transform ().untransform (px, py, x_zlim(1));
         pos(1,0) = tmp(0);
         pos(1,1) = tmp(1);
         pos(1,2) = tmp(2);
 
         ap.set_currentpoint (pos);
         if (ap.get_tag () != "legend" && ap.get_tag () != "colorbar")
-          fp.set_currentaxes (ap.get___myhandle__ ().value ());
+          m_fp.set_currentaxes (ap.get___myhandle__ ().value ());
       }
   }
 
   int menu_dy ()
   {
-    if (uimenu->is_visible ())
-      return menu_h;
+    if (m_uimenu->is_visible ())
+      return m_menu_h;
     else
       return 0;
   }
 
   octave_scalar_map format_key_event (int e_key, const char* e_text, int e_state)
   {
     octave_scalar_map evt;
 
@@ -1404,60 +1419,60 @@ private:
 
     Matrix bb (1, 4);
     bb(0) = xx;
     bb(1) = yy;
     bb(2) = ww;
     bb(3) = hh;
 
     // update outerposition
-    fp.set_boundingbox (bb, false, false);
+    m_fp.set_boundingbox (bb, false, false);
 
     // update position
-    fp.set_boundingbox (outerposition2position (bb), true, false);
+    m_fp.set_boundingbox (outerposition2position (bb), true, false);
   }
 
   bool pan_enabled (void)
   {
     // Getting pan mode property:
-    octave_value ov_pm = fp.get___pan_mode__ ();
+    octave_value ov_pm = m_fp.get___pan_mode__ ();
 
     octave_scalar_map pm = ov_pm.scalar_map_value ();
 
     return pm.contents ("Enable").string_value () == "on";
   }
 
   std::string pan_mode (void)
   {
     // Getting pan mode property:
-    octave_value ov_pm = fp.get___pan_mode__ ();
+    octave_value ov_pm = m_fp.get___pan_mode__ ();
 
     octave_scalar_map pm = ov_pm.scalar_map_value ();
 
     return pm.contents ("Motion").string_value ();
   }
 
   bool rotate_enabled (void)
   {
     // Getting rotate mode property:
-    octave_value ov_rm = fp.get___rotate_mode__ ();
+    octave_value ov_rm = m_fp.get___rotate_mode__ ();
 
     octave_scalar_map rm = ov_rm.scalar_map_value ();
 
     return rm.contents ("Enable").string_value () == "on";
   }
 
   int handle (int event)
   {
     if (event == FL_FOCUS)
       return 1;
 
     graphics_handle gh;
 
-    if (! fp.is_beingdeleted ())
+    if (! m_fp.is_beingdeleted ())
       {
         //std::cout << "plot_window::handle event = " <<  fl_eventnames[event] << std::endl;
 
         // FLTK resends keyboard events with flipped case if all
         // widgets rejects the event.
         // See Event Propagation http://www.fltk.org/doc-1.3/events.html
         static bool key_resent_detected = false;
 
@@ -1483,39 +1498,39 @@ private:
 
           case FL_KEYDOWN:
             {
               int e_key = Fl::event_key ();
               const char *e_text = Fl::event_text ();
               int e_state = Fl::event_state ();
               octave_scalar_map evt = format_key_event (e_key, e_text, e_state);
 
-              fp.set_currentcharacter (std::string (e_text));
-
-              if (! fp.get_keypressfcn ().is_empty ()
+              m_fp.set_currentcharacter (std::string (e_text));
+
+              if (! m_fp.get_keypressfcn ().is_empty ()
                   && (evt.contents ("Key").length () > 0))
                 {
                   // Update CurrentPoint before callback
-                  if (Fl::event_inside (canvas))
+                  if (Fl::event_inside (m_canvas))
                     {
-                      pos_x = Fl::event_x ();
-                      pos_y = Fl::event_y () - menu_dy ();
-
-                      set_currentpoint (pos_x, pos_y);
-
-                      gh = pixel2axes_or_ca (pos_x, pos_y);
+                      m_pos_x = Fl::event_x ();
+                      m_pos_y = Fl::event_y () - menu_dy ();
+
+                      set_currentpoint (m_pos_x, m_pos_y);
+
+                      gh = pixel2axes_or_ca (m_pos_x, m_pos_y);
 
                       if (gh.ok ())
                         {
-                          ax_obj = gh_manager::get_object (gh);
-                          set_axes_currentpoint (ax_obj, pos_x, pos_y);
+                          m_ax_obj = gh_manager::get_object (gh);
+                          set_axes_currentpoint (m_ax_obj, m_pos_x, m_pos_y);
                         }
                     }
 
-                  fp.execute_keypressfcn (evt);
+                  m_fp.execute_keypressfcn (evt);
                 }
 
               // Handle special keys used in toolbar
               switch (e_key)
                 {
                 case 'a':
                 case 'A':
                   axis_auto ();
@@ -1523,22 +1538,22 @@ private:
 
                 case 'g':
                 case 'G':
                   toggle_grid ();
                   return 1;
 
                 case 'p':
                 case 'P':
-                  fp.set___mouse_mode__ ("pan");
+                  m_fp.set___mouse_mode__ ("pan");
                   return 1;
 
                 case 'r':
                 case 'R':
-                  fp.set___mouse_mode__ ("rotate");
+                  m_fp.set___mouse_mode__ ("rotate");
                   return 1;
                 }
             }
             break;
 
           case FL_KEYUP:
             {
               int e_key = Fl::event_key ();
@@ -1559,163 +1574,163 @@ private:
                   evt = format_key_event (e_key, tmp_e_text, e_state);
                 }
               else
                 {
                   const char *e_text = Fl::event_text ();
                   evt = format_key_event (e_key, e_text, e_state);
                 }
 
-              if (! fp.get_keyreleasefcn ().is_empty ()
+              if (! m_fp.get_keyreleasefcn ().is_empty ()
                   && (evt.contents ("Key").length () > 0))
-                fp.execute_keyreleasefcn (evt);
+                m_fp.execute_keyreleasefcn (evt);
               return 1;
             }
             break;
           }
 
         // Events we only handle if they are in the canvas area.
-        if (Fl::event_inside (canvas))
+        if (Fl::event_inside (m_canvas))
           switch (event)
             {
             case FL_MOVE:
               pixel2status (pixel2axes_or_ca (Fl::event_x (),
                                               Fl::event_y () - menu_dy ()),
                             Fl::event_x (), Fl::event_y () - menu_dy ());
               return 1;
 
             case FL_PUSH:
-              pos_x = Fl::event_x ();
-              pos_y = Fl::event_y () - menu_dy ();
-
-              set_currentpoint (pos_x, pos_y);
+              m_pos_x = Fl::event_x ();
+              m_pos_y = Fl::event_y () - menu_dy ();
+
+              set_currentpoint (m_pos_x, m_pos_y);
 
               if (Fl::event_clicks ())
-                fp.set_selectiontype ("open");
+                m_fp.set_selectiontype ("open");
               else if (Fl::event_button () == FL_MIDDLE_MOUSE
                        || (Fl::event_button () == FL_LEFT_MOUSE
                            && Fl::event_shift ()))
-                fp.set_selectiontype ("extend");
+                m_fp.set_selectiontype ("extend");
               else if (Fl::event_button () == FL_RIGHT_MOUSE
                        || (Fl::event_button () == FL_LEFT_MOUSE
                            && Fl::event_ctrl ()))
-                fp.set_selectiontype ("alt");
+                m_fp.set_selectiontype ("alt");
               else
-                fp.set_selectiontype ("normal");
-
-              gh = pixel2axes_or_ca (pos_x, pos_y);
+                m_fp.set_selectiontype ("normal");
+
+              gh = pixel2axes_or_ca (m_pos_x, m_pos_y);
 
               if (gh.ok ())
                 {
-                  ax_obj = gh_manager::get_object (gh);
-                  set_axes_currentpoint (ax_obj, pos_x, pos_y);
+                  m_ax_obj = gh_manager::get_object (gh);
+                  set_axes_currentpoint (m_ax_obj, m_pos_x, m_pos_y);
                 }
 
               // Ensure windowbuttondownfcn is called after currentpoint
               // is updated but before calling buttondownfcn.
-              if (! fp.get_windowbuttondownfcn ().is_empty ())
-                fp.execute_windowbuttondownfcn (Fl::event_button ());
+              if (! m_fp.get_windowbuttondownfcn ().is_empty ())
+                m_fp.execute_windowbuttondownfcn (Fl::event_button ());
 
               if (gh.ok ())
                 {
-                  int ndim = calc_dimensions (ax_obj);
+                  int ndim = calc_dimensions (m_ax_obj);
 
                   if (ndim == 3)
-                    rotate->activate ();
+                    m_rotate->activate ();
                   else // ndim == 2
-                    rotate->deactivate ();
-
-                  fp.set_currentobject (ax_obj.get_handle ().value ());
-
-                  base_properties& props = ax_obj.get_properties ();
+                    m_rotate->deactivate ();
+
+                  m_fp.set_currentobject (m_ax_obj.get_handle ().value ());
+
+                  base_properties& props = m_ax_obj.get_properties ();
                   if (! props.get_buttondownfcn ().is_empty ())
                     props.execute_buttondownfcn (Fl::event_button ());
 
                   return 1;
                 }
-              else if (! fp.get_buttondownfcn ().is_empty ())
-                fp.execute_buttondownfcn (Fl::event_button ());
+              else if (! m_fp.get_buttondownfcn ().is_empty ())
+                m_fp.execute_buttondownfcn (Fl::event_button ());
 
               break;
 
             case FL_DRAG:
-              if (! fp.get_windowbuttonmotionfcn ().is_empty ())
+              if (! m_fp.get_windowbuttonmotionfcn ().is_empty ())
                 {
                   set_currentpoint (Fl::event_x (), Fl::event_y () - menu_dy ());
-                  fp.execute_windowbuttonmotionfcn ();
+                  m_fp.execute_windowbuttonmotionfcn ();
                 }
 
               if (Fl::event_button () == 1)
                 {
-                  if (ax_obj && ax_obj.isa ("axes"))
+                  if (m_ax_obj && m_ax_obj.isa ("axes"))
                     {
                       axes::properties& ap =
                         dynamic_cast<axes::properties&>
-                        (ax_obj.get_properties ());
+                        (m_ax_obj.get_properties ());
 
                       // Don't pan or rotate legend
                       if (ap.get_tag () != "legend")
                         {
                           if (rotate_enabled ())
-                            view2status (ax_obj);
+                            view2status (m_ax_obj);
                           else
-                            pixel2status (ax_obj, pos_x, pos_y,
+                            pixel2status (m_ax_obj, m_pos_x, m_pos_y,
                                           Fl::event_x (),
                                           Fl::event_y () - menu_dy ());
 
                           double x0, y0, x1, y1;
-                          Matrix pos = fp.get_boundingbox (true);
-                          pixel2pos (ax_obj, pos_x, pos_y, x0, y0);
-                          pixel2pos (ax_obj, Fl::event_x (),
+                          Matrix pos = m_fp.get_boundingbox (true);
+                          pixel2pos (m_ax_obj, m_pos_x, m_pos_y, x0, y0);
+                          pixel2pos (m_ax_obj, Fl::event_x (),
                                      Fl::event_y () - menu_dy (),
                                      x1, y1);
 
                           if (pan_enabled ())
                             {
                               std::string mode = pan_mode ();
 
                               ap.translate_view (mode, x0, x1, y0, y1);
                             }
                           else if (rotate_enabled ())
                             {
                               double daz, del;
-                              daz = (Fl::event_x () - pos_x) / pos(2) * 360;
-                              del = (Fl::event_y () - menu_dy () - pos_y)
+                              daz = (Fl::event_x () - m_pos_x) / pos(2) * 360;
+                              del = (Fl::event_y () - menu_dy () - m_pos_y)
                                     / pos(3) * 360;
                               ap.rotate_view (del, daz);
                             }
                         }
                       else
                         {
                           // move the position of the legend
                           Matrix pos = ap.get_position ().matrix_value ();
-                          pos(0) += double (Fl::event_x () - pos_x)
-                                    / canvas->w ();
-                          pos(1) -= double (Fl::event_y () - menu_dy () - pos_y)
-                                    / canvas->h ();
+                          pos(0) += double (Fl::event_x () - m_pos_x)
+                                    / m_canvas->w ();
+                          pos(1) -= double (Fl::event_y () - menu_dy () - m_pos_y)
+                                    / m_canvas->h ();
                           ap.set_position (pos);
                         }
 
-                      pos_x = Fl::event_x ();
-                      pos_y = Fl::event_y () - menu_dy ();
+                      m_pos_x = Fl::event_x ();
+                      m_pos_y = Fl::event_y () - menu_dy ();
                       mark_modified ();
                     }
                   return 1;
                 }
               else if (Fl::event_button () == 3)
                 {
-                  pixel2status (ax_obj, pos_x, pos_y,
+                  pixel2status (m_ax_obj, m_pos_x, m_pos_y,
                                 Fl::event_x (), Fl::event_y () - menu_dy ());
                   Matrix zoom_box (1,4,0);
-                  zoom_box (0) = pos_x;
-                  zoom_box (1) = pos_y;
-                  zoom_box (2) = Fl::event_x ();
-                  zoom_box (3) = Fl::event_y () - menu_dy ();
-                  canvas->set_zoom_box (zoom_box);
-                  canvas->zoom (true);
+                  zoom_box(0) = m_pos_x;
+                  zoom_box(1) = m_pos_y;
+                  zoom_box(2) = Fl::event_x ();
+                  zoom_box(3) = Fl::event_y () - menu_dy ();
+                  m_canvas->set_zoom_box (zoom_box);
+                  m_canvas->zoom (true);
                   mark_modified ();
                   return 1;
                 }
 
               break;
 
             case FL_MOUSEWHEEL:
               {
@@ -1745,50 +1760,50 @@ private:
 
                     ap.zoom_about_point ("both", x1, y1, factor, false);
                     mark_modified ();
                     return 1;
                   }
               }
 
             case FL_RELEASE:
-              if (! fp.get_windowbuttonupfcn ().is_empty ())
+              if (! m_fp.get_windowbuttonupfcn ().is_empty ())
                 {
                   set_currentpoint (Fl::event_x (), Fl::event_y () - menu_dy ());
-                  fp.execute_windowbuttonupfcn ();
+                  m_fp.execute_windowbuttonupfcn ();
                 }
 
               if ((Fl::event_button () == 1) && Fl::event_clicks ())
                 {
                   // Double click
                   set_on_ax_obj ("xlimmode", "auto");
                   set_on_ax_obj ("ylimmode", "auto");
                   set_on_ax_obj ("zlimmode", "auto");
                   mark_modified ();
                   return 1;
                 }
               if (Fl::event_button () == 3)
                 {
                   // End of drag -- zoom.
-                  if (canvas->zoom ())
+                  if (m_canvas->zoom ())
                     {
-                      canvas->zoom (false);
+                      m_canvas->zoom (false);
                       double x0,y0,x1,y1;
-                      if (ax_obj && ax_obj.isa ("axes"))
+                      if (m_ax_obj && m_ax_obj.isa ("axes"))
                         {
                           axes::properties& ap = dynamic_cast<axes::properties&>
-                                                 (ax_obj.get_properties ());
-                          pixel2pos (ax_obj, pos_x, pos_y, x0, y0);
+                                                 (m_ax_obj.get_properties ());
+                          pixel2pos (m_ax_obj, m_pos_x, m_pos_y, x0, y0);
                           int pos_x1 = Fl::event_x ();
                           int pos_y1 = Fl::event_y () - menu_dy ();
-                          pixel2pos (ax_obj, pos_x1, pos_y1, x1, y1);
+                          pixel2pos (m_ax_obj, pos_x1, pos_y1, x1, y1);
                           Matrix xl (1,2,0);
                           Matrix yl (1,2,0);
-                          int dx = abs (pos_x - pos_x1);
-                          int dy = abs (pos_y - pos_y1);
+                          int dx = abs (m_pos_x - pos_x1);
+                          int dy = abs (m_pos_y - pos_y1);
                           // Smallest zoom box must be 4 pixels square
                           if ((dx > 4) && (dy > 4))
                             {
                               if (x0 < x1)
                                 {
                                   xl(0) = x0;
                                   xl(1) = x1;
                                 }
@@ -2193,16 +2208,17 @@ figure_manager *figure_manager::instance
 std::string figure_manager::fltk_idx_header="fltk index=";
 int figure_manager::curr_index = 1;
 
 static bool toolkit_loaded = false;
 
 class fltk_graphics_toolkit : public base_graphics_toolkit
 {
 public:
+
   fltk_graphics_toolkit (void)
     : base_graphics_toolkit (FLTK_GRAPHICS_TOOLKIT_NAME),
       input_event_hook_fcn_id ()
   {
     Fl::visual (FL_RGB);
   }
 
   ~fltk_graphics_toolkit (void) = default;
