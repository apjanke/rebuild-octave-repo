# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1448483268 18000
#      Wed Nov 25 15:27:48 2015 -0500
# Node ID 200ae1d650b7a4a9dc21582cfd6ab07bbac6c79a
# Parent  46b15c018fa516d934e5ac7421648182c199fabc
propagate octave_execution_exception objects through try/catch blocks

* gripes.h, gripes.cc (gripe_user_supplied_eval,
gripe_wrong_type_arg): New overloaded functions that accept
octave_execution_exception objects.

* error.h, error.cc (error, verror, error_1, usage_1,
debug_or_throw_exception): New overloaded functions that accept
* octave_execution_exception objects.

* __qp__.cc, cellfun.cc, daspk.cc, dasrt.cc, dassl.cc, data.cc,
file-io.cc, graphics.cc, graphics.in.h, input.cc, load-path.cc,
ls-mat-ascii.cc, lsode.cc, mex.cc, oct-handle.h, oct-map.cc,
oct-stream.cc, quad.cc, rand.cc, toplev.cc, utils.cc, variables.cc,
__eigs__.cc, ov-base.cc, ov-class.cc, ov-fcn-handle.cc,
ov-oncleanup.cc, ov.cc, octave.cc, oct-parse.in.yy: Propagate
octave_execution_exception objects through try/catch blocks.

diff --git a/libinterp/corefcn/__qp__.cc b/libinterp/corefcn/__qp__.cc
--- a/libinterp/corefcn/__qp__.cc
+++ b/libinterp/corefcn/__qp__.cc
@@ -137,19 +137,19 @@ qp (const Matrix& H, const ColumnVector&
   // Computing the ???
 
   EIG eigH;
 
   try
     {
       eigH = EIG (H);
     }
-  catch (const octave_execution_exception&)
+  catch (const octave_execution_exception& e)
     {
-      error ("qp: failed to compute eigenvalues of H");
+      error (e, "qp: failed to compute eigenvalues of H");
     }
 
   ColumnVector eigenvalH = real (eigH.eigenvalues ());
   Matrix eigenvecH = real (eigH.eigenvectors ());
   double minReal = eigenvalH.min ();
   octave_idx_type indminR = 0;
   for (octave_idx_type i = 0; i < n; i++)
     {
@@ -285,19 +285,19 @@ qp (const Matrix& H, const ColumnVector&
               // Searching for the most negative curvature.
 
               EIG eigrH;
 
               try
                 {
                   eigrH = EIG (rH);
                 }
-              catch (const octave_execution_exception&)
+              catch (const octave_execution_exception& e)
                 {
-                  error ("qp: failed to compute eigenvalues of rH");
+                  error (e, "qp: failed to compute eigenvalues of rH");
                 }
 
               ColumnVector eigenvalrH = real (eigrH.eigenvalues ());
               Matrix eigenvecrH = real (eigrH.eigenvectors ());
               double mRrH = eigenvalrH.min ();
               indminR = 0;
               for (octave_idx_type i = 0; i < n; i++)
                 {
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -36,35 +36,36 @@ along with Octave; see the file COPYING.
 #include "lo-mappers.h"
 #include "oct-locbuf.h"
 
 #include "Cell.h"
 #include "oct-map.h"
 #include "defun.h"
 #include "parse.h"
 #include "variables.h"
-#include "ov-colon.h"
 #include "unwind-prot.h"
 #include "gripes.h"
+#include "toplev.h"
 #include "utils.h"
 
+#include "ov-bool.h"
 #include "ov-class.h"
-#include "ov-scalar.h"
-#include "ov-float.h"
+#include "ov-colon.h"
 #include "ov-complex.h"
+#include "ov-float.h"
 #include "ov-flt-complex.h"
-#include "ov-bool.h"
-#include "ov-int8.h"
 #include "ov-int16.h"
 #include "ov-int32.h"
 #include "ov-int64.h"
-#include "ov-uint8.h"
+#include "ov-int8.h"
+#include "ov-scalar.h"
 #include "ov-uint16.h"
 #include "ov-uint32.h"
 #include "ov-uint64.h"
+#include "ov-uint8.h"
 
 #include "ov-fcn-handle.h"
 
 static octave_value_list
 get_output_list (octave_idx_type count, octave_idx_type nargout,
                  const octave_value_list& inputlist,
                  octave_value& func,
                  octave_value& error_handler)
@@ -72,22 +73,26 @@ get_output_list (octave_idx_type count, 
   octave_value_list tmp;
 
   bool execution_error = false;
 
   try
     {
       tmp = func.do_multi_index_op (nargout, inputlist);
     }
-  catch (const octave_execution_exception&)
+  catch (const octave_execution_exception& e)
     {
       if (error_handler.is_defined ())
-        execution_error = true;
+        {
+          recover_from_exception ();
+
+          execution_error = true;
+        }
       else
-        octave_throw_execution_exception ();
+        throw e;
     }
 
   if (execution_error)
     {
       if (error_handler.is_defined ())
         {
           octave_scalar_map msg;
           msg.assign ("identifier", last_error_id ());
diff --git a/libinterp/corefcn/daspk.cc b/libinterp/corefcn/daspk.cc
--- a/libinterp/corefcn/daspk.cc
+++ b/libinterp/corefcn/daspk.cc
@@ -74,20 +74,19 @@ daspk_user_function (const ColumnVector&
   if (daspk_fcn)
     {
       octave_value_list tmp;
 
       try
         {
           tmp = daspk_fcn->do_multi_index_op (1, args);
         }
-      catch (const octave_execution_exception&)
+      catch (const octave_execution_exception& e)
         {
-          gripe_user_supplied_eval ("daspk");
-          throw;
+          gripe_user_supplied_eval (e, "daspk");
         }
 
       int tlen = tmp.length ();
       if (tlen > 0 && tmp(0).is_defined ())
         {
           if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
             {
               warning ("daspk: ignoring imaginary part returned from user-supplied function");
@@ -127,20 +126,19 @@ daspk_user_jacobian (const ColumnVector&
   if (daspk_jac)
     {
       octave_value_list tmp;
 
       try
         {
           tmp = daspk_jac->do_multi_index_op (1, args);
         }
-      catch (const octave_execution_exception&)
+      catch (const octave_execution_exception& e)
         {
-          gripe_user_supplied_eval ("daspk");
-          throw;
+          gripe_user_supplied_eval (e, "daspk");
         }
 
       int tlen = tmp.length ();
       if (tlen > 0 && tmp(0).is_defined ())
         {
           if (! warned_jac_imaginary && tmp(0).is_complex_type ())
             {
               warning ("daspk: ignoring imaginary part returned from user-supplied jacobian function");
diff --git a/libinterp/corefcn/dasrt.cc b/libinterp/corefcn/dasrt.cc
--- a/libinterp/corefcn/dasrt.cc
+++ b/libinterp/corefcn/dasrt.cc
@@ -74,20 +74,19 @@ dasrt_user_f (const ColumnVector& x, con
   if (dasrt_f)
     {
       octave_value_list tmp;
 
       try
         {
           tmp = dasrt_f->do_multi_index_op (1, args);
         }
-      catch (const octave_execution_exception&)
+      catch (const octave_execution_exception& e)
         {
-          gripe_user_supplied_eval ("dasrt");
-          throw;
+          gripe_user_supplied_eval (e, "dasrt");
         }
 
       if (tmp.length () > 0 && tmp(0).is_defined ())
         {
           if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
             {
               warning ("dasrt: ignoring imaginary part returned from user-supplied function");
               warned_fcn_imaginary = true;
@@ -118,20 +117,19 @@ dasrt_user_cf (const ColumnVector& x, do
   if (dasrt_cf)
     {
       octave_value_list tmp;
 
       try
         {
           tmp = dasrt_cf->do_multi_index_op (1, args);
         }
-      catch (const octave_execution_exception&)
+      catch (const octave_execution_exception& e)
         {
-          gripe_user_supplied_eval ("dasrt");
-          throw;
+          gripe_user_supplied_eval (e, "dasrt");
         }
 
       if (tmp.length () > 0 && tmp(0).is_defined ())
         {
           if (! warned_cf_imaginary && tmp(0).is_complex_type ())
             {
               warning ("dasrt: ignoring imaginary part returned from user-supplied constraint function");
               warned_cf_imaginary = true;
@@ -167,20 +165,19 @@ dasrt_user_j (const ColumnVector& x, con
   if (dasrt_j)
     {
       octave_value_list tmp;
 
       try
         {
           tmp = dasrt_j->do_multi_index_op (1, args);
         }
-      catch (const octave_execution_exception&)
+      catch (const octave_execution_exception& e)
         {
-          gripe_user_supplied_eval ("dasrt");
-          throw;
+          gripe_user_supplied_eval (e, "dasrt");
         }
 
       int tlen = tmp.length ();
       if (tlen > 0 && tmp(0).is_defined ())
         {
           if (! warned_jac_imaginary && tmp(0).is_complex_type ())
             {
               warning ("dasrt: ignoring imaginary part returned from user-supplied jacobian function");
diff --git a/libinterp/corefcn/dassl.cc b/libinterp/corefcn/dassl.cc
--- a/libinterp/corefcn/dassl.cc
+++ b/libinterp/corefcn/dassl.cc
@@ -74,20 +74,19 @@ dassl_user_function (const ColumnVector&
   if (dassl_fcn)
     {
       octave_value_list tmp;
 
       try
         {
           tmp = dassl_fcn->do_multi_index_op (1, args);
         }
-      catch (const octave_execution_exception&)
+      catch (const octave_execution_exception& e)
         {
-          gripe_user_supplied_eval ("dassl");
-          throw;
+          gripe_user_supplied_eval (e, "dassl");
         }
 
       int tlen = tmp.length ();
       if (tlen > 0 && tmp(0).is_defined ())
         {
           if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
             {
               warning ("dassl: ignoring imaginary part returned from user-supplied function");
@@ -127,20 +126,19 @@ dassl_user_jacobian (const ColumnVector&
   if (dassl_jac)
     {
       octave_value_list tmp;
 
       try
         {
           tmp = dassl_jac->do_multi_index_op (1, args);
         }
-      catch (const octave_execution_exception&)
+      catch (const octave_execution_exception& e)
         {
-          gripe_user_supplied_eval ("dassl");
-          throw;
+          gripe_user_supplied_eval (e, "dassl");
         }
 
       int tlen = tmp.length ();
       if (tlen > 0 && tmp(0).is_defined ())
         {
           if (! warned_jac_imaginary && tmp(0).is_complex_type ())
             {
               warning ("dassl: ignoring imaginary part returned from user-supplied jacobian function");
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -1805,19 +1805,19 @@ attempt_type_conversion (const octave_va
   if (fcn.is_defined ())
     {
       octave_value_list result;
 
       try
         {
           result = fcn.do_multi_index_op (1, octave_value_list (1, ov));
         }
-      catch (const octave_execution_exception&)
+      catch (const octave_execution_exception& e)
         {
-          error ("conversion from %s to %s failed", dtype.c_str (),
+          error (e, "conversion from %s to %s failed", dtype.c_str (),
                  cname.c_str ());
         }
 
       if (result.length () > 0)
         retval = result(0);
       else
         error ("conversion from %s to %s failed", dtype.c_str (),
                cname.c_str ());
@@ -1832,19 +1832,19 @@ attempt_type_conversion (const octave_va
       if (fcn.is_defined ())
         {
           octave_value_list result;
 
           try
             {
               result = fcn.do_multi_index_op (1, octave_value_list (1, ov));
             }
-          catch (const octave_execution_exception&)
+          catch (const octave_execution_exception& e)
             {
-              error ("%s constructor failed for %s argument", dtype.c_str (),
+              error (e, "%s constructor failed for %s argument", dtype.c_str (),
                      cname.c_str ());
             }
 
           if (result.length () > 0)
             retval = result(0);
           else
             error ("%s constructor failed for %s argument", dtype.c_str (),
                    cname.c_str ());
@@ -1872,19 +1872,19 @@ do_class_concat (const octave_value_list
       // Have method for dominant type.  Call it and let it handle conversions.
 
       octave_value_list tmp2;
 
       try
         {
           tmp2 = fcn.do_multi_index_op (1, ovl);
         }
-      catch (const octave_execution_exception&)
+      catch (const octave_execution_exception& e)
         {
-          error ("%s/%s method failed", dtype.c_str (), cattype.c_str ());
+          error (e, "%s/%s method failed", dtype.c_str (), cattype.c_str ());
         }
 
       if (tmp2.length () > 0)
         retval = tmp2(0);
       else
         error ("%s/%s method did not return a value", dtype.c_str (),
                cattype.c_str ());
     }
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -278,17 +278,18 @@ pr_where (std::ostream& os, const char *
       int column = elt.column ();
 
       pr_where_1 (os, "    %s at line %d column %d\n",
                   fcn_name.c_str (), line, column);
     }
 }
 
 static void
-debug_or_throw_exception (bool show_stack_trace = false)
+debug_or_throw_exception (const octave_execution_exception& e,
+                          bool show_stack_trace = false)
 {
   if ((interactive || forced_interactive)
       && Vdebug_on_error && octave_call_stack::caller_user_code ())
     {
       unwind_protect frame;
       frame.protect_var (Vdebug_on_error);
       Vdebug_on_error = false;
 
@@ -297,31 +298,33 @@ debug_or_throw_exception (bool show_stac
       tree_evaluator::current_frame = octave_call_stack::current_frame ();
 
       if (show_stack_trace)
         pr_where (std::cerr, "error");
 
       do_keyboard (octave_value_list ());
     }
   else
-    {
-      octave_execution_exception e;
+    throw e;
+}
+
+static void
+debug_or_throw_exception (bool show_stack_trace = false)
+{
+  octave_execution_exception e;
 
-      if (show_stack_trace
-          && octave_exception_state != octave_exec_exception)
-        {
-          std::ostringstream buf;
-          pr_where (buf, "error");
-          e.set_stack_trace (buf.str ());
-        }
+  if (show_stack_trace && octave_exception_state != octave_exec_exception)
+    {
+      std::ostringstream buf;
+      pr_where (buf, "error");
 
-      octave_exception_state = octave_exec_exception;
+      e.set_stack_trace (buf.str ());
+    }
 
-      throw e;
-    }
+  debug_or_throw_exception (e, show_stack_trace);
 }
 
 // Warning messages are never buffered.
 
 static void
 vwarning (const char *name, const char *id, const char *fmt, va_list args)
 {
   if (discard_warning_messages)
@@ -382,17 +385,26 @@ void
 message_with_id (const char *name, const char *id, const char *fmt, ...)
 {
   va_list args;
   va_start (args, fmt);
   vmessage_with_id (name, id, fmt, args);
   va_end (args);
 }
 
-void
+static void
+usage_1 (const octave_execution_exception& e, const char *id,
+         const char *fmt, va_list args)
+{
+  verror (true, std::cerr, "usage", id, fmt, args);
+
+  debug_or_throw_exception (e);
+}
+
+static void
 usage_1 (const char *id, const char *fmt, va_list args)
 {
   verror (true, std::cerr, "usage", id, fmt, args);
 
   debug_or_throw_exception ();
 }
 
 void
@@ -421,18 +433,19 @@ usage_with_id (const char *id, const cha
 {
   va_list args;
   va_start (args, fmt);
   vusage_with_id (id, fmt, args);
   va_end (args);
 }
 
 static void
-error_1 (std::ostream& os, const char *name, const char *id,
-         const char *fmt, va_list args, bool with_cfn = false)
+error_1 (const octave_execution_exception& e, std::ostream& os,
+         const char *name, const char *id, const char *fmt,
+         va_list args, bool with_cfn = false)
 {
   bool show_stack_trace = false;
 
   if (fmt)
     {
       if (*fmt)
         {
           size_t len = strlen (fmt);
@@ -459,17 +472,26 @@ error_1 (std::ostream& os, const char *n
                     show_stack_trace = true;
                 }
             }
         }
     }
   else
     panic ("error_1: invalid format");
 
-  debug_or_throw_exception (show_stack_trace);
+  debug_or_throw_exception (e, show_stack_trace);
+}
+
+static void
+error_1 (std::ostream& os, const char *name, const char *id,
+         const char *fmt, va_list args, bool with_cfn = false)
+{
+  octave_execution_exception e;
+
+  error_1 (e, os, name, id, fmt, args, with_cfn);
 }
 
 void
 verror (const char *fmt, va_list args)
 {
   error_1 (std::cerr, "error", "", fmt, args);
 }
 
@@ -478,16 +500,31 @@ error (const char *fmt, ...)
 {
   va_list args;
   va_start (args, fmt);
   verror (fmt, args);
   va_end (args);
 }
 
 void
+verror (const octave_execution_exception& e, const char *fmt, va_list args)
+{
+  error_1 (e, std::cerr, "error", "", fmt, args);
+}
+
+void
+error (const octave_execution_exception& e, const char *fmt, ...)
+{
+  va_list args;
+  va_start (args, fmt);
+  verror (e, fmt, args);
+  va_end (args);
+}
+
+void
 verror_with_cfn (const char *fmt, va_list args)
 {
   error_1 (std::cerr, "error", "", fmt, args, true);
 }
 
 void
 error_with_cfn (const char *fmt, ...)
 {
diff --git a/libinterp/corefcn/error.h b/libinterp/corefcn/error.h
--- a/libinterp/corefcn/error.h
+++ b/libinterp/corefcn/error.h
@@ -24,16 +24,17 @@ along with Octave; see the file COPYING.
 #define octave_error_h 1
 
 #include <cstdarg>
 #include <string>
 
 class octave_map;
 class octave_value_list;
 class unwind_protect;
+class octave_execution_exception;
 
 #define panic_impossible() \
   panic ("impossible state reached in file '%s' at line %d", __FILE__, __LINE__)
 
 extern OCTINTERP_API void reset_error_handler (void);
 
 extern OCTINTERP_API int warning_enabled (const std::string& id);
 
@@ -46,16 +47,21 @@ extern OCTINTERP_API void vusage (const 
 extern OCTINTERP_API void usage (const char *fmt, ...);
 
 extern OCTINTERP_API void vwarning (const char *fmt, va_list args);
 extern OCTINTERP_API void warning (const char *fmt, ...);
 
 extern OCTINTERP_API void verror (const char *fmt, va_list args);
 extern OCTINTERP_API void error (const char *fmt, ...);
 
+extern OCTINTERP_API void verror (const octave_execution_exception&,
+                                  const char *fmt, va_list args);
+extern OCTINTERP_API void error (const octave_execution_exception&,
+                                 const char *fmt, ...);
+
 extern OCTINTERP_API void verror_with_cfn (const char *fmt, va_list args);
 extern OCTINTERP_API void error_with_cfn (const char *fmt, ...);
 
 extern OCTINTERP_API void vparse_error (const char *fmt, va_list args);
 extern OCTINTERP_API void parse_error (const char *fmt, ...);
 
 extern OCTINTERP_API void
 vmessage_with_id (const char *id, const char *name,
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -1327,30 +1327,30 @@ do_fread (octave_stream& os, const octav
   oct_data_conv::data_type input_type;
   oct_data_conv::data_type output_type;
 
   try
     {
       oct_data_conv::string_to_data_type (prec, block_size,
                                           input_type, output_type);
     }
-  catch (const octave_execution_exception&)
+  catch (const octave_execution_exception& e)
     {
-      error ("fread: invalid PRECISION specified");
+      error (e, "fread: invalid PRECISION specified");
     }
 
   int skip = 0;
 
   try
     {
       skip = skip_arg.int_value (true);
     }
-  catch (const octave_execution_exception&)
+  catch (const octave_execution_exception& e)
     {
-      error ("fread: SKIP must be an integer");
+      error (e, "fread: SKIP must be an integer");
     }
 
   std::string arch = arch_arg.xstring_value ("fread: ARCH architecture type must be a string");
 
   oct_mach_info::float_format flt_fmt
     = oct_mach_info::string_to_float_format (arch);
 
   return os.read (size, block_size, input_type, output_type, skip,
@@ -1585,30 +1585,30 @@ do_fwrite (octave_stream& os, const octa
 
   int block_size = 1;
   oct_data_conv::data_type output_type;
 
   try
     {
       oct_data_conv::string_to_data_type (prec, block_size, output_type);
     }
-  catch (const octave_execution_exception&)
+  catch (const octave_execution_exception& e)
     {
-      error ("fwrite: invalid PRECISION specified");
+      error (e, "fwrite: invalid PRECISION specified");
     }
 
   int skip = 0;
 
   try
     {
       skip = skip_arg.int_value (true);
     }
-  catch (const octave_execution_exception&)
+  catch (const octave_execution_exception& e)
     {
-      error ("fwrite: SKIP must be an integer");
+      error (e, "fwrite: SKIP must be an integer");
     }
 
   std::string arch = arch_arg.xstring_value ("fwrite: ARCH architecture type must be a string");
 
   oct_mach_info::float_format flt_fmt
     = oct_mach_info::string_to_float_format (arch);
 
   return os.write (data, block_size, output_type, skip, flt_fmt);
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1259,19 +1259,19 @@ color_property::do_set (const octave_val
 
                   if (current_type != color_t || col != color_val)
                     {
                       color_val = col;
                       current_type = color_t;
                       return true;
                     }
                 }
-              catch (const octave_execution_exception&)
+              catch (const octave_execution_exception& e)
                 {
-                  error ("invalid value for color property \"%s\" (value = %s)",
+                  error (e, "invalid value for color property \"%s\" (value = %s)",
                          get_name ().c_str (), s.c_str ());
                 }
             }
         }
       else
         error ("invalid value for color property \"%s\"",
                get_name ().c_str ());
     }
@@ -2858,19 +2858,19 @@ base_properties::set_from_list (base_gra
            q++)
         {
           std::string pname = q->first;
 
           try
             {
               bgo.set (pname, q->second);
             }
-          catch (const octave_execution_exception&)
-            {
-              error ("error setting default property %s", pname.c_str ());
+          catch (const octave_execution_exception& e)
+            {
+              error (e, "error setting default property %s", pname.c_str ());
             }
         }
     }
 }
 
 /*
 ## test defaults are set in the order they were stored
 %!test
@@ -10186,19 +10186,19 @@ make_graphics_object (const std::string&
       graphics_handle h;
 
       try
         {
           h = gh_manager::make_graphics_handle (go_name, parent,
                                                 integer_figure_handle,
                                                 false, false);
         }
-      catch (const octave_execution_exception&)
-        {
-          error ("__go%s__: unable to create graphics handle",
+      catch (const octave_execution_exception& e)
+        {
+          error (e, "__go%s__: unable to create graphics handle",
                  go_name.c_str ());
         }
 
       adopt (parent, h);
 
       xset (h, xargs);
       xcreatefcn (h);
       xinitialize (h);
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -801,19 +801,19 @@ protected:
     else
       {
         NDArray nda;
 
         try
           {
             nda = val.array_value ();
           }
-        catch (const octave_execution_exception&)
+        catch (const octave_execution_exception& e)
           {
-            error ("set: invalid string property value for \"%s\"",
+            error (e, "set: invalid string property value for \"%s\"",
                    get_name ().c_str ());
           }
 
         octave_idx_type nel = nda.numel ();
 
         value.resize (nel);
 
         for (octave_idx_type i = 0; i < nel; i++)
@@ -1695,19 +1695,19 @@ protected:
   bool do_set (const octave_value& val)
   {
     Matrix new_kids;
 
     try
       {
         new_kids = val.matrix_value ();
       }
-    catch (const octave_execution_exception&)
+    catch (const octave_execution_exception& e)
       {
-        error ("set: children must be an array of graphics handles");
+        error (e, "set: children must be an array of graphics handles");
       }
 
     octave_idx_type nel = new_kids.numel ();
 
     const Matrix new_kids_column = new_kids.reshape (dim_vector (nel, 1));
 
     bool is_ok = true;
     bool add_hidden = true;
diff --git a/libinterp/corefcn/gripes.cc b/libinterp/corefcn/gripes.cc
--- a/libinterp/corefcn/gripes.cc
+++ b/libinterp/corefcn/gripes.cc
@@ -81,17 +81,26 @@ void
 gripe_square_matrix_required (const char *name)
 {
   error ("%s: argument must be a square matrix", name);
 }
 
 void
 gripe_user_supplied_eval (const char *name)
 {
-  error ("%s: evaluation of user-supplied function failed", name);
+  octave_execution_exception e;
+
+  gripe_user_supplied_eval (e, name);
+}
+
+void
+gripe_user_supplied_eval (const octave_execution_exception& e,
+                          const char *name)
+{
+  error (e, "%s: evaluation of user-supplied function failed", name);
 }
 
 void
 gripe_user_returned_invalid (const char *name)
 {
   error ("%s: user-supplied function returned invalid value", name);
 }
 
@@ -129,65 +138,130 @@ void
 gripe_data_conversion (const char *from, const char *to)
 {
   error ("unable to convert from %s to %s format", from, to);
 }
 
 void
 gripe_wrong_type_arg (const char *name, const char *s, bool is_error)
 {
+  octave_execution_exception e;
+
+  gripe_wrong_type_arg (e, name, s, is_error);
+}
+
+void
+gripe_wrong_type_arg (const octave_execution_exception& e,
+                      const char *name, const char *s, bool is_error)
+{
   if (is_error)
-    error ("%s: wrong type argument '%s'", name, s);
+    error (e, "%s: wrong type argument '%s'", name, s);
   else
     warning ("%s: wrong type argument '%s'", name, s);
 }
 
 void
 gripe_wrong_type_arg (const char *name, const std::string& s, bool is_error)
 {
-  gripe_wrong_type_arg (name, s.c_str (), is_error);
+  octave_execution_exception e;
+
+  gripe_wrong_type_arg (e, name, s.c_str (), is_error);
+}
+
+void
+gripe_wrong_type_arg (const octave_execution_exception& e,
+                      const char *name, const std::string& s, bool is_error)
+{
+  gripe_wrong_type_arg (e, name, s.c_str (), is_error);
 }
 
 void
 gripe_wrong_type_arg (const char *name, const octave_value& tc,
                       bool is_error)
 {
+  octave_execution_exception e;
+
+  gripe_wrong_type_arg (e, name, tc, is_error);
+}
+
+void
+gripe_wrong_type_arg (const octave_execution_exception& e,
+                      const char *name, const octave_value& tc,
+                      bool is_error)
+{
   std::string type = tc.type_name ();
 
-  gripe_wrong_type_arg (name, type, is_error);
+  gripe_wrong_type_arg (e, name, type, is_error);
 }
 
 void
 gripe_wrong_type_arg (const std::string& name, const octave_value& tc,
                       bool is_error)
 {
-  gripe_wrong_type_arg (name.c_str (), tc, is_error);
+  octave_execution_exception e;
+
+  gripe_wrong_type_arg (e, name, tc, is_error);
+}
+
+void
+gripe_wrong_type_arg (const octave_execution_exception& e,
+                      const std::string& name, const octave_value& tc,
+                      bool is_error)
+{
+  gripe_wrong_type_arg (e, name.c_str (), tc, is_error);
 }
 
 void
 gripe_wrong_type_arg (const char *s, bool is_error)
 {
+  octave_execution_exception e;
+
+  gripe_wrong_type_arg (e, s, is_error);
+}
+
+void
+gripe_wrong_type_arg (const octave_execution_exception& e,
+                      const char *s, bool is_error)
+{
   if (is_error)
-    error ("wrong type argument '%s'", s);
+    error (e, "wrong type argument '%s'", s);
   else
     warning ("wrong type argument '%s'", s);
 }
 
 void
 gripe_wrong_type_arg (const std::string& s, bool is_error)
 {
-  gripe_wrong_type_arg (s.c_str (), is_error);
+  octave_execution_exception e;
+
+  gripe_wrong_type_arg (e, s, is_error);
+}
+
+void
+gripe_wrong_type_arg (const octave_execution_exception& e,
+                      const std::string& s, bool is_error)
+{
+  gripe_wrong_type_arg (e, s.c_str (), is_error);
 }
 
 void
 gripe_wrong_type_arg (const octave_value& tc, bool is_error)
 {
+  octave_execution_exception e;
+
+  gripe_wrong_type_arg (e, tc, is_error);
+}
+
+void
+gripe_wrong_type_arg (const octave_execution_exception& e,
+                      const octave_value& tc, bool is_error)
+{
   std::string type = tc.type_name ();
 
-  gripe_wrong_type_arg (type, is_error);
+  gripe_wrong_type_arg (e, type, is_error);
 }
 
 void
 gripe_wrong_type_arg_for_unary_op (const octave_value& op)
 {
   std::string type = op.type_name ();
   error ("invalid operand '%s' for unary operator", type.c_str ());
 }
diff --git a/libinterp/corefcn/gripes.h b/libinterp/corefcn/gripes.h
--- a/libinterp/corefcn/gripes.h
+++ b/libinterp/corefcn/gripes.h
@@ -23,16 +23,17 @@ along with Octave; see the file COPYING.
 #if !defined (octave_gripes_h)
 #define octave_gripes_h 1
 
 #include <string>
 
 #include "lo-array-gripes.h"
 
 class octave_value;
+class octave_execution_exception;
 
 extern OCTINTERP_API void
 gripe_not_supported (const char *);
 
 extern OCTINTERP_API void
 gripe_not_implemented (const char *);
 
 extern OCTINTERP_API void
@@ -53,16 +54,20 @@ gripe_empty_arg (const char *name, bool 
 
 extern OCTINTERP_API void
 gripe_square_matrix_required (const char *name);
 
 extern OCTINTERP_API void
 gripe_user_supplied_eval (const char *name);
 
 extern OCTINTERP_API void
+gripe_user_supplied_eval (const octave_execution_exception& e,
+                          const char *name);
+
+extern OCTINTERP_API void
 gripe_user_returned_invalid (const char *name);
 
 extern OCTINTERP_API void
 gripe_invalid_conversion (const std::string& from, const std::string& to);
 
 extern OCTINTERP_API void
 gripe_invalid_value_specified (const char *name);
 
@@ -78,37 +83,69 @@ gripe_unrecognized_data_fmt (const char 
 extern OCTINTERP_API void
 gripe_data_conversion (const char *from, const char *to);
 
 extern OCTINTERP_API void
 gripe_wrong_type_arg (const char *name, const char *s,
                       bool is_error = true);
 
 extern OCTINTERP_API void
+gripe_wrong_type_arg (const octave_execution_exception& e,
+                      const char *name, const char *s,
+                      bool is_error = true);
+
+extern OCTINTERP_API void
 gripe_wrong_type_arg (const char *name, const std::string& s,
                       bool is_error = true);
 
 extern OCTINTERP_API void
+gripe_wrong_type_arg (const octave_execution_exception& e,
+                      const char *name, const std::string& s,
+                      bool is_error = true);
+
+extern OCTINTERP_API void
 gripe_wrong_type_arg (const char *name, const octave_value& tc,
                       bool is_error = true);
 
 extern OCTINTERP_API void
+gripe_wrong_type_arg (const octave_execution_exception& e,
+                      const char *name, const octave_value& tc,
+                      bool is_error = true);
+
+extern OCTINTERP_API void
 gripe_wrong_type_arg (const std::string& name, const octave_value& tc,
                       bool is_error = true);
 
 extern OCTINTERP_API void
+gripe_wrong_type_arg (const octave_execution_exception& e,
+                      const std::string& name, const octave_value& tc,
+                      bool is_error = true);
+
+extern OCTINTERP_API void
 gripe_wrong_type_arg (const char *s, bool is_error = true);
 
 extern OCTINTERP_API void
+gripe_wrong_type_arg (const octave_execution_exception& e,
+                      const char *s, bool is_error = true);
+
+extern OCTINTERP_API void
 gripe_wrong_type_arg (const std::string& s, bool is_error = true);
 
 extern OCTINTERP_API void
+gripe_wrong_type_arg (const octave_execution_exception& e,
+                      const std::string& s, bool is_error = true);
+
+extern OCTINTERP_API void
 gripe_wrong_type_arg (const octave_value& tc, bool is_error = true);
 
 extern OCTINTERP_API void
+gripe_wrong_type_arg (const octave_execution_exception& e,
+                      const octave_value& tc, bool is_error = true);
+
+extern OCTINTERP_API void
 gripe_wrong_type_arg_for_unary_op (const octave_value& op);
 
 extern OCTINTERP_API void
 gripe_wrong_type_arg_for_binary_op (const octave_value& op);
 
 extern OCTINTERP_API void
 gripe_implicit_conversion (const char *id, const char *from, const char *to);
 
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -642,19 +642,18 @@ get_debug_input (const std::string& prom
         }
       catch (const octave_execution_exception& e)
         {
           std::string stack_trace = e.info ();
 
           if (! stack_trace.empty ())
             std::cerr << stack_trace;
 
+          // Ignore errors when in debugging mode;
           recover_from_exception ();
-
-          // Ignore errors when in debugging mode;
         }
     }
 }
 
 const std::string octave_base_reader::in_src ("invalid");
 
 const std::string octave_terminal_reader::in_src ("terminal");
 
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -88,18 +88,20 @@ load_path::dir_info::update (void)
                 {
                   // We haven't seen this directory before.
 
                   initialize ();
                 }
             }
           catch (const octave_execution_exception&)
             {
-              // Skip updating if we don't know where we are, but
+              // Skip updating if we don't know where we are but
               // don't treat it as an error.
+
+              recover_from_exception ();
             }
         }
       else if (fs.mtime () + fs.time_resolution () > dir_time_last_checked)
         initialize ();
     }
   else
     {
       std::string msg = fs.error ();
@@ -154,17 +156,20 @@ load_path::dir_info::initialize (void)
           // FIXME: nothing is ever removed from this cache of
           // directory information, so there could be some resource
           // problems.  Perhaps it should be pruned from time to time.
 
           abs_dir_cache[abs_name] = *this;
         }
       catch (const octave_execution_exception&)
         {
-          // Skip updating if we don't know where we are.
+          // Skip updating if we don't know where we are but don't treat
+          // it as an error.
+
+          recover_from_exception ();
         }
     }
   else
     {
       std::string msg = fs.error ();
       warning ("load_path: %s: %s", dir_name.c_str (), msg.c_str ());
     }
 }
diff --git a/libinterp/corefcn/ls-mat-ascii.cc b/libinterp/corefcn/ls-mat-ascii.cc
--- a/libinterp/corefcn/ls-mat-ascii.cc
+++ b/libinterp/corefcn/ls-mat-ascii.cc
@@ -54,16 +54,17 @@ along with Octave; see the file COPYING.
 #include "ls-ascii-helper.h"
 #include "ls-mat-ascii.h"
 #include "oct-obj.h"
 #include "oct-map.h"
 #include "ov-cell.h"
 #include "pager.h"
 #include "pt-exp.h"
 #include "sysdep.h"
+#include "toplev.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 #include "version.h"
 #include "dMatrix.h"
 
 static std::string
 get_mat_data_input_line (std::istream& is)
@@ -370,18 +371,20 @@ save_mat_ascii_data (std::ostream& os, c
     warning ("save: omitting imaginary part for ASCII file");
 
   Matrix m;
 
   try
     {
       m = val.matrix_value (true);
     }
-  catch (const octave_execution_exception&)
+  catch (const octave_execution_exception& e)
     {
+      recover_from_exception ();
+
       success = false;
     }
 
   if (success)
     {
       long old_precision = os.precision ();
 
       os.precision (precision);
diff --git a/libinterp/corefcn/lsode.cc b/libinterp/corefcn/lsode.cc
--- a/libinterp/corefcn/lsode.cc
+++ b/libinterp/corefcn/lsode.cc
@@ -71,20 +71,19 @@ lsode_user_function (const ColumnVector&
   if (lsode_fcn)
     {
       octave_value_list tmp;
 
       try
         {
           tmp = lsode_fcn->do_multi_index_op (1, args);
         }
-      catch (const octave_execution_exception&)
+      catch (const octave_execution_exception& e)
         {
-          gripe_user_supplied_eval ("lsode");
-          throw;
+          gripe_user_supplied_eval (e, "lsode");
         }
 
       if (tmp.length () > 0 && tmp(0).is_defined ())
         {
           if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
             {
               warning ("lsode: ignoring imaginary part returned from user-supplied function");
               warned_fcn_imaginary = true;
@@ -114,20 +113,19 @@ lsode_user_jacobian (const ColumnVector&
   if (lsode_jac)
     {
       octave_value_list tmp;
 
       try
         {
           tmp = lsode_jac->do_multi_index_op (1, args);
         }
-      catch (const octave_execution_exception&)
+      catch (const octave_execution_exception& e)
         {
-          gripe_user_supplied_eval ("lsode");
-          throw;
+          gripe_user_supplied_eval (e, "lsode");
         }
 
       if (tmp.length () > 0 && tmp(0).is_defined ())
         {
           if (! warned_jac_imaginary && tmp(0).is_complex_type ())
             {
               warning ("lsode: ignoring imaginary part returned from user-supplied jacobian function");
               warned_jac_imaginary = true;
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -3107,16 +3107,18 @@ mexCallMATLAB (int nargout, mxArray *arg
   octave_value_list retval;
 
   try
     {
       retval = feval (fname, args, nargout);
     }
   catch (const octave_execution_exception&)
     {
+      recover_from_exception ();
+
       execution_error = true;
     }
 
   if (execution_error && mex_context->trap_feval_error == 0)
     {
       // FIXME: is this the correct way to clean up?  abort() is
       // going to trigger a long jump, so the normal class destructors
       // will not be called.  Hopefully this will reduce things to a
@@ -3168,16 +3170,18 @@ mexEvalString (const char *s)
   bool execution_error = false;
 
   try
     {
       ret = eval_string (s, false, parse_status, 0);
     }
   catch (const octave_execution_exception&)
     {
+      recover_from_exception ();
+
       execution_error = true;
     }
 
   if (parse_status || execution_error)
     retval = 1;
 
   return retval;
 }
diff --git a/libinterp/corefcn/oct-handle.h b/libinterp/corefcn/oct-handle.h
--- a/libinterp/corefcn/oct-handle.h
+++ b/libinterp/corefcn/oct-handle.h
@@ -41,19 +41,19 @@ public:
     if (a.is_empty ())
       /* do nothing */;
     else
       {
         try
           {
             val = a.double_value ();
           }
-        catch (const octave_execution_exception&)
+        catch (const octave_execution_exception& e)
           {
-            error ("invalid handle");
+            error (e, "invalid handle");
           }
       }
   }
 
   octave_handle (int a) : val (a) { }
 
   octave_handle (double a) : val (a) { }
 
diff --git a/libinterp/corefcn/oct-map.cc b/libinterp/corefcn/oct-map.cc
--- a/libinterp/corefcn/oct-map.cc
+++ b/libinterp/corefcn/oct-map.cc
@@ -645,19 +645,19 @@ permute_to_correct_order (octave_idx_typ
         {
           if (i == idx)
             continue;
 
           permute_to_correct_order1 (map_list[idx], map_list[i],
                                      new_map_list[i], perm);
         }
     }
-  catch (const octave_execution_exception&)
+  catch (const octave_execution_exception& e)
     {
-      error ("cat: field names mismatch in concatenating structs");
+      error (e, "cat: field names mismatch in concatenating structs");
     }
 }
 
 
 octave_map
 octave_map::cat (int dim, octave_idx_type n, const octave_scalar_map *map_list)
 {
   octave_map retval;
@@ -996,19 +996,19 @@ octave_map::assign (const idx_vector& i,
     {
       Array<octave_idx_type> perm;
       octave_map rhs1;
 
       try
         {
           rhs1 = rhs.orderfields (*this, perm);
         }
-      catch (const octave_execution_exception&)
+      catch (const octave_execution_exception& e)
         {
-          error ("incompatible fields in struct assignment");
+          error (e, "incompatible fields in struct assignment");
         }
 
       assert (rhs1.xkeys.is_same (xkeys));
       assign (i, rhs1);
     }
 }
 
 void
@@ -1044,19 +1044,19 @@ octave_map::assign (const idx_vector& i,
     {
       Array<octave_idx_type> perm;
       octave_map rhs1;
 
       try
         {
           rhs1 = rhs.orderfields (*this, perm);
         }
-      catch (const octave_execution_exception&)
+      catch (const octave_execution_exception& e)
         {
-          error ("incompatible fields in struct assignment");
+          error (e, "incompatible fields in struct assignment");
         }
 
       assert (rhs1.xkeys.is_same (xkeys));
       assign (i, j, rhs1);
     }
 }
 
 void
@@ -1092,19 +1092,19 @@ octave_map::assign (const Array<idx_vect
     {
       Array<octave_idx_type> perm;
       octave_map rhs1;
 
       try
         {
           rhs1 = rhs.orderfields (*this, perm);
         }
-      catch (const octave_execution_exception&)
+      catch (const octave_execution_exception& e)
         {
-          error ("incompatible fields in struct assignment");
+          error (e, "incompatible fields in struct assignment");
         }
 
       assert (rhs1.xkeys.is_same (xkeys));
       assign (ia, rhs1);
     }
 }
 
 void
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -45,16 +45,17 @@ along with Octave; see the file COPYING.
 #include "str-vec.h"
 
 #include "error.h"
 #include "gripes.h"
 #include "input.h"
 #include "oct-stdstrm.h"
 #include "oct-stream.h"
 #include "oct-obj.h"
+#include "toplev.h"
 #include "utils.h"
 
 // Possible values for conv_err:
 //
 //   1 : not a real scalar
 //   2 : value is NaN
 //   3 : value is not an integer
 
@@ -68,16 +69,18 @@ convert_to_valid_int (const octave_value
   double dval = 0.0;
 
   try
     {
       dval = tc.double_value ();
     }
   catch (const octave_execution_exception&)
     {
+      recover_from_exception ();
+
       conv_err = 1;
     }
 
   if (! conv_err)
     {
       if (! lo_ieee_isnan (dval))
         {
           int ival = NINT (dval);
diff --git a/libinterp/corefcn/quad.cc b/libinterp/corefcn/quad.cc
--- a/libinterp/corefcn/quad.cc
+++ b/libinterp/corefcn/quad.cc
@@ -68,20 +68,19 @@ quad_user_function (double x)
   if (quad_fcn)
     {
       octave_value_list tmp;
 
       try
         {
           tmp = quad_fcn->do_multi_index_op (1, args);
         }
-      catch (const octave_execution_exception&)
+      catch (const octave_execution_exception& e)
         {
-          gripe_user_supplied_eval ("quad");
-          throw;
+          gripe_user_supplied_eval (e, "quad");
         }
 
       if (tmp.length () && tmp(0).is_defined ())
         {
           if (! warned_imaginary && tmp(0).is_complex_type ())
             {
               warning ("quad: ignoring imaginary part returned from user-supplied function");
               warned_imaginary = true;
@@ -107,20 +106,19 @@ quad_float_user_function (float x)
   if (quad_fcn)
     {
       octave_value_list tmp;
 
       try
         {
           tmp = quad_fcn->do_multi_index_op (1, args);
         }
-      catch (const octave_execution_exception&)
+      catch (const octave_execution_exception& e)
         {
-          gripe_user_supplied_eval ("quad");
-          throw;
+          gripe_user_supplied_eval (e, "quad");
         }
 
       if (tmp.length () && tmp(0).is_defined ())
         {
           if (! warned_imaginary && tmp(0).is_complex_type ())
             {
               warning ("quad: ignoring imaginary part returned from user-supplied function");
               warned_imaginary = true;
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -209,19 +209,19 @@ do_rand (const octave_value_list& args, 
         else if (tmp.is_matrix_type ())
           {
             Array<int> iv;
 
             try
               {
                 iv = tmp.int_vector_value (true);
               }
-            catch (const octave_execution_exception&)
+            catch (const octave_execution_exception& e)
               {
-                error ("%s: dimensions must be a scalar or array of integers", fcn);
+                error (e, "%s: dimensions must be a scalar or array of integers", fcn);
               }
 
             octave_idx_type len = iv.numel ();
 
             dims.resize (len);
 
             for (octave_idx_type i = 0; i < len; i++)
               {
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -637,23 +637,26 @@ main_loop (void)
                 }
               else if (parser.lexer.end_of_input)
                 break;
             }
         }
       catch (const octave_interrupt_exception&)
         {
           recover_from_exception ();
+
           octave_stdout << "\n";
+
           if (quitting_gracefully)
             return exit_status;
         }
       catch (const index_exception& e)
         {
           recover_from_exception ();
+
           std::cerr << "error: unhandled index exception: "
                     << e.message () << " -- trying to return to prompt"
                     << std::endl;
         }
       catch (const octave_execution_exception& e)
         {
           std::string stack_trace = e.info ();
 
@@ -667,16 +670,17 @@ main_loop (void)
               // We should exit with a nonzero status.
               retval = 1;
               break;
             }
         }
       catch (const std::bad_alloc&)
         {
           recover_from_exception ();
+
           std::cerr << "error: out of memory -- trying to return to prompt"
                     << std::endl;
         }
     }
   while (retval == 0);
 
   octave_stdout << "\n";
 
@@ -1047,19 +1051,19 @@ command shell that is started to run the
         }
 
       if (nargin > 1)
         {
           try
             {
               return_output = args(1).is_true ();
             }
-          catch (const octave_execution_exception&)
+          catch (const octave_execution_exception& e)
             {
-              error ("system: RETURN_OUTPUT must be boolean value true or false");
+              error (e, "system: RETURN_OUTPUT must be boolean value true or false");
             }
         }
 
       if (return_output && type == et_async)
         {
           error ("system: can't return output from commands run asynchronously");
           return retval;
         }
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -1277,16 +1277,17 @@ dims_to_numel (const dim_vector& dims, c
                   idx_vector jdx = idxi.index_vector ();
 
                   retval *= jdx.length (dv(i));
                 }
               catch (const index_exception& e)
                 {
                   std::string idx = e.idx ();
                   std::string msg = e.details ();
+
                   error ("dims_to_numel: Invalid IDX %s. %s",
                          idx.c_str (), msg.c_str ());
                 }
             }
         }
     }
 
   return retval;
@@ -1444,16 +1445,18 @@ character @nospell{\"@xbackslashchar{}0\
 
       if (nargin == 2)
         retval = idx.extent (n) <= n;
       else
         retval = true;
     }
   catch (const octave_execution_exception&)
     {
+      recover_from_exception ();
+
       retval = false;
     }
 
   return retval;
 }
 
 /*
 %!assert (isindex ([1, 2, 3]))
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -369,17 +369,17 @@ safe_symbol_lookup (const std::string& s
   interpreter_try (frame);
 
   try
     {
       retval = symbol_table::find (symbol_name);
     }
   catch (const octave_execution_exception&)
     {
-      // Ignore errors.
+      recover_from_exception ();
     }
 
   return retval;
 }
 
 int
 symbol_exist (const std::string& name, const std::string& type)
 {
diff --git a/libinterp/dldfcn/__eigs__.cc b/libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/__eigs__.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -57,19 +57,19 @@ eigs_func (const ColumnVector &x, int &e
   if (eigs_fcn)
     {
       octave_value_list tmp;
 
       try
         {
           tmp = eigs_fcn->do_multi_index_op (1, args);
         }
-      catch (const octave_execution_exception&)
+      catch (const octave_execution_exception& e)
         {
-          gripe_user_supplied_eval ("eigs");
+          gripe_user_supplied_eval (e, "eigs");
         }
 
       if (tmp.length () && tmp(0).is_defined ())
         {
           if (! warned_imaginary && tmp(0).is_complex_type ())
             {
               warning ("eigs: ignoring imaginary part returned from user-supplied function");
               warned_imaginary = true;
@@ -97,19 +97,19 @@ eigs_complex_func (const ComplexColumnVe
   if (eigs_fcn)
     {
       octave_value_list tmp;
 
       try
         {
           tmp = eigs_fcn->do_multi_index_op (1, args);
         }
-      catch (const octave_execution_exception&)
+      catch (const octave_execution_exception& e)
         {
-          gripe_user_supplied_eval ("eigs");
+          gripe_user_supplied_eval (e, "eigs");
         }
 
       if (tmp.length () && tmp(0).is_defined ())
         {
           retval = tmp(0).complex_vector_value ("eigs: evaluation of user-supplied function failed");
         }
       else
         {
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -459,19 +459,19 @@ octave_base_value::print_info (std::ostr
     T retval = 0; \
  \
     double d = 0.0; \
  \
     try \
       { \
         d = double_value (frc_str_conv); \
       } \
-    catch (const octave_execution_exception&) \
+    catch (const octave_execution_exception& e) \
       { \
-        gripe_wrong_type_arg ("octave_base_value::" #F "_value ()", type_name ()); \
+        gripe_wrong_type_arg (e, "octave_base_value::" #F "_value ()", type_name ()); \
       } \
  \
     if (require_int && D_NINT (d) != d) \
       error_with_cfn ("conversion of %g to " #T " value failed", d); \
     else if (d < std::numeric_limits<T>::min ()) \
       retval = std::numeric_limits<T>::min (); \
     else if (d > std::numeric_limits<T>::max ()) \
       retval = std::numeric_limits<T>::max (); \
@@ -497,19 +497,19 @@ int
 octave_base_value::nint_value (bool frc_str_conv) const
 {
   double d = 0.0;
 
   try
     {
       d = double_value (frc_str_conv);
     }
-  catch (const octave_execution_exception&)
+  catch (const octave_execution_exception& e)
     {
-      gripe_wrong_type_arg ("octave_base_value::nint_value ()", type_name ());
+      gripe_wrong_type_arg (e, "octave_base_value::nint_value ()", type_name ());
     }
 
   if (xisnan (d))
     error ("conversion of NaN to integer value failed");
 
   return static_cast<int> (::fix (d));
 }
 
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -1101,16 +1101,18 @@ octave_class::reconstruct_exemplar (void
           octave_value_list result;
 
           try
             {
               result = ctor.do_multi_index_op (1, octave_value_list ());
             }
           catch (const octave_execution_exception&)
             {
+              recover_from_exception ();
+
               execution_error = true;
             }
 
           if (! execution_error && result.length () == 1)
             retval = true;
         }
       else
         warning ("no constructor for class %s", c_name.c_str ());
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -2079,16 +2079,18 @@ octave_fcn_binder::maybe_binder (const o
                               interpreter_try (frame);
 
                               try
                                 {
                                   root_val = make_fcn_handle (head_name);
                                 }
                               catch (const octave_execution_exception&)
                                 {
+                                  recover_from_exception ();
+
                                   bad = true;
                                 }
                             }
                         }
                     }
                 }
 
               if (! bad)
diff --git a/libinterp/octave-value/ov-oncleanup.cc b/libinterp/octave-value/ov-oncleanup.cc
--- a/libinterp/octave-value/ov-oncleanup.cc
+++ b/libinterp/octave-value/ov-oncleanup.cc
@@ -80,22 +80,22 @@ octave_oncleanup::~octave_oncleanup (voi
 
   try
     {
       // Run the actual code.
       fcn.do_multi_index_op (0, octave_value_list ());
     }
   catch (const octave_interrupt_exception&)
     {
-      // Swallow the interrupt.
+      recover_from_exception ();
+
       warning ("onCleanup: interrupt occured in cleanup action");
     }
   catch (const octave_execution_exception&)
     {
-      // Propagate the error.
       throw;
     }
   catch (...) // Yes, the black hole. We're in a d-tor.
     {
       // This shouldn't happen, in theory.
       error ("onCleanup: internal error: unhandled exception in cleanup action");
     }
 }
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -1868,27 +1868,27 @@ octave_value::float_complex_vector_value
   octave_value::NAME (const char *fmt, ...) const \
   { \
     TYPE retval; \
  \
     try \
       { \
         retval = FCN (); \
       } \
-    catch (const octave_execution_exception&) \
+    catch (const octave_execution_exception& e) \
       { \
         if (fmt) \
           { \
             va_list args; \
             va_start (args, fmt); \
-            verror (fmt, args); \
+            verror (e, fmt, args); \
             va_end (args); \
           } \
  \
-        throw; \
+        throw e; \
       } \
  \
     return retval; \
   }
 
 XVALUE_EXTRACTOR (short int, xshort_value, short_value)
 
 XVALUE_EXTRACTOR (unsigned short int, xushort_value, ushort_value)
@@ -2469,39 +2469,39 @@ do_colon_op (const octave_value& base, c
       bool dq_str = (base.is_dq_string () || limit.is_dq_string ());
 
       Matrix m_base, m_limit, m_increment;
 
       try
         {
           m_base = base.matrix_value (true);
         }
-      catch (const octave_execution_exception&)
+      catch (const octave_execution_exception& e)
         {
-          error ("invalid base value in colon expression");
+          error (e, "invalid base value in colon expression");
         }
 
       try
         {
           m_limit = limit.matrix_value (true);
         }
-      catch (const octave_execution_exception&)
+      catch (const octave_execution_exception& e)
         {
-          error ("invalid limit value in colon expression");
+          error (e, "invalid limit value in colon expression");
         }
 
       try
         {
           m_increment = (increment.is_defined ()
                          ? increment.matrix_value (true)
                          : Matrix (1, 1, 1.0));
         }
-      catch (const octave_execution_exception&)
+      catch (const octave_execution_exception& e)
         {
-          error ("invalid increment value in colon expression");
+          error (e, "invalid increment value in colon expression");
         }
 
       bool base_empty = m_base.is_empty ();
       bool limit_empty = m_limit.is_empty ();
       bool increment_empty = m_increment.is_empty ();
 
       if (base_empty || limit_empty || increment_empty)
         retval = Range ();
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -277,23 +277,26 @@ safe_source_file (const std::string& fil
 {
   try
     {
       source_file (file_name, context, verbose, require_file, warn_for);
     }
   catch (const octave_interrupt_exception&)
     {
       recover_from_exception ();
+
       octave_stdout << "\n";
+
       if (quitting_gracefully)
         clean_up_and_exit (exit_status);
     }
   catch (const octave_execution_exception&)
     {
       recover_from_exception ();
+
       gripe_safe_source_exception (file_name, "unhandled execution exception");
     }
 }
 
 // Initialize by reading startup files.
 
 static void
 execute_startup_files (void)
@@ -392,23 +395,26 @@ execute_eval_option_code (const std::str
 
   try
     {
       eval_string (code, false, parse_status, 0);
     }
   catch (const octave_interrupt_exception&)
     {
       recover_from_exception ();
+
       octave_stdout << "\n";
+
       if (quitting_gracefully)
         clean_up_and_exit (exit_status);
     }
   catch (const octave_execution_exception&)
     {
       recover_from_exception ();
+
       std::cerr << "error: unhandled execution exception -- eval failed"
                 << std::endl;
     }
 
   return parse_status;
 }
 
 static void
@@ -860,16 +866,18 @@ octave_execute_interpreter (void)
       int parse_status = 0;
 
       try
         {
           parse_status = execute_eval_option_code (code_to_eval);
         }
       catch (const octave_execution_exception&)
         {
+          recover_from_exception ();
+
           parse_status = 1;
         }
 
       if (! persist)
         {
           quitting_gracefully = true;
 
           clean_up_and_exit (parse_status);
@@ -892,16 +900,18 @@ octave_execute_interpreter (void)
       try
         {
           intern_argv (remaining_args, octave_cmdline_argv+last_arg_idx);
 
           execute_command_line_file (octave_cmdline_argv[last_arg_idx]);
         }
       catch (const octave_execution_exception&)
         {
+          recover_from_exception ();
+
           exit_status = 1;
         }
 
       if (! persist)
         {
           quitting_gracefully = true;
 
           clean_up_and_exit (exit_status);
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -4489,19 +4489,19 @@ source_file (const std::string& file_nam
 
   octave_function *fcn = 0;
 
   try
     {
       fcn = parse_fcn_file (file_full_name, file_name, "", "",
                             require_file, true, false, false, warn_for);
     }
-  catch (const octave_execution_exception&)
+  catch (const octave_execution_exception& e)
     {
-      error ("source: error sourcing file '%s'", file_full_name.c_str ());
+      error (e, "source: error sourcing file '%s'", file_full_name.c_str ());
     }
 
   if (fcn && fcn->is_user_script ())
     {
       octave_value_list args;
 
       if (verbose)
         {
@@ -4629,19 +4629,19 @@ feval (const std::string& name, const oc
   if (fcn.is_defined ())
     retval = fcn.do_multi_index_op (nargout, args);
   else
     {
       try
         {
           maybe_missing_function_hook (name);
         }
-      catch (const octave_execution_exception&)
+      catch (const octave_execution_exception& e)
         {
-          error ("feval: function '%s' not found", name.c_str ());
+          error (e, "feval: function '%s' not found", name.c_str ());
         }
     }
 
   return retval;
 }
 
 octave_value_list
 feval (octave_function *fcn, const octave_value_list& args, int nargout)
