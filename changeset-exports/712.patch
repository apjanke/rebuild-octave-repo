# HG changeset patch
# User jwe
# Date 779984328 0
#      Mon Sep 19 14:18:48 1994 +0000
# Node ID 36ba0576bd1be95850bf8ea4025fd2784103ee02
# Parent  5f15ab42a631c1796764fb4da88969055d7be06a
[project @ 1994-09-19 14:18:15 by jwe]

diff --git a/src/balance.cc b/src/balance.cc
--- a/src/balance.cc
+++ b/src/balance.cc
@@ -61,40 +61,40 @@ where OPT is an optional single characte
 [DD, AA] = balance (A, OPT) returns aa = dd\a*dd,\n\
 \n\
 [CC, DD, AA, BB] = balance (A, B, OPT) returns AA (BB) = CC*A*DD (CC*B*DD)")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin < 2 || nargin > 4 || nargout < 0 || nargout > 4)
+  if (nargin < 1 || nargin > 3 || nargout < 0 || nargout > 4)
     {
       print_usage ("balance");
       return retval;
     }
 
   char *bal_job;
   int my_nargin;		// # args w/o optional string arg
 
 // Determine if balancing option is listed.  Set my_nargin to the
 // number of matrix inputs.
 
   if (args(nargin-1).is_string ())
     {
       bal_job = args(nargin-1).string_value ();
-      my_nargin = nargin-2;
+      my_nargin = nargin-1;
     }
   else
     {
       bal_job = "B";
-      my_nargin = nargin-1;
+      my_nargin = nargin;
     }
 
-  tree_constant arg_a = args(1);
+  tree_constant arg_a = args(0);
 
   int a_nr = arg_a.rows ();
   int a_nc = arg_a.columns ();
 
 // Check argument 1 dimensions.
 
   if (empty_arg ("balance", a_nr, a_nc) < 0)
     return retval;
@@ -152,17 +152,17 @@ where OPT is an optional single characte
       break;
 
     case 2:
       {
 // Generalized eigenvalue problem.
 
 // 1st we have to check argument 2 dimensions and type...
 
-	tree_constant arg_b = args(2);
+	tree_constant arg_b = args(1);
 
 	int b_nr = arg_b.rows ();
 	int b_nc = arg_b.columns ();
       
 // Check argument 2 dimensions -- must match arg 1.
 
 	if (b_nr != b_nc || b_nr != a_nr)
 	  {
diff --git a/src/chol.cc b/src/chol.cc
--- a/src/chol.cc
+++ b/src/chol.cc
@@ -36,23 +36,25 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "help.h"
 #include "defun-dld.h"
 
 DEFUN_DLD_BUILTIN ("chol", Fchol, Schol, 2, 1,
   "R = chol (X): cholesky factorization")
 {
   Octave_object retval;
 
-  if (args.length () != 2 || nargout > 1)
+  int nargin = args.length ();
+
+  if (nargin != 1 || nargout > 1)
     {
       print_usage ("chol");
       return retval;
     }
 
-  tree_constant arg = args(1);
+  tree_constant arg = args(0);
     
   int nr = arg.rows ();
   int nc = arg.columns ();
 
   if (empty_arg ("chol", nr, nc) < 0)
     return retval;
 
   if (arg.is_real_type ())
diff --git a/src/colloc.cc b/src/colloc.cc
--- a/src/colloc.cc
+++ b/src/colloc.cc
@@ -35,45 +35,45 @@ Software Foundation, 675 Mass Ave, Cambr
 
 DEFUN_DLD_BUILTIN ("colloc", Fcolloc, Scolloc, 7, 4,
   "[R, A, B, Q] = colloc (N [, \"left\"] [, \"right\"]): collocation weights")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin < 2 || nargin > 4)
+  if (nargin < 1 || nargin > 3)
     {
       print_usage ("colloc");
       return retval;
     }
 
-  if (! args(1).is_scalar_type ())
+  if (! args(0).is_scalar_type ())
     {
       error ("colloc: first argument must be a scalar");
       return retval;
     }
 
-  double tmp = args(1).double_value ();
+  double tmp = args(0).double_value ();
 
   if (error_state)
     return retval;
 
   int ncol = NINT (tmp);
   if (ncol < 0)
     {
       error ("colloc: first argument must be non-negative");
       return retval;
     }
 
   int ntot = ncol;
   int left = 0;
   int right = 0;
 
-  for (int i = 2; i < nargin; i++)
+  for (int i = 1; i < nargin; i++)
     {
       if (args(i).is_defined ())
 	{
 	  if (! args(i).is_string ())
 	    {
 	      error ("colloc: expecting string argument");
 	      return retval;
 	    }
diff --git a/src/dassl.cc b/src/dassl.cc
--- a/src/dassl.cc
+++ b/src/dassl.cc
@@ -47,43 +47,41 @@ ColumnVector
 dassl_user_function (const ColumnVector& x, const ColumnVector& xdot, double t)
 {
   ColumnVector retval;
 
   int nstates = x.capacity ();
 
   assert (nstates == xdot.capacity ());
 
-//  tree_constant name (dassl_fcn->name ());
   Octave_object args;
-  args(3) = t;
-//  args(0) = name;
+  args(2) = t;
 
   if (nstates > 1)
     {
       Matrix m1 (nstates, 1);
       Matrix m2 (nstates, 1);
       for (int i = 0; i < nstates; i++)
 	{
 	  m1 (i, 0) = x.elem (i);
 	  m2 (i, 0) = xdot.elem (i);
 	}
       tree_constant state (m1);
       tree_constant deriv (m2);
-      args(1) = state;
-      args(2) = deriv;
+      args(1) = deriv;
+      args(0) = state;
     }
   else
     {
       double d1 = x.elem (0);
       double d2 = xdot.elem (0);
       tree_constant state (d1);
       tree_constant deriv (d2);
-      args(1) = state;
-      args(2) = deriv;
+      args(1) = deriv;
+      args(0) = state;
     }
 
   if (dassl_fcn)
     {
       Octave_object tmp = dassl_fcn->eval (0, 1, args);
 
       if (error_state)
 	{
@@ -115,55 +113,55 @@ compute the vector of residuals.  It mus
   res = f (x, xdot, t)\n\
 \n\
 where x, xdot, and res are vectors, and t is a scalar.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin < 5 || nargin > 6)
+  if (nargin < 4 || nargin > 5)
     {
       print_usage ("dassl");
       return retval;
     }
 
-  dassl_fcn = is_valid_function (args(1), "dassl", 1);
+  dassl_fcn = is_valid_function (args(0), "dassl", 1);
   if (! dassl_fcn || takes_correct_nargs (dassl_fcn, 4, "dassl", 1) != 1)
     return retval;
 
-  ColumnVector state = args(2).vector_value ();
+  ColumnVector state = args(1).vector_value ();
 
   if (error_state)
     {
       error ("dassl: expecting state vector as second argument");
       return retval;
     }
 
-  ColumnVector deriv = args(3).vector_value ();
+  ColumnVector deriv = args(2).vector_value ();
 
   if (error_state)
     {
       error ("dassl: expecting derivative vector as third argument");
       return retval;
     }
 
-  ColumnVector out_times = args(4).vector_value ();
+  ColumnVector out_times = args(3).vector_value ();
 
   if (error_state)
     {
       error ("dassl: expecting output time vector as fourth argument");
       return retval;
     }
 
   ColumnVector crit_times;
   int crit_times_set = 0;
-  if (nargin > 5)
+  if (nargin > 4)
     {
-      crit_times = args(5).vector_value ();
+      crit_times = args(4).vector_value ();
 
       if (error_state)
 	{
 	  error ("dassl: expecting critical time vector as fifth argument");
 	  return retval;
 	}
 
       crit_times_set = 1;
@@ -300,28 +298,28 @@ DEFUN_DLD_BUILTIN ("dassl_options", Fdas
 \n\
 Set or show options for dassl.  Keywords may be abbreviated\n\
 to the shortest match.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1)
+  if (nargin == 0)
     {
       print_dassl_option_list ();
       return retval;
     }
-  else if (nargin == 3)
+  else if (nargin == 2)
     {
-      char *keyword = args(1).string_value ();
+      char *keyword = args(0).string_value ();
 
       if (! error_state)
 	{
-	  double val = args(2).double_value ();
+	  double val = args(1).double_value ();
 
 	  if (! error_state)
 	    {
 	      do_dassl_option (keyword, val);
 	      return retval;
 	    }
 	}
     }
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -39,42 +39,42 @@ Software Foundation, Inc.
 #include "utils.h"
 #include "error.h"
 #include "defun.h"
 
 #ifndef MIN
 #define MIN(a,b) ((a) < (b) ? (a) : (b))
 #endif
 
-DEFUN ("all", Fall, Sall, 2, 1,
+DEFUN ("all", Fall, Sall, 1, 1,
   "all (X): are all elements of X nonzero?")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 2)
+  if (nargin == 1 && args(0).is_defined ())
+    retval = args(0).all ();
+  else
     print_usage ("all");
-  else if (nargin > 0 && args(1).is_defined ())
-    retval = args(1).all ();
 
   return retval;
 }
 
-DEFUN ("any", Fany, Sany, 2, 1,
+DEFUN ("any", Fany, Sany, 1, 1,
   "any (X): are any elements of X nonzero?")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 2)
+  if (nargin == 1 && args(0).is_defined ())
+    retval = args(0).any ();
+  else
     print_usage ("any");
-  else if (nargin > 0 && args(1).is_defined ())
-    retval = args(1).any ();
 
   return retval;
 }
 
 // These mapping functions may also be useful in other places, eh?
 
 typedef double (*d_dd_fcn) (double, double);
 
@@ -123,27 +123,27 @@ map (d_dd_fcn f, const Matrix& x, const 
 
   for (int j = 0; j < x_nc; j++)
     for (int i = 0; i < x_nr; i++)
       retval.elem (i, j) = f (x.elem (i, j), y.elem (i, j));
 
   return retval;
 }
 
-DEFUN ("atan2", Fatan2, Satan2, 3, 1,
+DEFUN ("atan2", Fatan2, Satan2, 2, 1,
   "atan2 (Y, X): atan (Y / X) in range -pi to pi")
 {
   Octave_object retval;
 
-  if (args.length () != 3)
-    print_usage ("atan2");
-  else
+  int nargin = args.length ();
+
+  if (nargin == 2 && args(0).is_defined () && args(1).is_defined ())
     {
-      tree_constant arg_y = args(1);
-      tree_constant arg_x = args(2);
+      tree_constant arg_y = args(0);
+      tree_constant arg_x = args(1);
 
       int y_nr = arg_y.rows ();
       int y_nc = arg_y.columns ();
 
       int x_nr = arg_x.rows ();
       int x_nc = arg_x.columns ();
 
       int arg_y_empty = empty_arg ("atan2", y_nr, y_nc);
@@ -207,179 +207,172 @@ DEFUN ("atan2", Fatan2, Satan2, 3, 1,
 
 	      if (! error_state)
 		retval = map (atan2, y, x);
 	    }
 	}
       else
 	error ("atan2: nonconformant matrices");
     }
+  else
+    print_usage ("atan2");
 
   return retval;
 }
 
-DEFUN ("cumprod", Fcumprod, Scumprod, 2, 1,
+DEFUN ("cumprod", Fcumprod, Scumprod, 1, 1,
   "cumprod (X): cumulative products")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 2)
+  if (nargin == 1 && args(0).is_defined ())
+    retval = args(0).cumprod ();
+  else
     print_usage ("cumprod");
-  else if (nargin > 0 && args(1).is_defined ())
-    retval = args(1).cumprod ();
 
   return retval;
 }
 
-DEFUN ("cumsum", Fcumsum, Scumsum, 2, 1,
+DEFUN ("cumsum", Fcumsum, Scumsum, 1, 1,
   "cumsum (X): cumulative sums")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 2)
+  if (nargin == 1 && args(0).is_defined ())
+    retval = args(0).cumsum ();
+  else
     print_usage ("cumsum");
-  else if (nargin > 0 && args(1).is_defined ())
-    retval = args(1).cumsum ();
 
   return retval;
 }
 
-DEFUN ("diag", Fdiag, Sdiag, 3, 1,
+DEFUN ("diag", Fdiag, Sdiag, 2, 1,
   "diag (X [,k]): form/extract diagonals")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin == 2)
-    retval = args(1).diag ();
-  else if (nargin == 3)
-    retval = args(1).diag (args(2));
+  if (nargin == 1 && args(0).is_defined ())
+    retval = args(0).diag ();
+  else if (nargin == 2 && args(0).is_defined () && args(1).is_defined ())
+    retval = args(0).diag (args(1));
   else
     print_usage ("diag");
 
   return retval;
 }
 
-DEFUN ("isstr", Fisstr, Sisstr, 2, 1,
+DEFUN ("isstr", Fisstr, Sisstr, 1, 1,
   "isstr (X): return 1 if X is a string, 0 otherwise")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 2)
-    print_usage ("isstr");
+  if (nargin == 1 && args(0).is_defined ())
+    retval = (double) args(0).is_string ();
   else
-    {
-      if (nargin > 0 && args(1).is_defined ())
-	retval = (double) args(1).is_string ();
-    }
+    print_usage ("isstr");
 
   return retval;
 }
 
-DEFUN ("prod", Fprod, Sprod, 2, 1,
+DEFUN ("prod", Fprod, Sprod, 1, 1,
   "prod (X): products")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 2)
+  if (nargin == 1 && args(0).is_defined ())
+    retval = args(0).prod ();
+  else
     print_usage ("prod");
-  else if (nargin > 0 && args(1).is_defined ())
-    retval = args(1).prod ();
 
   return retval;
 }
 
-DEFUN ("setstr", Fsetstr, Ssetstr, 2, 1,
+DEFUN ("setstr", Fsetstr, Ssetstr, 1, 1,
   "setstr (V): convert a vector to a string")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin == 2)
-    retval = args(1).convert_to_str ();
+  if (nargin == 1 && args(0).is_defined ())
+    retval = args(0).convert_to_str ();
   else
     print_usage ("setstr");
 
   return retval;
 }
 
-DEFUN ("size", Fsize, Ssize, 2, 1,
+DEFUN ("size", Fsize, Ssize, 1, 1,
   "[m, n] = size (x): return rows and columns of X")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 2)
-    print_usage ("size");
-  else
+  if (nargin == 1 && args(0).is_defined ())
     {
-      if (nargin > 0 && args(1).is_defined ())
+      int nr = args(0).rows ();
+      int nc = args(0).columns ();
+      if (nargout == 0 || nargout == 1)
 	{
-	  int nr = args(1).rows ();
-	  int nc = args(1).columns ();
-	  if (nargout == 0 || nargout == 1)
-	    {
-	      Matrix m (1, 2);
-	      m.elem (0, 0) = nr;
-	      m.elem (0, 1) = nc;
-	      retval = m;
-	    }
-	  else if (nargout == 2)
-	    {
-	      retval(1) = (double) nc;
-	      retval(0) = (double) nr;
-	    }
-	  else
-	    print_usage ("size");
+	  Matrix m (1, 2);
+	  m.elem (0, 0) = nr;
+	  m.elem (0, 1) = nc;
+	  retval = m;
 	}
+      else if (nargout == 2)
+	{
+	  retval(1) = (double) nc;
+	  retval(0) = (double) nr;
+	}
+      else
+	print_usage ("size");
     }
+  else
+    print_usage ("size");
 
   return retval;
 }
 
-DEFUN ("sum", Fsum, Ssum, 2, 1,
+DEFUN ("sum", Fsum, Ssum, 1, 1,
   "sum (X): sum of elements")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 2)
-    print_usage ("sum");
+  if (nargin == 1 && args(0).is_defined ())
+    retval = args(0).sum ();
   else
-    {
-      if (nargin > 0 && args(1).is_defined ())
-	retval = args(1).sum ();
-    }
+    print_usage ("sum");
 
   return retval;
 }
 
-DEFUN ("sumsq", Fsumsq, Ssumsq, 2, 1,
+DEFUN ("sumsq", Fsumsq, Ssumsq, 1, 1,
   "sumsq (X): sum of squares of elements")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 2)
+  if (nargin == 1 && args(0).is_defined ())
+    retval = args(0).sumsq ();
+  else
     print_usage ("sumsq");
-  else if (nargin > 0 && args(1).is_defined ())
-    retval = args(1).sumsq ();
 
   return retval;
 }
 
 static void
 check_dimensions (int& nr, int& nc, const char *warnfor)
 {
   if (nr < 0 || nc < 0)
@@ -463,59 +456,59 @@ fill_matrix (const tree_constant& a, con
   if (error_state)
     return tree_constant ();
 
   Matrix m (nr, nc, val);
 
   return m;
 }
 
-DEFUN ("ones", Fones, Sones, 3, 1,
+DEFUN ("ones", Fones, Sones, 2, 1,
   "ones (N), ones (N, M), ones (X): create a matrix of all ones")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   switch (nargin)
     {
+    case 0:
+      retval = 1.0;
+      break;
     case 1:
-      retval = 1.0;
+      retval = fill_matrix (args(0), 1.0, "ones");
       break;
     case 2:
-      retval = fill_matrix (args(1), 1.0, "ones");
-      break;
-    case 3:
-      retval = fill_matrix (args(1), args(2), 1.0, "ones");
+      retval = fill_matrix (args(0), args(1), 1.0, "ones");
       break;
     default:
       print_usage ("ones");
       break;
     }
 
   return retval;
 }
 
-DEFUN ("zeros", Fzeros, Szeros, 3, 1,
+DEFUN ("zeros", Fzeros, Szeros, 2, 1,
   "zeros (N), zeros (N, M), zeros (X): create a matrix of all zeros")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   switch (nargin)
     {
+    case 0:
+      retval = 0.0;
+      break;
     case 1:
-      retval = 0.0;
+      retval = fill_matrix (args(0), 0.0, "zeros");
       break;
     case 2:
-      retval = fill_matrix (args(1), 0.0, "zeros");
-      break;
-    case 3:
-      retval = fill_matrix (args(1), args(2), 0.0, "zeros");
+      retval = fill_matrix (args(0), args(1), 0.0, "zeros");
       break;
     default:
       print_usage ("zeros");
       break;
     }
 
   return retval;
 }
@@ -557,33 +550,33 @@ identity_matrix (const tree_constant& a,
       int n = MIN (nr, nc);
       for (int i = 0; i < n; i++)
 	m.elem (i, i) = 1.0;
     }
 
   return m;
 }
 
-DEFUN ("eye", Feye, Seye, 3, 1,
+DEFUN ("eye", Feye, Seye, 2, 1,
   "eye (N), eye (N, M), eye (X): create an identity matrix")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   switch (nargin)
     {
+    case 0:
+      retval = 1.0;
+      break;
     case 1:
-      retval = 1.0;
+      retval = identity_matrix (args(0));
       break;
     case 2:
-      retval = identity_matrix (args(1));
-      break;
-    case 3:
-      retval = identity_matrix (args(1), args(2));
+      retval = identity_matrix (args(0), args(1));
       break;
     default:
       print_usage ("eye");
       break;
     }
 
   return retval;
 }
diff --git a/src/defun-int.h b/src/defun-int.h
--- a/src/defun-int.h
+++ b/src/defun-int.h
@@ -87,17 +87,17 @@ Software Foundation, 675 Mass Ave, Cambr
 #define DECLARE_FUN(fname) \
   Octave_object \
   fname (const Octave_object& args, int nargout)
 
 // XXX FIXME XXX -- eliminate the need for these in the functions that
 // use them?
 
 #define DEFINE_ARGV(fcn_name) \
-  int argc = args.length (); \
+  int argc = args.length () + 1; \
   int save_argc = argc; \
   char **argv = make_argv (args, fcn_name); \
   char **save_argv = argv; \
   if (error_state) \
     return retval
 
 #define DELETE_ARGV \
   do \
diff --git a/src/det.cc b/src/det.cc
--- a/src/det.cc
+++ b/src/det.cc
@@ -38,23 +38,23 @@ Software Foundation, 675 Mass Ave, Cambr
 
 DEFUN_DLD_BUILTIN ("det", Fdet, Sdet, 2, 1,
   "det (X): determinant of a square matrix")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 2)
+  if (nargin != 1)
     {
       print_usage ("det");
       return retval;
     }
 
-  tree_constant arg = args(1);
+  tree_constant arg = args(0);
     
   int nr = arg.rows ();
   int nc = arg.columns ();
 
   if (nr == 0 && nc == 0)
     {
       retval = 1.0;
       return retval;
diff --git a/src/eig.cc b/src/eig.cc
--- a/src/eig.cc
+++ b/src/eig.cc
@@ -35,23 +35,25 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "help.h"
 #include "defun-dld.h"
 
 DEFUN_DLD_BUILTIN ("eig", Feig, Seig, 2, 1,
   "eig (X) or [V, D] = eig (X): compute eigenvalues and eigenvectors of X")
 {
   Octave_object retval;
 
-  if (args.length () != 2 || nargout > 2)
+  int nargin = args.length ();
+
+  if (nargin != 1 || nargout > 2)
     {
       print_usage ("eig");
       return retval;
     }
 
-  tree_constant arg = args(1);
+  tree_constant arg = args(0);
 
   int nr = arg.rows ();
   int nc = arg.columns ();
 
   if (empty_arg ("eig", nr, nc) < 0)
     return retval;
 
   if (nr != nc)
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -129,35 +129,35 @@ panic (const char *fmt, ...)
 
   va_list args;
   va_start (args, fmt);
   verror ("panic", fmt, args);
   va_end (args);
   abort ();
 }
 
-DEFUN ("error", Ferror, Serror, 2, 1,
+DEFUN ("error", Ferror, Serror, 1, 1,
   "error (MESSAGE): print MESSAGE and set the error state.\n\
 This should eventually take us up to the top level, possibly\n\
 printing traceback messages as we go.\n\
 \n\
 If MESSAGE ends in a newline character, traceback messages are not\n\
 printed.") 
 {
   Octave_object retval;
 
   char *msg = "unspecified_error";
 
   int nargin = args.length ();
 
-  if (nargin == 2 && args(1).is_defined ())
+  if (nargin == 1 && args(0).is_defined ())
     {
-      if (args(1).is_string ())
+      if (args(0).is_string ())
 	{
-	  msg = args(1).string_value ();
+	  msg = args(0).string_value ();
 
 	  if (! msg || ! *msg)
 	    return retval;
 	}
       else if (args(1).is_empty ())
 	return retval;
     }
 
diff --git a/src/expm.cc b/src/expm.cc
--- a/src/expm.cc
+++ b/src/expm.cc
@@ -55,23 +55,23 @@ extern "C"
 
 DEFUN_DLD_BUILTIN ("expm", Fexpm, Sexpm, 2, 1,
   "expm (X): matrix exponential, e^A")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 2)
+  if (nargin != 1)
     {
       print_usage ("expm");
       return retval;
     }
 
-  tree_constant arg = args(1);
+  tree_constant arg = args(0);
 
 // Constants for matrix exponential calculation.
 
   static double padec [] =
     {
       5.0000000000000000e-1,
       1.1666666666666667e-1,
       1.6666666666666667e-2,
diff --git a/src/fft.cc b/src/fft.cc
--- a/src/fft.cc
+++ b/src/fft.cc
@@ -40,27 +40,27 @@ Software Foundation, 675 Mass Ave, Cambr
 
 DEFUN_DLD_BUILTIN ("fft", Ffft, Sfft, 3, 1,
   "fft (X [, N]): fast fourier transform of a vector")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin < 2 || nargin > 3)
+  if (nargin < 1 || nargin > 2)
     {
       print_usage ("fft");
       return retval;
     }
 
-  tree_constant arg = args(1);
+  tree_constant arg = args(0);
 
   int n_points = arg.rows ();
-  if (nargin == 3)
-    n_points = NINT (args(2).double_value ());
+  if (nargin == 2)
+    n_points = NINT (args(1).double_value ());
 
   if (error_state)
     return retval;
 
   if (n_points < 0)
     {
       error ("fft: number of points must be greater than zero");
       return retval;
diff --git a/src/fft2.cc b/src/fft2.cc
--- a/src/fft2.cc
+++ b/src/fft2.cc
@@ -42,34 +42,34 @@ DEFUN_DLD_BUILTIN ("fft2", Ffft2, Sfft2,
   "fft2 (X [, N] [, M])\n\
 \n\
 two dimensional fast fourier transform of a vector")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin < 2 || nargin > 4)
+  if (nargin < 1 || nargin > 3)
     {
       print_usage ("fft2");
       return retval;
     }
 
-  tree_constant arg = args(1);
+  tree_constant arg = args(0);
 
   int n_rows = arg.rows ();
-  if (nargin > 2)
-    n_rows = NINT (args(2).double_value ());
+  if (nargin > 1)
+    n_rows = NINT (args(1).double_value ());
 
   if (error_state)
     return retval;
 
   int n_cols = arg.columns ();
-  if (nargin > 3)
-    n_cols = NINT (args(3).double_value ());
+  if (nargin > 2)
+    n_cols = NINT (args(2).double_value ());
 
   if (error_state)
     return retval;
 
   if (n_rows < 0 || n_cols < 0)
     {
       error ("fft2: number of points must be greater than zero");
       return retval;
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -275,37 +275,37 @@ file_io_get_file (const tree_constant& a
 	}
       else
 	error ("%s: invalid file specifier", warn_for);
     }
 
   return p;
 }
 
-DEFUN ("fclose", Ffclose, Sfclose, 2, 1,
+DEFUN ("fclose", Ffclose, Sfclose, 1, 1,
   "fclose (FILENAME or FILENUM): close a file")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 2)
+  if (nargin != 1)
     print_usage ("fclose");
   else
     retval = fclose_internal (args);
 
   return retval;
 }
 
 Octave_object
 fclose_internal (const Octave_object& args)
 {
   Octave_object retval;
 
-  Pix p = return_valid_file (args(1));
+  Pix p = return_valid_file (args(0));
 
   if (! p)
     return retval;
 
   file_info file = file_list (p);
 
   if (file.number () < 3)
     {
@@ -323,37 +323,37 @@ fclose_internal (const Octave_object& ar
     {
       error ("fclose: error on closing file");
       retval(0) = 0.0; // failed
     }
 
   return retval;
 }
 
-DEFUN ("fflush", Ffflush, Sfflush, 2, 1,
+DEFUN ("fflush", Ffflush, Sfflush, 1, 1,
   "fflush (FILENAME or FILENUM): flush buffered data to output file")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 2)
+  if (nargin != 1)
     print_usage ("fflush");
   else
     retval = fflush_internal (args);
 
   return retval;
 }
 
 Octave_object
 fflush_internal (const Octave_object& args)
 {
   Octave_object retval;
 
-  Pix p = return_valid_file (args(1));
+  Pix p = return_valid_file (args(0));
 
   if (! p)
     return retval;
 
   file_info file = file_list (p);
 
   if (strcmp (file.mode (), "r") == 0)
     {
@@ -389,45 +389,45 @@ valid_mode (const char *mode)
 	{
 	  m = mode[1];
 	  return (m == '\0' || (m == '+' && mode[2] == '\0'));
 	}
     }
   return 0;
 }
 
-DEFUN ("fgets", Ffgets, Sfgets, 3, 2,
+DEFUN ("fgets", Ffgets, Sfgets, 2, 2,
   "[STRING, LENGTH] = fgets (FILENAME or FILENUM, LENGTH)\n\
 \n\
 read a string from a file")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 3)
+  if (nargin != 2)
     print_usage ("fgets");
   else
     retval = fgets_internal (args, nargout);
 
   return retval;
 }
 
 Octave_object
 fgets_internal (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
-  Pix p = file_io_get_file (args(1), "r", "fgets");
+  Pix p = file_io_get_file (args(0), "r", "fgets");
   
   if (! p)
     return retval;
 
 
-  double dlen = args(2).double_value ();
+  double dlen = args(1).double_value ();
 
   if (error_state)
     return retval;
 
   int length = NINT (dlen);
 
   if ((double) length != dlen)
     {
@@ -449,72 +449,72 @@ fgets_internal (const Octave_object& arg
   if (nargout == 2)
     retval(1) = (double) strlen (string);
 
   retval(0) = string;
 
   return retval;
 }
 
-DEFUN ("fopen", Ffopen, Sfopen, 3, 1,
+DEFUN ("fopen", Ffopen, Sfopen, 2, 1,
   "FILENUM = fopen (FILENAME, MODE): open a file\n\
 \n\
   Valid values for mode include:\n\
 \n\
    r  : open text file for reading\n\
    w  : open text file for writing; discard previous contents if any\n\
    a  : append; open or create text file for writing at end of file\n\
    r+ : open text file for update (i.e., reading and writing)\n\
    w+ : create text file for update; discard previous contents if any\n\
    a+ : append; open or create text file for update, writing at end\n\n\
  Update mode permits reading from and writing to the same file.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 3)
+  if (nargin != 2)
     print_usage ("fopen");
   else
     retval = fopen_internal (args);
 
   return retval;
 }
 
 Octave_object
 fopen_internal (const Octave_object& args)
 {
   Octave_object retval;
   Pix p;
 
-  if (! args(1).is_string ())
+  if (! args(0).is_string ())
     {
       error ("fopen: file name must be a string");
       return retval;
     }
 
-  p = return_valid_file (args(1));
+  p = return_valid_file (args(0));
 
   if (p)
     {
       file_info file = file_list (p);
 
       retval(0) = (double) file.number ();
 
       return retval;
     }
 
-  if (! args(2).is_string ())
+  if (! args(1).is_string ())
     {
       error ("fopen: file mode must be a string");
       return retval;
     }
 
-  char *name = args(1).string_value ();
-  char *mode = args(2).string_value ();
+  char *name = args(0).string_value ();
+  char *mode = args(1).string_value ();
 
   if (! valid_mode (mode))
     {
       error ("fopen: invalid mode");
       return retval;
     }
 
   struct stat buffer;
@@ -537,24 +537,24 @@ fopen_internal (const Octave_object& arg
   file_info file (number, name, file_ptr, mode);
   file_list.append (file);
 
   retval(0) = (double) number;
 
   return retval;
 }
 
-DEFUN ("freport", Ffreport, Sfreport, 1, 1,
+DEFUN ("freport", Ffreport, Sfreport, 0, 1,
   "freport (): list open files and their status")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin > 1)
+  if (nargin > 0)
     warning ("freport: ignoring extra arguments");
 
   retval = freport_internal ();
 
   return retval;
 }
 
 Octave_object
@@ -575,94 +575,94 @@ freport_internal (void)
     }
 
   output_buf << "\n" << ends;
   maybe_page_output (output_buf);
 
   return retval;
 }
 
-DEFUN ("frewind", Ffrewind, Sfrewind, 2, 1,
+DEFUN ("frewind", Ffrewind, Sfrewind, 1, 1,
   "frewind (FILENAME or FILENUM): set file position at beginning of file")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 2)
+  if (nargin != 1)
     print_usage ("frewind");
   else
     retval = frewind_internal (args);
 
   return retval;
 }
 
 Octave_object
 frewind_internal (const Octave_object& args)
 {
   Octave_object retval;
 
-  Pix p = file_io_get_file (args(1), "a+", "frewind");
+  Pix p = file_io_get_file (args(0), "a+", "frewind");
 
   if (p)
     {
       file_info file = file_list (p);
       rewind (file.fptr ());
     }
 
   return retval;
 }
 
-DEFUN ("fseek", Ffseek, Sfseek, 4, 1,
+DEFUN ("fseek", Ffseek, Sfseek, 3, 1,
   "fseek (FILENAME or FILENUM, OFFSET [, ORIGIN])\n\
 \n\
 set file position for reading or writing")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 3 && nargin != 4)
+  if (nargin != 2 && nargin != 3)
     print_usage ("fseek");
   else
     retval = fseek_internal (args);
 
   return retval;
 }
 
 Octave_object
 fseek_internal (const Octave_object& args)
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  Pix p = file_io_get_file (args(1), "a+", "fseek");
+  Pix p = file_io_get_file (args(0), "a+", "fseek");
 
   if (! p)
     return retval;
 
   long origin = SEEK_SET;
 
-  double doff = args(2).double_value ();
+  double doff = args(1).double_value ();
 
   if (error_state)
     return retval;
 
   long offset = NINT (doff);
 
   if ((double) offset != doff)
     {
       error ("fseek: offset not an integer value");
       return retval;
     }
 
-  if (nargin == 4)
+  if (nargin == 3)
     {
-      double dorig = args(3).double_value ();
+      double dorig = args(2).double_value ();
 
       if (error_state)
 	return retval;
 
       origin = NINT (dorig);
 
       if ((double) dorig != origin)
 	{
@@ -693,37 +693,37 @@ fseek_internal (const Octave_object& arg
     }
 
   return retval;
 }
 
 /*
  * Tell current position of file.
  */
-DEFUN ("ftell", Fftell, Sftell, 2, 1,
+DEFUN ("ftell", Fftell, Sftell, 1, 1,
   "POSITION = ftell (FILENAME or FILENUM): returns the current file position")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 2)
+  if (nargin != 1)
     print_usage ("ftell");
   else
     retval = ftell_internal (args);
 
   return retval;
 }
 
 Octave_object
 ftell_internal (const Octave_object& args)
 {
   Octave_object retval;
 
-  Pix p = file_io_get_file (args(1), "a+", "ftell");
+  Pix p = file_io_get_file (args(0), "a+", "ftell");
 
   if (p)
     {
       file_info file = file_list (p);
       long offset = ftell (file.fptr ());
 
       retval(0) = (double) offset;
 
@@ -776,17 +776,17 @@ process_printf_format (const char *s, co
       goto invalid_format;
 
     default:
       break;
     }
 
   if (*s == '*')
     {
-      if (fmt_arg_count >= nargin)
+      if (fmt_arg_count > nargin)
 	{
 	  error ("%s: not enough arguments", type);
 	  return -1;
 	}
 
       double tmp_len = args(fmt_arg_count++).double_value ();
 
       if (error_state)
@@ -817,17 +817,17 @@ process_printf_format (const char *s, co
       fmt << *s++;
     }
 
   if (*s == '*')
     {
       if (*(s-1) == '*')
 	goto invalid_format;
 
-      if (fmt_arg_count >= nargin)
+      if (fmt_arg_count > nargin)
 	{
 	  error ("%s: not enough arguments", type);
 	  return -1;
 	}
 
       double tmp_len = args(fmt_arg_count++).double_value ();
 
       if (error_state)
@@ -856,17 +856,17 @@ process_printf_format (const char *s, co
     {
       chars_from_fmt_str++;
       fmt << *s++;
     }
 
   if (*s == '\0')
     goto invalid_format;
 
-  if (fmt_arg_count >= nargin)
+  if (fmt_arg_count > nargin)
     {
       error ("%s: not enough arguments", type);
       return -1;
     }
 
   switch (*s)
     {
     case 'd': case 'i': case 'o': case 'u': case 'x': case 'X':
@@ -958,17 +958,17 @@ process_printf_format (const char *s, co
  */
 DEFUN ("fprintf", Ffprintf, Sfprintf, -1, 1,
   "fprintf (FILENAME or FILENUM, FORMAT, ...)")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin < 3)
+  if (nargin < 2)
     print_usage ("fprintf");
   else
     retval = do_printf ("fprintf", args, nargout);
 
   return retval;
 }
 
 /*
@@ -976,17 +976,17 @@ DEFUN ("fprintf", Ffprintf, Sfprintf, -1
  */
 DEFUN ("printf", Fprintf, Sprintf, -1, 1,
   "printf (FORMAT, ...)")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin < 2)
+  if (nargin < 1)
     print_usage ("printf");
   else
     retval = do_printf ("printf", args, nargout);
 
   return retval;
 }
 
 /*
@@ -994,60 +994,60 @@ DEFUN ("printf", Fprintf, Sprintf, -1, 1
  */
 DEFUN ("sprintf", Fsprintf, Ssprintf, -1, 1,
   "s = sprintf (FORMAT, ...)")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin < 2)
+  if (nargin < 1)
     print_usage ("sprintf");
   else
     retval = do_printf ("sprintf", args, nargout);
 
   return retval;
 }
 
 Octave_object
 do_printf (const char *type, const Octave_object& args, int nargout)
 {
   Octave_object retval;
-  fmt_arg_count = 1;
+  fmt_arg_count = 0;
   char *fmt;
   file_info file;
 
   if (strcmp (type, "fprintf") == 0)
     {
-      Pix p = file_io_get_file (args(1), "a+", type);
+      Pix p = file_io_get_file (args(0), "a+", type);
 
       if (! p)
 	return retval;
 
       file = file_list (p);
 
       if (file.mode () == "r")
 	{
 	  error ("%s: file is read only", type);
 	  return retval;
 	}
 
-      fmt = args(2).string_value ();
+      fmt = args(1).string_value ();
 
       if (error_state)
 	{
 	  error ("%s: format must be a string", type);
 	  return retval;
 	}
 
       fmt_arg_count += 2;
     }
   else
     {
-      fmt = args(1).string_value ();
+      fmt = args(0).string_value ();
 
       if (error_state)
 	{
 	  error ("%s: invalid format string", type);
 	  return retval;
 	}
 
       fmt_arg_count++;
@@ -1154,17 +1154,17 @@ process_scanf_format (const char *s, ost
     }
 
   if (*s == '\0')
     goto invalid_format;
 
 // Even if we don't have a place to store them, attempt to convert
 // everything specified by the format string.
 
-  if (fmt_arg_count >= (nargout ? nargout : 1))
+  if (fmt_arg_count > (nargout ? nargout : 1))
     store_value = 0;
 
   switch (*s)
     {
     case 'd': case 'i': case 'o': case 'u': case 'x': case 'X':
       {
 	chars_from_fmt_str++;
 	fmt << *s << ends;
@@ -1275,60 +1275,60 @@ process_scanf_format (const char *s, ost
     }
 
   return -1;
 }
 
 /*
  * Formatted reading from a file.
  */
-DEFUN ("fscanf", Ffscanf, Sfscanf, 3, -1,
+DEFUN ("fscanf", Ffscanf, Sfscanf, 2, -1,
   "[A, B, C, ...] = fscanf (FILENAME or FILENUM, FORMAT)")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 2 && nargin != 3)
+  if (nargin != 1 && nargin != 2)
     print_usage ("fscanf");
   else
     retval = do_scanf ("fscanf", args, nargout);
 
   return retval;
 }
 
 /*
  * Formatted reading.
  */
-DEFUN ("scanf", Fscanf, Sscanf, 2, -1,
+DEFUN ("scanf", Fscanf, Sscanf, 1, -1,
   "[A, B, C, ...] = scanf (FORMAT)")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 2)
+  if (nargin != 1)
     print_usage ("scanf");
   else
     retval = do_scanf ("scanf", args, nargout);
 
   return retval;
 }
 
 /*
  * Formatted reading from a string.
  */
-DEFUN ("sscanf", Fsscanf, Ssscanf, 3, -1,
+DEFUN ("sscanf", Fsscanf, Ssscanf, 2, -1,
   "[A, B, C, ...] = sscanf (STRING, FORMAT)")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 3)
+  if (nargin != 2)
     print_usage ("sscanf");
   else
     retval = do_scanf ("sscanf", args, nargout);
 
   return retval;
 }
 
 Octave_object
@@ -1340,62 +1340,62 @@ do_scanf (const char *type, const Octave
   int tmp_file_open = 0;
   FILE *fptr = 0;
   file_info file;
 
   fmt_arg_count = 0;
 
   if (strcmp (type, "scanf") != 0)
     {
-      scanf_fmt = args(2).string_value ();
+      scanf_fmt = args(1).string_value ();
 
       if (error_state)
 	{
 	  error ("%s: format must be a string", type);
 	  return retval;
 	}
     }
 
   int doing_fscanf = (strcmp (type, "fscanf") == 0);
 
   if (doing_fscanf)
     {
-      Pix p = file_io_get_file (args(1), "r", type);
+      Pix p = file_io_get_file (args(0), "r", type);
 
       if (! p)
 	return retval;
 
       file = file_list (p);
 
       if (strcmp (file.mode (), "w") == 0 || strcmp (file.mode (), "a") == 0)
 	{
 	  error ("%s: this file is opened for writing only", type);
 	  return retval;
 	}
 
       fptr = file.fptr ();
     }
 
-  if ((! fptr && args(1).is_string ())
+  if ((! fptr && args(0).is_string ())
       || (doing_fscanf && file.number () == 0))
     {
       char *string;
 
       if (strcmp (type, "scanf") == 0)
-	scanf_fmt = args(1).string_value ();
+	scanf_fmt = args(0).string_value ();
 
       if (strcmp (type, "scanf") == 0
 	  || (doing_fscanf && file.number () == 0))
 	{
 	  string = gnu_readline ("");
 	  if (string && *string)
 	    maybe_save_history (string);
 	}
       else
-	string = args(1).string_value ();
+	string = args(0).string_value ();
 
       tmp_file = octave_tmp_file_name ();
 
       fptr = fopen (tmp_file, "w+");
       if (! fptr)
 	{
 	  error ("%s: error opening temporary file", type);
 	  return retval;
@@ -1505,17 +1505,17 @@ num_items_remaining (FILE *fptr, char *t
 
   fseek (fptr, curr_pos, SEEK_SET);
 
   long len = end_of_file - curr_pos;
 
   return len / size;
 }
 
-DEFUN ("fread", Ffread, Sfread, 4, 2,
+DEFUN ("fread", Ffread, Sfread, 3, 2,
   "[DATA, COUNT] = fread (FILENUM, SIZE, PRECISION)\n\
 \n\
  Reads data in binary form of type PRECISION from a file.\n\
 \n\
  FILENUM   : file number from fopen\n\
  SIZE      : size specification for the Data matrix\n\
  PRECISION : type of data to read, valid types are\n\
 \n\
@@ -1524,17 +1524,17 @@ DEFUN ("fread", Ffread, Sfread, 4, 2,
 \n\
  DATA      : matrix in which the data is stored\n\
  COUNT     : number of elements read")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin < 2 || nargin > 4)
+  if (nargin < 1 || nargin > 3)
     print_usage ("fread");
   else
     retval = fread_internal (args, nargout);
 
   return retval;
 }
 
 /*
@@ -1562,26 +1562,26 @@ DEFUN ("fread", Ffread, Sfread, 4, 2,
  */
 Octave_object
 fread_internal (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  Pix p = file_io_get_file (args(1), "r", "fread");
+  Pix p = file_io_get_file (args(0), "r", "fread");
 
   if (! p)
     return retval;
 
 // Get type and number of bytes per element to read.
   char *prec = "uchar";
-  if (nargin > 3)
+  if (nargin > 2)
     {
-      prec = args(3).string_value ();
+      prec = args(2).string_value ();
 
       if (error_state)
 	{
 	  error ("fread: precision must be a specified as a string");
 	  return retval;
 	}
     }
 
@@ -1594,30 +1594,30 @@ fread_internal (const Octave_object& arg
 // Set up matrix to read into.  If specified in arguments use that
 // number, otherwise read everyting left in file.
 
   double dnr = 0.0;
   double dnc = 0.0;
   int nr;
   int nc;
 
-  if (nargin > 2)
+  if (nargin > 1)
     {
-      if (args(2).is_scalar_type ())
+      if (args(1).is_scalar_type ())
 	{
-	  dnr = args(2).double_value ();
+	  dnr = args(1).double_value ();
 
 	  if (error_state)
 	    return retval;
 
 	  dnc = 1.0;
 	}
       else
 	{
-	  ColumnVector tmp = args(2).vector_value ();
+	  ColumnVector tmp = args(1).vector_value ();
 
 	  if (error_state || tmp.length () != 2)
 	    {
 	      error ("fread: invalid size specification\n");
 	      return retval;
 	    }
 
 	  dnr = tmp.elem (0);
@@ -1671,17 +1671,17 @@ fread_internal (const Octave_object& arg
   if (nargout > 1)
     retval(1) = (double) count;
 
   retval(0) = m;
 
   return retval;
 }
 
-DEFUN ("fwrite", Ffwrite, Sfwrite, 4, 1,
+DEFUN ("fwrite", Ffwrite, Sfwrite, 3, 1,
   "COUNT = fwrite (FILENUM, DATA, PRECISION)\n\
 \n\
  Writes data to a file in binary form of size PRECISION\n\
 \n\
  FILENUM   : file number from fopen\n\
  DATA      : matrix of elements to be written\n\
  PRECISION : type of data to read, valid types are\n\
 \n\
@@ -1689,17 +1689,17 @@ DEFUN ("fwrite", Ffwrite, Sfwrite, 4, 1,
                'double', 'uchar', 'ushort', 'uint', 'ulong'\n\
 \n\
  COUNT     : number of elements written")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin < 3 || nargin > 4)
+  if (nargin < 2 || nargin > 3)
     print_usage ("fwrite");
   else
     retval = fwrite_internal (args, nargout);
 
   return retval;
 }
 
 /*
@@ -1727,17 +1727,17 @@ fwrite_internal (const Octave_object& ar
 
   Pix p = file_io_get_file (args(1), "a+", "fwrite");
 
   if (! p)
     return retval;
 
 // Get type and number of bytes per element to read.
   char *prec = "uchar";
-  if (nargin > 3)
+  if (nargin > 2)
     {
       prec = args(3).string_value ();
 
       if (error_state)
 	{
 	  error ("fwrite: precision must be a specified as a string");
 	  return retval;
 	}
@@ -1752,27 +1752,27 @@ fwrite_internal (const Octave_object& ar
       int count = m.write (file.fptr (), prec);
 
       retval(0) = (double) count;
     }
 
   return retval;
 }
 
-DEFUN ("feof", Ffeof, Sfeof, 2, 1,
+DEFUN ("feof", Ffeof, Sfeof, 1, 1,
   "ERROR = feof (FILENAME or FILENUM)\n\
 \n\
  Returns a non zero value for an end of file condition for the\n\
  file specified by FILENAME or FILENUM from fopen")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 2)
+  if (nargin != 1)
     print_usage ("feof");
   else
     retval = feof_internal (args, nargout);
 
   return retval;
 }
 
 /*
@@ -1796,27 +1796,27 @@ feof_internal (const Octave_object& args
 
   file_info file = file_list (p);
 
   retval(0) = (double) feof (file.fptr ());
 
   return retval;
 }
 
-DEFUN ("ferror", Fferror, Sferror, 2, 1,
+DEFUN ("ferror", Fferror, Sferror, 1, 1,
   "ERROR = ferror (FILENAME or FILENUM)\n\
 \n\
  Returns a non zero value for an error condition on the\n\
  file specified by FILENAME or FILENUM from fopen")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 2)
+  if (nargin != 1)
     print_usage ("ferror");
   else
     retval = ferror_internal (args, nargout);
 
   return retval;
 }
 
 /*
@@ -1829,17 +1829,17 @@ DEFUN ("ferror", Fferror, Sferror, 2, 1,
  *     errnum  : error number
  */
 Octave_object
 ferror_internal (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
 // Get file info.
-  Pix p = return_valid_file (args(1));
+  Pix p = return_valid_file (args(0));
 
   if (! p)
     return retval;
 
   file_info file = file_list (p);
 
   int ierr = ferror (file.fptr ());
 
diff --git a/src/find.cc b/src/find.cc
--- a/src/find.cc
+++ b/src/find.cc
@@ -154,23 +154,23 @@ find_nonzero_elem_idx (const ComplexMatr
 
 DEFUN_DLD_BUILTIN ("find", Ffind, Sfind, 2, 3,
   "find (X) or [I, J, V] = find (X): Return indices of nonzero elements")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 2 || nargout > 3)
+  if (nargin != 1 || nargout > 3)
     {
       print_usage ("find");
       return retval;
     }
 
-  tree_constant arg = args(1);
+  tree_constant arg = args(0);
 
   if (arg.is_real_type ())
     {
       Matrix m = arg.matrix_value ();
 
       if (! error_state)
 	retval = find_nonzero_elem_idx (m, nargout);
     }
diff --git a/src/fsolve.cc b/src/fsolve.cc
--- a/src/fsolve.cc
+++ b/src/fsolve.cc
@@ -79,34 +79,32 @@ hybrd_info_to_fsolve_info (int info)
 
 ColumnVector
 fsolve_user_function (const ColumnVector& x)
 {
   ColumnVector retval;
 
   int n = x.capacity ();
 
-//  tree_constant name = fsolve_fcn->name ();
   Octave_object args;
-  args.resize (2);
-//  args(0) = name;
+  args.resize (1);
 
   if (n > 1)
     {
       Matrix m (n, 1);
       for (int i = 0; i < n; i++)
 	m (i, 0) = x.elem (i);
       tree_constant vars (m);
-      args(1) = vars;
+      args(0) = vars;
     }
   else
     {
       double d = x.elem (0);
       tree_constant vars (d);
-      args(1) = vars;
+      args(0) = vars;
     }
 
   if (fsolve_fcn)
     {
       Octave_object tmp = fsolve_fcn->eval (0, 1, args);
       if (tmp.length () > 0 && tmp(0).is_defined ())
 	{
 	  retval = tmp(0).vector_value ();
@@ -132,35 +130,35 @@ compute the vector of function values.  
   y = f (x)
 \n\
 where y and x are vectors.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin < 3 || nargin > 7 || nargout > 3)
+  if (nargin < 2 || nargin > 6 || nargout > 3)
     {
       print_usage ("fsolve");
       return retval;
     }
 
-  fsolve_fcn = is_valid_function (args(1), "fsolve", 1);
+  fsolve_fcn = is_valid_function (args(0), "fsolve", 1);
   if (! fsolve_fcn || takes_correct_nargs (fsolve_fcn, 2, "fsolve", 1) != 1)
     return retval;
 
-  ColumnVector x = args(2).vector_value ();
+  ColumnVector x = args(1).vector_value ();
 
   if (error_state)
     {
       error ("fsolve: expecting vector as second argument");
       return retval;
     }
 
-  if (nargin > 3)
+  if (nargin > 2)
     warning ("fsolve: ignoring extra arguments");
 
   if (nargout > 2)
     warning ("fsolve: can't compute path output yet");
 
   NLFunc foo_fcn (fsolve_user_function);
   NLEqn foo (x, foo_fcn);
   foo.copy (fsolve_opts);
@@ -266,28 +264,28 @@ DEFUN_DLD_BUILTIN ("fsolve_options", Ffs
 \n\
 Set or show options for fsolve.  Keywords may be abbreviated\n\
 to the shortest match.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1)
+  if (nargin == 0)
     {
       print_fsolve_option_list ();
       return retval;
     }
-  else if (nargin == 3)
+  else if (nargin == 2)
     {
-      char *keyword = args(1).string_value ();
+      char *keyword = args(0).string_value ();
 
       if (! error_state)
 	{
-	  double val = args(2).double_value ();
+	  double val = args(1).double_value ();
 
 	  if (! error_state)
 	    {
 	      do_fsolve_option (keyword, val);
 	      return retval;
 	    }
 	}
     }
diff --git a/src/givens.cc b/src/givens.cc
--- a/src/givens.cc
+++ b/src/givens.cc
@@ -52,24 +52,26 @@ DEFUN_DLD_BUILTIN ("givens", Fgivens, Sg
 \n\
 compute orthogonal matrix G = [c s; -conj (s) c]\n\
 such that G [x; y] = [*; 0]  (x, y scalars)\n\
 \n\
 [c, s] = givens (x, y) returns the (c, s) values themselves.")
 {
   Octave_object retval;
 
-  if (args.length () != 3 || nargout > 2)
+  int nargin = args.length ();
+
+  if (nargin != 2 || nargout > 2)
     {
       print_usage ("givens");
       return retval;
     }
 
-  tree_constant arg_a = args(1);
-  tree_constant arg_b = args(2);
+  tree_constant arg_a = args(0);
+  tree_constant arg_b = args(1);
 
   if (! arg_a.is_scalar_type () && arg_b.is_scalar_type ())
     {
       error("givens: requires two scalar arguments");
       return retval;
     }
 
   Complex cx, cy;
diff --git a/src/hess.cc b/src/hess.cc
--- a/src/hess.cc
+++ b/src/hess.cc
@@ -36,23 +36,25 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "help.h"
 #include "defun-dld.h"
 
 DEFUN_DLD_BUILTIN ("hess", Fhess, Shess, 2, 2,
   "[P, H] = hess (A) or H = hess (A): Hessenberg decomposition")
 {
   Octave_object retval;
 
-  if (args.length () != 2 || nargout > 2)
+  int nargin = args.length ();
+
+  if (nargin != 1 || nargout > 2)
     {
       print_usage ("hess");
       return retval;
     }
 
-  tree_constant arg = args(1);
+  tree_constant arg = args(0);
 
   int nr = arg.rows ();
   int nc = arg.columns ();
 
   if (empty_arg ("hess", nr, nc) < 0)
     return retval;
 
   if (nr != nc)
diff --git a/src/ifft.cc b/src/ifft.cc
--- a/src/ifft.cc
+++ b/src/ifft.cc
@@ -40,27 +40,27 @@ Software Foundation, 675 Mass Ave, Cambr
 
 DEFUN_DLD_BUILTIN ("ifft", Fifft, Sifft, 3, 1,
   "ifft (X [, N]): inverse fast fourier transform of a vector")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin < 2 || nargin > 3)
+  if (nargin < 1 || nargin > 2)
     {
       print_usage ("ifft");
       return retval;
     }
 
-  tree_constant arg = args(1);
+  tree_constant arg = args(0);
     
   int n_points = arg.rows ();
-  if (nargin == 3)
-    n_points = NINT (args(2).double_value ());
+  if (nargin == 2)
+    n_points = NINT (args(1).double_value ());
 
   if (error_state)
     return retval;
 
   if (n_points < 0)
     {
       error ("ifft: number of points must be greater than zero");
       return retval;
diff --git a/src/ifft2.cc b/src/ifft2.cc
--- a/src/ifft2.cc
+++ b/src/ifft2.cc
@@ -42,34 +42,34 @@ DEFUN_DLD_BUILTIN ("ifft2", Fifft2, Siff
   "ifft2 (X [, N] [, M])\n\
 \n\
 two dimensional inverse fast fourier transform of a vector") 
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin < 2 || nargin > 4)
+  if (nargin < 1 || nargin > 3)
     {
       print_usage ("ifft2");
       return retval;
     }
 
-  tree_constant arg = args(1);
+  tree_constant arg = args(0);
 
   int n_rows = arg.rows ();
-  if (nargin > 2)
-    n_rows = NINT (args(2).double_value ());
+  if (nargin > 1)
+    n_rows = NINT (args(1).double_value ());
 
   if (error_state)
     return retval;
 
   int n_cols = arg.columns ();
-  if (nargin > 3)
-    n_cols = NINT (args(3).double_value ());
+  if (nargin > 2)
+    n_cols = NINT (args(2).double_value ());
 
   if (error_state)
     return retval;
 
   if (n_rows < 0 || n_cols < 0)
     {
       error ("ifft2: number of points must be greater than zero");
       return retval;
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -752,23 +752,23 @@ static Octave_object
 get_user_input (const Octave_object& args, int nargout, int debug = 0)
 {
   tree_constant retval;
 
   int nargin = args.length ();
 
   int read_as_string = 0;
 
-  if (nargin == 3)
+  if (nargin == 2)
     read_as_string++;
 
   char *prompt = "debug> ";
-  if (nargin > 1)
+  if (nargin > 0)
    {
-     prompt = args(1).string_value ();
+     prompt = args(0).string_value ();
 
      if (error_state)
        {
 	 error ("input: unrecognized argument");
 	 return retval;
        }
     }
 
@@ -815,44 +815,44 @@ get_user_input (const Octave_object& arg
     error ("input: reading user-input failed!");
 
   if (debug)
     goto again;
 
   return retval;
 }
 
-DEFUN ("input", Finput, Sinput, 3, 1,
+DEFUN ("input", Finput, Sinput, 2, 1,
   "input (PROMPT [, S])\n\
 \n\
 Prompt user for input.  If the second argument is present, return
 value as a string.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin == 2 || nargin == 3)
+  if (nargin == 1 || nargin == 2)
     retval = get_user_input (args, nargout);
   else
     print_usage ("input");
 
   return retval;
 }
 
-DEFUN ("keyboard", Fkeyboard, Skeyboard, 2, 1,
+DEFUN ("keyboard", Fkeyboard, Skeyboard, 1, 1,
   "keyboard (PROMPT)\n\
 \n\
 maybe help in debugging function files")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1 || nargin == 2)
+  if (nargin == 0 || nargin == 1)
     retval = get_user_input (args, nargout, 1);
   else
     print_usage ("keyboard");
 
   return retval;
 }
 
 /*
diff --git a/src/inv.cc b/src/inv.cc
--- a/src/inv.cc
+++ b/src/inv.cc
@@ -38,23 +38,23 @@ Software Foundation, 675 Mass Ave, Cambr
 
 DEFUN_DLD_BUILTIN ("inv", Finv, Sinv, 2, 1,
   "inv (X): inverse of a square matrix")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 2)
+  if (nargin != 1)
     {
       print_usage ("inv");
       return retval;
     }
 
-  tree_constant arg = args(1);
+  tree_constant arg = args(0);
 
   int nr = arg.rows ();
   int nc = arg.columns ();
 
   if (empty_arg ("inverse", nr, nc) < 0)
     return retval;
 
   if (nr != nc)
diff --git a/src/log.cc b/src/log.cc
--- a/src/log.cc
+++ b/src/log.cc
@@ -37,23 +37,25 @@ Software Foundation, 675 Mass Ave, Cambr
 
 // XXX FIXME XXX -- the next two functions should really be just one...
 
 DEFUN_DLD_BUILTIN ("logm", Flogm, Slogm, 2, 1,
   "logm (X): matrix logarithm")
 {
   Octave_object retval;
 
-  if (args.length () != 2)
+  int nargin = args.length ();
+
+  if (nargin != 1)
     {
       print_usage ("logm");
       return retval;
     }
 
-  tree_constant arg = args(1);
+  tree_constant arg = args(0);
     
   if (empty_arg ("logm", arg.rows (), arg.columns ()) < 0)
     return retval;
 
   if (arg.is_real_scalar ())
     {
       double d = arg.double_value ();
       if (d > 0.0)
@@ -143,23 +145,25 @@ DEFUN_DLD_BUILTIN ("logm", Flogm, Slogm,
   return retval;
 }
 
 DEFUN_DLD_BUILTIN ("sqrtm", Fsqrtm, Ssqrtm, 2, 1,
  "sqrtm (X): matrix sqrt")
 {
   Octave_object retval;
 
-  if (args.length () != 2)
+  int nargin = args.length ();
+
+  if (nargin != 1)
     {
       print_usage ("sqrtm");
       return retval;
     }
 
-  tree_constant arg = args(1);
+  tree_constant arg = args(0);
     
   if (empty_arg ("sqrtm", arg.rows (), arg.columns ()))
     return retval;
 
   if (arg.is_real_scalar ())
     {
       double d = arg.double_value ();
       if (d > 0.0)
diff --git a/src/lsode.cc b/src/lsode.cc
--- a/src/lsode.cc
+++ b/src/lsode.cc
@@ -45,34 +45,32 @@ static ODE_options lsode_opts;
 
 ColumnVector
 lsode_user_function (const ColumnVector& x, double t)
 {
   ColumnVector retval;
 
   int nstates = x.capacity ();
 
-//  tree_constant name (lsode_fcn->name ());
   Octave_object args;
-  args(2) = t;
-//  args(0) = name;
+  args(1) = t;
 
   if (nstates > 1)
     {
       Matrix m (nstates, 1);
       for (int i = 0; i < nstates; i++)
 	m (i, 0) = x.elem (i);
       tree_constant state (m);
-      args(1) = state;
+      args(0) = state;
     }
   else
     {
       double d = x.elem (0);
       tree_constant state (d);
-      args(1) = state;
+      args(0) = state;
     }
 
   if (lsode_fcn)
     {
       Octave_object tmp = lsode_fcn->eval (0, 1, args);
 
       if (error_state)
 	{
@@ -103,48 +101,48 @@ compute the vector of right hand sides. 
   xdot = f (x, t)\n\
 \n\
 where xdot and x are vectors and t is a scalar.\n")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin < 4 || nargin > 5 || nargout > 1)
+  if (nargin < 3 || nargin > 4 || nargout > 1)
     {
       print_usage ("lsode");
       return retval;
     }
 
-  lsode_fcn = is_valid_function (args(1), "lsode", 1);
+  lsode_fcn = is_valid_function (args(0), "lsode", 1);
   if (! lsode_fcn || takes_correct_nargs (lsode_fcn, 3, "lsode", 1) != 1)
     return retval;
 
-  ColumnVector state = args(2).vector_value ();
+  ColumnVector state = args(1).vector_value ();
 
   if (error_state)
     {
       error ("lsode: expecting state vector as second argument");
       return retval;
     }
 
-  ColumnVector out_times = args(3).vector_value ();
+  ColumnVector out_times = args(2).vector_value ();
 
   if (error_state)
     {
       error ("lsode: expecting output time vector as third argument");
       return retval;
     }
 
   ColumnVector crit_times;
 
   int crit_times_set = 0;
-  if (nargin > 4)
+  if (nargin > 3)
     {
-      crit_times = args(4).vector_value ();
+      crit_times = args(3).vector_value ();
 
       if (error_state)
 	{
 	  error ("lsode: expecting critical time vector as fourth argument");
 	  return retval;
 	}
 
       crit_times_set = 1;
@@ -281,28 +279,28 @@ DEFUN_DLD_BUILTIN ("lsode_options", Flso
 \n\
 Set or show options for lsode.  Keywords may be abbreviated\n\
 to the shortest match.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1)
+  if (nargin == 0)
     {
       print_lsode_option_list ();
       return retval;
     }
-  else if (nargin == 3)
+  else if (nargin == 2)
     {
-      char *keyword = args(1).string_value ();
+      char *keyword = args(0).string_value ();
 
       if (! error_state)
 	{
-	  double val = args(2).double_value ();
+	  double val = args(1).double_value ();
 
 	  if (! error_state)
 	    {
 	      do_lsode_option (keyword, val);
 	      return retval;
 	    }
 	}
     }
diff --git a/src/lu.cc b/src/lu.cc
--- a/src/lu.cc
+++ b/src/lu.cc
@@ -35,23 +35,25 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "help.h"
 #include "defun-dld.h"
 
 DEFUN_DLD_BUILTIN ("lu", Flu, Slu, 2, 3,
   "[L, U, P] = lu (A): LU factorization")
 {
   Octave_object retval;
 
-  if (args.length () != 2 || nargout > 3)
+  int nargin = args.length ();
+
+  if (nargin != 1 || nargout > 3)
     {
       print_usage ("lu");
       return retval;
     }
 
-  tree_constant arg = args(1);
+  tree_constant arg = args(0);
 
   int nr = arg.rows ();
   int nc = arg.columns ();
 
   if (empty_arg ("lu", nr, nc) < 0)
     return retval;
 
   if (nr != nc)
diff --git a/src/minmax.cc b/src/minmax.cc
--- a/src/minmax.cc
+++ b/src/minmax.cc
@@ -145,39 +145,39 @@ max (const ComplexMatrix& a, const Compl
 
 DEFUN_DLD_BUILTIN ("min", Fmin, Smin, 3, 2,
   "min (X): minimum value(s) of a vector (matrix)")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1 || nargin > 3 || nargout > 2)
+  if (nargin < 1 || nargin > 2 || nargout > 2)
     {
       print_usage ("min");
       return retval;
     }
 
   tree_constant arg1;
   tree_constant arg2;
 
   switch (nargin)
     {
-    case 3:
-      arg2 = args(2);
+    case 2:
+      arg2 = args(1);
 // Fall through...
-    case 2:
-      arg1 = args(1);
+    case 1:
+      arg1 = args(0);
       break;
     default:
       panic_impossible ();
       break;
     }
 
-  if (nargin == 2 && (nargout == 1 || nargout == 0))
+  if (nargin == 1 && (nargout == 1 || nargout == 0))
     {
       if (arg1.is_real_scalar ())
 	{
 	  retval(0) = arg1.double_value ();
 	}
       else if (arg1.is_complex_scalar ())
 	{
           retval(0) = arg1.complex_value ();
@@ -207,17 +207,17 @@ DEFUN_DLD_BUILTIN ("min", Fmin, Smin, 3,
 	    }
 	}
       else
 	{
 	  gripe_wrong_type_arg ("min", arg1);
 	  return retval;
 	}
     }
-  else if (nargin == 2 && nargout == 2)
+  else if (nargin == 1 && nargout == 2)
     {
       if (arg1.is_real_scalar ())
         {
 	  retval(1) = 1;
 	  retval(0) = arg1.double_value ();
 	}
       else if (arg1.is_complex_scalar ())
 	{
@@ -261,17 +261,17 @@ DEFUN_DLD_BUILTIN ("min", Fmin, Smin, 3,
 	    }
 	}
       else
 	{
 	  gripe_wrong_type_arg ("min", arg1);
 	  return retval;
         }
     }
-  else if (nargin == 3)
+  else if (nargin == 2)
     {
       if (arg1.rows () == arg2.rows ()
 	  && arg1.columns () == arg2.columns ())
 	{
 	  if (arg1.is_real_type () && arg2.is_real_type ())
 	    {
 	      Matrix m1 = arg1.matrix_value ();
 
@@ -320,39 +320,39 @@ DEFUN_DLD_BUILTIN ("min", Fmin, Smin, 3,
 
 DEFUN_DLD_BUILTIN ("max", Fmax, Smax, 3, 2,
   "max (X): maximum value(s) of a vector (matrix)")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1 || nargin > 3 || nargout > 2)
+  if (nargin < 1 || nargin > 2 || nargout > 2)
     {
       print_usage ("max");
       return retval;
     }
 
   tree_constant arg1;
   tree_constant arg2;
 
   switch (nargin)
     {
-    case 3:
-      arg2 = args(2);
+    case 2:
+      arg2 = args(1);
 // Fall through...
-    case 2:
-      arg1 = args(1);
+    case 1:
+      arg1 = args(0);
       break;
     default:
       panic_impossible ();
       break;
     }
 
-  if (nargin == 2 && (nargout == 1 || nargout == 0))
+  if (nargin == 1 && (nargout == 1 || nargout == 0))
     {
       if (arg1.is_real_scalar ())
 	{
 	  retval(0) = arg1.double_value ();
 	}
       else if (arg1.is_complex_scalar ())
 	{
           retval(0) = arg1.complex_value ();
@@ -374,17 +374,17 @@ DEFUN_DLD_BUILTIN ("max", Fmax, Smax, 3,
 	    retval(0) = tree_constant (m.column_max (), 0);
 	}
       else
 	{
 	  gripe_wrong_type_arg ("max", arg1);
 	  return retval;
 	}
     }
-  else if (nargin == 2 && nargout == 2)
+  else if (nargin == 1 && nargout == 2)
     {
       if (arg1.is_real_scalar ())
 	{
 	  retval(1) = 1;
 	  retval(0) = arg1.double_value ();
 	}
       else if (arg1.is_complex_scalar ())
 	{
@@ -420,17 +420,17 @@ DEFUN_DLD_BUILTIN ("max", Fmax, Smax, 3,
 	    }
 	}
       else
 	{
 	  gripe_wrong_type_arg ("max", arg1);
 	  return retval;
 	}
     }
-  else if (nargin == 3)
+  else if (nargin == 2)
     {
       if (arg1.rows () == arg2.rows ()
 	  && arg1.columns () == arg2.columns ())
 	{
 // XXX FIXME XXX -- I don't think this is quite right.
           if (arg1.is_real_scalar ())
             {
 	      double result;
diff --git a/src/npsol.cc b/src/npsol.cc
--- a/src/npsol.cc
+++ b/src/npsol.cc
@@ -284,45 +284,45 @@ Handle all of the following:
   retval(2) = -1.0;
 
   print_usage ("npsol");
 
 #else
 
   int nargin = args.length ();
 
-  if (nargin < 3 || nargin == 4 || nargin == 7 || nargin == 10
-      || nargin > 11 || nargout > 4)
+  if (nargin < 2 || nargin == 3 || nargin == 6 || nargin == 9
+      || nargin > 10 || nargout > 4)
     {
       print_usage ("npsol");
       return retval;
     }
 
-  ColumnVector x = args(1).vector_value ();
+  ColumnVector x = args(0).vector_value ();
 
   if (error_state || x.capacity () == 0)
     {
       error ("npsol: expecting vector as first argument");
       return retval;
     }
 
-  npsol_objective = is_valid_function (args(2), "npsol", 1);
+  npsol_objective = is_valid_function (args(1), "npsol", 1);
   if (! npsol_objective
       || takes_correct_nargs (npsol_objective, 2, "npsol", 1) != 1)
     return retval;
 
   Objective func (npsol_objective_function);
 
   ColumnVector soln;
 
   Bounds bounds;
-  if (nargin == 5 || nargin == 8 || nargin == 11)
+  if (nargin == 4 || nargin == 7 || nargin == 10)
     {
-      ColumnVector lb = args(3).vector_value ();
-      ColumnVector ub = args(4).vector_value ();
+      ColumnVector lb = args(2).vector_value ();
+      ColumnVector ub = args(3).vector_value ();
 
       int lb_len = lb.capacity ();
       int ub_len = ub.capacity ();
 
       if (error_state || lb_len != ub_len || lb_len != x.capacity ())
 	{
 	  error ("npsol: lower and upper bounds and decision variable vector");
 	  error ("must all have the same number of elements");
@@ -333,69 +333,69 @@ Handle all of the following:
       bounds.set_lower_bounds (lb);
       bounds.set_upper_bounds (ub);
     }
 
   double objf;
   ColumnVector lambda;
   int inform;
 
-  if (nargin == 3)
+  if (nargin == 2)
     {
       // 1. npsol (x, phi)
 
       NPSOL nlp (x, func);
       nlp.copy (npsol_opts);
       soln = nlp.minimize (objf, inform, lambda);
 
       goto solved;
     }
 
-  if (nargin == 5)
+  if (nargin == 4)
     {
       // 2. npsol (x, phi, lb, ub)
 
       NPSOL nlp (x, func, bounds);
       nlp.copy (npsol_opts);
       soln = nlp.minimize (objf, inform, lambda);
 
       goto solved;
     }
 
   npsol_constraints = 0;
-  if (nargin == 6 || nargin == 8 || nargin == 9 || nargin == 11)
-    npsol_constraints = is_valid_function (args(nargin-2), "npsol", 0);
+  if (nargin == 5 || nargin == 7 || nargin == 8 || nargin == 10)
+    npsol_constraints = is_valid_function (args(nargin-1), "npsol", 0);
 
-  if (nargin == 8 || nargin == 6)
+  if (nargin == 7 || nargin == 5)
     {
       if (! npsol_constraints)
 	{
-	  ColumnVector lub = args(nargin-1).vector_value ();
-	  ColumnVector llb = args(nargin-3).vector_value ();
+	  ColumnVector lub = args(nargin).vector_value ();
+	  ColumnVector llb = args(nargin-2).vector_value ();
 
 	  if (error_state || llb.capacity () == 0 || lub.capacity () == 0)
 	    {
 	      error ("npsol: bounds for linear constraints must be vectors");
 	      return retval;
 	    }
 
-	  Matrix c = args(nargin-2).matrix_value ();
+	  Matrix c = args(nargin-1).matrix_value ();
 
 	  if (error_state)
 	    {
 	      error ("npsol: invalid linear constraint matrix");
 	      return retval;
 	    }
 
 	  if (! linear_constraints_ok (x, llb, c, lub, "npsol", 1))
 	    return retval;
 
 	  LinConst linear_constraints (llb, c, lub);
 
-	  if (nargin == 6)
+	  if (nargin == 5)
 	    {
 	      // 7. npsol (x, phi, llb, c, lub)
 
 	      NPSOL nlp (x, func, linear_constraints);
 	      nlp.copy (npsol_opts);
 	      soln = nlp.minimize (objf, inform, lambda);
 	    }
 	  else
@@ -407,28 +407,28 @@ Handle all of the following:
 	      soln = nlp.minimize (objf, inform, lambda);
 	    }
 	  goto solved;
 	}
       else
 	{
 	  if (takes_correct_nargs (npsol_constraints, 2, "npsol", 1))
 	    {
-	      ColumnVector nlub = args(nargin-1).vector_value ();
-	      ColumnVector nllb = args(nargin-3).vector_value ();
+	      ColumnVector nlub = args(nargin).vector_value ();
+	      ColumnVector nllb = args(nargin-2).vector_value ();
 
 	      if (error_state
 		  || (! nonlinear_constraints_ok
 		      (x, nllb, npsol_constraint_function, nlub, "npsol", 1)))
 		return retval;
 
 	      NLFunc const_func (npsol_constraint_function);
 	      NLConst nonlinear_constraints (nllb, const_func, nlub);
 
-	      if (nargin == 6)
+	      if (nargin == 5)
 		{
 		  // 8. npsol (x, phi, nllb, g, nlub)
 
 		  NPSOL nlp (x, func, nonlinear_constraints);
 		  nlp.copy (npsol_opts);
 		  soln = nlp.minimize (objf, inform, lambda);
 		}
 	      else
@@ -439,61 +439,61 @@ Handle all of the following:
 		  nlp.copy (npsol_opts);
 		  soln = nlp.minimize (objf, inform, lambda);
 		}
 	      goto solved;
 	    }
 	}
     }
 
-  if (nargin == 9 || nargin == 11)
+  if (nargin == 8 || nargin == 10)
     {
       if (! npsol_constraints)
 	{
 	  // Produce error message.
-	  is_valid_function (args(nargin-2), "npsol", 1);
+	  is_valid_function (args(nargin-1), "npsol", 1);
 	}
       else
 	{
 	  if (takes_correct_nargs (npsol_constraints, 2, "npsol", 1))
 	    {
-	      ColumnVector nlub = args(nargin-1).vector_value ();
-	      ColumnVector nllb = args(nargin-3).vector_value ();
+	      ColumnVector nlub = args(nargin).vector_value ();
+	      ColumnVector nllb = args(nargin-2).vector_value ();
 
 	      if (error_state
 		  || (! nonlinear_constraints_ok
 		      (x, nllb, npsol_constraint_function, nlub, "npsol", 1)))
 		return retval;
 
 	      NLFunc const_func (npsol_constraint_function);
 	      NLConst nonlinear_constraints (nllb, const_func, nlub);
 
-	      ColumnVector lub = args(nargin-4).vector_value ();
-	      ColumnVector llb = args(nargin-6).vector_value ();
+	      ColumnVector lub = args(nargin-3).vector_value ();
+	      ColumnVector llb = args(nargin-5).vector_value ();
 
 	      if (error_state || llb.capacity () == 0 || lub.capacity () == 0)
 		{
 		  error ("npsol: bounds for linear constraints must be vectors");
 		  return retval;
 		}
 	      
-	      Matrix c = args(nargin-5).matrix_value ();
+	      Matrix c = args(nargin-4).matrix_value ();
 
 	      if (error_state)
 		{
 		  error ("npsol: invalid linear constraint matrix");
 		  return retval;
 		}
 
 	      if (! linear_constraints_ok (x, llb, c, lub, "npsol", 1))
 		return retval;
 
 	      LinConst linear_constraints (llb, c, lub);
 
-	      if (nargin == 9)
+	      if (nargin == 8)
 		{
 		  // 6. npsol (x, phi, llb, c, lub, nllb, g, nlub)
 
 		  NPSOL nlp (x, func, linear_constraints,
 			     nonlinear_constraints);
 		  nlp.copy (npsol_opts);
 		  soln = nlp.minimize (objf, inform, lambda);
 		}
@@ -763,28 +763,28 @@ to the shortest match.")
 #if defined (NPSOL_MISSING)
 
   print_usage ("npsol_options");
 
 #else
 
   int nargin = args.length ();
 
-  if (nargin == 1)
+  if (nargin == 0)
     {
       print_npsol_option_list ();
       return retval;
     }
-  else if (nargin == 3)
+  else if (nargin == 2)
     {
-      char *keyword = args(1).string_value ();
+      char *keyword = args(0).string_value ();
 
       if (! error_state)
 	{
-	  double val = args(2).double_value ();
+	  double val = args(1).double_value ();
 
 	  if (! error_state)
 	    {
 	      do_npsol_option (keyword, val);
 	      return retval;
 	    }
 	}
     }
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -622,17 +622,19 @@ DEFUN_TEXT ("casesen", Fcasesen, Scasese
 
 DEFUN ("computer", Fcomputer, Scomputer, 1, 0,
   "computer ():\n\
 \n\
 Have Octave ask the system, \"What kind of computer are you?\"")
 {
   Octave_object retval;
 
-  if (args.length () != 1)
+  int nargin = args.length ();
+
+  if (nargin != 0)
     warning ("computer: ignoring extra arguments");
 
   ostrstream output_buf;
 
   if (strcmp (TARGET_HOST_TYPE, "unknown") == 0)
     output_buf << "Hi Dave, I'm a HAL-9000";
   else
     output_buf << TARGET_HOST_TYPE;
@@ -647,41 +649,41 @@ Have Octave ask the system, \"What kind 
       char *msg = output_buf.str ();
       retval = msg;
       delete [] msg;
     }
 
   return retval;
 }
 
-DEFUN ("flops", Fflops, Sflops, 2, 1,
+DEFUN ("flops", Fflops, Sflops, 0, 1,
   "flops (): count floating point operations")
 {
   int nargin = args.length ();
 
-  if (nargin > 2)
+  if (nargin > 0)
     print_usage ("flops");
 
   warning ("flops is a flop, always returning zero");
 
   return 0.0;
 }
 
-DEFUN ("quit", Fquit, Squit, 1, 0,
+DEFUN ("quit", Fquit, Squit, 0, 0,
   "quit (): exit Octave gracefully")
 {
   Octave_object retval;
   quitting_gracefully = 1;
   clean_up_and_exit (0);
   return retval;
 }
 
 DEFALIAS (exit, quit);
 
-DEFUN ("warranty", Fwarranty, Swarranty, 1, 0,
+DEFUN ("warranty", Fwarranty, Swarranty, 0, 0,
   "warranty (): describe copying conditions")
 {
   Octave_object retval;
 
   ostrstream output_buf;
   output_buf << "\n    Octave, version " << version_string
 	     << ".  Copyright (C) 1992, 1993, 1994 John W. Eaton\n"
 	     << "\n\
@@ -708,40 +710,40 @@ DEFUN ("warranty", Fwarranty, Swarranty,
 
 // XXX FIXME XXX -- this may not be the best place for these...
 
 Octave_object
 feval (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
-  tree_fvc *fcn = is_valid_function (args(1), "feval", 1);
+  tree_fvc *fcn = is_valid_function (args(0), "feval", 1);
   if (fcn)
     {
-      int nargin = args.length () - 1;
+      int tmp_nargin = args.length () - 1;
       Octave_object tmp_args;
-      tmp_args.resize (nargin);
-      for (int i = 0; i < nargin; i++)
+      tmp_args.resize (tmp_nargin);
+      for (int i = 0; i < tmp_nargin; i++)
 	tmp_args(i) = args(i+1);
       retval = fcn->eval (0, nargout, tmp_args);
     }
 
   return retval;
 }
 
 DEFUN ("feval", Ffeval, Sfeval, -1, 1,
   "feval (NAME, ARGS, ...)\n\
 \n\
 evaluate NAME as a function, passing ARGS as its arguments")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin > 1)
+  if (nargin > 0)
     retval = feval (args, nargout);
   else
     print_usage ("feval");
 
   return retval;
 }
 
 static Octave_object
@@ -815,44 +817,44 @@ eval_string (const tree_constant& arg, i
       return -1.0;
     }
 
 // Yes Virginia, we always print here...
 
   return eval_string (string, 1, 1, parse_status, nargout);
 }
 
-DEFUN ("eval", Feval, Seval, 3, 1,
+DEFUN ("eval", Feval, Seval, 2, 1,
   "eval (TRY, CATCH)\n\
 \n\
 Evaluate the string TRY as octave code.  If that fails, evaluate the\n\
 string CATCH.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin > 1)
+  if (nargin > 0)
     {
       begin_unwind_frame ("Feval");
 
-      if (nargin > 2)
+      if (nargin > 1)
 	{
 	  unwind_protect_int (suppress_octave_error_messages);
 	  suppress_octave_error_messages = 1;
 	}
 
       int parse_status = 0;
 
-      retval = eval_string (args(1), parse_status, nargout);
+      retval = eval_string (args(0), parse_status, nargout);
 
-      if (nargin > 2 && (parse_status != 0 || error_state))
+      if (nargin > 1 && (parse_status != 0 || error_state))
 	{
 	  error_state = 0;
-	  eval_string (args(2), parse_status, nargout);
+	  eval_string (args(1), parse_status, nargout);
 	  retval = Octave_object ();
 	}
 
       run_unwind_frame ("Feval");
     }
   else
     print_usage ("eval");
 
@@ -863,45 +865,45 @@ string CATCH.")
 
 DEFUN ("system", Fsystem, Ssystem, 2, 1,
   "system (string [, return_output]): execute shell commands")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin < 2 || nargin > 3)
+  if (nargin < 1 || nargin > 2)
     {
-      print_usage ("shell_cmd");
+      print_usage ("system");
       return retval;
     }
 
-  tree_constant tc_command = args(1);
+  tree_constant tc_command = args(0);
 
   char *tmp_str = tc_command.string_value ();
 
   if (error_state)
     {
-      error ("shell_cmd: expecting string as first argument");
+      error ("system: expecting string as first argument");
     }
   else
     {
       iprocstream cmd (tmp_str);
 
       ostrstream output_buf;
 
       char ch;
       while (cmd.get (ch))
 	output_buf.put (ch);
 
       output_buf << ends;
 
       int status = cmd.close ();
 
-      if (nargout > 0 || nargin > 2)
+      if (nargout > 0 || nargin > 1)
 	{
 	  char *msg = output_buf.str ();
 
 	  retval(1) = (double) status;
 	  retval(0) = msg;
 
 	  delete [] msg;
 	}
diff --git a/src/pinv.cc b/src/pinv.cc
--- a/src/pinv.cc
+++ b/src/pinv.cc
@@ -39,27 +39,27 @@ Software Foundation, 675 Mass Ave, Cambr
 DEFUN_DLD_BUILTIN ("pinv", Fpinv, Spinv, 3, 1,
   "pinv ( [, tol])\n\
 Returns the pseudoinverse of X; singular values less than tol are ignored.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin < 2 || nargin > 3)
+  if (nargin < 1 || nargin > 2)
     {
       print_usage ("pinv");
       return retval;
     }
 
-  tree_constant arg = args(1);
+  tree_constant arg = args(0);
 
   double tol = 0.0;
-  if (nargin == 3)
-    tol = args(2).double_value ();
+  if (nargin == 2)
+    tol = args(1).double_value ();
 
   if (error_state)
     return retval;
 
   if (tol < 0.0)
     {
       error ("pinv: tol must be greater than zero");
       return retval;
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -1292,25 +1292,25 @@ octave_print_internal (ostream& os, cons
 	      os << "\n";
 
 	      col += inc;
 	    }
 	}
     }
 }
 
-DEFUN ("disp", Fdisp, Sdisp, 3, 1,
+DEFUN ("disp", Fdisp, Sdisp, 1, 1,
   "disp (X): display value without name tag")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin == 2)
-    args(1).eval (1);
+  if (nargin == 1)
+    args(0).eval (1);
   else
     print_usage ("disp");
 
   return retval;
 }
 
 static void
 init_format_state (void)
diff --git a/src/pt-exp-base.cc b/src/pt-exp-base.cc
--- a/src/pt-exp-base.cc
+++ b/src/pt-exp-base.cc
@@ -105,36 +105,34 @@ print_as_scalar (const tree_constant& va
 
 // Make sure that all arguments have values.
 
 static int
 all_args_defined (const Octave_object& args)
 {
   int nargin = args.length ();
 
-  while (--nargin > 0)
-    {
-      if (args(nargin).is_undefined ())
-	return 0;
-    }
+  for (int i = 0; i < nargin; i++)
+    if (args(i).is_undefined ())
+      return 0;
+
   return 1;
 }
 
 // Are any of the arguments `:'?
 
 static int
 any_arg_is_magic_colon (const Octave_object& args)
 {
   int nargin = args.length ();
 
-  while (--nargin > 0)
-    {
-      if (args(nargin).is_magic_colon ())
+  for (int i = 0; i < nargin; i++)
+    if (args(i).is_magic_colon ())
 	return 1;
-    }
+
   return 0;
 }
 
 // Expressions.
 
 tree_constant
 tree_expression::eval (int print)
 {
@@ -754,22 +752,22 @@ tree_identifier::eval_undefined_error (v
 //   * On systems that support dynamic linking, we prefer .oct files
 //     over .m files.
 
 tree_fvc *
 tree_identifier::do_lookup (int& script_file_executed)
 {
   script_file_executed = lookup (sym);
 
-  tree_fvc *ans = 0;
+  tree_fvc *retval = 0;
 
   if (! script_file_executed)
-    ans = sym->def ();
-
-  return ans;
+    retval = sym->def ();
+
+  return retval;
 }
 
 void
 tree_identifier::mark_as_formal_parameter (void)
 {
   if (sym)
     sym->mark_as_formal_parameter ();
 }
@@ -779,39 +777,37 @@ tree_identifier::eval (int print)
 {
   tree_constant retval;
 
   if (error_state)
     return retval;
 
   int script_file_executed = 0;
 
-  tree_fvc *ans = do_lookup (script_file_executed);
+  tree_fvc *object_to_eval = do_lookup (script_file_executed);
 
   if (! script_file_executed)
     {
-      if (ans)
+      if (object_to_eval)
 	{
 	  int nargout = maybe_do_ans_assign ? 0 : 1;
 
-	  int nargin = (ans->is_constant ()) ? 0 : 1;
 	  Octave_object tmp_args;
-	  tmp_args.resize (nargin);
-	  Octave_object tmp = ans->eval (0, nargout, tmp_args);
+	  Octave_object tmp = object_to_eval->eval (0, nargout, tmp_args);
 
 	  if (tmp.length () > 0)
 	    retval = tmp(0);
 	}
       else
 	eval_undefined_error ();
     }
 
   if (! error_state && retval.is_defined ())
     {
-      if (maybe_do_ans_assign && ! ans->is_constant ())
+      if (maybe_do_ans_assign && ! object_to_eval->is_constant ())
 	{
 
 // XXX FIXME XXX -- need a procedure to do this, probably in
 // variables.cc, to isolate the code that does lookups...
 
 	  symbol_record *sr = global_sym_tab->lookup ("ans", 1, 0);
 
 	  assert (sr);
@@ -867,30 +863,30 @@ tree_identifier::eval (int print, int na
 {
   Octave_object retval;
 
   if (error_state)
     return retval;
 
   int script_file_executed = 0;
 
-  tree_fvc *ans = do_lookup (script_file_executed);
+  tree_fvc *object_to_eval = do_lookup (script_file_executed);
 
   if (! script_file_executed)
     {
-      if (ans)
+      if (object_to_eval)
 	{
 	  if (maybe_do_ans_assign && nargout == 1)
 	    {
 
 // Don't count the output arguments that we create automatically.
 
 	      nargout = 0;
 
-	      retval = ans->eval (0, nargout, args);
+	      retval = object_to_eval->eval (0, nargout, args);
 
 	      if (retval.length () > 0 && retval(0).is_defined ())
 		{
 
 // XXX FIXME XXX -- need a procedure to do this, probably in
 // variables.cc, to isolate the code that does lookups...
 
 		  symbol_record *sr = global_sym_tab->lookup ("ans", 1, 0);
@@ -903,17 +899,17 @@ tree_identifier::eval (int print, int na
 
 		  tree_simple_assignment_expression tmp_ass (ans_id,
 							     tmp, 0, 1);
 
 		  tmp_ass.eval (print);
 		}
 	    }
 	  else
-	    retval = ans->eval (print, nargout, args);
+	    retval = object_to_eval->eval (print, nargout, args);
 	}
       else
 	eval_undefined_error ();
     }
 
   return retval;
 }
 
@@ -945,23 +941,25 @@ tree_index_expression::eval (int print)
 {
   tree_constant retval;
 
   if (error_state)
     return retval;
 
   if (list)
     {
-// Extract the arguments into a simple vector.
+// Extract the arguments into a simple vector.  Don't pass null args.
+
       Octave_object args = list->convert_to_const_vector ();
-// Don't pass null arguments.
+
       int nargin = args.length ();
+
       if (error_state)
 	eval_error ();
-      else if (nargin > 1 && all_args_defined (args))
+      else if (nargin > 0 && all_args_defined (args))
 	{
 	  Octave_object tmp = id->eval (print, 1, args);
 
 	  if (error_state)
 	    eval_error ();
 
 	  if (tmp.length () > 0)
 	    retval = tmp(0);
@@ -982,22 +980,25 @@ tree_index_expression::eval (int print, 
 {
   Octave_object retval;
 
   if (error_state)
     return retval;
 
   if (list)
     {
-// Extract the arguments into a simple vector.
+// Extract the arguments into a simple vector.  Don't pass null args.
+
       Octave_object args = list->convert_to_const_vector ();
-// Don't pass null arguments.
+
+      int nargin = args.length ();
+
       if (error_state)
 	eval_error ();
-      else if (args.length () > 1 && all_args_defined (args))
+      else if (nargin > 0 && all_args_defined (args))
 	{
 	  retval = id->eval (print, nargout, args);
 	  if (error_state)
 	    eval_error ();
 	}
     }
   else
     {
@@ -1194,47 +1195,47 @@ tree_postfix_expression::print_code (ost
 // Unary expressions.
 
 tree_constant
 tree_unary_expression::eval (int print)
 {
   if (error_state)
     return tree_constant ();
 
-  tree_constant ans;
+  tree_constant retval;
 
   switch (etype)
     {
     case tree_expression::not:
     case tree_expression::uminus:
     case tree_expression::hermitian:
     case tree_expression::transpose:
       if (op)
 	{
 	  tree_constant u = op->eval (0);
 	  if (error_state)
 	    eval_error ();
 	  else if (u.is_defined ())
 	    {
-	      ans = do_unary_op (u, etype);
+	      retval = do_unary_op (u, etype);
 	      if (error_state)
 		{
-		  ans = tree_constant ();
+		  retval = tree_constant ();
 		  if (error_state)
 		    eval_error ();
 		}
 	    }
 	}
       break;
     default:
       ::error ("unary operator %d not implemented", etype);
       break;
     }
 
-  return ans;
+  return retval;
 }
 
 char *
 tree_unary_expression::oper (void) const
 {
   static char *op;
   switch (etype)
     {
@@ -1293,17 +1294,18 @@ tree_unary_expression::print_code (ostre
 // Binary expressions.
  
 tree_constant
 tree_binary_expression::eval (int print)
 {
   if (error_state)
     return tree_constant ();
 
-  tree_constant ans;
+  tree_constant retval;
+
   switch (etype)
     {
     case tree_expression::add:
     case tree_expression::subtract:
     case tree_expression::multiply:
     case tree_expression::el_mul:
     case tree_expression::divide:
     case tree_expression::el_div:
@@ -1326,20 +1328,20 @@ tree_binary_expression::eval (int print)
 	    eval_error ();
 	  else if (a.is_defined () && op2)
 	    {
 	      tree_constant b = op2->eval (0);
 	      if (error_state)
 		eval_error ();
 	      else if (b.is_defined ())
 		{
-		  ans = do_binary_op (a, b, etype);
+		  retval = do_binary_op (a, b, etype);
 		  if (error_state)
 		    {
-		      ans = tree_constant ();
+		      retval = tree_constant ();
 		      if (error_state)
 			eval_error ();
 		    }
 		}
 	    }
 	}
       break;
     case tree_expression::and_and:
@@ -1392,25 +1394,25 @@ tree_binary_expression::eval (int print)
 		if (error_state)
 		  {
 		    eval_error ();
 		    break;
 		  }
 	      }
 	  }
       done:
-	ans = tree_constant ((double) result);
+	retval = tree_constant ((double) result);
       }
       break;
     default:
       ::error ("binary operator %d not implemented", etype);
       break;
     }
 
-  return ans;
+  return retval;
 }
 
 char *
 tree_binary_expression::oper (void) const
 {
   static char *op;
   switch (etype)
     {
@@ -1483,75 +1485,75 @@ tree_simple_assignment_expression::~tree
   delete rhs;
 }
 
 tree_constant
 tree_simple_assignment_expression::eval (int print)
 {
   assert (etype == tree_expression::assignment);
 
-  tree_constant ans;
   tree_constant retval;
 
   if (error_state)
     return retval;
 
   if (rhs)
     {
       tree_constant rhs_val = rhs->eval (0);
       if (error_state)
 	{
 	  if (error_state)
 	    eval_error ();
 	}
       else if (! index)
 	{
-	  ans = lhs->assign (rhs_val);
+	  retval = lhs->assign (rhs_val);
 	  if (error_state)
 	    eval_error ();
 	}
       else
 	{
 // Extract the arguments into a simple vector.
+
 	  Octave_object args = index->convert_to_const_vector ();
 
 	  int nargin = args.length ();
 
 	  if (error_state)
 	    eval_error ();
-	  else if (nargin > 1)
+	  else if (nargin > 0)
 	    {
-	      ans = lhs->assign (rhs_val, args);
+	      retval = lhs->assign (rhs_val, args);
 	      if (error_state)
 		eval_error ();
 	    }
 	}
     }
 
-  if (! error_state && ans.is_defined ())
+  if (! error_state && retval.is_defined ())
     {
       int pad_after = 0;
       if (print && user_pref.print_answer_id_name)
 	{
-	  if (print_as_scalar (ans))
+	  if (print_as_scalar (retval))
 	    {
 	      ostrstream output_buf;
 	      output_buf << lhs->name () << " = " << ends;
 	      maybe_page_output (output_buf);
 	    }
 	  else
 	    {
 	      pad_after = 1;
 	      ostrstream output_buf;
 	      output_buf << lhs->name () << " =\n\n" << ends;
 	      maybe_page_output (output_buf);
 	    }
 	}
 
-      retval = ans.eval (print);
+      retval.eval (print);
 
       if (print && pad_after)
 	{
 	  ostrstream output_buf;
 	  output_buf << "\n" << ends;
 	  maybe_page_output (output_buf);
 	}
     }
@@ -1945,17 +1947,16 @@ tree_builtin::eval (int print)
   if (error_state)
     return retval;
 
   if (fcn)
     {
     eval_fcn:
 
       Octave_object args;
-      args(0) = tree_constant (my_name);
       Octave_object tmp = (*fcn) (args, 1);
       if (tmp.length () > 0)
 	retval = tmp(0);
     }
   else
     {
       fcn = load_octave_builtin (my_name);
 
@@ -1986,20 +1987,19 @@ tree_builtin::eval (int print, int nargo
 	::error ("invalid use of colon in function argument list");
       else
 	retval = (*fcn) (args, nargout);
     }
   else if (is_mapper)
     {
       if (nargin > nargin_max)
 	::error ("%s: too many arguments", my_name);
-      else if (nargin > 0 && args.length () > 0 && args(1).is_defined ())
+      else if (nargin > 0 && args(0).is_defined ())
 	{
-	  tree_constant tmp = args(1).mapper (mapper_fcn, 0);
-	  retval.resize (1);
+	  tree_constant tmp = args(0).mapper (mapper_fcn, 0);
 	  retval(0) = tmp;
 	}	
     }
   else
     {
       fcn = load_octave_builtin (my_name);
 
       if (fcn)
@@ -2223,24 +2223,19 @@ tree_function::eval (int print, int narg
       {
 	traceback_error ();
 	goto abort;
       }
     
 // Copy return values out.
 
     if (ret_list)
-      {
-	retval = ret_list->convert_to_const_vector ();
-      }
+      retval = ret_list->convert_to_const_vector ();
     else if (user_pref.return_last_computed_value)
-      {
-	retval.resize (1);
-	retval(0) = last_computed_value;
-      }
+      retval(0) = last_computed_value;
   }
 
  abort:
   run_unwind_frame ("func_eval");
 
   return retval;
 }
 
@@ -2332,25 +2327,25 @@ tree_function::print_code (ostream& os)
       cmd_list->print_code (os);
     }
 
   os << "endfunction";
 
   print_code_new_line (os);
 }
 
-DEFUN ("va_arg", Fva_arg, Sva_arg, 1, 1,
+DEFUN ("va_arg", Fva_arg, Sva_arg, 0, 1,
   "va_arg (): return next argument in a function that takes a\n\
 variable number of parameters")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1)
+  if (nargin == 0)
     {
       if (curr_function)
 	{
 	  if (curr_function->takes_varargs ())
 	    retval = curr_function->octave_va_arg ();
 	  else
 	    {
 	      error ("va_arg only valid within function taking variable");
@@ -2361,25 +2356,25 @@ variable number of parameters")
 	error ("va_arg only valid within function body");
     }
   else
     print_usage ("va_arg");
 
   return retval;
 }
 
-DEFUN ("va_start", Fva_start, Sva_start, 1, 0,
+DEFUN ("va_start", Fva_start, Sva_start, 0, 0,
   "va_start (): reset the pointer to the list of optional arguments\n\
 to the beginning")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1)
+  if (nargin == 0)
     {
       if (curr_function)
 	{
 	  if (curr_function->takes_varargs ())
 	    curr_function->octave_va_start ();
 	  else
 	    {
 	      error ("va_start only valid within function taking variable");
diff --git a/src/pt-misc.cc b/src/pt-misc.cc
--- a/src/pt-misc.cc
+++ b/src/pt-misc.cc
@@ -200,25 +200,23 @@ tree_statement_list::print_code (ostream
       if (elt)
 	elt->print_code (os);
     }
 }
 
 Octave_object
 tree_argument_list::convert_to_const_vector (void)
 {
-  int len = length () + 1;
+  int len = length ();
 
   Octave_object args;
   args.resize (len);
 
-// args[0] may eventually hold something useful, like the function
-// name.
   Pix p = first ();
-  for (int k = 1; k < len; k++)
+  for (int k = 0; k < len; k++)
     {
       tree_expression *elt = this->operator () (p);
       if (elt)
 	{
 	  args(k) = elt->eval (0);
 	  if (error_state)
 	    {
 	      ::error ("evaluating argument list element number %d", k);
@@ -227,16 +225,17 @@ tree_argument_list::convert_to_const_vec
 	  next (p);
 	}
       else
 	{
 	  args(k) = tree_constant ();
 	  break;
 	}
     }
+
   return args;
 }
 
 void
 tree_argument_list::print_code (ostream& os)
 {
   Pix p = first ();
 
@@ -266,26 +265,26 @@ tree_parameter_list::mark_as_formal_para
       tree_identifier *elt = this->operator () (p);
       elt->mark_as_formal_parameter ();
     }
 }
 
 void
 tree_parameter_list::define_from_arg_vector (const Octave_object& args)
 {
-  if (args.length () <= 0)
+  int nargin = args.length ();
+
+  if (nargin <= 0)
     return;
 
-  int nargin = args.length ();
-
-  int expected_nargin = length () + 1;
+  int expected_nargin = length ();
 
   Pix p = first ();
 
-  for (int i = 1; i < expected_nargin; i++)
+  for (int i = 0; i < expected_nargin; i++)
     {
       tree_identifier *elt = this->operator () (p);
 
       tree_constant *tmp = 0;
 
       if (i < nargin)
 	{
 	  if (args(i).is_defined () && args(i).is_magic_colon ())
diff --git a/src/qpsol.cc b/src/qpsol.cc
--- a/src/qpsol.cc
+++ b/src/qpsol.cc
@@ -86,52 +86,52 @@ Handle all of the following:
   retval(2) = -1.0;
 
   print_usage ("qpsol");
 
 #else
 
   int nargin = args.length ();
 
-  if (nargin < 4 || nargin == 5 || nargin == 8 || nargin > 9
+  if (nargin < 3 || nargin == 4 || nargin == 7 || nargin > 8
       || nargout > 4)
     {
       print_usage ("qpsol");
       return retval;
     }
 
-  ColumnVector x = args(1).vector_value ();
+  ColumnVector x = args(0).vector_value ();
 
   if (error_state || x.capacity () == 0)
     {
       error ("qpsol: expecting vector as first argument");
       return retval;
     }
 
-  Matrix H = args(2).matrix_value ();
+  Matrix H = args(1).matrix_value ();
 
   if (error_state || H.rows () != H.columns () || H.rows () != x.capacity ())
     {
       error ("qpsol: H must be a square matrix consistent with the size of x");
       return retval;
     }
 
-  ColumnVector c = args(3).vector_value ();
+  ColumnVector c = args(2).vector_value ();
 
   if (error_state || c.capacity () != x.capacity ())
     {
       error ("qpsol: c must be a vector the same size as x");
       return retval;
     }
 
   Bounds bounds;
-  if (nargin == 6 || nargin == 9)
+  if (nargin == 5 || nargin == 8)
     {
-      ColumnVector lb = args(4).vector_value ();
-      ColumnVector ub = args(5).vector_value ();
+      ColumnVector lb = args(3).vector_value ();
+      ColumnVector ub = args(4).vector_value ();
 
       int lb_len = lb.capacity ();
       int ub_len = ub.capacity ();
 
       if (error_state || lb_len != ub_len || lb_len != x.capacity ())
 	{
 	  error ("qpsol: lower and upper bounds and decision variable vector");
 	  error ("must all have the same number of elements");
@@ -143,63 +143,63 @@ Handle all of the following:
       bounds.set_upper_bounds (ub);
     }
 
   ColumnVector soln;
   double objf;
   ColumnVector lambda;
   int inform;
 
-  if (nargin == 4)
+  if (nargin == 3)
     {
       // 1. qpsol (x, H, c)
 
       QPSOL qp (x, H, c);
       qp.copy (qpsol_opts);
       soln = qp.minimize (objf, inform, lambda);
 
       goto solved;
     }
 
-  if (nargin == 6)
+  if (nargin == 5)
     {
       //  2. qpsol (x, H, c, lb, ub)
 
       QPSOL qp (x, H, c, bounds);
       qp.copy (qpsol_opts);
       soln = qp.minimize (objf, inform, lambda);
 
       goto solved;
     }
 
-  if (nargin == 7 || nargin == 9)
+  if (nargin == 6 || nargin == 8)
     {
-      ColumnVector lub = args(nargin-1).vector_value ();
-      ColumnVector llb = args(nargin-3).vector_value ();
+      ColumnVector lub = args(nargin).vector_value ();
+      ColumnVector llb = args(nargin-2).vector_value ();
 
       if (error_state || llb.capacity () == 0 || lub.capacity () == 0)
 	{
 	  error ("qpsol: bounds for linear constraints must be vectors");
 	  return retval;
 	}
 
-      Matrix A = args(nargin-2).matrix_value ();
+      Matrix A = args(nargin-1).matrix_value ();
 
       if (error_state)
 	{
 	  error ("qpsol: invalid linear constraint matrix");
 	  return retval;
 	}
 
       if (! linear_constraints_ok (x, llb, A, lub, "qpsol", 1))
 	return retval;
 
       LinConst linear_constraints (llb, A, lub);
 
-      if (nargin == 9)
+      if (nargin == 8)
 	{
 	  // 3. qpsol (x, H, c, lb, ub, llb, A, lub)
 
 	  QPSOL qp (x, H, c, bounds, linear_constraints);
 	  qp.copy (qpsol_opts);
 	  soln = qp.minimize (objf, inform, lambda);
 	}
       else
@@ -369,28 +369,28 @@ to the shortest match.")
 #if defined (QPSOL_MISSING)
 
   print_usage ("qpsol");
 
 #else
 
   int nargin = args.length ();
 
-  if (nargin == 1)
+  if (nargin == 0)
     {
       print_qpsol_option_list ();
       return retval;
     }
-  else if (nargin == 3)
+  else if (nargin == 2)
     {
-      char *keyword = args(1).string_value ();
+      char *keyword = args(0).string_value ();
 
       if (! error_state)
 	{
-	  double val = args(2).double_value ();
+	  double val = args(1).double_value ();
 
 	  if (! error_state)
 	    {
 	      do_qpsol_option (keyword, val);
 	      return retval;
 	    }
 	}
     }
diff --git a/src/qr.cc b/src/qr.cc
--- a/src/qr.cc
+++ b/src/qr.cc
@@ -55,29 +55,29 @@ DEFUN_DLD_BUILTIN ("qr", Fqr, Sqr, 2, 2,
 \n\
 qr (X) alone returns the output of the LAPACK routine dgeqrf, such\n\
 that R = triu (qr (X))")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 2 && nargin != 3 || nargout > 3)
+  if (nargin != 1 && nargin != 2 || nargout > 3)
     {
       print_usage ("qr");
       return retval;
     }
 
-  tree_constant arg = args(1);
+  tree_constant arg = args(0);
     
   if (empty_arg ("qr", arg.rows (), arg.columns ()) < 0)
     return retval;
 
   QR::type type = nargout == 1 ? QR::raw
-    : (nargin == 3 ? QR::economy : QR::std);
+    : (nargin == 2 ? QR::economy : QR::std);
 
   if (arg.is_real_type ())
     {
       Matrix m = arg.matrix_value ();
 
       if (! error_state)
 	{
 	  if (nargout < 3)
diff --git a/src/quad.cc b/src/quad.cc
--- a/src/quad.cc
+++ b/src/quad.cc
@@ -44,20 +44,18 @@ static tree_fvc *quad_fcn;
 
 static Quad_options quad_opts;
 
 double
 quad_user_function (double x)
 {
   double retval = 0.0;
 
-//  tree_constant name = quad_fcn->name ();
   Octave_object args;
-  args(1) = x;
-//  args(0) = name;
+  args(0) = x;
 
   if (quad_fcn)
     {
       Octave_object tmp = quad_fcn->eval (0, 1, args);
 
       if (error_state)
 	{
 	  quad_integration_error = 1;  // XXX FIXME XXX
@@ -99,35 +97,35 @@ The second and third arguments are limit
 both may be infinite.  The optional argument TOL specifies the desired\n\
 accuracy of the result.  The optional argument SING is a vector of\n\
 at which the integrand is singular.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin < 4 || nargin > 6 || nargout > 4)
+  if (nargin < 3 || nargin > 5 || nargout > 4)
     {
       print_usage ("quad");
       return retval;
     }
 
-  quad_fcn = is_valid_function (args(1), "fsolve", 1);
+  quad_fcn = is_valid_function (args(0), "fsolve", 1);
   if (! quad_fcn || takes_correct_nargs (quad_fcn, 2, "fsolve", 1) != 1)
     return retval;
 
-  double a = args(2).double_value ();
+  double a = args(1).double_value ();
 
   if (error_state)
     {
       error ("quad: expecting second argument to be a scalar");
       return retval;
     }
 
-  double b = args(3).double_value ();
+  double b = args(2).double_value ();
 
   if (error_state)
     {
       error ("quad: expecting third argument to be a scalar");
       return retval;
     }
 
   int indefinite = 0;
@@ -157,35 +155,35 @@ at which the integrand is singular.")
   double val = 0.0;
   double abstol = 1e-6;
   double reltol = 1e-6;
   Vector tol (2);
   Vector sing;
   int have_sing = 0;
   switch (nargin)
     {
-    case 6:
+    case 5:
       if (indefinite)
 	{
 	  error("quad: singularities not allowed on infinite intervals");
 	  return retval;
 	}
 
       have_sing = 1;
 
-      sing = args(5).vector_value ();
+      sing = args(4).vector_value ();
 
       if (error_state)
 	{
 	  error ("quad: expecting vector of singularities as fourth argument");
 	  return retval;
 	}
 
-    case 5:
-      tol = args(4).vector_value ();
+    case 4:
+      tol = args(3).vector_value ();
 
       if (error_state)
 	{
 	  error ("quad: expecting vector of tolerances as fifth argument");
 	  return retval;
 	}
 
       switch (tol.capacity ())
@@ -197,17 +195,17 @@ at which the integrand is singular.")
 	  abstol = tol.elem (0);
 	  break;
 
 	default:
 	  error ("quad: expecting tol to contain no more than two values");
 	  return retval;
 	}
 
-    case 4:
+    case 3:
       if (indefinite)
 	{
 	  IndefQuad iq (quad_user_function, bound, indef_type, abstol, reltol);
 	  iq.copy (quad_opts);
 	  val = iq.integrate (ier, nfun, abserr);
 	}
       else
 	{
@@ -332,28 +330,28 @@ DEFUN_DLD_BUILTIN ("quad_options", Fquad
 \n\
 Set or show options for quad.  Keywords may be abbreviated\n\
 to the shortest match.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1)
+  if (nargin == 0)
     {
       print_quad_option_list ();
       return retval;
     }
-  else if (nargin == 3)
+  else if (nargin == 2)
     {
-      char *keyword = args(1).string_value ();
+      char *keyword = args(0).string_value ();
 
       if (! error_state)
 	{
-	  double val = args(2).double_value ();
+	  double val = args(1).double_value ();
 
 	  if (! error_state)
 	    {
 	      do_quad_option (keyword, val);
 	      return retval;
 	    }
 	}
     }
diff --git a/src/qzval.cc b/src/qzval.cc
--- a/src/qzval.cc
+++ b/src/qzval.cc
@@ -57,24 +57,26 @@ extern "C"
 DEFUN_DLD_BUILTIN ("qzvalue", Fqzvalue, Sqzvalue, 3, 1,
   "X = qzval (A, B)\n\
 \n\
 compute generalized eigenvalues of the matrix pencil (A - lambda B).\n\
 A and B must be real matrices.")
 {
   Octave_object retval;
 
-  if (args.length () != 3 || nargout > 1)
+  int nargin = args.length ();
+
+  if (nargin != 2 || nargout > 1)
     {
       print_usage ("qzvalue");
       return retval;
     }
 
-  tree_constant arg_a = args(1);
-  tree_constant arg_b = args(2);
+  tree_constant arg_a = args(0);
+  tree_constant arg_b = args(1);
 
   int a_nr = arg_a.rows();
   int a_nc = arg_a.columns();
 
   int b_nr = arg_b.rows();
   int b_nc = arg_b.columns();
   
   if (empty_arg ("qzvalue", a_nr, a_nc) < 0
diff --git a/src/rand.cc b/src/rand.cc
--- a/src/rand.cc
+++ b/src/rand.cc
@@ -107,17 +107,17 @@ rand (\"dist\")         -- get current d
 rand (DISTRIBUTION)   -- set distribution type (\"normal\" or \"uniform\"\n\
 rand (SEED)           -- get current seed\n\
 rand (SEED, N)        -- set seed")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin > 3 || nargout > 1)
+  if (nargin > 2 || nargout > 1)
     {
       print_usage ("rand");
       return retval;
     }
 
   static int initialized = 0;
   if (! initialized)
     {
@@ -140,25 +140,25 @@ rand (SEED, N)        -- set seed")
       s1 = force_to_fit_range (s1, 1, 2147483399);
 
       F77_FCN (setall) (&s0, &s1);
       initialized = 1;
     }
 
   int n = 0;
   int m = 0;
-  if (nargin == 1)
+  if (nargin == 0)
     {
       n = 1;
       m = 1;
       goto gen_matrix;
     }
-  else if (nargin == 2)
+  else if (nargin == 1)
     {
-      tree_constant tmp = args(1);
+      tree_constant tmp = args(0);
 
       if (tmp.is_string ())
 	{
 	  char *s_arg = tmp.string_value ();
 	  if (strcmp (s_arg, "dist") == 0)
 	    {
 	      char *s = curr_rand_dist ();
 	      retval(0) = s;
@@ -186,43 +186,43 @@ rand (SEED, N)        -- set seed")
 	{
 	  Range r = tmp.range_value ();
 	  n = 1;
 	  m = NINT (r.nelem ());
 	  goto gen_matrix;
 	}
       else if (tmp.is_matrix_type ())
 	{
-	  n = NINT (args(1).rows ());
-	  m = NINT (args(1).columns ());
+	  n = NINT (args(0).rows ());
+	  m = NINT (args(0).columns ());
 	  goto gen_matrix;
 	}
       else
 	{
 	  gripe_wrong_type_arg ("rand", tmp);
 	  return retval;
 	}
     }
-  else if (nargin == 3)
+  else if (nargin == 2)
     {
-      if (args(1).is_string ()
-	  && strcmp (args(1).string_value (), "seed") == 0)
+      if (args(0).is_string ()
+	  && strcmp (args(0).string_value (), "seed") == 0)
 	{
-	  double d = args(2).double_value ();
+	  double d = args(1).double_value ();
 
 	  if (! error_state)
 	    set_rand_seed (d);
 	}
       else
 	{
-	  n = NINT (args(1).double_value ());
+	  n = NINT (args(0).double_value ());
 
 	  if (! error_state)
 	    {
-	      m = NINT (args(2).double_value ());
+	      m = NINT (args(1).double_value ());
 
 	      if (! error_state)
 		goto gen_matrix;
 	    }
 	}
     }
 
   return retval;
diff --git a/src/schur.cc b/src/schur.cc
--- a/src/schur.cc
+++ b/src/schur.cc
@@ -48,28 +48,28 @@ characters:\n\
   A = continuous time poles\n\
   D = discrete time poles\n\
   U = unordered schur (default)")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1 || nargin > 3 || nargout > 2)
+  if (nargin < 1 || nargin > 2 || nargout > 2)
     {
       print_usage ("schur");
       return retval;
     }
 
-  tree_constant arg = args(1);
+  tree_constant arg = args(0);
 
   char *ord = "U";
-  if (nargin == 3)
+  if (nargin == 2)
     {
-      ord = args(2).string_value ();
+      ord = args(1).string_value ();
 
       if (error_state)
 	{
 	  error ("schur: expecting string as second argument");
 	  return retval;
 	}
     }
 
diff --git a/src/sort.cc b/src/sort.cc
--- a/src/sort.cc
+++ b/src/sort.cc
@@ -167,29 +167,29 @@ DEFUN_DLD_BUILTIN ("sort", Fsort, Ssort,
   "[S, I] = sort (X)\n\
 \n\
 sort the columns of X, optionally return sort index")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin != 2)
+  if (nargin != 1)
     {
       print_usage ("sort");
       return retval;
     }
 
   int return_idx = nargout > 1;
   if (return_idx)
     retval.resize (2);
   else
     retval.resize (1);
 
-  tree_constant arg = args(1);
+  tree_constant arg = args(0);
 
   if (arg.is_real_type ())
     {
       Matrix m = arg.matrix_value ();
 
       if (! error_state)
 	{
 	  if (m.rows () == 1)
diff --git a/src/svd.cc b/src/svd.cc
--- a/src/svd.cc
+++ b/src/svd.cc
@@ -42,28 +42,28 @@ DEFUN_DLD_BUILTIN ("svd", Fsvd, Ssvd, 2,
 Compute the singular value decomposition of X.  Given a second input\n\
 argument, an `economy' sized factorization is computed that omits\n\
 unnecessary rows and columns of U and V")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin < 2 || nargin > 3 || nargout == 2 || nargout > 3)
+  if (nargin < 1 || nargin > 2 || nargout == 2 || nargout > 3)
     {
       print_usage ("svd");
       return retval;
     }
 
-  tree_constant arg = args(1);
+  tree_constant arg = args(0);
 
   if (empty_arg ("svd", arg.rows (), arg.columns ()) < 0)
     return retval;
 
-  SVD::type type = (nargin == 3) ? SVD::economy : SVD::std;
+  SVD::type type = (nargin == 2) ? SVD::economy : SVD::std;
 
   if (arg.is_real_type ())
     {
       Matrix tmp = arg.matrix_value ();
 
       if (! error_state)
 	{
 	  SVD result (tmp, type);
diff --git a/src/syl.cc b/src/syl.cc
--- a/src/syl.cc
+++ b/src/syl.cc
@@ -56,25 +56,27 @@ extern "C"
 			long, long);
 }
 
 DEFUN_DLD_BUILTIN ("syl", Fsyl, Ssyl, 4, 1,
   "X = syl (A, B, C): solve the Sylvester equation A X + X B + C = 0")
 {
   Octave_object retval;
 
-  if (args.length () != 4 || nargout > 1)
+  int nargin = args.length ();
+
+  if (nargin != 3 || nargout > 1)
     {
       print_usage ("syl");
       return retval;
     }
 
-  tree_constant arg_a = args(1);
-  tree_constant arg_b = args(2);
-  tree_constant arg_c = args(3);
+  tree_constant arg_a = args(0);
+  tree_constant arg_b = args(1);
+  tree_constant arg_c = args(2);
 
   int a_nr = arg_a.rows ();
   int a_nc = arg_a.columns ();
 
   int b_nr = arg_b.rows ();
   int b_nc = arg_b.columns ();
 
   int c_nr = arg_c.rows ();
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -368,17 +368,17 @@ kbhit (void)
 {
   int c;
   raw_mode (1);
   c = cin.get ();
   raw_mode (0);
   return c;
 }
 
-DEFUN ("clc", Fclc, Sclc, 1, 0,
+DEFUN ("clc", Fclc, Sclc, 0, 0,
   "clc (): clear screen")
 {
   Octave_object retval;
 
   rl_beg_of_line ();
   rl_kill_line (1);
 
 #if ! defined (_GO32_)
@@ -392,43 +392,43 @@ DEFUN ("clc", Fclc, Sclc, 1, 0,
 
   fflush (rl_outstream);
 
   return retval;
 }
 
 DEFALIAS (home, clc);
 
-DEFUN ("getenv", Fgetenv, Sgetenv, 2, 1,
+DEFUN ("getenv", Fgetenv, Sgetenv, 1, 1,
   "getenv (STRING): get environment variable values")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (nargin == 2)
+  if (nargin == 1)
     {
-      char *name = args(1).string_value ();
+      char *name = args(0).string_value ();
 
       if (! error_state)
 	{
 	  char *value = getenv (name);
 	  if (value)
 	    retval = value;
 	  else
 	    retval = "";
 	}
     }
   else
     print_usage ("getenv");
 
   return retval;
 }
 
-DEFUN ("kbhit", Fkbhit, Skbhit, 1, 1,
+DEFUN ("kbhit", Fkbhit, Skbhit, 0, 1,
   "kbhit: get a single character from the terminal")
 {
   Octave_object retval;
 
 // XXX FIXME XXX -- add timeout and default value args?
 
   if (interactive)
     {
@@ -444,29 +444,29 @@ DEFUN ("kbhit", Fkbhit, Skbhit, 1, 1,
 
 DEFUN ("pause", Fpause, Spause, 1, 1,
   "pause (seconds): suspend program execution")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
-  if (! (nargin == 1 || nargin == 2))
+  if (! (nargin == 0 || nargin == 1))
     {
       print_usage ("pause");
       return retval;
     }
 
   if (interactive)
     {
       switch (nargin)
 	{
-	case 2:
+	case 1:
 	  {
-	    double dval = args(1).double_value ();
+	    double dval = args(0).double_value ();
 
 	    if (! error_state)
 	      {
 		int delay = NINT (dval);
 		if (delay > 0)
 		  sleep (delay);
 	      }
 	  }
diff --git a/src/tc-rep.cc b/src/tc-rep.cc
--- a/src/tc-rep.cc
+++ b/src/tc-rep.cc
@@ -230,21 +230,21 @@ any_element_is_complex (const ComplexMat
   return 0;
 }
 
 static int
 valid_scalar_indices (const Octave_object& args)
 {
   int nargin = args.length ();
 
-  return ((nargin == 3
-	   && args(2).valid_as_scalar_index ()
-	   && args(1).valid_as_scalar_index ())
-	  || (nargin == 2
-	      && args(1).valid_as_scalar_index ()));
+  return ((nargin == 2
+	   && args(1).valid_as_scalar_index ()
+	   && args(0).valid_as_scalar_index ())
+	  || (nargin == 1
+	      && args(0).valid_as_scalar_index ()));
 }
 
 // Now, the classes.
 
 // The real representation of constants.
 
 TC_REP::tree_constant_rep (void)
 {
@@ -1799,64 +1799,68 @@ TC_REP::do_scalar_index (const Octave_ob
     {
       int rows = 0;
       int cols = 0;
 
       int nargin = args.length ();
 
       switch (nargin)
 	{
-	case 3:
+	case 2:
 	  {
-	    if (args(2).is_matrix_type ())
+	    tree_constant arg = args(1);
+
+	    if (arg.is_matrix_type ())
 	      {
-		Matrix mj = args(2).matrix_value ();
+		Matrix mj = arg.matrix_value ();
 
 		idx_vector j (mj, user_pref.do_fortran_indexing, "");
 		if (! j)
 		  return retval;
 
 		int len = j.length ();
 		if (len == j.ones_count ())
 		  cols = len;
 	      }
-	    else if (args(2).const_type () == magic_colon
-		     || (args(2).is_scalar_type ()
-			 && NINT (args(2).double_value ()) == 1))
+	    else if (arg.const_type () == magic_colon
+		     || (arg.is_scalar_type ()
+			 && NINT (arg.double_value ()) == 1))
 	      {
 		cols = 1;
 	      }
 	    else
 	      break;
 	  }
 
 // Fall through...
 
-	case 2:
+	case 1:
 	  {
-	    if (args(1).is_matrix_type ())
+	    tree_constant arg = args(0);
+
+	    if (arg.is_matrix_type ())
 	      {
-		Matrix mi = args(1).matrix_value ();
+		Matrix mi = arg.matrix_value ();
 
 		idx_vector i (mi, user_pref.do_fortran_indexing, "");
 		if (! i)
 		  return retval;
 
 		int len = i.length ();
 		if (len == i.ones_count ())
 		  rows = len;
 	      }
-	    else if (args(1).const_type () == magic_colon
-		     || (args(1).is_scalar_type ()
-			 && NINT (args(1).double_value ()) == 1))
+	    else if (arg.const_type () == magic_colon
+		     || (arg.is_scalar_type ()
+			 && NINT (arg.double_value ()) == 1))
 	      {
 		rows = 1;
 	      }
-	    else if (args(1).is_scalar_type ()
-		     && NINT (args(1).double_value ()) == 0)
+	    else if (arg.is_scalar_type ()
+		     && NINT (arg.double_value ()) == 0)
 	      {
 		return Matrix ();
 	      }
 	    else
 	      break;
 
 	    if (cols == 0)
 	      {
@@ -1897,38 +1901,46 @@ tree_constant
 TC_REP::do_matrix_index (const Octave_object& args) const
 {
   tree_constant retval;
 
   int nargin = args.length ();
 
   switch (nargin)
     {
-    case 2:
-      if (args.length () <= 0)
-	::error ("matrix index is null");
-      else if (args(1).is_undefined ())
-	::error ("matrix index is a null expression");
-      else
-	retval = do_matrix_index (args(1));
+    case 1:
+      {
+	tree_constant arg = args(0);
+
+	if (arg.is_undefined ())
+	  ::error ("matrix index is a null expression");
+	else
+	  retval = do_matrix_index (arg);
+      }
       break;
 
     case 3:
-      if (args.length () <= 0)
-	::error ("matrix indices are null");
-      else if (args(1).is_undefined ())
+      {
+	tree_constant arg_a = args(0);
+	tree_constant arg_b = args(1);
+
+	if (arg_a.is_undefined ())
 	::error ("first matrix index is a null expression");
-      else if (args(2).is_undefined ())
-	::error ("second matrix index is a null expression");
-      else
-	retval = do_matrix_index (args(1), args(2));
+	else if (arg_b.is_undefined ())
+	  ::error ("second matrix index is a null expression");
+	else
+	  retval = do_matrix_index (arg_a, arg_b);
+      }
       break;
 
     default:
-      ::error ("too many indices for matrix expression");
+      if (nargin == 0)
+	::error ("matrix indices expected, but none provided");
+      else
+	::error ("too many indices for matrix expression");
       break;
     }
 
   return  retval;
 }
 
 tree_constant
 TC_REP::do_matrix_index (const tree_constant& i_arg) const
@@ -3230,17 +3242,17 @@ TC_REP::do_scalar_assignment (const tree
 	  if (type_tag == matrix_constant)
 	    delete matrix;
 	  else if (type_tag == complex_matrix_constant)
 	    delete complex_matrix;
 
 	  type_tag = unknown_constant;
 	}
     }
-  else if (nargin > 3 || nargin < 2)
+  else if (nargin > 2 || nargin < 1)
     ::error ("invalid index expression for scalar type");
   else
     ::error ("index invalid or out of range for scalar type");
 }
 
 // Assignments to matrices (and vectors).
 //
 // For compatibility with Matlab, we allow assignment of an empty
@@ -3276,49 +3288,57 @@ TC_REP::do_matrix_assignment (const tree
     }
 
   int nargin = args.length ();
 
 // The do_matrix_assignment functions can't handle empty matrices, so
 // don't let any pass through here.
   switch (nargin)
     {
+    case 1:
+      {
+	tree_constant arg = args(0);
+
+	if (arg.is_undefined ())
+	  ::error ("matrix index is undefined");
+	else
+	  do_matrix_assignment (rhs, arg);
+      }
+      break;
+
     case 2:
-      if (args.length () <= 0)
-	::error ("matrix index is null");
-      else if (args(1).is_undefined ())
-	::error ("matrix index is undefined");
-      else
-	do_matrix_assignment (rhs, args(1));
-      break;
-
-    case 3:
-      if (args.length () <= 0)
-	::error ("matrix indices are null");
-      else if (args(1).is_undefined ())
-	::error ("first matrix index is undefined");
-      else if (args(2).is_undefined ())
-	::error ("second matrix index is undefined");
-      else if (args(1).is_empty () || args(2).is_empty ())
-	{
-	  if (! rhs.is_empty ())
-	    {
-	      ::error ("in assignment expression, a matrix index is empty");
-	      ::error ("but hte right hand side is not an empty matrix");
-	    }
+      {
+	tree_constant arg_a = args(0);
+	tree_constant arg_b = args(1);
+
+	if (arg_a.is_undefined ())
+	  ::error ("first matrix index is undefined");
+	else if (arg_b.is_undefined ())
+	  ::error ("second matrix index is undefined");
+	else if (arg_a.is_empty () || arg_b.is_empty ())
+	  {
+	    if (! rhs.is_empty ())
+	      {
+		::error ("in assignment expression, a matrix index is empty");
+		::error ("but the right hand side is not an empty matrix");
+	      }
 // XXX FIXME XXX -- to really be correct here, we should probably
 // check to see if the assignment conforms, but that seems like more
 // work than it's worth right now...
-	}
-      else
-	do_matrix_assignment (rhs, args(1), args(2));
+	  }
+	else
+	  do_matrix_assignment (rhs, arg_a, arg_b);
+      }
       break;
 
     default:
-      ::error ("too many indices for matrix expression");
+      if (nargin == 0)
+	::error ("matrix indices expected, but none provided");
+      else
+	::error ("too many indices for matrix expression");
       break;
     }
 }
 
 // Matrix assignments indexed by a single value.
 
 void
 TC_REP::do_matrix_assignment (const tree_constant& rhs,
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -493,33 +493,33 @@ D_NINT (double x)
 }
 
 // XXX FIXME XXX --  put these in some file, and make them extern.
 
 static int
 all_strings (const Octave_object& args)
 {
   int n = args.length ();
-  for (int i = 1; i < n; i++)
+  for (int i = 0; i < n; i++)
     if (! args(i).is_string ())
       return 0;
   return 1;
 }
 
 char **
 make_argv (const Octave_object& args, const char *fcn_name)
 {
   char **argv = 0;
   if (all_strings (args))
     {
       int n = args.length ();
       argv = new char * [n + 1];
       argv[0] = strsave (fcn_name);
-      for (int i = 1; i < n; i++)
-	argv[i] = strsave (args(i).string_value ());
+      for (int i = 0; i < n; i++)
+	argv[i+1] = strsave (args(i).string_value ());
     }
   else
     error ("%s: expecting all arguments to be strings", fcn_name);
 
   return argv;
 }
 
 int
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -162,35 +162,37 @@ is_valid_function (const tree_constant& 
 }
 
 // Does this function take the right number of arguments?
 
 int
 takes_correct_nargs (tree_fvc *fcn, int expected_nargin, char *warn_for,
 		     int warn)
 {
-  int nargin = fcn->max_expected_args () - 1;
-  int e_nargin = expected_nargin - 1;
+  int nargin = fcn->max_expected_args ();
+  int e_nargin = expected_nargin;
   if (nargin != e_nargin)
     {
       if (warn)
 	error ("%s: expecting function to take %d argument%c", 
 	       warn_for, e_nargin, (e_nargin == 1 ? "" : "s"));
       return 0;
     }
   return 1;
 }
 
-DEFUN ("is_global", Fis_global, Sis_global, 2, 1,
+DEFUN ("is_global", Fis_global, Sis_global, 1, 1,
   "is_global (X): return 1 if the string X names a global variable\n\
 otherwise, return 0.")
 {
   Octave_object retval = 0.0;
 
-  if (args.length () != 2)
+  int nargin = args.length ();
+
+  if (nargin != 1)
     {
       print_usage ("is_global");
       return retval;
     }
 
   char *name = args(1).string_value ();
 
   if (error_state)
@@ -201,25 +203,27 @@ otherwise, return 0.")
 
   symbol_record *sr = curr_sym_tab->lookup (name, 0, 0);
 
   retval = (double) (sr && sr->is_linked_to_global ());
 
   return retval;
 }
 
-DEFUN ("exist", Fexist, Sexist, 2, 1,
+DEFUN ("exist", Fexist, Sexist, 1, 1,
   "exist (NAME): check if variable or file exists\n\
 \n\
 return 0 if NAME is undefined, 1 if it is a variable, or 2 if it is\n\
 a function.") 
 {
   Octave_object retval;
 
-  if (args.length () != 2)
+  int nargin = args.length ();
+
+  if (nargin != 1)
     {
       print_usage ("exist");
       return retval;
     }
 
   char *name = args(1).string_value ();
 
   if (error_state)
@@ -1136,20 +1140,23 @@ character, but may not be combined.")
 DEFUN_TEXT ("whos", Fwhos, Swhos, -1, 1,
   "whos [-all] [-builtins] [-functions] [-long] [-variables]\n\
 \n\
 List currently defined symbol(s).  Options may be shortened to one\n\
 character, but may not be combined.")
 {
   Octave_object retval;
 
+  int nargin = args.length ();
+
   Octave_object tmp_args = args;
-  tmp_args(args.length ()) = "-long";
 
-  int argc = tmp_args.length ();
+  tmp_args(nargin) = "-long";
+
+  int argc = nargin + 1;
   char **argv = make_argv (tmp_args, "whos");
 
   if (error_state)
     return retval;
 
   retval = do_who (argc, argv, nargout);
 
   while (--argc >= 0)
@@ -1255,17 +1262,17 @@ alias_builtin (const char *alias, const 
 void
 bind_nargin_and_nargout (symbol_table *sym_tab, int nargin, int nargout)
 {
   tree_constant *tmp;
   symbol_record *sr;
 
   sr = sym_tab->lookup ("nargin", 1, 0);
   sr->unprotect ();
-  tmp = new tree_constant (nargin-1);
+  tmp = new tree_constant (nargin);
   sr->define (tmp);
   sr->protect ();
 
   sr = sym_tab->lookup ("nargout", 1, 0);
   sr->unprotect ();
   tmp = new tree_constant (nargout);
   sr->define (tmp);
   sr->protect ();
