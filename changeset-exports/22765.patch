# HG changeset patch
# User Rik <rik@octave.org>
# Date 1479164141 28800
#      Mon Nov 14 14:55:41 2016 -0800
# Node ID 01aae08a01055000746111cdc816f969a3a5f98b
# Parent  d261dcd73dcf3916dc31d99c990e0366a12dc795
maint: Rename variables to match documentation in m-files.

* fminbnd.m, javaclasspath.m, ls_command.m, isprop.m, roots.m, bicg.m, cgs.m,
qmr.m, dump_demos.m:
Rename variables in function to match documentation.

* normest1.m, AbsRel_norm.m, colstyle.m, frame2im.m, rotate.m:
Rename variables in documentation to match function.

* recycle.m: Rename variable 'state' to 'val' in documentation, and then
throughout code.

* untabify.m: Rename variable 'dblank' to 'deblank_arg'.

* speed.m: Add comment about why variable names can't match documentation.

diff --git a/scripts/general/interp1.m b/scripts/general/interp1.m
--- a/scripts/general/interp1.m
+++ b/scripts/general/interp1.m
@@ -361,17 +361,17 @@ function yi = interp1 (x, y, varargin)
         y = shiftdim (y, 1);
         yi = spline (x, y, reshape (xi, szx));
         if (! isvector (y))
           yi = shiftdim (yi, 1);
         endif
       endif
 
     otherwise
-      error ("interp1: invalid METHOD '%s'", METHOD);
+      error ("interp1: invalid METHOD '%s'", method);
 
   endswitch
 
   if (! ispp && isnumeric (extrap))
     ## determine which values are out of range and set them to extrap,
     ## unless extrap == "extrap".
     minx = min (x(1), x(nx));
     maxx = max (x(1), x(nx));
@@ -788,10 +788,10 @@ endfunction
 %!error <minimum of 2 points required> interp1 (1,1,1, "*linear")
 %!error <minimum of 2 points required> interp1 (1,1,1, "previous")
 %!error <minimum of 2 points required> interp1 (1,1,1, "*previous")
 %!warning <multiple discontinuities> interp1 ([1 1 1 2], [1 2 3 4], 1);
 %!error <discontinuities not supported> interp1 ([1 1],[1 2],1, "next")
 %!error <discontinuities not supported> interp1 ([1 1],[1 2],1, "pchip")
 %!error <discontinuities not supported> interp1 ([1 1],[1 2],1, "cubic")
 %!error <discontinuities not supported> interp1 ([1 1],[1 2],1, "spline")
-%!error <invalid method 'invalid'> interp1 (1:2,1:2,1, "invalid")
+%!error <invalid METHOD 'invalid'> interp1 (1:2,1:2,1, "invalid")
 
diff --git a/scripts/general/randi.m b/scripts/general/randi.m
--- a/scripts/general/randi.m
+++ b/scripts/general/randi.m
@@ -204,10 +204,10 @@ endfunction
 %!error <must be integer bounds> randi (1.5)
 %!error <must be integer bounds> randi ([1.5, 2.5])
 %!error <must be integer bounds> randi ([1, 2.5])
 %!error <must be integer bounds> randi ([1.5, 2])
 %!error <require IMAX .= 1> randi (0)
 %!error <require IMIN <= IMAX> randi ([10, 1])
 %!error <IMIN and IMAX must be smaller than flintmax\(\)> randi (flintmax ())
 %!error <range must be smaller than flintmax\(\)-1> randi ([-1, flintmax() - 1])
-%!error <unknown requested output class 'foo'> randi (10, "foo")
+%!error <unknown requested output CLASS 'foo'> randi (10, "foo")
 
diff --git a/scripts/image/rgbplot.m b/scripts/image/rgbplot.m
--- a/scripts/image/rgbplot.m
+++ b/scripts/image/rgbplot.m
@@ -85,10 +85,10 @@ endfunction
 %! subplot (1, 2, 2);
 %!  rgbplot (ocean, "composite");
 
 ## Test input validation
 %!error rgbplot ()
 %!error rgbplot (1,2)
 %!error <CMAP must be a valid colormap> rgbplot ({0 1 0})
 %!error <STYLE must be a string> rgbplot ([0 1 0], 2)
-%!error <unknown style 'nostyle'> rgbplot ([0 1 0], "nostyle")
+%!error <unknown STYLE 'nostyle'> rgbplot ([0 1 0], "nostyle")
 
diff --git a/scripts/java/javachk.m b/scripts/java/javachk.m
--- a/scripts/java/javachk.m
+++ b/scripts/java/javachk.m
@@ -143,10 +143,10 @@ endfunction
 
 %!testif HAVE_JAVA
 %! if (! usejava ("jvm"))
 %!   return;
 %! endif
 %! assert (javachk ("jvm"), "");
 
 ## Test input validation
-%!error <javachk: unrecognized feature 'foobar'> javachk ("foobar")
+%!error <javachk: unrecognized FEATURE 'foobar'> javachk ("foobar")
 
diff --git a/scripts/java/javaclasspath.m b/scripts/java/javaclasspath.m
--- a/scripts/java/javaclasspath.m
+++ b/scripts/java/javaclasspath.m
@@ -49,17 +49,17 @@
 ## Return the static classpath.
 ##
 ## @item @qcode{"-all"}
 ## Return both the static and dynamic classpath in a single cellstr.
 ## @end table
 ## @seealso{javaaddpath, javarmpath}
 ## @end deftypefn
 
-function [path1, path2] = javaclasspath (which)
+function [path1, path2] = javaclasspath (what = "")
 
   if (nargin > 1)
     print_usage ();
   endif
 
   ## dynamic classpath
   dynamic_path = javaMethod ("getClassPath", "org.octave.ClassHelper");
   dynamic_path_list = ostrsplit (dynamic_path, pathsep ());
@@ -72,19 +72,19 @@ function [path1, path2] = javaclasspath 
     ## remove first element (which is .../octave.jar)
     static_path_list(1) = [];
   else
     static_path_list = {};
   endif
 
   if (nargout == 0)
     if (! nargin)
-      which = "-all";
+      what = "-all";
     endif
-    switch (tolower (which))
+    switch (tolower (what))
       case "-dynamic", disp_path_list ("DYNAMIC", dynamic_path_list);
       case "-static",  disp_path_list ("STATIC", static_path_list);
       case "-all"
         disp_path_list ("STATIC", static_path_list);
         disp ("");
         disp_path_list ("DYNAMIC", dynamic_path_list);
       otherwise
         error ("javaclasspath: invalid value for WHAT");
@@ -93,31 +93,31 @@ function [path1, path2] = javaclasspath 
   else
     if (! nargin)
       ## This is to allow retrieval of both paths in separate variables with
       ## a single call to javaclasspath().  Matlab returns only the -dynamic
       ## path in this case but this won't break compatibility.
       path1 = cellstr (dynamic_path_list);
       path2 = cellstr (static_path_list);
     else
-      switch (tolower (which))
+      switch (tolower (what))
         case "-all",     path1 = cellstr ([static_path_list,dynamic_path_list]);
         case "-dynamic", path1 = cellstr (dynamic_path_list);
         case "-static",  path1 = cellstr (static_path_list);
         otherwise
           error ("javaclasspath: invalid value for WHAT");
       endswitch
     endif
   endif
 
 endfunction
 
 ## Display cell array of paths
 
-function disp_path_list (which, path_list)
-  printf ("   %s JAVA PATH\n\n", which);
+function disp_path_list (what, path_list)
+  printf ("   %s JAVA PATH\n\n", what);
   if (numel (path_list) > 0)
     printf ("      %s\n", path_list{:});
   else
     printf ("      - empty -\n");
   endif
 endfunction
 
diff --git a/scripts/java/usejava.m b/scripts/java/usejava.m
--- a/scripts/java/usejava.m
+++ b/scripts/java/usejava.m
@@ -90,10 +90,10 @@ endfunction
 %!   return;
 %! endif
 %! assert (usejava ("jvm"), true);
 
 ## Test input validation
 %!error usejava ()
 %!error usejava (1, 2)
 %!error usejava (1)
-%!error <unrecognized feature> usejava ("abc")
+%!error <unrecognized FEATURE> usejava ("abc")
 
diff --git a/scripts/linear-algebra/normest1.m b/scripts/linear-algebra/normest1.m
--- a/scripts/linear-algebra/normest1.m
+++ b/scripts/linear-algebra/normest1.m
@@ -12,97 +12,97 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {} {@var{c} =} normest1 (@var{a})
-## @deftypefnx {} {@var{c} =} normest1 (@var{a}, @var{t})
-## @deftypefnx {} {@var{c} =} normest1 (@var{a}, @var{t}, @var{x0})
-## @deftypefnx {} {@var{c} =} normest1 (@var{afun}, @var{t}, @var{x0}, @var{p1}, @var{p2}, @dots{})
-## @deftypefnx {} {[@var{c}, @var{v}] =} normest1 (@var{a}, @dots{})
-## @deftypefnx {} {[@var{c}, @var{v}, @var{w}] =} normest1 (@var{a}, @dots{})
-## @deftypefnx {} {[@var{c}, @var{v}, @var{w}, @var{it}] =} normest1 (@var{a}, @dots{})
-## Estimate the 1-norm of the matrix @var{a} using a block algorithm.
+## @deftypefn  {} {@var{c} =} normest1 (@var{A})
+## @deftypefnx {} {@var{c} =} normest1 (@var{A}, @var{t})
+## @deftypefnx {} {@var{c} =} normest1 (@var{A}, @var{t}, @var{x0})
+## @deftypefnx {} {@var{c} =} normest1 (@var{Afun}, @var{t}, @var{x0}, @var{p1}, @var{p2}, @dots{})
+## @deftypefnx {} {[@var{c}, @var{v}] =} normest1 (@var{A}, @dots{})
+## @deftypefnx {} {[@var{c}, @var{v}, @var{w}] =} normest1 (@var{A}, @dots{})
+## @deftypefnx {} {[@var{c}, @var{v}, @var{w}, @var{it}] =} normest1 (@var{A}, @dots{})
+## Estimate the 1-norm of the matrix @var{A} using a block algorithm.
 ##
-## For a medium size matrix @var{a}, @code{norm (@var{a}, 1)} should be
+## For a medium size matrix @var{A}, @code{norm (@var{A}, 1)} should be
 ## used instead.  For a large sparse matrix, when only an estimate of the norm
-## is needed, @code{normest1 (@var{a})} might be faster.  Moreover, it can be
+## is needed, @code{normest1 (@var{A})} might be faster.  Moreover, it can be
 ## used for the estimate of the 1-norm of a linear
-## operator @var{a} when matrix-vector products @code{@var{a} * @var{x}} and
-## @code{@var{a}' * @var{x}} can be cheaply computed.  In this case,
-## instead of the matrix @var{a}, a function
-## @code{@var{afun} (@var{flag}, @var{x})} can be used.  It should return:
+## operator @var{A} when matrix-vector products @code{@var{A} * @var{x}} and
+## @code{@var{A}' * @var{x}} can be cheaply computed.  In this case,
+## instead of the matrix @var{A}, a function
+## @code{@var{Afun} (@var{flag}, @var{x})} can be used.  It should return:
 ##
 ## @itemize @bullet
 ## @item
-## the dimension @var{n} of @var{a}, if @var{flag} is @qcode{"dim"}
+## the dimension @var{n} of @var{A}, if @var{flag} is @qcode{"dim"}
 ##
 ## @item
-## true if @var{a} is a real operator, if @var{flag} is @qcode{"real"}
+## true if @var{A} is a real operator, if @var{flag} is @qcode{"real"}
 ##
 ## @item
-## the result @code{@var{a} * @var{x}}, if @var{flag} is @qcode{"notransp"}
+## the result @code{@var{A} * @var{x}}, if @var{flag} is @qcode{"notransp"}
 ##
 ## @item
-## the result @code{@var{a}' * @var{x}}, if @var{flag} is @qcode{"transp"}
+## the result @code{@var{A}' * @var{x}}, if @var{flag} is @qcode{"transp"}
 ## @end itemize
 ##
-## A typical case is @var{a} defined by @code{@var{b} ^ @var{m}},
-## in which the result @code{@var{a} * @var{x}} can be computed without
+## A typical case is @var{A} defined by @code{@var{b} ^ @var{m}},
+## in which the result @code{@var{A} * @var{x}} can be computed without
 ## even forming explicitly @code{@var{b} ^ @var{m}} by:
 ##
 ## @example
 ## @group
 ## @var{y} = @var{x};
 ## for @var{i} = 1:@var{m}
 ##   @var{y} = @var{b} * @var{y};
 ## endfor
 ## @end group
 ## @end example
 ##
 ## The parameters @var{p1}, @var{p2}, @dots{} are arguments of
-## @code{@var{afun} (@var{flag}, @var{x}, @var{p1}, @var{p2}, @dots{})}.
+## @code{@var{Afun} (@var{flag}, @var{x}, @var{p1}, @var{p2}, @dots{})}.
 ##
 ## The default value for @var{t} is 2. The algorithm requires
 ## matrix-matrix products with sizes @var{n} x @var{n} and
 ## @var{n} x @var{t}.
 ##
 ## The initial matrix @var{x0} should have columns of unit 1-norm.
 ## The default initial matrix @var{x0} has the first column
 ## @code{ones (@var{n}, 1) / @var{n}}
 ## and, if @var{t} >  1, the remaining columns with random elements
 ## @code{-1 / @var{n}}, @code{1 / @var{n}}, divided by @var{n}.
 ## Therefore, if consistent results are required, the @qcode{"state"} of the
 ## random generator should be fixed before invoking @code{normest1}.
 ##
 ## On output, @var{c} is the desired estimate, @var{v} and @var{w}
-## vectors such that @code{@var{w} = @var{a} * @var{v}}, with
+## vectors such that @code{@var{w} = @var{A} * @var{v}}, with
 ## @code{norm (@var{w}, 1)} = @code{@var{c} * norm (@var{v}, 1)}.
 ## @var{it} contains in @code{@var{it}(1)} the number of iterations
 ## (the maximum number is hardcoded to 5) and in  @code{@var{it}(2)}
-## the total number of products @code{@var{a} * @var{x}} or
-## @code{@var{a}' * @var{x}} performed by the algorithm.
+## the total number of products @code{@var{A} * @var{x}} or
+## @code{@var{A}' * @var{x}} performed by the algorithm.
 ##
 ## Reference: @nospell{N. J. Higham and F. Tisseur},
 ## @cite{A block algorithm for matrix 1-norm estimation, with and
 ## application to 1-norm @nospell{pseudospectra}},
 ## @nospell{SIAM J. Matrix Anal. Appl.},
 ## pp. 1185--1201, Vol 21, No. 4, 2000.
 ##
 ## @seealso{normest, rand}
 ## @end deftypefn
 
 ## Ideally, we would set t and X to their default values but Matlab
 ## compatibility would require we set the default even when they are
 ## empty.
-function [est, v, w, k] = normest1 (A, t = [], X = [], varargin)
+function [est, v, w, k] = normest1 (A, t = [], x0 = [], varargin)
 
   if (nargin < 1)
     print_usage ();
   endif
 
   if (isempty (t))
     t = 2;
   endif
@@ -132,32 +132,34 @@ function [est, v, w, k] = normest1 (A, t
     Afun = @(x) A ("notransp", x, varargin{:});
     A1fun = @(x) A ("transp", x, varargin{:});
   else
     error ("normest1: A must be a square matrix or a function handle");
   endif
 
   t = min (t, n);
 
-  if (isempty (X))
+  if (isempty (x0))
     X = [ones(n, 1), sign(2 * rand(n, t - 1) - 1)];
     i = 2;
     imax = min (t, 2 ^ (n - 1));
     ## There are at most 2^(n-1) unparallel columns, see later.
     while (i <= imax)
       if (any (abs (X(:,i)' * X(:,1:i-1)) == n))
         ## column i is parallel to a colum 1:i-1. Change it.
         X(:,i) = sign (2 * rand (n, 1) - 1);
       else
         i++;
       endif
     endwhile
     X /= n;
-  elseif (columns (X) < t)
+  elseif (columns (x0) < t)
     error ("normest1: X should have %d columns", t);
+  else
+    X = x0;
   endif
 
   itmax = 5;
   ind_hist = zeros (n, 1);
   est_old = 0;
   ind = zeros (n, 1);
   S = zeros (n, t);
   k = [0; 0];
@@ -240,18 +242,20 @@ function [est, v, w, k] = normest1 (A, t
       endif
       X = zeros (n, tmax);
       X(sub2ind (size (X), ind(1:tmax), (1:tmax)')) = 1;
       ind_hist(ind(1:tmax)) = 1;
     endif
   endwhile
   v = zeros (n, 1);
   v(ind_best) = 1;
+
 endfunction
 
+
 %!function z = afun_A (flag, x, A, n)
 %!  switch flag
 %!  case {"dim"}
 %!    z = n;
 %!  case {"real"}
 %!    z = isreal (A);
 %!  case {"transp"}
 %!    z = A' * x;
@@ -365,8 +369,9 @@ endfunction
 %! end_unwind_protect
 
 ## Check IT is always a column vector.
 %!test
 %! [~, ~, ~, it] = normest1 (rand (3), 3);
 %! assert (iscolumn (it))
 %! [~, ~, ~, it] = normest1 (rand (50), 20);
 %! assert (iscolumn (it))
+
diff --git a/scripts/miscellaneous/ls_command.m b/scripts/miscellaneous/ls_command.m
--- a/scripts/miscellaneous/ls_command.m
+++ b/scripts/miscellaneous/ls_command.m
@@ -20,40 +20,40 @@
 ## @deftypefn  {} {@var{val} =} ls_command ()
 ## @deftypefnx {} {@var{old_val} =} ls_command (@var{new_val})
 ## Query or set the shell command used by Octave's @code{ls} command.
 ## @seealso{ls}
 ## @end deftypefn
 
 ## Author: jwe
 
-function old_cmd = ls_command (cmd)
+function old_val = ls_command (new_val)
 
   global __ls_command__;
 
   if (isempty (__ls_command__))
     ## MinGW uses different ls_command
     if (ispc () && ! isunix ()
         && isempty (file_in_path (getenv ("PATH"), "ls")))
       __ls_command__ = "dir /D";
     else
       __ls_command__ = "ls -C";
     endif
   endif
 
   if (nargin == 0 || nargin == 1)
 
-    old_cmd = __ls_command__;
+    old_val = __ls_command__;
 
     if (nargin == 1)
-      if (ischar (cmd))
-        __ls_command__ = cmd;
-      else
+      if (! ischar (new_val))
         error ("ls_command: argument must be a character string");
       endif
+
+      __ls_command__ = new_val;
     endif
 
   endif
 
 endfunction
 
 
 %!test
diff --git a/scripts/miscellaneous/recycle.m b/scripts/miscellaneous/recycle.m
--- a/scripts/miscellaneous/recycle.m
+++ b/scripts/miscellaneous/recycle.m
@@ -12,62 +12,62 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {} {@var{current_state} =} recycle ()
-## @deftypefnx {} {@var{old_state} =} recycle (@var{new_state})
+## @deftypefn  {} {@var{val} =} recycle ()
+## @deftypefnx {} {@var{old_val} =} recycle (@var{new_val})
 ## Query or set the preference for recycling deleted files.
 ##
 ## When recycling is enabled, commands which would permanently erase files
 ## instead move them to a temporary location (such as the directory labeled
 ## Trash).
 ##
 ## Programming Note: This function is provided for @sc{matlab} compatibility,
 ## but recycling is not implemented in Octave.  To help avoid accidental data
 ## loss an error will be raised if an attempt is made to enable file recycling.
 ## @seealso{delete, rmdir}
 ## @end deftypefn
 
 ## Author: jwe
 
-function retval = recycle (state)
+function val = recycle (new_val)
 
   persistent current_state = "off";
 
   if (nargin > 1)
     print_usage ();
   endif
 
   if (nargin == 0 || nargout > 0)
-    retval = current_state;
+    val = current_state;
   endif
 
   if (nargin == 1)
-    if (! ischar (state))
-      error ("recycle: STATE must be a character string");
+    if (! ischar (new_val))
+      error ("recycle: NEW_VAL must be a character string");
     endif
 
-    if (strcmpi (state, "on"))
+    if (strcmpi (new_val, "on"))
       error ("recycle: recycling files is not implemented");
-    elseif (strcmpi (state, "off"))
+    elseif (strcmpi (new_val, "off"))
       current_state = "off";
     else
-      error ("recycle: invalid value of STATE = '%s'", state);
+      error ("recycle: invalid value '%s'", new_val);
     endif
   endif
 
 endfunction
 
 
 %!test
 %! recycle ("off");
 %! assert (recycle ("off"), "off");
 
 %!error recycle ("on", "and I mean it")
-%!error <STATE must be a character string> recycle (1)
+%!error <NEW_VAL must be a character string> recycle (1)
 %!error <recycling files is not implemented> recycle ("on")
-%!error <invalid value of STATE = 'foobar'> recycle ("foobar")
+%!error <invalid value 'foobar'> recycle ("foobar")
 
diff --git a/scripts/miscellaneous/unpack.m b/scripts/miscellaneous/unpack.m
--- a/scripts/miscellaneous/unpack.m
+++ b/scripts/miscellaneous/unpack.m
@@ -337,19 +337,19 @@ endfunction
 %!   confirm_recursive_rmdir (false, "local");
 %!   rmdir (dirname, "s");
 %! end_unwind_protect
 
 ## Test input validation
 %!error unpack ()
 %!error unpack (1,2,3,4)
 %!error <FILE must be a string or cell array of strings> unpack (1)
-%!error <file "_%NOT_A_FILENAME%_" not found> unpack ("_%NOT_A_FILENAME%_")
-%!error <file "_%NOT_A_FILENAME%_" not found> unpack ({"_%NOT_A_FILENAME%_"})
-%!error <file "_%NOT_A_FILENAME%_" not found> unpack ({"_%NOT_A_FILENAME%_", "2nd_filename"})
+%!error <FILE "_%NOT_A_FILENAME%_" not found> unpack ("_%NOT_A_FILENAME%_")
+%!error <FILE "_%NOT_A_FILENAME%_" not found> unpack ({"_%NOT_A_FILENAME%_"})
+%!error <FILE "_%NOT_A_FILENAME%_" not found> unpack ({"_%NOT_A_FILENAME%_", "2nd_filename"})
 %!error <FILETYPE must be given for a directory>
 %! if (isunix || ismac)
 %!   unpack ("/");
 %! else
 %!   unpack ('C:\');
 %! endif
 %!error <FILETYPE must be "gunzip" for a directory>
 %! if (isunix || ismac)
diff --git a/scripts/ode/private/AbsRel_norm.m b/scripts/ode/private/AbsRel_norm.m
--- a/scripts/ode/private/AbsRel_norm.m
+++ b/scripts/ode/private/AbsRel_norm.m
@@ -13,17 +13,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {} {retval =} AbsRel_norm (@var{x}, @var{x_old}, @var{AbsTol}, @var{RelTol}, @var{normcoontrol}, @var{y})
+## @deftypefn {} {retval =} AbsRel_norm (@var{x}, @var{x_old}, @var{AbsTol}, @var{RelTol}, @var{normcontrol}, @var{y})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function retval = AbsRel_norm (x, x_old, AbsTol, RelTol, normcontrol, y = zeros (size (x)))
 
   n = numel (x);
 
   sc = AbsTol + max (abs (x), abs (x_old)) .* RelTol;
diff --git a/scripts/optimization/fminbnd.m b/scripts/optimization/fminbnd.m
--- a/scripts/optimization/fminbnd.m
+++ b/scripts/optimization/fminbnd.m
@@ -55,30 +55,30 @@
 
 ## This is patterned after opt/fmin.f from Netlib, which in turn is taken from
 ## Richard Brent: Algorithms For Minimization Without Derivatives,
 ## Prentice-Hall (1973)
 
 ## PKG_ADD: ## Discard result to avoid polluting workspace with ans at startup.
 ## PKG_ADD: [~] = __all_opts__ ("fminbnd");
 
-function [x, fval, info, output] = fminbnd (fun, xmin, xmax, options = struct ())
+function [x, fval, info, output] = fminbnd (fun, a, b, options = struct ())
 
   ## Get default options if requested.
   if (nargin == 1 && ischar (fun) && strcmp (fun, 'defaults'))
     x = optimset ("MaxIter", Inf, "MaxFunEvals", Inf, "TolX", 1e-8,
                   "OutputFcn", [], "FunValCheck", "off");
     return;
   endif
 
   if (nargin < 2 || nargin > 4)
     print_usage ();
   endif
 
-  if (xmin > xmax)
+  if (a > b)
     error ("Octave:invalid-input-arg",
            "fminbnd: the lower bound cannot be greater than the upper one");
   endif
 
   if (ischar (fun))
     fun = str2func (fun, "global");
   endif
 
@@ -95,24 +95,23 @@ function [x, fval, info, output] = fminb
   endif
 
   ## The default exit flag if exceeded number of iterations.
   info = 0;
   niter = 0;
   nfev = 0;
 
   c = 0.5*(3 - sqrt (5));
-  a = xmin; b = xmax;
   v = a + c*(b-a);
   w = x = v;
   e = 0;
   fv = fw = fval = fun (x);
   nfev += 1;
 
-  if (isa (xmin, "single") || isa (xmax, "single") || isa (fval, "single"))
+  if (isa (a, "single") || isa (b, "single") || isa (fval, "single"))
     sqrteps = eps ("single");
   else
     sqrteps = eps ("double");
   endif
 
   ## Only for display purposes.
   iter(1).funccount = nfev;
   iter(1).x = x;
diff --git a/scripts/pkg/private/describe.m b/scripts/pkg/private/describe.m
--- a/scripts/pkg/private/describe.m
+++ b/scripts/pkg/private/describe.m
@@ -17,18 +17,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {[@var{pkg_desc_list}, @var{flag}] =} describe (@var{pkgnames}, @var{verbose}, @var{local_list}, @var{global_list})
 ## Undocumented internal function.
 ## @end deftypefn
 
-function [pkg_desc_list, flag] = describe (pkgnames, verbose,
-                                           local_list, global_list)
+function [pkg_desc_list, flag] = describe (pkgnames, verbose, local_list, global_list)
 
   ## Get the list of installed packages.
   installed_pkgs_lst = installed_packages(local_list, global_list);
   num_packages = length (installed_pkgs_lst);
 
   if (isempty (pkgnames))
     describe_all = true;
     flag(1:num_packages) = {"Not Loaded"};
diff --git a/scripts/plot/appearance/annotation.m b/scripts/plot/appearance/annotation.m
--- a/scripts/plot/appearance/annotation.m
+++ b/scripts/plot/appearance/annotation.m
@@ -1520,15 +1520,15 @@ endfunction
 %!   assert (ancestor (h, "figure"), hf1);
 %!   assert (gcf (), hf2);
 %! unwind_protect_cleanup
 %!   close (hf1);
 %!   close (hf2);
 %! end_unwind_protect
 
 ## Test input validation
-%!error <unknown annotation type foo> annotation ("foo")
+%!error <unknown annotation TYPE foo> annotation ("foo")
 %!error annotation ([], "foo")
 %!error annotation ({})
 %!error annotation ("line", [.5 .6])
 %!error <X and Y must be 2-element vectors> annotation ("line", 1:3, 1:3)
 %!error <POS must be a 4-element vector> annotation ("textbox", 1:3)
 
diff --git a/scripts/plot/util/colstyle.m b/scripts/plot/util/colstyle.m
--- a/scripts/plot/util/colstyle.m
+++ b/scripts/plot/util/colstyle.m
@@ -12,18 +12,19 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {} {[@var{style}, @var{color}, @var{marker}, @var{msg}] =} colstyle (@var{linespec})
-## Parse @var{linespec} and return the line style, color, and markers given.
+## @deftypefn {} {[@var{style}, @var{color}, @var{marker}, @var{msg}] =} colstyle (@var{style})
+## Parse the line specification @var{style} and return the line style, color,
+## and markers given.
 ##
 ## In the case of an error, the string @var{msg} will return the text of the
 ## error.
 ## @end deftypefn
 
 function [l, c, m, msg] = colstyle (style)
 
   if (nargin != 1)
diff --git a/scripts/plot/util/frame2im.m b/scripts/plot/util/frame2im.m
--- a/scripts/plot/util/frame2im.m
+++ b/scripts/plot/util/frame2im.m
@@ -12,23 +12,23 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {} {[@var{x}, @var{map}] =} frame2im (@var{f})
+## @deftypefn {} {[@var{x}, @var{map}] =} frame2im (@var{frame})
 ## Convert movie frame to indexed image.
 ##
 ## A movie frame is simply a struct with the fields @qcode{"cdata"} and
 ## @qcode{"colormap"}.
 ##
-## Support for N-dimensional images or movies is given when @var{f} is a
+## Support for N-dimensional images or movies is given when @var{frame} is a
 ## struct array.  In such cases, @var{x} will be a @nospell{MxNx1xK or MxNx3xK}
 ## for indexed and RGB movies respectively, with each frame concatenated
 ## along the 4th dimension.
 ##
 ## @seealso{im2frame}
 ## @end deftypefn
 
 ## Author: Carnë Draug <carandraug@octave.org>
diff --git a/scripts/plot/util/isprop.m b/scripts/plot/util/isprop.m
--- a/scripts/plot/util/isprop.m
+++ b/scripts/plot/util/isprop.m
@@ -25,41 +25,41 @@
 ##
 ## For plotting, @var{obj} is a handle to a graphics object.  Otherwise,
 ## @var{obj} should be an instance of a class.
 ## @seealso{get, set, ismethod, isobject}
 ## @end deftypefn
 
 ## Author: Ben Abbott  <bpabbott@mac.com>
 
-function res = isprop (h, prop)
+function res = isprop (obj, prop)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  if (! all (ishandle (h)))
-    error ("isprop: H must be a graphics handle or vector of handles");
+  if (! all (ishandle (obj)))
+    error ("isprop: OBJ must be a graphics handle, vector of handles, or instance of a class");
   elseif (! ischar (prop))
     error ("isprop: PROP name must be a string");
   endif
 
-  res = false (size (h));
+  res = false (size (obj));
   for i = 1:numel (res)
     try
-      v = get (h(i), prop);
+      v = get (obj(i), prop);
       res(i) = true;
     end_try_catch
   endfor
 
 endfunction
 
 
 %!assert (isprop (0, "foobar"), false)
 %!assert (isprop (0, "screenpixelsperinch"), true)
 %!assert (isprop (zeros (2, 3), "visible"), true (2, 3))
 
 %!error isprop ()
 %!error isprop (1)
 %!error isprop (1,2,3)
-%!error <H must be a graphics handle> isprop ({1}, "visible")
+%!error <OBJ must be a graphics handle> isprop ({1}, "visible")
 %!error <PROP name must be a string> isprop (0, {"visible"})
 
diff --git a/scripts/plot/util/rotate.m b/scripts/plot/util/rotate.m
--- a/scripts/plot/util/rotate.m
+++ b/scripts/plot/util/rotate.m
@@ -12,20 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {} {} rotate (@var{h}, @var{dir}, @var{alpha})
+## @deftypefn  {} {} rotate (@var{h}, @var{direction}, @var{alpha})
 ## @deftypefnx {} {} rotate (@dots{}, @var{origin})
 ## Rotate the plot object @var{h} through @var{alpha} degrees around the line
-## with direction @var{dir} and origin @var{origin}.
+## with direction @var{direction} and origin @var{origin}.
 ##
 ## The default value of @var{origin} is the center of the axes object that is
 ## the parent of @var{h}.
 ##
 ## If @var{h} is a vector of handles, they must all have the same parent axes
 ## object.
 ##
 ## Graphics objects that may be rotated are lines, surfaces, patches, and
@@ -175,15 +175,16 @@ endfunction
 %! o2 = line ();
 %! o3 = text (0, 0, "foobar");
 %!error rotate ()
 %!error rotate (o1)
 %!error rotate (o1, [0,0,0])
 %!error <all handles must be children of the same axes object> rotate ([o1, o2], [0,0,0], 90)
 %!error <invalid direction> rotate (o1, "foo", 90)
 %!error <invalid rotation angle> rotate (o1, [0,0,0], "foo")
-%!error <invalid origin> rotate (o1, [0,0,0], 90, "foo")
+%!error <invalid ORIGIN> rotate (o1, [0,0,0], 90, "foo")
 %!error rotate (o1, [0,0,0], 90, [0,0,0], 1)
 %!error <H must be an array of one or more graphics handles> rotate (NaN, [0,0,0], 90)
 %!error <expecting image, line, patch, or surface objects> rotate (o3, [0,0,0], 90)
 %!test
 %! close (h1);
 %! close (h2);
+
diff --git a/scripts/polynomial/roots.m b/scripts/polynomial/roots.m
--- a/scripts/polynomial/roots.m
+++ b/scripts/polynomial/roots.m
@@ -74,45 +74,45 @@
 ## @end ifnottex
 ## @seealso{poly, compan, fzero}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 24 December 1993
 ## Adapted-By: jwe
 
-function r = roots (v)
+function r = roots (c)
 
-  if (nargin != 1 || (! isvector (v) && ! isempty (v)))
+  if (nargin != 1 || (! isvector (c) && ! isempty (c)))
     print_usage ();
-  elseif (any (! isfinite (v)))
+  elseif (any (! isfinite (c)))
     error ("roots: inputs must not contain Inf or NaN");
   endif
 
-  v = v(:);
-  n = numel (v);
+  c = c(:);
+  n = numel (c);
 
-  ## If v = [ 0 ... 0 v(k+1) ... v(k+l) 0 ... 0 ],
+  ## If c = [ 0 ... 0 c(k+1) ... c(k+l) 0 ... 0 ],
   ## we can remove the leading k zeros,
   ## and n - k - l roots of the polynomial are zero.
 
-  v_max = max (abs (v));
-  if (isempty (v) || v_max == 0)
+  c_max = max (abs (c));
+  if (isempty (c) || c_max == 0)
     r = [];
     return;
   endif
 
-  f = find (v ./ v_max);
+  f = find (c ./ c_max);
   m = numel (f);
 
-  v = v(f(1):f(m));
-  l = numel (v);
+  c = c(f(1):f(m));
+  l = numel (c);
   if (l > 1)
     A = diag (ones (1, l-2), -1);
-    A(1,:) = -v(2:l) ./ v(1);
+    A(1,:) = -c(2:l) ./ c(1);
     r = eig (A);
     if (f(m) < n)
       r = [r; zeros(n - f(m), 1)];
     endif
   else
     r = zeros (n - f(m), 1);
   endif
 
diff --git a/scripts/prefs/addpref.m b/scripts/prefs/addpref.m
--- a/scripts/prefs/addpref.m
+++ b/scripts/prefs/addpref.m
@@ -83,21 +83,21 @@ endfunction
 %!   addpref ("group1", "pref1", [1 2 3]);
 %!   assert (getpref ("group1", "pref1"), [1 2 3]);
 %!
 %!   addpref ("group2", {"prefA", "prefB"}, {"StringA", {"StringB"}});
 %!   assert (getpref ("group2", "prefA"), "StringA");
 %!   assert (getpref ("group2", "prefB"), {"StringB"});
 %!
 %!   fail ('addpref ("group1", "pref1", 4)', ...
-%!         "preference pref1 already exists in group group1");
+%!         "preference pref1 already exists in GROUP group1");
 %!   fail ('setpref ("group1", {"p1", "p2"}, 1)', ...
 %!         "size mismatch for PREF and VAL");
 %!   fail ('addpref ("group2", {"prefC", "prefA"}, {1, 2})',
-%!         "preference prefA already exists in group group2");
+%!         "preference prefA already exists in GROUP group2");
 %!
 %! unwind_protect_cleanup
 %!   unlink (fullfile (P_tmpdir (), ".octave_prefs"));
 %!   if (isempty (HOME))
 %!     unsetenv ("HOME");
 %!   else
 %!     setenv ("HOME", HOME);
 %!   endif
diff --git a/scripts/prefs/getpref.m b/scripts/prefs/getpref.m
--- a/scripts/prefs/getpref.m
+++ b/scripts/prefs/getpref.m
@@ -124,26 +124,26 @@ endfunction
 %!   assert (getpref ("group3"), []);
 %!
 %!   assert (getpref ("group1", "pref1"), [1 2 3]);
 %!   assert (getpref ("group2", "prefA"), "StringA");
 %!   assert (getpref ("group2", "prefB"), {"StringB"});
 %!   assert (getpref ("group1", "pref2", "New_Value"), "New_Value");
 %!   assert (getpref ("group1", "pref2"), "New_Value");
 %!   fail ('getpref ("group1", "no_such_pref")', ...
-%!         "preference no_such_pref does not exist in group group1");
+%!         "preference no_such_pref does not exist in GROUP group1");
 %!
 %!   assert (getpref ("group2", {"prefA", "prefB"}), {"StringA", {"StringB"}});
 %!   assert (getpref ("group2", {"prefA", "prefC"}, {1, "StringC"}),
 %!           {"StringA", "StringC"});
 %!   assert (getpref ("group2", "prefC"), "StringC");
 %!   fail ('getpref ("group1", {"p1", "p2"}, 1)', ...
 %!         "size mismatch for PREF and DEFAULT");
 %!   fail ('getpref ("group2", {"prefA", "prefD"})',
-%!         "preference prefD does not exist in group group2");
+%!         "preference prefD does not exist in GROUP group2");
 %!
 %! unwind_protect_cleanup
 %!   unlink (fullfile (P_tmpdir (), ".octave_prefs"));
 %!   if (isempty (HOME))
 %!     unsetenv ("HOME");
 %!   else
 %!     setenv ("HOME", HOME);
 %!   endif
diff --git a/scripts/prefs/rmpref.m b/scripts/prefs/rmpref.m
--- a/scripts/prefs/rmpref.m
+++ b/scripts/prefs/rmpref.m
@@ -84,19 +84,19 @@ endfunction
 %!   rmpref ("group1");
 %!   assert (! ispref ("group1"));
 %!
 %!   assert (ispref ("group2", "prefB"));
 %!   rmpref ("group2", "prefB");
 %!   assert (! ispref ("group2", "prefB"));
 %!
 %!   fail ('rmpref ("group3")', ...
-%!         "group group3 does not exist");
+%!         "GROUP group3 does not exist");
 %!   fail ('rmpref ("group3", "prefA")', ...
-%!         "group group3 does not exist");
+%!         "GROUP group3 does not exist");
 %!   fail ('rmpref ("group2", "prefB")',
 %!         "preference prefB does not exist");
 %!   fail ('rmpref ("group2", {"prefA", "prefB"})',
 %!         "preference prefB does not exist");
 %!
 %! unwind_protect_cleanup
 %!   unlink (fullfile (P_tmpdir (), ".octave_prefs"));
 %!   if (isempty (HOME))
diff --git a/scripts/sparse/bicg.m b/scripts/sparse/bicg.m
--- a/scripts/sparse/bicg.m
+++ b/scripts/sparse/bicg.m
@@ -69,17 +69,17 @@
 ##
 ## @seealso{bicgstab, cgs, gmres, pcg, qmr}
 ##
 ## @end deftypefn
 
 ## Author: Sylvain Pelissier <sylvain.pelissier@gmail.com>
 ## Author: Carlo de Falco
 
-function [x, flag, res1, k, resvec] = bicg (A, b, tol, maxit, M1, M2, x0)
+function [x, flag, res1, k, resvec] = bicg (A, b, rtol, maxit, M1, M2, x0)
 
   if (nargin >= 2 && isvector (full (b)))
 
     if (ischar (A))
       fun = str2func (A);
       Ax  = @(x) feval (fun, x, "notransp");
       Atx = @(x) feval (fun, x, "transp");
     elseif (isnumeric (A) && issquare (A))
@@ -87,18 +87,18 @@ function [x, flag, res1, k, resvec] = bi
       Atx = @(x) A' * x;
     elseif (isa (A, "function_handle"))
       Ax  = @(x) feval (A, x, "notransp");
       Atx = @(x) feval (A, x, "transp");
     else
       error ("bicg: A must be a square matrix or function");
     endif
 
-    if (nargin < 3 || isempty (tol))
-      tol = 1e-6;
+    if (nargin < 3 || isempty (rtol))
+      rtol = 1e-6;
     endif
 
     if (nargin < 4 || isempty (maxit))
       maxit = min (rows (b), 20);
     else
       maxit = fix (maxit);
     endif
 
@@ -171,44 +171,44 @@ function [x, flag, res1, k, resvec] = bi
 
         d = Pm1x (r1) + beta * d;
         f = Ptm1x (s1) + conj (beta) * f;
 
         r0 = r1;
         s0 = s1;
 
         res1 = norm (b - Ax (x)) / bnorm;
-        if (res1 < tol)
+        if (res1 < rtol)
           flag = 0;
           if (nargout < 2)
             printf ("bicg converged at iteration %i ", k);
             printf ("to a solution with relative residual %e\n", res1);
           endif
           break;
         endif
 
         if (res0 <= res1)
           flag = 3;
           printf ("bicg stopped at iteration %i ", k);
-          printf ("without converging to the desired tolerance %e\n", tol);
+          printf ("without converging to the desired tolerance %e\n", rtol);
           printf ("because the method stagnated.\n");
           printf ("The iterate returned (number %i) ", k-1);
           printf ("has relative residual %e\n", res0);
           break
         endif
         res0 = res1;
         if (nargout > 4)
           resvec(k) = res0;
         endif
       endfor
 
       if (k == maxit)
         flag = 1;
         printf ("bicg stopped at iteration %i ", maxit);
-        printf ("without converging to the desired tolerance %e\n", tol);
+        printf ("without converging to the desired tolerance %e\n", rtol);
         printf ("because the maximum number of iterations was reached. ");
         printf ("The iterate returned (number %i) has ", maxit);
         printf ("relative residual %e\n", res1);
       endif
 
     else
       flag = 0;
       if (nargout < 2)
@@ -222,46 +222,46 @@ function [x, flag, res1, k, resvec] = bi
 
 endfunction;
 
 
 %!test
 %! n = 100;
 %! A = spdiags ([-2*ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
 %! b = sum (A, 2);
-%! tol = 1e-8;
+%! rtol = 1e-8;
 %! maxit = 15;
 %! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n);
 %! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n);
-%! [x, flag, relres, iter, resvec] = bicg (A, b, tol, maxit, M1, M2);
+%! [x, flag, relres, iter, resvec] = bicg (A, b, rtol, maxit, M1, M2);
 %! assert (x, ones (size (b)), 1e-7);
 
 %!function y = afun (x, t, a)
 %!  switch (t)
 %!    case "notransp"
 %!      y = a * x;
 %!    case "transp"
 %!      y = a' * x;
 %!  endswitch
 %!endfunction
 %!
 %!test
 %! n = 100;
 %! A = spdiags ([-2*ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
 %! b = sum (A, 2);
-%! tol = 1e-8;
+%! rtol = 1e-8;
 %! maxit = 15;
 %! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n);
 %! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n);
 %!
 %! [x, flag, relres, iter, resvec] = bicg (@(x, t) afun (x, t, A),
-%!                                         b, tol, maxit, M1, M2);
+%!                                         b, rtol, maxit, M1, M2);
 %! assert (x, ones (size (b)), 1e-7);
 
 %!test
 %! n = 100;
-%! tol = 1e-8;
+%! rtol = 1e-8;
 %! a = sprand (n, n, .1);
 %! A = a' * a + 100 * eye (n);
 %! b = sum (A, 2);
-%! [x, flag, relres, iter, resvec] = bicg (A, b, tol, [], diag (diag (A)));
+%! [x, flag, relres, iter, resvec] = bicg (A, b, rtol, [], diag (diag (A)));
 %! assert (x, ones (size (b)), 1e-7);
 
diff --git a/scripts/sparse/cgs.m b/scripts/sparse/cgs.m
--- a/scripts/sparse/cgs.m
+++ b/scripts/sparse/cgs.m
@@ -63,32 +63,32 @@
 ##
 ## @item @var{resvec} is a vector containing the relative residual at
 ## each iteration.
 ## @end itemize
 ##
 ## @seealso{pcg, bicgstab, bicg, gmres, qmr}
 ## @end deftypefn
 
-function [x, flag, relres, iter, resvec] = cgs (A, b, tol, maxit, M1, M2, x0)
+function [x, flag, relres, iter, resvec] = cgs (A, b, rtol, maxit, M1, M2, x0)
 
   if (nargin >= 2 && nargin <= 7 && isvector (full (b)))
 
     if (ischar (A))
       A = str2func (A);
     elseif (isnumeric (A) && issquare (A))
       Ax = @(x) A * x;
     elseif (isa (A, "function_handle"))
       Ax = @(x) feval (A, x);
     else
       error ("cgs: A must be a square matrix or function");
     endif
 
-    if (nargin < 3 || isempty (tol))
-      tol = 1e-6;
+    if (nargin < 3 || isempty (rtol))
+      rtol = 1e-6;
     endif
 
     if (nargin < 4 || isempty (maxit))
       maxit = min (rows (b), 20);
     endif
 
     if (nargin < 5 || isempty (M1))
       M1m1x = @(x) x;
@@ -123,17 +123,17 @@ function [x, flag, relres, iter, resvec]
 
     x = x0;
 
     res = b - Ax (x);
     norm_b = norm (b);
     ## Vector of the residual norms for each iteration.
     resvec = norm (res) / norm_b;
     ro = 0;
-    ## Default behavior we don't reach tolerance tol within maxit iterations.
+    ## Default behavior we don't reach tolerance rtol within maxit iterations.
     flag = 1;
     for iter = 1:maxit
 
       z = precon (res);
 
       ## Cache.
       ro_old = ro;
       ro = res' * z;
@@ -147,18 +147,18 @@ function [x, flag, relres, iter, resvec]
       q = Ax (p);
       alpha = ro / (p' * q);
       x += alpha * p;
 
       res -= alpha * q;
       relres = norm (res) / norm_b;
       resvec = [resvec; relres];
 
-      if (relres <= tol)
-        ## We reach tolerance tol within maxit iterations.
+      if (relres <= rtol)
+        ## We reach tolerance rtol within maxit iterations.
         flag = 0;
         break
       elseif (resvec(end) == resvec(end - 1))
         ## The method stagnates.
         flag = 3;
         break
       endif
     endfor
@@ -166,22 +166,22 @@ function [x, flag, relres, iter, resvec]
     if (nargout < 1)
       if (flag == 0)
         printf ("cgs converged at iteration %i to a solution with relative residual %e\n",
                 iter, relres);
       elseif (flag == 3)
         printf (["cgs stopped at iteration %i without converging to the desired tolerance %e\n",
                  "because the method stagnated.\n",
                  "The iterate returned (number %i) has relative residual %e\n"],
-                iter, tol, iter, relres);
+                iter, rtol, iter, relres);
       else
         printf (["cgs stopped at iteration %i without converging to the desired tolerance %e\n",
                  "because the maximum number of iterations was reached.\n",
                  "The iterate returned (number %i) has relative residual %e\n"],
-                iter, tol, iter, relres);
+                iter, rtol, iter, relres);
       endif
     endif
 
   else
     print_usage ();
   endif
 
 endfunction
@@ -194,30 +194,30 @@ endfunction
 %! [a,b,c,d,e] = cgs (A,b)
 
 %!shared A, b, n, M
 %!
 %!test
 %! n = 100;
 %! A = spdiags ([-ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
 %! b = sum (A, 2);
-%! tol = 1e-8;
+%! rtol = 1e-8;
 %! maxit = 1000;
 %! M = 4*eye (n);
-%! [x, flag, relres, iter, resvec] = cgs (A, b, tol, maxit, M);
+%! [x, flag, relres, iter, resvec] = cgs (A, b, rtol, maxit, M);
 %! assert (x, ones (size (b)), 1e-7);
 %!
 %!test
-%! tol = 1e-8;
+%! rtol = 1e-8;
 %! maxit = 15;
 %!
-%! [x, flag, relres, iter, resvec] = cgs (@(x) A * x, b, tol, maxit, M);
+%! [x, flag, relres, iter, resvec] = cgs (@(x) A * x, b, rtol, maxit, M);
 %! assert (x, ones (size (b)), 1e-7);
 
 %!test
 %! n = 100;
-%! tol = 1e-8;
+%! rtol = 1e-8;
 %! a = sprand (n, n, .1);
 %! A = a'*a + 100 * eye (n);
 %! b = sum (A, 2);
-%! [x, flag, relres, iter, resvec] = cgs (A, b, tol, [], diag (diag (A)));
+%! [x, flag, relres, iter, resvec] = cgs (A, b, rtol, [], diag (diag (A)));
 %! assert (x, ones (size (b)), 1e-7);
 
diff --git a/scripts/sparse/qmr.m b/scripts/sparse/qmr.m
--- a/scripts/sparse/qmr.m
+++ b/scripts/sparse/qmr.m
@@ -82,17 +82,17 @@
 ## for iterative methods}, SIAM, 2nd ed., 1994.
 ## @end enumerate
 ##
 ## @seealso{bicg, bicgstab, cgs, gmres, pcg}
 ## @end deftypefn
 
 ## Author: Nathan Podlich <nathan.podlich@gmail.com>
 
-function [x, flag, relres, iter, resvec] = qmr (A, b, tol, maxit, M1, M2, x0)
+function [x, flag, relres, iter, resvec] = qmr (A, b, rtol, maxit, M1, M2, x0)
 
   if (nargin >= 2 && isvector (full (b)))
 
     if (ischar (A))
       fun = str2func (A);
       Ax  = @(x) feval (fun, x, "notransp");
       Atx = @(x) feval (fun, x, "transp");
     elseif (isa (A, "function_handle"))
@@ -100,18 +100,18 @@ function [x, flag, relres, iter, resvec]
       Atx = @(x) feval (A, x, "transp");
     elseif (isnumeric (A) && issquare (A))
       Ax  = @(x) A  * x;
       Atx = @(x) A' * x;
     else
       error ("qmr: A must be a square matrix or function");
     endif
 
-    if (nargin < 3 || isempty (tol))
-      tol = 1e-6;
+    if (nargin < 3 || isempty (rtol))
+      rtol = 1e-6;
     endif
 
     if (nargin < 4 || isempty (maxit))
       maxit = min (rows (b), 20);
     else
       maxit = fix (maxit);
     endif
 
@@ -220,17 +220,17 @@ function [x, flag, relres, iter, resvec]
       x += d;
       r -= s;
 
       res1 = norm (r) / bnorm;
       if (nargout > 4)
         resvec(iter + 1, 1) = norm (r);
       endif
 
-      if (res1 < tol)
+      if (res1 < rtol)
         ## Convergence achieved.
         flag = 0;
         break;
       elseif (res0 <= res1)
         ## Stagnation encountered.
         flag = 3;
         break;
       endif
@@ -239,25 +239,25 @@ function [x, flag, relres, iter, resvec]
       gamma0 = gamma1;
       rho0 = rho1;
     endfor
 
     relres = res1;
     if (flag == 1)
       if (nargout < 2)
         printf ("qmr stopped at iteration %i ", iter);
-        printf ("without converging to the desired tolerance %e\n", tol);
+        printf ("without converging to the desired tolerance %e\n", rtol);
         printf ("because the maximum number of iterations was reached. ");
         printf ("The iterate returned (number %i) has ", maxit);
         printf ("relative residual %e\n", res1);
       endif
     elseif (flag == 3)
       if (nargout < 2)
         printf ("qmr stopped at iteration %i ", iter);
-        printf (" without converging to the desired tolerance %e\n", tol);
+        printf (" without converging to the desired tolerance %e\n", rtol);
         printf ("because the method stagnated.\n");
         printf ("The iterate returned (number %i) ", iter);
         printf ("has relative residual %e\n", res1);
       endif
     elseif (nargout < 2)
       printf ("qmr converged at iteration %i ", iter);
       printf ("to a solution with relative residual %e\n", res1);
     endif
@@ -273,51 +273,51 @@ endfunction
 %! A = [5 -1 3;-1 2 -2;3 -2 3];
 %! b = [7;-1;4];
 %! [x, flag, relres, iter, resvec] = qmr (A, b)
 
 %!test
 %! n = 100;
 %! A = spdiags ([-2*ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
 %! b = sum (A, 2);
-%! tol = 1e-8;
+%! rtol = 1e-8;
 %! maxit = 15;
 %! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n);
 %! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n);
-%! [x, flag, relres, iter, resvec] = qmr (A, b, tol, maxit, M1, M2);
+%! [x, flag, relres, iter, resvec] = qmr (A, b, rtol, maxit, M1, M2);
 %! assert (x, ones (size (b)), 1e-7);
 
 %!function y = afun (x, t, a)
 %!  switch (t)
 %!    case "notransp"
 %!      y = a * x;
 %!    case "transp"
 %!      y = a' * x;
 %!  endswitch
 %!endfunction
 %!
 %!test
 %! n = 100;
 %! A = spdiags ([-2*ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
 %! b = sum (A, 2);
-%! tol = 1e-8;
+%! rtol = 1e-8;
 %! maxit = 15;
 %! M1 = spdiags ([ones(n,1)/(-2) ones(n,1)],-1:0, n, n);
 %! M2 = spdiags ([4*ones(n,1) -ones(n,1)], 0:1, n, n);
 %!
 %! [x, flag, relres, iter, resvec] = qmr (@(x, t) afun (x, t, A),
-%!                                         b, tol, maxit, M1, M2);
+%!                                         b, rtol, maxit, M1, M2);
 %! assert (x, ones (size (b)), 1e-7);
 
 %!test
 %! n = 100;
-%! tol = 1e-8;
+%! rtol = 1e-8;
 %! a = sprand (n, n, .1);
 %! A = a' * a + 100 * eye (n);
 %! b = sum (A, 2);
-%! [x, flag, relres, iter, resvec] = qmr (A, b, tol, [], diag (diag (A)));
+%! [x, flag, relres, iter, resvec] = qmr (A, b, rtol, [], diag (diag (A)));
 %! assert (x, ones (size (b)), 1e-7);
 
 %!test
 %! A = [1 + 1i, 1 + 1i; 2 - 1i, 2 + 1i];
 %! b = A * [1; 1];
 %! [x, flag, relres, iter, resvec] = qmr (A, b);
 %! assert (x, [1; 1], 1e-6);
diff --git a/scripts/strings/untabify.m b/scripts/strings/untabify.m
--- a/scripts/strings/untabify.m
+++ b/scripts/strings/untabify.m
@@ -46,31 +46,31 @@
 ## @end example
 ##
 ## @seealso{strjust, strsplit, deblank}
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2010-10-15
 
-function s = untabify (t, tw = 8, dblank = false)
+function s = untabify (t, tw = 8, deblank_arg = false)
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   elseif (! (ischar (t) || iscellstr (t)))
     error ("untabify: T must be a string or cellstring");
   endif
 
   if (ischar (t))
     s = replace_tabs (t, tw);
   else
     s = cellfun (@replace_tabs, t, {tw}, "uniformoutput", false);
   endif
 
-  if (dblank)
+  if (deblank_arg)
     s = deblank (s);
   endif
 
 endfunction
 
 function s = replace_tabs (t, tw)
 
   if (ndims (t) != 2)
diff --git a/scripts/testfun/private/dump_demos.m b/scripts/testfun/private/dump_demos.m
--- a/scripts/testfun/private/dump_demos.m
+++ b/scripts/testfun/private/dump_demos.m
@@ -45,39 +45,39 @@
 ## @example
 ## dump_demos plot dump.m png
 ## @end example
 ## @seealso{fntests, test, demo}
 ## @end deftypefn
 
 ## Author: Søren Hauberg  <soren@hauberg.org>
 
-function dump_demos (dirs={"plot/appearance", "plot/draw", "plot/util", "image"}, output="dump_plot_demos.m", fmt="png")
+function dump_demos (dirs={"plot/appearance", "plot/draw", "plot/util", "image"}, mfile="dump_plot_demos.m", fmt="png")
 
   if (nargin > 3)
     print_usage ();
   endif
 
   if (ischar (dirs))
     dirs = {dirs};
   elseif (! iscellstr (dirs))
     error ("dump_demos: DIRS must be a cell array of strings with directory names");
   endif
 
   if (! isunix ())
     dirs = strrep (dirs, "/", filesep ());
   endif
 
-  [~, funcname, ext] = fileparts (output);
+  [~, funcname, ext] = fileparts (mfile);
   if (isempty (ext))
-    output = [output ".m"];
+    mfile = [mfile ".m"];
   endif
 
   ## Create script beginning (close figures, etc.)
-  fid = fopen (output, "w");
+  fid = fopen (mfile, "w");
   fprintf (fid, "%% DO NOT EDIT!  Generated automatically by dump_demos.m\n");
   fprintf (fid, "function %s ()\n", funcname);
   fprintf (fid, "set (0, 'DefaultAxesColorOrder', ...\n");
   fprintf (fid, "  [ 0.00000   0.00000   1.00000 ;\n");
   fprintf (fid, "    0.00000   0.50000   0.00000 ;\n");
   fprintf (fid, "    1.00000   0.00000   0.00000 ;\n");
   fprintf (fid, "    0.00000   0.75000   0.75000 ;\n");
   fprintf (fid, "    0.75000   0.00000   0.75000 ;\n");
diff --git a/scripts/testfun/speed.m b/scripts/testfun/speed.m
--- a/scripts/testfun/speed.m
+++ b/scripts/testfun/speed.m
@@ -139,16 +139,20 @@
 ## In this case, the comparison should be computed relatively, as
 ## @code{abs ((@var{x} - @var{y}) ./ @var{y})} rather than absolutely as
 ## @code{abs (@var{x} - @var{y})}.
 ##
 ## Type @kbd{example ("speed")} to see some real examples or
 ## @kbd{demo ("speed")} to run them.
 ## @end deftypefn
 
+## Programming Note: All variables for speed() must use the internal prefix "__".
+## Shared variables are eval'ed into the current workspace and therefore might
+## collide with the names used in the speed.m function itself.
+
 ## FIXME: consider two dimensional speedup surfaces for functions like kron.
 function [__order, __test_n, __tnew, __torig] = speed (__f1, __init, __max_n = 100, __f2 = "", __tol = eps)
 
   if (nargin < 1 || nargin > 6)
     print_usage ();
   endif
 
   if (nargin < 2 || isempty (__init))
