# HG changeset patch
# User Jaroslav Hajek <highegg@gmail.com>
# Date 1255691551 -7200
#      Fri Oct 16 13:12:31 2009 +0200
# Node ID b4fdfee405b5cab18551b0fb6705bf7b300f1da5
# Parent  7b9cbaad68d64b9c7770adb3857f700480ba5806
remove ArrayN<T> + fix nonhom. diag-scalar ops

diff --git a/liboctave/Array-C.cc b/liboctave/Array-C.cc
--- a/liboctave/Array-C.cc
+++ b/liboctave/Array-C.cc
@@ -91,22 +91,17 @@ sortrows_comparator (sortmode mode, cons
 INSTANTIATE_ARRAY_SORT (Complex);
 
 INSTANTIATE_ARRAY (Complex, OCTAVE_API);
 
 #include "Array2.h"
 
 template class OCTAVE_API Array2<Complex>;
 
-#include "ArrayN.h"
-#include "ArrayN.cc"
-
-template class OCTAVE_API ArrayN<Complex>;
-
-template OCTAVE_API std::ostream& operator << (std::ostream&, const ArrayN<Complex>&);
+template OCTAVE_API std::ostream& operator << (std::ostream&, const Array<Complex>&);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 #ifdef _MSC_VER
 template class OCTAVE_API DiagArray2<Complex>::Proxy;
 #endif
 template class OCTAVE_API DiagArray2<Complex>;
diff --git a/liboctave/Array-b.cc b/liboctave/Array-b.cc
--- a/liboctave/Array-b.cc
+++ b/liboctave/Array-b.cc
@@ -34,22 +34,17 @@ along with Octave; see the file COPYING.
 INSTANTIATE_ARRAY_SORT (bool);
 
 INSTANTIATE_ARRAY (bool, OCTAVE_API);
 
 #include "Array2.h"
 
 template class OCTAVE_API Array2<bool>;
 
-#include "ArrayN.h"
-#include "ArrayN.cc"
-
-template class OCTAVE_API ArrayN<bool>;
-
-template OCTAVE_API std::ostream& operator << (std::ostream&, const ArrayN<bool>&);
+template OCTAVE_API std::ostream& operator << (std::ostream&, const Array<bool>&);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 template class OCTAVE_API DiagArray2<bool>;
 
 /*
 ;;; Local Variables: ***
diff --git a/liboctave/Array-ch.cc b/liboctave/Array-ch.cc
--- a/liboctave/Array-ch.cc
+++ b/liboctave/Array-ch.cc
@@ -34,22 +34,17 @@ along with Octave; see the file COPYING.
 INSTANTIATE_ARRAY_SORT (char);
 
 INSTANTIATE_ARRAY (char, OCTAVE_API);
 
 #include "Array2.h"
 
 template class OCTAVE_API Array2<char>;
 
-#include "ArrayN.h"
-#include "ArrayN.cc"
-
-template class OCTAVE_API ArrayN<char>;
-
-template OCTAVE_API std::ostream& operator << (std::ostream&, const ArrayN<char>&);
+template OCTAVE_API std::ostream& operator << (std::ostream&, const Array<char>&);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 template class OCTAVE_API DiagArray2<char>;
 
 /*
 ;;; Local Variables: ***
diff --git a/liboctave/Array-d.cc b/liboctave/Array-d.cc
--- a/liboctave/Array-d.cc
+++ b/liboctave/Array-d.cc
@@ -87,22 +87,17 @@ sortrows_comparator (sortmode mode, cons
 INSTANTIATE_ARRAY_SORT (double);
 
 INSTANTIATE_ARRAY (double, OCTAVE_API);
 
 #include "Array2.h"
 
 template class OCTAVE_API Array2<double>;
 
-#include "ArrayN.h"
-#include "ArrayN.cc"
-
-template class OCTAVE_API ArrayN<double>;
-
-template OCTAVE_API std::ostream& operator << (std::ostream&, const ArrayN<double>&);
+template OCTAVE_API std::ostream& operator << (std::ostream&, const Array<double>&);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 #ifdef _MSC_VER
 template class OCTAVE_API DiagArray2<double>::Proxy;
 #endif
 template class OCTAVE_API DiagArray2<double>;
diff --git a/liboctave/Array-f.cc b/liboctave/Array-f.cc
--- a/liboctave/Array-f.cc
+++ b/liboctave/Array-f.cc
@@ -87,22 +87,17 @@ sortrows_comparator (sortmode mode, cons
 INSTANTIATE_ARRAY_SORT (float);
 
 INSTANTIATE_ARRAY (float, OCTAVE_API);
 
 #include "Array2.h"
 
 template class OCTAVE_API Array2<float>;
 
-#include "ArrayN.h"
-#include "ArrayN.cc"
-
-template class OCTAVE_API ArrayN<float>;
-
-template OCTAVE_API std::ostream& operator << (std::ostream&, const ArrayN<float>&);
+template OCTAVE_API std::ostream& operator << (std::ostream&, const Array<float>&);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 #ifdef _MSC_VER
 template class OCTAVE_API DiagArray2<float>::Proxy;
 #endif
 template class OCTAVE_API DiagArray2<float>;
diff --git a/liboctave/Array-fC.cc b/liboctave/Array-fC.cc
--- a/liboctave/Array-fC.cc
+++ b/liboctave/Array-fC.cc
@@ -92,22 +92,17 @@ sortrows_comparator (sortmode mode, cons
 INSTANTIATE_ARRAY_SORT (FloatComplex);
 
 INSTANTIATE_ARRAY (FloatComplex, OCTAVE_API);
 
 #include "Array2.h"
 
 template class OCTAVE_API Array2<FloatComplex>;
 
-#include "ArrayN.h"
-#include "ArrayN.cc"
-
-template class OCTAVE_API ArrayN<FloatComplex>;
-
-template OCTAVE_API std::ostream& operator << (std::ostream&, const ArrayN<FloatComplex>&);
+template OCTAVE_API std::ostream& operator << (std::ostream&, const Array<FloatComplex>&);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 #ifdef _MSC_VER
 template class OCTAVE_API DiagArray2<FloatComplex>::Proxy;
 #endif
 template class OCTAVE_API DiagArray2<FloatComplex>;
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -2932,13 +2932,116 @@ void Array<T>::instantiation_guard ()
   // Array<T> instances should always be explicit and use INSTANTIATE_ARRAY.
   T::__xXxXx__();
 }
 
 #define INSTANTIATE_ARRAY(T, API) \
   template <> void Array<T>::instantiation_guard () { } \
   template class API Array<T>
 
+// FIXME: is this used?
+
+template <class T>
+std::ostream&
+operator << (std::ostream& os, const Array<T>& a)
+{
+  dim_vector a_dims = a.dims ();
+
+  int n_dims = a_dims.length ();
+
+  os << n_dims << "-dimensional array";
+
+  if (n_dims)
+    os << " (" << a_dims.str () << ")";
+
+  os <<"\n\n";
+
+  if (n_dims)
+    {
+      os << "data:";
+
+      Array<octave_idx_type> ra_idx (n_dims, 0);
+
+      // Number of times the first 2d-array is to be displayed.
+
+      octave_idx_type m = 1;
+      for (int i = 2; i < n_dims; i++)
+	m *= a_dims(i);
+
+      if (m == 1)
+        {
+          octave_idx_type rows = 0;
+          octave_idx_type cols = 0;
+
+          switch (n_dims)
+            {
+	    case 2:
+	      rows = a_dims(0);
+	      cols = a_dims(1);
+
+	      for (octave_idx_type j = 0; j < rows; j++)
+		{
+		  ra_idx(0) = j;
+		  for (octave_idx_type k = 0; k < cols; k++)
+		    {
+		      ra_idx(1) = k;
+		      os << " " << a.elem(ra_idx);
+		    }
+		  os << "\n";
+		}
+	      break;
+
+	    default:
+	      rows = a_dims(0);
+
+	      for (octave_idx_type k = 0; k < rows; k++)
+		{
+		  ra_idx(0) = k;
+		  os << " " << a.elem(ra_idx);
+		}
+	      break;
+	    }
+
+          os << "\n";
+        }
+      else
+        {
+          octave_idx_type rows = a_dims(0);
+          octave_idx_type cols = a_dims(1);
+
+          for (int i = 0; i < m; i++)
+            {
+              os << "\n(:,:,";
+
+              for (int j = 2; j < n_dims - 1; j++)
+		os << ra_idx(j) + 1 << ",";
+
+	      os << ra_idx(n_dims - 1) + 1 << ") = \n";
+
+	      for (octave_idx_type j = 0; j < rows; j++)
+	        {
+	          ra_idx(0) = j;
+
+	          for (octave_idx_type k = 0; k < cols; k++)
+	            {
+		      ra_idx(1) = k;
+		      os << " " << a.elem(ra_idx);
+		    }
+
+	          os << "\n";
+	        }
+
+	      os << "\n";
+
+	      if (i != m - 1)
+		increment_index (ra_idx, a_dims, 2);
+            }
+        }
+    }
+
+  return os;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -730,13 +730,17 @@ public:
   T& operator () (octave_idx_type i, octave_idx_type j, octave_idx_type k)
     { return ArrayClass::xelem (i, j, k); }
   T& operator () (const Array<octave_idx_type>& ra_idx)
     { return ArrayClass::xelem (ra_idx); }
 };
 
 #endif
 
+template <class T>
+std::ostream&
+operator << (std::ostream& os, const Array<T>& a);
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/ArrayN.cc b/liboctave/ArrayN.cc
deleted file mode 100644
--- a/liboctave/ArrayN.cc
+++ /dev/null
@@ -1,144 +0,0 @@
-// Template array classes
-/*
-
-Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2009 John W. Eaton
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 3 of the License, or (at your
-option) any later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, see
-<http://www.gnu.org/licenses/>.
-
-*/
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <cassert>
-
-#include <iostream>
-
-#include "Array-util.h"
-#include "ArrayN.h"
-#include "idx-vector.h"
-#include "lo-error.h"
-
-// N-dimensional array class.
-
-template <class T>
-std::ostream&
-operator << (std::ostream& os, const ArrayN<T>& a)
-{
-  dim_vector a_dims = a.dims ();
-
-  int n_dims = a_dims.length ();
-
-  os << n_dims << "-dimensional array";
-
-  if (n_dims)
-    os << " (" << a_dims.str () << ")";
-
-  os <<"\n\n";
-
-  if (n_dims)
-    {
-      os << "data:";
-
-      Array<octave_idx_type> ra_idx (n_dims, 0);
-
-      // Number of times the first 2d-array is to be displayed.
-
-      octave_idx_type m = 1;
-      for (int i = 2; i < n_dims; i++)
-	m *= a_dims(i);
-
-      if (m == 1)
-        {
-          octave_idx_type rows = 0;
-          octave_idx_type cols = 0;
-
-          switch (n_dims)
-            {
-	    case 2:
-	      rows = a_dims(0);
-	      cols = a_dims(1);
-
-	      for (octave_idx_type j = 0; j < rows; j++)
-		{
-		  ra_idx(0) = j;
-		  for (octave_idx_type k = 0; k < cols; k++)
-		    {
-		      ra_idx(1) = k;
-		      os << " " << a.elem(ra_idx);
-		    }
-		  os << "\n";
-		}
-	      break;
-
-	    default:
-	      rows = a_dims(0);
-
-	      for (octave_idx_type k = 0; k < rows; k++)
-		{
-		  ra_idx(0) = k;
-		  os << " " << a.elem(ra_idx);
-		}
-	      break;
-	    }
-
-          os << "\n";
-        }
-      else
-        {
-          octave_idx_type rows = a_dims(0);
-          octave_idx_type cols = a_dims(1);
-
-          for (int i = 0; i < m; i++)
-            {
-              os << "\n(:,:,";
-
-              for (int j = 2; j < n_dims - 1; j++)
-		os << ra_idx(j) + 1 << ",";
-
-	      os << ra_idx(n_dims - 1) + 1 << ") = \n";
-
-	      for (octave_idx_type j = 0; j < rows; j++)
-	        {
-	          ra_idx(0) = j;
-
-	          for (octave_idx_type k = 0; k < cols; k++)
-	            {
-		      ra_idx(1) = k;
-		      os << " " << a.elem(ra_idx);
-		    }
-
-	          os << "\n";
-	        }
-
-	      os << "\n";
-
-	      if (i != m - 1)
-		increment_index (ra_idx, a_dims, 2);
-            }
-        }
-    }
-
-  return os;
-}
-
-/*
-;;; Local Variables: ***
-;;; mode: C++ ***
-;;; End: ***
-*/
diff --git a/liboctave/ArrayN.h b/liboctave/ArrayN.h
--- a/liboctave/ArrayN.h
+++ b/liboctave/ArrayN.h
@@ -20,163 +20,23 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_ArrayN_h)
 #define octave_ArrayN_h 1
 
-#include <cassert>
-#include <climits>
-#include <cstdlib>
-
-#include <iosfwd>
-
 #include "Array.h"
-#include "Array2.h"
-#include "lo-error.h"
-#include "lo-math.h"
-
-class idx_vector;
-
-// N-dimensional array class.
-
-template <class T>
-class
-ArrayN : public Array<T>
-{
-protected:
-
-  ArrayN (T *d, const dim_vector& dv) : Array<T> (d, dv) { }
-
-public:
-
-  // These really need to be protected (and they will be in the
-  // future, so don't depend on them being here!), but they can't be
-  // until template friends work correctly in g++.
-
-  ArrayN (void) : Array<T> () { }
-
-  ArrayN (const dim_vector& dv) : Array<T> (dv) { }
-
-  ArrayN (const dim_vector& dv, const T& val)
-    : Array<T> (dv) { Array<T>::fill (val); }
-
-  template <class U>
-  explicit ArrayN (const Array2<U>& a) : Array<T> (a, a.dims ()) { }
-
-  template <class U>
-  ArrayN (const ArrayN<U>& a) : Array<T> (a, a.dims ()) { }
-
-  template <class U>
-  ArrayN (const Array<U>& a) : Array<T> (a) { }
-
-  template <class U>
-  ArrayN (const Array<U>& a, const dim_vector& dv)
-    : Array<T> (a, dv) { }
-
-  ~ArrayN (void) { }
-
-  ArrayN<T>& operator = (const ArrayN<T>& a)
-    {
-      if (this != &a)
-	Array<T>::operator = (a);
-
-      return *this;
-    }
-
-  ArrayN<T> column (octave_idx_type k) const
-    { return Array<T>::column (k); }
-  ArrayN<T> page (octave_idx_type k) const
-    { return Array<T>::page (k); }
-
-  ArrayN<T> linearize (void) const
-    { return Array<T>::linearize (); }
-  ArrayN<T> linear_slice (octave_idx_type lo, octave_idx_type up) const
-    { return Array<T>::linear_slice (lo, up); }
-
-  ArrayN<T> reshape (const dim_vector& new_dims) const
-    { return Array<T>::reshape (new_dims); }
+#define ArrayN Array
 
-  ArrayN<T> permute (const Array<octave_idx_type>& vec, bool inv = false) const
-    { return Array<T>::permute (vec, inv); }
-
-  ArrayN<T> ipermute (const Array<octave_idx_type>& vec) const
-    { return Array<T>::ipermute (vec); }
-
-  ArrayN<T> squeeze (void) const { return Array<T>::squeeze (); }
-
-  ArrayN<T> transpose (void) const { return Array<T>::transpose (); }
-  ArrayN<T> hermitian (T (*fcn) (const T&) = 0) const { return Array<T>::hermitian (fcn); }
-
-  ArrayN<T>& insert (const ArrayN<T>& a, const dim_vector& dv)
-    {
-      Array<T>::insert (a, dv);
-      return *this;
-    }
-
-  ArrayN<T>& insert (const ArrayN<T>& a, octave_idx_type r, octave_idx_type c)
-  {
-    Array<T>::insert (a, r, c);
-    return *this;
-  }
-
-  ArrayN<T> index (const idx_vector& i, bool resize_ok = false,
-		   const T& rfv = Array<T>::resize_fill_value ()) const
-    {
-      Array<T> tmp = Array<T>::index (i, resize_ok, rfv);
-      return ArrayN<T> (tmp, tmp.dims ());
-    }
-
-  ArrayN<T> index (const idx_vector& i, const idx_vector& j, bool resize_ok = false,
-		   const T& rfv = Array<T>::resize_fill_value ()) const
-    {
-      Array<T> tmp = Array<T>::index (i, j, resize_ok, rfv);
-      return ArrayN<T> (tmp, tmp.dims ());
-    }
-
-  ArrayN<T> index (const Array<idx_vector>& ra_idx, bool resize_ok = false,
-		   const T& rfv = Array<T>::resize_fill_value ()) const
-    {
-      Array<T> tmp = Array<T>::index (ra_idx, resize_ok, rfv);
-      return ArrayN<T> (tmp, tmp.dims ());
-    }
-
-  ArrayN<T> sort (int dim = 0, sortmode mode = ASCENDING) const
-    {
-      return Array<T>::sort (dim, mode);
-    }
-
-  ArrayN<T> sort (Array<octave_idx_type> &sidx, int dim = 0,
-		 sortmode mode = ASCENDING) const
-    {
-      return Array<T>::sort (sidx, dim, mode);
-    }
-
-  ArrayN<T> nth_element (const idx_vector& n, int dim = 0) const
-    {
-      return Array<T>::nth_element (n, dim);
-    }
-
-  ArrayN<T> diag (octave_idx_type k) const
-  {
-    return Array<T>::diag (k);
-  }
-
-  template <class U, class F>
-  ArrayN<U> map (F fcn) const
-  {
-    return Array<T>::template map<U> (fcn);
-  }
-};
-
-template <class T>
-std::ostream&
-operator << (std::ostream&, const ArrayN<T>&);
+// If we're with GNU C++, issue a warning.
+#ifdef __GNUC__
+#warning Using ArrayN<T> is deprecated. Use Array<T> directly.
+#endif
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -709,80 +709,80 @@ static const Complex Complex_NaN_result 
 
 ComplexNDArray
 ComplexNDArray::max (int dim) const
 {
   return do_mx_minmax_op<ComplexNDArray> (*this, dim, mx_inline_max);
 }
 
 ComplexNDArray
-ComplexNDArray::max (ArrayN<octave_idx_type>& idx_arg, int dim) const
+ComplexNDArray::max (Array<octave_idx_type>& idx_arg, int dim) const
 {
   return do_mx_minmax_op<ComplexNDArray> (*this, idx_arg, dim, mx_inline_max);
 }
 
 ComplexNDArray
 ComplexNDArray::min (int dim) const
 {
   return do_mx_minmax_op<ComplexNDArray> (*this, dim, mx_inline_min);
 }
 
 ComplexNDArray
-ComplexNDArray::min (ArrayN<octave_idx_type>& idx_arg, int dim) const
+ComplexNDArray::min (Array<octave_idx_type>& idx_arg, int dim) const
 {
   return do_mx_minmax_op<ComplexNDArray> (*this, idx_arg, dim, mx_inline_min);
 }
 
 ComplexNDArray
 ComplexNDArray::cummax (int dim) const
 {
   return do_mx_cumminmax_op<ComplexNDArray> (*this, dim, mx_inline_cummax);
 }
 
 ComplexNDArray
-ComplexNDArray::cummax (ArrayN<octave_idx_type>& idx_arg, int dim) const
+ComplexNDArray::cummax (Array<octave_idx_type>& idx_arg, int dim) const
 {
   return do_mx_cumminmax_op<ComplexNDArray> (*this, idx_arg, dim, mx_inline_cummax);
 }
 
 ComplexNDArray
 ComplexNDArray::cummin (int dim) const
 {
   return do_mx_cumminmax_op<ComplexNDArray> (*this, dim, mx_inline_cummin);
 }
 
 ComplexNDArray
-ComplexNDArray::cummin (ArrayN<octave_idx_type>& idx_arg, int dim) const
+ComplexNDArray::cummin (Array<octave_idx_type>& idx_arg, int dim) const
 {
   return do_mx_cumminmax_op<ComplexNDArray> (*this, idx_arg, dim, mx_inline_cummin);
 }
 
 NDArray
 ComplexNDArray::abs (void) const
 {
   return NDArray (mx_inline_cabs_dup (data (), length ()),
                   dims ());
 }
 
 boolNDArray
 ComplexNDArray::isnan (void) const
 {
-  return ArrayN<bool> (fastmap<bool> (xisnan));
+  return Array<bool> (fastmap<bool> (xisnan));
 }
 
 boolNDArray
 ComplexNDArray::isinf (void) const
 {
-  return ArrayN<bool> (fastmap<bool> (xisinf));
+  return Array<bool> (fastmap<bool> (xisinf));
 }
 
 boolNDArray
 ComplexNDArray::isfinite (void) const
 {
-  return ArrayN<bool> (fastmap<bool> (xfinite));
+  return Array<bool> (fastmap<bool> (xfinite));
 }
 
 ComplexNDArray
 conj (const ComplexNDArray& a)
 {
   return ComplexNDArray (mx_inline_conj_dup (a.data (), a.length ()),
                          a.dims ());
 }
diff --git a/liboctave/CNDArray.h b/liboctave/CNDArray.h
--- a/liboctave/CNDArray.h
+++ b/liboctave/CNDArray.h
@@ -47,17 +47,17 @@ public:
   ComplexNDArray (const ComplexNDArray& a) : MArrayN<Complex> (a) { }
 
   ComplexNDArray (const ComplexMatrix& a) : MArrayN<Complex> (a) { }
 
   template <class U>
   ComplexNDArray (const MArrayN<U>& a) : MArrayN<Complex> (a) { }
 
   template <class U>
-  ComplexNDArray (const ArrayN<U>& a) : MArrayN<Complex> (a) { }
+  ComplexNDArray (const Array<U>& a) : MArrayN<Complex> (a) { }
 
   ComplexNDArray (const charNDArray&); 
 
   ComplexNDArray& operator = (const ComplexNDArray& a)
     {
       MArrayN<Complex>::operator = (a);
       return *this;
     }
@@ -82,24 +82,24 @@ public:
   ComplexNDArray prod (int dim = -1) const;
   ComplexNDArray sum (int dim = -1) const;
   ComplexNDArray xsum (int dim = -1) const;
   ComplexNDArray sumsq (int dim = -1) const;
   ComplexNDArray concat (const ComplexNDArray& rb, const Array<octave_idx_type>& ra_idx);
   ComplexNDArray concat (const NDArray& rb, const Array<octave_idx_type>& ra_idx);
 
   ComplexNDArray max (int dim = 0) const;
-  ComplexNDArray max (ArrayN<octave_idx_type>& index, int dim = 0) const;
+  ComplexNDArray max (Array<octave_idx_type>& index, int dim = 0) const;
   ComplexNDArray min (int dim = 0) const;
-  ComplexNDArray min (ArrayN<octave_idx_type>& index, int dim = 0) const;
+  ComplexNDArray min (Array<octave_idx_type>& index, int dim = 0) const;
 
   ComplexNDArray cummax (int dim = 0) const;
-  ComplexNDArray cummax (ArrayN<octave_idx_type>& index, int dim = 0) const;
+  ComplexNDArray cummax (Array<octave_idx_type>& index, int dim = 0) const;
   ComplexNDArray cummin (int dim = 0) const;
-  ComplexNDArray cummin (ArrayN<octave_idx_type>& index, int dim = 0) const;
+  ComplexNDArray cummin (Array<octave_idx_type>& index, int dim = 0) const;
 
   ComplexNDArray diff (octave_idx_type order = 1, int dim = 0) const;
 
   ComplexNDArray& insert (const NDArray& a, octave_idx_type r, octave_idx_type c);
   ComplexNDArray& insert (const ComplexNDArray& a, octave_idx_type r, octave_idx_type c);
   ComplexNDArray& insert (const ComplexNDArray& a, const Array<octave_idx_type>& ra_idx);
   
   NDArray abs (void) const;
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,44 @@
+2009-10-16  Jaroslav Hajek  <highegg@gmail.com>
+
+	* ArrayN.h: Remove everything, just #define ArrayN Array. 
+	Warn if under gcc.
+	* ArrayN.cc: Remove.
+	* Array.cc (operator >>): New operator.
+	* Array.h: Declare it.
+
+	* Array-C.cc: Remove traces of ArrayN.
+	* Array-b.cc: Ditto.
+	* Array-ch.cc: Ditto.
+	* Array-d.cc: Ditto.
+	* Array-f.cc: Ditto.
+	* Array-fC.cc: Ditto.
+	* CNDArray.cc: Ditto.
+	* CNDArray.h: Ditto.
+	* MArrayN.h: Ditto.
+	* boolNDArray.cc: Ditto.
+	* boolNDArray.h: Ditto.
+	* chNDArray.h: Ditto.
+	* dNDArray.cc: Ditto.
+	* dNDArray.h: Ditto.
+	* fCNDArray.cc: Ditto.
+	* fCNDArray.h: Ditto.
+	* fNDArray.cc: Ditto.
+	* fNDArray.h: Ditto.
+	* intNDArray.cc: Ditto.
+	* intNDArray.h: Ditto.
+	* lo-specfun.cc: Ditto.
+	* lo-specfun.h: Ditto.
+
+	* mx-op-defs.h (DMS_BIN_OP, SDM_BIN_OP): Rewrite.
+	(DMS_BIN_OPS, SDM_BIN_OPS): Define dm*s and dm/s rather than dm+s and
+	dm-s which are rather useless.
+	* mx-ops: Update.
+
 2009-10-16  Jaroslav Hajek  <highegg@gmail.com>
 
 	* Array.cc (Array<T>::column, Array<T>::page, Array<T>::linearize,
 	Array<T>::linear_slice): New methods.
 	* Array.h: Declare them
 	* ArrayN.h: Forward them.
 
 2009-10-14  Jaroslav Hajek  <highegg@gmail.com>
diff --git a/liboctave/MArrayN.h b/liboctave/MArrayN.h
--- a/liboctave/MArrayN.h
+++ b/liboctave/MArrayN.h
@@ -20,58 +20,58 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_MArrayN_h)
 #define octave_MArrayN_h 1
 
-#include "ArrayN.h"
+#include "Array.h"
 #include "MArray2.h"
 #include "dim-vector.h"
 
 // N-dimensional array with math ops.
 
 // But first, some preprocessor abuse...
 
 #include "MArray-decl.h"
 
 MARRAY_OPS_FORWARD_DECLS (MArrayN, )
 
 template <class T>
 class
-MArrayN : public ArrayN<T>
+MArrayN : public Array<T>
 {
 protected:
 
-  MArrayN (T *d, const dim_vector& dv) : ArrayN<T> (d, dv) { }
+  MArrayN (T *d, const dim_vector& dv) : Array<T> (d, dv) { }
 
 public:
   
-  MArrayN (void) : ArrayN<T> () {}
+  MArrayN (void) : Array<T> () {}
   
-  MArrayN (const dim_vector& dv) : ArrayN<T> (dv) { }
+  MArrayN (const dim_vector& dv) : Array<T> (dv) { }
   
-  MArrayN (const dim_vector& dv, const T& val) : ArrayN<T> (dv, val) { }
+  MArrayN (const dim_vector& dv, const T& val) : Array<T> (dv, val) { }
 
   template <class U>
-  explicit MArrayN (const Array2<U>& a) : ArrayN<T> (a) { }
+  explicit MArrayN (const Array2<U>& a) : Array<T> (a) { }
 
   template <class U>
-  MArrayN (const ArrayN<U>& a) : ArrayN<T> (a) { }
+  MArrayN (const Array<U>& a) : Array<T> (a) { }
 
   template <class U>
-  MArrayN (const MArrayN<U>& a) : ArrayN<T> (a) { }
+  MArrayN (const MArrayN<U>& a) : Array<T> (a) { }
 
   ~MArrayN (void) { }
 
   MArrayN<T>& operator = (const MArrayN<T>& a)
     {
-      ArrayN<T>::operator = (a);
+      Array<T>::operator = (a);
       return *this;
     }
 
   octave_idx_type nnz (void) const
     {
       octave_idx_type retval = 0;
 
       const T *d = this->data ();
@@ -83,36 +83,36 @@ public:
 	  if (d[i] != T ())
 	    retval++;
 	}
 
       return retval;
     }
 
   MArrayN<T> reshape (const dim_vector& new_dims) const
-    { return ArrayN<T>::reshape (new_dims); }
+    { return Array<T>::reshape (new_dims); }
 
   MArrayN<T> permute (const Array<octave_idx_type>& vec, 
 		      bool inv = false) const
-    { return ArrayN<T>::permute (vec, inv); }
+    { return Array<T>::permute (vec, inv); }
 
   MArrayN<T> ipermute (const Array<octave_idx_type>& vec) const
-    { return ArrayN<T>::ipermute (vec); }
+    { return Array<T>::ipermute (vec); }
 
-  MArrayN squeeze (void) const { return ArrayN<T>::squeeze (); }
+  MArrayN squeeze (void) const { return Array<T>::squeeze (); }
 
   MArrayN<T> diag (octave_idx_type k) const
   {
-    return ArrayN<T>::diag (k);
+    return Array<T>::diag (k);
   }
 
   template <class U, class F>
   MArrayN<U> map (F fcn) const
   {
-    return ArrayN<T>::template map<U> (fcn);
+    return Array<T>::template map<U> (fcn);
   }
 
   void changesign (void);
 };
 
 #endif
 
 /*
diff --git a/liboctave/boolNDArray.cc b/liboctave/boolNDArray.cc
--- a/liboctave/boolNDArray.cc
+++ b/liboctave/boolNDArray.cc
@@ -145,17 +145,17 @@ boolNDArray::compute_index (Array<octave
 			    const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 boolNDArray
 boolNDArray::diag (octave_idx_type k) const
 {
-  return ArrayN<bool>::diag (k);
+  return Array<bool>::diag (k);
 }
 
 NDND_BOOL_OPS (boolNDArray, boolNDArray)
 NDND_CMP_OPS (boolNDArray, boolNDArray)
 
 NDS_BOOL_OPS (boolNDArray, bool)
 NDS_CMP_OPS (boolNDArray, bool)
 
diff --git a/liboctave/boolNDArray.h b/liboctave/boolNDArray.h
--- a/liboctave/boolNDArray.h
+++ b/liboctave/boolNDArray.h
@@ -18,47 +18,47 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_boolNDArray_h)
 #define octave_boolNDArray_h 1
 
-#include "ArrayN.h"
+#include "Array.h"
 
 #include "mx-defs.h"
 #include "mx-op-decl.h"
 
 #include "boolMatrix.h"
 
 class
 OCTAVE_API
-boolNDArray : public ArrayN<bool>
+boolNDArray : public Array<bool>
 {
 public:
 
   typedef boolMatrix matrix_type;
 
-  boolNDArray (void) : ArrayN<bool> () { }
+  boolNDArray (void) : Array<bool> () { }
 
-  boolNDArray (const dim_vector& dv) : ArrayN<bool> (dv) { }
+  boolNDArray (const dim_vector& dv) : Array<bool> (dv) { }
 
   boolNDArray (const dim_vector& dv, const bool& val)
-    : ArrayN<bool> (dv, val) { }
+    : Array<bool> (dv, val) { }
   
-  boolNDArray (const boolNDArray& a) : ArrayN<bool> (a) { }
+  boolNDArray (const boolNDArray& a) : Array<bool> (a) { }
 
-  boolNDArray (const boolMatrix& a) : ArrayN<bool> (a) { }
+  boolNDArray (const boolMatrix& a) : Array<bool> (a) { }
 
-  boolNDArray (const ArrayN<bool>& a) : ArrayN<bool> (a) { }
+  boolNDArray (const Array<bool>& a) : Array<bool> (a) { }
 
   boolNDArray& operator = (const boolNDArray& a)
     {
-      ArrayN<bool>::operator = (a);
+      Array<bool>::operator = (a);
       return *this;
     }
 
   // unary operations
 
   boolNDArray operator ! (void) const;
 
   boolNDArray& invert (void); 
@@ -75,17 +75,17 @@ public:
 
   boolNDArray concat (const boolNDArray& rb, const Array<octave_idx_type>& ra_idx);
 
   boolNDArray& insert (const boolNDArray& a, octave_idx_type r, octave_idx_type c);
   boolNDArray& insert (const boolNDArray& a, const Array<octave_idx_type>& ra_idx);
 
   boolMatrix matrix_value (void) const;
 
-  boolNDArray squeeze (void) const { return ArrayN<bool>::squeeze (); }
+  boolNDArray squeeze (void) const { return Array<bool>::squeeze (); }
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
 			       const dim_vector& dimensions,
 			       int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
 			    const dim_vector& dimensions);
 
@@ -115,17 +115,17 @@ public:
 
       return retval;
     }
 
   boolNDArray diag (octave_idx_type k = 0) const;
 
 private:
 
-  boolNDArray (bool *d, dim_vector& dv) : ArrayN<bool> (d, dv) { }
+  boolNDArray (bool *d, dim_vector& dv) : Array<bool> (d, dv) { }
 };
 
 NDND_BOOL_OP_DECLS (boolNDArray, boolNDArray, OCTAVE_API)
 NDND_CMP_OP_DECLS (boolNDArray, boolNDArray, OCTAVE_API)
 
 NDS_BOOL_OP_DECLS (boolNDArray, bool, OCTAVE_API)
 NDS_CMP_OP_DECLS (boolNDArray, bool, OCTAVE_API)
 
diff --git a/liboctave/chNDArray.h b/liboctave/chNDArray.h
--- a/liboctave/chNDArray.h
+++ b/liboctave/chNDArray.h
@@ -50,17 +50,17 @@ public:
   charNDArray (char c) : MArrayN<char> (charMatrix (c)) { }
 
   charNDArray (const char *s) : MArrayN<char> (charMatrix (s)) { }
 
   charNDArray (const std::string& s) : MArrayN<char> (charMatrix (s)) { }
 
   charNDArray (const string_vector& s) : MArrayN<char> (charMatrix (s)) { }
 
-  charNDArray (const ArrayN<char>& a) : MArrayN<char> (a) { }
+  charNDArray (const Array<char>& a) : MArrayN<char> (a) { }
 
   charNDArray& operator = (const charNDArray& a)
     {
       MArrayN<char>::operator = (a);
       return *this;
     }
 
   bool any_element_is_nan (void) const { return false; }
@@ -72,17 +72,17 @@ public:
   charNDArray concat (const charNDArray& rb, const Array<octave_idx_type>& ra_idx);
   charNDArray concat (const NDArray& rb, const Array<octave_idx_type>& ra_idx);
 
   charNDArray& insert (const charNDArray& a, octave_idx_type r, octave_idx_type c);
   charNDArray& insert (const charNDArray& a, const Array<octave_idx_type>& ra_idx);
   
   charMatrix matrix_value (void) const;
 
-  charNDArray squeeze (void) const { return ArrayN<char>::squeeze (); }
+  charNDArray squeeze (void) const { return Array<char>::squeeze (); }
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
 			       const dim_vector& dimensions,
 			       int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
 			    const dim_vector& dimensions);
 
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -739,53 +739,53 @@ NDArray::sumsq (int dim) const
 
 NDArray
 NDArray::max (int dim) const
 {
   return do_mx_minmax_op<NDArray> (*this, dim, mx_inline_max);
 }
 
 NDArray
-NDArray::max (ArrayN<octave_idx_type>& idx_arg, int dim) const
+NDArray::max (Array<octave_idx_type>& idx_arg, int dim) const
 {
   return do_mx_minmax_op<NDArray> (*this, idx_arg, dim, mx_inline_max);
 }
 
 NDArray
 NDArray::min (int dim) const
 {
   return do_mx_minmax_op<NDArray> (*this, dim, mx_inline_min);
 }
 
 NDArray
-NDArray::min (ArrayN<octave_idx_type>& idx_arg, int dim) const
+NDArray::min (Array<octave_idx_type>& idx_arg, int dim) const
 {
   return do_mx_minmax_op<NDArray> (*this, idx_arg, dim, mx_inline_min);
 }
 
 NDArray
 NDArray::cummax (int dim) const
 {
   return do_mx_cumminmax_op<NDArray> (*this, dim, mx_inline_cummax);
 }
 
 NDArray
-NDArray::cummax (ArrayN<octave_idx_type>& idx_arg, int dim) const
+NDArray::cummax (Array<octave_idx_type>& idx_arg, int dim) const
 {
   return do_mx_cumminmax_op<NDArray> (*this, idx_arg, dim, mx_inline_cummax);
 }
 
 NDArray
 NDArray::cummin (int dim) const
 {
   return do_mx_cumminmax_op<NDArray> (*this, dim, mx_inline_cummin);
 }
 
 NDArray
-NDArray::cummin (ArrayN<octave_idx_type>& idx_arg, int dim) const
+NDArray::cummin (Array<octave_idx_type>& idx_arg, int dim) const
 {
   return do_mx_cumminmax_op<NDArray> (*this, idx_arg, dim, mx_inline_cummin);
 }
 
 NDArray
 NDArray::diff (octave_idx_type order, int dim) const
 {
   return do_mx_diff_op<NDArray> (*this, dim, order, mx_inline_diff);
@@ -877,29 +877,29 @@ NDArray::abs (void) const
 {
   return NDArray (mx_inline_fabs_dup (data (), length ()),
                   dims ());
 }
 
 boolNDArray
 NDArray::isnan (void) const
 {
-  return ArrayN<bool> (fastmap<bool> (xisnan));
+  return Array<bool> (fastmap<bool> (xisnan));
 }
 
 boolNDArray
 NDArray::isinf (void) const
 {
-  return ArrayN<bool> (fastmap<bool> (xisinf));
+  return Array<bool> (fastmap<bool> (xisinf));
 }
 
 boolNDArray
 NDArray::isfinite (void) const
 {
-  return ArrayN<bool> (fastmap<bool> (xfinite));
+  return Array<bool> (fastmap<bool> (xfinite));
 }
 
 Matrix
 NDArray::matrix_value (void) const
 {
   Matrix retval;
 
   if (ndims () == 2)
diff --git a/liboctave/dNDArray.h b/liboctave/dNDArray.h
--- a/liboctave/dNDArray.h
+++ b/liboctave/dNDArray.h
@@ -52,17 +52,17 @@ public:
 
   NDArray (const Array<octave_idx_type>& a, bool zero_based = false, 
 	   bool negative_to_nan = false);
 
   template <class U>
   NDArray (const MArrayN<U>& a) : MArrayN<double> (a) { }
 
   template <class U>
-  NDArray (const ArrayN<U>& a) : MArrayN<double> (a) { }
+  NDArray (const Array<U>& a) : MArrayN<double> (a) { }
 
   template <class U>
   explicit NDArray (const intNDArray<U>& a) : MArrayN<double> (a) { }
 
   NDArray (const charNDArray&); 
 
   NDArray& operator = (const NDArray& a)
     {
@@ -94,24 +94,24 @@ public:
   NDArray sum (int dim = -1) const;  
   NDArray xsum (int dim = -1) const;  
   NDArray sumsq (int dim = -1) const;
   NDArray concat (const NDArray& rb, const Array<octave_idx_type>& ra_idx);
   ComplexNDArray concat (const ComplexNDArray& rb, const Array<octave_idx_type>& ra_idx);
   charNDArray concat (const charNDArray& rb, const Array<octave_idx_type>& ra_idx);
 
   NDArray max (int dim = 0) const;
-  NDArray max (ArrayN<octave_idx_type>& index, int dim = 0) const;
+  NDArray max (Array<octave_idx_type>& index, int dim = 0) const;
   NDArray min (int dim = 0) const;
-  NDArray min (ArrayN<octave_idx_type>& index, int dim = 0) const;
+  NDArray min (Array<octave_idx_type>& index, int dim = 0) const;
   
   NDArray cummax (int dim = 0) const;
-  NDArray cummax (ArrayN<octave_idx_type>& index, int dim = 0) const;
+  NDArray cummax (Array<octave_idx_type>& index, int dim = 0) const;
   NDArray cummin (int dim = 0) const;
-  NDArray cummin (ArrayN<octave_idx_type>& index, int dim = 0) const;
+  NDArray cummin (Array<octave_idx_type>& index, int dim = 0) const;
 
   NDArray diff (octave_idx_type order = 1, int dim = 0) const;
 
   NDArray& insert (const NDArray& a, octave_idx_type r, octave_idx_type c);
   NDArray& insert (const NDArray& a, const Array<octave_idx_type>& ra_idx);
 
   NDArray abs (void) const;
   boolNDArray isnan (void) const;
diff --git a/liboctave/fCNDArray.cc b/liboctave/fCNDArray.cc
--- a/liboctave/fCNDArray.cc
+++ b/liboctave/fCNDArray.cc
@@ -704,80 +704,80 @@ static const FloatComplex FloatComplex_N
 
 FloatComplexNDArray
 FloatComplexNDArray::max (int dim) const
 {
   return do_mx_minmax_op<FloatComplexNDArray> (*this, dim, mx_inline_max);
 }
 
 FloatComplexNDArray
-FloatComplexNDArray::max (ArrayN<octave_idx_type>& idx_arg, int dim) const
+FloatComplexNDArray::max (Array<octave_idx_type>& idx_arg, int dim) const
 {
   return do_mx_minmax_op<FloatComplexNDArray> (*this, idx_arg, dim, mx_inline_max);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::min (int dim) const
 {
   return do_mx_minmax_op<FloatComplexNDArray> (*this, dim, mx_inline_min);
 }
 
 FloatComplexNDArray
-FloatComplexNDArray::min (ArrayN<octave_idx_type>& idx_arg, int dim) const
+FloatComplexNDArray::min (Array<octave_idx_type>& idx_arg, int dim) const
 {
   return do_mx_minmax_op<FloatComplexNDArray> (*this, idx_arg, dim, mx_inline_min);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::cummax (int dim) const
 {
   return do_mx_cumminmax_op<FloatComplexNDArray> (*this, dim, mx_inline_cummax);
 }
 
 FloatComplexNDArray
-FloatComplexNDArray::cummax (ArrayN<octave_idx_type>& idx_arg, int dim) const
+FloatComplexNDArray::cummax (Array<octave_idx_type>& idx_arg, int dim) const
 {
   return do_mx_cumminmax_op<FloatComplexNDArray> (*this, idx_arg, dim, mx_inline_cummax);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::cummin (int dim) const
 {
   return do_mx_cumminmax_op<FloatComplexNDArray> (*this, dim, mx_inline_cummin);
 }
 
 FloatComplexNDArray
-FloatComplexNDArray::cummin (ArrayN<octave_idx_type>& idx_arg, int dim) const
+FloatComplexNDArray::cummin (Array<octave_idx_type>& idx_arg, int dim) const
 {
   return do_mx_cumminmax_op<FloatComplexNDArray> (*this, idx_arg, dim, mx_inline_cummin);
 }
 
 FloatNDArray
 FloatComplexNDArray::abs (void) const
 {
   return FloatNDArray (mx_inline_cabs_dup (data (), length ()),
                        dims ());
 }
 
 boolNDArray
 FloatComplexNDArray::isnan (void) const
 {
-  return ArrayN<bool> (fastmap<bool> (xisnan));
+  return Array<bool> (fastmap<bool> (xisnan));
 }
 
 boolNDArray
 FloatComplexNDArray::isinf (void) const
 {
-  return ArrayN<bool> (fastmap<bool> (xisinf));
+  return Array<bool> (fastmap<bool> (xisinf));
 }
 
 boolNDArray
 FloatComplexNDArray::isfinite (void) const
 {
-  return ArrayN<bool> (fastmap<bool> (xfinite));
+  return Array<bool> (fastmap<bool> (xfinite));
 }
 
 FloatComplexNDArray
 conj (const FloatComplexNDArray& a)
 {
   return FloatComplexNDArray (mx_inline_conj_dup (a.data (), a.length ()),
                               a.dims ());
 }
diff --git a/liboctave/fCNDArray.h b/liboctave/fCNDArray.h
--- a/liboctave/fCNDArray.h
+++ b/liboctave/fCNDArray.h
@@ -47,17 +47,17 @@ public:
   FloatComplexNDArray (const FloatComplexNDArray& a) : MArrayN<FloatComplex> (a) { }
 
   FloatComplexNDArray (const FloatComplexMatrix& a) : MArrayN<FloatComplex> (a) { }
 
   template <class U>
   FloatComplexNDArray (const MArrayN<U>& a) : MArrayN<FloatComplex> (a) { }
 
   template <class U>
-  FloatComplexNDArray (const ArrayN<U>& a) : MArrayN<FloatComplex> (a) { }
+  FloatComplexNDArray (const Array<U>& a) : MArrayN<FloatComplex> (a) { }
 
   FloatComplexNDArray (const charNDArray&); 
 
   FloatComplexNDArray& operator = (const FloatComplexNDArray& a)
     {
       MArrayN<FloatComplex>::operator = (a);
       return *this;
     }
@@ -82,24 +82,24 @@ public:
   FloatComplexNDArray prod (int dim = -1) const;
   FloatComplexNDArray sum (int dim = -1) const;
        ComplexNDArray dsum (int dim = -1) const;
   FloatComplexNDArray sumsq (int dim = -1) const;
   FloatComplexNDArray concat (const FloatComplexNDArray& rb, const Array<octave_idx_type>& ra_idx);
   FloatComplexNDArray concat (const FloatNDArray& rb, const Array<octave_idx_type>& ra_idx);
 
   FloatComplexNDArray max (int dim = 0) const;
-  FloatComplexNDArray max (ArrayN<octave_idx_type>& index, int dim = 0) const;
+  FloatComplexNDArray max (Array<octave_idx_type>& index, int dim = 0) const;
   FloatComplexNDArray min (int dim = 0) const;
-  FloatComplexNDArray min (ArrayN<octave_idx_type>& index, int dim = 0) const;
+  FloatComplexNDArray min (Array<octave_idx_type>& index, int dim = 0) const;
 
   FloatComplexNDArray cummax (int dim = 0) const;
-  FloatComplexNDArray cummax (ArrayN<octave_idx_type>& index, int dim = 0) const;
+  FloatComplexNDArray cummax (Array<octave_idx_type>& index, int dim = 0) const;
   FloatComplexNDArray cummin (int dim = 0) const;
-  FloatComplexNDArray cummin (ArrayN<octave_idx_type>& index, int dim = 0) const;
+  FloatComplexNDArray cummin (Array<octave_idx_type>& index, int dim = 0) const;
 
   FloatComplexNDArray diff (octave_idx_type order = 1, int dim = 0) const;
 
   FloatComplexNDArray& insert (const NDArray& a, octave_idx_type r, octave_idx_type c);
   FloatComplexNDArray& insert (const FloatComplexNDArray& a, octave_idx_type r, octave_idx_type c);
   FloatComplexNDArray& insert (const FloatComplexNDArray& a, const Array<octave_idx_type>& ra_idx);
   
   FloatNDArray abs (void) const;
diff --git a/liboctave/fNDArray.cc b/liboctave/fNDArray.cc
--- a/liboctave/fNDArray.cc
+++ b/liboctave/fNDArray.cc
@@ -697,53 +697,53 @@ FloatNDArray::sumsq (int dim) const
 
 FloatNDArray
 FloatNDArray::max (int dim) const
 {
   return do_mx_minmax_op<FloatNDArray> (*this, dim, mx_inline_max);
 }
 
 FloatNDArray
-FloatNDArray::max (ArrayN<octave_idx_type>& idx_arg, int dim) const
+FloatNDArray::max (Array<octave_idx_type>& idx_arg, int dim) const
 {
   return do_mx_minmax_op<FloatNDArray> (*this, idx_arg, dim, mx_inline_max);
 }
 
 FloatNDArray
 FloatNDArray::min (int dim) const
 {
   return do_mx_minmax_op<FloatNDArray> (*this, dim, mx_inline_min);
 }
 
 FloatNDArray
-FloatNDArray::min (ArrayN<octave_idx_type>& idx_arg, int dim) const
+FloatNDArray::min (Array<octave_idx_type>& idx_arg, int dim) const
 {
   return do_mx_minmax_op<FloatNDArray> (*this, idx_arg, dim, mx_inline_min);
 }
 
 FloatNDArray
 FloatNDArray::cummax (int dim) const
 {
   return do_mx_cumminmax_op<FloatNDArray> (*this, dim, mx_inline_cummax);
 }
 
 FloatNDArray
-FloatNDArray::cummax (ArrayN<octave_idx_type>& idx_arg, int dim) const
+FloatNDArray::cummax (Array<octave_idx_type>& idx_arg, int dim) const
 {
   return do_mx_cumminmax_op<FloatNDArray> (*this, idx_arg, dim, mx_inline_cummax);
 }
 
 FloatNDArray
 FloatNDArray::cummin (int dim) const
 {
   return do_mx_cumminmax_op<FloatNDArray> (*this, dim, mx_inline_cummin);
 }
 
 FloatNDArray
-FloatNDArray::cummin (ArrayN<octave_idx_type>& idx_arg, int dim) const
+FloatNDArray::cummin (Array<octave_idx_type>& idx_arg, int dim) const
 {
   return do_mx_cumminmax_op<FloatNDArray> (*this, idx_arg, dim, mx_inline_cummin);
 }
 
 FloatNDArray
 FloatNDArray::diff (octave_idx_type order, int dim) const
 {
   return do_mx_diff_op<FloatNDArray> (*this, dim, order, mx_inline_diff);
@@ -835,29 +835,29 @@ FloatNDArray::abs (void) const
 {
   return FloatNDArray (mx_inline_fabs_dup (data (), length ()),
                        dims ());
 }
 
 boolNDArray
 FloatNDArray::isnan (void) const
 {
-  return ArrayN<bool> (fastmap<bool> (xisnan));
+  return Array<bool> (fastmap<bool> (xisnan));
 }
 
 boolNDArray
 FloatNDArray::isinf (void) const
 {
-  return ArrayN<bool> (fastmap<bool> (xisinf));
+  return Array<bool> (fastmap<bool> (xisinf));
 }
 
 boolNDArray
 FloatNDArray::isfinite (void) const
 {
-  return ArrayN<bool> (fastmap<bool> (xfinite));
+  return Array<bool> (fastmap<bool> (xfinite));
 }
 
 FloatMatrix
 FloatNDArray::matrix_value (void) const
 {
   FloatMatrix retval;
 
   if (ndims () == 2)
diff --git a/liboctave/fNDArray.h b/liboctave/fNDArray.h
--- a/liboctave/fNDArray.h
+++ b/liboctave/fNDArray.h
@@ -49,17 +49,17 @@ public:
   FloatNDArray (const FloatNDArray& a) : MArrayN<float> (a) { }
 
   FloatNDArray (const FloatMatrix& a) : MArrayN<float> (a) { }
 
   template <class U>
   FloatNDArray (const MArrayN<U>& a) : MArrayN<float> (a) { }
 
   template <class U>
-  FloatNDArray (const ArrayN<U>& a) : MArrayN<float> (a) { }
+  FloatNDArray (const Array<U>& a) : MArrayN<float> (a) { }
 
   template <class U>
   explicit FloatNDArray (const intNDArray<U>& a) : MArrayN<float> (a) { }
 
   FloatNDArray (const charNDArray&); 
 
   FloatNDArray& operator = (const FloatNDArray& a)
     {
@@ -91,24 +91,24 @@ public:
   FloatNDArray sum (int dim = -1) const;  
        NDArray dsum (int dim = -1) const;  
   FloatNDArray sumsq (int dim = -1) const;
   FloatNDArray concat (const FloatNDArray& rb, const Array<octave_idx_type>& ra_idx);
   FloatComplexNDArray concat (const FloatComplexNDArray& rb, const Array<octave_idx_type>& ra_idx);
   charNDArray concat (const charNDArray& rb, const Array<octave_idx_type>& ra_idx);
 
   FloatNDArray max (int dim = 0) const;
-  FloatNDArray max (ArrayN<octave_idx_type>& index, int dim = 0) const;
+  FloatNDArray max (Array<octave_idx_type>& index, int dim = 0) const;
   FloatNDArray min (int dim = 0) const;
-  FloatNDArray min (ArrayN<octave_idx_type>& index, int dim = 0) const;
+  FloatNDArray min (Array<octave_idx_type>& index, int dim = 0) const;
   
   FloatNDArray cummax (int dim = 0) const;
-  FloatNDArray cummax (ArrayN<octave_idx_type>& index, int dim = 0) const;
+  FloatNDArray cummax (Array<octave_idx_type>& index, int dim = 0) const;
   FloatNDArray cummin (int dim = 0) const;
-  FloatNDArray cummin (ArrayN<octave_idx_type>& index, int dim = 0) const;
+  FloatNDArray cummin (Array<octave_idx_type>& index, int dim = 0) const;
 
   FloatNDArray diff (octave_idx_type order = 1, int dim = 0) const;
 
   FloatNDArray& insert (const FloatNDArray& a, octave_idx_type r, octave_idx_type c);
   FloatNDArray& insert (const FloatNDArray& a, const Array<octave_idx_type>& ra_idx);
 
   FloatNDArray abs (void) const;
   boolNDArray isnan (void) const;
diff --git a/liboctave/intNDArray.cc b/liboctave/intNDArray.cc
--- a/liboctave/intNDArray.cc
+++ b/liboctave/intNDArray.cc
@@ -226,59 +226,59 @@ template <class T>
 intNDArray<T>
 intNDArray<T>::max (int dim) const
 {
   return do_mx_minmax_op<intNDArray<T> > (*this, dim, mx_inline_max);
 }
 
 template <class T>
 intNDArray<T>
-intNDArray<T>::max (ArrayN<octave_idx_type>& idx_arg, int dim) const
+intNDArray<T>::max (Array<octave_idx_type>& idx_arg, int dim) const
 {
   return do_mx_minmax_op<intNDArray<T> > (*this, idx_arg, dim, mx_inline_max);
 }
 
 template <class T>
 intNDArray<T>
 intNDArray<T>::min (int dim) const
 {
   return do_mx_minmax_op<intNDArray<T> > (*this, dim, mx_inline_min);
 }
 
 template <class T>
 intNDArray<T>
-intNDArray<T>::min (ArrayN<octave_idx_type>& idx_arg, int dim) const
+intNDArray<T>::min (Array<octave_idx_type>& idx_arg, int dim) const
 {
   return do_mx_minmax_op<intNDArray<T> > (*this, idx_arg, dim, mx_inline_min);
 }
 
 template <class T>
 intNDArray<T>
 intNDArray<T>::cummax (int dim) const
 {
   return do_mx_cumminmax_op<intNDArray<T> > (*this, dim, mx_inline_cummax);
 }
 
 template <class T>
 intNDArray<T>
-intNDArray<T>::cummax (ArrayN<octave_idx_type>& idx_arg, int dim) const
+intNDArray<T>::cummax (Array<octave_idx_type>& idx_arg, int dim) const
 {
   return do_mx_cumminmax_op<intNDArray<T> > (*this, idx_arg, dim, mx_inline_cummax);
 }
 
 template <class T>
 intNDArray<T>
 intNDArray<T>::cummin (int dim) const
 {
   return do_mx_cumminmax_op<intNDArray<T> > (*this, dim, mx_inline_cummin);
 }
 
 template <class T>
 intNDArray<T>
-intNDArray<T>::cummin (ArrayN<octave_idx_type>& idx_arg, int dim) const
+intNDArray<T>::cummin (Array<octave_idx_type>& idx_arg, int dim) const
 {
   return do_mx_cumminmax_op<intNDArray<T> > (*this, idx_arg, dim, mx_inline_cummin);
 }
 
 template <class T>
 intNDArray<T>
 intNDArray<T>::diff (octave_idx_type order, int dim) const
 {
diff --git a/liboctave/intNDArray.h b/liboctave/intNDArray.h
--- a/liboctave/intNDArray.h
+++ b/liboctave/intNDArray.h
@@ -43,19 +43,16 @@ public:
   
   intNDArray (const dim_vector& dv, T val)
     : MArrayN<T> (dv, val) { }
   
   template <class U>
   explicit intNDArray (const Array<U>& a) : MArrayN<T> (a) { }
 
   template <class U>
-  explicit intNDArray (const ArrayN<U>& a) : MArrayN<T> (a) { }
-
-  template <class U>
   intNDArray (const MArrayN<U>& a) : MArrayN<T> (a) { }
 
   template <class U>
   intNDArray (const intNDArray<U>& a) : MArrayN<T> (a) { }
 
   intNDArray& operator = (const intNDArray<T>& a)
     {
       MArrayN<T>::operator = (a);
@@ -76,24 +73,24 @@ public:
     }
 
   // FIXME -- this is not quite the right thing.
 
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
 
   intNDArray max (int dim = 0) const;
-  intNDArray max (ArrayN<octave_idx_type>& index, int dim = 0) const;
+  intNDArray max (Array<octave_idx_type>& index, int dim = 0) const;
   intNDArray min (int dim = 0) const;
-  intNDArray min (ArrayN<octave_idx_type>& index, int dim = 0) const;
+  intNDArray min (Array<octave_idx_type>& index, int dim = 0) const;
   
   intNDArray cummax (int dim = 0) const;
-  intNDArray cummax (ArrayN<octave_idx_type>& index, int dim = 0) const;
+  intNDArray cummax (Array<octave_idx_type>& index, int dim = 0) const;
   intNDArray cummin (int dim = 0) const;
-  intNDArray cummin (ArrayN<octave_idx_type>& index, int dim = 0) const;
+  intNDArray cummin (Array<octave_idx_type>& index, int dim = 0) const;
   
   intNDArray sum (int dim) const;
   NDArray dsum (int dim) const;
   intNDArray cumsum (int dim) const;
 
   intNDArray diff (octave_idx_type order = 1, int dim = 0) const;
 
   intNDArray abs (void) const;
diff --git a/liboctave/lo-specfun.cc b/liboctave/lo-specfun.cc
--- a/liboctave/lo-specfun.cc
+++ b/liboctave/lo-specfun.cc
@@ -1066,49 +1066,49 @@ do_bessel (dptr f, const char *fn, const
     (*current_liboctave_error_handler)
       ("%s: the sizes of alpha and x must conform", fn);
 
   return retval;
 }
 
 static inline ComplexNDArray
 do_bessel (dptr f, const char *, double alpha, const ComplexNDArray& x,
-	   bool scaled, ArrayN<octave_idx_type>& ierr)
+	   bool scaled, Array<octave_idx_type>& ierr)
 {
   dim_vector dv = x.dims ();
   octave_idx_type nel = dv.numel ();
   ComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
       retval(i) = f (x(i), alpha, (scaled ? 2 : 1), ierr(i));
 
   return retval;
 }
 
 static inline ComplexNDArray
 do_bessel (dptr f, const char *, const NDArray& alpha, const Complex& x,
-	   bool scaled, ArrayN<octave_idx_type>& ierr)
+	   bool scaled, Array<octave_idx_type>& ierr)
 {
   dim_vector dv = alpha.dims ();
   octave_idx_type nel = dv.numel ();
   ComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
     retval(i) = f (x, alpha(i), (scaled ? 2 : 1), ierr(i));
 
   return retval;
 }
 
 static inline ComplexNDArray
 do_bessel (dptr f, const char *fn, const NDArray& alpha,
-	   const ComplexNDArray& x, bool scaled, ArrayN<octave_idx_type>& ierr)
+	   const ComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr)
 {
   dim_vector dv = x.dims ();
   ComplexNDArray retval;
 
   if (dv == alpha.dims ())
     {
       octave_idx_type nel = dv.numel ();
 
@@ -1172,33 +1172,33 @@ do_bessel (dptr f, const char *, const R
 	Array2<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define SN_BESSEL(name, fcn) \
   ComplexNDArray \
   name (double alpha, const ComplexNDArray& x, bool scaled, \
-	ArrayN<octave_idx_type>& ierr) \
+	Array<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define NS_BESSEL(name, fcn) \
   ComplexNDArray \
   name (const NDArray& alpha, const Complex& x, bool scaled, \
-	ArrayN<octave_idx_type>& ierr) \
+	Array<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define NN_BESSEL(name, fcn) \
   ComplexNDArray \
   name (const NDArray& alpha, const ComplexNDArray& x, bool scaled, \
-	ArrayN<octave_idx_type>& ierr) \
+	Array<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define RC_BESSEL(name, fcn) \
   ComplexMatrix \
   name (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, \
         Array2<octave_idx_type>& ierr) \
@@ -1663,49 +1663,49 @@ do_bessel (fptr f, const char *fn, const
     (*current_liboctave_error_handler)
       ("%s: the sizes of alpha and x must conform", fn);
 
   return retval;
 }
 
 static inline FloatComplexNDArray
 do_bessel (fptr f, const char *, float alpha, const FloatComplexNDArray& x,
-	   bool scaled, ArrayN<octave_idx_type>& ierr)
+	   bool scaled, Array<octave_idx_type>& ierr)
 {
   dim_vector dv = x.dims ();
   octave_idx_type nel = dv.numel ();
   FloatComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
       retval(i) = f (x(i), alpha, (scaled ? 2 : 1), ierr(i));
 
   return retval;
 }
 
 static inline FloatComplexNDArray
 do_bessel (fptr f, const char *, const FloatNDArray& alpha, const FloatComplex& x,
-	   bool scaled, ArrayN<octave_idx_type>& ierr)
+	   bool scaled, Array<octave_idx_type>& ierr)
 {
   dim_vector dv = alpha.dims ();
   octave_idx_type nel = dv.numel ();
   FloatComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
     retval(i) = f (x, alpha(i), (scaled ? 2 : 1), ierr(i));
 
   return retval;
 }
 
 static inline FloatComplexNDArray
 do_bessel (fptr f, const char *fn, const FloatNDArray& alpha,
-	   const FloatComplexNDArray& x, bool scaled, ArrayN<octave_idx_type>& ierr)
+	   const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr)
 {
   dim_vector dv = x.dims ();
   FloatComplexNDArray retval;
 
   if (dv == alpha.dims ())
     {
       octave_idx_type nel = dv.numel ();
 
@@ -1769,33 +1769,33 @@ do_bessel (fptr f, const char *, const F
 	Array2<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define SN_BESSEL(name, fcn) \
   FloatComplexNDArray \
   name (float alpha, const FloatComplexNDArray& x, bool scaled, \
-	ArrayN<octave_idx_type>& ierr) \
+	Array<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define NS_BESSEL(name, fcn) \
   FloatComplexNDArray \
   name (const FloatNDArray& alpha, const FloatComplex& x, bool scaled, \
-	ArrayN<octave_idx_type>& ierr) \
+	Array<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define NN_BESSEL(name, fcn) \
   FloatComplexNDArray \
   name (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled, \
-	ArrayN<octave_idx_type>& ierr) \
+	Array<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define RC_BESSEL(name, fcn) \
   FloatComplexMatrix \
   name (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, \
         Array2<octave_idx_type>& ierr) \
@@ -1926,32 +1926,32 @@ biry (const ComplexMatrix& z, bool deriv
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = biry (z(i,j), deriv, scaled, ierr(i,j));
 
   return retval;
 }
 
 ComplexNDArray
-airy (const ComplexNDArray& z, bool deriv, bool scaled, ArrayN<octave_idx_type>& ierr)
+airy (const ComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr)
 {
   dim_vector dv = z.dims ();
   octave_idx_type nel = dv.numel ();
   ComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
     retval (i) = airy (z(i), deriv, scaled, ierr(i));
 
   return retval;
 }
 
 ComplexNDArray
-biry (const ComplexNDArray& z, bool deriv, bool scaled, ArrayN<octave_idx_type>& ierr)
+biry (const ComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr)
 {
   dim_vector dv = z.dims ();
   octave_idx_type nel = dv.numel ();
   ComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
@@ -2056,32 +2056,32 @@ biry (const FloatComplexMatrix& z, bool 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = biry (z(i,j), deriv, scaled, ierr(i,j));
 
   return retval;
 }
 
 FloatComplexNDArray
-airy (const FloatComplexNDArray& z, bool deriv, bool scaled, ArrayN<octave_idx_type>& ierr)
+airy (const FloatComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr)
 {
   dim_vector dv = z.dims ();
   octave_idx_type nel = dv.numel ();
   FloatComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
     retval (i) = airy (z(i), deriv, scaled, ierr(i));
 
   return retval;
 }
 
 FloatComplexNDArray
-biry (const FloatComplexNDArray& z, bool deriv, bool scaled, ArrayN<octave_idx_type>& ierr)
+biry (const FloatComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr)
 {
   dim_vector dv = z.dims ();
   octave_idx_type nel = dv.numel ();
   FloatComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
diff --git a/liboctave/lo-specfun.h b/liboctave/lo-specfun.h
--- a/liboctave/lo-specfun.h
+++ b/liboctave/lo-specfun.h
@@ -20,17 +20,17 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_liboctave_specfun_h)
 #define octave_liboctave_specfun_h 1
 
 #include "oct-cmplx.h"
-#include "ArrayN.h"
+#include "Array.h"
 
 template <class T> class Array2;
 class Matrix;
 class ComplexMatrix;
 class NDArray;
 class ComplexNDArray;
 class RowVector;
 class ComplexColumnVector;
@@ -197,85 +197,85 @@ besselh1 (const Matrix& alpha, const Com
 	  Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselh2 (const Matrix& alpha, const ComplexMatrix& x, bool scaled,
 	  Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besselj (double alpha, const ComplexNDArray& x, bool scaled,
-	 ArrayN<octave_idx_type>& ierr);
+	 Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 bessely (double alpha, const ComplexNDArray& x, bool scaled,
-	 ArrayN<octave_idx_type>& ierr);
+	 Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besseli (double alpha, const ComplexNDArray& x, bool scaled,
-	 ArrayN<octave_idx_type>& ierr);
+	 Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besselk (double alpha, const ComplexNDArray& x, bool scaled,
-	 ArrayN<octave_idx_type>& ierr);
+	 Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besselh1 (double alpha, const ComplexNDArray& x, bool scaled,
-	  ArrayN<octave_idx_type>& ierr);
+	  Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besselh2 (double alpha, const ComplexNDArray& x, bool scaled,
-	  ArrayN<octave_idx_type>& ierr);
+	  Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besselj (const NDArray& alpha, const Complex& x, bool scaled,
-	 ArrayN<octave_idx_type>& ierr);
+	 Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 bessely (const NDArray& alpha, const Complex& x, bool scaled,
-	 ArrayN<octave_idx_type>& ierr);
+	 Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besseli (const NDArray& alpha, const Complex& x, bool scaled,
-	 ArrayN<octave_idx_type>& ierr);
+	 Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besselk (const NDArray& alpha, const Complex& x, bool scaled,
-	 ArrayN<octave_idx_type>& ierr);
+	 Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besselh1 (const NDArray& alpha, const Complex& x, bool scaled,
-	  ArrayN<octave_idx_type>& ierr);
+	  Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besselh2 (const NDArray& alpha, const Complex& x, bool scaled,
-	  ArrayN<octave_idx_type>& ierr);
+	  Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besselj (const NDArray& alpha, const ComplexNDArray& x, bool scaled,
-	 ArrayN<octave_idx_type>& ierr);
+	 Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 bessely (const NDArray& alpha, const ComplexNDArray& x, bool scaled,
-	 ArrayN<octave_idx_type>& ierr);
+	 Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besseli (const NDArray& alpha, const ComplexNDArray& x, bool scaled,
-	 ArrayN<octave_idx_type>& ierr);
+	 Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besselk (const NDArray& alpha, const ComplexNDArray& x, bool scaled,
-	 ArrayN<octave_idx_type>& ierr);
+	 Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besselh1 (const NDArray& alpha, const ComplexNDArray& x, bool scaled,
-	  ArrayN<octave_idx_type>& ierr);
+	  Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besselh2 (const NDArray& alpha, const ComplexNDArray& x, bool scaled,
-	  ArrayN<octave_idx_type>& ierr);
+	  Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselj (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
 	 Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 bessely (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
 	 Array2<octave_idx_type>& ierr);
@@ -383,85 +383,85 @@ besselh1 (const FloatMatrix& alpha, cons
 	  Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselh2 (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled,
 	  Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselj (float alpha, const FloatComplexNDArray& x, bool scaled,
-	 ArrayN<octave_idx_type>& ierr);
+	 Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 bessely (float alpha, const FloatComplexNDArray& x, bool scaled,
-	 ArrayN<octave_idx_type>& ierr);
+	 Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besseli (float alpha, const FloatComplexNDArray& x, bool scaled,
-	 ArrayN<octave_idx_type>& ierr);
+	 Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselk (float alpha, const FloatComplexNDArray& x, bool scaled,
-	 ArrayN<octave_idx_type>& ierr);
+	 Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselh1 (float alpha, const FloatComplexNDArray& x, bool scaled,
-	  ArrayN<octave_idx_type>& ierr);
+	  Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselh2 (float alpha, const FloatComplexNDArray& x, bool scaled,
-	  ArrayN<octave_idx_type>& ierr);
+	  Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselj (const FloatNDArray& alpha, const FloatComplex& x, bool scaled,
-	 ArrayN<octave_idx_type>& ierr);
+	 Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 bessely (const FloatNDArray& alpha, const FloatComplex& x, bool scaled,
-	 ArrayN<octave_idx_type>& ierr);
+	 Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besseli (const FloatNDArray& alpha, const FloatComplex& x, bool scaled,
-	 ArrayN<octave_idx_type>& ierr);
+	 Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselk (const FloatNDArray& alpha, const FloatComplex& x, bool scaled,
-	 ArrayN<octave_idx_type>& ierr);
+	 Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselh1 (const FloatNDArray& alpha, const FloatComplex& x, bool scaled,
-	  ArrayN<octave_idx_type>& ierr);
+	  Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselh2 (const FloatNDArray& alpha, const FloatComplex& x, bool scaled,
-	  ArrayN<octave_idx_type>& ierr);
+	  Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselj (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled,
-	 ArrayN<octave_idx_type>& ierr);
+	 Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 bessely (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled,
-	 ArrayN<octave_idx_type>& ierr);
+	 Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besseli (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled,
-	 ArrayN<octave_idx_type>& ierr);
+	 Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselk (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled,
-	 ArrayN<octave_idx_type>& ierr);
+	 Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselh1 (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled,
-	  ArrayN<octave_idx_type>& ierr);
+	  Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselh2 (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled,
-	  ArrayN<octave_idx_type>& ierr);
+	  Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselj (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled,
 	 Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 bessely (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled,
 	 Array2<octave_idx_type>& ierr);
@@ -487,35 +487,35 @@ extern OCTAVE_API Complex biry (const Co
 
 extern OCTAVE_API ComplexMatrix
 airy (const ComplexMatrix& z, bool deriv, bool scaled, Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 biry (const ComplexMatrix& z, bool deriv, bool scaled, Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
-airy (const ComplexNDArray& z, bool deriv, bool scaled, ArrayN<octave_idx_type>& ierr);
+airy (const ComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
-biry (const ComplexNDArray& z, bool deriv, bool scaled, ArrayN<octave_idx_type>& ierr);
+biry (const ComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplex airy (const FloatComplex& z, bool deriv, bool scaled, octave_idx_type& ierr);
 extern OCTAVE_API FloatComplex biry (const FloatComplex& z, bool deriv, bool scaled, octave_idx_type& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 airy (const FloatComplexMatrix& z, bool deriv, bool scaled, Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 biry (const FloatComplexMatrix& z, bool deriv, bool scaled, Array2<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
-airy (const FloatComplexNDArray& z, bool deriv, bool scaled, ArrayN<octave_idx_type>& ierr);
+airy (const FloatComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
-biry (const FloatComplexNDArray& z, bool deriv, bool scaled, ArrayN<octave_idx_type>& ierr);
+biry (const FloatComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API double betainc (double x, double a, double b);
 extern OCTAVE_API Matrix betainc (double x, double a, const Matrix& b);
 extern OCTAVE_API Matrix betainc (double x, const Matrix& a, double b);
 extern OCTAVE_API Matrix betainc (double x, const Matrix& a, const Matrix& b);
 
 extern OCTAVE_API NDArray betainc (double x, double a, const NDArray& b);
 extern OCTAVE_API NDArray betainc (double x, const NDArray& a, double b);
diff --git a/liboctave/mx-op-decl.h b/liboctave/mx-op-decl.h
--- a/liboctave/mx-op-decl.h
+++ b/liboctave/mx-op-decl.h
@@ -232,27 +232,26 @@ class boolNDArray;
 #define NDND_OP_DECLS(R, ND1, ND2, API) \
   NDND_BIN_OP_DECLS (R, ND1, ND2, API) \
   NDND_CMP_OP_DECLS (ND1, ND2, API) \
   NDND_BOOL_OP_DECLS (ND1, ND2, API)
 
 // scalar by diagonal matrix operations.
 
 #define SDM_BIN_OP_DECLS(R, S, DM, API) \
-  BIN_OP_DECL (R, operator +, S, DM, API); \
-  BIN_OP_DECL (R, operator -, S, DM, API);
+  BIN_OP_DECL (R, operator *, S, DM, API); \
 
 #define SDM_OP_DECLS(R, S, DM, API) \
   SDM_BIN_OP_DECLS(R, S, DM, API)
 
 // diagonal matrix by scalar operations.
 
 #define DMS_BIN_OP_DECLS(R, DM, S, API) \
-  BIN_OP_DECL (R, operator +, DM, S, API); \
-  BIN_OP_DECL (R, operator -, DM, S, API);
+  BIN_OP_DECL (R, operator *, DM, S, API); \
+  BIN_OP_DECL (R, operator /, DM, S, API);
 
 #define DMS_OP_DECLS(R, DM, S, API) \
   DMS_BIN_OP_DECLS(R, DM, S, API)
 
 // matrix by diagonal matrix operations.
 
 #define MDM_BIN_OP_DECLS(R, M, DM, API) \
   BIN_OP_DECL (R, operator +, M, DM, API); \
diff --git a/liboctave/mx-op-defs.h b/liboctave/mx-op-defs.h
--- a/liboctave/mx-op-defs.h
+++ b/liboctave/mx-op-defs.h
@@ -329,55 +329,48 @@ along with Octave; see the file COPYING.
   NDND_BOOL_OP (mx_el_or,      mx_inline_or,      ND1, ND2) \
   NDND_BOOL_OP (mx_el_not_and, mx_inline_not_and, ND1, ND2) \
   NDND_BOOL_OP (mx_el_not_or,  mx_inline_not_or,  ND1, ND2) \
   NDND_BOOL_OP (mx_el_and_not, mx_inline_and_not, ND1, ND2) \
   NDND_BOOL_OP (mx_el_or_not,  mx_inline_or_not,  ND1, ND2)
 
 // scalar by diagonal matrix operations.
 
-#define SDM_BIN_OP(R, OP, S, DM, OPEQ) \
+#define SDM_BIN_OP(R, OP, S, DM) \
   R \
-  OP (const S& s, const DM& dm) \
+  operator OP (const S& s, const DM& dm) \
   { \
-    octave_idx_type nr = dm.rows (); \
-    octave_idx_type nc = dm.cols (); \
- \
-    R r (nr, nc, s); \
+    R r (dm.rows (), dm.cols ()); \
  \
     for (octave_idx_type i = 0; i < dm.length (); i++) \
-      r.elem(i, i) OPEQ dm.elem(i, i); \
+      r.dgxelem (i) = s OP dm.dgelem (i); \
  \
     return r; \
 }
 
 #define SDM_BIN_OPS(R, S, DM) \
-  SDM_BIN_OP (R, operator +, S, DM, +=) \
-  SDM_BIN_OP (R, operator -, S, DM, -=)
+  SDM_BIN_OP (R, *, S, DM)
 
 // diagonal matrix by scalar operations.
 
-#define DMS_BIN_OP(R, OP, DM, S, SGN) \
+#define DMS_BIN_OP(R, OP, DM, S) \
   R \
-  OP (const DM& dm, const S& s) \
+  operator OP (const DM& dm, const S& s) \
   { \
-    octave_idx_type nr = dm.rows (); \
-    octave_idx_type nc = dm.cols (); \
- \
-    R r (nr, nc, SGN s); \
+    R r (dm.rows (), dm.cols ()); \
  \
     for (octave_idx_type i = 0; i < dm.length (); i++) \
-      r.elem(i, i) += dm.elem(i, i); \
+      r.dgxelem (i) = dm.dgelem (i) OP s; \
  \
     return r; \
   }
 
 #define DMS_BIN_OPS(R, DM, S) \
-  DMS_BIN_OP (R, operator +, DM, S, ) \
-  DMS_BIN_OP (R, operator -, DM, S, -)
+  DMS_BIN_OP (R, *, DM, S) \
+  DMS_BIN_OP (R, /, DM, S)
 
 // matrix by diagonal matrix operations.
 
 #define MDM_BIN_OP(R, OP, M, DM, OPEQ) \
 R \
 OP (const M& m, const DM& dm) \
 { \
   R r; \
diff --git a/liboctave/mx-ops b/liboctave/mx-ops
--- a/liboctave/mx-ops
+++ b/liboctave/mx-ops
@@ -77,75 +77,67 @@ pm PermMatrix PM PermMatrix.h YES static
 # op-type is one of
 #
 #  B: binary ops, + - * /
 #  C: comparison ops, < <= == != >= >
 #  L: logical ops, & |
 #
 cdm cdm dm B
 cdm dm cdm B
-cm cs cdm B
-cm cs dm B
+cdm cs dm B
 cm cs m BCL real NONE boolMatrix.h
 cnda cs nda BCL real NONE boolMatrix.h boolNDArray.h
-cm cdm cs B
 cm cdm cm B
 cm cdm m B
-cm cdm s B
+cdm cdm s B
 cm cm cdm B
 cm cm dm B
 cm cm m BCL real NONE boolMatrix.h
 cnda cnda nda BCL real NONE boolMatrix.h boolNDArray.h
 cm cm s BCL real NONE boolMatrix.h
 cnda cnda s BCL real NONE boolMatrix.h boolNDArray.h
-cm dm cs B
+cdm dm cs B
 cm dm cm B
 cm m cs BCL NONE real boolMatrix.h
 cnda nda cs BCL NONE real boolMatrix.h boolNDArray.h
 cm m cdm B
 cm m cm BCL NONE real boolMatrix.h
 cnda nda cnda BCL NONE real boolMatrix.h boolNDArray.h
-cm s cdm B
+cdm s cdm B
 cm s cm BCL NONE real boolMatrix.h
 cnda s cnda BCL NONE real boolMatrix.h boolNDArray.h
 m dm m B
-m dm s B
 m m dm B
-m s dm B
 #
 fcdm fcdm fdm B
 fcdm fdm fcdm B
-fcm fcs fcdm B
-fcm fcs fdm B
+fcdm fcs fdm B
 fcm fcs fm BCL real NONE boolMatrix.h
 fcnda fcs fnda BCL real NONE boolMatrix.h boolNDArray.h
-fcm fcdm fcs B
 fcm fcdm fcm B
 fcm fcdm fm B
-fcm fcdm fs B
+fcdm fcdm fs B
 fcm fcm fcdm B
 fcm fcm fdm B
 fcm fcm fm BCL real NONE boolMatrix.h
 fcnda fcnda fnda BCL real NONE boolMatrix.h boolNDArray.h
 fcm fcm fs BCL real NONE boolMatrix.h
 fcnda fcnda fs BCL real NONE boolMatrix.h boolNDArray.h
-fcm fdm fcs B
+fcdm fdm fcs B
 fcm fdm fcm B
 fcm fm fcs BCL NONE real boolMatrix.h
 fcnda fnda fcs BCL NONE real boolMatrix.h boolNDArray.h
 fcm fm fcdm B
 fcm fm fcm BCL NONE real boolMatrix.h
 fcnda fnda fcnda BCL NONE real boolMatrix.h boolNDArray.h
-fcm fs fcdm B
+fcdm fs fcdm B
 fcm fs fcm BCL NONE real boolMatrix.h
 fcnda fs fcnda BCL NONE real boolMatrix.h boolNDArray.h
 fm fdm fm B
-fm fdm fs B
 fm fm fdm B
-fm fs fdm B
 #
 m pm m B
 m m pm B
 cm pm cm B
 cm cm pm B
 fm pm fm B
 fm fm pm B
 fcm pm fcm B
diff --git a/src/Cell.cc b/src/Cell.cc
--- a/src/Cell.cc
+++ b/src/Cell.cc
@@ -28,22 +28,22 @@ along with Octave; see the file COPYING.
 #include "idx-vector.h"
 
 #include "Cell.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 
 Cell::Cell (const octave_value_list& ovl)
-  : ArrayN<octave_value> (ovl.cell_value ())
+  : Array<octave_value> (ovl.cell_value ())
 {
 }
 
 Cell::Cell (const string_vector& sv, bool trim)
-  : ArrayN<octave_value> ()
+  : Array<octave_value> ()
 {
   octave_idx_type n = sv.length ();
 
   if (n > 0)
     {
       resize (dim_vector (n, 1));
 
       for (octave_idx_type i = 0; i < n; i++)
@@ -58,32 +58,32 @@ Cell::Cell (const string_vector& sv, boo
 	    }
 
 	  elem(i,0) = s;
 	}
     }
 }
 
 Cell::Cell (const Array<std::string>& sa)
-  : ArrayN<octave_value> (sa.dims ())
+  : Array<octave_value> (sa.dims ())
 {
   octave_idx_type n = sa.numel ();
 
   octave_value *dst = fortran_vec ();
   const std::string *src = sa.data ();
 
   for (octave_idx_type i = 0; i < n; i++)
     dst[i] = src[i];
 }
 
 // Set size to DV, filling with [].  Then fill with as many elements of
 // SV as possible.
 
 Cell::Cell (const dim_vector& dv, const string_vector& sv, bool trim)
-  : ArrayN<octave_value> (dv, resize_fill_value ())
+  : Array<octave_value> (dv, resize_fill_value ())
 {
   octave_idx_type n = sv.length ();
 
   if (n > 0)
     {
       octave_idx_type m = numel ();
 
       octave_idx_type len = n > m ? m : n;
@@ -134,30 +134,30 @@ Cell::index (const octave_value_list& id
       retval = *this;
       break;
 
     case 1:
       {
 	idx_vector i = idx_arg(0).index_vector ();
 
 	if (! error_state)
-	  retval = ArrayN<octave_value>::index (i, resize_ok, resize_fill_value ());
+	  retval = Array<octave_value>::index (i, resize_ok, resize_fill_value ());
       }
       break;
 
     case 2:
       {
 	idx_vector i = idx_arg(0).index_vector ();
 
 	if (! error_state)
 	  {
 	    idx_vector j = idx_arg(1).index_vector ();
 
 	    if (! error_state)
-	      retval = ArrayN<octave_value>::index (i, j, resize_ok,
+	      retval = Array<octave_value>::index (i, j, resize_ok,
                                                     resize_fill_value ());
 	  }
       }
       break;
 
     default:
       {
 	Array<idx_vector> iv (n);
@@ -166,17 +166,17 @@ Cell::index (const octave_value_list& id
 	  {
 	    iv(i) = idx_arg(i).index_vector ();
 
 	    if (error_state)
 	      break;
 	  }
 
 	if (!error_state)
-	  retval = ArrayN<octave_value>::index (iv, resize_ok,
+	  retval = Array<octave_value>::index (iv, resize_ok,
                                                 resize_fill_value ());
       }
       break;
     }
 
   return retval;
 }
 
@@ -277,16 +277,16 @@ Cell::map (ctype_mapper fcn) const
     r[i] = ((p++)->*fcn) ();
 
   return retval;
 }
 
 Cell
 Cell::diag (octave_idx_type k) const
 {
-  return ArrayN<octave_value>::diag (k);
+  return Array<octave_value>::diag (k);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/Cell.h b/src/Cell.h
--- a/src/Cell.h
+++ b/src/Cell.h
@@ -21,73 +21,70 @@ along with Octave; see the file COPYING.
 
 */
 
 #if !defined (Cell_h)
 #define Cell_h 1
 
 #include <string>
 
-#include "ArrayN.h"
+#include "Array.h"
 #include "oct-alloc.h"
 #include "str-vec.h"
 #include "ov.h"
 
 class octave_value_list;
 
 class
 OCTINTERP_API
-Cell : public ArrayN<octave_value>
+Cell : public Array<octave_value>
 {
 public:
 
   Cell (void)
-    : ArrayN<octave_value> (dim_vector (0, 0)) { }
+    : Array<octave_value> (dim_vector (0, 0)) { }
 
   Cell (const octave_value& val)
-    : ArrayN<octave_value> (dim_vector (1, 1), val) { }
+    : Array<octave_value> (dim_vector (1, 1), val) { }
 
   Cell (const octave_value_list& ovl);
 
   Cell (octave_idx_type n, octave_idx_type m,
 	const octave_value& val = resize_fill_value ())
-    : ArrayN<octave_value> (dim_vector (n, m), val) { }
+    : Array<octave_value> (dim_vector (n, m), val) { }
 
   Cell (const dim_vector& dv, const octave_value& val = resize_fill_value ())
-    : ArrayN<octave_value> (dv, val) { }
-
-  Cell (const ArrayN<octave_value>& c)
-    : ArrayN<octave_value> (c) { }
+    : Array<octave_value> (dv, val) { }
 
   Cell (const Array<octave_value>& c)
-    : ArrayN<octave_value> (c) { }
+    : Array<octave_value> (c) { }
 
   Cell (const Array<octave_value>& c, octave_idx_type nr, octave_idx_type nc)
-    : ArrayN<octave_value> (c, dim_vector (nr, nc)) { }
+    : Array<octave_value> (c, dim_vector (nr, nc)) { }
 
   Cell (const string_vector& sv, bool trim = false);
 
   Cell (const Array<std::string>& sa);
 
   Cell (const dim_vector& dv, const string_vector& sv, bool trim = false);
 
   Cell (const Cell& c)
-    : ArrayN<octave_value> (c) { }
+    : Array<octave_value> (c) { }
 
   bool is_cellstr (void) const;
 
   Cell index (const octave_value_list& idx, bool resize_ok = false) const;
 
   Cell& delete_elements (const octave_value_list& idx);
 
   Cell& assign (const octave_value_list& idx, const Cell& rhs,
 		const octave_value& fill_val = resize_fill_value ());
 
   Cell reshape (const dim_vector& new_dims) const
-    { return ArrayN<octave_value>::reshape (new_dims); }
+    { return Array<octave_value>::reshape (new_dims); }
 
   octave_idx_type nnz (void) const;
 
   Cell column (octave_idx_type i) const;
 
   // FIXME
   boolMatrix all (int /* dim */ = 0) const { return boolMatrix (); }
 
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,36 @@
+2009-10-16  Jaroslav Hajek  <highegg@gmail.com>
+
+	* Cell.cc: Remove traces of ArrayN.
+	* Cell.h: Ditto.
+	* DLD-FUNCTIONS/besselj.cc: Ditto.
+	* DLD-FUNCTIONS/find.cc: Ditto.
+	* DLD-FUNCTIONS/lookup.cc: Ditto.
+	* DLD-FUNCTIONS/max.cc: Ditto.
+	* TEMPLATE-INST/Array-tc.cc: Ditto.
+	* data.cc: Ditto.
+	* oct-map.cc: Ditto.
+	* ov-cx-mat.h: Ditto.
+	* ov-flt-cx-mat.cc: Ditto.
+	* ov-flt-cx-mat.h: Ditto.
+	* ov-flt-re-mat.cc: Ditto.
+	* ov-flt-re-mat.h: Ditto.
+	* ov-intx.h: Ditto.
+	* ov-re-mat.h: Ditto.
+	* ov.cc: Ditto.
+	* ov.h: Ditto.
+	* pr-output.cc: Ditto.
+	* pr-output.h: Ditto.
+	* variables.cc: Ditto.
+
+	* OPERATORS/op-dm-scm.cc: Avoid using dm + s, dm - s operators.
+	* OPERATORS/op-dm-sm.cc: Ditto.
+	* OPERATORS/op-dms-template.cc: Ditto.
+
 2009-10-16  Jaroslav Hajek  <highegg@gmail.com>
 
 	* DLD-FUNCTIONS/cellfun.cc (Fnum2cell): Use Array<T>::column here.
 
 2009-10-15  Jaroslav Hajek  <highegg@gmail.com>
 
 	* DLD-FUNCTIONS/lookup.cc (Flookup): Update docstring.
 
diff --git a/src/DLD-FUNCTIONS/besselj.cc b/src/DLD-FUNCTIONS/besselj.cc
--- a/src/DLD-FUNCTIONS/besselj.cc
+++ b/src/DLD-FUNCTIONS/besselj.cc
@@ -128,17 +128,17 @@ do_bessel (enum bessel_type type, const 
 			gripe_bessel_arg (fn, "second");
 		    }
 		  else
 		    {
 		      FloatComplexNDArray x = x_arg.float_complex_array_value ();
 
 		      if (! error_state)
 			{
-			  ArrayN<octave_idx_type> ierr;
+			  Array<octave_idx_type> ierr;
 			  octave_value result;
 
 			  DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
 			  if (nargout > 1)
 			    retval(1) = NDArray (ierr);
 
 			  retval(0) = result;
@@ -192,17 +192,17 @@ do_bessel (enum bessel_type type, const 
 		  if (! error_state)
 		    {
 		      if (x_arg.is_scalar_type ())
 			{
 			  FloatComplex x = x_arg.float_complex_value ();
 
 			  if (! error_state)
 			    {
-			      ArrayN<octave_idx_type> ierr;
+			      Array<octave_idx_type> ierr;
 			      octave_value result;
 
 			      DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
 			      if (nargout > 1)
 				retval(1) = NDArray (ierr);
 
 			      retval(0) = result;
@@ -211,17 +211,17 @@ do_bessel (enum bessel_type type, const 
 			    gripe_bessel_arg (fn, "second");
 			}
 		      else
 			{
 			  FloatComplexNDArray x = x_arg.float_complex_array_value ();
 
 			  if (! error_state)
 			    {
-			      ArrayN<octave_idx_type> ierr;
+			      Array<octave_idx_type> ierr;
 			      octave_value result;
 			  
 			      DO_BESSEL (type, alpha, x, scaled, ierr, result);
 			  
 			      if (nargout > 1)
 				retval(1) = NDArray (ierr);
 
 			      retval(0) = result;
@@ -263,17 +263,17 @@ do_bessel (enum bessel_type type, const 
 			gripe_bessel_arg (fn, "second");
 		    }
 		  else
 		    {
 		      ComplexNDArray x = x_arg.complex_array_value ();
 
 		      if (! error_state)
 			{
-			  ArrayN<octave_idx_type> ierr;
+			  Array<octave_idx_type> ierr;
 			  octave_value result;
 
 			  DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
 			  if (nargout > 1)
 			    retval(1) = NDArray (ierr);
 
 			  retval(0) = result;
@@ -327,17 +327,17 @@ do_bessel (enum bessel_type type, const 
 		  if (! error_state)
 		    {
 		      if (x_arg.is_scalar_type ())
 			{
 			  Complex x = x_arg.complex_value ();
 
 			  if (! error_state)
 			    {
-			      ArrayN<octave_idx_type> ierr;
+			      Array<octave_idx_type> ierr;
 			      octave_value result;
 
 			      DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
 			      if (nargout > 1)
 				retval(1) = NDArray (ierr);
 
 			      retval(0) = result;
@@ -346,17 +346,17 @@ do_bessel (enum bessel_type type, const 
 			    gripe_bessel_arg (fn, "second");
 			}
 		      else
 			{
 			  ComplexNDArray x = x_arg.complex_array_value ();
 
 			  if (! error_state)
 			    {
-			      ArrayN<octave_idx_type> ierr;
+			      Array<octave_idx_type> ierr;
 			      octave_value result;
 			  
 			      DO_BESSEL (type, alpha, x, scaled, ierr, result);
 			  
 			      if (nargout > 1)
 				retval(1) = NDArray (ierr);
 
 			      retval(0) = result;
@@ -582,17 +582,17 @@ return @code{NaN}.\n\
 	  int idx = nargin == 1 ? 0 : 1;
 
 	  if (args (idx).is_single_type ())
 	    {
 	      FloatComplexNDArray z = args(idx).float_complex_array_value ();
 
 	      if (! error_state)
 		{
-		  ArrayN<octave_idx_type> ierr;
+		  Array<octave_idx_type> ierr;
 		  octave_value result;
 
 		  if (kind > 1)
 		    result = biry (z, kind == 3, scale, ierr);
 		  else
 		    result = airy (z, kind == 1, scale, ierr);
 
 		  if (nargout > 1)
@@ -604,17 +604,17 @@ return @code{NaN}.\n\
 		error ("airy: expecting complex matrix for Z");
 	    }
 	  else
 	    {
 	      ComplexNDArray z = args(idx).complex_array_value ();
 
 	      if (! error_state)
 		{
-		  ArrayN<octave_idx_type> ierr;
+		  Array<octave_idx_type> ierr;
 		  octave_value result;
 
 		  if (kind > 1)
 		    result = biry (z, kind == 3, scale, ierr);
 		  else
 		    result = airy (z, kind == 1, scale, ierr);
 
 		  if (nargout > 1)
diff --git a/src/DLD-FUNCTIONS/find.cc b/src/DLD-FUNCTIONS/find.cc
--- a/src/DLD-FUNCTIONS/find.cc
+++ b/src/DLD-FUNCTIONS/find.cc
@@ -48,17 +48,17 @@ find_nonzero_elem_idx (const Array<T>& n
     idx = nda.find (n_to_find, direction == -1);
   else
     idx = nda.find ();
 
   switch (nargout)
     {
     default:
     case 3:
-      retval(2) = ArrayN<T> (nda.index (idx_vector (idx)));
+      retval(2) = Array<T> (nda.index (idx_vector (idx)));
       // Fall through!
 
     case 2:
       {
         Array<octave_idx_type> jdx (idx.dims ());
         octave_idx_type n = idx.length (), nr = nda.rows ();
         for (octave_idx_type i = 0; i < n; i++)
           {
@@ -170,17 +170,17 @@ find_nonzero_elem_idx (const Sparse<T>& 
       scalar_arg = (v.columns () == 1);
     }
 
   Matrix idx (result_nr, result_nc);
 
   Matrix i_idx (result_nr, result_nc);
   Matrix j_idx (result_nr, result_nc);
 
-  ArrayN<T> val (dim_vector (result_nr, result_nc));
+  Array<T> val (dim_vector (result_nr, result_nc));
 
   if (count > 0)
     {
       // Search for elements to return.  Only search the region where
       // there are elements to be found using the count that we want
       // to find.
       for (octave_idx_type j = start_nc, cx = 0; j < end_nc; j++) 
 	for (octave_idx_type i = v.cidx(j); i < v.cidx(j+1); i++ ) 
@@ -280,17 +280,17 @@ find_nonzero_elem_idx (const PermMatrix&
     }
 
   bool scalar_arg = (v.rows () == 1 && v.cols () == 1);
 
   Matrix idx (count, 1);
   Matrix i_idx (count, 1);
   Matrix j_idx (count, 1);
   // Every value is 1.
-  ArrayN<double> val (dim_vector (count, 1), 1.0);
+  Array<double> val (dim_vector (count, 1), 1.0);
 
   if (count > 0)
     {
       const octave_idx_type* p = v.data ();
       if (v.is_col_perm ())
         {
           for (octave_idx_type k = 0; k < count; k++) 
             {
diff --git a/src/DLD-FUNCTIONS/lookup.cc b/src/DLD-FUNCTIONS/lookup.cc
--- a/src/DLD-FUNCTIONS/lookup.cc
+++ b/src/DLD-FUNCTIONS/lookup.cc
@@ -108,17 +108,17 @@ static octave_value
 do_numeric_lookup (const ArrayT& array, const ArrayT& values, 
                    bool left_inf, bool right_inf,
                    bool match_idx, bool match_bool)
 {
   octave_value retval;
 
   if (match_bool)
     {
-      boolNDArray match = ArrayN<bool> (array.lookupb (values));
+      boolNDArray match = Array<bool> (array.lookupb (values));
       retval = match;
     }
   else
     {
       Array<octave_idx_type> idx;
 
       if (match_idx)
         idx = array.lookupm (values);
diff --git a/src/DLD-FUNCTIONS/max.cc b/src/DLD-FUNCTIONS/max.cc
--- a/src/DLD-FUNCTIONS/max.cc
+++ b/src/DLD-FUNCTIONS/max.cc
@@ -66,17 +66,17 @@ along with Octave; see the file COPYING.
 	      retval(0) = n; \
 	    } \
 	} \
       else \
 	gripe_wrong_type_arg (#FCN, arg1); \
     } \
   else if (nargout == 2) \
     { \
-      ArrayN<octave_idx_type> index; \
+      Array<octave_idx_type> index; \
  \
       if (arg1.is_real_type ()) \
 	{ \
 	  NDArray m = arg1.array_value (); \
  \
 	  if (! error_state) \
 	    { \
 	      NDArray n = m. FCN (index, dim);	\
@@ -233,17 +233,17 @@ along with Octave; see the file COPYING.
 	      retval(0) = n; \
 	    } \
 	} \
       else \
 	gripe_wrong_type_arg (#FCN, arg1); \
     } \
   else if (nargout == 2) \
     { \
-      ArrayN<octave_idx_type> index; \
+      Array<octave_idx_type> index; \
  \
       if (arg1.is_real_type ()) \
 	{ \
 	  FloatNDArray m = arg1.float_array_value (); \
  \
 	  if (! error_state) \
 	    { \
 	      FloatNDArray n = m. FCN (index, dim);	\
@@ -385,17 +385,17 @@ along with Octave; see the file COPYING.
       if (! error_state) \
 	{ \
 	  TYP ## NDArray n = m. FCN (dim); \
 	  retval(0) = n; \
 	} \
     } \
   else if (nargout == 2) \
     { \
-      ArrayN<octave_idx_type> index; \
+      Array<octave_idx_type> index; \
  \
       TYP ## NDArray m = arg1. TYP ## _array_value (); \
  \
       if (! error_state) \
         { \
 	  TYP ## NDArray n = m. FCN (index, dim);	\
 	  retval(0) = n; \
 	} \
diff --git a/src/OPERATORS/op-dm-scm.cc b/src/OPERATORS/op-dm-scm.cc
--- a/src/OPERATORS/op-dm-scm.cc
+++ b/src/OPERATORS/op-dm-scm.cc
@@ -143,97 +143,97 @@ DEFBINOP (add_dm_scm, diag_matrix, spars
   CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_sparse_complex_matrix&);
 
   if (v2.rows() == 1 && v2.columns() == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
-      return octave_value (v1.diag_matrix_value () + d);
+      return octave_value (v1.matrix_value () + d);
     }
   else
     return v1.diag_matrix_value () + v2.sparse_complex_matrix_value ();
 }
 
 DEFBINOP (add_cdm_sm, complex_diag_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_diag_matrix&, const octave_sparse_matrix&);
 
   if (v2.rows() == 1 && v2.columns() == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
-      return octave_value (v1.complex_diag_matrix_value () + d);
+      return octave_value (v1.complex_matrix_value () + d);
     }
   else
     return v1.complex_diag_matrix_value () + v2.sparse_matrix_value ();
 }
 
 DEFBINOP (add_cdm_scm, complex_diag_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_diag_matrix&, const octave_sparse_complex_matrix&);
 
   if (v2.rows() == 1 && v2.columns() == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
-      return octave_value (v1.complex_diag_matrix_value () + d);
+      return octave_value (v1.complex_matrix_value () + d);
     }
   else
     return v1.complex_diag_matrix_value () + v2.sparse_complex_matrix_value ();
 }
 
 DEFBINOP (sub_dm_scm, diag_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_sparse_complex_matrix&);
 
   if (v2.rows() == 1 && v2.columns() == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
-      return octave_value (v1.diag_matrix_value () + (-d));
+      return octave_value (v1.matrix_value () + (-d));
     }
   else
     return v1.diag_matrix_value () - v2.sparse_complex_matrix_value ();
 }
 
 DEFBINOP (sub_cdm_sm, complex_diag_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_diag_matrix&, const octave_sparse_matrix&);
 
   if (v2.rows() == 1 && v2.columns() == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
-      return octave_value (v1.complex_diag_matrix_value () + (-d));
+      return octave_value (v1.complex_matrix_value () + (-d));
     }
   else
     return v1.complex_diag_matrix_value () - v2.sparse_matrix_value ();
 }
 
 DEFBINOP (sub_cdm_scm, complex_diag_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_diag_matrix&, const octave_sparse_complex_matrix&);
 
   if (v2.rows() == 1 && v2.columns() == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
-      return octave_value (v1.complex_diag_matrix_value () + (-d));
+      return octave_value (v1.complex_matrix_value () + (-d));
     }
   else
     return v1.complex_diag_matrix_value () - v2.sparse_complex_matrix_value ();
 }
 
 // sparse matrix by diagonal matrix ops
 
 DEFBINOP (mul_scm_dm, sparse_complex_matrix, diag_matrix)
diff --git a/src/OPERATORS/op-dm-sm.cc b/src/OPERATORS/op-dm-sm.cc
--- a/src/OPERATORS/op-dm-sm.cc
+++ b/src/OPERATORS/op-dm-sm.cc
@@ -73,33 +73,33 @@ DEFBINOP (add_dm_sm, diag_matrix, sparse
   CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_sparse_matrix&);
 
   if (v2.rows() == 1 && v2.columns() == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
-      return octave_value (v1.diag_matrix_value () + d);
+      return octave_value (v1.matrix_value () + d);
     }
   else
     return v1.diag_matrix_value () + v2.sparse_matrix_value ();
 }
 
 DEFBINOP (sub_dm_sm, diag_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_sparse_matrix&);
 
   if (v2.rows() == 1 && v2.columns() == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
-      return octave_value (v1.diag_matrix_value () - d);
+      return octave_value (v1.matrix_value () - d);
     }
   else
     return v1.diag_matrix_value () - v2.sparse_matrix_value ();
 }
 
 // sparse matrix by diagonal matrix ops
 
 DEFBINOP (mul_sm_dm, sparse_matrix, diag_matrix)
@@ -150,33 +150,33 @@ DEFBINOP (add_sm_dm, sparse_matrix, diag
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_diag_matrix&);
 
   if (v1.rows() == 1 && v1.columns() == 1)
     // If v1 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v1.scalar_value ();
 
-      return octave_value (d + v2.diag_matrix_value ());
+      return octave_value (d + v2.matrix_value ());
     }
   else
     return v1.sparse_matrix_value () + v2.diag_matrix_value ();
 }
 
 DEFBINOP (sub_sm_dm, sparse_matrix, diag_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_diag_matrix&);
 
   if (v1.rows() == 1 && v1.columns() == 1)
     // If v1 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v1.scalar_value ();
 
-      return octave_value (d - v2.diag_matrix_value ());
+      return octave_value (d - v2.matrix_value ());
     }
   else
     return v1.sparse_matrix_value () - v2.diag_matrix_value ();
 }
 
 void
 install_dm_sm_ops (void)
 {
diff --git a/src/OPERATORS/op-dms-template.cc b/src/OPERATORS/op-dms-template.cc
--- a/src/OPERATORS/op-dms-template.cc
+++ b/src/OPERATORS/op-dms-template.cc
@@ -35,21 +35,17 @@ along with Octave; see the file COPYING.
 #ifndef SCALARV
 #define SCALARV SCALAR
 #endif
 
 #ifndef MATRIXV
 #define MATRIXV MATRIX
 #endif
 
-DEFNDBINOP_OP (sdmadd, SCALAR, MATRIX, SCALARV, MATRIXV, +)
-DEFNDBINOP_OP (sdmsub, SCALAR, MATRIX, SCALARV, MATRIXV, -)
 DEFNDBINOP_OP (sdmmul, SCALAR, MATRIX, SCALARV, MATRIXV, *)
-DEFNDBINOP_OP (dmsadd, MATRIX, SCALAR, MATRIXV, SCALARV, +)
-DEFNDBINOP_OP (dmssub, MATRIX, SCALAR, MATRIXV, SCALARV, -)
 DEFNDBINOP_OP (dmsmul, MATRIX, SCALAR, MATRIXV, SCALARV, *)
 
 #define OCTAVE_MATRIX CONCAT2(octave_, MATRIX)
 #define OCTAVE_SCALAR CONCAT2(octave_, SCALAR)
 #define MATRIX_VALUE CONCAT2(MATRIXV, _value)
 #define SCALAR_VALUE CONCAT2(SCALARV, _value)
 
 template <class T>
@@ -83,18 +79,14 @@ DEFBINOP (dmspow, MATRIX, SCALAR)
 }
 
 #define SHORT_NAME CONCAT3(MSHORT, _, SSHORT)
 #define INST_NAME CONCAT3(install_, SHORT_NAME, _ops)
 
 void
 INST_NAME (void)
 {
-  INSTALL_BINOP (op_add, OCTAVE_MATRIX, OCTAVE_SCALAR, dmsadd);
-  INSTALL_BINOP (op_sub, OCTAVE_MATRIX, OCTAVE_SCALAR, dmssub);
   INSTALL_BINOP (op_mul, OCTAVE_MATRIX, OCTAVE_SCALAR, dmsmul);
   INSTALL_BINOP (op_div, OCTAVE_MATRIX, OCTAVE_SCALAR, dmsdiv);
-  INSTALL_BINOP (op_add, OCTAVE_SCALAR, OCTAVE_MATRIX, sdmadd);
-  INSTALL_BINOP (op_sub, OCTAVE_SCALAR, OCTAVE_MATRIX, sdmsub);
   INSTALL_BINOP (op_mul, OCTAVE_SCALAR, OCTAVE_MATRIX, sdmmul);
   INSTALL_BINOP (op_ldiv, OCTAVE_SCALAR, OCTAVE_MATRIX, sdmldiv);
   INSTALL_BINOP (op_pow, OCTAVE_MATRIX, OCTAVE_SCALAR, dmspow);
 }
diff --git a/src/TEMPLATE-INST/Array-tc.cc b/src/TEMPLATE-INST/Array-tc.cc
--- a/src/TEMPLATE-INST/Array-tc.cc
+++ b/src/TEMPLATE-INST/Array-tc.cc
@@ -27,28 +27,23 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "Array.h"
 #include "Array.cc"
 
 #include "Array2.h"
 
-#include "ArrayN.h"
-#include "ArrayN.cc"
-
 #include "ov.h"
 
 #include "oct-sort.cc"
 
 NO_INSTANTIATE_ARRAY_SORT (octave_value);
 
 INSTANTIATE_ARRAY (octave_value, OCTINTERP_API);
 
 template class OCTINTERP_API Array2<octave_value>;
 
-template class OCTINTERP_API ArrayN<octave_value>;
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -6258,17 +6258,17 @@ do_accumarray_sum (const idx_vector& idx
   else if (vals.length () == idx.length (n))
     {
       array = MArray<T> (n, T ());
       array.idx_add (idx, MArray<T> (vals));
     }
   else
     error ("accumarray: dimensions mismatch");
 
-  return NDT (MArrayN<T> (ArrayN<T> (array)));
+  return NDT (MArrayN<T> (Array<T> (array)));
 }
 
 DEFUN (__accumarray_sum__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __accumarray_sum__ (@var{idx}, @var{vals}, @var{n})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
diff --git a/src/oct-map.cc b/src/oct-map.cc
--- a/src/oct-map.cc
+++ b/src/oct-map.cc
@@ -504,17 +504,17 @@ Octave_map::index (const octave_value_li
         }
 
       if (! error_state)
         {
           for (const_iterator p = begin (); p != end (); p++)
             {
               Cell tmp = contents (p);
 
-              tmp = tmp.ArrayN<octave_value>::index (ra_idx, resize_ok);
+              tmp = tmp.Array<octave_value>::index (ra_idx, resize_ok);
 
               if (error_state)
                 break;
 
               retval.assign (key(p), tmp);
             }
 
           // Preserve order of keys.
diff --git a/src/ov-cx-mat.h b/src/ov-cx-mat.h
--- a/src/ov-cx-mat.h
+++ b/src/ov-cx-mat.h
@@ -61,17 +61,17 @@ public:
     : octave_base_matrix<ComplexNDArray> (m) { }
 
   octave_complex_matrix (const ComplexMatrix& m)
     : octave_base_matrix<ComplexNDArray> (m) { }
 
   octave_complex_matrix (const ComplexMatrix& m, const MatrixType& t)
     : octave_base_matrix<ComplexNDArray> (m, t) { }
 
-  octave_complex_matrix (const ArrayN<Complex>& m)
+  octave_complex_matrix (const Array<Complex>& m)
     : octave_base_matrix<ComplexNDArray> (ComplexNDArray (m)) { }
 
   octave_complex_matrix (const ComplexDiagMatrix& d)
     : octave_base_matrix<ComplexNDArray> (ComplexMatrix (d)) { }
 
   octave_complex_matrix (const ComplexRowVector& v)
     : octave_base_matrix<ComplexNDArray> (ComplexMatrix (v)) { }
 
diff --git a/src/ov-flt-cx-mat.cc b/src/ov-flt-cx-mat.cc
--- a/src/ov-flt-cx-mat.cc
+++ b/src/ov-flt-cx-mat.cc
@@ -254,25 +254,25 @@ SparseMatrix
 octave_float_complex_matrix::sparse_matrix_value (bool force_conversion) const
 {
   SparseMatrix retval;
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
 			       "complex matrix", "real matrix");
 
-  retval = SparseMatrix (::real (matrix.matrix_value ()));
+  retval = SparseMatrix (::real (complex_matrix_value ()));
 
   return retval;
 }
 
 SparseComplexMatrix
 octave_float_complex_matrix::sparse_complex_matrix_value (bool) const
 {
-  return SparseComplexMatrix (matrix.matrix_value ());
+  return SparseComplexMatrix (complex_matrix_value ());
 }
 
 octave_value
 octave_float_complex_matrix::diag (octave_idx_type k) const
 {
   octave_value retval;
   if (k == 0 && matrix.ndims () == 2 
       && (matrix.rows () == 1 || matrix.columns () == 1))
diff --git a/src/ov-flt-cx-mat.h b/src/ov-flt-cx-mat.h
--- a/src/ov-flt-cx-mat.h
+++ b/src/ov-flt-cx-mat.h
@@ -61,17 +61,17 @@ public:
     : octave_base_matrix<FloatComplexNDArray> (m) { }
 
   octave_float_complex_matrix (const FloatComplexMatrix& m)
     : octave_base_matrix<FloatComplexNDArray> (m) { }
 
   octave_float_complex_matrix (const FloatComplexMatrix& m, const MatrixType& t)
     : octave_base_matrix<FloatComplexNDArray> (m, t) { }
 
-  octave_float_complex_matrix (const ArrayN<FloatComplex>& m)
+  octave_float_complex_matrix (const Array<FloatComplex>& m)
     : octave_base_matrix<FloatComplexNDArray> (FloatComplexNDArray (m)) { }
 
   octave_float_complex_matrix (const FloatComplexDiagMatrix& d)
     : octave_base_matrix<FloatComplexNDArray> (FloatComplexMatrix (d)) { }
 
   octave_float_complex_matrix (const FloatComplexRowVector& v)
     : octave_base_matrix<FloatComplexNDArray> (FloatComplexMatrix (v)) { }
 
diff --git a/src/ov-flt-re-mat.cc b/src/ov-flt-re-mat.cc
--- a/src/ov-flt-re-mat.cc
+++ b/src/ov-flt-re-mat.cc
@@ -233,17 +233,17 @@ octave_float_matrix::char_array_value (b
     retval.elem (i) = static_cast<char>(matrix.elem (i));
 
   return retval;
 }
   
 SparseMatrix 
 octave_float_matrix::sparse_matrix_value (bool) const
 {
-  return SparseMatrix (matrix.matrix_value ());
+  return SparseMatrix (matrix_value ());
 }
 
 SparseComplexMatrix 
 octave_float_matrix::sparse_complex_matrix_value (bool) const
 {
   // FIXME Need a SparseComplexMatrix (Matrix) constructor to make
   // this function more efficient. Then this should become
   // return SparseComplexMatrix (matrix.matrix_value ());
diff --git a/src/ov-flt-re-mat.h b/src/ov-flt-re-mat.h
--- a/src/ov-flt-re-mat.h
+++ b/src/ov-flt-re-mat.h
@@ -61,17 +61,17 @@ public:
     : octave_base_matrix<FloatNDArray> (m) { }
 
   octave_float_matrix (const FloatMatrix& m, const MatrixType& t)
     : octave_base_matrix<FloatNDArray> (m, t) { }
 
   octave_float_matrix (const FloatNDArray& nda)
     : octave_base_matrix<FloatNDArray> (nda) { }
 
-  octave_float_matrix (const ArrayN<float>& m)
+  octave_float_matrix (const Array<float>& m)
     : octave_base_matrix<FloatNDArray> (FloatNDArray (m)) { }
 
   octave_float_matrix (const FloatDiagMatrix& d)
     : octave_base_matrix<FloatNDArray> (FloatMatrix (d)) { }
 
   octave_float_matrix (const FloatRowVector& v)
     : octave_base_matrix<FloatNDArray> (FloatMatrix (v)) { }
 
diff --git a/src/ov-intx.h b/src/ov-intx.h
--- a/src/ov-intx.h
+++ b/src/ov-intx.h
@@ -47,17 +47,17 @@ OCTAVE_VALUE_INT_MATRIX_T
 public:
 
   OCTAVE_VALUE_INT_MATRIX_T (void)
     : octave_base_int_matrix<intNDArray<OCTAVE_INT_T> > () { }
 
   OCTAVE_VALUE_INT_MATRIX_T (const intNDArray<OCTAVE_INT_T>& nda)
     : octave_base_int_matrix<intNDArray<OCTAVE_INT_T> > (nda) { }
 
-  OCTAVE_VALUE_INT_MATRIX_T (const ArrayN<OCTAVE_INT_T>& nda)
+  OCTAVE_VALUE_INT_MATRIX_T (const Array<OCTAVE_INT_T>& nda)
     : octave_base_int_matrix<intNDArray<OCTAVE_INT_T> >
         (intNDArray<OCTAVE_INT_T> (nda)) { }
 
   ~OCTAVE_VALUE_INT_MATRIX_T (void) { }
 
   octave_base_value *clone (void) const
     { return new OCTAVE_VALUE_INT_MATRIX_T (*this); }
 
diff --git a/src/ov-re-mat.h b/src/ov-re-mat.h
--- a/src/ov-re-mat.h
+++ b/src/ov-re-mat.h
@@ -61,17 +61,17 @@ public:
     : octave_base_matrix<NDArray> (m) { }
 
   octave_matrix (const Matrix& m, const MatrixType& t)
     : octave_base_matrix<NDArray> (m, t) { }
 
   octave_matrix (const NDArray& nda)
     : octave_base_matrix<NDArray> (nda) { }
 
-  octave_matrix (const ArrayN<double>& m)
+  octave_matrix (const Array<double>& m)
     : octave_base_matrix<NDArray> (NDArray (m)) { }
 
   octave_matrix (const DiagMatrix& d)
     : octave_base_matrix<NDArray> (Matrix (d)) { }
 
   octave_matrix (const RowVector& v)
     : octave_base_matrix<NDArray> (Matrix (v)) { }
 
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -581,17 +581,17 @@ octave_value::octave_value (float d)
 
 octave_value::octave_value (const Cell& c, bool is_csl)
   : rep (is_csl
 	 ? dynamic_cast<octave_base_value *> (new octave_cs_list (c))
 	 : dynamic_cast<octave_base_value *> (new octave_cell (c)))
 {
 }
 
-octave_value::octave_value (const ArrayN<octave_value>& a, bool is_csl)
+octave_value::octave_value (const Array<octave_value>& a, bool is_csl)
   : rep (is_csl
 	 ? dynamic_cast<octave_base_value *> (new octave_cs_list (Cell (a)))
 	 : dynamic_cast<octave_base_value *> (new octave_cell (Cell (a))))
 {
 }
 
 octave_value::octave_value (const Matrix& m, const MatrixType& t)
   : rep (new octave_matrix (m, t))
@@ -612,23 +612,23 @@ octave_value::octave_value (const NDArra
 }
 
 octave_value::octave_value (const FloatNDArray& a)
   : rep (new octave_float_matrix (a))
 {
   maybe_mutate ();
 }
 
-octave_value::octave_value (const ArrayN<double>& a)
+octave_value::octave_value (const Array<double>& a)
   : rep (new octave_matrix (a))
 {
   maybe_mutate ();
 }
 
-octave_value::octave_value (const ArrayN<float>& a)
+octave_value::octave_value (const Array<float>& a)
   : rep (new octave_float_matrix (a))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const DiagMatrix& d)
   : rep (new octave_diag_matrix (d))
 {
@@ -696,23 +696,23 @@ octave_value::octave_value (const Comple
 }
 
 octave_value::octave_value (const FloatComplexNDArray& a)
   : rep (new octave_float_complex_matrix (a))
 {
   maybe_mutate ();
 }
 
-octave_value::octave_value (const ArrayN<Complex>& a)
+octave_value::octave_value (const Array<Complex>& a)
   : rep (new octave_complex_matrix (a))
 {
   maybe_mutate ();
 }
 
-octave_value::octave_value (const ArrayN<FloatComplex>& a)
+octave_value::octave_value (const Array<FloatComplex>& a)
   : rep (new octave_float_complex_matrix (a))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const ComplexDiagMatrix& d)
   : rep (new octave_complex_diag_matrix (d))
 {
@@ -767,17 +767,17 @@ octave_value::octave_value (const boolMa
 }
 
 octave_value::octave_value (const boolNDArray& bnda)
   : rep (new octave_bool_matrix (bnda))
 {
   maybe_mutate ();
 }
 
-octave_value::octave_value (const ArrayN<bool>& bnda)
+octave_value::octave_value (const Array<bool>& bnda)
   : rep (new octave_bool_matrix (bnda))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (char c, char type)
   : rep (type == '"'
 	 ? new octave_char_matrix_dq_str (c)
@@ -821,17 +821,17 @@ octave_value::octave_value (const charMa
 octave_value::octave_value (const charNDArray& chm, char type)
   : rep (type == '"'
 	 ? new octave_char_matrix_dq_str (chm)
 	 : new octave_char_matrix_sq_str (chm))
 {
   maybe_mutate ();
 }
 
-octave_value::octave_value (const ArrayN<char>& chm, char type)
+octave_value::octave_value (const Array<char>& chm, char type)
   : rep (type == '"'
 	 ? new octave_char_matrix_dq_str (chm)
 	 : new octave_char_matrix_sq_str (chm))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const charMatrix& chm, bool, char type)
@@ -845,17 +845,17 @@ octave_value::octave_value (const charMa
 octave_value::octave_value (const charNDArray& chm, bool, char type)
   : rep (type == '"'
 	 ? new octave_char_matrix_dq_str (chm)
 	 : new octave_char_matrix_sq_str (chm))
 {
   maybe_mutate ();
 }
 
-octave_value::octave_value (const ArrayN<char>& chm, bool, char type)
+octave_value::octave_value (const Array<char>& chm, bool, char type)
   : rep (type == '"'
 	 ? new octave_char_matrix_dq_str (chm)
 	 : new octave_char_matrix_sq_str (chm))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const SparseMatrix& m, const MatrixType &t)
@@ -943,101 +943,101 @@ octave_value::octave_value (const octave
 }
 
 octave_value::octave_value (const int8NDArray& inda)
   : rep (new octave_int8_matrix (inda))
 {
   maybe_mutate ();
 }
 
-octave_value::octave_value (const ArrayN<octave_int8>& inda)
+octave_value::octave_value (const Array<octave_int8>& inda)
   : rep (new octave_int8_matrix (inda))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const uint8NDArray& inda)
   : rep (new octave_uint8_matrix (inda))
 {
   maybe_mutate ();
 }
 
-octave_value::octave_value (const ArrayN<octave_uint8>& inda)
+octave_value::octave_value (const Array<octave_uint8>& inda)
   : rep (new octave_uint8_matrix (inda))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const int16NDArray& inda)
   : rep (new octave_int16_matrix (inda))
 {
   maybe_mutate ();
 }
 
-octave_value::octave_value (const ArrayN<octave_int16>& inda)
+octave_value::octave_value (const Array<octave_int16>& inda)
   : rep (new octave_int16_matrix (inda))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const uint16NDArray& inda)
   : rep (new octave_uint16_matrix (inda))
 {
   maybe_mutate ();
 }
 
-octave_value::octave_value (const ArrayN<octave_uint16>& inda)
+octave_value::octave_value (const Array<octave_uint16>& inda)
   : rep (new octave_uint16_matrix (inda))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const int32NDArray& inda)
   : rep (new octave_int32_matrix (inda))
 {
   maybe_mutate ();
 }
 
-octave_value::octave_value (const ArrayN<octave_int32>& inda)
+octave_value::octave_value (const Array<octave_int32>& inda)
   : rep (new octave_int32_matrix (inda))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const uint32NDArray& inda)
   : rep (new octave_uint32_matrix (inda))
 {
   maybe_mutate ();
 }
 
-octave_value::octave_value (const ArrayN<octave_uint32>& inda)
+octave_value::octave_value (const Array<octave_uint32>& inda)
   : rep (new octave_uint32_matrix (inda))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const int64NDArray& inda)
   : rep (new octave_int64_matrix (inda))
 {
   maybe_mutate ();
 }
 
-octave_value::octave_value (const ArrayN<octave_int64>& inda)
+octave_value::octave_value (const Array<octave_int64>& inda)
   : rep (new octave_int64_matrix (inda))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const uint64NDArray& inda)
   : rep (new octave_uint64_matrix (inda))
 {
   maybe_mutate ();
 }
 
-octave_value::octave_value (const ArrayN<octave_uint64>& inda)
+octave_value::octave_value (const Array<octave_uint64>& inda)
   : rep (new octave_uint64_matrix (inda))
 {
   maybe_mutate ();
 }
 
 octave_value::octave_value (const Array<octave_idx_type>& inda, bool zero_based,
                             bool cache_index)
   : rep (new octave_matrix (inda, zero_based, cache_index))
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -185,61 +185,61 @@ public:
 #endif
 #if defined (HAVE_UNSIGNED_LONG_LONG_INT)
   octave_value (unsigned long long int i);
 #endif
 
   octave_value (octave_time t);
   octave_value (double d);
   octave_value (float d);
-  octave_value (const ArrayN<octave_value>& a, bool is_cs_list = false);
+  octave_value (const Array<octave_value>& a, bool is_cs_list = false);
   octave_value (const Cell& c, bool is_cs_list = false);
   octave_value (const Matrix& m, const MatrixType& t = MatrixType());
   octave_value (const FloatMatrix& m, const MatrixType& t = MatrixType());
   octave_value (const NDArray& nda);
   octave_value (const FloatNDArray& nda);
-  octave_value (const ArrayN<double>& m);
-  octave_value (const ArrayN<float>& m);
+  octave_value (const Array<double>& m);
+  octave_value (const Array<float>& m);
   octave_value (const DiagMatrix& d);
   octave_value (const FloatDiagMatrix& d);
   octave_value (const RowVector& v);
   octave_value (const FloatRowVector& v);
   octave_value (const ColumnVector& v);
   octave_value (const FloatColumnVector& v);
   octave_value (const Complex& C);
   octave_value (const FloatComplex& C);
   octave_value (const ComplexMatrix& m, const MatrixType& t = MatrixType());
   octave_value (const FloatComplexMatrix& m, const MatrixType& t = MatrixType());
   octave_value (const ComplexNDArray& cnda);
   octave_value (const FloatComplexNDArray& cnda);
-  octave_value (const ArrayN<Complex>& m);
-  octave_value (const ArrayN<FloatComplex>& m);
+  octave_value (const Array<Complex>& m);
+  octave_value (const Array<FloatComplex>& m);
   octave_value (const ComplexDiagMatrix& d);
   octave_value (const FloatComplexDiagMatrix& d);
   octave_value (const ComplexRowVector& v);
   octave_value (const FloatComplexRowVector& v);
   octave_value (const ComplexColumnVector& v);
   octave_value (const FloatComplexColumnVector& v);
   octave_value (const PermMatrix& p);
   octave_value (bool b);
   octave_value (const boolMatrix& bm, const MatrixType& t = MatrixType());
   octave_value (const boolNDArray& bnda);
-  octave_value (const ArrayN<bool>& bnda);
+  octave_value (const Array<bool>& bnda);
   octave_value (char c, char type = '\'');
   octave_value (const char *s, char type = '\'');
   octave_value (const std::string& s, char type = '\'');
   octave_value (const string_vector& s, char type = '\'');
   octave_value (const charMatrix& chm, 	char type = '\'');
   octave_value (const charNDArray& chnda, char type = '\'');
-  octave_value (const ArrayN<char>& chnda, char type = '\'');
+  octave_value (const Array<char>& chnda, char type = '\'');
   octave_value (const charMatrix& chm, bool is_string,
 		char type = '\'') GCC_ATTR_DEPRECATED;
   octave_value (const charNDArray& chnda, bool is_string,
 		char type = '\'') GCC_ATTR_DEPRECATED;
-  octave_value (const ArrayN<char>& chnda, bool is_string,
+  octave_value (const Array<char>& chnda, bool is_string,
 		char type = '\'') GCC_ATTR_DEPRECATED;
   octave_value (const SparseMatrix& m, const MatrixType& t = MatrixType ());
   octave_value (const Sparse<double>& m, const MatrixType& t = MatrixType ());
   octave_value (const SparseComplexMatrix& m, 
 		const MatrixType& t = MatrixType ());
   octave_value (const Sparse<Complex>& m, const MatrixType& t = MatrixType ());
   octave_value (const SparseBoolMatrix& bm, 
 		const MatrixType& t = MatrixType ());
@@ -248,31 +248,31 @@ public:
   octave_value (const octave_int16& i);
   octave_value (const octave_int32& i);
   octave_value (const octave_int64& i);
   octave_value (const octave_uint8& i);
   octave_value (const octave_uint16& i);
   octave_value (const octave_uint32& i);
   octave_value (const octave_uint64& i);
   octave_value (const int8NDArray& inda);
-  octave_value (const ArrayN<octave_int8>& inda);
+  octave_value (const Array<octave_int8>& inda);
   octave_value (const int16NDArray& inda);
-  octave_value (const ArrayN<octave_int16>& inda);
+  octave_value (const Array<octave_int16>& inda);
   octave_value (const int32NDArray& inda);
-  octave_value (const ArrayN<octave_int32>& inda);
+  octave_value (const Array<octave_int32>& inda);
   octave_value (const int64NDArray& inda);
-  octave_value (const ArrayN<octave_int64>& inda);
+  octave_value (const Array<octave_int64>& inda);
   octave_value (const uint8NDArray& inda);
-  octave_value (const ArrayN<octave_uint8>& inda);
+  octave_value (const Array<octave_uint8>& inda);
   octave_value (const uint16NDArray& inda);
-  octave_value (const ArrayN<octave_uint16>& inda);
+  octave_value (const Array<octave_uint16>& inda);
   octave_value (const uint32NDArray& inda);
-  octave_value (const ArrayN<octave_uint32>& inda);
+  octave_value (const Array<octave_uint32>& inda);
   octave_value (const uint64NDArray& inda);
-  octave_value (const ArrayN<octave_uint64>& inda);
+  octave_value (const Array<octave_uint64>& inda);
   octave_value (const Array<octave_idx_type>& inda, 
                 bool zero_based = false, bool cache_index = false);
   octave_value (const Array<std::string>& cellstr);
   octave_value (const idx_vector& idx);
   octave_value (double base, double limit, double inc);
   octave_value (const Range& r);
   octave_value (const Octave_map& m);
   octave_value (const Octave_map& m, const std::string& id);
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -2656,23 +2656,23 @@ octave_print_internal (std::ostream& os,
       break;
     }
 }
 
 void
 octave_print_internal (std::ostream& os, const std::string& s,
 		       bool pr_as_read_syntax, int extra_indent)
 {
-  ArrayN<std::string> nda (dim_vector (1, 1), s);
+  Array<std::string> nda (dim_vector (1, 1), s);
 
   octave_print_internal (os, nda, pr_as_read_syntax, extra_indent);
 }
 
 void
-octave_print_internal (std::ostream& os, const ArrayN<std::string>& nda,
+octave_print_internal (std::ostream& os, const Array<std::string>& nda,
 		       bool pr_as_read_syntax, int /* extra_indent */)
 {
   // FIXME -- this mostly duplicates the code in the
   // PRINT_ND_ARRAY macro.
 
   if (nda.is_empty ())
     print_empty_nd_array (os, nda.dims (), pr_as_read_syntax);
   else if (nda.length () == 1)
diff --git a/src/pr-output.h b/src/pr-output.h
--- a/src/pr-output.h
+++ b/src/pr-output.h
@@ -23,17 +23,17 @@ along with Octave; see the file COPYING.
 
 #if !defined (octave_pr_output_h)
 #define octave_pr_output_h 1
 
 #include <iosfwd>
 
 #include "oct-cmplx.h"
 
-template <typename T> class ArrayN;
+template <typename T> class Array;
 class ComplexMatrix;
 class FloatComplexMatrix;
 class ComplexDiagMatrix;
 class FloatComplexDiagMatrix;
 class ComplexNDArray;
 class FloatComplexNDArray;
 class Matrix;
 class FloatMatrix;
@@ -166,17 +166,17 @@ octave_print_internal (std::ostream& os,
 		       bool pr_as_string = false);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const std::string& s,
 		       bool pr_as_read_syntax = false,
 		       int extra_indent = 0);
 
 extern OCTINTERP_API void
-octave_print_internal (std::ostream& os, const ArrayN<std::string>& sa,
+octave_print_internal (std::ostream& os, const Array<std::string>& sa,
 		       bool pr_as_read_syntax = false,
 		       int extra_indent = 0);
 
 extern OCTINTERP_API void
 octave_print_internal (std::ostream& os, const intNDArray<octave_int8>& sa,
 		       bool pr_as_read_syntax = false,
 		       int extra_indent = 0);
 
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -1083,25 +1083,25 @@ public:
 
   bool empty (void) const { return lst.empty (); }
 
   Octave_map
   map_value (const std::string& caller_function_name, int nesting_level) const
   {
     size_t len = lst.size ();
 
-    Array<octave_value> name_info (len, 1);
-    Array<octave_value> size_info (len, 1);
-    Array<octave_value> bytes_info (len, 1);
-    Array<octave_value> class_info (len, 1);
-    Array<octave_value> global_info (len, 1);
-    Array<octave_value> sparse_info (len, 1);
-    Array<octave_value> complex_info (len, 1);
-    Array<octave_value> nesting_info (len, 1);
-    Array<octave_value> persistent_info (len, 1);
+    Cell name_info (len, 1);
+    Cell size_info (len, 1);
+    Cell bytes_info (len, 1);
+    Cell class_info (len, 1);
+    Cell global_info (len, 1);
+    Cell sparse_info (len, 1);
+    Cell complex_info (len, 1);
+    Cell nesting_info (len, 1);
+    Cell persistent_info (len, 1);
 
     std::list<symbol_info>::const_iterator p = lst.begin ();
 
     for (size_t j = 0; j < len; j++)
       {
 	const symbol_info& si = *p++;
 
 	Octave_map ni;
