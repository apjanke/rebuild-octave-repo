# HG changeset patch
# User David Bateman <dbateman@free.fr>
# Date 1219940634 14400
#      Thu Aug 28 12:23:54 2008 -0400
# Node ID 3b53b25e255035f1fe7117fe7826aa12b041ccb9
# Parent  c64c9581e9bf247e7d96ecf3f45f669b691ae12d
Add data sources and line series

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,12 @@
+2008-08-28  David Bateman  <dbateman@free.fr>
+
+	* NEWS: Update for some of the graphics changes
+	
 2008-08-11  Jaroslav Hajek <highegg@gmail.com>
 
 	* acx_blas_f77_func.m4, acx_lapack.m4: Update macros from
 	<http://autoconf-archive.cryp.to/>.
 
 2008-08-07  John W. Eaton  <jwe@octave.org>
 
 	* aclocal.m4 (OCTAVE_STRING_NPOS): Delete.
diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -1,13 +1,44 @@
 Summary of important user-visible changes for version 3.2:
 ---------------------------------------------------------
 
  ** Compatibility with Matlab graphics is much better now.  
 
+    The hggroup object and associated listener callback functions have
+    been added allowing the inclusion of group objects. Data sources
+    have been added to these group objects such that
+
+           x = 0:0.1:10;
+           y = sin (x);
+           plot (x, y, "ydatasource", "y");
+           for i = 1 : 100
+             pause(0.1)
+             y = sin (x + 0.1 * i);
+             refreshdata();
+           endfor
+
+    works as expected.
+
+    TO BE WRITTEN (Shai / Micheal inputs please)
+
+ ** Experimental OpenGL/FLTK based backend to replace gnuplot
+
+    An experimental backend to replace the gnuplot backend has been
+    written based on FLTK. This backend is off by default. You can
+    switch to using this  with the command
+
+        backend ("fltk")
+
+    for all future figures or for a particular figure with the command
+
+        backend (h, "fltk")
+
+    where "h" is a valid figure handle.
+
     TO BE WRITTEN (Shai / Micheal inputs please)
 
  ** Eliminate the functions for direct access to gnuplot from Octave.
     The functions __gnuplot_plot__, __gnuplot_set__, __gnuplot_raw__,
      __gnuplot_show__, __gnuplot_replot__, __gnuplot_splot__,
      __gnuplot_save_data__  and __gnuplot_send_inline_data__ have been
     removed from Octave. These function were incompatible with the high
     level graphics handle code.
diff --git a/doc/ChangeLog b/doc/ChangeLog
--- a/doc/ChangeLog
+++ b/doc/ChangeLog
@@ -1,8 +1,13 @@
+2008-08-28  David Bateman  <dbateman@free.fr>
+
+	* interpreter/plot.txi: Add description of data sources and line
+	series objects.
+
 2008-08-26  David Bateman  <dbateman@free.fr>
 
 	* interpreter/plot.txi: Document the group objects (bar, stem,
 	stair, quiver and area series), and cllback functions.
 
 2008-08-26  Jaroslav Hajek  <highegg@gmail.com>
 
 	* interpreter/contrib.txi: New file.
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -576,16 +576,22 @@ become children of the current axes obje
 @DOCSTRING(surface)
 
 By default, Octave refreshes the plot window when a prompt is printed,
 or when waiting for input.  To force an update at other times, call the
 @code{drawnow} function.
 
 @DOCSTRING(drawnow)
 
+Only figures that are modified will be updated. The @code{refresh}
+function can also be to force an update of the current figure, even if
+it is nor modified.
+
+@DOCSTRING(refresh)
+
 Normally, high-level plot functions like @code{plot} or @code{mesh} call
 @code{newplot} to initialize the state of the current axes so that the
 next plot is drawn in a blank window with default property settings.  To
 have two plots superimposed over one another, call the @code{hold}
 function.  For example,
 
 @example
 @group
@@ -631,17 +637,17 @@ figure window, call the @code{close} fun
 * Root Figure Properties::      
 * Figure Properties::           
 * Axes Properties::             
 * Line Properties::             
 * Text Properties::             
 * Image Properties::            
 * Patch Properties::            
 * Surface Properties::          
-* Seacrhing Properties::
+* Searching Properties::
 @end menu
 
 @node Root Figure Properties
 @subsubsection Root Figure Properties
 
 @table @code
 @item currentfigure
 Index to graphics object for the current figure.
@@ -1191,18 +1197,18 @@ The data determining the surface.  The @
 elements are vectors and @code{zdata} must be a matrix.
 
 @item keylabel
 The text of the legend entry corresponding to this surface.  Note that
 this property is not compatible with @sc{Matlab} and may be removed in a
 future version of Octave.
 @end table
 
-@node Seacrhing Properties
-@subsubsection Seacrhing Properties
+@node Searching Properties
+@subsubsection Searching Properties
 
 @DOCSTRING(findobj)
 
 @DOCSTRING(findall)
 
 
 @node Managing Default Properties
 @subsection Managing Default Properties
@@ -1468,17 +1474,32 @@ plot (x, cos (x), "color", [0, 1, 0], "p
 function update_props (h, d)
   set (get (h, "children"), "linestyle", get (h, "linestyle"));
 endfunction
 @end group
 @end example
 
 @noindent
 that adds a @code{linestyle} property to the @code{hggroup} and
-propagating any changes its its value to the children of the group.
+propagating any changes its its value to the children of the group. The
+@code{linkprop} function can be used to simplify the above to be
+
+@example
+@group
+x = 0:0.1:10;
+hg = hggroup ();
+h1 = plot (x, sin (x), "color", [1, 0, 0], "parent", hg);
+addproperty ("linestyle", hg, "linelinestyle", get (h, "linestyle"));
+hold on
+h2 = plot (x, cos (x), "color", [0, 1, 0], "parent", hg);
+hlink = linkprop ([hg, h1, h2], "color"); 
+@end group
+@end example
+
+@DOCSTRING(linkprop)
 
 These capabilities are used in a number of basic graphics objects. 
 The @code{hggroup} objects created by the functions of Octave contain
 one or more graphics object and are used to:
 
 @itemize @bullet
 @item group together multiple graphics objects,
 @item create linked properties between different graphics objects, and
@@ -1515,28 +1536,41 @@ member.
 
 In addition the members of the group can also be linked to other
 graphics objects through callback functions. For example the baseline of
 the @code{bar} or @code{stem} functions is a line object, whose length
 and position are automatically adjusted, based on changes to the
 corresponding hggroup elements.
 
 @menu
+* Data sources in object groups::
 * Area series::
 * Bar series::
 * Contour groups::
 * Error bar series::
 * Line series::
 * Quiver group::
 * Scatter group::
 * Stair group::
 * Stem Series::
 * Surface group::
 @end menu
 
+@node Data sources in object groups
+@subsubsection Data sources in object groups
+
+All of the group objects contain data source parameters. There are
+string parameters that contain an expression that is evaluated to update
+the relevant data property of the group when the @code{refreshdata}
+function is called. 
+
+@DOCSTRING(refreshdata)
+
+@c add the description of the linkdata function here when it is written
+
 @node Area series
 @subsubsection Area series
 
 Area series objects are created by the @code{area} function. Each of the
 @code{hggroup} elements contains a single patch object. The properties
 of the area series are
 
 @table @code
@@ -1552,16 +1586,20 @@ areas. @xref{Line Styles}.
 @itemx facecolor
 The line and fill color of the patch objects making up the areas. @xref{Colors}.
 
 @item xdata
 @itemx ydata
 The x and y coordinates of the original columns of the data passed to
 @code{area} prior to the cummulative summation used in the @code{area}
 function. 
+
+@item xdatasource
+@itemx ydatasource
+Data source variables.
 @end table
 
 @node Bar series
 @subsubsection Bar series
 
 Bar series objects are created by the @code{bar} or @code{barh}
 functions. Each @code{hgrroup} element contains a single patch object. 
 The properties of the bar series are
@@ -1602,32 +1640,68 @@ bars. @xref{Line Styles}.
 The line and fill color of the patch objects making up the bars. @xref{Colors}.
 
 @item xdata
 The nominal x positions of the bars. Changes in this property and
 propagated to the other members of the bar series. 
 
 @item ydata
 The y value of the bars in the @code{hggroup}.
+
+@item xdatasource
+@itemx ydatasource
+Data source variables.
 @end table
 
 @node Contour groups
 @subsubsection Contour groups
 
 TO BE WRITTEN
 
 @node Error bar series
 @subsubsection Error bar series
 
 TO BE WRITTEN
 
 @node Line series
 @subsubsection Line series
 
-TO BE WRITTEN
+line series objects are created by the @code{plot}  and @code{plot3}
+functions. Each @code{hggroup} element of the series contains a single
+line object as a child representing the stair. The properties of the
+line series are a one-to-one reflection of the children line object, and
+so the line series is only useful for its ability to add data sources to
+the group object.
+
+The properties of the line series are
+
+@table @code
+@item color
+The RGB color or color name of the line objects of the stairs. @xref{Colors}.
+
+@item linewidth
+@itemx linestyle
+The line width and style of the line objects of the stairs. @xref{Line Styles}.
+
+@item marker
+@itemx markeredgecolor
+@itemx markerfacecolor
+@itemx markersize
+The line and fill color of the markers on the stairs. @xref{Colors}.
+
+@item xdata
+@itemx ydata
+@itemx zdata
+The original x, y and z data of the stairs.
+
+@item xdatasource
+@itemx ydatasource
+@itemx zdatasource
+Data source variables.
+@end table
 
 @node Quiver group
 @subsubsection Quiver group
 
 Quiver series objects are created by the @code{quiver} or @code{quiver3}
 functions. Each @code{hggroup} element of the series contains three line
 objects as children representing the body and head of the arrow,
 together with a marker as the point of original of the arrows. The 
@@ -1665,16 +1739,24 @@ arrows. @xref{Colors}.
 @itemx ydata
 @itemx zdata
 The origins of the values of the vector field.
 
 @item udata
 @itemx vdata
 @itemx wdata
 The values of the vector field to plot.
+
+@item xdatasource
+@itemx ydatasource
+@itemx zdatasource
+@itemx udatasource
+@itemx vdatasource
+@itemx wdatasource
+Data source variables.
 @end table
 
 @node Scatter group
 @subsubsection Scatter group
 
 TO BE WRITTEN
 
 @node Stair group
@@ -1696,26 +1778,32 @@ The line width and style of the line obj
 @itemx markeredgecolor
 @itemx markerfacecolor
 @itemx markersize
 The line and fill color of the markers on the stairs. @xref{Colors}.
 
 @item xdata
 @itemx ydata
 The original x and y data of the stairs.
+
+@item xdatasource
+@itemx ydatasource
+Data source variables.
 @end table
 
 @node Surface group
 @subsubsection Surface group
 
 TO BE WRITTEN
 
 @node Graphics backends
 @subsection Graphics backends
 
+@DOCSTRING(backends)
+
 @DOCSTRING(available_backends)
 
 @menu
 * Interaction with gnuplot::
 @end menu
 
 @node Interaction with gnuplot
 @subsubsection Interaction with @code{gnuplot}
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,21 @@
+2008-08-28  David Bateman  <dbateman@free.fr>
+
+	* plot/__add_line_series__.m, plot/ishghandle.m, plot/linkprop.m,
+	plot/refresh.m, plot/refreshdata.m: New functions
+	* Makefile.in (SOURCES): Add them here.
+	
+	* plot/__area__.m, plot/__bars__.m, plot/__quiver__.m,
+	plot/__stem__.m, plot/stairs.m, plot/stem.m: Add data sources.
+
+	* plot/__plt2mm__.m, plot/__plt2mv__.m, plot/__plt2ss__.m,
+	plot/__plt2sv__.m, plot/__plt2vm__.m, plot/__plt2vs__.m,
+	plot/__plt2vv__.m, plot/plot3.m: Add line series and data sources.
+
 2008-08-28  Martin Weiser  <weiser2@natur.cuni.cz>
 
 	* plot/scatter3.m: Doc fix.
 
 2008-08-26  John W. Eaton  <jwe@octave.org>
 
 	* plot/hold.m: If hold is applied to a figure, set state for all
 	child axes objects.
diff --git a/scripts/plot/Makefile.in b/scripts/plot/Makefile.in
--- a/scripts/plot/Makefile.in
+++ b/scripts/plot/Makefile.in
@@ -29,16 +29,18 @@ VPATH = @srcdir@
 
 include $(TOPDIR)/Makeconf
 
 INSTALL = @INSTALL@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_DATA = @INSTALL_DATA@
 
 SOURCES = \
+  __add_datasource__.m \
+  __add_line_series__.m \
   __area__.m \
   __axes_limits__.m \
   __axis_label__.m \
   __bar__.m \
   __bars__.m \
   __contour__.m \
   __default_plot_options__.m \
   __errcomm__.m \
@@ -115,19 +117,21 @@ SOURCES = \
   ginput.m \
   grid.m \
   gtext.m \
   hggroup.m \
   hidden.m \
   hist.m \
   hold.m \
   isfigure.m \
+  ishghandle.m \
   ishold.m \
   legend.m \
   line.m \
+  linkprop.m \
   loglog.m \
   loglogerr.m \
   mesh.m \
   meshc.m \
   meshgrid.m \
   meshz.m \
   ndgrid.m \
   newplot.m \
@@ -140,16 +144,18 @@ SOURCES = \
   plot.m \
   plotyy.m \
   plot3.m \
   plotyy.m \
   polar.m \
   print.m \
   quiver.m \
   quiver3.m \
+  refresh.m \
+  refreshdata.m \
   replot.m \
   ribbon.m \
   rose.m \
   scatter.m \
   scatter3.m \
   semilogx.m \
   semilogxerr.m \
   semilogy.m \
diff --git a/scripts/plot/__add_datasource__.m b/scripts/plot/__add_datasource__.m
new file mode 100644
--- /dev/null
+++ b/scripts/plot/__add_datasource__.m
@@ -0,0 +1,51 @@
+## Copyright (C) 2008 David Bateman
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## Undocumented internal function
+
+function newargs = __add_datasource__ (fcn, h, data, varargin)
+
+  if (nargin < 3)
+    error ("internal error");
+  endif
+
+  if (ischar (data))
+    data = {data};
+  endif
+
+  for i = 1 : numel (data)
+    addproperty (strcat (data{i}, "datasource"), h, "string", "");
+  endfor
+
+  i = 1;
+  newargs = {};
+  while (i < numel (varargin))
+    arg = varargin{i++};
+    if (ischar (arg) && length (arg > 1) && strcmpi (arg(2:end), "datasource"))
+      arg = tolower (arg);
+      val = varargin{i++};
+      if (ischar (val)) 
+	set (h, arg, val);
+      else
+	error ("%s: expecting data source to be a string", fcn);
+      endif
+    else
+      newargs{end + 1} = arg;
+    endif
+  endwhile
+endfunction
diff --git a/scripts/plot/__add_line_series__.m b/scripts/plot/__add_line_series__.m
new file mode 100644
--- /dev/null
+++ b/scripts/plot/__add_line_series__.m
@@ -0,0 +1,64 @@
+## Copyright (C) 2008 David Bateman
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## Undocumented internal function
+
+function  __add_line_series__ (h, hg)
+
+  obj = get(h);
+
+  addproperty ("color", hg, "linecolor", obj.color);
+  addproperty ("linewidth", hg, "linelinewidth", obj.linewidth);
+  addproperty ("linestyle", hg, "linelinestyle", obj.linestyle);
+  addproperty ("marker", hg, "linemarker", obj.marker);
+  addproperty ("markeredgecolor", hg, "linemarkerfacecolor", 
+	       obj.markeredgecolor);
+  addproperty ("markerfacecolor", hg, "linemarkerfacecolor", 
+	       obj.markerfacecolor);
+  addproperty ("markersize", hg, "linemarkersize", obj.markersize);
+      
+  addlistener (hg, "color", @update_props);
+  addlistener (hg, "linewidth", @update_props); 
+  addlistener (hg, "linestyle", @update_props); 
+  addlistener (hg, "marker", @update_props); 
+  addlistener (hg, "markeredgecolor", @update_props); 
+  addlistener (hg, "markerfacecolor", @update_props); 
+  addlistener (hg, "markersize", @update_props);
+
+  addproperty ("xdata", hg, "data", obj.xdata);
+  addproperty ("ydata", hg, "data", obj.ydata);
+  addproperty ("zdata", hg, "data", obj.zdata);
+
+  addlistener (hg, "xdata", @update_props);
+  addlistener (hg, "ydata", @update_props);
+  addlistener (hg, "zdata", @update_props);
+endfunction
+
+function update_props (h, d)
+  set (get (h, "children"), "color", get (h, "color"), 
+       "linewidth", get (h, "linewidth"),
+       "linestyle", get (h, "linestyle"),
+       "marker", get (h, "marker"),
+       "markerfacecolor", get (h, "markerfacecolor"),
+       "markeredgecolor", get (h, "markeredgecolor"),
+       "markersize", get (h, "markersize"),
+       "xdata", get (h, "xdata"),
+       "ydata", get (h, "ydata"),
+       "zdata", get (h, "zdata"));
+endfunction
+
diff --git a/scripts/plot/__area__.m b/scripts/plot/__area__.m
--- a/scripts/plot/__area__.m
+++ b/scripts/plot/__area__.m
@@ -20,31 +20,34 @@
 
 function retval = __area__ (ax, x, y, bv, varargin)
 
   y0 = bv * ones (1, rows (y));
   y0 = zeros (1, rows (y));
   retval = [];
   for i = 1: size (y, 2);
     hg = hggroup ();
+    retval = [retval; hg];
+    args = __add_datasource__ ("area", hg, {"x", "y"}, varargin{:});
+
     x1 = x(:, 1).';
     y1 = y (:, i).';
     addproperty ("xdata", hg, "data", x1);
     addproperty ("ydata", hg, "data", y1);
 
     addlistener (hg, "xdata", @update_data);
     addlistener (hg, "ydata", @update_data);
 
     if (i == 1)
       h = patch (ax, [x1(1), x1, fliplr(x1)], [bv, y1, bv*ones(1, length(y1))],
-		 __next_line_color__ (), "parent", hg, varargin{:});
+		 __next_line_color__ (), "parent", hg, args{:});
     else
       y1 = y0 + y1;
       h = patch (ax, [x1(1), x1, fliplr(x1)], [y0(1), y1, fliplr(y0)],
-		 __next_line_color__ (), "parent", hg, varargin{:});
+		 __next_line_color__ (), "parent", hg, args{:});
     endif
 
     y0 = y1;
 
     addproperty ("basevalue", hg, "data", bv);
     addlistener (hg, "basevalue", @move_baseline); 
 
     addproperty ("edgecolor", hg, "patchedgecolor", get (h, "edgecolor"));
@@ -52,17 +55,16 @@ function retval = __area__ (ax, x, y, bv
     addproperty ("linestyle", hg, "patchlinestyle", get (h, "linestyle"));
     addproperty ("facecolor", hg, "patchfacecolor", get (h, "facecolor"));
 
     addlistener (hg, "edgecolor", @update_props);
     addlistener (hg, "linewidth", @update_props); 
     addlistener (hg, "linestyle", @update_props); 
     addlistener (hg, "facecolor", @update_props); 
 
-    retval = [retval; hg];
     addproperty ("areagroup", hg, "data");
     set (retval, "areagroup", retval);
   endfor
 
 endfunction
 
 function update_props (h, d)
   kids = get (h, "children");
diff --git a/scripts/plot/__bars__.m b/scripts/plot/__bars__.m
--- a/scripts/plot/__bars__.m
+++ b/scripts/plot/__bars__.m
@@ -24,40 +24,41 @@ function tmp = __bars__ (ax, vertical, x
 
   ycols = columns (y);
   clim = get (ax, "clim");
   tmp = [];
 
   for i = 1:ycols
     hg = hggroup ();
     tmp = [tmp; hg];
-
+    args = __add_datasource__ ("bar", hg, {"x", "y"}, varargin{:});
+    
     if (vertical)
       if (! have_color_spec)
 	if (ycols == 1)
 	  lev = clim(1);
 	else
 	  lev = (i - 1) * (clim(2) - clim(1)) / (ycols - 1) - clim(1);
 	endif
 	h = patch(xb(:,:,i), yb(:,:,i), "FaceColor", "flat", 
-		  "cdata", lev, "parent", hg, varargin{:});
+		  "cdata", lev, "parent", hg, args{:});
       else
-	h = patch(xb(:,:,i), yb(:,:,i), "parent", hg, varargin{:});
+	h = patch(xb(:,:,i), yb(:,:,i), "parent", hg, args{:});
       endif
     else
       if (! have_color_spec)
 	if (ycols == 1)
 	  lev = clim(1)
 	else
 	  lev = (i - 1) * (clim(2) - clim(1)) / (ycols - 1) - clim(1);
 	endif
 	h = patch(yb(:,:,i), xb(:,:,i), "FaceColor", "flat", 
-		  "cdata", lev, "parent", hg, varargin{:});
+		  "cdata", lev, "parent", hg, args{:});
       else
-	h = patch(yb(:,:,i), xb(:,:,i), "parent", hg, varargin{:});
+	h = patch(yb(:,:,i), xb(:,:,i), "parent", hg, args{:});
       endif
     endif
 
     if (i == 1)
       x_axis_range = get (ax, "xlim");
       h_baseline = line (x_axis_range, [0, 0], "color", [0, 0, 0]);
       set (h_baseline, "handlevisibility", "off");
       set (h_baseline, "xliminclude", "off");
diff --git a/scripts/plot/__plt2mm__.m b/scripts/plot/__plt2mm__.m
--- a/scripts/plot/__plt2mm__.m
+++ b/scripts/plot/__plt2mm__.m
@@ -49,19 +49,27 @@ function retval = __plt2mm__ (h, x, y, o
 	tkey = options(i).key;
 	if (! isempty (tkey))
 	  set (h, "key", "on");
 	endif
 	color = options(i).color;
 	if (isempty (color))
 	  color = __next_line_color__ ();
 	endif
-	retval(i) = line (x(:,i), y(:,i), "keylabel", tkey, "color", color,
-			  "linestyle", options(i).linestyle,
-			  "marker", options(i).marker, properties{:});
+
+	hg = hggroup ();
+	retval(i) = hg;
+	args = __add_datasource__ ("__plt2mm__", hg, {"x", "y", "z"}, 
+				   properties{:});
+
+	h = line (x(:,i), y(:,i), "keylabel", tkey, "color", color,
+		  "linestyle", options(i).linestyle,
+		  "marker", options(i).marker, "parent", hg, args{:});
+
+	__add_line_series__ (h, hg);
       endfor
     else
       error ("__plt2mm__: arguments must be a matrices");
     endif
   else
     error ("__plt2mm__: matrix dimensions must match");
   endif
 
diff --git a/scripts/plot/__plt2mv__.m b/scripts/plot/__plt2mv__.m
--- a/scripts/plot/__plt2mv__.m
+++ b/scripts/plot/__plt2mv__.m
@@ -65,17 +65,25 @@ function retval = __plt2mv__ (h, x, y, o
       tkey = options(i).key;
       if (! isempty (tkey))
 	set (h, "key", "on");
       endif
       color = options(i).color;
       if (isempty (color))
 	color = __next_line_color__ ();
       endif
-      retval(i) = line (x(:,i), y, "keylabel", tkey, "color", color,
-			"linestyle", options(i).linestyle,
-			"marker", options(i).marker, properties{:});
+
+      hg = hggroup ();
+      retval(i) = hg;
+      args = __add_datasource__ ("__plt2mv__", hg, {"x", "y", "z"}, 
+				 properties{:});
+
+      h = line (x(:,i), y, "keylabel", tkey, "color", color,
+		"linestyle", options(i).linestyle,
+		"marker", options(i).marker, "parent", hg, args{:});
+   
+      __add_line_series__ (h, hg);
     endfor
   else
     error ("__plt2mv__: arguments must be a matrices");
   endif
 
 endfunction
diff --git a/scripts/plot/__plt2ss__.m b/scripts/plot/__plt2ss__.m
--- a/scripts/plot/__plt2ss__.m
+++ b/scripts/plot/__plt2ss__.m
@@ -46,16 +46,24 @@ function retval = __plt2ss__ (h, x, y, o
     key = options.key;
     if (! isempty (key))
       set (h, "key", "on");
     endif
     color = options.color;
     if (isempty (color))
       color = __next_line_color__ ();
     endif
-    retval = line (x, y, "keylabel", key, "color", color,
-		   "linestyle", options.linestyle,
-		   "marker", options.marker, properties{:});
+
+    hg = hggroup ();
+    retval = hg;
+    properties = __add_datasource__ ("__plt2ss__", hg, {"x", "y", "z"}, 
+				     properties{:});
+
+    h = line (x, y, "keylabel", key, "color", color,
+	      "linestyle", options.linestyle,
+	      "marker", options.marker, "parent", hg, properties{:});
+
+    __add_line_series__ (h, hg);
   else
     error ("__plt2ss__: arguments must be scalars");
   endif
 
 endfunction
diff --git a/scripts/plot/__plt2sv__.m b/scripts/plot/__plt2sv__.m
--- a/scripts/plot/__plt2sv__.m
+++ b/scripts/plot/__plt2sv__.m
@@ -45,17 +45,25 @@ function retval = __plt2sv__ (h, x, y, o
       tkey = options(i).key;
       if (! isempty (tkey))
 	set (h, "key", "on");
       endif
       color = options(i).color;
       if (isempty (color))
 	color = __next_line_color__ ();
       endif
-      retval(i) = line (x, y(i), "keylabel", tkey, "color", color,
-			"linestyle", options(i).linestyle,
-			"marker", options(i).marker, properties{:});
+
+      hg = hggroup ();
+      retval(i) = hg;
+      args = __add_datasource__ ("__plt2sv__", hg, {"x", "y", "z"}, 
+				 properties{:});
+
+      h = line (x, y(i), "keylabel", tkey, "color", color,
+		"linestyle", options(i).linestyle,
+		"marker", options(i).marker, "parent", hg, args{:});
+
+      __add_line_series__ (h, hg);
     endfor
   else
     error ("__plt2sv__: first arg must be scalar, second arg must be vector");
   endif
 
 endfunction
diff --git a/scripts/plot/__plt2vm__.m b/scripts/plot/__plt2vm__.m
--- a/scripts/plot/__plt2vm__.m
+++ b/scripts/plot/__plt2vm__.m
@@ -65,17 +65,26 @@ function retval = __plt2vm__ (h, x, y, o
       tkey = options(i).key;
       if (! isempty (tkey))
 	set (h, "key", "on");
       endif
       color = options(i).color;
       if (isempty (color))
 	color = __next_line_color__ ();
       endif
-      retval(i) = line (x, y(:,i), "keylabel", tkey, "color", color,
-			"linestyle", options(i).linestyle,
-			"marker", options(i).marker, properties{:});
+
+      hg = hggroup ();
+      retval(i) = hg;
+      args = __add_datasource__ ("__plt2vm__", hg, {"x", "y", "z"}, 
+				 properties{:});
+
+      h = line (x, y(:,i), "keylabel", tkey, "color", color,
+		"linestyle", options(i).linestyle,
+		"marker", options(i).marker, "parent", hg, args{:});
+
+      __add_line_series__ (h, hg);
+
     endfor
   else
     error ("__plt2vm__: arguments must be a matrices");
   endif
 
 endfunction
diff --git a/scripts/plot/__plt2vs__.m b/scripts/plot/__plt2vs__.m
--- a/scripts/plot/__plt2vs__.m
+++ b/scripts/plot/__plt2vs__.m
@@ -45,17 +45,25 @@ function retval = __plt2vs__ (h, x, y, o
       tkey = options(i).key;
       if (! isempty (tkey))
 	set (h, "key", "on");
       endif
       color = options(i).color;
       if (isempty (color))
 	color = __next_line_color__ ();
       endif
-      retval(i) = line (x(i), y, "keylabel", tkey, "color", color,
-			"linestyle", options(i).linestyle,
-			"marker", options(i).marker, properties{:});
+
+      hg = hggroup ();
+      retval(i) = hg;
+      args = __add_datasource__ ("__plt2vs__", hg, {"x", "y", "z"}, 
+				 properties{:});
+
+      h = line (x(i), y, "keylabel", tkey, "color", color,
+		"linestyle", options(i).linestyle,
+		"marker", options(i).marker, "parent", hg, args{:});
+
+      __add_line_series__ (h, hg);
     endfor
   else
     error ("__plt2vs__: first arg must be vector, second arg must be scalar");
   endif
 
 endfunction
diff --git a/scripts/plot/__plt2vv__.m b/scripts/plot/__plt2vv__.m
--- a/scripts/plot/__plt2vv__.m
+++ b/scripts/plot/__plt2vv__.m
@@ -60,16 +60,24 @@ function retval = __plt2vv__ (h, x, y, o
     key = options.key;
     if (! isempty (key))
       set (h, "key", "on");
     endif
     color = options.color;
     if (isempty (color))
       color = __next_line_color__ ();
     endif
-    retval = line (x, y, "keylabel", key, "color", color,
-		   "linestyle", options.linestyle,
-		   "marker", options.marker, properties{:});
+
+    hg = hggroup ();
+    retval = hg;
+    properties = __add_datasource__ ("__plt2vv__", hg, {"x", "y", "z"}, 
+				     properties{:});
+
+    h = line (x, y, "keylabel", key, "color", color,
+	      "linestyle", options.linestyle,
+	      "marker", options.marker, "parent", hg, properties{:});
+
+    __add_line_series__ (h, hg);
   else
     error ("__plt2vv__: vector lengths must match");
   endif
 
 endfunction
diff --git a/scripts/plot/__quiver__.m b/scripts/plot/__quiver__.m
--- a/scripts/plot/__quiver__.m
+++ b/scripts/plot/__quiver__.m
@@ -70,33 +70,40 @@ function hg = __quiver__ (varargin)
     if (nargin >= ioff && isnumeric (varargin{ioff})
 	&& isscalar (varargin{ioff}))
       autoscale = varargin{ioff++};
     endif
   endif
 
   have_filled = false;
   have_line_spec = false;
+  args = {};
   while (ioff <= nargin)
     arg = varargin{ioff++};
     if (ischar (arg) && strncmp (tolower (arg), "filled", 6))
       have_filled = true;
     elseif ((ischar (arg) || iscell (arg))
 	    && ! have_line_spec)
       [linespec, valid] = __pltopt__ ("quiver", arg, false);
       if (valid)
 	have_line_spec = true;
 	if (strncmp (linespec.linestyle, "none", 4))
 	  linespec.linestyle = "-";
 	endif
       else
-	error ("quiver: invalid linespec");
+	args {end + 1} = arg;
+        if (ioff <= nargin)
+          args {end + 1} = varargin{ioff++};
+        endif
       endif
     else
-      error ("quiver: unrecognized argument");
+      args {end + 1} = arg;
+      if (ioff <= nargin)
+        args {end + 1} = varargin{ioff++};
+      endif
     endif
   endwhile
 
   if (autoscale)
     ## Scale the arrows to fit in the grid
     dx = (max(x(:)) - min(x(:))) ./ size (x, 2);
     dy = (max(y(:)) - min(y(:))) ./ size (y, 1);
     if (is3d)
@@ -115,16 +122,23 @@ function hg = __quiver__ (varargin)
 	ww = s*w;
       endif
     endif
   endif
 
   hstate = get (h, "nextplot");
   unwind_protect
     hg = hggroup ();
+    if (is3d)
+      args = __add_datasource__ ("quiver3", hg, 
+				 {"x", "y", "z", "u", "v", "w"}, args{:});
+    else
+      args = __add_datasource__ ("quiver", hg, 
+				 {"x", "y", "z", "u", "v", "w"}, args{:});
+    endif
     hold on;
 
     addproperty ("xdata", hg, "data", x);
     addproperty ("ydata", hg, "data", y);
 
     addproperty ("udata", hg, "data", u);
     addproperty ("vdata", hg, "data", v);
     if (is3d)
@@ -152,33 +166,33 @@ function hg = __quiver__ (varargin)
     endif
 
     if (have_line_spec)
       if (is3d)
 	h1 = plot3 ([x.'; xend.'; NaN(1, length (x))](:),
 		    [y.'; yend.'; NaN(1, length (y))](:),
 		    [z.'; zend.'; NaN(1, length (z))](:),
 		    "linestyle", linespec.linestyle, 
-		    "color", linespec.color, "parent", hg);
+		    "color", linespec.color, "parent", hg, args{:});
       else
 	h1 = plot ([x.'; xend.'; NaN(1, length (x))](:),
 		   [y.'; yend.'; NaN(1, length (y))](:),
 		   "linestyle", linespec.linestyle, 
-		    "color", linespec.color, "parent", hg);
+		    "color", linespec.color, "parent", hg, args{:});
       endif
     else
       if (is3d)
 	h1 = plot3 ([x.'; xend.'; NaN(1, length (x))](:),
 		    [y.'; yend.'; NaN(1, length (y))](:),
 		    [z.'; zend.'; NaN(1, length (z))](:),
-		    "parent", hg);
+		    "parent", hg, args{:});
       else
 	h1 = plot ([x.'; xend.'; NaN(1, length (x))](:),
 		   [y.'; yend.'; NaN(1, length (y))](:),
-		   "parent", hg);
+		   "parent", hg, args{:});
       endif
     endif
 
     xtmp = x + uu(:) .* (1 - arrowsize);
     ytmp = y + vv(:) .* (1 - arrowsize);
     xarrw1 = xtmp + (y - yend) * arrowsize / 3;
     xarrw2 = xtmp - (y - yend) * arrowsize / 3;
     yarrw1 = ytmp - (x - xend) * arrowsize / 3;
diff --git a/scripts/plot/__stem__.m b/scripts/plot/__stem__.m
--- a/scripts/plot/__stem__.m
+++ b/scripts/plot/__stem__.m
@@ -26,17 +26,18 @@ function h = __stem__ (have_z, varargin)
   if (have_z)
     caller = "stem3";
   else
     caller = "stem";
   endif
 
   [ax, varargin, nargin] = __plt_get_axis_arg__ (caller, varargin{:});
 
-  [x, y, z, dofill, llc, ls, mmc, ms] = check_stem_arg (have_z, varargin{:});
+  [x, y, z, dofill, llc, ls, mmc, ms, varargin] = ...
+      check_stem_arg (have_z, varargin{:});
 
   oldax = gca ();
   unwind_protect
     axes (ax);
     hold_state = get (ax, "nextplot");
     newplot ();
     h = [];
 
@@ -53,16 +54,18 @@ function h = __stem__ (have_z, varargin)
 	xt = x(:, i)';
 	xt = [xt; xt; NaN(1, nx)](:);
 	yt = y(:, i)';
 	yt = [zeros(1, nx); yt; NaN(1, nx)](:);
       endif
 
       hg  = hggroup ();
       h = [h; hg];
+      __add_datasource__ (caller, hg, {"x", "y", "z"}, varargin{:});
+      
       if (i == 1)
 	set (ax, "nextplot", "add");
       endif
 
       if (isempty (llc))
 	lc = __next_line_color__ ();
       else
 	lc = llc;
@@ -142,24 +145,39 @@ function h = __stem__ (have_z, varargin)
     endfor
 
   unwind_protect_cleanup
     set (ax, "nextplot", hold_state);
     axes (oldax);
   end_unwind_protect
 endfunction
 
-function [x, y, z, dofill, lc, ls, mc, ms] = check_stem_arg (have_z, varargin)
+function [x, y, z, dofill, lc, ls, mc, ms, newargs] = check_stem_arg (have_z, varargin)
 
   if (have_z)
     caller = "stem3";
   else
     caller = "stem";
   endif
 
+  ## Remove prop/val pairs from data to consider
+  i = 2;
+  newargs = {};
+  while (i < length (varargin))
+    if (ischar (varargin{i}) && !(strcmpi ("fill", varargin{i}) || 
+				 strcmpi ("filled", varargin{i})))
+      newargs{end + 1} = varargin{i};
+      newargs{end + 1} = varargin{i + 1};
+      nargin = nargin - 2;
+      varargin(i:i+1) = [];
+    else
+      i++;
+    endif
+  endwhile
+
   ## set specifiers to default values
   [lc, ls, mc, ms] = set_default_values ();
   dofill = 0;
   fill_2 = 0;
   linespec_2 = 0;
   z = [];
 
   ## check input arguments
diff --git a/scripts/plot/ishghandle.m b/scripts/plot/ishghandle.m
new file mode 100644
--- /dev/null
+++ b/scripts/plot/ishghandle.m
@@ -0,0 +1,28 @@
+## Copyright (C) 2008 David Bateman
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} ishghandle (@var{h})
+## Return true if @var{h} is a graphics handle and false otherwise.\n\
+## @end deftypefn
+
+function retval = ishghandle (h)
+  ## This function is just included for compatibility as Octave has 
+  ## no simulink equivalent.
+  retval = ishandle (h);
+endfunction
diff --git a/scripts/plot/linkprop.m b/scripts/plot/linkprop.m
new file mode 100644
--- /dev/null
+++ b/scripts/plot/linkprop.m
@@ -0,0 +1,98 @@
+## Copyright (C) 2008 David Bateman
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {@var{hlink} =} linkprop (@var{h}, @var{prop})
+## Links graphics object properties, such that a change in one is
+## propagated to the others. The properties to link are given as a
+## string of cell string array by @var{prop} and the objects containing
+## these properties by the handle array @var{h}.
+##
+## An example of the use of linkprops is
+##
+## @example
+## @group
+## x = 0:0.1:10;
+## subplot (1, 2, 1);
+## h1 = plot (x, sin (x));
+## subplot (1, 2, 2);
+## h2 = plot (x, cos (x));
+## hlink = linkprop ([h1, h2], @{"color","linestyle"@});
+## set (h1, "color", "green");
+## set (h2, "linestyle", "--");
+## @end group
+## @end example
+##
+## @end deftypefn
+
+function hlink = linkprop (h, prop)
+  if (ischar (prop))
+    prop = {prop};
+  elseif (!iscellstr (prop))
+    error ("linkprop: properties must be a string or cell string array");
+  endif
+
+  for i = 1 : numel (h)
+    for j = 1 : numel (prop)
+      addlistener (h(i), prop{j}, {@update_prop, h, prop{j}});
+    endfor
+  endfor
+
+  ## This should be an object that when destroyed removes the links
+  ## The below is not quite right. As when you call "clear hlink" the
+  ## hggroup continues to exist.
+  hlink = hggroup ();
+  set (hlink, "deletefcn", {@delete_prop, h, prop});
+endfunction
+
+function update_prop (h, d, hlist, prop)
+  persistent recursion = false;
+
+  ## Don't allow recursion
+  if (! recursion)
+    unwind_protect
+      recursion = true;
+      val = get (h, prop);
+      for hh = hlist(:)'
+	if (hh != h)
+	  oldval = get (hh, prop);
+	  if (! isequal (val, oldval))
+	    set (hh, prop, val);
+	  endif
+	endif
+      endfor
+    unwind_protect_cleanup
+      recursion = false;
+    end_unwind_protect
+  endif
+endfunction
+
+function delete_prop (h, d, hlist, prop)
+  ## FIXME. Actually need to delete the linked properties.
+  ## However, only warn if the graphics objects aren't being deleted.
+  warn = false;
+  for h = hlist(:)'
+    if (ishandle (h) && !strcmp (get (h, "beingdeleted"), "on"))
+      warn = true;
+      break;
+    endif
+  endfor
+  if (warn)
+    warning ("linkprop: can not remove linked properties");
+  endif
+endfunction
diff --git a/scripts/plot/plot3.m b/scripts/plot/plot3.m
--- a/scripts/plot/plot3.m
+++ b/scripts/plot/plot3.m
@@ -220,19 +220,25 @@ function retval = plot3 (varargin)
       if (! isempty (key))
 	set (gca (), "key", "on");
       endif
       color = options.color;
       if (isempty (color))
 	color = __next_line_color__ ();
       endif
 
-      tmp(++idx) = line (x(:), y(:), z(:),  "keylabel", key, "color", color,
-			 "linestyle", options.linestyle,
-			 "marker", options.marker, properties{:});
+      hg = hggroup ();
+      tmp(++idx) = hg;
+      properties = __add_datasource__ ("plot3", hg, {"x", "y", "z"}, properties{:});
+
+      hline = line (x(:), y(:), z(:),  "keylabel", key, "color", color,
+		    "linestyle", options.linestyle,
+		    "marker", options.marker, "parent", hg, properties{:});
+
+      __add_line_series__ (h, hg);
 
       x = new;
       y_set = 0;
       z_set = 0;
       fmt_set = 0;
       properties = {};
     endif
 
@@ -284,19 +290,25 @@ function retval = plot3 (varargin)
     if (! isempty (key))
       set (gca (), "key", "on");
     endif
     color = options.color;
     if (isempty (color))
       color = __next_line_color__ ();
     endif
 
-    tmp(++idx) = line (x(:), y(:), z(:),  "keylabel", key, "color", color,
-		       "linestyle", options.linestyle,
-		       "marker", options.marker, properties{:});
+    hg = hggroup ();
+    tmp(++idx) = hg;
+    properties = __add_datasource__ ("plot3", hg, {"x", "y", "z"}, properties{:});
+
+    hline = line (x(:), y(:), z(:),  "keylabel", key, "color", color,
+		  "linestyle", options.linestyle,
+		  "marker", options.marker, "parent", hg, properties{:});
+
+    __add_line_series__ (h, hg);
   endif
 
   set (gca (), "view", [-37.5, 30]);
 
   if (nargout > 0 && idx > 0)
     retval = tmp;
   endif
 
diff --git a/scripts/plot/refresh.m b/scripts/plot/refresh.m
new file mode 100644
--- /dev/null
+++ b/scripts/plot/refresh.m
@@ -0,0 +1,42 @@
+## Copyright (C) 2008 David Bateman
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} refresh ()
+## @deftypefnx {Function File} {} refresh (@var{h})
+## Refresh a figure, forcing it to be redrawn. Called without an
+## argument the current figure is redrawn, otherwise the figure pointed
+## to by @var{h} is redrawn.
+## @seealso{drawnow}
+## @end deftypefn
+
+function refresh (h)
+
+  if (nargin == 1)
+    if (!ishandle (h) || !strcmp (get (h, "type"), "figure"))
+      error ("refresh: expecting argument to be a valid figure handle");
+    endif
+  elseif (nargin > 1)
+    print_usage ();
+  else
+    h = gcf ();
+  endif
+
+  set(h,"__modified__", "on")
+  drawnow ();
+endfunction
diff --git a/scripts/plot/refreshdata.m b/scripts/plot/refreshdata.m
new file mode 100644
--- /dev/null
+++ b/scripts/plot/refreshdata.m
@@ -0,0 +1,107 @@
+## Copyright (C) 2008 David Bateman
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {} refreshdata ()
+## @deftypefnx {Function File} {} refreshdata (@var{h})
+## @deftypefnx {Function File} {} refreshdata (@var{h}, @var{ws})
+## Evaluates any datasource properties of the current figure and updates
+## the corresponding data. If call with one or more arguments @var{h} is
+## a scalar or array of figure handles which to refresh. The data
+## sources are by default evaluated in the "base" workspace but can also
+## be set in the "caller" workspace.
+##
+## An example of the use of refreshdata is
+##
+## @example
+## @group
+## x = 0:0.1:10;
+## y = sin (x);
+## plot (x, y, "ydatasource", "y");
+## for i = 1 : 100
+##   pause(0.1)
+##   y = sin (x + 0.1 * i);
+##   refreshdata();
+## endfor
+## @end group
+## @end example
+## 
+## @seealso{linkdata}
+## @end deftypefn
+
+function refreshdata (h, ws)
+
+  if (nargin == 0)
+    h = gcf ();
+    ws = "base";
+  else
+    if (iscell (h))
+      h = [h{:}];
+    endif
+    if (!all (ishandle (h)) || !all (strcmp (get (h, "type"), "figure")))
+      error ("refreshdata: expecting a list of figure handles");
+    endif
+    if (nargin < 2)
+      ws = "base";
+    else
+      if (!ischar (ws) || !(strcmpi (ws, "base") || strcmpi (ws, "caller")))
+	error ("refreshdata: expecting workspace to be \"base\" or ""caller\"");
+      else
+	ws = tolower (ws);
+      endif
+    endif
+  endif
+
+  h = findall (h);
+  objs = [];
+  props = {};
+
+  for i = 1 : numel (h)
+    obj = get (h (i));
+    fldnames = fieldnames (obj);
+    m = regexpi (fieldnames(obj), "^.datasource$", "match");
+    idx = cellfun (@(x) !isempty(x), m);
+    if (any (idx))
+      props = [props; {cell2mat(m(idx))}];
+      objs  = [objs ; h(i)];
+    endif
+  endfor
+
+  for i = 1 : length (objs)
+    for j = 1 : length (props {i})
+      expr = get (objs(i), props{i}{j});
+      if (!isempty (expr))
+	val = evalin (ws, expr);
+	prop =  props{i}{j}(1:end-6);
+        if (! isequal (get (objs(i), prop), val))
+	  set (objs(i), props{i}{j}(1:end-6), val);
+        endif
+      endif
+    endfor
+  endfor
+endfunction
+
+%!demo
+%! x = 0:0.1:10;
+%! y = sin (x);
+%! plot (x, y, "ydatasource", "y");
+%! for i = 1 : 100
+%!   pause(0.1)
+%!   y = sin (x + 0.1 * i);
+%!   refreshdata();
+%! endfor
diff --git a/scripts/plot/stairs.m b/scripts/plot/stairs.m
--- a/scripts/plot/stairs.m
+++ b/scripts/plot/stairs.m
@@ -76,28 +76,28 @@ function [xs, ys] = stairs (varargin)
       xs = h;
     endif
   endif
 endfunction
 
 function [h, xs, ys] = __stairs__ (doplot, varargin)
 
   if (nargin == 1 || ischar (varargin{2}))
-    idx = 1;
     y = varargin {1};
+    varargin(1) = [];
     if (ismatrix (y))
       if (isvector (y))
 	y = y(:);
       endif
       x = 1:rows (y);
     endif
   else
-    idx = 2;
     x = varargin{1};
     y = varargin{2};
+    varargin(1:2) = [];
   endif
 
   if (ndims (x) > 2 || ndims (y) > 2)
     error ("stairs: expecting 2-d arguments");
   endif
 
   vec_x = isvector (x);
 
@@ -139,29 +139,30 @@ function [h, xs, ys] = __stairs__ (doplo
 
   if (doplot)
     h = [];
     unwind_protect
       hold_state = get (gca (), "nextplot");
       for i = 1 : size(y, 2)
 	hg = hggroup ();
 	h = [h; hg];
+	args = __add_datasource__ ("stairs", hg, {"x", "y"}, varargin{:});
 
 	if (i == 1)
 	  set (gca (), "nextplot", "add");
 	endif
 
 	addproperty ("xdata", hg, "data", x(:,i).');
 	addproperty ("ydata", hg, "data", y(:,i).');
 
 	addlistener (hg, "xdata", @update_data);
 	addlistener (hg, "ydata", @update_data);
 
 	tmp = line (xs(:,i).', ys(:,i).', "color", __next_line_color__ (),
-		    "parent", hg, varargin{idx+1:end});
+		    "parent", hg, args{:});
 	
         addproperty ("color", hg, "linecolor", get (tmp, "color"));
 	addproperty ("linewidth", hg, "linelinewidth", get (tmp, "linewidth"));
 	addproperty ("linestyle", hg, "linelinestyle", get (tmp, "linestyle"));
 
 	addproperty ("marker", hg, "linemarker", get (tmp, "marker"));
 	addproperty ("markerfacecolor", hg, "linemarkerfacecolor",
 		     get (tmp, "markerfacecolor"));
diff --git a/scripts/plot/stem.m b/scripts/plot/stem.m
--- a/scripts/plot/stem.m
+++ b/scripts/plot/stem.m
@@ -66,17 +66,17 @@
 ## @seealso{bar, barh, plot}
 ## @end deftypefn
 
 ## Author: Michel D. Schmid <michaelschmid@users.sourceforge.net>
 ## Adapted-by: jwe
 
 function h = stem (varargin)
 
-  if (nargin < 1 || nargin > 3)
+  if (nargin < 1)
     print_usage ();
   endif
 
   tmp = __stem__ (false, varargin{:});
 
   if (nargout > 0)
     h = tmp;
   endif
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,13 @@
+2008-08-28  David Bateman  <dbateman@free.fr>
+
+	* graphics.h.in (root_figure::properties::showhiddenhandles):
+	New property.
+
 2008-08-27  Jaroslav Hajek  <highegg@gmail.com>
 
 	* DLD-FUNCTIONS/__glpk__.cc (F__glpk__): Initialize output vectors 
 	by NA value.
 
 2008-08-26 Ben Abbott <bpabott@mac.com>
 
 	* mappers.cc: Adjust tolerance for single precesion tests.
diff --git a/src/graphics.h.in b/src/graphics.h.in
--- a/src/graphics.h.in
+++ b/src/graphics.h.in
@@ -2088,16 +2088,17 @@ public:
     void remove_child (const graphics_handle& h);
     
     // See the genprops.awk script for an explanation of the
     // properties declarations.
 
     BEGIN_PROPERTIES(root_figure)
       handle_property currentfigure S , graphics_handle ()
       handle_property callbackobject Sr , graphics_handle ()
+      bool_property showhiddenhandles , "off"
     END_PROPERTIES
 
   private:
     std::list<graphics_handle> cbo_stack;
   };
 
 private:
   properties xproperties;
