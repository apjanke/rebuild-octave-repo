# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1266898041 18000
#      Mon Feb 22 23:07:21 2010 -0500
# Node ID d4d13389c957fa79527ae6980ef8a5f5e2eb28b5
# Parent  df1df5f0c236c93dbb132e3a2764de96f0d8ebf6
make load-save to matlab format work when using --enable-64

diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,43 @@
+2010-02-22  John W. Eaton  <jwe@octave.org>
+
+	* data-conv.cc, data-conv.h (read_floats, read_doubles,
+	do_float_format_conversion, do_double_format_conversion):
+	Declare len arg and loop counter as octave_idx_type, not int.
+	(strip_spaces): Use size_t for string dimension and index, not int.
+	(LS_DO_READ, LS_DO_WRITE): Declare loop counter as
+	octave_idx_type, not int.
+	(write_floats, write_doubles):
+	Declare len arg as octave_idx_type, not int.
+	(IEEE_big_double_to_IEEE_little_double,
+	VAX_D_double_to_IEEE_little_double,
+	VAX_G_double_to_IEEE_little_double,
+	Cray_to_IEEE_little_double,
+	IEEE_big_float_to_IEEE_little_float,
+	VAX_D_float_to_IEEE_little_float,
+	VAX_G_float_to_IEEE_little_float, Cray_to_IEEE_little_float,
+	IEEE_little_double_to_IEEE_big_double,
+	VAX_D_double_to_IEEE_big_double,
+	VAX_G_double_to_IEEE_big_double, Cray_to_IEEE_big_double,
+	IEEE_little_float_to_IEEE_big_float,
+	VAX_D_float_to_IEEE_big_float, VAX_G_float_to_IEEE_big_float,
+	Cray_to_IEEE_big_float, IEEE_little_double_to_VAX_D_double,
+	IEEE_big_double_to_VAX_D_double,
+	VAX_G_double_to_VAX_D_double, Cray_to_VAX_D_double,
+	IEEE_little_float_to_VAX_D_float,
+	IEEE_big_float_to_VAX_D_float, VAX_G_float_to_VAX_D_float,
+	Cray_to_VAX_D_float, IEEE_little_double_to_VAX_G_double,
+	IEEE_big_double_to_VAX_G_double,
+	VAX_D_double_to_VAX_G_double, Cray_to_VAX_G_double,
+	IEEE_little_float_to_VAX_G_float,
+	IEEE_big_float_to_VAX_G_float, VAX_D_float_to_VAX_G_float,
+	Cray_to_VAX_G_float, read_doubles):
+	Declare len arg as octave_idx_type, not int.
+
 2010-02-21  Michael Goffioul  <michael.goffioul@gmail.com>
 
 	* lo-sysdep.cc, lo-utils.h, oct-shlib.h: Define WIN32_LEAN_AND_MEAN
 	and don't #undef min/max.
 	* oct-inttypes.h: Don't #undef min/max.
 
 	* oct-glob.cc (octave_glob): Convert backslashes to forward slashes
 	automatically before calling glob, and convert back after the call
diff --git a/liboctave/data-conv.cc b/liboctave/data-conv.cc
--- a/liboctave/data-conv.cc
+++ b/liboctave/data-conv.cc
@@ -129,23 +129,23 @@ init_sized_type_lookup_table (oct_data_c
 
       bits *= 2;
     }
 }
 
 static std::string
 strip_spaces (const std::string& str)
 {
-  int n = str.length ();
+  size_t n = str.length ();
 
-  int k = 0;
+  size_t k = 0;
 
   std::string s (n, ' ');
 
-  for (int i = 0; i < n; i++)
+  for (size_t i = 0; i < n; i++)
     if (! isspace (str[i]))
       s[k++] = tolower (str[i]);
 
   s.resize (k);
 
   return s;
 }
 
@@ -485,34 +485,34 @@ oct_data_conv::data_type_as_string (oct_
   do \
     { \
       if (len > 0) \
         { \
           OCTAVE_LOCAL_BUFFER (TYPE, ptr, len); \
           stream.read (reinterpret_cast<char *>  (ptr), size * len); \
           if (swap) \
             swap_bytes< size > (ptr, len); \
-          for (int i = 0; i < len; i++) \
+          for (octave_idx_type i = 0; i < len; i++) \
             data[i] = ptr[i]; \
         } \
     } \
   while (0)
 
 // Have to use copy here to avoid writing over data accessed via
 // Matrix::data().
 
 #define LS_DO_WRITE(TYPE, data, size, len, stream) \
   do \
     { \
       if (len > 0) \
         { \
           char tmp_type = type; \
           stream.write (&tmp_type, 1); \
           OCTAVE_LOCAL_BUFFER (TYPE, ptr, len); \
-          for (int i = 0; i < len; i++) \
+          for (octave_idx_type i = 0; i < len; i++) \
             ptr[i] = static_cast <TYPE> (data[i]);         \
           stream.write (reinterpret_cast<char *> (ptr), size * len); \
         } \
     } \
   while (0)
 
 // Loading variables from files.
 
@@ -535,209 +535,209 @@ gripe_data_conversion (const char *from,
 // Currently, we only handle conversions for the IEEE types.  To fix
 // that, make more of the following routines work.
 
 // FIXME -- assumes sizeof (Complex) == 8
 // FIXME -- assumes sizeof (double) == 8
 // FIXME -- assumes sizeof (float) == 4
 
 static void
-IEEE_big_double_to_IEEE_little_double (void *d, int len)
+IEEE_big_double_to_IEEE_little_double (void *d, octave_idx_type len)
 {
   swap_bytes<8> (d, len);
 }
 
 static void
-VAX_D_double_to_IEEE_little_double (void * /* d */, int /* len */)
+VAX_D_double_to_IEEE_little_double (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("VAX D float", "IEEE little endian format");
 }
 
 static void
-VAX_G_double_to_IEEE_little_double (void * /* d */, int /* len */)
+VAX_G_double_to_IEEE_little_double (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("VAX G float", "IEEE little endian format");
 }
 
 static void
-Cray_to_IEEE_little_double (void * /* d */, int /* len */)
+Cray_to_IEEE_little_double (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("Cray", "IEEE little endian format");
 }
 
 static void
-IEEE_big_float_to_IEEE_little_float (void *d, int len)
+IEEE_big_float_to_IEEE_little_float (void *d, octave_idx_type len)
 {
   swap_bytes<4> (d, len);
 }
 
 static void
-VAX_D_float_to_IEEE_little_float (void * /* d */, int /* len */)
+VAX_D_float_to_IEEE_little_float (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("VAX D float", "IEEE little endian format");
 }
 
 static void
-VAX_G_float_to_IEEE_little_float (void * /* d */, int /* len */)
+VAX_G_float_to_IEEE_little_float (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("VAX G float", "IEEE little endian format");
 }
 
 static void
-Cray_to_IEEE_little_float (void * /* d */, int /* len */)
+Cray_to_IEEE_little_float (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("Cray", "IEEE little endian format");
 }
 
 static void
-IEEE_little_double_to_IEEE_big_double (void *d, int len)
+IEEE_little_double_to_IEEE_big_double (void *d, octave_idx_type len)
 {
   swap_bytes<8> (d, len);
 }
 
 static void
-VAX_D_double_to_IEEE_big_double (void * /* d */, int /* len */)
+VAX_D_double_to_IEEE_big_double (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("VAX D float", "IEEE big endian format");
 }
 
 static void
-VAX_G_double_to_IEEE_big_double (void * /* d */, int /* len */)
+VAX_G_double_to_IEEE_big_double (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("VAX G float", "IEEE big endian format");
 }
 
 static void
-Cray_to_IEEE_big_double (void * /* d */, int /* len */)
+Cray_to_IEEE_big_double (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("Cray", "IEEE big endian format");
 }
 
 static void
-IEEE_little_float_to_IEEE_big_float (void *d, int len)
+IEEE_little_float_to_IEEE_big_float (void *d, octave_idx_type len)
 {
   swap_bytes<4> (d, len);
 }
 
 static void
-VAX_D_float_to_IEEE_big_float (void * /* d */, int /* len */)
+VAX_D_float_to_IEEE_big_float (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("VAX D float", "IEEE big endian format");
 }
 
 static void
-VAX_G_float_to_IEEE_big_float (void * /* d */, int /* len */)
+VAX_G_float_to_IEEE_big_float (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("VAX G float", "IEEE big endian format");
 }
 
 static void
-Cray_to_IEEE_big_float (void * /* d */, int /* len */)
+Cray_to_IEEE_big_float (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("Cray", "IEEE big endian format");
 }
 
 static void
-IEEE_little_double_to_VAX_D_double (void * /* d */, int /* len */)
+IEEE_little_double_to_VAX_D_double (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("IEEE little endian", "VAX D");
 }
 
 static void
-IEEE_big_double_to_VAX_D_double (void * /* d */, int /* len */)
+IEEE_big_double_to_VAX_D_double (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("IEEE big endian", "VAX D");
 }
 
 static void
-VAX_G_double_to_VAX_D_double (void * /* d */, int /* len */)
+VAX_G_double_to_VAX_D_double (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("VAX G float", "VAX D");
 }
 
 static void
-Cray_to_VAX_D_double (void * /* d */, int /* len */)
+Cray_to_VAX_D_double (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("Cray", "VAX D");
 }
 
 static void
-IEEE_little_float_to_VAX_D_float (void * /* d */, int /* len */)
+IEEE_little_float_to_VAX_D_float (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("IEEE little endian", "VAX D");
 }
 
 static void
-IEEE_big_float_to_VAX_D_float (void * /* d */, int /* len */)
+IEEE_big_float_to_VAX_D_float (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("IEEE big endian", "VAX D");
 }
 
 static void
-VAX_G_float_to_VAX_D_float (void * /* d */, int /* len */)
+VAX_G_float_to_VAX_D_float (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("VAX G float", "VAX D");
 }
 
 static void
-Cray_to_VAX_D_float (void * /* d */, int /* len */)
+Cray_to_VAX_D_float (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("Cray", "VAX D");
 }
 
 static void
-IEEE_little_double_to_VAX_G_double (void * /* d */, int /* len */)
+IEEE_little_double_to_VAX_G_double (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("IEEE little endian", "VAX G");
 }
 
 static void
-IEEE_big_double_to_VAX_G_double (void * /* d */, int /* len */)
+IEEE_big_double_to_VAX_G_double (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("IEEE big endian", "VAX G");
 }
 
 static void
-VAX_D_double_to_VAX_G_double (void * /* d */, int /* len */)
+VAX_D_double_to_VAX_G_double (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("VAX D float", "VAX G");
 }
 
 static void
-Cray_to_VAX_G_double (void * /* d */, int /* len */)
+Cray_to_VAX_G_double (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("VAX G float", "VAX G");
 }
 
 static void
-IEEE_little_float_to_VAX_G_float (void * /* d */, int /* len */)
+IEEE_little_float_to_VAX_G_float (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("IEEE little endian", "VAX G");
 }
 
 static void
-IEEE_big_float_to_VAX_G_float (void * /* d */, int /* len */)
+IEEE_big_float_to_VAX_G_float (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("IEEE big endian", "VAX G");
 }
 
 static void
-VAX_D_float_to_VAX_G_float (void * /* d */, int /* len */)
+VAX_D_float_to_VAX_G_float (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("VAX D float", "VAX G");
 }
 
 static void
-Cray_to_VAX_G_float (void * /* d */, int /* len */)
+Cray_to_VAX_G_float (void * /* d */, octave_idx_type /* len */)
 {
   gripe_data_conversion ("VAX G float", "VAX G");
 }
 
 void
-do_double_format_conversion (void *data, int len,
+do_double_format_conversion (void *data, octave_idx_type len,
                              oct_mach_info::float_format from_fmt,
                              oct_mach_info::float_format to_fmt)
 {
   switch (to_fmt)
     {
     case oct_mach_info::flt_fmt_ieee_little_endian:
       switch (from_fmt)
         {
@@ -854,17 +854,17 @@ do_double_format_conversion (void *data,
       (*current_liboctave_error_handler)
         ("impossible state reached in file `%s' at line %d",
          __FILE__, __LINE__);
       break;
     }
 }
 
 void
-do_float_format_conversion (void *data, int len,
+do_float_format_conversion (void *data, octave_idx_type len,
                             oct_mach_info::float_format from_fmt,
                             oct_mach_info::float_format to_fmt)
 {
   switch (to_fmt)
     {
     case oct_mach_info::flt_fmt_ieee_little_endian:
       switch (from_fmt)
         {
@@ -981,17 +981,17 @@ do_float_format_conversion (void *data, 
       (*current_liboctave_error_handler)
         ("impossible state reached in file `%s' at line %d",
          __FILE__, __LINE__);
       break;
     }
 }
 
 void
-do_float_format_conversion (void *data, size_t sz, int len,
+do_float_format_conversion (void *data, size_t sz, octave_idx_type len,
                             oct_mach_info::float_format from_fmt,
                             oct_mach_info::float_format to_fmt)
 {
   switch (sz)
     {
     case sizeof (float):
       do_float_format_conversion (data, len, from_fmt, to_fmt);
       break;
@@ -1005,18 +1005,19 @@ do_float_format_conversion (void *data, 
         ("impossible state reached in file `%s' at line %d",
          __FILE__, __LINE__);
       break;
     }
 }
 
 
 void
-read_doubles (std::istream& is, double *data, save_type type, int len,
-              bool swap, oct_mach_info::float_format fmt)
+read_doubles (std::istream& is, double *data, save_type type,
+              octave_idx_type len, bool swap,
+              oct_mach_info::float_format fmt)
 {
   switch (type)
     {
     case LS_U_CHAR:
       LS_DO_READ (uint8_t, swap, data, 1, len, is);
       break;
 
     case LS_U_SHORT:
@@ -1039,17 +1040,17 @@ read_doubles (std::istream& is, double *
       LS_DO_READ (int32_t, swap, data, 4, len, is);
       break;
 
     case LS_FLOAT:
       {
         OCTAVE_LOCAL_BUFFER (float, ptr, len);
         is.read (reinterpret_cast<char *> (ptr), 4 * len);
         do_float_format_conversion (ptr, len, fmt);
-        for (int i = 0; i < len; i++)
+        for (octave_idx_type i = 0; i < len; i++)
           data[i] = ptr[i];
       }
       break;
 
     case LS_DOUBLE: // No conversion necessary.
       {
         is.read (reinterpret_cast<char *> (data), 8 * len);
         do_double_format_conversion (data, len, fmt);
@@ -1061,18 +1062,19 @@ read_doubles (std::istream& is, double *
 
     default:
       is.clear (std::ios::failbit|is.rdstate ());
       break;
     }
 }
 
 void
-read_floats (std::istream& is, float *data, save_type type, int len,
-              bool swap, oct_mach_info::float_format fmt)
+read_floats (std::istream& is, float *data, save_type type,
+             octave_idx_type len, bool swap,
+             oct_mach_info::float_format fmt)
 {
   switch (type)
     {
     case LS_U_CHAR:
       LS_DO_READ (uint8_t, swap, data, 1, len, is);
       break;
 
     case LS_U_SHORT:
@@ -1100,29 +1102,30 @@ read_floats (std::istream& is, float *da
       do_float_format_conversion (data, len, fmt);
       break;
 
     case LS_DOUBLE:
       {
         OCTAVE_LOCAL_BUFFER (double, ptr, len);
         is.read (reinterpret_cast<char *> (ptr), 8 * len);
         do_double_format_conversion (ptr, len, fmt);
-        for (int i = 0; i < len; i++)
+        for (octave_idx_type i = 0; i < len; i++)
           data[i] = ptr[i];
       }
       break;
 
     default:
       is.clear (std::ios::failbit|is.rdstate ());
       break;
     }
 }
 
 void
-write_doubles (std::ostream& os, const double *data, save_type type, int len)
+write_doubles (std::ostream& os, const double *data, save_type type,
+               octave_idx_type len)
 {
   switch (type)
     {
     case LS_U_CHAR:
       LS_DO_WRITE (uint8_t, data, 1, len, os);
       break;
 
     case LS_U_SHORT:
@@ -1160,17 +1163,18 @@ write_doubles (std::ostream& os, const d
     default:
       (*current_liboctave_error_handler)
         ("unrecognized data format requested");
       break;
     }
 }
 
 void
-write_floats (std::ostream& os, const float *data, save_type type, int len)
+write_floats (std::ostream& os, const float *data, save_type type,
+              octave_idx_type len)
 {
   switch (type)
     {
     case LS_U_CHAR:
       LS_DO_WRITE (uint8_t, data, 1, len, os);
       break;
 
     case LS_U_SHORT:
diff --git a/liboctave/data-conv.h b/liboctave/data-conv.h
--- a/liboctave/data-conv.h
+++ b/liboctave/data-conv.h
@@ -87,38 +87,42 @@ enum save_type
     LS_INT     = 5,
     LS_FLOAT   = 6,
     LS_DOUBLE  = 7,
     LS_U_LONG  = 8,
     LS_LONG    = 9
   };
 
 extern OCTAVE_API void
-do_double_format_conversion (void *data, int len,
+do_double_format_conversion (void *data, octave_idx_type len,
                              oct_mach_info::float_format from_fmt,
                              oct_mach_info::float_format to_fmt
                                = oct_mach_info::native_float_format ());
 
 extern OCTAVE_API void
-do_float_format_conversion (void *data, int len,
+do_float_format_conversion (void *data, octave_idx_type len,
                             oct_mach_info::float_format from_fmt,
                             oct_mach_info::float_format to_fmt
                               = oct_mach_info::native_float_format ());
 
 extern OCTAVE_API void
-do_float_format_conversion (void *data, size_t sz, int len,
+do_float_format_conversion (void *data, size_t sz, octave_idx_type len,
                             oct_mach_info::float_format from_fmt,
                             oct_mach_info::float_format to_fmt
                               = oct_mach_info::native_float_format ());
 
 extern OCTAVE_API void
-read_doubles (std::istream& is, double *data, save_type type, int len,
-              bool swap, oct_mach_info::float_format fmt);
+read_doubles (std::istream& is, double *data, save_type type,
+              octave_idx_type len, bool swap, oct_mach_info::float_format fmt);
+
 extern OCTAVE_API void
-write_doubles (std::ostream& os, const double *data, save_type type, int len);
+write_doubles (std::ostream& os, const double *data, save_type type,
+               octave_idx_type len);
 
 extern OCTAVE_API void
-read_floats (std::istream& is, float *data, save_type type, int len,
-              bool swap, oct_mach_info::float_format fmt);
+read_floats (std::istream& is, float *data, save_type type,
+             octave_idx_type len, bool swap, oct_mach_info::float_format fmt);
+
 extern OCTAVE_API void
-write_floats (std::ostream& os, const float *data, save_type type, int len);
+write_floats (std::ostream& os, const float *data, save_type type,
+              octave_idx_type len);
 
 #endif
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,39 @@
+2010-02-22  John W. Eaton  <jwe@octave.org>
+
+	* ls-mat5.cc: Use numel instead of nelem consistently and where
+	appropriate in all functions.
+	(read_mat5_binary_element): Declare ridx and cidx as pointer to
+	octave_idx_type, not int.
+	(read_mat5_integer_data): Declare count as octave_idx_type, not int.
+	(READ_INTEGER_DATA): Loop counter is octave_idx_type, not int.
+	(OCTAVE_MAT5_INTEGER_READ): Declare n and loop counter as
+	octave_idx_type, not int.
+	(read_mat5_binary_element): Rows and columns of sparse matrix
+	are octave_idx_type, not int.  Declare nzmax and nnz as
+	octave_idx_type.  Read nzmax as 32-bit int, and assign.  Move
+	decls closer to first use.
+	(read_mat5_binary_data): Declare count as octave_idx_type, not int.
+	(read_mat5_binary_element, write_mat5_array):
+	Use octave_idx_type instead of int for numel and loop counters.
+	(write_mat5_array): Declare len and nel as octave_idx_type.
+	Move declarations closer to first use.
+	(write_mat5_tag): Declare bytes arg as octave_idx_type, not int.
+	(write_mat5_integer_data): Declare nel as octave_idx_type, not int.
+	(write_mat5_cell_array): Declare nel and loop counter as
+	octave_idx_type, not int.
+	(save_mat5_array_length): Declare nel nad loop counters as
+	octave_idx_type, not int.
+	(save_mat5_binary_element): Declare dims and counters as
+	octave_idx_type, not int. Delete unused streampos variables.
+	Call write_mat5_sparse_index_vector to write ridx and cidx.
+	Don't write element if dimension is too large to save.
+	(gripe_dim_too_large, write_mat5_sparse_index_vector): New functions.
+
 2010-02-22  Carlo de Falco <kingcrimson@tiscali.it>
 
 	* dirfns.cc (Fglob): Make glob function test more robust.
 
 2010-02-21  Michael Goffioul  <michael.goffioul@gmail.com>
 
 	* gl-render.h: Define WIN32_LEAN_AND_MEAN and don't #undef min/max.
 	* DLD-FUNCTIONS/fltk_backend.cc: Don't #undef min/max.
@@ -13,16 +44,18 @@ 2010-02-21  Michael Goffioul  <michael.g
 	* ov-bool.h (class octave_bool): Add OCTINTERP_API.
 	* unwind-prot.h (class unwind_protect_safe): Ditto.
 
 	* Makefile.am: Add -bindir flag to liboctinterp_la_LDFLAGS. Remove
 	temporary libtool module file after copying oct file.
 
 2010-02-19  John W. Eaton  <jwe@octave.org>
 
+2010-02-19  John W. Eaton  <jwe@octave.org>
+
 	* DLD-FUNCTIONS/qr.cc: Increase tolerance for test.
 
 2010-02-19  Jaroslav Hajek  <highegg@gmail.com>
 
 	* ov-lazy-idx.cc (octave_lazy_index::reshape,
 	octave_lazy_index::squeeze, octave_lazy_index::permute,
 	octave_lazy_index::sort, octave_lazy_index::is_sorted,
 	octave_lazy_index::sort_rows_idx, octave_lazy_index::is_sorted_rows):
diff --git a/src/ls-mat5.cc b/src/ls-mat5.cc
--- a/src/ls-mat5.cc
+++ b/src/ls-mat5.cc
@@ -118,17 +118,17 @@ enum arrayclasstype
 
 // Read COUNT elements of data from IS in the format specified by TYPE,
 // placing the result in DATA.  If SWAP is TRUE, swap the bytes of
 // each element before copying to DATA.  FLT_FMT specifies the format
 // of the data if we are reading floating point numbers.
 
 static void
 read_mat5_binary_data (std::istream& is, double *data,
-                       int count, bool swap, mat5_data_type type,
+                       octave_idx_type  count, bool swap, mat5_data_type type,
                        oct_mach_info::float_format flt_fmt)
 {
   
   switch (type)
     {
     case miINT8:
       read_doubles (is, data, LS_CHAR, count, swap, flt_fmt);
       break;
@@ -183,30 +183,30 @@ read_mat5_binary_data (std::istream& is,
     case miMATRIX:
     default:
       break;
     }
 }
 
 template <class T>
 void
-read_mat5_integer_data (std::istream& is, T *m, int count, bool swap,
-                        mat5_data_type type)
+read_mat5_integer_data (std::istream& is, T *m, octave_idx_type count,
+                        bool swap, mat5_data_type type)
 {
 
 #define READ_INTEGER_DATA(TYPE, swap, data, size, len, stream)  \
   do \
     { \
       if (len > 0) \
         { \
           OCTAVE_LOCAL_BUFFER (TYPE, ptr, len); \
           stream.read (reinterpret_cast<char *> (ptr), size * len); \
           if (swap) \
             swap_bytes< size > (ptr, len); \
-          for (int i = 0; i < len; i++) \
+          for (octave_idx_type i = 0; i < len; i++) \
             data[i] = ptr[i]; \
         } \
     } \
   while (0)
 
   switch (type)
     {
     case miINT8:
@@ -252,58 +252,74 @@ read_mat5_integer_data (std::istream& is
     default:
       break;
     }
 
 #undef READ_INTEGER_DATA
 
 }
 
-template void read_mat5_integer_data (std::istream& is, octave_int8 *m,
-                                      int count, bool swap,
-                                      mat5_data_type type);
-template void read_mat5_integer_data (std::istream& is, octave_int16 *m,
-                                      int count, bool swap,
-                                      mat5_data_type type);
-template void read_mat5_integer_data (std::istream& is, octave_int32 *m,
-                                      int count, bool swap,
-                                      mat5_data_type type);
-template void read_mat5_integer_data (std::istream& is, octave_int64 *m,
-                                      int count, bool swap,
-                                      mat5_data_type type);
-template void read_mat5_integer_data (std::istream& is, octave_uint8 *m,
-                                      int count, bool swap,
-                                      mat5_data_type type);
-template void read_mat5_integer_data (std::istream& is, octave_uint16 *m,
-                                      int count, bool swap,
-                                      mat5_data_type type);
-template void read_mat5_integer_data (std::istream& is, octave_uint32 *m,
-                                      int count, bool swap,
-                                      mat5_data_type type);
-template void read_mat5_integer_data (std::istream& is, octave_uint64 *m,
-                                      int count, bool swap,
-                                      mat5_data_type type);
+template void
+read_mat5_integer_data (std::istream& is, octave_int8 *m,
+                        octave_idx_type count, bool swap,
+                        mat5_data_type type);
+
+template void
+read_mat5_integer_data (std::istream& is, octave_int16 *m,
+                        octave_idx_type count, bool swap,
+                        mat5_data_type type);
+
+template void
+read_mat5_integer_data (std::istream& is, octave_int32 *m,
+                        octave_idx_type count, bool swap,
+                        mat5_data_type type);
+
+template void
+read_mat5_integer_data (std::istream& is, octave_int64 *m,
+                        octave_idx_type count, bool swap,
+                        mat5_data_type type);
 
-template void read_mat5_integer_data (std::istream& is, int *m,
-                                      int count, bool swap,
-                                      mat5_data_type type);
+template void
+read_mat5_integer_data (std::istream& is, octave_uint8 *m,
+                        octave_idx_type count, bool swap,
+                        mat5_data_type type);
+
+template void
+read_mat5_integer_data (std::istream& is, octave_uint16 *m,
+                        octave_idx_type count, bool swap,
+                        mat5_data_type type);
+
+template void
+read_mat5_integer_data (std::istream& is, octave_uint32 *m,
+                        octave_idx_type count, bool swap,
+                        mat5_data_type type);
+
+template void
+read_mat5_integer_data (std::istream& is, octave_uint64 *m,
+                        octave_idx_type count, bool swap,
+                        mat5_data_type type);
+
+template void
+read_mat5_integer_data (std::istream& is, int *m,
+                        octave_idx_type count, bool swap,
+                        mat5_data_type type);
 
 #define OCTAVE_MAT5_INTEGER_READ(TYP) \
   { \
         TYP re (dims); \
   \
         std::streampos tmp_pos; \
   \
         if (read_mat5_tag (is, swap, type, len)) \
           { \
             error ("load: reading matrix data for `%s'", retval.c_str ()); \
             goto data_read_error; \
           } \
   \
-        int n = re.length (); \
+        octave_idx_type n = re.numel (); \
         tmp_pos = is.tellg (); \
         read_mat5_integer_data (is, re.fortran_vec (), n, swap, \
                                 static_cast<enum mat5_data_type> (type)); \
   \
         if (! is || error_state) \
           { \
             error ("load: reading matrix data for `%s'", retval.c_str ()); \
             goto data_read_error; \
@@ -318,30 +334,30 @@ template void read_mat5_integer_data (st
   \
             if (read_mat5_tag (is, swap, type, len)) \
               { \
                 error ("load: reading matrix data for `%s'", \
                        retval.c_str ()); \
                 goto data_read_error; \
               } \
   \
-            n = im.length (); \
+            n = im.numel (); \
             read_mat5_binary_data (is, im.fortran_vec (), n, swap, \
                                    static_cast<enum mat5_data_type> (type), flt_fmt); \
   \
             if (! is || error_state) \
               { \
                 error ("load: reading imaginary matrix data for `%s'", \
                        retval.c_str ()); \
                 goto data_read_error; \
               } \
   \
             ComplexNDArray ctmp (dims); \
   \
-            for (int i = 0; i < n; i++) \
+            for (octave_idx_type i = 0; i < n; i++) \
               ctmp(i) = Complex (re(i).double_value (), im(i)); \
   \
             tc = ctmp;  \
           } \
         else \
           tc = re; \
   }
   
@@ -401,54 +417,51 @@ read_int (std::istream& is, bool swap, i
 // FILENAME is used for error messages.
 
 std::string
 read_mat5_binary_element (std::istream& is, const std::string& filename,
                           bool swap, bool& global, octave_value& tc)
 {
   std::string retval;
 
-  // These are initialized here instead of closer to where they are
-  // first used to avoid errors from gcc about goto crossing
+  global = false;
+
+  // NOTE: these are initialized here instead of closer to where they
+  // are first used to avoid errors from gcc about goto crossing
   // initialization of variable.
 
-  oct_mach_info::float_format flt_fmt = oct_mach_info::flt_fmt_unknown;
-  int32_t type = 0;
-  std::string classname;
+  bool imag;
   bool isclass = false;
-  bool imag;
   bool logicalvar;
+  dim_vector dims;
   enum arrayclasstype arrayclass;
-  int32_t nzmax;
-  int32_t flags;
-  dim_vector dims;
-  int32_t len;
-  int32_t element_length;
-  std::streampos pos;
-  int16_t number;
-  number = *(reinterpret_cast<const int16_t *>("\x00\x01"));
-
-  global = false;
+  int16_t number = *(reinterpret_cast<const int16_t *>("\x00\x01"));
+  octave_idx_type nzmax;
+  std::string classname;
 
   // MAT files always use IEEE floating point
+  oct_mach_info::float_format flt_fmt = oct_mach_info::flt_fmt_unknown;
   if ((number == 1) ^ swap)
     flt_fmt = oct_mach_info::flt_fmt_ieee_big_endian;
   else
     flt_fmt = oct_mach_info::flt_fmt_ieee_little_endian;
 
   // element type and length
+  int32_t type = 0;
+  int32_t element_length;
   if (read_mat5_tag (is, swap, type, element_length))
     return retval;                      // EOF
 
 #ifdef HAVE_ZLIB
   if (type == miCOMPRESSED)
     {
-      // If C++ allowed us direct access to the file descriptor of an ifstream 
-      // in a uniform way, the code below could be vastly simplified, and 
-      // additional copies of the data in memory wouldn't be needed!!
+      // If C++ allowed us direct access to the file descriptor of an
+      // ifstream in a uniform way, the code below could be vastly
+      // simplified, and additional copies of the data in memory
+      // wouldn't be needed.
 
       OCTAVE_LOCAL_BUFFER (char, inbuf, element_length);
       is.read (inbuf, element_length);
 
       // We uncompress the first 8 bytes of the header to get the buffer length
       // This will fail with an error Z_MEM_ERROR
       uLongf destLen = 8;
       OCTAVE_LOCAL_BUFFER (unsigned int, tmp, 2);
@@ -460,18 +473,19 @@ read_mat5_binary_element (std::istream& 
           if (swap)
             swap_bytes<4> (tmp, 2);
 
           destLen = tmp[1] + 8;
           std::string outbuf (destLen, ' '); 
 
           // FIXME -- find a way to avoid casting away const here!
 
-          int err = uncompress (reinterpret_cast<Bytef *> (const_cast<char *> (outbuf.c_str ())), &destLen, 
-                                reinterpret_cast<Bytef *> (inbuf), element_length);
+          int err = uncompress (reinterpret_cast<Bytef *> (const_cast<char *> (outbuf.c_str ())),
+                                &destLen, reinterpret_cast<Bytef *> (inbuf),
+                                element_length);
 
           if (err != Z_OK)
             error ("load: error uncompressing data element");
           else
             {
               std::istringstream gz_is (outbuf);
               retval = read_mat5_binary_element (gz_is, filename, 
                                                  swap, global, tc);
@@ -479,44 +493,55 @@ read_mat5_binary_element (std::istream& 
         }
       else
         error ("load: error probing size of compressed data element");
 
       return retval;
     }
 #endif
 
+  std::streampos pos;
+
   if (type != miMATRIX)
     {
       pos = is.tellg ();
       error ("load: invalid element type = %d", type);
       goto early_read_error;
     }
 
   if (element_length == 0)
     {
       tc = Matrix ();
       return retval;
     }
 
   pos = is.tellg ();
 
   // array flags subelement
+  int32_t len;
   if (read_mat5_tag (is, swap, type, len) || type != miUINT32 || len != 8)
     {
       error ("load: invalid array flags subelement");
       goto early_read_error;
     }
 
+  int32_t flags;
   read_int (is, swap, flags);
+
   imag = (flags & 0x0800) != 0; // has an imaginary part?
+
   global = (flags & 0x0400) != 0; // global variable?
+
   logicalvar = (flags & 0x0200) != 0; // boolean ?
+
   arrayclass = static_cast<arrayclasstype> (flags & 0xff);
-  read_int (is, swap, nzmax);   // max number of non-zero in sparse
+  
+  int32_t tmp_nzmax;
+  read_int (is, swap, tmp_nzmax);   // max number of non-zero in sparse
+  nzmax = tmp_nzmax;
   
   // dimensions array subelement
   if (arrayclass != MAT_FILE_WORKSPACE_CLASS)
     {
       int32_t dim_len;
 
       if (read_mat5_tag (is, swap, type, dim_len) || type != miINT32)
         {
@@ -570,19 +595,19 @@ read_mat5_binary_element (std::istream& 
   }
 
   switch (arrayclass)
     {
     case MAT_FILE_CELL_CLASS:
       {
         Cell cell_array (dims);
 
-        int n = cell_array.length ();
+        octave_idx_type n = cell_array.numel ();
 
-        for (int i = 0; i < n; i++)
+        for (octave_idx_type i = 0; i < n; i++)
           {
             octave_value tc2;
 
             std::string nm
               = read_mat5_binary_element (is, filename, swap, global, tc2);
 
             if (! is || error_state)
               {
@@ -593,44 +618,36 @@ read_mat5_binary_element (std::istream& 
             cell_array(i) = tc2;
           }
 
         tc = cell_array;
       }
       break;
 
     case MAT_FILE_SPARSE_CLASS:
-#if SIZEOF_INT != SIZEOF_OCTAVE_IDX_TYPE
-      warning ("load: sparse objects are not implemented");
-      goto skip_ahead;
-#else
       {
-        int nr = dims(0);
-        int nc = dims(1);
+        octave_idx_type nr = dims(0);
+        octave_idx_type nc = dims(1);
         SparseMatrix sm;
         SparseComplexMatrix scm;
-        int *ridx;
-        int *cidx;
+        octave_idx_type *ridx;
+        octave_idx_type *cidx;
         double *data;
 
         // Setup return value
         if (imag)
           {
-            scm = SparseComplexMatrix (static_cast<octave_idx_type> (nr),
-                                       static_cast<octave_idx_type> (nc),
-                                       static_cast<octave_idx_type> (nzmax));
+            scm = SparseComplexMatrix (nr, nc, nzmax);
             ridx = scm.ridx ();
             cidx = scm.cidx ();
             data = 0;
           }
         else
           {
-            sm = SparseMatrix (static_cast<octave_idx_type> (nr),
-                               static_cast<octave_idx_type> (nc),
-                               static_cast<octave_idx_type> (nzmax));
+            sm = SparseMatrix (nr, nc, nzmax);
             ridx = sm.ridx ();
             cidx = sm.cidx ();
             data = sm.data ();
           }
 
         // row indices
         std::streampos tmp_pos;
           
@@ -675,21 +692,21 @@ read_mat5_binary_element (std::istream& 
 
         // real data subelement
         if (read_mat5_tag (is, swap, type, len))
           {
             error ("load: reading sparse matrix data for `%s'", retval.c_str ());
             goto data_read_error;
           }
 
-        int32_t nnz = cidx[nc];
+        octave_idx_type nnz = cidx[nc];
         NDArray re;
         if (imag)
           {
-            re = NDArray (dim_vector (static_cast<int> (nnz)));
+            re = NDArray (dim_vector (nnz));
             data = re.fortran_vec ();
           }
 
         tmp_pos = is.tellg ();
         read_mat5_binary_data (is, data, nnz, swap,
                                static_cast<enum mat5_data_type> (type), flt_fmt);
 
         if (! is || error_state)
@@ -716,25 +733,24 @@ read_mat5_binary_element (std::istream& 
 
             if (! is || error_state)
               {
                 error ("load: reading imaginary sparse matrix data for `%s'",
                        retval.c_str ());
                 goto data_read_error;
               }
 
-            for (int i = 0; i < nnz; i++)
+            for (octave_idx_type i = 0; i < nnz; i++)
               scm.xdata (i) = Complex (re (i), im (i));
 
             tc = scm;
           }
         else
           tc = sm;
       }
-#endif
       break;
 
     case MAT_FILE_FUNCTION_CLASS:
       {
         octave_value tc2;
         std::string nm
           = read_mat5_binary_element (is, filename, swap, global, tc2);
 
@@ -1139,20 +1155,20 @@ read_mat5_binary_element (std::istream& 
 
         // Logical variables can either be MAT_FILE_UINT8_CLASS or
         // MAT_FILE_DOUBLE_CLASS, so check if we have a logical
         // variable and convert it.
 
         if (logicalvar)
           {
             uint8NDArray in = tc.uint8_array_value ();
-            int nel = in.nelem ();
+            octave_idx_type nel = in.numel ();
             boolNDArray out (dims);
             
-            for (int i = 0; i < nel; i++)
+            for (octave_idx_type i = 0; i < nel; i++)
               out (i) = in(i).bool_value ();
 
             tc = out;
           }
       }
       break;
 
     case MAT_FILE_INT16_CLASS:
@@ -1193,17 +1209,17 @@ read_mat5_binary_element (std::istream& 
         std::streampos tmp_pos;
           
         if (read_mat5_tag (is, swap, type, len))
           {
             error ("load: reading matrix data for `%s'", retval.c_str ());
             goto data_read_error;
           }
 
-        int n = re.length ();
+        octave_idx_type n = re.numel ();
         tmp_pos = is.tellg ();
         read_mat5_binary_data (is, re.fortran_vec (), n, swap,
                                static_cast<enum mat5_data_type> (type), flt_fmt);
 
         if (! is || error_state)
           {
             error ("load: reading matrix data for `%s'", retval.c_str ());
             goto data_read_error;
@@ -1214,59 +1230,59 @@ read_mat5_binary_element (std::istream& 
         if (logicalvar)
           {
             // Logical variables can either be MAT_FILE_UINT8_CLASS or
             // MAT_FILE_DOUBLE_CLASS, so check if we have a logical
             // variable and convert it.
 
             boolNDArray out (dims);
             
-            for (int i = 0; i < n; i++)
+            for (octave_idx_type i = 0; i < n; i++)
               out (i) = static_cast<bool> (re (i));
 
             tc = out;
           }
         else if (imag)
           {
             // imaginary data subelement
 
             NDArray im (dims);
           
             if (read_mat5_tag (is, swap, type, len))
               {
                 error ("load: reading matrix data for `%s'", retval.c_str ());
                 goto data_read_error;
               }
 
-            n = im.length ();
+            n = im.numel ();
             read_mat5_binary_data (is, im.fortran_vec (), n, swap,
                                    static_cast<enum mat5_data_type> (type), flt_fmt);
 
             if (! is || error_state)
               {
                 error ("load: reading imaginary matrix data for `%s'",
                        retval.c_str ());
                 goto data_read_error;
               }
 
             ComplexNDArray ctmp (dims);
 
-            for (int i = 0; i < n; i++)
+            for (octave_idx_type i = 0; i < n; i++)
               ctmp(i) = Complex (re(i), im(i));
 
             tc = ctmp;
           }
         else
           {
             if (arrayclass == MAT_FILE_CHAR_CLASS)
               {
                 if (type == miUTF16 || type == miUTF32)
                   {
                     bool found_big_char = false;
-                    for (int i = 0; i < n; i++)
+                    for (octave_idx_type i = 0; i < n; i++)
                       {
                         if (re(i) > 127) {
                           re(i) = '?';
                           found_big_char = true;
                         }
                       }
 
                     if (found_big_char)
@@ -1276,28 +1292,28 @@ read_mat5_binary_element (std::istream& 
                       }
                   }
                 else if (type == miUTF8)
                   {
                     // Search for multi-byte encoded UTF8 characters and
                     // replace with 0x3F for '?'... Give the user a warning
 
                     bool utf8_multi_byte = false;
-                    for (int i = 0; i < n; i++)
+                    for (octave_idx_type i = 0; i < n; i++)
                       {
                         unsigned char a = static_cast<unsigned char> (re(i));
                         if (a > 0x7f)
                           utf8_multi_byte = true;
                       }
                     
                     if (utf8_multi_byte)
                       {
                         warning ("load: can not read multi-byte encoded UTF8 characters.");
                         warning ("      Replacing unreadable characters with '?'.");
-                        for (int i = 0; i < n; i++)
+                        for (octave_idx_type i = 0; i < n; i++)
                           {
                             unsigned char a = static_cast<unsigned char> (re(i));
                             if (a > 0x7f)
                               re(i) = '?';
                           }
                       }
                   }
                 tc = re;
@@ -1372,17 +1388,17 @@ read_mat5_binary_file_header (std::istre
       read_mat5_binary_element (is, filename, swap, global, tc);
 
       if (!is || error_state)
         return -1;
 
       if (tc.is_uint8_type ())
         {
           const uint8NDArray itmp = tc.uint8_array_value();
-          octave_idx_type ilen = itmp.nelem ();
+          octave_idx_type ilen = itmp.numel ();
 
           // Why should I have to initialize outbuf as just overwrite
           std::string outbuf (ilen - 7, ' ');
 
           // FIXME -- find a way to avoid casting away const here
           char *ctmp = const_cast<char *> (outbuf.c_str ());
           for (octave_idx_type j = 8; j < ilen; j++)
             ctmp[j-8] = itmp(j).char_value ();
@@ -1400,17 +1416,17 @@ read_mat5_binary_file_header (std::istre
       // Reposition to just after the header
       is.seekg (128, std::ios::beg);
     }
 
   return 0;
 }
 
 static int 
-write_mat5_tag (std::ostream& is, int type, int bytes)
+write_mat5_tag (std::ostream& is, int type, octave_idx_type bytes)
 {
   int32_t temp;
 
   if (bytes > 0 && bytes <= 4)
     temp = (bytes << 16) + type;
   else
     {
       temp = type;
@@ -1428,65 +1444,65 @@ write_mat5_tag (std::ostream& is, int ty
   return 1;
 }
 
 // write out the numeric values in M to OS,
 // preceded by the appropriate tag.
 static void 
 write_mat5_array (std::ostream& os, const NDArray& m, bool save_as_floats)
 {
-  int nel = m.nelem ();
-  double max_val, min_val;
   save_type st = LS_DOUBLE;
-  mat5_data_type mst;
-  int size;
-  unsigned len;
   const double *data = m.data ();
 
 // Have to use copy here to avoid writing over data accessed via
 // Matrix::data().
 
 #define MAT5_DO_WRITE(TYPE, data, count, stream) \
   do \
     { \
       OCTAVE_LOCAL_BUFFER (TYPE, ptr, count); \
-      for (int i = 0; i < count; i++) \
+      for (octave_idx_type i = 0; i < count; i++) \
         ptr[i] = static_cast<TYPE> (data[i]); \
       stream.write (reinterpret_cast<char *> (ptr), count * sizeof (TYPE)); \
     } \
   while (0)
 
   if (save_as_floats)
     {
       if (m.too_large_for_float ())
         {
           warning ("save: some values too large to save as floats --");
           warning ("save: saving as doubles instead");
         }
       else
         st = LS_FLOAT;
     }
 
+  double max_val, min_val;
   if (m.all_integers (max_val, min_val))
     st = get_save_type (max_val, min_val);
 
+  mat5_data_type mst;
+  int size;
   switch (st)
     {
     default:
     case LS_DOUBLE:  mst = miDOUBLE; size = 8; break;
     case LS_FLOAT:   mst = miSINGLE; size = 4; break;
     case LS_U_CHAR:  mst = miUINT8;  size = 1; break;
     case LS_U_SHORT: mst = miUINT16; size = 2; break;
     case LS_U_INT:   mst = miUINT32; size = 4; break;
     case LS_CHAR:    mst = miINT8;   size = 1; break;
     case LS_SHORT:   mst = miINT16;  size = 2; break;
     case LS_INT:     mst = miINT32;  size = 4; break;
     }
 
-  len = nel*size;
+  octave_idx_type nel = m.numel ();
+  octave_idx_type len = nel*size;
+
   write_mat5_tag (os, mst, len);
 
   {
     switch (st)
       {
       case LS_U_CHAR:
         MAT5_DO_WRITE (uint8_t, data, nel, os);
         break;
@@ -1537,17 +1553,18 @@ write_mat5_array (std::ostream& os, cons
     {
       static char buf[9]="\x00\x00\x00\x00\x00\x00\x00\x00";
       os.write (buf, PAD (len) - len);
     }
 }
 
 template <class T>
 void 
-write_mat5_integer_data (std::ostream& os, const T *m, int size, int nel)
+write_mat5_integer_data (std::ostream& os, const T *m, int size,
+                         octave_idx_type nel)
 {
   mat5_data_type mst;
   unsigned len;
 
   switch (size)
     {
     case 1:
       mst = miUINT8;
@@ -1587,67 +1604,85 @@ write_mat5_integer_data (std::ostream& o
 
   if (PAD (len) > len)
     {
       static char buf[9]="\x00\x00\x00\x00\x00\x00\x00\x00";
       os.write (buf, PAD (len) - len);
     }
 }
 
-template void write_mat5_integer_data (std::ostream& os, const octave_int8 *m,
-                                       int size, int nel);
-template void write_mat5_integer_data (std::ostream& os, const octave_int16 *m,
-                                       int size, int nel);
-template void write_mat5_integer_data (std::ostream& os, const octave_int32 *m,
-                                       int size, int nel);
-template void write_mat5_integer_data (std::ostream& os, const octave_int64 *m,
-                                       int size, int nel);
-template void write_mat5_integer_data (std::ostream& os, const octave_uint8 *m,
-                                       int size, int nel);
-template void write_mat5_integer_data (std::ostream& os, const octave_uint16 *m,
-                                       int size, int nel);
-template void write_mat5_integer_data (std::ostream& os, const octave_uint32 *m,
-                                       int size, int nel);
-template void write_mat5_integer_data (std::ostream& os, const octave_uint64 *m,
-                                       int size, int nel);
-template void write_mat5_integer_data (std::ostream& os, const int *m, 
-                                       int size, int nel);
+template void
+write_mat5_integer_data (std::ostream& os, const octave_int8 *m,
+                         int size, octave_idx_type nel);
+
+template void
+write_mat5_integer_data (std::ostream& os, const octave_int16 *m,
+                         int size, octave_idx_type nel);
+
+template void
+write_mat5_integer_data (std::ostream& os, const octave_int32 *m,
+                         int size, octave_idx_type nel);
+
+template void
+write_mat5_integer_data (std::ostream& os, const octave_int64 *m,
+                         int size, octave_idx_type nel);
+
+template void
+write_mat5_integer_data (std::ostream& os, const octave_uint8 *m,
+                         int size, octave_idx_type nel);
+
+template void
+write_mat5_integer_data (std::ostream& os, const octave_uint16 *m,
+                         int size, octave_idx_type nel);
+
+template void
+write_mat5_integer_data (std::ostream& os, const octave_uint32 *m,
+                         int size, octave_idx_type nel);
+
+template void
+write_mat5_integer_data (std::ostream& os, const octave_uint64 *m,
+                         int size, octave_idx_type nel);
+
+template void
+write_mat5_integer_data (std::ostream& os, const int *m, 
+                         int size, octave_idx_type nel);
 
 // Write out cell element values in the cell array to OS, preceded by
 // the appropriate tag.
 
 static bool 
 write_mat5_cell_array (std::ostream& os, const Cell& cell,
                        bool mark_as_global, bool save_as_floats)
 {
-  int nel = cell.nelem ();
+  octave_idx_type nel = cell.numel ();
 
-  for (int i = 0; i < nel; i++)
+  for (octave_idx_type i = 0; i < nel; i++)
     {
       octave_value ov = cell(i);
 
       if (! save_mat5_binary_element (os, ov, "", mark_as_global,
                                       false, save_as_floats))
         return false;
     }
 
   return true;
 }
 
 int
-save_mat5_array_length (const double* val, int nel, bool save_as_floats)
+save_mat5_array_length (const double* val, octave_idx_type nel,
+                        bool save_as_floats)
 {
   if (nel > 0)
     {
       int size = 8;
 
       if (save_as_floats)
         {
           bool too_large_for_float = false;
-          for (int i = 0; i < nel; i++)
+          for (octave_idx_type i = 0; i < nel; i++)
             {
               double tmp = val [i];
 
               if (! (xisnan (tmp) || xisinf (tmp))
                   && fabs (tmp) > FLT_MAX)
                 {
                   too_large_for_float = true;
                   break;
@@ -1701,148 +1736,149 @@ save_mat5_array_length (const double* va
 
       return 8 + nel * size;
     }
   else
     return 8;
 }
 
 int
-save_mat5_array_length (const Complex* val, int nel, bool save_as_floats)
+save_mat5_array_length (const Complex* val, octave_idx_type nel,
+                        bool save_as_floats)
 {
   int ret;
 
   OCTAVE_LOCAL_BUFFER (double, tmp, nel);
 
-  for (int i = 1; i < nel; i++)
+  for (octave_idx_type i = 1; i < nel; i++)
     tmp[i] = std::real (val[i]);
 
   ret = save_mat5_array_length (tmp, nel, save_as_floats);
 
-  for (int i = 1; i < nel; i++)
+  for (octave_idx_type i = 1; i < nel; i++)
     tmp[i] = std::imag (val[i]);
 
   ret += save_mat5_array_length (tmp, nel, save_as_floats);
 
   return ret;
 }
 
 int
 save_mat5_element_length (const octave_value& tc, const std::string& name, 
                           bool save_as_floats, bool mat7_format)
 {
-  int max_namelen = (mat7_format ? 63 : 31);
-  int len = name.length ();
+  size_t max_namelen = (mat7_format ? 63 : 31);
+  size_t len = name.length ();
   std::string cname = tc.class_name ();
   int ret = 32;
 
   if (len > 4)
     ret += PAD (len > max_namelen ? max_namelen : len);
 
   ret += PAD (4 * tc.ndims ());
   
   if (tc.is_string ())
     {
       charNDArray chm = tc.char_array_value ();
       ret += 8;
-      if (chm.nelem () > 2)
-        ret += PAD (2 * chm.nelem ());
+      if (chm.numel () > 2)
+        ret += PAD (2 * chm.numel ());
     }
   else if (tc.is_sparse_type ())
     {
       if (tc.is_complex_type ())
         {
           SparseComplexMatrix m = tc.sparse_complex_matrix_value ();
-          int nc = m.cols ();
-          int nnz = m.nzmax ();
+          octave_idx_type nc = m.cols ();
+          octave_idx_type nnz = m.nzmax ();
 
           ret += 16 + PAD (nnz * sizeof (int)) + PAD ((nc + 1) * sizeof (int)) +
-            save_mat5_array_length (m.data (), m.nelem (), save_as_floats);
+            save_mat5_array_length (m.data (), nnz, save_as_floats);
         }
       else
         {
           SparseMatrix m = tc.sparse_matrix_value ();
-          int nc = m.cols ();
-          int nnz = m.nzmax ();
+          octave_idx_type nc = m.cols ();
+          octave_idx_type nnz = m.nzmax ();
 
           ret += 16 + PAD (nnz * sizeof (int)) + PAD ((nc + 1) * sizeof (int)) +
-            save_mat5_array_length (m.data (), m.nelem (), save_as_floats);
+            save_mat5_array_length (m.data (), nnz, save_as_floats);
         }
     }
 
 #define INT_LEN(nel, size) \
   { \
     ret += 8; \
-    int sz = nel * size; \
+    octave_idx_type sz = nel * size; \
     if (sz > 4) \
       ret += PAD (sz);  \
   }
 
   else if (cname == "int8")
-    INT_LEN (tc.int8_array_value ().nelem (), 1)
+    INT_LEN (tc.int8_array_value ().numel (), 1)
   else if (cname == "int16")
-    INT_LEN (tc.int16_array_value ().nelem (), 2)
+    INT_LEN (tc.int16_array_value ().numel (), 2)
   else if (cname == "int32")
-    INT_LEN (tc.int32_array_value ().nelem (), 4)
+    INT_LEN (tc.int32_array_value ().numel (), 4)
   else if (cname == "int64")
-    INT_LEN (tc.int64_array_value ().nelem (), 8)
+    INT_LEN (tc.int64_array_value ().numel (), 8)
   else if (cname == "uint8")
-    INT_LEN (tc.uint8_array_value ().nelem (), 1)
+    INT_LEN (tc.uint8_array_value ().numel (), 1)
   else if (cname == "uint16")
-    INT_LEN (tc.uint16_array_value ().nelem (), 2)
+    INT_LEN (tc.uint16_array_value ().numel (), 2)
   else if (cname == "uint32")
-    INT_LEN (tc.uint32_array_value ().nelem (), 4)
+    INT_LEN (tc.uint32_array_value ().numel (), 4)
   else if (cname == "uint64")
-    INT_LEN (tc.uint64_array_value ().nelem (), 8)
+    INT_LEN (tc.uint64_array_value ().numel (), 8)
   else if (tc.is_bool_type ())
-    INT_LEN (tc.bool_array_value ().nelem (), 1)
+    INT_LEN (tc.bool_array_value ().numel (), 1)
   else if (tc.is_real_scalar () || tc.is_real_matrix () || tc.is_range ())
     {
       NDArray m = tc.array_value ();
-      ret += save_mat5_array_length (m.fortran_vec (), m.nelem (),
+      ret += save_mat5_array_length (m.fortran_vec (), m.numel (),
                                      save_as_floats);
     }
   else if (tc.is_cell ())
     {
       Cell cell = tc.cell_value ();
-      int nel = cell.nelem ();
+      octave_idx_type nel = cell.numel ();
 
       for (int i = 0; i < nel; i++)
         ret += 8 + 
           save_mat5_element_length (cell (i), "", save_as_floats, mat7_format);
     }
   else if (tc.is_complex_scalar () || tc.is_complex_matrix ()) 
     {
       ComplexNDArray m = tc.complex_array_value ();
-      ret += save_mat5_array_length (m.fortran_vec (), m.nelem (),
+      ret += save_mat5_array_length (m.fortran_vec (), m.numel (),
                                      save_as_floats);
     }
   else if (tc.is_map () || tc.is_inline_function () || tc.is_object ()) 
     {
       int fieldcnt = 0;
       const Octave_map m = tc.map_value ();
-      int nel = m.numel ();
+      octave_idx_type nel = m.numel ();
 
       if (tc.is_inline_function ())
         // length of "inline" is 6
         ret += 8 + PAD (6 > max_namelen ? max_namelen : 6);
       else if (tc.is_object ())
         {
-          int classlen = tc.class_name (). length ();
+          size_t classlen = tc.class_name (). length ();
 
           ret += 8 + PAD (classlen > max_namelen ? max_namelen : classlen);
         }
 
       for (Octave_map::const_iterator i = m.begin (); i != m.end (); i++)
         fieldcnt++;
 
       ret += 16 + fieldcnt * (max_namelen + 1);
 
 
-      for (int j = 0; j < nel; j++)
+      for (octave_idx_type j = 0; j < nel; j++)
         {
 
           for (Octave_map::const_iterator i = m.begin (); i != m.end (); i++)
             {
               const Cell elts = m.contents (i);
 
               ret += 8 + save_mat5_element_length (elts(j), "", 
                                                save_as_floats, mat7_format);
@@ -1850,30 +1886,98 @@ save_mat5_element_length (const octave_v
         }
     }
   else
     ret = -1;
 
   return ret;
 }
 
+static void
+write_mat5_sparse_index_vector (std::ostream& os,
+                                const octave_idx_type *idx,
+                                octave_idx_type nel)
+{
+  int tmp = sizeof (int);
+
+  OCTAVE_LOCAL_BUFFER (int32_t, tmp_idx, nel);
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    tmp_idx[i] = idx[i];
+
+  write_mat5_integer_data (os, tmp_idx, -tmp, nel);
+}
+
+static void
+gripe_dim_too_large (const std::string& name)
+{
+  warning ("save: skipping %s: dimension too large for MAT format",
+           name.c_str ());
+}
+
 // save the data from TC along with the corresponding NAME on stream
 // OS in the MatLab version 5 binary format.  Return true on success.
 
 bool
 save_mat5_binary_element (std::ostream& os,
                           const octave_value& tc, const std::string& name,
                           bool mark_as_global, bool mat7_format,
                           bool save_as_floats, bool compressing) 
 {
-  int32_t flags=0;
-  int32_t nnz=0;
-  std::streampos fixup, contin;
+  int32_t flags = 0;
+  int32_t nnz_32 = 0;
   std::string cname = tc.class_name ();
-  int max_namelen = (mat7_format ? 63 : 31);
+  size_t max_namelen = (mat7_format ? 63 : 31);
+
+  dim_vector dv = tc.dims ();
+  int nd = tc.ndims ();
+  int dim_len = 4*nd;
+
+  static octave_idx_type max_dim_val = std::numeric_limits<int32_t>::max ();
+
+  for (int i = 0; i < nd; i++)
+    {
+      if (dv(i) > max_dim_val)
+        {
+          gripe_dim_too_large (name);
+          goto skip_to_next;
+        }
+    }
+
+  if (tc.is_sparse_type ())
+    {
+      octave_idx_type nnz;
+      octave_idx_type nc;
+
+      if (tc.is_complex_type ())
+        {
+          SparseComplexMatrix scm = tc.sparse_complex_matrix_value ();
+          nnz = scm.nzmax ();
+          nc = scm.cols ();
+        }
+      else
+        {
+          SparseMatrix sm = tc.sparse_matrix_value ();
+          nnz = sm.nzmax ();
+          nc = sm.cols ();
+        }
+
+      if (nnz > max_dim_val || nc + 1 > max_dim_val)
+        {
+          gripe_dim_too_large (name);
+          goto skip_to_next;
+        }
+
+      nnz_32 = nnz;
+    }
+  else if (dv.numel () > max_dim_val)
+    {
+      gripe_dim_too_large (name);
+      goto skip_to_next;
+    }
 
 #ifdef HAVE_ZLIB
   if (mat7_format && !compressing)
     {
       bool ret = false;
 
       std::ostringstream buf;
 
@@ -1889,32 +1993,32 @@ save_mat5_binary_element (std::ostream& 
           std::string buf_str = buf.str ();
           uLongf srcLen = buf_str.length ();
           uLongf destLen = srcLen * 101 / 100 + 12; 
           OCTAVE_LOCAL_BUFFER (char, out_buf, destLen);
 
           if (compress (reinterpret_cast<Bytef *> (out_buf), &destLen, 
                         reinterpret_cast<const Bytef *> (buf_str.c_str ()), srcLen) == Z_OK)
             {
-              write_mat5_tag (os, miCOMPRESSED, static_cast<int> (destLen)); 
+              write_mat5_tag (os, miCOMPRESSED,
+                              static_cast<octave_idx_type> (destLen)); 
+
               os.write (out_buf, destLen);
             }
           else
             {
               error ("save: error compressing data element");
               ret = false;
             }
         }
 
       return ret;
     }
 #endif
 
-  // element type and length
-  fixup = os.tellp ();
   write_mat5_tag (os, miMATRIX, save_mat5_element_length 
                   (tc, name, save_as_floats, mat7_format));
   
   // array flags subelement
   write_mat5_tag (os, miUINT32, 8);
 
   if (tc.is_bool_type ())
     flags |= 0x0200;
@@ -1939,29 +2043,17 @@ save_mat5_binary_element (std::ostream& 
     flags |= MAT_FILE_UINT8_CLASS;
   else if (cname == "uint16")
     flags |= MAT_FILE_UINT16_CLASS;
   else if (cname == "uint32")
     flags |= MAT_FILE_UINT32_CLASS;
   else if (cname == "uint64")
     flags |= MAT_FILE_UINT64_CLASS;
   else if (tc.is_sparse_type ())
-    {
-      flags |= MAT_FILE_SPARSE_CLASS;
-      if (tc.is_complex_type ())
-        {
-          SparseComplexMatrix scm = tc.sparse_complex_matrix_value ();
-          nnz = scm.nzmax ();
-        }
-      else
-        {
-          SparseMatrix sm = tc.sparse_matrix_value ();
-          nnz = sm.nzmax ();
-        }
-    }
+    flags |= MAT_FILE_SPARSE_CLASS;
   else if (tc.is_real_scalar ())
     flags |= MAT_FILE_DOUBLE_CLASS;
   else if (tc.is_real_matrix () || tc.is_range ())
     flags |= MAT_FILE_DOUBLE_CLASS;
   else if (tc.is_complex_scalar ())
     flags |= MAT_FILE_DOUBLE_CLASS;
   else if (tc.is_complex_matrix ())
     flags |= MAT_FILE_DOUBLE_CLASS;
@@ -1973,41 +2065,35 @@ save_mat5_binary_element (std::ostream& 
     flags |= MAT_FILE_OBJECT_CLASS;
   else
     {
       gripe_wrong_type_arg ("save", tc, false);
       goto error_cleanup;
     }
 
   os.write (reinterpret_cast<char *> (&flags), 4);
-  os.write (reinterpret_cast<char *> (&nnz), 4);
+  os.write (reinterpret_cast<char *> (&nnz_32), 4);
 
-  {
-    dim_vector dv = tc.dims ();
-    int nd = tc.ndims ();
-    int dim_len = 4*nd;
-
-    write_mat5_tag (os, miINT32, dim_len);
+  write_mat5_tag (os, miINT32, dim_len);
 
-    for (int i = 0; i < nd; i++)
-      {
-        int32_t n = dv(i);
-        os.write (reinterpret_cast<char *> (&n), 4);
-      }
+  for (int i = 0; i < nd; i++)
+    {
+      int32_t n = dv(i);
+      os.write (reinterpret_cast<char *> (&n), 4);
+    }
 
-    if (PAD (dim_len) > dim_len)
-      {
-        static char buf[9]="\x00\x00\x00\x00\x00\x00\x00\x00";
-        os.write (buf, PAD (dim_len) - dim_len);
-      }
-  }
+  if (PAD (dim_len) > dim_len)
+    {
+      static char buf[9]="\x00\x00\x00\x00\x00\x00\x00\x00";
+      os.write (buf, PAD (dim_len) - dim_len);
+    }
 
   // array name subelement
   {
-    int namelen = name.length ();
+    size_t namelen = name.length ();
 
     if (namelen > max_namelen)
       namelen = max_namelen; // only 31 or 63 char names permitted in mat file
 
     int paddedlength = PAD (namelen);
 
     write_mat5_tag (os, miINT8, namelen);
     OCTAVE_LOCAL_BUFFER (char, paddedname, paddedlength);
@@ -2015,133 +2101,131 @@ save_mat5_binary_element (std::ostream& 
     strncpy (paddedname, name.c_str (), namelen);
     os.write (paddedname, paddedlength);
   }
 
   // data element
   if (tc.is_string ())
     {
       charNDArray chm = tc.char_array_value ();
-      int nel = chm.nelem ();
-      int len = nel*2;
-      int paddedlength = PAD (len);
+      octave_idx_type nel = chm.numel ();
+      octave_idx_type len = nel*2;
+      octave_idx_type paddedlength = PAD (len);
 
       OCTAVE_LOCAL_BUFFER (int16_t, buf, nel+3);
       write_mat5_tag (os, miUINT16, len);
 
       const char *s = chm.data ();
 
-      for (int i = 0; i < nel; i++)
+      for (octave_idx_type i = 0; i < nel; i++)
         buf[i] = *s++ & 0x00FF;
 
       os.write (reinterpret_cast<char *> (buf), len);
       
       if (paddedlength > len)
         {
           static char padbuf[9]="\x00\x00\x00\x00\x00\x00\x00\x00";
           os.write (padbuf, paddedlength - len);
         }
     }
   else if (tc.is_sparse_type ())
     {
       if (tc.is_complex_type ())
         {
           SparseComplexMatrix m = tc.sparse_complex_matrix_value ();
-          int nc = m.cols ();
+          octave_idx_type nnz = m.nnz ();
+          octave_idx_type nc = m.cols ();
 
-          int tmp = sizeof (int);
-
-          write_mat5_integer_data (os, m.ridx (), -tmp, nnz);
-          write_mat5_integer_data (os, m.cidx (), -tmp, nc + 1);
+          write_mat5_sparse_index_vector (os, m.ridx (), nnz);
+          write_mat5_sparse_index_vector (os, m.cidx (), nc + 1);
 
           NDArray buf (dim_vector (nnz, 1));
 
-          for (int i = 0; i < nnz; i++)
+          for (octave_idx_type i = 0; i < nnz; i++)
             buf (i) = std::real (m.data (i));
 
           write_mat5_array (os, buf, save_as_floats);
 
-          for (int i = 0; i < nnz; i++)
+          for (octave_idx_type i = 0; i < nnz; i++)
             buf (i) = std::imag (m.data (i));
 
           write_mat5_array (os, buf, save_as_floats);
         }
       else
         {
           SparseMatrix m = tc.sparse_matrix_value ();
-          int nc = m.cols ();
+          octave_idx_type nnz = m.nnz ();
+          octave_idx_type nc = m.cols ();
 
-          int tmp = sizeof (int);
-
-          write_mat5_integer_data (os, m.ridx (), -tmp, nnz);
-          write_mat5_integer_data (os, m.cidx (), -tmp, nc + 1);
+          write_mat5_sparse_index_vector (os, m.ridx (), nnz);
+          write_mat5_sparse_index_vector (os, m.cidx (), nc + 1);
 
           // FIXME
           // Is there a way to easily do without this buffer
           NDArray buf (dim_vector (nnz, 1));
 
           for (int i = 0; i < nnz; i++)
             buf (i) = m.data (i);
 
           write_mat5_array (os, buf, save_as_floats);
         }
     }
   else if (cname == "int8")
     {
       int8NDArray m = tc.int8_array_value ();
 
-      write_mat5_integer_data (os, m.fortran_vec (), -1, m.nelem ());
+      write_mat5_integer_data (os, m.fortran_vec (), -1, m.numel ());
     }
   else if (cname == "int16")
     {
       int16NDArray m = tc.int16_array_value ();
 
-      write_mat5_integer_data (os, m.fortran_vec (), -2, m.nelem ());
+      write_mat5_integer_data (os, m.fortran_vec (), -2, m.numel ());
     }
   else if (cname == "int32")
     {
       int32NDArray m = tc.int32_array_value ();
 
-      write_mat5_integer_data (os, m.fortran_vec (), -4, m.nelem ());
+      write_mat5_integer_data (os, m.fortran_vec (), -4, m.numel ());
     }
   else if (cname == "int64")
     {
       int64NDArray m = tc.int64_array_value ();
 
-      write_mat5_integer_data (os, m.fortran_vec (), -8, m.nelem ());
+      write_mat5_integer_data (os, m.fortran_vec (), -8, m.numel ());
     }
   else if (cname == "uint8")
     {
       uint8NDArray m = tc.uint8_array_value ();
 
-      write_mat5_integer_data (os, m.fortran_vec (), 1, m.nelem ());
+      write_mat5_integer_data (os, m.fortran_vec (), 1, m.numel ());
     }
   else if (cname == "uint16")
     {
       uint16NDArray m = tc.uint16_array_value ();
 
-      write_mat5_integer_data (os, m.fortran_vec (), 2, m.nelem ());
+      write_mat5_integer_data (os, m.fortran_vec (), 2, m.numel ());
     }
   else if (cname == "uint32")
     {
       uint32NDArray m = tc.uint32_array_value ();
 
-      write_mat5_integer_data (os, m.fortran_vec (), 4, m.nelem ());
+      write_mat5_integer_data (os, m.fortran_vec (), 4, m.numel ());
     }
   else if (cname == "uint64")
     {
       uint64NDArray m = tc.uint64_array_value ();
 
-      write_mat5_integer_data (os, m.fortran_vec (), 8, m.nelem ());
+      write_mat5_integer_data (os, m.fortran_vec (), 8, m.numel ());
     }
   else if (tc.is_bool_type ())
     {
       uint8NDArray m (tc.bool_array_value ());
 
-      write_mat5_integer_data (os, m.fortran_vec (), 1, m.nelem ());
+      write_mat5_integer_data (os, m.fortran_vec (), 1, m.numel ());
     }
   else if (tc.is_real_scalar () || tc.is_real_matrix () || tc.is_range ())
     {
       NDArray m = tc.array_value ();
 
       write_mat5_array (os, m, save_as_floats);
     }
   else if (tc.is_cell ())
@@ -2158,17 +2242,17 @@ save_mat5_binary_element (std::ostream& 
       write_mat5_array (os, ::real (m_cmplx), save_as_floats);
       write_mat5_array (os, ::imag (m_cmplx), save_as_floats);
     }
   else if (tc.is_map () || tc.is_inline_function() || tc.is_object ()) 
     {
       if (tc.is_inline_function () || tc.is_object ())
         {
           std::string classname = tc.is_object() ? tc.class_name () : "inline";
-          int namelen = classname.length ();
+          size_t namelen = classname.length ();
 
           if (namelen > max_namelen)
             namelen = max_namelen; // only 31 or 63 char names permitted
 
           int paddedlength = PAD (namelen);
 
           write_mat5_tag (os, miINT8, namelen);
           OCTAVE_LOCAL_BUFFER (char, paddedname, paddedlength);
@@ -2194,46 +2278,44 @@ save_mat5_binary_element (std::ostream& 
       // an Octave structure */
       // recursively write each element of the structure
       {
         char buf[64];
         int32_t maxfieldnamelength = max_namelen + 1;
 
         octave_idx_type nf = m.nfields ();
 
-        int fieldcnt = nf;
-
         write_mat5_tag (os, miINT32, 4);
         os.write (reinterpret_cast<char *> (&maxfieldnamelength), 4);
-        write_mat5_tag (os, miINT8, fieldcnt*maxfieldnamelength);
+        write_mat5_tag (os, miINT8, nf*maxfieldnamelength);
 
         // Iterating over the list of keys will preserve the order of
         // the fields.
         string_vector keys = m.keys ();
 
         for (octave_idx_type i = 0; i < nf; i++)
           {
             std::string key = keys(i);
 
             // write the name of each element
             memset (buf, 0, max_namelen + 1);
             // only 31 or 63 char names permitted
             strncpy (buf, key.c_str (), max_namelen);
             os.write (buf, max_namelen + 1);
           }
 
-        int len = m.numel ();
+        octave_idx_type len = m.numel ();
 
         // Create temporary copy of structure contents to avoid
         // multiple calls of the contents method.
         std::vector<const octave_value *> elts (nf);
         for (octave_idx_type i = 0; i < nf; i++)
           elts[i] = m.contents (keys(i)).data ();
 
-        for (int j = 0; j < len; j++)
+        for (octave_idx_type j = 0; j < len; j++)
           {
             // write the data of each element
 
             // Iterating over the list of keys will preserve the order
             // of the fields.
             for (octave_idx_type i = 0; i < nf; i++)
               {
                 bool retval2 = save_mat5_binary_element (os, elts[i][j], "",
@@ -2244,17 +2326,16 @@ save_mat5_binary_element (std::ostream& 
                   goto error_cleanup;
               }
           }
       }
     }
   else
     gripe_wrong_type_arg ("save", tc, false);
 
-  contin = os.tellp ();
-
+ skip_to_next:
   return true;
 
  error_cleanup:
   error ("save: error while writing `%s' to MAT file", name.c_str ());
 
   return false;
 }
