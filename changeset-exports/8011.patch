# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1217992172 14400
#      Tue Aug 05 23:09:32 2008 -0400
# Node ID 3100283874d789a9369b91912946e7a99663a062
# Parent  0e9b6af36559b65c13a49eba0a84f5e898bd7b79
improve backtrace error messages

diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,10 +1,70 @@
 2008-08-05  John W. Eaton  <jwe@octave.org>
 
+	* toplev.cc (octave_call_stack::backtrace_error_message): New
+	function.
+	* toplev.h: Provide decl.
+	(octave_call_stack::do_pop): Call backtrace_error_message if
+	error_state is nonzero.
+
+	* pt-unop.cc (tree_prefix_expression::eval_error, 
+	tree_postfix_expression::eval_error): Delete.  Eliminate all uses.
+	* pt-unop.h: Delete decls.
+
+	* pt-select.cc (tree_switch_case::eval_error,
+	tree_switch_command::eval_error): Delete.  Eliminate all uses.
+	(tree_if_command::eval): Omit "evaluating if command" message.
+	* pt-select.h: Delete decls.
+
+	* pt-loop.cc (tree_while_command::eval_error,
+	tree_complex_for_command::eval_error,
+	tree_simple_for_command::eval_error,
+	tree_do_until_command::eval_error): Delete.  Eliminate all uses.
+	* pt-loop.h: Delete decls.
+
+	* pt-exp.cc (tree_expression::is_logically_true): Omit "evaluating
+	conditional expression" error message.
+
+	* pt-decl.cc (tree_global_command::eval): Omit "evaluating global
+	command" error message.
+	(tree_static_command::eval): Omit "evaluating static command"
+	error message.
+
+	* pt-colon.cc (tree_colon_expression::eval_error): Omit
+	"evaluating colon expression" error message.
+	* pt-colon.h (tree_colon_expression::eval_error): Eliminate
+	default argument value.
+
+	* pt-idx.cc (tree_index_expression::eval_error): Delete.
+	Eliminate all uses.
+	* pt-idx.h: Delete decl.
+
+	* pt-binop.cc (tree_binary_expression::eval_error): Delete.
+	* pt-binop.cc, pt-cbinop.cc: Eliminate all uses of eval_error.
+	* pt-binop.h: Delete decl.
+
+	* pt-assign.cc (tree_simple_assignment::eval_error,
+	tree_multi_assignment::eval_error): Delete.  Eliminate all uses.
+	* pt-assign.h: Delete decls.
+
+	* ov-usr-fcn.cc (octave_user_script::traceback_error,
+	octave_user_function::traceback_error): Delete.  Eliminate all uses.
+	* ov-usr-fcn.h: Delete decls.
+
+	* ov-builtin.cc (octave_builtin::do_multi_index_op): Call
+	gripe_library_exectuion_error on octave_execution_exception.
+	* ov-mex-fcn.cc (octave_mex_function::do_multi_index_op): Likewise.
+	* ov.cc (do_binary_op, do_cat_op, do_unary_op,
+	do_non_const_unary_op): Likewise.
+	* pt-stmt.cc (tree_statement::eval): Likewise.
+
+	* gripes.cc (gripe_library_execution_error): New function.
+	* gripes.h: Provide decl.
+
 	* dirfns.cc (Fpathsep): Fix usage of dir_path::path_sep_str.
 	* defaults.cc (set_exec_path, set_image_path): Likewise.
 	* load-path.h (load_path::set_command_line_path): Likewise.
 	* load-path.cc (maybe_add_path_elts, load_path::do_initialize,
 	load_path::do_path, genpath, Fpath): Likewise.
 	(split_path): Fix usage of dir_path::path_sep_char.
 
 2008-08-04  John W. Eaton  <jwe@octave.org>
diff --git a/src/gripes.cc b/src/gripes.cc
--- a/src/gripes.cc
+++ b/src/gripes.cc
@@ -207,13 +207,22 @@ gripe_logical_conversion (void)
 extern void
 gripe_truncated_conversion (const char *srctype, const char *desttype)
 {
   warning_with_id ("Octave:int-convert-overflow", 
                    "data truncated converting from %s to %s",
                    srctype, desttype);
 }
 
+void
+gripe_library_execution_error (void)
+{
+  octave_exception_state = octave_no_exception;
+
+  if (! error_state)
+    error ("caught execution error in library function");
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/gripes.h b/src/gripes.h
--- a/src/gripes.h
+++ b/src/gripes.h
@@ -111,15 +111,18 @@ extern OCTINTERP_API void
 gripe_truncated_conversion (const char *srctype, const char *desttype);
 
 extern OCTINTERP_API void
 gripe_divide_by_zero (void);
 
 extern OCTINTERP_API void
 gripe_logical_conversion (void);
 
+extern OCTINTERP_API void
+gripe_library_execution_error (void);
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-builtin.cc b/src/ov-builtin.cc
--- a/src/ov-builtin.cc
+++ b/src/ov-builtin.cc
@@ -21,16 +21,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "error.h"
+#include "gripes.h"
 #include "oct-obj.h"
 #include "ov-builtin.h"
 #include "ov.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 
 DEFINE_OCTAVE_ALLOCATOR (octave_builtin);
 
@@ -102,18 +103,17 @@ octave_builtin::do_multi_index_op (int n
       unwind_protect::add (octave_call_stack::unwind_pop, 0);
 
       try
 	{
 	  retval = (*f) (args, nargout);
 	}
       catch (octave_execution_exception)
 	{
-	  octave_exception_state = octave_no_exception;
-	  error ("caught execution error in library function");
+	  gripe_library_execution_error ();
 	}
 
       unwind_protect::run_frame ("builtin_func_eval");
     }
 
   return retval;
 }
 
diff --git a/src/ov-mex-fcn.cc b/src/ov-mex-fcn.cc
--- a/src/ov-mex-fcn.cc
+++ b/src/ov-mex-fcn.cc
@@ -24,16 +24,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "oct-shlib.h"
 
 #include <defaults.h>
 #include "dynamic-ld.h"
 #include "error.h"
+#include "gripes.h"
 #include "oct-obj.h"
 #include "ov-mex-fcn.h"
 #include "ov.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 
 DEFINE_OCTAVE_ALLOCATOR (octave_mex_function);
 
@@ -144,18 +145,17 @@ octave_mex_function::do_multi_index_op (
       unwind_protect::add (octave_call_stack::unwind_pop, 0);
 
       try
 	{
 	  retval = call_mex (have_fmex, mex_fcn_ptr, args, nargout, this);
 	}
       catch (octave_execution_exception)
 	{
-	  octave_exception_state = octave_no_exception;
-	  error ("caught execution error in library function");
+	  gripe_library_execution_error ();
 	}
 
       unwind_protect::run_frame ("mex_func_eval");
     }
 
   return retval;
 }
 
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -105,89 +105,60 @@ octave_user_script::subsref (const std::
 }
 
 octave_value_list
 octave_user_script::do_multi_index_op (int nargout,
 				       const octave_value_list& args)
 {
   octave_value_list retval;
 
+  unwind_protect::begin_frame ("user_script_eval");
+
   if (! error_state)
     {
       if (args.length () == 0 && nargout == 0)
 	{
 	  if (cmd_list)
 	    {
-	      unwind_protect::begin_frame ("user_script_eval");
-
 	      unwind_protect_int (call_depth);
 	      call_depth++;
 
 	      if (call_depth < Vmax_recursion_depth)
 		{
 		  octave_call_stack::push (this);
 
 		  unwind_protect::add (octave_call_stack::unwind_pop, 0);
 
 		  cmd_list->eval ();
 
 		  if (tree_return_command::returning)
 		    tree_return_command::returning = 0;
 
 		  if (tree_break_command::breaking)
 		    tree_break_command::breaking--;
-
-		  if (error_state)
-		    traceback_error ();
 		}
 	      else
 		::error ("max_recursion_limit exceeded");
-
-	      unwind_protect::run_frame ("user_script_eval");
     	    }
 	}
       else
 	error ("invalid call to script");
     }
 
+  unwind_protect::run_frame ("user_script_eval");
+
   return retval;
 }
 
 void
 octave_user_script::accept (tree_walker& tw)
 {
   tw.visit_octave_user_script (*this);
 }
 
-// FIXME -- this function is exactly the same as
-// octave_user_function::traceback_error.
-
-void
-octave_user_script::traceback_error (void) const
-{
-  if (error_state >= 0)
-    error_state = -1;
-
-  if (my_name.empty ())
-    {
-      if (file_name.empty ())
-	::error ("called from `?unknown?'");
-      else
-	::error ("called from file `%s'", file_name.c_str ());
-    }
-  else
-    {
-      if (file_name.empty ())
-	::error ("called from `%s'", my_name.c_str ());
-      else 
-	::error ("called from `%s' in file `%s'",
-		 my_name.c_str (), file_name.c_str ());
-    }
-}
-
 // User defined functions.
 
 DEFINE_OCTAVE_ALLOCATOR (octave_user_function);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_user_function,
 				     "user-defined function",
 				     "user-defined function");
 
@@ -468,20 +439,17 @@ octave_user_function::do_multi_index_op 
 
     if (tree_return_command::returning)
       tree_return_command::returning = 0;
 
     if (tree_break_command::breaking)
       tree_break_command::breaking--;
 
     if (error_state)
-      {
-	traceback_error ();
-	goto abort;
-      }
+      goto abort;
     
     // Copy return values out.
 
     if (ret_list && ! is_inline_function ())
       {
 	ret_list->initialize_undefined_elements (my_name, nargout, Matrix ());
 
 	Cell varargout;
@@ -506,39 +474,16 @@ octave_user_function::do_multi_index_op 
 
  abort:
   unwind_protect::run_frame ("user_func_eval");
 
   return retval;
 }
 
 void
-octave_user_function::traceback_error (void) const
-{
-  if (error_state >= 0)
-    error_state = -1;
-
-  if (my_name.empty ())
-    {
-      if (file_name.empty ())
-	::error ("called from `?unknown?'");
-      else
-	::error ("called from file `%s'", file_name.c_str ());
-    }
-  else
-    {
-      if (file_name.empty ())
-	::error ("called from `%s'", my_name.c_str ());
-      else 
-	::error ("called from `%s' in file `%s'",
-		 my_name.c_str (), file_name.c_str ());
-    }
-}
-
-void
 octave_user_function::accept (tree_walker& tw)
 {
   tw.visit_octave_user_function (*this);
 }
 
 #if 0
 void
 octave_user_function::print_symtab_info (std::ostream& os) const
diff --git a/src/ov-usr-fcn.h b/src/ov-usr-fcn.h
--- a/src/ov-usr-fcn.h
+++ b/src/ov-usr-fcn.h
@@ -129,18 +129,16 @@ public:
 			     const std::list<octave_value_list>& idx,
 			     int nargout);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
   tree_statement_list *body (void) { return cmd_list; }
 
-  void traceback_error (void) const;
-
   void accept (tree_walker& tw);
 
 private:
 
   // The list of commands that make up the body of this function.
   tree_statement_list *cmd_list;
 
   // The name of the file we parsed.
@@ -294,18 +292,16 @@ public:
 
   octave_value_list subsref (const std::string& type,
 			     const std::list<octave_value_list>& idx,
 			     int nargout);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
-  void traceback_error (void) const;
-
   tree_parameter_list *parameter_list (void) { return param_list; }
 
   tree_parameter_list *return_list (void) { return ret_list; }
 
   tree_statement_list *body (void) { return cmd_list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -1541,18 +1541,17 @@ do_binary_op (octave_value::binary_op op
       if (f)
 	{
 	  try
 	    {
 	      retval = f (v1, v2);
 	    }
 	  catch (octave_execution_exception)
 	    {
-	      octave_exception_state = octave_no_exception;
-	      error ("caught execution error in library function");
+	      gripe_library_execution_error ();
 	    }
 	}	    
       else
 	gripe_binary_op (octave_value::binary_op_as_string (op),
 			 v1.class_name (), v2.class_name ());
     }
   else
     {
@@ -1565,18 +1564,17 @@ do_binary_op (octave_value::binary_op op
       if (f)
 	{
 	  try
 	    {
 	      retval = f (*v1.rep, *v2.rep);
 	    }
 	  catch (octave_execution_exception)
 	    {
-	      octave_exception_state = octave_no_exception;
-	      error ("caught execution error in library function");
+	      gripe_library_execution_error ();
 	    }
 	}
       else
 	{
 	  octave_value tv1;
 	  octave_base_value::type_conv_fcn cf1 = v1.numeric_conversion_function ();
 
 	  if (cf1)
@@ -1625,18 +1623,17 @@ do_binary_op (octave_value::binary_op op
 	      if (f)
 		{
 		  try
 		    {
 		      retval = f (*tv1.rep, *tv2.rep);
 		    }
 		  catch (octave_execution_exception)
 		    {
-		      octave_exception_state = octave_no_exception;
-		      error ("caught execution error in library function");
+		      gripe_library_execution_error ();
 		    }
 		}
 	      else
 		{
 		  //demote double -> single and try again
 		  cf1 = tv1.numeric_demotion_function ();
 
 		  if (cf1)
@@ -1680,18 +1677,17 @@ do_binary_op (octave_value::binary_op op
 		      if (f)
 			{
 			  try
 			    {
 			      retval = f (*tv1.rep, *tv2.rep);
 			    }
 			  catch (octave_execution_exception)
 			    {
-			      octave_exception_state = octave_no_exception;
-			      error ("caught execution error in library function");
+			      gripe_library_execution_error ();
 			    }
 			}
 		      else
 			gripe_binary_op (octave_value::binary_op_as_string (op),
 					 v1.type_name (), v2.type_name ());
 		    }
 		  else
 		    gripe_binary_op (octave_value::binary_op_as_string (op),
@@ -1744,18 +1740,17 @@ do_binary_op (octave_value::binary_op op
 		  if (f)
 		    {
 		      try
 			{
 			  retval = f (*tv1.rep, *tv2.rep);
 			}
 		      catch (octave_execution_exception)
 			{
-			  octave_exception_state = octave_no_exception;
-			  error ("caught execution error in library function");
+			  gripe_library_execution_error ();
 			}
 		    }
 		  else
 		    gripe_binary_op (octave_value::binary_op_as_string (op),
 				     v1.type_name (), v2.type_name ());
 		}
 	      else
 		gripe_binary_op (octave_value::binary_op_as_string (op),
@@ -1821,18 +1816,17 @@ do_binary_op (octave_value::compound_bin
       if (f)
 	{
 	  try
 	    {
 	      retval = f (v1, v2);
 	    }
 	  catch (octave_execution_exception)
 	    {
-	      octave_exception_state = octave_no_exception;
-	      error ("caught execution error in library function");
+	      gripe_library_execution_error ();
 	    }
 	}	    
       else
         retval = decompose_binary_op (op, v1, v2);
     }
   else
     {
       octave_value_typeinfo::binary_op_fcn f
@@ -1841,18 +1835,17 @@ do_binary_op (octave_value::compound_bin
       if (f)
 	{
 	  try
 	    {
 	      retval = f (*v1.rep, *v2.rep);
 	    }
 	  catch (octave_execution_exception)
 	    {
-	      octave_exception_state = octave_no_exception;
-	      error ("caught execution error in library function");
+	      gripe_library_execution_error ();
 	    }
 	}
       else
         retval = decompose_binary_op (op, v1, v2);
     }
 
   return retval;
 }
@@ -1888,18 +1881,17 @@ do_cat_op (const octave_value& v1, const
   if (f)
     {
       try
 	{
 	  retval = f (*v1.rep, *v2.rep, ra_idx);
 	}
       catch (octave_execution_exception)
 	{
-	  octave_exception_state = octave_no_exception;
-	  error ("caught execution error in library function");
+	  gripe_library_execution_error ();
 	}
     }
   else
     {
       octave_value tv1;
       octave_base_value::type_conv_fcn cf1 = v1.numeric_conversion_function ();
 
       if (cf1)
@@ -1948,18 +1940,17 @@ do_cat_op (const octave_value& v1, const
 	  if (f)
 	    {
 	      try
 		{
 		  retval = f (*tv1.rep, *tv2.rep, ra_idx);
 		}
 	      catch (octave_execution_exception)
 		{
-		  octave_exception_state = octave_no_exception;
-		  error ("caught execution error in library function");
+		  gripe_library_execution_error ();
 		}
 	    }
 	  else
 	    gripe_cat_op (v1.type_name (), v2.type_name ());
 	}
       else
 	gripe_cat_op (v1.type_name (), v2.type_name ());
     }
@@ -2005,18 +1996,17 @@ do_unary_op (octave_value::unary_op op, 
       if (f)
 	{
 	  try
 	    {
 	      retval = f (v);
 	    }
 	  catch (octave_execution_exception)
 	    {
-	      octave_exception_state = octave_no_exception;
-	      error ("caught execution error in library function");
+	      gripe_library_execution_error ();
 	    }
 	}
       else
 	gripe_unary_op (octave_value::unary_op_as_string (op),
 			v.class_name ());
     }
   else
     {
@@ -2029,18 +2019,17 @@ do_unary_op (octave_value::unary_op op, 
       if (f)
 	{
 	  try
 	    {
 	      retval = f (*v.rep);
 	    }
 	  catch (octave_execution_exception)
 	    {
-	      octave_exception_state = octave_no_exception;
-	      error ("caught execution error in library function");
+	      gripe_library_execution_error ();
 	    }
 	}
       else
 	{
 	  octave_value tv;
 	  octave_base_value::type_conv_fcn cf
 	    = v.numeric_conversion_function ();
 
@@ -2058,18 +2047,17 @@ do_unary_op (octave_value::unary_op op, 
 		  if (f)
 		    {
 		      try
 			{
 			  retval = f (*tv.rep);
 			}
 		      catch (octave_execution_exception)
 			{
-			  octave_exception_state = octave_no_exception;
-			  error ("caught execution error in library function");
+			  gripe_library_execution_error ();
 			}
 		    }
 		  else
 		    gripe_unary_op (octave_value::unary_op_as_string (op),
 				    v.type_name ());
 		}
 	      else
 		gripe_unary_op_conv (octave_value::unary_op_as_string (op));
@@ -2106,18 +2094,17 @@ octave_value::do_non_const_unary_op (una
       make_unique ();
 
       try
 	{
 	  f (*rep);
 	}
       catch (octave_execution_exception)
 	{
-	  octave_exception_state = octave_no_exception;
-	  error ("caught execution error in library function");
+	  gripe_library_execution_error ();
 	}
     }
   else
     {
       octave_base_value::type_conv_fcn cf = numeric_conversion_function ();
 
       if (cf)
 	{
@@ -2135,18 +2122,17 @@ octave_value::do_non_const_unary_op (una
 	      if (f)
 		{
 		  try
 		    {
 		      f (*rep);
 		    }
 		  catch (octave_execution_exception)
 		    {
-		      octave_exception_state = octave_no_exception;
-		      error ("caught execution error in library function");
+		      gripe_library_execution_error ();
 		    }
 
 		  if (old_rep && --old_rep->count == 0)
 		    delete old_rep;
 		}
 	      else
 		{
 		  if (old_rep)
diff --git a/src/pt-assign.cc b/src/pt-assign.cc
--- a/src/pt-assign.cc
+++ b/src/pt-assign.cc
@@ -203,40 +203,36 @@ tree_simple_assignment::rvalue (void)
 
       if (! (error_state || tmp.empty ()))
 	{
 	  octave_value rhs_val = tmp(0);
 
 	  if (rhs_val.is_undefined ())
 	    {
 	      error ("value on right hand side of assignment is undefined");
-	      eval_error ();
 	      return retval;
 	    }
 	  else
 	    {
 	      if (rhs_val.is_cs_list ())
 		{
 		  octave_value_list lst = rhs_val.list_value ();
 
 		  if (! lst.empty ())
 		    rhs_val = lst(0);
 		  else
 		    {
 		      error ("invalid number of elements on RHS of assignment");
-		      eval_error ();
 		      return retval;
 		    }
 		}
 
 	      octave_lvalue ult = lhs->lvalue ();
 
-	      if (error_state)
-		eval_error ();
-	      else
+	      if (! error_state)
 		{
 		  ult.assign (etype, rhs_val);
 
 		  if (! error_state)
 		    {
 		      if (etype == octave_value::op_asn_eq)
 			retval = rhs_val;
 		      else
@@ -254,39 +250,24 @@ tree_simple_assignment::rvalue (void)
 
 			  octave_value lhs_val = ult.value ();
 
 			  if (! error_state)
 			    lhs_val.print_with_name (octave_stdout,
 						     lhs->name ());
 			}
 		    }
-		  else
-		    eval_error ();
 		}
 	    }
 	}
-      else
-	eval_error ();
     }
 
   return retval;
 }
 
-void
-tree_simple_assignment::eval_error (void)
-{
-  int l = line ();
-  int c = column ();
-
-  if (l != -1 && c != -1)
-    ::error ("evaluating assignment expression near line %d, column %d",
-	     l, c);
-}
-
 std::string
 tree_simple_assignment::oper (void) const
 {
   return octave_value::assign_op_as_string (etype);
 }
 
 tree_expression *
 tree_simple_assignment::dup (symbol_table::scope_id scope,
@@ -375,17 +356,16 @@ tree_multi_assignment::rvalue (int)
       if (error_state)
 	return retval;
 
       if (rhs_val.empty ())
 	{
 	  if (n_out > 0)
 	    {
 	      error ("value on right hand side of assignment is undefined");
-	      eval_error ();
 	      return retval;
 	    }
 	}
       else
 	{
 	  octave_idx_type k = 0;
 
 	  octave_idx_type n = rhs_val.length ();
@@ -462,20 +442,17 @@ tree_multi_assignment::rvalue (int)
 			  k++;
 			}
 		    }
 		  else
 		    error ("element number %d undefined in return list", k+1);
 		}
 
 	      if (error_state)
-		{
-		  eval_error ();
-		  break;
-		}
+		break;
 	      else if (print_result ())
 		{
 		  // We clear any index here so that we can get
 		  // the new value of the referenced object below,
 		  // instead of the indexed value (which should be
 		  // the same as the right hand side value).
 
 		  ult.clear_index ();
@@ -488,33 +465,20 @@ tree_multi_assignment::rvalue (int)
 		}
 
 	      if (error_state)
 		break;
 
 	    }
 	}
     }
-  else
-    eval_error ();
 
   return retval;
 }
 
-void
-tree_multi_assignment::eval_error (void)
-{
-  int l = line ();
-  int c = column ();
-
-  if (l != -1 && c != -1)
-    ::error ("evaluating assignment expression near line %d, column %d",
-	     l, c);
-}
-
 std::string
 tree_multi_assignment::oper (void) const
 {
   return octave_value::assign_op_as_string (etype);
 }
 
 tree_expression *
 tree_multi_assignment::dup (symbol_table::scope_id scope,
diff --git a/src/pt-assign.h b/src/pt-assign.h
--- a/src/pt-assign.h
+++ b/src/pt-assign.h
@@ -60,18 +60,16 @@ public:
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   bool is_assignment_expression (void) const { return true; }
 
-  void eval_error (void);
-
   std::string oper (void) const;
 
   tree_expression *left_hand_side (void) { return lhs; }
 
   tree_expression *right_hand_side (void) { return rhs; }
 
   tree_expression *dup (symbol_table::scope_id scope,
 			symbol_table::context_id context);
@@ -131,18 +129,16 @@ public:
   bool is_assignment_expression (void) const { return true; }
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
-  void eval_error (void);
-
   std::string oper (void) const;
 
   tree_argument_list *left_hand_side (void) { return lhs; }
 
   tree_expression *right_hand_side (void) { return rhs; }
 
   tree_expression *dup (symbol_table::scope_id scope,
 			symbol_table::context_id context);
diff --git a/src/pt-binop.cc b/src/pt-binop.cc
--- a/src/pt-binop.cc
+++ b/src/pt-binop.cc
@@ -57,53 +57,33 @@ tree_binary_expression::rvalue (void)
 
   if (error_state)
     return retval;
 
   if (op_lhs)
     {
       octave_value a = op_lhs->rvalue ();
 
-      if (error_state)
-	eval_error ();
-      else if (a.is_defined () && op_rhs)
+      if (! error_state && a.is_defined () && op_rhs)
 	{
 	  octave_value b = op_rhs->rvalue ();
 
-	  if (error_state)
-	    eval_error ();
-	  else if (b.is_defined ())
+	  if (! error_state && b.is_defined ())
 	    {
 	      retval = ::do_binary_op (etype, a, b);
 
 	      if (error_state)
-		{
-		  retval = octave_value ();
-		  eval_error ();
-		}
+		retval = octave_value ();
 	    }
-	  else
-	    eval_error ();
 	}
-      else
-	eval_error ();
     }
-  else
-    eval_error ();
 
   return retval;
 }
 
-void
-tree_binary_expression::eval_error (void)
-{
-  ::error ("evaluating binary operator `%s' near line %d, column %d",
-	   oper () . c_str (), line (), column ());
-}
-
 std::string
 tree_binary_expression::oper (void) const
 {
   return octave_value::binary_op_as_string (etype);
 }
 
 tree_expression *
 tree_binary_expression::dup (symbol_table::scope_id scope,
@@ -152,25 +132,21 @@ tree_boolean_expression::rvalue (void)
     return retval;
 
   bool result = false;
 
   if (op_lhs)
     {
       octave_value a = op_lhs->rvalue ();
 
-      if (error_state)
-	eval_error ();
-      else
+      if (! error_state)
 	{
 	  bool a_true = a.is_true ();
 
-	  if (error_state)
-	    eval_error ();
-	  else
+	  if (! error_state)
 	    {
 	      if (a_true)
 		{
 		  if (etype == bool_or)
 		    {
 		      result = true;
 		      goto done;
 		    }
@@ -180,38 +156,27 @@ tree_boolean_expression::rvalue (void)
 		  if (etype == bool_and)
 		    goto done;
 		}
 
 	      if (op_rhs)
 		{
 		  octave_value b = op_rhs->rvalue ();
 
-		  if (error_state)
-		    eval_error ();
-		  else
-		    {
-		      result = b.is_true ();
-
-		      if (error_state)
-			eval_error ();
-		    }
+		  if (! error_state)
+		    result = b.is_true ();
 		}
-	      else
-		eval_error ();
 
 	    done:
 
 	      if (! error_state)
 		retval = octave_value (result);
 	    }
 	}
     }
-  else
-    eval_error ();
 
   return retval;
 }
 
 std::string
 tree_boolean_expression::oper (void) const
 {
   std::string retval = "<unknown>";
diff --git a/src/pt-binop.h b/src/pt-binop.h
--- a/src/pt-binop.h
+++ b/src/pt-binop.h
@@ -69,18 +69,16 @@ public:
   bool is_binary_expression (void) const { return true; }
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
-  void eval_error (void);
-
   std::string oper (void) const;
 
   octave_value::binary_op op_type (void) const { return etype; }
 
   tree_expression *lhs (void) { return op_lhs; }
   tree_expression *rhs (void) { return op_rhs; }
 
   tree_expression *dup (symbol_table::scope_id scope,
diff --git a/src/pt-cbinop.cc b/src/pt-cbinop.cc
--- a/src/pt-cbinop.cc
+++ b/src/pt-cbinop.cc
@@ -120,39 +120,26 @@ tree_compound_binary_expression::rvalue 
 
   if (error_state)
     return retval;
 
   if (op_lhs)
     {
       octave_value a = op_lhs->rvalue ();
 
-      if (error_state)
-	eval_error ();
-      else if (a.is_defined () && op_rhs)
+      if (! error_state && a.is_defined () && op_rhs)
 	{
 	  octave_value b = op_rhs->rvalue ();
 
-	  if (error_state)
-	    eval_error ();
-	  else if (b.is_defined ())
+	  if (! error_state && b.is_defined ())
 	    {
 	      retval = ::do_binary_op (etype, a, b);
 
 	      if (error_state)
-		{
-		  retval = octave_value ();
-		  eval_error ();
-		}
+		retval = octave_value ();
 	    }
-	  else
-	    eval_error ();
 	}
-      else
-	eval_error ();
     }
-  else
-    eval_error ();
 
   return retval;
 }
 
 
diff --git a/src/pt-colon.cc b/src/pt-colon.cc
--- a/src/pt-colon.cc
+++ b/src/pt-colon.cc
@@ -179,21 +179,17 @@ tree_colon_expression::rvalue (void)
     }
 
   return retval;
 }
 
 void
 tree_colon_expression::eval_error (const std::string& s) const
 {
-  if (! s.empty ())
-    ::error ("%s", s.c_str ());
-
-  ::error ("evaluating colon expression near line %d column %d",
-	   line (), column ());
+  ::error ("%s", s.c_str ());
 }
 
 int
 tree_colon_expression::line (void) const
 {
   return (op_base ? op_base->line ()
 	  : (op_increment ? op_increment->line ()
 	     : (op_limit ? op_limit->line ()
diff --git a/src/pt-colon.h b/src/pt-colon.h
--- a/src/pt-colon.h
+++ b/src/pt-colon.h
@@ -76,17 +76,17 @@ public:
   tree_colon_expression *append (tree_expression *t);
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
-  void eval_error (const std::string& s = std::string ()) const;
+  void eval_error (const std::string& s) const;
 
   tree_expression *base (void) { return op_base; }
 
   tree_expression *limit (void) { return op_limit; }
 
   tree_expression *increment (void) { return op_increment; }
 
   int line (void) const;
diff --git a/src/pt-decl.cc b/src/pt-decl.cc
--- a/src/pt-decl.cc
+++ b/src/pt-decl.cc
@@ -167,20 +167,16 @@ tree_global_command::do_init (tree_decl_
 
 void
 tree_global_command::eval (void)
 {
   MAYBE_DO_BREAKPOINT;
 
   if (init_list)
     init_list->eval (do_init);
-
-  if (error_state)
-    ::error ("evaluating global command near line %d, column %d",
-	     line (), column ());
 }
 
 tree_command *
 tree_global_command::dup (symbol_table::scope_id scope,
 			  symbol_table::context_id context)
 {
   return
     new tree_global_command (init_list ? init_list->dup (scope, context) : 0,
@@ -220,20 +216,16 @@ void
 tree_static_command::eval (void)
 {
   MAYBE_DO_BREAKPOINT;
 
   // Static variables only need to be marked and initialized once.
 
   if (init_list)
     init_list->eval (do_init);
-
-  if (error_state)
-    ::error ("evaluating static command near line %d, column %d",
-	     line (), column ());
 }
 
 tree_command *
 tree_static_command::dup (symbol_table::scope_id scope,
 			  symbol_table::context_id context)
 {
   return
     new tree_static_command (init_list ? init_list->dup (scope, context) : 0,
diff --git a/src/pt-exp.cc b/src/pt-exp.cc
--- a/src/pt-exp.cc
+++ b/src/pt-exp.cc
@@ -45,18 +45,16 @@ tree_expression::is_logically_true (cons
   if (! error_state)
     {
       if (t1.is_defined ())
 	return t1.is_true ();
       else
 	::error ("%s: undefined value used in conditional expression",
 		 warn_for);
     }
-  else
-    ::error ("%s: error evaluating conditional expression", warn_for);
 
   return expr_value;
 }
 
 octave_value
 tree_expression::rvalue (void)
 {
   ::error ("invalid rvalue function called in expression");
diff --git a/src/pt-idx.cc b/src/pt-idx.cc
--- a/src/pt-idx.cc
+++ b/src/pt-idx.cc
@@ -237,22 +237,17 @@ tree_index_expression::make_arg_struct (
 	  subs_field(i) = make_subs_cell (*p_args, *p_arg_nm);
 	  break;
 
 	case '{':
 	  subs_field(i) = make_subs_cell (*p_args, *p_arg_nm);
 	  break;
 
 	case '.':
-	  {
-	    subs_field(i) = get_struct_index (p_arg_nm, p_dyn_field);
-
-	    if (error_state)
-	      eval_error ();
-	  }
+	  subs_field(i) = get_struct_index (p_arg_nm, p_dyn_field);
 	  break;
 
 	default:
 	  panic_impossible ();
 	}
 
       if (error_state)
 	return m;
@@ -356,22 +351,17 @@ tree_index_expression::rvalue (int nargo
 		idx.push_back (make_value_list (*p_args, *p_arg_nm, &tmp));
 	      break;
 
 	    case '{':
 	      idx.push_back (make_value_list (*p_args, *p_arg_nm, &tmp));
 	      break;
 
 	    case '.':
-	      {
-		idx.push_back (octave_value (get_struct_index (p_arg_nm, p_dyn_field)));
-
-		if (error_state)
-		  eval_error ();
-	      }
+	      idx.push_back (octave_value (get_struct_index (p_arg_nm, p_dyn_field)));
 	      break;
 
 	    default:
 	      panic_impossible ();
 	    }
 
 	  if (error_state)
 	    break;
@@ -613,18 +603,16 @@ tree_index_expression::lvalue (void)
 				      }
 				  }
 			      }
 			  }
 		      }
 
 		    idx.push_back (octave_value (tidx));
 		  }
-		else
-		  eval_error ();
 	      }
 	      break;
 
 	    default:
 	      panic_impossible ();
 	    }
 
 	  if (error_state)
@@ -662,37 +650,16 @@ tree_index_expression::lvalue (void)
 %! assert (x(2).b == 1);
 
 %!test
 %! x = struct (zeros (0, 1), {"a", "b"});
 %! x(2).b = 1;
 %! assert (x(2).b == 1);
 */
 
-void
-tree_index_expression::eval_error (void) const
-{
-  int l = line ();
-  int c = column ();
-
-  const char *type_str;
-
-  if (type[0] == '.')
-    type_str = "structure reference operator";
-  else if (args.front ())
-    type_str = "index expression";
-  else
-    type_str = "expression";
-
-  if (l != -1 && c != -1)
-    ::error ("evaluating %s near line %d, column %d", type_str, l, c);
-  else
-    ::error ("evaluating %s", type_str);
-}
-
 tree_index_expression *
 tree_index_expression::dup (symbol_table::scope_id scope,
 			    symbol_table::context_id context)
 {
   tree_index_expression *new_idx_expr
     = new tree_index_expression (line (), column ());
 
   new_idx_expr->expr = expr ? expr->dup (scope, context) : 0;
diff --git a/src/pt-idx.h b/src/pt-idx.h
--- a/src/pt-idx.h
+++ b/src/pt-idx.h
@@ -83,18 +83,16 @@ public:
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   octave_lvalue lvalue (void);
 
-  void eval_error (void) const;
-
   tree_index_expression *dup (symbol_table::scope_id scope,
 			      symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // The LHS of this index expression.
diff --git a/src/pt-loop.cc b/src/pt-loop.cc
--- a/src/pt-loop.cc
+++ b/src/pt-loop.cc
@@ -96,40 +96,30 @@ tree_while_command::eval (void)
     {
       if (expr->is_logically_true ("while"))
 	{
 	  if (list)
 	    {
 	      list->eval ();
 
 	      if (error_state)
-		{
-		  eval_error ();
-		  goto cleanup;
-		}
+		goto cleanup;
 	    }
 
 	  if (quit_loop_now ())
 	    break;
 	}
       else
 	break;
     }
 
  cleanup:
   unwind_protect::run_frame ("while_command::eval");
 }
 
-void
-tree_while_command::eval_error (void)
-{
-  ::error ("evaluating while command near line %d, column %d",
-	   line (), column ());
-}
-
 tree_command *
 tree_while_command::dup (symbol_table::scope_id scope,
 			 symbol_table::context_id context)
 {
   return new tree_while_command (expr ? expr->dup (scope, context) : 0,
 				 list ? list->dup (scope, context) : 0,
 				 lead_comm ? lead_comm->dup () : 0,
 				 trail_comm ? trail_comm->dup (): 0,
@@ -163,37 +153,27 @@ tree_do_until_command::eval (void)
     {
       MAYBE_DO_BREAKPOINT;
 
       if (list)
 	{
 	  list->eval ();
 
 	  if (error_state)
-	    {
-	      eval_error ();
-	      goto cleanup;
-	    }
+	    goto cleanup;
 	}
 
       if (quit_loop_now () || expr->is_logically_true ("do-until"))
 	break;
     }
 
  cleanup:
   unwind_protect::run_frame ("do_until_command::eval");
 }
 
-void
-tree_do_until_command::eval_error (void)
-{
-  ::error ("evaluating do-until command near line %d, column %d",
-	   line (), column ());
-}
-
 tree_command *
 tree_do_until_command::dup (symbol_table::scope_id scope,
 			    symbol_table::context_id context)
 {
   return new tree_do_until_command (expr ? expr->dup (scope, context) : 0,
 				    list ? list->dup (scope, context) : 0,
 				    lead_comm ? lead_comm->dup () : 0,
 				    trail_comm ? trail_comm->dup (): 0,
@@ -218,28 +198,18 @@ tree_simple_for_command::~tree_simple_fo
 
 inline void
 tree_simple_for_command::do_for_loop_once (octave_lvalue& ult,
 					   const octave_value& rhs,
 					   bool& quit)
 {
   ult.assign (octave_value::op_asn_eq, rhs);
 
-  if (! error_state)
-    {
-      if (list)
-	{
-	  list->eval ();
-
-	  if (error_state)
-	    eval_error ();
-	}
-    }
-  else
-    eval_error ();
+  if (! error_state && list)
+    list->eval ();
 
   quit = quit_loop_now ();
 }
 
 #define DO_ND_LOOP(MTYPE, TYPE, CONV, ARG) \
   do \
     { \
       dim_vector dv = ARG.dims (); \
@@ -332,29 +302,23 @@ tree_simple_for_command::eval (void)
 
   unwind_protect_bool (evaluating_looping_command);
 
   evaluating_looping_command = true;
 
   octave_value rhs = expr->rvalue ();
 
   if (error_state || rhs.is_undefined ())
-    {
-      eval_error ();
-      goto cleanup;
-    }
+    goto cleanup;
 
   {
     octave_lvalue ult = lhs->lvalue ();
 
     if (error_state)
-      {
-	eval_error ();
-	goto cleanup;
-      }
+      goto cleanup;
 
     if (rhs.is_range ())
       {
 	Range rng = rhs.range_value ();
 
 	octave_idx_type steps = rng.nelem ();
 	double b = rng.base ();
 	double increment = rng.inc ();
@@ -484,23 +448,16 @@ tree_simple_for_command::eval (void)
 		 line (), column ());
       }
   }
 
  cleanup:
   unwind_protect::run_frame ("simple_for_command::eval");
 }
 
-void
-tree_simple_for_command::eval_error (void)
-{
-  ::error ("evaluating for command near line %d, column %d",
-	   line (), column ());
-}
-
 tree_command *
 tree_simple_for_command::dup (symbol_table::scope_id scope,
 			      symbol_table::context_id context)
 {
   return new tree_simple_for_command (lhs ? lhs->dup (scope, context) : 0,
 				      expr ? expr->dup (scope, context) : 0,
 				      list ? list->dup (scope, context) : 0,
 				      lead_comm ? lead_comm->dup () : 0,
@@ -529,28 +486,18 @@ tree_complex_for_command::do_for_loop_on
 					    const octave_value& key,
 					    bool& quit)
 {
   quit = false;
 
   val_ref.assign (octave_value::op_asn_eq, val);
   key_ref.assign (octave_value::op_asn_eq, key);
 
-  if (! error_state)
-    {
-      if (list)
-	{
-	  list->eval ();
-
-	  if (error_state)
-	    eval_error ();
-	}
-    }
-  else
-    eval_error ();
+  if (! error_state && list)
+    list->eval ();
 
   quit = quit_loop_now ();
 }
 
 void
 tree_complex_for_command::eval (void)
 {
   if (error_state)
@@ -560,20 +507,17 @@ tree_complex_for_command::eval (void)
 
   unwind_protect_bool (evaluating_looping_command);
 
   evaluating_looping_command = true;
 
   octave_value rhs = expr->rvalue ();
 
   if (error_state || rhs.is_undefined ())
-    {
-      eval_error ();
-      goto cleanup;
-    }
+    goto cleanup;
 
   if (rhs.is_map ())
     {
       // Cycle through structure elements.  First element of id_list
       // is set to value and the second is set to the name of the
       // structure element.
 
       tree_argument_list::iterator p = lhs->begin ();
@@ -606,23 +550,16 @@ tree_complex_for_command::eval (void)
     }
   else
     error ("in statement `for [X, Y] = VAL', VAL must be a structure");
 
  cleanup:
   unwind_protect::run_frame ("complex_for_command::eval");
 }
 
-void
-tree_complex_for_command::eval_error (void)
-{
-  ::error ("evaluating for command near line %d, column %d",
-	   line (), column ());
-}
-
 tree_command *
 tree_complex_for_command::dup (symbol_table::scope_id scope,
 			       symbol_table::context_id context)
 {
   return new tree_complex_for_command (lhs ? lhs->dup (scope, context) : 0,
 				       expr ? expr->dup (scope, context) : 0,
 				       list ? list->dup (scope, context) : 0,
 				       lead_comm ? lead_comm->dup () : 0,
diff --git a/src/pt-loop.h b/src/pt-loop.h
--- a/src/pt-loop.h
+++ b/src/pt-loop.h
@@ -64,18 +64,16 @@ public:
 		      int l = -1, int c = -1)
     : tree_command (l, c), expr (e), list (lst), lead_comm (lc),
       trail_comm (tc) { }
 
   ~tree_while_command (void);
 
   void eval (void);
 
-  void eval_error (void);
-
   tree_expression *condition (void) { return expr; }
 
   tree_statement_list *body (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
@@ -128,18 +126,16 @@ public:
 			 octave_comment_list *tc = 0,
 			 int l = -1, int c = -1)
     : tree_while_command (e, lst, lc, tc, l, c) { }
 
   ~tree_do_until_command (void) { }
 
   void eval (void);
 
-  void eval_error (void);
-
   tree_command *dup (symbol_table::scope_id scope,
 		     symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
@@ -167,18 +163,16 @@ public:
 			   int l = -1, int c = -1)
     : tree_command (l, c), lhs (le), expr (re), list (lst),
       lead_comm (lc), trail_comm (tc) { }
 
   ~tree_simple_for_command (void);
 
   void eval (void);
 
-  void eval_error (void);
-
   tree_expression *left_hand_side (void) { return lhs; }
 
   tree_expression *control_expr (void) { return expr; }
 
   tree_statement_list *body (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
@@ -232,18 +226,16 @@ public:
 			    int l = -1, int c = -1)
     : tree_command (l, c), lhs (le), expr (re), list (lst),
       lead_comm (lc), trail_comm (tc) { }
 
   ~tree_complex_for_command (void);
 
   void eval (void);
 
-  void eval_error (void);
-
   tree_argument_list *left_hand_side (void) { return lhs; }
 
   tree_expression *control_expr (void) { return expr; }
 
   tree_statement_list *body (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
diff --git a/src/pt-select.cc b/src/pt-select.cc
--- a/src/pt-select.cc
+++ b/src/pt-select.cc
@@ -119,20 +119,16 @@ tree_if_command::~tree_if_command (void)
   delete trail_comm;
 }
 
 void
 tree_if_command::eval (void)
 {
   if (list)
     list->eval ();
-
-  if (error_state)
-    ::error ("evaluating if command near line %d, column %d",
-	     line (), column ());
 }
 
 tree_command *
 tree_if_command::dup (symbol_table::scope_id scope,
 		      symbol_table::context_id context)
 {
   return new tree_if_command (list ? list->dup (scope, context) : 0,
 			      lead_comm ? lead_comm->dup () : 0,
@@ -190,40 +186,32 @@ tree_switch_case::label_matches (const o
 
 	  for (octave_idx_type i = 0; i < cell.rows (); i++)
 	    {
 	      for (octave_idx_type j = 0; j < cell.columns (); j++)
 		{
 		  bool match = equal (val, cell(i,j));
 
 		  if (error_state)
-		    {
-		      eval_error ();
-		      return false;
-		    }
+		    return false;
 		  else if (match)
 		    return true;
 		}
 	    }
 	}
       else
 	{
 	  bool match = equal (val, label_value);
 
 	  if (error_state)
-	    {
-	      eval_error ();
-	      return false;
-	    }
+	    return false;
 	  else
 	    return match;
 	}
     }
-  else
-    eval_error ();
 
   return false;
 }
 
 int
 tree_switch_case::eval (const octave_value& val)
 {
   int retval = 0;
@@ -234,22 +222,16 @@ tree_switch_case::eval (const octave_val
 	list->eval ();
 
       retval = 1;
     }
 
   return retval;
 }
 
-void
-tree_switch_case::eval_error (void)
-{
-  ::error ("evaluating switch case label");
-}
-
 tree_switch_case *
 tree_switch_case::dup (symbol_table::scope_id scope,
 		       symbol_table::context_id context)
 {
   return new tree_switch_case (label ? label->dup (scope, context) : 0,
 			       list ? list->dup (scope, context) : 0,
 			       lead_comm ? lead_comm->dup () : 0);
 }
@@ -308,39 +290,24 @@ tree_switch_command::~tree_switch_comman
 
 void
 tree_switch_command::eval (void)
 {
   if (expr)
     {
       octave_value val = expr->rvalue ();
 
-      if (! error_state)
-	{
-	  if (list)
-	    list->eval (val);
-
-	  if (error_state)
-	    eval_error ();
-	}
-      else
-	eval_error ();
+      if (! error_state && list)
+	list->eval (val);
     }
   else
     ::error ("missing value in switch command near line %d, column %d",
 	     line (), column ());
 }
 
-void
-tree_switch_command::eval_error (void)
-{
-  ::error ("evaluating switch command near line %d, column %d",
-	   line (), column ());
-}
-
 tree_command *
 tree_switch_command::dup (symbol_table::scope_id scope,
 			  symbol_table::context_id context)
 {
   return new tree_switch_command (expr ? expr->dup (scope, context) : 0,
 				  list ? list->dup (scope, context) : 0,
 				  lead_comm ? lead_comm->dup () : 0,
 				  trail_comm ? trail_comm->dup () : 0,
diff --git a/src/pt-select.h b/src/pt-select.h
--- a/src/pt-select.h
+++ b/src/pt-select.h
@@ -187,18 +187,16 @@ public:
   ~tree_switch_case (void);
 
   bool is_default_case (void) { return ! label; }
 
   bool label_matches (const octave_value& val);
 
   int eval (const octave_value& val);
 
-  void eval_error (void);
-
   tree_expression *case_label (void) { return label; }
 
   tree_statement_list *commands (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   tree_switch_case *dup (symbol_table::scope_id scope,
 			 symbol_table::context_id context);
@@ -272,18 +270,16 @@ public:
 		       int l = -1, int c = -1)
     : tree_command (l, c), expr (e), list (lst), lead_comm (lc),
       trail_comm (tc) { }
 
   ~tree_switch_command (void);
 
   void eval (void);
 
-  void eval_error (void);
-
   tree_expression *switch_value (void) { return expr; }
 
   tree_switch_case_list *case_list (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
diff --git a/src/pt-stmt.cc b/src/pt-stmt.cc
--- a/src/pt-stmt.cc
+++ b/src/pt-stmt.cc
@@ -24,16 +24,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "quit.h"
 
 #include "defun.h"
 #include "error.h"
+#include "gripes.h"
 #include "ov.h"
 #include "oct-lvalue.h"
 #include "input.h"
 #include "pager.h"
 #include "pt-bp.h"
 #include "pt-cmd.h"
 #include "pt-id.h"
 #include "pt-idx.h"
@@ -124,18 +125,17 @@ tree_statement::eval (bool silent, int n
 	      retval = expr->rvalue (nargout);
 
 	      if (do_bind_ans && ! (error_state || retval.empty ()))
 		bind_ans (retval(0), pf);
 	    }
 	}
       catch (octave_execution_exception)
 	{
-	  octave_exception_state = octave_no_exception;
-	  error ("caught execution error in library function");
+	  gripe_library_execution_error ();
 	}
     }
 
   return retval;
 }
 
 tree_statement *
 tree_statement::dup (symbol_table::scope_id scope,
diff --git a/src/pt-unop.cc b/src/pt-unop.cc
--- a/src/pt-unop.cc
+++ b/src/pt-unop.cc
@@ -78,53 +78,35 @@ tree_prefix_expression::rvalue (void)
 	      octave_lvalue ref = op->lvalue ();
 
 	      if (! error_state && ref.is_defined ())
 		{
 		  ref.do_unary_op (etype);
 
 		  retval = ref.value ();
 		}
-	      else
-		eval_error ();
 	    }
-	  else
-	    eval_error ();
 	}
       else
 	{
 	  octave_value val = op->rvalue ();
 
 	  if (! error_state && val.is_defined ())
 	    {
 	      retval = ::do_unary_op (etype, val);
 
 	      if (error_state)
-		{
-		  retval = octave_value ();
-		  eval_error ();
-		}
+		retval = octave_value ();
 	    }
-	  else
-	    eval_error ();
 	}
     }
-  else
-    eval_error ();
 
   return retval;
 }
 
-void
-tree_prefix_expression::eval_error (void)
-{
-  ::error ("evaluating prefix operator `%s' near line %d, column %d",
-	   oper () . c_str (), line (), column ());
-}
-
 tree_expression *
 tree_prefix_expression::dup (symbol_table::scope_id scope,
 			     symbol_table::context_id context)
 {
   tree_prefix_expression *new_pe
     = new tree_prefix_expression (op ? op->dup (scope, context) : 0,
 				  line (), column (), etype);
 
@@ -176,53 +158,35 @@ tree_postfix_expression::rvalue (void)
 	      octave_lvalue ref = op->lvalue ();
 
 	      if (! error_state && ref.is_defined ())
 		{
 		  retval = ref.value ();
 
 		  ref.do_unary_op (etype);
 		}
-	      else
-		eval_error ();
 	    }
-	  else
-	    eval_error ();
 	}
       else
 	{
 	  octave_value val = op->rvalue ();
 
 	  if (! error_state && val.is_defined ())
 	    {
 	      retval = ::do_unary_op (etype, val);
 
 	      if (error_state)
-		{
-		  retval = octave_value ();
-		  eval_error ();
-		}
+		retval = octave_value ();
 	    }
-	  else
-	    eval_error ();
 	}
     }
-  else
-    eval_error ();
 
   return retval;
 }
 
-void
-tree_postfix_expression::eval_error (void)
-{
-  ::error ("evaluating postfix operator `%s' near line %d, column %d",
-	   oper () . c_str (), line (), column ());
-}
-
 tree_expression *
 tree_postfix_expression::dup (symbol_table::scope_id scope,
 			      symbol_table::context_id context)
 {
   tree_postfix_expression *new_pe
     = new tree_postfix_expression (op ? op->dup (scope, context) : 0,
 				   line (), column (), etype);
 
diff --git a/src/pt-unop.h b/src/pt-unop.h
--- a/src/pt-unop.h
+++ b/src/pt-unop.h
@@ -99,18 +99,16 @@ public:
   ~tree_prefix_expression (void) { }
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
-  void eval_error (void);
-
   tree_expression *dup (symbol_table::scope_id scope,
 			symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
@@ -138,18 +136,16 @@ public:
   ~tree_postfix_expression (void) { }
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
-  void eval_error (void);
-
   tree_expression *dup (symbol_table::scope_id scope,
 			symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -468,16 +468,51 @@ octave_call_stack::do_goto_base_frame (v
   curr_frame = cs.size ();
 
   cs.push_back (tmp);
 
   symbol_table::set_scope_and_context (tmp.scope, tmp.context);
 }
 
 void
+octave_call_stack::backtrace_error_message (void) const
+{
+  if (error_state > 0)
+    {
+      error_state = -1;
+
+      error ("called from:");
+    }
+
+  if (! cs.empty ())
+    {
+      const call_stack_elt& elt = cs.back ();
+
+      octave_function *fcn = elt.fcn;
+      tree_statement *stmt = elt.stmt;
+
+      std::string fcn_name = "?unknown?";
+
+      if (fcn)
+	{
+	  fcn_name = fcn->fcn_file_name ();
+
+	  if (fcn_name.empty ())
+	    fcn_name = fcn->name ();
+	}
+
+      int line = stmt ? stmt->line () : -1;
+      int column = stmt ? stmt->column () : -1;
+
+      error ("  %s at line %d, column %d",
+	     fcn_name.c_str (), line, column);
+    }
+}
+
+void
 recover_from_exception (void)
 {
   can_interrupt = true;
   octave_interrupt_immediately = 0;
   octave_interrupt_state = 0;
   octave_signal_caught = 0;
   octave_exception_state = octave_no_exception;
   octave_restore_signal_mask ();
diff --git a/src/toplev.h b/src/toplev.h
--- a/src/toplev.h
+++ b/src/toplev.h
@@ -375,25 +375,30 @@ private:
   void do_goto_caller_frame (void);
 
   void do_goto_base_frame (void);
 
   void do_pop (void)
   {
     if (cs.size () > 1)
       {
+	if (error_state)
+	  backtrace_error_message ();
+
 	const call_stack_elt& elt = cs.back ();
 	curr_frame = elt.prev;
 	cs.pop_back ();
 	const call_stack_elt& new_elt = cs[curr_frame];
 	symbol_table::set_scope_and_context (new_elt.scope, new_elt.context);
       }
   }
 
   void do_clear (void) { cs.clear (); }
+
+  void backtrace_error_message (void) const;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
