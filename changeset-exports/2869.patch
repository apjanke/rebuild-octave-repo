# HG changeset patch
# User jwe
# Date 861412692 0
#      Sat Apr 19 01:18:12 1997 +0000
# Node ID 0da4980855bc2129355dc4b872b5d03da7738dfd
# Parent  30e1f6f411614aa08d85cbd7b1b2ff6974557cad
[project @ 1997-04-19 01:18:11 by jwe]

diff --git a/src/op-cm-cm.cc b/src/op-cm-cm.cc
--- a/src/op-cm-cm.cc
+++ b/src/op-cm-cm.cc
@@ -84,74 +84,62 @@ pow (const octave_value&, const octave_v
 static octave_value
 ldiv (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
   return xleftdiv (v1.complex_matrix_value (), v2.complex_matrix_value ());
 }
 
-#define BOOL_OP(OP, ONE_EMPTY_RESULT, TWO_EMPTY_RESULT) \
-  MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (), \
-		 ComplexMatrix, m2, v2.complex_matrix_value (), \
-		 real (m1 (i, j)) OP real (m2 (i, j)), #OP, \
-		 ONE_EMPTY_RESULT, TWO_EMPTY_RESULT)
-
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (<, boolMatrix (), boolMatrix ());
+  return mx_el_lt (v1.complex_matrix_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (<=, boolMatrix (), boolMatrix ());
+  return mx_el_le (v1.complex_matrix_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
-  MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (),
-		 ComplexMatrix, m2, v2.complex_matrix_value (),
-		 m1 (i, j) == m2 (i, j), "==",
-		 0.0, 1.0);
+  return mx_el_eq (v1.complex_matrix_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (>=, boolMatrix (), boolMatrix ());
+  return mx_el_ge (v1.complex_matrix_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (>, boolMatrix (), boolMatrix ());
+  return mx_el_gt (v1.complex_matrix_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
-  MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (),
-		 ComplexMatrix, m2, v2.complex_matrix_value (),
-		 m1 (i, j) != m2 (i, j), "!=",
-		 1.0, 0.0);
+  return mx_el_ne (v1.complex_matrix_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
   return octave_value (product (v1.complex_matrix_value (),
@@ -184,31 +172,25 @@ el_ldiv (const octave_value& a1, const o
 				 v1.complex_matrix_value ()));
 }
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
-  MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (),
-		 ComplexMatrix, m2, v2.complex_matrix_value (),
-		 m1 (i, j) != 0.0 && m2 (i, j) != 0.0, "&",
-		 boolMatrix (), boolMatrix ());
+  return mx_el_and (v1.complex_matrix_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
-  MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (),
-		 ComplexMatrix, m2, v2.complex_matrix_value (),
-		 m1 (i, j) != 0.0 || m2 (i, j) != 0.0, "|",
-		 boolMatrix (), boolMatrix ());
+  return mx_el_or (v1.complex_matrix_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 assign (octave_value& a1, const octave_value_list& idx,
 	const octave_value& a2)
 {
   CAST_BINOP_ARGS (octave_complex_matrix&, const octave_complex_matrix&);
 
diff --git a/src/op-cm-cs.cc b/src/op-cm-cs.cc
--- a/src/op-cm-cs.cc
+++ b/src/op-cm-cs.cc
@@ -87,71 +87,62 @@ pow (const octave_value& a1, const octav
 
 static octave_value
 ldiv (const octave_value& v1, const octave_value&)
 {
   gripe_nonconformant ("operator \\", v1.rows (), v1.columns (), 1, 1);
   return octave_value ();
 }
 
-#define BOOL_OP(OP, EMPTY_RESULT) \
-  MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (), \
-		 Complex, s, v2.complex_value (), \
-		 real (m (i, j)) OP real (s), EMPTY_RESULT)
-
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
-  BOOL_OP (<, boolMatrix ());
+  return mx_el_lt (v1.complex_matrix_value (), v2.complex_value ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
-  BOOL_OP (<=, boolMatrix ());
+  return mx_el_le (v1.complex_matrix_value (), v2.complex_value ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
-  MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (),
-		 Complex, s, v2.complex_value (),
-		 m (i, j) == s, 0.0);
+  return mx_el_eq (v1.complex_matrix_value (), v2.complex_value ());
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
-  BOOL_OP (>=, boolMatrix ());
+  return mx_el_ge (v1.complex_matrix_value (), v2.complex_value ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
-  BOOL_OP (>, boolMatrix ());
+  return mx_el_gt (v1.complex_matrix_value (), v2.complex_value ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
-  MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (),
-		 Complex, s, v2.complex_value (),
-		 m (i, j) != s, 1.0);
+  return mx_el_ne (v1.complex_matrix_value (), v2.complex_value ());
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
   return octave_value (v1.complex_matrix_value () * v2.complex_value ());
@@ -186,29 +177,25 @@ el_ldiv (const octave_value& a1, const o
   return x_el_div (v2.complex_value (), v1.complex_matrix_value ());
 }
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
-  MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (),
-		 Complex, s, v2.complex_value (),
-		 m (i, j) != 0.0 && s != 0.0, boolMatrix ());
+  return mx_el_and (v1.complex_matrix_value (), v2.complex_value ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
-  MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (),
-		 Complex, s, v2.complex_value (),
-		 m (i, j) != 0.0 || s != 0.0, boolMatrix ());
+  return mx_el_or (v1.complex_matrix_value (), v2.complex_value ());
 }
 
 static octave_value
 assign (octave_value& a1, const octave_value_list& idx,
 	const octave_value& a2)
 {
   CAST_BINOP_ARGS (octave_complex_matrix&, const octave_complex&);
 
diff --git a/src/op-cm-m.cc b/src/op-cm-m.cc
--- a/src/op-cm-m.cc
+++ b/src/op-cm-m.cc
@@ -85,74 +85,62 @@ pow (const octave_value&, const octave_v
 static octave_value
 ldiv (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
   return xleftdiv (v1.complex_matrix_value (), v2.matrix_value ());
 }
 
-#define BOOL_OP(OP, ONE_EMPTY_RESULT, TWO_EMPTY_RESULT) \
-  MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (), \
-		 Matrix, m2, v2.matrix_value (), \
-		 real (m1 (i, j)) OP m2 (i, j), #OP, \
-		 ONE_EMPTY_RESULT, TWO_EMPTY_RESULT)
-
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
-  BOOL_OP (<, boolMatrix (), boolMatrix ());
+  return mx_el_lt (v1.complex_matrix_value (), v2.matrix_value ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
-  BOOL_OP (<=, boolMatrix (), boolMatrix ());
+  return mx_el_le (v1.complex_matrix_value (), v2.matrix_value ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
-  MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (),
-		 Matrix, m2, v2.matrix_value (),
-		 m1 (i, j) == m2 (i, j), "==",
-		 0.0, 1.0);
+  return mx_el_eq (v1.complex_matrix_value (), v2.matrix_value ());
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
-  BOOL_OP (>=, boolMatrix (), boolMatrix ());
+  return mx_el_ge (v1.complex_matrix_value (), v2.matrix_value ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
-  BOOL_OP (>, boolMatrix (), boolMatrix ());
+  return mx_el_gt (v1.complex_matrix_value (), v2.matrix_value ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
-  MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (),
-		 Matrix, m2, v2.matrix_value (),
-		 m1 (i, j) != m2 (i, j), "!=",
-		 1.0, 0.0);
+  return mx_el_ne (v1.complex_matrix_value (), v2.matrix_value ());
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
   return product (v1.complex_matrix_value (), v2.matrix_value ());
@@ -182,31 +170,25 @@ el_ldiv (const octave_value& a1, const o
   return quotient (v2.matrix_value (), v1.complex_matrix_value ());
 }
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
-  MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (),
-		 Matrix, m2, v2.matrix_value (),
-		 m1 (i, j) != 0.0 && m2 (i, j), "&",
-		 boolMatrix (), boolMatrix ());
+  return mx_el_and (v1.complex_matrix_value (), v2.matrix_value ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
-  MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (),
-		 Matrix, m2, v2.matrix_value (),
-		 m1 (i, j) != 0.0 || m2 (i, j), "|",
-		 boolMatrix (), boolMatrix ());
+  return mx_el_or (v1.complex_matrix_value (), v2.matrix_value ());
 }
 
 static octave_value
 assign (octave_value& a1, const octave_value_list& idx,
 	const octave_value& a2)
 {
   CAST_BINOP_ARGS (octave_complex_matrix&, const octave_matrix&);
 
diff --git a/src/op-cm-s.cc b/src/op-cm-s.cc
--- a/src/op-cm-s.cc
+++ b/src/op-cm-s.cc
@@ -89,71 +89,62 @@ pow (const octave_value& a1, const octav
 
 static octave_value
 ldiv (const octave_value& v1, const octave_value&)
 {
   gripe_nonconformant ("operator \\", v1.rows (), v1.columns (), 1, 1);
   return octave_value ();
 }
 
-#define BOOL_OP(OP, EMPTY_RESULT) \
-  MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (), \
-		 double, s, v2.double_value (), \
-		 real (m (i, j)) OP s, EMPTY_RESULT)
-
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
-  BOOL_OP (<, boolMatrix ());
+  return mx_el_lt (v1.complex_matrix_value (), v2.double_value ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
-  BOOL_OP (<=, boolMatrix ());
+  return mx_el_le (v1.complex_matrix_value (), v2.double_value ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
-  MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (),
-		 double, s, v2.double_value (),
-		 m (i, j) == s, 0.0);
+  return mx_el_eq (v1.complex_matrix_value (), v2.double_value ());
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
-  BOOL_OP (>=, boolMatrix ());
+  return mx_el_ge (v1.complex_matrix_value (), v2.double_value ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
-  BOOL_OP (>, boolMatrix ());
+  return mx_el_gt (v1.complex_matrix_value (), v2.double_value ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
-  MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (),
-		 double, s, v2.double_value (),
-		 m (i, j) != s, 1.0);
+  return mx_el_ne (v1.complex_matrix_value (), v2.double_value ());
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
   return octave_value (v1.complex_matrix_value () * v2.double_value ());
@@ -188,29 +179,25 @@ el_ldiv (const octave_value& a1, const o
   return x_el_div (v2.double_value (), v1.complex_matrix_value ());
 }
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
-  MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (),
-		 double, s, v2.double_value (),
-		 m (i, j) != 0.0 && s, boolMatrix ());
+  return mx_el_and (v1.complex_matrix_value (), v2.double_value ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
-  MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (),
-		 double, s, v2.double_value (),
-		 m (i, j) != 0.0 || s, boolMatrix ());
+  return mx_el_or (v1.complex_matrix_value (), v2.double_value ());
 }
 
 static octave_value
 assign (octave_value& a1, const octave_value_list& idx,
 	const octave_value& a2)
 {
   CAST_BINOP_ARGS (octave_complex_matrix&, const octave_scalar&);
 
diff --git a/src/op-cs-cm.cc b/src/op-cs-cm.cc
--- a/src/op-cs-cm.cc
+++ b/src/op-cs-cm.cc
@@ -87,71 +87,62 @@ ldiv (const octave_value& a1, const octa
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.complex_matrix_value () / d);
 }
 
-#define BOOL_OP(OP, EMPTY_RESULT) \
-  SC_MX_BOOL_OP (Complex, s, v1.complex_value (), \
-		 ComplexMatrix, m, v2.complex_matrix_value (), \
-		 real (s) OP real (m (i, j)), EMPTY_RESULT)
-
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
-  BOOL_OP (<, boolMatrix ());
+  return mx_el_lt (v1.complex_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
-  BOOL_OP (<=, boolMatrix ());
+  return mx_el_le (v1.complex_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
-  SC_MX_BOOL_OP (Complex, s, v1.complex_value (),
-		 ComplexMatrix, m, v2.complex_matrix_value (),
-		 s == m (i, j), 0.0);
+  return mx_el_eq (v1.complex_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
-  BOOL_OP (>=, boolMatrix ());
+  return mx_el_ge (v1.complex_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
-  BOOL_OP (>, boolMatrix ());
+  return mx_el_gt (v1.complex_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
-  SC_MX_BOOL_OP (Complex, s, v1.complex_value (),
-		 ComplexMatrix, m, v2.complex_matrix_value (),
-		 s != m (i, j), 1.0);
+  return mx_el_ne (v1.complex_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
   return octave_value (v1.complex_value () * v2.complex_matrix_value ());
@@ -186,29 +177,25 @@ el_ldiv (const octave_value& a1, const o
   return octave_value (v2.complex_matrix_value () / d);
 }
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
-  SC_MX_BOOL_OP (Complex, s, v1.complex_value (),
-		 ComplexMatrix, m, v2.complex_matrix_value (),
-		 s != 0.0 && m (i, j) != 0.0, boolMatrix ());
+  return mx_el_and (v1.complex_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
-  SC_MX_BOOL_OP (Complex, s, v1.complex_value (),
-		 ComplexMatrix, m, v2.complex_matrix_value (),
-		 s != 0.0 || m (i, j) != 0.0, boolMatrix ());
+  return mx_el_or (v1.complex_value (), v2.complex_matrix_value ());
 }
 
 static octave_value *
 complex_matrix_conv (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_complex&);
 
   return new octave_complex_matrix (v.complex_matrix_value ());
diff --git a/src/op-cs-m.cc b/src/op-cs-m.cc
--- a/src/op-cs-m.cc
+++ b/src/op-cs-m.cc
@@ -91,71 +91,62 @@ ldiv (const octave_value& a1, const octa
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.matrix_value () / d);
 }
 
-#define BOOL_OP(OP, EMPTY_RESULT) \
-  SC_MX_BOOL_OP (Complex, s, v1.complex_value (), \
-		 Matrix, m, v2.matrix_value (), \
-		 real (s) OP m (i, j), EMPTY_RESULT)
-
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
-  BOOL_OP (<, boolMatrix ());
+  return mx_el_lt (v1.complex_value (), v2.matrix_value ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
-  BOOL_OP (<=, boolMatrix ());
+  return mx_el_le (v1.complex_value (), v2.matrix_value ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
-  SC_MX_BOOL_OP (Complex, s, v1.complex_value (),
-		 Matrix, m, v2.matrix_value (),
-		 s == m (i, j), 0.0);
+  return mx_el_eq (v1.complex_value (), v2.matrix_value ());
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
-  BOOL_OP (>=, boolMatrix ());
+  return mx_el_ge (v1.complex_value (), v2.matrix_value ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
-  BOOL_OP (>, boolMatrix ());
+  return mx_el_gt (v1.complex_value (), v2.matrix_value ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
-  SC_MX_BOOL_OP (Complex, s, v1.complex_value (),
-		 Matrix, m, v2.matrix_value (),
-		 s != m (i, j), 1.0);
+  return mx_el_ne (v1.complex_value (), v2.matrix_value ());
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
   return octave_value (v1.complex_value () * v2.matrix_value ());
@@ -190,29 +181,25 @@ el_ldiv (const octave_value& a1, const o
   return octave_value (v2.matrix_value () / d);
 }
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
-  SC_MX_BOOL_OP (Complex, s, v1.complex_value (), \
-		 Matrix, m, v2.matrix_value (), \
-		 s != 0.0 && m (i, j), boolMatrix ());
+  return mx_el_and (v1.complex_value (), v2.matrix_value ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
-  SC_MX_BOOL_OP (Complex, s, v1.complex_value (), \
-		 Matrix, m, v2.matrix_value (), \
-		 s != 0.0 || m (i, j), boolMatrix ());
+  return mx_el_or (v1.complex_value (), v2.matrix_value ());
 }
 
 static octave_value *
 complex_matrix_conv (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_complex&);
 
   return new octave_complex_matrix (v.complex_matrix_value ());
diff --git a/src/op-m-cm.cc b/src/op-m-cm.cc
--- a/src/op-m-cm.cc
+++ b/src/op-m-cm.cc
@@ -85,74 +85,62 @@ pow (const octave_value&, const octave_v
 static octave_value
 ldiv (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
   return xleftdiv (v1.matrix_value (), v2.complex_matrix_value ());
 }
 
-#define BOOL_OP(OP, ONE_EMPTY_RESULT, TWO_EMPTY_RESULT) \
-  MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (), \
-		 ComplexMatrix, m2, v2.complex_matrix_value (), \
-		 m1 (i, j) OP real (m2 (i, j)), #OP, \
-		 ONE_EMPTY_RESULT, TWO_EMPTY_RESULT)
-
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (<, boolMatrix (), boolMatrix ());
+  return mx_el_lt (v1.matrix_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (<=, boolMatrix (), boolMatrix ());
+  return mx_el_le (v1.matrix_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
-  MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (),
-		 ComplexMatrix, m2, v2.complex_matrix_value (),
-		 m1 (i, j) == m2 (i, j), "==",
-		 0.0, 1.0);
+  return mx_el_eq (v1.matrix_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (>=, boolMatrix (), boolMatrix ());
+  return mx_el_ge (v1.matrix_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (>, boolMatrix (), boolMatrix ());
+  return mx_el_gt (v1.matrix_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
-  MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (),
-		 ComplexMatrix, m2, v2.complex_matrix_value (),
-		 m1 (i, j) != m2 (i, j), "!=",
-		 1.0, 0.0);
+  return mx_el_ne (v1.matrix_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
   return product (v1.matrix_value (), v2.complex_matrix_value ());
@@ -182,31 +170,25 @@ el_ldiv (const octave_value& a1, const o
   return quotient (v2.complex_matrix_value (), v1.matrix_value ());
 }
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
-  MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (),
-		 ComplexMatrix, m2, v2.complex_matrix_value (),
-		 m1 (i, j) && m2 (i, j) != 0.0, "&",
-		 boolMatrix (), boolMatrix ());
+  return mx_el_and (v1.matrix_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
-  MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (),
-		 ComplexMatrix, m2, v2.complex_matrix_value (),
-		 m1 (i, j) || m2 (i, j) != 0.0, "|",
-		 boolMatrix (), boolMatrix ());
+  return mx_el_or (v1.matrix_value (), v2.complex_matrix_value ());
 }
 
 static octave_value *
 complex_matrix_conv (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_matrix&);
 
   return new octave_complex_matrix (ComplexMatrix (v.matrix_value ()));
diff --git a/src/op-m-cs.cc b/src/op-m-cs.cc
--- a/src/op-m-cs.cc
+++ b/src/op-m-cs.cc
@@ -91,71 +91,62 @@ pow (const octave_value& a1, const octav
 
 static octave_value
 ldiv (const octave_value& v1, const octave_value&)
 {
   gripe_nonconformant ("operator \\", v1.rows (), v1.columns (), 1, 1);
   return octave_value ();
 }
 
-#define BOOL_OP(OP, EMPTY_RESULT) \
-  MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (), \
-		 Complex, s, v2.complex_value (), \
-		 m (i, j) OP real (s), EMPTY_RESULT)
-
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
-  BOOL_OP (<, boolMatrix ());
+  return mx_el_lt (v1.matrix_value (), v2.complex_value ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
-  BOOL_OP (<=, boolMatrix ());
+  return mx_el_le (v1.matrix_value (), v2.complex_value ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
-  MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (),
-		 Complex, s, v2.complex_value (),
-		 m (i, j) == s, 0.0);
+  return mx_el_eq (v1.matrix_value (), v2.complex_value ());
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
-  BOOL_OP (>=, boolMatrix ());
+  return mx_el_ge (v1.matrix_value (), v2.complex_value ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
-  BOOL_OP (>, boolMatrix ());
+  return mx_el_gt (v1.matrix_value (), v2.complex_value ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
-  MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (),
-		 Complex, s, v2.complex_value (),
-		 m (i, j) != s, 1.0);
+  return mx_el_ne (v1.matrix_value (), v2.complex_value ());
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
   return octave_value (v1.matrix_value () * v2.complex_value ());
@@ -190,29 +181,25 @@ el_ldiv (const octave_value& a1, const o
   return x_el_div (v2.complex_value (), v1.matrix_value ());
 }
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
-  MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (),
-		 Complex, s, v2.complex_value (),
-		 m (i, j) && s != 0.0, boolMatrix ());
+  return mx_el_and (v1.matrix_value (), v2.complex_value ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
-  MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (),
-		 Complex, s, v2.complex_value (),
-		 m (i, j) || s != 0.0, boolMatrix ());
+  return mx_el_or (v1.matrix_value (), v2.complex_value ());
 }
 
 static octave_value *
 complex_matrix_conv (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_matrix&);
 
   return new octave_complex_matrix (ComplexMatrix (v.matrix_value ()));
diff --git a/src/op-m-m.cc b/src/op-m-m.cc
--- a/src/op-m-m.cc
+++ b/src/op-m-m.cc
@@ -81,68 +81,62 @@ pow (const octave_value&, const octave_v
 static octave_value
 ldiv (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
   return xleftdiv (v1.matrix_value (), v2.matrix_value ());
 }
 
-#define BOOL_OP(OP, ONE_EMPTY_RESULT, TWO_EMPTY_RESULT) \
-  MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (), \
-		 Matrix, m2, v2.matrix_value (), \
-		 m1 (i, j) OP m2 (i, j), #OP, \
-		 ONE_EMPTY_RESULT, TWO_EMPTY_RESULT)
-
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
-  BOOL_OP (<, boolMatrix (), boolMatrix ());
+  return mx_el_lt (v1.matrix_value (), v2.matrix_value ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
-  BOOL_OP (<=, boolMatrix (), boolMatrix ());
+  return mx_el_le (v1.matrix_value (), v2.matrix_value ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
-  BOOL_OP (==, 0.0, 1.0);
+  return mx_el_eq (v1.matrix_value (), v2.matrix_value ());
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
-  BOOL_OP (>=, boolMatrix (), boolMatrix ());
+  return mx_el_ge (v1.matrix_value (), v2.matrix_value ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
-  BOOL_OP (>, boolMatrix (), boolMatrix ());
+  return mx_el_gt (v1.matrix_value (), v2.matrix_value ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
-  BOOL_OP (!=, 1.0, 0.0);
+  return mx_el_ne (v1.matrix_value (), v2.matrix_value ());
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
   return octave_value (product (v1.matrix_value (), v2.matrix_value ()));
@@ -172,31 +166,25 @@ el_ldiv (const octave_value& a1, const o
   return octave_value (quotient (v2.matrix_value (), v1.matrix_value ()));
 }
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
-  MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (),
-		 Matrix, m2, v2.matrix_value (),
-		 m1 (i, j) && m2 (i, j), "&",
-		 boolMatrix (), boolMatrix ());
+  return mx_el_and (v1.matrix_value (), v2.matrix_value ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
-  MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (),
-		 Matrix, m2, v2.matrix_value (),
-		 m1 (i, j) || m2 (i, j), "|",
-		 boolMatrix (), boolMatrix ());
+  return mx_el_or (v1.matrix_value (), v2.matrix_value ());
 }
 
 static octave_value
 assign (octave_value& a1, const octave_value_list& idx,
 	const octave_value& a2)
 {
   CAST_BINOP_ARGS (octave_matrix&, const octave_matrix&);
 
diff --git a/src/op-m-s.cc b/src/op-m-s.cc
--- a/src/op-m-s.cc
+++ b/src/op-m-s.cc
@@ -87,67 +87,62 @@ pow (const octave_value& a1, const octav
 
 static octave_value
 ldiv (const octave_value& v1, const octave_value&)
 {
   gripe_nonconformant ("operator \\", v1.rows (), v1.columns (), 1, 1);
   return octave_value ();
 }
 
-#define BOOL_OP(OP, EMPTY_RESULT) \
-  MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (), \
-		 double, s, v2.double_value (), \
-		 m (i, j) OP s, EMPTY_RESULT)
-
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
-  BOOL_OP (<, boolMatrix ());
+  return mx_el_lt (v1.matrix_value (), v2.double_value ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
-  BOOL_OP (<=, boolMatrix ());
+  return mx_el_le (v1.matrix_value (), v2.double_value ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
-  BOOL_OP (==, 0.0);
+  return mx_el_eq (v1.matrix_value (), v2.double_value ());
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
-  BOOL_OP (>=, boolMatrix ());
+  return mx_el_ge (v1.matrix_value (), v2.double_value ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
-  BOOL_OP (>, boolMatrix ());
+  return mx_el_gt (v1.matrix_value (), v2.double_value ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
-  BOOL_OP (!=, 1.0);
+  return mx_el_ne (v1.matrix_value (), v2.double_value ());
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
   return octave_value (v1.matrix_value () * v2.double_value ());
@@ -182,29 +177,25 @@ el_ldiv (const octave_value& a1, const o
   return x_el_div (v2.double_value (), v1.matrix_value ());
 }
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
-  MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (),
-                 double, s, v2.double_value (),
-		 m (i, j) && s, boolMatrix ());
+  return mx_el_and (v1.matrix_value (), v2.double_value ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
-  MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (),
-                 double, s, v2.double_value (),
-		 m (i, j) || s, boolMatrix ());
+  return mx_el_or (v1.matrix_value (), v2.double_value ());
 }
 
 static octave_value
 assign (octave_value& a1, const octave_value_list& idx,
 	const octave_value& a2)
 {
   CAST_BINOP_ARGS (octave_matrix&, const octave_scalar&);
 
diff --git a/src/op-s-cm.cc b/src/op-s-cm.cc
--- a/src/op-s-cm.cc
+++ b/src/op-s-cm.cc
@@ -89,71 +89,62 @@ ldiv (const octave_value& a1, const octa
   double d = v1.double_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.complex_matrix_value () / d);
 }
 
-#define BOOL_OP(OP, EMPTY_RESULT) \
-  SC_MX_BOOL_OP (double, s, v1.double_value (), \
-		 ComplexMatrix, m, v2.complex_matrix_value (), \
-		 s OP real (m (i, j)), EMPTY_RESULT)
-
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
-  BOOL_OP (<, boolMatrix ());
+  return mx_el_lt (v1.double_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
-  BOOL_OP (<=, boolMatrix ());
+  return mx_el_le (v1.double_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
-  SC_MX_BOOL_OP (double, s, v1.double_value (),
-		 ComplexMatrix, m, v2.complex_matrix_value (),
-		 s == m (i, j), 0.0);
+  return mx_el_eq (v1.double_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
-  BOOL_OP (>=, boolMatrix ());
+  return mx_el_ge (v1.double_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
-  BOOL_OP (>, boolMatrix ());
+  return mx_el_gt (v1.double_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
-  SC_MX_BOOL_OP (double, s, v1.double_value (),
-		 ComplexMatrix, m, v2.complex_matrix_value (),
-		 s != m (i, j), 1.0);
+  return mx_el_ne (v1.double_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
   return octave_value (v1.double_value () * v2.complex_matrix_value ());
@@ -188,29 +179,25 @@ el_ldiv (const octave_value& a1, const o
   return octave_value (v2.complex_matrix_value () / d);
 }
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
-  SC_MX_BOOL_OP (double, s, v1.double_value (),
-		 ComplexMatrix, m, v2.complex_matrix_value (),
-		 s && m (i, j) != 0.0, boolMatrix ());
+  return mx_el_and (v1.double_value (), v2.complex_matrix_value ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
-  SC_MX_BOOL_OP (double, s, v1.double_value (),
-		 ComplexMatrix, m, v2.complex_matrix_value (),
-		 s || m (i, j) != 0.0, boolMatrix ());
+  return mx_el_or (v1.double_value (), v2.complex_matrix_value ());
 }
 
 static octave_value *
 complex_matrix_conv (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_scalar&);
 
   return new octave_complex_matrix (v.complex_matrix_value ());
diff --git a/src/op-s-m.cc b/src/op-s-m.cc
--- a/src/op-s-m.cc
+++ b/src/op-s-m.cc
@@ -87,67 +87,62 @@ ldiv (const octave_value& a1, const octa
   double d = v1.double_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.matrix_value () / d);
 }
 
-#define BOOL_OP(OP, EMPTY_RESULT) \
-  SC_MX_BOOL_OP (double, s, v1.double_value (), \
-		 Matrix, m, v2.matrix_value (), \
-		 s OP m (i, j), EMPTY_RESULT)
-
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
-  BOOL_OP (<, boolMatrix ());
+  return mx_el_lt (v1.double_value (), v2.matrix_value ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
-  BOOL_OP (<=, boolMatrix ());
+  return mx_el_le (v1.double_value (), v2.matrix_value ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
-  BOOL_OP (==, 0.0);
+  return mx_el_eq (v1.double_value (), v2.matrix_value ());
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
-  BOOL_OP (>=, boolMatrix ());
+  return mx_el_ge (v1.double_value (), v2.matrix_value ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
-  BOOL_OP (>, boolMatrix ());
+  return mx_el_gt (v1.double_value (), v2.matrix_value ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
-  BOOL_OP (!=, 1.0);
+  return mx_el_ne (v1.double_value (), v2.matrix_value ());
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
   return octave_value (v1.double_value () * v2.matrix_value ());
@@ -182,29 +177,25 @@ el_ldiv (const octave_value& a1, const o
   return octave_value (v2.matrix_value () / d);
 }
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
-  SC_MX_BOOL_OP (double, s, v1.double_value (),
-                 Matrix, m, v2.matrix_value (),
-		 s && m (i, j), boolMatrix ());
+  return mx_el_and (v1.double_value (), v2.matrix_value ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
-  SC_MX_BOOL_OP (double, s, v1.double_value (),
-                 Matrix, m, v2.matrix_value (),
-		 s || m (i, j), boolMatrix ());
+  return mx_el_or (v1.double_value (), v2.matrix_value ());
 }
 
 static octave_value *
 matrix_conv (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_scalar&);
 
   return new octave_matrix (v.matrix_value ());
