# HG changeset patch
# User jwe
# Date 774066691 0
#      Wed Jul 13 02:31:31 1994 +0000
# Node ID 309fc59f66ee48f0a95431af1a800bb49736d96b
# Parent  e078f05f4aacbc218fbbbe406de56f36fc845c1d
[project @ 1994-07-13 02:31:31 by jwe]

diff --git a/src/balance.cc b/src/balance.cc
--- a/src/balance.cc
+++ b/src/balance.cc
@@ -55,42 +55,45 @@ balance (const Octave_object& args, int 
   char *bal_job;
   int my_nargin;		// # args w/o optional string arg
   Octave_object retval;
 
   int nargin = args.length ();
 
   // determine if balancing option is listed
   // set my_nargin to the number of matrix inputs
-  if (args(nargin-1).const_type () == tree_constant_rep::string_constant ){
-    bal_job = args(nargin-1).string_value ();
-    my_nargin = nargin-2;
-  }
+  if (args(nargin-1).const_type () == tree_constant_rep::string_constant)
+    {
+      bal_job = args(nargin-1).string_value ();
+      my_nargin = nargin-2;
+    }
   else
-  {
-    bal_job = "B";
-    my_nargin = nargin-1;
-  }
+    {
+      bal_job = "B";
+      my_nargin = nargin-1;
+    }
 
   tree_constant arg = args(1).make_numeric ();
   int a_nr = arg.rows ();
   int a_nc = arg.columns ();
 
 // Check argument 1 dimensions.
 
   if (a_nr == 0 || a_nc == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
-	  if (flag < 0) warning ("balance: argument is empty matrix");
+	  if (flag < 0)
+	    warning ("balance: argument is empty matrix");
+
 	  Matrix m;
 	  retval.resize (2);
-	  retval(0) = tree_constant (m);
-	  retval(1) = tree_constant (m);
+	  retval(0) = m;
+	  retval(1) = m;
 	}
       else
 	error ("balance: empty matrix is invalid as argument");
 
       return retval;
     }
 
   if (a_nr != a_nc)
@@ -134,33 +137,33 @@ balance (const Octave_object& args, int 
 // Algebraic eigenvalue problem.
 
       retval.resize (nargout ? nargout : 1);
       if (arg.is_complex_type ())
 	{
 	  ComplexAEPBALANCE result (caa, bal_job);
 
 	  if (nargout == 0 || nargout == 1)
-	    retval(0) = tree_constant(result.balanced_matrix ());
+	    retval(0) = result.balanced_matrix ();
 	  else
 	    {
-	      retval(0) = tree_constant (result.balancing_matrix ());
-	      retval(1) = tree_constant (result.balanced_matrix ());
+	      retval(0) = result.balancing_matrix ();
+	      retval(1) = result.balanced_matrix ();
 	    }
 	}
       else
 	{
 	  AEPBALANCE result (aa, bal_job);
 
 	  if (nargout == 0 || nargout == 1)
-	    retval(0) = tree_constant (result.balanced_matrix ());
+	    retval(0) = result.balanced_matrix ();
 	  else
 	    {
-	      retval(0) = tree_constant (result.balancing_matrix ());
-	      retval(1) = tree_constant (result.balanced_matrix ());
+	      retval(0) = result.balancing_matrix ();
+	      retval(1) = result.balanced_matrix ();
 	    }
 	}
       break;
     case 2:
 
 // Generalized eigenvalue problem.
 
       {
@@ -192,17 +195,18 @@ balance (const Octave_object& args, int 
 	    else
 	      {
 		cbb.resize (1, 1);
 		cbb.elem (0, 0) = brg.complex_value ();
 	      }
 	  }
 	else
 	  {
-	    if (brg.is_matrix_type ()) bb = brg.matrix_value ();
+	    if (brg.is_matrix_type ())
+	      bb = brg.matrix_value ();
 	    else
 	      {
 		double d = brg.double_value ();
 		bb.resize (1, 1);
 		bb.elem (0, 0) = d;
 	      }
 	  }
   
@@ -236,51 +240,51 @@ balance (const Octave_object& args, int 
 	    cbb = result.left_balancing_matrix () * cbb
 	      * result.right_balancing_matrix ();
 
 	    switch (nargout)
 	      {
 	      case 0:
 	      case 1:
 		warning ("balance: should use two output arguments");
-		retval(0) = tree_constant (caa);
+		retval(0) = caa;
 		break;
 	      case 2:
-		retval(0) = tree_constant (caa);
-		retval(1) = tree_constant (cbb);
+		retval(0) = caa;
+		retval(1) = cbb;
 		break;
 	      case 4:
-		retval(0) = tree_constant (result.left_balancing_matrix ());
-		retval(1) = tree_constant (result.right_balancing_matrix ());
-		retval(2) = tree_constant (caa);
-		retval(3) = tree_constant (cbb);
+		retval(0) = result.left_balancing_matrix ();
+		retval(1) = result.right_balancing_matrix ();
+		retval(2) = caa;
+		retval(3) = cbb;
 		break;
 	      default:
 		error ("balance: invalid number of output arguments");
 		break;
 	      }
 	  }
 	else
 	  {
 	    switch (nargout)
 	      {
 	      case 0:
 	      case 1:
 		warning ("balance: should use two output arguments");
-		retval(0) = tree_constant (result.balanced_a_matrix ());
+		retval(0) = result.balanced_a_matrix ();
 		break;
 	      case 2:
-		retval(0) = tree_constant (result.balanced_a_matrix ());
-		retval(1) = tree_constant (result.balanced_b_matrix ());
+		retval(0) = result.balanced_a_matrix ();
+		retval(1) = result.balanced_b_matrix ();
 		break;
 	      case 4:
-		retval(0) = tree_constant (result.left_balancing_matrix ());
-		retval(1) = tree_constant (result.right_balancing_matrix ());
-		retval(2) = tree_constant (result.balanced_a_matrix ());
-		retval(3) = tree_constant (result.balanced_b_matrix ());
+		retval(0) = result.left_balancing_matrix ();
+		retval(1) = result.right_balancing_matrix ();
+		retval(2) = result.balanced_a_matrix ();
+		retval(3) = result.balanced_b_matrix ();
 		break;
 	      default:
 		error ("balance: invalid number of output arguments");
 		break;
 	      }
 	  }
       }
       break;
diff --git a/src/chol.cc b/src/chol.cc
--- a/src/chol.cc
+++ b/src/chol.cc
@@ -57,17 +57,17 @@ chol (const tree_constant& a)
   if (nr == 0 || nc == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0)
 	    gripe_empty_arg ("chol", 0);
 	  Matrix m;
-	  retval = tree_constant (m);
+	  retval = m;
 	}
       else
 	gripe_empty_arg ("chol", 1);
 
       return retval;
     }
 
   switch (tmp.const_type ())
@@ -75,40 +75,40 @@ chol (const tree_constant& a)
     case tree_constant_rep::matrix_constant:
       {
 	Matrix m = tmp.matrix_value ();
         int info;
 	CHOL fact (m, info);
         if (info != 0)
           error ("chol: matrix not positive definite");
         else
-  	  retval = tree_constant (fact.chol_matrix ());
+  	  retval = fact.chol_matrix ();
       }
       break;
     case tree_constant_rep::complex_matrix_constant:
       {
 	ComplexMatrix m = tmp.complex_matrix_value ();
         int info;
 	ComplexCHOL fact (m, info);
         if (info != 0)
           error ("chol: matrix not positive definite");
         else
-	  retval = tree_constant (fact.chol_matrix ());
+	  retval = fact.chol_matrix ();
       }
       break;
     case tree_constant_rep::scalar_constant:
       {
 	double d = tmp.double_value ();
-	retval = tree_constant (d);
+	retval = d;
       }
       break;
     case tree_constant_rep::complex_scalar_constant:
       {
 	Complex c = tmp.complex_value ();
-	retval = tree_constant (c);
+	retval = c;
       }
       break;
     default:
       break;
     }
   return retval;
 }
 
diff --git a/src/colloc.cc b/src/colloc.cc
--- a/src/colloc.cc
+++ b/src/colloc.cc
@@ -112,20 +112,20 @@ collocation_weights (const Octave_object
 
   ColumnVector r = wts.roots ();
   Matrix A = wts.first ();
   Matrix B = wts.second ();
   ColumnVector q = wts.quad_weights ();
 
   retval.resize (4);
 
-  retval(0) = tree_constant (r);
-  retval(1) = tree_constant (A);
-  retval(2) = tree_constant (B);
-  retval(3) = tree_constant (q);
+  retval(0) = r;
+  retval(1) = A;
+  retval(2) = B;
+  retval(3) = q;
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/src/dassl.cc b/src/dassl.cc
--- a/src/dassl.cc
+++ b/src/dassl.cc
@@ -63,17 +63,17 @@ dassl_user_function (const ColumnVector&
 
   int nstates = x.capacity ();
 
   assert (nstates == xdot.capacity ());
 
 //  tree_constant name (dassl_fcn->name ());
   Octave_object args (4);
 //  args(0) = name;
-  args(3) = tree_constant (t);
+  args(3) = t;
 
   if (nstates > 1)
     {
       Matrix m1 (nstates, 1);
       Matrix m2 (nstates, 1);
       for (int i = 0; i < nstates; i++)
 	{
 	  m1 (i, 0) = x.elem (i);
@@ -159,18 +159,18 @@ dassl (const Octave_object& args, int na
   Matrix deriv_output;
 
   if (crit_times_set)
     output = dae.integrate (out_times, deriv_output, crit_times);
   else
     output = dae.integrate (out_times, deriv_output);
 
   retval.resize (2);
-  retval(0) = tree_constant (output);
-  retval(1) = tree_constant (deriv_output);
+  retval(0) = output;
+  retval(1) = deriv_output;
   return retval;
 }
 
 typedef void (ODE_options::*d_set_opt_mf) (double);
 typedef double (ODE_options::*d_get_opt_mf) (void);
 
 #define MAX_TOKENS 3
 
diff --git a/src/det.cc b/src/det.cc
--- a/src/det.cc
+++ b/src/det.cc
@@ -58,17 +58,17 @@ determinant (const tree_constant& a)
       int flag = user_pref.propagate_empty_matrices;
       if (flag < 0)
 	gripe_empty_arg ("det", 0);
       else if (flag == 0)
 	gripe_empty_arg ("det", 1);
     }
 
   if (nr == 0 && nc == 0)
-    return tree_constant (1.0);
+    return 1.0;
 
   switch (tmp.const_type ())
     {
     case tree_constant_rep::matrix_constant:
       {
 	Matrix m = tmp.matrix_value ();
 	if (m.rows () == m.columns ())
 	  {
@@ -77,17 +77,17 @@ determinant (const tree_constant& a)
 	    DET det = m.determinant (info, rcond);
 	    double d = 0.0;
 	    if (info == -1)
 	      warning ("det: matrix singular to machine precision, rcond = %g",
 		       rcond);
 	    else
 	      d = det.value ();
 
-	    retval = tree_constant (d);
+	    retval = d;
 	  }
 	else
 	  gripe_square_matrix_required ("det");
       }
       break;
     case tree_constant_rep::complex_matrix_constant:
       {
 	ComplexMatrix m = tmp.complex_matrix_value ();
@@ -98,32 +98,32 @@ determinant (const tree_constant& a)
 	    ComplexDET det = m.determinant (info, rcond);
 	    Complex c = 0.0;
 	    if (info == -1)
 	      warning ("det: matrix singular to machine precision, rcond = %g",
 		       rcond);
 	    else
 	      c = det.value ();
 
-	    retval = tree_constant (c);
+	    retval = c;
 	  }
 	else
 	  gripe_square_matrix_required ("det");
       }
       break;
     case tree_constant_rep::scalar_constant:
       {
 	double d = tmp.double_value ();
-	retval = tree_constant (d);
+	retval = d;
       }
       break;
     case tree_constant_rep::complex_scalar_constant:
       {
 	Complex c = tmp.complex_value ();
-	retval = tree_constant (c);
+	retval = c;
       }
       break;
     default:
       break;
     }
   return retval;
 }
 
diff --git a/src/eig.cc b/src/eig.cc
--- a/src/eig.cc
+++ b/src/eig.cc
@@ -55,18 +55,18 @@ eig (const Octave_object& args, int narg
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0)
 	    gripe_empty_arg ("eig", 0);
 	  Matrix m;
 	  retval.resize (2);
-	  retval(0) = tree_constant (m);
-	  retval(1) = tree_constant (m);
+	  retval(0) = m;
+	  retval(1) = m;
 	}
       else
 	gripe_empty_arg ("eig", 1);
 
       return retval;
     }
 
   if (a_nr != a_nc)
@@ -101,27 +101,27 @@ eig (const Octave_object& args, int narg
     default:
       panic_impossible ();
       break;
     }
 
   if (nargout == 0 || nargout == 1)
     {
       retval.resize (1);
-      retval(0) = tree_constant (result.eigenvalues (), 1);
+      retval(0) = result.eigenvalues (), 1;
     }
   else
     {
 // Blame it on Matlab.
 
       ComplexDiagMatrix d (result.eigenvalues ());
 
       retval.resize (2);
-      retval(0) = tree_constant (result.eigenvectors ());
-      retval(1) = tree_constant (d);
+      retval(0) = result.eigenvectors ();
+      retval(1) = d;
     }
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/expm.cc b/src/expm.cc
--- a/src/expm.cc
+++ b/src/expm.cc
@@ -84,17 +84,17 @@ matrix_exp (const tree_constant& a)
   if (tmp.is_empty ())
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0)
 	    gripe_empty_arg ("expm", 0);
 	  Matrix m;
-	  retval = tree_constant (m);
+	  retval = m;
 	}
       else gripe_empty_arg ("expm", 1);
     }
   else if (tmp.rows () != tmp.columns ())
     gripe_square_matrix_required ("expm");
   else
     { 
       int i, j;
@@ -193,23 +193,23 @@ matrix_exp (const tree_constant& a)
 	    result = result * d;
 	    result = d.solve (result);
 	    result = result.transpose ();
 
 // Reverse preconditioning step 1: fix trace normalization.
 
 	    result = result * exp (trshift);
 
-	    retval = tree_constant (result);
+	    retval = result;
 	  }
 	  break;
 	case tree_constant_rep::complex_scalar_constant:
 	  {
 	    Complex c = tmp.complex_value ();
-	    retval = tree_constant (exp (c));
+	    retval = exp (c);
 	  }
 	  break;
 	case tree_constant_rep::matrix_constant:
 	  {
 
 // Compute the exponential.
 
 	    Matrix m = tmp.matrix_value ();
@@ -293,23 +293,23 @@ matrix_exp (const tree_constant& a)
 	    result = result * d;
 	    result = d.solve (result);
 	    result = result.transpose ();
 
 // Reverse preconditioning step 1: fix trace normalization.
 
 	    result = result * exp (trshift);
 
-	    retval = tree_constant (result);
+	    retval = result;
 	  }
 	  break;
 	case tree_constant_rep::scalar_constant:
 	  {
 	    double d = tmp.double_value ();
-	    retval = tree_constant (exp (d));
+	    retval = exp (d);
 	  }
 	  break;
 	default:
 	  panic_impossible();
 	  break;
 	}
     }
   return retval;
diff --git a/src/fft.cc b/src/fft.cc
--- a/src/fft.cc
+++ b/src/fft.cc
@@ -54,38 +54,38 @@ fft (const tree_constant& a)
   if (tmp.rows () == 0 || tmp.columns () == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0)
 	    gripe_empty_arg ("fft", 0);
 	  Matrix m;
-	  retval = tree_constant (m);
+	  retval = m;
 	}
       else
 	gripe_empty_arg ("fft", 1);
 
       return retval;
     }
 
   switch (tmp.const_type ())
     {
     case tree_constant_rep::matrix_constant:
       {
 	Matrix m = tmp.matrix_value ();
 	ComplexMatrix mfft = m.fourier ();
-	retval = tree_constant (mfft);
+	retval = mfft;
       }
       break;
     case tree_constant_rep::complex_matrix_constant:
       {
 	ComplexMatrix m = tmp.complex_matrix_value ();
 	ComplexMatrix mfft = m.fourier ();
-	retval = tree_constant (mfft);
+	retval = mfft;
       }
       break;
     case tree_constant_rep::scalar_constant:
     case tree_constant_rep::complex_scalar_constant:
       error ("fft: invalid scalar argument");
       break;
     default:
       panic_impossible ();
diff --git a/src/fsolve.cc b/src/fsolve.cc
--- a/src/fsolve.cc
+++ b/src/fsolve.cc
@@ -86,17 +86,17 @@ hybrd_info_to_fsolve_info (int info)
 
 ColumnVector
 fsolve_user_function (const ColumnVector& x)
 {
   ColumnVector retval;
 
   int n = x.capacity ();
 
-//  tree_constant name = tree_constant (fsolve_fcn->name ());
+//  tree_constant name = fsolve_fcn->name ();
   Octave_object args (2);
 //  args(0) = name;
 
   if (n > 1)
     {
       Matrix m (n, 1);
       for (int i = 0; i < n; i++)
 	m (i, 0) = x.elem (i);
@@ -154,23 +154,20 @@ fsolve (const Octave_object& args, int n
   foo.copy (fsolve_opts);
 
   int info;
   ColumnVector soln = foo.solve (info);
 
   info = hybrd_info_to_fsolve_info (info);
 
   retval.resize (nargout ? nargout : 1);
-  retval(0) = tree_constant (soln, 1);
+  retval(0) = soln, 1;
 
   if (nargout > 1)
-    retval(1) = tree_constant ((double) info);
-
-  if (nargout > 2)
-    retval(2) = tree_constant ();
+    retval(1) = (double) info;
 
   return retval;
 }
 
 typedef void (NLEqn_options::*d_set_opt_mf) (double);
 typedef double (NLEqn_options::*d_get_opt_mf) (void);
 
 #define MAX_TOKENS 1
diff --git a/src/givens.cc b/src/givens.cc
--- a/src/givens.cc
+++ b/src/givens.cc
@@ -115,17 +115,17 @@ givens (const Octave_object& args, int n
 	    case 1:
 	      {
 		ComplexMatrix g (2, 2);
 		g.elem (0, 0) = cc;
 		g.elem (1, 1) = cc;
 		g.elem (0, 1) = cs;
 		g.elem (1, 0) = -conj (cs);
 
-		retval(0) = tree_constant (g);
+		retval(0) = g;
 	      }
 	      break;
    
 	    case 2:		// output scalar values
 	      retval(0) = tree_constant(cc);
 	      retval(1) = tree_constant(cs);
 	      break;
 
@@ -146,23 +146,23 @@ givens (const Octave_object& args, int n
 	    case 1:
 	      {
 		Matrix g (2, 2);
 		g.elem (0, 0) = cc;
 		g.elem (1, 1) = cc;
 		g.elem (0, 1) = s;
 		g.elem (1, 0) = -s;
 
-		retval(0) = tree_constant (g);
+		retval(0) = g;
 	      }
 	      break;
    
 	    case 2:		// output scalar values
-	      retval(0) = tree_constant (cc);
-	      retval(1) = tree_constant (s);
+	      retval(0) = cc;
+	      retval(1) = s;
 	      break;
    
 	    default:
 	      error ("givens: invalid number of output arguments");
 	      break;
 	    }
 	}
     }
diff --git a/src/hess.cc b/src/hess.cc
--- a/src/hess.cc
+++ b/src/hess.cc
@@ -56,18 +56,18 @@ hess (const Octave_object& args, int nar
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0)
 	    warning ("hess: argument is empty matrix");
 	  Matrix m;
 	  retval.resize (2);
-	  retval(0) = tree_constant (m);
-	  retval(1) = tree_constant (m);
+	  retval(0) = m;
+	  retval(1) = m;
         }
       else
 	error ("hess: empty matrix is invalid as argument");
 
       return retval;
     }
 
   if (a_nr != a_nc)
@@ -85,74 +85,74 @@ hess (const Octave_object& args, int nar
       {
 	tmp = arg.matrix_value ();
 
 	HESS result (tmp);
 
 	if (nargout == 0 || nargout == 1)
 	  {
 	    retval.resize (1);
-	    retval(0) = tree_constant (result.hess_matrix ());
+	    retval(0) = result.hess_matrix ();
 	  }
         else
 	  {
 	    retval.resize (2);
-	    retval(0) = tree_constant (result.unitary_hess_matrix ());
-	    retval(1) = tree_constant (result.hess_matrix ());
+	    retval(0) = result.unitary_hess_matrix ();
+	    retval(1) = result.hess_matrix ();
           }
       }
       break;
     case tree_constant_rep::complex_matrix_constant:
       {
 	ctmp = arg.complex_matrix_value ();
 
 	ComplexHESS result (ctmp);
 
 	if (nargout == 0 || nargout == 1)
 	  {
 	    retval.resize (1);
-	    retval(0) = tree_constant (result.hess_matrix ());
+	    retval(0) = result.hess_matrix ();
 	  }
   	else
 	  {
 	    retval.resize (2);
-	    retval(0) = tree_constant (result.unitary_hess_matrix ());
-	    retval(1) = tree_constant (result.hess_matrix ());
+	    retval(0) = result.unitary_hess_matrix ();
+	    retval(1) = result.hess_matrix ();
 	  }
       }
       break;
     case tree_constant_rep::scalar_constant:
       {
 	double d = arg.double_value ();
 	if (nargout == 0 || nargout == 1)
 	  {
 	    retval.resize (1);
-	    retval(0) = tree_constant (d);
+	    retval(0) = d;
 	  }
 	else
 	  {
 	    retval.resize (2);
-	    retval(0) = tree_constant (1);
-	    retval(1) = tree_constant (d);
+	    retval(0) = 1;
+	    retval(1) = d;
 	  }
       }
       break;
     case tree_constant_rep::complex_scalar_constant:
       {
 	Complex c = arg.complex_value ();
 	if (nargout == 0 || nargout == 1)
  	  {
 	    retval.resize (1);
-	    retval(0) = tree_constant (c);
+	    retval(0) = c;
 	  }
 	else
 	  {
 	    retval.resize (2);
-	    retval(0) = tree_constant (1);
-	    retval(1) = tree_constant (c);
+	    retval(0) = 1;
+	    retval(1) = c;
 	  }
       }
       break;
     default:
       panic_impossible ();
       break;
     }
   return retval;
diff --git a/src/ifft.cc b/src/ifft.cc
--- a/src/ifft.cc
+++ b/src/ifft.cc
@@ -54,38 +54,38 @@ ifft (const tree_constant& a)
   if (tmp.rows () == 0 || tmp.columns () == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0)
 	    gripe_empty_arg ("ifft", 0);
 	  Matrix m;
-	  retval = tree_constant (m);
+	  retval = m;
 	}
       else
 	gripe_empty_arg ("ifft", 1);
 
       return retval;
     }
 
   switch (tmp.const_type ())
     {
     case tree_constant_rep::matrix_constant:
       {
 	Matrix m = tmp.matrix_value ();
 	ComplexMatrix mifft = m.ifourier ();
-	retval = tree_constant (mifft);
+	retval = mifft;
       }
       break;
     case tree_constant_rep::complex_matrix_constant:
       {
 	ComplexMatrix m = tmp.complex_matrix_value ();
 	ComplexMatrix mifft = m.ifourier ();
-	retval = tree_constant (mifft);
+	retval = mifft;
       }
       break;
     case tree_constant_rep::scalar_constant:
     case tree_constant_rep::complex_scalar_constant:
       error ("ifft: invalid scalar arguement");
       break;
     default:
       panic_impossible ();
diff --git a/src/inv.cc b/src/inv.cc
--- a/src/inv.cc
+++ b/src/inv.cc
@@ -59,66 +59,66 @@ inverse (const tree_constant& a)
       if (flag < 0)
 	gripe_empty_arg ("inverse", 0);
       else if (flag == 0)
 	gripe_empty_arg ("inverse", 1);
     }
 
   Matrix mtmp;
   if (nr == 0 && nc == 0)
-    return tree_constant (mtmp);
+    return mtmp;
 
   switch (tmp.const_type ())
     {
     case tree_constant_rep::matrix_constant:
       {
 	Matrix m = tmp.matrix_value ();
 	if (m.rows () == m.columns ())
 	  {
 	    int info;
 	    double rcond = 0.0;
 	    Matrix minv = m.inverse (info, rcond);
 	    if (info == -1)
 	      warning ("inverse: matrix singular to machine precision,\
  rcond = %g", rcond);
 	    else
-	      retval = tree_constant (minv);
+	      retval = minv;
 	  }
 	else
 	  gripe_square_matrix_required ("inverse");
       }
       break;
     case tree_constant_rep::scalar_constant:
       {
 	double d = 1.0 / tmp.double_value ();
-	retval = tree_constant (d);
+	retval = d;
       }
       break;
     case tree_constant_rep::complex_matrix_constant:
       {
 	ComplexMatrix m = tmp.complex_matrix_value ();
 	if (m.rows () == m.columns ())
 	  {
 	    int info;
 	    double rcond = 0.0;
 	    ComplexMatrix minv = m.inverse (info, rcond);
 	    if (info == -1)
 	      warning ("inverse: matrix singular to machine precision,\
  rcond = %g", rcond);
 	    else
-	      retval = tree_constant (minv);
+	      retval = minv;
 	  }
 	else
 	  gripe_square_matrix_required ("inverse");
       }
       break;
     case tree_constant_rep::complex_scalar_constant:
       {
 	Complex c = 1.0 / tmp.complex_value ();
-	retval = tree_constant (c);
+	retval = c;
       }
       break;
     default:
       break;
     }
   return retval;
 }
 
diff --git a/src/lsode.cc b/src/lsode.cc
--- a/src/lsode.cc
+++ b/src/lsode.cc
@@ -61,17 +61,17 @@ lsode_user_function (const ColumnVector&
 {
   ColumnVector retval;
 
   int nstates = x.capacity ();
 
 //  tree_constant name (lsode_fcn->name ());
   Octave_object args (3);
 //  args(0) = name;
-  args(2) = tree_constant (t);
+  args(2) = t;
 
   if (nstates > 1)
     {
       Matrix m (nstates, 1);
       for (int i = 0; i < nstates; i++)
 	m (i, 0) = x.elem (i);
       tree_constant state (m);
       args(1) = state;
@@ -142,17 +142,17 @@ lsode (const Octave_object& args, int na
   Matrix output (nsteps, nstates + 1);
 
   if (crit_times_set)
     output = ode.integrate (out_times, crit_times);
   else
     output = ode.integrate (out_times);
 
   retval.resize (1);
-  retval(0) = tree_constant (output);
+  retval(0) = output;
   return retval;
 }
 
 typedef void (ODE_options::*d_set_opt_mf) (double);
 typedef double (ODE_options::*d_get_opt_mf) (void);
 
 #define MAX_TOKENS 3
 
diff --git a/src/lu.cc b/src/lu.cc
--- a/src/lu.cc
+++ b/src/lu.cc
@@ -50,20 +50,21 @@ lu (const tree_constant& a, int nargout)
     
   if (tmp.rows () == 0 || tmp.columns () == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0)
 	    gripe_empty_arg ("lu", 0);
+
 	  Matrix m;
-	  retval(0) = tree_constant (m);
-	  retval(1) = tree_constant (m);
-	  retval(2) = tree_constant (m);
+	  retval(0) = m;
+	  retval(1) = m;
+	  retval(2) = m;
 	  return retval;
 	}
       else
 	gripe_empty_arg ("lu", 1);
     }
 
   switch (tmp.const_type ())
     {
@@ -75,25 +76,25 @@ lu (const tree_constant& a, int nargout)
 	    LU fact (m);
 	    switch (nargout)
 	      {
 	      case 1:
 	      case 2:
 		{
 		  Matrix P = fact.P ();
 		  Matrix L = P.transpose () * fact.L ();
-		  retval(0) = tree_constant (L);
-		  retval(1) = tree_constant (fact.U ());
+		  retval(0) = L;
+		  retval(1) = fact.U ();
 		}
 		break;
 	      case 3:
 	      default:
-		retval(0) = tree_constant (fact.L ());
-		retval(1) = tree_constant (fact.U ());
-		retval(2) = tree_constant (fact.P ());
+		retval(0) = fact.L ();
+		retval(1) = fact.U ();
+		retval(2) = fact.P ();
 		break;
 	      }
 	  }
 	else
 	  gripe_square_matrix_required ("lu");
       }
       break;
     case tree_constant_rep::complex_matrix_constant:
@@ -104,46 +105,46 @@ lu (const tree_constant& a, int nargout)
 	    ComplexLU fact (m);
 	    switch (nargout)
 	      {
 	      case 1:
 	      case 2:
 		{
 		  ComplexMatrix P = fact.P ();
 		  ComplexMatrix L = P.transpose () * fact.L ();
-		  retval(0) = tree_constant (L);
-		  retval(1) = tree_constant (fact.U ());
+		  retval(0) = L;
+		  retval(1) = fact.U ();
 		}
 		break;
 	      case 3:
 	      default:
-		retval(0) = tree_constant (fact.L ());
-		retval(1) = tree_constant (fact.U ());
-		retval(2) = tree_constant (fact.P ());
+		retval(0) = fact.L ();
+		retval(1) = fact.U ();
+		retval(2) = fact.P ();
 		break;
 	      }
 	  }
 	else
 	  gripe_square_matrix_required ("lu");
       }
       break;
     case tree_constant_rep::scalar_constant:
       {
 	double d = tmp.double_value ();
-	retval(0) = tree_constant (1.0);
-	retval(1) = tree_constant (d);
-	retval(2) = tree_constant (1.0);
+	retval(0) = 1.0;
+	retval(1) = d;
+	retval(2) = 1.0;
       }
       break;
     case tree_constant_rep::complex_scalar_constant:
       {
 	Complex c = tmp.complex_value ();
-	retval(0) = tree_constant (1.0);
-	retval(1) = tree_constant (c);
-	retval(2) = tree_constant (1.0);
+	retval(0) = 1.0;
+	retval(1) = c;
+	retval(2) = 1.0;
       }
       break;
     default:
       break;
     }
   return retval;
 }
 
diff --git a/src/npsol.cc b/src/npsol.cc
--- a/src/npsol.cc
+++ b/src/npsol.cc
@@ -66,25 +66,25 @@ npsol_objective_function (const ColumnVe
   int n = x.capacity ();
 
   tree_constant decision_vars;
   if (n > 1)
     {
       Matrix m (n, 1);
       for (int i = 0; i < n; i++)
 	m (i, 0) = x.elem (i);
-      decision_vars = tree_constant (m);
+      decision_vars = m;
     }
   else
     {
       double d = x.elem (0);
-      decision_vars = tree_constant (d);
+      decision_vars = d;
     }
 
-//  tree_constant name = tree_constant (npsol_objective->name ());
+//  tree_constant name = npsol_objective->name ();
   Octave_object args (2);
 //  args(0) = name;
   args(1) = decision_vars;
 
   static double retval;
   retval = 0.0;
 
   tree_constant objective_value;
@@ -143,25 +143,25 @@ npsol_constraint_function (const ColumnV
   int n = x.capacity ();
 
   tree_constant decision_vars;
   if (n > 1)
     {
       Matrix m (n, 1);
       for (int i = 0; i < n; i++)
 	m (i, 0) = x.elem (i);
-      decision_vars = tree_constant (m);
+      decision_vars = m;
     }
   else
     {
       double d = x.elem (0);
-      decision_vars = tree_constant (d);
+      decision_vars = d;
     }
 
-//  tree_constant name = tree_constant (npsol_constraints->name ());
+//  tree_constant name = npsol_constraints->name ();
   Octave_object args (2);
 //  args(0) = name;
   args(1) = decision_vars;
 
   if (npsol_constraints != (tree_fvc *)NULL)
     {
       Octave_object tmp = npsol_constraints->eval (0, 1, args);
 
@@ -469,23 +469,23 @@ Handle all of the following:
 	}
     }
 
   return retval;
 
  solved:
 
   retval.resize (nargout ? nargout : 1);
-  retval(0) = tree_constant (soln, 1);
+  retval(0) = soln, 1;
   if (nargout > 1)
-    retval(1) = tree_constant (objf);
+    retval(1) = objf;
   if (nargout > 2)
-    retval(2) = tree_constant ((double) inform);
+    retval(2) = (double) inform;
   if (nargout > 3)
-    retval(3) = tree_constant (lambda);
+    retval(3) = lambda;
 
   return retval;
 }
 
 typedef void (NPSOL_options::*d_set_opt_mf) (double);
 typedef void (NPSOL_options::*i_set_opt_mf) (int);
 typedef double (NPSOL_options::*d_get_opt_mf) (void);
 typedef int (NPSOL_options::*i_get_opt_mf) (void);
diff --git a/src/qpsol.cc b/src/qpsol.cc
--- a/src/qpsol.cc
+++ b/src/qpsol.cc
@@ -186,23 +186,23 @@ Handle all of the following:
       goto solved;
     }
 
   return retval;
 
  solved:
 
   retval.resize (nargout ? nargout : 1);
-  retval(0) = tree_constant (soln, 1);
+  retval(0) = soln, 1;
   if (nargout > 1)
-    retval(1) = tree_constant (objf);
+    retval(1) = objf;
   if (nargout > 2)
-    retval(2) = tree_constant ((double) inform);
+    retval(2) = (double) inform;
   if (nargout > 3)
-    retval(3) = tree_constant (lambda);
+    retval(3) = lambda;
 
   return retval;
 }
 
 typedef void (QPSOL_options::*d_set_opt_mf) (double);
 typedef void (QPSOL_options::*i_set_opt_mf) (int);
 typedef double (QPSOL_options::*d_get_opt_mf) (void);
 typedef int (QPSOL_options::*i_get_opt_mf) (void);
diff --git a/src/qr.cc b/src/qr.cc
--- a/src/qr.cc
+++ b/src/qr.cc
@@ -54,55 +54,55 @@ qr (const tree_constant& a, int nargout)
   if (nr == 0 || nc == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0)
 	    gripe_empty_arg ("qr", 0);
 	  Matrix m;
-	  retval(0) = tree_constant (m);
-	  retval(1) = tree_constant (m);
+	  retval(0) = m;
+	  retval(1) = m;
 	}
       else
 	gripe_empty_arg ("qr", 1);
 
       return retval;
     }
 
   switch (tmp.const_type ())
     {
     case tree_constant_rep::matrix_constant:
       {
 	Matrix m = tmp.matrix_value ();
 	QR fact (m);
-	retval(0) = tree_constant (fact.Q ());
-	retval(1) = tree_constant (fact.R ());
+	retval(0) = fact.Q ();
+	retval(1) = fact.R ();
       }
       break;
     case tree_constant_rep::complex_matrix_constant:
       {
 	ComplexMatrix m = tmp.complex_matrix_value ();
 	ComplexQR fact (m);
-	retval(0) = tree_constant (fact.Q ());
-	retval(1) = tree_constant (fact.R ());
+	retval(0) = fact.Q ();
+	retval(1) = fact.R ();
       }
       break;
     case tree_constant_rep::scalar_constant:
       {
 	double d = tmp.double_value ();
-	retval(0) = tree_constant (1.0);
-	retval(1) = tree_constant (d);
+	retval(0) = 1.0;
+	retval(1) = d;
       }
       break;
     case tree_constant_rep::complex_scalar_constant:
       {
 	Complex c = tmp.complex_value ();
-	retval(0) = tree_constant (1.0);
-	retval(1) = tree_constant (c);
+	retval(0) = 1.0;
+	retval(1) = c;
       }
       break;
     default:
       break;
     }
   return retval;
 }
 
diff --git a/src/quad.cc b/src/quad.cc
--- a/src/quad.cc
+++ b/src/quad.cc
@@ -57,20 +57,20 @@ builtin_quad_options_2 (const Octave_obj
 
 static Quad_options quad_opts;
 
 double
 quad_user_function (double x)
 {
   double retval = 0.0;
 
-//  tree_constant name = tree_constant (quad_fcn->name ());
+//  tree_constant name = quad_fcn->name ();
   Octave_object args (2);
 //  args(0) = name;
-  args(1) = tree_constant (x);
+  args(1) = x;
 
   if (quad_fcn != (tree_fvc *) NULL)
     {
       Octave_object tmp = quad_fcn->eval (0, 1, args);
 
       if (error_state)
 	{
 	  quad_integration_error = 1;  // XXX FIXME XXX
@@ -185,20 +185,20 @@ do_quad (const Octave_object& args, int 
       break;
     default:
       panic_impossible ();
       break;
     }
 
   retval.resize (4);
 
-  retval(0) = tree_constant (val);
-  retval(1) = tree_constant ((double) ier);
-  retval(2) = tree_constant ((double) nfun);
-  retval(3) = tree_constant (abserr);
+  retval(0) = val;
+  retval(1) = ier;
+  retval(2) = nfun;
+  retval(3) = abserr;
 
   return retval;
 }
 
 typedef void (Quad_options::*d_set_opt_mf) (double);
 typedef double (Quad_options::*d_get_opt_mf) (void);
 
 #define MAX_TOKENS 2
diff --git a/src/qzval.cc b/src/qzval.cc
--- a/src/qzval.cc
+++ b/src/qzval.cc
@@ -150,17 +150,17 @@ qzvalue (const Octave_object& args, int 
 		{
 
 // Finite generalized eigenvalue.
 
 		  cnt--;
 		  cx (cnt) = (alfr (i) + Im * alfi (i)) / beta (i);
 		}
 	    }
-	  retval(0)                          = tree_constant (cx);
+	  retval(0) = cx;
 	}
     }
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/rand.cc b/src/rand.cc
--- a/src/rand.cc
+++ b/src/rand.cc
@@ -149,23 +149,23 @@ rand_internal (const Octave_object& args
       switch (args(1).const_type ())
 	{
 	case tree_constant_rep::string_constant:
 	  char *s_arg = args(1).string_value ();
 	  if (strcmp (s_arg, "dist") == 0)
 	    {
 	      retval.resize (1);
 	      char *s = curr_rand_dist ();
-	      retval(0) = tree_constant (s);
+	      retval(0) = s;
 	    }
 	  else if (strcmp (s_arg, "seed") == 0)
 	    {
 	      retval.resize (1);
 	      double d = curr_rand_seed ();
-	      retval(0) = tree_constant (d);
+	      retval(0) = d;
 	    }
 	  else if (strcmp (s_arg, "uniform") == 0)
 	    current_distribution = uniform;
 	  else if (strcmp (s_arg, "normal") == 0)
 	    current_distribution = normal;
 	  else
 	    error ("rand: unrecognized string argument");
 	  break;
@@ -210,17 +210,17 @@ rand_internal (const Octave_object& args
   return retval;
 
  gen_matrix:
 
   if (n == 0 || m == 0)
     {
       retval.resize (1);
       Matrix m (0, 0);
-      retval(0) = tree_constant (m);
+      retval(0) = m;
     }
   else if (n > 0 && m > 0)
     {
       retval.resize (1);
       Matrix rand_mat (n, m);
       for (int j = 0; j < m; j++)
 	for (int i = 0; i < n; i++)
 	  {
@@ -238,17 +238,17 @@ rand_internal (const Octave_object& args
 		rand_mat.elem (i, j) = val;
 		break;
 	      default:
 		panic_impossible ();
 		break;
 	      }
 	  }
 
-      retval(0)   = tree_constant (rand_mat);
+      retval(0) = rand_mat;
     }
   else
     error ("rand: invalid negative argument");
 
   return retval;
 }
 
 /*
diff --git a/src/schur.cc b/src/schur.cc
--- a/src/schur.cc
+++ b/src/schur.cc
@@ -58,34 +58,34 @@ schur (const Octave_object& args, int na
     ord = args(2).string_value ();
 
   if (*ord != 'U' && *ord != 'A' && *ord != 'D'
       && *ord != 'u' && *ord != 'a' && *ord != 'd')
     {
       warning ("schur: incorrect ordered schur argument `%c'", *ord);
       Matrix m;
       retval.resize (2);
-      retval(0) = tree_constant (m);
-      retval(1) = tree_constant (m);
+      retval(0) = m;
+      retval(1) = m;
       return retval;
     }
   int a_nr = arg.rows ();
   int a_nc = arg.columns ();
 
   if (a_nr == 0 || a_nc == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
         {
           if (flag < 0)
             warning ("schur: argument is empty matrix");
           Matrix m;
           retval.resize (2);
-          retval(0) = tree_constant (m);
-          retval(1) = tree_constant (m);
+          retval(0) = m;
+          retval(1) = m;
         }
       else
         error ("schur: empty matrix is invalid as argument");
 
       return retval;
     }
   if (a_nr != a_nc)
     {
@@ -102,74 +102,74 @@ schur (const Octave_object& args, int na
       {
 	tmp = arg.matrix_value ();
 
 	SCHUR result (tmp,ord);
 
         if (nargout == 0 || nargout == 1)
           {
             retval.resize (1);
-            retval(0) = tree_constant (result.schur_matrix ());
+            retval(0) = result.schur_matrix ();
           }
         else
           {
             retval.resize (2);
-            retval(0) = tree_constant (result.unitary_matrix ());
-            retval(1) = tree_constant (result.schur_matrix ());
+            retval(0) = result.unitary_matrix ();
+            retval(1) = result.schur_matrix ();
           }
       }
       break;
     case tree_constant_rep::complex_matrix_constant:
       {
 	ctmp = arg.complex_matrix_value ();
 
         ComplexSCHUR result (ctmp,ord);
  
         if (nargout == 0 || nargout == 1)
           {
             retval.resize (1);
-            retval(0) = tree_constant (result.schur_matrix ());
+            retval(0) = result.schur_matrix ();
           }
         else
           {
             retval.resize (2);
-            retval(0) = tree_constant (result.unitary_matrix ());
-            retval(1) = tree_constant (result.schur_matrix ());
+            retval(0) = result.unitary_matrix ();
+            retval(1) = result.schur_matrix ();
           }
       }    
       break;
     case tree_constant_rep::scalar_constant:
       {
         double d = arg.double_value ();
         if (nargout == 0 || nargout == 1)
   	  {
 	    retval.resize (1);
-            retval(0) = tree_constant (d);
+            retval(0) = d;
           }
         else
 	  {
 	    retval.resize (2);
-	    retval(0) = tree_constant (1);
-	    retval(1) = tree_constant (d);
+	    retval(0) = 1.0;
+	    retval(1) = d;
   	  }
       }
       break;
     case tree_constant_rep::complex_scalar_constant:
       {
         Complex c = arg.complex_value ();
 	if (nargout == 0 || nargout == 1)
 	  {
 	    retval.resize (1);
-	    retval(0) = tree_constant (c);
+	    retval(0) = c;
 	  }
 	else
 	  {
 	    retval.resize (2);
-	    retval(0) = tree_constant (1);
-	    retval(1) = tree_constant (c);
+	    retval(0) = 1.0;
+	    retval(1) = c;
 	  }
       }
       break;
     default:
       panic_impossible ();
       break;    
     }
  
diff --git a/src/svd.cc b/src/svd.cc
--- a/src/svd.cc
+++ b/src/svd.cc
@@ -51,21 +51,22 @@ svd (const Octave_object& args, int narg
 
   if (arg.rows () == 0 || arg.columns () == 0)
     {
       int flag = user_pref.propagate_empty_matrices;
       if (flag != 0)
 	{
 	  if (flag < 0)
 	    gripe_empty_arg ("svd", 0);
+
 	  Matrix m;
 	  retval.resize (3);
-	  retval(0) = tree_constant (m);
-	  retval(1) = tree_constant (m);
-	  retval(2) = tree_constant (m);
+	  retval(0) = m;
+	  retval(1) = m;
+	  retval(2) = m;
 	}
       else
 	gripe_empty_arg ("svd", 1);
 
       return retval;
     }
 
   Matrix tmp;
@@ -103,19 +104,19 @@ svd (const Octave_object& args, int narg
 	if (nargout == 0 || nargout == 1)
 	  {
 	    retval.resize (1);
 	    retval(0) = tree_constant (sigma.diag (), 1);
 	  }
 	else
 	  {
 	    retval.resize (3);
-	    retval(0) = tree_constant (result.left_singular_matrix ());
-	    retval(1) = tree_constant (sigma);
-	    retval(2) = tree_constant (result.right_singular_matrix ());
+	    retval(0) = result.left_singular_matrix ();
+	    retval(1) = sigma;
+	    retval(2) = result.right_singular_matrix ();
 	  }
       }
       break;
     case tree_constant_rep::complex_scalar_constant:
     case tree_constant_rep::complex_matrix_constant:
       {
 	ComplexSVD result (ctmp);
 
@@ -124,19 +125,19 @@ svd (const Octave_object& args, int narg
 	if (nargout == 0 || nargout == 1)
 	  {
 	    retval.resize (1);
 	    retval(0) = tree_constant (sigma.diag (), 1);
 	  }
 	else
 	  {
 	    retval.resize (3);
-	    retval(0) = tree_constant (result.left_singular_matrix ());
-	    retval(1) = tree_constant (sigma);
-	    retval(2) = tree_constant (result.right_singular_matrix ());
+	    retval(0) = result.left_singular_matrix ();
+	    retval(1) = sigma;
+	    retval(2) = result.right_singular_matrix ();
 	  }
       }
       break;
     default:
       panic_impossible ();
       break;
     }
 
diff --git a/src/syl.cc b/src/syl.cc
--- a/src/syl.cc
+++ b/src/syl.cc
@@ -133,17 +133,17 @@ syl (const Octave_object& args, int narg
 	F77_FCN (ztrsyl) ("N", "N", &one, &a_rows, &b_rows,
 			  sch_a.fortran_vec (), &a_rows,
 			  sch_b.fortran_vec (), &b_rows,
 			  cx.fortran_vec (), &a_rows, &scale, &info,
 			  1L, 1L);
 
 	cx = -ua * cx * ub.hermitian ();
   
-	retval(0) = tree_constant (cx);
+	retval(0) = cx;
       }
     else
       {
 
 // Do everything in real arithmetic;
 
 	Matrix ca = arga.to_matrix ();
 	Matrix cb = argb.to_matrix ();
@@ -175,17 +175,17 @@ syl (const Octave_object& args, int narg
 			  cx.fortran_vec (), &a_rows, &scale, &info,
 			  1L, 1L);
 
 	if (info)
 	  error ("syl: trouble in dtrsyl info = %d", info);
   
 	cx = -ua*cx*ub.transpose ();
   
-	retval(0) = tree_constant (cx);
+	retval(0) = cx;
       }
     }
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
