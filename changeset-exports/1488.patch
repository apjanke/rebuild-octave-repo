# HG changeset patch
# User jwe
# Date 812155788 0
#      Tue Sep 26 22:49:48 1995 +0000
# Node ID 89c5874780671e738fc9f065521a5b384262583b
# Parent  eaf4f68d3757b37bc96d66bb51e3fcbb135059c4
[project @ 1995-09-26 22:49:48 by jwe]

diff --git a/src/balance.cc b/src/balance.cc
--- a/src/balance.cc
+++ b/src/balance.cc
@@ -38,17 +38,17 @@ Software Foundation, 59 Temple Place - S
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "utils.h"
 
-DEFUN_DLD_BUILTIN ("balance", Fbalance, Sbalance, 4, 4,
+DEFUN_DLD_BUILTIN ("balance", Fbalance, Sbalance, 11,
   "AA = balance (A [, OPT]) or [[DD,] AA] =  balance (A [, OPT])\n\
 \n\
 generalized eigenvalue problem:\n\
 \n\
   [cc, dd, aa, bb] = balance (a, b [, opt])\n\
 \n\
 where OPT is an optional single character argument as follows: \n\
 \n\
diff --git a/src/chol.cc b/src/chol.cc
--- a/src/chol.cc
+++ b/src/chol.cc
@@ -31,17 +31,17 @@ Software Foundation, 59 Temple Place - S
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "utils.h"
 
-DEFUN_DLD_BUILTIN ("chol", Fchol, Schol, 2, 1,
+DEFUN_DLD_BUILTIN ("chol", Fchol, Schol, 11,
   "R = chol (X): cholesky factorization")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 || nargout > 1)
     {
diff --git a/src/colloc.cc b/src/colloc.cc
--- a/src/colloc.cc
+++ b/src/colloc.cc
@@ -28,17 +28,17 @@ Software Foundation, 59 Temple Place - S
 #include "CollocWt.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "help.h"
 #include "tree-const.h"
 #include "utils.h"
 
-DEFUN_DLD_BUILTIN ("colloc", Fcolloc, Scolloc, 7, 4,
+DEFUN_DLD_BUILTIN ("colloc", Fcolloc, Scolloc, 10,
   "[R, A, B, Q] = colloc (N [, \"left\"] [, \"right\"]): collocation weights")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     {
diff --git a/src/dassl.cc b/src/dassl.cc
--- a/src/dassl.cc
+++ b/src/dassl.cc
@@ -98,17 +98,17 @@ dassl_user_function (const ColumnVector&
 	}
       else
 	gripe_user_supplied_eval ("dassl");
     }
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN ("dassl", Fdassl, Sdassl, 5, 2,
+DEFUN_DLD_BUILTIN ("dassl", Fdassl, Sdassl, 10,
   "dassl (\"function_name\", x_0, xdot_0, t_out)\n\
 dassl (F, X_0, XDOT_0, T_OUT, T_CRIT)\n\
 \n\
 The first argument is the name of the function to call to\n\
 compute the vector of residuals.  It must have the form\n\
 \n\
   res = f (x, xdot, t)\n\
 \n\
@@ -120,17 +120,17 @@ where x, xdot, and res are vectors, and 
 
   if (nargin < 4 || nargin > 5)
     {
       print_usage ("dassl");
       return retval;
     }
 
   dassl_fcn = is_valid_function (args(0), "dassl", 1);
-  if (! dassl_fcn || takes_correct_nargs (dassl_fcn, 3, "dassl", 1) != 1)
+  if (! dassl_fcn)
     return retval;
 
   ColumnVector state = args(1).vector_value ();
 
   if (error_state)
     {
       error ("dassl: expecting state vector as second argument");
       return retval;
@@ -310,17 +310,17 @@ show_dassl_option (const char *keyword)
       list++;
     }
 
   warning ("dassl_options: no match for `%s'", keyword);
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN ("dassl_options", Fdassl_options, Sdassl_options, -1, 1,
+DEFUN_DLD_BUILTIN ("dassl_options", Fdassl_options, Sdassl_options, 10,
   "dassl_options (KEYWORD, VALUE)\n\
 \n\
 Set or show options for dassl.  Keywords may be abbreviated\n\
 to the shortest match.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -45,32 +45,32 @@ Software Foundation, Inc.
 #ifndef MIN
 #define MIN(a,b) ((a) < (b) ? (a) : (b))
 #endif
 
 #ifndef ABS
 #define ABS(x) (((x) < 0) ? (-x) : (x))
 #endif
 
-DEFUN ("all", Fall, Sall, 1, 1,
+DEFUN ("all", Fall, Sall, 10,
   "all (X): are all elements of X nonzero?")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_defined ())
     retval = args(0).all ();
   else
     print_usage ("all");
 
   return retval;
 }
 
-DEFUN ("any", Fany, Sany, 1, 1,
+DEFUN ("any", Fany, Sany, 10,
   "any (X): are any elements of X nonzero?")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_defined ())
     retval = args(0).any ();
@@ -129,17 +129,17 @@ map (d_dd_fcn f, const Matrix& x, const 
 
   for (int j = 0; j < x_nc; j++)
     for (int i = 0; i < x_nr; i++)
       retval.elem (i, j) = f (x.elem (i, j), y.elem (i, j));
 
   return retval;
 }
 
-DEFUN ("atan2", Fatan2, Satan2, 2, 1,
+DEFUN ("atan2", Fatan2, Satan2, 10,
   "atan2 (Y, X): atan (Y / X) in range -pi to pi")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 2 && args(0).is_defined () && args(1).is_defined ())
     {
@@ -215,17 +215,17 @@ DEFUN ("atan2", Fatan2, Satan2, 2, 1,
 	error ("atan2: nonconformant matrices");
     }
   else
     print_usage ("atan2");
 
   return retval;
 }
 
-DEFUN ("cumprod", Fcumprod, Scumprod, 1, 1,
+DEFUN ("cumprod", Fcumprod, Scumprod, 10,
   "cumprod (X): cumulative products")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
@@ -252,17 +252,17 @@ DEFUN ("cumprod", Fcumprod, Scumprod, 1,
 	}
     }
   else
     print_usage ("cumprod");
 
   return retval;
 }
 
-DEFUN ("cumsum", Fcumsum, Scumsum, 1, 1,
+DEFUN ("cumsum", Fcumsum, Scumsum, 10,
   "cumsum (X): cumulative sums")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
@@ -534,34 +534,34 @@ make_diag (const tree_constant& a, const
 	gripe_wrong_type_arg ("diag", a);
     }
   else
     gripe_wrong_type_arg ("diag", a);
 
   return retval;
 }
 
-DEFUN ("diag", Fdiag, Sdiag, 2, 1,
+DEFUN ("diag", Fdiag, Sdiag, 10,
   "diag (X [,k]): form/extract diagonals")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_defined ())
     retval = make_diag (args(0));
   else if (nargin == 2 && args(0).is_defined () && args(1).is_defined ())
     retval = make_diag (args(0), args(1));
   else
     print_usage ("diag");
 
   return retval;
 }
 
-DEFUN ("prod", Fprod, Sprod, 1, 1,
+DEFUN ("prod", Fprod, Sprod, 10,
   "prod (X): products")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
@@ -588,17 +588,17 @@ DEFUN ("prod", Fprod, Sprod, 1, 1,
 	}
     }
   else
     print_usage ("prod");
 
   return retval;
 }
 
-DEFUN ("size", Fsize, Ssize, 2, 1,
+DEFUN ("size", Fsize, Ssize, 11,
   "[m, n] = size (x): return rows and columns of X\n\
 \n\
 d = size (x): return number of rows and columns of x as a row vector\n\
 \n\
 m = size (x, 1): return number of rows in x\n\
 m = size (x, 2): return number of columns in x")
 {
   Octave_object retval;
@@ -640,17 +640,17 @@ m = size (x, 2): return number of column
 	}
     }
   else
     print_usage ("size");
 
   return retval;
 }
 
-DEFUN ("sum", Fsum, Ssum, 1, 1,
+DEFUN ("sum", Fsum, Ssum, 10,
   "sum (X): sum of elements")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
@@ -677,17 +677,17 @@ DEFUN ("sum", Fsum, Ssum, 1, 1,
 	}
     }
   else
     print_usage ("sum");
 
   return retval;
 }
 
-DEFUN ("sumsq", Fsumsq, Ssumsq, 1, 1,
+DEFUN ("sumsq", Fsumsq, Ssumsq, 10,
   "sumsq (X): sum of squares of elements")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
@@ -714,17 +714,17 @@ DEFUN ("sumsq", Fsumsq, Ssumsq, 1, 1,
 	}
     }
   else
     print_usage ("sumsq");
 
   return retval;
 }
 
-DEFUN ("is_struct", Fis_struct, Sis_struct, 1, 1,
+DEFUN ("is_struct", Fis_struct, Sis_struct, 10,
   "is_struct (x): return nonzero if x is a structure")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
@@ -736,17 +736,17 @@ DEFUN ("is_struct", Fis_struct, Sis_stru
 	retval = 0.0;
     }
   else
     print_usage ("is_struct");
 
   return retval;
 }
 
-DEFUN ("struct_elements", Fstruct_elements, Sstruct_elements, 1, 1,
+DEFUN ("struct_elements", Fstruct_elements, Sstruct_elements, 10,
   "struct_elements (S)\n\
 \n\
 Return a list of the names of the elements of the structure S.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
@@ -771,17 +771,17 @@ Return a list of the names of the elemen
 	gripe_wrong_type_arg ("struct_elements", args (0));
     }
   else
     print_usage ("struct_elements");
 
   return retval;
 }
 
-DEFUN ("struct_contains", Fstruct_contains, Sstruct_contains, 1, 2,
+DEFUN ("struct_contains", Fstruct_contains, Sstruct_contains, 10,
   "struct_contains (S, NAME)\n\
 \n\
 return nonzero if S is a structure with element NAME")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
@@ -889,17 +889,17 @@ fill_matrix (const tree_constant& a, con
   if (error_state)
     return tree_constant ();
 
   Matrix m (nr, nc, val);
 
   return m;
 }
 
-DEFUN ("ones", Fones, Sones, 2, 1,
+DEFUN ("ones", Fones, Sones, 10,
   "ones (N), ones (N, M), ones (X): create a matrix of all ones")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   switch (nargin)
     {
@@ -918,17 +918,17 @@ DEFUN ("ones", Fones, Sones, 2, 1,
     default:
       print_usage ("ones");
       break;
     }
 
   return retval;
 }
 
-DEFUN ("zeros", Fzeros, Szeros, 2, 1,
+DEFUN ("zeros", Fzeros, Szeros, 10,
   "zeros (N), zeros (N, M), zeros (X): create a matrix of all zeros")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   switch (nargin)
     {
@@ -989,17 +989,17 @@ identity_matrix (const tree_constant& a,
       int n = MIN (nr, nc);
       for (int i = 0; i < n; i++)
 	m.elem (i, i) = 1.0;
     }
 
   return m;
 }
 
-DEFUN ("eye", Feye, Seye, 2, 1,
+DEFUN ("eye", Feye, Seye, 10,
   "eye (N), eye (N, M), eye (X): create an identity matrix")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   switch (nargin)
     {
@@ -1018,17 +1018,17 @@ DEFUN ("eye", Feye, Seye, 2, 1,
     default:
       print_usage ("eye");
       break;
     }
 
   return retval;
 }
 
-DEFUN ("linspace", Flinspace, Slinspace, 2, 1,
+DEFUN ("linspace", Flinspace, Slinspace, 10,
   "usage: linspace (x1, x2, n)\n\
 \n\
 Return a vector of n equally spaced points between x1 and x2\n\
 inclusive.\n\
 \n\
 If the final argument is omitted, n = 100 is assumed.\n\
 \n\
 All three arguments must be scalars.\n\
diff --git a/src/defun-dld.h b/src/defun-dld.h
--- a/src/defun-dld.h
+++ b/src/defun-dld.h
@@ -33,44 +33,44 @@ Software Foundation, 59 Temple Place - S
 // Define a builtin function that may be loaded dynamically at run
 // time.
 //
 // If Octave is not configured for dynamic linking of builtin
 // functions, this is exactly like DEFUN.
 
 #if defined (OCTAVE_LITE) && defined (MAKE_BUILTINS)
 #if defined (WITH_DLD)
-#define DEFUN_DLD_BUILTIN(name, fname, sname, nargin_max, nargout_max, doc) \
+#define DEFUN_DLD_BUILTIN(name, fname, sname, unused_arg_flags, doc) \
   BEGIN_INSTALL_BUILTIN \
-    DEFINE_FUN_STRUCT (name, 0, sname, nargin_max, nargout_max, 0, doc); \
+    DEFINE_FUN_STRUCT (name, 0, sname, unused_arg_flags, 0, doc); \
     install_builtin_function (&sname); \
   END_INSTALL_BUILTIN
 #else
-#define DEFUN_DLD_BUILTIN(name, fname, sname, nargin_max, nargout_max, doc) \
+#define DEFUN_DLD_BUILTIN(name, fname, sname, unused_arg_flags, doc) \
   BEGIN_INSTALL_BUILTIN \
     const char *sname = name " not included with --enable-lite-kernel"; \
   END_INSTALL_BUILTIN
 #endif
 #else
-#define DEFUN_DLD_BUILTIN(name, fname, sname, nargin_max, nargout_max, doc) \
-  DEFUN_INTERNAL (name, fname, sname, nargin_max, nargout_max, 0, doc)
+#define DEFUN_DLD_BUILTIN(name, fname, sname, unused_arg_flags, doc) \
+  DEFUN_INTERNAL (name, fname, sname, unused_arg_flags, 0, doc)
 #endif
 
 // Define a function that may be loaded dynamically at run time.
 //
 // If Octave is not configured for dynamic linking of builtin
 // functions, this won't do anything useful.
 //
 // The forward declaration is for the struct, the second is for the
 // definition of the function.
 
 #if ! defined (MAKE_BUILTINS)
-#define DEFUN_DLD(name, fname, sname, fsname, nargin_max, nargout_max, doc) \
+#define DEFUN_DLD(name, fname, sname, fsname, unused_arg_flags, doc) \
   DECLARE_FUN (fname); \
-  DEFINE_FUN_STRUCT (name, fname, sname, nargin_max, nargout_max, 0, doc); \
+  DEFINE_FUN_STRUCT (name, fname, sname, unused_arg_flags, 0, doc); \
   DEFINE_FUN_STRUCT_FUN (sname, fsname) \
   DECLARE_FUN (fname)
 #endif
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/src/defun-int.h b/src/defun-int.h
--- a/src/defun-int.h
+++ b/src/defun-int.h
@@ -29,69 +29,78 @@ Software Foundation, 59 Temple Place - S
 // create the buitlins.cc file.
 
 #ifdef MAKE_BUILTINS
 
 // Generate code to install name in the symbol table.  The script
 // mkdefs will create a .def file for every .cc file that uses DEFUN,
 // DEFUN_TEXT, or DEFUN_DLD.
 
-#define DEFUN_INTERNAL(name, fname, sname, nargin_max, nargout_max, \
+#define DEFUN_INTERNAL(name, fname, sname, unused_arg_flags, \
 		       is_text_fcn, doc) \
   BEGIN_INSTALL_BUILTIN \
-    extern DECLARE_FUN (fname); \
-    DEFINE_FUN_STRUCT (name, fname, sname, nargin_max, nargout_max, \
-		       is_text_fcn, doc); \
+    extern DECLARE_FUN_ ## unused_arg_flags (fname); \
+    DEFINE_FUN_STRUCT (name, fname, sname, is_text_fcn, doc); \
     install_builtin_function (&sname); \
   END_INSTALL_BUILTIN
 
 // Generate code for making another name for an existing function.
 
 #define DEFALIAS_INTERNAL(alias, name) \
   BEGIN_INSTALL_BUILTIN \
   alias_builtin (#alias, #name); \
   END_INSTALL_BUILTIN
 
 #else /* ! MAKE_BUILTINS */
 
 // Generate the first line of the function definition.  This ensures
 // that the internal functions all have the same signature.
 
-#define DEFUN_INTERNAL(name, fname, sname, nargin_max, nargout_max, \
+#define DEFUN_INTERNAL(name, fname, sname, unused_arg_flags, \
 		       is_text_fcn, doc) \
-  DECLARE_FUN (fname)
+  DECLARE_FUN_ ## unused_arg_flags (fname)
 
 // No definition is required for an alias.
 
 #define DEFALIAS_INTERNAL(name, alias)
 
 #endif /* ! MAKE_BUILTINS */
 
 // Define the structure that will be used to insert this function into
 // the symbol table.
 
-#define DEFINE_FUN_STRUCT(name, fname, sname, nargin_max, \
-			  nargout_max, is_text_fcn, doc) \
+#define DEFINE_FUN_STRUCT(name, fname, sname, is_text_fcn, doc) \
   static builtin_function sname = \
-    { name, nargin_max, nargout_max, is_text_fcn, fname, doc }
+    { name, is_text_fcn, fname, doc }
 
 #define DEFINE_FUN_STRUCT_FUN(sname, fsname) \
   builtin_function * \
   fsname (void) \
   { \
     return &sname; \
   }
 
 // Declare an internal function named fname.  This is the interface
 // used by all internal functions in Octave that are also callable
-// from the Octave language.
+// from the Octave language.  The funny suffixes are used to help us
+// avoid warnings from g++ about unused arguments.
+
+#define DECLARE_FUN_00(fname) \
+  Octave_object fname (const Octave_object&, int)
 
-#define DECLARE_FUN(fname) \
-  Octave_object \
-  fname (const Octave_object& args, int nargout)
+#define DECLARE_FUN_01(fname) \
+  Octave_object fname (const Octave_object&, int nargout)
+
+#define DECLARE_FUN_10(fname) \
+  Octave_object fname (const Octave_object& args, int)
+
+#define DECLARE_FUN_11(fname) \
+  Octave_object fname (const Octave_object& args, int nargout)
+
+#define DECLARE_FUN_(fname) DECLARE_FUN_11 (fname)
 
 // XXX FIXME XXX -- eliminate the need for these in the functions that
 // use them?
 
 #define DEFINE_ARGV(fcn_name) \
   int argc = args.length () + 1; \
   int save_argc = argc; \
   char **argv = make_argv (args, fcn_name); \
diff --git a/src/defun.h b/src/defun.h
--- a/src/defun.h
+++ b/src/defun.h
@@ -97,35 +97,38 @@ Software Foundation, 59 Temple Place - S
 //     constructed by prefixing name with the character F.
 //
 //   sname is the name of the structure that is used to hold
 //     information about the function, and that is passed to
 //     install_builtin_function to register the function in the symbol
 //     table.  By convention, it is constructed by prefixing name with
 //     the character S.
 //
-//   nargin_max is the maximum number of arguments this function can
-//     accept. XXX FIXME XXX -- is this really used now?
+//   unused_arg_flags is used to decide how to declare the function so
+//     that g++ doesn't complain about unused arguments.  It can be
+//     one of:
 //
-//   nargout_max is the maximum number of outputs this function can
-//     produce.  XXX FIXME XXX -- is this really used now?
+//     00:            Both of the arguments args and nargout are unused.
+//     10:            The argument args is unused.
+//     01:            The argument nargout is unused.
+//     11 or missing: Both of the arguments args and nargout are used.
 //
 //   doc is the simple help text for the function.
 
-#define DEFUN(name, fname, sname, nargin_max, nargout_max, doc) \
-  DEFUN_INTERNAL (name, fname, sname, nargin_max, nargout_max, 0, doc)
+#define DEFUN(name, fname, sname, unused_arg_flags, doc) \
+  DEFUN_INTERNAL (name, fname, sname, unused_arg_flags, 0, doc)
 
 // Define a builtin text-style function.
 //
 // This is like DEFUN, except that it defines a function that can be
 // called from the Octave language without using parenthesis to
 // surround the arguments). 
 
-#define DEFUN_TEXT(name, fname, sname, nargin_max, nargout_max, doc) \
-  DEFUN_INTERNAL (name, fname, sname, nargin_max, nargout_max, 1, doc)
+#define DEFUN_TEXT(name, fname, sname, unused_arg_flags, doc) \
+  DEFUN_INTERNAL (name, fname, sname, unused_arg_flags, 1, doc)
 
 // Define a mapper function.
 //
 //   name is the name of the function as a string
 //
 //   sname is the name of the structure that is used to hold
 //     information about the function, and that is passed to
 //     install_builtin_mapper to register the function in the symbol
diff --git a/src/det.cc b/src/det.cc
--- a/src/det.cc
+++ b/src/det.cc
@@ -31,17 +31,17 @@ Software Foundation, 59 Temple Place - S
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "utils.h"
 
-DEFUN_DLD_BUILTIN ("det", Fdet, Sdet, 2, 1,
+DEFUN_DLD_BUILTIN ("det", Fdet, Sdet, 10,
   "det (X): determinant of a square matrix")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -351,17 +351,17 @@ octave_change_to_directory (const char *
   if (cd_ok)
     do_external_plotter_cd (newdir);
   else
     error ("%s: %s", newdir, strerror (errno));
 
   return cd_ok;
 }
 
-DEFUN_TEXT ("cd", Fcd, Scd, 2, 1,
+DEFUN_TEXT ("cd", Fcd, Scd, 10,
   "cd [dir]\n\
 \n\
 change current working directory\n\
 if no arguments are given, the current directory is changed to the\n\
 users home directory")
 {
   Octave_object retval;
 
@@ -399,17 +399,17 @@ users home directory")
 
   return retval;
 }
 
 DEFALIAS (chdir, cd);
 
 // Get a directory listing.
 
-DEFUN_TEXT ("ls", Fls, Sls, -1, 1,
+DEFUN_TEXT ("ls", Fls, Sls, 10,
   "ls [options]\n\
 \n\
 print a directory listing")
 {
   Octave_object retval;
 
   DEFINE_ARGV("ls");
 
@@ -449,17 +449,17 @@ print a directory listing")
 
   DELETE_ARGV;
 
   return retval;
 }
 
 DEFALIAS (dir, ls);
 
-DEFUN ("pwd", Fpwd, Spwd, 1, 0,
+DEFUN ("pwd", Fpwd, Spwd, 00,
   "pwd (): print current working directory")
 {
   Octave_object retval;
   char *directory;
 
   if (verbatim_pwd)
     {
       char *buffer = new char [MAXPATHLEN];
@@ -480,17 +480,17 @@ DEFUN ("pwd", Fpwd, Spwd, 1, 0,
     {
       char *s = strconcat (directory, "\n");
       retval = s;
       delete [] s;
     }
   return retval;
 }
 
-DEFUN ("readdir", Freaddir, Sreaddir, 1, 0,
+DEFUN ("readdir", Freaddir, Sreaddir, 10,
   "readdir (NAME)\n\
 \n\
 Return an array of strings containing the list of all files in the
 named directory.  If sucessful, returns 0; otherwise an error message
 is printed.")
 {
   Octave_object retval;
   Octave_str_obj dirlist;
@@ -558,17 +558,17 @@ is printed.")
     retval(0) = dirlist;
 
   return retval;
 }
 
 // XXX FIXME XXX -- should probably also allow second arg to specify
 // mode.
 
-DEFUN ("mkdir", Fmkdir, Smkdir, 1, 0,
+DEFUN ("mkdir", Fmkdir, Smkdir, 10,
   "mkdir (NAME)\n\
 \n\
 Create the directory named by NAME.  If successful, returns 0;\n\
 otherwise prints an error message.")
 {
   Octave_object retval;
 
   int status = 0;
@@ -589,17 +589,17 @@ otherwise prints an error message.")
     print_usage ("mkdir");
 
   if (status == 0)
     retval (0) = (double) status;
 
   return retval;
 }
 
-DEFUN ("rmdir", Frmdir, Srmdir, 1, 0,
+DEFUN ("rmdir", Frmdir, Srmdir, 10,
   "rmdir (NAME)\n\
 \n\
 Remove the directory named by NAME.  If successful, returns 0;\n\
 otherwise prints an error message.")
 {
   Octave_object retval;
 
   int status = 0;
@@ -620,17 +620,17 @@ otherwise prints an error message.")
     print_usage ("rmdir");
 
   if (status == 0)
     retval (0) = (double) status;
 
   return retval;
 }
 
-DEFUN ("rename", Frename, Srename, 1, 0,
+DEFUN ("rename", Frename, Srename, 10,
   "rename (FROM, TO)\n\
 \n\
 Rename a file.  If successful, returns 0;\n\
 otherwise prints an error message and returns -1.")
 {
   Octave_object retval;
 
   int status = 0;
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -241,26 +241,28 @@ dld_octave_oct_file (const char *name)
 #endif
 
 Octave_builtin_fcn
 load_octave_builtin (const char *name)
 {
 #ifdef WITH_DLD
   return dld_octave_builtin (name);
 #else
+  (void) name;
   return 0;
 #endif
 }
 
 int
 load_octave_oct_file (const char *name)
 {
 #ifdef WITH_DLD
   return dld_octave_oct_file (name);
 #endif
+  (void) name;
   return 0;
 }
 
 void
 init_dynamic_linker (void)
 {
 #ifdef WITH_DLD
   octave_dld_init ();
diff --git a/src/eig.cc b/src/eig.cc
--- a/src/eig.cc
+++ b/src/eig.cc
@@ -30,17 +30,17 @@ Software Foundation, 59 Temple Place - S
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "utils.h"
 
-DEFUN_DLD_BUILTIN ("eig", Feig, Seig, 2, 1,
+DEFUN_DLD_BUILTIN ("eig", Feig, Seig, 11,
   "eig (X) or [V, D] = eig (X): compute eigenvalues and eigenvectors of X")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 || nargout > 2)
     {
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -167,17 +167,17 @@ panic (const char *fmt, ...)
 
   va_list args;
   va_start (args, fmt);
   verror ("panic", fmt, args);
   va_end (args);
   abort ();
 }
 
-DEFUN ("error", Ferror, Serror, 1, 1,
+DEFUN ("error", Ferror, Serror, 10,
   "error (MESSAGE): print MESSAGE and set the error state.\n\
 This should eventually take us up to the top level, possibly\n\
 printing traceback messages as we go.\n\
 \n\
 If MESSAGE ends in a newline character, traceback messages are not\n\
 printed.") 
 {
   Octave_object retval;
@@ -199,17 +199,17 @@ printed.")
 	return retval;
     }
 
   error (msg);
 
   return retval;
 }
 
-DEFUN ("warning", Fwarning, Swarning, 1, 1,
+DEFUN ("warning", Fwarning, Swarning, 10,
   "warning (MESSAGE): print a warning MESSAGE.\n\
 \n\
 See also: error")
 {
   Octave_object retval;
 
   const char *msg = "unspecified warning";
 
@@ -228,17 +228,17 @@ See also: error")
 	return retval;
     }
 
   warning (msg);
 
   return retval;
 }
 
-DEFUN ("usage", Fusage, Susage, 1, 1,
+DEFUN ("usage", Fusage, Susage, 10,
   "usage (MESSAGE): print a usage MESSAGE.\n\
 \n\
 See also: error")
 {
   Octave_object retval;
 
   const char *msg = "unknown";
 
diff --git a/src/expm.cc b/src/expm.cc
--- a/src/expm.cc
+++ b/src/expm.cc
@@ -50,17 +50,17 @@ extern "C"
 				   const int&, const double*,
 				   const int&, double*); 
 
   double F77_FCN (zlange, ZLANGE) (const char*, const int&,
 				   const int&, const Complex*,
 				   const int&, double*); 
 }
 
-DEFUN_DLD_BUILTIN ("expm", Fexpm, Sexpm, 2, 1,
+DEFUN_DLD_BUILTIN ("expm", Fexpm, Sexpm, 10,
   "expm (X): matrix exponential, e^A")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
diff --git a/src/fft.cc b/src/fft.cc
--- a/src/fft.cc
+++ b/src/fft.cc
@@ -33,17 +33,17 @@ Software Foundation, 59 Temple Place - S
 #include "gripes.h"
 #include "help.h"
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "utils.h"
 
 // This function should be merged with Fifft.
 
-DEFUN_DLD_BUILTIN ("fft", Ffft, Sfft, 3, 1,
+DEFUN_DLD_BUILTIN ("fft", Ffft, Sfft, 10,
   "fft (X [, N]): fast fourier transform of a vector")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     {
diff --git a/src/fft2.cc b/src/fft2.cc
--- a/src/fft2.cc
+++ b/src/fft2.cc
@@ -33,17 +33,17 @@ Software Foundation, 59 Temple Place - S
 #include "gripes.h"
 #include "help.h"
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "utils.h"
 
 // This function should be merged with Fifft2.
 
-DEFUN_DLD_BUILTIN ("fft2", Ffft2, Sfft2, 3, 1,
+DEFUN_DLD_BUILTIN ("fft2", Ffft2, Sfft2, 10,
   "fft2 (X [, N] [, M])\n\
 \n\
 two dimensional fast fourier transform of a vector")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -231,17 +231,17 @@ fclose_internal (const Octave_object& ar
     {
       error ("fclose: error on closing file");
       retval(0) = 0.0; // failed
     }
 
   return retval;
 }
 
-DEFUN ("fclose", Ffclose, Sfclose, 1, 1,
+DEFUN ("fclose", Ffclose, Sfclose, 10,
   "fclose (FILENAME or FILENUM):  close a file")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     print_usage ("fclose");
@@ -282,17 +282,17 @@ fflush_internal (const Octave_object& ar
     {
       error ("fflush: write error");
       retval(0) = 0.0; // failed
     }
 
   return retval;
 }
 
-DEFUN ("fflush", Ffflush, Sfflush, 1, 1,
+DEFUN ("fflush", Ffflush, Sfflush, 10,
   "fflush (FILENAME or FILENUM): flush buffered data to output file")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     print_usage ("fflush");
@@ -401,34 +401,34 @@ fgets_internal (const Octave_object& arg
   else
     retval(0) = -1.0;
 
   delete [] string;
 
   return retval;
 }
 
-DEFUN ("fgetl", Ffgetl, Sfgetl, 2, 2,
+DEFUN ("fgetl", Ffgetl, Sfgetl, 11,
   "[STRING, LENGTH] = fgetl (FILENAME or FILENUM [, LENGTH])\n\
 \n\
 read a string from a file")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     retval = fgets_internal (args, nargin, nargout, 1);
   else
     print_usage ("fgetl");
 
   return retval;
 }
 
-DEFUN ("fgets", Ffgets, Sfgets, 2, 2,
+DEFUN ("fgets", Ffgets, Sfgets, 11,
   "[STRING, LENGTH] = fgets (FILENAME or FILENUM [, LENGTH])\n\
 \n\
 read a string from a file")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
@@ -498,17 +498,17 @@ fopen_internal (const Octave_object& arg
   file_info file (file_number, name, file_ptr, mode);
   file_list.append (file);
 
   retval(0) = (double) file_number;
 
   return retval;
 }
 
-DEFUN ("fopen", Ffopen, Sfopen, 2, 1,
+DEFUN ("fopen", Ffopen, Sfopen, 10,
   "FILENUM = fopen (FILENAME, MODE): open a file\n\
 \n\
   Valid values for mode include:\n\
 \n\
    r  : open text file for reading\n\
    w  : open text file for writing; discard previous contents if any\n\
    a  : append; open or create text file for writing at end of file\n\
    r+ : open text file for update (i.e., reading and writing)\n\
@@ -548,17 +548,17 @@ freport_internal (void)
     }
 
   output_buf << "\n" << ends;
   maybe_page_output (output_buf);
 
   return retval;
 }
 
-DEFUN ("freport", Ffreport, Sfreport, 0, 1,
+DEFUN ("freport", Ffreport, Sfreport, 10,
   "freport (): list open files and their status")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     warning ("freport: ignoring extra arguments");
@@ -579,17 +579,17 @@ frewind_internal (const Octave_object& a
     {
       file_info file = file_list (p);
       rewind (file.fptr ());
     }
 
   return retval;
 }
 
-DEFUN ("frewind", Ffrewind, Sfrewind, 1, 1,
+DEFUN ("frewind", Ffrewind, Sfrewind, 10,
   "frewind (FILENAME or FILENUM): set file position at beginning of file")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     print_usage ("frewind");
@@ -675,17 +675,17 @@ fseek_internal (const Octave_object& arg
     {
       error ("fseek: file error");
       retval(0) = 0.0; // failed
     }
 
   return retval;
 }
 
-DEFUN ("fseek", Ffseek, Sfseek, 3, 1,
+DEFUN ("fseek", Ffseek, Sfseek, 10,
   "fseek (FILENAME or FILENUM, OFFSET [, ORIGIN])\n\
 \n\
 set file position for reading or writing")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
@@ -715,17 +715,17 @@ ftell_internal (const Octave_object& arg
 
       if (offset == -1L)
 	error ("ftell: write error");
     }
 
   return retval;
 }
 
-DEFUN ("ftell", Fftell, Sftell, 1, 1,
+DEFUN ("ftell", Fftell, Sftell, 10,
   "POSITION = ftell (FILENAME or FILENUM): returns the current file position")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     print_usage ("ftell");
@@ -965,17 +965,17 @@ process_printf_format (const char *s, co
  invalid_format:
   error ("%s: invalid format", type);
   return -1;
 }
 
 // Formatted printing to a file.
 
 static Octave_object
-do_printf (const char *type, const Octave_object& args, int nargout)
+do_printf (const char *type, const Octave_object& args)
 {
   Octave_object retval;
   fmt_arg_count = 0;
   const char *fmt;
   file_info file;
 
   if (strcmp (type, "fprintf") == 0)
     {
@@ -1067,61 +1067,61 @@ do_printf (const char *type, const Octav
       char *msg = output_buf.str ();
       retval(0) = msg;
       delete [] msg;
     }
 
   return retval;
 }
 
-DEFUN ("fprintf", Ffprintf, Sfprintf, -1, 1,
+DEFUN ("fprintf", Ffprintf, Sfprintf, 10,
   "fprintf (FILENAME or FILENUM, FORMAT, ...)")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin < 2)
     print_usage ("fprintf");
   else
-    retval = do_printf ("fprintf", args, nargout);
+    retval = do_printf ("fprintf", args);
 
   return retval;
 }
 
 // Formatted printing.
 
-DEFUN ("printf", Fprintf, Sprintf, -1, 1,
+DEFUN ("printf", Fprintf, Sprintf, 10,
   "printf (FORMAT, ...)")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin < 1)
     print_usage ("printf");
   else
-    retval = do_printf ("printf", args, nargout);
+    retval = do_printf ("printf", args);
 
   return retval;
 }
 
 // Formatted printing to a string.
 
-DEFUN ("sprintf", Fsprintf, Ssprintf, -1, 1,
+DEFUN ("sprintf", Fsprintf, Ssprintf, 10,
   "s = sprintf (FORMAT, ...)")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin < 1)
     print_usage ("sprintf");
   else
-    retval = do_printf ("sprintf", args, nargout);
+    retval = do_printf ("sprintf", args);
 
   return retval;
 }
 
 static int
 process_scanf_format (const char *s, ostrstream& fmt,
 		      const char *type, int nargout, FILE* fptr,
 		      Octave_object& values)
@@ -1433,51 +1433,51 @@ do_scanf (const char *type, const Octave
     }
 
   if (tmp_file_open)
     fclose (fptr);
 
   return retval;
 }
 
-DEFUN ("fscanf", Ffscanf, Sfscanf, 2, -1,
+DEFUN ("fscanf", Ffscanf, Sfscanf, 11,
   "[A, B, C, ...] = fscanf (FILENAME or FILENUM, FORMAT)")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 && nargin != 2)
     print_usage ("fscanf");
   else
     retval = do_scanf ("fscanf", args, nargout);
 
   return retval;
 }
 
 // Formatted reading.
 
-DEFUN ("scanf", Fscanf, Sscanf, 1, -1,
+DEFUN ("scanf", Fscanf, Sscanf, 11,
   "[A, B, C, ...] = scanf (FORMAT)")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     print_usage ("scanf");
   else
     retval = do_scanf ("scanf", args, nargout);
 
   return retval;
 }
 
 // Formatted reading from a string.
 
-DEFUN ("sscanf", Fsscanf, Ssscanf, 2, -1,
+DEFUN ("sscanf", Fsscanf, Ssscanf, 11,
   "[A, B, C, ...] = sscanf (STRING, FORMAT)")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin != 2)
     print_usage ("sscanf");
@@ -1691,17 +1691,17 @@ fread_internal (const Octave_object& arg
   if (nargout > 1)
     retval(1) = (double) count;
 
   retval(0) = m;
 
   return retval;
 }
 
-DEFUN ("fread", Ffread, Sfread, 3, 2,
+DEFUN ("fread", Ffread, Sfread, 11,
   "[DATA, COUNT] = fread (FILENUM, SIZE, PRECISION)\n\
 \n\
  Reads data in binary form of type PRECISION from a file.\n\
 \n\
  FILENUM   : file number from fopen\n\
  SIZE      : size specification for the Data matrix\n\
  PRECISION : type of data to read, valid types are\n\
 \n\
@@ -1734,17 +1734,17 @@ DEFUN ("fread", Ffread, Sfread, 3, 2,
 //                char, uchar, schar, short, ushort, int, uint,
 //                long, float, double
 //
 //                 Default is uchar.
 //
 //    count     : the number of elements written
 
 static Octave_object
-fwrite_internal (const Octave_object& args, int nargout)
+fwrite_internal (const Octave_object& args)
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   Pix p = file_io_get_file (args(0), "a+", "fwrite");
 
   if (! p)
@@ -1773,17 +1773,17 @@ fwrite_internal (const Octave_object& ar
       int count = m.write (file.fptr (), prec);
 
       retval(0) = (double) count;
     }
 
   return retval;
 }
 
-DEFUN ("fwrite", Ffwrite, Sfwrite, 3, 1,
+DEFUN ("fwrite", Ffwrite, Sfwrite, 10,
   "COUNT = fwrite (FILENUM, DATA, PRECISION)\n\
 \n\
  Writes data to a file in binary form of size PRECISION\n\
 \n\
  FILENUM   : file number from fopen\n\
  DATA      : matrix of elements to be written\n\
  PRECISION : type of data to read, valid types are\n\
 \n\
@@ -1794,59 +1794,59 @@ DEFUN ("fwrite", Ffwrite, Sfwrite, 3, 1,
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ("fwrite");
   else
-    retval = fwrite_internal (args, nargout);
+    retval = fwrite_internal (args);
 
   return retval;
 }
 
 // Check for an EOF condition on a file opened by fopen.
 //
 //   eof = feof (fid)
 //
 //     fid : file id from fopen
 //     eof : non zero for an end of file condition
 
 static Octave_object
-feof_internal (const Octave_object& args, int nargout)
+feof_internal (const Octave_object& args)
 {
   Octave_object retval;
 
   Pix p = return_valid_file (args(0));
 
   if (! p)
     return retval;
 
   file_info file = file_list (p);
 
   retval(0) = (double) feof (file.fptr ());
 
   return retval;
 }
 
-DEFUN ("feof", Ffeof, Sfeof, 1, 1,
+DEFUN ("feof", Ffeof, Sfeof, 10,
   "ERROR = feof (FILENAME or FILENUM)\n\
 \n\
  Returns a non zero value for an end of file condition for the\n\
  file specified by FILENAME or FILENUM from fopen")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     print_usage ("feof");
   else
-    retval = feof_internal (args, nargout);
+    retval = feof_internal (args);
 
   return retval;
 }
 
 // Check for an error condition on a file opened by fopen.
 //
 //   [message, errnum] = ferror (fid)
 //
@@ -1871,17 +1871,17 @@ ferror_internal (const Octave_object& ar
   if (nargout > 1)
     retval(1) = (double) ierr;
 
   retval(0) = strsave (strerror (ierr));
 
   return retval;
 }
 
-DEFUN ("ferror", Fferror, Sferror, 1, 1,
+DEFUN ("ferror", Fferror, Sferror, 11,
   "ERROR = ferror (FILENAME or FILENUM)\n\
 \n\
  Returns a non zero value for an error condition on the\n\
  file specified by FILENAME or FILENUM from fopen")
 {
   Octave_object retval;
 
   int nargin = args.length ();
@@ -1951,17 +1951,17 @@ popen_internal (const Octave_object& arg
   file_info file (number, name, file_ptr, mode);
   file_list.append (file);
 
   retval(0) = (double) number;
 
   return retval;
 }
 
-DEFUN ("popen", Fpopen, Spopen, 2, 1,
+DEFUN ("popen", Fpopen, Spopen, 10,
   "FILENUM = popen (FILENAME, MODE)\n\
 \n\
   start a process and create a pipe.  Valid values for mode are:\n\
 \n\
   \"r\" : connect stdout of process to pipe\n\
   \"w\" : connect stdin of process to pipe")
 {
   Octave_object retval;
@@ -2003,17 +2003,17 @@ pclose_internal (const Octave_object& ar
     {
       error ("pclose: error on closing file");
       retval(0) = 0.0; // failed
     }
 
   return retval;
 }
 
-DEFUN ("pclose", Fpclose, Spclose, 1, 1,
+DEFUN ("pclose", Fpclose, Spclose, 10,
   "pclose (FILENAME or FILENUM)\n\
 \n\
   Close a pipe and terminate the associated process")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
@@ -2021,17 +2021,17 @@ DEFUN ("pclose", Fpclose, Spclose, 1, 1,
     print_usage ("pclose");
   else
     retval = pclose_internal (args);
 
   return retval;
 }
 
 static Octave_object
-execute_internal (const Octave_object& args, int nargout)
+execute_internal (const Octave_object& args)
 {
   Octave_object retval (3, tree_constant (-1.0));
 
   pid_t pid = 0;
   int stdin_pipe[2];
   int stdout_pipe[2];
   FILE *stdin_file;
   FILE *stdout_file;
@@ -2103,29 +2103,29 @@ execute_internal (const Octave_object& a
   
   retval(2) = (double) pid;
   retval(1) = (double) new_stdout;
   retval(0) = (double) new_stdin;
 
   return retval;
 }
 
-DEFUN ("execute", Fexecute, Sexecute, 1, 3,
+DEFUN ("execute", Fexecute, Sexecute, 10,
   "[STDIN, STDOUT, PID] = execute (COMMAND)\n\
 \n\
   Start a program and redirect its stdin to STDIN and its stdout to STDOUT")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     print_usage ("execute");
   else
-    retval = execute_internal (args, nargout);
+    retval = execute_internal (args);
 
   return retval;
 }
 
 static Octave_object
 sync_system_internal (const Octave_object& args)
 {
   Octave_object retval (1, tree_constant (-1.0));
@@ -2137,17 +2137,17 @@ sync_system_internal (const Octave_objec
     }
 
   const char *name = args(0).string_value ();
 
   retval (0) = (double) system (name);
   return retval;
 }
 
-DEFUN ("sync_system", Fsync_system, Ssync_system, 1, 1,
+DEFUN ("sync_system", Fsync_system, Ssync_system, 10,
   "RETCODE = sync_system (FILENAME)\n\
 \n\
   Start a program and wait until it terminates")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
@@ -2190,17 +2190,17 @@ async_system_internal (const Octave_obje
     } 
   else
     {
       retval (0) = (double) pid;
       return retval;
     }
 }
 
-DEFUN ("async_system", Fasync_system, Sasync_system, 1, 1,
+DEFUN ("async_system", Fasync_system, Sasync_system, 10,
   "PID = async_system (FILENAME)\n\
 \n\
   Create a new process and start FILENAME")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
@@ -2249,17 +2249,17 @@ waitpid_internal (const Octave_object& a
 	  if (! error_state)
 	    retval (0) = (double) waitpid (pid, 0, options);
 	}
     }
 
   return retval;
 }
 
-DEFUN ("waitpid", Fwaitpid, Swaitpid, 1, 1,
+DEFUN ("waitpid", Fwaitpid, Swaitpid, 10,
   "STATUS = waitpid (PID, OPTIONS)\n\
 \n\
   wait for process PID to terminate\n\
 \n\
   PID can be:\n\
 \n\
      -1 : wait for any child process\n\
       0 : wait for any child process whose process group ID is equal to\n\
@@ -2314,17 +2314,17 @@ mkfifo_internal (const Octave_object& ar
 
   long mode = (long) args(1).double_value ();
 
   retval (0) = (double) mkfifo (name, mode);
 
   return retval;
 }
 
-DEFUN ("mkfifo", Fmkfifo, Smkfifo, 2, 1,
+DEFUN ("mkfifo", Fmkfifo, Smkfifo, 10,
   "STATUS = mkfifo (NAME, MODE)\n\
 \n\
   Create a FIFO special file named NAME with file mode MODE\n\
 \n\
   STATUS is:\n\
 \n\
     != 0 : if mkfifo failed\n\
        0 : if the FIFO special file could be created")
@@ -2355,17 +2355,17 @@ unlink_internal (const Octave_object& ar
 
   const char *name = args(0).string_value ();
 
   retval (0) = (double) unlink (name);
 
   return retval;
 }
 
-DEFUN ("unlink", Funlink, Sunlink, 1, 1,
+DEFUN ("unlink", Funlink, Sunlink, 10,
   "STATUS = unlink (NAME)\n\
 \n\
   Delete the file NAME\n\
 \n\
   STATUS is:\n\
 \n\
     != 0 : if unlink failed\n\
        0 : if the file could be successfully deleted")
@@ -2409,17 +2409,17 @@ mk_stat_map (struct stat& st)
 #endif
 #if defined (HAVE_ST_BLOCKS)
   m["blocks"] = (double) st.st_blocks;
 #endif
 
   return m;
 }
 
-DEFUN ("stat", Fstat, Sstat, 1, 1,
+DEFUN ("stat", Fstat, Sstat, 10,
   "stat (NAME)\n\
 \n\
   Given the name of a file, return a structure with the following
   elements:\n\
 \n\
     dev     : id of device containing a directory entry for this file\n\
     ino     : file number of the file\n\
     modestr : file mode, as a string of ten letters or dashes as in ls -l\n\
@@ -2460,17 +2460,17 @@ DEFUN ("stat", Fstat, Sstat, 1, 1,
 	}
     }
   else
     print_usage ("stat");
 
   return retval;
 }
 
-DEFUN ("lstat", Flstat, Slstat, 1, 1,
+DEFUN ("lstat", Flstat, Slstat, 10,
   "lstat (NAME)\n\
 \n\
   Like stat (NAME), but if NAME refers to a symbolic link, returns\n\
   information about the link itself, not the file that it points to.")
 {
   Octave_object retval;
 
   if (args.length () == 1)
@@ -2524,17 +2524,17 @@ convert (int x, int ibase, int obase)
 	  retval += mult * tmp;
 	  mult *= ibase;
 	}
     }
 
   return retval;
 }
 
-DEFUN ("umask", Fumask, Sumask, 2, 1,
+DEFUN ("umask", Fumask, Sumask, 10,
   "umask (MASK)\n\
 \n\
 Change the file permission mask for file creation for the current
 process.  MASK is an integer, interpreted as an octal number.  If
 successful, returns the previous value of the mask (as an integer to
 be interpreted as an octal number); otherwise an error message is
 printed.")
 {
diff --git a/src/find.cc b/src/find.cc
--- a/src/find.cc
+++ b/src/find.cc
@@ -28,17 +28,17 @@ Software Foundation, 59 Temple Place - S
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "tree-const.h"
 
 static Octave_object
 find_to_fortran_idx (const ColumnVector i_idx, const ColumnVector j_idx,
-		     const tree_constant& val, int nr, int nc, int nargout)
+		     const tree_constant& val, int nr, int nargout)
 {
   Octave_object retval;
 
   switch (nargout)
     {
     case 0:
     case 1:
       {
@@ -110,17 +110,17 @@ find_nonzero_elem_idx (const Matrix& m, 
 	    i_idx (count) = i + 1;
 	    j_idx (count) = j + 1;
 	    v (count) = d;
 	    count++;
 	  }
       }
 
   tree_constant tmp (v, 1);
-  return find_to_fortran_idx (i_idx, j_idx, tmp, m_nr, m_nc, nargout);
+  return find_to_fortran_idx (i_idx, j_idx, tmp, m_nr, nargout);
 }
 
 static Octave_object
 find_nonzero_elem_idx (const ComplexMatrix& m, int nargout)
 {
   int count = 0;
   int m_nr = m.rows ();
   int m_nc = m.columns ();
@@ -150,20 +150,20 @@ find_nonzero_elem_idx (const ComplexMatr
 	    i_idx (count) = i + 1;
 	    j_idx (count) = j + 1;
 	    v (count) = c;
 	    count++;
 	  }
       }
 
   tree_constant tmp (v, 1);
-  return find_to_fortran_idx (i_idx, j_idx, tmp, m_nr, m_nc, nargout);
+  return find_to_fortran_idx (i_idx, j_idx, tmp, m_nr, nargout);
 }
 
-DEFUN_DLD_BUILTIN ("find", Ffind, Sfind, 2, 3,
+DEFUN_DLD_BUILTIN ("find", Ffind, Sfind, 11,
   "find (X) or [I, J, V] = find (X): Return indices of nonzero elements")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 || nargout > 3)
     {
diff --git a/src/fsolve.cc b/src/fsolve.cc
--- a/src/fsolve.cc
+++ b/src/fsolve.cc
@@ -114,17 +114,17 @@ fsolve_user_function (const ColumnVector
 	}
       else
 	gripe_user_supplied_eval ("fsolve");
     }
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN ("fsolve", Ffsolve, Sfsolve, 2, 1,
+DEFUN_DLD_BUILTIN ("fsolve", Ffsolve, Sfsolve, 11,
   "Solve nonlinear equations using Minpack.  Usage:\n\
 \n\
   [X, INFO] = fsolve (F, X0)\n\
 \n\
 Where the first argument is the name of the  function to call to\n\
 compute the vector of function values.  It must have the form\n\
 \n\
   y = f (x)
@@ -137,17 +137,17 @@ where y and x are vectors.")
 
   if (nargin != 2 || nargout > 3)
     {
       print_usage ("fsolve");
       return retval;
     }
 
   fsolve_fcn = is_valid_function (args(0), "fsolve", 1);
-  if (! fsolve_fcn || takes_correct_nargs (fsolve_fcn, 1, "fsolve", 1) != 1)
+  if (! fsolve_fcn)
     return retval;
 
   ColumnVector x = args(1).vector_value ();
 
   if (error_state)
     {
       error ("fsolve: expecting vector as second argument");
       return retval;
@@ -276,17 +276,17 @@ show_fsolve_option (const char *keyword)
       list++;
     }
 
   warning ("fsolve_options: no match for `%s'", keyword);
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN ("fsolve_options", Ffsolve_options, Sfsolve_options, -1, 1,
+DEFUN_DLD_BUILTIN ("fsolve_options", Ffsolve_options, Sfsolve_options, 10,
   "fsolve_options (KEYWORD, VALUE)\n\
 \n\
 Set or show options for fsolve.  Keywords may be abbreviated\n\
 to the shortest match.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
diff --git a/src/fsqp.cc b/src/fsqp.cc
--- a/src/fsqp.cc
+++ b/src/fsqp.cc
@@ -49,22 +49,22 @@ fsqp_constraint_function (const ColumnVe
 {
   ColumnVector retval;
   return retval;
 }
 
 #endif
 
 #if defined (FSQP_MISSING)
-DEFUN_DLD_BUILTIN ("fsqp", Ffsqp, Sfsqp, 11, 3,
+DEFUN_DLD_BUILTIN ("fsqp", Ffsqp, Sfsqp, 00,
   "This function requires FSQP, which is not freely\n\
 redistributable.  For more information, read the file\n\
 libcruft/fsqp/README.MISSING in the source distribution.")
 #else
-DEFUN_DLD_BUILTIN ("fsqp", Ffsqp, Sfsqp, 11, 3,
+DEFUN_DLD_BUILTIN ("fsqp", Ffsqp, Sfsqp, 00,
   "[X, PHI] = fsqp (X, PHI [, LB, UB] [, LB, A, UB] [, LB, G, UB])\n\
 \n\
 Groups of arguments surrounded in `[]' are optional, but\n\
 must appear in the same relative order shown above.")
 #endif
 {
 /*
 
@@ -84,22 +84,22 @@ Handle all of the following:
   Octave_object retval;
 
   error ("fsqp: not implemented yet");
 
   return retval;
 }
 
 #if defined (FSQP_MISSING)
-DEFUN_DLD_BUILTIN ("fsqp_options", Ffsqp_options, Sfsqp_options, -1, 1,
+DEFUN_DLD_BUILTIN ("fsqp_options", Ffsqp_options, Sfsqp_options, 00,
   "This function requires FSQP, which is not freely\n\
 redistributable.  For more information, read the file\n\
 libcruft/fsqp/README.MISSING in the source distribution.")
 #else
-DEFUN_DLD_BUILTIN ("fsqp_options", Ffsqp_options, Sfsqp_options, -1, 1,
+DEFUN_DLD_BUILTIN ("fsqp_options", Ffsqp_options, Sfsqp_options, 00,
   "fsqp_options (KEYWORD, VALUE)\n\
 \n\
 Set or show options for fsqp.  Keywords may be abbreviated\n\
 to the shortest match.")
 #endif
 {
   Octave_object retval;
 
diff --git a/src/givens.cc b/src/givens.cc
--- a/src/givens.cc
+++ b/src/givens.cc
@@ -42,17 +42,17 @@ extern "C"
 {
   int F77_FCN (dlartg, DLARTG) (const double&, const double&, double&,
 				double&, double&);
 
   int F77_FCN (zlartg, ZLARTG) (const Complex&, const Complex&,
 				double&, Complex&, Complex&);
 }
 
-DEFUN_DLD_BUILTIN ("givens", Fgivens, Sgivens, 3, 2,
+DEFUN_DLD_BUILTIN ("givens", Fgivens, Sgivens, 11,
   "G = givens (X, Y)\n\
 \n\
 compute orthogonal matrix G = [c s; -conj (s) c]\n\
 such that G [x; y] = [*; 0]  (x, y scalars)\n\
 \n\
 [c, s] = givens (x, y) returns the (c, s) values themselves.")
 {
   Octave_object retval;
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -668,22 +668,22 @@ builtin_help (int argc, char **argv)
     }
 
   additional_help_message (output_buf);
   output_buf << ends;
   maybe_page_output (output_buf);
 }
 
 #ifdef USE_GNU_INFO
-DEFUN_TEXT ("help", Fhelp, Shelp, -1, 1,
+DEFUN_TEXT ("help", Fhelp, Shelp, 10,
   "help [-i] [topic ...]\n\
 \n\
 print cryptic yet witty messages")
 #else
-DEFUN_TEXT ("help", Fhelp, Shelp, -1, 1,
+DEFUN_TEXT ("help", Fhelp, Shelp, 10,
   "help [topic ...]\n\
 \n\
 print cryptic yet witty messages")
 #endif
 {
   Octave_object retval;
 
   DEFINE_ARGV("help");
@@ -707,17 +707,17 @@ print cryptic yet witty messages")
 	}
     }
 
   DELETE_ARGV;
 
   return retval;
 }
 
-DEFUN_TEXT ("type", Ftype, Stype, -1, 1,
+DEFUN_TEXT ("type", Ftype, Stype, 11,
   "type NAME ...]\n\
 \n\
 display the definition of each NAME that refers to a function")
 {
   Octave_object retval;
 
   DEFINE_ARGV("type");
 
@@ -848,17 +848,17 @@ display the definition of each NAME that
   else
     print_usage ("type");
 
   DELETE_ARGV;
 
   return retval;
 }
 
-DEFUN_TEXT ("which", Fwhich, Swhich, -1, 1,
+DEFUN_TEXT ("which", Fwhich, Swhich, 11,
   "which NAME ...]\n\
 \n\
 display the type of each NAME.  If NAME is defined from an function\n\
 file, print the full name of the file.")
 {
   Octave_object retval;
 
   DEFINE_ARGV("which");
diff --git a/src/hess.cc b/src/hess.cc
--- a/src/hess.cc
+++ b/src/hess.cc
@@ -31,17 +31,17 @@ Software Foundation, 59 Temple Place - S
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "utils.h"
 
-DEFUN_DLD_BUILTIN ("hess", Fhess, Shess, 2, 2,
+DEFUN_DLD_BUILTIN ("hess", Fhess, Shess, 11,
   "[P, H] = hess (A) or H = hess (A): Hessenberg decomposition")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 || nargout > 2)
     {
diff --git a/src/ifft.cc b/src/ifft.cc
--- a/src/ifft.cc
+++ b/src/ifft.cc
@@ -33,17 +33,17 @@ Software Foundation, 59 Temple Place - S
 #include "gripes.h"
 #include "help.h"
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "utils.h"
 
 // This function should be merged with Ffft.
 
-DEFUN_DLD_BUILTIN ("ifft", Fifft, Sifft, 3, 1,
+DEFUN_DLD_BUILTIN ("ifft", Fifft, Sifft, 10,
   "ifft (X [, N]): inverse fast fourier transform of a vector")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     {
diff --git a/src/ifft2.cc b/src/ifft2.cc
--- a/src/ifft2.cc
+++ b/src/ifft2.cc
@@ -33,17 +33,17 @@ Software Foundation, 59 Temple Place - S
 #include "gripes.h"
 #include "help.h"
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "utils.h"
 
 // This function should be merged with Ffft2.
 
-DEFUN_DLD_BUILTIN ("ifft2", Fifft2, Sifft2, 3, 1,
+DEFUN_DLD_BUILTIN ("ifft2", Fifft2, Sifft2, 10,
   "ifft2 (X [, N] [, M])\n\
 \n\
 two dimensional inverse fast fourier transform of a vector") 
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -154,19 +154,16 @@ int forced_interactive = 0;
 int promptflag = 1;
 
 // The current line of input, from wherever.
 char *current_input_line = 0;
 
 // A line of input from readline.
 static char *octave_gets_line = 0;
 
-extern tree_constant eval_string (const char *string, int print,
-				  int ans_assign, int& parse_status);
-
 // Append SOURCE to TARGET at INDEX.  SIZE is the current amount of
 // space allocated to TARGET.  SOURCE can be NULL, in which case
 // nothing happens.  Gets rid of SOURCE by free ()ing it.  Returns
 // TARGET in case the location has changed.
 
 static char *
 sub_append_string (char *source, char *target, int *index, int *size)
 {
@@ -847,17 +844,17 @@ command_generator (const char *text, int
 	    }
 	}
     }
 
   return 0;
 }
 
 static char **
-command_completer (char *text, int start, int end)
+command_completer (char *text, int /* start */, int /* end */)
 {
   char **matches = 0;
   matches = completion_matches (text, command_generator);
   return matches;
 }
 
 // The next two functions implement the equivalent of the K*rn shell
 // C-o operate-and-get-next-history-line editing command.  Stolen from
@@ -897,17 +894,17 @@ set_saved_history (void)
 	    }
 	}
     }
   saved_history_line_to_use = 0;
   rl_startup_hook = old_rl_startup_hook;
 }
 
 static void
-operate_and_get_next (int count, int c)
+operate_and_get_next (int /* count */, int /* c */)
 {
   int where;
 
   // Accept the current line.
 
   rl_newline ();
 
   // Find the current line, and find the next line to use.
@@ -967,17 +964,17 @@ match_sans_spaces (const char *standard,
 
   return retval;
 
 }
 
 // If the user simply hits return, this will produce an empty matrix.
 
 static Octave_object
-get_user_input (const Octave_object& args, int nargout, int debug = 0)
+get_user_input (const Octave_object& args, int debug = 0)
 {
   tree_constant retval;
 
   int nargin = args.length ();
 
   int read_as_string = 0;
 
   if (nargin == 2)
@@ -1028,17 +1025,17 @@ get_user_input (const Octave_object& arg
 	}
       else if (read_as_string)
 	{
 	  retval = input_buf;
 	}
       else
 	{
 	  int parse_status = 0;
-	  retval = eval_string (input_buf, 0, 0, parse_status);
+	  retval = eval_string (input_buf, 0, parse_status);
 	  if (retval.is_defined ())
 	    {
 	      if (debug)
 		retval.eval (1);
 	    }
 	  else
 	    retval = Matrix ();
 	}
@@ -1047,45 +1044,45 @@ get_user_input (const Octave_object& arg
     error ("input: reading user-input failed!");
 
   if (debug)
     goto again;
 
   return retval;
 }
 
-DEFUN ("input", Finput, Sinput, 2, 1,
+DEFUN ("input", Finput, Sinput, 10,
   "input (PROMPT [, S])\n\
 \n\
 Prompt user for input.  If the second argument is present, return
 value as a string.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
-    retval = get_user_input (args, nargout);
+    retval = get_user_input (args);
   else
     print_usage ("input");
 
   return retval;
 }
 
-DEFUN ("keyboard", Fkeyboard, Skeyboard, 1, 1,
+DEFUN ("keyboard", Fkeyboard, Skeyboard, 10,
   "keyboard (PROMPT)\n\
 \n\
 maybe help in debugging function files")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 0 || nargin == 1)
-    retval = get_user_input (args, nargout, 1);
+    retval = get_user_input (args, 1);
   else
     print_usage ("keyboard");
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/inv.cc b/src/inv.cc
--- a/src/inv.cc
+++ b/src/inv.cc
@@ -31,17 +31,17 @@ Software Foundation, 59 Temple Place - S
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "utils.h"
 
-DEFUN_DLD_BUILTIN ("inv", Finv, Sinv, 2, 1,
+DEFUN_DLD_BUILTIN ("inv", Finv, Sinv, 10,
   "inv (X): inverse of a square matrix")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
@@ -110,17 +110,17 @@ DEFUN_DLD_BUILTIN ("inv", Finv, Sinv, 2,
 
   return retval;
 }
 
 // XXX FIXME XXX -- this should really be done with an alias, but
 // alias_builtin() won't do the right thing if we are actually using
 // dynamic linking.
 
-DEFUN_DLD_BUILTIN ("inverse", Finverse, Sinverse, 2, 1,
+DEFUN_DLD_BUILTIN ("inverse", Finverse, Sinverse, 11,
   "inverse (X): inverse of a square matrix")
 {
   return Finv (args, nargout);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -1193,25 +1193,26 @@ match_any (char c, char *s)
 //   [ 1 + 2 ]  or  [ 1+ 2]  or  [ 1+2 ]  ==> binary
 
 static int
 looks_like_bin_op (int spc_prev, int spc_next)
 {
   return ((spc_prev && spc_next) || ! spc_prev);
 }
 
-// Duh.
-
+// Duh.  This seems to no longer be needed.
+#if 0
 static int
 next_char_is_space (void)
 {
   int c = yyinput ();
   yyunput (c, yytext);
   return (c == ' ' || c == '\t');
 }
+#endif
 
 // Try to determine if the next token should be treated as a postfix
 // unary operator.  This is ugly, but it seems to do the right thing.
 
 static int
 next_token_is_postfix_unary_op (int spc_prev, char *yytext)
 {
   int un_op = 0;
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -209,197 +209,197 @@ swap_8_bytes (char *t, int len)
 
 static void
 IEEE_big_double_to_IEEE_little_double (double *d, int len)
 {
   swap_8_bytes ((char *) d, len);
 }
 
 static void
-VAX_D_double_to_IEEE_little_double (double *d, int len)
+VAX_D_double_to_IEEE_little_double (double * /* d */, int /* len */)
 {
   gripe_data_conversion ("VAX D float", "IEEE little endian format");
 }
 
 static void
-VAX_G_double_to_IEEE_little_double (double *d, int len)
+VAX_G_double_to_IEEE_little_double (double * /* d */, int /* len */)
 {
   gripe_data_conversion ("VAX G float", "IEEE little endian format");
 }
 
 static void
-Cray_to_IEEE_little_double (double *d, int len)
+Cray_to_IEEE_little_double (double * /* d */, int /* len */)
 {
   gripe_data_conversion ("Cray", "IEEE little endian format");
 }
 
 static void
 IEEE_big_float_to_IEEE_little_float (float *d, int len)
 {
   swap_4_bytes ((char *) d, len);
 }
 
 static void
-VAX_D_float_to_IEEE_little_float (float *d, int len)
+VAX_D_float_to_IEEE_little_float (float * /* d */, int /* len */)
 {
   gripe_data_conversion ("VAX D float", "IEEE little endian format");
 }
 
 static void
-VAX_G_float_to_IEEE_little_float (float *d, int len)
+VAX_G_float_to_IEEE_little_float (float * /* d */, int /* len */)
 {
   gripe_data_conversion ("VAX G float", "IEEE little endian format");
 }
 
 static void
-Cray_to_IEEE_little_float (float *d, int len)
+Cray_to_IEEE_little_float (float * /* d */, int /* len */)
 {
   gripe_data_conversion ("Cray", "IEEE little endian format");
 }
 
 static void
 IEEE_little_double_to_IEEE_big_double (double *d, int len)
 {
   swap_8_bytes ((char *) d, len);
 }
 
 static void
-VAX_D_double_to_IEEE_big_double (double *d, int len)
+VAX_D_double_to_IEEE_big_double (double * /* d */, int /* len */)
 {
   gripe_data_conversion ("VAX D float", "IEEE big endian format");
 }
 
 static void
-VAX_G_double_to_IEEE_big_double (double *d, int len)
+VAX_G_double_to_IEEE_big_double (double * /* d */, int /* len */)
 {
   gripe_data_conversion ("VAX G float", "IEEE big endian format");
 }
 
 static void
-Cray_to_IEEE_big_double (double *d, int len)
+Cray_to_IEEE_big_double (double * /* d */, int /* len */)
 {
   gripe_data_conversion ("Cray", "IEEE big endian format");
 }
 
 static void
 IEEE_little_float_to_IEEE_big_float (float *d, int len)
 {
   swap_4_bytes ((char *) d, len);
 }
 
 static void
-VAX_D_float_to_IEEE_big_float (float *d, int len)
+VAX_D_float_to_IEEE_big_float (float * /* d */, int /* len */)
 {
   gripe_data_conversion ("VAX D float", "IEEE big endian format");
 }
 
 static void
-VAX_G_float_to_IEEE_big_float (float *d, int len)
+VAX_G_float_to_IEEE_big_float (float * /* d */, int /* len */)
 {
   gripe_data_conversion ("VAX G float", "IEEE big endian format");
 }
 
 static void
-Cray_to_IEEE_big_float (float *d, int len)
+Cray_to_IEEE_big_float (float * /* d */, int /* len */)
 {
   gripe_data_conversion ("Cray", "IEEE big endian format");
 }
 
 static void
-IEEE_little_double_to_VAX_D_double (double *d, int len)
+IEEE_little_double_to_VAX_D_double (double * /* d */, int /* len */)
 {
   gripe_data_conversion ("IEEE little endian", "VAX D");
 }
 
 static void
-IEEE_big_double_to_VAX_D_double (double *d, int len)
+IEEE_big_double_to_VAX_D_double (double * /* d */, int /* len */)
 {
   gripe_data_conversion ("IEEE big endian", "VAX D");
 }
 
 static void
-VAX_G_double_to_VAX_D_double (double *d, int len)
+VAX_G_double_to_VAX_D_double (double * /* d */, int /* len */)
 {
   gripe_data_conversion ("VAX G float", "VAX D");
 }
 
 static void
-Cray_to_VAX_D_double (double *d, int len)
+Cray_to_VAX_D_double (double * /* d */, int /* len */)
 {
   gripe_data_conversion ("Cray", "VAX D");
 }
 
 static void
-IEEE_little_float_to_VAX_D_float (float *d, int len)
+IEEE_little_float_to_VAX_D_float (float * /* d */, int /* len */)
 {
   gripe_data_conversion ("IEEE little endian", "VAX D");
 }
 
 static void
-IEEE_big_float_to_VAX_D_float (float *d, int len)
+IEEE_big_float_to_VAX_D_float (float * /* d */, int /* len */)
 {
   gripe_data_conversion ("IEEE big endian", "VAX D");
 }
 
 static void
-VAX_G_float_to_VAX_D_float (float *d, int len)
+VAX_G_float_to_VAX_D_float (float * /* d */, int /* len */)
 {
   gripe_data_conversion ("VAX G float", "VAX D");
 }
 
 static void
-Cray_to_VAX_D_float (float *d, int len)
+Cray_to_VAX_D_float (float * /* d */, int /* len */)
 {
   gripe_data_conversion ("Cray", "VAX D");
 }
 
 static void
-IEEE_little_double_to_VAX_G_double (double *d, int len)
+IEEE_little_double_to_VAX_G_double (double * /* d */, int /* len */)
 {
   gripe_data_conversion ("IEEE little endian", "VAX G");
 }
 
 static void
-IEEE_big_double_to_VAX_G_double (double *d, int len)
+IEEE_big_double_to_VAX_G_double (double * /* d */, int /* len */)
 {
   gripe_data_conversion ("IEEE big endian", "VAX G");
 }
 
 static void
-VAX_D_double_to_VAX_G_double (double *d, int len)
+VAX_D_double_to_VAX_G_double (double * /* d */, int /* len */)
 {
   gripe_data_conversion ("VAX D float", "VAX G");
 }
 
 static void
-Cray_to_VAX_G_double (double *d, int len)
+Cray_to_VAX_G_double (double * /* d */, int /* len */)
 {
   gripe_data_conversion ("VAX G float", "VAX G");
 }
 
 static void
-IEEE_little_float_to_VAX_G_float (float *d, int len)
+IEEE_little_float_to_VAX_G_float (float * /* d */, int /* len */)
 {
   gripe_data_conversion ("IEEE little endian", "VAX G");
 }
 
 static void
-IEEE_big_float_to_VAX_G_float (float *d, int len)
+IEEE_big_float_to_VAX_G_float (float * /* d */, int /* len */)
 {
   gripe_data_conversion ("IEEE big endian", "VAX G");
 }
 
 static void
-VAX_D_float_to_VAX_G_float (float *d, int len)
+VAX_D_float_to_VAX_G_float (float * /* d */, int /* len */)
 {
   gripe_data_conversion ("VAX D float", "VAX G");
 }
 
 static void
-Cray_to_VAX_G_float (float *d, int len)
+Cray_to_VAX_G_float (float * /* d */, int /* len */)
 {
   gripe_data_conversion ("VAX G float", "VAX G");
 }
 
 static void
 do_double_format_conversion (double *data, int len,
 			     floating_point_format fmt)
 {
@@ -2157,17 +2157,17 @@ do_load (istream& stream, const char *or
 	}
       else
 	maybe_page_output (output_buf);
     }
 
   return retval;
 }
 
-DEFUN_TEXT ("load", Fload, Sload, -1, 1,
+DEFUN_TEXT ("load", Fload, Sload, 11,
   "load [-force] [-ascii] [-binary] [-mat-binary] file [pattern ...]\n\
 \n\
 Load variables from a file.\n\
 \n\
 If no argument is supplied to select a format, load tries to read the
 named file as an Octave binary, then as a .mat file, and then as an
 Octave text file.\n\
 \n\
@@ -2988,17 +2988,17 @@ save_user_variables (void)
     {
       save_vars (0, 0, file, 0, format, 0);
       message (0, "save to `%s' complete", fname);
     }
   else
     warning ("unable to open `%s' for writing...", fname);
 }
 
-DEFUN_TEXT ("save", Fsave, Ssave, -1, 1,
+DEFUN_TEXT ("save", Fsave, Ssave, 10,
   "save [-ascii] [-binary] [-float-binary] [-mat-binary] \n\
      [-save-builtins] file [pattern ...]\n\
 \n\
 save variables in a file")
 {
   Octave_object retval;
 
   DEFINE_ARGV ("save");
diff --git a/src/log.cc b/src/log.cc
--- a/src/log.cc
+++ b/src/log.cc
@@ -33,17 +33,17 @@ Software Foundation, 59 Temple Place - S
 #include "help.h"
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "utils.h"
 
 // XXX FIXME XXX -- the next two functions should really be just
 // one...
 
-DEFUN_DLD_BUILTIN ("logm", Flogm, Slogm, 2, 1,
+DEFUN_DLD_BUILTIN ("logm", Flogm, Slogm, 10,
   "logm (X): matrix logarithm")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
@@ -145,17 +145,17 @@ DEFUN_DLD_BUILTIN ("logm", Flogm, Slogm,
   else
     {
       gripe_wrong_type_arg ("logm", arg);
     }
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN ("sqrtm", Fsqrtm, Ssqrtm, 2, 1,
+DEFUN_DLD_BUILTIN ("sqrtm", Fsqrtm, Ssqrtm, 10,
  "sqrtm (X): matrix sqrt")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
diff --git a/src/lpsolve.cc b/src/lpsolve.cc
--- a/src/lpsolve.cc
+++ b/src/lpsolve.cc
@@ -27,17 +27,17 @@ Software Foundation, 59 Temple Place - S
 
 #include "LPsolve.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "help.h"
 #include "tree-const.h"
 
-DEFUN_DLD_BUILTIN ("lp_solve", Flp_solve, Slp_solve, 11, 3,
+DEFUN_DLD_BUILTIN ("lp_solve", Flp_solve, Slp_solve, 00,
   "lp_solve (): solve linear programs using lp_solve.")
 {
   Octave_object retval;
 
   // Force a bad value of inform, and empty matrices for x and phi.
 
   Matrix m;
   retval(2) = -1.0;
@@ -45,17 +45,17 @@ DEFUN_DLD_BUILTIN ("lp_solve", Flp_solve
   retval(0) = m;
 
   error ("lp_solve: not implemented yet");
 
   return retval;
 }
 
 DEFUN_DLD_BUILTIN ("lp_solve_options", Flp_solve_options,
-		   Slp_solve_options, -1, 1, 
+		   Slp_solve_options, 00, 
   "lp_solve_options (KEYWORD, VALUE)\n\
 \n\
 Set or show options for lp_solve.  Keywords may be abbreviated\n\
 to the shortest match.")
 {
   Octave_object retval;
 
   error ("lp_solve_options: not implemented yet");
diff --git a/src/lsode.cc b/src/lsode.cc
--- a/src/lsode.cc
+++ b/src/lsode.cc
@@ -87,17 +87,17 @@ lsode_user_function (const ColumnVector&
 	}
       else
 	gripe_user_supplied_eval ("lsode");
     }
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN ("lsode", Flsode, Slsode, 4, 1,
+DEFUN_DLD_BUILTIN ("lsode", Flsode, Slsode, 11,
   "lsode (F, X0, T_OUT, T_CRIT)\n\
 \n\
 The first argument is the name of the function to call to\n\
 compute the vector of right hand sides.  It must have the form\n\
 \n\
   xdot = f (x, t)\n\
 \n\
 where xdot and x are vectors and t is a scalar.\n")
@@ -108,17 +108,17 @@ where xdot and x are vectors and t is a 
 
   if (nargin < 3 || nargin > 4 || nargout > 1)
     {
       print_usage ("lsode");
       return retval;
     }
 
   lsode_fcn = is_valid_function (args(0), "lsode", 1);
-  if (! lsode_fcn || takes_correct_nargs (lsode_fcn, 2, "lsode", 1) != 1)
+  if (! lsode_fcn)
     return retval;
 
   ColumnVector state = args(1).vector_value ();
 
   if (error_state)
     {
       error ("lsode: expecting state vector as second argument");
       return retval;
@@ -291,17 +291,17 @@ show_lsode_option (const char *keyword)
       list++;
     }
 
   warning ("lsode_options: no match for `%s'", keyword);
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN ("lsode_options", Flsode_options, Slsode_options, -1, 1,
+DEFUN_DLD_BUILTIN ("lsode_options", Flsode_options, Slsode_options, 10,
   "lsode_options (KEYWORD, VALUE)\n\
 \n\
 Set or show options for lsode.  Keywords may be abbreviated\n\
 to the shortest match.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
diff --git a/src/lu.cc b/src/lu.cc
--- a/src/lu.cc
+++ b/src/lu.cc
@@ -30,17 +30,17 @@ Software Foundation, 59 Temple Place - S
 
 #include "defun-dld.h"
 #include "gripes.h"
 #include "help.h"
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "utils.h"
 
-DEFUN_DLD_BUILTIN ("lu", Flu, Slu, 2, 3,
+DEFUN_DLD_BUILTIN ("lu", Flu, Slu, 11,
   "[L, U, P] = lu (A): LU factorization")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 || nargout > 3)
     {
diff --git a/src/minmax.cc b/src/minmax.cc
--- a/src/minmax.cc
+++ b/src/minmax.cc
@@ -357,17 +357,17 @@ max (const ComplexMatrix& a, const Compl
 		result.elem (i, j) = b.elem (i, j);
 	    }
 	}
     }
 
   return result;
 }
 
-DEFUN_DLD_BUILTIN ("min", Fmin, Smin, 3, 2,
+DEFUN_DLD_BUILTIN ("min", Fmin, Smin, 11,
   "min (X): minimum value(s) of a vector (matrix)")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2 || nargout > 2)
     {
@@ -585,17 +585,17 @@ DEFUN_DLD_BUILTIN ("min", Fmin, Smin, 3,
 	}
     }
   else
     panic_impossible ();
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN ("max", Fmax, Smax, 3, 2,
+DEFUN_DLD_BUILTIN ("max", Fmax, Smax, 11,
   "max (X): maximum value(s) of a vector (matrix)")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2 || nargout > 2)
     {
diff --git a/src/npsol.cc b/src/npsol.cc
--- a/src/npsol.cc
+++ b/src/npsol.cc
@@ -223,22 +223,22 @@ nonlinear_constraints_ok (const ColumnVe
 	}
     }
   return ok;
 }
 
 #endif
 
 #if defined (NPSOL_MISSING)
-DEFUN_DLD_BUILTIN ("npsol", Fnpsol, Snpsol, 10, 4,
+DEFUN_DLD_BUILTIN ("npsol", Fnpsol, Snpsol, 11,
   "This function requires NPSOL, which is not freely\n\
 redistributable.  For more information, read the file\n\
 libcruft/npsol/README.MISSING in the source distribution.")
 #else
-DEFUN_DLD_BUILTIN ("npsol", Fnpsol, Snpsol, 10, 4,
+DEFUN_DLD_BUILTIN ("npsol", Fnpsol, Snpsol, 11,
   "[X, OBJ, INFO, LAMBDA] = npsol (X, PHI [, LB, UB] [, LB, A, UB] [, LB, G, UB])\n\
 \n\
 Groups of arguments surrounded in `[]' are optional, but\n\
 must appear in the same relative order shown above.\n\
 \n\
 The second argument is a string containing the name of the objective\n\
 function to call.  The objective function must be of the form\n\
 \n\
@@ -297,18 +297,17 @@ Handle all of the following:
 
   if (error_state || x.capacity () == 0)
     {
       error ("npsol: expecting vector as first argument");
       return retval;
     }
 
   npsol_objective = is_valid_function (args(1), "npsol", 1);
-  if (! npsol_objective
-      || takes_correct_nargs (npsol_objective, 1, "npsol", 1) != 1)
+  if (! npsol_objective)
     return retval;
 
   Objective func (npsol_objective_function);
 
   ColumnVector soln;
 
   Bounds bounds;
   if (nargin == 4 || nargin == 7 || nargin == 10)
@@ -402,115 +401,109 @@ Handle all of the following:
 	      NPSOL nlp (x, func, bounds, linear_constraints);
 	      nlp.copy (npsol_opts);
 	      soln = nlp.minimize (objf, inform, lambda);
 	    }
 	  goto solved;
 	}
       else
 	{
-	  if (takes_correct_nargs (npsol_constraints, 1, "npsol", 1))
-	    {
-	      ColumnVector nlub = args(nargin-1).vector_value ();
-	      ColumnVector nllb = args(nargin-3).vector_value ();
+	  ColumnVector nlub = args(nargin-1).vector_value ();
+	  ColumnVector nllb = args(nargin-3).vector_value ();
 
-	      if (error_state
-		  || (! nonlinear_constraints_ok
-		      (x, nllb, npsol_constraint_function, nlub, "npsol", 1)))
-		return retval;
+	  if (error_state
+	      || (! nonlinear_constraints_ok
+		  (x, nllb, npsol_constraint_function, nlub, "npsol", 1)))
+	    return retval;
 
-	      NLFunc const_func (npsol_constraint_function);
-	      NLConst nonlinear_constraints (nllb, const_func, nlub);
+	  NLFunc const_func (npsol_constraint_function);
+	  NLConst nonlinear_constraints (nllb, const_func, nlub);
 
-	      if (nargin == 5)
-		{
-		  // 8. npsol (x, phi, nllb, g, nlub)
+	  if (nargin == 5)
+	    {
+	      // 8. npsol (x, phi, nllb, g, nlub)
 
-		  NPSOL nlp (x, func, nonlinear_constraints);
-		  nlp.copy (npsol_opts);
-		  soln = nlp.minimize (objf, inform, lambda);
-		}
-	      else
-		{
-		  // 5. npsol (x, phi, lb, ub, nllb, g, nlub)
+	      NPSOL nlp (x, func, nonlinear_constraints);
+	      nlp.copy (npsol_opts);
+	      soln = nlp.minimize (objf, inform, lambda);
+	    }
+	  else
+	    {
+	      // 5. npsol (x, phi, lb, ub, nllb, g, nlub)
 
-		  NPSOL nlp (x, func, bounds, nonlinear_constraints);
-		  nlp.copy (npsol_opts);
-		  soln = nlp.minimize (objf, inform, lambda);
-		}
-	      goto solved;
+	      NPSOL nlp (x, func, bounds, nonlinear_constraints);
+	      nlp.copy (npsol_opts);
+	      soln = nlp.minimize (objf, inform, lambda);
 	    }
+	  goto solved;
 	}
     }
 
   if (nargin == 8 || nargin == 10)
     {
       if (! npsol_constraints)
 	{
 	  // Produce error message.
 
 	  is_valid_function (args(nargin-2), "npsol", 1);
 	}
       else
 	{
-	  if (takes_correct_nargs (npsol_constraints, 1, "npsol", 1))
-	    {
-	      ColumnVector nlub = args(nargin-1).vector_value ();
-	      ColumnVector nllb = args(nargin-3).vector_value ();
+	  ColumnVector nlub = args(nargin-1).vector_value ();
+	  ColumnVector nllb = args(nargin-3).vector_value ();
 
-	      if (error_state
-		  || (! nonlinear_constraints_ok
-		      (x, nllb, npsol_constraint_function, nlub, "npsol", 1)))
-		return retval;
+	  if (error_state
+	      || (! nonlinear_constraints_ok
+		  (x, nllb, npsol_constraint_function, nlub, "npsol", 1)))
+	    return retval;
+
+	  NLFunc const_func (npsol_constraint_function);
+	  NLConst nonlinear_constraints (nllb, const_func, nlub);
 
-	      NLFunc const_func (npsol_constraint_function);
-	      NLConst nonlinear_constraints (nllb, const_func, nlub);
-
-	      ColumnVector lub = args(nargin-4).vector_value ();
-	      ColumnVector llb = args(nargin-6).vector_value ();
+	  ColumnVector lub = args(nargin-4).vector_value ();
+	  ColumnVector llb = args(nargin-6).vector_value ();
 
-	      if (error_state || llb.capacity () == 0 || lub.capacity () == 0)
-		{
-		  error ("npsol: bounds for linear constraints must be vectors");
-		  return retval;
-		}
+	  if (error_state || llb.capacity () == 0 || lub.capacity () == 0)
+	    {
+	      error ("npsol: bounds for linear constraints must be vectors");
+	      return retval;
+	    }
 	      
-	      Matrix c = args(nargin-5).matrix_value ();
+	  Matrix c = args(nargin-5).matrix_value ();
 
-	      if (error_state)
-		{
-		  error ("npsol: invalid linear constraint matrix");
-		  return retval;
-		}
+	  if (error_state)
+	    {
+	      error ("npsol: invalid linear constraint matrix");
+	      return retval;
+	    }
 
-	      if (! linear_constraints_ok (x, llb, c, lub, "npsol", 1))
-		return retval;
+	  if (! linear_constraints_ok (x, llb, c, lub, "npsol", 1))
+	    return retval;
 
-	      LinConst linear_constraints (llb, c, lub);
+	  LinConst linear_constraints (llb, c, lub);
 
-	      if (nargin == 8)
-		{
-		  // 6. npsol (x, phi, llb, c, lub, nllb, g, nlub)
+	  if (nargin == 8)
+	    {
+	      // 6. npsol (x, phi, llb, c, lub, nllb, g, nlub)
 
-		  NPSOL nlp (x, func, linear_constraints,
-			     nonlinear_constraints);
-		  nlp.copy (npsol_opts);
-		  soln = nlp.minimize (objf, inform, lambda);
-		}
-	      else
-		{
-		  // 4. npsol (x, phi, lb, ub, llb, c, lub, nllb, g, nlub)
+	      NPSOL nlp (x, func, linear_constraints,
+			 nonlinear_constraints);
+	      nlp.copy (npsol_opts);
+	      soln = nlp.minimize (objf, inform, lambda);
+	    }
+	  else
+	    {
+	      // 4. npsol (x, phi, lb, ub, llb, c, lub, nllb, g, nlub)
 
-		  NPSOL nlp (x, func, bounds, linear_constraints,
-			     nonlinear_constraints);
-		  nlp.copy (npsol_opts);
-		  soln = nlp.minimize (objf, inform, lambda);
-		}
-	      goto solved;
+	      NPSOL nlp (x, func, bounds, linear_constraints,
+			 nonlinear_constraints);
+	      nlp.copy (npsol_opts);
+	      soln = nlp.minimize (objf, inform, lambda);
 	    }
+	  goto solved;
 	}
     }
 
   return retval;
 
  solved:
 
   retval.resize (nargout ? nargout : 1);
@@ -771,22 +764,22 @@ show_npsol_option (const char *keyword)
   warning ("npsol_options: no match for `%s'", keyword);
 
   return retval;
 }
 
 #endif
 
 #if defined (NPSOL_MISSING)
-DEFUN_DLD_BUILTIN ("npsol_options", Fnpsol_options, Snpsol_options, -1, 1,
+DEFUN_DLD_BUILTIN ("npsol_options", Fnpsol_options, Snpsol_options, 10,
   "This function requires NPSOL, which is not freely\n\
 redistributable.  For more information, read the file\n\
 libcruft/npsol/README.MISSING in the source distribution.")
 #else
-DEFUN_DLD_BUILTIN ("npsol_options", Fnpsol_options, Snpsol_options, -1, 1,
+DEFUN_DLD_BUILTIN ("npsol_options", Fnpsol_options, Snpsol_options, 10,
   "npsol_options (KEYWORD, VALUE)\n\
 \n\
 Set or show options for npsol.  Keywords may be abbreviated\n\
 to the shortest match.")
 #endif
 {
   Octave_object retval;
 
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -631,49 +631,49 @@ current_history_number (void)
 
   if (octave_hist_size > 0)
     return history_base + where_history ();
   else
     return -1;
 
 }
 
-DEFUN_TEXT ("edit_history", Fedit_history, Sedit_history, -1, 1,
+DEFUN_TEXT ("edit_history", Fedit_history, Sedit_history, 10,
   "edit_history [first] [last]\n\
 \n\
 edit commands from the history list")
 {
   Octave_object retval;
 
   DEFINE_ARGV("edit_history");
 
   do_edit_history (argc, argv);
 
   DELETE_ARGV;
 
   return retval;
 }
 
-DEFUN_TEXT ("history", Fhistory, Shistory, -1, 1,
+DEFUN_TEXT ("history", Fhistory, Shistory, 10,
   "history [N] [-w file] [-r file] [-q]\n\
 \n\
 display, save, or load command history")
 {
   Octave_object retval;
 
   DEFINE_ARGV("history");
 
   do_history (argc, argv);
 
   DELETE_ARGV;
 
   return retval;
 }
 
-DEFUN_TEXT ("run_history", Frun_history, Srun_history, -1, 1,
+DEFUN_TEXT ("run_history", Frun_history, Srun_history, 10,
   "run_history [first] [last]\n\
 \n\
 run commands from the history list")
 {
   Octave_object retval;
 
   DEFINE_ARGV("run_history");
 
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -740,17 +740,17 @@ main (int argc, char **argv)
   while (retval == 0);
 
   if (retval == 1 && ! error_state)
     retval = 0;
 
   clean_up_and_exit (retval);
 }
 
-DEFUN_TEXT ("casesen", Fcasesen, Scasesen, 2, 1,
+DEFUN_TEXT ("casesen", Fcasesen, Scasesen, 10,
   "casesen [on|off]")
 {
   Octave_object retval;
 
   DEFINE_ARGV("casesen");
 
   if (argc == 1 || (argc > 1 && strcmp (argv[1], "off") == 0))
     warning ("casesen: sorry, Octave is always case sensitive");
@@ -759,17 +759,17 @@ DEFUN_TEXT ("casesen", Fcasesen, Scasese
   else
     print_usage ("casesen");
 
   DELETE_ARGV;
 
   return retval;
 }
 
-DEFUN ("computer", Fcomputer, Scomputer, 1, 0,
+DEFUN ("computer", Fcomputer, Scomputer, 11,
   "computer ():\n\
 \n\
 Have Octave ask the system, \"What kind of computer are you?\"")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
@@ -794,41 +794,41 @@ Have Octave ask the system, \"What kind 
       char *msg = output_buf.str ();
       retval = msg;
       delete [] msg;
     }
 
   return retval;
 }
 
-DEFUN ("flops", Fflops, Sflops, 0, 1,
+DEFUN ("flops", Fflops, Sflops, 10,
   "flops (): count floating point operations")
 {
   int nargin = args.length ();
 
   if (nargin > 0)
     print_usage ("flops");
 
   warning ("flops is a flop, always returning zero");
 
   return 0.0;
 }
 
-DEFUN ("quit", Fquit, Squit, 0, 0,
+DEFUN ("quit", Fquit, Squit, 00,
   "quit (): exit Octave gracefully")
 {
   Octave_object retval;
   quitting_gracefully = 1;
   clean_up_and_exit (0);
   return retval;
 }
 
 DEFALIAS (exit, quit);
 
-DEFUN ("warranty", Fwarranty, Swarranty, 0, 0,
+DEFUN ("warranty", Fwarranty, Swarranty, 00,
   "warranty (): describe copying conditions")
 {
   Octave_object retval;
 
   ostrstream output_buf;
   output_buf << "\n" OCTAVE_NAME_VERSION_AND_COPYRIGHT "\n\n\
 This program is free software; you can redistribute it and/or modify\n\
 it under the terms of the GNU General Public License as published by\n\
@@ -867,17 +867,17 @@ feval (const Octave_object& args, int na
       for (int i = 0; i < tmp_nargin; i++)
 	tmp_args(i) = args(i+1);
       retval = fcn->eval (0, nargout, tmp_args);
     }
 
   return retval;
 }
 
-DEFUN ("feval", Ffeval, Sfeval, -1, 1,
+DEFUN ("feval", Ffeval, Sfeval, 11,
   "feval (NAME, ARGS, ...)\n\
 \n\
 evaluate NAME as a function, passing ARGS as its arguments")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
@@ -885,18 +885,18 @@ evaluate NAME as a function, passing ARG
     retval = feval (args, nargout);
   else
     print_usage ("feval");
 
   return retval;
 }
 
 static Octave_object
-eval_string (const char *string, int print, int ans_assign,
-	     int& parse_status, int nargout)
+eval_string (const char *string, int print, int& parse_status,
+	     int nargout) 
 {
   begin_unwind_frame ("eval_string");
 
   unwind_protect_int (get_input_from_eval_string);
   unwind_protect_ptr (global_command);
   unwind_protect_ptr (current_eval_string);
 
   get_input_from_eval_string = 1;
@@ -931,23 +931,21 @@ eval_string (const char *string, int pri
       retval = command->eval (print, nargout);
       delete command;
     }
 
   return retval;
 }
 
 tree_constant
-eval_string (const char *string, int print, int ans_assign,
-	     int& parse_status)
+eval_string (const char *string, int print, int& parse_status)
 {
   tree_constant retval;
 
-  Octave_object tmp = eval_string (string, print, ans_assign,
-				   parse_status, 1);
+  Octave_object tmp = eval_string (string, print, parse_status, 1);
 
   retval = tmp(0);
 
   return retval;
 }
 
 static Octave_object
 eval_string (const tree_constant& arg, int& parse_status, int nargout)
@@ -957,20 +955,20 @@ eval_string (const tree_constant& arg, i
   if (error_state)
     {
       error ("eval: expecting string argument");
       return -1.0;
     }
 
   // Yes Virginia, we always print here...
 
-  return eval_string (string, 1, 1, parse_status, nargout);
+  return eval_string (string, 1, parse_status, nargout);
 }
 
-DEFUN ("eval", Feval, Seval, 2, 1,
+DEFUN ("eval", Feval, Seval, 11,
   "eval (TRY, CATCH)\n\
 \n\
 Evaluate the string TRY as octave code.  If that fails, evaluate the\n\
 string CATCH.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
@@ -1001,17 +999,17 @@ string CATCH.")
   else
     print_usage ("eval");
 
   return retval;
 }
 
 // Execute a shell command.
 
-DEFUN ("system", Fsystem, Ssystem, 2, 1,
+DEFUN ("system", Fsystem, Ssystem, 11,
   "system (string [, return_output]): execute shell commands")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     {
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -199,17 +199,17 @@ close_diary_file (void)
 
 void
 maybe_write_to_diary_file (const char *s)
 {
   if (write_to_diary_file && diary_stream)
     diary_stream << s;
 }
 
-DEFUN_TEXT ("diary", Fdiary, Sdiary, -1, 1,
+DEFUN_TEXT ("diary", Fdiary, Sdiary, 10,
   "diary [on|off]\n\
 diary [file]\n\
 \n\
 redirect all input and screen output to a file.")
 {
   Octave_object retval;
 
   DEFINE_ARGV ("diary");
@@ -248,17 +248,17 @@ redirect all input and screen output to 
       break;
     }
 
   DELETE_ARGV;
 
   return retval;
 }
 
-DEFUN_TEXT ("more", Fmore, Smore, -1, 1,
+DEFUN_TEXT ("more", Fmore, Smore, 10,
   "more on\n\
 more off\n\
 \n\
 Turn output pagination on or off.")
 {
   Octave_object retval;
 
   DEFINE_ARGV ("more");
diff --git a/src/pinv.cc b/src/pinv.cc
--- a/src/pinv.cc
+++ b/src/pinv.cc
@@ -31,17 +31,17 @@ Software Foundation, 59 Temple Place - S
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "utils.h"
 
-DEFUN_DLD_BUILTIN ("pinv", Fpinv, Spinv, 3, 1,
+DEFUN_DLD_BUILTIN ("pinv", Fpinv, Spinv, 10,
   "pinv ( [, tol])\n\
 Returns the pseudoinverse of X; singular values less than tol are ignored.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -867,42 +867,42 @@ union equiv
   unsigned char i[sizeof (double)];
 };
 
 #define PRINT_CHAR_BITS(os, c) \
   do \
     { \
       unsigned char ctmp = c; \
       char stmp[9]; \
-      stmp[0] = (c & 0x80) ? '1' : '0'; \
-      stmp[1] = (c & 0x40) ? '1' : '0'; \
-      stmp[2] = (c & 0x20) ? '1' : '0'; \
-      stmp[3] = (c & 0x10) ? '1' : '0'; \
-      stmp[4] = (c & 0x08) ? '1' : '0'; \
-      stmp[5] = (c & 0x04) ? '1' : '0'; \
-      stmp[6] = (c & 0x02) ? '1' : '0'; \
-      stmp[7] = (c & 0x01) ? '1' : '0'; \
+      stmp[0] = (ctmp & 0x80) ? '1' : '0'; \
+      stmp[1] = (ctmp & 0x40) ? '1' : '0'; \
+      stmp[2] = (ctmp & 0x20) ? '1' : '0'; \
+      stmp[3] = (ctmp & 0x10) ? '1' : '0'; \
+      stmp[4] = (ctmp & 0x08) ? '1' : '0'; \
+      stmp[5] = (ctmp & 0x04) ? '1' : '0'; \
+      stmp[6] = (ctmp & 0x02) ? '1' : '0'; \
+      stmp[7] = (ctmp & 0x01) ? '1' : '0'; \
       stmp[8] = '\0'; \
       os.form ("%s", stmp); \
     } \
   while (0)
 
 #define PRINT_CHAR_BITS_SWAPPED(os, c) \
   do \
     { \
       unsigned char ctmp = c; \
       char stmp[9]; \
-      stmp[0] = (c & 0x01) ? '1' : '0'; \
-      stmp[1] = (c & 0x02) ? '1' : '0'; \
-      stmp[2] = (c & 0x04) ? '1' : '0'; \
-      stmp[3] = (c & 0x08) ? '1' : '0'; \
-      stmp[4] = (c & 0x10) ? '1' : '0'; \
-      stmp[5] = (c & 0x20) ? '1' : '0'; \
-      stmp[6] = (c & 0x40) ? '1' : '0'; \
-      stmp[7] = (c & 0x80) ? '1' : '0'; \
+      stmp[0] = (ctmp & 0x01) ? '1' : '0'; \
+      stmp[1] = (ctmp & 0x02) ? '1' : '0'; \
+      stmp[2] = (ctmp & 0x04) ? '1' : '0'; \
+      stmp[3] = (ctmp & 0x08) ? '1' : '0'; \
+      stmp[4] = (ctmp & 0x10) ? '1' : '0'; \
+      stmp[5] = (ctmp & 0x20) ? '1' : '0'; \
+      stmp[6] = (ctmp & 0x40) ? '1' : '0'; \
+      stmp[7] = (ctmp & 0x80) ? '1' : '0'; \
       stmp[8] = '\0'; \
       os.form ("%s", stmp); \
     } \
   while (0)
 
 static inline void
 pr_any_float (const char *fmt, ostream& os, double d, int fw = 0)
 {
@@ -1474,17 +1474,17 @@ octave_print_internal (ostream& os, Octa
       else
 	os << s.elem (i) << "\n";
     }
 
   if (pr_as_read_syntax && nstr > 1)
     os << " ]";
 }
 
-DEFUN ("disp", Fdisp, Sdisp, 1, 1,
+DEFUN ("disp", Fdisp, Sdisp, 10,
   "disp (X): display value without name tag")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     args(0).eval (1);
@@ -1636,17 +1636,17 @@ set_format_style (int argc, char **argv)
     }
   else
     {
       init_format_state ();
       set_output_prec_and_fw (5, 10);
     }
 }
 
-DEFUN_TEXT ("format", Fformat, Sformat, -1, 1,
+DEFUN_TEXT ("format", Fformat, Sformat, 10,
   "format [style]\n\
 \n\
 set output formatting style")
 {
   Octave_object retval;
 
   DEFINE_ARGV("format");
 
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -91,17 +91,17 @@ tree_constant::operator new (size_t size
     }
 
   tree_constant *tmp = tc_newlist;
   tc_newlist = tc_newlist->freeptr;
   return tmp;
 }
 
 void
-tree_constant::operator delete (void *p, size_t size)
+tree_constant::operator delete (void *p, size_t /* size */)
 {
   tree_constant *tmp = (tree_constant *) p;
   tmp->freeptr = tc_newlist;
   tc_newlist = tmp;
 }
 
 // Simple assignment.
 
@@ -838,17 +838,17 @@ TC_REP::operator new (size_t size)
     }
 
   TC_REP *tmp = tc_rep_newlist;
   tc_rep_newlist = tc_rep_newlist->freeptr;
   return tmp;
 }
 
 void
-TC_REP::operator delete (void *p, size_t size)
+TC_REP::operator delete (void *p, size_t /* size */)
 {
   TC_REP *tmp = (TC_REP *) p;
   tmp->freeptr = tc_rep_newlist;
   tc_rep_newlist = tmp;
 }
 
 int
 TC_REP::rows (void) const
@@ -3594,17 +3594,17 @@ TC_REP::do_matrix_index (const Range& ri
       panic_impossible ();
       break;
     }
 
   return retval;
 }
 
 tree_constant
-TC_REP::do_matrix_index (TC_REP::constant_type mci,
+TC_REP::do_matrix_index (TC_REP::constant_type /* mci */,
 			 const tree_constant& j_arg) const
 {
   tree_constant retval;
 
   tree_constant tmp_j = j_arg.make_numeric_or_range_or_magic ();
 
   if (error_state)
     return retval;
@@ -5653,17 +5653,17 @@ TC_REP::do_matrix_assignment (const tree
       panic_impossible ();
       break;
     }
 }
 
 // -*- MA4 -*-
 void
 TC_REP::do_matrix_assignment (const tree_constant& rhs,
-			      TC_REP::constant_type i,
+			      TC_REP::constant_type /* i */,
 			      const tree_constant& j_arg)
 {
   tree_constant tmp_j = j_arg.make_numeric_or_range_or_magic ();
 
   if (error_state)
     return;
 
   TC_REP::constant_type jtype = tmp_j.const_type ();
diff --git a/src/pt-exp-base.cc b/src/pt-exp-base.cc
--- a/src/pt-exp-base.cc
+++ b/src/pt-exp-base.cc
@@ -177,17 +177,17 @@ any_arg_is_magic_colon (const Octave_obj
 	return 1;
 
   return 0;
 }
 
 // Expressions.
 
 tree_constant
-tree_expression::eval (int print)
+tree_expression::eval (int /* print */)
 {
   panic ("invalid evaluation of generic expression");
   return tree_constant ();
 }
 
 // General matrices.  This list type is much more work to handle than
 // constant matrices, but it allows us to construct matrices from
 // other matrices, variables, and functions.
@@ -286,17 +286,17 @@ struct const_matrix_list
   tree_constant elem;
   int nr;
   int nc;
 };
 
 // Less ugly than before, anyway.
 
 tree_constant
-tree_matrix::eval (int print)
+tree_matrix::eval (int /* print */)
 {
   tree_constant retval;
 
   if (error_state)
     return retval;
 
   // Just count the elements without looking at them.
 
@@ -642,47 +642,49 @@ tree_matrix::print_code (ostream& os)
 
   if (in_parens)
     os << ")";
 }
 
 // A base class for objects that can be return multiple values
 
 tree_constant
-tree_multi_val_ret::eval (int print)
+tree_multi_val_ret::eval (int /* print */)
 {
   panic ("invalid evaluation of generic expression");
   return tree_constant ();
 }
 
 // Used internally.
 
 tree_constant
-tree_oct_obj::eval (int print)
+tree_oct_obj::eval (int /* print */)
 {
   return values(0);
 }
 
 Octave_object
-tree_oct_obj::eval (int print, int nargout, const Octave_object& args)
+tree_oct_obj::eval (int /* print */, int /* nargout */,
+		    const Octave_object& /* args */)
 {
   return values;
 }
 
 // A base class for objects that can be evaluated with argument lists.
 
 tree_constant
-tree_fvc::assign (tree_constant& t, const Octave_object& args)
+tree_fvc::assign (tree_constant& /* t */, const Octave_object& /* args */)
 {
   panic_impossible ();
   return tree_constant ();
 }
 
 tree_constant
-tree_fvc::lookup_map_element (SLList<char*>& list, int insert, int silent)
+tree_fvc::lookup_map_element (SLList<char*>& /* list */,
+			      int /* insert */, int /* silent */)
 {
   static tree_constant retval;
 
   int l = line ();
   int c = column ();
 
   if (l == -1 && c == -1)
     ::error ("invalid structure reference");
@@ -1248,18 +1250,16 @@ tree_index_expression::eval (int print)
       // args.
 
       Octave_object args = list->convert_to_const_vector ();
 
       if (error_state)
 	eval_error ();
       else
 	{
-	  int nargin = args.length ();
-
 	  if (error_state)
 	    eval_error ();
 	  else
 	    {
 	      if (all_args_defined (args))
 		{
 		  Octave_object tmp = id->eval (print, 1, args);
 
@@ -1283,43 +1283,42 @@ tree_index_expression::eval (int print)
       if (error_state)
 	eval_error ();
     }
 
   return retval;
 }
 
 Octave_object
-tree_index_expression::eval (int print, int nargout, const Octave_object& args)
+tree_index_expression::eval (int print, int nargout,
+			     const Octave_object& /* args */)
 {
   Octave_object retval;
 
   if (error_state)
     return retval;
 
   if (list)
     {
       // Extract the arguments into a simple vector.  Don't pass null
       // args.
 
-      Octave_object args = list->convert_to_const_vector ();
+      Octave_object tmp_args = list->convert_to_const_vector ();
 
       if (error_state)
 	eval_error ();
       else
 	{
-	  int nargin = args.length ();
-
 	  if (error_state)
 	    eval_error ();
 	  else
 	    {
-	      if (all_args_defined (args))
+	      if (all_args_defined (tmp_args))
 		{
-		  retval = id->eval (print, nargout, args);
+		  retval = id->eval (print, nargout, tmp_args);
 
 		  if (error_state)
 		    eval_error ();
 		}
 	      else
 		{
 		  ::error ("undefined arguments found in index expression");
 		  eval_error ();
@@ -1540,17 +1539,17 @@ tree_postfix_expression::print_code (ost
 
   if (in_parens)
     os << ")";
 }
 
 // Unary expressions.
 
 tree_constant
-tree_unary_expression::eval (int print)
+tree_unary_expression::eval (int /* print */)
 {
   if (error_state)
     return tree_constant ();
 
   tree_constant retval;
 
   switch (etype)
     {
@@ -1658,17 +1657,17 @@ tree_unary_expression::print_code (ostre
 
   if (in_parens)
     os << ")";
 }
 
 // Binary expressions.
  
 tree_constant
-tree_binary_expression::eval (int print)
+tree_binary_expression::eval (int /* print */)
 {
   if (error_state)
     return tree_constant ();
 
   tree_constant retval;
 
   switch (etype)
     {
@@ -2046,17 +2045,17 @@ tree_multi_assignment_expression::eval (
   if (result.length () > 0)
     retval = result(0);
 
   return retval;
 }
 
 Octave_object
 tree_multi_assignment_expression::eval (int print, int nargout,
-					const Octave_object& args)
+					const Octave_object& /* args */)
 {
   assert (etype == tree_expression::multi_assignment);
 
   if (error_state || ! rhs)
     return Octave_object ();
 
   nargout = lhs->length ();
   Octave_object tmp_args;
@@ -2194,17 +2193,17 @@ tree_colon_expression::chain (tree_expre
       op2 = t;
 
       retval = this;
     }
   return retval;
 }
 
 tree_constant
-tree_colon_expression::eval (int print)
+tree_colon_expression::eval (int /* print */)
 {
   tree_constant retval;
 
   if (error_state || ! op1 || ! op2)
     return retval;
 
   tree_constant tmp = op1->eval (0);
 
@@ -2308,47 +2307,39 @@ tree_colon_expression::print_code (ostre
   if (in_parens)
     os << ")";
 }
 
 // Builtin functions.
 
 tree_builtin::tree_builtin (const char *nm)
 {
-  nargin_max = -1;
-  nargout_max = -1;
   is_mapper = 0;
   fcn = 0;
   if (nm)
     my_name = strsave (nm);
 }
 
-tree_builtin::tree_builtin (int i_max, int o_max, Mapper_fcn& m_fcn,
-			    const char *nm)
+tree_builtin::tree_builtin (Mapper_fcn& m_fcn, const char *nm)
 {
-  nargin_max = i_max;
-  nargout_max = o_max;
   mapper_fcn = m_fcn;
   is_mapper = 1;
   fcn = 0;
   my_name = nm ? strsave (nm) : 0;
 }
 
-tree_builtin::tree_builtin (int i_max, int o_max, Octave_builtin_fcn g_fcn,
-			    const char *nm)
+tree_builtin::tree_builtin (Octave_builtin_fcn g_fcn, const char *nm)
 {
-  nargin_max = i_max;
-  nargout_max = o_max;
   is_mapper = 0;
   fcn = g_fcn;
   my_name = nm ? strsave (nm) : 0;
 }
 
 tree_constant
-tree_builtin::eval (int print)
+tree_builtin::eval (int /* print */)
 {
   tree_constant retval;
 
   if (error_state)
     return retval;
 
   if (fcn)
     {
@@ -2372,17 +2363,18 @@ tree_builtin::eval (int print)
       else
 	::error ("unable to load builtin function %s", my_name);
     }
 
   return retval;
 }
 
 static tree_constant
-apply_mapper_fcn (const tree_constant& arg, Mapper_fcn& m_fcn, int print)
+apply_mapper_fcn (const tree_constant& arg, Mapper_fcn& m_fcn,
+		  int /* print */)
 {
   tree_constant retval;
 
   if (arg.is_real_type ())
     {
       if (arg.is_scalar_type ())
 	{
 	  double d = arg.double_value ();
@@ -2452,17 +2444,17 @@ apply_mapper_fcn (const tree_constant& a
     }
   else
     gripe_wrong_type_arg ("mapper", arg);
 
   return retval;
 }
 
 Octave_object
-tree_builtin::eval (int print, int nargout, const Octave_object& args)
+tree_builtin::eval (int /* print */, int nargout, const Octave_object& args)
 {
   Octave_object retval;
 
   if (error_state)
     return retval;
 
   int nargin = args.length ();
 
@@ -2472,19 +2464,22 @@ tree_builtin::eval (int print, int nargo
 
       if (any_arg_is_magic_colon (args))
 	::error ("invalid use of colon in function argument list");
       else
 	retval = (*fcn) (args, nargout);
     }
   else if (is_mapper)
     {
-      if (nargin > nargin_max)
-	::error ("%s: too many arguments", my_name);
-      else if (nargin > 0 && args(0).is_defined ())
+// XXX FIXME XXX -- should we just assume nargin_max == 1?
+//
+//      if (nargin > nargin_max)
+//	::error ("%s: too many arguments", my_name);
+//      else
+      if (nargin > 0 && args(0).is_defined ())
 	{
 	  tree_constant tmp = apply_mapper_fcn (args(0), mapper_fcn, 0);
 	  retval(0) = tmp;
 	}	
     }
   else
     {
       fcn = load_octave_builtin (my_name);
@@ -2493,27 +2488,16 @@ tree_builtin::eval (int print, int nargo
 	goto eval_fcn;
       else
 	::error ("unable to load builtin function %s", my_name);
     }
 
   return retval;
 }
 
-int
-tree_builtin::max_expected_args (void)
-{
-  int ea = nargin_max;
-  if (nargin_max < 0)
-    ea = INT_MAX;
-  else
-    ea = nargin_max;
-  return ea;
-}
-
 // User defined functions.
 
 void
 tree_function::install_nargin_and_nargout (void)
 {
   nargin_sr = sym_tab->lookup ("nargin", 1, 0);
   nargout_sr = sym_tab->lookup ("nargout", 1, 0);
 }
@@ -2702,17 +2686,17 @@ delete_vr_list (void *list)
 static void
 clear_symbol_table (void *table)
 {
   symbol_table *tmp = (symbol_table *) table;
   tmp->clear ();
 }
 
 Octave_object
-tree_function::eval (int print, int nargout, const Octave_object& args)
+tree_function::eval (int /* print */, int nargout, const Octave_object& args)
 {
   Octave_object retval;
 
   if (error_state)
     return retval;
 
   if (! cmd_list)
     return retval;
@@ -2820,30 +2804,16 @@ tree_function::eval (int print, int narg
   }
 
  abort:
   run_unwind_frame ("func_eval");
 
   return retval;
 }
 
-int
-tree_function::max_expected_args (void)
-{
-  if (param_list)
-    {
-      if (param_list->takes_varargs ())
-	return -1;
-      else
-	return param_list->length ();
-    }
-  else
-    return 1;
-}
-
 void
 tree_function::traceback_error (void)
 {
   if (error_state >= 0)
     error_state = -1;
 
   if (fcn_name)
     {
@@ -2913,17 +2883,17 @@ tree_function::print_code (ostream& os)
       cmd_list->print_code (os);
     }
 
   os << "endfunction";
 
   print_code_new_line (os);
 }
 
-DEFUN ("va_arg", Fva_arg, Sva_arg, 0, 1,
+DEFUN ("va_arg", Fva_arg, Sva_arg, 10,
   "va_arg (): return next argument in a function that takes a\n\
 variable number of parameters")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
@@ -2942,17 +2912,17 @@ variable number of parameters")
 	::error ("va_arg only valid within function body");
     }
   else
     print_usage ("va_arg");
 
   return retval;
 }
 
-DEFUN ("va_start", Fva_start, Sva_start, 0, 0,
+DEFUN ("va_start", Fva_start, Sva_start, 10,
   "va_start (): reset the pointer to the list of optional arguments\n\
 to the beginning")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
@@ -2971,17 +2941,17 @@ to the beginning")
 	::error ("va_start only valid within function body");
     }
   else
     print_usage ("va_start");
 
   return retval;
 }
 
-DEFUN ("vr_val", Fvr_val, Svr_val, 1, 0,
+DEFUN ("vr_val", Fvr_val, Svr_val, 10,
   "vr_val (X): append X to the list of optional return values for a
 function that allows a variable number of return values")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
diff --git a/src/pt-exp-base.h b/src/pt-exp-base.h
--- a/src/pt-exp-base.h
+++ b/src/pt-exp-base.h
@@ -258,19 +258,16 @@ public:
     { panic_impossible (); return 0; }
 
   virtual void bump_value (tree_expression::type)
     { panic_impossible (); }
 
   virtual tree_constant lookup_map_element (SLList<char*>& list,
 					    int insert = 0, int silent = 0);
 
-  virtual int max_expected_args (void)
-    { panic_impossible (); return 0; }
-  
   virtual char *fcn_file_name (void)
     { return 0; }
 
   virtual time_t time_parsed (void)
     { panic_impossible (); return 0; }
 
   virtual int is_system_fcn_file (void) const
     { return 0; }
@@ -805,46 +802,40 @@ tree_colon_expression : public tree_expr
 // Builtin functions.
 
 class
 tree_builtin : public tree_fvc
 {
 public:
   tree_builtin (const char *nm = 0);
 
-  tree_builtin (int i_max, int o_max, Mapper_fcn& m_fcn,
-		const char *nm = 0);
+  tree_builtin (Mapper_fcn& m_fcn, const char *nm = 0);
 
-  tree_builtin (int i_max, int o_max, Octave_builtin_fcn f,
-		const char *nm = 0);
+  tree_builtin (Octave_builtin_fcn f, const char *nm = 0);
 
   ~tree_builtin (void) { }  // XXX ?? XXX
 
 //  int is_builtin (void) const;
 
   int is_mapper_function (void) const
     { return is_mapper; }
 
   tree_constant eval (int print);
 
   Octave_object eval (int print, int nargout, const Octave_object& args);
 
   char *name (void) const
     { return my_name; }
 
-  int max_expected_args (void);
-
   void print_code (ostream& os)
     {
       os << my_name << " can't be printed because it is a builtin function\n";
     }
 
 private:
-  int nargin_max;
-  int nargout_max;
   int is_mapper;
   Mapper_fcn mapper_fcn;
   Octave_builtin_fcn fcn;
   char *my_name;
 };
 
 // User defined functions.
 
@@ -926,18 +917,16 @@ public:
 
   char *function_name (void)
     { return fcn_name; }
 
   tree_constant eval (int print);
 
   Octave_object eval (int print, int nargout, const Octave_object& args);
 
-  int max_expected_args (void);
-
   void traceback_error (void);
 
   void print_code (ostream& os);
 
 private:
   int call_depth;
   tree_parameter_list *param_list;
   tree_parameter_list *ret_list;
diff --git a/src/pt-plot.cc b/src/pt-plot.cc
--- a/src/pt-plot.cc
+++ b/src/pt-plot.cc
@@ -1104,17 +1104,17 @@ do_external_plotter_cd (const char *newd
       ostrstream plot_buf;
       plot_buf << "cd \"" << newdir << "\"\n" << ends;
       char *message = plot_buf.str ();
       send_to_plot_stream (message);
       delete [] message;
     }
 }
 
-DEFUN ("clearplot", Fclearplot, Sclearplot, 0, 0,
+DEFUN ("clearplot", Fclearplot, Sclearplot, 00,
   "clearplot (): clear the plot window")
 {
   Octave_object retval;
   send_to_plot_stream ("clear\n");
 
   // XXX FIXME XXX -- instead of just clearing these things, it would
   // be nice if we could reset things to a user-specified default
   // state.
@@ -1130,25 +1130,25 @@ DEFUN ("clearplot", Fclearplot, Sclearpl
 
   plot_line_count = 0;
 
   return retval;
 }
 
 DEFALIAS (clg, clearplot);
 
-DEFUN ("closeplot", Fcloseplot, Scloseplot, 0, 0,
+DEFUN ("closeplot", Fcloseplot, Scloseplot, 00,
   "closeplot (): close the stream to plotter")
 {
   Octave_object retval;
   close_plot_stream ();
   return retval;
 }
 
-DEFUN_TEXT ("hold", Fhold, Shold, 1, 0,
+DEFUN_TEXT ("hold", Fhold, Shold, 10,
   "hold [on|off]\n\
 \n\
 determine whether the plot window is cleared before the next line is\n\
 drawn.  With no argument, toggle the current state.") 
 {
   Octave_object retval;
 
   DEFINE_ARGV("hold");
@@ -1173,33 +1173,33 @@ drawn.  With no argument, toggle the cur
       break;
     }
 
   DELETE_ARGV;
 
   return retval;
 }
 
-DEFUN ("ishold", Fishold, Sishold, 0, 1,
+DEFUN ("ishold", Fishold, Sishold, 00,
   "ishold\n\
 \n\
 Return 1 if hold is on, otherwise return 0.")
 {
   return (double) (! clear_before_plotting);
 }
 
-DEFUN ("purge_tmp_files", Fpurge_tmp_files, Spurge_tmp_files, 0, 0,
+DEFUN ("purge_tmp_files", Fpurge_tmp_files, Spurge_tmp_files, 00,
   "delete temporary data files used for plotting")
 {
   Octave_object retval;
   cleanup_tmp_files ();
   return retval;
 }
 
-DEFUN_TEXT ("set", Fset, Sset, -1, 0,
+DEFUN_TEXT ("set", Fset, Sset, 10,
   "set [options]\n\
 \n\
 set plotting options")
 {
   Octave_object retval;
 
   DEFINE_ARGV("set");
 
@@ -1232,17 +1232,17 @@ set plotting options")
 
   delete [] plot_command;
 
   DELETE_ARGV;
 
   return retval;
 }
 
-DEFUN_TEXT ("show", Fshow, Sshow, -1, 0,
+DEFUN_TEXT ("show", Fshow, Sshow, 10,
   "show [options]\n\
 \n\
 show plotting options")
 {
   Octave_object retval;
 
   DEFINE_ARGV("show");
 
diff --git a/src/qpsol.cc b/src/qpsol.cc
--- a/src/qpsol.cc
+++ b/src/qpsol.cc
@@ -47,22 +47,22 @@ extern int linear_constraints_ok (const 
 				  const ColumnVector& lub, char *warn_for,
 				  int warn);
 
 static QPSOL_options qpsol_opts;
 
 #endif
 
 #if defined (QPSOL_MISSING)
-DEFUN_DLD_BUILTIN ("qpsol", Fqpsol, Sqpsol, 9, 3,
+DEFUN_DLD_BUILTIN ("qpsol", Fqpsol, Sqpsol, 11,
   "This function requires QPSOL, which is not freely\n\
 redistributable.  For more information, read the file\n\
 libcruft/qpsol/README.MISSING in the source distribution.")
 #else
-DEFUN_DLD_BUILTIN ("qpsol", Fqpsol, Sqpsol, 9, 3,
+DEFUN_DLD_BUILTIN ("qpsol", Fqpsol, Sqpsol, 11,
   "[X, OBJ, INFO, LAMBDA] = qpsol (X, H, C [, LB, UB] [, LB, A, UB])\n\
 \n\
 Groups of arguments surrounded in `[]' are optional, but\n\
 must appear in the same relative order shown above.")
 #endif
 {
 /*
 
@@ -380,22 +380,22 @@ show_qpsol_option (const char *keyword)
   warning ("qpsol_options: no match for `%s'", keyword);
 
   return retval;
 }
 
 #endif
 
 #if defined (QPSOL_MISSING)
-DEFUN_DLD_BUILTIN ("qpsol_options", Fqpsol_options, Sqpsol_options, -1, 1,
+DEFUN_DLD_BUILTIN ("qpsol_options", Fqpsol_options, Sqpsol_options, 10,
   "This function requires QPSOL, which is not freely\n\
 redistributable.  For more information, read the file\n\
 libcruft/qpsol/README.MISSING in the source distribution.")
 #else
-DEFUN_DLD_BUILTIN ("qpsol_options", Fqpsol_options, Sqpsol_options, -1, 1,
+DEFUN_DLD_BUILTIN ("qpsol_options", Fqpsol_options, Sqpsol_options, 10,
   "qpsol_options (KEYWORD, VALUE)\n
 \n\
 Set or show options for qpsol.  Keywords may be abbreviated\n\
 to the shortest match.")
 #endif
 {
   Octave_object retval;
 
diff --git a/src/qr.cc b/src/qr.cc
--- a/src/qr.cc
+++ b/src/qr.cc
@@ -32,17 +32,17 @@ Software Foundation, 59 Temple Place - S
 
 #include "defun-dld.h"
 #include "gripes.h"
 #include "help.h"
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "utils.h"
 
-DEFUN_DLD_BUILTIN ("qr", Fqr, Sqr, 2, 2,
+DEFUN_DLD_BUILTIN ("qr", Fqr, Sqr, 11,
   "[Q, R] = qr (X):      form Q unitary and R upper triangular such\n\
                        that Q * R = X\n\
 \n\
 [Q, R] = qr (X, 0):    form the economy decomposition such that if X is\n\
                        if X is m by n then only the first n columns of Q\n\
                        are computed.\n\
 \n\
 [Q, R, P] = qr (X):    form QRP factorization of X where\n\
diff --git a/src/quad.cc b/src/quad.cc
--- a/src/quad.cc
+++ b/src/quad.cc
@@ -78,17 +78,17 @@ quad_user_function (double x)
 	  quad_integration_error = 1;  // XXX FIXME XXX
 	  gripe_user_supplied_eval ("quad");
 	}
     }
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN ("quad", Fquad, Squad, 5, 3,
+DEFUN_DLD_BUILTIN ("quad", Fquad, Squad, 11,
   "[V, IER, NFUN] = quad (F, A, B [, TOL] [, SING])\n\
 \n\
 Where the first argument is the name of the  function to call to\n\
 compute the value of the integrand.  It must have the form\n\
 \n\
   y = f (x)
 \n\
 where y and x are scalars.\n\
@@ -110,17 +110,17 @@ integrand is singular.")
 
   if (nargin < 3 || nargin > 5 || nargout > 4)
     {
       print_usage ("quad");
       return retval;
     }
 
   quad_fcn = is_valid_function (args(0), "quad", 1);
-  if (! quad_fcn || takes_correct_nargs (quad_fcn, 1, "quad", 1) != 1)
+  if (! quad_fcn)
     return retval;
 
   double a = args(1).double_value ();
 
   if (error_state)
     {
       error ("quad: expecting second argument to be a scalar");
       return retval;
@@ -348,17 +348,17 @@ show_quad_option (const char *keyword)
       list++;
     }
 
   warning ("quad_options: no match for `%s'", keyword);
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN ("quad_options", Fquad_options, Squad_options, -1, 1,
+DEFUN_DLD_BUILTIN ("quad_options", Fquad_options, Squad_options, 10,
   "quad_options (KEYWORD, VALUE)\n\
 \n\
 Set or show options for quad.  Keywords may be abbreviated\n\
 to the shortest match.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
diff --git a/src/qzval.cc b/src/qzval.cc
--- a/src/qzval.cc
+++ b/src/qzval.cc
@@ -51,17 +51,17 @@ extern "C"
 			    const double&, const long&, double*,
 			    int&);
  
   int F77_FCN (qzval, QZVAL) (const int&, const int&, double*,
 			      double*, double*, double*, double*,
 			      const long&, double*);
 }
 
-DEFUN_DLD_BUILTIN ("qzval", Fqzval, Sqzval, 3, 1,
+DEFUN_DLD_BUILTIN ("qzval", Fqzval, Sqzval, 11,
   "X = qzval (A, B)\n\
 \n\
 compute generalized eigenvalues of the matrix pencil (A - lambda B).\n\
 A and B must be real matrices.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
diff --git a/src/rand.cc b/src/rand.cc
--- a/src/rand.cc
+++ b/src/rand.cc
@@ -99,17 +99,17 @@ curr_rand_dist (void)
     return "normal";
   else
     {
       panic_impossible ();
       return 0;
     }
 }
 
-DEFUN_DLD_BUILTIN ("rand", Frand, Srand, 2, 1,
+DEFUN_DLD_BUILTIN ("rand", Frand, Srand, 11,
   "rand                  -- generate a random value\n\
 \n\
 rand (N)              -- generate N x N matrix\n\
 rand (A)              -- generate matrix the size of A\n\
 rand (N, M)           -- generate N x M matrix\n\
 rand (\"dist\")         -- get current distribution\n\
 rand (DISTRIBUTION)   -- set distribution type (\"normal\" or \"uniform\"\n\
 rand (SEED)           -- get current seed\n\
diff --git a/src/resource.cc b/src/resource.cc
--- a/src/resource.cc
+++ b/src/resource.cc
@@ -95,17 +95,17 @@ mk_ru_map (struct rusage *ru)
   m ["nsignals"] = octave_NaN;
   m ["nvcsw"] = octave_NaN;
   m ["nivcsw"] = octave_NaN;
 #endif
 
   return m;
 }
 
-DEFUN ("getrusage", Fgetrusage, Sgetrusage, 0, 0,
+DEFUN ("getrusage", Fgetrusage, Sgetrusage, 00,
   "getrusage ()\n\
 \n\
 Return system resource statistics.")
 {
   Octave_object retval;
 
 #if defined (HAVE_GETRUSAGE)
 
diff --git a/src/schur.cc b/src/schur.cc
--- a/src/schur.cc
+++ b/src/schur.cc
@@ -31,17 +31,17 @@ Software Foundation, 59 Temple Place - S
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "utils.h"
 
-DEFUN_DLD_BUILTIN ("schur", Fschur, Sschur, 3, 2,
+DEFUN_DLD_BUILTIN ("schur", Fschur, Sschur, 11,
   "[U, S] = schur (A) or S = schur (A)\n\
 \n\
 or, for ordered Schur:\n\
 \n\
   [U, S] = schur (A, TYPE) or S = schur (A, TYPE)\n\
 where TYPE is a string that begins with one of the following\n\
 characters:\n\
 \n\
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -141,17 +141,17 @@ sigchld_handler (int sig)
     }
 
   octave_set_signal_handler (SIGCHLD, sigchld_handler);
 }
 #endif
 
 #if defined (__alpha__)
 static RETSIGTYPE
-sigfpe_handler (int sig)
+sigfpe_handler (int /* sig */)
 {
   // Can this ever cause trouble on systems that don't forget signal
   // handlers when they are invoked?
 
   octave_set_signal_handler (SIGFPE, sigfpe_handler);
 
   error ("floating point exception -- trying to return to prompt");
 
@@ -170,17 +170,17 @@ sigfpe_handler (int sig)
 #endif
 
 // Handle SIGINT by restarting the parser (see octave.cc).
 
 // XXX FIXME XXX -- it would probably be good to try to use POSIX
 // signal interface if it is available.
 
 static RETSIGTYPE
-sigint_handler (int sig)
+sigint_handler (int /* sig */)
 {
   // Can this ever cause trouble on systems that don't forget signal
   // handlers when they are invoked?
 
   octave_set_signal_handler (SIGINT, sigint_handler);
 
   if (can_interrupt)
     {
@@ -191,17 +191,17 @@ sigint_handler (int sig)
 #if RETSIGTYPE == void
   return;
 #else
   return 0;
 #endif
 }
 
 static RETSIGTYPE
-sigpipe_handler (int sig)
+sigpipe_handler (int /* sig */)
 {
   // Can this ever cause trouble on systems that don't forget signal
   // handlers when they are invoked?
 
   octave_set_signal_handler (SIGPIPE, sigpipe_handler);
 
   if (pipe_handler_error_count++ == 0)
     message (0, "broken pipe");
diff --git a/src/sort.cc b/src/sort.cc
--- a/src/sort.cc
+++ b/src/sort.cc
@@ -276,17 +276,17 @@ mx_sort (ComplexRowVector& cv)
     }
 
   retval (1) = tree_constant (idx, 0);
   retval (0) = tree_constant (cvs, 0);
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN ("sort", Fsort, Ssort, 2, 2,
+DEFUN_DLD_BUILTIN ("sort", Fsort, Ssort, 11,
   "[S, I] = sort (X)\n\
 \n\
 sort the columns of X, optionally return sort index")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
diff --git a/src/strfns.cc b/src/strfns.cc
--- a/src/strfns.cc
+++ b/src/strfns.cc
@@ -32,47 +32,47 @@ Software Foundation, 59 Temple Place - S
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "oct-obj.h"
 #include "tree-const.h"
 #include "utils.h"
 
-DEFUN ("isstr", Fisstr, Sisstr, 1, 1,
+DEFUN ("isstr", Fisstr, Sisstr, 10,
   "isstr (X): return 1 if X is a string, 0 otherwise")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_defined ())
     retval = (double) args(0).is_string ();
   else
     print_usage ("isstr");
 
   return retval;
 }
 
-DEFUN ("setstr", Fsetstr, Ssetstr, 1, 1,
+DEFUN ("setstr", Fsetstr, Ssetstr, 10,
   "setstr (V): convert a vector to a string")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_defined ())
     retval = args(0).convert_to_str ();
   else
     print_usage ("setstr");
 
   return retval;
 }
 
-DEFUN ("toascii", Ftoascii, Stoascii, 1, 1,
+DEFUN ("toascii", Ftoascii, Stoascii, 10,
   "toascii (STRING): return ASCII representation of STRING in a matrix")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
diff --git a/src/svd.cc b/src/svd.cc
--- a/src/svd.cc
+++ b/src/svd.cc
@@ -33,17 +33,17 @@ Software Foundation, 59 Temple Place - S
 #include "gripes.h"
 #include "help.h"
 #include "mappers.h"
 #include "pr-output.h"
 #include "tree-const.h"
 #include "user-prefs.h"
 #include "utils.h"
 
-DEFUN_DLD_BUILTIN ("svd", Fsvd, Ssvd, 2, 3,
+DEFUN_DLD_BUILTIN ("svd", Fsvd, Ssvd, 11,
   "S = svd (X) or [U, S, V] = svd (X [, 0])\n\
 \n\
 Compute the singular value decomposition of X.  Given a second input\n\
 argument, an `economy' sized factorization is computed that omits\n\
 unnecessary rows and columns of U and V.\n\
 \n\
 X may not contain any Inf or NaN values.")
 {
diff --git a/src/syl.cc b/src/syl.cc
--- a/src/syl.cc
+++ b/src/syl.cc
@@ -52,17 +52,17 @@ extern "C"
   int F77_FCN (ztrsyl, ZTRSYL) (const char*, const char*, const int&,
 				const int&, const int&,
 				const Complex*, const int&,
 				const Complex*, const int&, 
 				const Complex*, const int&, double&,
 				int&, long, long);
 }
 
-DEFUN_DLD_BUILTIN ("syl", Fsyl, Ssyl, 4, 1,
+DEFUN_DLD_BUILTIN ("syl", Fsyl, Ssyl, 11,
   "X = syl (A, B, C): solve the Sylvester equation A X + X B + C = 0")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin != 3 || nargout > 1)
     {
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -503,17 +503,17 @@ octave_chdir (const char *path)
     retval = _chdir2 (path);
 
   return retval;
 #else
   return chdir (path);
 #endif
 }
 
-DEFUN ("clc", Fclc, Sclc, 0, 0,
+DEFUN ("clc", Fclc, Sclc, 00,
   "clc (): clear screen")
 {
   Octave_object retval;
 
   rl_beg_of_line ();
   rl_kill_line (1);
 
 #if ! defined (_GO32_)
@@ -527,17 +527,17 @@ DEFUN ("clc", Fclc, Sclc, 0, 0,
 
   fflush (rl_outstream);
 
   return retval;
 }
 
 DEFALIAS (home, clc);
 
-DEFUN ("getenv", Fgetenv, Sgetenv, 1, 1,
+DEFUN ("getenv", Fgetenv, Sgetenv, 10,
   "getenv (STRING): get environment variable values")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
@@ -553,17 +553,17 @@ DEFUN ("getenv", Fgetenv, Sgetenv, 1, 1,
 	}
     }
   else
     print_usage ("getenv");
 
   return retval;
 }
 
-DEFUN ("kbhit", Fkbhit, Skbhit, 0, 1,
+DEFUN ("kbhit", Fkbhit, Skbhit, 00,
   "kbhit: get a single character from the terminal")
 {
   Octave_object retval;
 
   // XXX FIXME XXX -- add timeout and default value args?
 
   if (interactive)
     {
@@ -572,17 +572,17 @@ DEFUN ("kbhit", Fkbhit, Skbhit, 0, 1,
       s[0] = c;
       s[1] = '\0';
       retval = s;
     }
 
   return retval;
 }
 
-DEFUN ("pause", Fpause, Spause, 1, 1,
+DEFUN ("pause", Fpause, Spause, 10,
   "pause (seconds): suspend program execution")
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   if (! (nargin == 0 || nargin == 1))
     {
@@ -620,17 +620,17 @@ DEFUN ("pause", Fpause, Spause, 1, 1,
     }
 
   return retval;
 }
 
 // XXX FIXME XXX -- maybe this should only return 1 if IEEE floating
 // point functions really work.
 
-DEFUN ("isieee", Fisieee, Sisieee, 1, 1,
+DEFUN ("isieee", Fisieee, Sisieee, 00,
   "isieee (): return 1 if host uses IEEE floating point")
 {
   return (double) (native_float_format == OCTAVE_IEEE_LITTLE
 		   || native_float_format == OCTAVE_IEEE_BIG);
 }
 
 #if !defined (HAVE_GETHOSTNAME) && defined (HAVE_SYS_UTSNAME_H)
 int
diff --git a/src/timefns.cc b/src/timefns.cc
--- a/src/timefns.cc
+++ b/src/timefns.cc
@@ -81,17 +81,17 @@ extract_tm (Octave_map &m, double& fract
   tm.tm_isdst = NINT (m ["isdst"] . double_value ());
 #ifdef HAVE_TMZONE
   tm.tm_zone = (m ["zone"] . string_value ());
 #endif
 
   return &tm;
 }
 
-DEFUN ("time", Ftime, Stime, 1, 0,
+DEFUN ("time", Ftime, Stime, 00,
   "time ()\n\
 \n\
   Return current time.  On Unix systems, this is the number of\n\
   seconds since the epoch.")
 {
   time_t now;
   double fraction = 0.0;
 
@@ -113,17 +113,17 @@ DEFUN ("time", Ftime, Stime, 1, 0,
 
   now = time (0);
 
 #endif
  
   return (double) now + fraction;
 }
 
-DEFUN ("gmtime", Fgmtime, Sgmtime, 1, 1,
+DEFUN ("gmtime", Fgmtime, Sgmtime, 10,
   "gmtime (TIME)\n\
 \n\
   Given a value returned from time(), return a structure like that\n\
   returned from localtime() but with values corresponding to\n\
   Coordinated Universal Time (UTC).")
 {
   Octave_object retval;
 
@@ -141,17 +141,17 @@ DEFUN ("gmtime", Fgmtime, Sgmtime, 1, 1,
 	}
     }
   else
     print_usage ("gmtime");
 
   return retval;
 }
 
-DEFUN ("localtime", Flocaltime, Slocaltime, 1, 1,
+DEFUN ("localtime", Flocaltime, Slocaltime, 10,
   "localtime (TIME)\n\
 \n\
   Given a value returned from time(), return a structure with\n\
   the following elements:\n\
 \n\
     usec  : microseconds after the second (0, 999999)\n\
     sec   : seconds after the minute (0, 61)\n\
     min   : minutes after the hour (0, 59)\n\
@@ -180,17 +180,17 @@ DEFUN ("localtime", Flocaltime, Slocalti
 	}
     }
   else
     print_usage ("localtime");
 
   return retval;
 }
 
-DEFUN ("mktime", Fmktime, Smktime, 1, 2,
+DEFUN ("mktime", Fmktime, Smktime, 10,
   "mktime (TMSTRUCT)")
 {
   Octave_object retval;
 
   if (args.length () == 1 && args(0).is_map ()) 
     {
       Octave_map map = args(0).map_value ();
 
@@ -202,17 +202,17 @@ DEFUN ("mktime", Fmktime, Smktime, 1, 2,
 	retval = (double) mktime (tm) + fraction;
     }
   else
     print_usage ("mktime");
 
   return retval;
 }
 
-DEFUN ("strftime", Fstrftime, Sstrftime, 1, 2,
+DEFUN ("strftime", Fstrftime, Sstrftime, 10,
   "strftime (FMT, TMSTRUCT)\n\
 \n\
   Performs `%' substitutions similar to those in printf.  Except where\n\
   noted, substituted fields have a fixed size; numeric fields are\n\
   padded if necessary.  Padding is with zeros by default; for fields\n\
   that display a single number, padding can be changed or inhibited by\n\
   following the `%' with one of the modifiers described below.\n\
   Unknown field specifiers are copied as normal characters.  All other\n\
diff --git a/src/token.cc b/src/token.cc
--- a/src/token.cc
+++ b/src/token.cc
@@ -48,17 +48,17 @@ token::token (char *s, int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = string_token;
   str = strsave (s);
   orig_text = 0;
 }
 
-token::token (double d, char *s, int l, int c)
+token::token (double d, char * /* s */, int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = double_token;
   num = d;
   orig_text = 0; // strsave (s);
 }
 
@@ -144,23 +144,23 @@ token::sym_rec (void)
 }
 
 char *
 token::text_rep (void)
 {
   return orig_text;
 }
 
-token::token (const token& tok)
+token::token (const token& /* tok */)
 {
   panic_impossible ();
 }
 
 token&
-token::operator = (const token& tok)
+token::operator = (const token& /* tok */)
 {
   panic_impossible ();
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
diff --git a/src/toplev.h b/src/toplev.h
--- a/src/toplev.h
+++ b/src/toplev.h
@@ -21,25 +21,29 @@ Software Foundation, 59 Temple Place - S
 
 */
 
 #if !defined (octave_octave_h)
 #define octave_octave_h 1
 
 #include <cstdio>
 
+class tree_constant;
+class tree_function;
 class tree_statement_list;
-class tree_function;
 class Octave_str_obj;
 
 extern void clean_up_and_exit (int) NORETURN;
 
 extern void parse_and_execute (FILE *f, int print = 0);
 extern void parse_and_execute (char *s, int print = 0, int verbose = 0);
 
+extern tree_constant eval_string (const char *string, int print,
+				  int& parse_status);
+
 // argv[0] for this program.
 extern char *raw_prog_name;
 
 // Cleaned-up name of this program, not including path information.
 extern char *prog_name;
 
 // Login name for user running this program.
 extern char *user_name;
diff --git a/src/unwind-prot.cc b/src/unwind-prot.cc
--- a/src/unwind-prot.cc
+++ b/src/unwind-prot.cc
@@ -195,17 +195,16 @@ complex_matrix_cleanup (void *cm)
 class saved_variable
 {
  public:
   enum var_type { integer, generic_ptr, generic };
 
   saved_variable (void);
   saved_variable (int *p, int v);
   saved_variable (void **p, void *v);
-  saved_variable (void *p, void *v, size_t sz);
   ~saved_variable (void);
 
   void restore_value (void);
 
  private:
   union
     {
       int *ptr_to_int;
@@ -242,24 +241,16 @@ saved_variable::saved_variable (int *p, 
 saved_variable::saved_variable (void **p, void *v)
 {
   type_tag = generic_ptr;
   ptr_to_gen_ptr = p;
   gen_ptr_value = v;
   size = sizeof (void *);
 }
 
-saved_variable::saved_variable (void *p, void *v, size_t sz)
-{
-  gen_ptr = v;
-  gen_ptr_value = new char [sz];
-  memcpy (gen_ptr_value, v, sz);
-  size = sz;
-}
-
 saved_variable::~saved_variable (void)
 {
   if (type_tag == generic)
     delete [] gen_ptr_value;
 }
 
 void
 saved_variable::restore_value (void)
@@ -301,21 +292,14 @@ unwind_protect_int_internal (int *ptr, i
 
 void
 unwind_protect_ptr_internal (void **ptr, void *value)
 {
   saved_variable *s = new saved_variable (ptr, value);
   add_unwind_protect (restore_saved_variable, (void *) s);
 }
 
-void
-unwind_protect_var_internal (void *ptr, void *value, size_t size)
-{
-  saved_variable *s = new saved_variable (ptr, value, size);
-  add_unwind_protect (restore_saved_variable, (void *) s);
-}
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/unwind-prot.h b/src/unwind-prot.h
--- a/src/unwind-prot.h
+++ b/src/unwind-prot.h
@@ -49,19 +49,16 @@ void unwind_protect_ptr_internal (void *
 void unwind_protect_var_internal (void *ptr, void *value, size_t size);
 
 #define unwind_protect_int(i) \
   unwind_protect_int_internal (&(i), (i))
 
 #define unwind_protect_ptr(p) \
   unwind_protect_ptr_internal ((void **) &(p), (void *) (p))
 
-#define unwind_protect_var(i) \
-  unwind_protect_var_internal ((void *) &(i), (void *) &(i), sizeof (int))
-
 class
 unwind_elem
 {
  public:
   unwind_elem (void);
   unwind_elem (char *t);
   unwind_elem (cleanup_func f, void *p);
   unwind_elem (const unwind_elem& el);
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -176,17 +176,17 @@ octave_tmp_file_name (void)
 
   if (! retval)
     error ("can't open temporary file!");
 
   return retval;
 }
 
 DEFUN ("octave_tmp_file_name", Foctave_tmp_file_name,
-       Soctave_tmp_file_name, 0, 1,
+       Soctave_tmp_file_name, 10,
  "octave_tmp_file_name ()")
 {
   tree_constant retval;
 
   if (args.length () == 0)
     retval = octave_tmp_file_name ();
   else
     print_usage ("octave_tmp_file_name");
@@ -641,17 +641,17 @@ search_path_for_file (const char *path, 
     {
       retval = make_absolute (tmp, the_current_working_directory);
       free (tmp);
     }
 
   return retval;
 }
 
-DEFUN ("file_in_path", Ffile_in_path, Sfile_in_path, 3, 1,
+DEFUN ("file_in_path", Ffile_in_path, Sfile_in_path, 10,
   "file_in_path (PATH, NAME)")
 {
   Octave_object retval;
 
   DEFINE_ARGV("file_in_path");
 
   if (argc == 3)
     {
@@ -785,17 +785,17 @@ undo_string_escapes (const char *s)
   while ((t = undo_string_escape (*s++)))
     buf << t;
   buf << ends;
 
   return buf.str ();
 }
 
 DEFUN ("undo_string_escapes", Fundo_string_escapes,
-       Sundo_string_escapes, 1, 1,
+       Sundo_string_escapes, 10,
   "undo_string_escapes (STRING)")
 {
   tree_constant retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 && args(0).is_string ())
     {
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -149,35 +149,17 @@ is_valid_function (const tree_constant& 
 	error ("%s: the symbol `%s' is not valid as a function",
 	       warn_for, fcn_name);
       ans = 0;
     }
 
   return ans;
 }
 
-// Does this function take the right number of arguments?
-
-int
-takes_correct_nargs (tree_fvc *fcn, int expected_nargin, char *warn_for,
-		     int warn)
-{
-  int nargin = fcn->max_expected_args ();
-  int e_nargin = expected_nargin;
-  if (nargin != e_nargin)
-    {
-      if (warn)
-	error ("%s: expecting function to take %d argument%s",
-	       warn_for, e_nargin, (e_nargin == 1 ? "" : "s"));
-      return 0;
-    }
-  return 1;
-}
-
-DEFUN ("is_global", Fis_global, Sis_global, 1, 1,
+DEFUN ("is_global", Fis_global, Sis_global, 10,
   "is_global (X): return 1 if the string X names a global variable\n\
 otherwise, return 0.")
 {
   Octave_object retval = 0.0;
 
   int nargin = args.length ();
 
   if (nargin != 1)
@@ -196,17 +178,17 @@ otherwise, return 0.")
 
   symbol_record *sr = curr_sym_tab->lookup (name, 0, 0);
 
   retval = (double) (sr && sr->is_linked_to_global ());
 
   return retval;
 }
 
-DEFUN ("exist", Fexist, Sexist, 1, 1,
+DEFUN ("exist", Fexist, Sexist, 10,
   "exist (NAME): check if variable or file exists\n\
 \n\
 return 0 if NAME is undefined, 1 if it is a variable, or 2 if it is\n\
 a function.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
@@ -1183,17 +1165,17 @@ maybe_list (const char *header, char **a
 	  list_in_columns (output_buf, symbols);
 	  status = 1;
 	}
       delete [] symbols;
     }
   return status;
 }
 
-DEFUN_TEXT ("document", Fdocument, Sdocument, -1, 1,
+DEFUN_TEXT ("document", Fdocument, Sdocument, 10,
   "document symbol string ...\n\
 \n\
 Associate a cryptic message with a variable name.")
 {
   Octave_object retval;
 
   DEFINE_ARGV("document");
 
@@ -1221,17 +1203,17 @@ Associate a cryptic message with a varia
 
   return retval;
 }
 
 // XXX FIXME XXX -- this should take a list of regular expressions
 // naming the variables to look for.
 
 static Octave_object
-do_who (int argc, char **argv, int nargout)
+do_who (int argc, char **argv)
 {
   Octave_object retval;
 
   int show_builtins = 0;
   int show_functions = (curr_sym_tab == top_level_sym_tab);
   int show_variables = 1;
   int show_verbose = 0;
 
@@ -1317,34 +1299,34 @@ do_who (int argc, char **argv, int nargo
     output_buf << "\n";
 
   output_buf << ends;
   maybe_page_output (output_buf);
 
   return retval;
 }
 
-DEFUN_TEXT ("who", Fwho, Swho, -1, 1,
+DEFUN_TEXT ("who", Fwho, Swho, 10,
   "who [-all] [-builtins] [-functions] [-long] [-variables]\n\
 \n\
 List currently defined symbol(s).  Options may be shortened to one\n\
 character, but may not be combined.")
 {
   Octave_object retval;
 
   DEFINE_ARGV("who");
 
-  retval = do_who (argc, argv, nargout);
+  retval = do_who (argc, argv);
 
   DELETE_ARGV;
 
   return retval;
 }
 
-DEFUN_TEXT ("whos", Fwhos, Swhos, -1, 1,
+DEFUN_TEXT ("whos", Fwhos, Swhos, 10,
   "whos [-all] [-builtins] [-functions] [-long] [-variables]\n\
 \n\
 List currently defined symbol(s).  Options may be shortened to one\n\
 character, but may not be combined.")
 {
   Octave_object retval;
 
   int nargin = args.length ();
@@ -1355,17 +1337,17 @@ character, but may not be combined.")
   tmp_args(0) = "-long";
 
   int argc = tmp_args.length () + 1;
   char **argv = make_argv (tmp_args, "whos");
 
   if (error_state)
     return retval;
 
-  retval = do_who (argc, argv, nargout);
+  retval = do_who (argc, argv);
 
   while (--argc >= 0)
     delete [] argv[argc];
   delete [] argv;
 
   return retval;
 }
 
@@ -1381,33 +1363,32 @@ install_builtin_mapper (builtin_mapper_f
   mfcn.name = strsave (mf->name);
   mfcn.can_return_complex_for_real_arg = mf->can_return_complex_for_real_arg;
   mfcn.lower_limit = mf->lower_limit;
   mfcn.upper_limit = mf->upper_limit;
   mfcn.d_d_mapper = mf->d_d_mapper;
   mfcn.d_c_mapper = mf->d_c_mapper;
   mfcn.c_c_mapper = mf->c_c_mapper;
 
-  tree_builtin *def = new tree_builtin (1, 1, mfcn, mf->name);
+  tree_builtin *def = new tree_builtin (mfcn, mf->name);
 
   sym_rec->define (def);
 
   sym_rec->document (mf->help_string);
   sym_rec->make_eternal ();
   sym_rec->protect ();
 }
 
 void
 install_builtin_function (builtin_function *f)
 {
   symbol_record *sym_rec = global_sym_tab->lookup (f->name, 1);
   sym_rec->unprotect ();
 
-  tree_builtin *def = new tree_builtin (f->nargin_max, f->nargout_max,
-					f->fcn, f->name);
+  tree_builtin *def = new tree_builtin (f->fcn, f->name);
 
   sym_rec->define (def, f->is_text_fcn);
 
   sym_rec->document (f->help_string);
   sym_rec->make_eternal ();
   sym_rec->protect ();
 }
 
@@ -1807,17 +1788,17 @@ help and usage functions");
   DEFVAR ("whitespace_in_literal_matrix",
 	  SBV_whitespace_in_literal_matrix, "", 0,
 	  whitespace_in_literal_matrix,
     "control auto-insertion of commas and semicolons in literal matrices");
 }
 
 // Deleting names from the symbol tables.
 
-DEFUN_TEXT ("clear", Fclear, Sclear, -1, 1,
+DEFUN_TEXT ("clear", Fclear, Sclear, 10,
   "clear [-x] [name ...]\n\
 \n\
 Clear symbol(s) matching a list of globbing patterns.\n\
 \n\
 If no arguments are given, clear all user-defined variables and
 functions.\n\
 \n\
 With -x, exclude the named variables")
diff --git a/src/variables.h b/src/variables.h
--- a/src/variables.h
+++ b/src/variables.h
@@ -50,18 +50,16 @@ struct builtin_variable
   char *help_string;
 };
 
 typedef Octave_object (*Octave_builtin_fcn)(const Octave_object&, int);
 
 struct builtin_function
 {
   char *name;
-  int nargin_max;
-  int nargout_max;
   int is_text_fcn;
   Octave_builtin_fcn fcn;
   char *help_string;
 };
 
 extern void initialize_symbol_tables (void);
 
 extern int lookup (symbol_record *s, int exec_script = 1);
@@ -81,17 +79,16 @@ extern void link_to_builtin_or_function 
 extern void force_link_to_function (const char *s);
 
 extern int is_builtin_variable (const char *name);
 extern int is_text_function_name (const char *name);
 extern int is_globally_visible (const char *name);
 
 extern tree_fvc *is_valid_function (const tree_constant&, char *,
 				    int warn = 0); 
-extern int takes_correct_nargs (tree_fvc *, int, char *, int warn = 0);
 
 extern char **make_name_list (void);
 
 extern void install_builtin_mapper (builtin_mapper_function *mf);
 
 extern void install_builtin_function (builtin_function *gf);
 
 extern void install_builtin_variable (builtin_variable *v);
diff --git a/src/xdiv.cc b/src/xdiv.cc
--- a/src/xdiv.cc
+++ b/src/xdiv.cc
@@ -50,29 +50,29 @@ result_ok (int info, double rcond, int w
 
       return 0;
     }
   else
     return 1;
 }
 
 static inline int
-mx_leftdiv_conform (int a_nr, int a_nc, int b_nr, int warn = 1)
+mx_leftdiv_conform (int a_nr, int b_nr)
 {
   if (a_nr != b_nr)
     {
       error ("number of rows must be the same for left division");
       return 0;
     }
 
   return 1;
 }
 
 static inline int
-mx_div_conform (int b_nr, int b_nc, int a_nc, int warn = 1)
+mx_div_conform (int b_nc, int a_nc)
 {
   if (a_nc != b_nc)
     {
       error ("number of columns must be the same for right division");
       return 0;
     }
 
   return 1;
@@ -86,17 +86,17 @@ mx_div_conform (int b_nr, int b_nc, int 
 //                  +---+----+
 //   complex_matrix | 2 |  4 |
 //                  +---+----+
 
 // -*- 1 -*-
 tree_constant
 xdiv (const Matrix& a, const Matrix& b)
 {
-  if (! mx_div_conform (b.rows (), b.columns (), a.columns ()))
+  if (! mx_div_conform (b.columns (), a.columns ()))
     return tree_constant ();
 
   Matrix atmp = a.transpose ();
   Matrix btmp = b.transpose ();
 
   int info;
   if (btmp.rows () == btmp.columns ())
     {
@@ -111,17 +111,17 @@ xdiv (const Matrix& a, const Matrix& b)
 
   return tree_constant (result.transpose ());
 }
 
 // -*- 2 -*-
 tree_constant
 xdiv (const Matrix& a, const ComplexMatrix& b)
 {
-  if (! mx_div_conform (b.rows (), b.columns (), a.columns ()))
+  if (! mx_div_conform (b.columns (), a.columns ()))
     return tree_constant ();
 
   Matrix atmp = a.transpose ();
   ComplexMatrix btmp = b.hermitian ();
 
   int info;
   if (btmp.rows () == btmp.columns ())
     {
@@ -136,17 +136,17 @@ xdiv (const Matrix& a, const ComplexMatr
 
   return tree_constant (result.hermitian ());
 }
 
 // -*- 3 -*-
 tree_constant
 xdiv (const ComplexMatrix& a, const Matrix& b)
 {
-  if (! mx_div_conform (b.rows (), b.columns (), a.columns ()))
+  if (! mx_div_conform (b.columns (), a.columns ()))
     return tree_constant ();
 
   ComplexMatrix atmp = a.hermitian ();
   Matrix btmp = b.transpose ();
 
   int info;
   if (btmp.rows () == btmp.columns ())
     {
@@ -161,17 +161,17 @@ xdiv (const ComplexMatrix& a, const Matr
 
   return tree_constant (result.hermitian ());
 }
 
 // -*- 4 -*-
 tree_constant
 xdiv (const ComplexMatrix& a, const ComplexMatrix& b)
 {
-  if (! mx_div_conform (b.rows (), b.columns (), a.columns ()))
+  if (! mx_div_conform (b.columns (), a.columns ()))
     return tree_constant ();
 
   ComplexMatrix atmp = a.hermitian ();
   ComplexMatrix btmp = b.hermitian ();
 
   int info;
   if (btmp.rows () == btmp.columns ())
     {
@@ -264,17 +264,17 @@ x_el_div (const Complex a, const Complex
 //                  +---+----+
 //   complex_matrix | 2 |  4 |
 //                  +---+----+
 
 // -*- 1 -*-
 tree_constant
 xleftdiv (const Matrix& a, const Matrix& b)
 {
-  if (! mx_leftdiv_conform (a.rows (), a.columns (), b.rows ()))
+  if (! mx_leftdiv_conform (a.rows (), b.rows ()))
     return tree_constant ();
 
   int info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
       Matrix result = a.solve (b, info, rcond);
       if (result_ok (info, rcond))
@@ -286,17 +286,17 @@ xleftdiv (const Matrix& a, const Matrix&
 
   return tree_constant (result);
 }
 
 // -*- 2 -*-
 tree_constant
 xleftdiv (const Matrix& a, const ComplexMatrix& b)
 {
-  if (! mx_leftdiv_conform (a.rows (), a.columns (), b.rows ()))
+  if (! mx_leftdiv_conform (a.rows (), b.rows ()))
     return tree_constant ();
 
   int info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
       ComplexMatrix result = a.solve (b, info, rcond);
       if (result_ok (info, rcond))
@@ -308,17 +308,17 @@ xleftdiv (const Matrix& a, const Complex
 
   return tree_constant (result);
 }
 
 // -*- 3 -*-
 tree_constant
 xleftdiv (const ComplexMatrix& a, const Matrix& b)
 {
-  if (! mx_leftdiv_conform (a.rows (), a.columns (), b.rows ()))
+  if (! mx_leftdiv_conform (a.rows (), b.rows ()))
     return tree_constant ();
 
   int info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
       ComplexMatrix result = a.solve (b, info, rcond);
       if (result_ok (info, rcond))
@@ -330,17 +330,17 @@ xleftdiv (const ComplexMatrix& a, const 
 
   return tree_constant (result);
 }
 
 // -*- 4 -*-
 tree_constant
 xleftdiv (const ComplexMatrix& a, const ComplexMatrix& b)
 {
-  if (! mx_leftdiv_conform (a.rows (), a.columns (), b.rows ()))
+  if (! mx_leftdiv_conform (a.rows (), b.rows ()))
     return tree_constant ();
 
   int info;
   if (a.rows () == a.columns ())
     {
       double rcond = 0.0;
       ComplexMatrix result = a.solve (b, info, rcond);
       if (result_ok (info, rcond))
