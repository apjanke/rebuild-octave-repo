# HG changeset patch
# User jwe
# Date 1109834432 0
#      Thu Mar 03 07:20:32 2005 +0000
# Node ID e58bbd2b9c948962e266a9544684add12f6cf305
# Parent  64fcf6e776be139d530718710070344cf008bddc
[project @ 2005-03-03 07:20:32 by jwe]

diff --git a/scripts/strings/str2double.m b/scripts/strings/str2double.m
--- a/scripts/strings/str2double.m
+++ b/scripts/strings/str2double.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004 by Alois Schloegl <a.schloegl@ieee.org>	
+## Copyright (C) 2004 by Alois Schloegl
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2, or (at your option)
 ## any later version.
 ##
@@ -12,71 +12,78 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
-## STR2DOUBLE converts strings into numeric values
-##  [NUM, STATUS,STRARRAY] = STR2DOUBLE(STR)
+## -*- texinfo -*-
+## @deftypefn {Function File} {[@var{num}, @var{status}, @var{strarray}] =} str2double (@var{str}, @var{cdelim}, @var{rdelim}, @var{ddelim})
+## Convert strings into numeric values.
 ##
-##  STR2DOUBLE can replace STR2NUM, but avoids the insecure use of EVAL
-##  on unknown data [1].
+## @code{str2double} can replace @code{str2num}, but avoids the use of
+## @code{eval} on unknown data.
 ##
-##    STR can be the form '[+-]d[.]dd[[eE][+-]ddd]'
-##	d can be any of digit from 0 to 9, [] indicate optional elements
-##    NUM is the corresponding numeric value.
-##       if the conversion fails, status is -1 and NUM is NaN.
-##    STATUS = 0: conversion was successful
-##    STATUS = -1: couldnot convert string into numeric value
-##    STRARRAY is a cell array of strings.
+## @var{str} can be the form @samp{[+-]d[.]dd[[eE][+-]ddd]} in which
+## @samp{d} can be any of digit from 0 to 9, and @samp{[]} indicate
+## optional elements.
+##
+## @var{num} is the corresponding numeric value.  If the conversion
+## fails, status is -1 and @var{num} is NaN.
 ##
-##    Elements which are not defined or not valid return NaN and
-##        the STATUS becomes -1
-##    STR can be also a character array or a cell array of strings.
-##        Then, NUM and STATUS return matrices of appropriate size.
+## @var{status} is 0 if the conversion was successful and -1 otherwise.
+##
+## @var{strarray} is a cell array of strings.
+##
+## Elements which are not defined or not valid return NaN and the
+## @var{status} becomes -1.
 ##
-##    STR can also contain multiple elements.
-##    default row-delimiters are:
-##        NEWLINE, CARRIAGE RETURN and SEMICOLON i.e. ASCII 10, 13 and 59.
-##    default column-delimiters are:
-##        TAB, SPACE and COMMA i.e. ASCII 9, 32, and 44.
-##    default decimal delimiter is '.' char(46), sometimes (e.g in
-##	Tab-delimited text files generated by Excel export in Europe)
-##	might used ',' as decimal delimiter.
+## If @var{str} is a character array or a cell array of strings, then
+## @var{num} and @var{status} return matrices of appropriate size. 
+##
+## @var{str} can also contain multiple elements separated by row and
+## column delimiters (@var{cdelim} and @var{rdelim}).
+## 
+## The parameters @var{cdelim}, @var{rdelim}, and @var{ddelim} are
+## optional column, row, and decimal delimiters.
 ##
-##  [NUM, STATUS] = STR2DOUBLE(STR,CDELIM,RDELIM,DDELIM)
-##       CDELIM .. [OPTIONAL] user-specified column delimiter
-##       RDELIM .. [OPTIONAL] user-specified row delimiter
-##       DDELIM .. [OPTIONAL] user-specified decimal delimiter
-##       CDELIM, RDELIM and DDELIM must contain only
-##       NULL, NEWLINE, CARRIAGE RETURN, SEMICOLON, COLON, SLASH, TAB, SPACE, COMMA, or ()[]{}
-##       i.e. ASCII 0,9,10,11,12,13,14,32,33,34,40,41,44,47,58,59,91,93,123,124,125
+## The default row-delimiters are newline, carriage return and semicolon
+## (ASCII 10, 13 and 59).  The default column-delimiters are tab, space
+## and comma (ASCII 9, 32, and 44).  The default decimal delimiter is
+## @samp{.} (ASCII 46).
 ##
-##    Examples:
-##	str2double('-.1e-5')
-##	   ans = -1.0000e-006
+## @var{cdelim}, @var{rdelim}, and @var{ddelim} must contain only nul,
+## newline, carriage return, semicolon, colon, slash, tab, space, comma,
+## or @samp{()[]@{@}} (ASCII 0, 9, 10, 11, 12, 13, 14, 32, 33, 34, 40,
+## 41, 44, 47, 58, 59, 91, 93, 123, 124, 125).
+##
+## Examples:
+##
+## @example
+## str2double ("-.1e-5")
+## @result{} -1.0000e-006
 ##
-## 	str2double('.314e1, 44.44e-1, .7; -1e+1')
-##	ans =
-##	    3.1400    4.4440    0.7000
-##	  -10.0000       NaN       NaN
+## str2double (".314e1, 44.44e-1, .7; -1e+1")
+## @result{}
+##    3.1400    4.4440    0.7000
+##  -10.0000       NaN       NaN
 ##
-##	line ='200,300,400,NaN,-inf,cd,yes,no,999,maybe,NaN';
-##	[x,status]=str2double(line)
-##	x =
-##	   200   300   400   NaN  -Inf   NaN   NaN   NaN   999   NaN   NaN
-##	status =
-##	    0     0     0     0     0    -1    -1    -1     0    -1     0
-##
-## Reference(s):
-## [1] David A. Wheeler, Secure Programming for Linux and Unix HOWTO.
-##    http://en.tldp.org/HOWTO/Secure-Programs-HOWTO/
+## line = "200,300,400,NaN,-inf,cd,yes,no,999,maybe,NaN";
+## [x, status] = str2double (line)
+## x =
+##    200   300   400   NaN  -Inf   NaN   NaN   NaN   999   NaN   NaN
+## status =
+##     0     0     0     0     0    -1    -1    -1     0    -1     0
+## @end example
+## @end deftypefn
+
+## Author: Alois Schloegl <a.schloegl@ieee.org>
+## Adapted-by: jwe
 
 function [num, status, strarray] = str2double (s, cdelim, rdelim, ddelim)
 
   FLAG_OCTAVE = exist('OCTAVE_VERSION','builtin');
 
   ## digits, sign, exponent,NaN,Inf
   ## valid_char = '0123456789eE+-.nNaAiIfF';
 
@@ -253,17 +260,17 @@ function [num, status, strarray] = str2d
 	if (strcmpi (t(l:end), "inf"))
 	  num(k1,k2) = v*Inf;
 	elseif (strcmpi (t(l:end), "NaN"));
 	  num(k1,k2) = NaN;
 	else
 	  if (ddelim == ".")
 	    t(t==ddelim) = ".";
 	  endif
-	  [v,tmp2,c] = sscanf(char(t), "%f %s", "C");
+	  [v, tmp2, c] = sscanf(char(t), "%f %s", "C");
 	  ## [v,c,em,ni] = sscanf(char(t),"%f %s");
 	  ## c = c * (ni>length(t));
 	  if (c == 1),
 	    num(k1,k2) = v;
 	  else
 	    num(k1,k2) = NaN;
 	    status(k1,k2) = -1;
 	  endif
