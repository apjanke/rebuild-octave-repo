# HG changeset patch
# User jwe
# Date 945905774 0
#      Wed Dec 22 23:36:14 1999 +0000
# Node ID 18366d37e7dd22cd5070c2da7b6107680a0b8575
# Parent  e665633c76aff0f35a949f8106e28dda9f0b4b91
[project @ 1999-12-22 23:36:09 by jwe]

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,11 +1,36 @@
 1999-12-22  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* control/d2c.m: Use double quotes instead of single quotes for
+	string constants.
+	* control/dgkfdemo.m: Likewise.
+	* control/fir2sys.m: Likewise.
+	* control/frdemo.m: Likewise.
+	* control/moddemo.m: Likewise.
+	* control/minfo.m: Likewise.
+	* control/is_stabilizable.m: Likewise.
+	* control/is_dgkf.m: Likewise.
+	* control/polyout.m: Likewise.
+	* control/sysconnect.m: Likewise.
+	* control/sysrepdemo.m: Likewise.
+	* control/tf2sys.m: Likewise.
+	* control/tfout.m: Likewise.
+	* control/zp2sys.m: Likewise.
+	* control/zpout.m: Likewise.
+	* control/tzero.m: Likewise.
+
+	* control/DEMOcontrol.m: Handle moddemo case too.
+
+	* image/loadimage.m: Use double quotes instead of single quotes
+	for string constants.  Use sprintf instead of square brackets to
+	construct string.
+
 	* control/DEMOcontrol.m: Formatting tweaks.
+	* control/fir2sys.m: Likewise.
 
 1999-12-17  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* mkdoc: Only delete spaces before @ characters at the beginning
 	of a line.
 
 1999-12-15  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
diff --git a/scripts/control/DEMOcontrol.m b/scripts/control/DEMOcontrol.m
--- a/scripts/control/DEMOcontrol.m
+++ b/scripts/control/DEMOcontrol.m
@@ -55,26 +55,28 @@ function DEMOcontrol ()
     k = 0;
 
     while (k > 8 || k < 1),
       k = menu ("Octave Controls System Toolbox Demo",
 		"System representation",
     		"Block diagram manipulations",
     		"Frequency response functions",
     		"State space analysis functions",
+    		"System model manipulations",
     		"Root locus functions",
 		"LQG/H2/Hinfinity functions",
     		"End");
     endwhile
 
     switch (k)
       case (1) sysrepdemo ();
       case (2) bddemo ();
       case (3) frdemo ();
       case (4) analdemo ();
-      case (5) rldemo ();
-      case (6) dgkfdemo ();
-      case (7) return;
+      case (5) moddemo ();
+      case (6) rldemo ();
+      case (7) dgkfdemo ();
+      case (8) return;
     endswitch
 
   endwhile
 
 endfunction
diff --git a/scripts/control/bddemo.m b/scripts/control/bddemo.m
--- a/scripts/control/bddemo.m
+++ b/scripts/control/bddemo.m
@@ -54,17 +54,17 @@ function bddemo ()
       clc
       disp("sysadd: add two systems together")
       disp("syssub: subtract F = G - H")
       prompt
       help sysadd
       prompt
       help syssub
       prompt
-      disp('Example #1, \n')
+      disp("Example #1, \n")
       cmd = "sys1 = tf2sys([1 -1],[1 2 1]);";
       run_cmd
       cmd = "sys2 = tf2sys([1 -1],[1 2 3]);";
       run_cmd
       disp("sys1=")
       sysout(sys1);
       prompt
       disp("sys2=")
diff --git a/scripts/control/bode.m b/scripts/control/bode.m
--- a/scripts/control/bode.m
+++ b/scripts/control/bode.m
@@ -181,17 +181,17 @@ function [mag_r, phase_r, w_r] = bode (s
       semilogx(w,md);
     else
       loglog(w,md);
     endif
     if (is_siso(sys))
       if (gnuplot_has_multiplot)
         subplot(2,1,2);
       else
-        prompt('Press any key for phase plot');
+        prompt("Press any key for phase plot");
       endif
       axvec = axis2dlim([vec(w),vec(phase)]);
       axvec(1:2) = wv;
       axis(axvec);
       xlabel(xlstr);
       ylabel("Phase in deg");
       title([ "phase([Y/U]", tistr, ...
 	 "), u=", nth(inname,1),", y=",nth(outname,1)]);
diff --git a/scripts/control/controldemo.m b/scripts/control/controldemo.m
--- a/scripts/control/controldemo.m
+++ b/scripts/control/controldemo.m
@@ -17,46 +17,11 @@
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## Controls toolbox demo.
 ## Demo programs: bddemo.m, frdemo.m, analdemo.m, moddmeo.m, rldemo.m
 
 ## Author: David Clem
 ## Created: August 15, 1994
 
-function DEMOcontrol ()
-
-  disp(' O C T A V E    C O N T R O L   S Y S T E M S   T O O L B O X')
-
-  while (1)
-    clc
-    k = 0;
-    while (k > 8 || k < 1),
-      k = menu("Octave Controls System Toolbox Demo", ...
-	'System representation', ...
-    	'Block diagram manipulations ', ...
-    	'Frequency response functions ', ...
-    	'State space analysis functions ', ...
-    	'System model manipulations ', ...
-    	'Root locus functions ', ...
-	'LQG/H2/Hinfinity functions ', ...
-    	'End');
-
-    endwhile
-    if(k == 1)
-      sysrepdemo
-    elseif (k == 2)
-      bddemo
-    elseif (k == 3)
-      frdemo
-    elseif (k == 4)
-      analdemo
-    elseif (k == 5)
-      moddemo
-    elseif (k == 6)
-      rldemo
-    elseif (k == 7)
-      dgkfdemo
-    elseif (k == 8)
-      return
-    endif
-  endwhile
+function controldemo ()
+  DEMOcontrol ();
 endfunction
diff --git a/scripts/control/d2c.m b/scripts/control/d2c.m
--- a/scripts/control/d2c.m
+++ b/scripts/control/d2c.m
@@ -169,18 +169,18 @@ function csys = d2c (sys, opt)
         DMall = [DMtop; zeros(nb,na+nb) ];
       endif
   
       if(newgrad)
         GrMall = zeros(size(Mall));
         for ii=1:rows(Mtop)
           for jj=1:columns(Mtop)
   	  DMall(ii,jj) = Mall(ii,jj) + geps;
-            GrMall(ii,jj) = norm(Amat - expm(DMall*T),'fro') ...
-  	    - norm(Amat-expm(Mall*T),'fro');
+            GrMall(ii,jj) = norm (Amat - expm (DMall*T), "fro") ...
+  		- norm (Amat - expm (Mall*T), "fro");
       	  DMall(ii,jj) = Mall(ii,jj);
           endfor
         endfor
         GrMall = GrMall/norm(GrMall,1);
         newgrad = 0;
       endif
   
       ## got a gradient, now try to use it
diff --git a/scripts/control/dgkfdemo.m b/scripts/control/dgkfdemo.m
--- a/scripts/control/dgkfdemo.m
+++ b/scripts/control/dgkfdemo.m
@@ -25,75 +25,75 @@
 ## Created: June 1995
 
 function dgkfdemo ()
  
   save_val = page_screen_output;
   page_screen_output = 1;
   while (1)
     clc
-    menuopt=0;
-    while(menuopt > 10 || menuopt < 1)
-      menuopt = menu('Octave H2/Hinfinity options demo', ...
-	    'LQ regulator', ...
-	    'LG state estimator', ...
-	    'LQG optimal control design', ...
-	    'H2 gain of a system', ...
-	    'H2 optimal controller of a system', ...
-	    'Hinf gain of a system', ...
-	    'Hinf optimal controller of a SISO system', ...
-	    'Hinf optimal controller of a MIMO system', ...
-	    'Discrete-time Hinf optimal control by bilinear transform', ...
-	    'Return to main demo menu');
+    sel = 0;
+    while (sel > 10 || sel < 1)
+      sel = menu ("Octave H2/Hinfinity options demo",
+		  "LQ regulator",
+		  "LG state estimator",
+		  "LQG optimal control design",
+		  "H2 gain of a system",
+		  "H2 optimal controller of a system",
+		  "Hinf gain of a system",
+		  "Hinf optimal controller of a SISO system",
+		  "Hinf optimal controller of a MIMO system",
+		  "Discrete-time Hinf optimal control by bilinear transform",
+		  "Return to main demo menu");
     endwhile
-    if (menuopt == 1)
-      disp('Linear/Quadratic regulator design:')
-      disp('Compute optimal state feedback via the lqr command...')
+    if (sel == 1)
+      disp("Linear/Quadratic regulator design:")
+      disp("Compute optimal state feedback via the lqr command...")
       help lqr
-      disp(' ')
-      disp('Example:')
+      disp(" ")
+      disp("Example:")
       A = [0, 1; -2, -1]
       B = [0; 1]
       Q = [1, 0; 0, 0]
       R = 1
       disp("Q = state penalty matrix; R = input penalty matrix")
       prompt
-      disp('Compute state feedback gain k, ARE solution P, and closed-loop')
-      disp('poles as follows:');
+      disp("Compute state feedback gain k, ARE solution P, and closed-loop")
+      disp("poles as follows:");
       cmd = "[k, p, e] = lqr(A,B,Q,R)";
       run_cmd
       prompt
       disp("A similar approach can be used for LTI discrete-time systems")
       disp("by using the dlqr command in place of lqr (see LQG example).")
-    elseif (menuopt == 2)
-      disp('Linear/Gaussian estimator design:')
-      disp('Compute optimal state estimator via the lqe command...')
+    elseif (sel == 2)
+      disp("Linear/Gaussian estimator design:")
+      disp("Compute optimal state estimator via the lqe command...")
       help lqe
-      disp(' ')
-      disp('Example:')
+      disp(" ")
+      disp("Example:")
       A = [0, 1; -2, -1]
       disp("disturbance entry matrix G")
       G = eye(2)
       disp("Output measurement matrix C")
       C = [0, 1]
       SigW = [1, 0; 0, 1]
       SigV = 1
       disp("SigW = input disturbance intensity matrix;")
       disp("SigV = measurement noise intensity matrix")
       prompt
-      disp('Compute estimator feedback gain k, ARE solution P, and estimator')
-      disp('poles via the command: ')
+      disp("Compute estimator feedback gain k, ARE solution P, and estimator")
+      disp("poles via the command: ")
       cmd = "[k, p, e] = lqe(A,G,C,SigW,SigV)";
       run_cmd
       disp("A similar approach can be used for LTI discrete-time systems")
       disp("by using the dlqe command in place of lqe (see LQG example).")
-    elseif (menuopt == 3)
-      disp('LQG optimal controller of a system:')
-      disp('Input accepted as either A,B,C matrices or in system data structure form')
-      disp('in both discrete and continuous time.')
+    elseif (sel == 3)
+      disp("LQG optimal controller of a system:")
+      disp("Input accepted as either A,B,C matrices or in system data structure form")
+      disp("in both discrete and continuous time.")
       disp("Example 1: continuous time design:")
       prompt
       help lqg
       disp("Example system")
       A = [0, 1; .5, .5];
       B = [0; 2];
       G = eye(2)
       C = [1, 1];
@@ -137,57 +137,57 @@ function dgkfdemo ()
       disp(" [Bc*C,   Ac  ]")
       [Ac,Bc,Cc] = sys2ss(K);
       Acl = [A, B*Cc; Bc*C, Ac]
       prompt
       disp("Check: poles of Acl:")
       Acl_poles = sortcom(eig(Acl))
       disp("Predicted poles from design = union(Er,Ee)")
       pred_poles = sortcom([Er;Ee])
-    elseif (menuopt == 4)
-      disp('H2 gain of a system: (Energy in impulse response)')
-      disp('Example 1: Stable plant:')
+    elseif (sel == 4)
+      disp("H2 gain of a system: (Energy in impulse response)")
+      disp("Example 1: Stable plant:")
       cmd = "A = [0, 1; -2, -1]; B = [0; 1]; C = [1, 0]; sys_poles = eig(A)";
       run_cmd
       disp("Put into Packed system form:")
       cmd = "Asys = ss2sys(A,B,C);";
       run_cmd
       disp("Evaluate system 2-norm (impulse response energy):");
       cmd = "AsysH2 = h2norm(Asys)";
       run_cmd
       disp("Compare with a plot of the system impulse response:")
       tt = 0:0.1:20;
       for ii=1:length(tt)
         ht(ii) = C*expm(A*tt(ii))*B;
       endfor
       plot(tt,ht)
       title("impulse response of example plant")
       prompt
-      disp('Example 2: unstable plant')
+      disp("Example 2: unstable plant")
       cmd = "A = [0, 1; 2, 1]";
       eval(cmd);
       cmd = "B = [0; 1]";
       eval(cmd);
       cmd = "C = [1, 0]";
       eval(cmd);
       cmd = "sys_poles = eig(A)";
       run_cmd
       prompt
-      disp('Put into system data structure form:')
+      disp("Put into system data structure form:")
       cmd="Bsys = ss2sys(A,B,C);";
       run_cmd
-      disp('Evaluate 2-norm:')
+      disp("Evaluate 2-norm:")
       cmd = "BsysH2 = h2norm(Bsys)";
       run_cmd
-      disp(' ')
-      prompt('NOTICE: program returns a value without an error signal.')
-      disp('')
+      disp(" ")
+      prompt("NOTICE: program returns a value without an error signal.")
+      disp("")
 
-    elseif (menuopt == 5)
-      disp('H2 optimal controller of a system: command = h2syn:')
+    elseif (sel == 5)
+      disp("H2 optimal controller of a system: command = h2syn:")
       prompt
       help h2syn
       prompt
       disp("Example system: double integrator with output noise and")
       disp("input disturbance:")
       disp(" ");
       disp("       -------------------->y2");
       disp("       |   _________");
@@ -239,56 +239,56 @@ function dgkfdemo ()
       cmd="gain_err = gain_Kcl - gain";
       run_cmd
       disp("Check: multivarible bode plot:")
       cmd="bode(Kcl);";
       run_cmd
       prompt
       disp("Related functions: is_dgkf, is_controllable, is_stabilizable,")
       disp("                is_observable, is_detectable")
-    elseif (menuopt == 6)
-      disp('Hinfinity gain of a system: (max gain over all j-omega)')
-      disp('Example 1: Stable plant:')
+    elseif (sel == 6)
+      disp("Hinfinity gain of a system: (max gain over all j-omega)")
+      disp("Example 1: Stable plant:")
       cmd = "A = [0, 1; -2, -1]; B = [0; 1]; C = [1, 0]; sys_poles = eig(A)";
       run_cmd
-      disp('Pack into system format:')
+      disp("Pack into system format:")
       cmd = "Asys = ss2sys(A,B,C);";
       run_cmd
-      disp('The infinity norm must be computed iteratively by')
-      disp('binary search.  For this example, we select tolerance tol = 0.01, ')
-      disp('min gain gmin = 1e-2, max gain gmax=1e4.')
-      disp('Search quits when upper bound <= (1+tol)*lower bound.')
+      disp("The infinity norm must be computed iteratively by")
+      disp("binary search.  For this example, we select tolerance tol = 0.01, ")
+      disp("min gain gmin = 1e-2, max gain gmax=1e4.")
+      disp("Search quits when upper bound <= (1+tol)*lower bound.")
       cmd = "tol = 0.01; gmin = 1e-2; gmax = 1e+4;";
       run_cmd
       cmd = "[AsysHinf,gmin,gmax] = hinfnorm(Asys,tol,gmin,gmax)"
       run_cmd
       disp("Check: look at max value of magntude Bode plot of Asys:");
       [M,P,w] = bode(Asys);
-      xlabel('Omega')
-      ylabel('|Asys(j omega)| ')
+      xlabel("Omega")
+      ylabel("|Asys(j omega)| ")
       grid();
       semilogx(w,M);
       disp(["Max magnitude is ",num2str(max(M)), ...
 	", compared with gmin=",num2str(gmin)," and gmax=", ...
         num2str(gmax),"."])
       prompt
-      disp('Example 2: unstable plant')
+      disp("Example 2: unstable plant")
       cmd = "A = [0, 1; 2, 1]; B = [0; 1]; C = [1, 0]; sys_poles = eig(A)";
       run_cmd
       disp("Pack into system format:")
       cmd = "Bsys = ss2sys(A,B,C);";
       run_cmd
-      disp('Evaluate with BsysH2 = hinfnorm(Bsys,tol,gmin,gmax)')
+      disp("Evaluate with BsysH2 = hinfnorm(Bsys,tol,gmin,gmax)")
       BsysH2 = hinfnorm(Bsys,tol,gmin,gmax)
-      disp(' ')
-      disp('NOTICE: program returns a value without an error signal.')
-      disp('')
+      disp(" ")
+      disp("NOTICE: program returns a value without an error signal.")
+      disp("")
 
-    elseif (menuopt == 7)
-      disp('Hinfinity optimal controller of a system: command = hinfsyn:')
+    elseif (sel == 7)
+      disp("Hinfinity optimal controller of a system: command = hinfsyn:")
       prompt
       help hinfsyn
       prompt
       disp("Example system: double integrator with output noise and")
       disp("input disturbance:")
       A = [0, 1; 0, 0]
       B1 = [0, 0; 1, 0]
       B2 = [0; 1]
@@ -327,28 +327,28 @@ function dgkfdemo ()
       cmd="gain_err = gain_Kcl - gain";
       run_cmd
       disp("Check: multivarible bode plot:")
       cmd="bode(Kcl);";
       run_cmd
       prompt
       disp("Related functions: is_dgkf, is_controllable, is_stabilizable,")
       disp("                   is_observable, is_detectable, buildssic")
-    elseif (menuopt == 8)
-      disp('Hinfinity optimal controller of MIMO system: command = hinfsyn:')
+    elseif (sel == 8)
+      disp("Hinfinity optimal controller of MIMO system: command = hinfsyn:")
       prompt
       help hinfsyn
       prompt
       disp("Example system: Boeing 707-321 airspeed/pitch angle control")
       disp(" ")
       hinfdemo
-    elseif (menuopt == 9)
+    elseif (sel == 9)
       disp("Discrete time H-infinity control via bilinear transform");
       prompt
       dhinfdemo
-    elseif (menuopt == 10)
+    elseif (sel == 10)
       return
     endif
     prompt
   endwhile  
   page_screen_output = save_val;
 
 endfunction
diff --git a/scripts/control/fir2sys.m b/scripts/control/fir2sys.m
--- a/scripts/control/fir2sys.m
+++ b/scripts/control/fir2sys.m
@@ -72,27 +72,34 @@
 ## Name changed to TF2SYS July 1995
 ## updated for new system data structure format July 1996
 ## adapted from tf2sys july 1996
 
 function sys = fir2sys (num, tsam, inname, outname)
 
   ## Test for the correct number of input arguments
   if (nargin < 1 | nargin > 4)
-    usage('sys=fir2sys(num[,tsam,inname,outname])');
+    usage ("sys = fir2sys(num [, tsam, inname, outname])");
   endif
 
   ## let tf2sys do the argument checking
   den = [1,zeros(1,length(num)-1)];
 
   ## check sampling interval (if any)
-  if(nargin <= 1)               tsam = 1;		# default 
-  elseif (isempty(tsam))        tsam = 1;		endif
+  if (nargin <= 1)
+    tsam = 1;		# default 
+  elseif (isempty(tsam))
+    tsam = 1;
+  endif
 
   ## Set name of input
-  if(nargin < 3)  inname = sysdefioname(1,"u");        endif
+  if (nargin < 3)
+    inname = sysdefioname (1, "u");
+  endif
 
   ## Set name of output
-  if(nargin < 4)  outname = sysdefioname(1,"y"); 	endif
+  if (nargin < 4)
+    outname = sysdefioname (1, "y");
+  endif
 
-  sys = tf2sys(num,den,tsam,inname,outname);
+  sys = tf2sys (num, den, tsam, inname, outname);
   
 endfunction
diff --git a/scripts/control/frdemo.m b/scripts/control/frdemo.m
--- a/scripts/control/frdemo.m
+++ b/scripts/control/frdemo.m
@@ -28,33 +28,33 @@
 
 function frdemo ()
 
   disp("")
   clc
   j = 0;
   while (j != 4)
     disp("");
-    j = menu("Octave Controls Systems Toolbox Frequency Response Demo",...
-             'Bode analysis (bode)',...
-             'Nyquist analysis (nyquist)',...
-	     "Nichols analysis (nichols)", ...
-             'Return to main demo menu');
+    j = menu("Octave Controls Systems Toolbox Frequency Response Demo",
+             "Bode analysis (bode)",
+             "Nyquist analysis (nyquist)",
+	     "Nichols analysis (nichols)", 
+             "Return to main demo menu");
    
     if (j == 1)
       k1 = 0;
       while (k1 != 4)
         disp("\n");
         clc
 
-        k1 = menu("Bode analysis (bode)",...
-                  'Continuous system bode analysis',...
-                  'Discrete system bode analysis',...
-                  'Bode command description', ...
-                  'Return to frdemo menu');
+        k1 = menu("Bode analysis (bode)",
+                  "Continuous system bode analysis",
+                  "Discrete system bode analysis",
+                  "Bode command description", 
+                  "Return to frdemo menu");
        
         if( k1 == 1 )
           disp(" ")
           clc  
           disp("\nContinuous system bode analysis\n");
           disp("Example #1:")
           disp("\nConsider the system sys1=");
           sys1=tf2sys([1, 1], [1, 0, -1]);
@@ -142,17 +142,17 @@ function frdemo ()
           cmd = "sys_mimo = sysgroup(sys2,sys3);";
           disp(cmd); eval(cmd);
           disp("The resulting state-space system (after changing signal names");
           disp("in sys2) is");
           cmd = "sysout(sys_mimo)";
           eval(cmd);
           disp("\nNotice that there are now 2 inputs and 2 outputs, and that it did");
  	  disp("not matter what form the two systems were in when they were grouped.");
-          disp(["\nTo view the system\'s bode plots, execute the",...
+          disp(["\nTo view the system's bode plots, execute the",
         	" following command:\n"])
           cmd = "bode(sys_mimo);";
           run_cmd;
           prompt
           disp("\nTo view the bode plots for selected  channels, the command form changes:")
           cmd = "wrange = [];";
           disp(cmd)
           eval(cmd);
@@ -306,21 +306,21 @@ function frdemo ()
       disp("");
       while (k2 != 4)
         disp("\n");
         help nyquist
         prompt;
         disp("")
         clc;
 
-        k2 = menu("Nyquist analysis (Nyquist)",...
-                  'Continuous system nyquist analysis',...
-        	  'Discrete system nyquist analysis',...
-        	  'Mixed system nyquist analysis',...
-                  'Return to frdemo menu');
+        k2 = menu("Nyquist analysis (Nyquist)",
+                  "Continuous system nyquist analysis",
+        	  "Discrete system nyquist analysis",
+        	  "Mixed system nyquist analysis",
+                  "Return to frdemo menu");
 
         if( k2 == 1 )
           disp("")
           clc
  	  disp("\nContinuous system nyquist analysis\n");
       	  disp("Display Nyquist plots of a SISO system (nyquist)\n")
       	  disp("Example #1, Consider the following transfer function:\n")
           cmd = "sys1 = tf2sys(1, [1, 0.8, 1]);";
diff --git a/scripts/control/is_dgkf.m b/scripts/control/is_dgkf.m
--- a/scripts/control/is_dgkf.m
+++ b/scripts/control/is_dgkf.m
@@ -146,17 +146,17 @@ function [retval, dgkf_struct] = is_dgkf
     error("is_dgkf: insufficient number of regulated outputs");
   endif
 
   nw = nin - nu;           nw1 = nw + 1;
   nz = nout - ny;          nz1 = nz + 1;
 
   [A,B,C,D] = sys2ss(Asys);
   ## scale input/output for numerical reasons
-  if(norm(C,'fro')*norm(B,'fro') == 0)
+  if(norm (C, "fro") * norm (B, "fro") == 0)
     error("||C||*||B|| = 0; no dynamic connnection from inputs to outputs");
   endif
   xx = sqrt(norm(B, Inf) / norm(C, Inf));
   B = B / xx;  C = C * xx;
 
   ## partition matrices
   			Bw = B(:,1:nw);		Bu = B(:,nw1:nin);
   Cz = C(1:nz,:);	Dzw = D(1:nz,1:nw);	Dzu = D(1:nz,nw1:nin);
diff --git a/scripts/control/is_stabilizable.m b/scripts/control/is_stabilizable.m
--- a/scripts/control/is_stabilizable.m
+++ b/scripts/control/is_stabilizable.m
@@ -70,17 +70,17 @@ function [retval, U] = is_stabilizable (
     [retval,U] = is_controllable(a,b);
     tol = 1e2*rows(b)*eps;
   endif
   
   if( !retval & columns(U) > 0)
     ## now use an ordered Schur decomposition to get an orthogonal
     ## basis of the unstable subspace...
     n = rows(a);
-    [ua,s] = schur(-(a+eye(n)*tol),'A');
+    [ua, s] = schur (-(a+eye(n)*tol), "A");
     k = sum( real(eig(a)) >= 0 );	# count unstable poles 
 
     if( k > 0 )
       ua = ua(:,1:k);
       ## now see if span(ua) is contained in span(U)
       retval = (norm(ua - U*U'*ua) < tol);
     else
       retval = 1;			# all poles stable
diff --git a/scripts/control/minfo.m b/scripts/control/minfo.m
--- a/scripts/control/minfo.m
+++ b/scripts/control/minfo.m
@@ -34,17 +34,17 @@
 ## Modified by David Clem November 13, 1994
 ## Modified by A. S. Hodel July 1995
 
 function [systype, nout, nin, ncstates, ndstates] = minfo (inmat)
 
   warning("minfo: obsolete.  Use sys2ss, sys2tf, or sys2zp.");
     
   if (nargin ~= 1 )
-    disp('MINFO: Wrong number of arguments')
+    disp ("MINFO: Wrong number of arguments")
     systype = nout = nin = ncstates = ndstates = [];
   endif
   
   [rr,cc] = size(inmat);
   
   ## Check for empty matrix first!
   if (isempty(inmat))
     systype = "empty";
diff --git a/scripts/control/moddemo.m b/scripts/control/moddemo.m
--- a/scripts/control/moddemo.m
+++ b/scripts/control/moddemo.m
@@ -28,182 +28,182 @@
 ## Author: David Clem
 ## Created: August 15, 1994
 ## a s hodel: updated to reflect updated output order in ss2zp
 
 function moddemo ()
 
   while (1)
     clc
-    disp('Octave Model Manipulations Demo')
-    disp('=======================================')
-    disp('  1)  Perform continuous to discrete time conversion (c2d)')
-    disp('  2)  Convert from state space to zero / pole form (ss2zp)')
-    disp('      Convert from zero / pole to state space form (zp2ss)')
-    disp('  3)  Convert from state space to transfer function form (ss2tf)')
-    disp('      Convert from transfer function to state space form (tf2ss)')
-    disp('  4)  Convert from transfer function to zero / pole form (tf2zp)')
-    disp('      Convert from zero / pole to transfer function form (zp2tf)')
-    disp('  5)  Return to main demo menu')
-    disp(' ')
+    disp("Octave Model Manipulations Demo")
+    disp("=======================================")
+    disp("  1)  Perform continuous to discrete time conversion (c2d)")
+    disp("  2)  Convert from state space to zero / pole form (ss2zp)")
+    disp("      Convert from zero / pole to state space form (zp2ss)")
+    disp("  3)  Convert from state space to transfer function form (ss2tf)")
+    disp("      Convert from transfer function to state space form (tf2ss)")
+    disp("  4)  Convert from transfer function to zero / pole form (tf2zp)")
+    disp("      Convert from zero / pole to transfer function form (zp2tf)")
+    disp("  5)  Return to main demo menu")
+    disp(" ")
     k=6;
     while(k > 5 || k < 1)
-      k = input('Please enter a number:');
+      k = input("Please enter a number:");
     endwhile
     if (k == 1)
       clc
-      disp('Perform continuous to discrete time conversion (c2d)\n')
-      disp('Example #1, Consider the following continuous time state space system:\n')
+      disp("Perform continuous to discrete time conversion (c2d)\n")
+      disp("Example #1, Consider the following continuous time state space system:\n")
       a=[0, 1; -25, -4]
       b=[0; 1]
       c=[1, 1]
       d=1
       prompt
-      disp('\nTo convert this to a discrete time system (using a zero order hold),')
-      disp('use the following commands:\n')
+      disp("\nTo convert this to a discrete time system (using a zero order hold),")
+      disp("use the following commands:\n")
       cmd="sys=ss2sys(a,b,c,d);";
       run_cmd
       cmd="dsys = c2d(sys,0.2);";
       run_cmd
       cmd="sysout(dsys);";
       run_cmd
-      disp('Function check\n')
-      disp('Check the poles of sys vs dsys:\n')
+      disp("Function check\n")
+      disp("Check the poles of sys vs dsys:\n")
       cmd="[da,db]=sys2ss(dsys);";
       run_cmd
       cmd="lam = eig(a);";
       run_cmd
-      disp('Discretize the continuous time eigenvalues using the matrix exponential:\n')
-      disp('lambc = exp(lam*0.2)\n')
+      disp("Discretize the continuous time eigenvalues using the matrix exponential:\n")
+      disp("lambc = exp(lam*0.2)\n")
       lambc = exp(lam*0.2)
-      disp('Check the eigenvalues of da\n')
+      disp("Check the eigenvalues of da\n")
       lambd = eig(da)
-      disp('Calculate the difference between lambd and lambc:\n')
-      cmd = 'error = sort(lambd)-sort(lambc)\n';
+      disp("Calculate the difference between lambd and lambc:\n")
+      cmd = "error = sort(lambd)-sort(lambc)\n";
       run_cmd
       disp("The error is on the order of roundoff noise, so we're o.k.")
       prompt
       clc
     elseif (k == 2)
       clc
-      disp('Convert from state space to zero / pole form (ss2zp)\n')
-      disp('Example #1, Consider the following state space system:\n')
+      disp("Convert from state space to zero / pole form (ss2zp)\n")
+      disp("Example #1, Consider the following state space system:\n")
       a=[0, 3, 1; -2, -4, 5; 5, 8, 2]
       b=[0; 5; 2.5]
       c=[6, -1.9, 2]
       d=[-20]
       prompt
-      disp(' ')
-      disp('\nTo find the poles and zeros of this sytstem, use the following command:\n')
-      disp('\n[zer, pol] = ss2zp(a, b, c, d)\n')
+      disp(" ")
+      disp("\nTo find the poles and zeros of this sytstem, use the following command:\n")
+      disp("\n[zer, pol] = ss2zp(a, b, c, d)\n")
       prompt
-      disp('Results:\n')
+      disp("Results:\n")
       [zer, pol] = ss2zp(a, b, c, d)
-      disp('Variable Description:\n')
-      disp('zer, pol => zeros and poles of the state space system')
-      disp('a, b, c, d => state space system\n')
+      disp("Variable Description:\n")
+      disp("zer, pol => zeros and poles of the state space system")
+      disp("a, b, c, d => state space system\n")
       prompt
       clc
-      disp('Convert from zero / pole to state space form (zp2ss)\n')
-      disp('Example #1, Consider the following set of zeros and poles:\n')
+      disp("Convert from zero / pole to state space form (zp2ss)\n")
+      disp("Example #1, Consider the following set of zeros and poles:\n")
       zer
       pol
       prompt
-      disp('\nTo find an equivalent state space representation for this set of poles')
-      disp('and zeros, use the following commands:\n')
+      disp("\nTo find an equivalent state space representation for this set of poles")
+      disp("and zeros, use the following commands:\n")
       k=1
-      disp('\n[na, nb, nc, nd] = zp2ss(zer, pol, k)\n')
+      disp("\n[na, nb, nc, nd] = zp2ss(zer, pol, k)\n")
       prompt
-      disp('Results:\n')
+      disp("Results:\n")
       [na, nb, nc, nd] = zp2ss(zer, pol, k)
-      disp('Variable Description:\n')
-      disp('na, nb, nc, nd => state space system equivalent to zero / pole input')
-      disp('zer, pol => zeros and poles of desired state space system')
-      disp('k => gain associated with the zeros\n')
+      disp("Variable Description:\n")
+      disp("na, nb, nc, nd => state space system equivalent to zero / pole input")
+      disp("zer, pol => zeros and poles of desired state space system")
+      disp("k => gain associated with the zeros\n")
       prompt
-      disp('Function check\n')
-      disp('Are the eigenvalues of the origonal state space system the same as the')
-      disp('eigenvalues of the newly constructed state space system ?\n')
-      disp('Find the difference between the two sets of eigenvalues')
-      disp('error = sort(eig(a)) - sort(eig(na))\n')
+      disp("Function check\n")
+      disp("Are the eigenvalues of the origonal state space system the same as the")
+      disp("eigenvalues of the newly constructed state space system ?\n")
+      disp("Find the difference between the two sets of eigenvalues")
+      disp("error = sort(eig(a)) - sort(eig(na))\n")
       error = sort(eig(a)) - sort(eig(na))
       prompt
       clc
     elseif (k == 3)
       clc
-      disp('Convert from state space to transfer function (ss2tf)\n')
-      disp('Example #1, Consider the following state space system:\n')
+      disp("Convert from state space to transfer function (ss2tf)\n")
+      disp("Example #1, Consider the following state space system:\n")
       a=[0, 1; -2, -3]
       b=[1; 1]
       c=[1, 9]
       d=[1]
       prompt
-      disp('\nTo find an equivalent transfer function for this system, use')
-      disp('the following command:\n')
-      disp('[num, den] = ss2tf(a, b, c, d)\n')
+      disp("\nTo find an equivalent transfer function for this system, use")
+      disp("the following command:\n")
+      disp("[num, den] = ss2tf(a, b, c, d)\n")
       prompt
-      disp('Results:\n')
+      disp("Results:\n")
       [num,den] = ss2tf(a, b, c, d)
-      disp('Variable Description:\n')
-      disp('num, den => numerator and denominator of transfer function that is')
-      disp('            equivalent to the state space system')
-      disp('a, b, c, d => state space system\n')
+      disp("Variable Description:\n")
+      disp("num, den => numerator and denominator of transfer function that is")
+      disp("            equivalent to the state space system")
+      disp("a, b, c, d => state space system\n")
       prompt
       clc
-      disp('Convert from transfer function to state space form (tf2ss)\n')
-      disp('Example #1, Consider the following transfer function:\n')
+      disp("Convert from transfer function to state space form (tf2ss)\n")
+      disp("Example #1, Consider the following transfer function:\n")
       num
       den
       prompt
-      disp('\nTo find an equivalent state space representation for this system, use')
-      disp('the following command:\n')
-      disp('[a, b, c, d] = tf2ss(num, den)\n')
+      disp("\nTo find an equivalent state space representation for this system, use")
+      disp("the following command:\n")
+      disp("[a, b, c, d] = tf2ss(num, den)\n")
       prompt
-      disp('Results:\n')
+      disp("Results:\n")
       [a, b, c, d] = tf2ss(num, den)
-      disp('Variable Description:\n')
-      disp('a, b, c, d => state space system equivalent to transfer function input')
-      disp('num, den => numerator and denominator of transfer function that is equivalent')
-      disp('            to the state space system\n')
+      disp("Variable Description:\n")
+      disp("a, b, c, d => state space system equivalent to transfer function input")
+      disp("num, den => numerator and denominator of transfer function that is equivalent")
+      disp("            to the state space system\n")
       prompt
       clc
     elseif (k == 4)
       clc
-      disp('Convert from transfer function to zero / pole form (tf2zp)\n')
-      disp('Example #1, Consider the following transfer function:\n')
+      disp("Convert from transfer function to zero / pole form (tf2zp)\n")
+      disp("Example #1, Consider the following transfer function:\n")
       num=[1, 2, 3, 4, 5, ]
       den=[1, 2, 3, 4, 5, 6, 7]
       prompt
-      disp('\nTo find the zeros and poles of this system, use the following command:\n')
-      disp('[zer,pol] = tf2zp(num,den)\n')
+      disp("\nTo find the zeros and poles of this system, use the following command:\n")
+      disp("[zer,pol] = tf2zp(num,den)\n")
       prompt
-      disp('Results:\n')
+      disp("Results:\n")
       [zer,pol] = tf2zp(num,den)
-      disp('Variable Description:\n')
-      disp('zer,pol => zeros and poles of the transfer function')
-      disp('num, den => numerator and denominator of transfer function\n')
+      disp("Variable Description:\n")
+      disp("zer,pol => zeros and poles of the transfer function")
+      disp("num, den => numerator and denominator of transfer function\n")
       prompt
       clc
-      disp('Convert from zero / pole to transfer function (zp2tf)\n')
-      disp('Example #1, Consider the following set of zeros and poles:\n')
+      disp("Convert from zero / pole to transfer function (zp2tf)\n")
+      disp("Example #1, Consider the following set of zeros and poles:\n")
       zer
       pol 
       prompt
-      disp('\nTo find an equivalent transfer function representation for this set')
-      disp('of poles and zeros, use the following commands:\n')
+      disp("\nTo find an equivalent transfer function representation for this set")
+      disp("of poles and zeros, use the following commands:\n")
       k=1
-      disp('\n[num, den] = zp2tf(zer, pol, k)\n')
+      disp("\n[num, den] = zp2tf(zer, pol, k)\n")
       prompt
-      disp('Results:\n')
+      disp("Results:\n")
       [num, den] = zp2tf(zer, pol, k)
-      disp('Variable Description:\n')
-      disp('[num, den] => transfer function representation of desired set of zeros')
-      disp('              and poles') 
-      disp('a, b, c, d => state space system')
-      disp('zer, pol => zeros and poles of desired state space system')
-      disp('k => gain associated with the zeros\n')
+      disp("Variable Description:\n")
+      disp("[num, den] => transfer function representation of desired set of zeros")
+      disp("              and poles") 
+      disp("a, b, c, d => state space system")
+      disp("zer, pol => zeros and poles of desired state space system")
+      disp("k => gain associated with the zeros\n")
       prompt
       clc
     elseif (k == 5)
       return
     endif
   endwhile  
 endfunction
diff --git a/scripts/control/polyout.m b/scripts/control/polyout.m
--- a/scripts/control/polyout.m
+++ b/scripts/control/polyout.m
@@ -39,31 +39,31 @@ function y = polyout (c, x)
     usage("[y = ] polyout(c,[x])");
   endif
 
   if (!is_vector(c))
     error("polyout: first argument must be a vector");
   endif
   
   if (nargin == 1)
-    x = 's';
+    x = "s";
   elseif( ! isstr(x) )
     error("polyout: second argument must be a string");
   endif
 
   n = length(c);
   if(n > 0)
     n1 = n+1;
 
     if( imag(c(1)) )     tmp = com2str(c(1))
     else                 tmp = num2str(c(1));       endif
 
     for ii=2:n
-      if(real(c(ii)) < 0)     ns = ' - ';    c(ii) = -c(ii);
-      else                    ns = ' + ';                      endif
+      if(real(c(ii)) < 0)     ns = " - ";    c(ii) = -c(ii);
+      else                    ns = " + ";                      endif
 
       if( imag(c(ii)) )       nstr = sprintf("(%s)",com2str(c(ii)) );
       else                    nstr = num2str(c(ii));           endif
 
       tmp = sprintf("%s*%s^%d%s%s",tmp,x,n1-ii,ns,nstr);
       
     endfor
   else
diff --git a/scripts/control/sysconnect.m b/scripts/control/sysconnect.m
--- a/scripts/control/sysconnect.m
+++ b/scripts/control/sysconnect.m
@@ -122,17 +122,17 @@ function sys = sysconnect (sys, output_l
     error("max(input_list) exceeds the number of inputs");
   elseif(max(output_list) > pp)
     error("max(output_list) exceeds the number of outputs");
   endif
 
   output_list = reshape(output_list,1,length(output_list));
 
   ## make sure we're in state space form
-  sys = sysupdate(sys,'ss');
+  sys = sysupdate (sys, "ss");
 
   ## permute rows and columns of B,C,D matrices into pseudo-dgkf form...
   all_inputs = sysreorder(mm,input_list);
   all_outputs = sysreorder(pp,output_list);
 
   [aa,bb,cc,dd] = sys2ss(sys);
   bb = bb(:,all_inputs);
   cc = cc(all_outputs,:);
@@ -263,13 +263,15 @@ function sys = sysconnect (sys, output_l
   ## update connected input names
   for ii = 1:length(input_list)
     idx = input_list(ii);
     strval = sprintf("%s*",nth(sysgetsignals(sys,"in",idx),1) );
     sys = syssetsignals(sys,"in",strval,idx);
   endfor
   
   ## maintain original system type if it was SISO
-  if    (strcmp(sysgettype(sys),"tf") )       sysupdate(sys,'tf');
-  elseif(strcmp(sysgettype(sys),"zp") )       sysupdate(sys,'zp');
+  if (strcmp (sysgettype (sys), "tf"))
+    sysupdate (sys, "tf");
+  elseif (strcmp (sysgettype (sys),"zp"))
+    sysupdate (sys, "zp");
   endif
 
 endfunction
diff --git a/scripts/control/sysrepdemo.m b/scripts/control/sysrepdemo.m
--- a/scripts/control/sysrepdemo.m
+++ b/scripts/control/sysrepdemo.m
@@ -25,45 +25,45 @@
 ## Created: June 1995
 ## Revised Aug 1995 for system data structure format
 
 function sysrepdemo ()
 
   save_val = page_screen_output;
   page_screen_output = 1;
 
-  disp('System representation demo:')
+  disp("System representation demo:")
   num = [5, -1];
   denom = [1, -2, 6];
   a = b = c = [];
   syschoice = -1;
   ch_init = 2;
   ch_extract = ch_init+1;
   ch_update = ch_extract+1;
   ch_view = ch_update+1;
   ch_details = ch_view+1;
   ch_quit = ch_details+1;
   while(syschoice != ch_quit)
    disp(" ")
-    syschoice = menu('Octave System Representation Menu', ...
+    syschoice = menu("Octave System Representation Menu", ...
       "General overview of system representation (DO THIS FIRST)", ...
       "Initialize a system (ss2sys, tf2sys, zp2sys)", ...
       "Extract data from a system(sys2ss, sys2tf, sys2zp, etc.)", ...
       "Update internal representation (sysupdate)", ...
       "View the internal contents of a system (sysout)", ...
       "Details of internal representation", ...
       "Return to main menu");
     if(syschoice == 1)  # general overview
       disp("The Octave Control Systems Toolbox (OCST) was designed to")
       disp("provide a simple user interface to a powerful set of tools.")
-      disp(' ')
-      disp('               ----------')
-      disp(' input(s) ---->| System | ---> output(s) ')
-      disp('               ----------')
-      disp(' ')
+      disp(" ")
+      disp("               ----------")
+      disp(" input(s) ---->| System | ---> output(s) ")
+      disp("               ----------")
+      disp(" ")
       disp("Like other computer-aided control system design tools, the OCST")
       disp("enables users to enter their descriptions of dynamic systems in ")
       disp("their preferred form (state space, transfer function, or ");
       disp("zero-pole format).  ");
       disp("The OCST stores system descriptions in a single variable data ");
       disp("structure that allows for continuous time, discrete-time, or mixed ");
       disp("(sampled-data) systems.  ");
       disp(" ");
@@ -96,35 +96,35 @@ function sysrepdemo ()
       disp("Other options discussed under this menu are updating the internal")
       disp("representation form of a system data structure with sysupdate and printing")
       disp("the description of a dynamic system to the screen with sysout.")
       disp(" ")
       disp("Once the user is familiar with these commands, the rest of the ")
       disp("OCST package will be quite easy to use.")
     elseif(syschoice == ch_init) % Initialize
       disp("Initialization of a system:");
-      disp(' ');
+      disp(" ");
       formopt = 0;
       while(formopt != 4)
       disp("Three data formats may be used to initialize a system:")
         formopt = menu("System data structure initialization menu", ...
 		"State space form       (ss2sys)", ...
 		"Transfer function form (tf2sys)", ...
 		"zero-pole form         (zp2sys)", ...
 	    	"Return to System representation menu");
         if(formopt == 1)
-          disp('State space representation of a system is based on the usual')
-          disp('multi-variable differential equations')
-          disp(' ')
-          disp('  . ')
-          disp('  x = A x + B u      -or -   x(k+1) = A x(k) + B u(k) ')
-          disp('  y = C x + D u                y(k) = C x(k) + D u(k) ')
-          disp(' ')
-          disp('for matrices A, B, C, D of appropriate dimension.')
-          disp(' ')
+          disp("State space representation of a system is based on the usual")
+          disp("multi-variable differential equations")
+          disp(" ")
+          disp("  . ")
+          disp("  x = A x + B u      -or -   x(k+1) = A x(k) + B u(k) ")
+          disp("  y = C x + D u                y(k) = C x(k) + D u(k) ")
+          disp(" ")
+          disp("for matrices A, B, C, D of appropriate dimension.")
+          disp(" ")
           ssopt = 0;
           ssquit = 5;
           while(ssopt < ssquit)
             ssopt = menu("State space initialization examples", ...
 		"Double integrator example", ...
 		"Double delay (discrete-time) example", ...
 		"Summing junction (D-matrix only) example", ...
 		"ss2sys details (help ss2sys)", ...
diff --git a/scripts/control/tf2sys.m b/scripts/control/tf2sys.m
--- a/scripts/control/tf2sys.m
+++ b/scripts/control/tf2sys.m
@@ -54,41 +54,41 @@
 ## Created: July 29, 1994
 ## Name changed to TF2SYS July 1995
 ## updated for new system data structure format July 1996
 
 function outsys = tf2sys (num, den, tsam, inname, outname)
 
   ## Test for the correct number of input arguments
   if ((nargin < 2) || (nargin > 5))
-    usage('outsys=tf2sys(num,den[,tsam,inname,outname])');
+    usage ("outsys = tf2sys (num, den [, tsam, inname, outname])");
     return
   endif
 
   ## check input format 
   if( ! ( (is_vector(num) || is_scalar(num)) && ...
 	(is_vector(den) || is_scalar(den))) )
-    error(['num (',num2str(rows(num)),'x',num2str(columns(num)), ...
-      ') and den (',num2str(rows(den)),'x',num2str(columns(den)), ...
-      ') must be vectors'])
+    error(["num (",num2str(rows(num)),"x",num2str(columns(num)), ...
+      ") and den (",num2str(rows(den)),"x",num2str(columns(den)), ...
+      ") must be vectors"])
   endif
   
   ## strip leading zero coefficients
   num = tf2sysl(num);
   den = tf2sysl(den);
 
   if (length(num) >  length(den))
     error("# of poles (%d) < # of zeros (%d)",length(den)-1, length(num)-1);
   endif
 
   ## check sampling interval (if any)
   if(nargin <= 2)           tsam = 0;		# default
   elseif (isempty(tsam))    tsam = 0;           endif
   if ( (! (is_scalar(tsam) && (imag(tsam) == 0) )) || (tsam < 0) )
-    error('tsam must be a positive real scalar')
+    error("tsam must be a positive real scalar")
   endif
 
   outsys.num = num;
   outsys.den = den;
 
   ## Set the system vector:  active = 0(tf), updated = [1 0 0];
   outsys.sys = [0, 1, 0, 0];
 
diff --git a/scripts/control/tfout.m b/scripts/control/tfout.m
--- a/scripts/control/tfout.m
+++ b/scripts/control/tfout.m
@@ -37,27 +37,27 @@ function tfout (num, denom, x)
     usage("tfout(num,denom[,x])");
   endif
 
   if ( (!is_vector(num)) | (!is_vector(denom)) )
     error("tfout: first two argument must be vectors");
   endif
   
   if (nargin == 2)
-    x = 's';
+    x = "s";
   elseif( ! isstr(x) )
     error("tfout: third argument must be a string");
   endif
 
   numstring = polyout(num,x);
   denomstring = polyout(denom,x);
   len = max(length(numstring),length(denomstring));
   if(len > 0)
     y = strrep(blanks(len)," ","-");
     disp(numstring)
     disp(y)
     disp(denomstring)
   else
-    error('tfout: empty transfer function')
+    error ("tfout: empty transfer function")
   end
 
   empty_list_elements_ok = save_empty;
 endfunction
diff --git a/scripts/control/tzero.m b/scripts/control/tzero.m
--- a/scripts/control/tzero.m
+++ b/scripts/control/tzero.m
@@ -74,17 +74,17 @@ function [zer, gain] = tzero (A, B, C, D
     gain = D;
     return;
   endif
 
   ## First, balance the system via the zero computation generalized eigenvalue
   ## problem balancing method (Hodel and Tiller, Linear Alg. Appl., 1992)
 
   Asys = zgpbal(Asys); [A,B,C,D] = sys2ss(Asys);   # balance coefficients
-  meps = 2*eps*norm([A, B; C, D],'fro');
+  meps = 2*eps*norm ([A, B; C, D], "fro");
   Asys = zgreduce(Asys,meps);  [A, B, C, D] = sys2ss(Asys); # ENVD algorithm
   if(!isempty(A))
     ## repeat with dual system
     Asys = ss2sys(A', C', B', D');   Asys = zgreduce(Asys,meps);
 
     ## transform back
     [A,B,C,D] = sys2ss(Asys);    Asys = ss2sys(A', C', B', D');
   endif
diff --git a/scripts/control/zp2sys.m b/scripts/control/zp2sys.m
--- a/scripts/control/zp2sys.m
+++ b/scripts/control/zp2sys.m
@@ -72,17 +72,17 @@ function outsys = zp2sys (zer, pol, k, t
   if( ! (is_vector(pol) | isempty(pol)))
     error("pol must be a vector");
   endif
   if(!isempty(pol))
     pol = reshape(pol,1,length(pol));
   endif
 
   if (! is_scalar(k))
-     error('k must be a scalar');
+     error("k must be a scalar");
   endif
 
   ## Test proper numbers of poles and zeros.  The number of poles must be 
   ## greater than or equal to the number of zeros.
   if (length(zer) >  length(pol))
     error(["number of poles (", num2str(length(pol)), ...
 	") < number of zeros (", num2str(length(zer)),")"]);
   endif
diff --git a/scripts/control/zpout.m b/scripts/control/zpout.m
--- a/scripts/control/zpout.m
+++ b/scripts/control/zpout.m
@@ -41,17 +41,17 @@ function zpout (zer, pol, k, x)
     error("zer, pol must be vectors or empty");
   endif
 
   if(!is_scalar(k))
     error("zpout: argument k must be a scalar.")
   endif
  
   if (nargin == 3)
-    x = 's';
+    x = "s";
   elseif( ! isstr(x) )
     error("zpout: third argument must be a string");
   endif
  
   numstring = num2str(k);
 
   if(length(zer))
     ## find roots at z,s = 0
@@ -95,14 +95,14 @@ function zpout (zer, pol, k, x)
   if(len > 0)
     y = strrep(blanks(len)," ","-");
     disp(numstring)
     if(length(denomstring))
       disp(y)
       disp(denomstring)
     endif
   else
-    error('zpout: empty transfer function')
+    error ("zpout: empty transfer function")
   end
 
   empty_list_elements_ok = save_empty;
 
 endfunction
diff --git a/scripts/image/loadimage.m b/scripts/image/loadimage.m
--- a/scripts/image/loadimage.m
+++ b/scripts/image/loadimage.m
@@ -40,17 +40,17 @@ function [img_retval, map_retval] = load
   file = file_in_path (IMAGEPATH, filename);
 
   if (isempty (file))
     error ("loadimage: unable to find image file");
   endif
 
   ## The file is assumed to have variables img and map, or X and map.
 
-  eval (['load ', file]);
+  eval (sprintf ("load %s", file));
 
   if (exist ("img"))
     img_retval = img;
   elseif (exist ("X"))
     img_retval = X;
   else
     error ("loadimage: invalid image file found");
   endif
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,17 @@
+1999-12-22  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* lex.l (Vwarn_single_quote_string): New variable.
+	(syms_of_lex): DEFVAR it.
+	(warn_single_quote_string): New function.
+	(gripe_single_quote_string): New function.
+	Use new stuff to allow warnings for code that uses single quote
+	characters to introduce string constants.
+
 1999-12-20  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* mkbuiltins: Add #undef quad to generated file.
 
 1999-12-15  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* lex.l (Vwarn_separator_insert): New variable.
 	(syms_of_lex): DEFVAR it.
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -160,16 +160,18 @@ static bracket_brace_paren_nesting_level
 //   [eye (2)]
 //
 // will result in a call to `eye' with the argument `2'.
 
 static int Vwhitespace_in_literal_matrix;
 
 static bool Vwarn_separator_insert = false;
 
+static bool Vwarn_single_quote_string = false;
+
 // Forward declarations for functions defined at the bottom of this
 // file.
 
 static void fixup_column_count (char *s);
 static void do_comma_insert_check (void);
 static int is_plot_keyword (const string& s);
 static int is_keyword (const string& s);
 static string plot_style_token (const string& s);
@@ -184,16 +186,17 @@ static void handle_number (void);
 static int handle_string (char delim, int text_style = 0);
 static int handle_close_bracket (int spc_gobbled);
 static int handle_identifier (const string& tok, int spc_gobbled);
 static bool have_continuation (bool trailing_comments_ok = true);
 static bool have_ellipsis_continuation (bool trailing_comments_ok = true);
 static yum_yum eat_whitespace (void);
 static yum_yum eat_continuation (void);
 static void maybe_warn_separator_insert (char sep);
+static void gripe_single_quote_string (void);
 
 %}
 
 D	[0-9]
 S	[ \t]
 NL	((\n)|(\r\n))
 SNL	({S}|{NL})
 EL	(\.\.\.)
@@ -1750,16 +1753,20 @@ handle_string (char delim, int text_styl
 		    {
 		      lexer_flags.quote_is_transpose = true;
 		      lexer_flags.cant_be_identifier = true;
 		      lexer_flags.convert_spaces_to_comma = true;
 		    }
 
 		  yylval.tok_val = new token (s);
 		  token_stack.push (yylval.tok_val);
+
+		  if (delim == '\'')
+		    gripe_single_quote_string ();
+
 		  return TEXT;
 		}
 	    }
 	}
       else
 	{
 	  buf << (char) c;
 	}
@@ -2212,25 +2219,49 @@ maybe_warn_separator_insert (char sep)
 	warning ("potential auto-insertion of `%c' near line %d",
 		 sep, input_line_number);
       else
 	warning ("potential auto-insertion of `%c' near line %d of file %s",
 		 sep, input_line_number, nm.c_str ());
     }
 }
 
+static void
+gripe_single_quote_string (void)
+{
+  string nm = curr_fcn_file_full_name;
+
+  if (Vwarn_single_quote_string)
+    {
+      if (nm.empty ())
+	warning ("single quote delimited string near line %d",
+		 input_line_number);
+      else
+	warning ("single quote delimited string near line %d of file %s",
+		 input_line_number, nm.c_str ());
+    }
+}
+
 static int
 warn_separator_insert (void)
 {
   Vwarn_separator_insert = check_preference ("warn_separator_insert");
 
   return 0;
 }
 
 static int
+warn_single_quote_string (void)
+{
+  Vwarn_single_quote_string = check_preference ("warn_single_quote_string");
+
+  return 0;
+}
+
+static int
 whitespace_in_literal_matrix (void)
 {
   int pref = 0;
 
   string val = builtin_string_variable ("whitespace_in_literal_matrix");
 
   if (! val.empty ())
     {
@@ -2247,16 +2278,20 @@ whitespace_in_literal_matrix (void)
 
 void
 symbols_of_lex (void)
 {
   DEFVAR (warn_separator_insert, 0.0, warn_separator_insert,
     "print warning if commas or semicolons that might be inserted\n\
 automatically in literal matrices");
 
+  DEFVAR (warn_single_quote_string, 0.0, warn_single_quote_string,
+    "print warning if a signle quote character is used to introduce a\n\
+ string constant");
+
   DEFVAR (whitespace_in_literal_matrix, "", whitespace_in_literal_matrix,
     "control auto-insertion of commas and semicolons in literal matrices");
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
