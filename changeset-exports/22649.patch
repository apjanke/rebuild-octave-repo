# HG changeset patch
# User Rik <rik@octave.org>
# Date 1476915633 25200
#      Wed Oct 19 15:20:33 2016 -0700
# Node ID 2d9393be9a18ef1eabb18bbd18ae8c39a56e0b97
# Parent  859d48b5648db5af297cc2eada1b4829a50e3455
# Parent  9bc03a3f7a345c5b0551f6a93a19e950aad5a96c
maint: Periodic merge of stable to default.

diff --git a/scripts/ode/ode23.m b/scripts/ode/ode23.m
--- a/scripts/ode/ode23.m
+++ b/scripts/ode/ode23.m
@@ -84,25 +84,16 @@
 ## @group
 ## fvdp = @@(@var{t},@var{y}) [@var{y}(2); (1 - @var{y}(1)^2) * @var{y}(2) - @var{y}(1)];
 ## [@var{t},@var{y}] = ode23 (fvdp, [0, 20], [2, 0]);
 ## @end group
 ## @end example
 ## @seealso{odeset, odeget, ode45}
 ## @end deftypefn
 
-## FIXME: We store ChangeLog information in Mercurial.  Can this be deleted?
-## ChangeLog:
-##   20010703 the function file "ode23.m" was written by Marc Compere
-##     under the GPL for the use with this software.  This function has been
-##     taken as a base for the following implementation.
-##   20060810, Thomas Treichl
-##     This function was adapted to the new syntax that is used by the
-##     new OdePkg for Octave and is compatible to Matlab's ode23.
-
 function varargout = ode23 (fun, trange, init, varargin)
 
   if (nargin < 3)
     print_usage ();
   endif
 
   order  = 3;
   solver = "ode23";
@@ -156,22 +147,16 @@ function varargout = ode23 (fun, trange,
   endif
   if (! isa (fun, "function_handle"))
     error ("Octave:invalid-input-arg",
            "ode23: FUN must be a valid function handle");
   endif
 
   ## Start preprocessing, have a look which options are set in odeopts,
   ## check if an invalid or unused option is set.
-  ## FIXME: Why persistent?  Won't these have different values for every
-  ##        run of ode23?
-  persistent defaults   = [];
-  persistent classes    = [];
-  persistent attributes = [];
-
   [defaults, classes, attributes] = odedefaults (numel (init),
                                                  trange(1), trange(end));
 
   defaults   = rmfield (defaults,   {"Jacobian", "JPattern", "Vectorized", ...
                                      "MvPattern", "MassSingular", ...
                                      "InitialSlope", "MaxOrder", "BDF"});
   classes    = rmfield (classes,    {"Jacobian", "JPattern", "Vectorized", ...
                                      "MvPattern", "MassSingular", ...
@@ -238,18 +223,17 @@ function varargout = ode23 (fun, trange,
     endif
   endif
 
   solution = integrate_adaptive (@runge_kutta_23,
                                  order, fun, trange, init, odeopts);
 
   ## Postprocessing, do whatever when terminating integration algorithm
   if (odeopts.haveoutputfunction)  # Cleanup plotter
-    feval (odeopts.OutputFcn, solution.t(end),
-           solution.x(end,:)', "done", odeopts.funarguments{:});
+    feval (odeopts.OutputFcn, [], [], "done", odeopts.funarguments{:});
   endif
   if (! isempty (odeopts.Events))   # Cleanup event function handling
     ode_event_handler (odeopts.Events, solution.t(end),
                        solution.x(end,:)', "done", odeopts.funarguments{:});
   endif
 
   ## Print additional information if option Stats is set
   if (strcmp (odeopts.Stats, "on"))
@@ -307,30 +291,30 @@ endfunction
 %! tol = 1e-5 ./ 10.^[0:8];
 %! for i = 1 : numel (tol)
 %!   opt = odeset ("RelTol", tol(i), "AbsTol", realmin);
 %!   [t, y] = ode23 (@(t, y) -y, [0, 1], 1, opt);
 %!   h(i) = 1 / (numel (t) - 1);
 %!   err(i) = norm (y .* exp (t) - 1, Inf);
 %! endfor
 %!
-%! ## Estimate order numerically
-%! p = diff (log (err)) ./ diff (log (h))
-%!
 %! ## Estimate order visually
 %! loglog (h, tol, "-ob",
 %!         h, err, "-b",
 %!         h, (h/h(end)) .^ 2 .* tol(end), "k--",
 %!         h, (h/h(end)) .^ 3 .* tol(end), "k-");
 %! axis tight
 %! xlabel ("h");
 %! ylabel ("err(h)");
 %! title ("Convergence plot for ode23");
 %! legend ("imposed tolerance", "ode23 (relative) error",
 %!         "order 2", "order 3", "location", "northwest");
+%!
+%! ## Estimate order numerically
+%! p = diff (log (err)) ./ diff (log (h))
 
 ## We are using the "Van der Pol" implementation for all tests that are done
 ## for this function.
 ## For further tests we also define a reference solution (computed at high
 ## accuracy)
 %!function ydot = fpol (t, y)  # The Van der Pol ODE
 %!  ydot = [y(2); (1 - y(1)^2) * y(2) - y(1)];
 %!endfunction
@@ -355,34 +339,40 @@ endfunction
 %!endfunction
 %!function mas = fmas (t, y, varargin)
 %!  mas = [1, 0; 0, 1];             # Dummy mass matrix for tests
 %!endfunction
 %!function mas = fmsa (t, y, varargin)
 %!  mas = sparse ([1, 0; 0, 1]);    # A sparse dummy matrix
 %!endfunction
 %!function out = fout (t, y, flag, varargin)
-%!  if (regexp (char (flag), "init") == 1)
-%!    if (any (size (t) != [2, 1])) error ('"fout" step "init"'); endif
+%!  out = false;
+%!  if (strcmp (flag, "init"))
+%!    if (! isequal (size (t), [2, 1]))
+%!      error ('fout: step "init"');
+%!    endif
 %!  elseif (isempty (flag))
-%!    if (any (size (t) != [1, 1])) error ('"fout" step "calc"'); endif
-%!    out = false;
-%!  elseif (regexp (char (flag), "done") == 1)
-%!    if (any (size (t) != [1, 1])) error ('"fout" step "done"'); endif
+%!    if (! isequal (size (t), [1, 1]))
+%!      error ('fout: step "calc"');
+%!    endif
+%!  elseif (strcmp (flag, "done"))
+%!    if (! isempty (t))
+%!      warning ('fout: step "done"');
+%!    endif
 %!  else
-%!    error ('"fout" invalid flag');
+%!    error ("fout: invalid flag <%s>", flag);
 %!  endif
 %!endfunction
 %!
 %!test  # two output arguments
 %! [t, y] = ode23 (@fpol, [0 2], [2 0]);
 %! assert ([t(end), y(end,:)], [2, fref], 1e-3);
 %!test  # anonymous function instead of real function
-%! fvdb = @(t,y) [y(2); (1 - y(1)^2) * y(2) - y(1)];
-%! [t, y] = ode23 (fvdb, [0 2], [2 0]);
+%! fvdp = @(t,y) [y(2); (1 - y(1)^2) * y(2) - y(1)];
+%! [t, y] = ode23 (fvdp, [0 2], [2 0]);
 %! assert ([t(end), y(end,:)], [2, fref], 1e-3);
 %!test  # extra input arguments passed through
 %! [t, y] = ode23 (@fpol, [0 2], [2 0], 12, 13, "KL");
 %! assert ([t(end), y(end,:)], [2, fref], 1e-3);
 %!test  # empty OdePkg structure *but* extra input arguments
 %! opt = odeset;
 %! [t, y] = ode23 (@fpol, [0 2], [2 0], opt, 12, 13, "KL");
 %! assert ([t(end), y(end,:)], [2, fref], 1e-2);
@@ -479,19 +469,19 @@ endfunction
 %! sol = ode23 (@fpol, [0 2], [2 0], opt);
 %! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
 %!test  # Mass option as function and MStateDependence
 %! opt = odeset ("Mass", @fmas, "MStateDependence", "strong");
 %! sol = ode23 (@fpol, [0 2], [2 0], opt);
 %! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
 
 ## FIXME: Missing tests.
-## test for MvPattern option is missing
 ## test for InitialSlope option is missing
 ## test for MaxOrder option is missing
+## test for MvPattern option is missing
 
 ## Test input validation
 %!error ode23 ()
 %!error ode23 (1)
 %!error ode23 (1,2)
 %!error <TRANGE must be a numeric> ode23 (@fpol, {[0 25]}, [3 15 1])
 %!error <TRANGE must be a .* vector> ode23 (@fpol, [0 25; 25 0], [3 15 1])
 %!error <TRANGE must contain at least 2 elements> ode23 (@fpol, [1], [3 15 1])
diff --git a/scripts/ode/ode45.m b/scripts/ode/ode45.m
--- a/scripts/ode/ode45.m
+++ b/scripts/ode/ode45.m
@@ -138,21 +138,16 @@ function varargout = ode45 (fun, trange,
   endif
   if (! isa (fun, "function_handle"))
     error ("Octave:invalid-input-arg",
            "ode45: FUN must be a valid function handle");
   endif
 
   ## Start preprocessing, have a look which options are set in odeopts,
   ## check if an invalid or unused option is set
-  ## FIXME: Why persistent when it is changed with every run of ode45?
-  persistent defaults   = [];
-  persistent classes    = [];
-  persistent attributes = [];
-
   [defaults, classes, attributes] = odedefaults (numel (init),
                                                  trange(1), trange(end));
 
   defaults   = odeset (defaults, "Refine", 4);
   defaults   = rmfield (defaults,   {"Jacobian", "JPattern", "Vectorized", ...
                                      "MvPattern", "MassSingular", ...
                                      "InitialSlope", "MaxOrder", "BDF"});
   classes    = rmfield (classes,    {"Jacobian", "JPattern", "Vectorized", ...
@@ -219,18 +214,17 @@ function varargout = ode45 (fun, trange,
     endif
   endif
 
   solution = integrate_adaptive (@runge_kutta_45_dorpri,
                                  order, fun, trange, init, odeopts);
 
   ## Postprocessing, do whatever when terminating integration algorithm
   if (odeopts.haveoutputfunction)  # Cleanup plotter
-    feval (odeopts.OutputFcn, solution.t(end),
-           solution.x(end,:)', "done", odeopts.funarguments{:});
+    feval (odeopts.OutputFcn, [], [], "done", odeopts.funarguments{:});
   endif
   if (! isempty (odeopts.Events))   # Cleanup event function handling
     ode_event_handler (odeopts.Events, solution.t(end),
                        solution.x(end,:)', "done", odeopts.funarguments{:});
   endif
 
   ## Print additional information if option Stats is set
   if (strcmp (odeopts.Stats, "on"))
@@ -288,30 +282,30 @@ endfunction
 %! tol = 1e-5 ./ 10.^[0:8];
 %! for i = 1 : numel (tol)
 %!   opt = odeset ("RelTol", tol(i), "AbsTol", realmin);
 %!   [t, y] = ode45 (@(t, y) -y, [0, 1], 1, opt);
 %!   h(i) = 1 / (numel (t) - 1);
 %!   err(i) = norm (y .* exp (t) - 1, Inf);
 %! endfor
 %!
-%! ## Estimate order numerically
-%! p = diff (log (err)) ./ diff (log (h))
-%!
 %! ## Estimate order visually
 %! loglog (h, tol, "-ob",
 %!         h, err, "-b",
 %!         h, (h/h(end)) .^ 4 .* tol(end), "k--",
 %!         h, (h/h(end)) .^ 5 .* tol(end), "k-");
 %! axis tight
 %! xlabel ("h");
 %! ylabel ("err(h)");
 %! title ("Convergence plot for ode45");
 %! legend ("imposed tolerance", "ode45 (relative) error",
 %!         "order 4", "order 5", "location", "northwest");
+%!
+%! ## Estimate order numerically
+%! p = diff (log (err)) ./ diff (log (h))
 
 ## We are using the Van der Pol equation for all tests that are done
 ## for this function.
 ## For further tests we also define a reference solution (computed at high
 ## accuracy)
 %!function ydot = fpol (t, y)  # The Van der Pol ODE
 %!  ydot = [y(2); (1 - y(1)^2) * y(2) - y(1)];
 %!endfunction
@@ -336,37 +330,43 @@ endfunction
 %!endfunction
 %!function mas = fmas (t, y, varargin)
 %!  mas = [1, 0; 0, 1];            # Dummy mass matrix for tests
 %!endfunction
 %!function mas = fmsa (t, y, varargin)
 %!  mas = sparse ([1, 0; 0, 1]);   # A sparse dummy matrix
 %!endfunction
 %!function out = fout (t, y, flag, varargin)
-%!  if (regexp (char (flag), "init") == 1)
-%!    if (any (size (t) != [2, 1])) error ('"fout" step "init"'); endif
+%!  out = false;
+%!  if (strcmp (flag, "init"))
+%!    if (! isequal (size (t), [2, 1]))
+%!      error ('fout: step "init"');
+%!    endif
 %!  elseif (isempty (flag))
-%!    if (any (size (t) != [1, 1])) error ('"fout" step "calc"'); endif
-%!    out = false;
-%!  elseif (regexp (char (flag), 'done') == 1)
-%!    if (any (size (t) != [1, 1])) error ('"fout" step "done"'); endif
+%!    if (! isequal (size (t), [1, 1]))
+%!      error ('fout: step "calc"');
+%!    endif
+%!  elseif (strcmp (flag, "done"))
+%!    if (! isempty (t))
+%!      warning ('fout: step "done"');
+%!    endif
 %!  else
-%!    error ('"fout" invalid flag');
+%!    error ("fout: invalid flag <%s>", flag);
 %!  endif
 %!endfunction
 %!
 %!test  # two output arguments
 %! [t, y] = ode45 (@fpol, [0 2], [2 0]);
 %! assert ([t(end), y(end,:)], [2, fref], 1e-2);
 %!test  # not too many steps
 %! [t, y] = ode45 (@fpol, [0 2], [2 0]);
 %! assert (size (t) < 20);
 %!test  # anonymous function instead of real function
-%! fvdb = @(t,y) [y(2); (1 - y(1)^2) * y(2) - y(1)];
-%! [t, y] = ode45 (fvdb, [0 2], [2 0]);
+%! fvdp = @(t,y) [y(2); (1 - y(1)^2) * y(2) - y(1)];
+%! [t, y] = ode45 (fvdp, [0 2], [2 0]);
 %! assert ([t(end), y(end,:)], [2, fref], 1e-2);
 %!test  # string instead of function
 %! [t, y] = ode45 ("fpol", [0 2], [2 0]);
 %! assert ([t(end), y(end,:)], [2, fref], 1e-2);
 %!test  # extra input arguments passed through
 %! [t, y] = ode45 (@fpol, [0 2], [2 0], 12, 13, "KL");
 %! assert ([t(end), y(end,:)], [2, fref], 1e-2);
 %!test  # empty ODEOPT structure *but* extra input arguments
@@ -477,19 +477,19 @@ endfunction
 %! sol = ode45 (@fpol, [0 2], [2 0], opt);
 %! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
 %!test  # Mass option as function and MStateDependence
 %! opt = odeset ("Mass", @fmas, "MStateDependence", "strong");
 %! sol = ode45 (@fpol, [0 2], [2 0], opt);
 %! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
 
 ## FIXME: Missing tests.
-## test for MvPattern option is missing
 ## test for InitialSlope option is missing
 ## test for MaxOrder option is missing
+## test for MvPattern option is missing
 
 %!error ode45 ()
 %!error ode45 (1)
 %!error ode45 (1,2)
 %!error <TRANGE must be a numeric> ode45 (@fpol, {[0 25]}, [3 15 1])
 %!error <TRANGE must be a .* vector> ode45 (@fpol, [0 25; 25 0], [3 15 1])
 %!error <TRANGE must contain at least 2 elements> ode45 (@fpol, [1], [3 15 1])
 %!error <invalid time span> ode45 (@fpol, [1 1], [3 15 1])
diff --git a/scripts/ode/odeget.m b/scripts/ode/odeget.m
--- a/scripts/ode/odeget.m
+++ b/scripts/ode/odeget.m
@@ -32,19 +32,17 @@
 ## value @var{val} corresponding to @var{field} from @var{ode_opt}.
 ##
 ## If called with an optional third input argument, and @var{field} is
 ## not set in the structure @var{ode_opt}, then return the default value
 ## @var{default} instead.
 ## @seealso{odeset}
 ## @end deftypefn
 
-## FIXME: 4th input argument "opt" is undocumented.
-
-function val = odeget (ode_opt, field, default = [], opt = "")
+function val = odeget (ode_opt, field, default = [])
 
   validateattributes (ode_opt, {"struct"}, {"nonempty"});
   validateattributes (field, {"char"}, {"nonempty"});
 
   if (! isfield (ode_opt, field))
     error ("Octave:odeget:InvalidPropName",
            'odeget: Unrecognized property name "%s".', field);
   else
@@ -53,32 +51,34 @@ function val = odeget (ode_opt, field, d
       val = default;
     endif
   endif
 
 endfunction
 
 
 %!demo
-%! # Return the manually changed value RelTol of the ODE options
-%! # structure A.  If RelTol wouldn't have been changed then an
-%! # empty matrix value would have been returned.
+%! ## Return the manually changed value RelTol of the ODE options
+%! ## structure A.  If RelTol wouldn't have been changed then an
+%! ## empty matrix value would have been returned.
 %!
 %! A = odeset ("RelTol", 1e-1, "AbsTol", 1e-2);
 %! odeget (A, "RelTol", [])
 
 %!assert (odeget (odeset (), "RelTol"), [])
 %!assert (odeget (odeset ("RelTol", 10), "RelTol"), 10)
 %!assert (odeget (odeset (), "RelTol", 10), 10)
 %!assert (odeget (odeset (), "Stats"), [])
 %!assert (odeget (odeset (), "Stats", "on"), "on")
 %!assert (odeget (odeset (), "Mass"), [])
 %!assert (odeget (odeset (), "AbsTol", 1e-9), 1e-9)
 %!assert (odeget (odeset ("AbsTol", 1e-9), "AbsTol", []), 1e-9)
-%!assert (odeget (odeset ("foo", 42), "foo"), 42)
+%!test
+%! warning ("off", "Octave:invalid-input-arg", "local");
+%! assert (odeget (odeset ("foo", 42), "foo"), 42);
 
 %!error odeget ()
 %!error odeget (1)
 %!error odeget (1,2,3,4,5)
 %!error odeget (1, "opt1")
 %!error odeget (struct ("opt1", 1), 1)
 %!error odeget (struct ("opt1", 1), "foo")
 
diff --git a/scripts/ode/odeplot.m b/scripts/ode/odeplot.m
--- a/scripts/ode/odeplot.m
+++ b/scripts/ode/odeplot.m
@@ -14,95 +14,108 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## Author: Thomas Treichl <treichl@users.sourceforge.net>
 
 ## -*- texinfo -*-
-## @deftypefn {} {@var{ret} =} odeplot (@var{t}, @var{y}, @var{flag})
+## @deftypefn {} {@var{stop_solve} =} odeplot (@var{t}, @var{y}, @var{flag})
 ##
-## Open a new figure window and plot input @var{y} over time during the
-## solving of an ode problem.
+## Open a new figure window and plot the solution of an ode problem at each
+## time step during the integration.
 ##
-## The input @var{y} is a column vector.  The types and values of the input
-## parameter @var{t} and output parameter @var{ret} depend on the input
-## @var{flag} that is of type string.  If @var{flag} is
+## The types and values of the input parameters @var{t} and @var{y} depend on
+## the input @var{flag} that is of type string.  Valid values of @var{flag}
+## are:
 ##
 ## @table @option
 ## @item @qcode{"init"}
-## then @var{t} must be a column vector of length 2 with the first and
-## the last time step;  Nothing is returned from this function.
+## The input @var{t} must be a column vector of length 2 with the first and
+## last time step (@code{[@var{tfirst} @var{tlast}]}.  The input @var{y}
+## contains the initial conditions for the ode problem (@var{y0}).
 ##
 ## @item @qcode{""}
-## then @var{t} must be a scalar double specifying the actual time step;
-## The return value is false (resp. value 0) for @qcode{"not stop solving"}.
+## The input @var{t} must be a scalar double specifying the time for which
+## the solution in input @var{y} was calculated.
 ##
 ## @item @qcode{"done"}
-## then @var{t} must be a scalar double specifying the last time step;
-## Nothing is returned from this function.
+## The inputs should be empty, but are ignored if they are present.
 ## @end table
 ##
-## This function is called by an ode solver function if it was specified in
-## an options structure with @code{odeset}.  This function is an internal
-## helper function; It should never be necessary for this function to be
-## directly called by a user.  There is only minimal error detection
-## implemented in order to to achieve the highest performance.
+## @code{odeplot} always returns false, i.e., don't stop the ode solver.
 ##
-## For example, solve an anonymous implementation of the
+## Example: solve an anonymous implementation of the
 ## @nospell{@qcode{"Van der Pol"}} equation and display the results while
-## solving
+## solving.
 ##
 ## @example
 ## @group
-## fvdb = @@(t,y) [y(2); (1 - y(1)^2) * y(2) - y(1)];
+## fvdp = @@(t,y) [y(2); (1 - y(1)^2) * y(2) - y(1)];
 ##
 ## opt = odeset ("OutputFcn", @@odeplot, "RelTol", 1e-6);
-## sol = ode45 (fvdb, [0 20], [2 0], opt);
+## sol = ode45 (fvdp, [0 20], [2 0], opt);
 ## @end group
 ## @end example
 ##
-## @seealso{odeset, odeget}
+## Background Information:
+## This function is called by an ode solver function if it was specified in
+## the @qcode{"OutputFcn"} property of an options structure created with
+## @code{odeset}.  The ode solver will initially call the function with the
+## syntax @code{odeplot ([@var{tfirst}, @var{tlast}], @var{y0}, "init")}.  The
+## function initializes internal variables, creates a new figure window, and
+## sets the x limits of the plot.  Subsequently, at each time step during the
+## integration the ode solver calls @code{odeplot (@var{t}, @var{y}, [])}.
+## At the end of the solution the ode solver calls
+## @code{odeplot ([], [], "end")} so that odeplot can perform any clean-up
+## actions required.
+## @seealso{odeset, odeget, ode23, ode45}
 ## @end deftypefn
 
-function ret = odeplot (t, y, flag, varargin)
+function stop_solve = odeplot (t, y, flag)
 
-  ## No input argument check is done for a higher processing speed
-  persistent fig told yold counter;
+  ## No input argument checking is done for better performance
+  persistent hlines num_lines told yold;
+  persistent idx = 1;   # Don't remove.  Required for Octave parser.
+
+  ## odeplot never stops the integration
+  stop_solve = false;
 
-  if (strcmp (flag, "init"))
-    ## Nothing to return, t is either the time slot [tstart tstop]
-    ## or [t0, t1, ..., tn], y is the initial value vector "init"
-    counter = 1;
-    fig = figure ();
+  if (isempty (flag))
+    ## Default case, plot and return a value
+    idx += 1;
+    told(idx,1) = t(1,1);
+    yold(:,idx) = y(:,1);
+    for i = 1:num_lines
+      set (hlines(i), "xdata", told, "ydata", yold(i,:));
+    endfor
+    drawnow;
+
+    retval = false;
+
+  elseif (strcmp (flag, "init"))
+    ## t is either the time slot [tstart tstop] or [t0, t1, ..., tn]
+    ## y is the initial value vector for the ode solution
+    idx = 1;
     told = t(1,1);
     yold = y(:,1);
-
-  elseif (isempty (flag))
-    ## Return something, either false for "not stopping
-    ## the integration" or true for "stopping the integration"
-    counter += 1;
-    figure (fig);
-    told(counter,1) = t(1,1);
-    yold(:,counter) = y(:,1);
-    ## FIXME: Why not use '.' rather than 'o' and skip the markersize?
-    ## FIXME: Why not just update the xdata, ydata properties?
-    ##        Calling plot involves a lot of overhead.
-    plot (told, yold, "-o", "markersize", 1); drawnow;
-    ret = false;
+    figure ();
+    hlines = plot (told, yold, "-", "marker", ".", "markersize", 9);
+    xlim ([t(1), t(end)]);  # Fix limits which also speeds up plotting
+    num_lines = numel (hlines);
 
   elseif (strcmp (flag, "done"))
     ## Cleanup after ode solver has finished.
-    clear ("figure", "told", "yold", "counter");
+    hlines = num_lines = told = yold = idx = [];
 
   endif
 
 endfunction
 
 
 %!demo
-%! # Solve an anonymous implementation of the Van der Pol equation
-%! # and display the results while solving
-%! fvdb = @(t,y) [y(2); (1 - y(1)^2) * y(2) - y(1)];
+%! ## Solve an anonymous implementation of the Van der Pol equation
+%! ## and display the results while solving
+%! fvdp = @(t,y) [y(2); (1 - y(1)^2) * y(2) - y(1)];
 %! opt = odeset ("OutputFcn", @odeplot, "RelTol", 1e-6);
-%! sol = ode45 (fvdb, [0 20], [2 0], opt);
+%! sol = ode45 (fvdp, [0 20], [2 0], opt);
 
diff --git a/scripts/ode/odeset.m b/scripts/ode/odeset.m
--- a/scripts/ode/odeset.m
+++ b/scripts/ode/odeset.m
@@ -82,20 +82,16 @@
 ## @item JPattern
 ## If the Jacobian matrix is sparse and non-constant but maintains a
 ## constant sparsity pattern, specify the sparsity pattern.
 ##
 ## @item Mass
 ## Mass matrix, specified as a constant matrix or a function of
 ## time and state.
 ##
-## @item MassConstant
-## Specify whether the mass matrix is a constant matrix or depends on
-## the state.
-##
 ## @item MassSingular
 ## Specify whether the mass matrix is singular. Accepted values include
 ## @qcode{"yes"}, @qcode{"no"}, @qcode{"maybe"}.
 ##
 ## @item MaxOrder
 ## Maximum order of formula.
 ##
 ## @item MaxStep
@@ -160,18 +156,16 @@ function odestruct = odeset (varargin)
     p.addParameter ("BDF", []);
     p.addParameter ("Events", []);
     p.addParameter ("InitialSlope", []);
     p.addParameter ("InitialStep", []);
     p.addParameter ("Jacobian", []);
     p.addParameter ("JConstant", []);
     p.addParameter ("JPattern", []);
     p.addParameter ("Mass", []);
-    ## FIXME: MassConstant does not appear in Matlab documentation for odeset
-    p.addParameter ("MassConstant", []);
     p.addParameter ("MassSingular", []);
     p.addParameter ("MaxOrder", []);
     p.addParameter ("MaxStep", []);
     p.addParameter ("MStateDependence", []);
     p.addParameter ("MvPattern", []);
     p.addParameter ("NonNegative", []);
     p.addParameter ("NormControl", []);
     p.addParameter ("OutputFcn", []);
@@ -185,32 +179,27 @@ function odestruct = odeset (varargin)
 
   if (nargin == 0 && nargout == 0)
     print_options ();
   else
     p.parse (varargin{:});
     odestruct = p.Results;
     odestruct_extra = p.Unmatched;
 
-    ## FIXME: For speed, shouldn't this merge of structures only occur
-    ##        when there is something in odestruct_extra?
-    ## FIXME: Should alphabetical order of fieldnames be maintained
-    ##        by using sort?
-    s1 = cellfun (@(x) ifelse (iscell (x), {x}, x),
-                  struct2cell (odestruct),
-                  "UniformOutput", false);
+    xtra_fields = fieldnames (odestruct_extra);
+    if (! isempty (xtra_fields))
+      ## Merge extra fields into existing odestruct
+      for fldname = sort (xtra_fields.')
+        fldname = fldname{1};
+        warning ("Octave:invalid-input-arg",
+                 "odeset: unknown option \"%s\"\n", fldname);
+        odestruct.(fldname) = odestruct_extra.(fldname);
+      endfor
+    endif
 
-    s2 = cellfun (@(x) ifelse (iscell (x), {x}, x),
-                  struct2cell (odestruct_extra),
-                  "UniformOutput", false);
-
-    C = [fieldnames(odestruct)       s1;
-         fieldnames(odestruct_extra) s2];
-
-    odestruct = struct (C'{:});
   endif
 
 endfunction
 
 ## function to print all possible options
 function print_options ()
 
   disp ("List of the most common ODE solver options.");
@@ -220,17 +209,16 @@ function print_options ()
   disp ('                BDF:  binary, {["off"], "on"}');
   disp ('             Events:  function_handle, []');
   disp ('       InitialSlope:  vector, []');
   disp ('        InitialStep:  scalar, >0, []');
   disp ('           Jacobian:  matrix or function_handle, []');
   disp ('          JConstant:  binary, {["off"], "on"}');
   disp ('           JPattern:  sparse matrix, []');
   disp ('               Mass:  matrix or function_handle, []');
-  disp ('       MassConstant:  binary, {["off"], "on"}');
   disp ('       MassSingular:  switch, {["maybe"], "no", "yes"}');
   disp ('           MaxOrder:  switch, {[5], 1, 2, 3, 4, }');
   disp ('            MaxStep:  scalar, >0, []');
   disp ('   MStateDependence:  switch, {["weak"], "none", "strong"}');
   disp ('          MvPattern:  sparse matrix, []');
   disp ('        NonNegative:  vector of integers, []');
   disp ('        NormControl:  binary, {["off"], "on"}');
   disp ('          OutputFcn:  function_handle, []');
@@ -239,37 +227,37 @@ function print_options ()
   disp ('             RelTol:  scalar, >0, [1e-3]');
   disp ('              Stats:  binary, {["off"], "on"}');
   disp ('         Vectorized:  binary, {["off"], "on"}');
 
 endfunction
 
 
 %!demo
-%! # A new ODE options structure with default values is created.
+%! ## A new ODE options structure with default values is created.
 %!
 %! odeoptA = odeset ();
 
 %!demo
-%! # A new ODE options structure with manually set options
-%! # for "AbsTol" and "RelTol" is created.
+%! ## A new ODE options structure with manually set options
+%! ## for "AbsTol" and "RelTol" is created.
 %!
 %! odeoptB = odeset ("AbsTol", 1e-2, "RelTol", 1e-1);
 
 %!demo
-%! # A new ODE options structure is created from odeoptB with
-%! # a modified value for option "NormControl".
+%! ## A new ODE options structure is created from odeoptB with
+%! ## a modified value for option "NormControl".
 %!
 %! odeoptB = odeset ("AbsTol", 1e-2, "RelTol", 1e-1);
 %! odeoptC = odeset (odeoptB, "NormControl", "on");
 
 %!test
 %! odeoptA = odeset ();
 %! assert (isstruct (odeoptA));
-%! assert (numfields (odeoptA), 23);
+%! assert (numfields (odeoptA), 22);
 %! assert (all (structfun ("isempty", odeoptA)));
 
 %!shared odeoptB, odeoptC
 %!test
 %! odeoptB = odeset ("ABSTOL", 1e-2, "reltol", 1e-1);
 %! assert (odeoptB.AbsTol, 1e-2);  # Check canonicalization of name
 %! assert (odeoptB.RelTol, 1e-1);
 
@@ -279,32 +267,23 @@ endfunction
 %! assert (odeoptC.NormControl, "on");  # check new values override old ones
 
 %!test
 %! odeoptD = odeset (odeoptB, odeoptC);
 %! assert (odeoptD, odeoptC);
 
 ## Test custom user-defined option
 %!test
-%! wstate = warning ("off", "Octave:invalid-input-arg");
-%! unwind_protect
-%!   odeopt = odeset ("NewtonTol", 3);
-%!   assert (odeopt.NewtonTol, 3);
-%! unwind_protect_cleanup
-%!   warning (wstate);
-%! end_unwind_protect
+%! warning ("off", "Octave:invalid-input-arg", "local");
+%! odeopt = odeset ("NewtonTol", 3);
+%! assert (odeopt.NewtonTol, 3);
 
 ## FIXME: Add an inexact match option once it is available in inputParser.
 ## See bug #49364.
 ## %!warning <no exact match for 'Rel'.  Assuming 'RelTol'> odeset ("Rel", 1);
 ## %!error <Possible fields found: InitialSlope, InitialStep> odeset ("Initial", 1)
 
 ## Test input validation
 %!error <argument 'OPT1' is not a valid parameter> odeset ("opt1")
-%!error  odeset (1, 1)
+%!error odeset (1, 1)
 %!error <argument 'OPT1' is not a valid parameter> odeset (odeset (), "opt1")
-%!error  odeset (odeset (), 1, 1)
+%!error odeset (odeset (), 1, 1)
 
-##FIXME: Add not exact match option
-## %!warning <no exact match for 'Rel'.  Assuming 'RelTol'> odeset ("Rel", 1);
-## %!error <Possible fields found: InitialSlope, InitialStep> odeset ("Initial", 1)
-
-
diff --git a/scripts/ode/private/integrate_adaptive.m b/scripts/ode/private/integrate_adaptive.m
--- a/scripts/ode/private/integrate_adaptive.m
+++ b/scripts/ode/private/integrate_adaptive.m
@@ -91,18 +91,18 @@ function solution = integrate_adaptive (
 
   ## Initialize the OutputFcn
   if (options.haveoutputfunction)
     if (! isempty (options.OutputSel))
       solution.retout = x(options.OutputSel,end);
     else
       solution.retout = x;
     endif
-    feval (options.OutputFcn, tspan, solution.retout,
-           "init", options.funarguments{:});
+    feval (options.OutputFcn, tspan, solution.retout, "init",
+           options.funarguments{:});
   endif
 
   ## Initialize the EventFcn
   if (! isempty (options.Events))
     ode_event_handler (options.Events, tspan(end), x,
                        "init", options.funarguments{:});
   endif
 
@@ -111,16 +111,17 @@ function solution = integrate_adaptive (
   endif
 
   solution.cntloop = 0;
   solution.cntcycles = 0;
   solution.cntsave = 2;
   solution.unhandledtermination = true;
   ireject = 0;
 
+  NormControl = strcmp (options.NormControl, "on");
   k_vals = [];
   iout = istep = 1;
 
   while (dir * t_old < dir * tspan(end))
 
     ## Compute integration step from t_old to t_new = t_old + dt
     [t_new, options.comp] = kahan (t_old, options.comp, dt);
     [t_new, x_new, x_est, new_k_vals] = ...
@@ -128,19 +129,18 @@ function solution = integrate_adaptive (
 
     solution.cntcycles += 1;
 
     if (options.havenonnegative)
       x_new(nn, end) = abs (x_new(nn, end));
       x_est(nn, end) = abs (x_est(nn, end));
     endif
 
-    ## FIXME: Take strcmp out of while loop and calculate just once
     err = AbsRel_norm (x_new, x_old, options.AbsTol, options.RelTol,
-                       strcmp (options.NormControl, "on"), x_est);
+                       NormControl, x_est);
 
     ## Accept solution only if err <= 1.0
     if (err <= 1)
 
       solution.cntloop += 1;
       ireject = 0;              # Clear reject counter
 
       ## if output time steps are fixed
@@ -181,32 +181,36 @@ function solution = integrate_adaptive (
               endif
             endfor
             if (break_loop)
               break;
             endif
           endif
 
           ## Call OutputFcn only if a valid result has been found.
-          ## Stop integration if function returns false.
+          ## Stop integration if function returns true.
           if (options.haveoutputfunction)
             cnt = options.Refine + 1;
             approxtime = linspace (t_old, t_new, cnt);
             approxvals = interp1 ([t_old, t(t_caught), t_new],
                                   [x_old, x(:, t_caught), x_new] .',
                                   approxtime, "linear") .';
             if (! isempty (options.OutputSel))
               approxvals = approxvals(options.OutputSel, :);
             endif
+            stop_solve = false;
             for ii = 1:numel (approxtime)
-              pltret = feval (options.OutputFcn, approxtime(ii),
-                              approxvals(:, ii), [],
-                              options.funarguments{:});
+              stop_solve = feval (options.OutputFcn,
+                                  approxtime(ii), approxvals(:, ii), [],
+                                  options.funarguments{:});
+              if (stop_solve)
+                break;  # break from inner loop
+              endif
             endfor
-            if (pltret)  # Leave main loop
+            if (stop_solve)  # Leave main loop
               solution.unhandledtermination = false;
               break;
             endif
           endif
 
         endif
 
       else   # not fixed times
@@ -225,31 +229,36 @@ function solution = integrate_adaptive (
             t(istep) = solution.event{3}(end);
             x(:, istep) = solution.event{4}(end, :).';
             solution.unhandledtermination = false;
             break;
           endif
         endif
 
         ## Call OutputFcn only if a valid result has been found.
-        ## Stop integration if function returns false.
+        ## Stop integration if function returns true.
         if (options.haveoutputfunction)
           cnt = options.Refine + 1;
           approxtime = linspace (t_old, t_new, cnt);
           approxvals = interp1 ([t_old, t_new],
                                 [x_old, x_new] .',
                                 approxtime, "linear") .';
           if (! isempty (options.OutputSel))
             approxvals = approxvals(options.OutputSel, :);
           endif
+          stop_solve = false;
           for ii = 1:numel (approxtime)
-            pltret = feval (options.OutputFcn, approxtime(ii),
-                            approxvals(:, ii), [], options.funarguments{:});
+            stop_solve = feval (options.OutputFcn,
+                                approxtime(ii), approxvals(:, ii), [],
+                                options.funarguments{:});
+            if (stop_solve)
+              break;  # break from inner loop
+            endif
           endfor
-          if (pltret)  # Leave main loop
+          if (stop_solve)  # Leave main loop
             solution.unhandledtermination = false;
             break;
           endif
         endif
 
       endif
 
       ## move to next time-step
@@ -275,17 +284,17 @@ function solution = integrate_adaptive (
       endif
 
     endif
 
     ## Compute next timestep, formula taken from Hairer
     err += eps;  # avoid divisions by zero
     dt *= min (facmax, max (facmin, fac * (1 / err)^(1 / (order + 1))));
     dt = dir * min (abs (dt), options.MaxStep);
-    if (! (abs (dt) > eps (t (end))))
+    if (! (abs (dt) > eps (t(end))))
       break;
     endif
 
     ## Make sure we don't go past tpan(end)
     dt = dir * min (abs (dt), abs (tspan(end) - t_old));
 
   endwhile
 
diff --git a/scripts/ode/private/ode_event_handler.m b/scripts/ode/private/ode_event_handler.m
--- a/scripts/ode/private/ode_event_handler.m
+++ b/scripts/ode/private/ode_event_handler.m
@@ -14,107 +14,85 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {@var{retval} =} ode_event_handler (@var{@@evtfun}, @var{t}, @var{y}, @var{flag}, @var{par1}, @var{par2}, @dots{})
 ##
-## Return the solution of the event function that is specified as the first
-## input argument @var{@@evtfun} in the form of a function handle.
+## Return the solution of the event function (@var{@@evtfun}) which is
+## specified in the form of a function handle.
+#
+## The second input argument @var{t} is a scalar double and specifies the time
+## of the event evaluation.
 ##
-## The second input argument @var{t} is of type double scalar and
-## specifies the time of the event evaluation, the third input argument
-## @var{y} either is of type double column vector (for ODEs and DAEs) and
-## specifies the solutions or is of type cell array (for IDEs and DDEs) and
-## specifies the derivatives or the history values, the third input argument
-## @var{flag} is of type string and can be of the form
+## The third input argument @var{y} may be a column vector of type double
+## (for ODEs and DAEs) which specifies the solutions.  Alternatives, @var{y}
+## may be a cell array (for IDEs and DDEs) which specifies the solutions and
+## derivatives.
+##
+## The fourth input argument @var{flag} is of type string.  Valid values are:
 ##
 ## @table @option
 ## @item  @qcode{"init"}
-## then initialize internal persistent variables of the function
-## @code{ode_event_handler} and return an empty cell array of size 4,
+## Initialize internal persistent variables of the function
+## @code{ode_event_handler} and return an empty cell array of size 4.
 ##
 ## @item  @qcode{"calc"}
-## then do the evaluation of the event function and return the solution
-## @var{retval} as type cell array of size 4,
+## Evaluate the event function and return the solution @var{retval} as a cell
+## array of size 4.
 ##
 ## @item  @qcode{"done"}
-## then cleanup internal variables of the function
-## @code{ode_event_handler} and return an empty cell array of size 4.
+## Clean up internal variables of the function @code{ode_event_handler} and
+## return an empty cell array of size 4.
 ## @end table
 ##
-## Optionally if further input arguments @var{par1}, @var{par2}, @dots{} of
-## any type are given then pass these parameters through
-## @code{ode_event_handler} to the event function.
+## If additional input arguments @var{par1}, @var{par2}, @dots{} are given
+## these parameters are passed directly to the event function.
 ##
-## This function is an ODE internal helper function therefore it should
-## never be necessary that this function is called directly by a user.  There
-## is only little error detection implemented in this function file to
-## achieve the highest performance.
+## This function is an ODE internal helper function and it should never be
+## necessary to call it directly.
 ## @end deftypefn
 
 function retval = ode_event_handler (evtfun, t, y, flag = "", varargin)
 
   ## No error handling has been implemented in this function to achieve
-  ## the highest performance available.
+  ## the highest performance possible.
 
   ## retval{1} is true (to terminate) or false (to continue)
   ## retval{2} is the index information for which an event occurred
   ## retval{3} is the time information column vector
   ## retval{4} is the line by line result information matrix
 
   ## These persistent variables store the results and time value from the
   ## processing in the previous time stamp.
   ## evtold  the results from the event function
   ## told    the time stamp
   ## yold    the ODE result
   ## retcell the return values cell array
   ## evtcnt  the counter for how often this function has been called
-  persistent evtold told yold retcell evtcnt;
-
-  ## Call the event function if an event function has been defined to
-  ## initialize the internal variables of the event function and to get
-  ## a value for evtold.
-  if (strcmp (flag, "init"))
+  persistent evtold told yold retcell;
+  persistent evtcnt = 1;   # Don't remove.  Required for Octave parser.
 
-    if (! iscell (y))
-      inpargs = {evtfun, t, y};
-    else
-      inpargs = {evtfun, t, y{1}, y{2}};
-      y = y{1};  # Delete cell element 2
-    endif
-    if (nargin > 4)
-      inpargs = {inpargs{:}, varargin{:}};
-    endif
-    [evtold, term, dir] = feval (inpargs{:});
-
-    ## FIXME: This actually seems to assume that everything must be row vectors
-    ## We assume that all return values must be column vectors
-    evtold = evtold(:)'; term = term(:)'; dir = dir(:)';
-    told = t; yold = y; evtcnt = 1; retcell = cell (1,4);
-
-  ## Process the event, i.e.,
-  ## find the zero crossings for either a rising or falling edge
-  elseif (isempty (flag))
-
+  if (isempty (flag))
+    ## Process the event, i.e.,
+    ## find the zero crossings for either a rising or falling edge
     if (! iscell (y))
       inpargs = {evtfun, t, y};
     else
       inpargs = {evtfun, t, y{1}, y{2}};
       y = y{1};  # Delete cell element 2
     endif
     if (nargin > 4)
       inpargs = {inpargs{:}, varargin{:}};
     endif
     [evt, term, dir] = feval (inpargs{:});
 
-    ## FIXME: This actually seems to assume that everything must be row vectors
-    ## We assume that all return values must be column vectors
+    ## We require that all return values be row vectors
     evt = evt(:)'; term = term(:)'; dir = dir(:)';
 
     ## Check if one or more signs of the event has changed
     signum = (sign (evtold) != sign (evt));
     if (any (signum))         # One or more values have changed
       idx = find (signum);    # Get the index of the changed values
 
       if (any (dir(idx) == 0))
@@ -138,19 +116,42 @@ function retval = ode_event_handler (evt
         ## a linear interpolation
         tnew = t - evt(1,idx) * (t - told) / (evt(1,idx) - evtold(1,idx));
         ynew = (y - (t - tnew) * (y - yold) / (t - told))';
         retcell{3}(evtcnt,1) = tnew;
         retcell{4}(evtcnt,:) = ynew;
         evtcnt += 1;
       endif
 
-    endif  # Check for one or more signs ...
-    evtold = evt; told = t; retval = retcell; yold = y;
+    endif
+    evtold = evt; told = t; yold = y;
+    retval = retcell;
+
+  elseif (strcmp (flag, "init"))
+    ## Call the event function if an event function has been defined to
+    ## initialize the internal variables of the event function and to get
+    ## a value for evtold.
 
-  elseif (strcmp (flag, "done"))  # Clear this event handling function
-    clear ("evtold", "told", "retcell", "yold", "evtcnt");
-    retcell = cell (1,4);
+    if (! iscell (y))
+      inpargs = {evtfun, t, y};
+    else
+      inpargs = {evtfun, t, y{1}, y{2}};
+      y = y{1};  # Delete cell element 2
+    endif
+    if (nargin > 4)
+      inpargs = {inpargs{:}, varargin{:}};
+    endif
+    [evtold, ~, ~] = feval (inpargs{:});
+
+    ## We require that all return values be row vectors
+    evtold = evtold(:)'; told = t; yold = y;
+    evtcnt = 1;
+    retval = retcell = cell (1,4);
+
+  elseif (strcmp (flag, "done"))
+    ## Clear this event handling function
+    evtold = told = yold = evtcnt = [];
+    retval = retcell = cell (1,4);
 
   endif
 
 endfunction
 
diff --git a/scripts/ode/private/odedefaults.m b/scripts/ode/private/odedefaults.m
--- a/scripts/ode/private/odedefaults.m
+++ b/scripts/ode/private/odedefaults.m
@@ -28,43 +28,41 @@ function [defaults, classes, attributes]
                                 "BDF", "off",
                                 "Events", [],
                                 "InitialSlope", zeros (n,1),
                                 "InitialStep", [],
                                 "Jacobian", [],
                                 "JConstant", "off",
                                 "JPattern", [],
                                 "Mass", [],
-                                "MassConstant", "off",
                                 "MassSingular", "maybe",
                                 "MaxOrder", 5,
-                                "MaxStep", 0.1 * abs (t0-tf),
+                                "MaxStep", 0.1 * abs (tf - t0),
                                 "MStateDependence", "weak",
                                 "MvPattern", [],
                                 "NonNegative", [],
                                 "NormControl", "off",
                                 "OutputFcn", [],
                                 "OutputSel", [],
                                 "Refine", 1,
                                 "RelTol", 1e-3,
                                 "Stats", "off",
                                 "Vectorized", "off");
 
-  defaults.MaxStep = (0.1 * abs (t0-tf));
+  defaults.MaxStep = 0.1 * abs (tf -t0);
 
   persistent classes = struct ("AbsTol", {{"float"}},
                                "BDF", "char",
                                "Events", {{"function_handle"}},
                                "InitialSlope", {{"float"}},
                                "InitialStep", {{"float"}},
                                "Jacobian", {{"float", "function_handle", "cell"}},
                                "JConstant", "char",
                                "JPattern", {{"float"}},
                                "Mass", {{"float", "function_handle"}},
-                               "MassConstant", "char",
                                "MassSingular", "char",
                                "MaxOrder", {{"float"}},
                                "MaxStep", {{"float"}},
                                "MStateDependence", "char",
                                "MvPattern", {{"float"}},
                                "NonNegative", {{"float"}},
                                "NormControl", "char",
                                "OutputFcn", {{"function_handle"}},
@@ -78,17 +76,16 @@ function [defaults, classes, attributes]
                                   "BDF", {{"on", "off"}},
                                   "Events", {{}},
                                   "InitialSlope", {{"real", "vector", "numel", n}},
                                   "InitialStep", {{"positive", "scalar"}},
                                   "Jacobian", {{}},
                                   "JConstant", {{"on", "off"}},
                                   "JPattern", {{"vector"}},
                                   "Mass", {{}},
-                                  "MassConstant", {{"on", "off"}},
                                   "MassSingular", {{"no", "maybe", "yes"}},
                                   "MaxOrder", {{">=", 0, "<=", 5, "integer"}},
                                   "MaxStep", {{"positive", "scalar", "real"}},
                                   "MStateDependence", {{"weak", "strong", "none"}},
                                   "MvPattern", {{"vector"}},
                                   "NonNegative", {{"vector", "integer", "positive"}},
                                   "NormControl", {{"on", "off"}},
                                   "OutputFcn", {{}},
