# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1322904857 18000
#      Sat Dec 03 04:34:17 2011 -0500
# Node ID 7dd7cccf0757aaf6a68c61617e4beaa319d4deb0
# Parent  6cdfbe90e2ab89246acc7ecfde6026f033cc6c5c
clean up memory allocated for singletons before exit

* singleton-cleanup.h, singleton-cleanup.cc: New files.
* liboctave/Makefile.am (INCS, LIBOCTAVE_CXX_SOURCES):
Add them to the lists.

* toplev.cc (clean_up_and_exit): Call singleton_cleanup_list::cleanup.

* debug.h, debug.cc (bp_table::instance_ok): Move definition to
debug.cc.

* coment-list.h (octave_comment_buffer::~octave_comment_buffer):
Define destructor for class.
* ov-typeinfo.h (octave_value_typeinfo::~octave_value_typeinfo):
Likewise.

* cmd-edit.h (command_editor::cleanup_instance): New function.
* cmd-hist.h (command_history::cleanup_instance): New function.
* file-ops.h (file_ops::cleanup_instance): New function.
* mach-info.h (oct_mach_info::cleanup_instance): New function.
* oct-env.h (octave_env::cleanup_instance): New function.
* oct-fftw.h (octave_fftw_planner::cleanup_instance): New function.
* oct-rand.h (octave_rand::cleanup_instance): New function.
* oct-spparms.h (octave_sparse_params::cleanup_instance):
New function.
* pathsearch.h (static_members::cleanup_instance): New function.
* comment-list.h (octave_comment_buffer::cleanup_instance):
New function.
* debug.h (bp_table::cleanup_instance): New function.
* display.h (display_info::cleanup_instance): New function.
* dynamic-ld.cc (octave_shlib_list::cleanup_instance,
octave_mex_file_list::cleanup_instance): New functions.
* dynamic-ld.h (octave_dynamic_loader::cleanup_instance):
New function.
* load-path.h (load_path::cleanup_instance): New function.
* oct-stream.h (octave_stream_list::cleanup_instance): New function.
* ov-typeinfo.h (octave_value_typeinfo::cleanup_instance):
New function.
* pager.h, pager.cc (octave_pager_stream::instance_ok,
octave_pager_stream::cleanup_instance): New functions.
(octave_diary_stream::instance_ok,
octave_diary_stream::cleanup_instance): New functions.
* sighandlers.h (octave_child_list::cleanup_instance): New function.
* toplev.h (octave_call_stack
* pager.cc (octave_pager_stream::stream, octave_diary_stream::stream):
Use instance_ok to create instance.
* toplev.h (octave_call_stack::cleanup_instance): New function.

* cmd-edit.cc (command_editor::instance_ok):
Register cleanup function.
* cmd-hist.cc (command_history::instance_ok): Likewise.
* file-ops.cc (file_ops::instance_ok): Likewise.
* mach-info.cc (oct_mach_info::instance_ok): Likewise.
* oct-env.cc (octave_env::instance_ok): Likewise.
* oct-fftw.cc (octave_fftw_planner::instance_ok): Likewise.
* oct-rand.cc (octave_rand::instance_ok): Likewise.
* oct-spparms.cc (octave_sparse_params::instance_ok): Likewise.
* pathsearch.cc (dir_path::static_members::instance_ok): Likewise.
* comment-list.cc (comment_list::instance_ok): Likewise.
* debug.cc (bp_table::instance_ok): Likewise.
* display.cc (display_info::instance_ok): Likewise.
* dynamic-ld.cc (octave_shlib_list::instance_ok,
octave_mex_file_list::instance_ok, octave_dynamic_loader): Likewise.
* load-path.cc (load_path::instance_ok): Likewise.
* oct-stream.cc (octave_stream_list::instance_ok): Likewise.
* ov-typeinfo.cc (octave_value_typeinfo::instance_ok): Likewise.
* sighandlers.cc (octave_child_list::instance_ok): Likewise.

* symtab.h, symtab.cc (symbol_table::scope_id::create_instance):
New function.
* symtab.h (symbol_table::scope_id::instance_ok): Call create_instance.

* toplev.h, toplev.cc (octave_call_stack::create_instance):
New function.
* toplev.cc (octave_call_stack::instance_ok): Call create_instance.

* pager.h, pager.cc (octave_pager_stream::set_diary_skip,
octave_pager_stream::flush_current_contents_to_diary): Now static.
octave_pager_stream::do_set_diary_skip,
octave_pager_stream::do_flush_current_contents_to_diary):
New functions.
(octave_pager_stream::stream): Return std::ostream&, not
octave_pager_stream&.  If instance creation fails, return std::cout.
(octave_diary_stream::stream): Return std::ostream&, not
octave_diary_stream&.  If instance creation fails, return std::cout.
(octave_pager_stream::do_reset, octave_diary_stream::do_reset):
Use instance_ok to create instance.

diff --git a/liboctave/Makefile.am b/liboctave/Makefile.am
--- a/liboctave/Makefile.am
+++ b/liboctave/Makefile.am
@@ -239,16 +239,17 @@ INCS = \
   oct-time.h \
   oct-uname.h \
   pathlen.h \
   pathsearch.h \
   randgamma.h \
   randmtzig.h \
   randpoisson.h \
   regex-match.h \
+  singleton-cleanup.h \
   sparse-sort.h \
   sparse-util.h \
   statdefs.h \
   str-vec.h \
   sun-utils.h \
   sysdir.h \
   syswait.h \
   $(MATRIX_INC)
@@ -447,16 +448,17 @@ LIBOCTAVE_CXX_SOURCES = \
   oct-rand.cc \
   oct-shlib.cc \
   oct-spparms.cc \
   oct-syscalls.cc \
   oct-time.cc \
   oct-uname.cc \
   pathsearch.cc \
   regex-match.cc \
+  singleton-cleanup.cc \
   sparse-sort.cc \
   sparse-util.cc \
   str-vec.cc \
   $(TI_SRC) \
   $(MATRIX_SRC)
 
 include vx-op-src.mk
 include mx-op-src.mk
diff --git a/liboctave/cmd-edit.cc b/liboctave/cmd-edit.cc
--- a/liboctave/cmd-edit.cc
+++ b/liboctave/cmd-edit.cc
@@ -37,16 +37,17 @@ along with Octave; see the file COPYING.
 #include "cmd-edit.h"
 #include "cmd-hist.h"
 #include "file-ops.h"
 #include "lo-error.h"
 #include "lo-utils.h"
 #include "oct-env.h"
 #include "oct-mutex.h"
 #include "oct-time.h"
+#include "singleton-cleanup.h"
 
 command_editor *command_editor::instance = 0;
 
 std::set<command_editor::startup_hook_fcn> command_editor::startup_hook_set;
 
 std::set<command_editor::event_hook_fcn> command_editor::event_hook_set;
 
 static octave_mutex event_hook_lock;
@@ -826,17 +827,22 @@ default_command_editor::do_accept_line (
 }
 
 bool
 command_editor::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    make_command_editor ();
+    {
+      make_command_editor ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       current_liboctave_error_handler
         ("unable to create command history object!");
 
       retval = false;
     }
diff --git a/liboctave/cmd-edit.h b/liboctave/cmd-edit.h
--- a/liboctave/cmd-edit.h
+++ b/liboctave/cmd-edit.h
@@ -179,16 +179,18 @@ private:
   typedef std::set<startup_hook_fcn>::const_iterator startup_hook_set_const_iterator;
 
   typedef std::set<event_hook_fcn>::iterator event_hook_set_iterator;
   typedef std::set<event_hook_fcn>::const_iterator event_hook_set_const_iterator;
 
   // The real thing.
   static command_editor *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
 protected:
 
   // To use something other than the GNU readline library, derive a new
   // class from command_editor, overload these functions as
   // necessary, and make instance point to the new class.
 
   virtual void do_set_name (const std::string&) { }
 
diff --git a/liboctave/cmd-hist.cc b/liboctave/cmd-hist.cc
--- a/liboctave/cmd-hist.cc
+++ b/liboctave/cmd-hist.cc
@@ -44,16 +44,17 @@ command_history *command_history::instan
 #include <sys/types.h>
 #include <unistd.h>
 
 #include <fcntl.h>
 
 #include "oct-rl-hist.h"
 
 #include "file-stat.h"
+#include "singleton-cleanup.h"
 
 class
 gnu_history : public command_history
 {
 public:
 
   gnu_history (void)
     : command_history (), mark (0) { }
@@ -462,17 +463,22 @@ gnu_history::do_clean_up_and_save (const
 #endif
 
 bool
 command_history::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    make_command_history ();
+    {
+      make_command_history ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       (*current_liboctave_error_handler)
         ("unable to create command history object!");
 
       retval = false;
     }
diff --git a/liboctave/cmd-hist.h b/liboctave/cmd-hist.h
--- a/liboctave/cmd-hist.h
+++ b/liboctave/cmd-hist.h
@@ -121,16 +121,18 @@ private:
 
   static bool instance_ok (void);
 
   static void make_command_history (void);
 
   // The real thing.
   static command_history *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
 protected:
 
   // To use something other than the GNU history library, derive a new
   // class from command_history, overload these functions as
   // necessary, and make instance point to the new class.
 
   virtual void do_set_file (const std::string&);
 
diff --git a/liboctave/file-ops.cc b/liboctave/file-ops.cc
--- a/liboctave/file-ops.cc
+++ b/liboctave/file-ops.cc
@@ -37,21 +37,22 @@ along with Octave; see the file COPYING.
 #include <unistd.h>
 
 #include "pathmax.h"
 
 #include "dir-ops.h"
 #include "file-ops.h"
 #include "file-stat.h"
 #include "oct-env.h"
+#include "oct-locbuf.h"
 #include "oct-passwd.h"
 #include "pathlen.h"
 #include "quit.h"
+#include "singleton-cleanup.h"
 #include "str-vec.h"
-#include "oct-locbuf.h"
 
 file_ops *file_ops::instance = 0;
 
 bool
 file_ops::instance_ok (void)
 {
   bool retval = true;
 
@@ -68,23 +69,26 @@ file_ops::instance_ok (void)
       std::string system_dir_sep_chars = "/\\";
 #else
       std::string system_dir_sep_chars = system_dir_sep_str;
 #endif
 
       instance = new file_ops (system_dir_sep_char, system_dir_sep_str,
                                system_dir_sep_chars);
 
-      if (! instance)
-        {
-          (*current_liboctave_error_handler)
-            ("unable to create file_ops object!");
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
-          retval = false;
-        }
+  if (! instance)
+    {
+      (*current_liboctave_error_handler)
+        ("unable to create file_ops object!");
+
+      retval = false;
     }
 
   return retval;
 }
 
 // The following tilde-expansion code was stolen and adapted from
 // readline.
 
diff --git a/liboctave/file-ops.h b/liboctave/file-ops.h
--- a/liboctave/file-ops.h
+++ b/liboctave/file-ops.h
@@ -94,16 +94,18 @@ public:
 
     return path.substr (ipos);
   }
 
 private:
 
   static file_ops *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   // No copying!
 
   file_ops (const file_ops&);
 
   file_ops& operator = (const file_ops&);
 
   static bool instance_ok (void);
 
diff --git a/liboctave/mach-info.cc b/liboctave/mach-info.cc
--- a/liboctave/mach-info.cc
+++ b/liboctave/mach-info.cc
@@ -22,16 +22,17 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "mach-info.h"
+#include "singleton-cleanup.h"
 
 extern "C"
 {
   double F77_FUNC (d1mach, D1MACH) (const octave_idx_type&);
 }
 
 oct_mach_info *oct_mach_info::instance = 0;
 
@@ -158,17 +159,22 @@ oct_mach_info::oct_mach_info (void)
     big_chief (ten_little_endians ()) { }
 
 bool
 oct_mach_info::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new oct_mach_info ();
+    {
+      instance = new oct_mach_info ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       (*current_liboctave_error_handler)
         ("unable to create command history object!");
 
       retval = false;
     }
diff --git a/liboctave/mach-info.h b/liboctave/mach-info.h
--- a/liboctave/mach-info.h
+++ b/liboctave/mach-info.h
@@ -56,16 +56,18 @@ public:
   static float_format string_to_float_format (const std::string&);
 
   static std::string float_format_as_string (float_format);
 
 private:
 
   static oct_mach_info *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   // The floating point format for the current machine.
   mutable float_format native_float_fmt;
 
   // TRUE if the byte order on this system is big endian.
   mutable bool big_chief;
 
   // No copying!
 
diff --git a/liboctave/oct-env.cc b/liboctave/oct-env.cc
--- a/liboctave/oct-env.cc
+++ b/liboctave/oct-env.cc
@@ -53,16 +53,17 @@ Free Software Foundation, Inc.
 
 #include "file-ops.h"
 #include "lo-error.h"
 #include "lo-sysdep.h"
 #include "lo-utils.h"
 #include "oct-env.h"
 #include "oct-passwd.h"
 #include "oct-syscalls.h"
+#include "singleton-cleanup.h"
 
 octave_env::octave_env (void)
   : follow_symbolic_links (true), verbatim_pwd (true),
     current_directory (), prog_name (), prog_invocation_name (),
     user_name (), host_name ()
 {
   // Get a real value for the current directory.
   do_getcwd ();
@@ -76,17 +77,22 @@ octave_env::octave_env (void)
 octave_env *octave_env::instance = 0;
 
 bool
 octave_env::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new octave_env ();
+    {
+      instance = new octave_env ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       (*current_liboctave_error_handler)
         ("unable to create current working directory object!");
 
       retval = false;
     }
diff --git a/liboctave/oct-env.h b/liboctave/oct-env.h
--- a/liboctave/oct-env.h
+++ b/liboctave/oct-env.h
@@ -110,16 +110,19 @@ private:
 
   octave_env (const octave_env&);
 
   octave_env& operator = (const octave_env&);
 
   // The real thing.
   static octave_env *instance;
 
+
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   // TRUE means follow symbolic links that point to directories just
   // as if they are real directories.
   bool follow_symbolic_links;
 
   // TRUE means that pwd always give verbatim directory, regardless
   // of symbolic link following.
   bool verbatim_pwd;
 
diff --git a/liboctave/oct-fftw.cc b/liboctave/oct-fftw.cc
--- a/liboctave/oct-fftw.cc
+++ b/liboctave/oct-fftw.cc
@@ -28,16 +28,17 @@ along with Octave; see the file COPYING.
 
 #include <iostream>
 #include <vector>
 
 #include "lo-error.h"
 #include "oct-fftw.h"
 #include "quit.h"
 #include "oct-locbuf.h"
+#include "singleton-cleanup.h"
 
 octave_fftw_planner *octave_fftw_planner::instance = 0;
 
 // Helper class to create and cache fftw plans for both 1d and
 // 2d. This implementation defaults to using FFTW_ESTIMATE to create
 // the plans, which in theory is suboptimal, but provides quit
 // reasonable performance.
 
@@ -70,17 +71,22 @@ octave_fftw_planner::octave_fftw_planner
 }
 
 bool
 octave_fftw_planner::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new octave_fftw_planner ();
+    {
+      instance = new octave_fftw_planner ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       (*current_liboctave_error_handler)
         ("unable to create octave_fftw_planner object!");
 
       retval = false;
     }
diff --git a/liboctave/oct-fftw.h b/liboctave/oct-fftw.h
--- a/liboctave/oct-fftw.h
+++ b/liboctave/oct-fftw.h
@@ -103,16 +103,18 @@ private:
   // No copying!
 
   octave_fftw_planner (const octave_fftw_planner&);
 
   octave_fftw_planner& operator = (const octave_fftw_planner&);
 
   static octave_fftw_planner *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   fftw_plan
   do_create_plan (int dir, const int rank, const dim_vector dims,
                   octave_idx_type howmany, octave_idx_type stride,
                   octave_idx_type dist, const Complex *in,
                   Complex *out);
 
   fftw_plan
   do_create_plan (const int rank, const dim_vector dims,
diff --git a/liboctave/oct-rand.cc b/liboctave/oct-rand.cc
--- a/liboctave/oct-rand.cc
+++ b/liboctave/oct-rand.cc
@@ -24,28 +24,29 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include <map>
 #include <vector>
 
 #include <stdint.h>
 
+#include "data-conv.h"
 #include "f77-fcn.h"
+#include "lo-error.h"
 #include "lo-ieee.h"
-#include "lo-error.h"
 #include "lo-mappers.h"
+#include "mach-info.h"
+#include "oct-locbuf.h"
 #include "oct-rand.h"
 #include "oct-time.h"
-#include "data-conv.h"
+#include "randgamma.h"
 #include "randmtzig.h"
 #include "randpoisson.h"
-#include "randgamma.h"
-#include "mach-info.h"
-#include "oct-locbuf.h"
+#include "singleton-cleanup.h"
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dgennor, DGENNOR) (const double&, const double&, double&);
 
   F77_RET_T
   F77_FUNC (dgenunf, DGENUNF) (const double&, const double&, double&);
@@ -84,17 +85,22 @@ octave_rand::octave_rand (void)
 }
 
 bool
 octave_rand::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new octave_rand ();
+    {
+      instance = new octave_rand ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       (*current_liboctave_error_handler)
         ("unable to create octave_rand object!");
 
       retval = false;
     }
diff --git a/liboctave/oct-rand.h b/liboctave/oct-rand.h
--- a/liboctave/oct-rand.h
+++ b/liboctave/oct-rand.h
@@ -155,16 +155,18 @@ public:
   {
     return instance_ok () ? instance->do_vector (n, a) : Array<double> ();
   }
 
 private:
 
   static octave_rand *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   enum
   {
     unknown_dist,
     uniform_dist,
     normal_dist,
     expon_dist,
     poisson_dist,
     gamma_dist
diff --git a/liboctave/oct-spparms.cc b/liboctave/oct-spparms.cc
--- a/liboctave/oct-spparms.cc
+++ b/liboctave/oct-spparms.cc
@@ -24,26 +24,32 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "lo-error.h"
 #include "lo-ieee.h"
 
 #include "oct-spparms.h"
+#include "singleton-cleanup.h"
 
 octave_sparse_params *octave_sparse_params::instance = 0;
 
 bool
 octave_sparse_params::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new octave_sparse_params ();
+    {
+      instance = new octave_sparse_params ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       (*current_liboctave_error_handler)
         ("unable to create octave_sparse_params object!");
 
       retval = false;
     }
diff --git a/liboctave/oct-spparms.h b/liboctave/oct-spparms.h
--- a/liboctave/oct-spparms.h
+++ b/liboctave/oct-spparms.h
@@ -90,16 +90,18 @@ public:
 private:
 
   ColumnVector params;
 
   string_vector keys;
 
   static octave_sparse_params *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   void do_defaults (void);
 
   void do_tight (void);
 
   string_vector do_get_keys (void) const { return keys; }
 
   ColumnVector do_get_vals (void) const { return params; }
 
diff --git a/liboctave/pathsearch.cc b/liboctave/pathsearch.cc
--- a/liboctave/pathsearch.cc
+++ b/liboctave/pathsearch.cc
@@ -26,33 +26,38 @@ along with Octave; see the file COPYING.
 
 #include <cstdlib>
 
 #include <string>
 
 #include "lo-utils.h"
 #include "oct-env.h"
 #include "pathsearch.h"
-#include "str-vec.h"
+#include "singleton-cleanup.h"
 #include "str-vec.h"
 
 #include "kpse.cc"
 
 dir_path::static_members *dir_path::static_members::instance = 0;
 
 dir_path::static_members::static_members (void)
   : xpath_sep_char (SEPCHAR), xpath_sep_str (SEPCHAR_STR) { }
 
 bool
 dir_path::static_members::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new static_members ();
+    {
+      instance = new static_members ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       (*current_liboctave_error_handler)
         ("unable to create dir_path::static_members object!");
 
       retval = false;
     }
diff --git a/liboctave/pathsearch.h b/liboctave/pathsearch.h
--- a/liboctave/pathsearch.h
+++ b/liboctave/pathsearch.h
@@ -148,16 +148,18 @@ private:
     {
       return instance_ok () ? instance->xpath_sep_str : std::string ();
     }
 
   private:
 
     static static_members *instance;
 
+    static void cleanup_instance (void) { delete instance; instance = 0; }
+
     static bool instance_ok (void);
 
     // No copying!
 
     static_members (const static_members&);
 
     static_members& operator = (const static_members&);
 
diff --git a/liboctave/singleton-cleanup.cc b/liboctave/singleton-cleanup.cc
new file mode 100644
--- /dev/null
+++ b/liboctave/singleton-cleanup.cc
@@ -0,0 +1,60 @@
+/*
+
+Copyright (C) 2011 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <lo-error.h>
+#include <singleton-cleanup.h>
+
+singleton_cleanup_list *singleton_cleanup_list::instance = 0;
+
+singleton_cleanup_list::~singleton_cleanup_list (void)
+{
+  for (std::set<fptr>::iterator p = fcn_list.begin ();
+       p != fcn_list.end (); p++)
+    {
+      fptr fcn = *p;
+
+      fcn ();
+    }
+}
+
+bool
+singleton_cleanup_list::instance_ok (void)
+{
+  bool retval = true;
+
+  if (! instance)
+    instance = new singleton_cleanup_list ();
+
+  if (! instance)
+    {
+      current_liboctave_error_handler
+        ("unable to create singleton_cleanup_list object!");
+
+      retval = false;
+    }
+
+  return retval;
+}
diff --git a/liboctave/singleton-cleanup.h b/liboctave/singleton-cleanup.h
new file mode 100644
--- /dev/null
+++ b/liboctave/singleton-cleanup.h
@@ -0,0 +1,49 @@
+#if !defined (octave_singleton_cleanup_h)
+#define octave_singleton_cleanup_h 1
+
+#include <set>
+
+class
+singleton_cleanup_list
+{
+protected:
+
+  singleton_cleanup_list (void) : fcn_list () { }
+
+public:
+
+  typedef void (*fptr) (void);
+
+  ~singleton_cleanup_list (void);
+
+  static void add (fptr f)
+  {
+    if (instance_ok ())
+      instance->do_add (f);
+  }
+
+  static void cleanup (void) { delete instance; instance = 0; }
+
+private:
+
+  static singleton_cleanup_list *instance;
+
+  static bool instance_ok (void);
+
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
+  std::set<fptr> fcn_list;
+
+  void do_add (fptr f)
+  {
+    fcn_list.insert (f);
+  }
+
+  // No copying!
+
+  singleton_cleanup_list (const singleton_cleanup_list&);
+
+  singleton_cleanup_list& operator = (const singleton_cleanup_list&);
+};
+
+#endif
diff --git a/src/comment-list.cc b/src/comment-list.cc
--- a/src/comment-list.cc
+++ b/src/comment-list.cc
@@ -20,16 +20,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "lo-utils.h"
+#include "singleton-cleanup.h"
 
 #include "comment-list.h"
 #include "error.h"
 
 octave_comment_buffer *octave_comment_buffer::instance = 0;
 
 octave_comment_list *
 octave_comment_list::dup (void) const
@@ -47,17 +48,22 @@ octave_comment_list::dup (void) const
 }
 
 bool
 octave_comment_buffer::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new octave_comment_buffer ();
+    {
+      instance = new octave_comment_buffer ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       ::error ("unable to create comment buffer object");
 
       retval = false;
     }
 
diff --git a/src/comment-list.h b/src/comment-list.h
--- a/src/comment-list.h
+++ b/src/comment-list.h
@@ -100,16 +100,18 @@ public:
 class
 octave_comment_buffer
 {
 public:
 
   octave_comment_buffer (void)
     : comment_list (new octave_comment_list ()) { }
 
+  ~octave_comment_buffer (void) { delete comment_list; }
+
   static bool instance_ok (void);
 
   static void append
     (const std::string& s,
      octave_comment_elt::comment_type t = octave_comment_elt::unknown);
 
   static octave_comment_list *get_comment (void);
 
@@ -117,11 +119,13 @@ private:
 
   void do_append (const std::string& s, octave_comment_elt::comment_type t);
 
   octave_comment_list *do_get_comment (void);
 
   octave_comment_list *comment_list;
 
   static octave_comment_buffer *instance;
+
+  static void cleanup_instance (void) { delete instance; instance = 0; }
 };
 
 #endif
diff --git a/src/debug.cc b/src/debug.cc
--- a/src/debug.cc
+++ b/src/debug.cc
@@ -27,16 +27,17 @@ along with Octave; see the file COPYING.
 #include <deque>
 #include <fstream>
 #include <iomanip>
 #include <iostream>
 #include <set>
 #include <string>
 
 #include "file-stat.h"
+#include "singleton-cleanup.h"
 
 #include "defun.h"
 #include "error.h"
 #include "help.h"
 #include "input.h"
 #include "pager.h"
 #include "oct-obj.h"
 #include "utils.h"
@@ -245,16 +246,38 @@ parse_dbfunction_params (const char *who
             }
 
           if (error_state)
             break;
         }
     }
 }
 
+bool
+bp_table::instance_ok (void)
+{
+  bool retval = true;
+
+  if (! instance)
+    {
+      instance = new bp_table ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
+
+  if (! instance)
+    {
+      ::error ("unable to create breakpoint table!");
+      retval = false;
+    }
+
+  return retval;
+}
+
 bp_table::intmap
 bp_table::do_add_breakpoint (const std::string& fname,
                              const bp_table::intmap& line)
 {
   intmap retval;
 
   octave_idx_type len = line.size ();
 
diff --git a/src/debug.h b/src/debug.h
--- a/src/debug.h
+++ b/src/debug.h
@@ -50,31 +50,17 @@ public:
   typedef intmap::const_iterator const_intmap_iterator;
   typedef intmap::iterator intmap_iterator;
 
   typedef std::map <std::string, intmap> fname_line_map;
 
   typedef fname_line_map::const_iterator const_fname_line_map_iterator;
   typedef fname_line_map::iterator fname_line_map_iterator;
 
-  static bool instance_ok (void)
-  {
-    bool retval = true;
-
-    if (! instance)
-      instance = new bp_table ();
-
-    if (! instance)
-      {
-        ::error ("unable to create breakpoint table!");
-        retval = false;
-      }
-
-    return retval;
-  }
+  static bool instance_ok (void);
 
   // Add a breakpoint at the nearest executable line.
   static intmap add_breakpoint (const std::string& fname = "",
                                 const intmap& lines = intmap ())
   {
     return instance_ok ()
       ? instance->do_add_breakpoint (fname, lines) : intmap ();
   }
@@ -122,16 +108,18 @@ private:
   typedef std::set<std::string>::const_iterator const_bp_set_iterator;
   typedef std::set<std::string>::iterator bp_set_iterator;
 
   // Set of function names containing at least one breakpoint.
   std::set<std::string> bp_set;
 
   static bp_table *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   intmap do_add_breakpoint (const std::string& fname, const intmap& lines);
 
   int do_remove_breakpoint (const std::string&, const intmap& lines);
 
   intmap do_remove_all_breakpoints_in_file (const std::string& fname,
                                             bool silent);
 
   void do_remove_all_breakpoints (void);
diff --git a/src/display.cc b/src/display.cc
--- a/src/display.cc
+++ b/src/display.cc
@@ -29,16 +29,18 @@ along with Octave; see the file COPYING.
 #if defined (OCTAVE_USE_WINDOWS_API)
 #include <windows.h>
 #elif defined (HAVE_FRAMEWORK_CARBON)
 #include <Carbon/Carbon.h>
 #elif defined (HAVE_X_WINDOWS)
 #include <X11/Xlib.h>
 #endif
 
+#include "singleton-cleanup.h"
+
 #include "display.h"
 #include "error.h"
 
 display_info *display_info::instance = 0;
 
 void
 display_info::init (bool query)
 {
@@ -133,17 +135,22 @@ display_info::init (bool query)
 }
 
 bool
 display_info::instance_ok (bool query)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new display_info (query);
+    {
+      instance = new display_info (query);
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       ::error ("unable to create display_info object!");
 
       retval = false;
     }
 
diff --git a/src/display.h b/src/display.h
--- a/src/display.h
+++ b/src/display.h
@@ -68,16 +68,18 @@ public:
   {
     instance_ok (false);
   }
 
 private:
 
   static display_info *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   // Height, width, and depth of the display.
   int ht;
   int wd;
   int dp;
 
   // X- and Y- Resolution of the display in dots (pixels) per inch.
   double rx;
   double ry;
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -22,19 +22,20 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
 #include <list>
 
+#include "file-stat.h"
 #include "oct-env.h"
 #include "oct-time.h"
-#include "file-stat.h"
+#include "singleton-cleanup.h"
 
 #include <defaults.h>
 
 #include "defun.h"
 #include "dynamic-ld.h"
 #include "ov-fcn.h"
 #include "ov-dld-fcn.h"
 #include "ov-mex-fcn.h"
@@ -73,16 +74,18 @@ private:
   void do_remove (octave_shlib& shl, octave_shlib::close_hook cl_hook = 0);
 
   octave_shlib do_find_file (const std::string& file_name) const;
 
   void do_display (void) const;
 
   static octave_shlib_list *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   static bool instance_ok (void);
 
   // List of libraries we have loaded.
   std::list<octave_shlib> lib_list;
 
   // No copying!
 
   octave_shlib_list (const octave_shlib_list&);
@@ -143,17 +146,22 @@ octave_shlib_list::do_display (void) con
 }
 
 bool
 octave_shlib_list::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new octave_shlib_list ();
+    {
+      instance = new octave_shlib_list ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       ::error ("unable to create shared library list object!");
 
       retval = false;
     }
 
@@ -208,16 +216,18 @@ private:
   ~octave_mex_file_list (void) { }
 
   void do_append (const octave_shlib& shl);
 
   void do_remove (octave_shlib& shl, octave_shlib::close_hook cl_hook = 0);
 
   static octave_mex_file_list *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   static bool instance_ok (void);
 
   // List of libraries we have loaded.
   std::list<octave_shlib> file_list;
 
   // No copying!
 
   octave_mex_file_list (const octave_mex_file_list&);
@@ -253,17 +263,22 @@ octave_mex_file_list::do_remove (octave_
 }
 
 bool
 octave_mex_file_list::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new octave_mex_file_list ();
+    {
+      instance = new octave_mex_file_list ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       ::error ("unable to create shared library list object!");
 
       retval = false;
     }
 
@@ -290,17 +305,22 @@ octave_dynamic_loader *octave_dynamic_lo
 bool octave_dynamic_loader::doing_load = false;
 
 bool
 octave_dynamic_loader::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new octave_dynamic_loader ();
+    {
+      instance = new octave_dynamic_loader ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       ::error ("unable to create dynamic loader object!");
 
       retval = false;
     }
 
diff --git a/src/dynamic-ld.h b/src/dynamic-ld.h
--- a/src/dynamic-ld.h
+++ b/src/dynamic-ld.h
@@ -59,16 +59,18 @@ private:
   // No copying!
 
   octave_dynamic_loader (const octave_dynamic_loader&);
 
   octave_dynamic_loader& operator = (const octave_dynamic_loader&);
 
   static octave_dynamic_loader *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   static bool instance_ok (void);
 
   octave_function *
   do_load_oct (const std::string& fcn_name,
                 const std::string& file_name = std::string (),
                 bool relative = false);
 
   octave_function *
diff --git a/src/load-path.cc b/src/load-path.cc
--- a/src/load-path.cc
+++ b/src/load-path.cc
@@ -27,16 +27,17 @@ along with Octave; see the file COPYING.
 
 #include <algorithm>
 
 #include "dir-ops.h"
 #include "file-ops.h"
 #include "file-stat.h"
 #include "oct-env.h"
 #include "pathsearch.h"
+#include "singleton-cleanup.h"
 
 #include "defaults.h"
 #include "defun.h"
 #include "input.h"
 #include "load-path.h"
 #include "pager.h"
 #include "parse.h"
 #include "toplev.h"
@@ -285,17 +286,22 @@ load_path::dir_info::get_method_file_map
 }
 
 bool
 load_path::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new load_path ();
+    {
+      instance = new load_path ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       ::error ("unable to create load path object!");
 
       retval = false;
     }
 
diff --git a/src/load-path.h b/src/load-path.h
--- a/src/load-path.h
+++ b/src/load-path.h
@@ -438,16 +438,18 @@ private:
   mutable fcn_map_type fcn_map;
 
   mutable private_fcn_map_type private_fcn_map;
 
   mutable method_map_type method_map;
 
   static load_path *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   static hook_fcn_ptr add_hook;
 
   static hook_fcn_ptr remove_hook;
 
   static std::string command_line_path;
 
   static std::string sys_path;
 
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -35,18 +35,19 @@ along with Octave; see the file COPYING.
 #include <string>
 
 #include <Array.h>
 
 #include "byte-swap.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-utils.h"
+#include "quit.h"
+#include "singleton-cleanup.h"
 #include "str-vec.h"
-#include "quit.h"
 
 #include "error.h"
 #include "gripes.h"
 #include "input.h"
 #include "oct-stdstrm.h"
 #include "oct-stream.h"
 #include "oct-obj.h"
 #include "utils.h"
@@ -3911,17 +3912,22 @@ octave_stream::mode_as_string (int mode)
 octave_stream_list *octave_stream_list::instance = 0;
 
 bool
 octave_stream_list::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new octave_stream_list ();
+    {
+      instance = new octave_stream_list ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       ::error ("unable to create stream list object!");
 
       retval = false;
     }
 
diff --git a/src/oct-stream.h b/src/oct-stream.h
--- a/src/oct-stream.h
+++ b/src/oct-stream.h
@@ -684,16 +684,18 @@ private:
   typedef std::map<int, octave_stream> ostrl_map;
 
   ostrl_map list;
 
   mutable ostrl_map::const_iterator lookup_cache;
 
   static octave_stream_list *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   int do_insert (octave_stream& os);
 
   octave_stream do_lookup (int fid, const std::string& who = std::string ()) const;
   octave_stream do_lookup (const octave_value& fid,
                            const std::string& who = std::string ()) const;
 
   int do_remove (int fid, const std::string& who = std::string ());
   int do_remove (const octave_value& fid, const std::string& who = std::string ());
diff --git a/src/ov-typeinfo.cc b/src/ov-typeinfo.cc
--- a/src/ov-typeinfo.cc
+++ b/src/ov-typeinfo.cc
@@ -19,35 +19,41 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include "ov-typeinfo.h"
+#include "Array.h"
+#include "singleton-cleanup.h"
 
 #include "defun.h"
 #include "error.h"
+#include "ov-typeinfo.h"
 
 const int
 octave_value_typeinfo::init_tab_sz (16);
 
 octave_value_typeinfo *
 octave_value_typeinfo::instance (0);
 
-#include <Array.h>
-
 bool
 octave_value_typeinfo::instance_ok (void)
 {
   bool retval = true;
+
   if (! instance)
-    instance = new octave_value_typeinfo ();
+    {
+      instance = new octave_value_typeinfo ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       ::error ("unable to create value type info object!");
 
       retval = false;
     }
 
diff --git a/src/ov-typeinfo.h b/src/ov-typeinfo.h
--- a/src/ov-typeinfo.h
+++ b/src/ov-typeinfo.h
@@ -203,22 +203,26 @@ protected:
       compound_binary_ops (dim_vector (octave_value::num_compound_binary_ops, init_tab_sz, init_tab_sz), 0),
       cat_ops (dim_vector (init_tab_sz, init_tab_sz), 0),
       assign_ops (dim_vector (octave_value::num_assign_ops, init_tab_sz, init_tab_sz), 0),
       assignany_ops (dim_vector (octave_value::num_assign_ops, init_tab_sz), 0),
       pref_assign_conv (dim_vector (init_tab_sz, init_tab_sz), -1),
       type_conv_ops (dim_vector (init_tab_sz, init_tab_sz), 0),
       widening_ops (dim_vector (init_tab_sz, init_tab_sz), 0)  { }
 
+  ~octave_value_typeinfo (void) { }
+
 private:
 
   static const int init_tab_sz;
 
   static octave_value_typeinfo *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   int num_types;
 
   Array<std::string> types;
 
   Array<octave_value> vals;
 
   Array<void *> unary_class_ops;
 
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -25,26 +25,26 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <fstream>
 #include <iostream>
 #include <string>
 
 #include "cmd-edit.h"
 #include "oct-env.h"
+#include "singleton-cleanup.h"
 
-#include "procstream.h"
-
-#include <defaults.h>
+#include "defaults.h"
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "input.h"
 #include "oct-obj.h"
 #include "pager.h"
+#include "procstream.h"
 #include "sighandlers.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 // Our actual connection to the external pager.
 static oprocstream *external_pager = 0;
 
@@ -306,109 +306,159 @@ octave_pager_stream::octave_pager_stream
 }
 
 octave_pager_stream::~octave_pager_stream (void)
 {
   flush ();
   delete pb;
 }
 
-octave_pager_stream&
+std::ostream&
 octave_pager_stream::stream (void)
 {
-  if (! instance)
-    instance = new octave_pager_stream ();
-
-  return *instance;
+  return instance_ok () ? *instance : std::cout;
 }
 
 void
 octave_pager_stream::flush_current_contents_to_diary (void)
 {
-  if (pb)
-    pb->flush_current_contents_to_diary ();
+  if (instance_ok ())
+    instance->flush_current_contents_to_diary ();
 }
 
 void
 octave_pager_stream::set_diary_skip (void)
 {
-  if (pb)
-    pb->set_diary_skip ();
+  if (instance_ok ())
+    instance->do_set_diary_skip ();
 }
 
 // Reinitialize the pager buffer to avoid hanging on to large internal
 // buffers when they might not be needed.  This function should only be
 // called when the pager is not in use.  For example, just before
 // getting command-line input.
 
 void
 octave_pager_stream::reset (void)
 {
-  if (! instance)
-    instance = new octave_pager_stream ();
+  if (instance_ok ())
+    instance->do_reset ();
+}
 
-  instance->do_reset ();
+void
+octave_pager_stream::do_flush_current_contents_to_diary (void)
+{
+  if (pb)
+    pb->flush_current_contents_to_diary ();
+}
+
+void
+octave_pager_stream::do_set_diary_skip (void)
+{
+  if (pb)
+    pb->set_diary_skip ();
 }
 
 void
 octave_pager_stream::do_reset (void)
 {
   delete pb;
   pb = new octave_pager_buf ();
   rdbuf (pb);
   setf (unitbuf);
 }
 
+bool
+octave_pager_stream::instance_ok (void)
+{
+  bool retval = true;
+
+  if (! instance)
+    {
+      instance = new octave_pager_stream ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
+
+  if (! instance)
+    {
+      ::error ("unable to create pager_stream object!");
+
+      retval = false;
+    }
+
+  return retval;
+}
+
 octave_diary_stream *octave_diary_stream::instance = 0;
 
 octave_diary_stream::octave_diary_stream (void) : std::ostream (0), db (0)
 {
   db = new octave_diary_buf ();
   rdbuf (db);
   setf (unitbuf);
 }
 
 octave_diary_stream::~octave_diary_stream (void)
 {
   flush ();
   delete db;
 }
 
-octave_diary_stream&
+std::ostream&
 octave_diary_stream::stream (void)
 {
-  if (! instance)
-    instance = new octave_diary_stream ();
-
-  return *instance;
+  return instance_ok () ? *instance : std::cout;
 }
 
 // Reinitialize the diary buffer to avoid hanging on to large internal
 // buffers when they might not be needed.  This function should only be
 // called when the pager is not in use.  For example, just before
 // getting command-line input.
 
 void
 octave_diary_stream::reset (void)
 {
-  if (! instance)
-    instance = new octave_diary_stream ();
-
-  instance->do_reset ();
+  if (instance_ok ())
+    instance->do_reset ();
 }
 
 void
 octave_diary_stream::do_reset (void)
 {
   delete db;
   db = new octave_diary_buf ();
   rdbuf (db);
   setf (unitbuf);
 }
 
+bool
+octave_diary_stream::instance_ok (void)
+{
+  bool retval = true;
+
+  if (! instance)
+    {
+      instance = new octave_diary_stream ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
+
+  if (! instance)
+    {
+      ::error ("unable to create diary_stream object!");
+
+      retval = false;
+    }
+
+  return retval;
+}
+
 void
 flush_octave_stdout (void)
 {
   if (! flushing_output_to_pager)
     {
       unwind_protect frame;
 
       frame.protect_var (really_flush_to_pager);
@@ -432,34 +482,34 @@ close_diary_file (void)
   // function foo ()
   //   diary on;
   //   ...
   //   diary off;
   // endfunction
   //
   // will do the right thing.
 
-  octave_stdout.flush_current_contents_to_diary ();
+  octave_pager_stream::flush_current_contents_to_diary ();
 
   if (external_diary_file.is_open ())
     {
       octave_diary.flush ();
       external_diary_file.close ();
     }
 }
 
 static void
 open_diary_file (void)
 {
   close_diary_file ();
 
   // If there is pending output in the pager buf, it should not go
   // into the diary file.
 
-  octave_stdout.set_diary_skip ();
+  octave_pager_stream::set_diary_skip ();
 
   external_diary_file.open (diary_file.c_str (), std::ios::app);
 
   if (! external_diary_file)
     error ("diary: can't open diary file `%s'", diary_file.c_str ());
 }
 
 DEFUN (diary, args, ,
diff --git a/src/pager.h b/src/pager.h
--- a/src/pager.h
+++ b/src/pager.h
@@ -57,30 +57,38 @@ octave_pager_stream : public std::ostrea
 protected:
 
   octave_pager_stream (void);
 
 public:
 
   ~octave_pager_stream (void);
 
-  void flush_current_contents_to_diary (void);
+  static void flush_current_contents_to_diary (void);
 
-  void set_diary_skip (void);
+  static void set_diary_skip (void);
 
-  static octave_pager_stream& stream (void);
+  static std::ostream& stream (void);
 
   static void reset (void);
 
 private:
 
+  void do_flush_current_contents_to_diary (void);
+
+  void do_set_diary_skip (void);
+
   void do_reset (void);
 
   static octave_pager_stream *instance;
 
+  static bool instance_ok (void);
+
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   octave_pager_buf *pb;
 
   // No copying!
 
   octave_pager_stream (const octave_pager_stream&);
 
   octave_pager_stream& operator = (const octave_pager_stream&);
 };
@@ -105,26 +113,30 @@ octave_diary_stream : public std::ostrea
 protected:
 
   octave_diary_stream (void);
 
 public:
 
   ~octave_diary_stream (void);
 
-  static octave_diary_stream& stream (void);
+  static std::ostream& stream (void);
 
   static void reset (void);
 
 private:
 
   void do_reset (void);
 
   static octave_diary_stream *instance;
 
+  static bool instance_ok (void);
+
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   octave_diary_buf *db;
 
   // No copying!
 
   octave_diary_stream (const octave_diary_stream&);
 
   octave_diary_stream& operator = (const octave_diary_stream&);
 };
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -30,16 +30,17 @@ along with Octave; see the file COPYING.
 #include <new>
 
 #include <sys/types.h>
 #include <unistd.h>
 
 #include "cmd-edit.h"
 #include "oct-syscalls.h"
 #include "quit.h"
+#include "singleton-cleanup.h"
 
 #include "debug.h"
 #include "defun.h"
 #include "error.h"
 #include "input.h"
 #include "load-save.h"
 #include "oct-map.h"
 #include "pager.h"
@@ -799,17 +800,22 @@ make_sig_struct (void)
 octave_child_list::octave_child_list_rep *octave_child_list::instance = 0;
 
 bool
 octave_child_list::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
-    instance = new octave_child_list_rep ();
+    {
+      instance = new octave_child_list_rep ();
+
+      if (instance)
+        singleton_cleanup_list::add (cleanup_instance);
+    }
 
   if (! instance)
     {
       ::error ("unable to create child list object!");
 
       retval = false;
     }
 
diff --git a/src/sighandlers.h b/src/sighandlers.h
--- a/src/sighandlers.h
+++ b/src/sighandlers.h
@@ -165,11 +165,13 @@ public:
 
   static void remove (pid_t pid);
 
 private:
 
   static bool instance_ok (void);
 
   static octave_child_list_rep *instance;
+
+  static void cleanup_instance (void) { delete instance; instance = 0; }
 };
 
 #endif
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -20,34 +20,35 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include "file-ops.h"
+#include "file-stat.h"
 #include "oct-env.h"
 #include "oct-time.h"
-#include "file-ops.h"
-#include "file-stat.h"
+#include "singleton-cleanup.h"
 
+#include "debug.h"
 #include "defun.h"
 #include "dirfns.h"
 #include "input.h"
 #include "load-path.h"
-#include "symtab.h"
 #include "ov-fcn.h"
 #include "ov-usr-fcn.h"
 #include "pager.h"
 #include "parse.h"
 #include "pt-arg-list.h"
+#include "symtab.h"
 #include "unwind-prot.h"
 #include "utils.h"
-#include "debug.h"
 
 symbol_table *symbol_table::instance = 0;
 
 symbol_table::scope_id_cache *symbol_table::scope_id_cache::instance = 0;
 
 std::map<symbol_table::scope_id, symbol_table*> symbol_table::all_instances;
 
 std::map<std::string, octave_value> symbol_table::global_table;
@@ -65,16 +66,24 @@ symbol_table::scope_id symbol_table::xcu
 
 symbol_table::context_id symbol_table::xcurrent_context = 0;
 
 // Should Octave always check to see if function files have changed
 // since they were last compiled?
 static int Vignore_function_time_stamp = 1;
 
 void
+symbol_table::scope_id_cache::create_instance (void)
+{
+  instance = new scope_id_cache ();
+
+  singleton_cleanup_list::add (cleanup_instance);
+}
+
+void
 symbol_table::symbol_record::symbol_record_rep::dump
   (std::ostream& os, const std::string& prefix) const
 {
   octave_value val = varval (xcurrent_context);
 
   os << prefix << name;
 
   if (val.is_defined ())
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -76,22 +76,24 @@ public:
         return instance->do_free (scope);
     }
 
     static std::list<scope_id> scopes (void)
     {
       return instance_ok () ? instance->do_scopes () : std::list<scope_id> ();
     }
 
+    static void create_instance (void);
+
     static bool instance_ok (void)
     {
       bool retval = true;
 
       if (! instance)
-        instance = new scope_id_cache ();
+        create_instance ();
 
       if (! instance)
         {
           ::error ("unable to create scope_id_cache object!");
 
           retval = false;
         }
 
@@ -103,16 +105,18 @@ public:
     // No copying!
 
     scope_id_cache (const scope_id_cache&);
 
     scope_id_cache& operator = (const scope_id_cache&);
 
     static scope_id_cache *instance;
 
+    static void cleanup_instance (void) { delete instance; instance = 0; }
+
     // The next available scope not in the free list.
     scope_id next_available;
 
     // The set of scope IDs that are currently allocated.
     std::set<scope_id> in_use;
 
     // The set of scope IDs that are currently available.
     std::set<scope_id> free_list;
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -39,46 +39,47 @@ along with Octave; see the file COPYING.
 #include <unistd.h>
 
 #include "cmd-edit.h"
 #include "cmd-hist.h"
 #include "file-ops.h"
 #include "lo-error.h"
 #include "lo-mappers.h"
 #include "oct-env.h"
+#include "oct-locbuf.h"
 #include "quit.h"
+#include "singleton-cleanup.h"
 #include "str-vec.h"
-#include "oct-locbuf.h"
 
-#include <defaults.h>
+#include "defaults.h"
 #include "defun.h"
 #include "error.h"
 #include "file-io.h"
 #include "input.h"
 #include "lex.h"
-#include <oct-conf.h>
+#include "oct-conf.h"
 #include "oct-hist.h"
 #include "oct-map.h"
 #include "oct-obj.h"
+#include "ov.h"
 #include "pager.h"
 #include "parse.h"
 #include "pathsearch.h"
 #include "procstream.h"
-#include "ov.h"
 #include "pt-eval.h"
 #include "pt-jump.h"
 #include "pt-stmt.h"
 #include "sighandlers.h"
 #include "sysdep.h"
 #include "syswait.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
-#include <version.h>
+#include "version.h"
 
 void (*octave_exit) (int) = ::exit;
 
 // TRUE means the quit() call is allowed.
 bool quit_allowed = true;
 
 // TRUE means we are exiting via the builtin exit or quit functions.
 bool quitting_gracefully = false;
@@ -92,16 +93,29 @@ bool octave_interpreter_ready = false;
 // TRUE means we've processed all the init code and we are good to go.
 bool octave_initialized = false;
 
 // Current command to execute.
 tree_statement_list *global_command = 0;
 
 octave_call_stack *octave_call_stack::instance = 0;
 
+void
+octave_call_stack::create_instance (void)
+{
+  instance = new octave_call_stack ();
+
+  if (instance)
+    {
+      instance->do_push (0, symbol_table::top_scope (), 0);
+
+      singleton_cleanup_list::add (cleanup_instance);
+    }
+}
+
 int
 octave_call_stack::do_current_line (void) const
 {
   tree_statement *stmt = do_current_statement ();
 
   return stmt ? stmt->line () : -1;
 }
 
@@ -669,22 +683,24 @@ main_loop (void)
 // Fix up things before exiting.
 
 void
 clean_up_and_exit (int retval)
 {
   do_octave_atexit ();
 
   // Clean up symbol table.
-  SAFE_CALL (symbol_table::cleanup, ());
+  SAFE_CALL (symbol_table::cleanup, ())
 
-  SAFE_CALL (cleanup_parser, ());
+  SAFE_CALL (cleanup_parser, ())
 
   SAFE_CALL (sysdep_cleanup, ())
 
+  SAFE_CALL (singleton_cleanup_list::cleanup, ())
+
   SAFE_CALL (octave_chunk_buffer::clear, ())
 
   if (octave_exit)
     (*octave_exit) (retval == EOF ? 0 : retval);
 }
 
 DEFUN (quit, args, ,
   "-*- texinfo -*-\n\
diff --git a/src/toplev.h b/src/toplev.h
--- a/src/toplev.h
+++ b/src/toplev.h
@@ -107,32 +107,30 @@ protected:
 public:
 
   typedef std::deque<call_stack_elt>::iterator iterator;
   typedef std::deque<call_stack_elt>::const_iterator const_iterator;
 
   typedef std::deque<call_stack_elt>::reverse_iterator reverse_iterator;
   typedef std::deque<call_stack_elt>::const_reverse_iterator const_reverse_iterator;
 
+  static void create_instance (void);
+  
   static bool instance_ok (void)
   {
     bool retval = true;
 
     if (! instance)
-      {
-        instance = new octave_call_stack ();
+      create_instance ();
 
-        if (instance)
-          instance->do_push (0, symbol_table::top_scope (), 0);
-        else
-          {
-            ::error ("unable to create call stack object!");
+    if (! instance)
+      {
+        ::error ("unable to create call stack object!");
 
-            retval = false;
-          }
+        retval = false;
       }
 
     return retval;
   }
 
   // Current function (top of stack).
   static octave_function *current (void)
   {
@@ -295,16 +293,18 @@ private:
 
   // The current call stack.
   std::deque<call_stack_elt> cs;
 
   size_t curr_frame;
 
   static octave_call_stack *instance;
 
+  static void cleanup_instance (void) { delete instance; instance = 0; }
+
   int do_current_line (void) const;
 
   int do_current_column (void) const;
 
   int do_caller_user_code_line (void) const;
 
   int do_caller_user_code_column (void) const;
 
