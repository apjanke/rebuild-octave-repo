# HG changeset patch
# User jwe
# Date 862898113 0
#      Tue May 06 05:55:13 1997 +0000
# Node ID 9d26524e286988f1de663449695b35c367309ff4
# Parent  87cb7614257db1b082a9a1f3fa92cfb7774c325d
[project @ 1997-05-06 05:49:53 by jwe]

diff --git a/liboctave/file-ops.cc b/liboctave/file-ops.cc
--- a/liboctave/file-ops.cc
+++ b/liboctave/file-ops.cc
@@ -24,146 +24,175 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include <cerrno>
 #include <cstdio>
 #include <cstdlib>
 #include <cstring>
 
-#include <iostream.h>
-
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 #include "file-ops.h"
-#include "lo-error.h"
 #include "oct-env.h"
 #include "oct-passwd.h"
 #include "statdefs.h"
 #include "str-vec.h"
 
+#define NOT_SUPPORTED(nm) \
+  nm ## ": not supported on this system"
+
 // We provide a replacement for mkdir().
 
 int
 file_ops::mkdir (const string& name, mode_t mode)
 {
-  return ::mkdir (name.c_str (), mode);
+  string msg;
+  return mkdir (name, mode, msg);
 }
 
 int
 file_ops::mkdir (const string& name, mode_t mode, string& msg)
 {
   msg = string ();
 
-  int status = ::mkdir (name.c_str (), mode);
+  int status = -1;
+
+#if defined (HAVE_MKDIR)
+  status = ::mkdir (name.c_str (), mode);
 
   if (status < 0)
     msg = ::strerror (errno);
+#else
+  msg = NOT_SUPPORTED ("mkdir");
+#endif
 
   return status;
 }
 
 // I don't know how to emulate this on systems that don't provide it.
 
 int
 file_ops::mkfifo (const string& name, mode_t mode)
 {
-#if defined (HAVE_MKFIFO)
-  return ::mkfifo (name.c_str (), mode);
-#else
-  (*current_liboctave_error_handler)
-    ("mkfifo: not implemented on this system");
-  return -1;
-#endif
+  string msg;
+  return mkfifo (name, mode, msg);
 }
 
 int
 file_ops::mkfifo (const string& name, mode_t mode, string& msg)
 {
   msg = string ();
 
+  int status = -1;
+
 #if defined (HAVE_MKFIFO)
-  int status = ::mkfifo (name.c_str (), mode);
+  status = ::mkfifo (name.c_str (), mode);
 
   if (status < 0)
     msg = ::strerror (errno);
+#else
+  msg = NOT_SUPPORTED ("mkfifo");
+#endif
 
   return status;
-#else
-  (*current_liboctave_error_handler)
-    ("mkfifo: not implemented on this system");
-  return -1;
-#endif
 }
 
 // We provide a replacement for rename().
 
 int
 file_ops::rename (const string& from, const string& to)
 {
-  return ::rename (from.c_str (), to.c_str ());
+  string msg;
+  return rename (from, to, msg);
 }
 
 int
 file_ops::rename (const string& from, const string& to, string& msg)
 {
+  int status = -1;
+
   msg = string ();
 
-  int status = ::rename (from.c_str (), to.c_str ());
+#if defined (HAVE_RENAME)
+  status = ::rename (from.c_str (), to.c_str ());
 
   if (status < 0)
     msg = ::strerror (errno);
+#else
+  msg = NOT_SUPPORTED ("rename");
+#endif
 
   return status;
 }
 
 // We provide a replacement for rmdir().
 
 int
 file_ops::rmdir (const string& name)
 {
-  return ::rmdir (name.c_str ());
+  string msg;
+  return rmdir (name, msg);
 }
 
 int
 file_ops::rmdir (const string& name, string& msg)
 {
   msg = string ();
 
-  int status = ::rmdir (name.c_str ());
+  int status = -1;
+
+#if defined (HAVE_RMDIR)
+  status = ::rmdir (name.c_str ());
 
   if (status < 0)
     msg = ::strerror (errno);
+#else
+  msg = NOT_SUPPORTED ("rmdir");
+#endif
 
   return status;
 }
 
 // We provide a replacement for tempnam().
 
 string
-file_ops::tempnam (void)
+file_ops::tempnam (const string& dir, const string& pfx)
 {
+  string msg;
+  return tempnam (dir, pfx, msg);
+}
+
+string
+file_ops::tempnam (const string& dir, const string& pfx, string& msg)
+{
+  msg = string ();
+
   string retval;
+  
+  const char *pdir = dir.empty () ? 0 : dir.c_str ();
 
-  char *tmp = ::tempnam (0, "oct-");
+  const char *ppfx = pfx.empty () ? 0 : pfx.c_str ();
+
+  char *tmp = ::tempnam (pdir, ppfx);
 
   if (tmp)
     {
       retval = tmp;
 
-      free (tmp);
+      ::free (tmp);
     }
   else
-    (*current_liboctave_error_handler) ("can't open temporary file!");
+    msg = ::strerror (errno);
 
   return retval;
 }
 
 // If NAME has a leading ~ or ~user, Unix-style, expand it to the
 // user's home directory.  If no ~, or no <pwd.h>, just return NAME.
 
 // Mostly stolen from kpathsea.  Readline also has a more complicated
@@ -212,17 +241,17 @@ file_ops::tilde_expand (const string& na
 	    len -= beg + 1;
 
 	  string user = name.substr (beg+1, len);
 
 	  octave_passwd pw = octave_passwd::getpwnam (user);
 
 	  // If no such user, just use `.'.
 
-	  string home = pw.empty () ? : string (".") : pw.dir ();
+	  string home = pw ? string (".") : pw.dir ();
       
 	  expansion = string (" ", beg) + home;
 
 	  if (end != NPOS)
 	    expansion.append (name.substr (end));
 	}
     }
 
@@ -254,28 +283,35 @@ file_ops::umask (mode_t mode)
 #else
   return 0;
 #endif
 }
 
 int
 file_ops::unlink (const string& name)
 {
-  return ::unlink (name.c_str ());
+  string msg;
+  return unlink (name, msg);
 }
 
 int
-file_ops::unlink (const string& name, string& errmsg)
+file_ops::unlink (const string& name, string& msg)
 {
-  errmsg = string ();
+  msg = string ();
 
-  int status = ::unlink (name.c_str ());
+  int status = -1;
+
+#if defined (HAVE_UNLINK)
+  status = ::unlink (name.c_str ());
 
   if (status < 0)
-    errmsg = ::strerror (errno);
+    msg = ::strerror (errno);
+#else
+  msg = NOT_SUPPORTED ("unlink");
+#endif
 
   return status;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/file-ops.h b/liboctave/file-ops.h
--- a/liboctave/file-ops.h
+++ b/liboctave/file-ops.h
@@ -41,17 +41,18 @@ file_ops
   static int mkfifo (const string&, mode_t, string&);
 
   static int rename (const string&, const string&);
   static int rename (const string&, const string&, string&);
 
   static int rmdir (const string&);
   static int rmdir (const string&, string&);
 
-  static string tempnam (void);
+  static string tempnam (const string&, const string&);
+  static string tempnam (const string&, const string&, string&);
 
   static string tilde_expand (const string&);
   static string_vector tilde_expand (const string_vector&);
 
   static int umask (mode_t);
 
   static int unlink (const string&);
   static int unlink (const string&, string&);
diff --git a/liboctave/oct-env.cc b/liboctave/oct-env.cc
--- a/liboctave/oct-env.cc
+++ b/liboctave/oct-env.cc
@@ -368,17 +368,17 @@ octave_env::do_get_user_name (void) cons
 {
   // XXX FIXME XXX -- is it possible for this to change while Octave
   // is running?
 
   if (user_name.empty ())
     {
       octave_passwd pw = octave_passwd::getpwuid (getuid ());
 
-      user_name = pw.empty () ? string ("I have no name!") : pw.name ();
+      user_name = pw ? string ("I have no name!") : pw.name ();
     }
 
   return user_name;
 }
 
 string
 octave_env::do_get_host_name (void) const
 {
diff --git a/liboctave/oct-group.cc b/liboctave/oct-group.cc
new file mode 100644
--- /dev/null
+++ b/liboctave/oct-group.cc
@@ -0,0 +1,228 @@
+/*
+
+Copyright (C) 1996, 1997 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+
+#ifdef HAVE_GRP_H
+#include <grp.h>
+#endif
+
+#include "lo-error.h"
+#include "oct-group.h"
+#include "str-vec.h"
+
+#define NOT_SUPPORTED(nm) \
+  nm ## ": not supported on this system"
+
+string
+octave_group::name (void) const
+{
+  if (! ok ())
+    gripe_invalid ();
+
+  return gr_name;
+}
+
+string
+octave_group::passwd (void) const
+{
+  if (! ok ())
+    gripe_invalid ();
+
+  return gr_passwd;
+}
+
+gid_t
+octave_group::gid (void) const
+{
+  if (! ok ())
+    gripe_invalid ();
+
+  return gr_gid;
+}
+
+string_vector
+octave_group::mem (void) const
+{
+  if (! ok ())
+    gripe_invalid ();
+
+  return gr_mem;
+}
+
+octave_group
+octave_group::getgrent (void)
+{
+  string msg;
+  return getgrent (msg);
+}
+
+octave_group
+octave_group::getgrent (string& msg)
+{
+#if defined (HAVE_GETGRENT)
+  msg = string ();
+  return octave_group (::getgrent (), msg);
+#else
+  msg = NOT_SUPPORTED ("getgrent");
+  return octave_group ();
+#endif
+}
+
+octave_group
+octave_group::getgrgid (gid_t gid)
+{
+  string msg;
+  return getgrgid (gid, msg);
+}
+
+octave_group
+octave_group::getgrgid (gid_t gid, string& msg)
+{
+#if defined (HAVE_GETGRGID)
+  msg = string ();
+  return octave_group (::getgrgid (gid), msg);
+#else
+  msg = NOT_SUPPORTED ("getgruid");
+  return octave_group ();
+#endif
+}
+
+octave_group
+octave_group::getgrnam (const string& nm)
+{
+  string msg;
+  return getgrnam (msg);
+}
+
+octave_group
+octave_group::getgrnam (const string& nm, string& msg)
+{
+#if defined (HAVE_GETGRNAM)
+  msg = string ();
+  return octave_group (::getgrnam (nm.c_str ()), msg);
+#else
+  msg = NOT_SUPPORTED ("getgrnam");
+  return octave_group ();
+#endif
+}
+
+int
+octave_group::setgrent (void)
+{
+  string msg;
+  return setgrent (msg);
+}
+
+int
+octave_group::setgrent (string& msg)
+{
+#if defined (HAVE_SETGRENT)
+  msg = string ();
+  ::setgrent ();
+  return 0;
+#else
+  msg = NOT_SUPPORTED ("setgrent");
+  return -1;
+#endif
+}
+
+int
+octave_group::endgrent (void)
+{
+  string msg;
+  return endgrent (msg);
+}
+
+int
+octave_group::endgrent (string& msg)
+{
+#if defined (HAVE_ENDGRENT)
+  msg = string ();
+  ::endgrent ();
+  return 0;
+#else
+  msg = NOT_SUPPORTED ("endgrent");
+  return -1;
+#endif
+}
+
+octave_group::octave_group (void *p, string& msg)
+  : gr_name (), gr_passwd (), gr_gid (0), gr_mem (), valid (false)
+{
+#if defined (HAVE_GRP_H)
+  msg = string ();
+
+  if (p)
+    {
+      struct group *gr = static_cast<struct group *> (p);
+
+      gr_name = gr->gr_name;
+
+#if defined (HAVE_GR_PASSWD)
+      gr_passwd = gr->gr_passwd;
+#endif
+
+      // XXX FIXME XXX -- maybe there should be a string_vector
+      // constructor that takes a NULL terminated list of C
+      // strings.
+
+      const char * const *tmp = gr->gr_mem;
+
+      int k = 0;
+      while (*tmp++)
+	k++;
+
+      if (k > 0)
+	{
+	  tmp = gr->gr_mem;
+
+	  gr_mem.resize (k);
+
+	  for (int i = 0; i < k; i++)
+	    gr_mem[i] = tmp[i];
+	}
+
+      valid = true;
+    }
+#else
+  msg = NOT_SUPPORTED ("group functions");
+#endif
+}
+
+void
+octave_group::gripe_invalid (void) const
+{
+  (*current_liboctave_error_handler) ("invalid group object");
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/oct-group.h b/liboctave/oct-group.h
new file mode 100644
--- /dev/null
+++ b/liboctave/oct-group.h
@@ -0,0 +1,121 @@
+/*
+
+Copyright (C) 1996, 1997 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if !defined (octave_group_h)
+#define octave_group_h 1
+
+#include <string>
+
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+
+#include "str-vec.h"
+
+class
+octave_group
+{
+public:
+
+  octave_group (void)
+    : gr_name (), gr_passwd (), gr_gid (0), gr_mem (), valid (false)
+  { }
+
+  octave_group (const octave_group& gr)
+    : gr_name (gr.gr_name), gr_passwd (gr.gr_passwd),
+      gr_gid (gr.gr_gid), gr_mem (gr.gr_mem), valid (gr.valid) 
+  { }
+
+  octave_group& operator = (const octave_group& gr)
+  {
+    if (this != &gr)
+      {
+	gr_name  = gr.gr_name;
+	gr_passwd = gr.gr_passwd;
+	gr_gid = gr.gr_gid;
+	gr_mem = gr.gr_mem;
+	valid = gr.valid;
+      }
+
+    return *this;
+  }
+
+  string name (void) const;
+
+  string passwd (void) const;
+
+  gid_t gid (void) const;
+
+  string_vector mem (void) const;
+
+  bool ok (void) const { return valid; }
+
+  operator void* () const
+    { return ok ()
+	? static_cast<void *> (-1) : static_cast<void *> (0); }
+
+  static octave_group getgrent (void);
+  static octave_group getgrent (string& msg);
+
+  static octave_group getgrgid (gid_t gid);
+  static octave_group getgrgid (gid_t gid, string& msg);
+
+  static octave_group getgrnam (const string& nm);
+  static octave_group getgrnam (const string& nm, string& msg);
+
+  static int setgrent (void);
+  static int setgrent (string& msg);
+
+  static int endgrent (void);
+  static int endgrent (string& msg);
+
+private:
+
+  // The group name.
+  string gr_name;
+
+  // The group password.
+  string gr_passwd;
+
+  // The numeric group id.
+  gid_t gr_gid;
+
+  // The members of the group;
+  string_vector gr_mem;
+
+  // Flag that says whether we have been properly initialized.
+  bool valid;
+
+  // This is how we will create an octave_group object from a pointer
+  // to a struct group.
+  octave_group (void *p, string& msg);
+
+  void gripe_invalid (void) const;
+};
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/oct-passwd.cc b/liboctave/oct-passwd.cc
--- a/liboctave/oct-passwd.cc
+++ b/liboctave/oct-passwd.cc
@@ -19,23 +19,30 @@ along with Octave; see the file COPYING.
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+
 #ifdef HAVE_PWD_H
 #include <pwd.h>
 #endif
 
 #include "lo-error.h"
 #include "oct-passwd.h"
 
+#define NOT_SUPPORTED(nm) \
+  nm ## ": not supported on this system"
+
 string
 octave_passwd::name (void) const
 {
   if (! ok ())
     gripe_invalid ();
 
   return pw_name;
 }
@@ -92,101 +99,139 @@ octave_passwd::shell (void) const
     gripe_invalid ();
 
   return pw_shell;
 }
 
 octave_passwd
 octave_passwd::getpwent (void)
 {
-#ifdef HAVE_GETPWENT
-  return octave_passwd (::getpwent ());
+  string msg;
+  return getpwent (msg);
+}
+
+octave_passwd
+octave_passwd::getpwent (string& msg)
+{
+#if defined HAVE_GETPWENT
+  msg = string ();
+  return octave_passwd (::getpwent (), msg);
 #else
-  gripe_not_implemented ("getpwent");
-
+  msg = NOT_SUPPORTED ("getpwent");
   return octave_passwd ();
 #endif
 }
 
 octave_passwd
 octave_passwd::getpwuid (uid_t uid)
 {
-#ifdef HAVE_GETPWUID
-  return octave_passwd (::getpwuid (uid));
+  string msg;
+  return getpwuid (uid, msg);
+}
+
+octave_passwd
+octave_passwd::getpwuid (uid_t uid, string& msg)
+{
+#if defined (HAVE_GETPWUID)
+  msg = string ();
+  return octave_passwd (::getpwuid (uid), msg);
 #else
-  gripe_not_implemented ("getpwuid");
-
+  msg = NOT_SUPPORTED ("getpwuid");
   return octave_passwd ();
 #endif
 }
 
 octave_passwd
 octave_passwd::getpwnam (const string& nm)
 {
-#ifdef HAVE_GETPWNAM
-  return octave_passwd (::getpwnam (nm.c_str ()));
+  string msg;
+  return getpwnam (nm, msg);
+}
+
+octave_passwd
+octave_passwd::getpwnam (const string& nm, string& msg)
+{
+#if defined (HAVE_GETPWNAM)
+  msg = string ();
+  return octave_passwd (::getpwnam (nm.c_str ()), msg);
 #else
-  gripe_not_implemented ("getpwnam");
-
+  msg = NOT_SUPPORTED ("getpwnam");
   return octave_passwd ();
 #endif
 }
 
-void
+int
 octave_passwd::setpwent (void)
 {
-#ifdef HAVE_SETPWENT
+  string msg;
+  return setpwent (msg);
+}
+
+int
+octave_passwd::setpwent (string& msg)
+{
+#if defined (HAVE_SETPWENT)
+  msg = string ();
   ::setpwent ();
+  return 0;
 #else
-  gripe_not_implemented ("setpwent");
+  msg = NOT_SUPPORTED ("setpwent");
+  return -1;
 #endif
 }
 
-void
+int
 octave_passwd::endpwent (void)
 {
-#ifdef HAVE_ENDPWENT
+  string msg;
+  return endpwent (msg);
+}
+
+int
+octave_passwd::endpwent (string& msg)
+{
+#if defined (HAVE_ENDPWENT)
+  msg = string ();
   ::endpwent ();
+  return 0;
 #else
-  gripe_not_implemented ("endpwent");
+  msg = NOT_SUPPORTED ("endpwent");
+  return -1;
 #endif
 }
 
-octave_passwd::octave_passwd (void *p)
+octave_passwd::octave_passwd (void *p, string& msg)
   : pw_name (), pw_passwd (), pw_uid (0), pw_gid (0), pw_gecos (),
     pw_dir (), pw_shell (), valid (false)
 {
-#ifdef HAVE_PWD_H
+#if defined (HAVE_PWD_H)
+  msg = string ();
+
   if (p)
     {
       struct passwd *pw = static_cast<struct passwd *> (p);
 
       pw_name = pw->pw_name;
       pw_passwd = pw->pw_passwd;
       pw_uid = pw->pw_uid;
       pw_gid = pw->pw_gid;
       pw_gecos = pw->pw_gecos;
       pw_dir = pw->pw_dir;
       pw_shell = pw->pw_shell;
 
       valid = true;
     }
+#else
+  msg = NOT_SUPPORTED ("password functions");
 #endif
 }
 
 void
 octave_passwd::gripe_invalid (void) const
 {
   (*current_liboctave_error_handler) ("invalid password object");
 }
 
-void
-octave_passwd::gripe_not_supported (const string& fcn) const
-{
-  (*current_liboctave_error_handler)
-    ("%s: not supported on this system", fcn.c_str ());
-}
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/oct-passwd.h b/liboctave/oct-passwd.h
--- a/liboctave/oct-passwd.h
+++ b/liboctave/oct-passwd.h
@@ -41,31 +41,31 @@ public:
 
   octave_passwd (const octave_passwd& pw)
     : pw_name (pw.pw_name), pw_passwd (pw.pw_passwd),
       pw_uid (pw.pw_uid), pw_gid (pw.pw_gid), pw_gecos (pw.pw_gecos),
       pw_dir (pw.pw_dir), pw_shell (pw.pw_shell), valid (pw.valid)
   { }
 
   octave_passwd& operator = (const octave_passwd& pw)
-    {
-      if (this != &pw)
-	{
-	  pw_name = pw.pw_name;
-	  pw_passwd = pw.pw_passwd;
-	  pw_uid = pw.pw_uid;
-	  pw_gid = pw.pw_gid;
-	  pw_gecos = pw.pw_gecos;
-	  pw_dir = pw.pw_dir;
-	  pw_shell = pw.pw_shell;
-	  valid = pw.valid;
-	}
+  {
+    if (this != &pw)
+      {
+	pw_name = pw.pw_name;
+	pw_passwd = pw.pw_passwd;
+	pw_uid = pw.pw_uid;
+	pw_gid = pw.pw_gid;
+	pw_gecos = pw.pw_gecos;
+	pw_dir = pw.pw_dir;
+	pw_shell = pw.pw_shell;
+	valid = pw.valid;
+      }
 
-      return *this;
-    }
+    return *this;
+  }
 
   ~octave_passwd (void) { }
 
   string name (void) const;
 
   string passwd (void) const;
 
   uid_t uid (void) const;
@@ -80,24 +80,29 @@ public:
 
   bool ok (void) const { return valid; }
 
   operator void* () const
     { return ok ()
 	? static_cast<void *> (-1) : static_cast<void *> (0); }
 
   static octave_passwd getpwent (void);
+  static octave_passwd getpwent (string& msg);
 
   static octave_passwd getpwuid (uid_t uid);
+  static octave_passwd getpwuid (uid_t uid, string& msg);
 
   static octave_passwd getpwnam (const string& nm);
+  static octave_passwd getpwnam (const string& nm, string& msg);
 
-  static void setpwent (void);
+  static int setpwent (void);
+  static int setpwent (string& msg);
 
-  static void endpwent (void);
+  static int endpwent (void);
+  static int endpwent (string& msg);
 
 private:
 
   // User name.
   string pw_name;
 
   // Encrypted password.
   string pw_passwd;
@@ -117,21 +122,19 @@ private:
   // Login shell.
   string pw_shell;
 
   // Flag that says whether we have been properly initialized.
   bool valid;
 
   // This is how we will create an octave_passwd object from a pointer
   // to a struct passwd.
-  octave_passwd (void *);
+  octave_passwd (void *p, string& msg);
 
   void gripe_invalid (void) const;
-
-  void gripe_not_supported (const string& fcn) const;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/str-vec.cc b/liboctave/str-vec.cc
--- a/liboctave/str-vec.cc
+++ b/liboctave/str-vec.cc
@@ -24,16 +24,17 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include <string>
 
 #include <iostream.h>
 
 #include "cmd-edit.h"
+#include "lo-utils.h"
 #include "str-vec.h"
 
 // Create a string vector from a NULL terminated list of C strings.
 
 string_vector::string_vector (const char * const *s)
   : Array<string> ()
 {
   int n = 0;
@@ -52,16 +53,40 @@ string_vector::string_vector (const char
 
 string_vector::string_vector (const char * const *s, int n)
   : Array<string> (n)
 {
   for (int i = 0; i < n; i++)
     elem (i) = s[i];
 }
 
+char **
+string_vector::c_str_vec (void) const
+{
+  int len = length ();
+
+  char **retval = new char * [len + 1];
+
+  retval [len] = 0;
+
+  for (int i = 0; i < len; i++)
+    retval[i] = strsave (elem(i).c_str ());
+
+  return retval;
+}
+
+void
+string_vector::delete_c_str_vec (const char * const *v)
+{
+  while (*v)
+    delete [] *v;
+
+  delete [] v;
+}
+
 // Format a list in neat columns.  Mostly stolen from GNU ls.
 
 ostream&
 string_vector::list_in_columns (ostream& os) const
 {
   // Compute the maximum name length.
 
   int max_name_length = 0;
diff --git a/liboctave/str-vec.h b/liboctave/str-vec.h
--- a/liboctave/str-vec.h
+++ b/liboctave/str-vec.h
@@ -90,16 +90,20 @@ public:
   string operator[] (int i) const { return Array<string>::elem (i); }
 
   string_vector& qsort (void)
     {
       Array<string>::qsort (str_vec_compare);
       return *this;
     }
 
+  char **c_str_vec (void) const;
+
+  static void delete_c_str_vec (const char * const*);
+
   ostream& list_in_columns (ostream&) const;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,12 +1,20 @@
+Tue May  6 00:48:59 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* DLD-FUNCTIONS/getgrent.cc: Use new octave_group class.
+	* DLD-FUNCTIONS/getpwent.cc: Use new octave_passwd class.
+
+	* syscalls.cc: Simplify by using new functions defined in
+	liboctave/oct-syscalls.cc.
+
+	* file-io.cc (Ftmpnam): Accept DIR and PREFIX args.
+
 Mon May  5 00:54:03 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
-	* DLD-FUNCTIONS/getpwent.cc: Use new octave_passwd class.
-
 	* ov-str-mat.cc (octave_char_matrix_str::print_name_tag): Print
 	empty strings on one line.
 
 	* DLD-FUNCTIONS, OPERATORS, and	TEMPLATE-INST: New subdirectories.
 	Move appropriate files to new directories.
 	* Makefile.in: Add DLD-FUNCTIONS, OPERATORS, and TEMPLATE-INST
 	directories to VPATH.  Fix rules to work with new directory
 	structure.
diff --git a/src/DLD-FUNCTIONS/getgrent.cc b/src/DLD-FUNCTIONS/getgrent.cc
--- a/src/DLD-FUNCTIONS/getgrent.cc
+++ b/src/DLD-FUNCTIONS/getgrent.cc
@@ -25,206 +25,186 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include <string>
 
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 
-#ifdef HAVE_GRP_H
-#include <grp.h>
-#endif
+#include "oct-group.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "oct-map.h"
 #include "ov.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 // Group file functions.  (Why not?)
 
 static octave_value
-mk_gr_map (struct group *gr)
+mk_gr_map (const octave_group& gr)
 {
   octave_value retval;
 
   if (gr)
     {
       Octave_map m;
 
-      m ["name"] = gr->gr_name;
-#if defined (HAVE_GR_PASSWD)
-      m ["passwd"] = gr->gr_passwd;
-#else
-      m ["passwd"] = "";
-#endif
-      m ["gid"] = static_cast<double> (gr->gr_gid);
-
-      if (gr->gr_mem)
-	{
-	  // XXX FIXME XXX -- maybe there should be a string_vector
-	  // constructor that takes a NULL terminated list of C
-	  // strings.
-
-	  char **tmp = gr->gr_mem;
-
-	  int k = 0;
-	  while (*tmp++)
-	    k++;
-
-	  if (k > 0)
-	    {
-	      tmp = gr->gr_mem;
-
-	      string_vector members (k);
-
-	      for (int i = 0; i < k; i++)
-		members[i] = tmp[i];
-
-	      m ["mem"] = members;
-	    }
-	  else
-	    m ["mem"] = "";
-	}
+      m ["name"] = gr.name ();
+      m ["passwd"] = gr.passwd ();
+      m ["gid"] = static_cast<double> (gr.gid ());
+      m ["mem"] = gr.mem ();
 
       retval = m;
     }
   else
     retval = 0.0;
 
   return retval;
 }
 
 DEFUN_DLD (getgrent, args, ,
  "getgrent ()\n\
 \n\
 Read an entry from the group-file stream, opening it if necessary.")
 {
-  octave_value retval;
+  octave_value_list retval;
+
+  retval(1) = string ();
+  retval(0) = 0.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
-#ifdef HAVE_GETGRENT
-      retval = mk_gr_map (getgrent ());
-#else
-      gripe_not_supported ("getgrent");
-#endif
+      string msg;
+
+      retval(0) = mk_gr_map (octave_group::getgrent (msg));
+      retval(1) = msg;
     }
   else
     print_usage ("getgrent");
 
   return retval;
 }
 
 DEFUN_DLD (getgrgid, args, ,
   "getgrgid (GID)\n\
 \n\
 Search for a group entry with a matching group ID.")
 {
-  octave_value retval;
+  octave_value_list retval;
+
+  retval(1) = string ();
+  retval(0) = 0.0;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-#ifdef HAVE_GETGRGID
       double dval = args(0).double_value ();
 
       if (! error_state)
 	{
 	  if (D_NINT (dval) == dval)
 	    {
 	      gid_t gid = static_cast<gid_t> (dval);
 
-	      retval = mk_gr_map (getgrgid (gid));
+	      string msg;
+
+	      retval(0) = mk_gr_map (octave_group::getgrgid (gid, msg));
+	      retval(1) = msg;
 	    }
 	  else
 	    error ("getgrgid: argument must be an integer");
 	}
-#else
-      gripe_not_supported ("getgrgid");
-#endif
     }
   else
     print_usage ("getgrgid");
 
   return retval;
 }
 
 DEFUN_DLD (getgrnam, args, ,
   "getgrnam (NAME)\n\
 \n\
 Search for group entry with a matching group name.")
 {
-  octave_value retval;
+  octave_value_list retval;
+
+  retval(1) = string ();
+  retval(0) = 0.0;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-#ifdef HAVE_GETGRNAM
       string s = args(0).string_value ();
 
       if (! error_state)
-	retval = mk_gr_map (getgrnam (s.c_str ()));
-#else
-      gripe_not_supported ("getgrnam");
-#endif
+	{
+	  string msg;
+
+	  retval(0) = mk_gr_map (octave_group::getgrnam (s.c_str (), msg));
+	  retval(1) = msg;
+	}
     }
   else
     print_usage ("getgrnam");
 
   return retval;
 }
 
 DEFUN_DLD (setgrent, args, ,
   "setgrent ()\n\
 \n\
 Rewind the group-file stream.")
 {
-  octave_value retval;
+  octave_value_list retval;
+
+  retval(1) = string ();
+  retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
-#ifdef HAVE_SETGRENT
-      setgrent ();
-#else
-      gripe_not_supported ("setgrent");
-#endif
+      string msg;
+
+      retval(0) = static_cast<double> (octave_group::setgrent (msg));
+      retval(1) = msg;
     }
   else
     print_usage ("setgrent");
 
   return retval;
 }
 
 DEFUN_DLD (endgrent, args, ,
   "endgrent ()\n\
 \n\
 Close the group-file stream.")
 {
-  octave_value retval;
+  octave_value_list retval;
+
+  retval(1) = string ();
+  retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
-#ifdef HAVE_ENDGRENT
-      endgrent ();
-#else
-      gripe_not_supported ("endgrent");
-#endif
+      string msg;
+
+      retval(0) = static_cast<double> (octave_group::endgrent (msg));
+      retval(1) = msg;
     }
   else
     print_usage ("endgrent");
 
   return retval;
 }
 
 /*
diff --git a/src/DLD-FUNCTIONS/getpwent.cc b/src/DLD-FUNCTIONS/getpwent.cc
--- a/src/DLD-FUNCTIONS/getpwent.cc
+++ b/src/DLD-FUNCTIONS/getpwent.cc
@@ -68,109 +68,147 @@ mk_pw_map (const octave_passwd& pw)
   return retval;
 }
 
 DEFUN_DLD (getpwent, args, ,
  "getpwent ()\n\
 \n\
 Read an entry from the password-file stream, opening it if necessary.")
 {
-  octave_value retval;
+  octave_value_list retval;
+
+  retval(1) = string ();
+  retval(0) = 0.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
-    retval = mk_pw_map (octave_passwd::getpwent ());
+    {
+      string msg;
+
+      retval(0) = mk_pw_map (octave_passwd::getpwent (msg));
+      retval(1) = msg;
+    }
   else
     print_usage ("getpwent");
 
   return retval;
 }
 
 DEFUN_DLD (getpwuid, args, ,
   "getpwuid (UID)\n\
 \n\
 Search for a password entry with a matching user ID.")
 {
-  octave_value retval;
+  octave_value_list retval;
+
+  retval(1) = string ();
+  retval(0) = 0.0;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       double dval = args(0).double_value ();
 
       if (! error_state)
 	{
 	  if (D_NINT (dval) == dval)
 	    {
 	      uid_t uid = static_cast<uid_t> (dval);
 
-	      retval = mk_pw_map (octave_passwd::getpwuid (uid));
+	      string msg;
+
+	      retval(0) = mk_pw_map (octave_passwd::getpwuid (uid, msg));
+	      retval(1) = msg;
 	    }
 	  else
 	    error ("getpwuid: argument must be an integer");
 	}
     }
   else
     print_usage ("getpwuid");
 
   return retval;
 }
 
 DEFUN_DLD (getpwnam, args, ,
   "getpwnam (NAME)\n\
 \n\
 Search for password entry with a matching username.")
 {
-  octave_value retval;
+  octave_value_list retval;
+
+  retval(1) = string ();
+  retval(0) = 0.0;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       string s = args(0).string_value ();
 
       if (! error_state)
-	retval = mk_pw_map (octave_passwd::getpwnam (s.c_str ()));
+	{
+	  string msg;
+
+	  retval(0) = mk_pw_map (octave_passwd::getpwnam (s.c_str (), msg));
+	  retval(1) = msg;
+	}
     }
   else
     print_usage ("getpwnam");
 
   return retval;
 }
 
 DEFUN_DLD (setpwent, args, ,
   "setpwent ()\n\
 \n\
 Rewind the password-file stream.")
 {
-  octave_value retval;
+  octave_value_list retval;
+
+  retval(1) = string ();
+  retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
-    octave_passwd::setpwent ();
+    {
+      string msg;
+
+      retval(0) = static_cast<double> (octave_passwd::setpwent (msg));
+      retval(1) = msg;
+    }
   else
     print_usage ("setpwent");
 
   return retval;
 }
 
 DEFUN_DLD (endpwent, args, ,
   "endpwent ()\n\
 \n\
 Close the password-file stream.")
 {
-  octave_value retval;
+  octave_value_list retval;
+
+  retval(1) = string ();
+  retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
-    octave_passwd::endpwent ();
+    {
+      string msg;
+
+      retval(0) = static_cast<double> (octave_passwd::endpwent (msg));
+      retval(1) = msg;
+    }
   else
     print_usage ("endpwent");
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -41,16 +41,17 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #ifdef HAVE_FCNTL_H
 #include <fcntl.h>
 #endif
 
 #include "file-ops.h"
 #include "file-stat.h"
+#include "oct-syscalls.h"
 
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "lo-utils.h"
 #include "oct-map.h"
 #include "oct-obj.h"
@@ -101,46 +102,42 @@ Otherwise, FID is negative and MSG conta
 
   retval(1) = string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
-#if defined (HAVE_DUP2)
       double d_old = args(0).double_value ();
       double d_new = args(1).double_value ();
 
       if (! error_state)
 	{
 	  if (D_NINT (d_old) == d_old && D_NINT (d_new) == d_new)
 	    {
 	      int i_old = NINT (d_old);
 	      int i_new = NINT (d_new);
 
 	      // XXX FIXME XXX -- are these checks sufficient?
 	      if (i_old >= 0 && i_new >= 0)
 		{
-		  int status = dup2 (i_old, i_new);
+		  string msg;
+
+		  int status = octave_syscalls::dup2 (i_old, i_new, msg);
 
 		  retval(0) = static_cast<double> (status);
-
-		  if (status < 0)
-		    retval(1) = strerror (errno);
+		  retval(1) = msg;
 		}
 	      else
 		error ("dup2: invalid file id");
 	    }
 	  else
 	    error ("dup2: arguments must be integer values");
 	}
-#else
-      gripe_not_supported ("dup2");
-#endif
     }
   else
     print_usage ("dup2");
 
   return retval;
 }
 
 DEFUN (exec, args, ,
@@ -155,75 +152,59 @@ be nonzero, and MSG will contain a syste
 
   retval(1) = string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-#if defined (HAVE_EXECVP)
       string exec_file = args(0).string_value ();
 
       if (! error_state)
 	{
-	  char **exec_args = 0;
+	  string_vector exec_args;
 
 	  if (nargin == 2)
 	    {
-	      charMatrix chm = args(1).all_strings ();
+	      string_vector tmp = args(1).all_strings ();
 
 	      if (! error_state)
 		{
-		  int nr = chm.rows ();
-		  int nc = chm.cols ();
-
-		  exec_args = new char * [nr+2];
+		  int len = tmp.length ();
 
-		  // XXX FIXME XXX -- potential leak?
-
-		  exec_args[0] = strsave (exec_file.c_str ());
-		  exec_args[nr+1] = 0;
+		  exec_args.resize (len + 1);
 
-		  for (int i = 0; i < nr; i++)
-		    {
-		      exec_args[i+1] = new char [nc+1];
+		  exec_args[0] = exec_file;
 
-		      for (int j = 0; j < nc; j++)
-			exec_args[i+1][j] = chm (i, j);
-
-		      exec_args[i+1][nc] = '\0';
-		    }
+		  for (int i = 0; i < len; i++)
+		    exec_args[i+1] = tmp[i];
 		}
 	      else
 		error ("exec: arguments must be strings");
 	    }
 	  else
 	    {
-	      exec_args = new char * [2];
+	      exec_args.resize (1);
 
-	      exec_args[0] = strsave (exec_file.c_str ());
-	      exec_args[1] = 0;
+	      exec_args[0] = exec_file;
 	    }
 
 	  if (! error_state)
 	    {
-	      int status = execvp (exec_file.c_str (), exec_args);
+	      string msg;
+
+	      int status = octave_syscalls::execvp (exec_file, exec_args, msg);
 
 	      retval(0) = static_cast<double> (status);
-
-	      if (status < 0)
-		retval(1) = strerror (errno);
+	      retval(1) = msg;
 	    }
 	}
       else
 	error ("exec: first argument must be a string");
-#else
-      gripe_not_supported ("exec");
-#endif
     }
   else
     print_usage ("exec");
 
   return retval;
 }
 
 DEFUN (fcntl, args, ,
@@ -238,17 +219,16 @@ STATUS is nonzero and MSG contains a sys
 
   retval(1) = string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 3)
     {
-#if defined (HAVE_FCNTL)
       double d_fid = args(0).double_value ();
       double d_req = args(1).double_value ();
       double d_arg = args(2).double_value ();
 
       if (! error_state
 	  && D_NINT (d_fid) == d_fid
 	  && D_NINT (d_req) == d_req
 	  && D_NINT (d_arg) == d_arg)
@@ -257,29 +237,26 @@ STATUS is nonzero and MSG contains a sys
 	  int req = NINT (d_req);
 	  int arg = NINT (d_arg);
 
 	  // XXX FIXME XXX -- Need better checking here?
 	  if (fid < 0)
 	    error ("fcntl: invalid file id");
 	  else
 	    {
-	      int status = fcntl (fid, req, arg);
+	      string msg;
+
+	      int status = octave_syscalls::fcntl (fid, req, arg, msg);
 
 	      retval(0) = static_cast<double> (status);
-
-	      if (status < 0)
-		retval(1) = strerror (errno);
+	      retval(1) = msg;
 	    }
 	}
       else
 	error ("fcntl: file id must be an integer");
-#else
-      gripe_not_supported ("fcntl");
-#endif
     }
   else
     print_usage ("fcntl");
 
   return retval;
 }
 
 DEFUN (fork, args, ,
@@ -295,174 +272,136 @@ has occured, and MSG contains a system-d
 
   retval(1) = string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
-#if defined (HAVE_FORK)
-      pid_t pid = fork ();
+      string msg;
+
+      pid_t pid = octave_syscalls::fork (msg);
 
       retval(0) = static_cast<double> (pid);
-
-      if (pid < 0)
-	retval(1) = strerror (errno);
-#else
-      gripe_not_supported ("fork");
-#endif
+      retval(1) = msg;
     }
   else
     print_usage ("fork");
 
   return retval;
 }
 
 DEFUN (getpgrp, args, ,
   "pgid = getpgrp (): return the process group id of the current process")
 {
-  double retval = -1.0;
+  octave_value_list retval;
+
+  retval(1) = string ();
+  retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
-#if defined (HAVE_GETPGRP)
-      retval = getpgrp ();
-#else
-      gripe_not_supported ("getpgrp");
-#endif
+      string msg;
+
+      retval(0) = static_cast<double> (octave_syscalls::getpgrp (msg));
+      retval(1) = msg;
     }
   else
     print_usage ("getpgrp");
 
   return retval;
 }
 
 DEFUN (getpid, args, ,
   "pid = getpid (): return the process id of the current process")
 {
   double retval = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
-    {
-#if defined (HAVE_GETPID)
-      retval = getpid ();
-#else
-      gripe_not_supported ("getpid");
-#endif
-    }
+    retval = octave_syscalls::getpid ();
   else
     print_usage ("getpid");
 
   return retval;
 }
 
 DEFUN (getppid, args, ,
   "pid = getppid (): return the process id of the parent process")
 {
   double retval = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
-    {
-#if defined (HAVE_GETPPID)
-      retval = getppid ();
-#else
-      gripe_not_supported ("getppid");
-#endif
-    }
+    retval = octave_syscalls::getppid ();
   else
     print_usage ("getppid");
 
   return retval;
 }
 
 DEFUN (getegid, args, ,
   "gid = getegid (): return the effective group id of the current process")
 {
   double retval = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
-    {
-#if defined (HAVE_GETEGID)
-      retval = getegid ();
-#else
-      gripe_not_supported ("getegid");
-#endif
-    }
+    retval = octave_syscalls::getegid ();
   else
     print_usage ("getegid");
 
   return retval;
 }
 
 DEFUN (getgid, args, ,
   "gid = getgid (): return the real group id of the current process")
 {
   double retval = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
-    {
-#if defined (HAVE_GETGID)
-      retval = getgid ();
-#else
-      gripe_not_supported ("getgid");
-#endif
-    }
+    retval = octave_syscalls::getgid ();
   else
     print_usage ("getgid");
 
   return retval;
 }
 
 DEFUN (geteuid, args, ,
   "uid = geteuid (): return the effective user id of the current process")
 {
   double retval = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
-    {
-#if defined (HAVE_GETEUID)
-      retval = geteuid ();
-#else
-      gripe_not_supported ("geteuid");
-#endif
-    }
+    retval = octave_syscalls::geteuid ();
   else
     print_usage ("geteuid");
 
   return retval;
 }
 
 DEFUN (getuid, args, ,
   "uid = getuid (): return the real user id of the current process")
 {
   double retval = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
-    {
-#if defined (HAVE_GETUID)
-      retval = getuid ();
-#else
-      gripe_not_supported ("getuid");
-#endif
-    }
+    retval = octave_syscalls::getuid ();
   else
     print_usage ("getuid");
 
   return retval;
 }
 
 DEFUN (lstat, args, ,
   "[S, ERR, MSG] = lstat (NAME)\n\
@@ -535,17 +474,16 @@ STATUS is nonzero and MSG contains a sys
 	      if (status < 0)
 		retval(1) = msg;
 	    }
 	  else
 	    error ("mkfifo: MODE must be an integer");
 	}
       else
 	error ("mkfifo: file name must be a string");
-
     }
   else
     print_usage ("mkfifo");
 
   return retval;
 }
 
 DEFUN (pipe, args, ,
@@ -562,25 +500,24 @@ STATUS is nonzero and MSG contains a sys
   retval(2) = string ();
   retval(1) = -1.0;
   retval(0) = Matrix ();
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
-#if defined (HAVE_PIPE)
       int fid[2];
 
-      int status = pipe (fid);
+      string msg;
+
+      int status = octave_syscalls::pipe (fid, msg);
 
       if (status < 0)
-	{
-	  retval(2) = strerror (errno);
-	}
+	retval(2) = msg;
       else
 	{
 	  FILE *in_file = fdopen (fid[0], "r");
 	  FILE *out_file = fdopen (fid[1], "w");
 
 	  octave_istdiostream *is
 	    = new octave_istdiostream (string (), in_file);
 
@@ -590,19 +527,16 @@ STATUS is nonzero and MSG contains a sys
 	  octave_value_list file_ids;
 
 	  file_ids(1) = octave_stream_list::insert (os);
 	  file_ids(0) = octave_stream_list::insert (is);
 
 	  retval(1) = static_cast<double> (status);
           retval(0) = octave_value (file_ids);
 	}
-#else
-      gripe_not_supported ("pipe");
-#endif
     }
   else
     print_usage ("pipe");
 
   return retval;
 }
 
 DEFUN (stat, args, ,
@@ -682,19 +616,17 @@ STATUS is nonzero and MSG contains a sys
 	{
 	  string name = args(0).string_value ();
 
 	  string msg;
 
 	  int status = file_ops::unlink (name, msg);
 
 	  retval(0) = static_cast<double> (status);
-
-	  if (status < 0)
-	    retval(1) = msg;	    
+	  retval(1) = msg;	    
 	}
       else
 	error ("unlink: file name must be a string");
     }
   else
     print_usage ("unlink");
 
   return retval;
@@ -731,17 +663,16 @@ error message.")
 
   retval(1) = string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-#if defined (HAVE_WAITPID)
       double pid_num = args(0).double_value ();
   
       if (! error_state)
 	{
 	  if (D_NINT (pid_num) != pid_num)
 	    error ("waitpid: PID must be an integer value");
 	  else
 	    {
@@ -763,28 +694,26 @@ error message.")
 			  if (options < 0 || options > 3)
 			    error ("waitpid: invalid OPTIONS value specified");
 			}
 		    }
 		}
 
 	      if (! error_state)
 		{
-		  pid_t status = waitpid (pid, 0, options);
+		  string msg;
+
+		  pid_t status
+		    = octave_syscalls::waitpid (pid, options, msg);
 
 		  retval(0) = static_cast<double> (status);
-
-		  if (status < 0)
-		    retval(1) = strerror (errno);
+		  retval(1) = msg;
 		}
 	    }
 	}
-#else
-      gripe_not_supported ("waitpid");
-#endif
     }
   else
     print_usage ("waitpid");
 
   return retval;
 }
 
 #if !defined (O_NONBLOCK) && defined (O_NDELAY)
