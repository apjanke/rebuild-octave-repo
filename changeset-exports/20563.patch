# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1444105202 14400
#      Tue Oct 06 00:20:02 2015 -0400
# Node ID c1a6c31ac29a30f2693ca73b964819fc0944187d
# Parent  a05a0432dff45d9bf8824051e7f80e3b29474cb8
eliminate more simple uses of error_state

* ov-classdef.cc: Eliminate simple uses of error_state.

diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -95,32 +95,29 @@ get_base_name (const std::string& nm)
 }
 
 static void
 make_function_of_class (const std::string& class_name,
                         const octave_value& fcn)
 {
   octave_function *of = fcn.function_value ();
 
-  if (! error_state)
+  of->stash_dispatch_class (class_name);
+
+  octave_user_function *uf = of->user_function_value (true);
+
+  if (uf)
     {
-      of->stash_dispatch_class (class_name);
-
-      octave_user_function *uf = of->user_function_value (true);
-
-      if (! error_state && uf)
+      if (get_base_name (class_name) == uf->name ())
         {
-          if (get_base_name (class_name) == uf->name ())
-            {
-              uf->mark_as_class_constructor ();
-              uf->mark_as_classdef_constructor ();
-            }
-          else
-            uf->mark_as_class_method ();
+          uf->mark_as_class_constructor ();
+          uf->mark_as_classdef_constructor ();
         }
+      else
+        uf->mark_as_class_method ();
     }
 }
 
 static void
 make_function_of_class (const cdef_class& cls, const octave_value& fcn)
 {
   make_function_of_class (cls.get_name (), fcn);
 }
@@ -177,18 +174,17 @@ static cdef_class
 lookup_class (const octave_value& ov)
 {
   if (ov.is_string())
     return lookup_class (ov.string_value ());
   else
     {
       cdef_class cls (to_cdef (ov));
 
-      if (! error_state)
-        return lookup_class (cls);
+      return lookup_class (cls);
     }
 
   return cdef_class ();
 }
 
 static std::list<cdef_class>
 lookup_classes (const Cell& cls_list)
 {
@@ -230,23 +226,22 @@ is_superclass (const cdef_class& clsa, c
   bool retval = false;
 
   if (allow_equal && clsa == clsb)
     retval = true;
   else if (max_depth != 0)
     {
       Cell c = clsb.get ("SuperClasses").cell_value ();
 
-      for (int i = 0; ! error_state && ! retval && i < c.numel (); i++)
+      for (int i = 0; ! retval && i < c.numel (); i++)
         {
           cdef_class cls = lookup_class (c(i));
 
-          if (! error_state)
-            retval = is_superclass (clsa, cls, true,
-                                    max_depth < 0 ? max_depth : max_depth-1);
+          retval = is_superclass (clsa, cls, true,
+                                  max_depth < 0 ? max_depth : max_depth-1);
         }
     }
 
   return retval;
 }
 
 inline bool
 is_strict_superclass (const cdef_class& clsa, const cdef_class& clsb)
@@ -282,21 +277,19 @@ get_class_context (std::string& name, bo
 
   if (fcn && (fcn->is_class_method ()
               || fcn->is_classdef_constructor ()
               || fcn->is_anonymous_function_of_class ()
               || (fcn->is_private_function ()
                   && ! fcn->dispatch_class ().empty ())))
     {
       cls = lookup_class (fcn->dispatch_class ());
-      if (! error_state)
-        {
-          name = fcn->name ();
-          in_constructor = fcn->is_classdef_constructor ();
-        }
+
+      name = fcn->name ();
+      in_constructor = fcn->is_classdef_constructor ();
     }
 
   return cls;
 }
 
 inline cdef_class
 get_class_context (void)
 {
@@ -327,17 +320,17 @@ check_access (const cdef_class& cls, con
       if (acc_s == "public")
         return true;
 
       cdef_class ctx = get_class_context ();
 
       // The access is private or protected, this requires a
       // valid class context.
 
-      if (! error_state && ctx.ok ())
+      if (ctx.ok ())
         {
           if (acc_s == "private")
             return (ctx == cls);
           else if (acc_s == "protected")
             {
               if (is_superclass (cls, ctx))
                 // Calling a protected method in a superclass.
                 return true;
@@ -385,30 +378,27 @@ check_access (const cdef_class& cls, con
   else if (acc.is_cell ())
     {
       Cell acc_c = acc.cell_value ();
 
       cdef_class ctx = get_class_context ();
 
       // At this point, a class context is always required.
 
-      if (! error_state && ctx.ok ())
+      if (ctx.ok ())
         {
           if (ctx == cls)
             return true;
 
-          for (int i = 0; ! error_state && i < acc.numel (); i++)
+          for (int i = 0; i < acc.numel (); i++)
             {
               cdef_class acc_cls (to_cdef (acc_c(i)));
 
-              if (! error_state)
-                {
-                  if (is_superclass (acc_cls, ctx))
-                    return true;
-                }
+              if (is_superclass (acc_cls, ctx))
+                return true;
             }
         }
     }
   else
     error ("invalid property/method access in class `%s'",
            cls.get_name ().c_str ());
 
   return false;
@@ -578,17 +568,18 @@ class_fevalStatic (const octave_value_li
                            meth_name.c_str ());
                 }
               else
                 error ("fevalStatic: method not found: %s", meth_name.c_str ());
             }
           else
             error ("fevalStatic: invalid method name, expected a string value");
         }
-      error ("fevalStatic: invalid object, expected a meta.class object");
+      else
+        error ("fevalStatic: invalid object, expected a meta.class object");
     }
   else
     error ("fevalStatic: invalid arguments");
 
   return retval;
 }
 
 static octave_value_list
@@ -744,19 +735,16 @@ make_class (const std::string& name,
       else
         {
           cls.put ("HandleCompatible", all_handle_compatible);
           if (has_handle_class)
             cls.mark_as_handle_class ();
         }
     }
 
-  if (error_state)
-    return cdef_class ();
-
   if (! name.empty ())
     cdef_manager::register_class (cls);
 
   return cls;
 }
 
 static cdef_class
 make_class (const std::string& name, const cdef_class& super)
@@ -904,37 +892,31 @@ octave_classdef::subsref (const std::str
       cdef_method meth = cls.find_method ("subsref");
 
       if (meth.ok ())
         {
           octave_value_list args;
 
           args(1) = make_idx_args (type, idx, "subsref");
 
-          if (! error_state)
-            {
-              count++;
-              args(0) = octave_value (this);
-
-              retval = meth.execute (args, nargout, true, "subsref");
-            }
+          count++;
+          args(0) = octave_value (this);
+
+          retval = meth.execute (args, nargout, true, "subsref");
 
           return retval;
         }
     }
 
   // At this point, the default subsref mechanism must be used.
 
   retval = object.subsref (type, idx, nargout, skip, cdef_class ());
 
-  if (! error_state)
-    {
-      if (type.length () > skip && idx.size () > skip)
-        retval = retval(0).next_subsref (nargout, type, idx, skip);
-    }
+  if (type.length () > skip && idx.size () > skip)
+    retval = retval(0).next_subsref (nargout, type, idx, skip);
 
   return retval;
 }
 
 octave_value
 octave_classdef::subsref (const std::string& type,
                           const std::list<octave_value_list>& idx,
                           bool auto_add)
@@ -944,21 +926,18 @@ octave_classdef::subsref (const std::str
 
   // This variant of subsref is used to create temporary values when doing
   // assignment with multi-level indexing. AFAIK this is only used for internal
   // purpose (not sure we should even implement this) and any overload subsref
   // should not be called.
 
   retval = object.subsref (type, idx, 1, skip, cdef_class (), auto_add);
 
-  if (! error_state)
-    {
-      if (type.length () > skip && idx.size () > skip)
-        retval = retval(0).next_subsref (1, type, idx, skip);
-    }
+  if (type.length () > skip && idx.size () > skip)
+    retval = retval(0).next_subsref (1, type, idx, skip);
 
   return retval.length () > 0 ? retval(0) : octave_value ();
 }
 
 octave_value
 octave_classdef::subsasgn (const std::string& type,
                            const std::list<octave_value_list>& idx,
                            const octave_value& rhs)
@@ -972,54 +951,47 @@ octave_classdef::subsasgn (const std::st
       cdef_method meth = cls.find_method ("subsasgn");
 
       if (meth.ok ())
         {
           octave_value_list args;
 
           args(1) = make_idx_args (type, idx, "subsasgn");
 
-          if (! error_state)
-            {
-              count++;
-              args(0) = octave_value (this);
-              args(2) = rhs;
-
-              octave_value_list retlist;
-
-              retlist = meth.execute (args, 1, true, "subsasgn");
-
-              if (! error_state)
-                {
-                  if (retlist.length () > 0)
-                    retval = retlist(0);
-                  else
-                    error ("overloaded method `subsasgn' did not return any value");
-                }
-            }
+          count++;
+          args(0) = octave_value (this);
+          args(2) = rhs;
+
+          octave_value_list retlist;
+
+          retlist = meth.execute (args, 1, true, "subsasgn");
+
+          if (retlist.length () > 0)
+            retval = retlist(0);
+          else
+            error ("overloaded method `subsasgn' did not return any value");
         }
     }
 
-  if (! error_state && ! retval.is_defined ())
+  if (! retval.is_defined ())
     retval = object.subsasgn (type, idx, rhs);
 
   return retval;
 }
 
 octave_value
 octave_classdef::undef_subsasgn (const std::string& type,
                                  const std::list<octave_value_list>& idx,
                                  const octave_value& rhs)
 {
   if (type.length () == 1 && type[0] == '(')
     {
       object = object.make_array ();
 
-      if (! error_state)
-        return subsasgn (type, idx, rhs);
+      return subsasgn (type, idx, rhs);
     }
   else
     return octave_base_value::undef_subsasgn (type, idx, rhs);
 
   return octave_value ();
 }
 
 void
@@ -1196,22 +1168,19 @@ public:
         retval = do_multi_index_op (type.length () > 1 ? 1 : nargout,
                                     idx.front ());
         break;
       default:
         retval = do_multi_index_op (1, octave_value_list ());
         break;
       }
 
-    if (! error_state)
-      {
-        if (type.length () > skip && idx.size () > skip
-            && retval.length () > 0)
-          retval = retval(0).next_subsref (nargout, type, idx, skip);
-      }
+    if (type.length () > skip && idx.size () > skip
+        && retval.length () > 0)
+      retval = retval(0).next_subsref (nargout, type, idx, skip);
 
     return retval;
   }
 
   octave_value
   subsref (const std::string& type,
            const std::list<octave_value_list>& idx)
   {
@@ -1235,72 +1204,69 @@ public:
 
     if (! error_state && ctx.ok ())
       {
         std::string mname = args(0).string_value ();
         std::string cname = args(1).string_value ();
 
         cdef_class cls = lookup_class (cname);
 
-        if (! error_state)
+        if (in_constructor)
           {
-            if (in_constructor)
+            if (is_direct_superclass (cls, ctx))
               {
-                if (is_direct_superclass (cls, ctx))
+                if (is_constructed_object (mname))
                   {
-                    if (is_constructed_object (mname))
-                      {
-                        octave_value sym = symbol_table::varval (mname);
-
-                        cls.run_constructor (to_cdef_ref (sym), idx);
-
-                        retval(0) = sym;
-                      }
-                    else
-                      error ("cannot call superclass constructor with "
-                             "variable `%s'", mname.c_str ());
+                    octave_value sym = symbol_table::varval (mname);
+
+                    cls.run_constructor (to_cdef_ref (sym), idx);
+
+                    retval(0) = sym;
                   }
                 else
-                  error ("`%s' is not a direct superclass of `%s'",
+                  error ("cannot call superclass constructor with "
+                         "variable `%s'", mname.c_str ());
+              }
+            else
+              error ("`%s' is not a direct superclass of `%s'",
+                     cname.c_str (), ctx.get_name ().c_str ());
+          }
+        else
+          {
+            if (mname == meth_name)
+              {
+                if (is_strict_superclass (cls, ctx))
+                  {
+                    // I see 2 possible implementations here:
+                    // 1) use cdef_object::subsref with a different class
+                    //    context; this avoids duplicating code, but
+                    //    assumes the object is always the first argument
+                    // 2) lookup the method manually and call
+                    //    cdef_method::execute; this duplicates part of
+                    //    logic in cdef_object::subsref, but avoid the
+                    //    assumption of 1)
+                    // Not being sure about the assumption of 1), I
+                    // go with option 2) for the time being.
+
+                    cdef_method meth = cls.find_method (meth_name, false);
+
+                    if (meth.ok ())
+                      retval = meth.execute (idx, nargout, true,
+                                             meth_name);
+                    else
+                      error ("no method `%s' found in superclass `%s'",
+                             meth_name.c_str (), cname.c_str ());
+                  }
+                else
+                  error ("`%s' is not a superclass of `%s'",
                          cname.c_str (), ctx.get_name ().c_str ());
               }
             else
-              {
-                if (mname == meth_name)
-                  {
-                    if (is_strict_superclass (cls, ctx))
-                      {
-                        // I see 2 possible implementations here:
-                        // 1) use cdef_object::subsref with a different class
-                        //    context; this avoids duplicating code, but
-                        //    assumes the object is always the first argument
-                        // 2) lookup the method manually and call
-                        //    cdef_method::execute; this duplicates part of
-                        //    logic in cdef_object::subsref, but avoid the
-                        //    assumption of 1)
-                        // Not being sure about the assumption of 1), I
-                        // go with option 2) for the time being.
-
-                        cdef_method meth = cls.find_method (meth_name, false);
-
-                        if (meth.ok ())
-                          retval = meth.execute (idx, nargout, true,
-                                                 meth_name);
-                        else
-                          error ("no method `%s' found in superclass `%s'",
-                                 meth_name.c_str (), cname.c_str ());
-                      }
-                    else
-                      error ("`%s' is not a superclass of `%s'",
-                             cname.c_str (), ctx.get_name ().c_str ());
-                  }
-                else
-                  error ("method name mismatch (`%s' != `%s')",
-                         mname.c_str (), meth_name.c_str ());
-              }
+              error ("method name mismatch (`%s' != `%s')",
+                     mname.c_str (), meth_name.c_str ());
           }
       }
     else if (! error_state)
       error ("superclass calls can only occur in methods or constructors");
 
     return retval;
   }
 
@@ -1357,37 +1323,27 @@ cdef_object::map_value (void) const
 
           if (is_array ())
             {
               Array<cdef_object> a_obj = array_value ();
 
               Cell cvalue (a_obj.dims ());
 
               for (octave_idx_type i = 0; i < a_obj.numel (); i++)
-                {
-                  cvalue (i) = it->second.get_value (a_obj(i), false);
-
-                  if (error_state)
-                    break;
-                }
-
-              if (! error_state)
-                retval.setfield (it->first, cvalue);
+                cvalue (i) = it->second.get_value (a_obj(i), false);
+
+              retval.setfield (it->first, cvalue);
             }
           else
             {
               Cell cvalue (dim_vector (1, 1),
                            it->second.get_value (*this, false));
 
-              if (! error_state)
-                retval.setfield (it->first, cvalue);
+              retval.setfield (it->first, cvalue);
             }
-
-          if (error_state)
-            break;
         }
     }
 
   return retval;
 }
 
 string_vector
 cdef_object_rep::map_keys (void) const
@@ -1445,17 +1401,17 @@ cdef_object_scalar::subsref (const std::
             else
               {
                 refcount++;
                 retval = meth.execute (cdef_object (this), args, _nargout,
                                        true, "subsref");
               }
           }
 
-        if (skip == 0 && ! error_state)
+        if (skip == 0)
           {
             cdef_property prop = cls.find_property (name);
 
             if (prop.ok ())
               {
                 if (prop.is_constant ())
                   retval(0) = prop.get_value (true, "subsref");
                 else
@@ -1516,68 +1472,57 @@ cdef_object_scalar::subsasgn (const std:
   cdef_class cls = get_class ();
 
   switch (type[0])
     {
     case '.':
       {
         std::string name = (idx.front ())(0).string_value ();
 
-        if (! error_state)
+        cdef_property prop = cls.find_property (name);
+
+        if (prop.ok ())
           {
-            cdef_property prop = cls.find_property (name);
-
-            if (prop.ok ())
+            if (prop.is_constant ())
+              error ("subsasgn: cannot assign constant property: %s",
+                     name.c_str ());
+            else
               {
-                if (prop.is_constant ())
-                  error ("subsasgn: cannot assign constant property: %s",
-                         name.c_str ());
+                refcount++;
+
+                cdef_object obj (this);
+
+                if (type.length () == 1)
+                  {
+                    prop.set_value (obj, rhs, true, "subsasgn");
+
+                    retval = to_ov (obj);
+                  }
                 else
                   {
-                    refcount++;
-
-                    cdef_object obj (this);
-
-                    if (type.length () == 1)
-                      {
-                        prop.set_value (obj, rhs, true, "subsasgn");
-
-                        if (! error_state)
-                          retval = to_ov (obj);
-                      }
-                    else
-                      {
-                        octave_value val =
-                          prop.get_value (obj, true, "subsasgn");
-
-                        if (! error_state)
-                          {
-                            std::list<octave_value_list> args (idx);
-
-                            args.erase (args.begin ());
-
-                            val = val.assign (octave_value::op_asn_eq,
-                                              type.substr (1), args, rhs);
-
-                            if (! error_state)
-                              {
-                                if (val.class_name () != "object"
-                                    || ! to_cdef (val).is_handle_object ())
-                                  prop.set_value (obj, val, true, "subsasgn");
-
-                                if (! error_state)
-                                  retval = to_ov (obj);
-                              }
-                          }
-                      }
+                    octave_value val =
+                      prop.get_value (obj, true, "subsasgn");
+
+                    std::list<octave_value_list> args (idx);
+
+                    args.erase (args.begin ());
+
+                    val = val.assign (octave_value::op_asn_eq,
+                                      type.substr (1), args, rhs);
+
+                    if (val.class_name () != "object"
+                        || ! to_cdef (val).is_handle_object ())
+                      prop.set_value (obj, val, true, "subsasgn");
+
+                    retval = to_ov (obj);
                   }
               }
-            else
-              error ("subsasgn: unknown property: %s", name.c_str ());
           }
+        else
+          error ("subsasgn: unknown property: %s", name.c_str ());
       }
       break;
 
     case '(':
       {
         refcount++;
 
         cdef_object this_obj (this);
@@ -1585,18 +1530,17 @@ cdef_object_scalar::subsasgn (const std:
         Array<cdef_object> arr (dim_vector (1, 1), this_obj);
 
         cdef_object new_obj = cdef_object (new cdef_object_array (arr));
 
         new_obj.set_class (get_class ());
 
         octave_value tmp = new_obj.subsasgn (type, idx, rhs);
 
-        if (! error_state)
-          retval = tmp;
+        retval = tmp;
       }
       break;
 
     default:
       error ("subsasgn: object cannot be index with `%c'", type[0]);
       break;
     }
 
@@ -1605,23 +1549,19 @@ cdef_object_scalar::subsasgn (const std:
 
 void
 cdef_object_scalar::mark_for_construction (const cdef_class& cls)
 {
   std::string cls_name = cls.get_name ();
 
   Cell supcls = cls.get ("SuperClasses").cell_value ();
 
-  if (! error_state)
-    {
-      std::list<cdef_class> supcls_list = lookup_classes (supcls);
-
-      if (! error_state)
-        ctor_list[cls] = supcls_list;
-    }
+  std::list<cdef_class> supcls_list = lookup_classes (supcls);
+
+  ctor_list[cls] = supcls_list;
 }
 
 octave_value_list
 cdef_object_array::subsref (const std::string& type,
                             const std::list<octave_value_list>& idx,
                             int /* nargout */, size_t& skip,
                             const cdef_class& /* context */, bool auto_add)
 {
@@ -1640,56 +1580,50 @@ cdef_object_array::subsref (const std::s
             refcount++;
             retval(0) = to_ov (cdef_object (this));
             break;
           }
 
         bool is_scalar = true;
         Array<idx_vector> iv (dim_vector (1, ival.length ()));
 
-        for (int i = 0; ! error_state && i < ival.length (); i++)
+        for (int i = 0; i < ival.length (); i++)
           {
             try
               {
                 iv(i) = ival(i).index_vector ();
               }
             catch (index_exception& e)
               {
                 // Rethrow to allow more info to be reported later.
                 e.set_pos_if_unset (ival.length (), i+1);
                 throw;
               }
-            if (! error_state)
-              is_scalar = is_scalar && iv(i).is_scalar ();
+
+            is_scalar = is_scalar && iv(i).is_scalar ();
           }
 
-        if (! error_state)
+        Array<cdef_object> ires = array.index (iv, auto_add);
+
+        // If resizing is enabled (auto_add = true), it's possible
+        // indexing was out-of-bound and the result array contains
+        // invalid cdef_objects.
+
+        if (auto_add)
+          fill_empty_values (ires);
+
+        if (is_scalar)
+          retval(0) = to_ov (ires(0));
+        else
           {
-            Array<cdef_object> ires = array.index (iv, auto_add);
-
-            if (! error_state)
-              {
-                // If resizing is enabled (auto_add = true), it's possible
-                // indexing was out-of-bound and the result array contains
-                // invalid cdef_objects.
-
-                if (auto_add)
-                  fill_empty_values (ires);
-
-                if (is_scalar)
-                  retval(0) = to_ov (ires(0));
-                else
-                  {
-                    cdef_object array_obj (new cdef_object_array (ires));
-
-                    array_obj.set_class (get_class ());
-
-                    retval(0) = to_ov (array_obj);
-                  }
-              }
+            cdef_object array_obj (new cdef_object_array (ires));
+
+            array_obj.set_class (get_class ());
+
+            retval(0) = to_ov (array_obj);
           }
       }
       break;
 
     case '.':
       if (type.size () == 1 && idx.size () == 1)
         {
           Cell c (dims ());
@@ -1700,27 +1634,21 @@ cdef_object_array::subsref (const std::s
           size_t dummy_skip;
           cdef_class dummy_cls;
 
           for (octave_idx_type i = 0; i < n; i++)
             {
               octave_value_list r = array(i).subsref (type, idx, 1, dummy_skip,
                                                       dummy_cls);
 
-              if (! error_state)
-                {
-                  if (r.length () > 0)
-                    c(i) = r(0);
-                }
-              else
-                break;
+              if (r.length () > 0)
+                c(i) = r(0);
             }
 
-          if (! error_state)
-            retval(0) = octave_value (c, true);
+          retval(0) = octave_value (c, true);
 
           break;
         }
       // fall through "default"
 
     default:
       error ("can't perform indexing operation on array of %s objects",
              class_name ().c_str ());
@@ -1739,177 +1667,150 @@ cdef_object_array::subsasgn (const std::
 
   switch (type[0])
     {
     case '(':
       if (type.length () == 1)
         {
           cdef_object rhs_obj = to_cdef (rhs);
 
-          if (! error_state)
+          if (rhs_obj.get_class () == get_class ())
             {
-              if (rhs_obj.get_class () == get_class ())
+              const octave_value_list& ival = idx.front ();
+              bool is_scalar = true;
+              Array<idx_vector> iv (dim_vector (1, ival.length ()));
+
+              for (int i = 0; i < ival.length (); i++)
                 {
-                  const octave_value_list& ival = idx.front ();
-                  bool is_scalar = true;
-                  Array<idx_vector> iv (dim_vector (1, ival.length ()));
-
-                  for (int i = 0; ! error_state && i < ival.length (); i++)
+                  try
                     {
-                      try
-                        {
-                          iv(i) = ival(i).index_vector ();
-                        }
-                      catch (index_exception& e)
-                        {
-                          e.set_pos_if_unset (ival.length (), i+1);
-                          throw;   // var name set in pt-idx.cc / pt-assign.cc
-                        }
-                      if (! error_state)
-                        is_scalar = is_scalar && iv(i).is_scalar ();
+                      iv(i) = ival(i).index_vector ();
                     }
-
-                  if (! error_state)
+                  catch (index_exception& e)
                     {
-                      Array<cdef_object> rhs_mat;
-
-                      if (! rhs_obj.is_array ())
-                        {
-                          rhs_mat = Array<cdef_object> (dim_vector (1, 1));
-                          rhs_mat(0) = rhs_obj;
-                        }
-                      else
-                        rhs_mat = rhs_obj.array_value ();
-
-                      if (! error_state)
-                        {
-                          octave_idx_type n = array.numel ();
-
-                          array.assign (iv, rhs_mat, cdef_object ());
-
-                          if (! error_state)
-                            {
-                              if (array.numel () > n)
-                                fill_empty_values ();
-
-                              if (! error_state)
-                                {
-                                  refcount++;
-                                  retval = to_ov (cdef_object (this));
-                                }
-                            }
-                        }
+                      e.set_pos_if_unset (ival.length (), i+1);
+                      throw;   // var name set in pt-idx.cc / pt-assign.cc
                     }
+
+                  is_scalar = is_scalar && iv(i).is_scalar ();
+                }
+
+              Array<cdef_object> rhs_mat;
+
+              if (! rhs_obj.is_array ())
+                {
+                  rhs_mat = Array<cdef_object> (dim_vector (1, 1));
+                  rhs_mat(0) = rhs_obj;
                 }
               else
-                error ("can't assign %s object into array of %s objects.",
-                       rhs_obj.class_name ().c_str (),
-                       class_name ().c_str ());
+                rhs_mat = rhs_obj.array_value ();
+
+              octave_idx_type n = array.numel ();
+
+              array.assign (iv, rhs_mat, cdef_object ());
+
+              if (array.numel () > n)
+                fill_empty_values ();
+
+              refcount++;
+              retval = to_ov (cdef_object (this));
             }
+          else
+            error ("can't assign %s object into array of %s objects.",
+                   rhs_obj.class_name ().c_str (),
+                   class_name ().c_str ());
         }
       else
         {
           const octave_value_list& ival = idx.front ();
 
           bool is_scalar = true;
 
           Array<idx_vector> iv (dim_vector (1, ival.length ()));
 
-          for (int i = 0; ! error_state && i < ival.length (); i++)
+          for (int i = 0; i < ival.length (); i++)
             {
               try
                 {
                   iv(i) = ival(i).index_vector ();
                 }
               catch (index_exception& e)
                 {
                   // Rethrow to allow more info to be reported later.
                   e.set_pos_if_unset (ival.length (), i+1);
                   throw;
                 }
 
-              if (! error_state)
-                {
-                  is_scalar = is_scalar && iv(i).is_scalar ();
-
-                  if (! is_scalar)
-                    error ("subsasgn: invalid indexing for object array "
-                           "assignment, the index must reference a single "
-                           "object in the array.");
-                }
+              is_scalar = is_scalar && iv(i).is_scalar ();
+
+              if (! is_scalar)
+                error ("subsasgn: invalid indexing for object array "
+                       "assignment, the index must reference a single "
+                       "object in the array.");
             }
 
-          if (! error_state)
+          Array<cdef_object> a = array.index (iv, true);
+
+          if (a.numel () != 1)
+            error ("subsasgn: invalid indexing for object array "
+                   "assignment");
+
+          cdef_object obj = a(0);
+
+          int ignore_copies = 0;
+
+          // If the object in 'a' is not valid, this means the index
+          // was out-of-bound and we need to create a new object.
+
+          if (! obj.ok ())
+            obj = get_class ().construct_object (octave_value_list ());
+          else
+            // Optimize the subsasgn call to come. There are 2 copies
+            // that we can safely ignore:
+            // - 1 in "array"
+            // - 1 in "a"
+            ignore_copies = 2;
+
+          std::list<octave_value_list> next_idx (idx);
+
+          next_idx.erase (next_idx.begin ());
+
+          octave_value tmp = obj.subsasgn (type.substr (1), next_idx,
+                                           rhs, ignore_copies);
+
+          cdef_object robj = to_cdef (tmp);
+
+          if (robj.ok ()
+              && ! robj.is_array ()
+              && robj.get_class () == get_class ())
             {
-              Array<cdef_object> a = array.index (iv, true);
-
-              if (a.numel () != 1)
-                error ("subsasgn: invalid indexing for object array "
-                       "assignment");
-
-              if (! error_state)
+              // Small optimization, when dealing with handle
+              // objects, we don't need to re-assign the result
+              // of subsasgn back into the array.
+
+              if (! robj.is (a(0)))
                 {
-                  cdef_object obj = a(0);
-
-                  int ignore_copies = 0;
-
-                  // If the object in 'a' is not valid, this means the index
-                  // was out-of-bound and we need to create a new object.
-
-                  if (! obj.ok ())
-                    obj = get_class ().construct_object (octave_value_list ());
-                  else
-                    // Optimize the subsasgn call to come. There are 2 copies
-                    // that we can safely ignore:
-                    // - 1 in "array"
-                    // - 1 in "a"
-                    ignore_copies = 2;
-
-                  std::list<octave_value_list> next_idx (idx);
-
-                  next_idx.erase (next_idx.begin ());
-
-                  octave_value tmp = obj.subsasgn (type.substr (1), next_idx,
-                                                   rhs, ignore_copies);
-
-                  if (! error_state)
-                    {
-                      cdef_object robj = to_cdef (tmp);
-
-                      if (robj.ok ()
-                          && ! robj.is_array ()
-                          && robj.get_class () == get_class ())
-                        {
-                          // Small optimization, when dealing with handle
-                          // objects, we don't need to re-assign the result
-                          // of subsasgn back into the array.
-
-                          if (! robj.is (a(0)))
-                            {
-                              Array<cdef_object> rhs_a (dim_vector (1, 1),
-                                                        robj);
-
-                              octave_idx_type n = array.numel ();
-
-                              array.assign (iv, rhs_a);
-
-                              if (array.numel () > n)
-                                fill_empty_values ();
-                            }
-
-                          refcount++;
-
-                          retval = to_ov (cdef_object (this));
-                        }
-                      else
-                        error ("subasgn: invalid assignment into array of %s "
-                               "objects", class_name ().c_str ());
-                    }
+                  Array<cdef_object> rhs_a (dim_vector (1, 1),
+                                            robj);
+
+                  octave_idx_type n = array.numel ();
+
+                  array.assign (iv, rhs_a);
+
+                  if (array.numel () > n)
+                    fill_empty_values ();
                 }
+
+              refcount++;
+
+              retval = to_ov (cdef_object (this));
             }
+          else
+            error ("subasgn: invalid assignment into array of %s "
+                   "objects", class_name ().c_str ());
         }
       break;
 
     default:
       error ("can't perform indexing operation on array of %s objects",
              class_name ().c_str ());
       break;
     }
@@ -1917,36 +1818,32 @@ cdef_object_array::subsasgn (const std::
   return retval;
 }
 
 void
 cdef_object_array::fill_empty_values (Array<cdef_object>& arr)
 {
   cdef_class cls = get_class ();
 
-  if (! error_state)
+  cdef_object obj;
+
+  int n = arr.numel ();
+
+  for (int i = 0; i < n; i++)
     {
-      cdef_object obj;
-
-      int n = arr.numel ();
-
-      for (int i = 0; ! error_state && i < n; i++)
+      if (! arr.xelem (i).ok ())
         {
-          if (! arr.xelem (i).ok ())
+          if (! obj.ok ())
             {
-              if (! obj.ok ())
-                {
-                  obj = cls.construct_object (octave_value_list ());
-
-                  if (! error_state)
-                    arr.xelem (i) = obj;
-                }
-              else
-                arr.xelem (i) = obj.copy ();
+              obj = cls.construct_object (octave_value_list ());
+
+              arr.xelem (i) = obj;
             }
+          else
+            arr.xelem (i) = obj.copy ();
         }
     }
 }
 
 bool
 cdef_object_scalar::is_constructed_for (const cdef_class& cls) const
 {
   return (is_constructed ()
@@ -2027,39 +1924,36 @@ cdef_class::cdef_class_rep::find_method 
       // Look into superclasses
 
       Cell super_classes = get ("SuperClasses").cell_value ();
 
       for (int i = 0; i < super_classes.numel (); i++)
         {
           cdef_class cls = lookup_class (super_classes(i));
 
-          if (! error_state)
-            {
-              cdef_method meth = cls.find_method (nm);
-
-              if (meth.ok ())
-                return meth;
-            }
+          cdef_method meth = cls.find_method (nm);
+
+          if (meth.ok ())
+            return meth;
         }
     }
 
   return cdef_method ();
 }
 
 class ctor_analyzer : public tree_walker
 {
 public:
   ctor_analyzer (const std::string& ctor, const std::string& obj)
     : tree_walker (), who (ctor), obj_name (obj) { }
 
   void visit_statement_list (tree_statement_list& t)
   {
     for (tree_statement_list::const_iterator it = t.begin ();
-         ! error_state && it != t.end (); ++it)
+         it != t.end (); ++it)
       (*it)->accept (*this);
   }
 
   void visit_statement (tree_statement& t)
   {
     if (t.is_expression ())
       t.expression ()->accept (*this);
   }
@@ -2183,33 +2077,31 @@ cdef_class::cdef_class_rep::install_meth
               tree_statement_list *body = uf->body ();
 
               if (ret_list && ret_list->size () == 1)
                 {
                   std::string obj_name = ret_list->front ()->name ();
                   ctor_analyzer a (meth.get_name (), obj_name);
 
                   body->accept (a);
-                  if (! error_state)
+
+                  std::list<cdef_class> explicit_ctor_list
+                    = a.get_constructor_list ();
+
+                  for (std::list<cdef_class>::const_iterator
+                         it = explicit_ctor_list.begin ();
+                       it != explicit_ctor_list.end ();
+                       ++it)
                     {
-                      std::list<cdef_class> explicit_ctor_list
-                        = a.get_constructor_list ();
-
-                      for (std::list<cdef_class>::const_iterator
-                           it = explicit_ctor_list.begin ();
-                           ! error_state && it != explicit_ctor_list.end ();
-                           ++it)
-                        {
 #if DEBUG_TRACE
-                          std::cerr << "explicit superclass constructor: "
-                                    << it->get_name () << std::endl;
+                      std::cerr << "explicit superclass constructor: "
+                                << it->get_name () << std::endl;
 #endif
 
-                          implicit_ctor_list.remove (*it);
-                        }
+                      implicit_ctor_list.remove (*it);
                     }
                 }
               else
                 error ("%s: invalid constructor output arguments",
                        meth.get_name ().c_str ());
             }
         }
     }
@@ -2223,30 +2115,25 @@ cdef_class::cdef_class_rep::load_all_met
 
 Cell
 cdef_class::cdef_class_rep::get_methods (void)
 {
   std::map<std::string,cdef_method> meths;
 
   find_methods (meths, false);
 
-  if (! error_state)
-    {
-      Cell c (meths.size (), 1);
-
-      int idx = 0;
-
-      for (std::map<std::string,cdef_method>::const_iterator
-            it = meths.begin (); it != meths.end (); ++it, ++idx)
-        c (idx, 0) = to_ov (it->second);
-
-      return c;
-    }
-
-  return Cell ();
+  Cell c (meths.size (), 1);
+
+  int idx = 0;
+
+  for (std::map<std::string,cdef_method>::const_iterator
+         it = meths.begin (); it != meths.end (); ++it, ++idx)
+    c (idx, 0) = to_ov (it->second);
+
+  return c;
 }
 
 void
 cdef_class::cdef_class_rep::find_methods (std::map<std::string,
                                           cdef_method>& meths,
                                           bool only_inherited)
 {
   load_all_methods ();
@@ -2278,20 +2165,17 @@ cdef_class::cdef_class_rep::find_methods
   // Look into superclasses
 
   Cell super_classes = get ("SuperClasses").cell_value ();
 
   for (int i = 0; i < super_classes.numel (); i++)
     {
       cdef_class cls = lookup_class (super_classes(i));
 
-      if (! error_state)
-        cls.get_rep ()->find_methods (meths, true);
-      else
-        break;
+      cls.get_rep ()->find_methods (meths, true);
     }
 }
 
 cdef_property
 cdef_class::cdef_class_rep::find_property (const std::string& nm)
 {
   property_iterator it = property_map.find (nm);
 
@@ -2306,23 +2190,20 @@ cdef_class::cdef_class_rep::find_propert
   // Look into superclasses
 
   Cell super_classes = get ("SuperClasses").cell_value ();
 
   for (int i = 0; i < super_classes.numel (); i++)
     {
       cdef_class cls = lookup_class (super_classes(i));
 
-      if (! error_state)
-        {
-          cdef_property prop = cls.find_property (nm);
-
-          if (prop.ok ())
-            return prop;
-        }
+      cdef_property prop = cls.find_property (nm);
+
+      if (prop.ok ())
+        return prop;
     }
 
   return cdef_property ();
 }
 
 void
 cdef_class::cdef_class_rep::install_property (const cdef_property& prop)
 {
@@ -2333,30 +2214,25 @@ cdef_class::cdef_class_rep::install_prop
 
 Cell
 cdef_class::cdef_class_rep::get_properties (int mode)
 {
   std::map<std::string,cdef_property> props;
 
   props = get_property_map (mode);
 
-  if (! error_state)
-    {
-      Cell c (props.size (), 1);
-
-      int idx = 0;
-
-      for (std::map<std::string,cdef_property>::const_iterator
-            it = props.begin (); it != props.end (); ++it, ++idx)
-        c (idx, 0) = to_ov (it->second);
-
-      return c;
-    }
-
-  return Cell ();
+  Cell c (props.size (), 1);
+
+  int idx = 0;
+
+  for (std::map<std::string,cdef_property>::const_iterator
+         it = props.begin (); it != props.end (); ++it, ++idx)
+    c (idx, 0) = to_ov (it->second);
+
+  return c;
 }
 
 std::map<std::string, cdef_property>
 cdef_class::cdef_class_rep::get_property_map (int mode)
 {
   std::map<std::string,cdef_property> props;
 
   find_properties (props, mode);
@@ -2366,18 +2242,17 @@ cdef_class::cdef_class_rep::get_property
 
 void
 cdef_class::cdef_class_rep::find_properties (std::map<std::string,
                                              cdef_property>& props,
                                              int mode)
 {
   property_const_iterator it;
 
-  for (it = property_map.begin (); ! error_state && it != property_map.end ();
-       ++it)
+  for (it = property_map.begin (); it != property_map.end (); ++it)
     {
       std::string nm = it->second.get_name ();
 
       if (props.find (nm) == props.end ())
         {
           if (mode == property_inherited)
             {
               octave_value acc = it->second.get ("GetAccess");
@@ -2390,38 +2265,35 @@ cdef_class::cdef_class_rep::find_propert
           props[nm] = it->second;
         }
     }
 
   // Look into superclasses
 
   Cell super_classes = get ("SuperClasses").cell_value ();
 
-  for (int i = 0; ! error_state && i < super_classes.numel (); i++)
+  for (int i = 0; i < super_classes.numel (); i++)
     {
       cdef_class cls = lookup_class (super_classes(i));
 
-      if (! error_state)
-        cls.get_rep ()->find_properties (props,
-                                         (mode == property_all ?
-                                          property_all :
-                                          property_inherited));
-      else
-        break;
+      cls.get_rep ()->find_properties (props,
+                                       (mode == property_all
+                                        ? property_all
+                                        : property_inherited));
     }
 }
 
 void
 cdef_class::cdef_class_rep::find_names (std::set<std::string>& names,
                                         bool all)
 {
   load_all_methods ();
 
   for (method_const_iterator it = method_map.begin ();
-       ! error_state && it != method_map.end(); ++it)
+       it != method_map.end(); ++it)
     {
       if (! it->second.is_constructor ())
         {
           std::string nm = it->second.get_name ();
 
           if (! all)
             {
               octave_value acc = it->second.get ("Access");
@@ -2431,17 +2303,17 @@ cdef_class::cdef_class_rep::find_names (
                 continue;
             }
 
           names.insert (nm);
         }
     }
 
   for (property_const_iterator it = property_map.begin ();
-       ! error_state && it != property_map.end (); ++it)
+       it != property_map.end (); ++it)
     {
       std::string nm = it->second.get_name ();
 
       if (! all)
         {
           octave_value acc = it->second.get ("GetAccess");
 
           if (! acc.is_string()
@@ -2451,47 +2323,39 @@ cdef_class::cdef_class_rep::find_names (
 
       names.insert (nm);
     }
 
   // Look into superclasses
 
   Cell super_classes = get ("SuperClasses").cell_value ();
 
-  for (int i = 0; ! error_state && i < super_classes.numel (); i++)
+  for (int i = 0; i < super_classes.numel (); i++)
     {
       cdef_class cls = lookup_class (super_classes(i));
 
-      if (! error_state)
-        cls.get_rep ()->find_names (names, all);
-      else
-        break;
+      cls.get_rep ()->find_names (names, all);
     }
 }
 
 string_vector
 cdef_class::cdef_class_rep::get_names (void)
 {
   std::set<std::string> names;
 
   find_names (names, false);
 
-  if (! error_state)
-    {
-      string_vector v (names.size ());
-
-      int idx = 0;
-      for (std::set<std::string>::const_iterator it = names.begin ();
-           it != names.end (); ++it, ++idx)
-        v[idx] = *it;
-
-      return v.sort (true);
-    }
-
-  return string_vector ();
+  string_vector v (names.size ());
+
+  int idx = 0;
+  for (std::set<std::string>::const_iterator it = names.begin ();
+       it != names.end (); ++it, ++idx)
+    v[idx] = *it;
+
+  return v.sort (true);
 }
 
 void
 cdef_class::cdef_class_rep::delete_object (cdef_object obj)
 {
   method_iterator it = method_map.find ("delete");
 
   if (it != method_map.end ())
@@ -2510,18 +2374,17 @@ cdef_class::cdef_class_rep::delete_objec
   // Call "delete" in super classes
 
   Cell super_classes = get ("SuperClasses").cell_value ();
 
   for (int i = 0; i < super_classes.numel (); i++)
     {
       cdef_class cls = lookup_class (super_classes(i));
 
-      if (!error_state)
-        cls.delete_object (obj);
+      cls.delete_object (obj);
     }
 }
 
 octave_value_list
 cdef_class::cdef_class_rep::meta_subsref (const std::string& type,
                                           const std::list<octave_value_list>& idx,
                                           int nargout)
 {
@@ -2598,21 +2461,18 @@ cdef_class::cdef_class_rep::meta_subsref
         error ("invalid meta.class indexing");
       break;
 
     default:
       error ("invalid meta.class indexing");
       break;
     }
 
-  if (! error_state)
-    {
-      if (type.length () > skip && idx.size () > skip && ! retval.empty ())
-        retval = retval(0).next_subsref (nargout, type, idx, skip);
-    }
+  if (type.length () > skip && idx.size () > skip && ! retval.empty ())
+    retval = retval(0).next_subsref (nargout, type, idx, skip);
 
   return retval;
 }
 
 void
 cdef_class::cdef_class_rep::meta_release (void)
 {
   cdef_manager::unregister_class (wrap ());
@@ -2621,100 +2481,84 @@ cdef_class::cdef_class_rep::meta_release
 void
 cdef_class::cdef_class_rep::initialize_object (cdef_object& obj)
 {
   // Populate the object with default property values
 
   std::list<cdef_class> super_classes = lookup_classes (
                                           get ("SuperClasses").cell_value ());
 
-  if (! error_state)
+  for (std::list<cdef_class>::iterator it = super_classes.begin ();
+       it != super_classes.end (); ++it)
+    it->initialize_object (obj);
+
+  for (property_const_iterator it = property_map.begin ();
+       it != property_map.end (); ++it)
     {
-      for (std::list<cdef_class>::iterator it = super_classes.begin ();
-           ! error_state && it != super_classes.end (); ++it)
-        it->initialize_object (obj);
-
-      if (! error_state)
+      if (! it->second.get ("Dependent").bool_value ())
         {
-          for (property_const_iterator it = property_map.begin ();
-               ! error_state && it != property_map.end (); ++it)
-            {
-              if (! it->second.get ("Dependent").bool_value ())
-                {
-                  octave_value pvalue = it->second.get ("DefaultValue");
-
-                  if (pvalue.is_defined ())
-                    obj.put (it->first, pvalue);
-                  else
-                    obj.put (it->first, octave_value (Matrix ()));
-                }
-            }
-
-          if (! error_state)
-            {
-              refcount++;
-              obj.mark_for_construction (cdef_class (this));
-            }
+          octave_value pvalue = it->second.get ("DefaultValue");
+
+          if (pvalue.is_defined ())
+            obj.put (it->first, pvalue);
+          else
+            obj.put (it->first, octave_value (Matrix ()));
         }
     }
+
+  refcount++;
+  obj.mark_for_construction (cdef_class (this));
 }
 
 void
 cdef_class::cdef_class_rep::run_constructor (cdef_object& obj,
                                              const octave_value_list& args)
 {
   octave_value_list empty_args;
 
   for (std::list<cdef_class>::const_iterator it = implicit_ctor_list.begin ();
-       ! error_state && it != implicit_ctor_list.end (); ++it)
+       it != implicit_ctor_list.end (); ++it)
     {
       cdef_class supcls = lookup_class (*it);
 
-      if (! error_state)
-        supcls.run_constructor (obj, empty_args);
+      supcls.run_constructor (obj, empty_args);
     }
 
-  if (error_state)
-    return;
-
   std::string cls_name = get_name ();
   std::string ctor_name = get_base_name (cls_name);
 
   cdef_method ctor = find_method (ctor_name);
 
   if (ctor.ok ())
     {
       octave_value_list ctor_args (args);
       octave_value_list ctor_retval;
 
       ctor_args.prepend (to_ov (obj));
       ctor_retval = ctor.execute (ctor_args, 1, true, "constructor");
 
-      if (! error_state)
+      if (ctor_retval.length () == 1)
+        obj = to_cdef (ctor_retval(0));
+      else
         {
-          if (ctor_retval.length () == 1)
-            obj = to_cdef (ctor_retval(0));
-          else
-            {
-              error ("%s: invalid number of output arguments for classdef constructor",
-                     ctor_name.c_str ());
-              return;
-            }
+          error ("%s: invalid number of output arguments for classdef constructor",
+                 ctor_name.c_str ());
+          return;
         }
     }
 
   obj.mark_as_constructed (wrap ());
 }
 
 octave_value
 cdef_class::cdef_class_rep::construct (const octave_value_list& args)
 {
   cdef_object obj = construct_object (args);
 
-  if (! error_state && obj.ok ())
+  if (obj.ok ())
     return to_ov (obj);
 
   return octave_value ();
 }
 
 cdef_object
 cdef_class::cdef_class_rep::construct_object (const octave_value_list& args)
 {
@@ -2775,23 +2619,19 @@ cdef_class::cdef_class_rep::construct_ob
           if (is_handle_class ())
             obj = cdef_object (new handle_cdef_object ());
           else
             obj = cdef_object (new value_cdef_object ());
           obj.set_class (wrap ());
 
           initialize_object (obj);
 
-          if (! error_state)
-            {
-              run_constructor (obj, args);
-
-              if (! error_state)
-                return obj;
-            }
+          run_constructor (obj, args);
+
+          return obj;
         }
     }
   else
     error ("cannot instantiate object for abstract class `%s'",
            get_name ().c_str ());
 
   return cdef_object ();
 }
@@ -2848,55 +2688,47 @@ cdef_class::make_meta_class (tree_classd
 #endif
 
   std::list<cdef_class> slist;
 
   if (t->superclass_list ())
     {
       for (tree_classdef_superclass_list::iterator it =
              t->superclass_list ()->begin ();
-           ! error_state && it != t->superclass_list ()->end (); ++it)
+           it != t->superclass_list ()->end (); ++it)
         {
           std::string sclass_name = (*it)->class_name ();
 
 #if DEBUG_TRACE
           std::cerr << "superclass: " << sclass_name << std::endl;
 #endif
 
           cdef_class sclass = lookup_class (sclass_name);
 
-          if (! error_state)
+          if (! sclass.get ("Sealed").bool_value ())
+            slist.push_back (sclass);
+          else
             {
-              if (! sclass.get ("Sealed").bool_value ())
-                slist.push_back (sclass);
-              else
-                {
-                  error ("`%s' cannot inherit from `%s', because it is sealed",
-                         full_class_name.c_str (), sclass_name.c_str ());
-                  return retval;
-                }
+              error ("`%s' cannot inherit from `%s', because it is sealed",
+                     full_class_name.c_str (), sclass_name.c_str ());
+              return retval;
             }
-          else
-            return retval;
 
         }
     }
 
   retval = ::make_class (full_class_name, slist);
 
-  if (error_state)
-    return cdef_class ();
-
   // Package owning this class
 
   if (! t->package_name ().empty ())
     {
       cdef_package pack = cdef_manager::find_package (t->package_name ());
 
-      if (! error_state && pack.ok ())
+      if (pack.ok ())
         retval.put ("ContainingPackage", to_ov (pack));
     }
 
   // Class attributes
 
   if (t->attribute_list ())
     {
       for (tree_classdef_attribute_list::iterator
@@ -3197,18 +3029,17 @@ cdef_property::cdef_property_rep::get_va
   else
     {
       octave_value_list args;
 
       args(0) = to_ov (obj);
 
       args = execute_ov (get_fcn, args, 1);
 
-      if (! error_state)
-        retval = args(0);
+      retval = args(0);
     }
 
   return retval;
 }
 
 octave_value
 cdef_property::cdef_property_rep::get_value (bool do_check_access,
                                              const std::string& who)
@@ -3263,55 +3094,49 @@ cdef_property::cdef_property_rep::set_va
     {
       octave_value_list args;
 
       args(0) = to_ov (obj);
       args(1) = val;
 
       args = execute_ov (set_fcn, args, 1);
 
-      if (! error_state)
+      if (args.length () > 0 && args(0).is_defined ())
         {
-          if (args.length () > 0 && args(0).is_defined ())
+          if (args (0).is_classdef_object ())
             {
-              if (args (0).is_classdef_object ())
-                {
-                  cdef_object new_obj = to_cdef (args(0));
-
-                  if (! error_state)
-                    obj = new_obj;
-                }
-              else
-                ::warning ("set-method of property `%s' returned a non-classdef object",
-                           get_name ().c_str ());
+              cdef_object new_obj = to_cdef (args(0));
+
+              obj = new_obj;
             }
+          else
+            ::warning ("set-method of property `%s' returned a non-classdef object",
+                       get_name ().c_str ());
         }
     }
 }
 
 bool
 cdef_property::cdef_property_rep::check_get_access (void) const
 {
   cdef_class cls (to_cdef (get ("DefiningClass")));
 
-  if (! error_state)
-    return ::check_access (cls, get ("GetAccess"), std::string (),
-                           get_name (), false);
+  return ::check_access (cls, get ("GetAccess"), std::string (),
+                         get_name (), false);
 
   return false;
 }
 
 bool
 cdef_property::cdef_property_rep::check_set_access (void) const
 {
   cdef_class cls (to_cdef (get ("DefiningClass")));
 
-  if (! error_state)
-    return ::check_access (cls, get ("SetAccess"), std::string (),
-                           get_name (), true);
+  return ::check_access (cls, get ("SetAccess"), std::string (),
+                         get_name (), true);
 
   return false;
 }
 
 void
 cdef_method::cdef_method_rep::check_method (void)
 {
   if (is_external ())
@@ -3372,20 +3197,18 @@ cdef_method::cdef_method_rep::execute (c
 
       return retval;
     }
 
   if (! get ("Abstract").bool_value ())
     {
       check_method ();
 
-      if (! error_state && function.is_defined ())
-        {
-          retval = execute_ov (function, args, nargout);
-        }
+      if (function.is_defined ())
+        retval = execute_ov (function, args, nargout);
     }
   else
     error ("%s: cannot execute abstract method",
            get ("Name").string_value ().c_str ());
 
   return retval;
 }
 
@@ -3403,17 +3226,17 @@ cdef_method::cdef_method_rep::execute (c
 
       return retval;
     }
 
   if (! get ("Abstract").bool_value ())
     {
       check_method ();
 
-      if (! error_state && function.is_defined ())
+      if (function.is_defined ())
         {
           octave_value_list new_args;
 
           new_args.resize (args.length () + 1);
 
           new_args(0) = to_ov (obj);
           for (int i = 0; i < args.length (); i++)
             new_args(i+1) = args(i);
@@ -3437,20 +3260,17 @@ cdef_method::cdef_method_rep::is_constru
   return false;
 }
 
 bool
 cdef_method::cdef_method_rep::check_access (void) const
 {
   cdef_class cls (to_cdef (get ("DefiningClass")));
 
-  if (! error_state)
-    return ::check_access (cls, get ("Access"), get_name ());
-
-  return false;
+  return ::check_access (cls, get ("Access"), get_name ());
 }
 
 octave_value_list
 cdef_method::cdef_method_rep::meta_subsref
   (const std::string& type, const std::list<octave_value_list>& idx,
    int nargout)
 {
   octave_value_list retval;
@@ -3461,21 +3281,18 @@ cdef_method::cdef_method_rep::meta_subsr
       retval = execute (idx.front (), type.length () > 1 ? 1 : nargout, true);
       break;
 
     default:
       error ("invalid meta.method indexing");
       break;
     }
 
-  if (! error_state)
-    {
-      if (type.length () > 1 && idx.size () > 1 && ! retval.empty ())
-        retval = retval(0).next_subsref (nargout, type, idx, 1);
-    }
+  if (type.length () > 1 && idx.size () > 1 && ! retval.empty ())
+    retval = retval(0).next_subsref (nargout, type, idx, 1);
 
   return retval;
 }
 
 static cdef_package
 lookup_package (const std::string& name)
 {
   return cdef_manager::find_package (name);
@@ -3659,39 +3476,36 @@ cdef_package::cdef_package_rep::meta_sub
               octave_value o = find (nm);
 
               if (o.is_defined ())
                 {
                   if (o.is_function ())
                     {
                       octave_function* fcn = o.function_value ();
 
-                      if (! error_state)
+                      // NOTE: the case where the package query is the last
+                      // part of this subsref index is handled in the parse
+                      // tree, because there is some logic to handle magic
+                      // "end" that makes it impossible to execute the
+                      // function call at this stage.
+
+                      if (type.size () > 1
+                          && ! fcn->is_postfix_index_handled (type[1]))
                         {
-                          // NOTE: the case where the package query is the last
-                          // part of this subsref index is handled in the parse
-                          // tree, because there is some logic to handle magic
-                          // "end" that makes it impossible to execute the
-                          // function call at this stage.
-
-                          if (type.size () > 1
-                              && ! fcn->is_postfix_index_handled (type[1]))
-                            {
-                              octave_value_list tmp_args;
-
-                              retval = o.do_multi_index_op (nargout,
-                                                            tmp_args);
-                            }
-                          else
-                            retval(0) = o;
-
-                          if (type.size () > 1 && idx.size () > 1)
-                            retval = retval(0).next_subsref (nargout, type,
-                                                             idx, 1);
+                          octave_value_list tmp_args;
+
+                          retval = o.do_multi_index_op (nargout,
+                                                        tmp_args);
                         }
+                      else
+                        retval(0) = o;
+
+                      if (type.size () > 1 && idx.size () > 1)
+                        retval = retval(0).next_subsref (nargout, type,
+                                                         idx, 1);
                     }
                   else if (type.size () > 1 && idx.size () > 1)
                     retval = o.next_subsref (nargout, type, idx, 1);
                   else
                     retval(0) = o;
                 }
               else if (! error_state)
                 error ("member `%s' in package `%s' does not exist",
