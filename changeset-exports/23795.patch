# HG changeset patch
# User Rik <rik@octave.org>
# Date 1501019650 25200
#      Tue Jul 25 14:54:10 2017 -0700
# Node ID 980f39c3ab90dd169f17691467d663fd625d22e4
# Parent  7a10975104393614b0c273fa3f3c854a2f2065e9
Use C++11 nullptr rather than 0 in code (bug #51565).

* Backend.cc, BaseControl.h, ButtonGroup.cc, CheckBoxControl.cc,
Container.cc, ContextMenu.cc, ContextMenu.h, EditControl.cc, Figure.cc,
FigureWindow.cc, ListBoxControl.cc, Menu.cc, Menu.h, MouseModeActionGroup.cc,
Object.cc, ObjectProxy.cc, Panel.cc, PopupMenuControl.cc, PushButtonControl.cc,
PushTool.cc, RadioButtonControl.cc, SliderControl.cc, TextControl.cc,
ToggleButtonControl.cc, ToggleTool.cc, ToolBar.cc, ToolBar.h, ToolBarButton.cc,
ToolBarButton.h, QTerminal.h, BlockArray.cpp, Emulation.cpp, Filter.cpp,
Filter.h, History.cpp, KeyboardTranslator.cpp, QUnixTerminalImpl.h, Screen.cpp,
ScreenWindow.cpp, ScreenWindow.h, SelfListener.h, TerminalCharacterDecoder.cpp,
TerminalModel.cpp, TerminalView.cpp, TerminalView.h, kpty.cpp, dialog.cc,
dialog.h, files-dock-widget.cc, find-files-model.h, file-editor-tab.cc,
file-editor.cc, main-window.cc, octave-dock-widget.cc, octave-gui.cc,
parser.cc, resource-manager.cc, resource-manager.h, shortcut-manager.cc,
shortcut-manager.h, workspace-model.cc, workspace-view.cc, __magick_read__.cc,
c-file-ptr-stream.cc, c-file-ptr-stream.h, call-stack.cc, call-stack.h,
daspk.cc, dasrt.cc, dassl.cc, det.cc, display.h, error.cc, ft-text-renderer.cc,
gl-render.cc, gl2ps-print.cc, graphics.in.h, help.cc, input.cc, interpreter.cc,
load-path.cc, load-save.cc, ls-hdf5.cc, ls-hdf5.h, ls-mat5.cc, lsode.cc,
mex.cc, mxarray.in.h, oct-errno.h, oct-hist.cc, oct-iostrm.h, oct-procbuf.cc,
oct-procbuf.h, oct-stdstrm.h, oct-stream.cc, oct-stream.h, oct-strstrm.h,
oct-tex-parser.in.yy, octave-link.h, pager.cc, pager.h, pr-output.cc,
procstream.h, qz.cc, sighandlers.cc, svd.cc, symtab.cc, symtab.h,
text-renderer.cc, txt-eng.h, utils.cc, variables.cc, zfstream.cc, zfstream.h,
__glpk__.cc, __init_fltk__.cc, __ode15__.cc, audiodevinfo.cc, ccolamd.cc,
colamd.cc, dmperm.cc, gzip.cc, symbfact.cc, ov-base-int.cc, ov-base-int.h,
ov-base-mat.h, ov-base.cc, ov-base.h, ov-bool-mat.cc, ov-bool-sparse.cc,
ov-bool.cc, ov-builtin.h, ov-cell.cc, ov-class.cc, ov-complex.cc, ov-cx-mat.cc,
ov-cx-sparse.cc, ov-fcn-handle.cc, ov-fcn-inline.cc, ov-fcn.cc, ov-fcn.h,
ov-float.cc, ov-flt-complex.cc, ov-flt-cx-mat.cc, ov-flt-re-mat.cc, ov-java.cc,
ov-java.h, ov-mex-fcn.cc, ov-oncleanup.cc, ov-range.cc, ov-range.h,
ov-re-mat.cc, ov-re-sparse.cc, ov-scalar.cc, ov-str-mat.cc, ov-typeinfo.cc,
ov-typeinfo.h, ov-usr-fcn.cc, ov-usr-fcn.h, ov.cc, octave.cc, bp-table.cc,
bp-table.h, jit-ir.h, jit-typeinfo.cc, lex.h, profiler.cc, pt-arg-list.cc,
pt-array-list.cc, pt-assign.cc, pt-assign.h, pt-binop.cc, pt-binop.h,
pt-cell.cc, pt-classdef.cc, pt-classdef.h, pt-colon.cc, pt-colon.h, pt-decl.cc,
pt-decl.h, pt-eval.cc, pt-eval.h, pt-except.h, pt-fcn-handle.cc,
pt-fcn-handle.h, pt-idx.cc, pt-jit.cc, pt-loop.h, pt-mat.cc, pt-select.h,
pt-stmt.h, pt-tm-const.h, pt-unop.cc, pt-unop.h, pt.cc, Array-C.cc, Array-d.cc,
Array-f.cc, Array-fC.cc, Array-util.cc, Array.cc, Array.h, CMatrix.cc,
CSparse.cc, DiagArray2.h, MArray.h, MDiagArray2.h, MatrixType.cc, Sparse.cc,
Sparse.h, dMatrix.cc, dSparse.cc, fMatrix.cc, idx-vector.cc, idx-vector.h,
DAEFunc.h, DAERTFunc.h, ODEFunc.h, ODESFunc.h, eigs-base.cc, oct-fftw.cc,
oct-fftw.h, oct-rand.h, oct-spparms.h, schur.cc, sparse-chol.cc,
sparse-dmsolve.cc, sparse-lu.cc, sparse-qr.cc, child-list.h, dir-ops.cc,
dir-ops.h, file-ops.cc, lo-sysdep.cc, oct-env.h, oct-time.cc, cmd-edit.cc,
cmd-edit.h, cmd-hist.h, lo-regexp.cc, lo-regexp.h, lo-utils.cc, oct-shlib.cc,
oct-shlib.h, oct-sort.cc, oct-sort.h, quit.cc, singleton-cleanup.h, str-vec.cc:
Use C++11 nullptr rather than 0 in code (bug #51565).

diff --git a/libgui/graphics/Backend.cc b/libgui/graphics/Backend.cc
--- a/libgui/graphics/Backend.cc
+++ b/libgui/graphics/Backend.cc
@@ -214,17 +214,17 @@ namespace QtHandles
   Object*
   Backend::toolkitObject (const graphics_object& go)
   {
     ObjectProxy *proxy = toolkitObjectProxy (go);
 
     if (proxy)
       return proxy->object ();
 
-    return 0;
+    return nullptr;
   }
 
   ObjectProxy*
   Backend::toolkitObjectProxy (const graphics_object& go)
   {
     if (go)
       {
         octave_value ov = go.get (toolkitObjectProperty (go));
@@ -232,12 +232,12 @@ namespace QtHandles
         if (ov.is_defined () && ! ov.isempty ())
           {
             OCTAVE_INTPTR_TYPE ptr = ov.OCTAVE_PTR_SCALAR ().value ();
 
             return reinterpret_cast<ObjectProxy *> (ptr);
           }
       }
 
-    return 0;
+    return nullptr;
   }
 
 };
diff --git a/libgui/graphics/BaseControl.h b/libgui/graphics/BaseControl.h
--- a/libgui/graphics/BaseControl.h
+++ b/libgui/graphics/BaseControl.h
@@ -32,17 +32,17 @@ namespace QtHandles
 {
 
   class BaseControl : public Object
   {
   public:
     BaseControl (const graphics_object& go, QWidget *w);
     ~BaseControl (void);
 
-    Container * innerContainer (void) { return 0; }
+    Container * innerContainer (void) { return nullptr; }
 
     bool eventFilter (QObject *watched, QEvent *e);
 
   protected:
     void init (QWidget *w, bool callBase = false);
     void update (int pId);
 
   private:
diff --git a/libgui/graphics/ButtonGroup.cc b/libgui/graphics/ButtonGroup.cc
--- a/libgui/graphics/ButtonGroup.cc
+++ b/libgui/graphics/ButtonGroup.cc
@@ -103,23 +103,23 @@ namespace QtHandles
 
         if (container)
           {
             QFrame *frame = new QFrame (container);
             return new ButtonGroup (go, new QButtonGroup (frame), frame);
           }
       }
 
-    return 0;
+    return nullptr;
   }
 
   ButtonGroup::ButtonGroup (const graphics_object& go, QButtonGroup *buttongroup,
                             QFrame *frame)
-    : Object (go, frame), m_hiddenbutton(0), m_container (0), m_title (0),
-      m_blockUpdates (false)
+    : Object (go, frame), m_hiddenbutton(nullptr), m_container (nullptr),
+      m_title (nullptr), m_blockUpdates (false)
   {
     uibuttongroup::properties& pp = properties<uibuttongroup> ();
 
     frame->setObjectName ("UIButtonGroup");
     frame->setAutoFillBackground (true);
     Matrix bb = pp.get_boundingbox (false);
     frame->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
                         octave::math::round (bb(2)), octave::math::round (bb(3)));
@@ -288,17 +288,17 @@ namespace QtHandles
       case uibuttongroup::properties::ID_TITLE:
         {
           QString title = Utils::fromStdString (pp.get_title ());
 
           if (title.isEmpty ())
             {
               if (m_title)
                 delete m_title;
-              m_title = 0;
+              m_title = nullptr;
             }
           else
             {
               if (! m_title)
                 {
                   QPalette pal = frame->palette ();
 
                   m_title = new QLabel (title, frame);
diff --git a/libgui/graphics/CheckBoxControl.cc b/libgui/graphics/CheckBoxControl.cc
--- a/libgui/graphics/CheckBoxControl.cc
+++ b/libgui/graphics/CheckBoxControl.cc
@@ -40,17 +40,17 @@ namespace QtHandles
     if (parent)
       {
         Container *container = parent->innerContainer ();
 
         if (container)
           return new CheckBoxControl (go, new QCheckBox (container));
       }
 
-    return 0;
+    return nullptr;
   }
 
   CheckBoxControl::CheckBoxControl (const graphics_object& go, QCheckBox *box)
     : ButtonControl (go, box)
   {
     box->setAutoFillBackground (true);
   }
 
diff --git a/libgui/graphics/Container.cc b/libgui/graphics/Container.cc
--- a/libgui/graphics/Container.cc
+++ b/libgui/graphics/Container.cc
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 #include "Container.h"
 #include "Object.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
   Container::Container (QWidget *xparent)
-    : ContainerBase (xparent), m_canvas (0)
+    : ContainerBase (xparent), m_canvas (nullptr)
   {
     setFocusPolicy (Qt::ClickFocus);
   }
 
   Container::~Container (void)
   { }
 
   Canvas*
diff --git a/libgui/graphics/ContextMenu.cc b/libgui/graphics/ContextMenu.cc
--- a/libgui/graphics/ContextMenu.cc
+++ b/libgui/graphics/ContextMenu.cc
@@ -40,17 +40,17 @@ namespace QtHandles
 
     if (xparent)
       {
         QWidget *w = xparent->qWidget<QWidget> ();
 
         return new ContextMenu (go, new QMenu (w));
       }
 
-    return 0;
+    return nullptr;
   }
 
   ContextMenu::ContextMenu (const graphics_object& go, QMenu *xmenu)
     : Object (go, xmenu)
   {
     xmenu->setAutoFillBackground (true);
 
     connect (xmenu, SIGNAL (aboutToShow (void)), SLOT (aboutToShow (void)));
diff --git a/libgui/graphics/ContextMenu.h b/libgui/graphics/ContextMenu.h
--- a/libgui/graphics/ContextMenu.h
+++ b/libgui/graphics/ContextMenu.h
@@ -39,17 +39,17 @@ namespace QtHandles
 
   public:
     ContextMenu (const graphics_object& go, QMenu *menu);
     ~ContextMenu (void);
 
     static ContextMenu * create (const graphics_object& go);
     static void executeAt (const base_properties& props, const QPoint& pt);
 
-    Container * innerContainer (void) { return 0; }
+    Container * innerContainer (void) { return nullptr; }
 
     QWidget * menu (void);
 
   protected:
     void update (int pId);
 
   private slots:
     void aboutToShow (void);
diff --git a/libgui/graphics/EditControl.cc b/libgui/graphics/EditControl.cc
--- a/libgui/graphics/EditControl.cc
+++ b/libgui/graphics/EditControl.cc
@@ -49,17 +49,17 @@ namespace QtHandles
 
             if ((up.get_max () - up.get_min ()) > 1)
               return new EditControl (go, new TextEdit (container));
             else
               return new EditControl (go, new QLineEdit (container));
           }
       }
 
-    return 0;
+    return nullptr;
   }
 
   EditControl::EditControl (const graphics_object& go, QLineEdit *edit)
     : BaseControl (go, edit), m_multiLine (false), m_textChanged (false)
   {
     init (edit);
   }
 
diff --git a/libgui/graphics/Figure.cc b/libgui/graphics/Figure.cc
--- a/libgui/graphics/Figure.cc
+++ b/libgui/graphics/Figure.cc
@@ -119,18 +119,19 @@ namespace QtHandles
 
   Figure*
   Figure::create (const graphics_object& go)
   {
     return new Figure (go, new FigureWindow ());
   }
 
   Figure::Figure (const graphics_object& go, FigureWindow *win)
-    : Object (go, win), m_blockUpdates (false), m_figureToolBar (0),
-      m_menuBar (0), m_innerRect (), m_outerRect (), m_mouseModeGroup (0)
+    : Object (go, win), m_blockUpdates (false), m_figureToolBar (nullptr),
+      m_menuBar (nullptr), m_innerRect (), m_outerRect (),
+      m_mouseModeGroup (nullptr)
   {
     m_container = new Container (win);
     win->setCentralWidget (m_container);
 
     figure::properties& fp = properties<figure> ();
 
     // Status bar
     m_statusBar = win->statusBar ();
@@ -868,17 +869,18 @@ namespace QtHandles
       }
 
     if (prompt || file.isEmpty ())
       {
         QFileInfo finfo (file);
 
         file = QFileDialog::getSaveFileName (qWidget<FigureWindow> (),
                                              tr ("Save Figure As"),
-                                             finfo.absoluteFilePath (), 0, 0,
+                                             finfo.absoluteFilePath (),
+                                             nullptr, nullptr,
                                              QFileDialog::DontUseNativeDialog);
       }
 
     if (! file.isEmpty ())
       {
         QFileInfo finfo (file);
 
         setFileName (finfo.absoluteFilePath ());
diff --git a/libgui/graphics/FigureWindow.cc b/libgui/graphics/FigureWindow.cc
--- a/libgui/graphics/FigureWindow.cc
+++ b/libgui/graphics/FigureWindow.cc
@@ -40,12 +40,12 @@ namespace QtHandles
 
   FigureWindow::~FigureWindow (void)
   { }
 
   QMenu*
   FigureWindow::createPopupMenu (void)
   {
     // For the time being, disable menubar/toolbar popup menu
-    return 0;
+    return nullptr;
   }
 
 }
diff --git a/libgui/graphics/ListBoxControl.cc b/libgui/graphics/ListBoxControl.cc
--- a/libgui/graphics/ListBoxControl.cc
+++ b/libgui/graphics/ListBoxControl.cc
@@ -72,17 +72,17 @@ namespace QtHandles
     if (parent)
       {
         Container *container = parent->innerContainer ();
 
         if (container)
           return new ListBoxControl (go, new QListWidget (container));
       }
 
-    return 0;
+    return nullptr;
   }
 
   ListBoxControl::ListBoxControl (const graphics_object& go, QListWidget *list)
     : BaseControl (go, list), m_blockCallback (false), m_selectionChanged (false)
   {
     uicontrol::properties& up = properties<uicontrol> ();
 
     list->addItems (Utils::fromStringVector (up.get_string_vector ()));
diff --git a/libgui/graphics/Menu.cc b/libgui/graphics/Menu.cc
--- a/libgui/graphics/Menu.cc
+++ b/libgui/graphics/Menu.cc
@@ -65,21 +65,21 @@ namespace QtHandles
     if (parent_obj)
       {
         QObject *qObj = parent_obj->qObject ();
 
         if (qObj)
           return new Menu (go, new QAction (qObj), parent_obj);
       }
 
-    return 0;
+    return nullptr;
   }
 
   Menu::Menu (const graphics_object& go, QAction *action, Object *xparent)
-    : Object (go, action), m_parent (0), m_separator (0)
+    : Object (go, action), m_parent (nullptr), m_separator (nullptr)
   {
     uimenu::properties& up = properties<uimenu> ();
 
     action->setText (Utils::fromStdString (up.get_label ()));
 
     if (up.is_checked ())
       {
         action->setCheckable (true);
@@ -104,18 +104,18 @@ namespace QtHandles
 
     if (m_parent)
       {
         int pos = static_cast<int> (up.get_position ());
 
         if (pos <= 0)
           {
             if (m_separator)
-              m_parent->insertAction (0, m_separator);
-            m_parent->insertAction (0, action);
+              m_parent->insertAction (nullptr, m_separator);
+            m_parent->insertAction (nullptr, action);
 
             int count = 0;
 
             foreach (QAction *a, m_parent->actions ())
               if (! a->isSeparator ())
                 count++;
 
             up.get_property ("position").set
@@ -203,17 +203,17 @@ namespace QtHandles
                 if (m_parent)
                   m_parent->insertAction (action, m_separator);
               }
           }
         else
           {
             if (m_separator)
               delete m_separator;
-            m_separator = 0;
+            m_separator = nullptr;
           }
         break;
 
       case uimenu::properties::ID_VISIBLE:
         action->setVisible (up.is_visible ());
         if (m_separator)
           m_separator->setVisible (up.is_visible ());
         break;
diff --git a/libgui/graphics/Menu.h b/libgui/graphics/Menu.h
--- a/libgui/graphics/Menu.h
+++ b/libgui/graphics/Menu.h
@@ -38,17 +38,17 @@ namespace QtHandles
     Q_OBJECT
 
   public:
     Menu (const graphics_object& go, QAction *action, Object *parent);
     ~Menu (void);
 
     static Menu * create (const graphics_object& go);
 
-    Container * innerContainer (void) { return 0; }
+    Container * innerContainer (void) { return nullptr; }
 
     QWidget * menu (void);
 
   protected:
     void update (int pId);
 
   private slots:
     void actionTriggered (void);
diff --git a/libgui/graphics/MouseModeActionGroup.cc b/libgui/graphics/MouseModeActionGroup.cc
--- a/libgui/graphics/MouseModeActionGroup.cc
+++ b/libgui/graphics/MouseModeActionGroup.cc
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 
 #include "Figure.h"
 #include "MouseModeActionGroup.h"
 
 namespace QtHandles
 {
 
   MouseModeActionGroup::MouseModeActionGroup (QObject *xparent)
-    : QObject (xparent), m_current (0)
+    : QObject (xparent), m_current (nullptr)
   {
     m_actions.append (new QAction (QIcon (":/images/rotate.png"),
                                    tr ("Rotate"), this));
     QAction *zoom_in = new QAction ("Z+", this);
     zoom_in->setToolTip (tr ("Zoom In"));
     m_actions.append (zoom_in);
 
     QAction *zoom_out = new QAction ("Z-", this);
@@ -65,17 +65,17 @@ namespace QtHandles
 
   void
   MouseModeActionGroup::actionToggled (bool checked)
   {
     if (! checked)
       {
         if (sender () == m_current)
           {
-            m_current = 0;
+            m_current = nullptr;
             emit modeChanged (NoMode);
           }
       }
     else
       {
         int i = m_actions.indexOf (qobject_cast<QAction *> (sender ()));
 
         if (i >= 0)
diff --git a/libgui/graphics/Object.cc b/libgui/graphics/Object.cc
--- a/libgui/graphics/Object.cc
+++ b/libgui/graphics/Object.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 #include "Backend.h"
 #include "Object.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
   Object::Object (const graphics_object& go, QObject *obj)
-    : QObject (), m_handle (go.get_handle ()), m_qobject (0)
+    : QObject (), m_handle (go.get_handle ()), m_qobject (nullptr)
   {
     gh_manager::auto_lock lock (false);
 
     if (! lock)
       qCritical ("QtHandles::Object::Object: "
                  "creating Object (h=%g) without a valid lock!!!",
                  m_handle.value ());
 
@@ -133,17 +133,17 @@ namespace QtHandles
   { }
 
   void
   Object::finalize (void)
   {
     if (m_qobject)
       {
         delete m_qobject;
-        m_qobject = 0;
+        m_qobject = nullptr;
       }
     deleteLater ();
   }
 
   void
   Object::redraw (void)
   { }
 
@@ -153,17 +153,17 @@ namespace QtHandles
 
   void
   Object::beingDeleted (void)
   { }
 
   void Object::objectDestroyed (QObject *obj)
   {
     if (obj && obj == m_qobject)
-      m_qobject = 0;
+      m_qobject = nullptr;
   }
 
   Object*
   Object::parentObject (const graphics_object& go)
   {
     gh_manager::auto_lock lock;
 
     Object *parent = Backend::toolkitObject
@@ -175,12 +175,12 @@ namespace QtHandles
   Object*
   Object::fromQObject (QObject *obj)
   {
     QVariant v = obj->property ("QtHandles::Object");
 
     if (v.isValid ())
       return reinterpret_cast<Object *> (qvariant_cast<void*> (v));
 
-    return 0;
+    return nullptr;
   }
 
 }
diff --git a/libgui/graphics/ObjectProxy.cc b/libgui/graphics/ObjectProxy.cc
--- a/libgui/graphics/ObjectProxy.cc
+++ b/libgui/graphics/ObjectProxy.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 
 #include "Object.h"
 #include "ObjectProxy.h"
 
 namespace QtHandles
 {
 
   ObjectProxy::ObjectProxy (Object *obj)
-    : QObject (), m_object (0)
+    : QObject (), m_object (nullptr)
   {
     init (obj);
   }
 
   void
   ObjectProxy::init (Object *obj)
   {
     if (obj != m_object)
@@ -91,17 +91,17 @@ namespace QtHandles
     else if (m_object)
       m_object->slotUpdate (pId);
   }
 
   void
   ObjectProxy::finalize (void)
   {
     emit sendFinalize ();
-    init (0);
+    init (nullptr);
   }
 
   void
   ObjectProxy::redraw (void)
   {
     emit sendRedraw ();
   }
 
diff --git a/libgui/graphics/Panel.cc b/libgui/graphics/Panel.cc
--- a/libgui/graphics/Panel.cc
+++ b/libgui/graphics/Panel.cc
@@ -92,21 +92,22 @@ namespace QtHandles
     if (parent)
       {
         Container *container = parent->innerContainer ();
 
         if (container)
           return new Panel (go, new QFrame (container));
       }
 
-    return 0;
+    return nullptr;
   }
 
   Panel::Panel (const graphics_object& go, QFrame *frame)
-    : Object (go, frame), m_container (0), m_title (0), m_blockUpdates (false)
+    : Object (go, frame), m_container (nullptr), m_title (nullptr),
+      m_blockUpdates (false)
   {
     uipanel::properties& pp = properties<uipanel> ();
 
     frame->setObjectName ("UIPanel");
     frame->setAutoFillBackground (true);
     Matrix bb = pp.get_boundingbox (false);
     frame->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
                         octave::math::round (bb(2)), octave::math::round (bb(3)));
@@ -270,17 +271,17 @@ namespace QtHandles
       case uipanel::properties::ID_TITLE:
         {
           QString title = Utils::fromStdString (pp.get_title ());
 
           if (title.isEmpty ())
             {
               if (m_title)
                 delete m_title;
-              m_title = 0;
+              m_title = nullptr;
             }
           else
             {
               if (! m_title)
                 {
                   QPalette pal = frame->palette ();
 
                   m_title = new QLabel (title, frame);
diff --git a/libgui/graphics/PopupMenuControl.cc b/libgui/graphics/PopupMenuControl.cc
--- a/libgui/graphics/PopupMenuControl.cc
+++ b/libgui/graphics/PopupMenuControl.cc
@@ -41,17 +41,17 @@ namespace QtHandles
     if (parent)
       {
         Container *container = parent->innerContainer ();
 
         if (container)
           return new PopupMenuControl (go, new QComboBox (container));
       }
 
-    return 0;
+    return nullptr;
   }
 
   PopupMenuControl::PopupMenuControl (const graphics_object& go, QComboBox *box)
     : BaseControl (go, box), m_blockUpdate (false)
   {
     uicontrol::properties& up = properties<uicontrol> ();
 
     box->addItems (Utils::fromStdString (up.get_string_string ()).split ('|'));
diff --git a/libgui/graphics/PushButtonControl.cc b/libgui/graphics/PushButtonControl.cc
--- a/libgui/graphics/PushButtonControl.cc
+++ b/libgui/graphics/PushButtonControl.cc
@@ -42,17 +42,17 @@ namespace QtHandles
     if (parent)
       {
         Container *container = parent->innerContainer ();
 
         if (container)
           return new PushButtonControl (go, new QPushButton (container));
       }
 
-    return 0;
+    return nullptr;
   }
 
   PushButtonControl::PushButtonControl (const graphics_object& go,
                                         QPushButton *btn)
     : ButtonControl (go, btn)
   {
     btn->setAutoFillBackground (true);
   }
diff --git a/libgui/graphics/PushTool.cc b/libgui/graphics/PushTool.cc
--- a/libgui/graphics/PushTool.cc
+++ b/libgui/graphics/PushTool.cc
@@ -39,17 +39,17 @@ namespace QtHandles
     if (parent)
       {
         QWidget *parentWidget = parent->qWidget<QWidget> ();
 
         if (parentWidget)
           return new PushTool (go, new QAction (parentWidget));
       }
 
-    return 0;
+    return nullptr;
   }
 
   PushTool::PushTool (const graphics_object& go, QAction *action)
     : ToolBarButton<uipushtool> (go, action)
   {
     connect (action, SIGNAL (triggered (bool)), this, SLOT (clicked (void)));
   }
 
diff --git a/libgui/graphics/RadioButtonControl.cc b/libgui/graphics/RadioButtonControl.cc
--- a/libgui/graphics/RadioButtonControl.cc
+++ b/libgui/graphics/RadioButtonControl.cc
@@ -42,17 +42,17 @@ namespace QtHandles
     if (parent)
       {
         Container *container = parent->innerContainer ();
 
         if (container)
           return new RadioButtonControl (go, new QRadioButton (container));
       }
 
-    return 0;
+    return nullptr;
   }
 
   RadioButtonControl::RadioButtonControl (const graphics_object& go,
                                           QRadioButton *radio)
     : ButtonControl (go, radio)
   {
     Object *parent = Object::parentObject (go);
     ButtonGroup *btnGroup = dynamic_cast<ButtonGroup *>(parent);
diff --git a/libgui/graphics/SliderControl.cc b/libgui/graphics/SliderControl.cc
--- a/libgui/graphics/SliderControl.cc
+++ b/libgui/graphics/SliderControl.cc
@@ -43,17 +43,17 @@ namespace QtHandles
     if (parent)
       {
         Container *container = parent->innerContainer ();
 
         if (container)
           return new SliderControl (go, new QScrollBar (container));
       }
 
-    return 0;
+    return nullptr;
   }
 
   SliderControl::SliderControl (const graphics_object& go,
                                 QAbstractSlider *slider)
     : BaseControl (go, slider), m_blockUpdates (false)
   {
     uicontrol::properties& up = properties<uicontrol> ();
 
diff --git a/libgui/graphics/TextControl.cc b/libgui/graphics/TextControl.cc
--- a/libgui/graphics/TextControl.cc
+++ b/libgui/graphics/TextControl.cc
@@ -41,17 +41,17 @@ namespace QtHandles
     if (parent)
       {
         Container *container = parent->innerContainer ();
 
         if (container)
           return new TextControl (go, new QLabel (container));
       }
 
-    return 0;
+    return nullptr;
   }
 
   TextControl::TextControl (const graphics_object& go, QLabel *label)
     : BaseControl (go, label)
   {
     uicontrol::properties& up = properties<uicontrol> ();
 
     label->setAutoFillBackground (true);
diff --git a/libgui/graphics/ToggleButtonControl.cc b/libgui/graphics/ToggleButtonControl.cc
--- a/libgui/graphics/ToggleButtonControl.cc
+++ b/libgui/graphics/ToggleButtonControl.cc
@@ -42,17 +42,17 @@ namespace QtHandles
     if (parent)
       {
         Container *container = parent->innerContainer ();
 
         if (container)
           return new ToggleButtonControl (go, new QPushButton (container));
       }
 
-    return 0;
+    return nullptr;
   }
 
   ToggleButtonControl::ToggleButtonControl (const graphics_object& go,
       QPushButton *btn)
     : ButtonControl (go, btn)
   {
     Object *parent = Object::parentObject (go);
     ButtonGroup *btnGroup = dynamic_cast<ButtonGroup *>(parent);
diff --git a/libgui/graphics/ToggleTool.cc b/libgui/graphics/ToggleTool.cc
--- a/libgui/graphics/ToggleTool.cc
+++ b/libgui/graphics/ToggleTool.cc
@@ -39,17 +39,17 @@ namespace QtHandles
     if (parent)
       {
         QWidget *parentWidget = parent->qWidget<QWidget> ();
 
         if (parentWidget)
           return new ToggleTool (go, new QAction (parentWidget));
       }
 
-    return 0;
+    return nullptr;
   }
 
   ToggleTool::ToggleTool (const graphics_object& go, QAction *action)
     : ToolBarButton<uitoggletool> (go, action)
   {
     uitoggletool::properties& tp = properties<uitoggletool> ();
 
     action->setCheckable (true);
diff --git a/libgui/graphics/ToolBar.cc b/libgui/graphics/ToolBar.cc
--- a/libgui/graphics/ToolBar.cc
+++ b/libgui/graphics/ToolBar.cc
@@ -71,21 +71,21 @@ namespace QtHandles
     if (parent)
       {
         QWidget *parentWidget = parent->qWidget<QWidget> ();
 
         if (parentWidget)
           return new ToolBar (go, new QToolBar (parentWidget));
       }
 
-    return 0;
+    return nullptr;
   }
 
   ToolBar::ToolBar (const graphics_object& go, QToolBar *bar)
-    : Object (go, bar), m_empty (0), m_figure (0)
+    : Object (go, bar), m_empty (nullptr), m_figure (nullptr)
   {
     uitoolbar::properties& tp = properties<uitoolbar> ();
 
     bar->setFloatable (false);
     bar->setMovable (false);
     bar->setVisible (tp.is_visible ());
 
     m_empty = addEmptyAction (bar);
diff --git a/libgui/graphics/ToolBar.h b/libgui/graphics/ToolBar.h
--- a/libgui/graphics/ToolBar.h
+++ b/libgui/graphics/ToolBar.h
@@ -38,17 +38,17 @@ namespace QtHandles
     Q_OBJECT
 
   public:
     ToolBar (const graphics_object& go, QToolBar *bar);
     ~ToolBar (void);
 
     static ToolBar * create (const graphics_object& go);
 
-    Container * innerContainer (void) { return 0; }
+    Container * innerContainer (void) { return nullptr; }
 
     bool eventFilter (QObject *watched, QEvent *event);
 
   protected:
     void update (int pId);
     void beingDeleted (void);
 
   private slots:
diff --git a/libgui/graphics/ToolBarButton.cc b/libgui/graphics/ToolBarButton.cc
--- a/libgui/graphics/ToolBarButton.cc
+++ b/libgui/graphics/ToolBarButton.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 #include "ToolBarButton.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
   template <typename T>
   ToolBarButton<T>::ToolBarButton (const graphics_object& go, QAction *action)
-    : Object (go, action), m_separator (0)
+    : Object (go, action), m_separator (nullptr)
   {
     typename T::properties& tp = properties<T> ();
 
     action->setToolTip (Utils::fromStdString (tp.get_tooltipstring ()));
     action->setVisible (tp.is_visible ());
     QImage img = Utils::makeImageFromCData (tp.get_cdata (), 16, 16);
     action->setIcon (QIcon (QPixmap::fromImage (img)));
     if (tp.is_separator ())
@@ -102,17 +102,17 @@ namespace QtHandles
 
                 w->insertAction (action, m_separator);
               }
           }
         else
           {
             if (m_separator)
               delete m_separator;
-            m_separator = 0;
+            m_separator = nullptr;
           }
         break;
 
       case T::properties::ID_ENABLE:
         action->setEnabled (tp.is_enable ());
         break;
 
       default:
diff --git a/libgui/graphics/ToolBarButton.h b/libgui/graphics/ToolBarButton.h
--- a/libgui/graphics/ToolBarButton.h
+++ b/libgui/graphics/ToolBarButton.h
@@ -34,17 +34,17 @@ namespace QtHandles
 
   template <typename T>
   class ToolBarButton : public Object
   {
   public:
     ToolBarButton (const graphics_object& go, QAction *action);
     ~ToolBarButton (void);
 
-    Container * innerContainer (void) { return 0; }
+    Container * innerContainer (void) { return nullptr; }
 
   protected:
     void update (int pId);
 
   private:
     QAction *m_separator;
   };
 
diff --git a/libgui/qterminal/libqterminal/QTerminal.h b/libgui/qterminal/libqterminal/QTerminal.h
--- a/libgui/qterminal/libqterminal/QTerminal.h
+++ b/libgui/qterminal/libqterminal/QTerminal.h
@@ -38,17 +38,17 @@ see <http://www.gnu.org/licenses/>.
 #include "resource-manager.h"
 
 class QTerminal : public QWidget
 {
   Q_OBJECT
 
 public:
 
-  static QTerminal *create (QWidget *xparent = 0);
+  static QTerminal *create (QWidget *xparent = nullptr);
 
   static QList<QColor> default_colors (void);
 
   static QStringList color_names (void);
 
   virtual ~QTerminal (void) = default;
 
   virtual void setTerminalFont (const QFont& font) = 0;
@@ -116,17 +116,17 @@ public slots:
   void terminal_interrupt (void) { emit interrupt_signal (); }
 
   void set_global_shortcuts (bool focus_out);
 
   void edit_file (void);
 
 protected:
 
-  QTerminal (QWidget *xparent = 0) : QWidget (xparent)
+  QTerminal (QWidget *xparent = nullptr) : QWidget (xparent)
   {
     // context menu
     setContextMenuPolicy (Qt::CustomContextMenu);
 
     _contextMenu = new QMenu (this);
 
     _copy_action = _contextMenu->addAction (
                      resource_manager::icon ("edit-copy"),
diff --git a/libgui/qterminal/libqterminal/unix/BlockArray.cpp b/libgui/qterminal/libqterminal/unix/BlockArray.cpp
--- a/libgui/qterminal/libqterminal/unix/BlockArray.cpp
+++ b/libgui/qterminal/libqterminal/unix/BlockArray.cpp
@@ -110,17 +110,17 @@ const Block* BlockArray::at(size_t i)
     if (i == index + 1)
         return lastblock;
 
     if (i == lastmap_index)
         return lastmap;
 
     if (i > index) {
         qDebug() << "BlockArray::at() i > index\n";
-        return 0;
+        return nullptr;
     }
 
 //     if (index - i >= length) {
 //         kDebug(1211) << "BlockArray::at() index - i >= length\n";
 //         return 0;
 //     }
 
     size_t j = i; // (current - (index - i) + (index/size+1)*size) % size ;
@@ -139,17 +139,17 @@ const Block* BlockArray::at(size_t i)
 }
 
 void BlockArray::unmap()
 {
     if (lastmap) {
         int res = munmap((char*)lastmap, blocksize);
         if (res < 0) perror("munmap");
     }
-    lastmap = 0;
+    lastmap = nullptr;
     lastmap_index = size_t(-1);
 }
 
 bool BlockArray::setSize(size_t newsize)
 {
     return setHistorySize(newsize * 1024 / blocksize);
 }
 
@@ -159,17 +159,17 @@ bool BlockArray::setHistorySize(size_t n
 
     if (size == newsize)
         return false;
 
     unmap();
 
     if (!newsize) {
         delete lastblock;
-        lastblock = 0;
+        lastblock = nullptr;
         if (ion >= 0) close(ion);
         ion = -1;
         current = size_t(-1);
         return true;
     }
 
     if (!size) {
         FILE* tmp = tmpfile();
diff --git a/libgui/qterminal/libqterminal/unix/Emulation.cpp b/libgui/qterminal/libqterminal/unix/Emulation.cpp
--- a/libgui/qterminal/libqterminal/unix/Emulation.cpp
+++ b/libgui/qterminal/libqterminal/unix/Emulation.cpp
@@ -45,20 +45,20 @@
 
 // Konsole
 #include "unix/KeyboardTranslator.h"
 #include "unix/Screen.h"
 #include "unix/TerminalCharacterDecoder.h"
 #include "unix/ScreenWindow.h"
 
 Emulation::Emulation() :
-  _currentScreen(0),
-  _codec(0),
-  _decoder(0),
-  _keyTranslator(0),
+  _currentScreen(nullptr),
+  _codec(nullptr),
+  _decoder(nullptr),
+  _keyTranslator(nullptr),
   _usesMouse(false)
 {
 
   // create screens with a default size
   _screen[0] = new Screen(40,80);
   _screen[1] = new Screen(40,80);
   _currentScreen = _screen[0];
 
@@ -339,17 +339,17 @@ ushort ExtendedCharTable::extendedCharHa
     return hash;
 }
 bool ExtendedCharTable::extendedCharMatch(ushort hash , ushort* unicodePoints , ushort length) const
 {
     ushort* entry = extendedCharTable[hash];
 
     // compare given length with stored sequence length ( given as the first ushort in the
     // stored buffer )
-    if ( entry == 0 || entry[0] != length )
+    if ( entry == nullptr || entry[0] != length )
        return false;
     // if the lengths match, each character must be checked.  the stored buffer starts at
     // entry[1]
     for ( int i = 0 ; i < length ; i++ )
     {
         if ( entry[i+1] != unicodePoints[i] )
            return false;
     }
@@ -399,17 +399,17 @@ ushort* ExtendedCharTable::lookupExtende
     if ( buffer )
     {
         length = buffer[0];
         return buffer+1;
     }
     else
     {
         length = 0;
-        return 0;
+        return nullptr;
     }
 }
 
 ExtendedCharTable::ExtendedCharTable()
 {
 }
 ExtendedCharTable::~ExtendedCharTable()
 {
diff --git a/libgui/qterminal/libqterminal/unix/Filter.cpp b/libgui/qterminal/libqterminal/unix/Filter.cpp
--- a/libgui/qterminal/libqterminal/unix/Filter.cpp
+++ b/libgui/qterminal/libqterminal/unix/Filter.cpp
@@ -87,40 +87,40 @@ void FilterChain::clear()
 }
 Filter::HotSpot* FilterChain::hotSpotAt(int line , int column) const
 {
     QListIterator<Filter*> iter(*this);
     while (iter.hasNext())
     {
         Filter* filter = iter.next();
         Filter::HotSpot* spot = filter->hotSpotAt(line,column);
-        if ( spot != 0 )
+        if ( spot != nullptr )
         {
             return spot;
         }
     }
 
-    return 0;
+    return nullptr;
 }
 
 QList<Filter::HotSpot*> FilterChain::hotSpots() const
 {
     QList<Filter::HotSpot*> list;
     QListIterator<Filter*> iter(*this);
     while (iter.hasNext())
     {
         Filter* filter = iter.next();
         list << filter->hotSpots();
     }
     return list;
 }
 
 TerminalImageFilterChain::TerminalImageFilterChain()
-: _buffer(0)
-, _linePositions(0)
+: _buffer(nullptr)
+, _linePositions(nullptr)
 {
 }
 
 TerminalImageFilterChain::~TerminalImageFilterChain()
 {
     delete _buffer;
     delete _linePositions;
 }
@@ -173,18 +173,18 @@ void TerminalImageFilterChain::setImage(
         if ( !(lineProperties.value(i,LINE_DEFAULT) & LINE_WRAPPED) )
         	lineStream << QChar('\n');
     }
     decoder.end();
 //    qDebug("%s %d", __FILE__, __LINE__);
 }
 
 Filter::Filter() :
-_linePositions(0),
-_buffer(0)
+_linePositions(nullptr),
+_buffer(nullptr)
 {
 }
 
 Filter::~Filter()
 {
     QListIterator<HotSpot*> iter(_hotspotList);
     while (iter.hasNext())
     {
@@ -278,17 +278,17 @@ Filter::HotSpot* Filter::hotSpotAt(int l
         if ( spot->startLine() == line && spot->startColumn() > column )
             continue;
         if ( spot->endLine() == line && spot->endColumn() < column )
             continue;
 
         return spot;
     }
 
-    return 0;
+    return nullptr;
 }
 
 Filter::HotSpot::HotSpot(int startLine , int startColumn , int endLine , int endColumn)
     : _startLine(startLine)
     , _startColumn(startColumn)
     , _endLine(endLine)
     , _endColumn(endColumn)
     , _type(NotSpecified)
diff --git a/libgui/qterminal/libqterminal/unix/Filter.h b/libgui/qterminal/libqterminal/unix/Filter.h
--- a/libgui/qterminal/libqterminal/unix/Filter.h
+++ b/libgui/qterminal/libqterminal/unix/Filter.h
@@ -110,17 +110,17 @@ public:
        /**
         * Causes the an action associated with a hotspot to be triggered.
         *
         * @param object The object which caused the hotspot to be triggered.  This is
         * typically null ( in which case the default action should be performed ) or
         * one of the objects from the actions() list.  In which case the associated
         * action should be performed.
         */
-       virtual void activate(QObject* object = 0) = 0;
+       virtual void activate(QObject* object = nullptr) = 0;
        /**
         * Returns a list of actions associated with the hotspot which can be used in a
         * menu or toolbar
         */
        virtual QList<QAction*> actions();
 
        /**
         * Returns the text of a tooltip to be shown when the mouse moves over the hotspot, or
@@ -206,17 +206,17 @@ public:
      * Type of hotspot created by RegExpFilter.  The capturedTexts() method can be used to find the text
      * matched by the filter's regular expression.
      */
     class HotSpot : public Filter::HotSpot
     {
     public:
         HotSpot(int startLine, int startColumn,
                 int endLine , int endColumn, Filter::Type);
-        virtual void activate(QObject* object = 0);
+        virtual void activate(QObject* object = nullptr);
 
         /** Sets the captured texts associated with this hotspot */
         void setCapturedTexts(const QStringList& texts);
         /** Returns the texts found by the filter when matching the filter's regular expression */
         QStringList capturedTexts() const;
      private:
         QStringList _capturedTexts;
     };
@@ -279,17 +279,17 @@ public:
         virtual ~HotSpot();
 
         virtual QList<QAction*> actions();
 
         /**
          * Open a web browser at the current URL.  The url itself can be determined using
          * the capturedTexts() method.
          */
-        virtual void activate(QObject* object = 0);
+        virtual void activate(QObject* object = nullptr);
 
         virtual QString tooltip() const;
 
         FilterObject* get_urlObject () { return _urlObject; }
 
     private:
         enum UrlType
         {
diff --git a/libgui/qterminal/libqterminal/unix/History.cpp b/libgui/qterminal/libqterminal/unix/History.cpp
--- a/libgui/qterminal/libqterminal/unix/History.cpp
+++ b/libgui/qterminal/libqterminal/unix/History.cpp
@@ -79,17 +79,17 @@ FIXME: There is noticeable decrease in s
 
 /*
   A Row(X) data type which allows adding elements to the end.
 */
 
 HistoryFile::HistoryFile()
   : ion(-1),
     length(0),
-	fileMap(0)
+	fileMap(nullptr)
 {
   if (tmpFile.open())
   {
     tmpFile.setAutoRemove(true);
     ion = tmpFile.handle();
   }
 }
 
@@ -99,40 +99,40 @@ HistoryFile::~HistoryFile()
 		unmap();
 }
 
 //TODO:  Mapping the entire file in will cause problems if the history file becomes exceedingly large,
 //(ie. larger than available memory).  HistoryFile::map() should only map in sections of the file at a time,
 //to avoid this.
 void HistoryFile::map()
 {
-	assert( fileMap == 0 );
+	assert( fileMap == nullptr );
 
-	fileMap = (char*)mmap( 0 , length , PROT_READ , MAP_PRIVATE , ion , 0 );
+	fileMap = (char*)mmap( nullptr , length , PROT_READ , MAP_PRIVATE , ion , 0 );
 
     //if mmap'ing fails, fall back to the read-lseek combination
     if ( fileMap == MAP_FAILED )
     {
             readWriteBalance = 0;
-            fileMap = 0;
+            fileMap = nullptr;
             qDebug() << ": mmap'ing history failed.  errno = " << errno;
     }
 }
 
 void HistoryFile::unmap()
 {
 	int result = munmap( fileMap , length );
 	assert( result == 0 );
 
-	fileMap = 0;
+	fileMap = nullptr;
 }
 
 bool HistoryFile::isMapped()
 {
-	return (fileMap != 0);
+	return (fileMap != nullptr);
 }
 
 void HistoryFile::add(const unsigned char* bytes, int len)
 {
   if ( fileMap )
 		  unmap();
 		
   readWriteBalance++;
@@ -661,17 +661,17 @@ const QString& HistoryTypeFile::getFileN
 HistoryScroll* HistoryTypeFile::scroll(HistoryScroll *old) const
 {
   if (dynamic_cast<HistoryFile *>(old))
      return old; // Unchanged.
 
   HistoryScroll *newScroll = new HistoryScrollFile(m_fileName);
 
   Character line[LINE_SIZE];
-  int lines = (old != 0) ? old->getLines() : 0;
+  int lines = (old != nullptr) ? old->getLines() : 0;
   for(int i = 0; i < lines; i++)
   {
      int size = old->getLineLen(i);
      if (size > LINE_SIZE)
      {
         Character *tmp_line = new Character[size];
         old->getCells(i, 0, size, tmp_line);
         newScroll->addCells(tmp_line, size);
diff --git a/libgui/qterminal/libqterminal/unix/KeyboardTranslator.cpp b/libgui/qterminal/libqterminal/unix/KeyboardTranslator.cpp
--- a/libgui/qterminal/libqterminal/unix/KeyboardTranslator.cpp
+++ b/libgui/qterminal/libqterminal/unix/KeyboardTranslator.cpp
@@ -76,37 +76,37 @@ void KeyboardTranslatorManager::findTran
     QStringListIterator listIter(list);
     while (listIter.hasNext())
     {
         QString translatorPath = listIter.next();
 
         QString name = QFileInfo(translatorPath).baseName();
 
         if ( !_translators.contains(name) ) {
-            _translators.insert(name,0);
+            _translators.insert(name,nullptr);
 	}
     }
     _haveLoadedAll = true;
 }
 
 const KeyboardTranslator* KeyboardTranslatorManager::findTranslator(const QString& name)
 {
     if ( name.isEmpty() )
         return defaultTranslator();
 
     //here was smth wrong in original Konsole source
     findTranslators();
 
-    if ( _translators.contains(name) && _translators[name] != 0 ) {
+    if ( _translators.contains(name) && _translators[name] != nullptr ) {
         return _translators[name];
     }
 
     KeyboardTranslator* translator = loadTranslator(name);
 
-    if ( translator != 0 )
+    if ( translator != nullptr )
         _translators[name] = translator;
     else if ( !name.isEmpty() )
         qWarning() << "Unable to load translator" << name;
 
     return translator;
 }
 
 bool KeyboardTranslatorManager::saveTranslator(const KeyboardTranslator* translator)
@@ -142,28 +142,28 @@ bool KeyboardTranslatorManager::saveTran
 
 KeyboardTranslator* KeyboardTranslatorManager::loadTranslator(const QString& name)
 {
     const QString& path = findTranslatorPath(name);
 
     QFile source(path);
 
     if (name.isEmpty() || !source.open(QIODevice::ReadOnly | QIODevice::Text))
-        return 0;
+        return nullptr;
 
     return loadTranslator(&source,name);
 }
 
 const KeyboardTranslator* KeyboardTranslatorManager::defaultTranslator()
 {
     QBuffer textBuffer;
     textBuffer.setData(defaultTranslatorText,strlen(defaultTranslatorText));
 
     if (!textBuffer.open(QIODevice::ReadOnly))
-        return 0;
+        return nullptr;
 
     return loadTranslator(&textBuffer,"fallback");
 }
 
 KeyboardTranslator* KeyboardTranslatorManager::loadTranslator(QIODevice* source,const QString& name)
 {
     KeyboardTranslator* translator = new KeyboardTranslator(name);
     KeyboardTranslatorReader reader(source);
@@ -177,17 +177,17 @@ KeyboardTranslator* KeyboardTranslatorMa
 
     if ( !reader.parseError() )
     {
         return translator;
     }
     else
     {
         delete translator;
-        return 0;
+        return nullptr;
     }
 }
 
 KeyboardTranslatorWriter::KeyboardTranslatorWriter(QIODevice* destination)
     : _destination(destination)
 {
     Q_ASSERT( destination && destination->isWritable() );
 
diff --git a/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.h b/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.h
--- a/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.h
+++ b/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.h
@@ -29,17 +29,17 @@
 
 class QUnixTerminalImpl : public QTerminal
 {
     Q_OBJECT
 
     int fdstderr;
 
 public:
-    QUnixTerminalImpl(QWidget *parent = 0);
+    QUnixTerminalImpl(QWidget *parent = nullptr);
     virtual ~QUnixTerminalImpl();
 
     void setTerminalFont(const QFont &font);
     void setSize(int h, int v);
     void sendText(const QString& text);
 
     void setCursorType(CursorType type, bool blinking);
 
diff --git a/libgui/qterminal/libqterminal/unix/Screen.cpp b/libgui/qterminal/libqterminal/unix/Screen.cpp
--- a/libgui/qterminal/libqterminal/unix/Screen.cpp
+++ b/libgui/qterminal/libqterminal/unix/Screen.cpp
@@ -1528,17 +1528,17 @@ void Screen::setScroll(const HistoryType
 {
   clearSelection();
 
   if ( copyPreviousScroll )
     hist = t.scroll(hist);
   else
   {
       HistoryScroll* oldScroll = hist;
-      hist = t.scroll(0);
+      hist = t.scroll(nullptr);
       delete oldScroll;
   }
 }
 
 bool Screen::hasScroll()
 {
   return hist->hasScroll();
 }
diff --git a/libgui/qterminal/libqterminal/unix/ScreenWindow.cpp b/libgui/qterminal/libqterminal/unix/ScreenWindow.cpp
--- a/libgui/qterminal/libqterminal/unix/ScreenWindow.cpp
+++ b/libgui/qterminal/libqterminal/unix/ScreenWindow.cpp
@@ -25,17 +25,17 @@
 // Qt
 #include <QtCore>
 
 // Konsole
 #include "unix/Screen.h"
 
 ScreenWindow::ScreenWindow(QObject* parent)
     : QObject(parent)
-	, _windowBuffer(0)
+	, _windowBuffer(nullptr)
 	, _windowBufferSize(0)
 	, _bufferNeedsUpdate(true)
 	, _windowLines(1)
     , _currentLine(0)
     , _trackOutput(true)
     , _scrollCount(0)
 {
 }
@@ -55,17 +55,17 @@ Screen* ScreenWindow::screen() const
 {
     return _screen;
 }
 
 Character* ScreenWindow::getImage()
 {
 	// reallocate internal buffer if the window size has changed
 	int size = windowLines() * windowColumns();
-	if (_windowBuffer == 0 || _windowBufferSize != size)
+	if (_windowBuffer == nullptr || _windowBufferSize != size)
 	{
 		delete[] _windowBuffer;
 		_windowBufferSize = size;
 		_windowBuffer = new Character[size];
 		_bufferNeedsUpdate = true;
 	}
 
 	 if (!_bufferNeedsUpdate)
diff --git a/libgui/qterminal/libqterminal/unix/ScreenWindow.h b/libgui/qterminal/libqterminal/unix/ScreenWindow.h
--- a/libgui/qterminal/libqterminal/unix/ScreenWindow.h
+++ b/libgui/qterminal/libqterminal/unix/ScreenWindow.h
@@ -57,17 +57,17 @@ public:
      * Constructs a new screen window with the given parent.
      * A screen must be specified by calling setScreen() before calling getImage() or getLineProperties().
      *
      * You should not call this constructor directly, instead use the Emulation::createWindow() method
      * to create a window on the emulation which you wish to view.  This allows the emulation
      * to notify the window when the associated screen has changed and synchronize selection updates
      * between all views on a session.
      */
-    ScreenWindow(QObject* parent = 0);
+    ScreenWindow(QObject* parent = nullptr);
 	virtual ~ScreenWindow();
 
     /** Sets the screen which this window looks onto */
     void setScreen(Screen* screen);
     /** Returns the screen which this window looks onto */
     Screen* screen() const;
 
     /**
diff --git a/libgui/qterminal/libqterminal/unix/SelfListener.h b/libgui/qterminal/libqterminal/unix/SelfListener.h
--- a/libgui/qterminal/libqterminal/unix/SelfListener.h
+++ b/libgui/qterminal/libqterminal/unix/SelfListener.h
@@ -20,17 +20,17 @@
 
 #include <QThread>
 #include <unistd.h>
 
 class SelfListener : public QThread
 {
     Q_OBJECT
 public:
-    explicit SelfListener(int a, QObject *parent = 0);
+    explicit SelfListener(int a, QObject *parent = nullptr);
 
 signals:
     void recvData(const char* stdOutBuffer, int stdOutlen);
 
 public slots:
 
 protected:
     void run();
diff --git a/libgui/qterminal/libqterminal/unix/TerminalCharacterDecoder.cpp b/libgui/qterminal/libqterminal/unix/TerminalCharacterDecoder.cpp
--- a/libgui/qterminal/libqterminal/unix/TerminalCharacterDecoder.cpp
+++ b/libgui/qterminal/libqterminal/unix/TerminalCharacterDecoder.cpp
@@ -23,17 +23,17 @@
 
 // Own
 #include "unix/TerminalCharacterDecoder.h"
 
 // Qt
 #include <QtCore/QTextStream>
 
 PlainTextDecoder::PlainTextDecoder()
- : _output(0)
+ : _output(nullptr)
  , _includeTrailingWhitespace(true)
 {
 
 }
 void PlainTextDecoder::setTrailingWhitespace(bool enable)
 {
     _includeTrailingWhitespace = enable;
 }
@@ -81,18 +81,18 @@ void PlainTextDecoder::decodeLine(const 
 	{
 		plainText.append( QChar(characters[i].character) );
 	}
 
 	*_output << plainText;
 }
 
 HTMLDecoder::HTMLDecoder() :
-        _output(0)
-	   ,_colorTable(base_color_table)
+        _output(nullptr)
+       ,_colorTable(base_color_table)
        ,_innerSpanOpen(false)
        ,_lastRendition(DEFAULT_RENDITION)
 {
 	
 }
 
 void HTMLDecoder::begin(QTextStream* output)
 {
@@ -111,17 +111,17 @@ void HTMLDecoder::end()
     Q_ASSERT( _output );
 
     QString text;
 
     closeSpan(text);
 
     *_output << text;
 
-    _output = 0;
+    _output = nullptr;
 
 }
 
 //TODO: Support for LineProperty (mainly double width , double height)
 void HTMLDecoder::decodeLine(const Character* const characters, int count, LineProperty /*properties*/
 							)
 {
     Q_ASSERT( _output );
diff --git a/libgui/qterminal/libqterminal/unix/TerminalModel.cpp b/libgui/qterminal/libqterminal/unix/TerminalModel.cpp
--- a/libgui/qterminal/libqterminal/unix/TerminalModel.cpp
+++ b/libgui/qterminal/libqterminal/unix/TerminalModel.cpp
@@ -38,18 +38,18 @@
 #include <QtCore/QRegExp>
 #include <QtCore/QStringList>
 #include <QtCore>
 
 #include "unix/TerminalView.h"
 #include "unix/Vt102Emulation.h"
 
 TerminalModel::TerminalModel(KPty *kpty) :
-    _shellProcess(0)
-  , _emulation(0)
+    _shellProcess(nullptr)
+  , _emulation(nullptr)
   , _monitorActivity(false)
   , _monitorSilence(false)
   , _notifiedActivity(false)
   , _autoClose(true)
   , _wantedClose(false)
   , _silenceSeconds(10)
   , _addToUtmp(false)
   , _fullScripting(false)
@@ -109,17 +109,17 @@ QList<TerminalView*> TerminalModel::view
 }
 
 void TerminalModel::addView(TerminalView* widget)
 {
     Q_ASSERT( !_views.contains(widget) );
 
     _views.append(widget);
 
-    if ( _emulation != 0 )
+    if ( _emulation != nullptr )
     {
         // connect emulation - view signals and slots
         connect( widget , SIGNAL(keyPressedSignal(QKeyEvent*)) , _emulation ,
                  SLOT(sendKeyEvent(QKeyEvent*)) );
         connect( widget , SIGNAL(mouseSignal(int,int,int,int)) , _emulation ,
                  SLOT(sendMouseEvent(int,int,int,int)) );
         connect( widget , SIGNAL(sendStringToEmu(const char*)) , _emulation ,
                  SLOT(sendString(const char*)) );
@@ -158,30 +158,30 @@ void TerminalModel::sendData(const char 
     ssize_t bytesWritten = ::write(_kpty->masterFd(), buf, len);
     (void)bytesWritten;
 }
 
 void TerminalModel::removeView(TerminalView* widget)
 {
     _views.removeAll(widget);
 
-    disconnect(widget,0,this,0);
+    disconnect(widget,nullptr,this,nullptr);
 
-    if ( _emulation != 0 )
+    if ( _emulation != nullptr )
     {
         // disconnect
         //  - key presses signals from widget
         //  - mouse activity signals from widget
         //  - string sending signals from widget
         //
         //  ... and any other signals connected in addView()
-        disconnect( widget, 0, _emulation, 0);
+        disconnect( widget, nullptr, _emulation, nullptr);
 
         // disconnect state change signals emitted by emulation
-        disconnect( _emulation , 0 , widget , 0);
+        disconnect( _emulation , nullptr , widget , nullptr);
     }
 
     // close the session automatically when the last view is removed
     if ( _views.count() == 0 )
     {
         close();
     }
 }
diff --git a/libgui/qterminal/libqterminal/unix/TerminalView.cpp b/libgui/qterminal/libqterminal/unix/TerminalView.cpp
--- a/libgui/qterminal/libqterminal/unix/TerminalView.cpp
+++ b/libgui/qterminal/libqterminal/unix/TerminalView.cpp
@@ -85,17 +85,17 @@ ScreenWindow* TerminalView::screenWindow
 {
   return _screenWindow;
 }
 void TerminalView::setScreenWindow(ScreenWindow* window)
 {
   // disconnect existing screen window if any
   if ( _screenWindow )
     {
-      disconnect( _screenWindow , 0 , this , 0 );
+      disconnect( _screenWindow , nullptr , this , nullptr );
     }
 
   _screenWindow = window;
 
   if ( window )
     {
       //#warning "The order here is not specified - does it matter whether updateImage or updateLineProperties comes first?"
       connect( _screenWindow , SIGNAL(outputChanged()) , this , SLOT(updateLineProperties()) );
@@ -708,21 +708,22 @@ void TerminalView::scrollImage(int lines
 
   // constrain the region to the display
   // the bottom of the region is capped to the number of lines in the display's
   // internal image - 2, so that the height of 'region' is strictly less
   // than the height of the internal image.
   QRect region = screenWindowRegion;
   region.setBottom( qMin(region.bottom(),this->_lines-2) );
 
-  if (    lines == 0
-          || _image == 0
-          || !region.isValid()
-          || (region.top() + abs(lines)) >= region.bottom()
-          || this->_lines <= region.height() ) return;
+  if (lines == 0
+      || _image == nullptr
+      || !region.isValid()
+      || (region.top() + abs(lines)) >= region.bottom()
+      || this->_lines <= region.height() )
+    return;
 
   QRect scrollRect;
 
   void* firstCharPos = &_image[ region.top() * this->_columns ];
   void* lastCharPos = &_image[ (region.top() + abs(lines)) * this->_columns ];
 
   int top = _topMargin + (region.top() * _fontHeight);
   int linesToMove = region.height() - abs(lines);
diff --git a/libgui/qterminal/libqterminal/unix/TerminalView.h b/libgui/qterminal/libqterminal/unix/TerminalView.h
--- a/libgui/qterminal/libqterminal/unix/TerminalView.h
+++ b/libgui/qterminal/libqterminal/unix/TerminalView.h
@@ -61,17 +61,17 @@ class ScreenWindow;
  * TODO More documentation
  */
 class TerminalView : public QWidget
 {
    Q_OBJECT
 
 public:
     /** Constructs a new terminal display widget with the specified parent. */
-    TerminalView(QWidget *parent = 0);
+    TerminalView(QWidget *parent = nullptr);
     virtual ~TerminalView();
 
     /** Returns the terminal color palette used by the display. */
     const ColorEntry* colorTable() const;
     /** Sets the terminal color palette used by the display. */
     void setColorTable(const ColorEntry table[]);
     /**
      * Sets the seed used to generate random colors for the display
diff --git a/libgui/qterminal/libqterminal/unix/kpty.cpp b/libgui/qterminal/libqterminal/unix/kpty.cpp
--- a/libgui/qterminal/libqterminal/unix/kpty.cpp
+++ b/libgui/qterminal/libqterminal/unix/kpty.cpp
@@ -226,17 +226,17 @@ bool KPty::open()
   // Because not all the pty animals are created equal, they want to
   // be opened by several different methods.
 
   // We try, as we know them, one by one.
 
 #ifdef HAVE_OPENPTY
 
   char ptsn[PATH_MAX];
-  if (::openpty( &d->masterFd, &d->slaveFd, ptsn, 0, 0))
+  if (::openpty( &d->masterFd, &d->slaveFd, ptsn, nullptr, nullptr))
   {
     d->masterFd = -1;
     d->slaveFd = -1;
     qWarning() << "Can't open a pseudo teletype";
     return false;
   }
   d->ttyName = ptsn;
 
diff --git a/libgui/src/dialog.cc b/libgui/src/dialog.cc
--- a/libgui/src/dialog.cc
+++ b/libgui/src/dialog.cc
@@ -129,17 +129,17 @@ QUIWidgetCreator::filedialog_finished (c
 
 MessageDialog::MessageDialog (const QString& message,
                               const QString& title,
                               const QString& qsicon,
                               const QStringList& qsbutton,
                               const QString& defbutton,
                               const QStringList& role)
   : QMessageBox (QMessageBox::NoIcon, title.isEmpty () ? " " : title,
-                 message, 0, 0)
+                 message, 0, nullptr)
 {
   // Create a NonModal message.
   setWindowModality (Qt::NonModal);
 
   // Interpret the icon string, because enumeration QMessageBox::Icon can't
   // easily be made to pass through a signal.
   QMessageBox::Icon eicon = QMessageBox::NoIcon;
   if (qsicon == "error")
diff --git a/libgui/src/dialog.h b/libgui/src/dialog.h
--- a/libgui/src/dialog.h
+++ b/libgui/src/dialog.h
@@ -175,17 +175,17 @@ public:
                           const QStringList& role);
 
 private:
 
   void closeEvent (QCloseEvent *)
   {
     // Reroute the close tab to a button click so there is only a single
     // route to waking the wait condition.
-    emit buttonClicked (0);
+    emit buttonClicked (nullptr);
   }
 };
 
 class ListDialog : public QDialog
 {
   Q_OBJECT
 
   QItemSelectionModel *selector;
diff --git a/libgui/src/files-dock-widget.cc b/libgui/src/files-dock-widget.cc
--- a/libgui/src/files-dock-widget.cc
+++ b/libgui/src/files-dock-widget.cc
@@ -64,17 +64,17 @@ public:
 files_dock_widget::files_dock_widget (QWidget *p)
   : octave_dock_widget (p)
 {
   setObjectName ("FilesDockWidget");
   setWindowIcon (QIcon (":/actions/icons/logo.png"));
   set_title (tr ("File Browser"));
   setToolTip (tr ("Browse your files"));
 
-  _sig_mapper = 0;
+  _sig_mapper = nullptr;
 
   _columns_shown = QStringList ();
   _columns_shown.append (tr ("File size"));
   _columns_shown.append (tr ("File type"));
   _columns_shown.append (tr ("Date modified"));
   _columns_shown.append (tr ("Show hidden"));
   _columns_shown.append (tr ("Alternating row colors"));
 
diff --git a/libgui/src/find-files-model.h b/libgui/src/find-files-model.h
--- a/libgui/src/find-files-model.h
+++ b/libgui/src/find-files-model.h
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 #include <QIcon>
 
 
 class find_files_model : public QAbstractListModel
 {
   Q_OBJECT
 
 public:
-  find_files_model (QObject *p=0);
+  find_files_model (QObject *p = nullptr);
   ~find_files_model ();
 
   void clear ();
 
   void addFile (const QFileInfo& info);
 
   int rowCount (const QModelIndex& p = QModelIndex ()) const;
 
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -89,17 +89,17 @@ bool file_editor_tab::_cancelled = false
  The first holds breakpoints, bookmarks, and the debug program counter.
  The second holds line numbers.
  The third holds "fold" marks, to hide sections of text.
  */
 // Make parent null for the file editor tab so that warning
 // WindowModal messages don't affect grandparents.
 file_editor_tab::file_editor_tab (const QString& directory_arg)
 {
-  _lexer_apis = 0;
+  _lexer_apis = nullptr;
   _is_octave_file = true;
   _lines_changed = false;
 
   _ced = directory_arg;
 
   _file_name = "";
   _file_system_watcher.setObjectName ("_qt_autotest_force_engine_poller");
 
@@ -154,17 +154,17 @@ file_editor_tab::file_editor_tab (const 
   // status bar: eol mode
   QLabel *eol_label = new QLabel (tr ("eol:"), this);
   _eol_indicator = new QLabel ("",this);
   _status_bar->addWidget (eol_label, 0);
   _status_bar->addWidget (_eol_indicator, 0);
   _status_bar->addWidget (new QLabel (" ", this), 0);
 
   // Leave the find dialog box out of memory until requested.
-  _find_dialog = 0;
+  _find_dialog = nullptr;
   _find_dialog_is_visible = false;
 
   // symbols
   _edit_area->setMarginType (1, QsciScintilla::SymbolMargin);
   _edit_area->setMarginSensitivity (1, true);
   _edit_area->markerDefine (QsciScintilla::RightTriangle, marker::bookmark);
   _edit_area->setMarkerBackgroundColor (QColor (0,0,232), marker::bookmark);
   _edit_area->markerDefine (QsciScintilla::Circle, marker::breakpoint);
@@ -252,22 +252,22 @@ file_editor_tab::~file_editor_tab (void)
   emit remove_all_breakpoints ();
   emit remove_all_positions ();
 
   // Destroy items attached to _edit_area.
   QsciLexer *lexer = _edit_area->lexer ();
   if (lexer)
     {
       delete lexer;
-      _edit_area->setLexer (0);
+      _edit_area->setLexer (nullptr);
     }
   if (_find_dialog)
     {
       delete _find_dialog;
-      _find_dialog = 0;
+      _find_dialog = nullptr;
     }
 
   // Destroy _edit_area.
   delete _edit_area;
 }
 
 void
 file_editor_tab::set_encoding (const QString& new_encoding)
@@ -532,17 +532,17 @@ file_editor_tab::handle_margin_clicked (
     }
 }
 
 
 void
 file_editor_tab::update_lexer ()
 {
   // Create a new lexer
-  QsciLexer *lexer = 0;
+  QsciLexer *lexer = nullptr;
 
   _is_octave_file = false;
 
   // Find the required lexer from file extensions
   if (_file_name.endsWith (".m")
       || _file_name.endsWith ("octaverc"))
     {
 #if defined (HAVE_LEXER_OCTAVE)
@@ -2487,17 +2487,17 @@ file_editor_tab::change_editor_state (co
   emit editor_state_changed (_copy_available, _is_octave_file);
 }
 
 void
 file_editor_tab::file_name_query (const QWidget *ID)
 {
   // A zero (null pointer) means that all file editor tabs
   // should respond, otherwise just the desired file editor tab.
-  if (ID != this && ID != 0)
+  if (ID != this && ID != nullptr)
     return;
 
   // This list also includes windows with name ""
   emit add_filename_to_list (_file_name, _encoding, this);
 }
 
 void
 file_editor_tab::handle_file_reload_answer (int decision)
@@ -2532,17 +2532,17 @@ file_editor_tab::handle_file_resave_answ
       _edit_area->setModified (false);
       close ();
     }
 }
 
 void
 file_editor_tab::insert_debugger_pointer (const QWidget *ID, int line)
 {
-  if (ID != this || ID == 0)
+  if (ID != this || ID == nullptr)
     return;
 
   emit remove_all_positions ();  // debugger_position, unsure_debugger_position
 
   if (line > 0)
     {
       marker *dp;
 
@@ -2595,52 +2595,52 @@ file_editor_tab::insert_debugger_pointer
 
       center_current_line (false);
     }
 }
 
 void
 file_editor_tab::delete_debugger_pointer (const QWidget *ID, int line)
 {
-  if (ID != this || ID == 0)
+  if (ID != this || ID == nullptr)
     return;
 
   if (line > 0)
     emit remove_position_via_debugger_linenr (line);
 }
 
 void
 file_editor_tab::do_breakpoint_marker (bool insert, const QWidget *ID, int line,
                                        const QString& cond)
 {
-  if (ID != this || ID == 0)
+  if (ID != this || ID == nullptr)
     return;
 
   if (line > 0)
     {
       if (insert)
         {
           int editor_linenr = -1;
           marker *bp = nullptr;
 
           // If comes back indicating a non-zero breakpoint marker,
           // reuse it if possible
           emit find_translated_line_number (line, editor_linenr, bp);
-          if (bp != 0)
+          if (bp != nullptr)
             {
               if ((cond == "") != (bp->get_cond () == ""))
                 {       // can only reuse conditional bp as conditional
                   emit remove_breakpoint_via_debugger_linenr (line);
-                  bp = 0;
+                  bp = nullptr;
                 }
               else
                 bp->set_cond (cond);
             }
 
-          if (bp == 0)
+          if (bp == nullptr)
             {
               bp = new marker (_edit_area, line,
                                cond == "" ? marker::breakpoint
                                           : marker::cond_break, cond);
 
               connect (this, SIGNAL (remove_breakpoint_via_debugger_linenr
                                      (int)),
                        bp,   SLOT (handle_remove_via_original_linenr (int)));
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -52,20 +52,20 @@ file_editor::file_editor (QWidget *p)
   : file_editor_interface (p)
 {
   // Set current editing directory before construct because loaded
   // files will change ced accordingly.
   ced = QDir::currentPath ();
 
   // set action that are later added by the main window to null,
   // preventing access to them when they are still undefined
-  _undo_action = 0;
-  _copy_action = 0;
-  _paste_action = 0;
-  _selectall_action = 0;
+  _undo_action = nullptr;
+  _copy_action = nullptr;
+  _paste_action = nullptr;
+  _selectall_action = nullptr;
   _closed = false;
 
   construct ();
 
   // actions that should also be available in the find dialog
   _fetab_actions << _find_next_action;
   _fetab_actions << _find_previous_action;
 
@@ -86,17 +86,17 @@ file_editor::check_closing (void)
   // all files in the latter case all editor tabs are checked whether
   // they need to be saved. During these ckecked the tabs are not closed
   // since the user might cancel closing octave during one of these saving
   // dialogs. Therefore, saving the session for restoring at next start
   // is not done before the application is definitely closing
 
   // Have all file editor tabs signal what their filenames are.
   editor_tab_map.clear ();
-  emit fetab_file_name_query (0);
+  emit fetab_file_name_query (nullptr);
 
   // Save all tabs with confirmation.
   file_editor_tab::reset_cancel ();
   emit fetab_check_modified_file ();
 
   // If there was a cancellation, make the already saved/discarded tabs
   // recovering from the exit by removing the read-only state and by
   // recovering the debugger breakpoints. Finally return false in order to
@@ -302,17 +302,17 @@ file_editor::request_open_file (const QS
       // This happens if edit is calles without an argument
       // Open eitor with empty edit area instead (as new file would do)
       request_new_file ("");
     }
   else
     {
       // Have all file editor tabs signal what their filenames are.
       editor_tab_map.clear ();
-      emit fetab_file_name_query (0);
+      emit fetab_file_name_query (nullptr);
 
       // Check whether this file is already open in the editor.
       QWidget *tab = find_tab_widget (openFileName);
 
       if (tab)
         {
           _tab_widget->setCurrentWidget (tab);
 
@@ -338,17 +338,17 @@ file_editor::request_open_file (const QS
           file_editor_tab *fileEditorTab = nullptr;
           // Reuse <unnamed> tab if it hasn't yet been modified.
           bool reusing = false;
           tab = find_tab_widget ("");
           if (tab)
             {
               fileEditorTab = static_cast<file_editor_tab *>(tab);
               if (fileEditorTab->qsci_edit_area ()->isModified ())
-                fileEditorTab = 0;
+                fileEditorTab = nullptr;
               else
                 reusing = true;
             }
 
           // If <unnamed> was absent or modified, create a new tab.
           if (! fileEditorTab)
             fileEditorTab = new file_editor_tab ();
 
@@ -407,17 +407,17 @@ file_editor::request_open_file (const QS
                       QSettings *settings = resource_manager::get_settings ();
 
                       if (! settings->value ("editor/create_new_file", false).toBool ())
                         {
                           msgBox = new QMessageBox (QMessageBox::Question,
                                                     tr ("Octave Editor"),
                                                     tr ("File\n%1\ndoes not exist. "
                                                         "Do you want to create it?").arg (openFileName),
-                                                    QMessageBox::NoButton,0);
+                                                    QMessageBox::NoButton,nullptr);
                           QPushButton *create_button =
                             msgBox->addButton (tr ("Create"), QMessageBox::YesRole);
                           msgBox->addButton (tr ("Cancel"), QMessageBox::RejectRole);
                           msgBox->setDefaultButton (create_button);
                           msgBox->exec ();
 
                           QAbstractButton *clicked_button = msgBox->clickedButton ();
                           if (clicked_button != create_button)
@@ -475,17 +475,17 @@ file_editor::request_mru_open_file (QAct
 }
 
 void
 file_editor::check_conflict_save (const QString& saveFileName,
                                   bool remove_on_success)
 {
   // Have all file editor tabs signal what their filenames are.
   editor_tab_map.clear ();
-  emit fetab_file_name_query (0);
+  emit fetab_file_name_query (nullptr);
 
   // Check whether this file is already open in the editor.
   QWidget *tab = find_tab_widget (saveFileName);
 
   if (tab)
     {
       // Note: to overwrite the contents of some other file editor tab
       // with the same name requires identifying which file editor tab
@@ -495,17 +495,17 @@ file_editor::check_conflict_save (const 
       // somewhat confusing to the user.  For now, opt to do nothing.
 
       // Create a NonModal message about error.
       QMessageBox *msgBox
         = new QMessageBox (QMessageBox::Critical, tr ("Octave Editor"),
                            tr ("File not saved! A file with the selected name\n%1\n"
                                "is already open in the editor").
                            arg (saveFileName),
-                           QMessageBox::Ok, 0);
+                           QMessageBox::Ok, nullptr);
 
       msgBox->setWindowModality (Qt::NonModal);
       msgBox->setAttribute (Qt::WA_DeleteOnClose);
       msgBox->show ();
 
       return;
     }
 
@@ -521,17 +521,17 @@ file_editor::check_conflict_save (const 
         }
     }
   if (! saveFileWidget)
     {
       // Create a NonModal message about error.
       QMessageBox *msgBox
         = new QMessageBox (QMessageBox::Critical, tr ("Octave Editor"),
                            tr ("The associated file editor tab has disappeared."),
-                           QMessageBox::Ok, 0);
+                           QMessageBox::Ok, nullptr);
 
       msgBox->setWindowModality (Qt::NonModal);
       msgBox->setAttribute (Qt::WA_DeleteOnClose);
       msgBox->show ();
 
       return;
     }
 
@@ -549,17 +549,17 @@ file_editor::handle_insert_debugger_poin
 void
 file_editor::handle_delete_debugger_pointer_request (const QString& file,
                                                      int line)
 {
   if (! file.isEmpty ())
     {
       // Have all file editor tabs signal what their filenames are.
       editor_tab_map.clear ();
-      emit fetab_file_name_query (0);
+      emit fetab_file_name_query (nullptr);
 
       // Check whether this file is already open in the editor.
       QWidget *tab = find_tab_widget (file);
 
       if (tab)
         {
           _tab_widget->setCurrentWidget (tab);
 
@@ -1610,23 +1610,23 @@ file_editor::construct (void)
 
   _context_help_action = add_action (_help_menu, QIcon (),
           tr ("&Help on Keyword"), SLOT (request_context_help (bool)));
   _context_doc_action = add_action (_help_menu, QIcon (),
           tr ("&Documentation on Keyword"), SLOT (request_context_doc (bool)));
 
   // tab navigation (no menu, only actions)
 
-  _switch_left_tab_action = add_action (0, QIcon (), "",
+  _switch_left_tab_action = add_action (nullptr, QIcon (), "",
                                         SLOT (switch_left_tab ()));
-  _switch_right_tab_action = add_action (0, QIcon (), "",
+  _switch_right_tab_action = add_action (nullptr, QIcon (), "",
                                          SLOT (switch_right_tab ()));
-  _move_tab_left_action = add_action (0, QIcon (), "",
+  _move_tab_left_action = add_action (nullptr, QIcon (), "",
                                       SLOT (move_tab_left ()));
-  _move_tab_right_action = add_action (0, QIcon (), "",
+  _move_tab_right_action = add_action (nullptr, QIcon (), "",
                                        SLOT (move_tab_right ()));
 
   // toolbar
 
   // popdown menu with mru files
   QToolButton *popdown_button = new QToolButton ();
   popdown_button->setToolTip (tr ("Recent Files"));
   popdown_button->setMenu (_mru_file_menu);
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -145,21 +145,21 @@ octave_interpreter::interrupt (void)
 {
   thread_manager.interrupt ();
 }
 
 
 main_window::main_window (QWidget *p, octave::gui_application *app_context)
   : QMainWindow (p), m_app_context (app_context),
     m_interpreter (new octave_interpreter (app_context)),
-    m_main_thread (new QThread ()), _workspace_model (0), status_bar (0),
-    command_window (0), history_window (0), file_browser_window (0),
-    doc_browser_window (0), editor_window (0), workspace_window (0),
-    _settings_dlg (0), find_files_dlg (0), release_notes_window (0),
-    community_news_window (0), _octave_qt_link (0),
+    m_main_thread (new QThread ()), _workspace_model (nullptr), status_bar (nullptr),
+    command_window (nullptr), history_window (nullptr), file_browser_window (nullptr),
+    doc_browser_window (nullptr), editor_window (nullptr), workspace_window (nullptr),
+    _settings_dlg (nullptr), find_files_dlg (nullptr), release_notes_window (nullptr),
+    community_news_window (nullptr), _octave_qt_link (nullptr),
     _clipboard (QApplication::clipboard ()),
     _prevent_readline_conflicts (true),
     _suppress_dbg_location (true),
     _start_gui (app_context && app_context->start_gui_p ()),
     _file_encoding (QString ())
 {
   if (_start_gui)
     {
@@ -231,32 +231,32 @@ main_window::~main_window (void)
   delete history_window;
   delete status_bar;
   delete _workspace_model;
   delete m_interpreter;
   delete m_main_thread;
   if (find_files_dlg)
     {
       delete find_files_dlg;
-      find_files_dlg = 0;
+      find_files_dlg = nullptr;
     }
   if (release_notes_window)
     {
       delete release_notes_window;
-      release_notes_window = 0;
+      release_notes_window = nullptr;
     }
   if (_settings_dlg)
     {
       delete _settings_dlg;
-      _settings_dlg = 0;
+      _settings_dlg = nullptr;
     }
   if (community_news_window)
     {
       delete community_news_window;
-      community_news_window = 0;
+      community_news_window = nullptr;
     }
 }
 
 // catch focus changes and determine the active dock widget
 void
 main_window::focus_changed (QWidget *, QWidget *new_widget)
 {
   octave_dock_widget *dock = nullptr;
@@ -346,31 +346,33 @@ main_window::report_status_message (cons
 {
   status_bar->showMessage (statusMessage, 1000);
 }
 
 void
 main_window::handle_save_workspace_request (void)
 {
   QString file
-    = QFileDialog::getSaveFileName (this, tr ("Save Workspace As"), ".", 0, 0,
+    = QFileDialog::getSaveFileName (this, tr ("Save Workspace As"), ".",
+                                    nullptr, nullptr,
                                     QFileDialog::DontUseNativeDialog);
 
   if (! file.isEmpty ())
     octave_link::post_event (this, &main_window::save_workspace_callback,
                              file.toStdString ());
 }
 
 void
 main_window::handle_load_workspace_request (const QString& file_arg)
 {
   QString file = file_arg;
 
   if (file.isEmpty ())
-    file = QFileDialog::getOpenFileName (this, tr ("Load Workspace"), ".", 0, 0,
+    file = QFileDialog::getOpenFileName (this, tr ("Load Workspace"), ".",
+                                         nullptr, nullptr,
                                          QFileDialog::DontUseNativeDialog);
 
   if (! file.isEmpty ())
     octave_link::post_event (this, &main_window::load_workspace_callback,
                              file.toStdString ());
 }
 
 void
@@ -860,17 +862,17 @@ main_window::notice_settings (const QSet
   _prevent_readline_conflicts
     = settings->value ("shortcuts/prevent_readline_conflicts", true).toBool ();
 
   _suppress_dbg_location
     = ! settings->value ("terminal/print_debug_location", false).toBool ();
 
   resource_manager::update_network_settings ();
 
-  emit active_dock_changed (0, _active_dock); // update dock widget styles
+  emit active_dock_changed (nullptr, _active_dock); // update dock widget styles
 
   configure_shortcuts ();
   set_global_shortcuts (_active_dock == command_window);
   disable_menu_shortcuts (_active_dock == editor_window);
 }
 
 void
 main_window::confirm_shutdown_octave (void)
@@ -947,17 +949,17 @@ main_window::change_directory (const QSt
   _current_directory_combo_box->insertItem (0, dir);
   _current_directory_combo_box->setCurrentIndex (0);
 }
 
 void
 main_window::browse_for_directory (void)
 {
   QString dir
-    = QFileDialog::getExistingDirectory (this, tr ("Browse directories"), 0,
+    = QFileDialog::getExistingDirectory (this, tr ("Browse directories"), nullptr,
                                          QFileDialog::ShowDirsOnly |
                                          QFileDialog::DontUseNativeDialog);
 
   set_current_working_directory (dir);
 
   // FIXME: on Windows systems, the command window freezes after the
   // previous actions.  Forcing the focus appears to unstick it.
 
diff --git a/libgui/src/octave-dock-widget.cc b/libgui/src/octave-dock-widget.cc
--- a/libgui/src/octave-dock-widget.cc
+++ b/libgui/src/octave-dock-widget.cc
@@ -37,17 +37,17 @@ along with Octave; see the file COPYING.
 #include "octave-dock-widget.h"
 
 
 octave_dock_widget::octave_dock_widget (QWidget *p)
   : QDockWidget (p)
 {
   _parent = static_cast<QMainWindow *> (p);     // store main window
   _floating = false;
-  _predecessor_widget = 0;
+  _predecessor_widget = nullptr;
 
   connect (this, SIGNAL (visibilityChanged (bool)),
            this, SLOT (handle_visibility_changed (bool)));
 
   connect (p, SIGNAL (settings_changed (const QSettings*)),
            this, SLOT (handle_settings (const QSettings*)));
 
   connect (p, SIGNAL (active_dock_changed (octave_dock_widget*,
@@ -184,17 +184,17 @@ octave_dock_widget::set_title (const QSt
 
 // set focus to previously active widget in tabbed widget stack
 void
 octave_dock_widget::set_focus_predecessor ()
 {
   if (_predecessor_widget)    // only != 0 if widget was tabbed
     _predecessor_widget->focus ();
 
-  _predecessor_widget = 0;
+  _predecessor_widget = nullptr;
 }
 
 // make the widget floating
 void
 octave_dock_widget::make_window ()
 {
 #if defined (Q_OS_WIN32)
 
diff --git a/libgui/src/octave-gui.cc b/libgui/src/octave-gui.cc
--- a/libgui/src/octave-gui.cc
+++ b/libgui/src/octave-gui.cc
@@ -220,17 +220,17 @@ namespace octave
         shortcut_manager::init_data ();
       }
 
     // Force left-to-right alignment (see bug #46204)
     qt_app.setLayoutDirection (Qt::LeftToRight);
 
     // Create and show main window.
 
-    main_window w (0, this);
+    main_window w (nullptr, this);
 
     if (start_gui)
       {
         w.read_settings ();
 
         w.init_terminal_size ();
 
         // Connect signals for changes in visibility not before w
diff --git a/libgui/src/qtinfo/parser.cc b/libgui/src/qtinfo/parser.cc
--- a/libgui/src/qtinfo/parser.cc
+++ b/libgui/src/qtinfo/parser.cc
@@ -97,40 +97,40 @@ parser::open_file (QFileInfo & file_info
   QIODevice *iodevice = nullptr;
   if (_compressors_map.contains (file_info.suffix ()))
     {
       QString command = _compressors_map.value (file_info.suffix ()).arg (
                           file_info.absoluteFilePath ());
       iprocstream ips (command.toStdString ());
 
       if (ips.bad ())
-        return 0;
+        return nullptr;
 
       QByteArray result;
       char buffer[1024];
 
       while (! ips.eof ())
         {
           ips.read (buffer, sizeof (buffer));
           result.append (buffer, ips.gcount ());
         }
 
       QBuffer *io = new QBuffer (this);
       io->setData (result);
 
       if (! io->open (QIODevice::ReadOnly | QIODevice::Text))
-        return 0;
+        return nullptr;
 
       iodevice = io;
     }
   else
     {
       QFile *io = new QFile (file_info.absoluteFilePath ());
       if (! io->open (QIODevice::ReadOnly | QIODevice::Text))
-        return 0;
+        return nullptr;
       iodevice = io;
     }
 
   return iodevice;
 }
 
 int
 parser::is_ref (const QString& node)
diff --git a/libgui/src/resource-manager.cc b/libgui/src/resource-manager.cc
--- a/libgui/src/resource-manager.cc
+++ b/libgui/src/resource-manager.cc
@@ -58,18 +58,18 @@ default_qt_settings_file (void)
     dsf = (octave::config::oct_etc_dir ()
            + octave::sys::file_ops::dir_sep_str ()
            + "default-qt-settings");
 
   return QString::fromStdString (dsf);
 }
 
 resource_manager::resource_manager (void)
-  : settings_directory (), settings_file (), settings (0),
-    default_settings (0)
+  : settings_directory (), settings_file (), settings (nullptr),
+    default_settings (nullptr)
 {
 #if defined (HAVE_QT4)
   QString home_path
     = QDesktopServices::storageLocation (QDesktopServices::HomeLocation);
 #else
   QString home_path
     = QStandardPaths::writableLocation (QStandardPaths::HomeLocation);
 #endif
@@ -245,17 +245,17 @@ resource_manager::do_set_settings (const
          && settings->isWritable ()
          && settings->status () == QSettings::NoError))
     {
       QString msg = QString (QT_TR_NOOP (
         "The settings file\n%1\n"
         "does not exist and can not be created.\n"
         "Make sure you have read and write permissions to\n%2\n\n"
         "Octave GUI must be closed now."));
-      QMessageBox::critical (0, QString (QT_TR_NOOP ("Octave Critical Error")),
+      QMessageBox::critical (nullptr, QString (QT_TR_NOOP ("Octave Critical Error")),
           msg.arg (do_get_settings_file ()).arg (do_get_settings_directory ()));
       exit (1);
     }
 }
 
 bool
 resource_manager::do_is_first_run (void) const
 {
diff --git a/libgui/src/resource-manager.h b/libgui/src/resource-manager.h
--- a/libgui/src/resource-manager.h
+++ b/libgui/src/resource-manager.h
@@ -45,30 +45,30 @@ public:
   resource_manager (const resource_manager&) = delete;
 
   resource_manager& operator = (const resource_manager&) = delete;
 
   ~resource_manager ();
 
   static QSettings * get_settings (void)
   {
-    return instance_ok () ? instance->do_get_settings () : 0;
+    return instance_ok () ? instance->do_get_settings () : nullptr;
   }
 
   static QIcon icon (const QString& icon_name, bool fallback = true)
   {
     if (instance_ok ())
       return instance->do_icon (icon_name, fallback);
 
     return QIcon ();
   }
 
   static QSettings * get_default_settings (void)
   {
-    return instance_ok () ? instance->do_get_default_settings () : 0;
+    return instance_ok () ? instance->do_get_default_settings () : nullptr;
   }
 
   static QString get_settings_file (void)
   {
     return instance_ok () ? instance->do_get_settings_file () : QString ();
   }
 
   static void reload_settings (void)
@@ -111,17 +111,17 @@ public:
   static QString terminal_color_chars (void) { return "fbsc"; }
   static QStringList terminal_color_names (void);
   static QList<QColor> terminal_default_colors (void);
 
   static resource_manager *instance;
 
 public slots:
 
-  static void cleanup_instance (void) { delete instance; instance = 0; }
+  static void cleanup_instance (void) { delete instance; instance = nullptr; }
 
 private:
 
   static bool instance_ok (void);
 
   QString settings_directory;
 
   QString settings_file;
diff --git a/libgui/src/shortcut-manager.cc b/libgui/src/shortcut-manager.cc
--- a/libgui/src/shortcut-manager.cc
+++ b/libgui/src/shortcut-manager.cc
@@ -354,17 +354,17 @@ shortcut_manager::init (const QString& d
   if (key.startsWith ("main_")
       && actual == QKeySequence (Qt::ControlModifier+Qt::Key_D))
     _settings->setValue ("shortcuts/main_ctrld",true);
 }
 
 void
 shortcut_manager::do_fill_treewidget (QTreeWidget *tree_view)
 {
-  _dialog = 0;
+  _dialog = nullptr;
   _level_hash.clear ();
 
 #if defined (HAVE_QT4)
   tree_view->header ()->setResizeMode (QHeaderView::ResizeToContents);
 #else
   tree_view->header ()->setSectionResizeMode (QHeaderView::ResizeToContents);
 #endif
 
@@ -459,21 +459,21 @@ shortcut_manager::do_write_shortcuts (QS
           && _sc.at (i).actual_sc == QKeySequence (Qt::ControlModifier+Qt::Key_D))
         sc_ctrld = true;
     }
 
   settings->setValue ("shortcuts/main_ctrld",sc_ctrld);
 
   if (closing)
     {
-      delete _dialog;  // the dialog for key sequences can be removed now
-      _dialog = 0;     // make sure it is zero again
+      delete _dialog;     // the dialog for key sequences can be removed now
+      _dialog = nullptr;  // make sure it is zero again
     }
 
-  settings->sync ();    // sync the settings file
+  settings->sync ();      // sync the settings file
 }
 
 void
 shortcut_manager::do_set_shortcut (QAction *action, const QString& key)
 {
   int index;
 
   index = _action_hash[key] - 1;
@@ -689,22 +689,22 @@ shortcut_manager::do_import_export (int 
   if (action != OSC_DEFAULT)
     {
       QString file;
 
       if (action == OSC_IMPORT)
         file = QFileDialog::getOpenFileName (this,
                     tr ("Import shortcuts from file ..."), QString (),
                     tr ("Octave Shortcut Files (*.osc);;All Files (*)"),
-                    0, QFileDialog::DontUseNativeDialog);
+                    nullptr, QFileDialog::DontUseNativeDialog);
       else if (action == OSC_EXPORT)
         file = QFileDialog::getSaveFileName (this,
                     tr ("Export shortcuts into file ..."), QString (),
                     tr ("Octave Shortcut Files (*.osc);;All Files (*)"),
-                    0, QFileDialog::DontUseNativeDialog);
+                    nullptr, QFileDialog::DontUseNativeDialog);
 
       if (file.isEmpty ())
         return false;
 
       QSettings *osc_settings = new QSettings (file, QSettings::IniFormat);
 
       if (! osc_settings)
         {
@@ -717,17 +717,17 @@ shortcut_manager::do_import_export (int 
           if (action == OSC_IMPORT)
             import_shortcuts (osc_settings);   // import (special action)
           else if (action == OSC_EXPORT)
             do_write_shortcuts (osc_settings, false); // export, (save settings)
         }
     }
   else
     {
-      import_shortcuts (0);
+      import_shortcuts (nullptr);
     }
 
   return true;
 }
 
 // enter_shortcut:
 // class derived from QLineEdit for directly entering key sequences which
 enter_shortcut::enter_shortcut (QWidget *p) : QLineEdit (p)
diff --git a/libgui/src/shortcut-manager.h b/libgui/src/shortcut-manager.h
--- a/libgui/src/shortcut-manager.h
+++ b/libgui/src/shortcut-manager.h
@@ -101,17 +101,17 @@ public:
     if (instance_ok ())
       instance->do_import_export (action);
   }
 
   static shortcut_manager *instance;
 
 public slots:
 
-  static void cleanup_instance (void) { delete instance; instance = 0; }
+  static void cleanup_instance (void) { delete instance; instance = nullptr; }
 
 signals:
 
 protected:
 
 protected slots:
 
   void handle_double_clicked (QTreeWidgetItem*, int);
@@ -132,17 +132,17 @@ private:
   void import_shortcuts (QSettings *settings);
   bool overwrite_all_shortcuts (void);
 
   class shortcut_t
   {
   public:
 
     shortcut_t (void)
-      : tree_item (0), description (), settings_key (),
+      : tree_item (nullptr), description (), settings_key (),
         actual_sc (QKeySequence ()), default_sc (QKeySequence ())
     {  }
 
     shortcut_t (const shortcut_t& x)
       : tree_item (x.tree_item), description (x.description),
         settings_key (x.settings_key)
     {
       actual_sc = x.actual_sc;
diff --git a/libgui/src/workspace-model.cc b/libgui/src/workspace-model.cc
--- a/libgui/src/workspace-model.cc
+++ b/libgui/src/workspace-model.cc
@@ -92,17 +92,17 @@ int
 workspace_model::columnCount (const QModelIndex&) const
 {
   return _columnNames.size ();
 }
 
 Qt::ItemFlags
 workspace_model::flags (const QModelIndex& idx) const
 {
-  Qt::ItemFlags retval = 0;
+  Qt::ItemFlags retval = nullptr;
 
   if (idx.isValid ())
     {
       retval |= Qt::ItemIsEnabled;
 
       if (_top_level && idx.column () == 0)
         retval |= Qt::ItemIsSelectable;
     }
diff --git a/libgui/src/workspace-view.cc b/libgui/src/workspace-view.cc
--- a/libgui/src/workspace-view.cc
+++ b/libgui/src/workspace-view.cc
@@ -396,17 +396,17 @@ workspace_view::handle_contextmenu_renam
 
       QInputDialog *inputDialog = new QInputDialog ();
 
       inputDialog->setOptions (QInputDialog::NoButtons);
 
       bool ok = false;
 
       QString new_name
-        = inputDialog->getText (0, "Rename Variable", "New name:",
+        = inputDialog->getText (nullptr, "Rename Variable", "New name:",
                                 QLineEdit::Normal, var_name, &ok);
 
       if (ok && ! new_name.isEmpty ())
         {
           QAbstractItemModel *m = view->model ();
           m->setData (index, new_name, Qt::EditRole);
         }
     }
@@ -501,17 +501,17 @@ workspace_view::notice_settings (const Q
   _columns_shown.append (tr ("Attribute"));
 
   _columns_shown_keys = QStringList ();
   _columns_shown_keys.append ("workspaceview/show_class");
   _columns_shown_keys.append ("workspaceview/show_dimension");
   _columns_shown_keys.append ("workspaceview/show_value");
   _columns_shown_keys.append ("workspaceview/show_attribute");
 
-  _sig_mapper = 0;
+  _sig_mapper = nullptr;
 }
 
 void
 workspace_view::copyClipboard ()
 {
   if (view->hasFocus ())
     handle_contextmenu_copy ();
 }
diff --git a/libinterp/corefcn/__magick_read__.cc b/libinterp/corefcn/__magick_read__.cc
--- a/libinterp/corefcn/__magick_read__.cc
+++ b/libinterp/corefcn/__magick_read__.cc
@@ -1685,17 +1685,17 @@ This is a private internal function not 
     {
       warning ("Magick++ warning: %s", w.what ());
     }
   catch (Magick::Exception& e)
     {
       error ("Magick++ exception: %s", e.what ());
     }
 
-  static const char *fields[] = {"rows", "columns", "format", 0};
+  static const char *fields[] = {"rows", "columns", "format", nullptr};
   octave_scalar_map ping = octave_scalar_map (string_vector (fields));
   ping.setfield ("rows",    octave_value (img.rows ()));
   ping.setfield ("columns", octave_value (img.columns ()));
   ping.setfield ("format",  octave_value (img.magick ()));
 
   return ovl (ping);
 
 #else
@@ -1962,17 +1962,17 @@ Use @code{imfinfo} instead.
     // attribute() to obtain arbitrary ones, that may exist in only some
     // cases.  The following is a list of some methods and into what possible
     // Matlab compatible values they may be converted.
     //
     //  colorSpace()      -> PhotometricInterpretation
     //  backgroundColor() -> BackgroundColor
     //  interlaceType()   -> Interlaced, InterlaceType, and PlanarConfiguration
     //  label()           -> Title
-    0
+    nullptr
   };
 
   // The one we will return at the end
   octave_map info (dim_vector (nFrames, 1), string_vector (fields));
 
   // Some of the fields in the struct are about file information and will be
   // the same for all images in the file.  So we create a template, fill in
   // those values, and make a copy of the template for each image.
@@ -2100,17 +2100,17 @@ Use @code{imfinfo} instead.
         {
           "DateTime",
           "ImageDescription",
           "Make",
           "Model",
           "Software",
           "Artist",
           "Copyright",
-          0,
+          nullptr,
         };
         static const string_vector base_exif_str (base_exif_str_fields);
         static const octave_idx_type n_base_exif_str = base_exif_str.numel ();
         for (octave_idx_type field = 0; field < n_base_exif_str; field++)
           {
             info_frame.setfield (base_exif_str[field],
                                  octave_value (cimg.attribute (base_exif_str[field])));
             fill_exif (info_frame, cimg, base_exif_str[field]);
@@ -2139,17 +2139,17 @@ Use @code{imfinfo} instead.
               "LensMake",
               "LensModel",
               "LensSerialNumber",
               "SpectralSensitivity",
               // These last two are of type undefined but most likely will
               // be strings.  Even if they're not GM returns a string anyway.
               "UserComment",
               "MakerComment",
-              0
+              nullptr
             };
             static const string_vector exif_str (exif_str_fields);
             static const octave_idx_type n_exif_str = exif_str.numel ();
             for (octave_idx_type field = 0; field < n_exif_str; field++)
               fill_exif (camera, cimg, exif_str[field]);
 
             // Listed on the Exif specs as being of type SHORT or LONG.
             static const char *exif_int_fields[] =
@@ -2183,17 +2183,17 @@ Use @code{imfinfo} instead.
               "ExposureMode",
               "WhiteBalance",
               "SceneCaptureType",
               "GainControl",
               "Contrast",
               "Saturation",
               "Sharpness",
               "SubjectDistanceRange",
-              0
+              nullptr
             };
             static const string_vector exif_int (exif_int_fields);
             static const octave_idx_type n_exif_int = exif_int.numel ();
             for (octave_idx_type field = 0; field < n_exif_int; field++)
               fill_exif_ints (camera, cimg, exif_int[field]);
 
             // Listed as RATIONAL or SRATIONAL
             static const char *exif_float_fields[] =
@@ -2211,17 +2211,17 @@ Use @code{imfinfo} instead.
               "FocalLength",
               "FlashEnergy",
               "FocalPlaneXResolution",
               "FocalPlaneYResolution",
               "ExposureIndex",
               "DigitalZoomRatio",
               // Listed as RATIONAL or SRATIONAL with more than 1 count.
               "LensSpecification",
-              0
+              nullptr
             };
             static const string_vector exif_float (exif_float_fields);
             static const octave_idx_type n_exif_float = exif_float.numel ();
             for (octave_idx_type field = 0; field < n_exif_float; field++)
               fill_exif_floats (camera, cimg, exif_float[field]);
 
             // Inside a Exif field, it is possible that there is also a
             // GPS field.  This is not the same as ExifVersion but seems
@@ -2244,27 +2244,27 @@ Use @code{imfinfo} instead.
                   "GPSTrackRef",
                   "GPSImgDirectionRef",
                   "GPSMapDatum",
                   "GPSDestLatitudeRef",
                   "GPSDestLongitudeRef",
                   "GPSDestBearingRef",
                   "GPSDestDistanceRef",
                   "GPSDateStamp",
-                  0
+                  nullptr
                 };
                 static const string_vector gps_str (gps_str_fields);
                 static const octave_idx_type n_gps_str = gps_str.numel ();
                 for (octave_idx_type field = 0; field < n_gps_str; field++)
                   fill_exif (gps, cimg, gps_str[field]);
 
                 static const char *gps_int_fields[] =
                 {
                   "GPSDifferential",
-                  0
+                  nullptr
                 };
                 static const string_vector gps_int (gps_int_fields);
                 static const octave_idx_type n_gps_int = gps_int.numel ();
                 for (octave_idx_type field = 0; field < n_gps_int; field++)
                   fill_exif_ints (gps, cimg, gps_int[field]);
 
                 static const char *gps_float_fields[] =
                 {
@@ -2277,17 +2277,17 @@ Use @code{imfinfo} instead.
                   "GPSDestDistance",
                   "GPSHPositioningError",
                   // Listed as RATIONAL or SRATIONAL with more than 1 count.
                   "GPSLatitude",
                   "GPSLongitude",
                   "GPSTimeStamp",
                   "GPSDestLatitude",
                   "GPSDestLongitude",
-                  0
+                  nullptr
                 };
                 static const string_vector gps_float (gps_float_fields);
                 static const octave_idx_type n_gps_float = gps_float.numel ();
                 for (octave_idx_type field = 0; field < n_gps_float; field++)
                   fill_exif_floats (gps, cimg, gps_float[field]);
 
               }
           }
diff --git a/libinterp/corefcn/c-file-ptr-stream.cc b/libinterp/corefcn/c-file-ptr-stream.cc
--- a/libinterp/corefcn/c-file-ptr-stream.cc
+++ b/libinterp/corefcn/c-file-ptr-stream.cc
@@ -155,17 +155,17 @@ c_file_ptr_buf::buf_close (void)
 {
   int retval = -1;
 
   flush ();
 
   if (f)
     {
       retval = cf (f);
-      f = 0;
+      f = nullptr;
     }
 
   return retval;
 }
 
 int
 c_file_ptr_buf::seek (off_t offset, int origin)
 {
@@ -302,15 +302,15 @@ c_zfile_ptr_buf::buf_close (void)
 {
   int retval = -1;
 
   flush ();
 
   if (f)
     {
       retval = cf (f);
-      f = 0;
+      f = nullptr;
     }
 
   return retval;
 }
 
 #endif
diff --git a/libinterp/corefcn/c-file-ptr-stream.h b/libinterp/corefcn/c-file-ptr-stream.h
--- a/libinterp/corefcn/c-file-ptr-stream.h
+++ b/libinterp/corefcn/c-file-ptr-stream.h
@@ -102,25 +102,25 @@ private:
 
 template <typename STREAM_T, typename FILE_T, typename BUF_T>
 class
 c_file_ptr_stream : public STREAM_T
 {
 public:
 
   c_file_ptr_stream (FILE_T f, typename BUF_T::close_fcn cf = BUF_T::file_close)
-    : STREAM_T (0), buf (new BUF_T (f, cf)) { STREAM_T::init (buf); }
+    : STREAM_T (nullptr), buf (new BUF_T (f, cf)) { STREAM_T::init (buf); }
 
   // No copying!
 
   c_file_ptr_stream (const c_file_ptr_stream&) = delete;
 
   c_file_ptr_stream& operator = (const c_file_ptr_stream&) = delete;
 
-  ~c_file_ptr_stream (void) { delete buf; buf = 0; }
+  ~c_file_ptr_stream (void) { delete buf; buf = nullptr; }
 
   BUF_T * rdbuf (void) { return buf; }
 
   void stream_close (void) { if (buf) buf->buf_close (); }
 
   int seek (off_t offset, int origin)
   { return buf ? buf->seek (offset, origin) : -1; }
 
diff --git a/libinterp/corefcn/call-stack.cc b/libinterp/corefcn/call-stack.cc
--- a/libinterp/corefcn/call-stack.cc
+++ b/libinterp/corefcn/call-stack.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "ov-fcn.h"
 #include "ov-fcn-handle.h"
 #include "ov-usr-fcn.h"
 #include "pager.h"
 
 // Use static fields for the best efficiency.
 // NOTE: C++0x will allow these two to be merged into one.
 static const char *bt_fieldnames[] =
-  { "file", "name", "line", "column", "scope", "context", 0 };
+  { "file", "name", "line", "column", "scope", "context", nullptr };
 static const octave_fields bt_fields (bt_fieldnames);
 
 namespace octave
 {
   std::string
   call_stack::stack_frame::fcn_file_name (void) const
   {
     return m_fcn ? m_fcn->fcn_file_name () : "";
@@ -86,17 +86,17 @@ namespace octave
       return true;
   }
 
   call_stack::call_stack (interpreter& interp)
     : cs (), curr_frame (0), m_interpreter (interp)
   {
     symbol_table& symtab = m_interpreter.get_symbol_table ();
 
-    push (0, symtab.top_scope (), 0);
+    push (nullptr, symtab.top_scope (), 0);
   }
 
   int
   call_stack::current_line (void) const
   {
     int retval = -1;
 
     if (! cs.empty ())
diff --git a/libinterp/corefcn/call-stack.h b/libinterp/corefcn/call-stack.h
--- a/libinterp/corefcn/call-stack.h
+++ b/libinterp/corefcn/call-stack.h
@@ -47,17 +47,17 @@ namespace octave
 
     class stack_frame
     {
     public:
 
       friend class call_stack;
 
       stack_frame (octave_function *fcn = nullptr,
-                   symbol_table::scope *scope = 0,
+                   symbol_table::scope *scope = nullptr,
                    symbol_table::context_id context = 0, size_t prev = 0)
         : m_fcn (fcn), m_line (-1), m_column (-1), m_scope (scope),
           m_context (context), m_prev (prev)
       { }
 
       stack_frame (const stack_frame& elt)
         : m_fcn (elt.m_fcn), m_line (elt.m_line), m_column (elt.m_column),
           m_scope (elt.m_scope), m_context (elt.m_context), m_prev (elt.m_prev)
@@ -122,17 +122,17 @@ namespace octave
 
     size_t size (void) const { return cs.size (); }
 
     size_t num_user_code_frames (octave_idx_type& curr_user_frame) const;
 
     symbol_table::scope *current_scope (void) const
     {
       return (curr_frame > 0 && curr_frame < cs.size ()
-              ? cs[curr_frame].m_scope : 0);
+              ? cs[curr_frame].m_scope : nullptr);
     }
 
     symbol_table::context_id current_context (void) const
     {
       return (curr_frame > 0 && curr_frame < cs.size ()
               ? cs[curr_frame].m_context : 0);
     }
 
diff --git a/libinterp/corefcn/daspk.cc b/libinterp/corefcn/daspk.cc
--- a/libinterp/corefcn/daspk.cc
+++ b/libinterp/corefcn/daspk.cc
@@ -271,18 +271,18 @@ parameters for @code{daspk}.
   call_depth++;
 
   octave::symbol_table& symtab = interp.get_symbol_table ();
 
   if (call_depth > 1)
     error ("daspk: invalid recursive call");
 
   std::string fcn_name, fname, jac_name, jname;
-  daspk_fcn = 0;
-  daspk_jac = 0;
+  daspk_fcn = nullptr;
+  daspk_jac = nullptr;
 
   octave_value f_arg = args(0);
 
   if (f_arg.iscell ())
     {
       Cell c = f_arg.cell_value ();
       if (c.numel () == 1)
         f_arg = c(0);
@@ -312,17 +312,17 @@ parameters for @code{daspk}.
                   jname.append (" (x, xdot, t, cj) jac = ");
                   daspk_jac = extract_function (c(1), "daspk", jac_name,
                                                 jname, "; endfunction");
 
                   if (! daspk_jac)
                     {
                       if (fcn_name.length ())
                         symtab.clear_function (fcn_name);
-                      daspk_fcn = 0;
+                      daspk_fcn = nullptr;
                     }
                 }
             }
         }
       else
         error ("daspk: incorrect number of elements in cell array");
     }
 
@@ -366,17 +366,17 @@ parameters for @code{daspk}.
                     jname.append (" (x, xdot, t, cj) jac = ");
                     daspk_jac = extract_function (tmp(1), "daspk", jac_name,
                                                   jname, "; endfunction");
 
                     if (! daspk_jac)
                       {
                         if (fcn_name.length ())
                           symtab.clear_function (fcn_name);
-                        daspk_fcn = 0;
+                        daspk_fcn = nullptr;
                       }
                   }
               }
             }
         }
     }
 
   if (! daspk_fcn)
diff --git a/libinterp/corefcn/dasrt.cc b/libinterp/corefcn/dasrt.cc
--- a/libinterp/corefcn/dasrt.cc
+++ b/libinterp/corefcn/dasrt.cc
@@ -347,19 +347,19 @@ parameters for @code{dasrt}.
   frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     error ("dasrt: invalid recursive call");
 
   int argp = 0;
   std::string fcn_name, fname, jac_name, jname;
-  dasrt_f = 0;
-  dasrt_j = 0;
-  dasrt_cf = 0;
+  dasrt_f = nullptr;
+  dasrt_j = nullptr;
+  dasrt_cf = nullptr;
 
   octave::symbol_table& symtab = interp.get_symbol_table ();
 
   // Check all the arguments.  Are they the right animals?
 
   // Here's where I take care of f and j in one shot:
 
   octave_value f_arg = args(0);
@@ -395,17 +395,17 @@ parameters for @code{dasrt}.
                   jname.append (" (x, xdot, t, cj) jac = ");
                   dasrt_j = extract_function (c(1), "dasrt", jac_name, jname,
                                               "; endfunction");
 
                   if (! dasrt_j)
                     {
                       if (fcn_name.length ())
                         symtab.clear_function (fcn_name);
-                      dasrt_f = 0;
+                      dasrt_f = nullptr;
                     }
                 }
             }
         }
       else
         error ("dasrt: incorrect number of elements in cell array");
     }
 
@@ -442,17 +442,17 @@ parameters for @code{dasrt}.
                     jac_name = unique_symbol_name ("__dasrt_jac__");
                     jname = "function jac = ";
                     jname.append (jac_name);
                     jname.append (" (x, xdot, t, cj) jac = ");
                     dasrt_j = extract_function (tmp(1), "dasrt", jac_name,
                                                 jname, "; endfunction");
 
                     if (! dasrt_j)
-                      dasrt_f = 0;
+                      dasrt_f = nullptr;
                   }
               }
               break;
 
             default:
               error ("dasrt: first arg should be a string or 2-element string array");
             }
         }
diff --git a/libinterp/corefcn/dassl.cc b/libinterp/corefcn/dassl.cc
--- a/libinterp/corefcn/dassl.cc
+++ b/libinterp/corefcn/dassl.cc
@@ -272,18 +272,18 @@ parameters for @code{dassl}.
   call_depth++;
 
   if (call_depth > 1)
     error ("dassl: invalid recursive call");
 
   octave::symbol_table& symtab = interp.get_symbol_table ();
 
   std::string fcn_name, fname, jac_name, jname;
-  dassl_fcn = 0;
-  dassl_jac = 0;
+  dassl_fcn = nullptr;
+  dassl_jac = nullptr;
 
   octave_value f_arg = args(0);
 
   if (f_arg.iscell ())
     {
       Cell c = f_arg.cell_value ();
       if (c.numel () == 1)
         f_arg = c(0);
@@ -313,17 +313,17 @@ parameters for @code{dassl}.
                   jname.append (" (x, xdot, t, cj) jac = ");
                   dassl_jac = extract_function (c(1), "dassl", jac_name,
                                                 jname, "; endfunction");
 
                   if (! dassl_jac)
                     {
                       if (fcn_name.length ())
                         symtab.clear_function (fcn_name);
-                      dassl_fcn = 0;
+                      dassl_fcn = nullptr;
                     }
                 }
             }
         }
       else
         error ("dassl: incorrect number of elements in cell array");
     }
 
@@ -368,17 +368,17 @@ parameters for @code{dassl}.
                     dassl_jac = extract_function (tmp(1), "dassl",
                                                   jac_name, jname,
                                                   "; endfunction");
 
                     if (! dassl_jac)
                       {
                         if (fcn_name.length ())
                           symtab.clear_function (fcn_name);
-                        dassl_fcn = 0;
+                        dassl_fcn = nullptr;
                       }
                   }
               }
             }
         }
     }
 
   if (! dassl_fcn)
diff --git a/libinterp/corefcn/det.cc b/libinterp/corefcn/det.cc
--- a/libinterp/corefcn/det.cc
+++ b/libinterp/corefcn/det.cc
@@ -40,17 +40,17 @@ along with Octave; see the file COPYING.
 #include "ov-cx-diag.h"
 #include "ov-flt-re-diag.h"
 #include "ov-flt-cx-diag.h"
 #include "ov-perm.h"
 
 #define MAYBE_CAST(VAR, CLASS)                                          \
   const CLASS *VAR = (arg.type_id () == CLASS::static_type_id ()        \
                       ? dynamic_cast<const CLASS *> (&arg.get_rep ())   \
-                      : 0)
+                      : nullptr)
 
 DEFUN (det, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {} det (@var{A})
 @deftypefnx {} {[@var{d}, @var{rcond}] =} det (@var{A})
 Compute the determinant of @var{A}.
 
 Return an estimate of the reciprocal condition number if requested.
diff --git a/libinterp/corefcn/display.h b/libinterp/corefcn/display.h
--- a/libinterp/corefcn/display.h
+++ b/libinterp/corefcn/display.h
@@ -109,17 +109,17 @@ namespace octave
     {
       instance_ok (false);
     }
 
   private:
 
     static display_info *instance;
 
-    static void cleanup_instance (void) { delete instance; instance = 0; }
+    static void cleanup_instance (void) { delete instance; instance = nullptr; }
 
     // Height, width, and depth of the display.
     int m_ht;
     int m_wd;
     int m_dp;
 
     // X- and Y- Resolution of the display in dots (pixels) per inch.
     double m_rx;
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -248,21 +248,21 @@ pr_where_2 (std::ostream& os, const char
 
           if (len > 0)
             {
               if (fmt[len - 1] == '\n')
                 {
                   if (len > 1)
                     {
                       std::string tmp_fmt (fmt, len - 1);
-                      verror (false, os, 0, "", tmp_fmt.c_str (), args);
+                      verror (false, os, nullptr, "", tmp_fmt.c_str (), args);
                     }
                 }
               else
-                verror (false, os, 0, "", fmt, args);
+                verror (false, os, nullptr, "", fmt, args);
             }
         }
     }
   else
     panic ("pr_where_2: invalid format");
 }
 
 static void
@@ -536,17 +536,17 @@ error_1 (octave::execution_exception& e,
                 }
               else
                 {
                   verror (true, os, name, id, fmt, args, with_cfn);
 
                   octave::call_stack& cs
                     = octave::__get_call_stack__ ("error_1");
 
-                  bool in_user_code = cs.caller_user_code () != 0;
+                  bool in_user_code = cs.caller_user_code () != nullptr;
 
                   if (in_user_code && ! discard_error_messages)
                     show_stack_trace = true;
                 }
             }
         }
     }
   else
@@ -758,17 +758,17 @@ warning_1 (const char *id, const char *f
           std::string tmp_fmt (fmt, fmt_len - 1);
           vwarning ("warning", id, tmp_fmt.c_str (), args);
         }
       else
         vwarning ("warning", id, fmt, args);
 
       octave::call_stack& cs = octave::__get_call_stack__ ("warning_1");
 
-      bool in_user_code = cs.caller_user_code () != 0;
+      bool in_user_code = cs.caller_user_code () != nullptr;
 
       if (! fmt_suppresses_backtrace && in_user_code
           && Vbacktrace_on_warning
           && ! discard_warning_messages)
         pr_where (std::cerr, "warning");
 
       if ((octave::application::interactive ()
            || octave::application::forced_interactive ())
@@ -815,49 +815,49 @@ warning_with_id (const char *id, const c
   va_start (args, fmt);
   vwarning_with_id (id, fmt, args);
   va_end (args);
 }
 
 void
 vparse_error (const char *fmt, va_list args)
 {
-  error_1 (std::cerr, 0, "", fmt, args);
+  error_1 (std::cerr, nullptr, "", fmt, args);
 }
 
 void
 parse_error (const char *fmt, ...)
 {
   va_list args;
   va_start (args, fmt);
   vparse_error (fmt, args);
   va_end (args);
 }
 
 void
 vparse_error_with_id (const char *id, const char *fmt, va_list args)
 {
-  error_1 (std::cerr, 0, id, fmt, args);
+  error_1 (std::cerr, nullptr, id, fmt, args);
 }
 
 void
 parse_error_with_id (const char *id, const char *fmt, ...)
 {
   va_list args;
   va_start (args, fmt);
   vparse_error_with_id (id, fmt, args);
   va_end (args);
 }
 
 void
 rethrow_error (const char *id, const char *fmt, ...)
 {
   va_list args;
   va_start (args, fmt);
-  error_1 (std::cerr, 0, id, fmt, args);
+  error_1 (std::cerr, nullptr, id, fmt, args);
   va_end (args);
 }
 
 static std::list<error_stack_frame>
 make_stack_frame_list (const octave_map& stack)
 {
   std::list<error_stack_frame> frames;
 
@@ -887,17 +887,17 @@ make_stack_frame_list (const octave_map&
   return frames;
 }
 
 static void
 rethrow_error_1 (const char *id, const char *fmt, ...)
 {
   va_list args;
   va_start (args, fmt);
-  verror (false, std::cerr, 0, id, fmt, args);
+  verror (false, std::cerr, nullptr, id, fmt, args);
   va_end (args);
 }
 
 OCTAVE_NORETURN static
 void
 rethrow_error (const std::string& id, const std::string& msg,
                const octave_map& stack)
 {
@@ -948,17 +948,17 @@ panic (const char *fmt, ...)
   abort ();
 }
 
 static void
 defun_usage_message_1 (const char *fmt, ...)
 {
   va_list args;
   va_start (args, fmt);
-  error_1 (octave_stdout, 0, "", fmt, args);
+  error_1 (octave_stdout, nullptr, "", fmt, args);
   va_end (args);
 }
 
 void
 defun_usage_message (const std::string& msg)
 {
   defun_usage_message_1 ("%s", msg.c_str ());
 }
diff --git a/libinterp/corefcn/ft-text-renderer.cc b/libinterp/corefcn/ft-text-renderer.cc
--- a/libinterp/corefcn/ft-text-renderer.cc
+++ b/libinterp/corefcn/ft-text-renderer.cc
@@ -151,24 +151,24 @@ namespace octave
         }
 
       if (! instance)
         error ("unable to create ft_manager!");
 
       return retval;
     }
 
-    static void cleanup_instance (void) { delete instance; instance = 0; }
+    static void cleanup_instance (void) { delete instance; instance = nullptr; }
 
     static FT_Face get_font (const std::string& name, const std::string& weight,
                              const std::string& angle, double size)
     {
       return (instance_ok ()
               ? instance->do_get_font (name, weight, angle, size)
-              : 0);
+              : nullptr);
     }
 
     static void font_destroyed (FT_Face face)
     {
       if (instance_ok ())
         instance->do_font_destroyed (face);
     }
 
@@ -182,17 +182,17 @@ namespace octave
     // Cache the fonts loaded by FreeType.  This cache only contains
     // weak references to the fonts, strong references are only present
     // in class text_renderer.
     ft_cache cache;
 
     FT_Face do_get_font (const std::string& name, const std::string& weight,
                          const std::string& angle, double size)
     {
-      FT_Face retval = 0;
+      FT_Face retval = nullptr;
 
 #if defined (HAVE_FT_REFERENCE_FACE)
       // Look first into the font cache, then use fontconfig.  If the font
       // is present in the cache, simply add a reference and return it.
 
       ft_key key (name + ":" + weight + ":" + angle, size);
       ft_cache::const_iterator it = cache.find (key);
 
@@ -231,23 +231,23 @@ namespace octave
           FcPatternAddString (pat, FC_FAMILY,
                               (reinterpret_cast<const FcChar8 *>
                                (name == "*" ? "sans" : name.c_str ())));
 
           FcPatternAddInteger (pat, FC_WEIGHT, fc_weight);
           FcPatternAddInteger (pat, FC_SLANT, fc_angle);
           FcPatternAddDouble (pat, FC_PIXEL_SIZE, size);
 
-          if (FcConfigSubstitute (0, pat, FcMatchPattern))
+          if (FcConfigSubstitute (nullptr, pat, FcMatchPattern))
             {
               FcResult res;
               FcPattern *match;
 
               FcDefaultSubstitute (pat);
-              match = FcFontMatch (0, pat, &res);
+              match = FcFontMatch (nullptr, pat, &res);
 
               // FIXME: originally, this test also required that
               // res != FcResultNoMatch.  Is that really needed?
               if (match)
                 {
                   unsigned char *tmp;
 
                   FcPatternGetString (match, FC_FILE, 0, &tmp);
@@ -302,17 +302,17 @@ namespace octave
     void do_font_destroyed (FT_Face face)
     {
       if (face->generic.data)
         {
           ft_key *pkey = reinterpret_cast<ft_key *> (face->generic.data);
 
           cache.erase (*pkey);
           delete pkey;
-          face->generic.data = 0;
+          face->generic.data = nullptr;
         }
     }
 
   private:
     FT_Library library;
     bool freetype_initialized;
     bool fontconfig_initialized;
   };
@@ -418,20 +418,20 @@ namespace octave
     // Class to hold information about fonts and a strong
     // reference to the font objects loaded by FreeType.
 
     class ft_font : public text_renderer::font
     {
     public:
 
       ft_font (void)
-        : text_renderer::font (), face (0) { }
+        : text_renderer::font (), face (nullptr) { }
 
       ft_font (const std::string& nm, const std::string& wt,
-               const std::string& ang, double sz, FT_Face f = 0)
+               const std::string& ang, double sz, FT_Face f = nullptr)
         : text_renderer::font (nm, wt, ang, sz), face (f)
       { }
 
       ft_font (const ft_font& ft);
 
       ~ft_font (void)
       {
         if (face)
@@ -515,17 +515,17 @@ namespace octave
   };
 
   void
   ft_text_renderer::set_font (const std::string& name, const std::string& weight,
                               const std::string& angle, double size)
   {
     // FIXME: take "fontunits" into account
 
-    font = ft_font (name, weight, angle, size, 0);
+    font = ft_font (name, weight, angle, size, nullptr);
   }
 
   void
   ft_text_renderer::push_new_line (void)
   {
     switch (mode)
       {
       case MODE_BBOX:
@@ -899,17 +899,17 @@ namespace octave
                 else
                   previous = glyph_index;
               }
             else
               {
                 if (r != 0)
                   ::warning ("ft_text_renderer: failed to decode string `%s' with "
                              "locale `%s'", str.c_str (),
-                             std::setlocale (LC_CTYPE, 0));
+                             std::setlocale (LC_CTYPE, nullptr));
                 break;
               }
           }
 
         if (! fs.get_string ().empty ())
           {
             fs.set_y (line_yoffset + yoffset);
             fs.set_color (color);
@@ -1316,17 +1316,17 @@ namespace octave
             std::swap (box(2), box(3));
             box(1) = -box(1)-box(3);
             break;
           }
       }
   }
 
   ft_text_renderer::ft_font::ft_font (const ft_font& ft)
-    : text_renderer::font (ft), face (0)
+    : text_renderer::font (ft), face (nullptr)
   {
 #if defined (HAVE_FT_REFERENCE_FACE)
     FT_Face ft_face = ft.get_face ();
 
     if (ft_face && FT_Reference_Face (ft_face) == 0)
       face = ft_face;
 #endif
   }
@@ -1336,17 +1336,17 @@ namespace octave
   {
     if (&ft != this)
       {
         text_renderer::font::operator = (ft);
 
         if (face)
           {
             FT_Done_Face (face);
-            face = 0;
+            face = nullptr;
           }
 
 #if defined (HAVE_FT_REFERENCE_FACE)
         FT_Face ft_face = ft.get_face ();
 
         if (ft_face && FT_Reference_Face (ft_face) == 0)
           face = ft_face;
 #endif
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -263,17 +263,17 @@ namespace octave
 #if defined (HAVE_FRAMEWORK_OPENGL) && defined (HAVE_GLUTESSCALLBACK_THREEDOTS)
     typedef GLvoid (CALLBACK *fcn) (...);
 #else
     typedef void (CALLBACK *fcn) (void);
 #endif
 
   public:
 
-    opengl_tesselator (void) : glu_tess (0), fill () { init (); }
+    opengl_tesselator (void) : glu_tess (nullptr), fill () { init (); }
 
     // No copying!
 
     opengl_tesselator (const opengl_tesselator&) = delete;
 
     opengl_tesselator operator = (const opengl_tesselator&) = delete;
 
     virtual ~opengl_tesselator (void)
@@ -3424,17 +3424,17 @@ namespace octave
     const Matrix bbox = props.get_extent_matrix ();
 
     // FIXME: handle margin and surrounding box
     bool blend = glIsEnabled (GL_BLEND);
 
     glEnable (GL_BLEND);
     glEnable (GL_ALPHA_TEST);
     glRasterPos3d (pos(0), pos(1), pos.numel () > 2 ? pos(2) : 0.0);
-    glBitmap (0, 0, 0, 0, bbox(0), bbox(1), 0);
+    glBitmap (0, 0, 0, 0, bbox(0), bbox(1), nullptr);
     glDrawPixels (bbox(2), bbox(3),
                   GL_RGBA, GL_UNSIGNED_BYTE, props.get_pixels ().data ());
     glDisable (GL_ALPHA_TEST);
     if (! blend)
       glDisable (GL_BLEND);
 
 #else
 
@@ -4295,17 +4295,17 @@ namespace octave
         uint8NDArray pixels;
         text_to_pixels (txt, pixels, bbox, halign, valign, rotation);
 
         bool blend = glIsEnabled (GL_BLEND);
 
         glEnable (GL_BLEND);
         glEnable (GL_ALPHA_TEST);
         glRasterPos3d (x, y, z);
-        glBitmap(0, 0, 0, 0, bbox(0), bbox(1), 0);
+        glBitmap(0, 0, 0, 0, bbox(0), bbox(1), nullptr);
         glDrawPixels (bbox(2), bbox(3),
                       GL_RGBA, GL_UNSIGNED_BYTE, pixels.data ());
         glDisable (GL_ALPHA_TEST);
 
         if (! blend)
           glDisable (GL_BLEND);
       }
 
diff --git a/libinterp/corefcn/gl2ps-print.cc b/libinterp/corefcn/gl2ps-print.cc
--- a/libinterp/corefcn/gl2ps-print.cc
+++ b/libinterp/corefcn/gl2ps-print.cc
@@ -292,26 +292,26 @@ namespace octave
                 size_t n_end = include_graph.find_last_not_of (" ");
                 include_graph = include_graph.substr (n_begin,
                                                       n_end - n_begin + 1);
               }
             else
               include_graph = "foobar-inc";
 
             // GL2PS_SILENT was removed to allow gl2ps to print errors on stderr
-            GLint ret = gl2psBeginPage ("gl2ps_renderer figure", "Octave", 0,
+            GLint ret = gl2psBeginPage ("gl2ps_renderer figure", "Octave", nullptr,
                                         gl2ps_term, gl2ps_sort,
                                         (GL2PS_NO_BLENDING
                                          | GL2PS_OCCLUSION_CULL
                                          | GL2PS_BEST_ROOT
                                          | gl2ps_text
                                          | GL2PS_DRAW_BACKGROUND
                                          | GL2PS_NO_PS3_SHADING
                                          | GL2PS_USE_CURRENT_VIEWPORT),
-                                        GL_RGBA, 0, 0, 0, 0, 0,
+                                        GL_RGBA, 0, nullptr, 0, 0, 0,
                                         buffsize, tmpf, include_graph.c_str ());
             if (ret == GL2PS_ERROR)
               {
                 old_print_cmd.clear ();
                 error ("gl2ps_renderer::draw: gl2psBeginPage returned GL2PS_ERROR");
               }
 
             opengl_renderer::draw (go);
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -221,30 +221,30 @@ public:
   bool is_linear (void) const
   { return rep->is_linear (); }
 
   scaler& operator = (const scaler& s)
   {
     if (rep)
       {
         delete rep;
-        rep = 0;
+        rep = nullptr;
       }
 
     rep = s.rep->clone ();
 
     return *this;
   }
 
   scaler& operator = (const std::string& s)
   {
     if (rep)
       {
         delete rep;
-        rep = 0;
+        rep = nullptr;
       }
 
     if (s == "log")
       rep = new log_scaler ();
     else if (s == "neglog")
       rep = new neg_log_scaler ();
     else if (s == "linear")
       rep = new lin_scaler ();
@@ -5937,17 +5937,17 @@ private:
 };
 
 class
 graphics_event
 {
 public:
   typedef void (*event_fcn) (void*);
 
-  graphics_event (void) : rep (0) { }
+  graphics_event (void) : rep (nullptr) { }
 
   graphics_event (const graphics_event& e) : rep (e.rep)
   {
     rep->count++;
   }
 
   ~graphics_event (void)
   {
@@ -5969,17 +5969,17 @@ public:
 
     return *this;
   }
 
   void execute (void)
   { if (rep) rep->execute (); }
 
   bool ok (void) const
-  { return (rep != 0); }
+  { return (rep != nullptr); }
 
   static graphics_event
   create_callback_event (const graphics_handle& h,
                          const std::string& name,
                          const octave_value& data = Matrix ());
 
   static graphics_event
   create_callback_event (const graphics_handle& h,
@@ -6015,17 +6015,17 @@ public:
       create_instance ();
 
     if (! instance)
       error ("unable to create gh_manager!");
 
     return retval;
   }
 
-  static void cleanup_instance (void) { delete instance; instance = 0; }
+  static void cleanup_instance (void) { delete instance; instance = nullptr; }
 
   static graphics_handle get_handle (bool integer_figure_handle)
   {
     return instance_ok ()
            ? instance->do_get_handle (integer_figure_handle)
            : graphics_handle ();
   }
 
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -114,17 +114,17 @@ const static char * const operators[] =
   "=",
   "==",
   ">",
   ">=",
   "[",
   "]",
   "|",
   "||",
-  0
+  nullptr
 };
 
 const static string_vector operator_names (operators);
 
 static bool
 looks_like_html (const std::string& msg)
 {
   const size_t p1 = msg.find ('\n');
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -861,17 +861,17 @@ octave_yes_or_no (const std::string& pro
 
       std::string input_buf = interactive_input (prompt_string, eof);
 
       if (input_buf == "yes")
         return true;
       else if (input_buf == "no")
         return false;
       else
-        message (0, "Please answer yes or no.");
+        message (nullptr, "Please answer yes or no.");
     }
 }
 
 DEFUN (yes_or_no, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {@var{ans} =} yes_or_no ("@var{prompt}")
 Ask the user a yes-or-no question.
 
diff --git a/libinterp/corefcn/interpreter.cc b/libinterp/corefcn/interpreter.cc
--- a/libinterp/corefcn/interpreter.cc
+++ b/libinterp/corefcn/interpreter.cc
@@ -355,17 +355,17 @@ namespace octave
       m_symbol_table (),
       m_evaluator (*this),
       m_stream_list (*this),
       m_url_handle_manager (),
       m_cdef_manager (*this),
       m_gtk_manager (),
       m_interactive (false),
       m_read_site_files (true),
-      m_read_init_files (m_app_context != 0),
+      m_read_init_files (m_app_context != nullptr),
       m_verbose (false),
       m_inhibit_startup_message (false),
       m_load_path_initialized (false),
       m_history_initialized (false),
       m_initialized (false)
   {
     if (instance)
       throw std::runtime_error
@@ -837,18 +837,18 @@ namespace octave
 
     unwind_protect frame;
 
     octave_save_signal_mask ();
 
     can_interrupt = true;
 
     octave_signal_hook = signal_handler;
-    octave_interrupt_hook = 0;
-    octave_bad_alloc_hook = 0;
+    octave_interrupt_hook = nullptr;
+    octave_bad_alloc_hook = nullptr;
 
     catch_interrupts ();
 
     octave_initialized = true;
 
     frame.add_method (this, &interpreter::interactive, m_interactive);
 
     m_interactive = false;
@@ -881,18 +881,18 @@ namespace octave
 
     unwind_protect frame;
 
     octave_save_signal_mask ();
 
     can_interrupt = true;
 
     octave_signal_hook = signal_handler;
-    octave_interrupt_hook = 0;
-    octave_bad_alloc_hook = 0;
+    octave_interrupt_hook = nullptr;
+    octave_bad_alloc_hook = nullptr;
 
     catch_interrupts ();
 
     octave_initialized = true;
 
     frame.add_method (this, &interpreter::interactive, m_interactive);
 
     string_vector args = options.all_args ();
@@ -935,18 +935,18 @@ namespace octave
     if (! m_app_context)
       return 0;
 
     octave_save_signal_mask ();
 
     can_interrupt = true;
 
     octave_signal_hook = signal_handler;
-    octave_interrupt_hook = 0;
-    octave_bad_alloc_hook = 0;
+    octave_interrupt_hook = nullptr;
+    octave_bad_alloc_hook = nullptr;
 
     catch_interrupts ();
 
     octave_initialized = true;
 
     // The big loop.
 
     lexer *lxr = (application::interactive ()
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -118,17 +118,17 @@ find_private_file (const std::string& fn
 {
   std::string retval;
 
   // Look in private directory corresponding to current function (if
   // any).
 
   octave::symbol_table::scope *scope = octave::__get_current_scope__ ("find_private_file");
 
-  octave_user_function *curr_fcn = scope ? scope->function () : 0;
+  octave_user_function *curr_fcn = scope ? scope->function () : nullptr;
 
   if (curr_fcn)
     {
       // Even for private functions, dir_name doesn't contain the
       // "private" directory component so we append it here in all
       // cases.
 
       std::string dir_name = curr_fcn->dir_name ();
@@ -277,17 +277,17 @@ namespace octave
           }
       }
 
     // Temporarily disable add hook.
 
     unwind_protect frame;
     frame.protect_var (add_hook);
 
-    add_hook = 0;
+    add_hook = nullptr;
 
     clear ();
 
     for (const auto& elt : elts)
       append (elt, warn);
 
     // Restore add hook and execute for all newly added directories.
     frame.run_first ();
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -1356,29 +1356,29 @@ dump_octave_core (std::ostream& os, cons
             {
               save_mem_size += val_size;
 
               do_save (os, val, name, help, global, fmt, save_as_floats);
             }
         }
     }
 
-  message (0, "save to '%s' complete", fname);
+  message (nullptr, "save to '%s' complete", fname);
 }
 
 void
 dump_octave_core (void)
 {
   if (Vcrash_dumps_octave_core)
     {
       // FIXME: should choose better filename?
 
       const char *fname = Voctave_core_file_name.c_str ();
 
-      message (0, "attempting to save variables to '%s'...", fname);
+      message (nullptr, "attempting to save variables to '%s'...", fname);
 
       load_save_format format = LS_BINARY;
 
       bool save_as_floats = false;
 
       bool append = false;
 
       bool use_zlib = false;
diff --git a/libinterp/corefcn/ls-hdf5.cc b/libinterp/corefcn/ls-hdf5.cc
--- a/libinterp/corefcn/ls-hdf5.cc
+++ b/libinterp/corefcn/ls-hdf5.cc
@@ -230,20 +230,20 @@ hdf5_check_attr (octave_hdf5_id loc_id, 
   H5E_auto_t err_func;
   void *err_func_data;
 
   // turn off error reporting temporarily, but save the error
   // reporting function:
 
 #if defined (HAVE_HDF5_18)
   H5Eget_auto (octave_H5E_DEFAULT, &err_func, &err_func_data);
-  H5Eset_auto (octave_H5E_DEFAULT, 0, 0);
+  H5Eset_auto (octave_H5E_DEFAULT, 0, nullptr);
 #else
   H5Eget_auto (&err_func, &err_func_data);
-  H5Eset_auto (0, 0);
+  H5Eset_auto (0, nullptr);
 #endif
 
   hid_t attr_id = H5Aopen_name (loc_id, attr_name);
 
   if (attr_id >= 0)
     {
       // successful
       retval = true;
@@ -278,20 +278,20 @@ hdf5_get_scalar_attr (octave_hdf5_id loc
   H5E_auto_t err_func;
   void *err_func_data;
 
   // turn off error reporting temporarily, but save the error
   // reporting function:
 
 #if defined (HAVE_HDF5_18)
   H5Eget_auto (octave_H5E_DEFAULT, &err_func, &err_func_data);
-  H5Eset_auto (octave_H5E_DEFAULT, 0, 0);
+  H5Eset_auto (octave_H5E_DEFAULT, 0, nullptr);
 #else
   H5Eget_auto (&err_func, &err_func_data);
-  H5Eset_auto (0, 0);
+  H5Eset_auto (0, nullptr);
 #endif
 
   hid_t attr_id = H5Aopen_name (loc_id, attr_name);
 
   if (attr_id >= 0)
     {
       hid_t space_id = H5Aget_space (attr_id);
 
@@ -656,17 +656,17 @@ hdf5_read_next_data_internal (hid_t grou
 
 done:
   if (retval < 0)
     error ("load: error while reading hdf5 item %s", name);
 
   if (retval > 0)
     {
       // get documentation string, if any:
-      int comment_length = H5Gget_comment (group_id, name, 0, 0);
+      int comment_length = H5Gget_comment (group_id, name, 0, nullptr);
 
       if (comment_length > 1)
         {
           OCTAVE_LOCAL_BUFFER (char, tdoc, comment_length);
           H5Gget_comment (group_id, name, comment_length, tdoc);
           d->doc = tdoc;
         }
       else if (vname != name)
@@ -750,17 +750,17 @@ read_hdf5_data (std::istream& is, const 
   // check if only parts of the data is requested
   bool load_named_vars = argv_idx < argc;
   while (load_named_vars && hs.current_item < static_cast<int> (num_obj))
     {
       std::vector<char> var_name;
       bool found = false;
       size_t len = 0;
 
-      len = H5Gget_objname_by_idx (hs.file_id, hs.current_item, 0, 0);
+      len = H5Gget_objname_by_idx (hs.file_id, hs.current_item, nullptr, 0);
       var_name.resize (len+1);
       H5Gget_objname_by_idx (hs.file_id, hs.current_item, &var_name[0], len+1);
 
       for (int i = argv_idx; i < argc; i++)
         {
           glob_match pattern (argv[i]);
           if (pattern.match (std::string (&var_name[0])))
             {
@@ -905,17 +905,17 @@ save_hdf5_empty (octave_hdf5_id loc_id, 
       dims[i] = d(i);
       if (dims[i] < 1)
         empty = true;
     }
 
   if (! empty)
     return 0;
 
-  space_hid = H5Screate_simple (1, &sz, 0);
+  space_hid = H5Screate_simple (1, &sz, nullptr);
   if (space_hid < 0) return space_hid;
 #if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT);
 #endif
@@ -1076,17 +1076,17 @@ add_hdf5_data (octave_hdf5_id loc_id, co
     goto error_cleanup;
 
   // attach the type of the variable
   type_id = H5Tcopy (H5T_C_S1); H5Tset_size (type_id, t.length () + 1);
   if (type_id < 0)
     goto error_cleanup;
 
   dims[0] = 0;
-  space_id = H5Screate_simple (0 , dims, 0);
+  space_id = H5Screate_simple (0 , dims, nullptr);
   if (space_id < 0)
     goto error_cleanup;
 #if defined (HAVE_HDF5_18)
   data_type_id = H5Dcreate (data_id, "type",  type_id, space_id,
                             octave_H5P_DEFAULT, octave_H5P_DEFAULT,
                             octave_H5P_DEFAULT);
 #else
   data_type_id = H5Dcreate (data_id, "type",  type_id, space_id,
diff --git a/libinterp/corefcn/ls-hdf5.h b/libinterp/corefcn/ls-hdf5.h
--- a/libinterp/corefcn/ls-hdf5.h
+++ b/libinterp/corefcn/ls-hdf5.h
@@ -59,36 +59,36 @@ public:
 
 // input and output streams, subclassing istream and ostream
 // so that we can pass them for stream parameters in the functions below.
 
 class hdf5_ifstream : public hdf5_fstreambase, public std::istream
 {
 public:
 
-  hdf5_ifstream () : hdf5_fstreambase (), std::istream (0) { }
+  hdf5_ifstream () : hdf5_fstreambase (), std::istream (nullptr) { }
 
   hdf5_ifstream (const char *name, int mode = std::ios::in | std::ios::binary,
                  int prot = 0)
-    : hdf5_fstreambase (name, mode, prot), std::istream (0) { }
+    : hdf5_fstreambase (name, mode, prot), std::istream (nullptr) { }
 
   void open (const char *name, int mode = std::ios::in | std::ios::binary,
              int prot = 0)
   { hdf5_fstreambase::open (name, mode, prot); }
 };
 
 class hdf5_ofstream : public hdf5_fstreambase, public std::ostream
 {
 public:
 
-  hdf5_ofstream () : hdf5_fstreambase (), std::ostream (0) { }
+  hdf5_ofstream () : hdf5_fstreambase (), std::ostream (nullptr) { }
 
   hdf5_ofstream (const char *name, int mode = std::ios::out | std::ios::binary,
                  int prot = 0)
-    : hdf5_fstreambase (name, mode, prot), std::ostream (0) { }
+    : hdf5_fstreambase (name, mode, prot), std::ostream (nullptr) { }
 
   void open (const char *name, int mode = std::ios::out | std::ios::binary,
              int prot = 0)
   { hdf5_fstreambase::open (name, mode, prot); }
 };
 
 // Callback data structure for passing data to hdf5_read_next_data, below.
 
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -734,17 +734,17 @@ read_mat5_binary_element (std::istream& 
         double *data;
 
         // Setup return value
         if (imag)
           {
             scm = SparseComplexMatrix (nr, nc, nzmax);
             ridx = scm.ridx ();
             cidx = scm.cidx ();
-            data = 0;
+            data = nullptr;
           }
         else
           {
             sm = SparseMatrix (nr, nc, nzmax);
             ridx = sm.ridx ();
             cidx = sm.cidx ();
             data = sm.data ();
           }
diff --git a/libinterp/corefcn/lsode.cc b/libinterp/corefcn/lsode.cc
--- a/libinterp/corefcn/lsode.cc
+++ b/libinterp/corefcn/lsode.cc
@@ -272,18 +272,18 @@ parameters for @code{lsode}.
   call_depth++;
 
   if (call_depth > 1)
     error ("lsode: invalid recursive call");
 
   octave::symbol_table& symtab = interp.get_symbol_table ();
 
   std::string fcn_name, fname, jac_name, jname;
-  lsode_fcn = 0;
-  lsode_jac = 0;
+  lsode_fcn = nullptr;
+  lsode_jac = nullptr;
 
   octave_value f_arg = args(0);
 
   if (f_arg.iscell ())
     {
       Cell c = f_arg.cell_value ();
       if (c.numel () == 1)
         f_arg = c(0);
@@ -313,17 +313,17 @@ parameters for @code{lsode}.
                   jname.append (" (x, t) jac = ");
                   lsode_jac = extract_function (c(1), "lsode", jac_name,
                                                 jname, "; endfunction");
 
                   if (! lsode_jac)
                     {
                       if (fcn_name.length ())
                         symtab.clear_function (fcn_name);
-                      lsode_fcn = 0;
+                      lsode_fcn = nullptr;
                     }
                 }
             }
         }
       else
         error ("lsode: incorrect number of elements in cell array");
     }
 
@@ -368,17 +368,17 @@ parameters for @code{lsode}.
                     lsode_jac = extract_function (tmp(1), "lsode",
                                                   jac_name, jname,
                                                   "; endfunction");
 
                     if (! lsode_jac)
                       {
                         if (fcn_name.length ())
                           symtab.clear_function (fcn_name);
-                        lsode_fcn = 0;
+                        lsode_fcn = nullptr;
                       }
                   }
               }
               break;
 
             default:
               error ("lsode: first arg should be a string or 2-element string array");
             }
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -155,17 +155,17 @@ calc_single_subscript_internal (mwSize n
 static inline void * maybe_mark_foreign (void *ptr);
 
 class mxArray_octave_value : public mxArray_base
 {
 public:
 
   mxArray_octave_value (const octave_value& ov)
     : mxArray_base (), val (ov), mutate_flag (false),
-      id (mxUNKNOWN_CLASS), class_name (0), ndims (-1), dims (0) { }
+      id (mxUNKNOWN_CLASS), class_name (nullptr), ndims (-1), dims (nullptr) { }
 
   // No assignment!  FIXME: should this be implemented?  Note that we
   // do have a copy constructor.
 
   mxArray_octave_value& operator = (const mxArray_octave_value&) = delete;
 
   mxArray_base * dup (void) const { return new mxArray_octave_value (*this); }
 
@@ -183,28 +183,28 @@ public:
 
         // set_class_name will handle deleting class name that comes
         // from as_mxArray conversion function.
 
         if (class_name)
           {
             retval->set_class_name (class_name);
 
-            class_name = 0;
+            class_name = nullptr;
           }
 
         if (dims)
           {
             mwSize *xdims = retval->get_dimensions ();
 
             mxFree (xdims);
 
             retval->set_dimensions (dims, ndims);
 
-            dims = 0;
+            dims = nullptr;
           }
       }
 
     return retval;
   }
 
   ~mxArray_octave_value (void)
   {
@@ -375,17 +375,17 @@ public:
   }
 
   // Not allowed.
   void set_class_name (const char * /*name_arg*/) { request_mutation (); }
 
   mxArray * get_cell (mwIndex /*idx*/) const
   {
     request_mutation ();
-    return 0;
+    return nullptr;
   }
 
   // Not allowed.
   void set_cell (mwIndex /*idx*/, mxArray * /*val*/) { request_mutation (); }
 
   double get_scalar (void) const
   {
     if (val.issparse ())
@@ -418,17 +418,17 @@ public:
     return retval;
   }
 
   void * get_imag_data (void) const
   {
     void *retval = nullptr;
 
     if (is_numeric () && isreal ())
-      retval = 0;
+      retval = nullptr;
     else
       request_mutation ();
 
     return retval;
   }
 
   // Not allowed.
   void set_data (void * /*pr*/) { request_mutation (); }
@@ -465,32 +465,32 @@ public:
   }
 
   // Not allowed.
   void remove_field (int /*key_num*/) { request_mutation (); }
 
   mxArray * get_field_by_number (mwIndex /*index*/, int /*key_num*/) const
   {
     request_mutation ();
-    return 0;
+    return nullptr;
   }
 
   // Not allowed.
   void set_field_by_number (mwIndex /*index*/, int /*key_num*/,
                             mxArray * /*val*/)
   {
     request_mutation ();
   }
 
   int get_number_of_fields (void) const { return val.nfields (); }
 
   const char * get_field_name_by_number (int /*key_num*/) const
   {
     request_mutation ();
-    return 0;
+    return nullptr;
   }
 
   int get_field_number (const char * /*key*/) const
   {
     request_mutation ();
     return 0;
   }
 
@@ -598,17 +598,17 @@ public:
 protected:
 
   mxArray_octave_value (const mxArray_octave_value& arg)
     : mxArray_base (arg), val (arg.val), mutate_flag (arg.mutate_flag),
       id (arg.id), class_name (mxArray::strsave (arg.class_name)),
       ndims (arg.ndims),
       dims (ndims > 0 ? static_cast<mwSize *>
                          (mxArray::malloc (ndims * sizeof (mwSize)))
-                      : 0)
+                      : nullptr)
   {
     if (dims)
       {
         for (mwIndex i = 0; i < ndims; i++)
           dims[i] = arg.dims[i];
       }
   }
 
@@ -631,20 +631,20 @@ private:
 // The base class for the Matlab-style representation, used to handle
 // things that are common to all Matlab-style objects.
 
 class mxArray_matlab : public mxArray_base
 {
 protected:
 
   mxArray_matlab (mxClassID id_arg = mxUNKNOWN_CLASS)
-    : mxArray_base (), class_name (0), id (id_arg), ndims (0), dims (0) { }
+    : mxArray_base (), class_name (nullptr), id (id_arg), ndims (0), dims (nullptr) { }
 
   mxArray_matlab (mxClassID id_arg, mwSize ndims_arg, const mwSize *dims_arg)
-    : mxArray_base (), class_name (0), id (id_arg),
+    : mxArray_base (), class_name (nullptr), id (id_arg),
       ndims (ndims_arg < 2 ? 2 : ndims_arg),
       dims (static_cast<mwSize *> (mxArray::malloc (ndims * sizeof (mwSize))))
   {
     if (ndims_arg == 0)
       {
         dims[0] = 0;
         dims[1] = 0;
       }
@@ -662,34 +662,34 @@ protected:
         if (dims[i] == 1)
           ndims--;
         else
           break;
       }
   }
 
   mxArray_matlab (mxClassID id_arg, const dim_vector& dv)
-    : mxArray_base (), class_name (0), id (id_arg),
+    : mxArray_base (), class_name (nullptr), id (id_arg),
       ndims (dv.ndims ()),
       dims (static_cast<mwSize *> (mxArray::malloc (ndims * sizeof (mwSize))))
   {
     for (mwIndex i = 0; i < ndims; i++)
       dims[i] = dv(i);
 
     for (mwIndex i = ndims - 1; i > 1; i--)
       {
         if (dims[i] == 1)
           ndims--;
         else
           break;
       }
   }
 
   mxArray_matlab (mxClassID id_arg, mwSize m, mwSize n)
-    : mxArray_base (), class_name (0), id (id_arg), ndims (2),
+    : mxArray_base (), class_name (nullptr), id (id_arg), ndims (2),
       dims (static_cast<mwSize *> (mxArray::malloc (ndims * sizeof (mwSize))))
   {
     dims[0] = m;
     dims[1] = n;
   }
 
   mxArray_matlab (const mxArray_matlab& val)
     : mxArray_base (val), class_name (mxArray::strsave (val.class_name)),
@@ -799,17 +799,17 @@ public:
 
         for (int i = 0; i < ndims; i++)
           dims[i] = dims_arg[i];
 
         return 0;
       }
     else
       {
-        dims = 0;
+        dims = nullptr;
         return 0;
       }
   }
 
   mwSize get_number_of_elements (void) const
   {
     mwSize retval = dims[0];
 
@@ -1047,78 +1047,78 @@ public:
                                   get_element_size ())
                : mxArray::malloc (get_number_of_elements ()
                                   * get_element_size ())),
       pi (flag == mxCOMPLEX
             ? (init ? mxArray::calloc (get_number_of_elements (),
                                        get_element_size ())
                     : mxArray::malloc (get_number_of_elements ()
                                        * get_element_size ()))
-            : 0) { }
+            : nullptr) { }
 
   mxArray_number (mxClassID id_arg, const dim_vector& dv,
                   mxComplexity flag = mxREAL)
     : mxArray_matlab (id_arg, dv),
       pr (mxArray::calloc (get_number_of_elements (), get_element_size ())),
       pi (flag == mxCOMPLEX ? mxArray::calloc (get_number_of_elements (),
                                                get_element_size ())
-                            : 0)
+                            : nullptr)
   { }
 
   mxArray_number (mxClassID id_arg, mwSize m, mwSize n,
                   mxComplexity flag = mxREAL, bool init = true)
     : mxArray_matlab (id_arg, m, n),
       pr (init ? mxArray::calloc (get_number_of_elements (),
                                   get_element_size ())
                : mxArray::malloc (get_number_of_elements ()
                                   * get_element_size ())),
       pi (flag == mxCOMPLEX
             ? (init ? mxArray::calloc (get_number_of_elements (),
                                        get_element_size ())
                     : mxArray::malloc (get_number_of_elements ()
                                        * get_element_size ()))
-            : 0)
+            : nullptr)
   { }
 
   mxArray_number (mxClassID id_arg, double val)
     : mxArray_matlab (id_arg, 1, 1),
       pr (mxArray::calloc (get_number_of_elements (), get_element_size ())),
-      pi (0)
+      pi (nullptr)
   {
     double *dpr = static_cast<double *> (pr);
     dpr[0] = val;
   }
 
   mxArray_number (mxClassID id_arg, mxLogical val)
     : mxArray_matlab (id_arg, 1, 1),
       pr (mxArray::calloc (get_number_of_elements (), get_element_size ())),
-      pi (0)
+      pi (nullptr)
   {
     mxLogical *lpr = static_cast<mxLogical *> (pr);
     lpr[0] = val;
   }
 
   mxArray_number (const char *str)
     : mxArray_matlab (mxCHAR_CLASS,
                       str ? (strlen (str) ? 1 : 0) : 0,
                       str ? strlen (str) : 0),
     pr (mxArray::calloc (get_number_of_elements (), get_element_size ())),
-    pi (0)
+    pi (nullptr)
   {
     mxChar *cpr = static_cast<mxChar *> (pr);
     mwSize nel = get_number_of_elements ();
     for (mwIndex i = 0; i < nel; i++)
       cpr[i] = str[i];
   }
 
   // FIXME: ???
   mxArray_number (mwSize m, const char **str)
     : mxArray_matlab (mxCHAR_CLASS, m, max_str_len (m, str)),
       pr (mxArray::calloc (get_number_of_elements (), get_element_size ())),
-      pi (0)
+      pi (nullptr)
   {
     mxChar *cpr = static_cast<mxChar *> (pr);
 
     mwSize *dv = get_dimensions ();
 
     mwSize nc = dv[1];
 
     for (mwIndex j = 0; j < m; j++)
@@ -1137,17 +1137,17 @@ public:
 
 protected:
 
   mxArray_number (const mxArray_number& val)
     : mxArray_matlab (val),
       pr (mxArray::malloc (get_number_of_elements () * get_element_size ())),
       pi (val.pi ? mxArray::malloc (get_number_of_elements ()
                                     * get_element_size ())
-                 : 0)
+                 : nullptr)
   {
     size_t nbytes = get_number_of_elements () * get_element_size ();
 
     if (pr)
       memcpy (pr, val.pr, nbytes);
 
     if (pi)
       memcpy (pi, val.pi, nbytes);
@@ -1163,17 +1163,17 @@ public:
   mxArray_base * dup (void) const { return new mxArray_number (*this); }
 
   ~mxArray_number (void)
   {
     mxFree (pr);
     mxFree (pi);
   }
 
-  int is_complex (void) const { return pi != 0; }
+  int is_complex (void) const { return pi != nullptr; }
 
   double get_scalar (void) const
   {
     double retval = 0;
 
     switch (get_class_id ())
       {
       case mxDOUBLE_CLASS:
@@ -1454,27 +1454,27 @@ private:
 class mxArray_sparse : public mxArray_matlab
 {
 public:
 
   mxArray_sparse (mxClassID id_arg, mwSize m, mwSize n, mwSize nzmax_arg,
                   mxComplexity flag = mxREAL)
     : mxArray_matlab (id_arg, m, n), nzmax (nzmax_arg),
       pr (mxArray::calloc (nzmax, get_element_size ())),
-      pi (flag == mxCOMPLEX ? mxArray::calloc (nzmax, get_element_size ()) : 0),
+      pi (flag == mxCOMPLEX ? mxArray::calloc (nzmax, get_element_size ()) : nullptr),
       ir (static_cast<mwIndex *> (mxArray::calloc (nzmax, sizeof (mwIndex)))),
       jc (static_cast<mwIndex *> (mxArray::calloc (n + 1, sizeof (mwIndex))))
   { }
 
 private:
 
   mxArray_sparse (const mxArray_sparse& val)
     : mxArray_matlab (val), nzmax (val.nzmax),
       pr (mxArray::malloc (nzmax * get_element_size ())),
-      pi (val.pi ? mxArray::malloc (nzmax * get_element_size ()) : 0),
+      pi (val.pi ? mxArray::malloc (nzmax * get_element_size ()) : nullptr),
       ir (static_cast<mwIndex *> (mxArray::malloc (nzmax * sizeof (mwIndex)))),
       jc (static_cast<mwIndex *> (mxArray::malloc (nzmax * sizeof (mwIndex))))
   {
     size_t nbytes = nzmax * get_element_size ();
 
     if (pr)
       memcpy (pr, val.pr, nbytes);
 
@@ -1500,17 +1500,17 @@ public:
   ~mxArray_sparse (void)
   {
     mxFree (pr);
     mxFree (pi);
     mxFree (ir);
     mxFree (jc);
   }
 
-  int is_complex (void) const { return pi != 0; }
+  int is_complex (void) const { return pi != nullptr; }
 
   int is_sparse (void) const { return 1; }
 
   void * get_data (void) const { return pr; }
 
   void * get_imag_data (void) const { return pi; }
 
   void set_data (void *pr_arg) { pr = pr_arg; }
@@ -1674,17 +1674,17 @@ private:
     for (int i = 0; i < nfields; i++)
       fields[i] = mxArray::strsave (val.fields[i]);
 
     mwSize nel = get_number_of_elements ();
 
     for (mwIndex i = 0; i < nel * nfields; i++)
       {
         mxArray *ptr = val.data[i];
-        data[i] = (ptr ? ptr->dup () : 0);
+        data[i] = (ptr ? ptr->dup () : nullptr);
       }
   }
 
 public:
 
   // No assignment!  FIXME: should this be implemented?  Note that we
   // do have a copy constructor.
 
@@ -1741,17 +1741,17 @@ public:
                 mwIndex j = 0;
                 mwIndex k = 0;
                 mwIndex n = 0;
 
                 for (mwIndex i = 0; i < ntot; i++)
                   {
                     if (++n == nfields)
                       {
-                        new_data[j++] = 0;
+                        new_data[j++] = nullptr;
                         n = 0;
                       }
                     else
                       new_data[j++] = data[k++];
                   }
 
                 mxFree (data);
 
@@ -1814,26 +1814,26 @@ public:
         fields = new_fields;
         data = new_data;
       }
   }
 
   mxArray * get_field_by_number (mwIndex index, int key_num) const
   {
     return key_num >= 0 && key_num < nfields
-           ? data[nfields * index + key_num] : 0;
+           ? data[nfields * index + key_num] : nullptr;
   }
 
   void set_field_by_number (mwIndex index, int key_num, mxArray *val);
 
   int get_number_of_fields (void) const { return nfields; }
 
   const char * get_field_name_by_number (int key_num) const
   {
-    return key_num >= 0 && key_num < nfields ? fields[key_num] : 0;
+    return key_num >= 0 && key_num < nfields ? fields[key_num] : nullptr;
   }
 
   int get_field_number (const char *key) const
   {
     int retval = -1;
 
     for (int i = 0; i < nfields; i++)
       {
@@ -1914,17 +1914,17 @@ private:
       data (static_cast<mxArray **> (mxArray::malloc (get_number_of_elements ()
                                                       * sizeof (mxArray *))))
   {
     mwSize nel = get_number_of_elements ();
 
     for (mwIndex i = 0; i < nel; i++)
       {
         mxArray *ptr = val.data[i];
-        data[i] = (ptr ? ptr->dup () : 0);
+        data[i] = (ptr ? ptr->dup () : nullptr);
       }
   }
 
 public:
 
   // No assignment!  FIXME: should this be implemented?  Note that we
   // do have a copy constructor.
 
@@ -1939,17 +1939,17 @@ public:
     for (mwIndex i = 0; i < nel; i++)
       delete data[i];
 
     mxFree (data);
   }
 
   mxArray * get_cell (mwIndex idx) const
   {
-    return idx >= 0 && idx < get_number_of_elements () ? data[idx] : 0;
+    return idx >= 0 && idx < get_number_of_elements () ? data[idx] : nullptr;
   }
 
   void set_cell (mwIndex idx, mxArray *val);
 
   void * get_data (void) const { return data; }
 
   void set_data (void *data_arg) { data = static_cast<mxArray **> (data_arg); }
 
@@ -1972,63 +1972,63 @@ public:
 private:
 
   mxArray **data;
 };
 
 // ------------------------------------------------------------------
 
 mxArray::mxArray (const octave_value& ov)
-  : rep (new mxArray_octave_value (ov)), name (0) { }
+  : rep (new mxArray_octave_value (ov)), name (nullptr) { }
 
 mxArray::mxArray (mxClassID id, mwSize ndims, const mwSize *dims,
                   mxComplexity flag, bool init)
-  : rep (new mxArray_number (id, ndims, dims, flag, init)), name (0) { }
+  : rep (new mxArray_number (id, ndims, dims, flag, init)), name (nullptr) { }
 
 mxArray::mxArray (mxClassID id, const dim_vector& dv, mxComplexity flag)
-  : rep (new mxArray_number (id, dv, flag)), name (0) { }
+  : rep (new mxArray_number (id, dv, flag)), name (nullptr) { }
 
 mxArray::mxArray (mxClassID id, mwSize m, mwSize n,
                   mxComplexity flag, bool init)
-  : rep (new mxArray_number (id, m, n, flag, init)), name (0) { }
+  : rep (new mxArray_number (id, m, n, flag, init)), name (nullptr) { }
 
 mxArray::mxArray (mxClassID id, double val)
-  : rep (new mxArray_number (id, val)), name (0) { }
+  : rep (new mxArray_number (id, val)), name (nullptr) { }
 
 mxArray::mxArray (mxClassID id, mxLogical val)
-  : rep (new mxArray_number (id, val)), name (0) { }
+  : rep (new mxArray_number (id, val)), name (nullptr) { }
 
 mxArray::mxArray (const char *str)
-  : rep (new mxArray_number (str)), name (0) { }
+  : rep (new mxArray_number (str)), name (nullptr) { }
 
 mxArray::mxArray (mwSize m, const char **str)
-  : rep (new mxArray_number (m, str)), name (0) { }
+  : rep (new mxArray_number (m, str)), name (nullptr) { }
 
 mxArray::mxArray (mxClassID id, mwSize m, mwSize n, mwSize nzmax,
                   mxComplexity flag)
-  : rep (new mxArray_sparse (id, m, n, nzmax, flag)), name (0) { }
+  : rep (new mxArray_sparse (id, m, n, nzmax, flag)), name (nullptr) { }
 
 mxArray::mxArray (mwSize ndims, const mwSize *dims, int num_keys,
                   const char **keys)
-  : rep (new mxArray_struct (ndims, dims, num_keys, keys)), name (0) { }
+  : rep (new mxArray_struct (ndims, dims, num_keys, keys)), name (nullptr) { }
 
 mxArray::mxArray (const dim_vector& dv, int num_keys, const char **keys)
-  : rep (new mxArray_struct (dv, num_keys, keys)), name (0) { }
+  : rep (new mxArray_struct (dv, num_keys, keys)), name (nullptr) { }
 
 mxArray::mxArray (mwSize m, mwSize n, int num_keys, const char **keys)
-  : rep (new mxArray_struct (m, n, num_keys, keys)), name (0) { }
+  : rep (new mxArray_struct (m, n, num_keys, keys)), name (nullptr) { }
 
 mxArray::mxArray (mwSize ndims, const mwSize *dims)
-  : rep (new mxArray_cell (ndims, dims)), name (0) { }
+  : rep (new mxArray_cell (ndims, dims)), name (nullptr) { }
 
 mxArray::mxArray (const dim_vector& dv)
-  : rep (new mxArray_cell (dv)), name (0) { }
+  : rep (new mxArray_cell (dv)), name (nullptr) { }
 
 mxArray::mxArray (mwSize m, mwSize n)
-  : rep (new mxArray_cell (m, n)), name (0) { }
+  : rep (new mxArray_cell (m, n)), name (nullptr) { }
 
 mxArray::~mxArray (void)
 {
   mxFree (name);
 
   delete rep;
 }
 
@@ -2061,33 +2061,33 @@ mxArray::maybe_mutate (void) const
       // to replace the existing rep with the rep from the new object.
 
       mxArray *new_val = rep->mutate ();
 
       if (new_val)
         {
           delete rep;
           rep = new_val->rep;
-          new_val->rep = 0;
+          new_val->rep = nullptr;
           delete new_val;
         }
     }
 }
 
 // ------------------------------------------------------------------
 
 // A class to manage calls to MEX functions.  Mostly deals with memory
 // management.
 
 class mex
 {
 public:
 
   mex (octave_mex_function *f)
-    : curr_mex_fcn (f), memlist (), arraylist (), fname (0) { }
+    : curr_mex_fcn (f), memlist (), arraylist (), fname (nullptr) { }
 
   // No copying!
 
   mex (const mex&) = delete;
 
   mex& operator = (const mex&) = delete;
 
   ~mex (void)
@@ -3096,22 +3096,22 @@ call_mex (octave_mex_function& mex_fcn, 
   // Use at least 1 for nargout since even for zero specified args,
   // still want to be able to return an ans.
 
   volatile int nargout = nargout_arg;
 
   int nargin = args.length ();
   OCTAVE_LOCAL_BUFFER (mxArray *, argin, nargin);
   for (int i = 0; i < nargin; i++)
-    argin[i] = 0;
+    argin[i] = nullptr;
 
   int nout = (nargout == 0 ? 1 : nargout);
   OCTAVE_LOCAL_BUFFER (mxArray *, argout, nout);
   for (int i = 0; i < nout; i++)
-    argout[i] = 0;
+    argout[i] = nullptr;
 
   octave::unwind_protect_safe frame;
 
   // Save old mex pointer.
   frame.protect_var (mex_context);
 
   mex context (&mex_fcn);
 
@@ -3217,17 +3217,17 @@ mexCallMATLAB (int nargout, mxArray *arg
       // FIXME: it would be nice to avoid copying the value here,
       // but there is no way to steal memory from a matrix, never mind
       // that matrix memory is allocated by new[] and mxArray memory
       // is allocated by malloc().
       argout[i] = mex_context->make_value (retval(i));
     }
 
   while (num_to_copy < nargout)
-    argout[num_to_copy++] = 0;
+    argout[num_to_copy++] = nullptr;
 
   return execution_error ? 1 : 0;
 }
 
 mxArray *
 mexCallMATLABWithTrap (int nargout, mxArray *argout[], int nargin,
                        mxArray *argin[], const char *fname)
 {
diff --git a/libinterp/corefcn/mxarray.in.h b/libinterp/corefcn/mxarray.in.h
--- a/libinterp/corefcn/mxarray.in.h
+++ b/libinterp/corefcn/mxarray.in.h
@@ -132,17 +132,17 @@ class mxArray_base
 protected:
 
   mxArray_base (void) { }
 
 public:
 
   virtual mxArray_base * dup (void) const = 0;
 
-  virtual mxArray * as_mxArray (void) const { return 0; }
+  virtual mxArray * as_mxArray (void) const { return nullptr; }
 
   virtual ~mxArray_base (void) = default;
 
   virtual bool is_octave_value (void) const { return false; }
 
   virtual int iscell (void) const = 0;
 
   virtual int is_char (void) const = 0;
@@ -275,17 +275,17 @@ public:
   virtual char * array_to_string (void) const = 0;
 
   virtual mwIndex calc_single_subscript (mwSize nsubs, mwIndex *subs) const = 0;
 
   virtual size_t get_element_size (void) const = 0;
 
   virtual bool mutation_needed (void) const { return false; }
 
-  virtual mxArray * mutate (void) const { return 0; }
+  virtual mxArray * mutate (void) const { return nullptr; }
 
   virtual octave_value as_octave_value (void) const = 0;
 
 protected:
 
   mxArray_base (const mxArray_base&) { }
 
   OCTAVE_DEPRECATED (4.2, "use 'err_invalid_type' instead")
diff --git a/libinterp/corefcn/oct-errno.h b/libinterp/corefcn/oct-errno.h
--- a/libinterp/corefcn/oct-errno.h
+++ b/libinterp/corefcn/oct-errno.h
@@ -39,17 +39,17 @@ protected:
   octave_errno (void);
 
 public:
 
   ~octave_errno (void) = default;
 
   static bool instance_ok (void);
 
-  static void cleanup_instance (void) { delete instance; instance = 0; }
+  static void cleanup_instance (void) { delete instance; instance = nullptr; }
 
   static int lookup (const std::string& name);
 
   static octave_scalar_map list (void);
 
   static int get (void) { return errno; }
 
   static int set (int val)
diff --git a/libinterp/corefcn/oct-hist.cc b/libinterp/corefcn/oct-hist.cc
--- a/libinterp/corefcn/oct-hist.cc
+++ b/libinterp/corefcn/oct-hist.cc
@@ -282,17 +282,17 @@ edit_history_readline (std::fstream& str
         }
       else
         line[lindex++] = c;
     }
 
   if (! lindex)
     {
       delete [] line;
-      return 0;
+      return nullptr;
     }
 
   if (lindex + 2 >= line_len)
     {
       char *tmp_line = new char [lindex+3];
       strcpy (tmp_line, line);
       delete [] line;
       line = tmp_line;
@@ -470,17 +470,17 @@ do_edit_history (octave::interpreter& in
 
   // Write the commands to the history file since source_file
   // disables command line history while it executes.
 
   std::fstream file (name.c_str (), std::ios::in);
 
   char *line;
   //int first = 1;
-  while ((line = edit_history_readline (file)) != 0)
+  while ((line = edit_history_readline (file)) != nullptr)
     {
       // Skip blank lines.
 
       if (line[0] == '\n')
         {
           delete [] line;
           continue;
         }
diff --git a/libinterp/corefcn/oct-iostrm.h b/libinterp/corefcn/oct-iostrm.h
--- a/libinterp/corefcn/oct-iostrm.h
+++ b/libinterp/corefcn/oct-iostrm.h
@@ -94,17 +94,17 @@ public:
   create (std::istream *arg = nullptr, const std::string& n = "");
 
   // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const;
 
   std::istream * input_stream (void) { return is; }
 
-  std::ostream * output_stream (void) { return 0; }
+  std::ostream * output_stream (void) { return nullptr; }
 
 protected:
 
   ~octave_istream (void) = default;
 
 private:
 
   std::istream *is;
@@ -131,17 +131,17 @@ public:
 
   static octave::stream
   create (std::ostream *arg, const std::string& n = "");
 
   // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const;
 
-  std::istream * input_stream (void) { return 0; }
+  std::istream * input_stream (void) { return nullptr; }
 
   std::ostream * output_stream (void) { return os; }
 
 protected:
 
   ~octave_ostream (void) = default;
 
 private:
diff --git a/libinterp/corefcn/oct-procbuf.cc b/libinterp/corefcn/oct-procbuf.cc
--- a/libinterp/corefcn/oct-procbuf.cc
+++ b/libinterp/corefcn/oct-procbuf.cc
@@ -93,20 +93,20 @@ octave_procbuf::open (const char *comman
 
   int pipe_fds[2];
 
   volatile int child_std_end = (mode & std::ios::in) ? 1 : 0;
 
   volatile int parent_end, child_end;
 
   if (is_open ())
-    return 0;
+    return nullptr;
 
   if (octave::sys::pipe (pipe_fds) < 0)
-    return 0;
+    return nullptr;
 
   if (mode & std::ios::in)
     {
       parent_end = pipe_fds[0];
       child_end = pipe_fds[1];
     }
   else
     {
@@ -128,39 +128,39 @@ octave_procbuf::open (const char *comman
 
       while (octave_procbuf_list)
         {
           FILE *fp = octave_procbuf_list->f;
 
           if (fp)
             {
               std::fclose (fp);
-              fp = 0;
+              fp = nullptr;
             }
 
           octave_procbuf_list = octave_procbuf_list->next;
         }
 
-      execl (SHELL_PATH, "sh", "-c", command, static_cast<void *> (0));
+      execl (SHELL_PATH, "sh", "-c", command, static_cast<void *> (nullptr));
 
       exit (127);
     }
 
   octave_close_wrapper (child_end);
 
   if (proc_pid < 0)
     {
       octave_close_wrapper (parent_end);
-      return 0;
+      return nullptr;
     }
 
   f = (::fdopen (parent_end, (mode & std::ios::in) ? "r" : "w"));
 
   if (mode & std::ios::out)
-    ::setvbuf (f, 0, _IOLBF, BUFSIZ);
+    ::setvbuf (f, nullptr, _IOLBF, BUFSIZ);
 
   open_p = true;
 
   next = octave_procbuf_list;
   octave_procbuf_list = this;
 
   return this;
 
@@ -190,17 +190,17 @@ octave_procbuf::close (void)
 
   if (f)
     {
       pid_t wait_pid;
 
       int status = -1;
 
       for (octave_procbuf **ptr = &octave_procbuf_list;
-           *ptr != 0;
+           *ptr != nullptr;
            ptr = &(*ptr)->next)
         {
           if (*ptr == this)
             {
               *ptr = (*ptr)->next;
               status = 0;
               break;
             }
@@ -212,17 +212,17 @@ octave_procbuf::close (void)
 
           do
             {
               wait_pid = octave::sys::waitpid (proc_pid, &wstatus, 0);
             }
           while (wait_pid == -1 && errno == EINTR);
         }
 
-      f = 0;
+      f = nullptr;
     }
 
   open_p = false;
 
   return this;
 
 #else
 
diff --git a/libinterp/corefcn/oct-procbuf.h b/libinterp/corefcn/oct-procbuf.h
--- a/libinterp/corefcn/oct-procbuf.h
+++ b/libinterp/corefcn/oct-procbuf.h
@@ -34,21 +34,21 @@ along with Octave; see the file COPYING.
 
 class
 octave_procbuf : public c_file_ptr_buf
 {
 public:
 
   octave_procbuf (void)
     : c_file_ptr_buf (0), wstatus (-1), open_p (false), proc_pid (-1),
-      next (0) { }
+      next (nullptr) { }
 
   octave_procbuf (const char *command, int mode)
     : c_file_ptr_buf (0), wstatus (-1), open_p (false), proc_pid (-1),
-      next (0) { open (command, mode); }
+      next (nullptr) { open (command, mode); }
 
   // No copying!
 
   octave_procbuf (const octave_procbuf&) = delete;
 
   octave_procbuf& operator = (const octave_procbuf&) = delete;
 
   ~octave_procbuf (void) { close (); }
diff --git a/libinterp/corefcn/oct-stdstrm.h b/libinterp/corefcn/oct-stdstrm.h
--- a/libinterp/corefcn/oct-stdstrm.h
+++ b/libinterp/corefcn/oct-stdstrm.h
@@ -35,17 +35,17 @@ octave_tstdiostream : public octave::bas
 public:
 
   octave_tstdiostream (const std::string& n, FILE_T f = 0, int fid = 0,
                        std::ios::openmode m = std::ios::in | std::ios::out,
                        octave::mach_info::float_format ff
                          = octave::mach_info::native_float_format (),
                        typename BUF_T::close_fcn cf = BUF_T::file_close)
     : octave::base_stream (m, ff), nm (n), md (m),
-      s (f ? new STREAM_T (f, cf) : 0), fnum (fid)
+      s (f ? new STREAM_T (f, cf) : nullptr), fnum (fid)
   { }
 
   // No copying!
 
   octave_tstdiostream (const octave_tstdiostream&) = delete;
 
   octave_tstdiostream& operator = (const octave_tstdiostream&) = delete;
 
@@ -61,23 +61,23 @@ public:
   // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const { return s ? s->eof () : true; }
 
   // The name of the file.
 
   std::string name (void) const { return nm; }
 
-  std::istream * input_stream (void) { return (md & std::ios::in) ? s : 0; }
+  std::istream * input_stream (void) { return (md & std::ios::in) ? s : nullptr; }
 
-  std::ostream * output_stream (void) { return (md & std::ios::out) ? s : 0; }
+  std::ostream * output_stream (void) { return (md & std::ios::out) ? s : nullptr; }
 
   // FIXME: should not have to cast away const here.
   BUF_T * rdbuf (void) const
-  { return s ? (const_cast<STREAM_T *> (s))->rdbuf () : 0; }
+  { return s ? (const_cast<STREAM_T *> (s))->rdbuf () : nullptr; }
 
   int file_number (void) const { return fnum; }
 
   bool bad (void) const { return s ? s->bad () : true; }
 
   void clear (void) { if (s) s->clear (); }
 
   void do_close (void) { if (s) s->stream_close (); }
@@ -134,27 +134,27 @@ protected:
 #if defined (HAVE_ZLIB)
 
 class
 octave_zstdiostream
   : public octave_tstdiostream<c_zfile_ptr_buf, io_c_zfile_ptr_stream, gzFile>
 {
 public:
 
-  octave_zstdiostream (const std::string& n, gzFile f = 0, int fid = 0,
+  octave_zstdiostream (const std::string& n, gzFile f = nullptr, int fid = 0,
                        std::ios::openmode m = std::ios::in | std::ios::out,
                        octave::mach_info::float_format ff
                          = octave::mach_info::native_float_format (),
                        c_zfile_ptr_buf::close_fcn cf
                          = c_zfile_ptr_buf::file_close)
     : octave_tstdiostream<c_zfile_ptr_buf, io_c_zfile_ptr_stream, gzFile>
        (n, f, fid, m, ff, cf) { }
 
   static octave::stream
-  create (const std::string& n, gzFile f = 0, int fid = 0,
+  create (const std::string& n, gzFile f = nullptr, int fid = 0,
           std::ios::openmode m = std::ios::in | std::ios::out,
           octave::mach_info::float_format ff
             = octave::mach_info::native_float_format (),
           c_zfile_ptr_buf::close_fcn cf = c_zfile_ptr_buf::file_close)
   {
     return octave::stream (new octave_zstdiostream (n, f, fid, m, ff, cf));
   }
 
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -307,17 +307,17 @@ namespace octave
     const scanf_format_elt * first (void)
     {
       curr_idx = 0;
       return current ();
     }
 
     const scanf_format_elt * current (void) const
     {
-      return length () > 0 ? fmt_elts[curr_idx] : 0;
+      return length () > 0 ? fmt_elts[curr_idx] : nullptr;
     }
 
     const scanf_format_elt * next (bool cycle = true)
     {
       static scanf_format_elt dummy
         (0, 0, false, scanf_format_elt::null, '\0', "");
 
       curr_idx++;
@@ -816,31 +816,31 @@ namespace octave
     const printf_format_elt * first (void)
     {
       curr_idx = 0;
       return current ();
     }
 
     const printf_format_elt * current (void) const
     {
-      return length () > 0 ? fmt_elts[curr_idx] : 0;
+      return length () > 0 ? fmt_elts[curr_idx] : nullptr;
     }
 
     size_t length (void) const { return fmt_elts.size (); }
 
     const printf_format_elt * next (bool cycle = true)
     {
       curr_idx++;
 
       if (curr_idx >= length ())
         {
           if (cycle)
             curr_idx = 0;
           else
-            return 0;
+            return nullptr;
         }
 
       return current ();
     }
 
     bool last_elt_p (void) { return (curr_idx + 1 == length ()); }
 
     void printme (void) const;
@@ -1292,17 +1292,17 @@ namespace octave
 
     void seekg (char *old_idx) { idx = old_idx; }
 
     bool eof (void)
     {
       return (eob == buf && i_stream.eof ()) || (flags & std::ios_base::eofbit);
     }
 
-    operator const void* (void) { return (! eof () && ! flags) ? this : 0; }
+    operator const void* (void) { return (! eof () && ! flags) ? this : nullptr; }
 
     bool fail (void) { return flags & std::ios_base::failbit; }
 
     std::ios_base::iostate rdstate (void) { return flags; }
 
     void setstate (std::ios_base::iostate m) { flags = flags | m; }
 
     void clear (std::ios_base::iostate m
@@ -1721,39 +1721,39 @@ namespace octave
     const textscan_format_elt * first (void)
     {
       curr_idx = 0;
       return current ();
     }
 
     const textscan_format_elt * current (void) const
     {
-      return numel () > 0 ? fmt_elts[curr_idx] : 0;
+      return numel () > 0 ? fmt_elts[curr_idx] : nullptr;
     }
 
     const textscan_format_elt * next (bool cycle = true)
     {
       curr_idx++;
 
       if (curr_idx >= numel ())
         {
           if (cycle)
             curr_idx = 0;
           else
-            return 0;
+            return nullptr;
         }
 
       return current ();
     }
 
     void printme (void) const;
 
     bool ok (void) const { return (nconv >= 0); }
 
-    operator const void* (void) const { return ok () ? this : 0; }
+    operator const void* (void) const { return ok () ? this : nullptr; }
 
     // What function name should be shown when reporting errors.
     std::string who;
 
     // True if number of %f to be set from data file.
     bool set_from_first;
 
     // At least one conversion specifier is s,q,c, or [...].
@@ -6390,17 +6390,17 @@ namespace octave
     // Table function pointers for return types x read types.
 
     static conv_fptr conv_fptr_table[oct_data_conv::dt_unknown][14];
 
     if (! initialized)
       {
         for (int i = 0; i < oct_data_conv::dt_unknown; i++)
           for (int j = 0; j < 14; j++)
-            conv_fptr_table[i][j] = 0;
+            conv_fptr_table[i][j] = nullptr;
 
         FILL_TABLE_ROW (dt_int8, int8_t);
         FILL_TABLE_ROW (dt_uint8, uint8_t);
         FILL_TABLE_ROW (dt_int16, int16_t);
         FILL_TABLE_ROW (dt_uint16, uint16_t);
         FILL_TABLE_ROW (dt_int32, int32_t);
         FILL_TABLE_ROW (dt_uint32, uint32_t);
         FILL_TABLE_ROW (dt_int64, int64_t);
diff --git a/libinterp/corefcn/oct-stream.h b/libinterp/corefcn/oct-stream.h
--- a/libinterp/corefcn/oct-stream.h
+++ b/libinterp/corefcn/oct-stream.h
@@ -98,23 +98,23 @@ namespace octave
     // The name of the file.
 
     virtual std::string name (void) const = 0;
 
     // If the derived class provides this function and it returns a
     // pointer to a valid istream, scanf(), read(), getl(), and gets()
     // will automatically work for this stream.
 
-    virtual std::istream * input_stream (void) { return 0; }
+    virtual std::istream * input_stream (void) { return nullptr; }
 
     // If the derived class provides this function and it returns a
     // pointer to a valid ostream, flush(), write(), and printf() will
     // automatically work for this stream.
 
-    virtual std::ostream * output_stream (void) { return 0; }
+    virtual std::ostream * output_stream (void) { return nullptr; }
 
     // Return TRUE if this stream is open.
 
     bool is_open (void) const { return open_state; }
 
     virtual void do_close (void) { }
 
     void close (void)
@@ -344,38 +344,38 @@ namespace octave
       if (rep)
         rep->error (msg);
     }
 
     void error (const char *msg) { error (std::string (msg)); }
 
     int file_number (void) { return rep ? rep->file_number () : -1; }
 
-    bool is_valid (void) const { return (rep != 0); }
+    bool is_valid (void) const { return (rep != nullptr); }
 
     bool ok (void) const { return rep && rep->ok (); }
 
     operator bool () const { return ok (); }
 
     std::string name (void) const;
 
     int mode (void) const;
 
     mach_info::float_format float_format (void) const;
 
     static std::string mode_as_string (int mode);
 
     std::istream * input_stream (void)
     {
-      return rep ? rep->input_stream () : 0;
+      return rep ? rep->input_stream () : nullptr;
     }
 
     std::ostream * output_stream (void)
     {
-      return rep ? rep->output_stream () : 0;
+      return rep ? rep->output_stream () : nullptr;
     }
 
     void clearerr (void) { if (rep) rep->clearerr (); }
 
   private:
 
     // The actual representation of this stream.
     base_stream *rep;
diff --git a/libinterp/corefcn/oct-strstrm.h b/libinterp/corefcn/oct-strstrm.h
--- a/libinterp/corefcn/oct-strstrm.h
+++ b/libinterp/corefcn/oct-strstrm.h
@@ -112,21 +112,21 @@ public:
             = octave::mach_info::native_float_format ());
 
   // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const { return is.eof (); }
 
   std::istream * input_stream (void) { return &is; }
 
-  std::ostream * output_stream (void) { return 0; }
+  std::ostream * output_stream (void) { return nullptr; }
 
   off_t tell (void) { return is.tellg (); }
 
-  std::streambuf * rdbuf (void) { return is ? is.rdbuf () : 0; }
+  std::streambuf * rdbuf (void) { return is ? is.rdbuf () : nullptr; }
 
   bool bad (void) const { return is.bad (); }
 
   void clear (void) { is.clear (); }
 
 private:
 
   std::istringstream is;
@@ -158,23 +158,23 @@ public:
   create (std::ios::openmode arg_md = std::ios::out,
           octave::mach_info::float_format ff
             = octave::mach_info::native_float_format ());
 
   // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const { return os.eof (); }
 
-  std::istream * input_stream (void) { return 0; }
+  std::istream * input_stream (void) { return nullptr; }
 
   std::ostream * output_stream (void) { return &os; }
 
   std::string str (void) { return os.str (); }
 
-  std::streambuf * rdbuf (void) { return os ? os.rdbuf () : 0; }
+  std::streambuf * rdbuf (void) { return os ? os.rdbuf () : nullptr; }
 
   bool bad (void) const { return os.bad (); }
 
   void clear (void) { os.clear (); }
 
 private:
 
   std::ostringstream os;
diff --git a/libinterp/corefcn/oct-tex-parser.in.yy b/libinterp/corefcn/oct-tex-parser.in.yy
--- a/libinterp/corefcn/oct-tex-parser.in.yy
+++ b/libinterp/corefcn/oct-tex-parser.in.yy
@@ -207,17 +207,17 @@ string                          : // emp
 
 text_element*
 text_parser_tex::parse (const std::string& s)
 {
   octave_tex_debug = 0;
 
   if (init_lexer (s))
     {
-      result = 0;
+      result = nullptr;
 
       if (octave_tex_parse (*this) == 0)
         return result;
     }
 
   return new text_element_string (s);
 }
 
diff --git a/libinterp/corefcn/octave-link.h b/libinterp/corefcn/octave-link.h
--- a/libinterp/corefcn/octave-link.h
+++ b/libinterp/corefcn/octave-link.h
@@ -158,17 +158,17 @@ public:
   }
 
   static std::string
   question_dialog (const std::string& msg, const std::string& title,
                    const std::string& btn1, const std::string& btn2,
                    const std::string& btn3, const std::string& btndef)
   {
     return enabled () ? instance->do_question_dialog (msg, title, btn1,
-                                                      btn2, btn3, btndef) : 0;
+                                                      btn2, btn3, btndef) : "";
   }
 
   static std::pair<std::list<int>, int>
   list_dialog (const std::list<std::string>& list,
                const std::string& mode,
                int width, int height,
                const std::list<int>& initial_value,
                const std::string& name,
@@ -311,23 +311,23 @@ public:
 
   static void connect_link (octave_link *);
 
   static octave_link * disconnect_link (bool delete_instance = true)
   {
     if (delete_instance)
       {
         delete instance;
-        instance = 0;
-        return 0;
+        instance = nullptr;
+        return nullptr;
       }
     else
       {
         octave_link *retval = instance;
-        instance = 0;
+        instance = nullptr;
         return retval;
       }
   }
 
   static void set_default_prompts (std::string& ps1, std::string& ps2,
                                    std::string& ps4)
   {
     if (enabled ())
@@ -387,17 +387,17 @@ public:
       return false;
 
   }
 
 private:
 
   static octave_link *instance;
 
-  static bool instance_ok (void) { return instance != 0; }
+  static bool instance_ok (void) { return instance != nullptr; }
 
 protected:
 
   // Semaphore to lock access to the event queue.
   octave::mutex *event_queue_mutex;
 
   // Event Queue.
   octave::event_queue gui_event_queue;
diff --git a/libinterp/corefcn/pager.cc b/libinterp/corefcn/pager.cc
--- a/libinterp/corefcn/pager.cc
+++ b/libinterp/corefcn/pager.cc
@@ -94,17 +94,17 @@ static bool flushing_output_to_pager = f
 static void
 clear_external_pager (void)
 {
   if (external_pager)
     {
       octave::child_list::remove (external_pager->pid ());
 
       delete external_pager;
-      external_pager = 0;
+      external_pager = nullptr;
     }
 }
 
 static bool
 pager_event_handler (pid_t pid, int status)
 {
   bool retval = false;
 
@@ -299,17 +299,17 @@ namespace octave
 
     seekoff (0, std::ios::beg);
 
     return 0;
   }
 
   pager_stream *pager_stream::instance = nullptr;
 
-  pager_stream::pager_stream (void) : std::ostream (0), pb (0)
+  pager_stream::pager_stream (void) : std::ostream (nullptr), pb (nullptr)
   {
     pb = new pager_buf ();
     rdbuf (pb);
     setf (unitbuf);
   }
 
   pager_stream::~pager_stream (void)
   {
@@ -388,17 +388,17 @@ namespace octave
     if (! instance)
       error ("unable to create pager_stream object!");
 
     return retval;
   }
 
   diary_stream *diary_stream::instance = nullptr;
 
-  diary_stream::diary_stream (void) : std::ostream (0), db (0)
+  diary_stream::diary_stream (void) : std::ostream (nullptr), db (nullptr)
   {
     db = new diary_buf ();
     rdbuf (db);
     setf (unitbuf);
   }
 
   diary_stream::~diary_stream (void)
   {
diff --git a/libinterp/corefcn/pager.h b/libinterp/corefcn/pager.h
--- a/libinterp/corefcn/pager.h
+++ b/libinterp/corefcn/pager.h
@@ -87,17 +87,17 @@ namespace octave
     void do_set_diary_skip (void);
 
     void do_reset (void);
 
     static pager_stream *instance;
 
     static bool instance_ok (void);
 
-    static void cleanup_instance (void) { delete instance; instance = 0; }
+    static void cleanup_instance (void) { delete instance; instance = nullptr; }
 
     pager_buf *pb;
   };
 
   class
   OCTINTERP_API
   diary_buf : public std::stringbuf
   {
@@ -135,17 +135,17 @@ namespace octave
   private:
 
     void do_reset (void);
 
     static diary_stream *instance;
 
     static bool instance_ok (void);
 
-    static void cleanup_instance (void) { delete instance; instance = 0; }
+    static void cleanup_instance (void) { delete instance; instance = nullptr; }
 
     diary_buf *db;
   };
 
   extern OCTAVE_API void flush_stdout (void);
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -648,18 +648,18 @@ set_real_format (int digits, bool inf_or
     fmt = float_format (fw, rd, std::ios::fixed);
 
   curr_real_fmt = &fmt;
 }
 
 static void
 set_format (double d, int& fw)
 {
-  curr_real_fmt = 0;
-  curr_imag_fmt = 0;
+  curr_real_fmt = nullptr;
+  curr_imag_fmt = nullptr;
 
   if (free_format)
     return;
 
   bool inf_or_nan = (octave::math::isinf (d) || octave::math::isnan (d));
 
   bool int_only = (! inf_or_nan && octave::math::x_nint (d) == d);
 
@@ -801,18 +801,18 @@ set_real_matrix_format (int x_max, int x
     fmt = float_format (fw, rd, std::ios::fixed);
 
   curr_real_fmt = &fmt;
 }
 
 static void
 set_format (const Matrix& m, int& fw, double& scale)
 {
-  curr_real_fmt = 0;
-  curr_imag_fmt = 0;
+  curr_real_fmt = nullptr;
+  curr_imag_fmt = nullptr;
 
   if (free_format)
     return;
 
   bool inf_or_nan = m.any_element_is_inf_or_nan ();
 
   bool int_or_inf_or_nan = m.all_elements_are_int_or_inf_or_nan ();
 
@@ -981,18 +981,18 @@ set_complex_format (int x_max, int x_min
 
   curr_real_fmt = &r_fmt;
   curr_imag_fmt = &i_fmt;
 }
 
 static void
 set_format (const Complex& c, int& r_fw, int& i_fw)
 {
-  curr_real_fmt = 0;
-  curr_imag_fmt = 0;
+  curr_real_fmt = nullptr;
+  curr_imag_fmt = nullptr;
 
   if (free_format)
     return;
 
   double rp = c.real ();
   double ip = c.imag ();
 
   bool inf_or_nan = (octave::math::isinf (c) || octave::math::isnan (c));
@@ -1197,18 +1197,18 @@ set_complex_matrix_format (int x_max, in
 
   curr_real_fmt = &r_fmt;
   curr_imag_fmt = &i_fmt;
 }
 
 static void
 set_format (const ComplexMatrix& cm, int& r_fw, int& i_fw, double& scale)
 {
-  curr_real_fmt = 0;
-  curr_imag_fmt = 0;
+  curr_real_fmt = nullptr;
+  curr_imag_fmt = nullptr;
 
   if (free_format)
     return;
 
   Matrix rp = real (cm);
   Matrix ip = imag (cm);
 
   bool inf_or_nan = cm.any_element_is_inf_or_nan ();
@@ -1353,18 +1353,18 @@ set_range_format (int x_max, int x_min, 
     fmt = float_format (fw, rd, std::ios::fixed);
 
   curr_real_fmt = &fmt;
 }
 
 static void
 set_format (const Range& r, int& fw, double& scale)
 {
-  curr_real_fmt = 0;
-  curr_imag_fmt = 0;
+  curr_real_fmt = nullptr;
+  curr_imag_fmt = nullptr;
 
   if (free_format)
     return;
 
   double r_min = r.base ();
   double r_max = r.limit ();
 
   if (r_max < r_min)
diff --git a/libinterp/corefcn/procstream.h b/libinterp/corefcn/procstream.h
--- a/libinterp/corefcn/procstream.h
+++ b/libinterp/corefcn/procstream.h
@@ -73,23 +73,23 @@ private:
 
 class
 OCTINTERP_API
 iprocstream : public std::istream, public procstreambase
 // iprocstream : public procstreambase, public std::istream
 {
 public:
 
-  iprocstream (void) : std::istream (0), procstreambase () { }
+  iprocstream (void) : std::istream (nullptr), procstreambase () { }
 
   iprocstream (const std::string& name, int mode = std::ios::in)
-    : std::istream (0), procstreambase (name, mode) { }
+    : std::istream (nullptr), procstreambase (name, mode) { }
 
   iprocstream (const char *name, int mode = std::ios::in)
-    : std::istream (0), procstreambase (name, mode) { }
+    : std::istream (nullptr), procstreambase (name, mode) { }
 
   ~iprocstream (void) = default;
 
   void open (const std::string& name, int mode = std::ios::in)
   { procstreambase::open (name, mode); }
 
   void open (const char *name, int mode = std::ios::in)
   { procstreambase::open (name, mode); }
@@ -103,23 +103,23 @@ private:
 
 class
 OCTINTERP_API
 oprocstream : public std::ostream, public procstreambase
 // oprocstream : public procstreambase, public std::ostream
 {
 public:
 
-  oprocstream (void) : std::ostream (0), procstreambase () { }
+  oprocstream (void) : std::ostream (nullptr), procstreambase () { }
 
   oprocstream (const std::string& name, int mode = std::ios::out)
-    : std::ostream (0), procstreambase (name, mode) { }
+    : std::ostream (nullptr), procstreambase (name, mode) { }
 
   oprocstream (const char *name, int mode = std::ios::out)
-    : std::ostream (0), procstreambase (name, mode) { }
+    : std::ostream (nullptr), procstreambase (name, mode) { }
 
   ~oprocstream (void) = default;
 
   void open (const std::string& name, int mode = std::ios::out)
   { procstreambase::open (name, mode); }
 
   void open (const char *name, int mode = std::ios::out)
   { procstreambase::open (name, mode); }
@@ -133,23 +133,23 @@ private:
 
 class
 OCTINTERP_API
 procstream : public std::iostream, public procstreambase
 // procstream : public procstreambase, public std::iostream
 {
 public:
 
-  procstream (void) : std::iostream (0), procstreambase () { }
+  procstream (void) : std::iostream (nullptr), procstreambase () { }
 
   procstream (const std::string& name, int mode)
-    : std::iostream (0), procstreambase (name, mode) { }
+    : std::iostream (nullptr), procstreambase (name, mode) { }
 
   procstream (const char *name, int mode)
-    : std::iostream (0), procstreambase (name, mode) { }
+    : std::iostream (nullptr), procstreambase (name, mode) { }
 
   ~procstream (void) = default;
 
   void open (const std::string& name, int mode)
   { procstreambase::open (name, mode); }
 
   void open (const char *name, int mode)
   { procstreambase::open (name, mode); }
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -651,17 +651,17 @@ Note: @code{qz} performs permutation bal
 
 #if defined (DEBUG_SORT)
       std::cout << "qz: ordering eigenvalues: ord_job = "
                 << ord_job << std::endl;
 #endif
 
       // Declared static to avoid vfork/long jump compiler complaints.
       static sort_function sort_test;
-      sort_test = 0;
+      sort_test = nullptr;
 
       switch (ord_job)
         {
         case 'S':
           sort_test = &fin;
           break;
 
         case 'B':
diff --git a/libinterp/corefcn/sighandlers.cc b/libinterp/corefcn/sighandlers.cc
--- a/libinterp/corefcn/sighandlers.cc
+++ b/libinterp/corefcn/sighandlers.cc
@@ -325,17 +325,17 @@ namespace octave
     {
 #if defined (OCTAVE_USE_WINDOWS_API)
       return new w32_interrupt_manager ();
 #else
       return new posix_interrupt_manager ();
 #endif
     }
 
-    static void cleanup_instance (void) { delete instance; instance = 0; }
+    static void cleanup_instance (void) { delete instance; instance = nullptr; }
 
     static base_interrupt_manager *instance;
   };
 
   base_interrupt_manager *interrupt_manager::instance = nullptr;
 
   static void
   my_friendly_exit (int sig, bool save_vars = true)
diff --git a/libinterp/corefcn/svd.cc b/libinterp/corefcn/svd.cc
--- a/libinterp/corefcn/svd.cc
+++ b/libinterp/corefcn/svd.cc
@@ -401,17 +401,17 @@ with
 [@var{u}, @var{s}, @var{v}] = svd (@var{x});
 norm (@var{x} - @var{u}*@var{s}*@var{v'}, "fro")
 @end group
 @end example
 
 @seealso{svd}
 @end deftypefn */)
 {
-  static const char *driver_names[] = { "gesvd", "gesdd", 0 };
+  static const char *driver_names[] = { "gesvd", "gesdd", nullptr };
 
   return SET_INTERNAL_VARIABLE_CHOICES (svd_driver, driver_names);
 }
 
 /*
 %!test
 %! A = [1+1i, 1-1i, 0; 0, 2, 0; 1i, 1i, 1+2i];
 %! old_driver = svd_driver ("gesvd");
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -216,17 +216,17 @@ namespace octave
 
     return retval;
   }
 
   symbol_table::symbol_record
   symbol_table::dummy_symbol_record (static_cast<symbol_table::scope*> (nullptr));
 
   symbol_table::symbol_reference::symbol_reference (const symbol_record& record)
-    : m_scope (0), m_context (0),m_sym (record)
+    : m_scope (nullptr), m_context (0), m_sym (record)
   {
     m_scope = __get_current_scope__ ("symbol_reference");
   }
 
   void
   symbol_table::symbol_reference::update (void) const
   {
     symbol_table::scope *curr_scope
@@ -814,17 +814,17 @@ namespace octave
   symbol_table::fcn_info::fcn_info_rep::xfind (const octave_value_list& args,
                                                bool local_funcs)
   {
     if (local_funcs)
       {
         symbol_table::scope *scope
           = __get_current_scope__ ("symbol_table::fcn_info::fcn_info_rep::xfind");
 
-        octave_user_function *current_fcn = scope ? scope->function () : 0;
+        octave_user_function *current_fcn = scope ? scope->function () : nullptr;
 
         // Local function.
 
         if (current_fcn)
           {
             std::string fcn_file = current_fcn->fcn_file_name ();
 
             if (! fcn_file.empty ())
@@ -1018,17 +1018,17 @@ namespace octave
     if (cmdline_function.is_defined ())
       return cmdline_function;
 
     // Private function.
 
     symbol_table::scope *scope
       = __get_current_scope__ ("symbol_table::fcn_info::fcn_info_rep::x_builtin_find");
 
-    octave_user_function *current_fcn = scope ? scope->function () : 0;
+    octave_user_function *current_fcn = scope ? scope->function () : nullptr;
 
     if (current_fcn)
       {
         std::string dir_name = current_fcn->dir_name ();
 
         if (! dir_name.empty ())
           {
             str_val_iterator q = private_functions.find (dir_name);
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -91,17 +91,17 @@ namespace octave
     private:
 
       class symbol_record_rep
       {
       public:
 
         symbol_record_rep (scope *s, const std::string& nm,
                            const octave_value& v, unsigned int sc)
-          : m_decl_scope (s), curr_fcn (0), name (nm), value_stack (),
+          : m_decl_scope (s), curr_fcn (nullptr), name (nm), value_stack (),
             storage_class (sc), /* finfo (), */ valid (true), count (1)
         {
           value_stack.push_back (v);
         }
 
         // No copying!
 
         symbol_record_rep (const symbol_record_rep& ov) = delete;
@@ -487,17 +487,17 @@ namespace octave
 
     // Always access a symbol from the current scope.
     // Useful for scripts, as they may be executed in more than one scope.
     class
       symbol_reference
     {
     public:
 
-      symbol_reference (void) : m_scope (0), m_context (0) { }
+      symbol_reference (void) : m_scope (nullptr), m_context (0) { }
 
       symbol_reference (const symbol_record& record);
 
       symbol_reference (const symbol_record& record, scope *curr_scope,
                         context_id context)
         : m_scope (curr_scope), m_context (context), m_sym (record)
       { }
 
@@ -1531,25 +1531,25 @@ namespace octave
             retval.insert (retval.end (), parents.begin (), parents.end ());
         }
 
       return retval;
     }
 
     octave_user_function * get_curr_fcn (void)
     {
-      return m_current_scope ? m_current_scope->function () : 0;
+      return m_current_scope ? m_current_scope->function () : nullptr;
     }
 
     void cleanup (void);
 
     fcn_info * get_fcn_info (const std::string& name)
     {
       fcn_table_iterator p = m_fcn_table.find (name);
-      return p != m_fcn_table.end () ? &p->second : 0;
+      return p != m_fcn_table.end () ? &p->second : nullptr;
     }
 
     class scope
     {
     public:
 
       typedef std::map<std::string, symbol_table::symbol_record>::const_iterator
       table_const_iterator;
@@ -1562,17 +1562,17 @@ namespace octave
       m_persistent_symbols_iterator;
 
       typedef std::map<std::string, octave_value>::const_iterator
       subfunctions_const_iterator;
       typedef std::map<std::string, octave_value>::iterator subfunctions_iterator;
 
       scope (const std::string& name = "")
         : m_name (name), m_symbols (), m_persistent_symbols (), m_subfunctions (),
-          m_fcn (0), m_parent (0), m_children (), m_is_nested (false),
+          m_fcn (nullptr), m_parent (nullptr), m_children (), m_is_nested (false),
           m_is_static (false), m_context (0)
       { }
 
       // No copying!
 
       scope (const scope&) = delete;
 
       scope& operator = (const scope&) = delete;
diff --git a/libinterp/corefcn/text-renderer.cc b/libinterp/corefcn/text-renderer.cc
--- a/libinterp/corefcn/text-renderer.cc
+++ b/libinterp/corefcn/text-renderer.cc
@@ -61,17 +61,17 @@ namespace octave
           {
             warn_disabled_feature ("opengl_renderer::render_text",
                                    "rendering text (FreeType)");
 
             warned = true;
           }
       }
 
-    return rep != 0;
+    return rep != nullptr;
   }
 
   Matrix
   text_renderer::get_extent (text_element *elt, double rotation)
   {
     static Matrix empty_extent (1, 4, 0.0);
 
     return ok () ? rep->get_extent (elt, rotation) : empty_extent;
diff --git a/libinterp/corefcn/txt-eng.h b/libinterp/corefcn/txt-eng.h
--- a/libinterp/corefcn/txt-eng.h
+++ b/libinterp/corefcn/txt-eng.h
@@ -406,17 +406,17 @@ public:
 };
 
 class
 OCTINTERP_API
 text_parser_tex : public text_parser
 {
 public:
   text_parser_tex (void)
-    : text_parser (), scanner (0), buffer_state (0), result (0)
+    : text_parser (), scanner (nullptr), buffer_state (nullptr), result (nullptr)
   { }
 
   ~text_parser_tex (void)
   { destroy_lexer (); }
 
   text_element * parse (const std::string& s);
 
   void * get_scanner (void) { return scanner; }
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -182,34 +182,34 @@ keyword_almost_match (const char * const
   const char * const *s1 = std;
   const char **s2 = to_match;
 
   if (! s1 || ! s2)
     goto done;
 
   s2[tok_count] = beg;
   char *end;
-  while ((end = strchr (beg, ' ')) != 0)
+  while ((end = strchr (beg, ' ')) != nullptr)
     {
       *end = '\0';
       beg = end + 1;
 
       while (*beg == ' ')
         beg++;
 
       if (*beg == '\0')
         break;
 
       tok_count++;
       if (tok_count >= max_toks)
         goto done;
 
       s2[tok_count] = beg;
     }
-  s2[tok_count+1] = 0;
+  s2[tok_count+1] = nullptr;
 
   s2 = to_match;
 
   for (;;)
     {
       if (! almost_match (*s1, *s2, min_len[toks_matched], 0))
         goto done;
 
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -900,17 +900,17 @@ set_internal_variable (std::string& var,
 }
 
 octave_value
 set_internal_variable (int& var, const octave_value_list& args,
                        int nargout, const char *nm, const char **choices)
 {
   octave_value retval;
   int nchoices = 0;
-  while (choices[nchoices] != 0)
+  while (choices[nchoices] != nullptr)
     nchoices++;
 
   int nargin = args.length ();
 
   assert (var < nchoices);
 
   if (nargout > 0 || nargin == 0)
     retval = choices[var];
@@ -945,17 +945,17 @@ set_internal_variable (int& var, const o
 }
 
 octave_value
 set_internal_variable (std::string& var, const octave_value_list& args,
                        int nargout, const char *nm, const char **choices)
 {
   octave_value retval;
   int nchoices = 0;
-  while (choices[nchoices] != 0)
+  while (choices[nchoices] != nullptr)
     nchoices++;
 
   int nargin = args.length ();
 
   if (nargout > 0 || nargin == 0)
     retval = var;
 
   if (wants_local_change (args, nargin))
diff --git a/libinterp/corefcn/zfstream.cc b/libinterp/corefcn/zfstream.cc
--- a/libinterp/corefcn/zfstream.cc
+++ b/libinterp/corefcn/zfstream.cc
@@ -47,18 +47,18 @@ along with Octave; see the file COPYING.
 
 // Internal buffer sizes (default and "unbuffered" versions)
 #define STASHED_CHARACTERS 16
 #define BIGBUFSIZE (256 * 1024 + STASHED_CHARACTERS)
 #define SMALLBUFSIZE 1
 
 // Default constructor
 gzfilebuf::gzfilebuf ()
-  : file(0), io_mode(std::ios_base::openmode(0)), own_fd(false),
-    buffer(0), buffer_size(BIGBUFSIZE), own_buffer(true)
+  : file(nullptr), io_mode(std::ios_base::openmode(0)), own_fd(false),
+    buffer(nullptr), buffer_size(BIGBUFSIZE), own_buffer(true)
 {
   // No buffers to start with
   this->disable_buffer ();
 }
 
 // Destructor
 gzfilebuf::~gzfilebuf ()
 {
@@ -79,80 +79,80 @@ gzfilebuf::setcompression (int comp_leve
 }
 
 // Open gzipped file
 gzfilebuf*
 gzfilebuf::open (const char *name, std::ios_base::openmode mode)
 {
   // Fail if file already open
   if (this->is_open ())
-    return 0;
+    return nullptr;
   // Don't support simultaneous read/write access (yet)
   if ((mode & std::ios_base::in) && (mode & std::ios_base::out))
-    return 0;
+    return nullptr;
 
   // Build mode string for gzopen and check it [27.8.1.3.2]
   char char_mode[6] = "\0\0\0\0\0";
   if (! this->open_mode (mode, char_mode))
-    return 0;
+    return nullptr;
 
   // Attempt to open file
-  if ((file = gzopen (name, char_mode)) == 0)
-    return 0;
+  if ((file = gzopen (name, char_mode)) == nullptr)
+    return nullptr;
 
   // On success, allocate internal buffer and set flags
   this->enable_buffer ();
   io_mode = mode;
   own_fd = true;
   return this;
 }
 
 // Attach to gzipped file
 gzfilebuf*
 gzfilebuf::attach (int fd, std::ios_base::openmode mode)
 {
   // Fail if file already open
   if (this->is_open ())
-    return 0;
+    return nullptr;
   // Don't support simultaneous read/write access (yet)
   if ((mode & std::ios_base::in) && (mode & std::ios_base::out))
-    return 0;
+    return nullptr;
 
   // Build mode string for gzdopen and check it [27.8.1.3.2]
   char char_mode[6] = "\0\0\0\0\0";
   if (! this->open_mode (mode, char_mode))
-    return 0;
+    return nullptr;
 
   // Attempt to attach to file
-  if ((file = gzdopen (fd, char_mode)) == 0)
-    return 0;
+  if ((file = gzdopen (fd, char_mode)) == nullptr)
+    return nullptr;
 
   // On success, allocate internal buffer and set flags
   this->enable_buffer ();
   io_mode = mode;
   own_fd = false;
   return this;
 }
 
 // Close gzipped file
 gzfilebuf*
 gzfilebuf::close ()
 {
   // Fail immediately if no file is open
   if (! this->is_open ())
-    return 0;
+    return nullptr;
   // Assume success
   gzfilebuf *retval = this;
   // Attempt to sync and close gzipped file
   if (this->sync () == -1)
-    retval = 0;
+    retval = nullptr;
   if (gzclose (file) < 0)
-    retval = 0;
+    retval = nullptr;
   // File is now gone anyway (postcondition [27.8.1.3.8])
-  file = 0;
+  file = nullptr;
   own_fd = false;
   // Destroy internal buffer if it exists
   this->disable_buffer ();
   return retval;
 }
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
@@ -346,27 +346,27 @@ gzfilebuf::overflow (int_type c)
 }
 
 // Assign new buffer
 std::streambuf*
 gzfilebuf::setbuf (char_type *p, std::streamsize n)
 {
   // First make sure stuff is sync'ed, for safety
   if (this->sync () == -1)
-    return 0;
+    return nullptr;
   // If buffering is turned off on purpose via setbuf(0,0), still allocate one.
   // "Unbuffered" only really refers to put [27.8.1.4.10], while get needs at
   // least a buffer of size 1 (very inefficient though, therefore make it
   // bigger?).  This follows from [27.5.2.4.3]/12 (gptr needs to point at
   // something, it seems).
   if (! p || ! n)
     {
       // Replace existing buffer (if any) with small internal buffer
       this->disable_buffer ();
-      buffer = 0;
+      buffer = nullptr;
       buffer_size = 0;
       own_buffer = true;
       this->enable_buffer ();
     }
   else
     {
       // Replace existing buffer (if any) with external buffer
       this->disable_buffer ();
@@ -434,17 +434,17 @@ gzfilebuf::disable_buffer ()
 {
   // If internal buffer exists, deallocate it
   if (own_buffer && buffer)
     {
       // Preserve unbuffered status by zeroing size
       if (! this->pbase ())
         buffer_size = 0;
       delete[] buffer;
-      buffer = 0;
+      buffer = nullptr;
       this->setg (0, 0, 0);
       this->setp (0, 0);
     }
   else
     {
       // Reset buffer pointers to initial state if external buffer exists
       this->setg (buffer, buffer, buffer);
       if (buffer)
@@ -511,30 +511,30 @@ gzfilebuf::seekpos (pos_type sp, std::io
         overflow ();
     }
 
   return ret;
 }
 
 // Default constructor initializes stream buffer
 gzifstream::gzifstream ()
-  : std::istream (0), sb ()
+  : std::istream (nullptr), sb ()
 { this->init (&sb); }
 
 // Initialize stream buffer and open file
 gzifstream::gzifstream (const char *name, std::ios_base::openmode mode)
-  : std::istream (0), sb ()
+  : std::istream (nullptr), sb ()
 {
   this->init (&sb);
   this->open (name, mode);
 }
 
 // Initialize stream buffer and attach to file
 gzifstream::gzifstream (int fd, std::ios_base::openmode mode)
-  : std::istream (0), sb ()
+  : std::istream (nullptr), sb ()
 {
   this->init (&sb);
   this->attach (fd, mode);
 }
 
 // Open file and go into fail() state if unsuccessful
 void
 gzifstream::open (const char *name, std::ios_base::openmode mode)
@@ -560,30 +560,30 @@ void
 gzifstream::close ()
 {
   if (! sb.close ())
     this->setstate (std::ios_base::failbit);
 }
 
 // Default constructor initializes stream buffer
 gzofstream::gzofstream ()
-  : std::ostream (0), sb ()
+  : std::ostream (nullptr), sb ()
 { this->init (&sb); }
 
 // Initialize stream buffer and open file
 gzofstream::gzofstream (const char *name, std::ios_base::openmode mode)
-  : std::ostream (0), sb ()
+  : std::ostream (nullptr), sb ()
 {
   this->init (&sb);
   this->open (name, mode);
 }
 
 // Initialize stream buffer and attach to file
 gzofstream::gzofstream (int fd, std::ios_base::openmode mode)
-  : std::ostream (0), sb ()
+  : std::ostream (nullptr), sb ()
 {
   this->init (&sb);
   this->attach (fd, mode);
 }
 
 // Open file and go into fail() state if unsuccessful
 void
 gzofstream::open (const char *name, std::ios_base::openmode mode)
diff --git a/libinterp/corefcn/zfstream.h b/libinterp/corefcn/zfstream.h
--- a/libinterp/corefcn/zfstream.h
+++ b/libinterp/corefcn/zfstream.h
@@ -79,17 +79,17 @@ public:
   setcompression (int comp_level,
                   int comp_strategy = Z_DEFAULT_STRATEGY);
 
   /**
    *  @brief  Check if file is open.
    *  @return  True if file is open.
   */
   bool
-  is_open () const { return (file != 0); }
+  is_open () const { return (file != nullptr); }
 
   /**
    *  @brief  Open gzipped file.
    *  @param  name  Filename.
    *  @param  mode  Open mode flags.
    *  @return  @c this on success, NULL on failure.
   */
   gzfilebuf*
diff --git a/libinterp/dldfcn/__glpk__.cc b/libinterp/dldfcn/__glpk__.cc
--- a/libinterp/dldfcn/__glpk__.cc
+++ b/libinterp/dldfcn/__glpk__.cc
@@ -166,17 +166,17 @@ glpk (int sense, int n, int m, double *c
 
     }
 
   glp_load_matrix (lp, nz, rn, cn, a);
 
   if (save_pb)
     {
       static char tmp[] = "outpb.lp";
-      if (glp_write_lp (lp, 0, tmp) != 0)
+      if (glp_write_lp (lp, nullptr, tmp) != 0)
         error ("__glpk__: unable to write problem");
     }
 
   // scale the problem data
   if (! par->presol || lpsolver != 1)
     glp_scale_prob (lp, scale);
 
   // build advanced initial basis (if required)
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -118,17 +118,17 @@ right drag - rectangle zoom\n\
 left double click - autoscale\n\
 ";
 
 class OpenGL_fltk : public Fl_Gl_Window
 {
 public:
 
   OpenGL_fltk (int xx, int yy, int ww, int hh, double num)
-    : Fl_Gl_Window (xx, yy, ww, hh, 0), m_number (num), m_renderer (),
+    : Fl_Gl_Window (xx, yy, ww, hh, nullptr), m_number (num), m_renderer (),
       m_in_zoom (false), m_zoom_box ()
   {
 #if defined (HAVE_OPENGL)
     // Ask for double buffering and a depth buffer.
     mode (FL_DEPTH | FL_DOUBLE | FL_MULTISAMPLE);
 #else
     err_disabled_feature ("OpenGL_fltk", "OpenGL");
 #endif
@@ -481,17 +481,17 @@ public:
         Fl_Menu_Item *item
           = const_cast<Fl_Menu_Item *> (m_menubar->find_item (fltk_label.c_str ()));
         if (item)
           {
             if (! uimenup.get_callback ().isempty ())
               item->callback (static_cast<Fl_Callback *> (script_cb),
                               static_cast<void *> (&uimenup));
             else
-              item->callback (0, static_cast<void *> (0));
+              item->callback (nullptr, static_cast<void *> (nullptr));
           }
       }
   }
 
   void update_enable (uimenu::properties& uimenup)
   {
     std::string fltk_label = uimenup.get___fltk_label__ ();
     if (! fltk_label.empty ())
@@ -620,17 +620,18 @@ public:
               {
                 Matrix uimenu_ch = find_uimenu_children (uimenup);
                 int len = uimenu_ch.numel ();
                 int flags = 0;
                 if (len > 0)
                   flags = FL_SUBMENU;
                 if (len == 0 && uimenup.is_checked ())
                   flags += FL_MENU_TOGGLE + FL_MENU_VALUE;
-                m_menubar->add (fltk_label.c_str (), 0, 0, 0, flags);
+                m_menubar->add (fltk_label.c_str (),
+                                0, nullptr, nullptr, flags);
                 item_added = true;
               }
           }
         while (! item_added);
         uimenup.set___fltk_label__ (fltk_label);
       }
   }
 
@@ -781,20 +782,20 @@ class plot_window : public Fl_Window
 {
   friend class fltk_uimenu;
 
 public:
 
   plot_window (int xx, int yy, int ww, int hh, figure::properties& xfp,
                bool internal)
     : Fl_Window (xx, yy, ww, hh + m_menu_h + m_status_h + 2, "octave"),
-      m_window_label (), m_fp (xfp), m_uimenu (0), m_canvas (0),
-      m_autoscale (0), m_togglegrid (0), m_panzoom (0), m_rotate (0),
-      m_help (0), m_status (0), m_resize_dummy (0), m_ax_obj (),
-      m_pos_x (0), m_pos_y (0)
+      m_window_label (), m_fp (xfp), m_uimenu (nullptr), m_canvas (nullptr),
+      m_autoscale (nullptr), m_togglegrid (nullptr), m_panzoom (nullptr),
+      m_rotate (nullptr), m_help (nullptr), m_status (nullptr),
+      m_resize_dummy (nullptr), m_ax_obj (), m_pos_x (0), m_pos_y (0)
   {
     callback (window_close, static_cast<void *> (this));
 
     // The size of the resize_dummy box also determines the minimum
     // window size.
     m_resize_dummy = new Fl_Box (5 * m_status_h, m_menu_h,
                                  ww - 5 * m_status_h, hh);
 
diff --git a/libinterp/dldfcn/__ode15__.cc b/libinterp/dldfcn/__ode15__.cc
--- a/libinterp/dldfcn/__ode15__.cc
+++ b/libinterp/dldfcn/__ode15__.cc
@@ -100,30 +100,30 @@ namespace octave
 
     typedef
     SparseMatrix (*DAEJacCellSparse) (SparseMatrix *dfdy,
                                       SparseMatrix *dfdyp, realtype cj);
 
     //Default
     IDA (void)
       : t0 (0.0), y0 (), yp0 (), havejac (false), havejacfun (false),
-        havejacsparse (false), mem (0), num (), ida_fun (0),
-        ida_jac (0), dfdy (0), dfdyp (0), spdfdy (0),
-        spdfdyp (0), fun (0), jacfun (0), jacspfun (0),
-        jacdcell (0), jacspcell (0)
+        havejacsparse (false), mem (nullptr), num (), ida_fun (nullptr),
+        ida_jac (nullptr), dfdy (nullptr), dfdyp (nullptr), spdfdy (nullptr),
+        spdfdyp (nullptr), fun (nullptr), jacfun (nullptr), jacspfun (nullptr),
+        jacdcell (nullptr), jacspcell (nullptr)
     { }
 
 
     IDA (realtype t, ColumnVector y, ColumnVector yp,
          octave_function *ida_fcn, DAERHSFuncIDA daefun)
       : t0 (t), y0 (y), yp0 (yp), havejac (false), havejacfun (false),
-        havejacsparse (false), mem (0), num (), ida_fun (ida_fcn),
-        ida_jac (0), dfdy (0), dfdyp (0), spdfdy (0),
-        spdfdyp (0), fun (daefun), jacfun (0), jacspfun (0),
-        jacdcell (0), jacspcell (0)
+        havejacsparse (false), mem (nullptr), num (), ida_fun (ida_fcn),
+        ida_jac (nullptr), dfdy (nullptr), dfdyp (nullptr), spdfdy (nullptr),
+        spdfdyp (nullptr), fun (daefun), jacfun (nullptr), jacspfun (nullptr),
+        jacdcell (nullptr), jacspcell (nullptr)
     { }
 
 
     ~IDA (void) { IDAFree (&mem); }
 
     IDA&
     set_jacobian (octave_function *jac, DAEJacFuncDense j)
     {
diff --git a/libinterp/dldfcn/audiodevinfo.cc b/libinterp/dldfcn/audiodevinfo.cc
--- a/libinterp/dldfcn/audiodevinfo.cc
+++ b/libinterp/dldfcn/audiodevinfo.cc
@@ -314,37 +314,37 @@ recording using those parameters.
               warning ("Octave:invalid-audio-device",
                        "invalid audio device ID = %d", i);
               continue;
             }
 
           stream_parameters.suggestedLatency
             = device_info->defaultLowInputLatency;
 
-          stream_parameters.hostApiSpecificStreamInfo = 0;
+          stream_parameters.hostApiSpecificStreamInfo = nullptr;
 
           if (io == 0)
             {
               if (device_info->maxOutputChannels < chans)
                 continue;
 
-              err = Pa_IsFormatSupported (0, &stream_parameters, rate);
+              err = Pa_IsFormatSupported (nullptr, &stream_parameters, rate);
 
               if (err == paFormatIsSupported)
                 {
                   retval = i;
                   return retval;
                 }
             }
           else if (io == 1)
             {
               if (device_info->maxInputChannels < chans)
                 continue;
 
-              err = Pa_IsFormatSupported (&stream_parameters, 0, rate);
+              err = Pa_IsFormatSupported (&stream_parameters, nullptr, rate);
               if (err == paFormatIsSupported)
                 {
                   retval = i;
                   return retval;
                 }
             }
         }
       retval = -1;
@@ -369,39 +369,39 @@ recording using those parameters.
       const PaDeviceInfo *device_info = Pa_GetDeviceInfo (id);
 
       if (! device_info)
         error ("audiodevinfo: invalid audio device ID = %d", id);
 
       stream_parameters.suggestedLatency
         = device_info->defaultLowInputLatency;
 
-      stream_parameters.hostApiSpecificStreamInfo = 0;
+      stream_parameters.hostApiSpecificStreamInfo = nullptr;
       if (io == 0)
         {
           if (device_info->maxOutputChannels < chans)
             {
               retval = 0;
               return retval;
             }
-          err = Pa_IsFormatSupported (0, &stream_parameters, rate);
+          err = Pa_IsFormatSupported (nullptr, &stream_parameters, rate);
           if (err == paFormatIsSupported)
             {
               retval = 1;
               return retval;
             }
         }
       else if (io == 1)
         {
           if (device_info->maxInputChannels < chans)
             {
               retval = 0;
               return retval;
             }
-          err = Pa_IsFormatSupported (&stream_parameters, 0, rate);
+          err = Pa_IsFormatSupported (&stream_parameters, nullptr, rate);
           if (err == paFormatIsSupported)
             {
               retval = 1;
               return retval;
             }
         }
       else
         error ("audiodevinfo: please specify 0 for output and 1 for input devices");
@@ -819,20 +819,20 @@ portaudio_play_callback (const void *, v
 
 static void
 safe_audioplayer_stop (audioplayer *player)
 {
   player->stop ();
 }
 
 audioplayer::audioplayer (void)
-  : octave_callback_function (0),
+  : octave_callback_function (nullptr),
     id (-1), fs (0), nbits (16), channels (0), sample_number (0),
     end_sample (-1), tag (""), y (), userdata (Matrix ()),
-    left (), right (), stream (0), output_parameters (), type ()
+    left (), right (), stream (nullptr), output_parameters (), type ()
 { }
 
 audioplayer::~audioplayer (void)
 {
   if (isplaying ())
     {
       warning ("Octave:audio-interrupt",
                "interrupting playing audioplayer");
@@ -875,17 +875,17 @@ audioplayer::init_fn (void)
 
   if (! device_info)
     warning ("Octave:invalid-default-audio-device",
              "invalid default audio device ID = %d", device);
 
   output_parameters.suggestedLatency
     = (device_info ? device_info->defaultHighOutputLatency : -1);
 
-  output_parameters.hostApiSpecificStreamInfo = 0;
+  output_parameters.hostApiSpecificStreamInfo = nullptr;
 }
 
 void
 audioplayer::init (void)
 {
   // FIXME: Both of these variables are unused.
   // Should they be eliminated or is something not yet implemented?
   //
@@ -919,17 +919,17 @@ audioplayer::init (void)
 
   if (! device_info)
     warning ("Octave:invalid-default-audio-device",
              "invalid default audio device ID = %d", device);
 
   output_parameters.suggestedLatency
     = (device_info ? device_info->defaultHighOutputLatency : -1);
 
-  output_parameters.hostApiSpecificStreamInfo = 0;
+  output_parameters.hostApiSpecificStreamInfo = nullptr;
 }
 
 void
 audioplayer::set_y (const octave_value& y_arg)
 {
   if (y_arg.is_int8_type ())
     type = TYPE_INT8;
   else if (y_arg.is_uint8_type ())
@@ -1092,18 +1092,18 @@ audioplayer::playblocking (void)
 {
   if (get_stream ())
     stop ();
 
   const unsigned int buffer_size = get_fs () / 20;
   OCTAVE_LOCAL_BUFFER (uint32_t, buffer, buffer_size * 2);
 
   PaError err;
-  err = Pa_OpenStream (&stream, 0, &(output_parameters), get_fs (),
-                       buffer_size, paClipOff, 0, 0);
+  err = Pa_OpenStream (&stream, nullptr, &(output_parameters), get_fs (),
+                       buffer_size, paClipOff, nullptr, nullptr);
   if (err != paNoError)
     error ("audioplayer: unable to open audio playback stream");
 
   err = Pa_StartStream (stream);
   if (err != paNoError)
     error ("audioplayer: unable to start audio playback stream");
 
   unsigned int start, end;
@@ -1113,67 +1113,67 @@ audioplayer::playblocking (void)
   octave::unwind_protect frame;
 
   frame.add_fcn (safe_audioplayer_stop, this);
 
   for (unsigned int i = start; i < end; i += buffer_size)
     {
       octave_quit ();
 
-      if (octave_callback_function != 0)
-        octave_play_callback (0, buffer, buffer_size, 0, 0, this);
+      if (octave_callback_function != nullptr)
+        octave_play_callback (nullptr, buffer, buffer_size, nullptr, 0, this);
       else
-        portaudio_play_callback (0, buffer, buffer_size, 0, 0, this);
+        portaudio_play_callback (nullptr, buffer, buffer_size, nullptr, 0, this);
 
       err = Pa_WriteStream (stream, buffer, buffer_size);
     }
 }
 
 void
 audioplayer::play (void)
 {
   if (get_stream ())
     stop ();
 
   const unsigned int buffer_size = get_fs () / 20;
 
   PaError err;
-  if (octave_callback_function != 0)
-    err = Pa_OpenStream (&stream, 0, &(output_parameters),
+  if (octave_callback_function != nullptr)
+    err = Pa_OpenStream (&stream, nullptr, &(output_parameters),
                          get_fs (), buffer_size, paClipOff,
                          octave_play_callback, this);
   else
-    err = Pa_OpenStream (&stream, 0, &(output_parameters),
+    err = Pa_OpenStream (&stream, nullptr, &(output_parameters),
                          get_fs (), buffer_size, paClipOff,
                          portaudio_play_callback, this);
 
   if (err != paNoError)
     error ("audioplayer: failed to open audio playback stream");
 
   err = Pa_StartStream (stream);
   if (err != paNoError)
     error ("audioplayer: failed to start audio playback stream");
 }
 
 void
 audioplayer::pause (void)
 {
-  if (get_stream () == 0)
+  if (get_stream () == nullptr)
     return;
 
   PaError err;
   err = Pa_StopStream (stream);
   if (err != paNoError)
     error ("audiorecorder: failed to stop audio recording stream");
 }
 
 void
 audioplayer::resume (void)
 {
-  if (get_stream () == 0)
+  if (get_stream () == nullptr)
     return;
 
   PaError err;
   err = Pa_StartStream (stream);
   if (err != paNoError)
     error ("audiorecorder: failed to start audio recording stream");
 }
 
@@ -1181,40 +1181,40 @@ PaStream *
 audioplayer::get_stream (void)
 {
   return stream;
 }
 
 void
 audioplayer::stop (void)
 {
-  if (get_stream () == 0)
+  if (get_stream () == nullptr)
     return;
 
   PaError err;
   set_sample_number (0);
   reset_end_sample ();
   if (! Pa_IsStreamStopped (get_stream ()))
     {
       err = Pa_AbortStream (get_stream ());
       if (err != paNoError)
         error ("audioplayer: failed to stop audio playback stream");
     }
 
   err = Pa_CloseStream (get_stream ());
   if (err != paNoError)
     error ("audioplayer: failed to close audio playback stream");
 
-  stream = 0;
+  stream = nullptr;
 }
 
 bool
 audioplayer::isplaying (void)
 {
-  if (get_stream () == 0)
+  if (get_stream () == nullptr)
     return false;
 
   PaError err;
   err = Pa_IsStreamActive (stream);
   if (err != 0 && err != 1)
     error ("audiorecorder: checking stream activity status failed");
 
   return (err == 1);
@@ -1455,20 +1455,20 @@ portaudio_record_callback (const void *i
 
 static void
 safe_audiorecorder_stop (audiorecorder *recorder)
 {
   recorder->stop ();
 }
 
 audiorecorder::audiorecorder (void)
-  : octave_callback_function (0),
+  : octave_callback_function (nullptr),
     id (-1), fs (44100), nbits (16), channels (2), sample_number (0),
     end_sample (-1), tag (""), y (), userdata (Matrix ()),
-    left (), right (), stream (0), input_parameters (), type ()
+    left (), right (), stream (nullptr), input_parameters (), type ()
 { }
 
 audiorecorder::~audiorecorder (void)
 {
   if (isrecording ())
     {
       warning ("Octave:audio-interrupt",
                "interrupting recording audiorecorder");
@@ -1511,17 +1511,17 @@ audiorecorder::init (void)
 
   if (! device_info)
     warning ("Octave:invalid-default-audio-device",
              "invalid default audio device ID = %d", device);
 
   input_parameters.suggestedLatency
     = (device_info ? device_info->defaultHighInputLatency : -1);
 
-  input_parameters.hostApiSpecificStreamInfo = 0;
+  input_parameters.hostApiSpecificStreamInfo = nullptr;
 }
 
 void
 audiorecorder::set_fs (int fs_arg)
 {
   fs = fs_arg;
 }
 
@@ -1659,17 +1659,17 @@ audiorecorder::getplayer (void)
   player->init ();
 
   return player;
 }
 
 bool
 audiorecorder::isrecording (void)
 {
-  if (get_stream () == 0)
+  if (get_stream () == nullptr)
     return false;
 
   PaError err;
   err = Pa_IsStreamActive (stream);
   if (err != 0 && err != 1)
     error ("audiorecorder: checking stream activity status failed");
 
   return (err == 1);
@@ -1682,25 +1682,25 @@ audiorecorder::record (void)
     stop ();
 
   left.clear ();
   right.clear ();
 
   const unsigned int buffer_size = get_fs () / 20;
 
   PaError err;
-  if (octave_callback_function != 0)
+  if (octave_callback_function != nullptr)
     {
-      err = Pa_OpenStream (&stream, &(input_parameters), 0,
+      err = Pa_OpenStream (&stream, &(input_parameters), nullptr,
                            get_fs (), buffer_size, paClipOff,
                            octave_record_callback, this);
     }
   else
     {
-      err = Pa_OpenStream (&stream, &(input_parameters), 0,
+      err = Pa_OpenStream (&stream, &(input_parameters), nullptr,
                            get_fs (), buffer_size, paClipOff,
                            portaudio_record_callback, this);
     }
   if (err != paNoError)
     error ("audiorecorder: unable to open audio recording stream");
 
   err = Pa_StartStream (stream);
   if (err != paNoError)
@@ -1715,18 +1715,18 @@ audiorecorder::recordblocking (float sec
 
   left.clear ();
   right.clear ();
 
   const unsigned int buffer_size = get_fs () / 20;
   OCTAVE_LOCAL_BUFFER (uint8_t, buffer, buffer_size * 2 * 3);
 
   PaError err;
-  err = Pa_OpenStream (&stream, &(input_parameters), 0,
-                       get_fs (), buffer_size, paClipOff, 0, this);
+  err = Pa_OpenStream (&stream, &(input_parameters), nullptr,
+                       get_fs (), buffer_size, paClipOff, nullptr, this);
   if (err != paNoError)
     error ("audiorecorder: unable to open audio recording stream");
 
   err = Pa_StartStream (stream);
   if (err != paNoError)
     error ("audiorecorder: unable to start audio recording stream");
 
   unsigned int frames = seconds * get_fs ();
@@ -1736,68 +1736,68 @@ audiorecorder::recordblocking (float sec
   frame.add_fcn (safe_audiorecorder_stop, this);
 
   for (unsigned int i = 0; i < frames; i += buffer_size)
     {
       octave_quit ();
 
       Pa_ReadStream (get_stream (), buffer, buffer_size);
 
-      if (octave_callback_function != 0)
-        octave_record_callback (buffer, 0, buffer_size, 0, 0, this);
+      if (octave_callback_function != nullptr)
+        octave_record_callback (buffer, nullptr, buffer_size, nullptr, 0, this);
       else
-        portaudio_record_callback (buffer, 0, buffer_size, 0, 0, this);
+        portaudio_record_callback (buffer, nullptr, buffer_size, nullptr, 0, this);
     }
 }
 
 void
 audiorecorder::pause (void)
 {
-  if (get_stream () == 0)
+  if (get_stream () == nullptr)
     return;
 
   PaError err;
   err = Pa_StopStream (stream);
   if (err != paNoError)
     error ("audiorecorder: unable to stop audio recording stream");
 }
 
 void
 audiorecorder::resume (void)
 {
-  if (get_stream () == 0)
+  if (get_stream () == nullptr)
     return;
 
   PaError err;
   err = Pa_StartStream (stream);
   if (err != paNoError)
     error ("audiorecorder: unable to start audio recording stream");
 }
 
 void
 audiorecorder::stop (void)
 {
-  if (get_stream () == 0)
+  if (get_stream () == nullptr)
     return;
 
   PaError err;
   if (! Pa_IsStreamStopped (get_stream ()))
     {
       err = Pa_AbortStream (get_stream ());
       if (err != paNoError)
         error ("audioplayer: unable to stop audio playback stream");
     }
 
   err = Pa_CloseStream (stream);
   if (err != paNoError)
     error ("audiorecorder: unable to close audio recording stream");
 
   set_sample_number (0);
   reset_end_sample ();
-  stream = 0;
+  stream = nullptr;
 }
 
 void
 audiorecorder::append (float sample_l, float sample_r)
 {
   left.push_back (sample_l);
   right.push_back (sample_r);
   set_sample_number (get_sample_number () + 1);
diff --git a/libinterp/dldfcn/ccolamd.cc b/libinterp/dldfcn/ccolamd.cc
--- a/libinterp/dldfcn/ccolamd.cc
+++ b/libinterp/dldfcn/ccolamd.cc
@@ -281,17 +281,17 @@ ccolamd, csymamd, amd, colamd, symamd, a
           CCOLAMD_NAME (_report) (stats);
 
           error ("ccolamd: internal error!");
         }
     }
   else
     {
       // Order the columns (destroys A)
-      if (! CCOLAMD_NAME () (n_row, n_col, Alen, A, p, knobs, stats, 0))
+      if (! CCOLAMD_NAME () (n_row, n_col, Alen, A, p, knobs, stats, nullptr))
         {
           CCOLAMD_NAME (_report) (stats);
 
           error ("ccolamd: internal error!");
         }
     }
 
   // return the permutation vector
@@ -524,17 +524,17 @@ ccolamd, csymamd, amd, colamd, symamd, a
           error ("csymamd: internal error!");
         }
     }
   else
     {
       if (! CSYMAMD_NAME () (n_col,
                              octave::to_suitesparse_intptr (ridx),
                              octave::to_suitesparse_intptr (cidx),
-                             perm, knobs, stats, &calloc, &free, 0, -1))
+                             perm, knobs, stats, &calloc, &free, nullptr, -1))
         {
           CSYMAMD_NAME (_report)(stats);
 
           error ("csymamd: internal error!");
         }
     }
 
   // return the permutation vector
diff --git a/libinterp/dldfcn/colamd.cc b/libinterp/dldfcn/colamd.cc
--- a/libinterp/dldfcn/colamd.cc
+++ b/libinterp/dldfcn/colamd.cc
@@ -709,17 +709,17 @@ permutations on the tree.
   // column elimination tree post-ordering (reuse variables)
   OCTAVE_LOCAL_BUFFER (octave_idx_type, etree, n_col + 1);
 
   if (is_sym)
     {
       if (n_row != n_col)
         error ("etree: S is marked as symmetric, but is not square");
 
-      symetree (ridx, cidx, etree, 0, n_col);
+      symetree (ridx, cidx, etree, nullptr, n_col);
     }
   else
     {
       OCTAVE_LOCAL_BUFFER (octave_idx_type, colbeg, n_col);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, colend, n_col);
 
       for (octave_idx_type i = 0; i < n_col; i++)
         {
diff --git a/libinterp/dldfcn/dmperm.cc b/libinterp/dldfcn/dmperm.cc
--- a/libinterp/dldfcn/dmperm.cc
+++ b/libinterp/dldfcn/dmperm.cc
@@ -59,17 +59,17 @@ dmperm_internal (bool rank, const octave
   octave_value_list retval;
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
   SparseMatrix m;
   SparseComplexMatrix cm;
   CXSPARSE_NAME () csm;
   csm.m = nr;
   csm.n = nc;
-  csm.x = 0;
+  csm.x = nullptr;
   csm.nz = -1;
 
   if (arg.isreal ())
     {
       m = arg.sparse_matrix_value ();
       csm.nzmax = m.nnz ();
       csm.p = octave::to_suitesparse_intptr (m.xcidx ());
       csm.i = octave::to_suitesparse_intptr (m.xridx ());
diff --git a/libinterp/dldfcn/gzip.cc b/libinterp/dldfcn/gzip.cc
--- a/libinterp/dldfcn/gzip.cc
+++ b/libinterp/dldfcn/gzip.cc
@@ -160,17 +160,17 @@ namespace octave
 
       zipper (const zipper&) = delete;
 
       zipper& operator = (const zipper&) = delete;
 
       ~zipper (void)
       {
         if (m_bz != nullptr)
-          BZ2_bzWriteClose (&m_status, m_bz, 1, 0, 0);
+          BZ2_bzWriteClose (&m_status, m_bz, 1, nullptr, nullptr);
       }
 
       void deflate (void)
       {
         const std::size_t buf_len = 8192;
         char buf[buf_len];
         std::size_t n_read;
         while ((n_read = std::fread (buf, sizeof (buf[0]), buf_len, m_source.m_fp)) != 0)
@@ -183,17 +183,17 @@ namespace octave
           }
         if (std::ferror (m_source.m_fp))
           throw std::runtime_error ("failed to read from source file");
       }
 
       void close (void)
       {
         int abandon = (m_status == BZ_IO_ERROR) ? 1 : 0;
-        BZ2_bzWriteClose (&m_status, m_bz, abandon, 0, 0);
+        BZ2_bzWriteClose (&m_status, m_bz, abandon, nullptr, nullptr);
         if (m_status != BZ_OK)
           throw std::runtime_error ("failed to close bzip2 stream");
         m_bz = nullptr;
 
         // We have no error handling for failing to close source, let
         // the destructor close it.
         m_dest.close ();
       }
diff --git a/libinterp/dldfcn/symbfact.cc b/libinterp/dldfcn/symbfact.cc
--- a/libinterp/dldfcn/symbfact.cc
+++ b/libinterp/dldfcn/symbfact.cc
@@ -116,17 +116,17 @@ Cholesky@tie{}factorization as determine
 
   octave_value_list retval;
 
   double dummy;
   cholmod_sparse Astore;
   cholmod_sparse *A = &Astore;
   A->packed = true;
   A->sorted = true;
-  A->nz = 0;
+  A->nz = nullptr;
 #if defined (OCTAVE_ENABLE_64)
   A->itype = CHOLMOD_LONG;
 #else
   A->itype = CHOLMOD_INT;
 #endif
   A->dtype = CHOLMOD_DOUBLE;
   A->stype = 1;
   A->x = &dummy;
@@ -207,17 +207,17 @@ Cholesky@tie{}factorization as determine
   cholmod_common Common;
   cholmod_common *cm = &Common;
   CHOLMOD_NAME(start) (cm);
 
   double spu = octave_sparse_params::get_key ("spumoni");
   if (spu == 0.)
     {
       cm->print = -1;
-      SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, 0);
+      SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, nullptr);
     }
   else
     {
       cm->print = static_cast<int> (spu) + 2;
       SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, &SparseCholPrint);
     }
 
   cm->error_handler = &SparseCholError;
@@ -244,44 +244,44 @@ Cholesky@tie{}factorization as determine
   std::string err_msg;
 
   if (cm->status < CHOLMOD_OK)
     {
       err_msg = "symbfact: matrix corrupted";
       goto cleanup;
     }
 
-  if (CHOLMOD_NAME(postorder) (Parent, n, 0, Post, cm) != n)
+  if (CHOLMOD_NAME(postorder) (Parent, n, nullptr, Post, cm) != n)
     {
       err_msg = "symbfact: postorder failed";
       goto cleanup;
     }
 
-  CHOLMOD_NAME(rowcolcounts) (Alo, 0, 0, Parent, Post, 0, ColCount, First,
-                              octave::to_suitesparse_intptr (Level), cm);
+  CHOLMOD_NAME(rowcolcounts) (Alo, nullptr, 0, Parent, Post, nullptr, ColCount,
+                              First, octave::to_suitesparse_intptr (Level), cm);
 
   if (cm->status < CHOLMOD_OK)
     {
       err_msg = "symbfact: matrix corrupted";
       goto cleanup;
     }
 
   if (nargout > 4)
     {
       cholmod_sparse *A1, *A2;
 
       if (A->stype == 1)
         {
           A1 = A;
-          A2 = 0;
+          A2 = nullptr;
         }
       else if (A->stype == -1)
         {
           A1 = F;
-          A2 = 0;
+          A2 = nullptr;
         }
       else if (coletree)
         {
           A1 = F;
           A2 = A;
         }
       else
         {
diff --git a/libinterp/octave-value/ov-base-int.cc b/libinterp/octave-value/ov-base-int.cc
--- a/libinterp/octave-value/ov-base-int.cc
+++ b/libinterp/octave-value/ov-base-int.cc
@@ -422,17 +422,17 @@ octave_base_int_matrix<T>::save_hdf5 (oc
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv(rank-i-1);
 
-  space_hid = H5Screate_simple (rank, hdims, 0);
+  space_hid = H5Screate_simple (rank, hdims, nullptr);
 
   if (space_hid < 0) return false;
 #if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid,
                         octave_H5P_DEFAULT);
@@ -706,17 +706,17 @@ octave_base_int_scalar<T>::save_hdf5 (oc
 
 #if defined (HAVE_HDF5)
 
   hid_t save_type_hid = HDF5_SAVE_TYPE;
   hsize_t dimens[3];
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
 
-  space_hid = H5Screate_simple (0, dimens, 0);
+  space_hid = H5Screate_simple (0, dimens, nullptr);
   if (space_hid < 0) return false;
 
 #if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, save_type_hid, space_hid,
                         octave_H5P_DEFAULT);
diff --git a/libinterp/octave-value/ov-base-int.h b/libinterp/octave-value/ov-base-int.h
--- a/libinterp/octave-value/ov-base-int.h
+++ b/libinterp/octave-value/ov-base-int.h
@@ -112,17 +112,17 @@ public:
 
   ~octave_base_int_scalar (void) = default;
 
   octave_base_value * clone (void) const
   { return new octave_base_int_scalar (*this); }
   octave_base_value * empty_clone (void) const
   { return new octave_base_int_scalar (); }
 
-  octave_base_value * try_narrowing_conversion (void) { return 0; }
+  octave_base_value * try_narrowing_conversion (void) { return nullptr; }
 
   bool isreal (void) const { return true; }
 
   bool is_real_scalar (void) const { return true; }
 
   //  void increment (void) { scalar += 1; }
 
   //  void decrement (void) { scalar -= 1; }
diff --git a/libinterp/octave-value/ov-base-mat.h b/libinterp/octave-value/ov-base-mat.h
--- a/libinterp/octave-value/ov-base-mat.h
+++ b/libinterp/octave-value/ov-base-mat.h
@@ -48,26 +48,26 @@ octave_base_matrix : public octave_base_
 {
 public:
 
   octave_base_matrix (void)
     : octave_base_value (), matrix (), typ (), idx_cache () { }
 
   octave_base_matrix (const MT& m, const MatrixType& t = MatrixType ())
     : octave_base_value (), matrix (m),
-      typ (t.is_known () ? new MatrixType (t) : 0), idx_cache ()
+      typ (t.is_known () ? new MatrixType (t) : nullptr), idx_cache ()
   {
     if (matrix.ndims () == 0)
       matrix.resize (dim_vector (0, 0));
   }
 
   octave_base_matrix (const octave_base_matrix& m)
     : octave_base_value (), matrix (m.matrix),
-      typ (m.typ ? new MatrixType (*m.typ) : 0),
-      idx_cache (m.idx_cache ? new idx_vector (*m.idx_cache) : 0)
+      typ (m.typ ? new MatrixType (*m.typ) : nullptr),
+      idx_cache (m.idx_cache ? new idx_vector (*m.idx_cache) : nullptr)
   { }
 
   ~octave_base_matrix (void) { clear_cached_info (); }
 
   size_t byte_size (void) const { return matrix.byte_size (); }
 
   octave_value squeeze (void) const { return MT (matrix.squeeze ()); }
 
@@ -182,24 +182,24 @@ public:
 
 protected:
 
   MT matrix;
 
   idx_vector set_idx_cache (const idx_vector& idx) const
   {
     delete idx_cache;
-    idx_cache = (idx ? new idx_vector (idx) : 0);
+    idx_cache = (idx ? new idx_vector (idx) : nullptr);
     return idx;
   }
 
   void clear_cached_info (void) const
   {
-    delete typ; typ = 0;
-    delete idx_cache; idx_cache = 0;
+    delete typ; typ = nullptr;
+    delete idx_cache; idx_cache = nullptr;
   }
 
   mutable MatrixType *typ;
   mutable idx_vector *idx_cache;
 
 private:
 
   // No assignment.
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -998,17 +998,17 @@ octave_base_value::write (octave::stream
                           int, octave::mach_info::float_format) const
 {
   err_wrong_type_arg ("octave_base_value::write()", type_name ());
 }
 
 mxArray *
 octave_base_value::as_mxArray (void) const
 {
-  return 0;
+  return nullptr;
 }
 
 octave_value
 octave_base_value::diag (octave_idx_type) const
 {
   err_wrong_type_arg ("octave_base_value::diag ()", type_name ());
 }
 
@@ -1269,23 +1269,23 @@ octave_base_value::numeric_assign (const
 
           // Try biased (one-sided) conversions first.
           if (cf_rhs.type_id () >= 0
               && (octave_value_typeinfo::lookup_assign_op (octave_value::op_asn_eq,
                                                            t_lhs,
                                                            cf_rhs.type_id ())
                   || octave_value_typeinfo::lookup_pref_assign_conv (t_lhs,
                                                                      cf_rhs.type_id ()) >= 0))
-            cf_this = 0;
+            cf_this = nullptr;
           else if (cf_this.type_id () >= 0
                    && (octave_value_typeinfo::lookup_assign_op (octave_value::op_asn_eq,
                                                                 cf_this.type_id (), t_rhs)
                        || octave_value_typeinfo::lookup_pref_assign_conv (cf_this.type_id (),
                                                                           t_rhs) >= 0))
-            cf_rhs = 0;
+            cf_rhs = nullptr;
 
           if (cf_rhs)
             {
               octave_base_value *tmp = cf_rhs (rhs.get_rep ());
 
               if (! tmp)
                 err_assign_conversion_failed (type_name (), rhs.type_name ());
 
diff --git a/libinterp/octave-value/ov-base.h b/libinterp/octave-value/ov-base.h
--- a/libinterp/octave-value/ov-base.h
+++ b/libinterp/octave-value/ov-base.h
@@ -185,17 +185,17 @@ octave_base_value
 public:
 
   typedef octave_base_value * (*type_conv_fcn) (const octave_base_value&);
 
   // type conversion, including result type information
   class type_conv_info
   {
   public:
-    type_conv_info (type_conv_fcn f = 0, int t = -1)
+    type_conv_info (type_conv_fcn f = nullptr, int t = -1)
       : _fcn (f), _type_id (t) { }
 
     operator type_conv_fcn (void) const { return _fcn; }
 
     octave_base_value * operator () (const octave_base_value& v) const
     { return (*_fcn) (v); }
 
     int type_id (void) const { return _type_id; }
@@ -247,17 +247,17 @@ public:
   virtual octave_value as_int32 (void) const;
   virtual octave_value as_int64 (void) const;
 
   virtual octave_value as_uint8 (void) const;
   virtual octave_value as_uint16 (void) const;
   virtual octave_value as_uint32 (void) const;
   virtual octave_value as_uint64 (void) const;
 
-  virtual octave_base_value * try_narrowing_conversion (void) { return 0; }
+  virtual octave_base_value * try_narrowing_conversion (void) { return nullptr; }
 
   virtual void maybe_economize (void) { }
 
   virtual Matrix size (void);
 
   virtual octave_idx_type numel (const octave_value_list&);
 
   virtual octave_value
@@ -581,20 +581,20 @@ public:
 
   virtual size_t nparents (void) const;
 
   virtual std::list<std::string> parent_class_name_list (void) const;
 
   virtual string_vector parent_class_names (void) const;
 
   virtual octave_base_value * find_parent_class (const std::string&)
-  { return 0; }
+  { return nullptr; }
 
   virtual octave_base_value * unique_parent_class (const std::string&)
-  { return 0; }
+  { return nullptr; }
 
   virtual bool is_instance_of (const std::string&) const
   { return false; }
 
   virtual octave_function * function_value (bool silent = false);
 
   virtual octave_user_function * user_function_value (bool silent = false);
 
@@ -653,21 +653,21 @@ public:
   virtual bool
   load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   virtual int
   write (octave::stream& os, int block_size,
          oct_data_conv::data_type output_type, int skip,
          octave::mach_info::float_format flt_fmt) const;
 
-  virtual void * mex_get_data (void) const { return 0; }
+  virtual void * mex_get_data (void) const { return nullptr; }
 
-  virtual octave_idx_type * mex_get_ir (void) const { return 0; }
+  virtual octave_idx_type * mex_get_ir (void) const { return nullptr; }
 
-  virtual octave_idx_type * mex_get_jc (void) const { return 0; }
+  virtual octave_idx_type * mex_get_jc (void) const { return nullptr; }
 
   virtual mxArray * as_mxArray (void) const;
 
   virtual octave_value diag (octave_idx_type k = 0) const;
 
   virtual octave_value diag (octave_idx_type m, octave_idx_type n) const;
 
   virtual octave_value sort (octave_idx_type dim = 0,
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -444,17 +444,17 @@ octave_bool_matrix::save_hdf5 (octave_hd
   boolNDArray m = bool_array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv(rank-i-1);
 
-  space_hid = H5Screate_simple (rank, hdims, 0);
+  space_hid = H5Screate_simple (rank, hdims, nullptr);
   if (space_hid < 0) return false;
 #if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_HBOOL, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_HBOOL, space_hid,
                         octave_H5P_DEFAULT);
 #endif
diff --git a/libinterp/octave-value/ov-bool-sparse.cc b/libinterp/octave-value/ov-bool-sparse.cc
--- a/libinterp/octave-value/ov-bool-sparse.cc
+++ b/libinterp/octave-value/ov-bool-sparse.cc
@@ -351,17 +351,17 @@ octave_sparse_bool_matrix::save_hdf5 (oc
     return false;
 
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
   SparseBoolMatrix m = sparse_bool_matrix_value ();
   octave_idx_type tmp;
   hsize_t hdims[2];
 
-  space_hid = H5Screate_simple (0, hdims, 0);
+  space_hid = H5Screate_simple (0, hdims, nullptr);
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 #if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT,
@@ -440,17 +440,17 @@ octave_sparse_bool_matrix::save_hdf5 (oc
       return false;
     }
 
   H5Sclose (space_hid);
 
   hdims[0] = m.cols () + 1;
   hdims[1] = 1;
 
-  space_hid = H5Screate_simple (2, hdims, 0);
+  space_hid = H5Screate_simple (2, hdims, nullptr);
 
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
 #if defined (HAVE_HDF5_18)
@@ -479,17 +479,17 @@ octave_sparse_bool_matrix::save_hdf5 (oc
       return false;
     }
 
   H5Sclose (space_hid);
 
   hdims[0] = m.nnz ();
   hdims[1] = 1;
 
-  space_hid = H5Screate_simple (2, hdims, 0);
+  space_hid = H5Screate_simple (2, hdims, nullptr);
 
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
 #if defined (HAVE_HDF5_18)
diff --git a/libinterp/octave-value/ov-bool.cc b/libinterp/octave-value/ov-bool.cc
--- a/libinterp/octave-value/ov-bool.cc
+++ b/libinterp/octave-value/ov-bool.cc
@@ -228,17 +228,17 @@ octave_bool::save_hdf5 (octave_hdf5_id l
   bool retval = false;
 
 #if defined (HAVE_HDF5)
 
   hsize_t dimens[3];
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
 
-  space_hid = H5Screate_simple (0, dimens, 0);
+  space_hid = H5Screate_simple (0, dimens, nullptr);
   if (space_hid < 0) return false;
 #if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid,
                         octave_H5P_DEFAULT);
 #endif
diff --git a/libinterp/octave-value/ov-builtin.h b/libinterp/octave-value/ov-builtin.h
--- a/libinterp/octave-value/ov-builtin.h
+++ b/libinterp/octave-value/ov-builtin.h
@@ -45,38 +45,38 @@ namespace octave
 // Builtin functions.
 
 class
 OCTINTERP_API
 octave_builtin : public octave_function
 {
 public:
 
-  octave_builtin (void) : octave_function (), f (0), file (), jtype (0) { }
+  octave_builtin (void) : octave_function (), f (0), file (), jtype (nullptr) { }
 
   typedef octave_value_list (*meth) (octave::interpreter&,
                                      const octave_value_list&, int);
 
   typedef octave_value_list (*fcn) (const octave_value_list&, int);
 
   octave_builtin (fcn ff, const std::string& nm = "",
                   const std::string& ds = "")
-    : octave_function (nm, ds), f (ff), m (0), file (), jtype (0) { }
+    : octave_function (nm, ds), f (ff), m (0), file (), jtype (nullptr) { }
 
   octave_builtin (meth mm, const std::string& nm = "",
                   const std::string& ds = "")
-    : octave_function (nm, ds), f (0), m (mm), file (), jtype (0) { }
+    : octave_function (nm, ds), f (0), m (mm), file (), jtype (nullptr) { }
 
   octave_builtin (fcn ff, const std::string& nm, const std::string& fnm,
                   const std::string& ds)
-    : octave_function (nm, ds), f (ff), m (0), file (fnm), jtype (0) { }
+    : octave_function (nm, ds), f (ff), m (0), file (fnm), jtype (nullptr) { }
 
   octave_builtin (meth mm, const std::string& nm, const std::string& fnm,
                   const std::string& ds)
-    : octave_function (nm, ds), f (0), m (mm), file (fnm), jtype (0) { }
+    : octave_function (nm, ds), f (0), m (mm), file (fnm), jtype (nullptr) { }
 
   // No copying!
 
   octave_builtin (const octave_builtin& ob) = delete;
 
   octave_builtin& operator = (const octave_builtin& ob) = delete;
 
   ~octave_builtin (void) = default;
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -1003,17 +1003,17 @@ octave_cell::save_hdf5 (octave_hdf5_id l
 #endif
 
   if (data_hid < 0)
     return false;
 
   // Have to save cell array shape, since can't have a
   // dataset of groups....
 
-  space_hid = H5Screate_simple (1, &rank, 0);
+  space_hid = H5Screate_simple (1, &rank, nullptr);
 
   if (space_hid < 0)
     {
       H5Gclose (data_hid);
       return false;
     }
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, hdims, rank);
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -270,17 +270,17 @@ octave_class::dotref (const octave_value
 
   std::string method_class = get_current_method_class ();
 
   // Find the class in which this method resides before attempting to access
   // the requested field.
 
   octave_base_value *obvp = find_parent_class (method_class);
 
-  if (obvp == 0)
+  if (obvp == nullptr)
     error ("malformed class");
 
   octave_map my_map = (obvp != this) ? obvp->map_value () : map;
 
   std::string nm = idx(0).xstring_value ("invalid index for class");
 
   octave_map::const_iterator p = my_map.seek (nm);
 
@@ -1413,17 +1413,17 @@ octave_class::save_hdf5 (octave_hdf5_id 
     goto error_cleanup;
 
   // Add the class name to the group
   type_hid = H5Tcopy (H5T_C_S1); H5Tset_size (type_hid, c_name.length () + 1);
   if (type_hid < 0)
     goto error_cleanup;
 
   hdims[0] = 0;
-  space_hid = H5Screate_simple (0 , hdims, 0);
+  space_hid = H5Screate_simple (0 , hdims, nullptr);
   if (space_hid < 0)
     goto error_cleanup;
 #if defined (HAVE_HDF5_18)
   class_hid = H5Dcreate (group_hid, "classname",  type_hid, space_hid,
                          octave_H5P_DEFAULT, octave_H5P_DEFAULT,
                          octave_H5P_DEFAULT);
 #else
   class_hid = H5Dcreate (group_hid, "classname",  type_hid, space_hid,
diff --git a/libinterp/octave-value/ov-complex.cc b/libinterp/octave-value/ov-complex.cc
--- a/libinterp/octave-value/ov-complex.cc
+++ b/libinterp/octave-value/ov-complex.cc
@@ -359,17 +359,17 @@ octave_complex::save_hdf5 (octave_hdf5_i
   bool retval = false;
 
 #if defined (HAVE_HDF5)
 
   hsize_t dimens[3];
   hid_t space_hid, type_hid, data_hid;
   space_hid = type_hid = data_hid = -1;
 
-  space_hid = H5Screate_simple (0, dimens, 0);
+  space_hid = H5Screate_simple (0, dimens, nullptr);
   if (space_hid < 0)
     return false;
 
   type_hid = hdf5_make_complex_type (H5T_NATIVE_DOUBLE);
   if (type_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -543,17 +543,17 @@ octave_complex_matrix::save_hdf5 (octave
   ComplexNDArray m = complex_array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv(rank-i-1);
 
-  space_hid = H5Screate_simple (rank, hdims, 0);
+  space_hid = H5Screate_simple (rank, hdims, nullptr);
   if (space_hid < 0) return false;
 
   hid_t save_type_hid = H5T_NATIVE_DOUBLE;
 
   if (save_as_floats)
     {
       if (m.too_large_for_float ())
         {
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -383,17 +383,17 @@ octave_sparse_complex_matrix::save_hdf5 
     return false;
 
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
   SparseComplexMatrix m = sparse_complex_matrix_value ();
   octave_idx_type tmp;
   hsize_t hdims[2];
 
-  space_hid = H5Screate_simple (0, hdims, 0);
+  space_hid = H5Screate_simple (0, hdims, nullptr);
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
 #if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid,
@@ -470,17 +470,17 @@ octave_sparse_complex_matrix::save_hdf5 
       return false;
     }
 
   H5Sclose (space_hid);
 
   hdims[0] = m.cols () + 1;
   hdims[1] = 1;
 
-  space_hid = H5Screate_simple (2, hdims, 0);
+  space_hid = H5Screate_simple (2, hdims, nullptr);
 
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
 #if defined (HAVE_HDF5_18)
@@ -508,17 +508,17 @@ octave_sparse_complex_matrix::save_hdf5 
       return false;
     }
 
   H5Sclose (space_hid);
 
   hdims[0] = m.nnz ();
   hdims[1] = 1;
 
-  space_hid = H5Screate_simple (2, hdims, 0);
+  space_hid = H5Screate_simple (2, hdims, nullptr);
 
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
 #if defined (HAVE_HDF5_18)
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -734,17 +734,17 @@ octave_fcn_handle::save_hdf5 (octave_hdf
     {
       H5Gclose (group_hid);
       return false;
     }
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, 2);
   hdims[0] = 0;
   hdims[1] = 0;
-  space_hid = H5Screate_simple (0 , hdims, 0);
+  space_hid = H5Screate_simple (0 , hdims, nullptr);
   if (space_hid < 0)
     {
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
 #if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid,
@@ -866,17 +866,17 @@ octave_fcn_handle::save_hdf5 (octave_hdf
       std::string octaveroot = octave::config::octave_exec_home ();
 
       octave_function *f = function_value ();
       std::string fpath = (f ? f->fcn_file_name () : "");
 
       H5Sclose (space_hid);
       hdims[0] = 1;
       hdims[1] = octaveroot.length ();
-      space_hid = H5Screate_simple (0 , hdims, 0);
+      space_hid = H5Screate_simple (0 , hdims, nullptr);
       if (space_hid < 0)
         {
           H5Tclose (type_hid);
           H5Gclose (group_hid);
           return false;
         }
 
       H5Tclose (type_hid);
@@ -902,17 +902,17 @@ octave_fcn_handle::save_hdf5 (octave_hdf
           H5Tclose (type_hid);
           H5Gclose (group_hid);
           return false;
         }
 
       H5Sclose (space_hid);
       hdims[0] = 1;
       hdims[1] = fpath.length ();
-      space_hid = H5Screate_simple (0 , hdims, 0);
+      space_hid = H5Screate_simple (0 , hdims, nullptr);
       if (space_hid < 0)
         {
           H5Tclose (type_hid);
           H5Gclose (group_hid);
           return false;
         }
 
       H5Tclose (type_hid);
@@ -1118,20 +1118,20 @@ octave_fcn_handle::load_hdf5 (octave_hdf
 
       H5E_auto_t err_func;
       void *err_func_data;
 
       // turn off error reporting temporarily, but save the error
       // reporting function:
 #if defined (HAVE_HDF5_18)
       H5Eget_auto (octave_H5E_DEFAULT, &err_func, &err_func_data);
-      H5Eset_auto (octave_H5E_DEFAULT, 0, 0);
+      H5Eset_auto (octave_H5E_DEFAULT, 0, nullptr);
 #else
       H5Eget_auto (&err_func, &err_func_data);
-      H5Eset_auto (0, 0);
+      H5Eset_auto (0, nullptr);
 #endif
 
       hid_t attr_id = H5Aopen_name (group_hid, "SYMBOL_TABLE");
 
       if (attr_id >= 0)
         {
           if (H5Aread (attr_id, H5T_NATIVE_IDX, &len) < 0)
             success = false;
@@ -1234,20 +1234,20 @@ octave_fcn_handle::load_hdf5 (octave_hdf
 
       H5E_auto_t err_func;
       void *err_func_data;
 
       // turn off error reporting temporarily, but save the error
       // reporting function:
 #if defined (HAVE_HDF5_18)
       H5Eget_auto (octave_H5E_DEFAULT, &err_func, &err_func_data);
-      H5Eset_auto (octave_H5E_DEFAULT, 0, 0);
+      H5Eset_auto (octave_H5E_DEFAULT, 0, nullptr);
 #else
       H5Eget_auto (&err_func, &err_func_data);
-      H5Eset_auto (0, 0);
+      H5Eset_auto (0, nullptr);
 #endif
 
       hid_t attr_id = H5Aopen_name (group_hid, "OCTAVEROOT");
       if (attr_id >= 0)
         {
           H5Tclose (type_hid);
           type_hid = H5Aget_type (attr_id);
           type_class_hid = H5Tget_class (type_hid);
@@ -1627,17 +1627,17 @@ make_fcn_handle (const std::string& nm, 
       retval = octave_value (new octave_fcn_handle (f, tnm));
     }
   else
     {
       octave::load_path& lp = octave::__get_load_path__ ("make_fcn_handle");
 
       // Globally visible (or no match yet).  Query overloads.
       std::list<std::string> classes = lp.overloads (tnm);
-      bool any_match = fptr != 0 || classes.size () > 0;
+      bool any_match = fptr != nullptr || classes.size () > 0;
       if (! any_match)
         {
           // No match found, try updating load_path and query classes again.
           lp.update ();
           classes = lp.overloads (tnm);
           any_match = classes.size () > 0;
         }
 
@@ -1753,17 +1753,17 @@ particular output format.
 @seealso{func2str, str2func}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
   octave_fcn_handle *fh = args(0).fcn_handle_value ("functions: FCN_HANDLE argument must be a function handle object");
 
-  octave_function *fcn = (fh ? fh->function_value () : 0);
+  octave_function *fcn = (fh ? fh->function_value () : nullptr);
 
   if (! fcn)
     error ("functions: FCN_HANDLE is not a valid function handle object");
 
   octave_scalar_map m;
 
   std::string fh_nm = fh->fcn_name ();
 
@@ -1967,29 +1967,30 @@ octave_fcn_binder::octave_fcn_binder (co
 
 octave_fcn_handle *
 octave_fcn_binder::maybe_binder (const octave_value& f,
                                  octave::tree_evaluator *tw)
 {
   octave_fcn_handle *retval = nullptr;
 
   octave_user_function *usr_fcn = f.user_function_value (false);
-  octave::tree_parameter_list *param_list = (usr_fcn ? usr_fcn->parameter_list () : 0);
+  octave::tree_parameter_list *param_list = (usr_fcn ? usr_fcn->parameter_list ()
+                                                     : nullptr);
 
   octave::tree_statement_list *cmd_list = nullptr;
   octave::tree_expression *body_expr = nullptr;
 
   if (usr_fcn)
     {
       cmd_list = usr_fcn->body ();
       if (cmd_list)
         {
           // Verify that body is a single expression (always true in theory).
           body_expr = (cmd_list->length () == 1
-                       ? cmd_list->front ()->expression () : 0);
+                       ? cmd_list->front ()->expression () : nullptr);
         }
     }
 
   if (body_expr && body_expr->is_index_expression ()
       && ! (param_list && param_list->takes_varargs ()))
     {
       // It's an index expression.
       octave::tree_index_expression *idx_expr = dynamic_cast<octave::tree_index_expression *>
@@ -2012,17 +2013,17 @@ octave_fcn_binder::maybe_binder (const o
           std::map<std::string, int> arginmap;
           int npar = 0;
 
           if (param_list)
             {
               for (auto& param_p : *param_list)
                 {
                   octave::tree_decl_elt *elt = param_p;
-                  octave::tree_identifier *id = (elt ? elt->ident () : 0);
+                  octave::tree_identifier *id = (elt ? elt->ident () : nullptr);
                   if (id && ! id->is_black_hole ())
                     arginmap[id->name ()] = npar;
                 }
             }
 
           if (arg_list && arg_list->length () > 0)
             {
               bool bad = false;
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -308,17 +308,17 @@ octave_fcn_inline::save_hdf5 (octave_hdf
   //        than a null padded matrix?
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, 2);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   hdims[1] = ifargs.numel ();
   hdims[0] = len + 1;
 
-  space_hid = H5Screate_simple (2, hdims, 0);
+  space_hid = H5Screate_simple (2, hdims, nullptr);
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 #if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "args", H5T_NATIVE_CHAR, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
@@ -361,17 +361,17 @@ octave_fcn_inline::save_hdf5 (octave_hdf
   H5Tset_size (type_hid, nm.length () + 1);
   if (type_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
   hdims[0] = 0;
-  space_hid = H5Screate_simple (0 , hdims, 0);
+  space_hid = H5Screate_simple (0 , hdims, nullptr);
   if (space_hid < 0)
     {
       H5Tclose (type_hid);
       H5Gclose (group_hid);
       return false;
     }
 #if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "nm",  type_hid, space_hid,
diff --git a/libinterp/octave-value/ov-fcn.cc b/libinterp/octave-value/ov-fcn.cc
--- a/libinterp/octave-value/ov-fcn.cc
+++ b/libinterp/octave-value/ov-fcn.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include "ovl.h"
 #include "ov-fcn.h"
 
 
 octave_base_value *
 octave_function::clone (void) const
 {
   panic_impossible ();
-  return 0;
+  return nullptr;
 }
 
 octave_base_value *
 octave_function::empty_clone (void) const
 {
   panic_impossible ();
-  return 0;
+  return nullptr;
 }
diff --git a/libinterp/octave-value/ov-fcn.h b/libinterp/octave-value/ov-fcn.h
--- a/libinterp/octave-value/ov-fcn.h
+++ b/libinterp/octave-value/ov-fcn.h
@@ -76,21 +76,21 @@ public:
   virtual std::string src_file_name (void) const { return ""; }
 
   // The name to show in the profiler (also used as map-key).
   virtual std::string profiler_name (void) const { return name (); }
 
   virtual std::string parent_fcn_name (void) const { return ""; }
 
   virtual octave::symbol_table::scope * parent_fcn_scope (void) const
-  { return 0; }
+  { return nullptr; }
 
   virtual void mark_fcn_file_up_to_date (const octave::sys::time&) { }
 
-  virtual octave::symbol_table::scope * scope (void) { return 0; }
+  virtual octave::symbol_table::scope * scope (void) { return nullptr; }
 
   virtual octave::sys::time time_parsed (void) const
   { return octave::sys::time (static_cast<time_t> (0)); }
 
   virtual octave::sys::time time_checked (void) const
   { return octave::sys::time (static_cast<time_t> (0)); }
 
   virtual bool is_subfunction (void) const { return false; }
diff --git a/libinterp/octave-value/ov-float.cc b/libinterp/octave-value/ov-float.cc
--- a/libinterp/octave-value/ov-float.cc
+++ b/libinterp/octave-value/ov-float.cc
@@ -249,17 +249,17 @@ octave_float_scalar::save_hdf5 (octave_h
   bool retval = false;
 
 #if defined (HAVE_HDF5)
 
   hsize_t dimens[3];
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
 
-  space_hid = H5Screate_simple (0, dimens, 0);
+  space_hid = H5Screate_simple (0, dimens, nullptr);
   if (space_hid < 0) return false;
 #if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_FLOAT, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_FLOAT, space_hid,
                         octave_H5P_DEFAULT);
 #endif
diff --git a/libinterp/octave-value/ov-flt-complex.cc b/libinterp/octave-value/ov-flt-complex.cc
--- a/libinterp/octave-value/ov-flt-complex.cc
+++ b/libinterp/octave-value/ov-flt-complex.cc
@@ -306,17 +306,17 @@ octave_float_complex::save_hdf5 (octave_
   bool retval = false;
 
 #if defined (HAVE_HDF5)
 
   hsize_t dimens[3];
   hid_t space_hid, type_hid, data_hid;
   space_hid = type_hid = data_hid = -1;
 
-  space_hid = H5Screate_simple (0, dimens, 0);
+  space_hid = H5Screate_simple (0, dimens, nullptr);
   if (space_hid < 0)
     return false;
 
   type_hid = hdf5_make_complex_type (H5T_NATIVE_FLOAT);
   if (type_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -508,17 +508,17 @@ octave_float_complex_matrix::save_hdf5 (
   FloatComplexNDArray m = complex_array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv(rank-i-1);
 
-  space_hid = H5Screate_simple (rank, hdims, 0);
+  space_hid = H5Screate_simple (rank, hdims, nullptr);
   if (space_hid < 0) return false;
 
   hid_t save_type_hid = H5T_NATIVE_FLOAT;
 
 #if defined (HAVE_HDF5_INT2FLOAT_CONVERSIONS)
   // hdf5 currently doesn't support float/integer conversions
   else
     {
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -582,17 +582,17 @@ octave_float_matrix::save_hdf5 (octave_h
   FloatNDArray m = array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv(rank-i-1);
 
-  space_hid = H5Screate_simple (rank, hdims, 0);
+  space_hid = H5Screate_simple (rank, hdims, nullptr);
 
   if (space_hid < 0) return false;
 
   hid_t save_type_hid = H5T_NATIVE_FLOAT;
 
 #if defined (HAVE_HDF5_INT2FLOAT_CONVERSIONS)
   // hdf5 currently doesn't support float/integer conversions
   else
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -72,17 +72,17 @@ typedef jint (JNICALL *JNI_GetCreatedJav
                                                  jsize *nVMs);
 
 template <typename T>
 class java_local_ref
 {
 public:
 
   java_local_ref (JNIEnv *_env)
-    : jobj (0), detached (false), env (_env) { }
+    : jobj (nullptr), detached (false), env (_env) { }
 
   java_local_ref (JNIEnv *_env, T obj)
     : jobj (obj), detached (false), env (_env) { }
 
   ~java_local_ref (void) { release (); }
 
   T& operator = (T obj)
   {
@@ -101,17 +101,17 @@ public:
 
 private:
 
   void release (void)
   {
     if (env && jobj && ! detached)
       env->DeleteLocalRef (jobj);
 
-    jobj = 0;
+    jobj = nullptr;
   }
 
   java_local_ref (void)
     : jobj (0), detached (false), env (0)
   { }
 
 protected:
 
@@ -188,17 +188,17 @@ namespace octave
   class JVMArgs
   {
   public:
 
     JVMArgs (void)
     {
       vm_args.version = JNI_VERSION_1_2;
       vm_args.nOptions = 0;
-      vm_args.options = 0;
+      vm_args.options = nullptr;
       vm_args.ignoreUnrecognized = false;
     }
 
     ~JVMArgs (void)
     {
       clean ();
     }
 
@@ -232,24 +232,24 @@ namespace octave
             }
         }
     }
 
   private:
 
     void clean (void)
     {
-      if (vm_args.options != 0)
+      if (vm_args.options != nullptr)
         {
           for (int i = 0; i < vm_args.nOptions; i++)
             delete [] vm_args.options[i].optionString;
 
           delete [] vm_args.options;
 
-          vm_args.options = 0;
+          vm_args.options = nullptr;
           vm_args.nOptions = 0;
         }
     }
 
     void update (void)
     {
       clean ();
 
@@ -491,17 +491,17 @@ initial_class_path (void)
 static void
 initialize_jvm (void)
 {
   // Most of the time JVM already exists and has been initialized.
   if (jvm)
     return;
 
   JNIEnv *current_env;
-  const char *static_locale = setlocale (LC_ALL, 0);
+  const char *static_locale = setlocale (LC_ALL, nullptr);
   const std::string locale (static_locale);
 
 #if defined (OCTAVE_USE_WINDOWS_API)
 
   HMODULE hMod = GetModuleHandle ("jvm.dll");
   std::string jvm_lib_path;
 
   if (hMod)
@@ -593,17 +593,17 @@ initialize_jvm (void)
       switch (jvm->GetEnv (reinterpret_cast<void **> (&current_env),
                            JNI_VERSION_1_2))
         {
         case JNI_EDETACHED:
           // Attach the current thread
           JavaVMAttachArgs vm_args;
           vm_args.version = JNI_VERSION_1_2;
           vm_args.name = const_cast<char *> ("octave");
-          vm_args.group = 0;
+          vm_args.group = nullptr;
           if (jvm->AttachCurrentThread (reinterpret_cast<void **> (&current_env),
                                         &vm_args) < 0)
             error ("JVM internal error, unable to attach octave to existing JVM");
           break;
 
         case JNI_EVERSION:
           error ("JVM internal error, the required JNI version is not supported");
           break;
@@ -655,34 +655,34 @@ terminate_jvm (void)
 {
   if (jvm)
     {
       if (jvm_attached)
         jvm->DetachCurrentThread ();
       else
         jvm->DestroyJavaVM ();
 
-      jvm = 0;
+      jvm = nullptr;
       jvm_attached = false;
 
       if (jvm_lib)
         jvm_lib.close ();
 
       octave_set_default_fpucw ();
     }
 }
 
 static std::string
 jstring_to_string (JNIEnv *jni_env, jstring s)
 {
   std::string retval;
 
   if (jni_env)
     {
-      const char *cstr = jni_env->GetStringUTFChars (s, 0);
+      const char *cstr = jni_env->GetStringUTFChars (s, nullptr);
       retval = cstr;
       jni_env->ReleaseStringUTFChars (s, cstr);
     }
 
   return retval;
 }
 
 static std::string
@@ -804,21 +804,21 @@ check_exception (JNIEnv *jni_env)
 
   return retval;
 }
 
 static jclass
 find_octave_class (JNIEnv *jni_env, const char *name)
 {
   static std::string class_loader;
-  static jclass uiClass = 0;
+  static jclass uiClass = nullptr;
 
   jclass jcls = jni_env->FindClass (name);
 
-  if (jcls == 0)
+  if (jcls == nullptr)
     {
       jni_env->ExceptionClear ();
 
       if (! uiClass)
         {
           if (class_loader.empty ())
             {
               jclass_ref syscls (jni_env,
@@ -906,40 +906,40 @@ compute_array_dimensions (JNIEnv *jni_en
       if (idx >= dv.ndims ())
         dv.resize (idx+1);
       dv(idx) = len;
       jcls = reinterpret_cast<jclass>
         (jni_env->CallObjectMethod (jcls, getComponentType_ID));
       jobj = len > 0
         ? reinterpret_cast<jobjectArray> (jni_env->GetObjectArrayElement (jobj,
                                                                           0))
-        : 0;
+        : nullptr;
       idx++;
     }
 
   octave_set_default_fpucw ();
 
   return dv;
 }
 
 static jobject
 make_java_index (JNIEnv *jni_env, const octave_value_list& idx)
 {
   jclass_ref ocls (jni_env, jni_env->FindClass ("[I"));
-  jobjectArray retval = jni_env->NewObjectArray (idx.length (), ocls, 0);
+  jobjectArray retval = jni_env->NewObjectArray (idx.length (), ocls, nullptr);
  // Here retval has the same length as idx
 
   // Fill in entries of idx into retval
   for (int i = 0; i < idx.length (); i++)
     try
       {
         idx_vector v = idx(i).index_vector ();
 
         jintArray_ref i_array (jni_env, jni_env->NewIntArray (v.length ()));
-        jint *buf = jni_env->GetIntArrayElements (i_array, 0);
+        jint *buf = jni_env->GetIntArrayElements (i_array, nullptr);
         // Here, buf points to the beginning of i_array
 
         // Copy v to buf
         for (int k = 0; k < v.length (); k++)
           buf[k] = v(k);
 
         // set retval[i]=i_array
         jni_env->ReleaseIntArrayElements (i_array, buf, 0);
@@ -1269,17 +1269,17 @@ box (JNIEnv *jni_env, void *jobj_arg, vo
           cls = find_octave_class (jni_env, "org/octave/Matrix");
 
           if (jni_env->IsInstanceOf (jobj, cls))
             {
               jmethodID mID = jni_env->GetMethodID (cls, "getDims", "()[I");
               jintArray_ref iv (jni_env,
                                 reinterpret_cast<jintArray>
                                 (jni_env->CallObjectMethod (jobj, mID)));
-              jint *iv_data = jni_env->GetIntArrayElements (jintArray (iv), 0);
+              jint *iv_data = jni_env->GetIntArrayElements (jintArray (iv), nullptr);
               dim_vector dims;
               dims.resize (jni_env->GetArrayLength (jintArray (iv)));
 
               for (int i = 0; i < dims.ndims (); i++)
                 dims(i) = iv_data[i];
 
               jni_env->ReleaseIntArrayElements (jintArray (iv), iv_data, 0);
               mID = jni_env->GetMethodID (cls, "getClassName",
@@ -1606,18 +1606,18 @@ unbox (JNIEnv *jni_env, const octave_val
         UNBOX_PRIMITIVE_SCALAR (int64_t, int64_scalar, "java/lang/Long", "(J)V");
       else if (val.is_uint64_type ())
         UNBOX_PRIMITIVE_SCALAR (uint64_t, uint64_scalar, "java/lang/Long", "(J)V");
 
 #undef UNBOX_PRIMITIVE_SCALAR
     }
   else if (val.isempty ())
     {
-      jobj = 0;
-      jcls = 0;
+      jobj = nullptr;
+      jcls = nullptr;
       //jcls = jni_env->FindClass ("java/lang/Object");
     }
   else if (! Vjava_matrix_autoconversion
            && ((val.is_real_matrix ()
                 && (val.rows () == 1 || val.columns () == 1))
                || val.is_range ()))
     {
       Matrix m = val.matrix_value ();
@@ -1629,17 +1629,17 @@ unbox (JNIEnv *jni_env, const octave_val
   else if (Vjava_matrix_autoconversion
            && (val.is_matrix_type () || val.is_range ())
            && val.isreal ())
     {
       jclass_ref mcls (jni_env, find_octave_class (jni_env,
                                                    "org/octave/Matrix"));
       dim_vector dims = val.dims ();
       jintArray_ref iv (jni_env, jni_env->NewIntArray (dims.ndims ()));
-      jint *iv_data = jni_env->GetIntArrayElements (jintArray (iv), 0);
+      jint *iv_data = jni_env->GetIntArrayElements (jintArray (iv), nullptr);
 
       for (int i = 0; i < dims.ndims (); i++)
         iv_data[i] = dims(i);
 
       jni_env->ReleaseIntArrayElements (jintArray (iv), iv_data, 0);
 
       if (val.is_double_type ())
         {
@@ -1714,20 +1714,20 @@ unbox (JNIEnv *jni_env, const octave_val
        jobjectArray_ref& jobjs, jobjectArray_ref& jclss)
 {
   bool found = true;
 
   jclass_ref ocls (jni_env, jni_env->FindClass ("java/lang/Object"));
   jclass_ref ccls (jni_env, jni_env->FindClass ("java/lang/Class"));
 
   if (! jobjs)
-    jobjs = jni_env->NewObjectArray (args.length (), ocls, 0);
+    jobjs = jni_env->NewObjectArray (args.length (), ocls, nullptr);
 
   if (! jclss)
-    jclss = jni_env->NewObjectArray (args.length (), ccls, 0);
+    jclss = jni_env->NewObjectArray (args.length (), ccls, nullptr);
 
   for (int i = 0; i < args.length (); i++)
     {
       jobject_ref jobj (jni_env);
       jclass_ref jcls (jni_env);
 
       found = unbox (jni_env, args(i), jobj, jcls);
       if (! found)
@@ -1814,17 +1814,17 @@ Java_org_octave_Octave_call (JNIEnv *env
   std::string fname = jstring_to_string (env, funcName);
 
   int nargout = env->GetArrayLength (argout);
   int nargin = env->GetArrayLength (argin);
 
   octave_value_list varargin, varargout;
 
   for (int i = 0; i < nargin; i++)
-    varargin(i) = box (env, env->GetObjectArrayElement (argin, i), 0);
+    varargin(i) = box (env, env->GetObjectArrayElement (argin, i), nullptr);
 
   varargout = octave::feval (fname, varargin, nargout);
 
   jobjectArray_ref out_objs (env, argout), out_clss (env);
   out_objs.detach ();
   return unbox (env, varargout, out_objs, out_clss);
 }
 
@@ -1844,17 +1844,17 @@ Java_org_octave_Octave_doInvoke (JNIEnv 
     {
       octave_value val = it->second;
       int len = env->GetArrayLength (args);
       octave_value_list oct_args;
 
       for (int i = 0; i < len; i++)
         {
           jobject_ref jobj (env, env->GetObjectArrayElement (args, i));
-          oct_args(i) = box (env, jobj, 0);
+          oct_args(i) = box (env, jobj, nullptr);
         }
 
       BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
       if (val.is_function_handle ())
         {
           octave_function *fcn = val.function_value ();
           octave::feval (fcn, oct_args);
@@ -1892,27 +1892,27 @@ Java_org_octave_Octave_needThreadedInvok
   return (get_current_thread_ID (env) != octave_thread_ID);
 }
 
 #endif
 
 // octave_java class definition
 
 octave_java::octave_java (void)
-  : octave_base_value (), java_object (0), java_class (0)
+  : octave_base_value (), java_object (nullptr), java_class (nullptr)
 {
 #if ! defined (HAVE_JAVA)
 
   err_disabled_feature ("Java Objects", "Java");
 
 #endif
 }
 
 octave_java::octave_java (const voidptr& jobj, void *jcls)
-  : octave_base_value (), java_object (0), java_class (0)
+  : octave_base_value (), java_object (nullptr), java_class (nullptr)
 {
 #if defined (HAVE_JAVA)
 
   init (jobj, jcls);
 
 #else
 
   octave_unused_parameter (jobj);
@@ -2384,17 +2384,17 @@ octave_java::do_javaObject (void *jni_en
           jclass_ref helperClass (jni_env, find_octave_class (jni_env, "org/octave/ClassHelper"));
           jmethodID mID = jni_env->GetStaticMethodID (helperClass, "invokeConstructor",
                                                       "(Ljava/lang/String;[Ljava/lang/Object;[Ljava/lang/Class;)Ljava/lang/Object;");
           jstring_ref clsName (jni_env, jni_env->NewStringUTF (name.c_str ()));
           jobject_ref resObj (jni_env, jni_env->CallStaticObjectMethod (helperClass, mID,
                                                                         jstring (clsName), jobjectArray (arg_objs), jobjectArray (arg_types)));
 
           if (resObj)
-            retval = octave_value (new octave_java (resObj, 0));
+            retval = octave_value (new octave_java (resObj, nullptr));
           else
             check_exception (jni_env);
         }
 
       octave_set_default_fpucw ();
     }
 
   return retval;
@@ -2746,18 +2746,18 @@ octave_java::release (void)
   if (current_env)
     {
       if (java_object)
         current_env->DeleteGlobalRef (TO_JOBJECT (java_object));
 
       if (java_class)
         current_env->DeleteGlobalRef (TO_JCLASS (java_class));
 
-      java_object = 0;
-      java_class = 0;
+      java_object = nullptr;
+      java_class = nullptr;
     }
 
 #else
 
   // This shouldn't happen because construction of octave_java
   // objects is supposed to be impossible if Java is not available.
 
   panic_impossible ();
@@ -3080,17 +3080,17 @@ Undocumented internal function.
 
   JNIEnv *current_env = thread_jni_env ();
 
   octave_value_list retval;
 
   if (args(0).isjava ())
     {
       octave_java *jobj = TO_JAVA (args(0));
-      retval = ovl (box_more (current_env, jobj->to_java (), 0));
+      retval = ovl (box_more (current_env, jobj->to_java (), nullptr));
     }
   else
     retval = ovl (args(0));
 
   return retval;
 
 #else
 
diff --git a/libinterp/octave-value/ov-java.h b/libinterp/octave-value/ov-java.h
--- a/libinterp/octave-value/ov-java.h
+++ b/libinterp/octave-value/ov-java.h
@@ -34,17 +34,17 @@ class OCTINTERP_API octave_java : public
 {
 public:
 
   octave_java (void);
 
   octave_java (const voidptr& obj, void *cls = nullptr);
 
   octave_java (const octave_java& jobj)
-    : octave_base_value (jobj), java_object (0), java_class (0)
+    : octave_base_value (jobj), java_object (nullptr), java_class (nullptr)
   {
     init (jobj.java_object, jobj.java_class);
   }
 
   ~octave_java (void) { release (); }
 
   void * to_java (void) const { return java_object; }
   void * to_class (void) const { return java_class; }
diff --git a/libinterp/octave-value/ov-mex-fcn.cc b/libinterp/octave-value/ov-mex-fcn.cc
--- a/libinterp/octave-value/ov-mex-fcn.cc
+++ b/libinterp/octave-value/ov-mex-fcn.cc
@@ -41,17 +41,17 @@ along with Octave; see the file COPYING.
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_mex_function,
                                      "mex function", "mex function");
 
 octave_mex_function::octave_mex_function
   (void *fptr, bool fmex, const octave::dynamic_library& shl,
    const std::string& nm)
-  : octave_function (nm), m_mex_fcn_ptr (fptr), m_exit_fcn_ptr (0),
+  : octave_function (nm), m_mex_fcn_ptr (fptr), m_exit_fcn_ptr (nullptr),
     m_is_fmex (fmex), m_sh_lib (shl)
 {
   mark_fcn_file_up_to_date (time_parsed ());
 
   std::string file_name = fcn_file_name ();
 
   std::string oct_file_dir = octave::config::oct_file_dir ();
   m_is_system_fcn_file
diff --git a/libinterp/octave-value/ov-oncleanup.cc b/libinterp/octave-value/ov-oncleanup.cc
--- a/libinterp/octave-value/ov-oncleanup.cc
+++ b/libinterp/octave-value/ov-oncleanup.cc
@@ -42,21 +42,21 @@ octave_oncleanup::octave_oncleanup (cons
     {
       octave_function *fptr = f.function_value (true);
       if (! fptr)
         error ("onCleanup: no default dispatch for function handle");
 
       octave_user_function *uptr
         = dynamic_cast<octave_user_function *> (fptr);
 
-      if (uptr != 0)
+      if (uptr != nullptr)
         {
           octave::tree_parameter_list *pl = uptr->parameter_list ();
 
-          if (pl != 0 && pl->length () > 0)
+          if (pl != nullptr && pl->length () > 0)
             warning ("onCleanup: cleanup action takes parameters");
         }
     }
   else
     {
       fcn = octave_value ();
       error ("onCleanup: argument must be a function handle");
     }
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -624,17 +624,17 @@ octave_range::save_hdf5 (octave_hdf5_id 
   bool retval = false;
 
 #if defined (HAVE_HDF5)
 
   hsize_t dimens[3];
   hid_t space_hid, type_hid, data_hid;
   space_hid = type_hid = data_hid = -1;
 
-  space_hid = H5Screate_simple (0, dimens, 0);
+  space_hid = H5Screate_simple (0, dimens, nullptr);
   if (space_hid < 0) return false;
 
   type_hid = hdf5_make_range_type (H5T_NATIVE_DOUBLE);
   if (type_hid < 0)
     {
       H5Sclose (space_hid);
       return false;
     }
diff --git a/libinterp/octave-value/ov-range.h b/libinterp/octave-value/ov-range.h
--- a/libinterp/octave-value/ov-range.h
+++ b/libinterp/octave-value/ov-range.h
@@ -66,17 +66,17 @@ public:
     : octave_base_value (), range (r), idx_cache ()
   {
     if (range.numel () < 0 && range.numel () != -2)
       error ("invalid range");
   }
 
   octave_range (const octave_range& r)
     : octave_base_value (), range (r.range),
-      idx_cache (r.idx_cache ? new idx_vector (*r.idx_cache) : 0)
+      idx_cache (r.idx_cache ? new idx_vector (*r.idx_cache) : nullptr)
   { }
 
   octave_range (const Range& r, const idx_vector& cache)
     : octave_base_value (), range (r), idx_cache ()
   {
     set_idx_cache (cache);
   }
 
@@ -303,23 +303,23 @@ public:
 
 private:
 
   Range range;
 
   idx_vector set_idx_cache (const idx_vector& idx) const
   {
     delete idx_cache;
-    idx_cache = (idx ? new idx_vector (idx) : 0);
+    idx_cache = (idx ? new idx_vector (idx) : nullptr);
     return idx;
   }
 
   void clear_cached_info (void) const
   {
-    delete idx_cache; idx_cache = 0;
+    delete idx_cache; idx_cache = nullptr;
   }
 
   mutable idx_vector *idx_cache;
 
   // No assignment.
 
   octave_range& operator = (const octave_range&);
 
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -696,17 +696,17 @@ octave_matrix::save_hdf5 (octave_hdf5_id
   NDArray m = array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv(rank-i-1);
 
-  space_hid = H5Screate_simple (rank, hdims, 0);
+  space_hid = H5Screate_simple (rank, hdims, nullptr);
 
   if (space_hid < 0) return false;
 
   hid_t save_type_hid = H5T_NATIVE_DOUBLE;
 
   if (save_as_floats)
     {
       if (m.too_large_for_float ())
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -405,17 +405,17 @@ octave_sparse_matrix::save_hdf5 (octave_
     return false;
 
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
   SparseMatrix m = sparse_matrix_value ();
   octave_idx_type tmp;
   hsize_t hdims[2];
 
-  space_hid = H5Screate_simple (0, hdims, 0);
+  space_hid = H5Screate_simple (0, hdims, nullptr);
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 #if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "nr", H5T_NATIVE_IDX, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
@@ -490,17 +490,17 @@ octave_sparse_matrix::save_hdf5 (octave_
       return false;
     }
 
   H5Sclose (space_hid);
 
   hdims[0] = m.cols () + 1;
   hdims[1] = 1;
 
-  space_hid = H5Screate_simple (2, hdims, 0);
+  space_hid = H5Screate_simple (2, hdims, nullptr);
 
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 
 #if defined (HAVE_HDF5_18)
@@ -528,17 +528,17 @@ octave_sparse_matrix::save_hdf5 (octave_
       return false;
     }
 
   H5Sclose (space_hid);
 
   hdims[0] = m.nnz ();
   hdims[1] = 1;
 
-  space_hid = H5Screate_simple (2, hdims, 0);
+  space_hid = H5Screate_simple (2, hdims, nullptr);
 
   if (space_hid < 0)
     {
       H5Gclose (group_hid);
       return false;
     }
 #if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (group_hid, "ridx", H5T_NATIVE_IDX, space_hid,
diff --git a/libinterp/octave-value/ov-scalar.cc b/libinterp/octave-value/ov-scalar.cc
--- a/libinterp/octave-value/ov-scalar.cc
+++ b/libinterp/octave-value/ov-scalar.cc
@@ -269,17 +269,17 @@ octave_scalar::save_hdf5 (octave_hdf5_id
   bool retval = false;
 
 #if defined (HAVE_HDF5)
 
   hsize_t dimens[3];
   hid_t space_hid, data_hid;
   space_hid = data_hid = -1;
 
-  space_hid = H5Screate_simple (0, dimens, 0);
+  space_hid = H5Screate_simple (0, dimens, nullptr);
   if (space_hid < 0) return false;
 
 #if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_DOUBLE, space_hid,
                         octave_H5P_DEFAULT);
diff --git a/libinterp/octave-value/ov-str-mat.cc b/libinterp/octave-value/ov-str-mat.cc
--- a/libinterp/octave-value/ov-str-mat.cc
+++ b/libinterp/octave-value/ov-str-mat.cc
@@ -543,17 +543,17 @@ octave_char_matrix_str::save_hdf5 (octav
   charNDArray m = char_array_value ();
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
 
   // Octave uses column-major, while HDF5 uses row-major ordering
   for (int i = 0; i < rank; i++)
     hdims[i] = dv(rank-i-1);
 
-  space_hid = H5Screate_simple (rank, hdims, 0);
+  space_hid = H5Screate_simple (rank, hdims, nullptr);
   if (space_hid < 0)
     return false;
 #if defined (HAVE_HDF5_18)
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_CHAR, space_hid,
                         octave_H5P_DEFAULT, octave_H5P_DEFAULT, octave_H5P_DEFAULT);
 #else
   data_hid = H5Dcreate (loc_id, name, H5T_NATIVE_CHAR, space_hid,
                         octave_H5P_DEFAULT);
diff --git a/libinterp/octave-value/ov-typeinfo.cc b/libinterp/octave-value/ov-typeinfo.cc
--- a/libinterp/octave-value/ov-typeinfo.cc
+++ b/libinterp/octave-value/ov-typeinfo.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 #include "defun.h"
 #include "error.h"
 #include "ov-typeinfo.h"
 
 const int
 octave_value_typeinfo::init_tab_sz (16);
 
 octave_value_typeinfo *
-octave_value_typeinfo::instance (0);
+octave_value_typeinfo::instance (nullptr);
 
 bool
 octave_value_typeinfo::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
     {
@@ -186,38 +186,38 @@ octave_value_typeinfo::do_register_type 
   if (i == len)
     {
       len *= 2;
 
       types.resize (dim_vector (len, 1), "");
 
       vals.resize (dim_vector (len, 1), octave_value ());
 
-      unary_ops.resize (dim_vector (octave_value::num_unary_ops, len), 0);
+      unary_ops.resize (dim_vector (octave_value::num_unary_ops, len), nullptr);
 
       non_const_unary_ops.resize
-        (dim_vector (octave_value::num_unary_ops, len), 0);
+        (dim_vector (octave_value::num_unary_ops, len), nullptr);
 
       binary_ops.resize
-        (dim_vector (octave_value::num_binary_ops, len, len), 0);
+        (dim_vector (octave_value::num_binary_ops, len, len), nullptr);
 
       compound_binary_ops.resize
-        (dim_vector (octave_value::num_compound_binary_ops, len, len), 0);
+        (dim_vector (octave_value::num_compound_binary_ops, len, len), nullptr);
 
-      cat_ops.resize (dim_vector (len, len), 0);
+      cat_ops.resize (dim_vector (len, len), nullptr);
 
       assign_ops.resize
-        (dim_vector (octave_value::num_assign_ops, len, len), 0);
+        (dim_vector (octave_value::num_assign_ops, len, len), nullptr);
 
       assignany_ops.resize
-        (dim_vector (octave_value::num_assign_ops, len), 0);
+        (dim_vector (octave_value::num_assign_ops, len), nullptr);
 
       pref_assign_conv.resize (dim_vector (len, len), -1);
 
-      widening_ops.resize (dim_vector (len, len), 0);
+      widening_ops.resize (dim_vector (len, len), nullptr);
     }
 
   types (i) = t_name;
 
   vals (i) = val;
 
   num_types++;
 
@@ -710,17 +710,17 @@ octave_value_typeinfo::unary_ops_map (vo
 
   dim_vector tab_dims (1, len);
 
   for (int j = 0; j < octave_value::num_unary_ops; j++)
     {
       boolNDArray tab (tab_dims);
 
       for (int i = 0; i < len; i++)
-        tab.xelem (i) = (unary_ops(j,i) != 0);
+        tab.xelem (i) = (unary_ops(j,i) != nullptr);
 
       octave_value::unary_op op_id = static_cast<octave_value::unary_op> (j);
 
       retval.setfield (octave_value::unary_op_as_string (op_id), tab);
     }
 
   return retval;
 }
@@ -735,17 +735,17 @@ octave_value_typeinfo::non_const_unary_o
 
   dim_vector tab_dims (1, len);
 
   for (int j = 0; j < octave_value::num_unary_ops; j++)
     {
       boolNDArray tab (tab_dims);
 
       for (int i = 0; i < len; i++)
-        tab.xelem (i) = (non_const_unary_ops(j,i) != 0);
+        tab.xelem (i) = (non_const_unary_ops(j,i) != nullptr);
 
       octave_value::unary_op op_id = static_cast<octave_value::unary_op> (j);
 
       retval.setfield (octave_value::unary_op_as_string (op_id), tab);
     }
 
   return retval;
 }
@@ -760,17 +760,17 @@ octave_value_typeinfo::binary_ops_map (v
   dim_vector tab_dims (len, len);
 
   for (int k = 0; k < octave_value::num_binary_ops; k++)
     {
       boolNDArray tab (tab_dims);
 
       for (int j = 0; j < len; j++)
         for (int i = 0; i < len; i++)
-          tab.xelem (j,i) = (binary_ops(k,j,i) != 0);
+          tab.xelem (j,i) = (binary_ops(k,j,i) != nullptr);
 
       octave_value::binary_op op_id = static_cast<octave_value::binary_op> (k);
 
       retval.setfield (octave_value::binary_op_as_string (op_id), tab);
     }
 
   return retval;
 }
@@ -786,17 +786,17 @@ octave_value_typeinfo::compound_binary_o
   dim_vector tab_dims (len, len);
 
   for (int k = 0; k < octave_value::num_compound_binary_ops; k++)
     {
       boolNDArray tab (tab_dims);
 
       for (int j = 0; j < len; j++)
         for (int i = 0; i < len; i++)
-          tab.xelem (j,i) = (compound_binary_ops(k,j,i) != 0);
+          tab.xelem (j,i) = (compound_binary_ops(k,j,i) != nullptr);
 
       octave_value::compound_binary_op op_id
         = static_cast<octave_value::compound_binary_op> (k);
 
       retval.setfield (octave_value::binary_op_fcn_name (op_id), tab);
     }
 
   return retval;
@@ -812,17 +812,17 @@ octave_value_typeinfo::assign_ops_map (v
   dim_vector tab_dims (len, len);
 
   for (int k = 0; k < octave_value::num_assign_ops; k++)
     {
       boolNDArray tab (tab_dims);
 
       for (int j = 0; j < len; j++)
         for (int i = 0; i < len; i++)
-          tab.xelem (j,i) = (assign_ops(k,j,i) != 0);
+          tab.xelem (j,i) = (assign_ops(k,j,i) != nullptr);
 
       octave_value::assign_op op_id = static_cast<octave_value::assign_op> (k);
 
       retval.setfield (octave_value::assign_op_as_string (op_id), tab);
     }
 
   return retval;
 }
@@ -836,17 +836,17 @@ octave_value_typeinfo::assignany_ops_map
 
   dim_vector tab_dims (1, len);
 
   for (int j = 0; j < octave_value::num_assign_ops; j++)
     {
       boolNDArray tab (tab_dims);
 
       for (int i = 0; i < len; i++)
-        tab.xelem (i) = (assignany_ops(j,i) != 0);
+        tab.xelem (i) = (assignany_ops(j,i) != nullptr);
 
       octave_value::assign_op op_id = static_cast<octave_value::assign_op> (j);
 
       retval.setfield (octave_value::assign_op_as_string (op_id), tab);
     }
 
   return retval;
 }
diff --git a/libinterp/octave-value/ov-typeinfo.h b/libinterp/octave-value/ov-typeinfo.h
--- a/libinterp/octave-value/ov-typeinfo.h
+++ b/libinterp/octave-value/ov-typeinfo.h
@@ -199,33 +199,33 @@ protected:
       binary_class_ops (dim_vector (octave_value::num_binary_ops, 1), 0),
       binary_ops (dim_vector (octave_value::num_binary_ops, init_tab_sz, init_tab_sz), 0),
       compound_binary_class_ops (dim_vector (octave_value::num_compound_binary_ops, 1), 0),
       compound_binary_ops (dim_vector (octave_value::num_compound_binary_ops, init_tab_sz, init_tab_sz), 0),
       cat_ops (dim_vector (init_tab_sz, init_tab_sz), 0),
       assign_ops (dim_vector (octave_value::num_assign_ops, init_tab_sz, init_tab_sz), 0),
       assignany_ops (dim_vector (octave_value::num_assign_ops, init_tab_sz), 0),
       pref_assign_conv (dim_vector (init_tab_sz, init_tab_sz), -1),
-      widening_ops (dim_vector (init_tab_sz, init_tab_sz), 0)  { }
+      widening_ops (dim_vector (init_tab_sz, init_tab_sz), nullptr)  { }
 
   // No copying!
 
   octave_value_typeinfo (const octave_value_typeinfo&) = delete;
 
   octave_value_typeinfo& operator = (const octave_value_typeinfo&) = delete;
 
   ~octave_value_typeinfo (void) = default;
 
 private:
 
   static const int init_tab_sz;
 
   static octave_value_typeinfo *instance;
 
-  static void cleanup_instance (void) { delete instance; instance = 0; }
+  static void cleanup_instance (void) { delete instance; instance = nullptr; }
 
   int num_types;
 
   Array<std::string> types;
 
   Array<octave_value> vals;
 
   Array<void *> unary_class_ops;
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -120,17 +120,17 @@ octave_user_code::subfunctions (void) co
 
 // User defined scripts.
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_user_script,
                                      "user-defined script",
                                      "user-defined script");
 
 octave_user_script::octave_user_script (void)
-  : octave_user_code (), cmd_list (0), file_name (),
+  : octave_user_code (), cmd_list (nullptr), file_name (),
     t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     call_depth (-1)
 { }
 
 octave_user_script::octave_user_script (const std::string& fnm,
                                         const std::string& nm,
                                         octave::tree_statement_list *cmds,
@@ -142,17 +142,17 @@ octave_user_script::octave_user_script (
 {
   if (cmd_list)
     cmd_list->mark_as_script_body ();
 }
 
 octave_user_script::octave_user_script (const std::string& fnm,
                                         const std::string& nm,
                                         const std::string& ds)
-  : octave_user_code (nm, ds), cmd_list (0), file_name (fnm),
+  : octave_user_code (nm, ds), cmd_list (nullptr), file_name (fnm),
     t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     call_depth (-1)
 { }
 
 octave_user_script::~octave_user_script (void)
 {
   if (cmd_list)
@@ -244,17 +244,17 @@ octave_user_function::octave_user_functi
     location_line (0), location_column (0),
     parent_name (), t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     system_fcn_file (false), call_depth (-1),
     num_named_args (param_list ? param_list->length () : 0),
     subfunction (false), inline_function (false),
     anonymous_function (false), nested_function (false),
     class_constructor (none), class_method (false),
-    parent_scope (0)
+    parent_scope (nullptr)
 #if defined (HAVE_LLVM)
     , jit_info (0)
 #endif
 {
   if (cmd_list)
     cmd_list->mark_as_function_body ();
 
   if (m_scope)
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -58,17 +58,17 @@ class jit_function_info;
 class
 octave_user_code : public octave_function
 {
 protected:
 
   octave_user_code (const std::string& nm,
                     const std::string& ds = "")
     : octave_function (nm, ds), curr_unwind_protect_frame (0),
-      m_file_info (0)
+      m_file_info (nullptr)
   { }
 
 public:
 
   octave_user_code (void)
     : octave_function () { }
 
   // No copying!
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -1516,17 +1516,17 @@ octave_value::assign (assign_op op, cons
 octave_value&
 octave_value::assign (assign_op op, const octave_value& rhs)
 {
   if (op == op_asn_eq)
     // Regularize a null matrix if stored into a variable.
     operator = (rhs.storable_value ());
   else if (is_defined ())
     {
-      octave_value_typeinfo::assign_op_fcn f = 0;
+      octave_value_typeinfo::assign_op_fcn f = nullptr;
 
       // Only attempt to operate in-place if this variable is unshared.
       if (rep->count == 1)
         {
           int tthis = this->type_id ();
           int trhs = rhs.type_id ();
 
           f = octave_value_typeinfo::lookup_assign_op (op, tthis, trhs);
@@ -2187,22 +2187,22 @@ do_binary_op (octave_value::binary_op op
           octave_value tv2;
           octave_base_value::type_conv_info cf2 =
             v2.numeric_conversion_function ();
 
           // Try biased (one-sided) conversions first.
           if (cf2.type_id () >= 0
               && octave_value_typeinfo::lookup_binary_op (op, t1,
                                                           cf2.type_id ()))
-            cf1 = 0;
+            cf1 = nullptr;
           else if (cf1.type_id () >= 0
                    && octave_value_typeinfo::lookup_binary_op (op,
                                                                cf1.type_id (),
                                                                t2))
-            cf2 = 0;
+            cf2 = nullptr;
 
           if (cf1)
             {
               octave_base_value *tmp = cf1 (*v1.rep);
 
               if (! tmp)
                 err_binary_op_conv (octave_value::binary_op_as_string (op));
 
@@ -2235,22 +2235,22 @@ do_binary_op (octave_value::binary_op op
               cf1 = tv1.numeric_demotion_function ();
 
               cf2 = tv2.numeric_demotion_function ();
 
               // Try biased (one-sided) conversions first.
               if (cf2.type_id () >= 0
                   && octave_value_typeinfo::lookup_binary_op (op, t1,
                                                               cf2.type_id ()))
-                cf1 = 0;
+                cf1 = nullptr;
               else if (cf1.type_id () >= 0
                        && octave_value_typeinfo::lookup_binary_op (op,
                                                                    cf1.type_id (),
                                                                    t2))
-                cf2 = 0;
+                cf2 = nullptr;
 
               if (cf1)
                 {
                   octave_base_value *tmp = cf1 (*tv1.rep);
 
                   if (! tmp)
                     err_binary_op_conv (octave_value::binary_op_as_string (op));
 
@@ -2410,20 +2410,20 @@ do_cat_op (const octave_value& v1, const
       octave_base_value::type_conv_info cf1 = v1.numeric_conversion_function ();
 
       octave_value tv2;
       octave_base_value::type_conv_info cf2 = v2.numeric_conversion_function ();
 
       // Try biased (one-sided) conversions first.
       if (cf2.type_id () >= 0
           && octave_value_typeinfo::lookup_cat_op (t1, cf2.type_id ()))
-        cf1 = 0;
+        cf1 = nullptr;
       else if (cf1.type_id () >= 0
                && octave_value_typeinfo::lookup_cat_op (cf1.type_id (), t2))
-        cf2 = 0;
+        cf2 = nullptr;
 
       if (cf1)
         {
           octave_base_value *tmp = cf1 (*v1.rep);
 
           if (! tmp)
             err_cat_op_conv ();
 
@@ -2707,17 +2707,17 @@ octave_value::do_non_const_unary_op (una
             }
         }
     }
   else
     {
       // Non-genuine.
       int t = type_id ();
 
-      octave_value_typeinfo::non_const_unary_op_fcn f = 0;
+      octave_value_typeinfo::non_const_unary_op_fcn f = nullptr;
 
       // Only attempt to operate in-place if this variable is unshared.
       if (rep->count == 1)
         f = octave_value_typeinfo::lookup_non_const_unary_op (op, t);
 
       if (f)
         f (*rep);
       else
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -278,41 +278,41 @@ namespace octave
 
         for (octave_idx_type i = 0; i < nargs; i++)
           m_argv[i] = args[i+1];
       }
   }
 
   void application::interactive (bool arg)
   {
-    interpreter *interp = (instance ? instance->m_interpreter : 0);
+    interpreter *interp = (instance ? instance->m_interpreter : nullptr);
 
     if (interp)
       interp->interactive (arg);
   }
 
   bool application::forced_interactive (void)
   {
     return instance ? instance->m_options.forced_interactive () : false;
   }
 
   bool application::interactive (void)
   {
-    interpreter *interp = (instance ? instance->m_interpreter : 0);
+    interpreter *interp = (instance ? instance->m_interpreter : nullptr);
 
     return interp ? interp->interactive () : false;
   }
 
   application::~application (void)
   {
     // Delete interpreter if it still exists.
 
     delete m_interpreter;
 
-    instance = 0;
+    instance = nullptr;
   }
 
   bool application::interpreter_initialized (void)
   {
     return m_interpreter ? m_interpreter->initialized () : false;
   }
 
   interpreter& application::create_interpreter (void)
@@ -332,17 +332,17 @@ namespace octave
   {
     return m_interpreter ? m_interpreter->execute () : -1;
   }
 
   void application::delete_interpreter (void)
   {
     delete m_interpreter;
 
-    m_interpreter = 0;
+    m_interpreter = nullptr;
   }
 
   void application::init (void)
   {
     if (instance)
       throw std::runtime_error
         ("only one Octave application object may be active");
 
diff --git a/libinterp/parse-tree/bp-table.cc b/libinterp/parse-tree/bp-table.cc
--- a/libinterp/parse-tree/bp-table.cc
+++ b/libinterp/parse-tree/bp-table.cc
@@ -599,17 +599,17 @@ find_fcn_by_line (octave_user_code *main
         retval = next_fcn;
     }
   else  // main_fcn is a script.
     {
       if (! retval)
         retval = main_fcn;
     }
 
-  if (end_line != 0 && earliest_end < *end_line)
+  if (end_line != nullptr && earliest_end < *end_line)
     *end_line = earliest_end;
 
   return retval;
 }
 
 // Given file name fname, find the subfunction at line and create
 // a breakpoint there.  Put the system into debug_mode.
 bp_table::intmap
diff --git a/libinterp/parse-tree/bp-table.h b/libinterp/parse-tree/bp-table.h
--- a/libinterp/parse-tree/bp-table.h
+++ b/libinterp/parse-tree/bp-table.h
@@ -166,17 +166,17 @@ private:
   // *if* Vdebug_on_error / Vdebug_on_caught / Vdebug_on_warning is set.
   // Empty means stop on any error / caught error / warning.
   static std::set<std::string> errors_that_stop;
   static std::set<std::string> caught_that_stop;
   static std::set<std::string> warnings_that_stop;
 
   static bp_table *instance;
 
-  static void cleanup_instance (void) { delete instance; instance = 0; }
+  static void cleanup_instance (void) { delete instance; instance = nullptr; }
 
   bool do_add_breakpoint_1 (octave_user_code *fcn, const std::string& fname,
                             const intmap& line, const std::string& condition,
                             intmap& retval);
 
   intmap do_add_breakpoint (const std::string& fname, const intmap& lines,
                             const std::string& condition);
 
diff --git a/libinterp/parse-tree/jit-ir.h b/libinterp/parse-tree/jit-ir.h
--- a/libinterp/parse-tree/jit-ir.h
+++ b/libinterp/parse-tree/jit-ir.h
@@ -216,17 +216,17 @@ public:
 
   // replace all uses with
   virtual void replace_with (jit_value *value);
 
   jit_type * type (void) const { return ty; }
 
   llvm::Type * type_llvm (void) const
   {
-    return ty ? ty->to_llvm () : 0;
+    return ty ? ty->to_llvm () : nullptr;
   }
 
   const std::string& type_name (void) const
   {
     return ty->name ();
   }
 
   void stash_type (jit_type *new_ty) { ty = new_ty; }
@@ -1390,23 +1390,23 @@ jit_return : public jit_instruction
 {
 public:
   jit_return (void) { }
 
   jit_return (jit_value *retval) : jit_instruction (retval) { }
 
   jit_value * result (void) const
   {
-    return argument_count () ? argument (0) : 0;
+    return argument_count () ? argument (0) : nullptr;
   }
 
   jit_type * result_type (void) const
   {
     jit_value *res = result ();
-    return res ? res->type () : 0;
+    return res ? res->type () : nullptr;
   }
 
   virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
   {
     print_indent (os, indent) << "return";
 
     if (result ())
       os << " " << *result ();
diff --git a/libinterp/parse-tree/jit-typeinfo.cc b/libinterp/parse-tree/jit-typeinfo.cc
--- a/libinterp/parse-tree/jit-typeinfo.cc
+++ b/libinterp/parse-tree/jit-typeinfo.cc
@@ -514,17 +514,17 @@ jit_type::jit_type (const std::string& a
 
   for (size_t i = 0; i < jit_convention::length; ++i)
     mpacked_type[i] = llvm_type;
 }
 
 llvm::Type *
 jit_type::to_llvm_arg (void) const
 {
-  return llvm_type ? llvm_type->getPointerTo () : 0;
+  return llvm_type ? llvm_type->getPointerTo () : nullptr;
 }
 
 // -------------------- jit_function --------------------
 jit_function::jit_function () : module (0), llvm_function (0), mresult (0),
                                 call_conv (jit_convention::length),
                                 mcan_error (false)
 { }
 
diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -209,43 +209,43 @@ namespace octave
             delete buffer.back ();
             buffer.pop_back ();
           }
       }
 
       // Direct access.
       token * at (size_t n)
       {
-        return empty () ? 0 : buffer.at (n);
+        return empty () ? nullptr : buffer.at (n);
       }
 
       const token * at (size_t n) const
       {
-        return empty () ? 0 : buffer.at (n);
+        return empty () ? nullptr : buffer.at (n);
       }
 
       // Most recently pushed.
       token * front (void)
       {
-        return empty () ? 0 : buffer.front ();
+        return empty () ? nullptr : buffer.front ();
       }
 
       const token * front (void) const
       {
-        return empty () ? 0 : buffer.front ();
+        return empty () ? nullptr : buffer.front ();
       }
 
       token * back (void)
       {
-        return empty () ? 0 : buffer.back ();
+        return empty () ? nullptr : buffer.back ();
       }
 
       const token * back (void) const
       {
-        return empty () ? 0 : buffer.back ();
+        return empty () ? nullptr : buffer.back ();
       }
 
       // Number of elements currently in the buffer.
       size_t size (void) const { return buffer.size (); }
 
       bool empty (void) const { return buffer.empty (); }
 
       void clear (void)
@@ -488,17 +488,17 @@ namespace octave
 
     // Handle buffering of input for lexer.
 
    class input_buffer
     {
     public:
 
       input_buffer (void)
-        : buffer (), pos (0), chars_left (0), eof (false)
+        : buffer (), pos (nullptr), chars_left (0), eof (false)
       { }
 
       void fill (const std::string& input, bool eof_arg);
 
       // Copy at most max_size characters to buf.
       int copy_chunk (char *buf, size_t max_size);
 
       bool empty (void) const { return chars_left == 0; }
@@ -515,17 +515,17 @@ namespace octave
 
     // Collect comment text.
 
     class
     comment_buffer
     {
     public:
 
-      comment_buffer (void) : m_comment_list (0) { }
+      comment_buffer (void) : m_comment_list (nullptr) { }
 
       ~comment_buffer (void) { delete m_comment_list; }
 
       void append (const std::string& s, comment_elt::comment_type t)
       {
         if (! m_comment_list)
           m_comment_list = new comment_list ();
 
@@ -533,35 +533,35 @@ namespace octave
       }
 
       // Caller is expected to delete the returned value.
 
       comment_list * get_comment (void)
       {
         comment_list *retval = m_comment_list;
 
-        m_comment_list = 0;
+        m_comment_list = nullptr;
 
         return retval;
       }
 
       void reset (void)
       {
         delete m_comment_list;
 
-        m_comment_list = 0;
+        m_comment_list = nullptr;
       }
 
     private:
 
       comment_list *m_comment_list;
     };
 
     base_lexer (interpreter *interp = nullptr)
-      : lexical_feedback (), scanner (0), input_buf (), comment_buf (),
+      : lexical_feedback (), scanner (nullptr), input_buf (), comment_buf (),
         m_interpreter (interp)
     {
       init ();
     }
 
     // No copying!
 
     base_lexer (const base_lexer&) = delete;
diff --git a/libinterp/parse-tree/profiler.cc b/libinterp/parse-tree/profiler.cc
--- a/libinterp/parse-tree/profiler.cc
+++ b/libinterp/parse-tree/profiler.cc
@@ -170,18 +170,18 @@ namespace octave
     retval.assign ("NumCalls", rv_calls);
     retval.assign ("Children", rv_children);
 
     return retval;
   }
 
   profiler::profiler (void)
     : known_functions (), fcn_index (),
-      enabled (false), call_tree (new tree_node (0, 0)),
-      active_fcn (0), last_time (-1.0)
+      enabled (false), call_tree (new tree_node (nullptr, 0)),
+      active_fcn (nullptr), last_time (-1.0)
   { }
 
   profiler::~profiler (void)
   {
     delete call_tree;
   }
 
   void
@@ -258,18 +258,18 @@ namespace octave
       error ("Can't reset active profiler.");
 
     known_functions.clear ();
     fcn_index.clear ();
 
     if (call_tree)
       {
         delete call_tree;
-        call_tree = new tree_node (0, 0);
-        active_fcn = 0;
+        call_tree = new tree_node (nullptr, 0);
+        active_fcn = nullptr;
       }
 
     last_time = -1.0;
   }
 
   octave_value
   profiler::get_flat (void) const
   {
@@ -316,17 +316,17 @@ namespace octave
         static const char *fn[] =
           {
             "FunctionName",
             "TotalTime",
             "NumCalls",
             "IsRecursive",
             "Parents",
             "Children",
-            0
+            nullptr
           };
 
         static octave_map m (dim_vector (0, 1), string_vector (fn));
 
         retval = m;
       }
 
     return retval;
@@ -342,17 +342,17 @@ namespace octave
     else
       {
         static const char *fn[] =
           {
             "Index",
             "SelfTime",
             "NumCalls",
             "Children",
-            0
+            nullptr
           };
 
         static octave_map m (dim_vector (0, 1), string_vector (fn));
 
         retval = m;
       }
 
     return retval;
diff --git a/libinterp/parse-tree/pt-arg-list.cc b/libinterp/parse-tree/pt-arg-list.cc
--- a/libinterp/parse-tree/pt-arg-list.cc
+++ b/libinterp/parse-tree/pt-arg-list.cc
@@ -306,13 +306,13 @@ namespace octave
   tree_argument_list::dup (symbol_table::scope& scope) const
   {
     tree_argument_list *new_list = new tree_argument_list ();
 
     new_list->list_includes_magic_end = list_includes_magic_end;
     new_list->simple_assign_lhs = simple_assign_lhs;
 
     for (const tree_expression *elt : *this)
-      new_list->append (elt ? elt->dup (scope) : 0);
+      new_list->append (elt ? elt->dup (scope) : nullptr);
 
     return new_list;
   }
 }
diff --git a/libinterp/parse-tree/pt-array-list.cc b/libinterp/parse-tree/pt-array-list.cc
--- a/libinterp/parse-tree/pt-array-list.cc
+++ b/libinterp/parse-tree/pt-array-list.cc
@@ -77,26 +77,26 @@ namespace octave
     tree_expression::copy_base (array_list);
   }
 
   void
   tree_array_list::copy_base (const tree_array_list& array_list,
                               symbol_table::scope& scope)
   {
     for (const tree_argument_list *elt : array_list)
-      append (elt ? elt->dup (scope) : 0);
+      append (elt ? elt->dup (scope) : nullptr);
 
     copy_base (*this);
   }
 
   tree_expression *
   tree_array_list::dup (symbol_table::scope&) const
   {
     panic_impossible ();
-    return 0;
+    return nullptr;
   }
 
   void
   tree_array_list::accept (tree_walker&)
   {
     panic_impossible ();
   }
 }
diff --git a/libinterp/parse-tree/pt-assign.cc b/libinterp/parse-tree/pt-assign.cc
--- a/libinterp/parse-tree/pt-assign.cc
+++ b/libinterp/parse-tree/pt-assign.cc
@@ -55,18 +55,18 @@ namespace octave
   {
     return octave_value::assign_op_as_string (etype);
   }
 
   tree_expression *
   tree_simple_assignment::dup (symbol_table::scope& scope) const
   {
     tree_simple_assignment *new_sa
-      = new tree_simple_assignment (lhs ? lhs->dup (scope) : 0,
-                                    rhs ? rhs->dup (scope) : 0,
+      = new tree_simple_assignment (lhs ? lhs->dup (scope) : nullptr,
+                                    rhs ? rhs->dup (scope) : nullptr,
                                     preserve, etype);
 
     new_sa->copy_base (*this);
 
     return new_sa;
   }
 
   // Multi-valued assignment expressions.
@@ -90,17 +90,17 @@ namespace octave
   {
     return octave_value::assign_op_as_string (op_type ());
   }
 
   tree_expression *
   tree_multi_assignment::dup (symbol_table::scope&) const
   {
     panic_impossible ();
-    return 0;
+    return nullptr;
   }
 }
 
 /*
 %!function varargout = f ()
 %!  varargout{1} = nargout;
 %!endfunction
 %!
diff --git a/libinterp/parse-tree/pt-assign.h b/libinterp/parse-tree/pt-assign.h
--- a/libinterp/parse-tree/pt-assign.h
+++ b/libinterp/parse-tree/pt-assign.h
@@ -44,18 +44,18 @@ namespace octave
   // Simple assignment expressions.
 
   class tree_simple_assignment : public tree_expression
   {
   public:
 
     tree_simple_assignment (bool plhs = false, int l = -1, int c = -1,
                             octave_value::assign_op t = octave_value::op_asn_eq)
-      : tree_expression (l, c), lhs (0), rhs (0), preserve (plhs), ans_ass (),
-        etype (t) { }
+      : tree_expression (l, c), lhs (nullptr), rhs (nullptr), preserve (plhs),
+        ans_ass (), etype (t) { }
 
     tree_simple_assignment (tree_expression *le, tree_expression *re,
                             bool plhs = false, int l = -1, int c = -1,
                             octave_value::assign_op t = octave_value::op_asn_eq);
 
     // No copying!
 
     tree_simple_assignment (const tree_simple_assignment&) = delete;
@@ -110,17 +110,18 @@ namespace octave
 
   // Multi-valued assignment expressions.
 
   class tree_multi_assignment : public tree_expression
   {
   public:
 
     tree_multi_assignment (bool plhs = false, int l = -1, int c = -1)
-      : tree_expression (l, c), lhs (0), rhs (0), preserve (plhs) { }
+      : tree_expression (l, c), lhs (nullptr), rhs (nullptr), preserve (plhs)
+      { }
 
     tree_multi_assignment (tree_argument_list *lst, tree_expression *r,
                            bool plhs = false, int l = -1, int c = -1);
 
     // No copying!
 
     tree_multi_assignment (const tree_multi_assignment&) = delete;
 
diff --git a/libinterp/parse-tree/pt-binop.cc b/libinterp/parse-tree/pt-binop.cc
--- a/libinterp/parse-tree/pt-binop.cc
+++ b/libinterp/parse-tree/pt-binop.cc
@@ -48,18 +48,18 @@ namespace octave
   {
     return octave_value::binary_op_as_string (etype);
   }
 
   tree_expression *
   tree_binary_expression::dup (symbol_table::scope& scope) const
   {
     tree_binary_expression *new_be
-      = new tree_binary_expression (op_lhs ? op_lhs->dup (scope) : 0,
-                                    op_rhs ? op_rhs->dup (scope) : 0,
+      = new tree_binary_expression (op_lhs ? op_lhs->dup (scope) : nullptr,
+                                    op_rhs ? op_rhs->dup (scope) : nullptr,
                                     line (), column (), etype);
 
     new_be->copy_base (*this);
 
     return new_be;
   }
 
   // Boolean expressions.
@@ -85,17 +85,17 @@ namespace octave
 
     return retval;
   }
 
   tree_expression *
   tree_boolean_expression::dup (symbol_table::scope& scope) const
   {
     tree_boolean_expression *new_be
-      = new tree_boolean_expression (op_lhs ? op_lhs->dup (scope) : 0,
-                                     op_rhs ? op_rhs->dup (scope) : 0,
+      = new tree_boolean_expression (op_lhs ? op_lhs->dup (scope) : nullptr,
+                                     op_rhs ? op_rhs->dup (scope) : nullptr,
                                      line (), column (), etype);
 
     new_be->copy_base (*this);
 
     return new_be;
   }
 }
diff --git a/libinterp/parse-tree/pt-binop.h b/libinterp/parse-tree/pt-binop.h
--- a/libinterp/parse-tree/pt-binop.h
+++ b/libinterp/parse-tree/pt-binop.h
@@ -41,17 +41,17 @@ namespace octave
 
   class tree_binary_expression : public tree_expression
   {
   public:
 
     tree_binary_expression (int l = -1, int c = -1,
                             octave_value::binary_op t
                             = octave_value::unknown_binary_op)
-      : tree_expression (l, c), op_lhs (0), op_rhs (0), etype (t),
+      : tree_expression (l, c), op_lhs (nullptr), op_rhs (nullptr), etype (t),
         eligible_for_braindead_shortcircuit (false),
         braindead_shortcircuit_warning_issued (false) { }
 
     tree_binary_expression (tree_expression *a, tree_expression *b,
                             int l = -1, int c = -1,
                             octave_value::binary_op t
                             = octave_value::unknown_binary_op)
       : tree_expression (l, c), op_lhs (a), op_rhs (b), etype (t),
diff --git a/libinterp/parse-tree/pt-cell.cc b/libinterp/parse-tree/pt-cell.cc
--- a/libinterp/parse-tree/pt-cell.cc
+++ b/libinterp/parse-tree/pt-cell.cc
@@ -34,15 +34,15 @@ along with Octave; see the file COPYING.
 #include "pt-walk.h"
 #include "ov.h"
 
 namespace octave
 {
   tree_expression *
   tree_cell::dup (symbol_table::scope& scope) const
   {
-    tree_cell *new_cell = new tree_cell (0, line (), column ());
+    tree_cell *new_cell = new tree_cell (nullptr, line (), column ());
 
     new_cell->copy_base (*this, scope);
 
     return new_cell;
   }
 }
diff --git a/libinterp/parse-tree/pt-classdef.cc b/libinterp/parse-tree/pt-classdef.cc
--- a/libinterp/parse-tree/pt-classdef.cc
+++ b/libinterp/parse-tree/pt-classdef.cc
@@ -147,11 +147,11 @@ namespace octave
   octave_function*
   tree_classdef::make_meta_class (interpreter& interp, bool is_at_folder)
   {
     cdef_class cls = cdef_class::make_meta_class (interp, this, is_at_folder);
 
     if (cls.ok ())
       return cls.get_constructor_function ();
 
-    return 0;
+    return nullptr;
   }
 }
diff --git a/libinterp/parse-tree/pt-classdef.h b/libinterp/parse-tree/pt-classdef.h
--- a/libinterp/parse-tree/pt-classdef.h
+++ b/libinterp/parse-tree/pt-classdef.h
@@ -45,17 +45,17 @@ namespace octave
   {
   public:
 
     tree_classdef_attribute (tree_identifier *i = nullptr,
                              tree_expression *e = nullptr)
       : id (i), expr (e), neg (false) { }
 
     tree_classdef_attribute (tree_identifier *i, bool b)
-      : id (i), expr (0), neg (b) { }
+      : id (i), expr (nullptr), neg (b) { }
 
     // No copying!
 
     tree_classdef_attribute (const tree_classdef_attribute&) = delete;
 
     tree_classdef_attribute& operator = (const tree_classdef_attribute&) = delete;
 
     ~tree_classdef_attribute (void)
@@ -432,17 +432,17 @@ namespace octave
       tw.visit_classdef_events_block (*this);
     }
   };
 
   class tree_classdef_enum
   {
   public:
 
-    tree_classdef_enum (void) : id (0), expr (0) { }
+    tree_classdef_enum (void) : id (nullptr), expr (nullptr) { }
 
     tree_classdef_enum (tree_identifier *i, tree_expression *e)
       : id (i), expr (e) { }
 
     // No copying!
 
     tree_classdef_enum (const tree_classdef_enum&) = delete;
 
diff --git a/libinterp/parse-tree/pt-colon.cc b/libinterp/parse-tree/pt-colon.cc
--- a/libinterp/parse-tree/pt-colon.cc
+++ b/libinterp/parse-tree/pt-colon.cc
@@ -29,18 +29,18 @@ along with Octave; see the file COPYING.
 namespace octave
 {
   // Colon expressions.
 
   tree_expression *
   tree_colon_expression::dup (symbol_table::scope& scope) const
   {
     tree_colon_expression *new_ce
-      = new tree_colon_expression (op_base ? op_base->dup (scope) : 0,
-                                   op_limit ? op_limit->dup (scope) : 0,
-                                   op_increment ? op_increment->dup (scope) : 0,
+      = new tree_colon_expression (op_base ? op_base->dup (scope) : nullptr,
+                                   op_limit ? op_limit->dup (scope) : nullptr,
+                                   op_increment ? op_increment->dup (scope) : nullptr,
                                    line (), column ());
 
     new_ce->copy_base (*new_ce);
 
     return new_ce;
   }
 }
diff --git a/libinterp/parse-tree/pt-colon.h b/libinterp/parse-tree/pt-colon.h
--- a/libinterp/parse-tree/pt-colon.h
+++ b/libinterp/parse-tree/pt-colon.h
@@ -38,23 +38,23 @@ namespace octave
 {
   // Colon expressions.
 
   class tree_colon_expression : public tree_expression
   {
   public:
 
     tree_colon_expression (int l = -1, int c = -1)
-      : tree_expression (l, c), op_base (0), op_limit (0),
-        op_increment (0), save_base (false) { }
+      : tree_expression (l, c), op_base (nullptr), op_limit (nullptr),
+        op_increment (nullptr), save_base (false) { }
 
     tree_colon_expression (tree_expression *bas, tree_expression *lim,
                            int l = -1, int c = -1)
       : tree_expression (l, c), op_base (bas), op_limit (lim),
-        op_increment (0), save_base (false) { }
+        op_increment (nullptr), save_base (false) { }
 
     tree_colon_expression (tree_expression *bas, tree_expression *lim,
                            tree_expression *inc, int l = -1, int c = -1)
       : tree_expression (l, c), op_base (bas), op_limit (lim),
         op_increment (inc), save_base (false) { }
 
     // No copying!
 
diff --git a/libinterp/parse-tree/pt-decl.cc b/libinterp/parse-tree/pt-decl.cc
--- a/libinterp/parse-tree/pt-decl.cc
+++ b/libinterp/parse-tree/pt-decl.cc
@@ -45,18 +45,18 @@ namespace octave
   {
     delete id;
     delete expr;
   }
 
   tree_decl_elt *
   tree_decl_elt::dup (symbol_table::scope& scope) const
   {
-    return new tree_decl_elt (id ? id->dup (scope) : 0,
-                              expr ? expr->dup (scope) : 0);
+    return new tree_decl_elt (id ? id->dup (scope) : nullptr,
+                              expr ? expr->dup (scope) : nullptr);
   }
 
   // Initializer lists for declaration statements.
 
   // Declaration commands (global, static).
 
   tree_decl_command::tree_decl_command (const std::string& n,
                                         tree_decl_init_list *t, int l, int c)
diff --git a/libinterp/parse-tree/pt-decl.h b/libinterp/parse-tree/pt-decl.h
--- a/libinterp/parse-tree/pt-decl.h
+++ b/libinterp/parse-tree/pt-decl.h
@@ -155,17 +155,17 @@ namespace octave
 
   // Base class for declaration commands -- global, static, etc.
 
   class tree_decl_command : public tree_command
   {
   public:
 
     tree_decl_command (const std::string& n, int l = -1, int c = -1)
-      : tree_command (l, c), cmd_name (n), init_list (0) { }
+      : tree_command (l, c), cmd_name (n), init_list (nullptr) { }
 
     tree_decl_command (const std::string& n, tree_decl_init_list *t,
                        int l = -1, int c = -1);
 
     // No copying!
 
     tree_decl_command (const tree_decl_command&) = delete;
 
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -92,34 +92,34 @@ namespace octave
     tree_parameter_list *param_list = anon_fh.parameter_list ();
     tree_expression *expr = anon_fh.expression ();
 
     symbol_table::scope *af_scope = anon_fh.scope ();
 
     symbol_table& symtab = m_interpreter.get_symbol_table ();
 
     symbol_table::scope *af_parent_scope
-      = anon_fh.has_parent_scope () ? symtab.current_scope () : 0;
-
-    symbol_table::scope *new_scope = af_scope ? af_scope->dup () : 0;
+      = anon_fh.has_parent_scope () ? symtab.current_scope () : nullptr;
+
+    symbol_table::scope *new_scope = af_scope ? af_scope->dup () : nullptr;
 
     if (new_scope && af_parent_scope)
       new_scope->inherit (af_parent_scope);
 
     tree_parameter_list *param_list_dup
-      = param_list ? param_list->dup (*new_scope) : 0;
-
-    tree_parameter_list *ret_list = 0;
-
-    tree_statement_list *stmt_list = 0;
+      = param_list ? param_list->dup (*new_scope) : nullptr;
+
+    tree_parameter_list *ret_list = nullptr;
+
+    tree_statement_list *stmt_list = nullptr;
 
     if (expr)
       {
         tree_expression *expr_dup = expr->dup (*new_scope);
-        tree_statement *stmt = new tree_statement (expr_dup, 0);
+        tree_statement *stmt = new tree_statement (expr_dup, nullptr);
         stmt_list = new tree_statement_list (stmt);
       }
 
     octave_user_function *af
       = new octave_user_function (new_scope, param_list_dup, ret_list,
                                   stmt_list);
 
     new_scope->set_parent (af_parent_scope);
@@ -1273,17 +1273,17 @@ namespace octave
 
             if (al && al->length () > 0)
               {
                 // Function calls inside an argument list can't have
                 // ignored output arguments.
 
                 unwind_protect frame;
 
-                m_lvalue_list_stack.push (0);
+                m_lvalue_list_stack.push (nullptr);
 
                 frame.add_method (m_lvalue_list_stack,
                                   &value_stack<const std::list<octave_lvalue>*>::pop);
 
                 string_vector anm = *p_arg_nm;
                 first_args = al->convert_to_const_vector (this);
                 first_args.stash_name_tags (anm);
               }
@@ -1681,17 +1681,17 @@ namespace octave
   {
     octave_value retval;
 
     // Function calls inside an argument list can't have ignored
     // output arguments.
 
     unwind_protect frame;
 
-    m_lvalue_list_stack.push (0);
+    m_lvalue_list_stack.push (nullptr);
 
     frame.add_method (m_lvalue_list_stack,
                       &value_stack<const std::list<octave_lvalue>*>::pop);
 
     octave_idx_type nr = expr.length ();
     octave_idx_type nc = -1;
 
     Cell val;
@@ -2808,17 +2808,17 @@ namespace octave
 
     if (args)
       {
         // Function calls inside an argument list can't have ignored
         // output arguments.
 
         unwind_protect frame;
 
-        m_lvalue_list_stack.push (0);
+        m_lvalue_list_stack.push (nullptr);
 
         frame.add_method (m_lvalue_list_stack,
                           &value_stack<const std::list<octave_lvalue>*>::pop);
 
         if (rvalue && object && args->has_magic_end ()
             && object->is_undefined ())
           err_invalid_inquiry_subscript ();
 
diff --git a/libinterp/parse-tree/pt-eval.h b/libinterp/parse-tree/pt-eval.h
--- a/libinterp/parse-tree/pt-eval.h
+++ b/libinterp/parse-tree/pt-eval.h
@@ -255,17 +255,17 @@ namespace octave
 
     // TRUE means we are evaluating some kind of looping construct.
     static bool in_loop_command;
 
     Matrix ignored_fcn_outputs (void) const;
 
     const std::list<octave_lvalue> * lvalue_list (void)
     {
-      return m_lvalue_list_stack.empty () ? 0 : m_lvalue_list_stack.top ();
+      return m_lvalue_list_stack.empty () ? nullptr : m_lvalue_list_stack.top ();
     }
 
     octave_value evaluate (tree_expression *expr, int nargout = 1)
     {
       m_nargout_stack.push (nargout);
 
       expr->accept (*this);
 
diff --git a/libinterp/parse-tree/pt-except.h b/libinterp/parse-tree/pt-except.h
--- a/libinterp/parse-tree/pt-except.h
+++ b/libinterp/parse-tree/pt-except.h
@@ -37,18 +37,19 @@ namespace octave
 
   // Simple exception handling.
 
   class tree_try_catch_command : public tree_command
   {
   public:
 
     tree_try_catch_command (int l = -1, int c = -1)
-      : tree_command (l, c), try_code (0), catch_code (0), expr_id (0),
-        lead_comm (0), mid_comm (0), trail_comm (0) { }
+      : tree_command (l, c),
+        try_code (nullptr), catch_code (nullptr), expr_id (nullptr),
+        lead_comm (nullptr), mid_comm (nullptr), trail_comm (nullptr) { }
 
     tree_try_catch_command (tree_statement_list *tc, tree_statement_list *cc,
                             tree_identifier *id,
                             comment_list *cl = nullptr,
                             comment_list *cm = nullptr,
                             comment_list *ct = nullptr,
                             int l = -1, int c = -1)
       : tree_command (l, c), try_code (tc), catch_code (cc), expr_id (id),
@@ -102,18 +103,19 @@ namespace octave
 
   // Simple exception handling.
 
   class tree_unwind_protect_command : public tree_command
   {
   public:
 
     tree_unwind_protect_command (int l = -1, int c = -1)
-      : tree_command (l, c), unwind_protect_code (0), cleanup_code (0),
-        lead_comm (0), mid_comm (0), trail_comm (0) { }
+      : tree_command (l, c),
+        unwind_protect_code (nullptr), cleanup_code (nullptr),
+        lead_comm (nullptr), mid_comm (nullptr), trail_comm (nullptr) { }
 
     tree_unwind_protect_command (tree_statement_list *tc,
                                  tree_statement_list *cc,
                                  comment_list *cl = nullptr,
                                  comment_list *cm = nullptr,
                                  comment_list *ct = nullptr,
                                  int l = -1, int c = -1)
       : tree_command (l, c), unwind_protect_code (tc), cleanup_code (cc),
diff --git a/libinterp/parse-tree/pt-fcn-handle.cc b/libinterp/parse-tree/pt-fcn-handle.cc
--- a/libinterp/parse-tree/pt-fcn-handle.cc
+++ b/libinterp/parse-tree/pt-fcn-handle.cc
@@ -69,28 +69,28 @@ namespace octave
     tree_expression *expr = expression ();
 
     symbol_table::scope *af_scope = m_scope;
     symbol_table::scope *af_parent_scope = m_parent_scope;
 
     symbol_table& symtab
       = __get_symbol_table__ ("tree_anon_fcn_handle::dup");
 
-    symbol_table::scope *new_scope = af_scope ? af_scope->dup () : 0;
+    symbol_table::scope *new_scope = af_scope ? af_scope->dup () : nullptr;
 
     // FIXME: why should we inherit from the current scope here?  That
     // doesn't seem right, but with the way things work now it appears
     // to be required for bug-31371.tst to pass.
 
     if (new_scope)
       symtab.inherit (new_scope);
 
     tree_anon_fcn_handle *new_afh = new
-      tree_anon_fcn_handle (param_list ? param_list->dup (*new_scope) : 0,
-                            expr ? expr->dup (*new_scope) : 0,
+      tree_anon_fcn_handle (param_list ? param_list->dup (*new_scope) : nullptr,
+                            expr ? expr->dup (*new_scope) : nullptr,
                             new_scope, af_parent_scope, line (), column ());
 
     new_afh->copy_base (*this);
 
     return new_afh;
   }
 }
 
diff --git a/libinterp/parse-tree/pt-fcn-handle.h b/libinterp/parse-tree/pt-fcn-handle.h
--- a/libinterp/parse-tree/pt-fcn-handle.h
+++ b/libinterp/parse-tree/pt-fcn-handle.h
@@ -86,18 +86,19 @@ namespace octave
     std::string nm;
   };
 
   class tree_anon_fcn_handle : public tree_expression
   {
   public:
 
     tree_anon_fcn_handle (int l = -1, int c = -1)
-      : tree_expression (l, c), m_parameter_list (0), m_expression (0),
-        m_scope (0), m_parent_scope (0), m_file_name ()
+      : tree_expression (l, c), m_parameter_list (nullptr),
+        m_expression (nullptr), m_scope (nullptr), m_parent_scope (nullptr),
+        m_file_name ()
     { }
 
     tree_anon_fcn_handle (tree_parameter_list *pl, tree_expression *ex,
                           symbol_table::scope *scope,
                           symbol_table::scope *parent_scope,
                           int l = -1, int c = -1)
       : tree_expression (l, c), m_parameter_list (pl), m_expression (ex),
         m_scope (scope), m_parent_scope (parent_scope), m_file_name ()
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -39,17 +39,17 @@ along with Octave; see the file COPYING.
 #include "variables.h"
 #include "errwarn.h"
 
 namespace octave
 {
   // Index expressions.
 
   tree_index_expression::tree_index_expression (int l, int c)
-    : tree_expression (l, c), expr (0), args (0), type (),
+    : tree_expression (l, c), expr (nullptr), args (0), type (),
       arg_nm (), dyn_field () { }
 
   tree_index_expression::tree_index_expression (tree_expression *e,
                                                 tree_argument_list *lst,
                                                 int l, int c, char t)
     : tree_expression (l, c), expr (e), args (0), type (),
       arg_nm (), dyn_field ()
   {
@@ -75,35 +75,35 @@ namespace octave
   }
 
   void
   tree_index_expression::append (tree_argument_list *lst, char t)
   {
     args.push_back (lst);
     type.append (1, t);
     arg_nm.push_back (lst ? lst->get_arg_names () : string_vector ());
-    dyn_field.push_back (static_cast<tree_expression *> (0));
+    dyn_field.push_back (static_cast<tree_expression *> (nullptr));
 
     if (lst && lst->has_magic_tilde ())
       error ("invalid use of empty argument (~) in index expression");
   }
 
   void
   tree_index_expression::append (const std::string& n)
   {
-    args.push_back (static_cast<tree_argument_list *> (0));
+    args.push_back (static_cast<tree_argument_list *> (nullptr));
     type.append (".");
     arg_nm.push_back (n);
-    dyn_field.push_back (static_cast<tree_expression *> (0));
+    dyn_field.push_back (static_cast<tree_expression *> (nullptr));
   }
 
   void
   tree_index_expression::append (tree_expression *df)
   {
-    args.push_back (static_cast<tree_argument_list *> (0));
+    args.push_back (static_cast<tree_argument_list *> (nullptr));
     type.append (".");
     arg_nm.push_back ("");
     dyn_field.push_back (df);
   }
 
   tree_index_expression::~tree_index_expression (void)
   {
     delete expr;
@@ -386,33 +386,33 @@ namespace octave
   }
 
   tree_index_expression *
   tree_index_expression::dup (symbol_table::scope& scope) const
   {
     tree_index_expression *new_idx_expr
       = new tree_index_expression (line (), column ());
 
-    new_idx_expr->expr = (expr ? expr->dup (scope) : 0);
+    new_idx_expr->expr = (expr ? expr->dup (scope) : nullptr);
 
     std::list<tree_argument_list *> new_args;
 
     for (const tree_argument_list *elt : args)
-      new_args.push_back (elt ? elt->dup (scope) : 0);
+      new_args.push_back (elt ? elt->dup (scope) : nullptr);
 
     new_idx_expr->args = new_args;
 
     new_idx_expr->type = type;
 
     new_idx_expr->arg_nm = arg_nm;
 
     std::list<tree_expression *> new_dyn_field;
 
     for (const tree_expression *elt : dyn_field)
-      new_dyn_field.push_back (elt ? elt->dup (scope) : 0);
+      new_dyn_field.push_back (elt ? elt->dup (scope) : nullptr);
 
     new_idx_expr->dyn_field = new_dyn_field;
 
     new_idx_expr->copy_base (*this);
 
     return new_idx_expr;
   }
 }
diff --git a/libinterp/parse-tree/pt-jit.cc b/libinterp/parse-tree/pt-jit.cc
--- a/libinterp/parse-tree/pt-jit.cc
+++ b/libinterp/parse-tree/pt-jit.cc
@@ -1113,17 +1113,17 @@ jit_convert::create_checked_impl (jit_ca
   return ret;
 }
 
 jit_variable *
 jit_convert::find_variable (const std::string& vname) const
 {
   variable_map::const_iterator iter;
   iter = vmap.find (vname);
-  return iter != vmap.end () ? iter->second : 0;
+  return iter != vmap.end () ? iter->second : nullptr;
 }
 
 jit_variable *
 jit_convert::get_variable (const std::string& vname)
 {
   jit_variable *ret = find_variable (vname);
   if (ret)
     return ret;
diff --git a/libinterp/parse-tree/pt-loop.h b/libinterp/parse-tree/pt-loop.h
--- a/libinterp/parse-tree/pt-loop.h
+++ b/libinterp/parse-tree/pt-loop.h
@@ -41,42 +41,42 @@ namespace octave
 
   // While.
 
   class tree_while_command : public tree_command
   {
   public:
 
     tree_while_command (int l = -1, int c = -1)
-      : tree_command (l, c), expr (0), list (0), lead_comm (0),
-        trail_comm (0)
+      : tree_command (l, c), expr (nullptr), list (nullptr),
+        lead_comm (nullptr), trail_comm (nullptr)
 #if defined (HAVE_LLVM)
-      , compiled (0)
+      , compiled (nullptr)
 #endif
     { }
 
     tree_while_command (tree_expression *e,
                         comment_list *lc = nullptr,
                         comment_list *tc = nullptr,
                         int l = -1, int c = -1)
-      : tree_command (l, c), expr (e), list (0), lead_comm (lc),
-        trail_comm (tc)
+      : tree_command (l, c), expr (e), list (nullptr),
+        lead_comm (lc), trail_comm (tc)
 #if defined (HAVE_LLVM)
-      , compiled (0)
+      , compiled (nullptr)
 #endif
     { }
 
     tree_while_command (tree_expression *e, tree_statement_list *lst,
                         comment_list *lc = nullptr,
                         comment_list *tc = nullptr,
                         int l = -1, int c = -1)
       : tree_command (l, c), expr (e), list (lst), lead_comm (lc),
         trail_comm (tc)
 #if defined (HAVE_LLVM)
-      , compiled (0)
+      , compiled (nullptr)
 #endif
     { }
 
     // No copying!
 
     tree_while_command (const tree_while_command&) = delete;
 
     tree_while_command& operator = (const tree_while_command&) = delete;
@@ -169,19 +169,19 @@ namespace octave
   // For.
 
   class tree_simple_for_command : public tree_command
   {
   public:
 
     tree_simple_for_command (int l = -1, int c = -1)
       : tree_command (l, c), parallel (false), lhs (0), expr (0),
-        maxproc (0), list (0), lead_comm (0), trail_comm (0)
+        maxproc (0), list (nullptr), lead_comm (nullptr), trail_comm (nullptr)
 #if defined (HAVE_LLVM)
-      , compiled (0)
+      , compiled (nullptr)
 #endif
     { }
 
     tree_simple_for_command (bool parallel_arg, tree_expression *le,
                              tree_expression *re,
                              tree_expression *maxproc_arg,
                              tree_statement_list *lst,
                              comment_list *lc = nullptr,
@@ -265,18 +265,18 @@ namespace octave
 #endif
   };
 
   class tree_complex_for_command : public tree_command
   {
   public:
 
     tree_complex_for_command (int l = -1, int c = -1)
-      : tree_command (l, c), lhs (0), expr (0), list (0), lead_comm (0),
-        trail_comm (0) { }
+      : tree_command (l, c), lhs (nullptr), expr (nullptr), list (nullptr),
+        lead_comm (nullptr), trail_comm (nullptr) { }
 
     tree_complex_for_command (tree_argument_list *le, tree_expression *re,
                               tree_statement_list *lst,
                               comment_list *lc = nullptr,
                               comment_list *tc = nullptr,
                               int l = -1, int c = -1)
       : tree_command (l, c), lhs (le), expr (re), list (lst),
         lead_comm (lc), trail_comm (tc) { }
diff --git a/libinterp/parse-tree/pt-mat.cc b/libinterp/parse-tree/pt-mat.cc
--- a/libinterp/parse-tree/pt-mat.cc
+++ b/libinterp/parse-tree/pt-mat.cc
@@ -119,17 +119,17 @@ namespace octave
     if (! (all_dq_strings_p || all_sq_strings_p))
       warning_with_id ("Octave:mixed-string-concat",
                        "concatenation of different character string types may have unintended consequences");
   }
 
   tree_expression *
   tree_matrix::dup (symbol_table::scope& scope) const
   {
-    tree_matrix *new_matrix = new tree_matrix (0, line (), column ());
+    tree_matrix *new_matrix = new tree_matrix (nullptr, line (), column ());
 
     new_matrix->copy_base (*this, scope);
 
     return new_matrix;
   }
 }
 
 
diff --git a/libinterp/parse-tree/pt-select.h b/libinterp/parse-tree/pt-select.h
--- a/libinterp/parse-tree/pt-select.h
+++ b/libinterp/parse-tree/pt-select.h
@@ -38,21 +38,21 @@ namespace octave
 
   // If.
 
   class tree_if_clause : public tree
   {
   public:
 
     tree_if_clause (int l = -1, int c = -1)
-      : tree (l, c), expr (0), list (0), lead_comm (0) { }
+      : tree (l, c), expr (nullptr), list (nullptr), lead_comm (nullptr) { }
 
     tree_if_clause (tree_statement_list *sl, comment_list *lc = nullptr,
                     int l = -1, int c = -1)
-      : tree (l, c), expr (0), list (sl), lead_comm (lc) { }
+      : tree (l, c), expr (nullptr), list (sl), lead_comm (lc) { }
 
     tree_if_clause (tree_expression *e, tree_statement_list *sl,
                     comment_list *lc = nullptr,
                     int l = -1, int c = -1)
       : tree (l, c), expr (e), list (sl), lead_comm (lc) { }
 
     // No copying!
 
@@ -117,17 +117,19 @@ namespace octave
     }
   };
 
   class tree_if_command : public tree_command
   {
   public:
 
     tree_if_command (int l = -1, int c = -1)
-      : tree_command (l, c), list (0), lead_comm (0), trail_comm (0) { }
+      : tree_command (l, c), list (nullptr),
+        lead_comm (nullptr), trail_comm (nullptr)
+    { }
 
     tree_if_command (tree_if_command_list *lst, comment_list *lc,
                      comment_list *tc, int l = -1, int c = -1)
       : tree_command (l, c), list (lst), lead_comm (lc), trail_comm (tc) { }
 
     // No copying!
 
     tree_if_command (const tree_if_command&) = delete;
@@ -161,21 +163,21 @@ namespace octave
 
   // Switch.
 
   class tree_switch_case : public tree
   {
   public:
 
     tree_switch_case (int l = -1, int c = -1)
-      : tree (l, c), label (0), list (0), lead_comm (0) { }
+      : tree (l, c), label (nullptr), list (nullptr), lead_comm (nullptr) { }
 
     tree_switch_case (tree_statement_list *sl, comment_list *lc = nullptr,
                       int l = -1, int c = -1)
-      : tree (l, c), label (0), list (sl), lead_comm (lc) { }
+      : tree (l, c), label (nullptr), list (sl), lead_comm (lc) { }
 
     tree_switch_case (tree_expression *e, tree_statement_list *sl,
                       comment_list *lc = nullptr,
                       int l = -1, int c = -1)
       : tree (l, c), label (e), list (sl), lead_comm (lc) { }
 
     // No copying!
 
@@ -240,18 +242,18 @@ namespace octave
     }
   };
 
   class tree_switch_command : public tree_command
   {
   public:
 
     tree_switch_command (int l = -1, int c = -1)
-      : tree_command (l, c), expr (0), list (0), lead_comm (0),
-        trail_comm (0) { }
+      : tree_command (l, c), expr (nullptr), list (nullptr),
+        lead_comm (nullptr), trail_comm (nullptr) { }
 
     tree_switch_command (tree_expression *e, tree_switch_case_list *lst,
                          comment_list *lc, comment_list *tc,
                          int l = -1, int c = -1)
       : tree_command (l, c), expr (e), list (lst), lead_comm (lc),
         trail_comm (tc) { }
 
     // No copying!
diff --git a/libinterp/parse-tree/pt-stmt.h b/libinterp/parse-tree/pt-stmt.h
--- a/libinterp/parse-tree/pt-stmt.h
+++ b/libinterp/parse-tree/pt-stmt.h
@@ -44,39 +44,39 @@ namespace octave
   // A statement is either a command to execute or an expression to
   // evaluate.
 
   class tree_statement : public tree
   {
   public:
 
     tree_statement (void)
-      : cmd (0), expr (0), comm (0) { }
+      : cmd (nullptr), expr (nullptr), comm (nullptr) { }
 
     tree_statement (tree_command *c, comment_list *cl)
-      : cmd (c), expr (0), comm (cl) { }
+      : cmd (c), expr (nullptr), comm (cl) { }
 
     tree_statement (tree_expression *e, comment_list *cl)
-      : cmd (0), expr (e), comm (cl) { }
+      : cmd (nullptr), expr (e), comm (cl) { }
 
     // No copying!
 
     tree_statement (const tree_statement&) = delete;
 
     tree_statement& operator = (const tree_statement&) = delete;
 
     ~tree_statement (void);
 
     void set_print_flag (bool print_flag);
 
     bool print_result (void);
 
-    bool is_command (void) const { return cmd != 0; }
+    bool is_command (void) const { return cmd != nullptr; }
 
-    bool is_expression (void) const { return expr != 0; }
+    bool is_expression (void) const { return expr != nullptr; }
 
     void set_breakpoint (const std::string& condition);
 
     void delete_breakpoint (void);
 
     bool is_breakpoint (bool check_valid = false) const;
     std::string bp_cond () const;
 
diff --git a/libinterp/parse-tree/pt-tm-const.h b/libinterp/parse-tree/pt-tm-const.h
--- a/libinterp/parse-tree/pt-tm-const.h
+++ b/libinterp/parse-tree/pt-tm-const.h
@@ -114,17 +114,17 @@ namespace octave
     };
 
   public:
 
     typedef tm_row_const_rep::iterator iterator;
     typedef tm_row_const_rep::const_iterator const_iterator;
 
     tm_row_const (void)
-      : rep (0) { }
+      : rep (nullptr) { }
 
     tm_row_const (const tree_argument_list& row, tree_evaluator *tw)
       : rep (new tm_row_const_rep (row, tw)) { }
 
     tm_row_const (const tm_row_const& x)
       : rep (x.rep)
     {
       if (rep)
@@ -192,17 +192,17 @@ namespace octave
     tm_row_const_rep *rep;
   };
 
   class
   tm_const : public base_list<tm_row_const>
   {
   public:
 
-    tm_const (const tree_matrix& tm, tree_evaluator *tw = 0)
+    tm_const (const tree_matrix& tm, tree_evaluator *tw = nullptr)
       : dv (0, 0), all_str (false), all_sq_str (false),
         all_dq_str (false),
         some_str (false), all_real (false), all_cmplx (false),
         all_mt (true), any_cell (false), any_sparse (false),
         any_class (false), class_nm (), ok (false)
     { init (tm, tw); }
 
     ~tm_const (void) = default;
diff --git a/libinterp/parse-tree/pt-unop.cc b/libinterp/parse-tree/pt-unop.cc
--- a/libinterp/parse-tree/pt-unop.cc
+++ b/libinterp/parse-tree/pt-unop.cc
@@ -38,30 +38,30 @@ namespace octave
   }
 
   // Prefix expressions.
 
   tree_expression *
   tree_prefix_expression::dup (symbol_table::scope& scope) const
   {
     tree_prefix_expression *new_pe
-      = new tree_prefix_expression (op ? op->dup (scope) : 0,
+      = new tree_prefix_expression (op ? op->dup (scope) : nullptr,
                                     line (), column (), etype);
 
     new_pe->copy_base (*this);
 
     return new_pe;
   }
 
   // Postfix expressions.
 
   tree_expression *
   tree_postfix_expression::dup (symbol_table::scope& scope) const
   {
     tree_postfix_expression *new_pe
-      = new tree_postfix_expression (op ? op->dup (scope) : 0,
+      = new tree_postfix_expression (op ? op->dup (scope) : nullptr,
                                      line (), column (), etype);
 
     new_pe->copy_base (*this);
 
     return new_pe;
   }
 }
diff --git a/libinterp/parse-tree/pt-unop.h b/libinterp/parse-tree/pt-unop.h
--- a/libinterp/parse-tree/pt-unop.h
+++ b/libinterp/parse-tree/pt-unop.h
@@ -40,17 +40,17 @@ namespace octave
 
   class tree_unary_expression : public tree_expression
   {
   protected:
 
     tree_unary_expression (int l = -1, int c = -1,
                            octave_value::unary_op t
                            = octave_value::unknown_unary_op)
-      : tree_expression (l, c), op (0), etype (t)  { }
+      : tree_expression (l, c), op (nullptr), etype (t)  { }
 
     tree_unary_expression (tree_expression *e, int l = -1, int c = -1,
                            octave_value::unary_op t
                            = octave_value::unknown_unary_op)
       : tree_expression (l, c), op (e), etype (t) { }
 
   public:
 
diff --git a/libinterp/parse-tree/pt.cc b/libinterp/parse-tree/pt.cc
--- a/libinterp/parse-tree/pt.cc
+++ b/libinterp/parse-tree/pt.cc
@@ -54,17 +54,17 @@ namespace octave
 
   // function from libinterp/parse-tree/oct-parse.cc, not listed in oct-parse.h
   octave_value_list eval_string (const std::string&, bool, int&, int);
   // Is the current breakpoint condition met?
   bool
   tree::meets_bp_condition () const
   {
     bool retval;
-    if (bp == 0)
+    if (bp == nullptr)
       retval = false;
     else if (bp->empty ())     // empty condition always met
       retval = true;
     else
       {
         int parse_status = 0;
 
         unwind_protect frame;
diff --git a/liboctave/array/Array-C.cc b/liboctave/array/Array-C.cc
--- a/liboctave/array/Array-C.cc
+++ b/liboctave/array/Array-C.cc
@@ -59,17 +59,17 @@ static bool
 nan_descending_compare (const Complex& x, const Complex& y)
 {
   return octave::math::isnan (x) ? ! octave::math::isnan (y) : x > y;
 }
 
 Array<Complex>::compare_fcn_type
 safe_comparator (sortmode mode, const Array<Complex>& a , bool allow_chk)
 {
-  Array<Complex>::compare_fcn_type result = 0;
+  Array<Complex>::compare_fcn_type result = nullptr;
 
   if (allow_chk)
     {
       octave_idx_type k = 0;
       for (; k < a.numel () && ! octave::math::isnan (a(k)); k++) ;
       if (k == a.numel ())
         {
           if (mode == ASCENDING)
diff --git a/liboctave/array/Array-d.cc b/liboctave/array/Array-d.cc
--- a/liboctave/array/Array-d.cc
+++ b/liboctave/array/Array-d.cc
@@ -59,17 +59,17 @@ static bool
 nan_descending_compare (double x, double y)
 {
   return octave::math::isnan (x) ? ! octave::math::isnan (y) : x > y;
 }
 
 Array<double>::compare_fcn_type
 safe_comparator (sortmode mode, const Array<double>& a , bool allow_chk)
 {
-  Array<double>::compare_fcn_type result = 0;
+  Array<double>::compare_fcn_type result = nullptr;
 
   if (allow_chk)
     {
       octave_idx_type k = 0;
       for (; k < a.numel () && ! octave::math::isnan (a(k)); k++) ;
       if (k == a.numel ())
         {
           if (mode == ASCENDING)
diff --git a/liboctave/array/Array-f.cc b/liboctave/array/Array-f.cc
--- a/liboctave/array/Array-f.cc
+++ b/liboctave/array/Array-f.cc
@@ -59,17 +59,17 @@ static bool
 nan_descending_compare (float x, float y)
 {
   return octave::math::isnan (x) ? ! octave::math::isnan (y) : x > y;
 }
 
 Array<float>::compare_fcn_type
 safe_comparator (sortmode mode, const Array<float>& a , bool allow_chk)
 {
-  Array<float>::compare_fcn_type result = 0;
+  Array<float>::compare_fcn_type result = nullptr;
 
   if (allow_chk)
     {
       octave_idx_type k = 0;
       for (; k < a.numel () && ! octave::math::isnan (a(k)); k++) ;
       if (k == a.numel ())
         {
           if (mode == ASCENDING)
diff --git a/liboctave/array/Array-fC.cc b/liboctave/array/Array-fC.cc
--- a/liboctave/array/Array-fC.cc
+++ b/liboctave/array/Array-fC.cc
@@ -59,17 +59,17 @@ static bool
 nan_descending_compare (const FloatComplex& x, const FloatComplex& y)
 {
   return octave::math::isnan (x) ? ! octave::math::isnan (y) : x > y;
 }
 
 Array<FloatComplex>::compare_fcn_type
 safe_comparator (sortmode mode, const Array<FloatComplex>& a, bool allow_chk)
 {
-  Array<FloatComplex>::compare_fcn_type result = 0;
+  Array<FloatComplex>::compare_fcn_type result = nullptr;
 
   if (allow_chk)
     {
       octave_idx_type k = 0;
       for (; k < a.numel () && ! octave::math::isnan (a(k)); k++) ;
       if (k == a.numel ())
         {
           if (mode == ASCENDING)
diff --git a/liboctave/array/Array-util.cc b/liboctave/array/Array-util.cc
--- a/liboctave/array/Array-util.cc
+++ b/liboctave/array/Array-util.cc
@@ -261,17 +261,17 @@ freeze (Array<idx_vector>& ra_idx, const
   dim_vector retval;
 
   int n = ra_idx.numel ();
 
   assert (n == dimensions.ndims ());
 
   retval.resize (n);
 
-  static const char *tag[3] = { "row", "column", 0 };
+  static const char *tag[3] = { "row", "column", nullptr };
 
   for (int i = 0; i < n; i++)
     retval(i) = ra_idx(i).freeze (dimensions(i), tag[i < 2 ? i : 2],
                                   resize_ok);
 
   return retval;
 }
 
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -625,17 +625,17 @@ class rec_resize_helper
 {
   octave_idx_type *cext;
   octave_idx_type *sext;
   octave_idx_type *dext;
   int n;
 
 public:
   rec_resize_helper (const dim_vector& ndv, const dim_vector& odv)
-    : cext (0), sext (0), dext (0), n (0)
+    : cext (nullptr), sext (nullptr), dext (nullptr), n (0)
   {
     int l = ndv.ndims ();
     assert (odv.ndims () == l);
     octave_idx_type ld = 1;
     int i = 0;
     for (; i < l-1 && ndv(i) == odv(i); i++) ld *= ndv(i);
     n = l - i;
     cext = new octave_idx_type [3*n];
diff --git a/liboctave/array/Array.h b/liboctave/array/Array.h
--- a/liboctave/array/Array.h
+++ b/liboctave/array/Array.h
@@ -572,17 +572,17 @@ public:
 
   OCTAVE_DEPRECATED (4.4, "use 'isvector' instead")
   bool is_vector (void) const
   { return isvector (); }
 
   bool is_nd_vector (void) const { return dimensions.is_nd_vector (); }
 
   Array<T> transpose (void) const;
-  Array<T> hermitian (T (*fcn) (const T&) = 0) const;
+  Array<T> hermitian (T (*fcn) (const T&) = nullptr) const;
 
   const T * data (void) const { return slice_data; }
 
   const T * fortran_vec (void) const { return data (); }
 
   T * fortran_vec (void);
 
   bool is_shared (void) { return rep->count > 1; }
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -2071,32 +2071,32 @@ ComplexMatrix::fsolve (MatrixType& matty
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType& mattype, const Matrix& b) const
 {
   octave_idx_type info;
   double rcon;
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType& mattype, const Matrix& b,
                       octave_idx_type& info) const
 {
   double rcon;
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType& mattype, const Matrix& b,
                       octave_idx_type& info, double& rcon) const
 {
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType& mattype, const Matrix& b,
                       octave_idx_type& info, double& rcon,
                       solve_singularity_handler sing_handler,
                       bool singular_fallback, blas_trans_type transt) const
 {
@@ -2105,32 +2105,32 @@ ComplexMatrix::solve (MatrixType& mattyp
                 transt);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType& mattype, const ComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcon;
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType& mattype, const ComplexMatrix& b,
                       octave_idx_type& info) const
 {
   double rcon;
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType& mattype, const ComplexMatrix& b,
                       octave_idx_type& info, double& rcon) const
 {
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType& mattype, const ComplexMatrix& b,
                       octave_idx_type& info, double& rcon,
                       solve_singularity_handler sing_handler,
                       bool singular_fallback, blas_trans_type transt) const
 {
@@ -2166,32 +2166,32 @@ ComplexMatrix::solve (MatrixType& mattyp
   return retval;
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType& mattype, const ColumnVector& b) const
 {
   octave_idx_type info;
   double rcon;
-  return solve (mattype, ComplexColumnVector (b), info, rcon, 0);
+  return solve (mattype, ComplexColumnVector (b), info, rcon, nullptr);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType& mattype, const ColumnVector& b,
                       octave_idx_type& info) const
 {
   double rcon;
-  return solve (mattype, ComplexColumnVector (b), info, rcon, 0);
+  return solve (mattype, ComplexColumnVector (b), info, rcon, nullptr);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType& mattype, const ColumnVector& b,
                       octave_idx_type& info, double& rcon) const
 {
-  return solve (mattype, ComplexColumnVector (b), info, rcon, 0);
+  return solve (mattype, ComplexColumnVector (b), info, rcon, nullptr);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType& mattype, const ColumnVector& b,
                       octave_idx_type& info, double& rcon,
                       solve_singularity_handler sing_handler,
                       blas_trans_type transt) const
 {
@@ -2199,32 +2199,32 @@ ComplexMatrix::solve (MatrixType& mattyp
                 transt);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType& mattype, const ComplexColumnVector& b) const
 {
   octave_idx_type info;
   double rcon;
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType& mattype, const ComplexColumnVector& b,
                       octave_idx_type& info) const
 {
   double rcon;
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType& mattype, const ComplexColumnVector& b,
                       octave_idx_type& info, double& rcon) const
 {
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType& mattype, const ComplexColumnVector& b,
                       octave_idx_type& info, double& rcon,
                       solve_singularity_handler sing_handler,
                       blas_trans_type transt) const
 {
@@ -2234,62 +2234,62 @@ ComplexMatrix::solve (MatrixType& mattyp
   return tmp.column (static_cast<octave_idx_type> (0));
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const Matrix& b) const
 {
   octave_idx_type info;
   double rcon;
-  return solve (b, info, rcon, 0);
+  return solve (b, info, rcon, nullptr);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const Matrix& b, octave_idx_type& info) const
 {
   double rcon;
-  return solve (b, info, rcon, 0);
+  return solve (b, info, rcon, nullptr);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const Matrix& b, octave_idx_type& info,
                       double& rcon) const
 {
-  return solve (b, info, rcon, 0);
+  return solve (b, info, rcon, nullptr);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const Matrix& b, octave_idx_type& info, double& rcon,
                       solve_singularity_handler sing_handler,
                       blas_trans_type transt) const
 {
   ComplexMatrix tmp (b);
   return solve (tmp, info, rcon, sing_handler, transt);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const ComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcon;
-  return solve (b, info, rcon, 0);
+  return solve (b, info, rcon, nullptr);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const ComplexMatrix& b, octave_idx_type& info) const
 {
   double rcon;
-  return solve (b, info, rcon, 0);
+  return solve (b, info, rcon, nullptr);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const ComplexMatrix& b, octave_idx_type& info,
                       double& rcon) const
 {
-  return solve (b, info, rcon, 0);
+  return solve (b, info, rcon, nullptr);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const ComplexMatrix& b, octave_idx_type& info,
                       double& rcon,
                       solve_singularity_handler sing_handler,
                       blas_trans_type transt) const
 {
@@ -2297,62 +2297,62 @@ ComplexMatrix::solve (const ComplexMatri
   return solve (mattype, b, info, rcon, sing_handler, true, transt);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ColumnVector& b) const
 {
   octave_idx_type info;
   double rcon;
-  return solve (ComplexColumnVector (b), info, rcon, 0);
+  return solve (ComplexColumnVector (b), info, rcon, nullptr);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info) const
 {
   double rcon;
-  return solve (ComplexColumnVector (b), info, rcon, 0);
+  return solve (ComplexColumnVector (b), info, rcon, nullptr);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info,
                       double& rcon) const
 {
-  return solve (ComplexColumnVector (b), info, rcon, 0);
+  return solve (ComplexColumnVector (b), info, rcon, nullptr);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info,
                       double& rcon,
                       solve_singularity_handler sing_handler,
                       blas_trans_type transt) const
 {
   return solve (ComplexColumnVector (b), info, rcon, sing_handler, transt);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ComplexColumnVector& b) const
 {
   octave_idx_type info;
   double rcon;
-  return solve (b, info, rcon, 0);
+  return solve (b, info, rcon, nullptr);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info) const
 {
   double rcon;
-  return solve (b, info, rcon, 0);
+  return solve (b, info, rcon, nullptr);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info,
                       double& rcon) const
 {
-  return solve (b, info, rcon, 0);
+  return solve (b, info, rcon, nullptr);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info,
                       double& rcon,
                       solve_singularity_handler sing_handler,
                       blas_trans_type transt) const
 {
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -5674,17 +5674,17 @@ SparseComplexMatrix::fsolve (MatrixType&
           // Setup initial parameters
           CHOLMOD_NAME(start) (cm);
           cm->prefer_zomplex = false;
 
           double spu = octave_sparse_params::get_key ("spumoni");
           if (spu == 0.)
             {
               cm->print = -1;
-              SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, 0);
+              SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, nullptr);
             }
           else
             {
               cm->print = static_cast<int> (spu) + 2;
               SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, &SparseCholPrint);
             }
 
           cm->error_handler = &SparseCholError;
@@ -5926,17 +5926,17 @@ SparseComplexMatrix::fsolve (MatrixType&
           // Setup initial parameters
           CHOLMOD_NAME(start) (cm);
           cm->prefer_zomplex = false;
 
           double spu = octave_sparse_params::get_key ("spumoni");
           if (spu == 0.)
             {
               cm->print = -1;
-              SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, 0);
+              SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, nullptr);
             }
           else
             {
               cm->print = static_cast<int> (spu) + 2;
               SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, &SparseCholPrint);
             }
 
           cm->error_handler = &SparseCholError;
@@ -6227,17 +6227,17 @@ SparseComplexMatrix::fsolve (MatrixType&
           // Setup initial parameters
           CHOLMOD_NAME(start) (cm);
           cm->prefer_zomplex = false;
 
           double spu = octave_sparse_params::get_key ("spumoni");
           if (spu == 0.)
             {
               cm->print = -1;
-              SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, 0);
+              SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, nullptr);
             }
           else
             {
               cm->print = static_cast<int> (spu) + 2;
               SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, &SparseCholPrint);
             }
 
           cm->error_handler = &SparseCholError;
@@ -6458,17 +6458,17 @@ SparseComplexMatrix::fsolve (MatrixType&
           // Setup initial parameters
           CHOLMOD_NAME(start) (cm);
           cm->prefer_zomplex = false;
 
           double spu = octave_sparse_params::get_key ("spumoni");
           if (spu == 0.)
             {
               cm->print = -1;
-              SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, 0);
+              SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, nullptr);
             }
           else
             {
               cm->print = static_cast<int> (spu) + 2;
               SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, &SparseCholPrint);
             }
 
           cm->error_handler = &SparseCholError;
diff --git a/liboctave/array/DiagArray2.h b/liboctave/array/DiagArray2.h
--- a/liboctave/array/DiagArray2.h
+++ b/liboctave/array/DiagArray2.h
@@ -151,17 +151,17 @@ public:
 
   void resize (octave_idx_type n, octave_idx_type m, const T& rfv);
   void resize (octave_idx_type n, octave_idx_type m)
   {
     resize (n, m, Array<T>::resize_fill_value ());
   }
 
   DiagArray2<T> transpose (void) const;
-  DiagArray2<T> hermitian (T (*fcn) (const T&) = 0) const;
+  DiagArray2<T> hermitian (T (*fcn) (const T&) = nullptr) const;
 
   Array<T> array_value (void) const;
 
   const T * data (void) const { return Array<T>::data (); }
 
   const T * fortran_vec (void) const { return Array<T>::fortran_vec (); }
 
   T * fortran_vec (void) { return Array<T>::fortran_vec (); }
diff --git a/liboctave/array/MArray.h b/liboctave/array/MArray.h
--- a/liboctave/array/MArray.h
+++ b/liboctave/array/MArray.h
@@ -98,17 +98,17 @@ public:
   MArray<T> ipermute (const Array<octave_idx_type>& vec) const
   { return Array<T>::ipermute (vec); }
 
   MArray squeeze (void) const { return Array<T>::squeeze (); }
 
   MArray<T> transpose (void) const
   { return Array<T>::transpose (); }
 
-  MArray<T> hermitian (T (*fcn) (const T&) = 0) const
+  MArray<T> hermitian (T (*fcn) (const T&) = nullptr) const
   { return Array<T>::hermitian (fcn); }
 
   //! Performs indexed accumulative addition.
   //@{
   void idx_add (const idx_vector& idx, T val);
   void idx_add (const idx_vector& idx, const MArray<T>& vals);
   //@}
 
diff --git a/liboctave/array/MDiagArray2.h b/liboctave/array/MDiagArray2.h
--- a/liboctave/array/MDiagArray2.h
+++ b/liboctave/array/MDiagArray2.h
@@ -96,17 +96,17 @@ public:
     return std::count_if (d, d + nel,
                           [zero] (T elem) { return elem != zero; });
   }
 
   MArray<T> diag (octave_idx_type k = 0) const
   { return DiagArray2<T>::extract_diag (k); }
 
   MDiagArray2<T> transpose (void) const { return DiagArray2<T>::transpose (); }
-  MDiagArray2<T> hermitian (T (*fcn) (const T&) = 0) const
+  MDiagArray2<T> hermitian (T (*fcn) (const T&) = nullptr) const
   { return DiagArray2<T>::hermitian (fcn); }
 
   bool is_multiple_of_identity (T val) const;
 
   // Currently, the OPS functions don't need to be friends, but that
   // may change.
 
   friend MDiagArray2<T> operator + <> (const MDiagArray2<T>&);
diff --git a/liboctave/array/MatrixType.cc b/liboctave/array/MatrixType.cc
--- a/liboctave/array/MatrixType.cc
+++ b/liboctave/array/MatrixType.cc
@@ -60,22 +60,22 @@ warn_calculating_sparse_type (void)
 }
 
 // FIXME: There is a large code duplication here
 
 MatrixType::MatrixType (void)
   : typ (MatrixType::Unknown),
     sp_bandden (octave_sparse_params::get_bandden ()),
     bandden (0), upper_band (0),
-    lower_band (0), dense (false), full (false), nperm (0), perm (0) { }
+    lower_band (0), dense (false), full (false), nperm (0), perm (nullptr) { }
 
 MatrixType::MatrixType (const MatrixType& a)
   : typ (a.typ), sp_bandden (a.sp_bandden), bandden (a.bandden),
     upper_band (a.upper_band), lower_band (a.lower_band),
-    dense (a.dense), full (a.full), nperm (a.nperm), perm (0)
+    dense (a.dense), full (a.full), nperm (a.nperm), perm (nullptr)
 {
   if (nperm != 0)
     {
       perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = a.perm[i];
     }
 }
@@ -195,51 +195,51 @@ matrix_complex_probe (const MArray<std::
     typ = MatrixType::Rectangular;
 
   return typ;
 }
 
 MatrixType::MatrixType (const Matrix& a)
   : typ (MatrixType::Unknown),
     sp_bandden (0), bandden (0), upper_band (0), lower_band (0),
-    dense (false), full (true), nperm (0), perm (0)
+    dense (false), full (true), nperm (0), perm (nullptr)
 {
   typ = matrix_real_probe (a);
 }
 
 MatrixType::MatrixType (const ComplexMatrix& a)
   : typ (MatrixType::Unknown),
     sp_bandden (0), bandden (0), upper_band (0), lower_band (0),
-    dense (false), full (true), nperm (0), perm (0)
+    dense (false), full (true), nperm (0), perm (nullptr)
 {
   typ = matrix_complex_probe (a);
 }
 
 MatrixType::MatrixType (const FloatMatrix& a)
   : typ (MatrixType::Unknown),
     sp_bandden (0), bandden (0), upper_band (0), lower_band (0),
-    dense (false), full (true), nperm (0), perm (0)
+    dense (false), full (true), nperm (0), perm (nullptr)
 {
   typ = matrix_real_probe (a);
 }
 
 MatrixType::MatrixType (const FloatComplexMatrix& a)
   : typ (MatrixType::Unknown),
     sp_bandden (0), bandden (0), upper_band (0), lower_band (0),
-    dense (false), full (true), nperm (0), perm (0)
+    dense (false), full (true), nperm (0), perm (nullptr)
 {
   typ = matrix_complex_probe (a);
 }
 
 
 template <typename T>
 MatrixType::MatrixType (const MSparse<T>& a)
   : typ (MatrixType::Unknown),
     sp_bandden (0), bandden (0), upper_band (0), lower_band (0),
-    dense (false), full (false), nperm (0), perm (0)
+    dense (false), full (false), nperm (0), perm (nullptr)
 {
   octave_idx_type nrows = a.rows ();
   octave_idx_type ncols = a.cols ();
   octave_idx_type nm = (ncols < nrows ? ncols : nrows);
   octave_idx_type nnz = a.nnz ();
 
   if (octave_sparse_params::get_key ("spumoni") != 0.)
     warn_calculating_sparse_type ();
@@ -553,54 +553,54 @@ MatrixType::MatrixType (const MSparse<T>
     }
 }
 
 
 MatrixType::MatrixType (const matrix_type t, bool _full)
   : typ (MatrixType::Unknown),
     sp_bandden (octave_sparse_params::get_bandden ()),
     bandden (0), upper_band (0), lower_band (0),
-    dense (false), full (_full), nperm (0), perm (0)
+    dense (false), full (_full), nperm (0), perm (nullptr)
 {
   if (t == MatrixType::Unknown || t == MatrixType::Full
       || t == MatrixType::Diagonal || t == MatrixType::Permuted_Diagonal
       || t == MatrixType::Upper || t == MatrixType::Lower
       || t == MatrixType::Tridiagonal || t == MatrixType::Tridiagonal_Hermitian
       || t == MatrixType::Rectangular)
     typ = t;
   else
     warn_invalid ();
 }
 
 MatrixType::MatrixType (const matrix_type t, const octave_idx_type np,
                         const octave_idx_type *p, bool _full)
   : typ (MatrixType::Unknown),
     sp_bandden (octave_sparse_params::get_bandden ()),
     bandden (0), upper_band (0), lower_band (0),
-    dense (false), full (_full), nperm (0), perm (0)
+    dense (false), full (_full), nperm (0), perm (nullptr)
 {
   if ((t == MatrixType::Permuted_Upper || t == MatrixType::Permuted_Lower)
-      && np > 0 && p != 0)
+      && np > 0 && p != nullptr)
     {
       typ = t;
       nperm = np;
       perm = new octave_idx_type [nperm];
       for (octave_idx_type i = 0; i < nperm; i++)
         perm[i] = p[i];
     }
   else
     warn_invalid ();
 }
 
 MatrixType::MatrixType (const matrix_type t, const octave_idx_type ku,
                         const octave_idx_type kl, bool _full)
   : typ (MatrixType::Unknown),
     sp_bandden (octave_sparse_params::get_bandden ()),
     bandden (0), upper_band (0), lower_band (0),
-    dense (false), full (_full), nperm (0), perm (0)
+    dense (false), full (_full), nperm (0), perm (nullptr)
 {
   if (t == MatrixType::Banded || t == MatrixType::Banded_Hermitian)
     {
       typ = t;
       upper_band = ku;
       lower_band = kl;
     }
   else
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -201,17 +201,17 @@ Sparse<T>::SparseRep::any_element_is_nan
     if (octave::math::isnan (d[i]))
       return true;
 
   return false;
 }
 
 template <typename T>
 Sparse<T>::Sparse (octave_idx_type nr, octave_idx_type nc, T val)
-  : rep (0), dimensions (dim_vector (nr, nc))
+  : rep (nullptr), dimensions (dim_vector (nr, nc))
 {
   if (val != T ())
     {
       rep = new typename Sparse<T>::SparseRep (nr, nc, dimensions.safe_numel ());
 
       octave_idx_type ii = 0;
       xcidx (0) = 0;
       for (octave_idx_type j = 0; j < nc; j++)
@@ -229,28 +229,28 @@ Sparse<T>::Sparse (octave_idx_type nr, o
       rep = new typename Sparse<T>::SparseRep (nr, nc, 0);
       for (octave_idx_type j = 0; j < nc+1; j++)
         xcidx (j) = 0;
     }
 }
 
 template <typename T>
 Sparse<T>::Sparse (const dim_vector& dv)
-  : rep (0), dimensions (dv)
+  : rep (nullptr), dimensions (dv)
 {
   if (dv.ndims () != 2)
     (*current_liboctave_error_handler)
       ("Sparse::Sparse (const dim_vector&): dimension mismatch");
 
   rep = new typename Sparse<T>::SparseRep (dv(0), dv(1), 0);
 }
 
 template <typename T>
 Sparse<T>::Sparse (const Sparse<T>& a, const dim_vector& dv)
-  : rep (0), dimensions (dv)
+  : rep (nullptr), dimensions (dv)
 {
 
   // Work in unsigned long long to avoid overflow issues with numel
   unsigned long long a_nel = static_cast<unsigned long long>(a.rows ()) *
                              static_cast<unsigned long long>(a.cols ());
   unsigned long long dv_nel = static_cast<unsigned long long>(dv(0)) *
                               static_cast<unsigned long long>(dv(1));
 
@@ -285,17 +285,17 @@ Sparse<T>::Sparse (const Sparse<T>& a, c
     xcidx (k+1) = new_nzmx;
 }
 
 template <typename T>
 Sparse<T>::Sparse (const Array<T>& a, const idx_vector& r,
                    const idx_vector& c, octave_idx_type nr,
                    octave_idx_type nc, bool sum_terms,
                    octave_idx_type nzm)
-  : rep (0), dimensions ()
+  : rep (nullptr), dimensions ()
 {
   if (nr < 0)
     nr = r.extent (0);
   else if (r.extent (nr) > nr)
     (*current_liboctave_error_handler) ("sparse: row index %d out of bound %d",
                                         r.extent (nr), nr);
 
   if (nc < 0)
@@ -642,17 +642,17 @@ Sparse<T>::Sparse (const Array<T>& a, co
         }
 
       maybe_compress (true);
     }
 }
 
 template <typename T>
 Sparse<T>::Sparse (const Array<T>& a)
-  : rep (0), dimensions (a.dims ())
+  : rep (nullptr), dimensions (a.dims ())
 {
   if (dimensions.ndims () > 2)
     (*current_liboctave_error_handler)
       ("Sparse::Sparse (const Array<T>&): dimension mismatch");
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type len = a.numel ();
diff --git a/liboctave/array/Sparse.h b/liboctave/array/Sparse.h
--- a/liboctave/array/Sparse.h
+++ b/liboctave/array/Sparse.h
@@ -73,18 +73,18 @@ protected:
     { }
 
     SparseRep (octave_idx_type n)
       : d (0), r (0), c (new octave_idx_type [n+1] {}), nzmx (0), nrows (n),
         ncols (n), count (1)
     { }
 
     SparseRep (octave_idx_type nr, octave_idx_type nc, octave_idx_type nz = 0)
-      : d (nz > 0 ? new T [nz] {} : 0),
-        r (nz > 0 ? new octave_idx_type [nz] {} : 0),
+      : d (nz > 0 ? new T [nz] {} : nullptr),
+        r (nz > 0 ? new octave_idx_type [nz] {} : nullptr),
         c (new octave_idx_type [nc+1] {}), nzmx (nz), nrows (nr),
         ncols (nc), count (1)
     { }
 
     SparseRep (const SparseRep& a)
       : d (new T [a.nzmx]), r (new octave_idx_type [a.nzmx]),
         c (new octave_idx_type [a.ncols + 1]),
         nzmx (a.nzmx), nrows (a.nrows), ncols (a.ncols), count (1)
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -1736,32 +1736,32 @@ Matrix::fsolve (MatrixType& mattype, con
   return retval;
 }
 
 Matrix
 Matrix::solve (MatrixType& mattype, const Matrix& b) const
 {
   octave_idx_type info;
   double rcon;
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 Matrix
 Matrix::solve (MatrixType& mattype, const Matrix& b,
                octave_idx_type& info) const
 {
   double rcon;
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 Matrix
 Matrix::solve (MatrixType& mattype, const Matrix& b, octave_idx_type& info,
                double& rcon) const
 {
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 Matrix
 Matrix::solve (MatrixType& mattype, const Matrix& b, octave_idx_type& info,
                double& rcon, solve_singularity_handler sing_handler,
                bool singular_fallback, blas_trans_type transt) const
 {
   Matrix retval;
@@ -1793,32 +1793,32 @@ Matrix::solve (MatrixType& mattype, cons
   return retval;
 }
 
 ComplexMatrix
 Matrix::solve (MatrixType& mattype, const ComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcon;
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 ComplexMatrix
 Matrix::solve (MatrixType& mattype, const ComplexMatrix& b,
                octave_idx_type& info) const
 {
   double rcon;
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 ComplexMatrix
 Matrix::solve (MatrixType& mattype, const ComplexMatrix& b,
                octave_idx_type& info, double& rcon) const
 {
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 static Matrix
 stack_complex_matrix (const ComplexMatrix& cm)
 {
   octave_idx_type m = cm.rows ();
   octave_idx_type n = cm.cols ();
   octave_idx_type nel = m*n;
@@ -1873,17 +1873,17 @@ Matrix::solve (MatrixType& mattype, cons
   double rcon;
   return solve (mattype, b, info, rcon);
 }
 
 ColumnVector
 Matrix::solve (MatrixType& mattype, const ColumnVector& b,
                octave_idx_type& info, double& rcon) const
 {
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 ColumnVector
 Matrix::solve (MatrixType& mattype, const ColumnVector& b,
                octave_idx_type& info, double& rcon,
                solve_singularity_handler sing_handler,
                blas_trans_type transt) const
 {
@@ -1925,30 +1925,30 @@ Matrix::solve (MatrixType& mattype, cons
   return tmp.solve (mattype, b, info, rcon, sing_handler, transt);
 }
 
 Matrix
 Matrix::solve (const Matrix& b) const
 {
   octave_idx_type info;
   double rcon;
-  return solve (b, info, rcon, 0);
+  return solve (b, info, rcon, nullptr);
 }
 
 Matrix
 Matrix::solve (const Matrix& b, octave_idx_type& info) const
 {
   double rcon;
-  return solve (b, info, rcon, 0);
+  return solve (b, info, rcon, nullptr);
 }
 
 Matrix
 Matrix::solve (const Matrix& b, octave_idx_type& info, double& rcon) const
 {
-  return solve (b, info, rcon, 0);
+  return solve (b, info, rcon, nullptr);
 }
 
 Matrix
 Matrix::solve (const Matrix& b, octave_idx_type& info,
                double& rcon, solve_singularity_handler sing_handler,
                blas_trans_type transt) const
 {
   MatrixType mattype (*this);
@@ -1998,17 +1998,17 @@ Matrix::solve (const ColumnVector& b, oc
 {
   double rcon;
   return solve (b, info, rcon);
 }
 
 ColumnVector
 Matrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcon) const
 {
-  return solve (b, info, rcon, 0);
+  return solve (b, info, rcon, nullptr);
 }
 
 ColumnVector
 Matrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcon,
                solve_singularity_handler sing_handler,
                blas_trans_type transt) const
 {
   MatrixType mattype (*this);
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -5725,17 +5725,17 @@ SparseMatrix::fsolve (MatrixType& mattyp
           // Setup initial parameters
           CHOLMOD_NAME(start) (cm);
           cm->prefer_zomplex = false;
 
           double spu = octave_sparse_params::get_key ("spumoni");
           if (spu == 0.)
             {
               cm->print = -1;
-              SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, 0);
+              SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, nullptr);
             }
           else
             {
               cm->print = static_cast<int> (spu) + 2;
               SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, &SparseCholPrint);
             }
 
           cm->error_handler = &SparseCholError;
@@ -5950,17 +5950,17 @@ SparseMatrix::fsolve (MatrixType& mattyp
           // Setup initial parameters
           CHOLMOD_NAME(start) (cm);
           cm->prefer_zomplex = false;
 
           double spu = octave_sparse_params::get_key ("spumoni");
           if (spu == 0.)
             {
               cm->print = -1;
-              SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, 0);
+              SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, nullptr);
             }
           else
             {
               cm->print = static_cast<int> (spu) + 2;
               SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, &SparseCholPrint);
             }
 
           cm->error_handler = &SparseCholError;
@@ -6221,17 +6221,17 @@ SparseMatrix::fsolve (MatrixType& mattyp
           // Setup initial parameters
           CHOLMOD_NAME(start) (cm);
           cm->prefer_zomplex = false;
 
           double spu = octave_sparse_params::get_key ("spumoni");
           if (spu == 0.)
             {
               cm->print = -1;
-              SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, 0);
+              SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, nullptr);
             }
           else
             {
               cm->print = static_cast<int> (spu) + 2;
               SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, &SparseCholPrint);
             }
 
           cm->error_handler = &SparseCholError;
@@ -6466,17 +6466,17 @@ SparseMatrix::fsolve (MatrixType& mattyp
           // Setup initial parameters
           CHOLMOD_NAME(start) (cm);
           cm->prefer_zomplex = false;
 
           double spu = octave_sparse_params::get_key ("spumoni");
           if (spu == 0.)
             {
               cm->print = -1;
-              SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, 0);
+              SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, nullptr);
             }
           else
             {
               cm->print = static_cast<int> (spu) + 2;
               SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, &SparseCholPrint);
             }
 
           cm->error_handler = &SparseCholError;
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -1752,32 +1752,32 @@ FloatMatrix::fsolve (MatrixType& mattype
   return retval;
 }
 
 FloatMatrix
 FloatMatrix::solve (MatrixType& mattype, const FloatMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 FloatMatrix
 FloatMatrix::solve (MatrixType& mattype, const FloatMatrix& b,
                     octave_idx_type& info) const
 {
   float rcon;
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 FloatMatrix
 FloatMatrix::solve (MatrixType& mattype, const FloatMatrix& b,
                     octave_idx_type& info, float& rcon) const
 {
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 FloatMatrix
 FloatMatrix::solve (MatrixType& mattype, const FloatMatrix& b,
                     octave_idx_type& info,
                     float& rcon, solve_singularity_handler sing_handler,
                     bool singular_fallback, blas_trans_type transt) const
 {
@@ -1810,33 +1810,33 @@ FloatMatrix::solve (MatrixType& mattype,
   return retval;
 }
 
 FloatComplexMatrix
 FloatMatrix::solve (MatrixType& mattype, const FloatComplexMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 FloatComplexMatrix
 FloatMatrix::solve (MatrixType& mattype, const FloatComplexMatrix& b,
                     octave_idx_type& info) const
 {
   float rcon;
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 FloatComplexMatrix
 FloatMatrix::solve (MatrixType& mattype, const FloatComplexMatrix& b,
                     octave_idx_type& info,
                     float& rcon) const
 {
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 static FloatMatrix
 stack_complex_matrix (const FloatComplexMatrix& cm)
 {
   octave_idx_type m = cm.rows ();
   octave_idx_type n = cm.cols ();
   octave_idx_type nel = m*n;
@@ -1893,17 +1893,17 @@ FloatMatrix::solve (MatrixType& mattype,
   return solve (mattype, b, info, rcon);
 }
 
 FloatColumnVector
 FloatMatrix::solve (MatrixType& mattype, const FloatColumnVector& b,
                     octave_idx_type& info,
                     float& rcon) const
 {
-  return solve (mattype, b, info, rcon, 0);
+  return solve (mattype, b, info, rcon, nullptr);
 }
 
 FloatColumnVector
 FloatMatrix::solve (MatrixType& mattype, const FloatColumnVector& b,
                     octave_idx_type& info,
                     float& rcon, solve_singularity_handler sing_handler,
                     blas_trans_type transt) const
 {
@@ -1946,31 +1946,31 @@ FloatMatrix::solve (MatrixType& mattype,
   return tmp.solve (mattype, b, info, rcon, sing_handler, transt);
 }
 
 FloatMatrix
 FloatMatrix::solve (const FloatMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
-  return solve (b, info, rcon, 0);
+  return solve (b, info, rcon, nullptr);
 }
 
 FloatMatrix
 FloatMatrix::solve (const FloatMatrix& b, octave_idx_type& info) const
 {
   float rcon;
-  return solve (b, info, rcon, 0);
+  return solve (b, info, rcon, nullptr);
 }
 
 FloatMatrix
 FloatMatrix::solve (const FloatMatrix& b, octave_idx_type& info,
                     float& rcon) const
 {
-  return solve (b, info, rcon, 0);
+  return solve (b, info, rcon, nullptr);
 }
 
 FloatMatrix
 FloatMatrix::solve (const FloatMatrix& b, octave_idx_type& info,
                     float& rcon, solve_singularity_handler sing_handler,
                     blas_trans_type transt) const
 {
   MatrixType mattype (*this);
@@ -2022,17 +2022,17 @@ FloatMatrix::solve (const FloatColumnVec
   float rcon;
   return solve (b, info, rcon);
 }
 
 FloatColumnVector
 FloatMatrix::solve (const FloatColumnVector& b, octave_idx_type& info,
                     float& rcon) const
 {
-  return solve (b, info, rcon, 0);
+  return solve (b, info, rcon, nullptr);
 }
 
 FloatColumnVector
 FloatMatrix::solve (const FloatColumnVector& b, octave_idx_type& info,
                     float& rcon, solve_singularity_handler sing_handler,
                     blas_trans_type transt) const
 {
   MatrixType mattype (*this);
diff --git a/liboctave/array/idx-vector.cc b/liboctave/array/idx-vector.cc
--- a/liboctave/array/idx-vector.cc
+++ b/liboctave/array/idx-vector.cc
@@ -311,17 +311,17 @@ Array<octave_idx_type>
 idx_vector::idx_scalar_rep::as_array (void)
 {
   return Array<octave_idx_type> (dim_vector (1, 1), data);
 }
 
 template <typename T>
 idx_vector::idx_vector_rep::idx_vector_rep (const Array<T>& nda)
   : idx_base_rep (), data (0), len (nda.numel ()), ext (0),
-    aowner (0), orig_dims (nda.dims ())
+    aowner (nullptr), orig_dims (nda.dims ())
 {
   if (len != 0)
     {
       std::unique_ptr<octave_idx_type []> d (new octave_idx_type [len]);
 
       for (octave_idx_type i = 0; i < len; i++)
         d[i] = convert_index (nda.xelem (i), err, ext);
 
@@ -367,31 +367,31 @@ idx_vector::idx_vector_rep::idx_vector_r
         if (data[i] > max)
           max = data[i];
 
       ext = max + 1;
     }
 }
 
 idx_vector::idx_vector_rep::idx_vector_rep (bool b)
-  : idx_base_rep (), data (0), len (b ? 1 : 0), ext (0), aowner (0),
+  : idx_base_rep (), data (0), len (b ? 1 : 0), ext (0), aowner (nullptr),
     orig_dims (len, len)
 {
   if (len != 0)
     {
       octave_idx_type *d = new octave_idx_type [1];
       d[0] = 0;
       data = d;
       ext = 1;
     }
 }
 
 idx_vector::idx_vector_rep::idx_vector_rep (const Array<bool>& bnda,
                                             octave_idx_type nnz)
-  : idx_base_rep (), data (0), len (nnz), ext (0), aowner (0), orig_dims ()
+  : idx_base_rep (), data (0), len (nnz), ext (0), aowner (nullptr), orig_dims ()
 {
   if (nnz < 0)
     len = bnda.nnz ();
 
   const dim_vector dv = bnda.dims ();
 
   orig_dims = dv.make_nd_vector (len);
 
@@ -408,17 +408,17 @@ idx_vector::idx_vector_rep::idx_vector_r
 
       data = d;
 
       ext = d[k-1] + 1;
     }
 }
 
 idx_vector::idx_vector_rep::idx_vector_rep (const Sparse<bool>& bnda)
-  : idx_base_rep (), data (0), len (bnda.nnz ()), ext (0), aowner (0),
+  : idx_base_rep (), data (0), len (bnda.nnz ()), ext (0), aowner (nullptr),
     orig_dims ()
 {
   const dim_vector dv = bnda.dims ();
 
   orig_dims = dv.make_nd_vector (len);
 
   if (len != 0)
     {
@@ -462,17 +462,17 @@ idx_vector::idx_vector_rep::sort_uniq_cl
   if (len == 0)
     {
       count++;
       return this;
     }
 
   // This is wrapped in unique_ptr so that we don't leak on out-of-memory.
   std::unique_ptr<idx_vector_rep> new_rep (
-    new idx_vector_rep (0, len, ext, orig_dims, DIRECT));
+    new idx_vector_rep (nullptr, len, ext, orig_dims, DIRECT));
 
   if (ext > len*octave::math::log2 (1.0 + len))
     {
       // Use standard sort via octave_sort.
       octave_idx_type *new_data = new octave_idx_type [len];
       new_rep->data = new_data;
 
       std::copy_n (data, len, new_data);
@@ -535,17 +535,17 @@ idx_vector::idx_vector_rep::sort_uniq_cl
   return new_rep.release ();
 }
 
 idx_vector::idx_base_rep *
 idx_vector::idx_vector_rep::sort_idx (Array<octave_idx_type>& idx)
 {
   // This is wrapped in unique_ptr so that we don't leak on out-of-memory.
   std::unique_ptr<idx_vector_rep> new_rep (
-    new idx_vector_rep (0, len, ext, orig_dims, DIRECT));
+    new idx_vector_rep (nullptr, len, ext, orig_dims, DIRECT));
 
   if (ext > len*octave::math::log2 (1.0 + len))
     {
       // Use standard sort via octave_sort.
       idx.clear (orig_dims);
       octave_idx_type *idx_data = idx.fortran_vec ();
       for (octave_idx_type i = 0; i < len; i++)
         idx_data[i] = i;
@@ -636,31 +636,31 @@ idx_vector::idx_vector_rep::as_array (vo
       aowner = new Array<octave_idx_type> (retval);
 
       return retval;
     }
 }
 
 idx_vector::idx_mask_rep::idx_mask_rep (bool b)
   : idx_base_rep (), data (0), len (b ? 1 : 0), ext (0),
-    lsti (-1), lste (-1), aowner (0), orig_dims (len, len)
+    lsti (-1), lste (-1), aowner (nullptr), orig_dims (len, len)
 {
   if (len != 0)
     {
       bool *d = new bool [1];
       d[0] = true;
       data = d;
       ext = 1;
     }
 }
 
 idx_vector::idx_mask_rep::idx_mask_rep (const Array<bool>& bnda,
                                         octave_idx_type nnz)
   : idx_base_rep (), data (0), len (nnz), ext (bnda.numel ()),
-    lsti (-1), lste (-1), aowner (0), orig_dims ()
+    lsti (-1), lste (-1), aowner (nullptr), orig_dims ()
 {
   if (nnz < 0)
     len = bnda.nnz ();
 
   // We truncate the extent as much as possible.  For Matlab
   // compatibility, but maybe it's not a bad idea anyway.
   while (ext > 0 && ! bnda(ext-1))
     ext--;
@@ -763,17 +763,17 @@ idx_vector::idx_mask_rep::sort_idx (Arra
 
   count++;
   return this;
 }
 
 const idx_vector idx_vector::colon (new idx_vector::idx_colon_rep ());
 
 idx_vector::idx_vector (const Array<bool>& bnda)
-  : rep (0)
+  : rep (nullptr)
 {
   // Convert only if it means saving at least half the memory.
   static const int factor = (2 * sizeof (octave_idx_type));
   octave_idx_type nnz = bnda.nnz ();
   if (nnz <= bnda.numel () / factor)
     rep = new idx_vector_rep (bnda, nnz);
   else
     rep = new idx_mask_rep (bnda, nnz);
@@ -1035,17 +1035,17 @@ idx_vector::increment (void) const
 const octave_idx_type *
 idx_vector::raw (void)
 {
   if (rep->idx_class () != class_vector)
     *this = idx_vector (as_array (), extent (0));
 
   idx_vector_rep *r = dynamic_cast<idx_vector_rep *> (rep);
 
-  assert (r != 0);
+  assert (r != nullptr);
 
   return r->get_data ();
 }
 
 void
 idx_vector::copy_data (octave_idx_type *data) const
 {
   octave_idx_type len = rep->length (0);
diff --git a/liboctave/array/idx-vector.h b/liboctave/array/idx-vector.h
--- a/liboctave/array/idx-vector.h
+++ b/liboctave/array/idx-vector.h
@@ -277,24 +277,24 @@ private:
   };
 
   // The integer vector index.
   class OCTAVE_API idx_vector_rep : public idx_base_rep
   {
   public:
 
     idx_vector_rep (void)
-      : data (0), len (0), ext (0), aowner (0), orig_dims ()
+      : data (0), len (0), ext (0), aowner (nullptr), orig_dims ()
     { }
 
     // Direct constructor.
     idx_vector_rep (octave_idx_type *_data, octave_idx_type _len,
                     octave_idx_type _ext, const dim_vector& od, direct)
       : idx_base_rep (), data (_data), len (_len), ext (_ext),
-        aowner (0), orig_dims (od)
+        aowner (nullptr), orig_dims (od)
     { }
 
     // Zero-based constructor.
     idx_vector_rep (const Array<octave_idx_type>& inda);
 
     idx_vector_rep (const Array<octave_idx_type>& inda,
                     octave_idx_type _ext, direct);
 
@@ -364,17 +364,17 @@ private:
   public:
 
     idx_mask_rep (void) = delete;
 
     // Direct constructor.
     idx_mask_rep (bool *_data, octave_idx_type _len,
                   octave_idx_type _ext, const dim_vector& od, direct)
       : idx_base_rep (), data (_data), len (_len), ext (_ext),
-        lsti (-1), lste (-1), aowner (0), orig_dims (od)
+        lsti (-1), lste (-1), aowner (nullptr), orig_dims (od)
     { }
 
     idx_mask_rep (bool);
 
     idx_mask_rep (const Array<bool>&, octave_idx_type = -1);
 
     // No copying!
 
diff --git a/liboctave/numeric/DAEFunc.h b/liboctave/numeric/DAEFunc.h
--- a/liboctave/numeric/DAEFunc.h
+++ b/liboctave/numeric/DAEFunc.h
@@ -41,20 +41,20 @@ public:
   //
   //   PD = DG/DY + CJ * DG/DYPRIME
 
   typedef Matrix (*DAEJacFunc) (const ColumnVector& x,
                                 const ColumnVector& xdot,
                                 double t, double cj);
 
   DAEFunc (void)
-    : fun (0), jac (0), reset (true) { }
+    : fun (nullptr), jac (nullptr), reset (true) { }
 
   DAEFunc (DAERHSFunc f)
-    : fun (f), jac (0), reset (true) { }
+    : fun (f), jac (nullptr), reset (true) { }
 
   DAEFunc (DAERHSFunc f, DAEJacFunc j)
     : fun (f), jac (j), reset (true) { }
 
   DAEFunc (const DAEFunc& a)
     : fun (a.fun), jac (a.jac), reset (a.reset) { }
 
   DAEFunc& operator = (const DAEFunc& a)
diff --git a/liboctave/numeric/DAERTFunc.h b/liboctave/numeric/DAERTFunc.h
--- a/liboctave/numeric/DAERTFunc.h
+++ b/liboctave/numeric/DAERTFunc.h
@@ -30,23 +30,23 @@ along with Octave; see the file COPYING.
 class
 DAERTFunc : public DAEFunc
 {
 public:
 
   typedef ColumnVector (*DAERTConstrFunc) (const ColumnVector& x, double t);
 
   DAERTFunc (void)
-    : DAEFunc (), constr (0), reset (true) { }
+    : DAEFunc (), constr (nullptr), reset (true) { }
 
   DAERTFunc (DAERHSFunc f)
-    : DAEFunc (f), constr (0), reset (true) { }
+    : DAEFunc (f), constr (nullptr), reset (true) { }
 
   DAERTFunc (DAERHSFunc f, DAEJacFunc j)
-    : DAEFunc (f, j), constr (0), reset (true) { }
+    : DAEFunc (f, j), constr (nullptr), reset (true) { }
 
   DAERTFunc (DAERHSFunc f, DAERTConstrFunc cf)
     : DAEFunc (f), constr (cf), reset (true) { }
 
   DAERTFunc (DAERHSFunc f, DAERTConstrFunc cf, DAEJacFunc j)
     : DAEFunc (f, j), constr (cf), reset (true) { }
 
   DAERTFunc (const DAERTFunc& a)
diff --git a/liboctave/numeric/ODEFunc.h b/liboctave/numeric/ODEFunc.h
--- a/liboctave/numeric/ODEFunc.h
+++ b/liboctave/numeric/ODEFunc.h
@@ -32,20 +32,20 @@ class
 ODEFunc
 {
 public:
 
   typedef ColumnVector (*ODERHSFunc) (const ColumnVector&, double);
   typedef Matrix (*ODEJacFunc) (const ColumnVector&, double);
 
   ODEFunc (void)
-    : fun (0), jac (0), reset (true) { }
+    : fun (nullptr), jac (nullptr), reset (true) { }
 
   ODEFunc (ODERHSFunc f)
-    : fun (f), jac (0), reset (true) { }
+    : fun (f), jac (nullptr), reset (true) { }
 
   ODEFunc (ODERHSFunc f, ODEJacFunc j)
     : fun (f), jac (j), reset (true) { }
 
   ODEFunc (const ODEFunc& a)
     : fun (a.fun), jac (a.jac), reset (true) { }
 
   ODEFunc& operator = (const ODEFunc& a)
diff --git a/liboctave/numeric/ODESFunc.h b/liboctave/numeric/ODESFunc.h
--- a/liboctave/numeric/ODESFunc.h
+++ b/liboctave/numeric/ODESFunc.h
@@ -45,23 +45,23 @@ public:
 
   typedef ColumnVector (*ODES_bsub) (const ColumnVector& x, double,
                                      const ColumnVector& theta, int column);
 
   typedef Matrix (*ODES_jsub) (const ColumnVector& x, double,
                                const ColumnVector& theta);
 
   ODESFunc (void)
-    : fsub (0), bsub (0), jsub (0) { }
+    : fsub (nullptr), bsub (nullptr), jsub (nullptr) { }
 
   ODESFunc (ODES_fsub f)
-    : fsub (f), bsub (0), jsub (0) { }
+    : fsub (f), bsub (nullptr), jsub (nullptr) { }
 
   ODESFunc (ODES_fsub f, ODES_bsub b)
-    : fsub (f), bsub (b), jsub (0) { }
+    : fsub (f), bsub (b), jsub (nullptr) { }
 
   ODESFunc (ODES_fsub f, ODES_bsub b, ODES_jsub j)
     : fsub (f), bsub (b), jsub (j) { }
 
   ODESFunc (const ODESFunc& a)
     : fsub (a.fsub), bsub (a.bsub), jsub (a.jsub) { }
 
   ODESFunc& operator = (const ODESFunc& a)
diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -60,21 +60,21 @@ template <typename M, typename SM>
 static octave_idx_type
 lusolve (const SM& L, const SM& U, M& m)
 {
   octave_idx_type err = 0;
   double rcond;
   MatrixType utyp (MatrixType::Upper);
 
   // Sparse L is lower triangular, Dense L is permuted lower triangular!!!
-  m = L.solve (m, err, rcond, 0);
+  m = L.solve (m, err, rcond, nullptr);
   if (err)
     return err;
 
-  m = U.solve (utyp, m, err, rcond, 0);
+  m = U.solve (utyp, m, err, rcond, nullptr);
 
   return err;
 }
 
 template <typename SM, typename M>
 static M
 ltsolve (const SM& L, const ColumnVector& Q, const M& m)
 {
@@ -86,30 +86,30 @@ ltsolve (const SM& L, const ColumnVector
   MatrixType ltyp (MatrixType::Lower);
   M retval (n, b_nc);
   const double *qv = Q.fortran_vec ();
   for (octave_idx_type j = 0; j < b_nc; j++)
     {
       for (octave_idx_type i = 0; i < n; i++)
         retval.elem (i,j) = m.elem (static_cast<octave_idx_type>(qv[i]), j);
     }
-  return L.solve (ltyp, retval, err, rcond, 0);
+  return L.solve (ltyp, retval, err, rcond, nullptr);
 }
 
 template <typename SM, typename M>
 static M
 utsolve (const SM& U, const ColumnVector& Q, const M& m)
 {
   // Solve (U * Q_mat') * x = m by U * tmp = m, x(Q) = tmp (Q_mat * tmp = x)
   octave_idx_type n = U.cols ();
   octave_idx_type b_nc = m.cols ();
   octave_idx_type err = 0;
   double rcond;
   MatrixType utyp (MatrixType::Upper);
-  M tmp = U.solve (utyp, m, err, rcond, 0);
+  M tmp = U.solve (utyp, m, err, rcond, nullptr);
   M retval;
   const double *qv = Q.fortran_vec ();
 
   if (! err)
     {
       retval.resize (n, b_nc);
       for (octave_idx_type j = 0; j < b_nc; j++)
         {
diff --git a/liboctave/numeric/oct-fftw.cc b/liboctave/numeric/oct-fftw.cc
--- a/liboctave/numeric/oct-fftw.cc
+++ b/liboctave/numeric/oct-fftw.cc
@@ -58,20 +58,20 @@ namespace octave
 
   // FIXME: if we can ensure 16 byte alignment in Array<T>
   // (<T> *data) the FFTW3 can use SIMD instructions for further
   // acceleration.
 
   // Note that it is profitable to store the FFTW3 plans, for small FFTs.
 
   fftw_planner::fftw_planner (void)
-    : meth (ESTIMATE), rplan (0), rd (0), rs (0), rr (0), rh (0), rn (),
+    : meth (ESTIMATE), rplan (nullptr), rd (0), rs (0), rr (0), rh (0), rn (),
       rsimd_align (false), nthreads (1)
   {
-    plan[0] = plan[1] = 0;
+    plan[0] = plan[1] = nullptr;
     d[0] = d[1] = s[0] = s[1] = r[0] = r[1] = h[0] = h[1] = 0;
     simd_align[0] = simd_align[1] = false;
     inplace[0] = inplace[1] = false;
     n[0] = n[1] = dim_vector ();
 
 #if defined (HAVE_FFTW3_THREADS)
     int init_ret = fftw_init_threads ();
     if (! init_ret)
@@ -128,17 +128,17 @@ namespace octave
   fftw_planner::threads (int nt)
   {
 #if defined (HAVE_FFTW3_THREADS)
     if (instance_ok () && nt != threads ())
       {
         instance->nthreads = nt;
         fftw_plan_with_nthreads (nt);
         // Clear the current plans.
-        instance->rplan = instance->plan[0] = instance->plan[1] = 0;
+        instance->rplan = instance->plan[0] = instance->plan[1] = nullptr;
       }
 #else
     (*current_liboctave_warning_handler)
       ("unable to change number of threads without FFTW thread support");
 #endif
   }
 
 #define CHECK_SIMD_ALIGNMENT(x)                         \
@@ -157,17 +157,17 @@ namespace octave
     bool create_new_plan = false;
     bool ioalign = CHECK_SIMD_ALIGNMENT (in) && CHECK_SIMD_ALIGNMENT (out);
     bool ioinplace = (in == out);
 
     // Don't create a new plan if we have a non SIMD plan already but
     // can do SIMD.  This prevents endlessly recreating plans if we
     // change the alignment.
 
-    if (plan[which] == 0 || d[which] != dist || s[which] != stride
+    if (plan[which] == nullptr || d[which] != dist || s[which] != stride
         || r[which] != rank || h[which] != howmany
         || ioinplace != inplace[which]
         || ((ioalign != simd_align[which]) ? ! ioalign : false))
       create_new_plan = true;
     else
       {
         // We still might not have the same shape of array.
 
@@ -243,31 +243,31 @@ namespace octave
             OCTAVE_LOCAL_BUFFER (Complex, itmp, nn * howmany + 32);
             itmp = reinterpret_cast<Complex *>
               (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) +
                ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
 
             *cur_plan_p =
               fftw_plan_many_dft (rank, tmp, howmany,
                                   reinterpret_cast<fftw_complex *> (itmp),
-                                  0, stride, dist,
+                                  nullptr, stride, dist,
                                   reinterpret_cast<fftw_complex *> (out),
-                                  0, stride, dist, dir, plan_flags);
+                                  nullptr, stride, dist, dir, plan_flags);
           }
         else
           {
             *cur_plan_p =
               fftw_plan_many_dft (rank, tmp, howmany,
                                   reinterpret_cast<fftw_complex *> (const_cast<Complex *> (in)),
-                                  0, stride, dist,
+                                  nullptr, stride, dist,
                                   reinterpret_cast<fftw_complex *> (out),
-                                  0, stride, dist, dir, plan_flags);
+                                  nullptr, stride, dist, dir, plan_flags);
           }
 
-        if (*cur_plan_p == 0)
+        if (*cur_plan_p == nullptr)
           (*current_liboctave_error_handler) ("Error creating fftw plan");
       }
 
     return *cur_plan_p;
   }
 
   void *
   fftw_planner::do_create_plan (const int rank, const dim_vector& dims,
@@ -279,17 +279,17 @@ namespace octave
     fftw_plan *cur_plan_p = reinterpret_cast<fftw_plan *> (&rplan);
     bool create_new_plan = false;
     bool ioalign = CHECK_SIMD_ALIGNMENT (in) && CHECK_SIMD_ALIGNMENT (out);
 
     // Don't create a new plan if we have a non SIMD plan already but
     // can do SIMD.  This prevents endlessly recreating plans if we
     // change the alignment.
 
-    if (rplan == 0 || rd != dist || rs != stride || rr != rank
+    if (rplan == nullptr || rd != dist || rs != stride || rr != rank
         || rh != howmany || ((ioalign != rsimd_align) ? ! ioalign : false))
       create_new_plan = true;
     else
       {
         // We still might not have the same shape of array.
 
         for (int i = 0; i < rank; i++)
           if (dims(i) != rn(i))
@@ -361,31 +361,31 @@ namespace octave
             // Create matrix with the same size and 16-byte alignment as input
             OCTAVE_LOCAL_BUFFER (double, itmp, nn + 32);
             itmp = reinterpret_cast<double *>
               (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) +
                ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
 
             *cur_plan_p =
               fftw_plan_many_dft_r2c (rank, tmp, howmany, itmp,
-                                      0, stride, dist,
+                                      nullptr, stride, dist,
                                       reinterpret_cast<fftw_complex *> (out),
-                                      0, stride, dist, plan_flags);
+                                      nullptr, stride, dist, plan_flags);
           }
         else
           {
             *cur_plan_p =
               fftw_plan_many_dft_r2c (rank, tmp, howmany,
                                       (const_cast<double *> (in)),
-                                      0, stride, dist,
+                                      nullptr, stride, dist,
                                       reinterpret_cast<fftw_complex *> (out),
-                                      0, stride, dist, plan_flags);
+                                      nullptr, stride, dist, plan_flags);
           }
 
-        if (*cur_plan_p == 0)
+        if (*cur_plan_p == nullptr)
           (*current_liboctave_error_handler) ("Error creating fftw plan");
       }
 
     return *cur_plan_p;
   }
 
   fftw_planner::FftwMethod
   fftw_planner::do_method (void)
@@ -405,31 +405,31 @@ namespace octave
           {
             meth = _meth;
             if (rplan)
               fftw_destroy_plan (reinterpret_cast<fftw_plan> (rplan));
             if (plan[0])
               fftw_destroy_plan (reinterpret_cast<fftw_plan> (plan[0]));
             if (plan[1])
               fftw_destroy_plan (reinterpret_cast<fftw_plan> (plan[1]));
-            rplan = plan[0] = plan[1] = 0;
+            rplan = plan[0] = plan[1] = nullptr;
           }
       }
     else
       ret = UNKNOWN;
     return ret;
   }
 
   float_fftw_planner *float_fftw_planner::instance = nullptr;
 
   float_fftw_planner::float_fftw_planner (void)
-    : meth (ESTIMATE), rplan (0), rd (0), rs (0), rr (0), rh (0), rn (),
+    : meth (ESTIMATE), rplan (nullptr), rd (0), rs (0), rr (0), rh (0), rn (),
       rsimd_align (false), nthreads (1)
   {
-    plan[0] = plan[1] = 0;
+    plan[0] = plan[1] = nullptr;
     d[0] = d[1] = s[0] = s[1] = r[0] = r[1] = h[0] = h[1] = 0;
     simd_align[0] = simd_align[1] = false;
     inplace[0] = inplace[1] = false;
     n[0] = n[1] = dim_vector ();
 
 #if defined (HAVE_FFTW3F_THREADS)
     int init_ret = fftwf_init_threads ();
     if (! init_ret)
@@ -486,17 +486,17 @@ namespace octave
   float_fftw_planner::threads (int nt)
   {
 #if defined (HAVE_FFTW3F_THREADS)
     if (instance_ok () && nt != threads ())
       {
         instance->nthreads = nt;
         fftwf_plan_with_nthreads (nt);
         // Clear the current plans.
-        instance->rplan = instance->plan[0] = instance->plan[1] = 0;
+        instance->rplan = instance->plan[0] = instance->plan[1] = nullptr;
       }
 #else
     (*current_liboctave_warning_handler)
       ("unable to change number of threads without FFTW thread support");
 #endif
   }
 
   void *
@@ -513,17 +513,17 @@ namespace octave
     bool create_new_plan = false;
     bool ioalign = CHECK_SIMD_ALIGNMENT (in) && CHECK_SIMD_ALIGNMENT (out);
     bool ioinplace = (in == out);
 
     // Don't create a new plan if we have a non SIMD plan already but
     // can do SIMD.  This prevents endlessly recreating plans if we
     // change the alignment.
 
-    if (plan[which] == 0 || d[which] != dist || s[which] != stride
+    if (plan[which] == nullptr || d[which] != dist || s[which] != stride
         || r[which] != rank || h[which] != howmany
         || ioinplace != inplace[which]
         || ((ioalign != simd_align[which]) ? ! ioalign : false))
       create_new_plan = true;
     else
       {
         // We still might not have the same shape of array.
 
@@ -599,31 +599,31 @@ namespace octave
             OCTAVE_LOCAL_BUFFER (FloatComplex, itmp, nn * howmany + 32);
             itmp = reinterpret_cast<FloatComplex *>
               (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) +
                ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
 
             *cur_plan_p =
               fftwf_plan_many_dft (rank, tmp, howmany,
                                    reinterpret_cast<fftwf_complex *> (itmp),
-                                   0, stride, dist,
+                                   nullptr, stride, dist,
                                    reinterpret_cast<fftwf_complex *> (out),
-                                   0, stride, dist, dir, plan_flags);
+                                   nullptr, stride, dist, dir, plan_flags);
           }
         else
           {
             *cur_plan_p =
               fftwf_plan_many_dft (rank, tmp, howmany,
                                    reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *> (in)),
-                                   0, stride, dist,
+                                   nullptr, stride, dist,
                                    reinterpret_cast<fftwf_complex *> (out),
-                                   0, stride, dist, dir, plan_flags);
+                                   nullptr, stride, dist, dir, plan_flags);
           }
 
-        if (*cur_plan_p == 0)
+        if (*cur_plan_p == nullptr)
           (*current_liboctave_error_handler) ("Error creating fftw plan");
       }
 
     return *cur_plan_p;
   }
 
   void *
   float_fftw_planner::do_create_plan (const int rank, const dim_vector& dims,
@@ -635,17 +635,17 @@ namespace octave
     fftwf_plan *cur_plan_p = reinterpret_cast<fftwf_plan *> (&rplan);
     bool create_new_plan = false;
     bool ioalign = CHECK_SIMD_ALIGNMENT (in) && CHECK_SIMD_ALIGNMENT (out);
 
     // Don't create a new plan if we have a non SIMD plan already but
     // can do SIMD.  This prevents endlessly recreating plans if we
     // change the alignment.
 
-    if (rplan == 0 || rd != dist || rs != stride || rr != rank
+    if (rplan == nullptr || rd != dist || rs != stride || rr != rank
         || rh != howmany || ((ioalign != rsimd_align) ? ! ioalign : false))
       create_new_plan = true;
     else
       {
         // We still might not have the same shape of array.
 
         for (int i = 0; i < rank; i++)
           if (dims(i) != rn(i))
@@ -717,31 +717,31 @@ namespace octave
             // Create matrix with the same size and 16-byte alignment as input
             OCTAVE_LOCAL_BUFFER (float, itmp, nn + 32);
             itmp = reinterpret_cast<float *>
               (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) +
                ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
 
             *cur_plan_p =
               fftwf_plan_many_dft_r2c (rank, tmp, howmany, itmp,
-                                       0, stride, dist,
+                                       nullptr, stride, dist,
                                        reinterpret_cast<fftwf_complex *> (out),
-                                       0, stride, dist, plan_flags);
+                                       nullptr, stride, dist, plan_flags);
           }
         else
           {
             *cur_plan_p =
               fftwf_plan_many_dft_r2c (rank, tmp, howmany,
                                        (const_cast<float *> (in)),
-                                       0, stride, dist,
+                                       nullptr, stride, dist,
                                        reinterpret_cast<fftwf_complex *> (out),
-                                       0, stride, dist, plan_flags);
+                                       nullptr, stride, dist, plan_flags);
           }
 
-        if (*cur_plan_p == 0)
+        if (*cur_plan_p == nullptr)
           (*current_liboctave_error_handler) ("Error creating fftw plan");
       }
 
     return *cur_plan_p;
   }
 
   float_fftw_planner::FftwMethod
   float_fftw_planner::do_method (void)
@@ -761,17 +761,17 @@ namespace octave
           {
             meth = _meth;
             if (rplan)
               fftwf_destroy_plan (reinterpret_cast<fftwf_plan> (rplan));
             if (plan[0])
               fftwf_destroy_plan (reinterpret_cast<fftwf_plan> (plan[0]));
             if (plan[1])
               fftwf_destroy_plan (reinterpret_cast<fftwf_plan> (plan[1]));
-            rplan = plan[0] = plan[1] = 0;
+            rplan = plan[0] = plan[1] = nullptr;
           }
       }
     else
       ret = UNKNOWN;
     return ret;
   }
 
   template <typename T>
diff --git a/liboctave/numeric/oct-fftw.h b/liboctave/numeric/oct-fftw.h
--- a/liboctave/numeric/oct-fftw.h
+++ b/liboctave/numeric/oct-fftw.h
@@ -68,28 +68,28 @@ namespace octave
       create_plan (int dir, const int rank, const dim_vector& dims,
                    octave_idx_type howmany, octave_idx_type stride,
                    octave_idx_type dist, const Complex *in,
                    Complex *out)
     {
       return instance_ok ()
         ? instance->do_create_plan (dir, rank, dims, howmany, stride,
                                     dist, in, out)
-        : 0;
+        : nullptr;
     }
 
     static void *
       create_plan (const int rank, const dim_vector& dims,
                    octave_idx_type howmany, octave_idx_type stride,
                    octave_idx_type dist, const double *in, Complex *out)
     {
       return instance_ok ()
         ? instance->do_create_plan (rank, dims, howmany, stride, dist,
                                     in, out)
-        : 0;
+        : nullptr;
     }
 
     static FftwMethod method (void)
     {
       static FftwMethod dummy;
 
       return instance_ok () ? instance->do_method () : dummy;
     }
@@ -107,17 +107,17 @@ namespace octave
     {
       return instance_ok () ? instance->nthreads : 0;
     }
 
   private:
 
     static fftw_planner *instance;
 
-    static void cleanup_instance (void) { delete instance; instance = 0; }
+    static void cleanup_instance (void) { delete instance; instance = nullptr; }
 
     void *
     do_create_plan (int dir, const int rank, const dim_vector& dims,
                     octave_idx_type howmany, octave_idx_type stride,
                     octave_idx_type dist, const Complex *in,
                     Complex *out);
 
     void *
@@ -214,28 +214,28 @@ namespace octave
       create_plan (int dir, const int rank, const dim_vector& dims,
                    octave_idx_type howmany, octave_idx_type stride,
                    octave_idx_type dist, const FloatComplex *in,
                    FloatComplex *out)
     {
       return instance_ok ()
         ? instance->do_create_plan (dir, rank, dims, howmany, stride,
                                     dist, in, out)
-        : 0;
+        : nullptr;
     }
 
     static void *
       create_plan (const int rank, const dim_vector& dims,
                    octave_idx_type howmany, octave_idx_type stride,
                    octave_idx_type dist, const float *in, FloatComplex *out)
     {
       return instance_ok ()
         ? instance->do_create_plan (rank, dims, howmany, stride, dist,
                                     in, out)
-        : 0;
+        : nullptr;
     }
 
     static FftwMethod method (void)
     {
       static FftwMethod dummy;
 
       return instance_ok () ? instance->do_method () : dummy;
     }
@@ -253,17 +253,17 @@ namespace octave
     {
       return instance_ok () ? instance->nthreads : 0;
     }
 
   private:
 
     static float_fftw_planner *instance;
 
-    static void cleanup_instance (void) { delete instance; instance = 0; }
+    static void cleanup_instance (void) { delete instance; instance = nullptr; }
 
     void *
     do_create_plan (int dir, const int rank, const dim_vector& dims,
                     octave_idx_type howmany, octave_idx_type stride,
                     octave_idx_type dist, const FloatComplex *in,
                     FloatComplex *out);
 
     void *
diff --git a/liboctave/numeric/oct-rand.h b/liboctave/numeric/oct-rand.h
--- a/liboctave/numeric/oct-rand.h
+++ b/liboctave/numeric/oct-rand.h
@@ -176,17 +176,17 @@ public:
     return instance_ok () ? instance->do_float_nd_array (dims, a)
                           : FloatNDArray ();
   }
 
 private:
 
   static octave_rand *instance;
 
-  static void cleanup_instance (void) { delete instance; instance = 0; }
+  static void cleanup_instance (void) { delete instance; instance = nullptr; }
 
   enum
   {
     unknown_dist,
     uniform_dist,
     normal_dist,
     expon_dist,
     poisson_dist,
diff --git a/liboctave/numeric/oct-spparms.h b/liboctave/numeric/oct-spparms.h
--- a/liboctave/numeric/oct-spparms.h
+++ b/liboctave/numeric/oct-spparms.h
@@ -91,17 +91,17 @@ public:
 private:
 
   ColumnVector params;
 
   string_vector keys;
 
   static octave_sparse_params *instance;
 
-  static void cleanup_instance (void) { delete instance; instance = 0; }
+  static void cleanup_instance (void) { delete instance; instance = nullptr; }
 
   void do_defaults (void);
 
   void do_tight (void);
 
   string_vector do_get_keys (void) const { return keys; }
 
   ColumnVector do_get_vals (void) const { return params; }
diff --git a/liboctave/numeric/schur.cc b/liboctave/numeric/schur.cc
--- a/liboctave/numeric/schur.cc
+++ b/liboctave/numeric/schur.cc
@@ -123,17 +123,17 @@ namespace octave
       else
         jobvs = 'N';
 
       char ord_char = (ord.empty () ? 'U' : ord[0]);
 
       if (ord_char == 'A' || ord_char == 'D' || ord_char == 'a' || ord_char == 'd')
         sort = 'S';
 
-      volatile double_selector selector = 0;
+      volatile double_selector selector = nullptr;
       if (ord_char == 'A' || ord_char == 'a')
         selector = select_ana;
       else if (ord_char == 'D' || ord_char == 'd')
         selector = select_dig;
 
       F77_INT n = a_nc;
       F77_INT lwork = 8 * n;
       F77_INT liwork = 1;
@@ -210,17 +210,17 @@ namespace octave
       else
         jobvs = 'N';
 
       char ord_char = (ord.empty () ? 'U' : ord[0]);
 
       if (ord_char == 'A' || ord_char == 'D' || ord_char == 'a' || ord_char == 'd')
         sort = 'S';
 
-      volatile float_selector selector = 0;
+      volatile float_selector selector = nullptr;
       if (ord_char == 'A' || ord_char == 'a')
         selector = select_ana;
       else if (ord_char == 'D' || ord_char == 'd')
         selector = select_dig;
 
       F77_INT n = a_nc;
       F77_INT lwork = 8 * n;
       F77_INT liwork = 1;
@@ -297,17 +297,17 @@ namespace octave
       else
         jobvs = 'N';
 
       char ord_char = (ord.empty () ? 'U' : ord[0]);
 
       if (ord_char == 'A' || ord_char == 'D' || ord_char == 'a' || ord_char == 'd')
         sort = 'S';
 
-      volatile complex_selector selector = 0;
+      volatile complex_selector selector = nullptr;
       if (ord_char == 'A' || ord_char == 'a')
         selector = select_ana;
       else if (ord_char == 'D' || ord_char == 'd')
         selector = select_dig;
 
       F77_INT n = a_nc;
       F77_INT lwork = 8 * n;
       F77_INT info;
@@ -405,17 +405,17 @@ namespace octave
       else
         jobvs = 'N';
 
       char ord_char = (ord.empty () ? 'U' : ord[0]);
 
       if (ord_char == 'A' || ord_char == 'D' || ord_char == 'a' || ord_char == 'd')
         sort = 'S';
 
-      volatile float_complex_selector selector = 0;
+      volatile float_complex_selector selector = nullptr;
       if (ord_char == 'A' || ord_char == 'a')
         selector = select_ana;
       else if (ord_char == 'D' || ord_char == 'd')
         selector = select_dig;
 
       F77_INT n = a_nc;
       F77_INT lwork = 8 * n;
       F77_INT info;
diff --git a/liboctave/numeric/sparse-chol.cc b/liboctave/numeric/sparse-chol.cc
--- a/liboctave/numeric/sparse-chol.cc
+++ b/liboctave/numeric/sparse-chol.cc
@@ -48,34 +48,34 @@ namespace octave
     template <typename chol_type>
     class sparse_chol<chol_type>::sparse_chol_rep
     {
     public:
 
       sparse_chol_rep (void)
         : count (1), is_pd (false), minor_p (0), perms (), cond (0)
 #if defined (HAVE_CHOLMOD)
-        , Lsparse (0), Common ()
+        , Lsparse (nullptr), Common ()
 #endif
       { }
 
       sparse_chol_rep (const chol_type& a, bool natural, bool force)
         : count (1), is_pd (false), minor_p (0), perms (), cond (0)
 #if defined (HAVE_CHOLMOD)
-        , Lsparse (0), Common ()
+        , Lsparse (nullptr), Common ()
 #endif
       {
         init (a, natural, force);
       }
 
       sparse_chol_rep (const chol_type& a, octave_idx_type& info,
                        bool natural, bool force)
         : count (1), is_pd (false), minor_p (0), perms (), cond (0)
 #if defined (HAVE_CHOLMOD)
-        , Lsparse (0), Common ()
+        , Lsparse (nullptr), Common ()
 #endif
       {
         info = init (a, natural, force);
       }
 
       // No copying!
 
       sparse_chol_rep (const sparse_chol_rep&) = delete;
@@ -229,17 +229,17 @@ namespace octave
       CHOLMOD_NAME(start) (cm);
       cm->prefer_zomplex = false;
 
       double spu = octave_sparse_params::get_key ("spumoni");
 
       if (spu == 0.)
         {
           cm->print = -1;
-          SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, 0);
+          SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, nullptr);
         }
       else
         {
           cm->print = static_cast<int> (spu) + 2;
           SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function,
                                    &SparseCholPrint);
         }
 
diff --git a/liboctave/numeric/sparse-dmsolve.cc b/liboctave/numeric/sparse-dmsolve.cc
--- a/liboctave/numeric/sparse-dmsolve.cc
+++ b/liboctave/numeric/sparse-dmsolve.cc
@@ -384,17 +384,17 @@ dmsolve (const ST& a, const T& b, octave
   else
     {
       octave_idx_type nnz_remaining = a.nnz ();
 
       CXSPARSE_DNAME () csm;
 
       csm.m = nr;
       csm.n = nc;
-      csm.x = 0;
+      csm.x = nullptr;
       csm.nz = -1;
       csm.nzmax = a.nnz ();
 
       // Cast away const on A, with full knowledge that CSparse won't touch it.
       // Prevents the methods below from making a copy of the data.
       csm.p = const_cast<octave::suitesparse_integer *>
                 (octave::to_suitesparse_intptr (a.cidx ()));
       csm.i = const_cast<octave::suitesparse_integer *>
@@ -416,40 +416,43 @@ dmsolve (const ST& a, const T& b, octave
       retval.resize (nc, b_nc);
 
       // Leading over-determined block
       if (dm->rr[2] < nr && dm->cc[3] < nc)
         {
           ST m = dmsolve_extract (a, pinv, q, dm->rr[2], nr, dm->cc[3], nc,
                                   nnz_remaining, true);
           nnz_remaining -= m.nnz ();
-          RT mtmp = octave::math::qrsolve (m, dmsolve_extract (btmp, 0, 0,
+          RT mtmp = octave::math::qrsolve (m, dmsolve_extract (btmp,
+                                                               nullptr, nullptr,
                                                                dm->rr[2], b_nr,
                                                                0, b_nc),
                                            info);
           dmsolve_insert (retval, mtmp, q, dm->cc[3], 0);
 
           if (dm->rr[2] > 0 && ! info)
             {
               m = dmsolve_extract (a, pinv, q, 0, dm->rr[2],
                                    dm->cc[3], nc, nnz_remaining, true);
               nnz_remaining -= m.nnz ();
-              RT ctmp = dmsolve_extract (btmp, 0, 0, 0, dm->rr[2], 0, b_nc);
+              RT ctmp = dmsolve_extract (btmp, nullptr, nullptr,
+                                         0, dm->rr[2], 0, b_nc);
               btmp.insert (ctmp - m * mtmp, 0, 0);
             }
         }
 
       // Structurally non-singular blocks
       // FIXME: Should use fine Dulmange-Mendelsohn decomposition here.
       if (dm->rr[1] < dm->rr[2] && dm->cc[2] < dm->cc[3] && ! info)
         {
           ST m = dmsolve_extract (a, pinv, q, dm->rr[1], dm->rr[2],
                                   dm->cc[2], dm->cc[3], nnz_remaining, false);
           nnz_remaining -= m.nnz ();
-          RT btmp2 = dmsolve_extract (btmp, 0, 0, dm->rr[1], dm->rr[2],
+          RT btmp2 = dmsolve_extract (btmp, nullptr, nullptr,
+                                      dm->rr[1], dm->rr[2],
                                       0, b_nc);
           double rcond = 0.0;
           MatrixType mtyp (MatrixType::Full);
           RT mtmp = m.solve (mtyp, btmp2, info, rcond,
                              solve_singularity_warning, false);
           if (info != 0)
             {
               info = 0;
@@ -457,27 +460,29 @@ dmsolve (const ST& a, const T& b, octave
             }
 
           dmsolve_insert (retval, mtmp, q, dm->cc[2], 0);
           if (dm->rr[1] > 0 && ! info)
             {
               m = dmsolve_extract (a, pinv, q, 0, dm->rr[1], dm->cc[2],
                                    dm->cc[3], nnz_remaining, true);
               nnz_remaining -= m.nnz ();
-              RT ctmp = dmsolve_extract (btmp, 0, 0, 0, dm->rr[1], 0, b_nc);
+              RT ctmp = dmsolve_extract (btmp, nullptr, nullptr,
+                                         0, dm->rr[1], 0, b_nc);
               btmp.insert (ctmp - m * mtmp, 0, 0);
             }
         }
 
       // Trailing under-determined block
       if (dm->rr[1] > 0 && dm->cc[2] > 0 && ! info)
         {
           ST m = dmsolve_extract (a, pinv, q, 0, dm->rr[1], 0,
                                   dm->cc[2], nnz_remaining, true);
-          RT mtmp = octave::math::qrsolve (m, dmsolve_extract (btmp, 0, 0, 0,
+          RT mtmp = octave::math::qrsolve (m, dmsolve_extract (btmp, nullptr,
+                                                               nullptr, 0,
                                                                dm->rr[1], 0,
                                                                b_nc),
                                            info);
           dmsolve_insert (retval, mtmp, q, 0, 0);
         }
 
       CXSPARSE_DNAME (_dfree) (dm);
     }
diff --git a/liboctave/numeric/sparse-lu.cc b/liboctave/numeric/sparse-lu.cc
--- a/liboctave/numeric/sparse-lu.cc
+++ b/liboctave/numeric/sparse-lu.cc
@@ -300,52 +300,52 @@ namespace octave
     (octave_idx_type *Lp, octave_idx_type *Lj, Complex *Lz,
      octave_idx_type *Up, octave_idx_type *Ui, Complex *Uz,
      octave_idx_type *p, octave_idx_type *q, double *Dz,
      octave_idx_type *do_recip, double *Rs, void *Numeric)
     {
       return UMFPACK_ZNAME (get_numeric) (to_suitesparse_intptr (Lp),
                                           to_suitesparse_intptr (Lj),
                                           reinterpret_cast<double *> (Lz),
-                                          0, to_suitesparse_intptr (Up),
+                                          nullptr, to_suitesparse_intptr (Up),
                                           to_suitesparse_intptr (Ui),
                                           reinterpret_cast<double *> (Uz),
-                                          0, to_suitesparse_intptr (p),
+                                          nullptr, to_suitesparse_intptr (p),
                                           to_suitesparse_intptr (q),
                                           reinterpret_cast<double *> (Dz),
-                                          0, to_suitesparse_intptr (do_recip),
+                                          nullptr, to_suitesparse_intptr (do_recip),
                                           Rs, Numeric);
     }
 
     template <>
     inline octave_idx_type
     umfpack_numeric<Complex>
     (const octave_idx_type *Ap, const octave_idx_type *Ai,
      const Complex *Az, void *Symbolic, void **Numeric,
      const double *Control, double *Info)
     {
       return UMFPACK_ZNAME (numeric) (to_suitesparse_intptr (Ap),
                                       to_suitesparse_intptr (Ai),
                                       reinterpret_cast<const double *> (Az),
-                                      0, Symbolic, Numeric, Control, Info);
+                                      nullptr, Symbolic, Numeric, Control, Info);
     }
 
     template <>
     inline octave_idx_type
     umfpack_qsymbolic<Complex>
     (octave_idx_type n_row, octave_idx_type n_col,
      const octave_idx_type *Ap, const octave_idx_type *Ai,
      const Complex *Az, const octave_idx_type *Qinit,
      void **Symbolic, const double *Control, double *Info)
     {
       return UMFPACK_ZNAME (qsymbolic) (n_row, n_col,
                                         to_suitesparse_intptr (Ap),
                                         to_suitesparse_intptr (Ai),
                                         reinterpret_cast<const double *> (Az),
-                                        0, to_suitesparse_intptr (Qinit),
+                                        nullptr, to_suitesparse_intptr (Qinit),
                                         Symbolic, Control, Info);
     }
 
     template <>
     inline void
     umfpack_report_control<Complex> (const double *Control)
     {
       UMFPACK_ZNAME (report_control) (Control);
@@ -364,17 +364,17 @@ namespace octave
     (octave_idx_type n_row, octave_idx_type n_col,
      const octave_idx_type *Ap, const octave_idx_type *Ai,
      const Complex *Az, octave_idx_type col_form, const double *Control)
     {
       UMFPACK_ZNAME (report_matrix) (n_row, n_col,
                                      to_suitesparse_intptr (Ap),
                                      to_suitesparse_intptr (Ai),
                                      reinterpret_cast<const double *> (Az),
-                                     0, col_form, Control);
+                                     nullptr, col_form, Control);
     }
 
     template <>
     inline void
     umfpack_report_numeric<Complex> (void *Numeric, const double *Control)
     {
       UMFPACK_ZNAME (report_numeric) (Numeric, Control);
     }
@@ -461,17 +461,17 @@ namespace octave
 
       umfpack_report_matrix<lu_elt_type> (nr, nc, Ap, Ai, Ax,
                                           static_cast<octave_idx_type> (1),
                                           control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
-      int status = umfpack_qsymbolic<lu_elt_type> (nr, nc, Ap, Ai, Ax, 0,
+      int status = umfpack_qsymbolic<lu_elt_type> (nr, nc, Ap, Ai, Ax, nullptr,
                                                    &Symbolic, control, info);
 
       if (status < 0)
         {
           umfpack_report_status<lu_elt_type> (control, status);
           umfpack_report_info<lu_elt_type> (control, info);
 
           umfpack_free_symbolic<lu_elt_type> (&Symbolic);
@@ -554,17 +554,17 @@ namespace octave
                   octave_idx_type *p = P.fortran_vec ();
 
                   Q.resize (dim_vector (nc, 1));
                   octave_idx_type *q = Q.fortran_vec ();
 
                   octave_idx_type do_recip;
                   status = umfpack_get_numeric<lu_elt_type> (Ltp, Ltj, Ltx,
                                                              Up, Uj, Ux,
-                                                             p, q, 0,
+                                                             p, q, nullptr,
                                                              &do_recip, Rx,
                                                              Numeric);
 
                   umfpack_free_numeric<lu_elt_type> (&Numeric);
 
                   if (status < 0)
                     {
                       umfpack_report_status<lu_elt_type> (control, status);
@@ -792,17 +792,17 @@ namespace octave
                   octave_idx_type *p = P.fortran_vec ();
 
                   Q.resize (dim_vector (nc, 1));
                   octave_idx_type *q = Q.fortran_vec ();
 
                   octave_idx_type do_recip;
                   status = umfpack_get_numeric<lu_elt_type> (Ltp, Ltj, Ltx,
                                                              Up, Uj, Ux,
-                                                             p, q, 0,
+                                                             p, q, nullptr,
                                                              &do_recip,
                                                              Rx, Numeric);
 
                   umfpack_free_numeric<lu_elt_type> (&Numeric);
 
                   if (status < 0)
                     {
                       umfpack_report_status<lu_elt_type> (control, status);
diff --git a/liboctave/numeric/sparse-qr.cc b/liboctave/numeric/sparse-qr.cc
--- a/liboctave/numeric/sparse-qr.cc
+++ b/liboctave/numeric/sparse-qr.cc
@@ -175,17 +175,17 @@ namespace octave
 
     // Real-valued matrices.
 
     template <>
     sparse_qr<SparseMatrix>::sparse_qr_rep::sparse_qr_rep
     (const SparseMatrix& a, int order)
       : count (1), nrows (a.rows ()), ncols (a.columns ())
 #if defined (HAVE_CXSPARSE)
-      , S (0), N (0)
+      , S (nullptr), N (nullptr)
 #endif
     {
 #if defined (HAVE_CXSPARSE)
 
       CXSPARSE_DNAME () A;
 
       A.nzmax = a.nnz ();
       A.m = nrows;
@@ -945,17 +945,17 @@ namespace octave
 
     // Complex-valued matrices.
 
     template <>
     sparse_qr<SparseComplexMatrix>::sparse_qr_rep::sparse_qr_rep
     (const SparseComplexMatrix& a, int order)
       : count (1), nrows (a.rows ()), ncols (a.columns ())
 #if defined (HAVE_CXSPARSE)
-      , S (0), N (0)
+      , S (nullptr), N (nullptr)
 #endif
     {
 #if defined (HAVE_CXSPARSE)
 
       CXSPARSE_ZNAME () A;
 
       A.nzmax = a.nnz ();
       A.m = nrows;
diff --git a/liboctave/system/child-list.h b/liboctave/system/child-list.h
--- a/liboctave/system/child-list.h
+++ b/liboctave/system/child-list.h
@@ -42,17 +42,17 @@ namespace octave
     // Do whatever to handle event for child with PID (might not
     // actually be dead, could just be stopped).  Return true if
     // the list element corresponding to PID should be removed from
     // list.  This function should not call any functions that modify
     // the child_list.
 
     typedef bool (*child_event_handler) (pid_t, int);
 
-    child (pid_t id = -1, child_event_handler f = 0)
+    child (pid_t id = -1, child_event_handler f = nullptr)
       : pid (id), handler (f), have_status (0), status (0) { }
 
     child (const child& oc)
       : pid (oc.pid), handler (oc.handler),
         have_status (oc.have_status), status (oc.status) { }
 
     child& operator = (const child& oc)
     {
@@ -114,17 +114,17 @@ namespace octave
     static void remove (pid_t pid);
 
   private:
 
     static bool instance_ok (void);
 
     static child_list_rep *instance;
 
-    static void cleanup_instance (void) { delete instance; instance = 0; }
+    static void cleanup_instance (void) { delete instance; instance = nullptr; }
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED (4.2, "use 'octave::child' instead")
 typedef octave::child octave_child;
 
diff --git a/liboctave/system/dir-ops.cc b/liboctave/system/dir-ops.cc
--- a/liboctave/system/dir-ops.cc
+++ b/liboctave/system/dir-ops.cc
@@ -58,17 +58,17 @@ namespace octave
           dir = octave_opendir_wrapper (fullname.c_str ());
 
           if (! dir)
             errmsg = std::strerror (errno);
         }
       else
         errmsg = "dir_entry::open: empty filename";
 
-      return dir != 0;
+      return dir != nullptr;
     }
 
     string_vector
     dir_entry::read (void)
     {
       string_vector retval;
 
       if (ok ())
@@ -90,17 +90,17 @@ namespace octave
     dir_entry::close (void)
     {
       bool retval = true;
 
       if (dir)
         {
           retval = (octave_closedir_wrapper (dir) == 0);
 
-          dir = 0;
+          dir = nullptr;
         }
 
       return retval;
     }
 
     unsigned int
     dir_entry::max_name_length (void)
     {
diff --git a/liboctave/system/dir-ops.h b/liboctave/system/dir-ops.h
--- a/liboctave/system/dir-ops.h
+++ b/liboctave/system/dir-ops.h
@@ -35,17 +35,17 @@ namespace octave
   {
     class
     OCTAVE_API
     dir_entry
     {
     public:
 
       dir_entry (const std::string& n = "")
-        : name (n), dir (0), fail (false), errmsg ()
+        : name (n), dir (nullptr), fail (false), errmsg ()
       {
         if (! name.empty ())
           open ();
       }
 
       dir_entry (const dir_entry& d)
         : name (d.name), dir (d.dir), fail (d.fail), errmsg (d.errmsg) { }
 
diff --git a/liboctave/system/file-ops.cc b/liboctave/system/file-ops.cc
--- a/liboctave/system/file-ops.cc
+++ b/liboctave/system/file-ops.cc
@@ -52,22 +52,22 @@ along with Octave; see the file COPYING.
 #include "unistd-wrappers.h"
 
 // The following tilde-expansion code was stolen and adapted from
 // readline.
 
 // The default value of tilde_additional_prefixes.  This is set to
 // whitespace preceding a tilde so that simple programs which do not
 // perform any word separation get desired behavior.
-static const char *default_prefixes[] = { " ~", "\t~", ":~", 0 };
+static const char *default_prefixes[] = { " ~", "\t~", ":~", nullptr };
 
 // The default value of tilde_additional_suffixes.  This is set to
 // whitespace or newline so that simple programs which do not perform
 // any word separation get desired behavior.
-static const char *default_suffixes[] = { " ", "\n", ":", 0 };
+static const char *default_suffixes[] = { " ", "\n", ":", nullptr };
 
 static size_t
 tilde_find_prefix (const std::string& s, size_t& len)
 {
   len = 0;
 
   size_t s_len = s.length ();
 
@@ -244,19 +244,19 @@ namespace octave
       {
 #if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM)
         return "/\\";
 #else
         return dir_sep_str ();
 #endif
       }
 
-      tilde_expansion_hook tilde_expansion_preexpansion_hook = 0;
+      tilde_expansion_hook tilde_expansion_preexpansion_hook = nullptr;
 
-      tilde_expansion_hook tilde_expansion_failure_hook = 0;
+      tilde_expansion_hook tilde_expansion_failure_hook = nullptr;
 
       string_vector tilde_additional_prefixes = default_prefixes;
 
       string_vector tilde_additional_suffixes = default_suffixes;
 
       bool is_dev_sep (char c)
       {
 #if (defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM))
diff --git a/liboctave/system/lo-sysdep.cc b/liboctave/system/lo-sysdep.cc
--- a/liboctave/system/lo-sysdep.cc
+++ b/liboctave/system/lo-sysdep.cc
@@ -39,17 +39,17 @@ namespace octave
     getcwd (void)
     {
       std::string retval;
 
       // Using octave_getcwd_wrapper ensures that we have a getcwd that
       // will allocate a buffer as large as necessary if buf and size are
       // both 0.
 
-      char *tmp = octave_getcwd_wrapper (0, 0);
+      char *tmp = octave_getcwd_wrapper (nullptr, 0);
 
       if (! tmp)
         (*current_liboctave_error_handler) ("unable to find current directory");
 
       retval = tmp;
       free (tmp);
 
       return retval;
diff --git a/liboctave/system/oct-env.h b/liboctave/system/oct-env.h
--- a/liboctave/system/oct-env.h
+++ b/liboctave/system/oct-env.h
@@ -120,17 +120,17 @@ namespace octave
 
       void error (int) const;
 
       void error (const std::string&) const;
 
       // The real thing.
       static env *instance;
 
-      static void cleanup_instance (void) { delete instance; instance = 0; }
+      static void cleanup_instance (void) { delete instance; instance = nullptr; }
 
       // TRUE means follow symbolic links that point to directories just
       // as if they are real directories.
       bool follow_symbolic_links;
 
       // TRUE means that pwd always give verbatim directory, regardless
       // of symbolic link following.
       bool verbatim_pwd;
diff --git a/liboctave/system/oct-time.cc b/liboctave/system/oct-time.cc
--- a/liboctave/system/oct-time.cc
+++ b/liboctave/system/oct-time.cc
@@ -193,17 +193,17 @@ namespace octave
 
           while (chars_written == 0)
             {
               delete [] buf;
               buf = new char [bufsize];
               buf[0] = '\0';
 
               chars_written
-                = octave_strftime_wrapper (buf, bufsize, fmt_str, &t, 0, 0);
+                = octave_strftime_wrapper (buf, bufsize, fmt_str, &t, nullptr, 0);
 
               bufsize *= 2;
             }
 
 #if defined (HAVE_STRUCT_TM_TM_ZONE)
           delete [] ps;
 #endif
 
diff --git a/liboctave/util/cmd-edit.cc b/liboctave/util/cmd-edit.cc
--- a/liboctave/util/cmd-edit.cc
+++ b/liboctave/util/cmd-edit.cc
@@ -233,21 +233,21 @@ namespace octave
     static char ** command_completer (const char *text, int start, int end);
 
     static char * do_completer_word_break_hook ();
   };
 
   std::string gnu_readline::completer_quote_characters = "";
 
   gnu_readline::gnu_readline ()
-    : command_editor (), previous_startup_hook (0),
-      previous_pre_input_hook (0),
-      previous_event_hook (0), completion_function (0),
-      quoting_function (0), dequoting_function (0),
-      char_is_quoted_function (0), user_accept_line_function (0)
+    : command_editor (), previous_startup_hook (nullptr),
+      previous_pre_input_hook (nullptr),
+      previous_event_hook (nullptr), completion_function (nullptr),
+      quoting_function (nullptr), dequoting_function (nullptr),
+      char_is_quoted_function (nullptr), user_accept_line_function (nullptr)
   {
     // FIXME: need interface to rl_add_defun, rl_initialize, and
     // a function to set rl_terminal_name
 
     std::string term = sys::env::getenv ("TERM");
 
     octave_rl_set_terminal_name (term.c_str ());
 
@@ -440,50 +440,50 @@ namespace octave
   }
 
   void
   gnu_readline::do_set_completion_function (completion_fcn f)
   {
     completion_function = f;
 
     rl_attempted_completion_fcn_ptr fp
-      = (f ? gnu_readline::command_completer : 0);
+      = (f ? gnu_readline::command_completer : nullptr);
 
     ::octave_rl_set_completion_function (fp);
   }
 
   void
   gnu_readline::do_set_quoting_function (quoting_fcn f)
   {
     quoting_function = f;
 
     rl_quoting_fcn_ptr fp
-      = (f ? gnu_readline::command_quoter : 0);
+      = (f ? gnu_readline::command_quoter : nullptr);
 
     ::octave_rl_set_quoting_function (fp);
   }
 
   void
   gnu_readline::do_set_dequoting_function (dequoting_fcn f)
   {
     dequoting_function = f;
 
     rl_dequoting_fcn_ptr fp
-      = (f ? gnu_readline::command_dequoter : 0);
+      = (f ? gnu_readline::command_dequoter : nullptr);
 
     ::octave_rl_set_dequoting_function (fp);
   }
 
   void
   gnu_readline::do_set_char_is_quoted_function (char_is_quoted_fcn f)
   {
     char_is_quoted_function = f;
 
     rl_char_is_quoted_fcn_ptr fp
-      = (f ? gnu_readline::command_char_is_quoted : 0);
+      = (f ? gnu_readline::command_char_is_quoted : nullptr);
 
     ::octave_rl_set_char_is_quoted_function (fp);
   }
 
   void
   gnu_readline::do_set_user_accept_line_function (user_accept_line_fcn f)
   {
     user_accept_line_function = f;
@@ -902,17 +902,17 @@ namespace octave
     ::octave_rl_redisplay ();
 
     return ::octave_rl_newline (count, key);
   }
 
   char **
   gnu_readline::command_completer (const char *text, int, int)
   {
-    char **matches = 0;
+    char **matches = nullptr;
     matches
       = ::octave_rl_completion_matches (text, gnu_readline::command_generator);
     return matches;
   }
 
 #endif
 
   class
@@ -1184,31 +1184,31 @@ namespace octave
     if (instance_ok ())
       instance->do_set_input_stream (f);
   }
 
   FILE *
   command_editor::get_input_stream (void)
   {
     return (instance_ok ())
-           ? instance->do_get_input_stream () : 0;
+           ? instance->do_get_input_stream () : nullptr;
   }
 
   void
   command_editor::set_output_stream (FILE *f)
   {
     if (instance_ok ())
       instance->do_set_output_stream (f);
   }
 
   FILE *
   command_editor::get_output_stream (void)
   {
     return (instance_ok ())
-           ? instance->do_get_output_stream () : 0;
+           ? instance->do_get_output_stream () : nullptr;
   }
 
   void
   command_editor::redisplay (void)
   {
     if (instance_ok ())
       instance->do_redisplay ();
   }
@@ -1379,38 +1379,38 @@ namespace octave
     return (instance_ok ())
            ? instance->do_get_completion_function () : 0;
   }
 
   command_editor::quoting_fcn
   command_editor::get_quoting_function (void)
   {
     return (instance_ok ())
-           ? instance->do_get_quoting_function () : 0;
+           ? instance->do_get_quoting_function () : nullptr;
   }
 
   command_editor::dequoting_fcn
   command_editor::get_dequoting_function (void)
   {
     return (instance_ok ())
-           ? instance->do_get_dequoting_function () : 0;
+           ? instance->do_get_dequoting_function () : nullptr;
   }
 
   command_editor::char_is_quoted_fcn
   command_editor::get_char_is_quoted_function (void)
   {
     return (instance_ok ())
-           ? instance->do_get_char_is_quoted_function () : 0;
+           ? instance->do_get_char_is_quoted_function () : nullptr;
   }
 
   command_editor::user_accept_line_fcn
   command_editor::get_user_accept_line_function (void)
   {
     return (instance_ok ())
-           ? instance->do_get_user_accept_line_function () : 0;
+           ? instance->do_get_user_accept_line_function () : nullptr;
   }
 
   string_vector
   command_editor::generate_filename_completions (const std::string& text)
   {
     return (instance_ok ())
            ? instance->do_generate_filename_completions (text) : string_vector ();
   }
diff --git a/liboctave/util/cmd-edit.h b/liboctave/util/cmd-edit.h
--- a/liboctave/util/cmd-edit.h
+++ b/liboctave/util/cmd-edit.h
@@ -213,17 +213,17 @@ namespace octave
 
     static std::set<pre_input_hook_fcn> pre_input_hook_set;
 
     static std::set<event_hook_fcn> event_hook_set;
 
     // The real thing.
     static command_editor *instance;
 
-    static void cleanup_instance (void) { delete instance; instance = 0; }
+    static void cleanup_instance (void) { delete instance; instance = nullptr; }
 
   protected:
 
     // To use something other than the GNU readline library, derive a new
     // class from command_editor, overload these functions as
     // necessary, and make instance point to the new class.
 
     virtual void do_set_name (const std::string&) { }
@@ -286,27 +286,27 @@ namespace octave
     virtual void do_set_quoting_function (quoting_fcn) { }
 
     virtual void do_set_dequoting_function (dequoting_fcn) { }
 
     virtual void do_set_char_is_quoted_function (char_is_quoted_fcn) { }
 
     virtual void do_set_user_accept_line_function (user_accept_line_fcn) { }
 
-    virtual completion_fcn do_get_completion_function (void) const { return 0; }
+    virtual completion_fcn do_get_completion_function (void) const { return nullptr; }
 
-    virtual quoting_fcn do_get_quoting_function (void) const { return 0; }
+    virtual quoting_fcn do_get_quoting_function (void) const { return nullptr; }
 
-    virtual dequoting_fcn do_get_dequoting_function (void) const { return 0; }
+    virtual dequoting_fcn do_get_dequoting_function (void) const { return nullptr; }
 
     virtual char_is_quoted_fcn do_get_char_is_quoted_function (void) const
-    { return 0; }
+    { return nullptr; }
 
     virtual user_accept_line_fcn do_get_user_accept_line_function (void) const
-    { return 0; }
+    { return nullptr; }
 
     virtual string_vector
     do_generate_filename_completions (const std::string& text) = 0;
 
     virtual std::string do_get_line_buffer (void) const = 0;
 
     virtual std::string do_get_current_line (void) const = 0;
 
diff --git a/liboctave/util/cmd-hist.h b/liboctave/util/cmd-hist.h
--- a/liboctave/util/cmd-hist.h
+++ b/liboctave/util/cmd-hist.h
@@ -127,17 +127,17 @@ namespace octave
 
     static bool instance_ok (void);
 
     static void make_command_history (void);
 
     // The real thing.
     static command_history *instance;
 
-    static void cleanup_instance (void) { delete instance; instance = 0; }
+    static void cleanup_instance (void) { delete instance; instance = nullptr; }
 
   protected:
 
     // To use something other than the GNU history library, derive a new
     // class from command_history, overload these functions as
     // necessary, and make instance point to the new class.
 
     virtual void do_set_file (const std::string&);
diff --git a/liboctave/util/lo-regexp.cc b/liboctave/util/lo-regexp.cc
--- a/liboctave/util/lo-regexp.cc
+++ b/liboctave/util/lo-regexp.cc
@@ -225,17 +225,17 @@ namespace octave
     std::string buf_str = buf.str ();
 
     int pcre_options
       = (  (options.case_insensitive () ? PCRE_CASELESS : 0)
          | (options.dotexceptnewline () ? 0 : PCRE_DOTALL)
          | (options.lineanchors () ? PCRE_MULTILINE : 0)
          | (options.freespacing () ? PCRE_EXTENDED : 0));
 
-    data = pcre_compile (buf_str.c_str (), pcre_options, &err, &erroffset, 0);
+    data = pcre_compile (buf_str.c_str (), pcre_options, &err, &erroffset, nullptr);
 
     if (! data)
       (*current_liboctave_error_handler)
         ("%s: %s at position %d of expression", who.c_str (), err, erroffset);
   }
 
   regexp::match_data
   regexp::match (const std::string& buffer)
@@ -247,37 +247,37 @@ namespace octave
     int subpatterns;
     int namecount;
     int nameentrysize;
     char *nametable;
     size_t idx = 0;
 
     pcre *re = static_cast<pcre *> (data);
 
-    pcre_fullinfo (re, 0, PCRE_INFO_CAPTURECOUNT,  &subpatterns);
-    pcre_fullinfo (re, 0, PCRE_INFO_NAMECOUNT, &namecount);
-    pcre_fullinfo (re, 0, PCRE_INFO_NAMEENTRYSIZE, &nameentrysize);
-    pcre_fullinfo (re, 0, PCRE_INFO_NAMETABLE, &nametable);
+    pcre_fullinfo (re, nullptr, PCRE_INFO_CAPTURECOUNT,  &subpatterns);
+    pcre_fullinfo (re, nullptr, PCRE_INFO_NAMECOUNT, &namecount);
+    pcre_fullinfo (re, nullptr, PCRE_INFO_NAMEENTRYSIZE, &nameentrysize);
+    pcre_fullinfo (re, nullptr, PCRE_INFO_NAMETABLE, &nametable);
 
     OCTAVE_LOCAL_BUFFER (int, ovector, (subpatterns+1)*3);
     OCTAVE_LOCAL_BUFFER (int, nidx, namecount);
 
     for (int i = 0; i < namecount; i++)
       {
         // Index of subpattern in first two bytes of name (MSB first).
         // Extract index.
         nidx[i] = (static_cast<int> (nametable[i*nameentrysize])) << 8
                   | static_cast<int> (nametable[i*nameentrysize+1]);
       }
 
     while (true)
       {
         octave_quit ();
 
-        int matches = pcre_exec (re, 0, buffer.c_str (),
+        int matches = pcre_exec (re, nullptr, buffer.c_str (),
                                  buffer.length (), idx,
                                  (idx ? PCRE_NOTBOL : 0),
                                  ovector, (subpatterns+1)*3);
 
         if (matches == PCRE_ERROR_MATCHLIMIT)
           {
             // Try harder; start with default value for MATCH_LIMIT
             // and increase it.
diff --git a/liboctave/util/lo-regexp.h b/liboctave/util/lo-regexp.h
--- a/liboctave/util/lo-regexp.h
+++ b/liboctave/util/lo-regexp.h
@@ -44,17 +44,17 @@ namespace octave
   public:
 
     class opts;
     class match_data;
 
     regexp (const std::string& pat = "",
             const regexp::opts& opt = regexp::opts (),
             const std::string& w = "regexp")
-      : pattern (pat), options (opt), data (0), named_pats (),
+      : pattern (pat), options (opt), data (nullptr), named_pats (),
         nnames (0), named_idx (), who (w)
     {
       compile_internal ();
     }
 
     regexp (const regexp& rx)
       : pattern (rx.pattern), data (rx.data), named_pats (rx.named_pats),
         nnames (rx.nnames), named_idx (rx.named_idx)
diff --git a/liboctave/util/lo-utils.cc b/liboctave/util/lo-utils.cc
--- a/liboctave/util/lo-utils.cc
+++ b/liboctave/util/lo-utils.cc
@@ -70,17 +70,17 @@ bool xis_zero (float x)
 { return x == 0; }
 
 // Save a string.
 
 char *
 strsave (const char *s)
 {
   if (! s)
-    return 0;
+    return nullptr;
 
   int len = strlen (s);
   char *tmp = new char [len+1];
   tmp = strcpy (tmp, s);
   return tmp;
 }
 
 // This function was adapted from xputenv from Karl Berry's kpathsearch
@@ -160,17 +160,17 @@ octave_fgets (FILE *f, bool& eof)
       else
         {
           if (len == 0)
             {
               eof = true;
 
               free (buf);
 
-              buf = 0;
+              buf = nullptr;
             }
 
           break;
         }
     }
   while (retval.empty ());
 
   if (buf)
diff --git a/liboctave/util/oct-shlib.cc b/liboctave/util/oct-shlib.cc
--- a/liboctave/util/oct-shlib.cc
+++ b/liboctave/util/oct-shlib.cc
@@ -170,31 +170,31 @@ namespace octave
 
     octave_dlopen_shlib (const octave_dlopen_shlib&) = delete;
 
     octave_dlopen_shlib& operator = (const octave_dlopen_shlib&) = delete;
 
     ~octave_dlopen_shlib (void);
 
     void * search (const std::string& name,
-                   dynamic_library::name_mangler mangler = 0);
+                   dynamic_library::name_mangler mangler = nullptr);
 
     // FIXME: this is possibly redundant because failure to open a library will
     // normally throw an exception, avoiding the construction of an invalid
     // library.  Leave it here for possible future use.
 
-    bool is_open (void) const { return (library != 0); }
+    bool is_open (void) const { return (library != nullptr); }
 
   private:
 
     void *library;
   };
 
   octave_dlopen_shlib::octave_dlopen_shlib (const std::string& f)
-    : dynamic_library::dynlib_rep (f), library (0)
+    : dynamic_library::dynlib_rep (f), library (nullptr)
   {
     int flags = 0;
 
     // Use RTLD_NOW to resolve all symbols before dlopen returns.
     // By using this option, dlopen will detect errors and Octave
     // won't exit if there are unresolved symbols in the file we are
     // loading, and we may even get a useful diagnostic.
 #  if defined (RTLD_NOW)
@@ -430,17 +430,17 @@ namespace octave
 
     octave_dyld_shlib& operator = (const octave_dyld_shlib&) = delete;
 
     ~octave_dyld_shlib (void);
 
     void open (const std::string& f);
 
     void * search (const std::string& name,
-                   dynamic_library::name_mangler mangler = 0);
+                   dynamic_library::name_mangler mangler = nullptr);
 
     void close (void);
 
     bool is_open (void) const {return (handle != 0); }
 
   private:
 
     NSObjectFileImage img;
diff --git a/liboctave/util/oct-shlib.h b/liboctave/util/oct-shlib.h
--- a/liboctave/util/oct-shlib.h
+++ b/liboctave/util/oct-shlib.h
@@ -59,18 +59,18 @@ namespace octave
       virtual ~dynlib_rep (void)
       {
         instances.erase (file);
       }
 
       virtual bool is_open (void) const
       { return false; }
 
-      virtual void * search (const std::string&, name_mangler = 0)
-      { return 0; }
+      virtual void * search (const std::string&, name_mangler = nullptr)
+      { return nullptr; }
 
       bool is_out_of_date (void) const;
 
       // This method will be overridden conditionally.
       static dynlib_rep * new_instance (const std::string& f);
 
       static dynlib_rep * get_instance (const std::string& f, bool fake);
 
@@ -161,17 +161,17 @@ namespace octave
 
       rep->clear_fcn_names ();
 
       *this = dynamic_library ();
 
       return removed_fcns;
     }
 
-    void * search (const std::string& nm, name_mangler mangler = 0) const
+    void * search (const std::string& nm, name_mangler mangler = nullptr) const
     {
       void *f = rep->search (nm, mangler);
       if (f)
         rep->add_fcn_name (nm);
 
       return f;
     }
 
diff --git a/liboctave/util/oct-sort.cc b/liboctave/util/oct-sort.cc
--- a/liboctave/util/oct-sort.cc
+++ b/liboctave/util/oct-sort.cc
@@ -113,22 +113,22 @@ The Python license is
 
 #include "lo-mappers.h"
 #include "quit.h"
 #include "oct-sort.h"
 #include "oct-locbuf.h"
 
 template <typename T>
 octave_sort<T>::octave_sort (void) :
-  compare (ascending_compare), ms (0)
+  compare (ascending_compare), ms (nullptr)
 { }
 
 template <typename T>
 octave_sort<T>::octave_sort (compare_fcn_type comp)
-  : compare (comp), ms (0)
+  : compare (comp), ms (nullptr)
 { }
 
 template <typename T>
 octave_sort<T>::~octave_sort ()
 {
   delete ms;
 }
 
diff --git a/liboctave/util/oct-sort.h b/liboctave/util/oct-sort.h
--- a/liboctave/util/oct-sort.h
+++ b/liboctave/util/oct-sort.h
@@ -190,17 +190,17 @@ private:
   struct s_slice
   {
     octave_idx_type base, len;
   };
 
   struct MergeState
   {
     MergeState (void)
-      : min_gallop (), a (0), ia (0), alloced (0), n (0)
+      : min_gallop (), a (nullptr), ia (nullptr), alloced (0), n (0)
     { reset (); }
 
     // No copying!
 
     MergeState (const MergeState&) = delete;
 
     MergeState& operator = (const MergeState&) = delete;
 
diff --git a/liboctave/util/quit.cc b/liboctave/util/quit.cc
--- a/liboctave/util/quit.cc
+++ b/liboctave/util/quit.cc
@@ -26,19 +26,19 @@ along with Octave; see the file COPYING.
 
 #include <cstring>
 
 #include <iostream>
 #include <new>
 
 #include "quit.h"
 
-void (*octave_signal_hook) (void) = 0;
-void (*octave_interrupt_hook) (void) = 0;
-void (*octave_bad_alloc_hook) (void) = 0;
+void (*octave_signal_hook) (void) = nullptr;
+void (*octave_interrupt_hook) (void) = nullptr;
+void (*octave_bad_alloc_hook) (void) = nullptr;
 
 void
 octave_handle_signal (void)
 {
   if (octave_signal_hook)
     octave_signal_hook ();
 
   if (octave_interrupt_state > 0)
diff --git a/liboctave/util/singleton-cleanup.h b/liboctave/util/singleton-cleanup.h
--- a/liboctave/util/singleton-cleanup.h
+++ b/liboctave/util/singleton-cleanup.h
@@ -48,25 +48,25 @@ public:
   ~singleton_cleanup_list (void);
 
   static void add (fptr f)
   {
     if (instance_ok ())
       instance->do_add (f);
   }
 
-  static void cleanup (void) { delete instance; instance = 0; }
+  static void cleanup (void) { delete instance; instance = nullptr; }
 
 private:
 
   static singleton_cleanup_list *instance;
 
   static bool instance_ok (void);
 
-  static void cleanup_instance (void) { delete instance; instance = 0; }
+  static void cleanup_instance (void) { delete instance; instance = nullptr; }
 
   std::set<fptr> fcn_list;
 
   void do_add (fptr f)
   {
     fcn_list.insert (f);
   }
 };
diff --git a/liboctave/util/str-vec.cc b/liboctave/util/str-vec.cc
--- a/liboctave/util/str-vec.cc
+++ b/liboctave/util/str-vec.cc
@@ -152,17 +152,17 @@ string_vector::join (const std::string& 
 
 char **
 string_vector::c_str_vec (void) const
 {
   octave_idx_type len = numel ();
 
   char **retval = new char * [len + 1];
 
-  retval[len] = 0;
+  retval[len] = nullptr;
 
   for (octave_idx_type i = 0; i < len; i++)
     retval[i] = strsave (elem (i).c_str ());
 
   return retval;
 }
 
 std::list<std::string>
