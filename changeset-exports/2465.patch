# HG changeset patch
# User jwe
# Date 847011262 0
#      Sun Nov 03 08:54:22 1996 +0000
# Node ID 7ee42ff6536a3023fb8f57e6a4b967f8704f10c4
# Parent  76078d0868e92c5f603e9736961e453c7ec6e3c0
[project @ 1996-11-03 08:54:14 by jwe]

diff --git a/doc/interpreter/arith.texi b/doc/interpreter/arith.texi
--- a/doc/interpreter/arith.texi
+++ b/doc/interpreter/arith.texi
@@ -123,32 +123,32 @@ Compute the base-2 logarithm of @var{x}.
 Compute the base-10 logarithm of @var{x}.
 @end deftypefn
 
 @deftypefn {Mapping Function} {} sqrt (@var{x})
 Compute the square root of @var{x}.  To compute the matrix square root,
 see @ref{Linear Algebra}.
 @end deftypefn
 
-@deftypefn {Mapping Function} {} max (@var{x})
+@deftypefn {Loadable Function} {} max (@var{x})
 For a vector argument, return the maximum value.  For a matrix argument,
 return the maximum value from each column, as a row vector.  Thus,
 
 @example
 max (max (@var{x}))
 @end example
 
 @noindent
 returns the largest element of @var{x}.
 
 For complex arguments, the magnitude of the elements are used for
 comparison.
 @end deftypefn
 
-@deftypefn {Mapping Function} {} min (@var{x})
+@deftypefn {Loadable Function} {} min (@var{x})
 Like @code{max}, but return the minimum value.
 @end deftypefn
 
 @deftypefn {Mapping Function} {} rem (@var{x}, @var{y})
 Return the remainder of @code{@var{x} / @var{y}}, computed using the
 expression
 
 @example
diff --git a/doc/interpreter/diffeq.texi b/doc/interpreter/diffeq.texi
--- a/doc/interpreter/diffeq.texi
+++ b/doc/interpreter/diffeq.texi
@@ -35,17 +35,17 @@ dx
 -- = f (x, t)
 dt
 @end example
 @end ifinfo
 
 @noindent
 using Hindmarsh's ODE solver LSODE.
 
-@deftypefn {Built-in Function} {} lsode (@var{fcn}, @var{x0}, @var{t_out}, @var{t_crit})
+@deftypefn {Lodable Function} {} lsode (@var{fcn}, @var{x0}, @var{t_out}, @var{t_crit})
 The first argument is the name of the function to call to
 compute the vector of right hand sides.  It must have the form
 
 @example
 @var{xdot} = f (@var{x}, @var{t})
 @end example
 
 @noindent
@@ -93,17 +93,17 @@ value to store the values of the output 
 directly in the function call   The results can then be plotted using
 the command
 
 @example
 plot (t, x)
 @end example
 @end deftypefn
 
-@deftypefn {Built-in Function} {} lsode_options (@var{opt}, @var{val})
+@deftypefn {Lodable Function} {} lsode_options (@var{opt}, @var{val})
 When called with two arguments, this function allows you set options
 parameters for the function @code{lsode}.  Given one argument,
 @code{lsode_options} returns the value of the corresponding option.  If
 no arguments are supplied, the names of all the available options and
 their current values are displayed.
 @end deftypefn
 
 See Alan C. Hindmarsh, @cite{ODEPACK, A Systematized Collection of ODE
@@ -123,17 +123,17 @@ The function @code{dassl} can be used So
 @end iftex
 @ifinfo
 
 @example
 0 = f (x-dot, x, t),    x(t=0) = x_0, x-dot(t=0) = x-dot_0
 @end example
 @end ifinfo
 
-@deftypefn {Built-in Function} {[@var{x}, @var{xdot}] =} dassl (@var{fcn}, @var{x_0}, @var{xdot_0}, @var{t_out}, @var{t_crit})
+@deftypefn {Loadable Function} {[@var{x}, @var{xdot}] =} dassl (@var{fcn}, @var{x_0}, @var{xdot_0}, @var{t_out}, @var{t_crit})
 The first argument is the name of the function to call to
 compute the vector of residuals.  It must have the form
 
 @example
 @var{res} = f (@var{x}, @var{xdot}, @var{t})
 @end example
 
 @noindent
@@ -151,17 +151,17 @@ determining a consistent set for you, so
 the initial values result in the function evaluating to zero.
 
 The fifth argument is optional, and may be used to specify a set of
 times that the DAE solver should not integrate past.  It is useful for
 avoiding difficulties with singularities and points where there is a
 discontinuity in the derivative.
 @end deftypefn
 
-@deftypefn {Built-in Function} {} dassl_options (@var{opt}, @var{val})
+@deftypefn {Loadable Function} {} dassl_options (@var{opt}, @var{val})
 When called with two arguments, this function allows you set options
 parameters for the function @code{lsode}.  Given one argument,
 @code{dassl_options} returns the value of the corresponding option.  If
 no arguments are supplied, the names of all the available options and
 their current values are displayed.
 @end deftypefn
 
 See K. E. Brenan, et al., @cite{Numerical Solution of Initial-Value
diff --git a/doc/interpreter/linalg.texi b/doc/interpreter/linalg.texi
--- a/doc/interpreter/linalg.texi
+++ b/doc/interpreter/linalg.texi
@@ -14,19 +14,19 @@ 1989, and in @cite{LAPACK Users' Guide},
 * Basic Matrix Functions::      
 * Matrix Factorizations::       
 * Functions of a Matrix::       
 @end menu
 
 @node Basic Matrix Functions, Matrix Factorizations, Linear Algebra, Linear Algebra
 @section Basic Matrix Functions
 
-@deftypefn {Built-in Function} {@var{aa} =} balance (@var{a}, @var{opt})
-@deftypefnx {Built-in Function} {[@var{dd}, @var{aa}] =} balance (@var{a}, @var{opt})
-@deftypefnx {Built-in Function} {[@var{cc}, @var{dd}, @var{aa}, @var{bb]} =} balance (@var{a}, @var{b}, @var{opt})
+@deftypefn {Loadable Function} {@var{aa} =} balance (@var{a}, @var{opt})
+@deftypefnx {Loadable Function} {[@var{dd}, @var{aa}] =} balance (@var{a}, @var{opt})
+@deftypefnx {Loadable Function} {[@var{cc}, @var{dd}, @var{aa}, @var{bb]} =} balance (@var{a}, @var{b}, @var{opt})
 
 @code{[dd, aa] = balance (a)} returns @code{aa = dd \ a * dd}.
 @code{aa} is a matrix whose row/column norms are roughly equal in
 magnitude, and @code{dd} = @code{p * d}, where @code{p} is a permutation
 matrix and @code{d} is a diagonal matrix of powers of two.  This allows
 the equilibration to be computed without roundoff.  Results of
 eigenvalue calculation are typically improved by balancing first.
 
@@ -61,48 +61,48 @@ Generalized eigenvalue problem balancing
 @end deftypefn
 
 @deftypefn {} {} cond (@var{a})
 Compute the (two-norm) condition number of a matrix. @code{cond (a)} is
 defined as @code{norm (a) * norm (inv (a))}, and is computed via a
 singular value decomposition.
 @end deftypefn
 
-@deftypefn {Built-in Function} {} det (@var{a})
+@deftypefn {Loadable Function} {} det (@var{a})
 Compute the determinant of @var{a} using LINPACK.
 @end deftypefn
 
-@deftypefn {Built-in Function} {@var{lambda} =} eig (@var{a})
-@deftypefnx {Built-in Function} {[@var{v}, @var{lambda}] =} eig (@var{a})
+@deftypefn {Loadable Function} {@var{lambda} =} eig (@var{a})
+@deftypefnx {Loadable Function} {[@var{v}, @var{lambda}] =} eig (@var{a})
 The eigenvalues (and eigenvectors) of a matrix are computed in a several
 step process which begins with a Hessenberg decomposition (see
 @code{hess}), followed by a Schur decomposition (see @code{schur}), from
 which the eigenvalues are apparent.  The eigenvectors, when desired, are
 computed by further manipulations of the Schur decomposition.
 
 See also: @code{hess}, @code{schur}.
 @end deftypefn
 
-@deftypefn {Built-in Function} {@var{G} =} givens (@var{x}, @var{y})
-@deftypefnx {Built-in Function} {[@var{c}, @var{s}] =} givens (@var{x}, @var{y})
+@deftypefn {Loadable Function} {@var{G} =} givens (@var{x}, @var{y})
+@deftypefnx {Loadable Function} {[@var{c}, @var{s}] =} givens (@var{x}, @var{y})
 @code{G = givens(x, y)} returns a
 @iftex
 @tex
 $2\times 2$
 @end tex
 @end iftex
 @ifinfo
 2 x 2
 @end ifinfo
 orthogonal matrix @code{G = [c s; -s' c]} such that
 @code{G [x; y] = [*; 0]}  (x, y scalars)
 @end deftypefn
 
-@deftypefn {Built-in Function} {} inv (@var{a})
-@deftypefnx {Built-in Function} {} inverse (@var{a})
+@deftypefn {Loadable Function} {} inv (@var{a})
+@deftypefnx {Loadable Function} {} inverse (@var{a})
 Compute the inverse of the square matrix @var{a}.
 @end deftypefn
 
 @deftypefn {Function File} {} norm (@var{a}, @var{p})
 Compute the p-norm of the matrix @var{a}.  If the second argument is
 missing, @code{p = 2} is assumed.
 
 If @var{a} is a matrix:
@@ -190,46 +190,46 @@ singular value of @code{a}.
 
 @deftypefn {Function File} {} trace (@var{a})
 Compute the trace of @var{a}, @code{sum (diag (a))}.
 @end deftypefn
 
 @node Matrix Factorizations, Functions of a Matrix, Basic Matrix Functions, Linear Algebra
 @section Matrix Factorizations
 
-@deftypefn {Built-in Function} {} chol (@var{a})
+@deftypefn {Loadable Function} {} chol (@var{a})
 Compute the Cholesky factor, @var{r}, of the symmetric positive definite
 matrix @var{a}, where
 @iftex
 @tex
 $ R^T R = A $.
 @end tex
 @end iftex
 @ifinfo
 
 @example
 r' * r = a.
 @end example
 @end ifinfo
 @end deftypefn
 
-@deftypefn {Built-in Function} {@var{h} =} hess (@var{a})
-@deftypefnx {Built-in Function} {[@var{p}, @var{h}] =} hess (@var{a})
+@deftypefn {Loadable Function} {@var{h} =} hess (@var{a})
+@deftypefnx {Loadable Function} {[@var{p}, @var{h}] =} hess (@var{a})
 Compute the Hessenberg decomposition of the matrix @var{a}.
 
 The Hessenberg decomposition is usually used as the first step in an
 eigenvalue computation, but has other applications as well (see Golub,
 Nash, and Van Loan, IEEE Transactions on Automatic Control, 1979.  The
 Hessenberg decomposition is @code{p * h * p' = a} where @code{p} is a
 square unitary matrix (@code{p' * p = I}, using complex-conjugate
 transposition) and @code{h} is upper Hessenberg
 (@code{i >= j+1 => h (i, j) = 0}).
 @end deftypefn
 
-@deftypefn {Built-in Function} {[@var{l}, @var{u}, @var{p}] =} lu (@var{a})
+@deftypefn {Loadable Function} {[@var{l}, @var{u}, @var{p}] =} lu (@var{a})
 Compute the LU decomposition of @var{a}, using subroutines from
 LAPACK.  The result is returned in a permuted form, according to
 the optional return value @var{p}.  For example, given the matrix
 @code{a = [1, 2; 3, 4]},
 
 @example
 [l, u, p] = lu (a)
 @end example
@@ -250,17 +250,17 @@ u =
 
 p =
 
   0  1
   1  0
 @end example
 @end deftypefn
 
-@deftypefn {Built-in Function} {[@var{q}, @var{r}] =} qr (@var{a})
+@deftypefn {Loadable Function} {[@var{q}, @var{r}] =} qr (@var{a})
 Compute the QR factorization of @var{a}, using standard LAPACK
 subroutines.  For example, given the matrix @code{a = [1, 2; 3, 4]},
 
 @example
 [q, r] = qr (a)
 @end example
 
 @noindent
@@ -335,18 +335,18 @@ p =
    1  0
 @end example
 
 The permuted @code{qr} factorization @code{[q, r, pi] = qr (a)}
 factorization allows the construction of an orthogonal basis of
 @code{span (a)}.
 @end deftypefn
 
-@deftypefn {Built-in Function} {@var{s}} schur (@var{a})
-@deftypefnx {Built-in Function} {[@var{u}, @var{s}] =} schur (@var{a}, @var{opt})
+@deftypefn {Loadable Function} {@var{s}} schur (@var{a})
+@deftypefnx {Loadable Function} {[@var{u}, @var{s}] =} schur (@var{a}, @var{opt})
 The Schur decomposition is used to compute eigenvalues of a
 square matrix, and has applications in the solution of algebraic
 Riccati equations in control (see @code{are} and @code{dare}).
 @code{schur} always returns
 @iftex
 @tex
 $S = U^T A U$
 @end tex
@@ -541,18 +541,18 @@ leading eigenvalues of
 $S$.
 @end tex
 @end iftex
 @ifinfo
 @code{s}.
 @end ifinfo
 @end deftypefn
 
-@deftypefn {Built-in Function} {@var{s} =} svd (@var{a})
-@deftypefnx {Built-in Function} {[@var{u}, @var{s}, @var{v}] =} svd (@var{a})
+@deftypefn {Loadable Function} {@var{s} =} svd (@var{a})
+@deftypefnx {Loadable Function} {[@var{u}, @var{s}, @var{v}] =} svd (@var{a})
 Compute the singular value decomposition of @var{a}
 @iftex
 @tex
 $$
  A = U\Sigma V^H
 $$
 @end tex
 @end iftex
@@ -623,17 +623,17 @@ v =
 If given a second argument, @code{svd} returns an economy-sized
 decomposition, eliminating the unnecessary rows or columns of @var{u} or
 @var{v}.
 @end deftypefn
 
 @node Functions of a Matrix,  , Matrix Factorizations, Linear Algebra
 @section Functions of a Matrix
 
-@deftypefn {Built-in Function} {} expm (@var{a})
+@deftypefn {Loadable Function} {} expm (@var{a})
 Returns the exponential of a matrix, defined as the
 infinite Taylor series
 @iftex
 @tex
 $$
  \exp (A) = I + A + {A^2 \over 2!} + {A^3 \over 3!} + \cdots
 $$
 @end tex
@@ -709,23 +709,23 @@ approximation when
 @end tex
 @end iftex
 @ifinfo
 @code{Dq(a)}
 @end ifinfo
 is ill-conditioned.
 @end deftypefn
 
-@deftypefn {Built-in Function} {} logm (@var{a})
+@deftypefn {Loadable Function} {} logm (@var{a})
 Compute the matrix logarithm of the square matrix @var{a}.  Note that
 this is currently implemented in terms of an eigenvalue expansion and
 needs to be improved to be more robust.
 @end deftypefn
 
-@deftypefn {Built-in Function} {} sqrtm (@var{a})
+@deftypefn {Loadable Function} {} sqrtm (@var{a})
 Compute the matrix square root of the square matrix @var{a}.  Note that
 this is currently implemented in terms of an eigenvalue expansion and
 needs to be improved to be more robust.
 @end deftypefn
 
 @deftypefn {Function File} {} kron (@var{a}, @var{b})
 Form the kronecker product of two matrices, defined block by block as
 
@@ -746,21 +746,21 @@ Compute the Hessenberg-triangular decomp
 The Hessenberg-triangular decomposition is the first step in
 Moler and Stewart's QZ decomposition algorithm.  (The QZ decomposition
 will be included in a later release of Octave.)
 
 Algorithm taken from Golub and Van Loan, @cite{Matrix Computations, 2nd
 edition}.
 @end deftypefn
 
-@deftypefn {Built-in Function} {} qzval (@var{a}, @var{b})
+@deftypefn {Loadable Function} {} qzval (@var{a}, @var{b})
 Compute generalized eigenvalues.
 @end deftypefn
 
-@deftypefn {Built-in Function} {} syl (@var{a}, @var{b}, @var{c})
+@deftypefn {Loadable Function} {} syl (@var{a}, @var{b}, @var{c})
 Solve the Sylvester equation
 @iftex
 @tex
 $$
  A X + X B + C = 0
 $$
 @end tex
 @end iftex
diff --git a/doc/interpreter/matrix.texi b/doc/interpreter/matrix.texi
--- a/doc/interpreter/matrix.texi
+++ b/doc/interpreter/matrix.texi
@@ -109,17 +109,17 @@ otherwise. For example,
 @group
 finite ([13, Inf, NaN])
 
      @result{} [ 1, 0, 0 ]
 @end group
 @end example
 @end deftypefn
 
-@deftypefn {Built-in Function} {} find (@var{x})
+@deftypefn {Loadable Function} {} find (@var{x})
 The function @code{find} returns a vector of indices of nonzero elements
 of a matrix.  To obtain a single index for each matrix element, Octave
 pretends that the columns of a matrix form one long vector (like Fortran
 arrays are stored).  For example,
 
 @example
 @group
 find (eye (2))
@@ -245,17 +245,17 @@ retval (:) = a;
 @end example
 
 @noindent
 but it is somewhat less cryptic to use @code{reshape} instead of the
 colon operator.  Note that the total number of elements in the original
 matrix must match the total number of elements in the new matrix.
 @end deftypefn
 
-@deftypefn {Built-in Function} {[s, i] =} sort (@var{x})
+@deftypefn {Loadable Function} {[s, i] =} sort (@var{x})
 Returns a copy of @var{x} with the elements elements arranged in
 increasing order.  For matrices, @code{sort} orders the elements in each
 column.
 
 For example,
 
 @example
 @group
diff --git a/doc/interpreter/nonlin.texi b/doc/interpreter/nonlin.texi
--- a/doc/interpreter/nonlin.texi
+++ b/doc/interpreter/nonlin.texi
@@ -21,23 +21,23 @@ Octave can solve sets of nonlinear equat
 F (x) = 0
 @end example
 @end ifinfo
 
 @noindent
 using the function @code{fsolve}, which is based on the MINPACK
 subroutine @code{hybrd}.
 
-@deftypefn {Built-in Function} {[@var{x}, @var{info}] =} fsolve (@var{fcn}, @var{x0})
+@deftypefn {Loadable Function} {[@var{x}, @var{info}] =} fsolve (@var{fcn}, @var{x0})
 Given @var{fcn}, the name of a function of the form @code{f (@var{x})}
 and an initial starting point @var{x0}, @code{fsolve} solves the set of
 equations such that @code{f(@var{x}) == 0}.
 @end deftypefn
 
-@deftypefn {Built-in Function} {} fsolve_options (@var{opt}, @var{val})
+@deftypefn {Loadable Function} {} fsolve_options (@var{opt}, @var{val})
 When called with two arguments, this function allows you set options
 parameters for the function @code{fsolve}.  Given one argument,
 @code{fsolve_options} returns the value of the corresponding option.  If
 no arguments are supplied, the names of all the available options and
 their current values are displayed.
 @end deftypefn
 
 Here is a complete example.  To solve the set of equations
diff --git a/doc/interpreter/optim.texi b/doc/interpreter/optim.texi
--- a/doc/interpreter/optim.texi
+++ b/doc/interpreter/optim.texi
@@ -17,65 +17,65 @@
 @cindex optimization
 @cindex LP
 @cindex QP
 @cindex NLP
 
 @node Quadratic Programming, Nonlinear Programming, Optimization, Optimization
 @section Quadratic Programming
 
-@deftypefn {Built-in Function} {[@var{x}, @var{obj}, @var{info}, @var{lambda}] =} qpsol (@var{x}, @var{H}, @var{c}, @var{lb}, @var{ub}, @var{lb}, @var{A}, @var{ub})
+@deftypefn {Loadable Function} {[@var{x}, @var{obj}, @var{info}, @var{lambda}] =} qpsol (@var{x}, @var{H}, @var{c}, @var{lb}, @var{ub}, @var{lb}, @var{A}, @var{ub})
 Solve quadratic programs using Gill and Murray's QPSOL.  Because QPSOL
 is not freely redistributable, this function is only available if you
 have obtained your own copy of QPSOL.  @xref{Installation}.
 @end deftypefn
 
-@deftypefn {Built-in Function} {} qpsol_options (@var{opt}, @var{val})
+@deftypefn {Loadable Function} {} qpsol_options (@var{opt}, @var{val})
 When called with two arguments, this function allows you set options
 parameters for the function @code{qpsol}.  Given one argument,
 @code{qpsol_options} returns the value of the corresponding option.  If
 no arguments are supplied, the names of all the available options and
 their current values are displayed.
 @end deftypefn
 
 @node Nonlinear Programming, Linear Least Squares, Quadratic Programming, Optimization
 @section Nonlinear Programming
 
 @ignore
-@deftypefn {Built-in Function} {} fsqp ()
+@deftypefn {Loadable Function} {} fsqp ()
 @end deftypefn
 
-@deftypefn {Built-in Function} {} fsqp_options (@var{opt}, @var{val})
+@deftypefn {Loadable Function} {} fsqp_options (@var{opt}, @var{val})
 When called with two arguments, this function allows you set options
 parameters for the function @code{fsqp}.  Given one argument,
 @code{fsqp_options} returns the value of the corresponding option.  If
 no arguments are supplied, the names of all the available options and
 their current values are displayed.
 @end deftypefn
 
 Sorry, this hasn't been implemented yet.
 @end ignore
 
-@deftypefn {Built-in Function} {[@var{x}, @var{obj}, @var{info}, @var{lambda}] =} npsol (@var{x}, @var{phi}, @var{lb}, @var{ub}, @var{lb}, @var{A}, @var{ub}, @var{lb}, @var{g}, @var{ub})
+@deftypefn {Loadable Function} {[@var{x}, @var{obj}, @var{info}, @var{lambda}] =} npsol (@var{x}, @var{phi}, @var{lb}, @var{ub}, @var{lb}, @var{A}, @var{ub}, @var{lb}, @var{g}, @var{ub})
 Solve nonlinear programs using Gill and Murray's NPSOL.  Because NPSOL
 is not freely redistributable, this function is only available if you
 have obtained your own copy of NPSOL.  @xref{Installation}.
 
 The second argument is a string containing the name of the objective
 function to call.  The objective function must be of the form
 
 @example
 y = phi (x)
 @end example
 
 @noindent
 where x is a vector and y is a scalar.
 @end deftypefn
 
-@deftypefn {Built-in Function} {} npsol_options (@var{opt}, @var{val})
+@deftypefn {Loadable Function} {} npsol_options (@var{opt}, @var{val})
 When called with two arguments, this function allows you set options
 parameters for the function @code{npsol}.  Given one argument,
 @code{npsol_options} returns the value of the corresponding option.  If
 no arguments are supplied, the names of all the available options and
 their current values are displayed.
 @end deftypefn
 
 @node Linear Least Squares,  , Nonlinear Programming, Optimization
diff --git a/doc/interpreter/quad.texi b/doc/interpreter/quad.texi
--- a/doc/interpreter/quad.texi
+++ b/doc/interpreter/quad.texi
@@ -8,17 +8,17 @@
 @menu
 * Functions of one Variable::   
 * Orthogonal Collocation::      
 @end menu
 
 @node Functions of one Variable, Orthogonal Collocation, Quadrature, Quadrature
 @section Functions of one Variable
 
-@deftypefn {Built-in Function} {[@var{v}, @var{ier}, @var{nfun}] =} quad (@var{f}, @var{a}, @var{b}, @var{tol}, @var{sing})
+@deftypefn {Loadable Function} {[@var{v}, @var{ier}, @var{nfun}] =} quad (@var{f}, @var{a}, @var{b}, @var{tol}, @var{sing})
 Integrate a nonlinear function of one variable using Quadpack.
 The first argument is the name of the  function to call to compute the
 value of the integrand.  It must have the form
 
 @example
 y = f (x)
 @end example
 
@@ -34,25 +34,25 @@ absolute tolerance, and the second eleme
 tolerance.  To choose a relative test only, set the absolute
 tolerance to zero.  To choose an absolute test only, set the relative
 tolerance to zero. 
 
 The optional argument @var{sing} is a vector of values at which the
 integrand is known to be singular.
 @end deftypefn
 
-@deftypefn {Built-in Function} {} quad_options (@var{opt}, @var{val})
+@deftypefn {Loadable Function} {} quad_options (@var{opt}, @var{val})
 When called with two arguments, this function allows you set options
 parameters for the function @code{quad}.  Given one argument,
 @code{quad_options} returns the value of the corresponding option.  If
 no arguments are supplied, the names of all the available options and
 their current values are displayed.
 @end deftypefn
 
 @node Orthogonal Collocation,  , Functions of one Variable, Quadrature
 @section Orthogonal Collocation
 
-@deftypefn {Built-in Function} {[@var{r}, @var{A}, @var{B}, @var{q}] =} colloc (@var{n}, "left", "right")
+@deftypefn {Loadable Function} {[@var{r}, @var{A}, @var{B}, @var{q}] =} colloc (@var{n}, "left", "right")
 Compute derivative and integral weight matrices for orthogonal
 collocation using the subroutines given in J. Villadsen and
 M. L. Michelsen, @cite{Solution of Differential Equation Models by
 Polynomial Approximation}.
 @end deftypefn
diff --git a/doc/interpreter/signal.texi b/doc/interpreter/signal.texi
--- a/doc/interpreter/signal.texi
+++ b/doc/interpreter/signal.texi
@@ -15,38 +15,38 @@ is a matrix, @code{fft} computes the FFT
 
 If called with two arguments, @var{n} is expected to be an integer
 specifying the number of elements of @var{a} to use.  If @var{a} is a
 matrix, @var{n} specifies the number of rows of @var{a} to use.  If
 @var{n} is larger than the size of @var{a}, @var{a} is resized and
 padded with zeros.
 @end deftypefn
 
-@deftypefn {Built-in Function} {} ifft (@var{a} [, @var{n}])
+@deftypefn {Loadable Function} {} ifft (@var{a} [, @var{n}])
 Compute the inverse FFT of @var{a} using subroutines from FFTPACK.  If
 @var{a} is a matrix, @code{fft} computes the inverse FFT for each column
 of @var{a}.
 
 If called with two arguments, @var{n} is expected to be an integer
 specifying the number of elements of @var{a} to use.  If @var{a} is a
 matrix, @var{n} specifies the number of rows of @var{a} to use.  If
 @var{n} is larger than the size of @var{a}, @var{a} is resized and
 padded with zeros.
 @end deftypefn
 
-@deftypefn {Built-in Function} {} fft2 (@var{a} [, @var{n} [, @var{m}]])
+@deftypefn {Loadable Function} {} fft2 (@var{a} [, @var{n} [, @var{m}]])
 Compute the two dimensional FFT of @var{a}.
 
 The optional arguments @var{n} and @var{m} may be used specify the
 number of rows and columns of @var{a} to use.  If either of these is
 larger than the size of @var{a}, @var{a} is resized and padded with
 zeros.
 @end deftypefn
 
-@deftypefn {Built-in Function} {} ifft2 (@var{a} [, @var{n} [, @var{m}]])
+@deftypefn {Loadable Function} {} ifft2 (@var{a} [, @var{n} [, @var{m}]])
 Compute the two dimensional inverse FFT of @var{a}.
 
 The optional arguments @var{n} and @var{m} may be used specify the
 number of rows and columns of @var{a} to use.  If either of these is
 larger than the size of @var{a}, @var{a} is resized and padded with
 zeros.
 @end deftypefn
 
@@ -65,17 +65,17 @@ the optional argument @var{N} is specifi
 
 With two arguments, @code{fftfilt} filters @var{x} with the FIR filter
 @var{b} using the FFT.
 
 Given the optional third argument, @var{N}, @code{fftfilt} uses the
 overlap-add method to filter @var{x} with @var{b} using an N-point FFT.
 @end deftypefn
 
-@deftypefn {Built-in Function} {y =} filter (@var{b}, @var{a}, @var{x})
+@deftypefn {Loadable Function} {y =} filter (@var{b}, @var{a}, @var{x})
 This function returns the solution to the following linear,
 time-invariant difference equation:
 @iftex
 @tex
 $$
 \sum_{k=0}^N a_{k+1} y_{n-k} = \sum_{k=0}^M b_{k+1} x_{n-k}, \qquad
  1 \le n \le P
 $$
@@ -148,17 +148,17 @@ H(z) = {\sum_{k=0}^M d_{k+1} z^{-k} \ove
   H(z) = ----------------------
                N
           1 + SUM c(k+1) z(-k)
               k=1
 @end example
 @end ifinfo
 @end deftypefn
 
-@deftypefn {Built-in Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, @var{si})
+@deftypefn {Loadable Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, @var{si})
 This is the same as the @code{filter} function described above, except
 that @var{si} is taken as the initial state of the system and the final
 state is returned as @var{sf}.  The state vector is a column vector
 whose length is equal to the length of the longest coefficient vector
 minus one.  If @var{si} is not set, the initial state vector is set to
 all zeros.
 @end deftypefn
 
diff --git a/doc/interpreter/special.texi b/doc/interpreter/special.texi
--- a/doc/interpreter/special.texi
+++ b/doc/interpreter/special.texi
@@ -64,19 +64,19 @@ val_matrix = val * ones (n, m)
 @end deftypefn
 
 @deftypefn {Built-in Function} {} zeros (@var{x})
 @deftypefnx {Built-in Function} {} zeros (@var{n}, @var{m})
 Returns a matrix whose elements are all 0.  The arguments are handled
 the same as the arguments for @code{eye}.
 @end deftypefn
 
-@deftypefn {Built-in Function} {} rand (@var{x})
-@deftypefnx {Built-in Function} {} rand (@var{n}, @var{m})
-@deftypefnx {Built-in Function} {} rand (@code{"seed"}, @var{x})
+@deftypefn {Loadable Function} {} rand (@var{x})
+@deftypefnx {Loadable Function} {} rand (@var{n}, @var{m})
+@deftypefnx {Loadable Function} {} rand (@code{"seed"}, @var{x})
 Returns a matrix with random elements uniformly distributed on the
 interval (0, 1).  The arguments are handled the same as the arguments
 for @code{eye}.  In
 addition, you can set the seed for the random number generator using the
 form
 
 @example
 randn ("seed", @var{x})
@@ -88,19 +88,19 @@ where @var{x} is a scalar value.  If cal
 @example
 rand ("seed")
 @end example
 
 @noindent
 @code{rand} returns the current value of the seed.
 @end deftypefn
 
-@deftypefn {Built-in Function} {} randn (@var{x})
-@deftypefnx {Built-in Function} {} randn (@var{n}, @var{m})
-@deftypefnx {Built-in Function} {} randn (@code{"seed"}, @var{x})
+@deftypefn {Loadable Function} {} randn (@var{x})
+@deftypefnx {Loadable Function} {} randn (@var{n}, @var{m})
+@deftypefnx {Loadable Function} {} randn (@code{"seed"}, @var{x})
 Returns a matrix with normally distributed random elements.  The
 arguments are handled the same as the arguments for @code{eye}.  In
 addition, you can set the seed for the random number generator using the
 form
 
 @example
 randn ("seed", @var{x})
 @end example
diff --git a/doc/interpreter/system.texi b/doc/interpreter/system.texi
--- a/doc/interpreter/system.texi
+++ b/doc/interpreter/system.texi
@@ -18,17 +18,17 @@ and even start other programs from the O
 * Password Database Functions::  
 * System Information::          
 * Other Functions::             
 @end menu
 
 @node Timing Utilities, Filesystem Utilities, System Utilities, System Utilities
 @section Timing Utilities
 
-@deftypefn {Built-in Function} {} time ()
+@deftypefn {Loadable Function} {} time ()
 Return the current time as the number of seconds since the epoch.  The
 epoch is referenced to 00:00:00 CUT (Coordinated Universal Time) 1 Jan
 1970.
 @end deftypefn
 
 Several of Octave's time functions a data structure for time that
 includes the following elements:
 
@@ -63,37 +63,37 @@ Days since January 1 (0-365).
 
 @item isdst
 Daylight Savings Time flag.
 
 @item zone
 Time zone.
 @end table
 
-@deftypefn {Built-in Function} {} mktime (@var{time_struct})
+@deftypefn {Loadable Function} {} mktime (@var{time_struct})
 Convert a time structure to the number of seconds since the epoch.
 @end deftypefn
 
-@deftypefn {Built-in Function} {} localtime (@var{t})
+@deftypefn {Loadable Function} {} localtime (@var{t})
 Given a value returned from time (or any nonnegative integer),
 return a time structure corresponding to the local time zone.
 @end deftypefn
 
-@deftypefn {Built-in Function} {} gmtime (@var{t})
+@deftypefn {Loadable Function} {} gmtime (@var{t})
 Given a value returned from time (or any nonnegative integer),
 return a time structure corresponding to CUT.
 @end deftypefn
 
 @deftypefn {Function File} {} asctime (@var{time_struct})
 Convert a time structure to a string using the following five-field
 format: Thu Mar 28 08:40:14 1996.  The function @code{ctime (time)} is
 equivalent to @code{asctime (localtime (time))}.
 @end deftypefn
 
-@deftypefn {Built-in Function} {} strftime (@var{time_struct})
+@deftypefn {Loadable Function} {} strftime (@var{time_struct})
 Format a time structure in a flexible way using @samp{%} substitutions
 similar to those in @code{printf}.  Except where noted, substituted
 fields have a fixed size; numeric fields are padded if necessary.
 Padding is with zeros by default; for fields that display a single
 number, padding can be changed or inhibited by following the @samp{%}
 with one of the modifiers described below.  Unknown field specifiers are
 copied as normal characters.  All other characters are copied to the
 output without change.
@@ -552,38 +552,38 @@ The GECOS field.
 
 @item dir
 The home directory.
 
 @item shell
 The initial shell.
 @end table
 
-@deftypefn {Built-in Function} {passwd_struct =} getpwent ()
+@deftypefn {Loadable Function} {passwd_struct =} getpwent ()
 Return an entry from the password database, opening it if necessary.
 Once the end of the data has been reached, @code{getpwent} returns 0.
 @end deftypefn
 
-@deftypefn {Built-in Function} {passwd_struct =} getpwuid (@var{uid}).
+@deftypefn {Loadable Function} {passwd_struct =} getpwuid (@var{uid}).
 Return the first entry from the password database with the user ID
 @var{uid}.  If the user ID does not exist in the database,
 @code{getpwuid} returns 0.
 @end deftypefn
 
-@deftypefn {Built-in Function} {passwd_struct =} getpwnam (@var{name})
+@deftypefn {Loadable Function} {passwd_struct =} getpwnam (@var{name})
 Return the first entry from the password database with the user name
 @var{name}.  If the user name does not exist in the database,
 @code{getpwname} returns 0.
 @end deftypefn
 
-@deftypefn {Built-in Function} {} setpwent ()
+@deftypefn {Loadable Function} {} setpwent ()
 Return the internal pointer to the beginning of the password database.
 @end deftypefn
 
-@deftypefn {Built-in Function} {} endpwent ()
+@deftypefn {Loadable Function} {} endpwent ()
 Close the password database.
 @end deftypefn
 
 @node System Information, Other Functions, Password Database Functions, System Utilities
 @section System Information
 
 @deftypefn {Built-in Function} {} computer ()
 Returns a string of the form @var{cpu}-@var{vendor}-@var{os} that
@@ -600,17 +600,17 @@ Return 1 if your computer claims to conf
 floating point calculations.
 @end deftypefn
 
 @deftypefn {Built-in Function} {} version ()
 Returns Octave's version number as a string.  This is also the value of
 the built-in variable @code{OCTAVE_VERSION}.  @xref{Built-in Variables}.
 @end deftypefn
 
-@deftypefn {Built-in Function} {} getrusage ()
+@deftypefn {Loadable Function} {} getrusage ()
 Return a structure containing a number of statistics about the current
 Octave process.  Not all fields are available on all systems.  If it is
 not possible to get CPU time statistics, the CPU time slots are set to
 zero.  Other missing data are replaced by NaN.  Here is a list of all
 the possible fields that can be present in the structure returned by
 @code{getrusage}:
 
 @table @code
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,10 +1,23 @@
 Sun Nov  3 00:45:30 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* mk-oct-links.in: In sed command, match "DEFUN_DLD *( *", not
+	"DEFUN_DLD_BUILTIN *( *".
+
+	* chol.cc, colloc.cc, dassl.cc, det.cc, eig.cc, expm.cc, fft.cc,
+	fft2.cc, filter.cc, find.cc, fsolve.cc, fsqp.cc, getpwent.cc,
+	getrusage.cc, givens.cc, hess.cc, ifft.cc, ifft2.cc, inv.cc,
+	log.cc, lpsolve.cc, lsode.cc, lu.cc, minmax.cc, npsol.cc, pinv.cc,
+	qpsol.cc, qr.cc, quad.cc, qzval.cc, rand.cc, schur.cc, sort.cc,
+	svd.cc, syl.cc, time.cc: Change all uses of DEFUN_DLD_BUILTIN to
+	be just DEFUN_DLD.
+
+	* defun-dld.h: Eliminate DEFUN_DLD_BUILTIN.
+
 	* syswait.h: Use #ifdef HAVE_SYS_WAIT_H, not #if HAVE_SYS_WAIT_H
 	to decide whether to include sys/wait.h.
 
 	* pt-exp-base.h (tree_expression): Declare oper() here as a
 	virtual member function.
 
 	* pt-pr-code.cc (tree_print_code::visit_constant): Check for
 	string before checking for char_matrix.
diff --git a/src/balance.cc b/src/balance.cc
--- a/src/balance.cc
+++ b/src/balance.cc
@@ -36,17 +36,17 @@ Software Foundation, 59 Temple Place - S
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD_BUILTIN (balance, args, nargout,
+DEFUN_DLD (balance, args, nargout,
   "AA = balance (A [, OPT]) or [[DD,] AA] =  balance (A [, OPT])\n\
 \n\
 generalized eigenvalue problem:\n\
 \n\
   [cc, dd, aa, bb] = balance (a, b [, opt])\n\
 \n\
 where OPT is an optional single character argument as follows: \n\
 \n\
diff --git a/src/chol.cc b/src/chol.cc
--- a/src/chol.cc
+++ b/src/chol.cc
@@ -29,17 +29,17 @@ Software Foundation, 59 Temple Place - S
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD_BUILTIN (chol, args, nargout,
+DEFUN_DLD (chol, args, nargout,
   "R = chol (X): cholesky factorization")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 || nargout > 1)
     {
diff --git a/src/colloc.cc b/src/colloc.cc
--- a/src/colloc.cc
+++ b/src/colloc.cc
@@ -30,17 +30,17 @@ Software Foundation, 59 Temple Place - S
 
 #include "defun-dld.h"
 #include "error.h"
 #include "help.h"
 #include "mappers.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD_BUILTIN (colloc, args, ,
+DEFUN_DLD (colloc, args, ,
   "[R, A, B, Q] = colloc (N [, \"left\"] [, \"right\"]): collocation weights")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     {
diff --git a/src/dassl.cc b/src/dassl.cc
--- a/src/dassl.cc
+++ b/src/dassl.cc
@@ -100,17 +100,17 @@ dassl_user_function (const ColumnVector&
 	}
       else
 	gripe_user_supplied_eval ("dassl");
     }
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN (dassl, args, ,
+DEFUN_DLD (dassl, args, ,
   "dassl (\"function_name\", x_0, xdot_0, t_out)\n\
 dassl (F, X_0, XDOT_0, T_OUT, T_CRIT)\n\
 \n\
 The first argument is the name of the function to call to\n\
 compute the vector of residuals.  It must have the form\n\
 \n\
   res = f (x, xdot, t)\n\
 \n\
@@ -314,17 +314,17 @@ show_dassl_option (const string& keyword
       list++;
     }
 
   warning ("dassl_options: no match for `%s'", keyword.c_str ());
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN (dassl_options, args, ,
+DEFUN_DLD (dassl_options, args, ,
   "dassl_options (KEYWORD, VALUE)\n\
 \n\
 Set or show options for dassl.  Keywords may be abbreviated\n\
 to the shortest match.")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
diff --git a/src/defun-dld.h b/src/defun-dld.h
--- a/src/defun-dld.h
+++ b/src/defun-dld.h
@@ -28,37 +28,28 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "defun-int.h"
 
 // Define a builtin function that may be loaded dynamically at run
 // time.
 //
 // If Octave is not configured for dynamic linking of builtin
-// functions, this is exactly like DEFUN.
+// functions, this is similar to DEFUN, except that it will generate
+// an extra static struct and an extra externally visible function.
+//
+// The first DECLARE_FUN is for the struct, the second is for the
+// definition of the function.
 
-#if defined (OCTAVE_LITE) && defined (WITH_DYNAMIC_LINKING)
-#if ! defined (MAKE_BUILTINS)
-#define DEFUN_DLD_BUILTIN(name, args_name, nargout_name, doc) \
-  DEFUN_DLD (name, args_name, nargout_name, doc)
-#endif
-#else
-#define DEFUN_DLD_BUILTIN(name, args_name, nargout_name, doc) \
+#if defined (MAKE_BUILTINS)
+#if ! (defined (OCTAVE_LITE) && defined (WITH_DYNAMIC_LINKING))
+#define DEFUN_DLD(name, args_name, nargout_name, doc) \
   DEFUN_INTERNAL (name, args_name, nargout_name, 0, doc)
 #endif
-
-// Define a function that may be loaded dynamically at run time.
-//
-// If Octave is not configured for dynamic linking of builtin
-// functions, this won't do anything useful.
-//
-// The forward declaration is for the struct, the second is for the
-// definition of the function.
-
-#if ! defined (MAKE_BUILTINS)
+#else
 #define DEFUN_DLD(name, args_name, nargout_name, doc) \
   DECLARE_FUN (name, args_name, nargout_name); \
   DEFINE_FUN_STRUCT (name, 0, doc); \
   DEFINE_FUN_STRUCT_FUN (name) \
   DECLARE_FUN (name, args_name, nargout_name)
 #endif
 
 #endif
diff --git a/src/det.cc b/src/det.cc
--- a/src/det.cc
+++ b/src/det.cc
@@ -29,17 +29,17 @@ Software Foundation, 59 Temple Place - S
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD_BUILTIN (det, args, ,
+DEFUN_DLD (det, args, ,
   "det (X): determinant of a square matrix")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
diff --git a/src/eig.cc b/src/eig.cc
--- a/src/eig.cc
+++ b/src/eig.cc
@@ -28,17 +28,17 @@ Software Foundation, 59 Temple Place - S
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD_BUILTIN (eig, args, nargout,
+DEFUN_DLD (eig, args, nargout,
   "eig (X) or [V, D] = eig (X): compute eigenvalues and eigenvectors of X")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 || nargout > 2)
     {
diff --git a/src/expm.cc b/src/expm.cc
--- a/src/expm.cc
+++ b/src/expm.cc
@@ -28,17 +28,17 @@ Software Foundation, 59 Temple Place - S
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD_BUILTIN (expm, args, ,
+DEFUN_DLD (expm, args, ,
   "expm (X): matrix exponential, e^A")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
diff --git a/src/fft.cc b/src/fft.cc
--- a/src/fft.cc
+++ b/src/fft.cc
@@ -29,17 +29,17 @@ Software Foundation, 59 Temple Place - S
 #include "gripes.h"
 #include "help.h"
 #include "mappers.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 // This function should be merged with Fifft.
 
-DEFUN_DLD_BUILTIN (fft, args, ,
+DEFUN_DLD (fft, args, ,
   "fft (X [, N]): fast fourier transform of a vector")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     {
diff --git a/src/fft2.cc b/src/fft2.cc
--- a/src/fft2.cc
+++ b/src/fft2.cc
@@ -29,17 +29,17 @@ Software Foundation, 59 Temple Place - S
 #include "gripes.h"
 #include "help.h"
 #include "mappers.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 // This function should be merged with Fifft2.
 
-DEFUN_DLD_BUILTIN (fft2, args, ,
+DEFUN_DLD (fft2, args, ,
   "fft2 (X [, N] [, M])\n\
 \n\
 two dimensional fast fourier transform of a vector")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
diff --git a/src/filter.cc b/src/filter.cc
--- a/src/filter.cc
+++ b/src/filter.cc
@@ -143,17 +143,17 @@ filter (MArray<T>& b, MArray<T>& a, MArr
 
   int si_len = (a_len > b_len ? a_len : b_len) - 1;
 
   MArray<T> si (si_len, T (0.0));
 
   return filter (b, a, x, si);
 }
 
-DEFUN_DLD_BUILTIN (filter, args, ,
+DEFUN_DLD (filter, args, ,
   "usage: [y [, sf]] = filter (b, a, x [, si])\n\
 \n\
 y = filter (b, a, x) returns the solution to the following linear,\n\
 time-invariant difference equation:\n\
 \n\
   a[1] y[n] + ... + a[la] y[n-la+1] = b[1] x[n] + ... + b[lb] x[n-lb+1],\n\
 where la = length (a) and lb = length (b).\n\
 \n\
diff --git a/src/find.cc b/src/find.cc
--- a/src/find.cc
+++ b/src/find.cc
@@ -152,17 +152,17 @@ find_nonzero_elem_idx (const ComplexMatr
 	    count++;
 	  }
       }
 
   octave_value tmp (v, 1);
   return find_to_fortran_idx (i_idx, j_idx, tmp, m_nr, nargout);
 }
 
-DEFUN_DLD_BUILTIN (find, args, nargout,
+DEFUN_DLD (find, args, nargout,
   "find (X) or [I, J, V] = find (X): Return indices of nonzero elements")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 || nargout > 3)
     {
diff --git a/src/fsolve.cc b/src/fsolve.cc
--- a/src/fsolve.cc
+++ b/src/fsolve.cc
@@ -116,17 +116,17 @@ fsolve_user_function (const ColumnVector
 	}
       else
 	gripe_user_supplied_eval ("fsolve");
     }
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN (fsolve, args, nargout,
+DEFUN_DLD (fsolve, args, nargout,
   "Solve nonlinear equations using Minpack.  Usage:\n\
 \n\
   [X, INFO] = fsolve (F, X0)\n\
 \n\
 Where the first argument is the name of the  function to call to\n\
 compute the vector of function values.  It must have the form\n\
 \n\
   y = f (x)
@@ -275,17 +275,17 @@ show_fsolve_option (const string& keywor
       list++;
     }
 
   warning ("fsolve_options: no match for `%s'", keyword.c_str ());
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN (fsolve_options, args, ,
+DEFUN_DLD (fsolve_options, args, ,
   "fsolve_options (KEYWORD, VALUE)\n\
 \n\
 Set or show options for fsolve.  Keywords may be abbreviated\n\
 to the shortest match.")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
diff --git a/src/fsqp.cc b/src/fsqp.cc
--- a/src/fsqp.cc
+++ b/src/fsqp.cc
@@ -48,22 +48,22 @@ fsqp_constraint_function (const ColumnVe
 {
   ColumnVector retval;
   return retval;
 }
 
 #endif
 
 #if defined (FSQP_MISSING)
-DEFUN_DLD_BUILTIN (fsqp, , ,
+DEFUN_DLD (fsqp, , ,
   "This function requires FSQP, which is not freely\n\
 redistributable.  For more information, read the file\n\
 libcruft/fsqp/README.MISSING in the source distribution.")
 #else
-DEFUN_DLD_BUILTIN (fsqp, , ,
+DEFUN_DLD (fsqp, , ,
   "[X, PHI] = fsqp (X, PHI [, LB, UB] [, LB, A, UB] [, LB, G, UB])\n\
 \n\
 Groups of arguments surrounded in `[]' are optional, but\n\
 must appear in the same relative order shown above.")
 #endif
 {
 /*
 
@@ -83,22 +83,22 @@ Handle all of the following:
   octave_value_list retval;
 
   error ("fsqp: not implemented yet");
 
   return retval;
 }
 
 #if defined (FSQP_MISSING)
-DEFUN_DLD_BUILTIN (fsqp_options, , ,
+DEFUN_DLD (fsqp_options, , ,
   "This function requires FSQP, which is not freely\n\
 redistributable.  For more information, read the file\n\
 libcruft/fsqp/README.MISSING in the source distribution.")
 #else
-DEFUN_DLD_BUILTIN (fsqp_options, , ,
+DEFUN_DLD (fsqp_options, , ,
   "fsqp_options (KEYWORD, VALUE)\n\
 \n\
 Set or show options for fsqp.  Keywords may be abbreviated\n\
 to the shortest match.")
 #endif
 {
   octave_value_list retval;
 
diff --git a/src/getpwent.cc b/src/getpwent.cc
--- a/src/getpwent.cc
+++ b/src/getpwent.cc
@@ -74,33 +74,33 @@ mk_pw_map (struct passwd *pw)
        || defined (HAVE_ENDPWENT))
 static void
 gripe_not_implemented (const char *nm)
 {
   error ("%s: not implemented on this system", nm);
 }
 #endif
 
-DEFUN_DLD_BUILTIN (getpwent, , ,
+DEFUN_DLD (getpwent, , ,
  "getpwent ()\n\
 \n\
 Read an entry from the password-file stream, opening it if necessary.")
 {
   octave_value retval;
 
 #ifdef HAVE_GETPWENT
   retval = mk_pw_map (getpwent ());
 #else
   gripe_not_implemented ("getpwent");
 #endif
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN (getpwuid, args, ,
+DEFUN_DLD (getpwuid, args, ,
   "getpwuid (UID)\n\
 \n\
 Search for a password entry with a matching user ID.")
 {
   octave_value retval;
 
 #ifdef HAVE_GETPWUID
   int nargin = args.length ();
@@ -125,17 +125,17 @@ Search for a password entry with a match
     print_usage ("getpwuid");
 #else
   gripe_not_implemented ("getpwuid");
 #endif
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN (getpwnam, args, ,
+DEFUN_DLD (getpwnam, args, ,
   "getpwnam (NAME)\n\
 \n\
 Search for password entry with a matching username.")
 {
   octave_value retval;
 
 #ifdef HAVE_GETPWNAM
   int nargin = args.length ();
@@ -151,33 +151,33 @@ Search for password entry with a matchin
     print_usage ("getpwnam");
 #else
   gripe_not_implemented ("getpwnam");
 #endif
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN (setpwent, , ,
+DEFUN_DLD (setpwent, , ,
   "setpwent ()\n\
 \n\
 Rewind the password-file stream.")
 {
   octave_value retval;
 
 #ifdef HAVE_SETPWENT
   setpwent ();
 #else
   gripe_not_implemented ("setpwent");
 #endif
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN (endpwent, , ,
+DEFUN_DLD (endpwent, , ,
   "endpwent ()\n\
 \n\
 Close the password-file stream.")
 {
   octave_value retval;
 
 #ifdef HAVE_ENDPWENT
   endpwent ();
diff --git a/src/getrusage.cc b/src/getrusage.cc
--- a/src/getrusage.cc
+++ b/src/getrusage.cc
@@ -58,17 +58,17 @@ Software Foundation, 59 Temple Place - S
 #include "utils.h"
 
 #ifndef RUSAGE_SELF
 #define RUSAGE_SELF 0
 #endif
 
 // System resource functions.
 
-DEFUN_DLD_BUILTIN (getrusage, , ,
+DEFUN_DLD (getrusage, , ,
   "getrusage ()\n\
 \n\
 Return system resource statistics.")
 {
   Octave_map m;
   Octave_map tv_tmp;
 
 #if defined (HAVE_GETRUSAGE)
diff --git a/src/givens.cc b/src/givens.cc
--- a/src/givens.cc
+++ b/src/givens.cc
@@ -26,17 +26,17 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include "defun-dld.h"
 #include "error.h"
 #include "help.h"
 #include "oct-obj.h"
 
-DEFUN_DLD_BUILTIN (givens, args, nargout,
+DEFUN_DLD (givens, args, nargout,
   "G = givens (X, Y)\n\
 \n\
 compute orthogonal matrix G = [c s; -conj (s) c]\n\
 such that G [x; y] = [*; 0]  (x, y scalars)\n\
 \n\
 [c, s] = givens (x, y) returns the (c, s) values themselves.")
 {
   octave_value_list retval;
diff --git a/src/hess.cc b/src/hess.cc
--- a/src/hess.cc
+++ b/src/hess.cc
@@ -29,17 +29,17 @@ Software Foundation, 59 Temple Place - S
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD_BUILTIN (hess, args, nargout,
+DEFUN_DLD (hess, args, nargout,
   "[P, H] = hess (A) or H = hess (A): Hessenberg decomposition")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 || nargout > 2)
     {
diff --git a/src/ifft.cc b/src/ifft.cc
--- a/src/ifft.cc
+++ b/src/ifft.cc
@@ -29,17 +29,17 @@ Software Foundation, 59 Temple Place - S
 #include "gripes.h"
 #include "help.h"
 #include "mappers.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 // This function should be merged with Ffft.
 
-DEFUN_DLD_BUILTIN (ifft, args, ,
+DEFUN_DLD (ifft, args, ,
   "ifft (X [, N]): inverse fast fourier transform of a vector")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     {
diff --git a/src/ifft2.cc b/src/ifft2.cc
--- a/src/ifft2.cc
+++ b/src/ifft2.cc
@@ -29,17 +29,17 @@ Software Foundation, 59 Temple Place - S
 #include "gripes.h"
 #include "help.h"
 #include "mappers.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 // This function should be merged with Ffft2.
 
-DEFUN_DLD_BUILTIN (ifft2, args, ,
+DEFUN_DLD (ifft2, args, ,
   "ifft2 (X [, N] [, M])\n\
 \n\
 two dimensional inverse fast fourier transform of a vector") 
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
diff --git a/src/inv.cc b/src/inv.cc
--- a/src/inv.cc
+++ b/src/inv.cc
@@ -26,17 +26,17 @@ Software Foundation, 59 Temple Place - S
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD_BUILTIN (inv, args, ,
+DEFUN_DLD (inv, args, ,
   "inv (X): inverse of a square matrix")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
@@ -101,17 +101,17 @@ DEFUN_DLD_BUILTIN (inv, args, ,
 
   return retval;
 }
 
 // XXX FIXME XXX -- this should really be done with an alias, but
 // alias_builtin() won't do the right thing if we are actually using
 // dynamic linking.
 
-DEFUN_DLD_BUILTIN (inverse, args, nargout,
+DEFUN_DLD (inverse, args, nargout,
   "inverse (X): inverse of a square matrix")
 {
   return Finv (args, nargout);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/log.cc b/src/log.cc
--- a/src/log.cc
+++ b/src/log.cc
@@ -31,17 +31,17 @@ Software Foundation, 59 Temple Place - S
 #include "gripes.h"
 #include "help.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 // XXX FIXME XXX -- the next two functions should really be just
 // one...
 
-DEFUN_DLD_BUILTIN (logm, args, ,
+DEFUN_DLD (logm, args, ,
   "logm (X): matrix logarithm")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
@@ -143,17 +143,17 @@ DEFUN_DLD_BUILTIN (logm, args, ,
   else
     {
       gripe_wrong_type_arg ("logm", arg);
     }
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN (sqrtm, args, ,
+DEFUN_DLD (sqrtm, args, ,
  "sqrtm (X): matrix sqrt")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     {
diff --git a/src/lpsolve.cc b/src/lpsolve.cc
--- a/src/lpsolve.cc
+++ b/src/lpsolve.cc
@@ -26,34 +26,34 @@ Software Foundation, 59 Temple Place - S
 
 #include "LPsolve.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "help.h"
 #include "oct-obj.h"
 
-DEFUN_DLD_BUILTIN (lp_solve, , ,
+DEFUN_DLD (lp_solve, , ,
   "lp_solve (): solve linear programs using lp_solve.")
 {
   octave_value_list retval;
 
   // Force a bad value of inform, and empty matrices for x and phi.
 
   Matrix m;
   retval(2) = -1.0;
   retval(1) = m;
   retval(0) = m;
 
   error ("lp_solve: not implemented yet");
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN (lp_solve_options, , ,
+DEFUN_DLD (lp_solve_options, , ,
   "lp_solve_options (KEYWORD, VALUE)\n\
 \n\
 Set or show options for lp_solve.  Keywords may be abbreviated\n\
 to the shortest match.")
 {
   octave_value_list retval;
 
   error ("lp_solve_options: not implemented yet");
diff --git a/src/lsode.cc b/src/lsode.cc
--- a/src/lsode.cc
+++ b/src/lsode.cc
@@ -89,17 +89,17 @@ lsode_user_function (const ColumnVector&
 	}
       else
 	gripe_user_supplied_eval ("lsode");
     }
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN (lsode, args, nargout,
+DEFUN_DLD (lsode, args, nargout,
   "lsode (F, X0, T_OUT, T_CRIT)\n\
 \n\
 The first argument is the name of the function to call to\n\
 compute the vector of right hand sides.  It must have the form\n\
 \n\
   xdot = f (x, t)\n\
 \n\
 where xdot and x are vectors and t is a scalar.\n")
@@ -294,17 +294,17 @@ show_lsode_option (const string& keyword
       list++;
     }
 
   warning ("lsode_options: no match for `%s'", keyword.c_str ());
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN (lsode_options, args, ,
+DEFUN_DLD (lsode_options, args, ,
   "lsode_options (KEYWORD, VALUE)\n\
 \n\
 Set or show options for lsode.  Keywords may be abbreviated\n\
 to the shortest match.")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
diff --git a/src/lu.cc b/src/lu.cc
--- a/src/lu.cc
+++ b/src/lu.cc
@@ -29,17 +29,17 @@ Software Foundation, 59 Temple Place - S
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD_BUILTIN (lu, args, nargout,
+DEFUN_DLD (lu, args, nargout,
   "[L, U, P] = lu (A): LU factorization")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1 || nargout > 3)
     {
diff --git a/src/minmax.cc b/src/minmax.cc
--- a/src/minmax.cc
+++ b/src/minmax.cc
@@ -357,17 +357,17 @@ max (const ComplexMatrix& a, const Compl
 		result (i, j) = b (i, j);
 	    }
 	}
     }
 
   return result;
 }
 
-DEFUN_DLD_BUILTIN (min, args, nargout,
+DEFUN_DLD (min, args, nargout,
   "min (X): minimum value(s) of a vector (matrix)")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2 || nargout > 2)
     {
@@ -570,17 +570,17 @@ DEFUN_DLD_BUILTIN (min, args, nargout,
 	}
     }
   else
     panic_impossible ();
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN (max, args, nargout,
+DEFUN_DLD (max, args, nargout,
   "max (X): maximum value(s) of a vector (matrix)")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2 || nargout > 2)
     {
diff --git a/src/mk-oct-links.in b/src/mk-oct-links.in
--- a/src/mk-oct-links.in
+++ b/src/mk-oct-links.in
@@ -10,17 +10,17 @@
 LN_S="@LN_S@"
 
 links_dir=$1
 shift
 
 for f in "$@"; do
   base=`basename $f | sed 's/\.cc$//'`
   fcns=`grep -h '^ *DEFUN_DLD' $f |\
-        sed -e 's/DEFUN_DLD_BUILTIN *( *//' -e 's/ *,.*$//' |\
+        sed -e 's/DEFUN_DLD *( *//' -e 's/ *,.*$//' |\
         sort -u`
   if [ -n "$fcns" ]; then
     for n in $fcns; do
       if [ "$n" = "$base" ]; then
         true
       else
 	echo "creating link $n.oct -> $base.oct"
         ( cd $links_dir; rm -f $n.oct; $LN_S $base.oct $n.oct )
diff --git a/src/npsol.cc b/src/npsol.cc
--- a/src/npsol.cc
+++ b/src/npsol.cc
@@ -226,22 +226,22 @@ nonlinear_constraints_ok (const ColumnVe
 	}
     }
   return ok;
 }
 
 #endif
 
 #if defined (NPSOL_MISSING)
-DEFUN_DLD_BUILTIN (npsol, , ,
+DEFUN_DLD (npsol, , ,
   "This function requires NPSOL, which is not freely\n\
 redistributable.  For more information, read the file\n\
 libcruft/npsol/README.MISSING in the source distribution.")
 #else
-DEFUN_DLD_BUILTIN (npsol, args, nargout,
+DEFUN_DLD (npsol, args, nargout,
   "[X, OBJ, INFO, LAMBDA] = npsol (X, PHI [, LB, UB] [, A_LB, A, A_UB]\n\
                                 [, G_LB, G, G_UB])\n\
 \n\
 Groups of arguments surrounded in `[]' are optional, but\n\
 must appear in the same relative order shown above.\n\
 \n\
 The second argument is a string containing the name of the objective\n\
 function to call.  The objective function must be of the form\n\
@@ -765,22 +765,22 @@ show_npsol_option (const string& keyword
   warning ("npsol_options: no match for `%s'", keyword.c_str ());
 
   return retval;
 }
 
 #endif
 
 #if defined (NPSOL_MISSING)
-DEFUN_DLD_BUILTIN (npsol_options, , ,
+DEFUN_DLD (npsol_options, , ,
   "This function requires NPSOL, which is not freely\n\
 redistributable.  For more information, read the file\n\
 libcruft/npsol/README.MISSING in the source distribution.")
 #else
-DEFUN_DLD_BUILTIN (npsol_options, args, ,
+DEFUN_DLD (npsol_options, args, ,
   "npsol_options (KEYWORD, VALUE)\n\
 \n\
 Set or show options for npsol.  Keywords may be abbreviated\n\
 to the shortest match.")
 #endif
 {
   octave_value_list retval;
 
diff --git a/src/pinv.cc b/src/pinv.cc
--- a/src/pinv.cc
+++ b/src/pinv.cc
@@ -26,17 +26,17 @@ Software Foundation, 59 Temple Place - S
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD_BUILTIN (pinv, args, ,
+DEFUN_DLD (pinv, args, ,
   "pinv ( [, tol])\n\
 Returns the pseudoinverse of X; singular values less than tol are ignored.")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
diff --git a/src/qpsol.cc b/src/qpsol.cc
--- a/src/qpsol.cc
+++ b/src/qpsol.cc
@@ -76,22 +76,22 @@ linear_constraints_ok (const ColumnVecto
   return ok;
 }
 
 static QPSOL_options qpsol_opts;
 
 #endif
 
 #if defined (QPSOL_MISSING)
-DEFUN_DLD_BUILTIN (qpsol, , ,
+DEFUN_DLD (qpsol, , ,
   "This function requires QPSOL, which is not freely\n\
 redistributable.  For more information, read the file\n\
 libcruft/qpsol/README.MISSING in the source distribution.")
 #else
-DEFUN_DLD_BUILTIN (qpsol, args, nargout,
+DEFUN_DLD (qpsol, args, nargout,
   "[X, OBJ, INFO, LAMBDA] = qpsol (X, H, C [, LB, UB] [, A_LB, A, A_UB])\n\
 \n\
 Groups of arguments surrounded in `[]' are optional, but\n\
 must appear in the same relative order shown above.")
 #endif
 {
 /*
 
@@ -406,22 +406,22 @@ show_qpsol_option (const string& keyword
   warning ("qpsol_options: no match for `%s'", keyword.c_str ());
 
   return retval;
 }
 
 #endif
 
 #if defined (QPSOL_MISSING)
-DEFUN_DLD_BUILTIN (qpsol_options, , ,
+DEFUN_DLD (qpsol_options, , ,
   "This function requires QPSOL, which is not freely\n\
 redistributable.  For more information, read the file\n\
 libcruft/qpsol/README.MISSING in the source distribution.")
 #else
-DEFUN_DLD_BUILTIN (qpsol_options, args, ,
+DEFUN_DLD (qpsol_options, args, ,
   "qpsol_options (KEYWORD, VALUE)\n
 \n\
 Set or show options for qpsol.  Keywords may be abbreviated\n\
 to the shortest match.")
 #endif
 {
   octave_value_list retval;
 
diff --git a/src/qr.cc b/src/qr.cc
--- a/src/qr.cc
+++ b/src/qr.cc
@@ -31,17 +31,17 @@ Software Foundation, 59 Temple Place - S
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD_BUILTIN (qr, args, nargout,
+DEFUN_DLD (qr, args, nargout,
   "[Q, R] = qr (X):      form Q unitary and R upper triangular such\n\
                        that Q * R = X\n\
 \n\
 [Q, R] = qr (X, 0):    form the economy decomposition such that if X is\n\
                        if X is m by n then only the first n columns of Q\n\
                        are computed.\n\
 \n\
 [Q, R, P] = qr (X):    form QRP factorization of X where\n\
diff --git a/src/quad.cc b/src/quad.cc
--- a/src/quad.cc
+++ b/src/quad.cc
@@ -80,17 +80,17 @@ quad_user_function (double x)
 	  quad_integration_error = 1;  // XXX FIXME XXX
 	  gripe_user_supplied_eval ("quad");
 	}
     }
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN (quad, args, nargout,
+DEFUN_DLD (quad, args, nargout,
   "[V, IER, NFUN] = quad (F, A, B [, TOL] [, SING])\n\
 \n\
 Where the first argument is the name of the  function to call to\n\
 compute the value of the integrand.  It must have the form\n\
 \n\
   y = f (x)
 \n\
 where y and x are scalars.\n\
@@ -347,17 +347,17 @@ show_quad_option (const string& keyword)
       list++;
     }
 
   warning ("quad_options: no match for `%s'", keyword.c_str ());
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN (quad_options, args, ,
+DEFUN_DLD (quad_options, args, ,
   "quad_options (KEYWORD, VALUE)\n\
 \n\
 Set or show options for quad.  Keywords may be abbreviated\n\
 to the shortest match.")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
diff --git a/src/qzval.cc b/src/qzval.cc
--- a/src/qzval.cc
+++ b/src/qzval.cc
@@ -29,17 +29,17 @@ Software Foundation, 59 Temple Place - S
 #include <cfloat>
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "oct-obj.h"
 
-DEFUN_DLD_BUILTIN (qzval, args, ,
+DEFUN_DLD (qzval, args, ,
   "X = qzval (A, B)\n\
 \n\
 compute generalized eigenvalues of the matrix pencil (A - lambda B).\n\
 A and B must be real matrices.")
 {
   octave_value retval;
 
   int nargin = args.length ();
diff --git a/src/rand.cc b/src/rand.cc
--- a/src/rand.cc
+++ b/src/rand.cc
@@ -320,17 +320,17 @@ do_rand (const octave_value_list& args, 
       retval(0) = rand_mat;
     }
   else
     error ("rand: invalid negative argument");
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN (rand, args, nargout,
+DEFUN_DLD (rand, args, nargout,
   "rand            -- generate a random value from a uniform distribution\n\
 \n\
 rand (N)        -- generate N x N matrix\n\
 rand (size (A)) -- generate matrix the size of A\n\
 rand (N, M)     -- generate N x M matrix\n\
 rand (SEED)     -- get current seed\n\
 rand (SEED, N)  -- set seed\n\
 \n\
@@ -354,17 +354,17 @@ See also: randn")
 }
 
 static void
 reset_rand_generator (void *)
 {
   F77_FCN (setcgn, SETCGN) (current_distribution);
 }
 
-DEFUN_DLD_BUILTIN (randn, args, nargout,
+DEFUN_DLD (randn, args, nargout,
   "randn            -- generate a random value from a normal distribution\n\
 \n\
 randn (N)        -- generate N x N matrix\n\
 randn (size (A)) -- generate matrix the size of A\n\
 randn (N, M)     -- generate N x M matrix\n\
 randn (SEED)     -- get current seed\n\
 randn (SEED, N)  -- set seed\n\
 \n\
diff --git a/src/schur.cc b/src/schur.cc
--- a/src/schur.cc
+++ b/src/schur.cc
@@ -31,17 +31,17 @@ Software Foundation, 59 Temple Place - S
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD_BUILTIN (schur, args, nargout,
+DEFUN_DLD (schur, args, nargout,
   "[U, S] = schur (A) or S = schur (A)\n\
 \n\
 or, for ordered Schur:\n\
 \n\
   [U, S] = schur (A, TYPE) or S = schur (A, TYPE)\n\
 where TYPE is a string that begins with one of the following\n\
 characters:\n\
 \n\
diff --git a/src/sort.cc b/src/sort.cc
--- a/src/sort.cc
+++ b/src/sort.cc
@@ -303,17 +303,17 @@ mx_sort (ComplexRowVector& cv)
     }
 
   retval (1) = octave_value (idx, 0);
   retval (0) = octave_value (cvs, 0);
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN (sort, args, nargout,
+DEFUN_DLD (sort, args, nargout,
   "[S, I] = sort (X)\n\
 \n\
 sort the columns of X, optionally return sort index")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
diff --git a/src/svd.cc b/src/svd.cc
--- a/src/svd.cc
+++ b/src/svd.cc
@@ -31,17 +31,17 @@ Software Foundation, 59 Temple Place - S
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "mappers.h"
 #include "oct-obj.h"
 #include "pr-output.h"
 #include "utils.h"
 
-DEFUN_DLD_BUILTIN (svd, args, nargout,
+DEFUN_DLD (svd, args, nargout,
   "S = svd (X) or [U, S, V] = svd (X [, 0])\n\
 \n\
 Compute the singular value decomposition of X.  Given a second input\n\
 argument, an `economy' sized factorization is computed that omits\n\
 unnecessary rows and columns of U and V.\n\
 \n\
 X may not contain any Inf or NaN values.")
 {
diff --git a/src/syl.cc b/src/syl.cc
--- a/src/syl.cc
+++ b/src/syl.cc
@@ -28,17 +28,17 @@ Software Foundation, 59 Temple Place - S
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-DEFUN_DLD_BUILTIN (syl, args, nargout,
+DEFUN_DLD (syl, args, nargout,
   "X = syl (A, B, C): solve the Sylvester equation A X + X B + C = 0")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 3 || nargout > 1)
     {
diff --git a/src/time.cc b/src/time.cc
--- a/src/time.cc
+++ b/src/time.cc
@@ -84,17 +84,17 @@ extract_tm (Octave_map &m, double& fract
 #ifdef HAVE_TMZONE
   string tstr = m ["zone"] . string_value ();
   tm.tm_zone = tstr.c_str ();
 #endif
 
   return &tm;
 }
 
-DEFUN_DLD_BUILTIN (time, , ,
+DEFUN_DLD (time, , ,
   "time ()\n\
 \n\
 Return current time.  On Unix systems, this is the number of\n\
 seconds since the epoch.")
 {
   time_t now;
   double fraction = 0.0;
 
@@ -116,17 +116,17 @@ seconds since the epoch.")
 
   now = time (0);
 
 #endif
  
   return (double) now + fraction;
 }
 
-DEFUN_DLD_BUILTIN (gmtime, args, ,
+DEFUN_DLD (gmtime, args, ,
   "gmtime (TIME)\n\
 \n\
 Given a value returned from time(), return a structure like that\n\
 returned from localtime() but with values corresponding to\n\
 Coordinated Universal Time (UTC).")
 {
   octave_value_list retval;
 
@@ -144,17 +144,17 @@ Coordinated Universal Time (UTC).")
 	}
     }
   else
     print_usage ("gmtime");
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN (localtime, args, ,
+DEFUN_DLD (localtime, args, ,
   "localtime (TIME)\n\
 \n\
 Given a value returned from time(), return a structure with\n\
 the following elements:\n\
 \n\
   usec  : microseconds after the second (0, 999999)\n\
   sec   : seconds after the minute (0, 61)\n\
   min   : minutes after the hour (0, 59)\n\
@@ -183,17 +183,17 @@ the following elements:\n\
 	}
     }
   else
     print_usage ("localtime");
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN (mktime, args, ,
+DEFUN_DLD (mktime, args, ,
   "mktime (TMSTRUCT)")
 {
   octave_value_list retval;
 
   if (args.length () == 1 && args(0).is_map ()) 
     {
       Octave_map map = args(0).map_value ();
 
@@ -205,17 +205,17 @@ DEFUN_DLD_BUILTIN (mktime, args, ,
 	retval = (double) mktime (tm) + fraction;
     }
   else
     print_usage ("mktime");
 
   return retval;
 }
 
-DEFUN_DLD_BUILTIN (strftime, args, ,
+DEFUN_DLD (strftime, args, ,
   "strftime (FMT, TMSTRUCT)\n\
 \n\
 Performs `%' substitutions similar to those in printf.  Except where\n\
 noted, substituted fields have a fixed size; numeric fields are\n\
 padded if necessary.  Padding is with zeros by default; for fields\n\
 that display a single number, padding can be changed or inhibited by\n\
 following the `%' with one of the modifiers described below.\n\
 Unknown field specifiers are copied as normal characters.  All other\n\
