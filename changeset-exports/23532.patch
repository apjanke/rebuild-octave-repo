# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1495732397 14400
#      Thu May 25 13:13:17 2017 -0400
# Node ID 084245f9bd03d8f8e67515636f0746a8fa4c2eac
# Parent  60695e6ef4163e67cad7b7d77f9140933adfce78
pass reference to evaluator to octave_function call methods

* interpreter-private.h, interpreter-private.cc: (__get_evaluator__):
New function.

* interpreter.h, interpreter.cc (interpreter::m_evaluator):
Now a reference instead of a pointer.  Change all uses.
(interpreter::get_evaluator): New function.
(intrepreter::current_evaluator): Delete.  Replace all uses with
__get_evaluator__.

* ov-fcn.h, ov-fcn.cc (octave_function::call): Pass reference to
tree_evaluator.  Change all functions in derived classes and all
uses.
(octave_function::subsref): Delete.

* ov-usr-fcn.h, ov-usr-fcn.cc (octave_user_script::subsref): Delete.

* pt-eval.h, pt-eval.cc (tree_evaluator::m_interpreter): Now a
reference instead of a pointer.  Change all uses.

* ov-classdef.h, ov-classdef.cc (execute_ov): Delete.  Replaces uses
with calls to feval.
(octave_classdef_superclass_ref::subsref): Delete.

diff --git a/libinterp/corefcn/defun.cc b/libinterp/corefcn/defun.cc
--- a/libinterp/corefcn/defun.cc
+++ b/libinterp/corefcn/defun.cc
@@ -177,20 +177,22 @@ get_current_shlib (void)
             = dynamic_cast<octave_mex_function *> (curr_fcn);
           retval = mex->get_shlib ();
         }
     }
 
   return retval;
 }
 
-bool defun_isargout (int nargout, int iout)
+bool
+defun_isargout (int nargout, int iout)
 {
-  const std::list<octave_lvalue> *lvalue_list
-    = octave::current_evaluator->lvalue_list ();
+  octave::tree_evaluator& tw = octave::__get_evaluator__ ("defun_isargout");
+
+  const std::list<octave_lvalue> *lvalue_list = tw.lvalue_list ();
 
   if (iout >= std::max (nargout, 1))
     return false;
   else if (lvalue_list)
     {
       int k = 0;
       for (const auto& lval : *lvalue_list)
         {
@@ -202,20 +204,22 @@ bool defun_isargout (int nargout, int io
         }
 
       return true;
     }
   else
     return true;
 }
 
-void defun_isargout (int nargout, int nout, bool *isargout)
+void
+defun_isargout (int nargout, int nout, bool *isargout)
 {
-  const std::list<octave_lvalue> *lvalue_list
-    = octave::current_evaluator->lvalue_list ();
+  octave::tree_evaluator& tw = octave::__get_evaluator__ ("defun_isargout");
+
+  const std::list<octave_lvalue> *lvalue_list = tw.lvalue_list ();
 
   if (lvalue_list)
     {
       int k = 0;
       for (const auto& lval : *lvalue_list)
         {
           if (lval.is_black_hole ())
             isargout[k++] = false;
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -689,16 +689,18 @@ get_debug_input (const std::string& prom
 
       app->interactive (true);
 
       app->forced_interactive (true);
     }
 
   octave::parser curr_parser;
 
+  octave::tree_evaluator& tw = octave::__get_evaluator__ ("get_debug_input");
+
   while (Vdebugging)
     {
       try
         {
           Vtrack_line_num = false;
 
           reset_error_handler ();
 
@@ -707,17 +709,17 @@ get_debug_input (const std::string& prom
           int retval = curr_parser.run ();
 
           if (octave::command_editor::interrupt (false))
             break;
           else
             {
               if (retval == 0 && curr_parser.stmt_list)
                 {
-                  curr_parser.stmt_list->accept (*octave::current_evaluator);
+                  curr_parser.stmt_list->accept (tw);
 
                   if (octave_completion_matches_called)
                     octave_completion_matches_called = false;
                 }
 
               octave_quit ();
             }
         }
diff --git a/libinterp/corefcn/interpreter-private.cc b/libinterp/corefcn/interpreter-private.cc
--- a/libinterp/corefcn/interpreter-private.cc
+++ b/libinterp/corefcn/interpreter-private.cc
@@ -44,9 +44,16 @@ namespace octave
   }
 
   load_path& __get_load_path__ (const std::string& who)
   {
     interpreter& interp = __get_interpreter__ (who);
 
     return interp.get_load_path ();
   }
+
+  tree_evaluator& __get_evaluator__ (const std::string& who)
+  {
+    interpreter& interp = __get_interpreter__ (who);
+
+    return interp.get_evaluator ();
+  }
 }
diff --git a/libinterp/corefcn/interpreter-private.h b/libinterp/corefcn/interpreter-private.h
--- a/libinterp/corefcn/interpreter-private.h
+++ b/libinterp/corefcn/interpreter-private.h
@@ -26,15 +26,18 @@ along with Octave; see the file COPYING.
 #include "octave-config.h"
 
 #include <string>
 
 namespace octave
 {
   class interpreter;
   class load_path;
+  class tree_evaluator;
 
   extern interpreter& __get_interpreter__ (const std::string& who);
 
   extern load_path& __get_load_path__ (const std::string& who);
+
+  extern tree_evaluator& __get_evaluator__ (const std::string& who);
 }
 
 #endif
diff --git a/libinterp/corefcn/interpreter.cc b/libinterp/corefcn/interpreter.cc
--- a/libinterp/corefcn/interpreter.cc
+++ b/libinterp/corefcn/interpreter.cc
@@ -356,37 +356,33 @@ execute_pkg_add (const std::string& dir)
   catch (const octave::execution_exception&)
     {
       octave::interpreter::recover_from_exception ();
     }
 }
 
 namespace octave
 {
-  tree_evaluator *current_evaluator = nullptr;
-
   // Create an interpreter object and perform initialization up to the
   // point of setting reading command history and setting the load
   // path.
 
   interpreter::interpreter (application *app_context)
-    : m_app_context (app_context), m_evaluator (new tree_evaluator (this)),
+    : m_app_context (app_context), m_evaluator (new tree_evaluator (*this)),
       m_load_path (), m_interactive (false), m_read_site_files (true),
       m_read_init_files (m_app_context != 0), m_verbose (false),
       m_inhibit_startup_message (false), m_load_path_initialized (false),
       m_history_initialized (false), m_initialized (false)
   {
     if (instance)
       throw std::runtime_error
         ("only one Octave interpreter object may be active");
 
     instance = this;
 
-    current_evaluator = m_evaluator;
-
     // Matlab uses "C" locale for LC_NUMERIC class regardless of local setting
     setlocale (LC_NUMERIC, "C");
     setlocale (LC_TIME, "C");
     octave::sys::env::putenv ("LC_NUMERIC", "C");
     octave::sys::env::putenv ("LC_TIME", "C");
 
     // Initialize the default floating point unit control state.
     octave_set_default_fpucw ();
@@ -506,19 +502,16 @@ namespace octave
 
   interpreter *interpreter::instance = nullptr;
 
   interpreter::~interpreter (void)
   {
     cleanup ();
 
     instance = 0;
-    current_evaluator = 0;
-
-    delete m_evaluator;
   }
 
   // Read the history file unless a command-line option inhibits that.
 
   void interpreter::initialize_history (bool read_history_file)
   {
     if (! m_history_initialized)
       {
@@ -1130,16 +1123,21 @@ namespace octave
     // .oct files to be unregistered when the .oct file shared library
     // is unloaded.
     //
     // OCTAVE_SAFE_CALL (singleton_cleanup_list::cleanup, ());
 
     OCTAVE_SAFE_CALL (octave::chunk_buffer::clear, ());
   }
 
+  tree_evaluator& interpreter::get_evaluator (void)
+  {
+    return *m_evaluator;
+  }
+
   void interpreter::recover_from_exception (void)
   {
     octave::can_interrupt = true;
     octave_interrupt_immediately = 0;
     octave_interrupt_state = 0;
     octave_signal_caught = 0;
     octave_exception_state = octave_no_exception;
     octave_restore_signal_mask ();
diff --git a/libinterp/corefcn/interpreter.h b/libinterp/corefcn/interpreter.h
--- a/libinterp/corefcn/interpreter.h
+++ b/libinterp/corefcn/interpreter.h
@@ -40,18 +40,16 @@ extern OCTINTERP_API bool octave_interpr
 
 // TRUE means we've processed all the init code and we are good to go.
 extern OCTINTERP_API bool octave_initialized;
 
 namespace octave
 {
   class tree_evaluator;
 
-  extern tree_evaluator *current_evaluator;
-
   // The application object contains a pointer to the current
   // interpreter and the interpreter contains a pointer back to the
   // application context so we need a forward declaration for one (or
   // both) of them...
 
   class application;
 
   class OCTINTERP_API interpreter
@@ -132,16 +130,18 @@ namespace octave
       return m_initialized;
     }
 
     load_path& get_load_path (void)
     {
       return m_load_path;
     }
 
+    tree_evaluator& get_evaluator (void);
+
     static void recover_from_exception (void);
 
     static void add_atexit_function (const std::string& fname);
 
     static bool remove_atexit_function (const std::string& fname);
 
     static interpreter * the_interpreter (void) { return instance; }
 
diff --git a/libinterp/octave-value/ov-builtin.cc b/libinterp/octave-value/ov-builtin.cc
--- a/libinterp/octave-value/ov-builtin.cc
+++ b/libinterp/octave-value/ov-builtin.cc
@@ -36,17 +36,18 @@ along with Octave; see the file COPYING.
 #include "unwind-prot.h"
 
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_builtin,
                                      "built-in function",
                                      "built-in function");
 
 octave_value_list
-octave_builtin::call (int nargout, const octave_value_list& args)
+octave_builtin::call (octave::tree_evaluator&, int nargout,
+                      const octave_value_list& args)
 {
   octave_value_list retval;
 
   if (args.has_magic_colon ())
     error ("invalid use of colon in function argument list");
 
   octave::unwind_protect frame;
 
diff --git a/libinterp/octave-value/ov-builtin.h b/libinterp/octave-value/ov-builtin.h
--- a/libinterp/octave-value/ov-builtin.h
+++ b/libinterp/octave-value/ov-builtin.h
@@ -33,16 +33,17 @@ along with Octave; see the file COPYING.
 #include "ov-typeinfo.h"
 
 class octave_value;
 class octave_value_list;
 class jit_type;
 
 namespace octave
 {
+  class tree_evaluator;
   class interpreter;
 }
 
 // Builtin functions.
 
 class
 OCTINTERP_API
 octave_builtin : public octave_function
@@ -81,17 +82,18 @@ public:
   ~octave_builtin (void) = default;
 
   std::string src_file_name (void) const { return file; }
 
   octave_function * function_value (bool = false) { return this; }
 
   bool is_builtin_function (void) const { return true; }
 
-  octave_value_list call (int nargout, const octave_value_list& args);
+  octave_value_list call (octave::tree_evaluator& tw, int nargout,
+                          const octave_value_list& args);
 
   jit_type * to_jit (void) const;
 
   void stash_jit (jit_type& type);
 
   fcn function (void) const;
 
   meth method (void) const;
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -142,26 +142,16 @@ make_fcn_handle (const octave_value& fcn
   octave_value retval;
 
   if (fcn.is_defined ())
     retval = octave_value (new octave_fcn_handle (fcn, nm));
 
   return retval;
 }
 
-inline octave_value_list
-execute_ov (octave_value val, const octave_value_list& args, int nargout)
-{
-  std::list<octave_value_list> idx (1, args);
-
-  std::string type ("(");
-
-  return val.subsref (type, idx, nargout);
-}
-
 static cdef_class
 lookup_class (const std::string& name, bool error_if_not_found = true,
               bool load_if_not_found = true)
 {
   return cdef_manager::find_class (name, error_if_not_found,
                                    load_if_not_found);
 }
 
@@ -420,17 +410,18 @@ is_dummy_method (const octave_value& fcn
     retval = true;
 
   return retval;
 }
 
 static bool
 is_method_executing (const octave_value& ov, const cdef_object& obj)
 {
-  octave::tree_evaluator *tw = octave::current_evaluator;
+  octave::tree_evaluator& tw
+    = octave::__get_evaluator__ ("is_method_executing");
 
   octave_function *stack_fcn = octave::call_stack::current ();
 
   octave_function *method_fcn = ov.function_value (true);
 
   // Does the top of the call stack match our target function?
 
   if (stack_fcn && stack_fcn == method_fcn)
@@ -451,17 +442,17 @@ is_method_executing (const octave_value&
 
           octave::tree_parameter_list *pl = uf->is_classdef_constructor ()
             ? uf->return_list () : uf->parameter_list ();
 
           if (pl && pl->size () > 0)
             {
               octave::tree_decl_elt *elt = pl->front ();
 
-              octave_value arg0 = tw->evaluate (elt);
+              octave_value arg0 = tw.evaluate (elt);
 
               if (arg0.is_defined () && arg0.type_name () == "object")
                 {
                   cdef_object arg0_obj = to_cdef (arg0);
 
                   return obj.is (arg0_obj);
                 }
             }
@@ -1003,37 +994,29 @@ public:
   { object.meta_release (); }
 
   octave_function * function_value (bool = false) { return this; }
 
   octave_value_list
   subsref (const std::string& type,
            const std::list<octave_value_list>& idx,
            int nargout)
-  { return object.meta_subsref (type, idx, nargout); }
-
-  octave_value
-  subsref (const std::string& type,
-           const std::list<octave_value_list>& idx)
   {
-    octave_value_list retval;
-
-    retval = subsref (type, idx, 1);
-
-    return (retval.length () > 0 ? retval(0) : octave_value ());
+    return object.meta_subsref (type, idx, nargout);
   }
 
-  octave_value_list call (int nargout, const octave_value_list& idx)
+  octave_value_list call (octave::tree_evaluator&, int nargout,
+                          const octave_value_list& args)
   {
     // Emulate ()-type meta subsref
 
-    std::list<octave_value_list> l (1, idx);
+    std::list<octave_value_list> idx (1, args);
     std::string type ("(");
 
-    return subsref (type, l, nargout);
+    return subsref (type, idx, nargout);
   }
 
   bool accepts_postfix_index (char type) const
   { return object.meta_accepts_postfix_index (type); }
 
   bool
   is_classdef_constructor (const std::string& cname = "") const
   {
@@ -1067,54 +1050,17 @@ public:
   octave_classdef_superclass_ref (const octave_value_list& a)
     : octave_function (), args (a) { }
 
   ~octave_classdef_superclass_ref (void) = default;
 
   octave_function * function_value (bool = false) { return this; }
 
   octave_value_list
-  subsref (const std::string& type,
-           const std::list<octave_value_list>& idx,
-           int nargout)
-  {
-    size_t skip = 0;
-    octave_value_list retval;
-
-    switch (type[0])
-      {
-      case '(':
-        skip = 1;
-        retval = call (type.length () > 1 ? 1 : nargout, idx.front ());
-        break;
-      default:
-        retval = call (1, octave_value_list ());
-        break;
-      }
-
-    if (type.length () > skip && idx.size () > skip
-        && retval.length () > 0)
-      retval = retval(0).next_subsref (nargout, type, idx, skip);
-
-    return retval;
-  }
-
-  octave_value
-  subsref (const std::string& type,
-           const std::list<octave_value_list>& idx)
-  {
-    octave_value_list retval;
-
-    retval = subsref (type, idx, 1);
-
-    return (retval.length () > 0 ? retval(0) : octave_value ());
-  }
-
-  octave_value_list
-  call (int nargout, const octave_value_list& idx)
+  call (octave::tree_evaluator&, int nargout, const octave_value_list& idx)
   {
     octave_value_list retval;
 
     std::string meth_name;
     bool in_constructor;
     cdef_class ctx;
 
     ctx = get_class_context (meth_name, in_constructor);
@@ -2873,17 +2819,17 @@ cdef_property::cdef_property_rep::get_va
   if (get_fcn.is_empty () || is_method_executing (get_fcn, obj))
     retval = obj.get (get ("Name").string_value ());
   else
     {
       octave_value_list args;
 
       args(0) = to_ov (obj);
 
-      args = execute_ov (get_fcn, args, 1);
+      args = octave::feval (get_fcn, args, 1);
 
       retval = args(0);
     }
 
   return retval;
 }
 
 octave_value
@@ -2927,17 +2873,17 @@ cdef_property::cdef_property_rep::set_va
     obj.put (get ("Name").string_value (), val);
   else
     {
       octave_value_list args;
 
       args(0) = to_ov (obj);
       args(1) = val;
 
-      args = execute_ov (set_fcn, args, 1);
+      args = octave::feval (set_fcn, args, 1);
 
       if (args.length () > 0 && args(0).is_defined ())
         {
           if (args (0).is_classdef_object ())
             {
               cdef_object new_obj = to_cdef (args(0));
 
               obj = new_obj;
@@ -3034,17 +2980,17 @@ cdef_method::cdef_method_rep::execute (c
 
   if (get ("Abstract").bool_value ())
     error ("%s: cannot execute abstract method",
            get ("Name").string_value ().c_str ());
 
   check_method ();
 
   if (function.is_defined ())
-    retval = execute_ov (function, args, nargout);
+    retval = octave::feval (function, args, nargout);
 
   return retval;
 }
 
 octave_value_list
 cdef_method::cdef_method_rep::execute (const cdef_object& obj,
                                        const octave_value_list& args,
                                        int nargout, bool do_check_access,
@@ -3066,17 +3012,17 @@ cdef_method::cdef_method_rep::execute (c
       octave_value_list new_args;
 
       new_args.resize (args.length () + 1);
 
       new_args(0) = to_ov (obj);
       for (int i = 0; i < args.length (); i++)
         new_args(i+1) = args(i);
 
-      retval = execute_ov (function, new_args, nargout);
+      retval = octave::feval (function, new_args, nargout);
     }
 
   return retval;
 }
 
 bool
 cdef_method::cdef_method_rep::is_constructor (void) const
 {
diff --git a/libinterp/octave-value/ov-fcn.cc b/libinterp/octave-value/ov-fcn.cc
--- a/libinterp/octave-value/ov-fcn.cc
+++ b/libinterp/octave-value/ov-fcn.cc
@@ -37,53 +37,8 @@ octave_function::clone (void) const
 }
 
 octave_base_value *
 octave_function::empty_clone (void) const
 {
   panic_impossible ();
   return 0;
 }
-
-octave_value_list
-octave_function::subsref (const std::string& type,
-                          const std::list<octave_value_list>& idx,
-                          int nargout)
-{
-  octave_value_list retval;
-
-  switch (type[0])
-    {
-    case '(':
-      {
-        int tmp_nargout = (type.length () > 1 && nargout == 0) ? 1 : nargout;
-
-        retval = call (tmp_nargout, idx.front ());
-      }
-      break;
-
-    case '{':
-    case '.':
-      {
-        std::string nm = type_name ();
-        error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
-      }
-      break;
-
-    default:
-      panic_impossible ();
-    }
-
-  // FIXME: perhaps there should be an
-  // octave_value_list::next_subsref member function?  See also
-  // octave_user_function::subsref.
-  //
-  // FIXME: Note that if a function call returns multiple
-  // values, and there is further indexing to perform, then we are
-  // ignoring all but the first value.  Is this really what we want to
-  // do?  If it is not, then what should happen for stat("file").size,
-  // for exmaple?
-
-  if (idx.size () > 1)
-    retval = retval(0).next_subsref (nargout, type, idx);
-
-  return retval;
-}
diff --git a/libinterp/octave-value/ov-fcn.h b/libinterp/octave-value/ov-fcn.h
--- a/libinterp/octave-value/ov-fcn.h
+++ b/libinterp/octave-value/ov-fcn.h
@@ -32,16 +32,17 @@ along with Octave; see the file COPYING.
 
 #include "ovl.h"
 #include "ov-base.h"
 #include "ov-typeinfo.h"
 #include "symtab.h"
 
 namespace octave
 {
+  class tree_evaluator;
   class tree_walker;
 }
 
 // Functions.
 
 class
 OCTINTERP_API
 octave_function : public octave_base_value
@@ -194,31 +195,19 @@ public:
   virtual void unload (void) { }
 
   virtual void accept (octave::tree_walker&) { }
 
   virtual bool accepts_postfix_index (char type) const
   { return (type == '('); }
 
   virtual octave_value_list
-  call (int nargout = 0,
+  call (octave::tree_evaluator& tw, int nargout = 0,
         const octave_value_list& args = octave_value_list ()) = 0;
 
-  octave_value subsref (const std::string& type,
-                        const std::list<octave_value_list>& idx)
-  {
-    octave_value_list tmp = subsref (type, idx, 1);
-    return tmp.length () > 0 ? tmp(0) : octave_value ();
-  }
-
-  octave_value_list
-  subsref (const std::string& type,
-           const std::list<octave_value_list>& idx,
-           int nargout);
-
 protected:
 
   octave_function (const std::string& nm,
                    const std::string& ds = "")
     : relative (false), locked (false), private_function (false),
       xdispatch_class (), my_name (nm), my_dir_name (), doc (ds) { }
 
   // TRUE if this function was found from a relative path element.
diff --git a/libinterp/octave-value/ov-mex-fcn.cc b/libinterp/octave-value/ov-mex-fcn.cc
--- a/libinterp/octave-value/ov-mex-fcn.cc
+++ b/libinterp/octave-value/ov-mex-fcn.cc
@@ -78,17 +78,18 @@ octave_mex_function::time_parsed (void) 
 }
 
 // FIXME: shouldn't this declaration be a header file somewhere?
 extern octave_value_list
 call_mex (octave_mex_function& curr_mex_fcn, const octave_value_list& args,
           int nargout);
 
 octave_value_list
-octave_mex_function::call (int nargout, const octave_value_list& args)
+octave_mex_function::call (octave::tree_evaluator&, int nargout,
+                           const octave_value_list& args)
 {
   octave_value_list retval;
 
   if (args.has_magic_colon ())
     error ("invalid use of colon in function argument list");
 
   octave::unwind_protect frame;
 
diff --git a/libinterp/octave-value/ov-mex-fcn.h b/libinterp/octave-value/ov-mex-fcn.h
--- a/libinterp/octave-value/ov-mex-fcn.h
+++ b/libinterp/octave-value/ov-mex-fcn.h
@@ -31,16 +31,21 @@ along with Octave; see the file COPYING.
 
 #include "ov-fcn.h"
 #include "ov-builtin.h"
 #include "ov-typeinfo.h"
 
 class octave_value;
 class octave_value_list;
 
+namespace octave
+{
+  class tree_evaluator;
+}
+
 // Dynamically-linked functions.
 
 class
 octave_mex_function : public octave_function
 {
 public:
 
   octave_mex_function (void)
@@ -75,17 +80,18 @@ public:
   octave::sys::time time_checked (void) const { return m_time_checked; }
 
   bool is_system_fcn_file (void) const { return m_is_system_fcn_file; }
 
   bool is_builtin_function (void) const { return false; }
 
   bool is_mex_function (void) const { return true; }
 
-  octave_value_list call (int nargout, const octave_value_list& args);
+  octave_value_list call (octave::tree_evaluator& tw, int nargout,
+                          const octave_value_list& args);
 
   void atexit (void (*fcn) (void)) { m_exit_fcn_ptr = fcn; }
 
   octave::dynamic_library get_shlib (void) const { return m_sh_lib; }
 
   void *mex_fcn_ptr (void) const { return m_mex_fcn_ptr; }
 
   bool is_fmex (void) const { return m_is_fmex; }
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -107,24 +107,18 @@ octave_user_script::~octave_user_script 
 {
   if (cmd_list)
     cmd_list->remove_all_breakpoints (file_name);
 
   delete cmd_list;
 }
 
 octave_value_list
-octave_user_script::subsref (const std::string&,
-                             const std::list<octave_value_list>&, int)
-{
-  error ("invalid use of script %s in index expression", file_name.c_str ());
-}
-
-octave_value_list
-octave_user_script::call (int nargout, const octave_value_list& args)
+octave_user_script::call (octave::tree_evaluator& tw, int nargout,
+                          const octave_value_list& args)
 {
   octave_value_list retval;
 
   octave::unwind_protect frame;
 
   if (args.length () != 0 || nargout != 0)
     error ("invalid call to script %s", file_name.c_str ());
 
@@ -145,19 +139,17 @@ octave_user_script::call (int nargout, c
       Vtrack_line_num = true;
 
       frame.protect_var (octave::tree_evaluator::statement_context);
       octave::tree_evaluator::statement_context = octave::tree_evaluator::script;
 
       profile_data_accumulator::enter<octave_user_script>
         block (profiler, *this);
 
-      octave::tree_evaluator *tw = octave::current_evaluator;
-
-      cmd_list->accept (*tw);
+      cmd_list->accept (tw);
 
       if (octave::tree_return_command::returning)
         octave::tree_return_command::returning = 0;
 
       if (octave::tree_break_command::breaking)
         octave::tree_break_command::breaking--;
     }
 
@@ -400,17 +392,18 @@ octave_user_function::all_va_args (const
 
   if (n > 0)
     retval = args.slice (num_named_args, n);
 
   return retval;
 }
 
 octave_value_list
-octave_user_function::call (int nargout, const octave_value_list& _args)
+octave_user_function::call (octave::tree_evaluator& tw, int nargout,
+                            const octave_value_list& _args)
 {
   octave_value_list retval;
 
   if (! cmd_list)
     return retval;
 
   // If this function is a classdef constructor, extract the first input
   // argument, which must be the partially constructed object instance.
@@ -458,47 +451,45 @@ octave_user_function::call (int nargout,
     {
       symbol_table::push_context ();
 
       frame.add_fcn (symbol_table::pop_context);
     }
 
   string_vector arg_names = args.name_tags ();
 
-  octave::tree_evaluator *tw = octave::current_evaluator;
-
   if (param_list && ! param_list->varargs_only ())
-    tw->define_parameter_list_from_arg_vector (param_list, args);
+    tw.define_parameter_list_from_arg_vector (param_list, args);
 
   // For classdef constructor, pre-populate the output arguments
   // with the pre-initialized object instance, extracted above.
 
   if (is_classdef_constructor ())
     {
       if (! ret_list)
         error ("%s: invalid classdef constructor, no output argument defined",
                dispatch_class ().c_str ());
 
-      tw->define_parameter_list_from_arg_vector (ret_list, ret_args);
+      tw.define_parameter_list_from_arg_vector (ret_list, ret_args);
     }
 
   // Force parameter list to be undefined when this function exits.
   // Doing so decrements the reference counts on the values of local
   // variables that are also named function parameters.
 
   if (param_list)
-    frame.add_method (tw, &octave::tree_evaluator::undefine_parameter_list,
+    frame.add_method (&tw, &octave::tree_evaluator::undefine_parameter_list,
                       param_list);
 
   // Force return list to be undefined when this function exits.
   // Doing so decrements the reference counts on the values of local
   // variables that are also named values returned by this function.
 
   if (ret_list)
-    frame.add_method (tw, &octave::tree_evaluator::undefine_parameter_list,
+    frame.add_method (&tw, &octave::tree_evaluator::undefine_parameter_list,
                       ret_list);
 
   if (call_depth == 0)
     {
       // Force symbols to be undefined again when this function
       // exits.
       //
       // This cleanup function is added to the unwind_protect stack
@@ -543,50 +534,50 @@ octave_user_function::call (int nargout,
         octave::tree_statement *stmt = cmd_list->front ();
 
         octave::tree_expression *expr = stmt->expression ();
 
         if (expr)
           {
             octave::call_stack::set_location (stmt->line (), stmt->column ());
 
-            retval = tw->evaluate_n (expr, nargout);
+            retval = tw.evaluate_n (expr, nargout);
           }
       }
     else
-      cmd_list->accept (*tw);
+      cmd_list->accept (tw);
   }
 
   if (echo_commands)
     print_code_function_trailer ();
 
   if (octave::tree_return_command::returning)
     octave::tree_return_command::returning = 0;
 
   if (octave::tree_break_command::breaking)
     octave::tree_break_command::breaking--;
 
   // Copy return values out.
 
   if (ret_list && ! is_special_expr ())
     {
-      tw->initialize_undefined_parameter_list_elements (ret_list, my_name,
-                                                        nargout, Matrix ());
+      tw.initialize_undefined_parameter_list_elements (ret_list, my_name,
+                                                       nargout, Matrix ());
 
       Cell varargout;
 
       if (ret_list->takes_varargs ())
         {
           octave_value varargout_varval = symbol_table::varval ("varargout");
 
           if (varargout_varval.is_defined ())
             varargout = varargout_varval.xcell_value ("varargout must be a cell array object");
         }
 
-      retval = tw->convert_parameter_list_to_const_vector (ret_list, nargout, varargout);
+      retval = tw.convert_parameter_list_to_const_vector (ret_list, nargout, varargout);
     }
 
   return retval;
 }
 
 void
 octave_user_function::accept (octave::tree_walker& tw)
 {
@@ -641,17 +632,17 @@ octave_user_function::print_code_functio
 {
   octave::tree_print_code tpc (octave_stdout, VPS4);
 
   tpc.visit_octave_user_function_trailer (*this);
 }
 
 void
 octave_user_function::bind_automatic_vars
-  (octave::tree_evaluator *tw, const string_vector& arg_names,
+  (octave::tree_evaluator& tw, const string_vector& arg_names,
    int nargin, int nargout, const octave_value_list& va_args)
 {
   if (! arg_names.empty ())
     {
       // It is better to save this in the hidden variable .argn. and
       // then use that in the inputname function instead of using argn,
       // which might be redefined in a function.  Keep the old argn name
       // for backward compatibility of functions that use it directly.
@@ -678,17 +669,17 @@ octave_user_function::bind_automatic_var
   symbol_table::assign (".saved_warning_states.");
 
   symbol_table::mark_automatic (".saved_warning_states.");
   symbol_table::mark_automatic (".saved_warning_states.");
 
   if (takes_varargs ())
     symbol_table::assign ("varargin", va_args.cell_value ());
 
-  Matrix ignored_fcn_outputs = tw ? tw->ignored_fcn_outputs () : Matrix ();
+  Matrix ignored_fcn_outputs = tw.ignored_fcn_outputs ();
 
   symbol_table::assign (".ignored.", ignored_fcn_outputs);
 
   symbol_table::mark_hidden (".ignored.");
   symbol_table::mark_automatic (".ignored.");
 }
 
 void
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -129,21 +129,18 @@ public:
   }
 
   std::string fcn_file_name (void) const { return file_name; }
 
   octave::sys::time time_parsed (void) const { return t_parsed; }
 
   octave::sys::time time_checked (void) const { return t_checked; }
 
-  octave_value_list subsref (const std::string& type,
-                             const std::list<octave_value_list>& idx,
-                             int nargout);
-
-  octave_value_list call (int nargout, const octave_value_list& args);
+  octave_value_list call (octave::tree_evaluator& tw, int nargout,
+                          const octave_value_list& args);
 
   octave::tree_statement_list * body (void) { return cmd_list; }
 
   void accept (octave::tree_walker& tw);
 
 private:
 
   // The list of commands that make up the body of this function.
@@ -347,17 +344,18 @@ public:
   void mark_as_class_method (void) { class_method = true; }
 
   bool is_class_method (const std::string& cname = "") const
   {
     return class_method
            ? (cname.empty () ? true : cname == dispatch_class ()) : false;
   }
 
-  octave_value_list call (int nargout, const octave_value_list& args);
+  octave_value_list call (octave::tree_evaluator& tw, int nargout,
+                          const octave_value_list& args);
 
   octave::tree_parameter_list * parameter_list (void) { return param_list; }
 
   octave::tree_parameter_list * return_list (void) { return ret_list; }
 
   octave::tree_statement_list * body (void) { return cmd_list; }
 
   octave_comment_list * leading_comment (void) { return lead_comm; }
@@ -484,17 +482,17 @@ private:
 #endif
 
   void maybe_relocate_end_internal (void);
 
   void print_code_function_header (void);
 
   void print_code_function_trailer (void);
 
-  void bind_automatic_vars (octave::tree_evaluator *tw,
+  void bind_automatic_vars (octave::tree_evaluator& tw,
                             const string_vector& arg_names,
                             int nargin, int nargout,
                             const octave_value_list& va_args);
 
   void restore_warning_states (void);
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -541,19 +541,19 @@ namespace octave
         comment_list = 0;
       }
 
     private:
 
       octave_comment_list *comment_list;
     };
 
-    base_lexer (interpreter *interp_context = nullptr)
+    base_lexer (interpreter *interp = nullptr)
       : lexical_feedback (), scanner (0), input_buf (), comment_buf (),
-        m_interp_context (interp_context)
+        m_interpreter (interp)
     {
       init ();
     }
 
     // No copying!
 
     base_lexer (const base_lexer&) = delete;
 
@@ -648,17 +648,17 @@ namespace octave
 
     // Object that reads and buffers input.
     input_buffer input_buf;
 
     // Object that collects comment text.
     comment_buffer comment_buf;
 
     // Interpreter that contains us, if any.
-    interpreter *m_interp_context;
+    interpreter *m_interpreter;
 
     virtual void increment_promptflag (void) = 0;
 
     virtual void decrement_promptflag (void) = 0;
 
     virtual int promptflag (void) const = 0;
 
     virtual int promptflag (int) = 0;
@@ -715,27 +715,26 @@ namespace octave
     std::stack<int> start_state_stack;
   };
 
   class
   lexer : public base_lexer
   {
   public:
 
-    lexer (interpreter *interp_context = nullptr)
-      : base_lexer (interp_context), reader (this)
+    lexer (interpreter *interp = nullptr)
+      : base_lexer (interp), reader (this)
     { }
 
-    lexer (FILE *file, interpreter *interp_context = nullptr)
-      : base_lexer (interp_context), reader (file, this)
+    lexer (FILE *file, interpreter *interp = nullptr)
+      : base_lexer (interp), reader (file, this)
     { }
 
-    lexer (const std::string& eval_string,
-           interpreter *interp_context = nullptr)
-      : base_lexer (interp_context), reader (eval_string, this)
+    lexer (const std::string& eval_string, interpreter *interp = nullptr)
+      : base_lexer (interp), reader (eval_string, this)
     { }
 
     // No copying!
 
     lexer (const lexer&) = delete;
 
     lexer& operator = (const lexer&) = delete;
 
@@ -779,38 +778,37 @@ namespace octave
     input_reader reader;
   };
 
   class
   push_lexer : public base_lexer
   {
   public:
 
-    push_lexer (interpreter *interp_context = nullptr)
-      : base_lexer (interp_context), pflag (1)
+    push_lexer (interpreter *interp = nullptr)
+      : base_lexer (interp), pflag (1)
     {
       append_input ("", false);
     }
 
-    push_lexer (const std::string& input,
-                interpreter *interp_context = nullptr)
-      : base_lexer (interp_context), pflag (1)
+    push_lexer (const std::string& input, interpreter *interp = nullptr)
+      : base_lexer (interp), pflag (1)
     {
       append_input (input, false);
     }
 
-    push_lexer (bool eof, interpreter *interp_context = nullptr)
-      : base_lexer (interp_context), pflag (1)
+    push_lexer (bool eof, interpreter *interp = nullptr)
+      : base_lexer (interp), pflag (1)
     {
       append_input ("", eof);
     }
 
     push_lexer (const std::string& input, bool eof,
-                interpreter *interp_context = nullptr)
-      : base_lexer (interp_context), pflag (1)
+                interpreter *interp = nullptr)
+      : base_lexer (interp), pflag (1)
     {
       append_input (input, eof);
     }
 
     // No copying!
 
     push_lexer (const push_lexer&) = delete;
 
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -2353,17 +2353,20 @@ namespace octave
       {
         if (limit)
           {
             if (base->is_constant () && limit->is_constant ()
                 && (! incr || (incr && incr->is_constant ())))
               {
                 try
                   {
-                    octave_value tmp = octave::current_evaluator->evaluate (e);
+                    octave::tree_evaluator& tw
+                      = __get_evaluator__ ("finish_colon_expression");
+
+                    octave_value tmp = tw.evaluate (e);
 
                     tree_constant *tc_retval
                       = new tree_constant (tmp, base->line (), base->column ());
 
                     std::ostringstream buf;
 
                     tree_print_code tpc (buf);
 
@@ -3916,17 +3919,20 @@ namespace octave
 
   tree_argument_list *
   base_parser::validate_matrix_for_assignment (tree_expression *e)
   {
     tree_argument_list *retval = 0;
 
     if (e->is_constant ())
       {
-        octave_value ov = octave::current_evaluator->evaluate (e);
+        octave::tree_evaluator& tw
+          = __get_evaluator__ ("validate_matrix_for_assignment");
+
+        octave_value ov = tw.evaluate (e);
 
         delete e;
 
         if (ov.is_empty ())
           bison_error ("invalid empty left hand side of assignment");
         else
           bison_error ("invalid constant left hand side of assignment");
       }
@@ -3984,17 +3990,20 @@ namespace octave
 
     discard_error_messages = true;
     discard_warning_messages = true;
 
     if (array_list->all_elements_are_constant ())
       {
         try
           {
-            octave_value tmp = octave::current_evaluator->evaluate (array_list);
+            octave::tree_evaluator& tw
+              = __get_evaluator__ ("finish_array_list");
+
+            octave_value tmp = tw.evaluate (array_list);
 
             tree_constant *tc_retval
               = new tree_constant (tmp, array_list->line (),
                                    array_list->column ());
 
             std::ostringstream buf;
 
             tree_print_code tpc (buf);
@@ -4339,18 +4348,21 @@ parse_fcn_file (const std::string& full_
               // meta.class info (and stash it in the symbol
               // table?).  Return pointer to constructor?
 
               if (fcn_ptr)
                 panic_impossible ();
 
               bool is_at_folder = ! dispatch_type.empty ();
 
-              fcn_ptr =
-                parser.classdef_object->make_meta_class (octave::current_evaluator, is_at_folder);
+              octave::tree_evaluator& tw
+                = octave::__get_evaluator__ ("parse_fcn_file");
+
+              fcn_ptr
+                = parser.classdef_object->make_meta_class (&tw, is_at_folder);
 
               delete (parser.classdef_object);
 
               parser.classdef_object = 0;
             }
           else if (fcn_ptr)
             {
               fcn_ptr->maybe_relocate_end ();
@@ -4803,17 +4815,19 @@ namespace octave
       }
 
     if (verbose)
       {
         std::cout << "executing commands from " << full_name << " ... ";
         std::cout.flush ();
       }
 
-    fcn->call ();
+    tree_evaluator& tw = __get_evaluator__ ("source");
+
+    fcn->call (tw, 0);
 
     if (verbose)
       std::cout << "done." << std::endl;
 
     // Delete scripts not on the path, so they don't shadow ones that are.
     if (delete_fcn)
       delete fcn;
   }
@@ -4932,33 +4946,39 @@ namespace octave
   feval (const std::string& name, const octave_value_list& args, int nargout)
   {
     octave_value_list retval;
 
     octave_value fcn = symbol_table::find_function (name, args);
 
     if (fcn.is_defined ())
       {
+        tree_evaluator& tw = __get_evaluator__ ("feval");
+
         octave_function *of = fcn.function_value ();
 
-        retval = of->call (nargout, args);
+        retval = of->call (tw, nargout, args);
       }
     else
       error ("feval: function '%s' not found", name.c_str ());
 
     return retval;
   }
 
   octave_value_list
   feval (octave_function *fcn, const octave_value_list& args, int nargout)
   {
     octave_value_list retval;
 
     if (fcn)
-      retval = fcn->call (nargout, args);
+      {
+        tree_evaluator& tw = __get_evaluator__ ("feval");
+
+        retval = fcn->call (tw, nargout, args);
+      }
 
     return retval;
   }
 
   octave_value_list
   feval (octave_value& val, const octave_value_list& args, int nargout)
   {
     if (val.is_function ())
@@ -5130,16 +5150,18 @@ namespace octave
         parse_status = parser.run ();
 
         if (parse_status == 0)
           {
             if (parser.stmt_list)
               {
                 tree_statement *stmt = 0;
 
+                octave::tree_evaluator& tw = __get_evaluator__ ("eval_string");
+
                 if (parser.stmt_list->length () == 1
                     && (stmt = parser.stmt_list->front ())
                     && stmt->is_expression ())
                   {
                     tree_expression *expr = stmt->expression ();
 
                     if (silent)
                       expr->set_print_flag (false);
@@ -5151,26 +5173,26 @@ namespace octave
                         tree_identifier *id
                           = dynamic_cast<tree_identifier *> (expr);
 
                         do_bind_ans = (! id->is_variable ());
                       }
                     else
                       do_bind_ans = (! expr->is_assignment_expression ());
 
-                    retval = octave::current_evaluator->evaluate_n (expr, nargout);
+                    retval = tw.evaluate_n (expr, nargout);
 
                     if (do_bind_ans && ! retval.empty ())
                       bind_ans (retval(0), expr->print_result ());
 
                     if (nargout == 0)
                       retval = octave_value_list ();
                   }
                 else if (nargout == 0)
-                  parser.stmt_list->accept (*octave::current_evaluator);
+                  parser.stmt_list->accept (tw);
                 else
                   error ("eval: invalid use of statement list");
 
                 if (tree_return_command::returning
                     || tree_break_command::breaking
                     || tree_continue_command::continuing)
                   break;
               }
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -980,17 +980,17 @@ namespace octave
         if (val.is_function ())
           fcn = val.function_value (true);
 
         int nargout = m_nargout_stack.top ();
 
         if (fcn && ! (expr.is_postfix_indexed ()
                       && fcn->accepts_postfix_index (expr.postfix_index ())))
           {
-            retval = fcn->call (nargout);
+            retval = fcn->call (*this, nargout);
           }
         else
           {
             if (expr.print_result () && nargout == 0
                 && octave::tree_evaluator::statement_printing_enabled ())
               {
                 octave_value_list args = ovl (val);
                 args.stash_name_tags (string_vector (expr.name ()));
@@ -1213,17 +1213,17 @@ namespace octave
 
             if (val.is_function ())
               fcn = val.function_value (true);
 
             if (fcn)
               {
                 try
                   {
-                    retval = fcn->call (nargout, first_args);
+                    retval = fcn->call (*this, nargout, first_args);
                   }
                 catch (octave::index_exception& e)
                   {
                     final_index_error (e, expr);
                   }
 
                 beg++;
                 p_args++;
@@ -1815,17 +1815,17 @@ namespace octave
         // used for superclass references in classdef.
 
         octave_value val = retval(0);
         octave_function *f = val.function_value (true);
 
         if (f && ! (expr.is_postfix_indexed ()
                     && f->accepts_postfix_index (expr.postfix_index ())))
           {
-            retval = f->call (nargout);
+            retval = f->call (*this, nargout);
           }
       }
 
     m_value_stack.push (retval);
   }
 
   void
   tree_evaluator::visit_parameter_list (tree_parameter_list&)
diff --git a/libinterp/parse-tree/pt-eval.h b/libinterp/parse-tree/pt-eval.h
--- a/libinterp/parse-tree/pt-eval.h
+++ b/libinterp/parse-tree/pt-eval.h
@@ -97,19 +97,19 @@ namespace octave
 
     private:
 
       std::stack<T> m_stack;
     };
 
     typedef void (*decl_elt_init_fcn) (tree_decl_elt&);
 
-    tree_evaluator (interpreter *interp_context)
+    tree_evaluator (interpreter& interp)
       : m_value_stack (), m_lvalue_list_stack (), m_nargout_stack (),
-        m_interp_context (interp_context)
+        m_interpreter (interp)
     { }
 
     // No copying!
 
     tree_evaluator (const tree_evaluator&) = delete;
 
     tree_evaluator& operator = (const tree_evaluator&) = delete;
 
@@ -312,17 +312,17 @@ namespace octave
     std::list<octave_lvalue> make_lvalue_list (tree_argument_list *);
 
     value_stack<octave_value_list> m_value_stack;
 
     value_stack<const std::list<octave_lvalue>*> m_lvalue_list_stack;
 
     value_stack<int> m_nargout_stack;
 
-    interpreter *m_interp_context;
+    interpreter& m_interpreter;
   };
 }
 
 // Maximum nesting level for functions, scripts, or sourced files called
 // recursively.
 extern int Vmax_recursion_depth;
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
