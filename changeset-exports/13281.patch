# HG changeset patch
# User Michael Goffioul <michael.goffioul@gmail.com>
# Date 1317915858 -3600
#      Thu Oct 06 16:44:18 2011 +0100
# Node ID 834f904a3dcbdc16c046341207783dcfbe1a6ee0
# Parent  c60a059a18bc8f4cb1e81f079a319651ad53e4cb
Add support for full asynchronous graphics toolkit running in a separate
thread. Add uicontrol and uipanel implementation.

* oct-mutex.h (octave_base_mutex::try_lock): New method.
(octave_mutex::try_lock): Likewise.
(octave_auto_lock::octave_auto_lock): New argument for
blocking/non-blocking locks.
(octave_auto_lock::ok): New method to test locking state.
(octave_auto_lock::operator bool): Likewise.
(octave_thread): New utility class.
* oct-mutex.cc (octave_base_mutex::try_lock): New method.
(octave_w32_mutex::try_lock): Implement it for Win32.
(octave_pthread_mutex::try_lock): Implement it for pthread.
(octave_thread): Implement new utility class.
* octave.cc (octave_main): Initialize octave_thread.

* genprops.awk (emit_get_string_array): New function.
(emit_declarations): Use it for string_array_property.

* graphics.h.in (base_property::set): New argument to control toolkit
notifying.
(property::set): Likewise.
(string_array_property::string_vector_value): New method.
(radio_property::do_set): Add warning about abbreviated radio values.
(base_graphics_toolkit::initialize): Returns bool.
(graphics_toolkit::initialize): Likewise.
(base_graphics_object::toolkit_flag): New member.
(base_graphics_object::base_graphics_object): Initialize it.
(base_graphics_object::valid_toolkit_object): New method.
(base_graphics_object::initialize, base_graphics_object::finalize,
base_graphics_object::update): Likewise.
(graphics_object::initialize, graphics_object::finalize,
graphics_object::update): Likewise.
(figure::properties::set_toolkit): Move implementation to source file.
(base_properties::get_boundingbox): Add parent size argument for optimization.
(figure::properties::get_boundingbox): Likewise.
(axes::properties::get_boundingbox): Likewise.
(figure::properties::map_from_boundingbox): New utility method.
(figure::properties::map_to_boundingbox): Likewise.
(axes::properties::get_fontsize_points): New utility method.
(text::properties::get_fontsize_points): Likewise.
(axes::properties::xlabel, axes::properties::ylabel, axes::properties::zlabel,
axes::properties::title): Don't notify toolkit on initialization.
(axes::initialize): New method override.
(uicontrol): New class.
(uipanel): Likewise.
(graphics_event::create_callback_event): New static method overload.
(graphics_event::create_set_event): New argument to prevent circular
behavior when property change is triggered from the toolkit.
(gh_manager::post_set): Likewise.
(gh_manager::do_post_set): Likewise.
(gh_manager::make_graphics_handle): New argument controlling toolkit notify.
(gh_manager::make_figure_handle): Likewise.
(gh_manager::do_make_graphics_handle): Likewise.
(gh_manager::do_make_figure_handle): Likewise.
(gh_manager::try_lock): New static method.
(gh_manager::execute_listener): Likewise.
(gh_manager::enable_event_processing): Likewise.
(gh_manager::do_try_lock): New method.
(gh_manager::do_execute_listener): Likewise.
(gh_manager::do_enable_event_processing): Likewise.
(gh_manager::event_processing): New member.
(gh_manager::execute_callback): Protect graphics_object access.
(gh_manager::auto_lock): Inherits from octave_autolock. Renamed from autolock.
(gh_manager::auto_lock::auto_lock): New blocking/non-blocking argument.
* graphics.cc (default_control_position, default_control_sliderstep,
default_panel_position): New utility functions.
(convert_font_size): New utility function.
(convert_position): Support 2D-only positions.
(lookup_object_name): Support uicontrol and uipanel.
(make_graphics_object_from_type): Likewise.
(root_figure::init_factory_properties): Likewise.
(property_list::set, property_list::lookup): Likewise.
(base_property::set): New argument controlling toolkit notifying.
(base_property::run_listeners): Call gh_manager::execute_listener, allowing
to set a property from another thread and run listeners synchronously with
octave.
(color_property::do_set): Add warning about abbreviated radio value.
(double_radio_property::do_set): Likewise.
(finalize_r, initialize_r, xinitialize): New utility functions.
(gh_manager::do_free): Calls graphics_object::finalize.
(base_graphics_toolkit::initialize): Returns bool.
(gnuplot_toolkit::initialize): Likewise.
(figure::properties::set_toolkit): Move implementation from header.
(figure::properties::get_boundingbox): New argument for parent size.
(axes::properties::get_boundingbox): Likewise.
(figure::properties::map_from_boundingbox): New utility method.
(figure::properties::map_to_boundingbox): Likewise.
(axes::properties::update_fontunits): Use convert_font_size.
(axes::properties::get_fontsize_points): New utility method.
(text::properties::get_fontsize_points): Likewise.
(axes::initialize): New method override to trigger initialization of
labels and title.
(uicontrol): New class.
(uipanel): Likewise.
(gh_manager::gh_manager): Initialize new event_processing member.
(gh_manager::do_make_graphics_handle): New argument controlling toolkit
notifying.
(gh_manager::do_make_figure_handle): Likewise.
(callback_event::callback): New member.
(callback_event::callback_event): Initialize it.
(callback_event::execute): Use it.
(set_event::notify_toolkit): New member.
(set_event::set_event): Initialize it.
(set_event::execute): Use it. Also allow to set read-only properties.
(graphics_event::create_callback_event): New static method overload.
(graphics_event::create_set_event): New argument controlling toolkit notifying.
(gh_manager::do_restore_gcbo): Rename autolock to auto_lock.
(gh_manager::do_post_callback, gh_manager::do_post_function): Likewise.
(Fishandle, Fset, Fget, F__get__): Likewise.
(F__go_figure__, F__calc_dimensions__, GO_BODY): Likewise.
(F__go_delete__, F__go_axes_init__, F__go_handles__, F__go_figure_handles__,
Favailable_graphics_toolkits, Faddlistener, Fdellistener, Faddproperty):
Likewise.
(get_property_from_handle, set_property_in_handle): Likewise.
(gh_manager::do_post_set): Likewise. New argument controlling toolkit
notifying.
(gh_manager::do_execute_listener): New method.
(gh_manager::do_enable_event_processing): Likewise.
(gh_manager::do_execute_callback): Check callback argument validity.
Rename autolock to auto_lock.
(gh_manager::do_process_events): Execute drawnow at the end of event
processing loop, avoiding recursivity. Maintain the input event hook
if gh_manager::event_processing is non zero.
(make_graphics_object): Postpone object's toolkit initialization at
the end of the object creation.
(F__go_figure__): Likewise.
(F__go_uicontrol__, F__go_uipanel__): New functions.
* __init_fltk__.cc (fltk_graphics_toolkit::initialise): New method.

* gl-render.h (opengl_renderer::draw): New argument to identify top-level
calls.
(opengl_renderer::draw_uipanel): New method.
(opengl_renderer::init_gl_context): Likewise.
* gl-render.cc (opengl_renderer::draw): New argument to identify top-level
calls. Skip uicontrol objects. Handle uipanel objects when top-level.
(opengl_renderer::init_gl_context): New method.
(opengl_renderer::draw_figure): Use it.
(opengl_renderer::draw_uipanel): New method.

diff --git a/liboctave/oct-mutex.cc b/liboctave/oct-mutex.cc
--- a/liboctave/oct-mutex.cc
+++ b/liboctave/oct-mutex.cc
@@ -40,16 +40,24 @@ octave_base_mutex::lock (void)
 }
 
 void
 octave_base_mutex::unlock (void)
 {
   (*current_liboctave_error_handler) ("mutex not supported on this platform");
 }
 
+bool
+octave_base_mutex::try_lock (void)
+{
+  (*current_liboctave_error_handler) ("mutex not supported on this platform");
+
+  return false;
+}
+
 #if defined (__WIN32__) && ! defined (__CYGWIN__)
 
 class
 octave_w32_mutex : public octave_base_mutex
 {
 public:
   octave_w32_mutex (void)
     : octave_base_mutex ()
@@ -67,20 +75,39 @@ public:
     EnterCriticalSection (&cs);
   }
 
   void unlock (void)
   {
     LeaveCriticalSection (&cs);
   }
 
+  bool try_lock (void)
+  {
+    return (TryEnterCriticalSection (&cs) != 0);
+  }
+
 private:
   CRITICAL_SECTION cs;
 };
 
+static DWORD octave_thread_id = 0; 
+
+void
+octave_thread::init (void)
+{
+  octave_thread_id = GetCurrentThreadId ();
+}
+
+bool
+octave_thread::is_octave_thread (void)
+{
+  return (GetCurrentThreadId () == octave_thread_id);
+}
+
 #elif defined (HAVE_PTHREAD_H)
 
 class
 octave_pthread_mutex : public octave_base_mutex
 {
 public:
   octave_pthread_mutex (void)
     : octave_base_mutex (), pm ()
@@ -103,20 +130,39 @@ public:
     pthread_mutex_lock (&pm);
   }
 
   void unlock (void)
   {
     pthread_mutex_unlock (&pm);
   }
 
+  bool try_lock (void)
+  {
+    return (pthread_mutex_trylock (&pm) == 0);
+  }
+
 private:
   pthread_mutex_t pm;
 };
 
+static pthread_t octave_thread_id = 0;
+
+void
+octave_thread::init (void)
+{
+  octave_thread_id = pthread_self ();
+}
+
+bool
+octave_thread::is_octave_thread (void)
+{
+  return (pthread_equal (octave_thread_id, pthread_self ()) != 0);
+}
+
 #endif
 
 static octave_base_mutex *
 init_rep (void)
 {
 #if defined (__WIN32__) && ! defined (__CYGWIN__)
   return new octave_w32_mutex ();
 #elif defined (HAVE_PTHREAD_H)
diff --git a/liboctave/oct-mutex.h b/liboctave/oct-mutex.h
--- a/liboctave/oct-mutex.h
+++ b/liboctave/oct-mutex.h
@@ -34,16 +34,18 @@ public:
   octave_base_mutex (void) : count (1) { }
 
   virtual ~octave_base_mutex (void) { }
 
   virtual void lock (void);
 
   virtual void unlock (void);
 
+  virtual bool try_lock (void);
+
 private:
   int count;
 };
 
 class
 OCTAVE_API
 octave_mutex
 {
@@ -81,39 +83,66 @@ public:
     rep->lock ();
   }
 
   void unlock (void)
   {
     rep->unlock ();
   }
 
+  bool try_lock (void)
+  {
+    return rep->try_lock ();
+  }
+
 protected:
   octave_base_mutex *rep;
 };
 
 class
 octave_autolock
 {
 public:
-  octave_autolock (const octave_mutex& m)
-    : mutex (m)
+  octave_autolock (const octave_mutex& m, bool block = true)
+    : mutex (m), lock_result (false)
   {
-    mutex.lock ();
+    if (block)
+      {
+        mutex.lock ();
+        lock_result = true;
+      }
+    else
+      lock_result = mutex.try_lock ();
   }
 
   ~octave_autolock (void)
   {
-    mutex.unlock ();
+    if (lock_result)
+      mutex.unlock ();
   }
 
+  bool ok (void) const { return lock_result; }
+
+  operator bool (void) const { return ok (); }
+
 private:
 
   // No copying or default constructor!
   octave_autolock (void);
   octave_autolock (const octave_autolock&);
   octave_autolock& operator = (const octave_autolock&);
 
 private:
   octave_mutex mutex;
+  bool lock_result;
+};
+
+class
+OCTAVE_API
+octave_thread
+{
+public:
+  static void init (void);
+
+  static bool is_octave_thread (void);
 };
 
 #endif
diff --git a/src/DLD-FUNCTIONS/__init_fltk__.cc b/src/DLD-FUNCTIONS/__init_fltk__.cc
--- a/src/DLD-FUNCTIONS/__init_fltk__.cc
+++ b/src/DLD-FUNCTIONS/__init_fltk__.cc
@@ -1784,16 +1784,19 @@ class fltk_graphics_toolkit : public bas
 public:
   fltk_graphics_toolkit (void)
     : base_graphics_toolkit (FLTK_GRAPHICS_TOOLKIT_NAME) { }
 
   ~fltk_graphics_toolkit (void) { }
 
   bool is_valid (void) const { return true; }
 
+  bool initialize (const graphics_object& go)
+    { return go.isa ("figure"); }
+
   void finalize (const graphics_object& go)
   {
     if (go.isa ("figure"))
       {
         octave_value ov = go.get (caseless_str ("__plot_stream__"));
 
         if (! ov.is_empty ())
           figure_manager::delete_window (ov.string_value ());
diff --git a/src/genprops.awk b/src/genprops.awk
--- a/src/genprops.awk
+++ b/src/genprops.awk
@@ -236,16 +236,37 @@ function emit_get_callback (i)
 
 ## array_property
 
 function emit_get_array (i)
 {
   emit_get_accessor(i, "octave_value", "get");
 }
 
+## string_array_property
+
+function emit_get_string_array (i)
+{
+  printf ("  std::string get_%s_string (void) const", name[i]);
+
+  if (emit_get[i] == "definition")
+    printf (" { return %s.string_value (); }\n", name[i]);
+  else
+    printf (";\n");
+
+  printf ("  string_vector get_%s_vector (void) const", name[i]);
+
+  if (emit_get[i] == "definition")
+    printf (" { return %s.string_vector_value (); }\n", name[i]);
+  else
+    printf (";\n");
+
+  emit_get_accessor(i, "octave_value", "get");
+}
+
 ## common section
 
 function emit_common_declarations ()
 {
   printf ("public:\n");
   printf ("  properties (const graphics_handle& mh, const graphics_handle& p);\n\n");
   printf ("  ~properties (void) { }\n\n");
   printf ("  void set (const caseless_str& pname, const octave_value& val);\n\n");
@@ -295,34 +316,35 @@ function emit_declarations ()
     if (emit_get[i])
     {
       if (type[i] == "any_property")
         emit_get_accessor(i, "octave_value", "get");
       else if (type[i] == "handle_property")
         emit_get_accessor(i, "graphics_handle", "handle_value");
       else if (type[i] == "string_property")
         emit_get_accessor(i, "std::string", "string_value");
-      else if (type[i] == "string_array_property" \
-               || type[i] == "text_label_property")
+      else if (type[i] == "text_label_property")
         emit_get_accessor(i, "octave_value", "get");
       else if (type[i] == "double_property")
         emit_get_accessor(i, "double", "double_value");
       else if (type[i] == "double_radio_property")
         emit_get_double_radio(i);
       else if (type[i] == "array_property" \
                || type[i] == "row_vector_property")
         emit_get_array(i);
       else if (type[i] == "bool_property")
         emit_get_bool(i);
       else if (type[i] == "radio_property")
         emit_get_radio(i);
       else if (type[i] == "color_property")
         emit_get_color(i);
       else if (type[i] == "callback_property")
         emit_get_callback(i);
+      else if (type[i] == "string_array_property")
+        emit_get_string_array(i);
       else
       {
         printf ("  %s get_%s (void) const", type[i], name[i]);
 
         if (emit_get[i] == "definition")
           printf (" { return %s; }\n", name[i]);
         else
           printf (";\n");
diff --git a/src/gl-render.cc b/src/gl-render.cc
--- a/src/gl-render.cc
+++ b/src/gl-render.cc
@@ -539,17 +539,17 @@ private:
   int color_mode;       // 0: uni,  1: flat, 2: interp
   int light_mode;       // 0: none, 1: flat, 2: gouraud
   int index;
   bool first;
   std::list<vertex_data> tmp_vdata;
 };
 
 void
-opengl_renderer::draw (const graphics_object& go)
+opengl_renderer::draw (const graphics_object& go, bool toplevel)
 {
   if (! go.valid_object ())
     return;
 
   const base_properties& props = go.get_properties ();
 
   if (go.isa ("figure"))
     draw_figure (dynamic_cast<const figure::properties&> (props));
@@ -562,60 +562,93 @@ opengl_renderer::draw (const graphics_ob
   else if (go.isa ("patch"))
     draw_patch (dynamic_cast<const patch::properties&> (props));
   else if (go.isa ("hggroup"))
     draw_hggroup (dynamic_cast<const hggroup::properties&> (props));
   else if (go.isa ("text"))
     draw_text (dynamic_cast<const text::properties&> (props));
   else if (go.isa ("image"))
     draw_image (dynamic_cast<const image::properties&> (props));
-  else if (go.isa ("uimenu"))
-    ;
+  else if (go.isa ("uimenu") || go.isa ("uicontrol"))
+    /* SKIP */;
+  else if (go.isa ("uipanel"))
+    {
+      if (toplevel)
+        draw_uipanel (dynamic_cast<const uipanel::properties&> (props), go);
+    }
   else
-    warning ("opengl_renderer: cannot render object of type `%s'",
-             props.graphics_object_name ().c_str ());
+    {
+      warning ("opengl_renderer: cannot render object of type `%s'",
+               props.graphics_object_name ().c_str ());
+    }
 }
 
 void
 opengl_renderer::draw_figure (const figure::properties& props)
 {
   toolkit = props.get_toolkit ();
 
   // Initialize OpenGL context
 
+  init_gl_context (props.is___enhanced__ (), props.get_color_rgb ());
+
+  // Draw children
+
+  draw (props.get_all_children (), false);
+}
+
+void
+opengl_renderer::draw_uipanel (const uipanel::properties& props,
+                               const graphics_object& go)
+{
+  graphics_object fig = go.get_ancestor ("figure");
+  const figure::properties& figProps =
+    dynamic_cast<const figure::properties&> (fig.get_properties ());
+
+  toolkit = figProps.get_toolkit ();
+
+  // Initialize OpenGL context 
+
+  init_gl_context (figProps.is___enhanced__ (),
+                   props.get_backgroundcolor_rgb ());
+
+  // Draw children
+
+  draw (props.get_all_children (), false);
+}
+
+void
+opengl_renderer::init_gl_context (bool enhanced, const Matrix& c)
+{
+  // Initialize OpenGL context
+
   glEnable (GL_DEPTH_TEST);
   glDepthFunc (GL_LEQUAL);
   glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
   glAlphaFunc (GL_GREATER, 0.0f);
   glEnable (GL_NORMALIZE);
 
-  if (props.is___enhanced__ ())
+  if (enhanced)
     {
       glEnable (GL_BLEND);
       glEnable (GL_LINE_SMOOTH);
     }
   else
     {
       glDisable (GL_BLEND);
       glDisable (GL_LINE_SMOOTH);
     }
 
   // Clear background
 
-  Matrix c = props.get_color_rgb ();
-
   if (c.length() >= 3)
     {
       glClearColor (c(0), c(1), c(2), 1);
       glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
     }
-
-  // Draw children
-
-  draw (props.get_all_children ());
 }
 
 void
 opengl_renderer::render_grid (const std::string& gridstyle,
                               const Matrix& ticks, double lim1, double lim2,
                               double p1, double p1N, double p2, double p2N,
                               int xyz, bool is_3D)
 {
diff --git a/src/gl-render.h b/src/gl-render.h
--- a/src/gl-render.h
+++ b/src/gl-render.h
@@ -54,43 +54,47 @@ public:
     camera_pos (), camera_dir ()
 #if HAVE_FREETYPE
     , text_renderer ()
 #endif
   { }
 
   virtual ~opengl_renderer (void) { }
 
-  virtual void draw (const graphics_object& go);
+  virtual void draw (const graphics_object& go, bool toplevel = true);
 
-  virtual void draw (const Matrix& hlist)
+  virtual void draw (const Matrix& hlist, bool toplevel = false)
     {
       int len = hlist.length ();
 
       for (int i = len-1; i >= 0; i--)
         {
           graphics_object obj = gh_manager::get_object (hlist(i));
 
           if (obj)
-            draw (obj);
+            draw (obj, toplevel);
         }
     }
 
   virtual void set_viewport (int w, int h);
   virtual graphics_xform get_transform (void) const { return xform; }
 
 protected:
   virtual void draw_figure (const figure::properties& props);
   virtual void draw_axes (const axes::properties& props);
   virtual void draw_line (const line::properties& props);
   virtual void draw_surface (const surface::properties& props);
   virtual void draw_patch (const patch::properties& props);
   virtual void draw_hggroup (const hggroup::properties& props);
   virtual void draw_text (const text::properties& props);
   virtual void draw_image (const image::properties& props);
+  virtual void draw_uipanel (const uipanel::properties& props,
+                             const graphics_object& go);
+
+  virtual void init_gl_context (bool enhanced, const Matrix& backgroundColor);
 
   virtual void set_color (const Matrix& c);
   virtual void set_polygon_offset (bool on, double offset = 0.0);
   virtual void set_linewidth (float w);
   virtual void set_linestyle (const std::string& s, bool stipple = false);
   virtual void set_clipbox (double x1, double x2, double y1, double y2,
                             double z1, double z2);
   virtual void set_clipping (bool on);
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -44,16 +44,17 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "graphics.h"
 #include "input.h"
 #include "ov.h"
 #include "oct-locbuf.h"
 #include "oct-obj.h"
 #include "oct-map.h"
 #include "ov-fcn-handle.h"
+#include "pager.h"
 #include "parse.h"
 #include "toplev.h"
 #include "txt-eng-ft.h"
 #include "unwind-prot.h"
 
 // forward declarations
 static octave_value xget (const graphics_handle& h, const caseless_str& name);
 
@@ -304,36 +305,131 @@ default_figure_paperposition (void)
   m(0) = 0.25;
   m(1) = 2.50;
   m(2) = 8.00;
   m(3) = 6.00;
   return m;
 }
 
 static Matrix
+default_control_position (void)
+{
+  Matrix retval (1, 4, 0.0);
+
+  retval(0) = 0;
+  retval(1) = 0;
+  retval(2) = 80;
+  retval(3) = 30;
+
+  return retval;
+}
+
+static Matrix
+default_control_sliderstep (void)
+{
+  Matrix retval (1, 2, 0.0);
+
+  retval(0) = 0.01;
+  retval(1) = 0.1;
+
+  return retval;
+}
+
+static Matrix
+default_panel_position (void)
+{
+  Matrix retval (1, 4, 0.0);
+
+  retval(0) = 0;
+  retval(1) = 0;
+  retval(2) = retval(3) = 0.5;
+
+  return retval;
+}
+
+static double
+convert_font_size (double font_size, const caseless_str& from_units,
+                   const caseless_str& to_units, double parent_height = 0)
+{
+  // Simple case where from_units == to_units
+
+  if (from_units.compare (to_units))
+    return font_size;
+
+  // Converts the given fontsize using the following transformation:
+  // <old_font_size> => points => <new_font_size>
+
+  double points_size = 0;
+  double res = 0;
+
+  if (from_units.compare ("points"))
+    points_size = font_size;
+  else
+    {
+      res = xget (0, "screenpixelsperinch").double_value ();
+
+      if (from_units.compare ("pixels"))
+        points_size = font_size * 72.0 / res;
+      else if (from_units.compare ("inches"))
+        points_size = font_size * 72.0;
+      else if (from_units.compare ("centimeters"))
+        points_size = font_size * 72.0 / 2.54;
+      else if (from_units.compare ("normalized"))
+        points_size = font_size * parent_height * 72.0 / res;
+    }
+
+  double new_font_size = 0;
+
+  if (to_units.compare ("points"))
+    new_font_size = points_size;
+  else
+    {
+      if (res <= 0)
+        res = xget (0, "screenpixelsperinch").double_value ();
+
+      if (to_units.compare ("pixels"))
+        new_font_size = points_size * res / 72.0;
+      else if (to_units.compare ("inches"))
+        new_font_size = points_size / 72.0;
+      else if (to_units.compare ("centimeters"))
+        new_font_size = points_size * 2.54 / 72.0;
+      else if (to_units.compare ("normalized"))
+        {
+          // Avoid setting font size to (0/0) = NaN
+
+          if (parent_height > 0)
+            new_font_size = points_size * res / (parent_height * 72.0);
+        }
+    }
+
+  return new_font_size;
+}
+
+static Matrix
 convert_position (const Matrix& pos, const caseless_str& from_units,
                   const caseless_str& to_units,
                   const Matrix& parent_dim = Matrix (1, 2, 0.0))
 {
   Matrix retval (1, pos.numel ());
   double res = 0;
   bool is_rectangle = (pos.numel () == 4);
+  bool is_2d = (pos.numel () == 2);
 
   if (from_units.compare ("pixels"))
     retval = pos;
   else if (from_units.compare ("normalized"))
     {
       retval(0) = pos(0) * parent_dim(0) + 1;
       retval(1) = pos(1) * parent_dim(1) + 1;
       if (is_rectangle)
         {
           retval(2) = pos(2) * parent_dim(0);
           retval(3) = pos(3) * parent_dim(1);
         }
-      else
+      else if (! is_2d)
         retval(2) = 0;
     }
   else if (from_units.compare ("characters"))
     {
       if (res <= 0)
         res = xget (0, "screenpixelsperinch").double_value ();
 
       double f = 0.0;
@@ -346,17 +442,17 @@ convert_position (const Matrix& pos, con
         {
           retval(0) = 0.5 * pos(0) * f;
           retval(1) = pos(1) * f;
           if (is_rectangle)
             {
               retval(2) = 0.5 * pos(2) * f;
               retval(3) = pos(3) * f;
             }
-          else
+          else if (! is_2d)
             retval(2) = 0;
         }
     }
   else
     {
       if (res <= 0)
         res = xget (0, "screenpixelsperinch").double_value ();
 
@@ -373,33 +469,33 @@ convert_position (const Matrix& pos, con
         {
           retval(0) = pos(0) * f + 1;
           retval(1) = pos(1) * f + 1;
           if (is_rectangle)
             {
               retval(2) = pos(2) * f;
               retval(3) = pos(3) * f;
             }
-          else
+          else if (! is_2d)
             retval(2) = 0;
         }
     }
 
   if (! to_units.compare ("pixels"))
     {
       if (to_units.compare ("normalized"))
         {
           retval(0) = (retval(0) - 1) / parent_dim(0);
           retval(1) = (retval(1) - 1) / parent_dim(1);
           if (is_rectangle)
             {
               retval(2) /= parent_dim(0);
               retval(3) /= parent_dim(1);
             }
-          else
+          else if (! is_2d)
             retval(2) = 0;
         }
       else if (to_units.compare ("characters"))
         {
           if (res <= 0)
             res = xget (0, "screenpixelsperinch").double_value ();
 
           double f = 0.0;
@@ -410,17 +506,17 @@ convert_position (const Matrix& pos, con
             {
               retval(0) = 2 * retval(0) / f;
               retval(1) = retval(1) / f;
               if (is_rectangle)
                 {
                   retval(2) = 2 * retval(2) / f;
                   retval(3) = retval(3) / f;
                 }
-              else
+              else if (! is_2d)
                 retval(2) = 0;
             }
         }
       else
         {
           if (res <= 0)
             res = xget (0, "screenpixelsperinch").double_value ();
 
@@ -437,22 +533,22 @@ convert_position (const Matrix& pos, con
             {
               retval(0) = (retval(0) - 1) / f;
               retval(1) = (retval(1) - 1) / f;
               if (is_rectangle)
                 {
                   retval(2) /= f;
                   retval(3) /= f;
                 }
-              else
+              else if (! is_2d)
                 retval(2) = 0;
             }
         }
     }
-  else if (! is_rectangle)
+  else if (! is_rectangle && ! is_2d)
     retval(2) = 0;
 
   return retval;
 }
 
 static Matrix
 convert_text_position (const Matrix& pos, const text::properties& props,
                        const caseless_str& from_units,
@@ -711,18 +807,26 @@ lookup_object_name (const caseless_str& 
               pfx = name.substr (0, 6);
 
               if (pfx.compare ("figure") || pfx.compare ("uimenu"))
                 offset = 6;
               else if (len >= 7)
                 {
                   pfx = name.substr (0, 7);
 
-                  if (pfx.compare ("surface") || pfx.compare ("hggroup"))
+                  if (pfx.compare ("surface") || pfx.compare ("hggroup")
+		      || pfx.compare ("uipanel"))
                     offset = 7;
+                  else if (len >= 9)
+                    {
+                      pfx = name.substr (0, 9);
+
+                      if (pfx.compare ("uicontrol"))
+                        offset = 9;
+                    }
                 }
             }
         }
 
       if (offset > 0)
         {
           go_name = pfx;
           rest = name.substr (offset);
@@ -753,37 +857,37 @@ make_graphics_object_from_type (const ca
   else if (type.compare ("patch"))
     go = new patch (h, p);
   else if (type.compare ("surface"))
     go = new surface (h, p);
   else if (type.compare ("hggroup"))
     go = new hggroup (h, p);
   else if (type.compare ("uimenu"))
     go = new uimenu (h, p);
+  else if (type.compare ("uicontrol"))
+    go = new uicontrol (h, p);
+  else if (type.compare ("uipanel"))
+    go = new uipanel (h, p);
   return go;
 }
 
 // ---------------------------------------------------------------------
 
 bool
-base_property::set (const octave_value& v, bool do_run )
+base_property::set (const octave_value& v, bool do_run, bool do_notify_toolkit)
 {
   if (do_set (v))
     {
 
       // Notify graphics toolkit.
-      if (id >= 0)
+      if (id >= 0 && do_notify_toolkit)
         {
           graphics_object go = gh_manager::get_object (parent);
           if (go)
-            {
-              graphics_toolkit toolkit = go.get_toolkit ();
-              if (toolkit)
-                toolkit.update (go, id);
-            }
+            go.update (id);
         }
 
       // run listeners
       if (do_run && ! error_state)
         run_listeners (POSTSET);
 
       return true;
     }
@@ -794,17 +898,17 @@ base_property::set (const octave_value& 
 
 void
 base_property::run_listeners (listener_mode mode)
 {
   const octave_value_list& l = listeners[mode];
 
   for (int i = 0; i < l.length (); i++)
     {
-      gh_manager::execute_callback (parent, l(i), octave_value ());
+      gh_manager::execute_listener (parent, l(i));
 
       if (error_state)
         break;
     }
 }
 
 radio_values::radio_values (const std::string& opt_string)
   : default_val (), possible_vals ()
@@ -927,16 +1031,21 @@ color_property::do_set (const octave_val
       if (! s.empty ())
         {
           std::string match;
 
           if (radio_val.contains (s, match))
             {
               if (current_type != radio_t || match != current_val)
                 {
+                  if (s.length () != match.length ())
+                    warning_with_id ("Octave:abbreviated-property-match",
+                                     "%s: allowing %s to match %s value %s",
+                                     "set", s.c_str (), get_name ().c_str (),
+                                     match.c_str ());
                   current_val = match;
                   current_type = radio_t;
                   return true;
                 }
             }
           else
             {
               color_values col (s);
@@ -993,17 +1102,22 @@ double_radio_property::do_set (const oct
     {
       std::string s = val.string_value ();
       std::string match;
 
       if (! s.empty () && radio_val.contains (s, match))
         {
           if (current_type != radio_t || match != current_val)
             {
-              current_val = s;
+              if (s.length () != match.length ())
+                warning_with_id ("Octave:abbreviated-property-match",
+                                 "%s: allowing %s to match %s value %s",
+                                 "set", s.c_str (), get_name ().c_str (),
+                                 match.c_str ());
+              current_val = match;
               current_type = radio_t;
               return true;
             }
         }
       else
         error ("invalid value for double_radio property \"%s\"",
                get_name ().c_str ());
     }
@@ -1429,16 +1543,64 @@ property::create (const std::string& nam
       else
         error ("addproperty: unsupported type for dynamic property (= %s)",
                type.c_str ());
     }
 
   return retval;
 }
 
+static void
+finalize_r (const graphics_handle& h)
+{
+  graphics_object go = gh_manager::get_object (h);
+
+  if (go)
+    {
+      Matrix children = go.get_properties ().get_all_children ();
+
+      for (int k = 0; k < children.numel (); k++)
+        finalize_r (children(k));
+
+      go.finalize ();
+    }
+}
+
+static void
+initialize_r (const graphics_handle& h)
+{
+  graphics_object go = gh_manager::get_object (h);
+
+  if (go)
+    {
+      Matrix children = go.get_properties ().get_all_children ();
+
+      go.initialize ();
+
+      for (int k = 0; k < children.numel (); k++)
+        initialize_r (children(k));
+    }
+}
+
+void
+figure::properties::set_toolkit (const graphics_toolkit& b)
+{
+  if (toolkit)
+    finalize_r (get___myhandle__ ());
+
+  toolkit = b;
+  __graphics_toolkit__ = b.get_name ();
+  __plot_stream__ = Matrix ();
+
+  if (toolkit)
+    initialize_r (get___myhandle__ ());
+
+  mark_modified ();
+}
+
 // ---------------------------------------------------------------------
 
 void
 property_list::set (const caseless_str& name, const octave_value& val)
 {
   size_t offset = 0;
 
   size_t len = name.length ();
@@ -1461,18 +1623,26 @@ property_list::set (const caseless_str& 
               pfx = name.substr (0, 6);
 
               if (pfx.compare ("figure") || pfx.compare ("uimenu"))
                 offset = 6;
               else if (len > 7)
                 {
                   pfx = name.substr (0, 7);
 
-                  if (pfx.compare ("surface") || pfx.compare ("hggroup"))
+                  if (pfx.compare ("surface") || pfx.compare ("hggroup")
+                      || pfx.compare ("uipanel"))
                     offset = 7;
+                  else if (len > 9)
+                    {
+                      pfx = name.substr (0, 9);
+
+                      if (pfx.compare ("uicontrol"))
+                        offset = 9;
+                    }
                 }
             }
         }
 
       if (offset > 0)
         {
           // FIXME -- should we validate property names and values here?
 
@@ -1495,16 +1665,20 @@ property_list::set (const caseless_str& 
           else if (pfx == "figure")
             has_property = figure::properties::has_core_property (pname);
           else if (pfx == "surface")
             has_property = surface::properties::has_core_property (pname);
           else if (pfx == "hggroup")
             has_property = hggroup::properties::has_core_property (pname);
           else if (pfx == "uimenu")
             has_property = uimenu::properties::has_core_property (pname);
+          else if (pfx == "uicontrol")
+            has_property = uicontrol::properties::has_core_property (pname);
+          else if (pfx == "uipanel")
+            has_property = uipanel::properties::has_core_property (pname);
 
           if (has_property)
             {
               bool remove = false;
               if (val.is_string ())
                 {
                   caseless_str tval = val.string_value ();
 
@@ -1559,18 +1733,26 @@ property_list::lookup (const caseless_st
               pfx = name.substr (0, 6);
 
               if (pfx.compare ("figure") || pfx.compare ("uimenu"))
                 offset = 6;
               else if (len > 7)
                 {
                   pfx = name.substr (0, 7);
 
-                  if (pfx.compare ("surface") || pfx.compare ("hggroup"))
+                  if (pfx.compare ("surface") || pfx.compare ("hggroup")
+                      || pfx.compare ("uipanel"))
                     offset = 7;
+                  else if (len > 9)
+                    {
+                      pfx = name.substr (0, 9);
+
+                      if (pfx.compare ("uicontrol"))
+                        offset = 9;
+                    }
                 }
             }
         }
 
       if (offset > 0)
         {
           std::string pname = name.substr (offset);
 
@@ -1875,19 +2057,17 @@ gh_manager::do_free (const graphics_hand
 
               bp.delete_children ();
 
               octave_value val = bp.get_deletefcn ();
 
               bp.execute_deletefcn ();
 
               // Notify graphics toolkit.
-              graphics_toolkit toolkit = p->second.get_toolkit ();
-              if (toolkit)
-                toolkit.finalize (p->second);
+              p->second.finalize ();
 
               // Note: this will be valid only for first explicitly
               // deleted object.  All its children will then have an
               // unknown graphics toolkit.
 
               // Graphics handles for non-figure objects are negative
               // integers plus some random fractional part.  To avoid
               // running out of integers, we recycle the integer part
@@ -2046,32 +2226,41 @@ is_figure (double val)
 
 static void
 xcreatefcn (const graphics_handle& h)
 {
   graphics_object obj = gh_manager::get_object (h);
   obj.get_properties ().execute_createfcn  ();
 }
 
+static void
+xinitialize (const graphics_handle& h)
+{
+  graphics_object go = gh_manager::get_object (h);
+  
+  if (go)
+    go.initialize ();
+}
+
 // ---------------------------------------------------------------------
 
 void
 base_graphics_toolkit::update (const graphics_handle& h, int id)
 {
   graphics_object go = gh_manager::get_object (h);
 
   update (go, id);
 }
 
-void
+bool
 base_graphics_toolkit::initialize (const graphics_handle& h)
 {
   graphics_object go = gh_manager::get_object (h);
 
-  initialize (go);
+  return initialize (go);
 }
 
 void
 base_graphics_toolkit::finalize (const graphics_handle& h)
 {
   graphics_object go = gh_manager::get_object (h);
 
   finalize (go);
@@ -2308,16 +2497,21 @@ class gnuplot_toolkit : public base_grap
 public:
   gnuplot_toolkit (void)
       : base_graphics_toolkit ("gnuplot") { }
 
   ~gnuplot_toolkit (void) { }
 
   bool is_valid (void) const { return true; }
 
+  bool initialize (const graphics_object& go)
+    {
+      return go.isa ("figure");
+    }
+
   void finalize (const graphics_object& go)
     {
       if (go.isa ("figure"))
         {
           const figure::properties& props =
               dynamic_cast<const figure::properties&> (go.get_properties ());
 
           send_quit (props.get___plot_stream__ ());
@@ -2758,17 +2952,17 @@ figure::properties::set_visible (const o
       if (s == "on")
         xset (0, "currentfigure", __myhandle__.value ());
 
       visible = val;
     }
 }
 
 Matrix
-figure::properties::get_boundingbox (bool) const
+figure::properties::get_boundingbox (bool, const Matrix&) const
 {
   Matrix screen_size = screen_size_pixels ();
   Matrix pos;
 
   pos = convert_position (get_position ().matrix_value (), get_units (),
                           "pixels", screen_size);
 
   pos(0)--;
@@ -2787,16 +2981,50 @@ figure::properties::set_boundingbox (con
   pos(1) = screen_size(1) - pos(1) - pos(3);
   pos(1)++;
   pos(0)++;
   pos = convert_position (pos, "pixels", get_units (), screen_size);
 
   set_position (pos);
 }
 
+Matrix
+figure::properties::map_from_boundingbox (double x, double y) const
+{
+  Matrix bb = get_boundingbox (true);
+  Matrix pos (1, 2, 0);
+
+  pos(0) = x;
+  pos(1) = y;
+
+  pos(1) = bb(3) - pos(1);
+  pos(0)++;
+  pos = convert_position (pos, "pixels", get_units (),
+                          bb.extract_n (0, 2, 1, 2));
+
+  return pos;
+}
+
+Matrix
+figure::properties::map_to_boundingbox (double x, double y) const
+{
+  Matrix bb = get_boundingbox (true);
+  Matrix pos (1, 2, 0);
+
+  pos(0) = x;
+  pos(1) = y;
+
+  pos = convert_position (pos, get_units (), "pixels",
+                          bb.extract_n (0, 2, 1, 2));
+  pos(0)--;
+  pos(1) = bb(3) - pos(1);
+
+  return pos;
+}
+
 void
 figure::properties::set_position (const octave_value& v)
 {
   if (! error_state)
     {
       Matrix old_bb, new_bb;
 
       old_bb = get_boundingbox ();
@@ -4839,30 +5067,37 @@ axes::properties::update_font (void)
                           get ("fontsize").double_value ());
 #endif
 #endif
 }
 
 // The INTERNAL flag defines whether position or outerposition is used.
 
 Matrix
-axes::properties::get_boundingbox (bool internal) const
-{
-  graphics_object obj = gh_manager::get_object (get_parent ());
-  Matrix parent_bb = obj.get_properties ().get_boundingbox (true);
+axes::properties::get_boundingbox (bool internal,
+                                   const Matrix& parent_pix_size) const
+{
   Matrix pos = (internal ?
                   get_position ().matrix_value ()
                   : get_outerposition ().matrix_value ());
-
-  pos = convert_position (pos, get_units (), "pixels",
-                          parent_bb.extract_n (0, 2, 1, 2));
+  Matrix parent_size (parent_pix_size);
+
+  if (parent_size.numel () == 0)
+    {
+      graphics_object obj = gh_manager::get_object (get_parent ());
+
+      parent_size =
+       obj.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
+    }
+
+  pos = convert_position (pos, get_units (), "pixels", parent_size);
 
   pos(0)--;
   pos(1)--;
-  pos(1) = parent_bb(3) - pos(1) - pos(3);
+  pos(1) = parent_size(1) - pos(1) - pos(3);
 
   return pos;
 }
 
 Matrix
 axes::properties::get_extent (bool with_text, bool only_text_height) const
 {
   graphics_xform xform = get_transform ();
@@ -4985,41 +5220,36 @@ axes::properties::set_fontunits (const o
         }
     }
 }
 
 void
 axes::properties::update_fontunits (const caseless_str& old_units)
 {
   caseless_str new_units = get_fontunits ();
+  double parent_height = get_boundingbox (true).elem (3);
   double fsz = get_fontsize ();
-  double pixelsperinch = xget (0, "screenpixelsperinch").double_value();
-  double parent_height = get_boundingbox (true).elem (3);
-
-  if (old_units.compare ("normalized"))
-    fsz = fsz * parent_height * 72 / pixelsperinch;
-  else if (old_units.compare ("pixels"))
-    fsz = fsz * 72 / pixelsperinch;
-  else if (old_units.compare ("inches"))
-    fsz = fsz * 72;
-  else if (old_units.compare ("centimeters"))
-    fsz = fsz * 72 / 2.54;
-
-  if (new_units.compare ("normalized"))
-    fsz = fsz * pixelsperinch / parent_height / 72;
-  else if (new_units.compare ("pixels"))
-    fsz = fsz * pixelsperinch / 72;
-  else if (new_units.compare ("inches"))
-    fsz = fsz / 72;
-  else if (new_units.compare ("centimeters"))
-    fsz = fsz * 2.54 / 72;
+
+  fsz = convert_font_size (fsz, old_units, new_units, parent_height);
 
   set_fontsize (octave_value (fsz));
 }
 
+double
+axes::properties::get_fontsize_points (double box_pix_height) const
+{
+  double fs = get_fontsize ();
+  double parent_height = box_pix_height;
+
+  if (fontunits_is ("normalized") && parent_height <= 0)
+    parent_height = get_boundingbox (true).elem(3);
+
+  return convert_font_size (fs, get_fontunits (), "points", parent_height);
+}
+
 ColumnVector
 graphics_xform::xform_vector (double x, double y, double z)
 {
   return ::xform_vector (x, y, z);
 }
 
 Matrix
 graphics_xform::xform_eye (void)
@@ -6054,16 +6284,27 @@ axes::properties::clear_zoom_stack (void
 }
 
 void
 axes::reset_default_properties (void)
 {
   ::reset_default_properties (default_properties);
 }
 
+void
+axes::initialize (const graphics_object& go)
+{
+  base_graphics_object::initialize (go);
+
+  xinitialize (xproperties.get_title ());
+  xinitialize (xproperties.get_xlabel ());
+  xinitialize (xproperties.get_ylabel ());
+  xinitialize (xproperties.get_zlabel ());
+}
+
 // ---------------------------------------------------------------------
 
 Matrix
 line::properties::compute_xlim (void) const
 {
   Matrix m (1, 4);
 
   m(0) = xdata.min_val ();
@@ -6198,16 +6439,33 @@ text::properties::update_units (void)
       set_yliminclude ("on");
       // FIXME: see above
       set_zliminclude ("off");
     }
 
   cached_units = get_units ();
 }
 
+double
+text::properties::get_fontsize_points (double box_pix_height) const
+{
+  double fs = get_fontsize ();
+  double parent_height = box_pix_height;
+
+  if (fontunits_is ("normalized") && parent_height <= 0)
+    {
+      graphics_object go (gh_manager::get_object (get___myhandle__ ()));
+      graphics_object ax (go.get_ancestor ("axes"));
+
+      parent_height = ax.get_properties ().get_boundingbox (true).elem(3);
+    }
+
+  return convert_font_size (fs, get_fontunits (), "points", parent_height);
+}
+
 // ---------------------------------------------------------------------
 
 octave_value
 image::properties::get_color_data (void) const
 {
   return convert_cdata (*this, get_cdata (),
                         cdatamapping_is ("scaled"), 3);
 }
@@ -6551,16 +6809,289 @@ hggroup::update_axis_limits (const std::
     }
 
   base_graphics_object::update_axis_limits (axis_type);
 }
 
 // ---------------------------------------------------------------------
 
 octave_value
+uicontrol::properties::get_extent (void) const
+{
+  Matrix m = extent.get ().matrix_value ();
+
+  graphics_handle parent = get_parent ();
+  graphics_object parent_obj = gh_manager::get_object (parent);
+  Matrix parent_bbox = parent_obj.get_properties ().get_boundingbox (true),
+         parent_size = parent_bbox.extract_n (0, 2, 1, 2);
+
+  return convert_position (m, "pixels", get_units (), parent_size);
+}
+
+void
+uicontrol::properties::update_text_extent (void)
+{
+#ifdef HAVE_FREETYPE
+
+  text_element *elt;
+  ft_render text_renderer;
+  Matrix box;
+
+  // FIXME: parsed content should be cached for efficiency
+  // FIXME: support multiline text
+  
+  elt = text_parser_none ().parse (get_string_string ());
+#ifdef HAVE_FONTCONFIG
+  text_renderer.set_font (get_fontname (),
+			  get_fontweight (),
+			  get_fontangle (),
+			  get_fontsize ());
+#endif
+  box = text_renderer.get_extent (elt, 0);
+
+  Matrix ext (1, 4, 0.0);
+
+  // FIXME: also handle left and bottom components
+
+  ext(0) = ext(1) = 1;
+  ext(2) = box(0);
+  ext(3) = box(1);
+
+  set_extent (ext);
+
+#endif
+}
+
+void
+uicontrol::properties::update_units (void)
+{
+  Matrix pos = get_position ().matrix_value ();
+
+  graphics_handle parent = get_parent ();
+  graphics_object parent_obj = gh_manager::get_object (parent);
+  Matrix parent_bbox = parent_obj.get_properties ().get_boundingbox (true),
+         parent_size = parent_bbox.extract_n (0, 2, 1, 2);
+  
+  pos = convert_position (pos, cached_units, get_units (), parent_size);
+  set_position (pos);
+
+  cached_units = get_units ();
+}
+
+void
+uicontrol::properties::set_style (const octave_value& st)
+{
+  if (get___object__ ().is_empty())
+    style = st;
+  else
+    error ("set: cannot change the style of a uicontrol object after creation.");
+}
+
+Matrix
+uicontrol::properties::get_boundingbox (bool,
+                                        const Matrix& parent_pix_size) const
+{
+  Matrix pos = get_position ().matrix_value ();
+  Matrix parent_size (parent_pix_size);
+
+  if (parent_size.numel () == 0)
+    {
+      graphics_object obj = gh_manager::get_object (get_parent ());
+
+      parent_size =
+       obj.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
+    }
+
+  pos = convert_position (pos, get_units (), "pixels", parent_size);
+
+  pos(0)--;
+  pos(1)--;
+  pos(1) = parent_size(1) - pos(1) - pos(3);
+
+  return pos;
+}
+
+void
+uicontrol::properties::set_fontunits (const octave_value& v)
+{
+  if (! error_state)
+    {
+      caseless_str old_fontunits = get_fontunits ();
+      if (fontunits.set (v, true))
+        {
+          update_fontunits (old_fontunits);
+          mark_modified ();
+        }
+    }
+}
+
+void
+uicontrol::properties::update_fontunits (const caseless_str& old_units)
+{
+  caseless_str new_units = get_fontunits ();
+  double parent_height = get_boundingbox (false).elem (3);
+  double fsz = get_fontsize ();
+
+  fsz = convert_font_size (fsz, old_units, new_units, parent_height);
+
+  fontsize.set (octave_value (fsz), true);
+}
+
+double
+uicontrol::properties::get_fontsize_points (double box_pix_height) const
+{
+  double fs = get_fontsize ();
+  double parent_height = box_pix_height;
+
+  if (fontunits_is ("normalized") && parent_height <= 0)
+    parent_height = get_boundingbox (false).elem(3);
+
+  return convert_font_size (fs, get_fontunits (), "points", parent_height);
+}
+
+// ---------------------------------------------------------------------
+
+Matrix
+uipanel::properties::get_boundingbox (bool internal,
+                                      const Matrix& parent_pix_size) const
+{
+  Matrix pos = get_position ().matrix_value ();
+  Matrix parent_size (parent_pix_size);
+
+  if (parent_size.numel () == 0)
+    {
+      graphics_object obj = gh_manager::get_object (get_parent ());
+
+      parent_size =
+       obj.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
+    }
+
+  pos = convert_position (pos, get_units (), "pixels", parent_size);
+
+  pos(0)--;
+  pos(1)--;
+  pos(1) = parent_size(1) - pos(1) - pos(3);
+
+  if (internal)
+    {
+      double outer_height = pos(3);
+
+      pos(0) = pos(1) = 0;
+
+      if (! bordertype_is ("none"))
+        {
+          double bw = get_borderwidth ();
+          double mul = 1.0;
+
+          if (bordertype_is ("etchedin") || bordertype_is ("etchedout"))
+            mul = 2.0;
+
+          pos(0) += mul * bw;
+          pos(1) += mul * bw;
+          pos(2) -= 2 * mul * bw;
+          pos(3) -= 2 * mul * bw;
+        }
+
+      if (! get_title ().empty ())
+        {
+          double fs = get_fontsize ();
+
+          if (! fontunits_is ("pixels"))
+            {
+              double res = xget (0, "screenpixelsperinch").double_value ();
+
+              if (fontunits_is ("points"))
+                fs *= (res / 72.0);
+              else if (fontunits_is ("inches"))
+                fs *= res;
+              else if (fontunits_is ("centimeters"))
+                fs *= (res / 2.54);
+              else if (fontunits_is ("normalized"))
+                fs *= outer_height;
+            }
+
+          if (titleposition_is ("lefttop") || titleposition_is ("centertop")
+              || titleposition_is ("righttop"))
+            pos(1) += (fs / 2);
+          pos(3) -= (fs / 2);
+        }
+    }
+
+  return pos;
+}
+
+void
+uipanel::properties::set_units (const octave_value& v)
+{
+  if (! error_state)
+    {
+      caseless_str old_units = get_units ();
+      if (units.set (v, true))
+        {
+          update_units (old_units);
+          mark_modified ();
+        }
+    }
+}
+
+void
+uipanel::properties::update_units (const caseless_str& old_units)
+{
+  Matrix pos = get_position ().matrix_value ();
+
+  graphics_handle parent = get_parent ();
+  graphics_object parent_obj = gh_manager::get_object (parent);
+  Matrix parent_bbox = parent_obj.get_properties ().get_boundingbox (true),
+         parent_size = parent_bbox.extract_n (0, 2, 1, 2);
+  
+  pos = convert_position (pos, old_units, get_units (), parent_size);
+  set_position (pos);
+}
+
+void
+uipanel::properties::set_fontunits (const octave_value& v)
+{
+  if (! error_state)
+    {
+      caseless_str old_fontunits = get_fontunits ();
+      if (fontunits.set (v, true))
+        {
+          update_fontunits (old_fontunits);
+          mark_modified ();
+        }
+    }
+}
+
+void
+uipanel::properties::update_fontunits (const caseless_str& old_units)
+{
+  caseless_str new_units = get_fontunits ();
+  double parent_height = get_boundingbox (false).elem (3);
+  double fsz = get_fontsize ();
+
+  fsz = convert_font_size (fsz, old_units, new_units, parent_height);
+
+  set_fontsize (octave_value (fsz));
+}
+
+double
+uipanel::properties::get_fontsize_points (double box_pix_height) const
+{
+  double fs = get_fontsize ();
+  double parent_height = box_pix_height;
+
+  if (fontunits_is ("normalized") && parent_height <= 0)
+    parent_height = get_boundingbox (false).elem(3);
+
+  return convert_font_size (fs, get_fontunits (), "points", parent_height);
+}
+
+// ---------------------------------------------------------------------
+
+octave_value
 base_graphics_object::get_default (const caseless_str& name) const
 {
   graphics_handle parent = get_parent ();
   graphics_object parent_obj = gh_manager::get_object (parent);
 
   return parent_obj.get_default (type () + name);
 }
 
@@ -6572,68 +7103,68 @@ base_graphics_object::get_factory_defaul
   return parent_obj.get_factory_default (type () + name);
 }
 
 // We use a random value for the handle to avoid issues with plots and
 // scalar values for the first argument.
 gh_manager::gh_manager (void)
   : handle_map (), handle_free_list (),
     next_handle (-1.0 - (rand () + 1.0) / (RAND_MAX + 2.0)),
-    figure_list (), graphics_lock (), event_queue (), callback_objects ()
+    figure_list (), graphics_lock (),  event_queue (),
+    callback_objects (), event_processing (0)
 {
   handle_map[0] = graphics_object (new root_figure ());
 
   // Make sure the default graphics toolkit is registered.
   graphics_toolkit::default_toolkit ();
 }
 
 graphics_handle
 gh_manager::do_make_graphics_handle (const std::string& go_name,
-                                     const graphics_handle& p, bool do_createfcn)
+                                     const graphics_handle& p, bool do_createfcn,
+                                     bool do_notify_toolkit)
 {
   graphics_handle h = get_handle (go_name);
 
   base_graphics_object *go = 0;
 
   go = make_graphics_object_from_type (go_name, h, p);
 
   if (go)
     {
       graphics_object obj (go);
 
       handle_map[h] = obj;
       if (do_createfcn)
         go->get_properties ().execute_createfcn ();
 
       // Notify graphics toolkit.
-      graphics_toolkit toolkit = go->get_toolkit ();
-      if (toolkit)
-        toolkit.initialize (obj);
+      if (do_notify_toolkit)
+        obj.initialize ();
     }
   else
     error ("gh_manager::do_make_graphics_handle: invalid object type `%s'",
            go_name.c_str ());
 
   return h;
 }
 
 graphics_handle
-gh_manager::do_make_figure_handle (double val)
+gh_manager::do_make_figure_handle (double val, bool do_notify_toolkit)
 {
   graphics_handle h = val;
 
   base_graphics_object* go = new figure (h, 0);
   graphics_object obj (go);
 
   handle_map[h] = obj;
 
   // Notify graphics toolkit.
-  graphics_toolkit toolkit = go->get_toolkit ();
-  if (toolkit)
-    toolkit.initialize (obj);
+  if (do_notify_toolkit)
+    obj.initialize ();
 
   return h;
 }
 
 void
 gh_manager::do_push_figure (const graphics_handle& h)
 {
   do_pop_figure (h);
@@ -6658,32 +7189,41 @@ gh_manager::do_pop_figure (const graphic
 
 class
 callback_event : public base_graphics_event
 {
 public:
   callback_event (const graphics_handle& h, const std::string& name,
                   const octave_value& data = Matrix ())
       : base_graphics_event (), handle (h), callback_name (name),
-        callback_data (data) { }
+        callback (), callback_data (data) { }
+  
+  callback_event (const graphics_handle& h, const octave_value& cb,
+                  const octave_value& data = Matrix ())
+      : base_graphics_event (), handle (h), callback_name (),
+        callback (cb), callback_data (data) { }
 
   void execute (void)
     {
-      gh_manager::execute_callback (handle, callback_name, callback_data);
+      if (callback.is_defined ())
+        gh_manager::execute_callback (handle, callback, callback_data);
+      else
+        gh_manager::execute_callback (handle, callback_name, callback_data);
     }
 
 private:
   callback_event (void)
     : base_graphics_event (), handle (),
       callback_name (), callback_data ()
   { }
 
 private:
   graphics_handle handle;
   std::string callback_name;
+  octave_value callback;
   octave_value callback_data;
 };
 
 class
 function_event : public base_graphics_event
 {
 public:
   function_event (graphics_event::event_fcn fcn, void* data = 0)
@@ -6711,69 +7251,91 @@ private:
   function_event & operator = (const function_event &);
 };
 
 class
 set_event : public base_graphics_event
 {
 public:
   set_event (const graphics_handle& h, const std::string& name,
-             const octave_value& value)
+             const octave_value& value, bool do_notify_toolkit = true)
       : base_graphics_event (), handle (h), property_name (name),
-        property_value (value) { }
+        property_value (value), notify_toolkit (do_notify_toolkit) { }
 
   void execute (void)
     {
-      gh_manager::autolock guard;
-
-      xset (handle, property_name, property_value);
+      gh_manager::auto_lock guard;
+
+      graphics_object go = gh_manager::get_object (handle);
+
+      if (go)
+        {
+          property p = go.get_properties ().get_property (property_name);
+
+          if (p.ok ())
+            p.set (property_value, true, notify_toolkit);
+        }
     }
 
 private:
   set_event (void)
     : base_graphics_event (), handle (), property_name (), property_value ()
   { }
 
 private:
   graphics_handle handle;
   std::string property_name;
   octave_value property_value;
+  bool notify_toolkit;
 };
 
 graphics_event
 graphics_event::create_callback_event (const graphics_handle& h,
                                        const std::string& name,
                                        const octave_value& data)
 {
   graphics_event e;
 
   e.rep = new callback_event (h, name, data);
 
   return e;
 }
 
 graphics_event
+graphics_event::create_callback_event (const graphics_handle& h,
+                                       const octave_value& cb,
+                                       const octave_value& data)
+{
+  graphics_event e;
+
+  e.rep = new callback_event (h, cb, data);
+
+  return e;
+}
+
+graphics_event
 graphics_event::create_function_event (graphics_event::event_fcn fcn,
                                        void *data)
 {
   graphics_event e;
 
   e.rep = new function_event (fcn, data);
 
   return e;
 }
 
 graphics_event
 graphics_event::create_set_event (const graphics_handle& h,
                                   const std::string& name,
-                                  const octave_value& data)
+                                  const octave_value& data,
+                                  bool notify_toolkit)
 {
   graphics_event e;
 
-  e.rep = new set_event (h, name, data);
+  e.rep = new set_event (h, name, data, notify_toolkit);
 
   return e;
 }
 
 static void
 xset_gcbo (const graphics_handle& h)
 {
   graphics_object go = gh_manager::get_object (0);
@@ -6781,104 +7343,121 @@ xset_gcbo (const graphics_handle& h)
       dynamic_cast<root_figure::properties&> (go.get_properties ());
 
   props.set_callbackobject (h.as_octave_value ());
 }
 
 void
 gh_manager::do_restore_gcbo (void)
 {
-  gh_manager::autolock guard;
+  gh_manager::auto_lock guard;
 
   callback_objects.pop_front ();
 
   xset_gcbo (callback_objects.empty ()
              ? graphics_handle ()
              : callback_objects.front ().get_handle ());
 }
 
 void
+gh_manager::do_execute_listener (const graphics_handle& h,
+                                 const octave_value& l)
+{
+  if (octave_thread::is_octave_thread ())
+    gh_manager::execute_callback (h, l, octave_value ());
+  else
+    {
+      gh_manager::auto_lock guard;
+      
+      do_post_event (graphics_event::create_callback_event (h, l));
+    }
+}
+
+void
 gh_manager::do_execute_callback (const graphics_handle& h,
                                  const octave_value& cb_arg,
                                  const octave_value& data)
 {
-  octave_value_list args;
-  octave_function *fcn = 0;
-
-  args(0) = h.as_octave_value ();
-  if (data.is_defined ())
-    args(1) = data;
-  else
-    args(1) = Matrix ();
-
-  unwind_protect_safe frame;
-  frame.add_fcn (gh_manager::restore_gcbo);
-
-  if (true)
-    {
-      gh_manager::autolock guard;
-
-      callback_objects.push_front (get_object (h));
-      xset_gcbo (h);
-    }
-
-  BEGIN_INTERRUPT_WITH_EXCEPTIONS;
-
-  // Copy CB because "function_value" method is non-const.
-
-  octave_value cb = cb_arg;
-
-  if (cb.is_function_handle ())
-    fcn = cb.function_value ();
-  else if (cb.is_string ())
-    {
-      int status;
-      std::string s = cb.string_value ();
-
-      eval_string (s, false, status);
-    }
-  else if (cb.is_cell () && cb.length () > 0
-           && (cb.rows () == 1 || cb.columns () == 1)
-           && cb.cell_value ()(0).is_function_handle ())
-    {
-      Cell c = cb.cell_value ();
-
-      fcn = c(0).function_value ();
-      if (! error_state)
-        {
-          for (int i = 1; i < c.length () ; i++)
-            args(1+i) = c(i);
-        }
-    }
-  else
-    {
-      std::string nm = cb.class_name ();
-      error ("trying to execute non-executable object (class = %s)",
-             nm.c_str ());
-    }
-
-  if (fcn && ! error_state)
-    feval (fcn, args);
-
-  END_INTERRUPT_WITH_EXCEPTIONS;
+  if (cb_arg.is_defined () && ! cb_arg.is_empty ())
+    {
+      octave_value_list args;
+      octave_function *fcn = 0;
+
+      args(0) = h.as_octave_value ();
+      if (data.is_defined ())
+        args(1) = data;
+      else
+        args(1) = Matrix ();
+
+      unwind_protect_safe frame;
+      frame.add_fcn (gh_manager::restore_gcbo);
+
+      if (true)
+        {
+          gh_manager::auto_lock guard;
+
+          callback_objects.push_front (get_object (h));
+          xset_gcbo (h);
+        }
+
+      BEGIN_INTERRUPT_WITH_EXCEPTIONS;
+
+      // Copy CB because "function_value" method is non-const.
+
+      octave_value cb = cb_arg;
+
+      if (cb.is_function_handle ())
+        fcn = cb.function_value ();
+      else if (cb.is_string ())
+        {
+          int status;
+          std::string s = cb.string_value ();
+
+          eval_string (s, false, status);
+        }
+      else if (cb.is_cell () && cb.length () > 0
+               && (cb.rows () == 1 || cb.columns () == 1)
+               && cb.cell_value ()(0).is_function_handle ())
+        {
+          Cell c = cb.cell_value ();
+
+          fcn = c(0).function_value ();
+          if (! error_state)
+            {
+              for (int i = 1; i < c.length () ; i++)
+                args(1+i) = c(i);
+            }
+        }
+      else
+        {
+          std::string nm = cb.class_name ();
+          error ("trying to execute non-executable object (class = %s)",
+                 nm.c_str ());
+        }
+
+      if (fcn && ! error_state)
+        feval (fcn, args);
+
+      END_INTERRUPT_WITH_EXCEPTIONS;
+    }
 }
 
 void
 gh_manager::do_post_event (const graphics_event& e)
 {
   event_queue.push_back (e);
 
   command_editor::add_event_hook (gh_manager::process_events);
 }
 
 void
 gh_manager::do_post_callback (const graphics_handle& h, const std::string name,
                               const octave_value& data)
 {
-  gh_manager::autolock guard;
+  gh_manager::auto_lock guard;
 
   graphics_object go = get_object (h);
 
   if (go.valid_object ())
     {
       if (callback_objects.empty ())
         do_post_event (graphics_event::create_callback_event (h, name, data));
       else
@@ -6907,110 +7486,151 @@ gh_manager::do_post_callback (const grap
             }
         }
     }
 }
 
 void
 gh_manager::do_post_function (graphics_event::event_fcn fcn, void* fcn_data)
 {
-  gh_manager::autolock guard;
+  gh_manager::auto_lock guard;
 
   do_post_event (graphics_event::create_function_event (fcn, fcn_data));
 }
 
 void
 gh_manager::do_post_set (const graphics_handle& h, const std::string name,
-                         const octave_value& value)
-{
-  gh_manager::autolock guard;
-
-  do_post_event (graphics_event::create_set_event (h, name, value));
+                         const octave_value& value, bool notify_toolkit)
+{
+  gh_manager::auto_lock guard;
+
+  do_post_event (graphics_event::create_set_event (h, name, value,
+                                                   notify_toolkit));
 }
 
 int
 gh_manager::do_process_events (bool force)
 {
   graphics_event e;
-
-  do
-    {
-      e = graphics_event ();
-
-      gh_manager::lock ();
-
-      if (! event_queue.empty ())
-        {
-          if (callback_objects.empty () || force)
+  bool old_Vdrawnow_requested = Vdrawnow_requested;
+  unwind_protect frame;
+ 
+  static int process_events_executing = 0;
+ 
+  frame.protect_var (process_events_executing);
+
+  if (++process_events_executing <= 1)
+    {
+      do
+        {
+          e = graphics_event ();
+
+          gh_manager::lock ();
+
+          if (! event_queue.empty ())
             {
-              e = event_queue.front ();
-
-              event_queue.pop_front ();
-            }
-          else
-            {
-              const graphics_object& go = callback_objects.front ();
-
-              if (go.get_properties ().is_interruptible ())
+              if (callback_objects.empty () || force)
                 {
                   e = event_queue.front ();
 
                   event_queue.pop_front ();
                 }
+              else
+                {
+                  const graphics_object& go = callback_objects.front ();
+
+                  if (go.get_properties ().is_interruptible ())
+                    {
+                      e = event_queue.front ();
+
+                      event_queue.pop_front ();
+                    }
+                }
             }
-        }
+
+          gh_manager::unlock ();
+
+          if (e.ok ())
+	    e.execute ();
+        }
+      while (e.ok ());
+
+      gh_manager::lock ();
+
+      if (event_queue.empty () && event_processing == 0)
+        command_editor::remove_event_hook (gh_manager::process_events);
 
       gh_manager::unlock ();
 
-      if (e.ok ())
-        e.execute ();
-    }
-  while (e.ok ());
-
-  gh_manager::lock ();
-
-  if (event_queue.empty ())
-    command_editor::remove_event_hook (gh_manager::process_events);
-
-  gh_manager::unlock ();
+      flush_octave_stdout ();
+
+      if (Vdrawnow_requested && ! old_Vdrawnow_requested)
+        {
+          feval ("drawnow");
+
+          Vdrawnow_requested = false;
+        }
+    }
 
   return 0;
 }
 
+void 
+gh_manager::do_enable_event_processing (bool enable)
+{
+  gh_manager::auto_lock lock;
+
+  if (enable)
+    {
+      event_processing++;
+
+      command_editor::add_event_hook (gh_manager::process_events);
+    }
+  else
+    {
+      event_processing--;
+
+      if (event_queue.empty () && event_processing == 0)
+        command_editor::remove_event_hook (gh_manager::process_events);
+    }
+}
+
 property_list::plist_map_type
 root_figure::init_factory_properties (void)
 {
   property_list::plist_map_type plist_map;
 
   plist_map["figure"] = figure::properties::factory_defaults ();
   plist_map["axes"] = axes::properties::factory_defaults ();
   plist_map["line"] = line::properties::factory_defaults ();
   plist_map["text"] = text::properties::factory_defaults ();
   plist_map["image"] = image::properties::factory_defaults ();
   plist_map["patch"] = patch::properties::factory_defaults ();
   plist_map["surface"] = surface::properties::factory_defaults ();
   plist_map["hggroup"] = hggroup::properties::factory_defaults ();
   plist_map["uimenu"] = uimenu::properties::factory_defaults ();
+  plist_map["uicontrol"] = uicontrol::properties::factory_defaults ();
+  plist_map["uipanel"] = uipanel::properties::factory_defaults ();
 
   return plist_map;
 }
 
 // ---------------------------------------------------------------------
 
 DEFUN (ishandle, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ishandle (@var{h})\n\
 Return true if @var{h} is a graphics handle and false otherwise.\n\
 @var{h} may also be a matrix of handles in which case a logical\n\
 array is returned that is true where the elements of @var{h} are\n\
 graphics handles and false where they are not.\n\
 @seealso{isfigure}\n\
 @end deftypefn")
 {
-  gh_manager::autolock guard;
+  gh_manager::auto_lock guard;
 
   octave_value retval;
 
   if (args.length () == 1)
     retval = is_handle (args(0));
   else
     print_usage ();
 
@@ -7076,17 +7696,17 @@ the first row of @var{values} and so on.
 \n\
 Here, the field names of @var{pv} represent the property names, and the field\n\
 values give the property values.  In contrast to the previous case, all\n\
 elements of @var{pv} will be set in all handles in @var{h} independent of\n\
 the dimensions of @var{pv}.\n\
 @end itemize\n\
 @end deftypefn")
 {
-  gh_manager::autolock guard;
+  gh_manager::auto_lock guard;
 
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
       // get vector of graphics handles
@@ -7188,17 +7808,17 @@ DEFUN (get, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} get (@var{h}, @var{p})\n\
 Return the named property @var{p} from the graphics handle @var{h}.\n\
 If @var{p} is omitted, return the complete property list for @var{h}.\n\
 If @var{h} is a vector, return a cell array including the property\n\
 values or lists respectively.\n\
 @end deftypefn")
 {
-  gh_manager::autolock guard;
+  gh_manager::auto_lock guard;
 
   octave_value retval;
 
   Cell vals;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
@@ -7310,17 +7930,17 @@ values or lists respectively.\n\
 // property values or lists respectively.
 
 DEFUN (__get__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __get__ (@var{h})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  gh_manager::autolock guard;
+  gh_manager::auto_lock guard;
 
   octave_value retval;
 
   Cell vals;
 
   int nargin = args.length ();
 
   if (nargin == 1)
@@ -7401,24 +8021,25 @@ make_graphics_object (const std::string&
 
   if (! error_state)
     {
       graphics_handle parent = gh_manager::lookup (val);
 
       if (parent.ok ())
         {
           graphics_handle h
-            = gh_manager::make_graphics_handle (go_name, parent, false);
+            = gh_manager::make_graphics_handle (go_name, parent, false, false);
 
           if (! error_state)
             {
               adopt (parent, h);
 
               xset (h, xargs);
               xcreatefcn (h);
+              xinitialize (h);
 
               retval = h.value ();
 
               if (! error_state)
                 Vdrawnow_requested = true;
             }
           else
             error ("__go%s__: unable to create graphics handle",
@@ -7434,17 +8055,17 @@ make_graphics_object (const std::string&
 }
 
 DEFUN (__go_figure__, args, ,
    "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_figure__ (@var{fignum})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  gh_manager::autolock guard;
+  gh_manager::auto_lock guard;
 
   octave_value retval;
 
   if (args.length () > 0)
     {
       double val = args(0).double_value ();
 
       if (! error_state)
@@ -7457,28 +8078,30 @@ Undocumented internal function.\n\
 
               retval = h.value ();
             }
           else
             {
               graphics_handle h = octave_NaN;
 
               if (xisnan (val))
-                h = gh_manager::make_graphics_handle ("figure", 0, false);
+                h = gh_manager::make_graphics_handle ("figure", 0, false,
+						      false);
               else if (val > 0 && D_NINT (val) == val)
-                h = gh_manager::make_figure_handle (val);
+                h = gh_manager::make_figure_handle (val, false);
               else
                 error ("__go_figure__: invalid figure number");
 
               if (! error_state && h.ok ())
                 {
                   adopt (0, h);
 
                   xset (h, args.splice (0, 1));
                   xcreatefcn (h);
+                  xinitialize (h);
 
                   retval = h.value ();
                 }
               else
                 error ("__go_figure__: failed to create figure handle");
             }
         }
       else
@@ -7486,17 +8109,17 @@ Undocumented internal function.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 #define GO_BODY(TYPE) \
-  gh_manager::autolock guard; \
+  gh_manager::auto_lock guard; \
  \
   octave_value retval; \
  \
   if (args.length () > 0) \
     retval = make_graphics_object (#TYPE, args); \
   else \
     print_usage (); \
  \
@@ -7537,17 +8160,17 @@ calc_dimensions (const graphics_object& 
 
 DEFUN (__calc_dimensions__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __calc_dimensions__ (@var{axes})\n\
 Internal function.  Determine the number of dimensions in a graphics\n\
 object, whether 2 or 3.\n\
 @end deftypefn")
 {
-  gh_manager::autolock guard;
+  gh_manager::auto_lock guard;
 
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       double h = args(0).double_value ();
@@ -7630,23 +8253,41 @@ DEFUN (__go_uimenu__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_uimenu__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (uimenu);
 }
 
+DEFUN (__go_uicontrol__, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} __go_uicontrol__ (@var{parent})\n\
+Undocumented internal function.\n\
+@end deftypefn")
+{
+  GO_BODY (uicontrol);
+}
+
+DEFUN (__go_uipanel__, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} __go_uipanel__ (@var{parent})\n\
+Undocumented internal function.\n\
+@end deftypefn")
+{
+  GO_BODY (uipanel);
+}
+
 DEFUN (__go_delete__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_delete__ (@var{h})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  gh_manager::autolock guard;
+  gh_manager::auto_lock guard;
 
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       graphics_handle h = octave_NaN;
 
       const NDArray vals = args (0).array_value ();
@@ -7714,17 +8355,17 @@ Undocumented internal function.\n\
 }
 
 DEFUN (__go_axes_init__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_axes_init__ (@var{h}, @var{mode})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  gh_manager::autolock guard;
+  gh_manager::auto_lock guard;
 
   octave_value retval;
 
   int nargin = args.length ();
 
   std::string mode = "";
 
   if (nargin == 2)
@@ -7768,28 +8409,28 @@ Undocumented internal function.\n\
 }
 
 DEFUN (__go_handles__, , ,
    "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_handles__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  gh_manager::autolock guard;
+  gh_manager::auto_lock guard;
 
   return octave_value (gh_manager::handle_list ());
 }
 
 DEFUN (__go_figure_handles__, , ,
    "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_figure_handles__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  gh_manager::autolock guard;
+  gh_manager::auto_lock guard;
 
   return octave_value (gh_manager::figure_handle_list ());
 }
 
 DEFUN (__go_execute_callback__, args, ,
    "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} __go_execute_callback__ (@var{h}, @var{name})\n\
 @deftypefnx {Built-in Function} {} __go_execute_callback__ (@var{h}, @var{name}, @var{param})\n\
@@ -7875,17 +8516,17 @@ Internal function: returns the pixel siz
 }
 
 DEFUN (available_graphics_toolkits, , ,
    "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} available_graphics_toolkits ()\n\
 Return a cell array of registered graphics toolkits.\n\
 @end deftypefn")
 {
-  gh_manager::autolock guard;
+  gh_manager::auto_lock guard;
 
   return octave_value (graphics_toolkit::available_toolkits_list ());
 }
 
 DEFUN (drawnow, args, ,
    "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} drawnow ()\n\
 @deftypefnx {Built-in Function} {} drawnow (\"expose\")\n\
@@ -8082,17 +8723,17 @@ function my_listener (h, dummy, p1)\n\
 endfunction\n\
 \n\
 addlistener (gcf, \"position\", @{@@my_listener, \"my string\"@})\n\
 @end group\n\
 @end example\n\
 \n\
 @end deftypefn")
 {
-  gh_manager::autolock guard;
+  gh_manager::auto_lock guard;
 
   octave_value retval;
 
   if (args.length () >= 3 && args.length () <= 4)
     {
       double h = args(0).double_value ();
 
       if (! error_state)
@@ -8154,17 +8795,17 @@ endfunction\n\
 c = @{@@my_listener, \"my string\"@};\n\
 addlistener (gcf, \"position\", c);\n\
 dellistener (gcf, \"position\", c);\n\
 @end group\n\
 @end example\n\
 \n\
 @end deftypefn")
 {
-  gh_manager::autolock guard;
+  gh_manager::auto_lock guard;
 
   octave_value retval;
 
   if (args.length () == 3 || args.length () == 2)
     {
       double h = args(0).double_value ();
 
       if (! error_state)
@@ -8274,17 +8915,17 @@ Examples:\n\
 addproperty (\"my_property\", gcf, \"string\", \"a string value\");\n\
 addproperty (\"my_radio\", gcf, \"radio\", \"val_1|val_2|@{val_3@}\");\n\
 addproperty (\"my_style\", gcf, \"linelinestyle\", \"--\");\n\
 @end group\n\
 @end example\n\
 \n\
 @end deftypefn")
 {
-  gh_manager::autolock guard;
+  gh_manager::auto_lock guard;
 
   octave_value retval;
 
   if (args.length () >= 3)
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
@@ -8332,34 +8973,34 @@ addproperty (\"my_style\", gcf, \"lineli
 
   return retval;
 }
 
 octave_value
 get_property_from_handle (double handle, const std::string& property,
                           const std::string& func)
 {
-  gh_manager::autolock guard;
+  gh_manager::auto_lock guard;
 
   graphics_object obj = gh_manager::get_object (handle);
   octave_value retval;
 
   if (obj)
     retval = obj.get (caseless_str (property));
   else
     error ("%s: invalid handle (= %g)", func.c_str(), handle);
 
   return retval;
 }
 
 bool
 set_property_in_handle (double handle, const std::string& property,
                         const octave_value& arg, const std::string& func)
 {
-  gh_manager::autolock guard;
+  gh_manager::auto_lock guard;
 
   graphics_object obj = gh_manager::get_object (handle);
   int ret = false;
 
   if (obj)
     {
       obj.set (caseless_str (property), arg);
 
diff --git a/src/graphics.h.in b/src/graphics.h.in
--- a/src/graphics.h.in
+++ b/src/graphics.h.in
@@ -359,17 +359,18 @@ public:
   virtual bool is_radio (void) const { return false; }
 
   int get_id (void) const { return id; }
 
   void set_id (int d) { id = d; }
 
   // Sets property value, notifies graphics toolkit.
   // If do_run is true, runs associated listeners.
-  bool set (const octave_value& v, bool do_run = true);
+  bool set (const octave_value& v, bool do_run = true,
+            bool do_notify_toolkit = true);
 
   virtual octave_value get (void) const
     {
       error ("get: invalid property \"%s\"", name.c_str ());
       return octave_value ();
     }
 
 
@@ -594,16 +595,18 @@ public:
             s += separator;
         }
 
       return s;
     }
 
   Cell cell_value (void) const {return Cell (str);}
 
+  string_vector string_vector_value (void) const { return str; }
+
   string_array_property& operator = (const octave_value& val)
     {
       set (val);
       return *this;
     }
 
   base_property* clone (void) const { return new string_array_property (*this); }
 
@@ -1003,16 +1006,21 @@ protected:
         std::string s = newval.string_value ();
 
         std::string match;
 
         if (vals.validate (s, match))
           {
             if (match != current_val)
               {
+                if (s.length () != match.length ())
+                  warning_with_id ("Octave:abbreviated-property-match",
+                                   "%s: allowing %s to match %s value %s",
+                                   "set", s.c_str (), get_name ().c_str (),
+                                   match.c_str ());
                 current_val = match;
                 return true;
               }
           }
         else
           error ("set: invalid value for radio property \"%s\" (value = %s)",
               get_name ().c_str (), s.c_str ());
       }
@@ -1898,18 +1906,19 @@ public:
     { return rep->get_id (); }
 
   void set_id (int d)
     { rep->set_id (d); }
 
   octave_value get (void) const
     { return rep->get (); }
 
-  bool set (const octave_value& val)
-    { return rep->set (val); }
+  bool set (const octave_value& val, bool do_run = true,
+            bool do_notify_toolkit = true)
+    { return rep->set (val, do_run, do_notify_toolkit); }
 
   std::string values_as_string (void) const
     { return rep->values_as_string (); }
 
   Cell values_as_cell (void) const
     { return rep->values_as_cell (); }
 
   property& operator = (const octave_value& val)
@@ -2068,20 +2077,20 @@ public:
   virtual void update (const graphics_object&, int)
     { gripe_invalid ("base_graphics_toolkit::update"); }
 
   void update (const graphics_handle&, int);
 
   // Callback function executed when the given graphics object is
   // created.  This allows the graphics toolkit to do toolkit-specific
   // initializations for a newly created object.
-  virtual void initialize (const graphics_object&)
-    { gripe_invalid ("base_graphics_toolkit::initialize"); }
-
-  void initialize (const graphics_handle&);
+  virtual bool initialize (const graphics_object&)
+    { gripe_invalid ("base_graphics_toolkit::initialize"); return false; }
+
+  bool initialize (const graphics_handle&);
 
   // Callback function executed just prior to deleting the given
   // graphics object.  This allows the graphics toolkit to perform
   // toolkit-specific cleanup operations before an object is deleted.
   virtual void finalize (const graphics_object&)
     { gripe_invalid ("base_graphics_toolkit::finalize"); }
 
   void finalize (const graphics_handle&);
@@ -2163,21 +2172,21 @@ public:
   // Notifies graphics toolkit that object't property has changed.
   void update (const graphics_object& go, int id)
     { rep->update (go, id); }
 
   void update (const graphics_handle& h, int id)
     { rep->update (h, id); }
 
   // Notifies graphics toolkit that new object was created.
-  void initialize (const graphics_object& go)
-    { rep->initialize (go); }
-
-  void initialize (const graphics_handle& h)
-    { rep->initialize (h); }
+  bool initialize (const graphics_object& go)
+    { return rep->initialize (go); }
+
+  bool initialize (const graphics_handle& h)
+    { return rep->initialize (h); }
 
   // Notifies graphics toolkit that object was destroyed.
   // This is called only for explicitly deleted object. Children are
   // deleted implicitly and graphics toolkit isn't notified.
   void finalize (const graphics_object& go)
     { rep->finalize (go); }
 
   void finalize (const graphics_handle& h)
@@ -2225,16 +2234,17 @@ private:
 
   typedef std::map<std::string, graphics_toolkit>::const_iterator
     const_available_toolkits_iterator;
 };
 
 // ---------------------------------------------------------------------
 
 class base_graphics_object;
+class graphics_object;
 
 class OCTINTERP_API base_properties
 {
 public:
   base_properties (const std::string& ty = "unknown",
                    const graphics_handle& mh = graphics_handle (),
                    const graphics_handle& p = graphics_handle ());
 
@@ -2293,17 +2303,18 @@ public:
   virtual void adopt (const graphics_handle& h)
   {
     children.adopt (h.value ());
     mark_modified ();
   }
 
   virtual graphics_toolkit get_toolkit (void) const;
 
-  virtual Matrix get_boundingbox (bool /*internal*/ = false) const
+  virtual Matrix get_boundingbox (bool /*internal*/ = false,
+                                  const Matrix& /*parent_pix_size*/ = Matrix ()) const
     { return Matrix (1, 4, 0.0); }
 
   virtual void update_boundingbox (void);
 
   virtual void update_autopos (const std::string& elem_type);
 
   virtual void add_listener (const caseless_str&, const octave_value&,
                              listener_mode = POSTSET);
@@ -2437,17 +2448,17 @@ protected:
   virtual void init (void) { }
 };
 
 class OCTINTERP_API base_graphics_object
 {
 public:
   friend class graphics_object;
 
-  base_graphics_object (void) : count (1) { }
+  base_graphics_object (void) : count (1), toolkit_flag (false) { }
 
   virtual ~base_graphics_object (void) { }
 
   virtual void mark_modified (void)
   {
     if (valid_object ())
       get_properties ().mark_modified ();
     else
@@ -2598,16 +2609,18 @@ public:
 
   virtual void update_axis_limits (const std::string& axis_type);
 
   virtual void update_axis_limits (const std::string& axis_type,
                                    const graphics_handle& h);
 
   virtual bool valid_object (void) const { return false; }
 
+  bool valid_toolkit_object (void) const { return toolkit_flag; }
+
   virtual std::string type (void) const
   {
     return (valid_object () ? get_properties ().graphics_object_name ()
         : "unknown");
   }
 
   bool isa (const std::string& go_name) const
   {
@@ -2650,19 +2663,45 @@ public:
           std::string msg = (type () + "::reset_default_properties");
           gripe_not_implemented (msg.c_str ());
         }
       else
         error ("base_graphics_object::default: invalid graphics object");
     }
 
 protected:
+  virtual void initialize (const graphics_object& go)
+    {
+      if (! toolkit_flag)
+        toolkit_flag = get_toolkit ().initialize (go);
+    }
+
+  virtual void finalize (const graphics_object& go)
+    {
+      if (toolkit_flag)
+        {
+          get_toolkit ().finalize (go);
+          toolkit_flag = false;
+        }
+    }
+
+  virtual void update (const graphics_object& go, int id)
+    {
+      if (toolkit_flag)
+        get_toolkit ().update (go, id);
+    }
+
+protected:
   // A reference count.
   int count;
 
+  // A flag telling whether this object is a valid object
+  // in the backend context.
+  bool toolkit_flag;
+
   // No copying!
 
   base_graphics_object (const base_graphics_object&);
 
   base_graphics_object& operator = (const base_graphics_object&);
 };
 
 class OCTINTERP_API graphics_object
@@ -2848,16 +2887,22 @@ public:
   void add_property_listener (const std::string& nm, const octave_value& v,
                               listener_mode mode = POSTSET)
     { rep->add_property_listener (nm, v, mode); }
 
   void delete_property_listener (const std::string& nm, const octave_value& v,
                                  listener_mode mode = POSTSET)
     { rep->delete_property_listener (nm, v, mode); }
 
+  void initialize (void) { rep->initialize (*this); }
+  
+  void finalize (void) { rep->finalize (*this); }
+
+  void update (int id) { rep->update (*this, id); }
+
   void reset_default_properties (void)
   { rep->reset_default_properties (); }
 
 private:
   base_graphics_object *rep;
 };
 
 // ---------------------------------------------------------------------
@@ -3020,25 +3065,17 @@ public:
     graphics_toolkit get_toolkit (void) const
       {
         if (! toolkit)
           toolkit = graphics_toolkit::default_toolkit ();
 
         return toolkit;
       }
 
-    void set_toolkit (const graphics_toolkit& b)
-    {
-      if (toolkit)
-        toolkit.finalize (__myhandle__);
-      toolkit = b;
-      __graphics_toolkit__ = b.get_name ();
-      __plot_stream__ = Matrix ();
-      mark_modified ();
-    }
+    void set_toolkit (const graphics_toolkit& b);
 
     void set___graphics_toolkit__ (const octave_value& val)
     {
       if (! error_state)
         {
           if (val.is_string ())
             {
               std::string nm = val.string_value ();
@@ -3053,20 +3090,25 @@ public:
                   mark_modified ();
                 }
             }
           else
             error ("set___graphics_toolkit__ must be a string");
         }
     }
 
-    Matrix get_boundingbox (bool internal = false) const;
+    Matrix get_boundingbox (bool internal = false,
+                            const Matrix& parent_pix_size = Matrix ()) const;
 
     void set_boundingbox (const Matrix& bb);
 
+    Matrix map_from_boundingbox (double x, double y) const;
+
+    Matrix map_to_boundingbox (double x, double y) const;
+
     void update_units (const caseless_str& old_units);
 
     void update_paperunits (const caseless_str& old_paperunits);
 
     std::string get_title (void) const;
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
@@ -3309,19 +3351,22 @@ public:
     void set_defaults (base_graphics_object& obj, const std::string& mode);
 
     void remove_child (const graphics_handle& h);
 
     const scaler& get_x_scaler (void) const { return sx; }
     const scaler& get_y_scaler (void) const { return sy; }
     const scaler& get_z_scaler (void) const { return sz; }
 
-    Matrix get_boundingbox (bool internal = false) const;
+    Matrix get_boundingbox (bool internal = false,
+                            const Matrix& parent_pix_size = Matrix ()) const;
     Matrix get_extent (bool with_text = false, bool only_text_height=false) const;
 
+    double get_fontsize_points (double box_pix_height = 0) const;
+
     void update_boundingbox (void)
       {
         if (units_is ("normalized"))
           {
             sync_positions ();
             base_properties::update_boundingbox ();
           }
       }
@@ -3451,20 +3496,20 @@ public:
       row_vector_property zlim mu , default_lim ()
       row_vector_property clim m , default_lim ()
       row_vector_property alim m , default_lim ()
       radio_property xlimmode al , "{auto}|manual"
       radio_property ylimmode al , "{auto}|manual"
       radio_property zlimmode al , "{auto}|manual"
       radio_property climmode al , "{auto}|manual"
       radio_property alimmode    , "{auto}|manual"
-      handle_property xlabel SOf , gh_manager::make_graphics_handle ("text", __myhandle__, false)
-      handle_property ylabel SOf , gh_manager::make_graphics_handle ("text", __myhandle__, false)
-      handle_property zlabel SOf , gh_manager::make_graphics_handle ("text", __myhandle__, false)
-      handle_property title SOf , gh_manager::make_graphics_handle ("text", __myhandle__, false)
+      handle_property xlabel SOf , gh_manager::make_graphics_handle ("text", __myhandle__, false, false)
+      handle_property ylabel SOf , gh_manager::make_graphics_handle ("text", __myhandle__, false, false)
+      handle_property zlabel SOf , gh_manager::make_graphics_handle ("text", __myhandle__, false, false)
+      handle_property title SOf , gh_manager::make_graphics_handle ("text", __myhandle__, false, false)
       bool_property xgrid , "off"
       bool_property ygrid , "off"
       bool_property zgrid , "off"
       bool_property xminorgrid , "off"
       bool_property yminorgrid , "off"
       bool_property zminorgrid , "off"
       row_vector_property xtick mu , default_axes_tick ()
       row_vector_property ytick mu , default_axes_tick ()
@@ -3812,16 +3857,19 @@ public:
 
   void update_axis_limits (const std::string& axis_type,
                            const graphics_handle& h);
 
   bool valid_object (void) const { return true; }
 
   void reset_default_properties (void);
 
+protected:
+  void initialize (const graphics_object& go);
+
 private:
   property_list default_properties;
 };
 
 // ---------------------------------------------------------------------
 
 class OCTINTERP_API line : public base_graphics_object
 {
@@ -3897,16 +3945,18 @@ public:
 // ---------------------------------------------------------------------
 
 class OCTINTERP_API text : public base_graphics_object
 {
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
+    double get_fontsize_points (double box_pix_height = 0) const;
+
     // See the genprops.awk script for an explanation of the
     // properties declarations.
 
     BEGIN_PROPERTIES (text)
       text_label_property string u , ""
       radio_property units u , "{data}|pixels|normalized|inches|centimeters|points"
       array_property position mu , Matrix (1, 3, 0.0)
       double_property rotation mu , 0
@@ -4556,16 +4606,172 @@ public:
   const base_properties& get_properties (void) const { return xproperties; }
 
   bool valid_object (void) const { return true; }
 
 };
 
 // ---------------------------------------------------------------------
 
+class OCTINTERP_API uicontrol : public base_graphics_object
+{
+public:
+  class OCTINTERP_API properties : public base_properties
+  {
+  public:
+    Matrix get_boundingbox (bool internal = false,
+                            const Matrix& parent_pix_size = Matrix ()) const;
+
+    double get_fontsize_points (double box_pix_height = 0) const;
+
+    // See the genprops.awk script for an explanation of the
+    // properties declarations.
+
+    BEGIN_PROPERTIES (uicontrol)
+      any_property __object__ , Matrix ()
+      color_property backgroundcolor , color_values (1, 1, 1)
+      callback_property callback , Matrix ()
+      array_property cdata , Matrix ()
+      bool_property clipping , "on"
+      radio_property enable , "{on}|inactive|off"
+      array_property extent rG , Matrix (1, 4, 0.0)
+      radio_property fontangle u , "{normal}|italic|oblique"
+      string_property fontname u , OCTAVE_DEFAULT_FONTNAME
+      double_property fontsize u , 10
+      radio_property fontunits S , "inches|centimeters|normalized|{points}|pixels"
+      radio_property fontweight u , "light|{normal}|demi|bold"
+      color_property foregroundcolor , color_values (0, 0, 0)
+      radio_property horizontalalignment , "{left}|center|right"
+      callback_property keypressfcn , Matrix ()
+      double_property listboxtop , 1
+      double_property max , 1
+      double_property min , 0
+      array_property position , default_control_position ()
+      array_property sliderstep , default_control_sliderstep ()
+      string_array_property string u , ""
+      radio_property style S , "{pushbutton}|togglebutton|radiobutton|checkbox|edit|text|slider|frame|listbox|popupmenu"
+      string_property tooltipstring , ""
+      radio_property units u , "normalized|inches|centimeters|points|{pixels}|characters"
+      row_vector_property value , Matrix (1, 1, 1.0)
+      radio_property verticalalignment , "top|{middle}|bottom"
+    END_PROPERTIES
+
+  private:
+    std::string cached_units;
+
+  protected:
+    void init (void)
+      {
+        cdata.add_constraint ("double");
+        cdata.add_constraint (dim_vector (-1, -1, 3));
+        position.add_constraint (dim_vector (1, 4));
+        sliderstep.add_constraint (dim_vector (1, 2));
+        cached_units = get_units ();
+      }
+    
+    void update_text_extent (void);
+
+    void update_string (void) { update_text_extent (); }
+    void update_fontname (void) { update_text_extent (); }
+    void update_fontsize (void) { update_text_extent (); }
+    void update_fontangle (void) { update_text_extent (); }
+    void update_fontweight (void) { update_text_extent (); }
+    void update_fontunits (const caseless_str& old_units);
+
+    void update_units (void);
+
+  };
+
+private:
+  properties xproperties;
+
+public:
+  uicontrol (const graphics_handle& mh, const graphics_handle& p)
+    : base_graphics_object (), xproperties (mh, p)
+  {
+    xproperties.override_defaults (*this);
+  }
+
+  ~uicontrol (void) { xproperties.delete_children (); }
+
+  base_properties& get_properties (void) { return xproperties; }
+
+  const base_properties& get_properties (void) const { return xproperties; }
+
+  bool valid_object (void) const { return true; }
+};
+
+// ---------------------------------------------------------------------
+
+class OCTINTERP_API uipanel : public base_graphics_object
+{
+public:
+  class OCTINTERP_API properties : public base_properties
+  {
+  public:
+    Matrix get_boundingbox (bool internal = false,
+                            const Matrix& parent_pix_size = Matrix ()) const;
+
+    double get_fontsize_points (double box_pix_height = 0) const;
+
+    // See the genprops.awk script for an explanation of the
+    // properties declarations.
+
+    BEGIN_PROPERTIES (uipanel)
+      any_property __object__ , Matrix ()
+      color_property backgroundcolor , color_values (1, 1, 1)
+      radio_property bordertype , "none|{etchedin}|etchedout|beveledin|beveledout|line"
+      double_property borderwidth , 1
+      radio_property fontangle , "{normal}|italic|oblique"
+      string_property fontname , OCTAVE_DEFAULT_FONTNAME
+      double_property fontsize , 10
+      radio_property fontunits S , "inches|centimeters|normalized|{points}|pixels"
+      radio_property fontweight , "light|{normal}|demi|bold"
+      color_property foregroundcolor , color_values (0, 0, 0)
+      color_property highlightcolor , color_values (1, 1, 1)
+      array_property position , default_panel_position ()
+      callback_property resizefcn , Matrix ()
+      color_property shadowcolor , color_values (0, 0, 0)
+      string_property title , ""
+      radio_property titleposition , "{lefttop}|centertop|righttop|leftbottom|centerbottom|rightbottom"
+      radio_property units S , "{normalized}|inches|centimeters|points|pixels|characters"
+    END_PROPERTIES
+
+  protected:
+    void init (void)
+      {
+        position.add_constraint (dim_vector (1, 4));
+      }
+    
+    void update_units (const caseless_str& old_units);
+    void update_fontunits (const caseless_str& old_units);
+
+  };
+
+private:
+  properties xproperties;
+
+public:
+  uipanel (const graphics_handle& mh, const graphics_handle& p)
+    : base_graphics_object (), xproperties (mh, p)
+  {
+    xproperties.override_defaults (*this);
+  }
+
+  ~uipanel (void) { xproperties.delete_children (); }
+
+  base_properties& get_properties (void) { return xproperties; }
+
+  const base_properties& get_properties (void) const { return xproperties; }
+
+  bool valid_object (void) const { return true; }
+};
+
+// ---------------------------------------------------------------------
+
 octave_value
 get_property_from_handle (double handle, const std::string &property,
                           const std::string &func);
 bool
 set_property_in_handle (double handle, const std::string &property,
                         const octave_value &arg, const std::string &func);
 
 // ---------------------------------------------------------------------
@@ -4627,24 +4833,29 @@ public:
 
   bool ok (void) const
     { return (rep != 0); }
 
   static graphics_event
       create_callback_event (const graphics_handle& h,
                              const std::string& name,
                              const octave_value& data = Matrix ());
+  
+  static graphics_event
+      create_callback_event (const graphics_handle& h,
+                             const octave_value& cb,
+                             const octave_value& data = Matrix ());
 
   static graphics_event
       create_function_event (event_fcn fcn, void *data = 0);
 
   static graphics_event
-      create_set_event (const graphics_handle& h,
-                        const std::string& name,
-                        const octave_value& value);
+      create_set_event (const graphics_handle& h, const std::string& name,
+                        const octave_value& value,
+                        bool notify_toolkit = true);
 private:
   base_graphics_event *rep;
 };
 
 class OCTINTERP_API gh_manager
 {
 protected:
 
@@ -4693,27 +4904,31 @@ public:
 
   static graphics_object get_object (const graphics_handle& h)
   {
     return instance_ok () ? instance->do_get_object (h) : graphics_object ();
   }
 
   static graphics_handle
   make_graphics_handle (const std::string& go_name,
-                        const graphics_handle& parent, bool do_createfcn = true)
+                        const graphics_handle& parent, bool do_createfcn = true,
+                        bool do_notify_toolkit = true)
   {
     return instance_ok ()
-      ? instance->do_make_graphics_handle (go_name, parent, do_createfcn)
+      ? instance->do_make_graphics_handle (go_name, parent, do_createfcn,
+                                           do_notify_toolkit)
       : graphics_handle ();
   }
 
-  static graphics_handle make_figure_handle (double val)
+  static graphics_handle make_figure_handle (double val,
+                                             bool do_notify_toolkit = true)
   {
     return instance_ok ()
-      ? instance->do_make_figure_handle (val) : graphics_handle ();
+      ? instance->do_make_figure_handle (val, do_notify_toolkit)
+      : graphics_handle ();
   }
 
   static void push_figure (const graphics_handle& h)
   {
     if (instance_ok ())
       instance->do_push_figure (h);
   }
 
@@ -4735,40 +4950,60 @@ public:
   }
 
   static void lock (void)
   {
     if (instance_ok ())
       instance->do_lock ();
   }
 
+  static bool try_lock (void)
+  {
+    if (instance_ok ())
+      return instance->do_try_lock ();
+    else
+      return false;
+  }
+
   static void unlock (void)
   {
     if (instance_ok ())
       instance->do_unlock ();
   }
-
+  
   static Matrix figure_handle_list (void)
   {
     return instance_ok () ? instance->do_figure_handle_list () : Matrix ();
   }
 
+  static void execute_listener (const graphics_handle& h,
+                                const octave_value& l)
+  {
+    if (instance_ok ())
+      instance->do_execute_listener (h, l);
+  }
+
   static void execute_callback (const graphics_handle& h,
                                 const std::string& name,
                                 const octave_value& data = Matrix ())
   {
-    graphics_object go = get_object (h);
-
-    if (go.valid_object ())
+    octave_value cb;
+
+    if (true)
       {
-        octave_value cb = go.get (name);
-
-        if (! error_state)
-          execute_callback (h, cb, data);
+        gh_manager::auto_lock lock;
+
+        graphics_object go = get_object (h);
+
+        if (go.valid_object ())
+          cb = go.get (name);
       }
+
+    if (! error_state)
+      execute_callback (h, cb, data);
   }
 
   static void execute_callback (const graphics_handle& h,
                                 const octave_value& cb,
                                 const octave_value& data = Matrix ())
   {
     if (instance_ok ())
       instance->do_execute_callback (h, cb, data);
@@ -4776,66 +5011,74 @@ public:
 
   static void post_callback (const graphics_handle& h,
                              const std::string& name,
                              const octave_value& data = Matrix ())
   {
     if (instance_ok ())
       instance->do_post_callback (h, name, data);
   }
-
+  
   static void post_function (graphics_event::event_fcn fcn, void* data = 0)
   {
     if (instance_ok ())
       instance->do_post_function (fcn, data);
   }
 
-  static void post_set (const graphics_handle& h,
-                        const std::string& name,
-                        const octave_value& value)
+  static void post_set (const graphics_handle& h, const std::string& name,
+                        const octave_value& value, bool notify_toolkit = true)
   {
     if (instance_ok ())
-      instance->do_post_set (h, name, value);
+      instance->do_post_set (h, name, value, notify_toolkit);
   }
 
   static int process_events (void)
   {
     return (instance_ok () ?  instance->do_process_events () : 0);
   }
 
   static int flush_events (void)
   {
     return (instance_ok () ?  instance->do_process_events (true) : 0);
   }
 
+  static void enable_event_processing (bool enable = true)
+    {
+      if (instance_ok ())
+        instance->do_enable_event_processing (enable);
+    }
+
   static bool is_handle_visible (const graphics_handle& h)
   {
     bool retval = false;
 
     graphics_object go = get_object (h);
 
     if (go.valid_object ())
       retval = go.is_handle_visible ();
 
     return retval;
   }
 
 public:
-  class autolock
+  class auto_lock : public octave_autolock
   {
   public:
-    autolock (void) { lock (); }
-
-    ~autolock (void) { unlock (); }
+    auto_lock (bool wait = true)
+      : octave_autolock (instance_ok ()
+                         ? instance->graphics_lock
+                         : octave_mutex (),
+                         wait)
+      { }
 
   private:
 
     // No copying!
-    autolock (const autolock&);
-    autolock& operator = (const autolock&);
+    auto_lock (const auto_lock&);
+    auto_lock& operator = (const auto_lock&);
   };
 
 private:
 
   static gh_manager *instance;
 
   typedef std::map<graphics_handle, graphics_object>::iterator iterator;
   typedef std::map<graphics_handle, graphics_object>::const_iterator const_iterator;
@@ -4863,16 +5106,19 @@ private:
   octave_mutex graphics_lock;
 
   // The list of events queued by graphics toolkits.
   std::list<graphics_event> event_queue;
 
   // The stack of callback objects.
   std::list<graphics_object> callback_objects;
 
+  // A flag telling whether event processing must be constantly on.
+  int event_processing;
+
   graphics_handle get_handle (const std::string& go_name);
 
   void do_free (const graphics_handle& h);
 
   graphics_handle do_lookup (double val)
   {
     iterator p = (xisnan (val) ? handle_map.end () : handle_map.find (val));
 
@@ -4882,19 +5128,20 @@ private:
   graphics_object do_get_object (const graphics_handle& h)
   {
     iterator p = (h.ok () ? handle_map.find (h) : handle_map.end ());
 
     return (p != handle_map.end ()) ? p->second : graphics_object ();
   }
 
   graphics_handle do_make_graphics_handle (const std::string& go_name,
-                                           const graphics_handle& p, bool do_createfcn);
-
-  graphics_handle do_make_figure_handle (double val);
+                                           const graphics_handle& p, bool do_createfcn,
+                                           bool do_notify_toolkit);
+
+  graphics_handle do_make_figure_handle (double val, bool do_notify_toolkit);
 
   Matrix do_handle_list (void)
   {
     Matrix retval (1, handle_map.size ());
     octave_idx_type i = 0;
     for (const_iterator p = handle_map.begin (); p != handle_map.end (); p++)
       {
         graphics_handle h = p->first;
@@ -4923,40 +5170,46 @@ private:
 
   graphics_handle do_current_figure (void) const
   {
     return figure_list.empty () ? graphics_handle () : figure_list.front ();
   }
 
   void do_lock (void) { graphics_lock.lock (); }
 
+  bool do_try_lock (void) { return graphics_lock.try_lock (); }
+
   void do_unlock (void) { graphics_lock.unlock (); }
 
+  void do_execute_listener (const graphics_handle& h, const octave_value& l);
+
   void do_execute_callback (const graphics_handle& h, const octave_value& cb,
                             const octave_value& data);
 
   void do_post_callback (const graphics_handle& h, const std::string name,
                          const octave_value& data);
-
+  
   void do_post_function (graphics_event::event_fcn fcn, void* fcn_data);
 
   void do_post_set (const graphics_handle& h, const std::string name,
-                    const octave_value& value);
+                    const octave_value& value, bool notify_toolkit = true);
 
   int do_process_events (bool force = false);
 
   static void restore_gcbo (void)
   {
     if (instance_ok ())
       instance->do_restore_gcbo ();
   }
 
   void do_restore_gcbo (void);
 
   void do_post_event (const graphics_event& e);
+
+  void do_enable_event_processing (bool enable = true);
 };
 
 void get_children_limits (double& min_val, double& max_val,
                           double& min_pos, double& max_neg,
                           const Matrix& kids, char limit_type);
 
 OCTINTERP_API int calc_dimensions (const graphics_object& gh);
 
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -53,16 +53,17 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "file-io.h"
 #include "input.h"
 #include "lex.h"
 #include "load-path.h"
 #include "octave.h"
 #include "oct-hist.h"
 #include "oct-map.h"
+#include "oct-mutex.h"
 #include "oct-obj.h"
 #include "ops.h"
 #include "ov.h"
 #include "ov-range.h"
 #include "toplev.h"
 #include "parse.h"
 #include "procstream.h"
 #include "sighandlers.h"
@@ -627,16 +628,18 @@ maximum_braindamage (void)
 int
 octave_main (int argc, char **argv, int embedded)
 {
   octave_env::set_program_name (argv[0]);
 
   octave_program_invocation_name = octave_env::get_program_invocation_name ();
   octave_program_name = octave_env::get_program_name ();
 
+  octave_thread::init ();
+
   // The order of these calls is important.  The call to
   // install_defaults must come before install_builtins because
   // default variable values must be available for the variables to be
   // installed, and the call to install_builtins must come before the
   // options are processed because some command line options override
   // defaults by calling bind_internal_variable.
 
   init_signals ();
