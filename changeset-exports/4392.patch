# HG changeset patch
# User jwe
# Date 1051376424 0
#      Sat Apr 26 17:00:24 2003 +0000
# Node ID dd108fa566fad529390bd4cea0f6d71762a79c62
# Parent  17530e977bec13a039d1227724e00760e418f231
[project @ 2003-04-26 17:00:24 by jwe]

diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,13 @@
+2003-04-26  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* str-vec.cc (string_vector::append (const std::string&),
+	string_vector::append (const string_vector&)): New methods.
+
 2003-04-24  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* kpse.cc, kpse.h: Replace fn_type with std::string.
 
 	* lo-ieee.h (lo_ieee_signbit): Provide signbit decl for MinGW systems.
 
 	* kpse.cc (xclosedir): Don't define or declare for Windows.
 	(READABLE): Now a static function to avoid warnings from MinGW
diff --git a/liboctave/kpse.cc b/liboctave/kpse.cc
--- a/liboctave/kpse.cc
+++ b/liboctave/kpse.cc
@@ -47,20 +47,16 @@ Foundation, Inc., 59 Temple Place - Suit
 
 #ifdef HAVE_UNISTD_H
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 #include <unistd.h>
 #endif
 
-#ifdef WIN32
-#include <malloc.h>
-#endif /* not WIN32 */
-
 #include "sysdir.h"
 #include "statdefs.h"
 
 /* define NAME_MAX, the maximum length of a single
    component in a filename.  No such limit may exist, or may vary
    depending on the filesystem.  */
 
 /* Most likely the system will truncate filenames if it is not POSIX,
@@ -114,19 +110,16 @@ Foundation, Inc., 59 Temple Place - Suit
 /* debug.h: Runtime tracing.  */
 
 /* If NO_DEBUG is defined (not recommended), skip all this.  */
 #ifndef NO_DEBUG
 
 /* OK, we'll have tracing support.  */
 #define KPSE_DEBUG
 
-/* Set a bit.  */
-#define KPSE_DEBUG_SET(bit) kpathsea_debug |= 1 << (bit)
-
 /* Test if a bit is on.  */
 #define KPSE_DEBUG_P(bit) (kpathsea_debug & (1 << (bit)))
 
 #define KPSE_DEBUG_STAT 0		/* stat calls */
 #define KPSE_DEBUG_HASH 1		/* hash lookups */
 #define KPSE_DEBUG_FOPEN 2		/* fopen/fclose calls */
 #define KPSE_DEBUG_PATHS 3		/* search path initializations */
 #define KPSE_DEBUG_EXPAND 4		/* path element expansion */
@@ -170,26 +163,16 @@ extern int fclose (FILE *);
 #ifndef DOSISH
 #define DOSISH
 #endif
 
 #ifndef MAXPATHLEN
 #define MAXPATHLEN      _MAX_PATH
 #endif
 
-#define HAVE_DUP2       	1
-#define HAVE_RENAME     	1
-#define HAVE_RMDIR      	1
-#define HAVE_MKDIR      	1
-#define HAVE_GETHOSTNAME	1
-#define HAVE_RANDOM		1
-#define USE_UTIME		1
-#define HAVE_MOUSE		1
-#define HAVE_TZNAME		1
-
 /* These have to be defined because our compilers treat __STDC__ as being
    defined (most of them anyway). */
 
 #define access  _access
 #define stat    _stat
 #define strcasecmp _stricmp
 #define strdup  _strdup
 #define strncasecmp _strnicmp
@@ -199,48 +182,25 @@ extern int fclose (FILE *);
 
 /* Define this so that winsock.h definitions don't get included when
    windows.h is...  For this to have proper effect, config.h must
    always be included before windows.h.  */
 #define _WINSOCKAPI_    1
 
 #include <windows.h>
 
-/* Defines size_t and alloca ().  */
-#include <malloc.h>
-
 /* For proper declaration of environ.  */
 #include <io.h>
 #include <fcntl.h>
 #include <process.h>
 
 /* ============================================================ */
 
 #endif /* WIN32 */
 
-/* hash.h: declarations for a hash table.  */
-
-/* A single (key,value) pair.  */
-struct hash_element_type
-{
-  std::string key;
-  std::string value;
-  struct hash_element_type *next;
-};
-
-/* The usual arrangement of buckets initialized to null.  */
-struct hash_table_type
-{
-  hash_element_type **buckets;
-  unsigned size;
-};
-
-static hash_table_type hash_create (unsigned size);
-
-
 /* lib.h: other stuff.  */
 
 /* Define common sorts of messages.  */
 
 /* This should be called only after a system call fails.  Don't exit
    with status `errno', because that might be 256, which would mean
    success (exit statuses are truncated to eight bits).  */
 #define FATAL_PERROR(str) do { \
@@ -261,108 +221,349 @@ static hash_table_type hash_create (unsi
   START_FATAL (); fprintf (stderr, str, e1, e2, e3); END_FATAL ()
 #define FATAL4(str, e1, e2, e3, e4)					\
   START_FATAL (); fprintf (stderr, str, e1, e2, e3, e4); END_FATAL ()
 #define FATAL5(str, e1, e2, e3, e4, e5)					\
   START_FATAL (); fprintf (stderr, str, e1, e2, e3, e4, e5); END_FATAL ()
 #define FATAL6(str, e1, e2, e3, e4, e5, e6)				\
   START_FATAL (); fprintf (stderr, str, e1, e2, e3, e4, e5, e6); END_FATAL ()
 
-
 #define START_WARNING() do { fputs ("warning: ", stderr)
 #define END_WARNING() fputs (".\n", stderr); fflush (stderr); } while (0)
 
 #define WARNING(str)							\
   START_WARNING (); fputs (str, stderr); END_WARNING ()
 #define WARNING1(str, e1)						\
   START_WARNING (); fprintf (stderr, str, e1); END_WARNING ()
 #define WARNING2(str, e1, e2)						\
   START_WARNING (); fprintf (stderr, str, e1, e2); END_WARNING ()
 #define WARNING3(str, e1, e2, e3)					\
   START_WARNING (); fprintf (stderr, str, e1, e2, e3); END_WARNING ()
 #define WARNING4(str, e1, e2, e3, e4)					\
   START_WARNING (); fprintf (stderr, str, e1, e2, e3, e4); END_WARNING ()
 
-
 /* I find this easier to read.  */
 #define STREQ(s1, s2) (strcmp (s1, s2) == 0)
 #define STRNEQ(s1, s2, n) (strncmp (s1, s2, n) == 0)
 
 /* Support for FAT/ISO-9660 filesystems.  Theoretically this should be
    done at runtime, per filesystem, but that's painful to program.  */
 #ifdef MONOCASE_FILENAMES
 #define FILESTRCASEEQ(s1, s2) (strcasecmp (s1, s2) == 0)
 #define FILESTRNCASEEQ(s1, s2, l) (strncasecmp (s1, s2, l) == 0)
 #define FILECHARCASEEQ(c1, c2) (toupper (c1) == toupper (c2))
 #else
 #define FILESTRCASEEQ STREQ
 #define FILESTRNCASEEQ STRNEQ
 #define FILECHARCASEEQ(c1, c2) ((c1) == (c2))
 #endif
 
-
-
 /* (Re)Allocate N items of type T using xmalloc/xrealloc.  */
 #define XTALLOC(n, t) ((t *) xmalloc ((n) * sizeof (t)))
 #define XTALLOC1(t) XTALLOC (1, t)
 #define XRETALLOC(addr, n, t) ((addr) = (t *) xrealloc (addr, (n) * sizeof(t)))
 
 extern "C" char *xbasename (const char *name);
 
-static FILE *xfopen (const char *filename, const char *mode);
-
-static void xfclose (FILE *f, const char *filename);
-
 #ifndef WIN32
 static void xclosedir (DIR *d);
 #endif
 
-static void *xmalloc (unsigned size);
-
-static void *xrealloc (void *old_ptr, unsigned size);
-
 #ifndef WIN32
 int dir_links (const char *fn);
 #endif
 
-static unsigned hash (hash_table_type table, const std::string& key);
-
-static void hash_insert (hash_table_type *table, const std::string& key,
-			 const std::string& value);
-
-static string_vector hash_lookup (hash_table_type table,
-				  const std::string& key);
-
-static void hash_print (hash_table_type table, int summary_only);
-
-static char *concat (const char *s1, const char *s2);
-
-static char *concat3 (const char *s1, const char *s2, const char *s3);
-
-static void str_list_add (string_vector& l, const std::string& s);
-
-static void str_list_concat (string_vector& target, const string_vector& more);
-
 static void str_llist_add (str_llist_type *l, const std::string& str);
 
 static void str_llist_float (str_llist_type *l, str_llist_elt_type *mover);
 
 static std::string kpse_var_expand (const std::string& src);
 
 #include <ctime> /* for `time' */
 
+/* xmalloc.c: malloc with error checking.  */
+
+static void *
+xmalloc (unsigned size)
+{
+  void *new_mem = (void *) malloc (size);
+
+  if (new_mem == NULL)
+    {
+      fprintf (stderr, "fatal: memory exhausted (xmalloc of %u bytes).\n",
+               size);
+      /* 1 means success on VMS, so pick a random number (ASCII `K').  */
+      exit (75);
+    }
+
+  return new_mem;
+}
+
+/* xrealloc.c: realloc with error checking.  */
+
+static void *
+xrealloc (void *old_ptr, unsigned size)
+{
+  void *new_mem;
+
+  if (old_ptr == NULL)
+    new_mem = xmalloc (size);
+  else
+    {
+      new_mem = (void *) realloc (old_ptr, size);
+      if (new_mem == NULL)
+        {
+          /* We used to print OLD_PTR here using %x, and casting its
+             value to unsigned, but that lost on the Alpha, where
+             pointers and unsigned had different sizes.  Since the info
+             is of little or no value anyway, just don't print it.  */
+          fprintf (stderr, "fatal: memory exhausted (realloc of %u bytes).\n",
+                   size);
+          /* 1 means success on VMS, so pick a random number (ASCII `B').  */
+          exit (66);
+        }
+    }
+
+  return new_mem;
+}
+
 /* Return a copy of S in new storage.  */
 
 static char *
 xstrdup (const char *s)
 {
   char *new_string = (char *) xmalloc (strlen (s) + 1);
   return strcpy (new_string, s);
 }
 
+/* These routines just check the return status from standard library
+   routines and abort if an error happens.  */
+
+static FILE *
+xfopen (const char *filename, const char *mode)
+{
+  FILE *f;
+
+  assert (filename && mode);
+
+  f = fopen (filename, mode);
+  if (f == NULL)
+    FATAL_PERROR (filename);
+
+  return f;
+}
+
+static void
+xfclose (FILE *f, const char *filename)
+{
+  assert (f);
+
+  if (fclose (f) == EOF)
+    FATAL_PERROR (filename);
+}
+
+/* Return the concatenation of S1 and S2.  See `concatn.c' for a
+   `concatn', which takes a variable number of arguments.  */
+
+static char *
+concat (const char *s1, const char *s2)
+{
+  char *answer = (char *) xmalloc (strlen (s1) + strlen (s2) + 1);
+  strcpy (answer, s1);
+  strcat (answer, s2);
+
+  return answer;
+}
+
+/* concat3.c: concatenate three strings.  */
+
+static char *
+concat3 (const char *s1, const char *s2, const char *s3)
+{
+  char *answer
+    = (char *) xmalloc (strlen (s1) + strlen (s2) + strlen (s3) + 1);
+  strcpy (answer, s1);
+  strcat (answer, s2);
+  strcat (answer, s3);
+
+  return answer;
+}
+
+/* A single (key,value) pair.  */
+
+struct hash_element_type
+{
+  std::string key;
+  std::string value;
+  struct hash_element_type *next;
+};
+
+/* The usual arrangement of buckets initialized to null.  */
+
+struct hash_table_type
+{
+  hash_element_type **buckets;
+  unsigned size;
+};
+
+/* The hash function.  We go for simplicity here.  */
+
+/* All our hash tables are related to filenames.  */
+#ifdef MONOCASE_FILENAMES
+#define TRANSFORM(x) toupper (x)
+#else
+#define TRANSFORM(x) (x)
+#endif
+
+static unsigned
+hash (hash_table_type table, const std::string& key)
+{
+  unsigned n = 0;
+
+  /* Our keys aren't often anagrams of each other, so no point in
+     weighting the characters.  */
+  size_t len = key.length ();
+  for (size_t i = 0; i < len; i++)
+    n = (n + n + TRANSFORM (key[i])) % table.size;
+
+  return n;
+}
+
+static hash_table_type
+hash_create (unsigned size)
+{
+  /* hash_table_type ret; changed into "static ..." to work around gcc
+     optimizer bug for Alpha.  */
+  static hash_table_type ret;
+  unsigned b;
+  ret.buckets = new hash_element_type * [size];
+  ret.size = size;
+
+  /* calloc's zeroes aren't necessarily NULL, so be safe.  */
+  for (b = 0; b <ret.size; b++)
+    ret.buckets[b] = NULL;
+
+  return ret;
+}
+
+/* Whether or not KEY is already in MAP, insert it and VALUE.  Do not
+   duplicate the strings, in case they're being purposefully shared.  */
+
+static void
+hash_insert (hash_table_type *table, const std::string& key,
+	     const std::string& value)
+{
+  unsigned n = hash (*table, key);
+  hash_element_type *new_elt = new hash_element_type;
+
+  new_elt->key = key;
+  new_elt->value = value;
+  new_elt->next = NULL;
+
+  /* Insert the new element at the end of the list.  */
+  if (! table->buckets[n])
+    /* first element in bucket is a special case.  */
+    table->buckets[n] = new_elt;
+  else
+    {
+      hash_element_type *loc = table->buckets[n];
+      while (loc->next)		/* Find the last element.  */
+        loc = loc->next;
+      loc->next = new_elt;	/* Insert the new one after.  */
+    }
+}
+
+/* Look up STR in MAP.  Return a (dynamically-allocated) list of the
+   corresponding strings or NULL if no match.  */
+
+static string_vector
+hash_lookup (hash_table_type table, const std::string& key)
+{
+  hash_element_type *p;
+  string_vector ret;
+  unsigned n = hash (table, key);
+
+  /* Look at everything in this bucket.  */
+  for (p = table.buckets[n]; p != NULL; p = p->next)
+    if (FILESTRCASEEQ (key.c_str (), p->key.c_str ()))
+      /* Cast because the general string_vector shouldn't force const data.  */
+      ret.append (p->value);
+
+#ifdef KPSE_DEBUG
+  if (KPSE_DEBUG_P (KPSE_DEBUG_HASH))
+    {
+      DEBUGF1 ("hash_lookup (%s) =>", key.c_str ());
+      if (ret.empty ())
+        fputs (" (nil)\n", stderr);
+      else
+        {
+	  int len = ret.length ();
+	  for (int i = 0; i < len; i++)
+            {
+              putc (' ', stderr);
+	      fputs (ret[i].c_str (), stderr);
+            }
+          putc ('\n', stderr);
+        }
+      fflush (stderr);
+    }
+#endif
+
+  return ret;
+}
+
+/* We only print nonempty buckets, to decrease output volume.  */
+
+static void
+hash_print (hash_table_type table, int summary_only)
+{
+  unsigned b;
+  unsigned total_elements = 0, total_buckets = 0;
+
+  for (b = 0; b < table.size; b++)
+    {
+      hash_element_type *bucket = table.buckets[b];
+
+      if (bucket)
+	{
+	  unsigned len = 1;
+	  hash_element_type *tb;
+
+	  total_buckets++;
+	  if (! summary_only)
+	    fprintf (stderr, "%4d ", b);
+
+	  for (tb = bucket->next; tb != NULL; tb = tb->next)
+	    len++;
+
+	  if (! summary_only)
+	    fprintf (stderr, ":%-5d", len);
+
+	  total_elements += len;
+
+	  if (! summary_only)
+	    {
+	      for (tb = bucket; tb != NULL; tb = tb->next)
+		fprintf (stderr, " %s=>%s", tb->key.c_str (),
+			 tb->value.c_str ());
+
+	      putc ('\n', stderr);
+	    }
+	}
+    }
+
+  fprintf (stderr,
+	   "%u buckets, %u nonempty (%u%%); %u entries, average chain %.1f.\n",
+	   table.size,
+	   total_buckets,
+	   100 * total_buckets / table.size,
+	   total_elements,
+	   total_buckets ? total_elements / (double) total_buckets : 0.0);
+}
+
 /* Here's the simple one, when a program just wants a value.  */
 
 static std::string
 kpse_var_value (const std::string& var)
 {
   std::string ret;
 
   std::string tmp = octave_env::getenv (var);
@@ -563,17 +764,17 @@ log_search (const string_vector& filenam
 	  /* And show them online, if debugging.  We've already started
 	     the debugging line in `search', where this is called, so
 	     just print the filename here, don't use DEBUGF.  */
 	  if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
 	    fputs (filename.c_str (), stderr);
 	}
     }
 }
-
+
 /* Concatenate each element in DIRS with NAME (assume each ends with a
    /, to save time).  If SEARCH_ALL is false, return the first readable
    regular file.  Else continue to search for more.  In any case, if
    none, return a list containing just NULL.
 
    We keep a single buffer for the potential filenames and reallocate
    only when necessary.  I'm not sure it's noticeably faster, but it
    does seem cleaner.  (We do waste a bit of space in the return
@@ -602,17 +803,17 @@ dir_list_search (str_llist_type *dirs, c
           XRETALLOC (potential, allocated, char);
         }
 
       strcpy (potential, dir.c_str ());
       strcat (potential, name.c_str ());
 
       if (kpse_readable_file (potential))
         {
-          str_list_add (ret, potential);
+          ret.append (std::string (potential));
 
           /* Move this element towards the top of the list.  */
           str_llist_float (dirs, elt);
 
           /* If caller only wanted one file returned, no need to
              terminate the list with NULL; the caller knows to only look
              at the first element.  */
           if (! search_all)
@@ -625,34 +826,34 @@ dir_list_search (str_llist_type *dirs, c
     }
 
   /* If we get here, either we didn't find any files, or we were finding
      all the files.  But we're done with the last filename, anyway.  */
   free (potential);
 
   return ret;
 }
-
+
 /* This is called when NAME is absolute or explicitly relative; if it's
    readable, return (a list containing) it; otherwise, return NULL.  */
 
 static string_vector
 absolute_search (const std::string& name_arg)
 {
   string_vector ret_list;
   const char *name = name_arg.c_str ();
   char *found = kpse_readable_file (name);
 
   /* Add `found' to the return list even if it's null; that tells
      the caller we didn't find anything.  */
-  str_list_add (ret_list, found);
+  ret_list.append (std::string (found));
 
   return ret_list;
 }
-
+
 /* This is the hard case -- look for NAME in PATH.  If ALL is false,
    return the first file found.  Otherwise, search all elements of PATH.  */
 
 static string_vector
 path_search (const std::string& path_arg, const std::string& name,
 	     bool must_exist, bool all)
 {
   char *elt;
@@ -713,28 +914,28 @@ path_search (const std::string& path_arg
 	  if (dirs && *dirs)
 	    found = dir_list_search (dirs, name, all);
 	}
 
       /* Did we find anything anywhere?  */
       if (! found.empty ())
 	{
 	  if (all)
-	    str_list_concat (ret_list, found);
+	    ret_list.append (found);
 	  else
 	    {
-	      str_list_add (ret_list, found[0]);
+	      ret_list.append (found[0]);
 	      done = true;
 	    }
 	}
     }
 
   return ret_list;
 }
-
+
 /* Search PATH for ORIGINAL_NAME.  If ALL is false, or ORIGINAL_NAME is
    absolute_p, check ORIGINAL_NAME itself.  Otherwise, look at each
    element of PATH for the first readable ORIGINAL_NAME.
 
    Always return a list; if no files are found, the list will
    contain just NULL.  If ALL is true, the list will be
    terminated with NULL.  */
 
@@ -777,38 +978,37 @@ search (const std::string& path, const s
       log_search (ret_list);
 
       if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
 	putc ('\n', stderr);
     }
 
   return ret_list;
 }
-
+
 /* Search PATH for the first NAME.  */
 
 std::string
 kpse_path_search (const std::string& path, const std::string& name,
 		  bool must_exist)
 {
   string_vector ret_list = search (path, name, must_exist, false);
 
   return ret_list.empty () ? std::string () : ret_list[0];
 }
 
-
 /* Search all elements of PATH for files named NAME.  Not sure if it's
    right to assert `must_exist' here, but it suffices now.  */
 
 string_vector
 kpse_all_path_search (const std::string& path, const std::string& name)
 {
   return search (path, name, true, true);
 }
-
+
 /* This is the hard case -- look in each element of PATH for each
    element of NAMES.  If ALL is false, return the first file found.
    Otherwise, search all elements of PATH.  */
 
 static string_vector
 path_find_first_of (const std::string& path_arg, const string_vector& names,
 		    bool must_exist, bool all)
 {
@@ -896,20 +1096,20 @@ path_find_first_of (const std::string& p
 
 		  found = dir_list_search (tmp, name, all);
 		}
 
 	      /* Did we find anything anywhere?  */
 	      if (! found.empty ())
 		{
 		  if (all)
-		    str_list_concat (ret_list, found);
+		    ret_list.append (found);
 		  else
 		    {
-		      str_list_add (ret_list, found[0]);
+		      ret_list.append (found[0]);
 		      done = true;
 		    }
 		}
 	    }
 	}
     }
 
   return ret_list;
@@ -1101,17 +1301,16 @@ kpse_tilde_expand (const std::string& na
 
 std::string
 kpse_expand (const std::string& s)
 {
   std::string var_expansion = kpse_var_expand (s);
   return kpse_tilde_expand (var_expansion);
 }
 
-
 /* Forward declarations of functions from the original expand.c  */
 static char **brace_expand (const char *);
 static void free_array (char **);
 
 /* If $KPSE_DOT is defined in the environment, prepend it to any relative
    path components. */
 
 static std::string
@@ -1119,30 +1318,16 @@ kpse_expand_kpse_dot (const std::string&
 {
   std::string ret;
   char *elt;
   std::string kpse_dot = octave_env::getenv ("KPSE_DOT");
 
   if (kpse_dot.empty ())
     return path;
 
-#ifdef MSDOS
-  /* Some setups of ported Bash force $KPSE_DOT to have the //d/foo/bar
-     form (when `pwd' is used), which is not understood by libc and the OS.
-     Convert them back to the usual d:/foo/bar form.  */
-  if (kpse_dot.len > 3 && kpse_dot[0] == '/' && kpse_dot[1] == '/'
-      && kpse_dot[2] >= 'A' && kpse_dot[2] <= 'z' && kpse_dot[3] == '/')
-    {
-      kpse_dot = kpse_dot.substr (1);
-      kpse_dot = xstrdup (kpse_dot);
-      kpse_dot[0] = kpse_dot[1];  /* drive letter */
-      kpse_dot[1] = ':';
-    }
-#endif
-
   char *tmp = xstrdup (path.c_str ());
 
   for (elt = kpse_path_element (tmp); elt; elt = kpse_path_element (NULL))
     {
       /* We assume that the !! magic is only used on absolute components.
 	 Single "." get special treatment, as does "./" or its  equivalent.  */
 
       if (kpse_absolute_p (elt, false) || (elt[0] == '!' && elt[1] == '!'))
@@ -1226,33 +1411,33 @@ kpse_brace_expand (const char *path)
   /* Waste the last byte by overwriting the trailing env_sep with a null.  */
   len = ret.length ();
 
   if (len > 0)
     ret.resize (len - 1);
 
   return kpse_expand_kpse_dot (ret);
 }
-
+
 /* Expand all special constructs in a path, and include only the actually
    existing directories in the result. */
-char *
-kpse_path_expand (const char *path)
+std::string
+kpse_path_expand (const std::string& path_arg)
 {
-  char *ret;
+  std::string ret;
   char *elt;
   unsigned len;
 
-  /* Initialise ret to the empty string. */
-  ret = (char *) xmalloc (1);
-  *ret = 0;
+  const char *path = path_arg.c_str ();
+
   len = 0;
 
   /* Expand variables and braces first.  */
   std::string tmp = kpse_brace_expand (path);
+
   const char *xpath = tmp.c_str ();
 
   /* Now expand each of the path elements, printing the results */
   for (elt = kpse_path_element (xpath); elt; elt = kpse_path_element (NULL))
     {
       str_llist_type *dirs;
 
       /* Skip and ignore magic leading chars.  */
@@ -1283,43 +1468,42 @@ kpse_path_expand (const char *path)
     if (dirs && *dirs)
       {
 	str_llist_elt_type *dir;
 
 	for (dir = *dirs; dir; dir = STR_LLIST_NEXT (*dir))
 	  {
 	    const std::string thedir = STR_LLIST (*dir);
 	    unsigned dirlen = thedir.length ();
-	    char *save_ret = ret;
+
 	    /* Retain trailing slash if that's the root directory.  */
 	    if (dirlen == 1 || (dirlen == 3 && NAME_BEGINS_WITH_DEVICE (thedir)
 				&& IS_DIR_SEP (thedir[2])))
 	      {
-		ret = concat3 (ret, thedir.c_str (), ENV_SEP_STRING);
+		ret += thedir + ENV_SEP_STRING;
 		len += dirlen + 1;
 		ret[len - 1] = ENV_SEP;
 	      }
 	    else
 	      {
-		ret = concat (ret, thedir.c_str ());
+		ret += thedir;
 		len += dirlen;
 		ret [len - 1] = ENV_SEP;
 	      }
-	    free (save_ret);
 	  }
       }
     }
 
   /* Get rid of trailing ':', if any. */
   if (len != 0)
     ret[len - 1] = 0;
 
   return ret;
 }
-
+
 /* braces.c -- code for doing word expansion in curly braces. Taken from
    bash 1.14.5.  [Ans subsequently modified for kpatshea.]
 
    Copyright (C) 1987,1991 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 1, or (at your option)
@@ -1389,17 +1573,16 @@ copy_array (char **array)
   new_array = (char **)xmalloc ((len + 1) * sizeof (char *));
   for (i = 0; array[i]; i++)
     new_array[i] = savestring (array[i]);
   new_array[i] = (char *)NULL;
 
   return (new_array);
 }
 
-
 /* Return an array of strings; the brace expansion of TEXT. */
 static char **
 brace_expand (const char *text)
 {
   register int start;
   char *preamble, *amble;
   const char *postamble;
   char **tack, **result;
@@ -1448,17 +1631,16 @@ brace_expand (const char *text)
 
   tack = brace_expand (postamble);
   result = array_concat (result, tack);
   free_array (tack);
 
   return (result);
 }
 
-
 /* Expand the text found inside of braces.  We simply try to split the
    text at BRACE_ARG_SEPARATORs into separate strings.  We then brace
    expand each slot which needs it, until there are no more slots which
    need it. */
 static char **
 expand_amble (const char *text)
 {
   char **result, **partial;
@@ -1627,17 +1809,16 @@ typedef enum
   kpse_src_compile,    /* configure/compile-time default */
   kpse_src_texmf_cnf,  /* texmf.cnf, the kpathsea config file */
   kpse_src_client_cnf, /* application config file, e.g., config.ps */
   kpse_src_env,        /* environment variable */
   kpse_src_x,          /* X Window System resource */
   kpse_src_cmdline     /* command-line option */
 } kpse_src_type;
 
-
 /* For each file format, we record the following information.  The main
    thing that is not part of this structure is the environment variable
    lists. They are used directly in tex-file.c. We could incorporate
    them here, but it would complicate the code a bit. We could also do
    it via variable expansion, but not now, maybe not ever:
    ${PKFONTS-${TEXFONTS-/usr/local/lib/texmf/fonts//}}.  */
 
 typedef struct
@@ -1660,17 +1841,17 @@ typedef struct
   bool binmode;		     /* The files must be opened in binary mode. */
 } kpse_format_info_type;
 
 /* The sole variable of that type, indexed by `kpse_file_format_type'.
    Initialized by calls to `kpse_find_file' for `kpse_init_format'.  */
 static kpse_format_info_type kpse_format_info;
 
 #define DB_ENVS "TEXMFDBS"
-
+
 /* And EXPAND_DEFAULT calls kpse_expand_default on try_path and the
    present info->path.  */
 #define EXPAND_DEFAULT(try_path, source_string)			\
   if (! try_path.empty ())					\
     {								\
       info->raw_path = try_path;				\
       info->path = kpse_expand_default (try_path.c_str (), (info->path).c_str ());	\
       info->path_source = source_string;			\
@@ -1738,17 +1919,16 @@ init_path (kpse_format_info_type *info, 
       EXPAND_DEFAULT (val, concat (var, " environment variable"));
     }
 
   EXPAND_DEFAULT (info->override_path, "application override variable");
   std::string tmp = kpse_brace_expand ((info->path).c_str ());
   info->path = tmp;
 }
 
-
 /* Some file types have more than one suffix.  */
 
 static void
 add_suffixes (const char ***list, ...)
 {
   const char *s;
   unsigned count = 0;
   va_list ap;
@@ -1762,17 +1942,16 @@ add_suffixes (const char ***list, ...)
       (*list)[count - 1] = s;
     }
 
   va_end (ap);
 
   (*list)[count] = NULL;
 }
 
-
 static char *
 remove_dbonly (const char *path)
 {
   char *ret = XTALLOC (strlen (path) + 1, char), *q=ret;
   const char *p=path;
   bool new_elt=true;
 
   while (*p)
@@ -1872,17 +2051,17 @@ kpse_init_format (void)
 
       DEBUGF1 ("  program enable level = %d\n",
 	       kpse_format_info.program_enable_level);
     }
 #endif /* KPSE_DEBUG */
 
   return kpse_format_info.path;
 }
-
+
 static hash_table_type db; /* The hash table for all the ls-R's.  */
 /* SMALL: The old size of the hash table was 7603, with the assumption
    that a minimal ls-R bas about 3500 entries.  But a typical ls-R will
    be more like double that size.  */
 #ifndef DB_HASH_SIZE
 #define DB_HASH_SIZE 15991
 #endif
 #ifndef DB_NAME
@@ -1893,17 +2072,17 @@ static hash_table_type alias_db;
 #ifndef ALIAS_NAME
 #define ALIAS_NAME "aliases"
 #endif
 #ifndef ALIAS_HASH_SIZE
 #define ALIAS_HASH_SIZE 1009
 #endif
 
 static string_vector db_dir_list;
-
+
 /* If DIRNAME contains any element beginning with a `.' (that is more
    than just `./'), return true.  This is to allow ``hidden''
    directories -- ones that don't get searched.  */
 
 static bool
 ignore_dir_p (const char *dirname)
 {
   const char *dot_pos = dirname;
@@ -1912,17 +2091,17 @@ ignore_dir_p (const char *dirname)
     {
       /* If / before and no / after, skip it. */
       if (IS_DIR_SEP (dot_pos[-1]) && dot_pos[1] && !IS_DIR_SEP (dot_pos[1]))
 	return true;
     }
 
   return false;
 }
-
+
 /* Allocate in increments of this size.  */
 #define BLOCK_SIZE 75
 
 static char *
 read_line (FILE *f)
 {
   int c;
   unsigned limit = BLOCK_SIZE;
@@ -2047,19 +2226,17 @@ db_build (hash_table_type *table, const 
 
       if (file_count == 0)
 	{
 	  WARNING1 ("kpathsea: No usable entries in %s", db_filename.c_str ());
 	  WARNING ("kpathsea: See the manual for how to generate ls-R");
 	  db_file = NULL;
 	}
       else
-	{
-	  str_list_add (db_dir_list, top_dir);
-	}
+	db_dir_list.append (std::string (top_dir));
 
 #ifdef KPSE_DEBUG
       if (KPSE_DEBUG_P (KPSE_DEBUG_HASH))
 	{
 	  /* Don't make this a debugging bit, since the output is so
 	     voluminous, and being able to specify -1 is too useful.
 	     Instead, let people who want it run the program under
 	     a debugger and change the variable that way.  */
@@ -2076,17 +2253,16 @@ db_build (hash_table_type *table, const 
 #endif /* KPSE_DEBUG */
     }
 
   free (top_dir);
 
   return db_file != NULL;
 }
 
-
 /* Insert FNAME into the hash table.  This is for files that get built
    during a run.  We wouldn't want to reread all of ls-R, even if it got
    rebuilt.  */
 
 void
 kpse_db_insert (const char *passed_fname)
 {
   /* We might not have found ls-R, or even had occasion to look for it
@@ -2099,17 +2275,17 @@ kpse_db_insert (const char *passed_fname
       const char *file_part = xstrdup (baseptr);
 
       *baseptr = '\0';  /* Chop off the filename.  */
       dir_part = fname; /* That leaves the dir, with the trailing /.  */
 
       hash_insert (&db, file_part, dir_part);
     }
 }
-
+
 /* Return true if FILENAME could be in PATH_ELT, i.e., if the directory
    part of FILENAME matches PATH_ELT.  Have to consider // wildcards, but
    $ and ~ expansion have already been done.  */
 
 static bool
 match (const std::string& filename_arg, const std::string& path_elt_arg)
 {
   const char *filename = filename_arg.c_str ();
@@ -2211,17 +2387,17 @@ elt_in_db (const std::string& db_dir, co
     /* If we've reached the end of PATH_ELT, but not the end of the db
        directory, it's no good.  */
       else if (i == path_elt_len)
 	break;
     }
 
   return found;
 }
-
+
 /* If ALIAS_FILENAME exists, read it into TABLE.  */
 
 static bool
 alias_build (hash_table_type *table, const std::string& alias_filename)
 {
   char *line, *real, *alias;
   unsigned count = 0;
   FILE *alias_file = xfopen (alias_filename.c_str (), "r");
@@ -2274,17 +2450,17 @@ alias_build (hash_table_type *table, con
 	}
 #endif /* KPSE_DEBUG */
 
       xfclose (alias_file, alias_filename.c_str ());
     }
 
   return alias_file != NULL;
 }
-
+
 /* Initialize the path for ls-R files, and read them all into the hash
    table `db'.  If no usable ls-R's are found, set db.buckets to NULL.  */
 
 void
 kpse_init_db (void)
 {
   bool ok = false;
   const std::string db_path = kpse_init_format ();
@@ -2331,17 +2507,17 @@ kpse_init_db (void)
     }
 
   if (! ok)
     {
       free (alias_db.buckets);
       alias_db.buckets = NULL;
     }
 }
-
+
 /* Avoid doing anything if this PATH_ELT is irrelevant to the databases. */
 
 string_vector
 kpse_db_search (const std::string& name_arg,
 		const std::string& orig_path_elt_arg, bool all)
 {
   const char *last_slash;
   char *path_elt;
@@ -2448,17 +2624,18 @@ kpse_db_search (const std::string& name_
 		      if (kpse_readable_file (atry.c_str ()))
 			found = atry;
 		    }
 		}
 
 	      /* If we have a real file, add it to the list, maybe done.  */
 	      if (! found.empty ())
 		{
-		  str_list_add (ret, found);
+		  ret.append (found);
+
 		  if (! (all || found.empty ()))
 		    done = true;
 		}
 	    }
 	}
     }
 
   /* If we had to break up NAME, free the temporary PATH_ELT.  */
@@ -2530,17 +2707,17 @@ kpse_expand_default (const char *path, c
 }
 
 /* elt-dirs.c: Translate a path element to its corresponding
    director{y,ies}.  */
 
 /* To avoid giving prototypes for all the routines and then their real
    definitions, we give all the subroutines first.  The entry point is
    the last routine in the file.  */
-
+
 /* Make a copy of DIR (unless it's null) and save it in L.  Ensure that
    DIR ends with a DIR_SEP for the benefit of later searches.  */
 
 static void
 dir_list_add (str_llist_type *l, const std::string& dir)
 {
   char last_char = dir[dir.length () - 1];
   std::string saved_dir = dir;
@@ -2568,17 +2745,17 @@ dir_p (const std::string& fn)
 /* If DIR is a directory, add it to the list L.  */
 
 static void
 checked_dir_list_add (str_llist_type *l, const std::string& dir)
 {
   if (dir_p (dir))
     dir_list_add (l, dir);
 }
-
+
 /* The cache.  Typically, several paths have the same element; for
    example, /usr/local/lib/texmf/fonts//.  We don't want to compute the
    expansion of such a thing more than once.  Even though we also cache
    the dir_links call, that's not enough -- without this path element
    caching as well, the execution time doubles.  */
 
 typedef struct
 {
@@ -2599,39 +2776,37 @@ static void
 cache (const char *key, str_llist_type *value)
 {
   cache_length++;
   XRETALLOC (the_cache, cache_length, cache_entry);
   the_cache[cache_length - 1].key = xstrdup (key);
   the_cache[cache_length - 1].value = value;
 }
 
-
 /* To retrieve, just check the list in order.  */
 
 static str_llist_type *
 cached (const char *key)
 {
   unsigned p;
 
   for (p = 0; p < cache_length; p++)
     {
       if (FILESTRCASEEQ (the_cache[p].key, key))
         return the_cache[p].value;
     }
 
   return NULL;
 }
-
+
 /* Handle the magic path constructs.  */
 
 /* Declare recursively called routine.  */
 static void expand_elt (str_llist_type *, const char *, unsigned);
 
-
 /* POST is a pointer into the original element (which may no longer be
    ELT) to just after the doubled DIR_SEP, perhaps to the null.  Append
    subdirectories of ELT (up to ELT_LENGTH, which must be a /) to
    STR_LIST_PTR.  */
 
 #ifdef WIN32
 /* Shared across recursive calls, it acts like a stack. */
 static char dirname[MAX_PATH];
@@ -2740,23 +2915,17 @@ do_subdir (str_llist_type *str_list_ptr,
                  the only alternative I know of is to stat every entry
                  in the directory, and that is unacceptably slow.
 
                  The #ifdef here makes all this configurable at
                  compile-time, so that if we're using VMS directories or
                  some such, we can still find subdirectories, even if it
                  is much slower.  */
 #ifdef ST_NLINK_TRICK
-#ifdef AMIGA
-              /* With SAS/C++ 6.55 on the Amiga, `stat' sets the `st_nlink'
-                 field to -1 for a file, or to 1 for a directory.  */
-              if (links == 1)
-#else
               if (links > 2)
-#endif /* not AMIGA */
 #endif /* not ST_NLINK_TRICK */
                 /* All criteria are met; find subdirectories.  */
                 do_subdir (str_list_ptr, name.c_str (),
                            potential_len, post);
 #ifdef ST_NLINK_TRICK
               else if (*post == 0)
                 /* Nothing to match, no recursive subdirectories to
                    look for: we're done with this branch.  Add it.  */
@@ -2768,17 +2937,16 @@ do_subdir (str_llist_type *str_list_ptr,
           name.resize (elt_length);
         }
     }
 
   xclosedir (dir);
 #endif /* not WIN32 */
 }
 
-
 /* Assume ELT is non-empty and non-NULL.  Return list of corresponding
    directories (with no terminating NULL entry) in STR_LIST_PTR.  Start
    looking for magic constructs at START.  */
 
 static void
 expand_elt (str_llist_type *str_list_ptr, const char *elt, unsigned start)
 {
   const char *dir = elt + start;
@@ -2800,17 +2968,17 @@ expand_elt (str_llist_type *str_list_ptr
         }
 
       dir++;
     }
 
   /* When we reach the end of ELT, it will be a normal filename.  */
   checked_dir_list_add (str_list_ptr, elt);
 }
-
+
 /* Here is the entry point.  Returns directory list for ELT.  */
 
 str_llist_type *
 kpse_element_dirs (const char *elt)
 {
   str_llist_type *ret;
 
   /* If given nothing, return nothing.  */
@@ -2864,18 +3032,18 @@ static const char *path = NULL;
 /* Upon entry, the static `path' is at the first (and perhaps last)
    character of the return value, or else NULL if we're at the end (or
    haven't been called).  I make no provision for caching the results;
    thus, we parse the same path over and over, on every lookup.  If that
    turns out to be a significant lose, it can be fixed, but I'm guessing
    disk accesses overwhelm everything else.  If ENV_P is true, use
    IS_ENV_SEP; else use IS_DIR_SEP.  */
 
-static char *
-element (const char *passed_path, bool env_p)
+char *
+kpse_path_element (const char *passed_path)
 {
   const char *p;
   char *ret;
   int brace_level;
   unsigned len;
 
   if (passed_path)
     path = passed_path;
@@ -2885,18 +3053,17 @@ element (const char *passed_path, bool e
     return NULL;
 
   /* OK, we have a non-null `path' if we get here.  */
   assert (path);
   p = path;
 
   /* Find the next colon not enclosed by braces (or the end of the path).  */
   brace_level = 0;
-  while (*p != 0  && !(brace_level == 0
-                       && (env_p ? IS_ENV_SEP (*p) : IS_DIR_SEP (*p))))
+  while (*p != 0  && ! (brace_level == 0 && IS_ENV_SEP (*p)))
     {
       if (*p == '{')
 	++brace_level;
       else if (*p == '}')
 	--brace_level;
 
       ++p;
     }
@@ -2919,121 +3086,31 @@ element (const char *passed_path, bool e
   if (path[len] == 0)
     path = NULL;
   else
     path += len + 1;
 
   return ret;
 }
 
-char *
-kpse_path_element (const char *p)
-{
-  return element (p, true);
-}
-
-char *
-kpse_filename_component (const char *p)
-{
-  return element (p, false);
-}
-
-/* xfopen.c: fopen and fclose with error checking.  */
-
-/* These routines just check the return status from standard library
-   routines and abort if an error happens.  */
-
-FILE *
-xfopen (const char *filename, const char *mode)
-{
-  FILE *f;
-
-  assert (filename && mode);
-
-  f = fopen (filename, mode);
-  if (f == NULL)
-    FATAL_PERROR (filename);
-
-  return f;
-}
-
-void
-xfclose (FILE *f, const char *filename)
-{
-  assert (f);
-
-  if (fclose (f) == EOF)
-    FATAL_PERROR (filename);
-}
-
 #ifndef WIN32
 void
 xclosedir (DIR *d)
 {
 #ifdef CLOSEDIR_VOID
   closedir (d);
 #else
   int ret = closedir (d);
 
   if (ret != 0)
     FATAL ("closedir failed");
 #endif
 }
 #endif
 
-/* xmalloc.c: malloc with error checking.  */
-
-void *
-xmalloc (unsigned size)
-{
-  void *new_mem = (void *) malloc (size);
-
-  if (new_mem == NULL)
-    {
-      fprintf (stderr, "fatal: memory exhausted (xmalloc of %u bytes).\n",
-               size);
-      /* 1 means success on VMS, so pick a random number (ASCII `K').  */
-      exit (75);
-    }
-
-  return new_mem;
-}
-
-/* xrealloc.c: realloc with error checking.  */
-
-extern void *xmalloc (unsigned);
-
-void *
-xrealloc (void *old_ptr, unsigned size)
-{
-  void *new_mem;
-
-  if (old_ptr == NULL)
-    new_mem = xmalloc (size);
-  else
-    {
-      new_mem = (void *) realloc (old_ptr, size);
-      if (new_mem == NULL)
-        {
-          /* We used to print OLD_PTR here using %x, and casting its
-             value to unsigned, but that lost on the Alpha, where
-             pointers and unsigned had different sizes.  Since the info
-             is of little or no value anyway, just don't print it.  */
-          fprintf (stderr, "fatal: memory exhausted (realloc of %u bytes).\n",
-                   size);
-          /* 1 means success on VMS, so pick a random number (ASCII `B').  */
-          exit (66);
-        }
-    }
-
-  return new_mem;
-}
-
-/* xstrdup.c: strdup with error checking.  */
-
 /* dir.c: directory operations.  */
 
 #ifndef WIN32
 
 /* Return -1 if FN isn't a directory, else its number of links.
    Duplicate the call to stat; no need to incur overhead of a function
    call for that little bit of cleanliness. */
 
@@ -3061,202 +3138,16 @@ dir_links (const char *fn)
 #endif
     }
 
   return ret;
 }
 
 #endif /* !WIN32 */
 
-/* hash.c: hash table operations.  */
-
-/* The hash function.  We go for simplicity here.  */
-
-/* All our hash tables are related to filenames.  */
-#ifdef MONOCASE_FILENAMES
-#define TRANSFORM(x) toupper (x)
-#else
-#define TRANSFORM(x) (x)
-#endif
-
-static unsigned
-hash (hash_table_type table, const std::string& key)
-{
-  unsigned n = 0;
-
-  /* Our keys aren't often anagrams of each other, so no point in
-     weighting the characters.  */
-  size_t len = key.length ();
-  for (size_t i = 0; i < len; i++)
-    n = (n + n + TRANSFORM (key[i])) % table.size;
-
-  return n;
-}
-
-hash_table_type
-hash_create (unsigned size)
-{
-  /* hash_table_type ret; changed into "static ..." to work around gcc
-     optimizer bug for Alpha.  */
-  static hash_table_type ret;
-  unsigned b;
-  ret.buckets = new hash_element_type * [size];
-  ret.size = size;
-
-  /* calloc's zeroes aren't necessarily NULL, so be safe.  */
-  for (b = 0; b <ret.size; b++)
-    ret.buckets[b] = NULL;
-
-  return ret;
-}
-
-/* Whether or not KEY is already in MAP, insert it and VALUE.  Do not
-   duplicate the strings, in case they're being purposefully shared.  */
-
-void
-hash_insert (hash_table_type *table, const std::string& key,
-	     const std::string& value)
-{
-  unsigned n = hash (*table, key);
-  hash_element_type *new_elt = new hash_element_type;
-
-  new_elt->key = key;
-  new_elt->value = value;
-  new_elt->next = NULL;
-
-  /* Insert the new element at the end of the list.  */
-  if (! table->buckets[n])
-    /* first element in bucket is a special case.  */
-    table->buckets[n] = new_elt;
-  else
-    {
-      hash_element_type *loc = table->buckets[n];
-      while (loc->next)		/* Find the last element.  */
-        loc = loc->next;
-      loc->next = new_elt;	/* Insert the new one after.  */
-    }
-}
-
-/* Look up STR in MAP.  Return a (dynamically-allocated) list of the
-   corresponding strings or NULL if no match.  */
-
-static string_vector
-hash_lookup (hash_table_type table, const std::string& key)
-{
-  hash_element_type *p;
-  string_vector ret;
-  unsigned n = hash (table, key);
-
-  /* Look at everything in this bucket.  */
-  for (p = table.buckets[n]; p != NULL; p = p->next)
-    if (FILESTRCASEEQ (key.c_str (), p->key.c_str ()))
-      /* Cast because the general string_vector shouldn't force const data.  */
-      str_list_add (ret, p->value);
-
-#ifdef KPSE_DEBUG
-  if (KPSE_DEBUG_P (KPSE_DEBUG_HASH))
-    {
-      DEBUGF1 ("hash_lookup (%s) =>", key.c_str ());
-      if (ret.empty ())
-        fputs (" (nil)\n", stderr);
-      else
-        {
-	  int len = ret.length ();
-	  for (int i = 0; i < len; i++)
-            {
-              putc (' ', stderr);
-	      fputs (ret[i].c_str (), stderr);
-            }
-          putc ('\n', stderr);
-        }
-      fflush (stderr);
-    }
-#endif
-
-  return ret;
-}
-
-/* We only print nonempty buckets, to decrease output volume.  */
-
-void
-hash_print (hash_table_type table, int summary_only)
-{
-  unsigned b;
-  unsigned total_elements = 0, total_buckets = 0;
-
-  for (b = 0; b < table.size; b++)
-    {
-      hash_element_type *bucket = table.buckets[b];
-
-      if (bucket)
-	{
-	  unsigned len = 1;
-	  hash_element_type *tb;
-
-	  total_buckets++;
-	  if (! summary_only)
-	    fprintf (stderr, "%4d ", b);
-
-	  for (tb = bucket->next; tb != NULL; tb = tb->next)
-	    len++;
-
-	  if (! summary_only)
-	    fprintf (stderr, ":%-5d", len);
-
-	  total_elements += len;
-
-	  if (! summary_only)
-	    {
-	      for (tb = bucket; tb != NULL; tb = tb->next)
-		fprintf (stderr, " %s=>%s", tb->key.c_str (),
-			 tb->value.c_str ());
-
-	      putc ('\n', stderr);
-	    }
-	}
-    }
-
-  fprintf (stderr,
-	   "%u buckets, %u nonempty (%u%%); %u entries, average chain %.1f.\n",
-	   table.size,
-	   total_buckets,
-	   100 * total_buckets / table.size,
-	   total_elements,
-	   total_buckets ? total_elements / (double) total_buckets : 0.0);
-}
-
-/* concat.c: dynamic string concatenation.  */
-
-/* Return the concatenation of S1 and S2.  See `concatn.c' for a
-   `concatn', which takes a variable number of arguments.  */
-
-static char *
-concat (const char *s1, const char *s2)
-{
-  char *answer = (char *) xmalloc (strlen (s1) + strlen (s2) + 1);
-  strcpy (answer, s1);
-  strcat (answer, s2);
-
-  return answer;
-}
-
-/* concat3.c: concatenate three strings.  */
-
-static char *
-concat3 (const char *s1, const char *s2, const char *s3)
-{
-  char *answer
-    = (char *) xmalloc (strlen (s1) + strlen (s2) + strlen (s3) + 1);
-  strcpy (answer, s1);
-  strcat (answer, s2);
-  strcat (answer, s3);
-
-  return answer;
-}
-
 /* debug.c: Help the user discover what's going on.  */
 
 #ifdef KPSE_DEBUG
 
 unsigned int kpathsea_debug = 0;
 
 /* If the real definitions of fopen or fclose are macros, we lose -- the
    #undef won't restore them. */
@@ -3282,44 +3173,16 @@ fclose (FILE *f)
   if (KPSE_DEBUG_P (KPSE_DEBUG_FOPEN))
     DEBUGF2 ("fclose (0x%lx) => %d\n", (unsigned long) f, ret);
 
   return ret;
 }
 
 #endif
 
-/* str-list.c: define routines for string lists.  */
-
-/* See the lib.h file for comments.  */
-
-static void
-str_list_add (string_vector& l, const std::string& s)
-{
-  int len = l.length ();
-  l.resize (len + 1);
-  l[len] = s;
-}
-
-/* May as well save some reallocations and do everything in a chunk
-   instead of calling str_list_add on each element.  */
-
-void
-str_list_concat (string_vector& target, const string_vector& more)
-{
-  int e;
-  int prev_len = target.length ();
-  int new_len = prev_len + more.length ();
-
-  target.resize (new_len);
-
-  for (e = 0; e < more.length (); e++)
-    target[prev_len + e] = more[e];
-}
-
 /* str-llist.c: Implementation of a linked list of strings.  */
 
 /* Add the new string STR to the end of the list L.  */
 
 void
 str_llist_add (str_llist_type *l, const std::string& str)
 {
   str_llist_elt_type *e;
@@ -3334,17 +3197,17 @@ str_llist_add (str_llist_type *l, const 
   for (e = *l; e && STR_LLIST_NEXT (*e); e = STR_LLIST_NEXT (*e))
     ;
 
   if (! e)
     *l = new_elt;
   else
     STR_LLIST_NEXT (*e) = new_elt;
 }
-
+
 /* Move an element towards the top. The idea is that when a file is
    found in a given directory, later files will likely be in that same
    directory, and looking for the file in all the directories in between
    is thus a waste.  */
 
 void
 str_llist_float (str_llist_type *l, str_llist_elt_type *mover)
 {
@@ -3386,17 +3249,16 @@ str_llist_float (str_llist_type *l, str_
     }
 
   /* We've moved it.  */
   STR_LLIST_MOVED (*mover) = 1;
 }
 
 /* variable.c: variable expansion.  */
 
-
 /* We have to keep track of variables being expanded, otherwise
    constructs like TEXINPUTS = $TEXINPUTS result in an infinite loop.
    (Or indirectly recursive variables, etc.)  Our simple solution is to
    add to a list each time an expansion is started, and check the list
    before expanding.  */
 
 static std::map <std::string, bool> expansions;
 
@@ -3409,17 +3271,17 @@ expanding (const std::string& var, bool 
 /* Return whether VAR is currently being expanding.  */
 
 static bool
 expanding_p (const std::string& var)
 {
   return (expansions.find (var) != expansions.end ())
     ? expansions[var] : false;
 }
-
+
 /* Append the result of value of `var' to EXPANSION, where `var' begins
    at START and ends at END.  If `var' is not set, do not complain.
    This is a subroutine for the more complicated expansion function.  */
 
 static void
 expand (std::string &expansion, const std::string& var)
 {
   if (expanding_p (var))
@@ -3436,33 +3298,32 @@ expand (std::string &expansion, const st
 	{
 	  expanding (var, true);
 	  std::string tmp = kpse_var_expand (value);
 	  expanding (var, false);
 	  expansion += tmp;
 	}
     }
 }
-
+
 /* Can't think of when it would be useful to change these (and the
    diagnostic messages assume them), but ... */
 #ifndef IS_VAR_START /* starts all variable references */
 #define IS_VAR_START(c) ((c) == '$')
 #endif
 #ifndef IS_VAR_CHAR  /* variable name constituent */
 #define IS_VAR_CHAR(c) (isalnum (c) || (c) == '_')
 #endif
 #ifndef IS_VAR_BEGIN_DELIMITER /* start delimited variable name (after $) */
 #define IS_VAR_BEGIN_DELIMITER(c) ((c) == '{')
 #endif
 #ifndef IS_VAR_END_DELIMITER
 #define IS_VAR_END_DELIMITER(c) ((c) == '}')
 #endif
 
-
 /* Maybe we should support some or all of the various shell ${...}
    constructs, especially ${var-value}.  */
 
 std::string
 kpse_var_expand (const std::string& src)
 {
   std::string expansion;
 
diff --git a/liboctave/kpse.h b/liboctave/kpse.h
--- a/liboctave/kpse.h
+++ b/liboctave/kpse.h
@@ -115,17 +115,17 @@ extern std::string kpse_expand (const st
    because there is a whole sequence of defaults to run through; see
    `kpse_init_format'.  */
 extern std::string kpse_brace_expand (const char *path);
 
 /* Do brace expansion and call `kpse_expand' on each argument of the
    result, then expand any `//' constructs.  The final expansion (always
    in fresh memory) is a path of all the existing directories that match
    the pattern. */
-extern char *kpse_path_expand (const char *path);
+extern std::string kpse_path_expand (const std::string& path);
 
 /* default.h: Declare default path expander.  */
 
 /* Replace a leading or trailing or doubled : in PATH with DFLT.  If
    no extra colons, return PATH.  Only one extra colon is replaced.
    DFLT may not be NULL.  */
 
 extern char *kpse_expand_default (const char *path, const char *dflt);
diff --git a/liboctave/pathsearch.cc b/liboctave/pathsearch.cc
--- a/liboctave/pathsearch.cc
+++ b/liboctave/pathsearch.cc
@@ -124,39 +124,29 @@ dir_path::init (void)
       char *s = getenv ("KPATHSEA_DEBUG");
 
       if (s)
 	kpathsea_debug |= atoi (s);
 
       octave_kpathsea_initialized = true;
     }
 
-  char *t1 = 0;
-
   if (p_default.empty ())
-    t1 = kpse_path_expand (p_orig.c_str ());
+    p = kpse_path_expand (p_orig);
   else
     {
       char *t2
 	= kpse_expand_default (p_orig.c_str (), p_default.c_str ());
 
-      t1 = kpse_path_expand (t2);
+      p = kpse_path_expand (t2);
 
       if (t2)
 	free (t2);
     }
 
-  if (t1)
-    {
-      p = t1;
-      free (t1);
-    }
-  else
-    p = std::string ();
-
   int count = 0;
   char *path_elt = kpse_path_element (p.c_str ());
   while (path_elt)
     {
       path_elt = kpse_path_element (0);
       count++;
     }
 
diff --git a/liboctave/str-vec.cc b/liboctave/str-vec.cc
--- a/liboctave/str-vec.cc
+++ b/liboctave/str-vec.cc
@@ -92,16 +92,43 @@ string_vector::uniq (void)
 
       if (len != ++k)
 	resize (k);
     }
 
   return *this;
 }
 
+string_vector&
+string_vector::append (const std::string& s)
+{
+  int len = length ();
+
+  resize (len + 1);
+
+  elem(len) = s;
+
+  return *this;
+}
+
+string_vector&
+string_vector::append (const string_vector& sv)
+{
+  int len = length ();
+
+  int new_len = len + sv.length ();
+
+  resize (new_len);
+
+  for (int i = 0; i < new_len; i++)
+    elem(len + i) = sv[i];
+
+  return *this;
+}
+
 char **
 string_vector::c_str_vec (void) const
 {
   int len = length ();
 
   char **retval = new char * [len + 1];
 
   retval [len] = 0;
diff --git a/liboctave/str-vec.h b/liboctave/str-vec.h
--- a/liboctave/str-vec.h
+++ b/liboctave/str-vec.h
@@ -88,16 +88,20 @@ public:
     if (make_unique)
       uniq ();
 
     return *this;
   }
 
   string_vector& uniq (void);
 
+  string_vector& append (const std::string& s);
+
+  string_vector& append (const string_vector& sv);
+
   char **c_str_vec (void) const;
 
   static void delete_c_str_vec (const char * const*);
 
   std::ostream& list_in_columns (std::ostream&) const;
 };
 
 #endif
