# HG changeset patch
# User Rik <rik@octave.org>
# Date 1383015106 25200
#      Mon Oct 28 19:51:46 2013 -0700
# Node ID 175b392e91fe2a2b6f90a9b6c30cf1755f3c120f
# Parent  34d9812a943bdd718f51c21c7456d92ee487eeb2
Use GNU style coding conventions for code in libinterp/

* libinterp/corefcn/Cell.h, libinterp/corefcn/__contourc__.cc,
libinterp/corefcn/__dispatch__.cc, libinterp/corefcn/__lin_interpn__.cc,
libinterp/corefcn/__pchip_deriv__.cc, libinterp/corefcn/__qp__.cc,
libinterp/corefcn/balance.cc, libinterp/corefcn/besselj.cc,
libinterp/corefcn/betainc.cc, libinterp/corefcn/bitfcns.cc,
libinterp/corefcn/bsxfun.cc, libinterp/corefcn/c-file-ptr-stream.cc,
libinterp/corefcn/c-file-ptr-stream.h, libinterp/corefcn/cellfun.cc,
libinterp/corefcn/colloc.cc, libinterp/corefcn/comment-list.h,
libinterp/corefcn/conv2.cc, libinterp/corefcn/daspk.cc,
libinterp/corefcn/dasrt.cc, libinterp/corefcn/dassl.cc,
libinterp/corefcn/data.cc, libinterp/corefcn/debug.cc,
libinterp/corefcn/defaults.cc, libinterp/corefcn/defaults.in.h,
libinterp/corefcn/defun-int.h, libinterp/corefcn/defun.cc,
libinterp/corefcn/det.cc, libinterp/corefcn/dirfns.cc,
libinterp/corefcn/display.cc, libinterp/corefcn/dlmread.cc,
libinterp/corefcn/dot.cc, libinterp/corefcn/dynamic-ld.cc,
libinterp/corefcn/dynamic-ld.h, libinterp/corefcn/eig.cc,
libinterp/corefcn/ellipj.cc, libinterp/corefcn/error.cc,
libinterp/corefcn/error.h, libinterp/corefcn/event-queue.h,
libinterp/corefcn/fft.cc, libinterp/corefcn/fft2.cc, libinterp/corefcn/fftn.cc,
libinterp/corefcn/file-io.cc, libinterp/corefcn/filter.cc,
libinterp/corefcn/find.cc, libinterp/corefcn/gammainc.cc,
libinterp/corefcn/gcd.cc, libinterp/corefcn/getgrent.cc,
libinterp/corefcn/getpwent.cc, libinterp/corefcn/getrusage.cc,
libinterp/corefcn/givens.cc, libinterp/corefcn/gl-render.cc,
libinterp/corefcn/gl2ps-renderer.cc, libinterp/corefcn/gl2ps-renderer.h,
libinterp/corefcn/graphics.cc, libinterp/corefcn/graphics.in.h,
libinterp/corefcn/gripes.cc, libinterp/corefcn/gripes.h,
libinterp/corefcn/help.cc, libinterp/corefcn/hess.cc,
libinterp/corefcn/hex2num.cc, libinterp/corefcn/input.cc,
libinterp/corefcn/input.h, libinterp/corefcn/inv.cc,
libinterp/corefcn/jit-ir.h, libinterp/corefcn/jit-typeinfo.cc,
libinterp/corefcn/jit-typeinfo.h, libinterp/corefcn/jit-util.h,
libinterp/corefcn/kron.cc, libinterp/corefcn/load-path.cc,
libinterp/corefcn/load-path.h, libinterp/corefcn/load-save.cc,
libinterp/corefcn/load-save.h, libinterp/corefcn/lookup.cc,
libinterp/corefcn/ls-ascii-helper.cc, libinterp/corefcn/ls-hdf5.cc,
libinterp/corefcn/ls-hdf5.h, libinterp/corefcn/ls-mat-ascii.cc,
libinterp/corefcn/ls-mat-ascii.h, libinterp/corefcn/ls-mat4.cc,
libinterp/corefcn/ls-mat5.cc, libinterp/corefcn/ls-mat5.h,
libinterp/corefcn/ls-oct-ascii.cc, libinterp/corefcn/lsode.cc,
libinterp/corefcn/lu.cc, libinterp/corefcn/luinc.cc,
libinterp/corefcn/mappers.cc, libinterp/corefcn/matrix_type.cc,
libinterp/corefcn/max.cc, libinterp/corefcn/md5sum.cc,
libinterp/corefcn/mex.cc, libinterp/corefcn/mexproto.h,
libinterp/corefcn/mgorth.cc, libinterp/corefcn/mxarray.in.h,
libinterp/corefcn/nproc.cc, libinterp/corefcn/oct-hist.cc,
libinterp/corefcn/oct-lvalue.h, libinterp/corefcn/oct-map.cc,
libinterp/corefcn/oct-map.h, libinterp/corefcn/oct-obj.h,
libinterp/corefcn/oct-prcstrm.h, libinterp/corefcn/oct-stdstrm.h,
libinterp/corefcn/oct-stream.cc, libinterp/corefcn/oct-stream.h,
libinterp/corefcn/octave-link.cc, libinterp/corefcn/octave-link.h,
libinterp/corefcn/pager.cc, libinterp/corefcn/pinv.cc,
libinterp/corefcn/pr-output.cc, libinterp/corefcn/procstream.h,
libinterp/corefcn/profiler.cc, libinterp/corefcn/pt-jit.cc,
libinterp/corefcn/pt-jit.h, libinterp/corefcn/quad.cc,
libinterp/corefcn/quadcc.cc, libinterp/corefcn/qz.cc,
libinterp/corefcn/rand.cc, libinterp/corefcn/rcond.cc,
libinterp/corefcn/regexp.cc, libinterp/corefcn/schur.cc,
libinterp/corefcn/sighandlers.cc, libinterp/corefcn/sighandlers.h,
libinterp/corefcn/sparse-xdiv.cc, libinterp/corefcn/sparse-xdiv.h,
libinterp/corefcn/sparse-xpow.cc, libinterp/corefcn/sparse.cc,
libinterp/corefcn/spparms.cc, libinterp/corefcn/sqrtm.cc,
libinterp/corefcn/str2double.cc, libinterp/corefcn/strfind.cc,
libinterp/corefcn/strfns.cc, libinterp/corefcn/sub2ind.cc,
libinterp/corefcn/svd.cc, libinterp/corefcn/syl.cc,
libinterp/corefcn/symtab.cc, libinterp/corefcn/symtab.h,
libinterp/corefcn/syscalls.cc, libinterp/corefcn/sysdep.cc,
libinterp/corefcn/sysdep.h, libinterp/corefcn/time.cc,
libinterp/corefcn/toplev.cc, libinterp/corefcn/toplev.h,
libinterp/corefcn/tril.cc, libinterp/corefcn/txt-eng-ft.cc,
libinterp/corefcn/txt-eng-ft.h, libinterp/corefcn/txt-eng.h,
libinterp/corefcn/typecast.cc, libinterp/corefcn/urlwrite.cc,
libinterp/corefcn/utils.cc, libinterp/corefcn/variables.cc,
libinterp/corefcn/variables.h, libinterp/corefcn/xdiv.cc,
libinterp/corefcn/xdiv.h, libinterp/corefcn/xnorm.h, libinterp/corefcn/xpow.cc,
libinterp/corefcn/xpow.h, libinterp/corefcn/zfstream.cc,
libinterp/corefcn/zfstream.h, libinterp/dldfcn/__delaunayn__.cc,
libinterp/dldfcn/__dsearchn__.cc, libinterp/dldfcn/__eigs__.cc,
libinterp/dldfcn/__fltk_uigetfile__.cc, libinterp/dldfcn/__glpk__.cc,
libinterp/dldfcn/__init_fltk__.cc, libinterp/dldfcn/__init_gnuplot__.cc,
libinterp/dldfcn/__magick_read__.cc, libinterp/dldfcn/__voronoi__.cc,
libinterp/dldfcn/amd.cc, libinterp/dldfcn/ccolamd.cc, libinterp/dldfcn/chol.cc,
libinterp/dldfcn/colamd.cc, libinterp/dldfcn/convhulln.cc,
libinterp/dldfcn/dmperm.cc, libinterp/dldfcn/fftw.cc, libinterp/dldfcn/qr.cc,
libinterp/dldfcn/symbfact.cc, libinterp/dldfcn/symrcm.cc,
libinterp/dldfcn/tsearch.cc, libinterp/octave-value/ov-base-diag.cc,
libinterp/octave-value/ov-base-diag.h, libinterp/octave-value/ov-base-int.cc,
libinterp/octave-value/ov-base-int.h, libinterp/octave-value/ov-base-mat.h,
libinterp/octave-value/ov-base-scalar.cc,
libinterp/octave-value/ov-base-scalar.h,
libinterp/octave-value/ov-base-sparse.cc,
libinterp/octave-value/ov-base-sparse.h, libinterp/octave-value/ov-base.cc,
libinterp/octave-value/ov-base.h, libinterp/octave-value/ov-bool-mat.cc,
libinterp/octave-value/ov-bool-mat.h, libinterp/octave-value/ov-bool-sparse.cc,
libinterp/octave-value/ov-bool-sparse.h, libinterp/octave-value/ov-bool.cc,
libinterp/octave-value/ov-bool.h, libinterp/octave-value/ov-builtin.cc,
libinterp/octave-value/ov-builtin.h, libinterp/octave-value/ov-cell.cc,
libinterp/octave-value/ov-cell.h, libinterp/octave-value/ov-ch-mat.cc,
libinterp/octave-value/ov-ch-mat.h, libinterp/octave-value/ov-class.cc,
libinterp/octave-value/ov-class.h, libinterp/octave-value/ov-colon.h,
libinterp/octave-value/ov-complex.cc, libinterp/octave-value/ov-complex.h,
libinterp/octave-value/ov-cx-diag.cc, libinterp/octave-value/ov-cx-diag.h,
libinterp/octave-value/ov-cx-mat.cc, libinterp/octave-value/ov-cx-mat.h,
libinterp/octave-value/ov-cx-sparse.cc, libinterp/octave-value/ov-cx-sparse.h,
libinterp/octave-value/ov-dld-fcn.h, libinterp/octave-value/ov-fcn-handle.cc,
libinterp/octave-value/ov-fcn-handle.h,
libinterp/octave-value/ov-fcn-inline.cc,
libinterp/octave-value/ov-fcn-inline.h, libinterp/octave-value/ov-fcn.h,
libinterp/octave-value/ov-float.cc, libinterp/octave-value/ov-float.h,
libinterp/octave-value/ov-flt-complex.cc,
libinterp/octave-value/ov-flt-complex.h,
libinterp/octave-value/ov-flt-cx-diag.cc,
libinterp/octave-value/ov-flt-cx-diag.h,
libinterp/octave-value/ov-flt-cx-mat.cc,
libinterp/octave-value/ov-flt-cx-mat.h,
libinterp/octave-value/ov-flt-re-diag.cc,
libinterp/octave-value/ov-flt-re-diag.h,
libinterp/octave-value/ov-flt-re-mat.cc,
libinterp/octave-value/ov-flt-re-mat.h, libinterp/octave-value/ov-int16.cc,
libinterp/octave-value/ov-int32.cc, libinterp/octave-value/ov-int64.cc,
libinterp/octave-value/ov-int8.cc, libinterp/octave-value/ov-intx.h,
libinterp/octave-value/ov-java.cc, libinterp/octave-value/ov-lazy-idx.h,
libinterp/octave-value/ov-mex-fcn.cc, libinterp/octave-value/ov-mex-fcn.h,
libinterp/octave-value/ov-null-mat.cc, libinterp/octave-value/ov-null-mat.h,
libinterp/octave-value/ov-oncleanup.cc, libinterp/octave-value/ov-perm.cc,
libinterp/octave-value/ov-perm.h, libinterp/octave-value/ov-range.cc,
libinterp/octave-value/ov-range.h, libinterp/octave-value/ov-re-diag.cc,
libinterp/octave-value/ov-re-diag.h, libinterp/octave-value/ov-re-mat.cc,
libinterp/octave-value/ov-re-mat.h, libinterp/octave-value/ov-re-sparse.cc,
libinterp/octave-value/ov-re-sparse.h, libinterp/octave-value/ov-scalar.cc,
libinterp/octave-value/ov-scalar.h, libinterp/octave-value/ov-str-mat.cc,
libinterp/octave-value/ov-str-mat.h, libinterp/octave-value/ov-struct.cc,
libinterp/octave-value/ov-struct.h, libinterp/octave-value/ov-type-conv.h,
libinterp/octave-value/ov-typeinfo.cc, libinterp/octave-value/ov-typeinfo.h,
libinterp/octave-value/ov-uint16.cc, libinterp/octave-value/ov-uint32.cc,
libinterp/octave-value/ov-uint64.cc, libinterp/octave-value/ov-uint8.cc,
libinterp/octave-value/ov-usr-fcn.cc, libinterp/octave-value/ov-usr-fcn.h,
libinterp/octave-value/ov.cc, libinterp/octave-value/ov.h, libinterp/octave.cc,
libinterp/operators/op-b-bm.cc, libinterp/operators/op-b-sbm.cc,
libinterp/operators/op-bm-b.cc, libinterp/operators/op-bm-bm.cc,
libinterp/operators/op-cdm-cdm.cc, libinterp/operators/op-chm.cc,
libinterp/operators/op-class.cc, libinterp/operators/op-cm-cm.cc,
libinterp/operators/op-cm-cs.cc, libinterp/operators/op-cm-s.cc,
libinterp/operators/op-cm-scm.cc, libinterp/operators/op-cm-sm.cc,
libinterp/operators/op-cs-cm.cc, libinterp/operators/op-cs-cs.cc,
libinterp/operators/op-cs-scm.cc, libinterp/operators/op-cs-sm.cc,
libinterp/operators/op-dm-dm.cc, libinterp/operators/op-dm-scm.cc,
libinterp/operators/op-double-conv.cc, libinterp/operators/op-fcdm-fcdm.cc,
libinterp/operators/op-fcm-fcm.cc, libinterp/operators/op-fcm-fcs.cc,
libinterp/operators/op-fcm-fm.cc, libinterp/operators/op-fcm-fs.cc,
libinterp/operators/op-fcs-fcm.cc, libinterp/operators/op-fcs-fcs.cc,
libinterp/operators/op-fcs-fm.cc, libinterp/operators/op-fcs-fs.cc,
libinterp/operators/op-fdm-fdm.cc, libinterp/operators/op-float-conv.cc,
libinterp/operators/op-fm-fcm.cc, libinterp/operators/op-fm-fcs.cc,
libinterp/operators/op-fm-fm.cc, libinterp/operators/op-fm-fs.cc,
libinterp/operators/op-fs-fcm.cc, libinterp/operators/op-fs-fcs.cc,
libinterp/operators/op-fs-fm.cc, libinterp/operators/op-fs-fs.cc,
libinterp/operators/op-m-cm.cc, libinterp/operators/op-m-cs.cc,
libinterp/operators/op-m-m.cc, libinterp/operators/op-m-s.cc,
libinterp/operators/op-m-scm.cc, libinterp/operators/op-m-sm.cc,
libinterp/operators/op-pm-scm.cc, libinterp/operators/op-range.cc,
libinterp/operators/op-s-cm.cc, libinterp/operators/op-s-cs.cc,
libinterp/operators/op-s-scm.cc, libinterp/operators/op-sbm-b.cc,
libinterp/operators/op-sbm-bm.cc, libinterp/operators/op-sbm-sbm.cc,
libinterp/operators/op-scm-cm.cc, libinterp/operators/op-scm-cs.cc,
libinterp/operators/op-scm-m.cc, libinterp/operators/op-scm-s.cc,
libinterp/operators/op-scm-scm.cc, libinterp/operators/op-scm-sm.cc,
libinterp/operators/op-sm-cm.cc, libinterp/operators/op-sm-m.cc,
libinterp/operators/op-sm-s.cc, libinterp/operators/op-sm-scm.cc,
libinterp/operators/op-sm-sm.cc, libinterp/operators/op-str-m.cc,
libinterp/operators/op-str-s.cc, libinterp/operators/op-str-str.cc,
libinterp/operators/ops.h, libinterp/parse-tree/lex.h,
libinterp/parse-tree/parse.h, libinterp/parse-tree/pt-arg-list.cc,
libinterp/parse-tree/pt-arg-list.h, libinterp/parse-tree/pt-assign.cc,
libinterp/parse-tree/pt-assign.h, libinterp/parse-tree/pt-binop.cc,
libinterp/parse-tree/pt-binop.h, libinterp/parse-tree/pt-bp.h,
libinterp/parse-tree/pt-cbinop.cc, libinterp/parse-tree/pt-check.cc,
libinterp/parse-tree/pt-colon.cc, libinterp/parse-tree/pt-colon.h,
libinterp/parse-tree/pt-const.cc, libinterp/parse-tree/pt-decl.cc,
libinterp/parse-tree/pt-decl.h, libinterp/parse-tree/pt-eval.cc,
libinterp/parse-tree/pt-except.h, libinterp/parse-tree/pt-exp.h,
libinterp/parse-tree/pt-fcn-handle.cc, libinterp/parse-tree/pt-id.cc,
libinterp/parse-tree/pt-id.h, libinterp/parse-tree/pt-idx.cc,
libinterp/parse-tree/pt-idx.h, libinterp/parse-tree/pt-loop.h,
libinterp/parse-tree/pt-mat.cc, libinterp/parse-tree/pt-misc.cc,
libinterp/parse-tree/pt-misc.h, libinterp/parse-tree/pt-pr-code.cc,
libinterp/parse-tree/pt-select.h, libinterp/parse-tree/pt-stmt.h,
libinterp/parse-tree/token.h, libinterp/version.cc:
Use GNU style coding conventions for code in libinterp/

diff --git a/libinterp/corefcn/Cell.h b/libinterp/corefcn/Cell.h
--- a/libinterp/corefcn/Cell.h
+++ b/libinterp/corefcn/Cell.h
@@ -84,17 +84,17 @@ public:
   void delete_elements (const octave_value_list& idx);
 
   using Array<octave_value>::assign;
 
   void assign (const octave_value_list& idx, const Cell& rhs,
                const octave_value& fill_val = Matrix ());
 
   Cell reshape (const dim_vector& new_dims) const
-    { return Array<octave_value>::reshape (new_dims); }
+  { return Array<octave_value>::reshape (new_dims); }
 
   octave_idx_type nnz (void) const;
 
   Cell column (octave_idx_type i) const;
 
   // FIXME
   boolMatrix all (int /* dim */ = 0) const { return boolMatrix (); }
 
@@ -140,11 +140,11 @@ private:
 
   typedef octave_value (octave_value::*ctype_mapper) (void) const;
 
   Cell map (ctype_mapper) const;
 };
 
 template<>
 inline Cell octave_value_extract<Cell> (const octave_value& v)
-  { return v.cell_value (); }
+{ return v.cell_value (); }
 
 #endif
diff --git a/libinterp/corefcn/__contourc__.cc b/libinterp/corefcn/__contourc__.cc
--- a/libinterp/corefcn/__contourc__.cc
+++ b/libinterp/corefcn/__contourc__.cc
@@ -159,17 +159,17 @@ drawcn (const RowVector& X, const RowVec
               ct_y = py[pt[0]] + (py[pt[1]] - py[pt[0]])/(1 + tmp);
             }
 
           start_contour (lvl, ct_x, ct_y);
           first = false;
         }
 
       // Find stop edge.
-      // FIXME -- perhaps this should use a while loop?
+      // FIXME: perhaps this should use a while loop?
       for (unsigned int k = 1; k <= 4; k++)
         {
           if (start_edge == 0 || start_edge == 2)
             stop_edge = (start_edge + k) % 4;
           else
             stop_edge = (start_edge - k) % 4;
 
           if (static_cast<char> (1 << stop_edge) & id)
@@ -293,17 +293,17 @@ cntr (const RowVector& X, const RowVecto
 
   for (unsigned int r = 0; r < nr - 1; r++)
     for (unsigned int c = 0; c < nc - 1; c++)
       if (mark (r, c) > 0)
         drawcn (X, Y, Z, lvl, r, c, 0.0, 0.0, 255, true, mark);
 }
 
 DEFUN (__contourc__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __contourc__ (@var{x}, @var{y}, @var{z}, @var{levels})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 4)
     {
diff --git a/libinterp/corefcn/__dispatch__.cc b/libinterp/corefcn/__dispatch__.cc
--- a/libinterp/corefcn/__dispatch__.cc
+++ b/libinterp/corefcn/__dispatch__.cc
@@ -35,17 +35,17 @@ along with Octave; see the file COPYING.
 #include "ov-fcn.h"
 #include "ov-typeinfo.h"
 #include "pager.h"
 #include "parse.h"
 #include "symtab.h"
 #include "variables.h"
 
 DEFUN (__dispatch__, args, nargout,
-  "Undocumented internal function")
+       "Undocumented internal function")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   std::string f, r, t;
 
   if (nargin > 0 && nargin < 4)
diff --git a/libinterp/corefcn/__lin_interpn__.cc b/libinterp/corefcn/__lin_interpn__.cc
--- a/libinterp/corefcn/__lin_interpn__.cc
+++ b/libinterp/corefcn/__lin_interpn__.cc
@@ -263,17 +263,17 @@ lin_interpn (int n, M *X, const M V, M *
 // arrays of the same size as the array @var{v} in the \"ndgrid\" format
 // or vectors.  The parameters @var{y1}, @var{y2}, @dots{}, @var{yn} are
 // all @var{n}-dimensional arrays of the same size and represent the
 // points at which the array @var{vi} is interpolated.
 //
 //This function only performs linear interpolation.
 
 DEFUN (__lin_interpn__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{vi} =} __lin_interpn__ (@var{x1}, @var{x2}, @dots{}, @var{xn}, @var{v}, @var{y1}, @var{y2}, @dots{}, @var{yn})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
diff --git a/libinterp/corefcn/__pchip_deriv__.cc b/libinterp/corefcn/__pchip_deriv__.cc
--- a/libinterp/corefcn/__pchip_deriv__.cc
+++ b/libinterp/corefcn/__pchip_deriv__.cc
@@ -46,17 +46,17 @@ extern "C"
                            const octave_idx_type& incfd,
                            octave_idx_type *ierr);
 }
 
 // Wrapper for SLATEC/PCHIP function DPCHIM to calculate the derivates
 // for piecewise polynomials.
 
 DEFUN (__pchip_deriv__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __pchip_deriv__ (@var{x}, @var{y}, @var{dim})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
   const int nargin = args.length ();
 
   bool rows = (nargin == 3 && args (2).uint_value () == 2);
diff --git a/libinterp/corefcn/__qp__.cc b/libinterp/corefcn/__qp__.cc
--- a/libinterp/corefcn/__qp__.cc
+++ b/libinterp/corefcn/__qp__.cc
@@ -225,17 +225,17 @@ qp (const Matrix& H, const ColumnVector&
           // Computing the null space.
 
           octave_idx_type rank;
 
           Matrix Z = null (Aact, rank);
 
           octave_idx_type dimZ = n - rank;
 
-          // FIXME -- still remain to handle the case of
+          // FIXME: still remain to handle the case of
           // non-full rank active set matrix.
 
           // Computing the Y matrix (orthogonal to Z)
           Y = Aact.pseudo_inverse ();
 
           // Reduced Hessian
           Matrix Zt = Z.transpose ();
           Matrix rH = Zt * H * Z;
@@ -475,17 +475,17 @@ qp (const Matrix& H, const ColumnVector&
             }
         }
     }
 
   return info;
 }
 
 DEFUN (__qp__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{x}, @var{lambda}, @var{info}, @var{iter}] =} __qp__ (@var{x0}, @var{H}, @var{q}, @var{Aeq}, @var{beq}, @var{Ain}, @var{bin}, @var{maxit})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 8)
     {
diff --git a/libinterp/corefcn/balance.cc b/libinterp/corefcn/balance.cc
--- a/libinterp/corefcn/balance.cc
+++ b/libinterp/corefcn/balance.cc
@@ -42,17 +42,17 @@ along with Octave; see the file COPYING.
 #include "defun.h"
 #include "error.h"
 #include "f77-fcn.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN (balance, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{AA} =} balance (@var{A})\n\
 @deftypefnx {Built-in Function} {@var{AA} =} balance (@var{A}, @var{opt})\n\
 @deftypefnx {Built-in Function} {[@var{DD}, @var{AA}] =} balance (@var{A}, @var{opt})\n\
 @deftypefnx {Built-in Function} {[@var{D}, @var{P}, @var{AA}] =} balance (@var{A}, @var{opt})\n\
 @deftypefnx {Built-in Function} {[@var{CC}, @var{DD}, @var{AA}, @var{BB}] =} balance (@var{A}, @var{B}, @var{opt})\n\
 \n\
 Compute @code{@var{AA} = @var{DD} \\ @var{A} * @var{DD}} in which @var{AA}\n\
 is a matrix whose row and column norms are roughly equal in magnitude, and\n\
@@ -105,21 +105,21 @@ Generalized eigenvalue problem balancing
   octave_idx_type nn = args(0).rows ();
 
   if (nn != args(0).columns ())
     {
       gripe_square_matrix_required ("balance");
       return retval;
     }
 
-  bool isfloat = args(0).is_single_type () ||
-    (! AEPcase && args(1).is_single_type ());
+  bool isfloat = args(0).is_single_type ()
+                 || (! AEPcase && args(1).is_single_type ());
 
-  bool complex_case = (args(0).is_complex_type () ||
-                       (! AEPcase && args(1).is_complex_type ()));
+  bool complex_case = args(0).is_complex_type ()
+                      || (! AEPcase && args(1).is_complex_type ());
 
   // Extract argument 1 parameter for both AEP and GEP.
   Matrix aa;
   ComplexMatrix caa;
   FloatMatrix faa;
   FloatComplexMatrix fcaa;
 
   if (isfloat)
diff --git a/libinterp/corefcn/besselj.cc b/libinterp/corefcn/besselj.cc
--- a/libinterp/corefcn/besselj.cc
+++ b/libinterp/corefcn/besselj.cc
@@ -123,17 +123,18 @@ do_bessel (enum bessel_type type, const 
 
                           retval(0) = result;
                         }
                       else
                         gripe_bessel_arg (fn, "second");
                     }
                   else
                     {
-                      FloatComplexNDArray x = x_arg.float_complex_array_value ();
+                      FloatComplexNDArray x
+                        = x_arg.float_complex_array_value ();
 
                       if (! error_state)
                         {
                           Array<octave_idx_type> ierr;
                           octave_value result;
 
                           DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
@@ -206,17 +207,18 @@ do_bessel (enum bessel_type type, const 
 
                               retval(0) = result;
                             }
                           else
                             gripe_bessel_arg (fn, "second");
                         }
                       else
                         {
-                          FloatComplexNDArray x = x_arg.float_complex_array_value ();
+                          FloatComplexNDArray x
+                            = x_arg.float_complex_array_value ();
 
                           if (! error_state)
                             {
                               Array<octave_idx_type> ierr;
                               octave_value result;
 
                               DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
@@ -372,17 +374,17 @@ do_bessel (enum bessel_type type, const 
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (besselj, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{j}, @var{ierr}] =} besselj (@var{alpha}, @var{x}, @var{opt})\n\
 @deftypefnx {Built-in Function} {[@var{y}, @var{ierr}] =} bessely (@var{alpha}, @var{x}, @var{opt})\n\
 @deftypefnx {Built-in Function} {[@var{i}, @var{ierr}] =} besseli (@var{alpha}, @var{x}, @var{opt})\n\
 @deftypefnx {Built-in Function} {[@var{k}, @var{ierr}] =} besselk (@var{alpha}, @var{x}, @var{opt})\n\
 @deftypefnx {Built-in Function} {[@var{h}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})\n\
 Compute Bessel or Hankel functions of various kinds:\n\
 \n\
 @table @code\n\
@@ -446,44 +448,44 @@ Error---no computation, algorithm termin
 return @code{NaN}.\n\
 @end enumerate\n\
 @end deftypefn")
 {
   return do_bessel (BESSEL_J, "besselj", args, nargout);
 }
 
 DEFUN (bessely, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{y}, @var{ierr}] =} bessely (@var{alpha}, @var{x}, @var{opt})\n\
 See besselj.\n\
 @end deftypefn")
 {
   return do_bessel (BESSEL_Y, "bessely", args, nargout);
 }
 
 DEFUN (besseli, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{i}, @var{ierr}] =} besseli (@var{alpha}, @var{x}, @var{opt})\n\
 See besselj.\n\
 @end deftypefn")
 {
   return do_bessel (BESSEL_I, "besseli", args, nargout);
 }
 
 DEFUN (besselk, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{k}, @var{ierr}] =} besselk (@var{alpha}, @var{x}, @var{opt})\n\
 See besselj.\n\
 @end deftypefn")
 {
   return do_bessel (BESSEL_K, "besselk", args, nargout);
 }
 
 DEFUN (besselh, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{h}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})\n\
 See besselj.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
@@ -517,17 +519,17 @@ See besselj.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (airy, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{a}, @var{ierr}] =} airy (@var{k}, @var{z}, @var{opt})\n\
 Compute Airy functions of the first and second kind, and their\n\
 derivatives.\n\
 \n\
 @example\n\
 @group\n\
  K   Function   Scale factor (if \"opt\" is supplied)\n\
 ---  --------   ---------------------------------------\n\
diff --git a/libinterp/corefcn/betainc.cc b/libinterp/corefcn/betainc.cc
--- a/libinterp/corefcn/betainc.cc
+++ b/libinterp/corefcn/betainc.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 // FIXME: These functions do not need to be dynamically loaded.  They should
 //        be placed elsewhere in the Octave code hierarchy.
 
 DEFUN (betainc, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} betainc (@var{x}, @var{a}, @var{b})\n\
 Return the regularized incomplete Beta function,\n\
 @tex\n\
 $$\n\
  I (x, a, b) = {1 \\over {B (a, b)}} \\int_0^x t^{(a-z)} (1-t)^{(b-1)} dt.\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
@@ -325,17 +325,17 @@ compatible dimensions.\n\
 
 %!error betainc ()
 %!error betainc (1)
 %!error betainc (1,2)
 %!error betainc (1,2,3,4)
 */
 
 DEFUN (betaincinv, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} betaincinv (@var{y}, @var{a}, @var{b})\n\
 Compute the inverse of the incomplete Beta function, i.e., @var{x} such that\n\
 \n\
 @example\n\
 @var{y} == betainc (@var{x}, @var{a}, @var{b}) \n\
 @end example\n\
 @seealso{betainc, beta, betaln}\n\
 @end deftypefn")
diff --git a/libinterp/corefcn/bitfcns.cc b/libinterp/corefcn/bitfcns.cc
--- a/libinterp/corefcn/bitfcns.cc
+++ b/libinterp/corefcn/bitfcns.cc
@@ -43,36 +43,36 @@ along with Octave; see the file COPYING.
 #include "ov-float.h"
 #include "ov-scalar.h"
 #include "ov-re-mat.h"
 #include "ov-bool.h"
 
 #include <functional>
 
 #if !defined (HAVE_CXX_BITWISE_OP_TEMPLATES)
-namespace std 
+namespace std
 {
   template <typename T>
-  struct bit_and 
+  struct bit_and
   {
-  public: 
+  public:
     T operator() (const T & op1, const T & op2) const { return (op1 & op2); }
   };
 
   template <typename T>
-  struct bit_or 
+  struct bit_or
   {
-  public: 
+  public:
     T operator() (const T & op1, const T & op2) const { return (op1 | op2); }
   };
 
   template <typename T>
-  struct bit_xor 
+  struct bit_xor
   {
-  public: 
+  public:
     T operator() (const T & op1, const T & op2) const { return (op1 ^ op2); }
   };
 }
 #endif
 
 template <typename OP, typename T>
 octave_value
 bitopxx (const OP& op, const std::string& fname,
@@ -340,39 +340,39 @@ bitop (const std::string& fname, const o
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (bitand, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} bitand (@var{x}, @var{y})\n\
 Return the bitwise AND of non-negative integers.\n\
 @var{x}, @var{y} must be in the range [0,bitmax]\n\
 @seealso{bitor, bitxor, bitset, bitget, bitcmp, bitshift, bitmax}\n\
 @end deftypefn")
 {
   return bitop ("bitand", args);
 }
 
 DEFUN (bitor, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} bitor (@var{x}, @var{y})\n\
 Return the bitwise OR of non-negative integers.\n\
 @var{x}, @var{y} must be in the range [0,bitmax]\n\
 @seealso{bitor, bitxor, bitset, bitget, bitcmp, bitshift, bitmax}\n\
 @end deftypefn")
 {
   return bitop ("bitor", args);
 }
 
 DEFUN (bitxor, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} bitxor (@var{x}, @var{y})\n\
 Return the bitwise XOR of non-negative integers.\n\
 @var{x}, @var{y} must be in the range [0,bitmax]\n\
 @seealso{bitand, bitor, bitset, bitget, bitcmp, bitshift, bitmax}\n\
 @end deftypefn")
 {
   return bitop ("bitxor", args);
 }
@@ -491,17 +491,17 @@ bitshift (float a, int n, int64_t mask)
       else if ((N) < 1) \
         mask = 0; \
       mask = mask | octave_ ## T :: min (); /* FIXME: 2's complement only? */ \
       DO_BITSHIFT (T); \
     } \
   while (0)
 
 DEFUN (bitshift, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} bitshift (@var{a}, @var{k})\n\
 @deftypefnx {Built-in Function} {} bitshift (@var{a}, @var{k}, @var{n})\n\
 Return a @var{k} bit shift of @var{n}-digit unsigned\n\
 integers in @var{a}.  A positive @var{k} leads to a left shift;\n\
 A negative value to a right shift.  If @var{n} is omitted it defaults\n\
 to log2(bitmax)+1.\n\
 @var{n} must be in the range [1,log2(bitmax)+1] usually [1,33].\n\
 \n\
@@ -538,17 +538,17 @@ bitshift (10, [-2, -1, 0, 1, 2])\n\
       NDArray n = args(1).array_value ();
 
       if (error_state)
         error ("bitshift: expecting integer as second argument");
       else
         {
           if (nargin == 3)
             {
-              // FIXME -- for compatibility, we should accept an array
+              // FIXME: for compatibility, we should accept an array
               // or a scalar as the third argument.
               if (args(2).numel () > 1)
                 error ("bitshift: N must be a scalar integer");
               else
                 {
                   nbits = args(2).int_value ();
 
                   if (error_state)
@@ -578,51 +578,56 @@ bitshift (10, [-2, -1, 0, 1, 2])\n\
       else if (cname == "int16")
         DO_SBITSHIFT (int16, nbits < 16 ? nbits : 16);
       else if (cname == "int32")
         DO_SBITSHIFT (int32, nbits < 32 ? nbits : 32);
       else if (cname == "int64")
         DO_SBITSHIFT (int64, nbits < 64 ? nbits : 64);
       else if (cname == "double")
         {
-          static const int bits_in_mantissa = std::numeric_limits<double>::digits;
+          static const int bits_in_mantissa
+            = std::numeric_limits<double>::digits;
+
           nbits = (nbits < bits_in_mantissa ? nbits : bits_in_mantissa);
           int64_t mask = max_mantissa_value<double> ();
           if (nbits < bits_in_mantissa)
             mask = mask >> (bits_in_mantissa - nbits);
           else if (nbits < 1)
             mask = 0;
-          int bits_in_type = sizeof (double) * std::numeric_limits<unsigned char>::digits;
+          int bits_in_type = sizeof (double)
+                             * std::numeric_limits<unsigned char>::digits;
           NDArray m = m_arg.array_value ();
           DO_BITSHIFT ( );
         }
       else if (cname == "single")
         {
-          static const int bits_in_mantissa = std::numeric_limits<float>::digits;
+          static const int bits_in_mantissa
+            = std::numeric_limits<float>::digits;
           nbits = (nbits < bits_in_mantissa ? nbits : bits_in_mantissa);
           int64_t mask = max_mantissa_value<float> ();
           if (nbits < bits_in_mantissa)
             mask = mask >> (bits_in_mantissa - nbits);
           else if (nbits < 1)
             mask = 0;
-          int bits_in_type = sizeof (float) * std::numeric_limits<unsigned char>::digits;
+          int bits_in_type = sizeof (float)
+                             * std::numeric_limits<unsigned char>::digits;
           FloatNDArray m = m_arg.float_array_value ();
           DO_BITSHIFT (Float);
         }
       else
         error ("bitshift: not defined for %s objects", cname.c_str ());
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (bitmax, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} bitmax ()\n\
 @deftypefnx {Built-in Function} {} bitmax (\"double\")\n\
 @deftypefnx {Built-in Function} {} bitmax (\"single\")\n\
 Return the largest integer that can be represented within a floating point\n\
 value.  The default class is @qcode{\"double\"}, but @qcode{\"single\"} is a\n\
 valid option.  On IEEE-754 compatible systems, @code{bitmax} is\n\
 @w{@math{2^{53} - 1}} for @qcode{\"double\"} and @w{@math{2^{24} -1}} for\n\
 @qcode{\"single\"}.\n\
@@ -647,17 +652,17 @@ valid option.  On IEEE-754 compatible sy
     retval = (static_cast<float> (max_mantissa_value<float> ()));
   else
     error ("bitmax: not defined for class '%s'", cname.c_str ());
 
   return retval;
 }
 
 DEFUN (flintmax, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} flintmax ()\n\
 @deftypefnx {Built-in Function} {} flintmax (\"double\")\n\
 @deftypefnx {Built-in Function} {} flintmax (\"single\")\n\
 Return the largest integer that can be represented consecutively in a\n\
 floating point value.  The default class is @qcode{\"double\"}, but\n\
 @qcode{\"single\"} is a valid option.  On IEEE-754 compatible systems,\n\
 @code{flintmax} is @w{@math{2^53}} for @qcode{\"double\"} and\n\
 @w{@math{2^24}} for @qcode{\"single\"}.\n\
@@ -682,17 +687,17 @@ floating point value.  The default class
     retval = (static_cast<float> (max_mantissa_value<float> () + 1));
   else
     error ("flintmax: not defined for class '%s'", cname.c_str ());
 
   return retval;
 }
 
 DEFUN (intmax, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} intmax (@var{type})\n\
 Return the largest integer that can be represented in an integer type.\n\
 The variable @var{type} can be\n\
 \n\
 @table @code\n\
 @item int8\n\
 signed 8-bit integer.\n\
 \n\
@@ -752,17 +757,17 @@ The default for @var{type} is @code{uint
     retval = octave_int64 (std::numeric_limits<int64_t>::max ());
   else
     error ("intmax: not defined for '%s' objects", cname.c_str ());
 
   return retval;
 }
 
 DEFUN (intmin, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} intmin (@var{type})\n\
 Return the smallest integer that can be represented in an integer type.\n\
 The variable @var{type} can be\n\
 \n\
 @table @code\n\
 @item int8\n\
 signed 8-bit integer.\n\
 \n\
@@ -822,17 +827,17 @@ The default for @var{type} is @code{uint
     retval = octave_int64 (std::numeric_limits<int64_t>::min ());
   else
     error ("intmin: not defined for '%s' objects", cname.c_str ());
 
   return retval;
 }
 
 DEFUN (sizemax, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} sizemax ()\n\
 Return the largest value allowed for the size of an array.\n\
 If Octave is compiled with 64-bit indexing, the result is of class int64,\n\
 otherwise it is of class int32.  The maximum array size is slightly\n\
 smaller than the maximum value allowable for the relevant class as reported\n\
 by @code{intmax}.\n\
 @seealso{intmax}\n\
 @end deftypefn")
diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -84,17 +84,18 @@ static bsxfun_builtin_op
 bsxfun_builtin_lookup (const std::string& name)
 {
   for (int i = 0; i < bsxfun_num_builtin_ops; i++)
     if (name == bsxfun_builtin_names[i])
       return static_cast<bsxfun_builtin_op> (i);
   return bsxfun_builtin_unknown;
 }
 
-typedef octave_value (*bsxfun_handler) (const octave_value&, const octave_value&);
+typedef octave_value (*bsxfun_handler) (const octave_value&,
+                                        const octave_value&);
 
 // Static table of handlers.
 bsxfun_handler bsxfun_handler_table[bsxfun_num_builtin_ops][btyp_num_types];
 
 template <class NDA, NDA (bsxfun_op) (const NDA&, const NDA&)>
 static octave_value
 bsxfun_forward_op (const octave_value& x, const octave_value& y)
 {
@@ -107,17 +108,18 @@ template <class NDA, boolNDArray (bsxfun
 static octave_value
 bsxfun_forward_rel (const octave_value& x, const octave_value& y)
 {
   NDA xa = octave_value_extract<NDA> (x);
   NDA ya = octave_value_extract<NDA> (y);
   return octave_value (bsxfun_rel (xa, ya));
 }
 
-// Pow needs a special handler for reals because of the potentially complex result.
+// pow() needs a special handler for reals
+// because of the potentially complex result.
 template <class NDA, class CNDA>
 static octave_value
 do_bsxfun_real_pow (const octave_value& x, const octave_value& y)
 {
   NDA xa = octave_value_extract<NDA> (x);
   NDA ya = octave_value_extract<NDA> (y);
   if (! ya.all_integers () && xa.any_element_is_negative ())
     return octave_value (bsxfun_pow (CNDA (xa), ya));
@@ -167,18 +169,20 @@ static void maybe_fill_table (void)
   REGISTER_OP_HANDLER (bsxfun_builtin_or, btyp_bool, boolNDArray, bsxfun_or);
 
   // Register power handlers.
   bsxfun_handler_table[bsxfun_builtin_power][btyp_double] =
     do_bsxfun_real_pow<NDArray, ComplexNDArray>;
   bsxfun_handler_table[bsxfun_builtin_power][btyp_float] =
     do_bsxfun_real_pow<FloatNDArray, FloatComplexNDArray>;
 
-  REGISTER_OP_HANDLER (bsxfun_builtin_power, btyp_complex, ComplexNDArray, bsxfun_pow);
-  REGISTER_OP_HANDLER (bsxfun_builtin_power, btyp_float_complex, FloatComplexNDArray, bsxfun_pow);
+  REGISTER_OP_HANDLER (bsxfun_builtin_power, btyp_complex, ComplexNDArray,
+                       bsxfun_pow);
+  REGISTER_OP_HANDLER (bsxfun_builtin_power, btyp_float_complex,
+                       FloatComplexNDArray, bsxfun_pow);
 
   // For chars, we want just relational handlers.
   REGISTER_REL_HANDLER (bsxfun_builtin_eq, btyp_char, charNDArray, bsxfun_eq);
   REGISTER_REL_HANDLER (bsxfun_builtin_ne, btyp_char, charNDArray, bsxfun_ne);
   REGISTER_REL_HANDLER (bsxfun_builtin_lt, btyp_char, charNDArray, bsxfun_lt);
   REGISTER_REL_HANDLER (bsxfun_builtin_le, btyp_char, charNDArray, bsxfun_le);
   REGISTER_REL_HANDLER (bsxfun_builtin_gt, btyp_char, charNDArray, bsxfun_gt);
   REGISTER_REL_HANDLER (bsxfun_builtin_ge, btyp_char, charNDArray, bsxfun_ge);
@@ -268,17 +272,17 @@ maybe_update_column (octave_value& Ac, c
           return true;
         }
       else
         return false;
     }
 }
 
 #if 0
-// FIXME -- this function is not used; is it OK to delete it?
+// FIXME: this function is not used; is it OK to delete it?
 static void
 update_index (octave_value_list& idx, const dim_vector& dv, octave_idx_type i)
 {
   octave_idx_type nd = dv.length ();
 
   if (i == 0)
     {
       for (octave_idx_type j = nd - 1; j > 0; j--)
@@ -305,17 +309,17 @@ update_index (Array<int>& idx, const dim
   for (octave_idx_type j = 1; j < nd; j++)
     {
       idx (j) = i % dv (j);
       i = i / dv (j);
     }
 }
 
 DEFUN (bsxfun, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} bsxfun (@var{f}, @var{A}, @var{B})\n\
 The binary singleton expansion function applier performs broadcasting,\n\
 that is, applies a binary function @var{f} element-by-element to two\n\
 array arguments @var{A} and @var{B}, and expands as necessary\n\
 singleton dimensions in either input argument.  @var{f} is a function\n\
 handle, inline function, or string containing the name of the function\n\
 to evaluate.  The function @var{f} must be capable of accepting two\n\
 column-vector arguments of equal length, or one column vector argument\n\
@@ -338,48 +342,51 @@ dimensionality as the other array.\n\
 
       if (func.is_string ())
         {
           std::string name = func.string_value ();
           func = symbol_table::find_function (name);
           if (func.is_undefined ())
             error ("bsxfun: invalid function name: %s", name.c_str ());
         }
-      else if (! (args(0).is_function_handle () || args(0).is_inline_function ()))
+      else if (! (args(0).is_function_handle ()
+               || args(0).is_inline_function ()))
         error ("bsxfun: F must be a string or function handle");
 
       const octave_value A = args (1);
       const octave_value B = args (2);
 
       if (func.is_builtin_function ()
-          || (func.is_function_handle () && ! A.is_object () && ! B.is_object ()))
+          || (func.is_function_handle ()
+              && ! A.is_object () && ! B.is_object ()))
         {
-          // This may break if the default behavior is overriden. But if you override
-          // arithmetic operators for builtin classes, you should expect mayhem
-          // anyway (constant folding etc). Querying is_overloaded may not be
-          // exactly what we need here.
+          // This may break if the default behavior is overriden.  But if you
+          // override arithmetic operators for builtin classes, you should
+          // expect mayhem anyway (constant folding etc).  Querying
+          // is_overloaded() may not be exactly what we need here.
           octave_function *fcn_val = func.function_value ();
           if (fcn_val)
             {
-              octave_value tmp = maybe_optimized_builtin (fcn_val->name (), A, B);
+              octave_value tmp = maybe_optimized_builtin (fcn_val->name (),
+                                                          A, B);
               if (tmp.is_defined ())
                 retval(0) = tmp;
             }
         }
 
       if (! error_state && retval.empty ())
         {
           dim_vector dva = A.dims ();
           octave_idx_type nda = dva.length ();
           dim_vector dvb = B.dims ();
           octave_idx_type ndb = dvb.length ();
           octave_idx_type nd = nda;
 
           if (nda > ndb)
-              dvb.resize (nda, 1);
+            dvb.resize (nda, 1);
           else if (nda < ndb)
             {
               dva.resize (ndb, 1);
               nd = ndb;
             }
 
           for (octave_idx_type i = 0; i < nd; i++)
             if (dva (i) != dvb (i) && dva (i) != 1 && dvb (i) != 1)
@@ -390,18 +397,20 @@ dimensionality as the other array.\n\
 
           if (!error_state)
             {
               // Find the size of the output
               dim_vector dvc;
               dvc.resize (nd);
 
               for (octave_idx_type i = 0; i < nd; i++)
-                dvc (i) = (dva (i) < 1  ? dva (i) : (dvb (i) < 1 ? dvb (i) :
-                      (dva (i) > dvb (i) ? dva (i) : dvb (i))));
+                dvc (i) = (dva (i) < 1 ? dva (i)
+                                       : (dvb (i) < 1 ? dvb (i)
+                                                      : (dva (i) > dvb (i)
+                                                        ? dva (i) : dvb (i))));
 
               if (dva == dvb || dva.numel () == 1 || dvb.numel () == 1)
                 {
                   octave_value_list inputs;
                   inputs (0) = A;
                   inputs (1) = B;
                   retval = func.do_multi_index_op (1, inputs);
                 }
@@ -448,17 +457,18 @@ dimensionality as the other array.\n\
                   for (octave_idx_type i = 0; i < ncount; i++)
                     {
                       if (maybe_update_column (Ac, A, dva, dvc, i, idxA))
                         inputs (0) = Ac;
 
                       if (maybe_update_column (Bc, B, dvb, dvc, i, idxB))
                         inputs (1) = Bc;
 
-                      octave_value_list tmp = func.do_multi_index_op (1, inputs);
+                      octave_value_list tmp = func.do_multi_index_op (1,
+                                                                      inputs);
 
                       if (error_state)
                         break;
 
 #define BSXINIT(T, CLS, EXTRACTOR) \
                       (result_type == CLS) \
                         { \
                             have_ ## T = true; \
@@ -488,17 +498,18 @@ dimensionality as the other array.\n\
                                       result_ComplexNDArray.resize (dvc);
                                     }
                                 }
                               else if (result_type == "single")
                                 {
                                   if (tmp(0).is_real_type ())
                                     {
                                       have_FloatNDArray = true;
-                                      result_FloatNDArray = tmp(0).float_array_value ();
+                                      result_FloatNDArray
+                                        = tmp(0).float_array_value ();
                                       result_FloatNDArray.resize (dvc);
                                     }
                                   else
                                     {
                                       have_ComplexNDArray = true;
                                       result_ComplexNDArray =
                                         tmp(0).complex_array_value ();
                                       result_ComplexNDArray.resize (dvc);
@@ -566,17 +577,18 @@ dimensionality as the other array.\n\
                               else if (tmp(0).is_real_type ())
                                 result_FloatNDArray.insert
                                   (tmp(0).float_array_value (), ra_idx);
                               else
                                 {
                                   result_FloatComplexNDArray =
                                     FloatComplexNDArray (result_FloatNDArray);
                                   result_FloatComplexNDArray.insert
-                                    (tmp(0).float_complex_array_value (), ra_idx);
+                                    (tmp(0).float_complex_array_value (),
+                                     ra_idx);
                                   have_FloatNDArray = false;
                                   have_FloatComplexNDArray = true;
                                 }
                             }
                           else if (have_NDArray)
                             {
                               if (! tmp(0).is_float_type ())
                                 {
diff --git a/libinterp/corefcn/c-file-ptr-stream.cc b/libinterp/corefcn/c-file-ptr-stream.cc
--- a/libinterp/corefcn/c-file-ptr-stream.cc
+++ b/libinterp/corefcn/c-file-ptr-stream.cc
@@ -40,17 +40,17 @@ along with Octave; see the file COPYING.
 #define SEEK_END 2
 #endif
 
 c_file_ptr_buf::~c_file_ptr_buf (void)
 {
   buf_close ();
 }
 
-// FIXME -- I'm sure there is room for improvement here...
+// FIXME: I'm sure there is room for improvement here...
 
 c_file_ptr_buf::int_type
 c_file_ptr_buf::overflow (int_type c)
 {
 #if defined (CXX_ISO_COMPLIANT_LIBRARY)
   if (f)
     return (c != traits_type::eof ()) ? gnulib::fputc (c, f) : flush ();
   else
@@ -87,18 +87,18 @@ c_file_ptr_buf::underflow_common (bool b
     return EOF;
 #endif
 }
 
 c_file_ptr_buf::int_type
 c_file_ptr_buf::pbackfail (int_type c)
 {
 #if defined (CXX_ISO_COMPLIANT_LIBRARY)
-  return (c != traits_type::eof () && f) ? ungetc (c, f) :
-    traits_type::not_eof (c);
+  return (c != traits_type::eof () && f) ? ungetc (c, f)
+                                         : traits_type::not_eof (c);
 #else
   return (c != EOF && f) ? ungetc (c, f) : EOF;
 #endif
 }
 
 std::streamsize
 c_file_ptr_buf::xsputn (const char* s, std::streamsize n)
 {
@@ -212,17 +212,17 @@ c_file_ptr_buf::file_close (FILE *f)
 
 #ifdef HAVE_ZLIB
 
 c_zfile_ptr_buf::~c_zfile_ptr_buf (void)
 {
   buf_close ();
 }
 
-// FIXME -- I'm sure there is room for improvement here...
+// FIXME: I'm sure there is room for improvement here...
 
 c_zfile_ptr_buf::int_type
 c_zfile_ptr_buf::overflow (int_type c)
 {
 #if defined (CXX_ISO_COMPLIANT_LIBRARY)
   if (f)
     return (c != traits_type::eof ()) ? gzputc (f, c) : flush ();
   else
@@ -259,18 +259,18 @@ c_zfile_ptr_buf::underflow_common (bool 
     return EOF;
 #endif
 }
 
 c_zfile_ptr_buf::int_type
 c_zfile_ptr_buf::pbackfail (int_type c)
 {
 #if defined (CXX_ISO_COMPLIANT_LIBRARY)
-  return (c != traits_type::eof () && f) ? gzungetc (c, f) :
-    traits_type::not_eof (c);
+  return (c != traits_type::eof () && f) ? gzungetc (c, f)
+                                         : traits_type::not_eof (c);
 #else
   return (c != EOF && f) ? gzungetc (c, f) : EOF;
 #endif
 }
 
 std::streamsize
 c_zfile_ptr_buf::xsputn (const char* s, std::streamsize n)
 {
@@ -331,17 +331,17 @@ c_zfile_ptr_buf::sync (void)
   flush ();
 
   return 0;
 }
 
 int
 c_zfile_ptr_buf::flush (void)
 {
-  // FIXME -- do we need something more complex here, passing
+  // FIXME: do we need something more complex here, passing
   // something other than 0 for the second argument to gzflush and
   // checking the return value, etc.?
 
   return f ? gzflush (f, 0) : EOF;
 }
 
 int
 c_zfile_ptr_buf::buf_close (void)
diff --git a/libinterp/corefcn/c-file-ptr-stream.h b/libinterp/corefcn/c-file-ptr-stream.h
--- a/libinterp/corefcn/c-file-ptr-stream.h
+++ b/libinterp/corefcn/c-file-ptr-stream.h
@@ -39,17 +39,17 @@ public:
 #endif
 
   typedef int (*close_fcn) (FILE *);
 
   FILE* stdiofile (void) { return f; }
 
   c_file_ptr_buf (FILE *f_arg, close_fcn cf_arg = file_close)
     : std::streambuf (), f (f_arg), cf (cf_arg)
-    { }
+  { }
 
   ~c_file_ptr_buf (void);
 
   int_type overflow (int_type);
 
   int_type underflow (void) { return underflow_common (false); }
 
   int_type uflow (void) { return underflow_common (true); }
@@ -94,18 +94,17 @@ private:
 
   // No copying!
 
   c_file_ptr_buf (const c_file_ptr_buf&);
 
   c_file_ptr_buf& operator = (const c_file_ptr_buf&);
 };
 
-// FIXME -- the following three classes could probably share
-// some code...
+// FIXME: the following three classes could probably share some code...
 
 template <typename STREAM_T, typename FILE_T, typename BUF_T>
 class
 c_file_ptr_stream : public STREAM_T
 {
 public:
 
   c_file_ptr_stream (FILE_T f, typename BUF_T::close_fcn cf = BUF_T::file_close)
@@ -113,36 +112,39 @@ public:
 
   ~c_file_ptr_stream (void) { delete buf; buf = 0; }
 
   BUF_T *rdbuf (void) { return buf; }
 
   void stream_close (void) { if (buf) buf->buf_close (); }
 
   int seek (off_t offset, int origin)
-    { return buf ? buf->seek (offset, origin) : -1; }
+  { return buf ? buf->seek (offset, origin) : -1; }
 
   off_t tell (void) { return buf ? buf->tell () : -1; }
 
   void clear (void) { if (buf) buf->clear (); STREAM_T::clear (); }
 
 private:
 
   BUF_T *buf;
 
   // No copying!
 
   c_file_ptr_stream (const c_file_ptr_stream&);
 
   c_file_ptr_stream& operator = (const c_file_ptr_stream&);
 };
 
-typedef c_file_ptr_stream<std::istream, FILE *, c_file_ptr_buf> i_c_file_ptr_stream;
-typedef c_file_ptr_stream<std::ostream, FILE *, c_file_ptr_buf> o_c_file_ptr_stream;
-typedef c_file_ptr_stream<std::iostream, FILE *, c_file_ptr_buf> io_c_file_ptr_stream;
+typedef c_file_ptr_stream<std::istream, FILE *, c_file_ptr_buf>
+  i_c_file_ptr_stream;
+typedef c_file_ptr_stream<std::ostream, FILE *, c_file_ptr_buf>
+  o_c_file_ptr_stream;
+typedef c_file_ptr_stream<std::iostream, FILE *, c_file_ptr_buf>
+  io_c_file_ptr_stream;
 
 #ifdef HAVE_ZLIB
 
 #ifdef HAVE_ZLIB_H
 #include <zlib.h>
 #endif
 
 class
@@ -157,17 +159,17 @@ public:
 #endif
 
   typedef int (*close_fcn) (gzFile);
 
   gzFile stdiofile (void) { return f; }
 
   c_zfile_ptr_buf (gzFile f_arg, close_fcn cf_arg = file_close)
     : std::streambuf (), f (f_arg), cf (cf_arg)
-    { }
+  { }
 
   ~c_zfile_ptr_buf (void);
 
   int_type overflow (int_type);
 
   int_type underflow (void) { return underflow_common (false); }
 
   int_type uflow (void) { return underflow_common (true); }
@@ -188,17 +190,17 @@ public:
 
   int flush (void);
 
   int buf_close (void);
 
   int file_number () const { return -1; }
 
   int seek (off_t offset, int origin)
-    { return f ? gzseek (f, offset, origin) >= 0 : -1; }
+  { return f ? gzseek (f, offset, origin) >= 0 : -1; }
 
   off_t tell (void) { return f ? gztell (f) : -1; }
 
   void clear (void) { if (f) gzclearerr (f); }
 
   static int file_close (gzFile f) { return ::gzclose (f); }
 
 protected:
@@ -213,15 +215,18 @@ private:
 
   // No copying!
 
   c_zfile_ptr_buf (const c_zfile_ptr_buf&);
 
   c_zfile_ptr_buf& operator = (const c_zfile_ptr_buf&);
 };
 
-typedef c_file_ptr_stream<std::istream, gzFile, c_zfile_ptr_buf> i_c_zfile_ptr_stream;
-typedef c_file_ptr_stream<std::ostream, gzFile, c_zfile_ptr_buf> o_c_zfile_ptr_stream;
-typedef c_file_ptr_stream<std::iostream, gzFile, c_zfile_ptr_buf> io_c_zfile_ptr_stream;
+typedef c_file_ptr_stream<std::istream, gzFile, c_zfile_ptr_buf>
+  i_c_zfile_ptr_stream;
+typedef c_file_ptr_stream<std::ostream, gzFile, c_zfile_ptr_buf>
+  o_c_zfile_ptr_stream;
+typedef c_file_ptr_stream<std::iostream, gzFile, c_zfile_ptr_buf>
+  io_c_zfile_ptr_stream;
 
 #endif
 
 #endif
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -65,32 +65,36 @@ along with Octave; see the file COPYING.
 
 static octave_value_list
 get_output_list (octave_idx_type count, octave_idx_type nargout,
                  const octave_value_list& inputlist,
                  octave_value& func,
                  octave_value& error_handler)
 {
   octave_value_list tmp;
-  try {
-    tmp = func.do_multi_index_op (nargout, inputlist);
-  }
-  catch (octave_execution_exception) {
-    if (error_handler.is_defined ())
-      error_state = 1;
-  }
+  try
+    {
+      tmp = func.do_multi_index_op (nargout, inputlist);
+    }
+  catch (octave_execution_exception)
+    {
+      if (error_handler.is_defined ())
+        error_state = 1;
+    }
 
   if (error_state)
     {
       if (error_handler.is_defined ())
         {
           octave_scalar_map msg;
           msg.assign ("identifier", last_error_id ());
           msg.assign ("message", last_error_message ());
-          msg.assign ("index", static_cast<double> (count + static_cast<octave_idx_type>(1)));
+          msg.assign ("index",
+                      static_cast<double> (count
+                                           + static_cast<octave_idx_type>(1)));
 
           octave_value_list errlist = inputlist;
           errlist.prepend (msg);
 
           buffer_error_messages--;
 
           error_state = 0;
 
@@ -259,17 +263,17 @@ get_mapper_fun_options (const octave_val
 
       nargin -= 2;
     }
 
   nargin -= 1;
 }
 
 DEFUN (cellfun, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} cellfun (@var{name}, @var{C})\n\
 @deftypefnx {Built-in Function} {} cellfun (\"size\", @var{C}, @var{k})\n\
 @deftypefnx {Built-in Function} {} cellfun (\"isclass\", @var{C}, @var{class})\n\
 @deftypefnx {Built-in Function} {} cellfun (@var{func}, @var{C})\n\
 @deftypefnx {Built-in Function} {} cellfun (@var{func}, @var{C}, @var{D})\n\
 @deftypefnx {Built-in Function} {[@var{a}, @dots{}] =} cellfun (@dots{})\n\
 @deftypefnx {Built-in Function} {} cellfun (@dots{}, \"ErrorHandler\", @var{errfunc})\n\
 @deftypefnx {Built-in Function} {} cellfun (@dots{}, \"UniformOutput\", @var{val})\n\
@@ -1033,17 +1037,17 @@ v = cellfun (@@det, a); # faster\n\
 %!error cellfun (@sin, {[]}, "ErrorHandler")
 */
 
 // Arrayfun was originally a .m file written by Bill Denney and Jaroslav
 // Hajek.  It was converted to C++ by jwe so that it could properly
 // handle the nargout = 0 case.
 
 DEFUN (arrayfun, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Function File} {} arrayfun (@var{func}, @var{A})\n\
 @deftypefnx {Function File} {@var{x} =} arrayfun (@var{func}, @var{A})\n\
 @deftypefnx {Function File} {@var{x} =} arrayfun (@var{func}, @var{A}, @var{b}, @dots{})\n\
 @deftypefnx {Function File} {[@var{x}, @var{y}, @dots{}] =} arrayfun (@var{func}, @var{A}, @dots{})\n\
 @deftypefnx {Function File} {} arrayfun (@dots{}, \"UniformOutput\", @var{val})\n\
 @deftypefnx {Function File} {} arrayfun (@dots{}, \"ErrorHandler\", @var{errfunc})\n\
 \n\
 Execute a function on each element of an array.  This is useful for\n\
@@ -1151,17 +1155,17 @@ arrayfun (@@str2num, [1234],\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
   int nargout1 = (nargout < 1 ? 1 : nargout);
 
   if (nargin < 2)
     {
-      error_with_id ("Octave:invalid-fun-call", 
+      error_with_id ("Octave:invalid-fun-call",
                      "arrayfun: function requires at least 2 arguments");
       print_usage ();
       return retval;
     }
 
   octave_value func = args(0);
   bool symbol_table_lookup = false;
 
@@ -1225,17 +1229,17 @@ arrayfun (@@str2num, [1234],\n\
           if (f.is_defined ())
             func = f;
         }
 
     nevermind:
 
       bool uniform_output = true;
       octave_value error_handler;
-      
+
       get_mapper_fun_options (args, nargin, uniform_output, error_handler);
 
       if (error_state)
         return octave_value_list ();
 
       octave_value_list inputlist (nargin, octave_value ());
 
       OCTAVE_LOCAL_BUFFER (octave_value, inputs, nargin);
@@ -1263,17 +1267,17 @@ arrayfun (@@str2num, [1234],\n\
             {
               fdims = inputs[j].dims ();
               k = inputs[j].numel ();
 
               for (int i = j+1; i < nargin; i++)
                 {
                   if (mask[i] && inputs[i].dims () != fdims)
                     {
-                      error_with_id ("Octave:invalid-input-arg", 
+                      error_with_id ("Octave:invalid-input-arg",
                                      "arrayfun: dimensions mismatch");
                       return retval;
                     }
                 }
               break;
             }
         }
 
@@ -1311,17 +1315,17 @@ arrayfun (@@str2num, [1234],\n\
                 = get_output_list (count, nargout, inputlist, func,
                                    error_handler);
 
               if (error_state)
                 return retval;
 
               if (nargout > 0 && tmp.length () < nargout)
                 {
-                  error_with_id ("Octave:invalid-fun-call", 
+                  error_with_id ("Octave:invalid-fun-call",
                                  "arrayfun: function returned fewer than nargout values");
                   return retval;
                 }
 
               if  (nargout > 0
                    || (nargout == 0
                        && tmp.length () > 0 && tmp(0).is_defined ()))
                 {
@@ -1424,17 +1428,17 @@ arrayfun (@@str2num, [1234],\n\
                 = get_output_list (count, nargout, inputlist, func,
                                    error_handler);
 
               if (error_state)
                 return retval;
 
               if (nargout > 0 && tmp.length () < nargout)
                 {
-                  error_with_id ("Octave:invalid-fun-call", 
+                  error_with_id ("Octave:invalid-fun-call",
                                  "arrayfun: function returned fewer than nargout values");
                   return retval;
                 }
 
               if  (nargout > 0
                    || (nargout == 0
                        && tmp.length () > 0 && tmp(0).is_defined ()))
                 {
@@ -1456,17 +1460,17 @@ arrayfun (@@str2num, [1234],\n\
               retval.resize (nargout1);
 
               for (int j = 0; j < nargout1; j++)
                 retval(j) = results[j];
             }
         }
     }
   else
-    error_with_id ("Octave:invalid-fun-call", 
+    error_with_id ("Octave:invalid-fun-call",
                    "arrayfun: argument NAME must be a string or function handle");
 
   return retval;
 }
 
 /*
 %!function r = __f11 (x)
 %!  global __arrayfun_test_num_outputs__;
@@ -1771,17 +1775,17 @@ do_num2cell (const NDA& array, const Arr
         {
           retval.xelem (i) = NDA (parray.column (i).reshape (arraydv));
         }
 
       return retval;
     }
 }
 
-// FIXME -- this is a mess, but if a size method for the object exists,
+// FIXME: this is a mess, but if a size method for the object exists,
 // we have to call it to get the size of the object instead of using the
 // internal dims method.
 
 static dim_vector
 get_object_dims (octave_value& obj)
 {
   dim_vector retval;
 
@@ -1797,17 +1801,17 @@ get_object_dims (octave_value& obj)
   return retval;
 }
 
 static Cell
 do_object2cell (const octave_value& obj, const Array<int>& dimv)
 {
   Cell retval;
 
-  // FIXME -- this copy is only needed because the octave_value::size
+  // FIXME: this copy is only needed because the octave_value::size
   // method is not const.
   octave_value array = obj;
 
   if (dimv.is_empty ())
     {
       dim_vector dv = get_object_dims (array);
 
       if (! error_state)
@@ -1833,17 +1837,17 @@ do_object2cell (const octave_value& obj,
     {
       error ("num2cell (A, dim) not implemented for class objects");
     }
 
   return retval;
 }
 
 DEFUN (num2cell, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{C} =} num2cell (@var{A})\n\
 @deftypefnx {Built-in Function} {@var{C} =} num2cell (@var{A}, @var{dim})\n\
 Convert the numeric matrix @var{A} to a cell array.  If @var{dim} is\n\
 defined, the value @var{C} is of dimension 1 in this dimension and the\n\
 elements of @var{A} are placed into @var{C} in slices.  For example:\n\
 \n\
 @example\n\
 @group\n\
@@ -2162,17 +2166,17 @@ do_mat2cell (octave_value& a, const Arra
 
       rdv.increment_index (ridx);
     }
 
   return retval;
 }
 
 DEFUN (mat2cell, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{C} =} mat2cell (@var{A}, @var{m}, @var{n})\n\
 @deftypefnx {Built-in Function} {@var{C} =} mat2cell (@var{A}, @var{d1}, @var{d2}, @dots{})\n\
 @deftypefnx {Built-in Function} {@var{C} =} mat2cell (@var{A}, @var{r})\n\
 Convert the matrix @var{A} to a cell array.  If @var{A} is 2-D, then\n\
 it is required that @code{sum (@var{m}) == size (@var{A}, 1)} and\n\
 @code{sum (@var{n}) == size (@var{A}, 2)}.  Similarly, if @var{A} is\n\
 multi-dimensional and the number of dimensional arguments is equal\n\
 to the dimensions of @var{A}, then it is required that @code{sum (@var{di})\n\
@@ -2242,17 +2246,18 @@ mat2cell (reshape (1:16,4,4), [3,1], [3,
               retval = do_mat2cell_2d (a.sparse_matrix_value (), d, nargin-1);
             else
               retval = do_mat2cell (a.array_value (), d, nargin - 1);
             break;
           }
         case btyp_complex:
           {
             if (sparse)
-              retval = do_mat2cell_2d (a.sparse_complex_matrix_value (), d, nargin-1);
+              retval = do_mat2cell_2d (a.sparse_complex_matrix_value (), d,
+                                       nargin-1);
             else
               retval = do_mat2cell (a.complex_array_value (), d, nargin - 1);
             break;
           }
 #define BTYP_BRANCH(X,Y) \
         case btyp_ ## X: \
             retval = do_mat2cell (a.Y ## _value (), d, nargin - 1); \
           break
@@ -2332,17 +2337,17 @@ do_cellslices_nda (const NDA& array,
           retval(i) = array.index (idx);
         }
     }
 
   return retval;
 }
 
 DEFUN (cellslices, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{sl} =} cellslices (@var{x}, @var{lb}, @var{ub}, @var{dim})\n\
 Given an array @var{x}, this function produces a cell array of slices from\n\
 the array determined by the index vectors @var{lb}, @var{ub}, for lower and\n\
 upper bounds, respectively.  In other words, it is equivalent to the\n\
 following code:\n\
 \n\
 @example\n\
 @group\n\
@@ -2380,51 +2385,65 @@ slicing is done along the first non-sing
             error ("cellslices: the lengths of LB and UB must match");
           else
             {
               Cell retcell;
               if (! x.is_sparse_type () && x.is_matrix_type ())
                 {
                   // specialize for some dense arrays.
                   if (x.is_bool_type ())
-                    retcell = do_cellslices_nda (x.bool_array_value (), lb, ub, dim);
+                    retcell = do_cellslices_nda (x.bool_array_value (),
+                                                 lb, ub, dim);
                   else if (x.is_char_matrix ())
-                    retcell = do_cellslices_nda (x.char_array_value (), lb, ub, dim);
+                    retcell = do_cellslices_nda (x.char_array_value (),
+                                                 lb, ub, dim);
                   else if (x.is_integer_type ())
                     {
                       if (x.is_int8_type ())
-                        retcell = do_cellslices_nda (x.int8_array_value (), lb, ub, dim);
+                        retcell = do_cellslices_nda (x.int8_array_value (),
+                                                     lb, ub, dim);
                       else if (x.is_int16_type ())
-                        retcell = do_cellslices_nda (x.int16_array_value (), lb, ub, dim);
+                        retcell = do_cellslices_nda (x.int16_array_value (),
+                                                     lb, ub, dim);
                       else if (x.is_int32_type ())
-                        retcell = do_cellslices_nda (x.int32_array_value (), lb, ub, dim);
+                        retcell = do_cellslices_nda (x.int32_array_value (),
+                                                     lb, ub, dim);
                       else if (x.is_int64_type ())
-                        retcell = do_cellslices_nda (x.int64_array_value (), lb, ub, dim);
+                        retcell = do_cellslices_nda (x.int64_array_value (),
+                                                     lb, ub, dim);
                       else if (x.is_uint8_type ())
-                        retcell = do_cellslices_nda (x.uint8_array_value (), lb, ub, dim);
+                        retcell = do_cellslices_nda (x.uint8_array_value (),
+                                                     lb, ub, dim);
                       else if (x.is_uint16_type ())
-                        retcell = do_cellslices_nda (x.uint16_array_value (), lb, ub, dim);
+                        retcell = do_cellslices_nda (x.uint16_array_value (),
+                                                     lb, ub, dim);
                       else if (x.is_uint32_type ())
-                        retcell = do_cellslices_nda (x.uint32_array_value (), lb, ub, dim);
+                        retcell = do_cellslices_nda (x.uint32_array_value (),
+                                                     lb, ub, dim);
                       else if (x.is_uint64_type ())
-                        retcell = do_cellslices_nda (x.uint64_array_value (), lb, ub, dim);
+                        retcell = do_cellslices_nda (x.uint64_array_value (),
+                                                     lb, ub, dim);
                     }
                   else if (x.is_complex_type ())
                     {
                       if (x.is_single_type ())
-                        retcell = do_cellslices_nda (x.float_complex_array_value (), lb, ub, dim);
+                        retcell = do_cellslices_nda (x.float_complex_array_value (),
+                                                     lb, ub, dim);
                       else
-                        retcell = do_cellslices_nda (x.complex_array_value (), lb, ub, dim);
+                        retcell = do_cellslices_nda (x.complex_array_value (),
+                                                     lb, ub, dim);
                     }
                   else
                     {
                       if (x.is_single_type ())
-                        retcell = do_cellslices_nda (x.float_array_value (), lb, ub, dim);
+                        retcell = do_cellslices_nda (x.float_array_value (),
+                                                     lb, ub, dim);
                       else
-                        retcell = do_cellslices_nda (x.array_value (), lb, ub, dim);
+                        retcell = do_cellslices_nda (x.array_value (),
+                                                     lb, ub, dim);
                     }
                 }
               else
                 {
                   // generic code.
                   octave_idx_type n = lb.length ();
                   retcell = Cell (1, n);
                   const dim_vector dv = x.dims ();
@@ -2453,17 +2472,17 @@ slicing is done along the first non-sing
 /*
 %!test
 %! m = [1, 2, 3, 4; 5, 6, 7, 8; 9, 10, 11, 12];
 %! c = cellslices (m, [1, 2], [2, 3], 2);
 %! assert (c, {[1, 2; 5, 6; 9, 10], [2, 3; 6, 7; 10, 11]});
 */
 
 DEFUN (cellindexmat, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{y} =} cellindexmat (@var{x}, @var{varargin})\n\
 Given a cell array of matrices @var{x}, this function computes\n\
 \n\
 @example\n\
 @group\n\
 Y = cell (size (X));\n\
 for i = 1:numel (X)\n\
   Y@{i@} = X@{i@}(varargin@{:@});\n\
diff --git a/libinterp/corefcn/colloc.cc b/libinterp/corefcn/colloc.cc
--- a/libinterp/corefcn/colloc.cc
+++ b/libinterp/corefcn/colloc.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 #include "lo-mappers.h"
 
 #include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN (colloc, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{r}, @var{amat}, @var{bmat}, @var{q}] =} colloc (@var{n}, \"left\", \"right\")\n\
 Compute derivative and integral weight matrices for orthogonal\n\
 collocation using the subroutines given in J. Villadsen and\n\
 M. L. Michelsen, @cite{Solution of Differential Equation Models by\n\
 Polynomial Approximation}.\n\
 @end deftypefn")
 {
   octave_value_list retval;
diff --git a/libinterp/corefcn/comment-list.h b/libinterp/corefcn/comment-list.h
--- a/libinterp/corefcn/comment-list.h
+++ b/libinterp/corefcn/comment-list.h
@@ -51,25 +51,25 @@ public:
   octave_comment_elt (const std::string& s = std::string (),
                       comment_type t = unknown)
     : txt (s), typ (t) { }
 
   octave_comment_elt (const octave_comment_elt& oc)
     : txt (oc.txt), typ (oc.typ) { }
 
   octave_comment_elt& operator = (const octave_comment_elt& oc)
-    {
-      if (this != &oc)
-        {
-          txt = oc.txt;
-          typ = oc.typ;
-        }
+  {
+    if (this != &oc)
+      {
+        txt = oc.txt;
+        typ = oc.typ;
+      }
 
-      return *this;
-    }
+    return *this;
+  }
 
   std::string text (void) const { return txt; }
 
   comment_type type (void) const { return typ; }
 
   ~octave_comment_elt (void) { }
 
 private:
@@ -84,18 +84,18 @@ private:
 class
 octave_comment_list : public octave_base_list<octave_comment_elt>
 {
 public:
 
   octave_comment_list (void) { }
 
   void append (const octave_comment_elt& elt)
-    { octave_base_list<octave_comment_elt>::append (elt); }
+  { octave_base_list<octave_comment_elt>::append (elt); }
 
   void append (const std::string& s,
                octave_comment_elt::comment_type t = octave_comment_elt::unknown)
-    { append (octave_comment_elt (s, t)); }
+  { append (octave_comment_elt (s, t)); }
 
   octave_comment_list *dup (void) const;
 };
 
 #endif
diff --git a/libinterp/corefcn/conv2.cc b/libinterp/corefcn/conv2.cc
--- a/libinterp/corefcn/conv2.cc
+++ b/libinterp/corefcn/conv2.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 #include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 enum Shape { SHAPE_FULL, SHAPE_SAME, SHAPE_VALID };
 
 DEFUN (conv2, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} conv2 (@var{A}, @var{B})\n\
 @deftypefnx {Built-in Function} {} conv2 (@var{v1}, @var{v2}, @var{m})\n\
 @deftypefnx {Built-in Function} {} conv2 (@dots{}, @var{shape})\n\
 Return the 2-D convolution of @var{A} and @var{B}.  The size of the result\n\
 is determined by the optional @var{shape} argument which takes the following\n\
 values\n\
 \n\
 @table @asis\n\
@@ -67,18 +67,18 @@ When the third argument is a matrix, ret
   octave_value tmp;
   int nargin = args.length ();
   std::string shape = "full";   // default
   bool separable = false;
   convn_type ct;
 
   if (nargin < 2)
     {
-     print_usage ();
-     return retval;
+      print_usage ();
+      return retval;
     }
   else if (nargin == 3)
     {
       if (args(2).is_string ())
         shape = args(2).string_value ();
       else
         separable = true;
     }
@@ -104,17 +104,17 @@ When the third argument is a matrix, ret
     {
       error ("conv2: SHAPE type not valid");
       print_usage ();
       return retval;
     }
 
   if (separable)
     {
-     // If user requests separable, check first two params are vectors
+      // If user requests separable, check first two params are vectors
 
       if (! (1 == args(0).rows () || 1 == args(0).columns ())
           || ! (1 == args(1).rows () || 1 == args(1).columns ()))
         {
           print_usage ();
           return retval;
         }
 
@@ -286,17 +286,17 @@ When the third argument is a matrix, ret
 %!error <must be 1-D vectors or 2-D matrices> conv2 (ones (2), ones (2,2,2))
 %!error <SHAPE type not valid> conv2 (1,2, "NOT_A_SHAPE")
 %% Test alternate calling form which should be 2 vectors and a matrix
 %!error conv2 (ones (2), 1, 1)
 %!error conv2 (1, ones (2), 1)
 */
 
 DEFUN (convn, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{C} =} convn (@var{A}, @var{B})\n\
 @deftypefnx {Built-in Function} {@var{C} =} convn (@var{A}, @var{B}, @var{shape})\n\
 Return the n-D convolution of @var{A} and @var{B}.  The size of the result\n\
 is determined by the optional @var{shape} argument which takes the following\n\
 values\n\
 \n\
 @table @asis\n\
 @item @var{shape} = @qcode{\"full\"}\n\
@@ -318,18 +318,18 @@ The size of the result is @code{max (siz
   octave_value retval;
   octave_value tmp;
   int nargin = args.length ();
   std::string shape = "full";   // default
   convn_type ct;
 
   if (nargin < 2 || nargin > 3)
     {
-     print_usage ();
-     return retval;
+      print_usage ();
+      return retval;
     }
   else if (nargin == 3)
     {
       if (args(2).is_string ())
         shape = args(2).string_value ();
       else
         {
           error ("convn: SHAPE must be a string");
diff --git a/libinterp/corefcn/daspk.cc b/libinterp/corefcn/daspk.cc
--- a/libinterp/corefcn/daspk.cc
+++ b/libinterp/corefcn/daspk.cc
@@ -166,17 +166,17 @@ daspk_user_jacobian (const ColumnVector&
   do \
     { \
       ::error ("daspk: " fmt, arg); \
       DASPK_ABORT (); \
     } \
   while (0)
 
 DEFUN (daspk, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{x}, @var{xdot}, @var{istate}, @var{msg}] =} daspk (@var{fcn}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
 Solve the set of differential-algebraic equations\n\
 @tex\n\
 $$ 0 = f (x, \\dot{x}, t) $$\n\
 with\n\
 $$ x(t_0) = x_0, \\dot{x}(t_0) = \\dot{x}_0 $$\n\
 @end tex\n\
 @ifnottex\n\
@@ -305,31 +305,31 @@ parameters for @code{daspk}.\n\
                 daspk_fcn = c(0).function_value ();
               else
                 {
                   fcn_name = unique_symbol_name ("__daspk_fcn__");
                   fname = "function y = ";
                   fname.append (fcn_name);
                   fname.append (" (x, xdot, t) y = ");
                   daspk_fcn = extract_function
-                    (c(0), "daspk", fcn_name, fname, "; endfunction");
+                              (c(0), "daspk", fcn_name, fname, "; endfunction");
                 }
 
               if (daspk_fcn)
                 {
                   if (c(1).is_function_handle () || c(1).is_inline_function ())
                     daspk_jac = c(1).function_value ();
                   else
                     {
                       jac_name = unique_symbol_name ("__daspk_jac__");
                       jname = "function jac = ";
                       jname.append (jac_name);
                       jname.append (" (x, xdot, t, cj) jac = ");
-                      daspk_jac = extract_function
-                        (c(1), "daspk", jac_name, jname, "; endfunction");
+                      daspk_jac = extract_function (c(1), "daspk", jac_name,
+                                                    jname, "; endfunction");
 
                       if (!daspk_jac)
                         {
                           if (fcn_name.length ())
                             clear_function (fcn_name);
                           daspk_fcn = 0;
                         }
                     }
@@ -349,44 +349,44 @@ parameters for @code{daspk}.\n\
                 {
                 case 1:
                   do
                     {
                       fcn_name = unique_symbol_name ("__daspk_fcn__");
                       fname = "function y = ";
                       fname.append (fcn_name);
                       fname.append (" (x, xdot, t) y = ");
-                      daspk_fcn = extract_function
-                        (f_arg, "daspk", fcn_name, fname, "; endfunction");
+                      daspk_fcn = extract_function (f_arg, "daspk", fcn_name,
+                                                    fname, "; endfunction");
                     }
                   while (0);
                   break;
 
                 case 2:
                   {
                     string_vector tmp = f_arg.all_strings ();
 
                     if (! error_state)
                       {
                         fcn_name = unique_symbol_name ("__daspk_fcn__");
                         fname = "function y = ";
                         fname.append (fcn_name);
                         fname.append (" (x, xdot, t) y = ");
-                        daspk_fcn = extract_function
-                          (tmp(0), "daspk", fcn_name, fname, "; endfunction");
+                        daspk_fcn = extract_function (tmp(0), "daspk", fcn_name,
+                                                      fname, "; endfunction");
 
                         if (daspk_fcn)
                           {
                             jac_name = unique_symbol_name ("__daspk_jac__");
                             jname = "function jac = ";
                             jname.append (jac_name);
                             jname.append (" (x, xdot, t, cj) jac = ");
-                            daspk_jac = extract_function
-                              (tmp(1), "daspk", jac_name, jname,
-                               "; endfunction");
+                            daspk_jac = extract_function (tmp(1), "daspk",
+                                                          jac_name, jname,
+                                                          "; endfunction");
 
                             if (!daspk_jac)
                               {
                                 if (fcn_name.length ())
                                   clear_function (fcn_name);
                                 daspk_fcn = 0;
                               }
                           }
diff --git a/libinterp/corefcn/dasrt.cc b/libinterp/corefcn/dasrt.cc
--- a/libinterp/corefcn/dasrt.cc
+++ b/libinterp/corefcn/dasrt.cc
@@ -202,17 +202,17 @@ dasrt_user_j (const ColumnVector& x, con
   do \
     { \
       ::error ("dasrt: " fmt, arg); \
       DASRT_ABORT; \
     } \
   while (0)
 
 DEFUN (dasrt, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{x}, @var{xdot}, @var{t_out}, @var{istat}, @var{msg}] =} dasrt (@var{fcn}, [], @var{x_0}, @var{xdot_0}, @var{t})\n\
 @deftypefnx {Built-in Function} {@dots{} =} dasrt (@var{fcn}, @var{g}, @var{x_0}, @var{xdot_0}, @var{t})\n\
 @deftypefnx {Built-in Function} {@dots{} =} dasrt (@var{fcn}, [], @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
 @deftypefnx {Built-in Function} {@dots{} =} dasrt (@var{fcn}, @var{g}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
 Solve the set of differential-algebraic equations\n\
 @tex\n\
 $$ 0 = f (x, \\dot{x}, t) $$\n\
 with\n\
@@ -392,32 +392,32 @@ parameters for @code{dasrt}.\n\
           if (c(0).is_function_handle () || c(0).is_inline_function ())
             dasrt_f = c(0).function_value ();
           else
             {
               fcn_name = unique_symbol_name ("__dasrt_fcn__");
               fname = "function y = ";
               fname.append (fcn_name);
               fname.append (" (x, xdot, t) y = ");
-              dasrt_f = extract_function
-                (c(0), "dasrt", fcn_name, fname, "; endfunction");
+              dasrt_f = extract_function (c(0), "dasrt", fcn_name, fname,
+                                          "; endfunction");
             }
 
           if (dasrt_f)
             {
               if (c(1).is_function_handle () || c(1).is_inline_function ())
                 dasrt_j = c(1).function_value ();
               else
                 {
                   jac_name = unique_symbol_name ("__dasrt_jac__");
                   jname = "function jac = ";
                   jname.append (jac_name);
                   jname.append (" (x, xdot, t, cj) jac = ");
-                  dasrt_j = extract_function
-                    (c(1), "dasrt", jac_name, jname, "; endfunction");
+                  dasrt_j = extract_function (c(1), "dasrt", jac_name, jname,
+                                              "; endfunction");
 
                   if (!dasrt_j)
                     {
                       if (fcn_name.length ())
                         clear_function (fcn_name);
                       dasrt_f = 0;
                     }
                 }
@@ -435,41 +435,41 @@ parameters for @code{dasrt}.\n\
         {
           switch (f_arg.rows ())
             {
             case 1:
               fcn_name = unique_symbol_name ("__dasrt_fcn__");
               fname = "function y = ";
               fname.append (fcn_name);
               fname.append (" (x, xdot, t) y = ");
-              dasrt_f = extract_function
-                (f_arg, "dasrt", fcn_name, fname, "; endfunction");
+              dasrt_f = extract_function (f_arg, "dasrt", fcn_name, fname,
+                                          "; endfunction");
               break;
 
             case 2:
               {
                 string_vector tmp = args(0).all_strings ();
 
                 if (! error_state)
                   {
                     fcn_name = unique_symbol_name ("__dasrt_fcn__");
                     fname = "function y = ";
                     fname.append (fcn_name);
                     fname.append (" (x, xdot, t) y = ");
-                    dasrt_f = extract_function
-                      (tmp(0), "dasrt", fcn_name, fname, "; endfunction");
+                    dasrt_f = extract_function (tmp(0), "dasrt", fcn_name,
+                                                fname, "; endfunction");
 
                     if (dasrt_f)
                       {
                         jac_name = unique_symbol_name ("__dasrt_jac__");
                         jname = "function jac = ";
                         jname.append (jac_name);
                         jname.append (" (x, xdot, t, cj) jac = ");
-                        dasrt_j = extract_function
-                          (tmp(1), "dasrt", jac_name, jname, "; endfunction");
+                        dasrt_j = extract_function (tmp(1), "dasrt", jac_name,
+                                                    jname, "; endfunction");
 
                         if (! dasrt_j)
                           dasrt_f = 0;
                       }
                   }
               }
               break;
 
@@ -512,38 +512,36 @@ parameters for @code{dasrt}.\n\
   ColumnVector state (args(argp++).vector_value ());
 
   if (error_state)
     DASRT_ABORT2 ("expecting state vector as argument %d", argp);
 
   ColumnVector stateprime (args(argp++).vector_value ());
 
   if (error_state)
-    DASRT_ABORT2
-       ("expecting time derivative of state vector as argument %d", argp);
+    DASRT_ABORT2 ("expecting time derivative of state vector as argument %d",
+                  argp);
 
   ColumnVector out_times (args(argp++).vector_value ());
 
   if (error_state)
-    DASRT_ABORT2
-        ("expecting output time vector as %s argument %d", argp);
+    DASRT_ABORT2 ("expecting output time vector as %s argument %d", argp);
 
   double tzero = out_times (0);
 
   ColumnVector crit_times;
 
   bool crit_times_set = false;
 
   if (argp < nargin)
     {
       crit_times = ColumnVector (args(argp++).vector_value ());
 
       if (error_state)
-        DASRT_ABORT2
-          ("expecting critical time vector as argument %d", argp);
+        DASRT_ABORT2 ("expecting critical time vector as argument %d", argp);
 
       crit_times_set = true;
     }
 
   if (dasrt_j)
     func.set_jacobian_function (dasrt_user_j);
 
   DASRT_result output;
diff --git a/libinterp/corefcn/dassl.cc b/libinterp/corefcn/dassl.cc
--- a/libinterp/corefcn/dassl.cc
+++ b/libinterp/corefcn/dassl.cc
@@ -166,17 +166,17 @@ dassl_user_jacobian (const ColumnVector&
   do \
     { \
       ::error ("dassl: " fmt, arg); \
       DASSL_ABORT (); \
     } \
   while (0)
 
 DEFUN (dassl, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{x}, @var{xdot}, @var{istate}, @var{msg}] =} dassl (@var{fcn}, @var{x_0}, @var{xdot_0}, @var{t}, @var{t_crit})\n\
 Solve the set of differential-algebraic equations\n\
 @tex\n\
 $$ 0 = f (x, \\dot{x}, t) $$\n\
 with\n\
 $$ x(t_0) = x_0, \\dot{x}(t_0) = \\dot{x}_0 $$\n\
 @end tex\n\
 @ifnottex\n\
@@ -305,39 +305,39 @@ parameters for @code{dassl}.\n\
               if (c(0).is_function_handle () || c(0).is_inline_function ())
                 dassl_fcn = c(0).function_value ();
               else
                 {
                   fcn_name = unique_symbol_name ("__dassl_fcn__");
                   fname = "function y = ";
                   fname.append (fcn_name);
                   fname.append (" (x, xdot, t) y = ");
-                  dassl_fcn = extract_function
-                    (c(0), "dassl", fcn_name, fname, "; endfunction");
+                  dassl_fcn = extract_function (c(0), "dassl", fcn_name, fname,
+                                                "; endfunction");
                 }
 
               if (dassl_fcn)
                 {
                   if (c(1).is_function_handle () || c(1).is_inline_function ())
                     dassl_jac = c(1).function_value ();
                   else
                     {
-                        jac_name = unique_symbol_name ("__dassl_jac__");
-                        jname = "function jac = ";
-                        jname.append (jac_name);
-                        jname.append (" (x, xdot, t, cj) jac = ");
-                        dassl_jac = extract_function
-                          (c(1), "dassl", jac_name, jname, "; endfunction");
+                      jac_name = unique_symbol_name ("__dassl_jac__");
+                      jname = "function jac = ";
+                      jname.append (jac_name);
+                      jname.append (" (x, xdot, t, cj) jac = ");
+                      dassl_jac = extract_function (c(1), "dassl", jac_name,
+                                                    jname, "; endfunction");
 
-                        if (!dassl_jac)
-                          {
-                            if (fcn_name.length ())
-                              clear_function (fcn_name);
-                            dassl_fcn = 0;
-                          }
+                      if (!dassl_jac)
+                        {
+                          if (fcn_name.length ())
+                            clear_function (fcn_name);
+                          dassl_fcn = 0;
+                        }
                     }
                 }
             }
           else
             DASSL_ABORT1 ("incorrect number of elements in cell array");
         }
 
       if (!dassl_fcn && ! f_arg.is_cell ())
@@ -350,44 +350,44 @@ parameters for @code{dassl}.\n\
                 {
                 case 1:
                   do
                     {
                       fcn_name = unique_symbol_name ("__dassl_fcn__");
                       fname = "function y = ";
                       fname.append (fcn_name);
                       fname.append (" (x, xdot, t) y = ");
-                      dassl_fcn = extract_function
-                        (f_arg, "dassl", fcn_name, fname, "; endfunction");
+                      dassl_fcn = extract_function (f_arg, "dassl", fcn_name,
+                                                    fname, "; endfunction");
                     }
                   while (0);
                   break;
 
                 case 2:
                   {
                     string_vector tmp = f_arg.all_strings ();
 
                     if (! error_state)
                       {
                         fcn_name = unique_symbol_name ("__dassl_fcn__");
                         fname = "function y = ";
                         fname.append (fcn_name);
                         fname.append (" (x, xdot, t) y = ");
-                        dassl_fcn = extract_function
-                          (tmp(0), "dassl", fcn_name, fname, "; endfunction");
+                        dassl_fcn = extract_function (tmp(0), "dassl", fcn_name,
+                                                      fname, "; endfunction");
 
                         if (dassl_fcn)
                           {
                             jac_name = unique_symbol_name ("__dassl_jac__");
                             jname = "function jac = ";
                             jname.append (jac_name);
                             jname.append (" (x, xdot, t, cj) jac = ");
-                            dassl_jac = extract_function
-                              (tmp(1), "dassl", jac_name, jname,
-                               "; endfunction");
+                            dassl_jac = extract_function (tmp(1), "dassl",
+                                                          jac_name, jname,
+                                                          "; endfunction");
 
                             if (!dassl_jac)
                               {
                                 if (fcn_name.length ())
                                   clear_function (fcn_name);
                                 dassl_fcn = 0;
                               }
                           }
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -103,17 +103,17 @@ along with Octave; see the file COPYING.
         error (#FCN ": expecting dimension argument to be an integer"); \
     } \
   else \
     print_usage (); \
  \
   return retval
 
 DEFUN (all, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} all (@var{x})\n\
 @deftypefnx {Built-in Function} {} all (@var{x}, @var{dim})\n\
 For a vector argument, return true (logical 1) if all elements of the vector\n\
 are nonzero.\n\
 \n\
 For a matrix argument, return a row vector of logical ones and\n\
 zeros with each element indicating whether all of the elements of the\n\
 corresponding column of the matrix are nonzero.  For example:\n\
@@ -150,17 +150,17 @@ If the optional argument @var{dim} is su
 %! assert (all (x, 1) == [0, 1, 1]);
 %! assert (all (x, 2) == [0; 1; 1]);
 
 %!error all ()
 %!error all (1, 2, 3)
 */
 
 DEFUN (any, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} any (@var{x})\n\
 @deftypefnx {Built-in Function} {} any (@var{x}, @var{dim})\n\
 For a vector argument, return true (logical 1) if any element of the vector\n\
 is nonzero.\n\
 \n\
 For a matrix argument, return a row vector of logical ones and\n\
 zeros with each element indicating whether any of the elements of the\n\
 corresponding column of the matrix are nonzero.  For example:\n\
@@ -206,17 +206,17 @@ any (eye (2, 4), 2)\n\
 
 %!error any ()
 %!error any (1, 2, 3)
 */
 
 // These mapping functions may also be useful in other places, eh?
 
 DEFUN (atan2, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atan2 (@var{y}, @var{x})\n\
 Compute atan (@var{y} / @var{x}) for corresponding elements of @var{y}\n\
 and @var{x}.  Signal an error if @var{y} and @var{x} do not match in size\n\
 and orientation.\n\
 @seealso{tan, tand, tanh, atanh}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -346,17 +346,17 @@ do_hypot (const octave_value& x, const o
             }
         }
     }
 
   return retval;
 }
 
 DEFUN (hypot, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} hypot (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} hypot (@var{x}, @var{y}, @var{z}, @dots{})\n\
 Compute the element-by-element square root of the sum of the squares of\n\
 @var{x} and @var{y}.  This is equivalent to\n\
 @code{sqrt (@var{x}.^2 + @var{y}.^2)}, but calculated in a manner that\n\
 avoids overflows for large values of @var{x} or @var{y}.\n\
 @code{hypot} can also be called with more than 2 arguments; in this case,\n\
 the arguments are accumulated from left to right:\n\
@@ -409,17 +409,17 @@ map_2_xlog2 (const Array<T>& x, Array<T>
     {
       int exp;
       f.xelem (i) = xlog2 (x(i), exp);
       e.xelem (i) = exp;
     }
 }
 
 DEFUN (log2, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Mapping Function} {} log2 (@var{x})\n\
 @deftypefnx {Mapping Function} {[@var{f}, @var{e}] =} log2 (@var{x})\n\
 Compute the base-2 logarithm of each element of @var{x}.\n\
 \n\
 If called with two output arguments, split @var{x} into\n\
 binary mantissa and exponent so that\n\
 @tex\n\
 ${1 \\over 2} \\le \\left| f \\right| < 1$\n\
@@ -444,48 +444,48 @@ and @var{e} is an integer.  If\n\
       if (nargout < 2)
         retval(0) = args(0).log2 ();
       else if (args(0).is_single_type ())
         {
           if (args(0).is_real_type ())
             {
               FloatNDArray f;
               FloatNDArray x = args(0).float_array_value ();
-              // FIXME -- should E be an int value?
+              // FIXME: should E be an int value?
               FloatMatrix e;
               map_2_xlog2 (x, f, e);
               retval(1) = e;
               retval(0) = f;
             }
           else if (args(0).is_complex_type ())
             {
               FloatComplexNDArray f;
               FloatComplexNDArray x = args(0).float_complex_array_value ();
-              // FIXME -- should E be an int value?
+              // FIXME: should E be an int value?
               FloatNDArray e;
               map_2_xlog2 (x, f, e);
               retval(1) = e;
               retval(0) = f;
             }
         }
       else if (args(0).is_real_type ())
         {
           NDArray f;
           NDArray x = args(0).array_value ();
-          // FIXME -- should E be an int value?
+          // FIXME: should E be an int value?
           Matrix e;
           map_2_xlog2 (x, f, e);
           retval(1) = e;
           retval(0) = f;
         }
       else if (args(0).is_complex_type ())
         {
           ComplexNDArray f;
           ComplexNDArray x = args(0).complex_array_value ();
-          // FIXME -- should E be an int value?
+          // FIXME: should E be an int value?
           NDArray e;
           map_2_xlog2 (x, f, e);
           retval(1) = e;
           retval(0) = f;
         }
       else
         gripe_wrong_type_arg ("log2", args(0));
     }
@@ -509,17 +509,17 @@ and @var{e} is an integer.  If\n\
 
 %!test
 %! [f, e] = log2 (complex (zeros (3, 2), [0,-1; 2,-4; Inf,-Inf]));
 %! assert (f, complex (zeros (3, 2), [0,-0.5; 0.5,-0.5; Inf,-Inf]));
 %! assert (e(1:2,:), [0,1; 2,3]);
 */
 
 DEFUN (rem, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Mapping Function} {} rem (@var{x}, @var{y})\n\
 @deftypefnx {Mapping Function} {} fmod (@var{x}, @var{y})\n\
 Return the remainder of the division @code{@var{x} / @var{y}}, computed\n\
 using the expression\n\
 \n\
 @example\n\
 x - y .* fix (x ./ y)\n\
 @end example\n\
@@ -572,17 +572,18 @@ agree, or if either of the arguments is 
                 MAKE_INT_BRANCH (uint64);
 #undef MAKE_INT_BRANCH
                 default:
                   panic_impossible ();
                 }
             }
           else
             error ("rem: cannot combine %s and %d",
-                   args(0).class_name ().c_str (), args(1).class_name ().c_str ());
+                   args(0).class_name ().c_str (),
+                   args(1).class_name ().c_str ());
         }
       else if (args(0).is_single_type () || args(1).is_single_type ())
         {
           if (args(0).is_scalar_type () && args(1).is_scalar_type ())
             retval = xrem (args(0).float_value (), args(1).float_value ());
           else
             {
               FloatNDArray a0 = args(0).float_array_value ();
@@ -638,17 +639,17 @@ agree, or if either of the arguments is 
 %!assert (size (fmod (rand (2, 3, 4), 1)), [2, 3, 4])
 %!assert (size (fmod (1, rand (2, 3, 4))), [2, 3, 4])
 %!assert (size (fmod (1, 2)), [1, 1])
 */
 
 DEFALIAS (fmod, rem)
 
 DEFUN (mod, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} mod (@var{x}, @var{y})\n\
 Compute the modulo of @var{x} and @var{y}.  Conceptually this is given by\n\
 \n\
 @example\n\
 x - y .* floor (x ./ y)\n\
 @end example\n\
 \n\
 @noindent\n\
@@ -705,17 +706,18 @@ either of the arguments is complex.\n\
                 MAKE_INT_BRANCH (uint64);
 #undef MAKE_INT_BRANCH
                 default:
                   panic_impossible ();
                 }
             }
           else
             error ("mod: cannot combine %s and %d",
-                   args(0).class_name ().c_str (), args(1).class_name ().c_str ());
+                   args(0).class_name ().c_str (),
+                   args(1).class_name ().c_str ());
         }
       else if (args(0).is_single_type () || args(1).is_single_type ())
         {
           if (args(0).is_scalar_type () && args(1).is_scalar_type ())
             retval = xmod (args(0).float_value (), args(1).float_value ());
           else
             {
               FloatNDArray a0 = args(0).float_array_value ();
@@ -788,17 +790,17 @@ either of the arguments is complex.\n\
 %!assert (mod (5, uint8 (4)), uint8 (1))
 %!assert (mod (uint8 ([1:5]), 4), uint8 ([1,2,3,0,1]))
 
 ## non-integer real numbers
 %!assert (mod (2.1, 0.1), 0)
 %!assert (mod (2.1, 0.2), 0.1, eps)
 */
 
-// FIXME: Need to convert the reduction functions of this file for single precision
+// FIXME: Need to convert reduction functions of this file for single precision
 
 #define NATIVE_REDUCTION_1(FCN, TYPE, DIM) \
   (arg.is_ ## TYPE ## _type ()) \
     { \
       TYPE ## NDArray tmp = arg. TYPE ##_array_value (); \
       \
       if (! error_state) \
         { \
@@ -847,17 +849,18 @@ either of the arguments is complex.\n\
                     { \
                       SparseMatrix tmp = arg.sparse_matrix_value (); \
                       \
                       if (! error_state) \
                         retval = tmp.FCN (dim); \
                     } \
                   else \
                     { \
-                      SparseComplexMatrix tmp = arg.sparse_complex_matrix_value (); \
+                      SparseComplexMatrix tmp \
+                        = arg.sparse_complex_matrix_value (); \
                       \
                       if (! error_state) \
                         retval = tmp.FCN (dim); \
                     } \
                 } \
               else \
                 { \
                   if (isnative) \
@@ -1019,17 +1022,18 @@ either of the arguments is complex.\n\
                     { \
                       SparseComplexMatrix tmp = arg.sparse_complex_matrix_value (); \
  \
                       if (! error_state) \
                         retval = tmp.FCN (dim); \
                     } \
                   else if (arg.is_single_type ()) \
                     { \
-                      FloatComplexNDArray tmp = arg.float_complex_array_value (); \
+                      FloatComplexNDArray tmp \
+                        = arg.float_complex_array_value (); \
  \
                       if (! error_state) \
                         retval = tmp.FCN (dim); \
                     } \
                   else \
                     { \
                       ComplexNDArray tmp = arg.complex_array_value (); \
  \
@@ -1048,17 +1052,17 @@ either of the arguments is complex.\n\
         } \
     } \
   else \
     print_usage (); \
  \
   return retval
 
 DEFUN (cumprod, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} cumprod (@var{x})\n\
 @deftypefnx {Built-in Function} {} cumprod (@var{x}, @var{dim})\n\
 Cumulative product of elements along dimension @var{dim}.  If\n\
 @var{dim} is omitted, it defaults to the first non-singleton dimension.\n\
 \n\
 @seealso{prod, cumsum}\n\
 @end deftypefn")
 {
@@ -1081,17 +1085,17 @@ Cumulative product of elements along dim
 
 %!assert (cumprod (single ([2, 3; 4, 5]), 1), single ([2, 3; 8, 15]))
 %!assert (cumprod (single ([2, 3; 4, 5]), 2), single ([2, 6; 4, 20]))
 
 %!error cumprod ()
 */
 
 DEFUN (cumsum, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} cumsum (@var{x})\n\
 @deftypefnx {Built-in Function} {} cumsum (@var{x}, @var{dim})\n\
 @deftypefnx {Built-in Function} {} cumsum (@dots{}, \"native\")\n\
 @deftypefnx {Built-in Function} {} cumsum (@dots{}, \"double\")\n\
 @deftypefnx {Built-in Function} {} cumsum (@dots{}, \"extra\")\n\
 Cumulative sum of elements along dimension @var{dim}.  If @var{dim}\n\
 is omitted, it defaults to the first non-singleton dimension.\n\
 \n\
@@ -1230,17 +1234,17 @@ See @code{sum} for an explanation of the
 
 %!assert (cumsum (single ([1, 2; 3, 4]), 1), single ([1, 2; 4, 6]))
 %!assert (cumsum (single ([1, 2; 3, 4]), 2), single ([1, 3; 3, 7]))
 
 %!error cumsum ()
 */
 
 DEFUN (diag, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{M} =} diag (@var{v})\n\
 @deftypefnx {Built-in Function} {@var{M} =} diag (@var{v}, @var{k})\n\
 @deftypefnx {Built-in Function} {@var{M} =} diag (@var{v}, @var{m}, @var{n})\n\
 @deftypefnx {Built-in Function} {@var{v} =} diag (@var{M})\n\
 @deftypefnx {Built-in Function} {@var{v} =} diag (@var{M}, @var{k})\n\
 Return a diagonal matrix with vector @var{v} on diagonal @var{k}.  The\n\
 second argument is optional.  If it is positive, the vector is placed on\n\
 the @var{k}-th super-diagonal.  If it is negative, it is placed on the\n\
@@ -1361,17 +1365,17 @@ Given a matrix argument, instead of a ve
 %!assert (diag (single (i), 3, 3), diag ([single(i), 0, 0]))
 %!assert (diag ([1, 2], 3, 3), diag ([1, 2, 0]))
 %!assert (diag ([1, 2]*i, 3, 3), diag ([1, 2, 0]*i))
 %!assert (diag (single ([1, 2]), 3, 3), diag (single ([1, 2, 0])))
 %!assert (diag (single ([1, 2]*i), 3, 3), diag (single ([1, 2, 0]*i)))
 */
 
 DEFUN (prod, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} prod (@var{x})\n\
 @deftypefnx {Built-in Function} {} prod (@var{x}, @var{dim})\n\
 Product of elements along dimension @var{dim}.  If @var{dim} is\n\
 omitted, it defaults to the first non-singleton dimension.\n\
 @seealso{cumprod, sum}\n\
 @end deftypefn")
 {
   DATA_REDUCTION (prod);
@@ -1653,17 +1657,17 @@ do_class_concat (const octave_value_list
       octave_map m = do_single_type_concat_map (tmp, dim);
 
       std::string cname = tmp(0).class_name ();
       std::list<std::string> parents = tmp(0).parent_class_name_list ();
 
       retval = octave_value (new octave_class (m, cname, parents));
     }
 
- done:
+done:
   return retval;
 }
 
 static octave_value
 do_cat (const octave_value_list& xargs, int dim, std::string fname)
 {
   octave_value retval;
 
@@ -1704,17 +1708,18 @@ do_cat (const octave_value_list& xargs, 
             result_type = get_concat_class (result_type, args(i).class_name ());
 
           if (all_sq_strings_p && ! args(i).is_sq_string ())
             all_sq_strings_p = false;
           if (all_dq_strings_p && ! args(i).is_dq_string ())
             all_dq_strings_p = false;
           if (all_real_p && ! args(i).is_real_type ())
             all_real_p = false;
-          if (all_cmplx_p && ! (args(i).is_complex_type () || args(i).is_real_type ()))
+          if (all_cmplx_p && ! (args(i).is_complex_type ()
+              || args(i).is_real_type ()))
             all_cmplx_p = false;
           if (!any_sparse_p && args(i).is_sparse_type ())
             any_sparse_p = true;
           if (!any_cell_p && args(i).is_cell ())
             any_cell_p = true;
           if (!any_class_p && args(i).is_object ())
             any_class_p = true;
         }
@@ -1793,17 +1798,18 @@ do_cat (const octave_value_list& xargs, 
         retval = do_single_type_concat<Cell> (args, dim);
       else if (result_type == "struct")
         retval = do_single_type_concat_map (args, dim);
       else
         {
           dim_vector  dv = args(0).dims ();
 
           // Default concatenation.
-          bool (dim_vector::*concat_rule) (const dim_vector&, int) = &dim_vector::concat;
+          bool (dim_vector::*concat_rule) (const dim_vector&, int)
+            = &dim_vector::concat;
 
           if (dim == -1 || dim == -2)
             {
               concat_rule = &dim_vector::hvcat;
               dim = -dim - 1;
             }
 
           for (int i = 1; i < args.length (); i++)
@@ -2076,17 +2082,17 @@ new matrices.  For example:\n\
 %!assert (class (horzcat ("a", "a")), "char")
 
 %!assert (class (horzcat (cell (1), struct ("foo", "bar"))), "cell")
 
 %!error horzcat (struct ("foo", "bar"), cell (1))
 */
 
 DEFUN (vertcat, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} vertcat (@var{array1}, @var{array2}, @dots{}, @var{arrayN})\n\
 Return the vertical concatenation of N-D array objects, @var{array1},\n\
 @var{array2}, @dots{}, @var{arrayN} along dimension 1.\n\
 \n\
 Arrays may also be concatenated vertically using the syntax for creating\n\
 new matrices.  For example:\n\
 \n\
 @example\n\
@@ -2100,17 +2106,17 @@ new matrices.  For example:\n\
 
 /*
 %!test
 %! c = {"foo"; "bar"; "bazoloa"};
 %! assert (vertcat (c, "a", "bc", "def"), {"foo"; "bar"; "bazoloa"; "a"; "bc"; "def"});
 */
 
 DEFUN (cat, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} cat (@var{dim}, @var{array1}, @var{array2}, @dots{}, @var{arrayN})\n\
 Return the concatenation of N-D array objects, @var{array1},\n\
 @var{array2}, @dots{}, @var{arrayN} along dimension @var{dim}.\n\
 \n\
 @example\n\
 @group\n\
 A = ones (2, 2);\n\
 B = zeros (2, 2);\n\
@@ -2170,81 +2176,81 @@ cat (4, ones (2, 2), zeros (2, 2))\n\
     print_usage ();
 
   return retval;
 }
 
 /*
 %!function ret = __testcat (t1, t2, tr, cmplx)
 %!  assert (cat (1, cast ([], t1), cast ([], t2)), cast ([], tr));
-%! 
+%!
 %!  assert (cat (1, cast (1, t1), cast (2, t2)), cast ([1; 2], tr));
 %!  assert (cat (1, cast (1, t1), cast ([2; 3], t2)), cast ([1; 2; 3], tr));
 %!  assert (cat (1, cast ([1; 2], t1), cast (3, t2)), cast ([1; 2; 3], tr));
 %!  assert (cat (1, cast ([1; 2], t1), cast ([3; 4], t2)), cast ([1; 2; 3; 4], tr));
 %!  assert (cat (2, cast (1, t1), cast (2, t2)), cast ([1, 2], tr));
 %!  assert (cat (2, cast (1, t1), cast ([2, 3], t2)), cast ([1, 2, 3], tr));
 %!  assert (cat (2, cast ([1, 2], t1), cast (3, t2)), cast ([1, 2, 3], tr));
 %!  assert (cat (2, cast ([1, 2], t1), cast ([3, 4], t2)), cast ([1, 2, 3, 4], tr));
-%! 
+%!
 %!  assert ([cast(1, t1); cast(2, t2)], cast ([1; 2], tr));
 %!  assert ([cast(1, t1); cast([2; 3], t2)], cast ([1; 2; 3], tr));
 %!  assert ([cast([1; 2], t1); cast(3, t2)], cast ([1; 2; 3], tr));
 %!  assert ([cast([1; 2], t1); cast([3; 4], t2)], cast ([1; 2; 3; 4], tr));
 %!  assert ([cast(1, t1), cast(2, t2)], cast ([1, 2], tr));
 %!  assert ([cast(1, t1), cast([2, 3], t2)], cast ([1, 2, 3], tr));
 %!  assert ([cast([1, 2], t1), cast(3, t2)], cast ([1, 2, 3], tr));
 %!  assert ([cast([1, 2], t1), cast([3, 4], t2)], cast ([1, 2, 3, 4], tr));
-%! 
+%!
 %!  if (nargin == 3 || cmplx)
 %!    assert (cat (1, cast (1i, t1), cast (2, t2)), cast ([1i; 2], tr));
 %!    assert (cat (1, cast (1i, t1), cast ([2; 3], t2)), cast ([1i; 2; 3], tr));
 %!    assert (cat (1, cast ([1i; 2], t1), cast (3, t2)), cast ([1i; 2; 3], tr));
 %!    assert (cat (1, cast ([1i; 2], t1), cast ([3; 4], t2)), cast ([1i; 2; 3; 4], tr));
 %!    assert (cat (2, cast (1i, t1), cast (2, t2)), cast ([1i, 2], tr));
 %!    assert (cat (2, cast (1i, t1), cast ([2, 3], t2)), cast ([1i, 2, 3], tr));
 %!    assert (cat (2, cast ([1i, 2], t1), cast (3, t2)), cast ([1i, 2, 3], tr));
 %!    assert (cat (2, cast ([1i, 2], t1), cast ([3, 4], t2)), cast ([1i, 2, 3, 4], tr));
-%! 
+%!
 %!    assert ([cast(1i, t1); cast(2, t2)], cast ([1i; 2], tr));
 %!    assert ([cast(1i, t1); cast([2; 3], t2)], cast ([1i; 2; 3], tr));
 %!    assert ([cast([1i; 2], t1); cast(3, t2)], cast ([1i; 2; 3], tr));
 %!    assert ([cast([1i; 2], t1); cast([3; 4], t2)], cast ([1i; 2; 3; 4], tr));
 %!    assert ([cast(1i, t1), cast(2, t2)], cast ([1i, 2], tr));
 %!    assert ([cast(1i, t1), cast([2, 3], t2)], cast ([1i, 2, 3], tr));
 %!    assert ([cast([1i, 2], t1), cast(3, t2)], cast ([1i, 2, 3], tr));
 %!    assert ([cast([1i, 2], t1), cast([3, 4], t2)], cast ([1i, 2, 3, 4], tr));
-%! 
+%!
 %!    assert (cat (1, cast (1, t1), cast (2i, t2)), cast ([1; 2i], tr));
 %!    assert (cat (1, cast (1, t1), cast ([2i; 3], t2)), cast ([1; 2i; 3], tr));
 %!    assert (cat (1, cast ([1; 2], t1), cast (3i, t2)), cast ([1; 2; 3i], tr));
 %!    assert (cat (1, cast ([1; 2], t1), cast ([3i; 4], t2)), cast ([1; 2; 3i; 4], tr));
 %!    assert (cat (2, cast (1, t1), cast (2i, t2)), cast ([1, 2i], tr));
 %!    assert (cat (2, cast (1, t1), cast ([2i, 3], t2)), cast ([1, 2i, 3], tr));
 %!    assert (cat (2, cast ([1, 2], t1), cast (3i, t2)), cast ([1, 2, 3i], tr));
 %!    assert (cat (2, cast ([1, 2], t1), cast ([3i, 4], t2)), cast ([1, 2, 3i, 4], tr));
-%! 
+%!
 %!    assert ([cast(1, t1); cast(2i, t2)], cast ([1; 2i], tr));
 %!    assert ([cast(1, t1); cast([2i; 3], t2)], cast ([1; 2i; 3], tr));
 %!    assert ([cast([1; 2], t1); cast(3i, t2)], cast ([1; 2; 3i], tr));
 %!    assert ([cast([1; 2], t1); cast([3i; 4], t2)], cast ([1; 2; 3i; 4], tr));
 %!    assert ([cast(1, t1), cast(2i, t2)], cast ([1, 2i], tr));
 %!    assert ([cast(1, t1), cast([2i, 3], t2)], cast ([1, 2i, 3], tr));
 %!    assert ([cast([1, 2], t1), cast(3i, t2)], cast ([1, 2, 3i], tr));
 %!    assert ([cast([1, 2], t1), cast([3i, 4], t2)], cast ([1, 2, 3i, 4], tr));
-%! 
+%!
 %!    assert (cat (1, cast (1i, t1), cast (2i, t2)), cast ([1i; 2i], tr));
 %!    assert (cat (1, cast (1i, t1), cast ([2i; 3], t2)), cast ([1i; 2i; 3], tr));
 %!    assert (cat (1, cast ([1i; 2], t1), cast (3i, t2)), cast ([1i; 2; 3i], tr));
 %!    assert (cat (1, cast ([1i; 2], t1), cast ([3i; 4], t2)), cast ([1i; 2; 3i; 4], tr));
 %!    assert (cat (2, cast (1i, t1), cast (2i, t2)), cast ([1i, 2i], tr));
 %!    assert (cat (2, cast (1i, t1), cast ([2i, 3], t2)), cast ([1i, 2i, 3], tr));
 %!    assert (cat (2, cast ([1i, 2], t1), cast (3i, t2)), cast ([1i, 2, 3i], tr));
 %!    assert (cat (2, cast ([1i, 2], t1), cast ([3i, 4], t2)), cast ([1i, 2, 3i, 4], tr));
-%! 
+%!
 %!    assert ([cast(1i, t1); cast(2i, t2)], cast ([1i; 2i], tr));
 %!    assert ([cast(1i, t1); cast([2i; 3], t2)], cast ([1i; 2i; 3], tr));
 %!    assert ([cast([1i; 2], t1); cast(3i, t2)], cast ([1i; 2; 3i], tr));
 %!    assert ([cast([1i; 2], t1); cast([3i; 4], t2)], cast ([1i; 2; 3i; 4], tr));
 %!    assert ([cast(1i, t1), cast(2i, t2)], cast ([1i, 2i], tr));
 %!    assert ([cast(1i, t1), cast([2i, 3], t2)], cast ([1i, 2i, 3], tr));
 %!    assert ([cast([1i, 2], t1), cast(3i, t2)], cast ([1i, 2, 3i], tr));
 %!    assert ([cast([1i, 2], t1), cast([3i, 4], t2)], cast ([1i, 2, 3i, 4], tr));
@@ -2319,17 +2325,17 @@ static octave_value
 do_permute (const octave_value_list& args, bool inv)
 {
   octave_value retval;
 
   if (args.length () == 2 && args(1).length () >= args(1).ndims ())
     {
       Array<int> vec = args(1).int_vector_value ();
 
-      // FIXME -- maybe we should create an idx_vector object
+      // FIXME: maybe we should create an idx_vector object
       // here and pass that to permute?
 
       int n = vec.length ();
 
       for (int i = 0; i < n; i++)
         vec(i)--;
 
       octave_value ret = args(0).permute (vec, inv);
@@ -2339,46 +2345,46 @@ do_permute (const octave_value_list& arg
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (permute, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} permute (@var{A}, @var{perm})\n\
 Return the generalized transpose for an N-D array object @var{A}.\n\
 The permutation vector @var{perm} must contain the elements\n\
 @code{1:ndims (A)} (in any order, but each element must appear only once).\n\
 @seealso{ipermute}\n\
 @end deftypefn")
 {
   return do_permute (args, false);
 }
 
 DEFUN (ipermute, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ipermute (@var{A}, @var{iperm})\n\
 The inverse of the @code{permute} function.  The expression\n\
 \n\
 @example\n\
 ipermute (permute (A, perm), perm)\n\
 @end example\n\
 \n\
 @noindent\n\
 returns the original array @var{A}.\n\
 @seealso{permute}\n\
 @end deftypefn")
 {
   return do_permute (args, true);
 }
 
 DEFUN (length, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} length (@var{a})\n\
 Return the length of the object @var{a}.\n\
 \n\
 The length is 0 for empty objects, 1 for scalars, and the number of elements\n\
 for vectors.  For matrix objects, the length is the number of rows or\n\
 columns, whichever is greater (this odd definition is used for compatibility\n\
 with @sc{matlab}).\n\
 @seealso{numel, size}\n\
@@ -2390,17 +2396,17 @@ with @sc{matlab}).\n\
     retval = args(0).length ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (ndims, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ndims (@var{a})\n\
 Return the number of dimensions of @var{a}.\n\
 For any array, the result will always be larger than or equal to 2.\n\
 Trailing singleton dimensions are not counted.\n\
 \n\
 @example\n\
 @group\n\
 ndims (ones (4, 1, 2, 1))\n\
@@ -2416,17 +2422,17 @@ ndims (ones (4, 1, 2, 1))\n\
     retval = args(0).ndims ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (numel, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} numel (@var{a})\n\
 @deftypefnx {Built-in Function} {} numel (@var{a}, @var{idx1}, @var{idx2}, @dots{})\n\
 Return the number of elements in the object @var{a}.\n\
 Optionally, if indices @var{idx1}, @var{idx2}, @dots{} are supplied,\n\
 return the number of elements that would result from the indexing\n\
 \n\
 @example\n\
 @var{a}(@var{idx1}, @var{idx2}, @dots{})\n\
@@ -2463,17 +2469,17 @@ indexing, i.e., @code{object@{@dots{}@}}
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (size, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} size (@var{a})\n\
 @deftypefnx {Built-in Function} {} size (@var{a}, @var{dim})\n\
 Return the number of rows and columns of @var{a}.\n\
 \n\
 With one input argument and one output argument, the result is returned\n\
 in a row vector.  If there are multiple output arguments, the number of\n\
 rows is assigned to the first, and the number of columns to the second,\n\
 etc.  For example:\n\
@@ -2554,17 +2560,17 @@ returns the number of columns in the giv
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (size_equal, args, ,
-   "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} size_equal (@var{a}, @var{b}, @dots{})\n\
 Return true if the dimensions of all arguments agree.\n\
 Trailing singleton dimensions are ignored.\n\
 Called with a single or no argument, size_equal returns true.\n\
 @seealso{size, numel, ndims}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -2588,34 +2594,34 @@ Called with a single or no argument, siz
             }
         }
     }
 
   return retval;
 }
 
 DEFUN (nnz, args, ,
-   "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{scalar} =} nnz (@var{a})\n\
 Return the number of non zero elements in @var{a}.\n\
 @seealso{sparse, nzmax}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).nnz ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (nzmax, args, ,
-   "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{scalar} =} nzmax (@var{SM})\n\
 Return the amount of storage allocated to the sparse matrix @var{SM}.\n\
 Note that Octave tends to crop unused memory at the first opportunity\n\
 for sparse objects.  There are some cases of user created sparse objects\n\
 where the value returned by @dfn{nzmax} will not be the same as @dfn{nnz},\n\
 but in general they will give the same result.\n\
 @seealso{nnz, spalloc, sparse}\n\
 @end deftypefn")
@@ -2626,51 +2632,51 @@ but in general they will give the same r
     retval = args(0).nzmax ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (rows, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} rows (@var{a})\n\
 Return the number of rows of @var{a}.\n\
 @seealso{columns, size, length, numel, isscalar, isvector, ismatrix}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).rows ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (columns, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} columns (@var{a})\n\
 Return the number of columns of @var{a}.\n\
 @seealso{rows, size, length, numel, isscalar, isvector, ismatrix}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).columns ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (sum, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} sum (@var{x})\n\
 @deftypefnx {Built-in Function} {} sum (@var{x}, @var{dim})\n\
 @deftypefnx {Built-in Function} {} sum (@dots{}, \"native\")\n\
 @deftypefnx {Built-in Function} {} sum (@dots{}, \"double\")\n\
 @deftypefnx {Built-in Function} {} sum (@dots{}, \"extra\")\n\
 Sum of elements along dimension @var{dim}.  If @var{dim} is\n\
 omitted, it defaults to the first non-singleton dimension.\n\
 \n\
@@ -2790,17 +2796,17 @@ inputs, @qcode{\"extra\"} is the same as
             MAKE_INT_BRANCH (int16);
             MAKE_INT_BRANCH (int32);
             MAKE_INT_BRANCH (int64);
             MAKE_INT_BRANCH (uint8);
             MAKE_INT_BRANCH (uint16);
             MAKE_INT_BRANCH (uint32);
             MAKE_INT_BRANCH (uint64);
 #undef MAKE_INT_BRANCH
-            // GAGME: Accursed Matlab compatibility...
+              // GAGME: Accursed Matlab compatibility...
             case btyp_char:
               if (isextra)
                 retval = arg.array_value (true).xsum (dim);
               else
                 retval = arg.array_value (true).sum (dim);
               break;
             case btyp_bool:
               if (arg.is_sparse_type ())
@@ -2885,17 +2891,17 @@ inputs, @qcode{\"extra\"} is the same as
 
 ;-)
 %!assert (sum ("Octave") + "8", sumsq (primes (17)))
 
 %!error sum ()
 */
 
 DEFUN (sumsq, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} sumsq (@var{x})\n\
 @deftypefnx {Built-in Function} {} sumsq (@var{x}, @var{dim})\n\
 Sum of squares of elements along dimension @var{dim}.  If @var{dim}\n\
 is omitted, it defaults to the first non-singleton dimension.\n\
 \n\
 This function is conceptually equivalent to computing\n\
 \n\
 @example\n\
@@ -2924,17 +2930,17 @@ but it uses less memory and avoids calli
 
 %!assert (sumsq (single ([1, 2; 3, 4]), 1), single ([10, 20]))
 %!assert (sumsq (single ([1, 2; 3, 4]), 2), single ([5; 25]))
 
 %!error sumsq ()
 */
 
 DEFUN (islogical, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} islogical (@var{x})\n\
 @deftypefnx {Built-in Function} {} isbool (@var{x})\n\
 Return true if @var{x} is a logical object.\n\
 @seealso{isfloat, isinteger, ischar, isnumeric, isa}\n\
 @end deftypefn")
 {
   octave_value retval;
 
@@ -2958,17 +2964,17 @@ DEFALIAS (isbool, islogical);
 %!assert (islogical (single (1)), false)
 %!assert (islogical (single (1i)), false)
 %!assert (islogical (single ([1,1])), false)
 %!assert (islogical (sparse ([true, false])), true)
 %!assert (islogical (sparse ([1, 0])), false)
 */
 
 DEFUN (isinteger, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isinteger (@var{x})\n\
 Return true if @var{x} is an integer object (int8, uint8, int16, etc.).\n\
 Note that @w{@code{isinteger (14)}} is false because numeric constants in\n\
 Octave are double precision floating point values.\n\
 @seealso{isfloat, ischar, islogical, isnumeric, isa}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -2977,55 +2983,55 @@ Octave are double precision floating poi
     retval = args(0).is_integer_type ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (iscomplex, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} iscomplex (@var{x})\n\
 Return true if @var{x} is a complex-valued numeric object.\n\
 @seealso{isreal, isnumeric, islogical, ischar, isfloat, isa}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).is_complex_type ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (isfloat, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isfloat (@var{x})\n\
 Return true if @var{x} is a floating-point numeric object.\n\
 Objects of class double or single are floating-point objects.\n\
 @seealso{isinteger, ischar, islogical, isnumeric, isa}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).is_float_type ();
   else
     print_usage ();
 
   return retval;
 }
 
-// FIXME -- perhaps this should be implemented with an
+// FIXME: perhaps this should be implemented with an
 // octave_value member function?
 
 DEFUN (complex, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} complex (@var{x})\n\
 @deftypefnx {Built-in Function} {} complex (@var{re}, @var{im})\n\
 Return a complex result from real arguments.  With 1 real argument @var{x},\n\
 return the complex result @code{@var{x} + 0i}.  With 2 real arguments,\n\
 return the complex result @code{@var{re} + @var{im}}.  @code{complex} can\n\
 often be more convenient than expressions such as @code{a + i*b}.\n\
 For example:\n\
 \n\
@@ -3133,17 +3139,19 @@ complex ([1, 2], [3, 4])\n\
                 }
               else if (im.numel () == 1)
                 {
                   SparseComplexMatrix result;
                   if (im_val.nnz () == 0)
                     result = SparseComplexMatrix (re_val);
                   else
                     {
-                      result = SparseComplexMatrix (re_val.rows (), re_val.cols (), Complex (0, im_val (0)));
+                      result = SparseComplexMatrix (re_val.rows (),
+                                                    re_val.cols (),
+                                                    Complex (0, im_val (0)));
                       octave_idx_type nr = re_val.rows ();
                       octave_idx_type nc = re_val.cols ();
 
                       for (octave_idx_type j = 0; j < nc; j++)
                         {
                           octave_idx_type off = j * nr;
                           for (octave_idx_type i = re_val.cidx (j);
                                i < re_val.cidx (j + 1); i++)
@@ -3153,19 +3161,21 @@ complex ([1, 2], [3, 4])\n\
                         }
                     }
                   retval = octave_value (new octave_sparse_complex_matrix (result));
                 }
               else
                 {
                   if (re_val.dims () == im_val.dims ())
                     {
-                      SparseComplexMatrix result = SparseComplexMatrix (re_val)
-                        + Complex (0, 1) * SparseComplexMatrix (im_val);
-                      retval = octave_value (new octave_sparse_complex_matrix (result));
+                      SparseComplexMatrix result;
+                      result = SparseComplexMatrix (re_val)
+                               + Complex (0, 1) * SparseComplexMatrix (im_val);
+                      retval = octave_value (
+                                 new octave_sparse_complex_matrix (result));
                     }
                   else
                     error ("complex: dimension mismatch");
                 }
             }
         }
       else if (re.is_single_type () || im.is_single_type ())
         {
@@ -3173,82 +3183,92 @@ complex ([1, 2], [3, 4])\n\
             {
               float re_val = re.float_value ();
 
               if (im.numel () == 1)
                 {
                   float im_val = im.double_value ();
 
                   if (! error_state)
-                    retval = octave_value (new octave_float_complex (FloatComplex (re_val, im_val)));
+                    retval = octave_value (
+                               new octave_float_complex (FloatComplex (re_val,
+                                                                       im_val)));
                 }
               else
                 {
                   const FloatNDArray im_val = im.float_array_value ();
 
                   if (! error_state)
                     {
-                      FloatComplexNDArray result (im_val.dims (), FloatComplex ());
+                      FloatComplexNDArray result (im_val.dims (),
+                                                  FloatComplex ());
 
                       for (octave_idx_type i = 0; i < im_val.numel (); i++)
                         result.xelem (i) = FloatComplex (re_val, im_val(i));
 
-                      retval = octave_value (new octave_float_complex_matrix (result));
+                      retval = octave_value (
+                                 new octave_float_complex_matrix (result));
                     }
                 }
             }
           else
             {
               const FloatNDArray re_val = re.float_array_value ();
 
               if (im.numel () == 1)
                 {
                   float im_val = im.float_value ();
 
                   if (! error_state)
                     {
-                      FloatComplexNDArray result (re_val.dims (), FloatComplex ());
+                      FloatComplexNDArray result (re_val.dims (),
+                                                  FloatComplex ());
 
                       for (octave_idx_type i = 0; i < re_val.numel (); i++)
                         result.xelem (i) = FloatComplex (re_val(i), im_val);
 
-                      retval = octave_value (new octave_float_complex_matrix (result));
+                      retval = octave_value (
+                                 new octave_float_complex_matrix (result));
                     }
                 }
               else
                 {
                   const FloatNDArray im_val = im.float_array_value ();
 
                   if (! error_state)
                     {
                       if (re_val.dims () == im_val.dims ())
                         {
-                          FloatComplexNDArray result (re_val.dims (), FloatComplex ());
+                          FloatComplexNDArray result (re_val.dims (),
+                                                      FloatComplex ());
 
                           for (octave_idx_type i = 0; i < re_val.numel (); i++)
-                            result.xelem (i) = FloatComplex (re_val(i), im_val(i));
-
-                          retval = octave_value (new octave_float_complex_matrix (result));
+                            result.xelem (i) = FloatComplex (re_val(i),
+                                                             im_val(i));
+
+                          retval = octave_value (
+                                     new octave_float_complex_matrix (result));
                         }
                       else
                         error ("complex: dimension mismatch");
                     }
                 }
             }
         }
       else if (re.numel () == 1)
         {
           double re_val = re.double_value ();
 
           if (im.numel () == 1)
             {
               double im_val = im.double_value ();
 
               if (! error_state)
-                retval = octave_value (new octave_complex (Complex (re_val, im_val)));
+                retval = octave_value (new octave_complex (Complex (re_val,
+                                                                    im_val)));
             }
           else
             {
               const NDArray im_val = im.array_value ();
 
               if (! error_state)
                 {
                   ComplexNDArray result (im_val.dims (), Complex ());
@@ -3286,17 +3306,18 @@ complex ([1, 2], [3, 4])\n\
                 {
                   if (re_val.dims () == im_val.dims ())
                     {
                       ComplexNDArray result (re_val.dims (), Complex ());
 
                       for (octave_idx_type i = 0; i < re_val.numel (); i++)
                         result.xelem (i) = Complex (re_val(i), im_val(i));
 
-                      retval = octave_value (new octave_complex_matrix (result));
+                      retval = octave_value (
+                                 new octave_complex_matrix (result));
                     }
                   else
                     error ("complex: dimension mismatch");
                 }
             }
         }
 
       if (error_state)
@@ -3304,17 +3325,17 @@ complex ([1, 2], [3, 4])\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (isreal, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isreal (@var{x})\n\
 Return true if @var{x} is a non-complex matrix or scalar.\n\
 For compatibility with @sc{matlab}, this includes logical and character\n\
 matrices.\n\
 @seealso{iscomplex, isnumeric, isa}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -3323,17 +3344,17 @@ matrices.\n\
     retval = args(0).is_real_type ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (isempty, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isempty (@var{a})\n\
 Return true if @var{a} is an empty matrix (any one of its dimensions is\n\
 zero).  Otherwise, return false.\n\
 @seealso{isnull, isa}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
@@ -3346,17 +3367,17 @@ zero).  Otherwise, return false.\n\
 }
 
 /*
 %% Debian bug #706376
 %!assert (isempty (speye(2^16)), false)
 */
 
 DEFUN (isnumeric, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isnumeric (@var{x})\n\
 Return true if @var{x} is a numeric object, i.e., an integer, real, or\n\
 complex array.  Logical and character arrays are not considered to be\n\
 numeric.\n\
 @seealso{isinteger, isfloat, isreal, iscomplex, islogical, ischar, iscell, isstruct, isa}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -3381,32 +3402,34 @@ numeric.\n\
 %!assert (isnumeric ("Hello World"), false)
 %!assert (isnumeric (true), false)
 %!assert (isnumeric (false), false)
 %!assert (isnumeric ([true, false]), false)
 %!assert (isnumeric (sparse ([true, false])), false)
 */
 
 DEFUN (ismatrix, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ismatrix (@var{a})\n\
 Return true if @var{a} is a numeric, logical, or character matrix.\n\
 Scalars (1x1 matrices) and vectors (@nospell{1xN} or @nospell{Nx1} matrices)\n\
 are subsets of the more general N-dimensional matrix and @code{ismatrix}\n\
 will return true for these objects as well.\n\
 @seealso{isscalar, isvector, iscell, isstruct, issparse, isa}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
     {
       octave_value arg = args(0);
 
-      retval = arg.is_matrix_type () || arg.is_scalar_type () || arg.is_range ();
+      retval = arg.is_matrix_type ()
+               || arg.is_scalar_type ()
+               || arg.is_range ();
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -3483,17 +3506,17 @@ fill_matrix (const octave_value_list& ar
     }
 
   if (! error_state)
     {
       dims.chop_trailing_singletons ();
 
       check_dimensions (dims, fcn);
 
-      // FIXME -- perhaps this should be made extensible by
+      // FIXME: perhaps this should be made extensible by
       // using the class name to lookup a function to call to create
       // the new value.
 
       // Note that automatic narrowing will handle conversion from
       // NDArray to scalar.
 
       if (! error_state)
         {
@@ -3778,17 +3801,18 @@ fill_matrix (const octave_value_list& ar
       // Note that automatic narrowing will handle conversion from
       // NDArray to scalar.
 
       if (! error_state)
         {
           switch (dt)
             {
             case oct_data_conv::dt_single:
-              retval = FloatComplexNDArray (dims, static_cast<FloatComplex> (val));
+              retval = FloatComplexNDArray (dims,
+                                            static_cast<FloatComplex> (val));
               break;
 
             case oct_data_conv::dt_double:
               retval = ComplexNDArray (dims, val);
               break;
 
             default:
               error ("%s: invalid class name", fcn);
@@ -3848,17 +3872,17 @@ fill_matrix (const octave_value_list& ar
       if (! error_state)
         retval = boolNDArray (dims, val);
     }
 
   return retval;
 }
 
 DEFUN (ones, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} ones (@var{n})\n\
 @deftypefnx {Built-in Function} {} ones (@var{m}, @var{n})\n\
 @deftypefnx {Built-in Function} {} ones (@var{m}, @var{n}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} ones ([@var{m} @var{n} @dots{}])\n\
 @deftypefnx {Built-in Function} {} ones (@dots{}, @var{class})\n\
 Return a matrix or N-dimensional array whose elements are all 1.\n\
 If invoked with a single scalar integer argument @var{n}, return a square\n\
 @nospell{NxN} matrix.  If invoked with two or more scalar\n\
@@ -3897,17 +3921,17 @@ val = ones (m,n, \"uint8\")\n\
 
 %!assert (ones (3, "int8"), int8 ([1, 1, 1; 1, 1, 1; 1, 1, 1]))
 %!assert (ones (2, 3, "int8"), int8 ([1, 1, 1; 1, 1, 1]))
 %!assert (ones (3, 2, "int8"), int8 ([1, 1; 1, 1; 1, 1]))
 %!assert (size (ones (3, 4, 5, "int8")), [3, 4, 5])
 */
 
 DEFUN (zeros, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} zeros (@var{n})\n\
 @deftypefnx {Built-in Function} {} zeros (@var{m}, @var{n})\n\
 @deftypefnx {Built-in Function} {} zeros (@var{m}, @var{n}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} zeros ([@var{m} @var{n} @dots{}])\n\
 @deftypefnx {Built-in Function} {} zeros (@dots{}, @var{class})\n\
 Return a matrix or N-dimensional array whose elements are all 0.\n\
 If invoked with a single scalar integer argument, return a square\n\
 @nospell{NxN} matrix.  If invoked with two or more scalar\n\
@@ -3939,17 +3963,17 @@ val = zeros (m,n, \"uint8\")\n\
 
 %!assert (zeros (3, "int8"), int8 ([0, 0, 0; 0, 0, 0; 0, 0, 0]))
 %!assert (zeros (2, 3, "int8"), int8 ([0, 0, 0; 0, 0, 0]))
 %!assert (zeros (3, 2, "int8"), int8 ([0, 0; 0, 0; 0, 0]))
 %!assert (size (zeros (3, 4, 5, "int8")), [3, 4, 5])
 */
 
 DEFUN (Inf, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @c List other form of function in documentation index\n\
 @findex inf\n\
 \n\
 @deftypefn  {Built-in Function} {} Inf\n\
 @deftypefnx {Built-in Function} {} Inf (@var{n})\n\
 @deftypefnx {Built-in Function} {} Inf (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} Inf (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} Inf (@dots{}, @var{class})\n\
@@ -3996,17 +4020,17 @@ DEFALIAS (inf, Inf);
 
 %!error (inf (3, "int8"))
 %!error (inf (2, 3, "int8"))
 %!error (inf (3, 2, "int8"))
 %!error (inf (3, 4, 5, "int8"))
 */
 
 DEFUN (NaN, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @c List other form of function in documentation index\n\
 @findex nan\n\
 \n\
 @deftypefn  {Built-in Function} {} NaN\n\
 @deftypefnx {Built-in Function} {} NaN (@var{n})\n\
 @deftypefnx {Built-in Function} {} NaN (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} NaN (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} NaN (@dots{}, @var{class})\n\
@@ -4055,17 +4079,17 @@ DEFALIAS (nan, NaN);
 
 %!error (NaN (3, "int8"))
 %!error (NaN (2, 3, "int8"))
 %!error (NaN (3, 2, "int8"))
 %!error (NaN (3, 4, 5, "int8"))
 */
 
 DEFUN (e, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} e\n\
 @deftypefnx {Built-in Function} {} e (@var{n})\n\
 @deftypefnx {Built-in Function} {} e (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} e (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} e (@dots{}, @var{class})\n\
 Return a scalar, matrix, or N-dimensional array whose elements are all equal\n\
 to the base of natural logarithms.  The constant\n\
 @tex\n\
@@ -4090,17 +4114,17 @@ either @qcode{\"double\"} or @qcode{\"si
 #else
   double e_val = exp (1.0);
 #endif
 
   return fill_matrix (args, e_val, "e");
 }
 
 DEFUN (eps, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} eps\n\
 @deftypefnx {Built-in Function} {} eps (@var{x})\n\
 @deftypefnx {Built-in Function} {} eps (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} eps (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} eps (@dots{}, @var{class})\n\
 Return a scalar, matrix or N-dimensional array whose elements are all eps,\n\
 the machine precision.  More precisely, @code{eps} is the relative spacing\n\
 between any two adjacent numbers in the machine's floating point system.\n\
@@ -4131,26 +4155,26 @@ either @qcode{\"double\"} or @qcode{\"si
 
   if (nargin == 1 && ! args(0).is_string ())
     {
       if (args(0).is_single_type ())
         {
           Array<float> x = args(0).float_array_value ();
 
           if (! error_state)
-            {              
+            {
               Array<float> epsval (x.dims ());
-              
+
               for (octave_idx_type i = 0; i < x.numel (); i++)
                 {
                   float val = ::fabsf (x(i));
                   if (xisnan (val) || xisinf (val))
                     epsval(i) = lo_ieee_nan_value ();
                   else if (val < std::numeric_limits<float>::min ())
-                    epsval(i) = powf (2.0, -149e0);                  
+                    epsval(i) = powf (2.0, -149e0);
                   else
                     {
                       int expon;
                       frexpf (val, &expon);
                       epsval(i) = std::pow (static_cast <float> (2.0),
                                             static_cast <float> (expon - 24));
                     }
                 }
@@ -4196,34 +4220,34 @@ either @qcode{\"double\"} or @qcode{\"si
 %!assert (eps (1), 2^(-52))
 %!assert (eps (2), 2^(-51))
 %!assert (eps (realmax), 2^971)
 %!assert (eps (0), 2^(-1074))
 %!assert (eps (realmin/2), 2^(-1074))
 %!assert (eps (realmin/16), 2^(-1074))
 %!assert (eps (Inf), NaN)
 %!assert (eps (NaN), NaN)
-%!assert (eps ([1/2 1 2 realmax 0 realmin/2 realmin/16 Inf NaN]), 
+%!assert (eps ([1/2 1 2 realmax 0 realmin/2 realmin/16 Inf NaN]),
 %!             [2^(-53) 2^(-52) 2^(-51) 2^971 2^(-1074) 2^(-1074) 2^(-1074) NaN NaN])
 %!assert (eps (single (1/2)), single (2^(-24)))
 %!assert (eps (single (1)), single (2^(-23)))
 %!assert (eps (single (2)), single (2^(-22)))
 %!assert (eps (realmax ("single")), single (2^104))
 %!assert (eps (single (0)), single (2^(-149)))
 %!assert (eps (realmin ("single")/2), single (2^(-149)))
 %!assert (eps (realmin ("single")/16), single (2^(-149)))
 %!assert (eps (single (Inf)), single (NaN))
 %!assert (eps (single (NaN)), single (NaN))
-%!assert (eps (single ([1/2 1 2 realmax("single") 0 realmin("single")/2 realmin("single")/16 Inf NaN])), 
+%!assert (eps (single ([1/2 1 2 realmax("single") 0 realmin("single")/2 realmin("single")/16 Inf NaN])),
 %!             single ([2^(-24) 2^(-23) 2^(-22) 2^104 2^(-149) 2^(-149) 2^(-149) NaN NaN]))
 
 */
 
 DEFUN (pi, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} pi\n\
 @deftypefnx {Built-in Function} {} pi (@var{n})\n\
 @deftypefnx {Built-in Function} {} pi (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} pi (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} pi (@dots{}, @var{class})\n\
 Return a scalar, matrix, or N-dimensional array whose elements are all equal\n\
 to the ratio of the circumference of a circle to its\n\
 @tex\n\
@@ -4255,17 +4279,17 @@ either @qcode{\"double\"} or @qcode{\"si
 #else
   double pi_val = 4.0 * atan (1.0);
 #endif
 
   return fill_matrix (args, pi_val, "pi");
 }
 
 DEFUN (realmax, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} realmax\n\
 @deftypefnx {Built-in Function} {} realmax (@var{n})\n\
 @deftypefnx {Built-in Function} {} realmax (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} realmax (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} realmax (@dots{}, @var{class})\n\
 Return a scalar, matrix or N-dimensional array whose elements are all equal\n\
 to the largest floating point number that is representable.  The actual\n\
 value is system dependent.  On machines that support IEEE\n\
@@ -4289,17 +4313,17 @@ either @qcode{\"double\"} or @qcode{\"si
 @seealso{realmin, intmax, bitmax, eps}\n\
 @end deftypefn")
 {
   return fill_matrix (args, std::numeric_limits<double>::max (),
                       std::numeric_limits<float>::max (), "realmax");
 }
 
 DEFUN (realmin, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} realmin\n\
 @deftypefnx {Built-in Function} {} realmin (@var{n})\n\
 @deftypefnx {Built-in Function} {} realmin (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} realmin (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} realmin (@dots{}, @var{class})\n\
 Return a scalar, matrix or N-dimensional array whose elements are all equal\n\
 to the smallest normalized floating point number that is representable.\n\
 The actual value is system dependent.  On machines that support\n\
@@ -4323,17 +4347,17 @@ either @qcode{\"double\"} or @qcode{\"si
 @seealso{realmax, intmin, eps}\n\
 @end deftypefn")
 {
   return fill_matrix (args, std::numeric_limits<double>::min (),
                       std::numeric_limits<float>::min (), "realmin");
 }
 
 DEFUN (I, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @c List other forms of function in documentation index\n\
 @findex i\n\
 @findex j\n\
 @findex J\n\
 \n\
 @deftypefn  {Built-in Function} {} I\n\
 @deftypefnx {Built-in Function} {} I (@var{n})\n\
 @deftypefnx {Built-in Function} {} I (@var{n}, @var{m})\n\
@@ -4364,17 +4388,17 @@ either @qcode{\"double\"} or @qcode{\"si
   return fill_matrix (args, Complex (0.0, 1.0), "I");
 }
 
 DEFALIAS (i, I);
 DEFALIAS (J, I);
 DEFALIAS (j, I);
 
 DEFUN (NA, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} NA\n\
 @deftypefnx {Built-in Function} {} NA (@var{n})\n\
 @deftypefnx {Built-in Function} {} NA (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} NA (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} NA (@dots{}, @var{class})\n\
 Return a scalar, matrix, or N-dimensional array whose elements are all equal\n\
 to the special constant used to designate missing values.\n\
 \n\
@@ -4396,33 +4420,33 @@ either @qcode{\"double\"} or @qcode{\"si
 }
 
 /*
 %!assert (single (NA ("double")), NA ("single"))
 %!assert (double (NA ("single")), NA ("double"))
 */
 
 DEFUN (false, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} false (@var{x})\n\
 @deftypefnx {Built-in Function} {} false (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} false (@var{n}, @var{m}, @var{k}, @dots{})\n\
 Return a matrix or N-dimensional array whose elements are all logical 0.\n\
 If invoked with a single scalar integer argument, return a square\n\
 matrix of the specified size.  If invoked with two or more scalar\n\
 integer arguments, or a vector of integer values, return an array with\n\
 given dimensions.\n\
 @seealso{true}\n\
 @end deftypefn")
 {
   return fill_matrix (args, false, "false");
 }
 
 DEFUN (true, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} true (@var{x})\n\
 @deftypefnx {Built-in Function} {} true (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} true (@var{n}, @var{m}, @var{k}, @dots{})\n\
 Return a matrix or N-dimensional array whose elements are all logical 1.\n\
 If invoked with a single scalar integer argument, return a square\n\
 matrix of the specified size.  If invoked with two or more scalar\n\
 integer arguments, or a vector of integer values, return an array with\n\
 given dimensions.\n\
@@ -4479,17 +4503,17 @@ INSTANTIATE_EYE (FloatNDArray);
 INSTANTIATE_EYE (NDArray);
 INSTANTIATE_EYE (boolNDArray);
 
 static octave_value
 identity_matrix (int nr, int nc, oct_data_conv::data_type dt)
 {
   octave_value retval;
 
-  // FIXME -- perhaps this should be made extensible by using
+  // FIXME: perhaps this should be made extensible by using
   // the class name to lookup a function to call to create the new
   // value.
 
   if (! error_state)
     {
       switch (dt)
         {
         case oct_data_conv::dt_int8:
@@ -4543,17 +4567,17 @@ identity_matrix (int nr, int nc, oct_dat
     }
 
   return retval;
 }
 
 #undef INT_EYE_MATRIX
 
 DEFUN (eye, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} eye (@var{n})\n\
 @deftypefnx {Built-in Function} {} eye (@var{m}, @var{n})\n\
 @deftypefnx {Built-in Function} {} eye ([@var{m} @var{n}])\n\
 @deftypefnx {Built-in Function} {} eye (@dots{}, @var{class})\n\
 Return an identity matrix.  If invoked with a single scalar argument @var{n},\n\
 return a square @nospell{NxN} identity matrix.  If\n\
 supplied two scalar arguments (@var{m}, @var{n}), @code{eye} takes them to be\n\
 the number of rows and columns.  If given a vector with two elements,\n\
@@ -4700,17 +4724,17 @@ do_linspace (const octave_value& base, c
           retval = linspace (bv, lv, n);
         }
     }
 
   return retval;
 }
 
 DEFUN (linspace, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} linspace (@var{base}, @var{limit})\n\
 @deftypefnx {Built-in Function} {} linspace (@var{base}, @var{limit}, @var{n})\n\
 Return a row vector with @var{n} linearly spaced elements between\n\
 @var{base} and @var{limit}.  If the number of elements is greater than one,\n\
 then the endpoints @var{base} and @var{limit} are always included in\n\
 the range.  If @var{base} is greater than @var{limit}, the elements are\n\
 stored in decreasing order.  If the number of points is not specified, a\n\
 value of 100 is used.\n\
@@ -4789,21 +4813,21 @@ if fewer than two values are requested.\
 %! ##assert (linspace ([1, 2; 3, 4], 5, 6), linspace (1, 5, 6))
 
 %!assert (linspace (0, 1, []), 1)
 
 %!error linspace ()
 %!error linspace (1, 2, 3, 4)
 */
 
-// FIXME -- should accept dimensions as separate args for N-d
+// FIXME: should accept dimensions as separate args for N-d
 // arrays as well as 1-d and 2-d arrays.
 
 DEFUN (resize, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} resize (@var{x}, @var{m})\n\
 @deftypefnx {Built-in Function} {} resize (@var{x}, @var{m}, @var{n}, @dots{})\n\
 @deftypefnx {Built-in Function} {} resize (@var{x}, [@var{m} @var{n} @dots{}])\n\
 Resize @var{x} cutting off elements as necessary.\n\
 \n\
 In the result, element with certain indices is equal to the corresponding\n\
 element of @var{x} if the indices are within the bounds of @var{x};\n\
 otherwise, the element is set to zero.\n\
@@ -4880,20 +4904,20 @@ Resizing an object to fewer dimensions i
         }
 
     }
   else
     print_usage ();
   return retval;
 }
 
-// FIXME -- should use octave_idx_type for dimensions.
+// FIXME: should use octave_idx_type for dimensions.
 
 DEFUN (reshape, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} reshape (@var{A}, @var{m}, @var{n}, @dots{})\n\
 @deftypefnx {Built-in Function} {} reshape (@var{A}, [@var{m} @var{n} @dots{}])\n\
 @deftypefnx {Built-in Function} {} reshape (@var{A}, @dots{}, [], @dots{})\n\
 @deftypefnx {Built-in Function} {} reshape (@var{A}, @var{size})\n\
 Return a matrix with the specified dimensions (@var{m}, @var{n}, @dots{})\n\
 whose elements are taken from the matrix @var{A}.  The elements of the\n\
 matrix are accessed in column-major order (like Fortran arrays are stored).\n\
 \n\
@@ -4983,17 +5007,18 @@ the unspecified dimension.\n\
           if (nel == 0)
             new_dims(empty_dim-1) = 0;
           else
             {
               octave_idx_type a_nel = args(0).numel ();
               octave_idx_type size_empty_dim = a_nel / nel;
 
               if (a_nel != size_empty_dim * nel)
-                error ("reshape: SIZE is not divisible by the product of known dimensions (= %d)", nel);
+                error ("reshape: SIZE is not divisible by the product of known dimensions (= %d)",
+                       nel);
               else
                 new_dims(empty_dim-1) = size_empty_dim;
             }
         }
     }
   else
     {
       print_usage ();
@@ -5021,17 +5046,17 @@ the unspecified dimension.\n\
 %! s.a = 1;
 %! fail ("reshape (s, 2, 3)");
 
 %!error reshape ()
 %!error reshape (1, 2, 3, 4)
 */
 
 DEFUN (vec, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{v} =} vec (@var{x})\n\
 @deftypefnx {Built-in Function} {@var{v} =} vec (@var{x}, @var{dim})\n\
 Return the vector obtained by stacking the columns of the matrix @var{x}\n\
 one above the other.  Without @var{dim} this is equivalent to\n\
 @code{@var{x}(:)}.  If @var{dim} is supplied, the dimensions of @var{v}\n\
 are set to @var{dim} with all elements along the last dimension.\n\
 This is equivalent to @code{shiftdim (@var{x}(:), 1-@var{dim})}.\n\
 @seealso{vech, resize, cat}\n\
@@ -5087,17 +5112,17 @@ This is equivalent to @code{shiftdim (@v
 %!assert (vec ([1, 3; 2, 4], 3), shiftdim (vec ([1, 3; 2, 4]), -2))
 
 %!error vec ()
 %!error vec (1, 2, 3)
 %!error vec ([1, 2; 3, 4], 0)
 */
 
 DEFUN (squeeze, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} squeeze (@var{x})\n\
 Remove singleton dimensions from @var{x} and return the result.\n\
 Note that for compatibility with @sc{matlab}, all objects have\n\
 a minimum of two dimensions and row vectors are left unchanged.\n\
 @seealso{reshape}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -5106,17 +5131,17 @@ a minimum of two dimensions and row vect
     retval = args(0).squeeze ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (full, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{FM} =} full (@var{SM})\n\
 Return a full storage matrix from a sparse, diagonal, permutation matrix\n\
 or a range.\n\
 @seealso{sparse}\n\
 @end deftypefn")
 {
   octave_value retval;
 
@@ -5126,17 +5151,17 @@ or a range.\n\
     print_usage ();
 
   return retval;
 }
 
 // Compute various norms of the vector X.
 
 DEFUN (norm, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} norm (@var{A})\n\
 @deftypefnx {Built-in Function} {} norm (@var{A}, @var{p})\n\
 @deftypefnx {Built-in Function} {} norm (@var{A}, @var{p}, @var{opt})\n\
 Compute the p-norm of the matrix @var{A}.  If the second argument is\n\
 missing, @code{p = 2} is assumed.\n\
 \n\
 If @var{A} is a matrix (or sparse matrix):\n\
 \n\
@@ -5335,17 +5360,17 @@ compute the norms of each column and ret
 %!assert (norm (q, 3, "cols"), sum (q.^3, 1).^(1/3), sqrt (eps));
 %!assert (norm (q, "inf", "rows"), norm (q, Inf, "rows"));
 %!assert (norm (q, "inf", "cols"), norm (q, Inf, "cols"));
 %!assert (norm (q, [], "rows"), norm (q, 2, "rows"));
 %!assert (norm (q, [], "cols"), norm (q, 2, "cols"));
 
 %!test
 %! ## Test for norm returning NaN on sparse matrix (bug #30631)
-%! A = sparse (2,2); 
+%! A = sparse (2,2);
 %! A(2,1) = 1;
 %! assert (norm (A), 1);
 */
 
 static octave_value
 unary_op_defun_body (octave_value::unary_op op,
                      const octave_value_list& args)
 {
@@ -5354,48 +5379,48 @@ unary_op_defun_body (octave_value::unary
     retval = do_unary_op (op, args(0));
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (not, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} not (@var{x})\n\
 Return the logical NOT of @var{x}.  This function is equivalent to\n\
 @code{! x}.\n\
 @seealso{and, or, xor}\n\
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_not, args);
 }
 
 DEFUN (uplus, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} uplus (@var{x})\n\
 This function and @w{@tcode{+ x}} are equivalent.\n\
 @seealso{uminus, plus, minus}\n\
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_uplus, args);
 }
 
 DEFUN (uminus, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} uminus (@var{x})\n\
 This function and @w{@tcode{- x}} are equivalent.\n\
 @seealso{uplus, minus}\n\
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_uminus, args);
 }
 
 DEFUN (transpose, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} transpose (@var{x})\n\
 Return the transpose of @var{x}.\n\
 This function and @tcode{x.'} are equivalent.\n\
 @seealso{ctranspose}\n\
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_transpose, args);
 }
@@ -5416,17 +5441,17 @@ This function and @tcode{x.'} are equiva
 %!assert (single ([1;2;3;4]).', single ([1:4]))
 %!assert (single ([1,2;3,4]).', single ([1,3;2,4]))
 %!assert (single ([1,2i;3,4]).', single ([1,3;2i,4]))
 
 %!assert (transpose (single ([1,2;3,4])), single ([1,3;2,4]))
 */
 
 DEFUN (ctranspose, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ctranspose (@var{x})\n\
 Return the complex conjugate transpose of @var{x}.\n\
 This function and @tcode{x'} are equivalent.\n\
 @seealso{transpose}\n\
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_hermitian, args);
 }
@@ -5478,29 +5503,29 @@ binary_assoc_op_defun_body (octave_value
     case 0:
       print_usage ();
       break;
     case 1:
       retval = args(0);
       break;
     case 2:
       retval = do_binary_op (op, args(0), args(1));
-     break;
+      break;
     default:
-     retval = do_binary_op (op, args(0), args(1));
-     for (int i = 2; i < nargin; i++)
-       retval.assign (aop, args(i));
-     break;
+      retval = do_binary_op (op, args(0), args(1));
+      for (int i = 2; i < nargin; i++)
+        retval.assign (aop, args(i));
+      break;
     }
 
   return retval;
 }
 
 DEFUN (plus, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} plus (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} plus (@var{x1}, @var{x2}, @dots{})\n\
 This function and @w{@tcode{x + y}} are equivalent.\n\
 If more arguments are given, the summation is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
 (@dots{}((x1 + x2) + x3) + @dots{})\n\
@@ -5510,27 +5535,27 @@ At least one argument is required.\n\
 @seealso{minus, uplus}\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_add,
                                      octave_value::op_add_eq, args);
 }
 
 DEFUN (minus, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} minus (@var{x}, @var{y})\n\
 This function and @w{@tcode{x - y}} are equivalent.\n\
 @seealso{plus, uminus}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_sub, args);
 }
 
 DEFUN (mtimes, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} mtimes (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} mtimes (@var{x1}, @var{x2}, @dots{})\n\
 Return the matrix multiplication product of inputs.\n\
 This function and @w{@tcode{x * y}} are equivalent.\n\
 If more arguments are given, the multiplication is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
@@ -5541,112 +5566,112 @@ At least one argument is required.\n\
 @seealso{times, plus, minus, rdivide, mrdivide, mldivide, mpower}\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_mul,
                                      octave_value::op_mul_eq, args);
 }
 
 DEFUN (mrdivide, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mrdivide (@var{x}, @var{y})\n\
 Return the matrix right division of @var{x} and @var{y}.\n\
 This function and @w{@tcode{x / y}} are equivalent.\n\
 @seealso{mldivide, rdivide, plus, minus}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_div, args);
 }
 
 DEFUN (mpower, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mpower (@var{x}, @var{y})\n\
 Return the matrix power operation of @var{x} raised to the @var{y} power.\n\
 This function and @w{@tcode{x ^ y}} are equivalent.\n\
 @seealso{power, mtimes, plus, minus}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_pow, args);
 }
 
 DEFUN (mldivide, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mldivide (@var{x}, @var{y})\n\
 Return the matrix left division of @var{x} and @var{y}.\n\
 This function and @w{@tcode{x @xbackslashchar{} y}} are equivalent.\n\
 @seealso{mrdivide, ldivide, rdivide}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_ldiv, args);
 }
 
 DEFUN (lt, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} lt (@var{x}, @var{y})\n\
 This function is equivalent to @w{@code{x < y}}.\n\
 @seealso{le, eq, ge, gt, ne}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_lt, args);
 }
 
 DEFUN (le, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} le (@var{x}, @var{y})\n\
 This function is equivalent to @w{@code{x <= y}}.\n\
 @seealso{eq, ge, gt, ne, lt}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_le, args);
 }
 
 DEFUN (eq, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} eq (@var{x}, @var{y})\n\
 Return true if the two inputs are equal.\n\
 This function is equivalent to @w{@code{x == y}}.\n\
 @seealso{ne, isequal, le, ge, gt, ne, lt}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_eq, args);
 }
 
 DEFUN (ge, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ge (@var{x}, @var{y})\n\
 This function is equivalent to @w{@code{x >= y}}.\n\
 @seealso{le, eq, gt, ne, lt}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_ge, args);
 }
 
 DEFUN (gt, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} gt (@var{x}, @var{y})\n\
 This function is equivalent to @w{@code{x > y}}.\n\
 @seealso{le, eq, ge, ne, lt}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_gt, args);
 }
 
 DEFUN (ne, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ne (@var{x}, @var{y})\n\
 Return true if the two inputs are not equal.\n\
 This function is equivalent to @w{@code{x != y}}.\n\
 @seealso{eq, isequal, le, ge, lt}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_ne, args);
 }
 
 DEFUN (times, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} times (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} times (@var{x1}, @var{x2}, @dots{})\n\
 Return the element-by-element multiplication product of inputs.\n\
 This function and @w{@tcode{x .* y}} are equivalent.\n\
 If more arguments are given, the multiplication is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
@@ -5657,55 +5682,55 @@ At least one argument is required.\n\
 @seealso{mtimes, rdivide}\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_el_mul,
                                      octave_value::op_el_mul_eq, args);
 }
 
 DEFUN (rdivide, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} rdivide (@var{x}, @var{y})\n\
 Return the element-by-element right division of @var{x} and @var{y}.\n\
 This function and @w{@tcode{x ./ y}} are equivalent.\n\
 @seealso{ldivide, mrdivide, times, plus}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_el_div, args);
 }
 
 DEFUN (power, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} power (@var{x}, @var{y})\n\
 Return the element-by-element operation of @var{x} raised to the\n\
 @var{y} power.  If several complex results are possible,\n\
 returns the one with smallest non-negative argument (angle).  Use\n\
 @code{realpow}, @code{realsqrt}, @code{cbrt}, or @code{nthroot} if a\n\
 real result is preferred.\n\
 \n\
 This function and @w{@tcode{x .^ y}} are equivalent.\n\
 @seealso{mpower, realpow, realsqrt, cbrt, nthroot}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_el_pow, args);
 }
 
 DEFUN (ldivide, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ldivide (@var{x}, @var{y})\n\
 Return the element-by-element left division of @var{x} and @var{y}.\n\
 This function and @w{@tcode{x .@xbackslashchar{} y}} are equivalent.\n\
 @seealso{rdivide, mldivide, times, plus}\n\
 @end deftypefn")
 {
   return binary_op_defun_body (octave_value::op_el_ldiv, args);
 }
 
 DEFUN (and, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} and (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} and (@var{x1}, @var{x2}, @dots{})\n\
 Return the logical AND of @var{x} and @var{y}.\n\
 This function is equivalent to @w{@code{x & y}}.\n\
 If more arguments are given, the logical and is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
@@ -5716,17 +5741,17 @@ At least one argument is required.\n\
 @seealso{or, not, xor}\n\
 @end deftypefn")
 {
   return binary_assoc_op_defun_body (octave_value::op_el_and,
                                      octave_value::op_el_and_eq, args);
 }
 
 DEFUN (or, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} or (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} or (@var{x1}, @var{x2}, @dots{})\n\
 Return the logical OR of @var{x} and @var{y}.\n\
 This function is equivalent to @w{@code{x | y}}.\n\
 If more arguments are given, the logical or is applied\n\
 cumulatively from left to right:\n\
 \n\
 @example\n\
@@ -5739,17 +5764,17 @@ At least one argument is required.\n\
 {
   return binary_assoc_op_defun_body (octave_value::op_el_or,
                                      octave_value::op_el_or_eq, args);
 }
 
 static double tic_toc_timestamp = -1.0;
 
 DEFUN (tic, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} tic ()\n\
 @deftypefnx {Built-in Function} {@var{id} =} tic ()\n\
 @deftypefnx {Built-in Function} {} toc ()\n\
 @deftypefnx {Built-in Function} {} toc (@var{id})\n\
 @deftypefnx {Built-in Function} {@var{val} =} toc (@dots{})\n\
 Set or check a wall-clock timer.  Calling @code{tic} without an\n\
 output argument sets the internal timer state.  Subsequent calls\n\
 to @code{toc} return the number of seconds since the timer was set.\n\
@@ -5808,17 +5833,17 @@ doing nothing at all.\n\
     }
   else
     tic_toc_timestamp = tmp;
 
   return retval;
 }
 
 DEFUN (toc, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} toc ()\n\
 @deftypefnx {Built-in Function} {} toc (@var{id})\n\
 @deftypefnx {Built-in Function} {@var{val} =} toc (@dots{})\n\
 @seealso{tic, cputime}\n\
 @end deftypefn")
 {
   octave_value retval;
 
@@ -5835,19 +5860,20 @@ DEFUN (toc, args, nargout,
           octave_uint64 id = args(0).uint64_scalar_value ();
 
           if (! error_state)
             {
               uint64_t val = id.value ();
 
               start_time
                 = (static_cast<double> (val / CLOCKS_PER_SEC)
-                   + static_cast<double> (val % CLOCKS_PER_SEC) / CLOCKS_PER_SEC);
-
-              // FIXME -- should we also check to see whether the start
+                   + static_cast<double> (val % CLOCKS_PER_SEC)
+                   / CLOCKS_PER_SEC);
+
+              // FIXME: should we also check to see whether the start
               // time is after the beginning of this Octave session?
             }
           else
             error ("toc: invalid ID");
         }
 
       if (! error_state)
         {
@@ -5873,17 +5899,17 @@ DEFUN (toc, args, nargout,
 /*
 %!shared id
 %! id = tic ();
 %!assert (isa (id, "uint64"))
 %!assert (isa (toc (id), "double"))
 */
 
 DEFUN (cputime, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{total}, @var{user}, @var{system}] =} cputime ();\n\
 Return the CPU time used by your Octave session.  The first output is\n\
 the total time spent executing your process and is equal to the sum of\n\
 second and third outputs, which are the number of CPU seconds spent\n\
 executing in user mode and the number of CPU seconds spent executing in\n\
 system mode, respectively.  If your system does not have a way to report\n\
 CPU time usage, @code{cputime} returns 0 for each of its output values.\n\
 Note that because Octave used some CPU time to start, it is reasonable\n\
@@ -5902,56 +5928,56 @@ CPU time used is nonzero.\n\
 
 #if defined (HAVE_GETRUSAGE)
 
   struct rusage ru;
 
   getrusage (RUSAGE_SELF, &ru);
 
   usr = static_cast<double> (ru.ru_utime.tv_sec) +
-    static_cast<double> (ru.ru_utime.tv_usec) * 1e-6;
+        static_cast<double> (ru.ru_utime.tv_usec) * 1e-6;
 
   sys = static_cast<double> (ru.ru_stime.tv_sec) +
-    static_cast<double> (ru.ru_stime.tv_usec) * 1e-6;
+        static_cast<double> (ru.ru_stime.tv_usec) * 1e-6;
 
 #else
 
   struct tms t;
 
   times (&t);
 
   unsigned long ticks;
   unsigned long seconds;
   unsigned long fraction;
 
   ticks = t.tms_utime + t.tms_cutime;
   fraction = ticks % CLOCKS_PER_SEC;
   seconds = ticks / CLOCKS_PER_SEC;
 
   usr = static_cast<double> (seconds) + static_cast<double>(fraction) /
-    static_cast<double>(CLOCKS_PER_SEC);
+        static_cast<double>(CLOCKS_PER_SEC);
 
   ticks = t.tms_stime + t.tms_cstime;
   fraction = ticks % CLOCKS_PER_SEC;
   seconds = ticks / CLOCKS_PER_SEC;
 
   sys = static_cast<double> (seconds) + static_cast<double>(fraction) /
-    static_cast<double>(CLOCKS_PER_SEC);
+        static_cast<double>(CLOCKS_PER_SEC);
 
 #endif
 
   retval(2) = sys;
   retval(1) = usr;
   retval(0) = sys + usr;
 
   return retval;
 }
 
 DEFUN (sort, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{s}, @var{i}] =} sort (@var{x})\n\
 @deftypefnx {Built-in Function} {[@var{s}, @var{i}] =} sort (@var{x}, @var{dim})\n\
 @deftypefnx {Built-in Function} {[@var{s}, @var{i}] =} sort (@var{x}, @var{mode})\n\
 @deftypefnx {Built-in Function} {[@var{s}, @var{i}] =} sort (@var{x}, @var{dim}, @var{mode})\n\
 Return a copy of @var{x} with the elements arranged in increasing\n\
 order.  For matrices, @code{sort} orders the elements within columns\n\
 \n\
 For example:\n\
@@ -6090,17 +6116,17 @@ ordered lists.\n\
 
   if (return_idx)
     {
       retval.resize (2);
 
       Array<octave_idx_type> sidx;
 
       retval(0) = arg.sort (sidx, dim, smode);
-      retval(1) = idx_vector (sidx, dv(dim)); // No checking, the extent is known.
+      retval(1) = idx_vector (sidx, dv(dim)); // No checking, extent is known.
     }
   else
     retval(0) = arg.sort (dim, smode);
 
   return retval;
 }
 
 /*
@@ -6280,17 +6306,17 @@ ordered lists.\n\
 
 // Sort the rows of the matrix @var{a} according to the order
 // specified by @var{mode}, which can either be 'ascend' or 'descend'
 // and return the index vector corresponding to the sort order.
 //
 // This function does not yet support sparse matrices.
 
 DEFUN (__sort_rows_idx__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __sort_rows_idx__ (@var{a}, @var{mode})\n\
 Undocumented internal function.\n\
 @end deftypefn\n")
 {
   octave_value retval;
 
   int nargin = args.length ();
   sortmode smode = ASCENDING;
@@ -6329,19 +6355,19 @@ Undocumented internal function.\n\
     error ("__sort_rows_idx__: needs a 2-dimensional object");
 
   return retval;
 }
 
 static sortmode
 get_sort_mode_option (const octave_value& arg, const char *argn)
 {
-  // FIXME -- we initialize to UNSORTED here to avoid a GCC warning
+  // FIXME: we initialize to UNSORTED here to avoid a GCC warning
   // about possibly using sortmode uninitialized.
-  // FIXME -- shouldn't these modes be scoped inside a class?
+  // FIXME: shouldn't these modes be scoped inside a class?
   sortmode smode = UNSORTED;
 
   std::string mode = arg.string_value ();
 
   if (error_state)
     error ("issorted: expecting %s argument to be a character string", argn);
   else if (mode == "ascending")
     smode = ASCENDING;
@@ -6351,17 +6377,17 @@ get_sort_mode_option (const octave_value
     smode = UNSORTED;
   else
     error ("issorted: MODE must be \"ascending\", \"descending\", or \"either\"");
 
   return smode;
 }
 
 DEFUN (issorted, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} issorted (@var{a})\n\
 @deftypefnx {Built-in Function} {} issorted (@var{a}, @var{mode})\n\
 @deftypefnx {Built-in Function} {} issorted (@var{a}, \"rows\", @var{mode})\n\
 Return true if the array is sorted according to @var{mode}, which\n\
 may be either @qcode{\"ascending\"}, @qcode{\"descending\"}, or\n\
 @qcode{\"either\"}.  By default,  @var{mode} is @qcode{\"ascending\"}.  NaNs\n\
 are treated in the same manner as @code{sort}.\n\
 \n\
@@ -6462,17 +6488,17 @@ This function does not support sparse ma
 %!assert (issorted (flipud (sm), "rows", "either"))
 %!assert (issorted (sv, "either"))
 %!assert (issorted (fliplr (sv), "either"))
 %!assert (issorted (sv', "either"))
 %!assert (issorted (fliplr (sv)', "either"))
 */
 
 DEFUN (nth_element, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} nth_element (@var{x}, @var{n})\n\
 @deftypefnx {Built-in Function} {} nth_element (@var{x}, @var{n}, @var{dim})\n\
 Select the n-th smallest element of a vector, using the ordering defined by\n\
 @code{sort}.  In other words, the result is equivalent to\n\
 @code{sort(@var{x})(@var{n})}.\n\
 @var{n} can also be a contiguous range, either ascending @code{l:u}\n\
 or descending @code{u:-1:l}, in which case a range of elements is returned.\n\
 If @var{x} is an array, @code{nth_element} operates along the dimension\n\
@@ -6570,17 +6596,17 @@ do_accumarray_sum (const idx_vector& idx
     retval.idx_add (idx, vals);
   else
     error ("accumarray: dimensions mismatch");
 
   return retval;
 }
 
 DEFUN (__accumarray_sum__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __accumarray_sum__ (@var{idx}, @var{vals}, @var{n})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
   if (nargin >= 2 && nargin <= 3 && args(0).is_numeric_type ())
     {
@@ -6597,24 +6623,28 @@ Undocumented internal function.\n\
               Range r = vals.range_value ();
               if (r.inc () == 0)
                 vals = r.base ();
             }
 
           if (vals.is_single_type ())
             {
               if (vals.is_complex_type ())
-                retval = do_accumarray_sum (idx, vals.float_complex_array_value (), n);
+                retval = do_accumarray_sum (idx, 
+                                            vals.float_complex_array_value (),
+                                            n);
               else
                 retval = do_accumarray_sum (idx, vals.float_array_value (), n);
             }
           else if (vals.is_numeric_type () || vals.is_bool_type ())
             {
               if (vals.is_complex_type ())
-                retval = do_accumarray_sum (idx, vals.complex_array_value (), n);
+                retval = do_accumarray_sum (idx,
+                                            vals.complex_array_value (),
+                                            n);
               else
                 retval = do_accumarray_sum (idx, vals.array_value (), n);
             }
           else
             gripe_wrong_type_arg ("accumarray", vals);
         }
     }
   else
@@ -6671,30 +6701,33 @@ do_accumarray_minmax_fun (const octave_v
 
           switch (vals.builtin_type ())
             {
             case btyp_double:
               retval = do_accumarray_minmax (idx, vals.array_value (), n, ismin,
                                              zero.double_value ());
               break;
             case btyp_float:
-              retval = do_accumarray_minmax (idx, vals.float_array_value (), n, ismin,
-                                             zero.float_value ());
+              retval = do_accumarray_minmax (idx, vals.float_array_value (), n,
+                                             ismin, zero.float_value ());
               break;
             case btyp_complex:
-              retval = do_accumarray_minmax (idx, vals.complex_array_value (), n, ismin,
-                                             zero.complex_value ());
+              retval = do_accumarray_minmax (idx, vals.complex_array_value (),
+                                             n, ismin, zero.complex_value ());
               break;
             case btyp_float_complex:
-              retval = do_accumarray_minmax (idx, vals.float_complex_array_value (), n, ismin,
+              retval = do_accumarray_minmax (idx,
+                                             vals.float_complex_array_value (),
+                                             n, ismin,
                                              zero.float_complex_value ());
               break;
 #define MAKE_INT_BRANCH(X) \
             case btyp_ ## X: \
-              retval = do_accumarray_minmax (idx, vals.X ## _array_value (), n, ismin, \
+              retval = do_accumarray_minmax (idx, vals.X ## _array_value (), \
+                                             n, ismin, \
                                              zero.X ## _scalar_value ()); \
               break
 
             MAKE_INT_BRANCH (int8);
             MAKE_INT_BRANCH (int16);
             MAKE_INT_BRANCH (int32);
             MAKE_INT_BRANCH (int64);
             MAKE_INT_BRANCH (uint8);
@@ -6713,26 +6746,26 @@ do_accumarray_minmax_fun (const octave_v
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (__accumarray_min__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __accumarray_min__ (@var{idx}, @var{vals}, @var{zero}, @var{n})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   return do_accumarray_minmax_fun (args, true);
 }
 
 DEFUN (__accumarray_max__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __accumarray_max__ (@var{idx}, @var{vals}, @var{zero}, @var{n})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   return do_accumarray_minmax_fun (args, false);
 }
 
 template <class NDT>
@@ -6761,17 +6794,17 @@ do_accumdim_sum (const idx_vector& idx, 
     error ("accumdim: dimension mismatch");
 
   retval.idx_add_nd (idx, vals, dim);
 
   return retval;
 }
 
 DEFUN (__accumdim_sum__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __accumdim_sum__ (@var{idx}, @var{vals}, @var{dim}, @var{n})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
   if (nargin >= 2 && nargin <= 4 && args(0).is_numeric_type ())
     {
@@ -6786,24 +6819,28 @@ Undocumented internal function.\n\
 
       if (! error_state)
         {
           octave_value vals = args(1);
 
           if (vals.is_single_type ())
             {
               if (vals.is_complex_type ())
-                retval = do_accumdim_sum (idx, vals.float_complex_array_value (), dim, n);
+                retval = do_accumdim_sum (idx,
+                                          vals.float_complex_array_value (),
+                                          dim, n);
               else
-                retval = do_accumdim_sum (idx, vals.float_array_value (), dim, n);
+                retval = do_accumdim_sum (idx, vals.float_array_value (),
+                                          dim, n);
             }
           else if (vals.is_numeric_type () || vals.is_bool_type ())
             {
               if (vals.is_complex_type ())
-                retval = do_accumdim_sum (idx, vals.complex_array_value (), dim, n);
+                retval = do_accumdim_sum (idx, vals.complex_array_value (),
+                                          dim, n);
               else
                 retval = do_accumdim_sum (idx, vals.array_value (), dim, n);
             }
           else
             gripe_wrong_type_arg ("accumdim", vals);
         }
     }
   else
@@ -6872,17 +6909,17 @@ do_merge (const Array<bool>& mask,
   else if (tval.is_ ## INTX ## _type () && fval.is_ ## INTX ## _type ()) \
     { \
       retval = do_merge (mask, \
                          tval.INTX ## _array_value (), \
                          fval.INTX ## _array_value ()); \
     }
 
 DEFUN (merge, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} merge (@var{mask}, @var{tval}, @var{fval})\n\
 @deftypefnx {Built-in Function} {} ifelse (@var{mask}, @var{tval}, @var{fval})\n\
 Merge elements of @var{true_val} and @var{false_val}, depending on the\n\
 value of @var{mask}.  If @var{mask} is a logical scalar, the other two\n\
 arguments can be arbitrary values.  Otherwise, @var{mask} must be a logical\n\
 array, and @var{tval}, @var{fval} should be arrays of matching class, or\n\
 cell arrays.  In the scalar mask case, @var{tval} is returned if @var{mask}\n\
 is true, otherwise @var{fval} is returned.\n\
@@ -6985,29 +7022,31 @@ do_sparse_diff (const SparseT& array, oc
 {
   SparseT retval = array;
   if (dim == 1)
     {
       octave_idx_type k = retval.columns ();
       while (order > 0 && k > 0)
         {
           idx_vector col1 (':'), col2 (':'), sl1 (1, k), sl2 (0, k-1);
-          retval = SparseT (retval.index (col1, sl1)) - SparseT (retval.index (col2, sl2));
+          retval = SparseT (retval.index (col1, sl1))
+                 - SparseT (retval.index (col2, sl2));
           assert (retval.columns () == k-1);
           order--;
           k--;
         }
     }
   else
     {
       octave_idx_type k = retval.rows ();
       while (order > 0 && k > 0)
         {
           idx_vector col1 (':'), col2 (':'), sl1 (1, k), sl2 (0, k-1);
-          retval = SparseT (retval.index (sl1, col1)) - SparseT (retval.index (sl2, col2));
+          retval = SparseT (retval.index (sl1, col1))
+                 - SparseT (retval.index (sl2, col2));
           assert (retval.rows () == k-1);
           order--;
           k--;
         }
     }
 
   return retval;
 }
@@ -7072,17 +7111,18 @@ do_diff (const octave_value& array, octa
       else if (array.is_uint64_type ())
         retval = array.uint64_array_value ().diff (order, dim);
       else
         panic_impossible ();
     }
   else if (array.is_sparse_type ())
     {
       if (array.is_complex_type ())
-        retval = do_sparse_diff (array.sparse_complex_matrix_value (), order, dim);
+        retval = do_sparse_diff (array.sparse_complex_matrix_value (),
+                                 order, dim);
       else
         retval = do_sparse_diff (array.sparse_matrix_value (), order, dim);
     }
   else if (array.is_single_type ())
     {
       if (array.is_complex_type ())
         retval = array.float_complex_array_value ().diff (order, dim);
       else
@@ -7095,17 +7135,17 @@ do_diff (const octave_value& array, octa
       else
         retval = array.array_value ().diff (order, dim);
     }
 
   return retval;
 }
 
 DEFUN (diff, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} diff (@var{x})\n\
 @deftypefnx {Built-in Function} {} diff (@var{x}, @var{k})\n\
 @deftypefnx {Built-in Function} {} diff (@var{x}, @var{k}, @var{dim})\n\
 If @var{x} is a vector of length @math{n}, @code{diff (@var{x})} is the\n\
 vector of first differences\n\
 @tex\n\
  $x_2 - x_1, \\ldots{}, x_n - x_{n-1}$.\n\
 @end tex\n\
@@ -7212,17 +7252,17 @@ do_repelems (const Array<T>& src, const 
       std::fill_n (dest, k, src.checkelem (rep(0, i) - 1));
       dest += k;
     }
 
   return retval;
 }
 
 DEFUN (repelems, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} repelems (@var{x}, @var{r})\n\
 Construct a vector of repeated elements from @var{x}.  @var{r}\n\
 is a 2x@var{N} integer matrix specifying which elements to repeat and\n\
 how often to repeat each element.\n\
 \n\
 Entries in the first row, @var{r}(1,j), select an element to repeat.\n\
 The corresponding entry in the second row, @var{r}(2,j), specifies\n\
 the repeat count.  If @var{x} is a matrix then the columns of @var{x} are\n\
@@ -7306,35 +7346,35 @@ endfor\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (base64_encode, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{s} =} base64_encode (@var{x})\n\
 Encode a double matrix or array @var{x} into the base64 format string\n\
 @var{s}.\n\
 \n\
 @seealso{base64_decode}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
 
   if (nargin != 1)
     print_usage ();
-  else 
+  else
     {
-      if (! args(0).is_numeric_type ()) 
+      if (! args(0).is_numeric_type ())
         error ("base64_encode: encoding is supported only for numeric arrays");
-      else if (args(0).is_complex_type () 
-          || args(0).is_sparse_type ())
+      else if (args(0).is_complex_type ()
+               || args(0).is_sparse_type ())
         error ("base64_encode: encoding complex or sparse data is not supported");
       else if (args(0).is_integer_type ())
         {
 #define MAKE_INT_BRANCH(X)                                              \
           if (args(0).is_ ## X ## _type ())                             \
             {                                                           \
               const X##NDArray in = args(0).  X## _array_value ();      \
               size_t inlen =                                            \
@@ -7362,43 +7402,43 @@ Encode a double matrix or array @var{x} 
 
           else
             panic_impossible ();
         }
       else if (args(0).is_single_type ())
         {
           const Array<float> in = args(0).float_array_value ();
           size_t inlen;
-          inlen = in.numel () * sizeof (float) / sizeof (char); 
+          inlen = in.numel () * sizeof (float) / sizeof (char);
           const char*  inc;
-          inc = reinterpret_cast<const char*> (in.data ());  
+          inc = reinterpret_cast<const char*> (in.data ());
           char* out;
-          if (! error_state 
-              && octave_base64_encode (inc, inlen, &out))
-            {
-              retval(0) = octave_value (out);
-              ::free (out);
-            }
-        }                 
-      else
-        {
-          const Array<double> in = args(0).array_value ();
-          size_t inlen;
-          inlen = in.numel () * sizeof (double) / sizeof (char); 
-          const char*  inc;
-          inc = reinterpret_cast<const char*> (in.data ());   
-          char* out;
-          if (! error_state 
+          if (! error_state
               && octave_base64_encode (inc, inlen, &out))
             {
               retval(0) = octave_value (out);
               ::free (out);
             }
         }
-    }  
+      else
+        {
+          const Array<double> in = args(0).array_value ();
+          size_t inlen;
+          inlen = in.numel () * sizeof (double) / sizeof (char);
+          const char*  inc;
+          inc = reinterpret_cast<const char*> (in.data ());
+          char* out;
+          if (! error_state
+              && octave_base64_encode (inc, inlen, &out))
+            {
+              retval(0) = octave_value (out);
+              ::free (out);
+            }
+        }
+    }
   return retval;
 }
 
 /*
 %!assert (base64_encode (single (pi)), "2w9JQA==")
 %!assert (base64_encode (uint8 ([0 0 0])), "AAAA")
 %!assert (base64_encode (uint16 ([0 0 0])), "AAAAAAAA")
 %!assert (base64_encode (uint32 ([0 0 0])), "AAAAAAAAAAAAAAAA")
@@ -7408,17 +7448,17 @@ Encode a double matrix or array @var{x} 
 %!error base64_encode ()
 %!error base64_encode (1,2)
 %!error base64_encode ("A string")
 %!error base64_encode ({"A cell array"})
 %!error base64_encode (struct ())
 */
 
 DEFUN (base64_decode, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{x} =} base64_decode (@var{s})\n\
 @deftypefnx {Built-in Function} {@var{x} =} base64_decode (@var{s}, @var{dims})\n\
 Decode the double matrix or array @var{x} from the base64 encoded string\n\
 @var{s}.  The optional input parameter @var{dims} should be a vector\n\
 containing the dimensions of the decoded array.\n\
 @seealso{base64_encode}\n\
 @end deftypefn")
 {
@@ -7450,29 +7490,29 @@ containing the dimensions of the decoded
       if (! error_state)
         {
           Array<double> res = octave_base64_decode (str);
 
           if (nargin > 1)
             res = res.reshape (dims);
 
           retval = res;
-        }        
+        }
     }
 
-  return retval; 
+  return retval;
 }
 
 /*
 %!assert (base64_decode (base64_encode (pi)), pi)
 %!
-%!test 
+%!test
 %! in   = randn (10);
 %! outv = base64_decode (base64_encode (in));
-%! outm = base64_decode (base64_encode (in), size (in)); 
+%! outm = base64_decode (base64_encode (in), size (in));
 %! assert (outv, in(:).');
 %! assert (outm, in);
 
 %!error base64_decode ()
 %!error base64_decode (1,2,3)
 %!error base64_decode (1, "this is not a valid set of dimensions")
 %!error <input was not valid base64> base64_decode (1)
 %!error <input was not valid base64> base64_decode ("AQ=")
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -355,18 +355,17 @@ bp_table::do_remove_breakpoint_1 (octave
                                   const bp_table::intmap& line)
 {
   int retval = 0;
 
   std::string file = fcn->fcn_file_name ();
 
   tree_statement_list *cmds = fcn->body ();
 
-  // FIXME -- move the operation on cmds to the
-  // tree_statement_list class?
+  // FIXME: move the operation on cmds to the tree_statement_list class?
 
   if (cmds)
     {
       octave_value_list results = cmds->list_breakpoints ();
 
       if (results.length () > 0)
         {
           octave_idx_type len = line.size ();
@@ -552,18 +551,18 @@ bp_table::do_get_breakpoint_list (const 
           || do_find_bkpt_list (fname_list, *it) != "")
         {
           octave_user_code *f = get_user_code (*it);
 
           if (f)
             {
               tree_statement_list *cmds = f->body ();
 
-              // FIXME -- move the operation on cmds to the
-              // tree_statement_list class?
+              // FIXME: move the operation on cmds to the
+              //        tree_statement_list class?
               if (cmds)
                 {
                   octave_value_list bkpts = cmds->list_breakpoints ();
                   octave_idx_type len = bkpts.length ();
 
                   if (len > 0)
                     {
                       bp_table::intmap bkpts_vec;
@@ -602,17 +601,17 @@ intmap_to_ov (const bp_table::intmap& li
     }
 
   retval.resize (dim_vector (1, idx));
 
   return retval;
 }
 
 DEFUN (dbstop, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{rline} =} dbstop (\"@var{func}\")\n\
 @deftypefnx {Built-in Function} {@var{rline} =} dbstop (\"@var{func}\", @var{line})\n\
 @deftypefnx {Built-in Function} {@var{rline} =} dbstop (\"@var{func}\", @var{line1}, @var{line2}, @dots{})\n\
 Set a breakpoint in function @var{func}.\n\
 \n\
 Arguments are\n\
 \n\
 @table @var\n\
@@ -647,17 +646,17 @@ next executable line.\n\
 
   if (! error_state)
     retval = bp_table::add_breakpoint (symbol_name, lines);
 
   return intmap_to_ov (retval);
 }
 
 DEFUN (dbclear, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} dbclear (\"@var{func}\")\n\
 @deftypefnx {Built-in Function} {} dbclear (\"@var{func}\", @var{line}, @dots{})\n\
 @deftypefnx {Built-in Function} {} dbclear (@var{line}, @dots{})\n\
 Delete a breakpoint in the function @var{func}.\n\
 \n\
 Arguments are\n\
 \n\
 @table @var\n\
@@ -686,17 +685,17 @@ If the requested line is not a breakpoin
 
   if (! error_state)
     bp_table::remove_breakpoint (symbol_name, lines);
 
   return retval;
 }
 
 DEFUN (dbstatus, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} dbstatus ()\n\
 @deftypefnx {Built-in Function} {@var{brk_list} =} dbstatus ()\n\
 @deftypefnx {Built-in Function} {@var{brk_list} =} dbstatus (\"@var{func}\")\n\
 Report the location of active breakpoints.\n\
 \n\
 When called with no input or output arguments, print the list of\n\
 all functions with breakpoints and the line numbers where those\n\
 breakpoints are set.\n\
@@ -740,24 +739,24 @@ A line number, or vector of line numbers
           fcn_list(0) = symbol_name;
           bp_list = bp_table::get_breakpoint_list (fcn_list);
         }
       else
         gripe_wrong_type_arg ("dbstatus", args(0));
     }
   else
     {
-       octave_user_code *dbg_fcn = get_user_code ();
-       if (dbg_fcn)
-         {
-           symbol_name = dbg_fcn->name ();
-           fcn_list(0) = symbol_name;
-         }
+      octave_user_code *dbg_fcn = get_user_code ();
+      if (dbg_fcn)
+        {
+          symbol_name = dbg_fcn->name ();
+          fcn_list(0) = symbol_name;
+        }
 
-       bp_list = bp_table::get_breakpoint_list (fcn_list);
+      bp_list = bp_table::get_breakpoint_list (fcn_list);
     }
 
   if (nargout == 0)
     {
       // Print out the breakpoint information.
 
       for (bp_table::fname_line_map_iterator it = bp_list.begin ();
            it != bp_list.end (); it++)
@@ -802,17 +801,17 @@ A line number, or vector of line numbers
       retval.assign ("file", file);
       retval.assign ("line", line);
 
       return octave_value (retval);
     }
 }
 
 DEFUN (dbwhere, , ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Command} {} dbwhere\n\
 In debugging mode, report the current file and line number where\n\
 execution is stopped.\n\
 @seealso{dbstatus, dbcont, dbstep, dbup}\n\
 @end deftypefn")
 {
   octave_value retval;
 
@@ -899,17 +898,17 @@ do_dbtype (std::ostream& os, const std::
     }
   else
     os << "dbtype: unknown function " << name << "\n";
 
   os.flush ();
 }
 
 DEFUN (dbtype, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Command} {} dbtype\n\
 @deftypefnx {Command} {} dbtype @var{lineno}\n\
 @deftypefnx {Command} {} dbtype @var{startl:endl}\n\
 @deftypefnx {Command} {} dbtype @var{startl:end}\n\
 @deftypefnx {Command} {} dbtype @var{func}\n\
 @deftypefnx {Command} {} dbtype @var{func} @var{lineno}\n\
 @deftypefnx {Command} {} dbtype @var{func} @var{startl:endl}\n\
 @deftypefnx {Command} {} dbtype @var{func} @var{startl:end}\n\
@@ -947,17 +946,17 @@ numbers.\n\
 
         case 1: // (dbtype func) || (dbtype start:end)
           {
             std::string arg = argv[1];
 
             size_t ind = arg.find (':');
 
             if (ind != std::string::npos)  // (dbtype start:end)
-              {  
+              {
                 dbg_fcn = get_user_code ();
 
                 if (dbg_fcn)
                   {
                     std::string start_str = arg.substr (0, ind);
                     std::string end_str = arg.substr (ind + 1);
 
                     int start, end;
@@ -1032,17 +1031,17 @@ numbers.\n\
           error ("dbtype: expecting zero, one, or two arguments\n");
         }
     }
 
   return retval;
 }
 
 DEFUN (dblist, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Command} {} dblist\n\
 @deftypefnx {Command} {} dblist @var{n}\n\
 In debugging mode, list @var{n} lines of the function being debugged\n\
 centered around the current line to be executed.  If unspecified @var{n}\n\
 defaults to 10 (+/- 5 lines)\n\
 @seealso{dbwhere, dbtype}\n\
 @end deftypefn")
 {
@@ -1221,17 +1220,17 @@ do_dbstack (const octave_value_list& arg
 
 void
 show_octave_dbstack (void)
 {
   do_dbstack (octave_value_list (), 0, std::cerr);
 }
 
 DEFUN (dbstack, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Command} {} dbstack\n\
 @deftypefnx {Command} {} dbstack @var{n}\n\
 @deftypefnx {Command} {} dbstack @var{-completenames}\n\
 @deftypefnx {Built-in Function} {[@var{stack}, @var{idx}] =} dbstack (@dots{})\n\
 Display or return current debugging function stack information.\n\
 With optional argument @var{n}, omit the @var{n} innermost stack frames.\n\
 \n\
 Although accepted, the argument @var{-completenames} is silently ignored.\n\
@@ -1294,49 +1293,49 @@ do_dbupdown (const octave_value_list& ar
         n = -n;
 
       if (! octave_call_stack::goto_frame_relative (n, true))
         error ("%s: invalid stack frame", who.c_str ());
     }
 }
 
 DEFUN (dbup, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} dbup\n\
 @deftypefnx {Built-in Function} {} dbup (@var{n})\n\
 In debugging mode, move up the execution stack @var{n} frames.\n\
 If @var{n} is omitted, move up one frame.\n\
 @seealso{dbstack, dbdown}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   do_dbupdown (args, "dbup");
 
   return retval;
 }
 
 DEFUN (dbdown, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} dbdown\n\
 @deftypefnx {Built-in Function} {} dbdown (@var{n})\n\
 In debugging mode, move down the execution stack @var{n} frames.\n\
 If @var{n} is omitted, move down one frame.\n\
 @seealso{dbstack, dbup}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   do_dbupdown (args, "dbdown");
 
   return retval;
 }
 
 DEFUN (dbstep, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Command} {} dbstep\n\
 @deftypefnx {Command} {} dbstep @var{n}\n\
 @deftypefnx {Command} {} dbstep in\n\
 @deftypefnx {Command} {} dbstep out\n\
 @deftypefnx {Command} {} dbnext @dots{}\n\
 In debugging mode, execute the next @var{n} lines of code.\n\
 If @var{n} is omitted, execute the next single line of code.\n\
 If the next line of code is itself defined in terms of an m-file remain in\n\
@@ -1405,17 +1404,17 @@ execution to continue until the current 
     error ("dbstep: can only be called in debug mode");
 
   return octave_value_list ();
 }
 
 DEFALIAS (dbnext, dbstep);
 
 DEFUN (dbcont, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Command} {} dbcont\n\
 Leave command-line debugging mode and continue code execution normally.\n\
 @seealso{dbstep, dbquit}\n\
 @end deftypefn")
 {
   if (Vdebugging)
     {
       if (args.length () == 0)
@@ -1429,17 +1428,17 @@ Leave command-line debugging mode and co
     }
   else
     error ("dbcont: can only be called in debug mode");
 
   return octave_value_list ();
 }
 
 DEFUN (dbquit, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Command} {} dbquit\n\
 Quit debugging mode immediately without further code execution and\n\
 return to the Octave prompt.\n\
 @seealso{dbcont, dbstep}\n\
 @end deftypefn")
 {
   if (Vdebugging)
     {
@@ -1456,17 +1455,17 @@ return to the Octave prompt.\n\
     }
   else
     error ("dbquit: can only be called in debug mode");
 
   return octave_value_list ();
 }
 
 DEFUN (isdebugmode, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isdebugmode ()\n\
 Return true if in debugging mode, otherwise false.\n\
 @seealso{dbwhere, dbstack, dbstatus}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 0)
diff --git a/libinterp/corefcn/defaults.cc b/libinterp/corefcn/defaults.cc
--- a/libinterp/corefcn/defaults.cc
+++ b/libinterp/corefcn/defaults.cc
@@ -247,24 +247,24 @@ set_exec_path (const std::string& path_a
 {
   std::string tpath = path_arg;
 
   if (tpath.empty ())
     tpath = octave_env::getenv ("OCTAVE_EXEC_PATH");
 
   if (tpath.empty ())
     tpath = Vlocal_ver_arch_lib_dir + dir_path::path_sep_str ()
-      + Vlocal_api_arch_lib_dir + dir_path::path_sep_str ()
-      + Vlocal_arch_lib_dir + dir_path::path_sep_str ()
-      + Varch_lib_dir + dir_path::path_sep_str ()
-      + Vbin_dir;
+            + Vlocal_api_arch_lib_dir + dir_path::path_sep_str ()
+            + Vlocal_arch_lib_dir + dir_path::path_sep_str ()
+            + Varch_lib_dir + dir_path::path_sep_str ()
+            + Vbin_dir;
 
   VEXEC_PATH = tpath;
 
-  // FIXME -- should we really be modifying PATH in the environment?
+  // FIXME: should we really be modifying PATH in the environment?
   // The way things are now, Octave will ignore directories set in the
   // PATH with calls like
   //
   //   setenv ("PATH", "/my/path");
   //
   // To fix this, I think Octave should be searching the combination of
   // PATH and EXEC_PATH for programs that it executes instead of setting
   // the PATH in the environment and relying on the shell to do the
@@ -366,17 +366,18 @@ set_default_editor (void)
 
 static void
 set_local_site_defaults_file (void)
 {
   std::string lsf = octave_env::getenv ("OCTAVE_SITE_INITFILE");
 
   if (lsf.empty ())
     {
-      Vlocal_site_defaults_file = subst_octave_home (OCTAVE_LOCALSTARTUPFILEDIR);
+      Vlocal_site_defaults_file
+        = subst_octave_home (OCTAVE_LOCALSTARTUPFILEDIR);
       Vlocal_site_defaults_file.append ("/octaverc");
     }
   else
     Vlocal_site_defaults_file = lsf;
 }
 
 static void
 set_site_defaults_file (void)
@@ -461,17 +462,17 @@ install_defaults (void)
   set_local_site_defaults_file ();
 
   set_site_defaults_file ();
 
   set_built_in_docstrings_file ();
 }
 
 DEFUN (EDITOR, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} EDITOR ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} EDITOR (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} EDITOR (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the editor to\n\
 use with the @code{edit_history} command.  The default value is taken from\n\
 the environment variable @w{@env{EDITOR}} when Octave starts.  If the\n\
 environment variable is not initialized, @w{@env{EDITOR}} will be set to\n\
 @qcode{\"emacs\"}.\n\
@@ -494,17 +495,17 @@ The original variable value is restored 
 %! assert (EDITOR (), "X");
 %! EDITOR (orig_val);
 %! assert (EDITOR (), orig_val);
 
 %!error (EDITOR (1, 2))
 */
 
 DEFUN (EXEC_PATH, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} EXEC_PATH ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} EXEC_PATH (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} EXEC_PATH (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies a colon separated\n\
 list of directories to append to the shell PATH when executing external\n\
 programs.  The initial value of is taken from the environment variable\n\
 @w{@env{OCTAVE_EXEC_PATH}}, but that value can be overridden by\n\
 the command line argument @option{--exec-path PATH}.\n\
@@ -532,17 +533,17 @@ The original variable value is restored 
 %! assert (EXEC_PATH (), "X");
 %! EXEC_PATH (orig_val);
 %! assert (EXEC_PATH (), orig_val);
 
 %!error (EXEC_PATH (1, 2))
 */
 
 DEFUN (IMAGE_PATH, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} IMAGE_PATH ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} IMAGE_PATH (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} IMAGE_PATH (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies a colon separated\n\
 list of directories in which to search for image files.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.  \n\
@@ -562,17 +563,17 @@ The original variable value is restored 
 %! assert (IMAGE_PATH (), "X");
 %! IMAGE_PATH (orig_val);
 %! assert (IMAGE_PATH (), orig_val);
 
 %!error (IMAGE_PATH (1, 2))
 */
 
 DEFUN (OCTAVE_HOME, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} OCTAVE_HOME ()\n\
 Return the name of the top-level Octave installation directory.\n\
 \n\
 @seealso{EXEC_PATH, IMAGE_PATH}\n\
 @end deftypefn")
 {
   octave_value retval;
 
@@ -585,17 +586,17 @@ Return the name of the top-level Octave 
 }
 
 /*
 %!assert (ischar (OCTAVE_HOME ()))
 %!error OCTAVE_HOME (1)
 */
 
 DEFUNX ("OCTAVE_VERSION", FOCTAVE_VERSION, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} OCTAVE_VERSION ()\n\
 Return the version number of Octave, as a string.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
diff --git a/libinterp/corefcn/defaults.in.h b/libinterp/corefcn/defaults.in.h
--- a/libinterp/corefcn/defaults.in.h
+++ b/libinterp/corefcn/defaults.in.h
@@ -220,12 +220,15 @@ extern OCTINTERP_API std::string Vbuilt_
 
 // Name of the FFTW wisdom program.
 extern OCTINTERP_API std::string Vfftw_wisdom_program;
 
 extern OCTINTERP_API std::string subst_octave_home (const std::string&);
 
 extern OCTINTERP_API void install_defaults (void);
 
-extern OCTINTERP_API void set_exec_path (const std::string& path = std::string ());
-extern OCTINTERP_API void set_image_path (const std::string& path = std::string ());
+extern OCTINTERP_API void
+set_exec_path (const std::string& path = std::string ());
+
+extern OCTINTERP_API void
+set_image_path (const std::string& path = std::string ());
 
 #endif
diff --git a/libinterp/corefcn/defun-int.h b/libinterp/corefcn/defun-int.h
--- a/libinterp/corefcn/defun-int.h
+++ b/libinterp/corefcn/defun-int.h
@@ -30,17 +30,18 @@ along with Octave; see the file COPYING.
 #include "symtab.h"
 #include "version.h"
 
 class octave_value;
 
 extern OCTINTERP_API void print_usage (void);
 extern OCTINTERP_API void print_usage (const std::string&);
 
-extern OCTINTERP_API void check_version (const std::string& version, const std::string& fcn);
+extern OCTINTERP_API void check_version (const std::string& version,
+                                         const std::string& fcn);
 
 extern OCTINTERP_API void
 install_builtin_function (octave_builtin::fcn f, const std::string& name,
                           const std::string& file, const std::string& doc,
                           bool can_hide_function = true);
 
 extern OCTINTERP_API void
 install_dld_function (octave_dld_function::fcn f, const std::string& name,
@@ -54,18 +55,18 @@ install_mex_function (void *fptr, bool f
 extern OCTINTERP_API void
 alias_builtin (const std::string& alias, const std::string& name);
 
 // Gets the shlib of the currently executing DLD function, if any.
 extern OCTINTERP_API octave_shlib
 get_current_shlib (void);
 
 // This is a convenience class that calls the above function automatically at
-// construction time. When deriving new classes, you can either use it as a field
-// or as a parent (with multiple inheritance).
+// construction time. When deriving new classes, you can either use it as a
+// field or as a parent (with multiple inheritance).
 
 class octave_auto_shlib : public octave_shlib
 {
 public:
   octave_auto_shlib (void)
     : octave_shlib (get_current_shlib ()) { }
   octave_auto_shlib (const octave_shlib& shl)
     : octave_shlib (shl) { }
@@ -85,17 +86,18 @@ defun_isargout (int, int, bool *);
   DECLARE_FUNX (F ## name, args_name, nargout_name)
 
 // Define the code that will be used to insert the new function into
 // the symbol table.  We look for this name instead of the actual
 // function so that we can easily install the doc std::string too.
 
 typedef bool (*octave_dld_fcn_installer) (const octave_shlib&, bool relative);
 
-typedef octave_function * (*octave_dld_fcn_getter) (const octave_shlib&, bool relative);
+typedef octave_function * 
+  (*octave_dld_fcn_getter) (const octave_shlib&, bool relative);
 
 #define DEFINE_FUN_INSTALLER_FUN(name, doc) \
   DEFINE_FUNX_INSTALLER_FUN(#name, F ## name, G ## name, doc)
 
 #define DEFINE_FUNX_INSTALLER_FUN(name, fname, gname, doc) \
   extern "C" \
   OCTAVE_EXPORT \
   octave_function * \
diff --git a/libinterp/corefcn/defun.cc b/libinterp/corefcn/defun.cc
--- a/libinterp/corefcn/defun.cc
+++ b/libinterp/corefcn/defun.cc
@@ -128,32 +128,35 @@ get_current_shlib (void)
 {
   octave_shlib retval;
 
   octave_function *curr_fcn = octave_call_stack::current ();
   if (curr_fcn)
     {
       if (curr_fcn->is_dld_function ())
         {
-          octave_dld_function *dld = dynamic_cast<octave_dld_function *> (curr_fcn);
+          octave_dld_function *dld
+            = dynamic_cast<octave_dld_function *> (curr_fcn);
           retval = dld->get_shlib ();
         }
       else if (curr_fcn->is_mex_function ())
         {
-          octave_mex_function *mex = dynamic_cast<octave_mex_function *> (curr_fcn);
+          octave_mex_function *mex
+            = dynamic_cast<octave_mex_function *> (curr_fcn);
           retval = mex->get_shlib ();
         }
     }
 
   return retval;
 }
 
 bool defun_isargout (int nargout, int iout)
 {
-  const std::list<octave_lvalue> *lvalue_list = octave_builtin::curr_lvalue_list;
+  const std::list<octave_lvalue> *lvalue_list
+    = octave_builtin::curr_lvalue_list;
   if (iout >= std::max (nargout, 1))
     return false;
   else if (lvalue_list)
     {
       int k = 0;
       for (std::list<octave_lvalue>::const_iterator p = lvalue_list->begin ();
            p != lvalue_list->end (); p++)
         {
@@ -167,17 +170,19 @@ bool defun_isargout (int nargout, int io
       return true;
     }
   else
     return true;
 }
 
 void defun_isargout (int nargout, int nout, bool *isargout)
 {
-  const std::list<octave_lvalue> *lvalue_list = octave_builtin::curr_lvalue_list;
+  const std::list<octave_lvalue> *lvalue_list
+    = octave_builtin::curr_lvalue_list;
+
   if (lvalue_list)
     {
       int k = 0;
       for (std::list<octave_lvalue>::const_iterator p = lvalue_list->begin ();
            p != lvalue_list->end () && k < nout; p++)
         {
           if (p->is_black_hole ())
             isargout[k++] = false;
diff --git a/libinterp/corefcn/det.cc b/libinterp/corefcn/det.cc
--- a/libinterp/corefcn/det.cc
+++ b/libinterp/corefcn/det.cc
@@ -43,17 +43,17 @@ along with Octave; see the file COPYING.
 #include "ov-flt-cx-diag.h"
 #include "ov-perm.h"
 
 #define MAYBE_CAST(VAR, CLASS) \
   const CLASS *VAR = arg.type_id () == CLASS::static_type_id () ? \
    dynamic_cast<const CLASS *> (&arg.get_rep ()) : 0
 
 DEFUN (det, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} det (@var{A})\n\
 @deftypefnx {Built-in Function} {[@var{d}, @var{rcond}] =} det (@var{A})\n\
 Compute the determinant of @var{A}.\n\
 \n\
 Return an estimate of the reciprocal condition number if requested.\n\
 \n\
 Routines from @sc{lapack} are used for full matrices and code from\n\
 @sc{umfpack} is used for sparse matrices.\n\
@@ -101,32 +101,35 @@ For that, use any of the condition numbe
   bool isfloat = arg.is_single_type ();
 
   if (arg.is_diag_matrix ())
     {
       if (arg.is_complex_type ())
         {
           if (isfloat)
             {
-              retval(0) = arg.float_complex_diag_matrix_value ().determinant ().value ();
+              retval(0) = arg.float_complex_diag_matrix_value ()
+                          .determinant ().value ();
               if (nargout > 1)
                 retval(1) = arg.float_complex_diag_matrix_value ().rcond ();
             }
           else
             {
-              retval(0) = arg.complex_diag_matrix_value ().determinant ().value ();
+              retval(0) = arg.complex_diag_matrix_value ()
+                          .determinant ().value ();
               if (nargout > 1)
                 retval(1) = arg.complex_diag_matrix_value ().rcond ();
             }
         }
       else
         {
           if (isfloat)
             {
-              retval(0) = arg.float_diag_matrix_value ().determinant ().value ();
+              retval(0) = arg.float_diag_matrix_value ()
+                          .determinant ().value ();
               if (nargout > 1)
                 retval(1) = arg.float_diag_matrix_value ().rcond ();
             }
           else
             {
               retval(0) = arg.diag_matrix_value ().determinant ().value ();
               if (nargout > 1)
                 retval(1) = arg.diag_matrix_value ().rcond ();
@@ -195,17 +198,18 @@ For that, use any of the condition numbe
                 }
             }
           else
             {
               Matrix m = arg.matrix_value ();
               if (! error_state)
                 {
                   MAYBE_CAST (rep, octave_matrix);
-                  MatrixType mtype = rep ? rep -> matrix_type () : MatrixType ();
+                  MatrixType mtype = rep ? rep -> matrix_type ()
+                                         : MatrixType ();
                   DET det = m.determinant (mtype, info, rcond);
                   retval(1) = rcond;
                   retval(0) = info == -1 ? 0.0 : det.value ();
                   if (rep) rep->matrix_type (mtype);
                 }
             }
         }
       else if (arg.is_complex_type ())
@@ -225,17 +229,18 @@ For that, use any of the condition numbe
                 }
             }
           else
             {
               ComplexMatrix m = arg.complex_matrix_value ();
               if (! error_state)
                 {
                   MAYBE_CAST (rep, octave_complex_matrix);
-                  MatrixType mtype = rep ? rep -> matrix_type () : MatrixType ();
+                  MatrixType mtype = rep ? rep -> matrix_type () 
+                                         : MatrixType ();
                   ComplexDET det = m.determinant (mtype, info, rcond);
                   retval(1) = rcond;
                   retval(0) = info == -1 ? Complex (0.0) : det.value ();
                   if (rep) rep->matrix_type (mtype);
                 }
             }
         }
       else
diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -74,31 +74,31 @@ octave_change_to_directory (const std::s
   std::string xdir = file_ops::tilde_expand (newdir);
 
   int cd_ok = octave_env::chdir (xdir);
 
   if (cd_ok)
     {
       Vlast_chdir_time.stamp ();
 
-      // FIXME -- should these actions be handled as a list of functions
+      // FIXME: should these actions be handled as a list of functions
       // to call so users can add their own chdir handlers?
 
       load_path::update ();
 
       octave_link::change_directory (octave_env::get_current_directory ());
     }
   else
     error ("%s: %s", newdir.c_str (), gnulib::strerror (errno));
 
   return cd_ok;
 }
 
 DEFUN (cd, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Command} {} cd @var{dir}\n\
 @deftypefnx {Command} {} cd\n\
 @deftypefnx {Built-in Function} {@var{old_dir} =} cd @var{dir}\n\
 @deftypefnx {Command} {} chdir @dots{}\n\
 Change the current working directory to @var{dir}.\n\
 \n\
 If @var{dir} is omitted, the current directory is changed to the user's home\n\
 directory (@qcode{\"~\"}).\n\
@@ -150,28 +150,28 @@ present working directory rather than ch
     }
 
   return retval;
 }
 
 DEFALIAS (chdir, cd);
 
 DEFUN (pwd, , ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} pwd ()\n\
 @deftypefnx {Built-in Function} {@var{dir} =} pwd ()\n\
 Return the current working directory.\n\
 @seealso{cd, dir, ls, mkdir, rmdir}\n\
 @end deftypefn")
 {
   return octave_value (octave_env::get_current_directory ());
 }
 
 DEFUN (readdir, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{files} =} readdir (@var{dir})\n\
 @deftypefnx {Built-in Function} {[@var{files}, @var{err}, @var{msg}] =} readdir (@var{dir})\n\
 Return the names of files in the directory @var{dir} as a cell array of\n\
 strings.\n\
 \n\
 If an error occurs, return an empty cell array in @var{files}.\n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
@@ -212,17 +212,17 @@ system-dependent error message.\n\
 
   return retval;
 }
 
 // FIXME: should maybe also allow second arg to specify mode?
 //        OTOH, that might cause trouble with compatibility later...
 
 DEFUNX ("mkdir", Fmkdir, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} mkdir @var{dir}\n\
 @deftypefnx {Built-in Function} {} mkdir (@var{parent}, @var{dir})\n\
 @deftypefnx {Built-in Function} {[@var{status}, @var{msg}, @var{msgid}] =} mkdir (@dots{})\n\
 Create a directory named @var{dir} in the directory @var{parent}.\n\
 \n\
 If no @var{parent} directory is specified the present working directory is\n\
 used.\n\
 \n\
@@ -299,17 +299,17 @@ identifier.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("rmdir", Frmdir, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} rmdir @var{dir}\n\
 @deftypefnx {Built-in Function} {} rmdir (@var{dir}, \"s\")\n\
 @deftypefnx {Built-in Function} {[@var{status}, @var{msg}, @var{msgid}] =} rmdir (@dots{})\n\
 Remove the directory named @var{dir}.\n\
 \n\
 If successful, @var{status} is 1, and @var{msg}, @var{msgid} are empty\n\
 character strings ("").  Otherwise, @var{status} is 0, @var{msg} contains a\n\
 system-dependent error message, and @var{msgid} contains a unique message\n\
@@ -374,17 +374,17 @@ recursively remove all subdirectories as
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("link", Flink, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} link @var{old} @var{new}\n\
 @deftypefnx {Built-in Function} {[@var{err}, @var{msg}] =} link (@var{old}, @var{new})\n\
 Create a new link (also known as a hard link) to an existing file.\n\
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
 system-dependent error message.\n\
 @seealso{symlink, unlink, readlink, lstat}\n\
@@ -421,17 +421,17 @@ system-dependent error message.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("symlink", Fsymlink, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} symlink @var{old} @var{new}\n\
 @deftypefnx {Built-in Function} {[@var{err}, @var{msg}] =} symlink (@var{old}, @var{new})\n\
 Create a symbolic link @var{new} which contains the string @var{old}.\n\
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
 system-dependent error message.\n\
 @seealso{link, unlink, readlink, lstat}\n\
@@ -468,17 +468,17 @@ system-dependent error message.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("readlink", Freadlink, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} readlink @var{symlink}\n\
 @deftypefnx {Built-in Function} {[@var{result}, @var{err}, @var{msg}] =} readlink (@var{symlink})\n\
 Read the value of the symbolic link @var{symlink}.\n\
 \n\
 If successful, @var{result} contains the contents of the symbolic link\n\
 @var{symlink}, @var{err} is 0, and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a system-dependent\n\
 error message.\n\
@@ -512,17 +512,17 @@ error message.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("rename", Frename, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} rename @var{old} @var{new}\n\
 @deftypefnx {Built-in Function} {[@var{err}, @var{msg}] =} rename (@var{old}, @var{new})\n\
 Change the name of file @var{old} to @var{new}.\n\
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
 system-dependent error message.\n\
 @seealso{movefile, copyfile, ls, dir}\n\
@@ -559,17 +559,17 @@ system-dependent error message.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (glob, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} glob (@var{pattern})\n\
 Given an array of pattern strings (as a char array or a cell array) in\n\
 @var{pattern}, return a cell array of file names that match any of\n\
 them, or an empty cell array if no patterns match.  The pattern strings are\n\
 interpreted as filename globbing patterns (as they are used by Unix shells).\n\
 Within a pattern\n\
 \n\
 @table @code\n\
@@ -660,17 +660,17 @@ glob (\"file[12]\")\n\
 %! cd (cwd);
 %! rmdir (tmpdir);
 %! assert (result1, {"file1"; "myfile1"});
 %! assert (result2, {"myfile1"});
 %! assert (result3, {"file1"; "file2"});
 */
 
 DEFUNX ("fnmatch", Ffnmatch, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fnmatch (@var{pattern}, @var{string})\n\
 Return true or false for each element of @var{string} that matches any of\n\
 the elements of the string array @var{pattern}, using the rules of\n\
 filename pattern matching.  For example:\n\
 \n\
 @example\n\
 @group\n\
 fnmatch (\"a*b\", @{\"ab\"; \"axyzb\"; \"xyzab\"@})\n\
@@ -698,17 +698,17 @@ fnmatch (\"a*b\", @{\"ab\"; \"axyzb\"; \
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (filesep, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} filesep ()\n\
 @deftypefnx {Built-in Function} {} filesep (\"all\")\n\
 Return the system-dependent character used to separate directory names.\n\
 \n\
 If @qcode{\"all\"} is given, the function returns all valid file separators\n\
 in the form of a string.  The list of file separators is system-dependent.\n\
 It is @samp{/} (forward slash) under UNIX or @w{Mac OS X}, @samp{/} and\n\
 @samp{\\} (forward and backward slashes) under Windows.\n\
@@ -735,17 +735,17 @@ It is @samp{/} (forward slash) under UNI
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (pathsep, args, nargout,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} pathsep ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} pathsep (@var{new_val})\n\
 Query or set the character used to separate directories in a path.\n\
 @seealso{filesep}\n\
 @end deftypefn")
 {
   octave_value retval;
 
@@ -780,17 +780,17 @@ Query or set the character used to separ
     }
   else if (nargin > 1)
     print_usage ();
 
   return retval;
 }
 
 DEFUN (confirm_recursive_rmdir, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} confirm_recursive_rmdir ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} confirm_recursive_rmdir (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} confirm_recursive_rmdir (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave\n\
 will ask for confirmation before recursively removing a directory tree.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.  \n\
diff --git a/libinterp/corefcn/display.cc b/libinterp/corefcn/display.cc
--- a/libinterp/corefcn/display.cc
+++ b/libinterp/corefcn/display.cc
@@ -48,17 +48,17 @@ size_t DisplayBitsPerPixel (CGDirectDisp
 {
   CGDisplayModeRef mode = CGDisplayCopyDisplayMode (display);
   CFStringRef pixelEncoding = CGDisplayModeCopyPixelEncoding (mode);
 
   if (CFStringCompare (pixelEncoding, CFSTR (IO32BitDirectPixels), 0) == 0)
     return 32;
   else if (CFStringCompare (pixelEncoding, CFSTR (IO16BitDirectPixels), 0) == 0)
     return 16;
-  else 
+  else
     return 8;
 }
 #endif
 
 void
 display_info::init (bool query)
 {
   if (query)
diff --git a/libinterp/corefcn/dlmread.cc b/libinterp/corefcn/dlmread.cc
--- a/libinterp/corefcn/dlmread.cc
+++ b/libinterp/corefcn/dlmread.cc
@@ -36,17 +36,18 @@ along with Octave; see the file COPYING.
 #include "lo-ieee.h"
 
 #include "defun.h"
 #include "oct-stream.h"
 #include "error.h"
 #include "oct-obj.h"
 #include "utils.h"
 
-static const octave_idx_type idx_max =  std::numeric_limits<octave_idx_type>::max ();
+static const octave_idx_type idx_max =
+  std::numeric_limits<octave_idx_type>::max ();
 
 static bool
 read_cell_spec (std::istream& is, octave_idx_type& row, octave_idx_type& col)
 {
   bool stat = false;
 
   if (is.peek () == std::istream::traits_type::eof ())
     stat = true;
@@ -151,17 +152,17 @@ parse_range_spec (const octave_value& ra
     }
   else
     stat = false;
 
   return stat;
 }
 
 DEFUN (dlmread, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{data} =} dlmread (@var{file})\n\
 @deftypefnx {Built-in Function} {@var{data} =} dlmread (@var{file}, @var{sep})\n\
 @deftypefnx {Built-in Function} {@var{data} =} dlmread (@var{file}, @var{sep}, @var{r0}, @var{c0})\n\
 @deftypefnx {Built-in Function} {@var{data} =} dlmread (@var{file}, @var{sep}, @var{range})\n\
 @deftypefnx {Built-in Function} {@var{data} =} dlmread (@dots{}, \"emptyvalue\", @var{EMPTYVAL})\n\
 Read the matrix @var{data} from a text file.  If not defined the separator\n\
 between fields is determined from the file itself.  Otherwise the\n\
 separation character is defined by @var{sep}.\n\
@@ -191,17 +192,17 @@ fill empty fields.  The default is zero.
 
   double empty_value = 0.0;
 
   if (nargin > 2 && args(nargin-2).is_string ()
       && args(nargin-2).string_value () == "emptyvalue")
     {
       empty_value = args(nargin-1).double_value ();
       if (error_state)
-         return retval;
+        return retval;
       nargin -= 2;
     }
 
   if (nargin < 1 || nargin > 4)
     {
       print_usage ();
       return retval;
     }
@@ -209,17 +210,17 @@ fill empty fields.  The default is zero.
   std::istream *input = 0;
   std::ifstream input_file;
 
   if (args(0).is_string ())
     {
       // File name.
       std::string fname (args(0).string_value ());
       if (error_state)
-         return retval;
+        return retval;
 
       std::string tname = file_ops::tilde_expand (fname);
 
       input_file.open (tname.c_str (), std::ios::in);
 
       if (! input_file)
         {
           error ("dlmread: unable to open file '%s'", fname.c_str ());
@@ -228,17 +229,17 @@ fill empty fields.  The default is zero.
       else
         input = &input_file;
     }
   else if (args(0).is_scalar_type ())
     {
       octave_stream is = octave_stream_list::lookup (args(0), "dlmread");
 
       if (error_state)
-         return retval;
+        return retval;
 
       input = is.input_stream ();
 
       if (! input)
         {
           error ("dlmread: stream FILE not open for input");
           return retval;
         }
diff --git a/libinterp/corefcn/dot.cc b/libinterp/corefcn/dot.cc
--- a/libinterp/corefcn/dot.cc
+++ b/libinterp/corefcn/dot.cc
@@ -99,17 +99,17 @@ get_red_dims (const dim_vector& x, const
         {
           k = x(i);
           z(i) = 1;
         }
     }
 }
 
 DEFUN (dot, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} dot (@var{x}, @var{y}, @var{dim})\n\
 Compute the dot product of two vectors.  If @var{x} and @var{y}\n\
 are matrices, calculate the dot products along the first\n\
 non-singleton dimension.  If the optional argument @var{dim} is\n\
 given, calculate the dot products along this dimension.\n\
 \n\
 This is equivalent to\n\
 @code{sum (conj (@var{X}) .* @var{Y}, @var{dim})},\n\
@@ -165,28 +165,30 @@ but avoids forming a temporary array and
                 {
                   if (argx.is_single_type () || argy.is_single_type ())
                     {
                       FloatComplexNDArray x = argx.float_complex_array_value ();
                       FloatComplexNDArray y = argy.float_complex_array_value ();
                       get_red_dims (dimx, dimy, dim, dimz, m, n, k);
                       FloatComplexNDArray z(dimz);
                       if (! error_state)
-                        F77_XFCN (cdotc3, CDOTC3, (m, n, k, x.data (), y.data (),
+                        F77_XFCN (cdotc3, CDOTC3, (m, n, k,
+                                                   x.data (), y.data (),
                                                    z.fortran_vec ()));
                       retval = z;
                     }
                   else
                     {
                       ComplexNDArray x = argx.complex_array_value ();
                       ComplexNDArray y = argy.complex_array_value ();
                       get_red_dims (dimx, dimy, dim, dimz, m, n, k);
                       ComplexNDArray z(dimz);
                       if (! error_state)
-                        F77_XFCN (zdotc3, ZDOTC3, (m, n, k, x.data (), y.data (),
+                        F77_XFCN (zdotc3, ZDOTC3, (m, n, k,
+                                                   x.data (), y.data (),
                                                    z.fortran_vec ()));
                       retval = z;
                     }
                 }
               else if (argx.is_float_type () && argy.is_float_type ())
                 {
                   if (argx.is_single_type () || argy.is_single_type ())
                     {
@@ -258,17 +260,17 @@ but avoids forming a temporary array and
 %! y = int8 ([5 6; 7 8]);
 %! assert (dot (x, y), [26 44]);
 %! assert (dot (x, y, 2), [17; 53]);
 %! assert (dot (x, y, 3), [5 12; 21 32]);
 
 */
 
 DEFUN (blkmm, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} blkmm (@var{A}, @var{B})\n\
 Compute products of matrix blocks.  The blocks are given as\n\
 2-dimensional subarrays of the arrays @var{A}, @var{B}.\n\
 The size of @var{A} must have the form @code{[m,k,@dots{}]} and\n\
 size of @var{B} must be @code{[k,n,@dots{}]}.  The result is\n\
 then of size @code{[m,n,@dots{}]} and is computed as follows:\n\
 \n\
 @example\n\
@@ -312,50 +314,54 @@ endfor\n\
           if (argx.is_complex_type () || argy.is_complex_type ())
             {
               if (argx.is_single_type () || argy.is_single_type ())
                 {
                   FloatComplexNDArray x = argx.float_complex_array_value ();
                   FloatComplexNDArray y = argy.float_complex_array_value ();
                   FloatComplexNDArray z(dimz);
                   if (! error_state)
-                    F77_XFCN (cmatm3, CMATM3, (m, n, k, np, x.data (), y.data (),
+                    F77_XFCN (cmatm3, CMATM3, (m, n, k, np,
+                                               x.data (), y.data (),
                                                z.fortran_vec ()));
                   retval = z;
                 }
               else
                 {
                   ComplexNDArray x = argx.complex_array_value ();
                   ComplexNDArray y = argy.complex_array_value ();
                   ComplexNDArray z(dimz);
                   if (! error_state)
-                    F77_XFCN (zmatm3, ZMATM3, (m, n, k, np, x.data (), y.data (),
+                    F77_XFCN (zmatm3, ZMATM3, (m, n, k, np,
+                                               x.data (), y.data (),
                                                z.fortran_vec ()));
                   retval = z;
                 }
             }
           else
             {
               if (argx.is_single_type () || argy.is_single_type ())
                 {
                   FloatNDArray x = argx.float_array_value ();
                   FloatNDArray y = argy.float_array_value ();
                   FloatNDArray z(dimz);
                   if (! error_state)
-                    F77_XFCN (smatm3, SMATM3, (m, n, k, np, x.data (), y.data (),
+                    F77_XFCN (smatm3, SMATM3, (m, n, k, np,
+                                               x.data (), y.data (),
                                                z.fortran_vec ()));
                   retval = z;
                 }
               else
                 {
                   NDArray x = argx.array_value ();
                   NDArray y = argy.array_value ();
                   NDArray z(dimz);
                   if (! error_state)
-                    F77_XFCN (dmatm3, DMATM3, (m, n, k, np, x.data (), y.data (),
+                    F77_XFCN (dmatm3, DMATM3, (m, n, k, np,
+                                               x.data (), y.data (),
                                                z.fortran_vec ()));
                   retval = z;
                 }
             }
         }
       else
         error ("blkmm: A and B dimensions don't match: (%s) and (%s)",
                dimx.str ().c_str (), dimy.str ().c_str ());
diff --git a/libinterp/corefcn/dynamic-ld.cc b/libinterp/corefcn/dynamic-ld.cc
--- a/libinterp/corefcn/dynamic-ld.cc
+++ b/libinterp/corefcn/dynamic-ld.cc
@@ -182,17 +182,17 @@ octave_shlib_list::remove (octave_shlib&
   if (instance_ok ())
     instance->do_remove (shl, cl_hook);
 }
 
 octave_shlib
 octave_shlib_list::find_file (const std::string& file_name)
 {
   return (instance_ok ())
-    ? instance->do_find_file (file_name) : octave_shlib ();
+         ? instance->do_find_file (file_name) : octave_shlib ();
 }
 
 void
 octave_shlib_list::display (void)
 {
   if (instance_ok ())
     instance->do_display ();
 }
@@ -276,17 +276,17 @@ octave_dynamic_loader::do_load_oct (cons
   if (! error_state)
     {
       if (oct_file)
         {
           void *function = oct_file.search (fcn_name, name_mangler);
 
           if (! function)
             {
-              // FIXME -- can we determine this C mangling scheme
+              // FIXME: can we determine this C mangling scheme
               // automatically at run time or configure time?
 
               function = oct_file.search (fcn_name, name_uscore_mangler);
             }
 
           if (function)
             {
               octave_dld_fcn_getter f
@@ -340,17 +340,17 @@ octave_dynamic_loader::do_load_mex (cons
           void *function = 0;
 
           bool have_fmex = false;
 
           function = mex_file.search (fcn_name, mex_mangler);
 
           if (! function)
             {
-              // FIXME -- can we determine this C mangling scheme
+              // FIXME: can we determine this C mangling scheme
               // automatically at run time or configure time?
 
               function = mex_file.search (fcn_name, mex_uscore_mangler);
 
               if (! function)
                 {
                   function = mex_file.search (fcn_name, mex_f77_mangler);
 
@@ -411,30 +411,30 @@ octave_dynamic_loader::do_remove_mex (co
         octave_shlib_list::remove (shl);
     }
 
   return retval;
 }
 
 octave_function *
 octave_dynamic_loader::load_oct (const std::string& fcn_name,
-                                  const std::string& file_name,
-                                  bool relative)
+                                 const std::string& file_name,
+                                 bool relative)
 {
   return (instance_ok ())
-    ? instance->do_load_oct (fcn_name, file_name, relative) : 0;
+         ? instance->do_load_oct (fcn_name, file_name, relative) : 0;
 }
 
 octave_function *
 octave_dynamic_loader::load_mex (const std::string& fcn_name,
-                                  const std::string& file_name,
-                                  bool relative)
+                                 const std::string& file_name,
+                                 bool relative)
 {
   return (instance_ok ())
-    ? instance->do_load_mex (fcn_name, file_name, relative) : 0;
+         ? instance->do_load_mex (fcn_name, file_name, relative) : 0;
 }
 
 bool
 octave_dynamic_loader::remove_oct (const std::string& fcn_name,
                                    octave_shlib& shl)
 {
   return (instance_ok ()) ? instance->do_remove_oct (fcn_name, shl) : false;
 }
diff --git a/libinterp/corefcn/dynamic-ld.h b/libinterp/corefcn/dynamic-ld.h
--- a/libinterp/corefcn/dynamic-ld.h
+++ b/libinterp/corefcn/dynamic-ld.h
@@ -37,23 +37,23 @@ protected:
   octave_dynamic_loader (void) { }
 
 public:
 
   virtual ~octave_dynamic_loader (void) { }
 
   static octave_function *
   load_oct (const std::string& fcn_name,
-             const std::string& file_name = std::string (),
-             bool relative = false);
+            const std::string& file_name = std::string (),
+            bool relative = false);
 
   static octave_function *
   load_mex (const std::string& fcn_name,
-             const std::string& file_name = std::string (),
-             bool relative = false);
+            const std::string& file_name = std::string (),
+            bool relative = false);
 
   static bool remove_oct (const std::string& fcn_name, octave_shlib& shl);
 
   static bool remove_mex (const std::string& fcn_name, octave_shlib& shl);
 
 private:
 
   // No copying!
@@ -65,23 +65,23 @@ private:
   static octave_dynamic_loader *instance;
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
 
   static bool instance_ok (void);
 
   octave_function *
   do_load_oct (const std::string& fcn_name,
-                const std::string& file_name = std::string (),
-                bool relative = false);
+               const std::string& file_name = std::string (),
+               bool relative = false);
 
   octave_function *
   do_load_mex (const std::string& fcn_name,
-                const std::string& file_name = std::string (),
-                bool relative = false);
+               const std::string& file_name = std::string (),
+               bool relative = false);
 
   bool do_remove_oct (const std::string& fcn_name, octave_shlib& shl);
 
   bool do_remove_mex (const std::string& fcn_name, octave_shlib& shl);
 
   static bool doing_load;
 
 protected:
diff --git a/libinterp/corefcn/eig.cc b/libinterp/corefcn/eig.cc
--- a/libinterp/corefcn/eig.cc
+++ b/libinterp/corefcn/eig.cc
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN (eig, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{lambda} =} eig (@var{A})\n\
 @deftypefnx {Built-in Function} {@var{lambda} =} eig (@var{A}, @var{B})\n\
 @deftypefnx {Built-in Function} {[@var{V}, @var{lambda}] =} eig (@var{A})\n\
 @deftypefnx {Built-in Function} {[@var{V}, @var{lambda}] =} eig (@var{A}, @var{B})\n\
 Compute the eigenvalues (and optionally the eigenvectors) of a matrix\n\
 or a pair of matrices\n\
 \n\
 The algorithm used depends on whether there are one or two input\n\
diff --git a/libinterp/corefcn/ellipj.cc b/libinterp/corefcn/ellipj.cc
--- a/libinterp/corefcn/ellipj.cc
+++ b/libinterp/corefcn/ellipj.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 
 static void
 gripe_ellipj_arg (const char *arg)
 {
   error ("ellipj: expecting scalar or matrix as %s argument", arg);
 }
 
 DEFUN (ellipj, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{sn}, @var{cn}, @var{dn}, @var{err}] =} ellipj (@var{u}, @var{m})\n\
 @deftypefnx {Built-in Function} {[@var{sn}, @var{cn}, @var{dn}, @var{err}] =} ellipj (@var{u}, @var{m}, @var{tol})\n\
 Compute the Jacobi elliptic functions @var{sn}, @var{cn}, and @var{dn}\n\
 of complex argument @var{u} and real parameter @var{m}.\n\
 \n\
 If @var{m} is a scalar, the results are the same size as @var{u}.\n\
 If @var{u} is a scalar, the results are the same size as @var{m}.\n\
 If @var{u} is a column vector and @var{m} is a row vector, the\n\
@@ -95,17 +95,18 @@ and 16.15), Dover, 1965.\n\
         {
           gripe_ellipj_arg ("second");
           return retval;
         }
 
       if (u_arg.is_scalar_type ())
         {
           if (u_arg.is_real_type ())
-            {  // u real, m scalar
+            {
+              // u real, m scalar
               double u = args(0).double_value ();
 
               if (error_state)
                 {
                   gripe_ellipj_arg ("first");
                   return retval;
                 }
 
@@ -116,17 +117,18 @@ and 16.15), Dover, 1965.\n\
 
               if (nargout > 3)
                 retval(3) = err;
               retval(2) = dn;
               retval(1) = cn;
               retval(0) = sn;
             }
           else
-            {  // u complex, m scalar
+            {
+              // u complex, m scalar
               Complex u = u_arg.complex_value ();
 
               if (error_state)
                 {
                   gripe_ellipj_arg ("first");
                   return retval;
                 }
 
@@ -138,19 +140,20 @@ and 16.15), Dover, 1965.\n\
               if (nargout > 3)
                 retval(3) = err;
               retval(2) = dn;
               retval(1) = cn;
               retval(0) = sn;
             }
         }
       else
-        {  // u is matrix, m is scalar
+        {
+          // u is matrix, m is scalar
           ComplexNDArray u = u_arg.complex_array_value ();
-          
+
           if (error_state)
             {
               gripe_ellipj_arg ("first");
               return retval;
             }
 
           dim_vector sz_u = u.dims ();
 
@@ -182,19 +185,21 @@ and 16.15), Dover, 1965.\n\
         {
           gripe_ellipj_arg ("second");
           return retval;
         }
 
       dim_vector sz_m = m.dims ();
 
       if (u_arg.is_scalar_type ())
-        {  // u is scalar, m is array
+        {
+          // u is scalar, m is array
           if (u_arg.is_real_type ())
-            {  // u is real scalar, m is array
+            {
+              // u is real scalar, m is array
               double u = u_arg.double_value ();
 
               if (error_state)
                 {
                   gripe_ellipj_arg ("first");
                   return retval;
                 }
 
@@ -213,17 +218,18 @@ and 16.15), Dover, 1965.\n\
 
               if (nargout > 3)
                 retval(3) = err;
               retval(2) = dn;
               retval(1) = cn;
               retval(0) = sn;
             }
           else
-            {  // u is complex scalar, m is array
+            {
+              // u is complex scalar, m is array
               Complex u = u_arg.complex_value ();
 
               if (error_state)
                 {
                   gripe_ellipj_arg ("first");
                   return retval;
                 }
 
@@ -243,45 +249,49 @@ and 16.15), Dover, 1965.\n\
               if (nargout > 3)
                 retval(3) = err;
               retval(2) = dn;
               retval(1) = cn;
               retval(0) = sn;
             }
         }
       else
-        {  // u is array, m is array
+        {
+          // u is array, m is array
           if (u_arg.is_real_type ())
-            {  // u is real array, m is array
+            {
+              // u is real array, m is array
               NDArray u = u_arg.array_value ();
 
               if (error_state)
                 {
                   gripe_ellipj_arg ("first");
                   return retval;
                 }
 
               dim_vector sz_u = u.dims ();
 
               if (sz_u.length () == 2 && sz_m.length () == 2
                   && sz_u(1) == 1 && sz_m(0) == 1)
-                {  // u is real column vector, m is row vector
+                {
+                  // u is real column vector, m is row vector
                   octave_idx_type ur = sz_u(0);
                   octave_idx_type mc = sz_m(1);
                   dim_vector sz_out (ur, mc);
 
                   NDArray sn (sz_out), cn (sz_out), dn (sz_out);
                   NDArray err (sz_out);
 
                   const double *pu = u.data ();
                   const double *pm = m.data ();
 
                   for (octave_idx_type j = 0; j < mc; j++)
                     for (octave_idx_type i = 0; i < ur; i++)
-                      ellipj (pu[i], pm[j], sn(i,j), cn(i,j), dn(i,j), err(i,j));
+                      ellipj (pu[i], pm[j], sn(i,j), cn(i,j), dn(i,j),
+                              err(i,j));
 
                   if (nargout > 3)
                     retval(3) = err;
                   retval(2) = dn;
                   retval(1) = cn;
                   retval(0) = sn;
                 }
               else if (sz_m == sz_u)
@@ -305,43 +315,46 @@ and 16.15), Dover, 1965.\n\
                   retval(2) = dn;
                   retval(1) = cn;
                   retval(0) = sn;
                 }
               else
                 error ("ellipj: Invalid size combination for U and M");
             }
           else
-            {  // u is complex array, m is array
+            {
+              // u is complex array, m is array
               ComplexNDArray u = u_arg.complex_array_value ();
 
               if (error_state)
                 {
                   gripe_ellipj_arg ("second");
                   return retval;
                 }
 
               dim_vector sz_u = u.dims ();
 
               if (sz_u.length () == 2 && sz_m.length () == 2
                   && sz_u(1) == 1 && sz_m(0) == 1)
-                {  // u is complex column vector, m is row vector
+                {
+                  // u is complex column vector, m is row vector
                   octave_idx_type ur = sz_u(0);
                   octave_idx_type mc = sz_m(1);
                   dim_vector sz_out (ur, mc);
 
                   ComplexNDArray sn (sz_out), cn (sz_out), dn (sz_out);
                   NDArray err (sz_out);
 
                   const Complex *pu = u.data ();
                   const double  *pm = m.data ();
 
                   for (octave_idx_type j = 0; j < mc; j++)
                     for (octave_idx_type i = 0; i < ur; i++)
-                      ellipj (pu[i], pm[j], sn(i,j), cn(i,j), dn(i,j), err(i,j));
+                      ellipj (pu[i], pm[j], sn(i,j), cn(i,j), dn(i,j),
+                              err(i,j));
 
                   if (nargout > 3)
                     retval(3) = err;
                   retval(2) = dn;
                   retval(1) = cn;
                   retval(0) = sn;
                 }
               else if (sz_m == sz_u)
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -159,19 +159,19 @@ vwarning (const char *name, const char *
 
   if (name)
     output_buf << name << ": ";
 
   octave_vformat (output_buf, fmt, args);
 
   output_buf << std::endl;
 
-  // FIXME -- we really want to capture the message before it
-  // has all the formatting goop attached to it.  We probably also
-  // want just the message, not the traceback information.
+  // FIXME: we really want to capture the message before it has all the
+  //        formatting goop attached to it.  We probably also want just the
+  //        message, not the traceback information.
 
   std::string msg_string = output_buf.str ();
 
   if (! warning_state)
     {
       // This is the first warning in a possible series.
 
       Vlast_warning_id = id;
@@ -192,19 +192,19 @@ verror (bool save_last_error, std::ostre
         bool with_cfn = false)
 {
   if (discard_error_messages)
     return;
 
   if (! buffer_error_messages)
     flush_octave_stdout ();
 
-  // FIXME -- we really want to capture the message before it
-  // has all the formatting goop attached to it.  We probably also
-  // want just the message, not the traceback information.
+  // FIXME: we really want to capture the message before it has all the
+  //        formatting goop attached to it.  We probably also want just the
+  //        message, not the traceback information.
 
   std::ostringstream output_buf;
 
   octave_vformat (output_buf, fmt, args);
 
   std::string base_msg = output_buf.str ();
 
   bool to_beep_or_not_to_beep_p = Vbeep_on_error && ! error_state;
@@ -226,17 +226,17 @@ verror (bool save_last_error, std::ostre
       octave_function *curfcn = octave_call_stack::current ();
       if (curfcn)
         {
           std::string cfn = curfcn->name ();
           if (! cfn.empty ())
             {
               cfn += ':';
               if (cfn.length () > base_msg.length ()
-                 || base_msg.compare (0, cfn.length (), cfn) != 0)
+                  || base_msg.compare (0, cfn.length (), cfn) != 0)
                 {
                   msg_string += cfn + ' ';
                 }
             }
         }
     }
 
   msg_string += base_msg + "\n";
@@ -822,17 +822,17 @@ handle_message (error_fun f, const char 
           retval = msg;
         }
     }
 
   return retval;
 }
 
 DEFUN (rethrow, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} rethrow (@var{err})\n\
 Reissue a previous error as defined by @var{err}.  @var{err} is a structure\n\
 that must contain at least the @qcode{\"message\"} and @qcode{\"identifier\"}\n\
 fields.  @var{err} can also contain a field @qcode{\"stack\"} that gives\n\
 information on the assumed location of the error.  Typically @var{err} is\n\
 returned from @code{lasterror}.\n\
 @seealso{lasterror, lasterr, error}\n\
 @end deftypefn")
@@ -890,19 +890,18 @@ returned from @code{lasterror}.\n\
                       tmp_msg[len - 1] = '\0';
                       rethrow_error (id.c_str (), "%s\n", tmp_msg);
                     }
                 }
               else
                 rethrow_error (id.c_str (), "%s", tmp_msg);
               delete [] tmp_msg;
 
-              // FIXME -- is this the right thing to do for
-              // Vlast_error_stack?  Should it be saved and restored
-              // with unwind_protect?
+              // FIXME: is this the right thing to do for Vlast_error_stack?
+              //        Should it be saved and restored with unwind_protect?
 
               Vlast_error_stack = err_stack;
 
               if (err.contains ("stack"))
                 {
                   if (file.empty ())
                     {
                       if (nm.empty ())
@@ -919,42 +918,45 @@ returned from @code{lasterror}.\n\
                       else
                         {
                           if (l > 0)
                             {
                               if (c > 0)
                                 pr_where_1 ("error: called from '%s' near line %d, column %d",
                                             nm.c_str (), l, c);
                               else
-                                pr_where_1 ("error: called from '%d' near line %d", nm.c_str (), l);
+                                pr_where_1 ("error: called from '%d' near line %d",
+                                            nm.c_str (), l);
                             }
                         }
                     }
                   else
                     {
                       if (nm.empty ())
                         {
                           if (l > 0)
                             {
                               if (c > 0)
                                 pr_where_1 ("error: in file %s near line %d, column %d",
                                             file.c_str (), l, c);
                               else
-                                pr_where_1 ("error: in file %s near line %d", file.c_str (), l);
+                                pr_where_1 ("error: in file %s near line %d",
+                                            file.c_str (), l);
                             }
                         }
                       else
                         {
                           if (l > 0)
                             {
                               if (c > 0)
                                 pr_where_1 ("error: called from '%s' in file %s near line %d, column %d",
                                             nm.c_str (), file.c_str (), l, c);
                               else
-                                pr_where_1 ("error: called from '%d' in file %s near line %d", nm.c_str (), file.c_str (), l);
+                                pr_where_1 ("error: called from '%d' in file %s near line %d",
+                                            nm.c_str (), file.c_str (), l);
                             }
                         }
                     }
                 }
             }
           else
             error ("rethrow: ERR structure must contain the fields 'message and 'identifier'");
         }
@@ -1000,26 +1002,26 @@ maybe_extract_message_id (const std::str
 
                   nargs.resize (nargin-1);
 
                   for (int i = 1; i < nargin; i++)
                     nargs(i-1) = args(i);
                 }
               else
                 nargs(0) = "call to " + caller
-                  + " with message identifier requires message";
+                           + " with message identifier requires message";
             }
         }
     }
 
   return have_fmt;
 }
 
 DEFUN (error, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} error (@var{template}, @dots{})\n\
 @deftypefnx {Built-in Function} {} error (@var{id}, @var{template}, @dots{})\n\
 Format the optional arguments under the control of the template string\n\
 @var{template} using the same rules as the @code{printf} family of\n\
 functions (@pxref{Formatted Output}) and print the resulting message\n\
 on the @code{stderr} stream.  The message is prefixed by the character\n\
 string @samp{error: }.\n\
 \n\
@@ -1127,30 +1129,30 @@ Use a second backslash to stop interpola
           if (m.nfields () == 0)
             return retval;
 
           if (m.contains ("message"))
             {
               octave_value c = m.getfield ("message");
 
               if (c.is_string ())
-                 nargs(0) = c.string_value ();
+                nargs(0) = c.string_value ();
             }
 
           if (m.contains ("identifier"))
             {
               octave_value c = m.getfield ("identifier");
 
               if (c.is_string ())
-                 id = c.string_value ();
+                id = c.string_value ();
             }
 
-          // FIXME -- also need to handle "stack" field in error
-          // structure, but that will require some more significant
-          // surgery on handle_message, error_with_id, etc.
+          // FIXME: also need to handle "stack" field in error structure,
+          //        but that will require some more significant surgery on
+          //        handle_message, error_with_id, etc.
         }
       else
         {
           have_fmt = maybe_extract_message_id ("error", args, nargs, id);
 
           if (error_state)
             return retval;
         }
@@ -1211,17 +1213,17 @@ warning_query (const std::string& id_arg
     }
   else
     error ("warning: unable to find default warning state!");
 
   return retval;
 }
 
 DEFUN (warning, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} warning (@var{template}, @dots{})\n\
 @deftypefnx {Built-in Function} {} warning (@var{id}, @var{template}, @dots{})\n\
 @deftypefnx {Built-in Function} {} warning (\"on\", @var{id})\n\
 @deftypefnx {Built-in Function} {} warning (\"off\", @var{id})\n\
 @deftypefnx {Built-in Function} {} warning (\"query\", @var{id})\n\
 @deftypefnx {Built-in Function} {} warning (\"error\", @var{id})\n\
 @deftypefnx {Built-in Function} {} warning (@var{state}, @var{id}, \"local\")\n\
 Format the optional arguments under the control of the template string\n\
@@ -1302,18 +1304,17 @@ Use a second backslash to stop interpola
 
                   symbol_table::context_id context
                     = octave_call_stack::current_context ();
 
                   octave_scalar_map val = warning_query (arg2);
 
                   octave_value curr_state = val.contents ("state");
 
-                  // FIXME -- this might be better with a dictionary
-                  // object.
+                  // FIXME: this might be better with a dictionary object.
 
                   octave_value curr_warning_states
                     = symbol_table::varval (".saved_warning_states.",
                                             scope, context);
 
                   octave_map m;
 
                   if (curr_warning_states.is_defined ())
@@ -1368,17 +1369,17 @@ Use a second backslash to stop interpola
 
                   symbol_table::assign
                     (".saved_warning_states.", m, scope, context);
 
                   // Now ignore the "local" argument and continue to
                   // handle the current setting.
                   argc--;
                 }
-                  
+
               if (arg2 == "all")
                 {
                   octave_map tmp;
 
                   Cell id (1, 1);
                   Cell st (1, 1);
 
                   id(0) = arg2;
@@ -1474,31 +1475,31 @@ Use a second backslash to stop interpola
                       octave_idx_type nel = ident.numel ();
 
                       bool found = false;
 
                       for (octave_idx_type i = 0; i < nel; i++)
                         {
                           if (ident(i).string_value () == arg2)
                             {
-                              // FIXME -- if state for "all" is
-                              // same as arg1, we can simply remove the
-                              // item from the list.
+                              // FIXME: if state for "all" is  same as arg1,
+                              //        we can simply remove the item
+                              //        from the list.
 
                               state(i) = arg1;
                               warning_options.assign ("state", state);
                               found = true;
                               break;
                             }
                         }
 
                       if (! found)
                         {
-                          // FIXME -- if state for "all" is
-                          // same as arg1, we don't need to do anything.
+                          // FIXME: if state for "all" is same as arg1,
+                          //        we don't need to do anything.
 
                           ident.resize (dim_vector (1, nel+1));
                           state.resize (dim_vector (1, nel+1));
 
                           ident(nel) = arg2;
                           state(nel) = arg1;
 
                           warning_options.clear ();
@@ -1641,17 +1642,17 @@ initialize_default_warning_state (void)
   // mode.  Also, this error is not triggered in normal mode because another
   // error handler catches it first and gives:
   // error: subscript indices must be either positive integers or logicals
   set_warning_state ("Octave:noninteger-range-as-index", "error");
 
 }
 
 DEFUN (lasterror, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{lasterr} =} lasterror ()\n\
 @deftypefnx {Built-in Function} {} lasterror (@var{err})\n\
 @deftypefnx {Built-in Function} {} lasterror (\"reset\")\n\
 Query or set the last error message structure.  When called without\n\
 arguments, return a structure containing the last error message and other\n\
 information related to this error.  The elements of the structure are:\n\
 \n\
 @table @code\n\
@@ -1743,17 +1744,17 @@ fields are set to their default values.\
                 {
                   const std::string tmp =
                     new_err.getfield ("identifier").string_value ();
                   new_error_id = tmp;
                 }
 
               if (! error_state && new_err.contains ("stack"))
                 {
-                  new_err_stack = 
+                  new_err_stack =
                     new_err.getfield ("stack").scalar_map_value ();
 
                   if (! error_state && new_err_stack.contains ("file"))
                     {
                       const std::string tmp =
                         new_err_stack.getfield ("file").string_value ();
                       new_error_file = tmp;
                     }
@@ -1812,17 +1813,17 @@ fields are set to their default values.\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (lasterr, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{msg}, @var{msgid}] =} lasterr ()\n\
 @deftypefnx {Built-in Function} {} lasterr (@var{msg})\n\
 @deftypefnx {Built-in Function} {} lasterr (@var{msg}, @var{msgid})\n\
 Query or set the last error message.  When called without input arguments,\n\
 return the last error message and message identifier.  With one\n\
 argument, set the last error message to @var{msg}.  With two arguments,\n\
 also set the last message identifier.\n\
 @seealso{lasterror, error, lastwarn}\n\
@@ -1863,17 +1864,17 @@ also set the last message identifier.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (lastwarn, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{msg}, @var{msgid}] =} lastwarn ()\n\
 @deftypefnx {Built-in Function} {} lastwarn (@var{msg})\n\
 @deftypefnx {Built-in Function} {} lastwarn (@var{msg}, @var{msgid})\n\
 Query or set the last warning message.  When called without input arguments,\n\
 return the last warning message and message identifier.  With one\n\
 argument, set the last warning message to @var{msg}.  With two arguments,\n\
 also set the last message identifier.\n\
 @seealso{warning, lasterror, lasterr}\n\
@@ -1910,17 +1911,17 @@ also set the last message identifier.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (usage, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} usage (@var{msg})\n\
 Print the message @var{msg}, prefixed by the string @samp{usage: }, and\n\
 set Octave's internal error state such that control will return to the\n\
 top level without evaluating any more commands.  This is useful for\n\
 aborting from functions.\n\
 \n\
 After @code{usage} is evaluated, Octave will print a traceback of all\n\
 the function calls leading to the usage message.\n\
@@ -1944,33 +1945,33 @@ to check for the proper number of argume
 @end deftypefn")
 {
   octave_value_list retval;
   handle_message (usage_with_id, "", "unknown", args, true);
   return retval;
 }
 
 DEFUN (beep_on_error, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} beep_on_error ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} beep_on_error (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} beep_on_error (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will try\n\
 to ring the terminal bell before printing an error message.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.  \n\
 The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (beep_on_error);
 }
 
 DEFUN (debug_on_error, args, nargout,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} debug_on_error ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} debug_on_error (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} debug_on_error (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will try\n\
 to enter the debugger when an error is encountered.  This will also\n\
 inhibit printing of the normal traceback message (you will only see\n\
 the top-level error message).\n\
 \n\
@@ -1979,17 +1980,17 @@ variable is changed locally for the func
 The original variable value is restored when exiting the function.\n\
 @seealso{debug_on_warning, debug_on_interrupt}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (debug_on_error);
 }
 
 DEFUN (debug_on_warning, args, nargout,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} debug_on_warning ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} debug_on_warning (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} debug_on_warning (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will try\n\
 to enter the debugger when a warning is encountered.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.  \n\
diff --git a/libinterp/corefcn/error.h b/libinterp/corefcn/error.h
--- a/libinterp/corefcn/error.h
+++ b/libinterp/corefcn/error.h
@@ -32,17 +32,19 @@ class unwind_protect;
 #define panic_impossible() \
   panic ("impossible state reached in file '%s' at line %d", \
          __FILE__, __LINE__)
 
 extern OCTINTERP_API void reset_error_handler (void);
 
 extern OCTINTERP_API int warning_enabled (const std::string& id);
 
-extern OCTINTERP_API void vmessage (const char *name, const char *fmt, va_list args);
+extern OCTINTERP_API void
+vmessage (const char *name, const char *fmt, va_list args);
+
 extern OCTINTERP_API void message (const char *name, const char *fmt, ...);
 
 extern OCTINTERP_API void vusage (const char *fmt, va_list args);
 extern OCTINTERP_API void usage (const char *fmt, ...);
 
 extern OCTINTERP_API void vwarning (const char *fmt, va_list args);
 extern OCTINTERP_API void warning (const char *fmt, ...);
 
@@ -51,17 +53,18 @@ extern OCTINTERP_API void error (const c
 
 extern OCTINTERP_API void verror_with_cfn (const char *fmt, va_list args);
 extern OCTINTERP_API void error_with_cfn (const char *fmt, ...);
 
 extern OCTINTERP_API void vparse_error (const char *fmt, va_list args);
 extern OCTINTERP_API void parse_error (const char *fmt, ...);
 
 extern OCTINTERP_API void
-vmessage_with_id (const char *id, const char *name, const char *fmt, va_list args);
+vmessage_with_id (const char *id, const char *name,
+                  const char *fmt, va_list args);
 
 extern OCTINTERP_API void
 message_with_id (const char *id, const char *name, const char *fmt, ...);
 
 extern OCTINTERP_API void
 vusage_with_id (const char *id, const char *fmt, va_list args);
 
 extern OCTINTERP_API void
diff --git a/libinterp/corefcn/event-queue.h b/libinterp/corefcn/event-queue.h
--- a/libinterp/corefcn/event-queue.h
+++ b/libinterp/corefcn/event-queue.h
@@ -94,29 +94,29 @@ private:
 
   static void gripe_exception (void);
 
 public:
 
   event_queue_safe (void) : event_queue () { }
 
   ~event_queue_safe (void)
-    {
-      while (! empty ())
-        {
-          try
-            {
-              run_first ();
-            }
-          catch (...) // Yes, the black hole. Remember we're in a dtor.
-            {
-              gripe_exception ();
-            }
-        }
-    }
+  {
+    while (! empty ())
+      {
+        try
+          {
+            run_first ();
+          }
+        catch (...) // Yes, the black hole. Remember we're in a dtor.
+          {
+            gripe_exception ();
+          }
+      }
+  }
 
 private:
 
   // No copying!
 
   event_queue_safe (const event_queue_safe&);
 
   event_queue_safe& operator = (const event_queue_safe&);
diff --git a/libinterp/corefcn/fft.cc b/libinterp/corefcn/fft.cc
--- a/libinterp/corefcn/fft.cc
+++ b/libinterp/corefcn/fft.cc
@@ -63,31 +63,33 @@ do_fft (const octave_value_list &args, c
         {
           double dval = args(1).double_value ();
           if (xisnan (dval))
             error ("%s: number of points (N) cannot be NaN", fcn);
           else
             {
               n_points = NINTbig (dval);
               if (n_points < 0)
-                error ("%s: number of points (N) must be greater than zero", fcn);
+                error ("%s: number of points (N) must be greater than zero",
+                       fcn);
             }
         }
     }
 
   if (error_state)
     return retval;
 
   if (nargin > 2)
     {
       double dval = args(2).double_value ();
       if (xisnan (dval))
         error ("%s: DIM cannot be NaN", fcn);
       else if (dval < 1 || dval > dims.length ())
-        error ("%s: DIM must be a valid dimension along which to perform FFT", fcn);
+        error ("%s: DIM must be a valid dimension along which to perform FFT",
+               fcn);
       else
         // to be safe, cast it back to int since dim is an int
         dim = NINT (dval) - 1;
     }
 
   if (error_state)
     return retval;
 
@@ -193,17 +195,17 @@ do_fft (const octave_value_list &args, c
 %!assert (fft (ones (2,2,"single")), single ([2,2; 0,0]))
 %!assert (fft (eye (2,2,"single")), single ([1,1; 1,-1]))
 
 %!error (fft ())
 */
 
 
 DEFUN (fft, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} fft (@var{x})\n\
 @deftypefnx {Built-in Function} {} fft (@var{x}, @var{n})\n\
 @deftypefnx {Built-in Function} {} fft (@var{x}, @var{n}, @var{dim})\n\
 Compute the discrete Fourier transform of @var{A} using\n\
 a Fast Fourier Transform (FFT) algorithm.\n\
 \n\
 The FFT is calculated along the first non-singleton dimension of the\n\
 array.  Thus if @var{x} is a matrix, @code{fft (@var{x})} computes the\n\
@@ -222,17 +224,17 @@ dimension of the matrix along which the 
 @seealso{ifft, fft2, fftn, fftw}\n\
 @end deftypefn")
 {
   return do_fft (args, "fft", 0);
 }
 
 
 DEFUN (ifft, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} ifft (@var{x})\n\
 @deftypefnx {Built-in Function} {} ifft (@var{x}, @var{n})\n\
 @deftypefnx {Built-in Function} {} ifft (@var{x}, @var{n}, @var{dim})\n\
 Compute the inverse discrete Fourier transform of @var{A}\n\
 using a Fast Fourier Transform (FFT) algorithm.\n\
 \n\
 The inverse FFT is calculated along the first non-singleton dimension\n\
 of the array.  Thus if @var{x} is a matrix, @code{fft (@var{x})} computes\n\
diff --git a/libinterp/corefcn/fft2.cc b/libinterp/corefcn/fft2.cc
--- a/libinterp/corefcn/fft2.cc
+++ b/libinterp/corefcn/fft2.cc
@@ -163,17 +163,17 @@ do_fft2 (const octave_value_list &args, 
           gripe_wrong_type_arg (fcn, arg);
         }
     }
 
   return retval;
 }
 
 DEFUN (fft2, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} fft2 (@var{A})\n\
 @deftypefnx {Built-in Function} {} fft2 (@var{A}, @var{m}, @var{n})\n\
 Compute the two-dimensional discrete Fourier transform of @var{A} using\n\
 a Fast Fourier Transform (FFT) algorithm.\n\
 \n\
 The optional arguments @var{m} and @var{n} may be used specify the\n\
 number of rows and columns of @var{A} to use.  If either of these is\n\
 larger than the size of @var{A}, @var{A} is resized and padded with\n\
@@ -184,17 +184,17 @@ of @var{A} is treated separately.\n\
 @seealso {ifft2, fft, fftn, fftw}\n\
 @end deftypefn")
 {
   return do_fft2 (args, "fft2", 0);
 }
 
 
 DEFUN (ifft2, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} ifft2 (@var{A})\n\
 @deftypefnx {Built-in Function} {} ifft2 (@var{A}, @var{m}, @var{n})\n\
 Compute the inverse two-dimensional discrete Fourier transform of @var{A}\n\
 using a Fast Fourier Transform (FFT) algorithm.\n\
 \n\
 The optional arguments @var{m} and @var{n} may be used specify the\n\
 number of rows and columns of @var{A} to use.  If either of these is\n\
 larger than the size of @var{A}, @var{A} is resized and padded with\n\
diff --git a/libinterp/corefcn/fftn.cc b/libinterp/corefcn/fftn.cc
--- a/libinterp/corefcn/fftn.cc
+++ b/libinterp/corefcn/fftn.cc
@@ -70,17 +70,18 @@ do_fftn (const octave_value_list &args, 
         error ("%s: SIZE must be a vector of length dim", fcn);
       else
         {
           for (int i = 0; i < dims.length (); i++)
             {
               if (xisnan (val(i,0)))
                 error ("%s: SIZE has invalid NaN entries", fcn);
               else if (NINTbig (val(i,0)) < 0)
-                error ("%s: all dimensions in SIZE must be greater than zero", fcn);
+                error ("%s: all dimensions in SIZE must be greater than zero",
+                       fcn);
               else
                 {
                   dims(i) = NINTbig(val(i,0));
                 }
             }
         }
     }
 
@@ -145,17 +146,17 @@ do_fftn (const octave_value_list &args, 
           gripe_wrong_type_arg (fcn, arg);
         }
     }
 
   return retval;
 }
 
 DEFUN (fftn, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} fftn (@var{A})\n\
 @deftypefnx {Built-in Function} {} fftn (@var{A}, @var{size})\n\
 Compute the N-dimensional discrete Fourier transform of @var{A} using\n\
 a Fast Fourier Transform (FFT) algorithm.\n\
 \n\
 The optional vector argument @var{size} may be used specify the\n\
 dimensions of the array to be used.  If an element of @var{size} is\n\
 smaller than the corresponding dimension of @var{A}, then the dimension of\n\
@@ -164,17 +165,17 @@ of @var{size} is larger than the corresp
 is resized and padded with zeros.\n\
 @seealso{ifftn, fft, fft2, fftw}\n\
 @end deftypefn")
 {
   return do_fftn (args, "fftn", 0);
 }
 
 DEFUN (ifftn, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} ifftn (@var{A})\n\
 @deftypefnx {Built-in Function} {} ifftn (@var{A}, @var{size})\n\
 Compute the inverse N-dimensional discrete Fourier transform of @var{A}\n\
 using a Fast Fourier Transform (FFT) algorithm.\n\
 \n\
 The optional vector argument @var{size} may be used specify the\n\
 dimensions of the array to be used.  If an element of @var{size} is\n\
 smaller than the corresponding dimension of @var{A}, then the dimension of\n\
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -104,18 +104,18 @@ initialize_file_io (void)
 void
 close_files (void)
 {
   octave_stream_list::clear ();
 }
 
 // List of files to delete when we exit or crash.
 //
-// FIXME -- this should really be static, but that causes
-// problems on some systems.
+// FIXME: this should really be static,
+//        but that causes problems on some systems.
 std::stack <std::string> tmp_files;
 
 void
 mark_for_deletion (const std::string& file)
 {
   tmp_files.push (file);
 }
 
@@ -232,17 +232,17 @@ fopen_mode_to_ios_mode (const std::strin
       else
         ::error ("invalid mode specified");
     }
 
   return retval;
 }
 
 DEFUN (fclose, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} fclose (@var{fid})\n\
 @deftypefnx {Built-in Function} {} fclose (\"all\")\n\
 Close the specified file.  If successful, @code{fclose} returns 0,\n\
 otherwise, it returns -1.  The second form of the @code{fclose} call closes\n\
 all open files except @code{stdout}, @code{stderr}, and @code{stdin}.\n\
 @seealso{fopen, freport}\n\
 @end deftypefn")
 {
@@ -254,17 +254,17 @@ all open files except @code{stdout}, @co
     retval = octave_stream_list::remove (args(0), "fclose");
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fclear, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fclear (@var{fid})\n\
 Clear the stream state for the specified file.\n\
 @seealso{fopen}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
@@ -280,17 +280,17 @@ Clear the stream state for the specified
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fflush, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fflush (@var{fid})\n\
 Flush output to @var{fid}.  This is useful for ensuring that all\n\
 pending output makes it to the screen before some other event occurs.\n\
 For example, it is always a good idea to flush the standard output\n\
 stream before calling @code{input}.\n\
 \n\
 @code{fflush} returns 0 on success and an OS dependent error value\n\
 (@minus{}1 on Unix) on error.\n\
@@ -298,17 +298,17 @@ stream before calling @code{input}.\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      // FIXME -- any way to avoid special case for stdout?
+      // FIXME: any way to avoid special case for stdout?
 
       int fid = octave_stream_list::get_file_number (args (0));
 
       if (fid == 1)
         {
           flush_octave_stdout ();
 
           retval = 0;
@@ -323,17 +323,17 @@ stream before calling @code{input}.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fgetl, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{str} =} fgetl (@var{fid})\n\
 @deftypefnx {Built-in Function} {@var{str} =} fgetl (@var{fid}, @var{len})\n\
 Read characters from a file, stopping after a newline, or EOF,\n\
 or @var{len} characters have been read.  The characters read, excluding\n\
 the possible trailing newline, are returned as a string.\n\
 \n\
 If @var{len} is omitted, @code{fgetl} reads until the next newline\n\
 character.\n\
@@ -374,17 +374,17 @@ To read a line and return the terminatin
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fgets, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{str} =} fgets (@var{fid})\n\
 @deftypefnx {Built-in Function} {@var{str} =} fgets (@var{fid}, @var{len})\n\
 Read characters from a file, stopping after a newline, or EOF,\n\
 or @var{len} characters have been read.  The characters read, including\n\
 the possible trailing newline, are returned as a string.\n\
 \n\
 If @var{len} is omitted, @code{fgets} reads until the next newline\n\
 character.\n\
@@ -425,17 +425,17 @@ To read a line and discard the terminati
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fskipl, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{nlines} =} fskipl (@var{fid})\n\
 @deftypefnx {Built-in Function} {@var{nlines} =} fskipl (@var{fid}, @var{count})\n\
 @deftypefnx {Built-in Function} {@var{nlines} =} fskipl (@var{fid}, Inf)\n\
 Read and skip @var{count} lines from the file descriptor @var{fid}.\n\
 @code{fskipl} discards characters until an end-of-line is encountered exactly\n\
 @var{count}-times, or until the end-of-file marker is found.\n\
 \n\
 If @var{count} is omitted, it defaults to 1.  @var{count} may also be\n\
@@ -535,17 +535,18 @@ do_stream_open (const std::string& name,
                   else
                     retval.error (gnulib::strerror (errno));
                 }
               else
 #endif
                 {
                   FILE *fptr = gnulib::fopen (fname.c_str (), mode.c_str ());
 
-                  retval = octave_stdiostream::create (fname, fptr, md, flt_fmt);
+                  retval = octave_stdiostream::create (fname, fptr, md,
+                                                       flt_fmt);
 
                   if (! fptr)
                     retval.error (gnulib::strerror (errno));
                 }
 
             }
         }
     }
@@ -581,17 +582,17 @@ do_stream_open (const octave_value& tc_n
     }
   else
     ::error ("%s: file name must be a string", fcn);
 
   return retval;
 }
 
 DEFUN (fopen, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{fid}, @var{msg}] =} fopen (@var{name}, @var{mode}, @var{arch})\n\
 @deftypefnx {Built-in Function} {@var{fid_list} =} fopen (\"all\")\n\
 @deftypefnx {Built-in Function} {[@var{file}, @var{mode}, @var{arch}] =} fopen (@var{fid})\n\
 The first form of the @code{fopen} function opens the named file with\n\
 the specified mode (read-write, read-only, etc.) and architecture\n\
 interpretation (IEEE big endian, IEEE little endian, etc.), and returns\n\
 an integer value that may be used to refer to the file later.  If an\n\
 error occurs, @var{fid} is set to @minus{}1 and @var{msg} contains the\n\
@@ -709,20 +710,20 @@ however, conversions are currently only 
 
           return retval;
         }
     }
 
   if (nargin > 0 && nargin < 4)
     {
       octave_value mode = (nargin == 2 || nargin == 3)
-        ? args(1) : octave_value ("r");
+                          ? args(1) : octave_value ("r");
 
       octave_value arch = (nargin == 3)
-        ? args(2) : octave_value ("native");
+                          ? args(2) : octave_value ("native");
 
       int fid = -1;
 
       octave_stream os = do_stream_open (args(0), mode, arch, "fopen", fid);
 
       if (os && ! error_state)
         {
           retval(1) = "";
@@ -738,17 +739,17 @@ however, conversions are currently only 
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (freport, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} freport ()\n\
 Print a list of which files have been opened, and whether they are open\n\
 for reading, writing, or both.  For example:\n\
 \n\
 @example\n\
 @group\n\
 freport ()\n\
 \n\
@@ -771,17 +772,17 @@ freport ()\n\
     warning ("freport: ignoring extra arguments");
 
   octave_stdout << octave_stream_list::list_open_files ();
 
   return retval;
 }
 
 DEFUN (frewind, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} frewind (@var{fid})\n\
 Move the file pointer to the beginning of the file @var{fid}, returning\n\
 0 for success, and -1 if an error was encountered.  It is equivalent to\n\
 @code{fseek (@var{fid}, 0, SEEK_SET)}.\n\
 @seealso{fseek, ftell, fopen}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -802,17 +803,17 @@ 0 for success, and -1 if an error was en
 
   if (nargout > 0)
     retval = result;
 
   return retval;
 }
 
 DEFUN (fseek, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} fseek (@var{fid}, @var{offset})\n\
 @deftypefnx {Built-in Function} {} fseek (@var{fid}, @var{offset}, @var{origin})\n\
 @deftypefnx {Built-in Function} {@var{status} =} fseek (@dots{})\n\
 Set the file pointer to any location within the file @var{fid}.\n\
 \n\
 The pointer is positioned @var{offset} characters from the @var{origin},\n\
 which may be one of the predefined variables @w{@code{SEEK_CUR}} (current\n\
 position), @w{@code{SEEK_SET}} (beginning), or @w{@code{SEEK_END}} (end of\n\
@@ -831,29 +832,29 @@ Return 0 on success and -1 on error.\n\
 
   if (nargin == 2 || nargin == 3)
     {
       octave_stream os = octave_stream_list::lookup (args(0), "fseek");
 
       if (! error_state)
         {
           octave_value origin_arg = (nargin == 3)
-            ? args(2) : octave_value (-1.0);
+                                    ? args(2) : octave_value (-1.0);
 
           retval = os.seek (args(1), origin_arg);
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (ftell, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ftell (@var{fid})\n\
 Return the position of the file pointer as the number of characters\n\
 from the beginning of the file @var{fid}.\n\
 @seealso{fseek, feof, fopen}\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
@@ -868,17 +869,17 @@ from the beginning of the file @var{fid}
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fprintf, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fprintf (@var{fid}, @var{template}, @dots{})\n\
 This function is just like @code{printf}, except that the output is\n\
 written to the stream @var{fid} instead of @code{stdout}.\n\
 If @var{fid} is omitted, the output is written to @code{stdout}.\n\
 @seealso{fputs, fdisp, fwrite, fscanf, printf, sprintf, fopen}\n\
 @end deftypefn")
 {
   static std::string who = "fprintf";
@@ -929,17 +930,17 @@ If @var{fid} is omitted, the output is w
 
   if (nargout > 0)
     retval = result;
 
   return retval;
 }
 
 DEFUN (printf, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} printf (@var{template}, @dots{})\n\
 Print optional arguments under the control of the template string\n\
 @var{template} to the stream @code{stdout} and return the number of\n\
 characters printed.\n\
 @ifclear OCTAVE_MANUAL\n\
 \n\
 See the Formatted Output section of the GNU Octave manual for a\n\
 complete description of the syntax of the template string.\n\
@@ -979,17 +980,17 @@ complete description of the syntax of th
 
   if (nargout > 0)
     retval = result;
 
   return retval;
 }
 
 DEFUN (fputs, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fputs (@var{fid}, @var{string})\n\
 Write a string to a file with no formatting.\n\
 \n\
 Return a non-negative number on success and EOF on error.\n\
 @seealso{fdisp, fprintf, fwrite, fopen}\n\
 @end deftypefn")
 {
   static std::string who = "fputs";
@@ -1007,17 +1008,17 @@ Return a non-negative number on success 
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (puts, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} puts (@var{string})\n\
 Write a string to the standard output with no formatting.\n\
 \n\
 Return a non-negative number on success and EOF on error.\n\
 @seealso{fputs, disp}\n\
 @end deftypefn")
 {
   static std::string who = "puts";
@@ -1028,17 +1029,17 @@ Return a non-negative number on success 
     retval = stdout_stream.puts (args(0), who);
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (sprintf, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} sprintf (@var{template}, @dots{})\n\
 This is like @code{printf}, except that the output is returned as a\n\
 string.  Unlike the C library function, which requires you to provide a\n\
 suitably sized string as an argument, Octave's @code{sprintf} function\n\
 returns the string, automatically sized to hold all of the items\n\
 converted.\n\
 @seealso{printf, fprintf, sscanf}\n\
 @end deftypefn")
@@ -1088,17 +1089,17 @@ converted.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fscanf, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{val}, @var{count}, @var{errmsg}] =} fscanf (@var{fid}, @var{template}, @var{size})\n\
 @deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}, @var{errmsg}] =} fscanf (@var{fid}, @var{template}, \"C\")\n\
 In the first form, read from @var{fid} according to @var{template},\n\
 returning the result in the matrix @var{val}.\n\
 \n\
 The optional argument @var{size} specifies the amount of data to read\n\
 and may be one of\n\
 \n\
@@ -1173,18 +1174,19 @@ complete description of the syntax of th
 
           if (! error_state)
             {
               if (args(1).is_string ())
                 {
                   octave_idx_type count = 0;
 
                   Array<double> size = (nargin == 3)
-                    ? args(2).vector_value ()
-                    : Array<double> (dim_vector (1, 1), lo_ieee_inf_value ());
+                                       ? args(2).vector_value ()
+                                       : Array<double> (dim_vector (1, 1),
+                                                        lo_ieee_inf_value ());
 
                   if (! error_state)
                     {
                       octave_value tmp = os.scanf (args(1), size, count, who);
 
                       if (! error_state)
                         {
                           retval(2) = os.error ();
@@ -1217,17 +1219,17 @@ get_sscanf_data (const octave_value& val
     }
   else
     ::error ("sscanf: argument STRING must be a string");
 
   return retval;
 }
 
 DEFUN (sscanf, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{val}, @var{count}, @var{errmsg}, @var{pos}] =} sscanf (@var{string}, @var{template}, @var{size})\n\
 @deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}, @var{errmsg}] =} sscanf (@var{string}, @var{template}, \"C\")\n\
 This is like @code{fscanf}, except that the characters are taken from the\n\
 string @var{string} instead of from a stream.  Reaching the end of the\n\
 string is treated as an end-of-file condition.  In addition to the values\n\
 returned by @code{fscanf}, the index of the next character to be read\n\
 is returned in @var{pos}.\n\
 @seealso{fscanf, scanf, sprintf}\n\
@@ -1278,53 +1280,54 @@ is returned in @var{pos}.\n\
 
               if (os.is_valid ())
                 {
                   if (args(1).is_string ())
                     {
                       octave_idx_type count = 0;
 
                       Array<double> size = (nargin == 3)
-                        ? args(2).vector_value ()
-                        : Array<double> (dim_vector (1, 1),
-                                         lo_ieee_inf_value ());
+                                           ? args(2).vector_value ()
+                                           : Array<double> (dim_vector (1, 1),
+                                                            lo_ieee_inf_value ());
 
                       octave_value tmp = os.scanf (args(1), size, count, who);
 
                       if (! error_state)
                         {
-                          // FIXME -- is this the right thing to do?
+                          // FIXME: is this the right thing to do?
                           // Extract error message first, because getting
                           // position will clear it.
                           std::string errmsg = os.error ();
 
                           retval(3)
                             = (os.eof () ? data.length () : os.tell ()) + 1;
                           retval(2) = errmsg;
                           retval(1) = count;
                           retval(0) = tmp;
                         }
                     }
                   else
-                    ::error ("%s: format TEMPLATE must be a string", who.c_str ());
+                    ::error ("%s: format TEMPLATE must be a string",
+                             who.c_str ());
                 }
               else
                 ::error ("%s: unable to create temporary input buffer",
                          who.c_str  ());
             }
         }
       else
         print_usage ();
     }
 
   return retval;
 }
 
 DEFUN (scanf, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{val}, @var{count}, @var{errmsg}] =} scanf (@var{template}, @var{size})\n\
 @deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}, @var{errmsg}]] =} scanf (@var{template}, \"C\")\n\
 This is equivalent to calling @code{fscanf} with @var{fid} = @code{stdin}.\n\
 \n\
 It is currently not useful to call @code{scanf} in interactive\n\
 programs.\n\
 @seealso{fscanf, sscanf, printf}\n\
 @end deftypefn")
@@ -1395,17 +1398,17 @@ do_fread (octave_stream& os, const octav
     }
   else
     ::error ("fread: invalid SIZE specified");
 
   return retval;
 }
 
 DEFUN (fread, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{val}, @var{count}] =} fread (@var{fid}, @var{size}, @var{precision}, @var{skip}, @var{arch})\n\
 Read binary data of type @var{precision} from the specified file ID\n\
 @var{fid}.\n\
 \n\
 The optional argument @var{size} specifies the amount of data to read\n\
 and may be one of\n\
 \n\
 @table @code\n\
@@ -1656,17 +1659,17 @@ do_fwrite (octave_stream& os, const octa
     }
   else
     ::error ("fwrite: PRECISION must be a string");
 
   return retval;
 }
 
 DEFUN (fwrite, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{count} =} fwrite (@var{fid}, @var{data}, @var{precision}, @var{skip}, @var{arch})\n\
 Write data in binary form of type @var{precision} to the specified file\n\
 ID @var{fid}, returning the number of values successfully written to the\n\
 file.\n\
 \n\
 The argument @var{data} is a matrix of values that are to be written to\n\
 the file.  The values are extracted in column-major order.\n\
 \n\
@@ -1717,17 +1720,17 @@ are too large to fit in the specified pr
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("feof", Ffeof, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} feof (@var{fid})\n\
 Return 1 if an end-of-file condition has been encountered for a given\n\
 file and 0 otherwise.  Note that it will only return 1 if the end of the\n\
 file has already been encountered, not if the next read operation will\n\
 result in an end-of-file condition.\n\
 @seealso{fread, fopen}\n\
 @end deftypefn")
 {
@@ -1744,17 +1747,17 @@ result in an end-of-file condition.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("ferror", Fferror, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{err}, @var{msg}] =} ferror (@var{fid})\n\
 @deftypefnx {Built-in Function} {[@var{err}, @var{msg}] =} ferror (@var{fid}, \"clear\")\n\
 Return 1 if an error condition has been encountered for the file ID\n\
 @var{fid} and 0 otherwise.  Note that it will only return 1 if an error\n\
 has already been encountered, not if the next operation will result in\n\
 an error condition.\n\
 \n\
 The second argument is optional.  If it is supplied, also clear the\n\
@@ -1794,17 +1797,17 @@ error condition.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (popen, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{fid} =} popen (@var{command}, @var{mode})\n\
 Start a process and create a pipe.  The name of the command to run is\n\
 given by @var{command}.  The file identifier corresponding to the input\n\
 or output stream of the process is returned in @var{fid}.  The argument\n\
 @var{mode} may be\n\
 \n\
 @table @code\n\
 @item @qcode{\"r\"}\n\
@@ -1869,17 +1872,17 @@ endwhile\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("pclose", Fpclose, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} pclose (@var{fid})\n\
 Close a file identifier that was opened by @code{popen}.  You may also\n\
 use @code{fclose} for the same purpose.\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
@@ -1888,17 +1891,17 @@ use @code{fclose} for the same purpose.\
     retval = octave_stream_list::remove (args(0), "pclose");
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("tmpnam", Ftmpnam, args, ,
- "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @c List other forms of function in documentation index\n\
 @findex octave_tmp_file_name\n\
 \n\
 @deftypefn  {Built-in Function} {} tmpnam ()\n\
 @deftypefnx {Built-in Function} {} tmpnam (@var{dir})\n\
 @deftypefnx {Built-in Function} {} tmpnam (@var{dir}, @var{prefix})\n\
 Return a unique temporary file name as a string.\n\
 \n\
@@ -1936,17 +1939,17 @@ that it will not be available by the tim
     print_usage ();
 
   return retval;
 }
 
 DEFALIAS (octave_tmp_file_name, tmpnam);
 
 DEFUN (tmpfile, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{fid}, @var{msg}] =} tmpfile ()\n\
 Return the file ID corresponding to a new temporary file with a unique\n\
 name.  The file is opened in binary read/write (@qcode{\"w+b\"}) mode.\n\
 The file will be deleted automatically when it is closed or when Octave\n\
 exits.\n\
 \n\
 If successful, @var{fid} is a valid file ID and @var{msg} is an empty\n\
 string.  Otherwise, @var{fid} is -1 and @var{msg} contains a\n\
@@ -1987,17 +1990,17 @@ system-dependent error message.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (mkstemp, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{fid}, @var{name}, @var{msg}] =} mkstemp (@var{template}, @var{delete})\n\
 Return the file ID corresponding to a new temporary file with a unique\n\
 name created from @var{template}.  The last six characters of @var{template}\n\
 must be @code{XXXXXX} and these are replaced with a string that makes the\n\
 filename unique.  The file is then created with mode read/write and\n\
 permissions that are system dependent (on GNU/Linux systems, the permissions\n\
 will be 0600 for versions of glibc 2.0.7 and later).  The file is opened\n\
 in binary mode and with the @w{@code{O_EXCL}} flag.\n\
@@ -2102,17 +2105,17 @@ convert (int x, int ibase, int obase)
           mult *= ibase;
         }
     }
 
   return retval;
 }
 
 DEFUNX ("umask", Fumask, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} umask (@var{mask})\n\
 Set the permission mask for file creation.  The parameter @var{mask}\n\
 is an integer, interpreted as an octal number.  If successful,\n\
 returns the previous value of the mask (as an integer to be\n\
 interpreted as an octal number); otherwise an error message is printed.\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -2164,17 +2167,17 @@ const_value (const char *, const octave_
     retval = val;
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("P_tmpdir", FP_tmpdir, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} P_tmpdir ()\n\
 Return the default name of the directory for temporary files on\n\
 this system.  The name of this directory is system dependent.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
@@ -2186,17 +2189,17 @@ this system.  The name of this directory
 
   return retval;
 }
 
 // NOTE: the values of SEEK_SET, SEEK_CUR, and SEEK_END have to be
 // this way for Matlab compatibility.
 
 DEFUNX ("SEEK_SET", FSEEK_SET, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} SEEK_SET ()\n\
 @deftypefnx {Built-in Function} {} SEEK_CUR ()\n\
 @deftypefnx {Built-in Function} {} SEEK_END ()\n\
 Return the numerical value to pass to @code{fseek} to perform\n\
 one of the following actions:\n\
 \n\
 @table @code\n\
 @item SEEK_SET\n\
@@ -2210,28 +2213,28 @@ Position file relative to the end.\n\
 @end table\n\
 @seealso{fseek}\n\
 @end deftypefn")
 {
   return const_value ("SEEK_SET", args, -1);
 }
 
 DEFUNX ("SEEK_CUR", FSEEK_CUR, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} SEEK_CUR ()\n\
 Return the numerical value to pass to @code{fseek} to\n\
 position the file pointer relative to the current position.\n\
 @seealso{SEEK_SET, SEEK_END}.\n\
 @end deftypefn")
 {
   return const_value ("SEEK_CUR", args, 0);
 }
 
 DEFUNX ("SEEK_END", FSEEK_END, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} SEEK_END ()\n\
 Return the numerical value to pass to @code{fseek} to\n\
 position the file pointer relative to the end of the file.\n\
 @seealso{SEEK_SET, SEEK_CUR}.\n\
 @end deftypefn")
 {
   return const_value ("SEEK_END", args, 1);
 }
@@ -2248,40 +2251,40 @@ const_value (const char *, const octave_
     retval = val;
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("stdin", Fstdin, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} stdin ()\n\
 Return the numeric value corresponding to the standard input stream.\n\
 When Octave is used interactively, this is filtered through the command\n\
 line editing functions.\n\
 @seealso{stdout, stderr}\n\
 @end deftypefn")
 {
   return const_value ("stdin", args, stdin_file);
 }
 
 DEFUNX ("stdout", Fstdout, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} stdout ()\n\
 Return the numeric value corresponding to the standard output stream.\n\
 Data written to the standard output is normally filtered through the pager.\n\
 @seealso{stdin, stderr}\n\
 @end deftypefn")
 {
   return const_value ("stdout", args, stdout_file);
 }
 
 DEFUNX ("stderr", Fstderr, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} stderr ()\n\
 Return the numeric value corresponding to the standard error stream.\n\
 Even if paging is turned on, the standard error is not sent to the\n\
 pager.  It is useful for error messages and prompts.\n\
 @seealso{stdin, stdout}\n\
 @end deftypefn")
 {
   return const_value ("stderr", args, stderr_file);
diff --git a/libinterp/corefcn/filter.cc b/libinterp/corefcn/filter.cc
--- a/libinterp/corefcn/filter.cc
+++ b/libinterp/corefcn/filter.cc
@@ -44,17 +44,18 @@ filter (MArray<double>&, MArray<double>&
 
 extern MArray<Complex>
 filter (MArray<Complex>&, MArray<Complex>&, MArray<Complex>&, int dim);
 
 extern MArray<float>
 filter (MArray<float>&, MArray<float>&, MArray<float>&, int dim);
 
 extern MArray<FloatComplex>
-filter (MArray<FloatComplex>&, MArray<FloatComplex>&, MArray<FloatComplex>&, int dim);
+filter (MArray<FloatComplex>&, MArray<FloatComplex>&, MArray<FloatComplex>&,
+        int dim);
 #endif
 
 template <class T>
 MArray<T>
 filter (MArray<T>& b, MArray<T>& a, MArray<T>& x, MArray<T>& si,
         int dim = 0)
 {
   MArray<T> y;
@@ -164,17 +165,19 @@ filter (MArray<T>& b, MArray<T>& a, MArr
           T *psi = si.fortran_vec ();
 
           const T *pa = a.data ();
           const T *pb = b.data ();
           const T *px = x.data ();
 
           psi += si_offset;
 
-          for (octave_idx_type i = 0, idx = x_offset; i < x_len; i++, idx += x_stride)
+          for (octave_idx_type i = 0, idx = x_offset;
+               i < x_len;
+               i++, idx += x_stride)
             {
               py[idx] = psi[0] + pb[0] * px[idx];
 
               if (si_len > 0)
                 {
                   for (octave_idx_type j = 0; j < si_len - 1; j++)
                     {
                       OCTAVE_QUIT;
@@ -197,17 +200,19 @@ filter (MArray<T>& b, MArray<T>& a, MArr
           T *py = y.fortran_vec ();
           T *psi = si.fortran_vec ();
 
           const T *pb = b.data ();
           const T *px = x.data ();
 
           psi += si_offset;
 
-          for (octave_idx_type i = 0, idx = x_offset; i < x_len; i++, idx += x_stride)
+          for (octave_idx_type i = 0, idx = x_offset;
+               i < x_len;
+               i++, idx += x_stride)
             {
               py[idx] = psi[0] + pb[0] * px[idx];
 
               if (si_len > 1)
                 {
                   for (octave_idx_type j = 0; j < si_len - 1; j++)
                     {
                       OCTAVE_QUIT;
@@ -259,39 +264,38 @@ filter (MArray<T>& b, MArray<T>& a, MArr
       // Find first non-singleton dimension
       while (dim < x_dims.length () && x_dims(dim) <= 1)
         dim++;
 
       // All dimensions singleton, pick first dimension
       if (dim == x_dims.length ())
         dim = 0;
     }
-  else
-    if (dim < 0 || dim > x_dims.length ())
-      {
-        error ("filter: DIM must be a valid dimension");
-        return MArray<T> ();
-      }
+  else if (dim < 0 || dim > x_dims.length ())
+    {
+      error ("filter: DIM must be a valid dimension");
+      return MArray<T> ();
+    }
 
   octave_idx_type a_len = a.length ();
   octave_idx_type b_len = b.length ();
 
   octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
   dim_vector si_dims = x.dims ();
   for (int i = dim; i > 0; i--)
     si_dims(i) = si_dims(i-1);
   si_dims(0) = si_len;
 
   MArray<T> si (si_dims, T (0.0));
 
   return filter (b, a, x, si, dim);
 }
 
 DEFUN (filter, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {y =} filter (@var{b}, @var{a}, @var{x})\n\
 @deftypefnx {Built-in Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, @var{si})\n\
 @deftypefnx {Built-in Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, [], @var{dim})\n\
 @deftypefnx {Built-in Function} {[@var{y}, @var{sf}] =} filter (@var{b}, @var{a}, @var{x}, @var{si}, @var{dim})\n\
 Return the solution to the following linear, time-invariant difference\n\
 equation:\n\
 @tex\n\
 $$\n\
@@ -653,17 +657,18 @@ filter (MArray<float>&, MArray<float>&, 
 template MArray<float>
 filter (MArray<float>&, MArray<float>&, MArray<float>&, int dim);
 
 template MArray<FloatComplex>
 filter (MArray<FloatComplex>&, MArray<FloatComplex>&, MArray<FloatComplex>&,
         MArray<FloatComplex>&, int dim);
 
 template MArray<FloatComplex>
-filter (MArray<FloatComplex>&, MArray<FloatComplex>&, MArray<FloatComplex>&, int dim);
+filter (MArray<FloatComplex>&, MArray<FloatComplex>&, MArray<FloatComplex>&,
+        int dim);
 
 /*
 %!shared a, b, x, r
 %!test
 %! a = [1 1];
 %! b = [1 1];
 %! x = zeros (1,10);  x(1) = 1;
 %! assert (filter (b,   [1], x  ), [1 1 0 0 0 0 0 0 0 0]);
diff --git a/libinterp/corefcn/find.cc b/libinterp/corefcn/find.cc
--- a/libinterp/corefcn/find.cc
+++ b/libinterp/corefcn/find.cc
@@ -328,17 +328,17 @@ find_nonzero_elem_idx (const PermMatrix&
       panic_impossible ();
       break;
     }
 
   return retval;
 }
 
 DEFUN (find, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{idx} =} find (@var{x})\n\
 @deftypefnx {Built-in Function} {@var{idx} =} find (@var{x}, @var{n})\n\
 @deftypefnx {Built-in Function} {@var{idx} =} find (@var{x}, @var{n}, @var{direction})\n\
 @deftypefnx {Built-in Function} {[i, j] =} find (@dots{})\n\
 @deftypefnx {Built-in Function} {[i, j, v] =} find (@dots{})\n\
 Return a vector of indices of nonzero elements of a matrix, as a row if\n\
 @var{x} is a row vector or as a column otherwise.  To obtain a single index\n\
 for each matrix element, Octave pretends that the columns of a matrix form\n\
diff --git a/libinterp/corefcn/gammainc.cc b/libinterp/corefcn/gammainc.cc
--- a/libinterp/corefcn/gammainc.cc
+++ b/libinterp/corefcn/gammainc.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN (gammainc, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Mapping Function} {} gammainc (@var{x}, @var{a})\n\
 @deftypefnx {Mapping Function} {} gammainc (@var{x}, @var{a}, \"lower\")\n\
 @deftypefnx {Mapping Function} {} gammainc (@var{x}, @var{a}, \"upper\")\n\
 Compute the normalized incomplete gamma function,\n\
 @tex\n\
 $$\n\
  \\gamma (x, a) = {1 \\over {\\Gamma (a)}}\\displaystyle{\\int_0^x t^{a-1} e^{-t} dt}\n\
 $$\n\
@@ -111,49 +111,53 @@ gammainc (@var{x}, @var{a}) @equiv{} 1 -
               if (! error_state)
                 {
                   if (a_arg.is_scalar_type ())
                     {
                       float a = a_arg.float_value ();
 
                       if (! error_state)
                         retval = lower ? gammainc (x, a)
-                          : static_cast<float>(1) - gammainc (x, a);
+                                       : static_cast<float>(1)
+                                         - gammainc (x, a);
                     }
                   else
                     {
                       FloatNDArray a = a_arg.float_array_value ();
 
                       if (! error_state)
                         retval = lower ? gammainc (x, a)
-                          : static_cast<float>(1) - gammainc (x, a);
+                                       : static_cast<float>(1)
+                                         - gammainc (x, a);
                     }
                 }
             }
           else
             {
               FloatNDArray x = x_arg.float_array_value ();
 
               if (! error_state)
                 {
                   if (a_arg.is_scalar_type ())
                     {
                       float a = a_arg.float_value ();
 
                       if (! error_state)
                         retval = lower ? gammainc (x, a)
-                          : static_cast<float>(1) - gammainc (x, a);
+                                       : static_cast<float>(1)
+                                         - gammainc (x, a);
                     }
                   else
                     {
                       FloatNDArray a = a_arg.float_array_value ();
 
                       if (! error_state)
                         retval = lower ? gammainc (x, a)
-                          : static_cast<float>(1) - gammainc (x, a);
+                                       : static_cast<float>(1)
+                                         - gammainc (x, a);
                     }
                 }
             }
         }
       else
         {
           if (x_arg.is_scalar_type ())
             {
@@ -219,12 +223,12 @@ gammainc (@var{x}, @var{a}) @equiv{} 1 -
 
 %!test
 %! a = single ([.5 .5 .5 .5 .5]);
 %! x = single ([0 1 2 3 4]);
 %! v1 = sqrt (pi ("single"))*erf (x)./gamma (a);
 %! v3 = gammainc (x.*x, a);
 %! assert (v1, v3, sqrt (eps ("single")));
 
-%!assert (gammainc (single (0:4), single (0.5), "upper"), 
+%!assert (gammainc (single (0:4), single (0.5), "upper"),
 %!        single (1)-gammainc (single (0:4), single (0.5)),
 %!        single (1e-7))
 */
diff --git a/libinterp/corefcn/gcd.cc b/libinterp/corefcn/gcd.cc
--- a/libinterp/corefcn/gcd.cc
+++ b/libinterp/corefcn/gcd.cc
@@ -428,17 +428,17 @@ do_extended_gcd (const octave_value& a, 
       x = x.float_array_value ();
       y = y.float_array_value ();
     }
 
   return retval;
 }
 
 DEFUN (gcd, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{g} =} gcd (@var{a1}, @var{a2}, @dots{})\n\
 @deftypefnx {Built-in Function} {[@var{g}, @var{v1}, @dots{}] =} gcd (@var{a1}, @var{a2}, @dots{})\n\
 \n\
 Compute the greatest common divisor of @var{a1}, @var{a2}, @dots{}.  If more\n\
 than one argument is given all arguments must be the same size or scalar.\n\
 In this case the greatest common divisor is calculated for each element\n\
 individually.  All elements must be ordinary or Gaussian (complex)\n\
 integers.  Note that for Gaussian integers, the gcd is not unique up to\n\
diff --git a/libinterp/corefcn/getgrent.cc b/libinterp/corefcn/getgrent.cc
--- a/libinterp/corefcn/getgrent.cc
+++ b/libinterp/corefcn/getgrent.cc
@@ -58,17 +58,17 @@ mk_gr_map (const octave_group& gr)
     }
   else
     retval = 0;
 
   return retval;
 }
 
 DEFUN (getgrent, args, ,
- "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{grp_struct} =} getgrent ()\n\
 Return an entry from the group database, opening it if necessary.\n\
 Once the end of data has been reached, @code{getgrent} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
@@ -85,17 +85,17 @@ Once the end of data has been reached, @
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (getgrgid, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{grp_struct} =} getgrgid (@var{gid}).\n\
 Return the first entry from the group database with the group ID\n\
 @var{gid}.  If the group ID does not exist in the database,\n\
 @code{getgrgid} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
@@ -125,17 +125,17 @@ Return the first entry from the group da
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (getgrnam, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{grp_struct} =} getgrnam (@var{name})\n\
 Return the first entry from the group database with the group name\n\
 @var{name}.  If the group name does not exist in the database,\n\
 @code{getgrnam} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
@@ -158,17 +158,17 @@ Return the first entry from the group da
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (setgrent, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} setgrent ()\n\
 Return the internal pointer to the beginning of the group database.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1.0;
@@ -184,17 +184,17 @@ Return the internal pointer to the begin
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (endgrent, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} endgrent ()\n\
 Close the group database.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1.0;
diff --git a/libinterp/corefcn/getpwent.cc b/libinterp/corefcn/getpwent.cc
--- a/libinterp/corefcn/getpwent.cc
+++ b/libinterp/corefcn/getpwent.cc
@@ -61,17 +61,17 @@ mk_pw_map (const octave_passwd& pw)
     }
   else
     retval = 0;
 
   return retval;
 }
 
 DEFUN (getpwent, args, ,
- "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{pw_struct} =} getpwent ()\n\
 Return a structure containing an entry from the password database,\n\
 opening it if necessary.  Once the end of the data has been reached,\n\
 @code{getpwent} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
@@ -89,17 +89,17 @@ opening it if necessary.  Once the end o
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (getpwuid, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{pw_struct} =} getpwuid (@var{uid}).\n\
 Return a structure containing the first entry from the password database\n\
 with the user ID @var{uid}.  If the user ID does not exist in the\n\
 database, @code{getpwuid} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
@@ -129,17 +129,17 @@ database, @code{getpwuid} returns 0.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (getpwnam, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{pw_struct} =} getpwnam (@var{name})\n\
 Return a structure containing the first entry from the password database\n\
 with the user name @var{name}.  If the user name does not exist in the\n\
 database, @code{getpwname} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
@@ -162,17 +162,17 @@ database, @code{getpwname} returns 0.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (setpwent, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} setpwent ()\n\
 Return the internal pointer to the beginning of the password database.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1.0;
@@ -188,17 +188,17 @@ Return the internal pointer to the begin
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (endpwent, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} endpwent ()\n\
 Close the password database.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1.0;
diff --git a/libinterp/corefcn/getrusage.cc b/libinterp/corefcn/getrusage.cc
--- a/libinterp/corefcn/getrusage.cc
+++ b/libinterp/corefcn/getrusage.cc
@@ -55,17 +55,17 @@ along with Octave; see the file COPYING.
 
 #ifndef RUSAGE_SELF
 #define RUSAGE_SELF 0
 #endif
 
 // System resource functions.
 
 DEFUN (getrusage, , ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} getrusage ()\n\
 Return a structure containing a number of statistics about the current\n\
 Octave process.  Not all fields are available on all systems.  If it is\n\
 not possible to get CPU time statistics, the CPU time slots are set to\n\
 zero.  Other missing data are replaced by NaN@.  The list of possible\n\
 fields is:\n\
 \n\
 @table @code\n\
@@ -119,17 +119,17 @@ elements @code{sec} (seconds) @code{usec
 A structure containing the user CPU time used.  The structure has the\n\
 elements @code{sec} (seconds) @code{usec} (microseconds).\n\
 @end table\n\
 @end deftypefn")
 {
   octave_scalar_map m;
   octave_scalar_map tv_tmp;
 
-  // FIXME -- maybe encapsulate all of this in a liboctave class
+  // FIXME: maybe encapsulate all of this in a liboctave class
 #if defined (HAVE_GETRUSAGE)
 
   struct rusage ru;
 
   getrusage (RUSAGE_SELF, &ru);
 
   tv_tmp.assign ("sec", static_cast<double> (ru.ru_utime.tv_sec));
   tv_tmp.assign ("usec", static_cast<double> (ru.ru_utime.tv_usec));
diff --git a/libinterp/corefcn/givens.cc b/libinterp/corefcn/givens.cc
--- a/libinterp/corefcn/givens.cc
+++ b/libinterp/corefcn/givens.cc
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 
 DEFUN (givens, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{g} =} givens (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {[@var{c}, @var{s}] =} givens (@var{x}, @var{y})\n\
 @tex\n\
 Return a $2\\times 2$ orthogonal matrix\n\
 $$\n\
  G = \\left[\\matrix{c & s\\cr -s'& c\\cr}\\right]\n\
 $$\n\
 such that\n\
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -57,26 +57,26 @@ protected:
     { }
 
     texture_rep (GLuint id_arg, int w_arg, int h_arg, int tw_arg, int th_arg)
       : id (id_arg), w (w_arg), h (h_arg), tw (tw_arg), th (th_arg),
         tx (double(w)/tw), ty (double(h)/th), valid (true),
         count (1) { }
 
     ~texture_rep (void)
-      {
-        if (valid)
-          glDeleteTextures (1, &id);
-      }
+    {
+      if (valid)
+        glDeleteTextures (1, &id);
+    }
 
     void bind (int mode) const
-      { if (valid) glBindTexture (mode, id); }
+    { if (valid) glBindTexture (mode, id); }
 
     void tex_coord (double q, double r) const
-      { if (valid) glTexCoord2d (q*tx, r*ty); }
+    { if (valid) glTexCoord2d (q*tx, r*ty); }
 
     GLuint id;
     int w, h;
     int tw, th;
     double tx, ty;
     bool valid;
     octave_refcount<int> count;
   };
@@ -86,47 +86,47 @@ protected:
 private:
   opengl_texture (texture_rep *_rep) : rep (_rep) { }
 
 public:
   opengl_texture (void) : rep (new texture_rep ()) { }
 
   opengl_texture (const opengl_texture& tx)
     : rep (tx.rep)
-    {
-      rep->count++;
-    }
+  {
+    rep->count++;
+  }
 
   ~opengl_texture (void)
-    {
-      if (--rep->count == 0)
-        delete rep;
-    }
+  {
+    if (--rep->count == 0)
+      delete rep;
+  }
 
   opengl_texture& operator = (const opengl_texture& tx)
-    {
-      if (--rep->count == 0)
-        delete rep;
-
-      rep = tx.rep;
-      rep->count++;
-
-      return *this;
-    }
+  {
+    if (--rep->count == 0)
+      delete rep;
+
+    rep = tx.rep;
+    rep->count++;
+
+    return *this;
+  }
 
   static opengl_texture create (const octave_value& data);
 
   void bind (int mode = GL_TEXTURE_2D) const
-    { rep->bind (mode); }
+  { rep->bind (mode); }
 
   void tex_coord (double q, double r) const
-    { rep->tex_coord (q, r); }
+  { rep->tex_coord (q, r); }
 
   bool is_valid (void) const
-    { return rep->valid; }
+  { return rep->valid; }
 };
 
 static int
 next_power_of_2 (int n)
 {
   int m = 1;
 
   while (m < n && m < std::numeric_limits<int>::max ())
@@ -227,92 +227,92 @@ public:
   typedef void (CALLBACK *fcn) (void);
 #endif
 
 public:
 
   opengl_tesselator (void) : glu_tess (0), fill () { init (); }
 
   virtual ~opengl_tesselator (void)
-    { if (glu_tess) gluDeleteTess (glu_tess); }
+  { if (glu_tess) gluDeleteTess (glu_tess); }
 
   void begin_polygon (bool filled = true)
-    {
-      gluTessProperty (glu_tess, GLU_TESS_BOUNDARY_ONLY,
-                       (filled ? GL_FALSE : GL_TRUE));
-      fill = filled;
-      gluTessBeginPolygon (glu_tess, this);
-    }
+  {
+    gluTessProperty (glu_tess, GLU_TESS_BOUNDARY_ONLY,
+                     (filled ? GL_FALSE : GL_TRUE));
+    fill = filled;
+    gluTessBeginPolygon (glu_tess, this);
+  }
 
   void end_polygon (void) const
-    { gluTessEndPolygon (glu_tess); }
+  { gluTessEndPolygon (glu_tess); }
 
   void begin_contour (void) const
-    { gluTessBeginContour (glu_tess); }
+  { gluTessBeginContour (glu_tess); }
 
   void end_contour (void) const
-    { gluTessEndContour (glu_tess); }
+  { gluTessEndContour (glu_tess); }
 
   void add_vertex (double *loc, void *data) const
-    { gluTessVertex (glu_tess, loc, data); }
+  { gluTessVertex (glu_tess, loc, data); }
 
 protected:
   virtual void begin (GLenum /*type*/) { }
 
   virtual void end (void) { }
 
   virtual void vertex (void * /*data*/) { }
 
   virtual void combine (GLdouble [3] /*c*/, void * [4] /*data*/,
                         GLfloat  [4] /*w*/, void ** /*out_data*/) { }
 
   virtual void edge_flag (GLboolean /*flag*/) { }
 
   virtual void error (GLenum err)
-    { ::error ("OpenGL tesselation error (%d)", err); }
+  { ::error ("OpenGL tesselation error (%d)", err); }
 
   virtual void init (void)
-    {
-      glu_tess = gluNewTess ();
-
-      gluTessCallback (glu_tess, GLU_TESS_BEGIN_DATA,
-                       reinterpret_cast<fcn> (tess_begin));
-      gluTessCallback (glu_tess, GLU_TESS_END_DATA,
-                       reinterpret_cast<fcn> (tess_end));
-      gluTessCallback (glu_tess, GLU_TESS_VERTEX_DATA,
-                       reinterpret_cast<fcn> (tess_vertex));
-      gluTessCallback (glu_tess, GLU_TESS_COMBINE_DATA,
-                       reinterpret_cast<fcn> (tess_combine));
-      gluTessCallback (glu_tess, GLU_TESS_EDGE_FLAG_DATA,
-                       reinterpret_cast<fcn> (tess_edge_flag));
-      gluTessCallback (glu_tess, GLU_TESS_ERROR_DATA,
-                       reinterpret_cast<fcn> (tess_error));
-    }
+  {
+    glu_tess = gluNewTess ();
+
+    gluTessCallback (glu_tess, GLU_TESS_BEGIN_DATA,
+                     reinterpret_cast<fcn> (tess_begin));
+    gluTessCallback (glu_tess, GLU_TESS_END_DATA,
+                     reinterpret_cast<fcn> (tess_end));
+    gluTessCallback (glu_tess, GLU_TESS_VERTEX_DATA,
+                     reinterpret_cast<fcn> (tess_vertex));
+    gluTessCallback (glu_tess, GLU_TESS_COMBINE_DATA,
+                     reinterpret_cast<fcn> (tess_combine));
+    gluTessCallback (glu_tess, GLU_TESS_EDGE_FLAG_DATA,
+                     reinterpret_cast<fcn> (tess_edge_flag));
+    gluTessCallback (glu_tess, GLU_TESS_ERROR_DATA,
+                     reinterpret_cast<fcn> (tess_error));
+  }
 
   bool is_filled (void) const { return fill; }
 
 private:
   static void CALLBACK tess_begin (GLenum type, void *t)
-    { reinterpret_cast<opengl_tesselator *> (t)->begin (type); }
+  { reinterpret_cast<opengl_tesselator *> (t)->begin (type); }
 
   static void CALLBACK tess_end (void *t)
-    { reinterpret_cast<opengl_tesselator *> (t)->end (); }
+  { reinterpret_cast<opengl_tesselator *> (t)->end (); }
 
   static void CALLBACK tess_vertex (void *v, void *t)
-    { reinterpret_cast<opengl_tesselator *> (t)->vertex (v); }
+  { reinterpret_cast<opengl_tesselator *> (t)->vertex (v); }
 
   static void CALLBACK tess_combine (GLdouble c[3], void *v[4], GLfloat w[4],
                                      void **out,  void *t)
-    { reinterpret_cast<opengl_tesselator *> (t)->combine (c, v, w, out); }
+  { reinterpret_cast<opengl_tesselator *> (t)->combine (c, v, w, out); }
 
   static void CALLBACK tess_edge_flag (GLboolean flag, void *t)
-    { reinterpret_cast<opengl_tesselator *> (t)->edge_flag (flag); }
+  { reinterpret_cast<opengl_tesselator *> (t)->edge_flag (flag); }
 
   static void CALLBACK tess_error (GLenum err, void *t)
-    { reinterpret_cast<opengl_tesselator *> (t)->error (err); }
+  { reinterpret_cast<opengl_tesselator *> (t)->error (err); }
 
 private:
 
   // No copying!
 
   opengl_tesselator (const opengl_tesselator&);
 
   opengl_tesselator operator = (const opengl_tesselator&);
@@ -350,181 +350,181 @@ public:
         ambient (as), diffuse (ds), specular (ss), specular_exp (se),
         count (1) { }
   };
 
 private:
   vertex_data_rep *rep;
 
   vertex_data_rep *nil_rep (void) const
-    {
-      static vertex_data_rep *nr = new vertex_data_rep ();
-
-      return nr;
-    }
+  {
+    static vertex_data_rep *nr = new vertex_data_rep ();
+
+    return nr;
+  }
 
 public:
   vertex_data (void) : rep (nil_rep ())
-    { rep->count++; }
+  { rep->count++; }
 
   vertex_data (const vertex_data& v) : rep (v.rep)
-    { rep->count++; }
+  { rep->count++; }
 
   vertex_data (const Matrix& c, const Matrix& col, const Matrix& n,
                double a, float as, float ds, float ss, float se)
     : rep (new vertex_data_rep (c, col, n, a, as, ds, ss, se))
-    { }
+  { }
 
   vertex_data (vertex_data_rep *new_rep)
     : rep (new_rep) { }
 
   ~vertex_data (void)
-    {
-      if (--rep->count == 0)
-        delete rep;
-    }
+  {
+    if (--rep->count == 0)
+      delete rep;
+  }
 
   vertex_data& operator = (const vertex_data& v)
-    {
-      if (--rep->count == 0)
-        delete rep;
-
-      rep = v.rep;
-      rep->count++;
-
-      return *this;
-    }
+  {
+    if (--rep->count == 0)
+      delete rep;
+
+    rep = v.rep;
+    rep->count++;
+
+    return *this;
+  }
 
   vertex_data_rep *get_rep (void) const { return rep; }
 };
 
 class
 opengl_renderer::patch_tesselator : public opengl_tesselator
 {
 public:
   patch_tesselator (opengl_renderer *r, int cmode, int lmode, int idx = 0)
     : opengl_tesselator (), renderer (r),
       color_mode (cmode), light_mode (lmode), index (idx),
       first (true), tmp_vdata ()
   { }
 
 protected:
   void begin (GLenum type)
-    {
-      //printf ("patch_tesselator::begin (%d)\n", type);
-      first = true;
-
-      if (color_mode == 2 || light_mode == 2)
-        glShadeModel (GL_SMOOTH);
-      else
-        glShadeModel (GL_FLAT);
-
-      if (is_filled ())
-        renderer->set_polygon_offset (true, 1+index);
-
-      glBegin (type);
-    }
+  {
+    //printf ("patch_tesselator::begin (%d)\n", type);
+    first = true;
+
+    if (color_mode == 2 || light_mode == 2)
+      glShadeModel (GL_SMOOTH);
+    else
+      glShadeModel (GL_FLAT);
+
+    if (is_filled ())
+      renderer->set_polygon_offset (true, 1+index);
+
+    glBegin (type);
+  }
 
   void end (void)
-    {
-      //printf ("patch_tesselator::end\n");
-      glEnd ();
-      renderer->set_polygon_offset (false);
-    }
+  {
+    //printf ("patch_tesselator::end\n");
+    glEnd ();
+    renderer->set_polygon_offset (false);
+  }
 
   void vertex (void *data)
-    {
-      vertex_data::vertex_data_rep *v
-          = reinterpret_cast<vertex_data::vertex_data_rep *> (data);
-      //printf ("patch_tesselator::vertex (%g, %g, %g)\n", v->coords(0), v->coords(1), v->coords(2));
-
-      // FIXME: why did I need to keep the first vertex of the face
-      // in JHandles? I think it's related to the fact that the
-      // tessellation process might re-order the vertices, such that
-      // the first one you get here might not be the first one of the face;
-      // but I can't figure out the actual reason.
-      if (color_mode > 0 && (first || color_mode == 2))
-        {
-          Matrix col = v->color;
-
-          if (col.numel () == 3)
-            {
-              glColor3dv (col.data ());
-              if (light_mode > 0)
-                {
-                  float buf[4] = { 0, 0, 0, 1 };
-
-                  for (int k = 0; k < 3; k++)
-                    buf[k] = (v->ambient * col(k));
-                  glMaterialfv (LIGHT_MODE, GL_AMBIENT, buf);
-
-                  for (int k = 0; k < 3; k++)
-                    buf[k] = (v->diffuse * col(k));
-                  glMaterialfv (LIGHT_MODE, GL_AMBIENT, buf);
-                }
-            }
-        }
-
-      if (light_mode > 0 && (first || light_mode == 2))
-        glNormal3dv (v->normal.data ());
-
-      glVertex3dv (v->coords.data ());
-
-      first = false;
-    }
+  {
+    vertex_data::vertex_data_rep *v
+      = reinterpret_cast<vertex_data::vertex_data_rep *> (data);
+    //printf ("patch_tesselator::vertex (%g, %g, %g)\n", v->coords(0), v->coords(1), v->coords(2));
+
+    // FIXME: why did I need to keep the first vertex of the face
+    // in JHandles? I think it's related to the fact that the
+    // tessellation process might re-order the vertices, such that
+    // the first one you get here might not be the first one of the face;
+    // but I can't figure out the actual reason.
+    if (color_mode > 0 && (first || color_mode == 2))
+      {
+        Matrix col = v->color;
+
+        if (col.numel () == 3)
+          {
+            glColor3dv (col.data ());
+            if (light_mode > 0)
+              {
+                float buf[4] = { 0, 0, 0, 1 };
+
+                for (int k = 0; k < 3; k++)
+                  buf[k] = (v->ambient * col(k));
+                glMaterialfv (LIGHT_MODE, GL_AMBIENT, buf);
+
+                for (int k = 0; k < 3; k++)
+                  buf[k] = (v->diffuse * col(k));
+                glMaterialfv (LIGHT_MODE, GL_AMBIENT, buf);
+              }
+          }
+      }
+
+    if (light_mode > 0 && (first || light_mode == 2))
+      glNormal3dv (v->normal.data ());
+
+    glVertex3dv (v->coords.data ());
+
+    first = false;
+  }
 
   void combine (GLdouble xyz[3], void *data[4], GLfloat w[4],
                 void **out_data)
-    {
-      //printf ("patch_tesselator::combine\n");
-
-      vertex_data::vertex_data_rep *v[4];
-      int vmax = 4;
-
-      for (int i = 0; i < 4; i++)
-        {
-          v[i] = reinterpret_cast<vertex_data::vertex_data_rep *> (data[i]);
-
-          if (vmax == 4 && ! v[i])
-            vmax = i;
-        }
-
-      Matrix vv (1, 3, 0.0);
-      Matrix cc;
-      Matrix nn (1, 3, 0.0);
-      double aa = 0.0;
-
-      vv(0) = xyz[0];
-      vv(1) = xyz[1];
-      vv(2) = xyz[2];
-
-      if (v[0]->color.numel ())
-        {
-          cc.resize (1, 3, 0.0);
-          for (int ic = 0; ic < 3; ic++)
-            for (int iv = 0; iv < vmax; iv++)
-              cc(ic) += (w[iv] * v[iv]->color (ic));
-        }
-
-      if (v[0]->normal.numel () > 0)
-        {
-          for (int in = 0; in < 3; in++)
-            for (int iv = 0; iv < vmax; iv++)
-              nn(in) += (w[iv] * v[iv]->normal (in));
-        }
-
-      for (int iv = 0; iv < vmax; iv++)
-        aa += (w[iv] * v[iv]->alpha);
-
-      vertex_data new_v (vv, cc, nn, aa, v[0]->ambient, v[0]->diffuse,
-                         v[0]->specular, v[0]->specular_exp);
-      tmp_vdata.push_back (new_v);
-
-      *out_data = new_v.get_rep ();
-    }
+  {
+    //printf ("patch_tesselator::combine\n");
+
+    vertex_data::vertex_data_rep *v[4];
+    int vmax = 4;
+
+    for (int i = 0; i < 4; i++)
+      {
+        v[i] = reinterpret_cast<vertex_data::vertex_data_rep *> (data[i]);
+
+        if (vmax == 4 && ! v[i])
+          vmax = i;
+      }
+
+    Matrix vv (1, 3, 0.0);
+    Matrix cc;
+    Matrix nn (1, 3, 0.0);
+    double aa = 0.0;
+
+    vv(0) = xyz[0];
+    vv(1) = xyz[1];
+    vv(2) = xyz[2];
+
+    if (v[0]->color.numel ())
+      {
+        cc.resize (1, 3, 0.0);
+        for (int ic = 0; ic < 3; ic++)
+          for (int iv = 0; iv < vmax; iv++)
+            cc(ic) += (w[iv] * v[iv]->color (ic));
+      }
+
+    if (v[0]->normal.numel () > 0)
+      {
+        for (int in = 0; in < 3; in++)
+          for (int iv = 0; iv < vmax; iv++)
+            nn(in) += (w[iv] * v[iv]->normal (in));
+      }
+
+    for (int iv = 0; iv < vmax; iv++)
+      aa += (w[iv] * v[iv]->alpha);
+
+    vertex_data new_v (vv, cc, nn, aa, v[0]->ambient, v[0]->diffuse,
+                       v[0]->specular, v[0]->specular_exp);
+    tmp_vdata.push_back (new_v);
+
+    *out_data = new_v.get_rep ();
+  }
 
 private:
 
   // No copying!
 
   patch_tesselator (const patch_tesselator&);
 
   patch_tesselator& operator = (const patch_tesselator&);
@@ -595,17 +595,17 @@ opengl_renderer::draw_figure (const figu
 void
 opengl_renderer::draw_uipanel (const uipanel::properties& props,
                                const graphics_object& go)
 {
   graphics_object fig = go.get_ancestor ("figure");
   const figure::properties& figProps =
     dynamic_cast<const figure::properties&> (fig.get_properties ());
 
-  // Initialize OpenGL context 
+  // Initialize OpenGL context
 
   init_gl_context (figProps.is___enhanced__ (),
                    props.get_backgroundcolor_rgb ());
 
   // Draw children
 
   draw (props.get_all_children (), false);
 }
@@ -991,17 +991,18 @@ opengl_renderer::draw_axes_x_grid (const
 
   // X grid
 
   if (props.is_visible () && xstate != AXE_DEPTH_DIR)
     {
       std::string gridstyle = props.get_gridlinestyle ();
       std::string minorgridstyle = props.get_minorgridlinestyle ();
       bool do_xgrid = (props.is_xgrid () && (gridstyle != "none"));
-      bool do_xminorgrid = (props.is_xminorgrid () && (minorgridstyle != "none"));
+      bool do_xminorgrid = (props.is_xminorgrid ()
+                            && (minorgridstyle != "none"));
       bool do_xminortick = props.is_xminortick ();
       Matrix xticks = xform.xscale (props.get_xtick ().matrix_value ());
       Matrix xmticks = xform.xscale (props.get_xmtick ().matrix_value ());
       string_vector xticklabels = props.get_xticklabel ().all_strings ();
       int wmax = 0, hmax = 0;
       bool tick_along_z = nearhoriz || xisinf (fy);
       bool mirror = props.is_box () && xstate != AXE_ANY_DIR;
 
@@ -1098,17 +1099,18 @@ opengl_renderer::draw_axes_y_grid (const
 
   // Y grid
 
   if (ystate != AXE_DEPTH_DIR && props.is_visible ())
     {
       std::string gridstyle = props.get_gridlinestyle ();
       std::string minorgridstyle = props.get_minorgridlinestyle ();
       bool do_ygrid = (props.is_ygrid () && (gridstyle != "none"));
-      bool do_yminorgrid = (props.is_yminorgrid () && (minorgridstyle != "none"));
+      bool do_yminorgrid = (props.is_yminorgrid ()
+                            && (minorgridstyle != "none"));
       bool do_yminortick = props.is_yminortick ();
       Matrix yticks = xform.yscale (props.get_ytick ().matrix_value ());
       Matrix ymticks = xform.yscale (props.get_ymtick ().matrix_value ());
       string_vector yticklabels = props.get_yticklabel ().all_strings ();
       int wmax = 0, hmax = 0;
       bool tick_along_z = nearhoriz || xisinf (fx);
       bool mirror = props.is_box () && ystate != AXE_ANY_DIR
                     && (! props.has_property ("__plotyy_axes__"));
@@ -1196,17 +1198,18 @@ opengl_renderer::draw_axes_z_grid (const
 
   // Z Grid
 
   if (zstate != AXE_DEPTH_DIR && props.is_visible ())
     {
       std::string gridstyle = props.get_gridlinestyle ();
       std::string minorgridstyle = props.get_minorgridlinestyle ();
       bool do_zgrid = (props.is_zgrid () && (gridstyle != "none"));
-      bool do_zminorgrid = (props.is_zminorgrid () && (minorgridstyle != "none"));
+      bool do_zminorgrid = (props.is_zminorgrid ()
+                            && (minorgridstyle != "none"));
       bool do_zminortick = props.is_zminortick ();
       Matrix zticks = xform.zscale (props.get_ztick ().matrix_value ());
       Matrix zmticks = xform.zscale (props.get_zmtick ().matrix_value ());
       string_vector zticklabels = props.get_zticklabel ().all_strings ();
       int wmax = 0, hmax = 0;
       bool mirror = props.is_box () && zstate != AXE_ANY_DIR;
 
       set_color (props.get_zcolor_rgb ());
@@ -1398,20 +1401,20 @@ opengl_renderer::draw_axes (const axes::
   double x_max = props.get_x_max ();
   double y_min = props.get_y_min ();
   double y_max = props.get_y_max ();
   double z_min = props.get_z_min ();
   double z_max = props.get_z_max ();
 
   if (x_max > floatmax || y_max > floatmax || z_max > floatmax
       || x_min < -floatmax || y_min < -floatmax || z_min < -floatmax)
-  {
-    warning ("gl-render: data values greater than float capacity.  (1) Scale data, or (2) Use gnuplot");
-    return;
-  }
+    {
+      warning ("gl-render: data values greater than float capacity.  (1) Scale data, or (2) Use gnuplot");
+      return;
+    }
 
   setup_opengl_transformation (props);
 
   // draw axes object
 
   draw_axes_planes (props);
   draw_axes_boxes (props);
 
@@ -1431,17 +1434,19 @@ opengl_renderer::draw_axes (const axes::
 void
 opengl_renderer::draw_line (const line::properties& props)
 {
   Matrix x = xform.xscale (props.get_xdata ().matrix_value ());
   Matrix y = xform.yscale (props.get_ydata ().matrix_value ());
   Matrix z = xform.zscale (props.get_zdata ().matrix_value ());
 
   bool has_z = (z.numel () > 0);
-  int n = static_cast<int> (std::min (std::min (x.numel (), y.numel ()), (has_z ? z.numel () : std::numeric_limits<int>::max ())));
+  int n = static_cast<int> (std::min (std::min (x.numel (), y.numel ()),
+                                      (has_z ? z.numel ()
+                                             : std::numeric_limits<int>::max ())));
   octave_uint8 clip_mask = (props.is_clipping () ? 0x7F : 0x40), clip_ok (0x40);
 
   std::vector<octave_uint8> clip (n);
 
   if (has_z)
     for (int i = 0; i < n; i++)
       clip[i] = (clip_code (x(i), y(i), z(i)) & clip_mask);
   else
@@ -1579,17 +1584,18 @@ opengl_renderer::draw_surface (const sur
   int ec_mode = (props.edgecolor_is_rgb () ? 0 :
                  (props.edgecolor_is ("flat") ? 1 :
                   (props.edgecolor_is ("interp") ? 2 : -1)));
   int el_mode = (props.edgelighting_is ("none") ? 0 :
                  (props.edgelighting_is ("flat") ? 1 : 2));
   int ea_mode = (props.edgealpha_is_double () ? 0 :
                  (props.edgealpha_is ("flat") ? 1 : 2));
 
-  Matrix fcolor = (fc_mode == 3 ? Matrix (1, 3, 1.0) : props.get_facecolor_rgb ());
+  Matrix fcolor = (fc_mode == 3 ? Matrix (1, 3, 1.0)
+                                : props.get_facecolor_rgb ());
   Matrix ecolor = props.get_edgecolor_rgb ();
 
   float as = props.get_ambientstrength ();
   float ds = props.get_diffusestrength ();
   float ss = props.get_specularstrength ();
   float se = props.get_specularexponent ();
   float cb[4] = { 0.0, 0.0, 0.0, 1.0 };
   double d = 1.0;
@@ -1700,17 +1706,18 @@ opengl_renderer::draw_surface (const sur
                       j1 = j-1;
                       j2 = j;
                     }
 
                   glBegin (GL_QUADS);
 
                   // Vertex 1
                   if (fc_mode == 3)
-                    tex.tex_coord (double (i-1) / (zc-1), double (j-1) / (zr-1));
+                    tex.tex_coord (double (i-1) / (zc-1),
+                                   double (j-1) / (zr-1));
                   else if (fc_mode > 0)
                     {
                       // FIXME: is there a smarter way to do this?
                       for (int k = 0; k < 3; k++)
                         cb[k] = c(j-1, i-1, k);
                       glColor3fv (cb);
 
                       if (fl_mode > 0)
@@ -1724,17 +1731,19 @@ opengl_renderer::draw_surface (const sur
                           glMaterialfv (LIGHT_MODE, GL_DIFFUSE, cb);
                         }
                     }
                   if (fl_mode > 0)
                     {
                       d = sqrt (n(j-1,i-1,0) * n(j-1,i-1,0)
                                 + n(j-1,i-1,1) * n(j-1,i-1,1)
                                 + n(j-1,i-1,2) * n(j-1,i-1,2));
-                      glNormal3d (n(j-1,i-1,0)/d, n(j-1,i-1,1)/d, n(j-1,i-1,2)/d);
+                      glNormal3d (n(j-1,i-1,0)/d,
+                                  n(j-1,i-1,1)/d,
+                                  n(j-1,i-1,2)/d);
                     }
                   glVertex3d (x(j1,i-1), y(j-1,i1), z(j-1,i-1));
 
                   // Vertex 2
                   if (fc_mode == 3)
                     tex.tex_coord (double (i) / (zc-1), double (j-1) / (zr-1));
                   else if (fc_mode == 2)
                     {
@@ -2271,17 +2280,17 @@ opengl_renderer::draw_patch (const patch
           {
             if (has_facealpha)
               aa = a(i);
             else
               aa = a(idx);
           }
 
         vdata[i+j*fr] =
-            vertex_data (vv, cc, nn, aa, as, ds, ss, se);
+          vertex_data (vv, cc, nn, aa, as, ds, ss, se);
       }
 
   if (fl_mode > 0 || el_mode > 0)
     {
       float buf[4] = { ss, ss, ss, 1 };
 
       glMaterialfv (LIGHT_MODE, GL_SPECULAR, buf);
       glMaterialf (LIGHT_MODE, GL_SHININESS, se);
@@ -2382,17 +2391,18 @@ opengl_renderer::draw_patch (const patch
                 {
                   // This is an unclosed contour. Draw it as a line
                   bool flag = false;
 
                   for (int j = 0; j < count_f(i); j++)
                     {
                       if (! clip(int (f(i,j) - 1)))
                         {
-                          vertex_data::vertex_data_rep *vv = vdata[i+j*fr].get_rep ();
+                          vertex_data::vertex_data_rep *vv
+                            = vdata[i+j*fr].get_rep ();
                           const Matrix m = vv->coords;
                           if (! flag)
                             {
                               flag = true;
                               glBegin (GL_LINE_STRIP);
                             }
                           glVertex3d (m(0), m(1), m(2));
                         }
@@ -2408,17 +2418,18 @@ opengl_renderer::draw_patch (const patch
                 }
               else
                 {
                   tess.begin_polygon (false);
                   tess.begin_contour ();
 
                   for (int j = 0; j < count_f(i); j++)
                     {
-                      vertex_data::vertex_data_rep *vv = vdata[i+j*fr].get_rep ();
+                      vertex_data::vertex_data_rep *vv
+                        = vdata[i+j*fr].get_rep ();
                       tess.add_vertex (vv->coords.fortran_vec (), vv);
                     }
 
                   tess.end_contour ();
                   tess.end_polygon ();
                 }
             }
 
@@ -2429,18 +2440,19 @@ opengl_renderer::draw_patch (const patch
             glDisable (GL_LIGHTING);
         }
       else
         {
           // FIXME: implement transparency
         }
     }
 
-  if (! props.marker_is ("none") &&
-      ! (props.markeredgecolor_is ("none") && props.markerfacecolor_is ("none")))
+  if (! props.marker_is ("none")
+      && ! (props.markeredgecolor_is ("none")
+            && props.markerfacecolor_is ("none")))
     {
       bool do_edge = ! props.markeredgecolor_is ("none");
       bool do_face = ! props.markerfacecolor_is ("none");
 
       Matrix mecolor = props.get_markeredgecolor_rgb ();
       Matrix mfcolor = props.get_markerfacecolor_rgb ();
 
       bool has_markerfacecolor = false;
@@ -2450,29 +2462,29 @@ opengl_renderer::draw_patch (const patch
         {
           Matrix mc = props.get_color_data ().matrix_value ();
 
           if (mc.rows () == 1)
             {
               // Single color specifications, we can simplify a little bit
 
               if (mfcolor.numel () == 0
-                   && ! props.markerfacecolor_is ("none"))
+                  && ! props.markerfacecolor_is ("none"))
                 mfcolor = mc;
 
               if (mecolor.numel () == 0
-                   && ! props.markeredgecolor_is ("none"))
+                  && ! props.markeredgecolor_is ("none"))
                 mecolor = mc;
             }
           else
             {
               if (c.numel () == 0)
                 c = props.get_color_data ().matrix_value ();
               has_markerfacecolor = ((c.numel () > 0)
-                                    && (c.rows () == f.rows ()));
+                                     && (c.rows () == f.rows ()));
             }
         }
 
 
       init_marker (props.get_marker (), props.get_markersize (),
                    props.get_linewidth ());
 
       for (int i = 0; i < nf; i++)
@@ -2489,19 +2501,19 @@ opengl_renderer::draw_patch (const patch
                 cc.resize (1, 3);
                 if (has_markerfacecolor)
                   cc(0) = c(i,0), cc(1) = c(i,1), cc(2) = c(i,2);
                 else
                   cc(0) = c(idx,0), cc(1) = c(idx,1), cc(2) = c(idx,2);
               }
 
             Matrix lc = (do_edge ? (mecolor.numel () == 0 ? cc : mecolor)
-                         : Matrix ());
+                                 : Matrix ());
             Matrix fc = (do_face ? (mfcolor.numel () == 0 ? cc : mfcolor)
-                         : Matrix ());
+                                 : Matrix ());
 
             draw_marker (v(idx,0), v(idx,1), (has_z ? v(idx,2) : 0), lc, fc);
           }
 
       end_marker ();
     }
 }
 
@@ -2616,17 +2628,17 @@ opengl_renderer::draw_image (const image
         i0 += (ymin - im_ymin)/nor_dy + 1;
       if (im_ymax > ymax)
         i1 -= (im_ymax - ymax)/nor_dy;
     }
   else // clip to viewport
     {
       GLfloat vp[4];
       glGetFloatv (GL_VIEWPORT, vp);
-      // FIXME -- actually add the code to do it!
+      // FIXME: actually add the code to do it!
 
     }
 
   if (i0 >= i1 || j0 >= j1)
     return;
 
   glPixelZoom (pix_dx, -pix_dy);
   glRasterPos3d (im_xmin + nor_dx*j0, im_ymin + nor_dy*i0, 0);
@@ -3064,18 +3076,18 @@ opengl_renderer::text_to_pixels (const s
 #if HAVE_FREETYPE
   text_renderer.text_to_pixels (txt, pixels, bbox,
                                 halign, valign, rotation, "none");
 #endif
 }
 
 Matrix
 opengl_renderer::render_text (const std::string& txt,
-                            double x, double y, double z,
-                            int halign, int valign, double rotation)
+                              double x, double y, double z,
+                              int halign, int valign, double rotation)
 {
 #if HAVE_FREETYPE
   if (txt.empty ())
     return Matrix (1, 4, 0.0);
 
   uint8NDArray pixels;
   Matrix bbox;
   text_to_pixels (txt, pixels, bbox, halign, valign, rotation);
diff --git a/libinterp/corefcn/gl2ps-renderer.cc b/libinterp/corefcn/gl2ps-renderer.cc
--- a/libinterp/corefcn/gl2ps-renderer.cc
+++ b/libinterp/corefcn/gl2ps-renderer.cc
@@ -66,31 +66,33 @@ glps_renderer::draw (const graphics_obje
       if (term.find ("notxt") != std::string::npos) gl2ps_text = GL2PS_NO_TEXT;
 
       // Default sort order optimizes for 3D plots
       GLint gl2ps_sort = GL2PS_BSP_SORT;
       if (term.find ("is2D") != std::string::npos) gl2ps_sort = GL2PS_NO_SORT;
 
       while (state == GL2PS_OVERFLOW)
         {
-          // For LaTeX output the fltk print process uses two drawnow() commands.
-          // The first one is for the pdf/ps/eps graph to be included.  The print_cmd
-          // is saved as old_print_cmd.  Then the second drawnow() outputs the tex-file
-          // and the graphic filename to be included is extracted from old_print_cmd.
+          // For LaTeX output the fltk print process uses 2 drawnow() commands.
+          // The first one is for the pdf/ps/eps graph to be included.  The
+          // print_cmd is saved as old_print_cmd.  Then the second drawnow()
+          // outputs the tex-file and the graphic filename to be included is
+          // extracted from old_print_cmd.
           std::string include_graph;
           std::size_t found_redirect = old_print_cmd.find (">");
           if (found_redirect != std::string::npos)
             include_graph = old_print_cmd.substr (found_redirect + 1);
           else
             include_graph = old_print_cmd;
           std::size_t n_begin = include_graph.find_first_not_of (" ");
           if (n_begin != std::string::npos)
             {
               std::size_t n_end = include_graph.find_last_not_of (" ");
-              include_graph = include_graph.substr (n_begin, n_end - n_begin + 1);
+              include_graph = include_graph.substr (n_begin,
+                                                    n_end - n_begin + 1);
             }
           else
             include_graph = "foobar-inc";
           buffsize += 1024*1024;
           gl2psBeginPage ("glps_renderer figure", "Octave", viewport,
                           gl2ps_term, gl2ps_sort,
                           (GL2PS_SILENT | GL2PS_SIMPLE_LINE_OFFSET
                            | GL2PS_NO_BLENDING | GL2PS_OCCLUSION_CULL
@@ -178,17 +180,17 @@ glps_renderer::set_font (const base_prop
     fontname = "Courier";
   else if (fn == "symbol")
     fontname = "Symbol";
   else if (fn == "zapfdingbats")
     fontname = "ZapfDingbats";
   else
     fontname = "Helvetica";
 
-  // FIXME -- add support for bold and italic
+  // FIXME: add support for bold and italic
 }
 
 template <typename T>
 static void
 draw_pixels (GLsizei w, GLsizei h, GLenum format, const T *data)
 {
   OCTAVE_LOCAL_BUFFER (GLfloat, a, 3*w*h);
 
diff --git a/libinterp/corefcn/gl2ps-renderer.h b/libinterp/corefcn/gl2ps-renderer.h
--- a/libinterp/corefcn/gl2ps-renderer.h
+++ b/libinterp/corefcn/gl2ps-renderer.h
@@ -27,30 +27,28 @@ along with Octave; see the file COPYING.
 #include "gl2ps.h"
 
 class
 OCTINTERP_API
 glps_renderer : public opengl_renderer
 {
 public:
   glps_renderer (FILE *_fp, const std::string& _term)
-    : opengl_renderer () , fp (_fp), term (_term),
-    fontsize (), fontname () { }
+    : opengl_renderer () , fp (_fp), term (_term), fontsize (), fontname () { }
 
   ~glps_renderer (void) { }
 
   void draw (const graphics_object& go, const std::string print_cmd);
 
 protected:
 
   Matrix render_text (const std::string& txt,
                       double x, double y, double z,
                       int halign, int valign, double rotation = 0.0);
 
-
   void set_font (const base_properties& props);
 
   void draw_text (const text::properties& props);
   void draw_pixels (GLsizei w, GLsizei h, GLenum format,
                     GLenum type, const GLvoid *data);
 
   void set_linestyle (const std::string& s, bool use_stipple = false)
   {
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -132,17 +132,17 @@ validate_property_name (const std::strin
   return caseless_str ();
 }
 
 static Matrix
 jet_colormap (void)
 {
   Matrix cmap (64, 3, 0.0);
 
-  // Produce X in the same manner as linspace so that 
+  // Produce X in the same manner as linspace so that
   // jet_colormap and jet.m produce *exactly* the same result.
   double delta = 1.0 / 63.0;
 
   for (octave_idx_type i = 0; i < 64; i++)
     {
       // This is the jet colormap.  It would be nice to be able
       // to feval the jet function but since there is a static
       // property object that includes a colormap_property
@@ -446,17 +446,17 @@ convert_position (const Matrix& pos, con
     }
   else if (from_units.compare ("characters"))
     {
       if (res <= 0)
         res = xget (0, "screenpixelsperinch").double_value ();
 
       double f = 0.0;
 
-      // FIXME -- this assumes the system font is Helvetica 10pt
+      // FIXME: this assumes the system font is Helvetica 10pt
       //          (for which "x" requires 6x12 pixels at 74.951 pixels/inch)
       f = 12.0 * res / 74.951;
 
       if (f > 0)
         {
           retval(0) = 0.5 * pos(0) * f;
           retval(1) = pos(1) * f;
           if (is_rectangle)
@@ -574,17 +574,17 @@ convert_text_position (const Matrix& pos
   graphics_object go = gh_manager::get_object (props.get___myhandle__ ());
   graphics_object ax = go.get_ancestor ("axes");
 
   Matrix retval;
 
   if (ax.valid_object ())
     {
       const axes::properties& ax_props =
-          dynamic_cast<const axes::properties&> (ax.get_properties ());
+        dynamic_cast<const axes::properties&> (ax.get_properties ());
       graphics_xform ax_xform = ax_props.get_transform ();
       bool is_rectangle = (pos.numel () == 4);
       Matrix ax_bbox = ax_props.get_boundingbox (true),
              ax_size = ax_bbox.extract_n (0, 2, 1, 2);
 
       if (from_units.compare ("data"))
         {
           if (is_rectangle)
@@ -615,32 +615,37 @@ convert_text_position (const Matrix& pos
         retval = convert_position (pos, from_units, "pixels", ax_size);
 
       if (! to_units.compare ("pixels"))
         {
           if (to_units.compare ("data"))
             {
               if (is_rectangle)
                 {
-                  ColumnVector v1 = ax_xform.untransform (retval(0) + ax_bbox(0) - 1,
-                                                          ax_bbox(1) + ax_bbox(3)  - retval(1) + 1),
-                               v2 = ax_xform.untransform (retval(0) + retval(2) + ax_bbox(0) - 1,
-                                                          ax_bbox(1) + ax_bbox(3)  - (retval(1) + retval(3)) + 1);
+                  ColumnVector v1, v2;
+                  v1 = ax_xform.untransform (
+                         retval(0)  + ax_bbox(0) - 1,
+                         ax_bbox(1) + ax_bbox(3) - retval(1) + 1);
+                  v2 = ax_xform.untransform (
+                         retval(0)  + retval(2)  + ax_bbox(0) - 1,
+                         ax_bbox(1) + ax_bbox(3) - (retval(1) + retval(3)) + 1);
 
                   retval.resize (1, 4);
 
                   retval(0) = v1(0);
                   retval(1) = v1(1);
                   retval(2) = v2(0) - v1(0);
                   retval(3) = v2(1) - v1(1);
                 }
               else
                 {
-                  ColumnVector v = ax_xform.untransform (retval(0) + ax_bbox(0) - 1,
-                                                         ax_bbox(1) + ax_bbox(3)  - retval(1) + 1);
+                  ColumnVector v;
+                  v = ax_xform.untransform (
+                        retval(0)  + ax_bbox(0) - 1,
+                        ax_bbox(1) + ax_bbox(3) - retval(1) + 1);
 
                   retval.resize (1, 3);
 
                   retval(0) = v(0);
                   retval(1) = v(1);
                   retval(2) = v(2);
                 }
             }
@@ -653,17 +658,18 @@ convert_text_position (const Matrix& pos
 }
 
 // This function always returns the screensize in pixels
 static Matrix
 screen_size_pixels (void)
 {
   graphics_object obj = gh_manager::get_object (0);
   Matrix sz = obj.get ("screensize").matrix_value ();
-  return convert_position (sz, obj.get ("units").string_value (), "pixels", sz.extract_n (0, 2, 1, 2)).extract_n (0, 2, 1, 2);
+  return convert_position (sz, obj.get ("units").string_value (), "pixels",
+                           sz.extract_n (0, 2, 1, 2)).extract_n (0, 2, 1, 2);
 }
 
 static void
 convert_cdata_2 (bool is_scaled, double clim_0, double clim_1,
                  const double *cmapv, double x, octave_idx_type lda,
                  octave_idx_type nc, octave_idx_type i, double *av)
 {
   if (is_scaled)
@@ -1115,17 +1121,17 @@ color_property::do_set (const octave_val
                 }
               else
                 error ("invalid value for color property \"%s\" (value = %s)",
                        get_name ().c_str (), s.c_str ());
             }
         }
       else
         error ("invalid value for color property \"%s\"",
-           get_name ().c_str ());
+               get_name ().c_str ());
     }
   else if (val.is_numeric_type ())
     {
       Matrix m = val.matrix_value ();
 
       if (m.numel () == 3)
         {
           color_values col (m(0), m(1), m(2));
@@ -1136,17 +1142,17 @@ color_property::do_set (const octave_val
                   color_val = col;
                   current_type = color_t;
                   return true;
                 }
             }
         }
       else
         error ("invalid value for color property \"%s\"",
-           get_name ().c_str ());
+               get_name ().c_str ());
     }
   else
     error ("invalid value for color property \"%s\"",
            get_name ().c_str ());
 
   return false;
 }
 
@@ -1315,31 +1321,39 @@ array_property::get_data_limits (void)
   xmin = xminp = octave_Inf;
   xmax = xmaxp = -octave_Inf;
 
   if (! data.is_empty ())
     {
       if (data.is_integer_type ())
         {
           if (data.is_int8_type ())
-            get_array_limits (data.int8_array_value (), xmin, xmax, xminp, xmaxp);
+            get_array_limits (data.int8_array_value (),
+                              xmin, xmax, xminp, xmaxp);
           else if (data.is_uint8_type ())
-            get_array_limits (data.uint8_array_value (), xmin, xmax, xminp, xmaxp);
+            get_array_limits (data.uint8_array_value (),
+                              xmin, xmax, xminp, xmaxp);
           else if (data.is_int16_type ())
-            get_array_limits (data.int16_array_value (), xmin, xmax, xminp, xmaxp);
+            get_array_limits (data.int16_array_value (),
+                              xmin, xmax, xminp, xmaxp);
           else if (data.is_uint16_type ())
-            get_array_limits (data.uint16_array_value (), xmin, xmax, xminp, xmaxp);
+            get_array_limits (data.uint16_array_value (),
+                              xmin, xmax, xminp, xmaxp);
           else if (data.is_int32_type ())
-            get_array_limits (data.int32_array_value (), xmin, xmax, xminp, xmaxp);
+            get_array_limits (data.int32_array_value (),
+                              xmin, xmax, xminp, xmaxp);
           else if (data.is_uint32_type ())
-            get_array_limits (data.uint32_array_value (), xmin, xmax, xminp, xmaxp);
+            get_array_limits (data.uint32_array_value (),
+                              xmin, xmax, xminp, xmaxp);
           else if (data.is_int64_type ())
-            get_array_limits (data.int64_array_value (), xmin, xmax, xminp, xmaxp);
+            get_array_limits (data.int64_array_value (),
+                              xmin, xmax, xminp, xmaxp);
           else if (data.is_uint64_type ())
-            get_array_limits (data.uint64_array_value (), xmin, xmax, xminp, xmaxp);
+            get_array_limits (data.uint64_array_value (),
+                              xmin, xmax, xminp, xmaxp);
         }
       else
         get_array_limits (data.array_value (), xmin, xmax, xminp, xmaxp);
     }
 }
 
 bool
 handle_property::do_set (const octave_value& v)
@@ -1492,18 +1506,18 @@ property::create (const std::string& nam
     {
       std::string val = (args.length () > 0 ? args(0).string_value () : "");
 
       if (! error_state)
         retval = property (new string_property (name, h, val));
     }
   else if (type.compare ("any"))
     {
-      octave_value val =
-          (args.length () > 0 ? args(0) : octave_value (Matrix ()));
+      octave_value val = args.length () > 0 ? args(0)
+                                            : octave_value (Matrix ());
 
       retval = property (new any_property (name, h, val));
     }
   else if (type.compare ("radio"))
     {
       if (args.length () > 0)
         {
           std::string vals = args(0).string_value ();
@@ -1549,18 +1563,18 @@ property::create (const std::string& nam
   else if (type.compare ("data"))
     {
       retval = property (new array_property (name, h, Matrix ()));
 
       if (args.length () > 0)
         {
           retval.set (args(0));
 
-          // FIXME -- additional argument could define constraints,
-          // but is this really useful?
+          // FIXME: additional argument could define constraints,
+          //        but is this really useful?
         }
     }
   else if (type.compare ("color"))
     {
       color_values cv (0, 0, 0);
       radio_values rv;
 
       if (args.length () > 1)
@@ -1583,22 +1597,22 @@ property::create (const std::string& nam
     {
       caseless_str go_name, go_rest;
 
       if (lookup_object_name (type, go_name, go_rest))
         {
           graphics_object go;
 
           std::map<caseless_str, graphics_object>::const_iterator it =
-              dprop_obj_map.find (go_name);
+            dprop_obj_map.find (go_name);
 
           if (it == dprop_obj_map.end ())
             {
               base_graphics_object *bgo =
-                  make_graphics_object_from_type (go_name);
+                make_graphics_object_from_type (go_name);
 
               if (bgo)
                 {
                   go = graphics_object (bgo);
 
                   dprop_obj_map[go_name] = go;
                 }
             }
@@ -1745,22 +1759,23 @@ property_list::set (const caseless_str& 
                         }
                     }
                 }
             }
         }
 
       if (offset > 0)
         {
-          // FIXME -- should we validate property names and values here?
+          // FIXME: should we validate property names and values here?
 
           std::string pname = name.substr (offset);
 
           std::transform (pfx.begin (), pfx.end (), pfx.begin (), tolower);
-          std::transform (pname.begin (), pname.end (), pname.begin (), tolower);
+          std::transform (pname.begin (), pname.end (), pname.begin (),
+                          tolower);
 
           bool has_property = false;
           if (pfx == "axes")
             has_property = axes::properties::has_core_property (pname);
           else if (pfx == "line")
             has_property = line::properties::has_core_property (pname);
           else if (pfx == "text")
             has_property = text::properties::has_core_property (pname);
@@ -1886,17 +1901,18 @@ property_list::lookup (const caseless_st
             }
         }
 
       if (offset > 0)
         {
           std::string pname = name.substr (offset);
 
           std::transform (pfx.begin (), pfx.end (), pfx.begin (), tolower);
-          std::transform (pname.begin (), pname.end (), pname.begin (), tolower);
+          std::transform (pname.begin (), pname.end (), pname.begin (),
+                          tolower);
 
           plist_map_const_iterator p = find (pfx);
 
           if (p != end ())
             {
               const pval_map_type& pval_map = p->second;
 
               pval_map_const_iterator q = pval_map.find (pname);
@@ -1978,17 +1994,17 @@ graphics_object::set (const octave_value
 // Set properties given in two cell arrays containing names and values.
 void
 graphics_object::set (const Array<std::string>& names,
                       const Cell& values, octave_idx_type row)
 {
   if (names.numel () != values.columns ())
     {
       error ("set: number of names must match number of value columns (%d != %d)",
-            names.numel (), values.columns ());
+             names.numel (), values.columns ());
     }
 
   octave_idx_type k = names.columns ();
 
   for (octave_idx_type column = 0; column < k; column++)
     {
       caseless_str name = names(column);
       octave_value val  = values(row, column);
@@ -2050,17 +2066,17 @@ graphics_object::set (const Array<std::s
 void
 graphics_object::set (const octave_map& m)
 {
   for (octave_idx_type p = 0; p < m.nfields (); p++)
     {
       caseless_str name  = m.keys ()[p];
 
       octave_value val = octave_value (m.contents (name).elem (m.numel () - 1));
-      
+
       set_value_or_default (name, val);
 
       if (error_state)
         break;
     }
 }
 
 /*
@@ -2171,17 +2187,17 @@ graphics_object::set_value_or_default (c
 
           if (error_state)
             return;
 
           rep->set (name, default_val);
         }
       else
         {
-          // Matlab specifically uses "\default" to escape string setting 
+          // Matlab specifically uses "\default" to escape string setting
           if (tval.compare ("\\default") == 0)
             rep->set (name, "default");
           else if (tval.compare ("\\factory") == 0)
             rep->set (name, "factory");
           else
             rep->set (name, val);
         }
     }
@@ -2288,17 +2304,18 @@ gh_manager::do_free (const graphics_hand
               // Graphics handles for non-figure objects are negative
               // integers plus some random fractional part.  To avoid
               // running out of integers, we recycle the integer part
               // but tack on a new random part each time.
 
               handle_map.erase (p);
 
               if (h.value () < 0)
-                handle_free_list.insert (std::ceil (h.value ()) - make_handle_fraction ());
+                handle_free_list.insert
+                  (std::ceil (h.value ()) - make_handle_fraction ());
             }
           else
             error ("graphics_handle::free: invalid object %g", h.value ());
         }
       else
         error ("graphics_handle::free: can't delete root figure");
     }
 }
@@ -2482,17 +2499,17 @@ force_close_figure (const graphics_handl
   xset (handle, "closerequestfcn", Matrix ());
 
   delete_graphics_object (handle);
 }
 
 void
 gh_manager::do_close_all_figures (void)
 {
-  // FIXME -- should we process or discard pending events?
+  // FIXME: should we process or discard pending events?
 
   event_queue.clear ();
 
   // Don't use figure_list_iterator because we'll be removing elements
   // from the list elsewhere.
 
   Matrix hlist = do_figure_handle_list (true);
 
@@ -2654,33 +2671,34 @@ base_properties::set_from_list (base_gra
     }
 }
 
 octave_value
 base_properties::get_dynamic (const caseless_str& name) const
 {
   octave_value retval;
 
-  std::map<caseless_str, property, cmp_caseless_str>::const_iterator it = all_props.find (name);
+  std::map<caseless_str, property, cmp_caseless_str>::const_iterator it =
+    all_props.find (name);
 
   if (it != all_props.end ())
     retval = it->second.get ();
   else
     error ("get: unknown property \"%s\"", name.c_str ());
 
   return retval;
 }
 
 octave_value
 base_properties::get_dynamic (bool all) const
 {
   octave_scalar_map m;
 
-  for (std::map<caseless_str, property, cmp_caseless_str>::const_iterator it = all_props.begin ();
-       it != all_props.end (); ++it)
+  for (std::map<caseless_str, property, cmp_caseless_str>::const_iterator
+       it = all_props.begin (); it != all_props.end (); ++it)
     if (all || ! it->second.is_hidden ())
       m.assign (it->second.get_name (), it->second.get ());
 
   return m;
 }
 
 std::set<std::string>
 base_properties::dynamic_property_names (void) const
@@ -2698,17 +2716,18 @@ base_properties::has_dynamic_property (c
   else
     return all_props.find (pname) != all_props.end ();
 }
 
 void
 base_properties::set_dynamic (const caseless_str& pname,
                               const octave_value& val)
 {
-  std::map<caseless_str, property, cmp_caseless_str>::iterator it = all_props.find (pname);
+  std::map<caseless_str, property, cmp_caseless_str>::iterator it =
+    all_props.find (pname);
 
   if (it != all_props.end ())
     it->second.set (val);
   else
     error ("set: unknown property \"%s\"", pname.c_str ());
 
   if (! error_state)
     {
@@ -2716,17 +2735,18 @@ base_properties::set_dynamic (const case
 
       mark_modified ();
     }
 }
 
 property
 base_properties::get_property_dynamic (const caseless_str& name)
 {
-  std::map<caseless_str, property, cmp_caseless_str>::const_iterator it = all_props.find (name);
+  std::map<caseless_str, property, cmp_caseless_str>::const_iterator it =
+    all_props.find (name);
 
   if (it == all_props.end ())
     {
       error ("get_property: unknown property \"%s\"", name.c_str ());
       return property ();
     }
   else
     return it->second;
@@ -2906,17 +2926,17 @@ base_graphics_object::update_axis_limits
 
 void
 base_graphics_object::remove_all_listeners (void)
 {
   octave_map m = get (true).map_value ();
 
   for (octave_map::const_iterator pa = m.begin (); pa != m.end (); pa++)
     {
-      // FIXME -- there has to be a better way.  I think we want to
+      // FIXME: there has to be a better way.  I think we want to
       // ask whether it is OK to delete the listener for the given
       // property.  How can we know in advance that it will be OK?
 
       unwind_protect frame;
 
       frame.protect_var (error_state);
       frame.protect_var (discard_error_messages);
       frame.protect_var (Vdebug_on_error);
@@ -3718,59 +3738,81 @@ figure::properties::update_papersize (vo
       const double tol = 0.01;
 
       if (std::abs (sz(0) - 8.5) + std::abs (sz(1) - 11.0) < tol)
         typ = "usletter";
       else if (std::abs (sz(0) - 8.5) + std::abs (sz(1) - 14.0) < tol)
         typ = "uslegal";
       else if (std::abs (sz(0) - 11.0) + std::abs (sz(1) - 17.0) < tol)
         typ = "tabloid";
-      else if (std::abs (sz(0) - 841.0 * mm2in) + std::abs (sz(1) - 1198.0 * mm2in) < tol)
+      else if (std::abs (sz(0) - 841.0 * mm2in)
+               + std::abs (sz(1) - 1198.0 * mm2in) < tol)
         typ = "a0";
-      else if (std::abs (sz(0) - 594.0 * mm2in) + std::abs (sz(1) - 841.0 * mm2in) < tol)
+      else if (std::abs (sz(0) - 594.0 * mm2in)
+               + std::abs (sz(1) - 841.0 * mm2in) < tol)
         typ = "a1";
-      else if (std::abs (sz(0) - 420.0 * mm2in) + std::abs (sz(1) - 594.0 * mm2in) < tol)
+      else if (std::abs (sz(0) - 420.0 * mm2in)
+               + std::abs (sz(1) - 594.0 * mm2in) < tol)
         typ = "a2";
-      else if (std::abs (sz(0) - 297.0 * mm2in) + std::abs (sz(1) - 420.0 * mm2in) < tol)
+      else if (std::abs (sz(0) - 297.0 * mm2in)
+               + std::abs (sz(1) - 420.0 * mm2in) < tol)
         typ = "a3";
-      else if (std::abs (sz(0) - 210.0 * mm2in) + std::abs (sz(1) - 297.0 * mm2in) < tol)
+      else if (std::abs (sz(0) - 210.0 * mm2in)
+               + std::abs (sz(1) - 297.0 * mm2in) < tol)
         typ = "a4";
-      else if (std::abs (sz(0) - 148.0 * mm2in) + std::abs (sz(1) - 210.0 * mm2in) < tol)
+      else if (std::abs (sz(0) - 148.0 * mm2in)
+               + std::abs (sz(1) - 210.0 * mm2in) < tol)
         typ = "a5";
-      else if (std::abs (sz(0) - 1029.0 * mm2in) + std::abs (sz(1) - 1456.0 * mm2in) < tol)
+      else if (std::abs (sz(0) - 1029.0 * mm2in)
+               + std::abs (sz(1) - 1456.0 * mm2in) < tol)
         typ = "b0";
-      else if (std::abs (sz(0) - 728.0 * mm2in) + std::abs (sz(1) - 1028.0 * mm2in) < tol)
+      else if (std::abs (sz(0) - 728.0 * mm2in)
+               + std::abs (sz(1) - 1028.0 * mm2in) < tol)
         typ = "b1";
-      else if (std::abs (sz(0) - 514.0 * mm2in) + std::abs (sz(1) - 728.0 * mm2in) < tol)
+      else if (std::abs (sz(0) - 514.0 * mm2in)
+               + std::abs (sz(1) - 728.0 * mm2in) < tol)
         typ = "b2";
-      else if (std::abs (sz(0) - 364.0 * mm2in) + std::abs (sz(1) - 514.0 * mm2in) < tol)
+      else if (std::abs (sz(0) - 364.0 * mm2in)
+               + std::abs (sz(1) - 514.0 * mm2in) < tol)
         typ = "b3";
-      else if (std::abs (sz(0) - 257.0 * mm2in) + std::abs (sz(1) - 364.0 * mm2in) < tol)
+      else if (std::abs (sz(0) - 257.0 * mm2in)
+               + std::abs (sz(1) - 364.0 * mm2in) < tol)
         typ = "b4";
-      else if (std::abs (sz(0) - 182.0 * mm2in) + std::abs (sz(1) - 257.0 * mm2in) < tol)
+      else if (std::abs (sz(0) - 182.0 * mm2in)
+               + std::abs (sz(1) - 257.0 * mm2in) < tol)
         typ = "b5";
-      else if (std::abs (sz(0) - 9.0)  + std::abs (sz(1) - 12.0) < tol)
+      else if (std::abs (sz(0) - 9.0) 
+               + std::abs (sz(1) - 12.0) < tol)
         typ = "arch-a";
-      else if (std::abs (sz(0) - 12.0) + std::abs (sz(1) - 18.0) < tol)
+      else if (std::abs (sz(0) - 12.0)
+               + std::abs (sz(1) - 18.0) < tol)
         typ = "arch-b";
-      else if (std::abs (sz(0) - 18.0) + std::abs (sz(1) - 24.0) < tol)
+      else if (std::abs (sz(0) - 18.0)
+               + std::abs (sz(1) - 24.0) < tol)
         typ = "arch-c";
-      else if (std::abs (sz(0) - 24.0) + std::abs (sz(1) - 36.0) < tol)
+      else if (std::abs (sz(0) - 24.0)
+               + std::abs (sz(1) - 36.0) < tol)
         typ = "arch-d";
-      else if (std::abs (sz(0) - 36.0) + std::abs (sz(1) - 48.0) < tol)
+      else if (std::abs (sz(0) - 36.0)
+               + std::abs (sz(1) - 48.0) < tol)
         typ = "arch-e";
-      else if (std::abs (sz(0) - 8.5)  + std::abs (sz(1) - 11.0) < tol)
+      else if (std::abs (sz(0) - 8.5) 
+               + std::abs (sz(1) - 11.0) < tol)
         typ = "a";
-      else if (std::abs (sz(0) - 11.0) + std::abs (sz(1) - 17.0) < tol)
+      else if (std::abs (sz(0) - 11.0)
+               + std::abs (sz(1) - 17.0) < tol)
         typ = "b";
-      else if (std::abs (sz(0) - 17.0) + std::abs (sz(1) - 22.0) < tol)
+      else if (std::abs (sz(0) - 17.0)
+               + std::abs (sz(1) - 22.0) < tol)
         typ = "c";
-      else if (std::abs (sz(0) - 22.0) + std::abs (sz(1) - 34.0) < tol)
+      else if (std::abs (sz(0) - 22.0)
+               + std::abs (sz(1) - 34.0) < tol)
         typ = "d";
-      else if (std::abs (sz(0) - 34.0) + std::abs (sz(1) - 43.0) < tol)
+      else if (std::abs (sz(0) - 34.0)
+               + std::abs (sz(1) - 43.0) < tol)
         typ = "e";
       // Call papertype.set rather than set_papertype to avoid loops between
       // update_papersize and update_papertype
       papertype.set (typ);
     }
   if (punits == "centimeters")
     {
       sz(0) *= 2.54;
@@ -4441,17 +4483,17 @@ axes::properties::delete_text_child (han
       graphics_object go = gh_manager::get_object (h);
 
       if (go.valid_object ())
         gh_manager::free (h);
 
       base_properties::remove_child (h);
     }
 
-  // FIXME -- is it necessary to check whether the axes object is
+  // FIXME: is it necessary to check whether the axes object is
   // being deleted now?  I think this function is only called when an
   // individual child object is delete and not when the parent axes
   // object is deleted.
 
   if (! is_beingdeleted ())
     {
       hp = gh_manager::make_graphics_handle ("text", __myhandle__,
                                              false, false);
@@ -4585,25 +4627,27 @@ cross (const ColumnVector& v1, const Col
   r(1) = v1(2)*v2(0)-v1(0)*v2(2);
   r(2) = v1(0)*v2(1)-v1(1)*v2(0);
   return r;
 }
 
 inline Matrix
 unit_cube (void)
 {
-  static double data[32] = {
-      0,0,0,1,
-      1,0,0,1,
-      0,1,0,1,
-      0,0,1,1,
-      1,1,0,1,
-      1,0,1,1,
-      0,1,1,1,
-      1,1,1,1};
+  static double data[32] =
+  {
+    0,0,0,1,
+    1,0,0,1,
+    0,1,0,1,
+    0,0,1,1,
+    1,1,0,1,
+    1,0,1,1,
+    0,1,1,1,
+    1,1,1,1
+  };
   Matrix m (4, 8);
   memcpy (m.fortran_vec (), data, sizeof (double)*32);
   return m;
 }
 
 inline ColumnVector
 cam2xform (const Array<double>& m)
 {
@@ -4754,17 +4798,17 @@ axes::properties::update_camera (void)
   Matrix bb = get_boundingbox (true);
 
   double v_angle;
 
   if (cameraviewanglemode_is ("auto"))
     {
       double af;
 
-      // FIXME -- was this really needed?  When compared to Matlab, it
+      // FIXME: was this really needed?  When compared to Matlab, it
       // does not seem to be required. Need investigation with concrete
       // graphics toolkit to see results visually.
       if (false && dowarp)
         af = 1.0 / (xM > yM ? xM : yM);
       else
         {
           if ((bb(2)/bb(3)) > (xM/yM))
             af = 1.0 / yM;
@@ -4959,43 +5003,43 @@ axes::properties::update_axes_layout (vo
   ypTickN = (zSign ? yPlane : yPlaneN);
   zpTickN = (zSign ? zPlaneN : zPlane);
 
   /* 2D mode */
   x2Dtop = false;
   y2Dright = false;
   layer2Dtop = false;
   if (xstate == AXE_HORZ_DIR && ystate == AXE_VERT_DIR)
-  {
-    if (xaxislocation_is ("top"))
-    {
-      double tmp = yPlane;
-      yPlane = yPlaneN;
-      yPlaneN = tmp;
-      x2Dtop = true;
-    }
-    ypTick = yPlaneN;
-    ypTickN = yPlane;
-    if (yaxislocation_is ("right"))
-    {
-      double tmp = xPlane;
-      xPlane = xPlaneN;
-      xPlaneN = tmp;
-      y2Dright = true;
-    }
-    xpTick = xPlaneN;
-    xpTickN = xPlane;
-    if (layer_is ("top"))
-      {
-        zpTick = zPlaneN;
-        layer2Dtop = true;
-      }
-    else
-      zpTick = zPlane;
-  }
+    {
+      if (xaxislocation_is ("top"))
+        {
+          double tmp = yPlane;
+          yPlane = yPlaneN;
+          yPlaneN = tmp;
+          x2Dtop = true;
+        }
+      ypTick = yPlaneN;
+      ypTickN = yPlane;
+      if (yaxislocation_is ("right"))
+        {
+          double tmp = xPlane;
+          xPlane = xPlaneN;
+          xPlaneN = tmp;
+          y2Dright = true;
+        }
+      xpTick = xPlaneN;
+      xpTickN = xPlane;
+      if (layer_is ("top"))
+        {
+          zpTick = zPlaneN;
+          layer2Dtop = true;
+        }
+      else
+        zpTick = zPlane;
+    }
 
   Matrix viewmat = get_view ().matrix_value ();
   nearhoriz = std::abs (viewmat(1)) <= 5;
 
   update_ticklength ();
 }
 
 void
@@ -5050,18 +5094,19 @@ axes::properties::update_ticklength (voi
 static bool updating_xlabel_position = false;
 
 void
 axes::properties::update_xlabel_position (void)
 {
   if (updating_xlabel_position)
     return;
 
-  text::properties& xlabel_props = reinterpret_cast<text::properties&>
-    (gh_manager::get_object (get_xlabel ()).get_properties ());
+  text::properties& xlabel_props
+    = reinterpret_cast<text::properties&>
+        (gh_manager::get_object (get_xlabel ()).get_properties ());
 
   bool is_empty = xlabel_props.get_string ().is_empty ();
 
   unwind_protect frame;
   frame.protect_var (updating_xlabel_position);
   updating_xlabel_position = true;
 
   if (! is_empty)
@@ -5103,29 +5148,29 @@ axes::properties::update_xlabel_position
         p(2) += (signum (zpTick-zpTickN)*fz*xtickoffset);
       else
         p(1) += (signum (ypTick-ypTickN)*fy*xtickoffset);
 
       p = xform.transform (p(0), p(1), p(2), false);
 
       switch (xstate)
         {
-          case AXE_ANY_DIR:
-            p(0) += (xyzSym ? wmax : -wmax);
-            p(1) += hmax;
-            break;
-
-          case AXE_VERT_DIR:
-            p(0) -= wmax;
-            angle = 90;
-            break;
-
-          case AXE_HORZ_DIR:
-            p(1) += (x2Dtop ? -hmax : hmax);
-            break;
+        case AXE_ANY_DIR:
+          p(0) += (xyzSym ? wmax : -wmax);
+          p(1) += hmax;
+          break;
+
+        case AXE_VERT_DIR:
+          p(0) -= wmax;
+          angle = 90;
+          break;
+
+        case AXE_HORZ_DIR:
+          p(1) += (x2Dtop ? -hmax : hmax);
+          break;
         }
 
       if (xlabel_props.positionmode_is ("auto"))
         {
           p = xform.untransform (p(0), p(1), p(2), true);
           xlabel_props.set_position (p.extract_n (0, 3).transpose ());
           xlabel_props.set_positionmode ("auto");
         }
@@ -5141,18 +5186,19 @@ axes::properties::update_xlabel_position
 static bool updating_ylabel_position = false;
 
 void
 axes::properties::update_ylabel_position (void)
 {
   if (updating_ylabel_position)
     return;
 
-  text::properties& ylabel_props = reinterpret_cast<text::properties&>
-    (gh_manager::get_object (get_ylabel ()).get_properties ());
+  text::properties& ylabel_props
+    = reinterpret_cast<text::properties&>
+        (gh_manager::get_object (get_ylabel ()).get_properties ());
 
   bool is_empty = ylabel_props.get_string ().is_empty ();
 
   unwind_protect frame;
   frame.protect_var (updating_ylabel_position);
   updating_ylabel_position = true;
 
   if (! is_empty)
@@ -5203,29 +5249,29 @@ axes::properties::update_ylabel_position
         p(2) += (signum (zpTick-zpTickN)*fz*ytickoffset);
       else
         p(0) += (signum (xpTick-xpTickN)*fx*ytickoffset);
 
       p = xform.transform (p(0), p(1), p(2), false);
 
       switch (ystate)
         {
-          case AXE_ANY_DIR:
-            p(0) += (!xyzSym ? wmax : -wmax);
-            p(1) += hmax;
-            break;
-
-          case AXE_VERT_DIR:
-            p(0) += (y2Dright ? wmax : -wmax);
-            angle = 90;
-            break;
-
-          case AXE_HORZ_DIR:
-            p(1) += hmax;
-            break;
+        case AXE_ANY_DIR:
+          p(0) += (!xyzSym ? wmax : -wmax);
+          p(1) += hmax;
+          break;
+
+        case AXE_VERT_DIR:
+          p(0) += (y2Dright ? wmax : -wmax);
+          angle = 90;
+          break;
+
+        case AXE_HORZ_DIR:
+          p(1) += hmax;
+          break;
         }
 
       if (ylabel_props.positionmode_is ("auto"))
         {
           p = xform.untransform (p(0), p(1), p(2), true);
           ylabel_props.set_position (p.extract_n (0, 3).transpose ());
           ylabel_props.set_positionmode ("auto");
         }
@@ -5241,18 +5287,19 @@ axes::properties::update_ylabel_position
 static bool updating_zlabel_position = false;
 
 void
 axes::properties::update_zlabel_position (void)
 {
   if (updating_zlabel_position)
     return;
 
-  text::properties& zlabel_props = reinterpret_cast<text::properties&>
-    (gh_manager::get_object (get_zlabel ()).get_properties ());
+  text::properties& zlabel_props
+    = reinterpret_cast<text::properties&>
+        (gh_manager::get_object (get_zlabel ()).get_properties ());
 
   bool camAuto = cameraupvectormode_is ("auto");
   bool is_empty = zlabel_props.get_string ().is_empty ();
 
   unwind_protect frame;
   frame.protect_var (updating_zlabel_position);
   updating_zlabel_position = true;
 
@@ -5307,38 +5354,38 @@ axes::properties::update_zlabel_position
           else
             p(0) += (signum (xPlane-xPlaneN)*fx*ztickoffset);
         }
 
       p = xform.transform (p(0), p(1), p(2), false);
 
       switch (zstate)
         {
-          case AXE_ANY_DIR:
-            if (camAuto)
-              {
-                p(0) -= wmax;
-                angle = 90;
-              }
-
-            // FIXME -- what's the correct offset?
-            //
-            //   p[0] += (!xySym ? wmax : -wmax);
-            //   p[1] += (zSign ? hmax : -hmax);
-
-            break;
-
-          case AXE_VERT_DIR:
-            p(0) -= wmax;
-            angle = 90;
-            break;
-
-          case AXE_HORZ_DIR:
-            p(1) += hmax;
-            break;
+        case AXE_ANY_DIR:
+          if (camAuto)
+            {
+              p(0) -= wmax;
+              angle = 90;
+            }
+
+          // FIXME: what's the correct offset?
+          //
+          //   p[0] += (!xySym ? wmax : -wmax);
+          //   p[1] += (zSign ? hmax : -hmax);
+
+          break;
+
+        case AXE_VERT_DIR:
+          p(0) -= wmax;
+          angle = 90;
+          break;
+
+        case AXE_HORZ_DIR:
+          p(1) += hmax;
+          break;
         }
 
       if (zlabel_props.positionmode_is ("auto"))
         {
           p = xform.untransform (p(0), p(1), p(2), true);
           zlabel_props.set_position (p.extract_n (0, 3).transpose ());
           zlabel_props.set_positionmode ("auto");
         }
@@ -5354,18 +5401,19 @@ axes::properties::update_zlabel_position
 static bool updating_title_position = false;
 
 void
 axes::properties::update_title_position (void)
 {
   if (updating_title_position)
     return;
 
-  text::properties& title_props = reinterpret_cast<text::properties&>
-    (gh_manager::get_object (get_title ()).get_properties ());
+  text::properties& title_props
+    = reinterpret_cast<text::properties&>
+        (gh_manager::get_object (get_title ()).get_properties ());
 
   unwind_protect frame;
   frame.protect_var (updating_title_position);
   updating_title_position = true;
 
   if (title_props.positionmode_is ("auto"))
     {
       graphics_xform xform = get_transform ();
@@ -5408,25 +5456,25 @@ axes::properties::update_autopos (const 
   else if (elem_type == "sync")
     sync_positions ();
 }
 
 static void
 normalized_aspectratios (Matrix& aspectratios, const Matrix& scalefactors,
                          double xlength, double ylength, double zlength)
 {
-      double xval = xlength/scalefactors(0);
-      double yval = ylength/scalefactors(1);
-      double zval = zlength/scalefactors(2);
-
-      double minval = xmin (xmin (xval, yval), zval);
-
-      aspectratios(0) = xval/minval;
-      aspectratios(1) = yval/minval;
-      aspectratios(2) = zval/minval;
+  double xval = xlength/scalefactors(0);
+  double yval = ylength/scalefactors(1);
+  double zval = zlength/scalefactors(2);
+
+  double minval = xmin (xmin (xval, yval), zval);
+
+  aspectratios(0) = xval/minval;
+  aspectratios(1) = yval/minval;
+  aspectratios(2) = zval/minval;
 }
 
 static void
 max_axes_scale (double& s, Matrix& limits, const Matrix& kids,
                 double pbfactor, double dafactor, char limit_type, bool tight)
 {
   if (tight)
     {
@@ -5574,19 +5622,18 @@ axes::properties::update_font (void)
 }
 
 // The INTERNAL flag defines whether position or outerposition is used.
 
 Matrix
 axes::properties::get_boundingbox (bool internal,
                                    const Matrix& parent_pix_size) const
 {
-  Matrix pos = (internal ?
-                  get_position ().matrix_value ()
-                  : get_outerposition ().matrix_value ());
+  Matrix pos = internal ? get_position ().matrix_value ()
+                        : get_outerposition ().matrix_value ();
   Matrix parent_size (parent_pix_size);
 
   if (parent_size.numel () == 0)
     {
       graphics_object obj = gh_manager::get_object (get_parent ());
 
       if (obj.valid_object ())
         parent_size =
@@ -5636,18 +5683,19 @@ axes::properties::get_extent (bool with_
             text_handle = get_title ();
           else if (i == 1)
             text_handle = get_xlabel ();
           else if (i == 2)
             text_handle = get_ylabel ();
           else if (i == 3)
             text_handle = get_zlabel ();
 
-          text::properties& text_props = reinterpret_cast<text::properties&>
-            (gh_manager::get_object (text_handle).get_properties ());
+          text::properties& text_props
+            = reinterpret_cast<text::properties&>
+                (gh_manager::get_object (text_handle).get_properties ());
 
           Matrix text_pos = text_props.get_data_position ();
           text_pos = xform.transform (text_pos(0), text_pos(1), text_pos(2));
           if (text_props.get_string ().is_empty ())
             {
               ext(0) = std::min (ext(0), text_pos(0));
               ext(1) = std::min (ext(1), text_pos(1));
               ext(2) = std::max (ext(2), text_pos(0));
@@ -5658,30 +5706,32 @@ axes::properties::get_extent (bool with_
               Matrix text_ext = text_props.get_extent_matrix ();
 
               bool ignore_horizontal = false;
               bool ignore_vertical = false;
               if (only_text_height)
                 {
                   double text_rotation = text_props.get_rotation ();
                   if (text_rotation == 0. || text_rotation == 180.)
-                      ignore_horizontal = true;
+                    ignore_horizontal = true;
                   else if (text_rotation == 90. || text_rotation == 270.)
-                      ignore_vertical = true;
+                    ignore_vertical = true;
                 }
 
               if (! ignore_horizontal)
                 {
                   ext(0) = std::min (ext(0), text_pos(0)+text_ext(0));
-                  ext(2) = std::max (ext(2), text_pos(0)+text_ext(0)+text_ext(2));
+                  ext(2) = std::max (ext(2),
+                                     text_pos(0)+text_ext(0)+text_ext(2));
                 }
 
               if (! ignore_vertical)
                 {
-                  ext(1) = std::min (ext(1), text_pos(1)-text_ext(1)-text_ext(3));
+                  ext(1) = std::min (ext(1),
+                                     text_pos(1)-text_ext(1)-text_ext(3));
                   ext(3) = std::max (ext(3), text_pos(1)-text_ext(1));
                 }
             }
         }
     }
 
   ext(2) = ext(2)-ext(0);
   ext(3) = ext(3)-ext(1);
@@ -5719,17 +5769,17 @@ convert_ticklabel_string (const octave_v
         {
           std::string valstr = val.string_value ();
           std::istringstream iss (valstr);
           std::string tmpstr;
 
           // Split string with delimiter '|'
           while (std::getline (iss, tmpstr, '|'))
             sv.append (tmpstr);
-          
+
           // If string ends with '|' Matlab appends a null string
           if (*valstr.rbegin () == '|')
             sv.append (std::string (""));
         }
       else
         return retval;
 
       charMatrix chmat (sv, ' ');
@@ -5808,17 +5858,17 @@ convert_linestyleorder_string (const oct
         {
           std::string valstr = val.string_value ();
           std::istringstream iss (valstr);
           std::string tmpstr;
 
           // Split string with delimiter '|'
           while (std::getline (iss, tmpstr, '|'))
             sv.append (tmpstr);
-          
+
           // If string ends with '|' Matlab appends a null string
           if (*valstr.rbegin () == '|')
             sv.append (std::string (""));
         }
       else
         return retval;
 
       charMatrix chmat (sv, ' ');
@@ -5851,22 +5901,35 @@ axes::properties::set_units (const octav
         }
     }
 }
 
 void
 axes::properties::update_units (const caseless_str& old_units)
 {
   graphics_object obj = gh_manager::get_object (get_parent ());
-  Matrix parent_bb = obj.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
+  Matrix parent_bb
+    = obj.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
   caseless_str new_units = get_units ();
-  position.set (octave_value (convert_position (get_position ().matrix_value (), old_units, new_units, parent_bb)), false);
-  outerposition.set (octave_value (convert_position (get_outerposition ().matrix_value (), old_units, new_units, parent_bb)), false);
-  tightinset.set (octave_value (convert_position (get_tightinset ().matrix_value (), old_units, new_units, parent_bb)), false);
-  looseinset.set (octave_value (convert_position (get_looseinset ().matrix_value (), old_units, new_units, parent_bb)), false);
+  position.set (octave_value (convert_position (get_position ().matrix_value (),
+                                                old_units, new_units,
+                                                parent_bb)),
+                                                false);
+  outerposition.set (octave_value (convert_position (get_outerposition ().matrix_value (),
+                                                old_units, new_units,
+                                                parent_bb)),
+                                                false);
+  tightinset.set (octave_value (convert_position (get_tightinset ().matrix_value (),
+                                                old_units, new_units,
+                                                parent_bb)),
+                                                false);
+  looseinset.set (octave_value (convert_position (get_looseinset ().matrix_value (),
+                                                old_units, new_units,
+                                                parent_bb)),
+                                                false);
 }
 
 void
 axes::properties::set_fontunits (const octave_value& v)
 {
   if (! error_state)
     {
       caseless_str old_fontunits = get_fontunits ();
@@ -5955,18 +6018,18 @@ axes::get_default (const caseless_str& n
       graphics_object parent_obj = gh_manager::get_object (parent);
 
       retval = parent_obj.get_default (name);
     }
 
   return retval;
 }
 
-// FIXME -- remove.
-// FIXME -- maybe this should go into array_property class?
+// FIXME: remove.
+// FIXME: maybe this should go into array_property class?
 /*
 static void
 check_limit_vals (double& min_val, double& max_val,
                   double& min_pos, double& max_neg,
                   const array_property& data)
 {
   double val = data.min_val ();
   if (xfinite (val) && val < min_val)
@@ -6030,17 +6093,17 @@ magform (double x, double& a, int& b)
     {
       b = static_cast<int> (gnulib::floor (std::log10 (std::abs (x))));
       a = x / std::pow (10.0, b);
     }
 }
 
 // A translation from Tom Holoryd's python code at
 // http://kurage.nimh.nih.gov/tomh/tics.py
-// FIXME -- add log ticks
+// FIXME: add log ticks
 
 double
 axes::properties::calc_tick_sep (double lo, double hi)
 {
   int ticint = 5;
 
   // Reference: Lewart, C. R., "Algorithms SCALE1, SCALE2, and
   // SCALE3 for Determination of Scales on Computer Generated
@@ -6102,18 +6165,19 @@ axes::properties::get_axis_limits (doubl
               retval(1) = pow (10., retval(1));
               return retval;
             }
           if ((min_val <= 0 && max_val > 0))
             {
               warning ("axis: omitting non-positive data in log plot");
               min_val = min_pos;
             }
-          // FIXME -- maybe this test should also be relative?
-          if (std::abs (min_val - max_val) < sqrt (std::numeric_limits<double>::epsilon ()))
+          // FIXME: maybe this test should also be relative?
+          if (std::abs (min_val - max_val)
+              < sqrt (std::numeric_limits<double>::epsilon ()))
             {
               // Widen range when too small
               if (min_val >= 0)
                 {
                   min_val *= 0.9;
                   max_val *= 1.1;
                 }
               else
@@ -6138,17 +6202,18 @@ axes::properties::get_axis_limits (doubl
       else
         {
           if (min_val == 0 && max_val == 0)
             {
               min_val = -1;
               max_val = 1;
             }
           // FIXME -- maybe this test should also be relative?
-          else if (std::abs (min_val - max_val) < sqrt (std::numeric_limits<double>::epsilon ()))
+          else if (std::abs (min_val - max_val)
+                   < sqrt (std::numeric_limits<double>::epsilon ()))
             {
               min_val -= 0.1 * std::abs (min_val);
               max_val += 0.1 * std::abs (max_val);
             }
 
           double tick_sep = calc_tick_sep (min_val , max_val);
           double min_tick = gnulib::floor (min_val / tick_sep);
           double max_tick = std::ceil (max_val / tick_sep);
@@ -6167,17 +6232,17 @@ axes::properties::get_axis_limits (doubl
 }
 
 void
 axes::properties::calc_ticks_and_lims (array_property& lims,
                                        array_property& ticks,
                                        array_property& mticks,
                                        bool limmode_is_auto, bool is_logscale)
 {
-  // FIXME -- add log ticks and lims
+  // FIXME: add log ticks and lims
 
   if (lims.get ().is_empty ())
     return;
 
   double lo = (lims.get ().matrix_value ()) (0);
   double hi = (lims.get ().matrix_value ()) (1);
   bool is_negative = lo < 0 && hi < 0;
   double tmp;
@@ -6899,17 +6964,18 @@ axes::properties::zoom_about_point (doub
 
   xlims = do_zoom (x, factor, xlims, xscale_is ("log"));
   ylims = do_zoom (y, factor, ylims, yscale_is ("log"));
 
   zoom (xlims, ylims, push_to_zoom_stack);
 }
 
 void
-axes::properties::zoom (const Matrix& xl, const Matrix& yl, bool push_to_zoom_stack)
+axes::properties::zoom (const Matrix& xl, const Matrix& yl,
+                        bool push_to_zoom_stack)
 {
   if (push_to_zoom_stack)
     {
       zoom_stack.push_front (xlimmode.get ());
       zoom_stack.push_front (xlim.get ());
       zoom_stack.push_front (ylimmode.get ());
       zoom_stack.push_front (ylim.get ());
     }
@@ -7329,38 +7395,42 @@ surface::properties::update_normals (voi
                   j3 = j + 1;
                 }
 
               double& nx = n(j, i, 0);
               double& ny = n(j, i, 1);
               double& nz = n(j, i, 2);
 
               if ((j > 0) && (i > 0))
-                  // upper left quadrangle
-                  cross_product (x(j1,i-1)-x(j2,i), y(j-1,i1)-y(j,i2), z(j-1,i-1)-z(j,i),
-                                 x(j2,i-1)-x(j1,i), y(j,i1)-y(j-1,i2), z(j,i-1)-z(j-1,i),
-                                 nx, ny, nz);
+                // upper left quadrangle
+                cross_product
+                  (x(j1,i-1)-x(j2,i), y(j-1,i1)-y(j,i2), z(j-1,i-1)-z(j,i),
+                   x(j2,i-1)-x(j1,i), y(j,i1)-y(j-1,i2), z(j,i-1)-z(j-1,i),
+                   nx, ny, nz);
 
               if ((j > 0) && (i < (p -1)))
-                  // upper right quadrangle
-                  cross_product (x(j1,i+1)-x(j2,i), y(j-1,i3)-y(j,i2), z(j-1,i+1)-z(j,i),
-                                 x(j1,i)-x(j2,i+1), y(j-1,i2)-y(j,i3), z(j-1,i)-z(j,i+1),
-                                 nx, ny, nz);
+                // upper right quadrangle
+                cross_product
+                  (x(j1,i+1)-x(j2,i), y(j-1,i3)-y(j,i2), z(j-1,i+1)-z(j,i),
+                   x(j1,i)-x(j2,i+1), y(j-1,i2)-y(j,i3), z(j-1,i)-z(j,i+1),
+                   nx, ny, nz);
 
               if ((j < (q - 1)) && (i > 0))
-                  // lower left quadrangle
-                  cross_product (x(j2,i-1)-x(j3,i), y(j,i1)-y(j+1,i2), z(j,i-1)-z(j+1,i),
-                                 x(j3,i-1)-x(j2,i), y(j+1,i1)-y(j,i2), z(j+1,i-1)-z(j,i),
-                                 nx, ny, nz);
+                // lower left quadrangle
+                cross_product
+                  (x(j2,i-1)-x(j3,i), y(j,i1)-y(j+1,i2), z(j,i-1)-z(j+1,i),
+                   x(j3,i-1)-x(j2,i), y(j+1,i1)-y(j,i2), z(j+1,i-1)-z(j,i),
+                   nx, ny, nz);
 
               if ((j < (q - 1)) && (i < (p -1)))
-                  // lower right quadrangle
-                  cross_product (x(j3,i)-x(j2,i+1), y(j+1,i2)-y(j,i3), z(j+1,i)-z(j,i+1),
-                                 x(j3,i+1)-x(j2,i), y(j+1,i3)-y(j,i2), z(j+1,i+1)-z(j,i),
-                                 nx, ny, nz);
+                // lower right quadrangle
+                cross_product
+                  (x(j3,i)-x(j2,i+1), y(j+1,i2)-y(j,i3), z(j+1,i)-z(j,i+1),
+                   x(j3,i+1)-x(j2,i), y(j+1,i3)-y(j,i2), z(j+1,i+1)-z(j,i),
+                   nx, ny, nz);
 
               double d = -std::max (std::max (fabs (nx), fabs (ny)), fabs (nz));
 
               nx /= d;
               ny /= d;
               nz /= d;
             }
         }
@@ -7751,17 +7821,17 @@ uipanel::properties::get_boundingbox (bo
   Matrix pos = get_position ().matrix_value ();
   Matrix parent_size (parent_pix_size);
 
   if (parent_size.numel () == 0)
     {
       graphics_object obj = gh_manager::get_object (get_parent ());
 
       parent_size =
-       obj.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
+        obj.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
     }
 
   pos = convert_position (pos, get_units (), "pixels", parent_size);
 
   pos(0)--;
   pos(1)--;
   pos(1) = parent_size(1) - pos(1) - pos(3);
 
@@ -8026,22 +8096,22 @@ public:
       callback (), callback_data (data) { }
 
   callback_event (const graphics_handle& h, const octave_value& cb,
                   const octave_value& data = Matrix ())
     : base_graphics_event (), handle (h), callback_name (),
       callback (cb), callback_data (data) { }
 
   void execute (void)
-    {
-      if (callback.is_defined ())
-        gh_manager::execute_callback (handle, callback, callback_data);
-      else
-        gh_manager::execute_callback (handle, callback_name, callback_data);
-    }
+  {
+    if (callback.is_defined ())
+      gh_manager::execute_callback (handle, callback, callback_data);
+    else
+      gh_manager::execute_callback (handle, callback_name, callback_data);
+  }
 
 private:
   callback_event (void)
     : base_graphics_event (), handle (), callback_name (), callback_data ()
   { }
 
 private:
   graphics_handle handle;
@@ -8054,19 +8124,19 @@ class
 function_event : public base_graphics_event
 {
 public:
   function_event (graphics_event::event_fcn fcn, void* data = 0)
     : base_graphics_event (), function (fcn), function_data (data)
   { }
 
   void execute (void)
-    {
-      function (function_data);
-    }
+  {
+    function (function_data);
+  }
 
 private:
 
   graphics_event::event_fcn function;
 
   void* function_data;
 
   // function_event objects must be created with at least a function.
@@ -8084,29 +8154,29 @@ set_event : public base_graphics_event
 {
 public:
   set_event (const graphics_handle& h, const std::string& name,
              const octave_value& value, bool do_notify_toolkit = true)
     : base_graphics_event (), handle (h), property_name (name),
       property_value (value), notify_toolkit (do_notify_toolkit) { }
 
   void execute (void)
-    {
-      gh_manager::auto_lock guard;
-
-      graphics_object go = gh_manager::get_object (handle);
-
-      if (go)
-        {
-          property p = go.get_properties ().get_property (property_name);
-
-          if (p.ok ())
-            p.set (property_value, true, notify_toolkit);
-        }
-    }
+  {
+    gh_manager::auto_lock guard;
+
+    graphics_object go = gh_manager::get_object (handle);
+
+    if (go)
+      {
+        property p = go.get_properties ().get_property (property_name);
+
+        if (p.ok ())
+          p.set (property_value, true, notify_toolkit);
+      }
+  }
 
 private:
   set_event (void)
     : base_graphics_event (), handle (), property_name (), property_value ()
   { }
 
 private:
   graphics_handle handle;
@@ -8163,17 +8233,17 @@ graphics_event::create_set_event (const 
   return e;
 }
 
 static void
 xset_gcbo (const graphics_handle& h)
 {
   graphics_object go = gh_manager::get_object (0);
   root_figure::properties& props =
-      dynamic_cast<root_figure::properties&> (go.get_properties ());
+    dynamic_cast<root_figure::properties&> (go.get_properties ());
 
   props.set_callbackobject (h.as_octave_value ());
 }
 
 void
 gh_manager::do_restore_gcbo (void)
 {
   gh_manager::auto_lock guard;
@@ -8289,33 +8359,35 @@ gh_manager::do_post_callback (const grap
     {
       if (callback_objects.empty ())
         do_post_event (graphics_event::create_callback_event (h, name, data));
       else
         {
           const graphics_object& current = callback_objects.front ();
 
           if (current.get_properties ().is_interruptible ())
-            do_post_event (graphics_event::create_callback_event (h, name, data));
+            do_post_event (graphics_event::create_callback_event (h, name,
+                                                                  data));
           else
             {
               caseless_str busy_action (go.get_properties ().get_busyaction ());
 
               if (busy_action.compare ("queue"))
-                do_post_event (graphics_event::create_callback_event (h, name, data));
+                do_post_event (graphics_event::create_callback_event (h, name,
+                                                                      data));
               else
                 {
                   caseless_str cname (name);
 
-                  if (cname.compare ("deletefcn")
-                      || cname.compare ("createfcn")
+                  if (cname.compare ("deletefcn") || cname.compare ("createfcn")
                       || (go.isa ("figure")
                           && (cname.compare ("closerequestfcn")
                               || cname.compare ("resizefcn"))))
-                    do_post_event (graphics_event::create_callback_event (h, name, data));
+                    do_post_event (
+                      graphics_event::create_callback_event (h, name, data));
                 }
             }
         }
     }
 }
 
 void
 gh_manager::do_post_function (graphics_event::event_fcn fcn, void* fcn_data)
@@ -8441,17 +8513,17 @@ root_figure::init_factory_properties (vo
   plist_map["uitoggletool"] = uitoggletool::properties::factory_defaults ();
 
   return plist_map;
 }
 
 // ---------------------------------------------------------------------
 
 DEFUN (ishandle, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ishandle (@var{h})\n\
 Return true if @var{h} is a graphics handle and false otherwise.\n\
 \n\
 @var{h} may also be a matrix of handles in which case a logical\n\
 array is returned that is true where the elements of @var{h} are\n\
 graphics handles and false where they are not.\n\
 @seealso{isaxes, isfigure}\n\
 @end deftypefn")
@@ -8501,33 +8573,33 @@ is_handle_visible (const octave_value& v
           retval = result;
         }
     }
 
   return retval;
 }
 
 DEFUN (__is_handle_visible__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} __is_handle_visible__ (@var{h})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = is_handle_visible (args(0));
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (reset, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} reset (@var{h}, @var{property})\n\
 Remove any defaults set for the handle @var{h}.  The default figure\n\
 properties of @qcode{\"position\"}, @qcode{\"units\"},\n\
 @qcode{\"windowstyle\"} and @qcode{\"paperunits\"} and the default axes\n\
 properties of @qcode{\"position\"} and @qcode{\"units\"} are not reset.\n\
 @seealso{cla, clf}\n\
 @end deftypefn")
 {
@@ -8547,17 +8619,17 @@ properties of @qcode{\"position\"} and @
             gh_manager::get_object (hcv(n)).reset_default_properties ();
         }
     }
 
   return octave_value ();
 }
 
 DEFUN (set, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} set (@var{h}, @var{property}, @var{value}, @dots{})\n\
 @deftypefnx {Built-in Function} {} set (@var{h}, @var{properties}, @var{values})\n\
 @deftypefnx {Built-in Function} {} set (@var{h}, @var{pv})\n\
 Set named property values for the graphics handle (or vector of graphics\n\
 handles) @var{h}.\n\
 There are three ways how to give the property names and values:\n\
 \n\
 @itemize\n\
@@ -8620,17 +8692,17 @@ the dimensions of @var{pv}.\n\
                       else if (hcv.length () == args(2).cell_value ().rows ())
                         {
                           obj.set (args(1).cellstr_value (),
                                    args(2).cell_value (), n);
                         }
                       else
                         {
                           error ("set: number of graphics handles must match number of value rows (%d != %d)",
-                                hcv.length (), args(2).cell_value ().rows ());
+                                 hcv.length (), args(2).cell_value ().rows ());
                           break;
 
                         }
                     }
                   else if (nargin == 2 && args(1).is_map ())
                     {
                       obj.set (args(1).map_value ());
                     }
@@ -8656,17 +8728,17 @@ the dimensions of @var{pv}.\n\
                   error ("set: invalid handle (= %g)", hcv(n));
                   break;
                 }
 
               if (error_state)
                 break;
 
               request_drawnow = true;
-           }
+            }
 
           if (! error_state && request_drawnow)
             Vdrawnow_requested = true;
         }
       else
         error ("set: expecting graphics handle as first argument");
     }
   else
@@ -8686,17 +8758,17 @@ get_graphics_object_type (const double v
     retval = obj.type ();
   else
     error ("get: invalid handle (= %g)", val);
 
   return retval;
 }
 
 DEFUN (get, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} get (@var{h})\n\
 @deftypefnx {Built-in Function} {@var{val} =} get (@var{h}, @var{p})\n\
 Return the value of the named property @var{p} from the graphics handle\n\
 @var{h}.  If @var{p} is omitted, return the complete property list for\n\
 @var{h}.  If @var{h} is a vector, return a cell array including the property\n\
 values or lists respectively.\n\
 @seealso{set}\n\
 @end deftypefn")
@@ -8763,17 +8835,19 @@ values or lists respectively.\n\
                       vals.resize (dim_vector (len, plen));
 
                       for (octave_idx_type n = 0; ! error_state && n < len; n++)
                         {
                           graphics_object obj = gh_manager::get_object (hcv(n));
 
                           if (obj)
                             {
-                              for (octave_idx_type m = 0; ! error_state && m < plen; m++)
+                              for (octave_idx_type m = 0;
+                                   ! error_state && m < plen;
+                                   m++)
                                 {
                                   caseless_str property = plist(m);
 
                                   vals(n, m) = obj.get (property);
                                 }
                             }
                           else
                             {
@@ -8861,17 +8935,17 @@ values or lists respectively.\n\
 %!assert (get (findobj (0, "Tag", "nonexistenttag"), "nonexistentproperty"), [])
 */
 
 // Return all properties from the graphics handle @var{h}.
 // If @var{h} is a vector, return a cell array including the
 // property values or lists respectively.
 
 DEFUN (__get__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __get__ (@var{h})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
@@ -8989,17 +9063,17 @@ make_graphics_object (const std::string&
     }
   else
     error ("__go_%s__: invalid parent", go_name.c_str ());
 
   return retval;
 }
 
 DEFUN (__go_figure__, args, ,
-   "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_figure__ (@var{fignum})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
@@ -9108,17 +9182,17 @@ int
 calc_dimensions (const graphics_object& go)
 {
 
   int nd = 2;
 
   if (go.isa ("surface"))
     nd = 3;
   else if ((go.isa ("line") || go.isa ("patch"))
-            && ! go.get ("zdata").is_empty ())
+           && ! go.get ("zdata").is_empty ())
     nd = 3;
   else
     {
       Matrix kids = go.get_properties ().get_children ();
 
       for (octave_idx_type i = 0; i < kids.length (); i++)
         {
           graphics_handle hnd = gh_manager::lookup (kids(i));
@@ -9135,17 +9209,17 @@ calc_dimensions (const graphics_object& 
             }
         }
     }
 
   return nd;
 }
 
 DEFUN (__calc_dimensions__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __calc_dimensions__ (@var{axes})\n\
 Internal function.  Determine the number of dimensions in a graphics\n\
 object, whether 2 or 3.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value retval;
@@ -9161,143 +9235,143 @@ object, whether 2 or 3.\n\
     retval = calc_dimensions (gh_manager::get_object (h));
   else
     error ("__calc_dimensions__: expecting graphics handle as only argument");
 
   return retval;
 }
 
 DEFUN (__go_axes__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_axes__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (axes);
 }
 
 DEFUN (__go_line__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_line__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (line);
 }
 
 DEFUN (__go_text__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_text__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (text);
 }
 
 DEFUN (__go_image__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_image__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (image);
 }
 
 DEFUN (__go_surface__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_surface__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (surface);
 }
 
 DEFUN (__go_patch__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_patch__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (patch);
 }
 
 DEFUN (__go_hggroup__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_hggroup__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (hggroup);
 }
 
 DEFUN (__go_uimenu__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_uimenu__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (uimenu);
 }
 
 DEFUN (__go_uicontrol__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_uicontrol__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (uicontrol);
 }
 
 DEFUN (__go_uipanel__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_uipanel__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (uipanel);
 }
 
 DEFUN (__go_uicontextmenu__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_uicontextmenu__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (uicontextmenu);
 }
 
 DEFUN (__go_uitoolbar__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_uitoolbar__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (uitoolbar);
 }
 
 DEFUN (__go_uipushtool__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_uipushtool__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (uipushtool);
 }
 
 DEFUN (__go_uitoggletool__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_uitoggletool__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (uitoggletool);
 }
 
 DEFUN (__go_delete__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_delete__ (@var{h})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value_list retval;
 
@@ -9332,17 +9406,17 @@ Undocumented internal function.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (__go_axes_init__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_axes_init__ (@var{h}, @var{mode})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
@@ -9371,64 +9445,65 @@ Undocumented internal function.\n\
           if (h.ok ())
             {
               graphics_object obj = gh_manager::get_object (h);
 
               obj.set_defaults (mode);
 
               h = gh_manager::lookup (val);
               if (! h.ok ())
-                error ("__go_axes_init__: axis deleted during initialization (= %g)", val);
+                error ("__go_axes_init__: axis deleted during initialization (= %g)",
+                       val);
             }
           else
             error ("__go_axes_init__: invalid graphics object (= %g)", val);
         }
       else
         error ("__go_axes_init__: invalid graphics object");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (__go_handles__, args, ,
-   "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_handles__ (@var{show_hidden})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   bool show_hidden = false;
 
   if (args.length () > 0)
     show_hidden = args(0).bool_value ();
 
   return octave_value (gh_manager::handle_list (show_hidden));
 }
 
 DEFUN (__go_figure_handles__, args, ,
-   "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __go_figure_handles__ (@var{show_hidden})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   bool show_hidden = false;
 
   if (args.length () > 0)
     show_hidden = args(0).bool_value ();
 
   return octave_value (gh_manager::figure_handle_list (show_hidden));
 }
 
 DEFUN (__go_execute_callback__, args, ,
-   "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} __go_execute_callback__ (@var{h}, @var{name})\n\
 @deftypefnx {Built-in Function} {} __go_execute_callback__ (@var{h}, @var{name}, @var{param})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
@@ -9464,17 +9539,17 @@ Undocumented internal function.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (__image_pixel_size__, args, ,
-   "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{px}, @var{py}} __image_pixel_size__ (@var{h})\n\
 Internal function: returns the pixel size of the image in normalized units.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -9559,29 +9634,29 @@ gtk_manager::do_get_toolkit (void) const
     }
   else
     retval = pl->second;
 
   return retval;
 }
 
 DEFUN (available_graphics_toolkits, , ,
-   "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} available_graphics_toolkits ()\n\
 Return a cell array of registered graphics toolkits.\n\
 @seealso{graphics_toolkit, register_graphics_toolkit}\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   return octave_value (gtk_manager::available_toolkits_list ());
 }
 
 DEFUN (register_graphics_toolkit, args, ,
-   "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} register_graphics_toolkit (@var{toolkit})\n\
 List @var{toolkit} as an available graphics toolkit.\n\
 @seealso{available_graphics_toolkits}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   gh_manager::auto_lock guard;
@@ -9597,29 +9672,29 @@ List @var{toolkit} as an available graph
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (loaded_graphics_toolkits, , ,
-   "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} loaded_graphics_toolkits ()\n\
 Return a cell array of the currently loaded graphics toolkits.\n\
 @seealso{available_graphics_toolkits}\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   return octave_value (gtk_manager::loaded_toolkits_list ());
 }
 
 DEFUN (drawnow, args, ,
-   "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} drawnow ()\n\
 @deftypefnx {Built-in Function} {} drawnow (\"expose\")\n\
 @deftypefnx {Built-in Function} {} drawnow (@var{term}, @var{file}, @var{mono}, @var{debug_file})\n\
 Update figure windows and their children.  The event queue is flushed and\n\
 any callbacks generated are executed.  With the optional argument\n\
 @qcode{\"expose\"}, only graphic objects are updated and no other events or\n\
 callbacks are processed.\n\
 The third calling form of @code{drawnow} is for debugging and is\n\
@@ -9645,17 +9720,18 @@ undocumented.\n\
 
           for (int i = 0; ! error_state && i < hlist.length (); i++)
             {
               graphics_handle h = gh_manager::lookup (hlist(i));
 
               if (h.ok () && h != 0)
                 {
                   graphics_object go = gh_manager::get_object (h);
-                  figure::properties& fprops = dynamic_cast <figure::properties&> (go.get_properties ());
+                  figure::properties& fprops
+                    = dynamic_cast <figure::properties&> (go.get_properties ());
 
                   if (fprops.is_modified ())
                     {
                       if (fprops.is_visible ())
                         {
                           gh_manager::unlock ();
 
                           fprops.get_toolkit ().redraw_figure (go);
@@ -9740,18 +9816,18 @@ undocumented.\n\
                           graphics_handle h = gcf ();
 
                           if (h.ok ())
                             {
                               graphics_object go = gh_manager::get_object (h);
 
                               gh_manager::unlock ();
 
-                              go.get_toolkit ()
-                                .print_figure (go, term, file, mono, debug_file);
+                              go.get_toolkit ().print_figure (go, term, file,
+                                                              mono, debug_file);
 
                               gh_manager::lock ();
                             }
                           else
                             error ("drawnow: nothing to draw");
                         }
                       else
                         error ("drawnow: invalid DEBUG_FILE, expected a string value");
@@ -9770,17 +9846,17 @@ undocumented.\n\
     }
 
   gh_manager::unlock ();
 
   return retval;
 }
 
 DEFUN (addlistener, args, ,
-   "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} addlistener (@var{h}, @var{prop}, @var{fcn})\n\
 Register @var{fcn} as listener for the property @var{prop} of the graphics\n\
 object @var{h}.  Property listeners are executed (in order of registration)\n\
 when the property is set.  The new value is already available when the\n\
 listeners are executed.\n\
 \n\
 @var{prop} must be a string naming a valid property in @var{h}.\n\
 \n\
@@ -9849,17 +9925,17 @@ addlistener (gcf, \"position\", @{@@my_l
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (dellistener, args, ,
-   "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} dellistener (@var{h}, @var{prop}, @var{fcn})\n\
 Remove the registration of @var{fcn} as a listener for the property\n\
 @var{prop} of the graphics object @var{h}.  The function @var{fcn} must\n\
 be the same variable (not just the same value), as was passed to the\n\
 original call to @code{addlistener}.\n\
 \n\
 If @var{fcn} is not defined then all listener functions of @var{prop}\n\
 are removed.\n\
@@ -9896,24 +9972,27 @@ dellistener (gcf, \"position\", c);\n\
             {
               graphics_handle gh = gh_manager::lookup (h);
 
               if (gh.ok ())
                 {
                   graphics_object go = gh_manager::get_object (gh);
 
                   if (args.length () == 2)
-                    go.delete_property_listener (pname, octave_value (), POSTSET);
+                    go.delete_property_listener (pname, octave_value (),
+                                                 POSTSET);
                   else
                     {
                       caseless_str persistent = args(2).string_value ();
                       if (persistent.compare ("persistent"))
                         {
-                          go.delete_property_listener (pname, octave_value (), PERSISTENT);
-                          go.delete_property_listener (pname, octave_value (), POSTSET);
+                          go.delete_property_listener (pname, octave_value (),
+                                                       PERSISTENT);
+                          go.delete_property_listener (pname, octave_value (),
+                                                       POSTSET);
                         }
                       else
                         go.delete_property_listener (pname, args(2), POSTSET);
                     }
                 }
               else
                 error ("dellistener: invalid graphics object (= %g)",
                        h);
@@ -9926,17 +10005,17 @@ dellistener (gcf, \"position\", c);\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (addproperty, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} addproperty (@var{name}, @var{h}, @var{type})\n\
 @deftypefnx {Built-in Function} {} addproperty (@var{name}, @var{h}, @var{type}, @var{arg}, @dots{})\n\
 Create a new property named @var{name} in graphics object @var{h}.\n\
 @var{type} determines the type of the property to create.  @var{args}\n\
 usually contains the default value of the property, but additional\n\
 arguments might be given, depending on the type of the property.\n\
 \n\
 The supported property types are:\n\
@@ -10139,21 +10218,21 @@ do_cleanup_waitfor_listener (const octav
               graphics_handle handle = gh_manager::lookup (h);
 
               if (handle.ok ())
                 {
                   graphics_object go = gh_manager::get_object (handle);
 
                   if (go.get_properties ().has_property (pname))
                     {
-                      go.get_properties ()
-                        .delete_listener (pname, listener, mode);
+                      go.get_properties ().delete_listener (pname, listener,
+                                                            mode);
                       if (mode == POSTSET)
-                        go.get_properties ()
-                          .delete_listener (pname, listener, PERSISTENT);
+                        go.get_properties ().delete_listener (pname, listener,
+                                                              PERSISTENT);
                     }
                 }
             }
         }
     }
 }
 
 static void
@@ -10216,17 +10295,17 @@ waitfor_del_listener (const octave_value
       if (! error_state)
         waitfor_results[id] = true;
     }
 
   return octave_value_list ();
 }
 
 DEFUN (waitfor, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} waitfor (@var{h})\n\
 @deftypefnx {Built-in Function} {} waitfor (@var{h}, @var{prop})\n\
 @deftypefnx {Built-in Function} {} waitfor (@var{h}, @var{prop}, @var{value})\n\
 @deftypefnx {Built-in Function} {} waitfor (@dots{}, \"timeout\", @var{timeout})\n\
 Suspend the execution of the current program until a condition is\n\
 satisfied on the graphics handle @var{h}.\n\
 \n\
 While the program is suspended graphics events are still being processed\n\
@@ -10403,17 +10482,17 @@ In all cases, typing CTRL-C stops progra
                 error ("waitfor: invalid parameter, expected 'timeout'");
             }
 
           if (! error_state && timeout_index >= 0)
             {
               if (args.length () > (timeout_index + 1))
                 {
                   timeout = static_cast<int>
-                    (args(timeout_index + 1).scalar_value ());
+                            (args(timeout_index + 1).scalar_value ());
 
                   if (! error_state)
                     {
                       if (timeout < 1)
                         {
                           warning ("waitfor: the timeout value must be >= 1, using 1 instead");
                           timeout = 1;
                         }
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -60,44 +60,44 @@ typedef octave_handle graphics_handle;
 class base_scaler
 {
 public:
   base_scaler (void) { }
 
   virtual ~base_scaler (void) { }
 
   virtual Matrix scale (const Matrix& m) const
-    {
-      error ("invalid axis scale");
-      return m;
-    }
+  {
+    error ("invalid axis scale");
+    return m;
+  }
 
   virtual NDArray scale (const NDArray& m) const
-    {
-      error ("invalid axis scale");
-      return m;
-    }
+  {
+    error ("invalid axis scale");
+    return m;
+  }
 
   virtual double scale (double d) const
-    {
-      error ("invalid axis scale");
-      return d;
-    }
+  {
+    error ("invalid axis scale");
+    return d;
+  }
 
   virtual double unscale (double d) const
-    {
-      error ("invalid axis scale");
-      return d;
-    }
+  {
+    error ("invalid axis scale");
+    return d;
+  }
 
   virtual base_scaler* clone () const
-    { return new base_scaler (); }
+  { return new base_scaler (); }
 
   virtual bool is_linear (void) const
-    { return false; }
+  { return false; }
 };
 
 class lin_scaler : public base_scaler
 {
 public:
   lin_scaler (void) { }
 
   Matrix scale (const Matrix& m) const { return m; }
@@ -114,153 +114,153 @@ public:
 };
 
 class log_scaler : public base_scaler
 {
 public:
   log_scaler (void) { }
 
   Matrix scale (const Matrix& m) const
-    {
-      Matrix retval (m.rows (), m.cols ());
-
-      do_scale (m.data (), retval.fortran_vec (), m.numel ());
-
-      return retval;
-    }
+  {
+    Matrix retval (m.rows (), m.cols ());
+
+    do_scale (m.data (), retval.fortran_vec (), m.numel ());
+
+    return retval;
+  }
 
   NDArray scale (const NDArray& m) const
-    {
-      NDArray retval (m.dims ());
-
-      do_scale (m.data (), retval.fortran_vec (), m.numel ());
-
-      return retval;
-    }
+  {
+    NDArray retval (m.dims ());
+
+    do_scale (m.data (), retval.fortran_vec (), m.numel ());
+
+    return retval;
+  }
 
   double scale (double d) const
-    { return log10 (d); }
+  { return log10 (d); }
 
   double unscale (double d) const
-    { return pow (10.0, d); }
+  { return pow (10.0, d); }
 
   base_scaler* clone (void) const
-    { return new log_scaler (); }
+  { return new log_scaler (); }
 
 private:
   void do_scale (const double *src, double *dest, int n) const
-    {
-      for (int i = 0; i < n; i++)
-        dest[i] = log10 (src[i]);
-    }
+  {
+    for (int i = 0; i < n; i++)
+      dest[i] = log10 (src[i]);
+  }
 };
 
 class neg_log_scaler : public base_scaler
 {
 public:
   neg_log_scaler (void) { }
 
   Matrix scale (const Matrix& m) const
-    {
-      Matrix retval (m.rows (), m.cols ());
-
-      do_scale (m.data (), retval.fortran_vec (), m.numel ());
-
-      return retval;
-    }
+  {
+    Matrix retval (m.rows (), m.cols ());
+
+    do_scale (m.data (), retval.fortran_vec (), m.numel ());
+
+    return retval;
+  }
 
   NDArray scale (const NDArray& m) const
-    {
-      NDArray retval (m.dims ());
-
-      do_scale (m.data (), retval.fortran_vec (), m.numel ());
-
-      return retval;
-    }
+  {
+    NDArray retval (m.dims ());
+
+    do_scale (m.data (), retval.fortran_vec (), m.numel ());
+
+    return retval;
+  }
 
   double scale (double d) const
-    { return -log10 (-d); }
+  { return -log10 (-d); }
 
   double unscale (double d) const
-    { return -pow (10.0, -d); }
+  { return -pow (10.0, -d); }
 
   base_scaler* clone (void) const
-    { return new neg_log_scaler (); }
+  { return new neg_log_scaler (); }
 
 private:
   void do_scale (const double *src, double *dest, int n) const
-    {
-      for (int i = 0; i < n; i++)
-        dest[i] = -log10 (-src[i]);
-    }
+  {
+    for (int i = 0; i < n; i++)
+      dest[i] = -log10 (-src[i]);
+  }
 };
 
 class scaler
 {
 public:
   scaler (void) : rep (new base_scaler ()) { }
 
   scaler (const scaler& s) : rep (s.rep->clone ()) { }
 
   scaler (const std::string& s)
     : rep (s == "log"
            ? new log_scaler ()
            : (s == "neglog" ? new neg_log_scaler ()
               : (s == "linear" ? new lin_scaler () : new base_scaler ())))
-    { }
+  { }
 
   ~scaler (void) { delete rep; }
 
   Matrix scale (const Matrix& m) const
-    { return rep->scale (m); }
+  { return rep->scale (m); }
 
   NDArray scale (const NDArray& m) const
-    { return rep->scale (m); }
+  { return rep->scale (m); }
 
   double scale (double d) const
-    { return rep->scale (d); }
+  { return rep->scale (d); }
 
   double unscale (double d) const
-    { return rep->unscale (d); }
+  { return rep->unscale (d); }
 
   bool is_linear (void) const
-    { return rep->is_linear (); }
+  { return rep->is_linear (); }
 
   scaler& operator = (const scaler& s)
-    {
-      if (rep)
-        {
-          delete rep;
-          rep = 0;
-        }
-
-      rep = s.rep->clone ();
-
-      return *this;
-    }
+  {
+    if (rep)
+      {
+        delete rep;
+        rep = 0;
+      }
+
+    rep = s.rep->clone ();
+
+    return *this;
+  }
 
   scaler& operator = (const std::string& s)
-    {
-      if (rep)
-        {
-          delete rep;
-          rep = 0;
-        }
-
-      if (s == "log")
-        rep = new log_scaler ();
-      else if (s == "neglog")
-        rep = new neg_log_scaler ();
-      else if (s == "linear")
-        rep = new lin_scaler ();
-      else
-        rep = new base_scaler ();
-
-      return *this;
-    }
+  {
+    if (rep)
+      {
+        delete rep;
+        rep = 0;
+      }
+
+    if (s == "log")
+      rep = new log_scaler ();
+    else if (s == "neglog")
+      rep = new neg_log_scaler ();
+    else if (s == "linear")
+      rep = new lin_scaler ();
+    else
+      rep = new base_scaler ();
+
+    return *this;
+  }
 
 private:
   base_scaler *rep;
 };
 
 // ---------------------------------------------------------------------
 
 class property;
@@ -270,26 +270,26 @@ enum listener_mode { POSTSET, PERSISTENT
 class base_property
 {
 public:
   friend class property;
 
 public:
   base_property (void)
     : id (-1), count (1), name (), parent (), hidden (), listeners ()
-    { }
+  { }
 
   base_property (const std::string& s, const graphics_handle& h)
     : id (-1), count (1), name (s), parent (h), hidden (false), listeners ()
-    { }
+  { }
 
   base_property (const base_property& p)
     : id (-1), count (1), name (p.name), parent (p.parent),
       hidden (p.hidden), listeners ()
-    { }
+  { }
 
   virtual ~base_property (void) { }
 
   bool ok (void) const { return parent.ok (); }
 
   std::string get_name (void) const { return name; }
 
   void set_name (const std::string& s) { name = s; }
@@ -309,113 +309,115 @@ public:
   void set_id (int d) { id = d; }
 
   // Sets property value, notifies graphics toolkit.
   // If do_run is true, runs associated listeners.
   OCTINTERP_API bool set (const octave_value& v, bool do_run = true,
                           bool do_notify_toolkit = true);
 
   virtual octave_value get (void) const
-    {
-      error ("get: invalid property \"%s\"", name.c_str ());
-      return octave_value ();
-    }
+  {
+    error ("get: invalid property \"%s\"", name.c_str ());
+    return octave_value ();
+  }
 
 
   virtual std::string values_as_string (void) const
-    {
-      error ("values_as_string: invalid property \"%s\"", name.c_str ());
-      return std::string ();
-    }
+  {
+    error ("values_as_string: invalid property \"%s\"", name.c_str ());
+    return std::string ();
+  }
 
   virtual Cell values_as_cell (void) const
-    {
-      error ("values_as_cell: invalid property \"%s\"", name.c_str ());
-      return Cell ();
-    }
+  {
+    error ("values_as_cell: invalid property \"%s\"", name.c_str ());
+    return Cell ();
+  }
 
   base_property& operator = (const octave_value& val)
-    {
-      set (val);
-      return *this;
-    }
+  {
+    set (val);
+    return *this;
+  }
 
   void add_listener (const octave_value& v, listener_mode mode = POSTSET)
-    {
-      octave_value_list& l = listeners[mode];
-      l.resize (l.length () + 1, v);
-    }
+  {
+    octave_value_list& l = listeners[mode];
+    l.resize (l.length () + 1, v);
+  }
 
   void delete_listener (const octave_value& v = octave_value (),
                         listener_mode mode = POSTSET)
-    {
-      octave_value_list& l = listeners[mode];
-
-      if (v.is_defined ())
-        {
-          bool found = false;
-          int i;
-
-          for (i = 0; i < l.length (); i++)
-            {
-              if (v.internal_rep () == l(i).internal_rep ())
-                {
-                  found = true;
-                  break;
-                }
-            }
-          if (found)
-            {
-              for (int j = i; j < l.length () - 1; j++)
-                l(j) = l(j + 1);
-
-              l.resize (l.length () - 1);
-            }
-        }
-      else
-        {
-          if (mode == PERSISTENT)
-            l.resize (0);
-          else
-            {
-              octave_value_list lnew (0);
-              octave_value_list& lp = listeners[PERSISTENT];
-              for (int i = l.length () - 1; i >= 0 ; i--)
-                {
-                  for (int j = 0; j < lp.length (); j++)
-                    {
-                      if (l(i).internal_rep () == lp(j).internal_rep ())
-                        {
-                          lnew.resize (lnew.length () + 1, l(i));
-                          break;
-                        }
-                    }
-                }
-              l = lnew;
-            }
-        }
-
-    }
+  {
+    octave_value_list& l = listeners[mode];
+
+    if (v.is_defined ())
+      {
+        bool found = false;
+        int i;
+
+        for (i = 0; i < l.length (); i++)
+          {
+            if (v.internal_rep () == l(i).internal_rep ())
+              {
+                found = true;
+                break;
+              }
+          }
+        if (found)
+          {
+            for (int j = i; j < l.length () - 1; j++)
+              l(j) = l(j + 1);
+
+            l.resize (l.length () - 1);
+          }
+      }
+    else
+      {
+        if (mode == PERSISTENT)
+          l.resize (0);
+        else
+          {
+            octave_value_list lnew (0);
+            octave_value_list& lp = listeners[PERSISTENT];
+            for (int i = l.length () - 1; i >= 0 ; i--)
+              {
+                for (int j = 0; j < lp.length (); j++)
+                  {
+                    if (l(i).internal_rep () == lp(j).internal_rep ())
+                      {
+                        lnew.resize (lnew.length () + 1, l(i));
+                        break;
+                      }
+                  }
+              }
+            l = lnew;
+          }
+      }
+
+  }
 
   OCTINTERP_API void run_listeners (listener_mode mode = POSTSET);
 
   virtual base_property* clone (void) const
-    { return new base_property (*this); }
+  { return new base_property (*this); }
 
 protected:
   virtual bool do_set (const octave_value&)
-    {
-      error ("set: invalid property \"%s\"", name.c_str ());
-      return false;
-    }
+  {
+    error ("set: invalid property \"%s\"", name.c_str ());
+    return false;
+  }
 
 private:
   typedef std::map<listener_mode, octave_value_list> listener_map;
-  typedef std::map<listener_mode, octave_value_list>::iterator listener_map_iterator;
-  typedef std::map<listener_mode, octave_value_list>::const_iterator listener_map_const_iterator;
+  typedef std::map<listener_mode, octave_value_list>::iterator
+    listener_map_iterator;
+  typedef std::map<listener_mode, octave_value_list>::const_iterator
+    listener_map_const_iterator;
 
 private:
   int id;
   octave_refcount<int> count;
   std::string name;
   graphics_handle parent;
   bool hidden;
   listener_map listeners;
@@ -429,244 +431,245 @@ public:
   string_property (const std::string& s, const graphics_handle& h,
                    const std::string& val = "")
     : base_property (s, h), str (val) { }
 
   string_property (const string_property& p)
     : base_property (p), str (p.str) { }
 
   octave_value get (void) const
-    { return octave_value (str); }
+  { return octave_value (str); }
 
   std::string string_value (void) const { return str; }
 
   string_property& operator = (const octave_value& val)
-    {
-      set (val);
-      return *this;
-    }
+  {
+    set (val);
+    return *this;
+  }
 
   base_property* clone (void) const { return new string_property (*this); }
 
 protected:
   bool do_set (const octave_value& val)
-    {
-      if (val.is_string ())
-        {
-          std::string new_str = val.string_value ();
-
-          if (new_str != str)
-            {
-              str = new_str;
-              return true;
-            }
-        }
-      else
-        error ("set: invalid string property value for \"%s\"",
-               get_name ().c_str ());
-      return false;
-    }
+  {
+    if (val.is_string ())
+      {
+        std::string new_str = val.string_value ();
+
+        if (new_str != str)
+          {
+            str = new_str;
+            return true;
+          }
+      }
+    else
+      error ("set: invalid string property value for \"%s\"",
+             get_name ().c_str ());
+    return false;
+  }
 
 private:
   std::string str;
 };
 
 // ---------------------------------------------------------------------
 
 class string_array_property : public base_property
 {
 public:
   enum desired_enum { string_t, cell_t };
 
   string_array_property (const std::string& s, const graphics_handle& h,
                          const std::string& val = "", const char& sep = '|',
                          const desired_enum& typ = string_t)
     : base_property (s, h), desired_type (typ), separator (sep), str ()
-    {
-      size_t pos = 0;
-
-      while (true)
-        {
-          size_t new_pos = val.find_first_of (separator, pos);
-
-          if (new_pos == std::string::npos)
-            {
-              str.append (val.substr (pos));
-              break;
-            }
-          else
-            str.append (val.substr (pos, new_pos - pos));
-
-          pos = new_pos + 1;
-        }
-    }
+  {
+    size_t pos = 0;
+
+    while (true)
+      {
+        size_t new_pos = val.find_first_of (separator, pos);
+
+        if (new_pos == std::string::npos)
+          {
+            str.append (val.substr (pos));
+            break;
+          }
+        else
+          str.append (val.substr (pos, new_pos - pos));
+
+        pos = new_pos + 1;
+      }
+  }
 
   string_array_property (const std::string& s, const graphics_handle& h,
                          const Cell& c, const char& sep = '|',
                          const desired_enum& typ = string_t)
     : base_property (s, h), desired_type (typ), separator (sep), str ()
-    {
-      if (c.is_cellstr ())
-        {
-          string_vector strings (c.numel ());
-
-          for (octave_idx_type i = 0; i < c.numel (); i++)
-            strings[i] = c(i).string_value ();
-
-          str = strings;
-        }
-      else
-        error ("set: invalid order property value for \"%s\"",
-               get_name ().c_str ());
-    }
+  {
+    if (c.is_cellstr ())
+      {
+        string_vector strings (c.numel ());
+
+        for (octave_idx_type i = 0; i < c.numel (); i++)
+          strings[i] = c(i).string_value ();
+
+        str = strings;
+      }
+    else
+      error ("set: invalid order property value for \"%s\"",
+             get_name ().c_str ());
+  }
 
   string_array_property (const string_array_property& p)
     : base_property (p), desired_type (p.desired_type),
       separator (p.separator), str (p.str) { }
 
   octave_value get (void) const
-    {
-      if (desired_type == string_t)
-        return octave_value (string_value ());
-      else
-        return octave_value (cell_value ());
-    }
+  {
+    if (desired_type == string_t)
+      return octave_value (string_value ());
+    else
+      return octave_value (cell_value ());
+  }
 
   std::string string_value (void) const
-    {
-      std::string s;
-
-      for (octave_idx_type i = 0; i < str.length (); i++)
-        {
-          s += str[i];
-          if (i != str.length () - 1)
-            s += separator;
-        }
-
-      return s;
-    }
+  {
+    std::string s;
+
+    for (octave_idx_type i = 0; i < str.length (); i++)
+      {
+        s += str[i];
+        if (i != str.length () - 1)
+          s += separator;
+      }
+
+    return s;
+  }
 
   Cell cell_value (void) const {return Cell (str);}
 
   string_vector string_vector_value (void) const { return str; }
 
   string_array_property& operator = (const octave_value& val)
-    {
-      set (val);
-      return *this;
-    }
-
-  base_property* clone (void) const { return new string_array_property (*this); }
+  {
+    set (val);
+    return *this;
+  }
+
+  base_property* clone (void) const
+  { return new string_array_property (*this); }
 
 protected:
   bool do_set (const octave_value& val)
-    {
-      if (val.is_string () && val.rows () == 1)
-        {
-          bool replace = false;
-          std::string new_str = val.string_value ();
-          string_vector strings;
-          size_t pos = 0;
-
-          // Split single string on delimiter (usually '|')
-          while (pos != std::string::npos)
-            {
-              size_t new_pos = new_str.find_first_of (separator, pos);
-
-              if (new_pos == std::string::npos)
+  {
+    if (val.is_string () && val.rows () == 1)
+      {
+        bool replace = false;
+        std::string new_str = val.string_value ();
+        string_vector strings;
+        size_t pos = 0;
+
+        // Split single string on delimiter (usually '|')
+        while (pos != std::string::npos)
+          {
+            size_t new_pos = new_str.find_first_of (separator, pos);
+
+            if (new_pos == std::string::npos)
+              {
+                strings.append (new_str.substr (pos));
+                break;
+              }
+            else
+              strings.append (new_str.substr (pos, new_pos - pos));
+
+            pos = new_pos + 1;
+          }
+
+        if (str.numel () == strings.numel ())
+          {
+            for (octave_idx_type i = 0; i < str.numel (); i++)
+              if (strings[i] != str[i])
                 {
-                  strings.append (new_str.substr (pos));
+                  replace = true;
                   break;
                 }
-              else
-                strings.append (new_str.substr (pos, new_pos - pos));
-
-              pos = new_pos + 1;
-            }
-
-          if (str.numel () == strings.numel ())
-            {
-              for (octave_idx_type i = 0; i < str.numel (); i++)
+          }
+        else
+          replace = true;
+
+        desired_type = string_t;
+
+        if (replace)
+          {
+            str = strings;
+            return true;
+          }
+      }
+    else if (val.is_string ())  // multi-row character matrix
+      {
+        bool replace = false;
+        charMatrix chm = val.char_matrix_value ();
+        octave_idx_type nel = chm.rows ();
+        string_vector strings (nel);
+
+        if (nel != str.numel ())
+          replace = true;
+        for (octave_idx_type i = 0; i < nel; i++)
+          {
+            strings[i] = chm.row_as_string (i);
+            if (!replace && strings[i] != str[i])
+              replace = true;
+          }
+
+        desired_type = string_t;
+
+        if (replace)
+          {
+            str = strings;
+            return true;
+          }
+      }
+    else if (val.is_cellstr ())
+      {
+        bool replace = false;
+        Cell new_cell = val.cell_value ();
+
+        string_vector strings = new_cell.cellstr_value ();
+
+        octave_idx_type nel = strings.length ();
+
+        if (nel != str.length ())
+          replace = true;
+        else
+          {
+            for (octave_idx_type i = 0; i < nel; i++)
+              {
                 if (strings[i] != str[i])
                   {
                     replace = true;
                     break;
                   }
-            }
-          else
-            replace = true;
-
-          desired_type = string_t;
-
-          if (replace)
-            {
-              str = strings;
-              return true;
-            }
-        }
-      else if (val.is_string ())  // multi-row character matrix
-        {
-          bool replace = false;
-          charMatrix chm = val.char_matrix_value ();
-          octave_idx_type nel = chm.rows ();
-          string_vector strings (nel);
-
-          if (nel != str.numel ())
-            replace = true;
-          for (octave_idx_type i = 0; i < nel; i++)
-            {
-              strings[i] = chm.row_as_string (i);
-              if (!replace && strings[i] != str[i])
-                replace = true;
-            }
-
-          desired_type = string_t;
-
-          if (replace)
-            {
-              str = strings;
-              return true;
-            }
-        }
-      else if (val.is_cellstr ())
-        {
-          bool replace = false;
-          Cell new_cell = val.cell_value ();
-
-          string_vector strings = new_cell.cellstr_value ();
-
-          octave_idx_type nel = strings.length ();
-
-          if (nel != str.length ())
-            replace = true;
-          else
-            {
-              for (octave_idx_type i = 0; i < nel; i++)
-                {
-                  if (strings[i] != str[i])
-                    {
-                      replace = true;
-                      break;
-                    }
-                }
-            }
-
-          desired_type = cell_t;
-
-          if (replace)
-            {
-              str = strings;
-              return true;
-            }
-        }
-      else
-        error ("set: invalid string property value for \"%s\"",
-               get_name ().c_str ());
-      return false;
-    }
+              }
+          }
+
+        desired_type = cell_t;
+
+        if (replace)
+          {
+            str = strings;
+            return true;
+          }
+      }
+    else
+      error ("set: invalid string property value for \"%s\"",
+             get_name ().c_str ());
+    return false;
+  }
 
 private:
   desired_enum desired_type;
   char separator;
   string_vector str;
 };
 
 // ---------------------------------------------------------------------
@@ -956,25 +959,25 @@ public:
 
   const std::string& current_value (void) const { return current_val; }
 
   std::string values_as_string (void) const { return vals.values_as_string (); }
 
   Cell values_as_cell (void) const { return vals.values_as_cell (); }
 
   bool is (const caseless_str& v) const
-    { return v.compare (current_val); }
+  { return v.compare (current_val); }
 
   bool is_radio (void) const { return true; }
 
   radio_property& operator = (const octave_value& val)
-    {
-      set (val);
-      return *this;
-    }
+  {
+    set (val);
+    return *this;
+  }
 
   base_property* clone (void) const { return new radio_property (*this); }
 
 protected:
   bool do_set (const octave_value& newval)
   {
     if (newval.is_string ())
       {
@@ -992,21 +995,21 @@ protected:
                                    "set", s.c_str (), get_name ().c_str (),
                                    match.c_str ());
                 current_val = match;
                 return true;
               }
           }
         else
           error ("set: invalid value for radio property \"%s\" (value = %s)",
-              get_name ().c_str (), s.c_str ());
+                 get_name ().c_str (), s.c_str ());
       }
     else
       error ("set: invalid value for radio property \"%s\"",
-          get_name ().c_str ());
+             get_name ().c_str ());
     return false;
   }
 
 private:
   radio_values vals;
   std::string current_val;
 };
 
@@ -1040,24 +1043,24 @@ public:
   {
     if (&c != this)
       xrgb = c.xrgb;
 
     return *this;
   }
 
   bool operator == (const color_values& c) const
-    {
-      return (xrgb(0) == c.xrgb(0)
-              && xrgb(1) == c.xrgb(1)
-              && xrgb(2) == c.xrgb(2));
-    }
+  {
+    return (xrgb(0) == c.xrgb(0)
+            && xrgb(1) == c.xrgb(1)
+            && xrgb(2) == c.xrgb(2));
+  }
 
   bool operator != (const color_values& c) const
-    { return ! (*this == c); }
+  { return ! (*this == c); }
 
   Matrix rgb (void) const { return xrgb; }
 
   operator octave_value (void) const { return xrgb; }
 
   void validate (void) const
   {
     for (int i = 0; i < 3; i++)
@@ -1133,17 +1136,17 @@ public:
     return current_val;
   }
 
   bool is_rgb (void) const { return (current_type == color_t); }
 
   bool is_radio (void) const { return (current_type == radio_t); }
 
   bool is (const std::string& v) const
-    { return (is_radio () && current_val == v); }
+  { return (is_radio () && current_val == v); }
 
   Matrix rgb (void) const
   {
     if (current_type != color_t)
       error ("color has no rgb value");
 
     return color_val.rgb ();
   }
@@ -1152,26 +1155,27 @@ public:
   {
     if (current_type != radio_t)
       error ("color has no radio value");
 
     return current_val;
   }
 
   color_property& operator = (const octave_value& val)
-    {
-      set (val);
-      return *this;
-    }
+  {
+    set (val);
+    return *this;
+  }
 
   operator octave_value (void) const { return get (); }
 
   base_property* clone (void) const { return new color_property (*this); }
 
-  std::string values_as_string (void) const { return radio_val.values_as_string (); }
+  std::string values_as_string (void) const
+  { return radio_val.values_as_string (); }
 
   Cell values_as_cell (void) const { return radio_val.values_as_cell (); }
 
 protected:
   OCTINTERP_API bool do_set (const octave_value& newval);
 
 private:
   enum current_enum { color_t, radio_t } current_type;
@@ -1193,41 +1197,41 @@ public:
   double_property (const double_property& p)
     : base_property (p), current_val (p.current_val) { }
 
   octave_value get (void) const { return octave_value (current_val); }
 
   double double_value (void) const { return current_val; }
 
   double_property& operator = (const octave_value& val)
-    {
-      set (val);
-      return *this;
-    }
+  {
+    set (val);
+    return *this;
+  }
 
   base_property* clone (void) const { return new double_property (*this); }
 
 protected:
   bool do_set (const octave_value& v)
-    {
-      if (v.is_scalar_type () && v.is_real_type ())
-        {
-          double new_val = v.double_value ();
-
-          if (new_val != current_val)
-            {
-              current_val = new_val;
-              return true;
-            }
-        }
-      else
-        error ("set: invalid value for double property \"%s\"",
-               get_name ().c_str ());
-      return false;
-    }
+  {
+    if (v.is_scalar_type () && v.is_real_type ())
+      {
+        double new_val = v.double_value ();
+
+        if (new_val != current_val)
+          {
+            current_val = new_val;
+            return true;
+          }
+      }
+    else
+      error ("set: invalid value for double property \"%s\"",
+             get_name ().c_str ());
+    return false;
+  }
 
 private:
   double current_val;
 };
 
 // ---------------------------------------------------------------------
 
 class double_radio_property : public base_property
@@ -1266,17 +1270,17 @@ public:
     return current_val;
   }
 
   bool is_double (void) const { return (current_type == double_t); }
 
   bool is_radio (void) const { return (current_type == radio_t); }
 
   bool is (const std::string& v) const
-    { return (is_radio () && current_val == v); }
+  { return (is_radio () && current_val == v); }
 
   double double_value (void) const
   {
     if (current_type != double_t)
       error ("%s: property has no double", get_name ().c_str ());
 
     return dval;
   }
@@ -1285,25 +1289,25 @@ public:
   {
     if (current_type != radio_t)
       error ("%s: property has no radio value");
 
     return current_val;
   }
 
   double_radio_property& operator = (const octave_value& val)
-    {
-      set (val);
-      return *this;
-    }
+  {
+    set (val);
+    return *this;
+  }
 
   operator octave_value (void) const { return get (); }
 
   base_property* clone (void) const
-    { return new double_radio_property (*this); }
+  { return new double_radio_property (*this); }
 
 protected:
   OCTINTERP_API bool do_set (const octave_value& v);
 
 private:
   enum current_enum { double_t, radio_t } current_type;
   double dval;
   radio_values radio_val;
@@ -1314,102 +1318,102 @@ private:
 
 class array_property : public base_property
 {
 public:
   array_property (void)
     : base_property ("", graphics_handle ()), data (Matrix ()),
       xmin (), xmax (), xminp (), xmaxp (),
       type_constraints (), size_constraints ()
-    {
-      get_data_limits ();
-    }
+  {
+    get_data_limits ();
+  }
 
   array_property (const std::string& nm, const graphics_handle& h,
                   const octave_value& m)
     : base_property (nm, h), data (m.is_sparse_type () ? m.full_value () : m),
       xmin (), xmax (), xminp (), xmaxp (),
       type_constraints (), size_constraints ()
-    {
-      get_data_limits ();
-    }
+  {
+    get_data_limits ();
+  }
 
   // This copy constructor is only intended to be used
   // internally to access min/max values; no need to
   // copy constraints.
   array_property (const array_property& p)
     : base_property (p), data (p.data),
       xmin (p.xmin), xmax (p.xmax), xminp (p.xminp), xmaxp (p.xmaxp),
       type_constraints (), size_constraints ()
-    { }
+  { }
 
   octave_value get (void) const { return data; }
 
   void add_constraint (const std::string& type)
-    { type_constraints.insert (type); }
+  { type_constraints.insert (type); }
 
   void add_constraint (const dim_vector& dims)
-    { size_constraints.push_back (dims); }
+  { size_constraints.push_back (dims); }
 
   double min_val (void) const { return xmin; }
   double max_val (void) const { return xmax; }
   double min_pos (void) const { return xminp; }
   double max_neg (void) const { return xmaxp; }
 
   Matrix get_limits (void) const
-    {
-      Matrix m (1, 4);
-
-      m(0) = min_val ();
-      m(1) = max_val ();
-      m(2) = min_pos ();
-      m(3) = max_neg ();
-
-      return m;
-    }
+  {
+    Matrix m (1, 4);
+
+    m(0) = min_val ();
+    m(1) = max_val ();
+    m(2) = min_pos ();
+    m(3) = max_neg ();
+
+    return m;
+  }
 
   array_property& operator = (const octave_value& val)
-    {
-      set (val);
-      return *this;
-    }
+  {
+    set (val);
+    return *this;
+  }
 
   base_property* clone (void) const
-    {
-      array_property *p = new array_property (*this);
-
-      p->type_constraints = type_constraints;
-      p->size_constraints = size_constraints;
-
-      return p;
-    }
+  {
+    array_property *p = new array_property (*this);
+
+    p->type_constraints = type_constraints;
+    p->size_constraints = size_constraints;
+
+    return p;
+  }
 
 protected:
   bool do_set (const octave_value& v)
-    {
-      octave_value tmp = v.is_sparse_type () ? v.full_value () : v;
-
-      if (validate (tmp))
-        {
-          // FIXME: should we check for actual data change?
-          if (! is_equal (tmp))
-            {
-              data = tmp;
-
-              get_data_limits ();
-
-              return true;
-            }
-        }
-      else
-        error ("invalid value for array property \"%s\"",
-               get_name ().c_str ());
-
-      return false;
-    }
+  {
+    octave_value tmp = v.is_sparse_type () ? v.full_value () : v;
+
+    if (validate (tmp))
+      {
+        // FIXME: should we check for actual data change?
+        if (! is_equal (tmp))
+          {
+            data = tmp;
+
+            get_data_limits ();
+
+            return true;
+          }
+      }
+    else
+      error ("invalid value for array property \"%s\"",
+             get_name ().c_str ());
+
+    return false;
+  }
 
 private:
   OCTINTERP_API bool validate (const octave_value& v);
 
   OCTINTERP_API bool is_equal (const octave_value& v) const;
 
   OCTINTERP_API void get_data_limits (void);
 
@@ -1464,24 +1468,24 @@ public:
 
   row_vector_property& operator = (const octave_value& val)
   {
     set (val);
     return *this;
   }
 
   base_property* clone (void) const
-    {
-      row_vector_property *p = new row_vector_property (*this);
-
-      p->type_constraints = type_constraints;
-      p->size_constraints = size_constraints;
-
-      return p;
-    }
+  {
+    row_vector_property *p = new row_vector_property (*this);
+
+    p->type_constraints = type_constraints;
+    p->size_constraints = size_constraints;
+
+    return p;
+  }
 
 protected:
   bool do_set (const octave_value& v)
   {
     bool retval = array_property::do_set (v);
 
     if (! error_state)
       {
@@ -1509,44 +1513,44 @@ private:
 // ---------------------------------------------------------------------
 
 class bool_property : public radio_property
 {
 public:
   bool_property (const std::string& nm, const graphics_handle& h,
                  bool val)
     : radio_property (nm, h, radio_values (val ? "{on}|off" : "on|{off}"))
-    { }
+  { }
 
   bool_property (const std::string& nm, const graphics_handle& h,
                  const char* val)
     : radio_property (nm, h, radio_values ("on|off"), val)
-    { }
+  { }
 
   bool_property (const bool_property& p)
     : radio_property (p) { }
 
   bool is_on (void) const { return is ("on"); }
 
   bool_property& operator = (const octave_value& val)
-    {
-      set (val);
-      return *this;
-    }
+  {
+    set (val);
+    return *this;
+  }
 
   base_property* clone (void) const { return new bool_property (*this); }
 
 protected:
   bool do_set (const octave_value& val)
-    {
-      if (val.is_bool_scalar ())
-        return radio_property::do_set (val.bool_value () ? "on" : "off");
-      else
-        return radio_property::do_set (val);
-    }
+  {
+    if (val.is_bool_scalar ())
+      return radio_property::do_set (val.bool_value () ? "on" : "off");
+    else
+      return radio_property::do_set (val);
+  }
 };
 
 // ---------------------------------------------------------------------
 
 class handle_property : public base_property
 {
 public:
   handle_property (const std::string& nm, const graphics_handle& h,
@@ -1557,254 +1561,254 @@ public:
   handle_property (const handle_property& p)
     : base_property (p), current_val (p.current_val) { }
 
   octave_value get (void) const { return current_val.as_octave_value (); }
 
   graphics_handle handle_value (void) const { return current_val; }
 
   handle_property& operator = (const octave_value& val)
-    {
-      set (val);
-      return *this;
-    }
+  {
+    set (val);
+    return *this;
+  }
 
   handle_property& operator = (const graphics_handle& h)
-    {
-      set (octave_value (h.value ()));
-      return *this;
-    }
+  {
+    set (octave_value (h.value ()));
+    return *this;
+  }
 
   base_property* clone (void) const { return new handle_property (*this); }
 
 protected:
   OCTINTERP_API bool do_set (const octave_value& v);
 
 private:
   graphics_handle current_val;
 };
 
 // ---------------------------------------------------------------------
 
 class any_property : public base_property
 {
 public:
   any_property (const std::string& nm, const graphics_handle& h,
-                  const octave_value& m = Matrix ())
+                const octave_value& m = Matrix ())
     : base_property (nm, h), data (m) { }
 
   any_property (const any_property& p)
     : base_property (p), data (p.data) { }
 
   octave_value get (void) const { return data; }
 
   any_property& operator = (const octave_value& val)
-    {
-      set (val);
-      return *this;
-    }
+  {
+    set (val);
+    return *this;
+  }
 
   base_property* clone (void) const { return new any_property (*this); }
 
 protected:
   bool do_set (const octave_value& v)
-    {
-      data = v;
-      return true;
-    }
+  {
+    data = v;
+    return true;
+  }
 
 private:
   octave_value data;
 };
 
 // ---------------------------------------------------------------------
 
 class children_property : public base_property
 {
 public:
   children_property (void)
     : base_property ("", graphics_handle ()), children_list ()
-    {
-      do_init_children (Matrix ());
-    }
+  {
+    do_init_children (Matrix ());
+  }
 
   children_property (const std::string& nm, const graphics_handle& h,
                      const Matrix &val)
     : base_property (nm, h), children_list ()
-    {
-      do_init_children (val);
-    }
+  {
+    do_init_children (val);
+  }
 
   children_property (const children_property& p)
     : base_property (p), children_list ()
-    {
-      do_init_children (p.children_list);
-    }
+  {
+    do_init_children (p.children_list);
+  }
 
   children_property& operator = (const octave_value& val)
-    {
-      set (val);
-      return *this;
-    }
+  {
+    set (val);
+    return *this;
+  }
 
   base_property* clone (void) const { return new children_property (*this); }
 
   bool remove_child (const double &val)
-    {
-      return do_remove_child (val);
-    }
+  {
+    return do_remove_child (val);
+  }
 
   void adopt (const double &val)
-    {
-      do_adopt_child (val);
-    }
+  {
+    do_adopt_child (val);
+  }
 
   Matrix get_children (void) const
-    {
-      return do_get_children (false);
-    }
+  {
+    return do_get_children (false);
+  }
 
   Matrix get_hidden (void) const
-    {
-      return do_get_children (true);
-    }
+  {
+    return do_get_children (true);
+  }
 
   Matrix get_all (void) const
-   {
-     return do_get_all_children ();
-   }
+  {
+    return do_get_all_children ();
+  }
 
   octave_value get (void) const
-    {
-      return octave_value (get_children ());
-    }
+  {
+    return octave_value (get_children ());
+  }
 
   void delete_children (bool clear = false)
-    {
-      do_delete_children (clear);
-    }
+  {
+    do_delete_children (clear);
+  }
 
   void renumber (graphics_handle old_gh, graphics_handle new_gh)
-    {
-      for (children_list_iterator p = children_list.begin ();
-           p != children_list.end (); p++)
-        {
-          if (*p == old_gh)
-            {
-              *p = new_gh.value ();
-              return;
-            }
-        }
-
-      error ("children_list::renumber: child not found!");
-    }
+  {
+    for (children_list_iterator p = children_list.begin ();
+         p != children_list.end (); p++)
+      {
+        if (*p == old_gh)
+          {
+            *p = new_gh.value ();
+            return;
+          }
+      }
+
+    error ("children_list::renumber: child not found!");
+  }
 
 private:
   typedef std::list<double>::iterator children_list_iterator;
   typedef std::list<double>::const_iterator const_children_list_iterator;
   std::list<double> children_list;
 
 protected:
   bool do_set (const octave_value& val)
-    {
-      const Matrix new_kids = val.matrix_value ();
-
-      octave_idx_type nel = new_kids.numel ();
-
-      const Matrix new_kids_column = new_kids.reshape (dim_vector (nel, 1));
-
-      bool is_ok = true;
-
-      if (! error_state)
-        {
-          const Matrix visible_kids = do_get_children (false);
-
-          if (visible_kids.numel () == new_kids.numel ())
-            {
-              Matrix t1 = visible_kids.sort ();
-              Matrix t2 = new_kids_column.sort ();
-
-              if (t1 != t2)
-                is_ok = false;
-            }
-          else
-            is_ok = false;
-
-          if (! is_ok)
-            error ("set: new children must be a permutation of existing children");
-        }
-      else
-        {
+  {
+    const Matrix new_kids = val.matrix_value ();
+
+    octave_idx_type nel = new_kids.numel ();
+
+    const Matrix new_kids_column = new_kids.reshape (dim_vector (nel, 1));
+
+    bool is_ok = true;
+
+    if (! error_state)
+      {
+        const Matrix visible_kids = do_get_children (false);
+
+        if (visible_kids.numel () == new_kids.numel ())
+          {
+            Matrix t1 = visible_kids.sort ();
+            Matrix t2 = new_kids_column.sort ();
+
+            if (t1 != t2)
+              is_ok = false;
+          }
+        else
           is_ok = false;
-          error ("set: expecting children to be array of graphics handles");
-        }
-
-      if (is_ok)
-        {
-          Matrix tmp = new_kids_column.stack (get_hidden ());
-
-          children_list.clear ();
-
-          // Don't use do_init_children here, as that reverses the
-          // order of the list, and we don't want to do that if setting
-          // the child list directly.
-
-          for (octave_idx_type i = 0; i < tmp.numel (); i++)
-            children_list.push_back (tmp.xelem (i));
-        }
-
-      return is_ok;
-    }
+
+        if (! is_ok)
+          error ("set: new children must be a permutation of existing children");
+      }
+    else
+      {
+        is_ok = false;
+        error ("set: expecting children to be array of graphics handles");
+      }
+
+    if (is_ok)
+      {
+        Matrix tmp = new_kids_column.stack (get_hidden ());
+
+        children_list.clear ();
+
+        // Don't use do_init_children here, as that reverses the
+        // order of the list, and we don't want to do that if setting
+        // the child list directly.
+
+        for (octave_idx_type i = 0; i < tmp.numel (); i++)
+          children_list.push_back (tmp.xelem (i));
+      }
+
+    return is_ok;
+  }
 
 private:
   void do_init_children (const Matrix &val)
-    {
-      children_list.clear ();
-      for (octave_idx_type i = 0; i < val.numel (); i++)
-        children_list.push_front (val.xelem (i));
-    }
+  {
+    children_list.clear ();
+    for (octave_idx_type i = 0; i < val.numel (); i++)
+      children_list.push_front (val.xelem (i));
+  }
 
   void do_init_children (const std::list<double> &val)
-    {
-      children_list.clear ();
-      for (const_children_list_iterator p = val.begin (); p != val.end (); p++)
-        children_list.push_front (*p);
-    }
+  {
+    children_list.clear ();
+    for (const_children_list_iterator p = val.begin (); p != val.end (); p++)
+      children_list.push_front (*p);
+  }
 
   Matrix do_get_children (bool return_hidden) const;
 
   Matrix do_get_all_children (void) const
-    {
-      Matrix retval (children_list.size (), 1);
-      octave_idx_type i  = 0;
-
-      for (const_children_list_iterator p = children_list.begin ();
-           p != children_list.end (); p++)
-        retval(i++) = *p;
-      return retval;
-    }
+  {
+    Matrix retval (children_list.size (), 1);
+    octave_idx_type i  = 0;
+
+    for (const_children_list_iterator p = children_list.begin ();
+         p != children_list.end (); p++)
+      retval(i++) = *p;
+    return retval;
+  }
 
   bool do_remove_child (double child)
-    {
-      for (children_list_iterator p = children_list.begin ();
-           p != children_list.end (); p++)
-        {
-          if (*p == child)
-            {
-              children_list.erase (p);
-              return true;
-            }
-        }
-      return false;
-    }
+  {
+    for (children_list_iterator p = children_list.begin ();
+         p != children_list.end (); p++)
+      {
+        if (*p == child)
+          {
+            children_list.erase (p);
+            return true;
+          }
+      }
+    return false;
+  }
 
   void do_adopt_child (const double &val)
-    {
-      children_list.push_front (val);
-    }
+  {
+    children_list.push_front (val);
+  }
 
   void do_delete_children (bool clear);
 };
 
 
 
 // ---------------------------------------------------------------------
 
@@ -1818,41 +1822,41 @@ public:
   callback_property (const callback_property& p)
     : base_property (p), callback (p.callback), executing (false) { }
 
   octave_value get (void) const { return callback; }
 
   OCTINTERP_API void execute (const octave_value& data = octave_value ()) const;
 
   bool is_defined (void) const
-    {
-      return (callback.is_defined () && ! callback.is_empty ());
-    }
+  {
+    return (callback.is_defined () && ! callback.is_empty ());
+  }
 
   callback_property& operator = (const octave_value& val)
-    {
-      set (val);
-      return *this;
-    }
+  {
+    set (val);
+    return *this;
+  }
 
   base_property* clone (void) const { return new callback_property (*this); }
 
 protected:
   bool do_set (const octave_value& v)
-    {
-      if (validate (v))
-        {
-          callback = v;
-          return true;
-        }
-      else
-        error ("invalid value for callback property \"%s\"",
-               get_name ().c_str ());
-      return false;
-    }
+  {
+    if (validate (v))
+      {
+        callback = v;
+        return true;
+      }
+    else
+      error ("invalid value for callback property \"%s\"",
+             get_name ().c_str ());
+    return false;
+  }
 
 private:
   OCTINTERP_API bool validate (const octave_value& v) const;
 
 private:
   octave_value callback;
 
   // If TRUE, we are executing this callback.
@@ -1860,109 +1864,109 @@ private:
 };
 
 // ---------------------------------------------------------------------
 
 class property
 {
 public:
   property (void) : rep (new base_property ("", graphics_handle ()))
-    { }
+  { }
 
   property (base_property *bp, bool persist = false) : rep (bp)
-    { if (persist) rep->count++; }
+  { if (persist) rep->count++; }
 
   property (const property& p) : rep (p.rep)
-    {
-      rep->count++;
-    }
+  {
+    rep->count++;
+  }
 
   ~property (void)
-    {
-      if (--rep->count == 0)
-        delete rep;
-    }
+  {
+    if (--rep->count == 0)
+      delete rep;
+  }
 
   bool ok (void) const
-    { return rep->ok (); }
+  { return rep->ok (); }
 
   std::string get_name (void) const
-    { return rep->get_name (); }
+  { return rep->get_name (); }
 
   void set_name (const std::string& name)
-    { rep->set_name (name); }
+  { rep->set_name (name); }
 
   graphics_handle get_parent (void) const
-    { return rep->get_parent (); }
+  { return rep->get_parent (); }
 
   void set_parent (const graphics_handle& h)
-    { rep->set_parent (h); }
+  { rep->set_parent (h); }
 
   bool is_hidden (void) const
-    { return rep->is_hidden (); }
+  { return rep->is_hidden (); }
 
   void set_hidden (bool flag)
-    { rep->set_hidden (flag); }
+  { rep->set_hidden (flag); }
 
   bool is_radio (void) const
-    { return rep->is_radio (); }
+  { return rep->is_radio (); }
 
   int get_id (void) const
-    { return rep->get_id (); }
+  { return rep->get_id (); }
 
   void set_id (int d)
-    { rep->set_id (d); }
+  { rep->set_id (d); }
 
   octave_value get (void) const
-    { return rep->get (); }
+  { return rep->get (); }
 
   bool set (const octave_value& val, bool do_run = true,
             bool do_notify_toolkit = true)
-    { return rep->set (val, do_run, do_notify_toolkit); }
+  { return rep->set (val, do_run, do_notify_toolkit); }
 
   std::string values_as_string (void) const
-    { return rep->values_as_string (); }
+  { return rep->values_as_string (); }
 
   Cell values_as_cell (void) const
-    { return rep->values_as_cell (); }
+  { return rep->values_as_cell (); }
 
   property& operator = (const octave_value& val)
-    {
-      *rep = val;
-      return *this;
-    }
+  {
+    *rep = val;
+    return *this;
+  }
 
   property& operator = (const property& p)
-    {
-      if (rep && --rep->count == 0)
-        delete rep;
-
-      rep = p.rep;
-      rep->count++;
-
-      return *this;
-    }
+  {
+    if (rep && --rep->count == 0)
+      delete rep;
+
+    rep = p.rep;
+    rep->count++;
+
+    return *this;
+  }
 
   void add_listener (const octave_value& v, listener_mode mode = POSTSET)
-    { rep->add_listener (v, mode); }
+  { rep->add_listener (v, mode); }
 
   void delete_listener (const octave_value& v = octave_value (),
                         listener_mode mode = POSTSET)
   { rep->delete_listener (v, mode); }
 
   void run_listeners (listener_mode mode = POSTSET)
-    { rep->run_listeners (mode); }
+  { rep->run_listeners (mode); }
 
   OCTINTERP_API static
-      property create (const std::string& name, const graphics_handle& parent,
-                       const caseless_str& type,
-                       const octave_value_list& args);
+  property create (const std::string& name, const graphics_handle& parent,
+                   const caseless_str& type,
+                   const octave_value_list& args);
 
   property clone (void) const
-    { return property (rep->clone ()); }
+  { return property (rep->clone ()); }
 
   /*
   const string_property& as_string_property (void) const
     { return *(dynamic_cast<string_property*> (rep)); }
 
   const radio_property& as_radio_property (void) const
     { return *(dynamic_cast<radio_property*> (rep)); }
 
@@ -2044,165 +2048,165 @@ public:
 
   virtual ~base_graphics_toolkit (void) { }
 
   std::string get_name (void) const { return name; }
 
   virtual bool is_valid (void) const { return false; }
 
   virtual void redraw_figure (const graphics_object&) const
-    { gripe_invalid ("redraw_figure"); }
+  { gripe_invalid ("redraw_figure"); }
 
   virtual void print_figure (const graphics_object&, const std::string&,
                              const std::string&, bool,
                              const std::string& = "") const
-    { gripe_invalid ("print_figure"); }
+  { gripe_invalid ("print_figure"); }
 
   virtual Matrix get_canvas_size (const graphics_handle&) const
-    {
-      gripe_invalid ("get_canvas_size");
-      return Matrix (1, 2, 0.0);
-    }
+  {
+    gripe_invalid ("get_canvas_size");
+    return Matrix (1, 2, 0.0);
+  }
 
   virtual double get_screen_resolution (void) const
-    {
-      gripe_invalid ("get_screen_resolution");
-      return 72.0;
-    }
+  {
+    gripe_invalid ("get_screen_resolution");
+    return 72.0;
+  }
 
   virtual Matrix get_screen_size (void) const
-    {
-      gripe_invalid ("get_screen_size");
-      return Matrix (1, 2, 0.0);
-    }
+  {
+    gripe_invalid ("get_screen_size");
+    return Matrix (1, 2, 0.0);
+  }
 
   // Callback function executed when the given graphics object
   // changes.  This allows the graphics toolkit to act on property
   // changes if needed.
   virtual void update (const graphics_object&, int)
-    { gripe_invalid ("base_graphics_toolkit::update"); }
+  { gripe_invalid ("base_graphics_toolkit::update"); }
 
   void update (const graphics_handle&, int);
 
   // Callback function executed when the given graphics object is
   // created.  This allows the graphics toolkit to do toolkit-specific
   // initializations for a newly created object.
   virtual bool initialize (const graphics_object&)
-    { gripe_invalid ("base_graphics_toolkit::initialize"); return false; }
+  { gripe_invalid ("base_graphics_toolkit::initialize"); return false; }
 
   bool initialize (const graphics_handle&);
 
   // Callback function executed just prior to deleting the given
   // graphics object.  This allows the graphics toolkit to perform
   // toolkit-specific cleanup operations before an object is deleted.
   virtual void finalize (const graphics_object&)
-    { gripe_invalid ("base_graphics_toolkit::finalize"); }
+  { gripe_invalid ("base_graphics_toolkit::finalize"); }
 
   void finalize (const graphics_handle&);
 
   // Close the graphics toolkit.
   virtual void close (void)
   { gripe_invalid ("base_graphics_toolkit::close"); }
 
 private:
   std::string name;
   octave_refcount<int> count;
 
 private:
   void gripe_invalid (const std::string& fname) const
-    {
-      if (! is_valid ())
-        error ("%s: invalid graphics toolkit", fname.c_str ());
-    }
+  {
+    if (! is_valid ())
+      error ("%s: invalid graphics toolkit", fname.c_str ());
+  }
 };
 
 class graphics_toolkit
 {
 public:
   graphics_toolkit (void)
     : rep (new base_graphics_toolkit ("unknown"))
-    {
-      rep->count++;
-    }
+  {
+    rep->count++;
+  }
 
   graphics_toolkit (base_graphics_toolkit* b)
     : rep (b)
-    {
-      rep->count++;
-    }
+  {
+    rep->count++;
+  }
 
   graphics_toolkit (const graphics_toolkit& b)
     : rep (b.rep)
-    {
-      rep->count++;
-    }
+  {
+    rep->count++;
+  }
 
   ~graphics_toolkit (void)
-    {
-      if (--rep->count == 0)
-        delete rep;
-    }
+  {
+    if (--rep->count == 0)
+      delete rep;
+  }
 
   graphics_toolkit& operator = (const graphics_toolkit& b)
-    {
-      if (rep != b.rep)
-        {
-          if (--rep->count == 0)
-            delete rep;
-
-          rep = b.rep;
-          rep->count++;
-        }
-
-      return *this;
-    }
+  {
+    if (rep != b.rep)
+      {
+        if (--rep->count == 0)
+          delete rep;
+
+        rep = b.rep;
+        rep->count++;
+      }
+
+    return *this;
+  }
 
   operator bool (void) const { return rep->is_valid (); }
 
   std::string get_name (void) const { return rep->get_name (); }
 
   void redraw_figure (const graphics_object& go) const
-    { rep->redraw_figure (go); }
+  { rep->redraw_figure (go); }
 
   void print_figure (const graphics_object& go, const std::string& term,
                      const std::string& file, bool mono,
                      const std::string& debug_file = "") const
-    { rep->print_figure (go, term, file, mono, debug_file); }
+  { rep->print_figure (go, term, file, mono, debug_file); }
 
   Matrix get_canvas_size (const graphics_handle& fh) const
-    { return rep->get_canvas_size (fh); }
+  { return rep->get_canvas_size (fh); }
 
   double get_screen_resolution (void) const
-    { return rep->get_screen_resolution (); }
+  { return rep->get_screen_resolution (); }
 
   Matrix get_screen_size (void) const
-    { return rep->get_screen_size (); }
+  { return rep->get_screen_size (); }
 
   // Notifies graphics toolkit that object't property has changed.
   void update (const graphics_object& go, int id)
-    { rep->update (go, id); }
+  { rep->update (go, id); }
 
   void update (const graphics_handle& h, int id)
-    { rep->update (h, id); }
+  { rep->update (h, id); }
 
   // Notifies graphics toolkit that new object was created.
   bool initialize (const graphics_object& go)
-    { return rep->initialize (go); }
+  { return rep->initialize (go); }
 
   bool initialize (const graphics_handle& h)
-    { return rep->initialize (h); }
+  { return rep->initialize (h); }
 
   // Notifies graphics toolkit that object was destroyed.
   // This is called only for explicitly deleted object. Children are
   // deleted implicitly and graphics toolkit isn't notified.
   void finalize (const graphics_object& go)
-    { rep->finalize (go); }
+  { rep->finalize (go); }
 
   void finalize (const graphics_handle& h)
-    { rep->finalize (h); }
+  { rep->finalize (h); }
 
   // Close the graphics toolkit.
   void close (void) { rep->close (); }
 
 private:
 
   base_graphics_toolkit *rep;
 };
@@ -2238,17 +2242,17 @@ public:
   {
     if (instance_ok ())
       instance->do_unload_toolkit (name);
   }
 
   static graphics_toolkit find_toolkit (const std::string& name)
   {
     return instance_ok ()
-      ? instance->do_find_toolkit (name) : graphics_toolkit ();
+           ? instance->do_find_toolkit (name) : graphics_toolkit ();
   }
 
   static Cell available_toolkits_list (void)
   {
     return instance_ok () ? instance->do_available_toolkits_list () : Cell ();
   }
 
   static Cell loaded_toolkits_list (void)
@@ -2346,29 +2350,29 @@ private:
       return p->second;
     else
       return graphics_toolkit ();
   }
 
   Cell do_available_toolkits_list (void) const
   {
     Cell m (1 , available_toolkits.size ());
-    
+
     octave_idx_type i = 0;
     for (const_available_toolkits_iterator p = available_toolkits.begin ();
          p !=  available_toolkits.end (); p++)
       m(i++) = *p;
 
     return m;
   }
 
   Cell do_loaded_toolkits_list (void) const
   {
     Cell m (1 , loaded_toolkits.size ());
-    
+
     octave_idx_type i = 0;
     for (const_loaded_toolkits_iterator p = loaded_toolkits.begin ();
          p !=  loaded_toolkits.end (); p++)
       m(i++) = p->first;
 
     return m;
   }
 
@@ -2408,31 +2412,31 @@ public:
 
   virtual std::string graphics_object_name (void) const { return "unknown"; }
 
   void mark_modified (void);
 
   void override_defaults (base_graphics_object& obj);
 
   virtual void init_integerhandle (const octave_value&)
-    {
-      panic_impossible ();
-    }
+  {
+    panic_impossible ();
+  }
 
   // Look through DEFAULTS for properties with given CLASS_NAME, and
   // apply them to the current object with set (virtual method).
 
   void set_from_list (base_graphics_object& obj, property_list& defaults);
 
   void insert_property (const std::string& name, property p)
-    {
-      p.set_name (name);
-      p.set_parent (__myhandle__);
-      all_props[name] = p;
-    }
+  {
+    p.set_name (name);
+    p.set_parent (__myhandle__);
+    all_props[name] = p;
+  }
 
   virtual void set (const caseless_str&, const octave_value&);
 
   virtual octave_value get (const caseless_str& pname) const;
 
   virtual octave_value get (const std::string& pname) const
   {
     return get (caseless_str (pname));
@@ -2451,90 +2455,91 @@ public:
   {
     panic_impossible ();
     return false;
   }
 
   bool is_modified (void) const { return is___modified__ (); }
 
   virtual void remove_child (const graphics_handle& h)
-    {
-      if (children.remove_child (h.value ()))
-        mark_modified ();
-    }
+  {
+    if (children.remove_child (h.value ()))
+      mark_modified ();
+  }
 
   virtual void adopt (const graphics_handle& h)
   {
     children.adopt (h.value ());
     mark_modified ();
   }
 
   virtual graphics_toolkit get_toolkit (void) const;
 
-  virtual Matrix get_boundingbox (bool /*internal*/ = false,
-                                  const Matrix& /*parent_pix_size*/ = Matrix ()) const
-    { return Matrix (1, 4, 0.0); }
+  virtual Matrix
+  get_boundingbox (bool /*internal*/ = false,
+                   const Matrix& /*parent_pix_size*/ = Matrix ()) const
+  { return Matrix (1, 4, 0.0); }
 
   virtual void update_boundingbox (void);
 
   virtual void update_autopos (const std::string& elem_type);
 
   virtual void add_listener (const caseless_str&, const octave_value&,
                              listener_mode = POSTSET);
 
   virtual void delete_listener (const caseless_str&, const octave_value&,
                                 listener_mode = POSTSET);
 
   void set_tag (const octave_value& val) { tag = val; }
 
   void set_parent (const octave_value& val);
 
   Matrix get_children (void) const
-    {
-      return children.get_children ();
-    }
+  {
+    return children.get_children ();
+  }
 
   Matrix get_all_children (void) const
-    {
-      return children.get_all ();
-    }
+  {
+    return children.get_all ();
+  }
 
   Matrix get_hidden_children (void) const
-    {
-      return children.get_hidden ();
-    }
+  {
+    return children.get_hidden ();
+  }
 
   void set_modified (const octave_value& val) { set___modified__ (val); }
 
   void set___modified__ (const octave_value& val) { __modified__ = val; }
 
   void reparent (const graphics_handle& new_parent) { parent = new_parent; }
 
   // Update data limits for AXIS_TYPE (xdata, ydata, etc.) in the parent
   // axes object.
 
   virtual void update_axis_limits (const std::string& axis_type) const;
 
   virtual void update_axis_limits (const std::string& axis_type,
                                    const graphics_handle& h) const;
 
   virtual void delete_children (bool clear = false)
-    {
-      children.delete_children (clear);
-    }
+  {
+    children.delete_children (clear);
+  }
 
   void renumber_child (graphics_handle old_gh, graphics_handle new_gh)
-    {
-      children.renumber (old_gh, new_gh);
-    }
+  {
+    children.renumber (old_gh, new_gh);
+  }
 
   void renumber_parent (graphics_handle new_gh)
-    {
-      parent = new_gh;
-    }
+  {
+    parent = new_gh;
+  }
 
   static property_list::pval_map_type factory_defaults (void);
 
   // FIXME: these functions should be generated automatically by the
   //        genprops.awk script.
   //
   // EMIT_BASE_PROPERTIES_GET_FUNCTIONS
 
@@ -2589,33 +2594,33 @@ protected:
     bool_property visible , "on"
     // additional (Octave-specific) properties
     bool_property __modified__ s , "on"
     graphics_handle __myhandle__ fhrs , mh
   END_PROPERTIES
 
 protected:
   struct cmp_caseless_str
+  {
+    bool operator () (const caseless_str &a, const caseless_str &b) const
     {
-      bool operator () (const caseless_str &a, const caseless_str &b) const
-        {
-          std::string a1 = a;
-          std::transform (a1.begin (), a1.end (), a1.begin (), tolower);
-          std::string b1 = b;
-          std::transform (b1.begin (), b1.end (), b1.begin (), tolower);
-
-          return a1 < b1;
-        }
-    };
+      std::string a1 = a;
+      std::transform (a1.begin (), a1.end (), a1.begin (), tolower);
+      std::string b1 = b;
+      std::transform (b1.begin (), b1.end (), b1.begin (), tolower);
+
+      return a1 < b1;
+    }
+  };
 
   std::map<caseless_str, property, cmp_caseless_str> all_props;
 
 protected:
   void insert_static_property (const std::string& name, base_property& p)
-    { insert_property (name, property (&p, true)); }
+  { insert_property (name, property (&p, true)); }
 
   virtual void init (void) { }
 };
 
 class OCTINTERP_API base_graphics_object
 {
 public:
   friend class graphics_object;
@@ -2781,17 +2786,17 @@ public:
 
   virtual bool valid_object (void) const { return false; }
 
   bool valid_toolkit_object (void) const { return toolkit_flag; }
 
   virtual std::string type (void) const
   {
     return (valid_object () ? get_properties ().graphics_object_name ()
-        : "unknown");
+                            : "unknown");
   }
 
   bool isa (const std::string& go_name) const
   {
     return type () == go_name;
   }
 
   virtual graphics_toolkit get_toolkit (void) const
@@ -2803,63 +2808,63 @@ public:
         error ("base_graphics_object::get_toolkit: invalid graphics object");
         return graphics_toolkit ();
       }
   }
 
   virtual void add_property_listener (const std::string& nm,
                                       const octave_value& v,
                                       listener_mode mode = POSTSET)
-    {
-      if (valid_object ())
-        get_properties ().add_listener (nm, v, mode);
-    }
+  {
+    if (valid_object ())
+      get_properties ().add_listener (nm, v, mode);
+  }
 
   virtual void delete_property_listener (const std::string& nm,
                                          const octave_value& v,
                                          listener_mode mode = POSTSET)
-    {
-      if (valid_object ())
-        get_properties ().delete_listener (nm, v, mode);
-    }
+  {
+    if (valid_object ())
+      get_properties ().delete_listener (nm, v, mode);
+  }
 
   virtual void remove_all_listeners (void);
 
   virtual void reset_default_properties (void)
-    {
-      if (valid_object ())
-        {
-          std::string msg = (type () + "::reset_default_properties");
-          gripe_not_implemented (msg.c_str ());
-        }
-      else
-        error ("base_graphics_object::default: invalid graphics object");
-    }
+  {
+    if (valid_object ())
+      {
+        std::string msg = (type () + "::reset_default_properties");
+        gripe_not_implemented (msg.c_str ());
+      }
+    else
+      error ("base_graphics_object::default: invalid graphics object");
+  }
 
 protected:
   virtual void initialize (const graphics_object& go)
-    {
-      if (! toolkit_flag)
-        toolkit_flag = get_toolkit ().initialize (go);
-    }
+  {
+    if (! toolkit_flag)
+      toolkit_flag = get_toolkit ().initialize (go);
+  }
 
   virtual void finalize (const graphics_object& go)
-    {
-      if (toolkit_flag)
-        {
-          get_toolkit ().finalize (go);
-          toolkit_flag = false;
-        }
-    }
+  {
+    if (toolkit_flag)
+      {
+        get_toolkit ().finalize (go);
+        toolkit_flag = false;
+      }
+  }
 
   virtual void update (const graphics_object& go, int id)
-    {
-      if (toolkit_flag)
-        get_toolkit ().update (go, id);
-    }
+  {
+    if (toolkit_flag)
+      get_toolkit ().update (go, id);
+  }
 
 protected:
   // A reference count.
   octave_refcount<int> count;
 
   // A flag telling whether this object is a valid object
   // in the backend context.
   bool toolkit_flag;
@@ -2933,19 +2938,19 @@ public:
 
   void set_defaults (const std::string& mode) { rep->set_defaults (mode); }
 
   octave_value get (bool all = false) const { return rep->get (all); }
 
   octave_value get (const caseless_str& name) const
   {
     return name.compare ("default")
-      ? get_defaults ()
-      : (name.compare ("factory")
-         ? get_factory_defaults () : rep->get (name));
+           ? get_defaults ()
+           : (name.compare ("factory")
+              ? get_factory_defaults () : rep->get (name));
   }
 
   octave_value get (const std::string& name) const
   {
     return get (caseless_str (name));
   }
 
   octave_value get (const char *name) const
@@ -3051,24 +3056,24 @@ public:
 
   bool is_handle_visible (void) const
   { return get_properties ().is_handle_visible (); }
 
   graphics_toolkit get_toolkit (void) const { return rep->get_toolkit (); }
 
   void add_property_listener (const std::string& nm, const octave_value& v,
                               listener_mode mode = POSTSET)
-    { rep->add_property_listener (nm, v, mode); }
+  { rep->add_property_listener (nm, v, mode); }
 
   void delete_property_listener (const std::string& nm, const octave_value& v,
                                  listener_mode mode = POSTSET)
-    { rep->delete_property_listener (nm, v, mode); }
+  { rep->delete_property_listener (nm, v, mode); }
 
   void initialize (void) { rep->initialize (*this); }
-  
+
   void finalize (void) { rep->finalize (*this); }
 
   void update (int id) { rep->update (*this, id); }
 
   void reset_default_properties (void)
   { rep->reset_default_properties (); }
 
 private:
@@ -3135,17 +3140,18 @@ public:
     std::list<graphics_handle> cbo_stack;
   };
 
 private:
   properties xproperties;
 
 public:
 
-  root_figure (void) : xproperties (0, graphics_handle ()), default_properties () { }
+  root_figure (void)
+    : xproperties (0, graphics_handle ()), default_properties () { }
 
   ~root_figure (void) { }
 
   void mark_modified (void) { }
 
   void override_defaults (base_graphics_object& obj)
   {
     // Now override with our defaults.  If the default_properties
@@ -3237,31 +3243,31 @@ private:
 
 class OCTINTERP_API figure : public base_graphics_object
 {
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     void init_integerhandle (const octave_value& val)
-      {
-        integerhandle = val;
-      }
+    {
+      integerhandle = val;
+    }
 
     void remove_child (const graphics_handle& h);
 
     void set_visible (const octave_value& val);
 
     graphics_toolkit get_toolkit (void) const
-      {
-        if (! toolkit)
-          toolkit = gtk_manager::get_toolkit ();
-
-        return toolkit;
-      }
+    {
+      if (! toolkit)
+        toolkit = gtk_manager::get_toolkit ();
+
+      return toolkit;
+    }
 
     void set_toolkit (const graphics_toolkit& b);
 
     void set___graphics_toolkit__ (const octave_value& val)
     {
       if (! error_state)
         {
           if (val.is_string ())
@@ -3365,26 +3371,26 @@ public:
       bool_property __enhanced__ h , "on"
       string_property __graphics_toolkit__ s , gtk_manager::default_toolkit ()
       any_property __guidata__ h , Matrix ()
       any_property __plot_stream__ h , Matrix ()
     END_PROPERTIES
 
   protected:
     void init (void)
-      {
-        alphamap.add_constraint (dim_vector (-1, 1));
-        colormap.add_constraint (dim_vector (-1, 3));
-        outerposition.add_constraint (dim_vector (1, 4));
-        paperposition.add_constraint (dim_vector (1, 4));
-        papersize.add_constraint (dim_vector (1, 2));
-        pointershapecdata.add_constraint (dim_vector (16, 16));
-        pointershapehotspot.add_constraint (dim_vector (1, 2));
-        position.add_constraint (dim_vector (1, 4));
-      }
+    {
+      alphamap.add_constraint (dim_vector (-1, 1));
+      colormap.add_constraint (dim_vector (-1, 3));
+      outerposition.add_constraint (dim_vector (1, 4));
+      paperposition.add_constraint (dim_vector (1, 4));
+      papersize.add_constraint (dim_vector (1, 2));
+      pointershapecdata.add_constraint (dim_vector (16, 16));
+      pointershapehotspot.add_constraint (dim_vector (1, 2));
+      position.add_constraint (dim_vector (1, 4));
+    }
 
   private:
     mutable graphics_toolkit toolkit;
   };
 
 private:
   properties xproperties;
 
@@ -3456,91 +3462,92 @@ private:
 // ---------------------------------------------------------------------
 
 class OCTINTERP_API graphics_xform
 {
 public:
   graphics_xform (void)
     : xform (xform_eye ()), xform_inv (xform_eye ()),
       sx ("linear"), sy ("linear"), sz ("linear"),  zlim (1, 2, 0.0)
-    {
-      zlim(1) = 1.0;
-    }
+  {
+    zlim(1) = 1.0;
+  }
 
   graphics_xform (const Matrix& xm, const Matrix& xim,
                   const scaler& x, const scaler& y, const scaler& z,
                   const Matrix& zl)
     : xform (xm), xform_inv (xim), sx (x), sy (y), sz (z), zlim (zl) { }
 
   graphics_xform (const graphics_xform& g)
     : xform (g.xform), xform_inv (g.xform_inv), sx (g.sx),
       sy (g.sy), sz (g.sz), zlim (g.zlim) { }
 
   ~graphics_xform (void) { }
 
   graphics_xform& operator = (const graphics_xform& g)
-    {
-      xform = g.xform;
-      xform_inv = g.xform_inv;
-      sx = g.sx;
-      sy = g.sy;
-      sz = g.sz;
-      zlim = g.zlim;
-
-      return *this;
-    }
+  {
+    xform = g.xform;
+    xform_inv = g.xform_inv;
+    sx = g.sx;
+    sy = g.sy;
+    sz = g.sz;
+    zlim = g.zlim;
+
+    return *this;
+  }
 
   static ColumnVector xform_vector (double x, double y, double z);
 
   static Matrix xform_eye (void);
 
   ColumnVector transform (double x, double y, double z,
                           bool use_scale = true) const;
 
   ColumnVector untransform (double x, double y, double z,
                             bool use_scale = true) const;
 
   ColumnVector untransform (double x, double y, bool use_scale = true) const
-    { return untransform (x, y, (zlim(0)+zlim(1))/2, use_scale); }
+  { return untransform (x, y, (zlim(0)+zlim(1))/2, use_scale); }
 
   Matrix xscale (const Matrix& m) const { return sx.scale (m); }
   Matrix yscale (const Matrix& m) const { return sy.scale (m); }
   Matrix zscale (const Matrix& m) const { return sz.scale (m); }
 
   Matrix scale (const Matrix& m) const
-    {
-      bool has_z = (m.columns () > 2);
-
-      if (sx.is_linear () && sy.is_linear ()
-          && (! has_z || sz.is_linear ()))
-        return m;
-
-      Matrix retval (m.dims ());
-
-      int r = m.rows ();
-
-      for (int i = 0; i < r; i++)
-        {
-          retval(i,0) = sx.scale (m(i,0));
-          retval(i,1) = sy.scale (m(i,1));
-          if (has_z)
-            retval(i,2) = sz.scale (m(i,2));
-        }
-
-      return retval;
-    }
+  {
+    bool has_z = (m.columns () > 2);
+
+    if (sx.is_linear () && sy.is_linear ()
+        && (! has_z || sz.is_linear ()))
+      return m;
+
+    Matrix retval (m.dims ());
+
+    int r = m.rows ();
+
+    for (int i = 0; i < r; i++)
+      {
+        retval(i,0) = sx.scale (m(i,0));
+        retval(i,1) = sy.scale (m(i,1));
+        if (has_z)
+          retval(i,2) = sz.scale (m(i,2));
+      }
+
+    return retval;
+  }
 
 private:
   Matrix xform;
   Matrix xform_inv;
   scaler sx, sy, sz;
   Matrix zlim;
 };
 
-enum {
+enum
+{
   AXE_ANY_DIR   = 0,
   AXE_DEPTH_DIR = 1,
   AXE_HORZ_DIR  = 2,
   AXE_VERT_DIR  = 3
 };
 
 class OCTINTERP_API axes : public base_graphics_object
 {
@@ -3553,49 +3560,50 @@ public:
     void remove_child (const graphics_handle& h);
 
     const scaler& get_x_scaler (void) const { return sx; }
     const scaler& get_y_scaler (void) const { return sy; }
     const scaler& get_z_scaler (void) const { return sz; }
 
     Matrix get_boundingbox (bool internal = false,
                             const Matrix& parent_pix_size = Matrix ()) const;
-    Matrix get_extent (bool with_text = false, bool only_text_height=false) const;
+    Matrix get_extent (bool with_text = false,
+                       bool only_text_height=false) const;
 
     double get_fontsize_points (double box_pix_height = 0) const;
 
     void update_boundingbox (void)
-      {
-        if (units_is ("normalized"))
-          {
-            sync_positions ();
-            base_properties::update_boundingbox ();
-          }
-      }
+    {
+      if (units_is ("normalized"))
+        {
+          sync_positions ();
+          base_properties::update_boundingbox ();
+        }
+    }
 
     void update_camera (void);
     void update_axes_layout (void);
     void update_aspectratios (void);
     void update_transform (void)
-      {
-        update_aspectratios ();
-        update_camera ();
-        update_axes_layout ();
-      }
+    {
+      update_aspectratios ();
+      update_camera ();
+      update_axes_layout ();
+    }
 
     void sync_positions (void);
 
     void update_autopos (const std::string& elem_type);
     void update_xlabel_position (void);
     void update_ylabel_position (void);
     void update_zlabel_position (void);
     void update_title_position (void);
 
     graphics_xform get_transform (void) const
-      { return graphics_xform (x_render, x_render_inv, sx, sy, sz, x_zlim); }
+    { return graphics_xform (x_render, x_render_inv, sx, sy, sz, x_zlim); }
 
     Matrix get_transform_matrix (void) const { return x_render; }
     Matrix get_inverse_transform_matrix (void) const { return x_render_inv; }
     Matrix get_opengl_matrix_1 (void) const { return x_gl_mat1; }
     Matrix get_opengl_matrix_2 (void) const { return x_gl_mat2; }
     Matrix get_transform_zlim (void) const { return x_zlim; }
 
     int get_xstate (void) const { return xstate; }
@@ -3639,17 +3647,18 @@ public:
     ColumnVector pixel2coord (double px, double py) const
     { return get_transform ().untransform (px, py, (x_zlim(0)+x_zlim(1))/2); }
 
     ColumnVector coord2pixel (double x, double y, double z) const
     { return get_transform ().transform (x, y, z); }
 
     void zoom_about_point (double x, double y, double factor,
                            bool push_to_zoom_stack = true);
-    void zoom (const Matrix& xl, const Matrix& yl, bool push_to_zoom_stack = true);
+    void zoom (const Matrix& xl, const Matrix& yl,
+               bool push_to_zoom_stack = true);
     void translate_view (double x0, double x1, double y0, double y1);
     void rotate_view (double delta_az, double delta_el);
     void unzoom (void);
     void clear_zoom_stack (void);
 
     void update_units (const caseless_str& old_units);
 
     void update_fontunits (const caseless_str& old_fontunits);
@@ -3829,90 +3838,93 @@ public:
     void update_view (void) { sync_positions (); }
     void update_dataaspectratio (void) { sync_positions (); }
     void update_dataaspectratiomode (void) { sync_positions (); }
     void update_plotboxaspectratio (void) { sync_positions (); }
     void update_plotboxaspectratiomode (void) { sync_positions (); }
 
     void update_layer (void) { update_axes_layout (); }
     void update_yaxislocation (void)
-      {
-        update_axes_layout ();
-        update_ylabel_position ();
-      }
+    {
+      update_axes_layout ();
+      update_ylabel_position ();
+    }
     void update_xaxislocation (void)
-      {
-        update_axes_layout ();
-        update_xlabel_position ();
-      }
+    {
+      update_axes_layout ();
+      update_xlabel_position ();
+    }
 
     void update_xdir (void) { update_camera (); update_axes_layout (); }
     void update_ydir (void) { update_camera (); update_axes_layout (); }
     void update_zdir (void) { update_camera (); update_axes_layout (); }
 
     void update_ticklength (void);
     void update_tickdir (void) { update_ticklength (); }
     void update_tickdirmode (void) { update_ticklength (); }
 
     void update_xtick (void)
-      {
-        if (xticklabelmode.is ("auto"))
-          calc_ticklabels (xtick, xticklabel, xscale.is ("log"));
-      }
+    {
+      if (xticklabelmode.is ("auto"))
+        calc_ticklabels (xtick, xticklabel, xscale.is ("log"));
+    }
     void update_ytick (void)
-      {
-        if (yticklabelmode.is ("auto"))
-          calc_ticklabels (ytick, yticklabel, yscale.is ("log"));
-      }
+    {
+      if (yticklabelmode.is ("auto"))
+        calc_ticklabels (ytick, yticklabel, yscale.is ("log"));
+    }
     void update_ztick (void)
-      {
-        if (zticklabelmode.is ("auto"))
-          calc_ticklabels (ztick, zticklabel, zscale.is ("log"));
-      }
+    {
+      if (zticklabelmode.is ("auto"))
+        calc_ticklabels (ztick, zticklabel, zscale.is ("log"));
+    }
 
     void update_xtickmode (void)
-      {
+    {
       if (xtickmode.is ("auto"))
         {
-          calc_ticks_and_lims (xlim, xtick, xmtick, xlimmode.is ("auto"), xscale.is ("log"));
+          calc_ticks_and_lims (xlim, xtick, xmtick, xlimmode.is ("auto"),
+                               xscale.is ("log"));
           update_xtick ();
         }
-      }
+    }
     void update_ytickmode (void)
-      {
+    {
       if (ytickmode.is ("auto"))
         {
-          calc_ticks_and_lims (ylim, ytick, ymtick, ylimmode.is ("auto"), yscale.is ("log"));
+          calc_ticks_and_lims (ylim, ytick, ymtick, ylimmode.is ("auto"),
+                               yscale.is ("log"));
           update_ytick ();
         }
-      }
+    }
     void update_ztickmode (void)
-      {
+    {
       if (ztickmode.is ("auto"))
         {
-          calc_ticks_and_lims (zlim, ztick, zmtick, zlimmode.is ("auto"), zscale.is ("log"));
+          calc_ticks_and_lims (zlim, ztick, zmtick, zlimmode.is ("auto"),
+                               zscale.is ("log"));
           update_ztick ();
         }
-      }
+    }
 
     void update_xticklabelmode (void)
-      {
-        if (xticklabelmode.is ("auto"))
-          calc_ticklabels (xtick, xticklabel, xscale.is ("log"));
-      }
+    {
+      if (xticklabelmode.is ("auto"))
+        calc_ticklabels (xtick, xticklabel, xscale.is ("log"));
+    }
     void update_yticklabelmode (void)
-      {
-        if (yticklabelmode.is ("auto"))
-          calc_ticklabels (ytick, yticklabel, yscale.is ("log"));
-      }
+    {
+      if (yticklabelmode.is ("auto"))
+        calc_ticklabels (ytick, yticklabel, yscale.is ("log"));
+    }
     void update_zticklabelmode (void)
-      {
-        if (zticklabelmode.is ("auto"))
-          calc_ticklabels (ztick, zticklabel, zscale.is ("log"));
-      }
+    {
+      if (zticklabelmode.is ("auto"))
+        calc_ticklabels (ztick, zticklabel, zscale.is ("log"));
+    }
 
     void update_font (void);
     void update_fontname (void) { update_font (); }
     void update_fontsize (void) { update_font (); }
     void update_fontangle (void) { update_font (); }
     void update_fontweight (void) { update_font (); }
 
     void update_outerposition (void)
@@ -3955,55 +3967,57 @@ public:
       outerbox(2) = outerbox(2) - outerbox(0);
       outerbox(3) = outerbox(3) - outerbox(1);
       outerposition = outerbox;
       set_units (old_units);
       update_transform ();
     }
 
     void update_looseinset (void)
-      {
-        caseless_str old_units = get_units ();
-        set_units ("normalized");
-        Matrix innerbox = position.get ().matrix_value ();
-        innerbox(2) = innerbox(2) + innerbox(0);
-        innerbox(3) = innerbox(3) + innerbox(1);
-        Matrix outerbox = outerposition.get ().matrix_value ();
-        outerbox(2) = outerbox(2) + outerbox(0);
-        outerbox(3) = outerbox(3) + outerbox(1);
-        Matrix linset = looseinset.get ().matrix_value ();
-        Matrix tinset = tightinset.get ().matrix_value ();
-        if (activepositionproperty.is ("position"))
-          {
-            outerbox(0) = innerbox(0) - std::max (linset(0), tinset(0));
-            outerbox(1) = innerbox(1) - std::max (linset(1), tinset(1));
-            outerbox(2) = innerbox(2) + std::max (linset(2), tinset(2));
-            outerbox(3) = innerbox(3) + std::max (linset(3), tinset(3));
-            outerbox(2) = outerbox(2) - outerbox(0);
-            outerbox(3) = outerbox(3) - outerbox(1);
-            outerposition = outerbox;
-          }
-        else
-          {
-            innerbox(0) = outerbox(0) + std::max (linset(0), tinset(0));
-            innerbox(1) = outerbox(1) + std::max (linset(1), tinset(1));
-            innerbox(2) = outerbox(2) - std::max (linset(2), tinset(2));
-            innerbox(3) = outerbox(3) - std::max (linset(3), tinset(3));
-            innerbox(2) = innerbox(2) - innerbox(0);
-            innerbox(3) = innerbox(3) - innerbox(1);
-            position = innerbox;
-          }
-        set_units (old_units);
-        update_transform ();
-      }
+    {
+      caseless_str old_units = get_units ();
+      set_units ("normalized");
+      Matrix innerbox = position.get ().matrix_value ();
+      innerbox(2) = innerbox(2) + innerbox(0);
+      innerbox(3) = innerbox(3) + innerbox(1);
+      Matrix outerbox = outerposition.get ().matrix_value ();
+      outerbox(2) = outerbox(2) + outerbox(0);
+      outerbox(3) = outerbox(3) + outerbox(1);
+      Matrix linset = looseinset.get ().matrix_value ();
+      Matrix tinset = tightinset.get ().matrix_value ();
+      if (activepositionproperty.is ("position"))
+        {
+          outerbox(0) = innerbox(0) - std::max (linset(0), tinset(0));
+          outerbox(1) = innerbox(1) - std::max (linset(1), tinset(1));
+          outerbox(2) = innerbox(2) + std::max (linset(2), tinset(2));
+          outerbox(3) = innerbox(3) + std::max (linset(3), tinset(3));
+          outerbox(2) = outerbox(2) - outerbox(0);
+          outerbox(3) = outerbox(3) - outerbox(1);
+          outerposition = outerbox;
+        }
+      else
+        {
+          innerbox(0) = outerbox(0) + std::max (linset(0), tinset(0));
+          innerbox(1) = outerbox(1) + std::max (linset(1), tinset(1));
+          innerbox(2) = outerbox(2) - std::max (linset(2), tinset(2));
+          innerbox(3) = outerbox(3) - std::max (linset(3), tinset(3));
+          innerbox(2) = innerbox(2) - innerbox(0);
+          innerbox(3) = innerbox(3) - innerbox(1);
+          position = innerbox;
+        }
+      set_units (old_units);
+      update_transform ();
+    }
 
     double calc_tick_sep (double minval, double maxval);
-    void calc_ticks_and_lims (array_property& lims, array_property& ticks, array_property& mticks,
+    void calc_ticks_and_lims (array_property& lims, array_property& ticks,
+                              array_property& mticks,
                               bool limmode_is_auto, bool is_logscale);
-    void calc_ticklabels (const array_property& ticks, any_property& labels, bool is_logscale);
+    void calc_ticklabels (const array_property& ticks, any_property& labels,
+                          bool is_logscale);
     Matrix get_ticklabel_extents (const Matrix& ticks,
                                   const string_vector& ticklabels,
                                   const Matrix& limits);
 
     void fix_limits (array_property& lims)
     {
       if (lims.get ().is_empty ())
         return;
@@ -4028,51 +4042,54 @@ public:
   public:
     Matrix get_axis_limits (double xmin, double xmax,
                             double min_pos, double max_neg,
                             bool logscale);
 
     void update_xlim (bool do_clr_zoom = true)
     {
       if (xtickmode.is ("auto"))
-        calc_ticks_and_lims (xlim, xtick, xmtick, xlimmode.is ("auto"), xscale.is ("log"));
+        calc_ticks_and_lims (xlim, xtick, xmtick, xlimmode.is ("auto"),
+                             xscale.is ("log"));
       if (xticklabelmode.is ("auto"))
         calc_ticklabels (xtick, xticklabel, xscale.is ("log"));
 
       fix_limits (xlim);
 
       update_xscale ();
 
       if (do_clr_zoom)
         zoom_stack.clear ();
 
       update_axes_layout ();
     }
 
     void update_ylim (bool do_clr_zoom = true)
     {
       if (ytickmode.is ("auto"))
-        calc_ticks_and_lims (ylim, ytick, ymtick, ylimmode.is ("auto"), yscale.is ("log"));
+        calc_ticks_and_lims (ylim, ytick, ymtick, ylimmode.is ("auto"),
+                             yscale.is ("log"));
       if (yticklabelmode.is ("auto"))
         calc_ticklabels (ytick, yticklabel, yscale.is ("log"));
 
       fix_limits (ylim);
 
       update_yscale ();
 
       if (do_clr_zoom)
         zoom_stack.clear ();
 
       update_axes_layout ();
     }
 
     void update_zlim (void)
     {
       if (ztickmode.is ("auto"))
-        calc_ticks_and_lims (zlim, ztick, zmtick, zlimmode.is ("auto"), zscale.is ("log"));
+        calc_ticks_and_lims (zlim, ztick, zmtick, zlimmode.is ("auto"),
+                             zscale.is ("log"));
       if (zticklabelmode.is ("auto"))
         calc_ticklabels (ztick, zticklabel, zscale.is ("log"));
 
       fix_limits (zlim);
 
       update_zscale ();
 
       zoom_stack.clear ();
@@ -4211,20 +4228,20 @@ public:
     Matrix compute_xlim (void) const;
     Matrix compute_ylim (void) const;
 
     void update_xdata (void) { set_xlim (compute_xlim ()); }
 
     void update_ydata (void) { set_ylim (compute_ylim ()); }
 
     void update_zdata (void)
-      {
-        set_zlim (zdata.get_limits ());
-        set_zliminclude (get_zdata ().numel () > 0);
-      }
+    {
+      set_zlim (zdata.get_limits ());
+      set_zliminclude (get_zdata ().numel () > 0);
+    }
   };
 
 private:
   properties xproperties;
 
 public:
   line (const graphics_handle& mh, const graphics_handle& p)
     : base_graphics_object (), xproperties (mh, p)
@@ -4251,21 +4268,21 @@ public:
   public:
     double get_fontsize_points (double box_pix_height = 0) const;
 
     void set_position (const octave_value& val)
     {
       if (! error_state)
         {
           octave_value new_val (val);
-    
+
           if (new_val.numel () == 2)
             {
               dim_vector dv (1, 3);
-    
+
               new_val = new_val.resize (dv, true);
             }
 
           if (position.set (new_val, false))
             {
               set_positionmode ("manual");
               update_position ();
               position.run_listeners (POSTSET);
@@ -4323,46 +4340,46 @@ public:
     const uint8NDArray& get_pixels (void) const { return pixels; }
 #if HAVE_FREETYPE
     // freetype renderer, used for calculation of text size
     ft_render renderer;
 #endif
 
   protected:
     void init (void)
-      {
-        position.add_constraint (dim_vector (1, 3));
-        cached_units = get_units ();
-        update_font ();
-      }
+    {
+      position.add_constraint (dim_vector (1, 3));
+      cached_units = get_units ();
+      update_font ();
+    }
 
   private:
     void update_position (void)
-      {
-        Matrix pos = get_data_position ();
-        Matrix lim;
-
-        lim = Matrix (1, 3, pos(0));
-        lim(2) = (lim(2) <= 0 ? octave_Inf : lim(2));
-        set_xlim (lim);
-
-        lim = Matrix (1, 3, pos(1));
-        lim(2) = (lim(2) <= 0 ? octave_Inf : lim(2));
-        set_ylim (lim);
-
-        if (pos.numel () == 3)
-          {
-            lim = Matrix (1, 3, pos(2));
-            lim(2) = (lim(2) <= 0 ? octave_Inf : lim(2));
-            set_zliminclude ("on");
-            set_zlim (lim);
-          }
-        else
-          set_zliminclude ("off");
-      }
+    {
+      Matrix pos = get_data_position ();
+      Matrix lim;
+
+      lim = Matrix (1, 3, pos(0));
+      lim(2) = (lim(2) <= 0 ? octave_Inf : lim(2));
+      set_xlim (lim);
+
+      lim = Matrix (1, 3, pos(1));
+      lim(2) = (lim(2) <= 0 ? octave_Inf : lim(2));
+      set_ylim (lim);
+
+      if (pos.numel () == 3)
+        {
+          lim = Matrix (1, 3, pos(2));
+          lim(2) = (lim(2) <= 0 ? octave_Inf : lim(2));
+          set_zliminclude ("on");
+          set_zlim (lim);
+        }
+      else
+        set_zliminclude ("off");
+    }
 
     void update_text_extent (void);
 
     void request_autopos (void);
     void update_positionmode (void) { request_autopos (); }
     void update_rotationmode (void) { request_autopos (); }
     void update_horizontalalignmentmode (void) { request_autopos (); }
     void update_verticalalignmentmode (void) { request_autopos (); }
@@ -4410,24 +4427,24 @@ public:
 
 class OCTINTERP_API image : public base_graphics_object
 {
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     bool is_aliminclude (void) const
-      { return (aliminclude.is_on () && alphadatamapping.is ("scaled")); }
+    { return (aliminclude.is_on () && alphadatamapping.is ("scaled")); }
     std::string get_aliminclude (void) const
-      { return aliminclude.current_value (); }
+    { return aliminclude.current_value (); }
 
     bool is_climinclude (void) const
-      { return (climinclude.is_on () && cdatamapping.is ("scaled")); }
+    { return (climinclude.is_on () && cdatamapping.is ("scaled")); }
     std::string get_climinclude (void) const
-      { return climinclude.current_value (); }
+    { return climinclude.current_value (); }
 
     octave_value get_color_data (void) const;
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
     // Programming note: Keep property list sorted if new ones are added.
 
     BEGIN_PROPERTIES (image)
@@ -4465,30 +4482,30 @@ public:
         cdata.add_constraint (dim_vector (-1, -1, 3));
         alphadata.add_constraint (dim_vector (-1, -1));
         alphadata.add_constraint ("double");
         alphadata.add_constraint ("uint8");
       }
 
   private:
     void update_alphadata (void)
-      {
-        if (alphadatamapping_is ("scaled"))
-          set_alim (alphadata.get_limits ());
-        else
-          alim = alphadata.get_limits ();
-      }
+    {
+      if (alphadatamapping_is ("scaled"))
+        set_alim (alphadata.get_limits ());
+      else
+        alim = alphadata.get_limits ();
+    }
 
     void update_cdata (void)
-      {
-        if (cdatamapping_is ("scaled"))
-          set_clim (cdata.get_limits ());
-        else
-          clim = cdata.get_limits ();
-      }
+    {
+      if (cdatamapping_is ("scaled"))
+        set_clim (cdata.get_limits ());
+      else
+        clim = cdata.get_limits ();
+    }
 
     void update_xdata (void)
     {
       Matrix limits = xdata.get_limits ();
       float dp = pixel_xsize ();
 
       limits(0) = limits(0) - dp;
       limits(1) = limits(1) + dp;
@@ -4559,24 +4576,24 @@ class OCTINTERP_API patch : public base_
 {
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     octave_value get_color_data (void) const;
 
     bool is_aliminclude (void) const
-      { return (aliminclude.is_on () && alphadatamapping.is ("scaled")); }
+    { return (aliminclude.is_on () && alphadatamapping.is ("scaled")); }
     std::string get_aliminclude (void) const
-      { return aliminclude.current_value (); }
+    { return aliminclude.current_value (); }
 
     bool is_climinclude (void) const
-      { return (climinclude.is_on () && cdatamapping.is ("scaled")); }
+    { return (climinclude.is_on () && cdatamapping.is ("scaled")); }
     std::string get_climinclude (void) const
-      { return climinclude.current_value (); }
+    { return climinclude.current_value (); }
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
     // Programming note: Keep property list sorted if new ones are added.
 
     BEGIN_PROPERTIES (patch)
       radio_property alphadatamapping l , "none|{scaled}|direct"
       double_property ambientstrength , 0.3
@@ -4624,43 +4641,43 @@ public:
       bool_property climinclude hlg , "on"
       bool_property xliminclude hl , "on"
       bool_property yliminclude hl , "on"
       bool_property zliminclude hl , "on"
     END_PROPERTIES
 
   protected:
     void init (void)
-      {
-        xdata.add_constraint (dim_vector (-1, -1));
-        ydata.add_constraint (dim_vector (-1, -1));
-        zdata.add_constraint (dim_vector (-1, -1));
-        faces.add_constraint (dim_vector (-1, -1));
-        vertices.add_constraint (dim_vector (-1, 2));
-        vertices.add_constraint (dim_vector (-1, 3));
-        cdata.add_constraint (dim_vector (-1, -1));
-        cdata.add_constraint (dim_vector (-1, -1, 3));
-        facevertexcdata.add_constraint (dim_vector (-1, 1));
-        facevertexcdata.add_constraint (dim_vector (-1, 3));
-        facevertexalphadata.add_constraint (dim_vector (-1, 1));
-        vertexnormals.add_constraint (dim_vector (-1, -1));
-      }
+    {
+      xdata.add_constraint (dim_vector (-1, -1));
+      ydata.add_constraint (dim_vector (-1, -1));
+      zdata.add_constraint (dim_vector (-1, -1));
+      faces.add_constraint (dim_vector (-1, -1));
+      vertices.add_constraint (dim_vector (-1, 2));
+      vertices.add_constraint (dim_vector (-1, 3));
+      cdata.add_constraint (dim_vector (-1, -1));
+      cdata.add_constraint (dim_vector (-1, -1, 3));
+      facevertexcdata.add_constraint (dim_vector (-1, 1));
+      facevertexcdata.add_constraint (dim_vector (-1, 3));
+      facevertexalphadata.add_constraint (dim_vector (-1, 1));
+      vertexnormals.add_constraint (dim_vector (-1, -1));
+    }
 
   private:
     void update_xdata (void) { set_xlim (xdata.get_limits ()); }
     void update_ydata (void) { set_ylim (ydata.get_limits ()); }
     void update_zdata (void) { set_zlim (zdata.get_limits ()); }
 
     void update_cdata (void)
-      {
-        if (cdatamapping_is ("scaled"))
-          set_clim (cdata.get_limits ());
-        else
-          clim = cdata.get_limits ();
-      }
+    {
+      if (cdatamapping_is ("scaled"))
+        set_clim (cdata.get_limits ());
+      else
+        clim = cdata.get_limits ();
+    }
   };
 
 private:
   properties xproperties;
 
 public:
   patch (const graphics_handle& mh, const graphics_handle& p)
     : base_graphics_object (), xproperties (mh, p)
@@ -4683,24 +4700,24 @@ class OCTINTERP_API surface : public bas
 {
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     octave_value get_color_data (void) const;
 
     bool is_aliminclude (void) const
-      { return (aliminclude.is_on () && alphadatamapping.is ("scaled")); }
+    { return (aliminclude.is_on () && alphadatamapping.is ("scaled")); }
     std::string get_aliminclude (void) const
-      { return aliminclude.current_value (); }
+    { return aliminclude.current_value (); }
 
     bool is_climinclude (void) const
-      { return (climinclude.is_on () && cdatamapping.is ("scaled")); }
+    { return (climinclude.is_on () && cdatamapping.is ("scaled")); }
     std::string get_climinclude (void) const
-      { return climinclude.current_value (); }
+    { return climinclude.current_value (); }
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
     // Programming note: Keep property list sorted if new ones are added.
 
     BEGIN_PROPERTIES (surface)
       array_property alphadata u , Matrix ()
       radio_property alphadatamapping l , "none|direct|{scaled}"
@@ -4750,72 +4767,72 @@ public:
       bool_property climinclude hlg , "on"
       bool_property xliminclude hl , "on"
       bool_property yliminclude hl , "on"
       bool_property zliminclude hl , "on"
     END_PROPERTIES
 
   protected:
     void init (void)
-      {
-        xdata.add_constraint (dim_vector (-1, -1));
-        ydata.add_constraint (dim_vector (-1, -1));
-        zdata.add_constraint (dim_vector (-1, -1));
-        cdata.add_constraint ("double");
-        cdata.add_constraint ("single");
-        cdata.add_constraint (dim_vector (-1, -1));
-        cdata.add_constraint (dim_vector (-1, -1, 3));
-        alphadata.add_constraint ("double");
-        alphadata.add_constraint ("uint8");
-        alphadata.add_constraint (dim_vector (-1, -1));
-        vertexnormals.add_constraint (dim_vector (-1, -1, 3));
-      }
+    {
+      xdata.add_constraint (dim_vector (-1, -1));
+      ydata.add_constraint (dim_vector (-1, -1));
+      zdata.add_constraint (dim_vector (-1, -1));
+      cdata.add_constraint ("double");
+      cdata.add_constraint ("single");
+      cdata.add_constraint (dim_vector (-1, -1));
+      cdata.add_constraint (dim_vector (-1, -1, 3));
+      alphadata.add_constraint ("double");
+      alphadata.add_constraint ("uint8");
+      alphadata.add_constraint (dim_vector (-1, -1));
+      vertexnormals.add_constraint (dim_vector (-1, -1, 3));
+    }
 
   private:
     void update_alphadata (void)
-      {
-        if (alphadatamapping_is ("scaled"))
-          set_alim (alphadata.get_limits ());
-        else
-          alim = alphadata.get_limits ();
-      }
+    {
+      if (alphadatamapping_is ("scaled"))
+        set_alim (alphadata.get_limits ());
+      else
+        alim = alphadata.get_limits ();
+    }
 
     void update_cdata (void)
-      {
-        if (cdatamapping_is ("scaled"))
-          set_clim (cdata.get_limits ());
-        else
-          clim = cdata.get_limits ();
-      }
+    {
+      if (cdatamapping_is ("scaled"))
+        set_clim (cdata.get_limits ());
+      else
+        clim = cdata.get_limits ();
+    }
 
     void update_xdata (void)
-      {
-        update_normals ();
-        set_xlim (xdata.get_limits ());
-      }
+    {
+      update_normals ();
+      set_xlim (xdata.get_limits ());
+    }
 
     void update_ydata (void)
-      {
-        update_normals ();
-        set_ylim (ydata.get_limits ());
-      }
+    {
+      update_normals ();
+      set_ylim (ydata.get_limits ());
+    }
 
     void update_zdata (void)
-      {
-        update_normals ();
-        set_zlim (zdata.get_limits ());
-      }
+    {
+      update_normals ();
+      set_zlim (zdata.get_limits ());
+    }
 
     void update_normals (void);
 
     void update_normalmode (void)
-      { update_normals (); }
+    { update_normals (); }
 
     void update_vertexnormals (void)
-      { set_normalmode ("manual"); }
+    { set_normalmode ("manual"); }
   };
 
 private:
   properties xproperties;
 
 public:
   surface (const graphics_handle& mh, const graphics_handle& p)
     : base_graphics_object (), xproperties (mh, p)
@@ -4836,27 +4853,27 @@ public:
 
 class OCTINTERP_API hggroup : public base_graphics_object
 {
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     void remove_child (const graphics_handle& h)
-      {
-        base_properties::remove_child (h);
-        update_limits ();
-      }
+    {
+      base_properties::remove_child (h);
+      update_limits ();
+    }
 
     void adopt (const graphics_handle& h)
-      {
-
-        base_properties::adopt (h);
-        update_limits (h);
-      }
+    {
+
+      base_properties::adopt (h);
+      update_limits (h);
+    }
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
     // Programming note: Keep property list sorted if new ones are added.
 
     BEGIN_PROPERTIES (hggroup)
       string_property displayname , ""
       radio_property erasemode , "{normal}|none|xor|background"
@@ -4870,23 +4887,23 @@ public:
       bool_property aliminclude h , "on"
       bool_property climinclude h , "on"
       bool_property xliminclude h , "on"
       bool_property yliminclude h , "on"
       bool_property zliminclude h , "on"
     END_PROPERTIES
 
   private:
-      void update_limits (void) const;
-
-      void update_limits (const graphics_handle& h) const;
+    void update_limits (void) const;
+
+    void update_limits (const graphics_handle& h) const;
 
   protected:
     void init (void)
-      { }
+    { }
 
   };
 
 private:
   properties xproperties;
 
 public:
   hggroup (const graphics_handle& mh, const graphics_handle& p)
@@ -4914,24 +4931,24 @@ public:
 
 class OCTINTERP_API uimenu : public base_graphics_object
 {
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     void remove_child (const graphics_handle& h)
-      {
-        base_properties::remove_child (h);
-      }
+    {
+      base_properties::remove_child (h);
+    }
 
     void adopt (const graphics_handle& h)
-      {
-        base_properties::adopt (h);
-      }
+    {
+      base_properties::adopt (h);
+    }
 
     // See the genprops.awk script for an explanation of the
     // properties declarations.
     // Programming note: Keep property list sorted if new ones are added.
 
     BEGIN_PROPERTIES (uimenu)
       any_property __object__ , Matrix ()
       string_property accelerator , ""
@@ -4943,17 +4960,17 @@ public:
       double_property position , 9
       bool_property separator , "off"
       // Octave-specific properties
       string_property fltk_label h , ""
     END_PROPERTIES
 
   protected:
     void init (void)
-      { }
+    { }
   };
 
 private:
   properties xproperties;
 
 public:
   uimenu (const graphics_handle& mh, const graphics_handle& p)
     : base_graphics_object (), xproperties (mh, p)
@@ -4986,21 +5003,21 @@ public:
     BEGIN_PROPERTIES (uicontextmenu)
       any_property __object__ , Matrix ()
       callback_property callback , Matrix ()
       array_property position , Matrix (1, 2, 0.0)
     END_PROPERTIES
 
   protected:
     void init (void)
-      {
-        position.add_constraint (dim_vector (1, 2));
-        position.add_constraint (dim_vector (2, 1));
-        visible.set (octave_value (true));
-      }
+    {
+      position.add_constraint (dim_vector (1, 2));
+      position.add_constraint (dim_vector (2, 1));
+      visible.set (octave_value (true));
+    }
   };
 
 private:
   properties xproperties;
 
 public:
   uicontextmenu (const graphics_handle& mh, const graphics_handle& p)
     : base_graphics_object (), xproperties (mh, p)
@@ -5064,25 +5081,25 @@ public:
       radio_property verticalalignment , "top|{middle}|bottom"
     END_PROPERTIES
 
   private:
     std::string cached_units;
 
   protected:
     void init (void)
-      {
-        cdata.add_constraint ("double");
-        cdata.add_constraint ("single");
-        cdata.add_constraint (dim_vector (-1, -1, 3));
-        position.add_constraint (dim_vector (1, 4));
-        sliderstep.add_constraint (dim_vector (1, 2));
-        cached_units = get_units ();
-      }
-    
+    {
+      cdata.add_constraint ("double");
+      cdata.add_constraint ("single");
+      cdata.add_constraint (dim_vector (-1, -1, 3));
+      position.add_constraint (dim_vector (1, 4));
+      sliderstep.add_constraint (dim_vector (1, 2));
+      cached_units = get_units ();
+    }
+
     void update_text_extent (void);
 
     void update_string (void) { update_text_extent (); }
     void update_fontname (void) { update_text_extent (); }
     void update_fontsize (void) { update_text_extent (); }
     void update_fontangle (void) { update_text_extent (); }
     void update_fontweight (void) { update_text_extent (); }
     void update_fontunits (const caseless_str& old_units);
@@ -5190,17 +5207,17 @@ public:
     // Programming note: Keep property list sorted if new ones are added.
 
     BEGIN_PROPERTIES (uitoolbar)
       any_property __object__ , Matrix ()
     END_PROPERTIES
 
   protected:
     void init (void)
-      { }
+    { }
   };
 
 private:
   properties xproperties;
 
 public:
   uitoolbar (const graphics_handle& mh, const graphics_handle& p)
     : base_graphics_object (), xproperties (mh, p), default_properties ()
@@ -5284,21 +5301,21 @@ public:
       callback_property clickedcallback , Matrix ()
       bool_property enable , "on"
       bool_property separator , "off"
       string_property tooltipstring , ""
     END_PROPERTIES
 
   protected:
     void init (void)
-      {
-        cdata.add_constraint ("double");
-        cdata.add_constraint ("single");
-        cdata.add_constraint (dim_vector (-1, -1, 3));
-      }
+    {
+      cdata.add_constraint ("double");
+      cdata.add_constraint ("single");
+      cdata.add_constraint (dim_vector (-1, -1, 3));
+    }
   };
 
 private:
   properties xproperties;
 
 public:
   uipushtool (const graphics_handle& mh, const graphics_handle& p)
     : base_graphics_object (), xproperties (mh, p)
@@ -5337,21 +5354,21 @@ public:
       callback_property oncallback , Matrix ()
       bool_property separator , "off"
       bool_property state , "off"
       string_property tooltipstring , ""
     END_PROPERTIES
 
   protected:
     void init (void)
-      {
-        cdata.add_constraint ("double");
-        cdata.add_constraint ("single");
-        cdata.add_constraint (dim_vector (-1, -1, 3));
-      }
+    {
+      cdata.add_constraint ("double");
+      cdata.add_constraint ("single");
+      cdata.add_constraint (dim_vector (-1, -1, 3));
+    }
   };
 
 private:
   properties xproperties;
 
 public:
   uitoggletool (const graphics_handle& mh, const graphics_handle& p)
     : base_graphics_object (), xproperties (mh, p)
@@ -5402,64 +5419,64 @@ class
 graphics_event
 {
 public:
   typedef void (*event_fcn) (void*);
 
   graphics_event (void) : rep (0) { }
 
   graphics_event (const graphics_event& e) : rep (e.rep)
-    {
-      rep->count++;
-    }
+  {
+    rep->count++;
+  }
 
   ~graphics_event (void)
-    {
-      if (rep && --rep->count == 0)
-        delete rep;
-    }
+  {
+    if (rep && --rep->count == 0)
+      delete rep;
+  }
 
   graphics_event& operator = (const graphics_event& e)
-    {
-      if (rep != e.rep)
-        {
-          if (rep && --rep->count == 0)
-            delete rep;
-
-          rep = e.rep;
-          if (rep)
-            rep->count++;
-        }
-
-      return *this;
-    }
+  {
+    if (rep != e.rep)
+      {
+        if (rep && --rep->count == 0)
+          delete rep;
+
+        rep = e.rep;
+        if (rep)
+          rep->count++;
+      }
+
+    return *this;
+  }
 
   void execute (void)
-    { if (rep) rep->execute (); }
+  { if (rep) rep->execute (); }
 
   bool ok (void) const
-    { return (rep != 0); }
+  { return (rep != 0); }
+
+  static graphics_event
+  create_callback_event (const graphics_handle& h,
+                         const std::string& name,
+                         const octave_value& data = Matrix ());
 
   static graphics_event
-      create_callback_event (const graphics_handle& h,
-                             const std::string& name,
-                             const octave_value& data = Matrix ());
-  
-  static graphics_event
-      create_callback_event (const graphics_handle& h,
-                             const octave_value& cb,
-                             const octave_value& data = Matrix ());
+  create_callback_event (const graphics_handle& h,
+                         const octave_value& cb,
+                         const octave_value& data = Matrix ());
 
   static graphics_event
-      create_function_event (event_fcn fcn, void *data = 0);
+  create_function_event (event_fcn fcn, void *data = 0);
 
   static graphics_event
-      create_set_event (const graphics_handle& h, const std::string& name,
-                        const octave_value& value,
-                        bool notify_toolkit = true);
+  create_set_event (const graphics_handle& h, const std::string& name,
+                    const octave_value& value,
+                    bool notify_toolkit = true);
 private:
   base_graphics_event *rep;
 };
 
 class OCTINTERP_API gh_manager
 {
 protected:
 
@@ -5486,17 +5503,18 @@ public:
     return retval;
   }
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
 
   static graphics_handle get_handle (bool integer_figure_handle)
   {
     return instance_ok ()
-      ? instance->do_get_handle (integer_figure_handle) : graphics_handle ();
+           ? instance->do_get_handle (integer_figure_handle)
+           : graphics_handle ();
   }
 
   static void free (const graphics_handle& h)
   {
     if (instance_ok ())
       instance->do_free (h);
   }
 
@@ -5510,17 +5528,17 @@ public:
   static graphics_handle lookup (double val)
   {
     return instance_ok () ? instance->do_lookup (val) : graphics_handle ();
   }
 
   static graphics_handle lookup (const octave_value& val)
   {
     return val.is_real_scalar ()
-      ? lookup (val.double_value ()) : graphics_handle ();
+           ? lookup (val.double_value ()) : graphics_handle ();
   }
 
   static graphics_object get_object (double val)
   {
     return get_object (lookup (val));
   }
 
   static graphics_object get_object (const graphics_handle& h)
@@ -5531,28 +5549,28 @@ public:
   static graphics_handle
   make_graphics_handle (const std::string& go_name,
                         const graphics_handle& parent,
                         bool integer_figure_handle = false,
                         bool do_createfcn = true,
                         bool do_notify_toolkit = true)
   {
     return instance_ok ()
-      ? instance->do_make_graphics_handle (go_name, parent,
-                                           integer_figure_handle,
-                                           do_createfcn, do_notify_toolkit)
-      : graphics_handle ();
+           ? instance->do_make_graphics_handle (go_name, parent,
+               integer_figure_handle,
+               do_createfcn, do_notify_toolkit)
+           : graphics_handle ();
   }
 
   static graphics_handle make_figure_handle (double val,
                                              bool do_notify_toolkit = true)
   {
     return instance_ok ()
-      ? instance->do_make_figure_handle (val, do_notify_toolkit)
-      : graphics_handle ();
+           ? instance->do_make_figure_handle (val, do_notify_toolkit)
+           : graphics_handle ();
   }
 
   static void push_figure (const graphics_handle& h)
   {
     if (instance_ok ())
       instance->do_push_figure (h);
   }
 
@@ -5560,23 +5578,23 @@ public:
   {
     if (instance_ok ())
       instance->do_pop_figure (h);
   }
 
   static graphics_handle current_figure (void)
   {
     return instance_ok ()
-      ? instance->do_current_figure () : graphics_handle ();
+           ? instance->do_current_figure () : graphics_handle ();
   }
 
   static Matrix handle_list (bool show_hidden = false)
   {
     return instance_ok ()
-      ? instance->do_handle_list (show_hidden) : Matrix ();
+           ? instance->do_handle_list (show_hidden) : Matrix ();
   }
 
   static void lock (void)
   {
     if (instance_ok ())
       instance->do_lock ();
   }
 
@@ -5588,21 +5606,21 @@ public:
       return false;
   }
 
   static void unlock (void)
   {
     if (instance_ok ())
       instance->do_unlock ();
   }
-  
+
   static Matrix figure_handle_list (bool show_hidden = false)
   {
     return instance_ok ()
-      ? instance->do_figure_handle_list (show_hidden) : Matrix ();
+           ? instance->do_figure_handle_list (show_hidden) : Matrix ();
   }
 
   static void execute_listener (const graphics_handle& h,
                                 const octave_value& l)
   {
     if (instance_ok ())
       instance->do_execute_listener (h, l);
   }
@@ -5637,17 +5655,17 @@ public:
 
   static void post_callback (const graphics_handle& h,
                              const std::string& name,
                              const octave_value& data = Matrix ())
   {
     if (instance_ok ())
       instance->do_post_callback (h, name, data);
   }
-  
+
   static void post_function (graphics_event::event_fcn fcn, void* data = 0)
   {
     if (instance_ok ())
       instance->do_post_function (fcn, data);
   }
 
   static void post_set (const graphics_handle& h, const std::string& name,
                         const octave_value& value, bool notify_toolkit = true)
@@ -5662,20 +5680,20 @@ public:
   }
 
   static int flush_events (void)
   {
     return (instance_ok () ?  instance->do_process_events (true) : 0);
   }
 
   static void enable_event_processing (bool enable = true)
-    {
-      if (instance_ok ())
-        instance->do_enable_event_processing (enable);
-    }
+  {
+    if (instance_ok ())
+      instance->do_enable_event_processing (enable);
+  }
 
   static bool is_handle_visible (const graphics_handle& h)
   {
     bool retval = false;
 
     graphics_object go = get_object (h);
 
     if (go.valid_object ())
@@ -5694,31 +5712,32 @@ public:
   class auto_lock : public octave_autolock
   {
   public:
     auto_lock (bool wait = true)
       : octave_autolock (instance_ok ()
                          ? instance->graphics_lock
                          : octave_mutex (),
                          wait)
-      { }
+    { }
 
   private:
 
     // No copying!
     auto_lock (const auto_lock&);
     auto_lock& operator = (const auto_lock&);
   };
 
 private:
 
   static gh_manager *instance;
 
   typedef std::map<graphics_handle, graphics_object>::iterator iterator;
-  typedef std::map<graphics_handle, graphics_object>::const_iterator const_iterator;
+  typedef std::map<graphics_handle, graphics_object>::const_iterator
+    const_iterator;
 
   typedef std::set<graphics_handle>::iterator free_list_iterator;
   typedef std::set<graphics_handle>::const_iterator const_free_list_iterator;
 
   typedef std::list<graphics_handle>::iterator figure_list_iterator;
   typedef std::list<graphics_handle>::const_iterator const_figure_list_iterator;
 
   // A map of handles to graphics objects.
@@ -5842,17 +5861,17 @@ private:
 
   void do_execute_listener (const graphics_handle& h, const octave_value& l);
 
   void do_execute_callback (const graphics_handle& h, const octave_value& cb,
                             const octave_value& data);
 
   void do_post_callback (const graphics_handle& h, const std::string name,
                          const octave_value& data);
-  
+
   void do_post_function (graphics_event::event_fcn fcn, void* fcn_data);
 
   void do_post_set (const graphics_handle& h, const std::string name,
                     const octave_value& value, bool notify_toolkit = true);
 
   int do_process_events (bool force = false);
 
   void do_close_all_figures (void);
diff --git a/libinterp/corefcn/gripes.cc b/libinterp/corefcn/gripes.cc
--- a/libinterp/corefcn/gripes.cc
+++ b/libinterp/corefcn/gripes.cc
@@ -56,17 +56,18 @@ gripe_range_invalid (void)
 
 void
 gripe_nonconformant (void)
 {
   error ("nonconformant matrices");
 }
 
 void
-gripe_nonconformant (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2)
+gripe_nonconformant (octave_idx_type r1, octave_idx_type c1,
+                     octave_idx_type r2, octave_idx_type c2)
 {
   error ("nonconformant matrices (op1 is %dx%d, op2 is %dx%d)",
          r1, c1, r2, c2);
 }
 
 void
 gripe_empty_arg (const char *name, bool is_error)
 {
diff --git a/libinterp/corefcn/gripes.h b/libinterp/corefcn/gripes.h
--- a/libinterp/corefcn/gripes.h
+++ b/libinterp/corefcn/gripes.h
@@ -40,17 +40,18 @@ gripe_string_invalid (void);
 
 extern OCTINTERP_API void
 gripe_range_invalid (void);
 
 extern OCTINTERP_API void
 gripe_nonconformant (void);
 
 extern OCTINTERP_API void
-gripe_nonconformant (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2);
+gripe_nonconformant (octave_idx_type r1, octave_idx_type c1,
+                     octave_idx_type r2, octave_idx_type c2);
 
 extern OCTINTERP_API void
 gripe_empty_arg (const char *name, bool is_error);
 
 extern OCTINTERP_API void
 gripe_square_matrix_required (const char *name);
 
 extern OCTINTERP_API void
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -783,17 +783,17 @@ names (const map_type& lst)
     retval[j++] = iter->first;
   return retval;
 }
 
 const static map_type operators_map (operators, operators + size (operators));
 const static map_type keywords_map (keywords, keywords + size (keywords));
 const static string_vector keyword_names = names (keywords_map);
 
-// FIXME -- It's not likely that this does the right thing now.
+// FIXME: It's not likely that this does the right thing now.
 
 string_vector
 make_name_list (void)
 {
   const int key_len = keyword_names.length ();
 
   const string_vector bif = symbol_table::built_in_function_names ();
   const int bif_len = bif.length ();
@@ -840,19 +840,20 @@ make_name_list (void)
   return list;
 }
 
 static bool
 looks_like_html (const std::string& msg)
 {
   const size_t p1 = msg.find ('\n');
   std::string t = msg.substr (0, p1);
-  const size_t p2 = t.find ("<html"); // FIXME: this comparison should be case-insensitive
+  // FIXME: this comparison should be case-insensitive
+  const size_t p2 = t.find ("<html");
 
-   return (p2 != std::string::npos);
+  return (p2 != std::string::npos);
 }
 
 static bool
 looks_like_texinfo (const std::string& msg, size_t& p1)
 {
   p1 = msg.find ('\n');
 
   std::string t = msg.substr (0, p1);
@@ -884,17 +885,17 @@ raw_help_from_symbol_table (const std::s
           h = fcn->doc_string ();
 
           retval = true;
 
           w = fcn->fcn_file_name ();
 
           if (w.empty ())
             w = fcn->is_user_function ()
-              ? "command-line function" : "built-in function";
+                ? "command-line function" : "built-in function";
         }
     }
 
   return retval;
 }
 
 static bool
 raw_help_from_file (const std::string& nm, std::string& h,
@@ -931,17 +932,17 @@ raw_help (const std::string& nm, bool& s
    || raw_help_from_file (nm, h, f, symbol_found)
    || raw_help_from_map (nm, h, operators_map, symbol_found)
    || raw_help_from_map (nm, h, keywords_map, symbol_found));
 
   return h;
 }
 
 DEFUN (built_in_docstrings_file, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} built_in_docstrings_file ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} built_in_docstrings_file (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} built_in_docstrings_file (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the name of the\n\
 file containing docstrings for built-in Octave functions.\n\
 The default value is\n\
 @file{@var{octave-home}/share/octave/@var{version}/etc/built-in-docstrings},\n\
 in which @var{octave-home} is the root directory of the Octave installation,\n\
@@ -976,17 +977,17 @@ install_built_in_docstrings (void)
           // before the interpreter is initialized, so warning messages
           // won't work properly.
 
           std::cerr << "warning: is builtin-docstrings file corrupted?"
                     << std::endl;
           return;
         }
 
-      // FIXME -- eliminate fixed buffer size.
+      // FIXME: eliminate fixed buffer size.
       size_t bufsize = 100000;
 
       OCTAVE_LOCAL_BUFFER (char, buf, bufsize);
 
       while (! file.eof ())
         {
           file.getline (buf, bufsize, 0x1d);
 
@@ -1125,17 +1126,17 @@ do_get_help_text_from_file (const std::s
       else
         {
           format = "plain text";
         }
     }
 }
 
 DEFUN (get_help_text_from_file, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{text}, @var{format}] =} get_help_text_from_file (@var{fname})\n\
 Return the raw help text from the file @var{fname}.\n\
 \n\
 The raw help text is returned in @var{text} and the format in @var{format}\n\
 The format is a string which is one of @qcode{\"texinfo\"},\n\
 @qcode{\"html\"}, or @qcode{\"plain text\"}.\n\
 @end deftypefn")
 {
@@ -1163,41 +1164,41 @@ The format is a string which is one of @
 
   return retval;
 }
 
 // Return a cell array of strings containing the names of all
 // operators.
 
 DEFUN (__operators__, , ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Function File} __operators__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   return octave_value (Cell (names (operators_map)));
 }
 
 // Return a cell array of strings containing the names of all
 // keywords.
 
 DEFUN (__keywords__, , ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Function File} __keywords__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   return octave_value (Cell (names (keywords_map)));
 }
 
 // Return a cell array of strings containing the names of all builtin
 // functions.
 
 DEFUN (__builtins__, , ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Function File} __builtins__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   const string_vector bif = symbol_table::built_in_function_names ();
 
   return octave_value (Cell (bif));
 }
@@ -1228,17 +1229,17 @@ do_which (const std::string& name, std::
                   else
                     {
                       file = fcn->src_file_name ();
                       type = "built-in function";
                     }
                 }
               else
                 type = val.is_user_script ()
-                  ? std::string ("script") : std::string ("function");
+                       ? std::string ("script") : std::string ("function");
             }
         }
       else
         {
           // We might find a file that contains only a doc string.
 
           file = load_path::find_fcn_file (name);
         }
@@ -1266,17 +1267,17 @@ do_which (const std::string& name)
   std::string type;
 
   retval = do_which (name, type);
 
   return retval;
 }
 
 DEFUN (__which__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __which__ (@var{name}, @dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   string_vector argv = args.make_argv ("which");
 
@@ -1313,25 +1314,26 @@ Undocumented internal function.\n\
         }
       else
         print_usage ();
     }
 
   return retval;
 }
 
-// FIXME -- Are we sure this function always does the right thing?
+// FIXME: Are we sure this function always does the right thing?
 inline bool
 file_is_in_dir (const std::string filename, const std::string dir)
 {
   if (filename.find (dir) == 0)
     {
       const int dir_len = dir.size ();
       const int filename_len = filename.size ();
-      const int max_allowed_seps = file_ops::is_dir_sep (dir[dir_len-1]) ? 0 : 1;
+      const int max_allowed_seps = file_ops::is_dir_sep (dir[dir_len-1]) ? 0
+                                                                         : 1;
 
       int num_seps = 0;
       for (int i = dir_len; i < filename_len; i++)
         if (file_ops::is_dir_sep (filename[i]))
           num_seps ++;
 
       return (num_seps <= max_allowed_seps);
     }
@@ -1339,17 +1341,17 @@ file_is_in_dir (const std::string filena
     return false;
 }
 
 // Return a cell array of strings containing the names of all
 // functions available in DIRECTORY.  If no directory is given, search
 // the current path.
 
 DEFUN (__list_functions__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Function File} {@var{retval} =} __list_functions__ ()\n\
 @deftypefnx {Function File} {@var{retval} =} __list_functions__ (@var{directory})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   // Get list of functions
@@ -1379,17 +1381,17 @@ Undocumented internal function.\n\
       else
         error ("__list_functions__: DIRECTORY argument must be a string");
     }
 
   return retval;
 }
 
 DEFUN (doc_cache_file, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} doc_cache_file ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} doc_cache_file (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} doc_cache_file (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the name of the\n\
 Octave documentation cache file.  A cache file significantly improves\n\
 the performance of the @code{lookfor} command.  The default value is \n\
 @file{@var{octave-home}/share/octave/@var{version}/etc/doc-cache},\n\
 in which @var{octave-home} is the root directory of the Octave installation,\n\
@@ -1403,17 +1405,17 @@ variable is changed locally for the func
 The original variable value is restored when exiting the function.\n\
 @seealso{doc_cache_create, lookfor, info_program, doc, help, makeinfo_program}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (doc_cache_file);
 }
 
 DEFUN (texi_macros_file, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} texi_macros_file ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} texi_macros_file (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} texi_macros_file (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the name of the\n\
 file containing Texinfo macros that are prepended to documentation strings\n\
 before they are passed to makeinfo.  The default value is \n\
 @file{@var{octave-home}/share/octave/@var{version}/etc/macros.texi},\n\
 in which @var{octave-home} is the root directory of the Octave installation,\n\
@@ -1427,17 +1429,17 @@ variable is changed locally for the func
 The original variable value is restored when exiting the function.\n\
 @seealso{makeinfo_program}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (texi_macros_file);
 }
 
 DEFUN (info_file, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} info_file ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} info_file (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} info_file (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the name of the\n\
 Octave info file.  The default value is\n\
 @file{@var{octave-home}/info/octave.info}, in\n\
 which @var{octave-home} is the root directory of the Octave installation.\n\
 The default value may be overridden by the environment variable\n\
@@ -1449,17 +1451,17 @@ variable is changed locally for the func
 The original variable value is restored when exiting the function.\n\
 @seealso{info_program, doc, help, makeinfo_program}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (info_file);
 }
 
 DEFUN (info_program, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} info_program ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} info_program (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} info_program (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the name of the\n\
 info program to run.  The default value is\n\
 @file{@var{octave-home}/libexec/octave/@var{version}/exec/@var{arch}/info}\n\
 in which @var{octave-home} is the root directory of the Octave installation,\n\
 @var{version} is the Octave version number, and @var{arch}\n\
@@ -1473,17 +1475,17 @@ variable is changed locally for the func
 The original variable value is restored when exiting the function.\n\
 @seealso{info_file, doc, help, makeinfo_program}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (info_program);
 }
 
 DEFUN (makeinfo_program, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} makeinfo_program ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} makeinfo_program (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} makeinfo_program (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the name of the\n\
 program that Octave runs to format help text containing\n\
 Texinfo markup commands.  The default value is @code{makeinfo}.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
@@ -1491,17 +1493,17 @@ variable is changed locally for the func
 The original variable value is restored when exiting the function.\n\
 @seealso{texi_macros_file, info_file, info_program, doc, help}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (makeinfo_program);
 }
 
 DEFUN (suppress_verbose_help_message, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} suppress_verbose_help_message ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} suppress_verbose_help_message (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} suppress_verbose_help_message (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave\n\
 will add additional help information to the end of the output from\n\
 the @code{help} command and usage messages for built-in commands.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
diff --git a/libinterp/corefcn/hess.cc b/libinterp/corefcn/hess.cc
--- a/libinterp/corefcn/hess.cc
+++ b/libinterp/corefcn/hess.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN (hess, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{H} =} hess (@var{A})\n\
 @deftypefnx {Built-in Function} {[@var{P}, @var{H}] =} hess (@var{A})\n\
 @cindex Hessenberg decomposition\n\
 Compute the Hessenberg decomposition of the matrix @var{A}.\n\
 \n\
 The Hessenberg decomposition is\n\
 @tex\n\
 $$\n\
@@ -90,17 +90,17 @@ Nash, and Van Loan, IEEE Transactions on
       gripe_square_matrix_required ("hess");
       return retval;
     }
 
   if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
         {
-         FloatMatrix tmp = arg.float_matrix_value ();
+          FloatMatrix tmp = arg.float_matrix_value ();
 
           if (! error_state)
             {
               FloatHESS result (tmp);
 
               if (nargout <= 1)
                 retval(0) = result.hess_matrix ();
               else
diff --git a/libinterp/corefcn/hex2num.cc b/libinterp/corefcn/hex2num.cc
--- a/libinterp/corefcn/hex2num.cc
+++ b/libinterp/corefcn/hex2num.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN (hex2num, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{n} =} hex2num (@var{s})\n\
 @deftypefnx {Built-in Function} {@var{n} =} hex2num (@var{s}, @var{class})\n\
 Typecast the 16 character hexadecimal character string to an IEEE 754\n\
 double precision number.  If fewer than 16 characters are given the\n\
 strings are right padded with @qcode{'0'} characters.\n\
 \n\
 Given a string matrix, @code{hex2num} treats each row as a separate\n\
 number.\n\
@@ -192,17 +192,17 @@ hex2num ([\"402df854\"; \"41200000\"], \
 }
 
 /*
 %!assert (hex2num (["c00";"bff";"000";"3ff";"400"]), [-2:2]')
 %!assert (hex2num (["c00";"bf8";"000";"3f8";"400"], "single"), single([-2:2])')
 */
 
 DEFUN (num2hex, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{s} =} num2hex (@var{n})\n\
 Typecast a double or single precision number or vector to a 8 or 16\n\
 character hexadecimal string of the IEEE 754 representation of the number.\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 num2hex ([-1, 1, e, Inf])\n\
@@ -252,17 +252,17 @@ num2hex (single ([-1, 1, e, Inf]))\n\
                 float dval;
               } num;
 
               num.dval = *pv++;
 
               for (octave_idx_type j = 0; j < nchars; j++)
                 {
                   unsigned char ch =
-                    static_cast<char> (num.ival >> ((nchars - 1 - j) * 4) & 0xF);
+                    static_cast<char>(num.ival >> ((nchars - 1 - j) * 4) & 0xF);
                   if (ch >= 10)
                     ch += 'a' - 10;
                   else
                     ch += '0';
 
                   m.elem (i, j) = ch;
                 }
             }
@@ -289,17 +289,17 @@ num2hex (single ([-1, 1, e, Inf]))\n\
                 double dval;
               } num;
 
               num.dval = *pv++;
 
               for (octave_idx_type j = 0; j < nchars; j++)
                 {
                   unsigned char ch =
-                    static_cast<char> (num.ival >> ((nchars - 1 - j) * 4) & 0xF);
+                    static_cast<char>(num.ival >> ((nchars - 1 - j) * 4) & 0xF);
                   if (ch >= 10)
                     ch += 'a' - 10;
                   else
                     ch += '0';
 
                   m.elem (i, j) = ch;
                 }
             }
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -142,19 +142,19 @@ set_default_prompts (void)
   VPS4 = "+ ";
 
   octave_link::set_default_prompts (VPS1, VPS2, VPS4);
 }
 
 void
 octave_base_reader::do_input_echo (const std::string& input_string) const
 {
-  int do_echo = reading_script_file () ?
-    (Vecho_executing_commands & ECHO_SCRIPTS)
-      : (Vecho_executing_commands & ECHO_CMD_LINE) && ! forced_interactive;
+  int do_echo = reading_script_file ()
+    ? (Vecho_executing_commands & ECHO_SCRIPTS)
+    : (Vecho_executing_commands & ECHO_CMD_LINE) && ! forced_interactive;
 
   if (do_echo)
     {
       if (forced_interactive)
         {
           if (pflag > 0)
             octave_stdout << command_editor::decode_prompt_string (VPS1);
           else
@@ -319,17 +319,17 @@ octave_base_reader::reading_script_file 
 
 FILE *
 get_input_from_stdin (void)
 {
   command_editor::set_input_stream (stdin);
   return command_editor::get_input_stream ();
 }
 
-// FIXME -- make this generate file names when appropriate.
+// FIXME: make this generate file names when appropriate.
 
 static string_vector
 generate_possible_completions (const std::string& text, std::string& prefix,
                                std::string& hint)
 {
   string_vector names;
 
   prefix = "";
@@ -431,18 +431,18 @@ generate_completion (const std::string& 
 
           if (hint == name.substr (0, hint_len))
             {
               if (list_index <= name_list_len && ! prefix.empty ())
                 retval = prefix + "." + name;
               else
                 retval = name;
 
-              // FIXME -- looks_like_struct is broken for now,
-              // so it always returns false.
+              // FIXME: looks_like_struct is broken for now,
+              //        so it always returns false.
 
               if (matches == 1 && looks_like_struct (retval))
                 {
                   // Don't append anything, since we don't know
                   // whether it should be '(' or '.'.
 
                   command_editor::set_completion_append_character ('\0');
                 }
@@ -470,17 +470,17 @@ quoting_filename (const std::string &tex
 void
 initialize_command_input (void)
 {
   // If we are using readline, this allows conditional parsing of the
   // .inputrc file.
 
   command_editor::set_name ("Octave");
 
-  // FIXME -- this needs to include a comma too, but that
+  // FIXME: this needs to include a comma too, but that
   // causes trouble for the new struct element completion code.
 
   static const char *s = "\t\n !\"\'*+-/:;<=>(){}[\\]^`~";
 
   command_editor::set_basic_word_break_characters (s);
 
   command_editor::set_completer_word_break_characters (s);
 
@@ -531,17 +531,17 @@ get_debug_input (const std::string& prom
       if (Vgud_mode)
         {
           static char ctrl_z = 'Z' & 0x1f;
 
           buf << ctrl_z << ctrl_z << nm << ":" << curr_debug_line;
         }
       else
         {
-          // FIXME -- we should come up with a clean way to detect
+          // FIXME: we should come up with a clean way to detect
           // that we are stopped on the no-op command that marks the
           // end of a function or script.
 
           buf << "stopped in " << nm;
 
           if (curr_debug_line > 0)
             buf << " at line " << curr_debug_line;
 
@@ -697,17 +697,17 @@ get_user_input (const octave_value_list&
       if (input_buf[len - 1] != '\n')
         octave_diary << "\n";
 
       if (len < 1)
         return read_as_string ? octave_value ("") : octave_value (Matrix ());
 
       if (read_as_string)
         {
-          // FIXME -- fix gnu_readline and octave_gets instead!
+          // FIXME: fix gnu_readline and octave_gets instead!
           if (input_buf.length () == 1 && input_buf[0] == '\n')
             retval(0) = "";
           else
             retval(0) = input_buf;
         }
       else
         {
           int parse_status = 0;
@@ -720,17 +720,17 @@ get_user_input (const octave_value_list&
     }
   else
     error ("input: reading user-input failed!");
 
   return retval;
 }
 
 DEFUN (input, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{ans} =} input (@var{prompt})\n\
 @deftypefnx {Built-in Function} {@var{ans} =} input (@var{prompt}, \"s\")\n\
 Print a prompt and wait for user input.  For example,\n\
 \n\
 @example\n\
 input (\"Pick a number, any number! \")\n\
 @end example\n\
 \n\
@@ -789,17 +789,17 @@ octave_yes_or_no (const std::string& pro
       else if (input_buf == "no")
         return false;
       else
         message (0, "Please answer yes or no.");
     }
 }
 
 DEFUN (yes_or_no, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{ans} =} yes_or_no (\"@var{prompt}\")\n\
 Ask the user a yes-or-no question.  Return logical true if the answer is yes\n\
 or false if the answer is no.  Takes one argument, @var{prompt}, which is\n\
 the string to display when asking the question.  @var{prompt} should end in\n\
 a space; @code{yes-or-no} adds the string @samp{(yes or no) } to it.  The\n\
 user must confirm the answer with @key{RET} and can edit it until it has\n\
 been confirmed.\n\
 @seealso{input}\n\
@@ -848,17 +848,17 @@ do_keyboard (const octave_value_list& ar
 
   command_history::ignore_entries (false);
 
   frame.protect_var (Vdebugging);
 
   frame.add_fcn (octave_call_stack::restore_frame,
                  octave_call_stack::current_frame ());
 
-  // FIXME -- probably we just want to print one line, not the
+  // FIXME: probably we just want to print one line, not the
   // entire statement, which might span many lines...
   //
   // tree_print_code tpc (octave_stdout);
   // stmt.accept (tpc);
 
   Vdebugging = true;
 
   std::string prompt = "debug> ";
@@ -867,17 +867,17 @@ do_keyboard (const octave_value_list& ar
 
   if (! error_state)
     get_debug_input (prompt);
 
   return retval;
 }
 
 DEFUN (keyboard, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} keyboard ()\n\
 @deftypefnx {Built-in Function} {} keyboard (\"@var{prompt}\")\n\
 This function is normally used for simple debugging.  When the\n\
 @code{keyboard} function is executed, Octave prints a prompt and waits\n\
 for user input.  The input strings are then evaluated and the results\n\
 are printed.  This makes it possible to examine the values of variables\n\
 within a function, and to assign new values if necessary.  To leave the\n\
 prompt and return to normal execution type @samp{return} or @samp{dbcont}.\n\
@@ -910,17 +910,17 @@ If @code{keyboard} is invoked without ar
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (echo, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Command} {} echo options\n\
 Control whether commands are displayed as they are executed.  Valid\n\
 options are:\n\
 \n\
 @table @code\n\
 @item on\n\
 Enable echoing of commands as they are executed in script files.\n\
 \n\
@@ -994,17 +994,17 @@ With no arguments, @code{echo} toggles t
       print_usage ();
       break;
     }
 
   return retval;
 }
 
 DEFUN (completion_matches, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} completion_matches (@var{hint})\n\
 Generate possible completions given @var{hint}.\n\
 \n\
 This function is provided for the benefit of programs like Emacs which\n\
 might be controlling Octave and handling user input.  The current\n\
 command number is not incremented when this function is called.  This is\n\
 a feature, not a bug.\n\
 @end deftypefn")
@@ -1070,17 +1070,17 @@ a feature, not a bug.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (readline_read_init_file, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} readline_read_init_file (@var{file})\n\
 Read the readline library initialization file @var{file}.  If\n\
 @var{file} is omitted, read the default initialization file (normally\n\
 @file{~/.inputrc}).\n\
 \n\
 @xref{Readline Init File, , , readline, GNU Readline Library},\n\
 for details.\n\
 @seealso{readline_re_read_init_file}\n\
@@ -1101,17 +1101,17 @@ for details.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (readline_re_read_init_file, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} readline_re_read_init_file ()\n\
 Re-read the last readline library initialization file that was read.\n\
 @xref{Readline Init File, , , readline, GNU Readline Library},\n\
 for details.\n\
 @seealso{readline_read_init_file}\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -1131,17 +1131,17 @@ internal_input_event_hook_fcn (void)
 
   if (input_event_hook_functions.empty ())
     command_editor::remove_event_hook (internal_input_event_hook_fcn);
 
   return 0;
 }
 
 DEFUN (add_input_event_hook, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{id} =} add_input_event_hook (@var{fcn})\n\
 @deftypefnx {Built-in Function} {@var{id} =} add_input_event_hook (@var{fcn}, @var{data})\n\
 Add the named function or function handle @var{fcn} to the list of functions\n\
 to call periodically when Octave is waiting for input.  The function should\n\
 have the form\n\
 \n\
 @example\n\
 @var{fcn} (@var{data})\n\
@@ -1182,17 +1182,17 @@ the list of input hook functions.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (remove_input_event_hook, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} remove_input_event_hook (@var{name})\n\
 @deftypefnx {Built-in Function} {} remove_input_event_hook (@var{fcn_id})\n\
 Remove the named function or function handle with the given identifier\n\
 from the list of functions to call periodically when Octave is waiting\n\
 for input.\n\
 @seealso{add_input_event_hook}\n\
 @end deftypefn")
 {
@@ -1225,17 +1225,17 @@ for input.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (PS1, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} PS1 ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} PS1 (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} PS1 (@var{new_val}, \"local\")\n\
 Query or set the primary prompt string.  When executing interactively,\n\
 Octave displays the primary prompt when it is ready to read a command.\n\
 \n\
 The default value of the primary prompt string is @qcode{\"\\s:\\#> \"}.\n\
 To change it, use a command like\n\
@@ -1265,17 +1265,17 @@ variable is changed locally for the func
 The original variable value is restored when exiting the function.\n\
 @seealso{PS2, PS4}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (PS1);
 }
 
 DEFUN (PS2, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} PS2 ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} PS2 (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} PS2 (@var{new_val}, \"local\")\n\
 Query or set the secondary prompt string.  The secondary prompt is\n\
 printed when Octave is expecting additional input to complete a\n\
 command.  For example, if you are typing a @code{for} loop that spans several\n\
 lines, Octave will print the secondary prompt at the beginning of\n\
 each line after the first.  The default value of the secondary prompt\n\
@@ -1286,17 +1286,17 @@ variable is changed locally for the func
 The original variable value is restored when exiting the function.\n\
 @seealso{PS1, PS4}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (PS2);
 }
 
 DEFUN (PS4, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} PS4 ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} PS4 (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} PS4 (@var{new_val}, \"local\")\n\
 Query or set the character string used to prefix output produced\n\
 when echoing commands is enabled.\n\
 The default value is @qcode{\"+ \"}.\n\
 @xref{Diary and Echo Commands}, for a description of echoing commands.\n\
 \n\
@@ -1305,34 +1305,34 @@ variable is changed locally for the func
 The original variable value is restored when exiting the function.\n\
 @seealso{echo, echo_executing_commands, PS1, PS2}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (PS4);
 }
 
 DEFUN (completion_append_char, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} completion_append_char ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} completion_append_char (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} completion_append_char (@var{new_val}, \"local\")\n\
 Query or set the internal character variable that is appended to\n\
 successful command-line completion attempts.  The default\n\
 value is @qcode{\" \"} (a single space).\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.  \n\
 The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (completion_append_char);
 }
 
 DEFUN (echo_executing_commands, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} echo_executing_commands ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} echo_executing_commands (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} echo_executing_commands (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls the echo state.\n\
 It may be the sum of the following values:\n\
 \n\
 @table @asis\n\
 @item 1\n\
@@ -1355,17 +1355,17 @@ When called from inside a function with 
 variable is changed locally for the function and any subroutines it calls.  \n\
 The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (echo_executing_commands);
 }
 
 DEFUN (__request_drawnow__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} __request_drawnow__ ()\n\
 @deftypefnx {Built-in Function} {} __request_drawnow__ (@var{flag})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
@@ -1376,17 +1376,17 @@ Undocumented internal function.\n\
     Vdrawnow_requested = args(0).bool_value ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (__gud_mode__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __gud_mode__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -1396,17 +1396,17 @@ Undocumented internal function.\n\
     Vgud_mode = args(0).bool_value ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (filemarker, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} filemarker ()\n\
 @deftypefnx {Built-in Function} {} filemarker (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} filemarker (@var{new_val}, \"local\")\n\
 Query or set the character used to separate filename from the\n\
 the subfunction names contained within the file.  This can be used in\n\
 a generic manner to interact with subfunctions.  For example,\n\
 \n\
 @example\n\
diff --git a/libinterp/corefcn/input.h b/libinterp/corefcn/input.h
--- a/libinterp/corefcn/input.h
+++ b/libinterp/corefcn/input.h
@@ -53,17 +53,18 @@ extern OCTINTERP_API bool Vdrawnow_reque
 
 // TRUE if we are in debugging mode.
 extern OCTINTERP_API bool Vdebugging;
 
 extern void initialize_command_input (void);
 
 extern bool octave_yes_or_no (const std::string& prompt);
 
-extern octave_value do_keyboard (const octave_value_list& args = octave_value_list ());
+extern octave_value do_keyboard (const octave_value_list& args
+                                 = octave_value_list ());
 
 extern void remove_input_event_hook_functions (void);
 
 extern void set_default_prompts (void);
 
 extern std::string VPS4;
 
 extern char Vfilemarker;
diff --git a/libinterp/corefcn/inv.cc b/libinterp/corefcn/inv.cc
--- a/libinterp/corefcn/inv.cc
+++ b/libinterp/corefcn/inv.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "ov-re-diag.h"
 #include "ov-cx-diag.h"
 #include "ov-flt-re-diag.h"
 #include "ov-flt-cx-diag.h"
 #include "ov-perm.h"
 #include "utils.h"
 
 DEFUN (inv, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{x} =} inv (@var{A})\n\
 @deftypefnx {Built-in Function} {[@var{x}, @var{rcond}] =} inv (@var{A})\n\
 Compute the inverse of the square matrix @var{A}.  Return an estimate\n\
 of the reciprocal condition number if requested, otherwise warn of an\n\
 ill-conditioned matrix if the reciprocal condition number is small.\n\
 \n\
 In general it is best to avoid calculating the inverse of a matrix\n\
 directly.  For example, it is both faster and more accurate to solve\n\
@@ -227,22 +227,22 @@ of a sparse matrix if possible.\n\
 %!assert (inv ([1, 2; 3, 4]), [-2, 1; 1.5, -0.5], sqrt (eps))
 %!assert (inv (single ([1, 2; 3, 4])), single ([-2, 1; 1.5, -0.5]), sqrt (eps ("single")))
 
 %!error inv ()
 %!error inv ([1, 2; 3, 4], 2)
 %!error <argument must be a square matrix> inv ([1, 2; 3, 4; 5, 6])
 */
 
-// FIXME -- this should really be done with an alias, but
+// FIXME: this should really be done with an alias, but
 // alias_builtin() won't do the right thing if we are actually using
 // dynamic linking.
 
 DEFUN (inverse, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{x} =} inverse (@var{A})\n\
 @deftypefnx {Built-in Function} {[@var{x}, @var{rcond}] =} inverse (@var{A})\n\
 Compute the inverse of the square matrix @var{A}.\n\
 \n\
 This is an alias for @code{inv}.\n\
 @seealso{inv}\n\
 @end deftypefn")
 {
diff --git a/libinterp/corefcn/jit-ir.h b/libinterp/corefcn/jit-ir.h
--- a/libinterp/corefcn/jit-ir.h
+++ b/libinterp/corefcn/jit-ir.h
@@ -284,17 +284,17 @@ std::ostream& jit_print (std::ostream& o
 class
 jit_use : public jit_internal_node<jit_value, jit_use>
 {
 public:
   // some compilers don't allow us to use jit_internal_node without template
   // paremeters
   typedef jit_internal_node<jit_value, jit_use> PARENT_T;
 
-  jit_use (void) : muser (0), mindex (0) {}
+  jit_use (void) : muser (0), mindex (0) { }
 
   // we should really have a move operator, but not until c++11 :(
   jit_use (const jit_use& use) : muser (0), mindex (0)
   {
     *this = use;
   }
 
   jit_use& operator= (const jit_use& use)
@@ -324,17 +324,17 @@ private:
 };
 
 class
 jit_instruction : public jit_value
 {
 public:
   // FIXME: this code could be so much pretier with varadic templates...
   jit_instruction (void) : mid (next_id ()), mparent (0)
-  {}
+  { }
 
   jit_instruction (size_t nargs) : mid (next_id ()), mparent (0)
   {
     already_infered.reserve (nargs);
     marguments.reserve (nargs);
   }
 
 #define STASH_ARG(i) stash_argument (i, arg ## i);
@@ -349,18 +349,18 @@ public:
   JIT_INSTRUCTION_CTOR(2)
   JIT_INSTRUCTION_CTOR(3)
   JIT_INSTRUCTION_CTOR(4)
 
 #undef STASH_ARG
 #undef JIT_INSTRUCTION_CTOR
 
   jit_instruction (const std::vector<jit_value *>& aarguments)
-  : already_infered (aarguments.size ()), marguments (aarguments.size ()),
-    mid (next_id ()), mparent (0)
+    : already_infered (aarguments.size ()), marguments (aarguments.size ()),
+      mid (next_id ()), mparent (0)
   {
     for (size_t i = 0; i < aarguments.size (); ++i)
       stash_argument (i, aarguments[i]);
   }
 
   static void reset_ids (void)
   {
     next_id (true);
@@ -425,19 +425,19 @@ public:
   }
 
   const std::vector<jit_use>& arguments (void) const { return marguments; }
 
   // argument types which have been infered already
   const std::vector<jit_type *>& argument_types (void) const
   { return already_infered; }
 
-  virtual void push_variable (void) {}
+  virtual void push_variable (void) { }
 
-  virtual void pop_variable (void) {}
+  virtual void pop_variable (void) { }
 
   virtual void construct_ssa (void)
   {
     do_construct_ssa (0, argument_count ());
   }
 
   virtual bool infer (void) { return false; }
 
@@ -504,18 +504,17 @@ public:
   {
     print_indent (os, indent);
     return jit_print (os, type ()) << ": DUMMY";
   }
 
   JIT_VALUE_ACCEPT;
 };
 
-template <typename T, jit_type *(*EXTRACT_T)(void), typename PASS_T,
-          bool QUOTE>
+template <typename T, jit_type *(*EXTRACT_T)(void), typename PASS_T, bool QUOTE>
 class
 jit_const : public jit_value
 {
 public:
   typedef PASS_T pass_t;
 
   jit_const (PASS_T avalue) : mvalue (avalue)
   {
@@ -556,17 +555,17 @@ public:
   typedef std::set<jit_block *> df_set;
   typedef df_set::const_iterator df_iterator;
 
   static const size_t NO_ID = static_cast<size_t> (-1);
 
   jit_block (const std::string& aname, size_t avisit_count = 0)
     : mvisit_count (avisit_count), mid (NO_ID), idom (0), mname (aname),
       malive (false)
-  {}
+  { }
 
   virtual void replace_with (jit_value *value);
 
   void replace_in_phi (jit_block *ablock, jit_block *with);
 
   // we have a new internal list, but we want to stay compatable with jit_value
   jit_use *first_use (void) const { return jit_value::first_use (); }
 
@@ -771,19 +770,19 @@ private:
   std::list<jit_block *>::iterator mlocation;
 };
 
 // keeps track of phi functions that use a block on incomming edges
 class
 jit_phi_incomming : public jit_internal_node<jit_block, jit_phi_incomming>
 {
 public:
-  jit_phi_incomming (void) : muser (0) {}
+  jit_phi_incomming (void) : muser (0) { }
 
-  jit_phi_incomming (jit_phi *auser) : muser (auser) {}
+  jit_phi_incomming (jit_phi *auser) : muser (auser) { }
 
   jit_phi_incomming (const jit_phi_incomming& use)
   {
     *this = use;
   }
 
   jit_phi_incomming& operator= (const jit_phi_incomming& use)
   {
@@ -799,22 +798,22 @@ private:
   jit_phi *muser;
 };
 
 // A non-ssa variable
 class
 jit_variable : public jit_value
 {
 public:
-  jit_variable (const std::string& aname) : mname (aname), mlast_use (0) {}
+  jit_variable (const std::string& aname) : mname (aname), mlast_use (0) { }
 
   const std::string &name (void) const { return mname; }
 
-  // manipulate the value_stack, for use during SSA construction. The top of the
-  // value stack represents the current value for this variable
+  // manipulate the value_stack, for use during SSA construction. The top of
+  // the  value stack represents the current value for this variable
   bool has_top (void) const
   {
     return ! value_stack.empty ();
   }
 
   jit_value *top (void) const
   {
     return value_stack.top ();
@@ -863,23 +862,23 @@ private:
   std::stack<jit_value *> value_stack;
   jit_instruction *mlast_use;
 };
 
 class
 jit_assign_base : public jit_instruction
 {
 public:
-  jit_assign_base (jit_variable *adest) : jit_instruction (), mdest (adest) {}
+  jit_assign_base (jit_variable *adest) : jit_instruction (), mdest (adest) { }
 
   jit_assign_base (jit_variable *adest, size_t npred) : jit_instruction (npred),
                                                         mdest (adest) {}
 
   jit_assign_base (jit_variable *adest, jit_value *arg0, jit_value *arg1)
-    : jit_instruction (arg0, arg1), mdest (adest) {}
+    : jit_instruction (arg0, arg1), mdest (adest) { }
 
   jit_variable *dest (void) const { return mdest; }
 
   virtual void push_variable (void)
   {
     mdest->push (this);
   }
 
@@ -900,17 +899,17 @@ private:
   jit_variable *mdest;
 };
 
 class
 jit_assign : public jit_assign_base
 {
 public:
   jit_assign (jit_variable *adest, jit_value *asrc)
-    : jit_assign_base (adest, adest, asrc), martificial (false) {}
+    : jit_assign_base (adest, adest, asrc), martificial (false) { }
 
   jit_value *overwrite (void) const
   {
     return argument (0);
   }
 
   jit_value *src (void) const
   {
@@ -976,17 +975,17 @@ public:
     return mincomming[i].value ();
   }
 
   llvm::BasicBlock *incomming_llvm (size_t i) const
   {
     return incomming (i)->to_llvm ();
   }
 
-  virtual void construct_ssa (void) {}
+  virtual void construct_ssa (void) { }
 
   virtual bool infer (void);
 
   virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
   {
     std::stringstream ss;
     print_indent (ss, indent);
     short_print (ss) << " phi ";
@@ -1020,17 +1019,17 @@ private:
 class
 jit_terminator : public jit_instruction
 {
 public:
 #define JIT_TERMINATOR_CONST(N)                                         \
   jit_terminator (size_t asuccessor_count,                              \
                   OCT_MAKE_DECL_LIST (jit_value *, arg, N))             \
     : jit_instruction (OCT_MAKE_ARG_LIST (arg, N)),                     \
-      malive (asuccessor_count, false) {}
+      malive (asuccessor_count, false) { }
 
   JIT_TERMINATOR_CONST (1)
   JIT_TERMINATOR_CONST (2)
   JIT_TERMINATOR_CONST (3)
 
 #undef JIT_TERMINATOR_CONST
 
   jit_block *successor (size_t idx = 0) const
@@ -1075,17 +1074,17 @@ protected:
 private:
   std::vector<bool> malive;
 };
 
 class
 jit_branch : public jit_terminator
 {
 public:
-  jit_branch (jit_block *succ) : jit_terminator (1, succ) {}
+  jit_branch (jit_block *succ) : jit_terminator (1, succ) { }
 
   virtual size_t successor_count (void) const { return 1; }
 
   virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
   {
     print_indent (os, indent) << "branch: ";
     return print_successor (os);
   }
@@ -1093,17 +1092,17 @@ public:
   JIT_VALUE_ACCEPT;
 };
 
 class
 jit_cond_branch : public jit_terminator
 {
 public:
   jit_cond_branch (jit_value *c, jit_block *ctrue, jit_block *cfalse)
-    : jit_terminator (2, ctrue, cfalse, c) {}
+    : jit_terminator (2, ctrue, cfalse, c) { }
 
   jit_value *cond (void) const { return argument (2); }
 
   std::ostream& print_cond (std::ostream& os) const
   {
     return cond ()->short_print (os);
   }
 
@@ -1142,34 +1141,34 @@ public:
     const jit_function& ol = overload ();
     if (ol.valid ())
       stash_type (ol.result ());
   }
 
 #define JIT_CALL_CONST(N)                                               \
   jit_call (const jit_operation& aoperation,                            \
             OCT_MAKE_DECL_LIST (jit_value *, arg, N))                   \
-    : jit_instruction (OCT_MAKE_ARG_LIST (arg, N)), moperation (aoperation) {} \
+    : jit_instruction (OCT_MAKE_ARG_LIST (arg, N)), moperation (aoperation) { } \
                                                                         \
   jit_call (const jit_operation& (*aoperation) (void),                  \
             OCT_MAKE_DECL_LIST (jit_value *, arg, N))                   \
     : jit_instruction (OCT_MAKE_ARG_LIST (arg, N)), moperation (aoperation ()) \
-  {}
+  { }
 
   JIT_CALL_CONST (1)
   JIT_CALL_CONST (2)
   JIT_CALL_CONST (3)
   JIT_CALL_CONST (4)
 
 #undef JIT_CALL_CONST
 
   jit_call (const jit_operation& aoperation,
             const std::vector<jit_value *>& args)
-  : jit_instruction (args), moperation (aoperation)
-  {}
+    : jit_instruction (args), moperation (aoperation)
+  { }
 
   const jit_operation& operation (void) const { return moperation; }
 
   bool can_error (void) const
   {
     return overload ().can_error ();
   }
 
@@ -1208,29 +1207,29 @@ private:
 // checks error_state, if error_state is false then goto the normal branch,
 // otherwise goto the error branch
 class
 jit_error_check : public jit_terminator
 {
 public:
   // Which variable is the error check for?
   enum variable
-    {
-      var_error_state,
-      var_interrupt
-    };
+  {
+    var_error_state,
+    var_interrupt
+  };
 
   static std::string variable_to_string (variable v);
 
   jit_error_check (variable var, jit_call *acheck_for, jit_block *normal,
                    jit_block *error)
-    : jit_terminator (2, error, normal, acheck_for), mvariable (var) {}
+    : jit_terminator (2, error, normal, acheck_for), mvariable (var) { }
 
   jit_error_check (variable var, jit_block *normal, jit_block *error)
-    : jit_terminator (2, error, normal), mvariable (var) {}
+    : jit_terminator (2, error, normal), mvariable (var) { }
 
   variable check_variable (void) const { return mvariable; }
 
   bool has_check_for (void) const
   {
     return argument_count () == 3;
   }
 
@@ -1259,17 +1258,17 @@ class
 jit_magic_end : public jit_instruction
 {
 public:
   class
   context
   {
   public:
     context (void) : value (0), index (0), count (0)
-    {}
+    { }
 
     context (jit_factory& factory, jit_value *avalue, size_t aindex,
              size_t acount);
 
     jit_value *value;
     jit_const_index *index;
     jit_const_index *count;
   };
@@ -1324,18 +1323,18 @@ public:
   JIT_VALUE_ACCEPT;
 };
 
 class
 jit_store_argument : public jit_instruction
 {
 public:
   jit_store_argument (jit_variable *var)
-  : jit_instruction (var), dest (var)
-  {}
+    : jit_instruction (var), dest (var)
+  { }
 
   const std::string& name (void) const
   {
     return dest->name ();
   }
 
   const jit_function& overload (void) const
   {
@@ -1376,19 +1375,19 @@ public:
 private:
   jit_variable *dest;
 };
 
 class
 jit_return : public jit_instruction
 {
 public:
-  jit_return (void) {}
+  jit_return (void) { }
 
-  jit_return (jit_value *retval) : jit_instruction (retval) {}
+  jit_return (jit_value *retval) : jit_instruction (retval) { }
 
   jit_value *result (void) const
   {
     return argument_count () ? argument (0) : 0;
   }
 
   jit_type *result_type (void) const
   {
@@ -1408,17 +1407,17 @@ public:
 
   JIT_VALUE_ACCEPT;
 };
 
 class
 jit_ir_walker
 {
 public:
-  virtual ~jit_ir_walker () {}
+  virtual ~jit_ir_walker () { }
 
 #define JIT_METH(clname) \
   virtual void visit (jit_ ## clname&) = 0;
 
   JIT_VISIT_IR_CLASSES;
 
 #undef JIT_METH
 };
diff --git a/libinterp/corefcn/jit-typeinfo.cc b/libinterp/corefcn/jit-typeinfo.cc
--- a/libinterp/corefcn/jit-typeinfo.cc
+++ b/libinterp/corefcn/jit-typeinfo.cc
@@ -512,27 +512,27 @@ jit_range::all_elements_are_ints () cons
   Range r (*this);
   return r.all_elements_are_ints ();
 }
 
 std::ostream&
 operator<< (std::ostream& os, const jit_range& rng)
 {
   return os << "Range[" << rng.base << ", " << rng.limit << ", " << rng.inc
-            << ", " << rng.nelem << "]";
+         << ", " << rng.nelem << "]";
 }
 
 // -------------------- jit_matrix --------------------
 
 std::ostream&
 operator<< (std::ostream& os, const jit_matrix& mat)
 {
   return os << "Matrix[" << mat.ref_count << ", " << mat.slice_data << ", "
-            << mat.slice_len << ", " << mat.dimensions << ", "
-            << mat.array << "]";
+         << mat.slice_len << ", " << mat.dimensions << ", "
+         << mat.array << "]";
 }
 
 // -------------------- jit_type --------------------
 jit_type::jit_type (const std::string& aname, jit_type *aparent,
                     llvm::Type *allvm_type, bool askip_paren, int aid) :
   mname (aname), mparent (aparent), llvm_type (allvm_type), mid (aid),
   mdepth (aparent ? aparent->mdepth + 1 : 0), mskip_paren (askip_paren)
 {
@@ -713,17 +713,17 @@ jit_function::call (llvm::IRBuilderD& bu
   llvm::CallInst *callinst = builder.CreateCall (llvm_function, llvm_args);
   llvm::Value *ret = callinst;
 
   if (sret ())
     {
 #ifdef CALLINST_ADDATTRIBUTE_ARG_IS_ATTRIBUTES
       llvm::AttrBuilder attr_builder;
       attr_builder.addAttribute(llvm::Attributes::StructRet);
-      llvm::Attributes attrs = llvm::Attributes::get(context, attr_builder); 
+      llvm::Attributes attrs = llvm::Attributes::get(context, attr_builder);
       callinst->addAttribute (1, attrs);
 #else
       callinst->addAttribute (1, llvm::Attribute::StructRet);
 #endif
       ret = builder.CreateLoad (sret_mem);
     }
 
   if (mresult)
@@ -809,17 +809,17 @@ jit_operation::~jit_operation (void)
     {
       delete iter->first;
       delete iter->second;
     }
 }
 
 void
 jit_operation::add_overload (const jit_function& func,
-                            const std::vector<jit_type*>& args)
+                             const std::vector<jit_type*>& args)
 {
   if (args.size () >= overloads.size ())
     overloads.resize (args.size () + 1);
 
   Array<jit_function>& over = overloads[args.size ()];
   dim_vector dv (over.dims ());
   Array<octave_idx_type> idx = to_idx (args);
   bool must_resize = false;
@@ -1632,18 +1632,18 @@ jit_typeinfo::jit_typeinfo (llvm::Module
     llvm::BasicBlock *normal = fn.new_block ("normal", done);
     builder.CreateCondBr (cond, conv_error, normal);
 
     builder.SetInsertPoint (conv_error);
     ginvalid_index.call (builder);
     builder.CreateBr (done);
 
     builder.SetInsertPoint (normal);
-    llvm::Value *len = builder.CreateExtractValue (mat,
-                                                   llvm::ArrayRef<unsigned> (2));
+    llvm::Value *len
+      = builder.CreateExtractValue (mat, llvm::ArrayRef<unsigned> (2));
     cond = builder.CreateICmpSGT (int_idx, len);
 
 
     llvm::BasicBlock *bounds_error = fn.new_block ("bounds_error", done);
     llvm::BasicBlock *success = fn.new_block ("success", done);
     builder.CreateCondBr (cond, bounds_error, success);
 
     builder.SetInsertPoint (bounds_error);
@@ -1717,18 +1717,18 @@ jit_typeinfo::jit_typeinfo (llvm::Module
 
     // resize on out of bounds access
     builder.SetInsertPoint (bounds_error);
     llvm::Value *resize_result = resize_paren_subsasgn.call (builder, mat,
                                                              int_idx, value);
     builder.CreateBr (done);
 
     builder.SetInsertPoint (success);
-    llvm::Value *data = builder.CreateExtractValue (mat,
-                                                    llvm::ArrayRef<unsigned> (1));
+    llvm::Value *data
+      = builder.CreateExtractValue (mat, llvm::ArrayRef<unsigned> (1));
     llvm::Value *gep = builder.CreateInBoundsGEP (data, int_idx);
     builder.CreateStore (value, gep);
     builder.CreateBr (done);
 
     builder.SetInsertPoint (done);
 
     llvm::PHINode *merge = llvm::PHINode::Create (matrix_t, 3);
     builder.Insert (merge);
@@ -1918,17 +1918,18 @@ jit_typeinfo::new_type (const std::strin
   return ret;
 }
 
 void
 jit_typeinfo::add_print (jit_type *ty, void *fptr)
 {
   std::stringstream name;
   name << "octave_jit_print_" << ty->name ();
-  jit_function fn = create_external (engine, fptr, name.str (), 0, intN (8), ty);
+  jit_function fn = create_external (engine, fptr, name.str (),
+                                     0, intN (8), ty);
   print_fn.add_overload (fn);
 }
 
 // FIXME: cp between add_binary_op, add_binary_icmp, and add_binary_fcmp
 void
 jit_typeinfo::add_binary_op (jit_type *ty, int op, int llvm_op)
 {
   std::stringstream fname;
@@ -2240,17 +2241,17 @@ jit_typeinfo::do_type_of (const octave_v
 {
   if (ov.is_function ())
     {
       // FIXME: This is ugly, we need to finalize how we want to to this, then
       // have octave_value fully support the needed functionality
       octave_builtin *builtin
         = dynamic_cast<octave_builtin *> (ov.internal_rep ());
       return builtin && builtin->to_jit () ? builtin->to_jit ()
-        : unknown_function;
+                                           : unknown_function;
     }
 
   if (ov.is_range ())
     return get_range ();
 
   if (ov.is_double_type () && ! ov.is_complex_type ())
     {
       if (ov.is_real_scalar ())
diff --git a/libinterp/corefcn/jit-typeinfo.h b/libinterp/corefcn/jit-typeinfo.h
--- a/libinterp/corefcn/jit-typeinfo.h
+++ b/libinterp/corefcn/jit-typeinfo.h
@@ -32,48 +32,48 @@ along with Octave; see the file COPYING.
 
 #include "Range.h"
 #include "jit-util.h"
 
 // Defines the type system used by jit and a singleton class, jit_typeinfo, to
 // manage the types.
 //
 // FIXME:
-// Operations are defined and implemented in jit_typeinfo. Eventually they
+// Operations are defined and implemented in jit_typeinfo.  Eventually they
 // should be moved elsewhere. (just like with octave_typeinfo)
 
 // jit_range is compatable with the llvm range structure
 struct
 jit_range
 {
   jit_range (const Range& from) : base (from.base ()), limit (from.limit ()),
                                   inc (from.inc ()), nelem (from.nelem ())
-  {}
+  { }
 
   operator Range () const
   {
     return Range (base, limit, inc);
   }
 
   bool all_elements_are_ints () const;
 
   double base;
   double limit;
   double inc;
   octave_idx_type nelem;
 };
 
-std::ostream& operator<< (std::ostream& os, const jit_range& rng);
+std::ostream& operator << (std::ostream& os, const jit_range& rng);
 
 // jit_array is compatable with the llvm array/matrix structures
 template <typename T, typename U>
 struct
 jit_array
 {
-  jit_array () : array (0) {}
+  jit_array () : array (0) { }
 
   jit_array (T& from) : array (new T (from))
   {
     update ();
   }
 
   void update (void)
   {
@@ -100,17 +100,17 @@ jit_array
   octave_idx_type slice_len;
   octave_idx_type *dimensions;
 
   T *array;
 };
 
 typedef jit_array<NDArray, double> jit_matrix;
 
-std::ostream& operator<< (std::ostream& os, const jit_matrix& mat);
+std::ostream& operator << (std::ostream& os, const jit_matrix& mat);
 
 // calling convention
 namespace
 jit_convention
 {
   enum
   type
   {
@@ -212,22 +212,22 @@ private:
   llvm::Type *mpacked_type[jit_convention::length];
 };
 
 // seperate print function to allow easy printing if type is null
 std::ostream& jit_print (std::ostream& os, jit_type *atype);
 
 class jit_value;
 
-// An abstraction for calling llvm functions with jit_values. Deals with calling
-// convention details.
+// An abstraction for calling llvm functions with jit_values.  Deals with
+// calling convention details.
 class
 jit_function
 {
-  friend std::ostream& operator<< (std::ostream& os, const jit_function& fn);
+  friend std::ostream& operator << (std::ostream& os, const jit_function& fn);
 public:
   // create a function in an invalid state
   jit_function ();
 
   jit_function (llvm::Module *amodule, jit_convention::type acall_conv,
                 const llvm::Twine& aname, jit_type *aresult,
                 const std::vector<jit_type *>& aargs);
 
@@ -312,17 +312,17 @@ private:
   llvm::Module *module;
   llvm::Function *llvm_function;
   jit_type *mresult;
   std::vector<jit_type *> args;
   jit_convention::type call_conv;
   bool mcan_error;
 };
 
-std::ostream& operator<< (std::ostream& os, const jit_function& fn);
+std::ostream& operator << (std::ostream& os, const jit_function& fn);
 
 
 // Keeps track of information about how to implement operations (+, -, *, ect)
 // and their resulting types.
 class
 jit_operation
 {
 public:
@@ -384,17 +384,17 @@ private:
 
   std::string mname;
 };
 
 class
 jit_index_operation : public jit_operation
 {
 public:
-  jit_index_operation (void) : module (0), engine (0) {}
+  jit_index_operation (void) : module (0), engine (0) { }
 
   void initialize (llvm::Module *amodule, llvm::ExecutionEngine *aengine)
   {
     module = amodule;
     engine = aengine;
     do_initialize ();
   }
 protected:
diff --git a/libinterp/corefcn/jit-util.h b/libinterp/corefcn/jit-util.h
--- a/libinterp/corefcn/jit-util.h
+++ b/libinterp/corefcn/jit-util.h
@@ -72,20 +72,20 @@ class octave_builtin;
 class octave_value;
 class tree;
 class tree_expression;
 
 // thrown when we should give up on JIT and interpret
 class jit_fail_exception : public std::runtime_error
 {
 public:
-  jit_fail_exception (void) : std::runtime_error ("unknown"), mknown (false) {}
+  jit_fail_exception (void) : std::runtime_error ("unknown"), mknown (false) { }
   jit_fail_exception (const std::string& reason) : std::runtime_error (reason),
                                                    mknown (true)
-  {}
+  { }
 
   bool known (void) const { return mknown; }
 private:
   bool mknown;
 };
 
 // llvm doesn't provide this, and it's really useful for debugging
 std::ostream& operator<< (std::ostream& os, const llvm::Value& v);
@@ -97,17 +97,17 @@ class jit_internal_node;
 // linked lists. List items extend from jit_internal_list, and can be placed
 // in nodes of type jit_internal_node. We use CRTP twice.
 template <typename LIST_T, typename NODE_T>
 class
 jit_internal_list
 {
   friend class jit_internal_node<LIST_T, NODE_T>;
 public:
-  jit_internal_list (void) : use_head (0), use_tail (0), muse_count (0) {}
+  jit_internal_list (void) : use_head (0), use_tail (0), muse_count (0) { }
 
   virtual ~jit_internal_list (void)
   {
     while (use_head)
       use_head->stash_value (0);
   }
 
   NODE_T *first_use (void) const { return use_head; }
@@ -122,17 +122,17 @@ private:
 // a node for internal linked lists
 template <typename LIST_T, typename NODE_T>
 class
 jit_internal_node
 {
 public:
   typedef jit_internal_list<LIST_T, NODE_T> jit_ilist;
 
-  jit_internal_node (void) : mvalue (0), mnext (0), mprev (0) {}
+  jit_internal_node (void) : mvalue (0), mnext (0), mprev (0) { }
 
   ~jit_internal_node (void) { remove (); }
 
   LIST_T *value (void) const { return mvalue; }
 
   void stash_value (LIST_T *avalue)
   {
     remove ();
diff --git a/libinterp/corefcn/kron.cc b/libinterp/corefcn/kron.cc
--- a/libinterp/corefcn/kron.cc
+++ b/libinterp/corefcn/kron.cc
@@ -83,17 +83,18 @@ kron (const MDiagArray2<R>& a, const MAr
   octave_idx_type nca = a.cols (), ncb = b.cols ();
 
   MArray<T> c (dim_vector (nra*nrb, nca*ncb), T ());
 
   for (octave_idx_type ja = 0; ja < dla; ja++)
     for (octave_idx_type jb = 0; jb < ncb; jb++)
       {
         octave_quit ();
-        mx_inline_mul (nrb, &c.xelem (ja*nrb, ja*ncb + jb), a.dgelem (ja), b.data () + nrb*jb);
+        mx_inline_mul (nrb, &c.xelem (ja*nrb, ja*ncb + jb), a.dgelem (ja),
+                       b.data () + nrb*jb);
       }
 
   return c;
 }
 
 template <class T>
 static MSparse<T>
 kron (const MSparse<T>& A, const MSparse<T>& B)
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -72,17 +72,18 @@ load_path::dir_info::update (void)
                   // we have visited (indexed by its absolute name).
                   // If it is out of date, initialize it.  Otherwise,
                   // copy the info from the cache.  By doing that, we
                   // avoid unnecessary calls to stat that can slow
                   // things down tremendously for large directories.
 
                   const dir_info& di = p->second;
 
-                  if (fs.mtime () + fs.time_resolution () > di.dir_time_last_checked)
+                  if (fs.mtime () + fs.time_resolution ()
+                       > di.dir_time_last_checked)
                     initialize ();
                   else
                     *this = di;
                 }
               else
                 {
                   // We haven't seen this directory before.
 
@@ -124,17 +125,17 @@ load_path::dir_info::initialize (void)
       dir_time_last_checked = octave_time ();
 
       get_file_list (dir_name);
 
       try
         {
           std::string abs_name = octave_env::make_absolute (dir_name);
 
-          // FIXME -- nothing is ever removed from this cache of
+          // FIXME: nothing is ever removed from this cache of
           // directory information, so there could be some resource
           // problems.  Perhaps it should be pruned from time to time.
 
           abs_dir_cache[abs_name] = *this;
         }
       catch (octave_execution_exception)
         {
           // Skip updating if we don't know where we are.
@@ -303,18 +304,17 @@ load_path::instance_ok (void)
       ::error ("unable to create load path object!");
 
       retval = false;
     }
 
   return retval;
 }
 
-// FIXME -- maybe we should also maintain a map to speed up this
-// method of access.
+// FIXME: maybe we should also maintain a map to speed up this method of access.
 
 load_path::const_dir_info_list_iterator
 load_path::find_dir_info (const std::string& dir_arg) const
 {
   std::string dir = file_ops::tilde_expand (dir_arg);
 
   const_dir_info_list_iterator retval = dir_info_list.begin ();
 
@@ -439,18 +439,17 @@ load_path::move_method_map (const std::s
         {
           file_info_list_type& file_info_list = q->second;
 
           if (file_info_list.size () == 1)
             continue;
           else
             {
               for (file_info_list_iterator p = file_info_list.begin ();
-               p != file_info_list.end ();
-               p++)
+                   p != file_info_list.end (); p++)
                 {
                   if (p->dir_name == full_dir_name)
                     {
                       file_info fi = *p;
 
                       file_info_list.erase (p);
 
                       if (at_end)
@@ -717,17 +716,17 @@ load_path::do_add (const std::string& di
         }
       else if (warn)
         {
           std::string msg = fs.error ();
           warning ("addpath: %s: %s", dir_arg.c_str (), msg.c_str ());
         }
     }
 
-  // FIXME -- is there a better way to do this?
+  // FIXME: is there a better way to do this?
 
   i = find_dir_info (".");
 
   if (i != dir_info_list.end ())
     move (i, false);
 }
 
 void
@@ -796,24 +795,23 @@ load_path::remove_method_map (const std:
         {
           file_info_list_type& file_info_list = q->second;
 
           if (file_info_list.size () == 1)
             continue;
           else
             {
               for (file_info_list_iterator p = file_info_list.begin ();
-               p != file_info_list.end ();
-               p++)
+                   p != file_info_list.end (); p++)
                 {
                   if (p->dir_name == full_dir_name)
                     {
                       file_info_list.erase (p);
 
-                      // FIXME -- if there are no other elements, we
+                      // FIXME: if there are no other elements, we
                       // should remove this element of fm but calling
                       // erase here would invalidate the iterator q.
 
                       break;
                     }
                 }
             }
         }
@@ -1374,17 +1372,17 @@ load_path::do_find_first_of (const strin
                   file_name = rel_flist[j];
 
                   goto done;
                 }
             }
         }
     }
 
- done:
+done:
 
   if (! dir_name.empty ())
     retval = file_ops::concat (dir_name, file_name);
 
   return retval;
 }
 
 string_vector
@@ -1431,30 +1429,29 @@ load_path::do_find_all_first_of (const s
         }
       else
         rel_flist[rel_flen++] = file;
     }
 
   rel_flist.resize (rel_flen);
 
   for (const_dir_info_list_iterator p = dir_info_list.begin ();
-       p != dir_info_list.end ();
-       p++)
+       p != dir_info_list.end (); p++)
     {
       string_vector all_files = p->all_files;
 
       octave_idx_type len = all_files.length ();
 
       for (octave_idx_type i = 0; i < len; i++)
         {
           for (octave_idx_type j = 0; j < rel_flen; j++)
             {
               if (all_files[i] == rel_flist[j])
-                retlist.push_back
-                  (file_ops::concat (p->dir_name, rel_flist[j]));
+                retlist.push_back (file_ops::concat (p->dir_name,
+                                                     rel_flist[j]));
             }
         }
     }
 
   return retlist;
 }
 
 string_vector
@@ -1640,19 +1637,18 @@ load_path::do_display (std::ostream& os)
           fcn_files.list_in_columns (os);
         }
 
       const dir_info::method_file_map_type& method_file_map
         = i->method_file_map;
 
       if (! method_file_map.empty ())
         {
-          for (dir_info::const_method_file_map_iterator p = method_file_map.begin ();
-               p != method_file_map.end ();
-               p++)
+          for (dir_info::const_method_file_map_iterator
+               p = method_file_map.begin (); p != method_file_map.end (); p++)
             {
               os << "\n*** methods in " << i->dir_name
                  << "/@" << p->first << ":\n\n";
 
               const dir_info::class_info& ci = p->second;
 
               string_vector method_files = get_file_list (ci.method_file_map);
 
@@ -1725,17 +1721,19 @@ load_path::do_display (std::ostream& os)
 
 #endif
 }
 
 // True if a path is contained in a path list separated by path_sep_char
 static bool
 in_path_list (const std::string& path_list, const std::string& path)
 {
-  size_t ps = path.size (), pls = path_list.size (), pos = path_list.find (path);
+  size_t ps = path.size ();
+  size_t pls = path_list.size ();
+  size_t pos = path_list.find (path);
   char psc = dir_path::path_sep_char ();
   while (pos != std::string::npos)
     {
       if ((pos == 0 || path_list[pos-1] == psc)
           && (pos + ps == pls || path_list[pos + ps] == psc))
         return true;
       else
         pos = path_list.find (path, pos + 1);
@@ -1797,17 +1795,17 @@ load_path::add_to_fcn_map (const dir_inf
           else
             {
               // Warn if a built-in or library function is being shadowed.
 
               if (! file_info_list.empty ())
                 {
                   file_info& old = file_info_list.front ();
 
-                  // FIXME -- do we need to be more careful about the
+                  // FIXME: do we need to be more careful about the
                   // way we look for old.dir_name in sys_path to avoid
                   // partial matches?
 
                   // Don't warn about Contents.m files since we expect
                   // more than one to exist in the load path.
 
                   if (fname != "Contents.m"
                       && sys_path.find (old.dir_name) != std::string::npos
@@ -1899,17 +1897,17 @@ load_path::add_to_method_map (const dir_
 
               if (at_end)
                 file_info_list.push_back (fi);
               else
                 file_info_list.push_front (fi);
             }
           else
             {
-              // FIXME -- is this possible?
+              // FIXME: is this possible?
 
               file_info& fi = *p2;
 
               fi.types = types;
             }
         }
 
       // <FCN_NAME, TYPES>
@@ -1991,17 +1989,17 @@ execute_pkg_add (const std::string& dir)
 
 void
 execute_pkg_del (const std::string& dir)
 {
   execute_pkg_add_or_del (dir, "PKG_DEL");
 }
 
 DEFUN (genpath, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} genpath (@var{dir})\n\
 @deftypefnx {Built-in Function} {} genpath (@var{dir}, @var{skip}, @dots{})\n\
 Return a path constructed from @var{dir} and all its subdirectories.\n\
 If additional string parameters are given, the resulting path will\n\
 exclude directories with those names.\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -2042,49 +2040,49 @@ exclude directories with those names.\n\
   return retval;
 }
 
 static void
 rehash_internal (void)
 {
   load_path::update ();
 
-  // FIXME -- maybe we should rename this variable since it is being
+  // FIXME: maybe we should rename this variable since it is being
   // used for more than keeping track of the prompt time.
 
   // This will force updated functions to be found.
   Vlast_prompt_time.stamp ();
 }
 
 DEFUN (rehash, , ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} rehash ()\n\
 Reinitialize Octave's load path directory cache.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   rehash_internal ();
 
   return retval;
 }
 
 DEFUN (command_line_path, , ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} command_line_path (@dots{})\n\
 Return the command line path variable.\n\
 \n\
 @seealso{path, addpath, rmpath, genpath, pathdef, savepath, pathsep}\n\
 @end deftypefn")
 {
   return octave_value (load_path::get_command_line_path ());
 }
 
 DEFUN (restoredefaultpath, , ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} restoredefaultpath (@dots{})\n\
 Restore Octave's path to its initial state at startup.\n\
 \n\
 @seealso{path, addpath, rmpath, genpath, pathdef, savepath, pathsep}\n\
 @end deftypefn")
 {
   load_path::initialize (true);
 
@@ -2092,26 +2090,26 @@ Restore Octave's path to its initial sta
 }
 
 // Return Octave's original default list of directories in which to
 // search for function files.  This corresponds to the path that
 // exists prior to running the system's octaverc file or the user's
 // ~/.octaverc file
 
 DEFUN (__pathorig__, , ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{val} =} __pathorig__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   return octave_value (load_path::system_path ());
 }
 
 DEFUN (path, args, nargout,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} path (@dots{})\n\
 Modify or display Octave's load path.\n\
 \n\
 If @var{nargin} and @var{nargout} are zero, display the elements of\n\
 Octave's load path in an easy to read format.\n\
 \n\
 If @var{nargin} is zero and nargout is greater than zero, return the\n\
 current load path.\n\
@@ -2143,31 +2141,32 @@ No checks are made for duplicate element
 
           rehash_internal ();
         }
 
       if (nargout > 0)
         retval = load_path::path ();
       else if (argc == 1 && nargout == 0)
         {
-          octave_stdout << "\nOctave's search path contains the following directories:\n\n";
+          octave_stdout <<
+                        "\nOctave's search path contains the following directories:\n\n";
 
           string_vector dirs = load_path::dirs ();
 
           dirs.list_in_columns (octave_stdout);
 
           octave_stdout << "\n";
         }
     }
 
   return retval;
 }
 
 DEFUN (addpath, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} addpath (@var{dir1}, @dots{})\n\
 @deftypefnx {Built-in Function} {} addpath (@var{dir1}, @dots{}, @var{option})\n\
 Add named directories to the function search path.  If\n\
 @var{option} is @qcode{\"-begin\"} or 0 (the default), prepend the\n\
 directory name to the current path.  If @var{option} is @qcode{\"-end\"}\n\
 or 1, append the directory name to the current path.\n\
 Directories added to the path must exist.\n\
 \n\
@@ -2273,17 +2272,17 @@ addpath (\"dir1:/dir2:~/dir3\")\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (rmpath, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} rmpath (@var{dir1}, @dots{})\n\
 Remove @var{dir1}, @dots{} from the current function search path.\n\
 \n\
 In addition to accepting individual directory arguments, lists of\n\
 directory names separated by @code{pathsep} are also accepted.  For example:\n\
 \n\
 @example\n\
 rmpath (\"dir1:/dir2:~/dir3\")\n\
diff --git a/libinterp/corefcn/load-path.h b/libinterp/corefcn/load-path.h
--- a/libinterp/corefcn/load-path.h
+++ b/libinterp/corefcn/load-path.h
@@ -94,126 +94,127 @@ public:
     return instance_ok () ? instance->do_contains_canonical (dir_name) : false;
   }
 
   static std::string find_method (const std::string& class_name,
                                   const std::string& meth,
                                   std::string& dir_name)
   {
     return instance_ok ()
-      ? instance->do_find_method (class_name, meth, dir_name) : std::string ();
+           ? instance->do_find_method (class_name, meth, dir_name)
+           : std::string ();
   }
 
   static std::string find_method (const std::string& class_name,
                                   const std::string& meth)
   {
     std::string dir_name;
     return find_method (class_name, meth, dir_name);
   }
 
   static std::list<std::string> methods (const std::string& class_name)
   {
     return instance_ok ()
-      ? instance->do_methods (class_name) : std::list<std::string> ();
+           ? instance->do_methods (class_name) : std::list<std::string> ();
   }
 
   static std::list<std::string> overloads (const std::string& meth)
   {
     return instance_ok ()
-      ? instance->do_overloads (meth) : std::list<std::string> ();
+           ? instance->do_overloads (meth) : std::list<std::string> ();
   }
 
   static std::string find_fcn (const std::string& fcn, std::string& dir_name)
   {
     return instance_ok ()
-      ? instance->do_find_fcn (fcn, dir_name) : std::string ();
+           ? instance->do_find_fcn (fcn, dir_name) : std::string ();
   }
 
   static std::string find_fcn (const std::string& fcn)
   {
     std::string dir_name;
     return find_fcn (fcn, dir_name);
   }
 
   static std::string find_private_fcn (const std::string& dir,
                                        const std::string& fcn)
   {
     return instance_ok ()
-      ? instance->do_find_private_fcn (dir, fcn) : std::string ();
+           ? instance->do_find_private_fcn (dir, fcn) : std::string ();
   }
 
   static std::string find_fcn_file (const std::string& fcn)
   {
     std::string dir_name;
 
     return instance_ok () ?
-      instance->do_find_fcn (fcn, dir_name, M_FILE) : std::string ();
+           instance->do_find_fcn (fcn, dir_name, M_FILE) : std::string ();
   }
 
   static std::string find_oct_file (const std::string& fcn)
   {
     std::string dir_name;
 
     return instance_ok () ?
-      instance->do_find_fcn (fcn, dir_name, OCT_FILE) : std::string ();
+           instance->do_find_fcn (fcn, dir_name, OCT_FILE) : std::string ();
   }
 
   static std::string find_mex_file (const std::string& fcn)
   {
     std::string dir_name;
 
     return instance_ok () ?
-      instance->do_find_fcn (fcn, dir_name, MEX_FILE) : std::string ();
+           instance->do_find_fcn (fcn, dir_name, MEX_FILE) : std::string ();
   }
 
   static std::string find_file (const std::string& file)
   {
     return instance_ok ()
-      ? instance->do_find_file (file) : std::string ();
+           ? instance->do_find_file (file) : std::string ();
   }
 
   static std::string find_dir (const std::string& dir)
   {
     return instance_ok ()
-      ? instance->do_find_dir (dir) : std::string ();
+           ? instance->do_find_dir (dir) : std::string ();
   }
 
   static string_vector find_matching_dirs (const std::string& dir)
   {
     return instance_ok ()
-      ? instance->do_find_matching_dirs (dir) : string_vector ();
+           ? instance->do_find_matching_dirs (dir) : string_vector ();
   }
 
   static std::string find_first_of (const string_vector& files)
   {
     return instance_ok () ?
-      instance->do_find_first_of (files) : std::string ();
+           instance->do_find_first_of (files) : std::string ();
   }
 
   static string_vector find_all_first_of (const string_vector& files)
   {
     return instance_ok () ?
-      instance->do_find_all_first_of (files) : string_vector ();
+           instance->do_find_all_first_of (files) : string_vector ();
   }
 
   static string_vector dirs (void)
   {
     return instance_ok () ? instance->do_dirs () : string_vector ();
   }
 
   static std::list<std::string> dir_list (void)
   {
     return instance_ok ()
-      ? instance->do_dir_list () : std::list<std::string> ();
+           ? instance->do_dir_list () : std::list<std::string> ();
   }
 
   static string_vector files (const std::string& dir, bool omit_exts = false)
   {
     return instance_ok ()
-      ? instance->do_files (dir, omit_exts) : string_vector ();
+           ? instance->do_files (dir, omit_exts) : string_vector ();
   }
 
   static string_vector fcn_names (void)
   {
     return instance_ok () ? instance->do_fcn_names () : string_vector ();
   }
 
   static std::string path (void)
@@ -236,17 +237,18 @@ public:
     if (command_line_path.empty ())
       command_line_path = p;
     else
       command_line_path += dir_path::path_sep_str () + p;
   }
 
   static std::string get_command_line_path (void)
   {
-    return instance_ok () ? instance->do_get_command_line_path () : std::string ();
+    return instance_ok () ? instance->do_get_command_line_path ()
+                          : std::string ();
   }
 
   static std::string system_path (void)
   {
     return instance_ok () ? instance->do_system_path () : std::string ();
   }
 
 private:
@@ -297,17 +299,17 @@ private:
 
     // This default constructor is only provided so we can create a
     // std::map of dir_info objects.  You should not use this
     // constructor for any other purpose.
     dir_info (void)
       : dir_name (), abs_dir_name (), is_relative (false),
         dir_mtime (), dir_time_last_checked (),
         all_files (), fcn_files (), private_file_map (), method_file_map ()
-      { }
+    { }
 
     dir_info (const std::string& d)
       : dir_name (d), abs_dir_name (), is_relative (false),
         dir_mtime (), dir_time_last_checked (),
         all_files (), fcn_files (), private_file_map (), method_file_map ()
     {
       initialize ();
     }
@@ -423,17 +425,18 @@ private:
 
   // <FCN_NAME, FILE_INFO_LIST>
   typedef std::map<std::string, file_info_list_type> fcn_map_type;
 
   typedef fcn_map_type::const_iterator const_fcn_map_iterator;
   typedef fcn_map_type::iterator fcn_map_iterator;
 
   // <DIR_NAME, <FCN_NAME, TYPE>>
-  typedef std::map<std::string, dir_info::fcn_file_map_type> private_fcn_map_type;
+  typedef std::map<std::string, dir_info::fcn_file_map_type>
+    private_fcn_map_type;
 
   typedef private_fcn_map_type::const_iterator const_private_fcn_map_iterator;
   typedef private_fcn_map_type::iterator private_fcn_map_iterator;
 
   // <CLASS_NAME, <FCN_NAME, FILE_INFO_LIST>>
   typedef std::map<std::string, fcn_map_type> method_map_type;
 
   typedef method_map_type::const_iterator const_method_map_iterator;
@@ -548,17 +551,18 @@ private:
 
   friend void
   print_fcn_list (std::ostream& os, const dir_info::fcn_file_map_type& lst);
 
   void do_display (std::ostream& os) const;
 
   std::string do_system_path (void) const { return sys_path; }
 
-  std::string do_get_command_line_path (void) const { return command_line_path; }
+  std::string do_get_command_line_path (void) const
+  { return command_line_path; }
 
   void add_to_fcn_map (const dir_info& di, bool at_end) const;
 
   void add_to_private_fcn_map (const dir_info& di) const;
 
   void add_to_method_map (const dir_info& di, bool at_end) const;
 
   friend dir_info::fcn_file_map_type get_fcn_files (const std::string& d);
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -269,21 +269,21 @@ get_file_format (std::istream& file, con
 
               if (! tmp.empty ())
                 retval = LS_ASCII;
               else
                 {
                   file.clear ();
                   file.seekg (0, std::ios::beg);
 
-                  // FIXME -- looks_like_mat_ascii_file does not check to see
-                  // whether the file contains numbers.  It just skips comments and
-                  // checks for the same number of words on each line.  We may need
-                  // a better check here.  The best way to do that might be just
-                  // to try to read the file and see if it works.
+                  // FIXME: looks_like_mat_ascii_file does not check to see
+                  // whether the file contains numbers.  It just skips comments
+                  // and checks for the same number of words on each line.  We
+                  // may need a better check here.  The best way to do that
+                  // might be just to try to read the file and see if it works.
 
                   if (looks_like_mat_ascii_file (file, filename))
                     retval = LS_MAT_ASCII;
                 }
             }
         }
     }
 
@@ -550,17 +550,17 @@ find_file_to_load (const std::string& na
 bool
 is_octave_data_file (const std::string& fname)
 {
   bool use_zlib = false;
   return get_file_format (fname, fname, use_zlib, true) != LS_UNKNOWN;
 }
 
 DEFUN (load, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Command} {} load file\n\
 @deftypefnx {Command} {} load options file\n\
 @deftypefnx {Command} {} load options file v1 v2 @dots{}\n\
 @deftypefnx {Command} {S =} load (\"options\", \"file\", \"v1\", \"v2\", @dots{})\n\
 @deftypefnx {Command} {} load file options\n\
 @deftypefnx {Command} {} load file options v1 v2 @dots{}\n\
 @deftypefnx {Command} {S =} load (\"file\", \"options\", \"v1\", \"v2\", @dots{})\n\
 Load the named variables @var{v1}, @var{v2}, @dots{}, from the file\n\
@@ -835,17 +835,18 @@ Force Octave to assume the file is in Oc
                         {
                           if (file) file.close ();
                           return retval;
                         }
                     }
                   else if (format == LS_MAT5_BINARY
                            || format == LS_MAT7_BINARY)
                     {
-                      if (read_mat5_binary_file_header (file, swap, false, orig_fname) < 0)
+                      if (read_mat5_binary_file_header (file, swap, false,
+                                                        orig_fname) < 0)
                         {
                           if (file) file.close ();
                           return retval;
                         }
                     }
 
                   retval = do_load (file, orig_fname, format,
                                     flt_fmt, list_only, swap, verbose,
@@ -869,17 +870,18 @@ Force Octave to assume the file is in Oc
                         {
                           if (file) file.close ();
                           return retval;
                         }
                     }
                   else if (format == LS_MAT5_BINARY
                            || format == LS_MAT7_BINARY)
                     {
-                      if (read_mat5_binary_file_header (file, swap, false, orig_fname) < 0)
+                      if (read_mat5_binary_file_header (file, swap, false,
+                                                        orig_fname) < 0)
                         {
                           if (file) file.close ();
                           return retval;
                         }
                     }
 
                   retval = do_load (file, orig_fname, format,
                                     flt_fmt, list_only, swap, verbose,
@@ -1034,17 +1036,18 @@ save_fields (std::ostream& os, const oct
 static size_t
 save_vars (std::ostream& os, const std::string& pattern,
            load_save_format fmt, bool save_as_floats)
 {
   std::list<symbol_table::symbol_record> vars = symbol_table::glob (pattern);
 
   size_t saved = 0;
 
-  typedef std::list<symbol_table::symbol_record>::const_iterator const_vars_iterator;
+  typedef std::list<symbol_table::symbol_record>::const_iterator
+    const_vars_iterator;
 
   for (const_vars_iterator p = vars.begin (); p != vars.end (); p++)
     {
       do_save (os, *p, fmt, save_as_floats);
 
       if (error_state)
         break;
 
@@ -1256,17 +1259,17 @@ write_header (std::ostream& os, load_sav
                 hdf5_ofstream& hs = dynamic_cast<hdf5_ofstream&> (os);
                 H5Gset_comment (hs.file_id, "/", comment_string.c_str ());
               }
             else
 #endif /* HAVE_HDF5 */
               os << comment_string << "\n";
           }
       }
-    break;
+      break;
 
     default:
       break;
     }
 }
 
 void
 octave_prepare_hdf5 (void)
@@ -1357,31 +1360,32 @@ dump_octave_core (std::ostream& os, cons
 {
   write_header (os, fmt);
 
   std::list<symbol_table::symbol_record> vars
     = symbol_table::all_variables (symbol_table::top_scope (), 0);
 
   double save_mem_size = 0;
 
-  typedef std::list<symbol_table::symbol_record>::const_iterator const_vars_iterator;
+  typedef std::list<symbol_table::symbol_record>::const_iterator
+    const_vars_iterator;
 
   for (const_vars_iterator p = vars.begin (); p != vars.end (); p++)
     {
       octave_value val = p->varval ();
 
       if (val.is_defined ())
         {
           std::string name = p->name ();
           std::string help;
           bool global = p->is_global ();
 
           double val_size = val.byte_size () / 1024;
 
-          // FIXME -- maybe we should try to throw out the largest first...
+          // FIXME: maybe we should try to throw out the largest first...
 
           if (Voctave_core_file_limit < 0
               || save_mem_size + val_size < Voctave_core_file_limit)
             {
               save_mem_size += val_size;
 
               do_save (os, val, name, help, global, fmt, save_as_floats);
 
@@ -1394,17 +1398,17 @@ dump_octave_core (std::ostream& os, cons
   message (0, "save to '%s' complete", fname);
 }
 
 void
 dump_octave_core (void)
 {
   if (Vcrash_dumps_octave_core)
     {
-      // FIXME -- should choose better file name?
+      // FIXME: should choose better file name?
 
       const char *fname = Voctave_core_file_name.c_str ();
 
       message (0, "attempting to save variables to '%s'...", fname);
 
       load_save_format format = LS_BINARY;
 
       bool save_as_floats = false;
@@ -1480,17 +1484,17 @@ dump_octave_core (void)
               else
                 warning ("unable to open '%s' for writing...", fname);
             }
         }
     }
 }
 
 DEFUN (save, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Command} {} save file\n\
 @deftypefnx {Command} {} save options file\n\
 @deftypefnx {Command} {} save options file @var{v1} @var{v2} @dots{}\n\
 @deftypefnx {Command} {} save options file -struct @var{STRUCT} @var{f1} @var{f2} @dots{}\n\
 Save the named variables @var{v1}, @var{v2}, @dots{}, in the file\n\
 @var{file}.  The special filename @samp{-} may be used to write\n\
 output to the terminal.  If no variable names are listed, Octave saves\n\
 all the variables in the current scope.  Otherwise, full variable names or\n\
@@ -1664,18 +1668,18 @@ the file @file{data} in Octave's binary 
       else
 #endif /* HAVE_HDF5 */
         // don't insert any commands here!  the brace below must go
         // with the "else" above!
         {
           if (append)
             warning ("save: ignoring -append option for output to stdout");
 
-          // FIXME -- should things intended for the screen end up
-          // in a octave_value (string)?
+          // FIXME: should things intended for the screen
+          //        end up in an octave_value (string)?
 
           save_vars (argv, i, argc, octave_stdout, format,
                      save_as_floats, true);
         }
     }
 
   // Guard against things like 'save a*', which are probably mistakes...
 
@@ -1722,22 +1726,22 @@ the file @file{data} in Octave's binary 
           hdf5_ofstream hdf5_file (fname.c_str (), mode);
 
           if (hdf5_file.file_id != -1)
             {
               save_vars (argv, i, argc, hdf5_file, format,
                          save_as_floats, write_header_info);
 
               hdf5_file.close ();
-          }
-        else
-          {
-            gripe_file_open ("save", fname);
-            return retval;
-          }
+            }
+          else
+            {
+              gripe_file_open ("save", fname);
+              return retval;
+            }
         }
       else
 #endif /* HAVE_HDF5 */
         // don't insert any statements here!  The brace below must go
         // with the "else" above!
         {
 #ifdef HAVE_ZLIB
           if (use_zlib)
@@ -1781,17 +1785,17 @@ the file @file{data} in Octave's binary 
             }
         }
     }
 
   return retval;
 }
 
 DEFUN (crash_dumps_octave_core, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} crash_dumps_octave_core ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} crash_dumps_octave_core (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} crash_dumps_octave_core (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave tries\n\
 to save all current variables to the file @file{octave-workspace} if it\n\
 crashes or receives a hangup, terminate or similar signal.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
@@ -1799,17 +1803,17 @@ variable is changed locally for the func
 The original variable value is restored when exiting the function.\n\
 @seealso{octave_core_file_limit, octave_core_file_name, octave_core_file_options}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (crash_dumps_octave_core);
 }
 
 DEFUN (save_default_options, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} save_default_options ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} save_default_options (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} save_default_options (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the default options\n\
 for the @code{save} command, and defines the default format.\n\
 Typical values include @qcode{\"-ascii\"}, @qcode{\"-text -zip\"}.\n\
 The default value is @option{-text}.\n\
 \n\
@@ -1818,17 +1822,17 @@ variable is changed locally for the func
 The original variable value is restored when exiting the function.\n\
 @seealso{save}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (save_default_options);
 }
 
 DEFUN (octave_core_file_limit, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} octave_core_file_limit ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} octave_core_file_limit (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} octave_core_file_limit (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the maximum amount\n\
 of memory (in kilobytes) of the top-level workspace that Octave will\n\
 attempt to save when writing data to the crash dump file (the name of\n\
 the file is specified by @var{octave_core_file_name}).  If\n\
 @var{octave_core_file_options} flags specify a binary format,\n\
@@ -1841,17 +1845,17 @@ variable is changed locally for the func
 The original variable value is restored when exiting the function.\n\
 @seealso{crash_dumps_octave_core, octave_core_file_name, octave_core_file_options}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (octave_core_file_limit);
 }
 
 DEFUN (octave_core_file_name, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} octave_core_file_name ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} octave_core_file_name (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} octave_core_file_name (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the name of the file\n\
 used for saving data from the top-level workspace if Octave aborts.\n\
 The default value is @qcode{\"octave-workspace\"}\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
@@ -1859,17 +1863,17 @@ variable is changed locally for the func
 The original variable value is restored when exiting the function.\n\
 @seealso{crash_dumps_octave_core, octave_core_file_name, octave_core_file_options}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (octave_core_file_name);
 }
 
 DEFUN (octave_core_file_options, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} octave_core_file_options ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} octave_core_file_options (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} octave_core_file_options (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the options used for\n\
 saving the workspace data if Octave aborts.  The value of\n\
 @code{octave_core_file_options} should follow the same format as the\n\
 options for the @code{save} function.  The default value is Octave's binary\n\
 format.\n\
@@ -1879,17 +1883,17 @@ variable is changed locally for the func
 The original variable value is restored when exiting the function.\n\
 @seealso{crash_dumps_octave_core, octave_core_file_name, octave_core_file_limit}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (octave_core_file_options);
 }
 
 DEFUN (save_header_format_string, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} save_header_format_string ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} save_header_format_string (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} save_header_format_string (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the format\n\
 string used for the comment line written at the beginning of\n\
 text-format data files saved by Octave.  The format string is\n\
 passed to @code{strftime} and should begin with the character\n\
 @samp{#} and contain no newline characters.  If the value of\n\
diff --git a/libinterp/corefcn/load-save.h b/libinterp/corefcn/load-save.h
--- a/libinterp/corefcn/load-save.h
+++ b/libinterp/corefcn/load-save.h
@@ -29,28 +29,28 @@ along with Octave; see the file COPYING.
 #include "mach-info.h"
 #include "symtab.h"
 
 class octave_value;
 
 // FIXME: maybe MAT5 and MAT7 should be options to MAT_BINARY.
 // Similarly, save_as_floats may be an option for LS_BINARY, LS_HDF5 etc.
 enum load_save_format_type
-  {
-    LS_ASCII,
-    LS_BINARY,
-    LS_MAT_ASCII,
-    LS_MAT_BINARY,
-    LS_MAT5_BINARY,
-    LS_MAT7_BINARY,
+{
+  LS_ASCII,
+  LS_BINARY,
+  LS_MAT_ASCII,
+  LS_MAT_BINARY,
+  LS_MAT5_BINARY,
+  LS_MAT7_BINARY,
 #ifdef HAVE_HDF5
-    LS_HDF5,
+  LS_HDF5,
 #endif /* HAVE_HDF5 */
-    LS_UNKNOWN
-  };
+  LS_UNKNOWN
+};
 
 enum load_save_format_options
 {
   // LS_MAT_ASCII options (not exclusive)
   LS_MAT_ASCII_LONG = 1,
   LS_MAT_ASCII_TABS = 2,
   // LS_MAT_BINARY options
   LS_MAT_BINARY_V5 = 1,
@@ -61,17 +61,17 @@ enum load_save_format_options
 
 class load_save_format
 {
 public:
   load_save_format (load_save_format_type t,
                     load_save_format_options o = LS_NO_OPTION)
     : type (t), opts (o) { }
   operator int (void) const
-    { return type; }
+  { return type; }
   int type, opts;
 };
 
 extern void dump_octave_core (void);
 
 extern int
 read_binary_file_header (std::istream& is, bool& swap,
                          oct_mach_info::float_format& flt_fmt,
diff --git a/libinterp/corefcn/lookup.cc b/libinterp/corefcn/lookup.cc
--- a/libinterp/corefcn/lookup.cc
+++ b/libinterp/corefcn/lookup.cc
@@ -56,18 +56,18 @@ struct icmp_char_lt : public std::binary
 };
 
 struct icmp_char_gt : public std::binary_function<char, char, bool>
 {
   bool operator () (char x, char y) const
     { return std::toupper (x) > std::toupper (y); }
 };
 
-// FIXME -- maybe these should go elsewhere?
-// FIXME -- are they even needed now?
+// FIXME: maybe these should go elsewhere?
+// FIXME: are they even needed now?
 // case-insensitive ascending comparator
 #if 0
 static bool
 stri_comp_lt (const std::string& a, const std::string& b)
 {
   return std::lexicographical_compare (a.begin (), a.end (),
                                        b.begin (), b.end (),
                                        icmp_char_lt ());
@@ -182,17 +182,17 @@ do_numeric_lookup (const ArrayT& array, 
     }
   else
     retval = idx;
 
   return retval;
 }
 
 DEFUN (lookup, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{idx} =} lookup (@var{table}, @var{y})\n\
 @deftypefnx {Built-in Function} {@var{idx} =} lookup (@var{table}, @var{y}, @var{opt})\n\
 Lookup values in a sorted table.  Usually used as a prelude to\n\
 interpolation.\n\
 \n\
 If table is increasing and @code{idx = lookup (table, y)}, then\n\
 @code{table(idx(i)) <= y(i) < table(idx(i+1))} for all @code{y(i)}\n\
 within the table.  If @code{y(i) < table(1)} then\n\
@@ -281,18 +281,18 @@ at most n-1).\n\
     error ("lookup: l, r are not recognized for string lookups");
 
   if (error_state)
     return retval;
 
   if (num_case)
     {
 
-      // In the case of a complex array, absolute values will be used for compatibility
-      // (though it's not too meaningful).
+      // In the case of a complex array, absolute values will be used for
+      // compatibility (though it's not too meaningful).
 
       if (table.is_complex_type ())
         table = table.abs ();
 
       if (y.is_complex_type ())
         y = y.abs ();
 
       Array<octave_idx_type> idx;
@@ -351,17 +351,18 @@ at most n-1).\n\
       else if (match_idx)
         {
           NDArray ridx (idx.dims ());
           if (match_idx)
             {
               for (octave_idx_type i = 0; i < nval; i++)
                 {
                   octave_idx_type j = idx.xelem (i);
-                  ridx.xelem (i) = (j != 0 && str_y(i) == str_table(j-1)) ? j : 0;
+                  ridx.xelem (i) = (j != 0 && str_y(i) == str_table(j-1)) ? j
+                                                                          : 0;
                 }
             }
 
           retval = ridx;
         }
       else
         retval = idx;
     }
diff --git a/libinterp/corefcn/ls-ascii-helper.cc b/libinterp/corefcn/ls-ascii-helper.cc
--- a/libinterp/corefcn/ls-ascii-helper.cc
+++ b/libinterp/corefcn/ls-ascii-helper.cc
@@ -104,17 +104,17 @@ skip_preceeding_newline (std::istream& i
           is.get (d);
 
           // Make sure that for binary-mode opened ascii files
           // containing CRLF line endings we skip the LF after CR.
           if (c == '\r' && is.peek () == '\n')
             {
               // Yes, LF following CR, eat it.
               is.get (d);
-          }
+            }
 
           // Peek into next character.
           c = is.peek ();
 
           // Loop while still a newline ahead.
         }
       while (c == '\n' || c == '\r');
     }
diff --git a/libinterp/corefcn/ls-hdf5.cc b/libinterp/corefcn/ls-hdf5.cc
--- a/libinterp/corefcn/ls-hdf5.cc
+++ b/libinterp/corefcn/ls-hdf5.cc
@@ -243,18 +243,21 @@ hdf5_make_complex_type (hid_t num_type)
 // It returns 1 on success (in which case H5Giterate stops and returns),
 // -1 on error, and 0 to tell H5Giterate to continue on to the next item
 // (e.g. if NAME was a data type we don't recognize).
 
 herr_t
 hdf5_read_next_data (hid_t group_id, const char *name, void *dv)
 {
   hdf5_callback_data *d = static_cast <hdf5_callback_data *> (dv);
-  hid_t type_id = -1, type_class_id = -1, data_id = -1, subgroup_id = -1,
-    space_id = -1;
+  hid_t type_id = -1;
+  hid_t type_class_id = -1;
+  hid_t data_id = -1;
+  hid_t subgroup_id = -1;
+  hid_t space_id = -1;;
 
   H5G_stat_t info;
   herr_t retval = 0;
   bool ident_valid = valid_identifier (name);
 
   std::string vname = name;
 
   // Allow identifiers as all digits so we can load lists saved by
@@ -539,17 +542,17 @@ hdf5_read_next_data (hid_t group_id, con
   if (!ident_valid)
     {
       // should we attempt to handle invalid identifiers by converting
       // bad characters to '_', say?
       warning ("load: skipping invalid identifier '%s' in hdf5 file",
                name);
     }
 
- done:
+done:
   if (retval < 0)
     error ("load: error while reading hdf5 item %s", name);
 
   if (retval > 0)
     {
       // get documentation string, if any:
       int comment_length = H5Gget_comment (group_id, name, 0, 0);
 
@@ -575,17 +578,17 @@ hdf5_read_next_data (hid_t group_id, con
 
 // Read the next Octave variable from the stream IS, which must really be
 // an hdf5_ifstream.  Return the variable value in tc, its doc string
 // in doc, and whether it is global in global.  The return value is
 // the name of the variable, or NULL if none were found or there was
 // and error.
 std::string
 read_hdf5_data (std::istream& is, const std::string& /* filename */,
-                bool& global, octave_value& tc, std::string& doc, 
+                bool& global, octave_value& tc, std::string& doc,
                 const string_vector& argv, int argv_idx, int argc)
 {
   std::string retval;
 
   doc.resize (0);
 
   hdf5_ifstream& hs = dynamic_cast<hdf5_ifstream&> (is);
   hdf5_callback_data d;
@@ -869,17 +872,18 @@ add_hdf5_data (hid_t loc_id, const octav
   // themselves, so we convert them first to normal matrices using A = A(:,:).
   // This is a temporary hack.
   if (val.is_diag_matrix () || val.is_perm_matrix ()
       || val.type_id () == octave_lazy_index::static_type_id ())
     val = val.full_value ();
 
   std::string t = val.type_name ();
 #if HAVE_HDF5_18
-  data_id = H5Gcreate (loc_id, name.c_str (), H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+  data_id = H5Gcreate (loc_id, name.c_str (), H5P_DEFAULT, H5P_DEFAULT,
+                       H5P_DEFAULT);
 #else
   data_id = H5Gcreate (loc_id, name.c_str (), 0);
 #endif
   if (data_id < 0)
     goto error_cleanup;
 
   // attach the type of the variable
   type_id = H5Tcopy (H5T_C_S1); H5Tset_size (type_id, t.length () + 1);
@@ -911,17 +915,17 @@ add_hdf5_data (hid_t loc_id, const octav
   // if it's global, add an attribute "OCTAVE_GLOBAL" with value 1
   if (retval && mark_as_global)
     retval = hdf5_add_attr (data_id, "OCTAVE_GLOBAL") >= 0;
 
   // We are saving in the new variable format, so mark it
   if (retval)
     retval = hdf5_add_attr (data_id, "OCTAVE_NEW_FORMAT") >= 0;
 
- error_cleanup:
+error_cleanup:
 
   if (data_type_id >= 0)
     H5Dclose (data_type_id);
 
   if (type_id >= 0)
     H5Tclose (type_id);
 
   if (space_id >= 0)
diff --git a/libinterp/corefcn/ls-hdf5.h b/libinterp/corefcn/ls-hdf5.h
--- a/libinterp/corefcn/ls-hdf5.h
+++ b/libinterp/corefcn/ls-hdf5.h
@@ -44,62 +44,62 @@ public:
   int current_item;
 
   hdf5_fstreambase () : file_id (-1), current_item () { }
 
   ~hdf5_fstreambase () { close (); }
 
   hdf5_fstreambase (const char *name, int mode, int /* prot */ = 0)
     : file_id (-1), current_item (-1)
-    {
-      if (mode & std::ios::in)
-        file_id = H5Fopen (name, H5F_ACC_RDONLY, H5P_DEFAULT);
-      else if (mode & std::ios::out)
-        {
-          if (mode & std::ios::app && H5Fis_hdf5 (name) > 0)
-            file_id = H5Fopen (name, H5F_ACC_RDWR, H5P_DEFAULT);
-          else
-            file_id = H5Fcreate (name, H5F_ACC_TRUNC, H5P_DEFAULT,
-                                 H5P_DEFAULT);
-        }
-      if (file_id < 0)
-        std::ios::setstate (std::ios::badbit);
+  {
+    if (mode & std::ios::in)
+      file_id = H5Fopen (name, H5F_ACC_RDONLY, H5P_DEFAULT);
+    else if (mode & std::ios::out)
+      {
+        if (mode & std::ios::app && H5Fis_hdf5 (name) > 0)
+          file_id = H5Fopen (name, H5F_ACC_RDWR, H5P_DEFAULT);
+        else
+          file_id = H5Fcreate (name, H5F_ACC_TRUNC, H5P_DEFAULT,
+                               H5P_DEFAULT);
+      }
+    if (file_id < 0)
+      std::ios::setstate (std::ios::badbit);
 
-      current_item = 0;
-    }
+    current_item = 0;
+  }
 
   void close ()
-    {
-      if (file_id >= 0)
-        {
-          if (H5Fclose (file_id) < 0)
-            std::ios::setstate (std::ios::badbit);
-          file_id = -1;
-        }
-    }
+  {
+    if (file_id >= 0)
+      {
+        if (H5Fclose (file_id) < 0)
+          std::ios::setstate (std::ios::badbit);
+        file_id = -1;
+      }
+  }
 
   void open (const char *name, int mode, int)
-    {
-      clear ();
+  {
+    clear ();
 
-      if (mode & std::ios::in)
-        file_id = H5Fopen (name, H5F_ACC_RDONLY, H5P_DEFAULT);
-      else if (mode & std::ios::out)
-        {
-          if (mode & std::ios::app && H5Fis_hdf5 (name) > 0)
-            file_id = H5Fopen (name, H5F_ACC_RDWR, H5P_DEFAULT);
-          else
-            file_id = H5Fcreate (name, H5F_ACC_TRUNC, H5P_DEFAULT,
-                                 H5P_DEFAULT);
-        }
-      if (file_id < 0)
-        std::ios::setstate (std::ios::badbit);
+    if (mode & std::ios::in)
+      file_id = H5Fopen (name, H5F_ACC_RDONLY, H5P_DEFAULT);
+    else if (mode & std::ios::out)
+      {
+        if (mode & std::ios::app && H5Fis_hdf5 (name) > 0)
+          file_id = H5Fopen (name, H5F_ACC_RDWR, H5P_DEFAULT);
+        else
+          file_id = H5Fcreate (name, H5F_ACC_TRUNC, H5P_DEFAULT,
+                               H5P_DEFAULT);
+      }
+    if (file_id < 0)
+      std::ios::setstate (std::ios::badbit);
 
-      current_item = 0;
-    }
+    current_item = 0;
+  }
 };
 
 // input and output streams, subclassing istream and ostream
 // so that we can pass them for stream parameters in the functions below.
 
 class hdf5_ifstream : public hdf5_fstreambase, public std::istream
 {
 public:
@@ -107,32 +107,32 @@ public:
   hdf5_ifstream () : hdf5_fstreambase (), std::istream (0) { }
 
   hdf5_ifstream (const char *name, int mode = std::ios::in|std::ios::binary,
                  int prot = 0)
     : hdf5_fstreambase (name, mode, prot), std::istream (0) { }
 
   void open (const char *name, int mode = std::ios::in|std::ios::binary,
              int prot = 0)
-    { hdf5_fstreambase::open (name, mode, prot); }
+  { hdf5_fstreambase::open (name, mode, prot); }
 };
 
 class hdf5_ofstream : public hdf5_fstreambase, public std::ostream
 {
 public:
 
   hdf5_ofstream () : hdf5_fstreambase (), std::ostream (0) { }
 
   hdf5_ofstream (const char *name, int mode = std::ios::out|std::ios::binary,
                  int prot = 0)
     : hdf5_fstreambase (name, mode, prot), std::ostream (0) { }
 
   void open (const char *name, int mode = std::ios::out|std::ios::binary,
              int prot = 0)
-    { hdf5_fstreambase::open (name, mode, prot); }
+  { hdf5_fstreambase::open (name, mode, prot); }
 };
 
 // Callback data structure for passing data to hdf5_read_next_data, below.
 
 struct
 hdf5_callback_data
 {
   hdf5_callback_data (void)
@@ -175,17 +175,17 @@ add_hdf5_data (hid_t loc_id, const octav
 extern OCTINTERP_API int
 save_hdf5_empty (hid_t loc_id, const char *name, const dim_vector d);
 
 extern OCTINTERP_API int
 load_hdf5_empty (hid_t loc_id, const char *name, dim_vector &d);
 
 extern OCTINTERP_API std::string
 read_hdf5_data (std::istream& is,  const std::string& filename, bool& global,
-                octave_value& tc, std::string& doc,								
+                octave_value& tc, std::string& doc,
                 const string_vector& argv, int argv_idx, int argc);
 
 extern OCTINTERP_API bool
 save_hdf5_data (std::ostream& os, const octave_value& tc,
                 const std::string& name, const std::string& doc,
                 bool mark_as_global, bool save_as_floats);
 
 extern OCTINTERP_API bool
diff --git a/libinterp/corefcn/ls-mat-ascii.cc b/libinterp/corefcn/ls-mat-ascii.cc
--- a/libinterp/corefcn/ls-mat-ascii.cc
+++ b/libinterp/corefcn/ls-mat-ascii.cc
@@ -128,17 +128,18 @@ get_lines_and_columns (std::istream& is,
       file_line_number++;
 
       size_t beg = buf.find_first_not_of (", \t");
 
       // If we see a CR as the last character in the buffer, we had a
       // CRLF pair as the line separator.  Any other CR in the text
       // will not be considered as whitespace.
 
-      if (beg != std::string::npos && buf[beg] == '\r' && beg == buf.length () - 1)
+      if (beg != std::string::npos && buf[beg] == '\r'
+          && beg == buf.length () - 1)
         {
           // We had a blank line ending with a CRLF.  Handle it the
           // same as an empty line.
           beg = std::string::npos;
         }
 
       octave_idx_type tmp_nc = 0;
 
@@ -167,17 +168,17 @@ get_lines_and_columns (std::istream& is,
 
                       goto done;
                     }
                 }
 
               beg = buf.find_first_not_of (", \t", end);
 
               if (beg == std::string::npos || (buf[beg] == '\r' &&
-                                  beg == buf.length () - 1))
+                                               beg == buf.length () - 1))
                 {
                   // We had a line with trailing spaces and
                   // ending with a CRLF, so this should look like EOL,
                   // not a new colum.
                   break;
                 }
             }
           else
@@ -205,17 +206,17 @@ get_lines_and_columns (std::istream& is,
               goto done;
             }
         }
     }
 
   if (! quiet && (nr == 0 || nc == 0))
     error ("load: file '%s' seems to be empty!", filename.c_str ());
 
- done:
+done:
 
   is.clear ();
   is.seekg (pos);
 }
 
 // Extract a matrix from a file of numbers only.
 //
 // Comments are not allowed.  The file should only have numeric values.
@@ -323,17 +324,17 @@ read_mat_ascii_data (std::istream& is, c
                         }
 
                     }
                 }
             }
 
           if (is || is.eof ())
             {
-              // FIXME -- not sure this is best, but it works.
+              // FIXME: not sure this is best, but it works.
 
               if (is.eof ())
                 is.clear ();
 
               octave_idx_type expected = nr * nc;
 
               if (expected == total_count)
                 {
diff --git a/libinterp/corefcn/ls-mat-ascii.h b/libinterp/corefcn/ls-mat-ascii.h
--- a/libinterp/corefcn/ls-mat-ascii.h
+++ b/libinterp/corefcn/ls-mat-ascii.h
@@ -26,11 +26,12 @@ along with Octave; see the file COPYING.
 extern std::string
 read_mat_ascii_data (std::istream& is, const std::string& filename,
                      octave_value& tc);
 
 extern bool
 save_mat_ascii_data (std::ostream& os, const octave_value& val_arg,
                      int precision, bool tabs = false);
 
-extern bool looks_like_mat_ascii_file (std::istream& is, const std::string& filename);
+extern bool looks_like_mat_ascii_file (std::istream& is,
+                                       const std::string& filename);
 
 #endif
diff --git a/libinterp/corefcn/ls-mat4.cc b/libinterp/corefcn/ls-mat4.cc
--- a/libinterp/corefcn/ls-mat4.cc
+++ b/libinterp/corefcn/ls-mat4.cc
@@ -166,17 +166,17 @@ read_mat_file_header (std::istream& is, 
     {
       if (! quiet)
         error ("load: can't read binary file");
       return -1;
     }
 
   return 0;
 
- data_read_error:
+data_read_error:
   return -1;
 }
 
 // We don't just use a cast here, because we need to be able to detect
 // possible errors.
 
 oct_mach_info::float_format
 mopt_digit_to_float_format (int mach)
@@ -353,17 +353,18 @@ read_mat_binary_data (std::istream& is, 
             read_mat_binary_data (is, dtmp, prec, nr, swap, flt_fmt);
             for (octave_idx_type i = 0; i < nr - 1; i++)
               r.xelem (i) = dtmp[i] - 1;
             nr_new = dtmp[nr - 1];
             read_mat_binary_data (is, dtmp, prec, nr, swap, flt_fmt);
             for (octave_idx_type i = 0; i < nr - 1; i++)
               c.xelem (i) = dtmp[i] - 1;
             nc_new = dtmp[nr - 1];
-            read_mat_binary_data (is, data.fortran_vec (), prec, nr - 1, swap, flt_fmt);
+            read_mat_binary_data (is, data.fortran_vec (), prec, nr - 1,
+                                  swap, flt_fmt);
             read_mat_binary_data (is, dtmp, prec, 1, swap, flt_fmt);
 
             SparseMatrix sm = SparseMatrix (data, r, c, nr_new, nc_new);
 
             tc = order ? sm.transpose () : sm;
           }
       }
     else
@@ -401,20 +402,20 @@ read_mat_binary_data (std::istream& is, 
           }
         else
           tc = order ? re.transpose () : re;
 
         if (type == 1)
           tc = tc.convert_to_str (false, true, '\'');
       }
 
-      return retval;
-    }
+    return retval;
+  }
 
- data_read_error:
+data_read_error:
   error ("load: trouble reading binary file '%s'", filename.c_str ());
   return retval;
 }
 
 // Save the data from TC along with the corresponding NAME on stream OS
 // in the MatLab version 4 binary format.
 
 bool
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -84,43 +84,43 @@ along with Octave; see the file COPYING.
 #define READ_PAD(is_small_data_element, l) ((is_small_data_element) ? 4 : (((l)+7)/8)*8)
 #define PAD(l) (((l) > 0 && (l) <= 4) ? 4 : (((l)+7)/8)*8)
 #define INT8(l) ((l) == miINT8 || (l) == miUINT8 || (l) == miUTF8)
 
 
 // The subsystem data block
 static octave_value subsys_ov;
 
-// FIXME -- the following enum values should be the same as the
+// FIXME: the following enum values should be the same as the
 // mxClassID values in mexproto.h, but it seems they have also changed
 // over time.  What is the correct way to handle this and maintain
 // backward compatibility with old MAT files?  For now, use
 // "MAT_FILE_" instead of "mx" as the prefix for these names to avoid
 // conflict with the mxClassID enum in mexproto.h.
 
 enum arrayclasstype
-  {
-    MAT_FILE_CELL_CLASS=1,              // cell array
-    MAT_FILE_STRUCT_CLASS,              // structure
-    MAT_FILE_OBJECT_CLASS,              // object
-    MAT_FILE_CHAR_CLASS,                // character array
-    MAT_FILE_SPARSE_CLASS,              // sparse array
-    MAT_FILE_DOUBLE_CLASS,              // double precision array
-    MAT_FILE_SINGLE_CLASS,              // single precision floating point
-    MAT_FILE_INT8_CLASS,                // 8 bit signed integer
-    MAT_FILE_UINT8_CLASS,               // 8 bit unsigned integer
-    MAT_FILE_INT16_CLASS,               // 16 bit signed integer
-    MAT_FILE_UINT16_CLASS,              // 16 bit unsigned integer
-    MAT_FILE_INT32_CLASS,               // 32 bit signed integer
-    MAT_FILE_UINT32_CLASS,              // 32 bit unsigned integer
-    MAT_FILE_INT64_CLASS,               // 64 bit signed integer
-    MAT_FILE_UINT64_CLASS,              // 64 bit unsigned integer
-    MAT_FILE_FUNCTION_CLASS,            // Function handle
-    MAT_FILE_WORKSPACE_CLASS            // Workspace (undocumented)
-  };
+{
+  MAT_FILE_CELL_CLASS=1,              // cell array
+  MAT_FILE_STRUCT_CLASS,              // structure
+  MAT_FILE_OBJECT_CLASS,              // object
+  MAT_FILE_CHAR_CLASS,                // character array
+  MAT_FILE_SPARSE_CLASS,              // sparse array
+  MAT_FILE_DOUBLE_CLASS,              // double precision array
+  MAT_FILE_SINGLE_CLASS,              // single precision floating point
+  MAT_FILE_INT8_CLASS,                // 8 bit signed integer
+  MAT_FILE_UINT8_CLASS,               // 8 bit unsigned integer
+  MAT_FILE_INT16_CLASS,               // 16 bit signed integer
+  MAT_FILE_UINT16_CLASS,              // 16 bit unsigned integer
+  MAT_FILE_INT32_CLASS,               // 32 bit signed integer
+  MAT_FILE_UINT32_CLASS,              // 32 bit unsigned integer
+  MAT_FILE_INT64_CLASS,               // 64 bit signed integer
+  MAT_FILE_UINT64_CLASS,              // 64 bit unsigned integer
+  MAT_FILE_FUNCTION_CLASS,            // Function handle
+  MAT_FILE_WORKSPACE_CLASS            // Workspace (undocumented)
+};
 
 // Read COUNT elements of data from IS in the format specified by TYPE,
 // placing the result in DATA.  If SWAP is TRUE, swap the bytes of
 // each element before copying to DATA.  FLT_FMT specifies the format
 // of the data if we are reading floating point numbers.
 
 static void
 read_mat5_binary_data (std::istream& is, double *data,
@@ -424,17 +424,17 @@ read_mat5_integer_data (std::istream& is
   \
             tc = ctmp;  \
           } \
         else \
           tc = re; \
   }
 
 // Read one element tag from stream IS,
-// place the type code in TYPE, the byte count in BYTES and true (false) to 
+// place the type code in TYPE, the byte count in BYTES and true (false) to
 // IS_SMALL_DATA_ELEMENT if the tag is 4 (8) bytes long.
 // return nonzero on error
 static int
 read_mat5_tag (std::istream& is, bool swap, int32_t& type, int32_t& bytes,
                bool& is_small_data_element)
 {
   unsigned int upper;
   int32_t temp;
@@ -461,17 +461,17 @@ read_mat5_tag (std::istream& is, bool sw
       if (swap)
         swap_bytes<4> (&temp);
       bytes = temp;
       is_small_data_element = false;
     }
 
   return 0;
 
- data_read_error:
+data_read_error:
   return 1;
 }
 
 static void
 read_int (std::istream& is, bool swap, int32_t& val)
 {
   is.read (reinterpret_cast<char *> (&val), 4);
 
@@ -543,19 +543,20 @@ read_mat5_binary_element (std::istream& 
         {
           // Why should I have to initialize outbuf as I'll just overwrite!!
           if (swap)
             swap_bytes<4> (tmp, 2);
 
           destLen = tmp[1] + 8;
           std::string outbuf (destLen, ' ');
 
-          // FIXME -- find a way to avoid casting away const here!
-
-          int err = uncompress (reinterpret_cast<Bytef *> (const_cast<char *> (outbuf.c_str ())),
+          // FIXME: find a way to avoid casting away const here!
+
+          int err = uncompress (reinterpret_cast<Bytef *> 
+                                 (const_cast<char *> (outbuf.c_str ())),
                                 &destLen, reinterpret_cast<Bytef *> (inbuf),
                                 element_length);
 
           if (err != Z_OK)
             {
               std::string msg;
               switch (err)
                 {
@@ -786,75 +787,82 @@ read_mat5_binary_element (std::istream& 
           }
 
         is.seekg (tmp_pos + static_cast<std::streamoff>
                   (READ_PAD (is_small_data_element, len)));
 
         // col indices
         if (read_mat5_tag (is, swap, type, len, is_small_data_element))
           {
-            error ("load: reading sparse column data for '%s'", retval.c_str ());
+            error ("load: reading sparse column data for '%s'",
+                   retval.c_str ());
             goto data_read_error;
           }
 
         tmp_pos = is.tellg ();
 
         read_mat5_integer_data (is, cidx, nc + 1, swap,
                                 static_cast<enum mat5_data_type> (type));
 
         if (! is || error_state)
           {
-            error ("load: reading sparse column data for '%s'", retval.c_str ());
+            error ("load: reading sparse column data for '%s'",
+                   retval.c_str ());
             goto data_read_error;
           }
 
         is.seekg (tmp_pos + static_cast<std::streamoff>
                   (READ_PAD (is_small_data_element, len)));
 
         // real data subelement
         if (read_mat5_tag (is, swap, type, len, is_small_data_element))
           {
-            error ("load: reading sparse matrix data for '%s'", retval.c_str ());
+            error ("load: reading sparse matrix data for '%s'",
+                   retval.c_str ());
             goto data_read_error;
           }
 
         octave_idx_type nnz = cidx[nc];
         NDArray re;
         if (imag)
           {
             re = NDArray (dim_vector (nnz, 1));
             data = re.fortran_vec ();
           }
 
         tmp_pos = is.tellg ();
         read_mat5_binary_data (is, data, nnz, swap,
-                               static_cast<enum mat5_data_type> (type), flt_fmt);
+                               static_cast<enum mat5_data_type> (type),
+                               flt_fmt);
 
         if (! is || error_state)
           {
-            error ("load: reading sparse matrix data for '%s'", retval.c_str ());
+            error ("load: reading sparse matrix data for '%s'",
+                   retval.c_str ());
             goto data_read_error;
           }
 
         is.seekg (tmp_pos + static_cast<std::streamoff>
                   (READ_PAD (is_small_data_element, len)));
 
         // imaginary data subelement
         if (imag)
           {
             NDArray im (dim_vector (static_cast<int> (nnz), 1));
 
             if (read_mat5_tag (is, swap, type, len, is_small_data_element))
               {
-                error ("load: reading sparse matrix data for '%s'", retval.c_str ());
+                error ("load: reading sparse matrix data for '%s'",
+                       retval.c_str ());
                 goto data_read_error;
               }
 
             read_mat5_binary_data (is, im.fortran_vec (), nnz, swap,
-                                   static_cast<enum mat5_data_type> (type), flt_fmt);
+                                   static_cast<enum mat5_data_type> (type),
+                                   flt_fmt);
 
             if (! is || error_state)
               {
                 error ("load: reading imaginary sparse matrix data for '%s'",
                        retval.c_str ());
                 goto data_read_error;
               }
 
@@ -876,17 +884,18 @@ read_mat5_binary_element (std::istream& 
 
         if (! is || error_state)
           goto data_read_error;
 
         // Octave can handle both "/" and "\" as a directory seperator
         // and so can ignore the separator field of m0. I think the
         // sentinel field is also save to ignore.
         octave_scalar_map m0 = tc2.scalar_map_value ();
-        octave_scalar_map m1 = m0.contents ("function_handle").scalar_map_value ();
+        octave_scalar_map m1
+          = m0.contents ("function_handle").scalar_map_value ();
         std::string ftype = m1.contents ("type").string_value ();
         std::string fname = m1.contents ("function").string_value ();
         std::string fpath = m1.contents ("file").string_value ();
 
         if (ftype == "simple" || ftype == "scopedfunction")
           {
             if (fpath.length () == 0)
               // We have a builtin function
@@ -904,61 +913,64 @@ read_mat5_binary_element (std::istream& 
                     // doesn't equal octave_config_info ("exec_prefix")
                     // then the function points to a version of Octave
                     // or Matlab other than the running version. In that
                     // case we replace with the same function in the
                     // running version of Octave?
 
                     // First check if just replacing matlabroot is enough
                     std::string str = OCTAVE_EXEC_PREFIX +
-                      fpath.substr (mroot.length ());
+                                      fpath.substr (mroot.length ());
                     file_stat fs (str);
 
                     if (fs.exists ())
                       {
                         size_t xpos
                           = str.find_last_of (file_ops::dir_sep_chars ());
 
                         std::string dir_name = str.substr (0, xpos);
 
                         octave_function *fcn
                           = load_fcn_from_file (str, dir_name, "", fname);
 
                         if (fcn)
                           {
                             octave_value tmp (fcn);
 
-                            tc = octave_value (new octave_fcn_handle (tmp, fname));
+                            tc = octave_value (new octave_fcn_handle (tmp,
+                                                                      fname));
                           }
                       }
                     else
                       {
                         // Next just search for it anywhere in the system path
                         string_vector names(3);
                         names(0) = fname + ".oct";
                         names(1) = fname + ".mex";
                         names(2) = fname + ".m";
 
                         dir_path p (load_path::system_path ());
 
-                        str = octave_env::make_absolute (p.find_first_of (names));
+                        str =
+                          octave_env::make_absolute (p.find_first_of (names));
 
                         size_t xpos
                           = str.find_last_of (file_ops::dir_sep_chars ());
 
                         std::string dir_name = str.substr (0, xpos);
 
                         octave_function *fcn
                           = load_fcn_from_file (str, dir_name, "", fname);
 
                         if (fcn)
                           {
                             octave_value tmp (fcn);
 
-                            tc = octave_value (new octave_fcn_handle (tmp, fname));
+                            tc = octave_value (new octave_fcn_handle (tmp,
+                                                                      fname));
                           }
                         else
                           {
                             warning ("load: can't find the file %s",
                                      fpath.c_str ());
                             goto skip_ahead;
                           }
                       }
@@ -990,19 +1002,21 @@ read_mat5_binary_element (std::istream& 
           }
         else if (ftype == "nested")
           {
             warning ("load: can't load nested function");
             goto skip_ahead;
           }
         else if (ftype == "anonymous")
           {
-            octave_scalar_map m2 = m1.contents ("workspace").scalar_map_value ();
+            octave_scalar_map m2
+              = m1.contents ("workspace").scalar_map_value ();
             uint32NDArray MCOS = m2.contents ("MCOS").uint32_array_value ();
-            octave_idx_type off = static_cast<octave_idx_type>(MCOS(4).double_value ());
+            octave_idx_type off
+              = static_cast<octave_idx_type>(MCOS(4).double_value ());
             m2 = subsys_ov.scalar_map_value ();
             m2 = m2.contents ("MCOS").scalar_map_value ();
             tc2 = m2.contents ("MCOS").cell_value ()(1 + off).cell_value ()(1);
             m2 = tc2.scalar_map_value ();
 
             unwind_protect_safe frame;
 
             // Set up temporary scope to use for evaluating the text
@@ -1341,17 +1355,18 @@ read_mat5_binary_element (std::istream& 
           {
             error ("load: reading matrix data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         octave_idx_type n = re.numel ();
         tmp_pos = is.tellg ();
         read_mat5_binary_data (is, re.fortran_vec (), n, swap,
-                               static_cast<enum mat5_data_type> (type), flt_fmt);
+                               static_cast<enum mat5_data_type> (type),
+                               flt_fmt);
 
         if (! is || error_state)
           {
             error ("load: reading matrix data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         is.seekg (tmp_pos + static_cast<std::streamoff>
@@ -1366,17 +1381,18 @@ read_mat5_binary_element (std::istream& 
             if (read_mat5_tag (is, swap, type, len, is_small_data_element))
               {
                 error ("load: reading matrix data for '%s'", retval.c_str ());
                 goto data_read_error;
               }
 
             n = im.numel ();
             read_mat5_binary_data (is, im.fortran_vec (), n, swap,
-                                   static_cast<enum mat5_data_type> (type), flt_fmt);
+                                   static_cast<enum mat5_data_type> (type),
+                                   flt_fmt);
 
             if (! is || error_state)
               {
                 error ("load: reading imaginary matrix data for '%s'",
                        retval.c_str ());
                 goto data_read_error;
               }
 
@@ -1408,17 +1424,18 @@ read_mat5_binary_element (std::istream& 
           {
             error ("load: reading matrix data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         octave_idx_type n = re.numel ();
         tmp_pos = is.tellg ();
         read_mat5_binary_data (is, re.fortran_vec (), n, swap,
-                               static_cast<enum mat5_data_type> (type), flt_fmt);
+                               static_cast<enum mat5_data_type> (type),
+                               flt_fmt);
 
         if (! is || error_state)
           {
             error ("load: reading matrix data for '%s'", retval.c_str ());
             goto data_read_error;
           }
 
         is.seekg (tmp_pos + static_cast<std::streamoff>
@@ -1446,17 +1463,18 @@ read_mat5_binary_element (std::istream& 
             if (read_mat5_tag (is, swap, type, len, is_small_data_element))
               {
                 error ("load: reading matrix data for '%s'", retval.c_str ());
                 goto data_read_error;
               }
 
             n = im.numel ();
             read_mat5_binary_data (is, im.fortran_vec (), n, swap,
-                                   static_cast<enum mat5_data_type> (type), flt_fmt);
+                                   static_cast<enum mat5_data_type> (type),
+                                   flt_fmt);
 
             if (! is || error_state)
               {
                 error ("load: reading imaginary matrix data for '%s'",
                        retval.c_str ());
                 goto data_read_error;
               }
 
@@ -1471,20 +1489,21 @@ read_mat5_binary_element (std::istream& 
           {
             if (arrayclass == MAT_FILE_CHAR_CLASS)
               {
                 if (type == miUTF16 || type == miUTF32)
                   {
                     bool found_big_char = false;
                     for (octave_idx_type i = 0; i < n; i++)
                       {
-                        if (re(i) > 127) {
-                          re(i) = '?';
-                          found_big_char = true;
-                        }
+                        if (re(i) > 127)
+                          {
+                            re(i) = '?';
+                            found_big_char = true;
+                          }
                       }
 
                     if (found_big_char)
                       warning ("load: can not read non-ASCII portions of UTF characters; replacing unreadable characters with '?'");
                   }
                 else if (type == miUTF8)
                   {
                     // Search for multi-byte encoded UTF8 characters and
@@ -1498,17 +1517,18 @@ read_mat5_binary_element (std::istream& 
                           utf8_multi_byte = true;
                       }
 
                     if (utf8_multi_byte)
                       {
                         warning ("load: can not read multi-byte encoded UTF8 characters; replacing unreadable characters with '?'");
                         for (octave_idx_type i = 0; i < n; i++)
                           {
-                            unsigned char a = static_cast<unsigned char> (re(i));
+                            unsigned char a
+                              = static_cast<unsigned char> (re(i));
                             if (a > 0x7f)
                               re(i) = '?';
                           }
                       }
                   }
                 tc = re;
                 tc = tc.convert_to_str (false, true, '\'');
               }
@@ -1520,22 +1540,22 @@ read_mat5_binary_element (std::istream& 
 
   is.seekg (pos + static_cast<std::streamoff> (element_length));
 
   if (is.eof ())
     is.clear ();
 
   return retval;
 
- data_read_error:
- early_read_error:
+data_read_error:
+early_read_error:
   error ("load: trouble reading binary file '%s'", filename.c_str ());
   return std::string ();
 
- skip_ahead:
+skip_ahead:
   warning ("skipping over '%s'", retval.c_str ());
   is.seekg (pos + static_cast<std::streamoff> (element_length));
   return read_mat5_binary_element (is, filename, swap, global, tc);
 }
 
 int
 read_mat5_binary_file_header (std::istream& is, bool& swap, bool quiet,
                               const std::string& filename)
@@ -1586,17 +1606,17 @@ read_mat5_binary_file_header (std::istre
       if (tc.is_uint8_type ())
         {
           const uint8NDArray itmp = tc.uint8_array_value ();
           octave_idx_type ilen = itmp.numel ();
 
           // Why should I have to initialize outbuf as just overwrite
           std::string outbuf (ilen - 7, ' ');
 
-          // FIXME -- find a way to avoid casting away const here
+          // FIXME: find a way to avoid casting away const here
           char *ctmp = const_cast<char *> (outbuf.c_str ());
           for (octave_idx_type j = 8; j < ilen; j++)
             ctmp[j-8] = itmp(j).char_value ();
 
           std::istringstream fh_ws (outbuf);
 
           read_mat5_binary_element (fh_ws, filename, swap, global, subsys_ov);
 
@@ -1628,17 +1648,17 @@ write_mat5_tag (std::ostream& is, int ty
       temp = bytes;
     }
 
   if (! is.write (reinterpret_cast<char *> (&temp), 4))
     goto data_write_error;
 
   return 0;
 
- data_write_error:
+data_write_error:
   return 1;
 }
 
 // Have to use copy here to avoid writing over data accessed via
 // Matrix::data().
 
 #define MAT5_DO_WRITE(TYPE, data, count, stream) \
   do \
@@ -1968,18 +1988,18 @@ save_mat5_array_length (const double* va
                 }
             }
 
           if (!too_large_for_float)
             size = 4;
         }
 
       // The code below is disabled since get_save_type currently doesn't
-      // deal with integer types. This will need to be activated if get_save_type
-      // is changed.
+      // deal with integer types.  This will need to be activated if
+      // get_save_type is changed.
 
       // double max_val = val[0];
       // double min_val = val[0];
       // bool all_integers =  true;
       //
       // for (int i = 0; i < nel; i++)
       //   {
       //     double val = val[i];
@@ -2023,18 +2043,18 @@ int
 save_mat5_array_length (const float* /* val */, octave_idx_type nel, bool)
 {
   if (nel > 0)
     {
       int size = 4;
 
 
       // The code below is disabled since get_save_type currently doesn't
-      // deal with integer types. This will need to be activated if get_save_type
-      // is changed.
+      // deal with integer types.  This will need to be activated if
+      // get_save_type is changed.
 
       // float max_val = val[0];
       // float min_val = val[0];
       // bool all_integers =  true;
       //
       // for (int i = 0; i < nel; i++)
       //   {
       //     float val = val[i];
@@ -2372,17 +2392,19 @@ save_mat5_binary_element (std::ostream& 
           // destLen must be at least 0.1% larger than source buffer
           // + 12 bytes. Reality is it must be larger again than that.
           std::string buf_str = buf.str ();
           uLongf srcLen = buf_str.length ();
           uLongf destLen = srcLen * 101 / 100 + 12;
           OCTAVE_LOCAL_BUFFER (char, out_buf, destLen);
 
           if (compress (reinterpret_cast<Bytef *> (out_buf), &destLen,
-                        reinterpret_cast<const Bytef *> (buf_str.c_str ()), srcLen) == Z_OK)
+                        reinterpret_cast<const Bytef *> (buf_str.c_str ()),
+                                                         srcLen)
+              == Z_OK)
             {
               write_mat5_tag (os, miCOMPRESSED,
                               static_cast<octave_idx_type> (destLen));
 
               os.write (out_buf, destLen);
             }
           else
             {
@@ -2662,18 +2684,19 @@ save_mat5_binary_element (std::ostream& 
           OCTAVE_LOCAL_BUFFER (char, paddedname, paddedlength);
           memset (paddedname, 0, paddedlength);
           strncpy (paddedname, classname.c_str (), namelen);
           os.write (paddedname, paddedlength);
         }
 
       octave_map m;
 
-      if (tc.is_object () &&
-          load_path::find_method (tc.class_name (), "saveobj") != std::string ())
+      if (tc.is_object ()
+          && load_path::find_method (tc.class_name (),
+                                     "saveobj") != std::string ())
         {
           octave_value_list tmp = feval ("saveobj", tc, 1);
           if (! error_state)
             m = tmp(0).map_value ();
           else
             goto error_cleanup;
         }
       else
@@ -2730,16 +2753,16 @@ save_mat5_binary_element (std::ostream& 
                   goto error_cleanup;
               }
           }
       }
     }
   else
     gripe_wrong_type_arg ("save", tc, false);
 
- skip_to_next:
+skip_to_next:
   return true;
 
- error_cleanup:
+error_cleanup:
   error ("save: error while writing '%s' to MAT file", name.c_str ());
 
   return false;
 }
diff --git a/libinterp/corefcn/ls-mat5.h b/libinterp/corefcn/ls-mat5.h
--- a/libinterp/corefcn/ls-mat5.h
+++ b/libinterp/corefcn/ls-mat5.h
@@ -19,36 +19,36 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_ls_mat5_h)
 #define octave_ls_mat5_h 1
 
 enum mat5_data_type
-  {
-    miINT8 = 1,                 // 8 bit signed
-    miUINT8,                    // 8 bit unsigned
-    miINT16,                    // 16 bit signed
-    miUINT16,                   // 16 bit unsigned
-    miINT32,                    // 32 bit signed
-    miUINT32,                   // 32 bit unsigned
-    miSINGLE,                   // IEEE 754 single precision float
-    miRESERVE1,
-    miDOUBLE,                   // IEEE 754 double precision float
-    miRESERVE2,
-    miRESERVE3,
-    miINT64,                    // 64 bit signed
-    miUINT64,                   // 64 bit unsigned
-    miMATRIX,                   // MATLAB array
-    miCOMPRESSED,               // Compressed data
-    miUTF8,                     // Unicode UTF-8 Encoded Character Data
-    miUTF16,                    // Unicode UTF-16 Encoded Character Data
-    miUTF32                     // Unicode UTF-32 Encoded Character Data
-  };
+{
+  miINT8 = 1,                 // 8 bit signed
+  miUINT8,                    // 8 bit unsigned
+  miINT16,                    // 16 bit signed
+  miUINT16,                   // 16 bit unsigned
+  miINT32,                    // 32 bit signed
+  miUINT32,                   // 32 bit unsigned
+  miSINGLE,                   // IEEE 754 single precision float
+  miRESERVE1,
+  miDOUBLE,                   // IEEE 754 double precision float
+  miRESERVE2,
+  miRESERVE3,
+  miINT64,                    // 64 bit signed
+  miUINT64,                   // 64 bit unsigned
+  miMATRIX,                   // MATLAB array
+  miCOMPRESSED,               // Compressed data
+  miUTF8,                     // Unicode UTF-8 Encoded Character Data
+  miUTF16,                    // Unicode UTF-16 Encoded Character Data
+  miUTF32                     // Unicode UTF-32 Encoded Character Data
+};
 
 extern int
 read_mat5_binary_file_header (std::istream& is, bool& swap,
                               bool quiet = false,
                               const std::string& filename = std::string ());
 extern std::string
 read_mat5_binary_element (std::istream& is, const std::string& filename,
                           bool swap, bool& global, octave_value& tc);
diff --git a/libinterp/corefcn/ls-oct-ascii.cc b/libinterp/corefcn/ls-oct-ascii.cc
--- a/libinterp/corefcn/ls-oct-ascii.cc
+++ b/libinterp/corefcn/ls-oct-ascii.cc
@@ -219,17 +219,17 @@ extract_keyword (std::istream& is, const
 //  is
 //  # length: 1
 //  a
 //  # length: 6
 //  string
 //  # length: 5
 //  array
 //
-// FIXME -- this format is fairly rigid, and doesn't allow for
+// FIXME: this format is fairly rigid, and doesn't allow for
 // arbitrary comments.  Someone should fix that. It does allow arbitrary
 // types however.
 
 // Ugh.  The signature of the compare method is not standard in older
 // versions of the GNU libstdc++.  Do this instead:
 
 #define SUBSTRING_COMPARE_EQ(s, pos, n, t) (s.substr (pos, n) == t)
 
@@ -301,17 +301,17 @@ read_ascii_data (std::istream& is, const
 // flag MARK_AS_GLOBAL on stream OS in the plain text format described
 // above for load_ascii_data.  If NAME is empty, the name: line is not
 // generated.  PRECISION specifies the number of decimal digits to print.
 //
 // Assumes ranges and strings cannot contain Inf or NaN values.
 //
 // Returns 1 for success and 0 for failure.
 
-// FIXME -- should probably write the help string here too.
+// FIXME: should probably write the help string here too.
 
 bool
 save_ascii_data (std::ostream& os, const octave_value& val_arg,
                  const std::string& name, bool mark_as_global,
                  int precision)
 {
   bool success = true;
 
@@ -411,17 +411,17 @@ save_three_d (std::ostream& os, const oc
       ::error ("for now, I can only save real matrices in 3-D format");
       fail = true;
     }
 
   return (os && ! fail);
 }
 
 DEFUN (save_precision, args, nargout,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} save_precision ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} save_precision (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} save_precision (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the number of\n\
 digits to keep when saving data in text format.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
diff --git a/libinterp/corefcn/lsode.cc b/libinterp/corefcn/lsode.cc
--- a/libinterp/corefcn/lsode.cc
+++ b/libinterp/corefcn/lsode.cc
@@ -152,17 +152,17 @@ lsode_user_jacobian (const ColumnVector&
   do \
     { \
       ::error ("lsode: " fmt, arg); \
       LSODE_ABORT (); \
     } \
   while (0)
 
 DEFUN (lsode, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{x}, @var{istate}, @var{msg}] =} lsode (@var{fcn}, @var{x_0}, @var{t})\n\
 @deftypefnx {Built-in Function} {[@var{x}, @var{istate}, @var{msg}] =} lsode (@var{fcn}, @var{x_0}, @var{t}, @var{t_crit})\n\
 Solve the set of differential equations\n\
 @tex\n\
 $$ {dx \\over dt} = f (x, t) $$\n\
 with\n\
 $$ x(t_0) = x_0 $$\n\
 @end tex\n\
@@ -305,32 +305,32 @@ parameters for @code{lsode}.\n\
               if (c(0).is_function_handle () || c(0).is_inline_function ())
                 lsode_fcn = c(0).function_value ();
               else
                 {
                   fcn_name = unique_symbol_name ("__lsode_fcn__");
                   fname = "function y = ";
                   fname.append (fcn_name);
                   fname.append (" (x, t) y = ");
-                  lsode_fcn = extract_function
-                    (c(0), "lsode", fcn_name, fname, "; endfunction");
+                  lsode_fcn = extract_function (c(0), "lsode", fcn_name, fname,
+                                                "; endfunction");
                 }
 
               if (lsode_fcn)
                 {
                   if (c(1).is_function_handle () || c(1).is_inline_function ())
                     lsode_jac = c(1).function_value ();
                   else
                     {
-                        jac_name = unique_symbol_name ("__lsode_jac__");
-                        jname = "function jac = ";
-                        jname.append (jac_name);
-                        jname.append (" (x, t) jac = ");
-                        lsode_jac = extract_function
-                          (c(1), "lsode", jac_name, jname, "; endfunction");
+                      jac_name = unique_symbol_name ("__lsode_jac__");
+                      jname = "function jac = ";
+                      jname.append (jac_name);
+                      jname.append (" (x, t) jac = ");
+                      lsode_jac = extract_function (c(1), "lsode", jac_name,
+                                                    jname, "; endfunction");
 
                       if (!lsode_jac)
                         {
                           if (fcn_name.length ())
                             clear_function (fcn_name);
                           lsode_fcn = 0;
                         }
                     }
@@ -350,59 +350,59 @@ parameters for @code{lsode}.\n\
                 {
                 case 1:
                   do
                     {
                       fcn_name = unique_symbol_name ("__lsode_fcn__");
                       fname = "function y = ";
                       fname.append (fcn_name);
                       fname.append (" (x, t) y = ");
-                      lsode_fcn = extract_function
-                        (f_arg, "lsode", fcn_name, fname, "; endfunction");
+                      lsode_fcn = extract_function (f_arg, "lsode", fcn_name,
+                                                    fname, "; endfunction");
                     }
                   while (0);
                   break;
 
                 case 2:
                   {
                     string_vector tmp = f_arg.all_strings ();
 
                     if (! error_state)
                       {
                         fcn_name = unique_symbol_name ("__lsode_fcn__");
                         fname = "function y = ";
                         fname.append (fcn_name);
                         fname.append (" (x, t) y = ");
-                        lsode_fcn = extract_function
-                          (tmp(0), "lsode", fcn_name, fname, "; endfunction");
+                        lsode_fcn = extract_function (tmp(0), "lsode", fcn_name,
+                                                      fname, "; endfunction");
 
                         if (lsode_fcn)
                           {
                             jac_name = unique_symbol_name ("__lsode_jac__");
                             jname = "function jac = ";
                             jname.append (jac_name);
                             jname.append (" (x, t) jac = ");
-                            lsode_jac = extract_function
-                              (tmp(1), "lsode", jac_name, jname,
-                              "; endfunction");
+                            lsode_jac = extract_function (tmp(1), "lsode",
+                                                          jac_name, jname,
+                                                          "; endfunction");
 
                             if (!lsode_jac)
                               {
                                 if (fcn_name.length ())
                                   clear_function (fcn_name);
                                 lsode_fcn = 0;
                               }
                           }
                       }
                   }
                   break;
 
                 default:
                   LSODE_ABORT1
-                    ("first arg should be a string or 2-element string array");
+                  ("first arg should be a string or 2-element string array");
                 }
             }
         }
 
       if (error_state || ! lsode_fcn)
         LSODE_ABORT ();
 
       ColumnVector state (args(1).vector_value ());
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -57,17 +57,17 @@ get_lu_u (const base_lu<MT>& fact)
   MT U = fact.U ();
   if (U.is_square () && fact.regular ())
     return octave_value (U, MatrixType (MatrixType::Upper));
   else
     return U;
 }
 
 DEFUN (lu, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{L}, @var{U}] =} lu (@var{A})\n\
 @deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}] =} lu (@var{A})\n\
 @deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} lu (@var{S})\n\
 @deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}, @var{Q}, @var{R}] =} lu (@var{S})\n\
 @deftypefnx {Built-in Function} {[@dots{}] =} lu (@var{S}, @var{thres})\n\
 @deftypefnx {Built-in Function} {@var{y} =} lu (@dots{})\n\
 @deftypefnx {Built-in Function} {[@dots{}] =} lu (@dots{}, \"vector\")\n\
 @cindex LU decomposition\n\
@@ -230,19 +230,19 @@ information.\n\
                   retval(0) = fact.Y ();
                 else
                   {
                     PermMatrix P = fact.Pr_mat ();
                     SparseMatrix L = P.transpose () * fact.L ();
                     retval(1) = octave_value (fact.U (),
                                               MatrixType (MatrixType::Upper));
 
-                    retval(0) = octave_value (L,
-                        MatrixType (MatrixType::Permuted_Lower,
-                                    nr, fact.row_perm ()));
+                    retval(0)
+                      = octave_value (L, MatrixType (MatrixType::Permuted_Lower,
+                                                     nr, fact.row_perm ()));
                   }
               }
               break;
 
             case 3:
               {
                 SparseLU fact (m, Qinit, thres, false, true);
 
@@ -300,19 +300,19 @@ information.\n\
                   retval(0) = fact.Y ();
                 else
                   {
                     PermMatrix P = fact.Pr_mat ();
                     SparseComplexMatrix L = P.transpose () * fact.L ();
                     retval(1) = octave_value (fact.U (),
                                               MatrixType (MatrixType::Upper));
 
-                    retval(0) = octave_value (L,
-                        MatrixType (MatrixType::Permuted_Lower,
-                                    nr, fact.row_perm ()));
+                    retval(0)
+                      = octave_value (L, MatrixType (MatrixType::Permuted_Lower,
+                                                     nr, fact.row_perm ()));
                   }
               }
               break;
 
             case 3:
               {
                 SparseComplexLU fact (m, Qinit, thres, false, true);
 
@@ -585,22 +585,22 @@ information.\n\
 */
 
 static
 bool check_lu_dims (const octave_value& l, const octave_value& u,
                     const octave_value& p)
 {
   octave_idx_type m = l.rows (), k = u.rows (), n = u.columns ();
   return ((l.ndims () == 2 && u.ndims () == 2 && k == l.columns ())
-            && k == std::min (m, n) &&
-            (p.is_undefined () || p.rows () == m));
+          && k == std::min (m, n) &&
+          (p.is_undefined () || p.rows () == m));
 }
 
 DEFUN (luupdate, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{L}, @var{U}] =} luupdate (@var{L}, @var{U}, @var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}] =} luupdate (@var{L}, @var{U}, @var{P}, @var{x}, @var{y})\n\
 Given an LU@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{L}*@var{U}}, @var{L}@tie{}lower unit trapezoidal and\n\
 @var{U}@tie{}upper trapezoidal, return the LU@tie{}factorization\n\
 of @w{@var{A} + @var{x}*@var{y}.'}, where @var{x} and @var{y} are\n\
 column vectors (rank-1 update) or matrices with equal number of columns\n\
 (rank-k update).\n\
diff --git a/libinterp/corefcn/luinc.cc b/libinterp/corefcn/luinc.cc
--- a/libinterp/corefcn/luinc.cc
+++ b/libinterp/corefcn/luinc.cc
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 
 #include "MatrixType.h"
 #include "SparseCmplxLU.h"
 #include "SparsedbleLU.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
 DEFUN (luinc, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, '0')\n\
 @deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, @var{droptol})\n\
 @deftypefnx {Built-in Function} {[@var{L}, @var{U}, @var{P}, @var{Q}] =} luinc (@var{A}, @var{opts})\n\
 @cindex LU decomposition\n\
 Produce the incomplete LU@tie{}factorization of the sparse matrix @var{A}.\n\
 Two types of incomplete factorization are possible, and the type\n\
 is determined by the second argument to @code{luinc}.\n\
 \n\
@@ -212,40 +212,44 @@ values of @var{p} @var{q} as vector valu
                       {
                         SparseLU fact (sm, Qinit, thresh, false, true, droptol,
                                        milu, udiag);
 
                         if (! error_state)
                           {
                             SparseMatrix P = fact.Pr ();
                             SparseMatrix L = P.transpose () * fact.L ();
-                            retval(1) = octave_value (fact.U (),
-                                                      MatrixType (MatrixType::Upper));
-                            retval(0) = octave_value (L, MatrixType
-                                                      (MatrixType::Permuted_Lower,
-                                                       sm_nr, fact.row_perm ()));
+                            retval(1)
+                              = octave_value (fact.U (),
+                                              MatrixType (MatrixType::Upper));
+                            retval(0)
+                              = octave_value (L, MatrixType
+                                                   (MatrixType::Permuted_Lower,
+                                                    sm_nr, fact.row_perm ()));
                           }
                       }
                       break;
 
                     case 3:
                       {
                         SparseLU fact (sm, Qinit, thresh, false, true, droptol,
                                        milu, udiag);
 
                         if (! error_state)
                           {
                             if (vecout)
                               retval(2) = fact.Pr_vec ();
                             else
                               retval(2) = fact.Pr_mat ();
-                            retval(1) = octave_value (fact.U (),
-                                                      MatrixType (MatrixType::Upper));
-                            retval(0) = octave_value (fact.L (),
-                                                      MatrixType (MatrixType::Lower));
+                            retval(1)
+                              = octave_value (fact.U (),
+                                              MatrixType (MatrixType::Upper));
+                            retval(0)
+                              = octave_value (fact.L (),
+                                              MatrixType (MatrixType::Lower));
                           }
                       }
                       break;
 
                     case 4:
                     default:
                       {
                         SparseLU fact (sm, Qinit, thresh, false, false, droptol,
@@ -258,20 +262,22 @@ values of @var{p} @var{q} as vector valu
                                 retval(3) = fact.Pc_vec ();
                                 retval(2) = fact.Pr_vec ();
                               }
                             else
                               {
                                 retval(3) = fact.Pc_mat ();
                                 retval(2) = fact.Pr_mat ();
                               }
-                            retval(1) = octave_value (fact.U (),
-                                                      MatrixType (MatrixType::Upper));
-                            retval(0) = octave_value (fact.L (),
-                                                      MatrixType (MatrixType::Lower));
+                            retval(1)
+                              = octave_value (fact.U (),
+                                              MatrixType (MatrixType::Upper));
+                            retval(0)
+                              = octave_value (fact.L (),
+                                              MatrixType (MatrixType::Lower));
                           }
                       }
                       break;
                     }
                 }
             }
           else if (args(0).type_name () == "sparse complex matrix")
             {
@@ -295,40 +301,44 @@ values of @var{p} @var{q} as vector valu
                         SparseComplexLU fact (sm, Qinit, thresh, false, true,
                                               droptol, milu, udiag);
 
 
                         if (! error_state)
                           {
                             SparseMatrix P = fact.Pr ();
                             SparseComplexMatrix L = P.transpose () * fact.L ();
-                            retval(1) = octave_value (fact.U (),
-                                                      MatrixType (MatrixType::Upper));
-                            retval(0) = octave_value (L, MatrixType
-                                                      (MatrixType::Permuted_Lower,
-                                                       sm_nr, fact.row_perm ()));
+                            retval(1)
+                              = octave_value (fact.U (),
+                                              MatrixType (MatrixType::Upper));
+                            retval(0)
+                              = octave_value (L, MatrixType
+                                                  (MatrixType::Permuted_Lower,
+                                                   sm_nr, fact.row_perm ()));
                           }
                       }
                       break;
 
                     case 3:
                       {
                         SparseComplexLU fact (sm, Qinit, thresh, false, true,
                                               droptol, milu, udiag);
 
                         if (! error_state)
                           {
                             if (vecout)
                               retval(2) = fact.Pr_vec ();
                             else
                               retval(2) = fact.Pr_mat ();
-                            retval(1) = octave_value (fact.U (),
-                                                      MatrixType (MatrixType::Upper));
-                            retval(0) = octave_value (fact.L (),
-                                                      MatrixType (MatrixType::Lower));
+                            retval(1)
+                              = octave_value (fact.U (),
+                                              MatrixType (MatrixType::Upper));
+                            retval(0)
+                              = octave_value (fact.L (),
+                                              MatrixType (MatrixType::Lower));
                           }
                       }
                       break;
 
                     case 4:
                     default:
                       {
                         SparseComplexLU fact (sm, Qinit, thresh, false, false,
@@ -341,20 +351,22 @@ values of @var{p} @var{q} as vector valu
                                 retval(3) = fact.Pc_vec ();
                                 retval(2) = fact.Pr_vec ();
                               }
                             else
                               {
                                 retval(3) = fact.Pc_mat ();
                                 retval(2) = fact.Pr_mat ();
                               }
-                            retval(1) = octave_value (fact.U (),
-                                                      MatrixType (MatrixType::Upper));
-                            retval(0) = octave_value (fact.L (),
-                                                      MatrixType (MatrixType::Lower));
+                            retval(1)
+                              = octave_value (fact.U (),
+                                              MatrixType (MatrixType::Upper));
+                            retval(0)
+                              = octave_value (fact.L (),
+                                              MatrixType (MatrixType::Lower));
                           }
                       }
                       break;
                     }
                 }
             }
           else
             error ("luinc: matrix A must be sparse");
diff --git a/libinterp/corefcn/mappers.cc b/libinterp/corefcn/mappers.cc
--- a/libinterp/corefcn/mappers.cc
+++ b/libinterp/corefcn/mappers.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 
 #include "defun.h"
 #include "error.h"
 #include "variables.h"
 
 DEFUN (abs, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} abs (@var{z})\n\
 Compute the magnitude of @var{z}, defined as\n\
 @tex\n\
 $|z| = \\sqrt{x^2 + y^2}$.\n\
 @end tex\n\
 @ifnottex\n\
 |@var{z}| = @code{sqrt (x^2 + y^2)}.\n\
 @end ifnottex\n\
@@ -79,17 +79,17 @@ abs (3 + 4i)\n\
 %!assert (abs (single (3-4i)), single (5))
 %!assert (abs (single ([1.1, 3i; 3+4i, -3-4i])), single ([1.1, 3; 5, 5]))
 
 %!error abs ()
 %!error abs (1, 2)
 */
 
 DEFUN (acos, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} acos (@var{x})\n\
 Compute the inverse cosine in radians for each element of @var{x}.\n\
 @seealso{cos, acosd}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).acos ();
@@ -114,17 +114,17 @@ Compute the inverse cosine in radians fo
 %! v = single ([0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi]);
 %! assert (acos (x), v, sqrt (eps ("single")));
 
 %!error acos ()
 %!error acos (1, 2)
 */
 
 DEFUN (acosh, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} acosh (@var{x})\n\
 Compute the inverse hyperbolic cosine for each element of @var{x}.\n\
 @seealso{cosh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).acosh ();
@@ -145,32 +145,32 @@ Compute the inverse hyperbolic cosine fo
 %! v = single ([0, pi/2*i, pi*i, pi/2*i]);
 %! assert (acosh (x), v, sqrt (eps ("single")));
 
 %!error acosh ()
 %!error acosh (1, 2)
 */
 
 DEFUN (angle, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} angle (@var{z})\n\
 See arg.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).arg ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (arg, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Mapping Function} {} arg (@var{z})\n\
 @deftypefnx {Mapping Function} {} angle (@var{z})\n\
 Compute the argument of @var{z}, defined as,\n\
 @tex\n\
 $\\theta = atan2 (y, x),$\n\
 @end tex\n\
 @ifnottex\n\
 @var{theta} = @code{atan2 (@var{y}, @var{x})},\n\
@@ -215,17 +215,17 @@ arg (3 + 4i)\n\
 %!assert (arg (single (-i)), single (-pi/2))
 %!assert (arg (single ([1, i; -1, -i])), single ([0, pi/2; pi, -pi/2]), 2e1*eps ("single"))
 
 %!error arg ()
 %!error arg (1, 2)
 */
 
 DEFUN (asin, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} asin (@var{x})\n\
 Compute the inverse sine in radians for each element of @var{x}.\n\
 @seealso{sin, asind}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).asin ();
@@ -243,17 +243,17 @@ Compute the inverse sine in radians for 
 %! v = [0, pi/6, pi/4, pi/3, pi/2, pi/3, pi/4, pi/6, 0];
 %! assert (all (abs (asin (x) - v) < sqrt (eps)));
 
 %!error asin ()
 %!error asin (1, 2)
 */
 
 DEFUN (asinh, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} asinh (@var{x})\n\
 Compute the inverse hyperbolic sine for each element of @var{x}.\n\
 @seealso{sinh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).asinh ();
@@ -274,17 +274,17 @@ Compute the inverse hyperbolic sine for 
 %! x = single ([0, i, 0, -i]);
 %! assert (asinh (x), v,  sqrt (eps ("single")));
 
 %!error asinh ()
 %!error asinh (1, 2)
 */
 
 DEFUN (atan, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atan (@var{x})\n\
 Compute the inverse tangent in radians for each element of @var{x}.\n\
 @seealso{tan, atand}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).atan ();
@@ -309,17 +309,17 @@ Compute the inverse tangent in radians f
 %! x = single ([0, rt3/3, 1, rt3, -rt3, -1, -rt3/3, 0]);
 %! assert (atan (x), v, sqrt (eps ("single")));
 
 %!error atan ()
 %!error atan (1, 2)
 */
 
 DEFUN (atanh, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atanh (@var{x})\n\
 Compute the inverse hyperbolic tangent for each element of @var{x}.\n\
 @seealso{tanh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).atanh ();
@@ -340,17 +340,17 @@ Compute the inverse hyperbolic tangent f
 %! x = single ([0, 0]);
 %! assert (atanh (x), v, sqrt (eps ("single")));
 
 %!error atanh ()
 %!error atanh (1, 2)
 */
 
 DEFUN (cbrt, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} cbrt (@var{x})\n\
 Compute the real cube root of each element of @var{x}.\n\
 Unlike @code{@var{x}^(1/3)}, the result will be negative if @var{x} is\n\
 negative.\n\
 @seealso{nthroot}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -372,17 +372,17 @@ negative.\n\
 %!assert (cbrt (2^300), 2^100)
 %!assert (cbrt (125*2^300), 5*2^100)
 
 %!error cbrt ()
 %!error cbrt (1, 2)
 */
 
 DEFUN (ceil, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} ceil (@var{x})\n\
 Return the smallest integer not less than @var{x}.  This is equivalent to\n\
 rounding towards positive infinity.  If @var{x} is\n\
 complex, return @code{ceil (real (@var{x})) + ceil (imag (@var{x})) * I}.\n\
 \n\
 @example\n\
 @group\n\
 ceil ([-2.7, 2.7])\n\
@@ -414,17 +414,17 @@ ceil ([-2.7, 2.7])\n\
 ## complex single precision
 %!assert (ceil (single ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i])), single ([2+2i, 2+2i, -1-i, -1-i]))
 
 %!error ceil ()
 %!error ceil (1, 2)
 */
 
 DEFUN (conj, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} conj (@var{z})\n\
 Return the complex conjugate of @var{z}, defined as\n\
 @tex\n\
 $\\bar{z} = x - iy$.\n\
 @end tex\n\
 @ifnottex\n\
 @code{conj (@var{z})} = @var{x} - @var{i}@var{y}.\n\
 @end ifnottex\n\
@@ -453,17 +453,17 @@ Return the complex conjugate of @var{z},
 %!assert (conj (single (1-i)), single (1+i))
 %!assert (conj (single ([-1, -i; -1+i, -1-i])), single ([-1, i; -1-i, -1+i]))
 
 %!error conj ()
 %!error conj (1, 2)
 */
 
 DEFUN (cos, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} cos (@var{x})\n\
 Compute the cosine for each element of @var{x} in radians.\n\
 @seealso{acos, cosd, cosh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).cos ();
@@ -490,17 +490,17 @@ Compute the cosine for each element of @
 %! v = single ([1, rt3/2, rt2/2, 1/2, 0, -1/2, -rt2/2, -rt3/2, -1]);
 %! assert (cos (x), v, sqrt (eps ("single")));
 
 %!error cos ()
 %!error cos (1, 2)
 */
 
 DEFUN (cosh, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} cosh (@var{x})\n\
 Compute the hyperbolic cosine for each element of @var{x}.\n\
 @seealso{acosh, sinh, tanh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).cosh ();
@@ -521,17 +521,17 @@ Compute the hyperbolic cosine for each e
 %! v = single ([1, 0, -1, 0]);
 %! assert (cosh (x), v, sqrt (eps ("single")));
 
 %!error cosh ()
 %!error cosh (1, 2)
 */
 
 DEFUN (erf, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erf (@var{z})\n\
 Compute the error function,\n\
 @tex\n\
 $$\n\
  {\\rm erf} (z) = {2 \\over \\sqrt{\\pi}}\\int_0^z e^{-t^2} dt\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
@@ -591,17 +591,17 @@ erf (z) = --------- *  | e^(-t^2) dt\n\
 %! assert (erf (-x), -v, -1.e-10);
 %! assert (erfc (x), 1-v, -1.e-10);
 
 %!error erf ()
 %!error erf (1, 2)
 */
 
 DEFUN (erfinv, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erfinv (@var{x})\n\
 Compute the inverse error function, i.e., @var{y} such that\n\
 \n\
 @example\n\
 erf (@var{y}) == @var{x}\n\
 @end example\n\
 @seealso{erf, erfc, erfcx, erfi, dawson, erfcinv}\n\
 @end deftypefn")
@@ -629,17 +629,17 @@ erf (@var{y}) == @var{x}\n\
 %!assert (erfinv ([-1, 1, 1.1, -2.1]), [-Inf, Inf, NaN, NaN])
 %!error erfinv (1+2i)
 
 %!error erfinv ()
 %!error erfinv (1, 2)
 */
 
 DEFUN (erfcinv, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erfcinv (@var{x})\n\
 Compute the inverse complementary error function, i.e., @var{y} such that\n\
 \n\
 @example\n\
 erfc (@var{y}) == @var{x}\n\
 @end example\n\
 @seealso{erfc, erf, erfcx, erfi, dawson, erfinv}\n\
 @end deftypefn")
@@ -667,17 +667,17 @@ erfc (@var{y}) == @var{x}\n\
 %!assert (erfcinv ([2, 0, -0.1, 2.1]), [-Inf, Inf, NaN, NaN])
 %!error erfcinv (1+2i)
 
 %!error erfcinv ()
 %!error erfcinv (1, 2)
 */
 
 DEFUN (erfc, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erfc (@var{z})\n\
 Compute the complementary error function,\n\
 @tex\n\
 $1 - {\\rm erf} (z)$.\n\
 @end tex\n\
 @ifnottex\n\
 @w{@code{1 - erf (@var{z})}}.\n\
 @end ifnottex\n\
@@ -698,17 +698,17 @@ Compute the complementary error function
 %! a = -1i*sqrt (-1/(6.4187*6.4187));
 %! assert (erfc (a), erfc (real (a)));
 
 %!error erfc ()
 %!error erfc (1, 2)
 */
 
 DEFUN (erfcx, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erfcx (@var{z})\n\
 Compute the scaled complementary error function,\n\
 @tex\n\
 $$\n\
  e^{z^2} {\\rm erfc} (z) \\equiv e^{z^2} (1 - {\\rm erf} (z))\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
@@ -741,17 +741,17 @@ exp (z^2) * erfc (z)\n\
 %! v = [0.0056416137829894329, 0.0054246791754558-0.00108483153786434i];
 %! assert (erfcx (x), v, -1.e-10);
 
 %!error erfcx ()
 %!error erfcx (1, 2)
 */
 
 DEFUN (erfi, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erfi (@var{z})\n\
 Compute the imaginary error function,\n\
 @tex\n\
 $$\n\
  -i {\\rm erf} (iz) \n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
@@ -779,17 +779,17 @@ Compute the imaginary error function,\n\
 %! x = [-0.1, 0.1, 1, 1+2i,-1+2i,1e-6+2e-6i,0+2i];
 %! assert (erfi (x), -i * erf(i*x), -1.e-10);
 
 %!error erfi ()
 %!error erfi (1, 2)
 */
 
 DEFUN (dawson, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} dawson (@var{z})\n\
 Compute the Dawson (scaled imaginary error) function,\n\
 @tex\n\
 $$\n\
  {\\sqrt{\\pi} \\over 2} e^{-z^2} {\\rm erfi} (z) \\equiv -i {\\sqrt{\\pi} \\over 2} e^{-z^2} {\\rm erf} (iz)\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
@@ -819,17 +819,17 @@ Compute the Dawson (scaled imaginary err
 %! assert (dawson (x), v, -1.e-10);
 %! assert (dawson (-x), -v, -1.e-10);
 
 %!error dawson ()
 %!error dawson (1, 2)
 */
 
 DEFUN (exp, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} exp (@var{x})\n\
 Compute\n\
 @tex\n\
 $e^{x}$\n\
 @end tex\n\
 @ifnottex\n\
 @code{e^x}\n\
 @end ifnottex\n\
@@ -856,17 +856,17 @@ exponential, see @ref{Linear Algebra}.\n
 %!assert (exp ([Inf, -Inf, NaN]), [Inf 0 NaN])
 %!assert (exp (single ([Inf, -Inf, NaN])), single ([Inf 0 NaN]))
 
 %!error exp ()
 %!error exp (1, 2)
 */
 
 DEFUN (expm1, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} expm1 (@var{x})\n\
 Compute\n\
 @tex\n\
 $ e^{x} - 1 $\n\
 @end tex\n\
 @ifnottex\n\
 @code{exp (@var{x}) - 1}\n\
 @end ifnottex\n\
@@ -889,17 +889,17 @@ accurately in the neighborhood of zero.\
 %!assert (expm1 ([Inf, -Inf, NaN]), [Inf -1 NaN])
 %!assert (expm1 (single ([Inf, -Inf, NaN])), single ([Inf -1 NaN]))
 
 %!error expm1 ()
 %!error expm1 (1, 2)
 */
 
 DEFUN (isfinite, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Mapping Function} {} isfinite (@var{x})\n\
 @deftypefnx {Mapping Function} {} finite (@var{x})\n\
 Return a logical array which is true where the elements of @var{x} are\n\
 finite values and false where they are not.\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
@@ -928,17 +928,17 @@ finite ([13, Inf, NA, NaN])\n\
 %!assert (!finite (single (NaN)))
 %!assert (finite (single (rand (1,10))))
 
 %!error finite ()
 %!error finite (1, 2)
 */
 
 DEFUN (fix, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} fix (@var{x})\n\
 Truncate fractional portion of @var{x} and return the integer portion.  This\n\
 is equivalent to rounding towards zero.  If @var{x} is complex, return\n\
 @code{fix (real (@var{x})) + fix (imag (@var{x})) * I}.\n\
 \n\
 @example\n\
 @group\n\
 fix ([-2.7, 2.7])\n\
@@ -963,17 +963,17 @@ fix ([-2.7, 2.7])\n\
 %!assert (fix (single ([1.1, 1, -1.1, -1])), single ([1, 1, -1, -1]))
 %!assert (fix (single ([1.1+1.1i, 1+i, -1.1-1.1i, -1-i])), single ([1+i, 1+i, -1-i, -1-i]))
 
 %!error fix ()
 %!error fix (1, 2)
 */
 
 DEFUN (floor, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} floor (@var{x})\n\
 Return the largest integer not greater than @var{x}.  This is equivalent to\n\
 rounding towards negative infinity.  If @var{x} is\n\
 complex, return @code{floor (real (@var{x})) + floor (imag (@var{x})) * I}.\n\
 \n\
 @example\n\
 @group\n\
 floor ([-2.7, 2.7])\n\
@@ -998,17 +998,17 @@ floor ([-2.7, 2.7])\n\
 %!assert (floor (single ([2, 1.1, -1.1, -1])), single ([2, 1, -2, -1]))
 %!assert (floor (single ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i])), single ([2+2i, 1+i, -2-2i, -1-i]))
 
 %!error floor ()
 %!error floor (1, 2)
 */
 
 DEFUN (gamma, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} gamma (@var{z})\n\
 Compute the Gamma function,\n\
 @tex\n\
 $$\n\
  \\Gamma (z) = \\int_0^\\infty t^{z-1} e^{-t} dt.\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
@@ -1062,17 +1062,17 @@ gamma (z) = | t^(z-1) exp (-t) dt.\n\
 %! assert (gamma (x), v);
 %! assert (gamma (single (x)), single (v));
 
 %!error gamma ()
 %!error gamma (1, 2)
 */
 
 DEFUN (imag, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} imag (@var{z})\n\
 Return the imaginary part of @var{z} as a real number.\n\
 @seealso{real, conj}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).imag ();
@@ -1093,17 +1093,17 @@ Return the imaginary part of @var{z} as 
 %!assert (imag (single (1+i)), single (1))
 %!assert (imag (single ([i, 1; 1, i])), full (eye (2,"single")))
 
 %!error imag ()
 %!error imag (1, 2)
 */
 
 DEFUNX ("isalnum", Fisalnum, args, ,
-    "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isalnum (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 letters or digits and false where they are not.  This is equivalent to\n\
 (@code{isalpha (@var{s}) | isdigit (@var{s})}).\n\
 @seealso{isalpha, isdigit, ispunct, isspace, iscntrl}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -1124,17 +1124,17 @@ letters or digits and false where they a
 %! result(toascii ("a":"z") + 1) = true;
 %! assert (isalnum (charset), result);
 
 %!error isalnum ()
 %!error isalnum (1, 2)
 */
 
 DEFUNX ("isalpha", Fisalpha, args, ,
-    "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isalpha (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 letters and false where they are not.  This is equivalent to\n\
 (@code{islower (@var{s}) | isupper (@var{s})}).\n\
 @seealso{isdigit, ispunct, isspace, iscntrl, isalnum, islower, isupper}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -1154,17 +1154,17 @@ letters and false where they are not.  T
 %! result(toascii ("a":"z") + 1) = true;
 %! assert (isalpha (charset), result);
 
 %!error isalpha ()
 %!error isalpha (1, 2)
 */
 
 DEFUNX ("isascii", Fisascii, args, ,
-    "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isascii (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 ASCII characters (in the range 0 to 127 decimal) and false where they are\n\
 not.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
@@ -1181,17 +1181,17 @@ not.\n\
 %! result = true (1, 128);
 %! assert (isascii (charset), result);
 
 %!error isascii ()
 %!error isascii (1, 2)
 */
 
 DEFUNX ("iscntrl", Fiscntrl, args, ,
-    "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} iscntrl (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 control characters and false where they are not.\n\
 @seealso{ispunct, isspace, isalpha, isdigit}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
@@ -1210,17 +1210,17 @@ control characters and false where they 
 %! result(128) = true;
 %! assert (iscntrl (charset), result);
 
 %!error iscntrl ()
 %!error iscntrl (1, 2)
 */
 
 DEFUNX ("isdigit", Fisdigit, args, ,
-    "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isdigit (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 decimal digits (0-9) and false where they are not.\n\
 @seealso{isxdigit, isalpha, isletter, ispunct, isspace, iscntrl}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
@@ -1238,17 +1238,17 @@ decimal digits (0-9) and false where the
 %! result(toascii ("0":"9") + 1) = true;
 %! assert (isdigit (charset), result);
 
 %!error isdigit ()
 %!error isdigit (1, 2)
 */
 
 DEFUN (isinf, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isinf (@var{x})\n\
 Return a logical array which is true where the elements of @var{x} are\n\
 are infinite and false where they are not.\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 isinf ([13, Inf, NA, NaN])\n\
@@ -1280,17 +1280,17 @@ isinf ([13, Inf, NA, NaN])\n\
 %!assert (isinf (single (rand (1,10))), false (1,10))
 %!assert (isinf (single ([NaN -Inf -1 0 1 Inf NA])), [false, true, false, false, false, true, false])
 
 %!error isinf ()
 %!error isinf (1, 2)
 */
 
 DEFUNX ("isgraph", Fisgraph, args, ,
-    "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isgraph (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 printable characters (but not the space character) and false where they are\n\
 not.\n\
 @seealso{isprint}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -1309,17 +1309,17 @@ not.\n\
 %! result(34:127) = true;
 %! assert (isgraph (charset), result);
 
 %!error isgraph ()
 %!error isgraph (1, 2)
 */
 
 DEFUNX ("islower", Fislower, args, ,
-    "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} islower (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 lowercase letters and false where they are not.\n\
 @seealso{isupper, isalpha, isletter, isalnum}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
@@ -1337,17 +1337,17 @@ lowercase letters and false where they a
 %! result(toascii ("a":"z") + 1) = true;
 %! assert (islower (charset), result);
 
 %!error islower ()
 %!error islower (1, 2)
 */
 
 DEFUN (isna, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isna (@var{x})\n\
 Return a logical array which is true where the elements of @var{x} are\n\
 NA (missing) values and false where they are not.\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 isna ([13, Inf, NA, NaN])\n\
@@ -1379,17 +1379,17 @@ isna ([13, Inf, NA, NaN])\n\
 %!assert (isna (single (rand (1,10))), false (1,10))
 %!assert (isna (single ([NaN -Inf -1 0 1 Inf NA])), [false, false, false, false, false, false, true])
 
 %!error isna ()
 %!error isna (1, 2)
 */
 
 DEFUN (isnan, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isnan (@var{x})\n\
 Return a logical array which is true where the elements of @var{x} are\n\
 NaN values and false where they are not.\n\
 NA values are also considered NaN values.  For example:\n\
 \n\
 @example\n\
 @group\n\
 isnan ([13, Inf, NA, NaN])\n\
@@ -1421,17 +1421,17 @@ isnan ([13, Inf, NA, NaN])\n\
 %!assert (isnan (single (rand (1,10))), false (1,10))
 %!assert (isnan (single ([NaN -Inf -1 0 1 Inf NA])), [true, false, false, false, false, false, true])
 
 %!error isnan ()
 %!error isnan (1, 2)
 */
 
 DEFUNX ("isprint", Fisprint, args, ,
-    "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isprint (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 printable characters (including the space character) and false where they\n\
 are not.\n\
 @seealso{isgraph}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -1450,17 +1450,17 @@ are not.\n\
 %! result(33:127) = true;
 %! assert (isprint (charset), result);
 
 %!error isprint ()
 %!error isprint (1, 2)
 */
 
 DEFUNX ("ispunct", Fispunct, args, ,
-    "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} ispunct (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 punctuation characters and false where they are not.\n\
 @seealso{isalpha, isdigit, isspace, iscntrl}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
@@ -1481,17 +1481,17 @@ punctuation characters and false where t
 %! result(124:127) = true;
 %! assert (ispunct (charset), result);
 
 %!error ispunct ()
 %!error ispunct (1, 2)
 */
 
 DEFUNX ("isspace", Fisspace, args, ,
-    "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isspace (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 whitespace characters (space, formfeed, newline, carriage return, tab, and\n\
 vertical tab) and false where they are not.\n\
 @seealso{iscntrl, ispunct, isalpha, isdigit}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -1510,17 +1510,17 @@ vertical tab) and false where they are n
 %! result(toascii (" \f\n\r\t\v") + 1) = true;
 %! assert (isspace (charset), result);
 
 %!error isspace ()
 %!error isspace (1, 2)
 */
 
 DEFUNX ("isupper", Fisupper, args, ,
-    "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isupper (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 uppercase letters and false where they are not.\n\
 @seealso{islower, isalpha, isletter, isalnum}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
@@ -1538,17 +1538,17 @@ uppercase letters and false where they a
 %! result(toascii ("A":"Z") + 1) = true;
 %! assert (isupper (charset), result);
 
 %!error isupper ()
 %!error isupper (1, 2)
 */
 
 DEFUNX ("isxdigit", Fisxdigit, args, ,
-    "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isxdigit (@var{s})\n\
 Return a logical array which is true where the elements of @var{s} are\n\
 hexadecimal digits (0-9 and @nospell{a-fA-F}).\n\
 @seealso{isdigit}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
@@ -1568,17 +1568,17 @@ hexadecimal digits (0-9 and @nospell{a-f
 %! result(toascii ("a":"f") + 1) = true;
 %! assert (isxdigit (charset), result);
 
 %!error isxdigit ()
 %!error isxdigit (1, 2)
 */
 
 DEFUN (lgamma, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Mapping Function} {} lgamma (@var{x})\n\
 @deftypefnx {Mapping Function} {} gammaln (@var{x})\n\
 Return the natural logarithm of the gamma function of @var{x}.\n\
 @seealso{gamma, gammainc}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
@@ -1614,17 +1614,17 @@ Return the natural logarithm of the gamm
 %! assert (lgamma (x), v);
 %! assert (lgamma (single (x)), single (v));
 
 %!error lgamma ()
 %!error lgamma (1,2)
 */
 
 DEFUN (log, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log (@var{x})\n\
 Compute the natural logarithm,\n\
 @tex\n\
 $\\ln{(x)},$\n\
 @end tex\n\
 @ifnottex\n\
 @code{ln (@var{x})},\n\
 @end ifnottex\n\
@@ -1649,17 +1649,17 @@ matrix logarithm, see @ref{Linear Algebr
 %!assert (log (single ([1, e, e^2])), single ([0, 1, 2]), sqrt (eps ("single")))
 %!assert (log (single ([-0.5, -1.5, -2.5])), single (log ([0.5, 1.5, 2.5]) + pi*1i), 4*eps ("single"))
 
 %!error log ()
 %!error log (1, 2)
 */
 
 DEFUN (log10, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log10 (@var{x})\n\
 Compute the base-10 logarithm of each element of @var{x}.\n\
 @seealso{log, log2, logspace, exp}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).log10 ();
@@ -1673,17 +1673,17 @@ Compute the base-10 logarithm of each el
 %!assert (log10 ([0.01, 0.1, 1, 10, 100]), [-2, -1, 0, 1, 2], sqrt (eps))
 %!assert (log10 (single ([0.01, 0.1, 1, 10, 100])), single ([-2, -1, 0, 1, 2]), sqrt (eps ("single")))
 
 %!error log10 ()
 %!error log10 (1, 2)
 */
 
 DEFUN (log1p, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log1p (@var{x})\n\
 Compute\n\
 @tex\n\
 $\\ln{(1 + x)}$\n\
 @end tex\n\
 @ifnottex\n\
 @code{log (1 + @var{x})}\n\
 @end ifnottex\n\
@@ -1704,17 +1704,17 @@ accurately in the neighborhood of zero.\
 %!assert (log1p ([0, 2*eps, -2*eps]), [0, 2*eps, -2*eps], 1e-29)
 %!assert (log1p (single ([0, 2*eps, -2*eps])), single ([0, 2*eps, -2*eps]), 1e-29)
 
 %!error log1p ()
 %!error log1p (1, 2)
 */
 
 DEFUN (real, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} real (@var{z})\n\
 Return the real part of @var{z}.\n\
 @seealso{imag, conj}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).real ();
@@ -1735,17 +1735,17 @@ Return the real part of @var{z}.\n\
 %!assert (real (single (1+i)), single (1))
 %!assert (real (single ([1, i; i, 1])), full (eye (2,"single")))
 
 %!error real ()
 %!error real (1, 2)
 */
 
 DEFUN (round, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} round (@var{x})\n\
 Return the integer nearest to @var{x}.  If @var{x} is complex, return\n\
 @code{round (real (@var{x})) + round (imag (@var{x})) * I}.  If there\n\
 are two nearest integers, return the one further away from zero.\n\
 \n\
 @example\n\
 @group\n\
 round ([-2.7, 2.7])\n\
@@ -1781,17 +1781,17 @@ round ([-2.7, 2.7])\n\
 %!assert (round (single (-2.6)), single (-3))
 %!assert (round (single ([1.1, -2.4; -3.7, 7.1])), single ([1, -2; -4, 7]))
 
 %!error round ()
 %!error round (1, 2)
 */
 
 DEFUN (roundb, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} roundb (@var{x})\n\
 Return the integer nearest to @var{x}.  If there are two nearest\n\
 integers, return the even one (banker's rounding).  If @var{x} is complex,\n\
 return @code{roundb (real (@var{x})) + roundb (imag (@var{x})) * I}.\n\
 @seealso{round}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -1822,17 +1822,17 @@ return @code{roundb (real (@var{x})) + r
 %!assert (roundb (single (-2.6)), single (-3))
 %!assert (roundb (single ([1.1, -2.4; -3.7, 7.1])), single ([1, -2; -4, 7]))
 
 %!error roundb ()
 %!error roundb (1, 2)
 */
 
 DEFUN (sign, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sign (@var{x})\n\
 Compute the @dfn{signum} function, which is defined as\n\
 @tex\n\
 $$\n\
 {\\rm sign} (@var{x}) = \\cases{1,&$x>0$;\\cr 0,&$x=0$;\\cr -1,&$x<0$.\\cr}\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
@@ -1876,33 +1876,35 @@ whether zero is signed, use the @code{si
 %!assert (sign (single (3)), single (1))
 %!assert (sign (single ([1, -pi; e, 0])), single ([1, -1; 1, 0]))
 
 %!error sign ()
 %!error sign (1, 2)
 */
 
 DEFUNX ("signbit", Fsignbit, args, ,
-    "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} signbit (@var{x})\n\
 Return logical true if the value of @var{x} has its sign bit set.\n\
 Otherwise return logical false.  This behavior is consistent with the other\n\
 logical functions.  See@ref{Logical Values}.  The behavior differs from the\n\
 C language function which returns non-zero if the sign bit is set.\n\
 \n\
 This is not the same as @code{x < 0.0}, because IEEE 754 floating point\n\
 allows zero to be signed.  The comparison @code{-0.0 < 0.0} is false,\n\
 but @code{signbit (-0.0)} will return a nonzero value.\n\
 @seealso{sign}\n\
 @end deftypefn")
 {
   octave_value retval;
-  if (args.length () == 1) {
-    retval = args(0).xsignbit ();
-    retval = (retval != 0); }
+  if (args.length () == 1)
+    {
+      retval = args(0).xsignbit ();
+      retval = (retval != 0);
+    }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!assert (signbit (1) == 0)
@@ -1915,17 +1917,17 @@ but @code{signbit (-0.0)} will return a 
 %!assert (signbit (single (0)) == 0)
 %!assert (signbit (single (-0)) != 0)
 
 %!error sign ()
 %!error sign (1, 2)
 */
 
 DEFUN (sin, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sin (@var{x})\n\
 Compute the sine for each element of @var{x} in radians.\n\
 @seealso{asin, sind, sinh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).sin ();
@@ -1950,17 +1952,17 @@ Compute the sine for each element of @va
 %! v = single ([0, 1/2, rt2/2, rt3/2, 1, rt3/2, rt2/2, 1/2, 0]);
 %! assert (sin (x), v, sqrt (eps ("single")));
 
 %!error sin ()
 %!error sin (1, 2)
 */
 
 DEFUN (sinh, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sinh (@var{x})\n\
 Compute the hyperbolic sine for each element of @var{x}.\n\
 @seealso{asinh, cosh, tanh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).sinh ();
@@ -1981,17 +1983,17 @@ Compute the hyperbolic sine for each ele
 %! v = single ([0, i, 0, -i]);
 %! assert (sinh (x), v, sqrt (eps ("single")));
 
 %!error sinh ()
 %!error sinh (1, 2)
 */
 
 DEFUN (sqrt, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sqrt (@var{x})\n\
 Compute the square root of each element of @var{x}.  If @var{x} is negative,\n\
 a complex result is returned.  To compute the matrix square root, see\n\
 @ref{Linear Algebra}.\n\
 @seealso{realsqrt, nthroot}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -2014,17 +2016,17 @@ a complex result is returned.  To comput
 %!assert (sqrt (single (1+i)), single (exp (0.5 * log (1+i))), sqrt (eps ("single")))
 %!assert (sqrt (single ([4, -4; i, 1-i])), single ([2, 2i; exp(0.5 * log (i)), exp(0.5 * log (1-i))]), sqrt (eps ("single")))
 
 %!error sqrt ()
 %!error sqrt (1, 2)
 */
 
 DEFUN (tan, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} tan (@var{z})\n\
 Compute the tangent for each element of @var{x} in radians.\n\
 @seealso{atan, tand, tanh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).tan ();
@@ -2049,17 +2051,17 @@ Compute the tangent for each element of 
 %! v = single ([0, rt3/3, 1, rt3, -rt3, -1, -rt3/3, 0]);
 %! assert (tan (x), v,  sqrt (eps ("single")));
 
 %!error tan ()
 %!error tan (1, 2)
 */
 
 DEFUN (tanh, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} tanh (@var{x})\n\
 Compute hyperbolic tangent for each element of @var{x}.\n\
 @seealso{atanh, sinh, cosh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).tanh ();
@@ -2080,17 +2082,17 @@ Compute hyperbolic tangent for each elem
 %! v = single ([0, 0]);
 %! assert (tanh (x), v, sqrt (eps ("single")));
 
 %!error tanh ()
 %!error tanh (1, 2)
 */
 
 DEFUNX ("toascii", Ftoascii, args, ,
-    "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} toascii (@var{s})\n\
 Return ASCII representation of @var{s} in a matrix.  For example:\n\
 \n\
 @example\n\
 @group\n\
 toascii (\"ASCII\")\n\
      @result{} [ 65, 83, 67, 73, 73 ]\n\
 @end group\n\
@@ -2116,17 +2118,17 @@ toascii (\"ASCII\")\n\
 %!assert (toascii ("a":"z"), 97:122)
 %!assert (toascii ("{":"~"), 123:126)
 
 %!error toascii ()
 %!error toascii (1, 2)
 */
 
 DEFUNX ("tolower", Ftolower, args, ,
-    "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn  {Mapping Function} {} tolower (@var{s})\n\
 @deftypefnx {Mapping Function} {} lower (@var{s})\n\
 Return a copy of the string or cell string @var{s}, with each uppercase\n\
 character replaced by the corresponding lowercase one; non-alphabetic\n\
 characters are left unchanged.  For example:\n\
 \n\
 @example\n\
 @group\n\
@@ -2167,17 +2169,17 @@ DEFALIAS (lower, tolower);
 %! assert (tolower (charset), result);
 
 %!error <Invalid call to tolower> lower ()
 %!error <Invalid call to tolower> tolower ()
 %!error tolower (1, 2)
 */
 
 DEFUNX ("toupper", Ftoupper, args, ,
-    "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn  {Mapping Function} {} toupper (@var{s})\n\
 @deftypefnx {Mapping Function} {} upper (@var{s})\n\
 Return a copy of the string or cell string @var{s}, with each lowercase\n\
 character replaced by the corresponding uppercase one; non-alphabetic\n\
 characters are left unchanged.  For example:\n\
 \n\
 @example\n\
 @group\n\
diff --git a/libinterp/corefcn/matrix_type.cc b/libinterp/corefcn/matrix_type.cc
--- a/libinterp/corefcn/matrix_type.cc
+++ b/libinterp/corefcn/matrix_type.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "ov-re-mat.h"
 #include "ov-cx-mat.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "MatrixType.h"
 #include "oct-locbuf.h"
 
 DEFUN (matrix_type, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{type} =} matrix_type (@var{A})\n\
 @deftypefnx {Built-in Function} {@var{type} =} matrix_type (@var{A}, \"nocompute\")\n\
 @deftypefnx {Built-in Function} {@var{A} =} matrix_type (@var{A}, @var{type})\n\
 @deftypefnx {Built-in Function} {@var{A} =} matrix_type (@var{A}, \"upper\", @var{perm})\n\
 @deftypefnx {Built-in Function} {@var{A} =} matrix_type (@var{A}, \"lower\", @var{perm})\n\
 @deftypefnx {Built-in Function} {@var{A} =} matrix_type (@var{A}, \"banded\", @var{nl}, @var{nu})\n\
 Identify the matrix type or mark a matrix as a particular type.  This allows\n\
 more rapid solutions of linear equations involving @var{A} to be performed.\n\
@@ -119,17 +119,18 @@ LU@tie{}factorization.  Once the matrix 
 
   if (nargin == 0)
     print_usage ();
   else if (nargin > 4)
     error ("matrix_type: incorrect number of arguments");
   else
     {
       bool autocomp = true;
-      if (nargin == 2 && args(1).is_string () && args(1).string_value () == "nocompute")
+      if (nargin == 2 && args(1).is_string ()
+          && args(1).string_value () == "nocompute")
         {
           nargin = 1;
           autocomp = false;
         }
 
       if (args(0).is_scalar_type ())
         {
           if (nargin == 1)
@@ -209,17 +210,17 @@ LU@tie{}factorization.  Once the matrix 
               else
                 retval = octave_value ("Unknown");
             }
           else
             {
               // Ok, we're changing the matrix type
               std::string str_typ = args(1).string_value ();
 
-              // FIXME -- why do I have to explicitly call the constructor?
+              // FIXME: why do I have to explicitly call the constructor?
               MatrixType mattyp = MatrixType ();
 
               octave_idx_type nl = 0;
               octave_idx_type nu = 0;
 
               if (error_state)
                 error ("matrix_type: TYPE must be a string");
               else
@@ -231,17 +232,18 @@ LU@tie{}factorization.  Once the matrix 
                   if (str_typ == "diagonal")
                     mattyp.mark_as_diagonal ();
                   if (str_typ == "permuted diagonal")
                     mattyp.mark_as_permuted_diagonal ();
                   else if (str_typ == "upper")
                     mattyp.mark_as_upper_triangular ();
                   else if (str_typ == "lower")
                     mattyp.mark_as_lower_triangular ();
-                  else if (str_typ == "banded" || str_typ == "banded positive definite")
+                  else if (str_typ == "banded"
+                           || str_typ == "banded positive definite")
                     {
                       if (nargin != 4)
                         error ("matrix_type: banded matrix type requires 4 arguments");
                       else
                         {
                           nl = args(2).nint_value ();
                           nu = args(3).nint_value ();
 
@@ -270,17 +272,18 @@ LU@tie{}factorization.  Once the matrix 
                     mattyp.mark_as_full ();
                   else if (str_typ == "unknown")
                     mattyp.invalidate_type ();
                   else
                     error ("matrix_type: Unknown matrix type %s", str_typ.c_str ());
 
                   if (! error_state)
                     {
-                      if (nargin == 3 && (str_typ == "upper" || str_typ == "lower"))
+                      if (nargin == 3
+                          && (str_typ == "upper" || str_typ == "lower"))
                         {
                           const ColumnVector perm =
                             ColumnVector (args (2).vector_value ());
 
                           if (error_state)
                             error ("matrix_type: Invalid permutation vector PERM");
                           else
                             {
@@ -289,39 +292,43 @@ LU@tie{}factorization.  Once the matrix 
 
                               if (len != dv(0))
                                 error ("matrix_type: Invalid permutation vector PERM");
                               else
                                 {
                                   OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
 
                                   for (octave_idx_type i = 0; i < len; i++)
-                                    p[i] = static_cast<octave_idx_type> (perm (i)) - 1;
+                                    p[i] = static_cast<octave_idx_type>
+                                           (perm (i))
+                                           - 1;
 
                                   if (str_typ == "upper")
                                     mattyp.mark_as_permuted (len, p);
                                   else
                                     mattyp.mark_as_permuted (len, p);
                                 }
                             }
                         }
-                      else if (nargin != 2 && str_typ != "banded positive definite" &&
-                               str_typ != "banded")
+                      else if (nargin != 2
+                               && str_typ != "banded positive definite"
+                               && str_typ != "banded")
                         error ("matrix_type: Invalid number of arguments");
 
                       if (! error_state)
                         {
                           // Set the matrix type
                           if (args(0).is_complex_type ())
                             retval =
                               octave_value (args(0).sparse_complex_matrix_value (),
                                             mattyp);
                           else
-                            retval = octave_value (args(0).sparse_matrix_value (),
-                                                   mattyp);
+                            retval
+                              = octave_value (args(0).sparse_matrix_value (),
+                                              mattyp);
                         }
                     }
                 }
             }
         }
       else
         {
           if (nargin == 1)
@@ -331,17 +338,18 @@ LU@tie{}factorization.  Once the matrix 
               if (args(0).is_complex_type ())
                 {
                   mattyp = args(0).matrix_type ();
 
                   if (mattyp.is_unknown () && autocomp)
                     {
                       if (args(0).is_single_type ())
                         {
-                          FloatComplexMatrix m = args(0).float_complex_matrix_value ();
+                          FloatComplexMatrix m;
+                          m = args(0).float_complex_matrix_value ();
                           if (!error_state)
                             {
                               mattyp = MatrixType (m);
                               args(0).matrix_type (mattyp);
                             }
                         }
                       else
                         {
@@ -405,17 +413,17 @@ LU@tie{}factorization.  Once the matrix 
               else
                 retval = octave_value ("Unknown");
             }
           else
             {
               // Ok, we're changing the matrix type
               std::string str_typ = args(1).string_value ();
 
-              // FIXME -- why do I have to explicitly call the constructor?
+              // FIXME: why do I have to explicitly call the constructor?
               MatrixType mattyp = MatrixType (MatrixType::Unknown, true);
 
               if (error_state)
                 error ("matrix_type: TYPE must be a string");
               else
                 {
                   // Use STL function to convert to lower case
                   std::transform (str_typ.begin (), str_typ.end (),
@@ -432,17 +440,18 @@ LU@tie{}factorization.  Once the matrix 
                     }
                   else if (str_typ == "singular")
                     mattyp.mark_as_rectangular ();
                   else if (str_typ == "full")
                     mattyp.mark_as_full ();
                   else if (str_typ == "unknown")
                     mattyp.invalidate_type ();
                   else
-                    error ("matrix_type: Unknown matrix type %s", str_typ.c_str ());
+                    error ("matrix_type: Unknown matrix type %s",
+                           str_typ.c_str ());
 
                   if (! error_state)
                     {
                       if (nargin == 3 && (str_typ == "upper"
                                           || str_typ == "lower"))
                         {
                           const ColumnVector perm =
                             ColumnVector (args (2).vector_value ());
@@ -456,17 +465,19 @@ LU@tie{}factorization.  Once the matrix 
 
                               if (len != dv(0))
                                 error ("matrix_type: Invalid permutation vector PERM");
                               else
                                 {
                                   OCTAVE_LOCAL_BUFFER (octave_idx_type, p, len);
 
                                   for (octave_idx_type i = 0; i < len; i++)
-                                    p[i] = static_cast<octave_idx_type> (perm (i)) - 1;
+                                    p[i] = static_cast<octave_idx_type>
+                                           (perm (i))
+                                           - 1;
 
                                   if (str_typ == "upper")
                                     mattyp.mark_as_permuted (len, p);
                                   else
                                     mattyp.mark_as_permuted (len, p);
                                 }
                             }
                         }
@@ -475,33 +486,33 @@ LU@tie{}factorization.  Once the matrix 
 
                       if (! error_state)
                         {
                           // Set the matrix type
                           if (args(0).is_single_type ())
                             {
                               if (args(0).is_complex_type ())
                                 retval = octave_value
-                                  (args(0).float_complex_matrix_value (),
-                                   mattyp);
+                                         (args(0).float_complex_matrix_value (),
+                                          mattyp);
                               else
                                 retval = octave_value
-                                  (args(0).float_matrix_value (),
-                                   mattyp);
+                                         (args(0).float_matrix_value (),
+                                          mattyp);
                             }
                           else
                             {
                               if (args(0).is_complex_type ())
                                 retval = octave_value
-                                  (args(0).complex_matrix_value (),
-                                   mattyp);
+                                         (args(0).complex_matrix_value (),
+                                          mattyp);
                               else
                                 retval = octave_value
-                                  (args(0).matrix_value (),
-                                   mattyp);
+                                         (args(0).matrix_value (),
+                                          mattyp);
                             }
                         }
                     }
                 }
             }
         }
     }
 
diff --git a/libinterp/corefcn/max.cc b/libinterp/corefcn/max.cc
--- a/libinterp/corefcn/max.cc
+++ b/libinterp/corefcn/max.cc
@@ -289,44 +289,50 @@ do_minmax_body (const octave_value_list&
                     retval(0) = arg;
                     if (nargout > 1)
                       retval(1) = arg;
                   }
                 else if (ismin)
                   {
                     retval(0) = range.min ();
                     if (nargout > 1)
-                      retval(1) = static_cast<double> (range.inc () < 0 ? range.nelem () : 1);
+                      retval(1) = static_cast<double>
+                                  (range.inc () < 0 ? range.nelem () : 1);
                   }
                 else
                   {
                     retval(0) = range.max ();
                     if (nargout > 1)
-                      retval(1) = static_cast<double> (range.inc () >= 0 ? range.nelem () : 1);
+                      retval(1) = static_cast<double>
+                                  (range.inc () >= 0 ? range.nelem () : 1);
                   }
               }
             else if (arg.is_sparse_type ())
-              retval = do_minmax_red_op<SparseMatrix> (arg, nargout, dim, ismin);
+              retval = do_minmax_red_op<SparseMatrix> (arg, nargout, dim,
+                                                       ismin);
             else
               retval = do_minmax_red_op<NDArray> (arg, nargout, dim, ismin);
             break;
           }
         case btyp_complex:
           {
             if (arg.is_sparse_type ())
-              retval = do_minmax_red_op<SparseComplexMatrix> (arg, nargout, dim, ismin);
+              retval = do_minmax_red_op<SparseComplexMatrix> (arg, nargout, dim,
+                                                              ismin);
             else
-              retval = do_minmax_red_op<ComplexNDArray> (arg, nargout, dim, ismin);
+              retval = do_minmax_red_op<ComplexNDArray> (arg, nargout, dim,
+                                                         ismin);
             break;
           }
         case btyp_float:
           retval = do_minmax_red_op<FloatNDArray> (arg, nargout, dim, ismin);
           break;
         case btyp_float_complex:
-          retval = do_minmax_red_op<FloatComplexNDArray> (arg, nargout, dim, ismin);
+          retval = do_minmax_red_op<FloatComplexNDArray> (arg, nargout, dim,
+                                                          ismin);
           break;
         case btyp_char:
           retval = do_minmax_red_op<charNDArray> (arg, nargout, dim, ismin);
           break;
 #define MAKE_INT_BRANCH(X) \
         case btyp_ ## X: \
           retval = do_minmax_red_op<X ## NDArray> (arg, nargout, dim, ismin); \
           break;
@@ -339,17 +345,17 @@ do_minmax_body (const octave_value_list&
         MAKE_INT_BRANCH (uint32);
         MAKE_INT_BRANCH (uint64);
 #undef MAKE_INT_BRANCH
         case btyp_bool:
           retval = do_minmax_red_op<boolNDArray> (arg, nargout, dim, ismin);
           break;
         default:
           gripe_wrong_type_arg (func, arg);
-      }
+        }
     }
   else if (nargin == 2)
     {
       octave_value argx = args(0), argy = args(1);
       builtin_type_t xtyp = argx.builtin_type (), ytyp = argy.builtin_type ();
       builtin_type_t rtyp;
       if (xtyp == btyp_char && ytyp == btyp_char)
         rtyp = btyp_char;
@@ -368,17 +374,18 @@ do_minmax_body (const octave_value_list&
               retval = do_minmax_bin_op<NDArray> (argx, argy, ismin);
             break;
           }
         case btyp_complex:
           {
             if ((argx.is_sparse_type ()
                  && (argy.is_sparse_type () || argy.is_scalar_type ()))
                 || (argy.is_sparse_type () && argx.is_scalar_type ()))
-              retval = do_minmax_bin_op<SparseComplexMatrix> (argx, argy, ismin);
+              retval = do_minmax_bin_op<SparseComplexMatrix> (argx, argy,
+                                                              ismin);
             else
               retval = do_minmax_bin_op<ComplexNDArray> (argx, argy, ismin);
             break;
           }
         case btyp_float:
           retval = do_minmax_bin_op<FloatNDArray> (argx, argy, ismin);
           break;
         case btyp_float_complex:
@@ -407,17 +414,17 @@ do_minmax_body (const octave_value_list&
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (min, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} min (@var{x})\n\
 @deftypefnx {Built-in Function} {} min (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} min (@var{x}, [], @var{dim})\n\
 @deftypefnx {Built-in Function} {} min (@var{x}, @var{y}, @var{dim})\n\
 @deftypefnx {Built-in Function} {[@var{w}, @var{iw}] =} min (@var{x})\n\
 For a vector argument, return the minimum value.  For a matrix\n\
 argument, return the minimum value from each column, as a row\n\
 vector, or over the dimension @var{dim} if defined, in which case @var{y} \n\
@@ -482,17 +489,17 @@ minimum value(s).  Thus,\n\
 %! assert (ndims (i), 2);
 %! assert (i, [2, 2; 2, 2]);
 
 %!error min ()
 %!error min (1, 2, 3, 4)
 */
 
 DEFUN (max, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} max (@var{x})\n\
 @deftypefnx {Built-in Function} {} max (@var{x}, @var{y})\n\
 @deftypefnx {Built-in Function} {} max (@var{x}, [], @var{dim})\n\
 @deftypefnx {Built-in Function} {} max (@var{x}, @var{y}, @var{dim})\n\
 @deftypefnx {Built-in Function} {[@var{w}, @var{iw}] =} max (@var{x})\n\
 For a vector argument, return the maximum value.  For a matrix\n\
 argument, return the maximum value from each column, as a row\n\
 vector, or over the dimension @var{dim} if defined, in which case @var{y} \n\
@@ -615,56 +622,60 @@ do_cumminmax_body (const octave_value_li
         }
 
       switch (arg.builtin_type ())
         {
         case btyp_double:
           retval = do_cumminmax_red_op<NDArray> (arg, nargout, dim, ismin);
           break;
         case btyp_complex:
-          retval = do_cumminmax_red_op<ComplexNDArray> (arg, nargout, dim, ismin);
+          retval = do_cumminmax_red_op<ComplexNDArray> (arg, nargout, dim,
+                                                        ismin);
           break;
         case btyp_float:
           retval = do_cumminmax_red_op<FloatNDArray> (arg, nargout, dim, ismin);
           break;
         case btyp_float_complex:
-          retval = do_cumminmax_red_op<FloatComplexNDArray> (arg, nargout, dim, ismin);
+          retval = do_cumminmax_red_op<FloatComplexNDArray> (arg, nargout, dim,
+                                                             ismin);
           break;
 #define MAKE_INT_BRANCH(X) \
         case btyp_ ## X: \
-          retval = do_cumminmax_red_op<X ## NDArray> (arg, nargout, dim, ismin); \
+          retval = do_cumminmax_red_op<X ## NDArray> (arg, nargout, dim, \
+                                                      ismin); \
           break;
         MAKE_INT_BRANCH (int8);
         MAKE_INT_BRANCH (int16);
         MAKE_INT_BRANCH (int32);
         MAKE_INT_BRANCH (int64);
         MAKE_INT_BRANCH (uint8);
         MAKE_INT_BRANCH (uint16);
         MAKE_INT_BRANCH (uint32);
         MAKE_INT_BRANCH (uint64);
 #undef MAKE_INT_BRANCH
         case btyp_bool:
           {
-            retval = do_cumminmax_red_op<int8NDArray> (arg, nargout, dim, ismin);
+            retval = do_cumminmax_red_op<int8NDArray> (arg, nargout, dim,
+                                                       ismin);
             if (retval.length () > 0)
               retval(0) = retval(0).bool_array_value ();
             break;
           }
         default:
           gripe_wrong_type_arg (func, arg);
-      }
+        }
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (cummin, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} cummin (@var{x})\n\
 @deftypefnx {Built-in Function} {} cummin (@var{x}, @var{dim})\n\
 @deftypefnx {Built-in Function} {[@var{w}, @var{iw}] =} cummin (@var{x})\n\
 Return the cumulative minimum values along dimension @var{dim}.\n\
 \n\
 If @var{dim} is unspecified it defaults to column-wise operation.  For\n\
 example:\n\
 \n\
@@ -708,17 +719,17 @@ iw = 1  2  2  4  4  6\n\
 %! assert (ndims (iw), 3);
 %! assert (iw, ones (2,2,2));
 
 %!error cummin ()
 %!error cummin (1, 2, 3)
 */
 
 DEFUN (cummax, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} cummax (@var{x})\n\
 @deftypefnx {Built-in Function} {} cummax (@var{x}, @var{dim})\n\
 @deftypefnx {Built-in Function} {[@var{w}, @var{iw}] =} cummax (@dots{})\n\
 Return the cumulative maximum values along dimension @var{dim}.\n\
 \n\
 If @var{dim} is unspecified it defaults to column-wise operation.  For\n\
 example:\n\
 \n\
diff --git a/libinterp/corefcn/md5sum.cc b/libinterp/corefcn/md5sum.cc
--- a/libinterp/corefcn/md5sum.cc
+++ b/libinterp/corefcn/md5sum.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "file-stat.h"
 #include "file-ops.h"
 #include "gripes.h"
 #include "load-path.h"
 #include "oct-env.h"
 #include "oct-md5.h"
 
 DEFUN (md5sum, args, ,
-   "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} md5sum (@var{file})\n\
 @deftypefnx {Built-in Function} {} md5sum (@var{str}, @var{opt})\n\
 Calculate the MD5 sum of the file @var{file}.  If the second parameter\n\
 @var{opt} exists and is true, then calculate the MD5 sum of the\n\
 string @var{str}.\n\
 @end deftypefn")
 {
   octave_value retval;
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -92,17 +92,17 @@ valid_key (const char *key)
               if (! (isalnum (key[i]) || key[i] == '_'))
                 goto done;
             }
 
           retval = 1;
         }
     }
 
- done:
+done:
 
   return retval;
 }
 
 // ------------------------------------------------------------------
 
 void
 mxArray_base::error (const char *msg) const
@@ -240,17 +240,18 @@ public:
   }
 
   mwSize *get_dimensions (void) const
   {
     if (! dims)
       {
         ndims = val.ndims ();
 
-        dims = static_cast<mwSize *> (mxArray::malloc (ndims * sizeof (mwSize)));
+        dims = static_cast<mwSize *> (mxArray::malloc (ndims
+                                                       * sizeof (mwSize)));
 
         dim_vector dv = val.dims ();
 
         for (mwIndex i = 0; i < ndims; i++)
           dims[i] = dv(i);
       }
 
     return dims;
@@ -405,17 +406,18 @@ public:
 
   mxArray *get_field_by_number (mwIndex /*index*/, int /*key_num*/) const
   {
     request_mutation ();
     return 0;
   }
 
   // Not allowed.
-  void set_field_by_number (mwIndex /*index*/, int /*key_num*/, mxArray */*val*/)
+  void set_field_by_number (mwIndex /*index*/, int /*key_num*/,
+                            mxArray */*val*/)
   {
     request_mutation ();
   }
 
   int get_number_of_fields (void) const { return val.nfields (); }
 
   const char *get_field_name_by_number (int /*key_num*/) const
   {
@@ -449,18 +451,17 @@ public:
         retval = 0;
       }
 
     return retval;
   }
 
   char *array_to_string (void) const
   {
-    // FIXME -- this is suposed to handle multi-byte character
-    // strings.
+    // FIXME: this is suposed to handle multi-byte character strings.
 
     char *buf = 0;
 
     if (val.is_string ())
       {
         mwSize nel = get_number_of_elements ();
 
         buf = static_cast<char *> (mxArray::malloc (nel + 1));
@@ -530,17 +531,19 @@ public:
   octave_value as_octave_value (void) const { return val; }
 
 protected:
 
   mxArray_octave_value (const mxArray_octave_value& arg)
     : mxArray_base (arg), val (arg.val), mutate_flag (arg.mutate_flag),
       id (arg.id), class_name (mxArray::strsave (arg.class_name)),
       ndims (arg.ndims),
-      dims (ndims > 0 ? static_cast<mwSize *> (mxArray::malloc (ndims * sizeof (mwSize))) : 0)
+      dims (ndims > 0 ? static_cast<mwSize *>
+                         (mxArray::malloc (ndims * sizeof (mwSize)))
+                      : 0)
   {
     if (dims)
       {
         for (mwIndex i = 0; i < ndims; i++)
           dims[i] = arg.dims[i];
       }
   }
 
@@ -554,17 +557,17 @@ private:
   // code.  For other things, we just request mutation to a
   // Matlab-style mxArray object.
 
   mutable mxClassID id;
   mutable char *class_name;
   mutable mwSize ndims;
   mutable mwSize *dims;
 
-  // No assignment!  FIXME -- should this be implemented?  Note that we
+  // No assignment!  FIXME: should this be implemented?  Note that we
   // do have a copy constructor.
 
   mxArray_octave_value& operator = (const mxArray_octave_value&);
 };
 
 // The base class for the Matlab-style representation, used to handle
 // things that are common to all Matlab-style objects.
 
@@ -834,17 +837,18 @@ public:
   }
 
   mxArray *get_field_by_number (mwIndex /*index*/, int /*key_num*/) const
   {
     invalid_type_error ();
     return 0;
   }
 
-  void set_field_by_number (mwIndex /*index*/, int /*key_num*/, mxArray */*val*/)
+  void set_field_by_number (mwIndex /*index*/, int /*key_num*/,
+                            mxArray */*val*/)
   {
     invalid_type_error ();
   }
 
   int get_number_of_fields (void) const
   {
     invalid_type_error ();
     return 0;
@@ -937,44 +941,51 @@ private:
   mwSize ndims;
   mwSize *dims;
 
   void invalid_type_error (void) const
   {
     error ("invalid type for operation");
   }
 
-  // No assignment!  FIXME -- should this be implemented?  Note that we
+  // No assignment!  FIXME: should this be implemented?  Note that we
   // do have a copy constructor.
 
   mxArray_matlab& operator = (const mxArray_matlab&);
 };
 
 // Matlab-style numeric, character, and logical data.
 
 class mxArray_number : public mxArray_matlab
 {
 public:
 
   mxArray_number (mxClassID id_arg, mwSize ndims_arg, const mwSize *dims_arg,
                   mxComplexity flag = mxREAL)
     : mxArray_matlab (id_arg, ndims_arg, dims_arg),
       pr (mxArray::calloc (get_number_of_elements (), get_element_size ())),
-      pi (flag == mxCOMPLEX ? mxArray::calloc (get_number_of_elements (), get_element_size ()) : 0) { }
+      pi (flag == mxCOMPLEX ? mxArray::calloc (get_number_of_elements (),
+                                               get_element_size ())
+                            : 0) { }
 
   mxArray_number (mxClassID id_arg, const dim_vector& dv,
                   mxComplexity flag = mxREAL)
     : mxArray_matlab (id_arg, dv),
       pr (mxArray::calloc (get_number_of_elements (), get_element_size ())),
-      pi (flag == mxCOMPLEX ? mxArray::calloc (get_number_of_elements (), get_element_size ()) : 0) { }
-
-  mxArray_number (mxClassID id_arg, mwSize m, mwSize n, mxComplexity flag = mxREAL)
+      pi (flag == mxCOMPLEX ? mxArray::calloc (get_number_of_elements (),
+                                               get_element_size ())
+                            : 0) { }
+
+  mxArray_number (mxClassID id_arg, mwSize m, mwSize n,
+                  mxComplexity flag = mxREAL)
     : mxArray_matlab (id_arg, m, n),
       pr (mxArray::calloc (get_number_of_elements (), get_element_size ())),
-      pi (flag == mxCOMPLEX ? mxArray::calloc (get_number_of_elements (), get_element_size ()) : 0) { }
+      pi (flag == mxCOMPLEX ? mxArray::calloc (get_number_of_elements (),
+                                               get_element_size ())
+                            : 0) { }
 
   mxArray_number (mxClassID id_arg, double val)
     : mxArray_matlab (id_arg, 1, 1),
       pr (mxArray::calloc (get_number_of_elements (), get_element_size ())),
       pi (0)
   {
     double *dpr = static_cast<double *> (pr);
     dpr[0] = val;
@@ -988,18 +999,18 @@ public:
     mxLogical *lpr = static_cast<mxLogical *> (pr);
     lpr[0] = val;
   }
 
   mxArray_number (const char *str)
     : mxArray_matlab (mxCHAR_CLASS,
                       str ? (strlen (str) ? 1 : 0) : 0,
                       str ? strlen (str) : 0),
-      pr (mxArray::calloc (get_number_of_elements (), get_element_size ())),
-      pi (0)
+    pr (mxArray::calloc (get_number_of_elements (), get_element_size ())),
+    pi (0)
   {
     mxChar *cpr = static_cast<mxChar *> (pr);
     mwSize nel = get_number_of_elements ();
     for (mwIndex i = 0; i < nel; i++)
       cpr[i] = str[i];
   }
 
   // FIXME??
@@ -1130,18 +1141,17 @@ public:
         buf[nel] = 0;
       }
 
     return retval;
   }
 
   char *array_to_string (void) const
   {
-    // FIXME -- this is suposed to handle multi-byte character
-    // strings.
+    // FIXME: this is suposed to handle multi-byte character strings.
 
     mwSize nel = get_number_of_elements ();
 
     char *buf = static_cast<char *> (mxArray::malloc (nel + 1));
 
     if (buf)
       {
         mxChar *ptr = static_cast<mxChar *> (pr);
@@ -1316,33 +1326,35 @@ protected:
       }
 
     return retval;
   }
 
   mxArray_number (const mxArray_number& val)
     : mxArray_matlab (val),
       pr (mxArray::malloc (get_number_of_elements () * get_element_size ())),
-      pi (val.pi ? mxArray::malloc (get_number_of_elements () * get_element_size ()) : 0)
+      pi (val.pi ? mxArray::malloc (get_number_of_elements ()
+                                    * get_element_size ())
+                 : 0)
   {
     size_t nbytes = get_number_of_elements () * get_element_size ();
 
     if (pr)
       memcpy (pr, val.pr, nbytes);
 
     if (pi)
       memcpy (pi, val.pi, nbytes);
   }
 
 private:
 
   void *pr;
   void *pi;
 
-  // No assignment!  FIXME -- should this be implemented?  Note that we
+  // No assignment!  FIXME: should this be implemented?  Note that we
   // do have a copy constructor.
 
   mxArray_number& operator = (const mxArray_number&);
 };
 
 // Matlab-style sparse arrays.
 
 class mxArray_sparse : public mxArray_matlab
@@ -1351,17 +1363,17 @@ public:
 
   mxArray_sparse (mxClassID id_arg, mwSize m, mwSize n, mwSize nzmax_arg,
                   mxComplexity flag = mxREAL)
     : mxArray_matlab (id_arg, m, n), nzmax (nzmax_arg),
       pr (mxArray::calloc (nzmax, get_element_size ())),
       pi (flag == mxCOMPLEX ? mxArray::calloc (nzmax, get_element_size ()) : 0),
       ir (static_cast<mwIndex *> (mxArray::calloc (nzmax, sizeof (mwIndex)))),
       jc (static_cast<mwIndex *> (mxArray::calloc (n + 1, sizeof (mwIndex))))
-    { }
+  { }
 
   mxArray_base *dup (void) const { return new mxArray_sparse (*this); }
 
   ~mxArray_sparse (void)
   {
     mxFree (pr);
     mxFree (pi);
     mxFree (ir);
@@ -1499,49 +1511,59 @@ private:
 
     if (ir)
       memcpy (ir, val.ir, nzmax * sizeof (mwIndex));
 
     if (jc)
       memcpy (jc, val.jc, (val.get_n () + 1) * sizeof (mwIndex));
   }
 
-  // No assignment!  FIXME -- should this be implemented?  Note that we
+  // No assignment!  FIXME: should this be implemented?  Note that we
   // do have a copy constructor.
 
   mxArray_sparse& operator = (const mxArray_sparse&);
 };
 
 // Matlab-style struct arrays.
 
 class mxArray_struct : public mxArray_matlab
 {
 public:
 
   mxArray_struct (mwSize ndims_arg, const mwSize *dims_arg, int num_keys_arg,
                   const char **keys)
-    : mxArray_matlab (mxSTRUCT_CLASS, ndims_arg, dims_arg), nfields (num_keys_arg),
-      fields (static_cast<char **> (mxArray::calloc (nfields, sizeof (char *)))),
-      data (static_cast<mxArray **> (mxArray::calloc (nfields * get_number_of_elements (), sizeof (mxArray *))))
+    : mxArray_matlab (mxSTRUCT_CLASS, ndims_arg, dims_arg),
+      nfields (num_keys_arg),
+      fields (static_cast<char **> (mxArray::calloc (nfields,
+                                                     sizeof (char *)))),
+      data (static_cast<mxArray **> (mxArray::calloc (nfields *
+                                                      get_number_of_elements (),
+                                                      sizeof (mxArray *))))
   {
     init (keys);
   }
 
   mxArray_struct (const dim_vector& dv, int num_keys_arg, const char **keys)
     : mxArray_matlab (mxSTRUCT_CLASS, dv), nfields (num_keys_arg),
-      fields (static_cast<char **> (mxArray::calloc (nfields, sizeof (char *)))),
-      data (static_cast<mxArray **> (mxArray::calloc (nfields * get_number_of_elements (), sizeof (mxArray *))))
+      fields (static_cast<char **> (mxArray::calloc (nfields,
+                                                     sizeof (char *)))),
+      data (static_cast<mxArray **> (mxArray::calloc (nfields *
+                                                      get_number_of_elements (),
+                                                      sizeof (mxArray *))))
   {
     init (keys);
   }
 
   mxArray_struct (mwSize m, mwSize n, int num_keys_arg, const char **keys)
     : mxArray_matlab (mxSTRUCT_CLASS, m, n), nfields (num_keys_arg),
-      fields (static_cast<char **> (mxArray::calloc (nfields, sizeof (char *)))),
-      data (static_cast<mxArray **> (mxArray::calloc (nfields * get_number_of_elements (), sizeof (mxArray *))))
+      fields (static_cast<char **> (mxArray::calloc (nfields,
+                                                     sizeof (char *)))),
+      data (static_cast<mxArray **> (mxArray::calloc (nfields *
+                                                      get_number_of_elements (),
+                                                      sizeof (mxArray *))))
   {
     init (keys);
   }
 
   void init (const char **keys)
   {
     for (int i = 0; i < nfields; i++)
       fields[i] = mxArray::strsave (keys[i]);
@@ -1567,27 +1589,30 @@ public:
   int add_field (const char *key)
   {
     int retval = -1;
 
     if (valid_key (key))
       {
         nfields++;
 
-        fields = static_cast<char **> (mxRealloc (fields, nfields * sizeof (char *)));
+        fields = static_cast<char **>
+                  (mxRealloc (fields, nfields * sizeof (char *)));
 
         if (fields)
           {
             fields[nfields-1] = mxArray::strsave (key);
 
             mwSize nel = get_number_of_elements ();
 
             mwSize ntot = nfields * nel;
 
-            mxArray **new_data = static_cast<mxArray **> (mxArray::malloc (ntot * sizeof (mxArray *)));
+            mxArray **new_data;
+            new_data = static_cast<mxArray **>
+                        (mxArray::malloc (ntot * sizeof (mxArray *)));
 
             if (new_data)
               {
                 mwIndex j = 0;
                 mwIndex k = 0;
                 mwIndex n = 0;
 
                 for (mwIndex i = 0; i < ntot; i++)
@@ -1618,19 +1643,22 @@ public:
     if (key_num >= 0 && key_num < nfields)
       {
         mwSize nel = get_number_of_elements ();
 
         mwSize ntot = nfields * nel;
 
         int new_nfields = nfields - 1;
 
-        char **new_fields = static_cast<char **> (mxArray::malloc (new_nfields * sizeof (char *)));
-
-        mxArray **new_data = static_cast<mxArray **> (mxArray::malloc (new_nfields * nel * sizeof (mxArray *)));
+        char **new_fields = static_cast<char **>
+                             (mxArray::malloc (new_nfields * sizeof (char *)));
+
+        mxArray **new_data = static_cast<mxArray **>
+                              (mxArray::malloc (new_nfields * nel
+                                                * sizeof (mxArray *)));
 
         for (int i = 0; i < key_num; i++)
           new_fields[i] = fields[i];
 
         for (int i = key_num + 1; i < nfields; i++)
           new_fields[i-1] = fields[i];
 
         if (new_nfields > 0)
@@ -1659,17 +1687,17 @@ public:
         fields = new_fields;
         data = new_data;
       }
   }
 
   mxArray *get_field_by_number (mwIndex index, int key_num) const
   {
     return key_num >= 0 && key_num < nfields
-      ? data[nfields * index + key_num] : 0;
+           ? data[nfields * index + key_num] : 0;
   }
 
   void set_field_by_number (mwIndex index, int key_num, mxArray *val);
 
   int get_number_of_fields (void) const { return nfields; }
 
   const char *get_field_name_by_number (int key_num) const
   {
@@ -1727,54 +1755,60 @@ private:
   int nfields;
 
   char **fields;
 
   mxArray **data;
 
   mxArray_struct (const mxArray_struct& val)
     : mxArray_matlab (val), nfields (val.nfields),
-      fields (static_cast<char **> (mxArray::malloc (nfields * sizeof (char *)))),
-      data (static_cast<mxArray **> (mxArray::malloc (nfields * get_number_of_elements () * sizeof (mxArray *))))
+      fields (static_cast<char **> (mxArray::malloc (nfields
+                                                     * sizeof (char *)))),
+      data (static_cast<mxArray **> (mxArray::malloc (nfields *
+                                                      get_number_of_elements ()
+                                                      * sizeof (mxArray *))))
   {
     for (int i = 0; i < nfields; i++)
       fields[i] = mxArray::strsave (val.fields[i]);
 
     mwSize nel = get_number_of_elements ();
 
     for (mwIndex i = 0; i < nel * nfields; i++)
       {
         mxArray *ptr = val.data[i];
         data[i] = ptr ? ptr->dup () : 0;
       }
   }
 
-  // No assignment!  FIXME -- should this be implemented?  Note that we
+  // No assignment!  FIXME: should this be implemented?  Note that we
   // do have a copy constructor.
 
   mxArray_struct& operator = (const mxArray_struct& val);
 };
 
 // Matlab-style cell arrays.
 
 class mxArray_cell : public mxArray_matlab
 {
 public:
 
   mxArray_cell (mwSize ndims_arg, const mwSize *dims_arg)
     : mxArray_matlab (mxCELL_CLASS, ndims_arg, dims_arg),
-      data (static_cast<mxArray **> (mxArray::calloc (get_number_of_elements (), sizeof (mxArray *)))) { }
+      data (static_cast<mxArray **> (mxArray::calloc (get_number_of_elements (),
+                                     sizeof (mxArray *)))) { }
 
   mxArray_cell (const dim_vector& dv)
     : mxArray_matlab (mxCELL_CLASS, dv),
-      data (static_cast<mxArray **> (mxArray::calloc (get_number_of_elements (), sizeof (mxArray *)))) { }
+      data (static_cast<mxArray **> (mxArray::calloc (get_number_of_elements (),
+                                     sizeof (mxArray *)))) { }
 
   mxArray_cell (mwSize m, mwSize n)
     : mxArray_matlab (mxCELL_CLASS, m, n),
-      data (static_cast<mxArray **> (mxArray::calloc (get_number_of_elements (), sizeof (mxArray *)))) { }
+      data (static_cast<mxArray **> (mxArray::calloc (get_number_of_elements (),
+                                     sizeof (mxArray *)))) { }
 
   mxArray_base *dup (void) const { return new mxArray_cell (*this); }
 
   ~mxArray_cell (void)
   {
     mwSize nel = get_number_of_elements ();
 
     for  (mwIndex i = 0; i < nel; i++)
@@ -1811,39 +1845,41 @@ public:
   }
 
 private:
 
   mxArray **data;
 
   mxArray_cell (const mxArray_cell& val)
     : mxArray_matlab (val),
-      data (static_cast<mxArray **> (mxArray::malloc (get_number_of_elements () * sizeof (mxArray *))))
+      data (static_cast<mxArray **> (mxArray::malloc (get_number_of_elements ()
+                                                      * sizeof (mxArray *))))
   {
     mwSize nel = get_number_of_elements ();
 
     for (mwIndex i = 0; i < nel; i++)
       {
         mxArray *ptr = val.data[i];
         data[i] = ptr ? ptr->dup () : 0;
       }
   }
 
-  // No assignment!  FIXME -- should this be implemented?  Note that we
+  // No assignment!  FIXME: should this be implemented?  Note that we
   // do have a copy constructor.
 
   mxArray_cell& operator = (const mxArray_cell&);
 };
 
 // ------------------------------------------------------------------
 
 mxArray::mxArray (const octave_value& ov)
   : rep (new mxArray_octave_value (ov)), name (0) { }
 
-mxArray::mxArray (mxClassID id, mwSize ndims, const mwSize *dims, mxComplexity flag)
+mxArray::mxArray (mxClassID id, mwSize ndims, const mwSize *dims,
+                  mxComplexity flag)
   : rep (new mxArray_number (id, ndims, dims, flag)), name (0) { }
 
 mxArray::mxArray (mxClassID id, const dim_vector& dv, mxComplexity flag)
   : rep (new mxArray_number (id, dv, flag)), name (0) { }
 
 mxArray::mxArray (mxClassID id, mwSize m, mwSize n, mxComplexity flag)
   : rep (new mxArray_number (id, m, n, flag)), name (0) { }
 
@@ -1854,20 +1890,22 @@ mxArray::mxArray (mxClassID id, mxLogica
   : rep (new mxArray_number (id, val)), name (0) { }
 
 mxArray::mxArray (const char *str)
   : rep (new mxArray_number (str)), name (0) { }
 
 mxArray::mxArray (mwSize m, const char **str)
   : rep (new mxArray_number (m, str)), name (0) { }
 
-mxArray::mxArray (mxClassID id, mwSize m, mwSize n, mwSize nzmax, mxComplexity flag)
+mxArray::mxArray (mxClassID id, mwSize m, mwSize n, mwSize nzmax,
+                  mxComplexity flag)
   : rep (new mxArray_sparse (id, m, n, nzmax, flag)), name (0) { }
 
-mxArray::mxArray (mwSize ndims, const mwSize *dims, int num_keys, const char **keys)
+mxArray::mxArray (mwSize ndims, const mwSize *dims, int num_keys,
+                  const char **keys)
   : rep (new mxArray_struct (ndims, dims, num_keys, keys)), name (0) { }
 
 mxArray::mxArray (const dim_vector& dv, int num_keys, const char **keys)
   : rep (new mxArray_struct (dv, num_keys, keys)), name (0) { }
 
 mxArray::mxArray (mwSize m, mwSize n, int num_keys, const char **keys)
   : rep (new mxArray_struct (m, n, num_keys, keys)), name (0) { }
 
@@ -1987,17 +2025,17 @@ public:
 
   // Allocate memory.
   void *malloc_unmarked (size_t n)
   {
     void *ptr = gnulib::malloc (n);
 
     if (! ptr)
       {
-        // FIXME -- could use "octave_new_handler();" instead
+        // FIXME: could use "octave_new_handler();" instead
 
         error ("%s: failed to allocate %d bytes of memory",
                function_name (), n);
 
         abort ();
       }
 
     global_mark (ptr);
@@ -2368,17 +2406,18 @@ void *
 mxMalloc (size_t n)
 {
   return mex_context ? mex_context->malloc (n) : gnulib::malloc (n);
 }
 
 void *
 mxRealloc (void *ptr, size_t size)
 {
-  return mex_context ? mex_context->realloc (ptr, size) : gnulib::realloc (ptr, size);
+  return mex_context ? mex_context->realloc (ptr, size)
+                     : gnulib::realloc (ptr, size);
 }
 
 void
 mxFree (void *ptr)
 {
   if (mex_context)
     mex_context->free (ptr);
   else
@@ -2449,17 +2488,18 @@ mxCreateLogicalScalar (mxLogical val)
 mxArray *
 mxCreateNumericArray (mwSize ndims, const mwSize *dims, mxClassID class_id,
                       mxComplexity flag)
 {
   return maybe_mark_array (new mxArray (class_id, ndims, dims, flag));
 }
 
 mxArray *
-mxCreateNumericMatrix (mwSize m, mwSize n, mxClassID class_id, mxComplexity flag)
+mxCreateNumericMatrix (mwSize m, mwSize n, mxClassID class_id,
+                       mxComplexity flag)
 {
   return maybe_mark_array (new mxArray (class_id, m, n, flag));
 }
 
 mxArray *
 mxCreateSparse (mwSize m, mwSize n, mwSize nzmax, mxComplexity flag)
 {
   return maybe_mark_array (new mxArray (mxDOUBLE_CLASS, m, n, nzmax, flag));
@@ -2473,17 +2513,18 @@ mxCreateSparseLogicalMatrix (mwSize m, m
 
 mxArray *
 mxCreateString (const char *str)
 {
   return maybe_mark_array (new mxArray (str));
 }
 
 mxArray *
-mxCreateStructArray (mwSize ndims, const mwSize *dims, int num_keys, const char **keys)
+mxCreateStructArray (mwSize ndims, const mwSize *dims, int num_keys,
+                     const char **keys)
 {
   return maybe_mark_array (new mxArray (ndims, dims, num_keys, keys));
 }
 
 mxArray *
 mxCreateStructMatrix (mwSize m, mwSize n, int num_keys, const char **keys)
 {
   return maybe_mark_array (new mxArray (m, n, num_keys, keys));
@@ -2917,17 +2958,18 @@ size_t
 mxGetElementSize (const mxArray *ptr)
 {
   return ptr->get_element_size ();
 }
 
 // ------------------------------------------------------------------
 
 typedef void (*cmex_fptr) (int nlhs, mxArray **plhs, int nrhs, mxArray **prhs);
-typedef F77_RET_T (*fmex_fptr) (int& nlhs, mxArray **plhs, int& nrhs, mxArray **prhs);
+typedef F77_RET_T (*fmex_fptr) (int& nlhs, mxArray **plhs,
+                                int& nrhs, mxArray **prhs);
 
 octave_value_list
 call_mex (bool have_fmex, void *f, const octave_value_list& args,
           int nargout_arg, octave_mex_function *curr_mex_fcn)
 {
   // Use at least 1 for nargout since even for zero specified args,
   // still want to be able to return an ans.
 
@@ -3009,32 +3051,32 @@ mexFunctionName (void)
 }
 
 int
 mexCallMATLAB (int nargout, mxArray *argout[], int nargin,
                mxArray *argin[], const char *fname)
 {
   octave_value_list args;
 
-  // FIXME -- do we need unwind protect to clean up args?  Off hand, I
+  // FIXME: do we need unwind protect to clean up args?  Off hand, I
   // would say that this problem is endemic to Octave and we will
   // continue to have memory leaks after Ctrl-C until proper exception
   // handling is implemented.  longjmp() only clears the stack, so any
   // class which allocates data on the heap is going to leak.
 
   args.resize (nargin);
 
   for (int i = 0; i < nargin; i++)
     args(i) = mxArray::as_octave_value (argin[i]);
 
   octave_value_list retval = feval (fname, args, nargout);
 
   if (error_state && mex_context->trap_feval_error == 0)
     {
-      // FIXME -- is this the correct way to clean up?  abort() is
+      // FIXME: is this the correct way to clean up?  abort() is
       // going to trigger a long jump, so the normal class destructors
       // will not be called.  Hopefully this will reduce things to a
       // tiny leak.  Maybe create a new octave memory tracer type
       // which prints a friendly message every time it is
       // created/copied/deleted to check this.
 
       args.resize (0);
       retval.resize (0);
@@ -3043,17 +3085,17 @@ mexCallMATLAB (int nargout, mxArray *arg
 
   int num_to_copy = retval.length ();
 
   if (nargout < retval.length ())
     num_to_copy = nargout;
 
   for (int i = 0; i < num_to_copy; i++)
     {
-      // FIXME -- it would be nice to avoid copying the value here,
+      // FIXME: it would be nice to avoid copying the value here,
       // but there is no way to steal memory from a matrix, never mind
       // that matrix memory is allocated by new[] and mxArray memory
       // is allocated by malloc().
       argout[i] = mex_context->make_value (retval (i));
     }
 
   while (num_to_copy < nargout)
     argout[num_to_copy++] = 0;
@@ -3138,18 +3180,18 @@ void
 mexWarnMsgTxt (const char *s)
 {
   warning ("%s", s);
 }
 
 void
 mexWarnMsgIdAndTxt (const char *id, const char *fmt, ...)
 {
-  // FIXME -- is this right?  What does Matlab do if fmt is NULL or
-  // an empty string?
+  // FIXME: is this right?  What does Matlab do if fmt is NULL or
+  //        an empty string?
 
   if (fmt && strlen (fmt) > 0)
     {
       const char *fname = mexFunctionName ();
       size_t len = strlen (fname) + 2 + strlen (fmt) + 1;
       OCTAVE_LOCAL_BUFFER (char, tmpfmt, len);
       sprintf (tmpfmt, "%s: %s", fname, fmt);
       va_list args;
@@ -3176,17 +3218,17 @@ mexGetVariable (const char *space, const
   mxArray *retval = 0;
 
   octave_value val;
 
   if (! strcmp (space, "global"))
     val = get_global_value (name);
   else
     {
-      // FIXME -- should this be in variables.cc?
+      // FIXME: should this be in variables.cc?
 
       unwind_protect frame;
 
       bool caller = ! strcmp (space, "caller");
       bool base = ! strcmp (space, "base");
 
       if (caller || base)
         {
@@ -3239,17 +3281,17 @@ mexPutVariable (const char *space, const
 
   if (! name || name[0] == '\0')
     return 1;
 
   if (! strcmp (space, "global"))
     set_global_value (name, mxArray::as_octave_value (ptr));
   else
     {
-      // FIXME -- should this be in variables.cc?
+      // FIXME: should this be in variables.cc?
 
       unwind_protect frame;
 
       bool caller = ! strcmp (space, "caller");
       bool base = ! strcmp (space, "base");
 
       if (caller || base)
         {
diff --git a/libinterp/corefcn/mexproto.h b/libinterp/corefcn/mexproto.h
--- a/libinterp/corefcn/mexproto.h
+++ b/libinterp/corefcn/mexproto.h
@@ -69,41 +69,49 @@ extern "C" {
 
 #define MXARRAY_TYPEDEFS_ONLY
 #include "mxarray.h"
 #undef MXARRAY_TYPEDEFS_ONLY
 
 /* Interface to the interpreter.  */
 extern OCTINTERP_API const char *mexFunctionName (void);
 
-extern OCTINTERP_API int mexCallMATLAB (int nargout, mxArray *argout[], int nargin, mxArray *argin[], const char *fname);
+extern OCTINTERP_API int mexCallMATLAB (int nargout, mxArray *argout[],
+                                        int nargin, mxArray *argin[],
+                                        const char *fname);
 
 extern OCTINTERP_API void mexSetTrapFlag (int flag);
 extern OCTINTERP_API int mexEvalString (const char *s);
 extern OCTINTERP_API void mexErrMsgTxt (const char *s);
-extern OCTINTERP_API void mexErrMsgIdAndTxt (const char *id, const char *s, ...);
+extern OCTINTERP_API void mexErrMsgIdAndTxt (const char *id, const char *s,
+                                             ...);
 extern OCTINTERP_API void mexWarnMsgTxt (const char *s);
-extern OCTINTERP_API void mexWarnMsgIdAndTxt (const char *id, const char *s, ...);
+extern OCTINTERP_API void mexWarnMsgIdAndTxt (const char *id, const char *s,
+                                              ...);
 extern OCTINTERP_API int mexPrintf (const char *fmt, ...);
 
-extern OCTINTERP_API mxArray *mexGetVariable (const char *space, const char *name);
-extern OCTINTERP_API const mxArray *mexGetVariablePtr (const char *space, const char *name);
+extern OCTINTERP_API mxArray *mexGetVariable (const char *space,
+                                              const char *name);
+extern OCTINTERP_API const mxArray *mexGetVariablePtr (const char *space,
+                                                       const char *name);
 
 extern OCTINTERP_API int mexPutVariable (const char *space, const char *name,
                                          const mxArray *ptr);
 
 extern OCTINTERP_API void mexMakeArrayPersistent (mxArray *ptr);
 extern OCTINTERP_API void mexMakeMemoryPersistent (void *ptr);
 
 extern OCTINTERP_API int mexAtExit (void (*f) (void));
-extern OCTINTERP_API const mxArray *mexGet (double handle, const char *property);
+extern OCTINTERP_API const mxArray *mexGet (double handle,
+                                            const char *property);
 extern OCTINTERP_API int mexIsGlobal (const mxArray *ptr);
 extern OCTINTERP_API int mexIsLocked (void);
 extern OCTINTERP_API void mexLock (void);
-extern OCTINTERP_API int mexSet (double handle, const char *property, mxArray *val);
+extern OCTINTERP_API int mexSet (double handle, const char *property,
+                                 mxArray *val);
 extern OCTINTERP_API void mexUnlock (void);
 
 /* Floating point predicates.  */
 extern OCTINTERP_API int mxIsFinite (double v);
 extern OCTINTERP_API int mxIsInf (double v);
 extern OCTINTERP_API int mxIsNaN (double v);
 
 /* Floating point values.  */
@@ -113,32 +121,49 @@ extern OCTINTERP_API double mxGetNaN (vo
 
 /* Memory management.  */
 extern OCTINTERP_API void *mxCalloc (size_t n, size_t size);
 extern OCTINTERP_API void *mxMalloc (size_t n);
 extern OCTINTERP_API void *mxRealloc (void *ptr, size_t size);
 extern OCTINTERP_API void mxFree (void *ptr);
 
 /* Constructors.  */
-extern OCTINTERP_API mxArray *mxCreateCellArray (mwSize ndims, const mwSize *dims);
+extern OCTINTERP_API mxArray *mxCreateCellArray (mwSize ndims,
+                                                 const mwSize *dims);
 extern OCTINTERP_API mxArray *mxCreateCellMatrix (mwSize m, mwSize n);
-extern OCTINTERP_API mxArray *mxCreateCharArray (mwSize ndims, const mwSize *dims);
-extern OCTINTERP_API mxArray *mxCreateCharMatrixFromStrings (mwSize m, const char **str);
-extern OCTINTERP_API mxArray *mxCreateDoubleMatrix (mwSize nr, mwSize nc, mxComplexity flag);
+extern OCTINTERP_API mxArray *mxCreateCharArray (mwSize ndims,
+                                                 const mwSize *dims);
+extern OCTINTERP_API mxArray *mxCreateCharMatrixFromStrings (mwSize m,
+                                                             const char **str);
+extern OCTINTERP_API mxArray *mxCreateDoubleMatrix (mwSize nr, mwSize nc,
+                                                    mxComplexity flag);
 extern OCTINTERP_API mxArray *mxCreateDoubleScalar (double val);
-extern OCTINTERP_API mxArray *mxCreateLogicalArray (mwSize ndims, const mwSize *dims);
+extern OCTINTERP_API mxArray *mxCreateLogicalArray (mwSize ndims,
+                                                    const mwSize *dims);
 extern OCTINTERP_API mxArray *mxCreateLogicalMatrix (mwSize m, mwSize n);
 extern OCTINTERP_API mxArray *mxCreateLogicalScalar (mxLogical val);
-extern OCTINTERP_API mxArray *mxCreateNumericArray (mwSize ndims, const mwSize *dims, mxClassID class_id, mxComplexity flag);
-extern OCTINTERP_API mxArray *mxCreateNumericMatrix (mwSize m, mwSize n, mxClassID class_id, mxComplexity flag);
-extern OCTINTERP_API mxArray *mxCreateSparse (mwSize m, mwSize n, mwSize nzmax, mxComplexity flag);
-extern OCTINTERP_API mxArray *mxCreateSparseLogicalMatrix (mwSize m, mwSize n, mwSize nzmax);
+extern OCTINTERP_API mxArray *mxCreateNumericArray (mwSize ndims,
+                                                    const mwSize *dims,
+                                                    mxClassID class_id,
+                                                    mxComplexity flag);
+extern OCTINTERP_API mxArray *mxCreateNumericMatrix (mwSize m, mwSize n,
+                                                     mxClassID class_id,
+                                                     mxComplexity flag);
+extern OCTINTERP_API mxArray *mxCreateSparse (mwSize m, mwSize n, mwSize nzmax,
+                                              mxComplexity flag);
+extern OCTINTERP_API mxArray *mxCreateSparseLogicalMatrix (mwSize m, mwSize n,
+                                                           mwSize nzmax);
 extern OCTINTERP_API mxArray *mxCreateString (const char *str);
-extern OCTINTERP_API mxArray *mxCreateStructArray (mwSize ndims, const mwSize *dims, int num_keys, const char **keys);
-extern OCTINTERP_API mxArray *mxCreateStructMatrix (mwSize rows, mwSize cols, int num_keys, const char **keys);
+extern OCTINTERP_API mxArray *mxCreateStructArray (mwSize ndims,
+                                                   const mwSize *dims,
+                                                   int num_keys,
+                                                   const char **keys);
+extern OCTINTERP_API mxArray *mxCreateStructMatrix (mwSize rows, mwSize cols,
+                                                    int num_keys,
+                                                    const char **keys);
 
 /* Copy constructor.  */
 extern OCTINTERP_API mxArray *mxDuplicateArray (const mxArray *v);
 
 /* Destructor.  */
 extern OCTINTERP_API void mxDestroyArray (mxArray *v);
 
 /* Type Predicates.  */
@@ -179,17 +204,18 @@ extern OCTINTERP_API size_t mxGetM (cons
 extern OCTINTERP_API size_t mxGetN (const mxArray *ptr);
 extern OCTINTERP_API mwSize *mxGetDimensions (const mxArray *ptr);
 extern OCTINTERP_API mwSize mxGetNumberOfDimensions (const mxArray *ptr);
 extern OCTINTERP_API size_t mxGetNumberOfElements (const mxArray *ptr);
 
 /* Dimension setters.  */
 extern OCTINTERP_API void mxSetM (mxArray *ptr, mwSize M);
 extern OCTINTERP_API void mxSetN (mxArray *ptr, mwSize N);
-extern OCTINTERP_API void mxSetDimensions (mxArray *ptr, const mwSize *dims, mwSize ndims);
+extern OCTINTERP_API void mxSetDimensions (mxArray *ptr, const mwSize *dims,
+                                           mwSize ndims);
 
 /* Data extractors.  */
 extern OCTINTERP_API double *mxGetPi (const mxArray *ptr);
 extern OCTINTERP_API double *mxGetPr (const mxArray *ptr);
 extern OCTINTERP_API double mxGetScalar (const mxArray *ptr);
 extern OCTINTERP_API mxChar *mxGetChars (const mxArray *ptr);
 extern OCTINTERP_API mxLogical *mxGetLogicals (const mxArray *ptr);
 extern OCTINTERP_API void *mxGetData (const mxArray *ptr);
@@ -221,28 +247,34 @@ extern OCTINTERP_API void mxSetIr (mxArr
 extern OCTINTERP_API void mxSetJc (mxArray *ptr, mwIndex *jc);
 extern OCTINTERP_API void mxSetNzmax (mxArray *ptr, mwSize nzmax);
 
 /* Structure support.  */
 extern OCTINTERP_API int mxAddField (mxArray *ptr, const char *key);
 
 extern OCTINTERP_API void mxRemoveField (mxArray *ptr, int key_num);
 
-extern OCTINTERP_API mxArray *mxGetField (const mxArray *ptr, mwIndex index, const char *key);
-extern OCTINTERP_API mxArray *mxGetFieldByNumber (const mxArray *ptr, mwIndex index, int key_num);
+extern OCTINTERP_API mxArray *mxGetField (const mxArray *ptr, mwIndex index,
+                                          const char *key);
+extern OCTINTERP_API mxArray *mxGetFieldByNumber (const mxArray *ptr,
+                                                  mwIndex index, int key_num);
 
-extern OCTINTERP_API void mxSetField (mxArray *ptr, mwIndex index, const char *key, mxArray *val);
-extern OCTINTERP_API void mxSetFieldByNumber (mxArray *ptr, mwIndex index, int key_num, mxArray *val);
+extern OCTINTERP_API void mxSetField (mxArray *ptr, mwIndex index,
+                                      const char *key, mxArray *val);
+extern OCTINTERP_API void mxSetFieldByNumber (mxArray *ptr, mwIndex index,
+                                              int key_num, mxArray *val);
 
 extern OCTINTERP_API int mxGetNumberOfFields (const mxArray *ptr);
 
-extern OCTINTERP_API const char *mxGetFieldNameByNumber (const mxArray *ptr, int key_num);
+extern OCTINTERP_API const char *mxGetFieldNameByNumber (const mxArray *ptr,
+                                                         int key_num);
 extern OCTINTERP_API int mxGetFieldNumber (const mxArray *ptr, const char *key);
 
-extern OCTINTERP_API int mxGetString (const mxArray *ptr, char *buf, mwSize buflen);
+extern OCTINTERP_API int mxGetString (const mxArray *ptr, char *buf,
+                                      mwSize buflen);
 extern OCTINTERP_API char *mxArrayToString (const mxArray *ptr);
 
 /* Miscellaneous.  */
 #ifdef NDEBUG
 #define mxAssert(expr, msg) \
   do \
     { \
       if (! expr) \
@@ -264,17 +296,18 @@ extern OCTINTERP_API char *mxArrayToStri
         } \
     } \
   while (0)
 #else
 #define mxAssert(expr, msg)
 #define mxAssertS(expr, msg)
 #endif
 
-extern OCTINTERP_API mwIndex mxCalcSingleSubscript (const mxArray *ptr, mwSize nsubs, mwIndex *subs);
+extern OCTINTERP_API mwIndex mxCalcSingleSubscript (const mxArray *ptr,
+                                                    mwSize nsubs, mwIndex *subs);
 
 extern OCTINTERP_API size_t mxGetElementSize (const mxArray *ptr);
 
 #if defined (__cplusplus)
 }
 #endif
 
 #endif
diff --git a/libinterp/corefcn/mgorth.cc b/libinterp/corefcn/mgorth.cc
--- a/libinterp/corefcn/mgorth.cc
+++ b/libinterp/corefcn/mgorth.cc
@@ -44,17 +44,17 @@ do_mgorth (ColumnVector& x, const Matrix
     }
 
   h(Vc) = xnorm (x);
   if (real (h(Vc)) > 0)
     x = x / h(Vc);
 }
 
 DEFUN (mgorth, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{y}, @var{h}] =} mgorth (@var{x}, @var{v})\n\
 Orthogonalize a given column vector @var{x} with respect to a set of\n\
 orthonormal vectors comprising the columns of @var{v}\n\
 using the modified Gram-Schmidt method.\n\
 On exit, @var{y} is a unit vector such that:\n\
 \n\
 @example\n\
 @group\n\
@@ -66,20 +66,20 @@ On exit, @var{y} is a unit vector such t
 \n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 2 || nargout > 2)
-  {
-    print_usage ();
-    return retval;
-  }
+    {
+      print_usage ();
+      return retval;
+    }
 
   octave_value arg_x = args(0);
   octave_value arg_v = args(1);
 
   if (arg_v.ndims () != 2 || arg_x.ndims () != 2 || arg_x.columns () != 1
       || arg_v.rows () != arg_x.rows ())
     {
       error ("mgorth: V should be a matrix, and X a column vector with"
@@ -92,17 +92,18 @@ On exit, @var{y} is a unit vector such t
       error ("mgorth: X and V must be numeric");
     }
 
   bool iscomplex = (arg_x.is_complex_type () || arg_v.is_complex_type ());
   if (arg_x.is_single_type () || arg_v.is_single_type ())
     {
       if (iscomplex)
         {
-          FloatComplexColumnVector x = arg_x.float_complex_column_vector_value ();
+          FloatComplexColumnVector x
+            = arg_x.float_complex_column_vector_value ();
           FloatComplexMatrix V = arg_v.float_complex_matrix_value ();
           FloatComplexRowVector h;
           do_mgorth (x, V, h);
           retval(1) = h;
           retval(0) = x;
         }
       else
         {
diff --git a/libinterp/corefcn/mxarray.in.h b/libinterp/corefcn/mxarray.in.h
--- a/libinterp/corefcn/mxarray.in.h
+++ b/libinterp/corefcn/mxarray.in.h
@@ -43,43 +43,43 @@ OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 SUCH DAMAGE.
 
 */
 
 #if ! defined (MXARRAY_H)
 #define MXARRAY_H
 
 typedef enum
-  {
-    mxREAL = 0,
-    mxCOMPLEX = 1
-  }
-  mxComplexity;
+{
+  mxREAL = 0,
+  mxCOMPLEX = 1
+}
+mxComplexity;
 
 typedef enum
-  {
-    mxUNKNOWN_CLASS = 0,
-    mxCELL_CLASS,
-    mxSTRUCT_CLASS,
-    mxLOGICAL_CLASS,
-    mxCHAR_CLASS,
-    mxUNUSED_CLASS,
-    mxDOUBLE_CLASS,
-    mxSINGLE_CLASS,
-    mxINT8_CLASS,
-    mxUINT8_CLASS,
-    mxINT16_CLASS,
-    mxUINT16_CLASS,
-    mxINT32_CLASS,
-    mxUINT32_CLASS,
-    mxINT64_CLASS,
-    mxUINT64_CLASS,
-    mxFUNCTION_CLASS
-  }
-  mxClassID;
+{
+  mxUNKNOWN_CLASS = 0,
+  mxCELL_CLASS,
+  mxSTRUCT_CLASS,
+  mxLOGICAL_CLASS,
+  mxCHAR_CLASS,
+  mxUNUSED_CLASS,
+  mxDOUBLE_CLASS,
+  mxSINGLE_CLASS,
+  mxINT8_CLASS,
+  mxUINT8_CLASS,
+  mxINT16_CLASS,
+  mxUINT16_CLASS,
+  mxINT32_CLASS,
+  mxUINT32_CLASS,
+  mxINT64_CLASS,
+  mxUINT64_CLASS,
+  mxFUNCTION_CLASS
+}
+mxClassID;
 
 typedef unsigned char mxLogical;
 
 /* typedef Uint16 mxChar; */
 typedef char mxChar;
 
 /*
  * FIXME? Mathworks says these should be size_t on 64-bit system and when
@@ -247,17 +247,18 @@ public:
   virtual void set_nzmax (mwSize nzmax) = 0;
 
   virtual int add_field (const char *key) = 0;
 
   virtual void remove_field (int key_num) = 0;
 
   virtual mxArray *get_field_by_number (mwIndex index, int key_num) const = 0;
 
-  virtual void set_field_by_number (mwIndex index, int key_num, mxArray *val) = 0;
+  virtual void
+  set_field_by_number (mwIndex index, int key_num, mxArray *val) = 0;
 
   virtual int get_number_of_fields (void) const = 0;
 
   virtual const char *get_field_name_by_number (int key_num) const = 0;
 
   virtual int get_field_number (const char *key) const = 0;
 
   virtual int get_string (char *buf, mwSize buflen) const = 0;
@@ -381,55 +382,63 @@ public:
   int is_uint32 (void) const { return rep->is_uint32 (); }
 
   int is_uint64 (void) const { return rep->is_uint64 (); }
 
   int is_uint8 (void) const { return rep->is_uint8 (); }
 
   int is_logical_scalar (void) const { return rep->is_logical_scalar (); }
 
-  int is_logical_scalar_true (void) const { return rep->is_logical_scalar_true (); }
+  int is_logical_scalar_true (void) const
+  { return rep->is_logical_scalar_true (); }
 
   mwSize get_m (void) const { return rep->get_m (); }
 
   mwSize get_n (void) const { return rep->get_n (); }
 
   mwSize *get_dimensions (void) const { return rep->get_dimensions (); }
 
-  mwSize get_number_of_dimensions (void) const { return rep->get_number_of_dimensions (); }
+  mwSize get_number_of_dimensions (void) const
+  { return rep->get_number_of_dimensions (); }
 
   void set_m (mwSize m) { DO_VOID_MUTABLE_METHOD (set_m (m)); }
 
   void set_n (mwSize n) { DO_VOID_MUTABLE_METHOD (set_n (n)); }
 
-  void set_dimensions (mwSize *dims_arg, mwSize ndims_arg) { DO_VOID_MUTABLE_METHOD (set_dimensions (dims_arg, ndims_arg)); }
+  void set_dimensions (mwSize *dims_arg, mwSize ndims_arg)
+  { DO_VOID_MUTABLE_METHOD (set_dimensions (dims_arg, ndims_arg)); }
 
-  mwSize get_number_of_elements (void) const { return rep->get_number_of_elements (); }
+  mwSize get_number_of_elements (void) const
+  { return rep->get_number_of_elements (); }
 
   int is_empty (void) const { return get_number_of_elements () == 0; }
 
   const char *get_name (void) const { return name; }
 
   void set_name (const char *name_arg);
 
   mxClassID get_class_id (void) const { return rep->get_class_id (); }
 
   const char *get_class_name (void) const { return rep->get_class_name (); }
 
-  void set_class_name (const char *name_arg) { DO_VOID_MUTABLE_METHOD (set_class_name (name_arg)); }
+  void set_class_name (const char *name_arg)
+  { DO_VOID_MUTABLE_METHOD (set_class_name (name_arg)); }
 
-  mxArray *get_cell (mwIndex idx) const { DO_MUTABLE_METHOD (mxArray *, get_cell (idx)); }
+  mxArray *get_cell (mwIndex idx) const
+  { DO_MUTABLE_METHOD (mxArray *, get_cell (idx)); }
 
-  void set_cell (mwIndex idx, mxArray *val) { DO_VOID_MUTABLE_METHOD (set_cell (idx, val)); }
+  void set_cell (mwIndex idx, mxArray *val)
+  { DO_VOID_MUTABLE_METHOD (set_cell (idx, val)); }
 
   double get_scalar (void) const { return rep->get_scalar (); }
 
   void *get_data (void) const { DO_MUTABLE_METHOD (void *, get_data ()); }
 
-  void *get_imag_data (void) const { DO_MUTABLE_METHOD (void *, get_imag_data ()); }
+  void *get_imag_data (void) const
+  { DO_MUTABLE_METHOD (void *, get_imag_data ()); }
 
   void set_data (void *pr) { DO_VOID_MUTABLE_METHOD (set_data (pr)); }
 
   void set_imag_data (void *pi) { DO_VOID_MUTABLE_METHOD (set_imag_data (pi)); }
 
   mwIndex *get_ir (void) const { DO_MUTABLE_METHOD (mwIndex *, get_ir ()); }
 
   mwIndex *get_jc (void) const { DO_MUTABLE_METHOD (mwIndex *, get_jc ()); }
@@ -439,33 +448,40 @@ public:
   void set_ir (mwIndex *ir) { DO_VOID_MUTABLE_METHOD (set_ir (ir)); }
 
   void set_jc (mwIndex *jc) { DO_VOID_MUTABLE_METHOD (set_jc (jc)); }
 
   void set_nzmax (mwSize nzmax) { DO_VOID_MUTABLE_METHOD (set_nzmax (nzmax)); }
 
   int add_field (const char *key) { DO_MUTABLE_METHOD (int, add_field (key)); }
 
-  void remove_field (int key_num) { DO_VOID_MUTABLE_METHOD (remove_field (key_num)); }
+  void remove_field (int key_num)
+  { DO_VOID_MUTABLE_METHOD (remove_field (key_num)); }
 
-  mxArray *get_field_by_number (mwIndex index, int key_num) const { DO_MUTABLE_METHOD (mxArray *, get_field_by_number (index, key_num)); }
+  mxArray *get_field_by_number (mwIndex index, int key_num) const
+  { DO_MUTABLE_METHOD (mxArray *, get_field_by_number (index, key_num)); }
 
-  void set_field_by_number (mwIndex index, int key_num, mxArray *val) { DO_VOID_MUTABLE_METHOD (set_field_by_number (index, key_num, val)); }
+  void set_field_by_number (mwIndex index, int key_num, mxArray *val)
+  { DO_VOID_MUTABLE_METHOD (set_field_by_number (index, key_num, val)); }
 
   int get_number_of_fields (void) const { return rep->get_number_of_fields (); }
 
-  const char *get_field_name_by_number (int key_num) const { DO_MUTABLE_METHOD (const char*, get_field_name_by_number (key_num)); }
+  const char *get_field_name_by_number (int key_num) const
+  { DO_MUTABLE_METHOD (const char*, get_field_name_by_number (key_num)); }
 
-  int get_field_number (const char *key) const { DO_MUTABLE_METHOD (int, get_field_number (key)); }
+  int get_field_number (const char *key) const
+  { DO_MUTABLE_METHOD (int, get_field_number (key)); }
 
-  int get_string (char *buf, mwSize buflen) const { return rep->get_string (buf, buflen); }
+  int get_string (char *buf, mwSize buflen) const
+  { return rep->get_string (buf, buflen); }
 
   char *array_to_string (void) const { return rep->array_to_string (); }
 
-  mwIndex calc_single_subscript (mwSize nsubs, mwIndex *subs) const { return rep->calc_single_subscript (nsubs, subs); }
+  mwIndex calc_single_subscript (mwSize nsubs, mwIndex *subs) const
+  { return rep->calc_single_subscript (nsubs, subs); }
 
   size_t get_element_size (void) const { return rep->get_element_size (); }
 
   bool mutation_needed (void) const { return rep->mutation_needed (); }
 
   mxArray *mutate (void) const { return rep->mutate (); }
 
   static void *malloc (size_t n);
diff --git a/libinterp/corefcn/nproc.cc b/libinterp/corefcn/nproc.cc
--- a/libinterp/corefcn/nproc.cc
+++ b/libinterp/corefcn/nproc.cc
@@ -23,17 +23,17 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "defun.h"
 #include "nproc.h"
 
 DEFUN (nproc, args, nargout,
-   "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} nproc ()\n\
 @deftypefnx {Built-in Function} {} nproc (@var{query})\n\
 Return the current number of available processors.\n\
 \n\
 If called with the optional argument @var{query}, modify how processors\n\
 are counted as follows:\n\
 \n\
 @table @code\n\
diff --git a/libinterp/corefcn/oct-hist.cc b/libinterp/corefcn/oct-hist.cc
--- a/libinterp/corefcn/oct-hist.cc
+++ b/libinterp/corefcn/oct-hist.cc
@@ -165,17 +165,17 @@ do_history (const octave_value_list& arg
           gripe_wrong_type_arg ("history", arg);
           return hlist;
         }
 
       if (option == "-r" || option == "-w" || option == "-a"
           || option == "-n")
         {
           if (i < nargin - 1)
-            { 
+            {
               if (args(i+1).is_string ())
                 command_history::set_file (args(++i).string_value ());
               else
                 {
                   error ("history: expecting file name for %s option",
                          option.c_str ());
                   return hlist;
                 }
@@ -230,17 +230,17 @@ do_history (const octave_value_list& arg
 
           if (sscanf (option.c_str (), "%d", &tmp) == 1)
             {
               if (tmp > 0)
                 limit = tmp;
               else
                 limit = -tmp;
             }
-          
+
           else
             {
               if (option.length () > 0 && option[0] == '-')
                 error ("history: unrecognized option '%s'", option.c_str ());
               else
                 error ("history: bad non-numeric arg '%s'", option.c_str ());
 
               return  hlist;
@@ -578,17 +578,17 @@ octave_history_write_timestamp (void)
   std::string timestamp = now.strftime (Vhistory_timestamp_format_string);
 
   if (! timestamp.empty ())
     if (command_history::add (timestamp))
       octave_link::append_history (timestamp);
 }
 
 DEFUN (edit_history, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Command} {} edit_history\n\
 @deftypefnx {Command} {} edit_history @var{cmd_number}\n\
 @deftypefnx {Command} {} edit_history @var{first} @var{last}\n\
 Edit the history list using the editor named by the variable\n\
 @w{@env{EDITOR}}.\n\
 \n\
 The commands to be edited are first copied to a temporary file.  When you\n\
 exit the editor, Octave executes the commands that remain in the file.  It\n\
@@ -621,17 +621,17 @@ buffer to be edited.\n\
   octave_value_list retval;
 
   do_edit_history (args);
 
   return retval;
 }
 
 DEFUN (history, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Command} {} history\n\
 @deftypefnx {Command} {} history @var{opt1} @dots{}\n\
 @deftypefnx {Built-in Function} {@var{h} =} history ()\n\
 @deftypefnx {Built-in Function} {@var{h} =} history (@var{opt1}, @dots{})\n\
 If invoked with no arguments, @code{history} displays a list of commands\n\
 that you have executed.  Valid options are:\n\
 \n\
 @table @code\n\
@@ -670,17 +670,17 @@ argument as a cell string and will not b
 
   if (nargout > 0)
     retval = Cell (hlist);
 
   return retval;
 }
 
 DEFUN (run_history, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Command} {} run_history\n\
 @deftypefnx {Command} {} run_history @var{cmd_number}\n\
 @deftypefnx {Command} {} run_history @var{first} @var{last}\n\
 Run commands from the history list.\n\
 \n\
 When invoked with no arguments, run the previously executed command;\n\
 With one argument, run the specified command @var{cmd_number};\n\
 With two arguments, run the list of commands between @var{first} and\n\
@@ -728,17 +728,17 @@ run_history -1 -2\n\
   octave_value_list retval;
 
   do_run_history (args);
 
   return retval;
 }
 
 DEFUN (history_control, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} history_control ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} history_control (@var{new_val})\n\
 Query or set the internal variable that specifies how commands are saved\n\
 to the history list.  The default value is an empty character string,\n\
 but may be overridden by the environment variable\n\
 @w{@env{OCTAVE_HISTCONTROL}}.\n\
 \n\
 The value of @code{history_control} is a colon-separated list of values\n\
@@ -765,17 +765,17 @@ the history list, subject to the value o
 
   if (tmp != old_history_control)
     command_history::process_histcontrol (tmp);
 
   return retval;
 }
 
 DEFUN (history_size, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} history_size ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} history_size (@var{new_val})\n\
 Query or set the internal variable that specifies how many entries\n\
 to store in the history file.  The default value is @code{1000},\n\
 but may be overridden by the environment variable @w{@env{OCTAVE_HISTSIZE}}.\n\
 @seealso{history_file, history_timestamp_format_string, history_save}\n\
 @end deftypefn")
 {
@@ -791,17 +791,17 @@ but may be overridden by the environment
 
   if (tmp != old_history_size)
     command_history::set_size (tmp);
 
   return retval;
 }
 
 DEFUN (history_file, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} history_file ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} history_file (@var{new_val})\n\
 Query or set the internal variable that specifies the name of the\n\
 file used to store command history.  The default value is\n\
 @file{~/.octave_hist}, but may be overridden by the environment\n\
 variable @w{@env{OCTAVE_HISTFILE}}.\n\
 @seealso{history_size, history_save, history_timestamp_format_string}\n\
 @end deftypefn")
@@ -816,17 +816,17 @@ variable @w{@env{OCTAVE_HISTFILE}}.\n\
 
   if (tmp != old_history_file)
     command_history::set_file (tmp);
 
   return retval;
 }
 
 DEFUN (history_timestamp_format_string, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} history_timestamp_format_string ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} history_timestamp_format_string (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} history_timestamp_format_string (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the format string\n\
 for the comment line that is written to the history file when Octave\n\
 exits.  The format string is passed to @code{strftime}.  The default\n\
 value is\n\
 \n\
@@ -839,17 +839,17 @@ variable is changed locally for the func
 The original variable value is restored when exiting the function.\n\
 @seealso{strftime, history_file, history_size, history_save}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (history_timestamp_format_string);
 }
 
 DEFUN (history_save, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} history_save ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} history_save (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} history_save (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether commands entered\n\
 on the command line are saved in the history file.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.  \n\
diff --git a/libinterp/corefcn/oct-lvalue.h b/libinterp/corefcn/oct-lvalue.h
--- a/libinterp/corefcn/oct-lvalue.h
+++ b/libinterp/corefcn/oct-lvalue.h
@@ -42,27 +42,27 @@ public:
     : sym (s), type (), idx (), nel (1)
   { }
 
   octave_lvalue (const octave_lvalue& vr)
     : sym (vr.sym), type (vr.type), idx (vr.idx), nel (vr.nel)
   { }
 
   octave_lvalue& operator = (const octave_lvalue& vr)
-    {
-      if (this != &vr)
-        {
-          sym = vr.sym;
-          type = vr.type;
-          idx = vr.idx;
-          nel = vr.nel;
-        }
+  {
+    if (this != &vr)
+      {
+        sym = vr.sym;
+        type = vr.type;
+        idx = vr.idx;
+        nel = vr.nel;
+      }
 
-      return *this;
-    }
+    return *this;
+  }
 
   ~octave_lvalue (void) { }
 
   bool is_black_hole (void) const { return sym.is_black_hole (); }
 
   bool is_defined (void) const
   {
     return ! is_black_hole () && sym->is_defined ();
diff --git a/libinterp/corefcn/oct-map.cc b/libinterp/corefcn/oct-map.cc
--- a/libinterp/corefcn/oct-map.cc
+++ b/libinterp/corefcn/oct-map.cc
@@ -570,17 +570,18 @@ octave_map::resize (const dim_vector& dv
       dummy.resize (dv);
     }
 
   dimensions = dv;
   optimize_dimensions ();
 }
 
 void
-octave_map::do_cat (int dim, octave_idx_type n, const octave_scalar_map *map_list,
+octave_map::do_cat (int dim, octave_idx_type n,
+                    const octave_scalar_map *map_list,
                     octave_map& retval)
 {
   octave_idx_type nf = retval.nfields ();
   retval.xvals.reserve (nf);
 
   dim_vector& rd = retval.dimensions;
   rd.resize (dim+1, 1);
   rd(0) = rd(1) = 1;
@@ -611,48 +612,51 @@ octave_map::do_cat (int dim, octave_idx_
 
       retval.xvals.push_back (Array<octave_value>::cat (dim, n, field_list));
       if (j == 0)
         retval.dimensions = retval.xvals[j].dims ();
     }
 }
 
 // This is just a wrapper.
-void permute_to_correct_order1 (const octave_scalar_map& ref, const octave_scalar_map& src,
-                                octave_scalar_map& dest, Array<octave_idx_type>& perm)
+void permute_to_correct_order1 (const octave_scalar_map& ref,
+                                const octave_scalar_map& src,
+                                octave_scalar_map& dest,
+                                Array<octave_idx_type>& perm)
 {
   dest = src.orderfields (ref, perm);
 }
 
 // In non-scalar case, we also promote empty structs without fields.
 void permute_to_correct_order1 (const octave_map& ref, const octave_map& src,
                                 octave_map& dest, Array<octave_idx_type>& perm)
 {
   if (src.nfields () == 0 && src.is_empty ())
-     dest = octave_map (src.dims (), ref.keys ());
+    dest = octave_map (src.dims (), ref.keys ());
   else
-     dest = src.orderfields (ref, perm);
+    dest = src.orderfields (ref, perm);
 }
 
 template <class map>
 static void
 permute_to_correct_order (octave_idx_type n, octave_idx_type nf,
                           octave_idx_type idx, const map *map_list,
                           map *new_map_list)
 {
   new_map_list[idx] = map_list[idx];
 
   Array<octave_idx_type> perm (dim_vector (1, nf));
 
   for (octave_idx_type i = 0; i < n; i++)
     {
       if (i == idx)
-         continue;
+        continue;
 
-      permute_to_correct_order1 (map_list[idx], map_list[i], new_map_list[i], perm);
+      permute_to_correct_order1 (map_list[idx], map_list[i], new_map_list[i],
+                                 perm);
 
       if (error_state)
         {
           // Use liboctave exception to be consistent.
           (*current_liboctave_error_handler)
             ("cat: field names mismatch in concatenating structs");
           break;
         }
@@ -1573,17 +1577,17 @@ keys_ok (const Octave_map& a, const Octa
                 goto done;
             }
 
           keys = a_keys;
           retval = true;
         }
     }
 
- done:
+done:
   return retval;
 }
 
 Octave_map&
 Octave_map::maybe_delete_elements (const octave_value_list& idx)
 {
   string_vector t_keys = keys ();
   octave_idx_type len = t_keys.length ();
diff --git a/libinterp/corefcn/oct-map.h b/libinterp/corefcn/oct-map.h
--- a/libinterp/corefcn/oct-map.h
+++ b/libinterp/corefcn/oct-map.h
@@ -47,72 +47,72 @@ octave_fields
 
   private:
     fields_rep& operator = (const fields_rep&); // no assignment!
   };
 
   fields_rep *rep;
 
   static fields_rep *nil_rep (void)
-    {
-      static fields_rep nr;
-      return &nr;
-    }
+  {
+    static fields_rep nr;
+    return &nr;
+  }
 
 public:
 
   octave_fields (void) : rep (nil_rep ()) { rep->count++; }
   octave_fields (const string_vector&);
   octave_fields (const char * const *);
 
   ~octave_fields (void)
-    {
-      if (--rep->count == 0)
-        delete rep;
-    }
+  {
+    if (--rep->count == 0)
+      delete rep;
+  }
 
   void make_unique (void)
-    {
-      if (rep->count > 1)
-        {
-          fields_rep *r = new fields_rep (*rep);
+  {
+    if (rep->count > 1)
+      {
+        fields_rep *r = new fields_rep (*rep);
 
-          if (--rep->count == 0)
-            delete rep;
+        if (--rep->count == 0)
+          delete rep;
 
-          rep = r;
-        }
-    }
+        rep = r;
+      }
+  }
 
   octave_fields (const octave_fields& o) : rep (o.rep) { rep->count++; }
 
   octave_fields&
   operator = (const octave_fields& o)
-    {
-      o.rep->count++;
-      if (--rep->count == 0)
-        delete rep;
-      rep = o.rep;
+  {
+    o.rep->count++;
+    if (--rep->count == 0)
+      delete rep;
+    rep = o.rep;
 
-      return *this;
-    }
+    return *this;
+  }
 
   // constant iteration support. non-const iteration intentionally unsupported.
 
   typedef std::map<std::string, octave_idx_type>::const_iterator const_iterator;
   typedef const_iterator iterator;
 
   const_iterator begin (void) const { return rep->begin (); }
   const_iterator end (void) const { return rep->end (); }
 
   std::string key (const_iterator p) const { return p->first; }
   octave_idx_type index (const_iterator p) const { return p->second; }
 
   const_iterator seek (const std::string& k) const
-    { return rep->find (k); }
+  { return rep->find (k); }
 
   // high-level methods.
 
   // number of fields.
   octave_idx_type nfields (void) const { return rep->size (); }
 
   // check whether a field exists.
   bool isfield (const std::string& name) const;
@@ -133,25 +133,25 @@ public:
   // into the order of *this*.
   bool equal_up_to_order (const octave_fields& other,
                           octave_idx_type* perm) const;
 
   bool equal_up_to_order (const octave_fields& other,
                           Array<octave_idx_type>& perm) const;
 
   bool is_same (const octave_fields& other) const
-    { return rep == other.rep; }
+  { return rep == other.rep; }
 
   // Returns the fields as a vector of strings.
   string_vector fieldnames (void) const;
 
   void clear (void)
-    {
-      *this = octave_fields ();
-    }
+  {
+    *this = octave_fields ();
+  }
 };
 
 
 class OCTINTERP_API
 octave_scalar_map
 {
 public:
 
@@ -162,106 +162,107 @@ public:
 
   octave_scalar_map (const string_vector& k)
     : xkeys (k), xvals (k.length ()) { }
 
   octave_scalar_map (const octave_scalar_map& m)
     : xkeys (m.xkeys), xvals(m.xvals) { }
 
   octave_scalar_map& operator = (const octave_scalar_map& m)
-    {
-      xkeys = m.xkeys;
-      xvals = m.xvals;
+  {
+    xkeys = m.xkeys;
+    xvals = m.xvals;
 
-      return *this;
-    }
+    return *this;
+  }
 
   // iteration support. note that both const and non-const iterators are the
   // same. The const/non-const distinction is made by the key & contents method.
   typedef octave_fields::const_iterator const_iterator;
   typedef const_iterator iterator;
 
   const_iterator begin (void) const { return xkeys.begin (); }
   const_iterator end (void) const { return xkeys.end (); }
 
   const_iterator seek (const std::string& k) const { return xkeys.seek (k); }
 
   std::string key (const_iterator p) const
-    { return xkeys.key (p); }
+  { return xkeys.key (p); }
   octave_idx_type index (const_iterator p) const
-    { return xkeys.index (p); }
+  { return xkeys.index (p); }
 
   const octave_value& contents (const_iterator p) const
-    { return xvals[xkeys.index (p)]; }
+  { return xvals[xkeys.index (p)]; }
 
   octave_value& contents (iterator p)
-    { return xvals[xkeys.index (p)]; }
+  { return xvals[xkeys.index (p)]; }
 
   const octave_value& contents (octave_idx_type i) const
-    { return xvals[i]; }
+  { return xvals[i]; }
 
   octave_value& contents (octave_idx_type i)
-    { return xvals[i]; }
+  { return xvals[i]; }
 
   // number of fields.
   octave_idx_type nfields (void) const { return xkeys.nfields (); }
 
   // check whether a field exists.
   bool isfield (const std::string& name) const
-    { return xkeys.isfield (name); }
+  { return xkeys.isfield (name); }
 
   bool contains (const std::string& name) const
-    { return isfield (name); }
+  { return isfield (name); }
 
   string_vector fieldnames (void) const
-    { return xkeys.fieldnames (); }
+  { return xkeys.fieldnames (); }
 
   string_vector keys (void) const
-    { return fieldnames (); }
+  { return fieldnames (); }
 
   // get contents of a given field. empty value if not exist.
   octave_value getfield (const std::string& key) const;
 
   // set contents of a given field. add if not exist.
   void setfield (const std::string& key, const octave_value& val);
   void assign (const std::string& k, const octave_value& val)
-    { setfield (k, val); }
+  { setfield (k, val); }
 
   // remove a given field. do nothing if not exist.
   void rmfield (const std::string& key);
   void del (const std::string& k) { rmfield (k); }
 
   // return a copy with fields ordered, optionally along with permutation.
   octave_scalar_map orderfields (void) const;
   octave_scalar_map orderfields (Array<octave_idx_type>& perm) const;
   octave_scalar_map orderfields (const octave_scalar_map& other,
                                  Array<octave_idx_type>& perm) const;
 
   // aka getfield/setfield, but the latter returns a reference.
   octave_value contents (const std::string& k) const;
   octave_value& contents (const std::string& k);
 
   void clear (void)
-    {
-      xkeys.clear ();
-      xvals.clear ();
-    }
+  {
+    xkeys.clear ();
+    xvals.clear ();
+  }
 
   friend class octave_map;
 
 private:
 
   octave_fields xkeys;
   std::vector<octave_value> xvals;
 
 };
 
 template<>
-inline octave_scalar_map octave_value_extract<octave_scalar_map> (const octave_value& v)
-  { return v.scalar_map_value (); }
+inline octave_scalar_map
+octave_value_extract<octave_scalar_map> (const octave_value& v)
+{ return v.scalar_map_value (); }
 
 class OCTINTERP_API
 octave_map
 {
 public:
 
   octave_map (const octave_fields& k)
     : xkeys (k), xvals (k.nfields ()), dimensions () { }
@@ -284,95 +285,95 @@ public:
   octave_map (const octave_map& m)
     : xkeys (m.xkeys), xvals (m.xvals), dimensions (m.dimensions) { }
 
   octave_map (const octave_scalar_map& m);
 
   octave_map (const Octave_map& m);
 
   octave_map& operator = (const octave_map& m)
-    {
-      xkeys = m.xkeys;
-      xvals = m.xvals;
-      dimensions = m.dimensions;
+  {
+    xkeys = m.xkeys;
+    xvals = m.xvals;
+    dimensions = m.dimensions;
 
-      return *this;
-    }
+    return *this;
+  }
 
   // iteration support. note that both const and non-const iterators are the
   // same. The const/non-const distinction is made by the key & contents method.
   typedef octave_fields::const_iterator const_iterator;
   typedef const_iterator iterator;
 
   const_iterator begin (void) const { return xkeys.begin (); }
   const_iterator end (void) const { return xkeys.end (); }
 
   const_iterator seek (const std::string& k) const { return xkeys.seek (k); }
 
   std::string key (const_iterator p) const
-    { return xkeys.key (p); }
+  { return xkeys.key (p); }
   octave_idx_type index (const_iterator p) const
-    { return xkeys.index (p); }
+  { return xkeys.index (p); }
 
   const Cell& contents (const_iterator p) const
-    { return xvals[xkeys.index (p)]; }
+  { return xvals[xkeys.index (p)]; }
 
   Cell& contents (iterator p)
-    { return xvals[xkeys.index (p)]; }
+  { return xvals[xkeys.index (p)]; }
 
   const Cell& contents (octave_idx_type i) const
-    { return xvals[i]; }
+  { return xvals[i]; }
 
   Cell& contents (octave_idx_type i)
-    { return xvals[i]; }
+  { return xvals[i]; }
 
   // number of fields.
   octave_idx_type nfields (void) const { return xkeys.nfields (); }
 
   // check whether a field exists.
   bool isfield (const std::string& name) const
-    { return xkeys.isfield (name); }
+  { return xkeys.isfield (name); }
 
   bool contains (const std::string& name) const
-    { return isfield (name); }
+  { return isfield (name); }
 
   string_vector fieldnames (void) const
-    { return xkeys.fieldnames (); }
+  { return xkeys.fieldnames (); }
 
   string_vector keys (void) const
-    { return fieldnames (); }
+  { return fieldnames (); }
 
   // get contents of a given field. empty value if not exist.
   Cell getfield (const std::string& key) const;
 
   // set contents of a given field. add if not exist. checks for
   // correct dimensions.
   void setfield (const std::string& key, const Cell& val);
   void assign (const std::string& k, const Cell& val)
-    { setfield (k, val); }
+  { setfield (k, val); }
 
   // remove a given field. do nothing if not exist.
   void rmfield (const std::string& key);
   void del (const std::string& k) { rmfield (k); }
 
   // return a copy with fields ordered, optionally along with permutation.
   octave_map orderfields (void) const;
   octave_map orderfields (Array<octave_idx_type>& perm) const;
   octave_map orderfields (const octave_map& other,
                           Array<octave_idx_type>& perm) const;
 
   // aka getfield/setfield, but the latter returns a reference.
   Cell contents (const std::string& k) const;
   Cell& contents (const std::string& k);
 
   void clear (void)
-    {
-      xkeys.clear ();
-      xvals.clear ();
-    }
+  {
+    xkeys.clear ();
+    xvals.clear ();
+  }
 
   // The Array-like methods.
   octave_idx_type numel (void) const { return dimensions.numel (); }
   octave_idx_type length (void) const { return numel (); }
   bool is_empty (void) const { return dimensions.any_zero (); }
 
   octave_idx_type rows (void) const { return dimensions(0); }
   octave_idx_type cols (void) const { return dimensions(1); }
@@ -381,23 +382,23 @@ public:
   // Extract a scalar substructure.
   octave_scalar_map checkelem (octave_idx_type n) const;
   octave_scalar_map checkelem (octave_idx_type i, octave_idx_type j) const;
 
   octave_scalar_map
   checkelem (const Array<octave_idx_type>& ra_idx) const;
 
   octave_scalar_map operator () (octave_idx_type n) const
-    { return checkelem (n); }
+  { return checkelem (n); }
   octave_scalar_map operator () (octave_idx_type i, octave_idx_type j) const
-    { return checkelem (i, j); }
+  { return checkelem (i, j); }
 
   octave_scalar_map
   operator () (const Array<octave_idx_type>& ra_idx) const
-    { return checkelem (ra_idx); }
+  { return checkelem (ra_idx); }
 
   octave_map squeeze (void) const;
 
   octave_map permute (const Array<int>& vec, bool inv = false) const;
 
   dim_vector dims (void) const { return dimensions; }
 
   int ndims (void) const { return dimensions.length (); }
@@ -441,17 +442,18 @@ public:
   void delete_elements (const idx_vector& i);
 
   void delete_elements (int dim, const idx_vector& i);
 
   void delete_elements (const Array<idx_vector>& ia);
 
   void delete_elements (const octave_value_list&);
 
-  octave_map concat (const octave_map& rb, const Array<octave_idx_type>& ra_idx);
+  octave_map concat (const octave_map& rb,
+                     const Array<octave_idx_type>& ra_idx);
 
   // like checkelem, but no check.
   octave_scalar_map fast_elem_extract (octave_idx_type n) const;
 
   // element assignment, no bounds check
   bool fast_elem_insert (octave_idx_type n, const octave_scalar_map& rhs);
 
 private:
@@ -466,27 +468,27 @@ private:
   static void do_cat (int dim, octave_idx_type n,
                       const octave_scalar_map *map_list, octave_map& retval);
   static void do_cat (int dim, octave_idx_type n,
                       const octave_map *map_list, octave_map& retval);
 };
 
 template<>
 inline octave_map octave_value_extract<octave_map> (const octave_value& v)
-  { return v.map_value (); }
+{ return v.map_value (); }
 
 // The original Octave_map object which is now deprecated.
 // It was fully deprecated in version 3.8 and should be removed in 3.12.
 // Octave_map and octave_map are convertible to each other.
 
 class
 OCTINTERP_API
 Octave_map
 {
- public:
+public:
 
   typedef std::map<std::string, Cell>::iterator iterator;
   typedef std::map<std::string, Cell>::const_iterator const_iterator;
 
   typedef std::list<std::string>::iterator key_list_iterator;
   typedef std::list<std::string>::const_iterator const_key_list_iterator;
 
   // Warning!  You should always use at least two dimensions.
@@ -528,86 +530,86 @@ Octave_map
   }
 
   Octave_map (const Octave_map& m)
     : map (m.map), key_list (m.key_list), dimensions (m.dimensions) { }
 
   Octave_map (const octave_map& m);
 
   Octave_map& operator = (const Octave_map& m)
-    {
-      if (this != &m)
-        {
-          map = m.map;
-          key_list = m.key_list;
-          dimensions = m.dimensions;
-        }
+  {
+    if (this != &m)
+      {
+        map = m.map;
+        key_list = m.key_list;
+        dimensions = m.dimensions;
+      }
 
-      return *this;
-    }
+    return *this;
+  }
 
   ~Octave_map (void) { }
 
   Octave_map squeeze (void) const;
 
   Octave_map permute (const Array<int>& vec, bool inv = false) const;
 
   // This is the number of keys.
   octave_idx_type nfields (void) const { return map.size (); }
 
   void del (const std::string& k)
-    {
-      iterator p = map.find (k);
+  {
+    iterator p = map.find (k);
 
-      if (p != map.end ())
-        {
-          map.erase (p);
+    if (p != map.end ())
+      {
+        map.erase (p);
 
-          key_list_iterator q
-            = std::find (key_list.begin (), key_list.end (), k);
+        key_list_iterator q
+          = std::find (key_list.begin (), key_list.end (), k);
 
-          assert (q != key_list.end ());
+        assert (q != key_list.end ());
 
-          key_list.erase (q);
-        }
-    }
+        key_list.erase (q);
+      }
+  }
 
   iterator begin (void) { return iterator (map.begin ()); }
   const_iterator begin (void) const { return const_iterator (map.begin ()); }
 
   iterator end (void) { return iterator (map.end ()); }
   const_iterator end (void) const { return const_iterator (map.end ()); }
 
   std::string key (const_iterator p) const { return p->first; }
 
   Cell& contents (const std::string& k);
   Cell contents (const std::string& k) const;
 
   Cell& contents (iterator p)
-    { return p->second; }
+  { return p->second; }
 
   Cell contents (const_iterator p) const
-    { return p->second; }
+  { return p->second; }
 
   int intfield (const std::string& k, int def_val = 0) const;
 
   std::string stringfield (const std::string& k,
                            const std::string& def_val = std::string ()) const;
 
   iterator seek (const std::string& k) { return map.find (k); }
   const_iterator seek (const std::string& k) const { return map.find (k); }
 
   bool contains (const std::string& k) const
-    { return (seek (k) != map.end ()); }
+  { return (seek (k) != map.end ()); }
 
   void clear (void)
-    {
-      map.clear ();
-      key_list.clear ();
-    }
+  {
+    map.clear ();
+    key_list.clear ();
+  }
 
   string_vector keys (void) const;
 
   octave_idx_type rows (void) const { return dimensions(0); }
 
   octave_idx_type columns (void) const { return dimensions(1); }
 
   dim_vector dims (void) const { return dimensions; }
@@ -617,17 +619,18 @@ Octave_map
   Octave_map transpose (void) const;
 
   Octave_map reshape (const dim_vector& new_dims) const;
 
   void resize (const dim_vector& dv, bool fill = false);
 
   octave_idx_type numel (void) const { return dimensions.numel (); }
 
-  Octave_map concat (const Octave_map& rb, const Array<octave_idx_type>& ra_idx);
+  Octave_map concat (const Octave_map& rb,
+                     const Array<octave_idx_type>& ra_idx);
 
   Octave_map& maybe_delete_elements (const octave_value_list& idx);
 
   Octave_map& assign (const octave_value_list& idx, const Octave_map& rhs);
 
   Octave_map& assign (const octave_value_list& idx, const std::string& k,
                       const Cell& rhs);
 
@@ -646,15 +649,15 @@ private:
   // An extra list of keys, so we can keep track of the order the keys
   // are added for compatibility with you know what.
   std::list<std::string> key_list;
 
   // The current size.
   mutable dim_vector dimensions;
 
   void maybe_add_to_key_list (const std::string& k)
-    {
-      if (! contains (k))
-        key_list.push_back (k);
-    }
+  {
+    if (! contains (k))
+      key_list.push_back (k);
+  }
 } GCC_ATTR_DEPRECATED;
 
 #endif
diff --git a/libinterp/corefcn/oct-obj.h b/libinterp/corefcn/oct-obj.h
--- a/libinterp/corefcn/oct-obj.h
+++ b/libinterp/corefcn/oct-obj.h
@@ -62,25 +62,25 @@ public:
     : data (obj.data), names (obj.names) { }
 
   // Concatenation constructor.
   octave_value_list (const std::list<octave_value_list>&);
 
   ~octave_value_list (void) { }
 
   octave_value_list& operator = (const octave_value_list& obj)
-    {
-      if (this != &obj)
-        {
-          data = obj.data;
-          names = obj.names;
-        }
+  {
+    if (this != &obj)
+      {
+        data = obj.data;
+        names = obj.names;
+      }
 
-      return *this;
-    }
+    return *this;
+  }
 
   Array<octave_value> array_value (void) const { return data; }
 
   Cell cell_value (void) const { return array_value (); }
 
   // Assignment will resize on range errors.
 
   octave_value& operator () (octave_idx_type n) { return elem (n); }
@@ -101,23 +101,24 @@ public:
   octave_value_list& append (const octave_value& val);
 
   octave_value_list& append (const octave_value_list& lst);
 
   octave_value_list& reverse (void);
 
   octave_value_list
   slice (octave_idx_type offset, octave_idx_type len, bool tags = false) const
-    {
-      octave_value_list retval (data.linear_slice (offset, offset + len));
-      if (tags && len > 0 && names.length () > 0)
-        retval.names = names.linear_slice (offset, std::min (len, names.length ()));
+  {
+    octave_value_list retval (data.linear_slice (offset, offset + len));
+    if (tags && len > 0 && names.length () > 0)
+      retval.names = names.linear_slice (offset,
+                                         std::min (len, names.length ()));
 
-      return retval;
-    }
+    return retval;
+  }
 
   octave_value_list
   splice (octave_idx_type offset, octave_idx_type len,
           const octave_value_list& lst = octave_value_list ()) const;
 
   bool all_strings_p (void) const;
 
   bool all_scalars (void) const;
@@ -130,43 +131,43 @@ public:
 
   void stash_name_tags (const string_vector& nm) { names = nm; }
 
   string_vector name_tags (void) const { return names; }
 
   void make_storable_values (void);
 
   octave_value& xelem (octave_idx_type i)
-    {
-      return data.xelem (i);
-    }
+  {
+    return data.xelem (i);
+  }
 
   void clear (void)
-    {
-      data.clear ();
-    }
+  {
+    data.clear ();
+  }
 
 private:
 
   Array<octave_value> data;
 
   // This list of strings can be used to tag each element of data with
   // a name.  By default, it is empty.
   string_vector names;
 
   octave_value& elem (octave_idx_type n)
-    {
-      if (n >= length ())
-        resize (n + 1);
+  {
+    if (n >= length ())
+      resize (n + 1);
 
-      return data(n);
-    }
+    return data(n);
+  }
 
   const octave_value& elem (octave_idx_type n) const
-    { return data(n); }
+  { return data(n); }
 
   DECLARE_OCTAVE_ALLOCATOR
 };
 
 // Make it easy to build argument lists for built-in functions or for
 // returning values.
 
 inline octave_value_list
diff --git a/libinterp/corefcn/oct-prcstrm.h b/libinterp/corefcn/oct-prcstrm.h
--- a/libinterp/corefcn/oct-prcstrm.h
+++ b/libinterp/corefcn/oct-prcstrm.h
@@ -20,18 +20,18 @@ along with Octave; see the file COPYING.
 
 */
 
 #if !defined (octave_octave_procstream_h)
 #define octave_octave_procstream_h 1
 
 #include "oct-stdstrm.h"
 
-// FIXME -- why don't these classes use iprocstream and
-// oprocstream, which in turn use the octave_procbuf class?
+// FIXME: why don't these classes use iprocstream and oprocstream,
+//        which in turn use the octave_procbuf class?
 
 class
 octave_iprocstream : public octave_stdiostream
 {
 public:
 
   octave_iprocstream (const std::string& n,
                       std::ios::openmode arg_md = std::ios::in,
diff --git a/libinterp/corefcn/oct-stdstrm.h b/libinterp/corefcn/oct-stdstrm.h
--- a/libinterp/corefcn/oct-stdstrm.h
+++ b/libinterp/corefcn/oct-stdstrm.h
@@ -39,17 +39,17 @@ public:
                        typename BUF_T::close_fcn cf = BUF_T::file_close)
     : octave_base_stream (m, ff), nm (n), md (m),
       s (f ? new STREAM_T (f, cf) : 0), fnum (fid)
   { }
 
   // Position a stream at OFFSET relative to ORIGIN.
 
   int seek (off_t offset, int origin)
-    { return s ? s->seek (offset, origin) : -1; }
+  { return s ? s->seek (offset, origin) : -1; }
 
   // Return current stream position.
 
   off_t tell (void) { return s ? s->tell () : -1; }
 
   // Return non-zero if EOF has been reached on this stream.
 
   bool eof (void) const { return s ? s->eof () : true; }
@@ -57,19 +57,19 @@ public:
   // The name of the file.
 
   std::string name (void) const { return nm; }
 
   std::istream *input_stream (void) { return (md & std::ios::in) ? s : 0; }
 
   std::ostream *output_stream (void) { return (md & std::ios::out) ? s : 0; }
 
-  // FIXME -- should not have to cast away const here.
+  // FIXME: should not have to cast away const here.
   BUF_T *rdbuf (void) const
-    { return s ? (const_cast<STREAM_T *> (s))->rdbuf () : 0; }
+  { return s ? (const_cast<STREAM_T *> (s))->rdbuf () : 0; }
 
   int file_number (void) const { return fnum; }
 
   bool bad (void) const { return s ? s->bad () : true; }
 
   void clear (void) { if (s) s->clear (); }
 
   void do_close (void) { if (s) s->stream_close (); }
@@ -102,17 +102,18 @@ octave_stdiostream
 {
 public:
 
   octave_stdiostream (const std::string& n, FILE *f = 0,
                       std::ios::openmode m = std::ios::in|std::ios::out,
                       oct_mach_info::float_format ff
                         = oct_mach_info::native_float_format (),
                       c_file_ptr_buf::close_fcn cf = c_file_ptr_buf::file_close)
-    : octave_tstdiostream<c_file_ptr_buf, io_c_file_ptr_stream, FILE *> (n, f, f ? fileno (f) : -1, m, ff, cf) { }
+    : octave_tstdiostream<c_file_ptr_buf, io_c_file_ptr_stream, FILE *>
+       (n, f, f ? fileno (f) : -1, m, ff, cf) { }
 
   static octave_stream
   create (const std::string& n, FILE *f = 0,
           std::ios::openmode m = std::ios::in|std::ios::out,
           oct_mach_info::float_format ff
             = oct_mach_info::native_float_format (),
           c_file_ptr_buf::close_fcn cf = c_file_ptr_buf::file_close)
   {
@@ -139,18 +140,20 @@ octave_zstdiostream
   : public octave_tstdiostream<c_zfile_ptr_buf, io_c_zfile_ptr_stream, gzFile>
 {
 public:
 
   octave_zstdiostream (const std::string& n, gzFile f = 0, int fid = 0,
                        std::ios::openmode m = std::ios::in|std::ios::out,
                        oct_mach_info::float_format ff
                          = oct_mach_info::native_float_format (),
-                       c_zfile_ptr_buf::close_fcn cf = c_zfile_ptr_buf::file_close)
-    : octave_tstdiostream<c_zfile_ptr_buf, io_c_zfile_ptr_stream, gzFile> (n, f, fid, m, ff, cf) { }
+                       c_zfile_ptr_buf::close_fcn cf
+                         = c_zfile_ptr_buf::file_close)
+    : octave_tstdiostream<c_zfile_ptr_buf, io_c_zfile_ptr_stream, gzFile>
+       (n, f, fid, m, ff, cf) { }
 
   static octave_stream
   create (const std::string& n, gzFile f = 0, int fid = 0,
           std::ios::openmode m = std::ios::in|std::ios::out,
           oct_mach_info::float_format ff
             = oct_mach_info::native_float_format (),
           c_zfile_ptr_buf::close_fcn cf = c_zfile_ptr_buf::file_close)
   {
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -107,18 +107,18 @@ get_size (double d, const std::string& w
     }
   else
     ::error ("%s: NaN is invalid as size specification", who.c_str ());
 
   return retval;
 }
 
 static void
-get_size (const Array<double>& size, octave_idx_type& nr, octave_idx_type& nc, bool& one_elt_size_spec,
-          const std::string& who)
+get_size (const Array<double>& size, octave_idx_type& nr, octave_idx_type& nc,
+          bool& one_elt_size_spec, const std::string& who)
 {
   nr = -1;
   nc = -1;
 
   one_elt_size_spec = false;
 
   double dnr = -1.0;
   double dnc = -1.0;
@@ -279,17 +279,18 @@ expand_char_class (const std::string& s)
 
   size_t i = 0;
 
   while (i < len)
     {
       unsigned char c = s[i++];
 
       if (c == '-' && i > 1 && i < len
-          && static_cast<unsigned char> (s[i-2]) <= static_cast<unsigned char> (s[i]))
+          && (   static_cast<unsigned char> (s[i-2])
+              <= static_cast<unsigned char> (s[i])))
         {
           // Add all characters from the range except the first (we
           // already added it below).
 
           for (c = s[i-2]+1; c < s[i]; c++)
             retval += c;
         }
       else
@@ -472,17 +473,17 @@ scanf_format_list::finish_conversion (co
 
       nconv++;
     }
 
   if (nconv >= 0)
     {
       if (beg_idx != std::string::npos && end_idx != std::string::npos)
         char_class = expand_char_class (s.substr (beg_idx,
-                                                  end_idx - beg_idx + 1));
+                                        end_idx - beg_idx + 1));
 
       add_elt_to_list (width, discard, type, modifier, num_elts, char_class);
     }
 
   return retval;
 }
 
 void
@@ -694,19 +695,20 @@ printf_format_list::add_elt_to_list (int
         }
 
       delete buf;
       buf = 0;
     }
 }
 
 void
-printf_format_list::process_conversion
-  (const std::string& s, size_t& i, size_t n, int& args, std::string& flags,
-   int& fw, int& prec, char& modifier, char& type, octave_idx_type& num_elts)
+printf_format_list::process_conversion (const std::string& s, size_t& i,
+                                        size_t n, int& args, std::string& flags,
+                                        int& fw, int& prec, char& modifier,
+                                        char& type, octave_idx_type& num_elts)
 {
   args = 0;
   flags = "";
   fw = 0;
   prec = 0;
   modifier = '\0';
   type = '\0';
 
@@ -797,20 +799,20 @@ printf_format_list::process_conversion
 
   if (i < n)
     finish_conversion (s, i, args, flags, fw, prec, modifier, type, num_elts);
   else
     nconv = -1;
 }
 
 void
-printf_format_list::finish_conversion
-  (const std::string& s, size_t& i, int args, const std::string& flags,
-   int fw, int prec, char modifier, char& type, octave_idx_type& num_elts)
-
+printf_format_list::finish_conversion (const std::string& s, size_t& i,
+                                       int args, const std::string& flags,
+                                       int fw, int prec, char modifier,
+                                       char& type, octave_idx_type& num_elts)
 {
   switch (s[i])
     {
     case 'd': case 'i': case 'o': case 'x': case 'X':
     case 'u': case 'c':
       if (modifier == 'L')
         {
           nconv = -1;
@@ -1012,23 +1014,25 @@ octave_base_stream::do_gets (octave_idx_
       err = true;
       invalid_operation (who, "reading");
     }
 
   return retval;
 }
 
 std::string
-octave_base_stream::getl (octave_idx_type max_len, bool& err, const std::string& who)
+octave_base_stream::getl (octave_idx_type max_len, bool& err,
+                          const std::string& who)
 {
   return do_gets (max_len, err, true, who);
 }
 
 std::string
-octave_base_stream::gets (octave_idx_type max_len, bool& err, const std::string& who)
+octave_base_stream::gets (octave_idx_type max_len, bool& err,
+                          const std::string& who)
 {
   return do_gets (max_len, err, false, who);
 }
 
 off_t
 octave_base_stream::skipl (off_t num, bool& err, const std::string& who)
 {
   off_t cnt = -1;
@@ -1062,17 +1066,17 @@ octave_base_stream::skipl (off_t num, bo
                 break;
             }
 
           lastc = c;
         }
 
       // Maybe eat the following \n if \r was just met.
       if (c == '\r' && is.peek () == '\n')
-       is.get ();
+        is.get ();
 
       if (is.bad ())
         {
           err = true;
           error (who, "read error");
         }
 
       if (err)
@@ -1222,18 +1226,18 @@ octave_scan<> (std::istream& is, const s
 
   return is;
 }
 
 template <class T>
 void
 do_scanf_conv (std::istream& is, const scanf_format_elt& fmt,
                T valptr, Matrix& mval, double *data, octave_idx_type& idx,
-               octave_idx_type& conversion_count, octave_idx_type nr, octave_idx_type max_size,
-               bool discard)
+               octave_idx_type& conversion_count, octave_idx_type nr,
+               octave_idx_type max_size, bool discard)
 {
   OCTAVE_SCAN (is, fmt, valptr);
 
   if (is)
     {
       if (idx == max_size && ! discard)
         {
           max_size *= 2;
@@ -1251,17 +1255,18 @@ do_scanf_conv (std::istream& is, const s
           conversion_count++;
           data[idx++] = *(valptr);
         }
     }
 }
 
 template void
 do_scanf_conv (std::istream&, const scanf_format_elt&, double*,
-               Matrix&, double*, octave_idx_type&, octave_idx_type&, octave_idx_type, octave_idx_type, bool);
+               Matrix&, double*, octave_idx_type&, octave_idx_type&,
+               octave_idx_type, octave_idx_type, bool);
 
 #define DO_WHITESPACE_CONVERSION() \
   do \
     { \
       int c = EOF; \
  \
       while (is && (c = is.get ()) != EOF && isspace (c)) \
         /* skip whitespace */; \
@@ -1468,18 +1473,20 @@ do_scanf_conv (std::istream&, const scan
                 } \
             } \
         } \
     } \
   while (0)
 
 octave_value
 octave_base_stream::do_scanf (scanf_format_list& fmt_list,
-                              octave_idx_type nr, octave_idx_type nc, bool one_elt_size_spec,
-                              octave_idx_type& conversion_count, const std::string& who)
+                              octave_idx_type nr, octave_idx_type nc,
+                              bool one_elt_size_spec,
+                              octave_idx_type& conversion_count,
+                              const std::string& who)
 {
   octave_value retval = Matrix ();
 
   if ((interactive || forced_interactive) && file_number () == 0)
     {
       ::error ("%s: unable to read from stdin while running interactively",
                who.c_str ());
 
@@ -1799,17 +1806,17 @@ octave_base_stream::do_scanf (scanf_form
                     }
 
                   // If it looks like we have a matching failure, then
                   // reset the failbit in the stream state.
 
                   if (is.rdstate () & std::ios::failbit)
                     is.clear (is.rdstate () & (~std::ios::failbit));
 
-                  // FIXME -- is this the right thing to do?
+                  // FIXME: is this the right thing to do?
 
                   if (interactive && name () == "stdin")
                     {
                       is.clear ();
 
                       // Skip to end of line.
 
                       bool err;
@@ -1855,42 +1862,43 @@ octave_base_stream::do_scanf (scanf_form
         retval = retval.convert_to_str (false, true);
     }
 
   return retval;
 }
 
 octave_value
 octave_base_stream::scanf (const std::string& fmt, const Array<double>& size,
-                           octave_idx_type& conversion_count, const std::string& who)
+                           octave_idx_type& conversion_count,
+                           const std::string& who)
 {
   octave_value retval = Matrix ();
 
   conversion_count = 0;
 
   std::istream *isp = input_stream ();
 
   if (isp)
     {
       scanf_format_list fmt_list (fmt);
 
       if (fmt_list.num_conversions () == -1)
         ::error ("%s: invalid format specified", who.c_str ());
       else
         {
-        octave_idx_type nr = -1;
-        octave_idx_type nc = -1;
-
-        bool one_elt_size_spec;
-
-        get_size (size, nr, nc, one_elt_size_spec, who);
-
-        if (! error_state)
-          retval = do_scanf (fmt_list, nr, nc, one_elt_size_spec,
-                             conversion_count, who);
+          octave_idx_type nr = -1;
+          octave_idx_type nc = -1;
+
+          bool one_elt_size_spec;
+
+          get_size (size, nr, nc, one_elt_size_spec, who);
+
+          if (! error_state)
+            retval = do_scanf (fmt_list, nr, nc, one_elt_size_spec,
+                               conversion_count, who);
         }
     }
   else
     invalid_operation (who, "reading");
 
   return retval;
 }
 
@@ -2023,17 +2031,17 @@ octave_base_stream::do_oscanf (const sca
               break;
             }
         }
 
       if (ok () && is.fail ())
         {
           error ("%s: read error", who.c_str ());
 
-          // FIXME -- is this the right thing to do?
+          // FIXME: is this the right thing to do?
 
           if (interactive && name () == "stdin")
             {
               // Skip to end of line.
 
               bool err;
               do_gets (-1, err, false, who);
             }
@@ -2455,17 +2463,18 @@ octave_base_stream::do_printf (printf_fo
                       if (lo_ieee_isnan (val) || xisinf (val))
                         {
                           std::string tfmt = fmt;
                           std::string::size_type i1, i2;
 
                           tfmt.replace ((i1 = tfmt.rfind (elt->type)),
                                         1, 1, 's');
 
-                          if ((i2 = tfmt.rfind ('.')) != std::string::npos && i2 < i1)
+                          if ((i2 = tfmt.rfind ('.')) != std::string::npos
+                              && i2 < i1)
                             {
                               tfmt.erase (i2, i1-i2);
                               if (elt->prec < 0)
                                 nsa--;
                             }
 
                           const char *tval;
                           if (xisinf (val))
@@ -2494,19 +2503,18 @@ octave_base_stream::do_printf (printf_fo
                               break;
 
                             case 'o': case 'x': case 'X': case 'u':
                               DO_DOUBLE_CONV (unsigned);
                               break;
 
                             case 'f': case 'e': case 'E':
                             case 'g': case 'G':
-                              retval
-                                += do_printf_conv (os, fmt, nsa, sa_1, sa_2,
-                                                   val, who);
+                              retval += do_printf_conv (os, fmt, nsa,
+                                                        sa_1, sa_2, val, who);
                               break;
 
                             default:
                               error ("%s: invalid format specifier",
                                      who.c_str ());
                               return -1;
                               break;
                             }
@@ -2568,17 +2576,17 @@ octave_base_stream::puts (const std::str
   if (osp)
     {
       std::ostream& os = *osp;
 
       os << s;
 
       if (os)
         {
-          // FIXME -- why does this seem to be necessary?
+          // FIXME: why does this seem to be necessary?
           // Without it, output from a loop like
           //
           //   for i = 1:100, fputs (stdout, "foo\n"); endfor
           //
           // doesn't seem to go to the pager immediately.
 
           os.flush ();
 
@@ -2754,17 +2762,18 @@ octave_stream::skipl (off_t count, bool&
 
   if (stream_ok ())
     retval = rep->skipl (count, err, who);
 
   return retval;
 }
 
 off_t
-octave_stream::skipl (const octave_value& tc_count, bool& err, const std::string& who)
+octave_stream::skipl (const octave_value& tc_count, bool& err,
+                      const std::string& who)
 {
   off_t retval = -1;
 
   err = false;
 
   int conv_err = 0;
 
   int count = 1;
@@ -2861,18 +2870,17 @@ octave_stream::seek (off_t offset, int o
 }
 
 int
 octave_stream::seek (const octave_value& tc_offset,
                      const octave_value& tc_origin)
 {
   int retval = -1;
 
-  // FIXME -- should we have octave_value methods that handle off_t
-  // explicitly?
+  // FIXME: should we have octave_value methods that handle off_t explicitly?
   octave_int64 val = tc_offset.int64_scalar_value ();
   off_t xoffset = val.value ();
 
   if (! error_state)
     {
       int conv_err = 0;
 
       int origin = SEEK_SET;
@@ -3141,17 +3149,17 @@ octave_stream::finalize_read (std::list<
       break;
 
     default:
       retval = false;
       (*current_liboctave_error_handler)
         ("read: invalid type specification");
       break;
     }
-  
+
 
   return retval;
 }
 
 octave_value
 octave_stream::read (const Array<double>& size, octave_idx_type block_size,
                      oct_data_conv::data_type input_type,
                      oct_data_conv::data_type output_type,
@@ -3162,30 +3170,31 @@ octave_stream::read (const Array<double>
 
   octave_idx_type nr = -1;
   octave_idx_type nc = -1;
 
   bool one_elt_size_spec = false;
 
   if (stream_ok ())
     {
-      // FIXME -- we may eventually want to make this extensible.
-
-      // FIXME -- we need a better way to ensure that this
+      // FIXME: we may eventually want to make this extensible.
+
+      // FIXME: we need a better way to ensure that this
       // numbering stays consistent with the order of the elements in the
       // data_type enum in the oct_data_conv class.
 
       char_count = 0;
 
       get_size (size, nr, nc, one_elt_size_spec, "fread");
 
       if (! error_state)
         {
 
-          octave_idx_type elts_to_read = std::numeric_limits<octave_idx_type>::max ();
+          octave_idx_type elts_to_read
+            = std::numeric_limits<octave_idx_type>::max ();
 
           if (one_elt_size_spec)
             {
               // If NR == 0, Matlab returns [](0x0).
 
               // If NR > 0, the result will be a column vector with the given
               // number of rows.
 
@@ -3204,17 +3213,17 @@ octave_stream::read (const Array<double>
 
               // If NC < 0 we have [NR, Inf] and we'll wait to decide how big NC
               // should be.
 
               if (nr == 0 || nc == 0)
                 nr = nc = 0;
             }
 
-          // FIXME -- ensure that this does not overflow.
+          // FIXME: ensure that this does not overflow.
 
           elts_to_read = nr * nc;
 
           bool read_to_eof = elts_to_read < 0;
 
           octave_idx_type input_buf_elts = -1;
 
           if (skip == 0)
@@ -3222,35 +3231,38 @@ octave_stream::read (const Array<double>
               if (read_to_eof)
                 input_buf_elts = 1024 * 1024;
               else
                 input_buf_elts = elts_to_read;
             }
           else
             input_buf_elts = block_size;
 
-          octave_idx_type input_elt_size = oct_data_conv::data_type_size (input_type);
+          octave_idx_type input_elt_size
+            = oct_data_conv::data_type_size (input_type);
 
           octave_idx_type input_buf_size = input_buf_elts * input_elt_size;
 
           assert (input_buf_size >= 0);
 
-          // Must also work and return correct type object for 0 elements to read.
+          // Must also work and return correct type object
+          // for 0 elements to read.
 
           std::istream *isp = input_stream ();
 
           if (isp)
             {
               std::istream& is = *isp;
 
               std::list <void *> input_buf_list;
 
               octave_idx_type elts_read = 0;
 
-              while (is && ! is.eof () && (read_to_eof || elts_read < elts_to_read))
+              while (is && ! is.eof ()
+                     && (read_to_eof || elts_read < elts_to_read))
                 {
                   char *input_buf = new char [input_buf_size];
 
                   is.read (input_buf, input_buf_size);
 
                   size_t count = is.gcount ();
 
                   char_count += count;
@@ -3286,30 +3298,30 @@ octave_stream::read (const Array<double>
         invalid_operation ("fread", "reading");
     }
 
   return retval;
 }
 
 octave_idx_type
 octave_stream::write (const octave_value& data, octave_idx_type block_size,
-                      oct_data_conv::data_type output_type, octave_idx_type skip,
-                      oct_mach_info::float_format flt_fmt)
+                      oct_data_conv::data_type output_type,
+                      octave_idx_type skip, oct_mach_info::float_format flt_fmt)
 {
   octave_idx_type retval = -1;
 
   if (stream_ok ())
     {
       if (! error_state)
         {
           if (flt_fmt == oct_mach_info::flt_fmt_unknown)
             flt_fmt = float_format ();
 
           octave_idx_type status = data.write (*this, block_size, output_type,
-                                   skip, flt_fmt);
+                                               skip, flt_fmt);
 
           if (status < 0)
             error ("fwrite: write error");
           else
             retval = status;
         }
       else
         invalid_operation ("fwrite", "writing");
@@ -3479,17 +3491,17 @@ octave_stream::skip_bytes (size_t skip)
       seek (orig_pos, SEEK_SET);
 
       size_t remaining = eof_pos - orig_pos;
 
       if (remaining < skip)
         {
           seek (0, SEEK_END);
 
-          // FIXME -- probably should try to write larger blocks...
+          // FIXME: probably should try to write larger blocks...
 
           unsigned char zero = 0;
           for (size_t j = 0; j < skip - remaining; j++)
             os.write (reinterpret_cast<const char *> (&zero), 1);
         }
       else
         seek (skip, SEEK_CUR);
 
@@ -3502,24 +3514,22 @@ octave_stream::skip_bytes (size_t skip)
 
 template <class T>
 octave_idx_type
 octave_stream::write (const Array<T>& data, octave_idx_type block_size,
                       oct_data_conv::data_type output_type,
                       octave_idx_type skip,
                       oct_mach_info::float_format flt_fmt)
 {
-  bool swap
-    = ((oct_mach_info::words_big_endian ()
-        && flt_fmt == oct_mach_info::flt_fmt_ieee_little_endian)
-       || flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian);
-
-  bool do_data_conversion
-    = (swap || ! is_equivalent_type<T> (output_type) 
-       || flt_fmt != oct_mach_info::float_format ());
+  bool swap = ((oct_mach_info::words_big_endian ()
+                && flt_fmt == oct_mach_info::flt_fmt_ieee_little_endian)
+               || flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian);
+
+  bool do_data_conversion = (swap || ! is_equivalent_type<T> (output_type)
+                             || flt_fmt != oct_mach_info::float_format ());
 
   octave_idx_type nel = data.numel ();
 
   octave_idx_type chunk_size;
 
   if (skip != 0)
     chunk_size = block_size;
   else if (do_data_conversion)
@@ -3715,17 +3725,17 @@ octave_stream::puts (const std::string& 
   int retval = -1;
 
   if (stream_ok ())
     retval = rep->puts (s, who);
 
   return retval;
 }
 
-// FIXME -- maybe this should work for string arrays too.
+// FIXME: maybe this should work for string arrays too.
 
 int
 octave_stream::puts (const octave_value& tc_s, const std::string& who)
 {
   int retval = -1;
 
   if (tc_s.is_string ())
     {
@@ -3914,17 +3924,17 @@ octave_stream_list::list_open_files (voi
 {
   return (instance_ok ()) ? instance->do_list_open_files () : std::string ();
 }
 
 octave_value
 octave_stream_list::open_file_numbers (void)
 {
   return (instance_ok ())
-    ? instance->do_open_file_numbers () : octave_value ();
+         ? instance->do_open_file_numbers () : octave_value ();
 }
 
 int
 octave_stream_list::get_file_number (const octave_value& fid)
 {
   return (instance_ok ()) ? instance->do_get_file_number (fid) : -1;
 }
 
diff --git a/libinterp/corefcn/oct-stream.h b/libinterp/corefcn/oct-stream.h
--- a/libinterp/corefcn/oct-stream.h
+++ b/libinterp/corefcn/oct-stream.h
@@ -43,45 +43,45 @@ class octave_value_list;
 
 class
 OCTINTERP_API
 scanf_format_elt
 {
 public:
 
   enum special_conversion
-    {
-      whitespace_conversion = 1,
-      literal_conversion = 2
-    };
+  {
+    whitespace_conversion = 1,
+    literal_conversion = 2
+  };
 
   scanf_format_elt (const char *txt = 0, int w = 0, bool d = false,
                     char typ = '\0', char mod = '\0',
                     const std::string& ch_class = std::string ())
     : text (strsave (txt)), width (w), discard (d), type (typ),
       modifier (mod), char_class (ch_class) { }
 
   scanf_format_elt (const scanf_format_elt& e)
     : text (strsave (e.text)), width (e.width), discard (e.discard),
       type (e.type), modifier (e.modifier), char_class (e.char_class) { }
 
   scanf_format_elt& operator = (const scanf_format_elt& e)
-    {
-      if (this != &e)
-        {
-          text = strsave (e.text);
-          width = e.width;
-          discard = e.discard;
-          type = e.type;
-          modifier = e.modifier;
-          char_class = e.char_class;
-        }
+  {
+    if (this != &e)
+      {
+        text = strsave (e.text);
+        width = e.width;
+        discard = e.discard;
+        type = e.type;
+        modifier = e.modifier;
+        char_class = e.char_class;
+      }
 
-      return *this;
-    }
+    return *this;
+  }
 
   ~scanf_format_elt (void) { delete [] text; }
 
   // The C-style format string.
   const char *text;
 
   // The maximum field width.
   int width;
@@ -115,37 +115,37 @@ public:
   // The length can be different than the number of conversions.
   // For example, "x %d y %d z" has 2 conversions but the length of
   // the list is 3 because of the characters that appear after the
   // last conversion.
 
   octave_idx_type length (void) { return list.length (); }
 
   const scanf_format_elt *first (void)
-    {
-      curr_idx = 0;
-      return current ();
-    }
+  {
+    curr_idx = 0;
+    return current ();
+  }
 
   const scanf_format_elt *current (void) const
-    { return list.length () > 0 ? list.elem (curr_idx) : 0; }
+  { return list.length () > 0 ? list.elem (curr_idx) : 0; }
 
   const scanf_format_elt *next (bool cycle = true)
-    {
-      curr_idx++;
+  {
+    curr_idx++;
 
-      if (curr_idx >= list.length ())
-        {
-          if (cycle)
-            curr_idx = 0;
-          else
-            return 0;
-        }
-      return current ();
-    }
+    if (curr_idx >= list.length ())
+      {
+        if (cycle)
+          curr_idx = 0;
+        else
+          return 0;
+      }
+    return current ();
+  }
 
   void printme (void) const;
 
   bool ok (void) const { return (nconv >= 0); }
 
   operator bool () const { return ok (); }
 
   bool all_character_conversions (void);
@@ -156,17 +156,17 @@ private:
 
   // Number of conversions specified by this format string, or -1 if
   // invalid conversions have been found.
   octave_idx_type nconv;
 
   // Index to current element;
   octave_idx_type curr_idx;
 
-  // FIXME -- maybe LIST should be a std::list object?
+  // FIXME: maybe LIST should be a std::list object?
   // List of format elements.
   Array<scanf_format_elt*> list;
 
   // Temporary buffer.
   std::ostringstream *buf;
 
   void add_elt_to_list (int width, bool discard, char type, char modifier,
                         octave_idx_type& num_elts,
@@ -197,30 +197,30 @@ public:
     : text (strsave (txt)), args (n), fw (w), prec (p), flags (f),
       type (typ), modifier (mod) { }
 
   printf_format_elt (const printf_format_elt& e)
     : text (strsave (e.text)), args (e.args), fw (e.fw), prec (e.prec),
       flags (e.flags), type (e.type), modifier (e.modifier) { }
 
   printf_format_elt& operator = (const printf_format_elt& e)
-    {
-      if (this != &e)
-        {
-          text = strsave (e.text);
-          args = e.args;
-          fw = e.fw;
-          prec = e.prec;
-          flags = e.flags;
-          type = e.type;
-          modifier = e.modifier;
-        }
+  {
+    if (this != &e)
+      {
+        text = strsave (e.text);
+        args = e.args;
+        fw = e.fw;
+        prec = e.prec;
+        flags = e.flags;
+        type = e.type;
+        modifier = e.modifier;
+      }
 
-      return *this;
-    }
+    return *this;
+  }
 
   ~printf_format_elt (void) { delete [] text; }
 
   // The C-style format string.
   const char *text;
 
   // How many args do we expect to consume?
   int args;
@@ -250,38 +250,38 @@ public:
 
   printf_format_list (const std::string& fmt = std::string ());
 
   ~printf_format_list (void);
 
   octave_idx_type num_conversions (void) { return nconv; }
 
   const printf_format_elt *first (void)
-    {
-      curr_idx = 0;
-      return current ();
-    }
+  {
+    curr_idx = 0;
+    return current ();
+  }
 
   const printf_format_elt *current (void) const
-    { return list.length () > 0 ? list.elem (curr_idx) : 0; }
+  { return list.length () > 0 ? list.elem (curr_idx) : 0; }
 
   const printf_format_elt *next (bool cycle = true)
-    {
-      curr_idx++;
+  {
+    curr_idx++;
 
-      if (curr_idx >= list.length ())
-        {
-          if (cycle)
-            curr_idx = 0;
-          else
-            return 0;
-        }
+    if (curr_idx >= list.length ())
+      {
+        if (cycle)
+          curr_idx = 0;
+        else
+          return 0;
+      }
 
-      return current ();
-    }
+    return current ();
+  }
 
   bool last_elt_p (void) { return (curr_idx + 1 == list.length ()); }
 
   void printme (void) const;
 
   bool ok (void) const { return (nconv >= 0); }
 
   operator bool () const { return ok (); }
@@ -290,17 +290,17 @@ private:
 
   // Number of conversions specified by this format string, or -1 if
   // invalid conversions have been found.
   octave_idx_type nconv;
 
   // Index to current element;
   octave_idx_type curr_idx;
 
-  // FIXME -- maybe LIST should be a std::list object?
+  // FIXME: maybe LIST should be a std::list object?
   // List of format elements.
   Array<printf_format_elt*> list;
 
   // Temporary buffer.
   std::ostringstream *buf;
 
   void add_elt_to_list (int args, const std::string& flags, int fw,
                         int prec, char type, char modifier,
@@ -324,17 +324,17 @@ private:
 };
 
 // Provide an interface for Octave streams.
 
 class
 OCTINTERP_API
 octave_base_stream
 {
-friend class octave_stream;
+  friend class octave_stream;
 
 public:
 
   octave_base_stream (std::ios::openmode arg_md = std::ios::in|std::ios::out,
                       oct_mach_info::float_format ff
                         = oct_mach_info::native_float_format ())
     : count (0), md (arg_md), flt_fmt (ff), fail (false), open_state (true),
       errmsg ()
@@ -375,23 +375,23 @@ public:
 
   // Return TRUE if this stream is open.
 
   bool is_open (void) const { return open_state; }
 
   virtual void do_close (void) { }
 
   void close (void)
-    {
-      if (is_open ())
-        {
-          open_state = false;
-          do_close ();
-        }
-    }
+  {
+    if (is_open ())
+      {
+        open_state = false;
+        do_close ();
+      }
+  }
 
   virtual int file_number (void) const
   {
     // Kluge alert!
 
     if (name () == "stdin")
       return 0;
     else if (name () == "stdout")
@@ -449,21 +449,24 @@ private:
   std::string errmsg;
 
   // Functions that are defined for all input streams (input streams
   // are those that define is).
 
   std::string do_gets (octave_idx_type max_len, bool& err, bool strip_newline,
                        const std::string& who /* = "gets" */);
 
-  std::string getl (octave_idx_type max_len, bool& err, const std::string& who /* = "getl" */);
-  std::string gets (octave_idx_type max_len, bool& err, const std::string& who /* = "gets" */);
+  std::string getl (octave_idx_type max_len, bool& err,
+                    const std::string& who /* = "getl" */);
+  std::string gets (octave_idx_type max_len, bool& err,
+                    const std::string& who /* = "gets" */);
   off_t skipl (off_t count, bool& err, const std::string& who /* = "skipl" */);
 
-  octave_value do_scanf (scanf_format_list& fmt_list, octave_idx_type nr, octave_idx_type nc,
+  octave_value do_scanf (scanf_format_list& fmt_list, octave_idx_type nr,
+                         octave_idx_type nc,
                          bool one_elt_size_spec, octave_idx_type& count,
                          const std::string& who /* = "scanf" */);
 
   octave_value scanf (const std::string& fmt, const Array<double>& size,
                       octave_idx_type& count, const std::string& who /* = "scanf" */);
 
   bool do_oscanf (const scanf_format_elt *elt, octave_value&,
                   const std::string& who /* = "scanf" */);
@@ -507,26 +510,29 @@ public:
   ~octave_stream (void);
 
   octave_stream (const octave_stream&);
 
   octave_stream& operator = (const octave_stream&);
 
   int flush (void);
 
-  std::string getl (octave_idx_type max_len, bool& err, const std::string& who /* = "getl" */);
+  std::string getl (octave_idx_type max_len, bool& err,
+                    const std::string& who /* = "getl" */);
   std::string getl (const octave_value& max_len, bool& err,
                     const std::string& who /* = "getl" */);
 
-  std::string gets (octave_idx_type max_len, bool& err, const std::string& who /* = "gets" */);
+  std::string gets (octave_idx_type max_len, bool& err,
+                    const std::string& who /* = "gets" */);
   std::string gets (const octave_value& max_len, bool& err,
                     const std::string& who /* = "gets" */);
 
   off_t skipl (off_t count, bool& err, const std::string& who /* = "skipl" */);
-  off_t skipl (const octave_value& count, bool& err, const std::string& who /* = "skipl" */);
+  off_t skipl (const octave_value& count, bool& err,
+               const std::string& who /* = "skipl" */);
 
   int seek (off_t offset, int origin);
   int seek (const octave_value& offset, const octave_value& origin);
 
   off_t tell (void);
 
   int rewind (void);
 
@@ -576,28 +582,28 @@ public:
   int puts (const std::string& s, const std::string& who /* = "puts" */);
   int puts (const octave_value& s, const std::string& who /* = "puts" */);
 
   bool eof (void) const;
 
   std::string error (bool clear, int& err_num);
 
   std::string error (bool clear = false)
-    {
-      int err_num;
-      return error (clear, err_num);
-    }
+  {
+    int err_num;
+    return error (clear, err_num);
+  }
 
   // Set the error message and state.
 
   void error (const std::string& msg)
-    {
-      if (rep)
-        rep->error (msg);
-    }
+  {
+    if (rep)
+      rep->error (msg);
+  }
 
   void error (const char *msg) { error (std::string (msg)); }
 
   int file_number (void) { return rep ? rep->file_number () : -1; }
 
   bool is_valid (void) const { return (rep != 0); }
 
   bool ok (void) const { return rep && rep->ok (); }
@@ -625,35 +631,35 @@ public:
   void clearerr (void) { if (rep) rep->clearerr (); }
 
 private:
 
   // The actual representation of this stream.
   octave_base_stream *rep;
 
   bool stream_ok (bool clear = true) const
-    {
-      bool retval = true;
+  {
+    bool retval = true;
 
-      if (rep)
-        {
-          if (clear)
-            rep->clear ();
-        }
-      else
-        retval = false;
+    if (rep)
+      {
+        if (clear)
+          rep->clear ();
+      }
+    else
+      retval = false;
 
-      return retval;
-    }
+    return retval;
+  }
 
   void invalid_operation (const std::string& who, const char *rw)
-    {
-      if (rep)
-        rep->invalid_operation (who, rw);
-    }
+  {
+    if (rep)
+      rep->invalid_operation (who, rw);
+  }
 
   octave_value
   finalize_read (std::list<void *>& input_buf_list,
                  octave_idx_type input_buf_elts,
                  octave_idx_type elts_read,
                  octave_idx_type nr, octave_idx_type nc,
                  oct_data_conv::data_type input_type,
                  oct_data_conv::data_type output_type,
@@ -706,22 +712,24 @@ private:
   mutable ostrl_map::const_iterator lookup_cache;
 
   static octave_stream_list *instance;
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
 
   int do_insert (octave_stream& os);
 
-  octave_stream do_lookup (int fid, const std::string& who = std::string ()) const;
+  octave_stream do_lookup (int fid,
+                           const std::string& who = std::string ()) const;
   octave_stream do_lookup (const octave_value& fid,
                            const std::string& who = std::string ()) const;
 
   int do_remove (int fid, const std::string& who = std::string ());
-  int do_remove (const octave_value& fid, const std::string& who = std::string ());
+  int do_remove (const octave_value& fid,
+                 const std::string& who = std::string ());
 
   void do_clear (bool flush = true);
 
   string_vector do_get_info (int fid) const;
   string_vector do_get_info (const octave_value& fid) const;
 
   std::string do_list_open_files (void) const;
 
diff --git a/libinterp/corefcn/octave-link.cc b/libinterp/corefcn/octave-link.cc
--- a/libinterp/corefcn/octave-link.cc
+++ b/libinterp/corefcn/octave-link.cc
@@ -98,26 +98,26 @@ octave_link::do_discard_events (void)
   event_queue_mutex->lock ();
 
   gui_event_queue.discard ();
 
   event_queue_mutex->unlock ();
 }
 
 DEFUN (__octave_link_enabled__, , ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __octave_link_enabled__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   return octave_value (octave_link::enabled ());
 }
 
 DEFUN (__octave_link_edit_file__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __octave_link_edit_file__ (@var{file})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
@@ -132,17 +132,17 @@ Undocumented internal function.\n\
       else
         error ("expecting file name as argument");
     }
 
   return retval;
 }
 
 DEFUN (__octave_link_message_dialog__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __octave_link_message_dialog__ (@var{dlg}, @var{msg}, @var{title})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 3)
     {
@@ -159,17 +159,17 @@ Undocumented internal function.\n\
       else
         error ("invalid arguments");
     }
 
   return retval;
 }
 
 DEFUN (__octave_link_question_dialog__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __octave_link_question_dialog__ (@var{msg}, @var{title}, @var{btn1}, @var{btn2}, @var{btn3}, @var{default})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 6)
     {
@@ -179,27 +179,28 @@ Undocumented internal function.\n\
       std::string btn2   = args(3).string_value ();
       std::string btn3   = args(4).string_value ();
       std::string btndef = args(5).string_value ();
 
       if (! error_state)
         {
           flush_octave_stdout ();
 
-          retval = octave_link::question_dialog (msg, title, btn1, btn2, btn3, btndef);
+          retval = octave_link::question_dialog (msg, title, btn1, btn2, btn3,
+                                                 btndef);
         }
       else
         error ("invalid arguments");
     }
 
   return retval;
 }
 
 DEFUN (__octave_link_file_dialog__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __octave_link_file_dialog__ (@var{filterlist}, @var{title}, @var{filename}, @var{size} @var{multiselect}, @var{pathname})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 6)
     {
@@ -269,17 +270,17 @@ Undocumented internal function.\n\
       else
         error ("invalid arguments");
     }
 
   return retval;
 }
 
 DEFUN (__octave_link_list_dialog__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __octave_link_list_dialog__ (@var{list}, @var{mode}, @var{size}, @var{intial}, @var{name}, @var{prompt}, @var{ok_string}, @var{cancel_string})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 8)
     {
@@ -337,17 +338,17 @@ Undocumented internal function.\n\
       else
         error ("invalid arguments");
     }
 
   return retval;
 }
 
 DEFUN (__octave_link_input_dialog__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __octave_link_input_dialog__ (@var{prompt}, @var{title}, @var{rowscols}, @var{defaults})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 4)
     {
@@ -399,30 +400,30 @@ Undocumented internal function.\n\
       else
         error ("invalid arguments");
     }
 
   return retval;
 }
 
 DEFUN (__octave_link_show_preferences__, , ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __octave_link_show_preferences__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   retval = octave_link::show_preferences ();
 
   return retval;
 }
 
 DEFUN (__octave_link_show_doc__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __octave_link_show_doc__ ( @var{filename} )\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
   std::string file;
 
   if (args.length () >= 1)
diff --git a/libinterp/corefcn/octave-link.h b/libinterp/corefcn/octave-link.h
--- a/libinterp/corefcn/octave-link.h
+++ b/libinterp/corefcn/octave-link.h
@@ -158,53 +158,55 @@ public:
                int width, int height,
                const std::list<int>& initial_value,
                const std::string& name,
                const std::list<std::string>& prompt,
                const std::string& ok_string,
                const std::string& cancel_string)
   {
     return enabled ()
-      ? instance->do_list_dialog (list, mode, width, height,
-                                  initial_value, name, prompt,
-                                  ok_string, cancel_string)
-      : std::pair<std::list<int>, int> ();
+           ? instance->do_list_dialog (list, mode, width, height,
+                                       initial_value, name, prompt,
+                                       ok_string, cancel_string)
+           : std::pair<std::list<int>, int> ();
   }
 
   static std::list<std::string>
   input_dialog (const std::list<std::string>& prompt,
                 const std::string& title,
                 const std::list<float>& nr,
                 const std::list<float>& nc,
                 const std::list<std::string>& defaults)
   {
     return enabled ()
-      ? instance->do_input_dialog (prompt, title, nr, nc, defaults)
-      : std::list<std::string> ();
+           ? instance->do_input_dialog (prompt, title, nr, nc, defaults)
+           : std::list<std::string> ();
   }
 
   typedef std::list<std::pair<std::string, std::string> > filter_list;
 
   static std::list<std::string>
   file_dialog (const filter_list& filter, const std::string& title,
                const std::string& filename, const std::string& dirname,
                const std::string& multimode)
   {
     return enabled ()
-      ? instance->do_file_dialog (filter, title, filename, dirname, multimode)
-      : std::list<std::string> ();
+           ? instance->do_file_dialog (filter, title, filename, dirname,
+                                       multimode)
+           : std::list<std::string> ();
   }
 
 
   static int debug_cd_or_addpath_error (const std::string& file,
                                         const std::string& dir,
                                         bool addpath_option)
   {
     return enabled ()
-      ? instance->do_debug_cd_or_addpath_error (file, dir, addpath_option) : 0;
+           ? instance->do_debug_cd_or_addpath_error (file, dir, addpath_option)
+           : 0;
   }
 
   static void change_directory (const std::string& dir)
   {
     if (enabled ())
       instance->do_change_directory (dir);
   }
 
@@ -306,35 +308,35 @@ public:
   {
     return instance_ok () ? instance->link_enabled : false;
   }
 
   static bool
   show_preferences ()
   {
     if (enabled ())
-      { 
+      {
         instance->do_show_preferences ();
         return true;
       }
     else
       return false;
   }
 
-  static bool 
+  static bool
   show_doc (const std::string & file)
   {
     if (enabled ())
-      { 
+      {
         instance->do_show_doc (file);
         return true;
       }
     else
       return false;
- 
+
   }
 
 private:
 
   static octave_link *instance;
 
   // No copying!
 
diff --git a/libinterp/corefcn/pager.cc b/libinterp/corefcn/pager.cc
--- a/libinterp/corefcn/pager.cc
+++ b/libinterp/corefcn/pager.cc
@@ -175,17 +175,17 @@ do_sync (const char *msg, int len, bool 
 
 #if defined (EPIPE)
                   if (errno == EPIPE)
                     external_pager->setstate (std::ios::failbit);
 #endif
                 }
               else
                 {
-                  // FIXME -- omething is not right with the
+                  // FIXME: omething is not right with the
                   // pager.  If it died then we should receive a
                   // signal for that.  If there is some other problem,
                   // then what?
                 }
             }
           else
             {
               std::cout.write (msg, len);
@@ -508,17 +508,17 @@ open_diary_file (void)
 
   external_diary_file.open (diary_file.c_str (), std::ios::app);
 
   if (! external_diary_file)
     error ("diary: can't open diary file '%s'", diary_file.c_str ());
 }
 
 DEFUN (diary, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Command} {} diary\n\
 @deftypefnx {Command} {} diary on\n\
 @deftypefnx {Command} {} diary off\n\
 @deftypefnx {Command} {} diary @var{filename}\n\
 Record a list of all commands @emph{and} the output they produce, mixed\n\
 together just as they appear on the terminal.\n\
 \n\
 Valid options are:\n\
@@ -585,17 +585,17 @@ With no arguments, @code{diary} toggles 
       print_usage ();
       break;
     }
 
   return retval;
 }
 
 DEFUN (more, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Command} {} more\n\
 @deftypefnx {Command} {} more on\n\
 @deftypefnx {Command} {} more off\n\
 Turn output pagination on or off.  Without an argument, @code{more}\n\
 toggles the current state.\n\
 The current state can be determined via @code{page_screen_output}.\n\
 @seealso{page_screen_output, page_output_immediately, PAGER, PAGER_FLAGS}\n\
 @end deftypefn")
@@ -624,33 +624,33 @@ The current state can be determined via 
     Vpage_screen_output = ! Vpage_screen_output;
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (terminal_size, , ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} terminal_size ()\n\
 Return a two-element row vector containing the current size of the\n\
 terminal window in characters (rows and columns).\n\
 @seealso{list_in_columns}\n\
 @end deftypefn")
 {
   RowVector size (2, 0.0);
 
   size(0) = command_editor::terminal_rows ();
   size(1) = command_editor::terminal_cols ();
 
   return octave_value (size);
 }
 
 DEFUN (page_output_immediately, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} page_output_immediately ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} page_output_immediately (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} page_output_immediately (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave sends\n\
 output to the pager as soon as it is available.  Otherwise, Octave\n\
 buffers its output and waits until just before the prompt is printed to\n\
 flush it to the pager.\n\
 \n\
@@ -659,17 +659,17 @@ variable is changed locally for the func
 The original variable value is restored when exiting the function.\n\
 @seealso{page_screen_output, more, PAGER, PAGER_FLAGS}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (page_output_immediately);
 }
 
 DEFUN (page_screen_output, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} page_screen_output ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} page_screen_output (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} page_screen_output (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether output intended\n\
 for the terminal window that is longer than one page is sent through a\n\
 pager.  This allows you to view one screenful at a time.  Some pagers\n\
 (such as @code{less}---see @ref{Installation}) are also capable of moving\n\
 backward on the output.\n\
@@ -679,17 +679,17 @@ variable is changed locally for the func
 The original variable value is restored when exiting the function.\n\
 @seealso{more, page_output_immediately, PAGER, PAGER_FLAGS}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (page_screen_output);
 }
 
 DEFUN (PAGER, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} PAGER ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} PAGER (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} PAGER (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the program to use\n\
 to display terminal output on your system.  The default value is\n\
 normally @qcode{\"less\"}, @qcode{\"more\"}, or\n\
 @qcode{\"pg\"}, depending on what programs are installed on your system.\n\
 @xref{Installation}.\n\
@@ -699,17 +699,17 @@ variable is changed locally for the func
 The original variable value is restored when exiting the function.\n\
 @seealso{PAGER_FLAGS, page_output_immediately, more, page_screen_output}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (PAGER);
 }
 
 DEFUN (PAGER_FLAGS, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} PAGER_FLAGS ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} PAGER_FLAGS (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} PAGER_FLAGS (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the options to pass\n\
 to the pager.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.  \n\
diff --git a/libinterp/corefcn/pinv.cc b/libinterp/corefcn/pinv.cc
--- a/libinterp/corefcn/pinv.cc
+++ b/libinterp/corefcn/pinv.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "ops.h"
 #include "ov-re-diag.h"
 #include "ov-cx-diag.h"
 #include "ov-flt-re-diag.h"
 #include "ov-flt-cx-diag.h"
 #include "ov-perm.h"
 
 DEFUN (pinv, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} pinv (@var{x})\n\
 @deftypefnx {Built-in Function} {} pinv (@var{x}, @var{tol})\n\
 Return the pseudoinverse of @var{x}.  Singular values less than\n\
 @var{tol} are ignored.\n\
 \n\
 If the second argument is omitted, it is taken to be\n\
 \n\
 @example\n\
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -141,48 +141,49 @@ public:
   float_format (int w = current_output_max_field_width (),
                 int p = current_output_precision (), int f = 0)
     : fw (w), ex (0), prec (p), fmt (f), up (0), sp (0) { }
 
   float_format (int w, int e, int p, int f)
     : fw (w), ex (e), prec (p), fmt (f), up (0), sp (0) { }
 
   float_format (const float_format& ff)
-    : fw (ff.fw), ex (ff.ex), prec (ff.prec), fmt (ff.fmt), up (ff.up), sp (ff.sp) { }
+    : fw (ff.fw), ex (ff.ex), prec (ff.prec), fmt (ff.fmt), up (ff.up),
+      sp (ff.sp) { }
 
   float_format& operator = (const float_format& ff)
-    {
-      if (&ff != this)
-        {
-          fw = ff.fw;
-          ex = ff.ex;
-          prec = ff.prec;
-          fmt = ff.fmt;
-          up = ff.up;
-          sp = ff.sp;
-        }
-
-      return *this;
-    }
+  {
+    if (&ff != this)
+      {
+        fw = ff.fw;
+        ex = ff.ex;
+        prec = ff.prec;
+        fmt = ff.fmt;
+        up = ff.up;
+        sp = ff.sp;
+      }
+
+    return *this;
+  }
 
   ~float_format (void) { }
 
   float_format& scientific (void) { fmt = std::ios::scientific; return *this; }
   float_format& fixed (void) { fmt = std::ios::fixed; return *this; }
   float_format& general (void) { fmt = 0; return *this; }
 
   float_format& uppercase (void) { up = std::ios::uppercase; return *this; }
   float_format& lowercase (void) { up = 0; return *this; }
 
   float_format& precision (int p) { prec = p; return *this; }
 
   float_format& width (int w) { fw = w; return *this; }
 
   float_format& trailing_zeros (bool tz = true)
-    { sp = tz ? std::ios::showpoint : 0; return *this; }
+  { sp = tz ? std::ios::showpoint : 0; return *this; }
 
   friend std::ostream& operator << (std::ostream& os,
                                     const pr_engineering_float& pef);
 
   friend std::ostream& operator << (std::ostream& os,
                                     const pr_formatted_float& pff);
 
   friend std::ostream& operator << (std::ostream& os,
@@ -382,17 +383,18 @@ rational_approx (double val, int len)
       while (1)
         {
           double flip = 1. / frac;
           double step = xround (flip);
           double nextn = n;
           double nextd = d;
 
           // Have we converged to 1/intmax ?
-          if (m > 100 || fabs (frac) < 1 / static_cast<double> (std::numeric_limits<int>::max ()))
+          if (m > 100
+              || fabs (frac) < 1 / static_cast<double> (std::numeric_limits<int>::max ()))
             {
               lastn = n;
               lastd = d;
               break;
             }
 
           frac = flip - step;
           n = n * step + lastn;
@@ -423,17 +425,17 @@ rational_approx (double val, int len)
       if (lastd < 0.)
         {
           // Move sign to the top
           lastd = - lastd;
           lastn = - lastn;
           std::ostringstream buf;
           buf.flags (std::ios::fixed);
           buf << std::setprecision (0) << static_cast<int>(lastn)
-               << "/" << static_cast<int>(lastd);
+              << "/" << static_cast<int>(lastd);
           s = buf.str ();
         }
     }
 
   return s;
 }
 
 class
@@ -532,18 +534,17 @@ pr_min_internal (const Matrix& m)
       }
 
   if (all_inf_or_nan)
     result = 0.0;
 
   return result;
 }
 
-// FIXME -- it would be nice to share more code among these
-// functions,..
+// FIXME: it would be nice to share more code among these functions,..
 
 static void
 set_real_format (int digits, bool inf_or_nan, bool int_only, int &fw)
 {
   static float_format fmt;
 
   int prec = Voutput_precision;
 
@@ -647,18 +648,17 @@ set_format (double d, int& fw)
     return;
 
   bool inf_or_nan = (xisinf (d) || xisnan (d));
 
   bool int_only = (! inf_or_nan && D_NINT (d) == d);
 
   double d_abs = d < 0.0 ? -d : d;
 
-  int digits = (inf_or_nan || d_abs == 0.0)
-    ? 0 : num_digits (d_abs);
+  int digits = (inf_or_nan || d_abs == 0.0) ? 0 : num_digits (d_abs);
 
   set_real_format (digits, inf_or_nan, int_only, fw);
 }
 
 static inline void
 set_format (double d)
 {
   int fw;
@@ -807,18 +807,18 @@ set_format (const Matrix& m, int& fw, do
   Matrix m_abs = m.abs ();
   double max_abs = pr_max_internal (m_abs);
   double min_abs = pr_min_internal (m_abs);
 
   int x_max = max_abs == 0.0 ? 0 : num_digits (max_abs);
 
   int x_min = min_abs == 0.0 ? 0 : num_digits (min_abs);
 
-  scale = (x_max == 0 || int_or_inf_or_nan) ? 1.0
-    : std::pow (10.0, calc_scale_exp (x_max - 1));
+  scale = (x_max == 0 || int_or_inf_or_nan)
+            ? 1.0 : std::pow (10.0, calc_scale_exp (x_max - 1));
 
   set_real_matrix_format (x_max, x_min, inf_or_nan, int_or_inf_or_nan, fw);
 }
 
 static inline void
 set_format (const Matrix& m)
 {
   int fw;
@@ -1223,18 +1223,18 @@ set_format (const ComplexMatrix& cm, int
 
   int i_x_max = i_max_abs == 0.0 ? 0 : num_digits (i_max_abs);
 
   int i_x_min = i_min_abs == 0.0 ? 0 : num_digits (i_min_abs);
 
   int x_max = r_x_max > i_x_max ? r_x_max : i_x_max;
   int x_min = r_x_min > i_x_min ? r_x_min : i_x_min;
 
-  scale = (x_max == 0 || int_or_inf_or_nan) ? 1.0
-    : std::pow (10.0, calc_scale_exp (x_max - 1));
+  scale = (x_max == 0 || int_or_inf_or_nan)
+            ? 1.0 : std::pow (10.0, calc_scale_exp (x_max - 1));
 
   set_complex_matrix_format (x_max, x_min, r_x_max, r_x_min, inf_or_nan,
                              int_or_inf_or_nan, r_fw, i_fw);
 }
 
 static inline void
 set_format (const ComplexMatrix& cm)
 {
@@ -1379,18 +1379,18 @@ set_format (const Range& r, int& fw, dou
 
   double max_abs = r_max < 0.0 ? -r_max : r_max;
   double min_abs = r_min < 0.0 ? -r_min : r_min;
 
   int x_max = max_abs == 0.0 ? 0 : num_digits (max_abs);
 
   int x_min = min_abs == 0.0 ? 0 : num_digits (min_abs);
 
-  scale = (x_max == 0 || all_ints) ? 1.0
-    : std::pow (10.0, calc_scale_exp (x_max - 1));
+  scale = (x_max == 0 || all_ints)
+            ? 1.0 : std::pow (10.0, calc_scale_exp (x_max - 1));
 
   set_range_format (x_max, x_min, all_ints, fw);
 }
 
 static inline void
 set_format (const Range& r)
 {
   int fw;
@@ -1440,31 +1440,30 @@ union equiv
     } \
   while (0)
 
 static void
 pr_any_float (const float_format *fmt, std::ostream& os, double d, int fw = 0)
 {
   if (fmt)
     {
-      // Unless explicitly asked for, always print in big-endian
-      // format for hex and bit formats.
+      // Unless explicitly asked for, always print in big-endian format
+      // for hex and bit formats.
       //
       //   {bit,hex}_format == 1: print big-endian
       //   {bit,hex}_format == 2: print native
 
       if (hex_format)
         {
           equiv tmp;
           tmp.d = d;
 
-          // Unless explicitly asked for, always print in big-endian
-          // format.
-
-          // FIXME -- will bad things happen if we are
+          // Unless explicitly asked for, always print in big-endian format.
+
+          // FIXME: will bad things happen if we are
           // interrupted before resetting the format flags and fill
           // character?
 
           oct_mach_info::float_format flt_fmt =
             oct_mach_info::native_float_format ();
 
           char ofill = os.fill ('0');
 
@@ -1595,17 +1594,18 @@ pr_complex (std::ostream& os, const Comp
 
           pr_imag_float (os, i, i_fw);
         }
       os << "i";
     }
 }
 
 static void
-print_empty_matrix (std::ostream& os, octave_idx_type nr, octave_idx_type nc, bool pr_as_read_syntax)
+print_empty_matrix (std::ostream& os, octave_idx_type nr, octave_idx_type nc,
+                    bool pr_as_read_syntax)
 {
   assert (nr == 0 || nc == 0);
 
   if (pr_as_read_syntax)
     {
       if (nr == 0 && nc == 0)
         os << "[]";
       else
@@ -1934,38 +1934,38 @@ octave_print_internal (std::ostream& os,
                     }
 
                   pr_float (os, m(j,j));
                 }
 
               col += inc;
 
               if (col >= nc)
-                  os << " ]";
+                os << " ]";
               else
                 os << " ...\n";
             }
           os << ")";
         }
       else
         {
           os << "Diagonal Matrix\n";
           if (! Vcompact_format)
             os << "\n";
 
           pr_scale_header (os, scale);
 
           // kluge. Get the true width of a number.
           int zero_fw;
 
-            {
-              std::ostringstream tmp_oss;
-              pr_float (tmp_oss, 0.0, fw, scale);
-              zero_fw = tmp_oss.str ().length ();
-            }
+          {
+            std::ostringstream tmp_oss;
+            pr_float (tmp_oss, 0.0, fw, scale);
+            zero_fw = tmp_oss.str ().length ();
+          }
 
           for (octave_idx_type col = 0; col < nc; col += inc)
             {
               octave_idx_type lim = col + inc < nc ? col + inc : nc;
 
               pr_col_num_header (os, total_width, max_width, lim, col,
                                  extra_indent);
 
@@ -2128,17 +2128,17 @@ octave_print_internal (std::ostream& os,
 
 void
 octave_print_internal (std::ostream& os, const ComplexMatrix& cm,
                        bool pr_as_read_syntax, int extra_indent)
 {
   octave_idx_type nr = cm.rows ();
   octave_idx_type nc = cm.columns ();
 
- if (nr == 0 || nc == 0)
+  if (nr == 0 || nc == 0)
     print_empty_matrix (os, nr, nc, pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
       for (octave_idx_type i = 0; i < nr; i++)
         {
           for (octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
@@ -2264,17 +2264,17 @@ octave_print_internal (std::ostream& os,
 
 void
 octave_print_internal (std::ostream& os, const ComplexDiagMatrix& cm,
                        bool pr_as_read_syntax, int extra_indent)
 {
   octave_idx_type nr = cm.rows ();
   octave_idx_type nc = cm.columns ();
 
- if (nr == 0 || nc == 0)
+  if (nr == 0 || nc == 0)
     print_empty_matrix (os, nr, nc, pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
       for (octave_idx_type i = 0; i < nr; i++)
         {
           for (octave_idx_type j = 0; j < nc; j++)
             {
               octave_quit ();
@@ -2350,38 +2350,38 @@ octave_print_internal (std::ostream& os,
                     }
 
                   pr_complex (os, cm(j,j));
                 }
 
               col += inc;
 
               if (col >= nc)
-                  os << " ]";
+                os << " ]";
               else
                 os << " ...\n";
             }
           os << ")";
         }
       else
         {
           os << "Diagonal Matrix\n";
           if (! Vcompact_format)
             os << "\n";
 
           pr_scale_header (os, scale);
 
           // kluge. Get the true width of a number.
           int zero_fw;
 
-            {
-              std::ostringstream tmp_oss;
-              pr_complex (tmp_oss, Complex (0.0), r_fw, i_fw, scale);
-              zero_fw = tmp_oss.str ().length ();
-            }
+          {
+            std::ostringstream tmp_oss;
+            pr_complex (tmp_oss, Complex (0.0), r_fw, i_fw, scale);
+            zero_fw = tmp_oss.str ().length ();
+          }
 
           for (octave_idx_type col = 0; col < nc; col += inc)
             {
               octave_idx_type lim = col + inc < nc ? col + inc : nc;
 
               pr_col_num_header (os, total_width, max_width, lim, col,
                                  extra_indent);
 
@@ -2497,17 +2497,17 @@ octave_print_internal (std::ostream& os,
                     }
 
                   os << pvec (j);
                 }
 
               col += inc;
 
               if (col >= nc)
-                  os << " ]";
+                os << " ]";
               else
                 os << " ...\n";
             }
           if (! colp) os << ", :";
           os << ")";
         }
       else
         {
@@ -2551,29 +2551,29 @@ octave_print_internal (std::ostream& os,
     {
     case 1:
     case 2:
       octave_print_internal (os, nda.matrix_value (),
                              pr_as_read_syntax, extra_indent);
       break;
 
     default:
-      print_nd_array <ComplexNDArray, Complex,
-                      ComplexMatrix> (os, nda, pr_as_read_syntax);
+      print_nd_array <ComplexNDArray, Complex, ComplexMatrix>
+                      (os, nda, pr_as_read_syntax);
       break;
     }
 }
 
 void
 octave_print_internal (std::ostream& os, bool d, bool pr_as_read_syntax)
 {
   octave_print_internal (os, double (d), pr_as_read_syntax);
 }
 
-// FIXME -- write single precision versions of the printing functions.
+// FIXME: write single precision versions of the printing functions.
 
 void
 octave_print_internal (std::ostream& os, float d, bool pr_as_read_syntax)
 {
   octave_print_internal (os, double (d), pr_as_read_syntax);
 }
 
 void
@@ -2603,31 +2603,34 @@ octave_print_internal (std::ostream& os,
 {
   octave_print_internal (os, Complex (c), pr_as_read_syntax);
 }
 
 void
 octave_print_internal (std::ostream& os, const FloatComplexMatrix& cm,
                        bool pr_as_read_syntax, int extra_indent)
 {
-  octave_print_internal (os, ComplexMatrix (cm), pr_as_read_syntax, extra_indent);
+  octave_print_internal (os, ComplexMatrix (cm), pr_as_read_syntax,
+                         extra_indent);
 }
 
 void
 octave_print_internal (std::ostream& os, const FloatComplexDiagMatrix& cm,
                        bool pr_as_read_syntax, int extra_indent)
 {
-  octave_print_internal (os, ComplexDiagMatrix (cm), pr_as_read_syntax, extra_indent);
+  octave_print_internal (os, ComplexDiagMatrix (cm), pr_as_read_syntax,
+                         extra_indent);
 }
 
 void
 octave_print_internal (std::ostream& os, const FloatComplexNDArray& nda,
                        bool pr_as_read_syntax, int extra_indent)
 {
-  octave_print_internal (os, ComplexNDArray (nda), pr_as_read_syntax, extra_indent);
+  octave_print_internal (os, ComplexNDArray (nda), pr_as_read_syntax,
+                         extra_indent);
 }
 
 void
 octave_print_internal (std::ostream& os, const Range& r,
                        bool pr_as_read_syntax, int extra_indent)
 {
   double base = r.base ();
   double increment = r.inc ();
@@ -2823,18 +2826,18 @@ octave_print_internal (std::ostream& os,
     {
     case 1:
     case 2:
       octave_print_internal (os, nda.matrix_value (),
                              pr_as_read_syntax, extra_indent, pr_as_string);
       break;
 
     default:
-      print_nd_array <charNDArray, char,
-                      charMatrix> (os, nda, pr_as_read_syntax);
+      print_nd_array <charNDArray, char, charMatrix> (os, nda,
+                                                      pr_as_read_syntax);
       break;
     }
 }
 
 void
 octave_print_internal (std::ostream& os, const std::string& s,
                        bool pr_as_read_syntax, int extra_indent)
 {
@@ -2842,17 +2845,17 @@ octave_print_internal (std::ostream& os,
 
   octave_print_internal (os, nda, pr_as_read_syntax, extra_indent);
 }
 
 void
 octave_print_internal (std::ostream& os, const Array<std::string>& nda,
                        bool pr_as_read_syntax, int /* extra_indent */)
 {
-  // FIXME -- this mostly duplicates the code in the print_nd_array<>
+  // FIXME: this mostly duplicates the code in the print_nd_array<>
   // function. Can fix this with std::is_same from C++11.
 
   if (nda.is_empty ())
     print_empty_nd_array (os, nda.dims (), pr_as_read_syntax);
   else if (nda.length () == 1)
     {
       os << nda(0);
     }
@@ -2900,18 +2903,18 @@ octave_print_internal (std::ostream& os,
           idx(0) = idx_vector (':');
           idx(1) = idx_vector (':');
 
           for (int k = 2; k < ndims; k++)
             idx(k) = idx_vector (ra_idx(k));
 
           Array<std::string> page (nda.index (idx), dim_vector (nr, nc));
 
-          // FIXME -- need to do some more work to put these
-          // in neatly aligned columns...
+          // FIXME: need to do some more work to put these
+          //        in neatly aligned columns...
 
           octave_idx_type n_rows = page.rows ();
           octave_idx_type n_cols = page.cols ();
 
           os << nm << " =\n";
           if (! Vcompact_format)
             os << "\n";
 
@@ -3014,21 +3017,21 @@ pr_int (std::ostream& os, const T& d, in
       os << std::setw (fw)
          << typename octave_print_conv<T>::print_conv_type (d);
 
       if (bank_format)
         os << ".00";
     }
 }
 
-// FIXME -- all this mess with abs is an attempt to avoid seeing
+// FIXME: all this mess with abs is an attempt to avoid seeing
 //
 //   warning: comparison of unsigned expression < 0 is always false
 //
-// from GCC.  Isn't there a better way
+// from GCC.  Isn't there a better way?
 
 template <class T>
 /* static */ inline T
 abs (T x)
 {
   return x < 0 ? -x : x;
 }
 
@@ -3113,17 +3116,17 @@ PRINT_INT_SCALAR_INTERNAL (uint32_t)
 PRINT_INT_SCALAR_INTERNAL (int64_t)
 PRINT_INT_SCALAR_INTERNAL (uint64_t)
 
 template <class T>
 /* static */ inline void
 octave_print_internal_template (std::ostream& os, const intNDArray<T>& nda,
                                 bool pr_as_read_syntax, int extra_indent)
 {
-  // FIXME -- this mostly duplicates the code in the print_nd_array<>
+  // FIXME: this mostly duplicates the code in the print_nd_array<>
   // function. Can fix this with std::is_same from C++11.
 
   if (nda.is_empty ())
     print_empty_nd_array (os, nda.dims (), pr_as_read_syntax);
   else if (nda.length () == 1)
     octave_print_internal_template (os, nda(0), pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
     {
@@ -3219,24 +3222,25 @@ octave_print_internal_template (std::ost
         fw = nda(0).nbits ();
       else
         {
           bool isneg = false;
           int digits = 0;
 
           for (octave_idx_type i = 0; i < dims.numel (); i++)
             {
-              int new_digits = static_cast<int>
-                (gnulib::floor (log10 (double (abs (nda(i).value ()))) + 1.0));
+              int new_digits
+                = static_cast<int>
+                  (gnulib::floor (log10 (double (abs (nda(i).value ()))) + 1.0));
 
               if (new_digits > digits)
                 digits = new_digits;
 
               if (! isneg)
-              isneg = (abs (nda(i).value ()) != nda(i).value ());
+                isneg = (abs (nda(i).value ()) != nda(i).value ());
             }
 
           fw = digits + isneg;
         }
 
       int column_width = fw + (rat_format ?  0 : (bank_format ? 5 : 2));
       octave_idx_type total_width = nc * column_width;
       int max_width = command_editor::terminal_cols () - extra_indent;
@@ -3358,17 +3362,17 @@ PRINT_INT_ARRAY_INTERNAL (octave_uint64)
 
 void
 octave_print_internal (std::ostream&, const Cell&, bool, int, bool)
 {
   panic_impossible ();
 }
 
 DEFUN (rats, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} rats (@var{x}, @var{len})\n\
 Convert @var{x} into a rational approximation represented as a string.\n\
 You can convert the string back into a matrix as follows:\n\
 \n\
 @example\n\
 @group\n\
 r = rats (hilb (4));\n\
 x = str2num (r)\n\
@@ -3438,17 +3442,17 @@ representing the elements of @var{x}.  B
             error ("rats: X must be numeric");
         }
     }
 
   return retval;
 }
 
 DEFUN (disp, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} disp (@var{x})\n\
 Display the value of @var{x}.  For example:\n\
 \n\
 @example\n\
 @group\n\
 disp (\"The value of pi is:\"), disp (pi)\n\
 \n\
      @print{} the value of pi is:\n\
@@ -3482,17 +3486,17 @@ returns the formatted output in a string
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (fdisp, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fdisp (@var{fid}, @var{x})\n\
 Display the value of @var{x} on the stream @var{fid}.  For example:\n\
 \n\
 @example\n\
 @group\n\
 fdisp (stdout, \"The value of pi is:\"), fdisp (stdout, pi)\n\
 \n\
      @print{} the value of pi is:\n\
@@ -3754,17 +3758,17 @@ set_format_style (int argc, const string
   else
     {
       init_format_state ();
       set_output_prec_and_fw (5, 10);
     }
 }
 
 DEFUN (format, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Command} {} format\n\
 @deftypefnx {Command} {} format options\n\
 Reset or specify the format of the output produced by @code{disp} and\n\
 Octave's normal echoing mechanism.  This command only affects the display\n\
 of numbers but not how they are stored or computed.  To change the internal\n\
 representation from the default double use one of the conversion functions\n\
 such as @code{single}, @code{uint8}, @code{int64}, etc.\n\
 \n\
@@ -3938,17 +3942,17 @@ to produce a more readable output with l
     return retval;
 
   set_format_style (argc, argv);
 
   return retval;
 }
 
 DEFUN (fixed_point_format, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} fixed_point_format ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} fixed_point_format (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} fixed_point_format (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will\n\
 use a scaled format to print matrix values such that the largest\n\
 element may be written with a single leading digit with the scaling\n\
 factor is printed on the first line of output.  For example:\n\
 \n\
@@ -3977,17 +3981,17 @@ variable is changed locally for the func
 The original variable value is restored when exiting the function.\n\
 @seealso{format, output_max_field_width, output_precision}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (fixed_point_format);
 }
 
 DEFUN (print_empty_dimensions, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} print_empty_dimensions ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} print_empty_dimensions (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} print_empty_dimensions (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether the\n\
 dimensions of empty matrices are printed along with the empty matrix\n\
 symbol, @samp{[]}.  For example, the expression\n\
 \n\
 @example\n\
@@ -4006,17 +4010,17 @@ variable is changed locally for the func
 The original variable value is restored when exiting the function.\n\
 @seealso{format}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (print_empty_dimensions);
 }
 
 DEFUN (split_long_rows, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} split_long_rows ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} split_long_rows (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} split_long_rows (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether rows of a matrix\n\
 may be split when displayed to a terminal window.  If the rows are split,\n\
 Octave will display the matrix in a series of smaller pieces, each of\n\
 which can fit within the limits of your terminal width and each set of\n\
 rows is labeled so that you can easily see which columns are currently\n\
@@ -4044,17 +4048,17 @@ variable is changed locally for the func
 The original variable value is restored when exiting the function.\n\
 @seealso{format}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (split_long_rows);
 }
 
 DEFUN (output_max_field_width, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} output_max_field_width ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} output_max_field_width (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} output_max_field_width (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the maximum width\n\
 of a numeric output field.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.  \n\
@@ -4062,17 +4066,17 @@ The original variable value is restored 
 @seealso{format, fixed_point_format, output_precision}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE_WITH_LIMITS (output_max_field_width, 0,
                                             std::numeric_limits<int>::max ());
 }
 
 DEFUN (output_precision, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} output_precision ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} output_precision (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} output_precision (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the minimum number of\n\
 significant figures to display for numeric output.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.  \n\
diff --git a/libinterp/corefcn/procstream.h b/libinterp/corefcn/procstream.h
--- a/libinterp/corefcn/procstream.h
+++ b/libinterp/corefcn/procstream.h
@@ -40,17 +40,17 @@ public:
 
   procstreambase (const std::string& name, int mode);
 
   procstreambase (const char *name, int mode);
 
   ~procstreambase (void) { close (); }
 
   void open (const std::string& name, int mode)
-    { open (name.c_str (), mode); }
+  { open (name.c_str (), mode); }
 
   void open (const char *name, int mode);
 
   int is_open (void) const { return pb.is_open (); }
 
   int close (void);
 
   pid_t pid (void) const { return pb.pid (); }
@@ -81,20 +81,20 @@ public:
     : std::istream (0), procstreambase (name, mode) { }
 
   iprocstream (const char *name, int mode = std::ios::in)
     : std::istream (0), procstreambase (name, mode) { }
 
   ~iprocstream (void) { }
 
   void open (const std::string& name, int mode = std::ios::in)
-    { procstreambase::open (name, mode); }
+  { procstreambase::open (name, mode); }
 
   void open (const char *name, int mode = std::ios::in)
-    { procstreambase::open (name, mode); }
+  { procstreambase::open (name, mode); }
 
 private:
 
   iprocstream (const iprocstream&);
 
   iprocstream& operator = (const iprocstream&);
 };
 
@@ -111,20 +111,20 @@ public:
     : std::ostream (0), procstreambase (name, mode) { }
 
   oprocstream (const char *name, int mode = std::ios::out)
     : std::ostream (0), procstreambase (name, mode) { }
 
   ~oprocstream (void) { }
 
   void open (const std::string& name, int mode = std::ios::out)
-    { procstreambase::open (name, mode); }
+  { procstreambase::open (name, mode); }
 
   void open (const char *name, int mode = std::ios::out)
-    { procstreambase::open (name, mode); }
+  { procstreambase::open (name, mode); }
 
 private:
 
   oprocstream (const oprocstream&);
 
   oprocstream& operator = (const oprocstream&);
 };
 
@@ -141,20 +141,20 @@ public:
     : std::iostream (0), procstreambase (name, mode) { }
 
   procstream (const char *name, int mode)
     : std::iostream (0), procstreambase (name, mode) { }
 
   ~procstream (void) { }
 
   void open (const std::string& name, int mode)
-    { procstreambase::open (name, mode); }
+  { procstreambase::open (name, mode); }
 
   void open (const char *name, int mode)
-    { procstreambase::open (name, mode); }
+  { procstreambase::open (name, mode); }
 
 private:
 
   procstream (const procstream&);
 
   procstream& operator = (const procstream&);
 };
 
diff --git a/libinterp/corefcn/profiler.cc b/libinterp/corefcn/profiler.cc
--- a/libinterp/corefcn/profiler.cc
+++ b/libinterp/corefcn/profiler.cc
@@ -332,25 +332,25 @@ profile_data_accumulator::get_flat (void
       m.assign ("Parents", rv_parents);
       m.assign ("Children", rv_children);
 
       retval = m;
     }
   else
     {
       static const char *fn[] =
-        {
-          "FunctionName",
-          "TotalTime",
-          "NumCalls",
-          "IsRecursive",
-          "Parents",
-          "Children",
-          0
-        };
+      {
+        "FunctionName",
+        "TotalTime",
+        "NumCalls",
+        "IsRecursive",
+        "Parents",
+        "Children",
+        0
+      };
 
       static octave_map m (dim_vector (0, 1), string_vector (fn));
 
       retval = m;
     }
 
   return retval;
 }
@@ -360,38 +360,38 @@ profile_data_accumulator::get_hierarchic
 {
   octave_value retval;
 
   if (call_tree)
     retval = call_tree->get_hierarchical ();
   else
     {
       static const char *fn[] =
-        {
-          "Index",
-          "SelfTime",
-          "NumCalls",
-          "Children",
-          0
-        };
+      {
+        "Index",
+        "SelfTime",
+        "NumCalls",
+        "Children",
+        0
+      };
 
       static octave_map m (dim_vector (0, 1), string_vector (fn));
 
       retval = m;
     }
 
   return retval;
 }
 
 double
 profile_data_accumulator::query_time (void) const
 {
   octave_time now;
 
-  // FIXME -- is this volatile declaration really needed?
+  // FIXME: is this volatile declaration really needed?
   // See bug #34210 for additional details.
   volatile double dnow = now.double_value ();
 
   return dnow;
 }
 
 void
 profile_data_accumulator::add_current_time (void)
@@ -402,17 +402,17 @@ profile_data_accumulator::add_current_ti
   assert (call_tree && active_fcn != call_tree);
   active_fcn->add_time (t - last_time);
 }
 
 profile_data_accumulator profiler;
 
 // Enable or disable the profiler data collection.
 DEFUN (__profiler_enable__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Function File} __profiler_enable ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   const int nargin = args.length ();
   if (nargin > 0)
@@ -428,17 +428,17 @@ Undocumented internal function.\n\
 
   retval(0) = profiler.is_active ();
 
   return retval;
 }
 
 // Clear all collected profiling data.
 DEFUN (__profiler_reset__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Function File} __profiler_reset ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
   const int nargin = args.length ();
 
   if (nargin > 0)
@@ -446,17 +446,17 @@ Undocumented internal function.\n\
 
   profiler.reset ();
 
   return retval;
 }
 
 // Query the timings collected by the profiler.
 DEFUN (__profiler_data__, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Function File} __profiler_data ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
   const int nargin = args.length ();
 
   if (nargin > 0)
diff --git a/libinterp/corefcn/pt-jit.cc b/libinterp/corefcn/pt-jit.cc
--- a/libinterp/corefcn/pt-jit.cc
+++ b/libinterp/corefcn/pt-jit.cc
@@ -103,17 +103,17 @@ jit_convert::jit_convert (tree &tee, jit
   if (for_bounds)
     create_variable (next_for_bounds (false), for_bounds);
 
   try
     {
       visit (tee);
     }
   catch (const jit_break_exception&)
-    {}
+    { }
 
   // breaks must have been handled by the top level loop
   assert (breaks.empty ());
   assert (continues.empty ());
 
   block->append (factory.create<jit_branch> (final_block));
   blocks.push_back (final_block);
 
@@ -165,17 +165,17 @@ jit_convert::jit_convert (octave_user_fu
         {
           jit_variable *retvar = get_variable ("#return");
           jit_value *retval;
           try
             {
               retval = visit (expr);
             }
           catch (const jit_break_exception&)
-            {}
+            { }
 
           if (breaks.size () || continues.size ())
             throw jit_fail_exception ("break/continue not supported in "
                                       "anonymous functions");
 
           block->append (factory.create<jit_assign> (retvar, retval));
           return_value = retvar;
         }
@@ -259,19 +259,21 @@ jit_convert::visit_binary_expression (tr
       lhsv = create_checked (&jit_typeinfo::logically_true, lhsv);
 
       jit_block *short_early = factory.create<jit_block> ("short_early");
       blocks.push_back (short_early);
 
       jit_block *short_cont = factory.create<jit_block> ("short_cont");
 
       if (is_and)
-        block->append (factory.create<jit_cond_branch> (lhsv, short_cont, short_early));
+        block->append (factory.create<jit_cond_branch> (lhsv, short_cont,
+                                                        short_early));
       else
-        block->append (factory.create<jit_cond_branch> (lhsv, short_early, short_cont));
+        block->append (factory.create<jit_cond_branch> (lhsv, short_early,
+                                                        short_cont));
 
       block = short_early;
 
       jit_value *early_result = factory.create<jit_const_bool> (! is_and);
       block->append (factory.create<jit_assign> (short_result, early_result));
       block->append (factory.create<jit_branch> (done));
 
       blocks.push_back (short_cont);
@@ -316,18 +318,18 @@ jit_convert::visit_colon_expression (tre
   jit_value *increment;
   tree_expression *tinc = expr.increment ();
 
   if (tinc)
     increment = visit (tinc);
   else
     increment = factory.create<jit_const_scalar> (1);
 
-  result = block->append (factory.create<jit_call> (jit_typeinfo::make_range, base,
-                                            limit, increment));
+  result = block->append (factory.create<jit_call> (jit_typeinfo::make_range,
+                                                    base, limit, increment));
 }
 
 void
 jit_convert::visit_continue_command (tree_continue_command&)
 {
   continues.push_back (block);
   throw jit_break_exception ();
 }
@@ -576,17 +578,17 @@ jit_convert::visit_if_command_list (tree
 
       if (! tic->is_else_clause ())
         {
           tree_expression *expr = tic->condition ();
           jit_value *cond = visit (expr);
           jit_call *check = create_checked (&jit_typeinfo::logically_true,
                                             cond);
           jit_block *body = factory.create<jit_block> (i == 0 ? "if_body"
-                                                       : "ifelse_body");
+                                                              : "ifelse_body");
           blocks.push_back (body);
 
           jit_instruction *br = factory.create<jit_cond_branch> (check, body,
                                                         entry_blocks[i + 1]);
           block->append (br);
           block = body;
         }
 
@@ -594,18 +596,18 @@ jit_convert::visit_if_command_list (tree
       assert (stmt_lst); // jwe: Can this be null?
 
       try
         {
           stmt_lst->accept (*this);
           ++num_incomming;
           block->append (factory.create<jit_branch> (tail));
         }
-      catch(const jit_break_exception&)
-        {}
+      catch (const jit_break_exception&)
+        { }
 
       current_breaks.splice (current_breaks.end (), breaks);
       current_continues.splice (current_continues.end (), continues);
     }
 
   breaks.splice (breaks.end (), current_breaks);
   continues.splice (continues.end (), current_continues);
 
@@ -775,17 +777,18 @@ jit_convert::visit_statement (tree_state
 
       if (do_bind_ans)
         do_assign ("ans", expr_result, expr->print_result ());
       else if (expr->is_identifier () && expr->print_result ())
         {
           // FIXME: ugly hack, we need to come up with a way to pass
           // nargout to visit_identifier
           const jit_operation& fn = jit_typeinfo::print_value ();
-          jit_const_string *name = factory.create<jit_const_string> (expr->name ());
+          jit_const_string *name = factory.create<jit_const_string>
+                                    (expr->name ());
           block->append (factory.create<jit_call> (fn, name, expr_result));
         }
     }
 }
 
 void
 jit_convert::visit_statement_list (tree_statement_list& lst)
 {
@@ -1041,17 +1044,17 @@ jit_convert::resolve (tree_index_express
       end_context.push_back (ctx);
       call_args[idx + 1] = visit (*iter);
     }
 
   if (extra_arg)
     call_args[call_args.size () - 1] = extra_arg;
 
   const jit_operation& fres = lhs ? jit_typeinfo::paren_subsasgn ()
-    : jit_typeinfo::paren_subsref ();
+                                  : jit_typeinfo::paren_subsref ();
 
   return create_checked (fres, call_args);
 }
 
 jit_value *
 jit_convert::do_assign (tree_expression *exp, jit_value *rhs, bool artificial)
 {
   if (! exp)
@@ -1131,35 +1134,37 @@ jit_convert_llvm::convert_loop (llvm::Mo
       argument_vec.push_back (std::make_pair (extract->name (), true));
 
 
   jit_type *any = jit_typeinfo::get_any ();
 
   // argument is an array of octave_base_value*, or octave_base_value**
   llvm::Type *arg_type = any->to_llvm (); // this is octave_base_value*
   arg_type = arg_type->getPointerTo ();
-  llvm::FunctionType *ft = llvm::FunctionType::get (llvm::Type::getVoidTy (context),
-                                                    arg_type, false);
+  llvm::FunctionType *ft;
+  ft = llvm::FunctionType::get (llvm::Type::getVoidTy (context), arg_type,
+                                false);
   function = llvm::Function::Create (ft, llvm::Function::ExternalLinkage,
                                      "foobar", module);
 
   try
     {
       prelude = llvm::BasicBlock::Create (context, "prelude", function);
       builder.SetInsertPoint (prelude);
 
       llvm::Value *arg = function->arg_begin ();
       for (size_t i = 0; i < argument_vec.size (); ++i)
         {
           llvm::Value *loaded_arg = builder.CreateConstInBoundsGEP1_32 (arg, i);
           arguments[argument_vec[i].first] = loaded_arg;
         }
 
       convert (blocks, constants);
-    } catch (const jit_fail_exception& e)
+    }
+  catch (const jit_fail_exception& e)
     {
       function->eraseFromParent ();
       throw;
     }
 
   return function;
 }
 
@@ -1195,17 +1200,18 @@ jit_convert_llvm::convert_function (llvm
             {
               tree_decl_elt *elt = *piter;
               std::string arg_name = elt->name ();
               arguments[arg_name] = creating.argument (builder, i);
             }
         }
 
       convert (blocks, constants);
-    } catch (const jit_fail_exception& e)
+    }
+  catch (const jit_fail_exception& e)
     {
       function->eraseFromParent ();
       throw;
     }
 
   return creating;
 }
 
@@ -1462,17 +1468,17 @@ jit_convert_llvm::visit (jit_magic_end& 
   jit_magic_end::context ctx = me.resolve_context ();
   llvm::Value *ret = ol.call (builder, ctx.value, ctx.index, ctx.count);
   me.stash_llvm (ret);
 }
 
 // -------------------- jit_infer --------------------
 jit_infer::jit_infer (jit_factory& afactory, jit_block_list& ablocks,
                       const variable_map& avmap)
-  : blocks (ablocks), factory (afactory), vmap (avmap) {}
+  : blocks (ablocks), factory (afactory), vmap (avmap) { }
 
 void
 jit_infer::infer (void)
 {
   construct_ssa ();
 
   // initialize the worklist to instructions derived from constants
   const std::list<jit_value *>& constants = factory.constants ();
@@ -1517,18 +1523,18 @@ jit_infer::append_users (jit_value *v)
 void
 jit_infer::append_users_term (jit_terminator *term)
 {
   for (size_t i = 0; i < term->successor_count (); ++i)
     {
       if (term->alive (i))
         {
           jit_block *succ = term->successor (i);
-          for (jit_block::iterator iter = succ->begin (); iter != succ->end ()
-                 && isa<jit_phi> (*iter); ++iter)
+          for (jit_block::iterator iter = succ->begin ();
+               iter != succ->end () && isa<jit_phi> (*iter); ++iter)
             push_worklist (*iter);
 
           jit_terminator *sterm = succ->terminator ();
           if (sterm)
             push_worklist (sterm);
         }
     }
 }
@@ -1558,17 +1564,17 @@ jit_infer::construct_ssa (void)
 
           for (jit_block::df_iterator diter = b->df_begin ();
                diter != b->df_end (); ++diter)
             {
               jit_block *dblock = *diter;
               if (! added_phi.count (dblock))
                 {
                   jit_phi *phi = factory.create<jit_phi> (iter->second,
-                                                  dblock->use_count ());
+                                                          dblock->use_count ());
                   dblock->prepend (phi);
                   added_phi.insert (dblock);
                 }
 
               if (! visited.count (dblock))
                 {
                   ssa_worklist.push_back (dblock);
                   visited.insert (dblock);
@@ -1595,18 +1601,18 @@ jit_infer::do_construct_ssa (jit_block& 
       instr->push_variable ();
     }
 
   // finish phi nodes of successors
   for (size_t i = 0; i < ablock.successor_count (); ++i)
     {
       jit_block *finish = ablock.successor (i);
 
-      for (jit_block::iterator iter = finish->begin (); iter != finish->end ()
-             && isa<jit_phi> (*iter);)
+      for (jit_block::iterator iter = finish->begin ();
+           iter != finish->end () && isa<jit_phi> (*iter);)
         {
           jit_phi *phi = static_cast<jit_phi *> (*iter);
           jit_variable *var = phi->dest ();
           ++iter;
 
           if (var->has_top ())
             phi->add_incomming (&ablock, var->top ());
           else
@@ -1655,18 +1661,18 @@ void
 jit_infer::remove_dead ()
 {
   jit_block_list::iterator biter;
   for (biter = blocks.begin (); biter != blocks.end (); ++biter)
     {
       jit_block *b = *biter;
       if (b->alive ())
         {
-          for (jit_block::iterator iter = b->begin (); iter != b->end ()
-                 && isa<jit_phi> (*iter);)
+          for (jit_block::iterator iter = b->begin ();
+               iter != b->end () && isa<jit_phi> (*iter);)
             {
               jit_phi *phi = static_cast<jit_phi *> (*iter);
               if (phi->prune ())
                 iter = b->remove (iter);
               else
                 ++iter;
             }
         }
@@ -1770,18 +1776,18 @@ jit_infer::release_temp (jit_block& ablo
               temp.erase (arg);
             }
         }
     }
 
   if (! temp.size () || ! isa<jit_error_check> (ablock.terminator ()))
     return;
 
-  // FIXME: If we support try/catch or unwind_protect final_block may not be the
-  // destination
+  // FIXME: If we support try/catch or unwind_protect final_block
+  //        may not be the destination
   jit_block *split = ablock.maybe_split (factory, blocks, final_block ());
   jit_terminator *term = split->terminator ();
   for (std::set<jit_value *>::const_iterator iter = temp.begin ();
        iter != temp.end (); ++iter)
     {
       jit_value *value = *iter;
       jit_call *release
         = factory.create<jit_call> (&jit_typeinfo::release, value);
@@ -1792,18 +1798,18 @@ jit_infer::release_temp (jit_block& ablo
 
 void
 jit_infer::simplify_phi (void)
 {
   for (jit_block_list::iterator biter = blocks.begin (); biter != blocks.end ();
        ++biter)
     {
       jit_block &ablock = **biter;
-      for (jit_block::iterator iter = ablock.begin (); iter != ablock.end ()
-             && isa<jit_phi> (*iter); ++iter)
+      for (jit_block::iterator iter = ablock.begin ();
+           iter != ablock.end () && isa<jit_phi> (*iter); ++iter)
         simplify_phi (*static_cast<jit_phi *> (*iter));
     }
 }
 
 void
 jit_infer::simplify_phi (jit_phi& phi)
 {
   jit_block& pblock = *phi.parent ();
@@ -1949,34 +1955,34 @@ tree_jit::do_execute (tree_while_command
 bool
 tree_jit::do_execute (octave_user_function& fcn, const octave_value_list& args,
                       octave_value_list& retval)
 {
   if (! initialize () || ! enabled ())
     return false;
 
   jit_function_info *info = fcn.get_info ();
-    if (! info || ! info->match (args))
-      {
-        delete info;
-        info = new jit_function_info (*this, fcn, args);
-        fcn.stash_info (info);
-      }
+  if (! info || ! info->match (args))
+    {
+      delete info;
+      info = new jit_function_info (*this, fcn, args);
+      fcn.stash_info (info);
+    }
 
-    return info->execute (args, retval);
+  return info->execute (args, retval);
 }
 
 bool
 tree_jit::enabled (void)
 {
   // Ideally, we should only disable JIT if there is a breakpoint in the code we
   // are about to run. However, we can't figure this out in O(1) time, so we
   // conservatively check for the existence of any breakpoints.
   return Vjit_enable && ! bp_table::have_breakpoints ()
-    && ! Vdebug_on_interrupt && ! Vdebug_on_error;
+         && ! Vdebug_on_interrupt && ! Vdebug_on_error;
 }
 
 size_t
 tree_jit::trip_count (const octave_value& bounds) const
 {
   if (bounds.is_range ())
     {
       Range rng = bounds.range_value ();
@@ -2298,23 +2304,23 @@ jit_info::compile (tree_jit& tjit, tree&
     }
 }
 
 octave_value
 jit_info::find (const vmap& extra_vars, const std::string& vname) const
 {
   vmap::const_iterator iter = extra_vars.find (vname);
   return iter == extra_vars.end () ? symbol_table::varval (vname)
-    : *iter->second;
+                                   : *iter->second;
 }
 
 #endif
 
 DEFUN (debug_jit, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} debug_jit ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} debug_jit (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} debug_jit (@var{new_val}, \"local\")\n\
 Query or set the internal variable that determines whether\n\
 debugging/tracing is enabled for Octave's JIT compiler.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.  \n\
@@ -2326,17 +2332,17 @@ The original variable value is restored 
   return SET_INTERNAL_VARIABLE (debug_jit);
 #else
   warning ("debug_jit: JIT compiling not available in this version of Octave");
   return octave_value ();
 #endif
 }
 
 DEFUN (jit_enable, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} jit_enable ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} jit_enable (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} jit_enable (@var{new_val}, \"local\")\n\
 Query or set the internal variable that enables Octave's JIT compiler.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.  \n\
 The original variable value is restored when exiting the function.\n\
@@ -2347,17 +2353,17 @@ The original variable value is restored 
   return SET_INTERNAL_VARIABLE (jit_enable);
 #else
   warning ("jit_enable: JIT compiling not available in this version of Octave");
   return octave_value ();
 #endif
 }
 
 DEFUN (jit_startcnt, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} jit_startcnt ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} jit_startcnt (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} jit_startcnt (@var{new_val}, \"local\")\n\
 Query or set the internal variable that determines whether JIT compilation\n\
 will take place for a specific loop.  Because compilation is a costly\n\
 operation it does not make sense to employ JIT when the loop count is low.\n\
 By default only loops with greater than 1000 iterations will be accelerated.\n\
 \n\
diff --git a/libinterp/corefcn/pt-jit.h b/libinterp/corefcn/pt-jit.h
--- a/libinterp/corefcn/pt-jit.h
+++ b/libinterp/corefcn/pt-jit.h
@@ -360,17 +360,17 @@ public:
   static bool execute (octave_user_function& fcn, const octave_value_list& args,
                        octave_value_list& retval);
 
   llvm::ExecutionEngine *get_engine (void) const { return engine; }
 
   llvm::Module *get_module (void) const { return module; }
 
   void optimize (llvm::Function *fn);
- private:
+private:
   tree_jit (void);
 
   static tree_jit& instance (void);
 
   bool initialize (void);
 
   bool do_execute (tree_simple_for_command& cmd, const octave_value& bounds);
 
diff --git a/libinterp/corefcn/quad.cc b/libinterp/corefcn/quad.cc
--- a/libinterp/corefcn/quad.cc
+++ b/libinterp/corefcn/quad.cc
@@ -168,17 +168,17 @@ quad_float_user_function (float x)
   do \
     { \
       ::error ("quad: " fmt, arg); \
       QUAD_ABORT (); \
     } \
   while (0)
 
 DEFUN (quad, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{q} =} quad (@var{f}, @var{a}, @var{b})\n\
 @deftypefnx {Built-in Function} {@var{q} =} quad (@var{f}, @var{a}, @var{b}, @var{tol})\n\
 @deftypefnx {Built-in Function} {@var{q} =} quad (@var{f}, @var{a}, @var{b}, @var{tol}, @var{sing})\n\
 @deftypefnx {Built-in Function} {[@var{q}, @var{ier}, @var{nfun}, @var{err}] =} quad (@dots{})\n\
 Numerically evaluate the integral of @var{f} from @var{a} to @var{b} using\n\
 Fortran routines from @w{@sc{quadpack}}.  @var{f} is a function handle,\n\
 inline function, or a string containing the name of the function to\n\
 evaluate.  The function must have the form @code{y = f (x)} where @var{y} and\n\
@@ -254,17 +254,18 @@ variable by routines @code{dblquad} and 
             QUAD_ABORT1 ("expecting second argument to be a scalar");
 
           float b = args(2).float_value ();
 
           if (error_state)
             QUAD_ABORT1 ("expecting third argument to be a scalar");
 
           int indefinite = 0;
-          FloatIndefQuad::IntegralType indef_type = FloatIndefQuad::doubly_infinite;
+          FloatIndefQuad::IntegralType indef_type
+            = FloatIndefQuad::doubly_infinite;
           float bound = 0.0;
           if (xisinf (a) && xisinf (b))
             {
               indefinite = 1;
               indef_type = FloatIndefQuad::doubly_infinite;
             }
           else if (xisinf (a))
             {
diff --git a/libinterp/corefcn/quadcc.cc b/libinterp/corefcn/quadcc.cc
--- a/libinterp/corefcn/quadcc.cc
+++ b/libinterp/corefcn/quadcc.cc
@@ -33,48 +33,50 @@ along with Octave; see the file COPYING.
 #include "oct-obj.h"
 #include "utils.h"
 
 
 /* Extended debugging */
 #define DEBUG_QUADCC 0
 
 /* Define the minimum size of the interval heap. */
-#define min_cquad_heapsize  200 
+#define min_cquad_heapsize  200
 
 
 /* Data of a single interval */
 typedef struct
 {
   double a, b;
   double c[64];
   double fx[33];
   double igral, err;
   int depth, rdepth, ndiv;
 } cquad_ival;
 
 /* Some constants and matrices that we'll need.  */
 
-static const double xi[33] = {
+static const double xi[33] =
+{
   -1., -0.99518472667219688624, -0.98078528040323044912,
   -0.95694033573220886493, -0.92387953251128675612,
   -0.88192126434835502970, -0.83146961230254523708,
   -0.77301045336273696082, -0.70710678118654752440,
   -0.63439328416364549822, -0.55557023301960222475,
   -0.47139673682599764857, -0.38268343236508977173,
   -0.29028467725446236764, -0.19509032201612826785,
   -0.098017140329560601995, 0., 0.098017140329560601995,
   0.19509032201612826785, 0.29028467725446236764, 0.38268343236508977173,
   0.47139673682599764857, 0.55557023301960222475, 0.63439328416364549822,
   0.70710678118654752440, 0.77301045336273696082, 0.83146961230254523708,
   0.88192126434835502970, 0.92387953251128675612, 0.95694033573220886493,
   0.98078528040323044912, 0.99518472667219688624, 1.
 };
 
-static const double bee[68] = {
+static const double bee[68] =
+{
   0.00000000000000e+00, 2.28868854108532e-01, 0.00000000000000e+00,
   -8.15740215243451e-01, 0.00000000000000e+00, 5.31212715259731e-01,
   0.00000000000000e+00, 1.38538036812454e-02, 0.00000000000000e+00,
   3.74405228908818e-02, 0.00000000000000e+00, 2.12224115039342e-01,
   0.00000000000000e+00, -8.16362644507898e-01, 0.00000000000000e+00,
   5.35648426691481e-01, 0.00000000000000e+00, 1.52417902753662e-03,
   0.00000000000000e+00, 2.63058840550873e-03, 0.00000000000000e+00,
   4.15292106318904e-03, 0.00000000000000e+00, 6.97106011119775e-03,
@@ -90,57 +92,61 @@ static const double bee[68] = {
   1.76616363801885e-03, 0.00000000000000e+00, 2.53323433039089e-03,
   0.00000000000000e+00, 3.88872172121956e-03, 0.00000000000000e+00,
   6.58635106468291e-03, 0.00000000000000e+00, 1.30326736343254e-02,
   0.00000000000000e+00, 3.44353850696714e-02, 0.00000000000000e+00,
   2.05025409531915e-01, 0.00000000000000e+00, -8.14985893995401e-01,
   0.00000000000000e+00, 5.40679930965238e-01
 };
 
-static const double Lalpha[33] = {
+static const double Lalpha[33] =
+{
   5.77350269189626e-01, 5.16397779494322e-01, 5.07092552837110e-01,
   5.03952630678970e-01, 5.02518907629606e-01, 5.01745206004255e-01,
   5.01280411827603e-01, 5.00979432868120e-01, 5.00773395667191e-01,
   5.00626174321759e-01, 5.00517330712619e-01, 5.00434593736979e-01,
   5.00370233297676e-01, 5.00319182924304e-01, 5.00278009473803e-01,
   5.00244319584578e-01, 5.00216403386025e-01, 5.00193012939056e-01,
   5.00173220168024e-01, 5.00156323280355e-01, 5.00141783641018e-01,
   5.00129182278347e-01, 5.00118189340972e-01, 5.00108542278496e-01,
   5.00100030010004e-01, 5.00092481273333e-01, 5.00085755939229e-01,
   5.00079738458365e-01, 5.00074332862969e-01, 5.00069458915387e-01,
   5.00065049112355e-01, 5.00061046334395e-01, 5.00057401986298e-01
 };
 
-static const double Lgamma[33] = {
+static const double Lgamma[33] =
+{
   0.0, 0.0, 5.16397779494322e-01, 5.07092552837110e-01, 5.03952630678970e-01,
   5.02518907629606e-01, 5.01745206004255e-01, 5.01280411827603e-01,
   5.00979432868120e-01, 5.00773395667191e-01, 5.00626174321759e-01,
   5.00517330712619e-01, 5.00434593736979e-01, 5.00370233297676e-01,
   5.00319182924304e-01, 5.00278009473803e-01, 5.00244319584578e-01,
   5.00216403386025e-01, 5.00193012939056e-01, 5.00173220168024e-01,
   5.00156323280355e-01, 5.00141783641018e-01, 5.00129182278347e-01,
   5.00118189340972e-01, 5.00108542278496e-01, 5.00100030010003e-01,
   5.00092481273333e-01, 5.00085755939229e-01, 5.00079738458365e-01,
   5.00074332862969e-01, 5.00069458915387e-01, 5.00065049112355e-01,
   5.00061046334395e-01
 };
 
-static const double V1inv[5 * 5] = {
+static const double V1inv[5 * 5] =
+{
   .47140452079103168293e-1, .37712361663282534635, .56568542494923801952,
   .37712361663282534635, .47140452079103168293e-1,
   -.81649658092772603273e-1, -.46188021535170061160, 0,
   .46188021535170061160, .81649658092772603273e-1, .15058465048420853962,
   .12046772038736683169, -.54210474174315074262, .12046772038736683169,
   .15058465048420853962, -.21380899352993950775, .30237157840738178177, -0.,
   -.30237157840738178177, .21380899352993950775, .10774960475223581324,
   -.21549920950447162648, .21549920950447162648, -.21549920950447162648,
   .10774960475223581324
 };
 
-static const double V2inv[9 * 9] = {
+static const double V2inv[9 * 9] =
+{
   .11223917161691230546e-1, .10339219839658349826, .19754094204576565761,
   .25577315077753587922, .27835314560994251755, .25577315077753587922,
   .19754094204576565761, .10339219839658349826, .11223917161691230546e-1,
   -.19440394783993476970e-1, -.16544884625069155470, -.24193725566041460608,
   -.16953338808305493604, 0.0, .16953338808305493604, .24193725566041460608,
   .16544884625069155470, .19440394783993476970e-1, .26466393115406349388e-1,
   .17766815796285469394, .11316664642449611462, -.16306601003711325980,
   -.30847037493128779631, -.16306601003711325980, .11316664642449611462,
@@ -164,17 +170,18 @@ static const double V2inv[9 * 9] = {
   -.10894869830716590913, .20131094491947531782, -.15407672674888869038,
   .83385723639789791384e-1, 0.0, -.83385723639789791384e-1,
   .15407672674888869038, -.20131094491947531782, .10894869830716590913,
   .54581057089643838221e-1, -.10916211417928767644, .10916211417928767644,
   -.10916211417928767644, .10916211417928767644, -.10916211417928767644,
   .10916211417928767644, -.10916211417928767644, .54581057089643838221e-1
 };
 
-static const double V3inv[17 * 17] = {
+static const double V3inv[17 * 17] =
+{
   .27729677693590098996e-2, .26423663180333065153e-1,
   .53374068493933898312e-1, .77007854739523195947e-1,
   .98257061072911596869e-1, .11538049741786835604, .12832134344120884559,
   .13612785914022865001, .13888293186236181317, .13612785914022865001,
   .12832134344120884559, .11538049741786835604, .98257061072911596869e-1,
   .77007854739523195947e-1, .53374068493933898312e-1,
   .26423663180333065153e-1, .27729677693590098996e-2,
   -.48029210642807413690e-2, -.44887724635478800254e-1,
@@ -301,17 +308,18 @@ static const double V3inv[17 * 17] = {
   -.54971216929497681146e-1, .54971216929497681146e-1,
   -.54971216929497681146e-1, .54971216929497681146e-1,
   -.54971216929497681146e-1, .54971216929497681146e-1,
   -.54971216929497681146e-1, .54971216929497681146e-1,
   -.54971216929497681146e-1, .54971216929497681146e-1,
   -.54971216929497681146e-1, .27485608464748840573e-1
 };
 
-static const double V4inv[33 * 33] = {
+static const double V4inv[33 * 33] =
+{
   .69120897476690862600e-3, .66419939766331555194e-2,
   .13600665164323186111e-1, .20122785860913684493e-1,
   .26583214101668429944e-1, .32712713318999268739e-1,
   .38576221976287138036e-1, .44033030938268925133e-1,
   .49092709529622799673e-1, .53657949874312515646e-1,
   .57724533144734311859e-1, .61219564530655179096e-1,
   .64138907503837875026e-1, .66427905189318792009e-1,
   .68088956652280022887e-1, .69083051391555695878e-1,
@@ -877,17 +885,18 @@ static const double V4inv[33 * 33] = {
   -.27588282524939131481e-1, .27588282524939131481e-1,
   -.27588282524939131481e-1, .27588282524939131481e-1,
   -.27588282524939131481e-1, .27588282524939131481e-1,
   -.27588282524939131481e-1, .27588282524939131481e-1,
   -.27588282524939131481e-1, .27588282524939131481e-1,
   -.27588282524939131481e-1, .13794141262469565740e-1
 };
 
-static const double Tleft[33 * 33] = {
+static const double Tleft[33 * 33] =
+{
   1., -.86602540378443864678, 0., .33071891388307382381, 0.,
   -.20728904939721249057, 0., .15128841196122722208, 0.,
   -.11918864298744029244, 0., .98352013661686631224e-1, 0.,
   -.83727065404940845733e-1, 0., .72893399403505841203e-1, 0.,
   -.64544632643375022436e-1, 0., .57913170372415565639e-1, 0.,
   -.52518242575729562263e-1, 0., .48043311993977520457e-1, 0.,
   -.44271433659733990243e-1, 0., .41048928022856771981e-1, 0.,
   -.38263878662008271459e-1, 0., .35832844026365304501e-1, 0., 0.,
@@ -1131,263 +1140,264 @@ static const double Tleft[33 * 33] = {
   -.28867244235852488244e-7, .43982811713864556957e-6, 0., 0., 0., 0., 0.,
   0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
   0., 0., 0., 0., 0., 0., 0., 0., .46566128730773925781e-9,
   -.14899342093408253335e-7, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
   0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
   0., 0., .23283064365386962891e-9
 };
 
-static const double Tright[33 * 33] = {
+static const double Tright[33 * 33] =
+{
   1., .86602540378443864678, 0., -.33071891388307382381, 0.,
-    .20728904939721249057, 0., -.15128841196122722208, 0.,
-    .11918864298744029244, 0., -.98352013661686631224e-1, 0.,
-    .83727065404940845733e-1, 0., -.72893399403505841203e-1, 0.,
-    .64544632643375022436e-1, 0., -.57913170372415565639e-1, 0.,
-    .52518242575729562263e-1, 0., -.48043311993977520457e-1, 0.,
-    .44271433659733990243e-1, 0., -.41048928022856771981e-1, 0.,
-    .38263878662008271459e-1, 0., -.35832844026365304501e-1, 0., 0.,
-    .50000000000000000000, .96824583655185422130, .57282196186948000082,
-    -.21650635094610966169, -.35903516540862679125, .97578093724974971969e-1,
-    .26203921611325660506, -.55792409597991015609e-1, -.20644078533943456204,
-    .36172381205961199479e-1, .17035068468874958194,
-    -.25371838001497225980e-1, -.14501953125000000000,
-    .18786835250972344757e-1, .12625507130328301066,
-    -.14473795929590520582e-1, -.11179458309419422675,
-    .11494434254897626155e-1, .10030855351241635862,
-    -.93498556820544479096e-2, -.90964264465390582629e-1,
-    .77546391824364392762e-2, .83213457337452292745e-1,
-    -.65358085945588638605e-2, -.76680372422574234569e-1,
-    .55835321940047427169e-2, .71098828931825789428e-1,
-    -.48253327982967591019e-2, -.66274981937248958553e-1,
-    .42118078245337801387e-2, .62064306433355646267e-1,
-    -.37083386598903548973e-2, 0., 0., .25000000000000000000,
-    .73950997288745200531, .83852549156242113615, .23175620272173946716,
-    -.37791833195149451496, -.25710129174850522325, .21608307321780204633,
-    .22844049245646009157, -.14009503000335388415, -.19897685605518413847,
-    .98264706042471226893e-1, .17445445004279014046,
-    -.72761100054958328401e-1, -.15463589893742108388,
-    .56056770591708784481e-1, .13855313872640495158,
-    -.44517752443294564781e-1, -.12534277657695128850,
-    .36211835346039665762e-1, .11434398255136139683,
-    -.30033588409423828125e-1, -.10506705408753910481,
-    .25313077840725783008e-1, .97149327637744872155e-1,
-    -.21624927200393328444e-1, -.90319582367202122625e-1,
-    .18688433567711780666e-1, .84372291635345108584e-1,
-    -.16312261561845420752e-1, -.79149526894804751586e-1,
-    .14362333871852474757e-1, 0., 0., 0., .12500000000000000000,
-    .49607837082461073572, .82265291131801144317, .59621200088559103072,
-    -.80054302859059362371e-1, -.42612156697795759420,
-    -.90098145270865592887e-1, .29769623255090078484, .13630307904779758221,
-    -.21638835185708931831, -.14600247270306082052, .16348801804014290453,
-    .14340708728599057249, -.12755243353979286190, -.13661523715071346961,
-    .10215585947881057394, .12864248070157166547, -.83592528025348693602e-1,
-    -.12066728689302565222, .69633728678718053052e-1, .11314245177331919532,
-    -.58882939251410088028e-1, -.10621835858758221487,
-    .50432266865187597572e-1, .99916834723527771581e-1,
-    -.43672094283057258509e-1, -.94206380251950852413e-1,
-    .38181356812697746418e-1, .89035739656537771225e-1,
-    -.33661934598216332678e-1, 0., 0., 0., 0., .62500000000000000000e-1,
-    .31093357409581873586, .67604086414949799246, .75644205980613611039,
-    .28990586430124175741, -.30648508196770360914, -.35801372616842500052,
-    .91326869828709014708e-1, .31127929687500000000, .90915752838698393094e-2,
-    -.25637381283965534330, -.57601077850322797594e-1, .21019685709225757945,
-    .81244992138514014256e-1, -.17375078516720988858,
-    -.92289437277967051125e-1, .14527351914265391374,
-    .96675340792832019889e-1, -.12289485697108543415,
-    -.97448175340011084006e-1, .10511755943298339844,
-    .96242247086378239657e-1, -.90822942272780513537e-1,
-    -.93966350452322132384e-1, .79189411876493712558e-1,
-    .91139307067989309325e-1, -.69613039934383197265e-1,
-    -.88062491671135767870e-1, .61646331729340817494e-1, 0., 0., 0., 0., 0.,
-    .31250000000000000000e-1, .18684782411095934408, .50176689760410660236,
-    .74784031498626095398, .56472001151566251186, -.14842464993721351203e-1,
-    -.41162920273003120936, -.20243071230196532282, .23772054897172750436,
-    .24963810923972235950, -.12116179938394678936, -.24330535483519110663,
-    .47903849781124471359e-1, .22133299683101224293,
-    -.20542915138527200983e-2, -.19653465717678146728,
-    -.26818172626509178444e-1, .17319122357631210944,
-    .45065391411065545445e-1, -.15253391395444065941,
-    -.56543897711725408302e-1, .13469154928743585367,
-    .63632471400208840155e-1, -.11941684923913523817,
-    -.67828850207933293098e-1, .10636309084510652670,
-    .70095786922999181504e-1, -.95187373095150709082e-1, 0., 0., 0., 0., 0.,
-    0., .15625000000000000000e-1, .10909562534194485289,
-    .34842348626527747318, .64461114561628111443, .69382480527334683659,
-    .29551102358528827763, -.25527584713978439819, -.38878771718544715394,
-    -.82956185835347407489e-2, .31183177761966943912, .12831420840372374767,
-    -.22067618205599434368, -.17569196937129496961, .14598057000132284135,
-    .18864406621763419484, -.89921002550386645767e-1, -.18571835020187122114,
-    .48967672227195481777e-1, .17584685670380332798,
-    -.19267984545067426324e-1, -.16335437520503462738,
-    -.22598055455032407594e-2, .15032800884170631129,
-    .17883358353754640871e-1, -.13774837869432209951,
-    -.29227555960587143675e-1, .12604194747513151053, 0., 0., 0., 0., 0., 0.,
-    0., .78125000000000000000e-2, .62377810244809812496e-1,
-    .23080781467370883845, .50841310636012325368, .69834547012574056043,
-    .52572723156526459672, .11464215704954976471e-1, -.38698869011491210342,
-    -.26125646622255207507, .16951698812361607510, .29773875898928782269,
-    -.20130501202570367491e-1, -.26332493149159310198,
-    -.67734613690401207009e-1, .21207315477103762715, .11541543390889415193,
-    -.16249634759782417533, -.13885887405041735068, .11996491328010275427,
-    .14810432001630926895, -.85177658352556243411e-1, -.14918860659904380587,
-    .57317789510444151564e-1, .14569827645586660151,
-    -.35213090145965327390e-1, -.13975998126844578198, 0., 0., 0., 0., 0., 0.,
-    0., 0., .39062500000000000000e-2, .35101954600803571207e-1,
-    .14761284084133737720, .37655033076080192966, .62410290231517322776,
-    .64335622317683389875, .28188168266139524244, -.22488495672137010675,
-    -.39393811089283576186, -.75184777995770096714e-1, .28472023119398293003,
-    .20410910833705899572, -.15590046962908511750, -.23814567544617953125,
-    .54442805556829031204e-1, .22855930338589720954, .16303223615756629897e-1,
-    -.20172722433875559213, -.62723406421217419404e-1, .17012230831020922010,
-    .91754642766136561612e-1, -.13927644821381121197, -.10886600968068418181,
-    .11139075654373395292, .11797455976331702879, 0., 0., 0., 0., 0., 0., 0.,
-    0., 0., .19531250000000000000e-2, .19506820659607596598e-1,
-    .91865676095362231937e-1, .26604607809696493849, .51425874205091288223,
-    .66047561132505329292, .48660109511591303851, .17575661168678285615e-1,
-    -.36594333408055703366, -.29088854695378694533, .11318677346656537927,
-    .31110645235730182168, .60733219161008787341e-1, -.24333848233620420826,
-    -.15254312332655419708, .15995968483455388613, .19010344455215289289,
-    -.86040636766440260000e-1, -.19652589954665259945,
-    .27633388517205837713e-1, .18660848552712880387, .15942583868416775867e-1,
-    -.16902042462382064786, -.47278526495327740646e-1, 0., 0., 0., 0., 0., 0.,
-    0., 0., 0., 0., .97656250000000000000e-3, .10731084460857378207e-1,
-    .55939644713816406331e-1, .18118487371914493668, .39914857299829864263,
-    .60812322949933902435, .60011887183061967583, .26002695805835928795,
-    -.20883922404786010096, -.38988130966114638081, -.11797833550782589082,
-    .25231824756239520077, .24817859972953934712, -.90516417677868996417e-1,
-    -.26079073291293066798, -.30259468817169480161e-1, .22178195264114178432,
-    .10569877864302048175, -.16679648389266977455, -.14637718550245050850,
-    .11219272032739559870, .16359363640525750353, -.64358194509092101393e-1,
-    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., .48828125000000000000e-3,
-    .58542865274813470967e-2, .33461741635290096452e-1, .11979993155896201271,
-    .29580223766987206958, .51874761979436016742, .62861483498014306968,
-    .44868895761051453296, .12567502628371529386e-1, -.35040366183235474275,
-    -.30466868455569500886, .70903913601490112666e-1, .30822791893032512740,
-    .11969443264190207736, -.20764760317621313946, -.20629838355452128532,
-    .95269702915334718507e-1, .22432624768705133300,
-    -.33103381593477797101e-2, -.20570036048155716333,
-    -.62208282720094518964e-1, .17095309330441436348, 0., 0., 0., 0., 0., 0.,
-    0., 0., 0., 0., 0., 0., .24414062500000000000e-3,
-    .31714797501871532475e-2, .19721062526127334100e-1,
-    .77311181185536498246e-1, .21124871792841566575, .41777980401893650886,
-    .59401977834943551650, .56132417807488349048, .23433675061367565951,
-    -.20222775295220942126, -.38280372496506190127, -.14443804214023095767,
-    .22268950939178466797, .27211314150777981984, -.34184876506180717313e-1,
-    -.26006498895669734842, -.97650425186005090107e-1, .19024527660129101293,
-    .16789164198044635671, -.10875811641651905252, -.19276785058805921298, 0.,
-    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., .12207031250000000000e-3,
-    .17078941137247586143e-2, .11477733754843910060e-1,
-    .48887017020924625462e-1, .14634927241421789683, .32156282683019547854,
-    .52165811920227223937, .60001958466396926460, .41208501541480733755,
-    .11366945503190350975e-2, -.33968093962672089159, -.30955190935923386766,
-    .40657421856578262210e-1, .29873400409871531764, .16094481791768257440,
-    -.16876122436206497694, -.23650217045022161255, .33070260090574765012e-1,
-    .22985258456375907796, .68645651043827097771e-1, 0., 0., 0., 0., 0., 0.,
-    0., 0., 0., 0., 0., 0., 0., 0., .61035156250000000000e-4,
-    .91501857608428649078e-3, .66085179496951987952e-2,
-    .30383171695850355404e-1, .98840838845366876117e-1, .23855447246420318989,
-    .43322017468145613917, .58049033744876107191, .52533893203742699346,
-    .20681056202371946180, -.20180000924562504384, -.37503922291962681797,
-    -.15988102869837429062, .19823558102762374094, .28393023878803799622,
-    .11188133439357510403e-1, -.24730368377168229255, -.14731529061377942839,
-    .14878558042884266021, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
-    0., 0., .30517578125000000000e-4, .48804277318479845551e-3,
-    .37696080990601968396e-2, .18603912108994738255e-1,
-    .65325006755649582964e-1, .17162960707938819795, .34411527956476971322,
-    .52289350347082497959, .57319653625674910592, .37662253421045430413,
-    -.14099055105384663902e-1, -.33265570610216904208, -.30921265572647566661,
-    .19911390594166455281e-1, .28738590811031797718, .18912130469738472647,
-    -.13235936203215819193, -.25076406142356675279, 0., 0., 0., 0., 0., 0.,
-    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., .15258789062500000000e-4,
-    .25928719280954633249e-3, .21327398937568540428e-2,
-    .11244626133630732010e-1, .42375605740664331966e-1, .12031130345907846211,
-    .26352562258934426830, .44590628258512682078, .56682835613700749379,
-    .49116715128261660395, .17845943097110339078, -.20541650677432497477,
-    -.36739803642257458221, -.16776034069210108273, .17920950989905112908,
-    .28867732805385066532, .46473465543376206337e-1, 0., 0., 0., 0., 0., 0.,
-    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., .76293945312500000000e-5,
-    .13727610943181290891e-3, .11979683091449349286e-2,
-    .67195313034570709806e-2, .27044920779931968175e-1,
-    .82472196498517457862e-1, .19570475044896150093, .36391620788543817693,
-    .52241392782736588032, .54727504974907879912, .34211551468813581183,
-    -.31580472732719957762e-1, -.32830006549176759667, -.30563797665254420769,
-    .64905014620683140120e-2, .27642986248995073032, 0., 0., 0., 0., 0., 0.,
-    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., .38146972656250000000e-5,
-    .72454147007837596854e-4, .66859847582761390285e-3,
-    .39751311980366118437e-2, .17015198650201528366e-1,
-    .55443621868993855715e-1, .14157060481641692131, .28641242619559616836,
-    .45610665490966615415, .55262786406029265394, .45818352706035500108,
-    .14984403004611673047, -.21163807462970713245, -.36007252928843413718,
-    -.17030961385712954159, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
-    0., 0., 0., 0., 0., 0., 0., .19073486328125000000e-5,
-    .38135049864067468562e-4, .37101393638555730015e-3,
-    .23305339886279723213e-2, .10569913448297127219e-1,
-    .36640175162216897547e-1, .10010476414320235508, .21860074212675559892,
-    .38124757096345313719, .52020999209879669177, .52172632730659212045,
-    .30841620620308814614, -.50322546186721500184e-1, -.32577618885114899053,
-    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
-    0., 0., .95367431640625000000e-6, .20021483206955925244e-4,
-    .20481807322420625431e-3, .13553476938058909882e-2,
-    .64919676350791905019e-2, .23848725425069251903e-1,
-    .69384632678886421292e-1, .16249711393618776934, .30736618106830314788,
-    .46399909601971539157, .53765031034002467225, .42598991476520183929,
-    .12130445348350215652, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
-    0., 0., 0., 0., 0., 0., 0., 0., .47683715820312500000e-6,
-    .10487707828484902486e-4, .11254146162337528943e-3,
-    .78248929534271987118e-3, .39468337145306794566e-2,
-    .15313546659475671763e-1, .47249070825218564146e-1, .11804374107101480543,
-    .24031796927792491122, .39629215049166341285, .51629108968402548545,
-    .49622372075429782915, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
-    0., 0., 0., 0., 0., 0., 0., 0., 0., .23841857910156250000e-6,
-    .54823314130625337326e-5, .61575377321535518154e-4,
-    .44877834366497538134e-3, .23774612048621955857e-2,
-    .97136347645161687796e-2, .31671599547606636717e-1,
-    .84028665767000747480e-1, .18298487576742964949, .32647878537696945218,
-    .46970971486488895077, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
-    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., .11920928955078125000e-6,
-    .28604020001177375838e-5, .33559227978295551013e-4,
-    .25583821662860610560e-3, .14201552747787302339e-2,
-    .60938046986874414969e-2, .20930869247951926793e-1,
-    .58745021125678072911e-1, .13613725780285953720, .26083988356030237586,
-    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
-    0., 0., 0., 0., 0., 0., .59604644775390625000e-7,
-    .14898180663526043291e-5, .18224991282807693921e-4,
-    .14504433444608833821e-3, .84184722720281809548e-3,
-    .37846965430000478789e-2, .13656355548211376864e-1,
-    .40409541997718853934e-1, .99226988101858325902e-1, 0., 0., 0., 0., 0.,
-    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
-    0., 0., .29802322387695312500e-7, .77471708843445529468e-6,
-    .98649879372606876995e-5, .81814934772838523887e-4,
-    .49554483992403011328e-3, .23290922072351413938e-2,
-    .88068134250844034186e-2, .27393666952485719070e-1, 0., 0., 0., 0., 0.,
-    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
-    0., 0., 0., .14901161193847656250e-7, .40226235946098233685e-6,
-    .53236418690561306700e-5, .45933829691164002269e-4,
-    .28982005232838857913e-3, .14212974043211018374e-2,
-    .56192363087488842264e-2, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
-    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
-    .74505805969238281250e-8, .20858299254133430408e-6,
-    .28648457300134381744e-5, .25677535898258910850e-4,
-    .16849420429491355445e-3, .86062824010315834002e-3, 0., 0., 0., 0., 0.,
-    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
-    0., 0., 0., 0., 0., .37252902984619140625e-8, .10801736017613096861e-6,
-    .15376606719887104015e-5, .14296523739727437959e-4,
-    .97419023656050887203e-4, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
-    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
-    .18626451492309570312e-8, .55871592916438890146e-7,
-    .82331193828137454068e-6, .79302250528382787666e-5, 0., 0., 0., 0., 0.,
-    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
-    0., 0., 0., 0., 0., 0., 0., .93132257461547851562e-9,
-    .28867244235852488244e-7, .43982811713864556957e-6, 0., 0., 0., 0., 0.,
-    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
-    0., 0., 0., 0., 0., 0., 0., 0., .46566128730773925781e-9,
-    .14899342093408253335e-7, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
-    0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
-    0., 0., .23283064365386962891e-9
+  .20728904939721249057, 0., -.15128841196122722208, 0.,
+  .11918864298744029244, 0., -.98352013661686631224e-1, 0.,
+  .83727065404940845733e-1, 0., -.72893399403505841203e-1, 0.,
+  .64544632643375022436e-1, 0., -.57913170372415565639e-1, 0.,
+  .52518242575729562263e-1, 0., -.48043311993977520457e-1, 0.,
+  .44271433659733990243e-1, 0., -.41048928022856771981e-1, 0.,
+  .38263878662008271459e-1, 0., -.35832844026365304501e-1, 0., 0.,
+  .50000000000000000000, .96824583655185422130, .57282196186948000082,
+  -.21650635094610966169, -.35903516540862679125, .97578093724974971969e-1,
+  .26203921611325660506, -.55792409597991015609e-1, -.20644078533943456204,
+  .36172381205961199479e-1, .17035068468874958194,
+  -.25371838001497225980e-1, -.14501953125000000000,
+  .18786835250972344757e-1, .12625507130328301066,
+  -.14473795929590520582e-1, -.11179458309419422675,
+  .11494434254897626155e-1, .10030855351241635862,
+  -.93498556820544479096e-2, -.90964264465390582629e-1,
+  .77546391824364392762e-2, .83213457337452292745e-1,
+  -.65358085945588638605e-2, -.76680372422574234569e-1,
+  .55835321940047427169e-2, .71098828931825789428e-1,
+  -.48253327982967591019e-2, -.66274981937248958553e-1,
+  .42118078245337801387e-2, .62064306433355646267e-1,
+  -.37083386598903548973e-2, 0., 0., .25000000000000000000,
+  .73950997288745200531, .83852549156242113615, .23175620272173946716,
+  -.37791833195149451496, -.25710129174850522325, .21608307321780204633,
+  .22844049245646009157, -.14009503000335388415, -.19897685605518413847,
+  .98264706042471226893e-1, .17445445004279014046,
+  -.72761100054958328401e-1, -.15463589893742108388,
+  .56056770591708784481e-1, .13855313872640495158,
+  -.44517752443294564781e-1, -.12534277657695128850,
+  .36211835346039665762e-1, .11434398255136139683,
+  -.30033588409423828125e-1, -.10506705408753910481,
+  .25313077840725783008e-1, .97149327637744872155e-1,
+  -.21624927200393328444e-1, -.90319582367202122625e-1,
+  .18688433567711780666e-1, .84372291635345108584e-1,
+  -.16312261561845420752e-1, -.79149526894804751586e-1,
+  .14362333871852474757e-1, 0., 0., 0., .12500000000000000000,
+  .49607837082461073572, .82265291131801144317, .59621200088559103072,
+  -.80054302859059362371e-1, -.42612156697795759420,
+  -.90098145270865592887e-1, .29769623255090078484, .13630307904779758221,
+  -.21638835185708931831, -.14600247270306082052, .16348801804014290453,
+  .14340708728599057249, -.12755243353979286190, -.13661523715071346961,
+  .10215585947881057394, .12864248070157166547, -.83592528025348693602e-1,
+  -.12066728689302565222, .69633728678718053052e-1, .11314245177331919532,
+  -.58882939251410088028e-1, -.10621835858758221487,
+  .50432266865187597572e-1, .99916834723527771581e-1,
+  -.43672094283057258509e-1, -.94206380251950852413e-1,
+  .38181356812697746418e-1, .89035739656537771225e-1,
+  -.33661934598216332678e-1, 0., 0., 0., 0., .62500000000000000000e-1,
+  .31093357409581873586, .67604086414949799246, .75644205980613611039,
+  .28990586430124175741, -.30648508196770360914, -.35801372616842500052,
+  .91326869828709014708e-1, .31127929687500000000, .90915752838698393094e-2,
+  -.25637381283965534330, -.57601077850322797594e-1, .21019685709225757945,
+  .81244992138514014256e-1, -.17375078516720988858,
+  -.92289437277967051125e-1, .14527351914265391374,
+  .96675340792832019889e-1, -.12289485697108543415,
+  -.97448175340011084006e-1, .10511755943298339844,
+  .96242247086378239657e-1, -.90822942272780513537e-1,
+  -.93966350452322132384e-1, .79189411876493712558e-1,
+  .91139307067989309325e-1, -.69613039934383197265e-1,
+  -.88062491671135767870e-1, .61646331729340817494e-1, 0., 0., 0., 0., 0.,
+  .31250000000000000000e-1, .18684782411095934408, .50176689760410660236,
+  .74784031498626095398, .56472001151566251186, -.14842464993721351203e-1,
+  -.41162920273003120936, -.20243071230196532282, .23772054897172750436,
+  .24963810923972235950, -.12116179938394678936, -.24330535483519110663,
+  .47903849781124471359e-1, .22133299683101224293,
+  -.20542915138527200983e-2, -.19653465717678146728,
+  -.26818172626509178444e-1, .17319122357631210944,
+  .45065391411065545445e-1, -.15253391395444065941,
+  -.56543897711725408302e-1, .13469154928743585367,
+  .63632471400208840155e-1, -.11941684923913523817,
+  -.67828850207933293098e-1, .10636309084510652670,
+  .70095786922999181504e-1, -.95187373095150709082e-1, 0., 0., 0., 0., 0.,
+  0., .15625000000000000000e-1, .10909562534194485289,
+  .34842348626527747318, .64461114561628111443, .69382480527334683659,
+  .29551102358528827763, -.25527584713978439819, -.38878771718544715394,
+  -.82956185835347407489e-2, .31183177761966943912, .12831420840372374767,
+  -.22067618205599434368, -.17569196937129496961, .14598057000132284135,
+  .18864406621763419484, -.89921002550386645767e-1, -.18571835020187122114,
+  .48967672227195481777e-1, .17584685670380332798,
+  -.19267984545067426324e-1, -.16335437520503462738,
+  -.22598055455032407594e-2, .15032800884170631129,
+  .17883358353754640871e-1, -.13774837869432209951,
+  -.29227555960587143675e-1, .12604194747513151053, 0., 0., 0., 0., 0., 0.,
+  0., .78125000000000000000e-2, .62377810244809812496e-1,
+  .23080781467370883845, .50841310636012325368, .69834547012574056043,
+  .52572723156526459672, .11464215704954976471e-1, -.38698869011491210342,
+  -.26125646622255207507, .16951698812361607510, .29773875898928782269,
+  -.20130501202570367491e-1, -.26332493149159310198,
+  -.67734613690401207009e-1, .21207315477103762715, .11541543390889415193,
+  -.16249634759782417533, -.13885887405041735068, .11996491328010275427,
+  .14810432001630926895, -.85177658352556243411e-1, -.14918860659904380587,
+  .57317789510444151564e-1, .14569827645586660151,
+  -.35213090145965327390e-1, -.13975998126844578198, 0., 0., 0., 0., 0., 0.,
+  0., 0., .39062500000000000000e-2, .35101954600803571207e-1,
+  .14761284084133737720, .37655033076080192966, .62410290231517322776,
+  .64335622317683389875, .28188168266139524244, -.22488495672137010675,
+  -.39393811089283576186, -.75184777995770096714e-1, .28472023119398293003,
+  .20410910833705899572, -.15590046962908511750, -.23814567544617953125,
+  .54442805556829031204e-1, .22855930338589720954, .16303223615756629897e-1,
+  -.20172722433875559213, -.62723406421217419404e-1, .17012230831020922010,
+  .91754642766136561612e-1, -.13927644821381121197, -.10886600968068418181,
+  .11139075654373395292, .11797455976331702879, 0., 0., 0., 0., 0., 0., 0.,
+  0., 0., .19531250000000000000e-2, .19506820659607596598e-1,
+  .91865676095362231937e-1, .26604607809696493849, .51425874205091288223,
+  .66047561132505329292, .48660109511591303851, .17575661168678285615e-1,
+  -.36594333408055703366, -.29088854695378694533, .11318677346656537927,
+  .31110645235730182168, .60733219161008787341e-1, -.24333848233620420826,
+  -.15254312332655419708, .15995968483455388613, .19010344455215289289,
+  -.86040636766440260000e-1, -.19652589954665259945,
+  .27633388517205837713e-1, .18660848552712880387, .15942583868416775867e-1,
+  -.16902042462382064786, -.47278526495327740646e-1, 0., 0., 0., 0., 0., 0.,
+  0., 0., 0., 0., .97656250000000000000e-3, .10731084460857378207e-1,
+  .55939644713816406331e-1, .18118487371914493668, .39914857299829864263,
+  .60812322949933902435, .60011887183061967583, .26002695805835928795,
+  -.20883922404786010096, -.38988130966114638081, -.11797833550782589082,
+  .25231824756239520077, .24817859972953934712, -.90516417677868996417e-1,
+  -.26079073291293066798, -.30259468817169480161e-1, .22178195264114178432,
+  .10569877864302048175, -.16679648389266977455, -.14637718550245050850,
+  .11219272032739559870, .16359363640525750353, -.64358194509092101393e-1,
+  0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., .48828125000000000000e-3,
+  .58542865274813470967e-2, .33461741635290096452e-1, .11979993155896201271,
+  .29580223766987206958, .51874761979436016742, .62861483498014306968,
+  .44868895761051453296, .12567502628371529386e-1, -.35040366183235474275,
+  -.30466868455569500886, .70903913601490112666e-1, .30822791893032512740,
+  .11969443264190207736, -.20764760317621313946, -.20629838355452128532,
+  .95269702915334718507e-1, .22432624768705133300,
+  -.33103381593477797101e-2, -.20570036048155716333,
+  -.62208282720094518964e-1, .17095309330441436348, 0., 0., 0., 0., 0., 0.,
+  0., 0., 0., 0., 0., 0., .24414062500000000000e-3,
+  .31714797501871532475e-2, .19721062526127334100e-1,
+  .77311181185536498246e-1, .21124871792841566575, .41777980401893650886,
+  .59401977834943551650, .56132417807488349048, .23433675061367565951,
+  -.20222775295220942126, -.38280372496506190127, -.14443804214023095767,
+  .22268950939178466797, .27211314150777981984, -.34184876506180717313e-1,
+  -.26006498895669734842, -.97650425186005090107e-1, .19024527660129101293,
+  .16789164198044635671, -.10875811641651905252, -.19276785058805921298, 0.,
+  0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., .12207031250000000000e-3,
+  .17078941137247586143e-2, .11477733754843910060e-1,
+  .48887017020924625462e-1, .14634927241421789683, .32156282683019547854,
+  .52165811920227223937, .60001958466396926460, .41208501541480733755,
+  .11366945503190350975e-2, -.33968093962672089159, -.30955190935923386766,
+  .40657421856578262210e-1, .29873400409871531764, .16094481791768257440,
+  -.16876122436206497694, -.23650217045022161255, .33070260090574765012e-1,
+  .22985258456375907796, .68645651043827097771e-1, 0., 0., 0., 0., 0., 0.,
+  0., 0., 0., 0., 0., 0., 0., 0., .61035156250000000000e-4,
+  .91501857608428649078e-3, .66085179496951987952e-2,
+  .30383171695850355404e-1, .98840838845366876117e-1, .23855447246420318989,
+  .43322017468145613917, .58049033744876107191, .52533893203742699346,
+  .20681056202371946180, -.20180000924562504384, -.37503922291962681797,
+  -.15988102869837429062, .19823558102762374094, .28393023878803799622,
+  .11188133439357510403e-1, -.24730368377168229255, -.14731529061377942839,
+  .14878558042884266021, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
+  0., 0., .30517578125000000000e-4, .48804277318479845551e-3,
+  .37696080990601968396e-2, .18603912108994738255e-1,
+  .65325006755649582964e-1, .17162960707938819795, .34411527956476971322,
+  .52289350347082497959, .57319653625674910592, .37662253421045430413,
+  -.14099055105384663902e-1, -.33265570610216904208, -.30921265572647566661,
+  .19911390594166455281e-1, .28738590811031797718, .18912130469738472647,
+  -.13235936203215819193, -.25076406142356675279, 0., 0., 0., 0., 0., 0.,
+  0., 0., 0., 0., 0., 0., 0., 0., 0., 0., .15258789062500000000e-4,
+  .25928719280954633249e-3, .21327398937568540428e-2,
+  .11244626133630732010e-1, .42375605740664331966e-1, .12031130345907846211,
+  .26352562258934426830, .44590628258512682078, .56682835613700749379,
+  .49116715128261660395, .17845943097110339078, -.20541650677432497477,
+  -.36739803642257458221, -.16776034069210108273, .17920950989905112908,
+  .28867732805385066532, .46473465543376206337e-1, 0., 0., 0., 0., 0., 0.,
+  0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., .76293945312500000000e-5,
+  .13727610943181290891e-3, .11979683091449349286e-2,
+  .67195313034570709806e-2, .27044920779931968175e-1,
+  .82472196498517457862e-1, .19570475044896150093, .36391620788543817693,
+  .52241392782736588032, .54727504974907879912, .34211551468813581183,
+  -.31580472732719957762e-1, -.32830006549176759667, -.30563797665254420769,
+  .64905014620683140120e-2, .27642986248995073032, 0., 0., 0., 0., 0., 0.,
+  0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., .38146972656250000000e-5,
+  .72454147007837596854e-4, .66859847582761390285e-3,
+  .39751311980366118437e-2, .17015198650201528366e-1,
+  .55443621868993855715e-1, .14157060481641692131, .28641242619559616836,
+  .45610665490966615415, .55262786406029265394, .45818352706035500108,
+  .14984403004611673047, -.21163807462970713245, -.36007252928843413718,
+  -.17030961385712954159, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
+  0., 0., 0., 0., 0., 0., 0., .19073486328125000000e-5,
+  .38135049864067468562e-4, .37101393638555730015e-3,
+  .23305339886279723213e-2, .10569913448297127219e-1,
+  .36640175162216897547e-1, .10010476414320235508, .21860074212675559892,
+  .38124757096345313719, .52020999209879669177, .52172632730659212045,
+  .30841620620308814614, -.50322546186721500184e-1, -.32577618885114899053,
+  0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
+  0., 0., .95367431640625000000e-6, .20021483206955925244e-4,
+  .20481807322420625431e-3, .13553476938058909882e-2,
+  .64919676350791905019e-2, .23848725425069251903e-1,
+  .69384632678886421292e-1, .16249711393618776934, .30736618106830314788,
+  .46399909601971539157, .53765031034002467225, .42598991476520183929,
+  .12130445348350215652, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
+  0., 0., 0., 0., 0., 0., 0., 0., .47683715820312500000e-6,
+  .10487707828484902486e-4, .11254146162337528943e-3,
+  .78248929534271987118e-3, .39468337145306794566e-2,
+  .15313546659475671763e-1, .47249070825218564146e-1, .11804374107101480543,
+  .24031796927792491122, .39629215049166341285, .51629108968402548545,
+  .49622372075429782915, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
+  0., 0., 0., 0., 0., 0., 0., 0., 0., .23841857910156250000e-6,
+  .54823314130625337326e-5, .61575377321535518154e-4,
+  .44877834366497538134e-3, .23774612048621955857e-2,
+  .97136347645161687796e-2, .31671599547606636717e-1,
+  .84028665767000747480e-1, .18298487576742964949, .32647878537696945218,
+  .46970971486488895077, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
+  0., 0., 0., 0., 0., 0., 0., 0., 0., 0., .11920928955078125000e-6,
+  .28604020001177375838e-5, .33559227978295551013e-4,
+  .25583821662860610560e-3, .14201552747787302339e-2,
+  .60938046986874414969e-2, .20930869247951926793e-1,
+  .58745021125678072911e-1, .13613725780285953720, .26083988356030237586,
+  0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
+  0., 0., 0., 0., 0., 0., .59604644775390625000e-7,
+  .14898180663526043291e-5, .18224991282807693921e-4,
+  .14504433444608833821e-3, .84184722720281809548e-3,
+  .37846965430000478789e-2, .13656355548211376864e-1,
+  .40409541997718853934e-1, .99226988101858325902e-1, 0., 0., 0., 0., 0.,
+  0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
+  0., 0., .29802322387695312500e-7, .77471708843445529468e-6,
+  .98649879372606876995e-5, .81814934772838523887e-4,
+  .49554483992403011328e-3, .23290922072351413938e-2,
+  .88068134250844034186e-2, .27393666952485719070e-1, 0., 0., 0., 0., 0.,
+  0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
+  0., 0., 0., .14901161193847656250e-7, .40226235946098233685e-6,
+  .53236418690561306700e-5, .45933829691164002269e-4,
+  .28982005232838857913e-3, .14212974043211018374e-2,
+  .56192363087488842264e-2, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
+  0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
+  .74505805969238281250e-8, .20858299254133430408e-6,
+  .28648457300134381744e-5, .25677535898258910850e-4,
+  .16849420429491355445e-3, .86062824010315834002e-3, 0., 0., 0., 0., 0.,
+  0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
+  0., 0., 0., 0., 0., .37252902984619140625e-8, .10801736017613096861e-6,
+  .15376606719887104015e-5, .14296523739727437959e-4,
+  .97419023656050887203e-4, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
+  0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
+  .18626451492309570312e-8, .55871592916438890146e-7,
+  .82331193828137454068e-6, .79302250528382787666e-5, 0., 0., 0., 0., 0.,
+  0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
+  0., 0., 0., 0., 0., 0., 0., .93132257461547851562e-9,
+  .28867244235852488244e-7, .43982811713864556957e-6, 0., 0., 0., 0., 0.,
+  0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
+  0., 0., 0., 0., 0., 0., 0., 0., .46566128730773925781e-9,
+  .14899342093408253335e-7, 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
+  0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
+  0., 0., .23283064365386962891e-9
 };
 
 /* Allocates a workspace for the given maximum number of intervals.
     Note that if the workspace gets filled, the intervals with the
     lowest error estimates are dropped. The maximum number of
     intervals is therefore not the maximum number of intervals
     that will be computed, but merely the size of the buffer.
     */
@@ -1471,17 +1481,17 @@ downdate (double *c, int n, int d, int *
     }
 
 }
 
 
 /* The actual integration routine.  */
 
 DEFUN (quadcc, args, nargout,
-"-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Function File} {@var{q} =} quadcc (@var{f}, @var{a}, @var{b})\n\
 @deftypefnx {Function File} {@var{q} =} quadcc (@var{f}, @var{a}, @var{b}, @var{tol})\n\
 @deftypefnx {Function File} {@var{q} =} quadcc (@var{f}, @var{a}, @var{b}, @var{tol}, @var{sing})\n\
 @deftypefnx {Function File} {[@var{q}, @var{err}, @var{nr_points}] =} quadcc (@dots{})\n\
 Numerically evaluate the integral of @var{f} from @var{a} to @var{b}\n\
 using the doubly-adaptive Clenshaw-Curtis quadrature described by P. Gonnet\n\
 in @cite{Increasing the Reliability of Adaptive Quadrature Using Explicit\n\
 Interpolants}.\n\
@@ -1580,22 +1590,22 @@ Mathematical Software, Vol. 37, Issue 3,
       print_usage ();
       return retval;
     }
 
   if (args(0).is_function_handle () || args(0).is_inline_function ())
     fcn = args(0).function_value ();
   else
     {
-       std::string fcn_name = unique_symbol_name ("__quadcc_fcn__");
-       std::string fname = "function y = ";
-       fname.append (fcn_name);
-       fname.append ("(x) y = ");
-       fcn = extract_function (args(0), "quadcc", fcn_name, fname,
-                               "; endfunction");
+      std::string fcn_name = unique_symbol_name ("__quadcc_fcn__");
+      std::string fname = "function y = ";
+      fname.append (fcn_name);
+      fname.append ("(x) y = ");
+      fcn = extract_function (args(0), "quadcc", fcn_name, fname,
+                              "; endfunction");
     }
 
   if (! args(1).is_real_scalar ())
     {
       error ("quadcc: lower limit of integration (A) must be a single real scalar");
       return retval;
     }
   else
@@ -1783,19 +1793,18 @@ Mathematical Software, Vol. 37, Issue 3,
       OCTAVE_QUIT;
 
       /* Put our finger on the interval with the largest error. */
       iv = &(ivals[heap[0]]);
       m = (iv->a + iv->b) / 2;
       h = (iv->b - iv->a) / 2;
 
 #if (DEBUG_QUADCC)
-      printf
-        ("quadcc: processing ival %i (of %i) with [%e,%e] int=%e, err=%e, depth=%i\n",
-         heap[0], nivals, iv->a, iv->b, iv->igral, iv->err, iv->depth);
+      printf ("quadcc: processing ival %i (of %i) with [%e,%e] int=%e, err=%e, depth=%i\n",
+              heap[0], nivals, iv->a, iv->b, iv->igral, iv->err, iv->depth);
 #endif
 
       /* Should we try to increase the degree? */
       if (iv->depth < 3)
         {
 
           /* Keep tabs on some variables. */
           d = ++iv->depth;
@@ -1886,24 +1895,23 @@ Mathematical Software, Vol. 37, Issue 3,
         {
           split = 1;
         }
 
 
       /* Should we drop this interval? */
       if ((m + h * xi[0]) >= (m + h * xi[1])
           || (m + h * xi[31]) >= (m + h * xi[32])
-          || iv->err < fabs (iv->igral) * std::numeric_limits<double>::epsilon () * 10)
+          || iv->err < fabs (iv->igral)
+                       * std::numeric_limits<double>::epsilon () * 10)
         {
 
 #if (DEBUG_QUADCC)
-          printf
-            ("quadcc: dropping ival %i (of %i) with [%e,%e] int=%e, err=%e, depth=%i\n",
-             heap[0], nivals, iv->a, iv->b, iv->igral, iv->err,
-             iv->depth);
+          printf ("quadcc: dropping ival %i (of %i) with [%e,%e] int=%e, err=%e, depth=%i\n",
+                  heap[0], nivals, iv->a, iv->b, iv->igral, iv->err, iv->depth);
 #endif
 
           /* Keep this interval's contribution */
           err_final += iv->err;
           igral_final += iv->igral;
           /* Swap with the last element on the heap */
           t = heap[nivals - 1];
           heap[nivals - 1] = heap[0];
@@ -2202,20 +2210,18 @@ Mathematical Software, Vol. 37, Issue 3,
 
         }
 
       /* If the heap is about to overflow, remove the last two intervals. */
       while (nivals > cquad_heapsize - 2)
         {
           iv = &(ivals[heap[nivals - 1]]);
 #if (DEBUG_QUADCC)
-          printf
-            ("quadcc: dropping ival %i (of %i) with [%e,%e] int=%e, err=%e, depth=%i\n",
-             heap[0], nivals, iv->a, iv->b, iv->igral, iv->err,
-             iv->depth);
+          printf ("quadcc: dropping ival %i (of %i) with [%e,%e] int=%e, err=%e, depth=%i\n",
+                  heap[0], nivals, iv->a, iv->b, iv->igral, iv->err, iv->depth);
 #endif
           err_final += iv->err;
           igral_final += iv->igral;
           nivals--;
         }
 
       /* Collect the value of the integral and error. */
       igral = igral_final;
@@ -2228,20 +2234,19 @@ Mathematical Software, Vol. 37, Issue 3,
 
     }
 
   /* Dump the contents of the heap. */
 #if (DEBUG_QUADCC)
   for (i = 0; i < nivals; i++)
     {
       iv = &(ivals[heap[i]]);
-      printf
-        ("quadcc: ival %i (%i) with [%e,%e], int=%e, err=%e, depth=%i, rdepth=%i, ndiv=%i\n",
-         i, heap[i], iv->a, iv->b, iv->igral, iv->err, iv->depth,
-         iv->rdepth, iv->ndiv);
+      printf ("quadcc: ival %i (%i) with [%e,%e], int=%e, err=%e, depth=%i, rdepth=%i, ndiv=%i\n",
+              i, heap[i], iv->a, iv->b, iv->igral, iv->err, iv->depth,
+              iv->rdepth, iv->ndiv);
     }
 #endif
 
   /* Clean up and present the results. */
   if (nargout > 2)
     retval(2) = neval;
   if (nargout > 1)
     retval(1) = err;
@@ -2259,26 +2264,26 @@ Mathematical Software, Vol. 37, Issue 3,
 %!assert (quadcc (@sin, -pi, 0), -2, 1e-6)
 %!assert (quadcc (@sin, 0, pi), 2, 1e-6)
 %!assert (quadcc (@(x) 1./sqrt (x), 0, 1), 2, 1e-6)
 %!assert (quadcc (@(x) 1./(sqrt (x).*(x+1)), 0, Inf), pi, 1e-6)
 
 %!assert (quadcc (@(x) exp (-x .^ 2), -Inf, Inf), sqrt (pi), 1e-6)
 %!assert (quadcc (@(x) exp (-x .^ 2), -Inf, 0), sqrt (pi)/2, 1e-6)
 
-## Test function with NaNs in interval 
+## Test function with NaNs in interval
 %!function y = __nansin (x)
 %!  nan_locs = [-3*pi/4, -pi/4, 0, pi/3, pi/2, pi];
 %!  y = sin (x);
-%!  idx = min (abs (bsxfun (@minus, x(:), nan_locs)), [], 2); 
+%!  idx = min (abs (bsxfun (@minus, x(:), nan_locs)), [], 2);
 %!  y(idx < 1e-10) = NaN;
-%!endfunction 
+%!endfunction
 
 %!test
-%! [q, err, npoints] = quadcc ("__nansin", -pi, pi); 
+%! [q, err, npoints] = quadcc ("__nansin", -pi, pi);
 %! assert (q, 0, 1e-6);
 %! assert (err, 0, 15*eps);
 
 %% Test input validation
 %!error (quadcc ())
 %!error (quadcc (@sin))
 %!error (quadcc (@sin, 0))
 %!error (quadcc (@sin, ones (2), pi))
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -53,19 +53,20 @@ along with Octave; see the file COPYING.
 #include "pager.h"
 #if defined (DEBUG) || defined (DEBUG_SORT)
 #include "pr-output.h"
 #endif
 #include "symtab.h"
 #include "utils.h"
 #include "variables.h"
 
-typedef octave_idx_type (*sort_function) (const octave_idx_type& LSIZE, const double& ALPHA,
-                              const double& BETA, const double& S,
-                              const double& P);
+typedef octave_idx_type (*sort_function) (const octave_idx_type& LSIZE,
+                                          const double& ALPHA,
+                                          const double& BETA, const double& S,
+                                          const double& P);
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (dggbal, DGGBAL) (F77_CONST_CHAR_ARG_DECL,
                              const octave_idx_type& N, double* A,
                              const octave_idx_type& LDA, double* B,
                              const octave_idx_type& LDB, octave_idx_type& ILO,
@@ -286,17 +287,17 @@ fout (const octave_idx_type& lsize, cons
   else
     return (fabs (p) >= 1 ? 1 : -1);
 }
 
 
 //FIXME: Matlab does not produce lambda as the first output argument.
 //       Compatibility problem?
 DEFUN (qz, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{lambda} =} qz (@var{A}, @var{B})\n\
 @deftypefnx {Built-in Function} {@var{lambda} =} qz (@var{A}, @var{B}, @var{opt})\n\
 QZ@tie{}decomposition of the generalized eigenvalue problem\n\
 (@math{A x = s B x}).  There are three ways to call this function:\n\
 @enumerate\n\
 @item @code{@var{lambda} = qz (@var{A}, @var{B})}\n\
 \n\
 Computes the generalized eigenvalues\n\
@@ -371,17 +372,18 @@ Note: @code{qz} performs permutation bal
 compatibility with @sc{matlab}.\n\
 @seealso{eig, balance, lu, chol, hess, qr, qzhess, schur, svd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
 
 #ifdef DEBUG
-  std::cout << "qz: nargin = " << nargin << ", nargout = " << nargout << std::endl;
+  std::cout << "qz: nargin = " << nargin
+            << ", nargout = " << nargout << std::endl;
 #endif
 
   if (nargin < 2 || nargin > 3 || nargout > 7)
     {
       print_usage ();
       return retval;
     }
   else if (nargin == 3 && (nargout < 3 || nargout > 4))
@@ -422,49 +424,52 @@ compatibility with @sc{matlab}.\n\
         }
 
       // overflow constant required by dlag2
       F77_FUNC (xdlamch, XDLAMCH) (F77_CONST_CHAR_ARG2 ("S", 1),
                                    safmin
                                    F77_CHAR_ARG_LEN (1));
 
 #ifdef DEBUG_EIG
-      std::cout << "qz: initial value of safmin=" << setiosflags (std::ios::scientific)
-           << safmin << std::endl;
+      std::cout << "qz: initial value of safmin="
+                << setiosflags (std::ios::scientific)
+                << safmin << std::endl;
 #endif
 
       // Some machines (e.g., DEC alpha) get safmin = 0;
       // for these, use eps instead to avoid problems in dlag2.
       if (safmin == 0)
         {
 #ifdef DEBUG_EIG
           std::cout << "qz: DANGER WILL ROBINSON: safmin is 0!" << std::endl;
 #endif
 
           F77_FUNC (xdlamch, XDLAMCH) (F77_CONST_CHAR_ARG2 ("E", 1),
                                        safmin
                                        F77_CHAR_ARG_LEN (1));
 
 #ifdef DEBUG_EIG
-          std::cout << "qz: safmin set to " << setiosflags (std::ios::scientific)
-               << safmin << std::endl;
+          std::cout << "qz: safmin set to "
+                    << setiosflags (std::ios::scientific)
+                    << safmin << std::endl;
 #endif
         }
     }
 
 #ifdef DEBUG
   std::cout << "qz: check argument 1" << std::endl;
 #endif
 
   // Argument 1: check if it's o.k. dimensioned.
   octave_idx_type nn = args(0).rows ();
 
 #ifdef DEBUG
-  std::cout << "argument 1 dimensions: (" << nn << "," << args(0).columns () << ")"
-       << std::endl;
+  std::cout << "argument 1 dimensions: ("
+            << nn << "," << args(0).columns () << ")"
+            << std::endl;
 #endif
 
   int arg_is_empty = empty_arg ("qz", nn, args(0).columns ());
 
   if (arg_is_empty < 0)
     {
       gripe_empty_arg ("qz: parameter 1", 0);
       return retval;
@@ -548,17 +553,18 @@ compatibility with @sc{matlab}.\n\
   // Always perform permutation balancing.
   const char bal_job = 'P';
   RowVector lscale (nn), rscale (nn), work (6 * nn), rwork (nn);
 
   if (complex_case)
     {
 #ifdef DEBUG
       if (compq == 'V')
-        std::cout << "qz: performing balancing; CQ=" << std::endl << CQ << std::endl;
+        std::cout << "qz: performing balancing; CQ=" << std::endl
+                  << CQ << std::endl;
 #endif
       if (args(0).is_real_type ())
         caa = ComplexMatrix (aa);
 
       if (args(1).is_real_type ())
         cbb = ComplexMatrix (bb);
 
       if (compq == 'V')
@@ -573,17 +579,18 @@ compatibility with @sc{matlab}.\n\
                  nn, ilo, ihi, lscale.fortran_vec (),
                  rscale.fortran_vec (), work.fortran_vec (), info
                  F77_CHAR_ARG_LEN (1)));
     }
   else
     {
 #ifdef DEBUG
       if (compq == 'V')
-        std::cout << "qz: performing balancing; QQ=" << std::endl << QQ << std::endl;
+        std::cout << "qz: performing balancing; QQ=" << std::endl
+                  << QQ << std::endl;
 #endif
 
       F77_XFCN (dggbal, DGGBAL,
                 (F77_CONST_CHAR_ARG2 (&bal_job, 1),
                  nn, aa.fortran_vec (), nn, bb.fortran_vec (),
                  nn, ilo, ihi, lscale.fortran_vec (),
                  rscale.fortran_vec (), work.fortran_vec (), info
                  F77_CHAR_ARG_LEN (1)));
@@ -698,17 +705,18 @@ compatibility with @sc{matlab}.\n\
 #ifdef DEBUG
       std::cout << "qz: peforming qr decomposition of bb" << std::endl;
 #endif
 
       // Compute the QR factorization of bb.
       QR bqr (bb);
 
 #ifdef DEBUG
-      std::cout << "qz: qr (bb) done; now peforming qz decomposition" << std::endl;
+      std::cout << "qz: qr (bb) done; now peforming qz decomposition"
+                << std::endl;
 #endif
 
       bb = bqr.R ();
 
 #ifdef DEBUG
       std::cout << "qz: extracted bb" << std::endl;
 #endif
 
@@ -725,17 +733,18 @@ compatibility with @sc{matlab}.\n\
       if (compq == 'V')
         QQ = QQ * bqr.Q ();
 
 #ifdef DEBUG
       std::cout << "qz: precursors done..." << std::endl;
 #endif
 
 #ifdef DEBUG
-      std::cout << "qz: compq = " << compq << ", compz = " << compz << std::endl;
+      std::cout << "qz: compq = " << compq << ", compz = " << compz
+                << std::endl;
 #endif
 
       // Reduce  to generalized hessenberg form.
       F77_XFCN (dgghrd, DGGHRD,
                 (F77_CONST_CHAR_ARG2 (&compq, 1),
                  F77_CONST_CHAR_ARG2 (&compz, 1),
                  nn, ilo, ihi, aa.fortran_vec (),
                  nn, bb.fortran_vec (), nn, QQ.fortran_vec (), nn,
@@ -766,34 +775,36 @@ compatibility with @sc{matlab}.\n\
                      F77_CONST_CHAR_ARG2 ("L", 1),
                      nn, ilo, ihi, lscale.data (), rscale.data (),
                      nn, QQ.fortran_vec (), nn, info
                      F77_CHAR_ARG_LEN (1)
                      F77_CHAR_ARG_LEN (1)));
 
 #ifdef DEBUG
           if (compq == 'V')
-            std::cout << "qz: balancing done; QQ=" << std::endl << QQ << std::endl;
+            std::cout << "qz: balancing done; QQ=" << std::endl
+                      << QQ << std::endl;
 #endif
         }
 
-  // then right
+      // then right
       if (compz == 'V')
         {
-           F77_XFCN (dggbak, DGGBAK,
-                     (F77_CONST_CHAR_ARG2 (&bal_job, 1),
-                      F77_CONST_CHAR_ARG2 ("R", 1),
-                      nn, ilo, ihi, lscale.data (), rscale.data (),
-                      nn, ZZ.fortran_vec (), nn, info
-                      F77_CHAR_ARG_LEN (1)
-                      F77_CHAR_ARG_LEN (1)));
+          F77_XFCN (dggbak, DGGBAK,
+                    (F77_CONST_CHAR_ARG2 (&bal_job, 1),
+                     F77_CONST_CHAR_ARG2 ("R", 1),
+                     nn, ilo, ihi, lscale.data (), rscale.data (),
+                     nn, ZZ.fortran_vec (), nn, info
+                     F77_CHAR_ARG_LEN (1)
+                     F77_CHAR_ARG_LEN (1)));
 
 #ifdef DEBUG
-           if (compz == 'V')
-             std::cout << "qz: balancing done; ZZ=" << std::endl << ZZ << std::endl;
+          if (compz == 'V')
+            std::cout << "qz: balancing done; ZZ=" << std::endl
+                      << ZZ << std::endl;
 #endif
         }
 
     }
 
   // Order the QZ decomposition?
   if (! (ord_job == 'N' || ord_job == 'n'))
     {
@@ -910,60 +921,63 @@ compatibility with @sc{matlab}.\n\
                 zcnt = 1;
               else zcnt = 2;
 
               if (zcnt == 1)
                 {
                   // Real zero.
 #ifdef DEBUG_EIG
                   std::cout << "  single gen eig:" << std::endl;
-                  std::cout << "  alphar(" << jj << ") = " << aa(jj,jj) << std::endl;
-                  std::cout << "  betar( " << jj << ") = " << bb(jj,jj) << std::endl;
+                  std::cout << "  alphar(" << jj << ") = " << aa(jj,jj)
+                            << std::endl;
+                  std::cout << "  betar( " << jj << ") = " << bb(jj,jj)
+                            << std::endl;
                   std::cout << "  alphai(" << jj << ") = 0" << std::endl;
 #endif
 
                   alphar(jj) = aa(jj,jj);
                   alphai(jj) = 0;
                   betar(jj) = bb(jj,jj);
                 }
               else
                 {
                   // Complex conjugate pair.
 #ifdef DEBUG_EIG
                   std::cout << "qz: calling dlag2:" << std::endl;
                   std::cout << "safmin="
-                       << setiosflags (std::ios::scientific) << safmin << std::endl;
+                            << setiosflags (std::ios::scientific)
+                            << safmin << std::endl;
 
                   for (int idr = jj; idr <= jj+1; idr++)
                     {
                       for (int idc = jj; idc <= jj+1; idc++)
                         {
                           std::cout << "aa(" << idr << "," << idc << ")="
-                               << aa(idr,idc) << std::endl;
+                                    << aa(idr,idc) << std::endl;
                           std::cout << "bb(" << idr << "," << idc << ")="
-                               << bb(idr,idc) << std::endl;
+                                    << bb(idr,idc) << std::endl;
                         }
                     }
 #endif
 
-                  // FIXME -- probably should be using
+                  // FIXME: probably should be using
                   // fortran_vec instead of &aa(jj,jj) here.
 
                   double scale1, scale2, wr1, wr2, wi;
                   const double *aa_ptr = aa.data () + jj * nn + jj;
                   const double *bb_ptr = bb.data () + jj * nn + jj;
                   F77_XFCN (dlag2, DLAG2,
                             (aa_ptr, nn, bb_ptr, nn, safmin,
                              scale1, scale2, wr1, wr2, wi));
 
 #ifdef DEBUG_EIG
                   std::cout << "dlag2 returns: scale1=" << scale1
-                       << "\tscale2=" << scale2 << std::endl
-                       << "\twr1=" << wr1 << "\twr2=" << wr2
-                       << "\twi=" << wi << std::endl;
+                            << "\tscale2=" << scale2 << std::endl
+                            << "\twr1=" << wr1 << "\twr2=" << wr2
+                            << "\twi=" << wi << std::endl;
 #endif
 
                   // Just to be safe, check if it's a real pair.
                   if (wi == 0)
                     {
                       alphar(jj) = wr1;
                       alphai(jj) = 0;
                       betar(jj) = scale1;
@@ -990,17 +1004,17 @@ compatibility with @sc{matlab}.\n\
           octave_print_internal (std::cout, bb, 0);
 
           if (compz == 'V')
             {
               std::cout << std::endl << "ZZ="  << std::endl;
               octave_print_internal (std::cout, ZZ, 0);
             }
           std::cout << std::endl << "qz: ndim=" << ndim << std::endl
-               << "fail=" << fail << std::endl;
+                    << "fail=" << fail << std::endl;
           std::cout << "alphar = " << std::endl;
           octave_print_internal (std::cout, (Matrix) alphar, 0);
           std::cout << std::endl << "alphai = " << std::endl;
           octave_print_internal (std::cout, (Matrix) alphai, 0);
           std::cout << std::endl << "beta = " << std::endl;
           octave_print_internal (std::cout, (Matrix) betar, 0);
           std::cout << std::endl;
 #endif
@@ -1205,28 +1219,28 @@ compatibility with @sc{matlab}.\n\
             octave_print_internal (std::cout, cbb, 0);
             std::cout << std::endl << "qz: retval(0) = caa = " <<std::endl;
             octave_print_internal (std::cout, caa, 0);
             std::cout << std::endl;
 #endif
             retval(1) = cbb;
             retval(0) = caa;
           }
-      else
-        {
+        else
+          {
 #ifdef DEBUG
-          std::cout << "qz: retval(1) = bb = " << std::endl;
-          octave_print_internal (std::cout, bb, 0);
-          std::cout << std::endl << "qz: retval(0) = aa = " <<std::endl;
-          octave_print_internal (std::cout, aa, 0);
-          std::cout << std::endl;
+            std::cout << "qz: retval(1) = bb = " << std::endl;
+            octave_print_internal (std::cout, bb, 0);
+            std::cout << std::endl << "qz: retval(0) = aa = " <<std::endl;
+            octave_print_internal (std::cout, aa, 0);
+            std::cout << std::endl;
 #endif
-          retval(1) = bb;
-          retval(0) = aa;
-        }
+            retval(1) = bb;
+            retval(0) = aa;
+          }
       }
       break;
 
 
     case 1:
     case 0:
 #ifdef DEBUG
       std::cout << "qz: retval(0) = gev = " << gev << std::endl;
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -300,21 +300,21 @@ do_rand (const octave_value_list& args, 
               }
 
             goto gen_matrix;
           }
       }
       break;
     }
 
- done:
+done:
 
   return retval;
 
- gen_matrix:
+gen_matrix:
 
   dims.chop_trailing_singletons ();
 
   if (is_single)
     {
       if (additional_arg)
         {
           if (a.length () == 1)
@@ -359,17 +359,17 @@ do_rand (const octave_value_list& args, 
             }
         }
       else
         return octave_rand::nd_array (dims);
     }
 }
 
 DEFUN (rand, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} rand (@var{n})\n\
 @deftypefnx {Built-in Function} {} rand (@var{n}, @var{m}, @dots{})\n\
 @deftypefnx {Built-in Function} {} rand ([@var{n} @var{m} @dots{}])\n\
 @deftypefnx {Built-in Function} {@var{v} =} rand (\"state\")\n\
 @deftypefnx {Built-in Function} {} rand (\"state\", @var{v})\n\
 @deftypefnx {Built-in Function} {} rand (\"state\", \"reset\")\n\
 @deftypefnx {Built-in Function} {@var{v} =} rand (\"seed\")\n\
 @deftypefnx {Built-in Function} {} rand (\"seed\", @var{v})\n\
@@ -458,17 +458,17 @@ classes.\n\
 
   int nargin = args.length ();
 
   retval = do_rand (args, nargin, "rand", "uniform");
 
   return retval;
 }
 
-// FIXME -- The old generator (selected when "seed" is set) will not
+// FIXME: The old generator (selected when "seed" is set) will not
 // work properly if compiled to use 64-bit integers.
 
 /*
 %!test  # "state" can be a scalar
 %! rand ("state", 12);  x = rand (1,4);
 %! rand ("state", 12);  y = rand (1,4);
 %! assert (x, y);
 %!test  # "state" can be a vector
@@ -546,17 +546,17 @@ classes.\n\
 %!assert (__rand_sample__ (-2), __rand_sample__ (2^32-2))
 %!assert (__rand_sample__ (Inf), __rand_sample__ (NaN))
 %!assert (! isequal (__rand_sample__ (-1), __rand_sample__ (-2)))
 */
 
 static std::string current_distribution = octave_rand::distribution ();
 
 DEFUN (randn, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} randn (@var{n})\n\
 @deftypefnx {Built-in Function} {} randn (@var{n}, @var{m}, @dots{})\n\
 @deftypefnx {Built-in Function} {} randn ([@var{n} @var{m} @dots{}])\n\
 @deftypefnx {Built-in Function} {@var{v} =} randn (\"state\")\n\
 @deftypefnx {Built-in Function} {} randn (\"state\", @var{v})\n\
 @deftypefnx {Built-in Function} {} randn (\"state\", \"reset\")\n\
 @deftypefnx {Built-in Function} {@var{v} =} randn (\"seed\")\n\
 @deftypefnx {Built-in Function} {} randn (\"seed\", @var{v})\n\
@@ -618,17 +618,17 @@ J. Statistical Software, vol 5, 2000,\n\
 %!   assert (mean (x), 0, 0.01);
 %!   assert (var (x), 1, 0.02);
 %!   assert (skewness (x), 0, 0.02);
 %!   assert (kurtosis (x), 0, 0.04);
 %! endif
 */
 
 DEFUN (rande, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} rande (@var{n})\n\
 @deftypefnx {Built-in Function} {} rande (@var{n}, @var{m}, @dots{})\n\
 @deftypefnx {Built-in Function} {} rande ([@var{n} @var{m} @dots{}])\n\
 @deftypefnx {Built-in Function} {@var{v} =} rande (\"state\")\n\
 @deftypefnx {Built-in Function} {} rande (\"state\", @var{v})\n\
 @deftypefnx {Built-in Function} {} rande (\"state\", \"reset\")\n\
 @deftypefnx {Built-in Function} {@var{v} =} rande (\"seed\")\n\
 @deftypefnx {Built-in Function} {} rande (\"seed\", @var{v})\n\
@@ -691,17 +691,17 @@ J. Statistical Software, vol 5, 2000,\n\
 %!   assert (mean (x), 1, 0.01);
 %!   assert (var (x), 1, 0.03);
 %!   assert (skewness (x), 2, 0.06);
 %!   assert (kurtosis (x), 6, 0.7);
 %! endif
 */
 
 DEFUN (randg, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} randg (@var{n})\n\
 @deftypefnx {Built-in Function} {} randg (@var{n}, @var{m}, @dots{})\n\
 @deftypefnx {Built-in Function} {} randg ([@var{n} @var{m} @dots{}])\n\
 @deftypefnx {Built-in Function} {@var{v} =} randg (\"state\")\n\
 @deftypefnx {Built-in Function} {} randg (\"state\", @var{v})\n\
 @deftypefnx {Built-in Function} {} randg (\"state\", \"reset\")\n\
 @deftypefnx {Built-in Function} {@var{v} =} randg (\"seed\")\n\
 @deftypefnx {Built-in Function} {} randg (\"seed\", @var{v})\n\
@@ -963,17 +963,17 @@ classes.\n\
 %!   assert (mean (x),     a,          0.2);
 %!   assert (var (x),      a,          2);
 %!   assert (skewness (x), 2/sqrt (a), 0.05);
 %!   assert (kurtosis (x), 6/a,        0.2);
 %! endif
 */
 
 DEFUN (randp, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} randp (@var{l}, @var{n})\n\
 @deftypefnx {Built-in Function} {} randp (@var{l}, @var{n}, @var{m}, @dots{})\n\
 @deftypefnx {Built-in Function} {} randp (@var{l}, [@var{n} @var{m} @dots{}])\n\
 @deftypefnx {Built-in Function} {@var{v} =} randp (\"state\")\n\
 @deftypefnx {Built-in Function} {} randp (\"state\", @var{v})\n\
 @deftypefnx {Built-in Function} {} randp (\"state\", \"reset\")\n\
 @deftypefnx {Built-in Function} {@var{v} =} randp (\"seed\")\n\
 @deftypefnx {Built-in Function} {} randp (\"seed\", @var{v})\n\
@@ -1111,17 +1111,17 @@ classes.\n\
 %!     assert (var (x), a(1), 0.02*a(1));
 %!     assert (skewness (x), 1/sqrt (a(1)), a(3));
 %!     assert (kurtosis (x), 1/a(1), 3*a(3));
 %!   endfor
 %! endif
 */
 
 DEFUN (randperm, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} randperm (@var{n})\n\
 @deftypefnx {Built-in Function} {} randperm (@var{n}, @var{m})\n\
 Return a row vector containing a random permutation of @code{1:@var{n}}.\n\
 If @var{m} is supplied, return @var{m} unique entries, sampled without\n\
 replacement from @code{1:@var{n}}.  The complexity is O(@var{n}) in\n\
 memory and O(@var{m}) in time, unless @var{m} < @var{n}/5, in which case\n\
 O(@var{m}) memory is used as well.  The randomization is performed using\n\
 rand().  All permutations are equally likely.\n\
@@ -1166,17 +1166,17 @@ using std::unordered_map;
           double *rvec = r.fortran_vec ();
 
           octave_idx_type idx_len = short_shuffle ? m : n;
           Array<octave_idx_type> idx;
           try
             {
               idx = Array<octave_idx_type> (dim_vector (1, idx_len));
             }
-          catch(std::bad_alloc)
+          catch (std::bad_alloc)
             {
               // Looks like n is too big and short_shuffle is false.
               // Let's try again, but this time with the alternative.
               idx_len = m;
               short_shuffle = true;
               idx = Array<octave_idx_type> (dim_vector (1, idx_len));
             }
 
@@ -1189,17 +1189,17 @@ using std::unordered_map;
             {
               unordered_map<octave_idx_type, octave_idx_type> map (m);
 
               // Perform the Knuth shuffle only keeping track of moved
               // entries in the map
               for (octave_idx_type i = 0; i < m; i++)
                 {
                   octave_idx_type k = i +
-                    gnulib::floor (rvec[i] * (n - i));
+                                      gnulib::floor (rvec[i] * (n - i));
 
                   //For shuffling first m entries, no need to use extra
                   //storage
                   if (k < m)
                     {
                       std::swap (ivec[i], ivec[k]);
                     }
                   else
@@ -1213,17 +1213,17 @@ using std::unordered_map;
             }
           else
             {
 
               // Perform the Knuth shuffle of the first m entries
               for (octave_idx_type i = 0; i < m; i++)
                 {
                   octave_idx_type k = i +
-                    gnulib::floor (rvec[i] * (n - i));
+                                      gnulib::floor (rvec[i] * (n - i));
                   std::swap (ivec[i], ivec[k]);
                 }
             }
 
           // Convert to doubles, reusing r.
           for (octave_idx_type i = 0; i < m; i++)
             rvec[i] = ivec[i] + 1;
 
diff --git a/libinterp/corefcn/rcond.cc b/libinterp/corefcn/rcond.cc
--- a/libinterp/corefcn/rcond.cc
+++ b/libinterp/corefcn/rcond.cc
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN (rcond, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{c} =} rcond (@var{A})\n\
 Compute the 1-norm estimate of the reciprocal condition number as returned\n\
 by @sc{lapack}.  If the matrix is well-conditioned then @var{c} will be near\n\
 1 and if the matrix is poorly conditioned it will be close to zero.\n\
 \n\
 The matrix @var{A} must not be sparse.  If the matrix is sparse then\n\
 @code{condest (@var{A})} or @code{rcond (full (@var{A}))} should be used\n\
 instead.\n\
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -146,24 +146,24 @@ do_regexp_rep_string_escapes (const std:
               retval[i] = '\t';
               break;
 
             case 'v': // vertical tab
               retval[i] = '\v';
               break;
 
 #if 0
-// FIXME -- to be complete, we need to handle \oN, \o{N}, \xN, and
+// FIXME: to be complete, we need to handle \oN, \o{N}, \xN, and
 // \x{N}.  Hex digits may be upper or lower case.  Brackets are
 // optional, so \x5Bz is the same as \x{5B}z.
 
             case 'o': // octal number
             case 'x': // hex number
 #endif
- 
+
             default:  // pass escape sequence through
               retval[i] = '\\';
               retval[++i] = s[j];
               break;
             }
         }
       else
         {
@@ -580,17 +580,17 @@ octcellregexp (const octave_value_list &
   else
     retval = octregexp (args, nargout, who, case_insensitive);
 
   return retval;
 
 }
 
 DEFUN (regexp, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{s}, @var{e}, @var{te}, @var{m}, @var{t}, @var{nm}, @var{sp}] =} regexp (@var{str}, @var{pat})\n\
 @deftypefnx {Built-in Function} {[@dots{}] =} regexp (@var{str}, @var{pat}, \"@var{opt1}\", @dots{})\n\
 Regular expression string matching.  Search for @var{pat} in @var{str} and\n\
 return the positions and substrings of any matches, or empty values if there\n\
 are none.\n\
 \n\
 The matched pattern @var{pat} can include any of the standard regex\n\
 operators, including:\n\
@@ -1061,17 +1061,17 @@ are zero or more @qcode{'b'} characters 
 %! assert (a, {"oo"});
 %! assert (b, {"f", " bar"});
 
 %!assert (regexp ("\n", '\n'), 1);
 %!assert (regexp ("\n", "\n"), 1);
 */
 
 DEFUN (regexpi, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{s}, @var{e}, @var{te}, @var{m}, @var{t}, @var{nm}, @var{sp}] =} regexpi (@var{str}, @var{pat})\n\
 @deftypefnx {Built-in Function} {[@dots{}] =} regexpi (@var{str}, @var{pat}, \"@var{opt1}\", @dots{})\n\
 \n\
 Case insensitive regular expression string matching.  Search for @var{pat} in\n\
 @var{str} and return the positions and substrings of any matches, or empty\n\
 values if there are none.  @xref{XREFregexp,,regexp}, for details on the\n\
 syntax of the search pattern.\n\
 @seealso{regexp}\n\
@@ -1273,17 +1273,17 @@ octregexprep (const octave_value_list &a
   parse_options (options, regexpargs, who, 0, extra_args);
   if (error_state)
     return retval;
 
   return regexp_replace (pattern, buffer, replacement, options, who);
 }
 
 DEFUN (regexprep, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{outstr} =} regexprep (@var{string}, @var{pat}, @var{repstr})\n\
 @deftypefnx {Built-in Function} {@var{outstr} =} regexprep (@var{string}, @var{pat}, @var{repstr}, \"@var{opt1}\", @dots{})\n\
 Replace occurrences of pattern @var{pat} in @var{string} with @var{repstr}.\n\
 \n\
 The pattern is a regular expression as documented for @code{regexp}.\n\
 @xref{XREFregexp,,regexp}.\n\
 \n\
 The replacement string may contain @code{$i}, which substitutes\n\
@@ -1385,18 +1385,18 @@ quotes.  Use a second backslash to stop 
 
               if (error_state)
                 break;
 
               ret(i) = new_args(0);
             }
 
           if (!error_state)
-            retval = args(0).is_cell ()
-              ? octave_value (ret) : octave_value (ret(0));
+            retval = args(0).is_cell () ? octave_value (ret)
+                                        : octave_value (ret(0));
         }
     }
   else
     retval = octregexprep (args, "regexprep");
 
   return retval;
 }
 
diff --git a/libinterp/corefcn/schur.cc b/libinterp/corefcn/schur.cc
--- a/libinterp/corefcn/schur.cc
+++ b/libinterp/corefcn/schur.cc
@@ -53,17 +53,17 @@ mark_upper_triangular (const Matrix& a)
       return retval;
 
   retval.matrix_type (MatrixType::Upper);
 
   return retval;
 }
 
 DEFUN (schur, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{S} =} schur (@var{A})\n\
 @deftypefnx {Built-in Function} {@var{S} =} schur (@var{A}, \"real\")\n\
 @deftypefnx {Built-in Function} {@var{S} =} schur (@var{A}, \"complex\")\n\
 @deftypefnx {Built-in Function} {@var{S} =} schur (@var{A}, @var{opt})\n\
 @deftypefnx {Built-in Function} {[@var{U}, @var{S}] =} schur (@var{A}, @dots{})\n\
 @cindex Schur decomposition\n\
 Compute the Schur@tie{}decomposition of @var{A}\n\
 @tex\n\
@@ -289,17 +289,17 @@ Riccati equations in control (see @code{
 %!test
 %! fail ("schur ([1, 2; 3, 4], 2)", "warning");
 
 %!error schur ()
 %!error <argument must be a square matrix> schur ([1, 2, 3; 4, 5, 6])
 */
 
 DEFUN (rsf2csf, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Function File} {[@var{U}, @var{T}] =} rsf2csf (@var{UR}, @var{TR})\n\
 Convert a real, upper quasi-triangular Schur@tie{}form @var{TR} to a complex,\n\
 upper triangular Schur@tie{}form @var{T}.\n\
 \n\
 Note that the following relations hold:\n\
 \n\
 @tex\n\
 $UR \\cdot TR \\cdot {UR}^T = U T U^{\\dagger}$ and\n\
diff --git a/libinterp/corefcn/sighandlers.cc b/libinterp/corefcn/sighandlers.cc
--- a/libinterp/corefcn/sighandlers.cc
+++ b/libinterp/corefcn/sighandlers.cc
@@ -867,17 +867,17 @@ OCL_REP::wait (void)
             }
         }
     }
 
   return retval;
 }
 
 DEFUN (SIG, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} SIG ()\n\
 Return a structure containing Unix signal names and their defined values.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 0)
     {
@@ -894,17 +894,17 @@ Return a structure containing Unix signa
 /*
 %!assert (isstruct (SIG ()))
 %!assert (! isempty (SIG ()))
 
 %!error SIG (1)
 */
 
 DEFUN (debug_on_interrupt, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} debug_on_interrupt ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} debug_on_interrupt (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} debug_on_interrupt (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will try\n\
 to enter debugging mode when it receives an interrupt signal (typically\n\
 generated with @kbd{C-c}).  If a second interrupt signal is received\n\
 before reaching the debugging mode, a normal interrupt will occur.\n\
 \n\
@@ -925,17 +925,17 @@ The original variable value is restored 
 %! assert (debug_on_interrupt (), ! orig_val);
 %! debug_on_interrupt (orig_val);
 %! assert (debug_on_interrupt (), orig_val);
 
 %!error (debug_on_interrupt (1, 2))
 */
 
 DEFUN (sighup_dumps_octave_core, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} sighup_dumps_octave_core ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} sighup_dumps_octave_core (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} sighup_dumps_octave_core (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave tries\n\
 to save all current variables to the file @file{octave-workspace} if it\n\
 receives a hangup signal.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
@@ -954,17 +954,17 @@ The original variable value is restored 
 %! assert (sighup_dumps_octave_core (), ! orig_val);
 %! sighup_dumps_octave_core (orig_val);
 %! assert (sighup_dumps_octave_core (), orig_val);
 
 %!error (sighup_dumps_octave_core (1, 2))
 */
 
 DEFUN (sigterm_dumps_octave_core, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} sigterm_dumps_octave_core ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} sigterm_dumps_octave_core (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} sigterm_dumps_octave_core (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave tries\n\
 to save all current variables to the file @file{octave-workspace} if it\n\
 receives a terminate signal.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
diff --git a/libinterp/corefcn/sighandlers.h b/libinterp/corefcn/sighandlers.h
--- a/libinterp/corefcn/sighandlers.h
+++ b/libinterp/corefcn/sighandlers.h
@@ -40,17 +40,17 @@ Free Software Foundation, Inc.
 
 #include "syswait.h"
 #include "siglist.h"
 
 #include "base-list.h"
 
 typedef void sig_handler (int);
 
-// FIXME -- the data should probably be private...
+// FIXME: the data should probably be private...
 
 struct
 octave_interrupt_handler
 {
 #ifdef SIGINT
   sig_handler *int_handler;
 #endif
 
@@ -61,18 +61,19 @@ octave_interrupt_handler
 
 // Nonzero means we have already printed a message for this series of
 // SIGPIPES.  We assume that the writer will eventually give up.
 extern int pipe_handler_error_count;
 
 // TRUE means we can be interrupted.
 extern OCTINTERP_API bool can_interrupt;
 
-extern OCTINTERP_API sig_handler *octave_set_signal_handler (int, sig_handler *,
-                                               bool restart_syscalls = true);
+extern OCTINTERP_API
+sig_handler *octave_set_signal_handler (int, sig_handler *,
+                                        bool restart_syscalls = true);
 
 extern OCTINTERP_API void install_signal_handlers (void);
 
 extern OCTINTERP_API void octave_signal_handler (void);
 
 extern OCTINTERP_API octave_interrupt_handler octave_catch_interrupts (void);
 
 extern OCTINTERP_API octave_interrupt_handler octave_ignore_interrupts (void);
@@ -102,26 +103,26 @@ public:
   octave_child (pid_t id = -1, child_event_handler f = 0)
     : pid (id), handler (f), have_status (0), status (0) { }
 
   octave_child (const octave_child& oc)
     : pid (oc.pid), handler (oc.handler),
       have_status (oc.have_status), status (oc.status) { }
 
   octave_child& operator = (const octave_child& oc)
-    {
-      if (&oc != this)
-        {
-          pid = oc.pid;
-          handler = oc.handler;
-          have_status = oc.have_status;
-          status = oc.status;
-        }
-      return *this;
-    }
+  {
+    if (&oc != this)
+      {
+        pid = oc.pid;
+        handler = oc.handler;
+        have_status = oc.have_status;
+        status = oc.status;
+      }
+    return *this;
+  }
 
   ~octave_child (void) { }
 
   // The process id of this child.
   pid_t pid;
 
   // The function we call if an event happens for this child.
   child_event_handler handler;
diff --git a/libinterp/corefcn/sparse-xdiv.cc b/libinterp/corefcn/sparse-xdiv.cc
--- a/libinterp/corefcn/sparse-xdiv.cc
+++ b/libinterp/corefcn/sparse-xdiv.cc
@@ -267,17 +267,18 @@ xdiv (const SparseComplexMatrix& a, cons
     = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
 
   typ = btyp.transpose ();
   return result.hermitian ();
 }
 
 // -*- 8 -*-
 SparseComplexMatrix
-xdiv (const SparseComplexMatrix& a, const SparseComplexMatrix& b, MatrixType &typ)
+xdiv (const SparseComplexMatrix& a, const SparseComplexMatrix& b,
+      MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return SparseComplexMatrix ();
 
   SparseComplexMatrix atmp = a.hermitian ();
   SparseComplexMatrix btmp = b.hermitian ();
   MatrixType btyp = typ.transpose ();
 
@@ -622,12 +623,13 @@ xleftdiv (const DiagMatrix& d, const Spa
 SparseComplexMatrix
 xleftdiv (const ComplexDiagMatrix& d, const SparseMatrix& a,  MatrixType&)
 {
   return do_leftdiv_dm_sm<SparseComplexMatrix> (d, a);
 }
 
 // -*- 12 -*-
 SparseComplexMatrix
-xleftdiv (const ComplexDiagMatrix& d, const SparseComplexMatrix& a,  MatrixType&)
+xleftdiv (const ComplexDiagMatrix& d, const SparseComplexMatrix& a,
+          MatrixType&)
 {
   return do_leftdiv_dm_sm<SparseComplexMatrix> (d, a);
 }
diff --git a/libinterp/corefcn/sparse-xdiv.h b/libinterp/corefcn/sparse-xdiv.h
--- a/libinterp/corefcn/sparse-xdiv.h
+++ b/libinterp/corefcn/sparse-xdiv.h
@@ -71,23 +71,29 @@ extern ComplexMatrix xleftdiv (const Spa
 extern ComplexMatrix xleftdiv (const SparseComplexMatrix& a, const Matrix& b,
                                MatrixType &typ);
 extern ComplexMatrix xleftdiv (const SparseComplexMatrix& a,
                                const ComplexMatrix& b, MatrixType &typ);
 
 extern SparseMatrix xleftdiv (const SparseMatrix& a, const SparseMatrix& b,
                               MatrixType &typ);
 extern SparseComplexMatrix xleftdiv (const SparseMatrix& a,
-                                     const SparseComplexMatrix& b, MatrixType &typ);
+                                     const SparseComplexMatrix& b,
+                                     MatrixType &typ);
 extern SparseComplexMatrix xleftdiv (const SparseComplexMatrix& a,
                                      const SparseMatrix& b, MatrixType &typ);
 extern SparseComplexMatrix xleftdiv (const SparseComplexMatrix& a,
-                                     const SparseComplexMatrix& b, MatrixType &typ);
+                                     const SparseComplexMatrix& b,
+                                     MatrixType &typ);
 
-extern SparseMatrix xleftdiv (const DiagMatrix&, const SparseMatrix&, MatrixType&);
-extern SparseComplexMatrix xleftdiv (const ComplexDiagMatrix&, const SparseMatrix&,
+extern SparseMatrix xleftdiv (const DiagMatrix&, const SparseMatrix&,
+                              MatrixType&);
+extern SparseComplexMatrix xleftdiv (const ComplexDiagMatrix&,
+                                     const SparseMatrix&,
                                      MatrixType&);
-extern SparseComplexMatrix xleftdiv (const DiagMatrix&, const SparseComplexMatrix&,
+extern SparseComplexMatrix xleftdiv (const DiagMatrix&,
+                                     const SparseComplexMatrix&,
                                      MatrixType&);
-extern SparseComplexMatrix xleftdiv (const ComplexDiagMatrix&, const SparseComplexMatrix&,
+extern SparseComplexMatrix xleftdiv (const ComplexDiagMatrix&,
+                                     const SparseComplexMatrix&,
                                      MatrixType&);
 
 #endif
diff --git a/libinterp/corefcn/sparse-xpow.cc b/libinterp/corefcn/sparse-xpow.cc
--- a/libinterp/corefcn/sparse-xpow.cc
+++ b/libinterp/corefcn/sparse-xpow.cc
@@ -211,17 +211,17 @@ xpow (const SparseComplexMatrix& a, doub
 //                  +---+---+----+----+
 //   complex_scalar | * | 5 |  * | 11 |
 //                  +---+---+----+----+
 //   complex_matrix | 2 | 6 |  8 | 12 |
 //                  +---+---+----+----+
 //
 //   * -> not needed.
 
-// FIXME -- these functions need to be fixed so that things
+// FIXME: these functions need to be fixed so that things
 // like
 //
 //   a = -1; b = [ 0, 0.5, 1 ]; r = a .^ b
 //
 // and
 //
 //   a = -1; b = [ 0, 0.5, 1 ]; for i = 1:3, r(i) = a .^ b(i), end
 //
@@ -337,17 +337,17 @@ elem_xpow (const SparseMatrix& a, double
     {
       octave_idx_type nr = a.rows ();
       octave_idx_type nc = a.cols ();
 
       if (static_cast<int> (b) != b && a.any_element_is_negative ())
         {
           ComplexMatrix result (nr, nc, Complex (std::pow (0.0, b)));
 
-          // FIXME -- avoid apparent GNU libm bug by
+          // FIXME: avoid apparent GNU libm bug by
           // converting A and B to complex instead of just A.
           Complex btmp (b);
 
           for (octave_idx_type j = 0; j < nc; j++)
             for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
               {
                 octave_quit ();
 
@@ -375,17 +375,17 @@ elem_xpow (const SparseMatrix& a, double
   else if (static_cast<int> (b) != b && a.any_element_is_negative ())
     {
       SparseComplexMatrix result (a);
 
       for (octave_idx_type i = 0; i < nz; i++)
         {
           octave_quit ();
 
-          // FIXME -- avoid apparent GNU libm bug by
+          // FIXME: avoid apparent GNU libm bug by
           // converting A and B to complex instead of just A.
 
           Complex atmp (a.data (i));
           Complex btmp (b);
 
           result.data (i) = std::pow (atmp, btmp);
         }
 
@@ -752,15 +752,16 @@ elem_xpow (const SparseComplexMatrix& a,
     }
 
   SparseComplexMatrix result (nr, nc, Complex (1.0, 0.0));
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
         {
           octave_quit ();
-          result.xelem (a.ridx (i), j) = std::pow (a.data (i), b(a.ridx (i), j));
+          result.xelem (a.ridx (i), j) = std::pow (a.data (i),
+                                                   b(a.ridx (i), j));
         }
     }
   result.maybe_compress (true);
 
   return result;
 }
diff --git a/libinterp/corefcn/sparse.cc b/libinterp/corefcn/sparse.cc
--- a/libinterp/corefcn/sparse.cc
+++ b/libinterp/corefcn/sparse.cc
@@ -37,33 +37,33 @@ along with Octave; see the file COPYING.
 #include "quit.h"
 #include "unwind-prot.h"
 
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "ov-bool-sparse.h"
 
 DEFUN (issparse, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} issparse (@var{x})\n\
 Return true if @var{x} is a sparse matrix.\n\
 @seealso{ismatrix}\n\
 @end deftypefn")
 {
-   if (args.length () != 1)
-     {
-       print_usage ();
-       return octave_value ();
-     }
-   else
-     return octave_value (args(0).is_sparse_type ());
+  if (args.length () != 1)
+    {
+      print_usage ();
+      return octave_value ();
+    }
+  else
+    return octave_value (args(0).is_sparse_type ());
 }
 
 DEFUN (sparse, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{s} =} sparse (@var{a})\n\
 @deftypefnx {Built-in Function} {@var{s} =} sparse (@var{i}, @var{j}, @var{sv}, @var{m}, @var{n}, @var{nzmax})\n\
 @deftypefnx {Built-in Function} {@var{s} =} sparse (@var{i}, @var{j}, @var{sv})\n\
 @deftypefnx {Built-in Function} {@var{s} =} sparse (@var{i}, @var{j}, @var{s}, @var{m}, @var{n}, \"unique\")\n\
 @deftypefnx {Built-in Function} {@var{s} =} sparse (@var{m}, @var{n})\n\
 Create a sparse matrix from the full matrix or row, column, value triplets.\n\
 If @var{a} is a full matrix, convert it to a sparse matrix representation,\n\
 removing all zero values in the process.\n\
@@ -98,123 +98,123 @@ used.\n\
 @code{sparse (@var{m}, @var{n})} is equivalent to\n\
 @code{sparse ([], [], [], @var{m}, @var{n}, 0)}\n\
 \n\
 If any of @var{sv}, @var{i} or @var{j} are scalars, they are expanded\n\
 to have a common size.\n\
 @seealso{full, accumarray}\n\
 @end deftypefn")
 {
-   octave_value retval;
-   int nargin = args.length ();
+  octave_value retval;
+  int nargin = args.length ();
 
-   // Temporarily disable sparse_auto_mutate if set (it's obsolete anyway).
-   unwind_protect frame;
-   frame.protect_var (Vsparse_auto_mutate);
-   Vsparse_auto_mutate = false;
+  // Temporarily disable sparse_auto_mutate if set (it's obsolete anyway).
+  unwind_protect frame;
+  frame.protect_var (Vsparse_auto_mutate);
+  Vsparse_auto_mutate = false;
 
-   if (nargin == 1)
-     {
-       octave_value arg = args (0);
-       if (arg.is_bool_type ())
-         retval = arg.sparse_bool_matrix_value ();
-       else if (arg.is_complex_type ())
-         retval = arg.sparse_complex_matrix_value ();
-       else if (arg.is_numeric_type ())
-         retval = arg.sparse_matrix_value ();
-       else
-         gripe_wrong_type_arg ("sparse", arg);
-     }
-   else if (nargin == 2)
-     {
-       octave_idx_type m = 0, n = 0;
-       if (args(0).is_scalar_type () && args(1).is_scalar_type ())
-         {
-           m = args(0).idx_type_value ();
-           n = args(1).idx_type_value ();
-         }
-       else
-         error ("sparse: dimensions M,N must be scalar");
+  if (nargin == 1)
+    {
+      octave_value arg = args (0);
+      if (arg.is_bool_type ())
+        retval = arg.sparse_bool_matrix_value ();
+      else if (arg.is_complex_type ())
+        retval = arg.sparse_complex_matrix_value ();
+      else if (arg.is_numeric_type ())
+        retval = arg.sparse_matrix_value ();
+      else
+        gripe_wrong_type_arg ("sparse", arg);
+    }
+  else if (nargin == 2)
+    {
+      octave_idx_type m = 0, n = 0;
+      if (args(0).is_scalar_type () && args(1).is_scalar_type ())
+        {
+          m = args(0).idx_type_value ();
+          n = args(1).idx_type_value ();
+        }
+      else
+        error ("sparse: dimensions M,N must be scalar");
 
-       if (! error_state)
-         {
-           if (m >= 0 && n >= 0)
-             retval = SparseMatrix (m, n);
-           else
-             error ("sparse: dimensions M,N must be positive or zero");
-         }
-     }
-   else if (nargin >= 3)
-     {
-       bool summation = true;
-       if (nargin > 3 && args(nargin-1).is_string ())
-         {
-           std::string opt = args(nargin-1).string_value ();
-           if (opt == "unique")
-             summation = false;
-           else if (opt == "sum" || opt == "summation")
-             summation = true;
-           else
-             error ("sparse: invalid option: %s", opt.c_str ());
+      if (! error_state)
+        {
+          if (m >= 0 && n >= 0)
+            retval = SparseMatrix (m, n);
+          else
+            error ("sparse: dimensions M,N must be positive or zero");
+        }
+    }
+  else if (nargin >= 3)
+    {
+      bool summation = true;
+      if (nargin > 3 && args(nargin-1).is_string ())
+        {
+          std::string opt = args(nargin-1).string_value ();
+          if (opt == "unique")
+            summation = false;
+          else if (opt == "sum" || opt == "summation")
+            summation = true;
+          else
+            error ("sparse: invalid option: %s", opt.c_str ());
 
-           nargin -= 1;
-         }
+          nargin -= 1;
+        }
 
-       if (! error_state)
-         {
-           octave_idx_type m = -1, n = -1, nzmax = -1;
-           if (nargin == 6)
-             {
-               nzmax = args(5).idx_type_value ();
-               nargin --;
-             }
+      if (! error_state)
+        {
+          octave_idx_type m = -1, n = -1, nzmax = -1;
+          if (nargin == 6)
+            {
+              nzmax = args(5).idx_type_value ();
+              nargin --;
+            }
 
-           if (nargin == 5)
-             {
-               if (args(3).is_scalar_type () && args(4).is_scalar_type ())
-                 {
-                   m = args(3).idx_type_value ();
-                   n = args(4).idx_type_value ();
-                 }
-               else
-                 error ("sparse: expecting scalar dimensions");
+          if (nargin == 5)
+            {
+              if (args(3).is_scalar_type () && args(4).is_scalar_type ())
+                {
+                  m = args(3).idx_type_value ();
+                  n = args(4).idx_type_value ();
+                }
+              else
+                error ("sparse: expecting scalar dimensions");
 
 
-               if (! error_state && (m < 0 || n < 0))
-                 error ("sparse: dimensions must be non-negative");
-             }
-           else if (nargin != 3)
-             print_usage ();
+              if (! error_state && (m < 0 || n < 0))
+                error ("sparse: dimensions must be non-negative");
+            }
+          else if (nargin != 3)
+            print_usage ();
 
-           if (! error_state)
-             {
-               idx_vector i = args(0).index_vector ();
-               idx_vector j = args(1).index_vector ();
+          if (! error_state)
+            {
+              idx_vector i = args(0).index_vector ();
+              idx_vector j = args(1).index_vector ();
 
-               if (args(2).is_bool_type ())
-                 retval = SparseBoolMatrix (args(2).bool_array_value (), i, j,
-                                            m, n, summation, nzmax);
-               else if (args(2).is_complex_type ())
-                 retval = SparseComplexMatrix (args(2).complex_array_value (),
-                                               i, j, m, n, summation, nzmax);
-               else if (args(2).is_numeric_type ())
-                 retval = SparseMatrix (args(2).array_value (), i, j,
-                                        m, n, summation, nzmax);
-               else
-                 gripe_wrong_type_arg ("sparse", args(2));
-             }
+              if (args(2).is_bool_type ())
+                retval = SparseBoolMatrix (args(2).bool_array_value (), i, j,
+                                           m, n, summation, nzmax);
+              else if (args(2).is_complex_type ())
+                retval = SparseComplexMatrix (args(2).complex_array_value (),
+                                              i, j, m, n, summation, nzmax);
+              else if (args(2).is_numeric_type ())
+                retval = SparseMatrix (args(2).array_value (), i, j,
+                                       m, n, summation, nzmax);
+              else
+                gripe_wrong_type_arg ("sparse", args(2));
+            }
 
-         }
-     }
+        }
+    }
 
-   return retval;
+  return retval;
 }
 
 DEFUN (spalloc, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{s} =} spalloc (@var{m}, @var{n}, @var{nz})\n\
 Create an @var{m}-by-@var{n} sparse matrix with pre-allocated space for at\n\
 most @var{nz} nonzero elements.  This is useful for building the matrix\n\
 incrementally by a sequence of indexed assignments.  Subsequent indexed\n\
 assignments will reuse the pre-allocated memory, provided they are of one of\n\
 the simple forms\n\
 \n\
 @itemize\n\
@@ -240,30 +240,30 @@ be more memory and time-efficient under 
 it is possible to efficiently build a pre-allocated sparse matrix from\n\
 contiguous block of columns.\n\
 \n\
 The amount of pre-allocated memory for a given matrix may be queried using\n\
 the function @code{nzmax}.\n\
 @seealso{nzmax, sparse}\n\
 @end deftypefn")
 {
-   octave_value retval;
-   int nargin = args.length ();
+  octave_value retval;
+  int nargin = args.length ();
 
-   if (nargin == 2 || nargin == 3)
-     {
-       octave_idx_type m = args(0).idx_type_value ();
-       octave_idx_type n = args(1).idx_type_value ();
-       octave_idx_type nz = 0;
-       if (nargin == 3)
-         nz = args(2).idx_type_value ();
-       if (error_state)
-         ;
-       else if (m >= 0 && n >= 0 && nz >= 0)
-         retval = SparseMatrix (dim_vector (m, n), nz);
-       else
-         error ("spalloc: M,N,NZ must be non-negative");
-     }
-   else
-     print_usage ();
+  if (nargin == 2 || nargin == 3)
+    {
+      octave_idx_type m = args(0).idx_type_value ();
+      octave_idx_type n = args(1).idx_type_value ();
+      octave_idx_type nz = 0;
+      if (nargin == 3)
+        nz = args(2).idx_type_value ();
+      if (error_state)
+        ;
+      else if (m >= 0 && n >= 0 && nz >= 0)
+        retval = SparseMatrix (dim_vector (m, n), nz);
+      else
+        error ("spalloc: M,N,NZ must be non-negative");
+    }
+  else
+    print_usage ();
 
-   return retval;
+  return retval;
 }
diff --git a/libinterp/corefcn/spparms.cc b/libinterp/corefcn/spparms.cc
--- a/libinterp/corefcn/spparms.cc
+++ b/libinterp/corefcn/spparms.cc
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 #include "ov.h"
 #include "pager.h"
 #include "error.h"
 #include "gripes.h"
 
 #include "oct-spparms.h"
 
 DEFUN (spparms, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} { } spparms ()\n\
 @deftypefnx {Built-in Function} {@var{vals} =} spparms ()\n\
 @deftypefnx {Built-in Function} {[@var{keys}, @var{vals}] =} spparms ()\n\
 @deftypefnx {Built-in Function} {@var{val} =} spparms (@var{key})\n\
 @deftypefnx {Built-in Function} { } spparms (@var{vals})\n\
 @deftypefnx {Built-in Function} { } spparms (\"defaults\")\n\
 @deftypefnx {Built-in Function} { } spparms (\"tight\")\n\
 @deftypefnx {Built-in Function} { } spparms (@var{key}, @var{val})\n\
diff --git a/libinterp/corefcn/sqrtm.cc b/libinterp/corefcn/sqrtm.cc
--- a/libinterp/corefcn/sqrtm.cc
+++ b/libinterp/corefcn/sqrtm.cc
@@ -195,17 +195,17 @@ do_sqrtm (const octave_value& arg)
           break;
         }
     }
 
   return retval;
 }
 
 DEFUN (sqrtm, args, nargout,
- "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{s} =} sqrtm (@var{A})\n\
 @deftypefnx {Built-in Function} {[@var{s}, @var{error_estimate}] =} sqrtm (@var{A})\n\
 Compute the matrix square root of the square matrix @var{A}.\n\
 \n\
 Ref: N.J. Higham.  @cite{A New sqrtm for @sc{matlab}}.  Numerical\n\
 Analysis Report No. 336, Manchester @nospell{Centre} for Computational\n\
 Mathematics, Manchester, England, January 1999.\n\
 @seealso{expm, logm}\n\
@@ -237,17 +237,18 @@ Mathematics, Manchester, England, Januar
       retval.resize (1, 2);
       retval(2) = -1.0;
     }
 
   if (arg.is_diag_matrix ())
     // sqrtm of a diagonal matrix is just sqrt.
     retval(0) = arg.sqrt ();
   else if (arg.is_single_type ())
-    retval(0) = do_sqrtm<FloatMatrix, FloatComplexMatrix, FloatComplexSCHUR> (arg);
+    retval(0) = do_sqrtm<FloatMatrix, FloatComplexMatrix, FloatComplexSCHUR>
+                 (arg);
   else if (arg.is_numeric_type ())
     retval(0) = do_sqrtm<Matrix, ComplexMatrix, ComplexSCHUR> (arg);
 
   if (nargout > 1 && ! error_state)
     {
       // This corresponds to generic code
       //
       //   norm (s*s - x, "fro") / norm (x, "fro");
diff --git a/libinterp/corefcn/str2double.cc b/libinterp/corefcn/str2double.cc
--- a/libinterp/corefcn/str2double.cc
+++ b/libinterp/corefcn/str2double.cc
@@ -205,17 +205,17 @@ extract_num (std::istringstream& is, dou
 
               if (is_imag_unit (c))
                 {
                   imag = true;
                   is.get ();
                   c = is.peek ();
                 }
               else
-                is.setstate (std::ios::failbit); // indicate that read has failed.
+                is.setstate (std::ios::failbit); // indicate read has failed.
             }
           else if (is_imag_unit (c))
             {
               imag = true;
               is.get ();
               c = is.peek ();
             }
         }
@@ -289,17 +289,17 @@ str2double1 (const std::string& str_arg)
             set_component (val, num, i2);
         }
     }
 
   return val;
 }
 
 DEFUN (str2double, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} str2double (@var{s})\n\
 Convert a string to a real or complex number.\n\
 \n\
 The string must be in one of the following formats where\n\
 a and b are real numbers and the complex unit is @qcode{'i'} or @qcode{'j'}:\n\
 \n\
 @itemize\n\
 @item a + bi\n\
@@ -361,25 +361,25 @@ risk of using @code{eval} on unknown dat
             retval = sv.map<Complex> (str2double1);
         }
     }
   else if (args(0).is_cell ())
     {
       const Cell cell = args(0).cell_value ();
 
       if (! error_state)
-      {
-        ComplexNDArray output (cell.dims (), octave_NaN);
-        for (octave_idx_type i = 0; i < cell.numel (); i++)
         {
-          if (cell(i).is_string ())
-            output(i) = str2double1 (cell(i).string_value ());
+          ComplexNDArray output (cell.dims (), octave_NaN);
+          for (octave_idx_type i = 0; i < cell.numel (); i++)
+            {
+              if (cell(i).is_string ())
+                output(i) = str2double1 (cell(i).string_value ());
+            }
+          retval = output;
         }
-        retval = output;
-      }
     }
   else
     retval = Matrix (1, 1, octave_NaN);
 
 
   return retval;
 }
 
diff --git a/libinterp/corefcn/strfind.cc b/libinterp/corefcn/strfind.cc
--- a/libinterp/corefcn/strfind.cc
+++ b/libinterp/corefcn/strfind.cc
@@ -32,33 +32,34 @@ along with Octave; see the file COPYING.
 
 #include "Cell.h"
 #include "ov.h"
 #include "defun.h"
 #include "unwind-prot.h"
 #include "gripes.h"
 #include "utils.h"
 
-// This allows safe indexing with char. In C++, char may be (and often is) signed!
+// This allows safe indexing with char.
+// In C++, char may be (and often is) signed!
 #define ORD(ch) static_cast<unsigned char>(ch)
 #define TABSIZE (std::numeric_limits<unsigned char>::max () + 1)
 
 // This is the quick search algorithm, as described at
 // http://www-igm.univ-mlv.fr/~lecroq/string/node19.html
 static void
 qs_preprocess (const Array<char>& needle,
                octave_idx_type *table)
 {
   const char *x = needle.data ();
   octave_idx_type m = needle.numel ();
 
-   for (octave_idx_type i = 0; i < TABSIZE; i++)
-      table[i] = m + 1;
-   for (octave_idx_type i = 0; i < m; i++)
-      table[ORD(x[i])] = m - i;
+  for (octave_idx_type i = 0; i < TABSIZE; i++)
+    table[i] = m + 1;
+  for (octave_idx_type i = 0; i < m; i++)
+    table[ORD(x[i])] = m - i;
 }
 
 
 static Array<octave_idx_type>
 qs_search (const Array<char>& needle,
            const Array<char>& haystack,
            const octave_idx_type *table,
            bool overlaps = true)
@@ -141,17 +142,17 @@ qs_search (const Array<char>& needle,
     {
       result.xelem (k++) = *iter;
     }
 
   return result;
 }
 
 DEFUN (strfind, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{idx} =} strfind (@var{str}, @var{pattern})\n\
 @deftypefnx {Built-in Function} {@var{idx} =} strfind (@var{cellstr}, @var{pattern})\n\
 @deftypefnx {Built-in Function} {@var{idx} =} strfind (@dots{}, \"overlaps\", @var{val})\n\
 Search for @var{pattern} in the string @var{str} and return the\n\
 starting index of every such occurrence in the vector @var{idx}.\n\
 \n\
 If there is no such occurrence, or if @var{pattern} is longer\n\
 than @var{str}, then @var{idx} is the empty array @code{[]}.\n\
@@ -211,32 +212,35 @@ strfind (@{\"abababa\", \"bebebe\", \"ab
       octave_value argstr = args(0), argpat = args(1);
       if (argpat.is_string ())
         {
           Array<char> needle = argpat.char_array_value ();
           OCTAVE_LOCAL_BUFFER (octave_idx_type, table, TABSIZE);
           qs_preprocess (needle, table);
 
           if (argstr.is_string ())
-            retval = octave_value (qs_search (needle, argstr.char_array_value (),
+            retval = octave_value (qs_search (needle,
+                                              argstr.char_array_value (),
                                               table, overlaps),
                                    true, true);
           else if (argstr.is_cell ())
             {
               const Cell argsc = argstr.cell_value ();
               Cell retc (argsc.dims ());
               octave_idx_type ns = argsc.numel ();
 
               for (octave_idx_type i = 0; i < ns; i++)
                 {
                   octave_value argse = argsc(i);
                   if (argse.is_string ())
-                    retc(i) = octave_value (qs_search (needle, argse.char_array_value (),
-                                                       table, overlaps),
-                                            true, true);
+                    retc(i)
+                      = octave_value (qs_search (needle,
+                                                 argse.char_array_value (),
+                                                 table, overlaps),
+                                      true, true);
                   else
                     {
                       error ("strfind: each element of CELLSTR must be a string");
                       break;
                     }
                 }
 
               retval = retc;
@@ -324,17 +328,17 @@ qs_replace (const Array<char>& str, cons
           std::copy (src + k, src + siz, dest);
         }
     }
 
   return ret;
 }
 
 DEFUN (strrep, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{newstr} =} strrep (@var{str}, @var{ptn}, @var{rep})\n\
 @deftypefnx {Built-in Function} {@var{newstr} =} strrep (@var{cellstr}, @var{ptn}, @var{rep})\n\
 @deftypefnx {Built-in Function} {@var{newstr} =} strrep (@dots{}, \"overlaps\", @var{val})\n\
 Replace all occurrences of the pattern @var{ptn} in the string @var{str}\n\
 with the string @var{rep} and return the result.\n\
 \n\
 The optional argument @qcode{\"overlaps\"} determines whether the pattern\n\
 can match at every position in @var{str} (true), or only for unique\n\
@@ -381,28 +385,30 @@ strrep (\"This is a test string\", \"is\
         {
           const Array<char> pat = argpat.char_array_value ();
           const Array<char> rep = argrep.char_array_value ();
 
           OCTAVE_LOCAL_BUFFER (octave_idx_type, table, TABSIZE);
           qs_preprocess (pat, table);
 
           if (argstr.is_string ())
-            retval = qs_replace (argstr.char_array_value (), pat, rep, table, overlaps);
+            retval = qs_replace (argstr.char_array_value (), pat, rep,
+                                 table, overlaps);
           else if (argstr.is_cell ())
             {
               const Cell argsc = argstr.cell_value ();
               Cell retc (argsc.dims ());
               octave_idx_type ns = argsc.numel ();
 
               for (octave_idx_type i = 0; i < ns; i++)
                 {
                   octave_value argse = argsc(i);
                   if (argse.is_string ())
-                    retc(i) = qs_replace (argse.char_array_value (), pat, rep, table, overlaps);
+                    retc(i) = qs_replace (argse.char_array_value (), pat, rep,
+                                          table, overlaps);
                   else
                     {
                       error ("strrep: each element of S must be a string");
                       break;
                     }
                 }
 
               retval = retc;
diff --git a/libinterp/corefcn/strfns.cc b/libinterp/corefcn/strfns.cc
--- a/libinterp/corefcn/strfns.cc
+++ b/libinterp/corefcn/strfns.cc
@@ -36,17 +36,17 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "gripes.h"
 #include "ov.h"
 #include "oct-obj.h"
 #include "unwind-prot.h"
 #include "utils.h"
 
 DEFUN (char, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} char (@var{x})\n\
 @deftypefnx {Built-in Function} {} char (@var{x}, @dots{})\n\
 @deftypefnx {Built-in Function} {} char (@var{s1}, @var{s2}, @dots{})\n\
 @deftypefnx {Built-in Function} {} char (@var{cell_array})\n\
 Create a string array from one or more numeric matrices, character\n\
 matrices, or cell arrays.  Arguments are concatenated vertically.\n\
 The returned values are padded with blanks as needed to make each row\n\
 of the string array have the same length.  Empty input strings are\n\
@@ -167,17 +167,17 @@ char ([97, 98, 99], \"\", @{\"98\", \"99
 %!test
 %! x = char ("foo", "bar", "foobar");
 %! assert (x(1,:), "foo   ");
 %! assert (x(2,:), "bar   ");
 %! assert (x(3,:), "foobar");
 */
 
 DEFUN (strvcat, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} strvcat (@var{x})\n\
 @deftypefnx {Built-in Function} {} strvcat (@var{x}, @dots{})\n\
 @deftypefnx {Built-in Function} {} strvcat (@var{s1}, @var{s2}, @dots{})\n\
 @deftypefnx {Built-in Function} {} strvcat (@var{cell_array})\n\
 Create a character array from one or more numeric matrices, character\n\
 matrices, or cell arrays.  Arguments are concatenated vertically.\n\
 The returned values are padded with blanks as needed to make each row\n\
 of the string array have the same length.  Unlike @code{char}, empty\n\
@@ -298,17 +298,17 @@ strvcat ([97, 98, 99], \"\", @{\"98\", \
 %!assert (strvcat (["a";"be"], {"c", 100}), ["a";"be";"c";"d"])
 %!assert (strvcat ("a", "bb", "ccc"), ["a  "; "bb "; "ccc"])
 
 %!error strvcat ()
 */
 
 
 DEFUN (ischar, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ischar (@var{x})\n\
 Return true if @var{x} is a character array.\n\
 @seealso{isfloat, isinteger, islogical, isnumeric, iscellstr, isa}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
@@ -336,18 +336,20 @@ Return true if @var{x} is a character ar
 
 %!error ischar ()
 %!error ischar ("test", 1)
 */
 
 static octave_value
 do_strcmp_fun (const octave_value& arg0, const octave_value& arg1,
                octave_idx_type n, const char *fcn_name,
-               bool (*array_op) (const charNDArray&, const charNDArray&, octave_idx_type),
-               bool (*str_op) (const std::string&, const std::string&, octave_idx_type))
+               bool (*array_op) (const charNDArray&, const charNDArray&,
+                                 octave_idx_type),
+               bool (*str_op) (const std::string&, const std::string&,
+                               octave_idx_type))
 
 {
   octave_value retval;
 
   bool s1_string = arg0.is_string ();
   bool s1_cell = arg0.is_cell ();
   bool s2_string = arg1.is_string ();
   bool s2_cell = arg1.is_cell ();
@@ -423,27 +425,29 @@ do_strcmp_fun (const octave_value& arg0,
               // Must match in all dimensions.
 
               boolNDArray output (cell.dims (), false);
 
               if (cell.length () == r)
                 {
                   if (cell_val.is_cellstr ())
                     {
-                      const Array<std::string> cellstr = cell_val.cellstr_value ();
+                      const Array<std::string> cellstr
+                        = cell_val.cellstr_value ();
                       for (octave_idx_type i = 0; i < cellstr.length (); i++)
                         output(i) = str_op (str[i], cellstr(i), n);
                     }
                   else
                     {
                       // FIXME: should we warn here?
                       for (octave_idx_type i = 0; i < r; i++)
                         {
                           if (cell(i).is_string ())
-                            output(i) = str_op (str[i], cell(i).string_value (), n);
+                            output(i) = str_op (str[i],
+                                                cell(i).string_value (), n);
                         }
                     }
 
                   retval = output;
                 }
               else
                 retval = false;
             }
@@ -555,17 +559,17 @@ strcmp_array_op (const charNDArray& s1, 
 static bool
 strcmp_str_op (const std::string& s1, const std::string& s2,
                octave_idx_type)
 {
   return s1 == s2;
 }
 
 DEFUN (strcmp, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} strcmp (@var{s1}, @var{s2})\n\
 Return 1 if the character strings @var{s1} and @var{s2} are the same,\n\
 and 0 otherwise.\n\
 \n\
 If either @var{s1} or @var{s2} is a cell array of strings, then an array\n\
 of the same size is returned, containing the values described above for\n\
 every member of the cell array.  The other argument may also be a cell\n\
 array of strings (of the same size or with only one element), char matrix\n\
@@ -635,17 +639,18 @@ This is just the opposite of the corresp
 %!assert (strcmp ("fooba", "foobar"), false)
 
 %!error strcmp ()
 %!error strcmp ("foo", "bar", 3)
 */
 
 // Apparently, Matlab ignores the dims with strncmp. It also
 static bool
-strncmp_array_op (const charNDArray& s1, const charNDArray& s2, octave_idx_type n)
+strncmp_array_op (const charNDArray& s1, const charNDArray& s2,
+                  octave_idx_type n)
 {
   octave_idx_type l1 = s1.numel (), l2 = s2.numel ();
   return (n > 0 && n <= l1 && n <= l2
           && std::equal (s1.data (), s1.data () + n, s2.data ()));
 }
 
 // Otherwise, just use strings. Note that we neither extract substrings (which
 // would mean a copy, at least in GCC), nor use string::compare (which is a
@@ -654,17 +659,17 @@ static bool
 strncmp_str_op (const std::string& s1, const std::string& s2, octave_idx_type n)
 {
   octave_idx_type l1 = s1.length (), l2 = s2.length ();
   return (n > 0 && n <= l1 && n <= l2
           && std::equal (s1.data (), s1.data () + n, s2.data ()));
 }
 
 DEFUN (strncmp, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} strncmp (@var{s1}, @var{s2}, @var{n})\n\
 Return 1 if the first @var{n} characters of strings @var{s1} and @var{s2} are\n\
 the same, and 0 otherwise.\n\
 \n\
 @example\n\
 @group\n\
 strncmp (\"abce\", \"abcd\", 3)\n\
       @result{} 1\n\
@@ -740,25 +745,25 @@ strcmpi_array_op (const charNDArray& s1,
   return (s1.dims () == s2.dims ()
           && std::equal (s1.data (), s1.data () + s1.numel (), s2.data (),
                          icmp_char_eq ()));
 }
 
 // Ditto for string.
 static bool
 strcmpi_str_op (const std::string& s1, const std::string& s2,
-               octave_idx_type)
+                octave_idx_type)
 {
   return (s1.size () == s2.size ()
           && std::equal (s1.data (), s1.data () + s1.size (), s2.data (),
                          icmp_char_eq ()));
 }
 
 DEFUNX ("strcmpi", Fstrcmpi, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} strcmpi (@var{s1}, @var{s2})\n\
 Return 1 if the character strings @var{s1} and @var{s2} are the same,\n\
 disregarding case of alphabetic characters, and 0 otherwise.\n\
 \n\
 If either @var{s1} or @var{s2} is a cell array of strings, then an array\n\
 of the same size is returned, containing the values described above for\n\
 every member of the cell array.  The other argument may also be a cell\n\
 array of strings (of the same size or with only one element), char matrix\n\
@@ -786,36 +791,38 @@ This is just the opposite of the corresp
 }
 
 /*
 %!assert (strcmpi ("abc123", "ABC123"), true)
 */
 
 // Like strncmp.
 static bool
-strncmpi_array_op (const charNDArray& s1, const charNDArray& s2, octave_idx_type n)
+strncmpi_array_op (const charNDArray& s1, const charNDArray& s2,
+                   octave_idx_type n)
 {
   octave_idx_type l1 = s1.numel (), l2 = s2.numel ();
   return (n > 0 && n <= l1 && n <= l2
           && std::equal (s1.data (), s1.data () + n, s2.data (),
                          icmp_char_eq ()));
 }
 
 // Ditto.
 static bool
-strncmpi_str_op (const std::string& s1, const std::string& s2, octave_idx_type n)
+strncmpi_str_op (const std::string& s1, const std::string& s2,
+                 octave_idx_type n)
 {
   octave_idx_type l1 = s1.length (), l2 = s2.length ();
   return (n > 0 && n <= l1 && n <= l2
           && std::equal (s1.data (), s1.data () + n, s2.data (),
                          icmp_char_eq ()));
 }
 
 DEFUNX ("strncmpi", Fstrncmpi, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} strncmpi (@var{s1}, @var{s2}, @var{n})\n\
 Return 1 if the first @var{n} character of @var{s1} and @var{s2} are the\n\
 same, disregarding case of alphabetic characters, and 0 otherwise.\n\
 \n\
 If either @var{s1} or @var{s2} is a cell array of strings, then an array\n\
 of the same size is returned, containing the values described above for\n\
 every member of the cell array.  The other argument may also be a cell\n\
 array of strings (of the same size or with only one element), char matrix\n\
@@ -852,17 +859,17 @@ This is just the opposite of the corresp
   return retval;
 }
 
 /*
 %!assert (strncmpi ("abc123", "ABC456", 3), true)
 */
 
 DEFUN (list_in_columns, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} list_in_columns (@var{arg}, @var{width}, @var{prefix})\n\
 Return a string containing the elements of @var{arg} listed in\n\
 columns with an overall maximum width of @var{width} and optional\n\
 prefix @var{prefix}.  The argument @var{arg} must be a cell array\n\
 of character strings or a character array.  If @var{width} is not\n\
 specified or is an empty matrix, or less than or equal to zero,\n\
 the width of the terminal screen is used.\n\
 Newline characters are used to break the lines in the output string.\n\
@@ -916,17 +923,17 @@ whos ans\n\
       width = args(1).int_value ();
 
       if (error_state)
         {
           error ("list_in_columns: WIDTH must be an integer");
           return retval;
         }
     }
-                
+
   std::string prefix;
 
   if (nargin > 2)
     {
       if (args(2).is_string ())
         {
           prefix = args(2).string_value ();
 
diff --git a/libinterp/corefcn/sub2ind.cc b/libinterp/corefcn/sub2ind.cc
--- a/libinterp/corefcn/sub2ind.cc
+++ b/libinterp/corefcn/sub2ind.cc
@@ -57,17 +57,17 @@ get_dim_vector (const octave_value& val,
             }
         }
     }
 
   return dv;
 }
 
 DEFUN (sub2ind, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Function File} {@var{ind} =} sub2ind (@var{dims}, @var{i}, @var{j})\n\
 @deftypefnx {Function File} {@var{ind} =} sub2ind (@var{dims}, @var{s1}, @var{s2}, @dots{}, @var{sN})\n\
 Convert subscripts to a linear index.\n\
 \n\
 The following example shows how to convert the two-dimensional\n\
 index @code{(2,3)} of a 3-by-3 matrix to a linear index.  The matrix\n\
 is linearly indexed moving from one column to next, filling up\n\
 all rows in each column.\n\
@@ -163,17 +163,17 @@ linear_index = sub2ind ([3, 3], 2, 3)\n\
 
 ## Test input validation
 %!error <dimension vector> sub2ind ([10 10.5], 1, 1)
 %!error <subscript indices> sub2ind ([10 10], 1.5, 1)
 %!error <subscript indices> sub2ind ([10 10], 1, 1.5)
 */
 
 DEFUN (ind2sub, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Function File} {[@var{s1}, @var{s2}, @dots{}, @var{sN}] =} ind2sub (@var{dims}, @var{ind})\n\
 Convert a linear index to subscripts.\n\
 \n\
 The following example shows how to convert the linear index @code{8}\n\
 in a 3-by-3 matrix into a subscript.  The matrix is linearly indexed\n\
 moving from one column to next, filling up all rows in each column.\n\
 \n\
 @example\n\
diff --git a/libinterp/corefcn/svd.cc b/libinterp/corefcn/svd.cc
--- a/libinterp/corefcn/svd.cc
+++ b/libinterp/corefcn/svd.cc
@@ -35,17 +35,17 @@ along with Octave; see the file COPYING.
 #include "oct-obj.h"
 #include "pr-output.h"
 #include "utils.h"
 #include "variables.h"
 
 static int Vsvd_driver = SVD::GESVD;
 
 DEFUN (svd, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{s} =} svd (@var{A})\n\
 @deftypefnx {Built-in Function} {[@var{U}, @var{S}, @var{V}] =} svd (@var{A})\n\
 @deftypefnx {Built-in Function} {[@var{U}, @var{S}, @var{V}] =} svd (@var{A}, @var{econ})\n\
 @cindex singular value decomposition\n\
 Compute the singular value decomposition of @var{A}\n\
 @tex\n\
 $$\n\
  A = U S V^{\\dagger}\n\
@@ -164,17 +164,17 @@ decomposition, eliminating the unnecessa
               retval(1) = FloatMatrix (nr, nc);
               retval(0) = FloatDiagMatrix (nr, nr, 1.0f);
               break;
             case SVD::economy:
               retval(2) = FloatDiagMatrix (0, nc, 1.0f);
               retval(1) = FloatMatrix (0, 0);
               retval(0) = FloatDiagMatrix (nr, 0, 1.0f);
               break;
-            case SVD::sigma_only: default:
+          case SVD::sigma_only: default:
               retval(0) = FloatMatrix (0, 1);
               break;
             }
         }
       else
         {
           switch (type)
             {
@@ -183,17 +183,17 @@ decomposition, eliminating the unnecessa
               retval(1) = Matrix (nr, nc);
               retval(0) = DiagMatrix (nr, nr, 1.0);
               break;
             case SVD::economy:
               retval(2) = DiagMatrix (0, nc, 1.0);
               retval(1) = Matrix (0, 0);
               retval(0) = DiagMatrix (nr, 0, 1.0);
               break;
-            case SVD::sigma_only: default:
+          case SVD::sigma_only: default:
               retval(0) = Matrix (0, 1);
               break;
             }
         }
     }
   else
     {
       if (isfloat)
@@ -398,17 +398,17 @@ decomposition, eliminating the unnecessa
 %! assert (size (v), [0, 0]);
 
 %!error svd ()
 %!error svd ([1, 2; 4, 5], 2, 3)
 %!error [u, v] = svd ([1, 2; 3, 4])
 */
 
 DEFUN (svd_driver, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} svd_driver ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} svd_driver (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} svd_driver (@var{new_val}, \"local\")\n\
 Query or set the underlying @sc{lapack} driver used by @code{svd}.\n\
 Currently recognized values are @qcode{\"gesvd\"} and @qcode{\"gesdd\"}.  \n\
 The default is @qcode{\"gesvd\"}.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
diff --git a/libinterp/corefcn/syl.cc b/libinterp/corefcn/syl.cc
--- a/libinterp/corefcn/syl.cc
+++ b/libinterp/corefcn/syl.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN (syl, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{x} =} syl (@var{A}, @var{B}, @var{C})\n\
 Solve the Sylvester equation\n\
 @tex\n\
 $$\n\
  A X + X B + C = 0\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
@@ -80,18 +80,18 @@ syl ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10;
 
   octave_idx_type c_nr = arg_c.rows ();
   octave_idx_type c_nc = arg_c.columns ();
 
   int arg_a_is_empty = empty_arg ("syl", a_nr, a_nc);
   int arg_b_is_empty = empty_arg ("syl", b_nr, b_nc);
   int arg_c_is_empty = empty_arg ("syl", c_nr, c_nc);
 
-  bool isfloat = arg_a.is_single_type () || arg_b.is_single_type () ||
-    arg_c.is_single_type ();
+  bool isfloat = arg_a.is_single_type () || arg_b.is_single_type ()
+                 || arg_c.is_single_type ();
 
   if (arg_a_is_empty > 0 && arg_b_is_empty > 0 && arg_c_is_empty > 0)
     if (isfloat)
       return octave_value (FloatMatrix ());
     else
       return octave_value (Matrix ());
   else if (arg_a_is_empty || arg_b_is_empty || arg_c_is_empty)
     return retval;
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -50,17 +50,18 @@ symbol_table *symbol_table::instance = 0
 symbol_table::scope_id_cache *symbol_table::scope_id_cache::instance = 0;
 
 std::map<symbol_table::scope_id, symbol_table*> symbol_table::all_instances;
 
 std::map<std::string, octave_value> symbol_table::global_table;
 
 std::map<std::string, symbol_table::fcn_info> symbol_table::fcn_table;
 
-std::map<std::string, std::set<std::string> > symbol_table::class_precedence_table;
+std::map<std::string, std::set<std::string> >
+  symbol_table::class_precedence_table;
 
 std::map<std::string, std::list<std::string> > symbol_table::parent_map;
 
 const symbol_table::scope_id symbol_table::xglobal_scope = 0;
 const symbol_table::scope_id symbol_table::xtop_scope = 1;
 
 symbol_table::scope_id symbol_table::xcurrent_scope = 1;
 
@@ -78,23 +79,23 @@ symbol_table::scope_id_cache::create_ins
   singleton_cleanup_list::add (cleanup_instance);
 }
 
 symbol_table::context_id
 symbol_table::symbol_record::symbol_record_rep::active_context (void) const
 {
   octave_user_function *fcn = curr_fcn;
 
-  // FIXME -- If active_context () == -1, then it does not make much
+  // FIXME: If active_context () == -1, then it does not make much
   // sense to use this symbol_record. This means an attempt at accessing
   // a variable from a function that has not been called yet is
   // happening. This should be cleared up when an implementing closures.
 
   return fcn && fcn->active_context () != static_cast<context_id> (-1)
-    ? fcn->active_context () : xcurrent_context;
+         ? fcn->active_context () : xcurrent_context;
 }
 
 void
 symbol_table::symbol_record::symbol_record_rep::dump
   (std::ostream& os, const std::string& prefix) const
 {
   octave_value val = varval ();
 
@@ -150,17 +151,17 @@ symbol_table::symbol_record::find (const
 // visible.  If the file is no longer visible, then erase the
 // definition and move on.  If the file is visible, then we also
 // need to check to see whether the file has changed since the the
 // function was loaded/parsed.  However, this check should only
 // happen once per prompt (for files found from relative path
 // elements, we also check if the working directory has changed
 // since the last time the function was loaded/parsed).
 //
-// FIXME -- perhaps this should be done for all loaded functions when
+// FIXME: perhaps this should be done for all loaded functions when
 // the prompt is printed or the directory has changed, and then we
 // would not check for it when finding symbol definitions.
 
 static inline bool
 load_out_of_date_fcn (const std::string& ff, const std::string& dir_name,
                       octave_value& function,
                       const std::string& dispatch_type = std::string ())
 {
@@ -186,17 +187,17 @@ out_of_date_check (octave_value& functio
                    bool check_relative)
 {
   bool retval = false;
 
   octave_function *fcn = function.function_value (true);
 
   if (fcn)
     {
-      // FIXME -- we need to handle subfunctions properly here.
+      // FIXME: we need to handle subfunctions properly here.
 
       if (! fcn->is_subfunction ())
         {
           std::string ff = fcn->fcn_file_name ();
 
           if (! ff.empty ())
             {
               octave_time tc = fcn->time_checked ();
@@ -213,20 +214,20 @@ out_of_date_check (octave_value& functio
 
                   std::string file;
                   std::string dir_name;
 
                   if (check_relative)
                     {
                       int nm_len = nm.length ();
 
-                      if (octave_env::absolute_pathname (nm)
-                          && ((nm_len > 4 && (nm.substr (nm_len-4) == ".oct"
-                                              || nm.substr (nm_len-4) == ".mex"))
-                              || (nm_len > 2 && nm.substr (nm_len-2) == ".m")))
+                      if (octave_env::absolute_pathname (nm) &&
+                          ((nm_len > 4 && (nm.substr (nm_len-4) == ".oct"
+                                           || nm.substr (nm_len-4) == ".mex"))
+                            || (nm_len > 2 && nm.substr (nm_len-2) == ".m")))
                         file = nm;
                       else
                         {
                           // We don't want to make this an absolute name,
                           // because load_fcn_file looks at the name to
                           // decide whether it came from a relative lookup.
 
                           if (! dispatch_type.empty ())
@@ -238,17 +239,18 @@ out_of_date_check (octave_value& functio
                                 {
                                   const std::list<std::string>& plist
                                     = symbol_table::parent_classes (dispatch_type);
                                   std::list<std::string>::const_iterator it
                                     = plist.begin ();
 
                                   while (it != plist.end ())
                                     {
-                                      file = load_path::find_method (*it, nm, dir_name);
+                                      file = load_path::find_method (*it, nm,
+                                                                     dir_name);
                                       if (! file.empty ())
                                         break;
 
                                       it++;
                                     }
                                 }
                             }
 
@@ -446,17 +448,17 @@ symbol_table::fcn_info::fcn_info_rep::lo
             }
         }
     }
 
   return retval;
 }
 
 void
-symbol_table::fcn_info::fcn_info_rep:: mark_subfunction_in_scope_as_private
+symbol_table::fcn_info::fcn_info_rep::mark_subfunction_in_scope_as_private
   (scope_id scope, const std::string& class_name)
 {
   scope_val_iterator p = subfunctions.find (scope);
 
   if (p != subfunctions.end ())
     {
       octave_function *fcn = p->second.function_value ();
 
@@ -513,18 +515,20 @@ static builtin_type_t (*build_sup_table 
         builtin_type_t ityp = static_cast<builtin_type_t> (i);
         builtin_type_t jtyp = static_cast<builtin_type_t> (j);
         // FIXME: Is this really right?
         bool use_j =
           (jtyp == btyp_func_handle || ityp == btyp_bool
            || (btyp_isarray (ityp)
                && (! btyp_isarray (jtyp)
                    || (btyp_isinteger (jtyp) && ! btyp_isinteger (ityp))
-                   || ((ityp == btyp_double || ityp == btyp_complex || ityp == btyp_char)
-                       && (jtyp == btyp_float || jtyp == btyp_float_complex)))));
+                   || ((ityp == btyp_double || ityp == btyp_complex
+                        || ityp == btyp_char)
+                       && (jtyp == btyp_float
+                           || jtyp == btyp_float_complex)))));
 
         sup_table[i][j] = use_j ? jtyp : ityp;
       }
 
   return sup_table;
 }
 
 std::string
@@ -641,17 +645,17 @@ symbol_table::fcn_info::fcn_info_rep::xf
 
       octave_user_function *curr_fcn = symbol_table::get_curr_fcn ();
 
       for (scope_id scope = xcurrent_scope; scope >= 0;)
         {
           scope_val_iterator r = subfunctions.find (scope);
           if (r != subfunctions.end ())
             {
-              // FIXME -- out-of-date check here.
+              // FIXME: out-of-date check here.
 
               return r->second;
             }
 
           octave_user_function *scope_curr_fcn = get_curr_fcn (scope);
           if (scope_curr_fcn)
             scope = scope_curr_fcn->parent_fcn_scope ();
           else
@@ -893,33 +897,34 @@ symbol_table::fcn_info::fcn_info_rep::x_
   // subfunctions if we are currently executing a function defined
   // from a .m file.
 
   for (scope_id scope = xcurrent_scope; scope >= 0;)
     {
       scope_val_iterator r = subfunctions.find (scope);
       if (r != subfunctions.end ())
         {
-          // FIXME -- out-of-date check here.
+          // FIXME: out-of-date check here.
 
           return r->second;
         }
 
       octave_user_function *scope_curr_fcn = get_curr_fcn (scope);
       if (scope_curr_fcn)
         scope = scope_curr_fcn->parent_fcn_scope ();
       else
         scope = -1;
     }
 
   return octave_value ();
 }
 
 octave_value
-symbol_table::fcn_info::fcn_info_rep::find_method (const std::string& dispatch_type)
+symbol_table::fcn_info::fcn_info_rep::find_method
+  (const std::string& dispatch_type)
 {
   octave_value retval;
 
   str_val_iterator q = class_methods.find (dispatch_type);
 
   if (q == class_methods.end ())
     {
       octave_value val = load_class_method (dispatch_type);
@@ -1054,18 +1059,18 @@ static std::string
 fcn_file_name (const octave_value& fcn)
 {
   const octave_function *f = fcn.function_value ();
 
   return f ? f->fcn_file_name () : std::string ();
 }
 
 void
-symbol_table::fcn_info::fcn_info_rep::dump
-  (std::ostream& os, const std::string& prefix) const
+symbol_table::fcn_info::fcn_info_rep::dump (std::ostream& os,
+                                            const std::string& prefix) const
 {
   os << prefix << name
      << " ["
      << (cmdline_function.is_defined () ? "c" : "")
      << (built_in_function.is_defined () ? "b" : "")
      << "]\n";
 
   std::string tprefix = prefix + "  ";
@@ -1140,18 +1145,18 @@ octave_value
 symbol_table::find (const std::string& name,
                     const octave_value_list& args,
                     bool skip_variables,
                     bool local_funcs)
 {
   symbol_table *inst = get_instance (xcurrent_scope);
 
   return inst
-    ? inst->do_find (name, args, skip_variables, local_funcs)
-    : octave_value ();
+         ? inst->do_find (name, args, skip_variables, local_funcs)
+         : octave_value ();
 }
 
 octave_value
 symbol_table::builtin_find (const std::string& name)
 {
   symbol_table *inst = get_instance (xcurrent_scope);
 
   return inst ? inst->do_builtin_find (name) : octave_value ();
@@ -1226,17 +1231,18 @@ symbol_table::dump (std::ostream& os, sc
 
           std::map<std::string, octave_value> sfuns
             = symbol_table::subfunctions_defined_in_scope (scope);
 
           if (! sfuns.empty ())
             {
               os << "  subfunctions defined in this scope:\n";
 
-              for (std::map<std::string, octave_value>::const_iterator p = sfuns.begin ();
+              for (std::map<std::string,
+                   octave_value>::const_iterator p = sfuns.begin ();
                    p != sfuns.end (); p++)
                 os << "    " << p->first << "\n";
 
               os << "\n";
             }
 
           inst->do_dump (os);
         }
@@ -1278,17 +1284,17 @@ symbol_table::dump_functions (std::ostre
       os << "\n";
     }
 }
 
 void
 symbol_table::stash_dir_name_for_subfunctions (scope_id scope,
                                                const std::string& dir_name)
 {
-  // FIXME -- is this the best way to do this?  Maybe it would be
+  // FIXME: is this the best way to do this?  Maybe it would be
   // better if we had a map from scope to list of subfunctions
   // stored with the function.  Do we?
 
   for (fcn_table_const_iterator p = fcn_table.begin ();
        p != fcn_table.end (); p++)
     {
       std::pair<std::string, octave_value> tmp
         = p->second.subfunction_defined_in_scope (scope);
@@ -1517,17 +1523,17 @@ symbol_table::do_update_nest (void)
     }
 
   for (std::vector<symbol_table*>::iterator iter = nest_children.begin ();
        iter != nest_children.end (); ++iter)
     (*iter)->do_update_nest ();
 }
 
 DEFUN (ignore_function_time_stamp, args, nargout,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} ignore_function_time_stamp ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} ignore_function_time_stamp (@var{new_val})\n\
 Query or set the internal variable that controls whether Octave checks\n\
 the time stamp on files each time it looks up functions defined in\n\
 function files.  If the internal variable is set to @qcode{\"system\"},\n\
 Octave will not automatically recompile function files in subdirectories of\n\
 @file{@var{octave-home}/lib/@var{version}} if they have changed since\n\
 they were last compiled, but will recompile other function files in the\n\
@@ -1598,31 +1604,31 @@ need to recompiled.\n\
 
 ## Test input validation
 %!error (ignore_function_time_stamp ("all", "all"))
 %!error (ignore_function_time_stamp ("UNKNOWN_VALUE"))
 %!error (ignore_function_time_stamp (42))
 */
 
 DEFUN (__current_scope__, , ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{scope}, @var{context}]} __dump_symtab_info__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = symbol_table::current_context ();
   retval(0) = symbol_table::current_scope ();
 
   return retval;
 }
 
 DEFUN (__dump_symtab_info__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} __dump_symtab_info__ ()\n\
 @deftypefnx {Built-in Function} {} __dump_symtab_info__ (@var{scope})\n\
 @deftypefnx {Built-in Function} {} __dump_symtab_info__ (\"scopes\")\n\
 @deftypefnx {Built-in Function} {} __dump_symtab_info__ (\"functions\")\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -1652,18 +1658,18 @@ Undocumented internal function.\n\
           if (s_arg == "scopes")
             {
               std::list<symbol_table::scope_id> lst = symbol_table::scopes ();
 
               RowVector v (lst.size ());
 
               octave_idx_type k = 0;
 
-              for (std::list<symbol_table::scope_id>::const_iterator p = lst.begin ();
-                   p != lst.end (); p++)
+              for (std::list<symbol_table::scope_id>::const_iterator
+                   p = lst.begin (); p != lst.end (); p++)
                 v.xelem (k++) = *p;
 
               retval = v;
             }
           else if (s_arg == "functions")
             {
               symbol_table::dump_functions (octave_stdout);
             }
@@ -1683,17 +1689,17 @@ Undocumented internal function.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 #if 0
 
-// FIXME -- should we have functions like this in Octave?
+// FIXME: should we have functions like this in Octave?
 
 DEFUN (set_variable, args, , "set_variable (NAME, VALUE)")
 {
   octave_value retval;
 
   if (args.length () == 2)
     {
       std::string name = args(0).string_value ();
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -257,17 +257,17 @@ public:
         // avoid calling deprecated functions.
 
         if (is_global ())
           {
             symbol_table::global_table_iterator p
               = symbol_table::global_table.find (name);
 
             return (p == symbol_table::global_table.end ())
-              ? symbol_table::global_table[name] : p->second;
+                   ? symbol_table::global_table[name] : p->second;
           }
         else if (is_persistent ())
           {
             static octave_value foobar;
 
             symbol_table *inst
               = symbol_table::get_instance (symbol_table::current_scope ());
 
@@ -423,17 +423,17 @@ public:
       void init_persistent (void)
       {
         if (! is_defined ())
           {
             mark_persistent ();
 
             assign (symbol_table::persistent_varval (name));
           }
-        // FIXME -- this causes trouble with recursive calls.
+        // FIXME: this causes trouble with recursive calls.
         // else
         //   error ("unable to declare existing variable persistent");
       }
 
       void invalidate (void)
       {
         valid = false;
       }
@@ -732,20 +732,22 @@ public:
 
   class
   fcn_info
   {
   public:
 
     typedef std::map<std::string, std::string> dispatch_map_type;
 
-    typedef std::map<scope_id, octave_value>::const_iterator scope_val_const_iterator;
+    typedef std::map<scope_id, octave_value>::const_iterator
+      scope_val_const_iterator;
     typedef std::map<scope_id, octave_value>::iterator scope_val_iterator;
 
-    typedef std::map<std::string, octave_value>::const_iterator str_val_const_iterator;
+    typedef std::map<std::string, octave_value>::const_iterator
+      str_val_const_iterator;
     typedef std::map<std::string, octave_value>::iterator str_val_iterator;
 
     typedef dispatch_map_type::const_iterator dispatch_map_const_iterator;
     typedef dispatch_map_type::iterator dispatch_map_iterator;
 
   private:
 
     class
@@ -775,17 +777,18 @@ public:
 
       octave_value find_user_function (void);
 
       bool is_user_function_defined (void) const
       {
         return function_on_path.is_defined ();
       }
 
-      octave_value find_function (const octave_value_list& args, bool local_funcs)
+      octave_value find_function (const octave_value_list& args,
+                                  bool local_funcs)
       {
         return find (args, local_funcs);
       }
 
       void lock_subfunction (scope_id scope)
       {
         scope_val_iterator p = subfunctions.find (scope);
 
@@ -802,18 +805,18 @@ public:
       }
 
       std::pair<std::string, octave_value>
       subfunction_defined_in_scope (scope_id scope) const
       {
         scope_val_const_iterator p = subfunctions.find (scope);
 
         return p == subfunctions.end ()
-          ? std::pair<std::string, octave_value> ()
-          : std::pair<std::string, octave_value> (name, p->second);
+               ? std::pair<std::string, octave_value> ()
+               : std::pair<std::string, octave_value> (name, p->second);
       }
 
       void erase_subfunction (scope_id scope)
       {
         scope_val_iterator p = subfunctions.find (scope);
 
         if (p != subfunctions.end ())
           subfunctions.erase (p);
@@ -1018,17 +1021,18 @@ public:
       return rep->find_user_function ();
     }
 
     bool is_user_function_defined (void) const
     {
       return rep->is_user_function_defined ();
     }
 
-    octave_value find_function (const octave_value_list& args = octave_value_list (),
+    octave_value find_function (const octave_value_list& args
+                                  = octave_value_list (),
                                 bool local_funcs = true)
     {
       return rep->find_function (args, local_funcs);
     }
 
     void lock_subfunction (scope_id scope)
     {
       rep->lock_subfunction (scope);
@@ -1100,17 +1104,18 @@ public:
       rep->clear_dispatch (type);
     }
 
     void print_dispatch (std::ostream& os) const
     {
       rep->print_dispatch (os);
     }
 
-    std::string help_for_dispatch (void) const { return rep->help_for_dispatch (); }
+    std::string help_for_dispatch (void) const
+    { return rep->help_for_dispatch (); }
 
     dispatch_map_type get_dispatch (void) const
     {
       return rep->get_dispatch ();
     }
 
     void
     dump (std::ostream& os, const std::string& prefix = std::string ()) const
@@ -1196,27 +1201,25 @@ public:
         all_instances.erase (p);
 
         free_scope (scope);
       }
   }
 
   static void erase_subfunctions_in_scope (scope_id scope)
   {
-    for (fcn_table_iterator q = fcn_table.begin ();
-         q != fcn_table.end (); q++)
+    for (fcn_table_iterator q = fcn_table.begin (); q != fcn_table.end (); q++)
       q->second.erase_subfunction (scope);
   }
 
   static void
   mark_subfunctions_in_scope_as_private (scope_id scope,
                                          const std::string& class_name)
   {
-    for (fcn_table_iterator q = fcn_table.begin ();
-         q != fcn_table.end (); q++)
+    for (fcn_table_iterator q = fcn_table.begin (); q != fcn_table.end (); q++)
       q->second.mark_subfunction_in_scope_as_private (scope, class_name);
   }
 
   static scope_id dup_scope (scope_id scope)
   {
     scope_id retval = -1;
 
     symbol_table *inst = get_instance (scope);
@@ -1486,39 +1489,39 @@ public:
   }
 
   static octave_value
   find_built_in_function (const std::string& name)
   {
     fcn_table_const_iterator p = fcn_table.find (name);
 
     return (p != fcn_table.end ())
-      ? p->second.find_built_in_function () : octave_value ();
+           ? p->second.find_built_in_function () : octave_value ();
   }
 
   static octave_value
   find_autoload (const std::string& name)
   {
     fcn_table_iterator p = fcn_table.find (name);
 
     return (p != fcn_table.end ())
-      ? p->second.find_autoload () : octave_value ();
+           ? p->second.find_autoload () : octave_value ();
   }
 
   static octave_value
   find_function (const std::string& name,
                  const octave_value_list& args = octave_value_list (),
                  bool local_funcs = true);
 
   static octave_value find_user_function (const std::string& name)
   {
     fcn_table_iterator p = fcn_table.find (name);
 
     return (p != fcn_table.end ())
-      ? p->second.find_user_function () : octave_value ();
+           ? p->second.find_user_function () : octave_value ();
   }
 
   static void install_cmdline_function (const std::string& name,
                                         const octave_value& fcn)
   {
     fcn_table_iterator p = fcn_table.find (name);
 
     if (p != fcn_table.end ())
@@ -1675,17 +1678,17 @@ public:
     symbol_table *inst = get_instance (xcurrent_scope);
 
     if (inst)
       inst->do_clear_variable (name);
   }
 
   static void clear_symbol (const std::string& name)
   {
-    // FIXME -- are we supposed to do both here?
+    // FIXME: are we supposed to do both here?
 
     clear_variable (name);
     clear_function (name);
   }
 
   static void clear_function_pattern (const std::string& pat)
   {
     glob_match pattern (pat);
@@ -1718,33 +1721,33 @@ public:
     symbol_table *inst = get_instance (xcurrent_scope);
 
     if (inst)
       inst->do_clear_variable_regexp (pat);
   }
 
   static void clear_symbol_pattern (const std::string& pat)
   {
-    // FIXME -- are we supposed to do both here?
+    // FIXME: are we supposed to do both here?
 
     clear_variable_pattern (pat);
     clear_function_pattern (pat);
   }
 
   static void clear_user_function (const std::string& name)
   {
     fcn_table_iterator p = fcn_table.find (name);
 
     if (p != fcn_table.end ())
       {
         fcn_info& finfo = p->second;
 
         finfo.clear_user_function ();
       }
-    // FIXME -- is this necessary, or even useful?
+    // FIXME: is this necessary, or even useful?
     // else
     //   error ("clear: no such function '%s'", name.c_str ());
   }
 
   // This clears oct and mex files, incl. autoloads.
   static void clear_dld_function (const std::string& name)
   {
     fcn_table_iterator p = fcn_table.find (name);
@@ -1925,18 +1928,18 @@ public:
   all_variables (scope_id scope = xcurrent_scope,
                  context_id context = xdefault_context,
                  bool defined_only = true,
                  unsigned int exclude = symbol_record::hidden)
   {
     symbol_table *inst = get_instance (scope);
 
     return inst
-      ? inst->do_all_variables (context, defined_only, exclude)
-      : std::list<symbol_record> ();
+           ? inst->do_all_variables (context, defined_only, exclude)
+           : std::list<symbol_record> ();
   }
 
   static std::list<symbol_record> glob (const std::string& pattern)
   {
     symbol_table *inst = get_instance (xcurrent_scope);
 
     return inst ? inst->do_glob (pattern) : std::list<symbol_record> ();
   }
@@ -1972,17 +1975,17 @@ public:
     for (global_table_const_iterator p = global_table.begin ();
          p != global_table.end (); p++)
       {
         // We generate a list of symbol_record objects so that
         // the results from glob_variables and glob_global_variables
         // may be handled the same way.
 
         if (pat.match (p->first))
-          retval.push_back (symbol_record (xglobal_scope, 
+          retval.push_back (symbol_record (xglobal_scope,
                                            p->first, p->second,
                                            symbol_record::global));
       }
 
     return retval;
   }
 
   static std::list<symbol_record>
@@ -2147,17 +2150,17 @@ public:
       }
   }
 
   static std::list<workspace_element> workspace_info (void)
   {
     symbol_table *inst = get_instance (xcurrent_scope);
 
     return inst
-      ? inst->do_workspace_info () : std::list<workspace_element> ();
+           ? inst->do_workspace_info () : std::list<workspace_element> ();
   }
 
   static void dump (std::ostream& os, scope_id scope = xcurrent_scope);
 
   static void dump_global (std::ostream& os);
 
   static void dump_functions (std::ostream& os);
 
@@ -2230,71 +2233,81 @@ public:
     if (it != parent_map.end ())
       retval = it->second;
 
     for (std::list<std::string>::const_iterator lit = retval.begin ();
          lit != retval.end (); lit++)
       {
         // Search for parents of parents and append them to the list.
 
-        // FIXME -- should we worry about a circular inheritance graph?
+        // FIXME: should we worry about a circular inheritance graph?
 
         std::list<std::string> parents = parent_classes (*lit);
 
         if (! parents.empty ())
           retval.insert (retval.end (), parents.begin (), parents.end ());
       }
 
     return retval;
   }
 
   static octave_user_function *get_curr_fcn (scope_id scope = xcurrent_scope)
-    {
-      symbol_table *inst = get_instance (scope);
-      return inst->curr_fcn;
-    }
+  {
+    symbol_table *inst = get_instance (scope);
+    return inst->curr_fcn;
+  }
 
   static void set_curr_fcn (octave_user_function *curr_fcn,
                             scope_id scope = xcurrent_scope)
-    {
-      assert (scope != xtop_scope && scope != xglobal_scope);
-      symbol_table *inst = get_instance (scope);
-      // FIXME: normally, functions should not usurp each other's scope.
-      // If for any incredible reason this is needed, call
-      // set_user_function (0, scope) first. This may cause problems with
-      // nested functions, as the curr_fcn of symbol_records must be updated.
-      assert (inst->curr_fcn == 0 || curr_fcn == 0);
-      inst->curr_fcn = curr_fcn;
-    }
+  {
+    assert (scope != xtop_scope && scope != xglobal_scope);
+    symbol_table *inst = get_instance (scope);
+    // FIXME: normally, functions should not usurp each other's scope.
+    // If for any incredible reason this is needed, call
+    // set_user_function (0, scope) first. This may cause problems with
+    // nested functions, as the curr_fcn of symbol_records must be updated.
+    assert (inst->curr_fcn == 0 || curr_fcn == 0);
+    inst->curr_fcn = curr_fcn;
+  }
 
   static void cleanup (void);
 
 private:
 
   // No copying!
 
   symbol_table (const symbol_table&);
 
   symbol_table& operator = (const symbol_table&);
 
-  typedef std::map<std::string, symbol_record>::const_iterator table_const_iterator;
-  typedef std::map<std::string, symbol_record>::iterator table_iterator;
-
-  typedef std::map<std::string, octave_value>::const_iterator global_table_const_iterator;
-  typedef std::map<std::string, octave_value>::iterator global_table_iterator;
-
-  typedef std::map<std::string, octave_value>::const_iterator persistent_table_const_iterator;
-  typedef std::map<std::string, octave_value>::iterator persistent_table_iterator;
-
-  typedef std::map<scope_id, symbol_table*>::const_iterator all_instances_const_iterator;
-  typedef std::map<scope_id, symbol_table*>::iterator all_instances_iterator;
-
-  typedef std::map<std::string, fcn_info>::const_iterator fcn_table_const_iterator;
-  typedef std::map<std::string, fcn_info>::iterator fcn_table_iterator;
-  
+  typedef std::map<std::string, symbol_record>::const_iterator
+    table_const_iterator;
+  typedef std::map<std::string, symbol_record>::iterator
+    table_iterator;
+
+  typedef std::map<std::string, octave_value>::const_iterator
+    global_table_const_iterator;
+  typedef std::map<std::string, octave_value>::iterator
+    global_table_iterator;
+
+  typedef std::map<std::string, octave_value>::const_iterator
+    persistent_table_const_iterator;
+  typedef std::map<std::string, octave_value>::iterator
+    persistent_table_iterator;
+
+  typedef std::map<scope_id, symbol_table*>::const_iterator
+    all_instances_const_iterator;
+  typedef std::map<scope_id, symbol_table*>::iterator
+    all_instances_iterator;
+
+  typedef std::map<std::string, fcn_info>::const_iterator
+    fcn_table_const_iterator;
+  typedef std::map<std::string, fcn_info>::iterator
+    fcn_table_iterator;
+
   // The scope of this symbol table.
   scope_id my_scope;
 
   // Name for this table (usually the file name of the function
   // corresponding to the scope);
   std::string table_name;
 
   // Map from symbol names to symbol info.
@@ -2327,37 +2340,42 @@ private:
   // Map from function names to function info (subfunctions, private
   // functions, class constructors, class methods, etc.)
   static std::map<std::string, fcn_info> fcn_table;
 
   // Mape from class names to set of classes that have lower
   // precedence.
   static std::map<std::string, std::set<std::string> > class_precedence_table;
 
-  typedef std::map<std::string, std::set<std::string> >::const_iterator class_precedence_table_const_iterator;
-  typedef std::map<std::string, std::set<std::string> >::iterator class_precedence_table_iterator;
+  typedef std::map<std::string, std::set<std::string> >::const_iterator
+    class_precedence_table_const_iterator;
+  typedef std::map<std::string, std::set<std::string> >::iterator
+    class_precedence_table_iterator;
 
   // Map from class names to parent class names.
   static std::map<std::string, std::list<std::string> > parent_map;
 
-  typedef std::map<std::string, std::list<std::string> >::const_iterator const_parent_map_iterator;
-  typedef std::map<std::string, std::list<std::string> >::iterator parent_map_iterator;
+  typedef std::map<std::string, std::list<std::string> >::const_iterator
+    const_parent_map_iterator;
+  typedef std::map<std::string, std::list<std::string> >::iterator
+    parent_map_iterator;
 
   static const scope_id xglobal_scope;
   static const scope_id xtop_scope;
 
   static scope_id xcurrent_scope;
 
   static context_id xcurrent_context;
 
   static const context_id xdefault_context = static_cast<context_id> (-1);
 
   symbol_table (scope_id scope)
-    : my_scope (scope), table_name (), table (), nest_children (), nest_parent (0),
-    curr_fcn (0), static_workspace (false), persistent_table () { }
+    : my_scope (scope), table_name (), table (), nest_children (),
+      nest_parent (0), curr_fcn (0), static_workspace (false),
+      persistent_table () { }
 
   ~symbol_table (void) { }
 
   static symbol_table *get_instance (scope_id scope, bool create = true)
   {
     symbol_table *retval = 0;
 
     bool ok = true;
@@ -2425,17 +2443,18 @@ private:
   {
     table[sr.name ()] = sr;
   }
 
   void
   do_dup_scope (symbol_table& new_symbol_table) const
   {
     for (table_const_iterator p = table.begin (); p != table.end (); p++)
-      new_symbol_table.insert_symbol_record (p->second.dup (new_symbol_table.my_scope));
+      new_symbol_table.insert_symbol_record (p->second.dup (new_symbol_table
+                                                            .my_scope));
   }
 
   symbol_record do_find_symbol (const std::string& name)
   {
     table_iterator p = table.find (name);
 
     if (p == table.end ())
       return do_insert (name);
@@ -2464,20 +2483,20 @@ private:
                     sr.mark_inherited ();
                   }
               }
           }
       }
   }
 
   static fcn_info *get_fcn_info (const std::string& name)
-    {
-      fcn_table_iterator p = fcn_table.find (name);
-      return p != fcn_table.end () ? &p->second : 0;
-    }
+  {
+    fcn_table_iterator p = fcn_table.find (name);
+    return p != fcn_table.end () ? &p->second : 0;
+  }
 
   octave_value
   do_find (const std::string& name, const octave_value_list& args,
            bool skip_variables, bool local_funcs);
 
   octave_value do_builtin_find (const std::string& name);
 
   symbol_record& do_insert (const std::string& name, bool force_add = false)
@@ -2552,35 +2571,34 @@ private:
 
   octave_value do_varval (const std::string& name, context_id context) const
   {
     table_const_iterator p = table.find (name);
 
     return (p != table.end ()) ? p->second.varval (context) : octave_value ();
   }
 
-  void do_persistent_assign (const std::string& name,
-                             const octave_value& value)
+  void do_persistent_assign (const std::string& name, const octave_value& value)
   {
     persistent_table_iterator p = persistent_table.find (name);
 
     if (p == persistent_table.end ())
       persistent_table[name] = value;
     else
       p->second = value;
   }
 
   // Use do_persistent_assign (name, value) instead.
   // Delete when deprecated varref functions are removed.
   octave_value& do_persistent_varref (const std::string& name)
   {
     persistent_table_iterator p = persistent_table.find (name);
 
     return (p == persistent_table.end ())
-      ? persistent_table[name] : p->second;
+           ? persistent_table[name] : p->second;
   }
 
   octave_value do_persistent_varval (const std::string& name)
   {
     persistent_table_const_iterator p = persistent_table.find (name);
 
     return (p != persistent_table.end ()) ? p->second : octave_value ();
   }
diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -105,17 +105,17 @@ mk_stat_result (const base_file_stat& fs
       retval(1) = -1;
       retval(0) = Matrix ();
     }
 
   return retval;
 }
 
 DEFUNX ("dup2", Fdup2, args, ,
- "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{fid}, @var{msg}] =} dup2 (@var{old}, @var{new})\n\
 Duplicate a file descriptor.\n\
 \n\
 If successful, @var{fid} is greater than zero and contains the new file\n\
 ID@.  Otherwise, @var{fid} is negative and @var{msg} contains a\n\
 system-dependent error message.\n\
 @end deftypefn")
 {
@@ -157,17 +157,17 @@ system-dependent error message.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("exec", Fexec, args, ,
- "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} exec (@var{file}, @var{args})\n\
 Replace current process with a new process.  Calling @code{exec} without\n\
 first calling @code{fork} will terminate your current Octave process and\n\
 replace it with the program named by @var{file}.  For example,\n\
 \n\
 @example\n\
 exec (\"ls\" \"-l\")\n\
 @end example\n\
@@ -240,17 +240,17 @@ error message.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("popen2", Fpopen2, args, ,
- "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{in}, @var{out}, @var{pid}] =} popen2 (@var{command}, @var{args})\n\
 Start a subprocess with two-way communication.  The name of the process\n\
 is given by @var{command}, and @var{args} is an array of strings\n\
 containing options for the command.  The file identifiers for the input\n\
 and output streams of the subprocess are returned in @var{in} and\n\
 @var{out}.  If execution of the command is successful, @var{pid}\n\
 contains the process ID of the subprocess.  Otherwise, @var{pid} is\n\
 @minus{}1.\n\
@@ -334,37 +334,38 @@ exit status, it will linger until Octave
               bool sync_mode = (nargin == 3 ? args(2).bool_value () : false);
 
               if (! error_state)
                 {
                   int fildes[2];
                   std::string msg;
                   pid_t pid;
 
-                  pid = octave_syscalls::popen2 (exec_file, arg_list, sync_mode, fildes, msg, interactive);
+                  pid = octave_syscalls::popen2 (exec_file, arg_list, sync_mode,
+                                                 fildes, msg, interactive);
                   if (pid >= 0)
                     {
                       FILE *ifile = fdopen (fildes[1], "r");
                       FILE *ofile = fdopen (fildes[0], "w");
 
                       std::string nm;
 
                       octave_stream is = octave_stdiostream::create (nm, ifile,
-                          std::ios::in);
+                                                                  std::ios::in);
 
                       octave_stream os = octave_stdiostream::create (nm, ofile,
-                          std::ios::out);
+                                                                 std::ios::out);
 
                       Cell file_ids (1, 2);
 
                       retval(2) = pid;
                       retval(1) = octave_stream_list::insert (is);
                       retval(0) = octave_stream_list::insert (os);
                     }
-                                  else
+                  else
                     error (msg.c_str ());
                 }
             }
           else
             error ("popen2: arguments must be character strings");
         }
       else
         error ("popen2: COMMAND argument must be a string");
@@ -412,17 +413,17 @@ exit status, it will linger until Octave
 %! if (isunix ())
 %!   assert (str, {"these\n","strings\n","some\n","are\n"});
 %! else
 %!   assert (str, {"these\r\n","strings\r\n","some\r\n","are\r\n"});
 %! endif
 */
 
 DEFUNX ("fcntl", Ffcntl, args, ,
- "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} fcntl (@var{fid}, @var{request}, @var{arg})\n\
 Change the properties of the open file @var{fid}.  The following values\n\
 may be passed as @var{request}:\n\
 \n\
 @vtable @code\n\
 @item F_DUPFD\n\
 Return a duplicate file descriptor.\n\
 \n\
@@ -488,17 +489,17 @@ system-dependent error message.\n\
         {
           int fid = strm.file_number ();
 
           int req = args(1).int_value (true);
           int arg = args(2).int_value (true);
 
           if (! error_state)
             {
-              // FIXME -- Need better checking here?
+              // FIXME: Need better checking here?
               if (fid < 0)
                 error ("fcntl: invalid file id");
               else
                 {
                   std::string msg;
 
                   int status = octave_fcntl (fid, req, arg, msg);
 
@@ -512,17 +513,17 @@ system-dependent error message.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("fork", Ffork, args, ,
- "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{pid}, @var{msg}] =} fork ()\n\
 Create a copy of the current process.\n\
 \n\
 Fork can return one of the following values:\n\
 \n\
 @table @asis\n\
 @item > 0\n\
 You are in the parent process.  The value returned from @code{fork} is\n\
@@ -557,17 +558,17 @@ action.  A system dependent error messag
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("getpgrp", Fgetpgrp, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {pgid =} getpgrp ()\n\
 Return the process group id of the current process.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1;
@@ -583,17 +584,17 @@ Return the process group id of the curre
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("getpid", Fgetpid, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {pid =} getpid ()\n\
 Return the process id of the current process.\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
@@ -601,17 +602,17 @@ Return the process id of the current pro
     retval = octave_syscalls::getpid ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("getppid", Fgetppid, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {pid =} getppid ()\n\
 Return the process id of the parent process.\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
@@ -619,17 +620,17 @@ Return the process id of the parent proc
     retval = octave_syscalls::getppid ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("getegid", Fgetegid, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {egid =} getegid ()\n\
 Return the effective group id of the current process.\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
@@ -637,17 +638,17 @@ Return the effective group id of the cur
     retval = octave_syscalls::getegid ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("getgid", Fgetgid, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {gid =} getgid ()\n\
 Return the real group id of the current process.\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
@@ -655,17 +656,17 @@ Return the real group id of the current 
     retval = octave_syscalls::getgid ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("geteuid", Fgeteuid, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {euid =} geteuid ()\n\
 Return the effective user id of the current process.\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
@@ -673,17 +674,17 @@ Return the effective user id of the curr
     retval = octave_syscalls::geteuid ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("getuid", Fgetuid, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {uid =} getuid ()\n\
 Return the real user id of the current process.\n\
 @end deftypefn")
 {
   octave_value retval = -1;
 
   int nargin = args.length ();
 
@@ -691,17 +692,17 @@ Return the real user id of the current p
     retval = octave_syscalls::getuid ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("kill", Fkill, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} kill (@var{pid}, @var{sig})\n\
 Send signal @var{sig} to process @var{pid}.\n\
 \n\
 If @var{pid} is positive, then signal @var{sig} is sent to @var{pid}.\n\
 \n\
 If @var{pid} is 0, then signal @var{sig} is sent to every process\n\
 in the process group of the current process.\n\
 \n\
@@ -743,17 +744,17 @@ Return 0 if successful, otherwise return
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("lstat", Flstat, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{info} =} lstat (@var{symlink})\n\
 @deftypefnx {Built-in Function} {[@var{info}, @var{err}, @var{msg}] =} lstat (@var{symlink})\n\
 Return a structure @var{info} containing information about the symbolic link\n\
 @var{symlink}.\n\
 \n\
 The function outputs are described in the documentation for @code{stat}.\n\
 @seealso{stat, symlink}\n\
 @end deftypefn")
@@ -773,17 +774,17 @@ The function outputs are described in th
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("mkfifo", Fmkfifo, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} mkfifo (@var{name}, @var{mode})\n\
 @deftypefnx {Built-in Function} {[@var{err}, @var{msg}] =} mkfifo (@var{name}, @var{mode})\n\
 Create a FIFO special file named @var{name} with file mode @var{mode}\n\
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
 system-dependent error message.\n\
 @seealso{pipe}\n\
@@ -828,17 +829,17 @@ system-dependent error message.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("pipe", Fpipe, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{read_fd}, @var{write_fd}, @var{err}, @var{msg}] =} pipe ()\n\
 Create a pipe and return the reading and writing ends of the pipe\n\
 into @var{read_fd} and @var{write_fd} respectively.\n\
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
 system-dependent error message.\n\
 @seealso{mkfifo}\n\
@@ -883,17 +884,17 @@ system-dependent error message.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("stat", Fstat, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{info}, @var{err}, @var{msg}] =} stat (@var{file})\n\
 @deftypefnx {Built-in Function} {[@var{info}, @var{err}, @var{msg}] =} stat (@var{fid})\n\
 @deftypefnx {Built-in Function} {[@var{info}, @var{err}, @var{msg}] =} lstat (@var{file})\n\
 @deftypefnx {Built-in Function} {[@var{info}, @var{err}, @var{msg}] =} lstat (@var{fid})\n\
 Return a structure @var{info} containing the following information about\n\
 @var{file} or file identifier @var{fid}.\n\
 \n\
 @table @code\n\
@@ -1012,17 +1013,17 @@ For example:\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISREG", FS_ISREG, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} S_ISREG (@var{mode})\n\
 Return true if @var{mode} corresponds to a regular file.\n\
 \n\
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
@@ -1038,17 +1039,17 @@ The value of @var{mode} is assumed to be
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISDIR", FS_ISDIR, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} S_ISDIR (@var{mode})\n\
 Return true if @var{mode} corresponds to a directory.\n\
 \n\
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
@@ -1064,17 +1065,17 @@ The value of @var{mode} is assumed to be
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISCHR", FS_ISCHR, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} S_ISCHR (@var{mode})\n\
 Return true if @var{mode} corresponds to a character device.\n\
 \n\
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
@@ -1090,17 +1091,17 @@ The value of @var{mode} is assumed to be
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISBLK", FS_ISBLK, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} S_ISBLK (@var{mode})\n\
 Return true if @var{mode} corresponds to a block device.\n\
 \n\
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
@@ -1116,17 +1117,17 @@ The value of @var{mode} is assumed to be
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISFIFO", FS_ISFIFO, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} S_ISFIFO (@var{mode})\n\
 Return true if @var{mode} corresponds to a fifo.\n\
 \n\
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
@@ -1142,17 +1143,17 @@ The value of @var{mode} is assumed to be
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISLNK", FS_ISLNK, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} S_ISLNK (@var{mode})\n\
 Return true if @var{mode} corresponds to a symbolic link.\n\
 \n\
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
@@ -1168,17 +1169,17 @@ The value of @var{mode} is assumed to be
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISSOCK", FS_ISSOCK, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} S_ISSOCK (@var{mode})\n\
 Return true if @var{mode} corresponds to a socket.\n\
 \n\
 The value of @var{mode} is assumed to be returned from a call to @code{stat}.\n\
 @seealso{stat, lstat}\n\
 @end deftypefn")
 {
   octave_value retval = false;
@@ -1194,33 +1195,33 @@ The value of @var{mode} is assumed to be
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (gethostname, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} gethostname ()\n\
 Return the hostname of the system where Octave is running.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 0)
     retval = octave_env::get_host_name ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (uname, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{uts}, @var{err}, @var{msg}] =} uname ()\n\
 Return system information in the structure.  For example:\n\
 \n\
 @example\n\
 @group\n\
 uname ()\n\
    @result{} @{\n\
          sysname = x86_64\n\
@@ -1257,17 +1258,17 @@ system-dependent error message.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("unlink", Funlink, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} unlink (@var{file})\n\
 Delete the file named @var{file}.\n\
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
 system-dependent error message.\n\
 @end deftypefn")
 {
@@ -1296,17 +1297,17 @@ system-dependent error message.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("waitpid", Fwaitpid, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{pid}, @var{status}, @var{msg}] =} waitpid (@var{pid}, @var{options})\n\
 Wait for process @var{pid} to terminate.  The @var{pid} argument can be:\n\
 \n\
 @table @asis\n\
 @item @minus{}1\n\
 Wait for any child process.\n\
 \n\
 @item 0\n\
@@ -1365,17 +1366,18 @@ information about the subprocess that ex
             options = args(1).int_value (true);
 
           if (! error_state)
             {
               std::string msg;
 
               int status = 0;
 
-              pid_t result = octave_syscalls::waitpid (pid, &status, options, msg);
+              pid_t result = octave_syscalls::waitpid (pid, &status,
+                                                       options, msg);
 
               retval(2) = msg;
               retval(1) = status;
               retval(0) = result;
             }
           else
             error ("waitpid: OPTIONS must be an integer");
         }
@@ -1384,17 +1386,17 @@ information about the subprocess that ex
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("WIFEXITED", FWIFEXITED, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} WIFEXITED (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return true if the\n\
 child terminated normally.\n\
 @seealso{waitpid, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WCOREDUMP, WIFSTOPPED, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
@@ -1407,17 +1409,17 @@ child terminated normally.\n\
       else
         error ("WIFEXITED: STATUS must be an integer");
     }
 
   return retval;
 }
 
 DEFUNX ("WEXITSTATUS", FWEXITSTATUS, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} WEXITSTATUS (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return the exit\n\
 status of the child.  This function should only be employed if\n\
 @code{WIFEXITED} returned true.\n\
 @seealso{waitpid, WIFEXITED, WIFSIGNALED, WTERMSIG, WCOREDUMP, WIFSTOPPED, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
 {
   octave_value retval = 0;
@@ -1431,17 +1433,17 @@ status of the child.  This function shou
       else
         error ("WEXITSTATUS: STATUS must be an integer");
     }
 
   return retval;
 }
 
 DEFUNX ("WIFSIGNALED", FWIFSIGNALED, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} WIFSIGNALED (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return true if the\n\
 child process was terminated by a signal.\n\
 @seealso{waitpid, WIFEXITED, WEXITSTATUS, WTERMSIG, WCOREDUMP, WIFSTOPPED, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
@@ -1454,17 +1456,17 @@ child process was terminated by a signal
       else
         error ("WIFSIGNALED: STATUS must be an integer");
     }
 
   return retval;
 }
 
 DEFUNX ("WTERMSIG", FWTERMSIG, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} WTERMSIG (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return the number of\n\
 the signal that caused the child process to terminate.  This function\n\
 should only be employed if @code{WIFSIGNALED} returned true.\n\
 @seealso{waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WCOREDUMP, WIFSTOPPED, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
 {
   octave_value retval = 0;
@@ -1478,17 +1480,17 @@ should only be employed if @code{WIFSIGN
       else
         error ("WTERMSIG: STATUS must be an integer");
     }
 
   return retval;
 }
 
 DEFUNX ("WCOREDUMP", FWCOREDUMP, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} WCOREDUMP (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return true if the\n\
 child produced a core dump.  This function should only be employed if\n\
 @code{WIFSIGNALED} returned true.  The macro used to implement this\n\
 function is not specified in POSIX.1-2001 and is not available on some\n\
 Unix implementations (e.g., AIX, SunOS).\n\
 @seealso{waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WIFSTOPPED, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
@@ -1504,17 +1506,17 @@ Unix implementations (e.g., AIX, SunOS).
       else
         error ("WCOREDUMP: STATUS must be an integer");
     }
 
   return retval;
 }
 
 DEFUNX ("WIFSTOPPED", FWIFSTOPPED, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} WIFSTOPPED (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return true if the\n\
 child process was stopped by delivery of a signal; this is only\n\
 possible if the call was done using @code{WUNTRACED} or when the child\n\
 is being traced (see ptrace(2)).\n\
 @seealso{waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WCOREDUMP, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
 {
@@ -1529,17 +1531,17 @@ is being traced (see ptrace(2)).\n\
       else
         error ("WIFSTOPPED: STATUS must be an integer");
     }
 
   return retval;
 }
 
 DEFUNX ("WSTOPSIG", FWSTOPSIG, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} WSTOPSIG (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return the number of\n\
 the signal which caused the child to stop.  This function should only\n\
 be employed if @code{WIFSTOPPED} returned true.\n\
 @seealso{waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WCOREDUMP, WIFSTOPPED, WIFCONTINUED}\n\
 @end deftypefn")
 {
   octave_value retval = 0;
@@ -1553,17 +1555,17 @@ be employed if @code{WIFSTOPPED} returne
       else
         error ("WSTOPSIG: STATUS must be an integer");
     }
 
   return retval;
 }
 
 DEFUNX ("WIFCONTINUED", FWIFCONTINUED, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} WIFCONTINUED (@var{status})\n\
 Given @var{status} from a call to @code{waitpid}, return true if the\n\
 child process was resumed by delivery of @code{SIGCONT}.\n\
 @seealso{waitpid, WIFEXITED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WCOREDUMP, WIFSTOPPED, WSTOPSIG}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
@@ -1576,17 +1578,17 @@ child process was resumed by delivery of
       else
         error ("WIFCONTINUED: STATUS must be an integer");
     }
 
   return retval;
 }
 
 DEFUNX ("canonicalize_file_name", Fcanonicalize_file_name, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{cname}, @var{status}, @var{msg}] =} canonicalize_file_name (@var{fname})\n\
 Return the canonical name of file @var{fname}.  If the file does not exist\n\
 the empty string (\"\") is returned.\n\
 @seealso{make_absolute_filename, is_absolute_filename, is_rooted_relative_filename}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
@@ -1628,248 +1630,248 @@ const_value (const octave_value_list& ar
   return retval;
 }
 
 #if !defined (O_NONBLOCK) && defined (O_NDELAY)
 #define O_NONBLOCK O_NDELAY
 #endif
 
 DEFUNX ("F_DUPFD", FF_DUPFD, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_DUPFD ()\n\
 Return the numerical value to pass to @code{fcntl} to return a\n\
 duplicate file descriptor.\n\
 @seealso{fcntl, F_GETFD, F_GETFL, F_SETFD, F_SETFL}\n\
 @end deftypefn")
 {
 #if defined (F_DUPFD)
   return const_value (args, F_DUPFD);
 #else
   error ("F_DUPFD: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("F_GETFD", FF_GETFD, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_GETFD ()\n\
 Return the numerical value to pass to @code{fcntl} to return the\n\
 file descriptor flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFL, F_SETFD, F_SETFL}\n\
 @end deftypefn")
 {
 #if defined (F_GETFD)
   return const_value (args, F_GETFD);
 #else
   error ("F_GETFD: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("F_GETFL", FF_GETFL, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_GETFL ()\n\
 Return the numerical value to pass to @code{fcntl} to return the\n\
 file status flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFD, F_SETFD, F_SETFL}\n\
 @end deftypefn")
 {
 #if defined (F_GETFL)
   return const_value (args, F_GETFL);
 #else
   error ("F_GETFL: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("F_SETFD", FF_SETFD, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_SETFD ()\n\
 Return the numerical value to pass to @code{fcntl} to set the file\n\
 descriptor flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFD, F_GETFL, F_SETFL}\n\
 @end deftypefn")
 {
 #if defined (F_SETFD)
   return const_value (args, F_SETFD);
 #else
   error ("F_SETFD: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("F_SETFL", FF_SETFL, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} F_SETFL ()\n\
 Return the numerical value to pass to @code{fcntl} to set the file\n\
 status flags.\n\
 @seealso{fcntl, F_DUPFD, F_GETFD, F_GETFL, F_SETFD}\n\
 @end deftypefn")
 {
 #if defined (F_SETFL)
   return const_value (args, F_SETFL);
 #else
   error ("F_SETFL: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("O_APPEND", FO_APPEND, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_APPEND ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate each write operation appends,\n\
 or that may be passed to @code{fcntl} to set the write mode to append.\n\
 @seealso{fcntl, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_APPEND)
   return const_value (args, O_APPEND);
 #else
   error ("O_APPEND: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("O_ASYNC", FO_ASYNC, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_ASYNC ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate asynchronous I/O.\n\
 @seealso{fcntl, O_APPEND, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_ASYNC)
   return const_value (args, O_ASYNC);
 #else
   error ("O_ASYNC: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("O_CREAT", FO_CREAT, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_CREAT ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file should be\n\
 created if it does not exist.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_CREAT)
   return const_value (args, O_CREAT);
 #else
   error ("O_CREAT: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("O_EXCL", FO_EXCL, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_EXCL ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that file locking is used.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_EXCL)
   return const_value (args, O_EXCL);
 #else
   error ("O_EXCL: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("O_NONBLOCK", FO_NONBLOCK, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_NONBLOCK ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that non-blocking I/O is in use,\n\
 or that may be passsed to @code{fcntl} to set non-blocking I/O.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_NONBLOCK)
   return const_value (args, O_NONBLOCK);
 #else
   error ("O_NONBLOCK: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("O_RDONLY", FO_RDONLY, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_RDONLY ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for\n\
 reading only.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDWR, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_RDONLY)
   return const_value (args, O_RDONLY);
 #else
   error ("O_RDONLY: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("O_RDWR", FO_RDWR, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_RDWR ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for both\n\
 reading and writing.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_SYNC, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_RDWR)
   return const_value (args, O_RDWR);
 #else
   error ("O_RDWR: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("O_SYNC", FO_SYNC, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_SYNC ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for\n\
 synchronous I/O.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_TRUNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_SYNC)
   return const_value (args, O_SYNC);
 #else
   error ("O_SYNC: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("O_TRUNC", FO_TRUNC, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} O_TRUNC ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that if file exists, it should\n\
 be truncated when writing.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_WRONLY}\n\
 @end deftypefn")
 {
 #if defined (O_TRUNC)
   return const_value (args, O_TRUNC);
 #else
   error ("O_TRUNC: not available on this system");
   return octave_value ();
 #endif
 }
 
 DEFUNX ("O_WRONLY", FO_WRONLY, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} O_WRONLY ()\n\
 Return the numerical value of the file status flag that may be\n\
 returned by @code{fcntl} to indicate that a file is open for\n\
 writing only.\n\
 @seealso{fcntl, O_APPEND, O_ASYNC, O_CREAT, O_EXCL, O_NONBLOCK, O_RDONLY, O_RDWR, O_SYNC, O_TRUNC}\n\
 @end deftypefn")
 {
 #if defined (O_WRONLY)
@@ -1880,50 +1882,50 @@ writing only.\n\
 #endif
 }
 
 #if !defined (WNOHANG)
 #define WNOHANG 0
 #endif
 
 DEFUNX ("WNOHANG", FWNOHANG, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} WNOHANG ()\n\
 Return the numerical value of the option argument that may be\n\
 passed to @code{waitpid} to indicate that it should return its\n\
 status immediately instead of waiting for a process to exit.\n\
 @seealso{waitpid, WUNTRACED, WCONTINUE}\n\
 @end deftypefn")
 {
   return const_value (args, WNOHANG);
 }
 
 #if !defined (WUNTRACED)
 #define WUNTRACED 0
 #endif
 
 DEFUNX ("WUNTRACED", FWUNTRACED, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} WUNTRACED ()\n\
 Return the numerical value of the option argument that may be\n\
 passed to @code{waitpid} to indicate that it should also return\n\
 if the child process has stopped but is not traced via the\n\
 @code{ptrace} system call\n\
 @seealso{waitpid, WNOHANG, WCONTINUE}\n\
 @end deftypefn")
 {
   return const_value (args, WUNTRACED);
 }
 
 #if !defined (WCONTINUE)
 #define WCONTINUE 0
 #endif
 
 DEFUNX ("WCONTINUE", FWCONTINUE, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} WCONTINUE ()\n\
 Return the numerical value of the option argument that may be\n\
 passed to @code{waitpid} to indicate that it should also return\n\
 if a stopped child has been resumed by delivery of a @code{SIGCONT}\n\
 signal.\n\
 @seealso{waitpid, WNOHANG, WUNTRACED}\n\
 @end deftypefn")
 {
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -134,17 +134,17 @@ w32_set_octave_home (void)
                 {
                   bin_dir = mod_info.szExePath;
                   if (bin_dir[bin_dir.length () - 1] != '\\')
                     bin_dir.append (1, '\\');
                   break;
                 }
             }
           while (Module32Next (h, &mod_info));
-       }
+        }
 
       CloseHandle (h);
     }
 
   if (! bin_dir.empty ())
     {
       size_t pos = bin_dir.rfind ("\\bin\\");
 
@@ -154,17 +154,17 @@ w32_set_octave_home (void)
 }
 
 void
 w32_set_quiet_shutdown (void)
 {
   // Let the user close the console window or shutdown without the
   // pesky dialog.
   //
-  // FIXME -- should this be user configurable?
+  // FIXME: should this be user configurable?
   SetProcessShutdownParameters (0x280, SHUTDOWN_NORETRY);
 }
 
 void
 MINGW_signal_cleanup (void)
 {
   w32_set_quiet_shutdown ();
 }
@@ -523,33 +523,33 @@ get_P_tmpdir (void)
 #else
 
   return "/tmp";
 
 #endif
 }
 
 DEFUN (clc, , ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} clc ()\n\
 @deftypefnx {Built-in Function} {} home ()\n\
 Clear the terminal screen and move the cursor to the upper left corner.\n\
 @end deftypefn")
 {
   bool skip_redisplay = true;
 
   command_editor::clear_screen (skip_redisplay);
 
   return octave_value_list ();
 }
 
 DEFALIAS (home, clc);
 
 DEFUN (getenv, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} getenv (@var{var})\n\
 Return the value of the environment variable @var{var}.  For example,\n\
 \n\
 @example\n\
 getenv (\"PATH\")\n\
 @end example\n\
 \n\
 @noindent\n\
@@ -569,17 +569,17 @@ returns a string containing the value of
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (putenv, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} putenv (@var{var}, @var{value})\n\
 @deftypefnx {Built-in Function} {} setenv (@var{var}, @var{value})\n\
 Set the value of the environment variable @var{var} to @var{value}.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
@@ -611,20 +611,20 @@ DEFALIAS (setenv, putenv);
 
 /*
 %!assert (ischar (getenv ("OCTAVE_HOME")))
 %!test
 %! setenv ("dummy_variable_that_cannot_matter", "foobar");
 %! assert (getenv ("dummy_variable_that_cannot_matter"), "foobar");
 */
 
-// FIXME -- perhaps kbhit should also be able to print a prompt?
+// FIXME: perhaps kbhit should also be able to print a prompt?
 
 DEFUN (kbhit, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} kbhit ()\n\
 @deftypefnx {Built-in Function} {} kbhit (1)\n\
 Read a single keystroke from the keyboard.  If called with an\n\
 argument, don't wait for a keypress.  For example,\n\
 \n\
 @example\n\
 x = kbhit ();\n\
 @end example\n\
@@ -640,17 +640,17 @@ x = kbhit (1);\n\
 @noindent\n\
 is identical to the above example, but doesn't wait for a keypress,\n\
 returning the empty string if no key is available.\n\
 @seealso{input}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  // FIXME -- add timeout and default value args?
+  // FIXME: add timeout and default value args?
 
   if (interactive || forced_interactive)
     {
       Fdrawnow ();
 
       int c = octave_kbhit (args.length () == 0);
 
       if (c == -1)
@@ -660,17 +660,17 @@ returning the empty string if no key is 
 
       retval = s;
     }
 
   return retval;
 }
 
 DEFUN (pause, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} pause (@var{seconds})\n\
 Suspend the execution of the program.  If invoked without any arguments,\n\
 Octave waits until you type a character.  With a numeric argument, it\n\
 pauses for the given number of seconds.  For example, the following\n\
 statement prints a message and then waits 5 seconds before clearing the\n\
 screen.\n\
 \n\
 @example\n\
@@ -727,17 +727,17 @@ clc;\n\
 /*
 %!test
 %! pause (1);
 
 %!error (pause (1, 2))
 */
 
 DEFUN (sleep, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} sleep (@var{seconds})\n\
 Suspend the execution of the program for the given number of seconds.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
@@ -764,17 +764,17 @@ Suspend the execution of the program for
 %!test
 %! sleep (1);
 
 %!error (sleep ())
 %!error (sleep (1, 2))
 */
 
 DEFUN (usleep, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} usleep (@var{microseconds})\n\
 Suspend the execution of the program for the given number of\n\
 microseconds.  On systems where it is not possible to sleep for periods\n\
 of time less than one second, @code{usleep} will pause the execution for\n\
 @code{round (@var{microseconds} / 1e6)} seconds.\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -807,53 +807,53 @@ of time less than one second, @code{usle
 /*
 %!test
 %! usleep (1000);
 
 %!error (usleep ())
 %!error (usleep (1, 2))
 */
 
-// FIXME -- maybe this should only return 1 if IEEE floating
+// FIXME: maybe this should only return 1 if IEEE floating
 // point functions really work.
 
 DEFUN (isieee, , ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isieee ()\n\
 Return true if your computer @emph{claims} to conform to the IEEE standard\n\
 for floating point calculations.  No actual tests are performed.\n\
 @end deftypefn")
 {
   oct_mach_info::float_format flt_fmt = oct_mach_info::native_float_format ();
 
   return octave_value (flt_fmt == oct_mach_info::flt_fmt_ieee_little_endian
                        || flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian);
 }
 
 /*
 %!assert (islogical (isieee ()))
 */
 
 DEFUN (native_float_format, , ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} native_float_format ()\n\
 Return the native floating point format as a string\n\
 @end deftypefn")
 {
   oct_mach_info::float_format flt_fmt = oct_mach_info::native_float_format ();
 
   return octave_value (oct_mach_info::float_format_as_string (flt_fmt));
 }
 
 /*
 %!assert (ischar (native_float_format ()))
 */
 
 DEFUN (tilde_expand, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} tilde_expand (@var{string})\n\
 Perform tilde expansion on @var{string}.  If @var{string} begins with a\n\
 tilde character, (@samp{~}), all of the characters preceding the first\n\
 slash (or all characters, if there is no slash) are treated as a\n\
 possible user name, and the tilde and the following characters up to the\n\
 slash are replaced by the home directory of the named user.  If the\n\
 tilde is followed immediately by a slash, the tilde is replaced by the\n\
 home directory of the user running Octave.  For example:\n\
diff --git a/libinterp/corefcn/sysdep.h b/libinterp/corefcn/sysdep.h
--- a/libinterp/corefcn/sysdep.h
+++ b/libinterp/corefcn/sysdep.h
@@ -47,11 +47,12 @@ extern void w32_set_quiet_shutdown (void
 
 #if defined (__WIN32__) && ! defined (_POSIX_VERSION)
 extern void MINGW_signal_cleanup (void);
 #define MINGW_SIGNAL_CLEANUP() MINGW_signal_cleanup ()
 #else
 #define MINGW_SIGNAL_CLEANUP() do { } while (0)
 #endif
 
-extern OCTINTERP_API bool same_file_internal (const std::string&, const std::string&);
+extern OCTINTERP_API bool same_file_internal (const std::string&,
+                                              const std::string&);
 
 #endif
diff --git a/libinterp/corefcn/time.cc b/libinterp/corefcn/time.cc
--- a/libinterp/corefcn/time.cc
+++ b/libinterp/corefcn/time.cc
@@ -97,17 +97,17 @@ extract_tm (const octave_scalar_map& m)
   tm.yday (intfield (m, "yday"));
   tm.isdst (intfield (m, "isdst"));
   tm.zone (stringfield (m, "zone"));
 
   return tm;
 }
 
 DEFUN (time, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{seconds} =} time ()\n\
 Return the current time as the number of seconds since the epoch.  The\n\
 epoch is referenced to 00:00:00 CUT (Coordinated Universal Time) 1 Jan\n\
 1970.  For example, on Monday February 17, 1997 at 07:15:06 CUT, the\n\
 value returned by @code{time} was 856163706.\n\
 @seealso{strftime, strptime, localtime, gmtime, mktime, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
@@ -121,17 +121,17 @@ value returned by @code{time} was 856163
   return retval;
 }
 
 /*
 %!assert (time () > 0)
 */
 
 DEFUN (gmtime, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{tm_struct} =} gmtime (@var{t})\n\
 Given a value returned from @code{time}, or any non-negative integer,\n\
 return a time structure corresponding to CUT (Coordinated Universal Time).\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 gmtime (time ())\n\
@@ -183,17 +183,17 @@ gmtime (time ())\n\
 %! assert (isfield (ts, "isdst"));
 %! assert (isfield (ts, "yday"));
 
 %!error gmtime ()
 %!error gmtime (1, 2)
 */
 
 DEFUN (localtime, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{tm_struct} =} localtime (@var{t})\n\
 Given a value returned from @code{time}, or any non-negative integer,\n\
 return a time structure corresponding to the local time zone.\n\
 \n\
 @example\n\
 @group\n\
 localtime (time ())\n\
      @result{} @{\n\
@@ -244,17 +244,17 @@ localtime (time ())\n\
 %! assert (isfield (ts, "isdst"));
 %! assert (isfield (ts, "yday"));
 
 %!error localtime ()
 %!error localtime (1, 2)
 */
 
 DEFUN (mktime, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{seconds} =} mktime (@var{tm_struct})\n\
 Convert a time structure corresponding to the local time to the number\n\
 of seconds since the epoch.  For example:\n\
 \n\
 @example\n\
 @group\n\
 mktime (localtime (time ()))\n\
      @result{} 856163706\n\
@@ -298,17 +298,17 @@ mktime (localtime (time ()))\n\
 %!assert (datestr (datenum (1901, 1, 1), 0), "01-Jan-1901 00:00:00")
 %!assert (datestr (datenum (1795, 1, 1), 0), "01-Jan-1795 00:00:00")
 
 %!error mktime ()
 %!error mktime (1, 2, 3)
 */
 
 DEFUN (strftime, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} strftime (@var{fmt}, @var{tm_struct})\n\
 Format the time structure @var{tm_struct} in a flexible way using the\n\
 format string @var{fmt} that contains @samp{%} substitutions\n\
 similar to those in @code{printf}.  Except where noted, substituted\n\
 fields have a fixed size; numeric fields are padded if necessary.\n\
 Padding is with zeros by default; for fields that display a single\n\
 number, padding can be changed or inhibited by following the @samp{%}\n\
 with one of the modifiers described below.  Unknown field specifiers are\n\
@@ -493,17 +493,17 @@ Year (1970-).\n\
 %!assert (ischar (strftime ("%c%C%d%e%D%h%j", localtime (time ()))));
 %!assert (ischar (strftime ("%m%U%w%W%x%y%Y", localtime (time ()))));
 
 %!error strftime ()
 %!error strftime ("foo", localtime (time ()), 1)
 */
 
 DEFUN (strptime, args, ,
- "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{tm_struct}, @var{nchars}] =} strptime (@var{str}, @var{fmt})\n\
 Convert the string @var{str} to the time structure @var{tm_struct} under\n\
 the control of the format string @var{fmt}.\n\
 \n\
 If @var{fmt} fails to match, @var{nchars} is 0; otherwise, it is set to the\n\
 position of last matched character plus 1. Always check for this unless\n\
 you're absolutely sure the date string will be parsed correctly.\n\
 @seealso{strftime, localtime, gmtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -193,17 +193,18 @@ octave_call_stack::do_caller_user_code_c
             }
         }
     }
 
   return retval;
 }
 
 size_t
-octave_call_stack::do_num_user_code_frames (octave_idx_type& curr_user_frame) const
+octave_call_stack::do_num_user_code_frames
+  (octave_idx_type& curr_user_frame) const
 {
   size_t retval = 0;
 
   curr_user_frame = 0;
 
   // Look for the caller of dbstack.
   size_t frame = cs[curr_frame].prev;
 
@@ -260,17 +261,18 @@ octave_call_stack::do_caller_user_code (
     }
 
   return retval;
 }
 
 // Use static fields for the best efficiency.
 // NOTE: C++0x will allow these two to be merged into one.
 static const char *bt_fieldnames[] = { "file", "name", "line",
-    "column", "scope", "context", 0 };
+                                       "column", "scope", "context", 0
+                                     };
 static const octave_fields bt_fields (bt_fieldnames);
 
 octave_map
 octave_call_stack::empty_backtrace (void)
 {
   return octave_map (dim_vector (0, 1), bt_fields);
 }
 
@@ -609,26 +611,24 @@ main_loop (void)
           recover_from_exception ();
           octave_stdout << "\n";
           if (quitting_gracefully)
             return exit_status;
         }
       catch (octave_execution_exception)
         {
           recover_from_exception ();
-          std::cerr
-            << "error: unhandled execution exception -- trying to return to prompt"
-            << std::endl;
+          std::cerr << "error: unhandled execution exception -- trying to return to prompt"
+                    << std::endl;
         }
       catch (std::bad_alloc)
         {
           recover_from_exception ();
-          std::cerr
-            << "error: out of memory -- trying to return to prompt"
-            << std::endl;
+          std::cerr << "error: out of memory -- trying to return to prompt"
+                    << std::endl;
         }
     }
   while (retval == 0);
 
   if (retval == EOF)
     retval = 0;
 
   return retval;
@@ -669,17 +669,17 @@ do_octave_atexit (void)
 
       // Do this explicitly so that destructors for mex file objects
       // are called, so that functions registered with mexAtExit are
       // called.
       OCTAVE_SAFE_CALL (clear_mex_functions, ());
 
       OCTAVE_SAFE_CALL (command_editor::restore_terminal_state, ());
 
-      // FIXME -- is this needed?  Can it cause any trouble?
+      // FIXME: is this needed?  Can it cause any trouble?
       OCTAVE_SAFE_CALL (raw_mode, (0));
 
       OCTAVE_SAFE_CALL (octave_history_write_timestamp, ());
 
       if (! command_history::ignoring_entries ())
         OCTAVE_SAFE_CALL (command_history::clean_up_and_save, ());
 
       OCTAVE_SAFE_CALL (gh_manager::close_all_figures, ());
@@ -750,17 +750,17 @@ clean_up_and_exit (int retval, bool safe
   else
     {
       if (octave_exit)
         (*octave_exit) (retval);
     }
 }
 
 DEFUN (quit, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} exit (@var{status})\n\
 @deftypefnx {Built-in Function} {} quit (@var{status})\n\
 Exit the current Octave session.  If the optional integer value\n\
 @var{status} is supplied, pass that value to the operating system as the\n\
 Octave's exit status.  The default value is zero.\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -794,17 +794,17 @@ Octave's exit status.  The default value
     }
 
   return retval;
 }
 
 DEFALIAS (exit, quit);
 
 DEFUN (warranty, , ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} warranty ()\n\
 Describe the conditions for copying and distributing Octave.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   octave_stdout << "\n" << octave_name_version_and_copyright () << "\n\
 \n\
@@ -900,17 +900,17 @@ run_command_and_return_output (const std
     error ("unable to start subprocess for '%s'", cmd_str.c_str ());
 
   return retval;
 }
 
 enum system_exec_type { et_sync, et_async };
 
 DEFUN (system, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} system (\"@var{string}\")\n\
 @deftypefnx {Built-in Function} {} system (\"@var{string}\", @var{return_output})\n\
 @deftypefnx {Built-in Function} {} system (\"@var{string}\", @var{return_output}, @var{type})\n\
 @deftypefnx {Built-in Function} {[@var{status}, @var{output}] =} system (@dots{})\n\
 Execute a shell command specified by @var{string}.\n\
 If the optional argument @var{type} is @qcode{\"async\"}, the process\n\
 is started in the background and the process ID of the child process\n\
 is returned immediately.  Otherwise, the child process is started and\n\
@@ -1014,25 +1014,25 @@ command shell that is started to run the
 #if defined (__WIN32__) && ! defined (__CYGWIN__)
           // Work around weird double-quote handling on Windows systems.
           if (type == et_sync)
             cmd_str = "\"" + cmd_str + "\"";
 #endif
 
           if (type == et_async)
             {
-              // FIXME -- maybe this should go in sysdep.cc?
+              // FIXME: maybe this should go in sysdep.cc?
 #ifdef HAVE_FORK
               pid_t pid = fork ();
 
               if (pid < 0)
                 error ("system: fork failed -- can't create child process");
               else if (pid == 0)
                 {
-                  // FIXME -- should probably replace this
+                  // FIXME: should probably replace this
                   // call with something portable.
 
                   execl (SHELL_PATH, "sh", "-c", cmd_str.c_str (),
                          static_cast<void *> (0));
 
                   panic_impossible ();
                 }
               else
@@ -1117,17 +1117,17 @@ octave_remove_atexit_function (const std
         }
     }
 
   return found;
 }
 
 
 DEFUN (atexit, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} atexit (@var{fcn})\n\
 @deftypefnx {Built-in Function} {} atexit (@var{fcn}, @var{flag})\n\
 Register a function to be called when Octave exits.  For example,\n\
 \n\
 @example\n\
 @group\n\
 function last_words ()\n\
   disp (\"Bye bye\");\n\
@@ -1197,17 +1197,17 @@ multiple times.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (octave_config_info, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} octave_config_info ()\n\
 @deftypefnx {Built-in Function} {} octave_config_info (@var{option})\n\
 Return a structure containing configuration and installation\n\
 information for Octave.\n\
 \n\
 If @var{option} is a string, return the configuration information for the\n\
 specified option.\n\
 \n\
@@ -1227,196 +1227,196 @@ specified option.\n\
   struct conf_info_struct
   {
     bool subst_home;
     const char *key;
     const char *val;
   };
 
   static const conf_info_struct conf_info[] =
-    {
-      { false, "ALL_CFLAGS", OCTAVE_CONF_ALL_CFLAGS },
-      { false, "ALL_CXXFLAGS", OCTAVE_CONF_ALL_CXXFLAGS },
-      { false, "ALL_FFLAGS", OCTAVE_CONF_ALL_FFLAGS },
-      { false, "ALL_LDFLAGS", OCTAVE_CONF_ALL_LDFLAGS },
-      { false, "AMD_CPPFLAGS", OCTAVE_CONF_AMD_CPPFLAGS },
-      { false, "AMD_LDFLAGS", OCTAVE_CONF_AMD_LDFLAGS },
-      { false, "AMD_LIBS", OCTAVE_CONF_AMD_LIBS },
-      { false, "AR", OCTAVE_CONF_AR },
-      { false, "ARFLAGS", OCTAVE_CONF_ARFLAGS },
-      { false, "ARPACK_CPPFLAGS", OCTAVE_CONF_ARPACK_CPPFLAGS },
-      { false, "ARPACK_LDFLAGS", OCTAVE_CONF_ARPACK_LDFLAGS },
-      { false, "ARPACK_LIBS", OCTAVE_CONF_ARPACK_LIBS },
-      { false, "BLAS_LIBS", OCTAVE_CONF_BLAS_LIBS },
-      { false, "CAMD_CPPFLAGS", OCTAVE_CONF_CAMD_CPPFLAGS },
-      { false, "CAMD_LDFLAGS", OCTAVE_CONF_CAMD_LDFLAGS },
-      { false, "CAMD_LIBS", OCTAVE_CONF_CAMD_LIBS },
-      { false, "CARBON_LIBS", OCTAVE_CONF_CARBON_LIBS },
-      { false, "CC", OCTAVE_CONF_CC },
-      // FIXME: CC_VERSION is deprecated.  Remove in version 3.12
-      { false, "CC_VERSION", OCTAVE_CONF_CC_VERSION },
-      { false, "CCOLAMD_CPPFLAGS", OCTAVE_CONF_CCOLAMD_CPPFLAGS },
-      { false, "CCOLAMD_LDFLAGS", OCTAVE_CONF_CCOLAMD_LDFLAGS },
-      { false, "CCOLAMD_LIBS", OCTAVE_CONF_CCOLAMD_LIBS },
-      { false, "CFLAGS", OCTAVE_CONF_CFLAGS },
-      { false, "CHOLMOD_CPPFLAGS", OCTAVE_CONF_CHOLMOD_CPPFLAGS },
-      { false, "CHOLMOD_LDFLAGS", OCTAVE_CONF_CHOLMOD_LDFLAGS },
-      { false, "CHOLMOD_LIBS", OCTAVE_CONF_CHOLMOD_LIBS },
-      { false, "COLAMD_CPPFLAGS", OCTAVE_CONF_COLAMD_CPPFLAGS },
-      { false, "COLAMD_LDFLAGS", OCTAVE_CONF_COLAMD_LDFLAGS },
-      { false, "COLAMD_LIBS", OCTAVE_CONF_COLAMD_LIBS },
-      { false, "CPICFLAG", OCTAVE_CONF_CPICFLAG },
-      { false, "CPPFLAGS", OCTAVE_CONF_CPPFLAGS },
-      { false, "CURL_CPPFLAGS", OCTAVE_CONF_CURL_CPPFLAGS },
-      { false, "CURL_LDFLAGS", OCTAVE_CONF_CURL_LDFLAGS },
-      { false, "CURL_LIBS", OCTAVE_CONF_CURL_LIBS },
-      { false, "CXSPARSE_CPPFLAGS", OCTAVE_CONF_CXSPARSE_CPPFLAGS },
-      { false, "CXSPARSE_LDFLAGS", OCTAVE_CONF_CXSPARSE_LDFLAGS },
-      { false, "CXSPARSE_LIBS", OCTAVE_CONF_CXSPARSE_LIBS },
-      { false, "CXX", OCTAVE_CONF_CXX },
-      { false, "CXXCPP", OCTAVE_CONF_CXXCPP },
-      { false, "CXXFLAGS", OCTAVE_CONF_CXXFLAGS },
-      { false, "CXXPICFLAG", OCTAVE_CONF_CXXPICFLAG },
-      // FIXME: CXX_VERSION is deprecated.  Remove in version 3.12
-      { false, "CXX_VERSION", OCTAVE_CONF_CXX_VERSION },
-      { false, "DEFAULT_PAGER", OCTAVE_DEFAULT_PAGER },
-      { false, "DEFS", OCTAVE_CONF_DEFS },
-      { false, "DL_LD", OCTAVE_CONF_DL_LD },
-      { false, "DL_LDFLAGS", OCTAVE_CONF_DL_LDFLAGS },
-      { false, "DL_LIBS", OCTAVE_CONF_DL_LIBS },
-      { false, "GCC_VERSION", OCTAVE_CONF_GCC_VERSION },
-      { false, "GXX_VERSION", OCTAVE_CONF_GXX_VERSION },
-      { false, "ENABLE_DYNAMIC_LINKING", OCTAVE_CONF_ENABLE_DYNAMIC_LINKING },
-      { false, "EXEEXT", OCTAVE_CONF_EXEEXT },
-      { false, "F77", OCTAVE_CONF_F77 },
-      { false, "F77_FLOAT_STORE_FLAG", OCTAVE_CONF_F77_FLOAT_STORE_FLAG },
-      { false, "F77_INTEGER_8_FLAG", OCTAVE_CONF_F77_INTEGER_8_FLAG },
-      { false, "FC", OCTAVE_CONF_FC },
-      { false, "FFLAGS", OCTAVE_CONF_FFLAGS },
-      { false, "FFTW3_CPPFLAGS", OCTAVE_CONF_FFTW3_CPPFLAGS },
-      { false, "FFTW3_LDFLAGS", OCTAVE_CONF_FFTW3_LDFLAGS },
-      { false, "FFTW3_LIBS", OCTAVE_CONF_FFTW3_LIBS },
-      { false, "FFTW3F_CPPFLAGS", OCTAVE_CONF_FFTW3F_CPPFLAGS },
-      { false, "FFTW3F_LDFLAGS", OCTAVE_CONF_FFTW3F_LDFLAGS },
-      { false, "FFTW3F_LIBS", OCTAVE_CONF_FFTW3F_LIBS },
-      { false, "FLIBS", OCTAVE_CONF_FLIBS },
-      { false, "FPICFLAG", OCTAVE_CONF_FPICFLAG },
-      { false, "FT2_CFLAGS", OCTAVE_CONF_FT2_CFLAGS },
-      { false, "FT2_LIBS", OCTAVE_CONF_FT2_LIBS },
-      { false, "GLPK_CPPFLAGS", OCTAVE_CONF_GLPK_CPPFLAGS },
-      { false, "GLPK_LDFLAGS", OCTAVE_CONF_GLPK_LDFLAGS },
-      { false, "GLPK_LIBS", OCTAVE_CONF_GLPK_LIBS },
-      { false, "GNUPLOT", OCTAVE_CONF_GNUPLOT },
-      { false, "GRAPHICS_CFLAGS", OCTAVE_CONF_GRAPHICS_CFLAGS },
-      { false, "GRAPHICS_LIBS", OCTAVE_CONF_GRAPHICS_LIBS },
-      { false, "HDF5_CPPFLAGS", OCTAVE_CONF_HDF5_CPPFLAGS },
-      { false, "HDF5_LDFLAGS", OCTAVE_CONF_HDF5_LDFLAGS },
-      { false, "HDF5_LIBS", OCTAVE_CONF_HDF5_LIBS },
-      { false, "LAPACK_LIBS", OCTAVE_CONF_LAPACK_LIBS },
-      { false, "LDFLAGS", OCTAVE_CONF_LDFLAGS },
-      { false, "LD_CXX", OCTAVE_CONF_LD_CXX },
-      { false, "LD_STATIC_FLAG", OCTAVE_CONF_LD_STATIC_FLAG },
-      { false, "LEX", OCTAVE_CONF_LEX },
-      { false, "LEXLIB", OCTAVE_CONF_LEXLIB },
-      { false, "LFLAGS", OCTAVE_CONF_LFLAGS },
-      { false, "LIBEXT", OCTAVE_CONF_LIBEXT },
-      { false, "LIBFLAGS", OCTAVE_CONF_LIBFLAGS },
-      { false, "LIBOCTAVE", OCTAVE_CONF_LIBOCTAVE },
-      { false, "LIBOCTINTERP", OCTAVE_CONF_LIBOCTINTERP },
-      { false, "LIBS", OCTAVE_CONF_LIBS },
-      { false, "LLVM_CPPFLAGS", OCTAVE_CONF_LLVM_CPPFLAGS },
-      { false, "LLVM_LDFLAGS", OCTAVE_CONF_LLVM_LDFLAGS },
-      { false, "LLVM_LIBS", OCTAVE_CONF_LLVM_LIBS },
-      { false, "LN_S", OCTAVE_CONF_LN_S },
-      { false, "MAGICK_CPPFLAGS", OCTAVE_CONF_MAGICK_CPPFLAGS },
-      { false, "MAGICK_LDFLAGS", OCTAVE_CONF_MAGICK_LDFLAGS },
-      { false, "MAGICK_LIBS", OCTAVE_CONF_MAGICK_LIBS },
-      { false, "MKOCTFILE_DL_LDFLAGS", OCTAVE_CONF_MKOCTFILE_DL_LDFLAGS },
-      { false, "OCTAVE_LINK_DEPS", OCTAVE_CONF_OCTAVE_LINK_DEPS },
-      { false, "OCTAVE_LINK_OPTS", OCTAVE_CONF_OCTAVE_LINK_OPTS },
-      { false, "OCT_LINK_DEPS", OCTAVE_CONF_OCT_LINK_DEPS },
-      { false, "OCT_LINK_OPTS", OCTAVE_CONF_OCT_LINK_OPTS },
-      { false, "OPENGL_LIBS", OCTAVE_CONF_OPENGL_LIBS },
-      { false, "PTHREAD_CFLAGS", OCTAVE_CONF_PTHREAD_CFLAGS },
-      { false, "PTHREAD_LIBS", OCTAVE_CONF_PTHREAD_LIBS },
-      { false, "QHULL_CPPFLAGS", OCTAVE_CONF_QHULL_CPPFLAGS },
-      { false, "QHULL_LDFLAGS", OCTAVE_CONF_QHULL_LDFLAGS },
-      { false, "QHULL_LIBS", OCTAVE_CONF_QHULL_LIBS },
-      { false, "QRUPDATE_CPPFLAGS", OCTAVE_CONF_QRUPDATE_CPPFLAGS },
-      { false, "QRUPDATE_LDFLAGS", OCTAVE_CONF_QRUPDATE_LDFLAGS },
-      { false, "QRUPDATE_LIBS", OCTAVE_CONF_QRUPDATE_LIBS },
-      { false, "QT_CPPFLAGS", OCTAVE_CONF_QT_CPPFLAGS },
-      { false, "QT_LDFLAGS", OCTAVE_CONF_QT_LDFLAGS },
-      { false, "QT_LIBS", OCTAVE_CONF_QT_LIBS },
-      { false, "RANLIB", OCTAVE_CONF_RANLIB },
-      { false, "RDYNAMIC_FLAG", OCTAVE_CONF_RDYNAMIC_FLAG },
-      { false, "READLINE_LIBS", OCTAVE_CONF_READLINE_LIBS },
-      { false, "REGEX_LIBS", OCTAVE_CONF_REGEX_LIBS },
-      { false, "SED", OCTAVE_CONF_SED },
-      { false, "SHARED_LIBS", OCTAVE_CONF_SHARED_LIBS },
-      { false, "SHLEXT", OCTAVE_CONF_SHLEXT },
-      { false, "SHLEXT_VER", OCTAVE_CONF_SHLEXT_VER },
-      { false, "SH_LD", OCTAVE_CONF_SH_LD },
-      { false, "SH_LDFLAGS", OCTAVE_CONF_SH_LDFLAGS },
-      { false, "SONAME_FLAGS", OCTAVE_CONF_SONAME_FLAGS },
-      { false, "STATIC_LIBS", OCTAVE_CONF_STATIC_LIBS },
-      { false, "TERM_LIBS", OCTAVE_CONF_TERM_LIBS },
-      { false, "UMFPACK_CPPFLAGS", OCTAVE_CONF_UMFPACK_CPPFLAGS },
-      { false, "UMFPACK_LDFLAGS", OCTAVE_CONF_UMFPACK_LDFLAGS },
-      { false, "UMFPACK_LIBS", OCTAVE_CONF_UMFPACK_LIBS },
-      { false, "USE_64_BIT_IDX_T", OCTAVE_CONF_USE_64_BIT_IDX_T },
-      { false, "WARN_CFLAGS", OCTAVE_CONF_WARN_CFLAGS },
-      { false, "WARN_CXXFLAGS", OCTAVE_CONF_WARN_CXXFLAGS },
-      { false, "X11_INCFLAGS", OCTAVE_CONF_X11_INCFLAGS },
-      { false, "X11_LIBS", OCTAVE_CONF_X11_LIBS },
-      { false, "XTRA_CFLAGS", OCTAVE_CONF_XTRA_CFLAGS },
-      { false, "XTRA_CXXFLAGS", OCTAVE_CONF_XTRA_CXXFLAGS },
-      { false, "YACC", OCTAVE_CONF_YACC },
-      { false, "YFLAGS", OCTAVE_CONF_YFLAGS },
-      { false, "Z_CPPFLAGS", OCTAVE_CONF_Z_CPPFLAGS },
-      { false, "Z_LDFLAGS", OCTAVE_CONF_Z_LDFLAGS },
-      { false, "Z_LIBS", OCTAVE_CONF_Z_LIBS },
-      { false, "api_version", OCTAVE_API_VERSION },
-      { true, "archlibdir", OCTAVE_ARCHLIBDIR },
-      { true, "bindir", OCTAVE_BINDIR },
-      { false, "canonical_host_type", OCTAVE_CANONICAL_HOST_TYPE },
-      { false, "config_opts", OCTAVE_CONF_config_opts },
-      { true, "datadir", OCTAVE_DATADIR },
-      { true, "datarootdir", OCTAVE_DATAROOTDIR },
-      { true, "exec_prefix", OCTAVE_EXEC_PREFIX },
-      { true, "fcnfiledir", OCTAVE_FCNFILEDIR },
-      { true, "imagedir", OCTAVE_IMAGEDIR },
-      { true, "includedir", OCTAVE_INCLUDEDIR },
-      { true, "infodir", OCTAVE_INFODIR },
-      { true, "infofile", OCTAVE_INFOFILE },
-      { true, "libdir", OCTAVE_LIBDIR },
-      { true, "libexecdir", OCTAVE_LIBEXECDIR },
-      { true, "localapiarchlibdir", OCTAVE_LOCALAPIARCHLIBDIR },
-      { true, "localapifcnfiledir", OCTAVE_LOCALAPIFCNFILEDIR },
-      { true, "localapioctfiledir", OCTAVE_LOCALAPIOCTFILEDIR },
-      { true, "localarchlibdir", OCTAVE_LOCALARCHLIBDIR },
-      { true, "localfcnfiledir", OCTAVE_LOCALFCNFILEDIR },
-      { true, "localoctfiledir", OCTAVE_LOCALOCTFILEDIR },
-      { true, "localstartupfiledir", OCTAVE_LOCALSTARTUPFILEDIR },
-      { true, "localverarchlibdir", OCTAVE_LOCALVERARCHLIBDIR },
-      { true, "localverfcnfiledir", OCTAVE_LOCALVERFCNFILEDIR },
-      { true, "localveroctfiledir", OCTAVE_LOCALVEROCTFILEDIR },
-      { true, "man1dir", OCTAVE_MAN1DIR },
-      { false, "man1ext", OCTAVE_MAN1EXT },
-      { true, "mandir", OCTAVE_MANDIR },
-      { true, "octfiledir", OCTAVE_OCTFILEDIR },
-      { true, "octetcdir", OCTAVE_OCTETCDIR },
-      { true, "octincludedir", OCTAVE_OCTINCLUDEDIR },
-      { true, "octlibdir", OCTAVE_OCTLIBDIR },
-      { true, "octtestsdir", OCTAVE_OCTTESTSDIR },
-      { true, "prefix", OCTAVE_PREFIX },
-      { true, "startupfiledir", OCTAVE_STARTUPFILEDIR },
-      { false, "version", OCTAVE_VERSION },
-      { false, 0, 0 }
-    };
+  {
+    { false, "ALL_CFLAGS", OCTAVE_CONF_ALL_CFLAGS },
+    { false, "ALL_CXXFLAGS", OCTAVE_CONF_ALL_CXXFLAGS },
+    { false, "ALL_FFLAGS", OCTAVE_CONF_ALL_FFLAGS },
+    { false, "ALL_LDFLAGS", OCTAVE_CONF_ALL_LDFLAGS },
+    { false, "AMD_CPPFLAGS", OCTAVE_CONF_AMD_CPPFLAGS },
+    { false, "AMD_LDFLAGS", OCTAVE_CONF_AMD_LDFLAGS },
+    { false, "AMD_LIBS", OCTAVE_CONF_AMD_LIBS },
+    { false, "AR", OCTAVE_CONF_AR },
+    { false, "ARFLAGS", OCTAVE_CONF_ARFLAGS },
+    { false, "ARPACK_CPPFLAGS", OCTAVE_CONF_ARPACK_CPPFLAGS },
+    { false, "ARPACK_LDFLAGS", OCTAVE_CONF_ARPACK_LDFLAGS },
+    { false, "ARPACK_LIBS", OCTAVE_CONF_ARPACK_LIBS },
+    { false, "BLAS_LIBS", OCTAVE_CONF_BLAS_LIBS },
+    { false, "CAMD_CPPFLAGS", OCTAVE_CONF_CAMD_CPPFLAGS },
+    { false, "CAMD_LDFLAGS", OCTAVE_CONF_CAMD_LDFLAGS },
+    { false, "CAMD_LIBS", OCTAVE_CONF_CAMD_LIBS },
+    { false, "CARBON_LIBS", OCTAVE_CONF_CARBON_LIBS },
+    { false, "CC", OCTAVE_CONF_CC },
+    // FIXME: CC_VERSION is deprecated.  Remove in version 3.12
+    { false, "CC_VERSION", OCTAVE_CONF_CC_VERSION },
+    { false, "CCOLAMD_CPPFLAGS", OCTAVE_CONF_CCOLAMD_CPPFLAGS },
+    { false, "CCOLAMD_LDFLAGS", OCTAVE_CONF_CCOLAMD_LDFLAGS },
+    { false, "CCOLAMD_LIBS", OCTAVE_CONF_CCOLAMD_LIBS },
+    { false, "CFLAGS", OCTAVE_CONF_CFLAGS },
+    { false, "CHOLMOD_CPPFLAGS", OCTAVE_CONF_CHOLMOD_CPPFLAGS },
+    { false, "CHOLMOD_LDFLAGS", OCTAVE_CONF_CHOLMOD_LDFLAGS },
+    { false, "CHOLMOD_LIBS", OCTAVE_CONF_CHOLMOD_LIBS },
+    { false, "COLAMD_CPPFLAGS", OCTAVE_CONF_COLAMD_CPPFLAGS },
+    { false, "COLAMD_LDFLAGS", OCTAVE_CONF_COLAMD_LDFLAGS },
+    { false, "COLAMD_LIBS", OCTAVE_CONF_COLAMD_LIBS },
+    { false, "CPICFLAG", OCTAVE_CONF_CPICFLAG },
+    { false, "CPPFLAGS", OCTAVE_CONF_CPPFLAGS },
+    { false, "CURL_CPPFLAGS", OCTAVE_CONF_CURL_CPPFLAGS },
+    { false, "CURL_LDFLAGS", OCTAVE_CONF_CURL_LDFLAGS },
+    { false, "CURL_LIBS", OCTAVE_CONF_CURL_LIBS },
+    { false, "CXSPARSE_CPPFLAGS", OCTAVE_CONF_CXSPARSE_CPPFLAGS },
+    { false, "CXSPARSE_LDFLAGS", OCTAVE_CONF_CXSPARSE_LDFLAGS },
+    { false, "CXSPARSE_LIBS", OCTAVE_CONF_CXSPARSE_LIBS },
+    { false, "CXX", OCTAVE_CONF_CXX },
+    { false, "CXXCPP", OCTAVE_CONF_CXXCPP },
+    { false, "CXXFLAGS", OCTAVE_CONF_CXXFLAGS },
+    { false, "CXXPICFLAG", OCTAVE_CONF_CXXPICFLAG },
+    // FIXME: CXX_VERSION is deprecated.  Remove in version 3.12
+    { false, "CXX_VERSION", OCTAVE_CONF_CXX_VERSION },
+    { false, "DEFAULT_PAGER", OCTAVE_DEFAULT_PAGER },
+    { false, "DEFS", OCTAVE_CONF_DEFS },
+    { false, "DL_LD", OCTAVE_CONF_DL_LD },
+    { false, "DL_LDFLAGS", OCTAVE_CONF_DL_LDFLAGS },
+    { false, "DL_LIBS", OCTAVE_CONF_DL_LIBS },
+    { false, "GCC_VERSION", OCTAVE_CONF_GCC_VERSION },
+    { false, "GXX_VERSION", OCTAVE_CONF_GXX_VERSION },
+    { false, "ENABLE_DYNAMIC_LINKING", OCTAVE_CONF_ENABLE_DYNAMIC_LINKING },
+    { false, "EXEEXT", OCTAVE_CONF_EXEEXT },
+    { false, "F77", OCTAVE_CONF_F77 },
+    { false, "F77_FLOAT_STORE_FLAG", OCTAVE_CONF_F77_FLOAT_STORE_FLAG },
+    { false, "F77_INTEGER_8_FLAG", OCTAVE_CONF_F77_INTEGER_8_FLAG },
+    { false, "FC", OCTAVE_CONF_FC },
+    { false, "FFLAGS", OCTAVE_CONF_FFLAGS },
+    { false, "FFTW3_CPPFLAGS", OCTAVE_CONF_FFTW3_CPPFLAGS },
+    { false, "FFTW3_LDFLAGS", OCTAVE_CONF_FFTW3_LDFLAGS },
+    { false, "FFTW3_LIBS", OCTAVE_CONF_FFTW3_LIBS },
+    { false, "FFTW3F_CPPFLAGS", OCTAVE_CONF_FFTW3F_CPPFLAGS },
+    { false, "FFTW3F_LDFLAGS", OCTAVE_CONF_FFTW3F_LDFLAGS },
+    { false, "FFTW3F_LIBS", OCTAVE_CONF_FFTW3F_LIBS },
+    { false, "FLIBS", OCTAVE_CONF_FLIBS },
+    { false, "FPICFLAG", OCTAVE_CONF_FPICFLAG },
+    { false, "FT2_CFLAGS", OCTAVE_CONF_FT2_CFLAGS },
+    { false, "FT2_LIBS", OCTAVE_CONF_FT2_LIBS },
+    { false, "GLPK_CPPFLAGS", OCTAVE_CONF_GLPK_CPPFLAGS },
+    { false, "GLPK_LDFLAGS", OCTAVE_CONF_GLPK_LDFLAGS },
+    { false, "GLPK_LIBS", OCTAVE_CONF_GLPK_LIBS },
+    { false, "GNUPLOT", OCTAVE_CONF_GNUPLOT },
+    { false, "GRAPHICS_CFLAGS", OCTAVE_CONF_GRAPHICS_CFLAGS },
+    { false, "GRAPHICS_LIBS", OCTAVE_CONF_GRAPHICS_LIBS },
+    { false, "HDF5_CPPFLAGS", OCTAVE_CONF_HDF5_CPPFLAGS },
+    { false, "HDF5_LDFLAGS", OCTAVE_CONF_HDF5_LDFLAGS },
+    { false, "HDF5_LIBS", OCTAVE_CONF_HDF5_LIBS },
+    { false, "LAPACK_LIBS", OCTAVE_CONF_LAPACK_LIBS },
+    { false, "LDFLAGS", OCTAVE_CONF_LDFLAGS },
+    { false, "LD_CXX", OCTAVE_CONF_LD_CXX },
+    { false, "LD_STATIC_FLAG", OCTAVE_CONF_LD_STATIC_FLAG },
+    { false, "LEX", OCTAVE_CONF_LEX },
+    { false, "LEXLIB", OCTAVE_CONF_LEXLIB },
+    { false, "LFLAGS", OCTAVE_CONF_LFLAGS },
+    { false, "LIBEXT", OCTAVE_CONF_LIBEXT },
+    { false, "LIBFLAGS", OCTAVE_CONF_LIBFLAGS },
+    { false, "LIBOCTAVE", OCTAVE_CONF_LIBOCTAVE },
+    { false, "LIBOCTINTERP", OCTAVE_CONF_LIBOCTINTERP },
+    { false, "LIBS", OCTAVE_CONF_LIBS },
+    { false, "LLVM_CPPFLAGS", OCTAVE_CONF_LLVM_CPPFLAGS },
+    { false, "LLVM_LDFLAGS", OCTAVE_CONF_LLVM_LDFLAGS },
+    { false, "LLVM_LIBS", OCTAVE_CONF_LLVM_LIBS },
+    { false, "LN_S", OCTAVE_CONF_LN_S },
+    { false, "MAGICK_CPPFLAGS", OCTAVE_CONF_MAGICK_CPPFLAGS },
+    { false, "MAGICK_LDFLAGS", OCTAVE_CONF_MAGICK_LDFLAGS },
+    { false, "MAGICK_LIBS", OCTAVE_CONF_MAGICK_LIBS },
+    { false, "MKOCTFILE_DL_LDFLAGS", OCTAVE_CONF_MKOCTFILE_DL_LDFLAGS },
+    { false, "OCTAVE_LINK_DEPS", OCTAVE_CONF_OCTAVE_LINK_DEPS },
+    { false, "OCTAVE_LINK_OPTS", OCTAVE_CONF_OCTAVE_LINK_OPTS },
+    { false, "OCT_LINK_DEPS", OCTAVE_CONF_OCT_LINK_DEPS },
+    { false, "OCT_LINK_OPTS", OCTAVE_CONF_OCT_LINK_OPTS },
+    { false, "OPENGL_LIBS", OCTAVE_CONF_OPENGL_LIBS },
+    { false, "PTHREAD_CFLAGS", OCTAVE_CONF_PTHREAD_CFLAGS },
+    { false, "PTHREAD_LIBS", OCTAVE_CONF_PTHREAD_LIBS },
+    { false, "QHULL_CPPFLAGS", OCTAVE_CONF_QHULL_CPPFLAGS },
+    { false, "QHULL_LDFLAGS", OCTAVE_CONF_QHULL_LDFLAGS },
+    { false, "QHULL_LIBS", OCTAVE_CONF_QHULL_LIBS },
+    { false, "QRUPDATE_CPPFLAGS", OCTAVE_CONF_QRUPDATE_CPPFLAGS },
+    { false, "QRUPDATE_LDFLAGS", OCTAVE_CONF_QRUPDATE_LDFLAGS },
+    { false, "QRUPDATE_LIBS", OCTAVE_CONF_QRUPDATE_LIBS },
+    { false, "QT_CPPFLAGS", OCTAVE_CONF_QT_CPPFLAGS },
+    { false, "QT_LDFLAGS", OCTAVE_CONF_QT_LDFLAGS },
+    { false, "QT_LIBS", OCTAVE_CONF_QT_LIBS },
+    { false, "RANLIB", OCTAVE_CONF_RANLIB },
+    { false, "RDYNAMIC_FLAG", OCTAVE_CONF_RDYNAMIC_FLAG },
+    { false, "READLINE_LIBS", OCTAVE_CONF_READLINE_LIBS },
+    { false, "REGEX_LIBS", OCTAVE_CONF_REGEX_LIBS },
+    { false, "SED", OCTAVE_CONF_SED },
+    { false, "SHARED_LIBS", OCTAVE_CONF_SHARED_LIBS },
+    { false, "SHLEXT", OCTAVE_CONF_SHLEXT },
+    { false, "SHLEXT_VER", OCTAVE_CONF_SHLEXT_VER },
+    { false, "SH_LD", OCTAVE_CONF_SH_LD },
+    { false, "SH_LDFLAGS", OCTAVE_CONF_SH_LDFLAGS },
+    { false, "SONAME_FLAGS", OCTAVE_CONF_SONAME_FLAGS },
+    { false, "STATIC_LIBS", OCTAVE_CONF_STATIC_LIBS },
+    { false, "TERM_LIBS", OCTAVE_CONF_TERM_LIBS },
+    { false, "UMFPACK_CPPFLAGS", OCTAVE_CONF_UMFPACK_CPPFLAGS },
+    { false, "UMFPACK_LDFLAGS", OCTAVE_CONF_UMFPACK_LDFLAGS },
+    { false, "UMFPACK_LIBS", OCTAVE_CONF_UMFPACK_LIBS },
+    { false, "USE_64_BIT_IDX_T", OCTAVE_CONF_USE_64_BIT_IDX_T },
+    { false, "WARN_CFLAGS", OCTAVE_CONF_WARN_CFLAGS },
+    { false, "WARN_CXXFLAGS", OCTAVE_CONF_WARN_CXXFLAGS },
+    { false, "X11_INCFLAGS", OCTAVE_CONF_X11_INCFLAGS },
+    { false, "X11_LIBS", OCTAVE_CONF_X11_LIBS },
+    { false, "XTRA_CFLAGS", OCTAVE_CONF_XTRA_CFLAGS },
+    { false, "XTRA_CXXFLAGS", OCTAVE_CONF_XTRA_CXXFLAGS },
+    { false, "YACC", OCTAVE_CONF_YACC },
+    { false, "YFLAGS", OCTAVE_CONF_YFLAGS },
+    { false, "Z_CPPFLAGS", OCTAVE_CONF_Z_CPPFLAGS },
+    { false, "Z_LDFLAGS", OCTAVE_CONF_Z_LDFLAGS },
+    { false, "Z_LIBS", OCTAVE_CONF_Z_LIBS },
+    { false, "api_version", OCTAVE_API_VERSION },
+    { true, "archlibdir", OCTAVE_ARCHLIBDIR },
+    { true, "bindir", OCTAVE_BINDIR },
+    { false, "canonical_host_type", OCTAVE_CANONICAL_HOST_TYPE },
+    { false, "config_opts", OCTAVE_CONF_config_opts },
+    { true, "datadir", OCTAVE_DATADIR },
+    { true, "datarootdir", OCTAVE_DATAROOTDIR },
+    { true, "exec_prefix", OCTAVE_EXEC_PREFIX },
+    { true, "fcnfiledir", OCTAVE_FCNFILEDIR },
+    { true, "imagedir", OCTAVE_IMAGEDIR },
+    { true, "includedir", OCTAVE_INCLUDEDIR },
+    { true, "infodir", OCTAVE_INFODIR },
+    { true, "infofile", OCTAVE_INFOFILE },
+    { true, "libdir", OCTAVE_LIBDIR },
+    { true, "libexecdir", OCTAVE_LIBEXECDIR },
+    { true, "localapiarchlibdir", OCTAVE_LOCALAPIARCHLIBDIR },
+    { true, "localapifcnfiledir", OCTAVE_LOCALAPIFCNFILEDIR },
+    { true, "localapioctfiledir", OCTAVE_LOCALAPIOCTFILEDIR },
+    { true, "localarchlibdir", OCTAVE_LOCALARCHLIBDIR },
+    { true, "localfcnfiledir", OCTAVE_LOCALFCNFILEDIR },
+    { true, "localoctfiledir", OCTAVE_LOCALOCTFILEDIR },
+    { true, "localstartupfiledir", OCTAVE_LOCALSTARTUPFILEDIR },
+    { true, "localverarchlibdir", OCTAVE_LOCALVERARCHLIBDIR },
+    { true, "localverfcnfiledir", OCTAVE_LOCALVERFCNFILEDIR },
+    { true, "localveroctfiledir", OCTAVE_LOCALVEROCTFILEDIR },
+    { true, "man1dir", OCTAVE_MAN1DIR },
+    { false, "man1ext", OCTAVE_MAN1EXT },
+    { true, "mandir", OCTAVE_MANDIR },
+    { true, "octfiledir", OCTAVE_OCTFILEDIR },
+    { true, "octetcdir", OCTAVE_OCTETCDIR },
+    { true, "octincludedir", OCTAVE_OCTINCLUDEDIR },
+    { true, "octlibdir", OCTAVE_OCTLIBDIR },
+    { true, "octtestsdir", OCTAVE_OCTTESTSDIR },
+    { true, "prefix", OCTAVE_PREFIX },
+    { true, "startupfiledir", OCTAVE_STARTUPFILEDIR },
+    { false, "version", OCTAVE_VERSION },
+    { false, 0, 0 }
+  };
 
   if (! initialized)
     {
       m.assign ("dld", octave_value (octave_supports_dynamic_linking));
 
       oct_mach_info::float_format ff = oct_mach_info::native_float_format ();
       m.assign ("float_format",
                 octave_value (oct_mach_info::float_format_as_string (ff)));
diff --git a/libinterp/corefcn/toplev.h b/libinterp/corefcn/toplev.h
--- a/libinterp/corefcn/toplev.h
+++ b/libinterp/corefcn/toplev.h
@@ -102,21 +102,23 @@ protected:
 
   octave_call_stack (void) : cs (), curr_frame (0) { }
 
 public:
 
   typedef std::deque<call_stack_elt>::iterator iterator;
   typedef std::deque<call_stack_elt>::const_iterator const_iterator;
 
-  typedef std::deque<call_stack_elt>::reverse_iterator reverse_iterator;
-  typedef std::deque<call_stack_elt>::const_reverse_iterator const_reverse_iterator;
+  typedef std::deque<call_stack_elt>::reverse_iterator
+    reverse_iterator;
+  typedef std::deque<call_stack_elt>::const_reverse_iterator
+    const_reverse_iterator;
 
   static void create_instance (void);
-  
+
   static bool instance_ok (void)
   {
     bool retval = true;
 
     if (! instance)
       create_instance ();
 
     if (! instance)
@@ -173,17 +175,17 @@ public:
   static size_t size (void)
   {
     return instance_ok () ? instance->do_size () : 0;
   }
 
   static size_t num_user_code_frames (octave_idx_type& curr_user_frame)
   {
     return instance_ok ()
-      ? instance->do_num_user_code_frames (curr_user_frame) : 0;
+           ? instance->do_num_user_code_frames (curr_user_frame) : 0;
   }
 
   static symbol_table::scope_id current_scope (void)
   {
     return instance_ok () ? instance->do_current_scope () : 0;
   }
 
   static symbol_table::context_id current_context (void)
@@ -247,17 +249,17 @@ public:
   static void restore_frame (size_t n)
   {
     goto_frame (n);
   }
 
   static bool goto_frame_relative (int n, bool verbose = false)
   {
     return instance_ok ()
-      ? instance->do_goto_frame_relative (n, verbose) : false;
+           ? instance->do_goto_frame_relative (n, verbose) : false;
   }
 
   static void goto_caller_frame (void)
   {
     if (instance_ok ())
       instance->do_goto_caller_frame ();
   }
 
@@ -265,17 +267,17 @@ public:
   {
     if (instance_ok ())
       instance->do_goto_base_frame ();
   }
 
   static octave_map backtrace (size_t nskip, octave_idx_type& curr_user_frame)
   {
     return instance_ok ()
-      ? instance->do_backtrace (nskip, curr_user_frame) : octave_map ();
+           ? instance->do_backtrace (nskip, curr_user_frame) : octave_map ();
   }
 
   static octave_map empty_backtrace (void);
 
   static void pop (void)
   {
     if (instance_ok ())
       instance->do_pop ();
@@ -321,23 +323,23 @@ private:
 
   size_t do_size (void) { return cs.size (); }
 
   size_t do_num_user_code_frames (octave_idx_type& curr_user_frame) const;
 
   symbol_table::scope_id do_current_scope (void) const
   {
     return curr_frame > 0 && curr_frame < cs.size ()
-      ? cs[curr_frame].scope : 0;
+           ? cs[curr_frame].scope : 0;
   }
 
   symbol_table::context_id do_current_context (void) const
   {
     return curr_frame > 0 && curr_frame < cs.size ()
-      ? cs[curr_frame].context : 0;
+           ? cs[curr_frame].context : 0;
   }
 
   octave_function *do_element (size_t n)
   {
     octave_function *retval = 0;
 
     if (cs.size () > n)
       {
diff --git a/libinterp/corefcn/tril.cc b/libinterp/corefcn/tril.cc
--- a/libinterp/corefcn/tril.cc
+++ b/libinterp/corefcn/tril.cc
@@ -86,17 +86,18 @@ do_triu (const Array<T>& a, octave_idx_t
   octave_idx_type nr = a.rows (), nc = a.columns ();
   const T *avec = a.fortran_vec ();
   octave_idx_type zero = 0;
 
   if (pack)
     {
       octave_idx_type j1 = std::min (std::max (zero, k), nc);
       octave_idx_type j2 = std::min (std::max (zero, nr + k), nc);
-      octave_idx_type n = ((j2 - j1) * ((j1+1-k) + (j2-k))) / 2 + (nc - j2) * nr;
+      octave_idx_type n
+        = ((j2 - j1) * ((j1+1-k) + (j2-k))) / 2 + (nc - j2) * nr;
       Array<T> r (dim_vector (n, 1));
       T *rvec = r.fortran_vec ();
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_idx_type ii = std::min (std::max (zero, j + 1 - k), nr);
           rvec = std::copy (avec, avec + ii, rvec);
           avec += nr;
         }
@@ -224,23 +225,25 @@ do_trilu (const std::string& name,
             case btyp_double:
               if (arg.is_sparse_type ())
                 retval = do_trilu (arg.sparse_matrix_value (), k, lower, pack);
               else
                 retval = do_trilu (arg.array_value (), k, lower, pack);
               break;
             case btyp_complex:
               if (arg.is_sparse_type ())
-                retval = do_trilu (arg.sparse_complex_matrix_value (), k, lower, pack);
+                retval = do_trilu (arg.sparse_complex_matrix_value (), k, lower,
+                                   pack);
               else
                 retval = do_trilu (arg.complex_array_value (), k, lower, pack);
               break;
             case btyp_bool:
               if (arg.is_sparse_type ())
-                retval = do_trilu (arg.sparse_bool_matrix_value (), k, lower, pack);
+                retval = do_trilu (arg.sparse_bool_matrix_value (), k, lower,
+                                   pack);
               else
                 retval = do_trilu (arg.bool_array_value (), k, lower, pack);
               break;
 #define ARRAYCASE(TYP) \
             case btyp_ ## TYP: \
               retval = do_trilu (arg.TYP ## _array_value (), k, lower, pack); \
               break
             ARRAYCASE (float);
@@ -335,17 +338,17 @@ do_trilu (const std::string& name,
             }
         }
     }
 
   return retval;
 }
 
 DEFUN (tril, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Function File} {} tril (@var{A})\n\
 @deftypefnx {Function File} {} tril (@var{A}, @var{k})\n\
 @deftypefnx {Function File} {} tril (@var{A}, @var{k}, @var{pack})\n\
 @deftypefnx {Function File} {} triu (@var{A})\n\
 @deftypefnx {Function File} {} triu (@var{A}, @var{k})\n\
 @deftypefnx {Function File} {} triu (@var{A}, @var{k}, @var{pack})\n\
 Return a new matrix formed by extracting the lower (@code{tril})\n\
 or upper (@code{triu}) triangular part of the matrix @var{A}, and\n\
@@ -391,17 +394,17 @@ elements are not inserted into a matrix,
 above other.\n\
 @seealso{diag}\n\
 @end deftypefn")
 {
   return do_trilu ("tril", args);
 }
 
 DEFUN (triu, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Function File} {} triu (@var{A})\n\
 @deftypefnx {Function File} {} triu (@var{A}, @var{k})\n\
 @deftypefnx {Function File} {} triu (@var{A}, @var{k}, @var{pack})\n\
 See the documentation for the @code{tril} function (@pxref{tril}).\n\
 @end deftypefn")
 {
   return do_trilu ("triu", args);
 }
@@ -413,17 +416,17 @@ See the documentation for the @code{tril
 %! l0 = [1, 0, 0; 4, 5, 0; 7, 8, 9; 10, 11, 12];
 %! l1 = [1, 2, 0; 4, 5, 6; 7, 8, 9; 10, 11, 12];
 %! l2 = [1, 2, 3; 4, 5, 6; 7, 8, 9; 10, 11, 12];
 %! lm1 = [0, 0, 0; 4, 0, 0; 7, 8, 0; 10, 11, 12];
 %! lm2 = [0, 0, 0; 0, 0, 0; 7, 0, 0; 10, 11, 0];
 %! lm3 = [0, 0, 0; 0, 0, 0; 0, 0, 0; 10, 0, 0];
 %! lm4 = [0, 0, 0; 0, 0, 0; 0, 0, 0; 0, 0, 0];
 %!
-%! assert (tril (a, -4), lm4); 
+%! assert (tril (a, -4), lm4);
 %! assert (tril (a, -3), lm3);
 %! assert (tril (a, -2), lm2);
 %! assert (tril (a, -1), lm1);
 %! assert (tril (a), l0);
 %! assert (tril (a, 1), l1);
 %! assert (tril (a, 2), l2);
 
 %!error tril ()
diff --git a/libinterp/corefcn/txt-eng-ft.cc b/libinterp/corefcn/txt-eng-ft.cc
--- a/libinterp/corefcn/txt-eng-ft.cc
+++ b/libinterp/corefcn/txt-eng-ft.cc
@@ -72,50 +72,52 @@ gripe_glyph_render (FT_ULong c)
 // Forward declaration
 static void ft_face_destroyed (void* object);
 
 class
 ft_manager
 {
 public:
   static bool instance_ok (void)
-    {
-      bool retval = true;
+  {
+    bool retval = true;
 
-      if (! instance)
-        {
-          instance = new ft_manager ();
+    if (! instance)
+      {
+        instance = new ft_manager ();
 
-          if (instance)
-            singleton_cleanup_list::add (cleanup_instance);
-        }
+        if (instance)
+          singleton_cleanup_list::add (cleanup_instance);
+      }
 
-      if (! instance)
-        {
-          ::error ("unable to create ft_manager!");
+    if (! instance)
+      {
+        ::error ("unable to create ft_manager!");
 
-          retval = false;
-        }
+        retval = false;
+      }
 
-      return retval;
-    }
+    return retval;
+  }
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
 
   static FT_Face get_font (const std::string& name, const std::string& weight,
                            const std::string& angle, double size)
-    { return (instance_ok ()
-              ? instance->do_get_font (name, weight, angle, size)
-              : 0); }
+  {
+    return (instance_ok ()
+            ? instance->do_get_font (name, weight, angle, size)
+            : 0);
+  }
 
   static void font_destroyed (FT_Face face)
-    {
-      if (instance_ok ())
-        instance->do_font_destroyed (face);
-    }
+  {
+    if (instance_ok ())
+      instance->do_font_destroyed (face);
+  }
 
 private:
 
   static ft_manager *instance;
 
   typedef std::pair<std::string, double> ft_key;
   typedef std::map<ft_key, FT_Face> ft_cache;
 
@@ -129,191 +131,191 @@ private:
   // No copying!
 
   ft_manager (const ft_manager&);
 
   ft_manager& operator = (const ft_manager&);
 
   ft_manager (void)
     : library (), freetype_initialized (false), fontconfig_initialized (false)
-    {
-      if (FT_Init_FreeType (&library))
-        ::error ("unable to initialize freetype library");
-      else
-        freetype_initialized = true;
+  {
+    if (FT_Init_FreeType (&library))
+      ::error ("unable to initialize freetype library");
+    else
+      freetype_initialized = true;
 
 #if defined (HAVE_FONTCONFIG)
-      if (! FcInit ())
-        ::error ("unable to initialize fontconfig library");
-      else
-        fontconfig_initialized = true;
+    if (! FcInit ())
+      ::error ("unable to initialize fontconfig library");
+    else
+      fontconfig_initialized = true;
 #endif
-    }
+  }
 
   ~ft_manager (void)
-    {
-      if (freetype_initialized)
-        FT_Done_FreeType (library);
+  {
+    if (freetype_initialized)
+      FT_Done_FreeType (library);
 
 #if defined (HAVE_FONTCONFIG)
-      // FIXME: Skip the call to FcFini because it can trigger the assertion
-      //
-      //   octave: fccache.c:507: FcCacheFini: Assertion 'fcCacheChains[i] == ((void *)0)' failed.
-      //
-      // if (fontconfig_initialized)
-      //   FcFini ();
+    // FIXME: Skip the call to FcFini because it can trigger the assertion
+    //
+    //   octave: fccache.c:507: FcCacheFini: Assertion 'fcCacheChains[i] == ((void *)0)' failed.
+    //
+    // if (fontconfig_initialized)
+    //   FcFini ();
 #endif
-    }
+  }
 
 
   FT_Face do_get_font (const std::string& name, const std::string& weight,
                        const std::string& angle, double size)
-    {
-      FT_Face retval = 0;
+  {
+    FT_Face retval = 0;
 
 #if HAVE_FT_REFERENCE_FACE
-      // Look first into the font cache, then use fontconfig. If the font
-      // is present in the cache, simply add a reference and return it.
+    // Look first into the font cache, then use fontconfig. If the font
+    // is present in the cache, simply add a reference and return it.
 
-      ft_key key (name + ":" + weight + ":" + angle, size);
-      ft_cache::const_iterator it = cache.find (key);
+    ft_key key (name + ":" + weight + ":" + angle, size);
+    ft_cache::const_iterator it = cache.find (key);
 
-      if (it != cache.end ())
-        {
-          FT_Reference_Face (it->second);
-          return it->second;
-        }
+    if (it != cache.end ())
+      {
+        FT_Reference_Face (it->second);
+        return it->second;
+      }
 #endif
 
-      std::string file;
+    std::string file;
 
 #if defined (HAVE_FONTCONFIG)
-      if (fontconfig_initialized)
-        {
-          int fc_weight, fc_angle;
+    if (fontconfig_initialized)
+      {
+        int fc_weight, fc_angle;
 
-          if (weight == "bold")
-            fc_weight = FC_WEIGHT_BOLD;
-          else if (weight == "light")
-            fc_weight = FC_WEIGHT_LIGHT;
-          else if (weight == "demi")
-            fc_weight = FC_WEIGHT_DEMIBOLD;
-          else
-            fc_weight = FC_WEIGHT_NORMAL;
+        if (weight == "bold")
+          fc_weight = FC_WEIGHT_BOLD;
+        else if (weight == "light")
+          fc_weight = FC_WEIGHT_LIGHT;
+        else if (weight == "demi")
+          fc_weight = FC_WEIGHT_DEMIBOLD;
+        else
+          fc_weight = FC_WEIGHT_NORMAL;
 
-          if (angle == "italic")
-            fc_angle = FC_SLANT_ITALIC;
-          else if (angle == "oblique")
-            fc_angle = FC_SLANT_OBLIQUE;
-          else
-            fc_angle = FC_SLANT_ROMAN;
+        if (angle == "italic")
+          fc_angle = FC_SLANT_ITALIC;
+        else if (angle == "oblique")
+          fc_angle = FC_SLANT_OBLIQUE;
+        else
+          fc_angle = FC_SLANT_ROMAN;
 
-          FcPattern *pat = FcPatternCreate ();
+        FcPattern *pat = FcPatternCreate ();
 
-          FcPatternAddString (pat, FC_FAMILY,
-                              (reinterpret_cast<const FcChar8*>
-                               (name == "*" ? "sans" : name.c_str ())));
+        FcPatternAddString (pat, FC_FAMILY,
+                            (reinterpret_cast<const FcChar8*>
+                             (name == "*" ? "sans" : name.c_str ())));
 
-          FcPatternAddInteger (pat, FC_WEIGHT, fc_weight);
-          FcPatternAddInteger (pat, FC_SLANT, fc_angle);
-          FcPatternAddDouble (pat, FC_PIXEL_SIZE, size);
+        FcPatternAddInteger (pat, FC_WEIGHT, fc_weight);
+        FcPatternAddInteger (pat, FC_SLANT, fc_angle);
+        FcPatternAddDouble (pat, FC_PIXEL_SIZE, size);
 
-          if (FcConfigSubstitute (0, pat, FcMatchPattern))
-            {
-              FcResult res;
-              FcPattern *match;
+        if (FcConfigSubstitute (0, pat, FcMatchPattern))
+          {
+            FcResult res;
+            FcPattern *match;
 
-              FcDefaultSubstitute (pat);
-              match = FcFontMatch (0, pat, &res);
+            FcDefaultSubstitute (pat);
+            match = FcFontMatch (0, pat, &res);
 
-              // FIXME: originally, this test also required that
-              // res != FcResultNoMatch.  Is that really needed?
-              if (match)
-                {
-                  unsigned char *tmp;
+            // FIXME: originally, this test also required that
+            // res != FcResultNoMatch.  Is that really needed?
+            if (match)
+              {
+                unsigned char *tmp;
 
-                  FcPatternGetString (match, FC_FILE, 0, &tmp);
-                  file = reinterpret_cast<char*> (tmp);
-                }
-              else
-                ::warning ("could not match any font: %s-%s-%s-%g",
+                FcPatternGetString (match, FC_FILE, 0, &tmp);
+                file = reinterpret_cast<char*> (tmp);
+              }
+            else
+              ::warning ("could not match any font: %s-%s-%s-%g",
                          name.c_str (), weight.c_str (), angle.c_str (),
                          size);
 
-              if (match)
-                FcPatternDestroy (match);
-            }
+            if (match)
+              FcPatternDestroy (match);
+          }
 
-          FcPatternDestroy (pat);
-        }
+        FcPatternDestroy (pat);
+      }
 #endif
 
-      if (file.empty ())
-        {
+    if (file.empty ())
+      {
 #ifdef __WIN32__
-          file = "C:/WINDOWS/Fonts/verdana.ttf";
+        file = "C:/WINDOWS/Fonts/verdana.ttf";
 #else
-          // FIXME: find a "standard" font for UNIX platforms
+        // FIXME: find a "standard" font for UNIX platforms
 #endif
-        }
+      }
 
-      if (! file.empty ())
-        {
-          if (FT_New_Face (library, file.c_str (), 0, &retval))
-            ::warning ("ft_manager: unable to load font: %s", file.c_str ());
+    if (! file.empty ())
+      {
+        if (FT_New_Face (library, file.c_str (), 0, &retval))
+          ::warning ("ft_manager: unable to load font: %s", file.c_str ());
 #if HAVE_FT_REFERENCE_FACE
-          else
-            {
-              // Install a finalizer to notify ft_manager that the font is
-              // being destroyed. The class ft_manager only keeps weak
-              // references to font objects.
+        else
+          {
+            // Install a finalizer to notify ft_manager that the font is
+            // being destroyed. The class ft_manager only keeps weak
+            // references to font objects.
 
-              retval->generic.data = new ft_key (key);
-              retval->generic.finalizer = ft_face_destroyed;
+            retval->generic.data = new ft_key (key);
+            retval->generic.finalizer = ft_face_destroyed;
 
-              // Insert loaded font into the cache.
+            // Insert loaded font into the cache.
 
-              cache[key] = retval;
-            }
+            cache[key] = retval;
+          }
 #endif
-        }
+      }
 
-      return retval;
-    }
+    return retval;
+  }
 
   void do_font_destroyed (FT_Face face)
-    {
-      if (face->generic.data)
-        {
-          ft_key* pkey = reinterpret_cast<ft_key*> (face->generic.data);
+  {
+    if (face->generic.data)
+      {
+        ft_key* pkey = reinterpret_cast<ft_key*> (face->generic.data);
 
-          cache.erase (*pkey);
-          delete pkey;
-          face->generic.data = 0;
-        }
-    }
+        cache.erase (*pkey);
+        delete pkey;
+        face->generic.data = 0;
+      }
+  }
 
 private:
   FT_Library library;
   bool freetype_initialized;
   bool fontconfig_initialized;
 };
 
 ft_manager* ft_manager::instance = 0;
 
 static void
 ft_face_destroyed (void* object)
 { ft_manager::font_destroyed (reinterpret_cast<FT_Face> (object)); }
 
 // ---------------------------------------------------------------------------
 
 ft_render::ft_render (void)
-    : text_processor (), font (), bbox (1, 4, 0.0), halign (0), xoffset (0),
-      line_yoffset (0), yoffset (0), mode (MODE_BBOX),
-      color (dim_vector (1, 3), 0)
+  : text_processor (), font (), bbox (1, 4, 0.0), halign (0), xoffset (0),
+    line_yoffset (0), yoffset (0), mode (MODE_BBOX),
+    color (dim_vector (1, 3), 0)
 {
 }
 
 ft_render::~ft_render (void)
 {
 }
 
 void
@@ -326,53 +328,53 @@ ft_render::set_font (const std::string& 
 }
 
 void
 ft_render::push_new_line (void)
 {
   switch (mode)
     {
     case MODE_BBOX:
-        {
-          // Create a new bbox entry based on the current font.
+      {
+        // Create a new bbox entry based on the current font.
 
-          FT_Face face = font.get_face ();
+        FT_Face face = font.get_face ();
 
-          if (face)
-            {
-              int asc = face->size->metrics.ascender >> 6;
-              int desc = face->size->metrics.descender >> 6;
-              int h = face->size->metrics.height >> 6;
+        if (face)
+          {
+            int asc = face->size->metrics.ascender >> 6;
+            int desc = face->size->metrics.descender >> 6;
+            int h = face->size->metrics.height >> 6;
 
-              Matrix bb (1, 5, 0.0);
+            Matrix bb (1, 5, 0.0);
 
-              bb(1) = desc;
-              bb(3) = asc - desc;
-              bb(4) = h;
+            bb(1) = desc;
+            bb(3) = asc - desc;
+            bb(4) = h;
 
-              line_bbox.push_back (bb);
+            line_bbox.push_back (bb);
 
-              xoffset = yoffset = 0;
-            }
-        }
+            xoffset = yoffset = 0;
+          }
+      }
       break;
 
     case MODE_RENDER:
-        {
-          // Move to the next line bbox, adjust xoffset based on alignment
-          // and yoffset based on the old and new line bbox.
+      {
+        // Move to the next line bbox, adjust xoffset based on alignment
+        // and yoffset based on the old and new line bbox.
 
-          Matrix old_bbox = line_bbox.front ();
-          line_bbox.pop_front ();
-          Matrix new_bbox = line_bbox.front ();
+        Matrix old_bbox = line_bbox.front ();
+        line_bbox.pop_front ();
+        Matrix new_bbox = line_bbox.front ();
 
-          xoffset = compute_line_xoffset (new_bbox);
-          line_yoffset += (old_bbox(1) - (new_bbox(1) + new_bbox(3)));
-          yoffset = 0;
-        }
+        xoffset = compute_line_xoffset (new_bbox);
+        line_yoffset += (old_bbox(1) - (new_bbox(1) + new_bbox(3)));
+        yoffset = 0;
+      }
       break;
     }
 }
 
 int
 ft_render::compute_line_xoffset (const Matrix& lb) const
 {
   if (! bbox.is_empty ())
@@ -515,17 +517,18 @@ ft_render::process_character (FT_ULong c
       else
         {
           switch (mode)
             {
             case MODE_RENDER:
               if (code == '\n')
                 {
                   glyph_index = FT_Get_Char_Index (face, ' ');
-                  if (!glyph_index || FT_Load_Glyph (face, glyph_index, FT_LOAD_DEFAULT))
+                  if (! glyph_index
+                      || FT_Load_Glyph (face, glyph_index, FT_LOAD_DEFAULT))
                     {
                       glyph_index = 0;
                       gripe_missing_glyph (' ');
                     }
                   else
                     push_new_line ();
                 }
               else if (FT_Render_Glyph (face->glyph, FT_RENDER_MODE_NORMAL))
@@ -537,17 +540,18 @@ ft_render::process_character (FT_ULong c
                 {
                   FT_Bitmap& bitmap = face->glyph->bitmap;
                   int x0, y0;
 
                   if (previous)
                     {
                       FT_Vector delta;
 
-                      FT_Get_Kerning (face, previous, glyph_index, FT_KERNING_DEFAULT, &delta);
+                      FT_Get_Kerning (face, previous, glyph_index,
+                                      FT_KERNING_DEFAULT, &delta);
                       xoffset += (delta.x >> 6);
                     }
 
                   x0 = xoffset + face->glyph->bitmap_left;
                   y0 = line_yoffset + yoffset + face->glyph->bitmap_top;
 
                   // 'w' seems to have a negative -1
                   // face->glyph->bitmap_left, this is so we don't
@@ -856,53 +860,53 @@ ft_render::render (text_element* elt, Ma
     {
       elt->accept (*this);
 
       switch (rotation)
         {
         case ROTATION_0:
           break;
         case ROTATION_90:
-            {
-              Array<octave_idx_type> perm (dim_vector (3, 1));
-              perm(0) = 0;
-              perm(1) = 2;
-              perm(2) = 1;
-              pixels = pixels.permute (perm);
+          {
+            Array<octave_idx_type> perm (dim_vector (3, 1));
+            perm(0) = 0;
+            perm(1) = 2;
+            perm(2) = 1;
+            pixels = pixels.permute (perm);
 
-              Array<idx_vector> idx (dim_vector (3, 1));
-              idx(0) = idx_vector (':');
-              idx(1) = idx_vector (pixels.dim2 ()-1, -1, -1);
-              idx(2) = idx_vector (':');
-              pixels = uint8NDArray (pixels.index (idx));
-            }
+            Array<idx_vector> idx (dim_vector (3, 1));
+            idx(0) = idx_vector (':');
+            idx(1) = idx_vector (pixels.dim2 ()-1, -1, -1);
+            idx(2) = idx_vector (':');
+            pixels = uint8NDArray (pixels.index (idx));
+          }
           break;
         case ROTATION_180:
-            {
-              Array<idx_vector> idx (dim_vector (3, 1));
-              idx(0) = idx_vector (':');
-              idx(1) = idx_vector (pixels.dim2 ()-1, -1, -1);
-              idx(2)=  idx_vector (pixels.dim3 ()-1, -1, -1);
-              pixels = uint8NDArray (pixels.index (idx));
-            }
+          {
+            Array<idx_vector> idx (dim_vector (3, 1));
+            idx(0) = idx_vector (':');
+            idx(1) = idx_vector (pixels.dim2 ()-1, -1, -1);
+            idx(2)=  idx_vector (pixels.dim3 ()-1, -1, -1);
+            pixels = uint8NDArray (pixels.index (idx));
+          }
           break;
         case ROTATION_270:
-            {
-              Array<octave_idx_type> perm (dim_vector (3, 1));
-              perm(0) = 0;
-              perm(1) = 2;
-              perm(2) = 1;
-              pixels = pixels.permute (perm);
+          {
+            Array<octave_idx_type> perm (dim_vector (3, 1));
+            perm(0) = 0;
+            perm(1) = 2;
+            perm(2) = 1;
+            pixels = pixels.permute (perm);
 
-              Array<idx_vector> idx (dim_vector (3, 1));
-              idx(0) = idx_vector (':');
-              idx(1) = idx_vector (':');
-              idx(2) = idx_vector (pixels.dim3 ()-1, -1, -1);
-              pixels = uint8NDArray (pixels.index (idx));
-            }
+            Array<idx_vector> idx (dim_vector (3, 1));
+            idx(0) = idx_vector (':');
+            idx(1) = idx_vector (':');
+            idx(2) = idx_vector (pixels.dim3 ()-1, -1, -1);
+            pixels = uint8NDArray (pixels.index (idx));
+          }
           break;
         }
     }
 
   return pixels;
 }
 
 // Note:
@@ -1017,18 +1021,18 @@ ft_render::text_to_pixels (const std::st
       std::swap (box(0), box(1));
       std::swap (box(2), box(3));
       box(1) = -box(1)-box(3);
       break;
     }
 }
 
 ft_render::ft_font::ft_font (const ft_font& ft)
-     : name (ft.name), weight (ft.weight), angle (ft.angle), size (ft.size),
-       face (0)
+  : name (ft.name), weight (ft.weight), angle (ft.angle), size (ft.size),
+    face (0)
 {
 #if HAVE_FT_REFERENCE_FACE
   FT_Face ft_face = ft.get_face ();
 
   if (ft_face && FT_Reference_Face (ft_face) == 0)
     face = ft_face;
 #endif
 }
diff --git a/libinterp/corefcn/txt-eng-ft.h b/libinterp/corefcn/txt-eng-ft.h
--- a/libinterp/corefcn/txt-eng-ft.h
+++ b/libinterp/corefcn/txt-eng-ft.h
@@ -35,26 +35,28 @@ along with Octave; see the file COPYING.
 #include <uint8NDArray.h>
 #include "txt-eng.h"
 
 class
 OCTINTERP_API
 ft_render : public text_processor
 {
 public:
-  enum {
-      MODE_BBOX   = 0,
-      MODE_RENDER = 1
+  enum
+  {
+    MODE_BBOX   = 0,
+    MODE_RENDER = 1
   };
 
-  enum {
-      ROTATION_0   = 0,
-      ROTATION_90  = 1,
-      ROTATION_180 = 2,
-      ROTATION_270 = 3
+  enum
+  {
+    ROTATION_0   = 0,
+    ROTATION_90  = 1,
+    ROTATION_180 = 2,
+    ROTATION_270 = 3
   };
 
 public:
   ft_render (void);
 
   ~ft_render (void);
 
   void visit (text_element_string& e);
@@ -109,54 +111,54 @@ private:
 
   ft_render (const ft_render&);
 
   ft_render& operator = (const ft_render&);
 
   // Class to hold information about fonts and a strong
   // reference to the font objects loaded by freetype.
   class ft_font
-    {
-    public:
-      ft_font (void)
-        : name (), weight (), angle (), size (0), face (0) { }
+  {
+  public:
+    ft_font (void)
+      : name (), weight (), angle (), size (0), face (0) { }
 
-      ft_font (const std::string& nm, const std::string& wt,
-               const std::string& ang, double sz, FT_Face f = 0)
-        : name (nm), weight (wt), angle (ang), size (sz), face (f) { }
+    ft_font (const std::string& nm, const std::string& wt,
+             const std::string& ang, double sz, FT_Face f = 0)
+      : name (nm), weight (wt), angle (ang), size (sz), face (f) { }
 
-      ft_font (const ft_font& ft);
+    ft_font (const ft_font& ft);
 
-      ~ft_font (void)
-        {
-          if (face)
-            FT_Done_Face (face);
-        }
+    ~ft_font (void)
+    {
+      if (face)
+        FT_Done_Face (face);
+    }
 
-      ft_font& operator = (const ft_font& ft);
+    ft_font& operator = (const ft_font& ft);
 
-      bool is_valid (void) const { return get_face (); }
+    bool is_valid (void) const { return get_face (); }
 
-      std::string get_name (void) const { return name; }
+    std::string get_name (void) const { return name; }
 
-      std::string get_weight (void) const { return weight; }
+    std::string get_weight (void) const { return weight; }
 
-      std::string get_angle (void) const { return angle; }
+    std::string get_angle (void) const { return angle; }
 
-      double get_size (void) const { return size; }
+    double get_size (void) const { return size; }
 
-      FT_Face get_face (void) const;
+    FT_Face get_face (void) const;
 
-    private:
-      std::string name;
-      std::string weight;
-      std::string angle;
-      double size;
-      mutable FT_Face face;
-    };
+  private:
+    std::string name;
+    std::string weight;
+    std::string angle;
+    double size;
+    mutable FT_Face face;
+  };
 
   void push_new_line (void);
 
   void update_line_bbox (void);
 
   void compute_bbox (void);
 
   int compute_line_xoffset (const Matrix& lb) const;
diff --git a/libinterp/corefcn/txt-eng.h b/libinterp/corefcn/txt-eng.h
--- a/libinterp/corefcn/txt-eng.h
+++ b/libinterp/corefcn/txt-eng.h
@@ -100,55 +100,54 @@ public:
   void accept (text_processor& p);
 
 private:
   int symbol;
 };
 
 class
 OCTINTERP_API
-text_element_list :
-    public text_element,
-    public octave_base_list<text_element *>
+text_element_list
+  : public text_element, public octave_base_list<text_element *>
 {
 public:
   text_element_list (void)
     : text_element (), octave_base_list<text_element*> () { }
 
   text_element_list (text_element* e)
     : text_element (), octave_base_list<text_element*> ()
-    { push_back (e); }
+  { push_back (e); }
 
   ~text_element_list (void)
-    {
-      while (! empty ())
-        {
-          iterator it = begin ();
-          delete (*it);
-          erase (it);
-        }
-    }
+  {
+    while (! empty ())
+      {
+        iterator it = begin ();
+        delete (*it);
+        erase (it);
+      }
+  }
 
   void accept (text_processor& p);
 };
 
 class
 OCTINTERP_API
 text_element_subscript : public text_element
 {
 public:
   text_element_subscript (text_element* e)
     : text_element (), elem (e) { }
 
   text_element_subscript (char c)
     : text_element ()
-    { elem = new text_element_string (std::string (1, c)); }
+  { elem = new text_element_string (std::string (1, c)); }
 
   ~text_element_subscript (void)
-    { delete elem; }
+  { delete elem; }
 
   void accept (text_processor& p);
 
   text_element* get_element (void) { return elem; }
 
 private:
   text_element* elem;
 
@@ -161,20 +160,20 @@ OCTINTERP_API
 text_element_superscript : public text_element
 {
 public:
   text_element_superscript (text_element* e)
     : text_element (), elem (e) { }
 
   text_element_superscript (char c)
     : text_element ()
-    { elem = new text_element_string (std::string (1, c)); }
+  { elem = new text_element_string (std::string (1, c)); }
 
   ~text_element_superscript (void)
-    { delete elem; }
+  { delete elem; }
 
   void accept (text_processor& p);
 
   text_element* get_element (void) { return elem; }
 
 private:
   text_element* elem;
 
@@ -187,33 +186,33 @@ OCTINTERP_API
 text_element_combined : public text_element_list
 {
 public:
   text_element_combined (text_element* e)
     : text_element_list (e) { }
 
   text_element_combined (text_element* e1, text_element* e2)
     : text_element_list(e1)
-    { push_back (e2); }
+  { push_back (e2); }
 
   void accept (text_processor& p);
 };
 
 class
 OCTINTERP_API
 text_element_fontstyle : public text_element
 {
 public:
   enum fontstyle
-    {
-      normal,
-      bold,
-      italic,
-      oblique
-    };
+  {
+    normal,
+    bold,
+    italic,
+    oblique
+  };
 
   text_element_fontstyle (fontstyle st)
     : text_element (), style (st) { }
 
   ~text_element_fontstyle (void) { }
 
   fontstyle get_fontstyle (void) const { return style; }
 
@@ -270,39 +269,39 @@ private:
 
 class
 OCTINTERP_API
 text_element_color : public text_element
 {
 public:
   text_element_color (double r, double g, double b)
     : text_element (), rgb (1, 3, 0.0)
-    {
-      rgb(0) = r;
-      rgb(1) = g;
-      rgb(2) = b;
-    }
+  {
+    rgb(0) = r;
+    rgb(1) = g;
+    rgb(2) = b;
+  }
 
   text_element_color (const std::string& cname)
     : text_element (), rgb (1, 3, 0.0)
-    {
+  {
 #define ASSIGN_COLOR(r,g,b) { rgb(0) = r; rgb(1) = g; rgb(2) = b; }
-      if (cname == "red") ASSIGN_COLOR(1, 0, 0)
+    if (cname == "red") ASSIGN_COLOR(1, 0, 0)
       else if (cname == "green") ASSIGN_COLOR(0, 1, 0)
-      else if (cname == "yellow") ASSIGN_COLOR(1, 1, 0)
-      else if (cname == "magenta") ASSIGN_COLOR(1, 0, 1)
-      else if (cname == "blue") ASSIGN_COLOR(0, 0, 1)
-      else if (cname == "black") ASSIGN_COLOR(0, 0, 0)
-      else if (cname == "white") ASSIGN_COLOR(1, 1, 1)
-      else if (cname == "gray") ASSIGN_COLOR(.5, .5, .5)
-      else if (cname == "darkGreen") ASSIGN_COLOR(0, .5, 0)
-      else if (cname == "orange") ASSIGN_COLOR(1, .65, 0)
-      else if (cname == "lightBlue") ASSIGN_COLOR(0.68, .85, .9)
+        else if (cname == "yellow") ASSIGN_COLOR(1, 1, 0)
+          else if (cname == "magenta") ASSIGN_COLOR(1, 0, 1)
+            else if (cname == "blue") ASSIGN_COLOR(0, 0, 1)
+              else if (cname == "black") ASSIGN_COLOR(0, 0, 0)
+                else if (cname == "white") ASSIGN_COLOR(1, 1, 1)
+                  else if (cname == "gray") ASSIGN_COLOR(.5, .5, .5)
+                    else if (cname == "darkGreen") ASSIGN_COLOR(0, .5, 0)
+                      else if (cname == "orange") ASSIGN_COLOR(1, .65, 0)
+                        else if (cname == "lightBlue") ASSIGN_COLOR(0.68, .85, .9)
 #undef ASSIGN_COLOR
-    }
+  }
 
   ~text_element_color (void) { }
 
   Matrix get_color (void) { return rgb; }
 
   void accept (text_processor& p);
 
 private:
@@ -314,29 +313,29 @@ OCTINTERP_API
 text_processor
 {
 public:
   virtual void visit (text_element_string& e) = 0;
 
   virtual void visit (text_element_symbol&) { }
 
   virtual void visit (text_element_list& e)
-    {
-      for (text_element_list::iterator it = e.begin ();
-           it != e.end (); ++it)
-        {
-          (*it)->accept (*this);
-        }
-    }
+  {
+    for (text_element_list::iterator it = e.begin ();
+         it != e.end (); ++it)
+      {
+        (*it)->accept (*this);
+      }
+  }
 
   virtual void visit (text_element_subscript& e)
-    { e.get_element ()->accept (*this); }
+  { e.get_element ()->accept (*this); }
 
   virtual void visit (text_element_superscript& e)
-    { e.get_element ()->accept (*this); }
+  { e.get_element ()->accept (*this); }
 
   virtual void visit (text_element_combined&) { }
 
   virtual void visit (text_element_fontstyle&) { }
 
   virtual void visit (text_element_fontname&) { }
 
   virtual void visit (text_element_fontsize&) { }
@@ -393,32 +392,32 @@ public:
   ~text_parser_none (void) { }
 
   // FIXME: is it possible to use reference counting to manage the
   // memory for the object returned by the text parser?  That would be
   // preferable to having to know when and where to delete the object it
   // creates...
 
   text_element* parse (const std::string& s)
-    {
-      return new text_element_string (s);
-    }
+  {
+    return new text_element_string (s);
+  }
 };
 
 class
 OCTINTERP_API
 text_parser_tex : public text_parser
 {
 public:
   text_parser_tex (void)
     : text_parser (), scanner (0), buffer_state (0), result (0)
-    { }
+  { }
 
   ~text_parser_tex (void)
-    { destroy_lexer (); }
+  { destroy_lexer (); }
 
   text_element* parse (const std::string& s);
 
   void* get_scanner (void) { return scanner; }
 
   void set_parse_result (text_element* e) { result = e; }
 
   text_element* get_parse_result (void) { return result; }
diff --git a/libinterp/corefcn/typecast.cc b/libinterp/corefcn/typecast.cc
--- a/libinterp/corefcn/typecast.cc
+++ b/libinterp/corefcn/typecast.cc
@@ -84,17 +84,17 @@ reinterpret_copy (const void *data, octa
     {
       error ("typecast: incorrect number of input values to make output value");
       return ArrayType ();
     }
 }
 
 
 DEFUN (typecast, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} typecast (@var{x}, @var{class})\n\
 Return a new array @var{y} resulting from interpreting the data of\n\
 @var{x} in memory as data of the numeric class @var{class}.  Both the class\n\
 of @var{x} and @var{class} must be one of the built-in numeric classes:\n\
 \n\
 @example\n\
 @group\n\
 \"logical\"\n\
@@ -145,91 +145,111 @@ typecast (@var{x}, \"uint8\")\n\
       unwind_protect frame;
       const void *data = 0;
       octave_idx_type byte_size = 0;
       dim_vector old_dims;
 
       octave_value array = args(0);
 
       if (array.is_bool_type ())
-        get_data_and_bytesize (array.bool_array_value (), data, byte_size, old_dims, frame);
+        get_data_and_bytesize (array.bool_array_value (), data, byte_size,
+                               old_dims, frame);
       else if (array.is_string ())
-        get_data_and_bytesize (array.char_array_value (), data, byte_size, old_dims, frame);
+        get_data_and_bytesize (array.char_array_value (), data, byte_size,
+                               old_dims, frame);
       else if (array.is_integer_type ())
         {
           if (array.is_int8_type ())
-            get_data_and_bytesize (array.int8_array_value (), data, byte_size, old_dims, frame);
+            get_data_and_bytesize (array.int8_array_value (), data, byte_size,
+                                   old_dims, frame);
           else if (array.is_int16_type ())
-            get_data_and_bytesize (array.int16_array_value (), data, byte_size, old_dims, frame);
+            get_data_and_bytesize (array.int16_array_value (), data, byte_size,
+                                   old_dims, frame);
           else if (array.is_int32_type ())
-            get_data_and_bytesize (array.int32_array_value (), data, byte_size, old_dims, frame);
+            get_data_and_bytesize (array.int32_array_value (), data, byte_size,
+                                   old_dims, frame);
           else if (array.is_int64_type ())
-            get_data_and_bytesize (array.int64_array_value (), data, byte_size, old_dims, frame);
+            get_data_and_bytesize (array.int64_array_value (), data, byte_size,
+                                   old_dims, frame);
           else if (array.is_uint8_type ())
-            get_data_and_bytesize (array.uint8_array_value (), data, byte_size, old_dims, frame);
+            get_data_and_bytesize (array.uint8_array_value (), data, byte_size,
+                                   old_dims, frame);
           else if (array.is_uint16_type ())
-            get_data_and_bytesize (array.uint16_array_value (), data, byte_size, old_dims, frame);
+            get_data_and_bytesize (array.uint16_array_value (), data, byte_size,
+                                   old_dims, frame);
           else if (array.is_uint32_type ())
-            get_data_and_bytesize (array.uint32_array_value (), data, byte_size, old_dims, frame);
+            get_data_and_bytesize (array.uint32_array_value (), data, byte_size,
+                                   old_dims, frame);
           else if (array.is_uint64_type ())
-            get_data_and_bytesize (array.uint64_array_value (), data, byte_size, old_dims, frame);
+            get_data_and_bytesize (array.uint64_array_value (), data, byte_size,
+                                   old_dims, frame);
           else
             assert (0);
         }
       else if (array.is_complex_type ())
         {
           if (array.is_single_type ())
-            get_data_and_bytesize (array.float_complex_array_value (), data, byte_size, old_dims, frame);
+            get_data_and_bytesize (array.float_complex_array_value (), data,
+                                   byte_size, old_dims, frame);
           else
-            get_data_and_bytesize (array.complex_array_value (), data, byte_size, old_dims, frame);
+            get_data_and_bytesize (array.complex_array_value (), data,
+                                   byte_size, old_dims, frame);
         }
       else if (array.is_real_type ())
         {
           if (array.is_single_type ())
-            get_data_and_bytesize (array.float_array_value (), data, byte_size, old_dims, frame);
+            get_data_and_bytesize (array.float_array_value (), data, byte_size,
+                                   old_dims, frame);
           else
-            get_data_and_bytesize (array.array_value (), data, byte_size, old_dims, frame);
-        }
+            get_data_and_bytesize (array.array_value (), data, byte_size,
+                                   old_dims, frame); }
       else
-        error ("typecast: invalid input class: %s", array.class_name ().c_str ());
+        error ("typecast: invalid input class: %s",
+                                                array.class_name ().c_str ());
 
       std::string numclass = args(1).string_value ();
 
       if (error_state || numclass.size () == 0)
         ;
       else if (numclass == "char")
-        retval = octave_value (reinterpret_copy<charNDArray> (data, byte_size, old_dims), array.is_dq_string () ? '"' : '\'');
+        retval = octave_value (reinterpret_copy<charNDArray>
+                   (data, byte_size, old_dims), array.is_dq_string () ? '"'
+                                                                      : '\'');
       else if (numclass[0] == 'i')
         {
           if (numclass == "int8")
             retval = reinterpret_copy<int8NDArray> (data, byte_size, old_dims);
           else if (numclass == "int16")
             retval = reinterpret_copy<int16NDArray> (data, byte_size, old_dims);
           else if (numclass == "int32")
             retval = reinterpret_copy<int32NDArray> (data, byte_size, old_dims);
           else if (numclass == "int64")
             retval = reinterpret_copy<int64NDArray> (data, byte_size, old_dims);
         }
       else if (numclass[0] == 'u')
         {
           if (numclass == "uint8")
             retval = reinterpret_copy<uint8NDArray> (data, byte_size, old_dims);
           else if (numclass == "uint16")
-            retval = reinterpret_copy<uint16NDArray> (data, byte_size, old_dims);
+            retval = reinterpret_copy<uint16NDArray> (data, byte_size,
+                                                      old_dims);
           else if (numclass == "uint32")
-            retval = reinterpret_copy<uint32NDArray> (data, byte_size, old_dims);
+            retval = reinterpret_copy<uint32NDArray> (data, byte_size,
+                                                      old_dims);
           else if (numclass == "uint64")
-            retval = reinterpret_copy<uint64NDArray> (data, byte_size, old_dims);
+            retval = reinterpret_copy<uint64NDArray> (data, byte_size,
+                                                      old_dims);
         }
       else if (numclass == "single")
         retval = reinterpret_copy<FloatNDArray> (data, byte_size, old_dims);
       else if (numclass == "double")
         retval = reinterpret_copy<NDArray> (data, byte_size, old_dims);
       else if (numclass == "single complex")
-        retval = reinterpret_copy<FloatComplexNDArray> (data, byte_size, old_dims);
+        retval = reinterpret_copy<FloatComplexNDArray> (data, byte_size,
+                                                        old_dims);
       else if (numclass == "double complex")
         retval = reinterpret_copy<ComplexNDArray> (data, byte_size, old_dims);
 
       if (! error_state && retval.is_undefined ())
         error ("typecast: cannot convert to %s class", numclass.c_str ());
     }
   else
     print_usage ();
@@ -237,17 +257,18 @@ typecast (@var{x}, \"uint8\")\n\
   return retval;
 }
 
 template <class ArrayType>
 ArrayType
 do_bitpack (const boolNDArray& bitp)
 {
   typedef typename ArrayType::element_type T;
-  octave_idx_type n = bitp.numel () / (sizeof (T) * std::numeric_limits<unsigned char>::digits);
+  octave_idx_type n
+    = bitp.numel () / (sizeof (T) * std::numeric_limits<unsigned char>::digits);
 
   if (n * static_cast<int> (sizeof (T)) * std::numeric_limits<unsigned char>::digits == bitp.numel ())
     {
 
       ArrayType retval (get_vec_dims (bitp.dims (), n));
 
       const bool *bits = bitp.fortran_vec ();
       char *packed = reinterpret_cast<char *> (retval.fortran_vec ());
@@ -269,17 +290,17 @@ do_bitpack (const boolNDArray& bitp)
   else
     {
       error ("bitpack: incorrect number of bits to make up output value");
       return ArrayType ();
     }
 }
 
 DEFUN (bitpack, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{y} =} bitpack (@var{x}, @var{class})\n\
 Return a new array @var{y} resulting from interpreting an array\n\
 @var{x} as raw bit patterns for data of the numeric class @var{class}.\n\
 @var{class} must be one of the built-in numeric classes:\n\
 \n\
 @example\n\
 @group\n\
 \"char\"\n\
@@ -356,17 +377,18 @@ it is a column vector.\n\
   return retval;
 }
 
 template <class ArrayType>
 boolNDArray
 do_bitunpack (const ArrayType& array)
 {
   typedef typename ArrayType::element_type T;
-  octave_idx_type n = array.numel () * sizeof (T) * std::numeric_limits<unsigned char>::digits;
+  octave_idx_type n = array.numel () * sizeof (T)
+                      * std::numeric_limits<unsigned char>::digits;
 
   boolNDArray retval (get_vec_dims (array.dims (), n));
 
   const char *packed = reinterpret_cast<const char *> (array.fortran_vec ());
   bool *bits = retval.fortran_vec ();
 
   octave_idx_type m = n / std::numeric_limits<unsigned char>::digits;
 
@@ -378,17 +400,17 @@ do_bitunpack (const ArrayType& array)
         bits[j] = (c >>= 1) & 1;
       bits += std::numeric_limits<unsigned char>::digits;
     }
 
   return retval;
 }
 
 DEFUN (bitunpack, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{y} =} bitunpack (@var{x})\n\
 Return an array @var{y} corresponding to the raw bit patterns of\n\
 @var{x}.  @var{x} must belong to one of the built-in numeric classes:\n\
 \n\
 @example\n\
 @group\n\
 \"char\"\n\
 \"int8\"\n\
@@ -406,17 +428,18 @@ Return an array @var{y} corresponding to
 \n\
 The result is a row vector if @var{x} is a row vector; otherwise, it is a\n\
 column vector.\n\
 @seealso{bitpack, typecast}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  if (args.length () == 1 && (args(0).is_numeric_type () || args(0).is_string ()))
+  if (args.length () == 1
+      && (args(0).is_numeric_type () || args(0).is_string ()))
     {
       octave_value array = args(0);
 
       if (array.is_string ())
         retval = do_bitunpack (array.char_array_value ());
       else if (array.is_integer_type ())
         {
           if (array.is_int8_type ())
@@ -448,15 +471,16 @@ column vector.\n\
       else if (array.is_real_type ())
         {
           if (array.is_single_type ())
             retval = do_bitunpack (array.float_array_value ());
           else
             retval = do_bitunpack (array.array_value ());
         }
       else
-        error ("bitunpack: invalid input class: %s", array.class_name ().c_str ());
+        error ("bitunpack: invalid input class: %s",
+                                                 array.class_name ().c_str ());
     }
   else
     print_usage ();
 
   return retval;
 }
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -88,35 +88,34 @@ public:
 
     return retval;
   }
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
 
   static curl_handle get_handle (void)
   {
-    return instance_ok ()
-      ? instance->do_get_handle () : curl_handle ();
+    return instance_ok () ? instance->do_get_handle () : curl_handle ();
   }
 
   static void free (const curl_handle& h)
   {
     if (instance_ok ())
       instance->do_free (h);
   }
 
   static curl_handle lookup (double val)
   {
     return instance_ok () ? instance->do_lookup (val) : curl_handle ();
   }
 
   static curl_handle lookup (const octave_value& val)
   {
-    return val.is_real_scalar ()
-      ? lookup (val.double_value ()) : curl_handle ();
+    return val.is_real_scalar () ? lookup (val.double_value ())
+                                 : curl_handle ();
   }
 
   static url_transfer get_object (double val)
   {
     return get_object (lookup (val));
   }
 
   static url_transfer get_object (const octave_value& val)
@@ -130,17 +129,18 @@ public:
   }
 
   static curl_handle make_curl_handle (const std::string& host,
                                        const std::string& user,
                                        const std::string& passwd,
                                        std::ostream& os)
   {
     return instance_ok ()
-      ? instance->do_make_curl_handle (host, user, passwd, os) : curl_handle ();
+             ? instance->do_make_curl_handle (host, user, passwd, os)
+             : curl_handle ();
   }
 
   static Matrix handle_list (void)
   {
     return instance_ok () ? instance->do_handle_list () : Matrix ();
   }
 
 private:
@@ -268,27 +268,28 @@ ch_manager::do_free (const curl_handle& 
           // Curl handles are negative integers plus some random
           // fractional part.  To avoid running out of integers, we
           // recycle the integer part but tack on a new random part
           // each time.
 
           handle_map.erase (p);
 
           if (h.value () < 0)
-            handle_free_list.insert (std::ceil (h.value ()) - make_handle_fraction ());
+            handle_free_list.insert
+             (std::ceil (h.value ()) - make_handle_fraction ());
         }
       else
         error ("ch_manager::free: invalid object %g", h.value ());
     }
 }
 
 ch_manager *ch_manager::instance = 0;
 
 DEFUN (urlwrite, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} urlwrite (@var{url}, @var{localfile})\n\
 @deftypefnx {Loadable Function} {@var{f} =} urlwrite (@var{url}, @var{localfile})\n\
 @deftypefnx {Loadable Function} {[@var{f}, @var{success}] =} urlwrite (@var{url}, @var{localfile})\n\
 @deftypefnx {Loadable Function} {[@var{f}, @var{success}, @var{message}] =} urlwrite (@var{url}, @var{localfile})\n\
 Download a remote file specified by its @var{url} and save it as\n\
 @var{localfile}.  For example:\n\
 \n\
 @example\n\
@@ -437,17 +438,17 @@ urlwrite (\"http://www.google.com/search
 
   if (nargout < 2 && ! curl.good ())
     error ("urlwrite: %s", curl.lasterror ().c_str ());
 
   return retval;
 }
 
 DEFUN (urlread, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{s} =} urlread (@var{url})\n\
 @deftypefnx {Loadable Function} {[@var{s}, @var{success}] =} urlread (@var{url})\n\
 @deftypefnx {Loadable Function} {[@var{s}, @var{success}, @var{message}] =} urlread (@var{url})\n\
 @deftypefnx {Loadable Function} {[@dots{}] =} urlread (@var{url}, @var{method}, @var{param})\n\
 Download a remote file specified by its @var{url} and return its content\n\
 in string @var{s}.  For example:\n\
 \n\
 @example\n\
@@ -554,17 +555,17 @@ s = urlread (\"http://www.google.com/sea
 
   if (nargout < 2 && ! curl.good ())
     error ("urlread: %s", curl.lasterror().c_str());
 
   return retval;
 }
 
 DEFUN (__ftp__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{handle} =} __ftp__ (@var{host})\n\
 @deftypefnx {Loadable Function} {@var{handle} =} __ftp__ (@var{host}, @var{username}, @var{password})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
@@ -596,17 +597,17 @@ Undocumented internal function\n\
             retval = ch.value ();
         }
     }
 
   return retval;
 }
 
 DEFUN (__ftp_pwd__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_pwd__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -624,17 +625,17 @@ Undocumented internal function\n\
       else
         error ("__ftp_pwd__: invalid ftp handle");
     }
 
   return retval;
 }
 
 DEFUN (__ftp_cwd__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_cwd__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -662,17 +663,17 @@ Undocumented internal function\n\
       else
         error ("__ftp_cwd__: invalid ftp handle");
     }
 
   return retval;
 }
 
 DEFUN (__ftp_dir__, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_dir__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -743,17 +744,17 @@ Undocumented internal function\n\
       else
         error ("__ftp_dir__: invalid ftp handle");
     }
 
   return retval;
 }
 
 DEFUN (__ftp_ascii__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_ascii__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -771,17 +772,17 @@ Undocumented internal function\n\
       else
         error ("__ftp_ascii__: invalid ftp handle");
     }
 
   return retval;
 }
 
 DEFUN (__ftp_binary__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_binary__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -799,17 +800,17 @@ Undocumented internal function\n\
       else
         error ("__ftp_binary__: invalid ftp handle");
     }
 
   return retval;
 }
 
 DEFUN (__ftp_close__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_close__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -827,17 +828,17 @@ Undocumented internal function\n\
       else
         error ("__ftp_close__: invalid ftp handle");
     }
 
   return retval;
 }
 
 DEFUN (__ftp_mode__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_mode__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -855,17 +856,17 @@ Undocumented internal function\n\
       else
         error ("__ftp_binary__: invalid ftp handle");
     }
 
   return retval;
 }
 
 DEFUN (__ftp_delete__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_delete__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -890,17 +891,17 @@ Undocumented internal function\n\
       else
         error ("__ftp_delete__: invalid ftp handle");
     }
 
   return retval;
 }
 
 DEFUN (__ftp_rmdir__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_rmdir__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -925,17 +926,17 @@ Undocumented internal function\n\
       else
         error ("__ftp_rmdir__: invalid ftp handle");
     }
 
   return retval;
 }
 
 DEFUN (__ftp_mkdir__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_mkdir__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -960,17 +961,17 @@ Undocumented internal function\n\
       else
         error ("__ftp_mkdir__: invalid ftp handle");
     }
 
   return retval;
 }
 
 DEFUN (__ftp_rename__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_rename__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -996,17 +997,17 @@ Undocumented internal function\n\
       else
         error ("__ftp_rename__: invalid ftp handle");
     }
 
   return retval;
 }
 
 DEFUN (__ftp_mput__, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_mput__ (@var{handle}, @var{files})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -1087,17 +1088,17 @@ Undocumented internal function\n\
       else
         error ("__ftp_mput__: invalid ftp handle");
     }
 
   return retval;
 }
 
 DEFUN (__ftp_mget__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_mget__ (@var{handle}, @var{files})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -72,33 +72,33 @@ along with Octave; see the file COPYING.
 #include "variables.h"
 
 // Return TRUE if S is a valid identifier.
 
 bool
 valid_identifier (const char *s)
 {
   if (! s || ! (isalpha (*s) || *s == '_' || *s == '$'))
-     return false;
+    return false;
 
   while (*++s != '\0')
     if (! (isalnum (*s) || *s == '_' || *s == '$'))
       return false;
 
   return true;
 }
 
 bool
 valid_identifier (const std::string& s)
 {
   return valid_identifier (s.c_str ());
 }
 
 DEFUN (isvarname, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isvarname (@var{name})\n\
 Return true if @var{name} is a valid variable name.\n\
 @seealso{iskeyword, exist, who}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   int nargin = args.length ();
@@ -146,17 +146,18 @@ almost_match (const std::string& std, co
           && (case_sens
               ? (strncmp (std.c_str (), s.c_str (), slen) == 0)
               : (octave_strncasecmp (std.c_str (), s.c_str (), slen) == 0)));
 }
 
 // Ugh.
 
 int
-keyword_almost_match (const char * const *std, int *min_len, const std::string& s,
+keyword_almost_match (const char * const *std, int *min_len,
+                      const std::string& s,
                       int min_toks_to_match, int max_toks)
 {
   int status = 0;
   int tok_count = 0;
   int toks_matched = 0;
 
   if (s.empty () || max_toks < 1)
     return status;
@@ -224,17 +225,17 @@ keyword_almost_match (const char * const
           status = (toks_matched >= min_toks_to_match);
           goto done;
         }
 
       if (! *s1)
         goto done;
     }
 
- done:
+done:
 
   delete [] kw;
   delete [] to_match;
 
   return status;
 }
 
 // Return non-zero if either NR or NC is zero.  Return -1 if this
@@ -282,17 +283,17 @@ make_absolute (const string_vector& sv)
 
   for (octave_idx_type i = 0; i < len; i++)
     retval[i] = octave_env::make_absolute (sv[i]);
 
   return retval;
 }
 
 DEFUN (file_in_loadpath, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} file_in_loadpath (@var{file})\n\
 @deftypefnx {Built-in Function} {} file_in_loadpath (@var{file}, \"all\")\n\
 \n\
 Return the absolute name of @var{file} if it can be found in\n\
 the list of directories specified by @code{path}.\n\
 If no file is found, return an empty character string.\n\
 \n\
 If the first argument is a cell array of strings, search each\n\
@@ -311,17 +312,18 @@ name in the path.  If no files are found
 
   if (nargin == 1 || nargin == 2)
     {
       string_vector names = args(0).all_strings ();
 
       if (! error_state && names.length () > 0)
         {
           if (nargin == 1)
-            retval = octave_env::make_absolute (load_path::find_first_of (names));
+            retval =
+              octave_env::make_absolute (load_path::find_first_of (names));
           else if (nargin == 2)
             {
               std::string opt = args(1).string_value ();
 
               if (! error_state && opt == "all")
                 retval = Cell (make_absolute
                                (load_path::find_all_first_of (names)));
               else
@@ -351,17 +353,17 @@ name in the path.  If no files are found
 %! lst = file_in_loadpath ("$$probably_!!_not_&&_a_!!_file$$", "all");
 %! assert (lst, {});
 
 %!error file_in_loadpath ()
 %!error file_in_loadpath ("foo", "bar", 1)
 */
 
 DEFUN (file_in_path, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} file_in_path (@var{path}, @var{file})\n\
 @deftypefnx {Built-in Function} {} file_in_path (@var{path}, @var{file}, \"all\")\n\
 Return the absolute name of @var{file} if it can be found in\n\
 @var{path}.  The value of @var{path} should be a colon-separated list of\n\
 directories in the format described for @code{path}.  If no file\n\
 is found, return an empty character string.  For example:\n\
 \n\
 @example\n\
@@ -645,17 +647,17 @@ do_string_escapes (const std::string& s)
     }
 
   retval.resize (i);
 
   return retval;
 }
 
 DEFUN (do_string_escapes, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} do_string_escapes (@var{string})\n\
 Convert special characters in @var{string} to their escaped forms.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -743,17 +745,17 @@ undo_string_escapes (const std::string& 
 
   for (size_t i = 0; i < s.length (); i++)
     retval.append (undo_string_escape (s[i]));
 
   return retval;
 }
 
 DEFUN (undo_string_escapes, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} undo_string_escapes (@var{s})\n\
 Convert special characters in strings back to their escaped forms.  For\n\
 example, the expression\n\
 \n\
 @example\n\
 bell = \"\\a\";\n\
 @end example\n\
 \n\
@@ -804,17 +806,17 @@ representation.\n\
 %!assert (undo_string_escapes (char ([7, 8, 12, 10, 13, 9, 11])),
 %!        "\\a\\b\\f\\n\\r\\t\\v")
 
 %!error undo_string_escapes ()
 %!error undo_string_escapes ("foo", "bar")
 */
 
 DEFUN (is_absolute_filename, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_absolute_filename (@var{file})\n\
 Return true if @var{file} is an absolute filename.\n\
 @seealso{is_rooted_relative_filename, make_absolute_filename, isdir}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
@@ -829,17 +831,17 @@ Return true if @var{file} is an absolute
 /*
 ## FIXME: We need system-dependent tests here.
 
 %!error is_absolute_filename ()
 %!error is_absolute_filename ("foo", "bar")
 */
 
 DEFUN (is_rooted_relative_filename, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_rooted_relative_filename (@var{file})\n\
 Return true if @var{file} is a rooted-relative filename.\n\
 @seealso{is_absolute_filename, make_absolute_filename, isdir}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 1)
@@ -854,17 +856,17 @@ Return true if @var{file} is a rooted-re
 /*
 ## FIXME: We need system-dependent tests here.
 
 %!error is_rooted_relative_filename ()
 %!error is_rooted_relative_filename ("foo", "bar")
 */
 
 DEFUN (make_absolute_filename, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} make_absolute_filename (@var{file})\n\
 Return the full name of @var{file} beginning from the root of the file\n\
 system.  No check is done for the existence of @var{file}.\n\
 @seealso{canonicalize_file_name, is_absolute_filename, is_rooted_relative_filename, isdir}\n\
 @end deftypefn")
 {
   octave_value retval = std::string ();
 
@@ -886,17 +888,17 @@ system.  No check is done for the existe
 /*
 ## FIXME: We need system-dependent tests here.
 
 %!error make_absolute_filename ()
 %!error make_absolute_filename ("foo", "bar")
 */
 
 DEFUN (find_dir_in_path, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} find_dir_in_path (@var{dir})\n\
 @deftypefnx {Built-in Function} {} find_dir_in_path (@var{dir}, \"all\")\n\
 Return the full name of the path element matching @var{dir}.  The\n\
 match is performed at the end of each path element.  For example, if\n\
 @var{dir} is @qcode{\"foo/bar\"}, it matches the path element\n\
 @nospell{@qcode{\"/some/dir/foo/bar\"}}, but not\n\
 @nospell{@qcode{\"/some/dir/foo/bar/baz\"}}\n\
 @nospell{@qcode{\"/some/dir/allfoo/bar\"}}.\n\
@@ -934,17 +936,17 @@ containing all name matches rather than 
 /*
 ## FIXME: We need system-dependent tests here.
 
 %!error find_dir_in_path ()
 %!error find_dir_in_path ("foo", "bar", 1)
 */
 
 DEFUNX ("errno", Ferrno, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{err} =} errno ()\n\
 @deftypefnx {Built-in Function} {@var{err} =} errno (@var{val})\n\
 @deftypefnx {Built-in Function} {@var{err} =} errno (@var{name})\n\
 Return the current value of the system-dependent variable errno,\n\
 set its value to @var{val} and return the previous value, or return\n\
 the named error code given @var{name} as a character string, or -1\n\
 if @var{name} is not found.\n\
 @end deftypefn")
@@ -993,17 +995,17 @@ if @var{name} is not found.\n\
 %! errno (oldval);
 %! newval = errno ();
 %! assert (oldval, newval);
 
 %!error errno ("foo", 1)
 */
 
 DEFUN (errno_list, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} errno_list ()\n\
 Return a structure containing the system-dependent errno values.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 0)
     retval = octave_errno::list ();
@@ -1275,17 +1277,17 @@ octave_sleep (double seconds)
       octave_sleep (sec);
       octave_usleep (usec);
 
       octave_quit ();
     }
 }
 
 DEFUN (isindex, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} isindex (@var{ind})\n\
 @deftypefnx {Built-in Function} {} isindex (@var{ind}, @var{n})\n\
 Return true if @var{ind} is a valid index.  Valid indices are\n\
 either positive integers (although possibly of real data type), or logical\n\
 arrays.  If present, @var{n} specifies the maximum extent of the dimension\n\
 to be indexed.  When possible the internal result is cached so that\n\
 subsequent indexing using @var{ind} will not perform the check again.\n\
 @end deftypefn")
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -286,18 +286,17 @@ generate_struct_completions (const std::
           if (tmp.is_defined () && (tmp.is_map () || tmp.is_java ()))
             names = tmp.map_keys ();
         }
     }
 
   return names;
 }
 
-// FIXME -- this will have to be much smarter to work
-// "correctly".
+// FIXME: this will have to be much smarter to work "correctly".
 
 bool
 looks_like_struct (const std::string& text)
 {
   bool retval = (! text.empty ()
                  && text != "."
                  && text.find_first_of (file_ops::dir_sep_chars ()) == std::string::npos
                  && text.find ("..") == std::string::npos
@@ -348,17 +347,17 @@ do_isglobal (const octave_value_list& ar
       error ("isglobal: NAME must be a string");
       return retval;
     }
 
   return symbol_table::is_global (name);
 }
 
 DEFUN (isglobal, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isglobal (@var{name})\n\
 Return true if @var{name} is a globally visible variable.\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 global x\n\
 isglobal (\"x\")\n\
@@ -513,17 +512,17 @@ unique_symbol_name (const std::string& b
 
   while (symbol_exist (nm, "any"))
     nm.insert (pos++, 1, alpha[GET_IDX (len)]);
 
   return nm;
 }
 
 DEFUN (exist, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} exist (@var{name}, @var{type})\n\
 Return 1 if the name exists as a variable, 2 if the name is an\n\
 absolute file name, an ordinary file in Octave's @code{path}, or (after\n\
 appending @samp{.m}) a function file in Octave's @code{path}, 3 if the\n\
 name is a @samp{.oct} or @samp{.mex} file in Octave's @code{path},\n\
 5 if the name is a built-in function, 7 if the name is a directory, or 103\n\
 if the name is a function not associated with a file (entered on\n\
 the command line).\n\
@@ -946,38 +945,44 @@ print_descriptor (std::ostream& os, std:
       whos_parameter param = *i;
 
       if (param.command != '\0')
         {
           // Do the actual printing
           switch (param.modifier)
             {
             case 'l':
-              os << std::setiosflags (std::ios::left) << std::setw (param.parameter_length);
-              param_buf << std::setiosflags (std::ios::left) << std::setw (param.parameter_length);
+              os << std::setiosflags (std::ios::left)
+                 << std::setw (param.parameter_length);
+              param_buf << std::setiosflags (std::ios::left)
+                        << std::setw (param.parameter_length);
               break;
 
             case 'r':
-              os << std::setiosflags (std::ios::right) << std::setw (param.parameter_length);
-              param_buf << std::setiosflags (std::ios::right) << std::setw (param.parameter_length);
+              os << std::setiosflags (std::ios::right)
+                 << std::setw (param.parameter_length);
+              param_buf << std::setiosflags (std::ios::right)
+                        << std::setw (param.parameter_length);
               break;
 
             case 'c':
               if (param.command != 's')
                 {
                   os << std::setiosflags (std::ios::left)
                      << std::setw (param.parameter_length);
                   param_buf << std::setiosflags (std::ios::left)
                             << std::setw (param.parameter_length);
                 }
               break;
 
             default:
-              os << std::setiosflags (std::ios::left) << std::setw (param.parameter_length);
-              param_buf << std::setiosflags (std::ios::left) << std::setw (param.parameter_length);
+              os << std::setiosflags (std::ios::left)
+                 << std::setw (param.parameter_length);
+              param_buf << std::setiosflags (std::ios::left)
+                        << std::setw (param.parameter_length);
             }
 
           if (param.command == 's' && param.modifier == 'c')
             {
               int a, b;
 
               if (param.modifier == 'c')
                 {
@@ -985,21 +990,23 @@ print_descriptor (std::ostream& os, std:
                   a = (a < 0 ? 0 : a);
                   b = param.parameter_length - a - param.text . length ();
                   b = (b < 0 ? 0 : b);
                   os << std::setiosflags (std::ios::left) << std::setw (a)
                      << "" << std::resetiosflags (std::ios::left) << param.text
                      << std::setiosflags (std::ios::left)
                      << std::setw (b) << ""
                      << std::resetiosflags (std::ios::left);
-                  param_buf << std::setiosflags (std::ios::left) << std::setw (a)
-                     << "" << std::resetiosflags (std::ios::left) << param.line
-                     << std::setiosflags (std::ios::left)
-                     << std::setw (b) << ""
-                     << std::resetiosflags (std::ios::left);
+                  param_buf << std::setiosflags (std::ios::left)
+                            << std::setw (a)
+                            << "" << std::resetiosflags (std::ios::left)
+                            << param.line
+                            << std::setiosflags (std::ios::left)
+                            << std::setw (b) << ""
+                            << std::resetiosflags (std::ios::left);
                 }
             }
           else
             {
               os << param.text;
               param_buf << param.line;
             }
           os << std::resetiosflags (std::ios::left)
@@ -1014,17 +1021,17 @@ print_descriptor (std::ostream& os, std:
           param_buf << param.line;
           i++;
         }
     }
 
   os << param_buf.str ();
 }
 
-// FIXME -- This is a bit of a kluge.  We'd like to just use val.dims()
+// FIXME: This is a bit of a kluge.  We'd like to just use val.dims()
 // and if val is an object, expect that dims will call size if it is
 // overloaded by a user-defined method.  But there are currently some
 // unresolved const issues that prevent that solution from working.
 
 std::string
 get_dims_str (const octave_value& val)
 {
   octave_value tmp = val;
@@ -1083,20 +1090,20 @@ private:
                   os << std::setiosflags (std::ios::right)
                      << std::setw (param.parameter_length);
                   break;
 
                 case 'c':
                   if (param.command == 's')
                     {
                       int front = param.first_parameter_length
-                        - dims_str.find ('x');
+                                  - dims_str.find ('x');
                       int back = param.parameter_length
-                        - dims_str.length ()
-                        - front;
+                                 - dims_str.length ()
+                                 - front;
                       front = (front > 0) ? front : 0;
                       back = (back > 0) ? back : 0;
 
                       os << std::setiosflags (std::ios::left)
                          << std::setw (front)
                          << ""
                          << std::resetiosflags (std::ios::left)
                          << dims_str
@@ -1403,17 +1410,17 @@ public:
             pos = cmd.find (';');
             if (pos != std::string::npos)
               cmd = cmd.substr (0, pos+1);
             else
               error ("parameter without ; in whos_line_format");
 
             idx += cmd.length ();
 
-            // FIXME -- use iostream functions instead of sscanf!
+            // FIXME: use iostream functions instead of sscanf!
 
             if (cmd.find_first_of ("crl") != 1)
               items = sscanf (cmd.c_str (), "%c%c:%d:%d:%d;",
                               &garbage, &param.command, &a, &b, &balance);
             else
               items = sscanf (cmd.c_str (), "%c%c%c:%d:%d:%d;",
                               &garbage, &param.modifier, &param.command,
                               &a, &b, &balance) - 1;
@@ -1578,17 +1585,17 @@ do_who (int argc, const string_vector& a
 
               frame.add_fcn (symbol_table::clear_variables);
 
               feval ("load", octave_value (nm), 0);
 
               if (! error_state)
                 {
                   std::string newmsg = std::string ("Variables in the file ") +
-                    nm + ":\n\n";
+                                       nm + ":\n\n";
 
                   retval =  do_who (i, argv, return_list, verbose, newmsg);
                 }
             }
 
           return retval;
         }
       else if (argv[i] == "-regexp")
@@ -1624,18 +1631,18 @@ do_who (int argc, const string_vector& a
       std::string pat = pats[j];
 
       if (have_regexp)
         {
           std::list<symbol_table::symbol_record> tmp = global_only
             ? symbol_table::regexp_global_variables (pat)
             : symbol_table::regexp_variables (pat);
 
-          for (std::list<symbol_table::symbol_record>::const_iterator p = tmp.begin ();
-               p != tmp.end (); p++)
+          for (std::list<symbol_table::symbol_record>::const_iterator
+               p = tmp.begin (); p != tmp.end (); p++)
             {
               if (p->is_variable ())
                 {
                   if (verbose)
                     symbol_stats.append (*p);
                   else
                     symbol_names.push_back (p->name ());
                 }
@@ -1679,18 +1686,18 @@ do_who (int argc, const string_vector& a
                 }
             }
           else
             {
               std::list<symbol_table::symbol_record> tmp = global_only
                 ? symbol_table::glob_global_variables (pat)
                 : symbol_table::glob_variables (pat);
 
-              for (std::list<symbol_table::symbol_record>::const_iterator p = tmp.begin ();
-                   p != tmp.end (); p++)
+              for (std::list<symbol_table::symbol_record>::const_iterator
+                   p = tmp.begin (); p != tmp.end (); p++)
                 {
                   if (p->is_variable ())
                     {
                       if (verbose)
                         symbol_stats.append (*p);
                       else
                         symbol_names.push_back (p->name ());
                     }
@@ -1734,17 +1741,17 @@ do_who (int argc, const string_vector& a
 
       octave_stdout << "\n";
     }
 
   return retval;
 }
 
 DEFUN (who, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Command} {} who\n\
 @deftypefnx {Command} {} who pattern @dots{}\n\
 @deftypefnx {Command} {} who option pattern @dots{}\n\
 @deftypefnx {Command} {C =} who (\"pattern\", @dots{})\n\
 List currently defined variables matching the given patterns.  Valid\n\
 pattern syntax is the same as described for the @code{clear} command.\n\
 If no patterns are supplied, all variables are listed.\n\
 By default, only variables visible in the local scope are displayed.\n\
@@ -1784,17 +1791,17 @@ matching the given patterns.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (whos, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Command} {} whos\n\
 @deftypefnx {Command} {} whos pattern @dots{}\n\
 @deftypefnx {Command} {} whos option pattern @dots{}\n\
 @deftypefnx {Command} {S =} whos (\"pattern\", @dots{})\n\
 Provide detailed information on currently defined variables matching the\n\
 given patterns.  Options and pattern syntax are the same as for the\n\
 @code{who} command.  Extended information about each variable is\n\
 summarized in a table with the following default entries.\n\
@@ -1941,17 +1948,17 @@ mislocked (const std::string& nm)
       if (fcn)
         retval = fcn->islocked ();
     }
 
   return retval;
 }
 
 DEFUN (mlock, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mlock ()\n\
 Lock the current function into memory so that it can't be cleared.\n\
 @seealso{munlock, mislocked, persistent}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 0)
@@ -1965,17 +1972,17 @@ Lock the current function into memory so
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (munlock, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} munlock ()\n\
 @deftypefnx {Built-in Function} {} munlock (@var{fcn})\n\
 Unlock the named function @var{fcn}.  If no function is named\n\
 then unlock the current function.\n\
 @seealso{mlock, mislocked, persistent}\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -2001,17 +2008,17 @@ then unlock the current function.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 
 DEFUN (mislocked, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} mislocked ()\n\
 @deftypefnx {Built-in Function} {} mislocked (@var{fcn})\n\
 Return true if the named function @var{fcn} is locked.  If no function is\n\
 named then return true if the current function is locked.\n\
 @seealso{mlock, munlock, persistent}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -2190,17 +2197,17 @@ do_clear_symbols (const string_vector& a
                   bool exclusive = false)
 {
   if (idx == argc)
     symbol_table::clear_variables ();
   else
     {
       if (exclusive)
         {
-          // FIXME -- is this really what we want, or do we
+          // FIXME: is this really what we want, or do we
           // somehow want to only clear the functions that are not
           // shadowed by local variables?  It seems that would be a
           // bit harder to do.
 
           do_clear_variables (argv, argc, idx, exclusive);
           do_clear_functions (argv, argc, idx, exclusive);
         }
       else
@@ -2258,17 +2265,17 @@ do_matlab_compatible_clear (const string
         { \
           print_usage (); \
           return retval; \
         } \
     } \
   while (0)
 
 DEFUN (clear, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Command} {} clear [options] pattern @dots{}\n\
 Delete the names matching the given patterns from the symbol table.  The\n\
 pattern may contain the following special characters:\n\
 \n\
 @table @code\n\
 @item ?\n\
 Match any single character.\n\
 \n\
@@ -2463,17 +2470,17 @@ without the dash as well.\n\
             }
         }
     }
 
   return retval;
 }
 
 DEFUN (whos_line_format, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} whos_line_format ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} whos_line_format (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} whos_line_format (@var{new_val}, \"local\")\n\
 Query or set the format string used by the command @code{whos}.\n\
 \n\
 A full format string is:\n\
 @c Set example in small font to prevent overfull line\n\
 \n\
@@ -2541,17 +2548,17 @@ The original variable value is restored 
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (whos_line_format);
 }
 
 static std::string Vmissing_function_hook = "__unimplemented__";
 
 DEFUN (missing_function_hook, args, nargout,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} missing_function_hook ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} missing_function_hook (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} missing_function_hook (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the function to call when\n\
 an unknown identifier is requested.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.  \n\
@@ -2581,17 +2588,17 @@ void maybe_missing_function_hook (const 
 
           // Call.
           feval (func_name, octave_value (name));
         }
     }
 }
 
 DEFUN (__varval__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __varval__ (@var{name})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
@@ -2606,17 +2613,17 @@ Undocumented internal function.\n\
     print_usage ();
 
   return retval;
 }
 
 static std::string Vmissing_component_hook;
 
 DEFUN (missing_component_hook, args, nargout,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} missing_component_hook ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} missing_component_hook (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} missing_component_hook (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the function to call when\n\
 a component of Octave is missing.  This can be useful for packagers that\n\
 may split the Octave installation into multiple sub-packages, for example,\n\
 to provide a hint to users for how to install the missing components.\n\
 \n\
diff --git a/libinterp/corefcn/variables.h b/libinterp/corefcn/variables.h
--- a/libinterp/corefcn/variables.h
+++ b/libinterp/corefcn/variables.h
@@ -69,17 +69,18 @@ extern OCTINTERP_API bool
 looks_like_struct (const std::string& text);
 
 extern OCTINTERP_API int
 symbol_exist (const std::string& name, const std::string& type = "any");
 
 extern OCTINTERP_API std::string
 unique_symbol_name (const std::string& basename);
 
-extern OCTINTERP_API octave_value lookup_function_handle (const std::string& nm);
+extern OCTINTERP_API octave_value
+lookup_function_handle (const std::string& nm);
 
 extern OCTINTERP_API octave_value
 get_global_value (const std::string& nm, bool silent = false);
 
 extern OCTINTERP_API void
 set_global_value (const std::string& nm, const octave_value& val);
 
 extern OCTINTERP_API octave_value
@@ -125,17 +126,18 @@ set_internal_variable (int& var, const o
 #define SET_INTERNAL_VARIABLE_WITH_LIMITS(NM, MINVAL, MAXVAL) \
   set_internal_variable (V ## NM, args, nargout, #NM, MINVAL, MAXVAL)
 
 // in the following, CHOICES must be a C string array terminated by null.
 #define SET_INTERNAL_VARIABLE_CHOICES(NM, CHOICES) \
   set_internal_variable (V ## NM, args, nargout, #NM, CHOICES)
 
 extern OCTINTERP_API std::string builtin_string_variable (const std::string&);
-extern OCTINTERP_API int builtin_real_scalar_variable (const std::string&, double&);
+extern OCTINTERP_API int builtin_real_scalar_variable (const std::string&,
+                                                       double&);
 extern OCTINTERP_API octave_value builtin_any_variable (const std::string&);
 
 extern OCTINTERP_API void bind_ans (const octave_value& val, bool print);
 
 extern OCTINTERP_API void
 bind_internal_variable (const std::string& fname,
                         const octave_value& val) GCC_ATTR_DEPRECATED;
 
diff --git a/libinterp/corefcn/xdiv.cc b/libinterp/corefcn/xdiv.cc
--- a/libinterp/corefcn/xdiv.cc
+++ b/libinterp/corefcn/xdiv.cc
@@ -66,17 +66,18 @@ template <class T1, class T2>
 bool
 mx_leftdiv_conform (const T1& a, const T2& b, blas_trans_type blas_trans)
 {
   octave_idx_type a_nr = blas_trans == blas_no_trans ? a.rows () : a.cols ();
   octave_idx_type b_nr = b.rows ();
 
   if (a_nr != b_nr)
     {
-      octave_idx_type a_nc = blas_trans == blas_no_trans ? a.cols () : a.rows ();
+      octave_idx_type a_nc = blas_trans == blas_no_trans ? a.cols ()
+                                                         : a.rows ();
       octave_idx_type b_nc = b.cols ();
 
       gripe_nonconformant ("operator \\", a_nr, a_nc, b_nr, b_nc);
       return false;
     }
 
   return true;
 }
@@ -345,54 +346,58 @@ x_el_div (const Complex a, const Complex
 //            +--   +---+----+
 //   matrix         | 1 |  3 |
 //                  +---+----+
 //   complex_matrix | 2 |  4 |
 //                  +---+----+
 
 // -*- 1 -*-
 Matrix
-xleftdiv (const Matrix& a, const Matrix& b, MatrixType &typ, blas_trans_type transt)
+xleftdiv (const Matrix& a, const Matrix& b, MatrixType &typ,
+          blas_trans_type transt)
 {
   if (! mx_leftdiv_conform (a, b, transt))
     return Matrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // -*- 2 -*-
 ComplexMatrix
-xleftdiv (const Matrix& a, const ComplexMatrix& b, MatrixType &typ, blas_trans_type transt)
+xleftdiv (const Matrix& a, const ComplexMatrix& b, MatrixType &typ,
+          blas_trans_type transt)
 {
   if (! mx_leftdiv_conform (a, b, transt))
     return ComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
 
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // -*- 3 -*-
 ComplexMatrix
-xleftdiv (const ComplexMatrix& a, const Matrix& b, MatrixType &typ, blas_trans_type transt)
+xleftdiv (const ComplexMatrix& a, const Matrix& b, MatrixType &typ,
+          blas_trans_type transt)
 {
   if (! mx_leftdiv_conform (a, b, transt))
     return ComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // -*- 4 -*-
 ComplexMatrix
-xleftdiv (const ComplexMatrix& a, const ComplexMatrix& b, MatrixType &typ, blas_trans_type transt)
+xleftdiv (const ComplexMatrix& a, const ComplexMatrix& b, MatrixType &typ,
+          blas_trans_type transt)
 {
   if (! mx_leftdiv_conform (a, b, transt))
     return ComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
@@ -643,54 +648,58 @@ x_el_div (const FloatComplex a, const Fl
 //            +--   +---+----+
 //   matrix         | 1 |  3 |
 //                  +---+----+
 //   complex_matrix | 2 |  4 |
 //                  +---+----+
 
 // -*- 1 -*-
 FloatMatrix
-xleftdiv (const FloatMatrix& a, const FloatMatrix& b, MatrixType &typ, blas_trans_type transt)
+xleftdiv (const FloatMatrix& a, const FloatMatrix& b, MatrixType &typ,
+          blas_trans_type transt)
 {
   if (! mx_leftdiv_conform (a, b, transt))
     return FloatMatrix ();
 
   octave_idx_type info;
   float rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // -*- 2 -*-
 FloatComplexMatrix
-xleftdiv (const FloatMatrix& a, const FloatComplexMatrix& b, MatrixType &typ, blas_trans_type transt)
+xleftdiv (const FloatMatrix& a, const FloatComplexMatrix& b, MatrixType &typ,
+          blas_trans_type transt)
 {
   if (! mx_leftdiv_conform (a, b, transt))
     return FloatComplexMatrix ();
 
   octave_idx_type info;
   float rcond = 0.0;
 
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // -*- 3 -*-
 FloatComplexMatrix
-xleftdiv (const FloatComplexMatrix& a, const FloatMatrix& b, MatrixType &typ, blas_trans_type transt)
+xleftdiv (const FloatComplexMatrix& a, const FloatMatrix& b, MatrixType &typ,
+          blas_trans_type transt)
 {
   if (! mx_leftdiv_conform (a, b, transt))
     return FloatComplexMatrix ();
 
   octave_idx_type info;
   float rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // -*- 4 -*-
 FloatComplexMatrix
-xleftdiv (const FloatComplexMatrix& a, const FloatComplexMatrix& b, MatrixType &typ, blas_trans_type transt)
+xleftdiv (const FloatComplexMatrix& a, const FloatComplexMatrix& b,
+          MatrixType &typ, blas_trans_type transt)
 {
   if (! mx_leftdiv_conform (a, b, transt))
     return FloatComplexMatrix ();
 
   octave_idx_type info;
   float rcond = 0.0;
   return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
diff --git a/libinterp/corefcn/xdiv.h b/libinterp/corefcn/xdiv.h
--- a/libinterp/corefcn/xdiv.h
+++ b/libinterp/corefcn/xdiv.h
@@ -43,79 +43,101 @@ extern ComplexMatrix x_el_div (const Com
 extern NDArray x_el_div (double a, const NDArray& b);
 extern ComplexNDArray x_el_div (double a, const ComplexNDArray& b);
 extern ComplexNDArray x_el_div (const Complex a, const NDArray& b);
 extern ComplexNDArray x_el_div (const Complex a, const ComplexNDArray& b);
 
 extern Matrix xleftdiv (const Matrix& a, const Matrix& b, MatrixType &typ,
                         blas_trans_type transt = blas_no_trans);
 extern ComplexMatrix xleftdiv (const Matrix& a, const ComplexMatrix& b,
-                               MatrixType &typ, blas_trans_type transt = blas_no_trans);
+                               MatrixType &typ,
+                               blas_trans_type transt = blas_no_trans);
 extern ComplexMatrix xleftdiv (const ComplexMatrix& a, const Matrix& b,
-                               MatrixType &typ, blas_trans_type transt = blas_no_trans);
+                               MatrixType &typ,
+                               blas_trans_type transt = blas_no_trans);
 extern ComplexMatrix xleftdiv (const ComplexMatrix& a, const ComplexMatrix& b,
-                               MatrixType &typ, blas_trans_type transt = blas_no_trans);
+                               MatrixType &typ,
+                               blas_trans_type transt = blas_no_trans);
 
-extern FloatMatrix xdiv (const FloatMatrix& a, const FloatMatrix& b, MatrixType &typ);
-extern FloatComplexMatrix xdiv (const FloatMatrix& a, const FloatComplexMatrix& b,
-                           MatrixType &typ);
-extern FloatComplexMatrix xdiv (const FloatComplexMatrix& a, const FloatMatrix& b,
-                           MatrixType &typ);
-extern FloatComplexMatrix xdiv (const FloatComplexMatrix& a, const FloatComplexMatrix& b,
-                           MatrixType &typ);
+extern FloatMatrix xdiv (const FloatMatrix& a, const FloatMatrix& b,
+                         MatrixType &typ);
+extern FloatComplexMatrix xdiv (const FloatMatrix& a,
+                                const FloatComplexMatrix& b,
+                                MatrixType &typ);
+extern FloatComplexMatrix xdiv (const FloatComplexMatrix& a,
+                                const FloatMatrix& b,
+                                MatrixType &typ);
+extern FloatComplexMatrix xdiv (const FloatComplexMatrix& a,
+                                const FloatComplexMatrix& b,
+                                MatrixType &typ);
 
 extern FloatMatrix x_el_div (float a, const FloatMatrix& b);
 extern FloatComplexMatrix x_el_div (float a, const FloatComplexMatrix& b);
 extern FloatComplexMatrix x_el_div (const FloatComplex a, const FloatMatrix& b);
-extern FloatComplexMatrix x_el_div (const FloatComplex a, const FloatComplexMatrix& b);
+extern FloatComplexMatrix x_el_div (const FloatComplex a,
+                                    const FloatComplexMatrix& b);
 
 extern FloatNDArray x_el_div (float a, const FloatNDArray& b);
 extern FloatComplexNDArray x_el_div (float a, const FloatComplexNDArray& b);
-extern FloatComplexNDArray x_el_div (const FloatComplex a, const FloatNDArray& b);
-extern FloatComplexNDArray x_el_div (const FloatComplex a, const FloatComplexNDArray& b);
+extern FloatComplexNDArray x_el_div (const FloatComplex a,
+                                     const FloatNDArray& b);
+extern FloatComplexNDArray x_el_div (const FloatComplex a,
+                                     const FloatComplexNDArray& b);
 
-extern FloatMatrix xleftdiv (const FloatMatrix& a, const FloatMatrix& b, MatrixType &typ,
+extern FloatMatrix xleftdiv (const FloatMatrix& a, const FloatMatrix& b,
+                             MatrixType &typ,
                              blas_trans_type transt = blas_no_trans);
-extern FloatComplexMatrix xleftdiv (const FloatMatrix& a, const FloatComplexMatrix& b,
-                               MatrixType &typ, blas_trans_type transt = blas_no_trans);
-extern FloatComplexMatrix xleftdiv (const FloatComplexMatrix& a, const FloatMatrix& b,
-                               MatrixType &typ, blas_trans_type transt = blas_no_trans);
-extern FloatComplexMatrix xleftdiv (const FloatComplexMatrix& a, const FloatComplexMatrix& b,
-                               MatrixType &typ, blas_trans_type transt = blas_no_trans);
+extern FloatComplexMatrix xleftdiv (const FloatMatrix& a,
+                                    const FloatComplexMatrix& b,
+                                    MatrixType &typ,
+                                    blas_trans_type transt = blas_no_trans);
+extern FloatComplexMatrix xleftdiv (const FloatComplexMatrix& a,
+                                    const FloatMatrix& b,
+                                    MatrixType &typ,
+                                    blas_trans_type transt = blas_no_trans);
+extern FloatComplexMatrix xleftdiv (const FloatComplexMatrix& a,
+                                    const FloatComplexMatrix& b,
+                                    MatrixType &typ,
+                                    blas_trans_type transt = blas_no_trans);
 
 
 extern Matrix xdiv (const Matrix& a, const DiagMatrix& b);
 extern ComplexMatrix xdiv (const ComplexMatrix& a, const DiagMatrix& b);
 extern ComplexMatrix xdiv (const ComplexMatrix& a, const ComplexDiagMatrix& b);
 
 extern DiagMatrix xdiv (const DiagMatrix& a, const DiagMatrix& b);
 extern ComplexDiagMatrix xdiv (const ComplexDiagMatrix& a, const DiagMatrix& b);
-extern ComplexDiagMatrix xdiv (const ComplexDiagMatrix& a, const ComplexDiagMatrix& b);
+extern ComplexDiagMatrix xdiv (const ComplexDiagMatrix& a,
+                               const ComplexDiagMatrix& b);
 
 extern FloatMatrix xdiv (const FloatMatrix& a, const FloatDiagMatrix& b);
 extern FloatComplexMatrix xdiv (const FloatComplexMatrix& a,
                                 const FloatDiagMatrix& b);
 extern FloatComplexMatrix xdiv (const FloatMatrix& a,
                                 const FloatComplexDiagMatrix& b);
 extern FloatComplexMatrix xdiv (const FloatComplexMatrix& a,
                                 const FloatComplexDiagMatrix& b);
 
-extern FloatDiagMatrix xdiv (const FloatDiagMatrix& a, const FloatDiagMatrix& b);
+extern FloatDiagMatrix xdiv (const FloatDiagMatrix& a,
+                             const FloatDiagMatrix& b);
 extern FloatComplexDiagMatrix xdiv (const FloatComplexDiagMatrix& a,
                                     const FloatDiagMatrix& b);
 extern FloatComplexDiagMatrix xdiv (const FloatComplexDiagMatrix& a,
                                     const FloatComplexDiagMatrix& b);
 
 extern Matrix xleftdiv (const DiagMatrix& a, const Matrix& b);
 extern ComplexMatrix xleftdiv (const DiagMatrix& a, const ComplexMatrix& b);
-extern ComplexMatrix xleftdiv (const ComplexDiagMatrix& a, const ComplexMatrix& b);
+extern ComplexMatrix xleftdiv (const ComplexDiagMatrix& a,
+                               const ComplexMatrix& b);
 
 extern DiagMatrix xleftdiv (const DiagMatrix& a, const DiagMatrix& b);
-extern ComplexDiagMatrix xleftdiv (const DiagMatrix& a, const ComplexDiagMatrix& b);
-extern ComplexDiagMatrix xleftdiv (const ComplexDiagMatrix& a, const ComplexDiagMatrix& b);
+extern ComplexDiagMatrix xleftdiv (const DiagMatrix& a,
+                                   const ComplexDiagMatrix& b);
+extern ComplexDiagMatrix xleftdiv (const ComplexDiagMatrix& a,
+                                   const ComplexDiagMatrix& b);
 
 extern FloatMatrix xleftdiv (const FloatDiagMatrix& a,
                              const FloatMatrix& b);
 extern FloatComplexMatrix xleftdiv (const FloatDiagMatrix& a,
                                     const FloatComplexMatrix& b);
 extern FloatComplexMatrix xleftdiv (const FloatComplexDiagMatrix& a,
                                     const FloatComplexMatrix& b);
 
diff --git a/libinterp/corefcn/xnorm.h b/libinterp/corefcn/xnorm.h
--- a/libinterp/corefcn/xnorm.h
+++ b/libinterp/corefcn/xnorm.h
@@ -24,14 +24,21 @@ along with Octave; see the file COPYING.
 
 #if !defined (octave_xnorm_h)
 #define octave_xnorm_h 1
 
 #include "oct-norm.h"
 
 class octave_value;
 
-extern OCTINTERP_API octave_value xnorm (const octave_value& x, const octave_value& p);
-extern OCTINTERP_API octave_value xcolnorms (const octave_value& x, const octave_value& p);
-extern OCTINTERP_API octave_value xrownorms (const octave_value& x, const octave_value& p);
-extern OCTINTERP_API octave_value xfrobnorm (const octave_value& x);
+extern OCTINTERP_API octave_value
+xnorm (const octave_value& x, const octave_value& p);
+
+extern OCTINTERP_API octave_value
+xcolnorms (const octave_value& x, const octave_value& p);
+
+extern OCTINTERP_API octave_value
+xrownorms (const octave_value& x, const octave_value& p);
+
+extern OCTINTERP_API octave_value
+xfrobnorm (const octave_value& x);
 
 #endif
diff --git a/libinterp/corefcn/xpow.cc b/libinterp/corefcn/xpow.cc
--- a/libinterp/corefcn/xpow.cc
+++ b/libinterp/corefcn/xpow.cc
@@ -203,18 +203,17 @@ xpow (const Matrix& a, double b)
           int btmp = static_cast<int> (b);
           if (btmp == 0)
             {
               retval = DiagMatrix (nr, nr, 1.0);
             }
           else
             {
               // Too much copying?
-              // FIXME -- we shouldn't do this if the exponent is
-              // large...
+              // FIXME: we shouldn't do this if the exponent is large...
 
               Matrix atmp;
               if (btmp < 0)
                 {
                   btmp = -btmp;
 
                   octave_idx_type info;
                   double rcond = 0.0;
@@ -468,18 +467,17 @@ xpow (const ComplexMatrix& a, double b)
           int btmp = static_cast<int> (b);
           if (btmp == 0)
             {
               retval = DiagMatrix (nr, nr, 1.0);
             }
           else
             {
               // Too much copying?
-              // FIXME -- we shouldn't do this if the exponent is
-              // large...
+              // FIXME: we shouldn't do this if the exponent is large...
 
               ComplexMatrix atmp;
               if (btmp < 0)
                 {
                   btmp = -btmp;
 
                   octave_idx_type info;
                   double rcond = 0.0;
@@ -616,18 +614,17 @@ xpow (const DiagMatrix& a, const Complex
 //                  +---+---+----+----+
 //   complex_scalar | * | 5 |  * | 11 |
 //                  +---+---+----+----+
 //   complex_matrix | 2 | 6 |  8 | 12 |
 //                  +---+---+----+----+
 //
 //   * -> not needed.
 
-// FIXME -- these functions need to be fixed so that things
-// like
+// FIXME: these functions need to be fixed so that things like
 //
 //   a = -1; b = [ 0, 0.5, 1 ]; r = a .^ b
 //
 // and
 //
 //   a = -1; b = [ 0, 0.5, 1 ]; for i = 1:3, r(i) = a .^ b(i), end
 //
 // produce identical results.  Also, it would be nice if -1^0.5
@@ -1098,18 +1095,17 @@ elem_xpow (const ComplexMatrix& a, const
 //                  +---+---+----+----+
 //   complex_scalar | * | 5 |  * | 11 |
 //                  +---+---+----+----+
 //   complex_N_d    | 2 | 6 |  8 | 12 |
 //                  +---+---+----+----+
 //
 //   * -> not needed.
 
-// FIXME -- these functions need to be fixed so that things
-// like
+// FIXME: these functions need to be fixed so that things like
 //
 //   a = -1; b = [ 0, 0.5, 1 ]; r = a .^ b
 //
 // and
 //
 //   a = -1; b = [ 0, 0.5, 1 ]; for i = 1:3, r(i) = a .^ b(i), end
 //
 // produce identical results.  Also, it would be nice if -1^0.5
@@ -1653,18 +1649,17 @@ xpow (const FloatMatrix& a, float b)
           int btmp = static_cast<int> (b);
           if (btmp == 0)
             {
               retval = FloatDiagMatrix (nr, nr, 1.0);
             }
           else
             {
               // Too much copying?
-              // FIXME -- we shouldn't do this if the exponent is
-              // large...
+              // FIXME: we shouldn't do this if the exponent is large...
 
               FloatMatrix atmp;
               if (btmp < 0)
                 {
                   btmp = -btmp;
 
                   octave_idx_type info;
                   float rcond = 0.0;
@@ -1740,17 +1735,18 @@ xpow (const FloatDiagMatrix& a, float b)
           for (octave_idx_type i = 0; i < nc; i++)
             r.dgelem (i) = std::pow (a.dgelem (i), b);
           retval = r;
         }
       else
         {
           FloatComplexDiagMatrix r (nr, nc);
           for (octave_idx_type i = 0; i < nc; i++)
-            r.dgelem (i) = std::pow (static_cast<FloatComplex> (a.dgelem (i)), b);
+            r.dgelem (i) = std::pow (static_cast<FloatComplex> (a.dgelem (i)),
+                                                                b);
           retval = r;
         }
     }
 
   return retval;
 }
 
 // -*- 6 -*-
@@ -1906,18 +1902,17 @@ xpow (const FloatComplexMatrix& a, float
           int btmp = static_cast<int> (b);
           if (btmp == 0)
             {
               retval = FloatDiagMatrix (nr, nr, 1.0);
             }
           else
             {
               // Too much copying?
-              // FIXME -- we shouldn't do this if the exponent is
-              // large...
+              // FIXME: we shouldn't do this if the exponent is large...
 
               FloatComplexMatrix atmp;
               if (btmp < 0)
                 {
                   btmp = -btmp;
 
                   octave_idx_type info;
                   float rcond = 0.0;
@@ -2053,18 +2048,17 @@ xpow (const FloatDiagMatrix& a, const Fl
 //                  +---+---+----+----+
 //   complex_scalar | * | 5 |  * | 11 |
 //                  +---+---+----+----+
 //   complex_matrix | 2 | 6 |  8 | 12 |
 //                  +---+---+----+----+
 //
 //   * -> not needed.
 
-// FIXME -- these functions need to be fixed so that things
-// like
+// FIXME: these functions need to be fixed so that things like
 //
 //   a = -1; b = [ 0, 0.5, 1 ]; r = a .^ b
 //
 // and
 //
 //   a = -1; b = [ 0, 0.5, 1 ]; for i = 1:3, r(i) = a .^ b(i), end
 //
 // produce identical results.  Also, it would be nice if -1^0.5
@@ -2451,18 +2445,17 @@ elem_xpow (const FloatComplexMatrix& a, 
 //                  +---+---+----+----+
 //   complex_scalar | * | 5 |  * | 11 |
 //                  +---+---+----+----+
 //   complex_N_d    | 2 | 6 |  8 | 12 |
 //                  +---+---+----+----+
 //
 //   * -> not needed.
 
-// FIXME -- these functions need to be fixed so that things
-// like
+// FIXME: these functions need to be fixed so that things like
 //
 //   a = -1; b = [ 0, 0.5, 1 ]; r = a .^ b
 //
 // and
 //
 //   a = -1; b = [ 0, 0.5, 1 ]; for i = 1:3, r(i) = a .^ b(i), end
 //
 // produce identical results.  Also, it would be nice if -1^0.5
diff --git a/libinterp/corefcn/xpow.h b/libinterp/corefcn/xpow.h
--- a/libinterp/corefcn/xpow.h
+++ b/libinterp/corefcn/xpow.h
@@ -52,107 +52,152 @@ extern OCTINTERP_API octave_value xpow (
 extern OCTINTERP_API octave_value xpow (const DiagMatrix& a, double b);
 extern OCTINTERP_API octave_value xpow (const DiagMatrix& a, const Complex& b);
 
 extern OCTINTERP_API octave_value xpow (const PermMatrix& a, double b);
 
 extern OCTINTERP_API octave_value xpow (const Complex& a, double b);
 extern OCTINTERP_API octave_value xpow (const Complex& a, const Matrix& b);
 extern OCTINTERP_API octave_value xpow (const Complex& a, const Complex& b);
-extern OCTINTERP_API octave_value xpow (const Complex& a, const ComplexMatrix& b);
+extern OCTINTERP_API octave_value xpow (const Complex& a,
+                                        const ComplexMatrix& b);
 
 extern OCTINTERP_API octave_value xpow (const ComplexMatrix& a, double b);
-extern OCTINTERP_API octave_value xpow (const ComplexMatrix& a, const Complex& b);
+extern OCTINTERP_API octave_value xpow (const ComplexMatrix& a,
+                                        const Complex& b);
 
 extern OCTINTERP_API octave_value xpow (const ComplexDiagMatrix& a, double b);
-extern OCTINTERP_API octave_value xpow (const ComplexDiagMatrix& a, const Complex& b);
+extern OCTINTERP_API octave_value xpow (const ComplexDiagMatrix& a,
+                                        const Complex& b);
 
 extern OCTINTERP_API octave_value elem_xpow (double a, const Matrix& b);
 extern OCTINTERP_API octave_value elem_xpow (double a, const ComplexMatrix& b);
 extern OCTINTERP_API octave_value elem_xpow (double a, const Range& r);
 
 extern OCTINTERP_API octave_value elem_xpow (const Matrix& a, double b);
 extern OCTINTERP_API octave_value elem_xpow (const Matrix& a, const Matrix& b);
 extern OCTINTERP_API octave_value elem_xpow (const Matrix& a, const Complex& b);
-extern OCTINTERP_API octave_value elem_xpow (const Matrix& a, const ComplexMatrix& b);
+extern OCTINTERP_API octave_value elem_xpow (const Matrix& a,
+                                             const ComplexMatrix& b);
 
 extern OCTINTERP_API octave_value elem_xpow (const Complex& a, const Matrix& b);
-extern OCTINTERP_API octave_value elem_xpow (const Complex& a, const ComplexMatrix& b);
+extern OCTINTERP_API octave_value elem_xpow (const Complex& a,
+                                             const ComplexMatrix& b);
 extern OCTINTERP_API octave_value elem_xpow (const Complex& a, const Range& r);
 
 extern OCTINTERP_API octave_value elem_xpow (const ComplexMatrix& a, double b);
-extern OCTINTERP_API octave_value elem_xpow (const ComplexMatrix& a, const Matrix& b);
-extern OCTINTERP_API octave_value elem_xpow (const ComplexMatrix& a, const Complex& b);
-extern OCTINTERP_API octave_value elem_xpow (const ComplexMatrix& a, const ComplexMatrix& b);
+extern OCTINTERP_API octave_value elem_xpow (const ComplexMatrix& a,
+                                             const Matrix& b);
+extern OCTINTERP_API octave_value elem_xpow (const ComplexMatrix& a,
+                                             const Complex& b);
+extern OCTINTERP_API octave_value elem_xpow (const ComplexMatrix& a,
+                                             const ComplexMatrix& b);
 
 
 extern OCTINTERP_API octave_value elem_xpow (double a, const NDArray& b);
 extern OCTINTERP_API octave_value elem_xpow (double a, const ComplexNDArray& b);
 
 extern OCTINTERP_API octave_value elem_xpow (const NDArray& a, double b);
-extern OCTINTERP_API octave_value elem_xpow (const NDArray& a, const NDArray& b);
-extern OCTINTERP_API octave_value elem_xpow (const NDArray& a, const Complex& b);
-extern OCTINTERP_API octave_value elem_xpow (const NDArray& a, const ComplexNDArray& b);
+extern OCTINTERP_API octave_value elem_xpow (const NDArray& a,
+                                             const NDArray& b);
+extern OCTINTERP_API octave_value elem_xpow (const NDArray& a,
+                                             const Complex& b);
+extern OCTINTERP_API octave_value elem_xpow (const NDArray& a,
+                                             const ComplexNDArray& b);
 
-extern OCTINTERP_API octave_value elem_xpow (const Complex& a, const NDArray& b);
-extern OCTINTERP_API octave_value elem_xpow (const Complex& a, const ComplexNDArray& b);
+extern OCTINTERP_API octave_value elem_xpow (const Complex& a,
+                                             const NDArray& b);
+extern OCTINTERP_API octave_value elem_xpow (const Complex& a,
+                                             const ComplexNDArray& b);
 
-extern OCTINTERP_API octave_value elem_xpow (const ComplexNDArray& a, double b);
-extern OCTINTERP_API octave_value elem_xpow (const ComplexNDArray& a, const NDArray& b);
-extern OCTINTERP_API octave_value elem_xpow (const ComplexNDArray& a, const Complex& b);
-extern OCTINTERP_API octave_value elem_xpow (const ComplexNDArray& a, const ComplexNDArray& b);
+extern OCTINTERP_API octave_value elem_xpow (const ComplexNDArray& a,
+                                             double b);
+extern OCTINTERP_API octave_value elem_xpow (const ComplexNDArray& a,
+                                             const NDArray& b);
+extern OCTINTERP_API octave_value elem_xpow (const ComplexNDArray& a,
+                                             const Complex& b);
+extern OCTINTERP_API octave_value elem_xpow (const ComplexNDArray& a,
+                                             const ComplexNDArray& b);
 
 extern OCTINTERP_API octave_value xpow (float a, float b);
 extern OCTINTERP_API octave_value xpow (float a, const FloatMatrix& b);
 extern OCTINTERP_API octave_value xpow (float a, const FloatComplex& b);
 extern OCTINTERP_API octave_value xpow (float a, const FloatComplexMatrix& b);
 
 extern OCTINTERP_API octave_value xpow (const FloatMatrix& a, float b);
-extern OCTINTERP_API octave_value xpow (const FloatMatrix& a, const FloatComplex& b);
+extern OCTINTERP_API octave_value xpow (const FloatMatrix& a,
+                                        const FloatComplex& b);
 
 extern OCTINTERP_API octave_value xpow (const FloatDiagMatrix& a, float b);
-extern OCTINTERP_API octave_value xpow (const FloatDiagMatrix& a, const FloatComplex& b);
+extern OCTINTERP_API octave_value xpow (const FloatDiagMatrix& a,
+                                        const FloatComplex& b);
 
 extern OCTINTERP_API octave_value xpow (const FloatComplex& a, float b);
-extern OCTINTERP_API octave_value xpow (const FloatComplex& a, const FloatMatrix& b);
-extern OCTINTERP_API octave_value xpow (const FloatComplex& a, const FloatComplex& b);
-extern OCTINTERP_API octave_value xpow (const FloatComplex& a, const FloatComplexMatrix& b);
+extern OCTINTERP_API octave_value xpow (const FloatComplex& a,
+                                        const FloatMatrix& b);
+extern OCTINTERP_API octave_value xpow (const FloatComplex& a,
+                                        const FloatComplex& b);
+extern OCTINTERP_API octave_value xpow (const FloatComplex& a,
+                                        const FloatComplexMatrix& b);
 
 extern OCTINTERP_API octave_value xpow (const FloatComplexMatrix& a, float b);
-extern OCTINTERP_API octave_value xpow (const FloatComplexMatrix& a, const FloatComplex& b);
+extern OCTINTERP_API octave_value xpow (const FloatComplexMatrix& a,
+                                        const FloatComplex& b);
 
-extern OCTINTERP_API octave_value xpow (const FloatComplexDiagMatrix& a, float b);
-extern OCTINTERP_API octave_value xpow (const FloatComplexDiagMatrix& a, const FloatComplex& b);
+extern OCTINTERP_API octave_value xpow (const FloatComplexDiagMatrix& a,
+                                        float b);
+extern OCTINTERP_API octave_value xpow (const FloatComplexDiagMatrix& a,
+                                        const FloatComplex& b);
 
 extern OCTINTERP_API octave_value elem_xpow (float a, const FloatMatrix& b);
-extern OCTINTERP_API octave_value elem_xpow (float a, const FloatComplexMatrix& b);
+extern OCTINTERP_API octave_value elem_xpow (float a,
+                                             const FloatComplexMatrix& b);
 
 extern OCTINTERP_API octave_value elem_xpow (const FloatMatrix& a, float b);
-extern OCTINTERP_API octave_value elem_xpow (const FloatMatrix& a, const FloatMatrix& b);
-extern OCTINTERP_API octave_value elem_xpow (const FloatMatrix& a, const FloatComplex& b);
-extern OCTINTERP_API octave_value elem_xpow (const FloatMatrix& a, const FloatComplexMatrix& b);
+extern OCTINTERP_API octave_value elem_xpow (const FloatMatrix& a,
+                                             const FloatMatrix& b);
+extern OCTINTERP_API octave_value elem_xpow (const FloatMatrix& a,
+                                             const FloatComplex& b);
+extern OCTINTERP_API octave_value elem_xpow (const FloatMatrix& a,
+                                             const FloatComplexMatrix& b);
 
-extern OCTINTERP_API octave_value elem_xpow (const FloatComplex& a, const FloatMatrix& b);
-extern OCTINTERP_API octave_value elem_xpow (const FloatComplex& a, const FloatComplexMatrix& b);
+extern OCTINTERP_API octave_value elem_xpow (const FloatComplex& a,
+                                             const FloatMatrix& b);
+extern OCTINTERP_API octave_value elem_xpow (const FloatComplex& a,
+                                             const FloatComplexMatrix& b);
 
-extern OCTINTERP_API octave_value elem_xpow (const FloatComplexMatrix& a, float b);
-extern OCTINTERP_API octave_value elem_xpow (const FloatComplexMatrix& a, const FloatMatrix& b);
-extern OCTINTERP_API octave_value elem_xpow (const FloatComplexMatrix& a, const FloatComplex& b);
-extern OCTINTERP_API octave_value elem_xpow (const FloatComplexMatrix& a, const FloatComplexMatrix& b);
+extern OCTINTERP_API octave_value elem_xpow (const FloatComplexMatrix& a,
+                                             float b);
+extern OCTINTERP_API octave_value elem_xpow (const FloatComplexMatrix& a,
+                                             const FloatMatrix& b);
+extern OCTINTERP_API octave_value elem_xpow (const FloatComplexMatrix& a,
+                                             const FloatComplex& b);
+extern OCTINTERP_API octave_value elem_xpow (const FloatComplexMatrix& a,
+                                             const FloatComplexMatrix& b);
 
 
 extern OCTINTERP_API octave_value elem_xpow (float a, const FloatNDArray& b);
-extern OCTINTERP_API octave_value elem_xpow (float a, const FloatComplexNDArray& b);
+extern OCTINTERP_API octave_value elem_xpow (float a,
+                                             const FloatComplexNDArray& b);
 
 extern OCTINTERP_API octave_value elem_xpow (const FloatNDArray& a, float b);
-extern OCTINTERP_API octave_value elem_xpow (const FloatNDArray& a, const FloatNDArray& b);
-extern OCTINTERP_API octave_value elem_xpow (const FloatNDArray& a, const FloatComplex& b);
-extern OCTINTERP_API octave_value elem_xpow (const FloatNDArray& a, const FloatComplexNDArray& b);
+extern OCTINTERP_API octave_value elem_xpow (const FloatNDArray& a,
+                                             const FloatNDArray& b);
+extern OCTINTERP_API octave_value elem_xpow (const FloatNDArray& a,
+                                             const FloatComplex& b);
+extern OCTINTERP_API octave_value elem_xpow (const FloatNDArray& a,
+                                             const FloatComplexNDArray& b);
 
-extern OCTINTERP_API octave_value elem_xpow (const FloatComplex& a, const FloatNDArray& b);
-extern OCTINTERP_API octave_value elem_xpow (const FloatComplex& a, const FloatComplexNDArray& b);
+extern OCTINTERP_API octave_value elem_xpow (const FloatComplex& a,
+                                             const FloatNDArray& b);
+extern OCTINTERP_API octave_value elem_xpow (const FloatComplex& a,
+                                             const FloatComplexNDArray& b);
 
-extern OCTINTERP_API octave_value elem_xpow (const FloatComplexNDArray& a, float b);
-extern OCTINTERP_API octave_value elem_xpow (const FloatComplexNDArray& a, const FloatNDArray& b);
-extern OCTINTERP_API octave_value elem_xpow (const FloatComplexNDArray& a, const FloatComplex& b);
-extern OCTINTERP_API octave_value elem_xpow (const FloatComplexNDArray& a, const FloatComplexNDArray& b);
+extern OCTINTERP_API octave_value elem_xpow (const FloatComplexNDArray& a,
+                                             float b);
+extern OCTINTERP_API octave_value elem_xpow (const FloatComplexNDArray& a,
+                                             const FloatNDArray& b);
+extern OCTINTERP_API octave_value elem_xpow (const FloatComplexNDArray& a,
+                                             const FloatComplex& b);
+extern OCTINTERP_API octave_value elem_xpow (const FloatComplexNDArray& a,
+                                             const FloatComplexNDArray& b);
 
 #endif
diff --git a/libinterp/corefcn/zfstream.cc b/libinterp/corefcn/zfstream.cc
--- a/libinterp/corefcn/zfstream.cc
+++ b/libinterp/corefcn/zfstream.cc
@@ -48,18 +48,18 @@ along with Octave; see the file COPYING.
 #define STASHED_CHARACTERS 16
 #define BIGBUFSIZE (256 * 1024 + STASHED_CHARACTERS)
 #define SMALLBUFSIZE 1
 
 /*****************************************************************************/
 
 // Default constructor
 gzfilebuf::gzfilebuf ()
-: file(0), io_mode(std::ios_base::openmode(0)), own_fd(false),
-  buffer(0), buffer_size(BIGBUFSIZE), own_buffer(true)
+  : file(0), io_mode(std::ios_base::openmode(0)), own_fd(false),
+    buffer(0), buffer_size(BIGBUFSIZE), own_buffer(true)
 {
   // No buffers to start with
   this->disable_buffer ();
 }
 
 // Destructor
 gzfilebuf::~gzfilebuf ()
 {
@@ -69,26 +69,24 @@ gzfilebuf::~gzfilebuf ()
   if (own_fd)
     this->close ();
   // Make sure internal buffer is deallocated
   this->disable_buffer ();
 }
 
 // Set compression level and strategy
 int
-gzfilebuf::setcompression (int comp_level,
-                           int comp_strategy)
+gzfilebuf::setcompression (int comp_level, int comp_strategy)
 {
   return gzsetparams (file, comp_level, comp_strategy);
 }
 
 // Open gzipped file
 gzfilebuf*
-gzfilebuf::open (const char *name,
-                 std::ios_base::openmode mode)
+gzfilebuf::open (const char *name, std::ios_base::openmode mode)
 {
   // Fail if file already open
   if (this->is_open ())
     return 0;
   // Don't support simultaneous read/write access (yet)
   if ((mode & std::ios_base::in) && (mode & std::ios_base::out))
     return 0;
 
@@ -105,18 +103,17 @@ gzfilebuf::open (const char *name,
   this->enable_buffer ();
   io_mode = mode;
   own_fd = true;
   return this;
 }
 
 // Attach to gzipped file
 gzfilebuf*
-gzfilebuf::attach (int fd,
-                   std::ios_base::openmode mode)
+gzfilebuf::attach (int fd, std::ios_base::openmode mode)
 {
   // Fail if file already open
   if (this->is_open ())
     return 0;
   // Don't support simultaneous read/write access (yet)
   if ((mode & std::ios_base::in) && (mode & std::ios_base::out))
     return 0;
 
@@ -157,20 +154,19 @@ gzfilebuf::close ()
   this->disable_buffer ();
   return retval;
 }
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 // Convert int open mode to mode string
 bool
-gzfilebuf::open_mode (std::ios_base::openmode mode,
-                      char* c_mode) const
+gzfilebuf::open_mode (std::ios_base::openmode mode, char* c_mode) const
 {
-  // FIXME -- do we need testb?
+  // FIXME: do we need testb?
   // bool testb = mode & std::ios_base::binary;
   bool testi = mode & std::ios_base::in;
   bool testo = mode & std::ios_base::out;
   bool testt = mode & std::ios_base::trunc;
   bool testa = mode & std::ios_base::app;
 
   // Check for valid flag combinations - see [27.8.1.3.2] (Table 92)
   // Original zfstream hardcoded the compression level to maximum here...
@@ -181,20 +177,20 @@ gzfilebuf::open_mode (std::ios_base::ope
     strcpy (c_mode, "w");
   if (!testi && testo && !testt && testa)
     strcpy (c_mode, "a");
   if (!testi && testo && testt && !testa)
     strcpy (c_mode, "w");
   if (testi && !testo && !testt && !testa)
     strcpy (c_mode, "r");
   // No read/write mode yet
-//  if (testi && testo && !testt && !testa)
-//    strcpy(c_mode, "r+");
-//  if (testi && testo && testt && !testa)
-//    strcpy(c_mode, "w+");
+  //  if (testi && testo && !testt && !testa)
+  //    strcpy(c_mode, "r+");
+  //  if (testi && testo && testt && !testa)
+  //    strcpy(c_mode, "w+");
 
   // Mode string should be empty for invalid combination of flags
   if (strlen (c_mode) == 0)
     return false;
 
   strcat (c_mode, "b");
 
   return true;
@@ -281,193 +277,195 @@ gzfilebuf::underflow ()
     }
 
   // Attempt to fill internal buffer from gzipped file
   // (buffer must be guaranteed to exist...)
   int bytes_read = gzread (file, buffer + stash, buffer_size - stash);
 
   // Indicates error or EOF
   if (bytes_read <= 0)
-  {
-    // Reset get area
-    this->setg (buffer, buffer, buffer);
-    return traits_type::eof ();
-  }
+    {
+      // Reset get area
+      this->setg (buffer, buffer, buffer);
+      return traits_type::eof ();
+    }
   // Make all bytes read from file plus the stash available as get area
   this->setg (buffer, buffer + stash, buffer + bytes_read + stash);
 
   // Return next character in get area
   return traits_type::to_int_type (*(this->gptr ()));
 }
 
 // Write put area to gzipped file
 gzfilebuf::int_type
 gzfilebuf::overflow (int_type c)
 {
   // Determine whether put area is in use
   if (this->pbase ())
-  {
-    // Double-check pointer range
-    if (this->pptr () > this->epptr () || this->pptr () < this->pbase ())
-      return traits_type::eof ();
-    // Add extra character to buffer if not EOF
-    if (! traits_type::eq_int_type (c, traits_type::eof ()))
     {
-      *(this->pptr ()) = traits_type::to_char_type (c);
-      this->pbump (1);
+      // Double-check pointer range
+      if (this->pptr () > this->epptr () || this->pptr () < this->pbase ())
+        return traits_type::eof ();
+      // Add extra character to buffer if not EOF
+      if (! traits_type::eq_int_type (c, traits_type::eof ()))
+        {
+          *(this->pptr ()) = traits_type::to_char_type (c);
+          this->pbump (1);
+        }
+      // Number of characters to write to file
+      int bytes_to_write = this->pptr () - this->pbase ();
+      // Overflow doesn't fail if nothing is to be written
+      if (bytes_to_write > 0)
+        {
+          // If the file hasn't been opened for writing, produce error
+          if (! this->is_open () || !(io_mode & std::ios_base::out))
+            return traits_type::eof ();
+          // If gzipped file won't accept all bytes written to it, fail
+          if (gzwrite (file, this->pbase (), bytes_to_write) != bytes_to_write)
+            return traits_type::eof ();
+          // Reset next pointer to point to pbase on success
+          this->pbump (-bytes_to_write);
+        }
     }
-    // Number of characters to write to file
-    int bytes_to_write = this->pptr () - this->pbase ();
-    // Overflow doesn't fail if nothing is to be written
-    if (bytes_to_write > 0)
+  // Write extra character to file if not EOF
+  else if (! traits_type::eq_int_type (c, traits_type::eof ()))
     {
       // If the file hasn't been opened for writing, produce error
       if (! this->is_open () || !(io_mode & std::ios_base::out))
         return traits_type::eof ();
-      // If gzipped file won't accept all bytes written to it, fail
-      if (gzwrite (file, this->pbase (), bytes_to_write) != bytes_to_write)
+      // Impromptu char buffer (allows "unbuffered" output)
+      char_type last_char = traits_type::to_char_type (c);
+      // If gzipped file won't accept this character, fail
+      if (gzwrite (file, &last_char, 1) != 1)
         return traits_type::eof ();
-      // Reset next pointer to point to pbase on success
-      this->pbump (-bytes_to_write);
     }
-  }
-  // Write extra character to file if not EOF
-  else if (! traits_type::eq_int_type (c, traits_type::eof ()))
-  {
-    // If the file hasn't been opened for writing, produce error
-    if (! this->is_open () || !(io_mode & std::ios_base::out))
-      return traits_type::eof ();
-    // Impromptu char buffer (allows "unbuffered" output)
-    char_type last_char = traits_type::to_char_type (c);
-    // If gzipped file won't accept this character, fail
-    if (gzwrite (file, &last_char, 1) != 1)
-      return traits_type::eof ();
-  }
 
   // If you got here, you have succeeded (even if c was EOF)
   // The return value should therefore be non-EOF
   if (traits_type::eq_int_type (c, traits_type::eof ()))
     return traits_type::not_eof (c);
   else
     return c;
 }
 
 // Assign new buffer
 std::streambuf*
-gzfilebuf::setbuf (char_type* p,
-                   std::streamsize n)
+gzfilebuf::setbuf (char_type* p, std::streamsize n)
 {
   // First make sure stuff is sync'ed, for safety
   if (this->sync () == -1)
     return 0;
-  // If buffering is turned off on purpose via setbuf(0,0), still allocate one...
+  // If buffering is turned off on purpose via setbuf(0,0), still allocate one.
   // "Unbuffered" only really refers to put [27.8.1.4.10], while get needs at
-  // least a buffer of size 1 (very inefficient though, therefore make it bigger?)
-  // This follows from [27.5.2.4.3]/12 (gptr needs to point at something, it seems)
+  // least a buffer of size 1 (very inefficient though, therefore make it
+  // bigger?).  This follows from [27.5.2.4.3]/12 (gptr needs to point at
+  // something, it seems).
   if (!p || !n)
-  {
-    // Replace existing buffer (if any) with small internal buffer
-    this->disable_buffer ();
-    buffer = 0;
-    buffer_size = 0;
-    own_buffer = true;
-    this->enable_buffer ();
-  }
+    {
+      // Replace existing buffer (if any) with small internal buffer
+      this->disable_buffer ();
+      buffer = 0;
+      buffer_size = 0;
+      own_buffer = true;
+      this->enable_buffer ();
+    }
   else
-  {
-    // Replace existing buffer (if any) with external buffer
-    this->disable_buffer ();
-    buffer = p;
-    buffer_size = n;
-    own_buffer = false;
-    this->enable_buffer ();
-  }
+    {
+      // Replace existing buffer (if any) with external buffer
+      this->disable_buffer ();
+      buffer = p;
+      buffer_size = n;
+      own_buffer = false;
+      this->enable_buffer ();
+    }
   return this;
 }
 
 // Write put area to gzipped file (i.e. ensures that put area is empty)
 int
 gzfilebuf::sync ()
 {
-  return traits_type::eq_int_type (this->overflow (), traits_type::eof ()) ? -1 : 0;
+  return traits_type::eq_int_type (this->overflow (),
+                                   traits_type::eof ()) ? -1 : 0;
 }
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 // Allocate internal buffer
 void
 gzfilebuf::enable_buffer ()
 {
   // If internal buffer required, allocate one
   if (own_buffer && !buffer)
-  {
-    // Check for buffered vs. "unbuffered"
-    if (buffer_size > 0)
     {
-      // Allocate internal buffer
-      buffer = new char_type [buffer_size];
-      // Get area starts empty and will be expanded by underflow as need arises
+      // Check for buffered vs. "unbuffered"
+      if (buffer_size > 0)
+        {
+          // Allocate internal buffer
+          buffer = new char_type [buffer_size];
+          // Get area starts empty and will be expanded by underflow as needed
+          this->setg (buffer, buffer, buffer);
+          // Setup entire internal buffer as put area.
+          // The one-past-end pointer actually points to the last element of
+          // the buffer, so that overflow(c) can safely add the extra character 
+          // c to the sequence.  These pointers remain in place for the
+          // duration of the buffer
+          this->setp (buffer, buffer + buffer_size - 1);
+        }
+      else
+        {
+          // Even in "unbuffered" case, (small?) get buffer is still required
+          buffer_size = SMALLBUFSIZE;
+          buffer = new char_type [buffer_size];
+          this->setg (buffer, buffer, buffer);
+          // "Unbuffered" means no put buffer
+          this->setp (0, 0);
+        }
+    }
+  else
+    {
+      // If buffer already allocated, reset buffer pointers just to make sure no
+      // stale chars are lying around
       this->setg (buffer, buffer, buffer);
-      // Setup entire internal buffer as put area.
-      // The one-past-end pointer actually points to the last element of the buffer,
-      // so that overflow(c) can safely add the extra character c to the sequence.
-      // These pointers remain in place for the duration of the buffer
       this->setp (buffer, buffer + buffer_size - 1);
     }
-    else
-    {
-      // Even in "unbuffered" case, (small?) get buffer is still required
-      buffer_size = SMALLBUFSIZE;
-      buffer = new char_type [buffer_size];
-      this->setg (buffer, buffer, buffer);
-      // "Unbuffered" means no put buffer
-      this->setp (0, 0);
-    }
-  }
-  else
-  {
-    // If buffer already allocated, reset buffer pointers just to make sure no
-    // stale chars are lying around
-    this->setg (buffer, buffer, buffer);
-    this->setp (buffer, buffer + buffer_size - 1);
-  }
 }
 
 // Destroy internal buffer
 void
 gzfilebuf::disable_buffer ()
 {
   // If internal buffer exists, deallocate it
   if (own_buffer && buffer)
-  {
-    // Preserve unbuffered status by zeroing size
-    if (! this->pbase ())
-      buffer_size = 0;
-    delete[] buffer;
-    buffer = 0;
-    this->setg (0, 0, 0);
-    this->setp (0, 0);
-  }
+    {
+      // Preserve unbuffered status by zeroing size
+      if (! this->pbase ())
+        buffer_size = 0;
+      delete[] buffer;
+      buffer = 0;
+      this->setg (0, 0, 0);
+      this->setp (0, 0);
+    }
   else
-  {
-    // Reset buffer pointers to initial state if external buffer exists
-    this->setg (buffer, buffer, buffer);
-    if (buffer)
-      this->setp (buffer, buffer + buffer_size - 1);
-    else
-      this->setp (0, 0);
-  }
+    {
+      // Reset buffer pointers to initial state if external buffer exists
+      this->setg (buffer, buffer, buffer);
+      if (buffer)
+        this->setp (buffer, buffer + buffer_size - 1);
+      else
+        this->setp (0, 0);
+    }
 }
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 // Seek functions
 gzfilebuf::pos_type
 gzfilebuf::seekoff (off_type off, std::ios_base::seekdir way,
-                   std::ios_base::openmode)
+                    std::ios_base::openmode)
 {
   pos_type ret = pos_type (off_type (-1));
 
   if (this->is_open ())
     {
       off_type computed_off = off;
 
       if ((io_mode & std::ios_base::in) && way == std::ios_base::cur)
@@ -516,52 +514,48 @@ gzfilebuf::seekpos (pos_type sp, std::io
 
   return ret;
 }
 
 /*****************************************************************************/
 
 // Default constructor initializes stream buffer
 gzifstream::gzifstream ()
-: std::istream (0), sb ()
+  : std::istream (0), sb ()
 { this->init (&sb); }
 
 // Initialize stream buffer and open file
-gzifstream::gzifstream (const char* name,
-                        std::ios_base::openmode mode)
-: std::istream (0), sb ()
+gzifstream::gzifstream (const char* name, std::ios_base::openmode mode)
+  : std::istream (0), sb ()
 {
   this->init (&sb);
   this->open (name, mode);
 }
 
 // Initialize stream buffer and attach to file
-gzifstream::gzifstream (int fd,
-                        std::ios_base::openmode mode)
-: std::istream (0), sb ()
+gzifstream::gzifstream (int fd, std::ios_base::openmode mode)
+  : std::istream (0), sb ()
 {
   this->init (&sb);
   this->attach (fd, mode);
 }
 
 // Open file and go into fail() state if unsuccessful
 void
-gzifstream::open (const char* name,
-                  std::ios_base::openmode mode)
+gzifstream::open (const char* name, std::ios_base::openmode mode)
 {
   if (! sb.open (name, mode | std::ios_base::in))
     this->setstate (std::ios_base::failbit);
   else
     this->clear ();
 }
 
 // Attach to file and go into fail() state if unsuccessful
 void
-gzifstream::attach (int fd,
-                    std::ios_base::openmode mode)
+gzifstream::attach (int fd, std::ios_base::openmode mode)
 {
   if (! sb.attach (fd, mode | std::ios_base::in))
     this->setstate (std::ios_base::failbit);
   else
     this->clear ();
 }
 
 // Close file
@@ -571,52 +565,48 @@ gzifstream::close ()
   if (! sb.close ())
     this->setstate (std::ios_base::failbit);
 }
 
 /*****************************************************************************/
 
 // Default constructor initializes stream buffer
 gzofstream::gzofstream ()
-: std::ostream (0), sb ()
+  : std::ostream (0), sb ()
 { this->init (&sb); }
 
 // Initialize stream buffer and open file
-gzofstream::gzofstream (const char* name,
-                        std::ios_base::openmode mode)
-: std::ostream (0), sb ()
+gzofstream::gzofstream (const char* name, std::ios_base::openmode mode)
+  : std::ostream (0), sb ()
 {
   this->init (&sb);
   this->open (name, mode);
 }
 
 // Initialize stream buffer and attach to file
-gzofstream::gzofstream (int fd,
-                        std::ios_base::openmode mode)
-: std::ostream (0), sb ()
+gzofstream::gzofstream (int fd, std::ios_base::openmode mode)
+  : std::ostream (0), sb ()
 {
   this->init (&sb);
   this->attach (fd, mode);
 }
 
 // Open file and go into fail() state if unsuccessful
 void
-gzofstream::open (const char* name,
-                  std::ios_base::openmode mode)
+gzofstream::open (const char* name, std::ios_base::openmode mode)
 {
   if (! sb.open (name, mode | std::ios_base::out))
     this->setstate (std::ios_base::failbit);
   else
     this->clear ();
 }
 
 // Attach to file and go into fail() state if unsuccessful
 void
-gzofstream::attach (int fd,
-                    std::ios_base::openmode mode)
+gzofstream::attach (int fd, std::ios_base::openmode mode)
 {
   if (! sb.attach (fd, mode | std::ios_base::out))
     this->setstate (std::ios_base::failbit);
   else
     this->clear ();
 }
 
 // Close file
diff --git a/libinterp/corefcn/zfstream.h b/libinterp/corefcn/zfstream.h
--- a/libinterp/corefcn/zfstream.h
+++ b/libinterp/corefcn/zfstream.h
@@ -39,20 +39,20 @@ along with Octave; see the file COPYING.
 
 #include "zlib.h"
 
 /*****************************************************************************/
 
 /**
  *  @brief  Gzipped file stream buffer class.
  *
- *  This class implements basic_filebuf for gzipped files. It doesn't yet support
- *  seeking (allowed by zlib but slow/limited), putback and read/write access
- *  (tricky). Otherwise, it attempts to be a drop-in replacement for the standard
- *  file streambuf.
+ *  This class implements basic_filebuf for gzipped files. It doesn't yet
+ *  support seeking (allowed by zlib but slow/limited), putback and read/write
+ *  access *  (tricky). Otherwise, it attempts to be a drop-in replacement for
+ *  the standard file streambuf.
 */
 class gzfilebuf : public std::streambuf
 {
 public:
   //  Default constructor.
   gzfilebuf ();
 
   //  Destructor.
@@ -452,63 +452,63 @@ private:
 
 /**
  *  @brief  Gzipped file output stream manipulator class.
  *
  *  This class defines a two-argument manipulator for gzofstream. It is used
  *  as base for the setcompression(int,int) manipulator.
 */
 template<typename T1, typename T2>
-  class gzomanip2
-  {
-  public:
-    // Allows insertor to peek at internals
-    template <typename Ta, typename Tb>
-      friend gzofstream&
-      operator<<(gzofstream&,
-                 const gzomanip2<Ta,Tb>&);
+class gzomanip2
+{
+public:
+  // Allows insertor to peek at internals
+  template <typename Ta, typename Tb>
+  friend gzofstream&
+  operator<<(gzofstream&,
+             const gzomanip2<Ta,Tb>&);
 
-    // Constructor
-    gzomanip2 (gzofstream& (*f)(gzofstream&, T1, T2),
-               T1 v1,
-               T2 v2);
-  private:
-    // Underlying manipulator function
-    gzofstream&
-    (*func)(gzofstream&, T1, T2);
+  // Constructor
+  gzomanip2 (gzofstream& (*f)(gzofstream&, T1, T2),
+             T1 v1,
+             T2 v2);
+private:
+  // Underlying manipulator function
+  gzofstream&
+  (*func)(gzofstream&, T1, T2);
 
-    // Arguments for manipulator function
-    T1 val1;
-    T2 val2;
-  };
+  // Arguments for manipulator function
+  T1 val1;
+  T2 val2;
+};
 
 /*****************************************************************************/
 
 // Manipulator function thunks through to stream buffer
 inline gzofstream&
 setcompression (gzofstream &gzs, int l, int s = Z_DEFAULT_STRATEGY)
 {
   (gzs.rdbuf ())->setcompression (l, s);
   return gzs;
 }
 
 // Manipulator constructor stores arguments
 template<typename T1, typename T2>
-  inline
-  gzomanip2<T1,T2>::gzomanip2 (gzofstream &(*f)(gzofstream &, T1, T2),
-                               T1 v1,
-                               T2 v2)
+inline
+gzomanip2<T1,T2>::gzomanip2 (gzofstream &(*f)(gzofstream &, T1, T2),
+                             T1 v1,
+                             T2 v2)
   : func(f), val1(v1), val2(v2)
-  { }
+{ }
 
 // Insertor applies underlying manipulator function to stream
 template<typename T1, typename T2>
-  inline gzofstream&
-  operator<<(gzofstream& s, const gzomanip2<T1,T2>& m)
-  { return (*m.func)(s, m.val1, m.val2); }
+inline gzofstream&
+operator<<(gzofstream& s, const gzomanip2<T1,T2>& m)
+{ return (*m.func)(s, m.val1, m.val2); }
 
 // Insert this onto stream to simplify setting of compression level
 inline gzomanip2<int,int>
 setcompression (int l, int s = Z_DEFAULT_STRATEGY)
 { return gzomanip2<int,int>(&setcompression, l, s); }
 
 #endif // HAVE_ZLIB
 
diff --git a/libinterp/dldfcn/__delaunayn__.cc b/libinterp/dldfcn/__delaunayn__.cc
--- a/libinterp/dldfcn/__delaunayn__.cc
+++ b/libinterp/dldfcn/__delaunayn__.cc
@@ -141,17 +141,17 @@ Undocumented internal function.\n\
       if (outfile)
         frame.add_fcn (close_fcn, outfile);
       else
         {
           error ("__delaunayn__: unable to create temporary file for output");
           return retval;
         }
 
-      int exitcode = qh_new_qhull (dim, n, pt_array, 
+      int exitcode = qh_new_qhull (dim, n, pt_array,
                                    ismalloc, flags, outfile, errfile);
       if (! exitcode)
         {
           // triangulate non-simplicial facets
           qh_triangulate ();
 
           facetT *facet;
           vertexT *vertex, **vertexp;
diff --git a/libinterp/dldfcn/__dsearchn__.cc b/libinterp/dldfcn/__dsearchn__.cc
--- a/libinterp/dldfcn/__dsearchn__.cc
+++ b/libinterp/dldfcn/__dsearchn__.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 
 #include "lo-math.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "oct-obj.h"
 
 DEFUN_DLD (__dsearchn__, args, ,
-        "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{idx}, @var{d}] =} dsearch (@var{x}, @var{xi})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value_list retval;
 
   if (nargin != 2)
diff --git a/libinterp/dldfcn/__eigs__.cc b/libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/__eigs__.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -125,17 +125,17 @@ eigs_complex_func (const ComplexColumnVe
           gripe_user_supplied_eval ("eigs");
         }
     }
 
   return retval;
 }
 
 DEFUN_DLD (__eigs__, args, nargout,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{d} =} __eigs__ (@var{A})\n\
 @deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{A}, @var{k})\n\
 @deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{A}, @var{k}, @var{sigma})\n\
 @deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{A}, @var{k}, @var{sigma}, @var{opts})\n\
 @deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{A}, @var{B})\n\
 @deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{A}, @var{B}, @var{k})\n\
 @deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{A}, @var{B}, @var{k}, @var{sigma})\n\
 @deftypefnx {Loadable Function} {@var{d} =} __eigs__ (@var{A}, @var{B}, @var{k}, @var{sigma}, @var{opts})\n\
@@ -432,40 +432,44 @@ Undocumented internal function.\n\
       if (a_is_complex || b_is_complex)
         {
           ComplexMatrix eig_vec;
           ComplexColumnVector eig_val;
 
 
           if (have_a_fun)
             nconv = EigsComplexNonSymmetricFunc
-              (eigs_complex_func, n, typ, sigma, k, p, info, eig_vec, eig_val,
-               cresid, octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
+                    (eigs_complex_func, n, typ, sigma, k, p, info, eig_vec,
+                     eig_val, cresid, octave_stdout, tol, (nargout > 1), cholB,
+                     disp, maxit);
           else if (have_sigma)
             {
               if (a_is_sparse)
                 nconv = EigsComplexNonSymmetricMatrixShift
-                  (ascm, sigma, k, p, info, eig_vec, eig_val, bscm, permB,
-                   cresid, octave_stdout, tol, (nargout > 1), cholB, disp,
-                   maxit);
+                        (ascm, sigma, k, p, info, eig_vec, eig_val, bscm, permB,
+                         cresid, octave_stdout, tol, (nargout > 1), cholB, disp,
+                         maxit);
               else
                 nconv = EigsComplexNonSymmetricMatrixShift
-                  (acm, sigma, k, p, info, eig_vec, eig_val, bcm, permB, cresid,
-                   octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
+                        (acm, sigma, k, p, info, eig_vec, eig_val, bcm, permB,
+                         cresid, octave_stdout, tol, (nargout > 1), cholB, disp,
+                         maxit);
             }
           else
             {
               if (a_is_sparse)
                 nconv = EigsComplexNonSymmetricMatrix
-                  (ascm, typ, k, p, info, eig_vec, eig_val, bscm, permB, cresid,
-                   octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
+                        (ascm, typ, k, p, info, eig_vec, eig_val, bscm, permB,
+                         cresid, octave_stdout, tol, (nargout > 1), cholB, disp,
+                         maxit);
               else
                 nconv = EigsComplexNonSymmetricMatrix
-                  (acm, typ, k, p, info, eig_vec, eig_val, bcm, permB, cresid,
-                   octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
+                        (acm, typ, k, p, info, eig_vec, eig_val, bcm, permB,
+                         cresid, octave_stdout, tol, (nargout > 1), cholB, disp,
+                         maxit);
             }
 
           if (nargout < 2)
             retval(0) = eig_val;
           else
             {
               retval(2) = double (info);
               retval(1) = ComplexDiagMatrix (eig_val);
@@ -475,30 +479,31 @@ Undocumented internal function.\n\
       else if (sigmai != 0.)
         {
           // Promote real problem to a complex one.
           ComplexMatrix eig_vec;
           ComplexColumnVector eig_val;
 
           if (have_a_fun)
             nconv = EigsComplexNonSymmetricFunc
-              (eigs_complex_func, n, typ,  sigma, k, p, info, eig_vec, eig_val,
-               cresid, octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
+                    (eigs_complex_func, n, typ,  sigma, k, p, info, eig_vec,
+                     eig_val, cresid, octave_stdout, tol, (nargout > 1), cholB,
+                     disp, maxit);
           else
             {
               if (a_is_sparse)
                 nconv = EigsComplexNonSymmetricMatrixShift
-                  (SparseComplexMatrix (asmm), sigma, k, p, info, eig_vec,
-                   eig_val, SparseComplexMatrix (bsmm), permB, cresid,
-                   octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
+                        (SparseComplexMatrix (asmm), sigma, k, p, info, eig_vec,
+                         eig_val, SparseComplexMatrix (bsmm), permB, cresid,
+                         octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
               else
                 nconv = EigsComplexNonSymmetricMatrixShift
-                  (ComplexMatrix (amm), sigma, k, p, info, eig_vec,
-                   eig_val, ComplexMatrix (bmm), permB, cresid,
-                   octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
+                        (ComplexMatrix (amm), sigma, k, p, info, eig_vec,
+                         eig_val, ComplexMatrix (bmm), permB, cresid,
+                         octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
             }
 
           if (nargout < 2)
             retval(0) = eig_val;
           else
             {
               retval(2) = double (info);
               retval(1) = ComplexDiagMatrix (eig_val);
@@ -509,44 +514,44 @@ Undocumented internal function.\n\
         {
           if (symmetric)
             {
               Matrix eig_vec;
               ColumnVector eig_val;
 
               if (have_a_fun)
                 nconv = EigsRealSymmetricFunc
-                  (eigs_func, n, typ, sigmar, k, p, info, eig_vec, eig_val,
-                   resid, octave_stdout, tol, (nargout > 1), cholB, disp,
-                   maxit);
+                        (eigs_func, n, typ, sigmar, k, p, info, eig_vec,
+                         eig_val, resid, octave_stdout, tol, (nargout > 1),
+                         cholB, disp, maxit);
               else if (have_sigma)
                 {
                   if (a_is_sparse)
                     nconv = EigsRealSymmetricMatrixShift
-                      (asmm, sigmar, k, p, info, eig_vec, eig_val, bsmm, permB,
-                       resid, octave_stdout, tol, (nargout > 1), cholB, disp,
-                       maxit);
+                            (asmm, sigmar, k, p, info, eig_vec, eig_val, bsmm,
+                             permB, resid, octave_stdout, tol, (nargout > 1),
+                             cholB, disp, maxit);
                   else
                     nconv = EigsRealSymmetricMatrixShift
-                      (amm, sigmar, k, p, info, eig_vec, eig_val, bmm, permB,
-                       resid, octave_stdout, tol, (nargout > 1), cholB, disp,
-                       maxit);
+                            (amm, sigmar, k, p, info, eig_vec, eig_val, bmm,
+                             permB, resid, octave_stdout, tol, (nargout > 1),
+                             cholB, disp, maxit);
                 }
               else
                 {
                   if (a_is_sparse)
                     nconv = EigsRealSymmetricMatrix
-                      (asmm, typ, k, p, info, eig_vec, eig_val, bsmm, permB,
-                       resid, octave_stdout, tol, (nargout > 1), cholB, disp,
-                       maxit);
+                            (asmm, typ, k, p, info, eig_vec, eig_val, bsmm,
+                             permB, resid, octave_stdout, tol, (nargout > 1),
+                             cholB, disp, maxit);
                   else
                     nconv = EigsRealSymmetricMatrix
-                      (amm, typ, k, p, info, eig_vec, eig_val, bmm, permB,
-                       resid, octave_stdout, tol, (nargout > 1), cholB, disp,
-                       maxit);
+                            (amm, typ, k, p, info, eig_vec, eig_val, bmm, permB,
+                             resid, octave_stdout, tol, (nargout > 1), cholB,
+                             disp, maxit);
                 }
 
               if (nargout < 2)
                 retval(0) = eig_val;
               else
                 {
                   retval(2) = double (info);
                   retval(1) = DiagMatrix (eig_val);
@@ -555,44 +560,44 @@ Undocumented internal function.\n\
             }
           else
             {
               ComplexMatrix eig_vec;
               ComplexColumnVector eig_val;
 
               if (have_a_fun)
                 nconv = EigsRealNonSymmetricFunc
-                  (eigs_func, n, typ, sigmar, k, p, info, eig_vec, eig_val,
-                   resid, octave_stdout, tol, (nargout > 1), cholB, disp,
-                   maxit);
+                        (eigs_func, n, typ, sigmar, k, p, info, eig_vec,
+                         eig_val, resid, octave_stdout, tol, (nargout > 1),
+                         cholB, disp, maxit);
               else if (have_sigma)
                 {
                   if (a_is_sparse)
                     nconv = EigsRealNonSymmetricMatrixShift
-                      (asmm, sigmar, k, p, info, eig_vec, eig_val, bsmm, permB,
-                       resid, octave_stdout, tol, (nargout > 1), cholB, disp,
-                       maxit);
+                            (asmm, sigmar, k, p, info, eig_vec, eig_val, bsmm,
+                             permB, resid, octave_stdout, tol, (nargout > 1), 
+                             cholB, disp, maxit);
                   else
                     nconv = EigsRealNonSymmetricMatrixShift
-                      (amm, sigmar, k, p, info, eig_vec, eig_val, bmm, permB,
-                       resid, octave_stdout, tol, (nargout > 1), cholB, disp,
-                       maxit);
+                            (amm, sigmar, k, p, info, eig_vec, eig_val, bmm,
+                             permB, resid, octave_stdout, tol, (nargout > 1),
+                             cholB, disp, maxit);
                 }
               else
                 {
                   if (a_is_sparse)
                     nconv = EigsRealNonSymmetricMatrix
-                      (asmm, typ, k, p, info, eig_vec, eig_val, bsmm, permB,
-                       resid, octave_stdout, tol, (nargout > 1), cholB, disp,
-                       maxit);
+                            (asmm, typ, k, p, info, eig_vec, eig_val, bsmm,
+                             permB, resid, octave_stdout, tol, (nargout > 1),
+                             cholB, disp, maxit);
                   else
                     nconv = EigsRealNonSymmetricMatrix
-                      (amm, typ, k, p, info, eig_vec, eig_val, bmm, permB,
-                       resid, octave_stdout, tol, (nargout > 1), cholB, disp,
-                       maxit);
+                            (amm, typ, k, p, info, eig_vec, eig_val, bmm, permB,
+                             resid, octave_stdout, tol, (nargout > 1), cholB,
+                             disp, maxit);
                 }
 
               if (nargout < 2)
                 retval(0) = eig_val;
               else
                 {
                   retval(2) = double (info);
                   retval(1) = ComplexDiagMatrix (eig_val);
diff --git a/libinterp/dldfcn/__fltk_uigetfile__.cc b/libinterp/dldfcn/__fltk_uigetfile__.cc
--- a/libinterp/dldfcn/__fltk_uigetfile__.cc
+++ b/libinterp/dldfcn/__fltk_uigetfile__.cc
@@ -40,17 +40,17 @@ along with Octave; see the file COPYING.
 #undef Complex
 
 #endif
 
 #include "defun-dld.h"
 #include "file-ops.h"
 
 DEFUN_DLD (__fltk_uigetfile__, args, ,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __fltk_uigetfile__ (@dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifdef HAVE_FLTK
   // Expected argument list:
   //
   //   args(0) ... FileFilter in fltk format
diff --git a/libinterp/dldfcn/__glpk__.cc b/libinterp/dldfcn/__glpk__.cc
--- a/libinterp/dldfcn/__glpk__.cc
+++ b/libinterp/dldfcn/__glpk__.cc
@@ -287,19 +287,19 @@ glpk (int sense, int n, int m, double *c
               else
                 redcosts[i] = glp_ipt_col_dual (lp, i+1);
             }
         }
 
       *time = (clock () - t_start) / CLOCKS_PER_SEC;
     }
 
-   glp_delete_prob (lp);
+  glp_delete_prob (lp);
 
-   return errnum;
+  return errnum;
 }
 
 #endif
 
 #define OCTAVE_GLPK_GET_REAL_PARAM(NAME, VAL) \
   do \
     { \
       octave_value tmp = PARAM.getfield (NAME); \
@@ -347,17 +347,17 @@ glpk (int sense, int n, int m, double *c
               error ("glpk: invalid value in PARAM." NAME); \
               return retval; \
             } \
         } \
     } \
   while (0)
 
 DEFUN_DLD (__glpk__, args, ,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{values}] =} __glpk__ (@var{args})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   // The list of values to return.  See the declaration in oct-obj.h
   octave_value_list retval;
 
 #if defined (HAVE_GLPK)
@@ -476,25 +476,25 @@ Undocumented internal function.\n\
       return retval;
     }
 
   double *lb = LB.fortran_vec ();
 
   //-- LB argument, default: Free
   Array<int> freeLB (dim_vector (mrowsc, 1));
   for (int i = 0; i < mrowsc; i++)
-     {
-       if (xisinf (lb[i]))
-         {
-           freeLB(i) = 1;
-           lb[i] = -octave_Inf;
-         }
-       else
-         freeLB(i) = 0;
-     }
+    {
+      if (xisinf (lb[i]))
+        {
+          freeLB(i) = 1;
+          lb[i] = -octave_Inf;
+        }
+      else
+        freeLB(i) = 0;
+    }
 
   //-- 5th Input. An array of at least length numcols containing the upper
   //--            bound on each of the variables.
   Matrix UB (args(4).matrix_value ());
 
   if (error_state || UB.length () < mrowsc)
     {
       error ("__glpk__: invalid value of UB");
@@ -719,19 +719,19 @@ Undocumented internal function.\n\
   int status, errnum = 0;
 
   int jmpret = setjmp (mark);
 
   if (jmpret == 0)
     errnum = glpk (sense, mrowsc, mrowsA, c, nz, rn.fortran_vec (),
                    cn.fortran_vec (), a.fortran_vec (), b, ctype,
                    freeLB.fortran_vec (), lb, freeUB.fortran_vec (), ub,
-                   vartype.fortran_vec (), isMIP, lpsolver, save_pb, scale, &par,
-                   xmin.fortran_vec (), &fmin, &status, lambda.fortran_vec (),
-                   redcosts.fortran_vec (), &time);
+                   vartype.fortran_vec (), isMIP, lpsolver, save_pb, scale,
+                   &par, xmin.fortran_vec (), &fmin, &status,
+                   lambda.fortran_vec (), redcosts.fortran_vec (), &time);
 
   octave_scalar_map extra;
 
   if (! isMIP)
     {
       extra.assign ("lambda", lambda);
       extra.assign ("redcosts", redcosts);
     }
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -255,401 +255,411 @@ private:
 };
 
 // Parameter controlling how fast we zoom when using the scrool wheel.
 static double Vwheel_zoom_speed = 0.05;
 // Parameter controlling the GUI mode.
 static enum { pan_zoom, rotate_zoom, none } gui_mode;
 
 void script_cb (Fl_Widget*, void* data)
-  {
-    static_cast<uimenu::properties*> (data)->execute_callback ();
-  }
+{
+  static_cast<uimenu::properties*> (data)->execute_callback ();
+}
 
 
 class fltk_uimenu
 {
 public:
   fltk_uimenu (int xx, int yy, int ww, int hh)
-    {
-      menubar = new
-        Fl_Menu_Bar (xx, yy, ww, hh);
-    }
+  {
+    menubar = new
+    Fl_Menu_Bar (xx, yy, ww, hh);
+  }
 
   int items_to_show (void)
-    {
-      //returns the number of visible menu items
-      int len = menubar->size ();
-      int n = 0;
-      for (int t = 0; t < len; t++ )
-        {
-          const Fl_Menu_Item *m = static_cast<const Fl_Menu_Item*> (&(menubar->menu ()[t]));
-          if ((m->label () != NULL) && m->visible ())
-            n++;
-        }
+  {
+    //returns the number of visible menu items
+    int len = menubar->size ();
+    int n = 0;
+    for (int t = 0; t < len; t++ )
+      {
+        const Fl_Menu_Item *m = static_cast<const Fl_Menu_Item*> (&
+                                (menubar->menu ()[t]));
+        if ((m->label () != NULL) && m->visible ())
+          n++;
+      }
 
-      return n;
-    }
+    return n;
+  }
 
   void show (void)
-    {
-      menubar->show ();
-    }
+  {
+    menubar->show ();
+  }
 
   void hide (void)
-    {
-      menubar->hide ();
-    }
+  {
+    menubar->hide ();
+  }
 
-   bool is_visible (void)
-    {
-      return menubar->visible ();
-    }
+  bool is_visible (void)
+  {
+    return menubar->visible ();
+  }
 
   int find_index_by_name (const std::string& findname)
-    {
-      // This function is derived from Greg Ercolano's function
-      // int GetIndexByName(...), see:
-      // http://seriss.com/people/erco/fltk/#Menu_ChangeLabel
-      // He agreed via PM that it can be included in octave using GPLv3
-      // Kai Habel (14.10.2010)
+  {
+    // This function is derived from Greg Ercolano's function
+    // int GetIndexByName(...), see:
+    // http://seriss.com/people/erco/fltk/#Menu_ChangeLabel
+    // He agreed via PM that it can be included in octave using GPLv3
+    // Kai Habel (14.10.2010)
 
-      std::string menupath;
-      for (int t = 0; t < menubar->size (); t++ )
-        {
-          Fl_Menu_Item *m = const_cast<Fl_Menu_Item*> (&(menubar->menu ()[t]));
-          if (m->submenu ())
-            {
-              // item has submenu
-              if (!menupath.empty ())
-                menupath += "/";
-              menupath += m->label ();
+    std::string menupath;
+    for (int t = 0; t < menubar->size (); t++ )
+      {
+        Fl_Menu_Item *m = const_cast<Fl_Menu_Item*> (&(menubar->menu ()[t]));
+        if (m->submenu ())
+          {
+            // item has submenu
+            if (!menupath.empty ())
+              menupath += "/";
+            menupath += m->label ();
 
-              if (menupath.compare (findname) == 0 )
-                return (t);
-            }
-          else
-            {
-              // End of submenu? Pop back one level.
-              if (m->label () == NULL)
-                {
-                  std::size_t idx = menupath.find_last_of ("/");
-                  if (idx != std::string::npos)
-                    menupath.erase (idx);
-                  else
-                    menupath.clear ();
-                  continue;
-                }
-              // Menu item?
-              std::string itempath = menupath;
-              if (!itempath.empty ())
-                itempath += "/";
-              itempath += m->label ();
+            if (menupath.compare (findname) == 0 )
+              return (t);
+          }
+        else
+          {
+            // End of submenu? Pop back one level.
+            if (m->label () == NULL)
+              {
+                std::size_t idx = menupath.find_last_of ("/");
+                if (idx != std::string::npos)
+                  menupath.erase (idx);
+                else
+                  menupath.clear ();
+                continue;
+              }
+            // Menu item?
+            std::string itempath = menupath;
+            if (!itempath.empty ())
+              itempath += "/";
+            itempath += m->label ();
 
-              if (itempath.compare (findname) == 0)
-                return (t);
-            }
-        }
-      return (-1);
-    }
+            if (itempath.compare (findname) == 0)
+              return (t);
+          }
+      }
+    return (-1);
+  }
 
   Matrix find_uimenu_children (uimenu::properties& uimenup) const
-    {
-      Matrix uimenu_childs = uimenup.get_all_children ();
-      Matrix retval = do_find_uimenu_children (uimenu_childs);
-      return retval;
-    }
+  {
+    Matrix uimenu_childs = uimenup.get_all_children ();
+    Matrix retval = do_find_uimenu_children (uimenu_childs);
+    return retval;
+  }
 
   Matrix find_uimenu_children (figure::properties& figp) const
-    {
-      Matrix uimenu_childs = figp.get_all_children ();
-      Matrix retval = do_find_uimenu_children (uimenu_childs);
-      return retval;
-    }
+  {
+    Matrix uimenu_childs = figp.get_all_children ();
+    Matrix retval = do_find_uimenu_children (uimenu_childs);
+    return retval;
+  }
 
   Matrix do_find_uimenu_children (Matrix uimenu_childs) const
-    {
-      octave_idx_type k = 0;
+  {
+    octave_idx_type k = 0;
 
 
-      Matrix pos = Matrix (uimenu_childs.numel (), 1);
+    Matrix pos = Matrix (uimenu_childs.numel (), 1);
 
-      for (octave_idx_type ii = 0; ii < uimenu_childs.numel (); ii++)
+    for (octave_idx_type ii = 0; ii < uimenu_childs.numel (); ii++)
       {
         graphics_object kidgo = gh_manager::get_object (uimenu_childs (ii));
 
         if (kidgo.valid_object () && kidgo.isa ("uimenu"))
           {
             uimenu_childs(k) = uimenu_childs(ii);
             pos(k++) =
-              dynamic_cast<uimenu::properties&> (kidgo.get_properties ()).get_position ();
+              dynamic_cast<uimenu::properties&>
+              (kidgo.get_properties ()).get_position ();
           }
       }
 
-      uimenu_childs.resize (k, 1);
-      pos.resize (k, 1);
-      Matrix retval = Matrix (k, 1);
-      // Don't know if this is the best method to sort.
-      // Can we avoid the for loop?
-      Array<octave_idx_type> sidx = pos.sort_rows_idx (DESCENDING);
-      for (octave_idx_type ii = 0; ii < k; ii++)
-        retval(ii) = uimenu_childs (sidx(ii));
+    uimenu_childs.resize (k, 1);
+    pos.resize (k, 1);
+    Matrix retval = Matrix (k, 1);
+    // Don't know if this is the best method to sort.
+    // Can we avoid the for loop?
+    Array<octave_idx_type> sidx = pos.sort_rows_idx (DESCENDING);
+    for (octave_idx_type ii = 0; ii < k; ii++)
+      retval(ii) = uimenu_childs (sidx(ii));
 
-      return retval;
-    }
+    return retval;
+  }
 
   void delete_entry (uimenu::properties& uimenup)
-    {
-      std::string fltk_label = uimenup.get_fltk_label ();
-      int idx = find_index_by_name (fltk_label.c_str ());
+  {
+    std::string fltk_label = uimenup.get_fltk_label ();
+    int idx = find_index_by_name (fltk_label.c_str ());
 
-      if (idx >= 0)
-        menubar->remove (idx);
-    }
+    if (idx >= 0)
+      menubar->remove (idx);
+  }
 
   void update_accelerator (uimenu::properties& uimenup)
-    {
-      std::string fltk_label = uimenup.get_fltk_label ();
-      if (!fltk_label.empty ())
-        {
-          Fl_Menu_Item* item = const_cast<Fl_Menu_Item*> (menubar->find_item (fltk_label.c_str ()));
-          if (item != NULL)
-            {
-              std::string acc = uimenup.get_accelerator ();
-              if (acc.length () > 0)
-                {
-                  int key = FL_CTRL + acc[0];
-                  item->shortcut (key);
-                }
-            }
-        }
-    }
+  {
+    std::string fltk_label = uimenup.get_fltk_label ();
+    if (!fltk_label.empty ())
+      {
+        Fl_Menu_Item* item = const_cast<Fl_Menu_Item*> (menubar->find_item (
+                               fltk_label.c_str ()));
+        if (item != NULL)
+          {
+            std::string acc = uimenup.get_accelerator ();
+            if (acc.length () > 0)
+              {
+                int key = FL_CTRL + acc[0];
+                item->shortcut (key);
+              }
+          }
+      }
+  }
 
   void update_callback (uimenu::properties& uimenup)
-    {
-      std::string fltk_label = uimenup.get_fltk_label ();
-      if (!fltk_label.empty ())
-        {
-          Fl_Menu_Item* item = const_cast<Fl_Menu_Item*> (menubar->find_item (fltk_label.c_str ()));
-          if (item != NULL)
-            {
-              if (!uimenup.get_callback ().is_empty ())
-                item->callback (static_cast<Fl_Callback*> (script_cb),
-                                static_cast<void*> (&uimenup));
-              else
-                item->callback (NULL, static_cast<void*> (0));
-            }
-        }
-    }
+  {
+    std::string fltk_label = uimenup.get_fltk_label ();
+    if (!fltk_label.empty ())
+      {
+        Fl_Menu_Item* item = const_cast<Fl_Menu_Item*> (menubar->find_item (
+                               fltk_label.c_str ()));
+        if (item != NULL)
+          {
+            if (!uimenup.get_callback ().is_empty ())
+              item->callback (static_cast<Fl_Callback*> (script_cb),
+                              static_cast<void*> (&uimenup));
+            else
+              item->callback (NULL, static_cast<void*> (0));
+          }
+      }
+  }
 
   void update_enable (uimenu::properties& uimenup)
-    {
-      std::string fltk_label = uimenup.get_fltk_label ();
-      if (!fltk_label.empty ())
-        {
-          Fl_Menu_Item* item = const_cast<Fl_Menu_Item*> (menubar->find_item (fltk_label.c_str ()));
-          if (item != NULL)
-            {
-              if (uimenup.is_enable ())
-                item->activate ();
-              else
-                item->deactivate ();
-            }
-        }
-    }
+  {
+    std::string fltk_label = uimenup.get_fltk_label ();
+    if (!fltk_label.empty ())
+      {
+        Fl_Menu_Item* item = const_cast<Fl_Menu_Item*> (menubar->find_item (
+                               fltk_label.c_str ()));
+        if (item != NULL)
+          {
+            if (uimenup.is_enable ())
+              item->activate ();
+            else
+              item->deactivate ();
+          }
+      }
+  }
 
   void update_foregroundcolor (uimenu::properties& uimenup)
-    {
-      std::string fltk_label = uimenup.get_fltk_label ();
-      if (!fltk_label.empty ())
-        {
-          Fl_Menu_Item* item = const_cast<Fl_Menu_Item*> (menubar->find_item (fltk_label.c_str ()));
-          if (item != NULL)
-            {
-              Matrix rgb = uimenup.get_foregroundcolor_rgb ();
+  {
+    std::string fltk_label = uimenup.get_fltk_label ();
+    if (!fltk_label.empty ())
+      {
+        Fl_Menu_Item* item = const_cast<Fl_Menu_Item*> (menubar->find_item (
+                               fltk_label.c_str ()));
+        if (item != NULL)
+          {
+            Matrix rgb = uimenup.get_foregroundcolor_rgb ();
 
-              uchar r = static_cast<uchar> (gnulib::floor (rgb (0) * 255));
-              uchar g = static_cast<uchar> (gnulib::floor (rgb (1) * 255));
-              uchar b = static_cast<uchar> (gnulib::floor (rgb (2) * 255));
+            uchar r = static_cast<uchar> (gnulib::floor (rgb (0) * 255));
+            uchar g = static_cast<uchar> (gnulib::floor (rgb (1) * 255));
+            uchar b = static_cast<uchar> (gnulib::floor (rgb (2) * 255));
 
-              item->labelcolor (fl_rgb_color (r, g, b));
-            }
-        }
-    }
+            item->labelcolor (fl_rgb_color (r, g, b));
+          }
+      }
+  }
 
   void update_seperator (const uimenu::properties& uimenup)
-    {
-      // Matlab places the separator before the current
-      // menu entry, while fltk places it after. So we need to find
-      // the previous item in this menu/submenu. (Kai)
-      std::string fltk_label = uimenup.get_fltk_label ();
-      if (!fltk_label.empty ())
-        {
-          int itemflags = 0, idx;
-          int curr_idx = find_index_by_name (fltk_label.c_str ());
+  {
+    // Matlab places the separator before the current
+    // menu entry, while fltk places it after. So we need to find
+    // the previous item in this menu/submenu. (Kai)
+    std::string fltk_label = uimenup.get_fltk_label ();
+    if (!fltk_label.empty ())
+      {
+        int itemflags = 0, idx;
+        int curr_idx = find_index_by_name (fltk_label.c_str ());
 
-          for (idx = curr_idx - 1; idx >= 0; idx--)
-            {
-              Fl_Menu_Item* item = const_cast<Fl_Menu_Item*> (&menubar->menu () [idx]);
-              itemflags = item->flags;
-              if (item->label () != NULL)
-                break;
-            }
+        for (idx = curr_idx - 1; idx >= 0; idx--)
+          {
+            Fl_Menu_Item* item
+              = const_cast<Fl_Menu_Item*> (&menubar->menu () [idx]);
+            itemflags = item->flags;
+            if (item->label () != NULL)
+              break;
+          }
 
-          if (idx >= 0 && idx < menubar->size ())
-            {
-              if (uimenup.is_separator ())
-                {
-                  if (idx >= 0 && !(itemflags & FL_SUBMENU))
-                    menubar->mode (idx, itemflags | FL_MENU_DIVIDER);
-                }
-              else
-                menubar->mode (idx, itemflags & (~FL_MENU_DIVIDER));
-            }
-        }
-    }
+        if (idx >= 0 && idx < menubar->size ())
+          {
+            if (uimenup.is_separator ())
+              {
+                if (idx >= 0 && !(itemflags & FL_SUBMENU))
+                  menubar->mode (idx, itemflags | FL_MENU_DIVIDER);
+              }
+            else
+              menubar->mode (idx, itemflags & (~FL_MENU_DIVIDER));
+          }
+      }
+  }
 
   void update_visible (uimenu::properties& uimenup)
-    {
-      std::string fltk_label = uimenup.get_fltk_label ();
-      if (!fltk_label.empty ())
-        {
-          Fl_Menu_Item* item
-            = const_cast<Fl_Menu_Item*> (menubar->find_item (fltk_label.c_str ()));
-          if (item != NULL)
-            {
-              if (uimenup.is_visible ())
-                item->show ();
-              else
-                item->hide ();
-            }
-        }
-    }
+  {
+    std::string fltk_label = uimenup.get_fltk_label ();
+    if (!fltk_label.empty ())
+      {
+        Fl_Menu_Item* item
+          = const_cast<Fl_Menu_Item*> (menubar->find_item (fltk_label.c_str ()));
+        if (item != NULL)
+          {
+            if (uimenup.is_visible ())
+              item->show ();
+            else
+              item->hide ();
+          }
+      }
+  }
 
   void add_entry (uimenu::properties& uimenup)
-    {
+  {
 
-      std::string fltk_label = uimenup.get_fltk_label ();
+    std::string fltk_label = uimenup.get_fltk_label ();
 
-      if (!fltk_label.empty ())
-        {
-          bool item_added = false;
-          do
-            {
-              const Fl_Menu_Item* item
-                = menubar->find_item (fltk_label.c_str ());
+    if (!fltk_label.empty ())
+      {
+        bool item_added = false;
+        do
+          {
+            const Fl_Menu_Item* item
+              = menubar->find_item (fltk_label.c_str ());
 
-              if (item == NULL)
-                {
-                  Matrix uimenu_ch = find_uimenu_children (uimenup);
-                  int len = uimenu_ch.numel ();
-                  int flags = 0;
-                  if (len > 0)
-                    flags = FL_SUBMENU;
-                  if (len == 0 && uimenup.is_checked ())
-                    flags += FL_MENU_TOGGLE + FL_MENU_VALUE;
-                  menubar->add (fltk_label.c_str (), 0, 0, 0, flags);
-                  item_added = true;
-                }
-              else
-                {
-                  //avoid duplicate menulabels
-                  std::size_t idx1 = fltk_label.find_last_of ("(");
-                  std::size_t idx2 = fltk_label.find_last_of (")");
-                  int len = idx2 - idx1;
-                  int val = 1;
-                  if (len > 0)
-                    {
-                      std::string valstr = fltk_label.substr (idx1 + 1, len - 1);
-                      fltk_label.erase (idx1, len + 1);
-                      val = atoi (valstr.c_str ());
-                      if (val > 0 && val < 99)
-                        val++;
-                    }
-                  std::ostringstream valstream;
-                  valstream << val;
-                  fltk_label += "(" + valstream.str () + ")";
-                }
-            }
-          while (!item_added);
-          uimenup.set_fltk_label (fltk_label);
-        }
-    }
+            if (item == NULL)
+              {
+                Matrix uimenu_ch = find_uimenu_children (uimenup);
+                int len = uimenu_ch.numel ();
+                int flags = 0;
+                if (len > 0)
+                  flags = FL_SUBMENU;
+                if (len == 0 && uimenup.is_checked ())
+                  flags += FL_MENU_TOGGLE + FL_MENU_VALUE;
+                menubar->add (fltk_label.c_str (), 0, 0, 0, flags);
+                item_added = true;
+              }
+            else
+              {
+                //avoid duplicate menulabels
+                std::size_t idx1 = fltk_label.find_last_of ("(");
+                std::size_t idx2 = fltk_label.find_last_of (")");
+                int len = idx2 - idx1;
+                int val = 1;
+                if (len > 0)
+                  {
+                    std::string valstr = fltk_label.substr (idx1 + 1, len - 1);
+                    fltk_label.erase (idx1, len + 1);
+                    val = atoi (valstr.c_str ());
+                    if (val > 0 && val < 99)
+                      val++;
+                  }
+                std::ostringstream valstream;
+                valstream << val;
+                fltk_label += "(" + valstream.str () + ")";
+              }
+          }
+        while (!item_added);
+        uimenup.set_fltk_label (fltk_label);
+      }
+  }
 
   void add_to_menu (uimenu::properties& uimenup)
-    {
-      Matrix kids = find_uimenu_children (uimenup);
-      int len = kids.length ();
-      std::string fltk_label = uimenup.get_fltk_label ();
+  {
+    Matrix kids = find_uimenu_children (uimenup);
+    int len = kids.length ();
+    std::string fltk_label = uimenup.get_fltk_label ();
 
-      add_entry (uimenup);
-      update_foregroundcolor (uimenup);
-      update_callback (uimenup);
-      update_accelerator (uimenup);
-      update_enable (uimenup);
-      update_visible (uimenup);
-      update_seperator (uimenup);
+    add_entry (uimenup);
+    update_foregroundcolor (uimenup);
+    update_callback (uimenup);
+    update_accelerator (uimenup);
+    update_enable (uimenup);
+    update_visible (uimenup);
+    update_seperator (uimenup);
 
-      for (octave_idx_type ii = 0; ii < len; ii++)
-        {
-          graphics_object kgo = gh_manager::get_object (kids (len - (ii + 1)));
-          if (kgo.valid_object ())
-            {
-              uimenu::properties& kprop = dynamic_cast<uimenu::properties&> (kgo.get_properties ());
-              add_to_menu (kprop);
-            }
-        }
-    }
+    for (octave_idx_type ii = 0; ii < len; ii++)
+      {
+        graphics_object kgo = gh_manager::get_object (kids (len - (ii + 1)));
+        if (kgo.valid_object ())
+          {
+            uimenu::properties& kprop = dynamic_cast<uimenu::properties&>
+                                        (kgo.get_properties ());
+            add_to_menu (kprop);
+          }
+      }
+  }
 
   void add_to_menu (figure::properties& figp)
-    {
-      Matrix kids = find_uimenu_children (figp);
-      int len = kids.length ();
-      menubar->clear ();
-      for (octave_idx_type ii = 0; ii < len; ii++)
-        {
-          graphics_object kgo = gh_manager::get_object (kids (len - (ii + 1)));
+  {
+    Matrix kids = find_uimenu_children (figp);
+    int len = kids.length ();
+    menubar->clear ();
+    for (octave_idx_type ii = 0; ii < len; ii++)
+      {
+        graphics_object kgo = gh_manager::get_object (kids (len - (ii + 1)));
 
-          if (kgo.valid_object ())
-            {
-              uimenu::properties& kprop = dynamic_cast<uimenu::properties&> (kgo.get_properties ());
-              add_to_menu (kprop);
-            }
-        }
-    }
+        if (kgo.valid_object ())
+          {
+            uimenu::properties& kprop = dynamic_cast<uimenu::properties&>
+                                        (kgo.get_properties ());
+            add_to_menu (kprop);
+          }
+      }
+  }
 
   template <class T_prop>
   void remove_from_menu (T_prop& prop)
-    {
-      Matrix kids;
-      std::string type = prop.get_type ();
-      kids = find_uimenu_children (prop);
-      int len = kids.length ();
+  {
+    Matrix kids;
+    std::string type = prop.get_type ();
+    kids = find_uimenu_children (prop);
+    int len = kids.length ();
 
-      for (octave_idx_type ii = 0; ii < len; ii++)
-        {
-          graphics_object kgo = gh_manager::get_object (kids (len - (ii + 1)));
+    for (octave_idx_type ii = 0; ii < len; ii++)
+      {
+        graphics_object kgo = gh_manager::get_object (kids (len - (ii + 1)));
 
-          if (kgo.valid_object ())
-            {
-              uimenu::properties kprop = dynamic_cast<uimenu::properties&> (kgo.get_properties ());
-              remove_from_menu (kprop);
-            }
-        }
+        if (kgo.valid_object ())
+          {
+            uimenu::properties kprop = dynamic_cast<uimenu::properties&>
+                                       (kgo.get_properties ());
+            remove_from_menu (kprop);
+          }
+      }
 
-      if (type.compare ("uimenu") == 0)
-        delete_entry (dynamic_cast<uimenu::properties&> (prop));
-      else if (type.compare ("figure") == 0)
-        menubar->clear ();
-    }
+    if (type.compare ("uimenu") == 0)
+      delete_entry (dynamic_cast<uimenu::properties&> (prop));
+    else if (type.compare ("figure") == 0)
+      menubar->clear ();
+  }
 
   ~fltk_uimenu (void)
-    {
-      delete menubar;
-    }
+  {
+    delete menubar;
+  }
 
 private:
 
   // No copying!
 
   fltk_uimenu (const fltk_uimenu&);
 
   fltk_uimenu operator = (const fltk_uimenu&);
@@ -1081,30 +1091,30 @@ private:
       }
 
     status->value (cbuf.str ().c_str ());
     status->redraw ();
   }
 
   void view2status (graphics_object ax)
   {
-     if (ax && ax.isa ("axes"))
-       {
-         axes::properties& ap =
-           dynamic_cast<axes::properties&> (ax.get_properties ());
-         std::stringstream cbuf;
-         cbuf.precision (4);
-         cbuf.width (6);
-         Matrix v (1,2,0);
-         v = ap.get ("view").matrix_value ();
-         cbuf << "[azimuth: " << v(0) << ", elevation: " << v(1) << "]";
+    if (ax && ax.isa ("axes"))
+      {
+        axes::properties& ap =
+          dynamic_cast<axes::properties&> (ax.get_properties ());
+        std::stringstream cbuf;
+        cbuf.precision (4);
+        cbuf.width (6);
+        Matrix v (1,2,0);
+        v = ap.get ("view").matrix_value ();
+        cbuf << "[azimuth: " << v(0) << ", elevation: " << v(1) << "]";
 
-         status->value (cbuf.str ().c_str ());
-         status->redraw ();
-       }
+        status->value (cbuf.str ().c_str ());
+        status->redraw ();
+      }
   }
 
   void set_currentpoint (int px, int py)
   {
     if (!fp.is_beingdeleted ())
       {
         Matrix pos (1,2,0);
         pos(0) = px;
@@ -1134,22 +1144,22 @@ private:
         pos(1,1) = yy;
 
         ap.set_currentpoint (pos);
         fp.set_currentaxes (ap.get___myhandle__ ().value ());
       }
   }
 
   int menu_dy ()
-    {
-      if (uimenu->is_visible ())
-        return menu_h;
-      else
-        return 0;
-    }
+  {
+    if (uimenu->is_visible ())
+      return menu_h;
+    else
+      return 0;
+  }
 
   int key2shift (int key)
   {
     if (key == FL_Shift_L || key == FL_Shift_R)
       return FL_SHIFT;
 
     if (key == FL_Control_L || key == FL_Control_R)
       return FL_CTRL;
@@ -1256,32 +1266,32 @@ private:
                   evt.assign ("Modifier", octave_value (modifier2cell ()));
                   fp.execute_keypressfcn (evt);
                 }
               switch (key)
                 {
                 case 'a':
                 case 'A':
                   axis_auto ();
-                break;
+                  break;
 
                 case 'g':
                 case 'G':
                   toggle_grid ();
-                break;
+                  break;
 
                 case 'p':
                 case 'P':
                   gui_mode = pan_zoom;
-                break;
+                  break;
 
                 case 'r':
                 case 'R':
                   gui_mode = rotate_zoom;
-                break;
+                  break;
                 }
             }
             break;
 
           case FL_KEYUP:
             {
               int key = Fl::event_key ();
 
@@ -1294,17 +1304,18 @@ private:
                   evt.assign ("Key", octave_value (std::tolower (key_a)));
                   evt.assign ("Modifier", octave_value (modifier2cell ()));
                   fp.execute_keyreleasefcn (evt);
                 }
             }
             break;
 
           case FL_MOVE:
-            pixel2status (pixel2axes_or_ca (Fl::event_x (), Fl::event_y () - menu_dy ()),
+            pixel2status (pixel2axes_or_ca (Fl::event_x (),
+                                            Fl::event_y () - menu_dy ()),
                           Fl::event_x (), Fl::event_y () - menu_dy ());
             break;
 
           case FL_PUSH:
             pos_x = Fl::event_x ();
             pos_y = Fl::event_y () - menu_dy ();
 
             set_currentpoint (Fl::event_x (), Fl::event_y () - menu_dy ());
@@ -1312,17 +1323,17 @@ private:
             gh = pixel2axes_or_ca (pos_x, pos_y);
 
             if (gh.ok ())
               {
                 ax_obj = gh_manager::get_object (gh);
                 set_axes_currentpoint (ax_obj, pos_x, pos_y);
               }
 
-            fp.execute_windowbuttondownfcn (Fl::event_button()); 
+            fp.execute_windowbuttondownfcn (Fl::event_button());
 
             if (Fl::event_button () == 1 || Fl::event_button () == 3)
               return 1;
 
             break;
 
           case FL_DRAG:
             if (fp.get_windowbuttonmotionfcn ().is_defined ())
@@ -1332,34 +1343,39 @@ private:
               }
 
             if (Fl::event_button () == 1)
               {
                 if (ax_obj && ax_obj.isa ("axes"))
                   {
                     if (gui_mode == pan_zoom)
                       pixel2status (ax_obj, pos_x, pos_y,
-                                    Fl::event_x (), Fl::event_y () - menu_dy ());
+                                    Fl::event_x (),
+                                    Fl::event_y () - menu_dy ());
                     else
                       view2status (ax_obj);
                     axes::properties& ap =
-                      dynamic_cast<axes::properties&> (ax_obj.get_properties ());
+                      dynamic_cast<axes::properties&>
+                      (ax_obj.get_properties ());
 
                     double x0, y0, x1, y1;
                     Matrix pos = fp.get_boundingbox (true);
                     pixel2pos (ax_obj, pos_x, pos_y, x0, y0);
-                    pixel2pos (ax_obj, Fl::event_x (), Fl::event_y () - menu_dy (), x1, y1);
+                    pixel2pos (ax_obj, Fl::event_x (),
+                                       Fl::event_y () - menu_dy (),
+                                       x1, y1);
 
                     if (gui_mode == pan_zoom)
                       ap.translate_view (x0, x1, y0, y1);
                     else if (gui_mode == rotate_zoom)
                       {
                         double daz, del;
                         daz = (Fl::event_x () - pos_x) / pos(2) * 360;
-                        del = (Fl::event_y () - menu_dy () - pos_y) / pos(3) * 360;
+                        del = (Fl::event_y () - menu_dy () - pos_y)
+                              / pos(3) * 360;
                         ap.rotate_view (del, daz);
                       }
 
                     pos_x = Fl::event_x ();
                     pos_y = Fl::event_y () - menu_dy ();
                     mark_modified ();
                   }
                 return 1;
@@ -1379,70 +1395,72 @@ private:
               }
 
             break;
 
           case FL_MOUSEWHEEL:
             {
               graphics_object ax =
                 gh_manager::get_object (pixel2axes_or_ca (Fl::event_x (),
-                                                          Fl::event_y () - menu_dy ()));
+                                                          Fl::event_y ()
+                                                          - menu_dy ()));
               if (ax && ax.isa ("axes"))
                 {
                   axes::properties& ap =
                     dynamic_cast<axes::properties&> (ax.get_properties ());
 
                   // Determine if we're zooming in or out.
                   const double factor =
                     (Fl::event_dy () > 0) ? 1 / (1.0 - Vwheel_zoom_speed)
                                           : 1.0 - Vwheel_zoom_speed;
 
                   // Get the point we're zooming about.
                   double x1, y1;
-                  pixel2pos (ax, Fl::event_x (), Fl::event_y () - menu_dy (), x1, y1);
+                  pixel2pos (ax, Fl::event_x (), Fl::event_y () - menu_dy (),
+                             x1, y1);
 
                   ap.zoom_about_point (x1, y1, factor, false);
                   mark_modified ();
                 }
             }
-          return 1;
+            return 1;
 
           case FL_RELEASE:
             if (fp.get_windowbuttonupfcn ().is_defined ())
               {
                 set_currentpoint (Fl::event_x (), Fl::event_y () - menu_dy ());
                 fp.execute_windowbuttonupfcn ();
               }
 
             if (Fl::event_button () == 1)
               {
                 if ( Fl::event_clicks () == 1)
                   {
                     if (ax_obj && ax_obj.isa ("axes"))
                       {
-                        axes::properties& ap =
-                          dynamic_cast<axes::properties&> (ax_obj.get_properties ());
+                        axes::properties& ap = dynamic_cast<axes::properties&>
+                                               (ax_obj.get_properties ());
                         ap.set_xlimmode ("auto");
                         ap.set_ylimmode ("auto");
                         ap.set_zlimmode ("auto");
                         mark_modified ();
                       }
                   }
               }
             if (Fl::event_button () == 3)
               {
                 // End of drag -- zoom.
                 if (canvas->zoom ())
                   {
                     canvas->zoom (false);
                     double x0,y0,x1,y1;
                     if (ax_obj && ax_obj.isa ("axes"))
                       {
-                        axes::properties& ap =
-                          dynamic_cast<axes::properties&> (ax_obj.get_properties ());
+                        axes::properties& ap = dynamic_cast<axes::properties&>
+                                               (ax_obj.get_properties ());
                         pixel2pos (ax_obj, pos_x, pos_y, x0, y0);
                         int pos_x1 = Fl::event_x ();
                         int pos_y1 = Fl::event_y () - menu_dy ();
                         pixel2pos (ax_obj, pos_x1, pos_y1, x1, y1);
                         Matrix xl (1,2,0);
                         Matrix yl (1,2,0);
                         int dx = abs (pos_x - pos_x1);
                         int dy = abs (pos_y - pos_y1);
@@ -1843,17 +1861,17 @@ static int
           Matrix children = props.get_all_children ();
 
           for (octave_idx_type n = 0; n < children.numel (); n++)
             {
               graphics_object fobj = gh_manager::get_object (children (n));
               if (fobj && fobj.isa ("figure"))
                 {
                   figure::properties& fp =
-                      dynamic_cast<figure::properties&> (fobj.get_properties ());
+                    dynamic_cast<figure::properties&> (fobj.get_properties ());
                   if (fp.get___graphics_toolkit__ ()
                       == FLTK_GRAPHICS_TOOLKIT_NAME)
                     figure_manager::new_window (fp);
                 }
             }
         }
 
       // it seems that we have to call Fl::check twice to get everything drawn
@@ -1905,19 +1923,20 @@ public:
   {
     if (uimenu_obj.valid_object ())
       {
         uimenu::properties& uimenup =
           dynamic_cast<uimenu::properties&> (uimenu_obj.get_properties ());
         std::string fltk_label = uimenup.get_label ();
         graphics_object go = gh_manager::get_object (uimenu_obj.get_parent ());
         if (go.isa ("uimenu"))
-          fltk_label = dynamic_cast<const uimenu::properties&> (go.get_properties ()).get_fltk_label ()
-            + "/"
-            + fltk_label;
+          fltk_label = dynamic_cast<const uimenu::properties&>
+                       (go.get_properties ()).get_fltk_label ()
+                       + "/"
+                       + fltk_label;
         else if (go.isa ("figure"))
           ;
         else
           error ("unexpected parent object\n");
 
         uimenup.set_fltk_label (fltk_label);
       }
   }
@@ -1931,28 +1950,28 @@ public:
         if (! ov.is_empty ())
           {
             const figure::properties& fp =
               dynamic_cast<const figure::properties&> (go.get_properties ());
 
             switch (id)
               {
               case base_properties::ID_VISIBLE:
-                figure_manager::toggle_window_visibility
-                  (ov.string_value (), fp.is_visible ());
+                figure_manager::toggle_window_visibility (ov.string_value (),
+                                                          fp.is_visible ());
                 break;
 
               case figure::properties::ID_MENUBAR:
                 figure_manager::toggle_menubar_visibility
                   (ov.string_value (), fp.menubar_is ("figure"));
                 break;
 
               case figure::properties::ID_CURRENTAXES:
-                figure_manager::update_canvas
-                  (go.get_handle (), fp.get_currentaxes ());
+                figure_manager::update_canvas (go.get_handle (),
+                                               fp.get_currentaxes ());
                 break;
 
               case figure::properties::ID_NAME:
               case figure::properties::ID_NUMBERTITLE:
                 figure_manager::set_name (ov.string_value ());
                 break;
 
               case figure::properties::ID_INTEGERHANDLE:
@@ -2037,34 +2056,34 @@ public:
 
 private:
   octave_value_list input_event_hook_fcn_id;
 };
 
 #endif
 
 DEFUN_DLD (__fltk_redraw__, , ,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __fltk_redraw__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifdef HAVE_FLTK
   __fltk_redraw__ ();
 #else
   error ("__fltk_redraw__: not available without OpenGL and FLTK libraries");
 #endif
 
   return octave_value ();
 }
 
 // Initialize the fltk graphics toolkit.
 
 DEFUN_DLD (__init_fltk__, , ,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __init_fltk__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifdef HAVE_FLTK
   if (! toolkit_loaded)
     {
       mlock ();
@@ -2083,17 +2102,17 @@ Undocumented internal function.\n\
 #else
   error ("__init_fltk__: not available without OpenGL and FLTK libraries");
 #endif
 
   return octave_value ();
 }
 
 DEFUN_DLD (__fltk_maxtime__, args, ,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{maxtime} =} __fltk_maxtime__ ()\n\
 @deftypefnx {Loadable Function} {} __fltk_maxtime__ (@var{maxtime})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifdef HAVE_FLTK
   octave_value retval = fltk_maxtime;
 
@@ -2108,17 +2127,17 @@ Undocumented internal function.\n\
   return retval;
 #else
   error ("__fltk_maxtime__: not available without OpenGL and FLTK libraries");
   return octave_value ();
 #endif
 }
 
 DEFUN_DLD (__have_fltk__, , ,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{FLTK_available} =} __have_fltk__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_FLTK
   retval = true;
@@ -2132,17 +2151,17 @@ Undocumented internal function.\n\
 // FIXME: This function should be abstracted and made potentially
 // available to all graphics toolkits.  This suggests putting it in
 // graphics.cc as is done for drawnow() and having the master
 // mouse_wheel_zoom function call fltk_mouse_wheel_zoom.  The same
 // should be done for gui_mode and fltk_gui_mode.  For now (2011.01.30),
 // just changing function names and docstrings.
 
 DEFUN_DLD (mouse_wheel_zoom, args, nargout,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{val} =} mouse_wheel_zoom ()\n\
 @deftypefnx {Loadable Function} {@var{old_val} =} mouse_wheel_zoom (@var{new_val})\n\
 @deftypefnx {Loadable Function} {} mouse_wheel_zoom (@var{new_val}, \"local\")\n\
 Query or set the mouse wheel zoom factor.\n\
 \n\
 The zoom factor is a number in the range (0,1) which is the percentage of the\n\
 current axis limits that will be used when zooming.  For example, if the\n\
 current x-axis limits are [0, 50] and @code{mouse_wheel_zoom} is 0.4 (40%),\n\
@@ -2160,17 +2179,17 @@ This function is currently implemented o
   return SET_INTERNAL_VARIABLE_WITH_LIMITS(wheel_zoom_speed, 0.0001, 0.9999);
 #else
   error ("mouse_wheel_zoom: not available without OpenGL and FLTK libraries");
   return octave_value ();
 #endif
 }
 
 DEFUN_DLD (gui_mode, args, ,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{mode} =} gui_mode ()\n\
 @deftypefnx {Built-in Function} {} gui_mode (@var{mode})\n\
 Query or set the GUI mode for the current graphics toolkit.\n\
 The @var{mode} argument can be one of the following strings:\n\
 \n\
 @table @asis\n\
 @item @qcode{\"2d\"}\n\
 Allows panning and zooming of current axes.\n\
diff --git a/libinterp/dldfcn/__init_gnuplot__.cc b/libinterp/dldfcn/__init_gnuplot__.cc
--- a/libinterp/dldfcn/__init_gnuplot__.cc
+++ b/libinterp/dldfcn/__init_gnuplot__.cc
@@ -43,132 +43,132 @@ To initialize:
 // PKG_ADD: register_graphics_toolkit ("gnuplot");
 
 static bool toolkit_loaded = false;
 
 class gnuplot_graphics_toolkit : public base_graphics_toolkit
 {
 public:
   gnuplot_graphics_toolkit (void)
-      : base_graphics_toolkit ("gnuplot") { }
+    : base_graphics_toolkit ("gnuplot") { }
 
   ~gnuplot_graphics_toolkit (void) { }
 
   bool is_valid (void) const { return true; }
 
   bool initialize (const graphics_object& go)
-    {
-      return go.isa ("figure");
-    }
+  {
+    return go.isa ("figure");
+  }
 
   void finalize (const graphics_object& go)
-    {
-      if (go.isa ("figure"))
-        {
-          const figure::properties& props =
-              dynamic_cast<const figure::properties&> (go.get_properties ());
+  {
+    if (go.isa ("figure"))
+      {
+        const figure::properties& props =
+          dynamic_cast<const figure::properties&> (go.get_properties ());
 
-          send_quit (props.get___plot_stream__ ());
-        }
-    }
+        send_quit (props.get___plot_stream__ ());
+      }
+  }
 
   void update (const graphics_object& go, int id)
-    {
-      if (go.isa ("figure"))
-        {
-          graphics_object obj (go);
+  {
+    if (go.isa ("figure"))
+      {
+        graphics_object obj (go);
 
-          figure::properties& props =
-              dynamic_cast<figure::properties&> (obj.get_properties ());
+        figure::properties& props =
+          dynamic_cast<figure::properties&> (obj.get_properties ());
 
-          switch (id)
-            {
-            case base_properties::ID_VISIBLE:
-              if (! props.is_visible ())
-                {
-                  send_quit (props.get___plot_stream__ ());
-                  props.set___plot_stream__ (Matrix ());
-                  props.set___enhanced__ (false);
-                }
-              break;
-            }
-        }
-    }
+        switch (id)
+          {
+          case base_properties::ID_VISIBLE:
+            if (! props.is_visible ())
+              {
+                send_quit (props.get___plot_stream__ ());
+                props.set___plot_stream__ (Matrix ());
+                props.set___enhanced__ (false);
+              }
+            break;
+          }
+      }
+  }
 
   void redraw_figure (const graphics_object& go) const
-    {
-      octave_value_list args;
-      args(0) = go.get_handle ().as_octave_value ();
-      feval ("__gnuplot_drawnow__", args);
-    }
+  {
+    octave_value_list args;
+    args(0) = go.get_handle ().as_octave_value ();
+    feval ("__gnuplot_drawnow__", args);
+  }
 
   void print_figure (const graphics_object& go, const std::string& term,
                      const std::string& file, bool mono,
                      const std::string& debug_file) const
-    {
-      octave_value_list args;
-      if (! debug_file.empty ())
-        args(4) = debug_file;
-      args(3) = mono;
-      args(2) = file;
-      args(1) = term;
-      args(0) = go.get_handle ().as_octave_value ();
-      feval ("__gnuplot_drawnow__", args);
-    }
+  {
+    octave_value_list args;
+    if (! debug_file.empty ())
+      args(4) = debug_file;
+    args(3) = mono;
+    args(2) = file;
+    args(1) = term;
+    args(0) = go.get_handle ().as_octave_value ();
+    feval ("__gnuplot_drawnow__", args);
+  }
 
   Matrix get_canvas_size (const graphics_handle&) const
-    {
-      Matrix sz (1, 2, 0.0);
-      return sz;
-    }
+  {
+    Matrix sz (1, 2, 0.0);
+    return sz;
+  }
 
   double get_screen_resolution (void) const
-    { return 72.0; }
+  { return 72.0; }
 
   Matrix get_screen_size (void) const
-    { return Matrix (1, 2, 0.0); }
+  { return Matrix (1, 2, 0.0); }
 
   void close (void)
   {
     if (toolkit_loaded)
       {
         munlock ("__init_gnuplot__");
 
         gtk_manager::unload_toolkit ("gnuplot");
 
         toolkit_loaded = false;
       }
   }
 
 private:
 
   void send_quit (const octave_value& pstream) const
-    {
-      if (! pstream.is_empty ())
-        {
-          octave_value_list args;
-          Matrix fids = pstream.matrix_value ();
+  {
+    if (! pstream.is_empty ())
+      {
+        octave_value_list args;
+        Matrix fids = pstream.matrix_value ();
 
-          if (! error_state)
-            {
-              Ffputs (ovl (fids(0), "\nquit;\n"));
+        if (! error_state)
+          {
+            Ffputs (ovl (fids(0), "\nquit;\n"));
 
-              Ffflush (ovl (fids(0)));
-              Fpclose (ovl (fids(0)));
+            Ffflush (ovl (fids(0)));
+            Fpclose (ovl (fids(0)));
 
-              if (fids.numel () > 1)
-                {
-                  Fpclose (ovl (fids(1)));
+            if (fids.numel () > 1)
+              {
+                Fpclose (ovl (fids(1)));
 
-                  if (fids.numel () > 2)
-                    Fwaitpid (ovl (fids(2)));
-                }
-            }
-        }
-    }
+                if (fids.numel () > 2)
+                  Fwaitpid (ovl (fids(2)));
+              }
+          }
+      }
+  }
 };
 
 // Initialize the fltk graphics toolkit.
 
 DEFUN_DLD (__init_gnuplot__, , , "")
 {
   octave_value retval;
 
diff --git a/libinterp/dldfcn/__magick_read__.cc b/libinterp/dldfcn/__magick_read__.cc
--- a/libinterp/dldfcn/__magick_read__.cc
+++ b/libinterp/dldfcn/__magick_read__.cc
@@ -206,22 +206,22 @@ read_indexed_images (const std::vector<M
   // imvec has all of the pages of a file, even the ones we are not
   // interested in. We will use the first image that we will be actually
   // reading to get information about the image.
   const octave_idx_type def_elem = frameidx(0);
 
   T img       = T (dim_vector (nRows, nCols, 1, nFrames));
   P* img_fvec = img.fortran_vec ();
 
-  const octave_idx_type row_start  = region["row_start"];
-  const octave_idx_type col_start  = region["col_start"];
-  const octave_idx_type row_shift  = region["row_shift"];
-  const octave_idx_type col_shift  = region["col_shift"];
-  const octave_idx_type row_cache  = region["row_cache"];
-  const octave_idx_type col_cache  = region["col_cache"];
+  const octave_idx_type row_start = region["row_start"];
+  const octave_idx_type col_start = region["col_start"];
+  const octave_idx_type row_shift = region["row_shift"];
+  const octave_idx_type col_shift = region["col_shift"];
+  const octave_idx_type row_cache = region["row_cache"];
+  const octave_idx_type col_cache = region["col_cache"];
 
   // When reading PixelPackets from the Image Pixel Cache, they come in
   // row major order. So we keep moving back and forth there so we can
   // write the image in column major order.
   octave_idx_type idx = 0;
   for (octave_idx_type frame = 0; frame < nFrames; frame++)
     {
       imvec[frameidx(frame)].getConstPixels (col_start, row_start,
@@ -237,17 +237,17 @@ read_indexed_images (const std::vector<M
               img_fvec[idx++] = static_cast<P> (*pix);
               pix += row_shift;
             }
           pix -= col_shift;
         }
     }
   retval(0) = octave_value (img);
 
-//   Only bother reading the colormap if it was requested as output.
+  // Only bother reading the colormap if it was requested as output.
   if (nargout > 1)
     {
       // In theory, it should be possible for each frame of an image to
       // have different colormaps but for Matlab compatibility, we only
       // return the colormap of the first frame.  To obtain the colormaps
       // of different frames, one needs can either use imfinfo or a for
       // loop around imread.
       const octave_value_list maps =
@@ -298,22 +298,22 @@ read_images (std::vector<Magick::Image>&
   const octave_idx_type nCols = region["col_out"];
   T img;
 
   // imvec has all of the pages of a file, even the ones we are not
   // interested in. We will use the first image that we will be actually
   // reading to get information about the image.
   const octave_idx_type def_elem = frameidx(0);
 
-  const octave_idx_type row_start  = region["row_start"];
-  const octave_idx_type col_start  = region["col_start"];
-  const octave_idx_type row_shift  = region["row_shift"];
-  const octave_idx_type col_shift  = region["col_shift"];
-  const octave_idx_type row_cache  = region["row_cache"];
-  const octave_idx_type col_cache  = region["col_cache"];
+  const octave_idx_type row_start = region["row_start"];
+  const octave_idx_type col_start = region["col_start"];
+  const octave_idx_type row_shift = region["row_shift"];
+  const octave_idx_type col_shift = region["col_shift"];
+  const octave_idx_type row_cache = region["row_cache"];
+  const octave_idx_type col_cache = region["col_cache"];
 
   // GraphicsMagick (GM) keeps the image values in memory using whatever
   // QuantumDepth it was built with independently of the original image
   // bitdepth. Basically this means that if GM was built with quantum 16
   // all values are scaled in the uint16 range. If the original image
   // had an 8 bit depth, we need to rescale it for that range.
   // However, if the image had a bitdepth of 32, then we will be returning
   // a floating point image. In this case, the values need to be rescaled
@@ -357,17 +357,19 @@ read_images (std::vector<Magick::Image>&
       // These values come from libpng, not GM:
       //      Grayscale         = 0
       //      Palette           = 2 + 1
       //      RGB               = 2
       //      RGB + Alpha       = 2 + 4
       //      Grayscale + Alpha = 4
       // We won't bother with case 3 (palette) since those should be
       // read by the function to read indexed images
-      const std::string type_str = imvec[0].attribute ("PNG:IHDR.color-type-orig");
+      const std::string type_str
+        = imvec[0].attribute ("PNG:IHDR.color-type-orig");
+
       if (type_str == "0")
         type = Magick::GrayscaleType;
       else if (type_str == "2")
         type = Magick::TrueColorType;
       else if (type_str == "6")
         type = Magick::TrueColorMatteType;
       else if (type_str == "4")
         type = Magick::GrayscaleMatteType;
@@ -501,18 +503,18 @@ read_images (std::vector<Magick::Image>&
                     idx++;
                   }
                 pix -= col_shift;
               }
           }
         break;
       }
 
-    case Magick::PaletteMatteType:      // Indexed color (palette) image with opacity
-    case Magick::TrueColorMatteType:    // Truecolor image with opacity
+    case Magick::PaletteMatteType:    // Indexed color image with opacity
+    case Magick::TrueColorMatteType:  // Truecolor image with opacity
       {
         img   = T (dim_vector (nRows, nCols, 3, nFrames));
         T alpha   (dim_vector (nRows, nCols, 1, nFrames));
         P *img_fvec = img.fortran_vec ();
         P *a_fvec   = alpha.fortran_vec ();
 
         // Unlike the index for the other channels, this one won't need
         // to be reset on each frame since it's a separate matrix.
@@ -542,17 +544,17 @@ read_images (std::vector<Magick::Image>&
                   }
                 pix -= col_shift;
               }
           }
         retval(2) = alpha;
         break;
       }
 
-    case Magick::ColorSeparationType:   // Cyan/Yellow/Magenta/Black (CYMK) image
+    case Magick::ColorSeparationType:  // Cyan/Magenta/Yellow/Black (CMYK) image
       {
         img   = T (dim_vector (nRows, nCols, 4, nFrames));
         P *img_fvec = img.fortran_vec ();
 
         for (octave_idx_type frame = 0; frame < nFrames; frame++)
           {
             const Magick::PixelPacket *pix
               = imvec[frameidx(frame)].getConstPixels (col_start, row_start,
@@ -671,33 +673,34 @@ maybe_initialize_magick (void)
 
   if (! initialized)
     {
       // Save locale as GraphicsMagick might change this (fixed in
       // GraphicsMagick since version 1.3.13 released on December 24, 2011)
       const char *static_locale = setlocale (LC_ALL, NULL);
       const std::string locale (static_locale);
 
-      const std::string program_name = octave_env::get_program_invocation_name ();
+      const std::string program_name
+        = octave_env::get_program_invocation_name ();
       Magick::InitializeMagick (program_name.c_str ());
 
       // Restore locale from before GraphicsMagick initialisation
       setlocale (LC_ALL, locale.c_str ());
 
       if (QuantumDepth < 32)
         warning ("your version of %s limits images to %d bits per pixel",
                  MagickPackageName, QuantumDepth);
 
       initialized = true;
     }
 }
 #endif
 
 DEFUN_DLD (__magick_read__, args, nargout,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{img}, @var{map}, @var{alpha}] =} __magick_read__ (@var{fname}, @var{options})\n\
 Read image with GraphicsMagick or ImageMagick.\n\
 \n\
 This is a private internal function not intended for direct use.  Instead\n\
 use @code{imread}.\n\
 \n\
 @seealso{imfinfo, imformats, imread, imwrite}\n\
 @end deftypefn")
@@ -849,25 +852,25 @@ init_enconde_image (const octave_idx_typ
 
   img.classType (klass);
   img.type (type);
   // FIXME: for some reason, setting bitdepth doesn't seem to work for
   //        indexed images.
   img.depth (bitdepth);
   switch (type)
     {
-      case Magick::GrayscaleMatteType:
-      case Magick::TrueColorMatteType:
-      case Magick::ColorSeparationMatteType:
-      case Magick::PaletteMatteType:
-        img.matte (true);
-        break;
+    case Magick::GrayscaleMatteType:
+    case Magick::TrueColorMatteType:
+    case Magick::ColorSeparationMatteType:
+    case Magick::PaletteMatteType:
+      img.matte (true);
+      break;
 
-      default:
-        img.matte (false);
+    default:
+      img.matte (false);
     }
 
   return img;
 }
 
 template <class T>
 static void
 encode_indexed_images (std::vector<Magick::Image>& imvec,
@@ -909,19 +912,19 @@ encode_indexed_images (std::vector<Magic
       // index values? We don't know if a file format supports indexed
       // images. If we only set the indexes and then try to save the
       // image as JPEG for example, the indexed values get discarded,
       // there is no conversion from the indexes, it's the initial values
       // that get used. An alternative would be to only set the pixel
       // values (no indexes), then set the image as PseudoClass and GM
       // would create a colormap for us. However, we wouldn't have control
       // over the order of that colormap. And that's why we set both.
-      Magick::PixelPacket* pix  = m_img.getPixels (0, 0, nCols, nRows);
-      Magick::IndexPacket* ind  = m_img.getIndexes ();
-      const P* img_fvec         = img.fortran_vec ();
+      Magick::PixelPacket* pix = m_img.getPixels (0, 0, nCols, nRows);
+      Magick::IndexPacket* ind = m_img.getIndexes ();
+      const P* img_fvec        = img.fortran_vec ();
 
       octave_idx_type GM_idx = 0;
       for (octave_idx_type column = 0; column < nCols; column++)
         {
           for (octave_idx_type row = 0; row < nRows; row++)
             {
               ind[GM_idx] = double (*img_fvec);
               pix[GM_idx] = m_img.colorMap (double (*img_fvec));
@@ -983,21 +986,21 @@ encode_bool_image (std::vector<Magick::I
 }
 
 template <class T>
 static void
 encode_uint_image (std::vector<Magick::Image>& imvec,
                    const T& img, const T& alpha)
 {
   typedef typename T::element_type P;
-  const octave_idx_type channels  = img.ndims () < 3 ? 1 : img.dims ()(2);
-  const octave_idx_type nFrames   = img.ndims () < 4 ? 1 : img.dims ()(3);
-  const octave_idx_type nRows     = img.rows ();
-  const octave_idx_type nCols     = img.columns ();
-  const octave_idx_type bitdepth  = bitdepth_from_class<T> ();
+  const octave_idx_type channels = img.ndims () < 3 ? 1 : img.dims ()(2);
+  const octave_idx_type nFrames  = img.ndims () < 4 ? 1 : img.dims ()(3);
+  const octave_idx_type nRows    = img.rows ();
+  const octave_idx_type nCols    = img.columns ();
+  const octave_idx_type bitdepth = bitdepth_from_class<T> ();
 
   Magick::ImageType type;
   const bool has_alpha = ! alpha.is_empty ();
   switch (channels)
     {
     case 1:
       if (has_alpha)
         type = Magick::GrayscaleMatteType;
@@ -1029,17 +1032,18 @@ encode_uint_image (std::vector<Magick::I
 
   // We will be passing the values as integers with depth as specified
   // by QuantumDepth (maximum value specified by MaxRGB). This is independent
   // of the actual depth of the image. GM will then convert the values but
   // while in memory, it always keeps the values as specified by QuantumDepth.
   // From GM documentation:
   //  Color arguments are must be scaled to fit the Quantum size according to
   //  the range of MaxRGB
-  const double divisor = static_cast<double>((uint64_t (1) << bitdepth) - 1) / MaxRGB;
+  const double divisor = static_cast<double>((uint64_t (1) << bitdepth) - 1)
+                         / MaxRGB;
 
   const P *img_fvec = img.fortran_vec ();
   const P *a_fvec   = alpha.fortran_vec ();
   switch (type)
     {
     case Magick::GrayscaleType:
       {
         octave_idx_type GM_idx = 0;
@@ -1272,17 +1276,17 @@ write_file (const std::string& filename,
       error ("Magick++ exception: %s", e.what ());
       error_state = 1;
     }
 }
 
 #endif
 
 DEFUN_DLD (__magick_write__, args, ,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __magick_write__ (@var{fname}, @var{fmt}, @var{img}, @var{map}, @var{options})\n\
 Write image with GraphicsMagick or ImageMagick.\n\
 \n\
 This is a private internal function not intended for direct use.  Instead\n\
 use @code{imwrite}.\n\
 \n\
 @seealso{imfinfo, imformats, imread, imwrite}\n\
 @end deftypefn")
@@ -1340,18 +1344,20 @@ use @code{imwrite}.\n\
           // the actual values. For those who don't, we only use the values
           // on the range [0 1] and save integer values.
           // But here, even for formats that would support floating point
           // values, GM seems unable to do that so we at least make them uint32.
           uint32NDArray clip_img;
           uint32NDArray clip_alpha;
           if (img.is_single_type ())
             {
-              clip_img   = img_float2uint<FloatNDArray> (img.float_array_value ());
-              clip_alpha = img_float2uint<FloatNDArray> (alpha.float_array_value ());
+              clip_img   = img_float2uint<FloatNDArray>
+                             (img.float_array_value ());
+              clip_alpha = img_float2uint<FloatNDArray>
+                             (alpha.float_array_value ());
             }
           else
             {
               clip_img   = img_float2uint<NDArray> (img.array_value ());
               clip_alpha = img_float2uint<NDArray> (alpha.array_value ());
             }
           encode_uint_image<uint32NDArray> (imvec, clip_img, clip_alpha);
         }
@@ -1389,17 +1395,17 @@ use @code{imwrite}.\n\
   // If writemode is set to append, read the image and append to it. Even
   // if set to append, make sure that something was read at all.
   const std::string writemode = options.getfield ("writemode").string_value ();
   if (writemode == "append" && file_stat (filename).exists ())
     {
       std::vector<Magick::Image> ini_imvec;
       read_file (filename, ini_imvec);
       if (error_state)
-          return retval;
+        return retval;
       if (ini_imvec.size () > 0)
         {
           ini_imvec.insert (ini_imvec.end (), imvec.begin (), imvec.end ());
           ini_imvec.swap (imvec);
         }
     }
 
   write_file (filename, ext, imvec);
@@ -1415,17 +1421,17 @@ use @code{imwrite}.\n\
 %!assert (1)
 */
 
 // Gets the minimum information from images such as its size and format. Much
 // faster than using imfinfo, which slows down a lot since. Note than without
 // this, we need to read the image once for imfinfo to set defaults (which is
 // done in Octave language), and then again for the actual reading.
 DEFUN_DLD (__magick_ping__, args, ,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __magick_ping__ (@var{fname}, @var{idx})\n\
 Ping image information with GraphicsMagick or ImageMagick.\n\
 \n\
 This is a private internal function not intended for direct use.\n\
 \n\
 @seealso{imfinfo}\n\
 @end deftypefn")
 {
@@ -1475,106 +1481,106 @@ This is a private internal function not 
 }
 
 #ifdef HAVE_MAGICK
 static octave_value
 magick_to_octave_value (const Magick::CompressionType& magick)
 {
   switch (magick)
     {
-      case Magick::NoCompression:
-        return octave_value ("none");
-      case Magick::BZipCompression:
-        return octave_value ("bzip");
-      case Magick::FaxCompression:
-        return octave_value ("fax3");
-      case Magick::Group4Compression:
-        return octave_value ("fax4");
-      case Magick::JPEGCompression:
-        return octave_value ("jpeg");
-      case Magick::LZWCompression:
-        return octave_value ("lzw");
-      case Magick::RLECompression:
-        // This is named "rle" for the HDF, but the same thing is named
-        // "ccitt" and "PackBits" for binary and non-binary images in TIFF.
-        return octave_value ("rle");
-      case Magick::ZipCompression:
-        return octave_value ("deflate");
+    case Magick::NoCompression:
+      return octave_value ("none");
+    case Magick::BZipCompression:
+      return octave_value ("bzip");
+    case Magick::FaxCompression:
+      return octave_value ("fax3");
+    case Magick::Group4Compression:
+      return octave_value ("fax4");
+    case Magick::JPEGCompression:
+      return octave_value ("jpeg");
+    case Magick::LZWCompression:
+      return octave_value ("lzw");
+    case Magick::RLECompression:
+      // This is named "rle" for the HDF, but the same thing is named
+      // "ccitt" and "PackBits" for binary and non-binary images in TIFF.
+      return octave_value ("rle");
+    case Magick::ZipCompression:
+      return octave_value ("deflate");
 
       // The following are present only in recent versions of GraphicsMagick.
       // At the moment the only use of this would be to have imfinfo report
       // the compression method. In the future, someone could implement
       // the Compression option for imwrite in which case a macro in
       // configure.ac will have to check for their presence of this.
       // See bug #39913
-//      case Magick::LZMACompression:
-//        return octave_value ("lzma");
-//      case Magick::JPEG2000Compression:
-//        return octave_value ("jpeg2000");
-//      case Magick::JBIG1Compression:
-//        return octave_value ("jbig1");
-//      case Magick::JBIG2Compression:
-//        return octave_value ("jbig2");
-      default:
-        return octave_value ("undefined");
+      //      case Magick::LZMACompression:
+      //        return octave_value ("lzma");
+      //      case Magick::JPEG2000Compression:
+      //        return octave_value ("jpeg2000");
+      //      case Magick::JBIG1Compression:
+      //        return octave_value ("jbig1");
+      //      case Magick::JBIG2Compression:
+      //        return octave_value ("jbig2");
+    default:
+      return octave_value ("undefined");
     }
 }
 
 static octave_value
 magick_to_octave_value (const Magick::EndianType& magick)
 {
   switch (magick)
     {
-      case Magick::LSBEndian:
-        return octave_value ("little-endian");
-      case Magick::MSBEndian:
-        return octave_value ("big-endian");
-      default:
-        return octave_value ("undefined");
+    case Magick::LSBEndian:
+      return octave_value ("little-endian");
+    case Magick::MSBEndian:
+      return octave_value ("big-endian");
+    default:
+      return octave_value ("undefined");
     }
 }
 
 static octave_value
 magick_to_octave_value (const Magick::OrientationType& magick)
 {
   switch (magick)
     {
       // Values come from the TIFF6 spec
-      case Magick::TopLeftOrientation:
-        return octave_value (1);
-      case Magick::TopRightOrientation:
-        return octave_value (2);
-      case Magick::BottomRightOrientation:
-        return octave_value (3);
-      case Magick::BottomLeftOrientation:
-        return octave_value (4);
-      case Magick::LeftTopOrientation:
-        return octave_value (5);
-      case Magick::RightTopOrientation:
-        return octave_value (6);
-      case Magick::RightBottomOrientation:
-        return octave_value (7);
-      case Magick::LeftBottomOrientation:
-        return octave_value (8);
-      default:
-        return octave_value (1);
+    case Magick::TopLeftOrientation:
+      return octave_value (1);
+    case Magick::TopRightOrientation:
+      return octave_value (2);
+    case Magick::BottomRightOrientation:
+      return octave_value (3);
+    case Magick::BottomLeftOrientation:
+      return octave_value (4);
+    case Magick::LeftTopOrientation:
+      return octave_value (5);
+    case Magick::RightTopOrientation:
+      return octave_value (6);
+    case Magick::RightBottomOrientation:
+      return octave_value (7);
+    case Magick::LeftBottomOrientation:
+      return octave_value (8);
+    default:
+      return octave_value (1);
     }
 }
 
 static octave_value
 magick_to_octave_value (const Magick::ResolutionType& magick)
 {
   switch (magick)
     {
-      case Magick::PixelsPerInchResolution:
-        return octave_value ("Inch");
-      case Magick::PixelsPerCentimeterResolution:
-        return octave_value ("Centimeter");
-      default:
-        return octave_value ("undefined");
+    case Magick::PixelsPerInchResolution:
+      return octave_value ("Inch");
+    case Magick::PixelsPerCentimeterResolution:
+      return octave_value ("Centimeter");
+    default:
+      return octave_value ("undefined");
     }
 }
 
 // Meant to be shared with both imfinfo and imwrite.
 static std::map<octave_idx_type, std::string>
 init_disposal_methods ()
 {
   //  GIF Specifications:
@@ -1666,17 +1672,17 @@ fill_exif_floats (octave_scalar_map& map
       map.setfield (key, octave_value (values));
     }
   return;
 }
 
 #endif
 
 DEFUN_DLD (__magick_finfo__, args, ,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __magick_finfo__ (@var{fname})\n\
 Read image information with GraphicsMagick or ImageMagick.\n\
 \n\
 This is a private internal function not intended for direct use.  Instead\n\
 use @code{imfinfo}.\n\
 \n\
 @seealso{imfinfo, imformats, imread, imwrite}\n\
 @end deftypefn")
@@ -1716,65 +1722,65 @@ use @code{imfinfo}.\n\
   // information for that image, and then insert it into an octave_map.
   // Because in the same file, different images may have values for
   // different fields, we can't create a field only if there's a value.
   // Bad things happen if we merge octave_scalar_maps with different
   // fields from the others (suppose for example a TIFF file with 4 images,
   // where only the third image has a colormap.
 
   static const char *fields[] =
-    {
-      // These are fields that must always appear for Matlab.
-      "Filename",
-      "FileModDate",
-      "FileSize",
-      "Format",
-      "FormatVersion",
-      "Width",
-      "Height",
-      "BitDepth",
-      "ColorType",
+  {
+    // These are fields that must always appear for Matlab.
+    "Filename",
+    "FileModDate",
+    "FileSize",
+    "Format",
+    "FormatVersion",
+    "Width",
+    "Height",
+    "BitDepth",
+    "ColorType",
 
-      // These are format specific or not existent in Matlab. The most
-      // annoying thing is that Matlab may have different names for the
-      // same thing in different formats.
-      "DelayTime",
-      "DisposalMethod",
-      "LoopCount",
-      "ByteOrder",
-      "Gamma",
-      "Chromaticities",
-      "Comment",
-      "Quality",
-      "Compression",        // same as CompressionType
-      "Colormap",           // same as ColorTable (in PNG)
-      "Orientation",
-      "ResolutionUnit",
-      "XResolution",
-      "YResolution",
-      "Software",           // sometimes is an Exif tag
-      "Make",               // actually an Exif tag
-      "Model",              // actually an Exif tag
-      "DateTime",           // actually an Exif tag
-      "ImageDescription",   // actually an Exif tag
-      "Artist",             // actually an Exif tag
-      "Copyright",          // actually an Exif tag
-      "DigitalCamera",
-      "GPSInfo",
-      // Notes for the future: GM allows to get many attributes, and even has
-      // attribute() to obtain arbitrary ones, that may exist in only some
-      // cases. The following is a list of some methods and into what possible
-      // Matlab compatible values they may be converted.
-      //
-      //  colorSpace()      -> PhotometricInterpretation
-      //  backgroundColor() -> BackgroundColor
-      //  interlaceType()   -> Interlaced, InterlaceType, and PlanarConfiguration
-      //  label()           -> Title
-      0
-    };
+    // These are format specific or not existent in Matlab. The most
+    // annoying thing is that Matlab may have different names for the
+    // same thing in different formats.
+    "DelayTime",
+    "DisposalMethod",
+    "LoopCount",
+    "ByteOrder",
+    "Gamma",
+    "Chromaticities",
+    "Comment",
+    "Quality",
+    "Compression",        // same as CompressionType
+    "Colormap",           // same as ColorTable (in PNG)
+    "Orientation",
+    "ResolutionUnit",
+    "XResolution",
+    "YResolution",
+    "Software",           // sometimes is an Exif tag
+    "Make",               // actually an Exif tag
+    "Model",              // actually an Exif tag
+    "DateTime",           // actually an Exif tag
+    "ImageDescription",   // actually an Exif tag
+    "Artist",             // actually an Exif tag
+    "Copyright",          // actually an Exif tag
+    "DigitalCamera",
+    "GPSInfo",
+    // Notes for the future: GM allows to get many attributes, and even has
+    // attribute() to obtain arbitrary ones, that may exist in only some
+    // cases. The following is a list of some methods and into what possible
+    // Matlab compatible values they may be converted.
+    //
+    //  colorSpace()      -> PhotometricInterpretation
+    //  backgroundColor() -> BackgroundColor
+    //  interlaceType()   -> Interlaced, InterlaceType, and PlanarConfiguration
+    //  label()           -> Title
+    0
+  };
 
   // The one we will return at the end
   octave_map info (dim_vector (nFrames, 1), string_vector (fields));
 
   // Some of the fields in the struct are about file information and will be
   // the same for all images in the file. So we create a template, fill in
   // those values, and make a copy of the template for each image.
   octave_scalar_map template_info = (string_vector (fields));
@@ -1802,56 +1808,57 @@ use @code{imfinfo}.\n\
   for (octave_idx_type frame = 0; frame < nFrames; frame++)
     {
       octave_scalar_map info_frame (template_info);
       const Magick::Image img = imvec[frame];
 
       info_frame.setfield ("Width",  octave_value (img.columns ()));
       info_frame.setfield ("Height", octave_value (img.rows ()));
       info_frame.setfield ("BitDepth",
-        octave_value (get_depth (const_cast<Magick::Image&> (img))));
+                           octave_value (get_depth (const_cast<Magick::Image&> (img))));
 
       // Stuff related to colormap, image class and type
       // Because GM is too smart for us... Read the comments in is_indexed()
       {
         std::string color_type;
         Matrix cmap;
         if (is_indexed (img))
           {
             color_type = "indexed";
-            cmap = read_maps (const_cast<Magick::Image&> (img))(0).matrix_value ();
+            cmap =
+              read_maps (const_cast<Magick::Image&> (img))(0).matrix_value ();
           }
         else
           {
             switch (img.type ())
               {
-                case Magick::BilevelType:
-                case Magick::GrayscaleType:
-                case Magick::GrayscaleMatteType:
-                  color_type = "grayscale";
-                  break;
+              case Magick::BilevelType:
+              case Magick::GrayscaleType:
+              case Magick::GrayscaleMatteType:
+                color_type = "grayscale";
+                break;
 
-                case Magick::TrueColorType:
-                case Magick::TrueColorMatteType:
-                  color_type = "truecolor";
-                  break;
+              case Magick::TrueColorType:
+              case Magick::TrueColorMatteType:
+                color_type = "truecolor";
+                break;
 
-                case Magick::PaletteType:
-                case Magick::PaletteMatteType:
-                  // we should never get here or is_indexed needs to be fixed
-                  color_type = "indexed";
-                  break;
+              case Magick::PaletteType:
+              case Magick::PaletteMatteType:
+                // we should never get here or is_indexed needs to be fixed
+                color_type = "indexed";
+                break;
 
-                case Magick::ColorSeparationType:
-                case Magick::ColorSeparationMatteType:
-                  color_type = "CMYK";
-                  break;
+              case Magick::ColorSeparationType:
+              case Magick::ColorSeparationMatteType:
+                color_type = "CMYK";
+                break;
 
-                default:
-                  color_type = "undefined";
+              default:
+                color_type = "undefined";
               }
           }
         info_frame.setfield ("ColorType", octave_value (color_type));
         info_frame.setfield ("Colormap",  octave_value (cmap));
       }
 
       {
         // Not all images have chroma values. In such cases, they'll
@@ -1863,74 +1870,77 @@ use @code{imfinfo}.\n\
         img.chromaRedPrimary    (&chroma_fvec[2], &chroma_fvec[3]);
         img.chromaGreenPrimary  (&chroma_fvec[4], &chroma_fvec[5]);
         img.chromaBluePrimary   (&chroma_fvec[6], &chroma_fvec[7]);
         if (chromaticities.nnz () == 0)
           chromaticities = RowVector (0);
         info_frame.setfield ("Chromaticities", octave_value (chromaticities));
       }
 
-      info_frame.setfield ("Gamma",         octave_value (img.gamma ()));
-      info_frame.setfield ("XResolution",   octave_value (img.xResolution ()));
-      info_frame.setfield ("YResolution",   octave_value (img.yResolution ()));
-      info_frame.setfield ("DelayTime",     octave_value (img.animationDelay ()));
-      info_frame.setfield ("LoopCount",     octave_value (img.animationIterations ()));
-      info_frame.setfield ("Quality",       octave_value (img.quality ()));
-      info_frame.setfield ("Comment",       octave_value (img.comment ()));
+      info_frame.setfield ("Gamma",       octave_value (img.gamma ()));
+      info_frame.setfield ("XResolution", octave_value (img.xResolution ()));
+      info_frame.setfield ("YResolution", octave_value (img.yResolution ()));
+      info_frame.setfield ("DelayTime",   octave_value (img.animationDelay ()));
+      info_frame.setfield ("LoopCount",
+                           octave_value (img.animationIterations ()));
+      info_frame.setfield ("Quality",     octave_value (img.quality ()));
+      info_frame.setfield ("Comment",     octave_value (img.comment ()));
 
       info_frame.setfield ("Compression",
-        magick_to_octave_value (img.compressType ()));
+                           magick_to_octave_value (img.compressType ()));
       info_frame.setfield ("Orientation",
-        magick_to_octave_value (img.orientation ()));
+                           magick_to_octave_value (img.orientation ()));
       info_frame.setfield ("ResolutionUnit",
-        magick_to_octave_value (img.resolutionUnits ()));
+                           magick_to_octave_value (img.resolutionUnits ()));
       info_frame.setfield ("ByteOrder",
-        magick_to_octave_value (img.endian ()));
+                           magick_to_octave_value (img.endian ()));
 
       // It is not possible to know if there's an Exif field so we just
       // check for the Exif Version value. If it does exists, then we
       // bother about looking for specific fields.
       {
         Magick::Image& cimg = const_cast<Magick::Image&> (img);
 
         // These will be in Exif tags but must appear as fields in the
         // base struct array, not as another struct in one of its fields.
         // This is likely because they belong to the Baseline TIFF specs
         // and may appear out of the Exif tag. So first we check if it
         // exists outside the Exif tag.
         // See Section 4.6.4, table 4, page 28 of Exif specs version 2.3
         // (CIPA DC- 008-Translation- 2010)
-        static const char *base_exif_str_fields[] = {
+        static const char *base_exif_str_fields[] =
+        {
           "DateTime",
           "ImageDescription",
           "Make",
           "Model",
           "Software",
           "Artist",
           "Copyright",
           0,
         };
         static const string_vector base_exif_str (base_exif_str_fields);
         static const octave_idx_type n_base_exif_str = base_exif_str.numel ();
         for (octave_idx_type field = 0; field < n_base_exif_str; field++)
           {
             info_frame.setfield (base_exif_str[field],
-              octave_value (cimg.attribute (base_exif_str[field])));
+                                 octave_value (cimg.attribute (base_exif_str[field])));
             fill_exif (info_frame, cimg, base_exif_str[field]);
           }
 
         octave_scalar_map camera;
         octave_scalar_map gps;
         if (! cimg.attribute ("EXIF:ExifVersion").empty ())
           {
             // See Section 4.6.5, table 7 and 8, over pages page 42 to 43
             // of Exif specs version 2.3 (CIPA DC- 008-Translation- 2010)
 
             // Listed on the Exif specs as being of type ASCII.
-            static const char *exif_str_fields[] = {
+            static const char *exif_str_fields[] =
+            {
               "RelatedSoundFile",
               "DateTimeOriginal",
               "DateTimeDigitized",
               "SubSecTime",
               "DateTimeOriginal",
               "SubSecTimeOriginal",
               "SubSecTimeDigitized",
               "ImageUniqueID",
@@ -1947,17 +1957,18 @@ use @code{imfinfo}.\n\
               0
             };
             static const string_vector exif_str (exif_str_fields);
             static const octave_idx_type n_exif_str = exif_str.numel ();
             for (octave_idx_type field = 0; field < n_exif_str; field++)
               fill_exif (camera, cimg, exif_str[field]);
 
             // Listed on the Exif specs as being of type SHORT or LONG.
-            static const char *exif_int_fields[] = {
+            static const char *exif_int_fields[] =
+            {
               "ColorSpace",
               "ExifImageWidth",  // PixelXDimension (CPixelXDimension in Matlab)
               "ExifImageHeight", // PixelYDimension (CPixelYDimension in Matlab)
               "PhotographicSensitivity",
               "StandardOutputSensitivity",
               "RecommendedExposureIndex",
               "ISOSpeed",
               "ISOSpeedLatitudeyyy",
@@ -1990,17 +2001,18 @@ use @code{imfinfo}.\n\
               0
             };
             static const string_vector exif_int (exif_int_fields);
             static const octave_idx_type n_exif_int = exif_int.numel ();
             for (octave_idx_type field = 0; field < n_exif_int; field++)
               fill_exif_ints (camera, cimg, exif_int[field]);
 
             // Listed as RATIONAL or SRATIONAL
-            static const char *exif_float_fields[] = {
+            static const char *exif_float_fields[] =
+            {
               "Gamma",
               "CompressedBitsPerPixel",
               "ExposureTime",
               "FNumber",
               "ShutterSpeedValue",  // SRATIONAL
               "ApertureValue",
               "BrightnessValue",    // SRATIONAL
               "ExposureBiasValue",  // SRATIONAL
@@ -2025,17 +2037,18 @@ use @code{imfinfo}.\n\
             // GPS field. This is not the same as ExifVersion but seems
             // to be how we have to check for it.
             if (cimg.attribute ("EXIF:GPSInfo") != "unknown")
               {
                 // The story here is the same as with Exif.
                 // See Section 4.6.6, table 15 on page 68 of Exif specs
                 // version 2.3 (CIPA DC- 008-Translation- 2010)
 
-                static const char *gps_str_fields[] = {
+                static const char *gps_str_fields[] =
+                {
                   "GPSLatitudeRef",
                   "GPSLongitudeRef",
                   "GPSAltitudeRef",
                   "GPSSatellites",
                   "GPSStatus",
                   "GPSMeasureMode",
                   "GPSSpeedRef",
                   "GPSTrackRef",
@@ -2048,26 +2061,28 @@ use @code{imfinfo}.\n\
                   "GPSDateStamp",
                   0
                 };
                 static const string_vector gps_str (gps_str_fields);
                 static const octave_idx_type n_gps_str = gps_str.numel ();
                 for (octave_idx_type field = 0; field < n_gps_str; field++)
                   fill_exif (gps, cimg, gps_str[field]);
 
-                static const char *gps_int_fields[] = {
+                static const char *gps_int_fields[] =
+                {
                   "GPSDifferential",
                   0
                 };
                 static const string_vector gps_int (gps_int_fields);
                 static const octave_idx_type n_gps_int = gps_int.numel ();
                 for (octave_idx_type field = 0; field < n_gps_int; field++)
                   fill_exif_ints (gps, cimg, gps_int[field]);
 
-                static const char *gps_float_fields[] = {
+                static const char *gps_float_fields[] =
+                {
                   "GPSAltitude",
                   "GPSDOP",
                   "GPSSpeed",
                   "GPSTrack",
                   "GPSImgDirection",
                   "GPSDestBearing",
                   "GPSDestDistance",
                   "GPSHPositioningError",
@@ -2112,17 +2127,17 @@ use @code{imfinfo}.\n\
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
 
 DEFUN_DLD (__magick_formats__, args, ,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __magick_imformats__ (@var{formats})\n\
 Fill formats info with GraphicsMagick CoderInfo.\n\
 \n\
 @seealso{imfinfo, imformats, imread, imwrite}\n\
 @end deftypefn")
 {
   octave_value retval;
 #ifndef HAVE_MAGICK
diff --git a/libinterp/dldfcn/__voronoi__.cc b/libinterp/dldfcn/__voronoi__.cc
--- a/libinterp/dldfcn/__voronoi__.cc
+++ b/libinterp/dldfcn/__voronoi__.cc
@@ -55,17 +55,17 @@ char qh_version[] = "__voronoi__.oct 200
 
 static void
 close_fcn (FILE *f)
 {
   gnulib::fclose (f);
 }
 
 DEFUN_DLD (__voronoi__, args, ,
-        "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{C}, @var{F} =} __voronoi__ (@var{caller}, @var{pts})\n\
 @deftypefnx {Loadable Function} {@var{C}, @var{F} =} __voronoi__ (@var{caller}, @var{pts}, @var{options})\n\
 @deftypefnx {Loadable Function} {@var{C}, @var{F}, @var{Inf_Pts} =} __voronoi__ (@dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
@@ -145,17 +145,17 @@ Undocumented internal function.\n\
   std::string cmd = "qhull v" + options;
 
   OCTAVE_LOCAL_BUFFER (char, cmd_str, cmd.length () + 1);
 
   strcpy (cmd_str, cmd.c_str ());
 
   int exitcode = qh_new_qhull (dim, num_points, points.fortran_vec (),
                                ismalloc, cmd_str, outfile, errfile);
-  if (! exitcode) 
+  if (! exitcode)
     {
       // Calling findgood_all provides the number of Voronoi vertices
       // (sets qh num_good).
 
       qh_findgood_all (qh facet_list);
 
       octave_idx_type num_voronoi_regions
         = qh num_vertices - qh_setsize (qh del_vertices);
@@ -213,17 +213,17 @@ Undocumented internal function.\n\
 
           k++;
         }
 
       // If Qhull finds fewer regions than points, we will pad the end
       // of the at_inf and C arrays so that they always contain at least
       // as many elements as the given points array.
 
-      // FIXME -- is it possible (or does it make sense) for
+      // FIXME: is it possible (or does it make sense) for
       // num_voronoi_regions to ever be larger than num_points?
 
       octave_idx_type nr = (num_points > num_voronoi_regions
                             ? num_points : num_voronoi_regions);
 
       boolMatrix at_inf (nr, 1, false);
 
       // The list of Voronoi vertices.  The first element is always
diff --git a/libinterp/dldfcn/amd.cc b/libinterp/dldfcn/amd.cc
--- a/libinterp/dldfcn/amd.cc
+++ b/libinterp/dldfcn/amd.cc
@@ -46,17 +46,17 @@ along with Octave; see the file COPYING.
 
 #ifdef USE_64_BIT_IDX_T
 #define AMD_NAME(name) amd_l ## name
 #else
 #define AMD_NAME(name) amd ## name
 #endif
 
 DEFUN_DLD (amd, args, nargout,
-    "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{p} =} amd (@var{S})\n\
 @deftypefnx {Loadable Function} {@var{p} =} amd (@var{S}, @var{opts})\n\
 \n\
 Return the approximate minimum degree permutation of a matrix.  This\n\
 permutation such that the Cholesky@tie{}factorization of @code{@var{S}\n\
 (@var{p}, @var{p})} tends to be sparser than the Cholesky@tie{}factorization\n\
 of @var{S} itself.  @code{amd} is typically faster than @code{symamd} but\n\
 serves a similar purpose.\n\
@@ -157,18 +157,18 @@ The author of the code itself is Timothy
             }
 
           if (!error_state)
             {
               OCTAVE_LOCAL_BUFFER (octave_idx_type, P, n_col);
               Matrix xinfo (AMD_INFO, 1);
               double *Info = xinfo.fortran_vec ();
 
-              // FIXME -- how can we manage the memory allocation of
-              // amd in a cleaner manner?
+              // FIXME: how can we manage the memory allocation of amd
+              //        in a cleaner manner?
               amd_malloc = malloc;
               amd_free = free;
               amd_calloc = calloc;
               amd_realloc = realloc;
               amd_printf = printf;
 
               octave_idx_type result = AMD_NAME (_order) (n_col, cidx, ridx, P,
                                                           Control, Info);
diff --git a/libinterp/dldfcn/ccolamd.cc b/libinterp/dldfcn/ccolamd.cc
--- a/libinterp/dldfcn/ccolamd.cc
+++ b/libinterp/dldfcn/ccolamd.cc
@@ -47,17 +47,17 @@ along with Octave; see the file COPYING.
 #define CCOLAMD_NAME(name) ccolamd_l ## name
 #define CSYMAMD_NAME(name) csymamd_l ## name
 #else
 #define CCOLAMD_NAME(name) ccolamd ## name
 #define CSYMAMD_NAME(name) csymamd ## name
 #endif
 
 DEFUN_DLD (ccolamd, args, nargout,
-    "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{p} =} ccolamd (@var{S})\n\
 @deftypefnx {Loadable Function} {@var{p} =} ccolamd (@var{S}, @var{knobs})\n\
 @deftypefnx {Loadable Function} {@var{p} =} ccolamd (@var{S}, @var{knobs}, @var{cmember})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} ccolamd (@dots{})\n\
 \n\
 Constrained column approximate minimum degree permutation.\n\
 @code{@var{p} = ccolamd (@var{S})} returns the column approximate minimum\n\
 degree permutation vector for the sparse matrix @var{S}.  For a non-symmetric\n\
@@ -183,17 +183,18 @@ ccolamd, csymamd, amd, colamd, symamd, a
               if (knobs[CCOLAMD_LU] != 0)
                 octave_stdout << "lu (A)\n";
               else
                 octave_stdout << "chol (A'*A)\n";
 
               if (knobs[CCOLAMD_DENSE_ROW] >= 0)
                 octave_stdout << "knobs(2): " << User_knobs(1)
                               << ", rows with > max (16,"
-                              << knobs[CCOLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
+                              << knobs[CCOLAMD_DENSE_ROW]
+                              << "*sqrt (size(A,2)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(2): " << User_knobs(1)
                               << ", no dense rows removed\n";
 
               if (knobs[CCOLAMD_DENSE_COL] >= 0)
                 octave_stdout << "knobs(3): " << User_knobs(2)
                               << ", cols with > max (16,"
@@ -276,17 +277,18 @@ ccolamd, csymamd, amd, colamd, symamd, a
           for (octave_idx_type i = 0; i < cslen; i++)
             // convert cmember from 1-based to 0-based
             cmember[i] = static_cast<octave_idx_type>(in_cmember(i) - 1);
 
           if (cslen != n_col)
             error ("ccolamd: CMEMBER must be of length equal to #cols of A");
           else
             // Order the columns (destroys A)
-            if (! CCOLAMD_NAME () (n_row, n_col, Alen, A, p, knobs, stats, cmember))
+            if (! CCOLAMD_NAME () (n_row, n_col, Alen, A, p,
+                                   knobs, stats, cmember))
               {
                 CCOLAMD_NAME (_report) (stats) ;
                 error ("ccolamd: internal error!");
                 return retval;
               }
         }
       else
         {
@@ -331,17 +333,17 @@ ccolamd, csymamd, amd, colamd, symamd, a
   error ("ccolamd: not available in this version of Octave");
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (csymamd, args, nargout,
-    "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{p} =} csymamd (@var{S})\n\
 @deftypefnx {Loadable Function} {@var{p} =} csymamd (@var{S}, @var{knobs})\n\
 @deftypefnx {Loadable Function} {@var{p} =} csymamd (@var{S}, @var{knobs}, @var{cmember})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} csymamd (@dots{})\n\
 \n\
 For a symmetric positive definite matrix @var{S}, returns the permutation\n\
 vector @var{p} such that @code{@var{S}(@var{p},@var{p})} tends to have a\n\
 sparser Cholesky@tie{}factor than @var{S}.  Sometimes @code{csymamd} works\n\
@@ -423,23 +425,25 @@ ccolamd, csymamd, amd, colamd, symamd, a
           if (nel_User_knobs > 0)
             knobs[CCOLAMD_AGGRESSIVE] = User_knobs(1);
           if (nel_User_knobs > 1)
             spumoni = static_cast<int> (User_knobs(2));
 
           // print knob settings if spumoni is set
           if (spumoni)
             {
-              octave_stdout << "\ncsymamd version " << CCOLAMD_MAIN_VERSION << "."
-                            <<  CCOLAMD_SUB_VERSION << ", " << CCOLAMD_DATE << "\n";
+              octave_stdout << "\ncsymamd version " << CCOLAMD_MAIN_VERSION
+                            << "." << CCOLAMD_SUB_VERSION
+                            << ", " << CCOLAMD_DATE << "\n";
 
               if (knobs[CCOLAMD_DENSE_ROW] >= 0)
                 octave_stdout << "knobs(1): " << User_knobs(0)
                               << ", rows/cols with > max (16,"
-                              << knobs[CCOLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
+                              << knobs[CCOLAMD_DENSE_ROW]
+                              << "*sqrt (size(A,2)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(1): " << User_knobs(0)
                               << ", no dense rows/cols removed\n";
 
               if (knobs[CCOLAMD_AGGRESSIVE] != 0)
                 octave_stdout << "knobs(2): " << User_knobs(1)
                               << ", aggressive absorption: yes";
@@ -506,24 +510,23 @@ ccolamd, csymamd, amd, colamd, symamd, a
           octave_idx_type cslen = in_cmember.length ();
           OCTAVE_LOCAL_BUFFER (octave_idx_type, cmember, cslen);
           for (octave_idx_type i = 0; i < cslen; i++)
             // convert cmember from 1-based to 0-based
             cmember[i] = static_cast<octave_idx_type>(in_cmember(i) - 1);
 
           if (cslen != n_col)
             error ("csymamd: CMEMBER must be of length equal to #cols of A");
-          else
-            if (!CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats,
-                                  &calloc, &free, cmember, -1))
-              {
-                CSYMAMD_NAME (_report) (stats) ;
-                error ("csymamd: internal error!") ;
-                return retval;
-              }
+          else if (!CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats,
+                                     &calloc, &free, cmember, -1))
+            {
+              CSYMAMD_NAME (_report) (stats) ;
+              error ("csymamd: internal error!") ;
+              return retval;
+            }
         }
       else
         {
           if (!CSYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats,
                                 &calloc, &free, 0, -1))
             {
               CSYMAMD_NAME (_report) (stats) ;
               error ("csymamd: internal error!") ;
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -56,17 +56,17 @@ template <class CHOLT>
 static octave_value
 get_chol_l (const CHOLT& fact)
 {
   return octave_value (fact.chol_matrix ().transpose (),
                        MatrixType (MatrixType::Lower));
 }
 
 DEFUN_DLD (chol, args, nargout,
-"-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{R} =} chol (@var{A})\n\
 @deftypefnx {Loadable Function} {[@var{R}, @var{p}] =} chol (@var{A})\n\
 @deftypefnx {Loadable Function} {[@var{R}, @var{p}, @var{Q}] =} chol (@var{S})\n\
 @deftypefnx {Loadable Function} {[@var{R}, @var{p}, @var{Q}] =} chol (@var{S}, \"vector\")\n\
 @deftypefnx {Loadable Function} {[@var{L}, @dots{}] =} chol (@dots{}, \"lower\")\n\
 @deftypefnx {Loadable Function} {[@var{L}, @dots{}] =} chol (@dots{}, \"upper\")\n\
 @cindex Cholesky factorization\n\
 Compute the Cholesky@tie{}factor, @var{R}, of the symmetric positive definite\n\
@@ -156,19 +156,19 @@ sparse matrices.\n\
       std::string tmp = args(n++).string_value ();
 
       if (! error_state )
         {
           if (tmp.compare ("vector") == 0)
             vecout = true;
           else if (tmp.compare ("lower") == 0)
             // FIXME currently the option "lower" is handled by transposing the
-            //  matrix, factorizing it with the lapack function DPOTRF ('U', ...)
-            //  and finally transposing the factor. It would be more efficient to use
-            //  DPOTRF ('L', ...) in this case.
+            //  matrix, factorizing it with the lapack function
+            //  DPOTRF ('U', ...) and finally transposing the factor.  It would
+            //  be more efficient to use DPOTRF ('L', ...) in this case.
             LLt = true;
           else if (tmp.compare ("upper") == 0)
             LLt = false;
           else
             error ("chol: unexpected second or third input");
         }
       else
         error ("chol: expecting trailing string arguments");
@@ -314,20 +314,20 @@ sparse matrices.\n\
         {
           if (arg.is_real_type ())
             {
               Matrix m = arg.matrix_value ();
 
               if (! error_state)
                 {
                   octave_idx_type info;
-                  
+
                   CHOL fact;
                   if (LLt)
-                     fact = CHOL (m.transpose (), info);
+                    fact = CHOL (m.transpose (), info);
                   else
                     fact = CHOL (m, info);
 
                   if (nargout == 2 || info == 0)
                     {
                       retval(1) = info;
                       if (LLt)
                         retval(0) = get_chol_l (fact);
@@ -340,17 +340,17 @@ sparse matrices.\n\
             }
           else if (arg.is_complex_type ())
             {
               ComplexMatrix m = arg.complex_matrix_value ();
 
               if (! error_state)
                 {
                   octave_idx_type info;
-                  
+
                   ComplexCHOL fact;
                   if (LLt)
                     fact = ComplexCHOL (m.transpose (), info);
                   else
                     fact = ComplexCHOL (m, info);
 
                   if (nargout == 2 || info == 0)
                     {
@@ -378,17 +378,17 @@ sparse matrices.\n\
 
 %!error chol ()
 %!error <matrix must be positive definite> chol ([1, 2; 3, 4])
 %!error <requires square matrix> chol ([1, 2; 3, 4; 5, 6])
 %!error <unexpected second or third input> chol (1, 2)
 */
 
 DEFUN_DLD (cholinv, args, ,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} cholinv (@var{A})\n\
 Use the Cholesky@tie{}factorization to compute the inverse of the\n\
 symmetric positive definite matrix @var{A}.\n\
 @seealso{chol, chol2inv, inv}\n\
 @end deftypefn")
 {
   octave_value retval;
 
@@ -525,17 +525,17 @@ symmetric positive definite matrix @var{
 %! Ainv2 = inv (sparse (A));
 %! assert (norm (Ainv-Ainv2), 0, 1e-10);
 %!testif HAVE_CHOLMOD
 %! Ainv3 = cholinv (sparse (A));
 %! assert (norm (Ainv-Ainv3), 0, 1e-10);
 */
 
 DEFUN_DLD (chol2inv, args, ,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} chol2inv (@var{U})\n\
 Invert a symmetric, positive definite square matrix from its Cholesky\n\
 decomposition, @var{U}.  Note that @var{U} should be an upper-triangular\n\
 matrix with positive diagonal elements.  @code{chol2inv (@var{U})}\n\
 provides @code{inv (@var{U}'*@var{U})} but it is much faster than\n\
 using @code{inv}.\n\
 @seealso{chol, cholinv, inv}\n\
 @end deftypefn")
@@ -617,17 +617,17 @@ using @code{inv}.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (cholupdate, args, nargout,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{R1}, @var{info}] =} cholupdate (@var{R}, @var{u}, @var{op})\n\
 Update or downdate a Cholesky@tie{}factorization.  Given an upper triangular\n\
 matrix @var{R} and a column vector @var{u}, attempt to determine another\n\
 upper triangular matrix @var{R1} such that\n\
 \n\
 @itemize @bullet\n\
 @item\n\
 @var{R1}'*@var{R1} = @var{R}'*@var{R} + @var{u}*@var{u}'\n\
@@ -695,17 +695,18 @@ If @var{info} is not present, an error m
                       fact.update (u);
 
                     retval(0) = get_chol_r (fact);
                   }
                 else
                   {
                     // complex case
                     FloatComplexMatrix R = argr.float_complex_matrix_value ();
-                    FloatComplexColumnVector u = argu.float_complex_column_vector_value ();
+                    FloatComplexColumnVector u =
+                      argu.float_complex_column_vector_value ();
 
                     FloatComplexCHOL fact;
                     fact.set (R);
 
                     if (down)
                       err = fact.downdate (u);
                     else
                       fact.update (u);
@@ -825,17 +826,17 @@ If @var{info} is not present, an error m
 %! assert (norm (R1'*R1 - R'*R - single (uc*uc'), Inf) < 1e1*eps ("single"));
 %!
 %! R1 = cholupdate (R1, single (uc), "-");
 %! assert (norm (triu (R1)-R1, Inf), single (0));
 %! assert (norm (R1 - R, Inf) < 2e1*eps ("single"));
 */
 
 DEFUN_DLD (cholinsert, args, nargout,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{R1} =} cholinsert (@var{R}, @var{j}, @var{u})\n\
 @deftypefnx {Loadable Function} {[@var{R1}, @var{info}] =} cholinsert (@var{R}, @var{j}, @var{u})\n\
 Given a Cholesky@tie{}factorization of a real symmetric or complex Hermitian\n\
 positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper\n\
 triangular, return the Cholesky@tie{}factorization of\n\
 @var{A1}, where @w{A1(p,p) = A}, @w{A1(:,j) = A1(j,:)' = u} and\n\
 @w{p = [1:j-1,j+1:n+1]}.  @w{u(j)} should be positive.\n\
 On return, @var{info} is set to\n\
@@ -890,17 +891,18 @@ If @var{info} is not present, an error m
                       err = fact.insert_sym (u, j-1);
 
                       retval(0) = get_chol_r (fact);
                     }
                   else
                     {
                       // complex case
                       FloatComplexMatrix R = argr.float_complex_matrix_value ();
-                      FloatComplexColumnVector u = argu.float_complex_column_vector_value ();
+                      FloatComplexColumnVector u =
+                        argu.float_complex_column_vector_value ();
 
                       FloatComplexCHOL fact;
                       fact.set (R);
                       err = fact.insert_sym (u, j-1);
 
                       retval(0) = get_chol_r (fact);
                     }
                 }
@@ -917,17 +919,18 @@ If @var{info} is not present, an error m
                       err = fact.insert_sym (u, j-1);
 
                       retval(0) = get_chol_r (fact);
                     }
                   else
                     {
                       // complex case
                       ComplexMatrix R = argr.complex_matrix_value ();
-                      ComplexColumnVector u = argu.complex_column_vector_value ();
+                      ComplexColumnVector u =
+                        argu.complex_column_vector_value ();
 
                       ComplexCHOL fact;
                       fact.set (R);
                       err = fact.insert_sym (u, j-1);
 
                       retval(0) = get_chol_r (fact);
                     }
                 }
@@ -1066,17 +1069,17 @@ If @var{info} is not present, an error m
 %!       4,  3,  6, 16];
 %!
 %! b = [0,  1,  2,  3;
 %!     -1,  0,  1,  2;
 %!     -2, -1,  0,  1;
 %!     -3, -2, -1,  0];
 %!
 %! ca = a + i*b;
-%!   
+%!
 %! cca  = chol (ca);
 %!
 %! ccal  = chol (ca, "lower");
 %! ccal2 = chol (tril (ca), "lower");
 %!
 %! ccau  = chol (ca, "upper");
 %! ccau2 = chol (triu (ca), "upper");
 %!
@@ -1086,17 +1089,17 @@ If @var{info} is not present, an error m
 %!
 %! assert (cca, ccal',  16*eps);
 %! assert (cca, ccau,   16*eps);
 %! assert (cca, ccal2', 16*eps);
 %! assert (cca, ccau2,  16*eps);
 */
 
 DEFUN_DLD (choldelete, args, ,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{R1} =} choldelete (@var{R}, @var{j})\n\
 Given a Cholesky@tie{}factorization of a real symmetric or complex Hermitian\n\
 positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper\n\
 triangular, return the Cholesky@tie{}factorization of @w{A(p,p)}, where\n\
 @w{p = [1:j-1,j+1:n+1]}.\n\
 @seealso{chol, cholupdate, cholinsert, cholshift}\n\
 @end deftypefn")
 {
@@ -1219,17 +1222,17 @@ triangular, return the Cholesky@tie{}fac
 %! j = 3;  p = [1:j-1,j+1:4];
 %! R1 = choldelete (R,j);
 %!
 %! assert (norm (triu (R1)-R1, Inf), single (0));
 %! assert (norm (R1'*R1 - single (Ac(p,p)), Inf) < 1e1*eps ("single"));
 */
 
 DEFUN_DLD (cholshift, args, ,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{R1} =} cholshift (@var{R}, @var{i}, @var{j})\n\
 Given a Cholesky@tie{}factorization of a real symmetric or complex Hermitian\n\
 positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper\n\
 triangular, return the Cholesky@tie{}factorization of\n\
 @w{@var{A}(p,p)}, where @w{p} is the permutation @*\n\
 @code{p = [1:i-1, shift(i:j, 1), j+1:n]} if @w{@var{i} < @var{j}} @*\n\
  or @*\n\
 @code{p = [1:j-1, shift(j:i,-1), i+1:n]} if @w{@var{j} < @var{i}}.  @*\n\
@@ -1246,17 +1249,18 @@ triangular, return the Cholesky@tie{}fac
       print_usage ();
       return retval;
     }
 
   octave_value argr = args(0);
   octave_value argi = args(1);
   octave_value argj = args(2);
 
-  if (argr.is_numeric_type () && argi.is_real_scalar () && argj.is_real_scalar ())
+  if (argr.is_numeric_type ()
+      && argi.is_real_scalar () && argj.is_real_scalar ())
     {
       octave_idx_type n = argr.rows ();
       octave_idx_type i = argi.scalar_value ();
       octave_idx_type j = argj.scalar_value ();
 
       if (argr.columns () == n)
         {
           if (j > 0 && j <= n+1 && i > 0 && i <= n+1)
@@ -1354,17 +1358,17 @@ triangular, return the Cholesky@tie{}fac
 %! j = 1;  i = 3;  p = [1:j-1, shift(j:i,+1), i+1:4];
 %! R1 = cholshift (R, i, j);
 %!
 %! assert (norm (triu (R1)-R1, Inf), 0);
 %! assert (norm (R1'*R1 - Ac(p,p), Inf) < 1e1*eps);
 
 %!test
 %! R = chol (single (A));
-%! 
+%!
 %! i = 1;  j = 3;  p = [1:i-1, shift(i:j,-1), j+1:4];
 %! R1 = cholshift (R, i, j);
 %!
 %! assert (norm (triu (R1)-R1, Inf), 0);
 %! assert (norm (R1'*R1 - single (A(p,p)), Inf) < 1e1*eps ("single"));
 %!
 %! j = 1;  i = 3;  p = [1:j-1, shift(j:i,+1), i+1:4];
 %! R1 = cholshift (R, i, j);
diff --git a/libinterp/dldfcn/colamd.cc b/libinterp/dldfcn/colamd.cc
--- a/libinterp/dldfcn/colamd.cc
+++ b/libinterp/dldfcn/colamd.cc
@@ -65,17 +65,18 @@ symetree (const octave_idx_type *ridx, c
     for (octave_idx_type k = 0 ; k < n ; k++)
       Pinv[P[k]] = k ;
 
   for (octave_idx_type k = 0 ; k < n ; k++)
     {
       // L(k,:) pattern: all nodes reachable in etree from nz in A(0:k-1,k)
       Parent[k] = n ;                // parent of k is not yet known
       Flag[k] = k ;                  // mark node k as visited
-      octave_idx_type kk = (P) ? (P[k]) : (k) ;  // kth original, or permuted, column
+      octave_idx_type kk = (P) ? P[k]  // kth original, or permuted, column
+                               : (k) ;
       octave_idx_type p2 = cidx[kk+1] ;
       for (octave_idx_type p = cidx[kk] ; p < p2 ; p++)
         {
           // A (i,k) is nonzero (original or permuted A)
           octave_idx_type i = (Pinv) ? (Pinv[ridx[p]]) : (ridx[p]) ;
           if (i < k)
             {
               // follow path from i to root of etree, stop at flagged node
@@ -204,17 +205,17 @@ coletree (const octave_idx_type *ridx, c
               cset = link (cset, rset, pp);
               root[cset] = col;
             }
         }
     }
 }
 
 DEFUN_DLD (colamd, args, nargout,
-    "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{p} =} colamd (@var{S})\n\
 @deftypefnx {Loadable Function} {@var{p} =} colamd (@var{S}, @var{knobs})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} colamd (@var{S})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} colamd (@var{S}, @var{knobs})\n\
 \n\
 Column approximate minimum degree permutation.\n\
 @code{@var{p} = colamd (@var{S})} returns the column approximate minimum\n\
 degree permutation vector for the sparse matrix @var{S}.  For a\n\
@@ -304,18 +305,19 @@ Ng, Oak Ridge National Laboratory.  (see
             knobs[COLAMD_DENSE_COL] = User_knobs(1) ;
           if (nel_User_knobs > 2)
             spumoni = static_cast<int> (User_knobs(2));
 
           // print knob settings if spumoni is set
           if (spumoni)
             {
 
-              octave_stdout << "\ncolamd version " << COLAMD_MAIN_VERSION << "."
-                            <<  COLAMD_SUB_VERSION << ", " << COLAMD_DATE << ":\n";
+              octave_stdout << "\ncolamd version " << COLAMD_MAIN_VERSION
+                            << "." <<  COLAMD_SUB_VERSION
+                            << ", " << COLAMD_DATE << ":\n";
 
               if (knobs[COLAMD_DENSE_ROW] >= 0)
                 octave_stdout << "knobs(1): " << User_knobs (0)
                               << ", rows with > max (16,"
                               << knobs[COLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(1): " << User_knobs (0)
@@ -444,17 +446,17 @@ Ng, Oak Ridge National Laboratory.  (see
   error ("colamd: not available in this version of Octave");
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (symamd, args, nargout,
-    "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{p} =} symamd (@var{S})\n\
 @deftypefnx {Loadable Function} {@var{p} =} symamd (@var{S}, @var{knobs})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} symamd (@var{S})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} symamd (@var{S}, @var{knobs})\n\
 \n\
 For a symmetric positive definite matrix @var{S}, returns the permutation\n\
 vector p such that @code{@var{S}(@var{p}, @var{p})} tends to have a\n\
 sparser Cholesky@tie{}factor than @var{S}.  Sometimes @code{symamd} works\n\
@@ -585,17 +587,18 @@ Ng, Oak Ridge National Laboratory.  (see
         {
           error ("symamd: matrix S must be square");
           return retval;
         }
 
       // Allocate workspace for symamd
       OCTAVE_LOCAL_BUFFER (octave_idx_type, perm, n_col+1);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, stats, COLAMD_STATS);
-      if (!SYMAMD_NAME () (n_col, ridx, cidx, perm, knobs, stats, &calloc, &free))
+      if (!SYMAMD_NAME () (n_col, ridx, cidx, perm,
+                           knobs, stats, &calloc, &free))
         {
           SYMAMD_NAME (_report) (stats) ;
           error ("symamd: internal error!") ;
           return retval;
         }
 
       // column elimination tree post-ordering
       OCTAVE_LOCAL_BUFFER (octave_idx_type, etree, n_col + 1);
@@ -637,17 +640,17 @@ Ng, Oak Ridge National Laboratory.  (see
   error ("symamd: not available in this version of Octave");
 
 #endif
 
   return retval;
 }
 
 DEFUN_DLD (etree, args, nargout,
-    "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{p} =} etree (@var{S})\n\
 @deftypefnx {Loadable Function} {@var{p} =} etree (@var{S}, @var{typ})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{q}] =} etree (@var{S}, @var{typ})\n\
 \n\
 Return the elimination tree for the matrix @var{S}.  By default @var{S}\n\
 is assumed to be symmetric and the symmetric elimination tree is\n\
 returned.  The argument @var{typ} controls whether a symmetric or\n\
 column elimination tree is returned.  Valid values of @var{typ} are\n\
diff --git a/libinterp/dldfcn/convhulln.cc b/libinterp/dldfcn/convhulln.cc
--- a/libinterp/dldfcn/convhulln.cc
+++ b/libinterp/dldfcn/convhulln.cc
@@ -51,17 +51,17 @@ char qh_version[] = "convhulln.oct 2007-
 
 static void
 close_fcn (FILE *f)
 {
   gnulib::fclose (f);
 }
 
 DEFUN_DLD (convhulln, args, nargout,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{h} =} convhulln (@var{pts})\n\
 @deftypefnx {Loadable Function} {@var{h} =} convhulln (@var{pts}, @var{options})\n\
 @deftypefnx {Loadable Function} {[@var{h}, @var{v}] =} convhulln (@dots{})\n\
 Compute the convex hull of the set of points @var{pts} which is a matrix\n\
 of size [n, dim] containing n points in a space of dimension dim.\n\
 The hull @var{h} is an index vector into the set of points and specifies\n\
 which points form the enclosing hull.\n\
 \n\
@@ -126,17 +126,17 @@ convex hull is calculated.\n\n\
           for (octave_idx_type i = 0; i < tmp.numel (); i++)
             options += " " + tmp(i);
         }
       else
         {
           error ("convhulln: OPTIONS must be a string, cell array of strings, or empty");
           return retval;
         }
-     }
+    }
 
   boolT ismalloc = false;
 
   unwind_protect frame;
 
   // Replace the outfile pointer with stdout for debugging information.
 #if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM)
   FILE *outfile = gnulib::fopen ("NUL", "w");
@@ -285,30 +285,30 @@ convex hull is calculated.\n\n\
 
   return retval;
 }
 
 /*
 %!testif HAVE_QHULL
 %! cube = [0 0 0;1 0 0;1 1 0;0 1 0;0 0 1;1 0 1;1 1 1;0 1 1];
 %! [h, v] = convhulln (cube, "Qt");
-%! assert (size (h), [12 3]); 
+%! assert (size (h), [12 3]);
 %! h = sortrows (sort (h, 2), [1:3]);
 %! assert (h, [1 2 4; 1 2 6; 1 4 8; 1 5 6; 1 5 8; 2 3 4; 2 3 7; 2 6 7; 3 4 7; 4 7 8; 5 6 7; 5 7 8]);
 %! assert (v, 1, 10*eps);
 %! [h2, v2] = convhulln (cube); % Test defaut option = "Qt"
 %! assert (size (h2), size (h));
 %! h2 = sortrows (sort (h2, 2), [1:3]);
 %! assert (h2, h);
 %! assert (v2, v, 10*eps);
 
 %!testif HAVE_QHULL
 %! cube = [0 0 0;1 0 0;1 1 0;0 1 0;0 0 1;1 0 1;1 1 1;0 1 1];
 %! [h, v] = convhulln (cube, "QJ");
-%! assert (size (h), [12 3]); 
+%! assert (size (h), [12 3]);
 %! assert (sortrows (sort (h, 2), [1:3]), [1 2 4; 1 2 5; 1 4 5; 2 3 4; 2 3 6; 2 5 6; 3 4 8; 3 6 7; 3 7 8; 4 5 8; 5 6 8; 6 7 8]);
 %! assert (v, 1.0, 1e6*eps);
 
 %!testif HAVE_QHULL
 %! tetrahedron = [1 1 1;-1 -1 1;-1 1 -1;1 -1 -1];
 %! [h, v] = convhulln (tetrahedron);
 %! h = sortrows (sort (h, 2), [1 2 3]);
 %! assert (h, [1 2 3;1 2 4; 1 3 4; 2 3 4]);
diff --git a/libinterp/dldfcn/dmperm.cc b/libinterp/dldfcn/dmperm.cc
--- a/libinterp/dldfcn/dmperm.cc
+++ b/libinterp/dldfcn/dmperm.cc
@@ -127,17 +127,17 @@ dmperm_internal (bool rank, const octave
           CXSPARSE_NAME (_dfree) (dm);
         }
     }
   return retval;
 }
 #endif
 
 DEFUN_DLD (dmperm, args, nargout,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{p} =} dmperm (@var{S})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{q}, @var{r}, @var{S}] =} dmperm (@var{S})\n\
 \n\
 @cindex Dulmage-Mendelsohn decomposition\n\
 Perform a Dulmage-Mendelsohn permutation of the sparse matrix @var{S}.\n\
 With a single output argument @code{dmperm} performs the row permutations\n\
 @var{p} such that @code{@var{S}(@var{p},:)} has no zero elements on the\n\
 diagonal.\n\
@@ -183,17 +183,17 @@ 16(4):303-324, 1990.\n\
 %! d = 0.2;
 %! a = tril (sprandn (n,n,d), -1) + speye (n,n);
 %! a = a(randperm (n), randperm (n));
 %! [p,q,r,s] = dmperm (a);
 %! assert (tril (a(p,q), -1), sparse (n, n));
 */
 
 DEFUN_DLD (sprank, args, nargout,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{p} =} sprank (@var{S})\n\
 @cindex structural rank\n\
 \n\
 Calculate the structural rank of the sparse matrix @var{S}.  Note that\n\
 only the structure of the matrix is used in this calculation based on\n\
 a Dulmage-Mendelsohn permutation to block triangular form.  As such the\n\
 numerical rank of the matrix @var{S} is bounded by\n\
 @code{sprank (@var{S}) >= rank (@var{S})}.  Ignoring floating point errors\n\
diff --git a/libinterp/dldfcn/fftw.cc b/libinterp/dldfcn/fftw.cc
--- a/libinterp/dldfcn/fftw.cc
+++ b/libinterp/dldfcn/fftw.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 
 #include "oct-fftw.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "ov.h"
 
 DEFUN_DLD (fftw, args, ,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{method} =} fftw (\"planner\")\n\
 @deftypefnx {Loadable Function} {} fftw (\"planner\", @var{method})\n\
 @deftypefnx {Loadable Function} {@var{wisdom} =} fftw (\"dwisdom\")\n\
 @deftypefnx {Loadable Function} {} fftw (\"dwisdom\", @var{wisdom})\n\
 @deftypefnx {Loadable Function} {} fftw (\"threads\", @var{nthreads})\n\
 @deftypefnx {Loadable Function} {@var{nthreads} =} fftw (\"threads\")\n\
 \n\
 Manage @sc{fftw} wisdom data.  Wisdom data can be used to significantly\n\
@@ -146,17 +146,18 @@ used per default.\n\
         {
           if (arg0 == "planner")
             {
               if (nargin == 2)  //planner setter
                 {
                   if (args(1).is_string ())
                     {
                       // Use STL function to convert to lower case
-                      std::transform (arg0.begin (), arg0.end (), arg0.begin (), tolower);
+                      std::transform (arg0.begin (), arg0.end (), arg0.begin (),
+                                      tolower);
                       std::string arg1 = args(1).string_value ();
                       if (!error_state)
                         {
                           std::transform (arg1.begin (), arg1.end (),
                                           arg1.begin (), tolower);
                           octave_fftw_planner::FftwMethod meth
                             = octave_fftw_planner::UNKNOWN;
                           octave_float_fftw_planner::FftwMethod methf
@@ -230,17 +231,18 @@ used per default.\n\
             }
           else if (arg0 == "dwisdom")
             {
               if (nargin == 2)  //dwisdom setter
                 {
                   if (args(1).is_string ())
                     {
                       // Use STL function to convert to lower case
-                      std::transform (arg0.begin (), arg0.end (), arg0.begin (), tolower);
+                      std::transform (arg0.begin (), arg0.end (), arg0.begin (),
+                                      tolower);
                       std::string arg1 = args(1).string_value ();
                       if (!error_state)
                         {
                           char *str = fftw_export_wisdom_to_string ();
 
                           if (arg1.length () < 1)
                             fftw_forget_wisdom ();
                           else if (! fftw_import_wisdom_from_string (arg1.c_str ()))
@@ -263,17 +265,18 @@ used per default.\n\
           else if (arg0 == "swisdom")
             {
               //swisdom uses fftwf_ functions (float), dwisdom fftw_ (real)
               if (nargin == 2)  //swisdom setter
                 {
                   if (args(1).is_string ())
                     {
                       // Use STL function to convert to lower case
-                      std::transform (arg0.begin (), arg0.end (), arg0.begin (), tolower);
+                      std::transform (arg0.begin (), arg0.end (), arg0.begin (),
+                                      tolower);
                       std::string arg1 = args(1).string_value ();
                       if (!error_state)
                         {
                           char *str = fftwf_export_wisdom_to_string ();
 
                           if (arg1.length () < 1)
                             fftwf_forget_wisdom ();
                           else if (! fftwf_import_wisdom_from_string (arg1.c_str ()))
@@ -315,17 +318,17 @@ used per default.\n\
                         }
                       else
                         error ("number of threads must be >=1");
                     }
                   else
                     error ("setting threads needs one integer argument.");
                 }
               else //threads getter
-#if defined (HAVE_FFTW3_THREADS)              
+#if defined (HAVE_FFTW3_THREADS)
                 retval = octave_value (octave_fftw_planner::threads());
 #else
                 retval = 1;
 #endif
             }
           else
             error ("unrecognized argument");
         }
diff --git a/libinterp/dldfcn/qr.cc b/libinterp/dldfcn/qr.cc
--- a/libinterp/dldfcn/qr.cc
+++ b/libinterp/dldfcn/qr.cc
@@ -68,17 +68,17 @@ get_qr_r (const base_qr<MT>& fact)
 //
 // [Q, R, P] = qr (X, 0): form the economy decomposition with
 //                        permutation vector P such that Q * R = X (:, P)
 //
 // qr (X) alone returns the output of the LAPACK routine dgeqrf, such
 // that R = triu (qr (X))
 
 DEFUN_DLD (qr, args, nargout,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {[@var{Q}, @var{R}, @var{P}] =} qr (@var{A})\n\
 @deftypefnx {Loadable Function} {[@var{Q}, @var{R}, @var{P}] =} qr (@var{A}, '0')\n\
 @deftypefnx {Loadable Function} {[@var{C}, @var{R}] =} qr (@var{A}, @var{B})\n\
 @deftypefnx {Loadable Function} {[@var{C}, @var{R}] =} qr (@var{A}, @var{B}, '0')\n\
 @cindex QR factorization\n\
 Compute the QR@tie{}factorization of @var{A}, using standard @sc{lapack}\n\
 subroutines.  For example, given the matrix @code{@var{A} = [1, 2; 3, 4]},\n\
 \n\
@@ -284,17 +284,18 @@ x = @var{R} \\ @var{C}\n\
                     retval(0) = q.R (economy);
                 }
             }
         }
     }
   else
     {
       QR::type type = (nargout == 0 || nargout == 1) ? QR::raw
-        : (nargin == 2 ? QR::economy : QR::std);
+                                                     : nargin == 2
+                                                       ? QR::economy : QR::std;
 
       if (arg.is_single_type ())
         {
           if (arg.is_real_type ())
             {
               FloatMatrix m = arg.float_matrix_value ();
 
               if (! error_state)
@@ -464,17 +465,17 @@ x = @var{R} \\ @var{C}\n\
 %! [qe, re] = qr (a, 0);
 %!
 %! assert (q * r, a, sqrt (eps));
 %! assert (qe * re, a, sqrt (eps));
 
 %!test
 %! a = [0, 2, 1; 2, 1, 2];
 %!
-%! [q, r, p] = qr (a);  # FIXME: not giving right dimensions. 
+%! [q, r, p] = qr (a);  # FIXME: not giving right dimensions.
 %! [qe, re, pe] = qr (a, 0);
 %!
 %! assert (q * r, a * p, sqrt (eps));
 %! assert (qe * re, a(:, pe), sqrt (eps));
 
 %!test
 %! a = [0, 2; 2, 1; 1, 2];
 %!
@@ -740,28 +741,28 @@ x = @var{R} \\ @var{C}\n\
 */
 
 static
 bool check_qr_dims (const octave_value& q, const octave_value& r,
                     bool allow_ecf = false)
 {
   octave_idx_type m = q.rows (), k = r.rows (), n = r.columns ();
   return ((q.ndims () == 2 && r.ndims () == 2 && k == q.columns ())
-            && (m == k || (allow_ecf && k == n && k < m)));
+          && (m == k || (allow_ecf && k == n && k < m)));
 }
 
 static
 bool check_index (const octave_value& i, bool vector_allowed = false)
 {
   return ((i.is_real_type () || i.is_integer_type ())
           && (i.is_scalar_type () || vector_allowed));
 }
 
 DEFUN_DLD (qrupdate, args, ,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{Q1}, @var{R1}] =} qrupdate (@var{Q}, @var{R}, @var{u}, @var{v})\n\
 Given a QR@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and\n\
 @var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization\n\
 of @w{@var{A} + @var{u}*@var{v}'}, where @var{u} and @var{v} are\n\
 column vectors (rank-1 update) or matrices with equal number of columns\n\
 (rank-k update).  Notice that the latter case is done as a sequence of rank-1\n\
 updates; thus, for k large enough, it will be both faster and more accurate\n\
@@ -931,17 +932,17 @@ The QR@tie{}factorization supplied may b
 %! [Q,R] = qr (single (Ac));
 %! [Q,R] = qrupdate (Q, R, single (uc), single (vc));
 %! assert (norm (vec (Q'*Q - eye (5,"single")), Inf) < 1e1*eps ("single"));
 %! assert (norm (vec (triu (R)-R), Inf) == 0);
 %! assert (norm (vec (Q*R - single (Ac) - single (uc)*single (vc)'), Inf) < norm (single (Ac))*1e1*eps ("single"));
 */
 
 DEFUN_DLD (qrinsert, args, ,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{Q1}, @var{R1}] =} qrinsert (@var{Q}, @var{R}, @var{j}, @var{x}, @var{orient})\n\
 Given a QR@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and\n\
 @var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization of\n\
 @w{[A(:,1:j-1) x A(:,j:n)]}, where @var{u} is a column vector to be\n\
 inserted into @var{A} (if @var{orient} is @qcode{\"col\"}), or the\n\
 QR@tie{}factorization of @w{[A(1:j-1,:);x;A(:,j:n)]}, where @var{x}\n\
 is a row vector to be inserted into @var{A} (if @var{orient} is\n\
@@ -1041,19 +1042,22 @@ If @var{orient} is @qcode{\"row\"}, full
                   }
                 else
                   {
                     // complex case
                     if (argq.is_single_type ()
                         || argr.is_single_type ()
                         || argx.is_single_type ())
                       {
-                        FloatComplexMatrix Q = argq.float_complex_matrix_value ();
-                        FloatComplexMatrix R = argr.float_complex_matrix_value ();
-                        FloatComplexMatrix x = argx.float_complex_matrix_value ();
+                        FloatComplexMatrix Q =
+                          argq.float_complex_matrix_value ();
+                        FloatComplexMatrix R =
+                          argr.float_complex_matrix_value ();
+                        FloatComplexMatrix x =
+                          argx.float_complex_matrix_value ();
 
                         FloatComplexQR fact (Q, R);
 
                         if (col)
                           fact.insert_col (x, j-one);
                         else
                           fact.insert_row (x.row (0), j(0)-one);
 
@@ -1150,17 +1154,17 @@ If @var{orient} is @qcode{\"row\"}, full
 %! [Q,R] = qr (single (Ac));
 %! [Q,R] = qrinsert (Q, R, 3, x, "row");
 %! assert (norm (vec (Q'*Q - eye (6,"single")), Inf) < 1e1*eps ("single"));
 %! assert (norm (vec (triu (R) - R), Inf) == 0);
 %! assert (norm (vec (Q*R - single ([Ac(1:2,:);x;Ac(3:5,:)])), Inf) < norm (single (Ac))*1e1*eps ("single"));
 */
 
 DEFUN_DLD (qrdelete, args, ,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{Q1}, @var{R1}] =} qrdelete (@var{Q}, @var{R}, @var{j}, @var{orient})\n\
 Given a QR@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and\n\
 @var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization of\n\
 @w{[A(:,1:j-1) A(:,j+1:n)]}, i.e., @var{A} with one column deleted\n\
 (if @var{orient} is @qcode{\"col\"}), or the QR@tie{}factorization of\n\
 @w{[A(1:j-1,:);A(j+1:n,:)]}, i.e., @var{A} with one row deleted (if\n\
 @var{orient} is @qcode{\"row\"}).\n\
@@ -1250,18 +1254,20 @@ If @var{orient} is @qcode{\"row\"}, full
                       }
                   }
                 else
                   {
                     // complex case
                     if (argq.is_single_type ()
                         || argr.is_single_type ())
                       {
-                        FloatComplexMatrix Q = argq.float_complex_matrix_value ();
-                        FloatComplexMatrix R = argr.float_complex_matrix_value ();
+                        FloatComplexMatrix Q =
+                          argq.float_complex_matrix_value ();
+                        FloatComplexMatrix R =
+                          argr.float_complex_matrix_value ();
 
                         FloatComplexQR fact (Q, R);
 
                         if (col)
                           fact.delete_col (j-one);
                         else
                           fact.delete_row (j(0)-one);
 
@@ -1415,17 +1421,17 @@ If @var{orient} is @qcode{\"row\"}, full
 %! [Q,R] = qr (AA);
 %! [Q,R] = qrdelete (Q, R, 3, "row");
 %! assert (norm (vec (Q'*Q - eye (4,"single")), Inf) < 1e1*eps ("single"));
 %! assert (norm (vec (triu (R) - R), Inf) == 0);
 %! assert (norm (vec (Q*R - [AA(1:2,:);AA(4:5,:)]), Inf) < norm (AA)*1e1*eps ("single"));
 */
 
 DEFUN_DLD (qrshift, args, ,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{Q1}, @var{R1}] =} qrshift (@var{Q}, @var{R}, @var{i}, @var{j})\n\
 Given a QR@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and\n\
 @var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization\n\
 of @w{@var{A}(:,p)}, where @w{p} is the permutation @*\n\
 @code{p = [1:i-1, shift(i:j, 1), j+1:n]} if @w{@var{i} < @var{j}} @*\n\
  or @*\n\
 @code{p = [1:j-1, shift(j:i,-1), i+1:n]} if @w{@var{j} < @var{i}}.  @*\n\
diff --git a/libinterp/dldfcn/symbfact.cc b/libinterp/dldfcn/symbfact.cc
--- a/libinterp/dldfcn/symbfact.cc
+++ b/libinterp/dldfcn/symbfact.cc
@@ -35,17 +35,17 @@ along with Octave; see the file COPYING.
 #include "ov-cx-sparse.h"
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "utils.h"
 
 DEFUN_DLD (symbfact, args, nargout,
-    "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {[@var{count}, @var{h}, @var{parent}, @var{post}, @var{r}] =} symbfact (@var{S})\n\
 @deftypefnx {Loadable Function} {[@dots{}] =} symbfact (@var{S}, @var{typ})\n\
 @deftypefnx {Loadable Function} {[@dots{}] =} symbfact (@var{S}, @var{typ}, @var{mode})\n\
 \n\
 Perform a symbolic factorization analysis on the sparse matrix @var{S}.\n\
 Where\n\
 \n\
 @table @var\n\
@@ -350,15 +350,15 @@ factorization as determined by @var{typ}
           retval(1) = static_cast<double> (height);
         }
 
       for (octave_idx_type i = 0; i < n; i++)
         tmp(i) = ColCount[i];
       retval(0) = tmp;
     }
 
- symbfact_error:
+symbfact_error:
 #else
   error ("symbfact: not available in this version of Octave");
 #endif
 
   return retval;
 }
diff --git a/libinterp/dldfcn/symrcm.cc b/libinterp/dldfcn/symrcm.cc
--- a/libinterp/dldfcn/symrcm.cc
+++ b/libinterp/dldfcn/symrcm.cc
@@ -407,17 +407,17 @@ transpose (octave_idx_type N, const octa
         OCTAVE_QUIT;
         octave_idx_type q = w[ridx[k]]++;
         ridx2[q] = j;
       }
 }
 
 // An implementation of the Cuthill-McKee algorithm.
 DEFUN_DLD (symrcm, args, ,
-  "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{p} =} symrcm (@var{S})\n\
 Return the symmetric reverse Cuthill-McKee permutation of @var{S}.\n\
 @var{p} is a permutation vector such that\n\
 @code{@var{S}(@var{p}, @var{p})} tends to have its diagonal elements\n\
 closer to the diagonal than @var{S}.  This is a good preordering for LU\n\
 or Cholesky@tie{}factorization of matrices that come from ``long, skinny''\n\
 problems.  It works for both symmetric and asymmetric @var{S}.\n\
 \n\
diff --git a/libinterp/dldfcn/tsearch.cc b/libinterp/dldfcn/tsearch.cc
--- a/libinterp/dldfcn/tsearch.cc
+++ b/libinterp/dldfcn/tsearch.cc
@@ -60,17 +60,17 @@ inline double min (double a, double b, d
 // one should presort (how?) either the elements of the points of evaluation
 // to cut down the time needed to decide which triangle contains the
 // given point
 
 // e.g., build up a neighbouring triangle structure and use a simplex-like
 // method to traverse it
 
 DEFUN_DLD (tsearch, args, ,
-        "-*- texinfo -*-\n\
+           "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{idx} =} tsearch (@var{x}, @var{y}, @var{t}, @var{xi}, @var{yi})\n\
 Search for the enclosing Delaunay convex hull.  For @code{@var{t} =\n\
 delaunay (@var{x}, @var{y})}, finds the index in @var{t} containing the\n\
 points @code{(@var{xi}, @var{yi})}.  For points outside the convex hull,\n\
 @var{idx} is NaN.\n\
 @seealso{delaunay, delaunayn}\n\
 @end deftypefn")
 {
diff --git a/libinterp/octave-value/ov-base-diag.cc b/libinterp/octave-value/ov-base-diag.cc
--- a/libinterp/octave-value/ov-base-diag.cc
+++ b/libinterp/octave-value/ov-base-diag.cc
@@ -142,22 +142,25 @@ octave_base_diag<DMT, MT>::subsasgn (con
 
   switch (type[0])
     {
     case '(':
       {
         if (type.length () == 1)
           {
             octave_value_list jdx = idx.front ();
-            // Check for a simple element assignment. That means, if D is a diagonal matrix,
-            // 'D(i,i) = x' will not destroy its diagonality (provided i is a valid index).
-            if (jdx.length () == 2 && jdx(0).is_scalar_type () && jdx(1).is_scalar_type ())
+            // Check for a simple element assignment. That means, if D is a
+            // diagonal matrix, 'D(i,i) = x' will not destroy its diagonality
+            // (provided i is a valid index).
+            if (jdx.length () == 2
+                && jdx(0).is_scalar_type () && jdx(1).is_scalar_type ())
               {
                 typename DMT::element_type val;
-                idx_vector i0 = jdx(0).index_vector (), i1 = jdx(1).index_vector ();
+                idx_vector i0 = jdx(0).index_vector ();
+                idx_vector i1 = jdx(1).index_vector ();
                 if (! error_state  && i0(0) == i1(0)
                     && i0(0) < matrix.rows () && i1(0) < matrix.cols ()
                     && chk_valid_scalar (rhs, val))
                   {
                     matrix.dgelem (i0(0)) = val;
                     retval = this;
                     this->count++;
                     // invalidate cache
@@ -219,20 +222,22 @@ octave_base_diag<DMT, MT>::resize (const
 
 template <class DMT, class MT>
 bool
 octave_base_diag<DMT, MT>::is_true (void) const
 {
   return to_dense ().is_true ();
 }
 
-// FIXME: this should be achieveable using ::real
+// FIXME: This should be achieveable using ::real
 template <class T> inline T helper_getreal (T x) { return x; }
-template <class T> inline T helper_getreal (std::complex<T> x) { return x.real (); }
-// FIXME: we really need some traits so that ad hoc hooks like this are not necessary
+template <class T> inline T helper_getreal (std::complex<T> x)
+{ return x.real (); }
+// FIXME: We really need some traits so that ad hoc hooks like this
+//        are not necessary.
 template <class T> inline T helper_iscomplex (T) { return false; }
 template <class T> inline T helper_iscomplex (std::complex<T>) { return true; }
 
 template <class DMT, class MT>
 double
 octave_base_diag<DMT, MT>::double_value (bool force_conversion) const
 {
   double retval = lo_ieee_nan_value ();
@@ -409,27 +414,28 @@ template <class DMT, class MT>
 idx_vector
 octave_base_diag<DMT, MT>::index_vector (void) const
 {
   return to_dense ().index_vector ();
 }
 
 template <class DMT, class MT>
 octave_value
-octave_base_diag<DMT, MT>::convert_to_str_internal (bool pad, bool force, char type) const
+octave_base_diag<DMT, MT>::convert_to_str_internal (bool pad, bool force,
+                                                    char type) const
 {
   return to_dense ().convert_to_str_internal (pad, force, type);
 }
 
 template <class DMT, class MT>
 bool
 octave_base_diag<DMT, MT>::save_ascii (std::ostream& os)
 {
   os << "# rows: " << matrix.rows () << "\n"
-    << "# columns: " << matrix.columns () << "\n";
+     << "# columns: " << matrix.columns () << "\n";
 
   os << matrix.extract_diag ();
 
   return true;
 }
 
 template <class DMT, class MT>
 bool
@@ -494,25 +500,27 @@ octave_base_diag<DMT, MT>::print_as_scal
 {
   dim_vector dv = dims ();
 
   return (dv.all_ones () || dv.any_zero ());
 }
 
 template <class DMT, class MT>
 void
-octave_base_diag<DMT, MT>::print (std::ostream& os, bool pr_as_read_syntax) const
+octave_base_diag<DMT, MT>::print (std::ostream& os,
+                                  bool pr_as_read_syntax) const
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 template <class DMT, class MT>
 int
 octave_base_diag<DMT, MT>::write (octave_stream& os, int block_size,
-                                  oct_data_conv::data_type output_type, int skip,
+                                  oct_data_conv::data_type output_type,
+                                  int skip,
                                   oct_mach_info::float_format flt_fmt) const
 {
   return to_dense ().write (os, block_size, output_type, skip, flt_fmt);
 }
 
 template <class DMT, class MT>
 void
 octave_base_diag<DMT, MT>::print_info (std::ostream& os,
diff --git a/libinterp/octave-value/ov-base-diag.h b/libinterp/octave-value/ov-base-diag.h
--- a/libinterp/octave-value/ov-base-diag.h
+++ b/libinterp/octave-value/ov-base-diag.h
@@ -64,60 +64,60 @@ public:
 
   octave_value full_value (void) const { return to_dense (); }
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx);
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx, int)
-    { return subsref (type, idx); }
+  { return subsref (type, idx); }
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false);
 
   octave_value subsasgn (const std::string& type,
                          const std::list<octave_value_list>& idx,
                          const octave_value& rhs);
 
   dim_vector dims (void) const { return matrix.dims (); }
 
   octave_idx_type nnz (void) const { return to_dense ().nnz (); }
 
   octave_value reshape (const dim_vector& new_dims) const
-    { return to_dense ().reshape (new_dims); }
+  { return to_dense ().reshape (new_dims); }
 
   octave_value permute (const Array<int>& vec, bool inv = false) const
-    { return to_dense ().permute (vec, inv); }
+  { return to_dense ().permute (vec, inv); }
 
   octave_value resize (const dim_vector& dv, bool fill = false) const;
 
   octave_value all (int dim = 0) const { return MT (matrix).all (dim); }
   octave_value any (int dim = 0) const { return MT (matrix).any (dim); }
 
   MatrixType matrix_type (void) const { return MatrixType::Diagonal; }
   MatrixType matrix_type (const MatrixType&) const
-    { return matrix_type (); }
+  { return matrix_type (); }
 
   octave_value diag (octave_idx_type k = 0) const;
 
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
-    { return to_dense ().sort (dim, mode); }
+  { return to_dense ().sort (dim, mode); }
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
                      sortmode mode = ASCENDING) const
-    { return to_dense ().sort (sidx, dim, mode); }
+  { return to_dense ().sort (sidx, dim, mode); }
 
   sortmode is_sorted (sortmode mode = UNSORTED) const
-    { return to_dense ().is_sorted (mode); }
+  { return to_dense ().is_sorted (mode); }
 
   Array<octave_idx_type> sort_rows_idx (sortmode mode = ASCENDING) const
-    { return to_dense ().sort_rows_idx (mode); }
+  { return to_dense ().sort_rows_idx (mode); }
 
   sortmode is_sorted_rows (sortmode mode = UNSORTED) const
-    { return to_dense ().is_sorted_rows (mode); }
+  { return to_dense ().is_sorted_rows (mode); }
 
   bool is_matrix_type (void) const { return true; }
 
   bool is_numeric_type (void) const { return true; }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
@@ -126,17 +126,17 @@ public:
 
   bool is_diag_matrix (void) const { return true; }
 
   double double_value (bool = false) const;
 
   float float_value (bool = false) const;
 
   double scalar_value (bool frc_str_conv = false) const
-    { return double_value (frc_str_conv); }
+  { return double_value (frc_str_conv); }
 
   idx_vector index_vector (void) const;
 
   Matrix matrix_value (bool = false) const;
 
   FloatMatrix float_matrix_value (bool = false) const;
 
   Complex complex_value (bool = false) const;
diff --git a/libinterp/octave-value/ov-base-int.cc b/libinterp/octave-value/ov-base-int.cc
--- a/libinterp/octave-value/ov-base-int.cc
+++ b/libinterp/octave-value/ov-base-int.cc
@@ -124,17 +124,18 @@ struct octave_base_int_helper_traits<uns
 
 template <class T>
 octave_base_value *
 octave_base_int_matrix<T>::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
   if (this->matrix.nelem () == 1)
-    retval = new typename octave_value_int_traits<T>::scalar_type (this->matrix (0));
+    retval = new typename octave_value_int_traits<T>::scalar_type
+               (this->matrix (0));
 
   return retval;
 }
 
 template <class T>
 octave_value
 octave_base_int_matrix<T>::convert_to_str_internal (bool, bool, char type) const
 {
@@ -158,17 +159,17 @@ octave_base_int_matrix<T>::convert_to_st
 
       static const bool is_signed = std::numeric_limits<val_type>::is_signed;
       static const bool can_be_larger_than_uchar_max
         = octave_base_int_helper_traits<val_type>::can_be_larger_than_uchar_max;
 
       if (octave_base_int_helper<val_type, is_signed,
           can_be_larger_than_uchar_max>::char_value_out_of_range (ival))
         {
-          // FIXME -- is there something better we could do?
+          // FIXME: is there something better we could do?
 
           ival = 0;
 
           if (! warned)
             {
               ::warning ("range error for conversion to character value");
               warned = true;
             }
@@ -251,17 +252,18 @@ octave_base_int_matrix<T>::save_binary (
   int32_t tmp = - d.length ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i=0; i < d.length (); i++)
     {
       tmp = d(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
-  os.write (reinterpret_cast<const char *> (this->matrix.data ()), this->byte_size ());
+  os.write (reinterpret_cast<const char *> (this->matrix.data ()),
+            this->byte_size ());
 
   return true;
 }
 
 template <class T>
 bool
 octave_base_int_matrix<T>::load_binary (std::istream& is, bool swap,
                                         oct_mach_info::float_format )
@@ -383,17 +385,17 @@ octave_base_int_matrix<T>::load_hdf5 (hi
 {
   hid_t save_type_hid = HDF5_SAVE_TYPE;
   bool retval = false;
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     this->matrix.resize (dv);
   if (empty)
-      return (empty > 0);
+    return (empty > 0);
 
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t space_id = H5Dget_space (data_hid);
 
@@ -464,17 +466,17 @@ octave_base_int_scalar<T>::convert_to_st
 
   static const bool is_signed = std::numeric_limits<val_type>::is_signed;
   static const bool can_be_larger_than_uchar_max
     = octave_base_int_helper_traits<val_type>::can_be_larger_than_uchar_max;
 
   if (octave_base_int_helper<val_type, is_signed,
       can_be_larger_than_uchar_max>::char_value_out_of_range (ival))
     {
-      // FIXME -- is there something better we could do?
+      // FIXME: is there something better we could do?
 
       ival = 0;
 
       ::warning ("range error for conversion to character value");
     }
   else
     retval = octave_value (std::string (1, static_cast<char> (ival)), type);
 
diff --git a/libinterp/octave-value/ov-base-int.h b/libinterp/octave-value/ov-base-int.h
--- a/libinterp/octave-value/ov-base-int.h
+++ b/libinterp/octave-value/ov-base-int.h
@@ -47,18 +47,21 @@ octave_base_int_matrix : public octave_b
 public:
 
   octave_base_int_matrix (void) : octave_base_matrix<T> () { }
 
   octave_base_int_matrix (const T& nda) : octave_base_matrix<T> (nda) { }
 
   ~octave_base_int_matrix (void) { }
 
-  octave_base_value *clone (void) const { return new octave_base_int_matrix (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_base_int_matrix (); }
+  octave_base_value *clone (void) const
+  { return new octave_base_int_matrix (*this); }
+
+  octave_base_value *empty_clone (void) const
+  { return new octave_base_int_matrix (); }
 
   octave_base_value *try_narrowing_conversion (void);
 
   bool is_real_type (void) const { return true; }
 
   //  void increment (void) { matrix += 1; }
 
   //  void decrement (void) { matrix -= 1; }
@@ -92,18 +95,20 @@ octave_base_int_scalar : public octave_b
 public:
 
   octave_base_int_scalar (void) : octave_base_scalar<T> () { }
 
   octave_base_int_scalar (const T& s) : octave_base_scalar<T> (s) { }
 
   ~octave_base_int_scalar (void) { }
 
-  octave_base_value *clone (void) const { return new octave_base_int_scalar (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_base_int_scalar (); }
+  octave_base_value *clone (void) const
+  { return new octave_base_int_scalar (*this); }
+  octave_base_value *empty_clone (void) const
+  { return new octave_base_int_scalar (); }
 
   octave_base_value *try_narrowing_conversion (void) { return 0; }
 
   bool is_real_type (void) const { return true; }
 
   //  void increment (void) { scalar += 1; }
 
   //  void decrement (void) { scalar -= 1; }
diff --git a/libinterp/octave-value/ov-base-mat.h b/libinterp/octave-value/ov-base-mat.h
--- a/libinterp/octave-value/ov-base-mat.h
+++ b/libinterp/octave-value/ov-base-mat.h
@@ -58,93 +58,93 @@ public:
     if (matrix.ndims () == 0)
       matrix.resize (dim_vector (0, 0));
   }
 
   octave_base_matrix (const octave_base_matrix& m)
     : octave_base_value (), matrix (m.matrix),
       typ (m.typ ? new MatrixType (*m.typ) : 0),
       idx_cache (m.idx_cache ? new idx_vector (*m.idx_cache) : 0)
-    { }
+  { }
 
   ~octave_base_matrix (void) { clear_cached_info (); }
 
   size_t byte_size (void) const { return matrix.byte_size (); }
 
   octave_value squeeze (void) const { return MT (matrix.squeeze ()); }
 
   octave_value full_value (void) const { return matrix; }
 
   void maybe_economize (void) { matrix.maybe_economize (); }
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx);
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx, int)
-    { return subsref (type, idx); }
+  { return subsref (type, idx); }
 
   octave_value subsasgn (const std::string& type,
                          const std::list<octave_value_list>& idx,
                          const octave_value& rhs);
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false);
 
   octave_value_list do_multi_index_op (int, const octave_value_list& idx)
-    { return do_index_op (idx); }
+  { return do_index_op (idx); }
 
   void assign (const octave_value_list& idx, const MT& rhs);
 
   void assign (const octave_value_list& idx, typename MT::element_type rhs);
 
   void delete_elements (const octave_value_list& idx);
 
   dim_vector dims (void) const { return matrix.dims (); }
 
   octave_idx_type numel (void) const { return matrix.numel (); }
 
   int ndims (void) const { return matrix.ndims (); }
 
   octave_idx_type nnz (void) const { return matrix.nnz (); }
 
   octave_value reshape (const dim_vector& new_dims) const
-    { return MT (matrix.reshape (new_dims)); }
+  { return MT (matrix.reshape (new_dims)); }
 
   octave_value permute (const Array<int>& vec, bool inv = false) const
-    { return MT (matrix.permute (vec, inv)); }
+  { return MT (matrix.permute (vec, inv)); }
 
   octave_value resize (const dim_vector& dv, bool fill = false) const;
 
   octave_value all (int dim = 0) const { return matrix.all (dim); }
   octave_value any (int dim = 0) const { return matrix.any (dim); }
 
   MatrixType matrix_type (void) const { return typ ? *typ : MatrixType (); }
   MatrixType matrix_type (const MatrixType& _typ) const;
 
   octave_value diag (octave_idx_type k = 0) const
-    { return octave_value (matrix.diag (k)); }
+  { return octave_value (matrix.diag (k)); }
 
   octave_value diag (octave_idx_type m, octave_idx_type n) const
-    { return octave_value (matrix.diag (m, n)); }
+  { return octave_value (matrix.diag (m, n)); }
 
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
-    { return octave_value (matrix.sort (dim, mode)); }
+  { return octave_value (matrix.sort (dim, mode)); }
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
                      sortmode mode = ASCENDING) const
-    { return octave_value (matrix.sort (sidx, dim, mode)); }
+  { return octave_value (matrix.sort (sidx, dim, mode)); }
 
   sortmode is_sorted (sortmode mode = UNSORTED) const
-    { return matrix.is_sorted (mode); }
+  { return matrix.is_sorted (mode); }
 
   Array<octave_idx_type> sort_rows_idx (sortmode mode = ASCENDING) const
-    { return matrix.sort_rows_idx (mode); }
+  { return matrix.sort_rows_idx (mode); }
 
   sortmode is_sorted_rows (sortmode mode = UNSORTED) const
-    { return matrix.is_sorted_rows (mode); }
+  { return matrix.is_sorted_rows (mode); }
 
   bool is_matrix_type (void) const { return true; }
 
   bool is_numeric_type (void) const { return true; }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
@@ -153,48 +153,48 @@ public:
 
   bool print_as_scalar (void) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_info (std::ostream& os, const std::string& prefix) const;
 
   MT& matrix_ref (void)
-    {
-      clear_cached_info ();
-      return matrix;
-    }
+  {
+    clear_cached_info ();
+    return matrix;
+  }
 
   const MT& matrix_ref (void) const
-    {
-      return matrix;
-    }
+  {
+    return matrix;
+  }
 
   octave_value
   fast_elem_extract (octave_idx_type n) const;
 
   bool
   fast_elem_insert (octave_idx_type n, const octave_value& x);
 
 protected:
 
   MT matrix;
 
   idx_vector set_idx_cache (const idx_vector& idx) const
-    {
-      delete idx_cache;
-      idx_cache = idx ? new idx_vector (idx) : 0;
-      return idx;
-    }
+  {
+    delete idx_cache;
+    idx_cache = idx ? new idx_vector (idx) : 0;
+    return idx;
+  }
 
   void clear_cached_info (void) const
-    {
-      delete typ; typ = 0;
-      delete idx_cache; idx_cache = 0;
-    }
+  {
+    delete typ; typ = 0;
+    delete idx_cache; idx_cache = 0;
+  }
 
   mutable MatrixType *typ;
   mutable idx_vector *idx_cache;
 
 private:
 
   // No assignment.
 
diff --git a/libinterp/octave-value/ov-base-scalar.cc b/libinterp/octave-value/ov-base-scalar.cc
--- a/libinterp/octave-value/ov-base-scalar.cc
+++ b/libinterp/octave-value/ov-base-scalar.cc
@@ -174,17 +174,18 @@ octave_base_scalar<ST>::short_disp (void
 {
   std::ostringstream buf;
   octave_print_internal (buf, scalar);
   return buf.str ();
 }
 
 template <class ST>
 bool
-octave_base_scalar<ST>::fast_elem_insert_self (void *where, builtin_type_t btyp) const
+octave_base_scalar<ST>::fast_elem_insert_self (void *where,
+                                               builtin_type_t btyp) const
 {
 
   // Don't use builtin_type () here to avoid an extra VM call.
   if (btyp == class_to_btyp<ST>::btyp)
     {
       *(reinterpret_cast<ST *>(where)) = scalar;
       return true;
     }
diff --git a/libinterp/octave-value/ov-base-scalar.h b/libinterp/octave-value/ov-base-scalar.h
--- a/libinterp/octave-value/ov-base-scalar.h
+++ b/libinterp/octave-value/ov-base-scalar.h
@@ -60,24 +60,24 @@ public:
 
   octave_value full_value (void) const { return scalar; }
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx);
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx, int)
-    { return subsref (type, idx); }
+  { return subsref (type, idx); }
 
   octave_value subsasgn (const std::string& type,
                          const std::list<octave_value_list>& idx,
                          const octave_value& rhs);
 
   octave_value_list do_multi_index_op (int, const octave_value_list& idx)
-    { return do_index_op (idx); }
+  { return do_index_op (idx); }
 
   bool is_constant (void) const { return true; }
 
   bool is_defined (void) const { return true; }
 
   dim_vector dims (void) const { static dim_vector dv (1, 1); return dv; }
 
   octave_idx_type numel (void) const { return 1; }
@@ -96,40 +96,40 @@ public:
 
   octave_value any (int = 0) const { return (scalar != ST ()); }
 
   octave_value diag (octave_idx_type k = 0) const;
 
   octave_value diag (octave_idx_type m, octave_idx_type n) const;
 
   octave_value sort (octave_idx_type, sortmode) const
-    { return octave_value (scalar); }
+  { return octave_value (scalar); }
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type,
                      sortmode) const
-    {
-      sidx.resize (dim_vector (1, 1));
-      sidx(0) = 0;
-      return octave_value (scalar);
-    }
+  {
+    sidx.resize (dim_vector (1, 1));
+    sidx(0) = 0;
+    return octave_value (scalar);
+  }
 
   sortmode is_sorted (sortmode mode = UNSORTED) const
-    { return mode ? mode : ASCENDING; }
+  { return mode ? mode : ASCENDING; }
 
   Array<octave_idx_type> sort_rows_idx (sortmode) const
-    {
-      return Array<octave_idx_type> (dim_vector (1, 1),
-                                     static_cast<octave_idx_type> (0));
-    }
+  {
+    return Array<octave_idx_type> (dim_vector (1, 1),
+                                   static_cast<octave_idx_type> (0));
+  }
 
   sortmode is_sorted_rows (sortmode mode = UNSORTED) const
-    { return mode ? mode : ASCENDING; }
+  { return mode ? mode : ASCENDING; }
 
   MatrixType matrix_type (void) const { return MatrixType::Diagonal; }
   MatrixType matrix_type (const MatrixType&) const
-    { return matrix_type (); }
+  { return matrix_type (); }
 
   bool is_scalar_type (void) const { return true; }
 
   bool is_numeric_type (void) const { return true; }
 
   bool is_true (void) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
diff --git a/libinterp/octave-value/ov-base-sparse.cc b/libinterp/octave-value/ov-base-sparse.cc
--- a/libinterp/octave-value/ov-base-sparse.cc
+++ b/libinterp/octave-value/ov-base-sparse.cc
@@ -305,17 +305,17 @@ template <class T>
 void
 octave_base_sparse<T>::print_raw (std::ostream& os,
                                   bool pr_as_read_syntax) const
 {
   octave_idx_type nr = matrix.rows ();
   octave_idx_type nc = matrix.cols ();
   octave_idx_type nz = nnz ();
 
-  // FIXME -- this should probably all be handled by a
+  // FIXME: this should probably all be handled by a
   // separate octave_print_internal function that can handle format
   // compact, loose, etc.
 
   os << "Compressed Column Sparse (rows = " << nr
      << ", cols = " << nc
      << ", nnz = " << nz;
 
   // Avoid calling numel here since it can easily overflow
@@ -359,27 +359,26 @@ octave_base_sparse<T>::print_raw (std::o
   //  zero-based to one-based arrays
 
   if (nz != 0)
     {
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_quit ();
 
-          // FIXME -- is there an easy way to get the max row
+          // FIXME: is there an easy way to get the max row
           // and column indices so we can set the width appropriately
           // and line up the columns here?  Similarly, we should look
           // at all the nonzero values and display them with the same
           // formatting rules that apply to columns of a matrix.
 
           for (octave_idx_type i = matrix.cidx (j); i < matrix.cidx (j+1); i++)
             {
               os << "\n";
-              os << "  (" << matrix.ridx (i)+1 <<
-                ", "  << j+1 << ") -> ";
+              os << "  (" << matrix.ridx (i)+1 << ", "  << j+1 << ") -> ";
 
               octave_print_internal (os, matrix.data (i), pr_as_read_syntax);
             }
         }
     }
 }
 
 template <class T>
diff --git a/libinterp/octave-value/ov-base-sparse.h b/libinterp/octave-value/ov-base-sparse.h
--- a/libinterp/octave-value/ov-base-sparse.h
+++ b/libinterp/octave-value/ov-base-sparse.h
@@ -42,38 +42,38 @@ along with Octave; see the file COPYING.
 class tree_walker;
 
 class octave_sparse_bool_matrix;
 
 template <class T>
 class
 octave_base_sparse : public octave_base_value
 {
- public:
+public:
 
   octave_base_sparse (void)
     : octave_base_value (), matrix (), typ (MatrixType ())
   { }
 
-  octave_base_sparse (const T& a) : octave_base_value (), matrix (a),
-                                    typ (MatrixType ())
+  octave_base_sparse (const T& a)
+    : octave_base_value (), matrix (a), typ (MatrixType ())
   {
     if (matrix.ndims () == 0)
       matrix.resize (dim_vector (0, 0));
   }
 
-  octave_base_sparse (const T& a, const MatrixType& t) : octave_base_value (),
-                                matrix (a), typ (t)
+  octave_base_sparse (const T& a, const MatrixType& t)
+    : octave_base_value (), matrix (a), typ (t)
   {
     if (matrix.ndims () == 0)
       matrix.resize (dim_vector (0, 0));
   }
 
-  octave_base_sparse (const octave_base_sparse& a) :
-    octave_base_value (), matrix (a.matrix), typ (a.typ) { }
+  octave_base_sparse (const octave_base_sparse& a)
+    : octave_base_value (), matrix (a.matrix), typ (a.typ) { }
 
   ~octave_base_sparse (void) { }
 
   octave_idx_type numel (void) const { return dims ().safe_numel (); }
 
   octave_idx_type nnz (void) const { return matrix.nnz (); }
 
   octave_idx_type nzmax (void) const { return matrix.nzmax (); }
@@ -84,57 +84,57 @@ octave_base_sparse : public octave_base_
 
   octave_value full_value (void) const { return matrix.matrix_value (); }
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx);
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx, int)
-    { return subsref (type, idx); }
+  { return subsref (type, idx); }
 
   octave_value subsasgn (const std::string& type,
                          const std::list<octave_value_list>& idx,
                          const octave_value& rhs);
 
   void assign (const octave_value_list& idx, const T& rhs);
 
   void delete_elements (const octave_value_list& idx);
 
   dim_vector dims (void) const { return matrix.dims (); }
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false);
 
   octave_value reshape (const dim_vector& new_dims) const
-    { return T (matrix.reshape (new_dims)); }
+  { return T (matrix.reshape (new_dims)); }
 
   octave_value permute (const Array<int>& vec, bool inv = false) const
-    { return T (matrix.permute (vec, inv)); }
+  { return T (matrix.permute (vec, inv)); }
 
   octave_value resize (const dim_vector& dv, bool = false) const;
 
   octave_value all (int dim = 0) const { return matrix.all (dim); }
   octave_value any (int dim = 0) const { return matrix.any (dim); }
 
   octave_value diag (octave_idx_type k = 0) const
-    { return octave_value (matrix.diag (k)); }
+  { return octave_value (matrix.diag (k)); }
 
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
-    { return octave_value (matrix.sort (dim, mode)); }
+  { return octave_value (matrix.sort (dim, mode)); }
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
                      sortmode mode = ASCENDING) const
-    { return octave_value (matrix.sort (sidx, dim, mode)); }
+  { return octave_value (matrix.sort (sidx, dim, mode)); }
 
   sortmode is_sorted (sortmode mode = UNSORTED) const
-    { return full_value ().is_sorted (mode); }
+  { return full_value ().is_sorted (mode); }
 
   MatrixType matrix_type (void) const { return typ; }
   MatrixType matrix_type (const MatrixType& _typ) const
-    { MatrixType ret = typ; typ = _typ; return ret; }
+  { MatrixType ret = typ; typ = _typ; return ret; }
 
   bool is_matrix_type (void) const { return true; }
 
   bool is_numeric_type (void) const { return true; }
 
   bool is_sparse_type (void) const { return true; }
 
   bool is_defined (void) const { return true; }
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -403,17 +403,18 @@ octave_base_value::print (std::ostream&,
 
 void
 octave_base_value::print_raw (std::ostream&, bool) const
 {
   gripe_wrong_type_arg ("octave_base_value::print_raw ()", type_name ());
 }
 
 bool
-octave_base_value::print_name_tag (std::ostream& os, const std::string& name) const
+octave_base_value::print_name_tag (std::ostream& os,
+                                   const std::string& name) const
 {
   bool retval = false;
 
   indent (os);
 
   if (print_as_scalar ())
     os << name << " = ";
   else
@@ -541,17 +542,18 @@ octave_base_value::matrix_value (bool) c
   gripe_wrong_type_arg ("octave_base_value::matrix_value()", type_name ());
   return retval;
 }
 
 FloatMatrix
 octave_base_value::float_matrix_value (bool) const
 {
   FloatMatrix retval;
-  gripe_wrong_type_arg ("octave_base_value::float_matrix_value()", type_name ());
+  gripe_wrong_type_arg ("octave_base_value::float_matrix_value()",
+                        type_name ());
   return retval;
 }
 
 NDArray
 octave_base_value::array_value (bool) const
 {
   FloatNDArray retval;
   gripe_wrong_type_arg ("octave_base_value::array_value()", type_name ());
@@ -575,17 +577,18 @@ octave_base_value::complex_value (bool) 
   return retval;
 }
 
 FloatComplex
 octave_base_value::float_complex_value (bool) const
 {
   float tmp = lo_ieee_float_nan_value ();
   FloatComplex retval (tmp, tmp);
-  gripe_wrong_type_arg ("octave_base_value::float_complex_value()", type_name ());
+  gripe_wrong_type_arg ("octave_base_value::float_complex_value()",
+                        type_name ());
   return retval;
 }
 
 ComplexMatrix
 octave_base_value::complex_matrix_value (bool) const
 {
   ComplexMatrix retval;
   gripe_wrong_type_arg ("octave_base_value::complex_matrix_value()",
@@ -667,65 +670,71 @@ octave_base_value::char_array_value (boo
                         type_name ());
   return retval;
 }
 
 SparseMatrix
 octave_base_value::sparse_matrix_value (bool) const
 {
   SparseMatrix retval;
-  gripe_wrong_type_arg ("octave_base_value::sparse_matrix_value()", type_name ());
+  gripe_wrong_type_arg ("octave_base_value::sparse_matrix_value()",
+                        type_name ());
   return retval;
 }
 
 SparseComplexMatrix
 octave_base_value::sparse_complex_matrix_value (bool) const
 {
   SparseComplexMatrix retval;
-  gripe_wrong_type_arg ("octave_base_value::sparse_complex_matrix_value()", type_name ());
+  gripe_wrong_type_arg ("octave_base_value::sparse_complex_matrix_value()",
+                        type_name ());
   return retval;
 }
 
 SparseBoolMatrix
 octave_base_value::sparse_bool_matrix_value (bool) const
 {
   SparseBoolMatrix retval;
-  gripe_wrong_type_arg ("octave_base_value::sparse_bool_matrix_value()", type_name ());
+  gripe_wrong_type_arg ("octave_base_value::sparse_bool_matrix_value()",
+                        type_name ());
   return retval;
 }
 
 DiagMatrix
 octave_base_value::diag_matrix_value (bool) const
 {
   DiagMatrix retval;
   gripe_wrong_type_arg ("octave_base_value::diag_matrix_value()", type_name ());
   return retval;
 }
 
 FloatDiagMatrix
 octave_base_value::float_diag_matrix_value (bool) const
 {
   FloatDiagMatrix retval;
-  gripe_wrong_type_arg ("octave_base_value::float_diag_matrix_value()", type_name ());
+  gripe_wrong_type_arg ("octave_base_value::float_diag_matrix_value()",
+                        type_name ());
   return retval;
 }
 
 ComplexDiagMatrix
 octave_base_value::complex_diag_matrix_value (bool) const
 {
   ComplexDiagMatrix retval;
-  gripe_wrong_type_arg ("octave_base_value::complex_diag_matrix_value()", type_name ());
+  gripe_wrong_type_arg ("octave_base_value::complex_diag_matrix_value()",
+                        type_name ());
   return retval;
 }
 
 FloatComplexDiagMatrix
 octave_base_value::float_complex_diag_matrix_value (bool) const
 {
   FloatComplexDiagMatrix retval;
-  gripe_wrong_type_arg ("octave_base_value::float_complex_diag_matrix_value()", type_name ());
+  gripe_wrong_type_arg ("octave_base_value::float_complex_diag_matrix_value()",
+                        type_name ());
   return retval;
 }
 
 PermMatrix
 octave_base_value::perm_matrix_value (void) const
 {
   PermMatrix retval;
   gripe_wrong_type_arg ("octave_base_value::perm_matrix_value()", type_name ());
@@ -1172,79 +1181,79 @@ octave_base_value::is_sorted_rows (sortm
   return UNSORTED;
 }
 
 
 const char *
 octave_base_value::get_umap_name (unary_mapper_t umap)
 {
   static const char *names[num_unary_mappers] =
-    {
-      "abs",
-      "acos",
-      "acosh",
-      "angle",
-      "arg",
-      "asin",
-      "asinh",
-      "atan",
-      "atanh",
-      "cbrt",
-      "ceil",
-      "conj",
-      "cos",
-      "cosh",
-      "erf",
-      "erfinv",
-      "erfcinv",
-      "erfc",
-      "erfcx",
-      "erfi",
-      "dawson",
-      "exp",
-      "expm1",
-      "finite",
-      "fix",
-      "floor",
-      "gamma",
-      "imag",
-      "isinf",
-      "isna",
-      "isnan",
-      "lgamma",
-      "log",
-      "log2",
-      "log10",
-      "log1p",
-      "real",
-      "round",
-      "roundb",
-      "signum",
-      "sin",
-      "sinh",
-      "sqrt",
-      "tan",
-      "tanh",
-      "isalnum",
-      "isalpha",
-      "isascii",
-      "iscntrl",
-      "isdigit",
-      "isgraph",
-      "islower",
-      "isprint",
-      "ispunct",
-      "isspace",
-      "isupper",
-      "isxdigit",
-      "signbit",
-      "toascii",
-      "tolower",
-      "toupper"
-    };
+  {
+    "abs",
+    "acos",
+    "acosh",
+    "angle",
+    "arg",
+    "asin",
+    "asinh",
+    "atan",
+    "atanh",
+    "cbrt",
+    "ceil",
+    "conj",
+    "cos",
+    "cosh",
+    "erf",
+    "erfinv",
+    "erfcinv",
+    "erfc",
+    "erfcx",
+    "erfi",
+    "dawson",
+    "exp",
+    "expm1",
+    "finite",
+    "fix",
+    "floor",
+    "gamma",
+    "imag",
+    "isinf",
+    "isna",
+    "isnan",
+    "lgamma",
+    "log",
+    "log2",
+    "log10",
+    "log1p",
+    "real",
+    "round",
+    "roundb",
+    "signum",
+    "sin",
+    "sinh",
+    "sqrt",
+    "tan",
+    "tanh",
+    "isalnum",
+    "isalpha",
+    "isascii",
+    "iscntrl",
+    "isdigit",
+    "isgraph",
+    "islower",
+    "isprint",
+    "ispunct",
+    "isspace",
+    "isupper",
+    "isxdigit",
+    "signbit",
+    "toascii",
+    "tolower",
+    "toupper"
+  };
 
   if (umap < 0 || umap >= num_unary_mappers)
     return "unknown";
   else
     return names[umap];
 }
 
 octave_value
@@ -1371,17 +1380,18 @@ octave_base_value::numeric_assign (const
             = rhs.numeric_conversion_function ();
 
           octave_base_value::type_conv_info cf_this
             = numeric_conversion_function ();
 
           // Try biased (one-sided) conversions first.
           if (cf_rhs.type_id () >= 0
               && (octave_value_typeinfo::lookup_assign_op (octave_value::op_asn_eq,
-                                                           t_lhs, cf_rhs.type_id ())
+                                                           t_lhs,
+                                                           cf_rhs.type_id ())
                   || octave_value_typeinfo::lookup_pref_assign_conv (t_lhs,
                                                                      cf_rhs.type_id ()) >= 0))
             cf_this = 0;
           else if (cf_this.type_id () >= 0
                    && (octave_value_typeinfo::lookup_assign_op (octave_value::op_asn_eq,
                                                                 cf_this.type_id (), t_rhs)
                        || octave_value_typeinfo::lookup_pref_assign_conv (cf_this.type_id (),
                                                                           t_rhs) >= 0))
@@ -1422,17 +1432,18 @@ octave_base_value::numeric_assign (const
 
           if (cf_this || cf_rhs)
             {
               retval = tmp_lhs.subsasgn (type, idx, tmp_rhs);
 
               done = (! error_state);
             }
           else
-            gripe_no_conversion (octave_value::assign_op_as_string (octave_value::op_asn_eq),
+            gripe_no_conversion (octave_value::assign_op_as_string
+                                   (octave_value::op_asn_eq),
                                  type_name (), rhs.type_name ());
         }
     }
 
   // The assignment may have converted to a type that is wider than
   // necessary.
 
   retval.maybe_mutate ();
@@ -1452,17 +1463,17 @@ bool octave_base_value::beginning_of_lin
 
 void
 octave_base_value::indent (std::ostream& os) const
 {
   assert (curr_print_indent_level >= 0);
 
   if (beginning_of_line)
     {
-      // FIXME -- do we need this?
+      // FIXME: do we need this?
       // os << prefix;
 
       for (int i = 0; i < curr_print_indent_level; i++)
         os << " ";
 
       beginning_of_line = false;
     }
 }
@@ -1526,29 +1537,32 @@ CONVDECLX (cell_conv)
 }
 
 void
 install_base_type_conversions (void)
 {
   INSTALL_ASSIGNCONV (octave_base_value, octave_scalar, octave_matrix);
   INSTALL_ASSIGNCONV (octave_base_value, octave_matrix, octave_matrix);
   INSTALL_ASSIGNCONV (octave_base_value, octave_complex, octave_complex_matrix);
-  INSTALL_ASSIGNCONV (octave_base_value, octave_complex_matrix, octave_complex_matrix);
+  INSTALL_ASSIGNCONV (octave_base_value, octave_complex_matrix,
+                      octave_complex_matrix);
   INSTALL_ASSIGNCONV (octave_base_value, octave_range, octave_matrix);
-  INSTALL_ASSIGNCONV (octave_base_value, octave_char_matrix_str, octave_char_matrix_str);
+  INSTALL_ASSIGNCONV (octave_base_value, octave_char_matrix_str,
+                      octave_char_matrix_str);
   INSTALL_ASSIGNCONV (octave_base_value, octave_cell, octave_cell);
 
   INSTALL_WIDENOP (octave_base_value, octave_matrix, matrix_conv);
-  INSTALL_WIDENOP (octave_base_value, octave_complex_matrix, complex_matrix_conv);
+  INSTALL_WIDENOP (octave_base_value, octave_complex_matrix,
+                   complex_matrix_conv);
   INSTALL_WIDENOP (octave_base_value, octave_char_matrix_str, string_conv);
   INSTALL_WIDENOP (octave_base_value, octave_cell, cell_conv);
 }
 
 DEFUN (sparse_auto_mutate, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} sparse_auto_mutate ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} sparse_auto_mutate (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} sparse_auto_mutate (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will\n\
 automatically mutate sparse matrices to full matrices to save memory.\n\
 For example:\n\
 \n\
 @example\n\
diff --git a/libinterp/octave-value/ov-base.h b/libinterp/octave-value/ov-base.h
--- a/libinterp/octave-value/ov-base.h
+++ b/libinterp/octave-value/ov-base.h
@@ -92,17 +92,17 @@ inline bool btyp_isinteger (builtin_type
 { return btyp >= btyp_int8 && btyp <= btyp_uint64; }
 
 inline bool btyp_isfloat (builtin_type_t btyp)
 { return btyp <= btyp_float_complex; }
 
 inline bool btyp_isarray (builtin_type_t btyp)
 { return btyp <= btyp_char; }
 
-// Compute a numeric type for a possibly mixed-type operation, using these rules:
+// Compute numeric type for a possible mixed-type operation, using these rules:
 // bool -> double
 // single + double -> single
 // real + complex -> complex
 // integer + real -> integer
 // uint + uint -> uint (the bigger one)
 // sint + sint -> sint (the bigger one)
 //
 // failing otherwise.
@@ -183,22 +183,23 @@ octave_base_value
 public:
 
   typedef octave_base_value * (*type_conv_fcn) (const octave_base_value&);
 
   // type conversion, including result type information
   class type_conv_info
   {
   public:
-    type_conv_info (type_conv_fcn f = 0, int t = -1) : _fcn (f), _type_id (t) { }
+    type_conv_info (type_conv_fcn f = 0, int t = -1)
+      : _fcn (f), _type_id (t) { }
 
     operator type_conv_fcn (void) const { return _fcn; }
 
     octave_base_value * operator () (const octave_base_value &v) const
-      { return (*_fcn) (v); }
+    { return (*_fcn) (v); }
 
     int type_id (void) const { return _type_id; }
 
   private:
     type_conv_fcn _fcn;
     int _type_id;
   };
 
@@ -221,21 +222,21 @@ public:
   // Unique clone. Usually clones, but may be overriden to fake the
   // cloning when sharing copies is to be controlled from within an
   // instance (see octave_class).
   virtual octave_base_value *
   unique_clone (void) { return clone (); }
 
   virtual type_conv_info
   numeric_conversion_function (void) const
-    { return type_conv_info (); }
+  { return type_conv_info (); }
 
   virtual type_conv_info
   numeric_demotion_function (void) const
-    { return type_conv_info (); }
+  { return type_conv_info (); }
 
   virtual octave_value squeeze (void) const;
 
   virtual octave_value full_value (void) const;
 
   virtual octave_base_value *try_narrowing_conversion (void) { return 0; }
 
   virtual void maybe_economize (void) { }
@@ -286,31 +287,31 @@ public:
                   const std::list<octave_value_list>& idx,
                   const octave_value& rhs);
 
   virtual idx_vector index_vector (void) const;
 
   virtual dim_vector dims (void) const { return dim_vector (); }
 
   octave_idx_type rows (void) const
-    {
-      const dim_vector dv = dims ();
+  {
+    const dim_vector dv = dims ();
 
-      return dv(0);
-    }
+    return dv(0);
+  }
 
   octave_idx_type columns (void) const
-    {
-      const dim_vector dv = dims ();
+  {
+    const dim_vector dv = dims ();
 
-      return dv(1);
-    }
+    return dv(1);
+  }
 
   virtual int ndims (void) const
-    { return dims ().length (); }
+  { return dims ().length (); }
 
   virtual octave_idx_type numel (void) const { return dims ().numel (); }
 
   virtual octave_idx_type capacity (void) const { return numel (); }
 
   virtual size_t byte_size (void) const { return 0; }
 
   virtual octave_idx_type nnz (void) const;
@@ -465,20 +466,20 @@ public:
 
   virtual uint64_t uint64_value (bool = false, bool = false) const;
 
   virtual double double_value (bool = false) const;
 
   virtual float float_value (bool = false) const;
 
   virtual double scalar_value (bool frc_str_conv = false) const
-    { return double_value (frc_str_conv); }
+  { return double_value (frc_str_conv); }
 
   virtual float float_scalar_value (bool frc_str_conv = false) const
-    { return float_value (frc_str_conv); }
+  { return float_value (frc_str_conv); }
 
   virtual Cell cell_value (void) const;
 
   virtual Matrix matrix_value (bool = false) const;
 
   virtual FloatMatrix float_matrix_value (bool = false) const;
 
   virtual NDArray array_value (bool = false) const;
@@ -514,17 +515,18 @@ public:
   virtual SparseBoolMatrix sparse_bool_matrix_value (bool = false) const;
 
   virtual DiagMatrix diag_matrix_value (bool = false) const;
 
   virtual FloatDiagMatrix float_diag_matrix_value (bool = false) const;
 
   virtual ComplexDiagMatrix complex_diag_matrix_value (bool = false) const;
 
-  virtual FloatComplexDiagMatrix float_complex_diag_matrix_value (bool = false) const;
+  virtual FloatComplexDiagMatrix
+  float_complex_diag_matrix_value (bool = false) const;
 
   virtual PermMatrix perm_matrix_value (void) const;
 
   virtual octave_int8 int8_scalar_value (void) const;
 
   virtual octave_int16 int16_scalar_value (void) const;
 
   virtual octave_int32 int32_scalar_value (void) const;
@@ -571,20 +573,20 @@ public:
 
   virtual size_t nparents (void) const;
 
   virtual std::list<std::string> parent_class_name_list (void) const;
 
   virtual string_vector parent_class_names (void) const;
 
   virtual octave_base_value *find_parent_class (const std::string&)
-    { return 0; }
+  { return 0; }
 
   virtual octave_base_value *unique_parent_class (const std::string&)
-    { return 0; }
+  { return 0; }
 
   virtual octave_function *function_value (bool silent = false);
 
   virtual octave_user_function *user_function_value (bool silent = false);
 
   virtual octave_user_script *user_script_value (bool silent = false);
 
   virtual octave_user_code *user_code_value (bool silent = false);
@@ -672,81 +674,81 @@ public:
   virtual void unlock (void);
 
   virtual bool islocked (void) const { return false; }
 
   virtual void dump (std::ostream& os) const;
 
   // Standard mappers. Register new ones here.
   enum unary_mapper_t
-    {
-      umap_abs,
-      umap_acos,
-      umap_acosh,
-      umap_angle,
-      umap_arg,
-      umap_asin,
-      umap_asinh,
-      umap_atan,
-      umap_atanh,
-      umap_cbrt,
-      umap_ceil,
-      umap_conj,
-      umap_cos,
-      umap_cosh,
-      umap_erf,
-      umap_erfinv,
-      umap_erfcinv,
-      umap_erfc,
-      umap_erfcx,
-      umap_erfi,
-      umap_dawson,
-      umap_exp,
-      umap_expm1,
-      umap_finite,
-      umap_fix,
-      umap_floor,
-      umap_gamma,
-      umap_imag,
-      umap_isinf,
-      umap_isna,
-      umap_isnan,
-      umap_lgamma,
-      umap_log,
-      umap_log2,
-      umap_log10,
-      umap_log1p,
-      umap_real,
-      umap_round,
-      umap_roundb,
-      umap_signum,
-      umap_sin,
-      umap_sinh,
-      umap_sqrt,
-      umap_tan,
-      umap_tanh,
-      umap_xisalnum,
-      umap_xisalpha,
-      umap_xisascii,
-      umap_xiscntrl,
-      umap_xisdigit,
-      umap_xisgraph,
-      umap_xislower,
-      umap_xisprint,
-      umap_xispunct,
-      umap_xisspace,
-      umap_xisupper,
-      umap_xisxdigit,
-      umap_xsignbit,
-      umap_xtoascii,
-      umap_xtolower,
-      umap_xtoupper,
-      umap_unknown,
-      num_unary_mappers = umap_unknown
-    };
+  {
+    umap_abs,
+    umap_acos,
+    umap_acosh,
+    umap_angle,
+    umap_arg,
+    umap_asin,
+    umap_asinh,
+    umap_atan,
+    umap_atanh,
+    umap_cbrt,
+    umap_ceil,
+    umap_conj,
+    umap_cos,
+    umap_cosh,
+    umap_erf,
+    umap_erfinv,
+    umap_erfcinv,
+    umap_erfc,
+    umap_erfcx,
+    umap_erfi,
+    umap_dawson,
+    umap_exp,
+    umap_expm1,
+    umap_finite,
+    umap_fix,
+    umap_floor,
+    umap_gamma,
+    umap_imag,
+    umap_isinf,
+    umap_isna,
+    umap_isnan,
+    umap_lgamma,
+    umap_log,
+    umap_log2,
+    umap_log10,
+    umap_log1p,
+    umap_real,
+    umap_round,
+    umap_roundb,
+    umap_signum,
+    umap_sin,
+    umap_sinh,
+    umap_sqrt,
+    umap_tan,
+    umap_tanh,
+    umap_xisalnum,
+    umap_xisalpha,
+    umap_xisascii,
+    umap_xiscntrl,
+    umap_xisdigit,
+    umap_xisgraph,
+    umap_xislower,
+    umap_xisprint,
+    umap_xispunct,
+    umap_xisspace,
+    umap_xisupper,
+    umap_xisxdigit,
+    umap_xsignbit,
+    umap_xtoascii,
+    umap_xtolower,
+    umap_xtoupper,
+    umap_unknown,
+    num_unary_mappers = umap_unknown
+  };
 
   virtual octave_value map (unary_mapper_t) const;
 
   // These are fast indexing & assignment shortcuts for extracting
   // or inserting a single scalar from/to an array.
 
   // Extract the n-th element, aka val(n). Result is undefined if val is not an
   // array type or n is out of range. Never error.
@@ -784,26 +786,26 @@ protected:
 
   // This should only be called for derived types.
 
   octave_value numeric_assign (const std::string& type,
                                const std::list<octave_value_list>& idx,
                                const octave_value& rhs);
 
   void reset_indent_level (void) const
-    { curr_print_indent_level = 0; }
+  { curr_print_indent_level = 0; }
 
   void increment_indent_level (void) const
-    { curr_print_indent_level += 2; }
+  { curr_print_indent_level += 2; }
 
   void decrement_indent_level (void) const
-    { curr_print_indent_level -= 2; }
+  { curr_print_indent_level -= 2; }
 
   int current_print_indent_level (void) const
-    { return curr_print_indent_level; }
+  { return curr_print_indent_level; }
 
   void indent (std::ostream& os) const;
 
   void newline (std::ostream& os) const;
 
   void reset (void) const;
 
   // A reference count.
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -505,23 +505,24 @@ octave_bool_matrix::load_hdf5 (hid_t loc
     {
       dv.resize (rank);
       for (hsize_t i = 0, j = rank - 1; i < rank; i++, j--)
         dv(j) = hdims[i];
     }
 
   octave_idx_type nel = dv.numel ();
   OCTAVE_LOCAL_BUFFER (hbool_t, htmp, nel);
-  if (H5Dread (data_hid, H5T_NATIVE_HBOOL, H5S_ALL, H5S_ALL, H5P_DEFAULT, htmp) >= 0)
+  if (H5Dread (data_hid, H5T_NATIVE_HBOOL, H5S_ALL, H5S_ALL, H5P_DEFAULT, htmp)
+      >= 0)
     {
       retval = true;
 
       boolNDArray btmp (dv);
       for (octave_idx_type i = 0; i < nel; i++)
-          btmp.elem (i) = htmp[i];
+        btmp.elem (i) = htmp[i];
 
       matrix = btmp;
     }
 
   H5Dclose (data_hid);
 
   return retval;
 }
@@ -541,17 +542,17 @@ octave_bool_matrix::as_mxArray (void) co
 
   for (mwIndex i = 0; i < nel; i++)
     pr[i] = p[i];
 
   return retval;
 }
 
 DEFUN (logical, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} logical (@var{x})\n\
 Convert @var{x} to logical type.\n\
 @seealso{double, single, char}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
diff --git a/libinterp/octave-value/ov-bool-mat.h b/libinterp/octave-value/ov-bool-mat.h
--- a/libinterp/octave-value/ov-bool-mat.h
+++ b/libinterp/octave-value/ov-bool-mat.h
@@ -64,34 +64,37 @@ public:
   octave_bool_matrix (const boolMatrix& bm)
     : octave_base_matrix<boolNDArray> (bm) { }
 
   octave_bool_matrix (const boolMatrix& bm, const MatrixType& t)
     : octave_base_matrix<boolNDArray> (bm, t) { }
 
   octave_bool_matrix (const boolNDArray& bm, const idx_vector& cache)
     : octave_base_matrix<boolNDArray> (bm)
-    {
-      set_idx_cache (cache);
-    }
+  {
+    set_idx_cache (cache);
+  }
 
   octave_bool_matrix (const octave_bool_matrix& bm)
     : octave_base_matrix<boolNDArray> (bm) { }
 
   ~octave_bool_matrix (void) { }
 
-  octave_base_value *clone (void) const { return new octave_bool_matrix (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_bool_matrix (); }
+  octave_base_value *clone (void) const
+  { return new octave_bool_matrix (*this); }
+
+  octave_base_value *empty_clone (void) const
+  { return new octave_bool_matrix (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
   octave_base_value *try_narrowing_conversion (void);
 
   idx_vector index_vector (void) const
-    { return idx_cache ? *idx_cache : set_idx_cache (idx_vector (matrix)); }
+  { return idx_cache ? *idx_cache : set_idx_cache (idx_vector (matrix)); }
 
   builtin_type_t builtin_type (void) const { return btyp_bool; }
 
   bool is_bool_matrix (void) const { return true; }
 
   bool is_bool_type (void) const { return true; }
 
   bool is_real_type (void) const { return true; }
@@ -122,64 +125,64 @@ public:
   uint64NDArray
   uint64_array_value (void) const { return uint64NDArray (matrix); }
 
   double double_value (bool = false) const;
 
   float float_value (bool = false) const;
 
   double scalar_value (bool frc_str_conv = false) const
-    { return double_value (frc_str_conv); }
+  { return double_value (frc_str_conv); }
 
   Matrix matrix_value (bool = false) const
-    { return Matrix (matrix.matrix_value ()); }
+  { return Matrix (matrix.matrix_value ()); }
 
   FloatMatrix float_matrix_value (bool = false) const
-    { return FloatMatrix (matrix.matrix_value ()); }
+  { return FloatMatrix (matrix.matrix_value ()); }
 
   NDArray array_value (bool = false) const
-    { return NDArray (matrix); }
+  { return NDArray (matrix); }
 
   FloatNDArray float_array_value (bool = false) const
-    { return FloatNDArray (matrix); }
+  { return FloatNDArray (matrix); }
 
   Complex complex_value (bool = false) const;
 
   FloatComplex float_complex_value (bool = false) const;
 
   ComplexMatrix complex_matrix_value (bool = false) const
-    { return ComplexMatrix (matrix.matrix_value ( )); }
+  { return ComplexMatrix (matrix.matrix_value ( )); }
 
   FloatComplexMatrix float_complex_matrix_value (bool = false) const
-    { return FloatComplexMatrix (matrix.matrix_value ( )); }
+  { return FloatComplexMatrix (matrix.matrix_value ( )); }
 
   ComplexNDArray complex_array_value (bool = false) const
-    { return ComplexNDArray (matrix); }
+  { return ComplexNDArray (matrix); }
 
   FloatComplexNDArray float_complex_array_value (bool = false) const
-    { return FloatComplexNDArray (matrix); }
+  { return FloatComplexNDArray (matrix); }
 
   charNDArray
   char_array_value (bool = false) const
   {
     charNDArray retval (dims ());
 
     octave_idx_type nel = numel ();
 
     for (octave_idx_type i = 0; i < nel; i++)
       retval(i) = static_cast<char>(matrix(i));
 
     return retval;
   }
 
   boolMatrix bool_matrix_value (bool = false) const
-    { return matrix.matrix_value (); }
+  { return matrix.matrix_value (); }
 
   boolNDArray bool_array_value (bool = false) const
-    { return matrix; }
+  { return matrix; }
 
   SparseMatrix sparse_matrix_value (bool = false) const
   { return SparseMatrix (Matrix (matrix.matrix_value ())); }
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const
   { return SparseComplexMatrix (ComplexMatrix (matrix.matrix_value ())); }
 
   SparseBoolMatrix sparse_bool_matrix_value (bool = false) const
@@ -205,30 +208,30 @@ public:
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
-    { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
+  { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return matrix.mex_get_data (); }
 
   mxArray *as_mxArray (void) const;
 
   // Mapper functions are converted to double for treatment
   octave_value map (unary_mapper_t umap) const
-    {
-      octave_matrix m (array_value ());
-      return m.map (umap);
-    }
+  {
+    octave_matrix m (array_value ());
+    return m.map (umap);
+  }
 
 protected:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
diff --git a/libinterp/octave-value/ov-bool-sparse.cc b/libinterp/octave-value/ov-bool-sparse.cc
--- a/libinterp/octave-value/ov-bool-sparse.cc
+++ b/libinterp/octave-value/ov-bool-sparse.cc
@@ -46,24 +46,26 @@ along with Octave; see the file COPYING.
 
 #include "ov-base-sparse.h"
 #include "ov-base-sparse.cc"
 
 template class OCTINTERP_API octave_base_sparse<SparseBoolMatrix>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_sparse_bool_matrix);
 
-DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_sparse_bool_matrix, "sparse bool matrix", "logical");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_sparse_bool_matrix,
+                                     "sparse bool matrix", "logical");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
   CAST_CONV_ARG (const octave_sparse_bool_matrix&);
 
-  return new octave_sparse_matrix (SparseMatrix (v.sparse_bool_matrix_value ()));
+  return
+    new octave_sparse_matrix (SparseMatrix (v.sparse_bool_matrix_value ()));
 }
 
 octave_base_value::type_conv_info
 octave_sparse_bool_matrix::numeric_conversion_function (void) const
 {
   return octave_base_value::type_conv_info (default_numeric_conversion_function,
                                             octave_sparse_matrix::static_type_id ());
 }
@@ -267,20 +269,21 @@ octave_sparse_bool_matrix::load_binary (
 {
   int32_t nz, nc, nr, tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
 
   if (swap)
     swap_bytes<4> (&tmp);
 
-  if (tmp != -2) {
-    error ("load: only 2-D sparse matrices are supported");
-    return false;
-  }
+  if (tmp != -2)
+    {
+      error ("load: only 2-D sparse matrices are supported");
+      return false;
+    }
 
   if (! is.read (reinterpret_cast<char *> (&nr), 4))
     return false;
   if (! is.read (reinterpret_cast<char *> (&nc), 4))
     return false;
   if (! is.read (reinterpret_cast<char *> (&nz), 4))
     return false;
 
@@ -342,17 +345,18 @@ octave_sparse_bool_matrix::save_hdf5 (hi
   dim_vector dv = dims ();
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 #if HAVE_HDF5_18
-  hid_t group_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+  hid_t group_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT,
+                               H5P_DEFAULT);
 #else
   hid_t group_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (group_hid < 0)
     return false;
 
   hid_t space_hid = -1, data_hid = -1;
   bool retval = true;
@@ -376,17 +380,18 @@ octave_sparse_bool_matrix::save_hdf5 (hi
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   tmp = m.rows ();
-  retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, &tmp) >= 0;
+  retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL,
+                     H5S_ALL, H5P_DEFAULT, &tmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
@@ -574,17 +579,18 @@ octave_sparse_bool_matrix::load_hdf5 (hi
 
   if (rank != 0)
     {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nr) < 0)
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nr)
+      < 0)
     {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
@@ -598,17 +604,18 @@ octave_sparse_bool_matrix::load_hdf5 (hi
 
   if (rank != 0)
     {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nc) < 0)
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nc)
+      < 0)
     {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
@@ -622,17 +629,18 @@ octave_sparse_bool_matrix::load_hdf5 (hi
 
   if (rank != 0)
     {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nz) < 0)
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nz)
+      < 0)
     {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
@@ -666,17 +674,18 @@ octave_sparse_bool_matrix::load_hdf5 (hi
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   octave_idx_type *itmp = m.xcidx ();
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, itmp) < 0)
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, itmp)
+      < 0)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
diff --git a/libinterp/octave-value/ov-bool-sparse.h b/libinterp/octave-value/ov-bool-sparse.h
--- a/libinterp/octave-value/ov-bool-sparse.h
+++ b/libinterp/octave-value/ov-bool-sparse.h
@@ -71,41 +71,43 @@ public:
   octave_sparse_bool_matrix (const Sparse<bool>& a)
     : octave_base_sparse<SparseBoolMatrix> (a) { }
 
   octave_sparse_bool_matrix (const octave_sparse_bool_matrix& bm)
     : octave_base_sparse<SparseBoolMatrix> (bm) { }
 
   ~octave_sparse_bool_matrix (void) { }
 
-  octave_base_value *clone (void) const { return new octave_sparse_bool_matrix (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_sparse_bool_matrix (); }
+  octave_base_value *clone (void) const
+  { return new octave_sparse_bool_matrix (*this); }
+  octave_base_value *empty_clone (void) const
+  { return new octave_sparse_bool_matrix (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
   octave_base_value *try_narrowing_conversion (void);
 
   // FIXME Adapt idx_vector to allow sparse logical indexing without overflow!!
   idx_vector index_vector (void) const
-    { return idx_vector (matrix); }
+  { return idx_vector (matrix); }
 
   builtin_type_t builtin_type (void) const { return btyp_bool; }
 
   bool is_bool_matrix (void) const { return true; }
 
   bool is_bool_type (void) const { return true; }
 
   bool is_real_type (void) const { return true; }
 
   bool is_numeric_type (void) const { return false; }
 
   double double_value (bool = false) const;
 
   double scalar_value (bool frc_str_conv = false) const
-    { return double_value (frc_str_conv); }
+  { return double_value (frc_str_conv); }
 
   Matrix matrix_value (bool = false) const;
 
   NDArray array_value (bool = false) const;
 
   Complex complex_value (bool = false) const;
 
   ComplexMatrix complex_matrix_value (bool = false) const;
@@ -118,17 +120,17 @@ public:
 
   boolNDArray bool_array_value (bool = false) const;
 
   SparseMatrix sparse_matrix_value (bool = false) const;
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const;
 
   SparseBoolMatrix sparse_bool_matrix_value (bool = false) const
-    { return matrix; }
+  { return matrix; }
 
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
@@ -137,20 +139,20 @@ public:
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   mxArray *as_mxArray (void) const;
 
   // Mapper functions are converted to double for treatment
   octave_value map (unary_mapper_t umap) const
-    {
-      octave_sparse_matrix m (sparse_matrix_value ());
-      return m.map (umap);
-    }
+  {
+    octave_sparse_matrix m (sparse_matrix_value ());
+    return m.map (umap);
+  }
 
 protected:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
diff --git a/libinterp/octave-value/ov-bool.cc b/libinterp/octave-value/ov-bool.cc
--- a/libinterp/octave-value/ov-bool.cc
+++ b/libinterp/octave-value/ov-bool.cc
@@ -64,23 +64,23 @@ octave_bool::numeric_conversion_function
   return octave_base_value::type_conv_info (default_numeric_conversion_function,
                                             octave_scalar::static_type_id ());
 
 }
 
 octave_value
 octave_bool::do_index_op (const octave_value_list& idx, bool resize_ok)
 {
-  // FIXME -- this doesn't solve the problem of
+  // FIXME: this doesn't solve the problem of
   //
   //   a = 1; a([1,1], [1,1], [1,1])
   //
   // and similar constructions.  Hmm...
 
-  // FIXME -- using this constructor avoids narrowing the
+  // FIXME: using this constructor avoids narrowing the
   // 1x1 matrix back to a scalar value.  Need a better solution
   // to this problem.
 
   octave_value tmp (new octave_bool_matrix (bool_matrix_value ()));
 
   return tmp.do_index_op (idx, resize_ok);
 }
 
diff --git a/libinterp/octave-value/ov-bool.h b/libinterp/octave-value/ov-bool.h
--- a/libinterp/octave-value/ov-bool.h
+++ b/libinterp/octave-value/ov-bool.h
@@ -59,17 +59,18 @@ public:
     : octave_base_scalar<bool> (b) { }
 
   octave_bool (const octave_bool& s)
     : octave_base_scalar<bool> (s) { }
 
   ~octave_bool (void) { }
 
   octave_base_value *clone (void) const { return new octave_bool (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_bool_matrix (); }
+  octave_base_value *empty_clone (void) const
+  { return new octave_bool_matrix (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false);
 
   idx_vector index_vector (void) const { return idx_vector (scalar); }
 
@@ -84,45 +85,45 @@ public:
   bool is_real_type (void) const { return true; }
 
   bool is_numeric_type (void) const { return false; }
 
   bool is_true (void) const { return scalar; }
 
   int8NDArray
   int8_array_value (void) const
-    { return int8NDArray (dim_vector (1, 1), scalar); }
+  { return int8NDArray (dim_vector (1, 1), scalar); }
 
   int16NDArray
   int16_array_value (void) const
-    { return int16NDArray (dim_vector (1, 1), scalar); }
+  { return int16NDArray (dim_vector (1, 1), scalar); }
 
   int32NDArray
   int32_array_value (void) const
-    { return int32NDArray (dim_vector (1, 1), scalar); }
+  { return int32NDArray (dim_vector (1, 1), scalar); }
 
   int64NDArray
   int64_array_value (void) const
-    { return int64NDArray (dim_vector (1, 1), scalar); }
+  { return int64NDArray (dim_vector (1, 1), scalar); }
 
   uint8NDArray
   uint8_array_value (void) const
-    { return uint8NDArray (dim_vector (1, 1), scalar); }
+  { return uint8NDArray (dim_vector (1, 1), scalar); }
 
   uint16NDArray
   uint16_array_value (void) const
-    { return uint16NDArray (dim_vector (1, 1), scalar); }
+  { return uint16NDArray (dim_vector (1, 1), scalar); }
 
   uint32NDArray
   uint32_array_value (void) const
-    { return uint32NDArray (dim_vector (1, 1), scalar); }
+  { return uint32NDArray (dim_vector (1, 1), scalar); }
 
   uint64NDArray
   uint64_array_value (void) const
-    { return uint64NDArray (dim_vector (1, 1), scalar); }
+  { return uint64NDArray (dim_vector (1, 1), scalar); }
 
   octave_int8
   int8_scalar_value (void) const { return octave_int8 (scalar); }
 
   octave_int16
   int16_scalar_value (void) const { return octave_int16 (scalar); }
 
   octave_int32
@@ -147,68 +148,68 @@ public:
 
   float float_value (bool = false) const { return scalar; }
 
   double scalar_value (bool = false) const { return scalar; }
 
   float float_scalar_value (bool = false) const { return scalar; }
 
   Matrix matrix_value (bool = false) const
-    { return Matrix (1, 1, scalar); }
+  { return Matrix (1, 1, scalar); }
 
   FloatMatrix float_matrix_value (bool = false) const
-    { return FloatMatrix (1, 1, scalar); }
+  { return FloatMatrix (1, 1, scalar); }
 
   NDArray array_value (bool = false) const
-    { return NDArray (dim_vector (1, 1), static_cast<double> (scalar)); }
+  { return NDArray (dim_vector (1, 1), static_cast<double> (scalar)); }
 
   FloatNDArray float_array_value (bool = false) const
-    { return FloatNDArray (dim_vector (1, 1), static_cast<double> (scalar)); }
+  { return FloatNDArray (dim_vector (1, 1), static_cast<double> (scalar)); }
 
   Complex complex_value (bool = false) const { return scalar; }
 
   FloatComplex float_complex_value (bool = false) const { return scalar; }
 
   ComplexMatrix complex_matrix_value (bool = false) const
-    { return ComplexMatrix (1, 1, Complex (scalar)); }
+  { return ComplexMatrix (1, 1, Complex (scalar)); }
 
   FloatComplexMatrix float_complex_matrix_value (bool = false) const
-    { return FloatComplexMatrix (1, 1, FloatComplex (scalar)); }
+  { return FloatComplexMatrix (1, 1, FloatComplex (scalar)); }
 
   ComplexNDArray complex_array_value (bool = false) const
-    { return ComplexNDArray (dim_vector (1, 1), Complex (scalar)); }
+  { return ComplexNDArray (dim_vector (1, 1), Complex (scalar)); }
 
   FloatComplexNDArray float_complex_array_value (bool = false) const
-    { return FloatComplexNDArray (dim_vector (1, 1), FloatComplex (scalar)); }
+  { return FloatComplexNDArray (dim_vector (1, 1), FloatComplex (scalar)); }
 
   SparseMatrix sparse_matrix_value (bool = false) const
-    { return SparseMatrix (Matrix (1, 1, scalar)); }
+  { return SparseMatrix (Matrix (1, 1, scalar)); }
 
   // FIXME Need SparseComplexMatrix (Matrix) constructor!!!
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const
-    { return SparseComplexMatrix (sparse_matrix_value ()); }
+  { return SparseComplexMatrix (sparse_matrix_value ()); }
 
   SparseBoolMatrix sparse_bool_matrix_value (bool = false) const
-    { return SparseBoolMatrix (boolMatrix (1, 1, scalar)); }
+  { return SparseBoolMatrix (boolMatrix (1, 1, scalar)); }
 
   charNDArray
   char_array_value (bool = false) const
   {
     charNDArray retval (dim_vector (1, 1));
     retval(0) = static_cast<char> (scalar);
     return retval;
   }
 
   bool bool_value (bool = false) const { return scalar; }
 
   boolMatrix bool_matrix_value (bool = false) const
-    { return boolMatrix (1, 1, scalar); }
+  { return boolMatrix (1, 1, scalar); }
 
   boolNDArray bool_array_value (bool = false) const
-    { return boolNDArray (dim_vector (1, 1), scalar); }
+  { return boolNDArray (dim_vector (1, 1), scalar); }
 
   octave_value resize (const dim_vector& dv, bool fill = false) const;
 
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
@@ -222,29 +223,29 @@ public:
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
-    {
-      return os.write (bool_array_value (), block_size, output_type,
-                       skip, flt_fmt);
-    }
+  {
+    return os.write (bool_array_value (), block_size, output_type,
+                     skip, flt_fmt);
+  }
 
   mxArray *as_mxArray (void) const;
 
   // Mapper functions are converted to double for treatment
   octave_value map (unary_mapper_t umap) const
-    {
-      octave_scalar m (scalar_value ());
-      return m.map (umap);
-    }
+  {
+    octave_scalar m (scalar_value ());
+    return m.map (umap);
+  }
 
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
diff --git a/libinterp/octave-value/ov-builtin.cc b/libinterp/octave-value/ov-builtin.cc
--- a/libinterp/octave-value/ov-builtin.cc
+++ b/libinterp/octave-value/ov-builtin.cc
@@ -45,17 +45,18 @@ octave_builtin::subsref (const std::stri
                          int nargout)
 {
   return octave_builtin::subsref (type, idx, nargout, 0);
 }
 
 octave_value_list
 octave_builtin::subsref (const std::string& type,
                          const std::list<octave_value_list>& idx,
-                         int nargout, const std::list<octave_lvalue>* lvalue_list)
+                         int nargout,
+                         const std::list<octave_lvalue>* lvalue_list)
 {
   octave_value_list retval;
 
   switch (type[0])
     {
     case '(':
       {
         int tmp_nargout = (type.length () > 1 && nargout == 0) ? 1 : nargout;
@@ -72,21 +73,21 @@ octave_builtin::subsref (const std::stri
         error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
       }
       break;
 
     default:
       panic_impossible ();
     }
 
-  // FIXME -- perhaps there should be an
+  // FIXME: perhaps there should be an
   // octave_value_list::next_subsref member function?  See also
   // octave_user_function::subsref.
   //
-  // FIXME -- Note that if a function call returns multiple
+  // FIXME: Note that if a function call returns multiple
   // values, and there is further indexing to perform, then we are
   // ignoring all but the first value.  Is this really what we want to
   // do?  If it is not, then what should happen for stat("file").size,
   // for exmaple?
 
   if (idx.size () > 1)
     retval = retval(0).next_subsref (nargout, type, idx);
 
@@ -125,17 +126,17 @@ octave_builtin::do_multi_index_op (int n
         }
 
       try
         {
           BEGIN_PROFILER_BLOCK (profiler_name ())
 
           retval = (*f) (args, nargout);
           // Do not allow null values to be returned from functions.
-          // FIXME -- perhaps true builtins should be allowed?
+          // FIXME: perhaps true builtins should be allowed?
           retval.make_storable_values ();
           // Fix the case of a single undefined value.
           // This happens when a compiled function uses
           //   octave_value retval;
           // instead of
           //   octave_value_list retval;
           // the idiom is very common, so we solve that here.
           if (retval.length () == 1 && retval.xelem (0).is_undefined ())
diff --git a/libinterp/octave-value/ov-builtin.h b/libinterp/octave-value/ov-builtin.h
--- a/libinterp/octave-value/ov-builtin.h
+++ b/libinterp/octave-value/ov-builtin.h
@@ -53,28 +53,29 @@ public:
     : octave_function (nm, ds), f (ff), file (fnm), jtype (0) { }
 
   ~octave_builtin (void) { }
 
   std::string src_file_name (void) const { return file; }
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx)
-    {
-      octave_value_list tmp = subsref (type, idx, 1);
-      return tmp.length () > 0 ? tmp(0) : octave_value ();
-    }
+  {
+    octave_value_list tmp = subsref (type, idx, 1);
+    return tmp.length () > 0 ? tmp(0) : octave_value ();
+  }
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              int nargout);
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
-                             int nargout, const std::list<octave_lvalue>* lvalue_list);
+                             int nargout,
+                             const std::list<octave_lvalue>* lvalue_list);
 
   octave_function *function_value (bool = false) { return this; }
 
   bool is_builtin_function (void) const { return true; }
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -72,34 +72,35 @@ template <>
 void
 octave_base_matrix<Cell>::assign (const octave_value_list& idx, const Cell& rhs)
 {
   matrix.assign (idx, rhs);
 }
 
 template <>
 void
-octave_base_matrix<Cell>::assign (const octave_value_list& idx, octave_value rhs)
+octave_base_matrix<Cell>::assign (const octave_value_list& idx,
+                                  octave_value rhs)
 {
   // FIXME: Really?
   if (rhs.is_cell ())
     matrix.assign (idx, rhs.cell_value ());
   else
     matrix.assign (idx, Cell (rhs));
 }
 
 template <>
 void
 octave_base_matrix<Cell>::delete_elements (const octave_value_list& idx)
 {
   matrix.delete_elements (idx);
 }
 
-// FIXME: this list of specializations is becoming so long that we should really ask
-// whether octave_cell should inherit from octave_base_matrix at all.
+// FIXME: this list of specializations is becoming so long that we should
+// really ask whether octave_cell should inherit from octave_base_matrix at all.
 
 template <>
 octave_value
 octave_base_matrix<Cell>::fast_elem_extract (octave_idx_type n) const
 {
   if (n < matrix.numel ())
     return Cell (matrix(n));
   else
@@ -169,17 +170,17 @@ octave_cell::subsref (const std::string&
         error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
       }
       break;
 
     default:
       panic_impossible ();
     }
 
-  // FIXME -- perhaps there should be an
+  // FIXME: perhaps there should be an
   // octave_value_list::next_subsref member function?  See also
   // octave_user_function::subsref.
 
   if (idx.size () > 1)
     retval = (lvalue_list
               ? retval(0).next_subsref (nargout, type, idx, lvalue_list)
               : retval(0).next_subsref (nargout, type, idx));
 
@@ -221,17 +222,17 @@ octave_cell::subsref (const std::string&
         error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
       }
       break;
 
     default:
       panic_impossible ();
     }
 
-  // FIXME -- perhaps there should be an
+  // FIXME: perhaps there should be an
   // octave_value_list::next_subsref member function?  See also
   // octave_user_function::subsref.
 
   if (idx.size () > 1)
     retval = retval.next_subsref (auto_add, type, idx);
 
   return retval;
 }
@@ -312,17 +313,17 @@ octave_cell::subsasgn (const std::string
                     tmpc = Cell ();
 
                     if (! tmp.is_defined () || tmp.is_zero_by_zero ())
                       {
                         tmp = octave_value::empty_conv (type.substr (1), rhs);
                         tmp.make_unique (); // probably a no-op.
                       }
                     else
-                      // optimization: ignore the copy still stored inside our array.
+                      // optimization: ignore copy still stored inside array.
                       tmp.make_unique (1);
 
                     if (! error_state)
                       t_rhs = tmp.subsasgn (next_type, next_idx, rhs);
                   }
                 else
                   gripe_indexed_cs_list ();
               }
@@ -353,21 +354,20 @@ octave_cell::subsasgn (const std::string
       switch (type[0])
         {
         case '(':
           {
             octave_value_list i = idx.front ();
 
             if (t_rhs.is_cell ())
               octave_base_matrix<Cell>::assign (i, t_rhs.cell_value ());
+            else if (t_rhs.is_null_value ())
+              octave_base_matrix<Cell>::delete_elements (i);
             else
-              if (t_rhs.is_null_value ())
-                octave_base_matrix<Cell>::delete_elements (i);
-              else
-                octave_base_matrix<Cell>::assign (i, Cell (t_rhs));
+              octave_base_matrix<Cell>::assign (i, Cell (t_rhs));
 
             if (! error_state)
               {
                 count++;
                 retval = octave_value (this);
               }
             else
               gripe_failed_assignment ();
@@ -389,19 +389,21 @@ octave_cell::subsasgn (const std::string
                   if (! idxf(k).is_magic_colon ()) didx(k) = idxf(k).numel ();
 
                 if (didx.numel () == tmp_cell.numel ())
                   tmp_cell = tmp_cell.reshape (didx);
 
 
                 octave_base_matrix<Cell>::assign (idxf, tmp_cell);
               }
-            else if (idxf.all_scalars () || do_index_op (idxf, true).numel () == 1)
+            else if (idxf.all_scalars ()
+                     || do_index_op (idxf, true).numel () == 1)
               // Regularize a null matrix if stored into a cell.
-              octave_base_matrix<Cell>::assign (idxf, Cell (t_rhs.storable_value ()));
+              octave_base_matrix<Cell>::assign (idxf,
+                                                Cell (t_rhs.storable_value ()));
             else if (! error_state)
               gripe_nonbraced_cs_list_assignment ();
 
             if (! error_state)
               {
                 count++;
                 retval = octave_value (this);
               }
@@ -1127,17 +1129,18 @@ octave_cell::save_hdf5 (hid_t loc_id, co
 
   Cell tmp = cell_value ();
 
   octave_idx_type nel = dv.numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       std::ostringstream buf;
-      int digits = static_cast<int> (gnulib::floor (::log10 (static_cast<double> (nel)) + 1.0));
+      int digits = static_cast<int> (gnulib::floor (::log10 (static_cast<double>
+                                     (nel)) + 1.0));
       buf << "_" << std::setw (digits) << std::setfill ('0') << i;
       std::string s = buf.str ();
 
       if (! add_hdf5_data (data_hid, tmp.elem (i), s.c_str (), "", false,
                            save_as_floats))
         {
           H5Gclose (data_hid);
           return false;
@@ -1252,34 +1255,34 @@ octave_cell::load_hdf5 (hid_t loc_id, co
     }
 
   return retval;
 }
 
 #endif
 
 DEFUN (iscell, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} iscell (@var{x})\n\
 Return true if @var{x} is a cell array object.\n\
 @seealso{ismatrix, isstruct, iscellstr, isa}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).is_cell ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (cell, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} cell (@var{n})\n\
 @deftypefnx {Built-in Function} {} cell (@var{m}, @var{n})\n\
 @deftypefnx {Built-in Function} {} cell (@var{m}, @var{n}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} cell ([@var{m} @var{n} @dots{}])\n\
 Create a new cell array object.\n\
 If invoked with a single scalar integer argument, return a square\n\
 @nospell{NxN} cell array.  If invoked with two or more scalar\n\
 integer arguments, or a vector of integer values, return an array with\n\
@@ -1329,17 +1332,17 @@ the given dimensions.\n\
       if (! error_state)
         retval = Cell (dims, Matrix ());
     }
 
   return retval;
 }
 
 DEFUN (iscellstr, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} iscellstr (@var{cell})\n\
 Return true if every element of the cell array @var{cell} is a\n\
 character string.\n\
 @seealso{ischar}\n\
 @end deftypefn")
 {
   octave_value retval;
 
@@ -1352,17 +1355,17 @@ character string.\n\
 }
 
 // Note that since Fcellstr calls Fiscellstr, we need to have
 // Fiscellstr defined first (to provide a declaration) and also we
 // should keep it in the same file (so we don't have to provide a
 // declaration) and so we don't have to use feval to call it.
 
 DEFUN (cellstr, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} cellstr (@var{string})\n\
 Create a new cell array object from the elements of the string\n\
 array @var{string}.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
@@ -1385,17 +1388,17 @@ array @var{string}.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (struct2cell, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} struct2cell (@var{S})\n\
 Create a new cell array from the objects stored in the struct object.\n\
 If @var{f} is the number of fields in the structure, the resulting\n\
 cell array will have a dimension vector corresponding to\n\
 @code{[@var{F} size(@var{S})]}.  For example:\n\
 \n\
 @example\n\
 @group\n\
@@ -1438,19 +1441,19 @@ c(2,1,:)(:)\n\
           octave_idx_type num_fields = m.nfields ();
 
           // The resulting dim_vector should have dimensions:
           // [numel(fields) size(struct)]
           // except if the struct is a column vector.
 
           dim_vector result_dv;
           if (m_dv (m_dv.length () - 1) == 1)
-              result_dv.resize (m_dv.length ());
+            result_dv.resize (m_dv.length ());
           else
-              result_dv.resize (m_dv.length () + 1); // Add 1 for the fields.
+            result_dv.resize (m_dv.length () + 1); // Add 1 for the fields.
 
           result_dv(0) = num_fields;
 
           for (int i = 1; i < result_dv.length (); i++)
             result_dv(i) = m_dv(i-1);
 
           NoAlias<Cell> c (result_dv);
 
diff --git a/libinterp/octave-value/ov-cell.h b/libinterp/octave-value/ov-cell.h
--- a/libinterp/octave-value/ov-cell.h
+++ b/libinterp/octave-value/ov-cell.h
@@ -52,36 +52,37 @@ public:
 
   octave_cell (void)
     : octave_base_matrix<Cell> (), cellstr_cache () { }
 
   octave_cell (const Cell& c)
     : octave_base_matrix<Cell> (c), cellstr_cache () { }
 
   octave_cell (const Array<std::string>& str)
-    : octave_base_matrix<Cell> (Cell (str)), cellstr_cache (new Array<std::string> (str)) { }
+    : octave_base_matrix<Cell> (Cell (str)),
+      cellstr_cache (new Array<std::string> (str)) { }
 
   octave_cell (const octave_cell& c)
     : octave_base_matrix<Cell> (c), cellstr_cache () { }
 
   ~octave_cell (void) { }
 
   octave_base_value *clone (void) const { return new octave_cell (*this); }
   octave_base_value *empty_clone (void) const { return new octave_cell (); }
 
 #if 0
   octave_base_value *try_narrowing_conversion (void);
 #endif
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx)
-    {
-      octave_value_list tmp = subsref (type, idx, 1);
-      return tmp.length () > 0 ? tmp(0) : octave_value ();
-    }
+  {
+    octave_value_list tmp = subsref (type, idx, 1);
+    return tmp.length () > 0 ? tmp(0) : octave_value ();
+  }
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              int nargout)
   {
     return subsref (type, idx, nargout, 0);
   }
 
@@ -133,17 +134,17 @@ public:
 
   bool is_true (void) const;
 
   Cell cell_value (void) const { return matrix; }
 
   octave_value_list list_value (void) const;
 
   octave_value convert_to_str_internal (bool pad, bool, char type) const
-    { return octave_value (all_strings (pad), type); }
+  { return octave_value (all_strings (pad), type); }
 
   string_vector all_strings (bool pad = false) const;
 
   Array<std::string> cellstr_value (void) const;
 
   bool print_as_scalar (void) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
@@ -172,17 +173,17 @@ public:
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const;
 
 private:
 
   void clear_cellstr_cache (void) const
-    { cellstr_cache.reset (); }
+  { cellstr_cache.reset (); }
 
   mutable std::auto_ptr<Array<std::string> > cellstr_cache;
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
diff --git a/libinterp/octave-value/ov-ch-mat.cc b/libinterp/octave-value/ov-ch-mat.cc
--- a/libinterp/octave-value/ov-ch-mat.cc
+++ b/libinterp/octave-value/ov-ch-mat.cc
@@ -197,18 +197,18 @@ octave_char_matrix::map (unary_mapper_t 
     STRING_MAPPER (xispunct, std::ispunct, bool);
     STRING_MAPPER (xisspace, std::isspace, bool);
     STRING_MAPPER (xisupper, std::isupper, bool);
     STRING_MAPPER (xisxdigit, std::isxdigit, bool);
     STRING_MAPPER (xtoascii, xtoascii, double);
     STRING_MAPPER (xtolower, std::tolower, char);
     STRING_MAPPER (xtoupper, std::toupper, char);
 
-    // For Matlab compatibility, these should work on ASCII values
-    // without error or warning.
+      // For Matlab compatibility, these should work on ASCII values
+      // without error or warning.
     case umap_abs:
     case umap_ceil:
     case umap_fix:
     case umap_floor:
     case umap_imag:
     case umap_isinf:
     case umap_isnan:
     case umap_real:
diff --git a/libinterp/octave-value/ov-ch-mat.h b/libinterp/octave-value/ov-ch-mat.h
--- a/libinterp/octave-value/ov-ch-mat.h
+++ b/libinterp/octave-value/ov-ch-mat.h
@@ -77,74 +77,76 @@ protected:
 
   octave_char_matrix (const octave_char_matrix& chm)
     : octave_base_matrix<charNDArray> (chm) { }
 
 public:
 
   ~octave_char_matrix (void) { }
 
-  octave_base_value *clone (void) const { return new octave_char_matrix (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_char_matrix (); }
+  octave_base_value *clone (void) const
+  { return new octave_char_matrix (*this); }
+  octave_base_value *empty_clone (void) const
+  { return new octave_char_matrix (); }
 
   idx_vector index_vector (void) const;
 
   builtin_type_t builtin_type (void) const { return btyp_char; }
 
   bool is_char_matrix (void) const { return true; }
   bool is_real_matrix (void) const { return true; }
 
   bool is_real_type (void) const { return true; }
 
   double double_value (bool = false) const;
 
   float float_value (bool = false) const;
 
   double scalar_value (bool frc_str_conv = false) const
-    { return double_value (frc_str_conv); }
+  { return double_value (frc_str_conv); }
 
   float float_scalar_value (bool frc_str_conv = false) const
-    { return float_value (frc_str_conv); }
+  { return float_value (frc_str_conv); }
 
   Matrix matrix_value (bool = false) const
-    { return Matrix (matrix.matrix_value ()); }
+  { return Matrix (matrix.matrix_value ()); }
 
   FloatMatrix float_matrix_value (bool = false) const
-    { return FloatMatrix (matrix.matrix_value ()); }
+  { return FloatMatrix (matrix.matrix_value ()); }
 
   NDArray array_value (bool = false) const
-    { return NDArray (matrix); }
+  { return NDArray (matrix); }
 
   FloatNDArray float_array_value (bool = false) const
-    { return FloatNDArray (matrix); }
+  { return FloatNDArray (matrix); }
 
   Complex complex_value (bool = false) const;
 
   FloatComplex float_complex_value (bool = false) const;
 
   ComplexMatrix complex_matrix_value (bool = false) const
-    { return ComplexMatrix (matrix.matrix_value ()); }
+  { return ComplexMatrix (matrix.matrix_value ()); }
 
   FloatComplexMatrix float_complex_matrix_value (bool = false) const
-    { return FloatComplexMatrix (matrix.matrix_value ()); }
+  { return FloatComplexMatrix (matrix.matrix_value ()); }
 
   ComplexNDArray complex_array_value (bool = false) const
-    { return ComplexNDArray (matrix); }
+  { return ComplexNDArray (matrix); }
 
   FloatComplexNDArray float_complex_array_value (bool = false) const
-    { return FloatComplexNDArray (matrix); }
+  { return FloatComplexNDArray (matrix); }
 
   charMatrix char_matrix_value (bool = false) const
-    { return matrix.matrix_value (); }
+  { return matrix.matrix_value (); }
 
   charNDArray char_array_value (bool = false) const
-    { return matrix; }
+  { return matrix; }
 
   octave_value convert_to_str_internal (bool, bool, char type) const
-    { return octave_value (matrix, type); }
+  { return octave_value (matrix, type); }
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return matrix.mex_get_data (); }
 
   mxArray *as_mxArray (void) const;
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -62,17 +62,18 @@ DEFINE_OCTAVE_ALLOCATOR(octave_class);
 int octave_class::t_id (-1);
 
 const std::string octave_class::t_name ("class");
 
 void
 octave_class::register_type (void)
 {
   t_id = octave_value_typeinfo::register_type
-    (octave_class::t_name, "<unknown>", octave_value (new octave_class ()));
+         (octave_class::t_name, "<unknown>",
+          octave_value (new octave_class ()));
 }
 
 octave_class::octave_class (const octave_map& m, const std::string& id,
                             const octave_value_list& parents)
   : octave_base_value (), map (m), c_name (id), obsolete_copies (0)
 {
   octave_idx_type n = parents.length ();
 
@@ -168,17 +169,17 @@ octave_class::octave_class (const octave
 
                       Cell pcell (map.dims (), parent);
 
                       map.assign (pcnm, pcell);
                     }
 
                   else if (nel == p_nel)
                     {
-                      // FIXME -- is there a better way to do this?
+                      // FIXME: is there a better way to do this?
 
                       // The parent class object has the same number of
                       // elements as the map we are using to create the
                       // new object, so distribute those elements to
                       // each element of the new object by first
                       // splitting the elements of the parent class
                       // object into a cell array with one element per
                       // cell.  Then do the assignment all at once.
@@ -397,17 +398,17 @@ octave_class::dotref (const octave_value
   return retval;
 }
 
 static bool
 called_from_builtin (void)
 {
   octave_function *fcn = octave_call_stack::caller ();
 
-  // FIXME -- we probably need a better check here, or some other
+  // FIXME: we probably need a better check here, or some other
   // mechanism to avoid overloaded functions when builtin is used.
   // For example, what if someone overloads the builtin function?
   // Also, are there other places where using builtin is not properly
   // avoiding dispatch?
 
   return (fcn && fcn->name () == "builtin");
 }
 
@@ -421,17 +422,18 @@ octave_class::size (void)
   octave_value meth = symbol_table::find_method ("size", class_name ());
 
   if (meth.is_defined ())
     {
       count++;
       octave_value_list args (1, octave_value (this));
 
       octave_value_list lv = feval (meth.function_value (), args, 1);
-      if (lv.length () > 0 && lv(0).is_matrix_type () && lv(0).dims ().is_vector ())
+      if (lv.length () > 0
+          && lv(0).is_matrix_type () && lv(0).dims ().is_vector ())
         retval = lv(0).matrix_value ();
       else
         error ("@%s/size: invalid return value", class_name ().c_str ());
     }
   else
     {
       dim_vector dv = dims ();
 
@@ -483,17 +485,17 @@ octave_value_list
 octave_class::subsref (const std::string& type,
                        const std::list<octave_value_list>& idx,
                        int nargout)
 {
   octave_value_list retval;
 
   if (in_class_method () || called_from_builtin ())
     {
-      // FIXME -- this block of code is the same as the body of
+      // FIXME: this block of code is the same as the body of
       // octave_struct::subsref.  Maybe it could be shared instead of
       // duplicated.
 
       int skip = 1;
 
       switch (type[0])
         {
         case '(':
@@ -504,17 +506,18 @@ octave_class::subsref (const std::string
                 octave_value_list key_idx = *++p;
 
                 Cell tmp = dotref (key_idx);
 
                 if (! error_state)
                   {
                     Cell t = tmp.index (idx.front ());
 
-                    retval(0) = (t.length () == 1) ? t(0) : octave_value (t, true);
+                    retval(0) = (t.length () == 1) ? t(0)
+                                                   : octave_value (t, true);
 
                     // We handled two index elements, so tell
                     // next_subsref to skip both of them.
 
                     skip++;
                   }
               }
             else
@@ -537,17 +540,17 @@ octave_class::subsref (const std::string
         case '{':
           gripe_invalid_index_type (type_name (), type[0]);
           break;
 
         default:
           panic_impossible ();
         }
 
-      // FIXME -- perhaps there should be an
+      // FIXME: perhaps there should be an
       // octave_value_list::next_subsref member function?  See also
       // octave_user_function::subsref.
 
       if (idx.size () > 1)
         retval = retval(0).next_subsref (nargout, type, idx, skip);
     }
   else
     {
@@ -699,17 +702,17 @@ octave_class::subsasgn_common (const oct
               frame.protect_var (obsolete_copies);
               obsolete_copies = 2;
 
               tmp = feval (meth.function_value (), args);
             }
           else
             tmp = feval (meth.function_value (), args);
 
-          // FIXME -- should the subsasgn method be able to return
+          // FIXME: should the subsasgn method be able to return
           // more than one value?
 
           if (tmp.length () > 1)
             error ("expecting single return value from @%s/subsasgn",
                    class_name ().c_str ());
 
           else
             retval = tmp(0);
@@ -739,17 +742,17 @@ octave_class::subsasgn_common (const oct
             gripe_failed_assignment ();
         }
       else
         error ("malformed class");
 
       return retval;
     }
 
-  // FIXME -- this block of code is the same as the body of
+  // FIXME: this block of code is the same as the body of
   // octave_struct::subsasgn.  Maybe it could be shared instead of
   // duplicated.
 
   int n = type.length ();
 
   octave_value t_rhs = rhs;
 
   if (n > 1 && ! (type.length () == 2 && type[0] == '(' && type[1] == '.'))
@@ -837,17 +840,17 @@ octave_class::subsasgn_common (const oct
                     octave_value& tmp = tmpc(0);
 
                     if (! tmp.is_defined () || tmp.is_zero_by_zero ())
                       {
                         tmp = octave_value::empty_conv (next_type, rhs);
                         tmp.make_unique (); // probably a no-op.
                       }
                     else
-                      // optimization: ignore the copy still stored inside our map.
+                      // optimization: ignore copy still stored inside our map.
                       tmp.make_unique (1);
 
                     if (! error_state)
                       t_rhs = tmp.subsasgn (next_type, next_idx, rhs);
                   }
                 else
                   gripe_indexed_cs_list ();
               }
@@ -1486,17 +1489,17 @@ octave_class::save_binary (std::ostream&
       i++;
     }
 
   return true;
 }
 
 bool
 octave_class::load_binary (std::istream& is, bool swap,
-                            oct_mach_info::float_format fmt)
+                           oct_mach_info::float_format fmt)
 {
   bool success = true;
 
   int32_t classname_len;
 
   is.read (reinterpret_cast<char *> (&classname_len), 4);
   if (! is)
     return false;
@@ -1612,21 +1615,22 @@ octave_class::save_hdf5 (hid_t loc_id, c
 #if HAVE_HDF5_18
   class_hid = H5Dcreate (group_hid, "classname",  type_hid, space_hid,
                          H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   class_hid = H5Dcreate (group_hid, "classname",  type_hid, space_hid,
                          H5P_DEFAULT);
 #endif
   if (class_hid < 0 || H5Dwrite (class_hid, type_hid, H5S_ALL, H5S_ALL,
-                                    H5P_DEFAULT, c_name.c_str ()) < 0)
+                                 H5P_DEFAULT, c_name.c_str ()) < 0)
     goto error_cleanup;
 
 #if HAVE_HDF5_18
-  data_hid = H5Gcreate (group_hid, "value", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+  data_hid = H5Gcreate (group_hid, "value", H5P_DEFAULT, H5P_DEFAULT,
+                        H5P_DEFAULT);
 #else
   data_hid = H5Gcreate (group_hid, "value", 0);
 #endif
   if (data_hid < 0)
     goto error_cleanup;
 
   if (load_path::find_method (class_name (), "saveobj") != std::string ())
     {
@@ -1650,17 +1654,17 @@ octave_class::save_hdf5 (hid_t loc_id, c
                                     save_as_floats);
 
       if (! retval2)
         break;
 
       i++;
     }
 
- error_cleanup:
+error_cleanup:
 
   if (data_hid > 0)
     H5Gclose (data_hid);
 
   if (class_hid > 0)
     H5Dclose (class_hid);
 
   if (space_hid > 0)
@@ -1801,17 +1805,17 @@ octave_class::load_hdf5 (hid_t loc_id, c
               map = tmp(0).map_value ();
               retval = true;
             }
           else
             retval = false;
         }
     }
 
- error_cleanup:
+error_cleanup:
   if (data_hid > 0)
     H5Dclose (data_hid);
 
   if (data_hid > 0)
     H5Gclose (group_hid);
 
   return retval;
 }
@@ -1916,17 +1920,17 @@ octave_class::exemplar_info::compare (co
       retval = false;
       error ("invalid comparison of class exemplar to non-class object");
     }
 
   return retval;
 }
 
 DEFUN (class, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Function File} {@var{classname} =} class (@var{obj})\n\
 @deftypefnx {Function File} {} class (@var{s}, @var{id})\n\
 @deftypefnx {Function File} {} class (@var{s}, @var{id}, @var{p}, @dots{})\n\
 Return the class of the object @var{obj} or create a class with\n\
 fields from structure @var{s} and name (string) @var{id}.  Additional\n\
 arguments name a list of parent classes from which the new class is\n\
 derived.\n\
 @seealso{typeinfo, isa}\n\
@@ -2008,17 +2012,17 @@ derived.\n\
 %! jobj = javaObject ("java.lang.StringBuffer");
 %! assert (class (jobj), "java.lang.StringBuffer");
 
 %% Test Input Validation
 %!error class ()
 */
 
 DEFUN (__isa_parent__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __isa_parent__ (@var{class}, @var{name})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
   if (args.length () == 2)
     {
@@ -2035,17 +2039,17 @@ Undocumented internal function.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (__parent_classes__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __parent_classes__ (@var{x})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval = Cell ();
 
   if (args.length () == 1)
     {
@@ -2056,34 +2060,34 @@ Undocumented internal function.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (isobject, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isobject (@var{x})\n\
 Return true if @var{x} is a class object.\n\
 @seealso{class, typeinfo, isa, ismethod}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).is_object ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (ismethod, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ismethod (@var{x}, @var{method})\n\
 Return true if @var{x} is a class object and the string @var{method}\n\
 is a method of this class.\n\
 @seealso{isobject}\n\
 @end deftypefn")
 {
   octave_value retval;
 
@@ -2115,17 +2119,17 @@ is a method of this class.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (__methods__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} __methods__ (@var{x})\n\
 @deftypefnx {Built-in Function} {} __methods__ (\"classname\")\n\
 Internal function.\n\
 \n\
 Implements @code{methods} for Octave class objects and classnames.\n\
 @seealso{methods}\n\
 @end deftypefn")
 {
@@ -2173,17 +2177,17 @@ is_built_in_class (const std::string& cn
       built_in_class_names.insert ("int64");
       built_in_class_names.insert ("uint64");
     }
 
   return built_in_class_names.find (cn) != built_in_class_names.end ();
 }
 
 DEFUN (superiorto, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} superiorto (@var{class_name}, @dots{})\n\
 When called from a class constructor, mark the object currently\n\
 constructed as having a higher precedence than @var{class_name}.\n\
 More that one such class can be specified in a single call.\n\
 This function may only be called from a class constructor.\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -2195,18 +2199,18 @@ This function may only be called from a 
       return retval;
     }
 
   for (int i = 0; i < args.length (); i++)
     {
       std::string inf_class = args(i).string_value ();
       if (error_state)
         {
-              error ("superiorto: expecting argument to be class name");
-              break;
+          error ("superiorto: expecting argument to be class name");
+          break;
         }
 
       // User defined classes always have higher precedence
       // than built-in classes
       if (is_built_in_class (inf_class))
         break;
 
       std::string sup_class = fcn->name ();
@@ -2217,17 +2221,17 @@ This function may only be called from a 
           break;
         }
     }
 
   return retval;
 }
 
 DEFUN (inferiorto, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} inferiorto (@var{class_name}, @dots{})\n\
 When called from a class constructor, mark the object currently\n\
 constructed as having a lower precedence than @var{class_name}.\n\
 More that one such class can be specified in a single call.\n\
 This function may only be called from a class constructor.\n\
 @end deftypefn")
 {
   octave_value retval;
diff --git a/libinterp/octave-value/ov-class.h b/libinterp/octave-value/ov-class.h
--- a/libinterp/octave-value/ov-class.h
+++ b/libinterp/octave-value/ov-class.h
@@ -47,23 +47,23 @@ class tree_walker;
 class
 octave_class : public octave_base_value
 {
 public:
 
   octave_class (void)
     : octave_base_value (), map (), c_name (),
       parent_list (), obsolete_copies (0)
-    { }
+  { }
 
   octave_class (const octave_map& m, const std::string& id,
                 const std::list<std::string>& plist)
     : octave_base_value (), map (m), c_name (id),
       parent_list (plist), obsolete_copies (0)
-    { }
+  { }
 
   octave_class (const octave_map& m, const std::string& id,
                 const octave_value_list& parents);
 
   octave_class (const octave_class& s)
     : octave_base_value (s), map (s.map), c_name (s.c_name),
       parent_list (s.parent_list), obsolete_copies (0)  { }
 
@@ -81,20 +81,20 @@ public:
   Cell dotref (const octave_value_list& idx);
 
   Matrix size (void);
 
   octave_idx_type numel (const octave_value_list&);
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx)
-    {
-      octave_value_list tmp = subsref (type, idx, 1);
-      return tmp.length () > 0 ? tmp(0) : octave_value ();
-    }
+  {
+    octave_value_list tmp = subsref (type, idx, 1);
+    return tmp.length () > 0 ? tmp(0) : octave_value ();
+  }
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              int nargout);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& idx)
   {
@@ -129,44 +129,44 @@ public:
     return dv.numel ();
   }
 
   octave_idx_type nfields (void) const { return map.nfields (); }
 
   size_t nparents (void) const { return parent_list.size (); }
 
   octave_value reshape (const dim_vector& new_dims) const
-    {
-      octave_class retval = octave_class (*this);
-      retval.map = retval.map_value ().reshape (new_dims);
-      return octave_value (new octave_class (retval));
-    }
+  {
+    octave_class retval = octave_class (*this);
+    retval.map = retval.map_value ().reshape (new_dims);
+    return octave_value (new octave_class (retval));
+  }
 
   octave_value resize (const dim_vector& dv, bool = false) const
-    {
-      octave_class retval = octave_class (*this);
-      retval.map.resize (dv);
-      return octave_value (new octave_class (retval));
-    }
+  {
+    octave_class retval = octave_class (*this);
+    retval.map.resize (dv);
+    return octave_value (new octave_class (retval));
+  }
 
   bool is_defined (void) const { return true; }
 
   bool is_map (void) const { return false; }
 
   bool is_object (void) const { return true; }
 
   octave_map map_value (void) const { return map; }
 
   string_vector map_keys (void) const;
 
   std::list<std::string> parent_class_name_list (void) const
-    { return parent_list; }
+  { return parent_list; }
 
   string_vector parent_class_names (void) const
-    { return string_vector (parent_list); }
+  { return string_vector (parent_list); }
 
   octave_base_value *find_parent_class (const std::string&);
 
   octave_base_value *unique_parent_class (const std::string&);
 
   string_vector all_strings (bool pad) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
@@ -273,13 +273,15 @@ public:
 
     string_vector field_names;
     std::list<std::string> parent_class_names;
   };
 
   // A map from class names to lists of fields.
   static std::map<std::string, exemplar_info> exemplar_map;
 
-  typedef std::map<std::string, exemplar_info>::iterator exemplar_iterator;
-  typedef std::map<std::string, exemplar_info>::const_iterator exemplar_const_iterator;
+  typedef std::map<std::string, exemplar_info>::iterator
+    exemplar_iterator;
+  typedef std::map<std::string, exemplar_info>::const_iterator
+    exemplar_const_iterator;
 };
 
 #endif
diff --git a/libinterp/octave-value/ov-colon.h b/libinterp/octave-value/ov-colon.h
--- a/libinterp/octave-value/ov-colon.h
+++ b/libinterp/octave-value/ov-colon.h
@@ -49,18 +49,20 @@ public:
   octave_magic_colon (void)
     : octave_base_value () { }
 
   octave_magic_colon (const octave_magic_colon&)
     : octave_base_value () { }
 
   ~octave_magic_colon (void) { }
 
-  octave_base_value *clone (void) const { return new octave_magic_colon (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_magic_colon (); }
+  octave_base_value *clone (void) const
+  { return new octave_magic_colon (*this); }
+  octave_base_value *empty_clone (void) const
+  { return new octave_magic_colon (); }
 
   idx_vector index_vector (void) const { return idx_vector (':'); }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
 
   bool is_magic_colon (void) const { return true; }
diff --git a/libinterp/octave-value/ov-complex.cc b/libinterp/octave-value/ov-complex.cc
--- a/libinterp/octave-value/ov-complex.cc
+++ b/libinterp/octave-value/ov-complex.cc
@@ -61,18 +61,19 @@ default_numeric_demotion_function (const
   CAST_CONV_ARG (const octave_complex&);
 
   return new octave_float_complex (v.float_complex_value ());
 }
 
 octave_base_value::type_conv_info
 octave_complex::numeric_demotion_function (void) const
 {
-  return octave_base_value::type_conv_info (default_numeric_demotion_function,
-                                            octave_float_complex::static_type_id ());
+  return
+    octave_base_value::type_conv_info (default_numeric_demotion_function,
+                                       octave_float_complex::static_type_id ());
 }
 
 octave_base_value *
 octave_complex::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
   double im = std::imag (scalar);
@@ -81,23 +82,23 @@ octave_complex::try_narrowing_conversion
     retval = new octave_scalar (std::real (scalar));
 
   return retval;
 }
 
 octave_value
 octave_complex::do_index_op (const octave_value_list& idx, bool resize_ok)
 {
-  // FIXME -- this doesn't solve the problem of
+  // FIXME: this doesn't solve the problem of
   //
   //   a = i; a([1,1], [1,1], [1,1])
   //
   // and similar constructions.  Hmm...
 
-  // FIXME -- using this constructor avoids narrowing the
+  // FIXME: using this constructor avoids narrowing the
   // 1x1 matrix back to a scalar value.  Need a better solution
   // to this problem.
 
   octave_value tmp (new octave_complex_matrix (complex_matrix_value ()));
 
   return tmp.do_index_op (idx, resize_ok);
 }
 
@@ -213,17 +214,18 @@ ComplexNDArray
 octave_complex::complex_array_value (bool /* force_conversion */) const
 {
   return ComplexNDArray (dim_vector (1, 1), scalar);
 }
 
 FloatComplexNDArray
 octave_complex::float_complex_array_value (bool /* force_conversion */) const
 {
-  return FloatComplexNDArray (dim_vector (1, 1), static_cast<FloatComplex> (scalar));
+  return FloatComplexNDArray (dim_vector (1, 1),
+                              static_cast<FloatComplex> (scalar));
 }
 
 octave_value
 octave_complex::resize (const dim_vector& dv, bool fill) const
 {
   if (fill)
     {
       ComplexNDArray retval (dv, Complex (0));
diff --git a/libinterp/octave-value/ov-complex.h b/libinterp/octave-value/ov-complex.h
--- a/libinterp/octave-value/ov-complex.h
+++ b/libinterp/octave-value/ov-complex.h
@@ -65,74 +65,73 @@ public:
 
   octave_base_value *clone (void) const { return new octave_complex (*this); }
 
   // We return an octave_complex_matrix object here instead of an
   // octave_complex object so that in expressions like A(2,2,2) = 2
   // (for A previously undefined), A will be empty instead of a 1x1
   // object.
   octave_base_value *empty_clone (void) const
-    { return new octave_complex_matrix (); }
+  { return new octave_complex_matrix (); }
 
   type_conv_info numeric_demotion_function (void) const;
 
   octave_base_value *try_narrowing_conversion (void);
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false);
 
   // Use this to give a more specific error message
   idx_vector index_vector (void) const
   {
-    error (
-           "attempted to use a complex scalar as an index\n"
+    error ("attempted to use a complex scalar as an index\n"
            "       (forgot to initialize i or j?)");
     return idx_vector ();
   }
 
   octave_value any (int = 0) const
-    {
-      return (scalar != Complex (0, 0)
-              && ! (lo_ieee_isnan (std::real (scalar))
-                    || lo_ieee_isnan (std::imag (scalar))));
-    }
+  {
+    return (scalar != Complex (0, 0)
+            && ! (lo_ieee_isnan (std::real (scalar))
+                  || lo_ieee_isnan (std::imag (scalar))));
+  }
 
   builtin_type_t builtin_type (void) const { return btyp_complex; }
 
   bool is_complex_scalar (void) const { return true; }
 
   bool is_complex_type (void) const { return true; }
 
   bool is_double_type (void) const { return true; }
 
   bool is_float_type (void) const { return true; }
 
   double double_value (bool = false) const;
 
   float float_value (bool = false) const;
 
   double scalar_value (bool frc_str_conv = false) const
-    { return double_value (frc_str_conv); }
+  { return double_value (frc_str_conv); }
 
   float float_scalar_value (bool frc_str_conv = false) const
-    { return float_value (frc_str_conv); }
+  { return float_value (frc_str_conv); }
 
   Matrix matrix_value (bool = false) const;
 
   FloatMatrix float_matrix_value (bool = false) const;
 
   NDArray array_value (bool = false) const;
 
   FloatNDArray float_array_value (bool = false) const;
 
   SparseMatrix sparse_matrix_value (bool = false) const
-    { return SparseMatrix (matrix_value ()); }
+  { return SparseMatrix (matrix_value ()); }
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const
-    { return SparseComplexMatrix (complex_matrix_value ()); }
+  { return SparseComplexMatrix (complex_matrix_value ()); }
 
   octave_value resize (const dim_vector& dv, bool fill = false) const;
 
   Complex complex_value (bool = false) const;
 
   FloatComplex float_complex_value (bool = false) const;
 
   ComplexMatrix complex_matrix_value (bool = false) const;
@@ -182,21 +181,21 @@ public:
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
-    {
-      // Yes, for compatibility, we drop the imaginary part here.
-      return os.write (array_value (true), block_size, output_type,
-                       skip, flt_fmt);
-    }
+  {
+    // Yes, for compatibility, we drop the imaginary part here.
+    return os.write (array_value (true), block_size, output_type,
+                     skip, flt_fmt);
+  }
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
diff --git a/libinterp/octave-value/ov-cx-diag.cc b/libinterp/octave-value/ov-cx-diag.cc
--- a/libinterp/octave-value/ov-cx-diag.cc
+++ b/libinterp/octave-value/ov-cx-diag.cc
@@ -47,33 +47,36 @@ default_numeric_conversion_function (con
   CAST_CONV_ARG (const octave_complex_diag_matrix&);
 
   return new octave_complex_matrix (v.complex_matrix_value ());
 }
 
 octave_base_value::type_conv_info
 octave_complex_diag_matrix::numeric_conversion_function (void) const
 {
-  return octave_base_value::type_conv_info (default_numeric_conversion_function,
-                                            octave_complex_matrix::static_type_id ());
+  return octave_base_value::type_conv_info
+           (default_numeric_conversion_function,
+            octave_complex_matrix::static_type_id ());
 }
 
 static octave_base_value *
 default_numeric_demotion_function (const octave_base_value& a)
 {
   CAST_CONV_ARG (const octave_complex_diag_matrix&);
 
-  return new octave_float_complex_diag_matrix (v.float_complex_diag_matrix_value ());
+  return new octave_float_complex_diag_matrix
+               (v.float_complex_diag_matrix_value ());
 }
 
 octave_base_value::type_conv_info
 octave_complex_diag_matrix::numeric_demotion_function (void) const
 {
-  return octave_base_value::type_conv_info (default_numeric_demotion_function,
-                                            octave_float_complex_diag_matrix::static_type_id ());
+  return
+    octave_base_value::type_conv_info (default_numeric_demotion_function,
+                                       octave_float_complex_diag_matrix::static_type_id ());
 }
 
 octave_base_value *
 octave_complex_diag_matrix::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
   if (matrix.nelem () == 1)
@@ -144,17 +147,18 @@ octave_complex_diag_matrix::map (unary_m
     case umap_real:
       return ::real (matrix);
     case umap_conj:
       return ::conj (matrix);
     case umap_imag:
       return ::imag (matrix);
     case umap_sqrt:
       {
-        ComplexColumnVector tmp = matrix.extract_diag ().map<Complex> (std::sqrt);
+        ComplexColumnVector tmp =
+          matrix.extract_diag ().map<Complex> (std::sqrt);
         ComplexDiagMatrix retval (tmp);
         retval.resize (matrix.rows (), matrix.columns ());
         return retval;
       }
     default:
       return to_dense ().map (umap);
     }
 }
@@ -174,32 +178,33 @@ octave_complex_diag_matrix::save_binary 
       if (m.too_large_for_float ())
         {
           warning ("save: some values too large to save as floats --");
           warning ("save: saving as doubles instead");
         }
       else
         st = LS_FLOAT;
     }
-  else if (matrix.length () > 4096) // FIXME -- make this configurable.
+  else if (matrix.length () > 4096) // FIXME: make this configurable.
     {
       double max_val, min_val;
       if (m.all_integers (max_val, min_val))
         st = get_save_type (max_val, min_val);
     }
 
   const Complex *mtmp = m.data ();
-  write_doubles (os, reinterpret_cast<const double *> (mtmp), st, 2 * m.numel ());
+  write_doubles (os, reinterpret_cast<const double *> (mtmp), st,
+                 2 * m.numel ());
 
   return true;
 }
 
 bool
 octave_complex_diag_matrix::load_binary (std::istream& is, bool swap,
-                                 oct_mach_info::float_format fmt)
+                                         oct_mach_info::float_format fmt)
 {
   int32_t r, c;
   char tmp;
   if (! (is.read (reinterpret_cast<char *> (&r), 4)
          && is.read (reinterpret_cast<char *> (&c), 4)
          && is.read (reinterpret_cast<char *> (&tmp), 1)))
     return false;
   if (swap)
diff --git a/libinterp/octave-value/ov-cx-diag.h b/libinterp/octave-value/ov-cx-diag.h
--- a/libinterp/octave-value/ov-cx-diag.h
+++ b/libinterp/octave-value/ov-cx-diag.h
@@ -43,18 +43,20 @@ public:
   octave_complex_diag_matrix (const ComplexDiagMatrix& m)
     : octave_base_diag<ComplexDiagMatrix, ComplexMatrix> (m) { }
 
   octave_complex_diag_matrix (const octave_complex_diag_matrix& m)
     : octave_base_diag<ComplexDiagMatrix, ComplexMatrix> (m) { }
 
   ~octave_complex_diag_matrix (void) { }
 
-  octave_base_value *clone (void) const { return new octave_complex_diag_matrix (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_complex_diag_matrix (); }
+  octave_base_value *clone (void) const
+  { return new octave_complex_diag_matrix (*this); }
+  octave_base_value *empty_clone (void) const
+  { return new octave_complex_diag_matrix (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
   type_conv_info numeric_demotion_function (void) const;
 
   octave_base_value *try_narrowing_conversion (void);
 
   builtin_type_t builtin_type (void) const { return btyp_complex; }
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -69,18 +69,19 @@ default_numeric_demotion_function (const
   CAST_CONV_ARG (const octave_complex_matrix&);
 
   return new octave_float_complex_matrix (v.float_complex_array_value ());
 }
 
 octave_base_value::type_conv_info
 octave_complex_matrix::numeric_demotion_function (void) const
 {
-  return octave_base_value::type_conv_info (default_numeric_demotion_function,
-                                            octave_float_complex_matrix::static_type_id ());
+  return octave_base_value::type_conv_info
+           (default_numeric_demotion_function,
+            octave_float_complex_matrix::static_type_id ());
 }
 
 octave_base_value *
 octave_complex_matrix::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
   if (matrix.numel () == 1)
@@ -457,33 +458,34 @@ octave_complex_matrix::save_binary (std:
       if (m.too_large_for_float ())
         {
           warning ("save: some values too large to save as floats --");
           warning ("save: saving as doubles instead");
         }
       else
         st = LS_FLOAT;
     }
-  else if (d.numel () > 4096) // FIXME -- make this configurable.
+  else if (d.numel () > 4096) // FIXME: make this configurable.
     {
       double max_val, min_val;
       if (m.all_integers (max_val, min_val))
         st = get_save_type (max_val, min_val);
     }
 
 
   const Complex *mtmp = m.data ();
-  write_doubles (os, reinterpret_cast<const double *> (mtmp), st, 2 * d.numel ());
+  write_doubles (os, reinterpret_cast<const double *> (mtmp), st,
+                 2 * d.numel ());
 
   return true;
 }
 
 bool
 octave_complex_matrix::load_binary (std::istream& is, bool swap,
-                                 oct_mach_info::float_format fmt)
+                                    oct_mach_info::float_format fmt)
 {
   char tmp;
   int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims < 0)
@@ -642,17 +644,17 @@ octave_complex_matrix::load_hdf5 (hid_t 
 {
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize (dv);
   if (empty)
-      return (empty > 0);
+    return (empty > 0);
 
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t type_hid = H5Dget_type (data_hid);
 
diff --git a/libinterp/octave-value/ov-cx-mat.h b/libinterp/octave-value/ov-cx-mat.h
--- a/libinterp/octave-value/ov-cx-mat.h
+++ b/libinterp/octave-value/ov-cx-mat.h
@@ -77,18 +77,20 @@ public:
   octave_complex_matrix (const ComplexColumnVector& v)
     : octave_base_matrix<ComplexNDArray> (ComplexMatrix (v)) { }
 
   octave_complex_matrix (const octave_complex_matrix& cm)
     : octave_base_matrix<ComplexNDArray> (cm) { }
 
   ~octave_complex_matrix (void) { }
 
-  octave_base_value *clone (void) const { return new octave_complex_matrix (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_complex_matrix (); }
+  octave_base_value *clone (void) const
+  { return new octave_complex_matrix (*this); }
+  octave_base_value *empty_clone (void) const
+  { return new octave_complex_matrix (); }
 
   type_conv_info numeric_demotion_function (void) const;
 
   octave_base_value *try_narrowing_conversion (void);
 
   builtin_type_t builtin_type (void) const { return btyp_complex; }
 
   bool is_complex_matrix (void) const { return true; }
@@ -99,20 +101,20 @@ public:
 
   bool is_float_type (void) const { return true; }
 
   double double_value (bool = false) const;
 
   float float_value (bool = false) const;
 
   double scalar_value (bool frc_str_conv = false) const
-    { return double_value (frc_str_conv); }
+  { return double_value (frc_str_conv); }
 
   float float_scalar_value (bool frc_str_conv = false) const
-    { return float_value (frc_str_conv); }
+  { return float_value (frc_str_conv); }
 
   Matrix matrix_value (bool = false) const;
 
   FloatMatrix float_matrix_value (bool = false) const;
 
   Complex complex_value (bool = false) const;
 
   FloatComplex float_complex_value (bool = false) const;
@@ -156,21 +158,21 @@ public:
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
-    {
-      // Yes, for compatibility, we drop the imaginary part here.
-      return os.write (matrix_value (true), block_size, output_type,
-                       skip, flt_fmt);
-    }
+  {
+    // Yes, for compatibility, we drop the imaginary part here.
+    return os.write (matrix_value (true), block_size, output_type,
+                     skip, flt_fmt);
+  }
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -46,17 +46,18 @@ along with Octave; see the file COPYING.
 #include "ov-base-sparse.cc"
 
 #include "ov-bool-sparse.h"
 
 template class OCTINTERP_API octave_base_sparse<SparseComplexMatrix>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_sparse_complex_matrix);
 
-DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_sparse_complex_matrix, "sparse complex matrix", "double");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_sparse_complex_matrix,
+                                     "sparse complex matrix", "double");
 
 octave_base_value *
 octave_sparse_complex_matrix::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
   if (Vsparse_auto_mutate)
     {
@@ -105,17 +106,17 @@ double
 octave_sparse_complex_matrix::double_value (bool force_conversion) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
                                "complex sparse matrix", "real scalar");
 
-  // FIXME -- maybe this should be a function, valid_as_scalar()
+  // FIXME: maybe this should be a function, valid_as_scalar()
   if (numel () > 0)
     {
       if (numel () > 1)
         gripe_implicit_conversion ("Octave:array-to-scalar",
                                    "complex sparse matrix", "real scalar");
 
       retval = std::real (matrix (0, 0));
     }
@@ -141,17 +142,17 @@ octave_sparse_complex_matrix::matrix_val
 
 Complex
 octave_sparse_complex_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  // FIXME -- maybe this should be a function, valid_as_scalar()
+  // FIXME: maybe this should be a function, valid_as_scalar()
   if (numel () > 0)
     {
       if (numel () > 1)
         gripe_implicit_conversion ("Octave:array-to-scalar",
                                    "complex sparse matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
@@ -258,61 +259,63 @@ octave_sparse_complex_matrix::save_binar
       if (matrix.too_large_for_float ())
         {
           warning ("save: some values too large to save as floats --");
           warning ("save: saving as doubles instead");
         }
       else
         st = LS_FLOAT;
     }
-  else if (matrix.nnz () > 8192) // FIXME -- make this configurable.
+  else if (matrix.nnz () > 8192) // FIXME: make this configurable.
     {
       double max_val, min_val;
       if (matrix.all_integers (max_val, min_val))
         st = get_save_type (max_val, min_val);
     }
 
   // add one to the printed indices to go from
   // zero-based to one-based arrays
-   for (int i = 0; i < nc+1; i++)
-     {
-       octave_quit ();
-       itmp = matrix.cidx (i);
-       os.write (reinterpret_cast<char *> (&itmp), 4);
-     }
+  for (int i = 0; i < nc+1; i++)
+    {
+      octave_quit ();
+      itmp = matrix.cidx (i);
+      os.write (reinterpret_cast<char *> (&itmp), 4);
+    }
 
-   for (int i = 0; i < nz; i++)
-     {
-       octave_quit ();
-       itmp = matrix.ridx (i);
-       os.write (reinterpret_cast<char *> (&itmp), 4);
-     }
+  for (int i = 0; i < nz; i++)
+    {
+      octave_quit ();
+      itmp = matrix.ridx (i);
+      os.write (reinterpret_cast<char *> (&itmp), 4);
+    }
 
-   write_doubles (os, reinterpret_cast<const double *> (matrix.data ()), st, 2 * nz);
+  write_doubles (os, reinterpret_cast<const double *> (matrix.data ()), st,
+                 2 * nz);
 
   return true;
 }
 
 bool
 octave_sparse_complex_matrix::load_binary (std::istream& is, bool swap,
-                                   oct_mach_info::float_format fmt)
+                                           oct_mach_info::float_format fmt)
 {
   int32_t nz, nc, nr, tmp;
   char ctmp;
 
   if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
 
   if (swap)
     swap_bytes<4> (&tmp);
 
-  if (tmp != -2) {
-    error ("load: only 2-D sparse matrices are supported");
-    return false;
-  }
+  if (tmp != -2)
+    {
+      error ("load: only 2-D sparse matrices are supported");
+      return false;
+    }
 
   if (! is.read (reinterpret_cast<char *> (&nr), 4))
     return false;
   if (! is.read (reinterpret_cast<char *> (&nc), 4))
     return false;
   if (! is.read (reinterpret_cast<char *> (&nz), 4))
     return false;
 
@@ -374,17 +377,18 @@ octave_sparse_complex_matrix::save_hdf5 
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
 #if HAVE_HDF5_18
-  hid_t group_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+  hid_t group_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT,
+                               H5P_DEFAULT);
 #else
   hid_t group_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (group_hid < 0)
     return false;
 
   hid_t space_hid = -1, data_hid = -1;
   bool retval = true;
@@ -535,17 +539,18 @@ octave_sparse_complex_matrix::save_hdf5 
   if (data_hid < 0)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   itmp = m.xridx ();
-  retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, itmp) >= 0;
+  retval = H5Dwrite (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT,
+                     itmp) >= 0;
   H5Dclose (data_hid);
   if (!retval)
     {
       H5Sclose (space_hid);
       H5Gclose (group_hid);
       return false;
     }
 
@@ -643,17 +648,18 @@ octave_sparse_complex_matrix::load_hdf5 
 
   if (rank != 0)
     {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nr) < 0)
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL,
+               H5S_ALL, H5P_DEFAULT, &nr) < 0)
     {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
@@ -667,17 +673,18 @@ octave_sparse_complex_matrix::load_hdf5 
 
   if (rank != 0)
     {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nc) < 0)
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL,
+               H5S_ALL, H5P_DEFAULT, &nc) < 0)
     {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
@@ -691,17 +698,18 @@ octave_sparse_complex_matrix::load_hdf5 
 
   if (rank != 0)
     {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, &nz) < 0)
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL,
+               H5S_ALL, H5P_DEFAULT, &nz) < 0)
     {
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Dclose (data_hid);
 
@@ -735,17 +743,18 @@ octave_sparse_complex_matrix::load_hdf5 
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   octave_idx_type *itmp = m.xcidx ();
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, itmp) < 0)
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL,
+               H5S_ALL, H5P_DEFAULT, itmp) < 0)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
@@ -774,17 +783,18 @@ octave_sparse_complex_matrix::load_hdf5 
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   itmp = m.xridx ();
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, itmp) < 0)
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL,
+               H5S_ALL, H5P_DEFAULT, itmp) < 0)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
diff --git a/libinterp/octave-value/ov-cx-sparse.h b/libinterp/octave-value/ov-cx-sparse.h
--- a/libinterp/octave-value/ov-cx-sparse.h
+++ b/libinterp/octave-value/ov-cx-sparse.h
@@ -82,62 +82,64 @@ public:
   octave_sparse_complex_matrix (const Sparse<Complex>& m)
     : octave_base_sparse<SparseComplexMatrix> (SparseComplexMatrix (m)) { }
 
   octave_sparse_complex_matrix (const octave_sparse_complex_matrix& cm)
     : octave_base_sparse<SparseComplexMatrix> (cm) { }
 
   ~octave_sparse_complex_matrix (void) { }
 
-  octave_base_value *clone (void) const { return new octave_sparse_complex_matrix (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_sparse_complex_matrix (); }
+  octave_base_value *clone (void) const
+  { return new octave_sparse_complex_matrix (*this); }
+  octave_base_value *empty_clone (void) const
+  { return new octave_sparse_complex_matrix (); }
 
   octave_base_value *try_narrowing_conversion (void);
 
   builtin_type_t builtin_type (void) const { return btyp_complex; }
 
   bool is_complex_matrix (void) const { return true; }
 
   bool is_complex_type (void) const { return true; }
 
   bool is_double_type (void) const { return true; }
 
   bool is_float_type (void) const { return true; }
 
   double double_value (bool = false) const;
 
   double scalar_value (bool frc_str_conv = false) const
-    { return double_value (frc_str_conv); }
+  { return double_value (frc_str_conv); }
 
   Matrix matrix_value (bool = false) const;
 
   Complex complex_value (bool = false) const;
 
   ComplexMatrix complex_matrix_value (bool = false) const;
 
   ComplexNDArray complex_array_value (bool = false) const;
 
   charNDArray char_array_value (bool frc_str_conv = false) const;
 
   SparseMatrix sparse_matrix_value (bool = false) const;
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const
-    { return matrix; }
+  { return matrix; }
 
   SparseBoolMatrix sparse_bool_matrix_value (bool warn = false) const;
 
 #if 0
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
-    {
-      // Yes, for compatibility, we drop the imaginary part here.
-      return os.write (matrix_value (true), block_size, output_type,
-                       skip, flt_fmt);
-    }
+  {
+    // Yes, for compatibility, we drop the imaginary part here.
+    return os.write (matrix_value (true), block_size, output_type,
+                     skip, flt_fmt);
+  }
 #endif
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
diff --git a/libinterp/octave-value/ov-dld-fcn.h b/libinterp/octave-value/ov-dld-fcn.h
--- a/libinterp/octave-value/ov-dld-fcn.h
+++ b/libinterp/octave-value/ov-dld-fcn.h
@@ -64,22 +64,22 @@ public:
 
   bool is_system_fcn_file (void) const { return system_fcn_file; }
 
   bool is_builtin_function (void) const { return false; }
 
   bool is_dld_function (void) const { return true; }
 
   static octave_dld_function* create (octave_builtin::fcn ff,
-      const octave_shlib& shl,
-      const std::string& nm = std::string (),
-      const std::string& ds = std::string ());
+                                      const octave_shlib& shl,
+                                      const std::string& nm = std::string (),
+                                      const std::string& ds = std::string ());
 
   octave_shlib get_shlib (void) const
-    { return sh_lib; }
+  { return sh_lib; }
 
 private:
 
   octave_shlib sh_lib;
 
   // The time the file was last checked to see if it needs to be
   // parsed again.
   mutable octave_time t_checked;
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -91,17 +91,18 @@ octave_fcn_handle::subsref (const std::s
                             int nargout)
 {
   return octave_fcn_handle::subsref (type, idx, nargout, 0);
 }
 
 octave_value_list
 octave_fcn_handle::subsref (const std::string& type,
                             const std::list<octave_value_list>& idx,
-                            int nargout, const std::list<octave_lvalue>* lvalue_list)
+                            int nargout,
+                            const std::list<octave_lvalue>* lvalue_list)
 {
   octave_value_list retval;
 
   switch (type[0])
     {
     case '(':
       {
         int tmp_nargout = (type.length () > 1 && nargout == 0) ? 1 : nargout;
@@ -118,17 +119,17 @@ octave_fcn_handle::subsref (const std::s
         error ("%s cannot be indexed with %c", tnm.c_str (), type[0]);
       }
       break;
 
     default:
       panic_impossible ();
     }
 
-  // FIXME -- perhaps there should be an
+  // FIXME: perhaps there should be an
   // octave_value_list::next_subsref member function?  See also
   // octave_builtin::subsref.
 
   if (idx.size () > 1)
     retval = retval(0).next_subsref (nargout, type, idx);
 
   return retval;
 }
@@ -205,17 +206,18 @@ octave_fcn_handle::do_multi_index_op (in
             }
         }
 
       if (ov_fcn.is_defined ())
         retval = ov_fcn.do_multi_index_op (nargout, args, lvalue_list);
       else if (fcn.is_defined ())
         retval = fcn.do_multi_index_op (nargout, args, lvalue_list);
       else
-        error ("%s: no method for class %s", nm.c_str (), dispatch_type.c_str ());
+        error ("%s: no method for class %s",
+               nm.c_str (), dispatch_type.c_str ());
     }
   else
     {
       // Non-overloaded function (anonymous, subfunction, private function).
       if (fcn.is_defined ())
         retval = fcn.do_multi_index_op (nargout, args, lvalue_list);
       else
         error ("%s: no longer valid function handle", nm.c_str ());
@@ -230,19 +232,21 @@ octave_fcn_handle::is_equal_to (const oc
   bool retval = fcn.is_copy_of (h.fcn) && (has_overloads == h.has_overloads);
   retval = retval && (overloads.size () == h.overloads.size ());
 
   if (retval && has_overloads)
     {
       for (int i = 0; i < btyp_num_types && retval; i++)
         retval = builtin_overloads[i].is_copy_of (h.builtin_overloads[i]);
 
-      str_ov_map::const_iterator iter = overloads.begin (), hiter = h.overloads.begin ();
+      str_ov_map::const_iterator iter = overloads.begin ();
+      str_ov_map::const_iterator hiter = h.overloads.begin ();
       for (; iter != overloads.end () && retval; iter++, hiter++)
-        retval = (iter->first == hiter->first) && (iter->second.is_copy_of (hiter->second));
+        retval = (iter->first == hiter->first)
+                 && (iter->second.is_copy_of (hiter->second));
     }
 
   return retval;
 }
 
 bool
 octave_fcn_handle::set_fcn (const std::string &octaveroot,
                             const std::string& fpath)
@@ -251,17 +255,17 @@ octave_fcn_handle::set_fcn (const std::s
 
   if (octaveroot.length () != 0
       && fpath.length () >= octaveroot.length ()
       && fpath.substr (0, octaveroot.length ()) == octaveroot
       && OCTAVE_EXEC_PREFIX != octaveroot)
     {
       // First check if just replacing matlabroot is enough
       std::string str = OCTAVE_EXEC_PREFIX +
-        fpath.substr (octaveroot.length ());
+                        fpath.substr (octaveroot.length ());
       file_stat fs (str);
 
       if (fs.exists ())
         {
           size_t xpos = str.find_last_of (file_ops::dir_sep_chars ());
 
           std::string dir_name = str.substr (0, xpos);
 
@@ -367,18 +371,18 @@ octave_fcn_handle::save_ascii (std::ostr
         = symbol_table::all_variables (f->scope (), 0);
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         {
           os << "# length: " << varlen << "\n";
 
-          for (std::list<symbol_table::symbol_record>::const_iterator p = vars.begin ();
-               p != vars.end (); p++)
+          for (std::list<symbol_table::symbol_record>::const_iterator
+               p = vars.begin (); p != vars.end (); p++)
             {
               if (! save_ascii_data (os, p->varval (0), p->name (), false, 0))
                 return os;
             }
         }
     }
   else
     {
@@ -542,18 +546,18 @@ octave_fcn_handle::save_binary (std::ost
       print_raw (buf, true);
       std::string stmp = buf.str ();
       tmp = stmp.length ();
       os.write (reinterpret_cast<char *> (&tmp), 4);
       os.write (stmp.c_str (), stmp.length ());
 
       if (varlen > 0)
         {
-          for (std::list<symbol_table::symbol_record>::const_iterator p = vars.begin ();
-               p != vars.end (); p++)
+          for (std::list<symbol_table::symbol_record>::const_iterator
+               p = vars.begin (); p != vars.end (); p++)
             {
               if (! save_binary_data (os, p->varval (0), p->name (),
                                       "", 0, save_as_floats))
                 return os;
             }
         }
     }
   else
@@ -691,17 +695,17 @@ octave_fcn_handle::load_binary (std::ist
           size_t pos1 = nm.find_first_of ("\n");
           size_t pos2 = nm.find_first_of ("\n", pos1 + 1);
           octaveroot = nm.substr (pos1 + 1, pos2 - pos1 - 1);
           fpath = nm.substr (pos2 + 1);
           nm = nm.substr (0, pos1);
         }
 
       success = set_fcn (octaveroot, fpath);
-     }
+    }
 
   return success;
 }
 
 #if defined (HAVE_HDF5)
 bool
 octave_fcn_handle::save_hdf5 (hid_t loc_id, const char *name,
                               bool save_as_floats)
@@ -819,30 +823,31 @@ octave_fcn_handle::save_hdf5 (hid_t loc_
               else
                 retval = false;
 
               H5Sclose (as_id);
             }
           else
             retval = false;
 #if HAVE_HDF5_18
-          data_hid = H5Gcreate (group_hid, "symbol table", H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+          data_hid = H5Gcreate (group_hid, "symbol table",
+                                H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
           data_hid = H5Gcreate (group_hid, "symbol table", 0);
 #endif
           if (data_hid < 0)
             {
               H5Sclose (space_hid);
               H5Tclose (type_hid);
               H5Gclose (group_hid);
               return false;
             }
 
-          for (std::list<symbol_table::symbol_record>::const_iterator p = vars.begin ();
-               p != vars.end (); p++)
+          for (std::list<symbol_table::symbol_record>::const_iterator
+               p = vars.begin (); p != vars.end (); p++)
             {
               if (! add_hdf5_data (data_hid, p->varval (0), p->name (),
                                    "", false, save_as_floats))
                 break;
             }
           H5Gclose (data_hid);
         }
     }
@@ -1427,17 +1432,17 @@ octave_fcn_handle::print_raw (std::ostre
 
 octave_value
 make_fcn_handle (const std::string& nm, bool local_funcs)
 {
   octave_value retval;
 
   // Bow to the god of compatibility.
 
-  // FIXME -- it seems ugly to put this here, but there is no single
+  // FIXME: it seems ugly to put this here, but there is no single
   // function in the parser that converts from the operator name to
   // the corresponding function name.  At least try to do it without N
   // string compares.
 
   std::string tnm = nm;
 
   size_t len = nm.length ();
 
@@ -1648,17 +1653,17 @@ make_fcn_handle (const std::string& nm, 
 %!      "&", "and";
 %!      "|", "or"};
 %! for i = 1:rows (x)
 %!   assert (functions (str2func (x{i,1})).function, x{i,2});
 %! endfor
 */
 
 DEFUN (functions, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} functions (@var{fcn_handle})\n\
 Return a struct containing information about the function handle\n\
 @var{fcn_handle}.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
@@ -1714,18 +1719,18 @@ Return a struct containing information a
                   std::list<symbol_table::symbol_record> vars
                     = symbol_table::all_variables (fu->scope (), 0);
 
                   size_t varlen = vars.size ();
 
                   if (varlen > 0)
                     {
                       octave_scalar_map ws;
-                      for (std::list<symbol_table::symbol_record>::const_iterator p = vars.begin ();
-                           p != vars.end (); p++)
+                      for (std::list<symbol_table::symbol_record>::const_iterator
+                           p = vars.begin (); p != vars.end (); p++)
                         {
                           ws.assign (p->name (), p->varval (0));
                         }
 
                       m.setfield ("workspace", ws);
                     }
                 }
               else if (fcn->is_user_function () || fcn->is_user_script ())
@@ -1746,17 +1751,17 @@ Return a struct containing information a
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (func2str, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} func2str (@var{fcn_handle})\n\
 Return a string containing the name of the function referenced by\n\
 the function handle @var{fcn_handle}.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
@@ -1783,17 +1788,17 @@ the function handle @var{fcn_handle}.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (str2func, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} str2func (@var{fcn_name})\n\
 @deftypefnx {Built-in Function} {} str2func (@var{fcn_name}, \"global\")\n\
 Return a function handle constructed from the string @var{fcn_name}.\n\
 If the optional @qcode{\"global\"} argument is passed, locally visible\n\
 functions are ignored in the lookup.\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -1826,17 +1831,17 @@ functions are ignored in the lookup.\n\
 %!    y = __testrecursionfunc (@(x) f (2*x), x, n);
 %!  endif
 %!endfunction
 %!
 %!assert (__testrecursionfunc (@(x) x, 1), 8)
 */
 
 DEFUN (is_function_handle, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_function_handle (@var{x})\n\
 Return true if @var{x} is a function handle.\n\
 @seealso{isa, typeinfo, class}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
@@ -1861,18 +1866,18 @@ Return true if @var{x} is a function han
 %!error is_function_handle (1, 2)
 */
 
 octave_fcn_binder::octave_fcn_binder (const octave_value& f,
                                       const octave_value& root,
                                       const octave_value_list& templ,
                                       const std::vector<int>& mask,
                                       int exp_nargin)
-: octave_fcn_handle (f), root_handle (root), arg_template (templ),
-  arg_mask (mask), expected_nargin (exp_nargin)
+  : octave_fcn_handle (f), root_handle (root), arg_template (templ),
+    arg_mask (mask), expected_nargin (exp_nargin)
 {
 }
 
 octave_fcn_handle *
 octave_fcn_binder::maybe_binder (const octave_value& f)
 {
   octave_fcn_handle *retval = 0;
 
@@ -1885,67 +1890,71 @@ octave_fcn_binder::maybe_binder (const o
   tree_expression *body_expr = (cmd_list->length () == 1
                                 ? cmd_list->front ()->expression () : 0);
 
 
   if (body_expr && body_expr->is_index_expression ()
       && ! (param_list && param_list->takes_varargs ()))
     {
       // It's an index expression.
-      tree_index_expression *idx_expr = dynamic_cast<tree_index_expression *> (body_expr);
+      tree_index_expression *idx_expr = dynamic_cast<tree_index_expression *>
+                                        (body_expr);
       tree_expression *head_expr = idx_expr->expression ();
       std::list<tree_argument_list *> arg_lists = idx_expr->arg_lists ();
       std::string type_tags = idx_expr->type_tags ();
 
       if (type_tags.length () == 1 && type_tags[0] == '('
           && head_expr->is_identifier ())
         {
           assert (arg_lists.size () == 1);
 
           // It's a single index expression: a(x,y,....)
-          tree_identifier *head_id = dynamic_cast<tree_identifier *> (head_expr);
+          tree_identifier *head_id =
+            dynamic_cast<tree_identifier *> (head_expr);
           tree_argument_list *arg_list = arg_lists.front ();
 
           // Build a map of input params to their position.
           std::map<std::string, int> arginmap;
           int npar = 0;
 
           if (param_list)
             {
               for (tree_parameter_list::iterator it = param_list->begin ();
                    it != param_list->end (); ++it, ++npar)
                 {
                   tree_decl_elt *elt = *it;
                   tree_identifier *id = elt ? elt->ident () : 0;
                   if (id && ! id->is_black_hole ())
-                     arginmap[id->name ()] = npar;
+                    arginmap[id->name ()] = npar;
                 }
             }
 
           if (arg_list && arg_list->length () > 0)
             {
               bool bad = false;
               int nargs = arg_list->length ();
               octave_value_list arg_template (nargs);
               std::vector<int> arg_mask (nargs);
 
-              // Verify that each argument is either a named param, a constant, or a defined identifier.
+              // Verify that each argument is either a named param, a constant,
+              // or a defined identifier.
               int iarg = 0;
               for (tree_argument_list::iterator it = arg_list->begin ();
                    it != arg_list->end (); ++it, ++iarg)
                 {
                   tree_expression *elt = *it;
                   if (elt && elt->is_constant ())
                     {
                       arg_template(iarg) = elt->rvalue1 ();
                       arg_mask[iarg] = -1;
                     }
                   else if (elt && elt->is_identifier ())
                     {
-                      tree_identifier *elt_id = dynamic_cast<tree_identifier *> (elt);
+                      tree_identifier *elt_id =
+                        dynamic_cast<tree_identifier *> (elt);
                       if (arginmap.find (elt_id->name ()) != arginmap.end ())
                         {
                           arg_mask[iarg] = arginmap[elt_id->name ()];
                         }
                       else if (elt_id->is_defined ())
                         {
                           arg_template(iarg) = elt_id->rvalue1 ();
                           arg_mask[iarg] = -1;
@@ -1964,34 +1973,34 @@ octave_fcn_binder::maybe_binder (const o
                 }
 
               octave_value root_val;
 
               if (! bad)
                 {
                   // If the head is a value, use it as root.
                   if (head_id->is_defined ())
-                     root_val = head_id->rvalue1 ();
+                    root_val = head_id->rvalue1 ();
                   else
                     {
                       // It's a name.
                       std::string head_name = head_id->name ();
                       // Function handles can't handle legacy dispatch, so
                       // we make sure it's not defined.
                       if (symbol_table::get_dispatch (head_name).size () > 0)
-                         bad = true;
+                        bad = true;
                       else
                         {
                           // Simulate try/catch.
                           unwind_protect frame;
                           interpreter_try (frame);
 
                           root_val = make_fcn_handle (head_name);
                           if (error_state)
-                             bad = true;
+                            bad = true;
                         }
                     }
                 }
 
               if (! bad)
                 {
                   // Stash proper name tags.
                   std::list<string_vector> arg_names = idx_expr->arg_names ();
@@ -2001,17 +2010,17 @@ octave_fcn_binder::maybe_binder (const o
                   retval = new octave_fcn_binder (f, root_val, arg_template,
                                                   arg_mask, npar);
                 }
             }
         }
     }
 
   if (! retval)
-     retval = new octave_fcn_handle (f, octave_fcn_handle::anonymous);
+    retval = new octave_fcn_handle (f, octave_fcn_handle::anonymous);
 
   return retval;
 }
 
 octave_value_list
 octave_fcn_binder::do_multi_index_op (int nargout,
                                       const octave_value_list& args)
 {
@@ -2026,26 +2035,26 @@ octave_fcn_binder::do_multi_index_op (in
   octave_value_list retval;
 
   if (args.length () == expected_nargin)
     {
       for (int i = 0; i < arg_template.length (); i++)
         {
           int j = arg_mask[i];
           if (j >= 0)
-             arg_template(i) = args(j); // May force a copy...
+            arg_template(i) = args(j); // May force a copy...
         }
 
-      // Make a shallow copy of arg_template, to ensure consistency throughout the following
-      // call even if we happen to get back here.
+      // Make a shallow copy of arg_template, to ensure consistency throughout
+      // the following call even if we happen to get back here.
       octave_value_list tmp (arg_template);
       retval = root_handle.do_multi_index_op (nargout, tmp, lvalue_list);
     }
   else
-     retval = octave_fcn_handle::do_multi_index_op (nargout, args, lvalue_list);
+    retval = octave_fcn_handle::do_multi_index_op (nargout, args, lvalue_list);
 
   return retval;
 }
 
 /*
 %!function r = __f (g, i)
 %!  r = g(i);
 %!endfunction
diff --git a/libinterp/octave-value/ov-fcn-handle.h b/libinterp/octave-value/ov-fcn-handle.h
--- a/libinterp/octave-value/ov-fcn-handle.h
+++ b/libinterp/octave-value/ov-fcn-handle.h
@@ -54,43 +54,46 @@ public:
 
   octave_fcn_handle (const std::string& n)
     : fcn (), nm (n), has_overloads (false), overloads () { }
 
   octave_fcn_handle (const octave_value& f,  const std::string& n = anonymous);
 
   octave_fcn_handle (const octave_fcn_handle& fh)
     : octave_base_value (fh), fcn (fh.fcn), nm (fh.nm),
-    has_overloads (fh.has_overloads), overloads ()
-   {
-     for (int i = 0; i < btyp_num_types; i++)
-       builtin_overloads[i] = fh.builtin_overloads[i];
+      has_overloads (fh.has_overloads), overloads ()
+  {
+    for (int i = 0; i < btyp_num_types; i++)
+      builtin_overloads[i] = fh.builtin_overloads[i];
 
-     overloads = fh.overloads;
-   }
+    overloads = fh.overloads;
+  }
 
   ~octave_fcn_handle (void) { }
 
-  octave_base_value *clone (void) const { return new octave_fcn_handle (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_fcn_handle (); }
+  octave_base_value *clone (void) const
+  { return new octave_fcn_handle (*this); }
+  octave_base_value *empty_clone (void) const
+  { return new octave_fcn_handle (); }
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx)
-    {
-      octave_value_list tmp = subsref (type, idx, 1);
-      return tmp.length () > 0 ? tmp(0) : octave_value ();
-    }
+  {
+    octave_value_list tmp = subsref (type, idx, 1);
+    return tmp.length () > 0 ? tmp(0) : octave_value ();
+  }
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              int nargout);
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
-                             int nargout, const std::list<octave_lvalue>* lvalue_list);
+                             int nargout,
+                             const std::list<octave_lvalue>* lvalue_list);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args,
                      const std::list<octave_lvalue>* lvalue_list);
 
@@ -100,42 +103,43 @@ public:
 
   builtin_type_t builtin_type (void) const { return btyp_func_handle; }
 
   bool is_overloaded (void) const { return has_overloads; }
 
   dim_vector dims (void) const { static dim_vector dv (1, 1); return dv; }
 
   octave_function *function_value (bool = false)
-    { return fcn.function_value (); }
+  { return fcn.function_value (); }
 
   octave_user_function *user_function_value (bool = false)
-    { return fcn.user_function_value (); }
+  { return fcn.user_function_value (); }
 
   octave_fcn_handle *fcn_handle_value (bool = false) { return this; }
 
   octave_value fcn_val (void) const { return fcn; }
 
   std::string fcn_name (void) const { return nm; }
 
   void set_overload (builtin_type_t btyp, const octave_value& ov_fcn)
-    {
-      if (btyp != btyp_unknown)
-        {
-          has_overloads = true;
-          builtin_overloads[btyp] = ov_fcn;
-        }
+  {
+    if (btyp != btyp_unknown)
+      {
+        has_overloads = true;
+        builtin_overloads[btyp] = ov_fcn;
+      }
 
-    }
+  }
 
-  void set_overload (const std::string& dispatch_type, const octave_value& ov_fcn)
-    {
-      has_overloads = true;
-      overloads[dispatch_type] = ov_fcn;
-    }
+  void set_overload (const std::string& dispatch_type,
+                     const octave_value& ov_fcn)
+  {
+    has_overloads = true;
+    overloads[dispatch_type] = ov_fcn;
+  }
 
   bool is_equal_to (const octave_fcn_handle&) const;
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -629,17 +629,17 @@ octave_fcn_inline::print_raw (std::ostre
 
 octave_value
 octave_fcn_inline::convert_to_str_internal (bool, bool, char type) const
 {
   return octave_value (fcn_text (), type);
 }
 
 DEFUNX ("inline", Finline, args, ,
-  "-*- texinfo -*-\n\
+        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} inline (@var{str})\n\
 @deftypefnx {Built-in Function} {} inline (@var{str}, @var{arg1}, @dots{})\n\
 @deftypefnx {Built-in Function} {} inline (@var{str}, @var{n})\n\
 Create an inline function from the character string @var{str}.\n\
 If called with a single argument, the arguments of the generated\n\
 function are extracted from the function itself.  The generated\n\
 function arguments will then be in alphabetical order.  It should\n\
 be noted that i, and j are ignored as arguments due to the\n\
@@ -801,17 +801,17 @@ If the second argument is an integer @va
 
               for (int i = 1; i < nargin; i++)
                 {
                   if (args(i).is_string ())
                     {
                       std::string s = args(i).string_value ();
                       fargs(i-1) = s;
                     }
-                    else
+                  else
                     {
                       error ("inline: expecting string arguments");
                       return retval;
                     }
                 }
             }
 
           retval = octave_value (new octave_fcn_inline (fun, fargs));
@@ -838,17 +838,17 @@ If the second argument is an integer @va
 %!error inline ()
 %!error <STR argument must be a string> inline (1)
 %!error <N must be an integer> inline ("2", ones (2,2))
 %!error <N must be a positive integer> inline ("2", -1)
 %!error <expecting string arguments> inline ("2", "x", -1, "y")
 */
 
 DEFUN (formula, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} formula (@var{fun})\n\
 Return a character string representing the inline function @var{fun}.\n\
 Note that @code{char (@var{fun})} is equivalent to\n\
 @code{formula (@var{fun})}.\n\
 @seealso{argnames, inline, vectorize}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -876,17 +876,17 @@ Note that @code{char (@var{fun})} is equ
 
 ## Test input validation
 %!error formula ()
 %!error formula (1, 2)
 %!error <FUN must be an inline function> formula (1)
 */
 
 DEFUN (argnames, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} argnames (@var{fun})\n\
 Return a cell array of character strings containing the names of\n\
 the arguments of the inline function @var{fun}.\n\
 @seealso{inline, formula, vectorize}\n\
 @end deftypefn")
 {
   octave_value retval;
 
@@ -923,17 +923,17 @@ the arguments of the inline function @va
 
 ## Test input validation
 %!error argnames ()
 %!error argnames (1, 2)
 %!error <FUN must be an inline function> argnames (1)
 */
 
 DEFUN (vectorize, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} vectorize (@var{fun})\n\
 Create a vectorized version of the inline function @var{fun}\n\
 by replacing all occurrences of @code{*}, @code{/}, etc., with\n\
 @code{.*}, @code{./}, etc.\n\
 \n\
 This may be useful, for example, when using inline functions with\n\
 numerical integration or optimization where a vector-valued function\n\
 is expected.\n\
diff --git a/libinterp/octave-value/ov-fcn-inline.h b/libinterp/octave-value/ov-fcn-inline.h
--- a/libinterp/octave-value/ov-fcn-inline.h
+++ b/libinterp/octave-value/ov-fcn-inline.h
@@ -49,18 +49,20 @@ public:
   octave_fcn_inline (const std::string& f, const string_vector& a,
                      const std::string& n = std::string ());
 
   octave_fcn_inline (const octave_fcn_inline& fi)
     : octave_fcn_handle (fi), iftext (fi.iftext), ifargs (fi.ifargs) { }
 
   ~octave_fcn_inline (void) { }
 
-  octave_base_value *clone (void) const { return new octave_fcn_inline (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_fcn_inline (); }
+  octave_base_value *clone (void) const
+  { return new octave_fcn_inline (*this); }
+  octave_base_value *empty_clone (void) const
+  { return new octave_fcn_inline (); }
 
   bool is_inline_function (void) const { return true; }
 
   octave_fcn_inline *fcn_inline_value (bool = false) { return this; }
 
   std::string fcn_text (void) const { return iftext; }
 
   string_vector fcn_arg_names (void) const { return ifargs; }
diff --git a/libinterp/octave-value/ov-fcn.h b/libinterp/octave-value/ov-fcn.h
--- a/libinterp/octave-value/ov-fcn.h
+++ b/libinterp/octave-value/ov-fcn.h
@@ -70,28 +70,28 @@ public:
 
   virtual symbol_table::scope_id parent_fcn_scope (void) const { return -1; }
 
   virtual void mark_fcn_file_up_to_date (const octave_time&) { }
 
   virtual symbol_table::scope_id scope (void) { return -1; }
 
   virtual octave_time time_parsed (void) const
-    { return octave_time (static_cast<time_t> (0)); }
+  { return octave_time (static_cast<time_t> (0)); }
 
   virtual octave_time time_checked (void) const
-    { return octave_time (static_cast<time_t> (0)); }
+  { return octave_time (static_cast<time_t> (0)); }
 
   virtual bool is_subfunction (void) const { return false; }
 
   virtual bool is_class_constructor (const std::string& = std::string ()) const
-    { return false; }
+  { return false; }
 
   virtual bool is_class_method (const std::string& = std::string ()) const
-    { return false; }
+  { return false; }
 
   virtual bool takes_varargs (void) const { return false; }
 
   virtual bool takes_var_return (void) const { return false; }
 
   void stash_dispatch_class (const std::string& nm) { xdispatch_class = nm; }
 
   std::string dispatch_class (void) const { return xdispatch_class; }
@@ -101,21 +101,21 @@ public:
   {
     private_function = true;
     xdispatch_class = cname;
   }
 
   bool is_private_function (void) const { return private_function; }
 
   bool is_private_function_of_class (const std::string& nm) const
-    { return private_function && xdispatch_class == nm; }
+  { return private_function && xdispatch_class == nm; }
 
   virtual bool
   is_anonymous_function_of_class (const std::string& = std::string ()) const
-    { return false; }
+  { return false; }
 
   std::string dir_name (void) const { return my_dir_name; }
 
   void stash_dir_name (const std::string& dir) { my_dir_name = dir; }
 
   void lock (void)
   {
     this->lock_subfunctions ();
diff --git a/libinterp/octave-value/ov-float.cc b/libinterp/octave-value/ov-float.cc
--- a/libinterp/octave-value/ov-float.cc
+++ b/libinterp/octave-value/ov-float.cc
@@ -50,28 +50,29 @@ along with Octave; see the file COPYING.
 
 #include "ls-oct-ascii.h"
 #include "ls-hdf5.h"
 
 template class octave_base_scalar<float>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_float_scalar);
 
-DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_scalar, "float scalar", "single");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_scalar, "float scalar",
+                                     "single");
 
 octave_value
 octave_float_scalar::do_index_op (const octave_value_list& idx, bool resize_ok)
 {
-  // FIXME -- this doesn't solve the problem of
+  // FIXME: this doesn't solve the problem of
   //
   //   a = 1; a([1,1], [1,1], [1,1])
   //
   // and similar constructions.  Hmm...
 
-  // FIXME -- using this constructor avoids narrowing the
+  // FIXME: using this constructor avoids narrowing the
   // 1x1 matrix back to a scalar value.  Need a better solution
   // to this problem.
 
   octave_value tmp (new octave_float_matrix (float_matrix_value ()));
 
   return tmp.do_index_op (idx, resize_ok);
 }
 
@@ -112,17 +113,17 @@ octave_float_scalar::convert_to_str_inte
   if (xisnan (scalar))
     gripe_nan_to_character_conversion ();
   else
     {
       int ival = NINT (scalar);
 
       if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
         {
-          // FIXME -- is there something better we could do?
+          // FIXME: is there something better we could do?
 
           ival = 0;
 
           ::warning ("range error for conversion to character value");
         }
 
       retval = octave_value (std::string (1, static_cast<char> (ival)), type);
     }
@@ -163,17 +164,17 @@ octave_float_scalar::save_binary (std::o
   float dtmp = float_value ();
   os.write (reinterpret_cast<char *> (&dtmp), 4);
 
   return true;
 }
 
 bool
 octave_float_scalar::load_binary (std::istream& is, bool swap,
-                            oct_mach_info::float_format fmt)
+                                  oct_mach_info::float_format fmt)
 {
   char tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
 
   float dtmp;
   read_floats (is, &dtmp, static_cast<save_type> (tmp), 1, swap, fmt);
   if (error_state || ! is)
@@ -182,17 +183,17 @@ octave_float_scalar::load_binary (std::i
   scalar = dtmp;
   return true;
 }
 
 #if defined (HAVE_HDF5)
 
 bool
 octave_float_scalar::save_hdf5 (hid_t loc_id, const char *name,
-                          bool /* save_as_floats */)
+                                bool /* save_as_floats */)
 {
   hsize_t dimens[3];
   hid_t space_hid = -1, data_hid = -1;
   bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0) return false;
 #if HAVE_HDF5_18
@@ -326,17 +327,18 @@ octave_float_scalar::map (unary_mapper_t
       SCALAR_MAPPER (xsignbit, xsignbit);
 
     default:
       return octave_base_value::map (umap);
     }
 }
 
 bool
-octave_float_scalar::fast_elem_insert_self (void *where, builtin_type_t btyp) const
+octave_float_scalar::fast_elem_insert_self (void *where,
+                                            builtin_type_t btyp) const
 {
 
   // Support inline real->complex conversion.
   if (btyp == btyp_float)
     {
       *(reinterpret_cast<float *>(where)) = scalar;
       return true;
     }
diff --git a/libinterp/octave-value/ov-float.h b/libinterp/octave-value/ov-float.h
--- a/libinterp/octave-value/ov-float.h
+++ b/libinterp/octave-value/ov-float.h
@@ -60,72 +60,74 @@ public:
   octave_float_scalar (float d)
     : octave_base_scalar<float> (d) { }
 
   octave_float_scalar (const octave_float_scalar& s)
     : octave_base_scalar<float> (s) { }
 
   ~octave_float_scalar (void) { }
 
-  octave_base_value *clone (void) const { return new octave_float_scalar (*this); }
+  octave_base_value *clone (void) const
+  { return new octave_float_scalar (*this); }
 
   // We return an octave_matrix here instead of an octave_float_scalar so
   // that in expressions like A(2,2,2) = 2 (for A previously
   // undefined), A will be empty instead of a 1x1 object.
-  octave_base_value *empty_clone (void) const { return new octave_float_matrix (); }
+  octave_base_value *empty_clone (void) const
+  { return new octave_float_matrix (); }
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false);
 
   idx_vector index_vector (void) const { return idx_vector (scalar); }
 
   octave_value any (int = 0) const
-    { return (scalar != 0 && ! lo_ieee_isnan (scalar)); }
+  { return (scalar != 0 && ! lo_ieee_isnan (scalar)); }
 
   builtin_type_t builtin_type (void) const { return btyp_float; }
 
   bool is_real_scalar (void) const { return true; }
 
   bool is_real_type (void) const { return true; }
 
   bool is_single_type (void) const { return true; }
 
   bool is_float_type (void) const { return true; }
 
   int8NDArray
   int8_array_value (void) const
-    { return int8NDArray (dim_vector (1, 1), scalar); }
+  { return int8NDArray (dim_vector (1, 1), scalar); }
 
   int16NDArray
   int16_array_value (void) const
-    { return int16NDArray (dim_vector (1, 1), scalar); }
+  { return int16NDArray (dim_vector (1, 1), scalar); }
 
   int32NDArray
   int32_array_value (void) const
-    { return int32NDArray (dim_vector (1, 1), scalar); }
+  { return int32NDArray (dim_vector (1, 1), scalar); }
 
   int64NDArray
   int64_array_value (void) const
-    { return int64NDArray (dim_vector (1, 1), scalar); }
+  { return int64NDArray (dim_vector (1, 1), scalar); }
 
   uint8NDArray
   uint8_array_value (void) const
-    { return uint8NDArray (dim_vector (1, 1), scalar); }
+  { return uint8NDArray (dim_vector (1, 1), scalar); }
 
   uint16NDArray
   uint16_array_value (void) const
-    { return uint16NDArray (dim_vector (1, 1), scalar); }
+  { return uint16NDArray (dim_vector (1, 1), scalar); }
 
   uint32NDArray
   uint32_array_value (void) const
-    { return uint32NDArray (dim_vector (1, 1), scalar); }
+  { return uint32NDArray (dim_vector (1, 1), scalar); }
 
   uint64NDArray
   uint64_array_value (void) const
-    { return uint64NDArray (dim_vector (1, 1), scalar); }
+  { return uint64NDArray (dim_vector (1, 1), scalar); }
 
 #define DEFINE_INT_SCALAR_VALUE(TYPE) \
   octave_ ## TYPE \
   TYPE ## _scalar_value (void) const \
     { return octave_ ## TYPE (scalar); }
 
   DEFINE_INT_SCALAR_VALUE (int8)
   DEFINE_INT_SCALAR_VALUE (int16)
@@ -133,60 +135,62 @@ public:
   DEFINE_INT_SCALAR_VALUE (int64)
   DEFINE_INT_SCALAR_VALUE (uint8)
   DEFINE_INT_SCALAR_VALUE (uint16)
   DEFINE_INT_SCALAR_VALUE (uint32)
   DEFINE_INT_SCALAR_VALUE (uint64)
 
 #undef DEFINE_INT_SCALAR_VALUE
 
-  double double_value (bool = false) const { return static_cast<double> (scalar); }
+  double double_value (bool = false) const
+  { return static_cast<double> (scalar); }
 
   float float_value (bool = false) const { return scalar; }
 
-  double scalar_value (bool = false) const { return static_cast<double> (scalar); }
+  double scalar_value (bool = false) const
+  { return static_cast<double> (scalar); }
 
   float float_scalar_value (bool = false) const { return scalar; }
 
   Matrix matrix_value (bool = false) const
-    { return Matrix (1, 1, scalar); }
+  { return Matrix (1, 1, scalar); }
 
   FloatMatrix float_matrix_value (bool = false) const
-    { return FloatMatrix (1, 1, scalar); }
+  { return FloatMatrix (1, 1, scalar); }
 
   NDArray array_value (bool = false) const
-    { return NDArray (dim_vector (1, 1), scalar); }
+  { return NDArray (dim_vector (1, 1), scalar); }
 
   FloatNDArray float_array_value (bool = false) const
-    { return FloatNDArray (dim_vector (1, 1), scalar); }
+  { return FloatNDArray (dim_vector (1, 1), scalar); }
 
   SparseMatrix sparse_matrix_value (bool = false) const
-    { return SparseMatrix (Matrix (1, 1, scalar)); }
+  { return SparseMatrix (Matrix (1, 1, scalar)); }
 
   // FIXME Need SparseComplexMatrix (Matrix) constructor!!!
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const
-    { return SparseComplexMatrix (sparse_matrix_value ()); }
+  { return SparseComplexMatrix (sparse_matrix_value ()); }
 
   octave_value resize (const dim_vector& dv, bool fill = false) const;
 
   Complex complex_value (bool = false) const { return scalar; }
 
   FloatComplex float_complex_value (bool = false) const { return scalar; }
 
   ComplexMatrix complex_matrix_value (bool = false) const
-    { return  ComplexMatrix (1, 1, Complex (scalar)); }
+  { return  ComplexMatrix (1, 1, Complex (scalar)); }
 
   FloatComplexMatrix float_complex_matrix_value (bool = false) const
-    { return  FloatComplexMatrix (1, 1, FloatComplex (scalar)); }
+  { return  FloatComplexMatrix (1, 1, FloatComplex (scalar)); }
 
   ComplexNDArray complex_array_value (bool = false) const
-    { return ComplexNDArray (dim_vector (1, 1), Complex (scalar)); }
+  { return ComplexNDArray (dim_vector (1, 1), Complex (scalar)); }
 
   FloatComplexNDArray float_complex_array_value (bool = false) const
-    { return FloatComplexNDArray (dim_vector (1, 1), FloatComplex (scalar)); }
+  { return FloatComplexNDArray (dim_vector (1, 1), FloatComplex (scalar)); }
 
   charNDArray
   char_array_value (bool = false) const
   {
     charNDArray retval (dim_vector (1, 1));
     retval(0) = static_cast<char> (scalar);
     return retval;
   }
@@ -232,20 +236,20 @@ public:
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
-    {
-      return os.write (array_value (), block_size, output_type,
-                       skip, flt_fmt);
-    }
+  {
+    return os.write (array_value (), block_size, output_type,
+                     skip, flt_fmt);
+  }
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
   bool fast_elem_insert_self (void *where, builtin_type_t btyp) const;
 
 private:
diff --git a/libinterp/octave-value/ov-flt-complex.cc b/libinterp/octave-value/ov-flt-complex.cc
--- a/libinterp/octave-value/ov-flt-complex.cc
+++ b/libinterp/octave-value/ov-flt-complex.cc
@@ -66,23 +66,23 @@ octave_float_complex::try_narrowing_conv
     retval = new octave_float_scalar (std::real (scalar));
 
   return retval;
 }
 
 octave_value
 octave_float_complex::do_index_op (const octave_value_list& idx, bool resize_ok)
 {
-  // FIXME -- this doesn't solve the problem of
+  // FIXME: this doesn't solve the problem of
   //
   //   a = i; a([1,1], [1,1], [1,1])
   //
   // and similar constructions.  Hmm...
 
-  // FIXME -- using this constructor avoids narrowing the
+  // FIXME: using this constructor avoids narrowing the
   // 1x1 matrix back to a scalar value.  Need a better solution
   // to this problem.
 
   octave_value tmp (new octave_float_complex_matrix (float_complex_matrix_value ()));
 
   return tmp.do_index_op (idx, resize_ok);
 }
 
@@ -227,17 +227,19 @@ octave_float_complex::resize (const dim_
 
       return retval;
     }
 }
 
 octave_value
 octave_float_complex::diag (octave_idx_type m, octave_idx_type n) const
 {
-  return FloatComplexDiagMatrix (Array<FloatComplex> (dim_vector (1, 1), scalar), m, n);
+  return
+    FloatComplexDiagMatrix (Array<FloatComplex> (dim_vector (1, 1), scalar),
+                            m, n);
 }
 
 bool
 octave_float_complex::save_ascii (std::ostream& os)
 {
   FloatComplex c = float_complex_value ();
 
   octave_write_float_complex (os, c);
@@ -270,37 +272,37 @@ octave_float_complex::save_binary (std::
   FloatComplex ctmp = float_complex_value ();
   os.write (reinterpret_cast<char *> (&ctmp), 8);
 
   return true;
 }
 
 bool
 octave_float_complex::load_binary (std::istream& is, bool swap,
-                             oct_mach_info::float_format fmt)
+                                   oct_mach_info::float_format fmt)
 {
   char tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 1))
     return false;
 
   FloatComplex ctmp;
   read_floats (is, reinterpret_cast<float *> (&ctmp),
-                static_cast<save_type> (tmp), 2, swap, fmt);
+               static_cast<save_type> (tmp), 2, swap, fmt);
   if (error_state || ! is)
     return false;
 
   scalar = ctmp;
   return true;
 }
 
 #if defined (HAVE_HDF5)
 
 bool
 octave_float_complex::save_hdf5 (hid_t loc_id, const char *name,
-                           bool /* save_as_floats */)
+                                 bool /* save_as_floats */)
 {
   hsize_t dimens[3];
   hid_t space_hid = -1, type_hid = -1, data_hid = -1;
   bool retval = true;
 
   space_hid = H5Screate_simple (0, dimens, 0);
   if (space_hid < 0)
     return false;
diff --git a/libinterp/octave-value/ov-flt-complex.h b/libinterp/octave-value/ov-flt-complex.h
--- a/libinterp/octave-value/ov-flt-complex.h
+++ b/libinterp/octave-value/ov-flt-complex.h
@@ -58,70 +58,71 @@ public:
   octave_float_complex (const FloatComplex& c)
     : octave_base_scalar<FloatComplex> (c) { }
 
   octave_float_complex (const octave_float_complex& c)
     : octave_base_scalar<FloatComplex> (c) { }
 
   ~octave_float_complex (void) { }
 
-  octave_base_value *clone (void) const { return new octave_float_complex (*this); }
+  octave_base_value *clone (void) const
+  { return new octave_float_complex (*this); }
 
   // We return an octave_float_complex_matrix object here instead of an
   // octave_float_complex object so that in expressions like A(2,2,2) = 2
   // (for A previously undefined), A will be empty instead of a 1x1
   // object.
   octave_base_value *empty_clone (void) const
-    { return new octave_float_complex_matrix (); }
+  { return new octave_float_complex_matrix (); }
 
   octave_base_value *try_narrowing_conversion (void);
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false);
 
   octave_value any (int = 0) const
-    {
-      return (scalar != FloatComplex (0, 0)
-              && ! (lo_ieee_isnan (std::real (scalar))
-                    || lo_ieee_isnan (std::imag (scalar))));
-    }
+  {
+    return (scalar != FloatComplex (0, 0)
+            && ! (lo_ieee_isnan (std::real (scalar))
+                  || lo_ieee_isnan (std::imag (scalar))));
+  }
 
   builtin_type_t builtin_type (void) const { return btyp_float_complex; }
 
   bool is_complex_scalar (void) const { return true; }
 
   bool is_complex_type (void) const { return true; }
 
   bool is_single_type (void) const { return true; }
 
   bool is_float_type (void) const { return true; }
 
   double double_value (bool = false) const;
 
   float float_value (bool = false) const;
 
   double scalar_value (bool frc_str_conv = false) const
-    { return double_value (frc_str_conv); }
+  { return double_value (frc_str_conv); }
 
   float float_scalar_value (bool frc_str_conv = false) const
-    { return float_value (frc_str_conv); }
+  { return float_value (frc_str_conv); }
 
   Matrix matrix_value (bool = false) const;
 
   FloatMatrix float_matrix_value (bool = false) const;
 
   NDArray array_value (bool = false) const;
 
   FloatNDArray float_array_value (bool = false) const;
 
   SparseMatrix sparse_matrix_value (bool = false) const
-    { return SparseMatrix (matrix_value ()); }
+  { return SparseMatrix (matrix_value ()); }
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const
-    { return SparseComplexMatrix (complex_matrix_value ()); }
+  { return SparseComplexMatrix (complex_matrix_value ()); }
 
   octave_value resize (const dim_vector& dv, bool fill = false) const;
 
   Complex complex_value (bool = false) const;
 
   FloatComplex float_complex_value (bool = false) const;
 
   ComplexMatrix complex_matrix_value (bool = false) const;
@@ -171,21 +172,21 @@ public:
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
-    {
-      // Yes, for compatibility, we drop the imaginary part here.
-      return os.write (array_value (true), block_size, output_type,
-                       skip, flt_fmt);
-    }
+  {
+    // Yes, for compatibility, we drop the imaginary part here.
+    return os.write (array_value (true), block_size, output_type,
+                     skip, flt_fmt);
+  }
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
diff --git a/libinterp/octave-value/ov-flt-cx-diag.cc b/libinterp/octave-value/ov-flt-cx-diag.cc
--- a/libinterp/octave-value/ov-flt-cx-diag.cc
+++ b/libinterp/octave-value/ov-flt-cx-diag.cc
@@ -128,17 +128,18 @@ octave_float_complex_diag_matrix::map (u
     case umap_real:
       return ::real (matrix);
     case umap_conj:
       return ::conj (matrix);
     case umap_imag:
       return ::imag (matrix);
     case umap_sqrt:
       {
-        FloatComplexColumnVector tmp = matrix.extract_diag ().map<FloatComplex> (std::sqrt);
+        FloatComplexColumnVector tmp = matrix.extract_diag ().map<FloatComplex>
+                                       (std::sqrt);
         FloatComplexDiagMatrix retval (tmp);
         retval.resize (matrix.rows (), matrix.columns ());
         return retval;
       }
     default:
       return to_dense ().map (umap);
     }
 }
@@ -150,32 +151,32 @@ octave_float_complex_diag_matrix::save_b
 {
 
   int32_t r = matrix.rows (), c = matrix.cols ();
   os.write (reinterpret_cast<char *> (&r), 4);
   os.write (reinterpret_cast<char *> (&c), 4);
 
   FloatComplexMatrix m = FloatComplexMatrix (matrix.extract_diag ());
   save_type st = LS_FLOAT;
-  if (matrix.length () > 4096) // FIXME -- make this configurable.
+  if (matrix.length () > 4096) // FIXME: make this configurable.
     {
       float max_val, min_val;
       if (m.all_integers (max_val, min_val))
         st = get_save_type (max_val, min_val);
     }
 
   const FloatComplex *mtmp = m.data ();
   write_floats (os, reinterpret_cast<const float *> (mtmp), st, 2 * m.numel ());
 
   return true;
 }
 
 bool
 octave_float_complex_diag_matrix::load_binary (std::istream& is, bool swap,
-                                 oct_mach_info::float_format fmt)
+                                               oct_mach_info::float_format fmt)
 {
   int32_t r, c;
   char tmp;
   if (! (is.read (reinterpret_cast<char *> (&r), 4)
          && is.read (reinterpret_cast<char *> (&c), 4)
          && is.read (reinterpret_cast<char *> (&tmp), 1)))
     return false;
   if (swap)
diff --git a/libinterp/octave-value/ov-flt-cx-diag.h b/libinterp/octave-value/ov-flt-cx-diag.h
--- a/libinterp/octave-value/ov-flt-cx-diag.h
+++ b/libinterp/octave-value/ov-flt-cx-diag.h
@@ -43,18 +43,20 @@ public:
   octave_float_complex_diag_matrix (const FloatComplexDiagMatrix& m)
     : octave_base_diag<FloatComplexDiagMatrix, FloatComplexMatrix> (m) { }
 
   octave_float_complex_diag_matrix (const octave_float_complex_diag_matrix& m)
     : octave_base_diag<FloatComplexDiagMatrix, FloatComplexMatrix> (m) { }
 
   ~octave_float_complex_diag_matrix (void) { }
 
-  octave_base_value *clone (void) const { return new octave_float_complex_diag_matrix (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_float_complex_diag_matrix (); }
+  octave_base_value *clone (void) const
+  { return new octave_float_complex_diag_matrix (*this); }
+  octave_base_value *empty_clone (void) const
+  { return new octave_float_complex_diag_matrix (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
   octave_base_value *try_narrowing_conversion (void);
 
   builtin_type_t builtin_type (void) const { return btyp_float_complex; }
 
   bool is_complex_matrix (void) const { return true; }
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -436,32 +436,32 @@ octave_float_complex_matrix::save_binary
   for (int i = 0; i < d.length (); i++)
     {
       tmp = d(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   FloatComplexNDArray m = complex_array_value ();
   save_type st = LS_FLOAT;
-  if (d.numel () > 4096) // FIXME -- make this configurable.
+  if (d.numel () > 4096) // FIXME: make this configurable.
     {
       float max_val, min_val;
       if (m.all_integers (max_val, min_val))
         st = get_save_type (max_val, min_val);
     }
 
   const FloatComplex *mtmp = m.data ();
   write_floats (os, reinterpret_cast<const float *> (mtmp), st, 2 * d.numel ());
 
   return true;
 }
 
 bool
 octave_float_complex_matrix::load_binary (std::istream& is, bool swap,
-                                 oct_mach_info::float_format fmt)
+                                          oct_mach_info::float_format fmt)
 {
   char tmp;
   int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims < 0)
@@ -493,17 +493,17 @@ octave_float_complex_matrix::load_binary
         }
 
       if (! is.read (reinterpret_cast<char *> (&tmp), 1))
         return false;
 
       FloatComplexNDArray m(dv);
       FloatComplex *im = m.fortran_vec ();
       read_floats (is, reinterpret_cast<float *> (im),
-                    static_cast<save_type> (tmp), 2 * dv.numel (), swap, fmt);
+                   static_cast<save_type> (tmp), 2 * dv.numel (), swap, fmt);
       if (error_state || ! is)
         return false;
       matrix = m;
     }
   else
     {
       int32_t nr, nc;
       nr = mdims;
@@ -512,17 +512,17 @@ octave_float_complex_matrix::load_binary
       if (swap)
         swap_bytes<4> (&nc);
       if (! is.read (reinterpret_cast<char *> (&tmp), 1))
         return false;
       FloatComplexMatrix m (nr, nc);
       FloatComplex *im = m.fortran_vec ();
       octave_idx_type len = nr * nc;
       read_floats (is, reinterpret_cast<float *> (im),
-                    static_cast<save_type> (tmp), 2*len, swap, fmt);
+                   static_cast<save_type> (tmp), 2*len, swap, fmt);
       if (error_state || ! is)
         return false;
       matrix = m;
     }
   return true;
 }
 
 #if defined (HAVE_HDF5)
@@ -609,17 +609,17 @@ octave_float_complex_matrix::load_hdf5 (
 {
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize (dv);
   if (empty)
-      return (empty > 0);
+    return (empty > 0);
 
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t type_hid = H5Dget_type (data_hid);
 
@@ -678,17 +678,17 @@ octave_float_complex_matrix::load_hdf5 (
 
   return retval;
 }
 
 #endif
 
 void
 octave_float_complex_matrix::print_raw (std::ostream& os,
-                                  bool pr_as_read_syntax) const
+                                        bool pr_as_read_syntax) const
 {
   octave_print_internal (os, matrix, pr_as_read_syntax,
                          current_print_indent_level ());
 }
 
 mxArray *
 octave_float_complex_matrix::as_mxArray (void) const
 {
diff --git a/libinterp/octave-value/ov-flt-cx-mat.h b/libinterp/octave-value/ov-flt-cx-mat.h
--- a/libinterp/octave-value/ov-flt-cx-mat.h
+++ b/libinterp/octave-value/ov-flt-cx-mat.h
@@ -77,18 +77,20 @@ public:
   octave_float_complex_matrix (const FloatComplexColumnVector& v)
     : octave_base_matrix<FloatComplexNDArray> (FloatComplexMatrix (v)) { }
 
   octave_float_complex_matrix (const octave_float_complex_matrix& cm)
     : octave_base_matrix<FloatComplexNDArray> (cm) { }
 
   ~octave_float_complex_matrix (void) { }
 
-  octave_base_value *clone (void) const { return new octave_float_complex_matrix (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_float_complex_matrix (); }
+  octave_base_value *clone (void) const
+  { return new octave_float_complex_matrix (*this); }
+  octave_base_value *empty_clone (void) const
+  { return new octave_float_complex_matrix (); }
 
   octave_base_value *try_narrowing_conversion (void);
 
   builtin_type_t builtin_type (void) const { return btyp_float_complex; }
 
   bool is_complex_matrix (void) const { return true; }
 
   bool is_complex_type (void) const { return true; }
@@ -97,20 +99,20 @@ public:
 
   bool is_float_type (void) const { return true; }
 
   double double_value (bool = false) const;
 
   float float_value (bool = false) const;
 
   double scalar_value (bool frc_str_conv = false) const
-    { return double_value (frc_str_conv); }
+  { return double_value (frc_str_conv); }
 
   float float_scalar_value (bool frc_str_conv = false) const
-    { return float_value (frc_str_conv); }
+  { return float_value (frc_str_conv); }
 
   Matrix matrix_value (bool = false) const;
 
   FloatMatrix float_matrix_value (bool = false) const;
 
   Complex complex_value (bool = false) const;
 
   FloatComplex float_complex_value (bool = false) const;
@@ -154,21 +156,21 @@ public:
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
-    {
-      // Yes, for compatibility, we drop the imaginary part here.
-      return os.write (matrix_value (true), block_size, output_type,
-                       skip, flt_fmt);
-    }
+  {
+    // Yes, for compatibility, we drop the imaginary part here.
+    return os.write (matrix_value (true), block_size, output_type,
+                     skip, flt_fmt);
+  }
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
diff --git a/libinterp/octave-value/ov-flt-re-diag.cc b/libinterp/octave-value/ov-flt-re-diag.cc
--- a/libinterp/octave-value/ov-flt-re-diag.cc
+++ b/libinterp/octave-value/ov-flt-re-diag.cc
@@ -98,17 +98,18 @@ octave_float_diag_matrix::map (unary_map
       return matrix.abs ();
     case umap_real:
     case umap_conj:
       return matrix;
     case umap_imag:
       return DiagMatrix (matrix.rows (), matrix.cols (), 0.0);
     case umap_sqrt:
       {
-        FloatComplexColumnVector tmp = matrix.extract_diag ().map<FloatComplex> (rc_sqrt);
+        FloatComplexColumnVector tmp = matrix.extract_diag ().map<FloatComplex>
+                                       (rc_sqrt);
         FloatComplexDiagMatrix retval (tmp);
         retval.resize (matrix.rows (), matrix.columns ());
         return retval;
       }
     default:
       return to_dense ().map (umap);
     }
 }
@@ -119,32 +120,32 @@ octave_float_diag_matrix::save_binary (s
 {
 
   int32_t r = matrix.rows (), c = matrix.cols ();
   os.write (reinterpret_cast<char *> (&r), 4);
   os.write (reinterpret_cast<char *> (&c), 4);
 
   FloatMatrix m = FloatMatrix (matrix.extract_diag ());
   save_type st = LS_FLOAT;
-  if (matrix.length () > 8192) // FIXME -- make this configurable.
+  if (matrix.length () > 8192) // FIXME: make this configurable.
     {
       float max_val, min_val;
       if (m.all_integers (max_val, min_val))
         st = get_save_type (max_val, min_val);
     }
 
   const float *mtmp = m.data ();
   write_floats (os, mtmp, st, m.numel ());
 
   return true;
 }
 
 bool
 octave_float_diag_matrix::load_binary (std::istream& is, bool swap,
-                                 oct_mach_info::float_format fmt)
+                                       oct_mach_info::float_format fmt)
 {
   int32_t r, c;
   char tmp;
   if (! (is.read (reinterpret_cast<char *> (&r), 4)
          && is.read (reinterpret_cast<char *> (&c), 4)
          && is.read (reinterpret_cast<char *> (&tmp), 1)))
     return false;
   if (swap)
diff --git a/libinterp/octave-value/ov-flt-re-diag.h b/libinterp/octave-value/ov-flt-re-diag.h
--- a/libinterp/octave-value/ov-flt-re-diag.h
+++ b/libinterp/octave-value/ov-flt-re-diag.h
@@ -43,18 +43,20 @@ public:
   octave_float_diag_matrix (const FloatDiagMatrix& m)
     : octave_base_diag<FloatDiagMatrix, FloatMatrix> (m) { }
 
   octave_float_diag_matrix (const octave_float_diag_matrix& m)
     : octave_base_diag<FloatDiagMatrix, FloatMatrix> (m) { }
 
   ~octave_float_diag_matrix (void) { }
 
-  octave_base_value *clone (void) const { return new octave_float_diag_matrix (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_float_diag_matrix (); }
+  octave_base_value *clone (void) const
+  { return new octave_float_diag_matrix (*this); }
+  octave_base_value *empty_clone (void) const
+  { return new octave_float_diag_matrix (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
   octave_base_value *try_narrowing_conversion (void);
 
   builtin_type_t builtin_type (void) const { return btyp_float; }
 
   bool is_real_matrix (void) const { return true; }
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -67,17 +67,18 @@ along with Octave; see the file COPYING.
 #include "ls-oct-ascii.h"
 #include "ls-utils.h"
 #include "ls-hdf5.h"
 
 template class octave_base_matrix<FloatNDArray>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_float_matrix);
 
-DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_matrix, "float matrix", "single");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_matrix, "float matrix",
+                                     "single");
 
 octave_base_value *
 octave_float_matrix::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
   if (matrix.nelem () == 1)
     retval = new octave_float_scalar (matrix (0));
@@ -300,18 +301,17 @@ octave_float_matrix::convert_to_str_inte
           return retval;
         }
       else
         {
           int ival = NINT (d);
 
           if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
             {
-              // FIXME -- is there something
-              // better we could do?
+              // FIXME: is there something better we could do?
 
               ival = 0;
 
               if (! warned)
                 {
                   ::warning ("range error for conversion to character value");
                   warned = true;
                 }
@@ -464,32 +464,32 @@ octave_float_matrix::save_binary (std::o
   for (int i = 0; i < d.length (); i++)
     {
       tmp = d(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   FloatNDArray m = float_array_value ();
   save_type st = LS_FLOAT;
-  if (d.numel () > 8192) // FIXME -- make this configurable.
+  if (d.numel () > 8192) // FIXME: make this configurable.
     {
       float max_val, min_val;
       if (m.all_integers (max_val, min_val))
         st = get_save_type (max_val, min_val);
     }
 
   const float *mtmp = m.data ();
   write_floats (os, mtmp, st, d.numel ());
 
   return true;
 }
 
 bool
 octave_float_matrix::load_binary (std::istream& is, bool swap,
-                                 oct_mach_info::float_format fmt)
+                                  oct_mach_info::float_format fmt)
 {
   char tmp;
   int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims < 0)
@@ -520,17 +520,18 @@ octave_float_matrix::load_binary (std::i
           dv(0) = 1;
         }
 
       if (! is.read (reinterpret_cast<char *> (&tmp), 1))
         return false;
 
       FloatNDArray m(dv);
       float *re = m.fortran_vec ();
-      read_floats (is, re, static_cast<save_type> (tmp), dv.numel (), swap, fmt);
+      read_floats (is, re, static_cast<save_type> (tmp), dv.numel (),
+                   swap, fmt);
       if (error_state || ! is)
         return false;
       matrix = m;
     }
   else
     {
       int32_t nr, nc;
       nr = mdims;
@@ -617,17 +618,17 @@ octave_float_matrix::load_hdf5 (hid_t lo
 {
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize (dv);
   if (empty)
-      return (empty > 0);
+    return (empty > 0);
 
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t space_id = H5Dget_space (data_hid);
 
@@ -673,17 +674,17 @@ octave_float_matrix::load_hdf5 (hid_t lo
 
   return retval;
 }
 
 #endif
 
 void
 octave_float_matrix::print_raw (std::ostream& os,
-                          bool pr_as_read_syntax) const
+                                bool pr_as_read_syntax) const
 {
   octave_print_internal (os, matrix, pr_as_read_syntax,
                          current_print_indent_level ());
 }
 
 mxArray *
 octave_float_matrix::as_mxArray (void) const
 {
@@ -811,50 +812,54 @@ octave_float_matrix::map (unary_mapper_t
       ARRAY_MAPPER (xsignbit, float, xsignbit);
 
     default:
       return octave_base_value::map (umap);
     }
 }
 
 DEFUN (single, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} single (@var{x})\n\
 Convert @var{x} to single precision type.\n\
 @seealso{double}\n\
 @end deftypefn")
 {
   // The OCTAVE_TYPE_CONV_BODY3 macro declares retval, so they go
   // inside their own scopes, and we don't declare retval here to
   // avoid a shadowed declaration warning.
 
   if (args.length () == 1)
     {
       if (args(0).is_diag_matrix ())
         {
           if (args(0).is_complex_type ())
             {
-              OCTAVE_TYPE_CONV_BODY3 (single, octave_float_complex_diag_matrix, octave_float_complex);
+              OCTAVE_TYPE_CONV_BODY3 (single, octave_float_complex_diag_matrix,
+                                      octave_float_complex);
             }
           else
             {
-              OCTAVE_TYPE_CONV_BODY3 (single, octave_float_diag_matrix, octave_float_scalar);
+              OCTAVE_TYPE_CONV_BODY3 (single, octave_float_diag_matrix,
+                                      octave_float_scalar);
             }
         }
       else if (args(0).is_sparse_type ())
         {
           error ("single: sparse type does not support single precision");
         }
       else if (args(0).is_complex_type ())
         {
-          OCTAVE_TYPE_CONV_BODY3 (single, octave_float_complex_matrix, octave_float_complex);
+          OCTAVE_TYPE_CONV_BODY3 (single, octave_float_complex_matrix,
+                                  octave_float_complex);
         }
       else
         {
-          OCTAVE_TYPE_CONV_BODY3 (single, octave_float_matrix, octave_float_scalar);
+          OCTAVE_TYPE_CONV_BODY3 (single, octave_float_matrix,
+                                  octave_float_scalar);
         }
     }
   else
     print_usage ();
 
   return octave_value ();
 }
 
diff --git a/libinterp/octave-value/ov-flt-re-mat.h b/libinterp/octave-value/ov-flt-re-mat.h
--- a/libinterp/octave-value/ov-flt-re-mat.h
+++ b/libinterp/octave-value/ov-flt-re-mat.h
@@ -77,23 +77,25 @@ public:
   octave_float_matrix (const FloatColumnVector& v)
     : octave_base_matrix<FloatNDArray> (FloatMatrix (v)) { }
 
   octave_float_matrix (const octave_float_matrix& m)
     : octave_base_matrix<FloatNDArray> (m) { }
 
   ~octave_float_matrix (void) { }
 
-  octave_base_value *clone (void) const { return new octave_float_matrix (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_float_matrix (); }
+  octave_base_value *clone (void) const
+  { return new octave_float_matrix (*this); }
+  octave_base_value *empty_clone (void) const
+  { return new octave_float_matrix (); }
 
   octave_base_value *try_narrowing_conversion (void);
 
   idx_vector index_vector (void) const
-    { return idx_cache ? *idx_cache : set_idx_cache (idx_vector (matrix)); }
+  { return idx_cache ? *idx_cache : set_idx_cache (idx_vector (matrix)); }
 
   builtin_type_t builtin_type (void) const { return btyp_float; }
 
   bool is_real_matrix (void) const { return true; }
 
   bool is_real_type (void) const { return true; }
 
   bool is_single_type (void) const { return true; }
@@ -124,20 +126,20 @@ public:
   uint64NDArray
   uint64_array_value (void) const { return uint64NDArray (matrix); }
 
   double double_value (bool = false) const;
 
   float float_value (bool = false) const;
 
   double scalar_value (bool frc_str_conv = false) const
-    { return double_value (frc_str_conv); }
+  { return double_value (frc_str_conv); }
 
   float float_scalar_value (bool frc_str_conv = false) const
-    { return float_value (frc_str_conv); }
+  { return float_value (frc_str_conv); }
 
   Matrix matrix_value (bool = false) const;
 
   FloatMatrix float_matrix_value (bool = false) const;
 
   Complex complex_value (bool = false) const;
 
   FloatComplex float_complex_value (bool = false) const;
@@ -190,17 +192,17 @@ public:
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
-    { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
+  { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return matrix.mex_get_data (); }
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
diff --git a/libinterp/octave-value/ov-int16.cc b/libinterp/octave-value/ov-int16.cc
--- a/libinterp/octave-value/ov-int16.cc
+++ b/libinterp/octave-value/ov-int16.cc
@@ -69,17 +69,17 @@ template class octave_base_scalar<octave
 template class octave_base_int_scalar<octave_int16>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_int16_scalar);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int16_scalar,
                                      "int16 scalar", "int16");
 
 DEFUN (int16, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} int16 (@var{x})\n\
 Convert @var{x} to 16-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int16);
 }
 
 /*
diff --git a/libinterp/octave-value/ov-int32.cc b/libinterp/octave-value/ov-int32.cc
--- a/libinterp/octave-value/ov-int32.cc
+++ b/libinterp/octave-value/ov-int32.cc
@@ -69,17 +69,17 @@ template class octave_base_scalar<octave
 template class octave_base_int_scalar<octave_int32>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_int32_scalar);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int32_scalar,
                                      "int32 scalar", "int32");
 
 DEFUN (int32, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} int32 (@var{x})\n\
 Convert @var{x} to 32-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int32);
 }
 
 /*
diff --git a/libinterp/octave-value/ov-int64.cc b/libinterp/octave-value/ov-int64.cc
--- a/libinterp/octave-value/ov-int64.cc
+++ b/libinterp/octave-value/ov-int64.cc
@@ -69,17 +69,17 @@ template class octave_base_scalar<octave
 template class octave_base_int_scalar<octave_int64>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_int64_scalar);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int64_scalar,
                                      "int64 scalar", "int64");
 
 DEFUN (int64, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} int64 (@var{x})\n\
 Convert @var{x} to 64-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int64);
 }
 
 /*
diff --git a/libinterp/octave-value/ov-int8.cc b/libinterp/octave-value/ov-int8.cc
--- a/libinterp/octave-value/ov-int8.cc
+++ b/libinterp/octave-value/ov-int8.cc
@@ -69,17 +69,17 @@ template class octave_base_scalar<octave
 template class octave_base_int_scalar<octave_int8>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_int8_scalar);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_int8_scalar,
                                      "int8 scalar", "int8");
 
 DEFUN (int8, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} int8 (@var{x})\n\
 Convert @var{x} to 8-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int8);
 }
 
 /*
diff --git a/libinterp/octave-value/ov-intx.h b/libinterp/octave-value/ov-intx.h
--- a/libinterp/octave-value/ov-intx.h
+++ b/libinterp/octave-value/ov-intx.h
@@ -56,20 +56,20 @@ public:
 
   OCTAVE_VALUE_INT_MATRIX_T (const Array<OCTAVE_INT_T>& nda)
     : octave_base_int_matrix<intNDArray<OCTAVE_INT_T> >
         (intNDArray<OCTAVE_INT_T> (nda)) { }
 
   ~OCTAVE_VALUE_INT_MATRIX_T (void) { }
 
   octave_base_value *clone (void) const
-    { return new OCTAVE_VALUE_INT_MATRIX_T (*this); }
+  { return new OCTAVE_VALUE_INT_MATRIX_T (*this); }
 
   octave_base_value *empty_clone (void) const
-    { return new OCTAVE_VALUE_INT_MATRIX_T (); }
+  { return new OCTAVE_VALUE_INT_MATRIX_T (); }
 
   bool OCTAVE_TYPE_PREDICATE_FUNCTION (void) const { return true; }
 
   bool is_integer_type (void) const { return true; }
 
   builtin_type_t builtin_type (void) const { return OCTAVE_INT_BTYP; }
 
 public:
@@ -95,171 +95,171 @@ public:
   uint32NDArray
   uint32_array_value (void) const { return uint32NDArray (matrix); }
 
   uint64NDArray
   uint64_array_value (void) const { return uint64NDArray (matrix); }
 
   double
   double_value (bool = false) const
-    {
-      double retval = lo_ieee_nan_value ();
+  {
+    double retval = lo_ieee_nan_value ();
 
-      if (numel () > 0)
-        {
-          gripe_implicit_conversion ("Octave:array-to-scalar",
-                                     type_name (), "real scalar");
+    if (numel () > 0)
+      {
+        gripe_implicit_conversion ("Octave:array-to-scalar",
+                                   type_name (), "real scalar");
 
-          retval = matrix(0).double_value ();
-        }
-      else
-        gripe_invalid_conversion (type_name (), "real scalar");
+        retval = matrix(0).double_value ();
+      }
+    else
+      gripe_invalid_conversion (type_name (), "real scalar");
 
-      return retval;
+    return retval;
 
-    }
+  }
 
   float
   float_value (bool = false) const
-    {
-      float retval = lo_ieee_float_nan_value ();
+  {
+    float retval = lo_ieee_float_nan_value ();
 
-      if (numel () > 0)
-        {
-          gripe_implicit_conversion ("Octave:array-to-scalar",
-                                     type_name (), "real scalar");
+    if (numel () > 0)
+      {
+        gripe_implicit_conversion ("Octave:array-to-scalar",
+                                   type_name (), "real scalar");
 
-          retval = matrix(0).float_value ();
-        }
-      else
-        gripe_invalid_conversion (type_name (), "real scalar");
+        retval = matrix(0).float_value ();
+      }
+    else
+      gripe_invalid_conversion (type_name (), "real scalar");
 
-      return retval;
+    return retval;
 
-    }
+  }
 
   double scalar_value (bool = false) const { return double_value (); }
 
   float float_scalar_value (bool = false) const { return float_value (); }
 
   Matrix
   matrix_value (bool = false) const
-    {
-      Matrix retval;
-      dim_vector dv = dims ();
-      if (dv.length () > 2)
-        error ("invalid conversion of %s to Matrix", type_name ().c_str ());
-      else
-        {
-          retval = Matrix (dv(0), dv(1));
-          double *vec = retval.fortran_vec ();
-          octave_idx_type nel = matrix.numel ();
-          for (octave_idx_type i = 0; i < nel; i++)
-            vec[i] = matrix(i).double_value ();
-        }
-      return retval;
-    }
+  {
+    Matrix retval;
+    dim_vector dv = dims ();
+    if (dv.length () > 2)
+      error ("invalid conversion of %s to Matrix", type_name ().c_str ());
+    else
+      {
+        retval = Matrix (dv(0), dv(1));
+        double *vec = retval.fortran_vec ();
+        octave_idx_type nel = matrix.numel ();
+        for (octave_idx_type i = 0; i < nel; i++)
+          vec[i] = matrix(i).double_value ();
+      }
+    return retval;
+  }
 
   FloatMatrix
   float_matrix_value (bool = false) const
-    {
-      FloatMatrix retval;
-      dim_vector dv = dims ();
-      if (dv.length () > 2)
-        error ("invalid conversion of %s to FloatMatrix", type_name ().c_str ());
-      else
-        {
-          retval = FloatMatrix (dv(0), dv(1));
-          float *vec = retval.fortran_vec ();
-          octave_idx_type nel = matrix.numel ();
-          for (octave_idx_type i = 0; i < nel; i++)
-            vec[i] = matrix(i).float_value ();
-        }
-      return retval;
-    }
+  {
+    FloatMatrix retval;
+    dim_vector dv = dims ();
+    if (dv.length () > 2)
+      error ("invalid conversion of %s to FloatMatrix", type_name ().c_str ());
+    else
+      {
+        retval = FloatMatrix (dv(0), dv(1));
+        float *vec = retval.fortran_vec ();
+        octave_idx_type nel = matrix.numel ();
+        for (octave_idx_type i = 0; i < nel; i++)
+          vec[i] = matrix(i).float_value ();
+      }
+    return retval;
+  }
 
   ComplexMatrix
   complex_matrix_value (bool = false) const
-    {
-      ComplexMatrix retval;
-      dim_vector dv = dims ();
-      if (dv.length () > 2)
-        error ("invalid conversion of %s to Matrix", type_name ().c_str ());
-      else
-        {
-          retval = ComplexMatrix (dv(0), dv(1));
-          Complex *vec = retval.fortran_vec ();
-          octave_idx_type nel = matrix.numel ();
-          for (octave_idx_type i = 0; i < nel; i++)
-            vec[i] = Complex (matrix(i).double_value ());
-        }
-      return retval;
-    }
+  {
+    ComplexMatrix retval;
+    dim_vector dv = dims ();
+    if (dv.length () > 2)
+      error ("invalid conversion of %s to Matrix", type_name ().c_str ());
+    else
+      {
+        retval = ComplexMatrix (dv(0), dv(1));
+        Complex *vec = retval.fortran_vec ();
+        octave_idx_type nel = matrix.numel ();
+        for (octave_idx_type i = 0; i < nel; i++)
+          vec[i] = Complex (matrix(i).double_value ());
+      }
+    return retval;
+  }
 
   FloatComplexMatrix
   float_complex_matrix_value (bool = false) const
-    {
-      FloatComplexMatrix retval;
-      dim_vector dv = dims ();
-      if (dv.length () > 2)
-        error ("invalid conversion of %s to FloatMatrix", type_name ().c_str ());
-      else
-        {
-          retval = FloatComplexMatrix (dv(0), dv(1));
-          FloatComplex *vec = retval.fortran_vec ();
-          octave_idx_type nel = matrix.numel ();
-          for (octave_idx_type i = 0; i < nel; i++)
-            vec[i] = FloatComplex (matrix(i).float_value ());
-        }
-      return retval;
-    }
+  {
+    FloatComplexMatrix retval;
+    dim_vector dv = dims ();
+    if (dv.length () > 2)
+      error ("invalid conversion of %s to FloatMatrix", type_name ().c_str ());
+    else
+      {
+        retval = FloatComplexMatrix (dv(0), dv(1));
+        FloatComplex *vec = retval.fortran_vec ();
+        octave_idx_type nel = matrix.numel ();
+        for (octave_idx_type i = 0; i < nel; i++)
+          vec[i] = FloatComplex (matrix(i).float_value ());
+      }
+    return retval;
+  }
 
   NDArray
   array_value (bool = false) const
-    {
-      NDArray retval (matrix.dims ());
-      double *vec = retval.fortran_vec ();
-      octave_idx_type nel = matrix.numel ();
-      for (octave_idx_type i = 0; i < nel; i++)
-        vec[i] = matrix(i).double_value ();
-      return retval;
-    }
+  {
+    NDArray retval (matrix.dims ());
+    double *vec = retval.fortran_vec ();
+    octave_idx_type nel = matrix.numel ();
+    for (octave_idx_type i = 0; i < nel; i++)
+      vec[i] = matrix(i).double_value ();
+    return retval;
+  }
 
   FloatNDArray
   float_array_value (bool = false) const
-    {
-      FloatNDArray retval (matrix.dims ());
-      float *vec = retval.fortran_vec ();
-      octave_idx_type nel = matrix.numel ();
-      for (octave_idx_type i = 0; i < nel; i++)
-        vec[i] = matrix(i).float_value ();
-      return retval;
-    }
+  {
+    FloatNDArray retval (matrix.dims ());
+    float *vec = retval.fortran_vec ();
+    octave_idx_type nel = matrix.numel ();
+    for (octave_idx_type i = 0; i < nel; i++)
+      vec[i] = matrix(i).float_value ();
+    return retval;
+  }
 
   ComplexNDArray
   complex_array_value (bool = false) const
-    {
-      ComplexNDArray retval (matrix.dims ());
-      Complex *vec = retval.fortran_vec ();
-      octave_idx_type nel = matrix.numel ();
-      for (octave_idx_type i = 0; i < nel; i++)
-        vec[i] = Complex (matrix(i).double_value ());
-      return retval;
-    }
+  {
+    ComplexNDArray retval (matrix.dims ());
+    Complex *vec = retval.fortran_vec ();
+    octave_idx_type nel = matrix.numel ();
+    for (octave_idx_type i = 0; i < nel; i++)
+      vec[i] = Complex (matrix(i).double_value ());
+    return retval;
+  }
 
   FloatComplexNDArray
   float_complex_array_value (bool = false) const
-    {
-      FloatComplexNDArray retval (matrix.dims ());
-      FloatComplex *vec = retval.fortran_vec ();
-      octave_idx_type nel = matrix.numel ();
-      for (octave_idx_type i = 0; i < nel; i++)
-        vec[i] = FloatComplex (matrix(i).float_value ());
-      return retval;
-    }
+  {
+    FloatComplexNDArray retval (matrix.dims ());
+    FloatComplex *vec = retval.fortran_vec ();
+    octave_idx_type nel = matrix.numel ();
+    for (octave_idx_type i = 0; i < nel; i++)
+      vec[i] = FloatComplex (matrix(i).float_value ());
+    return retval;
+  }
 
   boolNDArray
   bool_array_value (bool warn = false) const
   {
     boolNDArray retval (dims ());
 
     octave_idx_type nel = numel ();
 
@@ -284,89 +284,90 @@ public:
     for (octave_idx_type i = 0; i < nel; i++)
       vec[i] = matrix(i).char_value ();
 
     return retval;
   }
 
   // Use matrix_ref here to clear index cache.
   void increment (void)
-   {
-     matrix_ref () += OCTAVE_INT_T (1);
-   }
+  {
+    matrix_ref () += OCTAVE_INT_T (1);
+  }
 
   void decrement (void)
-   {
-     matrix_ref () -= OCTAVE_INT_T (1);
-   }
+  {
+    matrix_ref () -= OCTAVE_INT_T (1);
+  }
 
   void changesign (void)
-   {
-     matrix_ref ().changesign ();
-   }
+  {
+    matrix_ref ().changesign ();
+  }
 
   idx_vector index_vector (void) const
-    { return idx_cache ? *idx_cache : set_idx_cache (idx_vector (matrix)); }
+  { return idx_cache ? *idx_cache : set_idx_cache (idx_vector (matrix)); }
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
-    { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
+  { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return matrix.mex_get_data (); }
 
   mxArray *as_mxArray (void) const
   {
     mxArray *retval = new mxArray (OCTAVE_INT_MX_CLASS, dims (), mxREAL);
 
-    OCTAVE_INT_T::val_type *pr = static_cast<OCTAVE_INT_T::val_type *> (retval->get_data ());
+    OCTAVE_INT_T::val_type *pr = static_cast<OCTAVE_INT_T::val_type *>
+                                 (retval->get_data ());
 
     mwSize nel = numel ();
 
     const OCTAVE_INT_T *p = matrix.data ();
 
     for (mwIndex i = 0; i < nel; i++)
       pr[i] = p[i].value ();
 
     return retval;
   }
 
   octave_value map (unary_mapper_t umap) const
-    {
-      switch (umap)
+  {
+    switch (umap)
+      {
+      case umap_abs:
+        return matrix.abs ();
+      case umap_signum:
+        return matrix.signum ();
+      case umap_ceil:
+      case umap_conj:
+      case umap_fix:
+      case umap_floor:
+      case umap_real:
+      case umap_round:
+        return matrix;
+      case umap_imag:
+        return intNDArray<OCTAVE_INT_T> (matrix.dims (), OCTAVE_INT_T ());
+      case umap_isnan:
+      case umap_isna:
+      case umap_isinf:
+        return boolNDArray (matrix.dims (), false);
+      case umap_finite:
+        return boolNDArray (matrix.dims (), true);
+
+      default:
         {
-        case umap_abs:
-          return matrix.abs ();
-        case umap_signum:
-          return matrix.signum ();
-        case umap_ceil:
-        case umap_conj:
-        case umap_fix:
-        case umap_floor:
-        case umap_real:
-        case umap_round:
-          return matrix;
-        case umap_imag:
-          return intNDArray<OCTAVE_INT_T> (matrix.dims (), OCTAVE_INT_T ());
-        case umap_isnan:
-        case umap_isna:
-        case umap_isinf:
-          return boolNDArray (matrix.dims (), false);
-        case umap_finite:
-          return boolNDArray (matrix.dims (), true);
-
-        default:
-          {
-            octave_matrix m (array_value ());
-            return m.map (umap);
-          }
+          octave_matrix m (array_value ());
+          return m.map (umap);
         }
-    }
+      }
+  }
 
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
@@ -381,40 +382,40 @@ public:
     : octave_base_int_scalar<OCTAVE_INT_T> () { }
 
   OCTAVE_VALUE_INT_SCALAR_T (const OCTAVE_INT_T& nda)
     : octave_base_int_scalar<OCTAVE_INT_T> (nda) { }
 
   ~OCTAVE_VALUE_INT_SCALAR_T (void) { }
 
   octave_base_value *clone (void) const
-    { return new OCTAVE_VALUE_INT_SCALAR_T (*this); }
+  { return new OCTAVE_VALUE_INT_SCALAR_T (*this); }
 
   octave_base_value *empty_clone (void) const
-    { return new OCTAVE_VALUE_INT_MATRIX_T (); }
+  { return new OCTAVE_VALUE_INT_MATRIX_T (); }
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false)
-    {
-      // FIXME -- this doesn't solve the problem of
-      //
-      //   a = 1; a([1,1], [1,1], [1,1])
-      //
-      // and similar constructions.  Hmm...
+  {
+    // FIXME: this doesn't solve the problem of
+    //
+    //   a = 1; a([1,1], [1,1], [1,1])
+    //
+    // and similar constructions.  Hmm...
 
-      // FIXME -- using this constructor avoids narrowing the
-      // 1x1 matrix back to a scalar value.  Need a better solution
-      // to this problem.
+    // FIXME: using this constructor avoids narrowing the
+    // 1x1 matrix back to a scalar value.  Need a better solution
+    // to this problem.
 
-      octave_value tmp
-        (new OCTAVE_VALUE_INT_MATRIX_T
-         (OCTAVE_VALUE_INT_NDARRAY_EXTRACTOR_FUNCTION ()));
+    octave_value tmp
+    (new OCTAVE_VALUE_INT_MATRIX_T
+     (OCTAVE_VALUE_INT_NDARRAY_EXTRACTOR_FUNCTION ()));
 
-      return tmp.do_index_op (idx, resize_ok);
-    }
+    return tmp.do_index_op (idx, resize_ok);
+  }
 
   bool OCTAVE_TYPE_PREDICATE_FUNCTION (void) const { return true; }
 
   bool is_integer_type (void) const { return true; }
 
   builtin_type_t builtin_type (void) const { return OCTAVE_INT_BTYP; }
 
 public:
@@ -440,135 +441,136 @@ public:
   octave_uint32
   uint32_scalar_value (void) const { return octave_uint32 (scalar); }
 
   octave_uint64
   uint64_scalar_value (void) const { return octave_uint64 (scalar); }
 
   int8NDArray
   int8_array_value (void) const
-    { return int8NDArray (dim_vector (1, 1), int8_scalar_value ()); }
+  { return int8NDArray (dim_vector (1, 1), int8_scalar_value ()); }
 
   int16NDArray
   int16_array_value (void) const
-    { return int16NDArray (dim_vector (1, 1), int16_scalar_value ()); }
+  { return int16NDArray (dim_vector (1, 1), int16_scalar_value ()); }
 
   int32NDArray
   int32_array_value (void) const
-    { return int32NDArray (dim_vector (1, 1), int32_scalar_value ()); }
+  { return int32NDArray (dim_vector (1, 1), int32_scalar_value ()); }
 
   int64NDArray
   int64_array_value (void) const
-    { return int64NDArray (dim_vector (1, 1), int64_scalar_value ()); }
+  { return int64NDArray (dim_vector (1, 1), int64_scalar_value ()); }
 
   uint8NDArray
   uint8_array_value (void) const
-    { return uint8NDArray (dim_vector (1, 1), uint8_scalar_value ()); }
+  { return uint8NDArray (dim_vector (1, 1), uint8_scalar_value ()); }
 
   uint16NDArray
   uint16_array_value (void) const
-    { return uint16NDArray (dim_vector (1, 1), uint16_scalar_value ()); }
+  { return uint16NDArray (dim_vector (1, 1), uint16_scalar_value ()); }
 
   uint32NDArray
   uint32_array_value (void) const
-    { return uint32NDArray (dim_vector (1, 1), uint32_scalar_value ()); }
+  { return uint32NDArray (dim_vector (1, 1), uint32_scalar_value ()); }
 
   uint64NDArray
   uint64_array_value (void) const
-    { return uint64NDArray (dim_vector (1, 1), uint64_scalar_value ()); }
+  { return uint64NDArray (dim_vector (1, 1), uint64_scalar_value ()); }
 
   octave_value resize (const dim_vector& dv, bool fill = false) const
-    {
-      if (fill)
-        {
-          intNDArray<OCTAVE_INT_T> retval (dv, 0);
-          if (dv.numel ())
-            retval(0) = scalar;
-          return retval;
-        }
-      else
-        {
-          intNDArray<OCTAVE_INT_T> retval (dv);
-          if (dv.numel ())
-            retval(0) = scalar;
-          return retval;
-        }
-    }
+  {
+    if (fill)
+      {
+        intNDArray<OCTAVE_INT_T> retval (dv, 0);
+        if (dv.numel ())
+          retval(0) = scalar;
+        return retval;
+      }
+    else
+      {
+        intNDArray<OCTAVE_INT_T> retval (dv);
+        if (dv.numel ())
+          retval(0) = scalar;
+        return retval;
+      }
+  }
 
   double double_value (bool = false) const { return scalar.double_value (); }
 
   float float_value (bool = false) const { return scalar.float_value (); }
 
   double scalar_value (bool = false) const { return scalar.double_value (); }
 
-  float float_scalar_value (bool = false) const { return scalar.float_value (); }
+  float float_scalar_value (bool = false) const
+  { return scalar.float_value (); }
 
   Matrix
   matrix_value (bool = false) const
-    {
-      Matrix retval (1, 1);
-      retval(0,0) = scalar.double_value ();
-      return retval;
-    }
+  {
+    Matrix retval (1, 1);
+    retval(0,0) = scalar.double_value ();
+    return retval;
+  }
 
   FloatMatrix
   float_matrix_value (bool = false) const
-    {
-      FloatMatrix retval (1, 1);
-      retval(0,0) = scalar.float_value ();
-      return retval;
-    }
+  {
+    FloatMatrix retval (1, 1);
+    retval(0,0) = scalar.float_value ();
+    return retval;
+  }
 
   ComplexMatrix
   complex_matrix_value (bool = false) const
-    {
-      ComplexMatrix retval (1, 1);
-      retval(0,0) = Complex (scalar.double_value ());
-      return retval;
-    }
+  {
+    ComplexMatrix retval (1, 1);
+    retval(0,0) = Complex (scalar.double_value ());
+    return retval;
+  }
 
   FloatComplexMatrix
   float_complex_matrix_value (bool = false) const
-    {
-      FloatComplexMatrix retval (1, 1);
-      retval(0,0) = FloatComplex (scalar.float_value ());
-      return retval;
-    }
+  {
+    FloatComplexMatrix retval (1, 1);
+    retval(0,0) = FloatComplex (scalar.float_value ());
+    return retval;
+  }
 
   NDArray
   array_value (bool = false) const
-    {
-      NDArray retval (dim_vector (1, 1));
-      retval(0) = scalar.double_value ();
-      return retval;
-    }
+  {
+    NDArray retval (dim_vector (1, 1));
+    retval(0) = scalar.double_value ();
+    return retval;
+  }
 
   FloatNDArray
   float_array_value (bool = false) const
-    {
-      FloatNDArray retval (dim_vector (1, 1));
-      retval(0) = scalar.float_value ();
-      return retval;
-    }
+  {
+    FloatNDArray retval (dim_vector (1, 1));
+    retval(0) = scalar.float_value ();
+    return retval;
+  }
 
   ComplexNDArray
   complex_array_value (bool = false) const
-    {
-      ComplexNDArray retval (dim_vector (1, 1));
-      retval(0) = FloatComplex (scalar.double_value ());
-      return retval;
-    }
+  {
+    ComplexNDArray retval (dim_vector (1, 1));
+    retval(0) = FloatComplex (scalar.double_value ());
+    return retval;
+  }
 
   FloatComplexNDArray
   float_complex_array_value (bool = false) const
-    {
-      FloatComplexNDArray retval (dim_vector (1, 1));
-      retval(0) = FloatComplex (scalar.float_value ());
-      return retval;
-    }
+  {
+    FloatComplexNDArray retval (dim_vector (1, 1));
+    retval(0) = FloatComplex (scalar.float_value ());
+    return retval;
+  }
 
   bool bool_value (bool warn = false) const
   {
     if (warn && scalar != 0.0 && scalar != 1.0)
       gripe_logical_conversion ();
 
     return scalar.bool_value ();
   }
@@ -590,80 +592,81 @@ public:
   char_array_value (bool = false) const
   {
     charNDArray retval (dim_vector (1, 1));
     retval(0) = scalar.char_value ();
     return retval;
   }
 
   void increment (void)
-   {
-     scalar += OCTAVE_INT_T (1);
-   }
+  {
+    scalar += OCTAVE_INT_T (1);
+  }
 
   void decrement (void)
-   {
-     scalar -= OCTAVE_INT_T (1);
-   }
+  {
+    scalar -= OCTAVE_INT_T (1);
+  }
 
   idx_vector index_vector (void) const { return idx_vector (scalar); }
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, octave_idx_type skip,
              oct_mach_info::float_format flt_fmt) const
-    {
-      return os.write (OCTAVE_VALUE_INT_NDARRAY_EXTRACTOR_FUNCTION (),
-                       block_size, output_type, skip, flt_fmt);
-    }
+  {
+    return os.write (OCTAVE_VALUE_INT_NDARRAY_EXTRACTOR_FUNCTION (),
+                     block_size, output_type, skip, flt_fmt);
+  }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return scalar.mex_get_data (); }
 
   mxArray *as_mxArray (void) const
   {
     mxArray *retval = new mxArray (OCTAVE_INT_MX_CLASS, 1, 1, mxREAL);
 
-    OCTAVE_INT_T::val_type *pr = static_cast<OCTAVE_INT_T::val_type *> (retval->get_data ());
+    OCTAVE_INT_T::val_type *pr = static_cast<OCTAVE_INT_T::val_type *>
+                                 (retval->get_data ());
 
     pr[0] = scalar.value ();
 
     return retval;
   }
 
   octave_value map (unary_mapper_t umap) const
-    {
-      switch (umap)
+  {
+    switch (umap)
+      {
+      case umap_abs:
+        return scalar.abs ();
+      case umap_signum:
+        return scalar.signum ();
+      case umap_ceil:
+      case umap_conj:
+      case umap_fix:
+      case umap_floor:
+      case umap_real:
+      case umap_round:
+        return scalar;
+      case umap_imag:
+        return OCTAVE_INT_T ();
+      case umap_isnan:
+      case umap_isna:
+      case umap_isinf:
+        return false;
+      case umap_finite:
+        return true;
+
+      default:
         {
-        case umap_abs:
-          return scalar.abs ();
-        case umap_signum:
-          return scalar.signum ();
-        case umap_ceil:
-        case umap_conj:
-        case umap_fix:
-        case umap_floor:
-        case umap_real:
-        case umap_round:
-          return scalar;
-        case umap_imag:
-          return OCTAVE_INT_T ();
-        case umap_isnan:
-        case umap_isna:
-        case umap_isinf:
-          return false;
-        case umap_finite:
-          return true;
-
-        default:
-          {
-            octave_scalar m (scalar_value ());
-            return m.map (umap);
-          }
+          octave_scalar m (scalar_value ());
+          return m.map (umap);
         }
-    }
+      }
+  }
 
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -161,17 +161,18 @@ private:
     clean ();
 
     if (java_opts.size () > 0)
       {
         int index = 0;
 
         vm_args.nOptions = java_opts.size ();
         vm_args.options = new JavaVMOption [vm_args.nOptions];
-        for (std::list<std::string>::const_iterator it = java_opts.begin (); it != java_opts.end (); ++it)
+        for (std::list<std::string>::const_iterator it = java_opts.begin ();
+             it != java_opts.end (); ++it)
           {
             if (Vdebug_java)
               std::cout << *it << std::endl;
             vm_args.options[index++].optionString = strsave ((*it).c_str ());
           }
         java_opts.clear ();
       }
   }
@@ -192,17 +193,18 @@ read_registry_string (const std::string&
 
   std::string retval;
 
   if (! RegOpenKeyEx (HKEY_LOCAL_MACHINE, key.c_str (), 0, KEY_READ, &hkey))
     {
       if (! RegQueryValueEx (hkey, value.c_str (), 0, 0, 0, &len))
         {
           retval.resize (len);
-          if (RegQueryValueEx (hkey, value.c_str (), 0, 0, (LPBYTE)&retval[0], &len))
+          if (RegQueryValueEx (hkey, value.c_str (), 0, 0,
+                               (LPBYTE)&retval[0], &len))
             retval = "";
           else if (retval[len-1] == '\0')
             retval.resize (--len);
         }
       RegCloseKey (hkey);
     }
 
   return retval;
@@ -240,17 +242,18 @@ set_dll_directory (const std::string& di
   typedef BOOL (WINAPI *dllfcn_t) (LPCTSTR path);
 
   static dllfcn_t dllfcn = NULL;
   static bool first = true;
 
   if (! dllfcn && first)
     {
       HINSTANCE hKernel32 = GetModuleHandle ("kernel32");
-      dllfcn = reinterpret_cast<dllfcn_t> (GetProcAddress (hKernel32, "SetDllDirectoryA"));
+      dllfcn = reinterpret_cast<dllfcn_t> (GetProcAddress (hKernel32,
+                                           "SetDllDirectoryA"));
       first = false;
     }
 
   if (dllfcn)
     dllfcn (dir.empty () ? NULL : dir.c_str ());
 }
 #endif
 
@@ -503,18 +506,20 @@ initialize_jvm (void)
 
   set_dll_directory ();
 
   if (! old_cwd.empty ())
     octave_env::chdir (old_cwd);
 
 #endif
 
-  JNI_CreateJavaVM_t create_vm = reinterpret_cast<JNI_CreateJavaVM_t> (lib.search ("JNI_CreateJavaVM"));
-  JNI_GetCreatedJavaVMs_t get_vm = reinterpret_cast<JNI_GetCreatedJavaVMs_t> (lib.search ("JNI_GetCreatedJavaVMs"));
+  JNI_CreateJavaVM_t create_vm =
+    reinterpret_cast<JNI_CreateJavaVM_t> (lib.search ("JNI_CreateJavaVM"));
+  JNI_GetCreatedJavaVMs_t get_vm =
+    reinterpret_cast<JNI_GetCreatedJavaVMs_t> (lib.search ("JNI_GetCreatedJavaVMs"));
 
   if (!create_vm)
     throw std::string ("unable to find JNI_CreateJavaVM in ") + jvm_lib_path;
 
   if (!get_vm)
     throw std::string ("unable to find JNI_GetCreatedJavaVMs in ") + jvm_lib_path;
 
   if (get_vm (&jvm, 1, &nVMs) == 0 && nVMs > 0)
@@ -535,17 +540,18 @@ initialize_jvm (void)
       switch (jvm->GetEnv (reinterpret_cast<void **> (&current_env), JNI_VERSION_1_2))
         {
         case JNI_EDETACHED:
           // Attach the current thread
           JavaVMAttachArgs vm_args;
           vm_args.version = JNI_VERSION_1_2;
           vm_args.name = const_cast<char *> ("octave");
           vm_args.group = NULL;
-          if (jvm->AttachCurrentThread (reinterpret_cast<void **> (&current_env), &vm_args) < 0)
+          if (jvm->AttachCurrentThread (reinterpret_cast<void **> (&current_env),
+                                        &vm_args) < 0)
             throw std::string ("JVM internal error, unable to attach octave to existing JVM");
           break;
 
         case JNI_EVERSION:
           throw std::string ("JVM internal error, the required JNI version is not supported");
           break;
 
         case JNI_OK:
@@ -630,17 +636,18 @@ jstring_to_string (JNIEnv* jni_env, jobj
   std::string retval;
 
   if (jni_env && obj)
     {
       jclass_ref cls (jni_env, jni_env->FindClass ("java/lang/String"));
       if (cls)
         {
           if (jni_env->IsInstanceOf (obj, cls))
-            retval = jstring_to_string (jni_env, reinterpret_cast<jstring> (obj));
+            retval = jstring_to_string (jni_env,
+                                        reinterpret_cast<jstring> (obj));
         }
     }
 
   return retval;
 }
 
 bool
 octave_java::is_java_string (void) const
@@ -666,18 +673,20 @@ check_exception (JNIEnv* jni_env)
   if (ex)
     {
       if (Vdebug_java)
         jni_env->ExceptionDescribe ();
 
       jni_env->ExceptionClear ();
 
       jclass_ref jcls (jni_env, jni_env->GetObjectClass (ex));
-      jmethodID mID = jni_env->GetMethodID (jcls, "toString", "()Ljava/lang/String;");
-      jstring_ref js (jni_env, reinterpret_cast<jstring> (jni_env->CallObjectMethod (ex, mID)));
+      jmethodID mID = jni_env->GetMethodID (jcls, "toString",
+                                            "()Ljava/lang/String;");
+      jstring_ref js (jni_env,
+                      reinterpret_cast<jstring> (jni_env->CallObjectMethod (ex, mID)));
       std::string msg = jstring_to_string (jni_env, js);
 
       error ("[java] %s", msg.c_str ());
     }
   else
     retval = Matrix ();
 
   return retval;
@@ -694,17 +703,18 @@ find_octave_class (JNIEnv *jni_env, cons
   if (jcls == 0)
     {
       jni_env->ExceptionClear ();
 
       if (! uiClass)
         {
           if (class_loader.empty ())
             {
-              jclass_ref syscls (jni_env, jni_env->FindClass ("java/lang/System"));
+              jclass_ref syscls (jni_env,
+                                 jni_env->FindClass ("java/lang/System"));
               jmethodID mID = jni_env->GetStaticMethodID (syscls, "getProperty", "(Ljava/lang/String;)Ljava/lang/String;");
               jstring_ref js (jni_env, jni_env->NewStringUTF ("octave.class.loader"));
               js = reinterpret_cast<jstring> (jni_env->CallStaticObjectMethod (syscls, mID, jstring (js)));
               class_loader = jstring_to_string (jni_env, jstring (js));
               std::replace (class_loader.begin (), class_loader.end (), '.', '/');
             }
 
           jclass_ref uicls (jni_env, jni_env->FindClass (class_loader.c_str ()));
@@ -1143,17 +1153,18 @@ box_more (JNIEnv* jni_env, jobject jobj,
               int rows = jni_env->GetArrayLength (jarr), cols = 0;
 
               if (rows > 0)
                 {
                   Matrix m;
 
                   for (int r = 0; r < rows; r++)
                     {
-                      jdoubleArray_ref row (jni_env, reinterpret_cast<jdoubleArray> (jni_env->GetObjectArrayElement (jarr, r)));
+                      jdoubleArray_ref row (jni_env,
+                                            reinterpret_cast<jdoubleArray> (jni_env->GetObjectArrayElement (jarr, r)));
 
                       if (m.length () == 0)
                         {
                           cols = jni_env->GetArrayLength (row);
                           m.resize (cols, rows);
                         }
                       jni_env->GetDoubleArrayRegion (row, 0, cols, m.fortran_vec () + r * cols);
                     }
@@ -1171,17 +1182,18 @@ box_more (JNIEnv* jni_env, jobject jobj,
           if (jni_env->IsInstanceOf (jobj, cls))
             {
               jobjectArray jarr = reinterpret_cast<jobjectArray> (jobj);
               int len = jni_env->GetArrayLength (jarr);
               Cell m (len, 1);
 
               for (int i = 0; i < len; i++)
                 {
-                  jstring_ref js (jni_env, reinterpret_cast<jstring> (jni_env->GetObjectArrayElement (jarr, i)));
+                  jstring_ref js (jni_env,
+                                  reinterpret_cast<jstring> (jni_env->GetObjectArrayElement (jarr, i)));
                   m(i) = jstring_to_string (jni_env, js);
                 }
 
               retval = m;
             }
         }
     }
 
@@ -1281,44 +1293,49 @@ unbox (JNIEnv* jni_env, const octave_val
         iv_data[i] = dims(i);
 
       jni_env->ReleaseIntArrayElements (jintArray (iv), iv_data, 0);
 
       if (val.is_double_type ())
         {
           NDArray m = val.array_value ();
           jdoubleArray_ref dv (jni_env, jni_env->NewDoubleArray (m.length ()));
-          jni_env->SetDoubleArrayRegion (jdoubleArray (dv), 0, m.length (), m.fortran_vec ());
+          jni_env->SetDoubleArrayRegion (jdoubleArray (dv), 0, m.length (),
+                                         m.fortran_vec ());
           jmethodID mID = jni_env->GetMethodID (mcls, "<init>", "([D[I)V");
-          jobj = jni_env->NewObject (jclass (mcls), mID, jdoubleArray (dv), jintArray (iv));
+          jobj = jni_env->NewObject (jclass (mcls), mID, jdoubleArray (dv),
+                                     jintArray (iv));
           jcls = jni_env->GetObjectClass (jobj);
         }
       else if (val.is_int8_type ())
         {
           int8NDArray m = val.int8_array_value ();
           jbyteArray_ref bv (jni_env, jni_env->NewByteArray (m.length ()));
-          jni_env->SetByteArrayRegion (jbyteArray (bv), 0, m.length (), reinterpret_cast <jbyte *> (m.fortran_vec ()));
+          jni_env->SetByteArrayRegion (jbyteArray (bv), 0, m.length (),
+                                       reinterpret_cast <jbyte *> (m.fortran_vec ()));
           jmethodID mID = jni_env->GetMethodID (mcls, "<init>", "([B[I)V");
           jobj = jni_env->NewObject (jclass (mcls), mID, jbyteArray (bv), jintArray (iv));
           jcls = jni_env->GetObjectClass (jobj);
         }
       else if (val.is_uint8_type ())
         {
           uint8NDArray m = val.uint8_array_value ();
           jbyteArray_ref bv (jni_env, jni_env->NewByteArray (m.length ()));
-          jni_env->SetByteArrayRegion (jbyteArray (bv), 0, m.length (), reinterpret_cast<jbyte *> (m.fortran_vec ()));
+          jni_env->SetByteArrayRegion (jbyteArray (bv), 0, m.length (),
+                                       reinterpret_cast<jbyte *> (m.fortran_vec ()));
           jmethodID mID = jni_env->GetMethodID (mcls, "<init>", "([B[I)V");
           jobj = jni_env->NewObject (jclass (mcls), mID, jbyteArray (bv), jintArray (iv));
           jcls = jni_env->GetObjectClass (jobj);
         }
       else if (val.is_int32_type ())
         {
           int32NDArray m = val.int32_array_value ();
           jintArray_ref v (jni_env, jni_env->NewIntArray (m.length ()));
-          jni_env->SetIntArrayRegion (jintArray (v), 0, m.length (), reinterpret_cast<jint *> (m.fortran_vec ()));
+          jni_env->SetIntArrayRegion (jintArray (v), 0, m.length (),
+                                      reinterpret_cast<jint *> (m.fortran_vec ()));
           jmethodID mID = jni_env->GetMethodID (mcls, "<init>", "([I[I)V");
           jobj = jni_env->NewObject (jclass (mcls), mID, jintArray (v), jintArray (iv));
           jcls = jni_env->GetObjectClass (jobj);
         }
       else
         {
           found = 0;
           error ("cannot convert matrix of type '%s'", val.class_name ().c_str ());
@@ -1326,17 +1343,18 @@ unbox (JNIEnv* jni_env, const octave_val
     }
   else if (val.is_cellstr ())
     {
       Cell cellStr = val.cell_value ();
       jclass_ref scls (jni_env, jni_env->FindClass ("java/lang/String"));
       jobjectArray array = jni_env->NewObjectArray (cellStr.length (), scls, 0);
       for (int i = 0; i < cellStr.length (); i++)
         {
-          jstring_ref jstr (jni_env, jni_env->NewStringUTF (cellStr(i).string_value().c_str ()));
+          jstring_ref jstr (jni_env,
+                            jni_env->NewStringUTF (cellStr(i).string_value().c_str ()));
           jni_env->SetObjectArrayElement (array, i, jstr);
         }
       jobj = array;
       jcls = jni_env->GetObjectClass (jobj);
     }
   else
     {
       jclass rcls = find_octave_class (jni_env, "org/octave/OctaveReference");
@@ -1555,17 +1573,17 @@ DEFINE_OCTAVE_ALLOCATOR (octave_java);
 int octave_java::t_id (-1);
 
 const std::string octave_java::t_name ("octave_java");
 
 void
 octave_java::register_type (void)
 {
   t_id = octave_value_typeinfo::register_type
-    (octave_java::t_name, "<unknown>", octave_value (new octave_java ()));
+         (octave_java::t_name, "<unknown>", octave_value (new octave_java ()));
 }
 
 dim_vector
 octave_java::dims (void) const
 {
   JNIEnv *current_env = thread_jni_env ();
 
   if (current_env && java_object)
@@ -1640,86 +1658,86 @@ octave_java::subsasgn (const std::string
                        const octave_value &rhs)
 {
   octave_value retval;
 
   JNIEnv *current_env = thread_jni_env ();
 
   switch (type[0])
     {
-      case '.':
-        if (type.length () == 1)
-          {
-            // field assignment
-            octave_value_list ovl;
-            count++;
-            ovl(0) = octave_value (this);
-            ovl(1) = (idx.front ())(0);
-            ovl(2) = rhs;
-            feval ("__java_set__", ovl, 0);
-            if (! error_state)
-              {
-                count++;
-                retval = octave_value (this);
-              }
-          }
-        else if (type.length () > 2 && type[1] == '(')
-          {
-            std::list<octave_value_list> new_idx;
-            std::list<octave_value_list>::const_iterator it = idx.begin ();
-            new_idx.push_back (*it++);
-            new_idx.push_back (*it++);
-            octave_value_list u = subsref (type.substr (0, 2), new_idx, 1);
-            if (! error_state)
-              {
-                std::list<octave_value_list> next_idx (idx);
-                next_idx.erase (next_idx.begin ());
-                next_idx.erase (next_idx.begin ());
-                u(0).subsasgn (type.substr (2), next_idx, rhs);
-                if (! error_state)
-                  {
-                    count++;
-                    retval = octave_value (this);
-                  }
-              }
-          }
-        else if (type[1] == '.')
-          {
-            octave_value_list u = subsref (type.substr (0, 1), idx, 1);
-            if (! error_state)
-              {
-                std::list<octave_value_list> next_idx (idx);
-                next_idx.erase (next_idx.begin ());
-                u(0).subsasgn (type.substr (1), next_idx, rhs);
-                if (! error_state)
-                  {
-                    count++;
-                    retval = octave_value (this);
-                  }
-              }
-          }
-        else
-          error ("invalid indexing/assignment on Java object");
-        break;
+    case '.':
+      if (type.length () == 1)
+        {
+          // field assignment
+          octave_value_list ovl;
+          count++;
+          ovl(0) = octave_value (this);
+          ovl(1) = (idx.front ())(0);
+          ovl(2) = rhs;
+          feval ("__java_set__", ovl, 0);
+          if (! error_state)
+            {
+              count++;
+              retval = octave_value (this);
+            }
+        }
+      else if (type.length () > 2 && type[1] == '(')
+        {
+          std::list<octave_value_list> new_idx;
+          std::list<octave_value_list>::const_iterator it = idx.begin ();
+          new_idx.push_back (*it++);
+          new_idx.push_back (*it++);
+          octave_value_list u = subsref (type.substr (0, 2), new_idx, 1);
+          if (! error_state)
+            {
+              std::list<octave_value_list> next_idx (idx);
+              next_idx.erase (next_idx.begin ());
+              next_idx.erase (next_idx.begin ());
+              u(0).subsasgn (type.substr (2), next_idx, rhs);
+              if (! error_state)
+                {
+                  count++;
+                  retval = octave_value (this);
+                }
+            }
+        }
+      else if (type[1] == '.')
+        {
+          octave_value_list u = subsref (type.substr (0, 1), idx, 1);
+          if (! error_state)
+            {
+              std::list<octave_value_list> next_idx (idx);
+              next_idx.erase (next_idx.begin ());
+              u(0).subsasgn (type.substr (1), next_idx, rhs);
+              if (! error_state)
+                {
+                  count++;
+                  retval = octave_value (this);
+                }
+            }
+        }
+      else
+        error ("invalid indexing/assignment on Java object");
+      break;
 
-      case '(':
-        if (current_env)
-          {
-            set_array_elements (current_env, to_java (), idx.front (), rhs);
-            if (! error_state)
-              {
-                count++;
-                retval = octave_value (this);
-              }
-          }
-        break;
+    case '(':
+      if (current_env)
+        {
+          set_array_elements (current_env, to_java (), idx.front (), rhs);
+          if (! error_state)
+            {
+              count++;
+              retval = octave_value (this);
+            }
+        }
+      break;
 
-      default:
-        error ("Java object cannot be indexed with %c", type[0]);
-        break;
+    default:
+      error ("Java object cannot be indexed with %c", type[0]);
+      break;
     }
 
   return retval;
 }
 
 string_vector
 octave_java::map_keys (void) const
 {
@@ -1752,17 +1770,17 @@ octave_java::print (std::ostream& os, bo
 void
 octave_java::print_raw (std::ostream& os, bool) const
 {
   os << "<Java object: " << java_classname << ">";
 }
 
 octave_value
 octave_java::do_javaMethod (JNIEnv* jni_env, const std::string& name,
-                             const octave_value_list& args)
+                            const octave_value_list& args)
 {
   octave_value retval;
 
   if (jni_env)
     {
       jobjectArray_ref arg_objs (jni_env), arg_types (jni_env);
       if (unbox (jni_env, args, arg_objs, arg_types))
         {
@@ -1781,19 +1799,19 @@ octave_java::do_javaMethod (JNIEnv* jni_
       restore_fpu_state ();
     }
 
   return retval;
 }
 
 octave_value
 octave_java:: do_javaMethod (JNIEnv* jni_env,
-                              const std::string& class_name,
-                              const std::string& name,
-                              const octave_value_list& args)
+                             const std::string& class_name,
+                             const std::string& name,
+                             const octave_value_list& args)
 {
   octave_value retval;
 
   if (jni_env)
     {
       jobjectArray_ref arg_objs (jni_env), arg_types (jni_env);
       if (unbox (jni_env, args, arg_objs, arg_types))
         {
@@ -1813,17 +1831,17 @@ octave_java:: do_javaMethod (JNIEnv* jni
       restore_fpu_state ();
     }
 
   return retval;
 }
 
 octave_value
 octave_java::do_javaObject (JNIEnv* jni_env, const std::string& name,
-                             const octave_value_list& args)
+                            const octave_value_list& args)
 {
   octave_value retval;
 
   if (jni_env)
     {
       jobjectArray_ref arg_objs (jni_env), arg_types (jni_env);
 
       if (unbox (jni_env, args, arg_objs, arg_types))
@@ -1954,17 +1972,17 @@ octave_java::do_java_set (JNIEnv* jni_en
 }
 
 #endif  // endif on HAVE_JAVA
 
 // DEFUN blocks below must be outside of HAVE_JAVA block so that
 // documentation strings are always available, even when functions are not.
 
 DEFUN (__java_init__, , ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} java_init ()\n\
 Internal function used @strong{only} when debugging Java interface.\n\
 Function will directly call initialize_java() to create an instance of a JVM.\n\
 @end deftypefn")
 {
 
 #ifdef HAVE_JAVA
   octave_value retval;
@@ -1979,34 +1997,34 @@ Function will directly call initialize_j
   return retval;
 #else
   error ("__java_init__: Octave was not compiled with Java interface");
   return octave_value ();
 #endif
 }
 
 DEFUN (__java_exit__, , ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} java_exit ()\n\
 Internal function used @strong{only} when debugging Java interface.\n\
 Function will directly call terminate_jvm() to destroy the current JVM\n\
 instance.\n\
 @end deftypefn")
 {
 #ifdef HAVE_JAVA
   terminate_jvm ();
 #else
   error ("__java_init__: Octave was not compiled with Java interface");
 #endif
 
   return octave_value ();
 }
 
 DEFUN (javaObject, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{jobj} =} javaObject (@var{classname})\n\
 @deftypefnx {Built-in Function} {@var{jobj} =} javaObject (@var{classname}, @var{arg1}, @dots{})\n\
 Create a Java object of class @var{classsname}, by calling the class\n\
 constructor with the arguments @var{arg1}, @dots{}\n\
 \n\
 The first example below creates an uninitialized object,\n\
 while the second example supplies an initial argument to the constructor.\n\
 \n\
@@ -2057,17 +2075,17 @@ x = javaObject (\"java.lang.StringBuffer
 %!testif HAVE_JAVA
 %% The tests below merely check if javaObject works at all. Whether it works
 %% properly, i.e. creates the right values, is a matter of Java itself
 %% Create a Short and check if it really is a short, i.e. whether it overflows
 %! assert (javaObject ("java.lang.Short", 40000).doubleValue < 0);
 */
 
 DEFUN (javaMethod, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{ret} =} javaMethod (@var{methodname}, @var{obj})\n\
 @deftypefnx {Built-in Function} {@var{ret} =} javaMethod (@var{methodname}, @var{obj}, @var{arg1}, @dots{})\n\
 Invoke the method @var{methodname} on the Java object @var{obj} with the\n\
 arguments @var{arg1}, @dots{}  For static methods, @var{obj} can be a string\n\
 representing the fully qualified name of the corresponding class.  The\n\
 function returns the result of the method invocation.\n\
 \n\
 When @var{obj} is a regular Java object, structure-like indexing can be\n\
@@ -2132,17 +2150,17 @@ equivalent\n\
 /*
 %!testif HAVE_JAVA
 %% Check for valid first two Java version numbers
 %! jver = strsplit (javaMethod ('getProperty', 'java.lang.System', 'java.version'), '.');
 %! assert (isfinite (str2double (jver{1})) && isfinite (str2double (jver{2})));
 */
 
 DEFUN (__java_get__, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{val} =} __java_get__ (@var{obj}, @var{name})\n\
 Get the value of the field @var{name} of the Java object @var{obj}.  For\n\
 static fields, @var{obj} can be a string representing the fully qualified\n\
 name of the corresponding class.\n\
 \n\
 When @var{obj} is a regular Java object, structure-like indexing can be\n\
 used as a shortcut syntax.  For instance, the two following statements are\n\
 equivalent\n\
@@ -2194,17 +2212,17 @@ equivalent\n\
   return retval;
 #else
   error ("__java_get__: Octave was not compiled with Java interface");
   return octave_value ();
 #endif
 }
 
 DEFUN (__java_set__, args, ,
-    "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{obj} =} __java_set__ (@var{obj}, @var{name}, @var{val})\n\
 Set the value of the field @var{name} of the Java object @var{obj} to\n\
 @var{val}.  For static fields, @var{obj} can be a string representing the\n\
 fully qualified named of the corresponding Java class.\n\
 \n\
 When @var{obj} is a regular Java object, structure-like indexing can be\n\
 used as a shortcut syntax.  For instance, the two following statements are\n\
 equivalent\n\
@@ -2256,17 +2274,17 @@ equivalent\n\
   return retval;
 #else
   error ("__java_set__: Octave was not compiled with Java interface");
   return octave_value ();
 #endif
 }
 
 DEFUN (java2mat, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} java2mat (@var{javaobj})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
 #ifdef HAVE_JAVA
   octave_value_list retval;
 
   initialize_java ();
@@ -2292,17 +2310,17 @@ Undocumented internal function.\n\
   return retval;
 #else
   error ("java2mat: Octave was not compiled with Java interface");
   return octave_value ();
 #endif
 }
 
 DEFUN (java_matrix_autoconversion, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} java_matrix_autoconversion ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} java_matrix_autoconversion (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} java_matrix_autoconversion (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Java arrays are\n\
 automatically converted to Octave matrices.  The default value is false.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.  \n\
@@ -2314,17 +2332,17 @@ The original variable value is restored 
   return SET_INTERNAL_VARIABLE (java_matrix_autoconversion);
 #else
   error ("java_matrix_autoconversion: Octave was not compiled with Java interface");
   return octave_value ();
 #endif
 }
 
 DEFUN (java_unsigned_autoconversion, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} java_unsigned_autoconversion ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} java_unsigned_autoconversion (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} java_unsigned_autoconversion (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls how integer classes are\n\
 converted when @code{java_matrix_autoconversion} is enabled.  When enabled,\n\
 Java arrays of class Byte or Integer are converted to matrices of class\n\
 uint8 or uint32 respectively.  The default value is true.\n\
 \n\
@@ -2338,17 +2356,17 @@ The original variable value is restored 
   return SET_INTERNAL_VARIABLE (java_unsigned_autoconversion);
 #else
   error ("java_unsigned_autoconversion: Octave was not compiled with Java interface");
   return octave_value ();
 #endif
 }
 
 DEFUN (debug_java, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} debug_java ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} debug_java (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} debug_java (@var{new_val}, \"local\")\n\
 Query or set the internal variable that determines whether extra debugging\n\
 information regarding the initialization of the JVM and any Java exceptions\n\
 is printed.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
@@ -2361,19 +2379,19 @@ The original variable value is restored 
   return SET_INTERNAL_VARIABLE (debug_java);
 #else
   error ("debug_java: Octave was not compiled with Java interface");
   return octave_value ();
 #endif
 }
 
 // Outside of #ifdef HAVE_JAVA because it is desirable to be able to
-// test for the presence of a Java object without having Java installed. 
+// test for the presence of a Java object without having Java installed.
 DEFUN (isjava, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isjava (@var{x})\n\
 Return true if @var{x} is a Java object.\n\
 @seealso{class, typeinfo, isa, javaObject}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 1)
diff --git a/libinterp/octave-value/ov-lazy-idx.h b/libinterp/octave-value/ov-lazy-idx.h
--- a/libinterp/octave-value/ov-lazy-idx.h
+++ b/libinterp/octave-value/ov-lazy-idx.h
@@ -40,73 +40,74 @@ public:
   octave_lazy_index (const idx_vector& idx)
     : octave_base_value (), index (idx), value () { }
 
   octave_lazy_index (const octave_lazy_index& i)
     : octave_base_value (), index (i.index), value (i.value) { }
 
   ~octave_lazy_index (void) { }
 
-  octave_base_value *clone (void) const { return new octave_lazy_index (*this); }
+  octave_base_value *clone (void) const
+  { return new octave_lazy_index (*this); }
   octave_base_value *empty_clone (void) const { return new octave_matrix (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
   octave_base_value *try_narrowing_conversion (void);
 
   size_t byte_size (void) const { return numel () * sizeof (octave_idx_type); }
 
   octave_value squeeze (void) const;
 
   octave_value full_value (void) const { return make_value (); }
 
   idx_vector index_vector (void) const
-    { return index; }
+  { return index; }
 
   builtin_type_t builtin_type (void) const { return btyp_double; }
 
   bool is_real_matrix (void) const { return true; }
 
   bool is_real_type (void) const { return true; }
 
   bool is_double_type (void) const { return true; }
 
   bool is_float_type (void) const { return true; }
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx)
-    { return make_value ().subsref (type, idx); }
+  { return make_value ().subsref (type, idx); }
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx, int)
-    { return subsref (type, idx); }
+  { return subsref (type, idx); }
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false)
-    { return make_value ().do_index_op (idx, resize_ok); }
+  { return make_value ().do_index_op (idx, resize_ok); }
 
   dim_vector dims (void) const { return index.orig_dimensions (); }
 
   octave_idx_type numel (void) const { return index.length (0); }
 
   octave_idx_type nnz (void) const { return numel (); }
 
   octave_value reshape (const dim_vector& new_dims) const;
 
   octave_value permute (const Array<int>& vec, bool inv = false) const;
 
   octave_value resize (const dim_vector& dv, bool fill = false) const
-    { return make_value ().resize (dv, fill); }
+  { return make_value ().resize (dv, fill); }
 
   octave_value all (int dim = 0) const { return make_value ().all (dim); }
   octave_value any (int dim = 0) const { return make_value ().any (dim); }
 
   MatrixType matrix_type (void) const { return make_value ().matrix_type (); }
   MatrixType matrix_type (const MatrixType& _typ) const
-    { return make_value ().matrix_type (_typ); }
+  { return make_value ().matrix_type (_typ); }
 
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const;
 
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
                      sortmode mode = ASCENDING) const;
 
   sortmode is_sorted (sortmode mode = UNSORTED) const;
 
@@ -118,26 +119,26 @@ public:
 
   bool is_numeric_type (void) const { return true; }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
 
   bool is_true (void) const
-    { return make_value ().is_true (); }
+  { return make_value ().is_true (); }
 
   bool print_as_scalar (void) const
-    { return make_value ().print_as_scalar (); }
+  { return make_value ().print_as_scalar (); }
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const
-    { make_value ().print (os, pr_as_read_syntax); }
+  { make_value ().print (os, pr_as_read_syntax); }
 
   void print_info (std::ostream& os, const std::string& prefix) const
-    { make_value ().print_info (os, prefix); }
+  { make_value ().print_info (os, prefix); }
 
 #define FORWARD_VALUE_QUERY(TYPE,NAME) \
   TYPE \
   NAME (void) const { return make_value ().NAME (); }
 
   FORWARD_VALUE_QUERY (int8NDArray,  int8_array_value)
   FORWARD_VALUE_QUERY (int16NDArray, int16_array_value)
   FORWARD_VALUE_QUERY (int32NDArray, int32_array_value)
@@ -181,70 +182,71 @@ public:
 
   FORWARD_VALUE_QUERY1 (FloatNDArray, float_array_value)
 
   FORWARD_VALUE_QUERY1 (SparseMatrix, sparse_matrix_value)
 
   FORWARD_VALUE_QUERY1 (SparseComplexMatrix, sparse_complex_matrix_value)
 
   octave_value diag (octave_idx_type k = 0) const
-    { return make_value ().diag (k); }
+  { return make_value ().diag (k); }
 
   octave_value convert_to_str_internal (bool pad, bool force, char type) const
-    { return make_value ().convert_to_str_internal (pad, force, type); }
+  { return make_value ().convert_to_str_internal (pad, force, type); }
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const
-    { return make_value ().print_raw (os, pr_as_read_syntax); }
+  { return make_value ().print_raw (os, pr_as_read_syntax); }
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
   // HDF5 functions not defined.
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
-    { return make_value ().write (os, block_size, output_type, skip, flt_fmt); }
+  { return make_value ().write (os, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const
-    { return make_value ().mex_get_data (); }
+  { return make_value ().mex_get_data (); }
 
   mxArray *as_mxArray (void) const
-    { return make_value ().as_mxArray (); }
+  { return make_value ().as_mxArray (); }
 
   octave_value map (unary_mapper_t umap) const
-    { return make_value ().map (umap); }
+  { return make_value ().map (umap); }
 
 private:
   const octave_value& make_value (void) const
-    {
-      if (value.is_undefined ())
-        value = octave_value (index, false);
+  {
+    if (value.is_undefined ())
+      value = octave_value (index, false);
 
-      return value;
-    }
+    return value;
+  }
 
   octave_value& make_value (void)
-    {
-      if (value.is_undefined ())
-        value = octave_value (index, false);
+  {
+    if (value.is_undefined ())
+      value = octave_value (index, false);
 
-      return value;
-    }
+    return value;
+  }
 
   idx_vector index;
   mutable octave_value value;
 
-  static octave_base_value *numeric_conversion_function (const octave_base_value&);
+  static octave_base_value *
+  numeric_conversion_function (const octave_base_value&);
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
diff --git a/libinterp/octave-value/ov-mex-fcn.cc b/libinterp/octave-value/ov-mex-fcn.cc
--- a/libinterp/octave-value/ov-mex-fcn.cc
+++ b/libinterp/octave-value/ov-mex-fcn.cc
@@ -101,33 +101,33 @@ octave_mex_function::subsref (const std:
         error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
       }
       break;
 
     default:
       panic_impossible ();
     }
 
-  // FIXME -- perhaps there should be an
+  // FIXME: perhaps there should be an
   // octave_value_list::next_subsref member function?  See also
   // octave_user_function::subsref.
   //
-  // FIXME -- Note that if a function call returns multiple
+  // FIXME: Note that if a function call returns multiple
   // values, and there is further indexing to perform, then we are
   // ignoring all but the first value.  Is this really what we want to
   // do?  If it is not, then what should happen for stat("file").size,
   // for exmaple?
 
   if (idx.size () > 1)
     retval = retval(0).next_subsref (nargout, type, idx);
 
   return retval;
 }
 
-// FIXME -- shouldn't this declaration be a header file somewhere?
+// FIXME: shouldn't this declaration be a header file somewhere?
 extern octave_value_list
 call_mex (bool have_fmex, void *f, const octave_value_list& args,
           int nargout, octave_mex_function *curr_mex_fcn);
 
 octave_value_list
 octave_mex_function::do_multi_index_op (int nargout,
                                         const octave_value_list& args)
 {
diff --git a/libinterp/octave-value/ov-mex-fcn.h b/libinterp/octave-value/ov-mex-fcn.h
--- a/libinterp/octave-value/ov-mex-fcn.h
+++ b/libinterp/octave-value/ov-mex-fcn.h
@@ -49,20 +49,20 @@ public:
 
   octave_mex_function (void *fptr, bool fmex, const octave_shlib& shl,
                        const std::string& nm = std::string ());
 
   ~octave_mex_function (void);
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx)
-    {
-      octave_value_list tmp = subsref (type, idx, 1);
-      return tmp.length () > 0 ? tmp(0) : octave_value ();
-    }
+  {
+    octave_value_list tmp = subsref (type, idx, 1);
+    return tmp.length () > 0 ? tmp(0) : octave_value ();
+  }
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              int nargout);
 
   octave_function *function_value (bool = false) { return this; }
 
   const octave_function *function_value (bool = false) const { return this; }
@@ -82,17 +82,17 @@ public:
   bool is_mex_function (void) const { return true; }
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
   void atexit (void (*fcn) (void)) { exit_fcn_ptr = fcn; }
 
   octave_shlib get_shlib (void) const
-    { return sh_lib; }
+  { return sh_lib; }
 
 private:
 
   void *mex_fcn_ptr;
 
   void (*exit_fcn_ptr) (void);
 
   bool have_fmex;
diff --git a/libinterp/octave-value/ov-null-mat.cc b/libinterp/octave-value/ov-null-mat.cc
--- a/libinterp/octave-value/ov-null-mat.cc
+++ b/libinterp/octave-value/ov-null-mat.cc
@@ -23,34 +23,36 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "ov-null-mat.h"
 #include "ops.h"
 #include "defun.h"
 
-DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_null_matrix, "null_matrix", "double");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_null_matrix, "null_matrix",
+                                     "double");
 
 const octave_value octave_null_matrix::instance (new octave_null_matrix ());
 
 static octave_base_value *
 default_null_matrix_numeric_conversion_function (const octave_base_value& a)
 {
   // The cast is not necessary?
   // CAST_CONV_ARG (const octave_null_matrix&);
 
   return a.empty_clone ();
 }
 
 octave_base_value::type_conv_info
 octave_null_matrix::numeric_conversion_function (void) const
 {
-  return octave_base_value::type_conv_info (default_null_matrix_numeric_conversion_function,
-                                            octave_matrix::static_type_id ());
+  return octave_base_value::type_conv_info
+           (default_null_matrix_numeric_conversion_function,
+            octave_matrix::static_type_id ());
 }
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_null_str, "null_string", "char");
 
 const octave_value octave_null_str::instance (new octave_null_str ());
 
 static octave_base_value *
 default_null_str_numeric_conversion_function (const octave_base_value& a)
@@ -59,42 +61,45 @@ default_null_str_numeric_conversion_func
   // CAST_CONV_ARG (const octave_null_str&);
 
   return a.empty_clone ();
 }
 
 octave_base_value::type_conv_info
 octave_null_str::numeric_conversion_function (void) const
 {
-  return octave_base_value::type_conv_info (default_null_str_numeric_conversion_function,
-                                            octave_char_matrix_str::static_type_id ());
+  return octave_base_value::type_conv_info
+          (default_null_str_numeric_conversion_function,
+           octave_char_matrix_str::static_type_id ());
 }
 
-DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_null_sq_str, "null_sq_string", "char");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_null_sq_str, "null_sq_string",
+                                     "char");
 
 const octave_value octave_null_sq_str::instance (new octave_null_sq_str ());
 
 static octave_base_value *
 default_null_sq_str_numeric_conversion_function (const octave_base_value& a)
 {
   // The cast is not necessary?
   // CAST_CONV_ARG (const octave_null_sq_str&);
 
   return a.empty_clone ();
 }
 
 octave_base_value::type_conv_info
 octave_null_sq_str::numeric_conversion_function (void) const
 {
-  return octave_base_value::type_conv_info (default_null_sq_str_numeric_conversion_function,
-                                            octave_char_matrix_sq_str::static_type_id ());
+  return octave_base_value::type_conv_info
+           (default_null_sq_str_numeric_conversion_function,
+            octave_char_matrix_sq_str::static_type_id ());
 }
 
 DEFUN (isnull, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isnull (@var{x})\n\
 Return true if @var{x} is a special null matrix, string, or single quoted\n\
 string.  Indexed assignment with such a value on the right-hand side should\n\
 delete array elements.  This function should be used when overloading\n\
 indexed assignment for user-defined classes instead of @code{isempty}, to\n\
 distinguish the cases:\n\
 \n\
 @table @asis\n\
diff --git a/libinterp/octave-value/ov-null-mat.h b/libinterp/octave-value/ov-null-mat.h
--- a/libinterp/octave-value/ov-null-mat.h
+++ b/libinterp/octave-value/ov-null-mat.h
@@ -23,20 +23,21 @@ along with Octave; see the file COPYING.
 #if !defined (octave_null_matrix_h)
 #define octave_null_matrix_h 1
 
 #include "ov.h"
 #include "ov-re-mat.h"
 #include "ov-str-mat.h"
 
 // Design rationale:
-// The constructors are hidden. There is only one null matrix (or null string) object,
-// that can have shallow copies. Cloning the object returns just a normal empty matrix,
-// so all the shallow copies are, in fact, read-only. This conveniently ensures that any
-// attempt to fiddle with the null matrix destroys its special status.
+// The constructors are hidden.  There is only one null matrix (or null string)
+// object, that can have shallow copies.  Cloning the object returns just a
+// normal empty matrix, so all the shallow copies are, in fact, read-only. This
+// conveniently ensures that any attempt to fiddle with the null matrix
+// destroys its special status.
 
 // The special [] value.
 
 class
 OCTINTERP_API
 octave_null_matrix : public octave_matrix
 {
   octave_null_matrix (void) : octave_matrix () { }
diff --git a/libinterp/octave-value/ov-oncleanup.cc b/libinterp/octave-value/ov-oncleanup.cc
--- a/libinterp/octave-value/ov-oncleanup.cc
+++ b/libinterp/octave-value/ov-oncleanup.cc
@@ -132,17 +132,18 @@ octave_oncleanup::save_ascii (std::ostre
 bool
 octave_oncleanup::load_ascii (std::istream& /* is */)
 {
   warn_save_load ();
   return true;
 }
 
 bool
-octave_oncleanup::save_binary (std::ostream& /* os */, bool& /* save_as_floats */)
+octave_oncleanup::save_binary (std::ostream& /* os */,
+                               bool& /* save_as_floats */)
 {
   warn_save_load ();
   return true;
 }
 
 bool
 octave_oncleanup::load_binary (std::istream& /* is */, bool /* swap */,
                                oct_mach_info::float_format /* fmt */)
@@ -180,17 +181,17 @@ octave_oncleanup::print_raw (std::ostrea
 {
   os << "onCleanup (";
   if (fcn.is_defined ())
     fcn.print_raw (os, pr_as_read_syntax);
   os << ")";
 }
 
 DEFUN (onCleanup, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{c} =} onCleanup (@var{action})\n\
 Create a special object that executes a given function upon destruction.\n\
 If the object is copied to multiple variables (or cell or struct array\n\
 elements) or returned from a function, @var{action} will be executed after\n\
 clearing the last copy of the object.  Note that if multiple local onCleanup\n\
 variables are created, the order in which they are called is unspecified.\n\
 For similar functionality @xref{The unwind_protect Statement}.\n\
 @end deftypefn")
diff --git a/libinterp/octave-value/ov-perm.cc b/libinterp/octave-value/ov-perm.cc
--- a/libinterp/octave-value/ov-perm.cc
+++ b/libinterp/octave-value/ov-perm.cc
@@ -246,17 +246,18 @@ FORWARD_MATRIX_VALUE (charNDArray, char_
 
 idx_vector
 octave_perm_matrix::index_vector (void) const
 {
   return to_dense ().index_vector ();
 }
 
 octave_value
-octave_perm_matrix::convert_to_str_internal (bool pad, bool force, char type) const
+octave_perm_matrix::convert_to_str_internal (bool pad, bool force,
+                                             char type) const
 {
   return to_dense ().convert_to_str_internal (pad, force, type);
 }
 
 bool
 octave_perm_matrix::save_ascii (std::ostream& os)
 {
   typedef octave_int<octave_idx_type> idx_int_type;
@@ -314,17 +315,18 @@ octave_perm_matrix::load_ascii (std::ist
 bool
 octave_perm_matrix::save_binary (std::ostream& os, bool&)
 {
 
   int32_t sz = matrix.rows ();
   bool colp = matrix.is_col_perm ();
   os.write (reinterpret_cast<char *> (&sz), 4);
   os.write (reinterpret_cast<char *> (&colp), 1);
-  os.write (reinterpret_cast<const char *> (matrix.data ()), matrix.byte_size ());
+  os.write (reinterpret_cast<const char *> (matrix.data ()),
+                                            matrix.byte_size ());
 
   return true;
 }
 
 bool
 octave_perm_matrix::load_binary (std::istream& is, bool swap,
                                  oct_mach_info::float_format )
 {
@@ -390,35 +392,35 @@ void
 octave_perm_matrix::print (std::ostream& os, bool pr_as_read_syntax) const
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 
 int
 octave_perm_matrix::write (octave_stream& os, int block_size,
-                                oct_data_conv::data_type output_type, int skip,
-                                oct_mach_info::float_format flt_fmt) const
+                           oct_data_conv::data_type output_type, int skip,
+                           oct_mach_info::float_format flt_fmt) const
 {
   return to_dense ().write (os, block_size, output_type, skip, flt_fmt);
 }
 
 void
 octave_perm_matrix::print_info (std::ostream& os,
-                                    const std::string& prefix) const
+                                const std::string& prefix) const
 {
   matrix.print_info (os, prefix);
 }
 
 
 octave_value
 octave_perm_matrix::to_dense (void) const
 {
   if (! dense_cache.is_defined ())
-      dense_cache = Matrix (matrix);
+    dense_cache = Matrix (matrix);
 
   return dense_cache;
 }
 
 DEFINE_OCTAVE_ALLOCATOR (octave_perm_matrix);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_perm_matrix,
                                      "permutation matrix", "double");
diff --git a/libinterp/octave-value/ov-perm.h b/libinterp/octave-value/ov-perm.h
--- a/libinterp/octave-value/ov-perm.h
+++ b/libinterp/octave-value/ov-perm.h
@@ -34,76 +34,78 @@ class
 OCTINTERP_API
 octave_perm_matrix : public octave_base_value
 {
 public:
   octave_perm_matrix (void) : matrix (), dense_cache () { }
 
   octave_perm_matrix (const PermMatrix& p) : matrix (p), dense_cache () { }
 
-  octave_base_value *clone (void) const { return new octave_perm_matrix (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_perm_matrix (); }
+  octave_base_value *clone (void) const
+  { return new octave_perm_matrix (*this); }
+  octave_base_value *empty_clone (void) const
+  { return new octave_perm_matrix (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
   octave_base_value *try_narrowing_conversion (void);
 
   size_t byte_size (void) const { return matrix.byte_size (); }
 
   octave_value squeeze (void) const { return matrix; }
 
   octave_value full_value (void) const { return to_dense (); }
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx);
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx, int)
-    { return subsref (type, idx); }
+  { return subsref (type, idx); }
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false);
 
   dim_vector dims (void) const { return matrix.dims (); }
 
   octave_idx_type nnz (void) const { return matrix.rows (); }
 
   octave_value reshape (const dim_vector& new_dims) const
-    { return to_dense ().reshape (new_dims); }
+  { return to_dense ().reshape (new_dims); }
 
   octave_value permute (const Array<int>& vec, bool inv = false) const
-    { return to_dense ().permute (vec, inv); }
+  { return to_dense ().permute (vec, inv); }
 
   octave_value resize (const dim_vector& dv, bool fill = false) const
-    { return to_dense ().resize (dv, fill); }
+  { return to_dense ().resize (dv, fill); }
 
   octave_value all (int dim = 0) const { return to_dense ().all (dim); }
   octave_value any (int dim = 0) const { return to_dense ().any (dim); }
 
   MatrixType matrix_type (void) const { return MatrixType::Permuted_Diagonal; }
   MatrixType matrix_type (const MatrixType&) const
-    { return matrix_type (); }
+  { return matrix_type (); }
 
   octave_value diag (octave_idx_type k = 0) const
-    { return to_dense () .diag (k); }
+  { return to_dense () .diag (k); }
 
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
-    { return to_dense ().sort (dim, mode); }
+  { return to_dense ().sort (dim, mode); }
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
                      sortmode mode = ASCENDING) const
-    { return to_dense ().sort (sidx, dim, mode); }
+  { return to_dense ().sort (sidx, dim, mode); }
 
   sortmode is_sorted (sortmode mode = UNSORTED) const
-    { return to_dense ().is_sorted (mode); }
+  { return to_dense ().is_sorted (mode); }
 
   Array<octave_idx_type> sort_rows_idx (sortmode mode = ASCENDING) const
-    { return to_dense ().sort_rows_idx (mode); }
+  { return to_dense ().sort_rows_idx (mode); }
 
   sortmode is_sorted_rows (sortmode mode = UNSORTED) const
-    { return to_dense ().is_sorted_rows (mode); }
+  { return to_dense ().is_sorted_rows (mode); }
 
   builtin_type_t builtin_type (void) const { return btyp_double; }
 
   bool is_perm_matrix (void) const { return true; }
 
   bool is_matrix_type (void) const { return true; }
 
   bool is_numeric_type (void) const { return true; }
@@ -122,22 +124,22 @@ public:
 
   bool is_true (void) const;
 
   double double_value (bool = false) const;
 
   float float_value (bool = false) const;
 
   double scalar_value (bool frc_str_conv = false) const
-    { return double_value (frc_str_conv); }
+  { return double_value (frc_str_conv); }
 
   idx_vector index_vector (void) const;
 
   PermMatrix perm_matrix_value (void) const
-    { return matrix; }
+  { return matrix; }
 
   Matrix matrix_value (bool = false) const;
 
   FloatMatrix float_matrix_value (bool = false) const;
 
   Complex complex_value (bool = false) const;
 
   FloatComplex float_complex_value (bool = false) const;
@@ -209,17 +211,17 @@ public:
 
   bool print_as_scalar (void) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_info (std::ostream& os, const std::string& prefix) const;
 
   octave_value map (unary_mapper_t umap) const
-    { return to_dense ().map (umap); }
+  { return to_dense ().map (umap); }
 
 protected:
 
   PermMatrix matrix;
 
   virtual octave_value to_dense (void) const;
 
   mutable octave_value dense_cache;
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -219,39 +219,40 @@ octave_range::char_array_value (bool) co
     retval.elem (i) = static_cast<char>(matrix.elem (i));
 
   return retval;
 }
 
 octave_value
 octave_range::all (int dim) const
 {
-  // FIXME -- this is a potential waste of memory.
+  // FIXME: this is a potential waste of memory.
 
   Matrix m = range.matrix_value ();
 
   return m.all (dim);
 }
 
 octave_value
 octave_range::any (int dim) const
 {
-  // FIXME -- this is a potential waste of memory.
+  // FIXME: this is a potential waste of memory.
 
   Matrix m = range.matrix_value ();
 
   return m.any (dim);
 }
 
 octave_value
 octave_range::diag (octave_idx_type k) const
 {
-  return (k == 0
-          ? octave_value (DiagMatrix (DiagArray2<double> (range.matrix_value ())))
-          : octave_value (range.diag (k)));
+  return
+    (k == 0
+       ? octave_value (DiagMatrix (DiagArray2<double> (range.matrix_value ())))
+       : octave_value (range.diag (k)));
 }
 
 octave_value
 octave_range::diag (octave_idx_type m, octave_idx_type n) const
 {
   Matrix mat = range.matrix_value ();
 
   return mat.diag (m, n);
@@ -259,17 +260,17 @@ octave_range::diag (octave_idx_type m, o
 
 bool
 octave_range::is_true (void) const
 {
   bool retval = false;
 
   if (range.nelem () != 0)
     {
-      // FIXME -- this is a potential waste of memory.
+      // FIXME: this is a potential waste of memory.
 
       Matrix m ((range.matrix_value () . all ()) . all ());
 
       retval = (m.rows () == 1 && m.columns () == 1 && m (0, 0) != 0.0);
     }
 
   return retval;
 }
@@ -386,17 +387,17 @@ octave_range::print_name_tag (std::ostre
 
   return retval;
 }
 
 std::string
 octave_range::short_disp (void) const
 {
   std::ostringstream buf;
-  
+
   octave_idx_type len = range.nelem ();
 
   if (len == 0)
     buf << "[]";
   else
     {
       buf << range.base () << ":";
 
@@ -674,17 +675,17 @@ octave_range::as_mxArray (void) const
 
   for (mwSize i = 0; i < nel; i++)
     pr[i] = p[i];
 
   return retval;
 }
 
 DEFUN (allow_noninteger_range_as_index, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} allow_noninteger_range_as_index ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} allow_noninteger_range_as_index (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} allow_noninteger_range_as_index (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether non-integer\n\
 ranges are allowed as indices.  This might be useful for @sc{matlab}\n\
 compatibility; however, it is still not entirely compatible because\n\
 @sc{matlab} treats the range expression differently in different contexts.\n\
 \n\
diff --git a/libinterp/octave-value/ov-range.h b/libinterp/octave-value/ov-range.h
--- a/libinterp/octave-value/ov-range.h
+++ b/libinterp/octave-value/ov-range.h
@@ -53,38 +53,38 @@ octave_range : public octave_base_value
 {
 public:
 
   octave_range (void)
     : octave_base_value (), range (), idx_cache () { }
 
   octave_range (double base, double limit, double inc)
     : octave_base_value (), range (base, limit, inc), idx_cache ()
-      {
-        if (range.nelem () < 0)
-          ::error ("invalid range");
-      }
+  {
+    if (range.nelem () < 0)
+      ::error ("invalid range");
+  }
 
   octave_range (const Range& r)
     : octave_base_value (), range (r), idx_cache ()
-      {
-        if (range.nelem () < 0 && range.nelem () != -2)
-          ::error ("invalid range");
-      }
+  {
+    if (range.nelem () < 0 && range.nelem () != -2)
+      ::error ("invalid range");
+  }
 
   octave_range (const octave_range& r)
     : octave_base_value (), range (r.range),
       idx_cache (r.idx_cache ? new idx_vector (*r.idx_cache) : 0)
-    { }
+  { }
 
   octave_range (const Range& r, const idx_vector& cache)
     : octave_base_value (), range (r), idx_cache ()
-      {
-        set_idx_cache (cache);
-      }
+  {
+    set_idx_cache (cache);
+  }
 
   ~octave_range (void) { clear_cached_info (); }
 
   octave_base_value *clone (void) const { return new octave_range (*this); }
 
   // A range is really just a special kind of real matrix object.  In
   // the places where we need to call empty_clone, it makes more sense
   // to create an empty matrix (0x0) instead of an empty range (1x0).
@@ -94,39 +94,39 @@ public:
 
   octave_base_value *try_narrowing_conversion (void);
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx);
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx, int)
-    { return subsref (type, idx); }
+  { return subsref (type, idx); }
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false);
 
   idx_vector index_vector (void) const;
 
   dim_vector dims (void) const
-    {
-      octave_idx_type n = range.nelem ();
-      return dim_vector (n > 0, n);
-    }
+  {
+    octave_idx_type n = range.nelem ();
+    return dim_vector (n > 0, n);
+  }
 
   octave_value resize (const dim_vector& dv, bool fill = false) const;
 
 
   size_t byte_size (void) const { return 3 * sizeof (double); }
 
   octave_value reshape (const dim_vector& new_dims) const
-    { return NDArray (array_value ().reshape (new_dims)); }
+  { return NDArray (array_value ().reshape (new_dims)); }
 
   octave_value permute (const Array<int>& vec, bool inv = false) const
-    { return NDArray (array_value ().permute (vec, inv)); }
+  { return NDArray (array_value ().permute (vec, inv)); }
 
   octave_value squeeze (void) const { return range; }
 
   octave_value full_value (void) const { return range.matrix_value (); }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
@@ -137,30 +137,30 @@ public:
 
   octave_value any (int dim = 0) const;
 
   octave_value diag (octave_idx_type k = 0) const;
 
   octave_value diag (octave_idx_type m, octave_idx_type n) const;
 
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
-    { return range.sort (dim, mode); }
+  { return range.sort (dim, mode); }
 
   octave_value sort (Array<octave_idx_type>& sidx, octave_idx_type dim = 0,
                      sortmode mode = ASCENDING) const
-    { return range.sort (sidx, dim, mode); }
+  { return range.sort (sidx, dim, mode); }
 
   sortmode is_sorted (sortmode mode = UNSORTED) const
-    { return range.is_sorted (mode); }
+  { return range.is_sorted (mode); }
 
   Array<octave_idx_type> sort_rows_idx (sortmode) const
-    { return Array<octave_idx_type> (dim_vector (1, 0)); }
+  { return Array<octave_idx_type> (dim_vector (1, 0)); }
 
   sortmode is_sorted_rows (sortmode mode = UNSORTED) const
-    { return mode ? mode : ASCENDING; }
+  { return mode ? mode : ASCENDING; }
 
   builtin_type_t builtin_type (void) const { return btyp_double; }
 
   bool is_real_type (void) const { return true; }
 
   bool is_double_type (void) const { return true; }
 
   bool is_float_type (void) const { return true; }
@@ -169,36 +169,36 @@ public:
 
   bool is_true (void) const;
 
   double double_value (bool = false) const;
 
   float float_value (bool = false) const;
 
   double scalar_value (bool frc_str_conv = false) const
-    { return double_value (frc_str_conv); }
+  { return double_value (frc_str_conv); }
 
   float float_scalar_value (bool frc_str_conv = false) const
-    { return float_value (frc_str_conv); }
+  { return float_value (frc_str_conv); }
 
   Matrix matrix_value (bool = false) const
-    { return range.matrix_value (); }
+  { return range.matrix_value (); }
 
   FloatMatrix float_matrix_value (bool = false) const
-    { return range.matrix_value (); }
+  { return range.matrix_value (); }
 
   NDArray array_value (bool = false) const
-    { return range.matrix_value (); }
+  { return range.matrix_value (); }
 
   FloatNDArray float_array_value (bool = false) const
-    { return FloatMatrix (range.matrix_value ()); }
+  { return FloatMatrix (range.matrix_value ()); }
 
   charNDArray char_array_value (bool = false) const;
 
-  // FIXME -- it would be better to have Range::intXNDArray_value
+  // FIXME: it would be better to have Range::intXNDArray_value
   // functions to avoid the intermediate conversion to a matrix
   // object.
 
   int8NDArray
   int8_array_value (void) const { return int8NDArray (array_value ()); }
 
   int16NDArray
   int16_array_value (void) const { return int16NDArray (array_value ()); }
@@ -217,38 +217,38 @@ public:
 
   uint32NDArray
   uint32_array_value (void) const { return uint32NDArray (array_value ()); }
 
   uint64NDArray
   uint64_array_value (void) const { return uint64NDArray (array_value ()); }
 
   SparseMatrix sparse_matrix_value (bool = false) const
-    { return SparseMatrix (range.matrix_value ()); }
+  { return SparseMatrix (range.matrix_value ()); }
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const
-    { return SparseComplexMatrix (sparse_matrix_value ()); }
+  { return SparseComplexMatrix (sparse_matrix_value ()); }
 
   Complex complex_value (bool = false) const;
 
   FloatComplex float_complex_value (bool = false) const;
 
   boolNDArray bool_array_value (bool warn = false) const;
 
   ComplexMatrix complex_matrix_value (bool = false) const
-    { return ComplexMatrix (range.matrix_value ()); }
+  { return ComplexMatrix (range.matrix_value ()); }
 
   FloatComplexMatrix float_complex_matrix_value (bool = false) const
-    { return FloatComplexMatrix (range.matrix_value ()); }
+  { return FloatComplexMatrix (range.matrix_value ()); }
 
   ComplexNDArray complex_array_value (bool = false) const
-    { return ComplexMatrix (range.matrix_value ()); }
+  { return ComplexMatrix (range.matrix_value ()); }
 
   FloatComplexNDArray float_complex_array_value (bool = false) const
-    { return FloatComplexMatrix (range.matrix_value ()); }
+  { return FloatComplexMatrix (range.matrix_value ()); }
 
   Range range_value (void) const { return range; }
 
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
@@ -270,47 +270,46 @@ public:
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
-    {
-      // FIXME -- could be more memory efficient by having a
-      // special case of the octave_stream::write method for ranges.
+  {
+    // FIXME: could be more memory efficient by having a
+    // special case of the octave_stream::write method for ranges.
 
-      return os.write (matrix_value (), block_size, output_type, skip,
-                       flt_fmt);
-    }
+    return os.write (matrix_value (), block_size, output_type, skip, flt_fmt);
+  }
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const
-    {
-      octave_matrix m (matrix_value ());
-      return m.map (umap);
-    }
+  {
+    octave_matrix m (matrix_value ());
+    return m.map (umap);
+  }
 
 private:
 
   Range range;
 
   idx_vector set_idx_cache (const idx_vector& idx) const
-    {
-      delete idx_cache;
-      idx_cache = idx ? new idx_vector (idx) : 0;
-      return idx;
-    }
+  {
+    delete idx_cache;
+    idx_cache = idx ? new idx_vector (idx) : 0;
+    return idx;
+  }
 
   void clear_cached_info (void) const
-    {
-      delete idx_cache; idx_cache = 0;
-    }
+  {
+    delete idx_cache; idx_cache = 0;
+  }
 
   mutable idx_vector *idx_cache;
 
   // No assignment.
 
   octave_range& operator = (const octave_range&);
 
   DECLARE_OCTAVE_ALLOCATOR
diff --git a/libinterp/octave-value/ov-re-diag.cc b/libinterp/octave-value/ov-re-diag.cc
--- a/libinterp/octave-value/ov-re-diag.cc
+++ b/libinterp/octave-value/ov-re-diag.cc
@@ -32,17 +32,18 @@ along with Octave; see the file COPYING.
 #include "ov-scalar.h"
 #include "ov-re-mat.h"
 #include "ls-utils.h"
 
 template class octave_base_diag<DiagMatrix, Matrix>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_diag_matrix);
 
-DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_diag_matrix, "diagonal matrix", "double");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_diag_matrix, "diagonal matrix",
+                                     "double");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
   CAST_CONV_ARG (const octave_diag_matrix&);
 
   return new octave_matrix (v.matrix_value ());
 }
@@ -60,18 +61,19 @@ default_numeric_demotion_function (const
   CAST_CONV_ARG (const octave_diag_matrix&);
 
   return new octave_float_diag_matrix (v.float_diag_matrix_value ());
 }
 
 octave_base_value::type_conv_info
 octave_diag_matrix::numeric_demotion_function (void) const
 {
-  return octave_base_value::type_conv_info (default_numeric_demotion_function,
-                                            octave_float_diag_matrix::static_type_id ());
+  return octave_base_value::type_conv_info
+           (default_numeric_demotion_function,
+            octave_float_diag_matrix::static_type_id ());
 }
 
 octave_base_value *
 octave_diag_matrix::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
   if (matrix.nelem () == 1)
@@ -188,17 +190,17 @@ octave_diag_matrix::save_binary (std::os
       if (m.too_large_for_float ())
         {
           warning ("save: some values too large to save as floats --");
           warning ("save: saving as doubles instead");
         }
       else
         st = LS_FLOAT;
     }
-  else if (matrix.length () > 8192) // FIXME -- make this configurable.
+  else if (matrix.length () > 8192) // FIXME: make this configurable.
     {
       double max_val, min_val;
       if (m.all_integers (max_val, min_val))
         st = get_save_type (max_val, min_val);
     }
 
   const double *mtmp = m.data ();
   write_doubles (os, mtmp, st, m.numel ());
diff --git a/libinterp/octave-value/ov-re-diag.h b/libinterp/octave-value/ov-re-diag.h
--- a/libinterp/octave-value/ov-re-diag.h
+++ b/libinterp/octave-value/ov-re-diag.h
@@ -43,18 +43,20 @@ public:
   octave_diag_matrix (const DiagMatrix& m)
     : octave_base_diag<DiagMatrix, Matrix> (m) { }
 
   octave_diag_matrix (const octave_diag_matrix& m)
     : octave_base_diag<DiagMatrix, Matrix> (m) { }
 
   ~octave_diag_matrix (void) { }
 
-  octave_base_value *clone (void) const { return new octave_diag_matrix (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_diag_matrix (); }
+  octave_base_value *clone (void) const
+  { return new octave_diag_matrix (*this); }
+  octave_base_value *empty_clone (void) const
+  { return new octave_diag_matrix (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
   type_conv_info numeric_demotion_function (void) const;
 
   octave_base_value *try_narrowing_conversion (void);
 
   octave_value do_index_op (const octave_value_list& idx,
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -80,18 +80,19 @@ default_numeric_demotion_function (const
   CAST_CONV_ARG (const octave_matrix&);
 
   return new octave_float_matrix (v.float_array_value ());
 }
 
 octave_base_value::type_conv_info
 octave_matrix::numeric_demotion_function (void) const
 {
-  return octave_base_value::type_conv_info (default_numeric_demotion_function,
-                                            octave_float_matrix::static_type_id ());
+  return octave_base_value::type_conv_info
+           (default_numeric_demotion_function,
+            octave_float_matrix::static_type_id ());
 }
 
 octave_base_value *
 octave_matrix::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
   if (matrix.nelem () == 1)
@@ -402,18 +403,17 @@ octave_matrix::convert_to_str_internal (
           return retval;
         }
       else
         {
           int ival = NINT (d);
 
           if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
             {
-              // FIXME -- is there something
-              // better we could do?
+              // FIXME: is there something better we could do?
 
               ival = 0;
 
               if (! warned)
                 {
                   ::warning ("range error for conversion to character value");
                   warned = true;
                 }
@@ -576,32 +576,32 @@ octave_matrix::save_binary (std::ostream
       if (m.too_large_for_float ())
         {
           warning ("save: some values too large to save as floats --");
           warning ("save: saving as doubles instead");
         }
       else
         st = LS_FLOAT;
     }
-  else if (d.numel () > 8192) // FIXME -- make this configurable.
+  else if (d.numel () > 8192) // FIXME: make this configurable.
     {
       double max_val, min_val;
       if (m.all_integers (max_val, min_val))
         st = get_save_type (max_val, min_val);
     }
 
   const double *mtmp = m.data ();
   write_doubles (os, mtmp, st, d.numel ());
 
   return true;
 }
 
 bool
 octave_matrix::load_binary (std::istream& is, bool swap,
-                                 oct_mach_info::float_format fmt)
+                            oct_mach_info::float_format fmt)
 {
   char tmp;
   int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims < 0)
@@ -632,17 +632,18 @@ octave_matrix::load_binary (std::istream
           dv(0) = 1;
         }
 
       if (! is.read (reinterpret_cast<char *> (&tmp), 1))
         return false;
 
       NDArray m(dv);
       double *re = m.fortran_vec ();
-      read_doubles (is, re, static_cast<save_type> (tmp), dv.numel (), swap, fmt);
+      read_doubles (is, re, static_cast<save_type> (tmp), dv.numel (),
+                    swap, fmt);
       if (error_state || ! is)
         return false;
       matrix = m;
     }
   else
     {
       int32_t nr, nc;
       nr = mdims;
@@ -740,17 +741,17 @@ octave_matrix::load_hdf5 (hid_t loc_id, 
 {
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize (dv);
   if (empty)
-      return (empty > 0);
+    return (empty > 0);
 
 #if HAVE_HDF5_18
   hid_t data_hid = H5Dopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t data_hid = H5Dopen (loc_id, name);
 #endif
   hid_t space_id = H5Dget_space (data_hid);
 
@@ -940,17 +941,17 @@ octave_matrix::map (unary_mapper_t umap)
           return error_state ? octave_value () : str_conv.map (umap);
         }
       else
         return octave_base_value::map (umap);
     }
 }
 
 DEFUN (double, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} double (@var{x})\n\
 Convert @var{x} to double precision type.\n\
 @seealso{single}\n\
 @end deftypefn")
 {
   // The OCTAVE_TYPE_CONV_BODY3 macro declares retval, so they go
   // inside their own scopes, and we don't declare retval here to
   // avoid a shadowed declaration warning.
@@ -960,37 +961,42 @@ Convert @var{x} to double precision type
       if (args(0).is_perm_matrix ())
         {
           OCTAVE_TYPE_CONV_BODY3 (double, octave_perm_matrix, octave_scalar);
         }
       else if (args(0).is_diag_matrix ())
         {
           if (args(0).is_complex_type ())
             {
-              OCTAVE_TYPE_CONV_BODY3 (double, octave_complex_diag_matrix, octave_complex);
+              OCTAVE_TYPE_CONV_BODY3 (double, octave_complex_diag_matrix,
+                                      octave_complex);
             }
           else
             {
-              OCTAVE_TYPE_CONV_BODY3 (double, octave_diag_matrix, octave_scalar);
+              OCTAVE_TYPE_CONV_BODY3 (double, octave_diag_matrix,
+                                      octave_scalar);
             }
         }
       else if (args(0).is_sparse_type ())
         {
           if (args(0).is_complex_type ())
             {
-              OCTAVE_TYPE_CONV_BODY3 (double, octave_sparse_complex_matrix, octave_complex);
+              OCTAVE_TYPE_CONV_BODY3 (double, octave_sparse_complex_matrix,
+                                      octave_complex);
             }
           else
             {
-              OCTAVE_TYPE_CONV_BODY3 (double, octave_sparse_matrix, octave_scalar);
+              OCTAVE_TYPE_CONV_BODY3 (double, octave_sparse_matrix,
+                                      octave_scalar);
             }
         }
       else if (args(0).is_complex_type ())
         {
-          OCTAVE_TYPE_CONV_BODY3 (double, octave_complex_matrix, octave_complex);
+          OCTAVE_TYPE_CONV_BODY3 (double, octave_complex_matrix,
+                                  octave_complex);
         }
       else
         {
           OCTAVE_TYPE_CONV_BODY3 (double, octave_matrix, octave_scalar);
         }
     }
   else
     print_usage ();
diff --git a/libinterp/octave-value/ov-re-mat.h b/libinterp/octave-value/ov-re-mat.h
--- a/libinterp/octave-value/ov-re-mat.h
+++ b/libinterp/octave-value/ov-re-mat.h
@@ -78,39 +78,39 @@ public:
     : octave_base_matrix<NDArray> (Matrix (v)) { }
 
   octave_matrix (const octave_matrix& m)
     : octave_base_matrix<NDArray> (m) { }
 
   octave_matrix (const Array<octave_idx_type>& idx,
                  bool zero_based = false, bool cache_index = false)
     : octave_base_matrix<NDArray> (NDArray (idx, zero_based))
-    {
-      // Auto-create cache to speed up subsequent indexing.
-      if (zero_based && cache_index)
-        set_idx_cache (idx_vector (idx));
-    }
+  {
+    // Auto-create cache to speed up subsequent indexing.
+    if (zero_based && cache_index)
+      set_idx_cache (idx_vector (idx));
+  }
 
   octave_matrix (const NDArray& nda, const idx_vector& cache)
     : octave_base_matrix<NDArray> (nda)
-    {
-      set_idx_cache (cache);
-    }
+  {
+    set_idx_cache (cache);
+  }
 
   ~octave_matrix (void) { }
 
   octave_base_value *clone (void) const { return new octave_matrix (*this); }
   octave_base_value *empty_clone (void) const { return new octave_matrix (); }
 
   type_conv_info numeric_demotion_function (void) const;
 
   octave_base_value *try_narrowing_conversion (void);
 
   idx_vector index_vector (void) const
-    { return idx_cache ? *idx_cache : set_idx_cache (idx_vector (matrix)); }
+  { return idx_cache ? *idx_cache : set_idx_cache (idx_vector (matrix)); }
 
   builtin_type_t builtin_type (void) const { return btyp_double; }
 
   bool is_real_matrix (void) const { return true; }
 
   bool is_real_type (void) const { return true; }
 
   bool is_double_type (void) const { return true; }
@@ -141,17 +141,17 @@ public:
   uint64NDArray
   uint64_array_value (void) const { return uint64NDArray (matrix); }
 
   double double_value (bool = false) const;
 
   float float_value (bool = false) const;
 
   double scalar_value (bool frc_str_conv = false) const
-    { return double_value (frc_str_conv); }
+  { return double_value (frc_str_conv); }
 
   Matrix matrix_value (bool = false) const;
 
   FloatMatrix float_matrix_value (bool = false) const;
 
   Complex complex_value (bool = false) const;
 
   FloatComplex float_complex_value (bool = false) const;
@@ -218,17 +218,17 @@ public:
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
-    { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
+  { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return matrix.mex_get_data (); }
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -46,17 +46,18 @@ along with Octave; see the file COPYING.
 #include "ov-base-sparse.cc"
 
 #include "ov-bool-sparse.h"
 
 template class OCTINTERP_API octave_base_sparse<SparseMatrix>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_sparse_matrix);
 
-DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_sparse_matrix, "sparse matrix", "double");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_sparse_matrix, "sparse matrix",
+                                     "double");
 
 idx_vector
 octave_sparse_matrix::index_vector (void) const
 {
   if (matrix.numel () == matrix.nnz ())
     return idx_vector (array_value ());
   else
     {
@@ -113,17 +114,17 @@ octave_sparse_matrix::double_value (bool
 
 Complex
 octave_sparse_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  // FIXME -- maybe this should be a function, valid_as_scalar()
+  // FIXME: maybe this should be a function, valid_as_scalar()
   if (rows () > 0 && columns () > 0)
     {
       if (numel () > 1)
         gripe_implicit_conversion ("Octave:array-to-scalar",
                                    "real sparse matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
@@ -218,42 +219,42 @@ octave_sparse_matrix::convert_to_str_int
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = matrix.cidx (j);
              i < matrix.cidx (j+1); i++)
           {
             octave_quit ();
 
             double d = matrix.data (i);
 
-              if (xisnan (d))
-                {
-                  gripe_nan_to_character_conversion ();
-                  return retval;
-                }
-              else
-                {
-                  int ival = NINT (d);
+            if (xisnan (d))
+              {
+                gripe_nan_to_character_conversion ();
+                return retval;
+              }
+            else
+              {
+                int ival = NINT (d);
 
-                  if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
-                    {
-                      // FIXME -- is there something
-                      // better we could do?
+                if (ival < 0
+                    || ival > std::numeric_limits<unsigned char>::max ())
+                  {
+                    // FIXME: is there something better we could do?
 
-                      ival = 0;
+                    ival = 0;
 
-                      if (! warned)
-                        {
-                          ::warning ("range error for conversion to character value");
-                          warned = true;
-                        }
-                    }
+                    if (! warned)
+                      {
+                        ::warning ("range error for conversion to character value");
+                        warned = true;
+                      }
+                  }
 
-                  chm (matrix.ridx (i) + j * nr) =
-                    static_cast<char> (ival);
-                }
+                chm (matrix.ridx (i) + j * nr) =
+                  static_cast<char> (ival);
+              }
           }
 
       retval = octave_value (chm, type);
     }
 
   return retval;
 }
 
@@ -291,40 +292,40 @@ octave_sparse_matrix::save_binary (std::
       if (matrix.too_large_for_float ())
         {
           warning ("save: some values too large to save as floats --");
           warning ("save: saving as doubles instead");
         }
       else
         st = LS_FLOAT;
     }
-  else if (matrix.nnz () > 8192) // FIXME -- make this configurable.
+  else if (matrix.nnz () > 8192) // FIXME: make this configurable.
     {
       double max_val, min_val;
       if (matrix.all_integers (max_val, min_val))
         st = get_save_type (max_val, min_val);
     }
 
   // add one to the printed indices to go from
   // zero-based to one-based arrays
-   for (int i = 0; i < nc+1; i++)
-     {
-       octave_quit ();
-       itmp = matrix.cidx (i);
-       os.write (reinterpret_cast<char *> (&itmp), 4);
-     }
+  for (int i = 0; i < nc+1; i++)
+    {
+      octave_quit ();
+      itmp = matrix.cidx (i);
+      os.write (reinterpret_cast<char *> (&itmp), 4);
+    }
 
-   for (int i = 0; i < nz; i++)
-     {
-       octave_quit ();
-       itmp = matrix.ridx (i);
-       os.write (reinterpret_cast<char *> (&itmp), 4);
-     }
+  for (int i = 0; i < nz; i++)
+    {
+      octave_quit ();
+      itmp = matrix.ridx (i);
+      os.write (reinterpret_cast<char *> (&itmp), 4);
+    }
 
-   write_doubles (os, matrix.data (), st, nz);
+  write_doubles (os, matrix.data (), st, nz);
 
   return true;
 }
 
 bool
 octave_sparse_matrix::load_binary (std::istream& is, bool swap,
                                    oct_mach_info::float_format fmt)
 {
@@ -332,20 +333,21 @@ octave_sparse_matrix::load_binary (std::
   char ctmp;
 
   if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
 
   if (swap)
     swap_bytes<4> (&tmp);
 
-  if (tmp != -2) {
-    error ("load: only 2-D sparse matrices are supported");
-    return false;
-  }
+  if (tmp != -2)
+    {
+      error ("load: only 2-D sparse matrices are supported");
+      return false;
+    }
 
   if (! is.read (reinterpret_cast<char *> (&nr), 4))
     return false;
   if (! is.read (reinterpret_cast<char *> (&nc), 4))
     return false;
   if (! is.read (reinterpret_cast<char *> (&nz), 4))
     return false;
 
@@ -406,17 +408,18 @@ octave_sparse_matrix::save_hdf5 (hid_t l
   int empty = save_hdf5_empty (loc_id, name, dv);
   if (empty)
     return (empty > 0);
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
 #if HAVE_HDF5_18
-  hid_t group_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+  hid_t group_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT,
+                               H5P_DEFAULT);
 #else
   hid_t group_hid = H5Gcreate (loc_id, name, 0);
 #endif
   if (group_hid < 0)
     return false;
 
   hid_t space_hid = -1, data_hid = -1;
   bool retval = true;
diff --git a/libinterp/octave-value/ov-re-sparse.h b/libinterp/octave-value/ov-re-sparse.h
--- a/libinterp/octave-value/ov-re-sparse.h
+++ b/libinterp/octave-value/ov-re-sparse.h
@@ -80,18 +80,20 @@ public:
   octave_sparse_matrix (const Sparse<double>& m, const MatrixType& t)
     : octave_base_sparse<SparseMatrix> (SparseMatrix (m), t) { }
 
   octave_sparse_matrix (const octave_sparse_matrix& m)
     : octave_base_sparse<SparseMatrix> (m) { }
 
   ~octave_sparse_matrix (void) { }
 
-  octave_base_value *clone (void) const { return new octave_sparse_matrix (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_sparse_matrix (); }
+  octave_base_value *clone (void) const
+  { return new octave_sparse_matrix (*this); }
+  octave_base_value *empty_clone (void) const
+  { return new octave_sparse_matrix (); }
 
   octave_base_value *try_narrowing_conversion (void);
 
   idx_vector index_vector (void) const;
 
   builtin_type_t builtin_type (void) const { return btyp_double; }
 
   bool is_real_matrix (void) const { return true; }
@@ -100,47 +102,47 @@ public:
 
   bool is_double_type (void) const { return true; }
 
   bool is_float_type (void) const { return true; }
 
   double double_value (bool = false) const;
 
   double scalar_value (bool frc_str_conv = false) const
-    { return double_value (frc_str_conv); }
+  { return double_value (frc_str_conv); }
 
   Matrix matrix_value (bool = false) const;
 
   Complex complex_value (bool = false) const;
 
   boolNDArray bool_array_value (bool warn = false) const;
 
   charNDArray char_array_value (bool = false) const;
 
   ComplexMatrix complex_matrix_value (bool = false) const;
 
   ComplexNDArray complex_array_value (bool = false) const;
 
   NDArray array_value (bool = false) const;
 
   SparseMatrix sparse_matrix_value (bool = false) const
-    { return matrix; }
+  { return matrix; }
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const
-    { return SparseComplexMatrix (matrix); }
+  { return SparseComplexMatrix (matrix); }
 
   SparseBoolMatrix sparse_bool_matrix_value (bool warn = false) const;
 
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
 #if 0
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
-    { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
+  { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 #endif
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
diff --git a/libinterp/octave-value/ov-scalar.cc b/libinterp/octave-value/ov-scalar.cc
--- a/libinterp/octave-value/ov-scalar.cc
+++ b/libinterp/octave-value/ov-scalar.cc
@@ -63,30 +63,31 @@ default_numeric_demotion_function (const
   CAST_CONV_ARG (const octave_scalar&);
 
   return new octave_float_scalar (v.float_value ());
 }
 
 octave_base_value::type_conv_info
 octave_scalar::numeric_demotion_function (void) const
 {
-  return octave_base_value::type_conv_info (default_numeric_demotion_function,
-                                            octave_float_scalar::static_type_id ());
+  return octave_base_value::type_conv_info
+           (default_numeric_demotion_function,
+            octave_float_scalar::static_type_id ());
 }
 
 octave_value
 octave_scalar::do_index_op (const octave_value_list& idx, bool resize_ok)
 {
-  // FIXME -- this doesn't solve the problem of
+  // FIXME: this doesn't solve the problem of
   //
   //   a = 1; a([1,1], [1,1], [1,1])
   //
   // and similar constructions.  Hmm...
 
-  // FIXME -- using this constructor avoids narrowing the
+  // FIXME: using this constructor avoids narrowing the
   // 1x1 matrix back to a scalar value.  Need a better solution
   // to this problem.
 
   octave_value tmp (new octave_matrix (matrix_value ()));
 
   return tmp.do_index_op (idx, resize_ok);
 }
 
@@ -127,17 +128,17 @@ octave_scalar::convert_to_str_internal (
   if (xisnan (scalar))
     gripe_nan_to_character_conversion ();
   else
     {
       int ival = NINT (scalar);
 
       if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
         {
-          // FIXME -- is there something better we could do?
+          // FIXME: is there something better we could do?
 
           ival = 0;
 
           ::warning ("range error for conversion to character value");
         }
 
       retval = octave_value (std::string (1, static_cast<char> (ival)), type);
     }
diff --git a/libinterp/octave-value/ov-scalar.h b/libinterp/octave-value/ov-scalar.h
--- a/libinterp/octave-value/ov-scalar.h
+++ b/libinterp/octave-value/ov-scalar.h
@@ -74,59 +74,59 @@ public:
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false);
 
   type_conv_info numeric_demotion_function (void) const;
 
   idx_vector index_vector (void) const { return idx_vector (scalar); }
 
   octave_value any (int = 0) const
-    { return (scalar != 0 && ! lo_ieee_isnan (scalar)); }
+  { return (scalar != 0 && ! lo_ieee_isnan (scalar)); }
 
   builtin_type_t builtin_type (void) const { return btyp_double; }
 
   bool is_real_scalar (void) const { return true; }
 
   bool is_real_type (void) const { return true; }
 
   bool is_double_type (void) const { return true; }
 
   bool is_float_type (void) const { return true; }
 
   int8NDArray
   int8_array_value (void) const
-    { return int8NDArray (dim_vector (1, 1), scalar); }
+  { return int8NDArray (dim_vector (1, 1), scalar); }
 
   int16NDArray
   int16_array_value (void) const
-    { return int16NDArray (dim_vector (1, 1), scalar); }
+  { return int16NDArray (dim_vector (1, 1), scalar); }
 
   int32NDArray
   int32_array_value (void) const
-    { return int32NDArray (dim_vector (1, 1), scalar); }
+  { return int32NDArray (dim_vector (1, 1), scalar); }
 
   int64NDArray
   int64_array_value (void) const
-    { return int64NDArray (dim_vector (1, 1), scalar); }
+  { return int64NDArray (dim_vector (1, 1), scalar); }
 
   uint8NDArray
   uint8_array_value (void) const
-    { return uint8NDArray (dim_vector (1, 1), scalar); }
+  { return uint8NDArray (dim_vector (1, 1), scalar); }
 
   uint16NDArray
   uint16_array_value (void) const
-    { return uint16NDArray (dim_vector (1, 1), scalar); }
+  { return uint16NDArray (dim_vector (1, 1), scalar); }
 
   uint32NDArray
   uint32_array_value (void) const
-    { return uint32NDArray (dim_vector (1, 1), scalar); }
+  { return uint32NDArray (dim_vector (1, 1), scalar); }
 
   uint64NDArray
   uint64_array_value (void) const
-    { return uint64NDArray (dim_vector (1, 1), scalar); }
+  { return uint64NDArray (dim_vector (1, 1), scalar); }
 
 #define DEFINE_INT_SCALAR_VALUE(TYPE) \
   octave_ ## TYPE \
   TYPE ## _scalar_value (void) const \
     { return octave_ ## TYPE (scalar); }
 
   DEFINE_INT_SCALAR_VALUE (int8)
   DEFINE_INT_SCALAR_VALUE (int16)
@@ -136,58 +136,60 @@ public:
   DEFINE_INT_SCALAR_VALUE (uint16)
   DEFINE_INT_SCALAR_VALUE (uint32)
   DEFINE_INT_SCALAR_VALUE (uint64)
 
 #undef DEFINE_INT_SCALAR_VALUE
 
   double double_value (bool = false) const { return scalar; }
 
-  float float_value (bool = false) const { return static_cast<float> (scalar); }
+  float float_value (bool = false) const
+  { return static_cast<float> (scalar); }
 
   double scalar_value (bool = false) const { return scalar; }
 
-  float float_scalar_value (bool = false) const { return static_cast<float> (scalar); }
+  float float_scalar_value (bool = false) const
+  { return static_cast<float> (scalar); }
 
   Matrix matrix_value (bool = false) const
-    { return Matrix (1, 1, scalar); }
+  { return Matrix (1, 1, scalar); }
 
   FloatMatrix float_matrix_value (bool = false) const
-    { return FloatMatrix (1, 1, scalar); }
+  { return FloatMatrix (1, 1, scalar); }
 
   NDArray array_value (bool = false) const
-    { return NDArray (dim_vector (1, 1), scalar); }
+  { return NDArray (dim_vector (1, 1), scalar); }
 
   FloatNDArray float_array_value (bool = false) const
-    { return FloatNDArray (dim_vector (1, 1), scalar); }
+  { return FloatNDArray (dim_vector (1, 1), scalar); }
 
   SparseMatrix sparse_matrix_value (bool = false) const
-    { return SparseMatrix (Matrix (1, 1, scalar)); }
+  { return SparseMatrix (Matrix (1, 1, scalar)); }
 
   // FIXME Need SparseComplexMatrix (Matrix) constructor!!!
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const
-    { return SparseComplexMatrix (sparse_matrix_value ()); }
+  { return SparseComplexMatrix (sparse_matrix_value ()); }
 
   octave_value resize (const dim_vector& dv, bool fill = false) const;
 
   Complex complex_value (bool = false) const { return scalar; }
 
   FloatComplex float_complex_value (bool = false) const { return scalar; }
 
   ComplexMatrix complex_matrix_value (bool = false) const
-    { return  ComplexMatrix (1, 1, Complex (scalar)); }
+  { return  ComplexMatrix (1, 1, Complex (scalar)); }
 
   FloatComplexMatrix float_complex_matrix_value (bool = false) const
-    { return  FloatComplexMatrix (1, 1, FloatComplex (scalar)); }
+  { return  FloatComplexMatrix (1, 1, FloatComplex (scalar)); }
 
   ComplexNDArray complex_array_value (bool = false) const
-    { return ComplexNDArray (dim_vector (1, 1), Complex (scalar)); }
+  { return ComplexNDArray (dim_vector (1, 1), Complex (scalar)); }
 
   FloatComplexNDArray float_complex_array_value (bool = false) const
-    { return FloatComplexNDArray (dim_vector (1, 1), FloatComplex (scalar)); }
+  { return FloatComplexNDArray (dim_vector (1, 1), FloatComplex (scalar)); }
 
   charNDArray
   char_array_value (bool = false) const
   {
     charNDArray retval (dim_vector (1, 1));
     retval(0) = static_cast<char> (scalar);
     return retval;
   }
@@ -233,20 +235,20 @@ public:
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
-    {
-      return os.write (array_value (), block_size, output_type,
-                       skip, flt_fmt);
-    }
+  {
+    return os.write (array_value (), block_size, output_type,
+                     skip, flt_fmt);
+  }
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
   bool fast_elem_insert_self (void *where, builtin_type_t btyp) const;
 
 private:
diff --git a/libinterp/octave-value/ov-str-mat.cc b/libinterp/octave-value/ov-str-mat.cc
--- a/libinterp/octave-value/ov-str-mat.cc
+++ b/libinterp/octave-value/ov-str-mat.cc
@@ -52,17 +52,18 @@ along with Octave; see the file COPYING.
 #include "pr-output.h"
 #include "pt-mat.h"
 #include "utils.h"
 
 DEFINE_OCTAVE_ALLOCATOR (octave_char_matrix_str);
 DEFINE_OCTAVE_ALLOCATOR (octave_char_matrix_sq_str);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_char_matrix_str, "string", "char");
-DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_char_matrix_sq_str, "sq_string", "char");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_char_matrix_sq_str, "sq_string",
+                                     "char");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
   octave_base_value *retval = 0;
 
   CAST_CONV_ARG (const octave_char_matrix_str&);
 
@@ -124,18 +125,19 @@ octave_char_matrix_str::do_index_op_inte
     default:
       {
         Array<idx_vector> idx_vec (dim_vector (len, 1));
 
         for (octave_idx_type i = 0; i < len; i++)
           idx_vec(i) = idx(i).index_vector ();
 
         if (! error_state)
-          retval = octave_value (charNDArray (matrix.index (idx_vec, resize_ok)),
-                                 type);
+          retval =
+            octave_value (charNDArray (matrix.index (idx_vec, resize_ok)),
+                          type);
       }
       break;
     }
 
   return retval;
 }
 
 octave_value
@@ -256,17 +258,18 @@ octave_char_matrix_str::cellstr_value (v
     }
   else
     error ("cellstr: cannot convert multidimensional arrays");
 
   return retval;
 }
 
 void
-octave_char_matrix_str::print_raw (std::ostream& os, bool pr_as_read_syntax) const
+octave_char_matrix_str::print_raw (std::ostream& os,
+                                   bool pr_as_read_syntax) const
 {
   octave_print_internal (os, matrix, pr_as_read_syntax,
                          current_print_indent_level (), true);
 }
 
 bool
 octave_char_matrix_str::save_ascii (std::ostream& os)
 {
@@ -366,18 +369,17 @@ octave_char_matrix_str::load_ascii (std:
             }
         }
       else if (kw == "elements")
         {
           int elements = val;
 
           if (elements >= 0)
             {
-              // FIXME -- need to be able to get max length
-              // before doing anything.
+              // FIXME: need to be able to get max length before doing anything.
 
               charMatrix chm (elements, 0);
               int max_len = 0;
               for (int i = 0; i < elements; i++)
                 {
                   int len;
                   if (extract_keyword (is, "length", len) && len >= 0)
                     {
@@ -689,17 +691,18 @@ octave_char_matrix_str::load_hdf5 (hid_t
             }
           else
             {
               OCTAVE_LOCAL_BUFFER (char, s, slen);
               // create datatype for (null-terminated) string
               // to read into:
               hid_t st_id = H5Tcopy (H5T_C_S1);
               H5Tset_size (st_id, slen+1);
-              if (H5Dread (data_hid, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT, s) < 0)
+              if (H5Dread (data_hid, st_id, H5S_ALL,
+                           H5S_ALL, H5P_DEFAULT, s) < 0)
                 {
                   H5Tclose (st_id);
                   H5Tclose (type_hid);
                   H5Sclose (space_hid);
                   H5Dclose (data_hid);
                   return false;
                 }
 
@@ -733,17 +736,18 @@ octave_char_matrix_str::load_hdf5 (hid_t
 
               OCTAVE_LOCAL_BUFFER (char, s, elements * (slen+1));
 
               // create datatype for (null-terminated) string
               // to read into:
               hid_t st_id = H5Tcopy (H5T_C_S1);
               H5Tset_size (st_id, slen+1);
 
-              if (H5Dread (data_hid, st_id, H5S_ALL, H5S_ALL, H5P_DEFAULT, s) < 0)
+              if (H5Dread (data_hid, st_id, H5S_ALL,
+                           H5S_ALL, H5P_DEFAULT, s) < 0)
                 {
                   H5Tclose (st_id);
                   H5Tclose (type_hid);
                   H5Sclose (space_hid);
                   H5Dclose (data_hid);
                   return false;
                 }
 
diff --git a/libinterp/octave-value/ov-str-mat.h b/libinterp/octave-value/ov-str-mat.h
--- a/libinterp/octave-value/ov-str-mat.h
+++ b/libinterp/octave-value/ov-str-mat.h
@@ -79,38 +79,40 @@ public:
   octave_char_matrix_str (const octave_char_matrix& chm)
     : octave_char_matrix (chm) { }
 
   octave_char_matrix_str (const octave_char_matrix_str& chms)
     : octave_char_matrix (chms) { }
 
   ~octave_char_matrix_str (void) { }
 
-  octave_base_value *clone (void) const { return new octave_char_matrix_str (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_char_matrix_str (); }
+  octave_base_value *clone (void) const
+  { return new octave_char_matrix_str (*this); }
+  octave_base_value *empty_clone (void) const
+  { return new octave_char_matrix_str (); }
 
   type_conv_info numeric_conversion_function (void) const;
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false)
-    { return do_index_op_internal (idx, resize_ok); }
+  { return do_index_op_internal (idx, resize_ok); }
 
   octave_value squeeze (void) const
-    { return octave_value (charNDArray (matrix.squeeze ())); }
+  { return octave_value (charNDArray (matrix.squeeze ())); }
 
   octave_value reshape (const dim_vector& new_dims) const
-    { return octave_value (charNDArray (matrix.reshape (new_dims))); }
+  { return octave_value (charNDArray (matrix.reshape (new_dims))); }
 
   octave_value permute (const Array<int>& vec, bool inv = false) const
-    { return octave_value (charNDArray (matrix.permute (vec, inv))); }
+  { return octave_value (charNDArray (matrix.permute (vec, inv))); }
 
   octave_value resize (const dim_vector& dv, bool fill = false) const;
 
   octave_value diag (octave_idx_type k = 0) const
-    { return octave_value (matrix.diag (k)); }
+  { return octave_value (matrix.diag (k)); }
 
   bool is_string (void) const { return true; }
 
   bool is_numeric_type (void) const { return false; }
 
   double double_value (bool = false) const;
 
   Matrix matrix_value (bool = false) const;
@@ -125,21 +127,21 @@ public:
 
   string_vector all_strings (bool pad = false) const;
 
   std::string string_value (bool force = false) const;
 
   Array<std::string> cellstr_value (void) const;
 
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
-    { return octave_value (matrix.sort (dim, mode)); }
+  { return octave_value (matrix.sort (dim, mode)); }
 
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
                      sortmode mode = ASCENDING) const
-    { return octave_value (matrix.sort (sidx, dim, mode)); }
+  { return octave_value (matrix.sort (sidx, dim, mode)); }
 
   bool print_as_scalar (void) const { return (rows () <= 1); }
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
@@ -153,17 +155,17 @@ public:
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              oct_mach_info::float_format flt_fmt) const
-    { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
+  { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
 protected:
 
   octave_value do_index_op_internal (const octave_value_list& idx,
                                      bool resize_ok, char type = '"');
 
 private:
 
@@ -206,51 +208,53 @@ public:
   octave_char_matrix_sq_str (const octave_char_matrix_str& chm)
     : octave_char_matrix_str (chm) { }
 
   octave_char_matrix_sq_str (const octave_char_matrix_sq_str& chms)
     : octave_char_matrix_str (chms) { }
 
   ~octave_char_matrix_sq_str (void) { }
 
-  octave_base_value *clone (void) const { return new octave_char_matrix_sq_str (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_char_matrix_sq_str (); }
+  octave_base_value *clone (void) const
+  { return new octave_char_matrix_sq_str (*this); }
+  octave_base_value *empty_clone (void) const
+  { return new octave_char_matrix_sq_str (); }
 
   octave_value squeeze (void) const
-    { return octave_value (charNDArray (matrix.squeeze ()), '\''); }
+  { return octave_value (charNDArray (matrix.squeeze ()), '\''); }
 
   octave_value reshape (const dim_vector& new_dims) const
-    { return octave_value (charNDArray (matrix.reshape (new_dims)), '\''); }
+  { return octave_value (charNDArray (matrix.reshape (new_dims)), '\''); }
 
   octave_value permute (const Array<int>& vec, bool inv = false) const
-    { return octave_value (charNDArray (matrix.permute (vec, inv)), '\''); }
+  { return octave_value (charNDArray (matrix.permute (vec, inv)), '\''); }
 
   octave_value resize (const dim_vector& dv, bool = false) const
-    {
-      charNDArray retval (matrix);
-      retval.resize (dv);
-      return octave_value (retval, '\'');
-    }
+  {
+    charNDArray retval (matrix);
+    retval.resize (dv);
+    return octave_value (retval, '\'');
+  }
 
   octave_value diag (octave_idx_type k = 0) const
-    { return octave_value (matrix.diag (k), '\''); }
+  { return octave_value (matrix.diag (k), '\''); }
 
   bool is_sq_string (void) const { return true; }
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false)
-    { return do_index_op_internal (idx, resize_ok, '\''); }
+  { return do_index_op_internal (idx, resize_ok, '\''); }
 
 
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
-    { return octave_value (matrix.sort (dim, mode), '\''); }
+  { return octave_value (matrix.sort (dim, mode), '\''); }
 
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
                      sortmode mode = ASCENDING) const
-    { return octave_value (matrix.sort (sidx, dim, mode), '\''); }
+  { return octave_value (matrix.sort (sidx, dim, mode), '\''); }
 
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -80,17 +80,17 @@ octave_struct::dotref (const octave_valu
 
   octave_map::const_iterator p = map.seek (nm);
 
   if (p != map.end ())
     retval = map.contents (p);
   else if (auto_add)
     retval = (numel () == 0) ? Cell (dim_vector (1, 1)) : Cell (dims ());
   else
-    error_with_id ("Octave:invalid-indexing", 
+    error_with_id ("Octave:invalid-indexing",
                    "structure has no member '%s'", nm.c_str ());
 
   return retval;
 }
 
 #if 0
 static void
 gripe_invalid_index1 (void)
@@ -184,17 +184,17 @@ octave_struct::subsref (const std::strin
     case '{':
       gripe_invalid_index_type (type_name (), type[0]);
       break;
 
     default:
       panic_impossible ();
     }
 
-  // FIXME -- perhaps there should be an
+  // FIXME: perhaps there should be an
   // octave_value_list::next_subsref member function?  See also
   // octave_user_function::subsref.
 
   if (idx.size () > 1)
     retval = retval(0).next_subsref (nargout, type, idx, skip);
 
   return retval;
 }
@@ -250,17 +250,17 @@ octave_struct::subsref (const std::strin
     case '{':
       gripe_invalid_index_type (type_name (), type[0]);
       break;
 
     default:
       panic_impossible ();
     }
 
-  // FIXME -- perhaps there should be an
+  // FIXME: perhaps there should be an
   // octave_value_list::next_subsref member function?  See also
   // octave_user_function::subsref.
 
   if (idx.size () > 1)
     retval = retval.next_subsref (auto_add, type, idx, skip);
 
   return retval;
 }
@@ -340,38 +340,41 @@ octave_struct::subsasgn (const std::stri
                 Cell tmpc (1, 1);
                 octave_map::iterator pkey = map.seek (key);
                 if (pkey != map.end ())
                   {
                     map.contents (pkey).make_unique ();
                     tmpc = map.contents (pkey).index (idx.front (), true);
                   }
 
-                // FIXME: better code reuse? cf. octave_cell::subsasgn and the case below.
+                // FIXME: better code reuse?
+                //        cf. octave_cell::subsasgn and the case below.
                 if (! error_state)
                   {
                     if (tmpc.numel () == 1)
                       {
                         octave_value& tmp = tmpc(0);
 
                         bool orig_undefined = tmp.is_undefined ();
 
                         if (orig_undefined || tmp.is_zero_by_zero ())
                           {
                             tmp = octave_value::empty_conv (next_type, rhs);
                             tmp.make_unique (); // probably a no-op.
                           }
                         else
-                          // optimization: ignore the copy still stored inside our map.
+                          // optimization: ignore the copy
+                          // still stored inside our map.
                           tmp.make_unique (1);
 
                         if (! error_state)
-                          t_rhs = (orig_undefined
-                                   ? tmp.undef_subsasgn (next_type, next_idx, rhs)
-                                   : tmp.subsasgn (next_type, next_idx, rhs));
+                          t_rhs =
+                            (orig_undefined
+                               ? tmp.undef_subsasgn (next_type, next_idx, rhs)
+                               : tmp.subsasgn (next_type, next_idx, rhs));
                       }
                     else
                       gripe_indexed_cs_list ();
                   }
               }
             else
               gripe_invalid_index_for_assignment ();
           }
@@ -414,17 +417,18 @@ octave_struct::subsasgn (const std::stri
                     bool orig_undefined = tmp.is_undefined ();
 
                     if (orig_undefined || tmp.is_zero_by_zero ())
                       {
                         tmp = octave_value::empty_conv (next_type, rhs);
                         tmp.make_unique (); // probably a no-op.
                       }
                     else
-                      // optimization: ignore the copy still stored inside our map.
+                      // optimization: ignore the copy
+                      // still stored inside our map.
                       tmp.make_unique (1);
 
                     if (! error_state)
                       t_rhs = (orig_undefined
                                ? tmp.undef_subsasgn (next_type, next_idx, rhs)
                                : tmp.subsasgn (next_type, next_idx, rhs));
                   }
                 else
@@ -468,17 +472,18 @@ octave_struct::subsasgn (const std::stri
                     if (t_rhs.is_cs_list ())
                       {
                         Cell tmp_cell = Cell (t_rhs.list_value ());
 
                         // Inquire the proper shape of the RHS.
 
                         dim_vector didx = dims ().redim (idxf.length ());
                         for (octave_idx_type k = 0; k < idxf.length (); k++)
-                          if (! idxf(k).is_magic_colon ()) didx(k) = idxf(k).numel ();
+                          if (! idxf(k).is_magic_colon ())
+                            didx(k) = idxf(k).numel ();
 
                         if (didx.numel () == tmp_cell.numel ())
                           tmp_cell = tmp_cell.reshape (didx);
 
 
                         map.assign (idxf, key, tmp_cell);
 
                         if (! error_state)
@@ -486,22 +491,25 @@ octave_struct::subsasgn (const std::stri
                             count++;
                             retval = octave_value (this);
                           }
                         else
                           gripe_failed_assignment ();
                       }
                     else
                       {
-                        const octave_map& cmap = const_cast<const octave_map &> (map);
-                        // cast map to const reference to avoid forced key insertion.
+                        const octave_map& cmap =
+                          const_cast<const octave_map &> (map);
+                        // cast to const reference, avoid forced key insertion.
                         if (idxf.all_scalars ()
-                            || cmap.contents (key).index (idxf, true).numel () == 1)
+                            || cmap.contents (key).index (idxf, true).numel ()
+                               == 1)
                           {
-                            map.assign (idxf, key, Cell (t_rhs.storable_value ()));
+                            map.assign (idxf,
+                                        key, Cell (t_rhs.storable_value ()));
                             if (! error_state)
                               {
                                 count++;
                                 retval = octave_value (this);
                               }
                             else
                               gripe_failed_assignment ();
                           }
@@ -836,20 +844,21 @@ octave_struct::load_ascii (std::istream&
               success = false;
             }
         }
       else if (len == 0 )
         map = octave_map (dv);
       else
         panic_impossible ();
     }
-  else {
-    error ("load: failed to extract number of elements in structure");
-    success = false;
-  }
+  else
+    {
+      error ("load: failed to extract number of elements in structure");
+      success = false;
+    }
 
   return success;
 }
 
 bool
 octave_struct::save_binary (std::ostream& os, bool& save_as_floats)
 {
   octave_map m = map_value ();
@@ -1026,17 +1035,17 @@ octave_struct::load_hdf5 (hid_t loc_id, 
 #if HAVE_HDF5_18
   hid_t group_id = H5Gopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t group_id = H5Gopen (loc_id, name);
 #endif
   H5Gget_num_objs (group_id, &num_obj);
   H5Gclose (group_id);
 
-  // FIXME -- fields appear to be sorted alphabetically on loading.
+  // FIXME: fields appear to be sorted alphabetically on loading.
   // Why is that happening?
 
   while (current_item < static_cast<int> (num_obj)
          && (retval2 = H5Giterate (loc_id, name, &current_item,
                                    hdf5_read_next_data, &dsub)) > 0)
     {
       octave_value t2 = dsub.tc;
 
@@ -1120,17 +1129,18 @@ octave_struct::fast_elem_insert (octave_
       return (x.get_rep ().fast_elem_insert_self (here, btyp_struct)
               && map.fast_elem_insert (n, *sm_ptr));
     }
 
   return retval;
 }
 DEFINE_OCTAVE_ALLOCATOR(octave_scalar_struct);
 
-DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA(octave_scalar_struct, "scalar struct", "struct");
+DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA(octave_scalar_struct, "scalar struct",
+                                    "struct");
 
 octave_value
 octave_scalar_struct::dotref (const octave_value_list& idx, bool auto_add)
 {
   octave_value retval;
 
   assert (idx.length () == 1);
 
@@ -1407,17 +1417,18 @@ octave_scalar_struct::print_raw (std::os
     {
       indent (os);
       os << "<structure>";
       newline (os);
     }
 }
 
 bool
-octave_scalar_struct::print_name_tag (std::ostream& os, const std::string& name) const
+octave_scalar_struct::print_name_tag (std::ostream& os,
+                                      const std::string& name) const
 {
   bool retval = false;
 
   indent (os);
 
   if (Vstruct_levels_to_print < 0)
     os << name << " = ";
   else
@@ -1507,20 +1518,21 @@ octave_scalar_struct::load_ascii (std::i
               success = false;
             }
         }
       else if (len == 0)
         map = octave_scalar_map ();
       else
         panic_impossible ();
     }
-  else {
-    error ("load: failed to extract number of elements in structure");
-    success = false;
-  }
+  else
+    {
+      error ("load: failed to extract number of elements in structure");
+      success = false;
+    }
 
   return success;
 }
 
 bool
 octave_scalar_struct::save_binary (std::ostream& os, bool& save_as_floats)
 {
   octave_map m = map_value ();
@@ -1602,17 +1614,18 @@ octave_scalar_struct::load_binary (std::
     success = false;
 
   return success;
 }
 
 #if defined (HAVE_HDF5)
 
 bool
-octave_scalar_struct::save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats)
+octave_scalar_struct::save_hdf5 (hid_t loc_id, const char *name,
+                                 bool save_as_floats)
 {
   hid_t data_hid = -1;
 
 #if HAVE_HDF5_18
   data_hid = H5Gcreate (loc_id, name, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
 #else
   data_hid = H5Gcreate (loc_id, name, 0);
 #endif
@@ -1659,17 +1672,17 @@ octave_scalar_struct::load_hdf5 (hid_t l
 #if HAVE_HDF5_18
   hid_t group_id = H5Gopen (loc_id, name, H5P_DEFAULT);
 #else
   hid_t group_id = H5Gopen (loc_id, name);
 #endif
   H5Gget_num_objs (group_id, &num_obj);
   H5Gclose (group_id);
 
-  // FIXME -- fields appear to be sorted alphabetically on loading.
+  // FIXME: fields appear to be sorted alphabetically on loading.
   // Why is that happening?
 
   while (current_item < static_cast<int> (num_obj)
          && (retval2 = H5Giterate (loc_id, name, &current_item,
                                    hdf5_read_next_data, &dsub)) > 0)
     {
       octave_value t2 = dsub.tc;
 
@@ -1730,30 +1743,31 @@ octave_scalar_struct::as_mxArray (void) 
 
 octave_value
 octave_scalar_struct::to_array (void)
 {
   return new octave_struct (octave_map (map));
 }
 
 bool
-octave_scalar_struct::fast_elem_insert_self (void *where, builtin_type_t btyp) const
+octave_scalar_struct::fast_elem_insert_self (void *where,
+                                             builtin_type_t btyp) const
 {
 
   if (btyp == btyp_struct)
     {
       *(reinterpret_cast<const octave_scalar_map **>(where)) = &map;
       return true;
     }
   else
     return false;
 }
 
 DEFUN (struct, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} struct (@var{field1}, @var{value1}, @var{field2}, @var{value2}, @dots{})\n\
 \n\
 Create a scalar or array structure and initialize its values.  The\n\
 @var{field1}, @var{field2}, @dots{} variables are strings giving the\n\
 names of the fields and the @var{value1}, @var{value2}, @dots{}\n\
 variables can be any type.\n\
 \n\
 If the values are cell arrays, create a structure array and initialize\n\
@@ -1942,34 +1956,34 @@ produces a struct @strong{array}.\n\
 %!assert (isstruct (x))
 %!assert (isempty (fieldnames (x)))
 %!fail ('struct ("a",{1,2},"b",{1,2,3})', 'dimensions of parameter 2 do not match those of parameter 4')
 %!fail ('struct (1,2,3,4)', 'struct: expecting alternating "field", VALUE pairs')
 %!fail ('struct ("1",2,"3")', 'struct: expecting alternating "field", VALUE pairs')
 */
 
 DEFUN (isstruct, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isstruct (@var{x})\n\
 Return true if @var{x} is a structure or a structure array.\n\
 @seealso{ismatrix, iscell, isa}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).is_map ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (__fieldnames__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} __fieldnames__ (@var{struct})\n\
 @deftypefnx {Built-in Function} {} __fieldnames__ (@var{obj})\n\
 Internal function.\n\
 \n\
 Implements @code{fieldnames()} for structures and Octave objects.\n\
 @seealso{fieldnames}\n\
 @end deftypefn")
 {
@@ -1986,17 +2000,17 @@ Implements @code{fieldnames()} for struc
     retval = Cell (0, 1);
   else
     retval = Cell (keys);
 
   return retval;
 }
 
 DEFUN (isfield, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isfield (@var{x}, @var{name})\n\
 Return true if the @var{x} is a structure and it\n\
 includes an element named @var{name}.  If @var{name} is a cell\n\
 array of strings then a logical array of equal dimension is returned.\n\
 @end deftypefn")
 {
   octave_value retval;
 
@@ -2005,17 +2019,17 @@ array of strings then a logical array of
   if (nargin == 2)
     {
       retval = false;
 
       if (args(0).is_map ())
         {
           octave_map m = args(0).map_value ();
 
-          // FIXME -- should this work for all types that can do
+          // FIXME: should this work for all types that can do
           // structure reference operations?
 
           if (args(1).is_string ())
             {
               std::string key = args(1).string_value ();
 
               retval = m.isfield (key);
             }
@@ -2043,17 +2057,17 @@ array of strings then a logical array of
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (nfields, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} nfields (@var{s})\n\
 Return the number of fields of the structure @var{s}.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -2273,34 +2287,34 @@ each of the named fields.\n\
 %! assert (size (y), [1, 6]);
 %!test
 %! y = rmfield (x, {"a", "f"});
 %! assert (fieldnames (y), {"d"; "b"; "c"});
 %! assert (size (y), [1, 6]);
 */
 
 DEFUN (struct_levels_to_print, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} struct_levels_to_print ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} struct_levels_to_print (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} struct_levels_to_print (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the number of\n\
 structure levels to display.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.  \n\
 The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE_WITH_LIMITS (struct_levels_to_print, -1,
                                             std::numeric_limits<int>::max ());
 }
 
 DEFUN (print_struct_array_contents, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} print_struct_array_contents ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} print_struct_array_contents (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} print_struct_array_contents (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies whether to print struct\n\
 array contents.  If true, values of struct array elements are printed.\n\
 This variable does not affect scalar structures.  Their elements\n\
 are always printed.  In both cases, however, printing will be limited to\n\
 the number of levels specified by @var{struct_levels_to_print}.\n\
diff --git a/libinterp/octave-value/ov-struct.h b/libinterp/octave-value/ov-struct.h
--- a/libinterp/octave-value/ov-struct.h
+++ b/libinterp/octave-value/ov-struct.h
@@ -63,20 +63,20 @@ public:
   octave_base_value *empty_clone (void) const { return new octave_struct (); }
 
   octave_base_value *try_narrowing_conversion (void);
 
   Cell dotref (const octave_value_list& idx, bool auto_add = false);
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx)
-    {
-      octave_value_list tmp = subsref (type, idx, 1);
-      return tmp.length () > 0 ? tmp(0) : octave_value ();
-    }
+  {
+    octave_value_list tmp = subsref (type, idx, 1);
+    return tmp.length () > 0 ? tmp(0) : octave_value ();
+  }
 
   octave_value_list subsref (const std::string&,
                              const std::list<octave_value_list>&, int);
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx,
                         bool auto_add);
 
@@ -85,17 +85,17 @@ public:
 
   octave_value subsasgn (const std::string& type,
                          const std::list<octave_value_list>& idx,
                          const octave_value& rhs);
 
   octave_value squeeze (void) const { return map.squeeze (); }
 
   octave_value permute (const Array<int>& vec, bool inv = false) const
-    { return map.permute (vec, inv); }
+  { return map.permute (vec, inv); }
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false);
 
   dim_vector dims (void) const { return map.dims (); }
 
   size_t byte_size (void) const;
 
@@ -104,20 +104,20 @@ public:
   octave_idx_type numel (void) const
   {
     return map.numel ();
   }
 
   octave_idx_type nfields (void) const { return map.nfields (); }
 
   octave_value reshape (const dim_vector& new_dims) const
-    { return map.reshape (new_dims); }
+  { return map.reshape (new_dims); }
 
   octave_value resize (const dim_vector& dv, bool fill = false) const
-    { octave_map tmap = map; tmap.resize (dv, fill); return tmap; }
+  { octave_map tmap = map; tmap.resize (dv, fill); return tmap; }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
 
   bool is_map (void) const { return true; }
 
   builtin_type_t builtin_type (void) const { return btyp_struct; }
@@ -178,18 +178,20 @@ public:
   octave_scalar_struct (const octave_scalar_map& m)
     : octave_base_value (), map (m) { }
 
   octave_scalar_struct (const octave_scalar_struct& s)
     : octave_base_value (), map (s.map) { }
 
   ~octave_scalar_struct (void) { }
 
-  octave_base_value *clone (void) const { return new octave_scalar_struct (*this); }
-  octave_base_value *empty_clone (void) const { return new octave_scalar_struct (); }
+  octave_base_value *clone (void) const
+  { return new octave_scalar_struct (*this); }
+  octave_base_value *empty_clone (void) const
+  { return new octave_scalar_struct (); }
 
   octave_value dotref (const octave_value_list& idx, bool auto_add = false);
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx);
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx, int);
@@ -204,17 +206,17 @@ public:
 
   octave_value subsasgn (const std::string& type,
                          const std::list<octave_value_list>& idx,
                          const octave_value& rhs);
 
   octave_value squeeze (void) const { return map; }
 
   octave_value permute (const Array<int>& vec, bool inv = false) const
-    { return octave_map (map).permute (vec, inv); }
+  { return octave_map (map).permute (vec, inv); }
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false);
 
   dim_vector dims (void) const { static dim_vector dv (1, 1); return dv; }
 
   size_t byte_size (void) const;
 
@@ -223,20 +225,20 @@ public:
   octave_idx_type numel (void) const
   {
     return 1;
   }
 
   octave_idx_type nfields (void) const { return map.nfields (); }
 
   octave_value reshape (const dim_vector& new_dims) const
-    { return octave_map (map).reshape (new_dims); }
+  { return octave_map (map).reshape (new_dims); }
 
   octave_value resize (const dim_vector& dv, bool fill = false) const
-    { octave_map tmap = map; tmap.resize (dv, fill); return tmap; }
+  { octave_map tmap = map; tmap.resize (dv, fill); return tmap; }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
 
   bool is_map (void) const { return true; }
 
   builtin_type_t builtin_type (void) const { return btyp_struct; }
diff --git a/libinterp/octave-value/ov-type-conv.h b/libinterp/octave-value/ov-type-conv.h
--- a/libinterp/octave-value/ov-type-conv.h
+++ b/libinterp/octave-value/ov-type-conv.h
@@ -20,17 +20,18 @@ along with Octave; see the file COPYING.
 
 */
 
 #if !defined (octave_ov_type_conv_h)
 #define octave_ov_type_conv_h 1
 
 static
 octave_value
-octave_type_conv_body (const octave_value &arg, const std::string& name, int t_result)
+octave_type_conv_body (const octave_value &arg, const std::string& name,
+                       int t_result)
 {
   int t_arg = arg.type_id ();
   octave_value retval;
 
   if (t_arg == t_result || arg.class_name () == name)
     {
       retval = arg;
     }
diff --git a/libinterp/octave-value/ov-typeinfo.cc b/libinterp/octave-value/ov-typeinfo.cc
--- a/libinterp/octave-value/ov-typeinfo.cc
+++ b/libinterp/octave-value/ov-typeinfo.cc
@@ -61,127 +61,130 @@ octave_value_typeinfo::instance_ok (void
 }
 
 int
 octave_value_typeinfo::register_type (const std::string& t_name,
                                       const std::string& c_name,
                                       const octave_value& val)
 {
   return (instance_ok ())
-    ? instance->do_register_type (t_name, c_name, val) : -1;
+         ? instance->do_register_type (t_name, c_name, val) : -1;
 }
 
 bool
 octave_value_typeinfo::register_unary_class_op (octave_value::unary_op op,
                                                 octave_value_typeinfo::unary_class_op_fcn f)
 {
   return (instance_ok ())
-    ? instance->do_register_unary_class_op (op, f) : false;
+         ? instance->do_register_unary_class_op (op, f) : false;
 }
 
 bool
 octave_value_typeinfo::register_unary_op (octave_value::unary_op op,
-                                           int t, octave_value_typeinfo::unary_op_fcn f)
+                                          int t,
+                                          octave_value_typeinfo::unary_op_fcn f)
 {
   return (instance_ok ())
-    ? instance->do_register_unary_op (op, t, f) : false;
+         ? instance->do_register_unary_op (op, t, f) : false;
 }
 
 bool
 octave_value_typeinfo::register_non_const_unary_op (octave_value::unary_op op,
                                                     int t,
                                                     octave_value_typeinfo::non_const_unary_op_fcn f)
 {
   return (instance_ok ())
-    ? instance->do_register_non_const_unary_op (op, t, f) : false;
+         ? instance->do_register_non_const_unary_op (op, t, f) : false;
 }
 
 bool
 octave_value_typeinfo::register_binary_class_op (octave_value::binary_op op,
                                                  octave_value_typeinfo::binary_class_op_fcn f)
 {
   return (instance_ok ())
-    ? instance->do_register_binary_class_op (op, f) : false;
+         ? instance->do_register_binary_class_op (op, f) : false;
 }
 
 bool
 octave_value_typeinfo::register_binary_op (octave_value::binary_op op,
                                            int t1, int t2,
                                            octave_value_typeinfo::binary_op_fcn f)
 {
   return (instance_ok ())
-    ? instance->do_register_binary_op (op, t1, t2, f) : false;
+         ? instance->do_register_binary_op (op, t1, t2, f) : false;
 }
 
 bool
 octave_value_typeinfo::register_binary_class_op (octave_value::compound_binary_op op,
                                                  octave_value_typeinfo::binary_class_op_fcn f)
 {
   return (instance_ok ())
-    ? instance->do_register_binary_class_op (op, f) : false;
+         ? instance->do_register_binary_class_op (op, f) : false;
 }
 
 bool
 octave_value_typeinfo::register_binary_op (octave_value::compound_binary_op op,
                                            int t1, int t2,
                                            octave_value_typeinfo::binary_op_fcn f)
 {
   return (instance_ok ())
-    ? instance->do_register_binary_op (op, t1, t2, f) : false;
+         ? instance->do_register_binary_op (op, t1, t2, f) : false;
 }
 
 bool
-octave_value_typeinfo::register_cat_op (int t1, int t2, octave_value_typeinfo::cat_op_fcn f)
+octave_value_typeinfo::register_cat_op (int t1, int t2,
+                                        octave_value_typeinfo::cat_op_fcn f)
 {
   return (instance_ok ())
-    ? instance->do_register_cat_op (t1, t2, f) : false;
+         ? instance->do_register_cat_op (t1, t2, f) : false;
 }
 
 bool
 octave_value_typeinfo::register_assign_op (octave_value::assign_op op,
                                            int t_lhs, int t_rhs,
                                            octave_value_typeinfo::assign_op_fcn f)
 {
   return (instance_ok ())
-    ? instance->do_register_assign_op (op, t_lhs, t_rhs, f) : -1;
+         ? instance->do_register_assign_op (op, t_lhs, t_rhs, f) : -1;
 }
 
 bool
 octave_value_typeinfo::register_assignany_op (octave_value::assign_op op,
                                               int t_lhs, octave_value_typeinfo::assignany_op_fcn f)
 {
   return (instance_ok ())
-    ? instance->do_register_assignany_op (op, t_lhs, f) : -1;
+         ? instance->do_register_assignany_op (op, t_lhs, f) : -1;
 }
 
 bool
 octave_value_typeinfo::register_pref_assign_conv (int t_lhs, int t_rhs,
                                                   int t_result)
 {
   return (instance_ok ())
-    ? instance->do_register_pref_assign_conv (t_lhs, t_rhs, t_result) : false;
+         ? instance->do_register_pref_assign_conv (t_lhs, t_rhs, t_result)
+         : false;
 }
 
 bool
 octave_value_typeinfo::register_type_conv_op (int t, int t_result,
                                               octave_base_value::type_conv_fcn f)
 {
   return (instance_ok ())
-    ? instance->do_register_type_conv_op (t, t_result, f) : false;
+         ? instance->do_register_type_conv_op (t, t_result, f) : false;
 }
 
 bool
 octave_value_typeinfo::register_widening_op (int t, int t_result,
                                              octave_base_value::type_conv_fcn f)
 {
   return (instance_ok ())
-    ? instance->do_register_widening_op (t, t_result, f) : false;
+         ? instance->do_register_widening_op (t, t_result, f) : false;
 }
 
-// FIXME -- we should also store all class names and provide a
+// FIXME: we should also store all class names and provide a
 // way to list them (calling class with nargin == 0?).
 
 int
 octave_value_typeinfo::do_register_type (const std::string& t_name,
                                          const std::string& /* c_name */,
                                          const octave_value& val)
 {
   int i = 0;
@@ -242,24 +245,26 @@ octave_value_typeinfo::do_register_unary
   if (lookup_unary_class_op (op))
     {
       std::string op_name = octave_value::unary_op_as_string (op);
 
       warning ("duplicate unary operator '%s' for class dispatch",
                op_name.c_str ());
     }
 
-  unary_class_ops.checkelem (static_cast<int> (op)) = reinterpret_cast<void *> (f);
+  unary_class_ops.checkelem (static_cast<int> (op))
+    = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_unary_op (octave_value::unary_op op,
-                                             int t, octave_value_typeinfo::unary_op_fcn f)
+                                             int t,
+                                             octave_value_typeinfo::unary_op_fcn f)
 {
   if (lookup_unary_op (op, t))
     {
       std::string op_name = octave_value::unary_op_as_string (op);
       std::string type_name = types(t);
 
       warning ("duplicate unary operator '%s' for type '%s'",
                op_name.c_str (), type_name.c_str ());
@@ -267,45 +272,48 @@ octave_value_typeinfo::do_register_unary
 
   unary_ops.checkelem (static_cast<int> (op), t) = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_non_const_unary_op
-  (octave_value::unary_op op, int t, octave_value_typeinfo::non_const_unary_op_fcn f)
+  (octave_value::unary_op op, int t,
+   octave_value_typeinfo::non_const_unary_op_fcn f)
 {
   if (lookup_non_const_unary_op (op, t))
     {
       std::string op_name = octave_value::unary_op_as_string (op);
       std::string type_name = types(t);
 
       warning ("duplicate unary operator '%s' for type '%s'",
                op_name.c_str (), type_name.c_str ());
     }
 
-  non_const_unary_ops.checkelem (static_cast<int> (op), t) = reinterpret_cast<void *> (f);
+  non_const_unary_ops.checkelem (static_cast<int> (op), t)
+    = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_binary_class_op (octave_value::binary_op op,
                                                     octave_value_typeinfo::binary_class_op_fcn f)
 {
   if (lookup_binary_class_op (op))
     {
       std::string op_name = octave_value::binary_op_as_string (op);
 
       warning ("duplicate binary operator '%s' for class dispatch",
                op_name.c_str ());
     }
 
-  binary_class_ops.checkelem (static_cast<int> (op)) = reinterpret_cast<void *> (f);
+  binary_class_ops.checkelem (static_cast<int> (op))
+    = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_binary_op (octave_value::binary_op op,
                                               int t1, int t2,
                                               octave_value_typeinfo::binary_op_fcn f)
@@ -315,34 +323,36 @@ octave_value_typeinfo::do_register_binar
       std::string op_name = octave_value::binary_op_as_string (op);
       std::string t1_name = types(t1);
       std::string t2_name = types(t2);
 
       warning ("duplicate binary operator '%s' for types '%s' and '%s'",
                op_name.c_str (), t1_name.c_str (), t1_name.c_str ());
     }
 
-  binary_ops.checkelem (static_cast<int> (op), t1, t2) = reinterpret_cast<void *> (f);
+  binary_ops.checkelem (static_cast<int> (op), t1, t2)
+    = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_binary_class_op (octave_value::compound_binary_op op,
                                                     octave_value_typeinfo::binary_class_op_fcn f)
 {
   if (lookup_binary_class_op (op))
     {
       std::string op_name = octave_value::binary_op_fcn_name (op);
 
       warning ("duplicate compound binary operator '%s' for class dispatch",
                op_name.c_str ());
     }
 
-  compound_binary_class_ops.checkelem (static_cast<int> (op)) = reinterpret_cast<void *> (f);
+  compound_binary_class_ops.checkelem (static_cast<int> (op))
+    = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_binary_op (octave_value::compound_binary_op op,
                                               int t1, int t2,
                                               octave_value_typeinfo::binary_op_fcn f)
@@ -352,23 +362,25 @@ octave_value_typeinfo::do_register_binar
       std::string op_name = octave_value::binary_op_fcn_name (op);
       std::string t1_name = types(t1);
       std::string t2_name = types(t2);
 
       warning ("duplicate compound binary operator '%s' for types '%s' and '%s'",
                op_name.c_str (), t1_name.c_str (), t1_name.c_str ());
     }
 
-  compound_binary_ops.checkelem (static_cast<int> (op), t1, t2) = reinterpret_cast<void *> (f);
+  compound_binary_ops.checkelem (static_cast<int> (op), t1, t2)
+    = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
-octave_value_typeinfo::do_register_cat_op (int t1, int t2, octave_value_typeinfo::cat_op_fcn f)
+octave_value_typeinfo::do_register_cat_op (int t1, int t2,
+                                           octave_value_typeinfo::cat_op_fcn f)
 {
   if (lookup_cat_op (t1, t2))
     {
       std::string t1_name = types(t1);
       std::string t2_name = types(t2);
 
       warning ("duplicate concatenation operator for types '%s' and '%s'",
                t1_name.c_str (), t1_name.c_str ());
@@ -389,17 +401,18 @@ octave_value_typeinfo::do_register_assig
       std::string op_name = octave_value::assign_op_as_string (op);
       std::string t_lhs_name = types(t_lhs);
       std::string t_rhs_name = types(t_rhs);
 
       warning ("duplicate assignment operator '%s' for types '%s' and '%s'",
                op_name.c_str (), t_lhs_name.c_str (), t_rhs_name.c_str ());
     }
 
-  assign_ops.checkelem (static_cast<int> (op), t_lhs, t_rhs) = reinterpret_cast<void *> (f);
+  assign_ops.checkelem (static_cast<int> (op), t_lhs, t_rhs)
+    = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_assignany_op (octave_value::assign_op op,
                                                  int t_lhs, octave_value_typeinfo::assignany_op_fcn f)
 {
@@ -407,17 +420,18 @@ octave_value_typeinfo::do_register_assig
     {
       std::string op_name = octave_value::assign_op_as_string (op);
       std::string t_lhs_name = types(t_lhs);
 
       warning ("duplicate assignment operator '%s' for types '%s'",
                op_name.c_str (), t_lhs_name.c_str ());
     }
 
-  assignany_ops.checkelem (static_cast<int> (op), t_lhs) = reinterpret_cast<void *> (f);
+  assignany_ops.checkelem (static_cast<int> (op), t_lhs)
+    = reinterpret_cast<void *> (f);
 
   return false;
 }
 
 bool
 octave_value_typeinfo::do_register_pref_assign_conv (int t_lhs, int t_rhs,
                                                      int t_result)
 {
@@ -591,17 +605,17 @@ octave_value_typeinfo::do_installed_type
 
   for (int i = 0; i < num_types; i++)
     retval(i) = types(i);
 
   return retval;
 }
 
 DEFUN (typeinfo, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} typeinfo ()\n\
 @deftypefnx {Built-in Function} {} typeinfo (@var{expr})\n\
 \n\
 Return the type of the expression @var{expr}, as a string.  If\n\
 @var{expr} is omitted, return an cell array of strings containing all the\n\
 currently installed data types.\n\
 @end deftypefn")
 {
diff --git a/libinterp/octave-value/ov-typeinfo.h b/libinterp/octave-value/ov-typeinfo.h
--- a/libinterp/octave-value/ov-typeinfo.h
+++ b/libinterp/octave-value/ov-typeinfo.h
@@ -296,17 +296,18 @@ private:
     (octave_value::unary_op, int);
 
   binary_class_op_fcn do_lookup_binary_class_op (octave_value::binary_op);
 
   binary_op_fcn do_lookup_binary_op (octave_value::binary_op, int, int);
 
   binary_class_op_fcn do_lookup_binary_class_op (octave_value::compound_binary_op);
 
-  binary_op_fcn do_lookup_binary_op (octave_value::compound_binary_op, int, int);
+  binary_op_fcn do_lookup_binary_op (octave_value::compound_binary_op,
+                                     int, int);
 
   cat_op_fcn do_lookup_cat_op (int, int);
 
   assign_op_fcn do_lookup_assign_op (octave_value::assign_op, int, int);
 
   assignany_op_fcn do_lookup_assignany_op (octave_value::assign_op, int);
 
   int do_lookup_pref_assign_conv (int, int);
diff --git a/libinterp/octave-value/ov-uint16.cc b/libinterp/octave-value/ov-uint16.cc
--- a/libinterp/octave-value/ov-uint16.cc
+++ b/libinterp/octave-value/ov-uint16.cc
@@ -69,17 +69,17 @@ template class octave_base_scalar<octave
 template class octave_base_int_scalar<octave_uint16>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_uint16_scalar);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint16_scalar,
                                      "uint16 scalar", "uint16");
 
 DEFUN (uint16, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} uint16 (@var{x})\n\
 Convert @var{x} to unsigned 16-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint16);
 }
 
 /*
diff --git a/libinterp/octave-value/ov-uint32.cc b/libinterp/octave-value/ov-uint32.cc
--- a/libinterp/octave-value/ov-uint32.cc
+++ b/libinterp/octave-value/ov-uint32.cc
@@ -69,17 +69,17 @@ template class octave_base_scalar<octave
 template class octave_base_int_scalar<octave_uint32>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_uint32_scalar);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint32_scalar,
                                      "uint32 scalar", "uint32");
 
 DEFUN (uint32, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} uint32 (@var{x})\n\
 Convert @var{x} to unsigned 32-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint32);
 }
 
 /*
diff --git a/libinterp/octave-value/ov-uint64.cc b/libinterp/octave-value/ov-uint64.cc
--- a/libinterp/octave-value/ov-uint64.cc
+++ b/libinterp/octave-value/ov-uint64.cc
@@ -69,17 +69,17 @@ template class octave_base_scalar<octave
 template class octave_base_int_scalar<octave_uint64>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_uint64_scalar);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint64_scalar,
                                      "uint64 scalar", "uint64");
 
 DEFUN (uint64, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} uint64 (@var{x})\n\
 Convert @var{x} to unsigned 64-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint64);
 }
 
 /*
diff --git a/libinterp/octave-value/ov-uint8.cc b/libinterp/octave-value/ov-uint8.cc
--- a/libinterp/octave-value/ov-uint8.cc
+++ b/libinterp/octave-value/ov-uint8.cc
@@ -69,17 +69,17 @@ template class octave_base_scalar<octave
 template class octave_base_int_scalar<octave_uint8>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_uint8_scalar);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_uint8_scalar,
                                      "uint8 scalar", "uint8");
 
 DEFUN (uint8, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} uint8 (@var{x})\n\
 Convert @var{x} to unsigned 8-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint8);
 }
 
 /*
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -227,17 +227,17 @@ octave_user_function::~octave_user_funct
   delete cmd_list;
   delete lead_comm;
   delete trail_comm;
 
 #ifdef HAVE_LLVM
   delete jit_info;
 #endif
 
-  // FIXME -- this is really playing with fire.
+  // FIXME: this is really playing with fire.
   symbol_table::erase_scope (local_scope);
 }
 
 octave_user_function *
 octave_user_function::define_ret_list (tree_parameter_list *t)
 {
   ret_list = t;
 
@@ -418,17 +418,18 @@ octave_user_function::subsref (const std
                                int nargout)
 {
   return octave_user_function::subsref (type, idx, nargout, 0);
 }
 
 octave_value_list
 octave_user_function::subsref (const std::string& type,
                                const std::list<octave_value_list>& idx,
-                               int nargout, const std::list<octave_lvalue>* lvalue_list)
+                               int nargout,
+                               const std::list<octave_lvalue>* lvalue_list)
 {
   octave_value_list retval;
 
   switch (type[0])
     {
     case '(':
       {
         int tmp_nargout = (type.length () > 1 && nargout == 0) ? 1 : nargout;
@@ -445,17 +446,17 @@ octave_user_function::subsref (const std
         error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
       }
       break;
 
     default:
       panic_impossible ();
     }
 
-  // FIXME -- perhaps there should be an
+  // FIXME: perhaps there should be an
   // octave_value_list::next_subsref member function?  See also
   // octave_builtin::subsref.
 
   if (idx.size () > 1)
     retval = retval(0).next_subsref (nargout, type, idx);
 
   return retval;
 }
@@ -686,26 +687,28 @@ octave_user_function::print_code_functio
   tree_print_code tpc (octave_stdout, VPS4);
 
   tpc.visit_octave_user_function_trailer (*this);
 }
 
 void
 octave_user_function::bind_automatic_vars
   (const string_vector& arg_names, int nargin, int nargout,
-   const octave_value_list& va_args, const std::list<octave_lvalue> *lvalue_list)
+   const octave_value_list& va_args,
+   const std::list<octave_lvalue> *lvalue_list)
 {
   if (! arg_names.empty ())
     {
       // It is better to save this in the hidden variable .argn. and
       // then use that in the inputname function instead of using argn,
       // which might be redefined in a function.  Keep the old argn name
       // for backward compatibility of functions that use it directly.
 
-      symbol_table::force_assign ("argn", charMatrix (arg_names, Vstring_fill_char));
+      symbol_table::force_assign ("argn",
+                                  charMatrix (arg_names, Vstring_fill_char));
       symbol_table::force_assign (".argn.", Cell (arg_names));
 
       symbol_table::mark_hidden (".argn.");
 
       symbol_table::mark_automatic ("argn");
       symbol_table::mark_automatic (".argn.");
     }
 
@@ -736,18 +739,18 @@ octave_user_function::bind_automatic_var
            p != lvalue_list->end (); p++)
         nbh += p->is_black_hole ();
 
       if (nbh > 0)
         {
           // Only assign the hidden variable if black holes actually present.
           Matrix bh (1, nbh);
           octave_idx_type k = 0, l = 0;
-          for (std::list<octave_lvalue>::const_iterator p = lvalue_list->begin ();
-               p != lvalue_list->end (); p++)
+          for (std::list<octave_lvalue>::const_iterator
+               p = lvalue_list->begin (); p != lvalue_list->end (); p++)
             {
               if (p->is_black_hole ())
                 bh(l++) = k+1;
               k += p->numel ();
             }
 
           symbol_table::assign (".ignored.", bh);
         }
@@ -779,17 +782,17 @@ octave_user_function::restore_warning_st
       Cell states = m.contents ("state");
 
       for (octave_idx_type i = 0; i < m.numel (); i++)
         Fwarning (ovl (states(i), ids(i)));
     }
 }
 
 DEFUN (nargin, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} nargin ()\n\
 @deftypefnx {Built-in Function} {} nargin (@var{fcn})\n\
 Within a function, return the number of arguments passed to the function.\n\
 At the top level, return the number of command line arguments passed to\n\
 Octave.\n\
 \n\
 If called with the optional argument @var{fcn}, a function name or handle,\n\
 return the declared number of arguments that the function can accept.\n\
@@ -824,17 +827,18 @@ This feature does not work on builtin fu
               tree_parameter_list *param_list = fcn->parameter_list ();
 
               retval = param_list ? param_list->length () : 0;
               if (fcn->takes_varargs ())
                 retval = -1 - retval;
             }
           else
             {
-              // Matlab gives up for histc, so maybe it's ok we give up somtimes too.
+              // Matlab gives up for histc,
+              // so maybe it's ok that that we give up somtimes too?
               error ("nargin: nargin information not available for builtin functions");
             }
         }
       else
         error ("nargin: FCN must be a string or function handle");
     }
   else if (nargin == 0)
     {
@@ -845,17 +849,17 @@ This feature does not work on builtin fu
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (nargout, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} nargout ()\n\
 @deftypefnx {Built-in Function} {} nargout (@var{fcn})\n\
 Within a function, return the number of values the caller expects to\n\
 receive.  If called with the optional argument @var{fcn}, a function\n\
 name or handle, return the number of declared output values that the\n\
 function can produce.  If the final output argument is @var{varargout}\n\
 the returned value is negative.\n\
 \n\
@@ -935,27 +939,28 @@ At the top level, @code{nargout} with no
       octave_function *fcn_val = func.function_value ();
       if (fcn_val)
         {
           octave_user_function *fcn = fcn_val->user_function_value (true);
 
           if (fcn)
             {
               tree_parameter_list *ret_list = fcn->return_list ();
-          
+
               retval = ret_list ? ret_list->length () : 0;
 
               if (fcn->takes_var_return ())
                 retval = -1 - retval;
             }
           else
             {
-              // JWE said this information is not available (currently, 2011-03-10)
+              // JWE said this information is not available (2011-03-10)
               // without making intrusive changes to Octave.
-              // Matlab gives up for histc, so maybe it's ok we give up somtimes too.
+              // Matlab gives up for histc,
+              // so maybe it's ok that we give up somtimes too?
               error ("nargout: nargout information not available for builtin functions.");
             }
         }
       else
         error ("nargout: FCN must be a string or function handle");
     }
   else if (nargin == 0)
     {
@@ -971,17 +976,17 @@ At the top level, @code{nargout} with no
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (optimize_subsasgn_calls, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} optimize_subsasgn_calls ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} optimize_subsasgn_calls (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} optimize_subsasgn_calls (@var{new_val}, \"local\")\n\
 Query or set the internal flag for subsasgn method call optimizations.\n\
 If true, Octave will attempt to eliminate the redundant copying when calling\n\
 subsasgn method of a user-defined class.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
@@ -1008,17 +1013,17 @@ static bool isargout1 (int nargout, cons
       error ("isargout: K must be a positive integer");
       return false;
     }
   else
     return (k == 1 || k <= nargout) && ! val_in_table (ignored, k);
 }
 
 DEFUN (isargout, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isargout (@var{k})\n\
 Within a function, return a logical value indicating whether the argument\n\
 @var{k} will be assigned on output to a variable.  If the result is false,\n\
 the argument has been ignored during the function call through the use of\n\
 the tilde (~) special output argument.  Functions can use @code{isargout} to\n\
 avoid performing unnecessary calculations for outputs which are unwanted.\n\
 \n\
 If @var{k} is outside the range @code{1:max (nargout)}, the function returns\n\
@@ -1055,17 +1060,19 @@ element-by-element and a logical array i
                 retval = isargout1 (nargout1, ignored, k);
             }
           else if (args(0).is_numeric_type ())
             {
               const NDArray ka = args(0).array_value ();
               if (! error_state)
                 {
                   boolNDArray r (ka.dims ());
-                  for (octave_idx_type i = 0; i < ka.numel () && ! error_state; i++)
+                  for (octave_idx_type i = 0;
+                       i < ka.numel () && ! error_state;
+                       i++)
                     r(i) = isargout1 (nargout1, ignored, ka(i));
 
                   retval = r;
                 }
             }
           else
             gripe_wrong_type_arg ("isargout", args(0));
         }
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -107,33 +107,33 @@ public:
 
   bool is_user_script (void) const { return true; }
 
   void stash_fcn_file_name (const std::string& nm) { file_name = nm; }
 
   void mark_fcn_file_up_to_date (const octave_time& t) { t_checked = t; }
 
   void stash_fcn_file_time (const octave_time& t)
-    {
-      t_parsed = t;
-      mark_fcn_file_up_to_date (t);
-    }
+  {
+    t_parsed = t;
+    mark_fcn_file_up_to_date (t);
+  }
 
   std::string fcn_file_name (void) const { return file_name; }
 
   octave_time time_parsed (void) const { return t_parsed; }
 
   octave_time time_checked (void) const { return t_checked; }
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx)
-    {
-      octave_value_list tmp = subsref (type, idx, 1);
-      return tmp.length () > 0 ? tmp(0) : octave_value ();
-    }
+  {
+    octave_value_list tmp = subsref (type, idx, 1);
+    return tmp.length () > 0 ? tmp(0) : octave_value ();
+  }
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              int nargout);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
@@ -182,45 +182,45 @@ public:
                         tree_parameter_list *rl = 0,
                         tree_statement_list *cl = 0);
 
   ~octave_user_function (void);
 
   symbol_table::context_id active_context () const
   {
     return is_anonymous_function ()
-      ? 0 : static_cast<symbol_table::context_id>(call_depth);
+           ? 0 : static_cast<symbol_table::context_id>(call_depth);
   }
 
   octave_function *function_value (bool = false) { return this; }
 
   octave_user_function *user_function_value (bool = false) { return this; }
 
   octave_user_code *user_code_value (bool = false) { return this; }
 
   octave_user_function *define_param_list (tree_parameter_list *t);
 
   octave_user_function *define_ret_list (tree_parameter_list *t);
 
   void stash_fcn_file_name (const std::string& nm);
 
   void stash_fcn_location (int line, int col)
-    {
-      location_line = line;
-      location_column = col;
-    }
+  {
+    location_line = line;
+    location_column = col;
+  }
 
   int beginning_line (void) const { return location_line; }
   int beginning_column (void) const { return location_column; }
 
   void stash_fcn_end_location (int line, int col)
-    {
-      end_location_line = line;
-      end_location_column = col;
-    }
+  {
+    end_location_line = line;
+    end_location_column = col;
+  }
 
   int ending_line (void) const { return end_location_line; }
   int ending_column (void) const { return end_location_column; }
 
   void maybe_relocate_end (void);
 
   void stash_parent_fcn_name (const std::string& p) { parent_name = p; }
 
@@ -228,20 +228,20 @@ public:
 
   void stash_leading_comment (octave_comment_list *lc) { lead_comm = lc; }
 
   void stash_trailing_comment (octave_comment_list *tc) { trail_comm = tc; }
 
   void mark_fcn_file_up_to_date (const octave_time& t) { t_checked = t; }
 
   void stash_fcn_file_time (const octave_time& t)
-    {
-      t_parsed = t;
-      mark_fcn_file_up_to_date (t);
-    }
+  {
+    t_parsed = t;
+    mark_fcn_file_up_to_date (t);
+  }
 
   std::string fcn_file_name (void) const { return file_name; }
 
   std::string profiler_name (void) const;
 
   std::string parent_fcn_name (void) const { return parent_name; }
 
   symbol_table::scope_id parent_fcn_scope (void) const { return parent_scope; }
@@ -254,30 +254,30 @@ public:
 
   void mark_as_system_fcn_file (void);
 
   bool is_system_fcn_file (void) const { return system_fcn_file; }
 
   bool is_user_function (void) const { return true; }
 
   void erase_subfunctions (void)
-    {
-      symbol_table::erase_subfunctions_in_scope (local_scope);
-    }
+  {
+    symbol_table::erase_subfunctions_in_scope (local_scope);
+  }
 
   bool takes_varargs (void) const;
 
   bool takes_var_return (void) const;
 
   void mark_as_private_function (const std::string& cname = std::string ())
-    {
-      symbol_table::mark_subfunctions_in_scope_as_private (local_scope, cname);
+  {
+    symbol_table::mark_subfunctions_in_scope_as_private (local_scope, cname);
 
-      octave_function::mark_as_private_function (cname);
-    }
+    octave_function::mark_as_private_function (cname);
+  }
 
   void lock_subfunctions (void);
 
   void unlock_subfunctions (void);
 
   std::map<std::string, octave_value> subfunctions (void) const;
 
   bool has_subfunctions (void) const;
@@ -301,23 +301,23 @@ public:
 
   bool is_inline_function (void) const { return inline_function; }
 
   void mark_as_anonymous_function (void) { anonymous_function = true; }
 
   bool is_anonymous_function (void) const { return anonymous_function; }
 
   bool is_anonymous_function_of_class
-    (const std::string& cname = std::string ()) const
+  (const std::string& cname = std::string ()) const
   {
     return anonymous_function
-      ? (cname.empty ()
-         ? (! dispatch_class ().empty ())
-         : cname == dispatch_class ())
-      : false;
+           ? (cname.empty ()
+              ? (! dispatch_class ().empty ())
+              : cname == dispatch_class ())
+           : false;
   }
 
   // If we are a special expression, then the function body consists of exactly
   // one expression. The expression's result is the return value of the
   // function.
   bool is_special_expr (void) const
   {
     return is_inline_function () || is_anonymous_function ();
@@ -325,43 +325,44 @@ public:
 
   bool is_nested_function (void) const { return nested_function; }
 
   void mark_as_nested_function (void) { nested_function = true; }
 
   void mark_as_class_constructor (void) { class_constructor = true; }
 
   bool is_class_constructor (const std::string& cname = std::string ()) const
-    {
-      return class_constructor
-        ? (cname.empty () ? true : cname == dispatch_class ()) : false;
-    }
+  {
+    return class_constructor
+           ? (cname.empty () ? true : cname == dispatch_class ()) : false;
+  }
 
   void mark_as_class_method (void) { class_method = true; }
 
   bool is_class_method (const std::string& cname = std::string ()) const
-    {
-      return class_method
-        ? (cname.empty () ? true : cname == dispatch_class ()) : false;
-    }
+  {
+    return class_method
+           ? (cname.empty () ? true : cname == dispatch_class ()) : false;
+  }
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx)
-    {
-      octave_value_list tmp = subsref (type, idx, 1);
-      return tmp.length () > 0 ? tmp(0) : octave_value ();
-    }
+  {
+    octave_value_list tmp = subsref (type, idx, 1);
+    return tmp.length () > 0 ? tmp(0) : octave_value ();
+  }
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              int nargout);
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
-                             int nargout, const std::list<octave_lvalue>* lvalue_list);
+                             int nargout,
+                             const std::list<octave_lvalue>* lvalue_list);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args,
                      const std::list<octave_lvalue>* lvalue_list);
 
@@ -380,25 +381,25 @@ public:
   tree_expression *special_expr (void);
 
   bool subsasgn_optimization_ok (void);
 
   void accept (tree_walker& tw);
 
   template <class T>
   bool local_protect (T& variable)
-    {
-      if (curr_unwind_protect_frame)
-        {
-          curr_unwind_protect_frame->protect_var (variable);
-          return true;
-        }
-      else
-        return false;
-    }
+  {
+    if (curr_unwind_protect_frame)
+      {
+        curr_unwind_protect_frame->protect_var (variable);
+        return true;
+      }
+    else
+      return false;
+  }
 
 #ifdef HAVE_LLVM
   jit_function_info *get_info (void) { return jit_info; }
 
   void stash_info (jit_function_info *info) { jit_info = info; }
 #endif
 
 #if 0
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -1455,17 +1455,18 @@ octave_value::assign (assign_op op, cons
           f = octave_value_typeinfo::lookup_assign_op (op, tthis, trhs);
         }
 
       if (f)
         {
           try
             {
               f (*rep, octave_value_list (), *rhs.rep);
-              maybe_mutate (); // Usually unnecessary, but may be needed (complex arrays).
+              // Usually unnecessary, but may be needed (complex arrays).
+              maybe_mutate ();
             }
           catch (octave_execution_exception)
             {
               gripe_library_execution_error ();
             }
         }
       else
         {
@@ -1838,18 +1839,19 @@ octave_value::float_column_vector_value 
   return FloatColumnVector (float_vector_value (force_string_conv,
                                                 frc_vec_conv));
 }
 
 FloatComplexColumnVector
 octave_value::float_complex_column_vector_value (bool force_string_conv,
                                                  bool frc_vec_conv) const
 {
-  return FloatComplexColumnVector (float_complex_vector_value (force_string_conv,
-                                                               frc_vec_conv));
+  return
+    FloatComplexColumnVector (float_complex_vector_value (force_string_conv,
+                                                          frc_vec_conv));
 }
 
 FloatRowVector
 octave_value::float_row_vector_value (bool force_string_conv,
                                       bool frc_vec_conv) const
 {
   return FloatRowVector (float_vector_value (force_string_conv,
                                              frc_vec_conv));
@@ -1966,17 +1968,17 @@ do_binary_op (octave_value::binary_op op
             }
         }
       else
         gripe_binary_op (octave_value::binary_op_as_string (op),
                          v1.class_name (), v2.class_name ());
     }
   else
     {
-      // FIXME -- we need to handle overloading operators for built-in
+      // FIXME: we need to handle overloading operators for built-in
       // classes (double, char, int8, etc.)
 
       octave_value_typeinfo::binary_op_fcn f
         = octave_value_typeinfo::lookup_binary_op (op, t1, t2);
 
       if (f)
         {
           try
@@ -1986,27 +1988,31 @@ do_binary_op (octave_value::binary_op op
           catch (octave_execution_exception)
             {
               gripe_library_execution_error ();
             }
         }
       else
         {
           octave_value tv1;
-          octave_base_value::type_conv_info cf1 = v1.numeric_conversion_function ();
+          octave_base_value::type_conv_info cf1 =
+            v1.numeric_conversion_function ();
 
           octave_value tv2;
-          octave_base_value::type_conv_info cf2 = v2.numeric_conversion_function ();
+          octave_base_value::type_conv_info cf2 =
+            v2.numeric_conversion_function ();
 
           // Try biased (one-sided) conversions first.
           if (cf2.type_id () >= 0 &&
               octave_value_typeinfo::lookup_binary_op (op, t1, cf2.type_id ()))
             cf1 = 0;
-          else if (cf1.type_id () >= 0 &&
-                   octave_value_typeinfo::lookup_binary_op (op, cf1.type_id (), t2))
+          else if (cf1.type_id () >= 0
+                   && octave_value_typeinfo::lookup_binary_op (op,
+                                                               cf1.type_id (),
+                                                               t2))
             cf2 = 0;
 
           if (cf1)
             {
               octave_base_value *tmp = cf1 (*v1.rep);
 
               if (tmp)
                 {
@@ -2048,50 +2054,55 @@ do_binary_op (octave_value::binary_op op
             {
               //demote double -> single and try again
               cf1 = tv1.numeric_demotion_function ();
 
               cf2 = tv2.numeric_demotion_function ();
 
               // Try biased (one-sided) conversions first.
               if (cf2.type_id () >= 0
-                  && octave_value_typeinfo::lookup_binary_op (op, t1, cf2.type_id ()))
+                  && octave_value_typeinfo::lookup_binary_op (op, t1,
+                                                              cf2.type_id ()))
                 cf1 = 0;
-              else if (cf1.type_id () >= 0
-                       && octave_value_typeinfo::lookup_binary_op (op, cf1.type_id (), t2))
+              else if (cf1.type_id () >= 0 &&
+                       octave_value_typeinfo::lookup_binary_op (op,
+                                                                cf1.type_id (),
+                                                                t2))
                 cf2 = 0;
 
               if (cf1)
                 {
                   octave_base_value *tmp = cf1 (*tv1.rep);
 
                   if (tmp)
                     {
                       tv1 = octave_value (tmp);
                       t1 = tv1.type_id ();
                     }
                   else
                     {
-                      gripe_binary_op_conv (octave_value::binary_op_as_string (op));
+                      gripe_binary_op_conv
+                        (octave_value::binary_op_as_string (op));
                       return retval;
                     }
                 }
 
               if (cf2)
                 {
                   octave_base_value *tmp = cf2 (*tv2.rep);
 
                   if (tmp)
                     {
                       tv2 = octave_value (tmp);
                       t2 = tv2.type_id ();
                     }
                   else
                     {
-                      gripe_binary_op_conv (octave_value::binary_op_as_string (op));
+                      gripe_binary_op_conv
+                        (octave_value::binary_op_as_string (op));
                       return retval;
                     }
                 }
 
               if (cf1 || cf2)
                 {
                   f = octave_value_typeinfo::lookup_binary_op (op, t1, t2);
 
@@ -2387,17 +2398,17 @@ do_unary_op (octave_value::unary_op op, 
             }
         }
       else
         gripe_unary_op (octave_value::unary_op_as_string (op),
                         v.class_name ());
     }
   else
     {
-      // FIXME -- we need to handle overloading operators for built-in
+      // FIXME: we need to handle overloading operators for built-in
       // classes (double, char, int8, etc.)
 
       octave_value_typeinfo::unary_op_fcn f
         = octave_value_typeinfo::lookup_unary_op (op, t);
 
       if (f)
         {
           try
@@ -2524,17 +2535,18 @@ octave_value::do_non_const_unary_op (una
                                       type_name ());
                     }
                 }
               else
                 gripe_unary_op_conversion_failed
                   (octave_value::unary_op_as_string (op), type_name ());
             }
           else
-            gripe_unary_op (octave_value::unary_op_as_string (op), type_name ());
+            gripe_unary_op (octave_value::unary_op_as_string (op),
+                            type_name ());
         }
     }
   else
     {
       // Non-genuine.
       int t = type_id ();
 
       octave_value_typeinfo::non_const_unary_op_fcn f = 0;
@@ -2564,17 +2576,17 @@ octave_value::do_non_const_unary_op (una
 octave_value&
 octave_value::do_non_const_unary_op (unary_op op, const std::string& type,
                                      const std::list<octave_value_list>& idx)
 {
   if (idx.empty ())
     do_non_const_unary_op (op);
   else
     {
-      // FIXME -- only do the following stuff if we can't find a
+      // FIXME: only do the following stuff if we can't find a
       // specific function to call to handle the op= operation for the
       // types we have.
 
       assign_op assop = unary_op_to_assign_op (op);
 
       assign (assop, type, idx, 1.0);
     }
 
@@ -2773,17 +2785,17 @@ install_types (void)
   octave_lazy_index::register_type ();
   octave_oncleanup::register_type ();
 #ifdef HAVE_JAVA
   octave_java::register_type ();
 #endif
 }
 
 DEFUN (sizeof, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} sizeof (@var{val})\n\
 Return the size of @var{val} in bytes.\n\
 @seealso{whos}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
@@ -2869,21 +2881,22 @@ decode_subscripts (const char* name, con
                      name, k+1);
               return;
             }
 
           idx.push_back (idx_item);
         }
     }
   else
-    error ("%s: second argument must be a structure with fields 'type' and 'subs'", name);
+    error ("%s: second argument must be a structure with fields 'type' and 'subs'",
+           name);
 }
 
 DEFUN (subsref, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} subsref (@var{val}, @var{idx})\n\
 Perform the subscripted element selection operation according to\n\
 the subscript specified by @var{idx}.\n\
 \n\
 The subscript @var{idx} is expected to be a structure array with\n\
 fields @samp{type} and @samp{subs}.  Valid values for @samp{type}\n\
 are @samp{\"()\"}, @samp{\"@{@}\"}, and @samp{\".\"}.\n\
 The @samp{subs} field may be either @samp{\":\"} or a cell array\n\
@@ -2936,17 +2949,17 @@ and @samp{subs}, return @var{val}.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (subsasgn, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} subsasgn (@var{val}, @var{idx}, @var{rhs})\n\
 Perform the subscripted assignment operation according to\n\
 the subscript specified by @var{idx}.\n\
 \n\
 The subscript @var{idx} is expected to be a structure array with\n\
 fields @samp{type} and @samp{subs}.  Valid values for @samp{type}\n\
 are @samp{\"()\"}, @samp{\"@{@}\"}, and @samp{\".\"}.\n\
 The @samp{subs} field may be either @samp{\":\"} or a cell array\n\
@@ -3071,17 +3084,17 @@ and @samp{subs}, return @var{rhs}.\n\
 %!# s = subsasgn (s, idx4, 163);
 %! t.a = "Hello";
 %! t.b = "There";
 %! t.c = 163;
 %! assert (s, t);
 */
 
 DEFUN (is_sq_string, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_sq_string (@var{x})\n\
 Return true if @var{x} is a single-quoted character string.\n\
 @seealso{is_dq_string, ischar}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
@@ -3098,17 +3111,17 @@ Return true if @var{x} is a single-quote
 %!assert (is_sq_string (1.0), false)
 %!assert (is_sq_string ({2.0}), false)
 
 %!error is_sq_string ()
 %!error is_sq_string ('foo', 2)
 */
 
 DEFUN (is_dq_string, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_dq_string (@var{x})\n\
 Return true if @var{x} is a double-quoted character string.\n\
 @seealso{is_sq_string, ischar}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -160,30 +160,30 @@ public:
   static std::string assign_op_as_string (assign_op);
 
   static octave_value empty_conv (const std::string& type,
                                   const octave_value& rhs = octave_value ());
 
   enum magic_colon { magic_colon_t };
 
   octave_value (void)
-    {
-      static octave_base_value nil_rep;
-      rep = &nil_rep;
-      rep->count++;
-    }
+  {
+    static octave_base_value nil_rep;
+    rep = &nil_rep;
+    rep->count++;
+  }
 
   octave_value (short int i);
   octave_value (unsigned short int i);
   octave_value (int i);
   octave_value (unsigned int i);
   octave_value (long int i);
   octave_value (unsigned long int i);
 
-  // FIXME -- these are kluges.  They turn into doubles
+  // FIXME: these are kluges.  They turn into doubles
   // internally, which will break for very large values.  We just use
   // them to store things like 64-bit ino_t, etc, and hope that those
   // values are never actually larger than can be represented exactly
   // in a double.
 
 #if defined (HAVE_LONG_LONG_INT)
   octave_value (long long int i);
 #endif
@@ -210,17 +210,18 @@ public:
   octave_value (const FloatDiagMatrix& d);
   octave_value (const RowVector& v);
   octave_value (const FloatRowVector& v);
   octave_value (const ColumnVector& v);
   octave_value (const FloatColumnVector& v);
   octave_value (const Complex& C);
   octave_value (const FloatComplex& C);
   octave_value (const ComplexMatrix& m, const MatrixType& t = MatrixType ());
-  octave_value (const FloatComplexMatrix& m, const MatrixType& t = MatrixType ());
+  octave_value (const FloatComplexMatrix& m,
+                const MatrixType& t = MatrixType ());
   octave_value (const ComplexNDArray& cnda);
   octave_value (const FloatComplexNDArray& cnda);
   octave_value (const Array<Complex>& m);
   octave_value (const Array<FloatComplex>& m);
   octave_value (const ComplexDiagMatrix& d);
   octave_value (const FloatComplexDiagMatrix& d);
   octave_value (const ComplexRowVector& v);
   octave_value (const FloatComplexRowVector& v);
@@ -291,120 +292,120 @@ public:
   octave_value (octave_value::magic_colon);
 
   octave_value (octave_base_value *new_rep, bool borrow = false);
   octave_value (octave_base_value *new_rep, int xcount) GCC_ATTR_DEPRECATED;
 
   // Copy constructor.
 
   octave_value (const octave_value& a)
-    {
-      rep = a.rep;
-      rep->count++;
-    }
+  {
+    rep = a.rep;
+    rep->count++;
+  }
 
   // This should only be called for derived types.
 
   octave_base_value *clone (void) const;
 
   octave_base_value *empty_clone (void) const
-    { return rep->empty_clone (); }
+  { return rep->empty_clone (); }
 
   // Delete the representation of this constant if the count drops to
   // zero.
 
   ~octave_value (void)
   {
     if (--rep->count == 0)
       delete rep;
   }
 
   void make_unique (void)
-    {
-      if (rep->count > 1)
-        {
-          octave_base_value *r = rep->unique_clone ();
+  {
+    if (rep->count > 1)
+      {
+        octave_base_value *r = rep->unique_clone ();
 
-          if (--rep->count == 0)
-            delete rep;
+        if (--rep->count == 0)
+          delete rep;
 
-          rep = r;
-        }
-    }
+        rep = r;
+      }
+  }
 
   // This uniquifies the value if it is referenced by more than a certain
   // number of shallow copies. This is useful for optimizations where we
   // know a certain copy, typically within a cell array, to be obsolete.
   void make_unique (int obsolete_copies)
-    {
-      if (rep->count > obsolete_copies + 1)
-        {
-          octave_base_value *r = rep->unique_clone ();
+  {
+    if (rep->count > obsolete_copies + 1)
+      {
+        octave_base_value *r = rep->unique_clone ();
 
-          if (--rep->count == 0)
-            delete rep;
+        if (--rep->count == 0)
+          delete rep;
 
-          rep = r;
-        }
-    }
+        rep = r;
+      }
+  }
 
   // Simple assignment.
 
   octave_value& operator = (const octave_value& a)
-    {
-      if (rep != a.rep)
-        {
-          if (--rep->count == 0)
-            delete rep;
+  {
+    if (rep != a.rep)
+      {
+        if (--rep->count == 0)
+          delete rep;
 
-          rep = a.rep;
-          rep->count++;
-        }
+        rep = a.rep;
+        rep->count++;
+      }
 
-      return *this;
-    }
+    return *this;
+  }
 
   octave_idx_type get_count (void) const { return rep->count; }
 
   octave_base_value::type_conv_info numeric_conversion_function (void) const
-    { return rep->numeric_conversion_function (); }
+  { return rep->numeric_conversion_function (); }
 
   octave_base_value::type_conv_info numeric_demotion_function (void) const
-    { return rep->numeric_demotion_function (); }
+  { return rep->numeric_demotion_function (); }
 
   void maybe_mutate (void);
 
   octave_value squeeze (void) const
-    { return rep->squeeze (); }
+  { return rep->squeeze (); }
 
   // The result of full().
   octave_value full_value (void) const
-    { return rep->full_value (); }
+  { return rep->full_value (); }
 
   octave_base_value *try_narrowing_conversion (void)
-    { return rep->try_narrowing_conversion (); }
+  { return rep->try_narrowing_conversion (); }
 
   // Close to dims (), but can be overloaded for classes.
   Matrix size (void)
-    { return rep->size (); }
+  { return rep->size (); }
 
   octave_idx_type numel (const octave_value_list& idx)
-    { return rep->numel (idx); }
+  { return rep->numel (idx); }
 
   octave_value single_subsref (const std::string& type,
                                const octave_value_list& idx);
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx)
-    { return rep->subsref (type, idx); }
+  { return rep->subsref (type, idx); }
 
   octave_value subsref (const std::string& type,
                         const std::list<octave_value_list>& idx,
                         bool auto_add)
-    { return rep->subsref (type, idx, auto_add); }
+  { return rep->subsref (type, idx, auto_add); }
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              int nargout);
 
   octave_value_list subsref (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              int nargout,
@@ -426,535 +427,539 @@ public:
                                   size_t skip = 1);
 
   octave_value next_subsref (bool auto_add, const std::string& type, const
                              std::list<octave_value_list>& idx,
                              size_t skip = 1);
 
   octave_value do_index_op (const octave_value_list& idx,
                             bool resize_ok = false)
-    { return rep->do_index_op (idx, resize_ok); }
+  { return rep->do_index_op (idx, resize_ok); }
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& idx);
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& idx,
                      const std::list<octave_lvalue> *lvalue_list);
 
   octave_value subsasgn (const std::string& type,
-                                 const std::list<octave_value_list>& idx,
-                                 const octave_value& rhs);
+                         const std::list<octave_value_list>& idx,
+                         const octave_value& rhs);
 
   octave_value undef_subsasgn (const std::string& type,
                                const std::list<octave_value_list>& idx,
                                const octave_value& rhs);
 
   octave_value& assign (assign_op op, const std::string& type,
-                       const std::list<octave_value_list>& idx,
-                       const octave_value& rhs);
+                        const std::list<octave_value_list>& idx,
+                        const octave_value& rhs);
 
   octave_value& assign (assign_op, const octave_value& rhs);
 
   idx_vector index_vector (void) const
-    { return rep->index_vector (); }
+  { return rep->index_vector (); }
 
   // Size.
 
   dim_vector dims (void) const
-    { return rep->dims (); }
+  { return rep->dims (); }
 
   octave_idx_type rows (void) const { return rep->rows (); }
 
   octave_idx_type columns (void) const { return rep->columns (); }
 
   octave_idx_type length (void) const;
 
   int ndims (void) const { return rep->ndims (); }
 
   bool all_zero_dims (void) const { return dims ().all_zero (); }
 
   octave_idx_type numel (void) const
-    { return rep->numel (); }
+  { return rep->numel (); }
 
   octave_idx_type capacity (void) const
-    { return rep->capacity (); }
+  { return rep->capacity (); }
 
   size_t byte_size (void) const
-    { return rep->byte_size (); }
+  { return rep->byte_size (); }
 
   octave_idx_type nnz (void) const { return rep->nnz (); }
 
   octave_idx_type nzmax (void) const { return rep->nzmax (); }
 
   octave_idx_type nfields (void) const { return rep->nfields (); }
 
   octave_value reshape (const dim_vector& dv) const
-    { return rep->reshape (dv); }
+  { return rep->reshape (dv); }
 
   octave_value permute (const Array<int>& vec, bool inv = false) const
-    { return rep->permute (vec, inv); }
+  { return rep->permute (vec, inv); }
 
   octave_value ipermute (const Array<int>& vec) const
-    { return rep->permute (vec, true); }
+  { return rep->permute (vec, true); }
 
   octave_value resize (const dim_vector& dv, bool fill = false) const
-    { return rep->resize (dv, fill);}
+  { return rep->resize (dv, fill);}
 
   MatrixType matrix_type (void) const
   { return rep->matrix_type (); }
 
   MatrixType matrix_type (const MatrixType& typ) const
   { return rep->matrix_type (typ); }
 
   // Does this constant have a type?  Both of these are provided since
   // it is sometimes more natural to write is_undefined() instead of
   // ! is_defined().
 
   bool is_defined (void) const
-    { return rep->is_defined (); }
+  { return rep->is_defined (); }
 
   bool is_undefined (void) const
-    { return ! is_defined (); }
+  { return ! is_defined (); }
 
   bool is_empty (void) const
-    { return rep->is_empty (); }
+  { return rep->is_empty (); }
 
   bool is_cell (void) const
-    { return rep->is_cell (); }
+  { return rep->is_cell (); }
 
   bool is_cellstr (void) const
-    { return rep->is_cellstr (); }
+  { return rep->is_cellstr (); }
 
   bool is_real_scalar (void) const
-    { return rep->is_real_scalar (); }
+  { return rep->is_real_scalar (); }
 
   bool is_real_matrix (void) const
-    { return rep->is_real_matrix (); }
+  { return rep->is_real_matrix (); }
 
   bool is_complex_scalar (void) const
-    { return rep->is_complex_scalar (); }
+  { return rep->is_complex_scalar (); }
 
   bool is_complex_matrix (void) const
-    { return rep->is_complex_matrix (); }
+  { return rep->is_complex_matrix (); }
 
   bool is_bool_scalar (void) const
-    { return rep->is_bool_scalar (); }
+  { return rep->is_bool_scalar (); }
 
   bool is_bool_matrix (void) const
-    { return rep->is_bool_matrix (); }
+  { return rep->is_bool_matrix (); }
 
   bool is_char_matrix (void) const
-    { return rep->is_char_matrix (); }
+  { return rep->is_char_matrix (); }
 
   bool is_diag_matrix (void) const
-    { return rep->is_diag_matrix (); }
+  { return rep->is_diag_matrix (); }
 
   bool is_perm_matrix (void) const
-    { return rep->is_perm_matrix (); }
+  { return rep->is_perm_matrix (); }
 
   bool is_string (void) const
-    { return rep->is_string (); }
+  { return rep->is_string (); }
 
   bool is_sq_string (void) const
-    { return rep->is_sq_string (); }
+  { return rep->is_sq_string (); }
 
   bool is_dq_string (void) const
-    { return rep->is_string () && ! rep->is_sq_string (); }
+  { return rep->is_string () && ! rep->is_sq_string (); }
 
   bool is_range (void) const
-    { return rep->is_range (); }
+  { return rep->is_range (); }
 
   bool is_map (void) const
-    { return rep->is_map (); }
+  { return rep->is_map (); }
 
   bool is_object (void) const
-    { return rep->is_object (); }
+  { return rep->is_object (); }
 
   bool is_java (void) const
-    { return rep->is_java (); }
+  { return rep->is_java (); }
 
   bool is_cs_list (void) const
-    { return rep->is_cs_list (); }
+  { return rep->is_cs_list (); }
 
   bool is_magic_colon (void) const
-    { return rep->is_magic_colon (); }
+  { return rep->is_magic_colon (); }
 
   bool is_null_value (void) const
-    { return rep->is_null_value (); }
+  { return rep->is_null_value (); }
 
   // Are any or all of the elements in this constant nonzero?
 
   octave_value all (int dim = 0) const
-    { return rep->all (dim); }
+  { return rep->all (dim); }
 
   octave_value any (int dim = 0) const
-    { return rep->any (dim); }
+  { return rep->any (dim); }
 
   builtin_type_t builtin_type (void) const
-    { return rep->builtin_type (); }
+  { return rep->builtin_type (); }
 
   // Floating point types.
 
   bool is_double_type (void) const
-    { return rep->is_double_type (); }
+  { return rep->is_double_type (); }
 
   bool is_single_type (void) const
-    { return rep->is_single_type (); }
+  { return rep->is_single_type (); }
 
   bool is_float_type (void) const
-    { return rep->is_float_type (); }
+  { return rep->is_float_type (); }
 
   // Integer types.
 
   bool is_int8_type (void) const
-    { return rep->is_int8_type (); }
+  { return rep->is_int8_type (); }
 
   bool is_int16_type (void) const
-    { return rep->is_int16_type (); }
+  { return rep->is_int16_type (); }
 
   bool is_int32_type (void) const
-    { return rep->is_int32_type (); }
+  { return rep->is_int32_type (); }
 
   bool is_int64_type (void) const
-   { return rep->is_int64_type (); }
+  { return rep->is_int64_type (); }
 
   bool is_uint8_type (void) const
-    { return rep->is_uint8_type (); }
+  { return rep->is_uint8_type (); }
 
   bool is_uint16_type (void) const
-    { return rep->is_uint16_type (); }
+  { return rep->is_uint16_type (); }
 
   bool is_uint32_type (void) const
-    { return rep->is_uint32_type (); }
+  { return rep->is_uint32_type (); }
 
   bool is_uint64_type (void) const
-    { return rep->is_uint64_type (); }
+  { return rep->is_uint64_type (); }
 
   // Other type stuff.
 
   bool is_bool_type (void) const
-    { return rep->is_bool_type (); }
+  { return rep->is_bool_type (); }
 
   bool is_integer_type (void) const
-    { return rep->is_integer_type (); }
+  { return rep->is_integer_type (); }
 
   bool is_real_type (void) const
-    { return rep->is_real_type (); }
+  { return rep->is_real_type (); }
 
   bool is_complex_type (void) const
-    { return rep->is_complex_type (); }
+  { return rep->is_complex_type (); }
 
   bool is_scalar_type (void) const
-    { return rep->is_scalar_type (); }
+  { return rep->is_scalar_type (); }
 
   bool is_matrix_type (void) const
-    { return rep->is_matrix_type (); }
+  { return rep->is_matrix_type (); }
 
   bool is_numeric_type (void) const
-    { return rep->is_numeric_type (); }
+  { return rep->is_numeric_type (); }
 
   bool is_sparse_type (void) const
-    { return rep->is_sparse_type (); }
+  { return rep->is_sparse_type (); }
 
   // Does this constant correspond to a truth value?
 
   bool is_true (void) const
-    { return rep->is_true (); }
+  { return rep->is_true (); }
 
   // Do two constants match (in a switch statement)?
 
   bool is_equal (const octave_value&) const;
 
   // Are the dimensions of this constant zero by zero?
 
   bool is_zero_by_zero (void) const
-    { return (rows () == 0 && columns () == 0); }
+  { return (rows () == 0 && columns () == 0); }
 
   bool is_constant (void) const
-    { return rep->is_constant (); }
+  { return rep->is_constant (); }
 
   bool is_function_handle (void) const
-    { return rep->is_function_handle (); }
+  { return rep->is_function_handle (); }
 
   bool is_anonymous_function (void) const
-    { return rep->is_anonymous_function (); }
+  { return rep->is_anonymous_function (); }
 
   bool is_inline_function (void) const
-    { return rep->is_inline_function (); }
+  { return rep->is_inline_function (); }
 
   bool is_function (void) const
-    { return rep->is_function (); }
+  { return rep->is_function (); }
 
   bool is_user_script (void) const
-    { return rep->is_user_script (); }
+  { return rep->is_user_script (); }
 
   bool is_user_function (void) const
-    { return rep->is_user_function (); }
+  { return rep->is_user_function (); }
 
   bool is_user_code (void) const
-    { return rep->is_user_code (); }
+  { return rep->is_user_code (); }
 
   bool is_builtin_function (void) const
-    { return rep->is_builtin_function (); }
+  { return rep->is_builtin_function (); }
 
   bool is_dld_function (void) const
-    { return rep->is_dld_function (); }
+  { return rep->is_dld_function (); }
 
   bool is_mex_function (void) const
-    { return rep->is_mex_function (); }
+  { return rep->is_mex_function (); }
 
   void erase_subfunctions (void) { rep->erase_subfunctions (); }
 
   // Values.
 
   octave_value eval (void) { return *this; }
 
   short int
   short_value (bool req_int = false, bool frc_str_conv = false) const
-    { return rep->short_value (req_int, frc_str_conv); }
+  { return rep->short_value (req_int, frc_str_conv); }
 
   unsigned short int
   ushort_value (bool req_int = false, bool frc_str_conv = false) const
-    { return rep->ushort_value (req_int, frc_str_conv); }
+  { return rep->ushort_value (req_int, frc_str_conv); }
 
   int int_value (bool req_int = false, bool frc_str_conv = false) const
-    { return rep->int_value (req_int, frc_str_conv); }
+  { return rep->int_value (req_int, frc_str_conv); }
 
   unsigned int
   uint_value (bool req_int = false, bool frc_str_conv = false) const
-    { return rep->uint_value (req_int, frc_str_conv); }
+  { return rep->uint_value (req_int, frc_str_conv); }
 
   int nint_value (bool frc_str_conv = false) const
-    { return rep->nint_value (frc_str_conv); }
+  { return rep->nint_value (frc_str_conv); }
 
   long int
   long_value (bool req_int = false, bool frc_str_conv = false) const
-    { return rep->long_value (req_int, frc_str_conv); }
+  { return rep->long_value (req_int, frc_str_conv); }
 
   unsigned long int
   ulong_value (bool req_int = false, bool frc_str_conv = false) const
-    { return rep->ulong_value (req_int, frc_str_conv); }
+  { return rep->ulong_value (req_int, frc_str_conv); }
 
   int64_t
   int64_value (bool req_int = false, bool frc_str_conv = false) const
-    { return rep->int64_value (req_int, frc_str_conv); }
+  { return rep->int64_value (req_int, frc_str_conv); }
 
   uint64_t
   uint64_value (bool req_int = false, bool frc_str_conv = false) const
-    { return rep->uint64_value (req_int, frc_str_conv); }
+  { return rep->uint64_value (req_int, frc_str_conv); }
 
   octave_idx_type
   idx_type_value (bool req_int = false, bool frc_str_conv = false) const;
 
   double double_value (bool frc_str_conv = false) const
-    { return rep->double_value (frc_str_conv); }
+  { return rep->double_value (frc_str_conv); }
 
   float float_value (bool frc_str_conv = false) const
-    { return rep->float_value (frc_str_conv); }
+  { return rep->float_value (frc_str_conv); }
 
   double scalar_value (bool frc_str_conv = false) const
-    { return rep->scalar_value (frc_str_conv); }
+  { return rep->scalar_value (frc_str_conv); }
 
   float float_scalar_value (bool frc_str_conv = false) const
-    { return rep->float_scalar_value (frc_str_conv); }
+  { return rep->float_scalar_value (frc_str_conv); }
 
   Cell cell_value (void) const;
 
   Matrix matrix_value (bool frc_str_conv = false) const
-    { return rep->matrix_value (frc_str_conv); }
+  { return rep->matrix_value (frc_str_conv); }
 
   FloatMatrix float_matrix_value (bool frc_str_conv = false) const
-    { return rep->float_matrix_value (frc_str_conv); }
+  { return rep->float_matrix_value (frc_str_conv); }
 
   NDArray array_value (bool frc_str_conv = false) const
-    { return rep->array_value (frc_str_conv); }
+  { return rep->array_value (frc_str_conv); }
 
   FloatNDArray float_array_value (bool frc_str_conv = false) const
-    { return rep->float_array_value (frc_str_conv); }
+  { return rep->float_array_value (frc_str_conv); }
 
   Complex complex_value (bool frc_str_conv = false) const
-    { return rep->complex_value (frc_str_conv); }
+  { return rep->complex_value (frc_str_conv); }
 
   FloatComplex float_complex_value (bool frc_str_conv = false) const
-    { return rep->float_complex_value (frc_str_conv); }
+  { return rep->float_complex_value (frc_str_conv); }
 
   ComplexMatrix complex_matrix_value (bool frc_str_conv = false) const
-    { return rep->complex_matrix_value (frc_str_conv); }
+  { return rep->complex_matrix_value (frc_str_conv); }
 
-  FloatComplexMatrix float_complex_matrix_value (bool frc_str_conv = false) const
-    { return rep->float_complex_matrix_value (frc_str_conv); }
+  FloatComplexMatrix
+  float_complex_matrix_value (bool frc_str_conv = false) const
+  { return rep->float_complex_matrix_value (frc_str_conv); }
 
   ComplexNDArray complex_array_value (bool frc_str_conv = false) const
-    { return rep->complex_array_value (frc_str_conv); }
+  { return rep->complex_array_value (frc_str_conv); }
 
-  FloatComplexNDArray float_complex_array_value (bool frc_str_conv = false) const
-    { return rep->float_complex_array_value (frc_str_conv); }
+  FloatComplexNDArray
+  float_complex_array_value (bool frc_str_conv = false) const
+  { return rep->float_complex_array_value (frc_str_conv); }
 
   bool bool_value (bool warn = false) const
-    { return rep->bool_value (warn); }
+  { return rep->bool_value (warn); }
 
   boolMatrix bool_matrix_value (bool warn = false) const
-    { return rep->bool_matrix_value (warn); }
+  { return rep->bool_matrix_value (warn); }
 
   boolNDArray bool_array_value (bool warn = false) const
-    { return rep->bool_array_value (warn); }
+  { return rep->bool_array_value (warn); }
 
   charMatrix char_matrix_value (bool frc_str_conv = false) const
-    { return rep->char_matrix_value (frc_str_conv); }
+  { return rep->char_matrix_value (frc_str_conv); }
 
   charNDArray char_array_value (bool frc_str_conv = false) const
-    { return rep->char_array_value (frc_str_conv); }
+  { return rep->char_array_value (frc_str_conv); }
 
   SparseMatrix sparse_matrix_value (bool frc_str_conv = false) const
-    { return rep->sparse_matrix_value (frc_str_conv); }
+  { return rep->sparse_matrix_value (frc_str_conv); }
 
-  SparseComplexMatrix sparse_complex_matrix_value (bool frc_str_conv = false) const
-    { return rep->sparse_complex_matrix_value (frc_str_conv); }
+  SparseComplexMatrix
+  sparse_complex_matrix_value (bool frc_str_conv = false) const
+  { return rep->sparse_complex_matrix_value (frc_str_conv); }
 
   SparseBoolMatrix sparse_bool_matrix_value (bool warn = false) const
-    { return rep->sparse_bool_matrix_value (warn); }
+  { return rep->sparse_bool_matrix_value (warn); }
 
   DiagMatrix diag_matrix_value (bool force = false) const
-    { return rep->diag_matrix_value (force); }
+  { return rep->diag_matrix_value (force); }
 
   FloatDiagMatrix float_diag_matrix_value (bool force = false) const
-    { return rep->float_diag_matrix_value (force); }
+  { return rep->float_diag_matrix_value (force); }
 
   ComplexDiagMatrix complex_diag_matrix_value (bool force = false) const
-    { return rep->complex_diag_matrix_value (force); }
+  { return rep->complex_diag_matrix_value (force); }
 
-  FloatComplexDiagMatrix float_complex_diag_matrix_value (bool force = false) const
-    { return rep->float_complex_diag_matrix_value (force); }
+  FloatComplexDiagMatrix
+  float_complex_diag_matrix_value (bool force = false) const
+  { return rep->float_complex_diag_matrix_value (force); }
 
   PermMatrix perm_matrix_value (void) const
-    { return rep->perm_matrix_value (); }
+  { return rep->perm_matrix_value (); }
 
   octave_int8 int8_scalar_value (void) const
-    { return rep->int8_scalar_value (); }
+  { return rep->int8_scalar_value (); }
 
   octave_int16 int16_scalar_value (void) const
-    { return rep->int16_scalar_value (); }
+  { return rep->int16_scalar_value (); }
 
   octave_int32 int32_scalar_value (void) const
-    { return rep->int32_scalar_value (); }
+  { return rep->int32_scalar_value (); }
 
   octave_int64 int64_scalar_value (void) const
-    { return rep->int64_scalar_value (); }
+  { return rep->int64_scalar_value (); }
 
   octave_uint8 uint8_scalar_value (void) const
-    { return rep->uint8_scalar_value (); }
+  { return rep->uint8_scalar_value (); }
 
   octave_uint16 uint16_scalar_value (void) const
-    { return rep->uint16_scalar_value (); }
+  { return rep->uint16_scalar_value (); }
 
   octave_uint32 uint32_scalar_value (void) const
-    { return rep->uint32_scalar_value (); }
+  { return rep->uint32_scalar_value (); }
 
   octave_uint64 uint64_scalar_value (void) const
-    { return rep->uint64_scalar_value (); }
+  { return rep->uint64_scalar_value (); }
 
   int8NDArray int8_array_value (void) const
-    { return rep->int8_array_value (); }
+  { return rep->int8_array_value (); }
 
   int16NDArray int16_array_value (void) const
-    { return rep->int16_array_value (); }
+  { return rep->int16_array_value (); }
 
   int32NDArray int32_array_value (void) const
-    { return rep->int32_array_value (); }
+  { return rep->int32_array_value (); }
 
   int64NDArray int64_array_value (void) const
-    { return rep->int64_array_value (); }
+  { return rep->int64_array_value (); }
 
   uint8NDArray uint8_array_value (void) const
-    { return rep->uint8_array_value (); }
+  { return rep->uint8_array_value (); }
 
   uint16NDArray uint16_array_value (void) const
-    { return rep->uint16_array_value (); }
+  { return rep->uint16_array_value (); }
 
   uint32NDArray uint32_array_value (void) const
-    { return rep->uint32_array_value (); }
+  { return rep->uint32_array_value (); }
 
   uint64NDArray uint64_array_value (void) const
-    { return rep->uint64_array_value (); }
+  { return rep->uint64_array_value (); }
 
   string_vector all_strings (bool pad = false) const
-    { return rep->all_strings (pad); }
+  { return rep->all_strings (pad); }
 
   std::string string_value (bool force = false) const
-    { return rep->string_value (force); }
+  { return rep->string_value (force); }
 
   Array<std::string> cellstr_value (void) const
-    { return rep->cellstr_value (); }
+  { return rep->cellstr_value (); }
 
   Range range_value (void) const
-    { return rep->range_value (); }
+  { return rep->range_value (); }
 
   octave_map map_value (void) const;
 
   octave_scalar_map scalar_map_value (void) const;
 
   string_vector map_keys (void) const
-    { return rep->map_keys (); }
+  { return rep->map_keys (); }
 
   size_t nparents (void) const
-    { return rep->nparents (); }
+  { return rep->nparents (); }
 
   std::list<std::string> parent_class_name_list (void) const
-    { return rep->parent_class_name_list (); }
+  { return rep->parent_class_name_list (); }
 
   string_vector parent_class_names (void) const
-    { return rep->parent_class_names (); }
+  { return rep->parent_class_names (); }
 
   octave_base_value *
   find_parent_class (const std::string& parent_class_name)
-    { return rep->find_parent_class (parent_class_name); }
+  { return rep->find_parent_class (parent_class_name); }
 
   octave_function *function_value (bool silent = false) const;
 
   octave_user_function *user_function_value (bool silent = false) const;
 
   octave_user_script *user_script_value (bool silent = false) const;
 
   octave_user_code *user_code_value (bool silent = false) const;
 
   octave_fcn_handle *fcn_handle_value (bool silent = false) const;
 
   octave_fcn_inline *fcn_inline_value (bool silent = false) const;
 
   octave_value_list list_value (void) const;
 
   ColumnVector column_vector_value (bool frc_str_conv = false,
-                             bool frc_vec_conv = false) const;
+                                    bool frc_vec_conv = false) const;
 
   ComplexColumnVector
   complex_column_vector_value (bool frc_str_conv = false,
-                        bool frc_vec_conv = false) const;
+                               bool frc_vec_conv = false) const;
 
   RowVector row_vector_value (bool frc_str_conv = false,
                               bool frc_vec_conv = false) const;
 
   ComplexRowVector
   complex_row_vector_value (bool frc_str_conv = false,
                             bool frc_vec_conv = false) const;
 
 
   FloatColumnVector float_column_vector_value (bool frc_str_conv = false,
-                             bool frc_vec_conv = false) const;
+                                               bool frc_vec_conv = false) const;
 
   FloatComplexColumnVector
   float_complex_column_vector_value (bool frc_str_conv = false,
-                        bool frc_vec_conv = false) const;
+                                     bool frc_vec_conv = false) const;
 
   FloatRowVector float_row_vector_value (bool frc_str_conv = false,
-                              bool frc_vec_conv = false) const;
+                                         bool frc_vec_conv = false) const;
 
   FloatComplexRowVector
   float_complex_row_vector_value (bool frc_str_conv = false,
-                            bool frc_vec_conv = false) const;
+                                  bool frc_vec_conv = false) const;
 
 
 
 
   Array<int> int_vector_value (bool req_int = false,
                                bool frc_str_conv = false,
                                bool frc_vec_conv = false) const;
 
@@ -965,25 +970,26 @@ public:
 
   Array<double> vector_value (bool frc_str_conv = false,
                               bool frc_vec_conv = false) const;
 
   Array<Complex> complex_vector_value (bool frc_str_conv = false,
                                        bool frc_vec_conv = false) const;
 
   Array<float> float_vector_value (bool frc_str_conv = false,
-                              bool frc_vec_conv = false) const;
+                                   bool frc_vec_conv = false) const;
 
-  Array<FloatComplex> float_complex_vector_value (bool frc_str_conv = false,
-                                       bool frc_vec_conv = false) const;
+  Array<FloatComplex>
+  float_complex_vector_value (bool frc_str_conv = false,
+                              bool frc_vec_conv = false) const;
 
   // Possibly economize a lazy-indexed value.
 
   void maybe_economize (void)
-    { rep->maybe_economize (); }
+  { rep->maybe_economize (); }
 
   // The following two hook conversions are called on any octave_value prior to
   // storing it to a "permanent" location, like a named variable, a cell or a
   // struct component, or a return value of a function.
 
   octave_value storable_value (void) const;
 
   // Ditto, but in place, i.e. equivalent to *this = this->storable_value (),
@@ -992,133 +998,132 @@ public:
   void make_storable_value (void);
 
   // Conversions.  These should probably be private.  If a user of this
   // class wants a certain kind of constant, he should simply ask for
   // it, and we should convert it if possible.
 
   octave_value convert_to_str (bool pad = false, bool force = false,
                                char type = '\'') const
-    { return rep->convert_to_str (pad, force, type); }
+  { return rep->convert_to_str (pad, force, type); }
 
   octave_value
   convert_to_str_internal (bool pad, bool force, char type) const
-    { return rep->convert_to_str_internal (pad, force, type); }
+  { return rep->convert_to_str_internal (pad, force, type); }
 
   void convert_to_row_or_column_vector (void)
-    { rep->convert_to_row_or_column_vector (); }
+  { rep->convert_to_row_or_column_vector (); }
 
   bool print_as_scalar (void) const
-    { return rep->print_as_scalar (); }
+  { return rep->print_as_scalar (); }
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const
-    { rep->print (os, pr_as_read_syntax); }
+  { rep->print (os, pr_as_read_syntax); }
 
-  void print_raw (std::ostream& os,
-                          bool pr_as_read_syntax = false) const
-    { rep->print_raw (os, pr_as_read_syntax); }
+  void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const
+  { rep->print_raw (os, pr_as_read_syntax); }
 
   bool print_name_tag (std::ostream& os, const std::string& name) const
-    { return rep->print_name_tag (os, name); }
+  { return rep->print_name_tag (os, name); }
 
   void print_with_name (std::ostream& os, const std::string& name) const
   { rep->print_with_name (os, name, true); }
 
   std::string short_disp (void) const { return rep->short_disp (); }
 
   int type_id (void) const { return rep->type_id (); }
 
   std::string type_name (void) const { return rep->type_name (); }
 
   std::string class_name (void) const { return rep->class_name (); }
 
   // Unary and binary operations.
 
   friend OCTINTERP_API octave_value do_unary_op (unary_op op,
-                                   const octave_value& a);
+                                                 const octave_value& a);
 
   octave_value& do_non_const_unary_op (unary_op op);
 
   octave_value& do_non_const_unary_op (unary_op op, const std::string& type,
-                                      const std::list<octave_value_list>& idx);
+                                       const std::list<octave_value_list>& idx);
 
   friend OCTINTERP_API octave_value do_binary_op (binary_op op,
-                                    const octave_value& a,
-                                    const octave_value& b);
+                                                  const octave_value& a,
+                                                  const octave_value& b);
 
   friend OCTINTERP_API octave_value do_binary_op (compound_binary_op op,
                                                   const octave_value& a,
                                                   const octave_value& b);
 
   friend OCTINTERP_API octave_value do_cat_op (const octave_value& a,
-                                 const octave_value& b,
-                                 const Array<octave_idx_type>& ra_idx);
+                                               const octave_value& b,
+                                               const Array<octave_idx_type>& ra_idx);
 
   const octave_base_value& get_rep (void) const { return *rep; }
 
   bool is_copy_of (const octave_value &val) const { return rep == val.rep; }
 
   void print_info (std::ostream& os,
-                           const std::string& prefix = std::string ()) const;
+                   const std::string& prefix = std::string ()) const;
 
   bool save_ascii (std::ostream& os) { return rep->save_ascii (os); }
 
   bool load_ascii (std::istream& is) { return rep->load_ascii (is); }
 
   bool save_binary (std::ostream& os, bool& save_as_floats)
-    { return rep->save_binary (os, save_as_floats); }
+  { return rep->save_binary (os, save_as_floats); }
 
   bool load_binary (std::istream& is, bool swap,
-                            oct_mach_info::float_format fmt)
-    { return rep->load_binary (is, swap, fmt); }
+                    oct_mach_info::float_format fmt)
+  { return rep->load_binary (is, swap, fmt); }
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats)
-    { return rep->save_hdf5 (loc_id, name, save_as_floats); }
+  { return rep->save_hdf5 (loc_id, name, save_as_floats); }
 
   bool load_hdf5 (hid_t loc_id, const char *name)
-    { return rep->load_hdf5 (loc_id, name); }
+  { return rep->load_hdf5 (loc_id, name); }
 #endif
 
   int write (octave_stream& os, int block_size,
-                     oct_data_conv::data_type output_type, int skip,
-                     oct_mach_info::float_format flt_fmt) const;
+             oct_data_conv::data_type output_type, int skip,
+             oct_mach_info::float_format flt_fmt) const;
 
   octave_base_value *internal_rep (void) const { return rep; }
 
   // Unsafe.  These functions exist to support the MEX interface.
   // You should not use them anywhere else.
   void *mex_get_data (void) const { return rep->mex_get_data (); }
 
   octave_idx_type *mex_get_ir (void) const { return rep->mex_get_ir (); }
 
   octave_idx_type *mex_get_jc (void) const { return rep->mex_get_jc (); }
 
   mxArray *as_mxArray (void) const { return rep->as_mxArray (); }
 
   octave_value diag (octave_idx_type k = 0) const
-    { return rep->diag (k); }
+  { return rep->diag (k); }
 
   octave_value diag (octave_idx_type m, octave_idx_type n) const
-    { return rep->diag (m, n); }
+  { return rep->diag (m, n); }
 
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
-    { return rep->sort (dim, mode); }
+  { return rep->sort (dim, mode); }
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
-                 sortmode mode = ASCENDING) const
-    { return rep->sort (sidx, dim, mode); }
+                     sortmode mode = ASCENDING) const
+  { return rep->sort (sidx, dim, mode); }
 
   sortmode is_sorted (sortmode mode = UNSORTED) const
-    { return rep->is_sorted (mode); }
+  { return rep->is_sorted (mode); }
 
   Array<octave_idx_type> sort_rows_idx (sortmode mode = ASCENDING) const
-    { return rep->sort_rows_idx (mode); }
+  { return rep->sort_rows_idx (mode); }
 
   sortmode is_sorted_rows (sortmode mode = UNSORTED) const
-    { return rep->is_sorted_rows (mode); }
+  { return rep->is_sorted_rows (mode); }
 
   void lock (void) { rep->lock (); }
 
   void unlock (void) { rep->unlock (); }
 
   bool islocked (void) const { return rep->islocked (); }
 
   void dump (std::ostream& os) const { rep->dump (os); }
@@ -1190,33 +1195,33 @@ public:
   MAPPER_FORWARD (xsignbit)
   MAPPER_FORWARD (xtoascii)
   MAPPER_FORWARD (xtolower)
   MAPPER_FORWARD (xtoupper)
 
 #undef MAPPER_FORWARD
 
   octave_value map (octave_base_value::unary_mapper_t umap) const
-    { return rep->map (umap); }
+  { return rep->map (umap); }
 
   // Extract the n-th element, aka val(n). Result is undefined if val is not an
   // array type or n is out of range. Never error.
   octave_value
   fast_elem_extract (octave_idx_type n) const
-    { return rep->fast_elem_extract (n); }
+  { return rep->fast_elem_extract (n); }
 
   // Assign the n-th element, aka val(n) = x. Returns false if val is not an
   // array type, x is not a matching scalar type, or n is out of range.
   // Never error.
   virtual bool
   fast_elem_insert (octave_idx_type n, const octave_value& x)
-    {
-      make_unique ();
-      return rep->fast_elem_insert (n, x);
-    }
+  {
+    make_unique ();
+    return rep->fast_elem_insert (n, x);
+  }
 
 protected:
 
   // The real representation.
   octave_base_value *rep;
 
 private:
 
@@ -1336,17 +1341,17 @@ extern OCTINTERP_API void install_types 
 // simplify the transition to the new octave_value class hierarchy,
 // which uses octave_base_value instead of octave_value for the type
 // of octave_value::rep.
 #define OV_REP_TYPE octave_base_value
 
 // Templated value extractors.
 template<class Value>
 inline Value octave_value_extract (const octave_value&)
-  { assert (false); }
+{ assert (false); }
 
 #define DEF_VALUE_EXTRACTOR(VALUE,MPREFIX) \
 template<> \
 inline VALUE octave_value_extract<VALUE> (const octave_value& v) \
   { return v.MPREFIX ## _value (); }
 
 DEF_VALUE_EXTRACTOR (double, scalar)
 DEF_VALUE_EXTRACTOR (float, float_scalar)
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -186,17 +186,17 @@ intern_argv (int argc, char **argv)
       // Skip program name in argv.
       int i = argc;
       while (--i > 0)
         octave_argv[i-1] = *(argv+i);
     }
 }
 
 DEFUN (__version_info__, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {retval =} __version_info__ (@var{name}, @var{version}, @var{release}, @var{date})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   static octave_map vinfo;
 
@@ -856,24 +856,24 @@ octave_execute_interpreter (void)
 
   // Force input to be echoed if not really interactive, but the user
   // has forced interactive behavior.
 
   if (! interactive && forced_interactive)
     {
       command_editor::blink_matching_paren (false);
 
-      // FIXME -- is this the right thing to do?
+      // FIXME: is this the right thing to do?
 
       Fecho_executing_commands (octave_value (ECHO_CMD_LINE));
     }
 
   if (octave_embedded)
     {
-      // FIXME -- do we need to do any cleanup here before
+      // FIXME: do we need to do any cleanup here before
       // returning?  If we don't, what will happen to Octave functions
       // that have been registered to execute with atexit, for example?
 
       return 1;
     }
 
   int retval = main_loop ();
 
@@ -926,17 +926,17 @@ check_starting_gui (void)
 int
 octave_starting_gui (void)
 {
   start_gui = check_starting_gui ();
   return start_gui;
 }
 
 DEFUN (isguirunning, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isguirunning ()\n\
 Return true if Octave is running in GUI mode and false otherwise.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 0)
     retval = start_gui;
@@ -947,17 +947,17 @@ Return true if Octave is running in GUI 
 }
 
 /*
 %!assert (islogical (isguirunning ()))
 %!error isguirunning (1)
 */
 
 DEFUN (argv, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} argv ()\n\
 Return the command line arguments passed to Octave.  For example,\n\
 if you invoked Octave using the command\n\
 \n\
 @example\n\
 octave --no-line-editing --silent\n\
 @end example\n\
 \n\
@@ -981,17 +981,17 @@ for an example of how to create an execu
 }
 
 /*
 %!assert (iscellstr (argv ()))
 %!error argv (1)
 */
 
 DEFUN (program_invocation_name, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} program_invocation_name ()\n\
 Return the name that was typed at the shell prompt to run Octave.\n\
 \n\
 If executing a script from the command line (e.g., @code{octave foo.m})\n\
 or using an executable Octave script, the program name is set to the\n\
 name of the script.  @xref{Executable Octave Programs}, for an example of\n\
 how to create an executable Octave script.\n\
 @seealso{program_name}\n\
@@ -1008,17 +1008,17 @@ how to create an executable Octave scrip
 }
 
 /*
 %!assert (ischar (program_invocation_name ()))
 %!error program_invocation_name (1)
 */
 
 DEFUN (program_name, args, ,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} program_name ()\n\
 Return the last component of the value returned by\n\
 @code{program_invocation_name}.\n\
 @seealso{program_invocation_name}\n\
 @end deftypefn")
 {
   octave_value retval;
 
diff --git a/libinterp/operators/op-b-bm.cc b/libinterp/operators/op-b-bm.cc
--- a/libinterp/operators/op-b-bm.cc
+++ b/libinterp/operators/op-b-bm.cc
@@ -46,17 +46,18 @@ DEFNDBINOP_FN (el_or, bool, bool_matrix,
 DEFNDBINOP_FN (el_and_not, bool, bool_matrix, bool, bool_array, mx_el_and_not)
 DEFNDBINOP_FN (el_or_not, bool, bool_matrix, bool, bool_array, mx_el_or_not)
 
 DEFNDCATOP_FN (b_bm, bool, bool_matrix, bool_array, bool_array, concat)
 DEFNDCATOP_FN (b_m, bool, matrix, array, array, concat)
 DEFNDCATOP_FN (s_bm, scalar, bool_matrix, array, array, concat)
 
 DEFNDCATOP_FN (b_fm, bool, float_matrix, float_array, float_array, concat)
-DEFNDCATOP_FN (f_bm, float_scalar, bool_matrix, float_array, float_array, concat)
+DEFNDCATOP_FN (f_bm, float_scalar, bool_matrix, float_array, float_array,
+               concat)
 
 DEFCONV (bool_matrix_conv, bool, bool_matrix)
 {
   CAST_CONV_ARG (const octave_bool&);
 
   return new octave_bool_matrix (v.bool_matrix_value ());
 }
 
diff --git a/libinterp/operators/op-b-sbm.cc b/libinterp/operators/op-b-sbm.cc
--- a/libinterp/operators/op-b-sbm.cc
+++ b/libinterp/operators/op-b-sbm.cc
@@ -86,10 +86,11 @@ install_b_sbm_ops (void)
 
   INSTALL_CATOP (octave_bool, octave_sparse_bool_matrix, b_sbm);
   INSTALL_CATOP (octave_bool, octave_sparse_matrix, b_sm);
   INSTALL_CATOP (octave_scalar, octave_sparse_bool_matrix, s_sbm);
 
   INSTALL_ASSIGNCONV (octave_bool, octave_sparse_bool_matrix,
                       octave_bool_matrix);
 
-  INSTALL_WIDENOP (octave_bool, octave_sparse_bool_matrix, sparse_bool_matrix_conv);
+  INSTALL_WIDENOP (octave_bool, octave_sparse_bool_matrix,
+                   sparse_bool_matrix_conv);
 }
diff --git a/libinterp/operators/op-bm-b.cc b/libinterp/operators/op-bm-b.cc
--- a/libinterp/operators/op-bm-b.cc
+++ b/libinterp/operators/op-bm-b.cc
@@ -53,30 +53,31 @@ DEFNDBINOP_FN (el_and, bool_matrix, bool
 DEFNDBINOP_FN (el_or, bool_matrix, bool, bool_array, bool, mx_el_or)
 
 DEFNDBINOP_FN (el_not_and, bool_matrix, bool, bool_array, bool, mx_el_not_and)
 DEFNDBINOP_FN (el_not_or, bool_matrix, bool, bool_array, bool, mx_el_not_or)
 
 DEFNDCATOP_FN (bm_b, bool_matrix, bool, bool_array, bool_array, concat)
 DEFNDCATOP_FN (bm_s, bool_matrix, scalar, array, array, concat)
 DEFNDCATOP_FN (m_b, matrix, bool, array, array, concat)
-DEFNDCATOP_FN (bm_f, bool_matrix, float_scalar, float_array, float_array, concat)
+DEFNDCATOP_FN (bm_f, bool_matrix, float_scalar, float_array, float_array,
+               concat)
 DEFNDCATOP_FN (fm_b, float_matrix, bool, float_array, float_array, concat)
 
 DEFNDASSIGNOP_FN (assign, bool_matrix, bool, bool_array, assign)
 
 static octave_value
 oct_assignop_conv_and_assign (octave_base_value& a1,
                               const octave_value_list& idx,
                               const octave_base_value& a2)
 {
   octave_bool_matrix& v1 = dynamic_cast<octave_bool_matrix&> (a1);
 
-  // FIXME -- perhaps add a warning for this conversion if the values
-  // are not all 0 or 1?
+  // FIXME: perhaps add a warning for this conversion
+  //        if the values are not all 0 or 1?
 
   boolNDArray v2 = a2.bool_array_value (true);
 
   if (! error_state)
     v1.assign (idx, v2);
 
   return octave_value ();
 }
@@ -92,20 +93,29 @@ install_bm_b_ops (void)
   INSTALL_CATOP (octave_bool_matrix, octave_bool, bm_b);
   INSTALL_CATOP (octave_bool_matrix, octave_scalar, bm_s);
   INSTALL_CATOP (octave_matrix, octave_bool, m_b);
   INSTALL_CATOP (octave_bool_matrix, octave_float_scalar, bm_f);
   INSTALL_CATOP (octave_float_matrix, octave_bool, fm_b);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_bool, assign);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_scalar, conv_and_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_scalar,
+                    conv_and_assign);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_int8_scalar, conv_and_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_int16_scalar, conv_and_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_int32_scalar, conv_and_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_int64_scalar, conv_and_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_int8_scalar,
+                    conv_and_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_int16_scalar,
+                    conv_and_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_int32_scalar,
+                    conv_and_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_int64_scalar,
+                    conv_and_assign);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_uint8_scalar, conv_and_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_uint16_scalar, conv_and_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_uint32_scalar, conv_and_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_uint64_scalar, conv_and_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_uint8_scalar,
+                    conv_and_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_uint16_scalar,
+                    conv_and_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_uint32_scalar,
+                    conv_and_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_uint64_scalar,
+                    conv_and_assign);
 }
diff --git a/libinterp/operators/op-bm-bm.cc b/libinterp/operators/op-bm-bm.cc
--- a/libinterp/operators/op-bm-bm.cc
+++ b/libinterp/operators/op-bm-bm.cc
@@ -90,34 +90,38 @@ DEFNDBINOP_FN (el_and_not, bool_matrix, 
                mx_el_and_not)
 
 DEFNDBINOP_FN (el_or_not,  bool_matrix, bool_matrix, bool_array, bool_array,
                mx_el_or_not)
 
 DEFNDCATOP_FN (bm_bm, bool_matrix, bool_matrix, bool_array, bool_array, concat)
 DEFNDCATOP_FN (bm_m, bool_matrix, matrix, array, array, concat)
 DEFNDCATOP_FN (m_bm, matrix, bool_matrix, array, array, concat)
-DEFNDCATOP_FN (bm_fm, bool_matrix, float_matrix, float_array, float_array, concat)
-DEFNDCATOP_FN (fm_bm, float_matrix, bool_matrix, float_array, float_array, concat)
+DEFNDCATOP_FN (bm_fm, bool_matrix, float_matrix, float_array, float_array,
+               concat)
+DEFNDCATOP_FN (fm_bm, float_matrix, bool_matrix, float_array, float_array,
+               concat)
 
 DEFNDASSIGNOP_FN (assign, bool_matrix, bool_matrix, bool_array, assign)
-DEFNDASSIGNOP_FNOP (assign_and, bool_matrix, bool_matrix, bool_array, mx_el_and_assign)
-DEFNDASSIGNOP_FNOP (assign_or, bool_matrix, bool_matrix, bool_array, mx_el_or_assign)
+DEFNDASSIGNOP_FNOP (assign_and, bool_matrix, bool_matrix, bool_array,
+                    mx_el_and_assign)
+DEFNDASSIGNOP_FNOP (assign_or, bool_matrix, bool_matrix, bool_array,
+                    mx_el_or_assign)
 
 DEFNULLASSIGNOP_FN (null_assign, bool_matrix, delete_elements)
 
 static octave_value
 oct_assignop_conv_and_assign (octave_base_value& a1,
                               const octave_value_list& idx,
                               const octave_base_value& a2)
 {
   octave_bool_matrix& v1 = dynamic_cast<octave_bool_matrix&> (a1);
 
-  // FIXME -- perhaps add a warning for this conversion if the values
-  // are not all 0 or 1?
+  // FIXME: perhaps add a warning for this conversion
+  //        if the values are not all 0 or 1?
 
   boolNDArray v2 = a2.bool_array_value (true);
 
   if (! error_state)
     v1.assign (idx, v2);
 
   return octave_value ();
 }
@@ -136,49 +140,71 @@ install_bm_bm_ops (void)
 
   INSTALL_NCUNOP (op_not, octave_bool_matrix, invert);
 
   INSTALL_BINOP (op_eq, octave_bool_matrix, octave_bool_matrix, eq);
   INSTALL_BINOP (op_ne, octave_bool_matrix, octave_bool_matrix, ne);
 
   INSTALL_BINOP (op_el_and, octave_bool_matrix, octave_bool_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_bool_matrix, octave_bool_matrix, el_or);
-  INSTALL_BINOP (op_el_not_and, octave_bool_matrix, octave_bool_matrix, el_not_and);
-  INSTALL_BINOP (op_el_not_or, octave_bool_matrix, octave_bool_matrix, el_not_or);
-  INSTALL_BINOP (op_el_and_not, octave_bool_matrix, octave_bool_matrix, el_and_not);
-  INSTALL_BINOP (op_el_or_not, octave_bool_matrix, octave_bool_matrix, el_or_not);
+  INSTALL_BINOP (op_el_not_and, octave_bool_matrix, octave_bool_matrix,
+                 el_not_and);
+  INSTALL_BINOP (op_el_not_or, octave_bool_matrix, octave_bool_matrix,
+                 el_not_or);
+  INSTALL_BINOP (op_el_and_not, octave_bool_matrix, octave_bool_matrix,
+                 el_and_not);
+  INSTALL_BINOP (op_el_or_not, octave_bool_matrix, octave_bool_matrix,
+                 el_or_not);
 
   INSTALL_CATOP (octave_bool_matrix, octave_bool_matrix, bm_bm);
   INSTALL_CATOP (octave_bool_matrix, octave_matrix, bm_m);
   INSTALL_CATOP (octave_matrix, octave_bool_matrix, m_bm);
   INSTALL_CATOP (octave_bool_matrix, octave_float_matrix, bm_fm);
   INSTALL_CATOP (octave_float_matrix, octave_bool_matrix, fm_bm);
 
   INSTALL_CONVOP (octave_matrix, octave_bool_matrix, matrix_to_bool_matrix);
   INSTALL_CONVOP (octave_scalar, octave_bool_matrix, scalar_to_bool_matrix);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_bool_matrix, assign);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_matrix, conv_and_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_char_matrix_str, conv_and_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_char_matrix_sq_str, conv_and_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_matrix,
+                    conv_and_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_char_matrix_str,
+                    conv_and_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_char_matrix_sq_str,
+                    conv_and_assign);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_range, conv_and_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_range,
+                    conv_and_assign);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_sparse_matrix, conv_and_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_sparse_matrix,
+                    conv_and_assign);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_int8_matrix, conv_and_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_int16_matrix, conv_and_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_int32_matrix, conv_and_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_int64_matrix, conv_and_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_int8_matrix,
+                    conv_and_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_int16_matrix,
+                    conv_and_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_int32_matrix,
+                    conv_and_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_int64_matrix,
+                    conv_and_assign);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_uint8_matrix, conv_and_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_uint16_matrix, conv_and_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_uint32_matrix, conv_and_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_uint64_matrix, conv_and_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_uint8_matrix,
+                    conv_and_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_uint16_matrix,
+                    conv_and_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_uint32_matrix,
+                    conv_and_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_uint64_matrix,
+                    conv_and_assign);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_null_matrix, null_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_null_str, null_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_null_sq_str, null_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_null_matrix,
+                    null_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_null_str,
+                    null_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_bool_matrix, octave_null_sq_str,
+                    null_assign);
 
-  INSTALL_ASSIGNOP (op_el_and_eq, octave_bool_matrix, octave_bool_matrix, assign_and);
-  INSTALL_ASSIGNOP (op_el_or_eq, octave_bool_matrix, octave_bool_matrix, assign_or);
+  INSTALL_ASSIGNOP (op_el_and_eq, octave_bool_matrix, octave_bool_matrix,
+                    assign_and);
+  INSTALL_ASSIGNOP (op_el_or_eq, octave_bool_matrix, octave_bool_matrix,
+                    assign_or);
 }
diff --git a/libinterp/operators/op-cdm-cdm.cc b/libinterp/operators/op-cdm-cdm.cc
--- a/libinterp/operators/op-cdm-cdm.cc
+++ b/libinterp/operators/op-cdm-cdm.cc
@@ -55,56 +55,67 @@ DEFUNOP (hermitian, complex_diag_matrix)
 // matrix by matrix ops.
 
 DEFBINOP_OP (add, complex_diag_matrix, complex_diag_matrix, +)
 DEFBINOP_OP (sub, complex_diag_matrix, complex_diag_matrix, -)
 DEFBINOP_OP (mul, complex_diag_matrix, complex_diag_matrix, *)
 
 DEFBINOP (div, complex_diag_matrix, complex_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_diag_matrix&, const octave_complex_diag_matrix&);
+  CAST_BINOP_ARGS (const octave_complex_diag_matrix&,
+                   const octave_complex_diag_matrix&);
 
   return xdiv (v1.complex_diag_matrix_value (),
                v2.complex_diag_matrix_value ());
 }
 
 DEFBINOP (ldiv, complex_diag_matrix, complex_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_diag_matrix&, const octave_complex_diag_matrix&);
+  CAST_BINOP_ARGS (const octave_complex_diag_matrix&,
+                   const octave_complex_diag_matrix&);
 
   return xleftdiv (v1.complex_diag_matrix_value (),
                    v2.complex_diag_matrix_value ());
 }
 
 CONVDECL (complex_diag_matrix_to_complex_matrix)
 {
   CAST_CONV_ARG (const octave_complex_diag_matrix&);
 
   return new octave_complex_matrix (v.complex_matrix_value ());
 }
 
 CONVDECL (complex_diag_matrix_to_float_complex_diag_matrix)
 {
   CAST_CONV_ARG (const octave_complex_diag_matrix&);
 
-  return new octave_float_complex_diag_matrix (v.float_complex_diag_matrix_value ());
+  return
+    new octave_float_complex_diag_matrix (v.float_complex_diag_matrix_value ());
 }
 
 void
 install_cdm_cdm_ops (void)
 {
   INSTALL_UNOP (op_uplus, octave_complex_diag_matrix, uplus);
   INSTALL_UNOP (op_uminus, octave_complex_diag_matrix, uminus);
   INSTALL_UNOP (op_transpose, octave_complex_diag_matrix, transpose);
   INSTALL_UNOP (op_hermitian, octave_complex_diag_matrix, hermitian);
 
-  INSTALL_BINOP (op_add, octave_complex_diag_matrix, octave_complex_diag_matrix, add);
-  INSTALL_BINOP (op_sub, octave_complex_diag_matrix, octave_complex_diag_matrix, sub);
-  INSTALL_BINOP (op_mul, octave_complex_diag_matrix, octave_complex_diag_matrix, mul);
-  INSTALL_BINOP (op_div, octave_complex_diag_matrix, octave_complex_diag_matrix, div);
-  INSTALL_BINOP (op_ldiv, octave_complex_diag_matrix, octave_complex_diag_matrix, ldiv);
+  INSTALL_BINOP (op_add, octave_complex_diag_matrix, octave_complex_diag_matrix,
+                 add);
+  INSTALL_BINOP (op_sub, octave_complex_diag_matrix, octave_complex_diag_matrix,
+                 sub);
+  INSTALL_BINOP (op_mul, octave_complex_diag_matrix, octave_complex_diag_matrix,
+                 mul);
+  INSTALL_BINOP (op_div, octave_complex_diag_matrix, octave_complex_diag_matrix,
+                 div);
+  INSTALL_BINOP (op_ldiv, octave_complex_diag_matrix,
+                 octave_complex_diag_matrix, ldiv);
 
-  INSTALL_CONVOP (octave_complex_diag_matrix, octave_complex_matrix, complex_diag_matrix_to_complex_matrix);
+  INSTALL_CONVOP (octave_complex_diag_matrix, octave_complex_matrix,
+                  complex_diag_matrix_to_complex_matrix);
   INSTALL_CONVOP (octave_complex_diag_matrix, octave_float_complex_diag_matrix,
                   complex_diag_matrix_to_float_complex_diag_matrix);
-  INSTALL_ASSIGNCONV (octave_complex_diag_matrix, octave_complex_matrix, octave_complex_matrix);
-  INSTALL_WIDENOP (octave_complex_diag_matrix, octave_complex_matrix, complex_diag_matrix_to_complex_matrix);
+  INSTALL_ASSIGNCONV (octave_complex_diag_matrix, octave_complex_matrix,
+                      octave_complex_matrix);
+  INSTALL_WIDENOP (octave_complex_diag_matrix, octave_complex_matrix,
+                   complex_diag_matrix_to_complex_matrix);
 }
diff --git a/libinterp/operators/op-chm.cc b/libinterp/operators/op-chm.cc
--- a/libinterp/operators/op-chm.cc
+++ b/libinterp/operators/op-chm.cc
@@ -49,51 +49,51 @@ DEFNDCATOP_FN (chm_chm, char_matrix, cha
 
 DEFCATOP (chm_s, char_matrix, scalar)
 {
   CAST_BINOP_ARGS (octave_char_matrix&, const octave_scalar&);
 
   gripe_implicit_conversion ("Octave:num-to-str",
                              v2.type_name (), v1.type_name ());
 
-  return octave_value (v1.char_array_value (). concat(v2.array_value (),
-                               ra_idx));
+  return octave_value (v1.char_array_value (). concat (v2.array_value (),
+                       ra_idx));
 }
 
 DEFCATOP (chm_m, char_matrix, matrix)
 {
   CAST_BINOP_ARGS (octave_char_matrix&, const octave_matrix&);
 
   gripe_implicit_conversion ("Octave:num-to-str",
                              v2.type_name (), v1.type_name ());
 
   return octave_value (v1.char_array_value (). concat (v2.array_value (),
-                               ra_idx));
+                       ra_idx));
 }
 
 DEFCATOP (s_chm, scalar, char_matrix)
 {
   CAST_BINOP_ARGS (octave_scalar&, const octave_char_matrix&);
 
   gripe_implicit_conversion ("Octave:num-to-str",
                              v1.type_name (), v2.type_name ());
 
   return octave_value (v1.array_value (). concat (v2.char_array_value (),
-                               ra_idx));
+                       ra_idx));
 }
 
 DEFCATOP (m_chm, matrix, char_matrix)
 {
   CAST_BINOP_ARGS (octave_matrix&, const octave_char_matrix&);
 
   gripe_implicit_conversion ("Octave:num-to-str",
                              v1.type_name (), v2.type_name ());
 
   return octave_value (v1.array_value (). concat (v2.char_array_value (),
-                               ra_idx));
+                       ra_idx));
 }
 
 void
 install_chm_ops (void)
 {
   INSTALL_UNOP (op_transpose, octave_char_matrix, transpose);
   INSTALL_UNOP (op_hermitian, octave_char_matrix, transpose);
 
diff --git a/libinterp/operators/op-class.cc b/libinterp/operators/op-class.cc
--- a/libinterp/operators/op-class.cc
+++ b/libinterp/operators/op-class.cc
@@ -67,17 +67,17 @@ along with Octave; see the file COPYING.
   }
 
 DEF_CLASS_UNOP (not)
 DEF_CLASS_UNOP (uplus)
 DEF_CLASS_UNOP (uminus)
 DEF_CLASS_UNOP (transpose)
 DEF_CLASS_UNOP (ctranspose)
 
-// FIXME -- we need to handle precedence in the binop function.
+// FIXME: we need to handle precedence in the binop function.
 
 #define DEF_CLASS_BINOP(name) \
   static octave_value \
   oct_binop_ ## name (const octave_value& a1, const octave_value& a2) \
   { \
     octave_value retval; \
  \
     std::string dispatch_type \
diff --git a/libinterp/operators/op-cm-cm.cc b/libinterp/operators/op-cm-cm.cc
--- a/libinterp/operators/op-cm-cm.cc
+++ b/libinterp/operators/op-cm-cm.cc
@@ -68,18 +68,20 @@ DEFUNOP (hermitian, complex_matrix)
 }
 
 DEFNCUNOP_METHOD (incr, complex_matrix, increment)
 DEFNCUNOP_METHOD (decr, complex_matrix, decrement)
 DEFNCUNOP_METHOD (changesign, complex_matrix, changesign)
 
 // complex matrix by complex matrix ops.
 
-DEFNDBINOP_OP (add, complex_matrix, complex_matrix, complex_array, complex_array, +)
-DEFNDBINOP_OP (sub, complex_matrix, complex_matrix, complex_array, complex_array, -)
+DEFNDBINOP_OP (add, complex_matrix, complex_matrix, complex_array,
+               complex_array, +)
+DEFNDBINOP_OP (sub, complex_matrix, complex_matrix, complex_array,
+               complex_array, -)
 
 DEFBINOP_OP (mul, complex_matrix, complex_matrix, *)
 
 DEFBINOP (div, complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
   MatrixType typ = v2.matrix_type ();
 
@@ -153,59 +155,77 @@ DEFBINOP (trans_ldiv, complex_matrix, co
 }
 
 DEFBINOP (herm_ldiv, complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (),
-                                v2.complex_matrix_value (), typ, blas_conj_trans);
+                                v2.complex_matrix_value (), typ,
+                                blas_conj_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
 
-DEFNDCMPLXCMPOP_FN (lt, complex_matrix, complex_matrix, complex_array, complex_array, mx_el_lt)
-DEFNDCMPLXCMPOP_FN (le, complex_matrix, complex_matrix, complex_array, complex_array, mx_el_le)
-DEFNDCMPLXCMPOP_FN (eq, complex_matrix, complex_matrix, complex_array, complex_array, mx_el_eq)
-DEFNDCMPLXCMPOP_FN (ge, complex_matrix, complex_matrix, complex_array, complex_array, mx_el_ge)
-DEFNDCMPLXCMPOP_FN (gt, complex_matrix, complex_matrix, complex_array, complex_array, mx_el_gt)
-DEFNDCMPLXCMPOP_FN (ne, complex_matrix, complex_matrix, complex_array, complex_array, mx_el_ne)
+DEFNDCMPLXCMPOP_FN (lt, complex_matrix, complex_matrix, complex_array,
+                    complex_array, mx_el_lt)
+DEFNDCMPLXCMPOP_FN (le, complex_matrix, complex_matrix, complex_array,
+                    complex_array, mx_el_le)
+DEFNDCMPLXCMPOP_FN (eq, complex_matrix, complex_matrix, complex_array,
+                    complex_array, mx_el_eq)
+DEFNDCMPLXCMPOP_FN (ge, complex_matrix, complex_matrix, complex_array,
+                    complex_array, mx_el_ge)
+DEFNDCMPLXCMPOP_FN (gt, complex_matrix, complex_matrix, complex_array,
+                    complex_array, mx_el_gt)
+DEFNDCMPLXCMPOP_FN (ne, complex_matrix, complex_matrix, complex_array,
+                    complex_array, mx_el_ne)
 
-DEFNDBINOP_FN (el_mul, complex_matrix, complex_matrix, complex_array, complex_array, product)
-DEFNDBINOP_FN (el_div, complex_matrix, complex_matrix, complex_array, complex_array, quotient)
-DEFNDBINOP_FN (el_pow, complex_matrix, complex_matrix, complex_array, complex_array, elem_xpow)
+DEFNDBINOP_FN (el_mul, complex_matrix, complex_matrix, complex_array,
+               complex_array, product)
+DEFNDBINOP_FN (el_div, complex_matrix, complex_matrix, complex_array,
+               complex_array, quotient)
+DEFNDBINOP_FN (el_pow, complex_matrix, complex_matrix, complex_array,
+               complex_array, elem_xpow)
 
 DEFBINOP (el_ldiv, complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
-  return octave_value (quotient (v2.complex_array_value (), v1.complex_array_value ()));
+  return octave_value (quotient (v2.complex_array_value (),
+                                 v1.complex_array_value ()));
 }
 
-DEFNDBINOP_FN (el_and, complex_matrix, complex_matrix, complex_array, complex_array, mx_el_and)
-DEFNDBINOP_FN (el_or,  complex_matrix, complex_matrix, complex_array, complex_array, mx_el_or)
+DEFNDBINOP_FN (el_and, complex_matrix, complex_matrix, complex_array,
+               complex_array, mx_el_and)
+DEFNDBINOP_FN (el_or,  complex_matrix, complex_matrix, complex_array,
+               complex_array, mx_el_or)
 
-DEFNDCATOP_FN (cm_cm, complex_matrix, complex_matrix, complex_array, complex_array, concat)
+DEFNDCATOP_FN (cm_cm, complex_matrix, complex_matrix, complex_array,
+               complex_array, concat)
 
 DEFNDASSIGNOP_FN (assign, complex_matrix, complex_matrix, complex_array, assign)
 
 DEFNULLASSIGNOP_FN (null_assign, complex_matrix, delete_elements)
 
 DEFNDASSIGNOP_OP (assign_add, complex_matrix, complex_matrix, complex_array, +=)
 DEFNDASSIGNOP_OP (assign_sub, complex_matrix, complex_matrix, complex_array, -=)
-DEFNDASSIGNOP_FNOP (assign_el_mul, complex_matrix, complex_matrix, complex_array, product_eq)
-DEFNDASSIGNOP_FNOP (assign_el_div, complex_matrix, complex_matrix, complex_array, quotient_eq)
+DEFNDASSIGNOP_FNOP (assign_el_mul, complex_matrix, complex_matrix,
+                    complex_array, product_eq)
+DEFNDASSIGNOP_FNOP (assign_el_div, complex_matrix, complex_matrix,
+                    complex_array, quotient_eq)
 
 CONVDECL (complex_matrix_to_float_complex_matrix)
 {
   CAST_CONV_ARG (const octave_complex_matrix&);
 
-  return new octave_float_complex_matrix (FloatComplexNDArray (v.complex_array_value ()));
+  return
+    new octave_float_complex_matrix
+          (FloatComplexNDArray (v.complex_array_value ()));
 }
 
 void
 install_cm_cm_ops (void)
 {
   INSTALL_UNOP (op_not, octave_complex_matrix, not);
   INSTALL_UNOP (op_uplus, octave_complex_matrix, uplus);
   INSTALL_UNOP (op_uminus, octave_complex_matrix, uminus);
@@ -217,44 +237,63 @@ install_cm_cm_ops (void)
   INSTALL_NCUNOP (op_uminus, octave_complex_matrix, changesign);
 
   INSTALL_BINOP (op_add, octave_complex_matrix, octave_complex_matrix, add);
   INSTALL_BINOP (op_sub, octave_complex_matrix, octave_complex_matrix, sub);
   INSTALL_BINOP (op_mul, octave_complex_matrix, octave_complex_matrix, mul);
   INSTALL_BINOP (op_div, octave_complex_matrix, octave_complex_matrix, div);
   INSTALL_BINOP (op_pow, octave_complex_matrix, octave_complex_matrix, pow);
   INSTALL_BINOP (op_ldiv, octave_complex_matrix, octave_complex_matrix, ldiv);
-  INSTALL_BINOP (op_trans_mul, octave_complex_matrix, octave_complex_matrix, trans_mul);
-  INSTALL_BINOP (op_mul_trans, octave_complex_matrix, octave_complex_matrix, mul_trans);
-  INSTALL_BINOP (op_herm_mul, octave_complex_matrix, octave_complex_matrix, herm_mul);
-  INSTALL_BINOP (op_mul_herm, octave_complex_matrix, octave_complex_matrix, mul_herm);
-  INSTALL_BINOP (op_trans_ldiv, octave_complex_matrix, octave_complex_matrix, trans_ldiv);
-  INSTALL_BINOP (op_herm_ldiv, octave_complex_matrix, octave_complex_matrix, herm_ldiv);
+  INSTALL_BINOP (op_trans_mul, octave_complex_matrix, octave_complex_matrix,
+                 trans_mul);
+  INSTALL_BINOP (op_mul_trans, octave_complex_matrix, octave_complex_matrix,
+                 mul_trans);
+  INSTALL_BINOP (op_herm_mul, octave_complex_matrix, octave_complex_matrix,
+                 herm_mul);
+  INSTALL_BINOP (op_mul_herm, octave_complex_matrix, octave_complex_matrix,
+                 mul_herm);
+  INSTALL_BINOP (op_trans_ldiv, octave_complex_matrix, octave_complex_matrix,
+                 trans_ldiv);
+  INSTALL_BINOP (op_herm_ldiv, octave_complex_matrix, octave_complex_matrix,
+                 herm_ldiv);
 
   INSTALL_BINOP (op_lt, octave_complex_matrix, octave_complex_matrix, lt);
   INSTALL_BINOP (op_le, octave_complex_matrix, octave_complex_matrix, le);
   INSTALL_BINOP (op_eq, octave_complex_matrix, octave_complex_matrix, eq);
   INSTALL_BINOP (op_ge, octave_complex_matrix, octave_complex_matrix, ge);
   INSTALL_BINOP (op_gt, octave_complex_matrix, octave_complex_matrix, gt);
   INSTALL_BINOP (op_ne, octave_complex_matrix, octave_complex_matrix, ne);
-  INSTALL_BINOP (op_el_mul, octave_complex_matrix, octave_complex_matrix, el_mul);
-  INSTALL_BINOP (op_el_div, octave_complex_matrix, octave_complex_matrix, el_div);
-  INSTALL_BINOP (op_el_pow, octave_complex_matrix, octave_complex_matrix, el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_complex_matrix, octave_complex_matrix, el_ldiv);
-  INSTALL_BINOP (op_el_and, octave_complex_matrix, octave_complex_matrix, el_and);
+  INSTALL_BINOP (op_el_mul, octave_complex_matrix, octave_complex_matrix,
+                 el_mul);
+  INSTALL_BINOP (op_el_div, octave_complex_matrix, octave_complex_matrix,
+                 el_div);
+  INSTALL_BINOP (op_el_pow, octave_complex_matrix, octave_complex_matrix,
+                 el_pow);
+  INSTALL_BINOP (op_el_ldiv, octave_complex_matrix, octave_complex_matrix,
+                 el_ldiv);
+  INSTALL_BINOP (op_el_and, octave_complex_matrix, octave_complex_matrix,
+                 el_and);
   INSTALL_BINOP (op_el_or, octave_complex_matrix, octave_complex_matrix, el_or);
 
   INSTALL_CATOP (octave_complex_matrix, octave_complex_matrix, cm_cm);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, octave_complex_matrix, assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, octave_complex_matrix,
+                    assign);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, octave_null_matrix, null_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, octave_null_str, null_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, octave_null_sq_str, null_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, octave_null_matrix,
+                    null_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, octave_null_str,
+                    null_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, octave_null_sq_str,
+                    null_assign);
 
-  INSTALL_ASSIGNOP (op_add_eq, octave_complex_matrix, octave_complex_matrix, assign_add);
-  INSTALL_ASSIGNOP (op_sub_eq, octave_complex_matrix, octave_complex_matrix, assign_sub);
-  INSTALL_ASSIGNOP (op_el_mul_eq, octave_complex_matrix, octave_complex_matrix, assign_el_mul);
-  INSTALL_ASSIGNOP (op_el_div_eq, octave_complex_matrix, octave_complex_matrix, assign_el_div);
+  INSTALL_ASSIGNOP (op_add_eq, octave_complex_matrix, octave_complex_matrix,
+                    assign_add);
+  INSTALL_ASSIGNOP (op_sub_eq, octave_complex_matrix, octave_complex_matrix,
+                    assign_sub);
+  INSTALL_ASSIGNOP (op_el_mul_eq, octave_complex_matrix, octave_complex_matrix,
+                    assign_el_mul);
+  INSTALL_ASSIGNOP (op_el_div_eq, octave_complex_matrix, octave_complex_matrix,
+                    assign_el_div);
 
   INSTALL_CONVOP (octave_complex_matrix, octave_float_complex_matrix,
                   complex_matrix_to_float_complex_matrix);
 }
diff --git a/libinterp/operators/op-cm-cs.cc b/libinterp/operators/op-cm-cs.cc
--- a/libinterp/operators/op-cm-cs.cc
+++ b/libinterp/operators/op-cm-cs.cc
@@ -63,53 +63,64 @@ DEFBINOP (ldiv, complex_matrix, complex)
   ComplexMatrix m2 = v2.complex_matrix_value ();
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (m1, m2, typ);
   v1.matrix_type (typ);
   return ret;
 }
 
-DEFNDCMPLXCMPOP_FN (lt, complex_matrix, complex, complex_array, complex, mx_el_lt)
-DEFNDCMPLXCMPOP_FN (le, complex_matrix, complex, complex_array, complex, mx_el_le)
-DEFNDCMPLXCMPOP_FN (eq, complex_matrix, complex, complex_array, complex, mx_el_eq)
-DEFNDCMPLXCMPOP_FN (ge, complex_matrix, complex, complex_array, complex, mx_el_ge)
-DEFNDCMPLXCMPOP_FN (gt, complex_matrix, complex, complex_array, complex, mx_el_gt)
-DEFNDCMPLXCMPOP_FN (ne, complex_matrix, complex, complex_array, complex, mx_el_ne)
+DEFNDCMPLXCMPOP_FN (lt, complex_matrix, complex, complex_array, complex,
+                    mx_el_lt)
+DEFNDCMPLXCMPOP_FN (le, complex_matrix, complex, complex_array, complex,
+                    mx_el_le)
+DEFNDCMPLXCMPOP_FN (eq, complex_matrix, complex, complex_array, complex,
+                    mx_el_eq)
+DEFNDCMPLXCMPOP_FN (ge, complex_matrix, complex, complex_array, complex,
+                    mx_el_ge)
+DEFNDCMPLXCMPOP_FN (gt, complex_matrix, complex, complex_array, complex,
+                    mx_el_gt)
+DEFNDCMPLXCMPOP_FN (ne, complex_matrix, complex, complex_array, complex,
+                    mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, complex_matrix, complex, complex_array, complex, *)
 
 DEFBINOP (el_div, complex_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
   Complex d = v2.complex_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v1.complex_array_value () / d);
 }
 
-DEFNDBINOP_FN (el_pow, complex_matrix, complex, complex_array, complex, elem_xpow)
+DEFNDBINOP_FN (el_pow, complex_matrix, complex, complex_array, complex,
+               elem_xpow)
 
 DEFBINOP (el_ldiv, complex_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
   return x_el_div (v2.complex_value (), v1.complex_array_value ());
 }
 
-DEFNDBINOP_FN (el_and, complex_matrix, complex, complex_array, complex, mx_el_and)
-DEFNDBINOP_FN (el_or,  complex_matrix, complex, complex_array, complex, mx_el_or)
+DEFNDBINOP_FN (el_and, complex_matrix, complex, complex_array, complex,
+               mx_el_and)
+DEFNDBINOP_FN (el_or,  complex_matrix, complex, complex_array, complex,
+               mx_el_or)
 
-DEFNDCATOP_FN (cm_cs, complex_matrix, complex, complex_array, complex_array, concat)
+DEFNDCATOP_FN (cm_cs, complex_matrix, complex, complex_array, complex_array,
+               concat)
 
 DEFNDASSIGNOP_FN (assign, complex_matrix, complex, complex, assign)
-DEFNDASSIGNOP_FN (sgl_assign, float_complex_matrix, complex, float_complex, assign)
+DEFNDASSIGNOP_FN (sgl_assign, float_complex_matrix, complex, float_complex,
+                  assign)
 
 DEFNDASSIGNOP_OP (assign_add, complex_matrix, complex_scalar, complex, +=)
 DEFNDASSIGNOP_OP (assign_sub, complex_matrix, complex_scalar, complex, -=)
 DEFNDASSIGNOP_OP (assign_mul, complex_matrix, complex_scalar, complex, *=)
 DEFNDASSIGNOP_OP (assign_div, complex_matrix, complex_scalar, complex, /=)
 
 void
 install_cm_cs_ops (void)
@@ -131,15 +142,20 @@ install_cm_cs_ops (void)
   INSTALL_BINOP (op_el_pow, octave_complex_matrix, octave_complex, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_complex_matrix, octave_complex, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_complex_matrix, octave_complex, el_and);
   INSTALL_BINOP (op_el_or, octave_complex_matrix, octave_complex, el_or);
 
   INSTALL_CATOP (octave_complex_matrix, octave_complex, cm_cs);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, octave_complex, assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, octave_complex, sgl_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, octave_complex,
+                    sgl_assign);
 
-  INSTALL_ASSIGNOP (op_add_eq, octave_complex_matrix, octave_complex_scalar, assign_add);
-  INSTALL_ASSIGNOP (op_sub_eq, octave_complex_matrix, octave_complex_scalar, assign_sub);
-  INSTALL_ASSIGNOP (op_mul_eq, octave_complex_matrix, octave_complex_scalar, assign_mul);
-  INSTALL_ASSIGNOP (op_div_eq, octave_complex_matrix, octave_complex_scalar, assign_div);
+  INSTALL_ASSIGNOP (op_add_eq, octave_complex_matrix, octave_complex_scalar,
+                    assign_add);
+  INSTALL_ASSIGNOP (op_sub_eq, octave_complex_matrix, octave_complex_scalar,
+                    assign_sub);
+  INSTALL_ASSIGNOP (op_mul_eq, octave_complex_matrix, octave_complex_scalar,
+                    assign_mul);
+  INSTALL_ASSIGNOP (op_div_eq, octave_complex_matrix, octave_complex_scalar,
+                    assign_div);
 }
diff --git a/libinterp/operators/op-cm-s.cc b/libinterp/operators/op-cm-s.cc
--- a/libinterp/operators/op-cm-s.cc
+++ b/libinterp/operators/op-cm-s.cc
@@ -133,11 +133,13 @@ install_cm_s_ops (void)
   INSTALL_BINOP (op_el_ldiv, octave_complex_matrix, octave_scalar, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_complex_matrix, octave_scalar, el_and);
   INSTALL_BINOP (op_el_or, octave_complex_matrix, octave_scalar, el_or);
 
   INSTALL_CATOP (octave_complex_matrix, octave_scalar, cm_s);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix, octave_scalar, assign);
 
-  INSTALL_ASSIGNOP (op_mul_eq, octave_complex_matrix, octave_scalar, assign_mul);
-  INSTALL_ASSIGNOP (op_div_eq, octave_complex_matrix, octave_scalar, assign_div);
+  INSTALL_ASSIGNOP (op_mul_eq, octave_complex_matrix, octave_scalar,
+                    assign_mul);
+  INSTALL_ASSIGNOP (op_div_eq, octave_complex_matrix, octave_scalar,
+                    assign_div);
 }
diff --git a/libinterp/operators/op-cm-scm.cc b/libinterp/operators/op-cm-scm.cc
--- a/libinterp/operators/op-cm-scm.cc
+++ b/libinterp/operators/op-cm-scm.cc
@@ -105,18 +105,18 @@ DEFBINOP_FN (el_mul, complex_matrix, spa
 DEFBINOP_FN (el_div, complex_matrix, sparse_complex_matrix, quotient)
 
 DEFBINOP (el_pow, complex_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&,
                    const octave_sparse_complex_matrix&);
 
   return octave_value
-    (elem_xpow (SparseComplexMatrix (v1.complex_matrix_value ()),
-                v2.sparse_complex_matrix_value ()));
+         (elem_xpow (SparseComplexMatrix (v1.complex_matrix_value ()),
+                     v2.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&,
                    const octave_sparse_complex_matrix&);
 
   return octave_value (quotient (v2.sparse_complex_matrix_value (),
@@ -135,17 +135,17 @@ DEFCATOP (cm_scm, complex_matrix, sparse
                                     ra_idx));
 }
 
 DEFCONV (sparse_complex_matrix_conv, complex_matrix,
          sparse_complex_matrix)
 {
   CAST_CONV_ARG (const octave_complex_matrix&);
   return new octave_sparse_complex_matrix
-    (SparseComplexMatrix (v.complex_matrix_value ()));
+         (SparseComplexMatrix (v.complex_matrix_value ()));
 }
 
 DEFNDASSIGNOP_FN (assign, complex_matrix, sparse_complex_matrix,
                   complex_array, assign)
 
 void
 install_cm_scm_ops (void)
 {
diff --git a/libinterp/operators/op-cm-sm.cc b/libinterp/operators/op-cm-sm.cc
--- a/libinterp/operators/op-cm-sm.cc
+++ b/libinterp/operators/op-cm-sm.cc
@@ -101,26 +101,26 @@ DEFBINOP_FN (el_mul, complex_matrix, spa
 DEFBINOP_FN (el_div, complex_matrix, sparse_matrix, quotient)
 
 DEFBINOP (el_pow, complex_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&,
                    const octave_sparse_matrix&);
 
   return octave_value
-    (elem_xpow ( SparseComplexMatrix (v1.complex_matrix_value ()),
-                 v2.sparse_matrix_value ()));
+         (elem_xpow ( SparseComplexMatrix (v1.complex_matrix_value ()),
+                      v2.sparse_matrix_value ()));
 }
 
 DEFBINOP (el_ldiv, complex_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&,
                    const octave_sparse_matrix&);
   return octave_value
-    (quotient (v2.sparse_matrix_value (), v1.complex_matrix_value ()));
+         (quotient (v2.sparse_matrix_value (), v1.complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, complex_matrix, sparse_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  complex_matrix, sparse_matrix, mx_el_or)
 
 DEFCATOP (cm_sm, complex_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (octave_complex_matrix&, const octave_sparse_matrix&);
diff --git a/libinterp/operators/op-cs-cm.cc b/libinterp/operators/op-cs-cm.cc
--- a/libinterp/operators/op-cs-cm.cc
+++ b/libinterp/operators/op-cs-cm.cc
@@ -63,43 +63,54 @@ DEFBINOP (ldiv, complex, complex_matrix)
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.complex_array_value () / d);
 }
 
-DEFNDCMPLXCMPOP_FN (lt, complex, complex_matrix, complex, complex_array, mx_el_lt)
-DEFNDCMPLXCMPOP_FN (le, complex, complex_matrix, complex, complex_array, mx_el_le)
-DEFNDCMPLXCMPOP_FN (eq, complex, complex_matrix, complex, complex_array, mx_el_eq)
-DEFNDCMPLXCMPOP_FN (ge, complex, complex_matrix, complex, complex_array, mx_el_ge)
-DEFNDCMPLXCMPOP_FN (gt, complex, complex_matrix, complex, complex_array, mx_el_gt)
-DEFNDCMPLXCMPOP_FN (ne, complex, complex_matrix, complex, complex_array, mx_el_ne)
+DEFNDCMPLXCMPOP_FN (lt, complex, complex_matrix, complex, complex_array,
+                    mx_el_lt)
+DEFNDCMPLXCMPOP_FN (le, complex, complex_matrix, complex, complex_array,
+                    mx_el_le)
+DEFNDCMPLXCMPOP_FN (eq, complex, complex_matrix, complex, complex_array,
+                    mx_el_eq)
+DEFNDCMPLXCMPOP_FN (ge, complex, complex_matrix, complex, complex_array,
+                    mx_el_ge)
+DEFNDCMPLXCMPOP_FN (gt, complex, complex_matrix, complex, complex_array,
+                    mx_el_gt)
+DEFNDCMPLXCMPOP_FN (ne, complex, complex_matrix, complex, complex_array,
+                    mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, complex, complex_matrix, complex, complex_array, *)
-DEFNDBINOP_FN (el_div, complex, complex_matrix, complex, complex_array, x_el_div)
-DEFNDBINOP_FN (el_pow, complex, complex_matrix, complex, complex_array, elem_xpow)
+DEFNDBINOP_FN (el_div, complex, complex_matrix, complex, complex_array,
+               x_el_div)
+DEFNDBINOP_FN (el_pow, complex, complex_matrix, complex, complex_array,
+               elem_xpow)
 
 DEFBINOP (el_ldiv, complex, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
   Complex d = v1.complex_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.complex_array_value () / d);
 }
 
-DEFNDBINOP_FN (el_and, complex, complex_matrix, complex, complex_array, mx_el_and)
-DEFNDBINOP_FN (el_or,  complex, complex_matrix, complex, complex_array, mx_el_or)
+DEFNDBINOP_FN (el_and, complex, complex_matrix, complex, complex_array,
+               mx_el_and)
+DEFNDBINOP_FN (el_or,  complex, complex_matrix, complex, complex_array,
+               mx_el_or)
 
-DEFNDCATOP_FN (cs_cm, complex, complex_matrix, complex_array, complex_array, concat)
+DEFNDCATOP_FN (cs_cm, complex, complex_matrix, complex_array, complex_array,
+               concat)
 
 DEFCONV (complex_matrix_conv, complex, complex_matrix)
 {
   CAST_CONV_ARG (const octave_complex&);
 
   return new octave_complex_matrix (v.complex_matrix_value ());
 }
 
@@ -122,12 +133,13 @@ install_cs_cm_ops (void)
   INSTALL_BINOP (op_el_div, octave_complex, octave_complex_matrix, el_div);
   INSTALL_BINOP (op_el_pow, octave_complex, octave_complex_matrix, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_complex, octave_complex_matrix, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_complex, octave_complex_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_complex, octave_complex_matrix, el_or);
 
   INSTALL_CATOP (octave_complex, octave_complex_matrix, cs_cm);
 
-  INSTALL_ASSIGNCONV (octave_complex, octave_complex_matrix, octave_complex_matrix);
+  INSTALL_ASSIGNCONV (octave_complex, octave_complex_matrix,
+                      octave_complex_matrix);
 
   INSTALL_WIDENOP (octave_complex, octave_complex_matrix, complex_matrix_conv);
 }
diff --git a/libinterp/operators/op-cs-cs.cc b/libinterp/operators/op-cs-cs.cc
--- a/libinterp/operators/op-cs-cs.cc
+++ b/libinterp/operators/op-cs-cs.cc
@@ -145,17 +145,19 @@ DEFBINOP (el_or, complex, complex)
 }
 
 DEFNDCATOP_FN (cs_cs, complex, complex, complex_array, complex_array, concat)
 
 CONVDECL (complex_to_float_complex)
 {
   CAST_CONV_ARG (const octave_complex&);
 
-  return new octave_float_complex_matrix (FloatComplexMatrix (1, 1, static_cast<FloatComplex>(v.complex_value ())));
+  return new octave_float_complex_matrix (FloatComplexMatrix (1, 1,
+                                          static_cast<FloatComplex>
+                                            (v.complex_value ())));
 }
 
 void
 install_cs_cs_ops (void)
 {
   INSTALL_UNOP (op_not, octave_complex, not);
   INSTALL_UNOP (op_uplus, octave_complex, uplus);
   INSTALL_UNOP (op_uminus, octave_complex, uminus);
@@ -183,15 +185,17 @@ install_cs_cs_ops (void)
   INSTALL_BINOP (op_el_ldiv, octave_complex, octave_complex, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_complex, octave_complex, el_and);
   INSTALL_BINOP (op_el_or, octave_complex, octave_complex, el_or);
 
   INSTALL_CATOP (octave_complex, octave_complex, cs_cs);
 
   INSTALL_ASSIGNCONV (octave_complex, octave_complex, octave_complex_matrix);
 
-  INSTALL_ASSIGNCONV (octave_complex, octave_null_matrix, octave_complex_matrix);
+  INSTALL_ASSIGNCONV (octave_complex, octave_null_matrix,
+                      octave_complex_matrix);
   INSTALL_ASSIGNCONV (octave_complex, octave_null_str, octave_complex_matrix);
-  INSTALL_ASSIGNCONV (octave_complex, octave_null_sq_str, octave_complex_matrix);
+  INSTALL_ASSIGNCONV (octave_complex, octave_null_sq_str,
+                      octave_complex_matrix);
 
   INSTALL_CONVOP (octave_complex, octave_float_complex_matrix,
                   complex_to_float_complex);
 }
diff --git a/libinterp/operators/op-cs-scm.cc b/libinterp/operators/op-cs-scm.cc
--- a/libinterp/operators/op-cs-scm.cc
+++ b/libinterp/operators/op-cs-scm.cc
@@ -125,17 +125,17 @@ DEFCATOP (cs_scm, complex, sparse_comple
                                     ra_idx));
 }
 
 DEFCONV (sparse_complex_matrix_conv, complex, sparse_complex_matrix)
 {
   CAST_CONV_ARG (const octave_complex&);
 
   return new octave_sparse_complex_matrix
-    (SparseComplexMatrix (v.complex_matrix_value ()));
+         (SparseComplexMatrix (v.complex_matrix_value ()));
 }
 
 void
 install_cs_scm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_complex, octave_sparse_complex_matrix, add);
   INSTALL_BINOP (op_sub, octave_complex, octave_sparse_complex_matrix, sub);
   INSTALL_BINOP (op_mul, octave_complex, octave_sparse_complex_matrix, mul);
diff --git a/libinterp/operators/op-cs-sm.cc b/libinterp/operators/op-cs-sm.cc
--- a/libinterp/operators/op-cs-sm.cc
+++ b/libinterp/operators/op-cs-sm.cc
@@ -127,17 +127,17 @@ DEFCATOP (cs_sm, sparse_matrix, complex)
   return octave_value (tmp. concat (v2.sparse_matrix_value (), ra_idx));
 }
 
 DEFCONV (sparse_matrix_conv, complex, sparse_matrix)
 {
   CAST_CONV_ARG (const octave_complex&);
 
   return new octave_sparse_matrix
-    (SparseMatrix (v.matrix_value ()));
+         (SparseMatrix (v.matrix_value ()));
 }
 
 void
 install_cs_sm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_complex, octave_sparse_matrix, add);
   INSTALL_BINOP (op_sub, octave_complex, octave_sparse_matrix, sub);
   INSTALL_BINOP (op_mul, octave_complex, octave_sparse_matrix, mul);
diff --git a/libinterp/operators/op-dm-dm.cc b/libinterp/operators/op-dm-dm.cc
--- a/libinterp/operators/op-dm-dm.cc
+++ b/libinterp/operators/op-dm-dm.cc
@@ -92,12 +92,13 @@ install_dm_dm_ops (void)
 
   INSTALL_BINOP (op_add, octave_diag_matrix, octave_diag_matrix, add);
   INSTALL_BINOP (op_sub, octave_diag_matrix, octave_diag_matrix, sub);
   INSTALL_BINOP (op_mul, octave_diag_matrix, octave_diag_matrix, mul);
   INSTALL_BINOP (op_div, octave_diag_matrix, octave_diag_matrix, div);
   INSTALL_BINOP (op_ldiv, octave_diag_matrix, octave_diag_matrix, ldiv);
 
   INSTALL_CONVOP (octave_diag_matrix, octave_matrix, diag_matrix_to_matrix);
-  INSTALL_CONVOP (octave_diag_matrix, octave_float_diag_matrix, diag_matrix_to_float_diag_matrix);
+  INSTALL_CONVOP (octave_diag_matrix, octave_float_diag_matrix,
+                  diag_matrix_to_float_diag_matrix);
   INSTALL_ASSIGNCONV (octave_diag_matrix, octave_matrix, octave_matrix);
   INSTALL_WIDENOP (octave_diag_matrix, octave_matrix, diag_matrix_to_matrix);
 }
diff --git a/libinterp/operators/op-dm-scm.cc b/libinterp/operators/op-dm-scm.cc
--- a/libinterp/operators/op-dm-scm.cc
+++ b/libinterp/operators/op-dm-scm.cc
@@ -36,76 +36,82 @@ along with Octave; see the file COPYING.
 #include "ov-cx-sparse.h"
 
 #include "sparse-xdiv.h"
 
 // diagonal matrix by sparse matrix ops
 
 DEFBINOP (mul_dm_scm, diag_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_sparse_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_diag_matrix&,
+                   const octave_sparse_complex_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.diag_matrix_value () * d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
-      SparseComplexMatrix ret = v1.diag_matrix_value () * v2.sparse_complex_matrix_value ();
+      SparseComplexMatrix ret = v1.diag_matrix_value () *
+                                v2.sparse_complex_matrix_value ();
       octave_value out = octave_value (ret);
       typ.mark_as_unsymmetric ();
       out.matrix_type (typ);
       return out;
     }
 }
 
 DEFBINOP (mul_cdm_sm, complex_diag_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_diag_matrix&, const octave_sparse_matrix&);
+  CAST_BINOP_ARGS (const octave_complex_diag_matrix&,
+                   const octave_sparse_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.scalar_value ();
 
       return octave_value (v1.complex_diag_matrix_value () * d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
-      SparseComplexMatrix ret = v1.complex_diag_matrix_value () * v2.sparse_matrix_value ();
+      SparseComplexMatrix ret = v1.complex_diag_matrix_value () *
+                                v2.sparse_matrix_value ();
       octave_value out = octave_value (ret);
       typ.mark_as_unsymmetric ();
       out.matrix_type (typ);
       return out;
     }
 }
 
 DEFBINOP (mul_cdm_scm, complex_diag_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_diag_matrix&, const octave_sparse_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_complex_diag_matrix&,
+                   const octave_sparse_complex_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.complex_diag_matrix_value () * d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
-      SparseComplexMatrix ret = v1.complex_diag_matrix_value () * v2.sparse_complex_matrix_value ();
+      SparseComplexMatrix ret = v1.complex_diag_matrix_value () *
+                                v2.sparse_complex_matrix_value ();
       octave_value out = octave_value (ret);
       typ.mark_as_unsymmetric ();
       out.matrix_type (typ);
       return out;
     }
 }
 
 DEFBINOP (ldiv_dm_scm, diag_matrix, sparse_complex_matrix)
@@ -129,103 +135,110 @@ DEFBINOP (ldiv_cdm_sm, complex_diag_matr
 }
 
 DEFBINOP (ldiv_cdm_scm, complex_diag_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_diag_matrix&,
                    const octave_sparse_complex_matrix&);
 
   MatrixType typ = v2.matrix_type ();
-  return xleftdiv (v1.complex_diag_matrix_value (), v2.sparse_complex_matrix_value (),
+  return xleftdiv (v1.complex_diag_matrix_value (),
+                   v2.sparse_complex_matrix_value (),
                    typ);
 }
 
 DEFBINOP (add_dm_scm, diag_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_sparse_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_diag_matrix&,
+                   const octave_sparse_complex_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.matrix_value () + d);
     }
   else
     return v1.diag_matrix_value () + v2.sparse_complex_matrix_value ();
 }
 
 DEFBINOP (add_cdm_sm, complex_diag_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_diag_matrix&, const octave_sparse_matrix&);
+  CAST_BINOP_ARGS (const octave_complex_diag_matrix&,
+                   const octave_sparse_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.complex_matrix_value () + d);
     }
   else
     return v1.complex_diag_matrix_value () + v2.sparse_matrix_value ();
 }
 
 DEFBINOP (add_cdm_scm, complex_diag_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_diag_matrix&, const octave_sparse_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_complex_diag_matrix&,
+                   const octave_sparse_complex_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.complex_matrix_value () + d);
     }
   else
     return v1.complex_diag_matrix_value () + v2.sparse_complex_matrix_value ();
 }
 
 DEFBINOP (sub_dm_scm, diag_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_diag_matrix&, const octave_sparse_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_diag_matrix&,
+                   const octave_sparse_complex_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.matrix_value () + (-d));
     }
   else
     return v1.diag_matrix_value () - v2.sparse_complex_matrix_value ();
 }
 
 DEFBINOP (sub_cdm_sm, complex_diag_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_diag_matrix&, const octave_sparse_matrix&);
+  CAST_BINOP_ARGS (const octave_complex_diag_matrix&,
+                   const octave_sparse_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.complex_matrix_value () + (-d));
     }
   else
     return v1.complex_diag_matrix_value () - v2.sparse_matrix_value ();
 }
 
 DEFBINOP (sub_cdm_scm, complex_diag_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_complex_diag_matrix&, const octave_sparse_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_complex_diag_matrix&,
+                   const octave_sparse_complex_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.complex_matrix_value () + (-d));
@@ -233,63 +246,68 @@ DEFBINOP (sub_cdm_scm, complex_diag_matr
   else
     return v1.complex_diag_matrix_value () - v2.sparse_complex_matrix_value ();
 }
 
 // sparse matrix by diagonal matrix ops
 
 DEFBINOP (mul_scm_dm, sparse_complex_matrix, diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_diag_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
+                   const octave_diag_matrix&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     // If v1 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v1.complex_value ();
 
       return octave_value (d * v2.diag_matrix_value ());
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
-      SparseComplexMatrix ret = v1.sparse_complex_matrix_value () * v2.diag_matrix_value ();
+      SparseComplexMatrix ret = v1.sparse_complex_matrix_value () *
+                                v2.diag_matrix_value ();
       octave_value out = octave_value (ret);
       typ.mark_as_unsymmetric ();
       out.matrix_type (typ);
       return out;
     }
 }
 
 DEFBINOP (mul_sm_cdm, sparse_matrix, complex_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex_diag_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_matrix&,
+                   const octave_complex_diag_matrix&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     // If v1 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v1.complex_value ();
 
       return octave_value (d * v2.complex_diag_matrix_value ());
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
-      SparseComplexMatrix ret = v1.sparse_matrix_value () * v2.complex_diag_matrix_value ();
+      SparseComplexMatrix ret = v1.sparse_matrix_value () *
+                                v2.complex_diag_matrix_value ();
       octave_value out = octave_value (ret);
       typ.mark_as_unsymmetric ();
       out.matrix_type (typ);
       return out;
     }
 }
 
 DEFBINOP (mul_scm_cdm, sparse_complex_matrix, complex_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex_diag_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
+                   const octave_complex_diag_matrix&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     // If v1 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v1.complex_value ();
 
       return octave_value (d * v2.complex_diag_matrix_value ());
@@ -299,167 +317,180 @@ DEFBINOP (mul_scm_cdm, sparse_complex_ma
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_complex_matrix_value () * d);
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
-      SparseComplexMatrix ret = v1.sparse_complex_matrix_value () * v2.complex_diag_matrix_value ();
+      SparseComplexMatrix ret = v1.sparse_complex_matrix_value () *
+                                v2.complex_diag_matrix_value ();
       octave_value out = octave_value (ret);
       typ.mark_as_unsymmetric ();
       out.matrix_type (typ);
       return out;
     }
 }
 
 DEFBINOP (div_scm_dm, sparse_complex_matrix, diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_diag_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
+                   const octave_diag_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_complex_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
-      return xdiv (v1.sparse_complex_matrix_value (), v2.diag_matrix_value (), typ);
+      return xdiv (v1.sparse_complex_matrix_value (),
+                   v2.diag_matrix_value (), typ);
     }
 }
 
 DEFBINOP (div_sm_cdm, sparse_matrix, complex_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex_diag_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_matrix&,
+                   const octave_complex_diag_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       std::complex<double> d = v2.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
-      return xdiv (v1.sparse_matrix_value (), v2.complex_diag_matrix_value (), typ);
+      return xdiv (v1.sparse_matrix_value (),
+                   v2.complex_diag_matrix_value (), typ);
     }
 }
 
 DEFBINOP (div_scm_cdm, sparse_complex_matrix, complex_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex_diag_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
+                   const octave_complex_diag_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       std::complex<double> d = v2.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_complex_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
-      return xdiv (v1.sparse_complex_matrix_value (), v2.complex_diag_matrix_value (), typ);
+      return xdiv (v1.sparse_complex_matrix_value (),
+                   v2.complex_diag_matrix_value (), typ);
     }
 }
 
 DEFBINOP (add_sm_cdm, sparse_matrix, complex_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex_diag_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_matrix&,
+                   const octave_complex_diag_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_matrix_value () + d);
     }
   else
     return v1.sparse_matrix_value () + v2.complex_diag_matrix_value ();
 }
 
 DEFBINOP (add_scm_dm, sparse_complex_matrix, diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_diag_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
+                   const octave_diag_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.sparse_complex_matrix_value () + d);
     }
   else
     return v1.sparse_complex_matrix_value () + v2.diag_matrix_value ();
 }
 
 DEFBINOP (add_scm_cdm, sparse_complex_matrix, complex_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex_diag_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
+                   const octave_complex_diag_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_complex_matrix_value () + d);
     }
   else
     return v1.sparse_complex_matrix_value () + v2.complex_diag_matrix_value ();
 }
 
 DEFBINOP (sub_sm_cdm, sparse_matrix, complex_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex_diag_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_matrix&,
+                   const octave_complex_diag_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_matrix_value () + (-d));
     }
   else
     return v1.sparse_matrix_value () - v2.complex_diag_matrix_value ();
 }
 
 DEFBINOP (sub_scm_dm, sparse_complex_matrix, diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_diag_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
+                   const octave_diag_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       double d = v2.scalar_value ();
 
       return octave_value (v1.sparse_complex_matrix_value () + (-d));
     }
   else
     return v1.sparse_complex_matrix_value () - v2.diag_matrix_value ();
 }
 
 DEFBINOP (sub_scm_cdm, sparse_complex_matrix, complex_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex_diag_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
+                   const octave_complex_diag_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     // If v2 is a scalar in disguise, return a diagonal matrix rather than
     // a sparse matrix.
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_complex_matrix_value () + (-d));
@@ -470,42 +501,57 @@ DEFBINOP (sub_scm_cdm, sparse_complex_ma
 
 void
 install_dm_scm_ops (void)
 {
   INSTALL_BINOP (op_mul, octave_diag_matrix, octave_sparse_complex_matrix,
                  mul_dm_scm);
   INSTALL_BINOP (op_mul, octave_complex_diag_matrix, octave_sparse_matrix,
                  mul_cdm_sm);
-  INSTALL_BINOP (op_mul, octave_complex_diag_matrix, octave_sparse_complex_matrix,
-                 mul_cdm_scm);
-  INSTALL_BINOP (op_ldiv, octave_diag_matrix, octave_sparse_complex_matrix, ldiv_dm_scm);
-  INSTALL_BINOP (op_ldiv, octave_complex_diag_matrix, octave_sparse_matrix, ldiv_cdm_sm);
-  INSTALL_BINOP (op_ldiv, octave_complex_diag_matrix, octave_sparse_complex_matrix,
-                 ldiv_cdm_scm);
+  INSTALL_BINOP (op_mul, octave_complex_diag_matrix,
+                 octave_sparse_complex_matrix, mul_cdm_scm);
+  INSTALL_BINOP (op_ldiv, octave_diag_matrix, octave_sparse_complex_matrix,
+                 ldiv_dm_scm);
+  INSTALL_BINOP (op_ldiv, octave_complex_diag_matrix, octave_sparse_matrix,
+                 ldiv_cdm_sm);
+  INSTALL_BINOP (op_ldiv, octave_complex_diag_matrix,
+                 octave_sparse_complex_matrix, ldiv_cdm_scm);
 
-  INSTALL_BINOP (op_add, octave_diag_matrix, octave_sparse_complex_matrix, add_dm_scm);
-  INSTALL_BINOP (op_add, octave_complex_diag_matrix, octave_sparse_matrix, add_cdm_sm);
-  INSTALL_BINOP (op_add, octave_complex_diag_matrix, octave_sparse_complex_matrix,
-                 add_cdm_scm);
-  INSTALL_BINOP (op_sub, octave_diag_matrix, octave_sparse_complex_matrix, sub_dm_scm);
-  INSTALL_BINOP (op_sub, octave_complex_diag_matrix, octave_sparse_matrix, sub_cdm_sm);
-  INSTALL_BINOP (op_sub, octave_complex_diag_matrix, octave_sparse_complex_matrix,
-                 sub_cdm_scm);
+  INSTALL_BINOP (op_add, octave_diag_matrix, octave_sparse_complex_matrix,
+                 add_dm_scm);
+  INSTALL_BINOP (op_add, octave_complex_diag_matrix, octave_sparse_matrix,
+                 add_cdm_sm);
+  INSTALL_BINOP (op_add, octave_complex_diag_matrix,
+                 octave_sparse_complex_matrix, add_cdm_scm);
+  INSTALL_BINOP (op_sub, octave_diag_matrix, octave_sparse_complex_matrix,
+                 sub_dm_scm);
+  INSTALL_BINOP (op_sub, octave_complex_diag_matrix, octave_sparse_matrix,
+                 sub_cdm_sm);
+  INSTALL_BINOP (op_sub, octave_complex_diag_matrix,
+                 octave_sparse_complex_matrix, sub_cdm_scm);
 
   INSTALL_BINOP (op_mul, octave_sparse_complex_matrix, octave_diag_matrix,
                  mul_scm_dm);
   INSTALL_BINOP (op_mul, octave_sparse_matrix, octave_complex_diag_matrix,
                  mul_sm_cdm);
-  INSTALL_BINOP (op_mul, octave_sparse_complex_matrix, octave_complex_diag_matrix,
-                 mul_scm_cdm);
+  INSTALL_BINOP (op_mul, octave_sparse_complex_matrix,
+                 octave_complex_diag_matrix, mul_scm_cdm);
 
-  INSTALL_BINOP (op_div, octave_sparse_complex_matrix, octave_diag_matrix, div_scm_dm);
-  INSTALL_BINOP (op_div, octave_sparse_matrix, octave_complex_diag_matrix, div_sm_cdm);
-  INSTALL_BINOP (op_div, octave_sparse_complex_matrix, octave_complex_diag_matrix, div_scm_cdm);
+  INSTALL_BINOP (op_div, octave_sparse_complex_matrix, octave_diag_matrix,
+                 div_scm_dm);
+  INSTALL_BINOP (op_div, octave_sparse_matrix, octave_complex_diag_matrix,
+                 div_sm_cdm);
+  INSTALL_BINOP (op_div, octave_sparse_complex_matrix,
+                 octave_complex_diag_matrix, div_scm_cdm);
 
-  INSTALL_BINOP (op_add, octave_sparse_complex_matrix, octave_diag_matrix, add_scm_dm);
-  INSTALL_BINOP (op_add, octave_sparse_matrix, octave_complex_diag_matrix, add_sm_cdm);
-  INSTALL_BINOP (op_add, octave_sparse_complex_matrix, octave_complex_diag_matrix, add_scm_cdm);
-  INSTALL_BINOP (op_sub, octave_sparse_complex_matrix, octave_diag_matrix, sub_scm_dm);
-  INSTALL_BINOP (op_sub, octave_sparse_matrix, octave_complex_diag_matrix, sub_sm_cdm);
-  INSTALL_BINOP (op_sub, octave_sparse_complex_matrix, octave_complex_diag_matrix, sub_scm_cdm);
+  INSTALL_BINOP (op_add, octave_sparse_complex_matrix, octave_diag_matrix,
+                 add_scm_dm);
+  INSTALL_BINOP (op_add, octave_sparse_matrix, octave_complex_diag_matrix,
+                 add_sm_cdm);
+  INSTALL_BINOP (op_add, octave_sparse_complex_matrix,
+                 octave_complex_diag_matrix, add_scm_cdm);
+  INSTALL_BINOP (op_sub, octave_sparse_complex_matrix, octave_diag_matrix,
+                 sub_scm_dm);
+  INSTALL_BINOP (op_sub, octave_sparse_matrix, octave_complex_diag_matrix,
+                 sub_sm_cdm);
+  INSTALL_BINOP (op_sub, octave_sparse_complex_matrix,
+                 octave_complex_diag_matrix, sub_scm_cdm);
 }
diff --git a/libinterp/operators/op-double-conv.cc b/libinterp/operators/op-double-conv.cc
--- a/libinterp/operators/op-double-conv.cc
+++ b/libinterp/operators/op-double-conv.cc
@@ -79,41 +79,62 @@ DEFDBLCONVFN (range_to_double_matrix, ra
 DEFSTRDBLCONVFN(char_matrix_str_to_double_matrix, char_matrix_str)
 DEFSTRDBLCONVFN(char_matrix_sq_str_to_double_matrix, char_matrix_sq_str)
 
 DEFDBLCONVFN (double_scalar_to_double_matrix, scalar, array)
 
 void
 install_double_conv_ops (void)
 {
-  INSTALL_CONVOP (octave_int8_matrix, octave_matrix, int8_matrix_to_double_matrix);
-  INSTALL_CONVOP (octave_int16_matrix, octave_matrix, int16_matrix_to_double_matrix);
-  INSTALL_CONVOP (octave_int32_matrix, octave_matrix, int32_matrix_to_double_matrix);
-  INSTALL_CONVOP (octave_int64_matrix, octave_matrix, int64_matrix_to_double_matrix);
+  INSTALL_CONVOP (octave_int8_matrix, octave_matrix,
+                  int8_matrix_to_double_matrix);
+  INSTALL_CONVOP (octave_int16_matrix, octave_matrix,
+                  int16_matrix_to_double_matrix);
+  INSTALL_CONVOP (octave_int32_matrix, octave_matrix,
+                  int32_matrix_to_double_matrix);
+  INSTALL_CONVOP (octave_int64_matrix, octave_matrix,
+                  int64_matrix_to_double_matrix);
 
-  INSTALL_CONVOP (octave_uint8_matrix, octave_matrix, uint8_matrix_to_double_matrix);
-  INSTALL_CONVOP (octave_uint16_matrix, octave_matrix, uint16_matrix_to_double_matrix);
-  INSTALL_CONVOP (octave_uint32_matrix, octave_matrix, uint32_matrix_to_double_matrix);
-  INSTALL_CONVOP (octave_uint64_matrix, octave_matrix, uint64_matrix_to_double_matrix);
+  INSTALL_CONVOP (octave_uint8_matrix, octave_matrix,
+                  uint8_matrix_to_double_matrix);
+  INSTALL_CONVOP (octave_uint16_matrix, octave_matrix,
+                  uint16_matrix_to_double_matrix);
+  INSTALL_CONVOP (octave_uint32_matrix, octave_matrix,
+                  uint32_matrix_to_double_matrix);
+  INSTALL_CONVOP (octave_uint64_matrix, octave_matrix,
+                  uint64_matrix_to_double_matrix);
 
-  INSTALL_CONVOP (octave_int8_scalar, octave_matrix, int8_scalar_to_double_matrix);
-  INSTALL_CONVOP (octave_int16_scalar, octave_matrix, int16_scalar_to_double_matrix);
-  INSTALL_CONVOP (octave_int32_scalar, octave_matrix, int32_scalar_to_double_matrix);
-  INSTALL_CONVOP (octave_int64_scalar, octave_matrix, int64_scalar_to_double_matrix);
+  INSTALL_CONVOP (octave_int8_scalar, octave_matrix,
+                  int8_scalar_to_double_matrix);
+  INSTALL_CONVOP (octave_int16_scalar, octave_matrix,
+                  int16_scalar_to_double_matrix);
+  INSTALL_CONVOP (octave_int32_scalar, octave_matrix,
+                  int32_scalar_to_double_matrix);
+  INSTALL_CONVOP (octave_int64_scalar, octave_matrix,
+                  int64_scalar_to_double_matrix);
 
-  INSTALL_CONVOP (octave_uint8_scalar, octave_matrix, uint8_scalar_to_double_matrix);
-  INSTALL_CONVOP (octave_uint16_scalar, octave_matrix, uint16_scalar_to_double_matrix);
-  INSTALL_CONVOP (octave_uint32_scalar, octave_matrix, uint32_scalar_to_double_matrix);
-  INSTALL_CONVOP (octave_uint64_scalar, octave_matrix, uint64_scalar_to_double_matrix);
+  INSTALL_CONVOP (octave_uint8_scalar, octave_matrix,
+                  uint8_scalar_to_double_matrix);
+  INSTALL_CONVOP (octave_uint16_scalar, octave_matrix,
+                  uint16_scalar_to_double_matrix);
+  INSTALL_CONVOP (octave_uint32_scalar, octave_matrix,
+                  uint32_scalar_to_double_matrix);
+  INSTALL_CONVOP (octave_uint64_scalar, octave_matrix,
+                  uint64_scalar_to_double_matrix);
 
-  INSTALL_CONVOP (octave_bool_matrix, octave_matrix, bool_matrix_to_double_matrix);
+  INSTALL_CONVOP (octave_bool_matrix, octave_matrix,
+                  bool_matrix_to_double_matrix);
   INSTALL_CONVOP (octave_bool, octave_matrix, bool_scalar_to_double_matrix);
 
-  INSTALL_CONVOP (octave_sparse_matrix, octave_matrix, sparse_matrix_to_double_matrix);
-  INSTALL_CONVOP (octave_sparse_bool_matrix, octave_matrix, sparse_bool_matrix_to_double_matrix);
+  INSTALL_CONVOP (octave_sparse_matrix, octave_matrix,
+                  sparse_matrix_to_double_matrix);
+  INSTALL_CONVOP (octave_sparse_bool_matrix, octave_matrix,
+                  sparse_bool_matrix_to_double_matrix);
 
   INSTALL_CONVOP (octave_range, octave_matrix, range_to_double_matrix);
 
-  INSTALL_CONVOP (octave_char_matrix_str, octave_matrix, char_matrix_str_to_double_matrix);
-  INSTALL_CONVOP (octave_char_matrix_sq_str, octave_matrix, char_matrix_sq_str_to_double_matrix);
+  INSTALL_CONVOP (octave_char_matrix_str, octave_matrix,
+                  char_matrix_str_to_double_matrix);
+  INSTALL_CONVOP (octave_char_matrix_sq_str, octave_matrix,
+                  char_matrix_sq_str_to_double_matrix);
 
   INSTALL_CONVOP (octave_scalar, octave_matrix, double_scalar_to_double_matrix);
 }
diff --git a/libinterp/operators/op-fcdm-fcdm.cc b/libinterp/operators/op-fcdm-fcdm.cc
--- a/libinterp/operators/op-fcdm-fcdm.cc
+++ b/libinterp/operators/op-fcdm-fcdm.cc
@@ -55,25 +55,27 @@ DEFUNOP (hermitian, float_complex_diag_m
 // matrix by matrix ops.
 
 DEFBINOP_OP (add, float_complex_diag_matrix, float_complex_diag_matrix, +)
 DEFBINOP_OP (sub, float_complex_diag_matrix, float_complex_diag_matrix, -)
 DEFBINOP_OP (mul, float_complex_diag_matrix, float_complex_diag_matrix, *)
 
 DEFBINOP (div, float_complex_diag_matrix, float_complex_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_diag_matrix&, const octave_float_complex_diag_matrix&);
+  CAST_BINOP_ARGS (const octave_float_complex_diag_matrix&,
+                   const octave_float_complex_diag_matrix&);
 
   return xdiv (v1.float_complex_diag_matrix_value (),
                v2.float_complex_diag_matrix_value ());
 }
 
 DEFBINOP (ldiv, float_complex_diag_matrix, float_complex_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_diag_matrix&, const octave_float_complex_diag_matrix&);
+  CAST_BINOP_ARGS (const octave_float_complex_diag_matrix&,
+                   const octave_float_complex_diag_matrix&);
 
   return xleftdiv (v1.float_complex_diag_matrix_value (),
                    v2.float_complex_diag_matrix_value ());
 }
 
 CONVDECL (float_complex_diag_matrix_to_float_complex_matrix)
 {
   CAST_CONV_ARG (const octave_float_complex_diag_matrix&);
@@ -91,22 +93,28 @@ CONVDECL (float_complex_diag_matrix_to_c
 void
 install_fcdm_fcdm_ops (void)
 {
   INSTALL_UNOP (op_uplus, octave_float_complex_diag_matrix, uplus);
   INSTALL_UNOP (op_uminus, octave_float_complex_diag_matrix, uminus);
   INSTALL_UNOP (op_transpose, octave_float_complex_diag_matrix, transpose);
   INSTALL_UNOP (op_hermitian, octave_float_complex_diag_matrix, hermitian);
 
-  INSTALL_BINOP (op_add, octave_float_complex_diag_matrix, octave_float_complex_diag_matrix, add);
-  INSTALL_BINOP (op_sub, octave_float_complex_diag_matrix, octave_float_complex_diag_matrix, sub);
-  INSTALL_BINOP (op_mul, octave_float_complex_diag_matrix, octave_float_complex_diag_matrix, mul);
-  INSTALL_BINOP (op_div, octave_float_complex_diag_matrix, octave_float_complex_diag_matrix, div);
-  INSTALL_BINOP (op_ldiv, octave_float_complex_diag_matrix, octave_float_complex_diag_matrix, ldiv);
+  INSTALL_BINOP (op_add, octave_float_complex_diag_matrix,
+                 octave_float_complex_diag_matrix, add);
+  INSTALL_BINOP (op_sub, octave_float_complex_diag_matrix,
+                 octave_float_complex_diag_matrix, sub);
+  INSTALL_BINOP (op_mul, octave_float_complex_diag_matrix,
+                 octave_float_complex_diag_matrix, mul);
+  INSTALL_BINOP (op_div, octave_float_complex_diag_matrix,
+                 octave_float_complex_diag_matrix, div);
+  INSTALL_BINOP (op_ldiv, octave_float_complex_diag_matrix,
+                 octave_float_complex_diag_matrix, ldiv);
 
   INSTALL_CONVOP (octave_float_complex_diag_matrix, octave_complex_diag_matrix,
                   float_complex_diag_matrix_to_complex_diag_matrix);
   INSTALL_CONVOP (octave_float_complex_diag_matrix, octave_float_complex_matrix,
                   float_complex_diag_matrix_to_float_complex_matrix);
-  INSTALL_ASSIGNCONV (octave_float_complex_diag_matrix, octave_float_complex_matrix, octave_float_complex_matrix);
+  INSTALL_ASSIGNCONV (octave_float_complex_diag_matrix,
+                      octave_float_complex_matrix, octave_float_complex_matrix);
   INSTALL_WIDENOP (octave_float_complex_diag_matrix, octave_complex_diag_matrix,
                    float_complex_diag_matrix_to_complex_diag_matrix);
 }
diff --git a/libinterp/operators/op-fcm-fcm.cc b/libinterp/operators/op-fcm-fcm.cc
--- a/libinterp/operators/op-fcm-fcm.cc
+++ b/libinterp/operators/op-fcm-fcm.cc
@@ -82,17 +82,17 @@ DEFBINOP_OP (mul, float_complex_matrix, 
 
 DEFBINOP (div, float_complex_matrix, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&,
                    const octave_float_complex_matrix&);
   MatrixType typ = v2.matrix_type ();
 
   FloatComplexMatrix ret = xdiv (v1.float_complex_matrix_value (),
-                            v2.float_complex_matrix_value (), typ);
+                                 v2.float_complex_matrix_value (), typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, float_complex_matrix, float_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
@@ -109,98 +109,105 @@ DEFBINOP (ldiv, float_complex_matrix, fl
                                      v2.float_complex_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (trans_mul, float_complex_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&, const octave_float_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
+                   const octave_float_complex_matrix&);
   return octave_value(xgemm (v1.float_complex_matrix_value (),
                              v2.float_complex_matrix_value (),
                              blas_trans, blas_no_trans));
 }
 
 DEFBINOP (mul_trans, float_complex_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&, const octave_float_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
+                   const octave_float_complex_matrix&);
   return octave_value(xgemm (v1.float_complex_matrix_value (),
                              v2.float_complex_matrix_value (),
                              blas_no_trans, blas_trans));
 }
 
 DEFBINOP (herm_mul, float_complex_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&, const octave_float_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
+                   const octave_float_complex_matrix&);
   return octave_value(xgemm (v1.float_complex_matrix_value (),
                              v2.float_complex_matrix_value (),
                              blas_conj_trans, blas_no_trans));
 }
 
 DEFBINOP (mul_herm, float_complex_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&, const octave_float_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
+                   const octave_float_complex_matrix&);
   return octave_value(xgemm (v1.float_complex_matrix_value (),
                              v2.float_complex_matrix_value (),
                              blas_no_trans, blas_conj_trans));
 }
 
 DEFBINOP (trans_ldiv, float_complex_matrix, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&,
                    const octave_float_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (v1.float_complex_matrix_value (),
-                                     v2.float_complex_matrix_value (), typ, blas_trans);
+                                     v2.float_complex_matrix_value (),
+                                     typ, blas_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (herm_ldiv, float_complex_matrix, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&,
                    const octave_float_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (v1.float_complex_matrix_value (),
-                                     v2.float_complex_matrix_value (), typ, blas_conj_trans);
+                                     v2.float_complex_matrix_value (),
+                                     typ, blas_conj_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFNDCMPLXCMPOP_FN (lt, float_complex_matrix, float_complex_matrix,
-               float_complex_array, float_complex_array, mx_el_lt)
+                    float_complex_array, float_complex_array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, float_complex_matrix, float_complex_matrix,
-               float_complex_array, float_complex_array, mx_el_le)
+                    float_complex_array, float_complex_array, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, float_complex_matrix, float_complex_matrix,
-               float_complex_array, float_complex_array, mx_el_eq)
+                    float_complex_array, float_complex_array, mx_el_eq)
 DEFNDCMPLXCMPOP_FN (ge, float_complex_matrix, float_complex_matrix,
-               float_complex_array, float_complex_array, mx_el_ge)
+                    float_complex_array, float_complex_array, mx_el_ge)
 DEFNDCMPLXCMPOP_FN (gt, float_complex_matrix, float_complex_matrix,
-               float_complex_array, float_complex_array, mx_el_gt)
+                    float_complex_array, float_complex_array, mx_el_gt)
 DEFNDCMPLXCMPOP_FN (ne, float_complex_matrix, float_complex_matrix,
-               float_complex_array, float_complex_array, mx_el_ne)
+                    float_complex_array, float_complex_array, mx_el_ne)
 
 DEFNDBINOP_FN (el_mul, float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, product)
 DEFNDBINOP_FN (el_div, float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, quotient)
 DEFNDBINOP_FN (el_pow, float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex_matrix, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&,
                    const octave_float_complex_matrix&);
 
-  return octave_value (quotient (v2.float_complex_array_value (), v1.float_complex_array_value ()));
+  return octave_value (quotient (v2.float_complex_array_value (),
+                                 v1.float_complex_array_value ()));
 }
 
 DEFNDBINOP_FN (el_and, float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_complex_matrix, float_complex_matrix,
                float_complex_array, float_complex_array, mx_el_or)
 
 DEFNDCATOP_FN (fcm_fcm, float_complex_matrix, float_complex_matrix,
@@ -229,17 +236,18 @@ DEFNDASSIGNOP_FNOP (assign_el_mul, float
                     float_complex_array, product_eq)
 DEFNDASSIGNOP_FNOP (assign_el_div, float_complex_matrix, float_complex_matrix,
                     float_complex_array, quotient_eq)
 
 CONVDECL (float_complex_matrix_to_complex_matrix)
 {
   CAST_CONV_ARG (const octave_float_complex_matrix&);
 
-  return new octave_complex_matrix (ComplexNDArray (v.float_complex_array_value ()));
+  return
+    new octave_complex_matrix (ComplexNDArray (v.float_complex_array_value ()));
 }
 
 void
 install_fcm_fcm_ops (void)
 {
   INSTALL_UNOP (op_not, octave_float_complex_matrix, not);
   INSTALL_UNOP (op_uplus, octave_float_complex_matrix, uplus);
   INSTALL_UNOP (op_uminus, octave_float_complex_matrix, uminus);
diff --git a/libinterp/operators/op-fcm-fcs.cc b/libinterp/operators/op-fcm-fcs.cc
--- a/libinterp/operators/op-fcm-fcs.cc
+++ b/libinterp/operators/op-fcm-fcs.cc
@@ -70,27 +70,27 @@ DEFBINOP (ldiv, float_complex_matrix, fl
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (m1, m2, typ);
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFNDCMPLXCMPOP_FN (lt, float_complex_matrix, float_complex,
-               float_complex_array, float_complex, mx_el_lt)
+                    float_complex_array, float_complex, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, float_complex_matrix, float_complex,
-               float_complex_array, float_complex, mx_el_le)
+                    float_complex_array, float_complex, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, float_complex_matrix, float_complex,
-               float_complex_array, float_complex, mx_el_eq)
+                    float_complex_array, float_complex, mx_el_eq)
 DEFNDCMPLXCMPOP_FN (ge, float_complex_matrix, float_complex,
-               float_complex_array, float_complex, mx_el_ge)
+                    float_complex_array, float_complex, mx_el_ge)
 DEFNDCMPLXCMPOP_FN (gt, float_complex_matrix, float_complex,
-               float_complex_array, float_complex, mx_el_gt)
+                    float_complex_array, float_complex, mx_el_gt)
 DEFNDCMPLXCMPOP_FN (ne, float_complex_matrix, float_complex,
-               float_complex_array, float_complex, mx_el_ne)
+                    float_complex_array, float_complex, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, float_complex_matrix, float_complex,
                float_complex_array, float_complex, *)
 
 DEFBINOP (el_div, float_complex_matrix, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&,
                    const octave_float_complex&);
diff --git a/libinterp/operators/op-fcm-fm.cc b/libinterp/operators/op-fcm-fm.cc
--- a/libinterp/operators/op-fcm-fm.cc
+++ b/libinterp/operators/op-fcm-fm.cc
@@ -38,24 +38,27 @@ along with Octave; see the file COPYING.
 #include "ov-re-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // complex matrix by matrix ops.
 
-DEFNDBINOP_OP (add, float_complex_matrix, float_matrix, float_complex_array, float_array, +)
-DEFNDBINOP_OP (sub, float_complex_matrix, float_matrix, float_complex_array, float_array, -)
+DEFNDBINOP_OP (add, float_complex_matrix, float_matrix, float_complex_array,
+               float_array, +)
+DEFNDBINOP_OP (sub, float_complex_matrix, float_matrix, float_complex_array,
+               float_array, -)
 
 DEFBINOP_OP (mul, float_complex_matrix, float_matrix, *)
 
 DEFBINOP (mul_trans, float_complex_matrix, float_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&, const octave_float_matrix&);
+  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
+                   const octave_float_matrix&);
 
   FloatComplexMatrix m1 = v1.float_complex_matrix_value ();
   FloatMatrix m2 = v2.float_matrix_value ();
 
   return FloatComplexMatrix (xgemm (real (m1), m2, blas_no_trans, blas_trans),
                              xgemm (imag (m1), m2, blas_no_trans, blas_trans));
 }
 
@@ -88,27 +91,27 @@ DEFBINOP (ldiv, float_complex_matrix, fl
   FloatComplexMatrix ret = xleftdiv (v1.float_complex_matrix_value (),
                                      v2.float_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFNDCMPLXCMPOP_FN (lt, float_complex_matrix, float_matrix,
-               float_complex_array, float_array, mx_el_lt)
+                    float_complex_array, float_array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, float_complex_matrix, float_matrix,
-               float_complex_array, float_array, mx_el_le)
+                    float_complex_array, float_array, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, float_complex_matrix, float_matrix,
-               float_complex_array, float_array, mx_el_eq)
+                    float_complex_array, float_array, mx_el_eq)
 DEFNDCMPLXCMPOP_FN (ge, float_complex_matrix, float_matrix,
-               float_complex_array, float_array, mx_el_ge)
+                    float_complex_array, float_array, mx_el_ge)
 DEFNDCMPLXCMPOP_FN (gt, float_complex_matrix, float_matrix,
-               float_complex_array, float_array, mx_el_gt)
+                    float_complex_array, float_array, mx_el_gt)
 DEFNDCMPLXCMPOP_FN (ne, float_complex_matrix, float_matrix,
-               float_complex_array, float_array, mx_el_ne)
+                    float_complex_array, float_array, mx_el_ne)
 
 DEFNDBINOP_FN (el_mul, float_complex_matrix, float_matrix,
                float_complex_array, float_array, product)
 DEFNDBINOP_FN (el_div, float_complex_matrix, float_matrix,
                float_complex_array, float_array, quotient)
 DEFNDBINOP_FN (el_pow, float_complex_matrix, float_matrix,
                float_complex_array, float_array, elem_xpow)
 
diff --git a/libinterp/operators/op-fcm-fs.cc b/libinterp/operators/op-fcm-fs.cc
--- a/libinterp/operators/op-fcm-fs.cc
+++ b/libinterp/operators/op-fcm-fs.cc
@@ -37,82 +37,89 @@ along with Octave; see the file COPYING.
 #include "ov-scalar.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // complex matrix by scalar ops.
 
-DEFNDBINOP_OP (add, float_complex_matrix, float_scalar, float_complex_array, float_scalar, +)
-DEFNDBINOP_OP (sub, float_complex_matrix, float_scalar, float_complex_array, float_scalar, -)
-DEFNDBINOP_OP (mul, float_complex_matrix, float_scalar, float_complex_array, float_scalar, *)
+DEFNDBINOP_OP (add, float_complex_matrix, float_scalar, float_complex_array,
+               float_scalar, +)
+DEFNDBINOP_OP (sub, float_complex_matrix, float_scalar, float_complex_array,
+               float_scalar, -)
+DEFNDBINOP_OP (mul, float_complex_matrix, float_scalar, float_complex_array,
+               float_scalar, *)
 
 DEFBINOP (div, float_complex_matrix, float)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&, const octave_float_scalar&);
+  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
+                   const octave_float_scalar&);
 
   float d = v2.float_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v1.float_complex_array_value () / d);
 }
 
 DEFBINOP_FN (pow, float_complex_matrix, float_scalar, xpow)
 
 DEFBINOP (ldiv, float_complex_matrix, float)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&, const octave_float_scalar&);
+  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
+                   const octave_float_scalar&);
 
   FloatComplexMatrix m1 = v1.float_complex_matrix_value ();
   FloatMatrix m2 = v2.float_matrix_value ();
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (m1, m2, typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFNDCMPLXCMPOP_FN (lt, float_complex_matrix, float_scalar, float_complex_array,
-               float_scalar, mx_el_lt)
+                    float_scalar, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, float_complex_matrix, float_scalar, float_complex_array,
-               float_scalar, mx_el_le)
+                    float_scalar, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, float_complex_matrix, float_scalar, float_complex_array,
-               float_scalar, mx_el_eq)
+                    float_scalar, mx_el_eq)
 DEFNDCMPLXCMPOP_FN (ge, float_complex_matrix, float_scalar, float_complex_array,
-               float_scalar, mx_el_ge)
+                    float_scalar, mx_el_ge)
 DEFNDCMPLXCMPOP_FN (gt, float_complex_matrix, float_scalar, float_complex_array,
-               float_scalar, mx_el_gt)
+                    float_scalar, mx_el_gt)
 DEFNDCMPLXCMPOP_FN (ne, float_complex_matrix, float_scalar, float_complex_array,
-               float_scalar, mx_el_ne)
+                    float_scalar, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, *)
 
 DEFBINOP (el_div, float_complex_matrix, float)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&, const octave_float_scalar&);
+  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
+                   const octave_float_scalar&);
 
   float d = v2.float_value ();
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v1.float_complex_array_value () / d);
 }
 
 DEFNDBINOP_FN (el_pow, float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex_matrix, float)
 {
-  CAST_BINOP_ARGS (const octave_float_complex_matrix&, const octave_float_scalar&);
+  CAST_BINOP_ARGS (const octave_float_complex_matrix&,
+                   const octave_float_scalar&);
 
   return x_el_div (v2.float_value (), v1.float_complex_array_value ());
 }
 
 DEFNDBINOP_FN (el_and, float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, mx_el_and)
 DEFNDBINOP_FN (el_or,  float_complex_matrix, float_scalar, float_complex_array,
                float_scalar, mx_el_or)
@@ -121,45 +128,54 @@ DEFNDCATOP_FN (fcm_fs, float_complex_mat
                float_array, concat)
 
 DEFNDCATOP_FN (cm_fs, complex_matrix, float_scalar, float_complex_array,
                float_array, concat)
 
 DEFNDCATOP_FN (fcm_s, float_complex_matrix, scalar, float_complex_array,
                float_array, concat)
 
-DEFNDASSIGNOP_FN (assign, float_complex_matrix, float_scalar, float_complex_array, assign)
-DEFNDASSIGNOP_FN (dbl_assign, complex_matrix, float_scalar, complex_array, assign)
+DEFNDASSIGNOP_FN (assign, float_complex_matrix, float_scalar,
+                  float_complex_array, assign)
+DEFNDASSIGNOP_FN (dbl_assign, complex_matrix, float_scalar, complex_array,
+                  assign)
 
 DEFNDASSIGNOP_OP (assign_mul, float_complex_matrix, float_scalar,
                   float_scalar, *=)
 DEFNDASSIGNOP_OP (assign_div, float_complex_matrix, float_scalar,
                   float_scalar, /=)
 
 void
 install_fcm_fs_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_complex_matrix, octave_float_scalar, add);
   INSTALL_BINOP (op_sub, octave_float_complex_matrix, octave_float_scalar, sub);
   INSTALL_BINOP (op_mul, octave_float_complex_matrix, octave_float_scalar, mul);
   INSTALL_BINOP (op_div, octave_float_complex_matrix, octave_float_scalar, div);
   INSTALL_BINOP (op_pow, octave_float_complex_matrix, octave_float_scalar, pow);
-  INSTALL_BINOP (op_ldiv, octave_float_complex_matrix, octave_float_scalar, ldiv);
+  INSTALL_BINOP (op_ldiv, octave_float_complex_matrix, octave_float_scalar,
+                 ldiv);
   INSTALL_BINOP (op_lt, octave_float_complex_matrix, octave_float_scalar, lt);
   INSTALL_BINOP (op_le, octave_float_complex_matrix, octave_float_scalar, le);
   INSTALL_BINOP (op_eq, octave_float_complex_matrix, octave_float_scalar, eq);
   INSTALL_BINOP (op_ge, octave_float_complex_matrix, octave_float_scalar, ge);
   INSTALL_BINOP (op_gt, octave_float_complex_matrix, octave_float_scalar, gt);
   INSTALL_BINOP (op_ne, octave_float_complex_matrix, octave_float_scalar, ne);
-  INSTALL_BINOP (op_el_mul, octave_float_complex_matrix, octave_float_scalar, el_mul);
-  INSTALL_BINOP (op_el_div, octave_float_complex_matrix, octave_float_scalar, el_div);
-  INSTALL_BINOP (op_el_pow, octave_float_complex_matrix, octave_float_scalar, el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_float_complex_matrix, octave_float_scalar, el_ldiv);
-  INSTALL_BINOP (op_el_and, octave_float_complex_matrix, octave_float_scalar, el_and);
-  INSTALL_BINOP (op_el_or, octave_float_complex_matrix, octave_float_scalar, el_or);
+  INSTALL_BINOP (op_el_mul, octave_float_complex_matrix, octave_float_scalar,
+                 el_mul);
+  INSTALL_BINOP (op_el_div, octave_float_complex_matrix, octave_float_scalar,
+                 el_div);
+  INSTALL_BINOP (op_el_pow, octave_float_complex_matrix, octave_float_scalar,
+                 el_pow);
+  INSTALL_BINOP (op_el_ldiv, octave_float_complex_matrix, octave_float_scalar,
+                 el_ldiv);
+  INSTALL_BINOP (op_el_and, octave_float_complex_matrix, octave_float_scalar,
+                 el_and);
+  INSTALL_BINOP (op_el_or, octave_float_complex_matrix, octave_float_scalar,
+                 el_or);
 
   INSTALL_CATOP (octave_float_complex_matrix, octave_float_scalar, fcm_fs);
   INSTALL_CATOP (octave_complex_matrix, octave_float_scalar, cm_fs);
   INSTALL_CATOP (octave_float_complex_matrix, octave_scalar, fcm_s);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix,
                     octave_float_scalar, assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_complex_matrix,
diff --git a/libinterp/operators/op-fcs-fcm.cc b/libinterp/operators/op-fcs-fcm.cc
--- a/libinterp/operators/op-fcs-fcm.cc
+++ b/libinterp/operators/op-fcs-fcm.cc
@@ -33,120 +33,146 @@ along with Octave; see the file COPYING.
 #include "ov-flt-cx-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
 #include "xpow.h"
 
 // complex scalar by complex matrix ops.
 
-DEFNDBINOP_OP (add, float_complex, float_complex_matrix, float_complex, float_complex_array, +)
-DEFNDBINOP_OP (sub, float_complex, float_complex_matrix, float_complex, float_complex_array, -)
-DEFNDBINOP_OP (mul, float_complex, float_complex_matrix, float_complex, float_complex_array, *)
+DEFNDBINOP_OP (add, float_complex, float_complex_matrix, float_complex,
+               float_complex_array, +)
+DEFNDBINOP_OP (sub, float_complex, float_complex_matrix, float_complex,
+               float_complex_array, -)
+DEFNDBINOP_OP (mul, float_complex, float_complex_matrix, float_complex,
+               float_complex_array, *)
 
 DEFBINOP (div, float_complex, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_float_complex&,
+                   const octave_float_complex_matrix&);
 
   FloatComplexMatrix m1 = v1.float_complex_matrix_value ();
   FloatComplexMatrix m2 = v2.float_complex_matrix_value ();
   MatrixType typ = v2.matrix_type ();
 
   FloatComplexMatrix ret = xdiv (m1, m2, typ);
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP_FN (pow, float_complex, float_complex_matrix, xpow)
 
 DEFBINOP (ldiv, float_complex, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_float_complex&,
+                   const octave_float_complex_matrix&);
 
   FloatComplex d = v1.float_complex_value ();
 
   if (d == static_cast<float>(0.0))
     gripe_divide_by_zero ();
 
   return octave_value (v2.float_complex_array_value () / d);
 }
 
 DEFNDCMPLXCMPOP_FN (lt, float_complex, float_complex_matrix, float_complex,
-               float_complex_array, mx_el_lt)
+                    float_complex_array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, float_complex, float_complex_matrix, float_complex,
-               float_complex_array, mx_el_le)
+                    float_complex_array, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, float_complex, float_complex_matrix, float_complex,
-               float_complex_array, mx_el_eq)
+                    float_complex_array, mx_el_eq)
 DEFNDCMPLXCMPOP_FN (ge, float_complex, float_complex_matrix, float_complex,
-               float_complex_array, mx_el_ge)
+                    float_complex_array, mx_el_ge)
 DEFNDCMPLXCMPOP_FN (gt, float_complex, float_complex_matrix, float_complex,
-               float_complex_array, mx_el_gt)
+                    float_complex_array, mx_el_gt)
 DEFNDCMPLXCMPOP_FN (ne, float_complex, float_complex_matrix, float_complex,
-               float_complex_array, mx_el_ne)
+                    float_complex_array, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, float_complex, float_complex_matrix, float_complex,
                float_complex_array, *)
 DEFNDBINOP_FN (el_div, float_complex, float_complex_matrix, float_complex,
                float_complex_array, x_el_div)
 DEFNDBINOP_FN (el_pow, float_complex, float_complex_matrix, float_complex,
                float_complex_array, elem_xpow)
 
 DEFBINOP (el_ldiv, float_complex, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_complex&, const octave_float_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_float_complex&,
+                   const octave_float_complex_matrix&);
 
   FloatComplex d = v1.float_complex_value ();
 
   if (d == static_cast<float>(0.0))
     gripe_divide_by_zero ();
 
   return octave_value (v2.float_complex_array_value () / d);
 }
 
-DEFNDBINOP_FN (el_and, float_complex, float_complex_matrix, float_complex, float_complex_array, mx_el_and)
-DEFNDBINOP_FN (el_or,  float_complex, float_complex_matrix, float_complex, float_complex_array, mx_el_or)
+DEFNDBINOP_FN (el_and, float_complex, float_complex_matrix, float_complex,
+               float_complex_array, mx_el_and)
+DEFNDBINOP_FN (el_or,  float_complex, float_complex_matrix, float_complex,
+               float_complex_array, mx_el_or)
 
-DEFNDCATOP_FN (fcs_fcm, float_complex, float_complex_matrix, float_complex_array, float_complex_array, concat)
+DEFNDCATOP_FN (fcs_fcm, float_complex, float_complex_matrix,
+               float_complex_array, float_complex_array, concat)
 
-DEFNDCATOP_FN (cs_fcm, complex, float_complex_matrix, float_complex_array, float_complex_array, concat)
+DEFNDCATOP_FN (cs_fcm, complex, float_complex_matrix, float_complex_array,
+               float_complex_array, concat)
 
-DEFNDCATOP_FN (fcs_cm, float_complex, complex_matrix, float_complex_array, float_complex_array, concat)
+DEFNDCATOP_FN (fcs_cm, float_complex, complex_matrix, float_complex_array,
+               float_complex_array, concat)
 
 DEFCONV (float_complex_matrix_conv, float_complex, float_complex_matrix)
 {
   CAST_CONV_ARG (const octave_float_complex&);
 
   return new octave_float_complex_matrix (v.float_complex_matrix_value ());
 }
 
 void
 install_fcs_fcm_ops (void)
 {
-  INSTALL_BINOP (op_add, octave_float_complex, octave_float_complex_matrix, add);
-  INSTALL_BINOP (op_sub, octave_float_complex, octave_float_complex_matrix, sub);
-  INSTALL_BINOP (op_mul, octave_float_complex, octave_float_complex_matrix, mul);
-  INSTALL_BINOP (op_div, octave_float_complex, octave_float_complex_matrix, div);
-  INSTALL_BINOP (op_pow, octave_float_complex, octave_float_complex_matrix, pow);
-  INSTALL_BINOP (op_ldiv, octave_float_complex, octave_float_complex_matrix, ldiv);
+  INSTALL_BINOP (op_add, octave_float_complex, octave_float_complex_matrix,
+                 add);
+  INSTALL_BINOP (op_sub, octave_float_complex, octave_float_complex_matrix,
+                 sub);
+  INSTALL_BINOP (op_mul, octave_float_complex, octave_float_complex_matrix,
+                 mul);
+  INSTALL_BINOP (op_div, octave_float_complex, octave_float_complex_matrix,
+                 div);
+  INSTALL_BINOP (op_pow, octave_float_complex, octave_float_complex_matrix,
+                 pow);
+  INSTALL_BINOP (op_ldiv, octave_float_complex, octave_float_complex_matrix,
+                 ldiv);
   INSTALL_BINOP (op_lt, octave_float_complex, octave_float_complex_matrix, lt);
   INSTALL_BINOP (op_le, octave_float_complex, octave_float_complex_matrix, le);
   INSTALL_BINOP (op_eq, octave_float_complex, octave_float_complex_matrix, eq);
   INSTALL_BINOP (op_ge, octave_float_complex, octave_float_complex_matrix, ge);
   INSTALL_BINOP (op_gt, octave_float_complex, octave_float_complex_matrix, gt);
   INSTALL_BINOP (op_ne, octave_float_complex, octave_float_complex_matrix, ne);
-  INSTALL_BINOP (op_el_mul, octave_float_complex, octave_float_complex_matrix, el_mul);
-  INSTALL_BINOP (op_el_div, octave_float_complex, octave_float_complex_matrix, el_div);
-  INSTALL_BINOP (op_el_pow, octave_float_complex, octave_float_complex_matrix, el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_float_complex, octave_float_complex_matrix, el_ldiv);
-  INSTALL_BINOP (op_el_and, octave_float_complex, octave_float_complex_matrix, el_and);
-  INSTALL_BINOP (op_el_or, octave_float_complex, octave_float_complex_matrix, el_or);
+  INSTALL_BINOP (op_el_mul, octave_float_complex, octave_float_complex_matrix,
+                 el_mul);
+  INSTALL_BINOP (op_el_div, octave_float_complex, octave_float_complex_matrix,
+                 el_div);
+  INSTALL_BINOP (op_el_pow, octave_float_complex, octave_float_complex_matrix,
+                 el_pow);
+  INSTALL_BINOP (op_el_ldiv, octave_float_complex, octave_float_complex_matrix,
+                 el_ldiv);
+  INSTALL_BINOP (op_el_and, octave_float_complex, octave_float_complex_matrix,
+                 el_and);
+  INSTALL_BINOP (op_el_or, octave_float_complex, octave_float_complex_matrix,
+                 el_or);
 
   INSTALL_CATOP (octave_float_complex, octave_float_complex_matrix, fcs_fcm);
   INSTALL_CATOP (octave_complex, octave_float_complex_matrix, cs_fcm);
   INSTALL_CATOP (octave_float_complex, octave_complex_matrix, fcs_cm);
 
-  INSTALL_ASSIGNCONV (octave_float_complex, octave_float_complex_matrix, octave_float_complex_matrix);
+  INSTALL_ASSIGNCONV (octave_float_complex, octave_float_complex_matrix,
+                      octave_float_complex_matrix);
 
-  INSTALL_ASSIGNCONV (octave_complex, octave_float_complex_matrix, octave_complex_matrix);
+  INSTALL_ASSIGNCONV (octave_complex, octave_float_complex_matrix,
+                      octave_complex_matrix);
 
-  INSTALL_WIDENOP (octave_float_complex, octave_float_complex_matrix, float_complex_matrix_conv);
+  INSTALL_WIDENOP (octave_float_complex, octave_float_complex_matrix,
+                   float_complex_matrix_conv);
 }
diff --git a/libinterp/operators/op-fcs-fcs.cc b/libinterp/operators/op-fcs-fcs.cc
--- a/libinterp/operators/op-fcs-fcs.cc
+++ b/libinterp/operators/op-fcs-fcs.cc
@@ -152,17 +152,19 @@ DEFNDCATOP_FN (cs_fcs, complex, float_co
 
 DEFNDCATOP_FN (fcs_cs, float_complex, complex, float_complex_array,
                float_complex_array, concat)
 
 CONVDECL (float_complex_to_complex)
 {
   CAST_CONV_ARG (const octave_float_complex&);
 
-  return new octave_complex_matrix (ComplexMatrix (1, 1, static_cast<Complex>(v.float_complex_value ())));
+  return new octave_complex_matrix
+               (ComplexMatrix (1, 1,
+                               static_cast<Complex>(v.float_complex_value ())));
 }
 
 void
 install_fcs_fcs_ops (void)
 {
   INSTALL_UNOP (op_not, octave_float_complex, not);
   INSTALL_UNOP (op_uplus, octave_float_complex, uplus);
   INSTALL_UNOP (op_uminus, octave_float_complex, uminus);
@@ -182,27 +184,33 @@ install_fcs_fcs_ops (void)
   INSTALL_BINOP (op_le, octave_float_complex, octave_float_complex, le);
   INSTALL_BINOP (op_eq, octave_float_complex, octave_float_complex, eq);
   INSTALL_BINOP (op_ge, octave_float_complex, octave_float_complex, ge);
   INSTALL_BINOP (op_gt, octave_float_complex, octave_float_complex, gt);
   INSTALL_BINOP (op_ne, octave_float_complex, octave_float_complex, ne);
   INSTALL_BINOP (op_el_mul, octave_float_complex, octave_float_complex, el_mul);
   INSTALL_BINOP (op_el_div, octave_float_complex, octave_float_complex, el_div);
   INSTALL_BINOP (op_el_pow, octave_float_complex, octave_float_complex, el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_float_complex, octave_float_complex, el_ldiv);
+  INSTALL_BINOP (op_el_ldiv, octave_float_complex, octave_float_complex,
+                 el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_complex, octave_float_complex, el_and);
   INSTALL_BINOP (op_el_or, octave_float_complex, octave_float_complex, el_or);
 
   INSTALL_CATOP (octave_float_complex, octave_float_complex, fcs_fcs);
   INSTALL_CATOP (octave_complex, octave_float_complex, cs_fcs);
   INSTALL_CATOP (octave_float_complex, octave_complex, fcs_cs);
 
-  INSTALL_ASSIGNCONV (octave_float_complex, octave_float_complex, octave_float_complex_matrix);
+  INSTALL_ASSIGNCONV (octave_float_complex, octave_float_complex,
+                      octave_float_complex_matrix);
 
-  INSTALL_ASSIGNCONV (octave_complex, octave_float_complex, octave_complex_matrix);
+  INSTALL_ASSIGNCONV (octave_complex, octave_float_complex,
+                      octave_complex_matrix);
 
-  INSTALL_ASSIGNCONV (octave_float_complex, octave_null_matrix, octave_float_complex_matrix);
-  INSTALL_ASSIGNCONV (octave_float_complex, octave_null_str, octave_float_complex_matrix);
-  INSTALL_ASSIGNCONV (octave_float_complex, octave_null_sq_str, octave_float_complex_matrix);
+  INSTALL_ASSIGNCONV (octave_float_complex, octave_null_matrix,
+                      octave_float_complex_matrix);
+  INSTALL_ASSIGNCONV (octave_float_complex, octave_null_str,
+                      octave_float_complex_matrix);
+  INSTALL_ASSIGNCONV (octave_float_complex, octave_null_sq_str,
+                      octave_float_complex_matrix);
 
   INSTALL_CONVOP (octave_float_complex, octave_complex_matrix,
                   float_complex_to_complex);
 }
diff --git a/libinterp/operators/op-fcs-fm.cc b/libinterp/operators/op-fcs-fm.cc
--- a/libinterp/operators/op-fcs-fm.cc
+++ b/libinterp/operators/op-fcs-fm.cc
@@ -73,27 +73,27 @@ DEFBINOP (ldiv, float_complex, float_mat
 
   if (d == static_cast<float>(0.0))
     gripe_divide_by_zero ();
 
   return octave_value (v2.float_array_value () / d);
 }
 
 DEFNDCMPLXCMPOP_FN (lt, float_complex, float_matrix, float_complex,
-               float_array, mx_el_lt)
+                    float_array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, float_complex, float_matrix, float_complex,
-               float_array, mx_el_le)
+                    float_array, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, float_complex, float_matrix, float_complex,
-               float_array, mx_el_eq)
+                    float_array, mx_el_eq)
 DEFNDCMPLXCMPOP_FN (ge, float_complex, float_matrix, float_complex,
-               float_array, mx_el_ge)
+                    float_array, mx_el_ge)
 DEFNDCMPLXCMPOP_FN (gt, float_complex, float_matrix, float_complex,
-               float_array, mx_el_gt)
+                    float_array, mx_el_gt)
 DEFNDCMPLXCMPOP_FN (ne, float_complex, float_matrix, float_complex,
-               float_array, mx_el_ne)
+                    float_array, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, float_complex, float_matrix, float_complex,
                float_array, *)
 DEFNDBINOP_FN (el_div, float_complex, float_matrix, float_complex,
                float_array, x_el_div)
 DEFNDBINOP_FN (el_pow, float_complex, float_matrix, float_complex,
                float_array, elem_xpow)
 
@@ -136,17 +136,18 @@ install_fcs_fm_ops (void)
   INSTALL_BINOP (op_le, octave_float_complex, octave_float_matrix, le);
   INSTALL_BINOP (op_eq, octave_float_complex, octave_float_matrix, eq);
   INSTALL_BINOP (op_ge, octave_float_complex, octave_float_matrix, ge);
   INSTALL_BINOP (op_gt, octave_float_complex, octave_float_matrix, gt);
   INSTALL_BINOP (op_ne, octave_float_complex, octave_float_matrix, ne);
   INSTALL_BINOP (op_el_mul, octave_float_complex, octave_float_matrix, el_mul);
   INSTALL_BINOP (op_el_div, octave_float_complex, octave_float_matrix, el_div);
   INSTALL_BINOP (op_el_pow, octave_float_complex, octave_float_matrix, el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_float_complex, octave_float_matrix, el_ldiv);
+  INSTALL_BINOP (op_el_ldiv, octave_float_complex, octave_float_matrix,
+                 el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_complex, octave_float_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_float_complex, octave_float_matrix, el_or);
 
   INSTALL_CATOP (octave_float_complex, octave_float_matrix, fcs_fm);
   INSTALL_CATOP (octave_complex, octave_float_matrix, cs_fm);
   INSTALL_CATOP (octave_float_complex, octave_matrix, fcs_m);
 
   INSTALL_ASSIGNCONV (octave_float_complex, octave_float_matrix,
diff --git a/libinterp/operators/op-fcs-fs.cc b/libinterp/operators/op-fcs-fs.cc
--- a/libinterp/operators/op-fcs-fs.cc
+++ b/libinterp/operators/op-fcs-fs.cc
@@ -143,17 +143,18 @@ install_fcs_fs_ops (void)
   INSTALL_BINOP (op_le, octave_float_complex, octave_float_scalar, le);
   INSTALL_BINOP (op_eq, octave_float_complex, octave_float_scalar, eq);
   INSTALL_BINOP (op_ge, octave_float_complex, octave_float_scalar, ge);
   INSTALL_BINOP (op_gt, octave_float_complex, octave_float_scalar, gt);
   INSTALL_BINOP (op_ne, octave_float_complex, octave_float_scalar, ne);
   INSTALL_BINOP (op_el_mul, octave_float_complex, octave_float_scalar, el_mul);
   INSTALL_BINOP (op_el_div, octave_float_complex, octave_float_scalar, el_div);
   INSTALL_BINOP (op_el_pow, octave_float_complex, octave_float_scalar, el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_float_complex, octave_float_scalar, el_ldiv);
+  INSTALL_BINOP (op_el_ldiv, octave_float_complex, octave_float_scalar,
+                 el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_complex, octave_float_scalar, el_and);
   INSTALL_BINOP (op_el_or, octave_float_complex, octave_float_scalar, el_or);
 
   INSTALL_CATOP (octave_float_complex, octave_float_scalar, fcs_fs);
   INSTALL_CATOP (octave_complex, octave_float_scalar, cs_fs);
   INSTALL_CATOP (octave_float_complex, octave_scalar, fcs_s);
 
   INSTALL_ASSIGNCONV (octave_float_complex, octave_float_scalar,
diff --git a/libinterp/operators/op-fdm-fdm.cc b/libinterp/operators/op-fdm-fdm.cc
--- a/libinterp/operators/op-fdm-fdm.cc
+++ b/libinterp/operators/op-fdm-fdm.cc
@@ -49,25 +49,27 @@ DEFUNOP (transpose, float_diag_matrix)
 // matrix by matrix ops.
 
 DEFBINOP_OP (add, float_diag_matrix, float_diag_matrix, +)
 DEFBINOP_OP (sub, float_diag_matrix, float_diag_matrix, -)
 DEFBINOP_OP (mul, float_diag_matrix, float_diag_matrix, *)
 
 DEFBINOP (div, float_diag_matrix, float_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_diag_matrix&, const octave_float_diag_matrix&);
+  CAST_BINOP_ARGS (const octave_float_diag_matrix&,
+                   const octave_float_diag_matrix&);
 
   return xdiv (v1.float_diag_matrix_value (),
                v2.float_diag_matrix_value ());
 }
 
 DEFBINOP (ldiv, float_diag_matrix, float_diag_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_diag_matrix&, const octave_float_diag_matrix&);
+  CAST_BINOP_ARGS (const octave_float_diag_matrix&,
+                   const octave_float_diag_matrix&);
 
   return xleftdiv (v1.float_diag_matrix_value (),
                    v2.float_diag_matrix_value ());
 }
 
 CONVDECL (float_diag_matrix_to_diag_matrix)
 {
   CAST_CONV_ARG (const octave_float_diag_matrix&);
@@ -85,19 +87,28 @@ CONVDECL (float_diag_matrix_to_float_mat
 void
 install_fdm_fdm_ops (void)
 {
   INSTALL_UNOP (op_uplus, octave_float_diag_matrix, uplus);
   INSTALL_UNOP (op_uminus, octave_float_diag_matrix, uminus);
   INSTALL_UNOP (op_transpose, octave_float_diag_matrix, transpose);
   INSTALL_UNOP (op_hermitian, octave_float_diag_matrix, transpose);
 
-  INSTALL_BINOP (op_add, octave_float_diag_matrix, octave_float_diag_matrix, add);
-  INSTALL_BINOP (op_sub, octave_float_diag_matrix, octave_float_diag_matrix, sub);
-  INSTALL_BINOP (op_mul, octave_float_diag_matrix, octave_float_diag_matrix, mul);
-  INSTALL_BINOP (op_div, octave_float_diag_matrix, octave_float_diag_matrix, div);
-  INSTALL_BINOP (op_ldiv, octave_float_diag_matrix, octave_float_diag_matrix, ldiv);
+  INSTALL_BINOP (op_add, octave_float_diag_matrix, octave_float_diag_matrix,
+                 add);
+  INSTALL_BINOP (op_sub, octave_float_diag_matrix, octave_float_diag_matrix,
+                 sub);
+  INSTALL_BINOP (op_mul, octave_float_diag_matrix, octave_float_diag_matrix,
+                 mul);
+  INSTALL_BINOP (op_div, octave_float_diag_matrix, octave_float_diag_matrix,
+                 div);
+  INSTALL_BINOP (op_ldiv, octave_float_diag_matrix, octave_float_diag_matrix,
+                 ldiv);
 
-  INSTALL_CONVOP (octave_float_diag_matrix, octave_float_matrix, float_diag_matrix_to_float_matrix);
-  INSTALL_CONVOP (octave_float_diag_matrix, octave_diag_matrix, float_diag_matrix_to_diag_matrix);
-  INSTALL_ASSIGNCONV (octave_float_diag_matrix, octave_float_matrix, octave_float_matrix);
-  INSTALL_WIDENOP (octave_float_diag_matrix, octave_float_matrix, float_diag_matrix_to_float_matrix);
+  INSTALL_CONVOP (octave_float_diag_matrix, octave_float_matrix,
+                  float_diag_matrix_to_float_matrix);
+  INSTALL_CONVOP (octave_float_diag_matrix, octave_diag_matrix,
+                  float_diag_matrix_to_diag_matrix);
+  INSTALL_ASSIGNCONV (octave_float_diag_matrix, octave_float_matrix,
+                      octave_float_matrix);
+  INSTALL_WIDENOP (octave_float_diag_matrix, octave_float_matrix,
+                   float_diag_matrix_to_float_matrix);
 }
diff --git a/libinterp/operators/op-float-conv.cc b/libinterp/operators/op-float-conv.cc
--- a/libinterp/operators/op-float-conv.cc
+++ b/libinterp/operators/op-float-conv.cc
@@ -74,38 +74,59 @@ DEFFLTCONVFN (range_to_float_matrix, ran
 DEFSTRFLTCONVFN(char_matrix_str_to_float_matrix, char_matrix_str)
 DEFSTRFLTCONVFN(char_matrix_sq_str_to_float_matrix, char_matrix_sq_str)
 
 DEFFLTCONVFN (float_scalar_to_float_matrix, scalar, array)
 
 void
 install_float_conv_ops (void)
 {
-  INSTALL_CONVOP (octave_int8_matrix, octave_float_matrix, int8_matrix_to_float_matrix);
-  INSTALL_CONVOP (octave_int16_matrix, octave_float_matrix, int16_matrix_to_float_matrix);
-  INSTALL_CONVOP (octave_int32_matrix, octave_float_matrix, int32_matrix_to_float_matrix);
-  INSTALL_CONVOP (octave_int64_matrix, octave_float_matrix, int64_matrix_to_float_matrix);
+  INSTALL_CONVOP (octave_int8_matrix, octave_float_matrix,
+                  int8_matrix_to_float_matrix);
+  INSTALL_CONVOP (octave_int16_matrix, octave_float_matrix,
+                  int16_matrix_to_float_matrix);
+  INSTALL_CONVOP (octave_int32_matrix, octave_float_matrix,
+                  int32_matrix_to_float_matrix);
+  INSTALL_CONVOP (octave_int64_matrix, octave_float_matrix,
+                  int64_matrix_to_float_matrix);
 
-  INSTALL_CONVOP (octave_uint8_matrix, octave_float_matrix, uint8_matrix_to_float_matrix);
-  INSTALL_CONVOP (octave_uint16_matrix, octave_float_matrix, uint16_matrix_to_float_matrix);
-  INSTALL_CONVOP (octave_uint32_matrix, octave_float_matrix, uint32_matrix_to_float_matrix);
-  INSTALL_CONVOP (octave_uint64_matrix, octave_float_matrix, uint64_matrix_to_float_matrix);
+  INSTALL_CONVOP (octave_uint8_matrix, octave_float_matrix,
+                  uint8_matrix_to_float_matrix);
+  INSTALL_CONVOP (octave_uint16_matrix, octave_float_matrix,
+                  uint16_matrix_to_float_matrix);
+  INSTALL_CONVOP (octave_uint32_matrix, octave_float_matrix,
+                  uint32_matrix_to_float_matrix);
+  INSTALL_CONVOP (octave_uint64_matrix, octave_float_matrix,
+                  uint64_matrix_to_float_matrix);
 
-  INSTALL_CONVOP (octave_int8_scalar, octave_float_matrix, int8_scalar_to_float_matrix);
-  INSTALL_CONVOP (octave_int16_scalar, octave_float_matrix, int16_scalar_to_float_matrix);
-  INSTALL_CONVOP (octave_int32_scalar, octave_float_matrix, int32_scalar_to_float_matrix);
-  INSTALL_CONVOP (octave_int64_scalar, octave_float_matrix, int64_scalar_to_float_matrix);
+  INSTALL_CONVOP (octave_int8_scalar, octave_float_matrix,
+                  int8_scalar_to_float_matrix);
+  INSTALL_CONVOP (octave_int16_scalar, octave_float_matrix,
+                  int16_scalar_to_float_matrix);
+  INSTALL_CONVOP (octave_int32_scalar, octave_float_matrix,
+                  int32_scalar_to_float_matrix);
+  INSTALL_CONVOP (octave_int64_scalar, octave_float_matrix,
+                  int64_scalar_to_float_matrix);
 
-  INSTALL_CONVOP (octave_uint8_scalar, octave_float_matrix, uint8_scalar_to_float_matrix);
-  INSTALL_CONVOP (octave_uint16_scalar, octave_float_matrix, uint16_scalar_to_float_matrix);
-  INSTALL_CONVOP (octave_uint32_scalar, octave_float_matrix, uint32_scalar_to_float_matrix);
-  INSTALL_CONVOP (octave_uint64_scalar, octave_float_matrix, uint64_scalar_to_float_matrix);
+  INSTALL_CONVOP (octave_uint8_scalar, octave_float_matrix,
+                  uint8_scalar_to_float_matrix);
+  INSTALL_CONVOP (octave_uint16_scalar, octave_float_matrix,
+                  uint16_scalar_to_float_matrix);
+  INSTALL_CONVOP (octave_uint32_scalar, octave_float_matrix,
+                  uint32_scalar_to_float_matrix);
+  INSTALL_CONVOP (octave_uint64_scalar, octave_float_matrix,
+                  uint64_scalar_to_float_matrix);
 
-  INSTALL_CONVOP (octave_bool_matrix, octave_float_matrix, bool_matrix_to_float_matrix);
-  INSTALL_CONVOP (octave_bool, octave_float_matrix, bool_scalar_to_float_matrix);
+  INSTALL_CONVOP (octave_bool_matrix, octave_float_matrix,
+                  bool_matrix_to_float_matrix);
+  INSTALL_CONVOP (octave_bool, octave_float_matrix,
+                  bool_scalar_to_float_matrix);
 
   INSTALL_CONVOP (octave_range, octave_float_matrix, range_to_float_matrix);
 
-  INSTALL_CONVOP (octave_char_matrix_str, octave_float_matrix, char_matrix_str_to_float_matrix);
-  INSTALL_CONVOP (octave_char_matrix_sq_str, octave_float_matrix, char_matrix_sq_str_to_float_matrix);
+  INSTALL_CONVOP (octave_char_matrix_str, octave_float_matrix,
+                  char_matrix_str_to_float_matrix);
+  INSTALL_CONVOP (octave_char_matrix_sq_str, octave_float_matrix,
+                  char_matrix_sq_str_to_float_matrix);
 
-  INSTALL_CONVOP (octave_scalar, octave_float_matrix, float_scalar_to_float_matrix);
+  INSTALL_CONVOP (octave_scalar, octave_float_matrix,
+                  float_scalar_to_float_matrix);
 }
diff --git a/libinterp/operators/op-fm-fcm.cc b/libinterp/operators/op-fm-fcm.cc
--- a/libinterp/operators/op-fm-fcm.cc
+++ b/libinterp/operators/op-fm-fcm.cc
@@ -47,17 +47,18 @@ DEFNDBINOP_OP (add, float_matrix, float_
                float_complex_array, +)
 DEFNDBINOP_OP (sub, float_matrix, float_complex_matrix, float_array,
                float_complex_array, -)
 
 DEFBINOP_OP (mul, float_matrix, float_complex_matrix, *)
 
 DEFBINOP (trans_mul, float_matrix, float_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_float_matrix&,
+                   const octave_float_complex_matrix&);
 
   FloatMatrix m1 = v1.float_matrix_value ();
   FloatComplexMatrix m2 = v2.float_complex_matrix_value ();
 
   return FloatComplexMatrix (xgemm (m1, real (m2), blas_trans, blas_no_trans),
                              xgemm (m1, imag (m2), blas_trans, blas_no_trans));
 }
 
@@ -82,47 +83,48 @@ DEFBINOPX (pow, float_matrix, float_comp
 
 DEFBINOP (ldiv, float_matrix, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&,
                    const octave_float_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (v1.float_matrix_value (),
-                                v2.float_complex_matrix_value (), typ);
+                                     v2.float_complex_matrix_value (), typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFBINOP (trans_ldiv, float_matrix, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&,
                    const octave_float_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
 
   FloatComplexMatrix ret = xleftdiv (v1.float_matrix_value (),
-                         v2.float_complex_matrix_value (), typ, blas_trans);
+                                     v2.float_complex_matrix_value (),
+                                     typ, blas_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFNDCMPLXCMPOP_FN (lt, float_matrix, float_complex_matrix, float_array,
-               float_complex_array, mx_el_lt)
+                    float_complex_array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, float_matrix, float_complex_matrix, float_array,
-               float_complex_array, mx_el_le)
+                    float_complex_array, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, float_matrix, float_complex_matrix, float_array,
-               float_complex_array, mx_el_eq)
+                    float_complex_array, mx_el_eq)
 DEFNDCMPLXCMPOP_FN (ge, float_matrix, float_complex_matrix, float_array,
-               float_complex_array, mx_el_ge)
+                    float_complex_array, mx_el_ge)
 DEFNDCMPLXCMPOP_FN (gt, float_matrix, float_complex_matrix, float_array,
-               float_complex_array, mx_el_gt)
+                    float_complex_array, mx_el_gt)
 DEFNDCMPLXCMPOP_FN (ne, float_matrix, float_complex_matrix, float_array,
-               float_complex_array, mx_el_ne)
+                    float_complex_array, mx_el_ne)
 
 DEFNDBINOP_FN (el_mul, float_matrix, float_complex_matrix, float_array,
                float_complex_array, product)
 DEFNDBINOP_FN (el_div, float_matrix, float_complex_matrix, float_array,
                float_complex_array, quotient)
 DEFNDBINOP_FN (el_pow, float_matrix, float_complex_matrix, float_array,
                float_complex_array, elem_xpow)
 
@@ -147,17 +149,18 @@ DEFNDCATOP_FN (m_fcm, matrix, float_comp
 
 DEFNDCATOP_FN (fm_cm, float_matrix, complex_matrix, float_array,
                float_complex_array, concat)
 
 DEFCONV (float_complex_matrix_conv, float_matrix, float_complex_matrix)
 {
   CAST_CONV_ARG (const octave_float_matrix&);
 
-  return new octave_float_complex_matrix (FloatComplexNDArray (v.float_array_value ()));
+  return new octave_float_complex_matrix (FloatComplexNDArray
+                                           (v.float_array_value ()));
 }
 
 void
 install_fm_fcm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_matrix, octave_float_complex_matrix, add);
   INSTALL_BINOP (op_sub, octave_float_matrix, octave_float_complex_matrix, sub);
   INSTALL_BINOP (op_mul, octave_float_matrix, octave_float_complex_matrix, mul);
diff --git a/libinterp/operators/op-fm-fcs.cc b/libinterp/operators/op-fm-fcs.cc
--- a/libinterp/operators/op-fm-fcs.cc
+++ b/libinterp/operators/op-fm-fcs.cc
@@ -73,27 +73,27 @@ DEFBINOP (ldiv, float_matrix, float_comp
 
   FloatComplexMatrix ret = xleftdiv (m1, m2, typ);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFNDCMPLXCMPOP_FN (lt, float_matrix, float_complex, float_array,
-               float_complex, mx_el_lt)
+                    float_complex, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, float_matrix, float_complex, float_array,
-               float_complex, mx_el_le)
+                    float_complex, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, float_matrix, float_complex, float_array,
-               float_complex, mx_el_eq)
+                    float_complex, mx_el_eq)
 DEFNDCMPLXCMPOP_FN (ge, float_matrix, float_complex, float_array,
-               float_complex, mx_el_ge)
+                    float_complex, mx_el_ge)
 DEFNDCMPLXCMPOP_FN (gt, float_matrix, float_complex, float_array,
-               float_complex, mx_el_gt)
+                    float_complex, mx_el_gt)
 DEFNDCMPLXCMPOP_FN (ne, float_matrix, float_complex, float_array,
-               float_complex, mx_el_ne)
+                    float_complex, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, float_matrix, float_complex, float_array,
                float_complex, *)
 
 DEFBINOP (el_div, float_matrix, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_complex&);
 
@@ -142,17 +142,18 @@ install_fm_fcs_ops (void)
   INSTALL_BINOP (op_le, octave_float_matrix, octave_float_complex, le);
   INSTALL_BINOP (op_eq, octave_float_matrix, octave_float_complex, eq);
   INSTALL_BINOP (op_ge, octave_float_matrix, octave_float_complex, ge);
   INSTALL_BINOP (op_gt, octave_float_matrix, octave_float_complex, gt);
   INSTALL_BINOP (op_ne, octave_float_matrix, octave_float_complex, ne);
   INSTALL_BINOP (op_el_mul, octave_float_matrix, octave_float_complex, el_mul);
   INSTALL_BINOP (op_el_div, octave_float_matrix, octave_float_complex, el_div);
   INSTALL_BINOP (op_el_pow, octave_float_matrix, octave_float_complex, el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_float_matrix, octave_float_complex, el_ldiv);
+  INSTALL_BINOP (op_el_ldiv, octave_float_matrix, octave_float_complex,
+                 el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_matrix, octave_float_complex, el_and);
   INSTALL_BINOP (op_el_or, octave_float_matrix, octave_float_complex, el_or);
 
   INSTALL_CATOP (octave_float_matrix, octave_float_complex, fm_fcs);
   INSTALL_CATOP (octave_matrix, octave_float_complex, m_fcs);
   INSTALL_CATOP (octave_float_matrix, octave_complex, fm_cs);
 
   INSTALL_ASSIGNCONV (octave_float_matrix, octave_float_complex,
diff --git a/libinterp/operators/op-fm-fm.cc b/libinterp/operators/op-fm-fm.cc
--- a/libinterp/operators/op-fm-fm.cc
+++ b/libinterp/operators/op-fm-fm.cc
@@ -176,18 +176,20 @@ DEFNDCATOP_FN (fm_m, float_matrix, matri
 DEFNDASSIGNOP_FN (assign, float_matrix, float_matrix, float_array, assign)
 
 DEFNDASSIGNOP_FN (dbl_assign, matrix, float_matrix, array, assign)
 
 DEFNULLASSIGNOP_FN (null_assign, float_matrix, delete_elements)
 
 DEFNDASSIGNOP_OP (assign_add, float_matrix, float_matrix, float_array, +=)
 DEFNDASSIGNOP_OP (assign_sub, float_matrix, float_matrix, float_array, -=)
-DEFNDASSIGNOP_FNOP (assign_el_mul, float_matrix, float_matrix, float_array, product_eq)
-DEFNDASSIGNOP_FNOP (assign_el_div, float_matrix, float_matrix, float_array, quotient_eq)
+DEFNDASSIGNOP_FNOP (assign_el_mul, float_matrix, float_matrix, float_array,
+                    product_eq)
+DEFNDASSIGNOP_FNOP (assign_el_div, float_matrix, float_matrix, float_array,
+                    quotient_eq)
 
 CONVDECL (float_matrix_to_matrix)
 {
   CAST_CONV_ARG (const octave_float_matrix&);
 
   return new octave_matrix (v.array_value ());
 }
 
@@ -217,39 +219,56 @@ install_fm_fm_ops (void)
   INSTALL_BINOP (op_gt, octave_float_matrix, octave_float_matrix, gt);
   INSTALL_BINOP (op_ne, octave_float_matrix, octave_float_matrix, ne);
   INSTALL_BINOP (op_el_mul, octave_float_matrix, octave_float_matrix, el_mul);
   INSTALL_BINOP (op_el_div, octave_float_matrix, octave_float_matrix, el_div);
   INSTALL_BINOP (op_el_pow, octave_float_matrix, octave_float_matrix, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_float_matrix, octave_float_matrix, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_matrix, octave_float_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_float_matrix, octave_float_matrix, el_or);
-  INSTALL_BINOP (op_el_and_not, octave_float_matrix, octave_float_matrix, el_and_not);
-  INSTALL_BINOP (op_el_or_not, octave_float_matrix, octave_float_matrix, el_or_not);
-  INSTALL_BINOP (op_el_not_and, octave_float_matrix, octave_float_matrix, el_not_and);
-  INSTALL_BINOP (op_el_not_or, octave_float_matrix, octave_float_matrix, el_not_or);
-  INSTALL_BINOP (op_trans_mul, octave_float_matrix, octave_float_matrix, trans_mul);
-  INSTALL_BINOP (op_mul_trans, octave_float_matrix, octave_float_matrix, mul_trans);
-  INSTALL_BINOP (op_herm_mul, octave_float_matrix, octave_float_matrix, trans_mul);
-  INSTALL_BINOP (op_mul_herm, octave_float_matrix, octave_float_matrix, mul_trans);
-  INSTALL_BINOP (op_trans_ldiv, octave_float_matrix, octave_float_matrix, trans_ldiv);
-  INSTALL_BINOP (op_herm_ldiv, octave_float_matrix, octave_float_matrix, trans_ldiv);
+  INSTALL_BINOP (op_el_and_not, octave_float_matrix, octave_float_matrix,
+                 el_and_not);
+  INSTALL_BINOP (op_el_or_not, octave_float_matrix, octave_float_matrix,
+                 el_or_not);
+  INSTALL_BINOP (op_el_not_and, octave_float_matrix, octave_float_matrix,
+                 el_not_and);
+  INSTALL_BINOP (op_el_not_or, octave_float_matrix, octave_float_matrix,
+                 el_not_or);
+  INSTALL_BINOP (op_trans_mul, octave_float_matrix, octave_float_matrix,
+                 trans_mul);
+  INSTALL_BINOP (op_mul_trans, octave_float_matrix, octave_float_matrix,
+                 mul_trans);
+  INSTALL_BINOP (op_herm_mul, octave_float_matrix, octave_float_matrix,
+                 trans_mul);
+  INSTALL_BINOP (op_mul_herm, octave_float_matrix, octave_float_matrix,
+                 mul_trans);
+  INSTALL_BINOP (op_trans_ldiv, octave_float_matrix, octave_float_matrix,
+                 trans_ldiv);
+  INSTALL_BINOP (op_herm_ldiv, octave_float_matrix, octave_float_matrix,
+                 trans_ldiv);
 
   INSTALL_CATOP (octave_float_matrix, octave_float_matrix, fm_fm);
   INSTALL_CATOP (octave_matrix, octave_float_matrix, m_fm);
   INSTALL_CATOP (octave_float_matrix, octave_matrix, fm_m);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix,
                     octave_float_matrix, assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_matrix,
                     octave_float_matrix, dbl_assign);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, octave_null_matrix, null_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, octave_null_str, null_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, octave_null_sq_str, null_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, octave_null_matrix,
+                    null_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, octave_null_str,
+                    null_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, octave_null_sq_str,
+                    null_assign);
 
-  INSTALL_ASSIGNOP (op_add_eq, octave_float_matrix, octave_float_matrix, assign_add);
-  INSTALL_ASSIGNOP (op_sub_eq, octave_float_matrix, octave_float_matrix, assign_sub);
-  INSTALL_ASSIGNOP (op_el_mul_eq, octave_float_matrix, octave_float_matrix, assign_el_mul);
-  INSTALL_ASSIGNOP (op_el_div_eq, octave_float_matrix, octave_float_matrix, assign_el_div);
+  INSTALL_ASSIGNOP (op_add_eq, octave_float_matrix, octave_float_matrix,
+                    assign_add);
+  INSTALL_ASSIGNOP (op_sub_eq, octave_float_matrix, octave_float_matrix,
+                    assign_sub);
+  INSTALL_ASSIGNOP (op_el_mul_eq, octave_float_matrix, octave_float_matrix,
+                    assign_el_mul);
+  INSTALL_ASSIGNOP (op_el_div_eq, octave_float_matrix, octave_float_matrix,
+                    assign_el_div);
 
   INSTALL_CONVOP (octave_float_matrix, octave_matrix, float_matrix_to_matrix);
 }
diff --git a/libinterp/operators/op-fm-fs.cc b/libinterp/operators/op-fm-fs.cc
--- a/libinterp/operators/op-fm-fs.cc
+++ b/libinterp/operators/op-fm-fs.cc
@@ -147,16 +147,21 @@ install_fm_fs_ops (void)
   INSTALL_BINOP (op_el_ldiv, octave_float_matrix, octave_float_scalar, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_matrix, octave_float_scalar, el_and);
   INSTALL_BINOP (op_el_or, octave_float_matrix, octave_float_scalar, el_or);
 
   INSTALL_CATOP (octave_float_matrix, octave_float_scalar, fm_fs);
   INSTALL_CATOP (octave_matrix, octave_float_scalar, m_fs);
   INSTALL_CATOP (octave_float_matrix, octave_scalar, fm_s);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, octave_float_scalar, assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, octave_float_scalar,
+                    assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_matrix, octave_float_scalar, dbl_assign);
 
-  INSTALL_ASSIGNOP (op_add_eq, octave_float_matrix, octave_float_scalar, assign_add);
-  INSTALL_ASSIGNOP (op_sub_eq, octave_float_matrix, octave_float_scalar, assign_sub);
-  INSTALL_ASSIGNOP (op_mul_eq, octave_float_matrix, octave_float_scalar, assign_mul);
-  INSTALL_ASSIGNOP (op_div_eq, octave_float_matrix, octave_float_scalar, assign_div);
+  INSTALL_ASSIGNOP (op_add_eq, octave_float_matrix, octave_float_scalar,
+                    assign_add);
+  INSTALL_ASSIGNOP (op_sub_eq, octave_float_matrix, octave_float_scalar,
+                    assign_sub);
+  INSTALL_ASSIGNOP (op_mul_eq, octave_float_matrix, octave_float_scalar,
+                    assign_mul);
+  INSTALL_ASSIGNOP (op_div_eq, octave_float_matrix, octave_float_scalar,
+                    assign_div);
 }
diff --git a/libinterp/operators/op-fs-fcm.cc b/libinterp/operators/op-fs-fcm.cc
--- a/libinterp/operators/op-fs-fcm.cc
+++ b/libinterp/operators/op-fs-fcm.cc
@@ -77,27 +77,27 @@ DEFBINOP (ldiv, float_scalar, float_comp
 
   if (d == 0.0)
     gripe_divide_by_zero ();
 
   return octave_value (v2.float_complex_array_value () / d);
 }
 
 DEFNDCMPLXCMPOP_FN (lt, float_scalar, float_complex_matrix, float_scalar,
-               float_complex_array, mx_el_lt)
+                    float_complex_array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, float_scalar, float_complex_matrix, float_scalar,
-               float_complex_array, mx_el_le)
+                    float_complex_array, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, float_scalar, float_complex_matrix, float_scalar,
-               float_complex_array, mx_el_eq)
+                    float_complex_array, mx_el_eq)
 DEFNDCMPLXCMPOP_FN (ge, float_scalar, float_complex_matrix, float_scalar,
-               float_complex_array, mx_el_ge)
+                    float_complex_array, mx_el_ge)
 DEFNDCMPLXCMPOP_FN (gt, float_scalar, float_complex_matrix, float_scalar,
-               float_complex_array, mx_el_gt)
+                    float_complex_array, mx_el_gt)
 DEFNDCMPLXCMPOP_FN (ne, float_scalar, float_complex_matrix, float_scalar,
-               float_complex_array, mx_el_ne)
+                    float_complex_array, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, *)
 DEFNDBINOP_FN (el_div, float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, x_el_div)
 DEFNDBINOP_FN (el_pow, float_scalar, float_complex_matrix, float_scalar,
                float_complex_array, elem_xpow)
 
@@ -127,17 +127,18 @@ DEFNDCATOP_FN (s_fcm, scalar, float_comp
 
 DEFNDCATOP_FN (fs_cm, float_scalar, complex_matrix, float_array,
                float_complex_array, concat)
 
 DEFCONV (float_complex_matrix_conv, float_scalar, float_complex_matrix)
 {
   CAST_CONV_ARG (const octave_float_scalar&);
 
-  return new octave_float_complex_matrix (FloatComplexMatrix (v.float_matrix_value ()));
+  return new octave_float_complex_matrix (FloatComplexMatrix
+                                            (v.float_matrix_value ()));
 }
 
 void
 install_fs_fcm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_float_scalar, octave_float_complex_matrix, add);
   INSTALL_BINOP (op_sub, octave_float_scalar, octave_float_complex_matrix, sub);
   INSTALL_BINOP (op_mul, octave_float_scalar, octave_float_complex_matrix, mul);
diff --git a/libinterp/operators/op-fs-fcs.cc b/libinterp/operators/op-fs-fcs.cc
--- a/libinterp/operators/op-fs-fcs.cc
+++ b/libinterp/operators/op-fs-fcs.cc
@@ -104,24 +104,28 @@ DEFBINOP (el_ldiv, float_scalar, float_c
 
   return octave_value (v2.float_complex_value () / d);
 }
 
 DEFBINOP (el_and, float_scalar, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_complex&);
 
-  return octave_value (v1.float_scalar_value () && (v2.float_complex_value () != static_cast<float>(0.0)));
+  return octave_value (v1.float_scalar_value ()
+                       && (v2.float_complex_value ()
+                            != static_cast<float>(0.0)));
 }
 
 DEFBINOP (el_or, float_scalar, float_complex)
 {
   CAST_BINOP_ARGS (const octave_float_scalar&, const octave_float_complex&);
 
-  return octave_value (v1.float_scalar_value () || (v2.float_complex_value () != static_cast<float>(0.0)));
+  return octave_value (v1.float_scalar_value ()
+                       || (v2.float_complex_value ()
+                            != static_cast<float>(0.0)));
 }
 
 DEFNDCATOP_FN (fs_fcs, float_scalar, float_complex, float_array,
                float_complex_array, concat)
 
 DEFNDCATOP_FN (s_fcs, scalar, float_complex, float_array,
                float_complex_array, concat)
 
@@ -141,17 +145,18 @@ install_fs_fcs_ops (void)
   INSTALL_BINOP (op_le, octave_float_scalar, octave_float_complex, le);
   INSTALL_BINOP (op_eq, octave_float_scalar, octave_float_complex, eq);
   INSTALL_BINOP (op_ge, octave_float_scalar, octave_float_complex, ge);
   INSTALL_BINOP (op_gt, octave_float_scalar, octave_float_complex, gt);
   INSTALL_BINOP (op_ne, octave_float_scalar, octave_float_complex, ne);
   INSTALL_BINOP (op_el_mul, octave_float_scalar, octave_float_complex, el_mul);
   INSTALL_BINOP (op_el_div, octave_float_scalar, octave_float_complex, el_div);
   INSTALL_BINOP (op_el_pow, octave_float_scalar, octave_float_complex, el_pow);
-  INSTALL_BINOP (op_el_ldiv, octave_float_scalar, octave_float_complex, el_ldiv);
+  INSTALL_BINOP (op_el_ldiv, octave_float_scalar, octave_float_complex,
+                 el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_scalar, octave_float_complex, el_and);
   INSTALL_BINOP (op_el_or, octave_float_scalar, octave_float_complex, el_or);
 
   INSTALL_CATOP (octave_float_scalar, octave_float_complex, fs_fcs);
   INSTALL_CATOP (octave_scalar, octave_float_complex, s_fcs);
   INSTALL_CATOP (octave_float_scalar, octave_complex, fs_cs);
 
   INSTALL_ASSIGNCONV (octave_float_scalar, octave_float_complex,
diff --git a/libinterp/operators/op-fs-fm.cc b/libinterp/operators/op-fs-fm.cc
--- a/libinterp/operators/op-fs-fm.cc
+++ b/libinterp/operators/op-fs-fm.cc
@@ -74,17 +74,17 @@ DEFNDBINOP_FN (lt, float_scalar, float_m
                float_array, mx_el_lt)
 DEFNDBINOP_FN (le, float_scalar, float_matrix, float_scalar,
                float_array, mx_el_le)
 DEFNDBINOP_FN (eq, float_scalar, float_matrix, float_scalar,
                float_array, mx_el_eq)
 DEFNDBINOP_FN (ge, float_scalar, float_matrix, float_scalar,
                float_array, mx_el_ge)
 DEFNDBINOP_FN (gt, float_scalar, float_matrix, float_scalar,
-float_array, mx_el_gt)
+               float_array, mx_el_gt)
 DEFNDBINOP_FN (ne, float_scalar, float_matrix, float_scalar,
                float_array, mx_el_ne)
 
 DEFNDBINOP_OP (el_mul, float_scalar, float_matrix, float_scalar,
                float_array, *)
 DEFNDBINOP_FN (el_div, float_scalar, float_matrix, float_scalar,
                float_array, x_el_div)
 DEFNDBINOP_FN (el_pow, float_scalar, float_matrix, float_scalar,
@@ -142,13 +142,14 @@ install_fs_fm_ops (void)
   INSTALL_BINOP (op_el_ldiv, octave_float_scalar, octave_float_matrix, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_scalar, octave_float_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_float_scalar, octave_float_matrix, el_or);
 
   INSTALL_CATOP (octave_float_scalar, octave_float_matrix, fs_fm);
   INSTALL_CATOP (octave_scalar, octave_float_matrix, s_fm);
   INSTALL_CATOP (octave_float_scalar, octave_matrix, fs_m);
 
-  INSTALL_ASSIGNCONV (octave_float_scalar, octave_float_matrix, octave_float_matrix);
+  INSTALL_ASSIGNCONV (octave_float_scalar, octave_float_matrix,
+                      octave_float_matrix);
   INSTALL_ASSIGNCONV (octave_scalar, octave_float_matrix, octave_matrix);
 
   INSTALL_WIDENOP (octave_float_scalar, octave_float_matrix, matrix_conv);
 }
diff --git a/libinterp/operators/op-fs-fs.cc b/libinterp/operators/op-fs-fs.cc
--- a/libinterp/operators/op-fs-fs.cc
+++ b/libinterp/operators/op-fs-fs.cc
@@ -122,25 +122,27 @@ DEFBINOP (el_ldiv, float_scalar, float_s
     gripe_divide_by_zero ();
 
   return octave_value (v2.float_value () / d);
 }
 
 DEFSCALARBOOLOP_OP (el_and, float_scalar, float_scalar, &&)
 DEFSCALARBOOLOP_OP (el_or, float_scalar, float_scalar, ||)
 
-DEFNDCATOP_FN (fs_fs, float_scalar, float_scalar, float_array, float_array, concat)
+DEFNDCATOP_FN (fs_fs, float_scalar, float_scalar, float_array, float_array,
+               concat)
 DEFNDCATOP_FN (s_fs, scalar, float_scalar, float_array, float_array, concat)
 DEFNDCATOP_FN (fs_s, float_scalar, scalar, float_array, float_array, concat)
 
 CONVDECL (float_to_scalar)
 {
   CAST_CONV_ARG (const octave_float_scalar&);
 
-  return new octave_matrix (Matrix (1, 1, static_cast<double>(v.float_value ())));
+  return new octave_matrix (Matrix (1, 1,
+                                    static_cast<double>(v.float_value ())));
 }
 
 void
 install_fs_fs_ops (void)
 {
   INSTALL_UNOP (op_not, octave_float_scalar, not);
   INSTALL_UNOP (op_uplus, octave_float_scalar, uplus);
   INSTALL_UNOP (op_uminus, octave_float_scalar, uminus);
@@ -168,17 +170,21 @@ install_fs_fs_ops (void)
   INSTALL_BINOP (op_el_ldiv, octave_float_scalar, octave_float_scalar, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_float_scalar, octave_float_scalar, el_and);
   INSTALL_BINOP (op_el_or, octave_float_scalar, octave_float_scalar, el_or);
 
   INSTALL_CATOP (octave_float_scalar, octave_float_scalar, fs_fs);
   INSTALL_CATOP (octave_scalar, octave_float_scalar, s_fs);
   INSTALL_CATOP (octave_float_scalar, octave_scalar, fs_s);
 
-  INSTALL_ASSIGNCONV (octave_float_scalar, octave_float_scalar, octave_float_matrix);
+  INSTALL_ASSIGNCONV (octave_float_scalar, octave_float_scalar,
+                      octave_float_matrix);
   INSTALL_ASSIGNCONV (octave_scalar, octave_float_scalar, octave_matrix);
 
-  INSTALL_ASSIGNCONV (octave_float_scalar, octave_null_matrix, octave_float_matrix);
-  INSTALL_ASSIGNCONV (octave_float_scalar, octave_null_str, octave_float_matrix);
-  INSTALL_ASSIGNCONV (octave_float_scalar, octave_null_sq_str, octave_float_matrix);
+  INSTALL_ASSIGNCONV (octave_float_scalar, octave_null_matrix,
+                      octave_float_matrix);
+  INSTALL_ASSIGNCONV (octave_float_scalar, octave_null_str,
+                      octave_float_matrix);
+  INSTALL_ASSIGNCONV (octave_float_scalar, octave_null_sq_str,
+                      octave_float_matrix);
 
   INSTALL_CONVOP (octave_float_scalar, octave_matrix, float_to_scalar);
 }
diff --git a/libinterp/operators/op-m-cm.cc b/libinterp/operators/op-m-cm.cc
--- a/libinterp/operators/op-m-cm.cc
+++ b/libinterp/operators/op-m-cm.cc
@@ -90,17 +90,17 @@ DEFBINOP (ldiv, matrix, complex_matrix)
 }
 
 DEFBINOP (trans_ldiv, matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (v1.matrix_value (),
-                         v2.complex_matrix_value (), typ, blas_trans);
+                                v2.complex_matrix_value (), typ, blas_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFNDCMPLXCMPOP_FN (lt, matrix, complex_matrix, array, complex_array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, matrix, complex_matrix, array, complex_array, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, matrix, complex_matrix, array, complex_array, mx_el_eq)
@@ -149,18 +149,22 @@ install_m_cm_ops (void)
   INSTALL_BINOP (op_el_mul, octave_matrix, octave_complex_matrix, el_mul);
   INSTALL_BINOP (op_el_div, octave_matrix, octave_complex_matrix, el_div);
   INSTALL_BINOP (op_el_pow, octave_matrix, octave_complex_matrix, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_matrix, octave_complex_matrix, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_matrix, octave_complex_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_matrix, octave_complex_matrix, el_or);
   INSTALL_BINOP (op_trans_mul, octave_matrix, octave_complex_matrix, trans_mul);
   INSTALL_BINOP (op_herm_mul, octave_matrix, octave_complex_matrix, trans_mul);
-  INSTALL_BINOP (op_trans_ldiv, octave_matrix, octave_complex_matrix, trans_ldiv);
-  INSTALL_BINOP (op_herm_ldiv, octave_matrix, octave_complex_matrix, trans_ldiv);
+  INSTALL_BINOP (op_trans_ldiv, octave_matrix, octave_complex_matrix,
+                 trans_ldiv);
+  INSTALL_BINOP (op_herm_ldiv, octave_matrix, octave_complex_matrix,
+                 trans_ldiv);
 
   INSTALL_CATOP (octave_matrix, octave_complex_matrix, m_cm);
 
-  INSTALL_ASSIGNCONV (octave_matrix, octave_complex_matrix, octave_complex_matrix);
-  INSTALL_ASSIGNCONV (octave_float_matrix, octave_complex_matrix, octave_float_complex_matrix);
+  INSTALL_ASSIGNCONV (octave_matrix, octave_complex_matrix,
+                      octave_complex_matrix);
+  INSTALL_ASSIGNCONV (octave_float_matrix, octave_complex_matrix,
+                      octave_float_complex_matrix);
 
   INSTALL_WIDENOP (octave_matrix, octave_complex_matrix, complex_matrix_conv);
 }
diff --git a/libinterp/operators/op-m-cs.cc b/libinterp/operators/op-m-cs.cc
--- a/libinterp/operators/op-m-cs.cc
+++ b/libinterp/operators/op-m-cs.cc
@@ -131,10 +131,11 @@ install_m_cs_ops (void)
   INSTALL_BINOP (op_el_pow, octave_matrix, octave_complex, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_matrix, octave_complex, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_matrix, octave_complex, el_and);
   INSTALL_BINOP (op_el_or, octave_matrix, octave_complex, el_or);
 
   INSTALL_CATOP (octave_matrix, octave_complex, m_cs);
 
   INSTALL_ASSIGNCONV (octave_matrix, octave_complex, octave_complex_matrix);
-  INSTALL_ASSIGNCONV (octave_float_matrix, octave_complex, octave_float_complex_matrix);
+  INSTALL_ASSIGNCONV (octave_float_matrix, octave_complex,
+                      octave_float_complex_matrix);
 }
diff --git a/libinterp/operators/op-m-m.cc b/libinterp/operators/op-m-m.cc
--- a/libinterp/operators/op-m-m.cc
+++ b/libinterp/operators/op-m-m.cc
@@ -107,17 +107,18 @@ DEFBINOP (mul_trans, matrix, matrix)
                              blas_no_trans, blas_trans));
 }
 
 DEFBINOP (trans_ldiv, matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
   MatrixType typ = v1.matrix_type ();
 
-  Matrix ret = xleftdiv (v1.matrix_value (), v2.matrix_value (), typ, blas_trans);
+  Matrix ret = xleftdiv (v1.matrix_value (), v2.matrix_value (),
+                         typ, blas_trans);
 
   v1.matrix_type (typ);
   return ret;
 }
 
 DEFNDBINOP_FN (lt, matrix, matrix, array, array, mx_el_lt)
 DEFNDBINOP_FN (le, matrix, matrix, array, array, mx_el_le)
 DEFNDBINOP_FN (eq, matrix, matrix, array, array, mx_el_eq)
diff --git a/libinterp/operators/op-m-s.cc b/libinterp/operators/op-m-s.cc
--- a/libinterp/operators/op-m-s.cc
+++ b/libinterp/operators/op-m-s.cc
@@ -102,17 +102,18 @@ DEFBINOP (el_ldiv, matrix, scalar)
 
 DEFNDBINOP_FN (el_and, matrix, scalar, array, scalar, mx_el_and)
 DEFNDBINOP_FN (el_or, matrix, scalar, array, scalar, mx_el_or)
 
 DEFNDCATOP_FN (m_s, matrix, scalar, array, array, concat)
 
 DEFNDASSIGNOP_FN (assign, matrix, scalar, scalar, assign)
 DEFNDASSIGNOP_FN (sgl_assign, float_matrix, scalar, float_scalar, assign)
-DEFNDASSIGNOP_FN (clx_sgl_assign, float_complex_matrix, scalar, float_complex, assign)
+DEFNDASSIGNOP_FN (clx_sgl_assign, float_complex_matrix, scalar, float_complex,
+                  assign)
 
 DEFNDASSIGNOP_OP (assign_add, matrix, scalar, scalar, +=)
 DEFNDASSIGNOP_OP (assign_sub, matrix, scalar, scalar, -=)
 DEFNDASSIGNOP_OP (assign_mul, matrix, scalar, scalar, *=)
 DEFNDASSIGNOP_OP (assign_div, matrix, scalar, scalar, /=)
 
 void
 install_m_s_ops (void)
@@ -141,15 +142,16 @@ install_m_s_ops (void)
   INSTALL_BINOP (op_el_ldiv, octave_matrix, octave_scalar, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_matrix, octave_scalar, el_and);
   INSTALL_BINOP (op_el_or, octave_matrix, octave_scalar, el_or);
 
   INSTALL_CATOP (octave_matrix, octave_scalar, m_s);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_matrix, octave_scalar, assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, octave_scalar, sgl_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, octave_scalar, clx_sgl_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_float_complex_matrix, octave_scalar,
+                    clx_sgl_assign);
 
   INSTALL_ASSIGNOP (op_add_eq, octave_matrix, octave_scalar, assign_add);
   INSTALL_ASSIGNOP (op_sub_eq, octave_matrix, octave_scalar, assign_sub);
   INSTALL_ASSIGNOP (op_mul_eq, octave_matrix, octave_scalar, assign_mul);
   INSTALL_ASSIGNOP (op_div_eq, octave_matrix, octave_scalar, assign_div);
 }
diff --git a/libinterp/operators/op-m-scm.cc b/libinterp/operators/op-m-scm.cc
--- a/libinterp/operators/op-m-scm.cc
+++ b/libinterp/operators/op-m-scm.cc
@@ -102,26 +102,26 @@ DEFBINOP_FN (el_mul, matrix, sparse_comp
 DEFBINOP_FN (el_div, matrix, sparse_complex_matrix, quotient)
 
 DEFBINOP (el_pow, matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&,
                    const octave_sparse_complex_matrix&);
 
   return octave_value
-    (elem_xpow (SparseMatrix (v1.matrix_value ()),
-                v2.sparse_complex_matrix_value ()));
+         (elem_xpow (SparseMatrix (v1.matrix_value ()),
+                     v2.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP (el_ldiv, matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&,
                    const octave_sparse_complex_matrix&);
   return octave_value
-    (quotient (v2.sparse_complex_matrix_value (), v1.matrix_value ()));
+         (quotient (v2.sparse_complex_matrix_value (), v1.matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, matrix, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  matrix, sparse_complex_matrix, mx_el_or)
 
 DEFCATOP (m_scm, matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (octave_matrix&, const octave_sparse_complex_matrix&);
@@ -129,17 +129,17 @@ DEFCATOP (m_scm, matrix, sparse_complex_
   return octave_value (tmp. concat (v2.sparse_complex_matrix_value (),
                                     ra_idx));
 }
 
 DEFCONV (sparse_complex_matrix_conv, matrix, sparse_complex_matrix)
 {
   CAST_CONV_ARG (const octave_matrix&);
   return new octave_sparse_complex_matrix
-    (SparseComplexMatrix (v.complex_matrix_value ()));
+         (SparseComplexMatrix (v.complex_matrix_value ()));
 }
 
 void
 install_m_scm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_matrix, octave_sparse_complex_matrix, add);
   INSTALL_BINOP (op_sub, octave_matrix, octave_sparse_complex_matrix, sub);
   INSTALL_BINOP (op_mul, octave_matrix, octave_sparse_complex_matrix, mul);
diff --git a/libinterp/operators/op-m-sm.cc b/libinterp/operators/op-m-sm.cc
--- a/libinterp/operators/op-m-sm.cc
+++ b/libinterp/operators/op-m-sm.cc
@@ -107,17 +107,17 @@ DEFBINOP (el_pow, matrix, sparse_matrix)
                                   v2.sparse_matrix_value ()));
 }
 
 DEFBINOP (el_ldiv, matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_matrix&);
 
   return octave_value
-    (quotient (v2.sparse_matrix_value (), v1.matrix_value ()));
+         (quotient (v2.sparse_matrix_value (), v1.matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, matrix, sparse_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  matrix, sparse_matrix, mx_el_or)
 
 DEFCATOP (m_sm, matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (octave_matrix&, const octave_sparse_matrix&);
diff --git a/libinterp/operators/op-pm-scm.cc b/libinterp/operators/op-pm-scm.cc
--- a/libinterp/operators/op-pm-scm.cc
+++ b/libinterp/operators/op-pm-scm.cc
@@ -32,58 +32,62 @@ along with Octave; see the file COPYING.
 
 #include "ov-perm.h"
 #include "ov-cx-sparse.h"
 
 // permutation matrix by sparse matrix ops
 
 DEFBINOP (mul_pm_scm, perm_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_sparse_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_perm_matrix&,
+                   const octave_sparse_complex_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       std::complex<double> d = v2.complex_value ();
 
       return octave_value (v1.sparse_matrix_value () * d);
     }
   else if (v1.rows () == 1 && v1.columns () == 1)
     return octave_value (v2.sparse_complex_matrix_value ());
   else
     return v1.perm_matrix_value  () * v2.sparse_complex_matrix_value ();
 }
 
 DEFBINOP (ldiv_pm_scm, perm_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_perm_matrix&, const octave_sparse_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_perm_matrix&,
+                   const octave_sparse_complex_matrix&);
 
   return v1.perm_matrix_value ().inverse () * v2.sparse_complex_matrix_value ();
 }
 
 // sparse matrix by diagonal matrix ops
 
 DEFBINOP (mul_scm_pm, sparse_complex_matrix, perm_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_perm_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
+                   const octave_perm_matrix&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       std::complex<double> d = v1.scalar_value ();
 
       return octave_value (d * v2.sparse_matrix_value ());
     }
   else if (v2.rows () == 1 && v2.columns () == 1)
     return octave_value (v1.sparse_complex_matrix_value ());
   else
     return v1.sparse_complex_matrix_value  () * v2.perm_matrix_value ();
 }
 
 DEFBINOP (div_scm_pm, sparse_complex_matrix, perm_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_perm_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
+                   const octave_perm_matrix&);
 
   return v1.sparse_complex_matrix_value () * v2.perm_matrix_value ().inverse ();
 }
 
 void
 install_pm_scm_ops (void)
 {
   INSTALL_BINOP (op_mul, octave_perm_matrix, octave_sparse_complex_matrix,
diff --git a/libinterp/operators/op-range.cc b/libinterp/operators/op-range.cc
--- a/libinterp/operators/op-range.cc
+++ b/libinterp/operators/op-range.cc
@@ -123,17 +123,17 @@ install_range_ops (void)
   INSTALL_CATOP (octave_scalar, octave_range, s_r);
   INSTALL_CATOP (octave_matrix, octave_range, m_r);
   INSTALL_CATOP (octave_complex, octave_range, cs_r);
   INSTALL_CATOP (octave_complex_matrix, octave_range, cm_r);
   INSTALL_CATOP (octave_bool, octave_range, b_r);
   INSTALL_CATOP (octave_bool_matrix, octave_range, bm_r);
   INSTALL_CATOP (octave_char_matrix, octave_range, chm_r);
 
-  // FIXME -- this would be unneccessary if
+  // FIXME: this would be unneccessary if
   // octave_base_value::numeric_assign always tried converting lhs
   // before rhs.
 
   INSTALL_ASSIGNCONV (octave_range, octave_null_matrix, octave_matrix);
   INSTALL_ASSIGNCONV (octave_range, octave_null_str, octave_matrix);
   INSTALL_ASSIGNCONV (octave_range, octave_null_sq_str, octave_matrix);
 
   // However, this should probably be here just in case we need it.
diff --git a/libinterp/operators/op-s-cm.cc b/libinterp/operators/op-s-cm.cc
--- a/libinterp/operators/op-s-cm.cc
+++ b/libinterp/operators/op-s-cm.cc
@@ -130,13 +130,15 @@ install_s_cm_ops (void)
   INSTALL_BINOP (op_el_div, octave_scalar, octave_complex_matrix, el_div);
   INSTALL_BINOP (op_el_pow, octave_scalar, octave_complex_matrix, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_scalar, octave_complex_matrix, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_scalar, octave_complex_matrix, el_and);
   INSTALL_BINOP (op_el_or, octave_scalar, octave_complex_matrix, el_or);
 
   INSTALL_CATOP (octave_scalar, octave_complex_matrix, s_cm);
 
-  INSTALL_ASSIGNCONV (octave_scalar, octave_complex_matrix, octave_complex_matrix);
-  INSTALL_ASSIGNCONV (octave_float_scalar, octave_complex_matrix, octave_float_complex_matrix);
+  INSTALL_ASSIGNCONV (octave_scalar, octave_complex_matrix,
+                      octave_complex_matrix);
+  INSTALL_ASSIGNCONV (octave_float_scalar, octave_complex_matrix,
+                      octave_float_complex_matrix);
 
   INSTALL_WIDENOP (octave_scalar, octave_complex_matrix, complex_matrix_conv);
 }
diff --git a/libinterp/operators/op-s-cs.cc b/libinterp/operators/op-s-cs.cc
--- a/libinterp/operators/op-s-cs.cc
+++ b/libinterp/operators/op-s-cs.cc
@@ -140,10 +140,11 @@ install_s_cs_ops (void)
   INSTALL_BINOP (op_el_pow, octave_scalar, octave_complex, el_pow);
   INSTALL_BINOP (op_el_ldiv, octave_scalar, octave_complex, el_ldiv);
   INSTALL_BINOP (op_el_and, octave_scalar, octave_complex, el_and);
   INSTALL_BINOP (op_el_or, octave_scalar, octave_complex, el_or);
 
   INSTALL_CATOP (octave_scalar, octave_complex, s_cs);
 
   INSTALL_ASSIGNCONV (octave_scalar, octave_complex, octave_complex_matrix);
-  INSTALL_ASSIGNCONV (octave_float_scalar, octave_complex, octave_float_complex_matrix);
+  INSTALL_ASSIGNCONV (octave_float_scalar, octave_complex,
+                      octave_float_complex_matrix);
 }
diff --git a/libinterp/operators/op-s-scm.cc b/libinterp/operators/op-s-scm.cc
--- a/libinterp/operators/op-s-scm.cc
+++ b/libinterp/operators/op-s-scm.cc
@@ -124,25 +124,25 @@ DEFBINOP (el_ldiv, scalar, sparse_comple
 DEFBINOP_FN (el_and, scalar, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or, scalar, sparse_complex_matrix, mx_el_or)
 
 DEFCATOP (s_scm, scalar, sparse_compelx_matrix)
 {
   CAST_BINOP_ARGS (octave_scalar&, const octave_sparse_complex_matrix&);
   SparseMatrix tmp (1, 1, v1.scalar_value ());
   return octave_value
-    (tmp.concat (v2.sparse_complex_matrix_value (), ra_idx));
+         (tmp.concat (v2.sparse_complex_matrix_value (), ra_idx));
 }
 
 DEFCONV (sparse_complex_matrix_conv, scalar, sparse_complex_matrix)
 {
   CAST_CONV_ARG (const octave_scalar&);
 
   return new octave_sparse_complex_matrix
-    (SparseComplexMatrix (v.complex_matrix_value ()));
+         (SparseComplexMatrix (v.complex_matrix_value ()));
 }
 
 void
 install_s_scm_ops (void)
 {
   INSTALL_BINOP (op_add, octave_scalar, octave_sparse_complex_matrix, add);
   INSTALL_BINOP (op_sub, octave_scalar, octave_sparse_complex_matrix, sub);
   INSTALL_BINOP (op_mul, octave_scalar, octave_sparse_complex_matrix, mul);
diff --git a/libinterp/operators/op-sbm-b.cc b/libinterp/operators/op-sbm-b.cc
--- a/libinterp/operators/op-sbm-b.cc
+++ b/libinterp/operators/op-sbm-b.cc
@@ -87,17 +87,17 @@ DEFASSIGNOP (assign, sparse_bool_matrix,
 
 static octave_value
 oct_assignop_conv_and_assign (octave_base_value& a1,
                               const octave_value_list& idx,
                               const octave_base_value& a2)
 {
   octave_sparse_bool_matrix& v1 = dynamic_cast<octave_sparse_bool_matrix&> (a1);
 
-  // FIXME -- perhaps add a warning for this conversion if the values
+  // FIXME: perhaps add a warning for this conversion if the values
   // are not all 0 or 1?
 
   SparseBoolMatrix v2 (1, 1, a2.bool_value ());
 
   if (! error_state)
     v1.assign (idx, v2);
 
   return octave_value ();
diff --git a/libinterp/operators/op-sbm-bm.cc b/libinterp/operators/op-sbm-bm.cc
--- a/libinterp/operators/op-sbm-bm.cc
+++ b/libinterp/operators/op-sbm-bm.cc
@@ -93,17 +93,17 @@ DEFNULLASSIGNOP_FN (null_assign, sparse_
 
 static octave_value
 oct_assignop_conv_and_assign (octave_base_value& a1,
                               const octave_value_list& idx,
                               const octave_base_value& a2)
 {
   octave_sparse_bool_matrix& v1 = dynamic_cast<octave_sparse_bool_matrix&> (a1);
 
-  // FIXME -- perhaps add a warning for this conversion if the values
+  // FIXME: perhaps add a warning for this conversion if the values
   // are not all 0 or 1?
 
   SparseBoolMatrix v2 (a2.bool_array_value ());
 
   if (! error_state)
     v1.assign (idx, v2);
 
   return octave_value ();
diff --git a/libinterp/operators/op-sbm-sbm.cc b/libinterp/operators/op-sbm-sbm.cc
--- a/libinterp/operators/op-sbm-sbm.cc
+++ b/libinterp/operators/op-sbm-sbm.cc
@@ -74,17 +74,18 @@ DEFNDCATOP_FN (sm_sbm, sparse_matrix, sp
 
 DEFASSIGNOP_FN (assign, sparse_bool_matrix, sparse_bool_matrix,
                 assign)
 
 CONVDECL (bool_matrix_to_double_matrix)
 {
   CAST_CONV_ARG (const octave_sparse_bool_matrix&);
 
-  return new octave_sparse_matrix (SparseMatrix (v.sparse_bool_matrix_value ()));
+  return new octave_sparse_matrix (SparseMatrix
+                                    (v.sparse_bool_matrix_value ()));
 }
 
 void
 install_sbm_sbm_ops (void)
 {
   INSTALL_UNOP (op_not, octave_sparse_bool_matrix, not);
   INSTALL_UNOP (op_uplus, octave_sparse_bool_matrix, uplus);
   INSTALL_UNOP (op_uminus, octave_sparse_bool_matrix, uminus);
diff --git a/libinterp/operators/op-scm-cm.cc b/libinterp/operators/op-scm-cm.cc
--- a/libinterp/operators/op-scm-cm.cc
+++ b/libinterp/operators/op-scm-cm.cc
@@ -62,33 +62,34 @@ DEFBINOP (div, sparse_complex_matrix, co
 DEFBINOPX (pow, sparse_complex_matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
+                   const octave_complex_matrix&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v2.complex_array_value () / d);
     }
   else
     {
       MatrixType typ = v1.matrix_type ();
 
       ComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (),
-                      v2.complex_matrix_value (), typ);
+                                    v2.complex_matrix_value (), typ);
 
       v1.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOP_FN (trans_mul, sparse_complex_matrix, complex_matrix, trans_mul);
 DEFBINOP_FN (herm_mul, sparse_complex_matrix, complex_matrix, herm_mul);
@@ -104,18 +105,18 @@ DEFBINOP_FN (el_mul, sparse_complex_matr
 DEFBINOP_FN (el_div, sparse_complex_matrix, complex_matrix, quotient)
 
 DEFBINOP (el_pow, sparse_complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_complex_matrix&);
 
   return octave_value
-    (elem_xpow (v1.sparse_complex_matrix_value (), SparseComplexMatrix
-                (v2.complex_matrix_value ())));
+         (elem_xpow (v1.sparse_complex_matrix_value (), SparseComplexMatrix
+                     (v2.complex_matrix_value ())));
 }
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_complex_matrix&);
 
   return octave_value (quotient (v2.complex_matrix_value (),
@@ -126,17 +127,17 @@ DEFBINOP_FN (el_and, sparse_complex_matr
 DEFBINOP_FN (el_or,  sparse_complex_matrix, complex_matrix, mx_el_or)
 
 DEFCATOP (scm_cm, sparse_complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (octave_sparse_complex_matrix&,
                    const octave_complex_matrix&);
   SparseComplexMatrix tmp (v2.complex_matrix_value ());
   return octave_value
-    (v1.sparse_complex_matrix_value (). concat (tmp, ra_idx));
+         (v1.sparse_complex_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFASSIGNOP (assign, sparse_complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (octave_sparse_complex_matrix&,
                    const octave_complex_matrix&);
 
   SparseComplexMatrix tmp (v2.complex_matrix_value ());
diff --git a/libinterp/operators/op-scm-cs.cc b/libinterp/operators/op-scm-cs.cc
--- a/libinterp/operators/op-scm-cs.cc
+++ b/libinterp/operators/op-scm-cs.cc
@@ -120,28 +120,28 @@ DEFBINOP (el_div, sparse_complex_matrix,
 DEFBINOP_FN (el_pow, sparse_complex_matrix, complex, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_complex&);
 
   return octave_value
-    (x_el_div (v2.complex_value (), v1.sparse_complex_matrix_value ()));
+         (x_el_div (v2.complex_value (), v1.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_complex_matrix, complex, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_complex_matrix, complex, mx_el_or)
 
 DEFCATOP (scm_cs, sparse_complex_matrix, complex)
 {
   CAST_BINOP_ARGS (octave_sparse_complex_matrix&, const octave_complex&);
   SparseComplexMatrix tmp (1, 1, v2.complex_value ());
   return octave_value
-    (v1.sparse_complex_matrix_value (). concat (tmp, ra_idx));
+         (v1.sparse_complex_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFASSIGNOP (assign, sparse_complex_matrix, complex)
 {
   CAST_BINOP_ARGS (octave_sparse_complex_matrix&, const octave_complex&);
 
   SparseComplexMatrix tmp (1, 1, v2.complex_value ());
   v1.assign (idx, tmp);
diff --git a/libinterp/operators/op-scm-m.cc b/libinterp/operators/op-scm-m.cc
--- a/libinterp/operators/op-scm-m.cc
+++ b/libinterp/operators/op-scm-m.cc
@@ -102,38 +102,38 @@ DEFBINOP_FN (el_mul, sparse_complex_matr
 DEFBINOP_FN (el_div, sparse_complex_matrix, matrix, quotient)
 
 DEFBINOP (el_pow, sparse_complex_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_matrix&);
 
   return octave_value
-    (elem_xpow (v1.sparse_complex_matrix_value (), SparseMatrix
-                (v2.matrix_value ())));
+         (elem_xpow (v1.sparse_complex_matrix_value (), SparseMatrix
+                     (v2.matrix_value ())));
 }
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_matrix&);
 
   return octave_value
-    (quotient (v2.matrix_value (), v1.sparse_complex_matrix_value ()));
+         (quotient (v2.matrix_value (), v1.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_complex_matrix, matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_complex_matrix, matrix, mx_el_or)
 
 DEFCATOP (scm_m, sparse_complex_matrix, matrix)
 {
   CAST_BINOP_ARGS (octave_sparse_complex_matrix&, const octave_matrix&);
   SparseMatrix tmp (v2.matrix_value ());
   return octave_value
-    (v1.sparse_complex_matrix_value (). concat (tmp, ra_idx));
+         (v1.sparse_complex_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFASSIGNOP (assign, sparse_complex_matrix, matrix)
 {
   CAST_BINOP_ARGS (octave_sparse_complex_matrix&, const octave_matrix&);
 
   SparseComplexMatrix tmp (v2.complex_matrix_value ());
   v1.assign (idx, tmp);
diff --git a/libinterp/operators/op-scm-s.cc b/libinterp/operators/op-scm-s.cc
--- a/libinterp/operators/op-scm-s.cc
+++ b/libinterp/operators/op-scm-s.cc
@@ -126,28 +126,28 @@ DEFBINOP (el_div, sparse_complex_matrix,
 
 DEFBINOP_FN (el_pow, sparse_complex_matrix, scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_scalar&);
 
   return octave_value
-    (x_el_div (v2.double_value (), v1.sparse_complex_matrix_value ()));
+         (x_el_div (v2.double_value (), v1.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_complex_matrix, scalar, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_complex_matrix, scalar, mx_el_or)
 
 DEFCATOP (scm_s, sparse_complex_matrix, scalar)
 {
   CAST_BINOP_ARGS (octave_sparse_complex_matrix&, const octave_scalar&);
   SparseComplexMatrix tmp (1, 1, v2.complex_value ());
   return octave_value
-    (v1.sparse_complex_matrix_value (). concat (tmp, ra_idx));
+         (v1.sparse_complex_matrix_value (). concat (tmp, ra_idx));
 }
 
 DEFASSIGNOP (assign, sparse_complex_matrix, scalar)
 {
   CAST_BINOP_ARGS (octave_sparse_complex_matrix&, const octave_scalar&);
 
   SparseComplexMatrix tmp (1, 1, v2.complex_value ());
   v1.assign (idx, tmp);
diff --git a/libinterp/operators/op-scm-scm.cc b/libinterp/operators/op-scm-scm.cc
--- a/libinterp/operators/op-scm-scm.cc
+++ b/libinterp/operators/op-scm-scm.cc
@@ -55,26 +55,26 @@ along with Octave; see the file COPYING.
 DEFUNOP_OP (not, sparse_complex_matrix, !)
 DEFUNOP_OP (uplus, sparse_complex_matrix, /* no-op */)
 DEFUNOP_OP (uminus, sparse_complex_matrix, -)
 
 DEFUNOP (transpose, sparse_complex_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_complex_matrix&);
   return octave_value
-    (v.sparse_complex_matrix_value ().transpose (),
-     v.matrix_type ().transpose ());
+         (v.sparse_complex_matrix_value ().transpose (),
+          v.matrix_type ().transpose ());
 }
 
 DEFUNOP (hermitian, sparse_complex_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_complex_matrix&);
   return octave_value
-    (v.sparse_complex_matrix_value ().hermitian (),
-     v.matrix_type ().transpose ());
+         (v.sparse_complex_matrix_value ().hermitian (),
+          v.matrix_type ().transpose ());
 }
 
 #if 0
 DEFUNOP (incr, sparse_complex_matrix)
 {
   CAST_UNOP_ARG (const octave_sparse_complex_matrix&);
 
   return octave_value (v.complex_matrix_value () .increment ());
diff --git a/libinterp/operators/op-scm-sm.cc b/libinterp/operators/op-scm-sm.cc
--- a/libinterp/operators/op-scm-sm.cc
+++ b/libinterp/operators/op-scm-sm.cc
@@ -42,17 +42,18 @@ along with Octave; see the file COPYING.
 
 DEFBINOP_OP (add, sparse_complex_matrix, sparse_matrix, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, sparse_matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, sparse_matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_sparse_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
+                   const octave_sparse_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       double d = v2.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
@@ -72,17 +73,18 @@ DEFBINOP (div, sparse_complex_matrix, sp
 DEFBINOPX (pow, sparse_complex_matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, sparse_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_sparse_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
+                   const octave_sparse_matrix&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       Complex d = v1.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
@@ -111,18 +113,18 @@ DEFBINOP_FN (el_mul, sparse_complex_matr
 DEFBINOP_FN (el_div, sparse_complex_matrix, sparse_matrix, quotient)
 DEFBINOP_FN (el_pow, sparse_complex_matrix, sparse_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_complex_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_sparse_matrix&);
 
-  return octave_value
-    (quotient (v2.sparse_matrix_value (), v1.sparse_complex_matrix_value ()));
+  return octave_value (quotient (v2.sparse_matrix_value (),
+                                 v1.sparse_complex_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_complex_matrix, sparse_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_complex_matrix, sparse_matrix, mx_el_or)
 
 DEFCATOP_FN (scm_sm, sparse_complex_matrix, sparse_matrix, concat)
 
 DEFASSIGNOP_FN (assign, sparse_complex_matrix, sparse_matrix, assign)
diff --git a/libinterp/operators/op-sm-cm.cc b/libinterp/operators/op-sm-cm.cc
--- a/libinterp/operators/op-sm-cm.cc
+++ b/libinterp/operators/op-sm-cm.cc
@@ -101,27 +101,27 @@ DEFBINOP_FN (el_mul, sparse_matrix, comp
 DEFBINOP_FN (el_div, sparse_matrix, complex_matrix, quotient)
 
 DEFBINOP (el_pow, sparse_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&,
                    const octave_complex_matrix&);
 
   return octave_value
-    (elem_xpow (v1.sparse_matrix_value (), SparseComplexMatrix
-                (v2.complex_matrix_value ())));
+         (elem_xpow (v1.sparse_matrix_value (), SparseComplexMatrix
+                     (v2.complex_matrix_value ())));
 }
 
 DEFBINOP (el_ldiv, sparse_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&,
                    const octave_complex_matrix&);
 
   return octave_value
-    (quotient (v2.complex_matrix_value (), v1.sparse_matrix_value ()));
+         (quotient (v2.complex_matrix_value (), v1.sparse_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_matrix, complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_matrix, complex_matrix, mx_el_or)
 
 DEFCATOP (sm_cm, sparse_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_complex_matrix&);
diff --git a/libinterp/operators/op-sm-m.cc b/libinterp/operators/op-sm-m.cc
--- a/libinterp/operators/op-sm-m.cc
+++ b/libinterp/operators/op-sm-m.cc
@@ -108,17 +108,17 @@ DEFBINOP (el_pow, sparse_matrix, matrix)
                                   SparseMatrix (v2.matrix_value ())));
 }
 
 DEFBINOP (el_ldiv, sparse_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_matrix&);
 
   return octave_value
-    (quotient (v2.matrix_value (), v1.sparse_matrix_value ()));
+         (quotient (v2.matrix_value (), v1.sparse_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_matrix, matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_matrix, matrix, mx_el_or)
 
 DEFCATOP (sm_m, sparse_matrix, matrix)
 {
   CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_matrix&);
diff --git a/libinterp/operators/op-sm-s.cc b/libinterp/operators/op-sm-s.cc
--- a/libinterp/operators/op-sm-s.cc
+++ b/libinterp/operators/op-sm-s.cc
@@ -119,17 +119,17 @@ DEFBINOP (el_div, sparse_matrix, scalar)
 
 DEFBINOP_FN (el_pow, sparse_matrix, scalar, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_scalar&);
 
   return octave_value
-    (x_el_div (v2.complex_value (), v1.sparse_matrix_value ()));
+         (x_el_div (v2.complex_value (), v1.sparse_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_matrix, scalar, mx_el_and)
 DEFBINOP_FN (el_or, sparse_matrix, scalar, mx_el_or)
 
 DEFCATOP (sm_s, sparse_matrix, scalar)
 {
   CAST_BINOP_ARGS (octave_sparse_matrix&, const octave_scalar&);
diff --git a/libinterp/operators/op-sm-scm.cc b/libinterp/operators/op-sm-scm.cc
--- a/libinterp/operators/op-sm-scm.cc
+++ b/libinterp/operators/op-sm-scm.cc
@@ -42,47 +42,49 @@ along with Octave; see the file COPYING.
 
 DEFBINOP_OP (add, sparse_matrix, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, sparse_matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, sparse_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_matrix&,
+                   const octave_sparse_complex_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
     {
       Complex d = v2.complex_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
       return octave_value (v1.sparse_matrix_value () / d);
     }
   else
     {
       MatrixType typ = v2.matrix_type ();
       SparseComplexMatrix ret = xdiv (v1.sparse_matrix_value (),
-                                  v2.sparse_complex_matrix_value (), typ);
+                                      v2.sparse_complex_matrix_value (), typ);
 
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOPX (pow, sparse_matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, sparse_complex_matrix)
 {
-  CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_complex_matrix&);
+  CAST_BINOP_ARGS (const octave_sparse_matrix&,
+                   const octave_sparse_complex_matrix&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
       double d = v1.scalar_value ();
 
       if (d == 0.0)
         gripe_divide_by_zero ();
 
@@ -112,18 +114,18 @@ DEFBINOP_FN (el_mul, sparse_matrix, spar
 DEFBINOP_FN (el_div, sparse_matrix, sparse_complex_matrix, quotient)
 DEFBINOP_FN (el_pow, sparse_matrix, sparse_complex_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&,
                    const octave_sparse_complex_matrix&);
 
-  return octave_value
-    (quotient (v2.sparse_complex_matrix_value (), v1.sparse_matrix_value ()));
+  return octave_value (quotient (v2.sparse_complex_matrix_value (),
+                                 v1.sparse_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_matrix, sparse_complex_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_matrix, sparse_complex_matrix, mx_el_or)
 
 DEFCATOP_FN (sm_scm, sparse_matrix, sparse_complex_matrix, concat)
 
 DEFCONV (sparse_complex_matrix_conv, sparse_matrix, sparse_complex_matrix)
diff --git a/libinterp/operators/op-sm-sm.cc b/libinterp/operators/op-sm-sm.cc
--- a/libinterp/operators/op-sm-sm.cc
+++ b/libinterp/operators/op-sm-sm.cc
@@ -51,25 +51,27 @@ DEFUNOP (transpose, sparse_matrix)
 }
 
 // sparse matrix by sparse matrix ops.
 
 DEFBINOP_OP (add, sparse_matrix, sparse_matrix, +)
 
 // DEFBINOP_OP (sub, sparse_matrix, sparse_matrix, -)
 
-  static octave_value
-  oct_binop_sub (const octave_base_value& a1, const octave_base_value& a2)
-  {
-    const octave_sparse_matrix& v1 = dynamic_cast<const octave_sparse_matrix&> (a1);
-    const octave_sparse_matrix& v2 = dynamic_cast<const octave_sparse_matrix&> (a2);
-    SparseMatrix m = v1.sparse_matrix_value () - v2.sparse_matrix_value ();
+static octave_value
+oct_binop_sub (const octave_base_value& a1, const octave_base_value& a2)
+{
+  const octave_sparse_matrix& v1 =
+    dynamic_cast<const octave_sparse_matrix&> (a1);
+  const octave_sparse_matrix& v2 =
+    dynamic_cast<const octave_sparse_matrix&> (a2);
+  SparseMatrix m = v1.sparse_matrix_value () - v2.sparse_matrix_value ();
 
-    return octave_value (m);
-  }
+  return octave_value (m);
+}
 
 DEFBINOP_OP (mul, sparse_matrix, sparse_matrix, *)
 
 DEFBINOP (div, sparse_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_matrix&);
 
   if (v2.rows () == 1 && v2.columns () == 1)
@@ -134,17 +136,17 @@ DEFBINOP_FN (el_mul, sparse_matrix, spar
 DEFBINOP_FN (el_div, sparse_matrix, sparse_matrix, quotient)
 
 DEFBINOP_FN (el_pow, sparse_matrix, sparse_matrix, elem_xpow)
 
 DEFBINOP (el_ldiv, sparse_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_matrix&);
   return octave_value
-    (quotient (v2.sparse_matrix_value (), v1.sparse_matrix_value ()));
+         (quotient (v2.sparse_matrix_value (), v1.sparse_matrix_value ()));
 }
 
 DEFBINOP_FN (el_and, sparse_matrix, sparse_matrix, mx_el_and)
 DEFBINOP_FN (el_or,  sparse_matrix, sparse_matrix, mx_el_or)
 
 DEFCATOP_FN (sm_sm, sparse_matrix, sparse_matrix, concat)
 
 DEFASSIGNOP_FN (assign, sparse_matrix, sparse_matrix, assign)
@@ -185,12 +187,15 @@ install_sm_sm_ops (void)
   INSTALL_BINOP (op_el_or, octave_sparse_matrix, octave_sparse_matrix,
                  el_or);
 
   INSTALL_CATOP (octave_sparse_matrix, octave_sparse_matrix, sm_sm);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_matrix, octave_sparse_matrix,
                     assign);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_matrix, octave_null_matrix, null_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_matrix, octave_null_str, null_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_matrix, octave_null_sq_str, null_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_matrix, octave_null_matrix,
+                    null_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_matrix, octave_null_str,
+                    null_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_sparse_matrix, octave_null_sq_str,
+                    null_assign);
 }
diff --git a/libinterp/operators/op-str-m.cc b/libinterp/operators/op-str-m.cc
--- a/libinterp/operators/op-str-m.cc
+++ b/libinterp/operators/op-str-m.cc
@@ -49,16 +49,17 @@ DEFASSIGNOP (assign, char_matrix_str, oc
 DEFNDCHARCATOP_FN (str_m, char_matrix_str, matrix, concat)
 
 DEFNDCHARCATOP_FN (m_str, matrix, char_matrix_str, concat)
 
 void
 install_str_m_ops (void)
 {
   INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_str, octave_matrix, assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_sq_str, octave_matrix, assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_sq_str, octave_matrix,
+                    assign);
 
   INSTALL_CATOP (octave_char_matrix_str, octave_matrix, str_m);
   INSTALL_CATOP (octave_char_matrix_sq_str, octave_matrix, str_m);
 
   INSTALL_CATOP (octave_matrix, octave_char_matrix_str, m_str);
   INSTALL_CATOP (octave_matrix, octave_char_matrix_sq_str, m_str);
 }
diff --git a/libinterp/operators/op-str-s.cc b/libinterp/operators/op-str-s.cc
--- a/libinterp/operators/op-str-s.cc
+++ b/libinterp/operators/op-str-s.cc
@@ -49,16 +49,17 @@ DEFASSIGNOP (assign, char_matrix_str, oc
 DEFNDCHARCATOP_FN (str_s, char_matrix_str, scalar, concat)
 
 DEFNDCHARCATOP_FN (s_str, scalar, char_matrix_str, concat)
 
 void
 install_str_s_ops (void)
 {
   INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_str, octave_scalar, assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_sq_str, octave_scalar, assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_sq_str, octave_scalar,
+                    assign);
 
   INSTALL_CATOP (octave_char_matrix_str, octave_scalar, str_s);
   INSTALL_CATOP (octave_char_matrix_sq_str, octave_scalar, str_s);
 
   INSTALL_CATOP (octave_scalar, octave_char_matrix_str, s_str);
   INSTALL_CATOP (octave_scalar, octave_char_matrix_sq_str, s_str);
 }
diff --git a/libinterp/operators/op-str-str.cc b/libinterp/operators/op-str-str.cc
--- a/libinterp/operators/op-str-str.cc
+++ b/libinterp/operators/op-str-str.cc
@@ -72,22 +72,28 @@ DEFUNOP (transpose, char_matrix_str)
       { \
         if (a2_is_scalar) \
           return octave_value (f (v1.e1 ## _value (), (v2.e2 ## _value ())(0))); \
         else \
           return octave_value (f (v1.e1 ## _value (), v2.e2 ## _value ())); \
       } \
   }
 
-DEFCHARNDBINOP_FN (lt, <, char_matrix_str, char_matrix_str, char_array, char_array, mx_el_lt)
-DEFCHARNDBINOP_FN (le, <=, char_matrix_str, char_matrix_str, char_array, char_array, mx_el_le)
-DEFCHARNDBINOP_FN (eq, ==, char_matrix_str, char_matrix_str, char_array, char_array, mx_el_eq)
-DEFCHARNDBINOP_FN (ge, >=, char_matrix_str, char_matrix_str, char_array, char_array, mx_el_ge)
-DEFCHARNDBINOP_FN (gt, >, char_matrix_str, char_matrix_str, char_array, char_array, mx_el_gt)
-DEFCHARNDBINOP_FN (ne, !=, char_matrix_str, char_matrix_str, char_array, char_array, mx_el_ne)
+DEFCHARNDBINOP_FN (lt, <, char_matrix_str, char_matrix_str, char_array,
+                   char_array, mx_el_lt)
+DEFCHARNDBINOP_FN (le, <=, char_matrix_str, char_matrix_str, char_array,
+                   char_array, mx_el_le)
+DEFCHARNDBINOP_FN (eq, ==, char_matrix_str, char_matrix_str, char_array,
+                   char_array, mx_el_eq)
+DEFCHARNDBINOP_FN (ge, >=, char_matrix_str, char_matrix_str, char_array,
+                   char_array, mx_el_ge)
+DEFCHARNDBINOP_FN (gt, >, char_matrix_str, char_matrix_str, char_array,
+                   char_array, mx_el_gt)
+DEFCHARNDBINOP_FN (ne, !=, char_matrix_str, char_matrix_str, char_array,
+                   char_array, mx_el_ne)
 
 DEFASSIGNOP (assign, char_matrix_str, char_matrix_str)
 {
   CAST_BINOP_ARGS (octave_char_matrix_str&, const octave_char_matrix_str&);
 
   v1.assign (idx, v2.char_array_value ());
   return octave_value ();
 }
@@ -103,53 +109,71 @@ install_str_str_ops (void)
   INSTALL_UNOP (op_transpose, octave_char_matrix_sq_str, transpose);
 
   INSTALL_UNOP (op_hermitian, octave_char_matrix_str, transpose);
   INSTALL_UNOP (op_hermitian, octave_char_matrix_sq_str, transpose);
 
   INSTALL_BINOP (op_lt, octave_char_matrix_str, octave_char_matrix_str, lt);
   INSTALL_BINOP (op_lt, octave_char_matrix_str, octave_char_matrix_sq_str, lt);
   INSTALL_BINOP (op_lt, octave_char_matrix_sq_str, octave_char_matrix_str, lt);
-  INSTALL_BINOP (op_lt, octave_char_matrix_sq_str, octave_char_matrix_sq_str, lt);
+  INSTALL_BINOP (op_lt, octave_char_matrix_sq_str, octave_char_matrix_sq_str,
+                 lt);
 
   INSTALL_BINOP (op_le, octave_char_matrix_str, octave_char_matrix_str, le);
   INSTALL_BINOP (op_le, octave_char_matrix_str, octave_char_matrix_sq_str, le);
   INSTALL_BINOP (op_le, octave_char_matrix_sq_str, octave_char_matrix_str, le);
-  INSTALL_BINOP (op_le, octave_char_matrix_sq_str, octave_char_matrix_sq_str, le);
+  INSTALL_BINOP (op_le, octave_char_matrix_sq_str, octave_char_matrix_sq_str,
+                 le);
 
   INSTALL_BINOP (op_eq, octave_char_matrix_str, octave_char_matrix_str, eq);
   INSTALL_BINOP (op_eq, octave_char_matrix_str, octave_char_matrix_sq_str, eq);
   INSTALL_BINOP (op_eq, octave_char_matrix_sq_str, octave_char_matrix_str, eq);
-  INSTALL_BINOP (op_eq, octave_char_matrix_sq_str, octave_char_matrix_sq_str, eq);
+  INSTALL_BINOP (op_eq, octave_char_matrix_sq_str, octave_char_matrix_sq_str,
+                 eq);
 
   INSTALL_BINOP (op_ge, octave_char_matrix_str, octave_char_matrix_str, ge);
   INSTALL_BINOP (op_ge, octave_char_matrix_str, octave_char_matrix_sq_str, ge);
   INSTALL_BINOP (op_ge, octave_char_matrix_sq_str, octave_char_matrix_str, ge);
-  INSTALL_BINOP (op_ge, octave_char_matrix_sq_str, octave_char_matrix_sq_str, ge);
+  INSTALL_BINOP (op_ge, octave_char_matrix_sq_str, octave_char_matrix_sq_str,
+                 ge);
 
   INSTALL_BINOP (op_gt, octave_char_matrix_str, octave_char_matrix_str, gt);
   INSTALL_BINOP (op_gt, octave_char_matrix_str, octave_char_matrix_sq_str, gt);
   INSTALL_BINOP (op_gt, octave_char_matrix_sq_str, octave_char_matrix_str, gt);
-  INSTALL_BINOP (op_gt, octave_char_matrix_sq_str, octave_char_matrix_sq_str, gt);
+  INSTALL_BINOP (op_gt, octave_char_matrix_sq_str, octave_char_matrix_sq_str,
+                 gt);
 
   INSTALL_BINOP (op_ne, octave_char_matrix_str, octave_char_matrix_str, ne);
   INSTALL_BINOP (op_ne, octave_char_matrix_str, octave_char_matrix_sq_str, ne);
   INSTALL_BINOP (op_ne, octave_char_matrix_sq_str, octave_char_matrix_str, ne);
-  INSTALL_BINOP (op_ne, octave_char_matrix_sq_str, octave_char_matrix_sq_str, ne);
+  INSTALL_BINOP (op_ne, octave_char_matrix_sq_str, octave_char_matrix_sq_str,
+                 ne);
 
   INSTALL_CATOP (octave_char_matrix_str, octave_char_matrix_str, str_str);
   INSTALL_CATOP (octave_char_matrix_str, octave_char_matrix_sq_str, str_str);
   INSTALL_CATOP (octave_char_matrix_sq_str, octave_char_matrix_str, str_str);
   INSTALL_CATOP (octave_char_matrix_sq_str, octave_char_matrix_sq_str, str_str);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_str, octave_char_matrix_str, assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_str, octave_char_matrix_sq_str, assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_sq_str, octave_char_matrix_str, assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_sq_str, octave_char_matrix_sq_str, assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_str, octave_char_matrix_str,
+                    assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_str,
+                    octave_char_matrix_sq_str,
+                    assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_sq_str,
+                    octave_char_matrix_str,
+                    assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_sq_str,
+                    octave_char_matrix_sq_str, assign);
 
-  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_str, octave_null_matrix, null_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_str, octave_null_str, null_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_str, octave_null_sq_str, null_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_sq_str, octave_null_matrix, null_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_sq_str, octave_null_str, null_assign);
-  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_sq_str, octave_null_sq_str, null_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_str, octave_null_matrix,
+                    null_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_str, octave_null_str,
+                    null_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_str, octave_null_sq_str,
+                    null_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_sq_str, octave_null_matrix,
+                    null_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_sq_str, octave_null_str,
+                    null_assign);
+  INSTALL_ASSIGNOP (op_asn_eq, octave_char_matrix_sq_str, octave_null_sq_str,
+                    null_assign);
 
 }
diff --git a/libinterp/operators/ops.h b/libinterp/operators/ops.h
--- a/libinterp/operators/ops.h
+++ b/libinterp/operators/ops.h
@@ -240,17 +240,17 @@ extern void install_ops (void);
 
 #define DEFNDUNOP_OP(name, t, e, op) \
   UNOPDECL (name, a) \
   { \
     CAST_UNOP_ARG (const CONCAT2(octave_, t)&); \
     return octave_value (op v.CONCAT2(e, _value) ()); \
   }
 
-// FIXME -- in some cases, the constructor isn't necessary.
+// FIXME: in some cases, the constructor isn't necessary.
 
 #define DEFUNOP_FN(name, t, f) \
   UNOPDECL (name, a) \
   { \
     CAST_UNOP_ARG (const CONCAT2(octave_, t)&); \
     return octave_value (f (v.CONCAT2(t, _value) ())); \
   }
 
@@ -313,17 +313,17 @@ extern void install_ops (void);
 #define DEFNDBINOP_OP(name, t1, t2, e1, e2, op) \
   BINOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (const CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
     return octave_value \
       (v1.CONCAT2(e1, _value) () op v2.CONCAT2(e2, _value) ()); \
   }
 
-// FIXME -- in some cases, the constructor isn't necessary.
+// FIXME: in some cases, the constructor isn't necessary.
 
 #define DEFBINOP_FN(name, t1, t2, f) \
   BINOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (const CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
     return octave_value (f (v1.CONCAT2(t1, _value) (), v2.CONCAT2(t2, _value) ())); \
   }
 
@@ -347,17 +347,17 @@ extern void install_ops (void);
                       const Array<octave_idx_type>& ra_idx)
 
 #define DEFCATOPX(name, t1, t2) \
   CATOPDECL (name, , )
 
 #define DEFCATOP(name, t1, t2)  \
   CATOPDECL (name, a1, a2)
 
-// FIXME -- in some cases, the constructor isn't necessary.
+// FIXME: in some cases, the constructor isn't necessary.
 
 #define DEFCATOP_FN(name, t1, t2, f) \
   CATOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
     return octave_value (v1.CONCAT2(t1, _value) () . f (v2.CONCAT2(t2, _value) (), ra_idx)); \
   }
 
diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -94,22 +94,22 @@ public:
 
   // Track nesting of square brackets, curly braces, and parentheses.
 
   class bbp_nesting_level
   {
   private:
 
     enum bracket_type
-      {
-        BRACKET = 1,
-        BRACE = 2,
-        PAREN = 3,
-        ANON_FCN_BODY = 4
-      };
+    {
+      BRACKET = 1,
+      BRACE = 2,
+      PAREN = 3,
+      ANON_FCN_BODY = 4
+    };
 
   public:
 
     bbp_nesting_level (void) : context () { }
 
     bbp_nesting_level (const bbp_nesting_level& nl) : context (nl.context) { }
 
     bbp_nesting_level& operator = (const bbp_nesting_level& nl)
@@ -257,24 +257,24 @@ public:
     size_t sz;
 
     // No copying!
 
     token_cache (const token_cache&);
 
     token_cache& operator = (const token_cache&);
   };
-  
+
   lexical_feedback (void)
     : end_of_input (false), at_beginning_of_statement (true),
       looking_at_anon_fcn_args (false), looking_at_return_list (false),
       looking_at_parameter_list (false), looking_at_decl_list (false),
       looking_at_initializer_expression (false),
       looking_at_matrix_or_assign_lhs (false),
-      looking_for_object_index (false), 
+      looking_for_object_index (false),
       looking_at_indirect_ref (false), parsing_class_method (false),
       maybe_classdef_get_set_method (false), parsing_classdef (false),
       quote_is_transpose (false), force_script (false),
       reading_fcn_file (false), reading_script_file (false),
       reading_classdef_file (false),
       input_line_number (1), current_input_column (1),
       bracketflag (0), braceflag (0),
       looping (0), defining_func (0), looking_at_function_handle (0),
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -80,17 +80,18 @@ get_help_from_file (const std::string& n
 
 extern OCTINTERP_API std::string
 get_help_from_file (const std::string& nm, bool& symbol_found);
 
 extern OCTINTERP_API std::string lookup_autoload (const std::string& nm);
 
 extern OCTINTERP_API string_vector autoloaded_functions (void);
 
-extern OCTINTERP_API string_vector reverse_lookup_autoload (const std::string& nm);
+extern OCTINTERP_API string_vector
+reverse_lookup_autoload (const std::string& nm);
 
 extern OCTINTERP_API octave_function *
 load_fcn_from_file (const std::string& file_name,
                     const std::string& dir_name = std::string (),
                     const std::string& dispatch_type = std::string (),
                     const std::string& fcn_name = std::string (),
                     bool autoload = false);
 
@@ -117,17 +118,17 @@ extern OCTINTERP_API octave_value_list
 eval_string (const std::string&, bool silent, int& parse_status, int hargout);
 
 extern OCTINTERP_API octave_value
 eval_string (const std::string&, bool silent, int& parse_status);
 
 extern OCTINTERP_API void cleanup_statement_list (tree_statement_list **lst);
 
 // Global access to currently active lexer.
-// FIXME -- to be removed after more parser+lexer refactoring.
+// FIXME: to be removed after more parser+lexer refactoring.
 extern octave_base_lexer *LEXER;
 
 class
 octave_base_parser
 {
 public:
 
   octave_base_parser (octave_base_lexer& lxr)
diff --git a/libinterp/parse-tree/pt-arg-list.cc b/libinterp/parse-tree/pt-arg-list.cc
--- a/libinterp/parse-tree/pt-arg-list.cc
+++ b/libinterp/parse-tree/pt-arg-list.cc
@@ -122,17 +122,17 @@ tree_argument_list::is_valid_lvalue_list
   return retval;
 }
 
 static const octave_value *indexed_object = 0;
 static int index_position = 0;
 static int num_indices = 0;
 
 DEFCONSTFUN (end, , ,
-  "-*- texinfo -*-\n\
+             "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} end\n\
 The magic index @qcode{\"end\"} refers to the last valid entry in an indexing\n\
 operation.\n\
 \n\
 Example:\n\
 \n\
 @example\n\
 @group\n\
@@ -309,17 +309,17 @@ tree_argument_list::variable_names (void
 
   for (const_iterator p = begin (); p != end (); p++)
     {
       tree_expression *elt = *p;
 
       if (elt->is_identifier ())
         {
           tree_identifier *id = dynamic_cast<tree_identifier *> (elt);
-      
+
           retval.push_back (id->name ());
         }
       else if (elt->is_index_expression ())
         {
           tree_index_expression *idx_expr
             = dynamic_cast<tree_index_expression *> (elt);
 
           retval.push_back (idx_expr->name ());
diff --git a/libinterp/parse-tree/pt-arg-list.h b/libinterp/parse-tree/pt-arg-list.h
--- a/libinterp/parse-tree/pt-arg-list.h
+++ b/libinterp/parse-tree/pt-arg-list.h
@@ -42,37 +42,37 @@ class
 tree_argument_list : public octave_base_list<tree_expression *>
 {
 public:
 
   typedef tree_expression* element_type;
 
   tree_argument_list (void)
     : list_includes_magic_end (false), list_includes_magic_tilde (false),
-    simple_assign_lhs (false) { }
+      simple_assign_lhs (false) { }
 
   tree_argument_list (tree_expression *t)
     : list_includes_magic_end (false), list_includes_magic_tilde (false),
-    simple_assign_lhs (false)
+      simple_assign_lhs (false)
   { append (t); }
 
   ~tree_argument_list (void);
 
   bool has_magic_end (void) const;
 
   bool has_magic_tilde (void) const
-    { return list_includes_magic_tilde; }
+  { return list_includes_magic_tilde; }
 
   tree_expression *remove_front (void)
-    {
-      iterator p = begin ();
-      tree_expression *retval = *p;
-      erase (p);
-      return retval;
-    }
+  {
+    iterator p = begin ();
+    tree_expression *retval = *p;
+    erase (p);
+    return retval;
+  }
 
   void append (const element_type& s);
 
   void mark_as_simple_assign_lhs (void) { simple_assign_lhs = true; }
 
   bool is_simple_assign_lhs (void) { return simple_assign_lhs; }
 
   bool all_elements_are_constant (void) const;
diff --git a/libinterp/parse-tree/pt-assign.cc b/libinterp/parse-tree/pt-assign.cc
--- a/libinterp/parse-tree/pt-assign.cc
+++ b/libinterp/parse-tree/pt-assign.cc
@@ -43,17 +43,18 @@ along with Octave; see the file COPYING.
 #include "utils.h"
 #include "variables.h"
 
 // Simple assignment expressions.
 
 tree_simple_assignment::tree_simple_assignment
   (tree_expression *le, tree_expression *re,
    bool plhs, int l, int c, octave_value::assign_op t)
-    : tree_expression (l, c), lhs (le), rhs (re), preserve (plhs), etype (t) { }
+ : tree_expression (l, c), lhs (le), rhs (re), preserve (plhs), etype (t)
+{ }
 
 tree_simple_assignment::~tree_simple_assignment (void)
 {
   if (! preserve)
     delete lhs;
 
   delete rhs;
 }
@@ -173,17 +174,18 @@ tree_simple_assignment::accept (tree_wal
   tw.visit_simple_assignment (*this);
 }
 
 // Multi-valued assignment expressions.
 
 tree_multi_assignment::tree_multi_assignment
   (tree_argument_list *lst, tree_expression *r,
    bool plhs, int l, int c)
-    : tree_expression (l, c), lhs (lst), rhs (r), preserve (plhs) { }
+  : tree_expression (l, c), lhs (lst), rhs (r), preserve (plhs)
+{ }
 
 tree_multi_assignment::~tree_multi_assignment (void)
 {
   if (! preserve)
     delete lhs;
 
   delete rhs;
 }
@@ -196,17 +198,17 @@ tree_multi_assignment::rvalue1 (int narg
   const octave_value_list tmp = rvalue (nargout);
 
   if (! tmp.empty ())
     retval = tmp(0);
 
   return retval;
 }
 
-// FIXME -- this works, but it would look a little better if
+// FIXME: this works, but it would look a little better if
 // it were broken up into a couple of separate functions.
 
 octave_value_list
 tree_multi_assignment::rvalue (int)
 {
   octave_value_list retval;
 
   if (error_state)
@@ -223,18 +225,20 @@ tree_multi_assignment::rvalue (int)
 
       for (std::list<octave_lvalue>::const_iterator p = lvalue_list.begin ();
            p != lvalue_list.end ();
            p++)
         n_out += p->numel ();
 
       // The following trick is used to keep rhs_val constant.
       const octave_value_list rhs_val1 = rhs->rvalue (n_out, &lvalue_list);
-      const octave_value_list rhs_val = (rhs_val1.length () == 1 && rhs_val1(0).is_cs_list ()
-                                         ? rhs_val1(0).list_value () : rhs_val1);
+      const octave_value_list rhs_val = (rhs_val1.length () == 1
+                                         && rhs_val1(0).is_cs_list ()
+                                         ? rhs_val1(0).list_value ()
+                                         : rhs_val1);
 
       if (error_state)
         return retval;
 
       octave_idx_type k = 0;
 
       octave_idx_type n = rhs_val.length ();
 
@@ -256,17 +260,18 @@ tree_multi_assignment::rvalue (int)
 
           if (nel != 1)
             {
               if (k + nel <= n)
                 {
                   // This won't do a copy.
                   octave_value_list ovl  = rhs_val.slice (k, nel);
 
-                  ult.assign (octave_value::op_asn_eq, octave_value (ovl, true));
+                  ult.assign (octave_value::op_asn_eq,
+                              octave_value (ovl, true));
 
                   if (! error_state)
                     {
                       retval_list.push_back (ovl);
 
                       k += nel;
                     }
                 }
diff --git a/libinterp/parse-tree/pt-assign.h b/libinterp/parse-tree/pt-assign.h
--- a/libinterp/parse-tree/pt-assign.h
+++ b/libinterp/parse-tree/pt-assign.h
@@ -138,17 +138,18 @@ public:
 
   tree_expression *right_hand_side (void) { return rhs; }
 
   tree_expression *dup (symbol_table::scope_id scope,
                         symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
-  octave_value::assign_op op_type (void) const { return octave_value::op_asn_eq; }
+  octave_value::assign_op op_type (void) const
+  { return octave_value::op_asn_eq; }
 
 private:
 
   // The left hand side of the assignment.
   tree_argument_list *lhs;
 
   // The right hand side of the assignment.
   tree_expression *rhs;
diff --git a/libinterp/parse-tree/pt-binop.cc b/libinterp/parse-tree/pt-binop.cc
--- a/libinterp/parse-tree/pt-binop.cc
+++ b/libinterp/parse-tree/pt-binop.cc
@@ -274,17 +274,17 @@ tree_boolean_expression::dup (symbol_tab
                                    line (), column (), etype);
 
   new_be->copy_base (*this);
 
   return new_be;
 }
 
 DEFUN (do_braindead_shortcircuit_evaluation, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} do_braindead_shortcircuit_evaluation ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} do_braindead_shortcircuit_evaluation (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} do_braindead_shortcircuit_evaluation (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will\n\
 do short-circuit evaluation of @samp{|} and @samp{&} operators inside the\n\
 conditions of if or while statements.\n\
 \n\
 This feature is only provided for compatibility with @sc{matlab} and should\n\
diff --git a/libinterp/parse-tree/pt-binop.h b/libinterp/parse-tree/pt-binop.h
--- a/libinterp/parse-tree/pt-binop.h
+++ b/libinterp/parse-tree/pt-binop.h
@@ -51,47 +51,46 @@ public:
   tree_binary_expression (tree_expression *a, tree_expression *b,
                           int l = -1, int c = -1,
                           octave_value::binary_op t
                             = octave_value::unknown_binary_op)
     : tree_expression (l, c), op_lhs (a), op_rhs (b), etype (t),
       eligible_for_braindead_shortcircuit (false) { }
 
   ~tree_binary_expression (void)
-    {
-      delete op_lhs;
-      delete op_rhs;
-    }
+  {
+    delete op_lhs;
+    delete op_rhs;
+  }
 
   void mark_braindead_shortcircuit (const std::string& file)
-    {
-      if (etype == octave_value::op_el_and
-          || etype == octave_value::op_el_or)
-        {
-          if (file.empty ())
-            warning_with_id ("Octave:possible-matlab-short-circuit-operator",
-                             "possible Matlab-style short-circuit operator at line %d, column %d",
-                             line (), column ());
-          else
-            warning_with_id ("Octave:possible-matlab-short-circuit-operator",
-                             "%s: possible Matlab-style short-circuit operator at line %d, column %d",
-                             file.c_str (), line (), column ());
+  {
+    if (etype == octave_value::op_el_and || etype == octave_value::op_el_or)
+      {
+        if (file.empty ())
+          warning_with_id ("Octave:possible-matlab-short-circuit-operator",
+                           "possible Matlab-style short-circuit operator at line %d, column %d",
+                           line (), column ());
+        else
+          warning_with_id ("Octave:possible-matlab-short-circuit-operator",
+                           "%s: possible Matlab-style short-circuit operator at line %d, column %d",
+                           file.c_str (), line (), column ());
 
-          eligible_for_braindead_shortcircuit = true;
+        eligible_for_braindead_shortcircuit = true;
 
-          op_lhs->mark_braindead_shortcircuit (file);
-          op_rhs->mark_braindead_shortcircuit (file);
-        }
-    }
+        op_lhs->mark_braindead_shortcircuit (file);
+        op_rhs->mark_braindead_shortcircuit (file);
+      }
+  }
 
   bool has_magic_end (void) const
-    {
-      return ((op_lhs && op_lhs->has_magic_end ())
-              || (op_rhs && op_rhs->has_magic_end ()));
-    }
+  {
+    return ((op_lhs && op_lhs->has_magic_end ())
+            || (op_rhs && op_rhs->has_magic_end ()));
+  }
 
   bool is_binary_expression (void) const { return true; }
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue1 (int nargout = 1);
 
   octave_value_list rvalue (int nargout);
@@ -133,21 +132,21 @@ private:
 // Boolean expressions.
 
 class
 tree_boolean_expression : public tree_binary_expression
 {
 public:
 
   enum type
-    {
-      unknown,
-      bool_and,
-      bool_or
-    };
+  {
+    unknown,
+    bool_and,
+    bool_or
+  };
 
   tree_boolean_expression (int l = -1, int c = -1, type t = unknown)
     : tree_binary_expression (l, c), etype (t) { }
 
   tree_boolean_expression (tree_expression *a, tree_expression *b,
                            int l = -1, int c = -1, type t = unknown)
     : tree_binary_expression (a, b, l, c), etype (t) { }
 
diff --git a/libinterp/parse-tree/pt-bp.h b/libinterp/parse-tree/pt-bp.h
--- a/libinterp/parse-tree/pt-bp.h
+++ b/libinterp/parse-tree/pt-bp.h
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 #include "toplev.h"
 
 class tree;
 class tree_decl_command;
 
 class
 tree_breakpoint : public tree_walker
 {
- public:
+public:
 
   enum action { set = 1, clear = 2, list = 3 };
 
   tree_breakpoint (int l, action a)
     : line (l), act (a), found (false), bp_list () { }
 
   ~tree_breakpoint (void) { }
 
@@ -131,17 +131,17 @@ tree_breakpoint : public tree_walker
   void visit_try_catch_command (tree_try_catch_command&);
 
   void visit_unwind_protect_command (tree_unwind_protect_command&);
 
   octave_value_list get_list (void) { return bp_list; }
 
   int get_line (void) { return found ? line : 0; }
 
- private:
+private:
 
   void do_decl_command (tree_decl_command&);
 
   void take_action (tree& tr);
 
   void take_action (tree_statement& stmt);
 
   // Statement line number we are looking for.
diff --git a/libinterp/parse-tree/pt-cbinop.cc b/libinterp/parse-tree/pt-cbinop.cc
--- a/libinterp/parse-tree/pt-cbinop.cc
+++ b/libinterp/parse-tree/pt-cbinop.cc
@@ -122,17 +122,18 @@ simplify_ldiv_op (tree_expression *&a, t
     retop = octave_value::op_trans_ldiv;
 
   return retop;
 }
 
 // Possibly contract and/or with negation.
 
 static octave_value::compound_binary_op
-simplify_and_or_op (tree_expression *&a, tree_expression *&b, octave_value::binary_op op)
+simplify_and_or_op (tree_expression *&a, tree_expression *&b,
+                    octave_value::binary_op op)
 {
   octave_value::compound_binary_op retop
     = octave_value::unknown_compound_binary_op;
 
   octave_value::unary_op opa = strip_not (a);
 
   if (opa == octave_value::op_not)
     {
@@ -180,13 +181,15 @@ maybe_compound_binary_expression (tree_e
       break;
 
     default:
       ct = octave_value::unknown_compound_binary_op;
       break;
     }
 
   tree_binary_expression *ret = (ct == octave_value::unknown_compound_binary_op)
-    ? new tree_binary_expression (a, b, l, c, t)
-    : new tree_compound_binary_expression (a, b, l, c, t, ca, cb, ct);
+                                ? new tree_binary_expression (a, b, l, c, t)
+                                : new tree_compound_binary_expression (a, b, l,
+                                                                       c, t, ca,
+                                                                       cb, ct);
 
   return ret;
 }
diff --git a/libinterp/parse-tree/pt-check.cc b/libinterp/parse-tree/pt-check.cc
--- a/libinterp/parse-tree/pt-check.cc
+++ b/libinterp/parse-tree/pt-check.cc
@@ -513,18 +513,17 @@ tree_checker::visit_try_catch_command (t
 
   tree_statement_list *catch_code = cmd.cleanup ();
 
   if (catch_code)
     catch_code->accept (*this);
 }
 
 void
-tree_checker::visit_unwind_protect_command
-  (tree_unwind_protect_command& cmd)
+tree_checker::visit_unwind_protect_command (tree_unwind_protect_command& cmd)
 {
   tree_statement_list *unwind_protect_code = cmd.body ();
 
   if (unwind_protect_code)
     unwind_protect_code->accept (*this);
 
   tree_statement_list *cleanup_code = cmd.cleanup ();
 
diff --git a/libinterp/parse-tree/pt-colon.cc b/libinterp/parse-tree/pt-colon.cc
--- a/libinterp/parse-tree/pt-colon.cc
+++ b/libinterp/parse-tree/pt-colon.cc
@@ -265,17 +265,18 @@ tree_colon_expression::column (void) con
 
 tree_expression *
 tree_colon_expression::dup (symbol_table::scope_id scope,
                             symbol_table::context_id context) const
 {
   tree_colon_expression *new_ce = new
     tree_colon_expression (op_base ? op_base->dup (scope, context) : 0,
                            op_limit ? op_limit->dup (scope, context) : 0,
-                           op_increment ? op_increment->dup (scope, context) : 0,
+                           op_increment ? op_increment->dup (scope, context)
+                                        : 0,
                            line (), column ());
 
   new_ce->copy_base (*new_ce);
 
   return new_ce;
 }
 
 void
diff --git a/libinterp/parse-tree/pt-colon.h b/libinterp/parse-tree/pt-colon.h
--- a/libinterp/parse-tree/pt-colon.h
+++ b/libinterp/parse-tree/pt-colon.h
@@ -50,30 +50,30 @@ public:
       op_increment (0), save_base (false) { }
 
   tree_colon_expression (tree_expression *bas, tree_expression *lim,
                          tree_expression *inc, int l = -1, int c = -1)
     : tree_expression (l, c), op_base (bas), op_limit (lim),
       op_increment (inc), save_base (false) { }
 
   ~tree_colon_expression (void)
-    {
-      if (! save_base)
-        delete op_base;
+  {
+    if (! save_base)
+      delete op_base;
 
-      delete op_limit;
-      delete op_increment;
-    }
+    delete op_limit;
+    delete op_increment;
+  }
 
   bool has_magic_end (void) const
-    {
-      return ((op_base && op_base->has_magic_end ())
-              || (op_limit && op_limit->has_magic_end ())
-              || (op_increment && op_increment->has_magic_end ()));
-    }
+  {
+    return ((op_base && op_base->has_magic_end ())
+            || (op_limit && op_limit->has_magic_end ())
+            || (op_increment && op_increment->has_magic_end ()));
+  }
 
   void preserve_base (void) { save_base = true; }
 
   tree_colon_expression *append (tree_expression *t);
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue1 (int nargout = 1);
diff --git a/libinterp/parse-tree/pt-const.cc b/libinterp/parse-tree/pt-const.cc
--- a/libinterp/parse-tree/pt-const.cc
+++ b/libinterp/parse-tree/pt-const.cc
@@ -32,17 +32,18 @@ along with Octave; see the file COPYING.
 #include "pt-const.h"
 #include "pt-walk.h"
 
 // We are likely to have a lot of tree_constant objects to allocate,
 // so make the grow_size large.
 DEFINE_OCTAVE_ALLOCATOR2 (tree_constant, 1024);
 
 void
-tree_constant::print (std::ostream& os, bool pr_as_read_syntax, bool pr_orig_text)
+tree_constant::print (std::ostream& os, bool pr_as_read_syntax,
+                      bool pr_orig_text)
 {
   if (pr_orig_text && ! orig_text.empty ())
     os << orig_text;
   else
     val.print (os, pr_as_read_syntax);
 }
 
 void
diff --git a/libinterp/parse-tree/pt-decl.cc b/libinterp/parse-tree/pt-decl.cc
--- a/libinterp/parse-tree/pt-decl.cc
+++ b/libinterp/parse-tree/pt-decl.cc
@@ -128,20 +128,21 @@ tree_global_command::accept (tree_walker
 {
   tw.visit_global_command (*this);
 }
 
 // Static.
 
 tree_command *
 tree_persistent_command::dup (symbol_table::scope_id scope,
-                          symbol_table::context_id context) const
+                              symbol_table::context_id context) const
 {
   return
-    new tree_persistent_command (init_list ? init_list->dup (scope, context) : 0,
+    new tree_persistent_command (init_list ? init_list->dup (scope, context)
+                                           : 0,
                                  line (), column ());
 }
 
 void
 tree_persistent_command::accept (tree_walker& tw)
 {
   tw.visit_persistent_command (*this);
 }
diff --git a/libinterp/parse-tree/pt-decl.h b/libinterp/parse-tree/pt-decl.h
--- a/libinterp/parse-tree/pt-decl.h
+++ b/libinterp/parse-tree/pt-decl.h
@@ -113,24 +113,24 @@ tree_decl_init_list : public octave_base
 {
 public:
 
   tree_decl_init_list (void) { }
 
   tree_decl_init_list (tree_decl_elt *t) { append (t); }
 
   ~tree_decl_init_list (void)
-    {
-      while (! empty ())
-        {
-          iterator p = begin ();
-          delete *p;
-          erase (p);
-        }
-    }
+  {
+    while (! empty ())
+      {
+        iterator p = begin ();
+        delete *p;
+        erase (p);
+      }
+  }
 
   tree_decl_init_list *dup (symbol_table::scope_id scope,
                             symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -247,21 +247,21 @@ tree_decl_elt::eval (void)
 
   if (id && expr)
     {
       octave_lvalue ult = id->lvalue ();
 
       octave_value init_val = expr->rvalue1 ();
 
       if (! error_state)
-       {
-         ult.assign (octave_value::op_asn_eq, init_val);
+        {
+          ult.assign (octave_value::op_asn_eq, init_val);
 
-         retval = true;
-       }
+          retval = true;
+        }
     }
 
   return retval;
 }
 #endif
 
 void
 tree_evaluator::visit_decl_init_list (tree_decl_init_list&)
@@ -295,17 +295,17 @@ void
 tree_evaluator::visit_simple_for_command (tree_simple_for_command& cmd)
 {
   if (error_state)
     return;
 
   if (debug_mode)
     do_breakpoint (cmd.is_breakpoint ());
 
-  // FIXME -- need to handle PARFOR loops here using cmd.in_parallel ()
+  // FIXME: need to handle PARFOR loops here using cmd.in_parallel ()
   // and cmd.maxproc_expr ();
 
   unwind_protect frame;
 
   frame.protect_var (in_loop_command);
 
   in_loop_command = true;
 
@@ -700,18 +700,18 @@ tree_evaluator::visit_statement (tree_st
       if (statement_context == function || statement_context == script)
         {
           // Skip commands issued at a debug> prompt to avoid disturbing
           // the state of the program we are debugging.
 
           if (! Vdebugging)
             octave_call_stack::set_location (stmt.line (), stmt.column ());
 
-          // FIXME -- we need to distinguish functions from scripts to
-          // get this right.
+          // FIXME: we need to distinguish functions from scripts
+          //        to get this right.
           if ((statement_context == script
                && ((Vecho_executing_commands & ECHO_SCRIPTS)
                    || (Vecho_executing_commands & ECHO_FUNCTIONS)))
               || (statement_context == function
                   && (Vecho_executing_commands & ECHO_FUNCTIONS)))
             stmt.echo_code ();
         }
 
@@ -719,22 +719,22 @@ tree_evaluator::visit_statement (tree_st
         {
           if (cmd)
             cmd->accept (*this);
           else
             {
               if (debug_mode)
                 do_breakpoint (expr->is_breakpoint ());
 
-              // FIXME -- maybe all of this should be packaged in
+              // FIXME: maybe all of this should be packaged in
               // one virtual function that returns a flag saying whether
               // or not the expression will take care of binding ans and
               // printing the result.
 
-              // FIXME -- it seems that we should just have to
+              // FIXME: it seems that we should just have to
               // call expr->rvalue1 () and that should take care of
               // everything, binding ans as necessary?
 
               bool do_bind_ans = false;
 
               if (expr->is_identifier ())
                 {
                   tree_identifier *id = dynamic_cast<tree_identifier *> (expr);
@@ -755,17 +755,17 @@ tree_evaluator::visit_statement (tree_st
             }
         }
       catch (octave_execution_exception)
         {
           gripe_library_execution_error ();
         }
       catch (std::bad_alloc)
         {
-          // FIXME -- We want to use error_with_id here so that we set
+          // FIXME: We want to use error_with_id here so that we set
           // the error state, give users control over this error
           // message, and so that we set the error_state appropriately
           // so we'll get stack trace info when appropriate.  But
           // error_with_id will require some memory allocations.  Is
           // there anything we can do to make those more likely to
           // succeed?
 
           error_with_id ("Octave:bad-alloc",
@@ -983,17 +983,17 @@ tree_evaluator::do_unwind_protect_cleanu
   tree_break_command::breaking = 0;
 
   if (list)
     list->accept (*this);
 
   // The unwind_protects are popped off the stack in the reverse of
   // the order they are pushed on.
 
-  // FIXME -- these statements say that if we see a break or
+  // FIXME: these statements say that if we see a break or
   // return statement in the cleanup block, that we want to use the
   // new value of the breaking or returning flag instead of restoring
   // the previous value.  Is that the right thing to do?  I think so.
   // Consider the case of
   //
   //   function foo ()
   //     unwind_protect
   //       stderr << "1: this should always be executed\n";
@@ -1246,17 +1246,17 @@ tree_evaluator::do_breakpoint (bool is_b
 
 octave_value
 tree_evaluator::do_keyboard (const octave_value_list& args) const
 {
   return ::do_keyboard (args);
 }
 
 DEFUN (max_recursion_depth, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} max_recursion_depth ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} max_recursion_depth (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} max_recursion_depth (@var{new_val}, \"local\")\n\
 Query or set the internal limit on the number of times a function may\n\
 be called recursively.  If the limit is exceeded, an error message is\n\
 printed and control returns to the top level.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
@@ -1275,17 +1275,17 @@ The original variable value is restored 
 %! assert (max_recursion_depth (), 2*orig_val);
 %! max_recursion_depth (orig_val);
 %! assert (max_recursion_depth (), orig_val);
 
 %!error (max_recursion_depth (1, 2))
 */
 
 DEFUN (silent_functions, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} silent_functions ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} silent_functions (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} silent_functions (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether internal\n\
 output from a function is suppressed.  If this option is disabled,\n\
 Octave will display the results produced by evaluating expressions\n\
 within a function body that are not terminated with a semicolon.\n\
 \n\
diff --git a/libinterp/parse-tree/pt-except.h b/libinterp/parse-tree/pt-except.h
--- a/libinterp/parse-tree/pt-except.h
+++ b/libinterp/parse-tree/pt-except.h
@@ -35,18 +35,18 @@ class tree_walker;
 // Simple exception handling.
 
 class
 tree_try_catch_command : public tree_command
 {
 public:
 
   tree_try_catch_command (int l = -1, int c = -1)
-    : tree_command (l, c), try_code (0), catch_code (0), expr_id (0), lead_comm (0),
-      mid_comm (0), trail_comm (0) { }
+    : tree_command (l, c), try_code (0), catch_code (0), expr_id (0),
+      lead_comm (0), mid_comm (0), trail_comm (0) { }
 
   tree_try_catch_command (tree_statement_list *tc, tree_statement_list *cc,
                           tree_identifier *id,
                           octave_comment_list *cl = 0,
                           octave_comment_list *cm = 0,
                           octave_comment_list *ct = 0,
                           int l = -1, int c = -1)
     : tree_command (l, c), try_code (tc), catch_code (cc), expr_id (id),
diff --git a/libinterp/parse-tree/pt-exp.h b/libinterp/parse-tree/pt-exp.h
--- a/libinterp/parse-tree/pt-exp.h
+++ b/libinterp/parse-tree/pt-exp.h
@@ -75,18 +75,18 @@ public:
   virtual bool lvalue_ok (void) const { return false; }
 
   virtual bool rvalue_ok (void) const { return false; }
 
   virtual octave_value rvalue1 (int nargout = 1);
 
   virtual octave_value_list rvalue (int nargout);
 
-  virtual octave_value_list rvalue (int nargout,
-                                    const std::list<octave_lvalue> *lvalue_list);
+  virtual octave_value_list
+  rvalue (int nargout, const std::list<octave_lvalue> *lvalue_list);
 
   virtual octave_lvalue lvalue (void);
 
   int paren_count (void) const { return num_parens; }
 
   bool is_postfix_indexed (void) const { return postfix_indexed; }
 
   // Check if the result of the expression should be printed.
@@ -98,39 +98,39 @@ public:
 
   virtual std::string name (void) const { return "<unknown>"; }
 
   virtual std::string original_text (void) const;
 
   virtual void mark_braindead_shortcircuit (const std::string&) { }
 
   tree_expression *mark_in_parens (void)
-    {
-      num_parens++;
-      return this;
-    }
+  {
+    num_parens++;
+    return this;
+  }
 
   tree_expression *mark_postfix_indexed (void)
-    {
-      postfix_indexed = true;
-      return this;
-    }
+  {
+    postfix_indexed = true;
+    return this;
+  }
 
   tree_expression *set_print_flag (bool print)
-    {
-      print_flag = print;
-      return this;
-    }
+  {
+    print_flag = print;
+    return this;
+  }
 
   virtual void copy_base (const tree_expression& e)
-    {
-      num_parens = e.num_parens;
-      postfix_indexed = e.postfix_indexed;
-      print_flag = e.print_flag;
-    }
+  {
+    num_parens = e.num_parens;
+    postfix_indexed = e.postfix_indexed;
+    print_flag = e.print_flag;
+  }
 
 protected:
 
   // A count of the number of times this expression appears directly
   // inside a set of parentheses.
   //
   //   (((e1)) + e2)  ==> 2 for expression e1
   //                  ==> 1 for expression ((e1)) + e2
diff --git a/libinterp/parse-tree/pt-fcn-handle.cc b/libinterp/parse-tree/pt-fcn-handle.cc
--- a/libinterp/parse-tree/pt-fcn-handle.cc
+++ b/libinterp/parse-tree/pt-fcn-handle.cc
@@ -83,17 +83,17 @@ void
 tree_fcn_handle::accept (tree_walker& tw)
 {
   tw.visit_fcn_handle (*this);
 }
 
 octave_value
 tree_anon_fcn_handle::rvalue1 (int)
 {
-  // FIXME -- should CMD_LIST be limited to a single expression?
+  // FIXME: should CMD_LIST be limited to a single expression?
   // I think that is what Matlab does.
 
   tree_parameter_list *param_list = parameter_list ();
   tree_parameter_list *ret_list = return_list ();
   tree_statement_list *cmd_list = body ();
   symbol_table::scope_id this_scope = scope ();
 
   symbol_table::scope_id new_scope = symbol_table::dup_scope (this_scope);
@@ -107,17 +107,17 @@ tree_anon_fcn_handle::rvalue1 (int)
                                 param_list ? param_list->dup (new_scope, 0) : 0,
                                 ret_list ? ret_list->dup (new_scope, 0) : 0,
                                 cmd_list ? cmd_list->dup (new_scope, 0) : 0);
 
   octave_function *curr_fcn = octave_call_stack::current ();
 
   if (curr_fcn)
     {
-      // FIXME -- maybe it would be better to just stash curr_fcn
+      // FIXME: maybe it would be better to just stash curr_fcn
       // instead of individual bits of info about it?
 
       uf->stash_parent_fcn_name (curr_fcn->name ());
       uf->stash_dir_name (curr_fcn->dir_name ());
 
       symbol_table::scope_id parent_scope = curr_fcn->parent_fcn_scope ();
 
       if (parent_scope < 0)
diff --git a/libinterp/parse-tree/pt-id.cc b/libinterp/parse-tree/pt-id.cc
--- a/libinterp/parse-tree/pt-id.cc
+++ b/libinterp/parse-tree/pt-id.cc
@@ -131,17 +131,17 @@ tree_identifier::lvalue (void)
 
 tree_identifier *
 tree_identifier::dup (symbol_table::scope_id sc,
                       symbol_table::context_id) const
 {
   // The new tree_identifier object contains a symbol_record
   // entry from the duplicated scope.
 
-  // FIXME -- is this the best way?
+  // FIXME: is this the best way?
   symbol_table::symbol_record new_sym
     = symbol_table::find_symbol (name (), sc);
 
   tree_identifier *new_id
     = new tree_identifier (new_sym, line (), column ());
 
   new_id->copy_base (*this);
 
diff --git a/libinterp/parse-tree/pt-id.h b/libinterp/parse-tree/pt-id.h
--- a/libinterp/parse-tree/pt-id.h
+++ b/libinterp/parse-tree/pt-id.h
@@ -151,17 +151,17 @@ public:
 
   std::string name (void) const { return "~"; }
 
   bool is_variable (void) { return false; }
 
   bool is_black_hole (void) { return true; }
 
   tree_black_hole *dup (void) const
-    { return new tree_black_hole; }
+  { return new tree_black_hole; }
 
   octave_lvalue lvalue (void)
-    {
-      return octave_lvalue (); // black hole lvalue
-    }
+  {
+    return octave_lvalue (); // black hole lvalue
+  }
 };
 
 #endif
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -280,17 +280,18 @@ tree_index_expression::make_arg_struct (
 
 octave_value_list
 tree_index_expression::rvalue (int nargout)
 {
   return tree_index_expression::rvalue (nargout, 0);
 }
 
 octave_value_list
-tree_index_expression::rvalue (int nargout, const std::list<octave_lvalue> *lvalue_list)
+tree_index_expression::rvalue (int nargout,
+                               const std::list<octave_lvalue> *lvalue_list)
 {
   octave_value_list retval;
 
   if (error_state)
     return retval;
 
   octave_value first_expr_val;
 
@@ -389,17 +390,18 @@ tree_index_expression::rvalue (int nargo
                 idx.push_back (make_value_list (*p_args, *p_arg_nm, &tmp));
               break;
 
             case '{':
               idx.push_back (make_value_list (*p_args, *p_arg_nm, &tmp));
               break;
 
             case '.':
-              idx.push_back (octave_value (get_struct_index (p_arg_nm, p_dyn_field)));
+              idx.push_back (octave_value (get_struct_index (p_arg_nm,
+                                                             p_dyn_field)));
               break;
 
             default:
               panic_impossible ();
             }
 
           if (error_state)
             break;
diff --git a/libinterp/parse-tree/pt-idx.h b/libinterp/parse-tree/pt-idx.h
--- a/libinterp/parse-tree/pt-idx.h
+++ b/libinterp/parse-tree/pt-idx.h
@@ -80,17 +80,18 @@ public:
   bool lvalue_ok (void) const { return expr->lvalue_ok (); }
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue1 (int nargout = 1);
 
   octave_value_list rvalue (int nargout);
 
-  octave_value_list rvalue (int nargout, const std::list<octave_lvalue> *lvalue_list);
+  octave_value_list rvalue (int nargout,
+                            const std::list<octave_lvalue> *lvalue_list);
 
   octave_lvalue lvalue (void);
 
   tree_index_expression *dup (symbol_table::scope_id scope,
                               symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
diff --git a/libinterp/parse-tree/pt-loop.h b/libinterp/parse-tree/pt-loop.h
--- a/libinterp/parse-tree/pt-loop.h
+++ b/libinterp/parse-tree/pt-loop.h
@@ -44,39 +44,39 @@ class
 tree_while_command : public tree_command
 {
 public:
 
   tree_while_command (int l = -1, int c = -1)
     : tree_command (l, c), expr (0), list (0), lead_comm (0),
       trail_comm (0)
 #ifdef HAVE_LLVM
-    , compiled (0)
+      , compiled (0)
 #endif
   { }
 
   tree_while_command (tree_expression *e,
                       octave_comment_list *lc = 0,
                       octave_comment_list *tc = 0,
                       int l = -1, int c = -1)
     : tree_command (l, c), expr (e), list (0), lead_comm (lc),
       trail_comm (tc)
 #ifdef HAVE_LLVM
-    , compiled (0)
+      , compiled (0)
 #endif
   { }
 
   tree_while_command (tree_expression *e, tree_statement_list *lst,
                       octave_comment_list *lc = 0,
                       octave_comment_list *tc = 0,
                       int l = -1, int c = -1)
     : tree_command (l, c), expr (e), list (lst), lead_comm (lc),
       trail_comm (tc)
 #ifdef HAVE_LLVM
-    , compiled (0)
+      , compiled (0)
 #endif
   { }
 
   ~tree_while_command (void);
 
   tree_expression *condition (void) { return expr; }
 
   tree_statement_list *body (void) { return list; }
@@ -175,32 +175,32 @@ class
 tree_simple_for_command : public tree_command
 {
 public:
 
   tree_simple_for_command (int l = -1, int c = -1)
     : tree_command (l, c), parallel (false), lhs (0), expr (0),
       maxproc (0), list (0), lead_comm (0), trail_comm (0)
 #ifdef HAVE_LLVM
-    , compiled (0)
+      , compiled (0)
 #endif
   { }
 
   tree_simple_for_command (bool parallel_arg, tree_expression *le,
                            tree_expression *re,
                            tree_expression *maxproc_arg,
                            tree_statement_list *lst,
                            octave_comment_list *lc = 0,
                            octave_comment_list *tc = 0,
                            int l = -1, int c = -1)
     : tree_command (l, c), parallel (parallel_arg), lhs (le),
       expr (re), maxproc (maxproc_arg), list (lst),
       lead_comm (lc), trail_comm (tc)
 #ifdef HAVE_LLVM
-    , compiled (0)
+      , compiled (0)
 #endif
   { }
 
   ~tree_simple_for_command (void);
 
   bool in_parallel (void) { return parallel; }
 
   tree_expression *left_hand_side (void) { return lhs; }
diff --git a/libinterp/parse-tree/pt-mat.cc b/libinterp/parse-tree/pt-mat.cc
--- a/libinterp/parse-tree/pt-mat.cc
+++ b/libinterp/parse-tree/pt-mat.cc
@@ -447,17 +447,18 @@ tm_row_const::tm_row_const_rep::cellify 
             {
               if (first_elem)
                 {
                   first_elem = false;
                   dv = this_elt_dv;
                 }
               else if (! dv.hvcat (this_elt_dv, 1))
                 {
-                  eval_error ("horizontal dimensions mismatch", dv, this_elt_dv);
+                  eval_error ("horizontal dimensions mismatch",
+                              dv, this_elt_dv);
                   break;
                 }
             }
         }
     }
 }
 
 class
@@ -742,17 +743,17 @@ single_type_concat (Array<T>& result,
           && row.all_1x1_p ())
         {
           // Optimize all scalars case.
           result.clear (dv);
           assert (static_cast<size_t> (result.numel ()) == row.length ());
           octave_idx_type i = 0;
           for (tm_row_const::iterator q = row.begin ();
                q != row.end () && ! error_state; q++)
-             result(i++) = octave_value_extract<T> (*q);
+            result(i++) = octave_value_extract<T> (*q);
 
           return;
         }
 
       octave_idx_type ncols = row.length (), i = 0;
       OCTAVE_LOCAL_BUFFER (Array<T>, array_list, ncols);
 
       for (tm_row_const::iterator q = row.begin ();
@@ -1363,17 +1364,17 @@ tree_matrix::accept (tree_walker& tw)
 %!assert (isnull ([,]))
 %!assert (isnull ([;]))
 %!assert (isnull ([;;]))
 %!assert (isnull ([;,;]))
 %!assert (isnull ([,;,;,]))
 */
 
 DEFUN (string_fill_char, args, nargout,
-  "-*- texinfo -*-\n\
+       "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} string_fill_char ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} string_fill_char (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} string_fill_char (@var{new_val}, \"local\")\n\
 Query or set the internal variable used to pad all rows of a character\n\
 matrix to the same length.  It must be a single character.  The default\n\
 value is @qcode{\" \"} (a single space).  For example:\n\
 \n\
 @example\n\
diff --git a/libinterp/parse-tree/pt-misc.cc b/libinterp/parse-tree/pt-misc.cc
--- a/libinterp/parse-tree/pt-misc.cc
+++ b/libinterp/parse-tree/pt-misc.cc
@@ -119,17 +119,18 @@ tree_parameter_list::validate (in_or_out
         }
     }
 
   return retval;
 }
 
 void
 tree_parameter_list::initialize_undefined_elements (const std::string& warnfor,
-                                                    int nargout, const octave_value& val)
+                                                    int nargout,
+                                                    const octave_value& val)
 {
   bool warned = false;
 
   int count = 0;
 
   octave_value tmp = symbol_table::varval (".ignored.");
   const Matrix ignored = tmp.is_defined () ? tmp.matrix_value () : Matrix ();
 
@@ -231,17 +232,17 @@ tree_parameter_list::undefine (void)
 std::list<std::string>
 tree_parameter_list::variable_names (void) const
 {
   std::list<std::string> retval;
 
   for (const_iterator p = begin (); p != end (); p++)
     {
       tree_decl_elt *elt = *p;
-      
+
       retval.push_back (elt->name ());
     }
 
   return retval;
 }
 
 octave_value_list
 tree_parameter_list::convert_to_const_vector (int nargout,
diff --git a/libinterp/parse-tree/pt-misc.h b/libinterp/parse-tree/pt-misc.h
--- a/libinterp/parse-tree/pt-misc.h
+++ b/libinterp/parse-tree/pt-misc.h
@@ -43,20 +43,20 @@ class tree_walker;
 // only.
 
 class
 tree_parameter_list : public octave_base_list<tree_decl_elt *>
 {
 public:
 
   enum in_or_out
-    {
-      in = 1,
-      out = 2
-    };
+  {
+    in = 1,
+    out = 2
+  };
 
   tree_parameter_list (void)
     : marked_for_varargs (0) { }
 
   tree_parameter_list (tree_decl_elt *t)
     : marked_for_varargs (0) { append (t); }
 
   tree_parameter_list (tree_identifier *id)
@@ -78,17 +78,18 @@ public:
   void define_from_arg_vector (const octave_value_list& args);
 
   void undefine (void);
 
   bool is_defined (void);
 
   std::list<std::string> variable_names (void) const;
 
-  octave_value_list convert_to_const_vector (int nargout, const Cell& varargout);
+  octave_value_list convert_to_const_vector (int nargout,
+                                             const Cell& varargout);
 
   tree_parameter_list *dup (symbol_table::scope_id scope,
                             symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
diff --git a/libinterp/parse-tree/pt-pr-code.cc b/libinterp/parse-tree/pt-pr-code.cc
--- a/libinterp/parse-tree/pt-pr-code.cc
+++ b/libinterp/parse-tree/pt-pr-code.cc
@@ -1032,18 +1032,17 @@ tree_print_code::visit_try_catch_command
   print_indented_comment (cmd.trailing_comment ());
 
   indent ();
 
   os << "end_try_catch";
 }
 
 void
-tree_print_code::visit_unwind_protect_command
-  (tree_unwind_protect_command& cmd)
+tree_print_code::visit_unwind_protect_command (tree_unwind_protect_command& cmd)
 {
   print_comment_list (cmd.leading_comment ());
 
   indent ();
 
   os << "unwind_protect";
 
   newline ();
diff --git a/libinterp/parse-tree/pt-select.h b/libinterp/parse-tree/pt-select.h
--- a/libinterp/parse-tree/pt-select.h
+++ b/libinterp/parse-tree/pt-select.h
@@ -90,24 +90,24 @@ tree_if_command_list : public octave_bas
 {
 public:
 
   tree_if_command_list (void) { }
 
   tree_if_command_list (tree_if_clause *t) { append (t); }
 
   ~tree_if_command_list (void)
-    {
-      while (! empty ())
-        {
-          iterator p = begin ();
-          delete *p;
-          erase (p);
-        }
-    }
+  {
+    while (! empty ())
+      {
+        iterator p = begin ();
+        delete *p;
+        erase (p);
+      }
+  }
 
   tree_if_command_list *dup (symbol_table::scope_id scope,
                              symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
@@ -220,24 +220,24 @@ tree_switch_case_list : public octave_ba
 {
 public:
 
   tree_switch_case_list (void) { }
 
   tree_switch_case_list (tree_switch_case *t) { append (t); }
 
   ~tree_switch_case_list (void)
-    {
-      while (! empty ())
-        {
-          iterator p = begin ();
-          delete *p;
-          erase (p);
-        }
-    }
+  {
+    while (! empty ())
+      {
+        iterator p = begin ();
+        delete *p;
+        erase (p);
+      }
+  }
 
   tree_switch_case_list *dup (symbol_table::scope_id scope,
                               symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
diff --git a/libinterp/parse-tree/pt-stmt.h b/libinterp/parse-tree/pt-stmt.h
--- a/libinterp/parse-tree/pt-stmt.h
+++ b/libinterp/parse-tree/pt-stmt.h
@@ -133,24 +133,24 @@ public:
     : function_body (false), anon_function_body (false),
       script_body (false) { }
 
   tree_statement_list (tree_statement *s)
     : function_body (false), anon_function_body (false),
       script_body (false) { append (s); }
 
   ~tree_statement_list (void)
-    {
-      while (! empty ())
-        {
-          iterator p = begin ();
-          delete *p;
-          erase (p);
-        }
-    }
+  {
+    while (! empty ())
+      {
+        iterator p = begin ();
+        delete *p;
+        erase (p);
+      }
+  }
 
   void mark_as_function_body (void) { function_body = true; }
 
   void mark_as_anon_function_body (void) { anon_function_body = true; }
 
   void mark_as_script_body (void) { script_body = true; }
 
   bool is_function_body (void) const { return function_body; }
diff --git a/libinterp/parse-tree/token.h b/libinterp/parse-tree/token.h
--- a/libinterp/parse-tree/token.h
+++ b/libinterp/parse-tree/token.h
@@ -28,44 +28,44 @@ along with Octave; see the file COPYING.
 #include "symtab.h"
 
 class
 token
 {
 public:
 
   enum token_type
-    {
-      generic_token,
-      keyword_token,
-      string_token,
-      double_token,
-      ettype_token,
-      sym_rec_token,
-      scls_rec_token,
-      meta_rec_token
-    };
+  {
+    generic_token,
+    keyword_token,
+    string_token,
+    double_token,
+    ettype_token,
+    sym_rec_token,
+    scls_rec_token,
+    meta_rec_token
+  };
 
   enum end_tok_type
-    {
-      simple_end,
-      classdef_end,
-      enumeration_end,
-      events_end,
-      for_end,
-      function_end,
-      if_end,
-      methods_end,
-      parfor_end,
-      properties_end,
-      switch_end,
-      while_end,
-      try_catch_end,
-      unwind_protect_end
-    };
+  {
+    simple_end,
+    classdef_end,
+    enumeration_end,
+    events_end,
+    for_end,
+    function_end,
+    if_end,
+    methods_end,
+    parfor_end,
+    properties_end,
+    switch_end,
+    while_end,
+    try_catch_end,
+    unwind_protect_end
+  };
 
   token (int tv, int l = -1, int c = -1);
   token (int tv, bool is_keyword, int l = -1, int c = -1);
   token (int tv, const std::string& s, int l = -1, int c = -1);
   token (int tv, double d, const std::string& s = std::string (),
          int l = -1, int c = -1);
   token (int tv, end_tok_type t, int l = -1, int c = -1);
   token (int tv, symbol_table::symbol_record *s, int l = -1, int c = -1);
@@ -125,29 +125,29 @@ private:
 
   bool maybe_cmd;
   bool tspc;
   int line_num;
   int column_num;
   int tok_val;
   token_type type_tag;
   union
+  {
+    std::string *str;
+    double num;
+    end_tok_type et;
+    symbol_table::symbol_record *sr;
+    struct
     {
-      std::string *str;
-      double num;
-      end_tok_type et;
-      symbol_table::symbol_record *sr;
-      struct
-        {
-          symbol_table::symbol_record *mr;
-          symbol_table::symbol_record *cr;
-          symbol_table::symbol_record *pr;
-        } sc;
-      struct
-        {
-          symbol_table::symbol_record *cr;
-          symbol_table::symbol_record *pr;
-        } mc;
-    };
+      symbol_table::symbol_record *mr;
+      symbol_table::symbol_record *cr;
+      symbol_table::symbol_record *pr;
+    } sc;
+    struct
+    {
+      symbol_table::symbol_record *cr;
+      symbol_table::symbol_record *pr;
+    } mc;
+  };
   std::string orig_text;
 };
 
 #endif
diff --git a/libinterp/version.cc b/libinterp/version.cc
--- a/libinterp/version.cc
+++ b/libinterp/version.cc
@@ -29,45 +29,45 @@ along with Octave; see the file COPYING.
 #include "defaults.h"
 #include "version.h"
 
 static std::string
 octave_warranty_statement (const std::string& extra_info = std::string ())
 {
   return "There is ABSOLUTELY NO WARRANTY; not even for MERCHANTABILITY or\n\
 FITNESS FOR A PARTICULAR PURPOSE."
-    + extra_info;
+         + extra_info;
 }
 
 static std::string
 format_url (bool html, const std::string& url)
 {
   return html ? "<a href=\"" + url + "\">" + url + "</a>" : url;
 }
 
 std::string
 octave_www_statement (bool html)
 {
   return "Additional information about Octave is available at "
-    + format_url (html, "http://www.octave.org.");
+         + format_url (html, "http://www.octave.org.");
 }
 
 std::string
 octave_contrib_statement (bool html)
 {
   return "Please contribute if you find this software useful.\n\
 For more information, visit "
-    + format_url (html, "http://www.octave.org/get-involved.html");
+         + format_url (html, "http://www.octave.org/get-involved.html");
 }
 
 std::string
 octave_bugs_statement (bool html)
 {
   return "Read " + format_url (html, "http://www.octave.org/bugs.html")
-    + " to learn how to submit bug reports.";
+         + " to learn how to submit bug reports.";
 }
 
 std::string
 octave_name_version_and_copyright (void)
 {
   // The GNU coding standards say that on the first line printed by
   // --version, the version number should follow the last space on the
   // line.
@@ -78,43 +78,43 @@ octave_name_version_and_copyright (void)
 std::string
 octave_name_version_copyright_copying_and_warranty
  (bool html, const std::string& extra_info)
 {
   std::string br = html ? "<br>\n" : "\n";
   std::string sep = html ? "\n</p>\n<p>\n" : "\n\n";
 
   return octave_name_version_and_copyright ()
-    + br
-    + "This is free software; see the source code for copying conditions."
-    + br
-    + octave_warranty_statement (extra_info)
-    + sep
-    + "Octave was configured for \"" OCTAVE_CANONICAL_HOST_TYPE "\".";
+         + br
+         + "This is free software; see the source code for copying conditions."
+         + br
+         + octave_warranty_statement (extra_info)
+         + sep
+         + "Octave was configured for \"" OCTAVE_CANONICAL_HOST_TYPE "\".";
 }
 
 std::string
 octave_name_version_copyright_copying_warranty_and_bugs
   (bool html, const std::string& extra_info)
 {
   std::string sep = html ? "\n</p>\n<p>\n" : "\n\n";
 
   std::string msg;
 
   if (html)
     msg = "<p>\n";
 
   msg += octave_name_version_copyright_copying_and_warranty (html, extra_info)
-    + sep
-    + octave_www_statement (html)
-    + sep
-    + octave_contrib_statement (html)
-    + sep
-    + octave_bugs_statement (html)
-    + (html ? "\n</p>" : "");
+         + sep
+         + octave_www_statement (html)
+         + sep
+         + octave_contrib_statement (html)
+         + sep
+         + octave_bugs_statement (html)
+         + (html ? "\n</p>" : "");
 
   return msg;
 }
 
 std::string
 octave_startup_message (bool html)
 {
   std::string msg
