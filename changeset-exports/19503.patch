# HG changeset patch
# User Mike Miller <mtmiller@ieee.org>
# Date 1380801178 14400
#      Thu Oct 03 07:52:58 2013 -0400
# Node ID 36a26a131209646e2881d71a2ac7891dff6b3c63
# Parent  97c9ba013ed1892fe6a1bd8711ccc09366b18064
Apply Octave coding style to audio project additions

* libinterp/dldfcn/__player_audioplayer__.cc,
libinterp/dldfcn/__recorder_audiorecorder__.cc,
libinterp/dldfcn/audiodevinfo.cc, libinterp/dldfcn/audioinfo.cc,
libinterp/dldfcn/audioread.cc, libinterp/dldfcn/audiowrite.cc,
libinterp/dldfcn/player_class.cc, libinterp/dldfcn/player_class.h,
libinterp/dldfcn/recorder_class.cc, libinterp/dldfcn/recorder_class.h,
scripts/audio/@audioplayer/__get_properties__.m,
scripts/audio/@audioplayer/audioplayer.m,
scripts/audio/@audioplayer/display.m, scripts/audio/@audioplayer/get.m,
scripts/audio/@audioplayer/isplaying.m, scripts/audio/@audioplayer/pause.m,
scripts/audio/@audioplayer/play.m,
scripts/audio/@audioplayer/playblocking.m,
scripts/audio/@audioplayer/resume.m, scripts/audio/@audioplayer/set.m,
scripts/audio/@audioplayer/stop.m, scripts/audio/@audioplayer/subsasgn.m,
scripts/audio/@audioplayer/subsref.m,
scripts/audio/@audiorecorder/__get_properties__.m,
scripts/audio/@audiorecorder/audiorecorder.m,
scripts/audio/@audiorecorder/display.m, scripts/audio/@audiorecorder/get.m,
scripts/audio/@audiorecorder/getaudiodata.m,
scripts/audio/@audiorecorder/getplayer.m,
scripts/audio/@audiorecorder/isrecording.m,
scripts/audio/@audiorecorder/pause.m, scripts/audio/@audiorecorder/play.m,
scripts/audio/@audiorecorder/record.m,
scripts/audio/@audiorecorder/recordblocking.m,
scripts/audio/@audiorecorder/resume.m, scripts/audio/@audiorecorder/set.m,
scripts/audio/@audiorecorder/stop.m,
scripts/audio/@audiorecorder/subsasgn.m,
scripts/audio/@audiorecorder/subsref.m: Apply consistent Octave indentation,
spacing, and quoting styles. Strip trailing whitespace. Remove braces from
one-line if-else blocks. Simplify some variable declarations.

diff --git a/libinterp/dldfcn/__player_audioplayer__.cc b/libinterp/dldfcn/__player_audioplayer__.cc
--- a/libinterp/dldfcn/__player_audioplayer__.cc
+++ b/libinterp/dldfcn/__player_audioplayer__.cc
@@ -26,460 +26,403 @@ along with Octave; see the file COPYING.
 
 #include "oct.h"
 #include "ov-struct.h"
 
 #ifdef HAVE_PORTAUDIO
 #include "player_class.cc"
 #include "recorder_class.cc"
 #endif
-   
-DEFUN_DLD(__player_audioplayer__, args, ,
-"__player_audioplayer__"
-)
+
+DEFUN_DLD (__player_audioplayer__, args, ,
+"__player_audioplayer__")
 {
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   audioplayer* retval = new audioplayer ();
   bool is_function = args(0).is_string () || args(0).is_function_handle () || args(0).is_inline_function ();
   if (is_function)
-    {
-      retval->set_y (args (0).function_value ());
-    }
+    retval->set_y (args(0).function_value ());
   else
-    {
-      retval->set_y (args (0));
-    }
-  retval->set_fs (args (1).int_value ());
+    retval->set_y (args(0));
+  retval->set_fs (args(1).int_value ());
   switch (nargin)
     {
       case 3:
-        retval->set_nbits (args (2).int_value ());
+        retval->set_nbits (args(2).int_value ());
         break;
       case 4:
-        retval->set_nbits (args (2).int_value ());
-        retval->set_id (args (3).int_value ());
+        retval->set_nbits (args(2).int_value ());
+        retval->set_id (args(3).int_value ());
         break;
     }
   if (is_function)
-    {
-      retval->init_fn ();
-    }
+    retval->init_fn ();
   else
-    {
-      retval->init (); 
-    }
-  return octave_value(retval);
+    retval->init ();
+  return octave_value (retval);
 #else
   octave_value retval;
-  error("portaudio not found on your system and thus audio functionality is not present");
+  error ("portaudio not found on your system and thus audio functionality is not present");
   return retval;
 #endif
 }
-   
-DEFUN_DLD(__player_get_channels__, args, ,
-"__player_get_channels__"
-)
+
+DEFUN_DLD (__player_get_channels__, args, ,
+"__player_get_channels__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      audioplayer* player = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      player = &((audioplayer &)rep);
-      retval = octave_value(player->get_channels());
+      const octave_base_value& rep = args(0).get_rep ();
+      audioplayer *player = &((audioplayer &)rep);
+      retval = octave_value (player->get_channels ());
     }
 #else
-  error("portaudio not found on your system and thus audio functionality is not present");
+  error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
-   
-DEFUN_DLD(__player_get_fs__, args, ,
-"__player_get_fs__"
-)
+
+DEFUN_DLD (__player_get_fs__, args, ,
+"__player_get_fs__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      audioplayer* player = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      player = &((audioplayer &)rep);
-      retval = octave_value(player->get_fs());
+      const octave_base_value& rep = args(0).get_rep ();
+      audioplayer *player = &((audioplayer &)rep);
+      retval = octave_value (player->get_fs ());
     }
 #else
-  error("portaudio not found on your system and thus audio functionality is not present");
+  error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__player_get_id__, args, ,
-"__player_get_id__"
-)
+DEFUN_DLD (__player_get_id__, args, ,
+"__player_get_id__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      audioplayer* player = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      player = &((audioplayer &)rep);
-      retval = octave_value(player->get_id());
+      const octave_base_value& rep = args(0).get_rep ();
+      audioplayer *player = &((audioplayer &)rep);
+      retval = octave_value (player->get_id ());
     }
 #else
-  error("portaudio not found on your system and thus audio functionality is not present");
+  error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__player_get_nbits__, args, ,
-"__player_get_nbits__"
-)
+DEFUN_DLD (__player_get_nbits__, args, ,
+"__player_get_nbits__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      audioplayer* player = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      player = &((audioplayer &)rep);
-      retval = octave_value(player->get_nbits());
+      const octave_base_value& rep = args(0).get_rep ();
+      audioplayer *player = &((audioplayer &)rep);
+      retval = octave_value (player->get_nbits ());
     }
 #else
-  error("portaudio not found on your system and thus audio functionality is not present");
+  error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
- 
-DEFUN_DLD(__player_get_sample_number__, args, ,
-"__player_get_sample_number__"
-)
+
+DEFUN_DLD (__player_get_sample_number__, args, ,
+"__player_get_sample_number__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      audioplayer* player = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      player = &((audioplayer &)rep);
-      retval = octave_value(player->get_sample_number());
+      const octave_base_value& rep = args(0).get_rep ();
+      audioplayer *player = &((audioplayer &)rep);
+      retval = octave_value (player->get_sample_number ());
     }
 #else
-  error("portaudio not found on your system and thus audio functionality is not present");
+  error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__player_get_tag__, args, ,
-"__player_get_tag__"
-)
+DEFUN_DLD (__player_get_tag__, args, ,
+"__player_get_tag__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      audioplayer* player = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      player = &((audioplayer &)rep);
+      const octave_base_value& rep = args(0).get_rep ();
+      audioplayer *player = &((audioplayer &)rep);
       retval = octave_value (player->get_tag ());
     }
 #else
-  error("portaudio not found on your system and thus audio functionality is not present");
+  error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__player_get_total_samples__, args, ,
-"__player_get_total_samples__"
-)
+DEFUN_DLD (__player_get_total_samples__, args, ,
+"__player_get_total_samples__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      audioplayer* player = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      player = &((audioplayer &)rep);
-      retval = octave_value(player->get_total_samples());
+      const octave_base_value& rep = args(0).get_rep ();
+      audioplayer *player = &((audioplayer &)rep);
+      retval = octave_value (player->get_total_samples ());
     }
 #else
-  error("portaudio not found on your system and thus audio functionality is not present");
+  error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__player_get_userdata__, args, ,
-"__player_get_userdata__"
-)
+DEFUN_DLD (__player_get_userdata__, args, ,
+"__player_get_userdata__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      audioplayer* player = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      player = &((audioplayer &)rep);
+      const octave_base_value& rep = args(0).get_rep ();
+      audioplayer *player = &((audioplayer &)rep);
       retval = player->get_userdata ();
     }
 #else
-  error("portaudio not found on your system and thus audio functionality is not present");
+  error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__player_isplaying__, args, ,
-"__player_isplaying__"
-)
+DEFUN_DLD (__player_isplaying__, args, ,
+"__player_isplaying__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      audioplayer* player = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      player = &((audioplayer &)rep);
-      if (player->isplaying())
-        {
-          return octave_value(1);
-        }
+      const octave_base_value& rep = args(0).get_rep ();
+      audioplayer *player = &((audioplayer &)rep);
+      if (player->isplaying ())
+        return octave_value (1);
       else
-        {
-          return octave_value(0);
-        }
+        return octave_value (0);
     }
 #else
-  error("portaudio not found on your system and thus audio functionality is not present");
+  error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__player_pause__, args, ,
-"__player_pause__"
-)
+DEFUN_DLD (__player_pause__, args, ,
+"__player_pause__")
+{
+  octave_value retval;
+#ifdef HAVE_PORTAUDIO
+  int nargin = args.length ();
+  if (nargin == 1)
+    {
+      const octave_base_value& rep = args(0).get_rep ();
+      audioplayer *player = &((audioplayer &)rep);
+      player->pause ();
+    }
+#else
+  error ("portaudio not found on your system and thus audio functionality is not present");
+#endif
+  return retval;
+}
+
+DEFUN_DLD (__player_playblocking__, args, ,
+"__player_playblocking__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      audioplayer* player = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      player = &((audioplayer &)rep);
-      player->pause();
+      const octave_base_value& rep = args(0).get_rep ();
+      audioplayer *player = &((audioplayer &)rep);
+      player->playblocking ();
+    }
+  else
+    {
+      const octave_base_value& rep = args(0).get_rep ();
+      audioplayer *player = &((audioplayer &)rep);
+      if (args(1).is_matrix_type ())
+        {
+          unsigned int start, end;
+          RowVector range = args(1).row_vector_value ();
+          start = range.elem (0) - 1;
+          end = range.elem (1) - 1;
+          if (start < 0 or start > player->get_total_samples () or
+              start > end or end < 0 or end > player->get_total_samples ())
+            error ("audioplayer: invalid range specified for playback");
+          player->set_sample_number (start);
+          player->set_end_sample (end);
+        }
+      else
+        {
+          unsigned int start;
+          start = args(1).int_value () - 1;
+          if (start < 0 or start > player->get_total_samples ())
+            error ("audioplayer: invalid range specified for playback");
+          player->set_sample_number (start);
+        }
+      player->playblocking ();
     }
 #else
-  error("portaudio not found on your system and thus audio functionality is not present");
+  error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__player_playblocking__, args, ,
-"__player_playblocking__"
-)
-{
-  octave_value retval;
-#ifdef HAVE_PORTAUDIO
-  int nargin = args.length ();
-  if (nargin == 1)
-    {
-      audioplayer* player = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      player = &((audioplayer &)rep);
-      player->playblocking();
-    }
-  else
-    {
-      audioplayer* player = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      player = &((audioplayer &)rep);
-      if (args (1).is_matrix_type ())
-        {
-          unsigned int start, end;
-          RowVector range = args (1).row_vector_value ();
-          start = range.elem(0) - 1;
-          end = range.elem(1) - 1;
-          if (start < 0 or start > player->get_total_samples() or 
-              start > end or end < 0 or end > player->get_total_samples())
-            {
-              error("audioplayer: invalid range specified for playback");
-            }
-          player->set_sample_number(start);
-          player->set_end_sample(end);
-        }
-      else
-        {
-          unsigned int start;
-          start = args (1).int_value() - 1;
-          if (start < 0 or start > player->get_total_samples())
-            {
-              error("audioplayer: invalid range specified for playback");
-            }
-          player->set_sample_number(start);
-        }
-      player->playblocking();
-    }
-#else
-  error("portaudio not found on your system and thus audio functionality is not present");
-#endif
-  return retval;
-}
-
-DEFUN_DLD(__player_play__, args, ,
-"__player_play__"
-)
+DEFUN_DLD (__player_play__, args, ,
+"__player_play__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      audioplayer* player = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      player = &((audioplayer &)rep);
-      player->play();
+      const octave_base_value& rep = args(0).get_rep ();
+      audioplayer *player = &((audioplayer &)rep);
+      player->play ();
     }
   else
     {
-      audioplayer* player = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      player = &((audioplayer &)rep);
-      if (args (1).is_matrix_type ())
+      const octave_base_value& rep = args(0).get_rep ();
+      audioplayer *player = &((audioplayer &)rep);
+      if (args(1).is_matrix_type ())
         {
           unsigned int start, end;
-          RowVector range = args (1).row_vector_value ();
-          start = range.elem(0) - 1;
-          end = range.elem(1) - 1;
-          if (start < 0 or start > player->get_total_samples() or 
-              start > end or end < 0 or end > player->get_total_samples())
-            {
-              error("audioplayer: invalid range specified for playback");
-            }
-          player->set_sample_number(start);
-          player->set_end_sample(end);
+          RowVector range = args(1).row_vector_value ();
+          start = range.elem (0) - 1;
+          end = range.elem (1) - 1;
+          if (start < 0 or start > player->get_total_samples () or
+              start > end or end < 0 or end > player->get_total_samples ())
+            error ("audioplayer: invalid range specified for playback");
+          player->set_sample_number (start);
+          player->set_end_sample (end);
         }
       else
         {
           unsigned int start;
-          start = args (1).int_value() - 1;
-          if (start < 0 or start > player->get_total_samples())
-            {
-              error("audioplayer: invalid range specified for playback");
-            }
-          player->set_sample_number(start);
+          start = args(1).int_value () - 1;
+          if (start < 0 or start > player->get_total_samples ())
+            error ("audioplayer: invalid range specified for playback");
+          player->set_sample_number (start);
         }
-      player->play();
+      player->play ();
     }
 #else
-  error("portaudio not found on your system and thus audio functionality is not present");
+  error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__player_resume__, args, ,
-"__player_resume__"
-)
+DEFUN_DLD (__player_resume__, args, ,
+"__player_resume__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      audioplayer* player = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      player = &((audioplayer &)rep);
-      player->resume();
+      const octave_base_value& rep = args(0).get_rep ();
+      audioplayer *player = &((audioplayer &)rep);
+      player->resume ();
     }
 #else
-  error("portaudio not found on your system and thus audio functionality is not present");
+  error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__player_set_fs__, args, ,
-"__player_set_fs__"
-)
+DEFUN_DLD (__player_set_fs__, args, ,
+"__player_set_fs__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 2)
     {
-      audioplayer* player = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      player = &((audioplayer &)rep);
+      const octave_base_value& rep = args(0).get_rep ();
+      audioplayer *player = &((audioplayer &)rep);
       player->set_fs (args(1).int_value ());
     }
 #else
-  error("portaudio not found on your system and thus audio functionality is not present");
+  error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__player_set_tag__, args, ,
-"__player_set_tag__"
-)
+DEFUN_DLD (__player_set_tag__, args, ,
+"__player_set_tag__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 2)
     {
-      audioplayer* player = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      player = &((audioplayer &)rep);
+      const octave_base_value& rep = args(0).get_rep ();
+      audioplayer *player = &((audioplayer &)rep);
       player->set_tag (args(1).char_matrix_value ());
     }
 #else
-  error("portaudio not found on your system and thus audio functionality is not present");
+  error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__player_set_userdata__, args, ,
-"__player_set_userdata__"
-)
+DEFUN_DLD (__player_set_userdata__, args, ,
+"__player_set_userdata__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 2)
     {
-      audioplayer* player = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      player = &((audioplayer &)rep);
+      const octave_base_value& rep = args(0).get_rep ();
+      audioplayer *player = &((audioplayer &)rep);
       player->set_userdata (args(1));
     }
 #else
-  error("portaudio not found on your system and thus audio functionality is not present");
+  error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__player_stop__, args, ,
-"__player_stop__"
-)
+DEFUN_DLD (__player_stop__, args, ,
+"__player_stop__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      audioplayer* player = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      player = &((audioplayer &)rep);
-      player->stop();
+      const octave_base_value& rep = args(0).get_rep ();
+      audioplayer *player = &((audioplayer &)rep);
+      player->stop ();
     }
 #else
-  error("portaudio not found on your system and thus audio functionality is not present");
+  error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
diff --git a/libinterp/dldfcn/__recorder_audiorecorder__.cc b/libinterp/dldfcn/__recorder_audiorecorder__.cc
--- a/libinterp/dldfcn/__recorder_audiorecorder__.cc
+++ b/libinterp/dldfcn/__recorder_audiorecorder__.cc
@@ -26,31 +26,30 @@ along with Octave; see the file COPYING.
 
 #include "oct.h"
 #include "ov-struct.h"
 
 #ifdef HAVE_PORTAUDIO
 #include "player_class.cc"
 #include "recorder_class.cc"
 #endif
-   
-DEFUN_DLD(__recorder_audiorecorder__, args, ,
-"__recorder_audiorecorder__"
-)
+
+DEFUN_DLD (__recorder_audiorecorder__, args, ,
+"__recorder_audiorecorder__")
 {
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   audiorecorder* retval = new audiorecorder ();
   int offset = 0;
   if (nargin > 0)
     {
       bool is_function = args(0).is_string () || args(0).is_function_handle () || args(0).is_inline_function ();
       if (is_function)
         {
-          retval->octave_callback_function = args (0).function_value ();
+          retval->octave_callback_function = args(0).function_value ();
           offset = 1;
         }
     }
   switch (nargin - offset)
      {
       case 3:
         retval->set_fs (args(0 + offset).int_value ());
         retval->set_nbits (args(1 + offset).int_value ());
@@ -58,379 +57,339 @@ DEFUN_DLD(__recorder_audiorecorder__, ar
         break;
       case 4:
         retval->set_fs (args(0 + offset).int_value ());
         retval->set_nbits (args(1 + offset).int_value ());
         retval->set_channels (args(2 + offset).int_value ());
         retval->set_id (args(3 + offset).int_value ());
         break;
     }
-  retval->init();
-  return octave_value(retval);
+  retval->init ();
+  return octave_value (retval);
 #else
   octave_value retval;
   error ("portaudio not found on your system and thus audio functionality is not present");
   return retval;
 #endif
 }
-   
-DEFUN_DLD(__recorder_getaudiodata__, args, ,
-"__recorder_getaudiodata__"
-)
+
+DEFUN_DLD (__recorder_getaudiodata__, args, ,
+"__recorder_getaudiodata__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
-  audiorecorder* recorder = 0;
-  const octave_base_value& rep = args (0).get_rep ();
-  recorder = &((audiorecorder &)rep);
+  const octave_base_value& rep = args(0).get_rep ();
+  audiorecorder *recorder = &((audiorecorder &)rep);
   retval = octave_value (recorder->getaudiodata ());
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__recorder_get_channels__, args, ,
-"__recorder_get_channels__"
-)
+DEFUN_DLD (__recorder_get_channels__, args, ,
+"__recorder_get_channels__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      audiorecorder* recorder = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      recorder = &((audiorecorder &)rep);
-      retval = octave_value(recorder->get_channels());
+      const octave_base_value& rep = args(0).get_rep ();
+      audiorecorder *recorder = &((audiorecorder &)rep);
+      retval = octave_value (recorder->get_channels ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__recorder_get_fs__, args, ,
-"__recorder_get_fs__"
-)
+DEFUN_DLD (__recorder_get_fs__, args, ,
+"__recorder_get_fs__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      audiorecorder* recorder = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      recorder = &((audiorecorder &)rep);
-      retval = octave_value(recorder->get_fs());
+      const octave_base_value& rep = args(0).get_rep ();
+      audiorecorder *recorder = &((audiorecorder &)rep);
+      retval = octave_value (recorder->get_fs ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__recorder_get_id__, args, ,
-"__recorder_get_id__"
-)
+DEFUN_DLD (__recorder_get_id__, args, ,
+"__recorder_get_id__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      audiorecorder* recorder = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      recorder = &((audiorecorder &)rep);
-      retval = octave_value(recorder->get_id());
+      const octave_base_value& rep = args(0).get_rep ();
+      audiorecorder *recorder = &((audiorecorder &)rep);
+      retval = octave_value (recorder->get_id ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__recorder_get_nbits__, args, ,
-"__recorder_get_nbits__"
-)
+DEFUN_DLD (__recorder_get_nbits__, args, ,
+"__recorder_get_nbits__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      audiorecorder* recorder = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      recorder = &((audiorecorder &)rep);
-      retval = octave_value(recorder->get_nbits ());
+      const octave_base_value& rep = args(0).get_rep ();
+      audiorecorder *recorder = &((audiorecorder &)rep);
+      retval = octave_value (recorder->get_nbits ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__recorder_get_sample_number__, args, ,
-"__recorder_get_sample_number__"
-)
+DEFUN_DLD (__recorder_get_sample_number__, args, ,
+"__recorder_get_sample_number__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      audiorecorder* recorder = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      recorder = &((audiorecorder &)rep);
-      retval = octave_value(recorder->get_sample_number());
+      const octave_base_value& rep = args(0).get_rep ();
+      audiorecorder *recorder = &((audiorecorder &)rep);
+      retval = octave_value (recorder->get_sample_number ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__recorder_get_tag__, args, ,
-"__recorder_get_tag__"
-)
+DEFUN_DLD (__recorder_get_tag__, args, ,
+"__recorder_get_tag__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      audiorecorder* recorder = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      recorder = &((audiorecorder &)rep);
+      const octave_base_value& rep = args(0).get_rep ();
+      audiorecorder *recorder = &((audiorecorder &)rep);
       retval = octave_value (recorder->get_tag ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__recorder_get_total_samples__, args, ,
-"__recorder_get_total_samples__"
-)
+DEFUN_DLD (__recorder_get_total_samples__, args, ,
+"__recorder_get_total_samples__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      audiorecorder* recorder = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      recorder = &((audiorecorder &)rep);
-      retval = octave_value(recorder->get_total_samples());
+      const octave_base_value& rep = args(0).get_rep ();
+      audiorecorder *recorder = &((audiorecorder &)rep);
+      retval = octave_value (recorder->get_total_samples ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__recorder_get_userdata__, args, ,
-"__recorder_get_userdata__"
-)
+DEFUN_DLD (__recorder_get_userdata__, args, ,
+"__recorder_get_userdata__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      audiorecorder* recorder = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      recorder = &((audiorecorder &)rep);
+      const octave_base_value& rep = args(0).get_rep ();
+      audiorecorder *recorder = &((audiorecorder &)rep);
       retval = recorder->get_userdata ();
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__recorder_isrecording__, args, ,
-"__recorder_isrecording__"
-)
+DEFUN_DLD (__recorder_isrecording__, args, ,
+"__recorder_isrecording__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      audiorecorder* recorder = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      recorder = &((audiorecorder &)rep);
-      if (recorder->isrecording())
-        {
-          return octave_value(1);
-        }
+      const octave_base_value& rep = args(0).get_rep ();
+      audiorecorder *recorder = &((audiorecorder &)rep);
+      if (recorder->isrecording ())
+        return octave_value (1);
       else
-        {
-          return octave_value(0);
-        }
+        return octave_value (0);
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__recorder_pause__, args, ,
-"__recorder_pause__"
-)
+DEFUN_DLD (__recorder_pause__, args, ,
+"__recorder_pause__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      audiorecorder* recorder = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      recorder = &((audiorecorder &)rep);
-      recorder->pause();
+      const octave_base_value& rep = args(0).get_rep ();
+      audiorecorder *recorder = &((audiorecorder &)rep);
+      recorder->pause ();
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__recorder_recordblocking__, args, ,
-"__recorder_recordblocking__"
-)
+DEFUN_DLD (__recorder_recordblocking__, args, ,
+"__recorder_recordblocking__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
-  audiorecorder* recorder = 0;
-  const octave_base_value& rep = args (0).get_rep ();
-  recorder = &((audiorecorder &)rep);
-  recorder->recordblocking (args (1).float_value ());
+  const octave_base_value& rep = args(0).get_rep ();
+  audiorecorder *recorder = &((audiorecorder &)rep);
+  recorder->recordblocking (args(1).float_value ());
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__recorder_record__, args, ,
-"__recorder_record__"
-)
+DEFUN_DLD (__recorder_record__, args, ,
+"__recorder_record__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
-  audiorecorder* recorder = 0;
-  const octave_base_value& rep = args (0).get_rep ();
-  recorder = &((audiorecorder &)rep);
+  const octave_base_value& rep = args(0).get_rep ();
+  audiorecorder *recorder = &((audiorecorder &)rep);
   if (args.length () == 1)
     {
       recorder->record ();
     }
   else if (args.length () == 2)
     {
-      recorder->set_end_sample (args (1).int_value () * recorder->get_fs ());
+      recorder->set_end_sample (args(1).int_value () * recorder->get_fs ());
       recorder->record ();
     }
   else
     {
       error ("audiorecorder: wrong number of arguments passed to record");
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__recorder_resume__, args, ,
-"__recorder_resume__"
-)
+DEFUN_DLD (__recorder_resume__, args, ,
+"__recorder_resume__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 1)
     {
-      audiorecorder* recorder = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      recorder = &((audiorecorder &)rep);
-      recorder->resume();
+      const octave_base_value& rep = args(0).get_rep ();
+      audiorecorder *recorder = &((audiorecorder &)rep);
+      recorder->resume ();
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__recorder_set_fs__, args, ,
-"__recorder_set_fs__"
-)
+DEFUN_DLD (__recorder_set_fs__, args, ,
+"__recorder_set_fs__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 2)
     {
-      audiorecorder* recorder = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      recorder = &((audiorecorder &)rep);
-      recorder->set_fs (args (1).int_value());
+      const octave_base_value& rep = args(0).get_rep ();
+      audiorecorder *recorder = &((audiorecorder &)rep);
+      recorder->set_fs (args(1).int_value ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__recorder_set_tag__, args, ,
-"__recorder_set_tag__"
-)
+DEFUN_DLD (__recorder_set_tag__, args, ,
+"__recorder_set_tag__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 2)
     {
-      audiorecorder* recorder = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      recorder = &((audiorecorder &)rep);
+      const octave_base_value& rep = args(0).get_rep ();
+      audiorecorder *recorder = &((audiorecorder &)rep);
       recorder->set_tag (args(1).char_matrix_value ());
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__recorder_set_userdata__, args, ,
-"__recorder_set_userdata__"
-)
+DEFUN_DLD (__recorder_set_userdata__, args, ,
+"__recorder_set_userdata__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
   int nargin = args.length ();
   if (nargin == 2)
     {
-      audiorecorder* recorder = 0;
-      const octave_base_value& rep = args (0).get_rep ();
-      recorder = &((audiorecorder &)rep);
+      const octave_base_value& rep = args(0).get_rep ();
+      audiorecorder *recorder = &((audiorecorder &)rep);
       recorder->set_userdata (args(1));
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
-DEFUN_DLD(__recorder_stop__, args, ,
-"__recorder_stop__"
-)
+DEFUN_DLD (__recorder_stop__, args, ,
+"__recorder_stop__")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
-  audiorecorder* recorder = 0;
-  const octave_base_value& rep = args (0).get_rep ();
-  recorder = &((audiorecorder &)rep);
-  recorder->stop();
+  const octave_base_value& rep = args(0).get_rep ();
+  audiorecorder *recorder = &((audiorecorder &)rep);
+  recorder->stop ();
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
diff --git a/libinterp/dldfcn/audiodevinfo.cc b/libinterp/dldfcn/audiodevinfo.cc
--- a/libinterp/dldfcn/audiodevinfo.cc
+++ b/libinterp/dldfcn/audiodevinfo.cc
@@ -23,137 +23,127 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "oct.h"
 #include "ov-struct.h"
 #include <portaudio.h>
 
-PaSampleFormat bits_to_format(int bits)
+PaSampleFormat
+bits_to_format (int bits)
 {
   if (bits == 8)
-    {
-      return paInt8;
-    }
+    return paInt8;
   else if (bits == 16)
-    {
-      return paInt16;
-    }
+    return paInt16;
   else if (bits == 24)
-    {
-      return paInt24;
-    }
+    return paInt24;
   else if (bits == 32)
-    {
-      return paInt32;
-    }
+    return paInt32;
   else if (bits == -1)
-    {
-      return paFloat32;
-    }
-  else 
-    {
-      return 0;
-    }
+    return paFloat32;
+  else
+    return 0;
 }
-  
-DEFUN_DLD(audiodevinfo, args, ,
+
+DEFUN_DLD (audiodevinfo, args, ,
 "-*- texinfo -*-\n\
 @deftypefn{Loadable Function} @var{devinfo} = audiodevinfo\n\
 \n\
 Returns a structure with two fields called \"input\" and \"output\". \
 Each structure contains an array of structures with three fields called \
 \"Name\", \"DriverVersion\" and \"ID\". Each structure contains information \
 about a PortAudio device.\n\
 \n\
 @end deftypefn\n\
 \n\
-@deftypefn{Loadable Function} @var{devs} = audiodevinfo(@var{IO})\n\
+@deftypefn{Loadable Function} @var{devs} = audiodevinfo (@var{IO})\n\
 \n\
 Returns the number of input or output devices available. Set @var{IO} to 1 \
 for input devices and to 0 for output devices.\n\
 @end deftypefn\n\
 \n\
-@deftypefn{Loadable Function} @var{name} = audiodevinfo(@var{IO}, @var{ID})\n\
+@deftypefn{Loadable Function} @var{name} = audiodevinfo (@var{IO}, @var{ID})\n\
 \n\
 Returns the name of a device specified by numerical @var{ID}. Set @var{IO} \
 to 1 for input devices and to 0 for output devices.\n\
 @end deftypefn\n\
 \n\
-@deftypefn{Loadable Function} @var{id} = audiodevinfo(@var{IO}, @var{name})\n\
+@deftypefn{Loadable Function} @var{id} = audiodevinfo (@var{IO}, @var{name})\n\
 \n\
 Returns the id of a device specified by name. Set @var{IO} \
 to 1 for input devices and to 0 for output devices.\n\
 @end deftypefn\n\
 \n\
-@deftypefn{Loadable Function} @var{id} = audiodevinfo(@var{IO}, @var{rate},\
+@deftypefn{Loadable Function} @var{id} = audiodevinfo (@var{IO}, @var{rate},\
  @var{bits}, @var{chans})\n\
 \n\
 Returns the id of the first device that supports playback or recording\
  using the specified sampling rate (@var{rate}), bits per sample (@var{bits})\
  and number of channels (@var{chans}). Set @var{IO} to 1 for input devices\
  ant to 0 for output devices.\
 @end deftypefn\n\
 \n\
-@deftypefn{Loadable Function} @var{supports} = audiodevinfo(@var{IO}, @var{ID},\
+@deftypefn{Loadable Function} @var{supports} = audiodevinfo (@var{IO}, @var{ID},\
  @var{rate}, @var{bits}, @var{chans})\n\
 \n\
 Returns 1 if the device bearing @var{ID} supports specified sampling rate\
  (@var{rate}), bits per sample (@var{bits}) and number of channels (@var{chans}).\
  Returns 0 otherwise. Set @var{IO} to 1 for input devices and to 0 for output\
  devices.\n\
-@end deftypefn"
-)
+@end deftypefn")
 {
   octave_value retval;
 #ifdef HAVE_PORTAUDIO
-  int nargin = args.length();
+  int nargin = args.length ();
   PaError err;
   octave_scalar_map devinfo;
   octave_value_list input;
   octave_value_list output;
+
   err = Pa_Initialize ();
-  if (err != paNoError) 
-    { 
+  if (err != paNoError)
+    {
       error ("audiodevinfo: cannot initialize PortAudio");
       return retval;
     }
-  int num_devices;
-  num_devices = Pa_GetDeviceCount ();
-  if (num_devices < 0) 
+
+  int num_devices = Pa_GetDeviceCount ();
+  if (num_devices < 0)
     {
       error ("audiodevinfo: no audio device found");
       return retval;
     }
-      octave_idx_type numinput = 0, numoutput = 0;
+
+  octave_idx_type numinput = 0, numoutput = 0;
   for (int i = 0; i < num_devices; i++)
     {
-      const PaDeviceInfo* device_info  = Pa_GetDeviceInfo (i);
-
+      const PaDeviceInfo *device_info = Pa_GetDeviceInfo (i);
       if (device_info->maxInputChannels != 0)
-          numinput++;
-
+        numinput++;
       if (device_info->maxOutputChannels != 0)
-          numoutput++;
+        numoutput++;
     }
-  Cell input_name (dim_vector (1, numinput)),
-    input_id (dim_vector (1, numinput)),
-    input_driver_version (dim_vector (1, numinput)),
-    output_name (dim_vector (1, numoutput)),
-    output_driver_version (dim_vector (1, numoutput)),
-    output_id (dim_vector (1, numoutput));
+
+  Cell input_name (dim_vector (1, numinput));
+  Cell input_driver_version (dim_vector (1, numinput));
+  Cell input_id (dim_vector (1, numinput));
+  Cell output_name (dim_vector (1, numoutput));
+  Cell output_driver_version (dim_vector (1, numoutput));
+  Cell output_id (dim_vector (1, numoutput));
+
   octave_idx_type idx_i = 0, idx_o = 0;
   for (int i = 0; i < num_devices; i++)
     {
-      const PaDeviceInfo* device_info  = Pa_GetDeviceInfo (i);
+      const PaDeviceInfo *device_info = Pa_GetDeviceInfo (i);
       const char *driver;
       char name[128];
-      driver = Pa_GetHostApiInfo (device_info -> hostApi) -> name;
-      sprintf(name, "%s (%s)", device_info->name, driver);
+      driver = Pa_GetHostApiInfo (device_info->hostApi)->name;
+      sprintf (name, "%s (%s)", device_info->name, driver);
 
       if (device_info->maxInputChannels != 0)
         {
           input_name(idx_i) = name;
           input_driver_version(idx_i) = driver;
           input_id(idx_i) = i;
           idx_i++;
         }
@@ -161,84 +151,78 @@ Returns 1 if the device bearing @var{ID}
       if (device_info->maxOutputChannels != 0)
         {
           output_name(idx_o) = name;
           output_driver_version(idx_o) = driver;
           output_id(idx_o) = i;
           idx_o++;
         }
     }
+
   octave_map inputdev, outputdev;
   inputdev.setfield ("Name", input_name);
   inputdev.setfield ("DriverVersion", input_driver_version);
   inputdev.setfield ("ID", input_id);
   outputdev.setfield ("Name", output_name);
   outputdev.setfield ("DriverVersion", output_driver_version);
   outputdev.setfield ("ID", output_id);
   devinfo.setfield ("input", inputdev);
   devinfo.setfield ("output", outputdev);
-  // Return information about input and output audio devices and 
+
+  // Return information about input and output audio devices and
   // their properties.
   if (nargin == 0)
-    {
-      retval = devinfo;
-    }
+    retval = devinfo;
   // Return the number of input or output devices
   else if (nargin == 1)
     {
       if (args(0).int_value () == 0)
-        {
-          retval = octave_value (numoutput);
-        }
+        retval = octave_value (numoutput);
       else if (args(0).int_value () == 1)
+        retval = octave_value (numinput);
+      else
         {
-          retval = octave_value (numinput);
-        }
-      else 
-        {
-          error ("audiodevinfo: please specify 0 for output \
-and 1 for input devices");
+          error ("audiodevinfo: please specify 0 for output and 1 for input devices");
           return retval;
         }
     }
   // Return device name when given id or id when given device name.
   else if (nargin == 2)
     {
       bool found = false;
       int outin = args(0).int_value ();
       if (args(1).is_string ())
         {
           if (outin == 0)
             {
               for (int i = 0; i < numoutput; i++)
                 {
                   if (output_name(i).string_value () == args(1).string_value ())
-                    { 
+                    {
                       retval = output_id(i);
                       found = true;
                       break;
                     }
                 }
             }
           else if (outin == 1)
             {
               for (int i = 0; i < numinput; i++)
                 {
                   if (input_name(i).string_value () == args(1).string_value ())
-                    { 
+                    {
                       retval = input_id(i);
                       found = true;
                       break;
                     }
                 }
             }
-          else 
+          else
             {
-              error ("audiodevinfo: please specify 0 for output \
-and 1 for input devices");
+              error ("audiodevinfo: please specify 0 for output and 1 for input devices");
               return retval;
             }
         }
       else
         {
           if (outin == 0)
             {
               for (int i = 0; i < numoutput; i++)
@@ -258,27 +242,24 @@ and 1 for input devices");
                   if (input_id(i).int_value () == args(1).int_value ())
                     {
                       retval = input_name(i);
                       found = true;
                       break;
                     }
                 }
             }
-          else 
+          else
             {
-              error ("audiodevinfo: please specify 0 for output \
-and 1 for input devices");
+              error ("audiodevinfo: please specify 0 for output and 1 for input devices");
               return retval;
             }
         }
       if (not found)
-        {
-          error("audiodevinfo: no device meeting the specified criteria found");
-        }
+        error ("audiodevinfo: no device meeting the specified criteria found");
     }
   else if (nargin == 3)
     {
       //
     }
   // Return the id of the first device meeting specified criteria.
   else if (nargin == 4)
     {
@@ -286,80 +267,74 @@ and 1 for input devices");
       int rate = args(1).int_value ();
       int bits = args(2).int_value ();
       int chans = args(3).int_value ();
       for (int i = 0; i < num_devices; i++)
         {
           PaStreamParameters stream_parameters;
           stream_parameters.device = i;
           stream_parameters.channelCount = chans;
-          PaSampleFormat format = bits_to_format(bits);
+          PaSampleFormat format = bits_to_format (bits);
           if (format != 0)
-            {
-              stream_parameters.sampleFormat = format;
-            }
+            stream_parameters.sampleFormat = format;
           else
             {
-              error("audiodevinfo: no such bits per sample format");
+              error ("audiodevinfo: no such bits per sample format");
               return retval;
             }
-          stream_parameters.suggestedLatency = 
-            Pa_GetDeviceInfo (i)->defaultLowInputLatency;
+          stream_parameters.suggestedLatency =
+              Pa_GetDeviceInfo (i)->defaultLowInputLatency;
           stream_parameters.hostApiSpecificStreamInfo = NULL;
           if (io == 0)
             {
               if (Pa_GetDeviceInfo (i)->maxOutputChannels < chans)
-                {
-                  continue;
-                }
+                continue;
+
               err = Pa_IsFormatSupported (NULL, &stream_parameters, rate);
               if (err == paFormatIsSupported)
                 {
                   retval = i;
                   return retval;
                 }
             }
           else if (io == 1)
             {
               if (Pa_GetDeviceInfo (i)->maxInputChannels < chans)
-                {
-                  continue;
-                }
+                continue;
+
               err = Pa_IsFormatSupported (&stream_parameters, NULL, rate);
               if (err == paFormatIsSupported)
                 {
                   retval = i;
                   return retval;
                 }
             }
         }
-        retval = -1;
+      retval = -1;
     }
   // Check if given device supports specified playback or recording modes.
   else if (nargin == 5)
     {
       int io = args(0).int_value ();
       int id = args(1).int_value ();
       int rate = args(2).int_value ();
       int bits = args(3).int_value ();
       int chans = args(4).int_value ();
       PaStreamParameters stream_parameters;
       stream_parameters.device = id;
       stream_parameters.channelCount = chans;
-      PaSampleFormat format = bits_to_format(bits);
+      PaSampleFormat format = bits_to_format (bits);
       if (format != 0)
-        {
-          stream_parameters.sampleFormat = format;
-        }
+        stream_parameters.sampleFormat = format;
       else
         {
-          error("audiodevinfo: no such bits per sample format");
+          error ("audiodevinfo: no such bits per sample format");
           return retval;
         }
-      stream_parameters.suggestedLatency = 
+      stream_parameters.suggestedLatency =
         Pa_GetDeviceInfo (id)->defaultLowInputLatency;
       stream_parameters.hostApiSpecificStreamInfo = NULL;
       if (io == 0)
         {
           if (Pa_GetDeviceInfo (id)->maxOutputChannels < chans)
             {
               retval = 0;
               return retval;
@@ -382,62 +357,59 @@ and 1 for input devices");
           if (err == paFormatIsSupported)
             {
               retval = 1;
               return retval;
             }
         }
       else
         {
-          error ("audiodevinfo: please specify 0 for output\
-and 1 for input devices");
+          error ("audiodevinfo: please specify 0 for output and 1 for input devices");
           return retval;
         }
       retval = 0;
     }
   else
     {
       error ("audiodevinfo: wrong number of arguments");
       return retval;
     }
 #else
   error ("portaudio not found on your system and thus audio functionality is not present");
 #endif
   return retval;
 }
 
 /*
+%!test
+%! devinfo = audiodevinfo;
+%! assert(rows(devinfo.('input')) == 1);
+%! assert(rows(devinfo.('output')) == 1);
 
 %!test
-%!  devinfo = audiodevinfo;
-%!  assert(rows(devinfo.('input')) == 1);
-%!  assert(rows(devinfo.('output')) == 1);
-
-%!test
-%!  devinfo = audiodevinfo;
-%!  nout = audiodevinfo(0);
-%!  nin = audiodevinfo(1);
-%!  assert(columns(devinfo.('output')) == nout);
-%!  assert(columns(devinfo.('input')) == nin);
+%! devinfo = audiodevinfo;
+%! nout = audiodevinfo(0);
+%! nin = audiodevinfo(1);
+%! assert(columns(devinfo.('output')) == nout);
+%! assert(columns(devinfo.('input')) == nin);
 
 %!test
-%!  devinfo = audiodevinfo;
-%!  nout = audiodevinfo(0);
-%!  nin = audiodevinfo(1);
-%!  for i=1:nout,
-%!    assert(devinfo.('output')(i).('Name') == audiodevinfo(0, devinfo.('output')(i).('ID')))
-%!  end
-%!  for i=1:nin,
-%!    assert(devinfo.('input')(i).('Name') == audiodevinfo(0, devinfo.('input')(i).('ID')))
-%!  end
+%! devinfo = audiodevinfo;
+%! nout = audiodevinfo(0);
+%! nin = audiodevinfo(1);
+%! for i=1:nout,
+%!   assert(devinfo.('output')(i).('Name') == audiodevinfo(0, devinfo.('output')(i).('ID')))
+%! end
+%! for i=1:nin,
+%!   assert(devinfo.('input')(i).('Name') == audiodevinfo(0, devinfo.('input')(i).('ID')))
+%! end
 
 %!test
-%!  devinfo = audiodevinfo;
-%!  nout = audiodevinfo(0);
-%!  nin = audiodevinfo(1);
-%!  for i=1:nout,
-%!    assert(devinfo.('output')(i).('ID') == audiodevinfo(0, devinfo.('output')(i).('Name')))
-%!  end
-%!  for i=1:nin,
-%!    assert(devinfo.('input')(i).('ID') == audiodevinfo(0, devinfo.('input')(i).('Name')))
-%!  end
-
+%! devinfo = audiodevinfo;
+%! nout = audiodevinfo(0);
+%! nin = audiodevinfo(1);
+%! for i=1:nout,
+%!   assert(devinfo.('output')(i).('ID') == audiodevinfo(0, devinfo.('output')(i).('Name')))
+%! end
+%! for i=1:nin,
+%!   assert(devinfo.('input')(i).('ID') == audiodevinfo(0, devinfo.('input')(i).('Name')))
+%! end
 */
diff --git a/libinterp/dldfcn/audioinfo.cc b/libinterp/dldfcn/audioinfo.cc
--- a/libinterp/dldfcn/audioinfo.cc
+++ b/libinterp/dldfcn/audioinfo.cc
@@ -22,74 +22,63 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "oct.h"
 #include "ov-struct.h"
 #ifdef HAVE_SNDFILE
-  #include <sndfile.h>
+#include <sndfile.h>
 #endif
-  
-DEFUN_DLD(audioinfo, args, ,
+
+DEFUN_DLD (audioinfo, args, ,
 "-*- texinfo -*-\n\
-@deftypefn{Loadable Function} info = audioinfo(@var{filename})\n\
+@deftypefn{Loadable Function} info = audioinfo (@var{filename})\n\
 \n\
 Return information about an audio file specified by @var{filename}.\
 \n\
-@end deftypefn"
-)
+@end deftypefn")
 {
   octave_scalar_map retval;
   if (args.length () != 1 || not args(0).is_string ())
     {
       print_usage ();
-      return octave_value(retval);
+      return octave_value (retval);
     }
 #ifdef HAVE_SNDFILE
   Matrix audio;
   SNDFILE *file;
   SF_INFO info;
   info.format = 0;
   int start, end;
-  file = sf_open(args(0).string_value ().c_str (), SFM_READ, &info);
+  file = sf_open (args(0).string_value ().c_str (), SFM_READ, &info);
   retval.assign ("Filename", args(0).string_value ());
   retval.assign ("CompressionMethod", "");
   retval.assign ("NumChannels", info.channels);
   retval.assign ("SampleRate", info.samplerate);
   retval.assign ("TotalSamples", info.frames);
   retval.assign ("Duration", (float)info.frames / (float)info.samplerate);
+
   int bits;
   if (info.format & SF_FORMAT_PCM_S8)
-    {
-      bits = 8;
-    }
+    bits = 8;
   else if (info.format & SF_FORMAT_PCM_U8)
-    {
-      bits = 8;
-    }
+    bits = 8;
   else if (info.format & SF_FORMAT_PCM_16)
-    {
-      bits = 16;
-    }
+    bits = 16;
   else if (info.format & SF_FORMAT_PCM_24)
-    {
-      bits = 24;
-    }
+    bits = 24;
   else if (info.format & SF_FORMAT_PCM_32)
-    {
-      bits = 32;
-    }
+    bits = 32;
   else
-    {
-      bits = -1;
-    }
+    bits = -1;
+
   retval.assign ("BitsPerSample", bits);
   retval.assign ("BitRate", -1);
   retval.assign ("Title", sf_get_string (file, SF_STR_TITLE));
   retval.assign ("Artist", sf_get_string (file, SF_STR_ARTIST));
   retval.assign ("Comment", sf_get_string (file, SF_STR_COMMENT));
 #else
-  error("sndfile not found on your system and thus audioinfo is not functional");
+  error ("sndfile not found on your system and thus audioinfo is not functional");
 #endif
-  return octave_value(retval);
+  return octave_value (retval);
 }
diff --git a/libinterp/dldfcn/audioread.cc b/libinterp/dldfcn/audioread.cc
--- a/libinterp/dldfcn/audioread.cc
+++ b/libinterp/dldfcn/audioread.cc
@@ -22,123 +22,105 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "oct.h"
 #include "ov-struct.h"
 #ifdef HAVE_SNDFILE
-  #include <sndfile.h>
+#include <sndfile.h>
 #endif
-  
-DEFUN_DLD(audioread, args, ,
+
+DEFUN_DLD (audioread, args, ,
 "-*- texinfo -*-\n\
-@deftypefn{Loadable Function} [@var{y}, @var{Fs}] = audioread(@var{filename})\n\
+@deftypefn{Loadable Function} [@var{y}, @var{Fs}] = audioread (@var{filename})\n\
 \n\
 Load an audio file that is specified by @var{filename}. It will be loaded in to \
 a column matrix with as many rows as there are audio frames and as many columns \
 as there are channels in the file. Sampling rate will be stored in @var{Fs}. \
 \n\
 @end deftypefn\n\
-@deftypefn{Loadable Function} [@var{y}, @var{Fs}] = audioread(@var{filename}, @var{samples})\n\
+@deftypefn{Loadable Function} [@var{y}, @var{Fs}] = audioread (@var{filename}, @var{samples})\n\
 \n\
 Read a specified range of samples from a file specified by @var{filename}. \
 Argument @var{samples} is a vector with two values specifying starting frame \
 and ending frame. \
 \n\
 @end deftypefn\n\
-@deftypefn{Loadable Function} [@var{y}, @var{Fs}] = audioread(@var{filename}, @var{dataType})\n\
+@deftypefn{Loadable Function} [@var{y}, @var{Fs}] = audioread (@var{filename}, @var{dataType})\n\
 \n\
 Read a file and return an array of specified type. If @var{dataType} is \"native\" then \
 an array of fixed width integer type will be returned depending on how data is stored \
 in the audio file. If @var{dataType} is \"double\" a double matrix will be returned. \
 \n\
 @end deftypefn\n\
-@deftypefn{Loadable Function} [@var{y}, @var{Fs}] = audioread(@var{filename}, @var{samples}, @var{dataType})\n\
+@deftypefn{Loadable Function} [@var{y}, @var{Fs}] = audioread (@var{filename}, @var{samples}, @var{dataType})\n\
 \n\
 Read a file and return a specified range of frames in an array of specified type. \
 \n\
 @end deftypefn"
 )
 {
   octave_value_list retval;
 #ifdef HAVE_SNDFILE
   Matrix audio;
   octave_value ret_audio;
   SNDFILE *file;
   SF_INFO info;
   info.format = 0;
   int start, end;
-  file = sf_open(args(0).string_value ().c_str (), SFM_READ, &info);
+  file = sf_open (args(0).string_value ().c_str (), SFM_READ, &info);
   start = 0;
   end = info.frames;
-  float *data = (float *)malloc (sizeof(float) * info.frames * info.channels);
-  sf_read_float(file, data, info.frames * info.channels);
+  float *data = (float *)malloc (sizeof (float) * info.frames * info.channels);
+  sf_read_float (file, data, info.frames * info.channels);
   if (args.length () == 2 && !args(1).is_string () || args.length () == 3)
     {
       RowVector range = args(1).row_vector_value ();
       start = range(0);
       end = range(1);
     }
   audio.resize (end - start, info.channels);
   for (int i = start; i < end; i++)
     {
       for (int channel = 0; channel < info.channels; channel++)
         {
           audio(i - start, channel) = data[i * info.channels + channel];
         }
-    } 
+    }
   free (data);
   if (args.length () == 2 && args(1).is_string () || args.length () == 3)
     {
       std::string type;
       if (args.length () == 3)
-        {
-          type = args(2).string_value ();
-        }
+        type = args(2).string_value ();
       else
-        {
-          type = args(1).string_value ();
-        }
+        type = args(1).string_value ();
+
       if (type == "native")
         {
           if (info.format & SF_FORMAT_PCM_S8)
-            {
-              ret_audio = octave_value ((audio * 127)).int8_array_value ();
-            }
+            ret_audio = octave_value ((audio * 127)).int8_array_value ();
           else if (info.format & SF_FORMAT_PCM_U8)
-            {
-              ret_audio = octave_value ((audio * 127 + 127)).uint8_array_value ();
-            }
+            ret_audio = octave_value ((audio * 127 + 127)).uint8_array_value ();
           else if (info.format & SF_FORMAT_PCM_16)
-            {
-              ret_audio = octave_value ((audio * 32767)).int16_array_value ();
-            }
+            ret_audio = octave_value ((audio * 32767)).int16_array_value ();
           else if (info.format & SF_FORMAT_PCM_24)
-            {
-              ret_audio = octave_value ((audio * 8388608)).int32_array_value ();
-            }
+            ret_audio = octave_value ((audio * 8388608)).int32_array_value ();
           else if (info.format & SF_FORMAT_PCM_32)
-            {
-              ret_audio = octave_value ((audio * 2147483648)).int32_array_value ();
-            }
+            ret_audio = octave_value ((audio * 2147483648)).int32_array_value ();
           else
-            {
-              ret_audio = octave_value (audio);
-            }
+            ret_audio = octave_value (audio);
         }
       else
-        {
-          ret_audio = octave_value (audio);
-        }
+        ret_audio = octave_value (audio);
     }
   else
-    {
-      ret_audio = octave_value (audio);
-    }
+    ret_audio = octave_value (audio);
+
   retval(0) = ret_audio;
   retval(1) = info.samplerate;
 #else
-  error("sndfile not found on your system and thus audioread is not functional");
+  error ("sndfile not found on your system and thus audioread is not functional");
 #endif
-  return octave_value(retval);
+  return octave_value (retval);
 }
diff --git a/libinterp/dldfcn/audiowrite.cc b/libinterp/dldfcn/audiowrite.cc
--- a/libinterp/dldfcn/audiowrite.cc
+++ b/libinterp/dldfcn/audiowrite.cc
@@ -22,23 +22,24 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "oct.h"
 #include "ov-struct.h"
 #ifdef HAVE_SNDFILE
-  #include <sndfile.h>
+#include <sndfile.h>
 #endif
 #include <string>
 #include <map>
 
 #ifdef HAVE_SNDFILE
-static void fill_extension_table(std::map<std::string, int> &table)
+static void
+fill_extension_table (std::map<std::string, int> &table)
 {
   table["wav"] = SF_FORMAT_WAV;
   table["aiff"] = SF_FORMAT_AIFF;
   table["au"] = SF_FORMAT_AU;
   table["raw"] = SF_FORMAT_RAW;
   table["paf"] = SF_FORMAT_PAF;
   table["svx"] = SF_FORMAT_SVX;
   table["nist"] = SF_FORMAT_NIST;
@@ -57,26 +58,26 @@ static void fill_extension_table(std::ma
   table["flac"] = SF_FORMAT_FLAC;
   table["caf"] = SF_FORMAT_CAF;
   table["wve"] = SF_FORMAT_WVE;
   table["ogg"] = SF_FORMAT_OGG;
   table["mpc2k"] = SF_FORMAT_MPC2K;
   table["rf64"] = SF_FORMAT_RF64;
 }
 #endif
-  
-DEFUN_DLD(audiowrite, args, ,
+
+DEFUN_DLD (audiowrite, args, ,
 "-*- texinfo -*-\n\
-@deftypefn{Loadable Function} audiowrite(@var{filename}, @var{y}, @var{Fs})\n\
+@deftypefn{Loadable Function} audiowrite (@var{filename}, @var{y}, @var{Fs})\n\
 \n\
 Write audio data from the matrix @var{y} to a file specified by @var{filename}, \
 file format will be determined by the file extension.\
 \n\
 @end deftypefn\n\
-@deftypefn{Loadable Function} audiowrite(@var{filename}, @var{y}, @var{Fs}, @var{Name}, @var{Value})\n\
+@deftypefn{Loadable Function} audiowrite (@var{filename}, @var{y}, @var{Fs}, @var{Name}, @var{Value})\n\
 \n\
 Lets you specify additional parameters when writing the file. Those parameters are given in the table below:\n\
 \n\
 @table @samp\n\
 @item BitsPerSample\n\
 Number of bits per sample, valid values are 8, 16, 24 and 32. Default is 16.\n\
 @item BitRate\n\
 Valid argument name, but ignored. Left for compatibility with MATLAB.\n\
@@ -84,116 +85,85 @@ Valid argument name, but ignored. Left f
 Quality setting for the Ogg Vorbis compressor. Values can range between 0 and 100 with 100 being the highest quality setting. Default is 75.\n\
 @item Title\n\
 Title for the audio file.\n\
 @item Artist\n\
 Artist name.\n\
 @item Comment\n\
 Comment.\n\
 @end table\n\
-@end deftypefn"
-)
+@end deftypefn")
 {
   octave_scalar_map retval;
 #ifdef HAVE_SNDFILE
   std::map<std::string, int> extension_to_format;
-  fill_extension_table(extension_to_format);
+  fill_extension_table (extension_to_format);
   std::string filename = args(0).string_value ();
-  std::string extension = filename.substr(filename.find_last_of(".") + 1);
-  std::transform(extension.begin(), extension.end(), extension.begin(), ::tolower);
+  std::string extension = filename.substr (filename.find_last_of (".") + 1);
+  std::transform (extension.begin (), extension.end (), extension.begin (), ::tolower);
   Matrix audio = args(1).matrix_value ();
   SNDFILE *file;
   SF_INFO info;
-  float *data = (float *)malloc(audio.rows () * audio.cols () * sizeof(float));
+  float *data = (float *)malloc (audio.rows () * audio.cols () * sizeof (float));
   for (int i = 0; i < audio.cols (); i++)
     {
       for (int j = 0; j < audio.rows (); j++)
         {
           data[j * audio.cols () + i] = audio(j, i);
         }
     }
+
   if (extension == "ogg")
-    {
-      info.format = SF_FORMAT_VORBIS;
-    }
+    info.format = SF_FORMAT_VORBIS;
   else
-    {
-      info.format = SF_FORMAT_PCM_16;
-    }
+    info.format = SF_FORMAT_PCM_16;
+
   std::string title = "";
   std::string artist = "";
   std::string comment = "";
   float quality = 0.75;
   for (int i = 3; i < args.length (); i += 2)
     {
       if (args(i).string_value () == "BitsPerSample")
         {
           int bits = args(i + 1).int_value ();
           if (bits == 8)
-            {
-              info.format |= SF_FORMAT_PCM_S8;
-            }
+            info.format |= SF_FORMAT_PCM_S8;
           else if (bits == 16)
-            {
-              info.format |= SF_FORMAT_PCM_16;
-            }
+            info.format |= SF_FORMAT_PCM_16;
           else if (bits == 24)
-            {
-              info.format |= SF_FORMAT_PCM_24;
-            }
+            info.format |= SF_FORMAT_PCM_24;
           else if (bits == 32)
-            {
-              info.format |= SF_FORMAT_PCM_32;
-            }
+            info.format |= SF_FORMAT_PCM_32;
           else
-            {
-              error("audiowrite: wrong number of bits specified");
-            }
+            error ("audiowrite: wrong number of bits specified");
         }
       else if (args(i).string_value () == "BitRate")
-        {
-
-        }
+        ;
       else if (args(i).string_value () == "Quality")
-        {
-          quality = args(i + 1).int_value () * 0.01;
-        }
+        quality = args(i + 1).int_value () * 0.01;
       else if (args(i).string_value () == "Title")
-        {
-          title = args(i + 1).string_value ();
-        }
+        title = args(i + 1).string_value ();
       else if (args(i).string_value () == "Artist")
-        {
-          artist = args(i + 1).string_value ();
-        }
+        artist = args(i + 1).string_value ();
       else if (args(i).string_value () == "Comment")
-        {
-          comment = args(i + 1).string_value ();
-        }
+        comment = args(i + 1).string_value ();
       else
-        {
-          error("audiowrite: wrong argument name");
-        }
+        error ("audiowrite: wrong argument name");
     }
   info.samplerate = args(2).int_value ();
   info.channels = audio.cols ();
   info.format |= extension_to_format[extension];
   file = sf_open (filename.c_str (), SFM_WRITE, &info);
   if (title != "")
-    {
-      sf_set_string (file, SF_STR_TITLE, title.c_str ());
-    }
+    sf_set_string (file, SF_STR_TITLE, title.c_str ());
   if (artist != "")
-    {
-      sf_set_string (file, SF_STR_ARTIST, artist.c_str ());
-    }
+    sf_set_string (file, SF_STR_ARTIST, artist.c_str ());
   if (comment != "")
-    {
-      sf_set_string (file, SF_STR_COMMENT, comment.c_str ());
-    }
+    sf_set_string (file, SF_STR_COMMENT, comment.c_str ());
   sf_write_float (file, data, audio.rows () * audio.cols ());
   sf_close (file);
   free (data);
 #else
-  error("sndfile not found on your system and thus audiowrite is not functional");
+  error ("sndfile not found on your system and thus audiowrite is not functional");
 #endif
-  return octave_value(retval);
+  return octave_value (retval);
 }
diff --git a/libinterp/dldfcn/player_class.cc b/libinterp/dldfcn/player_class.cc
--- a/libinterp/dldfcn/player_class.cc
+++ b/libinterp/dldfcn/player_class.cc
@@ -27,75 +27,66 @@ along with Octave; see the file COPYING.
 #include "oct.h"
 #include "ov.h"
 #include "parse.h"
 #include <portaudio.h>
 #include <stdint.h>
 
 #include "player_class.h"
 
-PaSampleFormat bits_to_format(int bits)
+PaSampleFormat
+bits_to_format (int bits)
 {
   if (bits == 8)
-    {
-      return paInt8;
-    }
+    return paInt8;
   else if (bits == 16)
-    {
-      return paInt16;
-    }
+    return paInt16;
   else if (bits == 24)
-    {
-      return paInt24;
-    }
+    return paInt24;
   else if (bits == 32)
-    {
-      return paInt32;
-    }
+    return paInt32;
   else if (bits == -1)
-    {
-      return paFloat32;
-    }
-  else 
-    {
-      return 0;
-    }
+    return paFloat32;
+  else
+    return 0;
 }
 
 #define BUFFER_SIZE 512
 
 DEFINE_OCTAVE_ALLOCATOR (audioplayer);
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (audioplayer, "audioplayer", "audioplayer");
 
-int is_big_endian (void)
+int
+is_big_endian (void)
 {
-  union 
+  union
     {
       uint32_t i;
       char c[4];
-    } bint = {0x01020304};
-  return bint.c[0] == 1; 
+    } bint = { 0x01020304 };
+  return bint.c[0] == 1;
 }
 
-static int octave_play_callback(const void *input, void *output,
-                                unsigned long frames,
-                                const PaStreamCallbackTimeInfo *time,
-                                PaStreamCallbackFlags status,
-                                void *data)
+static int
+octave_play_callback (const void *input, void *output,
+                      unsigned long frames,
+                      const PaStreamCallbackTimeInfo *time,
+                      PaStreamCallbackFlags status,
+                      void *data)
 {
   audioplayer *player = (audioplayer *)data;
   int big_endian = is_big_endian ();
   octave_value_list args, retval;
   args(0) = frames;
   retval = feval (player->octave_callback_function, args, 1);
   RowVector sound_l, sound_r;
   Matrix sound = retval(0).matrix_value ();
   int return_status = retval(1).int_value ();
-  sound_l.resize(frames);
-  sound_r.resize(frames);
+  sound_l.resize (frames);
+  sound_r.resize (frames);
   if (sound.cols () == 1)
     {
       for (int i = 0; i < frames; i++)
         {
           sound_l(i) = sound(i, 0);
           sound_r(i) = sound(i, 0);
         }
     }
@@ -103,107 +94,104 @@ static int octave_play_callback(const vo
     {
       for (int i = 0; i < frames; i++)
         {
           sound_l(i) = sound(i, 0);
           sound_r(i) = sound(i, 1);
         }
     }
   else
-    {
-      return paAbort;
-    }
+    return paAbort;
+
   for (int i = 0; i < frames; i++)
     {
       if (player->get_nbits () == 8)
         {
           int8_t *buffer = (int8_t *)output;
-          buffer[2 * i] = sound_l.elem(i) * (pow (2.0, 7) - 1);
-          buffer[2 * i + 1] = sound_r.elem(i) * (pow (2.0, 7) - 1);
+          buffer[2 * i] = sound_l.elem (i) * (pow (2.0, 7) - 1);
+          buffer[2 * i + 1] = sound_r.elem (i) * (pow (2.0, 7) - 1);
         }
       else if (player->get_nbits () == 16)
         {
           int16_t *buffer = (int16_t *)output;
-          buffer[2 * i] = sound_l.elem(i) * (pow (2.0, 15) - 1);
-          buffer[2 * i + 1] = sound_r.elem(i) * (pow (2.0, 15) - 1);
+          buffer[2 * i] = sound_l.elem (i) * (pow (2.0, 15) - 1);
+          buffer[2 * i + 1] = sound_r.elem (i) * (pow (2.0, 15) - 1);
         }
-      else if (player->get_nbits() == 24)
+      else if (player->get_nbits () == 24)
         {
           uint8_t *buffer = (uint8_t *)output;
-          int32_t sample_l = sound_l.elem(i) * (pow (2.0, 23) - 1);
-          int32_t sample_r = sound_r.elem(i) * (pow (2.0, 23) - 1);
+          int32_t sample_l = sound_l.elem (i) * (pow (2.0, 23) - 1);
+          int32_t sample_r = sound_r.elem (i) * (pow (2.0, 23) - 1);
           sample_l &= 0x00ffffff;
           sample_r &= 0x00ffffff;
           uint8_t *_sample_l = (uint8_t *)&sample_l;
           uint8_t *_sample_r = (uint8_t *)&sample_r;
           buffer[i * 6 + 0] = _sample_l[0 + big_endian];
           buffer[i * 6 + 1] = _sample_l[1 + big_endian];
           buffer[i * 6 + 2] = _sample_l[2 + big_endian];
           buffer[i * 6 + 3] = _sample_r[0 + big_endian];
-          buffer[i * 6 + 4] = _sample_r[1 + big_endian]; 
+          buffer[i * 6 + 4] = _sample_r[1 + big_endian];
           buffer[i * 6 + 5] = _sample_r[2 + big_endian];
         }
     }
   return return_status;
 }
 
-static int portaudio_play_callback (const void *input, void *output,
-                                   unsigned long frames,
-                                   const PaStreamCallbackTimeInfo* time,
-                                   PaStreamCallbackFlags status,
-                                   void *data)
+static int
+portaudio_play_callback (const void *input, void *output,
+                         unsigned long frames,
+                         const PaStreamCallbackTimeInfo* time,
+                         PaStreamCallbackFlags status,
+                         void *data)
 {
   audioplayer *player = (audioplayer *)data;
   int big_endian = is_big_endian ();
   int channels = player->get_channels ();
   RowVector *sound_l = player->get_left ();
   RowVector *sound_r;
+
   if (channels > 1)
-    {
-      sound_r = player->get_right ();
-    }
+    sound_r = player->get_right ();
   else
-    {
-      sound_r = sound_l;
-    }
+    sound_r = sound_l;
+
   for (int j = 0, k = 0; j < frames; j++, k += 2)
     {
-      unsigned int sample_number = player->get_sample_number();
+      unsigned int sample_number = player->get_sample_number ();
       if (sample_number > player->get_end_sample ())
-       {
-         return paAbort;
-       }
+        return paAbort;
+
       if (player->get_type () == DOUBLE)
         {
           if (player->get_nbits () == 8)
             {
               int8_t *buffer = (int8_t *)output;
               buffer[k] = sound_l->elem (sample_number) * (pow (2.0, 7) - 1);
               buffer[k + 1] = sound_r->elem (sample_number) * (pow (2.0, 7) - 1);
             }
           else if (player->get_nbits () == 16)
             {
               int16_t *buffer = (int16_t *)output;
               buffer[k] = sound_l->elem (sample_number) * (pow (2.0, 15) - 1);
               buffer[k + 1] = sound_r->elem (sample_number) * (pow (2.0, 15) - 1);
             }
-          else if (player->get_nbits() == 24)
+          else if (player->get_nbits () == 24)
             {
               uint8_t *buffer = (uint8_t *)output;
-              int32_t sample_l = sound_l->elem(sample_number) * (pow (2.0, 23) - 1);
-              int32_t sample_r = sound_r->elem(sample_number) * (pow (2.0, 23) - 1);
+              int32_t sample_l = sound_l->elem (sample_number) * (pow (2.0, 23) - 1);
+              int32_t sample_r = sound_r->elem (sample_number) * (pow (2.0, 23) - 1);
               sample_l &= 0x00ffffff;
               sample_r &= 0x00ffffff;
               uint8_t *_sample_l = (uint8_t *)&sample_l;
               uint8_t *_sample_r = (uint8_t *)&sample_r;
               buffer[j * 6 + 0] = _sample_l[0 + big_endian];
               buffer[j * 6 + 1] = _sample_l[1 + big_endian];
               buffer[j * 6 + 2] = _sample_l[2 + big_endian];
               buffer[j * 6 + 3] = _sample_r[0 + big_endian];
-              buffer[j * 6 + 4] = _sample_r[1 + big_endian]; 
+              buffer[j * 6 + 4] = _sample_r[1 + big_endian];
               buffer[j * 6 + 5] = _sample_r[2 + big_endian];
             }
         }
       else if (player->get_type () == INT8)
         {
           int8_t *buffer = (int8_t *)output;
           buffer[k] = sound_l->elem (sample_number);
           buffer[k + 1] = sound_r->elem (sample_number);
@@ -220,418 +208,426 @@ static int portaudio_play_callback (cons
           buffer[k] = sound_l->elem (sample_number);
           buffer[k + 1] = sound_r->elem (sample_number);
         }
       player->set_sample_number (sample_number + 1);
     }
   return paContinue;
 }
 
-audioplayer::audioplayer ()
+audioplayer::audioplayer (void)
 {
   this->nbits = 16;
   this->id = -1;
   this->sample_number = 0;
   this->tag = charMatrix ("");
   Matrix userdata;
   this->userdata = octave_value (userdata);
   this->stream = 0;
   this->octave_callback_function = 0;
 }
 
-audioplayer::~audioplayer ()
-{
-
-}
-
-void audioplayer::print (std::ostream& os, bool pr_as_read_syntax ) const
+void
+audioplayer::print (std::ostream& os, bool pr_as_read_syntax) const
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 
-void audioplayer::print_raw (std::ostream& os, bool pr_as_read_syntax) const
+void
+audioplayer::print_raw (std::ostream& os, bool pr_as_read_syntax) const
 {
   os << 0;
 }
 
-void audioplayer::init_fn()
+void
+audioplayer::init_fn (void)
 {
   PaError err;
   int device;
+
   err = Pa_Initialize ();
-  if (err != paNoError) 
-    { 
+  if (err != paNoError)
+    {
       error ("audioplayer: Initialization error!");
       return;
     }
-  int numDevices;
-  numDevices = Pa_GetDeviceCount ();
-  if (numDevices < 0) 
+
+  int numDevices = Pa_GetDeviceCount ();
+  if (numDevices < 0)
     {
       error ("audioplayer: No audio devices found!");
       return;
     }
+
   if (this->get_id () == -1)
-    {
-      device = Pa_GetDefaultOutputDevice ();
-    }  
-  else 
-    {
-      device = this->get_id ();
-    }
+    device = Pa_GetDefaultOutputDevice ();
+  else
+    device = this->get_id ();
+
   output_parameters.device = device;
   output_parameters.channelCount = 2;
   output_parameters.sampleFormat = bits_to_format (this->get_nbits ());
   output_parameters.suggestedLatency = Pa_GetDeviceInfo (device)->defaultHighOutputLatency;
   output_parameters.hostApiSpecificStreamInfo = NULL;
 }
 
-void audioplayer::init ()
+void
+audioplayer::init (void)
 {
   PaError err;
   int channels = this->y.rows ();
   RowVector *sound_l = this->get_left ();
   int device;
+
   err = Pa_Initialize ();
-  if (err != paNoError) 
-    { 
+  if (err != paNoError)
+    {
       error ("audioplayer: Initialization error!");
       return;
     }
-  int numDevices;
-  numDevices = Pa_GetDeviceCount ();
-  if (numDevices < 0) 
+
+  int numDevices = Pa_GetDeviceCount ();
+  if (numDevices < 0)
     {
       error ("audioplayer: No audio devices found!");
       return;
     }
+
   if (this->get_id () == -1)
-    {
-      device = Pa_GetDefaultOutputDevice ();
-    }  
-  else 
-    {
-      device = this->get_id ();
-    }
+    device = Pa_GetDefaultOutputDevice ();
+  else
+    device = this->get_id ();
+
   output_parameters.device = device;
   output_parameters.channelCount = 2;
+
   if (this->type == DOUBLE)
-    {
-      output_parameters.sampleFormat = bits_to_format (this->get_nbits ());
-    }
+    output_parameters.sampleFormat = bits_to_format (this->get_nbits ());
   else if (this->type == INT8)
-    {
-      output_parameters.sampleFormat = paInt8;
-    }
+    output_parameters.sampleFormat = paInt8;
   else if (this->type == UINT8)
-    {
-      output_parameters.sampleFormat = paUInt8;
-    }
+    output_parameters.sampleFormat = paUInt8;
   else if (this->type == INT16)
-    {
-      output_parameters.sampleFormat = paInt16;
-    }
+    output_parameters.sampleFormat = paInt16;
+
   output_parameters.suggestedLatency = Pa_GetDeviceInfo (device)->defaultHighOutputLatency;
   output_parameters.hostApiSpecificStreamInfo = NULL;
 }
 
-void audioplayer::set_y (octave_value y)
+void
+audioplayer::set_y (octave_value y)
 {
   if (y.is_int8_type ())
-    {
-      this->type = INT8;
-    }
+    this->type = INT8;
   else if (y.is_uint8_type ())
-    {
-      this->type = UINT8;
-    }
+    this->type = UINT8;
   else if (y.is_int16_type ())
-    {
-      this->type = INT16;
-    }
+    this->type = INT16;
   else
-    {
-      this->type = DOUBLE;
-    }
+    this->type = DOUBLE;
+
   this->y = y.matrix_value ();
   if (this->y.rows () > 2)
-    {
-      this->y = this->y.transpose ();
-    }
+    this->y = this->y.transpose ();
+
   this->channels = this->y.rows ();
   this->left = this->y.row (0);
   if (this->channels == 2)
-    {
-      this->right = this->y.row (1);
-    }
+    this->right = this->y.row (1);
+
   this->reset_end_sample ();
 }
 
-void audioplayer::set_y (octave_function *fn)
+void
+audioplayer::set_y (octave_function *fn)
 {
   this->octave_callback_function = fn;
   this->channels = 2;
   this->reset_end_sample ();
 }
 
-Matrix &audioplayer::get_y ()
+Matrix&
+audioplayer::get_y (void)
 {
   return this->y;
 }
 
-RowVector *audioplayer::get_left ()
+RowVector *
+audioplayer::get_left (void)
 {
   return &(this->left);
 }
 
-RowVector *audioplayer::get_right ()
+RowVector *
+audioplayer::get_right (void)
 {
   return &(this->right);
 }
 
-void audioplayer::set_fs (int fs)
+void
+audioplayer::set_fs (int fs)
 {
   this->fs = fs;
 }
 
-int audioplayer::get_fs ()
+int
+audioplayer::get_fs (void)
 {
   return this->fs;
 }
 
-void audioplayer::set_nbits (int nbits)
+void
+audioplayer::set_nbits (int nbits)
 {
   this->nbits = nbits;
 }
 
-int audioplayer::get_nbits ()
+int
+audioplayer::get_nbits (void)
 {
   return this->nbits;
 }
 
-void audioplayer::set_id (int id)
+void
+audioplayer::set_id (int id)
 {
   this->id = id;
 }
 
-int audioplayer::get_id ()
+int
+audioplayer::get_id (void)
 {
   return this->id;
 }
 
-int audioplayer::get_channels ()
+int
+audioplayer::get_channels (void)
 {
   return this->channels;
 }
 
-audio_type audioplayer::get_type ()
+audio_type
+audioplayer::get_type (void)
 {
   return this->type;
 }
 
-void audioplayer::set_sample_number (unsigned int sample_number)
+void
+audioplayer::set_sample_number (unsigned int sample_number)
 {
   this->sample_number = sample_number;
 }
 
-unsigned int audioplayer::get_sample_number ()
+unsigned int
+audioplayer::get_sample_number (void)
 {
   return this->sample_number;
 }
 
-unsigned int audioplayer::get_total_samples ()
+unsigned int
+audioplayer::get_total_samples (void)
 {
   return this->left.length ();
 }
 
-void audioplayer::set_end_sample (unsigned int end_sample)
+void
+audioplayer::set_end_sample (unsigned int end_sample)
 {
   this->end_sample = end_sample;
 }
 
-unsigned int audioplayer::get_end_sample ()
+unsigned int
+audioplayer::get_end_sample (void)
 {
   return this->end_sample;
 }
 
-void audioplayer::reset_end_sample ()
+void
+audioplayer::reset_end_sample (void)
 {
   this->set_end_sample (this->left.length ());
 }
 
-void audioplayer::set_tag (charMatrix tag)
+void
+audioplayer::set_tag (charMatrix tag)
 {
   this->tag = tag;
 }
 
-charMatrix audioplayer::get_tag ()
+charMatrix
+audioplayer::get_tag (void)
 {
   return this->tag;
 }
 
-void audioplayer::set_userdata (octave_value userdata)
+void
+audioplayer::set_userdata (octave_value userdata)
 {
   this->userdata = userdata;
 }
 
-octave_value audioplayer::get_userdata ()
+octave_value
+audioplayer::get_userdata (void)
 {
   return this->userdata;
 }
 
-void audioplayer::playblocking ()
+void
+audioplayer::playblocking (void)
 {
   if (this->get_stream ())
-    {
-      this->stop ();
-    }
+    this->stop ();
+
   PaError err;
   uint32_t buffer[BUFFER_SIZE * 2];
   err = Pa_OpenStream (&stream, NULL, &(this->output_parameters), this->get_fs (), BUFFER_SIZE, paClipOff, NULL, NULL);
-  if (err != paNoError) 
-    { 
+  if (err != paNoError)
+    {
       error ("audioplayer: Error opening audio playback stream");
       return;
     }
+
   err = Pa_StartStream (stream);
-  if (err != paNoError) 
+  if (err != paNoError)
     {
       error ("audioplayer: Error starting audio playback stream");
       return;
     }
+
   unsigned int start, end;
   start = this->get_sample_number ();
   end = this->get_end_sample ();
-  for (int i = start; i < end; i += BUFFER_SIZE) 
+  for (int i = start; i < end; i += BUFFER_SIZE)
     {
       if (this->octave_callback_function != 0)
-        {
-          octave_play_callback (0, (void *)buffer, BUFFER_SIZE, 0, 0, (void *)this);
-        }
+        octave_play_callback (0, (void *)buffer, BUFFER_SIZE, 0, 0, (void *)this);
       else
-        {
-          portaudio_play_callback (0, (void *)buffer, BUFFER_SIZE, 0, 0, (void *)this);
-        }
+        portaudio_play_callback (0, (void *)buffer, BUFFER_SIZE, 0, 0, (void *)this);
       err = Pa_WriteStream (stream, buffer, BUFFER_SIZE);
     }
+
   err = Pa_StopStream (stream);
-  if (err != paNoError) 
+  if (err != paNoError)
     {
       error ("audioplayer: Error stoping audio playback stream");
       return;
     }
+
   err = Pa_CloseStream (stream);
-  if (err != paNoError) 
-    { 
+  if (err != paNoError)
+    {
       error ("audioplayer: Error closing audio playback stream");
       return;
     }
+
   stream = 0;
   this->set_sample_number (0);
   this->reset_end_sample ();
 }
 
-void audioplayer::play ()
+void
+audioplayer::play (void)
 {
   if (this->get_stream ())
-    {
-      this->stop ();
-    }
+    this->stop ();
+
   PaError err;
   if (this->octave_callback_function != 0)
-    {
-      err = Pa_OpenStream (&stream, NULL, &(this->output_parameters), this->get_fs (), BUFFER_SIZE, paClipOff, octave_play_callback, (void *)this);
-    }
+    err = Pa_OpenStream (&stream, NULL, &(this->output_parameters), this->get_fs (), BUFFER_SIZE, paClipOff, octave_play_callback, (void *)this);
   else
+    err = Pa_OpenStream (&stream, NULL, &(this->output_parameters), this->get_fs (), BUFFER_SIZE, paClipOff, portaudio_play_callback, (void *)this);
+
+  if (err != paNoError)
     {
-      err = Pa_OpenStream (&stream, NULL, &(this->output_parameters), this->get_fs (), BUFFER_SIZE, paClipOff, portaudio_play_callback, (void *)this);
-    }
-  if (err != paNoError) 
-    { 
       error ("audioplayer: Error opening audio playback stream");
       return;
     }
+
   err = Pa_StartStream (stream);
-  if (err != paNoError) 
+  if (err != paNoError)
     {
       error ("audioplayer: Error starting audio playback stream");
       return;
     }
 }
 
-void audioplayer::pause ()
+void
+audioplayer::pause (void)
 {
   if (this->get_stream () == 0)
-    {
-      return;
-    }
+    return;
+
   PaError err;
   err = Pa_StopStream (stream);
-  if (err != paNoError) 
+  if (err != paNoError)
     {
       error ("audiorecorder: Error stoping audio recording stream");
       return;
-    } 
+    }
 }
 
-void audioplayer::resume ()
+void
+audioplayer::resume (void)
 {
-  if (this->get_stream() == 0)
-    {
-      return;
-    }
+  if (this->get_stream () == 0)
+    return;
+
   PaError err;
   err = Pa_StartStream (stream);
-  if (err != paNoError) 
+  if (err != paNoError)
     {
       error ("audiorecorder: Error starting audio recording stream");
       return;
     }
 }
 
-PaStream *audioplayer::get_stream()
+PaStream *
+audioplayer::get_stream (void)
 {
   return this->stream;
 }
 
-void audioplayer::stop()
+void
+audioplayer::stop (void)
 {
   if (this->get_stream () == 0)
-    {
-      return;
-    }
+    return;
+
   PaError err;
   this->set_sample_number (0);
   this->reset_end_sample ();
   if (not Pa_IsStreamStopped (this->get_stream ()))
     {
       err = Pa_AbortStream (this->get_stream ());
-      if (err != paNoError) 
+      if (err != paNoError)
         {
           error ("audioplayer: Error stopping audio playback stream");
           return;
         }
     }
+
   err = Pa_CloseStream (this->get_stream ());
-  if (err != paNoError) 
-    { 
+  if (err != paNoError)
+    {
       error ("audioplayer: Error closing audio playback stream");
       return;
     }
+
   stream = 0;
 }
 
-bool audioplayer::isplaying ()
+bool
+audioplayer::isplaying (void)
 {
-  if (this->get_stream() == 0)
-    {
-      return false;
-    }
+  if (this->get_stream () == 0)
+    return false;
+
   PaError err;
   err = Pa_IsStreamActive (stream);
-  if (err != 0 and err != 1) 
+  if (err != 0 and err != 1)
     {
       error ("audiorecorder: Error checking stream activity status");
       return false;
     }
-  return bool(err);
+
+  return (err == 1);
 }
diff --git a/libinterp/dldfcn/player_class.h b/libinterp/dldfcn/player_class.h
--- a/libinterp/dldfcn/player_class.h
+++ b/libinterp/dldfcn/player_class.h
@@ -25,84 +25,84 @@ along with Octave; see the file COPYING.
 
 #include <string>
 #include "oct.h"
 #include "ov-int32.h"
 #include <portaudio.h>
 
 #include "player_class.h"
 
-enum audio_type {INT8, UINT8, INT16, DOUBLE};
+enum audio_type { INT8, UINT8, INT16, DOUBLE };
 
-class audioplayer : public octave_base_value 
+class audioplayer : public octave_base_value
 {
 public:
-    audioplayer();
-    ~audioplayer();
-    // Overloaded base functions
-    double player_value() const { return 0; }
-    virtual double scalar_value (bool frc_str_conv = false) const 
-    {
-        return 0;
-    }
-    void print (std::ostream& os, bool pr_as_read_syntax = false) const;
-    void print_raw (std::ostream& os, bool pr_as_read_syntax) const;
-    // Properties
-    bool is_constant (void) const { return true;}
-    bool is_defined (void) const { return true;}
-    bool print_as_scalar (void) const { return true;}
+  audioplayer (void);
+  ~audioplayer (void) {};
+
+  // Overloaded base functions
+  double player_value (void) const { return 0; }
+  virtual double scalar_value (bool frc_str_conv = false) const { return 0; }
+  void print (std::ostream& os, bool pr_as_read_syntax = false) const;
+  void print_raw (std::ostream& os, bool pr_as_read_syntax) const;
+
+  // Properties
+  bool is_constant (void) const { return true; }
+  bool is_defined (void) const { return true; }
+  bool print_as_scalar (void) const { return true; }
 
-    void init();
-    void init_fn();
-    void set_y(octave_value y);
-    void set_y(octave_function *fn);
-    void set_y(std::string fn);
-    Matrix &get_y();
-    RowVector *get_left();
-    RowVector *get_right();
-    void set_fs(int fs);
-    int get_fs();
-    void set_nbits(int nbits);
-    int get_nbits();
-    void set_id(int id);
-    int get_id();
-    int get_channels();
-    audio_type get_type();
+  void init (void);
+  void init_fn (void);
+  void set_y (octave_value y);
+  void set_y (octave_function *fn);
+  void set_y (std::string fn);
+  Matrix& get_y (void);
+  RowVector *get_left (void);
+  RowVector *get_right (void);
+  void set_fs (int fs);
+  int get_fs (void);
+  void set_nbits (int nbits);
+  int get_nbits (void);
+  void set_id (int id);
+  int get_id (void);
+  int get_channels (void);
+  audio_type get_type (void);
 
-    void set_sample_number(unsigned int sample);
-    unsigned int get_sample_number();
-    unsigned int get_total_samples();
-    void set_end_sample(unsigned int sample);
-    unsigned int get_end_sample();
-    void reset_end_sample();
-    void set_tag(charMatrix tag);
-    charMatrix get_tag();
-    void set_userdata(octave_value userdata);
-    octave_value get_userdata();
-    PaStream *get_stream();
-    octave_function *octave_callback_function;
+  void set_sample_number (unsigned int sample);
+  unsigned int get_sample_number (void);
+  unsigned int get_total_samples (void);
+  void set_end_sample (unsigned int sample);
+  unsigned int get_end_sample (void);
+  void reset_end_sample (void);
+  void set_tag (charMatrix tag);
+  charMatrix get_tag (void);
+  void set_userdata (octave_value userdata);
+  octave_value get_userdata (void);
+  PaStream *get_stream (void);
+  octave_function *octave_callback_function;
 
-    void playblocking();
-    void play();
-    void pause();
-    void resume();
-    void stop();
-    bool isplaying();
+  void playblocking (void);
+  void play (void);
+  void pause (void);
+  void resume (void);
+  void stop (void);
+  bool isplaying (void);
+
 private:
-    Matrix y;
-    RowVector left;
-    RowVector right;
-    charMatrix tag;
-    octave_value userdata;
-    int channels;
-    int fs;
-    int nbits;
-    int id;
-    unsigned int sample_number;
-    unsigned int end_sample;
-    PaStream *stream;
-    PaStreamParameters output_parameters;
-    audio_type type;
-    DECLARE_OCTAVE_ALLOCATOR
-    DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
+  Matrix y;
+  RowVector left;
+  RowVector right;
+  charMatrix tag;
+  octave_value userdata;
+  int channels;
+  int fs;
+  int nbits;
+  int id;
+  unsigned int sample_number;
+  unsigned int end_sample;
+  PaStream *stream;
+  PaStreamParameters output_parameters;
+  audio_type type;
+  DECLARE_OCTAVE_ALLOCATOR
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif // PLAYER_CLASS_H
diff --git a/libinterp/dldfcn/recorder_class.cc b/libinterp/dldfcn/recorder_class.cc
--- a/libinterp/dldfcn/recorder_class.cc
+++ b/libinterp/dldfcn/recorder_class.cc
@@ -33,466 +33,480 @@ along with Octave; see the file COPYING.
 #include "player_class.h"
 #include "recorder_class.h"
 
 #define BUFFER_SIZE 512
 
 DEFINE_OCTAVE_ALLOCATOR (audiorecorder);
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (audiorecorder, "audiorecorder", "audiorecorder");
 
-static int octave_record_callback (const void *input, void *output,
-                                   unsigned long frames,
-                                   const PaStreamCallbackTimeInfo* time,
-                                   PaStreamCallbackFlags status,
-                                   void *data)
+static int
+octave_record_callback (const void *input, void *output,
+                        unsigned long frames,
+                        const PaStreamCallbackTimeInfo* time,
+                        PaStreamCallbackFlags status,
+                        void *data)
 {
   audiorecorder *recorder = (audiorecorder *)data;
   int channels = recorder->get_channels ();
-  int return_status;
   float sample_l, sample_r;
   Matrix sound;
-  sound.resize(frames, 2);
+  sound.resize (frames, 2);
   if (recorder->get_nbits () == 8)
     {
       int8_t *input8 = (int8_t *)input;
       for (int i = 0; i < frames; i++)
         {
-          sample_l = input8[i * channels] / (pow(2.0, 7) - 1.0);
-          sample_r = input8[i * channels + (channels - 1)] / (pow(2.0, 7) - 1.0);
+          sample_l = input8[i * channels] / (pow (2.0, 7) - 1.0);
+          sample_r = input8[i * channels + (channels - 1)] / (pow (2.0, 7) - 1.0);
           sound(i, 0) = sample_l;
           sound(i, 1) = sample_r;
         }
       }
   else if (recorder->get_nbits () == 16)
     {
       int16_t *input16 = (int16_t *)input;
       for (int i = 0; i < frames; i++)
         {
-          sample_l = input16[i * channels] / (pow(2.0, 15) - 1.0);
-          sample_r = input16[i * channels + (channels - 1)] / (pow(2.0, 15) - 1.0);
+          sample_l = input16[i * channels] / (pow (2.0, 15) - 1.0);
+          sample_r = input16[i * channels + (channels - 1)] / (pow (2.0, 15) - 1.0);
           sound(i, 0) = sample_l;
-          sound(i, 1) = sample_r;          
+          sound(i, 1) = sample_r;
         }
     }
   else if (recorder->get_nbits () == 24)
     {
       uint8_t *input24 = (uint8_t *)input;
       int32_t sample_l32, sample_r32;
       uint8_t *_sample_l = (uint8_t *)&sample_l;
       uint8_t *_sample_r = (uint8_t *)&sample_r;
       for (int i = 0; i < frames; i++)
         {
           for (int j = 0; j < 3; j++)
             {
               _sample_l[j] = input24[i * channels * 3 + j];
               _sample_r[j] = input24[i * channels * 3 + (channels - 1) * 3 + j];
             }
           if (sample_l32 & 0x00800000)
-            {
-              sample_l32 |= 0xff000000;
-            }
+            sample_l32 |= 0xff000000;
           if (sample_r32 & 0x00800000)
-            {
-              sample_r32 |= 0xff000000;
-            }
-          sound(i, 0) = sample_l32 / pow(2.0, 23);
-          sound(i, 1) = sample_r32 / pow(2.0, 23);
+            sample_r32 |= 0xff000000;
+          sound(i, 0) = sample_l32 / pow (2.0, 23);
+          sound(i, 1) = sample_r32 / pow (2.0, 23);
         }
     }
-    octave_value_list args, retval;
-    args(0) = sound;
-    retval = feval (recorder->octave_callback_function, args, 1);
-    return_status = retval(0).int_value ();
-    return return_status;
+
+  octave_value_list args, retval;
+  args(0) = sound;
+  retval = feval (recorder->octave_callback_function, args, 1);
+  return retval(0).int_value ();
 }
 
-static int portaudio_record_callback (const void *input, void *output,
-                               unsigned long frames,
-                               const PaStreamCallbackTimeInfo* time,
-                               PaStreamCallbackFlags status,
-                               void *data)
+static int
+portaudio_record_callback (const void *input, void *output,
+                           unsigned long frames,
+                           const PaStreamCallbackTimeInfo* time,
+                           PaStreamCallbackFlags status,
+                           void *data)
 {
   audiorecorder *recorder = (audiorecorder *)data;
   int channels = recorder->get_channels ();
   float sample_l, sample_r;
   if (recorder->get_nbits () == 8)
     {
       int8_t *input8 = (int8_t *)input;
       for (int i = 0; i < frames; i++)
         {
-          sample_l = input8[i * channels] / (pow(2.0, 7) - 1.0);
-          sample_r = input8[i * channels + (channels - 1)] / (pow(2.0, 7) - 1.0);
-          recorder->append(sample_l, sample_r);
+          sample_l = input8[i * channels] / (pow (2.0, 7) - 1.0);
+          sample_r = input8[i * channels + (channels - 1)] / (pow (2.0, 7) - 1.0);
+          recorder->append (sample_l, sample_r);
         }
-      }
+    }
   else if (recorder->get_nbits () == 16)
     {
       int16_t *input16 = (int16_t *)input;
       for (int i = 0; i < frames; i++)
         {
-          sample_l = input16[i * channels] / (pow(2.0, 15) - 1.0);
-          sample_r = input16[i * channels + (channels - 1)] / (pow(2.0, 15) - 1.0);
-          recorder->append(sample_l, sample_r);
+          sample_l = input16[i * channels] / (pow (2.0, 15) - 1.0);
+          sample_r = input16[i * channels + (channels - 1)] / (pow (2.0, 15) - 1.0);
+          recorder->append (sample_l, sample_r);
         }
     }
   else if (recorder->get_nbits () == 24)
     {
       uint8_t *input24 = (uint8_t *)input;
       int32_t sample_l32, sample_r32;
       uint8_t *_sample_l = (uint8_t *)&sample_l;
       uint8_t *_sample_r = (uint8_t *)&sample_r;
       for (int i = 0; i < frames; i++)
         {
           for (int j = 0; j < 3; j++)
             {
               _sample_l[j] = input24[i * channels * 3 + j];
               _sample_r[j] = input24[i * channels * 3 + (channels - 1) * 3 + j];
             }
           if (sample_l32 & 0x00800000)
-            {
-              sample_l32 |= 0xff000000;
-            }
+            sample_l32 |= 0xff000000;
           if (sample_r32 & 0x00800000)
-            {
-              sample_r32 |= 0xff000000;
-            }
-          recorder->append(sample_l32 / pow(2.0, 23), sample_r32 / pow(2.0, 23));
+            sample_r32 |= 0xff000000;
+          recorder->append (sample_l32 / pow (2.0, 23), sample_r32 / pow (2.0, 23));
         }
     }
-    if (recorder->get_sample_number () > recorder->get_end_sample ())
-      {
-        return paComplete;
-      }
-    return paContinue;
+
+  if (recorder->get_sample_number () > recorder->get_end_sample ())
+    return paComplete;
+
+  return paContinue;
 }
 
-audiorecorder::audiorecorder ()
+audiorecorder::audiorecorder (void)
 {
   this->id = -1;
   this->sample_number = 0;
   this->channels = 1;
   this->tag = charMatrix ("");
   Matrix userdata;
   this->userdata = octave_value (userdata);
   this->stream = 0;
   this->end_sample = -1;
-  this->set_fs(44100);
-  this->set_nbits(16);
-  this->set_channels(2);
+  this->set_fs (44100);
+  this->set_nbits (16);
+  this->set_channels (2);
   this->octave_callback_function = 0;
 }
 
-audiorecorder::~audiorecorder ()
-{
-
-}
-
-void audiorecorder::print (std::ostream& os, bool pr_as_read_syntax ) const
+void
+audiorecorder::print (std::ostream& os, bool pr_as_read_syntax) const
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 
-void audiorecorder::print_raw (std::ostream& os, bool pr_as_read_syntax) const
+void
+audiorecorder::print_raw (std::ostream& os, bool pr_as_read_syntax) const
 {
   os << 0;
 }
 
-void audiorecorder::init ()
+void
+audiorecorder::init (void)
 {
   PaError err;
   int device;
   err = Pa_Initialize ();
-  if (err != paNoError) 
-    { 
+  if (err != paNoError)
+    {
       error ("audiorecorder: Initialization error!");
       return;
     }
-  int numDevices;
-  numDevices = Pa_GetDeviceCount ();
-  if (numDevices < 0) 
+
+  int numDevices = Pa_GetDeviceCount ();
+  if (numDevices < 0)
     {
       error ("audiorecorder: No audio devices found!");
       return;
     }
+
   if (this->get_id () == -1)
-    {
-      device = Pa_GetDefaultInputDevice ();
-    }  
-  else 
-    {
-      device = this->get_id ();
-    }
+    device = Pa_GetDefaultInputDevice ();
+  else
+    device = this->get_id ();
+
   this->input_parameters.device = device;
   this->input_parameters.channelCount = this->get_channels ();
   this->input_parameters.sampleFormat = bits_to_format (this->get_nbits ());
   this->input_parameters.suggestedLatency = Pa_GetDeviceInfo (device)->defaultHighInputLatency;
   this->input_parameters.hostApiSpecificStreamInfo = NULL;
 }
 
-void audiorecorder::set_fs (int fs)
+void
+audiorecorder::set_fs (int fs)
 {
   this->fs = fs;
 }
 
-int audiorecorder::get_fs ()
+int
+audiorecorder::get_fs (void)
 {
   return this->fs;
 }
 
-void audiorecorder::set_nbits (int nbits)
+void
+audiorecorder::set_nbits (int nbits)
 {
   this->nbits = nbits;
 }
 
-int audiorecorder::get_nbits ()
+int
+audiorecorder::get_nbits (void)
 {
   return this->nbits;
 }
 
-void audiorecorder::set_id (int id)
+void
+audiorecorder::set_id (int id)
 {
   this->id = id;
 }
 
-int audiorecorder::get_id ()
+int
+audiorecorder::get_id (void)
 {
   return this->id;
 }
 
-void audiorecorder::set_channels (int channels)
+void
+audiorecorder::set_channels (int channels)
 {
-  assert(channels == 1 or channels == 2);
+  assert (channels == 1 or channels == 2);
   this->channels = channels;
 }
 
-int audiorecorder::get_channels ()
+int
+audiorecorder::get_channels (void)
 {
   return this->channels;
 }
 
-audio_type audiorecorder::get_type ()
+audio_type
+audiorecorder::get_type (void)
 {
   return this->type;
 }
 
-void audiorecorder::set_sample_number (unsigned int sample_number)
+void
+audiorecorder::set_sample_number (unsigned int sample_number)
 {
   this->sample_number = sample_number;
 }
 
-unsigned int audiorecorder::get_sample_number ()
+unsigned int
+audiorecorder::get_sample_number (void)
 {
   return this->sample_number;
 }
 
-unsigned int audiorecorder::get_total_samples ()
+unsigned int
+audiorecorder::get_total_samples (void)
 {
   return this->left.size ();
 }
 
-void audiorecorder::set_end_sample (unsigned int end_sample)
+void
+audiorecorder::set_end_sample (unsigned int end_sample)
 {
   this->end_sample = end_sample;
 }
 
-unsigned int audiorecorder::get_end_sample ()
+unsigned int
+audiorecorder::get_end_sample (void)
 {
   return this->end_sample;
 }
 
-void audiorecorder::reset_end_sample ()
+void
+audiorecorder::reset_end_sample (void)
 {
   this->set_end_sample (this->left.size ());
 }
 
-void audiorecorder::set_tag (charMatrix tag)
+void
+audiorecorder::set_tag (charMatrix tag)
 {
   this->tag = tag;
 }
 
-charMatrix audiorecorder::get_tag ()
+charMatrix
+audiorecorder::get_tag (void)
 {
   return this->tag;
 }
 
-void audiorecorder::set_userdata (octave_value userdata)
+void
+audiorecorder::set_userdata (octave_value userdata)
 {
   this->userdata = userdata;
 }
 
-octave_value audiorecorder::get_userdata ()
+octave_value
+audiorecorder::get_userdata (void)
 {
   return this->userdata;
 }
 
-octave_value audiorecorder::getaudiodata()
+octave_value
+audiorecorder::getaudiodata (void)
 {
-  Matrix audio (2, this->left.size());
-  for (int i = 0; i < this->left.size(); i++)
+  Matrix audio (2, this->left.size ());
+  for (int i = 0; i < this->left.size (); i++)
     {
       audio(0, i) = this->left[i];
       audio(1, i) = this->right[i];
     }
   return octave_value (audio);
 }
 
-audioplayer *audiorecorder::getplayer ()
+audioplayer *
+audiorecorder::getplayer (void)
 {
   audioplayer *player = new audioplayer ();
-  player->set_y(this->getaudiodata ());
-  player->set_fs(this->get_fs ());
-  player->set_nbits(this->get_nbits ());
-  player->init();
+  player->set_y (this->getaudiodata ());
+  player->set_fs (this->get_fs ());
+  player->set_nbits (this->get_nbits ());
+  player->init ();
   return player;
 }
 
-bool audiorecorder::isrecording()
+bool
+audiorecorder::isrecording (void)
 {
-  if (this->get_stream() == 0)
-    {
-      return false;
-    }
+  if (this->get_stream () == 0)
+    return false;
+
   PaError err;
   err = Pa_IsStreamActive (stream);
-  if (err != 0 and err != 1) 
+  if (err != 0 and err != 1)
     {
       error ("audiorecorder: Error checking stream activity status");
       return false;
     }
-  return bool(err);
+
+  return (err == 1);
 }
 
-void audiorecorder::record()
+void
+audiorecorder::record (void)
 {
-  if (this->get_stream())
-    {
-      this->stop ();
-    }
+  if (this->get_stream ())
+    this->stop ();
+
   this->left.clear ();
   this->right.clear ();
   PaError err;
   if (this->octave_callback_function != 0)
     {
       err = Pa_OpenStream (&stream, &(this->input_parameters), NULL, this->get_fs (), BUFFER_SIZE, paClipOff, octave_record_callback, (void *)this);
     }
   else
     {
       err = Pa_OpenStream (&stream, &(this->input_parameters), NULL, this->get_fs (), BUFFER_SIZE, paClipOff, portaudio_record_callback, (void *)this);
     }
-  if (err != paNoError) 
-    { 
+  if (err != paNoError)
+    {
       error ("audiorecorder: Error opening audio recording stream");
       return;
     }
   err = Pa_StartStream (stream);
-  if (err != paNoError) 
+  if (err != paNoError)
     {
       error ("audiorecorder: Error starting audio recording stream");
       return;
     }
 }
 
-void audiorecorder::recordblocking (float seconds)
+void
+audiorecorder::recordblocking (float seconds)
 {
   if (this->get_stream ())
-    {
-      this->stop ();
-    }
+    this->stop ();
+
   this->left.clear ();
   this->right.clear ();
+
   PaError err;
   err = Pa_OpenStream (&stream, &(this->input_parameters), NULL, this->get_fs (), BUFFER_SIZE, paClipOff, NULL, (void *)this);
-  if (err != paNoError) 
-    { 
+  if (err != paNoError)
+    {
       error ("audiorecorder: Error opening audio recording stream");
       return;
     }
+
   err = Pa_StartStream (stream);
-  if (err != paNoError) 
+  if (err != paNoError)
     {
       error ("audiorecorder: Error starting audio recording stream");
       return;
     }
+
   unsigned int frames = seconds * this->get_fs ();
   uint8_t buffer[BUFFER_SIZE * 2 * 3];
   for (int i = 0; i < frames / BUFFER_SIZE; i++)
     {
-      Pa_ReadStream(this->get_stream (), (void *)buffer, BUFFER_SIZE);
+      Pa_ReadStream (this->get_stream (), (void *)buffer, BUFFER_SIZE);
       if (this->octave_callback_function != 0)
-        {
-          octave_record_callback((void *)buffer, NULL, BUFFER_SIZE, 0, 0, (void *)this);
-        }
+        octave_record_callback ((void *)buffer, NULL, BUFFER_SIZE, 0, 0, (void *)this);
       else
-        {
-          portaudio_record_callback((void *)buffer, NULL, BUFFER_SIZE, 0, 0, (void *)this);
-        }
+        portaudio_record_callback ((void *)buffer, NULL, BUFFER_SIZE, 0, 0, (void *)this);
     }
 }
 
-void audiorecorder::pause ()
+void
+audiorecorder::pause (void)
 {
   if (this->get_stream () == 0)
-    {
-      return;
-    }
+    return;
+
   PaError err;
   err = Pa_StopStream (stream);
-  if (err != paNoError) 
+  if (err != paNoError)
     {
       error ("audiorecorder: Error stoping audio recording stream");
       return;
-    } 
+    }
 }
 
-void audiorecorder::resume()
+void
+audiorecorder::resume (void)
 {
-  if (this->get_stream() == 0)
-    {
-      return;
-    }
+  if (this->get_stream () == 0)
+    return;
+
   PaError err;
   err = Pa_StartStream (stream);
-  if (err != paNoError) 
+  if (err != paNoError)
     {
       error ("audiorecorder: Error starting audio recording stream");
       return;
     }
 }
 
-void audiorecorder::stop()
+void
+audiorecorder::stop (void)
 {
-  if (this->get_stream() == 0)
-    {
-      return;
-    }
+  if (this->get_stream () == 0)
+    return;
+
   PaError err;
   if (not Pa_IsStreamStopped (this->get_stream ()))
     {
       err = Pa_AbortStream (this->get_stream ());
-      if (err != paNoError) 
+      if (err != paNoError)
         {
           error ("audioplayer: Error stopping audio playback stream");
           return;
         }
     }
+
   err = Pa_CloseStream (stream);
-  if (err != paNoError) 
-    { 
+  if (err != paNoError)
+    {
       error ("audiorecorder: Error closing audio recording stream");
       return;
     }
+
   this->set_sample_number (0);
   this->reset_end_sample ();
   stream = 0;
 }
 
-void audiorecorder::append (float sample_l, float sample_r)
+void
+audiorecorder::append (float sample_l, float sample_r)
 {
   this->left.push_back (sample_l);
   this->right.push_back (sample_r);
   this->set_sample_number (this->get_sample_number () + 1);
 }
 
-PaStream *audiorecorder::get_stream()
+PaStream *
+audiorecorder::get_stream (void)
 {
   return this->stream;
 }
diff --git a/libinterp/dldfcn/recorder_class.h b/libinterp/dldfcn/recorder_class.h
--- a/libinterp/dldfcn/recorder_class.h
+++ b/libinterp/dldfcn/recorder_class.h
@@ -26,80 +26,80 @@ along with Octave; see the file COPYING.
 #include <vector>
 
 #include "oct.h"
 #include "ov-int32.h"
 #include <portaudio.h>
 
 #include "player_class.h"
 
-class audiorecorder : public octave_base_value 
+class audiorecorder : public octave_base_value
 {
 public:
-    audiorecorder();
-    ~audiorecorder();
-    // Overloaded base functions
-    double player_value() const { return 0; }
-    virtual double scalar_value (bool frc_str_conv = false) const 
-    {
-        return 0;
-    }
-    void print (std::ostream& os, bool pr_as_read_syntax = false) const;
-    void print_raw (std::ostream& os, bool pr_as_read_syntax) const;
-    // Properties
-    bool is_constant (void) const { return true;}
-    bool is_defined (void) const { return true;}
-    bool print_as_scalar (void) const { return true;}
+  audiorecorder (void);
+  ~audiorecorder (void) {};
+
+  // Overloaded base functions
+  double player_value (void) const { return 0; }
+  virtual double scalar_value (bool frc_str_conv = false) const { return 0; }
+  void print (std::ostream& os, bool pr_as_read_syntax = false) const;
+  void print_raw (std::ostream& os, bool pr_as_read_syntax) const;
 
-    void init();
-    void set_fs(int fs);
-    int get_fs();
-    void set_nbits(int nbits);
-    int get_nbits();
-    void set_id(int id);
-    int get_id();
-    void set_channels(int channels);
-    int get_channels();
-    audio_type get_type();
+  // Properties
+  bool is_constant (void) const { return true; }
+  bool is_defined (void) const { return true; }
+  bool print_as_scalar (void) const { return true; }
+
+  void init (void);
+  void set_fs (int fs);
+  int get_fs (void);
+  void set_nbits (int nbits);
+  int get_nbits (void);
+  void set_id (int id);
+  int get_id (void);
+  void set_channels (int channels);
+  int get_channels (void);
+  audio_type get_type (void);
 
-    void set_sample_number(unsigned int sample);
-    unsigned int get_sample_number();
-    unsigned int get_total_samples();
-    void set_end_sample(unsigned int sample);
-    unsigned int get_end_sample();
-    void reset_end_sample();
-    void set_tag(charMatrix tag);
-    charMatrix get_tag();
-    void set_userdata(octave_value userdata);
-    octave_value get_userdata();
-    PaStream *get_stream();
-    octave_function *octave_callback_function;
+  void set_sample_number (unsigned int sample);
+  unsigned int get_sample_number (void);
+  unsigned int get_total_samples (void);
+  void set_end_sample (unsigned int sample);
+  unsigned int get_end_sample (void);
+  void reset_end_sample (void);
+  void set_tag (charMatrix tag);
+  charMatrix get_tag (void);
+  void set_userdata (octave_value userdata);
+  octave_value get_userdata (void);
+  PaStream *get_stream (void);
+  octave_function *octave_callback_function;
 
-    octave_value getaudiodata();
-    audioplayer *getplayer();
-    bool isrecording();
-    audioplayer play();
-    void record();
-    void recordblocking(float seconds);
-    void pause();
-    void resume();
-    void stop();
-    void append(float sample_l, float sample_r);
+  octave_value getaudiodata (void);
+  audioplayer *getplayer (void);
+  bool isrecording (void);
+  audioplayer play (void);
+  void record (void);
+  void recordblocking (float seconds);
+  void pause (void);
+  void resume (void);
+  void stop (void);
+  void append (float sample_l, float sample_r);
+
 private:
-    Matrix y;
-    std::vector<float> left;
-    std::vector<float> right;
-    charMatrix tag;
-    octave_value userdata;
-    int channels;
-    int fs;
-    int nbits;
-    int id;
-    unsigned int sample_number;
-    unsigned int end_sample;
-    PaStream *stream;
-    PaStreamParameters input_parameters;
-    audio_type type;
-    DECLARE_OCTAVE_ALLOCATOR
-    DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
+  Matrix y;
+  std::vector<float> left;
+  std::vector<float> right;
+  charMatrix tag;
+  octave_value userdata;
+  int channels;
+  int fs;
+  int nbits;
+  int id;
+  unsigned int sample_number;
+  unsigned int end_sample;
+  PaStream *stream;
+  PaStreamParameters input_parameters;
+  audio_type type;
+  DECLARE_OCTAVE_ALLOCATOR
+  DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif // RECORDER_CLASS_H
diff --git a/scripts/audio/@audioplayer/__get_properties__.m b/scripts/audio/@audioplayer/__get_properties__.m
--- a/scripts/audio/@audioplayer/__get_properties__.m
+++ b/scripts/audio/@audioplayer/__get_properties__.m
@@ -17,21 +17,21 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn{Function File} @var{Properties} = __get_properties__ (@var{playerObj})
 ## For a given audioplayer object this function gathers and returns the current values of all properties.
 ## @end deftypefn
 
 function properties = __get_properties__ (player)
-  properties.BitsPerSample = __player_get_nbits__ (struct(player).player);
-  properties.CurrentSample = __player_get_sample_number__ (struct(player).player);
-  properties.DeviceID = __player_get_id__ (struct(player).player);
-  properties.NumberOfChannels = __player_get_channels__ (struct(player).player);
-  if __player_isplaying__ (struct(player).player)
+  properties.BitsPerSample = __player_get_nbits__ (struct (player).player);
+  properties.CurrentSample = __player_get_sample_number__ (struct (player).player);
+  properties.DeviceID = __player_get_id__ (struct (player).player);
+  properties.NumberOfChannels = __player_get_channels__ (struct (player).player);
+  if __player_isplaying__ (struct (player).player)
     running = "on";
   else
     running = "off";
   endif
   properties.Running = running;
   properties.SampleRate = __player_get_fs__ (struct (player).player);
   properties.TotalSamples = __player_get_total_samples__ (struct (player).player);
   properties.Tag = __player_get_tag__ (struct (player).player);
diff --git a/scripts/audio/@audioplayer/audioplayer.m b/scripts/audio/@audioplayer/audioplayer.m
--- a/scripts/audio/@audioplayer/audioplayer.m
+++ b/scripts/audio/@audioplayer/audioplayer.m
@@ -67,43 +67,43 @@
 ## @code{  nr = incr * frames;}
 ## @code{  left = sin (2.0 * pi * [lphase:incl:lphase+nl]);}
 ## @code{  right = sin (2.0 * pi * [rphase:incr:rphase+nr]);}
 ## @code{  sound = [left', right'];}
 ## @code{  status = 0;}
 ## @code{  lphase = lphase + nl;}
 ## @code{  rphase = rphase + nr;}
 ## @code{endfunction}
-## @code{player = audioplayer(@@callback_sine, 44100);}
+## @code{player = audioplayer (@@callback_sine, 44100);}
 ## @code{play (player);}
 ## @code{# play for as long as you want}
 ## @code{stop (player);}
 ## @end group
 ## @end example
 
 function player = audioplayer (varargin)
   if (nargin < 1 || nargin > 4)
     print_usage ();
   endif
-  if ((isa(varargin{1}, 'function_handle') || ischar(varargin{1})) && nargin < 2)
+  if ((isa (varargin{1}, "function_handle") || ischar (varargin{1})) && nargin < 2)
     print_usage ();
   endif
-  if isa (varargin{1}, 'audiorecorder')
+  if isa (varargin{1}, "audiorecorder")
     if nargin == 1
-      player = getplayer(varargin{1});
+      player = getplayer (varargin{1});
     elseif nargin == 2
       recorder = varargin{1};
       data = getaudiodata (recorder);
-      player = audioplayer (data, get (recorder, 'SampleRate'), get (recorder, 'BitsPerSample'), varargin{2});    
+      player = audioplayer (data, get (recorder, "SampleRate"), get (recorder, "BitsPerSample"), varargin{2});
     else
       print_usage ();
     endif
   else
-    if ischar(varargin{1})
-      varargin{1} = str2func(varargin{1});
+    if ischar (varargin{1})
+      varargin{1} = str2func (varargin{1});
     endif
     player.player = __player_audioplayer__ (varargin{:});
     player = class (player, "audioplayer");
   endif
 endfunction
 
 %!test
 %!  mono = randn (1, 44100) - 0.5;
@@ -147,43 +147,43 @@ endfunction
 %!  sleep (1);
 %!  assert (!isplaying (player));
 %!  assert (player.CurrentSample, 0);
 
 %!test
 %!  audio = randn (2, 44100) - 0.5;
 %!  fs = 44100;
 %!  player = audioplayer (audio, fs);
-%!  set (player, {'SampleRate', 'Tag', 'UserData'}, {8000, 'tag', [1, 2; 3, 4]});
+%!  set (player, {"SampleRate", "Tag", "UserData"}, {8000, "tag", [1, 2; 3, 4]});
 %!  assert (player.SampleRate, 8000);
-%!  assert (player.Tag, 'tag');
+%!  assert (player.Tag, "tag");
 %!  assert (player.UserData, [1, 2; 3, 4]);
 
 %!test
 %!  audio = randn (2, 44100) - 0.5;
 %!  fs = 44100;
 %!  player = audioplayer (audio, fs);
 %!  settable = set (player);
 %!  settable.SampleRate = 8000;
-%!  settable.Tag = 'tag';
+%!  settable.Tag = "tag";
 %!  settable.UserData = [1, 2; 3, 4];
 %!  set (player, settable);
 %!  assert (player.SampleRate, 8000);
-%!  assert (player.Tag, 'tag');
+%!  assert (player.Tag, "tag");
 %!  assert (player.UserData, [1, 2; 3, 4]);
 
 %!test
 %!  audio = randn (2, 44100) - 0.5;
 %!  fs = 44100;
 %!  player = audioplayer (audio, fs);
 %!  player.SampleRate = 8000;
-%!  player.Tag = 'tag';
+%!  player.Tag = "tag";
 %!  player.UserData = [1, 2; 3, 4];
-%!  properties = get (player, {'SampleRate', 'Tag', 'UserData'});
-%!  assert (properties, {8000, 'tag', [1, 2; 3, 4]});
+%!  properties = get (player, {"SampleRate", "Tag", "UserData"});
+%!  assert (properties, {8000, "tag", [1, 2; 3, 4]});
 
 %!function [ sound, status ] = callback (samples)
 %!  sound = rand (samples, 2) - 0.5;
 %!  status = 0;
 %!endfunction
 
 %!test
 %!  player = audioplayer (@callback, 44100);
@@ -191,10 +191,10 @@ endfunction
 %!  sleep (2);
 %!  stop (player);
 %!  assert (1);
 
 %!test
 %!  player = audioplayer ("callback", 44100, 16);
 %!  play (player);
 %!  sleep (2);
-%!  stop(player);
+%!  stop (player);
 %!  assert (1);
diff --git a/scripts/audio/@audioplayer/display.m b/scripts/audio/@audioplayer/display.m
--- a/scripts/audio/@audioplayer/display.m
+++ b/scripts/audio/@audioplayer/display.m
@@ -16,11 +16,11 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn{Function File} display (@var{playerObj})
 ## Display an audioplayer object.
 ## @end deftypefn
 
-function display(player)
-  disp(__get_properties__(player));
+function display (player)
+  disp (__get_properties__ (player));
 endfunction
diff --git a/scripts/audio/@audioplayer/get.m b/scripts/audio/@audioplayer/get.m
--- a/scripts/audio/@audioplayer/get.m
+++ b/scripts/audio/@audioplayer/get.m
@@ -19,32 +19,32 @@
 ## -*- texinfo -*-
 ## @deftypefn{Function File} @var{Value} = get (@var{playerObj}, @var{Name})
 ## Returns the @var{Value} of the property identified by @var{Name}.
 ## @end deftypefn
 ## @deftypefn{Function File} @var{Values} = get (@var{playerObj}, @{@var{Name1}, ... , @var{NameN}@})
 ## Returns the @var{Values} of the properties identified by @var{Name1} to @var{NameN}.
 ## @end deftypefn
 ## @deftypefn{Function File} @var{Values} = get (@var{playerObj})
-## Returns a scalar structure with values of all properties of @var{playerObj}. 
+## Returns a scalar structure with values of all properties of @var{playerObj}.
 ## The field names correspond to property names.
 ## @end deftypefn
 
 function result = get (varargin)
   player = varargin{1};
   properties = __get_properties__ (player);
   if nargin == 1
     result = properties;
   elseif nargin == 2
     if ischar (varargin{2})
       result = getfield (properties, varargin{2});
     else
       result = {};
       index = 1;
       for property = varargin{2}
-        result{index} = getfield (properties, char(property));
+        result{index} = getfield (properties, char (property));
         index = index + 1;
       endfor
     endif
   else
-    error ('audioplayer: wrong number of arguments to the get method');
+    error ("audioplayer: wrong number of arguments to the get method");
   endif
 endfunction
diff --git a/scripts/audio/@audioplayer/isplaying.m b/scripts/audio/@audioplayer/isplaying.m
--- a/scripts/audio/@audioplayer/isplaying.m
+++ b/scripts/audio/@audioplayer/isplaying.m
@@ -17,11 +17,11 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn{Function File} isplaying (@var{playerObj})
 ## Returns 1 if the audioplayer object is currently playing back audio.
 ## Returns 0 otherwise.
 ## @end deftypefn
 
-function result = isplaying(player)
-    result = __player_isplaying__(struct(player).player);
+function result = isplaying (player)
+  result = __player_isplaying__ (struct (player).player);
 endfunction
diff --git a/scripts/audio/@audioplayer/pause.m b/scripts/audio/@audioplayer/pause.m
--- a/scripts/audio/@audioplayer/pause.m
+++ b/scripts/audio/@audioplayer/pause.m
@@ -16,11 +16,11 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn{Function File} pause (@var{playerObj})
 ## Pause the playback with the possibility of resuming it later at the same place.
 ## @end deftypefn
 
-function pause(player)
-    __player_pause__(struct(player).player);
+function pause (player)
+  __player_pause__ (struct (player).player);
 endfunction
diff --git a/scripts/audio/@audioplayer/play.m b/scripts/audio/@audioplayer/play.m
--- a/scripts/audio/@audioplayer/play.m
+++ b/scripts/audio/@audioplayer/play.m
@@ -22,14 +22,14 @@
 ## @end deftypefn
 ## @deftypefn{Function File} play  (@var{playerObj}, @var{start})
 ## Play back audio stored in an audioplayer object starting at the time in seconds specified by @var{start}.
 ## @end deftypefn
 ## @deftypefn{Function File} play (@var{playerObj}, [@var{start}, @var{end}])
 ## Play back audio stored in an audioplayer object starting at the time in seconds specified by @var{start} and ending at the time specified by @var{end}.
 ## @end deftypefn
 
-function play(varargin)
+function play (varargin)
   if (nargin < 1 || nargin > 2)
     print_usage ();
-  endif 
-  __player_play__(struct(varargin{1}).player, varargin{2:end});
+  endif
+  __player_play__ (struct (varargin{1}).player, varargin{2:end});
 endfunction
diff --git a/scripts/audio/@audioplayer/playblocking.m b/scripts/audio/@audioplayer/playblocking.m
--- a/scripts/audio/@audioplayer/playblocking.m
+++ b/scripts/audio/@audioplayer/playblocking.m
@@ -22,14 +22,14 @@
 ## @end deftypefn
 ## @deftypefn{Function File} playblocking (@var{playerObj}, @var{start})
 ## Play back audio stored in the audioplayer object starting at the time in seconds specified by @var{start}.
 ## @end deftypefn
 ## @deftypefn{Function File} playblocking (@var{playerObj}, [@var{start}, @var{end}])
 ## Play back audio stored in the audioplayer object starting at the time in seconds specified by @var{start} and ending at the time specified by @var{end}.
 ## @end deftypefn
 
-function playblocking(varargin)
+function playblocking (varargin)
   if (nargin < 1 || nargin > 2)
     print_usage ();
-  endif 
-  __player_playblocking__(struct(varargin{1}).player, varargin{2:end});
+  endif
+  __player_playblocking__ (struct (varargin{1}).player, varargin{2:end});
 endfunction
diff --git a/scripts/audio/@audioplayer/resume.m b/scripts/audio/@audioplayer/resume.m
--- a/scripts/audio/@audioplayer/resume.m
+++ b/scripts/audio/@audioplayer/resume.m
@@ -16,11 +16,11 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn{Function File} resume (@var{playerObj})
 ## Resume playback for a previously paused audioplayer object.
 ## @end deftypefn
 
-function resume(player)
-    __player_resume__(struct(player).player);
+function resume (player)
+  __player_resume__ (struct (player).player);
 endfunction
diff --git a/scripts/audio/@audioplayer/set.m b/scripts/audio/@audioplayer/set.m
--- a/scripts/audio/@audioplayer/set.m
+++ b/scripts/audio/@audioplayer/set.m
@@ -27,46 +27,46 @@
 ## Given a structure where fields are property names, set the value of those properties for an audioplayer object to corresponding values.
 ## @end deftypefn
 ## @deftypefn{Function File} @var{settableProperties} = set (@var{playerObj})
 ## Returns a structure of settable properties.
 ## @end deftypefn
 
 function settable = set (varargin)
   if nargin < 1 || nargin > 3
-    print_usage();
+    print_usage ();
   endif
   player = struct (varargin{1}).player;
   if nargin == 1
     settable.SampleRate = {};
     settable.Tag = {};
     settable.UserData = {};
   elseif nargin == 2
     for [value, property] = varargin{2}
       setproperty (player, property, value);
     endfor
   elseif nargin == 3
     if iscell (varargin{2})
       index = 1;
       for property = varargin{2}
-        setproperty (player, char(property), varargin{3}{index});
+        setproperty (player, char (property), varargin{3}{index});
         index = index + 1;
       endfor
     else
       setproperty (player, varargin{2}, varargin{3});
     endif
   else
-    error ('audioplayer: wrong number of arguments to the set method');
+    error ("audioplayer: wrong number of arguments to the set method");
   endif
 endfunction
 
 function setproperty (player, property, value)
-  switch property
-    case 'SampleRate'
+  switch (property)
+    case "SampleRate"
       __player_set_fs__ (player, value);
-    case 'Tag'
+    case "Tag"
       __player_set_tag__ (player, value);
-    case 'UserData'
+    case "UserData"
       __player_set_userdata__ (player, value);
     otherwise
-      error ('audioplayer: no such property or the property specified is read-only');
+      error ("audioplayer: no such property or the property specified is read-only");
   endswitch
 endfunction
diff --git a/scripts/audio/@audioplayer/stop.m b/scripts/audio/@audioplayer/stop.m
--- a/scripts/audio/@audioplayer/stop.m
+++ b/scripts/audio/@audioplayer/stop.m
@@ -16,11 +16,11 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn{Function File} stop (@var{playerObj})
 ## Stop the playback and reset the relevant variables to their starting values.
 ## @end deftypefn
 
-function stop(player)
-    __player_stop__(struct(player).player);
+function stop (player)
+  __player_stop__ (struct (player).player);
 endfunction
diff --git a/scripts/audio/@audioplayer/subsasgn.m b/scripts/audio/@audioplayer/subsasgn.m
--- a/scripts/audio/@audioplayer/subsasgn.m
+++ b/scripts/audio/@audioplayer/subsasgn.m
@@ -11,20 +11,20 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-function value = subsasgn(player, idx, rhs)
+function value = subsasgn (player, idx, rhs)
   if (isempty (idx))
     error ("audioplayer: missing index");
   endif
-  if (strcmp(idx(1).type, "."))
+  if (strcmp (idx(1).type, "."))
     field = idx.subs;
-    set(player, field, rhs);
+    set (player, field, rhs);
     value = player;
   else
     error ("audioplayer: invalid subscript type");
   endif
 endfunction
diff --git a/scripts/audio/@audioplayer/subsref.m b/scripts/audio/@audioplayer/subsref.m
--- a/scripts/audio/@audioplayer/subsref.m
+++ b/scripts/audio/@audioplayer/subsref.m
@@ -11,19 +11,19 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-function value = subsref(player, idx)
+function value = subsref (player, idx)
   if (isempty (idx))
     error ("audioplayer: missing index");
   endif
-  if (strcmp(idx(1).type, "."))
+  if (strcmp (idx(1).type, "."))
     field = idx.subs;
-    value = get(player, field);
+    value = get (player, field);
   else
     error ("audioplayer: invalid subscript file")
   endif
 endfunction
diff --git a/scripts/audio/@audiorecorder/__get_properties__.m b/scripts/audio/@audiorecorder/__get_properties__.m
--- a/scripts/audio/@audiorecorder/__get_properties__.m
+++ b/scripts/audio/@audiorecorder/__get_properties__.m
@@ -12,21 +12,21 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 function properties = __get_properties__ (recorder)
-  properties.BitsPerSample = __recorder_get_nbits__ (struct(recorder).recorder);
-  properties.CurrentSample = __recorder_get_sample_number__ (struct(recorder).recorder);
-  properties.DeviceID = __recorder_get_id__ (struct(recorder).recorder);
-  properties.NumberOfChannels = __recorder_get_channels__ (struct(recorder).recorder);
-  if __recorder_isrecording__ (struct(recorder).recorder)
+  properties.BitsPerSample = __recorder_get_nbits__ (struct (recorder).recorder);
+  properties.CurrentSample = __recorder_get_sample_number__ (struct (recorder).recorder);
+  properties.DeviceID = __recorder_get_id__ (struct (recorder).recorder);
+  properties.NumberOfChannels = __recorder_get_channels__ (struct (recorder).recorder);
+  if __recorder_isrecording__ (struct (recorder).recorder)
     running = "on";
   else
     running = "off";
   endif
   properties.Running = running;
   properties.SampleRate = __recorder_get_fs__ (struct (recorder).recorder);
   properties.TotalSamples = __recorder_get_total_samples__ (struct (recorder).recorder);
   properties.Tag = __recorder_get_tag__ (struct (recorder).recorder);
diff --git a/scripts/audio/@audiorecorder/audiorecorder.m b/scripts/audio/@audiorecorder/audiorecorder.m
--- a/scripts/audio/@audiorecorder/audiorecorder.m
+++ b/scripts/audio/@audiorecorder/audiorecorder.m
@@ -35,43 +35,43 @@
 ## @deftypefn{Function File} recorder = audiorecorder (@var{function}, @var{Fs}, @var{nBytes}, @var{ID})
 ## Same as above but also allows you to specify device ID that will be used.
 ## @end deftypefn
 
 function recorder = audiorecorder (varargin)
   if (nargin > 5)
     print_usage ();
   endif
-  if nargin > 0 && ischar(varargin{1})
-    varargin{1} = str2func(varargin{1});
+  if nargin > 0 && ischar (varargin{1})
+    varargin{1} = str2func (varargin{1});
   endif
   recorder.recorder = __recorder_audiorecorder__ (varargin{:});
   recorder = class (recorder, "audiorecorder");
 endfunction
 
 %!test
 %!  recorder = audiorecorder (44100, 16, 2);
 %!  recordblocking (recorder, 1);
-%!  data = getaudiodata (recorder, 'int16');
-%!  assert (strcmp (class (data), 'int16'));
-%!  data = getaudiodata (recorder, 'int8');
-%!  assert (strcmp (class (data), 'int8'));
-%!  data = getaudiodata (recorder, 'uint8');
-%!  assert (strcmp (class (data), 'uint8'));
+%!  data = getaudiodata (recorder, "int16");
+%!  assert (strcmp (class (data), "int16"));
+%!  data = getaudiodata (recorder, "int8");
+%!  assert (strcmp (class (data), "int8"));
+%!  data = getaudiodata (recorder, "uint8");
+%!  assert (strcmp (class (data), "uint8"));
 %!  assert (size (data)(1), recorder.TotalSamples);
 %!  assert (size (data)(2), 2);
 %!  assert (size (data)(1) != 0);
 
 %!test
 %!  recorder = audiorecorder (44100, 16, 2);
 %!  record (recorder, 1)
 %!  sleep (2);
 %!  record (recorder, 1);
 %!  sleep (2);
-%!  data = getaudiodata(recorder);
+%!  data = getaudiodata (recorder);
 %!  assert (size (data)(1) < 44100 * 2);
 
 %!test
 %!  recorder = audiorecorder (44100, 16, 2);
 %!  record (recorder, 1);
 %!  sleep (2);
 %!  player1 = audioplayer (recorder);
 %!  player2 = getplayer (recorder);
@@ -79,58 +79,58 @@ endfunction
 %!  sleep (2);
 %!  play (player2);
 %!  sleep (2);
 %!  assert (player1.TotalSamples, recorder.TotalSamples);
 %!  assert (player2.TotalSamples, recorder.TotalSamples);
 
 %!test
 %!  recorder = audiorecorder;
-%!  set (recorder, {'SampleRate', 'Tag', 'UserData'}, {8000, 'tag', [1, 2; 3, 4]});
+%!  set (recorder, {"SampleRate", "Tag", "UserData"}, {8000, "tag", [1, 2; 3, 4]});
 %!  assert (recorder.SampleRate, 8000);
-%!  assert (recorder.Tag, 'tag');
+%!  assert (recorder.Tag, "tag");
 %!  assert (recorder.UserData, [1, 2; 3, 4]);
 
 %!test
 %!  recorder = audiorecorder;
 %!  settable = set (recorder);
 %!  settable.SampleRate = 8000;
-%!  settable.Tag = 'tag';
+%!  settable.Tag = "tag";
 %!  settable.UserData = [1, 2; 3, 4];
 %!  set (recorder, settable);
 %!  assert (recorder.SampleRate, 8000);
-%!  assert (recorder.Tag, 'tag');
+%!  assert (recorder.Tag, "tag");
 %!  assert (recorder.UserData, [1, 2; 3, 4]);
 
 %!test
 %!  recorder = audiorecorder;
 %!  recorder.SampleRate = 8000;
-%!  recorder.Tag = 'tag';
+%!  recorder.Tag = "tag";
 %!  recorder.UserData = [1, 2; 3, 4];
-%!  properties = get (recorder, {'SampleRate', 'Tag', 'UserData'});
-%!  assert (properties, {8000, 'tag', [1, 2; 3, 4]});
+%!  properties = get (recorder, {"SampleRate", "Tag", "UserData"});
+%!  assert (properties, {8000, "tag", [1, 2; 3, 4]});
 
 #%!function status = callback_record (sound)
-#%!  fid = fopen('record.txt', 'at');
+#%!  fid = fopen ("record.txt", "at");
 #%!  for index = 1:rows(sound)
-#%!    fprintf(fid, "%.4f, %.4f\n", sound(index, 1), sound(index, 2));
+#%!    fprintf (fid, "%.4f, %.4f\n", sound(index, 1), sound(index, 2));
 #%!  endfor
-#%!  fclose(fid);
+#%!  fclose (fid);
 #%!  status = 0;
 #%!endfunction
 
 #%!test
 #%!  recorder = audiorecorder (@callback_record, 44100);
-#%!  unlink('record.txt')
+#%!  unlink ("record.txt")
 #%!  record (recorder);
 #%!  sleep (2);
 #%!  stop (player);
-#%!  s = stat('record.txt');
+#%!  s = stat ("record.txt");
 #%!  assert (s.size > 0);
 
 #%!test
 #%!  recorder = audiorecorder (@callback_record, 44100);
-#%!  unlink('record.txt')
+#%!  unlink ("record.txt")
 #%!  record (recorder);
 #%!  sleep (2);
 #%!  stop (recorder);
-#%!  s = stat('record.txt');
+#%!  s = stat ("record.txt");
 #%!  assert (s.size > 0);
diff --git a/scripts/audio/@audiorecorder/display.m b/scripts/audio/@audiorecorder/display.m
--- a/scripts/audio/@audiorecorder/display.m
+++ b/scripts/audio/@audiorecorder/display.m
@@ -16,11 +16,11 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn{Function File} display (@var{recorderObj})
 ## Display an audiorecorder object.
 ## @end deftypefn
 
-function display(recorder)
-  disp(__get_properties__(recorder));
+function display (recorder)
+  disp (__get_properties__ (recorder));
 endfunction
diff --git a/scripts/audio/@audiorecorder/get.m b/scripts/audio/@audiorecorder/get.m
--- a/scripts/audio/@audiorecorder/get.m
+++ b/scripts/audio/@audiorecorder/get.m
@@ -19,32 +19,32 @@
 ## -*- texinfo -*-
 ## @deftypefn{Function File} @var{Value} = get (@var{recorderObj}, @var{Name})
 ## Returns the @var{Value} of the property identified by @var{Name}.
 ## @end deftypefn
 ## @deftypefn{Function File} @var{Values} = get (@var{recorderObj}, @{@var{Name1}, ... , @var{NameN}@})
 ## Returns the @var{Values} of the properties identified by @var{Name1} to @var{NameN}.
 ## @end deftypefn
 ## @deftypefn{Function File} @var{Values} = get (@var{recorderObj})
-## Returns a scalar structure with values of all properties of @var{recorderObj}. 
+## Returns a scalar structure with values of all properties of @var{recorderObj}.
 ## The field names correspond to property names.
 ## @end deftypefn
 
 function result = get (varargin)
   recorder = varargin{1};
   properties = __get_properties__ (recorder);
   if nargin == 1
     result = properties;
   elseif nargin == 2
     if ischar (varargin{2})
       result = getfield (properties, varargin{2});
     else
       result = {};
       index = 1;
       for property = varargin{2}
-        result{index} = getfield (properties, char(property));
+        result{index} = getfield (properties, char (property));
         index = index + 1;
       endfor
     endif
   else
-    error ('audiorecorder: wrong number of arguments to the get method');
+    error ("audiorecorder: wrong number of arguments to the get method");
   endif
 endfunction
diff --git a/scripts/audio/@audiorecorder/getaudiodata.m b/scripts/audio/@audiorecorder/getaudiodata.m
--- a/scripts/audio/@audiorecorder/getaudiodata.m
+++ b/scripts/audio/@audiorecorder/getaudiodata.m
@@ -20,33 +20,33 @@
 ## @deftypefn{Function File} getaudiodata (@var{recorderObj})
 ## Returns recorder audio data as a Matrix with values between -1.0 and 1.0 and with as many columns as there are channels in the recorder.
 ## @end deftypefn
 ## @deftypefn{Function File} getaudiodata (@var{recorderObj}, @var{dataType})
 ## Converts recorded data to specified @var{dataType}. It can be set to 'double',
 ## 'single', 'int16', 'int8' or 'uint8'.
 ## @end deftypefn
 
-function data = getaudiodata(varargin)
-    if (nargin < 1 || nargin > 2)
-      print_usage ();
-    endif
-    recorder = varargin{1};
-    if (nargin == 1)
-      data = __recorder_getaudiodata__(struct(recorder).recorder);
-    else
-      data = __recorder_getaudiodata__(struct(recorder).recorder);
-      type = varargin{2};
-      switch type
-        case 'int16'
-          data = int16(data * (2.0 ^ 15));
-        case 'int8'
-          data = int8(data * (2.0 ^ 7));
-        case 'uint8'
-          data = uint8((data + 1.0) * 0.5 * (2.0 ^ 8 - 1));
-      endswitch
-    endif
-    if get(recorder, 'NumberOfChannels') == 2
-      data = data';
-    else
-      data = data(1,:)';
-    endif
+function data = getaudiodata (varargin)
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+  endif
+  recorder = varargin{1};
+  if (nargin == 1)
+    data = __recorder_getaudiodata__ (struct (recorder).recorder);
+  else
+    data = __recorder_getaudiodata__ (struct (recorder).recorder);
+    type = varargin{2};
+    switch (type)
+      case "int16"
+        data = int16 (data * (2.0 ^ 15));
+      case "int8"
+        data = int8 (data * (2.0 ^ 7));
+      case "uint8"
+        data = uint8 ((data + 1.0) * 0.5 * (2.0 ^ 8 - 1));
+    endswitch
+  endif
+  if get (recorder, "NumberOfChannels") == 2
+    data = data';
+  else
+    data = data(1,:)';
+  endif
 endfunction
diff --git a/scripts/audio/@audiorecorder/getplayer.m b/scripts/audio/@audiorecorder/getplayer.m
--- a/scripts/audio/@audiorecorder/getplayer.m
+++ b/scripts/audio/@audiorecorder/getplayer.m
@@ -16,16 +16,16 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn{Function File} getplayer (@var{recorderObj})
 ## Returns an audioplayer object with data recorded by the recorder.
 ## @end deftypefn
 
-function player = getplayer(varargin)
+function player = getplayer (varargin)
   if (nargin < 1 || nargin > 2)
     print_usage ();
-  endif 
+  endif
   recorder = varargin{1};
-  data = getaudiodata(recorder);
-  player = audioplayer(data, get(recorder, 'SampleRate'), get(recorder, 'BitsPerSample'));
+  data = getaudiodata (recorder);
+  player = audioplayer (data, get (recorder, "SampleRate"), get (recorder, "BitsPerSample"));
 endfunction
diff --git a/scripts/audio/@audiorecorder/isrecording.m b/scripts/audio/@audiorecorder/isrecording.m
--- a/scripts/audio/@audiorecorder/isrecording.m
+++ b/scripts/audio/@audiorecorder/isrecording.m
@@ -17,11 +17,11 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn{Function File} isrecording (@var{recorderObj})
 ## Returns 1 if the audiorecorder object is currently recording audio.
 ## Returns 0 otherwise.
 ## @end deftypefn
 
-function result = isrecording(recorder)
-    result = __recorder_isrecording__(struct(recorder).recorder);
+function result = isrecording (recorder)
+  result = __recorder_isrecording__ (struct (recorder).recorder);
 endfunction
diff --git a/scripts/audio/@audiorecorder/pause.m b/scripts/audio/@audiorecorder/pause.m
--- a/scripts/audio/@audiorecorder/pause.m
+++ b/scripts/audio/@audiorecorder/pause.m
@@ -16,11 +16,11 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn{Function File} pause (@var{recorderObj})
 ## Pause recording with the possibility of resuming it later.
 ## @end deftypefn
 
-function pause(recorder)
-    __recorder_pause__(struct(recorder).recorder);
+function pause (recorder)
+  __recorder_pause__ (struct (recorder).recorder);
 endfunction
diff --git a/scripts/audio/@audiorecorder/play.m b/scripts/audio/@audiorecorder/play.m
--- a/scripts/audio/@audiorecorder/play.m
+++ b/scripts/audio/@audiorecorder/play.m
@@ -22,21 +22,21 @@
 ## @end deftypefn
 ## @deftypefn{Function File} player = play (@var{recorderObj}, start)
 ## Play the audio recorded in @var{recorderObj} starting from @var{start} seconds in to the recording. Returns a corresponding audioplayer object.
 ## @end deftypefn
 ## @deftypefn{Function File} player = play (@var{recorderObj}, [start, end])
 ## Play the audio recorded in @var{recorderObj} starting from @var{start} seconds and ending at @var{end} seconds in the recording. Returns a corresponding audioplayer object.
 ## @end deftypefn
 
-function player = play(varargin)
+function player = play (varargin)
   if (nargin < 1 || nargin > 2)
     print_usage ();
-  endif 
+  endif
   recorder = varargin{1};
-  data = getaudiodata(recorder);
-  player = audioplayer(data, get(recorder, 'SampleRate'), get(recorder, 'BitsPerSample'));
+  data = getaudiodata (recorder);
+  player = audioplayer (data, get (recorder, "SampleRate"), get (recorder, "BitsPerSample"));
   if (nargin == 1)
-    play(player);
+    play (player);
   else
-    play(player, varargin{2});
+    play (player, varargin{2});
   endif
 endfunction
diff --git a/scripts/audio/@audiorecorder/record.m b/scripts/audio/@audiorecorder/record.m
--- a/scripts/audio/@audiorecorder/record.m
+++ b/scripts/audio/@audiorecorder/record.m
@@ -19,14 +19,14 @@
 ## -*- texinfo -*-
 ## @deftypefn{Function File} record (@var{recorderObj})
 ## Record audio without blocking. The recording will continue until you use the stop method on @var{recorderObj}.
 ## @end deftypefn
 ## @deftypefn{Function File} record (@var{playerObj}, @var{length})
 ## Record audio without blocking. The recording will continue for @var{length} seconds.
 ## @end deftypefn
 
-function record(varargin)
+function record (varargin)
   if (nargin < 1 || nargin > 2)
     print_usage ();
-  endif 
-  __recorder_record__(struct(varargin{1}).recorder, varargin{2:end});
+  endif
+  __recorder_record__ (struct (varargin{1}).recorder, varargin{2:end});
 endfunction
diff --git a/scripts/audio/@audiorecorder/recordblocking.m b/scripts/audio/@audiorecorder/recordblocking.m
--- a/scripts/audio/@audiorecorder/recordblocking.m
+++ b/scripts/audio/@audiorecorder/recordblocking.m
@@ -17,14 +17,14 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn{Function File} recordblocking (@var{recorderObj}, @var{length})
 ## Record audio with blocking (synchronous I/O). You must specify the number of seconds
 ## that the recording will continue for.
 ## @end deftypefn
 
-function recordblocking(varargin)
+function recordblocking (varargin)
   if (nargin != 2)
     print_usage ();
-  endif 
-  __recorder_recordblocking__(struct(varargin{1}).recorder, varargin{2});
+  endif
+  __recorder_recordblocking__ (struct (varargin{1}).recorder, varargin{2});
 endfunction
diff --git a/scripts/audio/@audiorecorder/resume.m b/scripts/audio/@audiorecorder/resume.m
--- a/scripts/audio/@audiorecorder/resume.m
+++ b/scripts/audio/@audiorecorder/resume.m
@@ -16,11 +16,11 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn{Function File} resume (@var{recorderObj})
 ## Will resume recording if pause was used before on @var{recorderObj}.
 ## @end deftypefn
 
-function resume(recorder)
-    __recorder_resume__(struct(recorder).recorder);
+function resume (recorder)
+  __recorder_resume__ (struct (recorder).recorder);
 endfunction
diff --git a/scripts/audio/@audiorecorder/set.m b/scripts/audio/@audiorecorder/set.m
--- a/scripts/audio/@audiorecorder/set.m
+++ b/scripts/audio/@audiorecorder/set.m
@@ -27,46 +27,46 @@
 ## Given a structure where fields are property names, set the value of those properties for an audiorecorder object to corresponding values.
 ## @end deftypefn
 ## @deftypefn{Function File} @var{settableProperties} = set (@var{recorderObj})
 ## Returns a structure of settable properties.
 ## @end deftypefn
 
 function settable = set (varargin)
   if nargin < 1 || nargin > 3
-    print_usage();
+    print_usage ();
   endif
   recorder = struct (varargin{1}).recorder;
   if nargin == 1
     settable.SampleRate = {};
     settable.Tag = {};
     settable.UserData = {};
   elseif nargin == 2
     for [value, property] = varargin{2}
       setproperty (recorder, property, value);
     endfor
   elseif nargin == 3
     if iscell (varargin{2})
       index = 1;
       for property = varargin{2}
-        setproperty (recorder, char(property), varargin{3}{index});
+        setproperty (recorder, char (property), varargin{3}{index});
         index = index + 1;
       endfor
     else
       setproperty (recorder, varargin{2}, varargin{3});
     endif
   else
-    error ('audiorecorder: wrong number of arguments to the set method');
+    error ("audiorecorder: wrong number of arguments to the set method");
   endif
 endfunction
 
 function setproperty (recorder, property, value)
-  switch property
-    case 'SampleRate'
+  switch (property)
+    case "SampleRate"
       __recorder_set_fs__ (recorder, value);
-    case 'Tag'
+    case "Tag"
       __recorder_set_tag__ (recorder, value);
-    case 'UserData'
+    case "UserData"
       __recorder_set_userdata__ (recorder, value);
     otherwise
-      error ('audiorecorder: no such property or the property specified is read-only');
+      error ("audiorecorder: no such property or the property specified is read-only");
   endswitch
 endfunction
diff --git a/scripts/audio/@audiorecorder/stop.m b/scripts/audio/@audiorecorder/stop.m
--- a/scripts/audio/@audiorecorder/stop.m
+++ b/scripts/audio/@audiorecorder/stop.m
@@ -16,11 +16,11 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn{Function File} stop (@var{recorderObj})
 ## Will stop recording, clean up any audio streams.
 ## @end deftypefn
 
-function stop(recorder)
-    __recorder_stop__(struct(recorder).recorder);
+function stop (recorder)
+  __recorder_stop__ (struct (recorder).recorder);
 endfunction
diff --git a/scripts/audio/@audiorecorder/subsasgn.m b/scripts/audio/@audiorecorder/subsasgn.m
--- a/scripts/audio/@audiorecorder/subsasgn.m
+++ b/scripts/audio/@audiorecorder/subsasgn.m
@@ -11,20 +11,20 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-function value = subsasgn(recorder, idx, rhs)
+function value = subsasgn (recorder, idx, rhs)
   if (isempty (idx))
     error ("audiorecorder: missing index");
   endif
-  if (strcmp(idx(1).type, "."))
+  if (strcmp (idx(1).type, "."))
     field = idx.subs;
-    set(recorder, field, rhs);
+    set (recorder, field, rhs);
     value = recorder;
   else
     error ("audiorecorder: invalid subscript type");
   endif
 endfunction
diff --git a/scripts/audio/@audiorecorder/subsref.m b/scripts/audio/@audiorecorder/subsref.m
--- a/scripts/audio/@audiorecorder/subsref.m
+++ b/scripts/audio/@audiorecorder/subsref.m
@@ -11,19 +11,19 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-function value = subsref(recorder, idx)
+function value = subsref (recorder, idx)
   if (isempty (idx))
     error ("audiorecorder: missing index");
   endif
-  if (strcmp(idx(1).type, "."))
+  if (strcmp (idx(1).type, "."))
     field = idx.subs;
-    value = get(recorder, field);
+    value = get (recorder, field);
   else
     error ("audiorecorder: invalid subscript file")
   endif
 endfunction
