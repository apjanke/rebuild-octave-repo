# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1295565969 18000
#      Thu Jan 20 18:26:09 2011 -0500
# Node ID b0084095098e8b9570d2420527de37a0c9e15778
# Parent  d5bd2766c6404b1c6fb941a466e629254f529a9e
missing semicolons in script files

diff --git a/scripts/@ftp/loadobj.m b/scripts/@ftp/loadobj.m
--- a/scripts/@ftp/loadobj.m
+++ b/scripts/@ftp/loadobj.m
@@ -22,15 +22,15 @@ function b = loadobj (a)
     b = rmfield (b, "jobject");
   endif
   b.curlhandle = tmpnam ("ftp-");
   __ftp__ (b.curlhandle, b.host, b.username, b.password);
   if (isfield (b, "dir"))
     if (! isempty (b.dir))
       __ftp_cwd__ (b.curlhandle, b.dir);
     endif
-    b = rmfield (b, "dir")
+    b = rmfield (b, "dir");
   elseif (isfield (b, "remotePwd"))
     ## FIXME: Can we read matlab java stringBuffer objects?
     warning ("can not change remote directory in loqded FTP object");
     b = rmfield (b, "remotePwd");
   endif
 endfunction
diff --git a/scripts/@ftp/saveobj.m b/scripts/@ftp/saveobj.m
--- a/scripts/@ftp/saveobj.m
+++ b/scripts/@ftp/saveobj.m
@@ -13,11 +13,11 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 function b = saveobj (a)
   b = a;
-  b = rmfield (b, "curlhandle")
+  b = rmfield (b, "curlhandle");
   b.dir = __ftp_pwd (a.curlhandle);
 endfunction
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,39 @@
+2011-01-20  John W. Eaton  <jwe@octave.org>
+
+	* @ftp/loadobj.m, @ftp/saveobj.m, audio/record.m,
+	general/accumarray.m, general/accumdim.m, general/arrayfun.m,
+	general/bicubic.m, general/curl.m, general/divergence.m,
+	general/gradient.m, general/interp2.m, general/rat.m,
+	image/imagesc.m, io/strread.m, io/textscan.m,
+	linear-algebra/krylov.m, miscellaneous/getappdata.m,
+	miscellaneous/isappdata.m, miscellaneous/rmappdata.m,
+	miscellaneous/setappdata.m, miscellaneous/what.m,
+	optimization/qp.m, path/savepath.m, pkg/pkg.m,
+	plot/__fltk_print__.m, plot/__gnuplot_print__.m,
+	plot/__go_draw_axes__.m, plot/__print_parse_opts__.m,
+	plot/axis.m, plot/caxis.m, plot/cla.m, plot/clabel.m,
+	plot/clf.m, plot/colorbar.m, plot/cylinder.m, plot/daspect.m,
+	plot/gnuplot_drawnow.m, plot/meshc.m, plot/newplot.m,
+	plot/orient.m, plot/pbaspect.m, plot/plotyy.m, plot/print.m,
+	plot/private/__actual_axis_position__.m,
+	plot/private/__axis_label__.m, plot/private/__bar__.m,
+	plot/private/__clabel__.m, plot/private/__errplot__.m,
+	plot/private/__ezplot__.m, plot/private/__ghostscript__.m,
+	plot/private/__patch__.m, plot/private/__pie__.m,
+	plot/private/__quiver__.m, plot/private/__scatter__.m,
+	plot/private/__stem__.m, plot/private/__tight_eps_bbox__.m,
+	plot/refresh.m, plot/spinmap.m, plot/subplot.m, plot/surfc.m,
+	plot/uigetfile.m, polynomial/polyout.m, sparse/spaugment.m,
+	sparse/svds.m, sparse/treeplot.m, statistics/base/histc.m,
+	statistics/distributions/hygecdf.m,
+	statistics/distributions/hygeinv.m, statistics/tests/manova.m,
+	strings/deblank.m, testfun/runtests.m: Add missing semicolons.
+
 2011-01-20  John W. Eaton  <jwe@octave.org>
 
 	* deprecated/cellidx.m, deprecated/dmult.m,
 	deprecated/intwarning.m, deprecated/str2mat.m, general/curl.m,
 	general/divergence.m, general/gradient.m, geometry/griddata.m,
 	help/gen_doc_cache.m, io/dlmwrite.m, miscellaneous/getappdata.m,
 	miscellaneous/isappdata.m, miscellaneous/rmappdata.m,
 	miscellaneous/setappdata.m, miscellaneous/unpack.m,
diff --git a/scripts/audio/record.m b/scripts/audio/record.m
--- a/scripts/audio/record.m
+++ b/scripts/audio/record.m
@@ -39,17 +39,17 @@ function X = record (sec, sampling_rate)
 
   unwind_protect
 
     file = tmpnam ();
 
     input ("Please hit ENTER and speak afterwards!\n", 1);
 
     cmd = sprintf ("dd if=/dev/dsp of=\"%s\" bs=%d count=%d",
-                   file, sampling_rate, sec)
+                   file, sampling_rate, sec);
 
     system (cmd);
 
     num = fopen (file, "rb");
 
     [Y, c] = fread (num, sampling_rate * sec, "uchar");
 
     fclose (num);
diff --git a/scripts/general/accumarray.m b/scripts/general/accumarray.m
--- a/scripts/general/accumarray.m
+++ b/scripts/general/accumarray.m
@@ -134,31 +134,31 @@ function A = accumarray (subs, vals, sz 
     endif
 
     ## Form the sparse matrix.
     if (isempty (sz))
       A = sparse (subs(:,1), subs(:,2), vals, mode);
     elseif (length (sz) == 2)
       A = sparse (subs(:,1), subs(:,2), vals, sz(1), sz(2), mode);
     else
-      error ("accumarray: dimensions mismatch")
+      error ("accumarray: dimensions mismatch");
     endif
 
   else
 
     ## Linearize subscripts.
     if (ndims > 1)
       if (isempty (sz))
         if (iscell (subs))
           sz = cellfun (@max, subs);
         else
           sz = max (subs, [], 1);
         endif
       elseif (ndims != length (sz))
-        error ("accumarray: dimensions mismatch")
+        error ("accumarray: dimensions mismatch");
       endif
 
       ## Convert multidimensional subscripts.
       if (ismatrix (subs))
         subs = num2cell (subs, 1);
       endif
       subs = sub2ind (sz, subs{:}); # creates index cache
     elseif (! isempty (sz) && length (sz) < 2)
diff --git a/scripts/general/accumdim.m b/scripts/general/accumdim.m
--- a/scripts/general/accumdim.m
+++ b/scripts/general/accumdim.m
@@ -66,17 +66,17 @@ function A = accumdim (subs, vals, dim, 
     error ("accumdim: SUBS must be a subscript vector");
   elseif (! isindex (subs)) # creates index cache
     error ("accumdim: indices must be positive integers");
   else
     m = max (subs);
     if (n == 0)
       n = m;
     elseif (n < m)
-      error ("accumdim: N index out of range")
+      error ("accumdim: N index out of range");
     endif
   endif
 
   sz = size (vals);
 
   if (nargin < 3)
     [~, dim] = max (sz != 1); # first non-singleton dim
   elseif (! isindex (dim))
diff --git a/scripts/general/arrayfun.m b/scripts/general/arrayfun.m
--- a/scripts/general/arrayfun.m
+++ b/scripts/general/arrayfun.m
@@ -157,17 +157,17 @@ function varargout = arrayfun (func, var
   args = cellfun (@num2cell, args, "UniformOutput", false,
   "ErrorHandler",  @arg_class_error);
 
   [varargout{1:max(1, nargout)}] = cellfun (func, args{:}, opts{:});
 
 endfunction
 
 function arg_class_error (S, X)
-  error ("arrayfun: invalid argument of class %s", class (X))
+  error ("arrayfun: invalid argument of class %s", class (X));
 endfunction
 
 %% Test function to check the "Errorhandler" option
 %!function [z] = arrayfunerror (S, varargin)
 %!      z = S;
 %!    endfunction
 %% First input argument can be a string, an inline function, a
 %% function_handle or an anonymous function
diff --git a/scripts/general/bicubic.m b/scripts/general/bicubic.m
--- a/scripts/general/bicubic.m
+++ b/scripts/general/bicubic.m
@@ -34,17 +34,17 @@
 
 function zi = bicubic (x, y, z, xi, yi, extrapval, spline_alpha)
 
   if (nargin < 1 || nargin > 7)
     print_usage ();
   endif
 
   if (nargin == 7 && isscalar(spline_alpha))
-    a = spline_alpha
+    a = spline_alpha;
   else
     a = 0.5;
   endif
 
   if (nargin < 6)
     extrapval = NaN;
   endif
 
diff --git a/scripts/general/curl.m b/scripts/general/curl.m
--- a/scripts/general/curl.m
+++ b/scripts/general/curl.m
@@ -91,22 +91,22 @@ function varargout = curl (varargin)
     if (nargout == 0)
       av
     elseif (nargout == 1)
       varargout{1} = av;
     elseif (nargout == 2)
       varargout{1} = rot_z;
       varargout{2} = av;
     else
-      error ("curl: number of output arguments must be 1 or 2")
+      error ("curl: number of output arguments must be 1 or 2");
     endif
 
   elseif ((nargin == 6) || (nargin == 3))
     if (!size_equal (varargin{fidx}, varargin{fidx + 1}, varargin{fidx + 2}))
-      error ("curl: size of X, Y, and Z must match")
+      error ("curl: size of X, Y, and Z must match");
     elseif (ndims (varargin{fidx}) != 3)
       error ("curl: expected two-dimensional matrices X, Y, and Z");
     elseif ((length (dx) != size (varargin{fidx}, 2))
          || (length (dy) != size (varargin{fidx}, 1))
          || (length (dz) != size (varargin{fidx}, 3)))
       error ("curl: size of dx, dy, and dz must match the respective dimesion of X, Y, and Z");
     endif
 
diff --git a/scripts/general/divergence.m b/scripts/general/divergence.m
--- a/scripts/general/divergence.m
+++ b/scripts/general/divergence.m
@@ -81,17 +81,17 @@ function retval = divergence (varargin)
       error ("divergence: size of dx and dy must match the respective dimension of X and Y");
     endif
 
     retval = gradient(varargin{fidx}, dx, dy);
     retval += gradient(varargin{fidx + 1}.', dy, dx).';
 
   elseif ((nargin == 6) || (nargin == 3))
     if (!size_equal (varargin{fidx},varargin{fidx + 1},varargin{fidx + 2}))
-      error ("divergence: size of X, Y, and Z must match")
+      error ("divergence: size of X, Y, and Z must match");
     elseif (ndims (varargin{fidx}) != 3)
       error ("divergence: expected two-dimensional matrices X, Y, and Z");
     elseif ((length (dx) != size (varargin{fidx}, 2))
          || (length (dy) != size (varargin{fidx}, 1))
          || (length (dz) != size (varargin{fidx}, 3)))
       error ("divergence: size of dx, dy, and dz must match the respective dimesion of X, Y, and Z");
     endif
 
diff --git a/scripts/general/gradient.m b/scripts/general/gradient.m
--- a/scripts/general/gradient.m
+++ b/scripts/general/gradient.m
@@ -62,17 +62,17 @@
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 ## Modified: David Bateman <dbateman@free.fr> Added NDArray support
 
 function varargout = gradient (m, varargin)
 
   if (nargin < 1)
-    print_usage ()
+    print_usage ();
   endif
 
   nargout_with_ans = max(1,nargout);
   if (ismatrix (m))
     [varargout{1:nargout_with_ans}] = matrix_gradient (m, varargin{:});
   elseif (isa (m, "function_handle"))
     [varargout{1:nargout_with_ans}] = handle_gradient (m, varargin{:});
   elseif (ischar(m))
@@ -93,17 +93,17 @@ function varargout = matrix_gradient (m,
 
   nd = ndims (m);
   sz = size (m);
   if (length(sz) > 1)
     tmp = sz(1); sz(1) = sz(2); sz(2) = tmp;
   endif
 
   if (nargin > 2 && nargin != nd + 1)
-    print_usage ()
+    print_usage ();
   endif
 
   ## cell d stores a spacing vector for each dimension
   d = cell (1, nd);
   if (nargin == 1)
     ## no spacing given - assume 1.0 for all dimensions
     for i = 1:nd
       d{i} = ones (sz(i) - 1, 1);
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -224,31 +224,31 @@ function ZI = interp2 (varargin)
 
       ## scale XI, YI values to a 1-spaced grid
       Xsc = (XI - X(xidx)) ./ (diff (X)(xidx));
       Ysc = (YI - Y(yidx)) ./ (diff (Y)(yidx));
 
       ## Get 2D index.
       idx = sub2ind (size (a), yidx, xidx);
       ## We can dispose of the 1D indices at this point to save memory.
-      clear xidx yidx
+      clear xidx yidx;
 
       ## apply plane equation
       ZI = a(idx) + b(idx).*Xsc + c(idx).*Ysc + d(idx).*Xsc.*Ysc;
 
     elseif (strcmp (method, "nearest"))
       ii = (XI - X(xidx) >= X(xidx + 1) - XI);
       jj = (YI - Y(yidx) >= Y(yidx + 1) - YI);
       idx = sub2ind (size (Z), yidx+jj, xidx+ii);
       ZI = Z(idx);
 
     elseif (strcmp (method, "pchip"))
 
       if (length (X) < 2 || length (Y) < 2)
-        error ("interp2: pchip2 requires at least 2 points in each dimension")
+        error ("interp2: pchip2 requires at least 2 points in each dimension");
       endif
 
       ## first order derivatives
       DX = __pchip_deriv__ (X, Z, 2);
       DY = __pchip_deriv__ (Y, Z, 1);
       ## Compute mixed derivatives row-wise and column-wise, use the average.
       DXY = (__pchip_deriv__ (X, DY, 2) + __pchip_deriv__ (Y, DX, 1))/2;
 
diff --git a/scripts/general/rat.m b/scripts/general/rat.m
--- a/scripts/general/rat.m
+++ b/scripts/general/rat.m
@@ -136,17 +136,17 @@ function [n,d] = rat(x,tol)
         else
           s = [s(1:end-1), " + 1/(", int2str(step), ")"];
         endif
       endwhile
       s = [s, repmat(")", 1, j-2)];
       n_nc = columns (n);
       s_nc = columns (s);
       if (n_nc > s_nc)
-        s(:,s_nc+1:n_nc) = " "
+        s(:,s_nc+1:n_nc) = " ";
       elseif (s_nc > n_nc)
         n(:,n_nc+1:s_nc) = " ";
       endif
       n = cat (1, n, s);
     endfor
   endif
 
 endfunction
diff --git a/scripts/image/imagesc.m b/scripts/image/imagesc.m
--- a/scripts/image/imagesc.m
+++ b/scripts/image/imagesc.m
@@ -103,17 +103,17 @@ function ret = __imagesc__ (ax, x, y, A,
     A = x;
     limits = y;
     x = y = [];
   elseif (nargin == 4 && ! isscalar (x) && ! isscalar (y) && ! isscalar (A))
     limits = [];
   endif
 
   ret = image (ax, x, y, A);
-  set (ret, "cdatamapping", "scaled")
+  set (ret, "cdatamapping", "scaled");
 
   ## use given limits or guess them from the matrix
   if (length (limits) == 2 && limits(2) >= limits(1))
     set (ax, "clim", limits);
   elseif (! isempty (limits))
     error ("imagesc: expected data LIMITS to be [lo, hi]");
   endif
 
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -227,17 +227,17 @@ function varargout = strread (str, forma
         varargout {k} = data.';
         k++;
       case {"%*", "%*s"}
         ## skip the word
       otherwise
         ## Ensure descriptive content is consistent
         if (numel (unique (data)) > 1
             || ! strcmpi (unique (data), fmt_words{m}))
-          error ("strread: FORMAT does not match data")
+          error ("strread: FORMAT does not match data");
         endif
     endswitch
   endfor
 endfunction
 
 function out = split_by (text, sep)
   sep = union (sep, "\n");
   pat = sprintf ("[^%s]+", sep);
diff --git a/scripts/io/textscan.m b/scripts/io/textscan.m
--- a/scripts/io/textscan.m
+++ b/scripts/io/textscan.m
@@ -72,17 +72,17 @@ function [C, p] = textscan (fid, format,
     args{end+1} = "emptyvalue";
     args{end+1} = NaN;
   endif
 
   if (isa (fid, "double") && fid > 0 || ischar (fid))
     if (ischar (format))
       if (ischar (fid))
         if (nargout == 2)
-          error ("textscan: cannot provide position information for character input")
+          error ("textscan: cannot provide position information for character input");
         endif
         str = fid;
       else
         ## Maybe skip header lines
         headerlines = find (strcmpi (args, "headerlines"), 1);
         if (! isempty (headerlines))
           fskipl (fid, headerlines);
           args(headerlines:headerlines+1) = [];
diff --git a/scripts/linear-algebra/krylov.m b/scripts/linear-algebra/krylov.m
--- a/scripts/linear-algebra/krylov.m
+++ b/scripts/linear-algebra/krylov.m
@@ -54,17 +54,17 @@
 ## Conference on Decision and Control, December 2003.
 ## @end deftypefn
 
 ## Author: A. Scottedward Hodel <a.s.hodel@eng.auburn.edu>
 
 function [Uret, H, nu] = krylov (A, V, k, eps1, pflg);
 
   if (isa (A, "single") || isa (V, "single"))
-    defeps = 1e-6
+    defeps = 1e-6;
   else
     defeps = 1e-12;
   endif
 
   if (nargin < 3 || nargin > 5)
     print_usage ();
   elseif (nargin < 5)
     ## Default permutation flag.
@@ -83,17 +83,17 @@ function [Uret, H, nu] = krylov (A, V, k
   if (! issquare (A) || isempty (A))
     error ("krylov: A(%d x %d) must be a non-empty square matrix", rows (A), columns (A));
   endif
   na = rows (A);
 
   [m, kb] = size (V);
   if (m != na)
     error ("krylov: A(%d x %d), V(%d x %d): argument dimensions do not match",
-          na, na, m, kb)
+          na, na, m, kb);
   endif
 
   if (! isscalar (k))
     error ("krylov: K must be a scalar integer");
   endif
 
   Vnrm = norm (V, Inf);
 
@@ -176,19 +176,19 @@ function [Uret, H, nu] = krylov (A, V, k
       endif
     endwhile
 
     ## Check for oversize V (due to full rank).
     if ((columns (V) > na) && (length (alpha) == na))
       ## Trim to size.
       V = V(:,1:na);
     elseif (columns(V) > na)
-      krylov_V = V
-      krylov_na = na
-      krylov_length_alpha = length (alpha)
+      krylov_V = V;
+      krylov_na = na;
+      krylov_length_alpha = length (alpha);
       error ("krylov: this case should never happen; submit a bug report");
     endif
 
     if (columns (V) > 0)
       ## Construct next Q and multiply.
       Q = zeros (size (V));
       for kk = 1:columns (Q)
         Q(pivot_vec(nu-columns(Q)+kk),kk) = 1;
diff --git a/scripts/miscellaneous/getappdata.m b/scripts/miscellaneous/getappdata.m
--- a/scripts/miscellaneous/getappdata.m
+++ b/scripts/miscellaneous/getappdata.m
@@ -21,17 +21,17 @@
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2010-07-15
 
 function val = getappdata (h, name)
 
   if (! (all (ishandle (h)) && ischar (name)))
-    error ("getappdata: invalid input")
+    error ("getappdata: invalid input");
   endif
 
   appdata(numel(h)) = struct();
   for nh = 1:numel(h)
     appdata(nh) = get (h(nh), "__appdata__");
   end
   if (nh > 1)
     val = {appdata.(name)};
diff --git a/scripts/miscellaneous/isappdata.m b/scripts/miscellaneous/isappdata.m
--- a/scripts/miscellaneous/isappdata.m
+++ b/scripts/miscellaneous/isappdata.m
@@ -22,17 +22,17 @@
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2010-07-15
 
 function res = isappdata (h, name)
 
   if (! (all (ishandle (h)) && ischar (name)))
-    error ("isappdata: invalid input")
+    error ("isappdata: invalid input");
   endif
 
   for nh = 1:numel(h)
     data = get (h(nh));
     if (isfield (data, "__appdata__") && isfield (data.__appdata__, name))
       res(nh) = true;
     else
       res(nh) = false;
diff --git a/scripts/miscellaneous/rmappdata.m b/scripts/miscellaneous/rmappdata.m
--- a/scripts/miscellaneous/rmappdata.m
+++ b/scripts/miscellaneous/rmappdata.m
@@ -21,17 +21,17 @@
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2010-07-15
 
 function rmappdata (h, varargin)
 
   if (! (all (ishandle (h)) && iscellstr (varargin)))
-    error ("rmappdata: invalid input")
+    error ("rmappdata: invalid input");
   endif
 
   for nh = 1:numel(h)
     appdata = get (h(nh), "__appdata__");
     appdata = rmfield (appdata, varargin);
     set (h(nh), "__appdata__", appdata);
   endfor
 
diff --git a/scripts/miscellaneous/setappdata.m b/scripts/miscellaneous/setappdata.m
--- a/scripts/miscellaneous/setappdata.m
+++ b/scripts/miscellaneous/setappdata.m
@@ -22,34 +22,34 @@
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2010-07-15
 
 function setappdata (h, varargin)
 
   if (! (all (ishandle (h)) && mod (numel (varargin), 2) == 0))
-    error ("setappdata: invalid input")
+    error ("setappdata: invalid input");
   endif
 
   for nh = 1:numel(h)
     if (! isfield (get (h(nh)), "__appdata__"))
       addproperty ("__appdata__", h(nh), "any", struct ());
     end
     appdata = get (h(nh), "__appdata__");
     for narg = 1:2:numel(varargin)
       if (iscellstr (varargin{narg}))
         ## Handle cell arrays like set() does.
         set (h(nh), "__appdata__", appdata);
         setappdata (h(nh), vertcat (varargin{narg}', varargin{narg+1}'){:});
         appdata = get (h(nh), "__appdata__");
       elseif (ischar (varargin{narg}))
         appdata.(varargin{narg}) = varargin{narg+1};
       else
-        error ("setappdata: invalid input")
+        error ("setappdata: invalid input");
       endif
     endfor
     set (h(nh), "__appdata__", appdata);
   endfor
 
 endfunction
 
 %!test
diff --git a/scripts/miscellaneous/what.m b/scripts/miscellaneous/what.m
--- a/scripts/miscellaneous/what.m
+++ b/scripts/miscellaneous/what.m
@@ -84,17 +84,17 @@ function ret = what (d)
     __display_filenames__ ("\nClasses in directory", w.path, w.classes);
   else
     ret = w;
   endif
 endfunction
 
 function __display_filenames__ (msg, p, f)
   if (length (f) > 0)
-    printf ("%s %s:\n\n", msg, p)
+    printf ("%s %s:\n\n", msg, p);
 
     maxlen = max (cellfun (@length, f));
     ncols = max (1, floor (terminal_size()(2) / (maxlen + 3)));
     fmt = "";
     for i = 1: ncols
       fmt = sprintf ("%s   %%-%ds", fmt, maxlen);
     endfor
     fmt = [fmt, "\n"];
diff --git a/scripts/optimization/qp.m b/scripts/optimization/qp.m
--- a/scripts/optimization/qp.m
+++ b/scripts/optimization/qp.m
@@ -316,17 +316,17 @@ function [x, obj, INFO, lambda] = qp (x0
 
     info = 0;
     if (eq_infeasible || in_infeasible)
       ## The initial guess is not feasible.
       ## First define xbar that is feasible with respect to the equality
       ## constraints.
       if (eq_infeasible)
         if (rank (A) < n_eq)
-          error ("qp: equality constraint matrix must be full row rank")
+          error ("qp: equality constraint matrix must be full row rank");
         endif
         xbar = pinv (A) * b;
       else
         xbar = x0;
       endif
 
       ## Check if xbar is feasible with respect to the inequality
       ## constraints also.
diff --git a/scripts/path/savepath.m b/scripts/path/savepath.m
--- a/scripts/path/savepath.m
+++ b/scripts/path/savepath.m
@@ -103,17 +103,17 @@ function varargout = savepath (file)
 
   ## write the results
   [fid, msg] = fopen (file, "wt");
   if (fid < 0)
     error ("savepath: unable to open file for writing, %s, %s", file, msg);
   endif
   unwind_protect
     for i = 1:length (pre)
-      fprintf (fid, "%s\n", pre{i})
+      fprintf (fid, "%s\n", pre{i});
     endfor
 
     ## Remove the portion of the path defined via the command line
     ## and/or the environment.
     workingpath = parsepath (path);
     command_line_path = parsepath (command_line_path ());
     octave_path = parsepath (getenv ("OCTAVE_PATH"));
     if (isempty (pathdef ()))
@@ -169,28 +169,28 @@ function varargout = savepath (file)
       path_to_save_end   = {};
     endif
     path_to_save_begin = cell2mat (path_to_save_begin);
     path_to_save_end   = cell2mat (path_to_save_end);
 
     ## Use single quotes for PATH argument to avoid string escape
     ## processing.  Since we are using single quotes around the arg,
     ## double any single quote characters found in the string.
-    fprintf (fid, "%s\n", beginstring)
+    fprintf (fid, "%s\n", beginstring);
     if (! isempty (path_to_save_begin))
       n = find (path_to_save_begin != pathsep, 1, "last");
       fprintf (fid, "  addpath ('%s', '-begin');\n",
-               strrep (path_to_save_begin(1:n), "'", "''"))
+               strrep (path_to_save_begin(1:n), "'", "''"));
     endif
     if (! isempty (path_to_save_end))
       n = find (path_to_save_end != pathsep, 1, "last");
       fprintf (fid, "  addpath ('%s', '-end');\n",
-               strrep (path_to_save_end(1:n), "'", "''"))
+               strrep (path_to_save_end(1:n), "'", "''"));
     endif
-    fprintf (fid, "%s\n", endstring)
+    fprintf (fid, "%s\n", endstring);
 
     for i = 1:length (post)
       fprintf (fid, "%s\n", post{i});
     endfor
   unwind_protect_cleanup
     closeread = fclose (fid);
     if (closeread < 0)
       error ("savepath: could not close savefile after writing, %s", file);
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -664,17 +664,17 @@ function install (files, handle_deps, au
 
         ## Get the name of the directories produced by tar.
         [dirlist, err, msg] = readdir (tmpdir);
         if (err)
           error ("couldn't read directory produced by tar: %s", msg);
         endif
 
         if (length (dirlist) > 3)
-          error ("bundles of packages are not allowed")
+          error ("bundles of packages are not allowed");
         endif
       endif
 
       ## The filename pointed to an uncompressed package to begin with.
       if (exist (tgz, "dir"))
         dirlist = {".", "..", tgz};
       endif
 
@@ -2238,17 +2238,17 @@ function [status, output] = shell (cmd)
         have_sh = false;
       else
         have_sh = true;
       endif
     endif
     if (have_sh)
       [status, output] = system (cstrcat ("sh.exe -c \"", cmd, "\""));
     else
-      error ("Can not find the command shell")
+      error ("Can not find the command shell");
     endif
   else
     [status, output] = system (cmd);
   endif
 endfunction
 
 function newdesc = save_order (desc)
   newdesc = {};
diff --git a/scripts/plot/__fltk_print__.m b/scripts/plot/__fltk_print__.m
--- a/scripts/plot/__fltk_print__.m
+++ b/scripts/plot/__fltk_print__.m
@@ -20,18 +20,18 @@
 ## @deftypefn {Function File} {} __fltk_print__ (@var{@dots{}})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function opts = __fltk_print__ (opts)
 
   dos_shell = (ispc () && ! isunix ());
 
-  figure (opts.figure)
-  drawnow ("expose")
+  figure (opts.figure);
+  drawnow ("expose");
   __fltk_redraw__ ();
 
   if (! isempty (opts.fig2dev_binary))
     ## fig2dev is prefered for conversion to emf
     fig2dev_devices = {"pstex", "mf", "emf"};
   else
     fig2dev_devices = {"pstex", "mf"};
   endif
@@ -106,17 +106,17 @@ function opts = __fltk_print__ (opts)
     pipeline = {sprintf("%s > %s", cmd, opts.name)};
   case {"dxf", "emf", "fig", "hpgl"}
     cmd = opts.pstoedit_cmd (opts);
     gl2ps_device = {"eps"};
     pipeline = {sprintf("%s > %s", cmd, opts.name)};
   case {"corel", "gif"}
     error ("print:unsupporteddevice",
            "print.m: %s output is not available for the FLTK graphics toolkit",
-           upper (opts.devopt))
+           upper (opts.devopt));
   case opts.ghostscript.device
     opts.ghostscript.source = "-";
     opts.ghostscript.output = opts.name;
     if (opts.send_to_printer)
       opts.unlink(strcmp (opts.unlink, opts.ghostscript.output)) = [];
       opts.ghostscript.output = "-";
     endif
     [cmd_gs, cmd_cleanup] = __ghostscript__ (opts.ghostscript);
@@ -135,24 +135,24 @@ function opts = __fltk_print__ (opts)
       endif
     else
       gl2ps_device = {"eps"};
       pipeline = {cmd};
     endif
   otherwise
     error (sprintf ("print:no%soutput", opts.devopt),
            "print.m: %s output is not available for GL2PS output",
-           upper (opts.devopt))
+           upper (opts.devopt));
   endswitch
 
   opts.pipeline = pipeline;
 
   for n = 1:numel(pipeline)
     if (opts.debug)
-      fprintf ("fltk-pipeline: '%s'\n", pipeline{n})
+      fprintf ("fltk-pipeline: '%s'\n", pipeline{n});
     endif
     pid = popen (pipeline{n}, "w");
     if (pid < 0)
       error ("print:popenfailed", "print.m: failed to open pipe");
     endif
     unwind_protect
       drawnow (gl2ps_device{n} , sprintf ("%d" , pid));
       waitpid (pid);
diff --git a/scripts/plot/__gnuplot_print__.m b/scripts/plot/__gnuplot_print__.m
--- a/scripts/plot/__gnuplot_print__.m
+++ b/scripts/plot/__gnuplot_print__.m
@@ -82,39 +82,39 @@ function opts = __gnuplot_print__ (opts)
     endif
     if (__gnuplot_has_feature__ ("epslatex_implies_eps_filesuffix"))
       suffix = "tex";
     else
       %% Gnuplot 4.0 wants a ".eps" suffix.
       suffix = "eps";
     endif
     local_drawnow (sprintf ("%s %s", term, gp_opts),
-                   strcat (name, ".", suffix), opts)
+                   strcat (name, ".", suffix), opts);
   case "tikz"
     if (__gnuplot_has_terminal__ ("tikz"))
       local_drawnow (sprintf ("lua tikz %s", gp_opts), opts.name, opts);
     else
       error (sprintf ("print:no%soutput", opts.devopt),
              "print.m: '%s' output is not available for gnuplot-%s",
-             upper (opts.devopt), __gnuplot_version__ ())
+             upper (opts.devopt), __gnuplot_version__ ());
     endif
   case "svg"
     local_drawnow (sprintf ("svg dynamic %s", gp_opts), opts.name, opts);
   case {"aifm", "corel", "eepic", "emf", "fig"}
     local_drawnow (sprintf ("%s %s", opts.devopt, gp_opts), opts.name, opts);
   case {"pdfcairo", "pngcairo"}
     if (__gnuplot_has_terminal__ (opts.devopt))
       local_drawnow (sprintf ("%s %s", opts.devopt, gp_opts), opts.name, opts);
     else
       error (sprintf ("print:no%soutput", opts.devopt),
              "print.m: '%s' output is not available for gnuplot-%s",
-             upper (opts.devopt), __gnuplot_version__ ())
+             upper (opts.devopt), __gnuplot_version__ ());
     endif
   case {"canvas", "dxf", "hpgl", "mf", "gif", "pstricks", "texdraw"}
-    local_drawnow (sprintf ("%s %s", opts.devopt, gp_opts), opts.name, opts)
+    local_drawnow (sprintf ("%s %s", opts.devopt, gp_opts), opts.name, opts);
   case opts.ghostscript.device
     gp_opts = font_spec (opts, "devopt", "eps");
     opts.ghostscript.output = opts.name;
     opts.ghostscript.source = strcat (tmpnam (), ".eps");
     eps_drawnow (opts, opts.ghostscript.source, gp_opts);
     [cmd_gs, cmd_cleanup] = __ghostscript__ (opts.ghostscript);
     if (opts.send_to_printer || isempty (opts.name))
       cmd_lpr = opts.lpr_cmd (opts);
@@ -134,33 +134,33 @@ function opts = __gnuplot_print__ (opts)
         pipeline = {sprintf("%s ; %s", cmd, cmd_cleanup)};
       endif
     else
       pipeline = {cmd};
     endif
   otherwise
     error (sprintf ("print:no%soutput", opts.devopt),
            "print.m: %s output is not available for the Gnuplot graphics toolkit",
-           upper (opts.devopt))
+           upper (opts.devopt));
   endswitch
 
 
   opts.pipeline = pipeline;
 
   for n = 1:numel(pipeline)
     if (opts.debug)
-      fprintf ("gnuplot-pipeline: '%s'\n", pipeline{n})
+      fprintf ("gnuplot-pipeline: '%s'\n", pipeline{n});
     endif
     [status, output] = system (pipeline{n});
     if (status)
       fprintf ("%s\n%s\n%s\n",
                "---------- output begin ----------",
                output,
                "----------- output end -----------");
-      error ("gnuplot:failedpipe", "print: failed to print")
+      error ("gnuplot:failedpipe", "print: failed to print");
     endif
   endfor
 
 endfunction
 
 function eps_drawnow (opts, epsfile, gp_opts)
   [h, fontsize] = get_figure_text_objs (opts);
   unwind_protect
@@ -176,17 +176,17 @@ function eps_drawnow (opts, epsfile, gp_
 endfunction
 
 function local_drawnow (term, file, opts)
   if (opts.use_color < 0)
     mono = true;
   else
     mono = false;
   endif
-  figure (opts.figure)
+  figure (opts.figure);
   if (isempty (opts.debug_file) || ! opts.debug)
     drawnow (term, file, mono);
   else
     drawnow (term, file, mono, opts.debug_file);
   endif
 endfunction
 
 function f = font_spec (opts, varargin)
diff --git a/scripts/plot/__go_draw_axes__.m b/scripts/plot/__go_draw_axes__.m
--- a/scripts/plot/__go_draw_axes__.m
+++ b/scripts/plot/__go_draw_axes__.m
@@ -112,21 +112,21 @@ function __go_draw_axes__ (h, plot_strea
         if (strcmpi (axis_obj.dataaspectratiomode, "manual"))
           sz_str = sprintf ("set size ratio %.15g", -dr);
         else
           sz_str = "set size noratio";
         endif
         sz_str = sprintf ("%s %.15g, %.15g;\n", sz_str, pos(3), pos(4));
       endif
     else ## activepositionproperty == outerposition
-      fprintf (plot_stream, "unset tmargin;\n")
-      fprintf (plot_stream, "unset bmargin;\n")
-      fprintf (plot_stream, "unset lmargin;\n")
-      fprintf (plot_stream, "unset rmargin;\n")
-      fprintf (plot_stream, "set origin %g, %g;\n", pos(1:2))
+      fprintf (plot_stream, "unset tmargin;\n");
+      fprintf (plot_stream, "unset bmargin;\n");
+      fprintf (plot_stream, "unset lmargin;\n");
+      fprintf (plot_stream, "unset rmargin;\n");
+      fprintf (plot_stream, "set origin %g, %g;\n", pos(1:2));
       sz_str = "";
       if (strcmpi (axis_obj.dataaspectratiomode, "manual"))
         sz_str = sprintf ("ratio %g", -dr);
       else
         sz_str = "noratio";
       endif
       sz_str = sprintf ("set size %s %g, %g;\n", sz_str, pos(3:4));
     endif
@@ -391,20 +391,20 @@ function __go_draw_axes__ (h, plot_strea
     ximg_data_idx = 0;
 
     while (! isempty (kids))
 
       obj = get (kids(end));
       if (isfield (obj, "units"))
         units = obj.units;
         unwind_protect
-          set (kids(end), "units", "data")
+          set (kids(end), "units", "data");
           obj = get (kids(end));
         unwind_protect_cleanup
-          set (kids(end), "units", units)
+          set (kids(end), "units", units);
         end_unwind_protect
       endif
       kids = kids(1:(end-1));
 
       if (strcmpi (obj.visible, "off"))
         continue;
       endif
 
diff --git a/scripts/plot/__print_parse_opts__.m b/scripts/plot/__print_parse_opts__.m
--- a/scripts/plot/__print_parse_opts__.m
+++ b/scripts/plot/__print_parse_opts__.m
@@ -118,17 +118,17 @@ function arg_st = __print_parse_opts__ (
       elseif (strncmp (arg, "-FIG2DEV:", 9))
         arg_st.fig2dev_binary = arg{10:end};
       elseif (strncmp (arg, "-PSTOEDIT:", 9))
         arg_st.pstoedit_binary = arg{10:end};
       elseif ((length (arg) > 2) && arg(1:2) == "-G")
         arg_st.ghostscript.binary = file_in_path (getenv ("PATH"), arg(3:end));
         if (isempty (arg_st.ghostscript.binary))
           error ("print: Ghostscript binary ""%s"" could not be located",
-                 arg(3:end))
+                 arg(3:end));
         else
           arg_st.ghostscript_binary = __quote_path__ (arg_st.ghostscript_binary);
         endif
       elseif (length (arg) > 2 && arg(1:2) == "-F")
         idx = rindex (arg, ":");
         if (idx)
           arg_st.font = arg(3:idx-1);
           arg_st.fontsize = str2num (arg(idx+1:end));
@@ -256,21 +256,21 @@ function arg_st = __print_parse_opts__ (
       if (have_ghostscript)
         file_exists = ((numel (dir (arg_st.name)) == 1)
                        && (! isdir (arg_st.name)));
         if (! file_exists)
           arg_st.append_to_file = false;
         endif
       else
         arg_st.append_to_file = false;
-        warning ("print.m: appended output requires ghostscript to be installed")
+        warning ("print.m: appended output requires ghostscript to be installed");
       endif
     else
       warning ("print.m: appended output is not supported for device '%s'",
-               arg_st.devopt)
+               arg_st.devopt);
       arg_st.append_to_file = false;
     endif
   endif
 
   if (! isempty (arg_st.printer) || isempty (arg_st.name))
     arg_st.send_to_printer = true;
   endif
 
@@ -339,26 +339,26 @@ function arg_st = __print_parse_opts__ (
     arg_st.ghostscript.resolution = [];
   else
     arg_st.ghostscript.papersize = "";
     arg_st.ghostscript.pageoffset = [0, 0];
   endif
 
   if (warn_on_missing_binary)
     if (isempty (arg_st.ghostscript.binary))
-      warning ("print:missinggs", "print.m: Ghostscript binary is not available")
+      warning ("print:missinggs", "print.m: Ghostscript binary is not available");
     endif
     if (isempty (arg_st.epstool_binary))
-      warning ("print:missinggs", "print.m: epstool binary is not available")
+      warning ("print:missinggs", "print.m: epstool binary is not available");
     endif
     if (isempty (arg_st.fig2dev_binary))
-      warning ("print:missinggs", "print.m: fig2dev binary is not available")
+      warning ("print:missinggs", "print.m: fig2dev binary is not available");
     endif
     if (isempty (arg_st.pstoedit_binary))
-      warning ("print:missinggs", "print.m: pstoedit binary is not available")
+      warning ("print:missinggs", "print.m: pstoedit binary is not available");
     endif
     warn_on_missing_binary = false;
   endif
 
 endfunction
 
 %!test
 %! opts = __print_parse_opts__ ();
@@ -431,17 +431,17 @@ function gs = __ghostscript_binary__ ()
 
   if (isempty (ghostscript_binary))
     GSC = getenv ("GSC");
     if (exist (GSC, "file")
         || (! isempty (GSC) && file_in_path (getenv ("PATH"), GSC)))
       gs_binaries = {GSC};
     elseif (! isempty (GSC) && warn_on_bad_gsc)
       warning ("print:badgscenv",
-               "print.m: GSC environment variable not set properly")
+               "print.m: GSC environment variable not set properly");
       warn_on_bad_gsc = false;
       gs_binaries = {};
     else
       gs_binaries = {};
     endif
     if (isunix ())
       ## Unix - Includes Mac OSX and Cygwin.
       gs_binaries = horzcat (gs_binaries, {"gs", "gs.exe"});
@@ -451,17 +451,17 @@ function gs = __ghostscript_binary__ ()
     endif
     n = 0;
     while (n < numel (gs_binaries) && isempty (ghostscript_binary))
       n = n + 1;
       ghostscript_binary = file_in_path (getenv ("PATH"), gs_binaries{n});
     endwhile
     if (warn_on_no_ghostscript && isempty (ghostscript_binary))
       warning ("print:noghostscript",
-               "print.m: ghostscript not found in PATH")
+               "print.m: ghostscript not found in PATH");
       warn_on_no_ghostscript = false;
     endif
   endif
 
   gs = ghostscript_binary;
 
 endfunction
 
@@ -485,17 +485,17 @@ function bin = __find_binary__ (binary)
     endif
     n = 0;
     while (n < numel (binaries) && isempty (data.(binary).bin))
       n = n + 1;
       data.(binary).bin = file_in_path (getenv ("PATH"), binaries{n});
     endwhile
     if (isempty (data.(binary).bin) && data.(binary).warn_on_absence)
       warning (sprintf ("print:no%s", binary),
-               "print.m: '%s' not found in PATH", binary)
+               "print.m: '%s' not found in PATH", binary);
       data.(binary).warn_on_absence = false;
     endif
   endif
 
   bin = data.(binary).bin;
 
 endfunction
 
@@ -566,17 +566,17 @@ endfunction
 function value = convert2points (value, units)
     switch (units)
     case "inches"
       value = value * 72;
     case "centimeters"
       value = value * 72 / 25.4;
     case "normalized"
       error ("print:customnormalized",
-             "print.m: papersize=='<custom>' and paperunits='normalized' may not be combined")
+             "print.m: papersize=='<custom>' and paperunits='normalized' may not be combined");
     endswitch
 endfunction
 
 function device_list = gs_device_list ();
   ## Graphics formats/languages, not priners.
   device_list = {"bmp16"; "bmp16m"; "bmp256"; "bmp32b"; "bmpgray"; ...
                  "epswrite"; "jpeg"; "jpegcymk"; "jpeggray"; "pbm"; ...
                  "pbmraw"; "pcx16"; "pcx24b"; "pcx256"; "pcx2up"; ...
diff --git a/scripts/plot/axis.m b/scripts/plot/axis.m
--- a/scripts/plot/axis.m
+++ b/scripts/plot/axis.m
@@ -171,32 +171,32 @@ function curr_axis = __axis__ (ca, ax, v
     ## 'matrix mode' to reverse the y-axis
     if (strcmpi (ax, "ij"))
       set (ca, "ydir", "reverse");
     elseif (strcmpi (ax, "xy"))
       set (ca, "ydir", "normal");
 
       ## aspect ratio
     elseif (strcmpi (ax, "image"))
-      __axis__ (ca, "equal")
+      __axis__ (ca, "equal");
       __do_tight_option__ (ca);
     elseif (strcmpi (ax, "square"))
       set (ca, "plotboxaspectratio", [1, 1, 1]);
     elseif  (strcmp (ax, "equal"))
       if (strcmp (get (get (ca, "parent"), "__graphics_toolkit__"), "gnuplot"))
         ## FIXME - gnuplot applies the aspect ratio activepostionproperty.
         set (ca, "activepositionproperty", "position");
         ## The following line is a trick used to trigger the recalculation of
         ## aspect related magnitudes even if the aspect ratio is the same
         ## (useful with the x11 gnuplot terminal after a window resize)
         set (ca, "dataaspectratiomode", "auto");
       endif
-      set (ca, "dataaspectratio", [1, 1, 1])
+      set (ca, "dataaspectratio", [1, 1, 1]);
     elseif (strcmpi (ax, "normal"))
-      set (ca, "plotboxaspectratio", [1, 1, 1])
+      set (ca, "plotboxaspectratio", [1, 1, 1]);
       set (ca, "plotboxaspectratiomode", "auto");
 
       ## axis limits
     elseif (len >= 4 && strcmpi (ax(1:4), "auto"))
       if (len > 4)
         if (any (ax == "x"))
           set (ca, "xlimmode", "auto");
         endif
diff --git a/scripts/plot/caxis.m b/scripts/plot/caxis.m
--- a/scripts/plot/caxis.m
+++ b/scripts/plot/caxis.m
@@ -76,13 +76,13 @@ function [cmin, cmax] = __caxis__ (ca, a
     endif
 
     set (ca, "clim", [ax(1), ax(2)]);
   else
     error ("caxis: expecting no args, a string or a 2 element vector");
   endif
 
   if (nargin > 2)
-    __caxis__ (ca, varargin{:})'
+    __caxis__ (ca, varargin{:})';
   endif
 
 endfunction
 
diff --git a/scripts/plot/cla.m b/scripts/plot/cla.m
--- a/scripts/plot/cla.m
+++ b/scripts/plot/cla.m
@@ -77,17 +77,17 @@ function cla (varargin)
   endif
 
   ## FIXME: The defaults should be "reset()" below, but so far there is
   ## no method to determine the defaults, much less return an object's
   ## properties to their default values.  Instead make a close
   ## approximation.
 
   axes (hax);
-  axis auto
+  axis ("auto");
 
   ## Set the current axis back to where it was upon entry.
   axes (oldhax);
 
 endfunction
 
 %!test
 %! hf = figure (1, "visible", "off");
diff --git a/scripts/plot/clabel.m b/scripts/plot/clabel.m
--- a/scripts/plot/clabel.m
+++ b/scripts/plot/clabel.m
@@ -56,17 +56,17 @@
 ## @end deftypefn
 
 function retval = clabel (c, varargin)
   label_spacing = 2 * 72;
   have_hg = false;
   have_labelspacing = false;
 
   if (nargin < 1)
-    print_usage()
+    print_usage ();
   elseif (nargin == 1)
     hparent = gca ();
   else
     arg = varargin{1};
     if (isscalar (arg) && ishandle(arg)
         && strcmp (get (arg, "type"), "hggroup"))
       obj = get (arg);
       if (! isfield (obj, "contourmatrix"))
diff --git a/scripts/plot/clf.m b/scripts/plot/clf.m
--- a/scripts/plot/clf.m
+++ b/scripts/plot/clf.m
@@ -60,17 +60,17 @@ function clf (varargin)
     hfig = gcf;
     oldfig = hfig;
     do_reset = false;
   endif
 
   if (do_reset)
     ## Select all the children, including the one with hidden handles.
     hc = allchild (hfig);
-    reset (hfig)
+    reset (hfig);
   else
     ## Select only the chilren with visible handles.
     hc = get (hfig, "children");
   endif
 
   ## Delete the children.
   delete (hc);
 
diff --git a/scripts/plot/colorbar.m b/scripts/plot/colorbar.m
--- a/scripts/plot/colorbar.m
+++ b/scripts/plot/colorbar.m
@@ -91,23 +91,23 @@ function h = colorbar (varargin)
   endwhile
 
   if (isempty (ax))
     ax = gca ();
   endif
 
   showhiddenhandles = get (0, "showhiddenhandles");
   unwind_protect
-    set (0, "showhiddenhandles", "on")
+    set (0, "showhiddenhandles", "on");
     cax = findobj (get (ax, "parent"), "tag", "colorbar", "type", "axes", "axes", ax);
     if (! isempty (cax))
       delete (cax);
     endif
   unwind_protect_cleanup
-    set (0, "showhiddenhandles", showhiddenhandles)
+    set (0, "showhiddenhandles", showhiddenhandles);
   end_unwind_protect
 
   if (! deleting)
     ## FIXME - Matlab does not require the "position" property to be active.
     ##         Is there a way to determine the plotbox position for the
     ##         gnuplot graphics toolkit with the outerposition is active?
     set (ax, "activepositionproperty", "position");
     obj = get (ax);
@@ -158,22 +158,22 @@ function h = colorbar (varargin)
 
     ctext = text (0, 0, "", "tag", "colorbar","visible", "off",
                   "handlevisibility", "off", "xliminclude", "off",
                   "yliminclude", "off", "zliminclude", "off",
                   "deletefcn", {@deletecolorbar, cax, obj});
 
     set (cax, "deletefcn", {@resetaxis, obj});
 
-    addlistener (ax, "clim", {@update_colorbar_clim, hi, vertical})
-    addlistener (ax, "plotboxaspectratio", {@update_colorbar_axis, cax, obj})
-    addlistener (ax, "plotboxaspectratiomode", {@update_colorbar_axis, cax, obj})
-    addlistener (ax, "dataaspectratio", {@update_colorbar_axis, cax, obj})
-    addlistener (ax, "dataaspectratiomode", {@update_colorbar_axis, cax, obj})
-    addlistener (ax, "position", {@update_colorbar_axis, cax, obj})
+    addlistener (ax, "clim", {@update_colorbar_clim, hi, vertical});
+    addlistener (ax, "plotboxaspectratio", {@update_colorbar_axis, cax, obj});
+    addlistener (ax, "plotboxaspectratiomode", {@update_colorbar_axis, cax, obj});
+    addlistener (ax, "dataaspectratio", {@update_colorbar_axis, cax, obj});
+    addlistener (ax, "dataaspectratiomode", {@update_colorbar_axis, cax, obj});
+    addlistener (ax, "position", {@update_colorbar_axis, cax, obj});
 
   endif
 
   if (nargout > 0)
     h = cax;
   endif
 endfunction
 
diff --git a/scripts/plot/cylinder.m b/scripts/plot/cylinder.m
--- a/scripts/plot/cylinder.m
+++ b/scripts/plot/cylinder.m
@@ -60,17 +60,17 @@ function [xx, yy, zz] = cylinder (vararg
   elseif (nargs == 2)
     r = args{1};
     n = args{2};
   else
     print_usage ();
   endif
 
   if (length (r) < 2)
-    error ("cylinder: length(R) must be larger than 2")
+    error ("cylinder: length(R) must be larger than 2");
   endif
 
   phi = linspace (0, 2*pi, n+1);
   idx = 1:length(r);
   [phi, idx] = meshgrid(phi, idx);
   z = (idx - 1) / (length(r) - 1);
   r = r(idx);
   [x, y] = pol2cart (phi, r);
diff --git a/scripts/plot/daspect.m b/scripts/plot/daspect.m
--- a/scripts/plot/daspect.m
+++ b/scripts/plot/daspect.m
@@ -51,41 +51,41 @@ function varargout = daspect (varargin)
       if (ischar (varargin{1})
           && any (strcmpi (varargin{1}, {"mode", "manual", "auto"})))
         switch (varargin{1})
         case "mode"
           if (nargout < 2)
             varargout{1} = get (hax, "dataaspectratiomode");
             return
           else
-            error ("daspect: only one output is allowed")
+            error ("daspect: only one output is allowed");
           endif
         case "manual"
           set (hax, "dataaspectratiomode", "manual");
         case "auto"
           set (hax, "dataaspectratiomode", "auto");
         endswitch
       elseif (isreal (varargin{1}) && numel (varargin{1}) == 2)
-        set (hax, "dataaspectratio", [varargin{1}, 1])
+        set (hax, "dataaspectratio", [varargin{1}, 1]);
       elseif (isreal (varargin{1}) && numel (varargin{1}) == 3)
-        set (hax, "dataaspectratio", varargin{1})
+        set (hax, "dataaspectratio", varargin{1});
       else
-        error ("daspect: invalid input")
+        error ("daspect: invalid input");
       endif
     elseif (numel (varargin) > 1)
-      error ("daspect: too many inputs")
+      error ("daspect: too many inputs");
     endif
   elseif (nargout == 0)
     print_usage ();
   endif
 
   if (nargout == 1)
     varargout{1} = get (hax, "dataaspectratio");
   elseif (nargout > 1)
-    error ("daspect: only one output is allowed")
+    error ("daspect: only one output is allowed");
   endif
 
 endfunction
 
 %!demo
 %! x = 0:0.01:4;
 %! clf
 %! plot (x, cos (x), x, sin (x))
diff --git a/scripts/plot/gnuplot_drawnow.m b/scripts/plot/gnuplot_drawnow.m
--- a/scripts/plot/gnuplot_drawnow.m
+++ b/scripts/plot/gnuplot_drawnow.m
@@ -47,17 +47,17 @@ function gnuplot_drawnow (h, term, file,
         __go_draw_figure__ (h, plot_stream(1), enhanced, mono);
         if (nargin == 5)
           fid = fopen (debug_file, "wb");
           enhanced = gnuplot_set_term (fid, true, h, term, file);
           __go_draw_figure__ (h, fid, enhanced, mono);
         endif
       else
         error ("gnuplot_drawnow: the gnuplot terminal, \"%s\", is not available",
-               gnuplot_trim_term (term))
+               gnuplot_trim_term (term));
       endif
     unwind_protect_cleanup
       set (h, "__plot_stream__", default_plot_stream);
       if (! isempty (plot_stream))
         pclose (plot_stream(1));
         if (numel (plot_stream) > 1)
           pclose (plot_stream(2));
         endif
@@ -246,27 +246,27 @@ function enhanced = gnuplot_set_term (pl
               gnuplot_pos(2) = screen_size(2) - gnuplot_pos(2) - gnuplot_size(2);
               gnuplot_pos = max (gnuplot_pos, 1);
               size_str = sprintf ("%s position %d,%d", size_str,
                                   gnuplot_pos(1), gnuplot_pos(2));
             endif
           endif
         else
           size_str = "";
-          warning ("gnuplot_set_term: size is zero")
+          warning ("gnuplot_set_term: size is zero");
         endif
       else
         ## A specified size take priority over the figure properies.
         size_str = "";
       endif
     else
       if isempty (h)
-        disp ("gnuplot_set_term: figure handle is empty")
+        disp ("gnuplot_set_term: figure handle is empty");
       elseif !isfigure(h)
-        disp ("gnuplot_set_term: not a figure handle")
+        disp ("gnuplot_set_term: not a figure handle");
       endif
       title_str = "";
       size_str = "";
     endif
 
     ## Set the gnuplot terminal (type, enhanced, title, options & size).
     term_str = sprintf ("set terminal %s", term);
     if (! isempty (enh_str))
diff --git a/scripts/plot/meshc.m b/scripts/plot/meshc.m
--- a/scripts/plot/meshc.m
+++ b/scripts/plot/meshc.m
@@ -38,17 +38,17 @@ function h = meshc (varargin)
   set (tmp, "facecolor", "w");
   set (tmp, "edgecolor", "flat");
 
   if (! ishold ())
     set (ax, "view", [-37.5, 30],
          "xgrid", "on", "ygrid", "on", "zgrid", "on");
   endif
 
-  drawnow
+  drawnow ();
   zmin = get (ax, "zlim")(1);
 
   [c, tmp2] = __contour__ (ax, zmin, varargin{:});
 
   tmp = [tmp; tmp2];
 
   if (nargout > 0)
     h = tmp;
diff --git a/scripts/plot/newplot.m b/scripts/plot/newplot.m
--- a/scripts/plot/newplot.m
+++ b/scripts/plot/newplot.m
@@ -29,17 +29,17 @@ function newplot ()
     cf = gcf ();
     fnp = get (cf, "nextplot");
     switch (fnp)
       ## FIXME -- probably we should do more than validate the nextplot
       ## property value...
       case "new"
       case "add"
       case "replacechildren"
-        delete (get (cf, "children"))
+        delete (get (cf, "children"));
       case "replace"
       otherwise
         error ("newplot: unrecognized nextplot property for current figure");
     endswitch
     ca = gca ();
     anp = get (ca, "nextplot");
     if (strcmp (get (ca, "__hold_all__"), "off"))
       __next_line_color__ (true);
@@ -47,17 +47,17 @@ function newplot ()
     else
       __next_line_color__ (false);
       __next_line_style__ (false);
     endif
     switch (anp)
       case "new"
       case "add"
       case "replacechildren"
-        delete (get (ca, "children"))
+        delete (get (ca, "children"));
       case "replace"
         __go_axes_init__ (ca, "replace");
         __request_drawnow__ ();
       otherwise
         error ("newplot: unrecognized nextplot property for current axes");
     endswitch
   else
     print_usage ();
diff --git a/scripts/plot/orient.m b/scripts/plot/orient.m
--- a/scripts/plot/orient.m
+++ b/scripts/plot/orient.m
@@ -48,22 +48,22 @@ function retval = orient (varargin)
   elseif (nargin == 1)
     orientation = varargin{1};
     if (strcmpi (orientation, "landscape") || strcmpi (orientation, "portrait"))
       if (! strcmpi (get (cf, "paperorientation"), orientation))
         ## FIXME - with the proper listeners in place there won't be a need to set
         ##         the papersize and paperpostion here.
         papersize = get (cf, "papersize");
         paperposition = get (cf, "paperposition");
-        set (cf, "paperorientation", orientation)
+        set (cf, "paperorientation", orientation);
         set (cf, "papersize", papersize([2, 1]));
         set (cf, "paperposition", paperposition([2, 1, 4, 3]));
       endif
     elseif (strcmpi (varargin{1}, 'tall'))
-      orient ("portrait")
+      orient ("portrait");
       papersize = get (cf, "papersize");
       set (cf, "paperposition", [0.25, 0.25, (papersize - 0.5)]);
     else
       error ("orient: unknown ORIENTATION");
     endif
   else
     print_usage ();
   endif
diff --git a/scripts/plot/pbaspect.m b/scripts/plot/pbaspect.m
--- a/scripts/plot/pbaspect.m
+++ b/scripts/plot/pbaspect.m
@@ -51,41 +51,41 @@ function varargout = pbaspect (varargin)
       if (ischar (varargin{1})
           && any (strcmpi (varargin{1}, {"mode", "manual", "auto"})))
         switch (varargin{1})
         case "mode"
           if (nargout < 2)
             varargout{1} = get (hax, "plotboxaspectratiomode");
             return
           else
-            error ("pbaspect: only one output is allowed")
+            error ("pbaspect: only one output is allowed");
           endif
         case "manual"
           set (hax, "plotboxaspectratiomode", "manual");
         case "auto"
           set (hax, "plotboxaspectratiomode", "auto");
         endswitch
       elseif (isreal (varargin{1}) && numel (varargin{1}) == 2)
-        set (hax, "plotboxaspectratio", [varargin{1}, 1])
+        set (hax, "plotboxaspectratio", [varargin{1}, 1]);
       elseif (isreal (varargin{1}) && numel (varargin{1}) == 3)
-        set (hax, "plotboxaspectratio", varargin{1})
+        set (hax, "plotboxaspectratio", varargin{1});
       else
-        error ("pbaspect: invalid input")
+        error ("pbaspect: invalid input");
       endif
     elseif (numel (varargin) > 1)
-      error ("pbaspect: too many inputs")
+      error ("pbaspect: too many inputs");
     endif
   elseif (nargout == 0)
     print_usage ();
   endif
 
   if (nargout == 1)
     varargout{1} = get (hax, "plotboxaspectratio");
   elseif (nargout > 1)
-    error ("pbaspect: only one output is allowed")
+    error ("pbaspect: only one output is allowed");
   endif
 
 endfunction
 
 %!demo
 %! x = 0:0.01:4;
 %! clf
 %! plot (x, cos (x), x, sin (x))
diff --git a/scripts/plot/plotyy.m b/scripts/plot/plotyy.m
--- a/scripts/plot/plotyy.m
+++ b/scripts/plot/plotyy.m
@@ -108,17 +108,17 @@ function [Ax, H1, H2] = plotyy (varargin
     [ax, h1, h2] = __plotyy__ (ax, varargin{:});
   unwind_protect_cleanup
     ## Only change back to the old axis if we didn't delete it
     if (ishandle(oldh) && strcmp (get (oldh, "type"), "axes"))
       axes (oldh);
     endif
   end_unwind_protect
 
-  set (ax, "activepositionproperty", "position")
+  set (ax, "activepositionproperty", "position");
 
   if (nargout > 0)
     Ax = ax;
     H1 = h1;
     H2 = h2;
   endif
 
 endfunction
@@ -187,17 +187,17 @@ function [ax, h1, h2] = __plotyy__ (ax, 
   addlistener (ax(2), "view", {@update_position, ax(1)});
   addlistener (ax(1), "plotboxaspectratio", {@update_position, ax(2)});
   addlistener (ax(2), "plotboxaspectratio", {@update_position, ax(1)});
   addlistener (ax(1), "plotboxaspectratiomode", {@update_position, ax(2)});
   addlistener (ax(2), "plotboxaspectratiomode", {@update_position, ax(1)});
 
   ## Tag the plotyy axes, so we can use that information
   ## not to mirror the y axis tick marks
-  set (ax, "tag", "plotyy")
+  set (ax, "tag", "plotyy");
 
   ## Cross-reference one axis to the other in the userdata
   set (ax(1), "userdata", ax(2));
   set (ax(2), "userdata", ax(1));
 
   ## Store the axes handles for the sister axes.
   try
     addproperty ("__plotyy_axes__", ax(1), "data", ax);
@@ -260,17 +260,17 @@ function update_position (h, d, ax2)
       view = get (h, "view");
       plotboxaspectratio = get (h, "plotboxaspectratio");
       plotboxaspectratiomode = get (h, "plotboxaspectratiomode");
       oldposition = get (ax2, "position");
       oldview = get (ax2, "view");
       oldplotboxaspectratio = get (ax2, "plotboxaspectratio");
       oldplotboxaspectratiomode = get (ax2, "plotboxaspectratiomode");
       if (! (isequal (position, oldposition) && isequal (view, oldview)))
-        set (ax2, "position", position, "view", view)
+        set (ax2, "position", position, "view", view);
       endif
       if (! (isequal (plotboxaspectratio, oldplotboxaspectratio)
              && isequal (plotboxaspectratiomode, oldplotboxaspectratiomode)))
         set (ax2, "plotboxaspectratio", plotboxaspectratio);
         set (ax2, "plotboxaspectratiomode", plotboxaspectratiomode);
       endif
     unwind_protect_cleanup
       recursion = false;
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -261,21 +261,21 @@ function print (varargin)
 
   opts.pstoedit_cmd = @pstoedit;
   opts.fig2dev_cmd = @fig2dev;
   opts.latex_standalone = @latex_standalone;
   opts.lpr_cmd = @lpr;
   opts.epstool_cmd = @epstool;
 
   if (! isfigure (opts.figure))
-    error ("print: no figure to print")
+    error ("print: no figure to print");
   endif
 
   orig_figure = get (0, "currentfigure");
-  figure (opts.figure)
+  figure (opts.figure);
 
   if (opts.append_to_file)
     [~, ~, ext] = fileparts (opts.ghostscript.output);
     opts.ghostscript.prepend = strcat (tmpnam (), ext);
     copyfile (opts.ghostscript.output, opts.ghostscript.prepend);
   endif
 
   unwind_protect
@@ -284,17 +284,17 @@ function print (varargin)
     props = [];
 
     ## graphics toolkit tranlates figure position to eps bbox in points
     fpos = get (opts.figure, "position");
     props(1).h = opts.figure;
     props(1).name = "position";
     props(1).value = {fpos};
     fpos(3:4) = opts.canvas_size;
-    set (opts.figure, "position", fpos)
+    set (opts.figure, "position", fpos);
 
     ## Set figure background to none. This is done both for
     ## consistency with Matlab and to elliminate the visible
     ## box along the figure's perimeter.
     props(2).h = opts.figure;
     props(2).name = "color";
     props(2).value{1} = get (props(2).h, props(2).name);
     set (props(2).h, props(2).name, "none");
@@ -307,17 +307,17 @@ function print (varargin)
         props(m+n).name = "linestyle";
         props(m+n).value = {get(h(n), "linestyle")};
       endfor
       if (opts.force_solid > 0)
         linestyle = "-";
       else
         linestyle = "--";
       endif
-      set (h, "linestyle", linestyle)
+      set (h, "linestyle", linestyle);
     endif
 
     if (opts.use_color < 0
         && ! strcmp (get (opts.figure, "__graphics_toolkit__"), "gnuplot"))
       color_props = {"color", "facecolor", "edgecolor", "colormap"};
       for c = 1:numel(color_props)
         h = findall (opts.figure, "-property", color_props{c});
         hnone = findall (opts.figure, color_props{c}, "none");
@@ -330,17 +330,17 @@ function print (varargin)
             rgb = get (h(n), color_props{c});
             props(end+1).h = h(n);
             props(end).name = color_props{c};
             props(end).value = {get(h(n), color_props{c})};
             if (isnumeric (rgb))
               ## convert RGB color to RGB gray scale
               xfer = repmat ([0.30, 0.59, 0.11], size (rgb, 1), 1);
               ggg = repmat (sum (xfer .* rgb, 2), 1, 3);
-              set (h(n), color_props{c}, ggg)
+              set (h(n), color_props{c}, ggg);
             endif
           endif
         endfor
       endfor
     endif
 
     if (! isempty (opts.font) || ! isempty (opts.fontsize))
       h = findall (opts.figure, "-property", "fontname");
@@ -357,51 +357,51 @@ function print (varargin)
           if (! isempty (opts.fontsize))
             props(end+1).h = h(n);
             props(end).name = "fontsize";
             props(end).value = {get(h(n), "fontsize")};
           endif
         endif
       endfor
       if (! isempty (opts.font))
-        set (h(ishandle(h)), "fontname", opts.font)
+        set (h(ishandle(h)), "fontname", opts.font);
       endif
       if (! isempty (opts.fontsize))
         if (ischar (opts.fontsize))
           fontsize = str2double (opts.fontsize);
         else
           fontsize = opts.fontsize;
         endif
-        set (h(ishandle(h)), "fontsize", fontsize)
+        set (h(ishandle(h)), "fontsize", fontsize);
       endif
     endif
 
     ## call the graphcis toolkit print script
     switch (get (opts.figure, "__graphics_toolkit__"))
     case "gnuplot"
       opts = __gnuplot_print__ (opts);
     otherwise
       opts = __fltk_print__ (opts);
     endswitch
 
   unwind_protect_cleanup
     ## restore modified properties
     if (isstruct (props))
       for n = 1:numel(props)
         if (ishandle (props(n).h))
-          set (props(n).h, props(n).name, props(n).value{1})
+          set (props(n).h, props(n).name, props(n).value{1});
         endif
       endfor
     endif
 
     ## Unlink temporary files
     for n = 1:numel(opts.unlink)
       [status, output] = unlink (opts.unlink{n});
       if (status != 0)
-        warning ("print.m: %s, '%s'", output, opts.unlink{n})
+        warning ("print.m: %s, '%s'", output, opts.unlink{n});
       endif
     endfor
   end_unwind_protect
 
   if (isfigure (orig_figure))
     figure (orig_figure);
   endif
 
@@ -449,17 +449,17 @@ function cmd = epstool (opts, filein, fi
     endif
   else
     pipeout = false;
     fileout = strcat ("'", strtrim (fileout), "'");
   endif
 
   if (! isempty (opts.preview) && opts.tight_flag)
     warning ("print:previewandtight",
-             "print.m: eps preview may not be combined with -tight")
+             "print.m: eps preview may not be combined with -tight");
   endif
   if (! isempty (opts.preview) || opts.tight_flag)
     if (! isempty (opts.epstool_binary))
       if (opts.tight_flag)
         cmd = "--copy --bbox";
       elseif (! isempty (opts.preview))
         switch opts.preview
         case "tiff"
@@ -486,41 +486,41 @@ function cmd = epstool (opts, filein, fi
                        cmd, filein, fileout);
       endif
       if (pipein)
         if (dos_shell)
           filein(filein=="'") = "\"";
           gs_cmd = __ghostscript__ ("binary", opts.ghostscript.binary,
                                     "device", "epswrite",
                                     "source", "-",
-                                    "output", filein)
+                                    "output", filein);
           cmd = sprintf ("%s %s & %s", gs_cmd, filein, cmd);
         else
           cmd = sprintf ("cat > %s ; %s", filein, cmd);
         endif
       endif
       if (pipeout)
         if (dos_shell)
           cmd = sprintf ("%s & type %s", cmd, fileout);
         else
           cmd = sprintf ("%s ; cat %s", cmd, fileout);
         endif
       endif
       if (! isempty (cleanup))
         if (pipeout && dos_shell)
           error ("print:epstoolpipe",
-                 "print.m: cannot pipe output of 'epstool' for DOS shell")
+                 "print.m: cannot pipe output of 'epstool' for DOS shell");
         elseif (pipeout)
           cmd = sprintf ("( %s %s )", cmd, cleanup);
         else
           cmd = sprintf ("%s %s", cmd, cleanup);
         endif
       endif
     elseif (isempty (opts.epstool_binary))
-      error ("print:noepstool", "print.m: 'epstool' not found in PATH")
+      error ("print:noepstool", "print.m: 'epstool' not found in PATH");
     endif
   else
     if (pipein && pipeout)
       if (dos_shell)
         cmd = __ghostscript__ ("binary", opts.ghostscript.binary,
                                "device", "epswrite",
                                "source", "-",
                                "output", "-");
@@ -548,107 +548,107 @@ function cmd = epstool (opts, filein, fi
       if (dos_shell)
         cmd = sprintf (" copy %s %s ", filein, fileout);
       else
         cmd = sprintf (" cp %s %s ", filein, fileout);
       endif
     endif
   endif
   if (opts.debug)
-    fprintf ("epstool command: '%s'\n", cmd)
+    fprintf ("epstool command: '%s'\n", cmd);
   endif
 endfunction
 
 function cmd = fig2dev (opts, devopt)
   if (nargin < 2)
     devopt =  opts.devopt;
   endif
   dos_shell = (ispc () && ! isunix ());
   if (! isempty (opts.fig2dev_binary))
     if (dos_shell)
       ## FIXME - is this the right thing to do for DOS?
       cmd = sprintf ("%s -L %s 2> NUL", opts.fig2dev_binary, devopt);
     else
       cmd = sprintf ("%s -L %s 2> /dev/null", opts.fig2dev_binary, devopt);
     endif
   elseif (isempty (opts.fig2dev_binary))
-    error ("print:nofig2dev", "print.m: 'fig2dev' not found in PATH")
+    error ("print:nofig2dev", "print.m: 'fig2dev' not found in PATH");
   endif
   if (opts.debug)
-    fprintf ("fig2dev command: '%s'\n", cmd)
+    fprintf ("fig2dev command: '%s'\n", cmd);
   endif
 endfunction
 
 function latex_standalone (latexfile)
   prepend = {"\\documentclass{minimal}";
              "\\usepackage{epsfig,color}";
              "\\begin{document}";
              "\\centering"};
   postpend = {"\\end{document}"};
   fid = fopen (latexfile, "r");
   if (fid >= 0)
     latex = fscanf (fid, "%c", Inf);
     status = fclose (fid);
     if (status != 0)
       error ("print:errorclosingfile",
-             "print.m: error closing file '%s'", latexfile)
+             "print.m: error closing file '%s'", latexfile);
     endif
   else
     error ("print:erroropeningfile",
-           "print.m: error opening file '%s'", latexfile)
+           "print.m: error opening file '%s'", latexfile);
   endif
   fid = fopen (latexfile, "w");
   if (fid >= 0)
     fprintf (fid, "%s\n", prepend{:});
     fprintf (fid, "%s", latex);
     fprintf (fid, "%s\n", postpend{:});
     status = fclose (fid);
     if (status != 0)
       error ("print:errorclosingfile",
-             "print.m: error closing file '%s'", latexfile)
+             "print.m: error closing file '%s'", latexfile);
     endif
   else
     error ("print:erroropeningfile",
-           "print.m: error opening file '%s'", latexfile)
+           "print.m: error opening file '%s'", latexfile);
   endif
 endfunction
 
 function cmd = lpr (opts)
   if (nargin < 2)
     devopt =  opts.devopt;
   endif
   if (! isempty (opts.lpr_binary))
     cmd = opts.lpr_binary;
     if (! isempty (opts.lpr_options))
       cmd = sprintf ("%s %s", cmd, opts.lpr_options);
     endif
     if (! isempty (opts.printer))
       cmd = sprintf ("%s -P %s", cmd, opts.printer);
     endif
   elseif (isempty (opts.lpr_binary))
-    error ("print:nolpr", "print.m: 'lpr' not found in PATH")
+    error ("print:nolpr", "print.m: 'lpr' not found in PATH");
   endif
   if (opts.debug)
-    fprintf ("lpr command: '%s'\n", cmd)
+    fprintf ("lpr command: '%s'\n", cmd);
   endif
 endfunction
 
 function cmd = pstoedit (opts, devopt)
   if (nargin < 2)
     devopt =  opts.devopt;
   endif
   dos_shell = (ispc () && ! isunix ());
   if (! isempty (opts.pstoedit_binary))
     if (dos_shell)
       cmd = sprintf ("%s -f %s 2> NUL", opts.pstoedit_binary, devopt);
     else
       ## FIXME - is this the right thing to do for DOS?
       cmd = sprintf ("%s -f %s 2> /dev/null", opts.pstoedit_binary, devopt);
     endif
   elseif (isempty (opts.pstoedit_binary))
-    error ("print:nopstoedit", "print.m: 'pstoedit' not found in PATH")
+    error ("print:nopstoedit", "print.m: 'pstoedit' not found in PATH");
   endif
   if (opts.debug)
-    fprintf ("pstoedit command: '%s'\n", cmd)
+    fprintf ("pstoedit command: '%s'\n", cmd);
   endif
 endfunction
 
 
diff --git a/scripts/plot/private/__actual_axis_position__.m b/scripts/plot/private/__actual_axis_position__.m
--- a/scripts/plot/private/__actual_axis_position__.m
+++ b/scripts/plot/private/__actual_axis_position__.m
@@ -32,21 +32,21 @@ function pos = __actual_axis_position__ 
     axis_obj = h;
     h = axis_obj.__my_handle__;
   endif
 
   ## Get figure size in pixels
   orig_fig_units = get (axis_obj.parent, "units");
   orig_fig_position = get (axis_obj.parent, "position");
   unwind_protect
-    set (axis_obj.parent, "units", "pixels")
+    set (axis_obj.parent, "units", "pixels");
     fig_position = get (axis_obj.parent, "position");
   unwind_protect_cleanup
-    set (axis_obj.parent, "units", orig_fig_units)
-    set (axis_obj.parent, "position", orig_fig_position)
+    set (axis_obj.parent, "units", orig_fig_units);
+    set (axis_obj.parent, "position", orig_fig_position);
   end_unwind_protect
   ## Get axes size in pixels
   if (strcmp (get (axis_obj.parent, "__graphics_toolkit__"), "gnuplot")
       && strcmp (axis_obj.activepositionproperty, "outerposition"))
     pos_in_pixels = axis_obj.outerposition .* fig_position([3, 4, 3, 4]);
   else
     pos_in_pixels = axis_obj.position .* fig_position([3, 4, 3, 4]);
   endif
diff --git a/scripts/plot/private/__axis_label__.m b/scripts/plot/private/__axis_label__.m
--- a/scripts/plot/private/__axis_label__.m
+++ b/scripts/plot/private/__axis_label__.m
@@ -32,17 +32,18 @@ function retval = __axis_label__ (caller
 
     set (h, "fontangle", get (ca, "fontangle"),
          "fontname", get (ca, "fontname"),
          "fontsize", get (ca, "fontsize"),
          "fontunits", get (ca, "fontunits"),
          "fontweight", get (ca, "fontweight"),
          "string", txt,
          varargin{:});
-    __fltk_redraw__()
+
+    __fltk_redraw__();
 
     if (nargout > 0)
       retval = h;
     endif
   else
     error ("%s: expecting first argument to be character string", caller);
   endif
 
diff --git a/scripts/plot/private/__bar__.m b/scripts/plot/private/__bar__.m
--- a/scripts/plot/private/__bar__.m
+++ b/scripts/plot/private/__bar__.m
@@ -197,17 +197,17 @@ function tmp = bars (ax, vertical, x, y,
         h = patch(xb(:,:,i), yb(:,:,i), "FaceColor", "flat",
                   "cdata", lev, "parent", hg);
       else
         h = patch(xb(:,:,i), yb(:,:,i), "parent", hg);
       endif
     else
       if (! have_color_spec)
         if (ycols == 1)
-          lev = clim(1)
+          lev = clim(1);
         else
           lev = (i - 1) * (clim(2) - clim(1)) / (ycols - 1) - clim(1);
         endif
         h = patch(yb(:,:,i), xb(:,:,i), "FaceColor", "flat",
                   "cdata", lev, "parent", hg);
       else
         h = patch(yb(:,:,i), xb(:,:,i), "parent", hg);
       endif
@@ -233,19 +233,19 @@ function tmp = bars (ax, vertical, x, y,
 
     addproperty ("barwidth", hg, "data", width);
     if (group)
       addproperty ("barlayout", hg, "radio", "stacked|{grouped}", "grouped");
     else
       addproperty ("barlayout", hg, "radio", "{stacked}|grouped", "stacked");
     endif
     if (vertical)
-      addproperty ("horizontal", hg, "radio", "on|{off}", "off")
+      addproperty ("horizontal", hg, "radio", "on|{off}", "off");
     else
-      addproperty ("horizontal", hg, "radio", "{on}|off", "on")
+      addproperty ("horizontal", hg, "radio", "{on}|off", "on");
     endif
 
     addlistener (hg, "barwidth", @update_group);
     addlistener (hg, "barlayout", @update_group);
     addlistener (hg, "horizontal", @update_group);
 
     addproperty ("edgecolor", hg, "patchedgecolor", get (h, "edgecolor"));
     addproperty ("linewidth", hg, "patchlinewidth", get (h, "linewidth"));
diff --git a/scripts/plot/private/__clabel__.m b/scripts/plot/private/__clabel__.m
--- a/scripts/plot/private/__clabel__.m
+++ b/scripts/plot/private/__clabel__.m
@@ -36,17 +36,17 @@ function h = __clabel__ (c, v, hparent, 
     y = get (hparent, "ydata");
     ymin = min (y(:));
     ymax = max (y(:));
   else
     i1 = 1;
     while (i1 < length (c))
       clev = c(1,i1);
       clen = c(2,i1);
-      p = c(:, i1+1:i1+clen)
+      p = c(:, i1+1:i1+clen);
 
       xmin = min (c(1,:));
       xmax = max (c(1,:));
       ymin = min (c(2,:));
       ymax = max (c(2,:));
 
       i1 += clen+1;
     endwhile
diff --git a/scripts/plot/private/__errplot__.m b/scripts/plot/private/__errplot__.m
--- a/scripts/plot/private/__errplot__.m
+++ b/scripts/plot/private/__errplot__.m
@@ -144,34 +144,34 @@ function h = __errplot__ (fstr, p, varar
           udata = varargin{6}(:,i);
         else
           error ("errorbar: error plot with 6 columns only valid for boxxy and xyerr");
         endif
       otherwise
         error ("errorbar: error plot requires 2, 3, 4 or 6 arguments");
     endswitch
 
-    addproperty ("xdata", hg, "data", xdata(:))
-    addproperty ("ydata", hg, "data", ydata(:))
-    addproperty ("ldata", hg, "data", ldata(:))
-    addproperty ("udata", hg, "data", udata(:))
-    addproperty ("xldata", hg, "data", xldata(:))
-    addproperty ("xudata", hg, "data", xudata(:))
+    addproperty ("xdata", hg, "data", xdata(:));
+    addproperty ("ydata", hg, "data", ydata(:));
+    addproperty ("ldata", hg, "data", ldata(:));
+    addproperty ("udata", hg, "data", udata(:));
+    addproperty ("xldata", hg, "data", xldata(:));
+    addproperty ("xudata", hg, "data", xudata(:));
     addproperty ("format", hg, "string", ifmt);
 
-    addproperty ("color", hg, "linecolor", get (hl(1), "color"))
-    addproperty ("linewidth", hg, "linelinewidth", get (hl(1), "linewidth"))
-    addproperty ("linestyle", hg, "linelinestyle", get (hl(1), "linestyle"))
-    addproperty ("marker", hg, "linemarker", get (hl(1), "marker"))
+    addproperty ("color", hg, "linecolor", get (hl(1), "color"));
+    addproperty ("linewidth", hg, "linelinewidth", get (hl(1), "linewidth"));
+    addproperty ("linestyle", hg, "linelinestyle", get (hl(1), "linestyle"));
+    addproperty ("marker", hg, "linemarker", get (hl(1), "marker"));
     addproperty ("markerfacecolor", hg, "linemarkerfacecolor",
-                 get (hl(1), "markerfacecolor"))
+                 get (hl(1), "markerfacecolor"));
     addproperty ("markeredgecolor", hg, "linemarkerfacecolor",
-                 get (hl(1), "markeredgecolor"))
+                 get (hl(1), "markeredgecolor"));
     addproperty ("markersize", hg, "linemarkersize",
-                 get (hl(1), "markersize"))
+                 get (hl(1), "markersize"));
 
     fcn = {@update_props, hl};
     addlistener (hg, "color", fcn);
     addlistener (hg, "linewidth", fcn);
     addlistener (hg, "linestyle", fcn);
     addlistener (hg, "marker", fcn);
     addlistener (hg, "markerfacecolor", fcn);
     addlistener (hg, "markersize", fcn);
@@ -184,17 +184,17 @@ function h = __errplot__ (fstr, p, varar
     addlistener (hg, "xldata", fcn);
     addlistener (hg, "xudata", fcn);
     addlistener (hg, "format", fcn);
 
     hax = ancestor (hg, "axes");
     addlistener (hax, "xscale", fcn);
     addlistener (hax, "yscale", fcn);
 
-    update_data (hg, [], hl)
+    update_data (hg, [], hl);
 
   endfor
 
 endfunction
 
 function [xdata, ydata] = errorbar_data (xdata, ydata, ldata, udata,
                                          xldata, xudata, ifmt,
                                          xscale, yscale)
@@ -252,17 +252,17 @@ function [xdata, ydata] = errorbar_data 
     [x1, y1] = errorbar_data (xdata, ydata, ldata, udata,
                               xldata, xudata, "xerr", xscale, yscale);
     [x2, y2] = errorbar_data (xdata, ydata, ldata, udata,
                               xldata, xudata, "yerr", xscale, yscale);
     xdata = [x1; x2];
     ydata = [y1; y2];
     return
   else
-      error ("errorbar: valid error bar types are xerr, yerr, boxxy, and xyerr")
+    error ("errorbar: valid error bar types are xerr, yerr, boxxy, and xyerr");
   endif
   xdata = xdata.'(:);
   ydata = ydata.'(:);
 endfunction
 
 function update_props (hg, dummy, hl)
   set (hl, "color", get (hg, "color"),
            "linewidth", get (hg, "linewidth"));,
diff --git a/scripts/plot/private/__ezplot__.m b/scripts/plot/private/__ezplot__.m
--- a/scripts/plot/private/__ezplot__.m
+++ b/scripts/plot/private/__ezplot__.m
@@ -413,20 +413,20 @@ function [h, needusage] = __ezplot__ (pf
     if (iscontour)
       [clev, h] = feval (pfunc, X, Y, Z);
     elseif (isplot && nargs == 2)
       h = [];
       hold_state = get (ax, "nextplot");
       for i = 1 : length (XX)
         h = [h; plot(XX{i}, YY{i})];
         if (i == 1)
-          set (ax, "nextplot", "add")
+          set (ax, "nextplot", "add");
         endif
       endfor
-      set (ax, "nextplot", hold_state)
+      set (ax, "nextplot", hold_state);
     elseif (ispolar || isplot)
       h = feval (pfunc, X, Z);
       if (isplot && !parametric)
         axis ([X(1), X(end), yrange]);
       endif
     else
       h = feval (pfunc, X, Y, Z);
     endif
diff --git a/scripts/plot/private/__ghostscript__.m b/scripts/plot/private/__ghostscript__.m
--- a/scripts/plot/private/__ghostscript__.m
+++ b/scripts/plot/private/__ghostscript__.m
@@ -92,17 +92,17 @@ function [gs_cmd, cleanup_cmd] = __ghost
                          gs_opts, opts.papersize);
       if (opts.papersize(1) > opts.papersize(2))
         ## Lanscape mode: This option will result in automatic rotation of the
         ##                document page if the requested page size matches one
         ##                of the default page sizes
         gs_opts = sprintf ("%s -dNORANGEPAGESIZE", gs_opts);
       endif
     else
-      error ("print:badpapersize", "__ghostscript__.m: invalid 'papersize'")
+      error ("print:badpapersize", "__ghostscript__.m: invalid 'papersize'");
     endif
     gs_opts = sprintf ("%s -dFIXEDMEDIA", gs_opts);
     ## "pageoffset" is relative to the coordinates, not the BBox LLHC.
     str = sprintf ("%s [%d %d] %s", "<< /Margins [0 0] /.HWMargins [0 0 0 0] /PageOffset",
                    opts.pageoffset, ">> setpagedevice");
     offset_ps = {"%!PS-Adobe-3.0", str, "%%EOF"};
     if (isfield (opts, "offsetfile"))
       offsetfile = opts.offsetfile;
@@ -111,27 +111,27 @@ function [gs_cmd, cleanup_cmd] = __ghost
       offsetfile = strcat (tmpnam (), ".ps");
       cleanup_cmd = sprintf ("rm %s", offsetfile);
     endif
     unwind_protect
       fid = fopen (offsetfile, "w");
       if (fid == -1)
         error ("print:fopenfailed", "__ghostscript__.m: fopen() failed");
       endif
-      fprintf (fid, "%s\n", offset_ps{:})
+      fprintf (fid, "%s\n", offset_ps{:});
     unwind_protect_cleanup
       status = fclose (fid);
       if (status == -1)
         error ("print:fclosefailed", "__ghostscript__.m: fclose() failed");
       endif
     end_unwind_protect
     if (opts.debug)
-      fprintf ("---- begin %s ----\n", offsetfile)
-      fprintf ("%s\n", offset_ps{:})
-      fprintf ("----- end %s -----\n", offsetfile)
+      fprintf ("---- begin %s ----\n", offsetfile);
+      fprintf ("%s\n", offset_ps{:});
+      fprintf ("----- end %s -----\n", offsetfile);
     endif
   endif
 
   if (isempty (opts.output))
     cmd = sprintf ("%s %s", opts.binary, gs_opts);
   else
     cmd = sprintf ("%s %s -sOutputFile=%s", opts.binary, gs_opts, opts.output);
   endif
diff --git a/scripts/plot/private/__patch__.m b/scripts/plot/private/__patch__.m
--- a/scripts/plot/private/__patch__.m
+++ b/scripts/plot/private/__patch__.m
@@ -101,17 +101,17 @@ function [h, failed] = __patch__ (p, var
         elseif (size (c, ndims (c)) == 3)
           args{7} = "facecolor";
           args{8} = "flat";
           args{9} = "cdata";
           args{10} = c;
         else
           ## Color Vectors
           if (rows (c) != rows (x) || rows (c) != length (y))
-            error ("patch: size of x, y, and c must be equal")
+            error ("patch: size of x, y, and c must be equal");
           else
             args{7} = "facecolor";
             args{8} = "interp";
             args{9} = "cdata";
             args{10} = [];
           endif
         endif
       elseif (ischar (varargin{iarg}) && rem (nargin - iarg, 2) != 0)
diff --git a/scripts/plot/private/__pie__.m b/scripts/plot/private/__pie__.m
--- a/scripts/plot/private/__pie__.m
+++ b/scripts/plot/private/__pie__.m
@@ -141,17 +141,17 @@ function hlist = __pie__ (caller, vararg
     else
       error ("__pie__: unknown caller `%s'", caller);
     endif
   endfor
 
   addlistener(gca, "view", {@update_text_pos, hlist});
 
   if (strncmp (caller, "pie3", 4))
-    axis ([-1.25, 1.25, -1.25, 1.25, -0.05, 0.4], "equal", "off")
+    axis ([-1.25, 1.25, -1.25, 1.25, -0.05, 0.4], "equal", "off");
     view (-37.5, 30);
   elseif (strncmp (caller, "pie", 3))
     axis ([-1.5, 1.5, -1.5, 1.5], "square", "off");
   endif
 endfunction
 
 function update_text_pos (all_handles)
   ## Text objects in the foreground should be at the base level.
@@ -179,22 +179,22 @@ function update_text_pos (all_handles)
     theta *= 180/pi;
     theta -= azel(1);
     theta = mod (theta, 360);
     ud_mask = (theta > 180);
     lr_mask = (theta > 90) & (theta < 270);
     for i = 1 : length (tobj)
       if (is_pie3)
         if (ud_mask(i))
-          set (tobj(i), "position", [pos(i,1), pos(i,2), -0.05])
+          set (tobj(i), "position", [pos(i,1), pos(i,2), -0.05]);
         else
-          set (tobj(i), "position", [pos(i,1), pos(i,2), 0.40])
+          set (tobj(i), "position", [pos(i,1), pos(i,2), 0.40]);
         endif
       endif
 
       if (lr_mask(i))
-        set (tobj(i), "horizontalalignment", "right")
+        set (tobj(i), "horizontalalignment", "right");
       else
-        set (tobj(i), "horizontalalignment", "left")
+        set (tobj(i), "horizontalalignment", "left");
       endif
     endfor
   endif
 endfunction
diff --git a/scripts/plot/private/__quiver__.m b/scripts/plot/private/__quiver__.m
--- a/scripts/plot/private/__quiver__.m
+++ b/scripts/plot/private/__quiver__.m
@@ -37,17 +37,17 @@ function hg = __quiver__ (varargin)
     endif
   endfor
 
   ioff = 3;
   if (nargin < (6 + is3d) || firstnonnumeric < (6 + is3d))
     u = varargin{ioff++};
     v = varargin{ioff++};
     if (is3d)
-      w = varargin{ioff++}
+      w = varargin{ioff++};
       [x, y, z] = meshgrid (1:size(u,2), 1:size(u,1), 1:max(size(w)));
     else
       [x, y] = meshgrid (1:size(u,2), 1:size(u,1));
     endif
     if (nargin >= ioff && isnumeric (varargin{ioff})
         && isscalar (varargin{ioff}))
       autoscale = varargin{ioff++};
     endif
@@ -270,25 +270,25 @@ function hg = __quiver__ (varargin)
     if (have_filled)
       ## FIXME gnuplot doesn't respect the markerfacecolor field
       set (h3, "markerfacecolor", get (h1, "color"));
     endif
 
     ## Set up the hggroup properties and listeners
     if (autoscale)
       addproperty ("autoscale", hg, "radio", "{on}|off", "on");
-      addproperty ("autoscalefactor", hg, "data", autoscale)
+      addproperty ("autoscalefactor", hg, "data", autoscale);
     else
       addproperty ("autoscale", hg, "radio", "{on}|off", "off");
-      addproperty ("autoscalefactor", hg, "data", 1.0)
+      addproperty ("autoscalefactor", hg, "data", 1.0);
     endif
-    addlistener (hg, "autoscale", @update_data)
-    addlistener (hg, "autoscalefactor", @update_data)
+    addlistener (hg, "autoscale", @update_data);
+    addlistener (hg, "autoscalefactor", @update_data);
 
-    addproperty ("maxheadsize", hg, "data", arrowsize)
+    addproperty ("maxheadsize", hg, "data", arrowsize);
     addlistener (hg, "maxheadsize", @update_data);
 
     addproperty ("showarrowhead", hg, "radio", "{on}|off", "on");
     addlistener (hg, "showarrowhead", @update_props);
 
     addproperty ("color", hg, "linecolor", get (h1, "color"));
     addproperty ("linewidth", hg, "linelinewidth", get (h1, "linewidth"));
     addproperty ("linestyle", hg, "linelinestyle", get (h1, "linestyle"));
diff --git a/scripts/plot/private/__scatter__.m b/scripts/plot/private/__scatter__.m
--- a/scripts/plot/private/__scatter__.m
+++ b/scripts/plot/private/__scatter__.m
@@ -237,17 +237,17 @@ function hg = __scatter__ (varargin)
     endif
   endif
   addlistener (hg, "linewidth", @update_props);
   addlistener (hg, "marker", @update_props);
   addlistener (hg, "markerfacecolor", @update_props);
   addlistener (hg, "markeredgecolor", @update_props);
 
   if (! isempty (newargs))
-    set (hg, newargs{:})
+    set (hg, newargs{:});
   endif
 
 endfunction
 
 function [y, idx] =  unique_idx (x, byrows)
   if (nargin == 2)
     [xx, idx] = sortrows (x);
     n = rows (x);
@@ -325,17 +325,17 @@ function update_props (h, d)
   lw = get (h, "linewidth");
   m = get (h, "marker");
   fc = get (h, "markerfacecolor");
   ec = get (h, "markeredgecolor");
   kids = get (h, "children");
 
   for i = 1 : numel (kids)
     set (kids (i), "linewidth", lw, "marker", m, "markerfacecolor", fc,
-         "edgecolor", ec)
+         "edgecolor", ec);
   endfor
 endfunction
 
 function update_data (h, d)
   x1 = get (h, "xdata");
   y1 = get (h, "ydata");
   z1 = get (h, "zdata");
   c1 = get (h, "cdata");
diff --git a/scripts/plot/private/__stem__.m b/scripts/plot/private/__stem__.m
--- a/scripts/plot/private/__stem__.m
+++ b/scripts/plot/private/__stem__.m
@@ -546,12 +546,12 @@ function update_data (h, d)
       zt = [bl * ones(1, nx); z; NaN(1, nx)](:);
     else
       y = y(:)';
       yt = [bl * ones(1, nx); y; NaN(1, nx)](:);
       zt = [];
     endif
 
     kids = get (h, "children");
-    set (kids(2), "xdata", xt, "ydata", yt, "zdata", zt)
-    set (kids(1), "xdata", x, "ydata", y, "zdata", z)
+    set (kids(2), "xdata", xt, "ydata", yt, "zdata", zt);
+    set (kids(1), "xdata", x, "ydata", y, "zdata", z);
   endif
 endfunction
diff --git a/scripts/plot/private/__tight_eps_bbox__.m b/scripts/plot/private/__tight_eps_bbox__.m
--- a/scripts/plot/private/__tight_eps_bbox__.m
+++ b/scripts/plot/private/__tight_eps_bbox__.m
@@ -30,30 +30,30 @@ function bb = __tight_eps_bbox__ (opts, 
 
   cmd = sprintf ("\"%s\" \"%s\" 2>&1", "head", eps_file_name);
   [status, output] = system (cmd);
 
   if (status == 0)
     orig_bbox_line = get_bbox (output);
   else
     error ("print:noboundingbox",
-           "print.m: no bounding box found in '%s'", eps_file_name)
+           "print.m: no bounding box found in '%s'", eps_file_name);
   endif
 
   ghostscript_options = "-q -dBATCH -dSAFER -dNOPAUSE -dTextAlphaBits=4 -sDEVICE=bbox";
   cmd = sprintf ("\"%s\" %s \"%s\" 2>&1", opts.ghostscript.binary,
                  ghostscript_options, eps_file_name);
   [status, output] = system (cmd);
 
   if (status == 0)
     tight_bbox_line = get_bbox (output);
   else
     warning ("print:nogsboundingbox",
              "print.m: ghostscript failed to determine the bounding for '%s'",
-             eps_file_name)
+             eps_file_name);
   endif
 
   ## Attempt to fix the bbox in place.
   fid = fopen (eps_file_name, "r+");
   unwind_protect
     bbox_replaced = false;
     looking_for_bbox = true;
     while (looking_for_bbox)
@@ -91,17 +91,17 @@ function bb = __tight_eps_bbox__ (opts, 
       fclose (fid);
     end_unwind_protect
     n = strfind (data, box_string);
     if (numel (n) > 1)
       ## Only replace one instance.
       n = n(1);
     elseif (isempty (n))
       error ("print:noboundingbox", ...
-             "print.m: no bounding box found in '%s'.", eps_file_name)
+             "print.m: no bounding box found in '%s'.", eps_file_name);
     endif
     m = numel (orig_bbox_line);
     data = horzcat (data(1:(n-1)), tight_bbox_line, data((n+m):end));
     fid = fopen (eps_file_name, "w");
     unwind_protect
       fprintf (fid, "%s", data);
     unwind_protect_cleanup
       fclose (fid);
diff --git a/scripts/plot/refresh.m b/scripts/plot/refresh.m
--- a/scripts/plot/refresh.m
+++ b/scripts/plot/refresh.m
@@ -32,11 +32,11 @@ function refresh (h)
       error ("refresh: expecting argument to be a valid figure handle");
     endif
   elseif (nargin > 1)
     print_usage ();
   else
     h = gcf ();
   endif
 
-  set(h,"__modified__", "on")
+  set(h,"__modified__", "on");
   drawnow ();
 endfunction
diff --git a/scripts/plot/spinmap.m b/scripts/plot/spinmap.m
--- a/scripts/plot/spinmap.m
+++ b/scripts/plot/spinmap.m
@@ -41,17 +41,17 @@ function spinmap (t, inc)
   cmap = get (gcf (), "colormap");
   clen = rows (cmap);
 
   t0 = clock;
 
   while (etime (clock, t0) < t)
     for n = 1:inc:clen
       newmap = shift (cmap, n, 1);
-      set (gcf (), "colormap", newmap)
+      set (gcf (), "colormap", newmap);
       drawnow ();
     endfor
   endwhile
 
-  set (gcf (), "colormap", cmap)
+  set (gcf (), "colormap", cmap);
 
 endfunction
 
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -90,34 +90,34 @@ function h = subplot (rows, cols, index,
     tmp = (tmp - index) / 10;
     cols = rem (tmp, 10);
     tmp = (tmp - cols) / 10;
     rows = rem (tmp, 10);
 
   elseif (! (isscalar (cols) && isscalar (rows)))
     error ("subplot: COLS, and ROWS must be scalars");
   elseif (any (index < 1) || any (index > rows*cols))
-    error ("subplot: INDEX value must be greater than 1 and less than ROWS*COLS")
+    error ("subplot: INDEX value must be greater than 1 and less than ROWS*COLS");
   endif
 
   cols = round (cols);
   rows = round (rows);
   index = round (index);
 
   if (index > cols*rows)
     error ("subplot: INDEX must be less than COLS*ROWS");
   endif
 
   if (cols < 1 || rows < 1 || index < 1)
     error ("subplot: COLS,ROWS,INDEX must be be positive");
   endif
 
   units = get (0, "defaultaxesunits");
   unwind_protect
-    set (0, "defaultaxesunits", "normalized")
+    set (0, "defaultaxesunits", "normalized");
     pos = subplot_position (rows, cols, index, "position", units);
 
     cf = gcf ();
 
     set (cf, "nextplot", "add");
 
     found = false;
     kids = get (cf, "children");
diff --git a/scripts/plot/surfc.m b/scripts/plot/surfc.m
--- a/scripts/plot/surfc.m
+++ b/scripts/plot/surfc.m
@@ -37,17 +37,17 @@ function h = surfc (varargin)
 
   set (tmp, "facecolor", "flat");
 
   if (! ishold ())
     set (ax, "view", [-37.5, 30],
          "xgrid", "on", "ygrid", "on", "zgrid", "on");
   endif
 
-  drawnow
+  drawnow ();
   zmin = get (ax, "zlim")(1);
 
   [c, tmp2] = __contour__ (ax, zmin, varargin{:});
 
   tmp = [tmp; tmp2];
 
   if (nargout > 0)
     h = tmp;
diff --git a/scripts/plot/uigetfile.m b/scripts/plot/uigetfile.m
--- a/scripts/plot/uigetfile.m
+++ b/scripts/plot/uigetfile.m
@@ -128,23 +128,23 @@ function [retfile, retpath, retindex] = 
 
       for i = stridx : 2 : nargin
         prop = varargin{i};
         val = varargin{i + 1};
         if (strncmp (tolower (prop), "position", 8))
           if (ismatrix (val) && length(val) == 2)
             outargs{4} = val;
           else
-            error ("uigetfile: expecting 2-element vector for position argument")
+            error ("uigetfile: expecting 2-element vector for position argument");
           endif
         elseif (strncmp (tolower (prop), "multiselect", 11))
           if (ischar (val))
             outargs{5} = tolower (val);
           else
-            error ("uigetfile: expecting string argument (on/off) for multiselect")
+            error ("uigetfile: expecting string argument (on/off) for multiselect");
           endif
         else
           error ("uigetfile: unknown argument");
         endif
       endfor
     endif
   else
     error ("uigetfile: number of input arguments must be less than eight");
diff --git a/scripts/polynomial/polyout.m b/scripts/polynomial/polyout.m
--- a/scripts/polynomial/polyout.m
+++ b/scripts/polynomial/polyout.m
@@ -74,17 +74,17 @@ function y = polyout (c, x)
       tmp = sprintf ("%s*%s^%d%s%s", tmp, x, n1-ii, ns, coeff (c(ii)));
 
     endfor
   else
     tmp = " ";
   endif
 
   if(nargout == 0)
-    disp (tmp)
+    disp (tmp);
   else
     y = tmp;
   endif
 
 endfunction
 
 function str = coeff (c)
   if (imag (c))
diff --git a/scripts/sparse/spaugment.m b/scripts/sparse/spaugment.m
--- a/scripts/sparse/spaugment.m
+++ b/scripts/sparse/spaugment.m
@@ -73,17 +73,17 @@
 ## @end deftypefn
 
 function s = spaugment (A, c)
   if (nargin < 2)
     if (issparse (A))
       c = max (max (abs (A))) / 1000;
     else
       if (ndims (A) != 2)
-        error ("spaugment: expecting 2-dimenisional matrix")
+        error ("spaugment: expecting 2-dimenisional matrix");
       else
         c = max (abs (A(:))) / 1000;
       endif
     endif
   elseif (!isscalar (c))
     error ("spaugment: C must be a scalar");
   endif
 
diff --git a/scripts/sparse/svds.m b/scripts/sparse/svds.m
--- a/scripts/sparse/svds.m
+++ b/scripts/sparse/svds.m
@@ -94,17 +94,17 @@ function [u, s, v, flag] = svds (A, k, s
 
   persistent root2 = sqrt (2);
 
   if (nargin < 1 || nargin > 4)
     print_usage ();
   endif
 
   if (ndims(A) > 2)
-    error ("svds: A must be a 2D matrix")
+    error ("svds: A must be a 2D matrix");
   endif
 
   if (nargin < 4)
     opts.tol = 1e-10 / root2;
     opts.disp = 0;
     opts.maxit = 300;
   else
     if (!isstruct (opts))
diff --git a/scripts/sparse/treeplot.m b/scripts/sparse/treeplot.m
--- a/scripts/sparse/treeplot.m
+++ b/scripts/sparse/treeplot.m
@@ -185,17 +185,17 @@ function treeplot (tree, node_s, edge_s)
           ## Tree component start.
           istart = idx(i-1) + 1;
           ## Tree component end.
           istop = idx(i) - 1;
           if (istop - istart < 1)
             continue;
           endif
           plot (x_coordinate(skelet(istart:istop)),
-                y_coordinate(skelet(istart:istop)), edge_style)
+                y_coordinate(skelet(istart:istop)), edge_style);
         endfor
 
         ## Set axis and graph size.
         axis ([0.5, left_most+0.5, max_ht-0.5, num_nodes-0.5], "nolabel");
 
       unwind_protect_cleanup
         if (! hold_is_on)
           hold ("off");
diff --git a/scripts/statistics/base/histc.m b/scripts/statistics/base/histc.m
--- a/scripts/statistics/base/histc.m
+++ b/scripts/statistics/base/histc.m
@@ -49,17 +49,17 @@ function [n, idx] = histc (x, edges, dim
   endif
 
   if (!isreal (x))
     error ("histc: X argument must be real-valued, not complex");
   endif
 
   num_edges = numel (edges);
   if (num_edges == 0)
-    error ("histc: EDGES must not be empty")
+    error ("histc: EDGES must not be empty");
   endif
 
   if (!isreal (edges))
     error ("histc: EDGES must be real-valued, not complex");
   else
     ## Make sure 'edges' is sorted
     edges = edges (:);
     if (!issorted (edges) || edges(1) > edges(end))
diff --git a/scripts/statistics/distributions/hygecdf.m b/scripts/statistics/distributions/hygecdf.m
--- a/scripts/statistics/distributions/hygecdf.m
+++ b/scripts/statistics/distributions/hygecdf.m
@@ -39,14 +39,14 @@ function cdf = hygecdf (x, t, m, n)
   endif
 
   if (!isscalar (t) || !isscalar (m) || !isscalar (n))
     error ("hygecdf: T, M and N must all be positive integers");
   endif
 
   if (t < 0 || m < 0 || n <= 0 || t != round (t) || m != round (m)
       || n != round (n) || m > t || n > t)
-    cdf = NaN (size (x))
+    cdf = NaN (size (x));
   else
     cdf = discrete_cdf (x, 0 : n, hygepdf (0 : n, t, m, n));
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/hygeinv.m b/scripts/statistics/distributions/hygeinv.m
--- a/scripts/statistics/distributions/hygeinv.m
+++ b/scripts/statistics/distributions/hygeinv.m
@@ -36,14 +36,14 @@ function inv = hygeinv (x, t, m, n)
   endif
 
   if (!isscalar (t) || !isscalar (m) || !isscalar (n))
     error ("hygeinv: T, M and N must all be positive integers");
   endif
 
   if (t < 0 || m < 0 || n <= 0 || t != round (t) || m != round (m)
       || n != round (n) || m > t || n > t)
-    inv = NaN (size (x))
+    inv = NaN (size (x));
   else
     inv = discrete_inv (x, 0 : n, hygepdf (0 : n, t, m, n));
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/manova.m b/scripts/statistics/tests/manova.m
--- a/scripts/statistics/tests/manova.m
+++ b/scripts/statistics/tests/manova.m
@@ -89,29 +89,29 @@ function manova (x, g)
     l (l < eps) = 0;
   endif
 
   ## Wilks' Lambda
   ## =============
 
   Lambda = prod (1 ./ (1 + l));
 
-  delta = n_w + n_b - (p + n_b + 1) / 2
-  df_num = p * n_b
+  delta = n_w + n_b - (p + n_b + 1) / 2;
+  df_num = p * n_b;
   W_pval_1 = 1 - chi2cdf (- delta * log (Lambda), df_num);
 
   if (p < 3)
     eta = p;
   else
-    eta = sqrt ((p^2 * n_b^2 - 4) / (p^2 + n_b^2 - 5))
+    eta = sqrt ((p^2 * n_b^2 - 4) / (p^2 + n_b^2 - 5));
   endif
 
-  df_den = delta * eta - df_num / 2 + 1
+  df_den = delta * eta - df_num / 2 + 1;
 
-  WT = exp (- log (Lambda) / eta) - 1
+  WT = exp (- log (Lambda) / eta) - 1;
   W_pval_2 = 1 - f_cdf (WT * df_den / df_num, df_num, df_den);
 
   if (0)
 
     ## Hotelling-Lawley Test
     ## =====================
 
     HL = sum (l);
diff --git a/scripts/strings/deblank.m b/scripts/strings/deblank.m
--- a/scripts/strings/deblank.m
+++ b/scripts/strings/deblank.m
@@ -36,17 +36,17 @@ function s = deblank (s)
   char_arg = ischar (s);
 
   if (char_arg || isnumeric (s))
 
     if (! isempty (s))
       if (char_arg)
         k = find (! isspace (s) & s != "\0");
       else
-        warning ("deblank: expecting character string argument")
+        warning ("deblank: expecting character string argument");
         k = find (s != 0);
       endif
 
       if (isempty (k))
         s = resize (s, 0, 0);
       else
         s = s(:,1:ceil (max (k) / rows (s)));
       endif
diff --git a/scripts/testfun/runtests.m b/scripts/testfun/runtests.m
--- a/scripts/testfun/runtests.m
+++ b/scripts/testfun/runtests.m
@@ -57,17 +57,17 @@ function run_all_tests (directory)
   fflush (stdout);
   for i = 1:numel (flist)
     f = flist{i};
     if (length (f) > 2 && strcmp (f((end-1):end), ".m"))
       ff = fullfile (directory, f);
       if (has_tests (ff))
         print_test_file_name (f);
         [p, n, xf, sk] = test (ff, "quiet");
-        print_pass_fail (n, p)
+        print_pass_fail (n, p);
         fflush (stdout);
       else
         no_tests{end+1} = f;
       endif
     endif
   endfor
   if (! isempty (no_tests))
     printf ("\nThe following files in %s have no tests:\n\n", directory);
