# HG changeset patch
# User jwe
# Date 886668307 0
#      Thu Feb 05 08:45:07 1998 +0000
# Node ID 0d640dc625c77f89dc7fe032314dbc0fb9332731
# Parent  fb9924282a3e87d0aa63527af78b43fe4b20b601
[project @ 1998-02-05 08:44:59 by jwe]

diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,33 @@
+Thu Feb  5 02:12:38 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* dir-ops.h (dir_entry::operator bool ()): Return bool, not void*.
+	* file-stat.h (file_stat::operator bool ()): Likewise.
+	* idx-vector.h (idx_vector::operator bool ()): Likewise.
+	* oct-group.h (octave_group::operator bool ()): Likewise.
+	* oct-passwd.h (octave_passwd::operator bool ()): Likewise.
+
+	* data-conv.cc (IEEE_little_double_to_IEEE_big_double):
+	Don't cast arg in call to swap_8_bytes.
+	(IEEE_big_double_to_IEEE_little_double): Ditto
+	(IEEE_big_float_to_IEEE_little_float): Don't cast arg in call to
+	swap_4_bytes.
+	(IEEE_little_float_to_IEEE_big_float): Ditto
+
+	* oct-alloc.cc (grow): Use X_CAST, not static_cast.
+	* prog-args.cc (prog_args::getopt): Likewise.
+	* dMatrix.cc (read_int, do_read, write_int, do_write): Likewise.
+	* cmd-edit.cc (gnu_readline::do_set_completion_function): Likewise.
+	* data-conv.cc (LS_DO_READ, LS_DO_WRITE, read_doubles, write_doubles):
+	Likewise.
+
+	* byte-swap.h (swap_bytes, swap_2_bytes, swap_4_bytes,
+	swap_8_bytes): Declare ptr arg as void*, then use cast.
+
 Mon Feb  2 01:42:56 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Makefile.in (install, uninstall): Use $(octlibdir), not $(libdir).
 	Use $(mk-libdir-link).
 
 	* file-stat.cc (file_stat::update_internal): Use stat and lstat,
 	not SAFE_STAT and SAFE_LSTAT.
 	(lstat): New function, defined if HAVE_LSTAT is not defined.
diff --git a/liboctave/byte-swap.h b/liboctave/byte-swap.h
--- a/liboctave/byte-swap.h
+++ b/liboctave/byte-swap.h
@@ -19,75 +19,86 @@ along with Octave; see the file COPYING.
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #if !defined (octave_byte_swap_h)
 #define octave_byte_swap_h 1
 
 static inline void
-swap_bytes (char *t, unsigned int i, unsigned int j)
+swap_bytes (void *ptr, unsigned int i, unsigned int j)
 {
+  char *t = static_cast<char *> (ptr);
+
   char tmp = t[i];
   t[i] = t[j];
   t[j] = tmp;
 }
 
 static inline void
-swap_2_bytes (char *t)
+swap_2_bytes (void *ptr)
 {
+  char *t = static_cast<char *> (ptr);
+
   swap_bytes (t, 0, 1);
 }
 
 static inline void
-swap_4_bytes (char *t)
+swap_4_bytes (void *ptr)
 {
+  char *t = static_cast<char *> (ptr);
+
   swap_bytes (t, 0, 3);
   swap_bytes (t, 1, 2);
 }
 
 static inline void
-swap_8_bytes (char *t)
+swap_8_bytes (void *ptr)
 {
+  char *t = static_cast<char *> (ptr);
+
   swap_bytes (t, 0, 7);
   swap_bytes (t, 1, 6);
   swap_bytes (t, 2, 5);
   swap_bytes (t, 3, 4);
 }
 
 static inline void
-swap_2_bytes (char *t, int len)
+swap_2_bytes (void *ptr, int len)
 {
-  char *ptr = t;
+  char *t = static_cast<char *> (ptr);
+
   for (int i = 0; i < len; i++)
     {
-      swap_2_bytes (ptr);
-      ptr += 2;
+      swap_2_bytes (t);
+      t += 2;
     }
 }
 
 static inline void
-swap_4_bytes (char *t, int len)
+swap_4_bytes (void *ptr, int len)
 {
-  char *ptr = t;
+  char *t = static_cast<char *> (ptr);
+
   for (int i = 0; i < len; i++)
     {
-      swap_4_bytes (ptr);
-      ptr += 4;
+      swap_4_bytes (t);
+      t += 4;
     }
 }
 
 static inline void
-swap_8_bytes (char *t, int len)
+swap_8_bytes (void *ptr, int len)
 {
-  char *ptr = t;
+  char *t = static_cast<char *> (ptr);
+
   for (int i = 0; i < len; i++)
     {
-      swap_8_bytes (ptr);
-      ptr += 8;
+      swap_8_bytes (t);
+      t += 8;
     }
 }
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/cmd-edit.cc b/liboctave/cmd-edit.cc
--- a/liboctave/cmd-edit.cc
+++ b/liboctave/cmd-edit.cc
@@ -272,17 +272,17 @@ void
 gnu_readline::do_set_completion_function (completion_fcn f)
 {
   completion_function = f;
 
   typedef char** (*foo) (...);
 
   rl_attempted_completion_function
     = completion_function
-    ? static_cast<foo> (gnu_readline::command_completer) : 0;
+    ? reinterpret_cast<foo> (gnu_readline::command_completer) : 0;
 }
 
 gnu_readline::completion_fcn
 gnu_readline::do_get_completion_function (void) const
 {
   return completion_function;
 }
 
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -2372,35 +2372,35 @@ operator >> (istream& is, Matrix& a)
 
   return is;
 }
 
 template <class T>
 static void
 read_int (istream& is, bool swap_bytes, T& val)
 {
-  is.read (static_cast<char *> (&val), sizeof (T));
+  is.read (X_CAST (char *, &val), sizeof (T));
 
   if (swap_bytes)
     {
       switch (sizeof (T))
 	{
 	case 1:
 	  break;
 
 	case 2:
-	  swap_2_bytes (static_cast<char *> (&val));
+	  swap_2_bytes (X_CAST (char *, &val));
 	  break;
 
 	case 4:
-	  swap_4_bytes (static_cast<char *> (&val));
+	  swap_4_bytes (X_CAST (char *, &val));
 	  break;
 
 	case 8:
-	  swap_8_bytes (static_cast<char *> (&val));
+	  swap_8_bytes (X_CAST (char *, &val));
 	  break;
 
 	default:
 	  (*current_liboctave_error_handler)
 	    ("read_int: unrecognized data format!");
 	}
     }
 }
@@ -2495,28 +2495,28 @@ do_read (istream& is, oct_data_conv::dat
 	val = tmp;
       }
       break;
 
     case oct_data_conv::dt_float:
       {
 	float f;
 
-	is.read (static_cast<char *> (&f), sizeof (float));
+	is.read (X_CAST (char *, &f), sizeof (float));
 
 	if (do_float_conversion)
 	  do_float_format_conversion (&f, 1, flt_fmt);
 
 	val = f;
       }
       break;
 
     case oct_data_conv::dt_double:
       {
-	is.read (static_cast<char *> (&val), sizeof (double));
+	is.read (X_CAST (char *, &val), sizeof (double));
 
 	if (do_float_conversion)
 	  do_double_format_conversion (&val, 1, flt_fmt);
       }
       break;
 
     default:
       retval = false;
@@ -2686,34 +2686,34 @@ write_int (ostream& os, bool swap_bytes,
   if (swap_bytes)
     {
       switch (sizeof (T))
 	{
 	case 1:
 	  break;
 
 	case 2:
-	  swap_2_bytes (static_cast<char *> (&val));
+	  swap_2_bytes (X_CAST (char *, &val));
 	  break;
 
 	case 4:
-	  swap_4_bytes (static_cast<char *> (&val));
+	  swap_4_bytes (X_CAST (char *, &val));
 	  break;
 
 	case 8:
-	  swap_8_bytes (static_cast<char *> (&val));
+	  swap_8_bytes (X_CAST (char *, &val));
 	  break;
 
 	default:
 	  (*current_liboctave_error_handler)
 	    ("write_int: unrecognized data format!");
 	}
     }
 
-  os.write (static_cast<char *> (&val), sizeof (T));
+  os.write (X_CAST (char *, &val), sizeof (T));
 }
 
 template void write_int (ostream&, bool, char);
 template void write_int (ostream&, bool, signed char);
 template void write_int (ostream&, bool, unsigned char);
 template void write_int (ostream&, bool, short);
 template void write_int (ostream&, bool, unsigned short);
 template void write_int (ostream&, bool, int);
@@ -2726,68 +2726,68 @@ do_write (ostream& os, double d, oct_dat
 	  oct_mach_info::float_format flt_fmt, bool swap_bytes,
 	  bool do_float_conversion)
 {
   bool retval = true;
 
   switch (dt)
     {
     case oct_data_conv::dt_char:
-      write_int (os, swap_bytes, static_cast<char> (d));
+      write_int (os, swap_bytes, X_CAST (char, d));
       break;
 
     case oct_data_conv::dt_schar:
-      write_int (os, swap_bytes, static_cast<signed char> (d));
+      write_int (os, swap_bytes, X_CAST (signed char, d));
       break;
 
     case oct_data_conv::dt_uchar:
-      write_int (os, swap_bytes, static_cast<unsigned char> (d));
+      write_int (os, swap_bytes, X_CAST (unsigned char, d));
       break;
 
     case oct_data_conv::dt_short:
-      write_int (os, swap_bytes, static_cast<short> (d));
+      write_int (os, swap_bytes, X_CAST (short, d));
       break;
 
     case oct_data_conv::dt_ushort:
-      write_int (os, swap_bytes, static_cast<unsigned short> (d));
+      write_int (os, swap_bytes, X_CAST (unsigned short, d));
       break;
 
     case oct_data_conv::dt_int:
-      write_int (os, swap_bytes, static_cast<int> (d));
+      write_int (os, swap_bytes, X_CAST (int, d));
       break;
 
     case oct_data_conv::dt_uint:
-      write_int (os, swap_bytes, static_cast<unsigned int> (d));
+      write_int (os, swap_bytes, X_CAST (unsigned int, d));
       break;
 
     case oct_data_conv::dt_long:
-      write_int (os, swap_bytes, static_cast<long> (d));
+      write_int (os, swap_bytes, X_CAST (long, d));
       break;
 
     case oct_data_conv::dt_ulong:
-      write_int (os, swap_bytes, static_cast<unsigned long> (d));
+      write_int (os, swap_bytes, X_CAST (unsigned long, d));
       break;
 
     case oct_data_conv::dt_float:
       {
 	float f = d;
 
 	if (do_float_conversion)
 	  do_float_format_conversion (&f, 1, flt_fmt);
 
-	os.write (static_cast<char *> (&f), sizeof (float));
+	os.write (X_CAST (char *, &f), sizeof (float));
       }
       break;
 
     case oct_data_conv::dt_double:
       {
 	if (do_float_conversion)
 	  do_double_format_conversion (&d, 1, flt_fmt);
 
-	os.write (static_cast<char *> (&d), sizeof (double));
+	os.write (X_CAST (char *, &d), sizeof (double));
       }
       break;
 
     default:
       retval = false;
       (*current_liboctave_error_handler)
 	("write: invalid type specification");
       break;
diff --git a/liboctave/data-conv.cc b/liboctave/data-conv.cc
--- a/liboctave/data-conv.cc
+++ b/liboctave/data-conv.cc
@@ -101,20 +101,20 @@ oct_data_conv::string_to_data_type (cons
   return retval;
 }
 
 #define swap_1_bytes(x, y)
 
 #define LS_DO_READ(TYPE,swap,data,size,len,stream) \
   do \
     { \
-      volatile TYPE *ptr = (TYPE *) data; \
-      stream.read ((TYPE *) ptr, size * len); \
+      volatile TYPE *ptr = X_CAST (volatile TYPE *, data); \
+      stream.read (X_CAST (TYPE *, ptr), size * len); \
       if (swap) \
-        swap_ ## size ## _bytes (static_cast<char *> (ptr), len); \
+        swap_ ## size ## _bytes (ptr, len); \
       TYPE tmp = ptr[0]; \
       for (int i = len - 1; i > 0; i--) \
         data[i] = ptr[i]; \
       data[0] = tmp; \
     } \
   while (0)
 
 // Have to use copy here to avoid writing over data accessed via
@@ -122,18 +122,18 @@ oct_data_conv::string_to_data_type (cons
 
 #define LS_DO_WRITE(TYPE,data,size,len,stream) \
   do \
     { \
       char tmp_type = static_cast<char> (type); \
       stream.write (&tmp_type, 1); \
       TYPE *ptr = new TYPE [len]; \
       for (int i = 0; i < len; i++) \
-        ptr[i] = (TYPE) data[i]; \
-      stream.write ((TYPE *) ptr, size * len); \
+        ptr[i] = X_CAST (TYPE, data[i]); \
+      stream.write (ptr, size * len); \
       delete [] ptr ; \
     } \
   while (0)
 
 // Loading variables from files.
 
 static void
 gripe_unrecognized_float_fmt (void)
@@ -156,17 +156,17 @@ gripe_data_conversion (const char *from,
 
 // XXX FIXME XXX -- assumes sizeof (Complex) == 8
 // XXX FIXME XXX -- assumes sizeof (double) == 8
 // XXX FIXME XXX -- assumes sizeof (float) == 4
 
 static void
 IEEE_big_double_to_IEEE_little_double (double *d, int len)
 {
-  swap_8_bytes (static_cast<char *> (d), len);
+  swap_8_bytes (d, len);
 }
 
 static void
 VAX_D_double_to_IEEE_little_double (double * /* d */, int /* len */)
 {
   gripe_data_conversion ("VAX D float", "IEEE little endian format");
 }
 
@@ -180,17 +180,17 @@ static void
 Cray_to_IEEE_little_double (double * /* d */, int /* len */)
 {
   gripe_data_conversion ("Cray", "IEEE little endian format");
 }
 
 static void
 IEEE_big_float_to_IEEE_little_float (float *d, int len)
 {
-  swap_4_bytes (static_cast<char *> (d), len);
+  swap_4_bytes (d, len);
 }
 
 static void
 VAX_D_float_to_IEEE_little_float (float * /* d */, int /* len */)
 {
   gripe_data_conversion ("VAX D float", "IEEE little endian format");
 }
 
@@ -204,17 +204,17 @@ static void
 Cray_to_IEEE_little_float (float * /* d */, int /* len */)
 {
   gripe_data_conversion ("Cray", "IEEE little endian format");
 }
 
 static void
 IEEE_little_double_to_IEEE_big_double (double *d, int len)
 {
-  swap_8_bytes (static_cast<char *> (d), len);
+  swap_8_bytes (d, len);
 }
 
 static void
 VAX_D_double_to_IEEE_big_double (double * /* d */, int /* len */)
 {
   gripe_data_conversion ("VAX D float", "IEEE big endian format");
 }
 
@@ -228,17 +228,17 @@ static void
 Cray_to_IEEE_big_double (double * /* d */, int /* len */)
 {
   gripe_data_conversion ("Cray", "IEEE big endian format");
 }
 
 static void
 IEEE_little_float_to_IEEE_big_float (float *d, int len)
 {
-  swap_4_bytes (static_cast<char *> (d), len);
+  swap_4_bytes (d, len);
 }
 
 static void
 VAX_D_float_to_IEEE_big_float (float * /* d */, int /* len */)
 {
   gripe_data_conversion ("VAX D float", "IEEE big endian format");
 }
 
@@ -629,19 +629,19 @@ read_doubles (istream& is, double *data,
       break;
 
     case LS_INT:
       LS_DO_READ (FOUR_BYTE_INT, swap, data, 4, len, is);
       break;
 
     case LS_FLOAT:
       {
-	volatile float *ptr = static_cast<float *> (data);
+	volatile float *ptr = X_CAST (float *, data);
 	is.read (data, 4 * len);
-	do_float_format_conversion (static_cast<float *> (data), len, fmt);
+	do_float_format_conversion (X_CAST (float *, data), len, fmt);
 	float tmp = ptr[0];
 	for (int i = len - 1; i > 0; i--)
 	  data[i] = ptr[i];
 	data[0] = tmp;
       }
       break;
 
     case LS_DOUBLE:
@@ -685,17 +685,17 @@ write_doubles (ostream& os, const double
       break;
 
     case LS_FLOAT:
       LS_DO_WRITE (float, data, 4, len, os);
       break;
 
     case LS_DOUBLE:
       {
-	char tmp_type = static_cast<char> (type);
+	char tmp_type = X_CAST (char, type);
 	os.write (&tmp_type, 1);
 	os.write (data, 8 * len);
       }
       break;
 
     default:
       (*current_liboctave_error_handler)
 	("unrecognized data format requested");
diff --git a/liboctave/dir-ops.h b/liboctave/dir-ops.h
--- a/liboctave/dir-ops.h
+++ b/liboctave/dir-ops.h
@@ -53,17 +53,17 @@ public:
   bool open (const string& = string ());
 
   string_vector read (void);
 
   void close (void);
 
   bool ok (void) const { return dir && ! fail; }
 
-  operator void* () const { return ok () ? (void *) -1 : (void *) 0; }
+  operator bool () const { return ok (); }
 
   string error (void) const { return ok () ? string () : errmsg; }
 
 private:
 
   // Name of the directory.
   string name;
 
diff --git a/liboctave/file-stat.h b/liboctave/file-stat.h
--- a/liboctave/file-stat.h
+++ b/liboctave/file-stat.h
@@ -107,19 +107,17 @@ public:
 #if defined (HAVE_ST_BLOCKS)
   long blocks (void) const { return fs_blocks; }
 #endif
 
   string mode_as_string (void) const;
 
   bool ok (void) const { return initialized && ! fail; }
 
-  operator void* () const
-    { return ok ()
-	? static_cast<void *> (-1) : static_cast<void *> (0); }
+  operator bool () const { return ok (); }
 
   bool exists (void) const { return ok (); }
 
   string error (void) const { return ok () ? string () : errmsg; }
 
   // Has the file referenced by this object been modified since TIME?
   bool is_newer (time_t time) const { return fs_mtime > time; }
 
diff --git a/liboctave/idx-vector.h b/liboctave/idx-vector.h
--- a/liboctave/idx-vector.h
+++ b/liboctave/idx-vector.h
@@ -207,18 +207,17 @@ public:
 	    delete rep;
 
 	  rep = a.rep;
 	  rep->count++;
 	}
       return *this;
     }
 
-  operator void * () const
-    { return static_cast<void *> (rep->ok ()); }
+  operator bool () const { return rep->ok (); }
 
   int capacity (void) const { return rep->capacity (); }
   int length (int cl) const { return rep->length (cl); }
 
   int elem (int n) const { return rep->elem (n); }
   int checkelem (int n) const { return rep->checkelem (n); }
   int operator () (int n) const { return rep->operator () (n); }
 
diff --git a/liboctave/oct-alloc.cc b/liboctave/oct-alloc.cc
--- a/liboctave/oct-alloc.cc
+++ b/liboctave/oct-alloc.cc
@@ -74,23 +74,23 @@ octave_allocator::grow (void)
   if (start)
     {
       char *last = &start[(grow_size - 1) * item_size];
 
       char *p = start;
       while (p < last)
 	{
 	  char *next = p + item_size;
-	  (static_cast<link *> (p)) -> next = static_cast<link *> (next);
+	  (X_CAST (link *, p)) -> next = X_CAST (link *, next);
 	  p = next;
 	}
 
-      (static_cast<link *> (last)) -> next = 0;
+      (X_CAST (link *, last)) -> next = 0;
 
-      head = static_cast<link *> (start);
+      head = X_CAST (link *, start);
     }
   else
     {
       typedef void (*error_handler_function) (void);
 
       error_handler_function f = set_new_handler (0);
       set_new_handler (f);
 
diff --git a/liboctave/oct-group.h b/liboctave/oct-group.h
--- a/liboctave/oct-group.h
+++ b/liboctave/oct-group.h
@@ -64,19 +64,17 @@ public:
   string passwd (void) const;
 
   gid_t gid (void) const;
 
   string_vector mem (void) const;
 
   bool ok (void) const { return valid; }
 
-  operator void* () const
-    { return ok ()
-	? static_cast<void *> (-1) : static_cast<void *> (0); }
+  operator bool () const { return ok (); }
 
   static octave_group getgrent (void);
   static octave_group getgrent (string& msg);
 
   static octave_group getgrgid (gid_t gid);
   static octave_group getgrgid (gid_t gid, string& msg);
 
   static octave_group getgrnam (const string& nm);
diff --git a/liboctave/oct-passwd.h b/liboctave/oct-passwd.h
--- a/liboctave/oct-passwd.h
+++ b/liboctave/oct-passwd.h
@@ -75,19 +75,17 @@ public:
   string gecos (void) const;
 
   string dir (void) const;
 
   string shell (void) const;
 
   bool ok (void) const { return valid; }
 
-  operator void* () const
-    { return ok ()
-	? static_cast<void *> (-1) : static_cast<void *> (0); }
+  operator bool () const { return ok (); }
 
   static octave_passwd getpwent (void);
   static octave_passwd getpwent (string& msg);
 
   static octave_passwd getpwuid (uid_t uid);
   static octave_passwd getpwuid (uid_t uid, string& msg);
 
   static octave_passwd getpwnam (const string& nm);
diff --git a/liboctave/prog-args.cc b/liboctave/prog-args.cc
--- a/liboctave/prog-args.cc
+++ b/liboctave/prog-args.cc
@@ -28,17 +28,17 @@ Software Foundation, 59 Temple Place - S
 
 #include "prog-args.h"
 
 int
 prog_args::getopt (void)
 {
   if (long_opts)
     return ::getopt_long (xargc, xargv, short_opts,
-			  static_cast<const struct option *> (long_opts), 0);
+			  X_CAST (const struct option *, long_opts), 0);
   else
     return ::getopt (xargc, xargv, short_opts);
 }
 
 const char *
 prog_args::optarg (void)
 {
   return ::optarg;
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,52 @@
+Thu Feb  5 02:27:18 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* ov-bool-mat.cc: Only declare assign function if
+	CXX_NEW_FRIEND_TEMPLATE_DECL is not defined.
+
+	* ov-base.h, ov-bool-mat.h, ov-bool.h, ov-ch-mat.h, ov-complex.h,
+	ov-cx-mat.h, ov-range.h, ov-re-mat.h, ov-scalar.h: Handle default
+	args for *_value functions consistently.
+
+	* symtab.cc (maybe_list_cmp_fcn): Declare args as void*, not
+	void**, then use X_CAST.
+
+	* OPERATORS/op-s-cm.cc: Include mx-cm-s.h.
+
+	* defun-int.h: Include ov-builtin.h, ov-mapper.h, and symtab.h.
+	(install_builtin_mapper, install_builtin_function,
+	install_builtin_variable) Use specific types rather than void * in
+	declaration.
+	* defun.cc (install_builtin_mapper, install_builtin_function,
+	install_builtin_variable): Likewise.  Eliminate casts.
+
+	* load-save.cc (read_binary_data, read_mat_file_header,
+	save_binary_data): Use X_CAST, not static_cast.
+	* unwind-prot.h (unwind_protect::save_ptr): Likewise.
+	* Map.cc (goodCHptr, index_to_CHptr, CHptr_to_index): Likewise.
+	* dynamic-ld.cc (octave_dlopen_dynamic_loder::resolve_reference):
+	Likewise.
+
+	* pt-mat.cc (tm_const::operator bool ()): 
+	(tm_row_const::operator bool ()): Likewise.
+	* oct-stream.cc (printf_value_cache::operator bool ()): Likewise.
+	(scanf_format_list::operator bool ()): Likewise.
+	(printf_format_list::operator bool ()): Likewise.
+	(octave_stream::operator bool ()): Likewise.
+
+Wed Feb  4 13:08:29 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* DLD-FUNCTIONS/minmax.cc: Include cmath, not oct-math.h.
+
+	* syscalls.cc (Fdup2): Convert stream to actual system file id.
+
+	* oct-stream.cc (octave_base_stream::fileno, octave_stream::fileno): 
+	New functions.
+
 Tue Feb  3 00:24:44 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* defaults.cc (exec_path): Append Vbin_dir to std_path.
 
 	* octave.cc (initialize_pathsearch): Set TEXMFDBS, not TEXMF.
 	Look for OCTAVE_DB_PATH in environment.
 	Simplify using Vdata_dir and Vlibexec_dir.
 
diff --git a/src/DLD-FUNCTIONS/minmax.cc b/src/DLD-FUNCTIONS/minmax.cc
--- a/src/DLD-FUNCTIONS/minmax.cc
+++ b/src/DLD-FUNCTIONS/minmax.cc
@@ -19,18 +19,19 @@ along with Octave; see the file COPYING.
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include <cmath>
+
 #include "lo-ieee.h"
-#include "oct-math.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 
 #ifndef MAX
 #define MAX(a,b) ((a) > (b) ? (a) : (b))
diff --git a/src/Map.cc b/src/Map.cc
--- a/src/Map.cc
+++ b/src/Map.cc
@@ -111,32 +111,30 @@ Map<C>::error (const string& msg) const
 // The nodes are linked together serially via a version of a trick
 // used in some vtables: odd pointers are actually links to the next
 // table entry.  Not terrible, but not wonderful either.
 
 template <class C>
 static int
 goodCHptr (CHNode<C> *t)
 {
-  return (((static_cast<unsigned> (t)) & 1) == 0);
+  return (((X_CAST (unsigned, t)) & 1) == 0);
 }
 
-// This sucks, but avoids g++ 2.6.0 `type unification failed' errors.
-
 static void *
 index_to_CHptr (int i)
 {
-  return static_cast<void *> ((i << 1) + 1);
+  return X_CAST (void *, (i << 1) + 1);
 }
 
 template <class C>
 static unsigned int
 CHptr_to_index (CHNode<C> *t)
 {
-  return (static_cast<unsigned> (t)) >> 1;
+  return (X_CAST (unsigned, t)) >> 1;
 }
 
 template <class C>
 CHMap<C>::CHMap (const C& dflt, unsigned int sz) : Map<C> (dflt)
 {
   tab = new CHNode<C>* [size = sz];
   for (unsigned int i = 0; i < size; ++i)
     tab[i] = static_cast<CHNode<C> *> (index_to_CHptr (i+1));
diff --git a/src/OPERATORS/op-s-cm.cc b/src/OPERATORS/op-s-cm.cc
--- a/src/OPERATORS/op-s-cm.cc
+++ b/src/OPERATORS/op-s-cm.cc
@@ -24,16 +24,17 @@ Software Foundation, 59 Temple Place - S
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "mx-s-cm.h"
+#include "mx-cm-s.h"
 
 #include "gripes.h"
 #include "ov.h"
 #include "ov-scalar.h"
 #include "ov-cx-mat.h"
 #include "ov-typeinfo.h"
 #include "ops.h"
 #include "xdiv.h"
diff --git a/src/defun-int.h b/src/defun-int.h
--- a/src/defun-int.h
+++ b/src/defun-int.h
@@ -20,37 +20,38 @@ Software Foundation, 59 Temple Place - S
 
 */
 
 #if !defined (octave_defun_int_h)
 #define octave_defun_int_h 1
 
 #include <string>
 
+#include "ov-builtin.h"
+#include "ov-mapper.h"
+#include "symtab.h"
 #include "version.h"
 
 class octave_value;
 
 extern void print_usage (const string& nm, bool just_usage = false);
 
 extern void check_version (const string& version, const string& fcn);
 
-// XXX FIXME XXX -- change to use actual pointer types instead of void*
-// when things are not changing as rapidly.
+extern void
+install_builtin_mapper (octave_mapper *mf);
 
 extern void
-install_builtin_mapper (void *mf);
-
-extern void
-install_builtin_function (void *f, const string& name, const string& doc,
-			  bool is_text_fcn = false);
+install_builtin_function (octave_builtin::fcn f, const string& name,
+			  const string& doc, bool is_text_fcn = false);
 
 extern void
 install_builtin_variable (const string& n, const octave_value& v,
-			  bool iaf, bool p, bool e, void *svf,
+			  bool iaf, bool p, bool e,
+			  symbol_record::change_function chg_fcn,
 			  const string& h);
 
 extern void
 alias_builtin (const string& alias, const string& name);
 
 // MAKE_BUILTINS is defined to extract function names and related
 // information and create the *.def files that are eventually used to
 // create the buitlins.cc file.
diff --git a/src/defun.cc b/src/defun.cc
--- a/src/defun.cc
+++ b/src/defun.cc
@@ -64,38 +64,34 @@ check_version (const string& version, co
   if (version != OCTAVE_VERSION)
     warning ("incompatible version %s found in function `%s'",
 	     version.c_str (), fcn.c_str ());
 }
 
 // Install variables and functions in the symbol tables.
 
 void
-install_builtin_mapper (void *mf_arg)
+install_builtin_mapper (octave_mapper *mf)
 {
-  octave_mapper *mf = static_cast<octave_mapper *> (mf_arg);
-
   symbol_record *sym_rec = global_sym_tab->lookup (mf->name (), true);
 
   unsigned int t
     = symbol_record::BUILTIN_FUNCTION | symbol_record::MAPPER_FUNCTION;
 
   sym_rec->unprotect ();
   sym_rec->define (mf, t);
   sym_rec->document (mf->doc_string ());
   sym_rec->make_eternal ();
   sym_rec->protect ();
 }
 
 void
-install_builtin_function (void *f_arg, const string& name,
+install_builtin_function (octave_builtin::fcn f, const string& name,
 			  const string& doc, bool is_text_fcn)
 {
-  octave_builtin::fcn f = static_cast<octave_builtin::fcn> (f_arg);
-
   symbol_record *sym_rec = global_sym_tab->lookup (name, true);
 
   unsigned int t = symbol_record::BUILTIN_FUNCTION;
 
   if (is_text_fcn)
     t |= symbol_record::TEXT_FUNCTION;
 
   sym_rec->unprotect ();
@@ -124,23 +120,21 @@ install_builtin_variable_as_function (co
     sym_rec->protect ();
 
   if (eternal)
     sym_rec->make_eternal ();
 }
 
 void
 install_builtin_variable (const string& name, const octave_value& value,
-			  bool install_as_function, bool protect,
-			  bool eternal, void *chg_fcn_arg,
+			  bool install_as_function,
+			  bool protect, bool eternal,
+			  symbol_record::change_function chg_fcn,
 			  const string& help_string)
 {
-  symbol_record::change_function chg_fcn
-    = static_cast<symbol_record::change_function> (chg_fcn_arg);
-
   if (install_as_function)
     install_builtin_variable_as_function (name, value, protect,
 					  eternal, help_string);
   else
     bind_builtin_variable (name, value, protect, eternal,
 			   chg_fcn, help_string);
 }
 
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -93,17 +93,17 @@ octave_dlopen_dynamic_loader::resolve_re
   void *handle = dlopen (file.c_str (), RTLD_LAZY);
 
   const char *nm = name.c_str ();
 
   if (handle)
     {
       void *tmp = dlsym (handle, nm);
 
-      retval = static_cast<octave_dynamic_loader::builtin_fcn_installer> (tmp);
+      retval = X_CAST (octave_dynamic_loader::builtin_fcn_installer, tmp);
 
       if (! retval)
 	{
 	  const char *errmsg = dlerror ();
 
 	  if (errmsg)
 	    error("%s: `%s'", nm, errmsg);
 	  else
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -749,28 +749,28 @@ read_binary_data (istream& is, bool swap
 
   // We expect to fail here, at the beginning of a record, so not
   // being able to read another name should not result in an error.
 
   is.read (&name_len, 4);
   if (! is)
     return 0;
   if (swap)
-    swap_4_bytes (static_cast<char *> (&name_len));
+    swap_4_bytes (X_CAST (char *, &name_len));
 
   name = new char [name_len+1];
   name[name_len] = '\0';
   if (! is.read (name, name_len))
     goto data_read_error;
 
   is.read (&doc_len, 4);
   if (! is)
     goto data_read_error;
   if (swap)
-    swap_4_bytes (static_cast<char *> (&doc_len));
+    swap_4_bytes (X_CAST (char *, &doc_len));
 
   doc = new char [doc_len+1];
   doc[doc_len] = '\0';
   if (! is.read (doc, doc_len))
     goto data_read_error;
 
   if (! is.read (&tmp, 1))
     goto data_read_error;
@@ -782,90 +782,90 @@ read_binary_data (istream& is, bool swap
 
   switch (tmp)
     {
     case 1:
       {
 	if (! is.read (&tmp, 1))
 	  goto data_read_error;
 	double dtmp;
-	read_doubles (is, &dtmp, static_cast<save_type> (tmp), 1, swap, fmt);
+	read_doubles (is, &dtmp, X_CAST (save_type, tmp), 1, swap, fmt);
 	if (error_state || ! is)
 	  goto data_read_error;
 	tc = dtmp;
       }
       break;
 
     case 2:
       {
 	FOUR_BYTE_INT nr, nc;
 	if (! is.read (&nr, 4))
 	  goto data_read_error;
 	if (swap)
-	  swap_4_bytes (static_cast<char *> (&nr));
+	  swap_4_bytes (X_CAST (char *, &nr));
 	if (! is.read (&nc, 4))
 	  goto data_read_error;
 	if (swap)
-	  swap_4_bytes (static_cast<char *> (&nc));
+	  swap_4_bytes (X_CAST (char *, &nc));
 	if (! is.read (&tmp, 1))
 	  goto data_read_error;
 	Matrix m (nr, nc);
 	double *re = m.fortran_vec ();
 	int len = nr * nc;
-	read_doubles (is, re, static_cast<save_type> (tmp), len, swap, fmt);
+	read_doubles (is, re, X_CAST (save_type, tmp), len, swap, fmt);
 	if (error_state || ! is)
 	  goto data_read_error;
 	tc = m;
       }
       break;
 
     case 3:
       {
 	if (! is.read (&tmp, 1))
 	  goto data_read_error;
 	Complex ctmp;
-	read_doubles (is, static_cast<double *> (&ctmp),
-		      static_cast<save_type> (tmp), 2, swap, fmt);
+	read_doubles (is, X_CAST (double *, &ctmp),
+		      X_CAST (save_type, tmp), 2, swap, fmt);
 	if (error_state || ! is)
 	  goto data_read_error;
 	tc = ctmp;
       }
       break;
 
     case 4:
       {
 	FOUR_BYTE_INT nr, nc;
 	if (! is.read (&nr, 4))
 	  goto data_read_error;
 	if (swap)
-	  swap_4_bytes (static_cast<char *> (&nr));
+	  swap_4_bytes (X_CAST (char *, &nr));
 	if (! is.read (&nc, 4))
 	  goto data_read_error;
 	if (swap)
-	  swap_4_bytes (static_cast<char *> (&nc));
+	  swap_4_bytes (X_CAST (char *, &nc));
 	if (! is.read (&tmp, 1))
 	  goto data_read_error;
 	ComplexMatrix m (nr, nc);
 	Complex *im = m.fortran_vec ();
 	int len = nr * nc;
-	read_doubles (is, static_cast<double *> (im),
-		      static_cast<save_type> (tmp), 2*len, swap, fmt);
+	read_doubles (is, X_CAST (double *, im),
+		      X_CAST (save_type, tmp), 2*len, swap, fmt);
 	if (error_state || ! is)
 	  goto data_read_error;
 	tc = m;
       }
       break;
 
     case 5:
       {
 	FOUR_BYTE_INT len;
 	if (! is.read (&len, 4))
 	  goto data_read_error;
 	if (swap)
-	  swap_4_bytes (static_cast<char *> (&len));
+	  swap_4_bytes (X_CAST (char *, &len));
 	char *s = new char [len+1];
 	if (! is.read (s, len))
 	  {
 	    delete [] s;
 	    goto data_read_error;
 	  }
 	s[len] = '\0';
 	tc = s;
@@ -875,46 +875,46 @@ read_binary_data (istream& is, bool swap
     case 6:
       {
 	if (! is.read (&tmp, 1))
 	  goto data_read_error;
 	double bas, lim, inc;
 	if (! is.read (&bas, 8))
 	  goto data_read_error;
 	if (swap)
-	  swap_8_bytes (static_cast<char *> (&bas));
+	  swap_8_bytes (X_CAST (char *, &bas));
 	if (! is.read (&lim, 8))
 	  goto data_read_error;
 	if (swap)
-	  swap_8_bytes (static_cast<char *> (&lim));
+	  swap_8_bytes (X_CAST (char *, &lim));
 	if (! is.read (&inc, 8))
 	  goto data_read_error;
 	if (swap)
-	  swap_8_bytes (static_cast<char *> (&inc));
+	  swap_8_bytes (X_CAST (char *, &inc));
 	Range r (bas, lim, inc);
 	tc = r;
       }
       break;
 
     case 7:
       {
 	FOUR_BYTE_INT elements;
 	if (! is.read (&elements, 4))
 	  goto data_read_error;
 	if (swap)
-	  swap_4_bytes (static_cast<char *> (&elements));
+	  swap_4_bytes (X_CAST (char *, &elements));
 	charMatrix chm (elements, 0);
 	int max_len = 0;
 	for (int i = 0; i < elements; i++)
 	  {
 	    FOUR_BYTE_INT len;
 	    if (! is.read (&len, 4))
 	      goto data_read_error;
 	    if (swap)
-	      swap_4_bytes (static_cast<char *> (&len));
+	      swap_4_bytes (X_CAST (char *, &len));
 	    char *tmp = new char [len+1];
 	    if (! is.read (tmp, len))
 	      {
 		delete [] tmp;
 		goto data_read_error;
 	      }
 	    if (len > max_len)
 	      {
@@ -1147,21 +1147,21 @@ read_mat_file_header (istream& is, bool&
 
   // mopt is signed, therefore byte swap may result in negative value.
 
   if (mopt > 9999 || mopt < 0)
     swap = true;
 
   if (swap)
     {
-      swap_4_bytes (static_cast<char *> (&mopt));
-      swap_4_bytes (static_cast<char *> (&nr));
-      swap_4_bytes (static_cast<char *> (&nc));
-      swap_4_bytes (static_cast<char *> (&imag));
-      swap_4_bytes (static_cast<char *> (&len));
+      swap_4_bytes (X_CAST (char *, &mopt));
+      swap_4_bytes (X_CAST (char *, &nr));
+      swap_4_bytes (X_CAST (char *, &nc));
+      swap_4_bytes (X_CAST (char *, &imag));
+      swap_4_bytes (X_CAST (char *, &len));
     }
 
   if (mopt > 9999 || mopt < 0 || imag > 1 || imag < 0)
     {
       if (! quiet)
 	error ("load: can't read binary file");
       return -1;
     }
@@ -1913,17 +1913,17 @@ save_binary_data (ostream& os, const oct
 	}
       else if (len > 4096) // XXX FIXME XXX -- make this configurable.
 	{
 	  double max_val, min_val;
 	  if (m.all_integers (max_val, min_val))
 	    st = get_save_type (max_val, min_val);
 	}
       const Complex *mtmp = m.data ();
-      write_doubles (os, static_cast<const double *> (mtmp), st, 2*len);
+      write_doubles (os, X_CAST (const double *, mtmp), st, 2*len);
     }
   else if (tc.is_string ())
     {
       tmp = 7;
       os.write (&tmp, 1);
       FOUR_BYTE_INT nr = tc.rows ();
       os.write (&nr, 4);
       charMatrix chm = tc.char_matrix_value ();
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -715,16 +715,51 @@ printf_format_list::printme (void) const
 
       cerr << elt->args<< "\t"
 	   << elt->type << "\t"
 	   << elt->modifier << "\t"
 	   << undo_string_escapes (elt->text) << "\n";
     }
 }
 
+int
+octave_base_stream::fileno (void)
+{
+  // Kluge alert!
+
+  if (name () == "stdin")
+    return 0;
+
+  if (name () == "stdout")
+    return 1;
+
+  if (name () == "stderr")
+    return 2;
+
+  int retval = -1;
+
+  istream *is = input_stream ();
+  ostream *os = output_stream ();
+
+  int i_fid = is ? ((filebuf *) (is->rdbuf ()))->fd () : -1;
+  int o_fid = os ? ((filebuf *) (os->rdbuf ()))->fd () : -1;
+
+  if (i_fid >= 0)
+    {
+      if (o_fid >= 0)
+	retval = (i_fid == o_fid) ? i_fid : -1;
+      else
+	retval = i_fid;
+    }
+  else if (o_fid >= 0)
+    retval = o_fid;
+
+  return retval;
+}
+
 void
 octave_base_stream::error (const string& msg)
 {
   fail = true;
   errmsg = msg;
 }
 
 void
@@ -1536,21 +1571,17 @@ public:
   double double_value (void);
 
   // Get the current value as an int and advance the internal pointer.
   int int_value (void);
 
   // Get the current value as a string and advance the internal pointer.
   string string_value (void);
 
-  operator void* () const
-    {
-      return (curr_state == ok)
-	? static_cast<void *> (-1) : static_cast<void *> (0);
-    }
+  operator bool () const { return (curr_state == ok); }
 
   bool no_more_values (void) { return curr_state == list_exhausted; }
 
   bool looking_at_string (void);
 
 private:
 
   const octave_value_list values;
diff --git a/src/oct-stream.h b/src/oct-stream.h
--- a/src/oct-stream.h
+++ b/src/oct-stream.h
@@ -88,21 +88,17 @@ public:
 	curr_idx = 0;
       return current ();
     }
 
   void printme (void) const;
 
   bool ok (void) const { return (nconv >= 0); }
 
-  operator void* () const
-    {
-      return ok ()
-	? static_cast<void *> (-1) : static_cast<void *> (0);
-    }
+  operator bool () const { return ok (); }
 
   bool all_character_conversions (void);
 
   bool all_numeric_conversions (void);
 
 private:
 
   // Number of conversions specified by this format string, or -1 if
@@ -177,21 +173,17 @@ public:
 	curr_idx = 0;
       return current ();
     }
 
   void printme (void) const;
 
   bool ok (void) const { return (nconv >= 0); }
 
-  operator void* () const
-    {
-      return ok ()
-	? static_cast<void *> (-1) : static_cast<void *> (0);
-    }
+  operator bool () const { return ok (); }
 
 private:
 
   // Number of conversions specified by this format string, or -1 if
   // invalid conversions have been found.
   int nconv;
 
   // Index to current element;
@@ -260,16 +252,18 @@ public:
   virtual istream *input_stream (void) { return 0; }
 
   // If the derived class provides this function and it returns a
   // pointer to a valid ostream, flush(), write(), and printf() will
   // automatically work for this stream.
 
   virtual ostream *output_stream (void) { return 0; }
 
+  int fileno (void);
+
   bool ok (void) const { return ! fail; }
 
   // Return current error message for this stream.
 
   string error (bool clear, int& err_num);
 
 protected:
 
@@ -413,23 +407,21 @@ public:
   string error (bool clear, int& err_num);
 
   string error (bool clear = false)
     {
       int err_num;
       return error (clear, err_num);
     }
 
+  int fileno (void) { return rep ? rep->fileno () : -1; }
+
   bool ok (void) const { return rep && rep->ok (); }
 
-  operator void* () const
-    {
-      return ok ()
-	? static_cast<void *> (-1) : static_cast<void *> (0);
-    }
+  operator bool () const { return ok (); }
 
   string name (void);
 
   int mode (void);
 
   oct_mach_info::float_format float_format (void);
 
   static string mode_as_string (int mode);
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -141,27 +141,28 @@ public:
 
   bool is_zero_by_zero (void) const
     { return (rows () == 0 && columns () == 0); }
 
   bool is_constant (void) const { return false; }
 
   bool is_function (void) const { return false; }
 
-  double double_value (bool) const;
+  double double_value (bool = false) const;
 
-  double scalar_value (bool) const { return double_value (); }
-
-  Matrix matrix_value (bool frc_str_conv = false) const;
+  double scalar_value (bool frc_str_conv = false) const
+    { return double_value (frc_str_conv); }
 
-  Complex complex_value (bool frc_str_conv = false) const;
+  Matrix matrix_value (bool = false) const;
+
+  Complex complex_value (bool = false) const;
 
-  ComplexMatrix complex_matrix_value (bool frc_str_conv = false) const;
+  ComplexMatrix complex_matrix_value (bool = false) const;
 
-  charMatrix char_matrix_value (bool frc_str_conv = false) const;
+  charMatrix char_matrix_value (bool = false) const;
 
   string_vector all_strings (void) const;
 
   string string_value (void) const;
 
   Range range_value (void) const;
 
   Octave_map map_value (void) const;
diff --git a/src/ov-bool-mat.cc b/src/ov-bool-mat.cc
--- a/src/ov-bool-mat.cc
+++ b/src/ov-bool-mat.cc
@@ -107,17 +107,19 @@ octave_bool_matrix::do_index_op (const o
     default:
       error ("invalid number of indices (%d) for matrix value", len);
       break;
     }
 
   return retval;
 }
 
+#if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 extern void assign (Array2<bool>&, const Array2<bool>&);
+#endif
 
 void
 octave_bool_matrix::assign (const octave_value_list& idx,
 			    const boolMatrix& rhs)
 {
   int len = idx.length ();
 
   switch (len)
diff --git a/src/ov-bool-mat.h b/src/ov-bool-mat.h
--- a/src/ov-bool-mat.h
+++ b/src/ov-bool-mat.h
@@ -102,25 +102,28 @@ public:
   bool valid_as_scalar_index (void) const;
 
   bool valid_as_zero_index (void) const { return is_zero_by_zero (); }
 
   bool is_true (void) const;
 
   double double_value (bool = false) const;
 
-  double scalar_value (bool = false) const { return double_value (); }
+  double scalar_value (bool frc_str_conv = false) const
+    { return double_value (frc_str_conv); }
 
   Matrix matrix_value (bool = false) const { return matrix; }
 
   Complex complex_value (bool = false) const;
 
-  ComplexMatrix complex_matrix_value (bool = false) const { return matrix; }
+  ComplexMatrix complex_matrix_value (bool = false) const
+    { return matrix; }
 
-  boolMatrix bool_matrix_value (bool = false) const { return matrix; }
+  boolMatrix bool_matrix_value (bool = false) const
+    { return matrix; }
 
   octave_value convert_to_str (void) const
     { return octave_value (matrix); }
 
   octave_value transpose (void) const
     { return octave_value (matrix.transpose ()); }
 
   octave_value hermitian (void) const
diff --git a/src/ov-bool.h b/src/ov-bool.h
--- a/src/ov-bool.h
+++ b/src/ov-bool.h
@@ -99,17 +99,18 @@ public:
   bool valid_as_zero_index (void) const { return ! scalar; }
 
   bool is_true (void) const { return scalar; }
 
   double double_value (bool = false) const { return scalar; }
 
   double scalar_value (bool = false) const { return scalar; }
 
-  Matrix matrix_value (bool = false) const { return Matrix (1, 1, scalar); }
+  Matrix matrix_value (bool = false) const
+    { return Matrix (1, 1, scalar); }
 
   Complex complex_value (bool = false) const { return scalar; }
 
   ComplexMatrix complex_matrix_value (bool = false) const
     { return  ComplexMatrix (1, 1, Complex (scalar)); }
 
   bool bool_value (void) const { return scalar; }
 
diff --git a/src/ov-ch-mat.h b/src/ov-ch-mat.h
--- a/src/ov-ch-mat.h
+++ b/src/ov-ch-mat.h
@@ -101,25 +101,28 @@ public:
 
   bool valid_as_scalar_index (void) const;
   bool valid_as_zero_index (void) const;
 
   bool is_true (void) const;
 
   double double_value (bool = false) const;
 
-  double scalar_value (bool = false) const { return double_value (); }
+  double scalar_value (bool frc_str_conv = false) const
+    { return double_value (frc_str_conv); }
 
   Matrix matrix_value (bool = false) const { return matrix; }
 
   Complex complex_value (bool = false) const;
 
-  ComplexMatrix complex_matrix_value (bool = false) const { return matrix; }
+  ComplexMatrix complex_matrix_value (bool = false) const
+    { return matrix; }
 
-  charMatrix char_matrix_value (bool = false) const { return matrix; }
+  charMatrix char_matrix_value (bool = false) const
+    { return matrix; }
 
   octave_value convert_to_str (void) const
     { return octave_value (matrix, true); }
 
   octave_value transpose (void) const
     { return octave_value (matrix.transpose ()); }
 
   octave_value hermitian (void) const
diff --git a/src/ov-complex.h b/src/ov-complex.h
--- a/src/ov-complex.h
+++ b/src/ov-complex.h
@@ -99,17 +99,18 @@ public:
   bool valid_as_zero_index (void) const { return false; }
 
   bool is_true (void) const { return (scalar != 0.0); }
 
   bool is_empty (void) const { return (rows () == 0 && columns () == 0); }
 
   double double_value (bool = false) const;
 
-  double scalar_value (bool = false) const { return double_value (); }
+  double scalar_value (bool frc_str_conv = false) const
+    { return double_value (frc_str_conv); }
 
   Matrix matrix_value (bool = false) const;
 
   Complex complex_value (bool = false) const;
 
   ComplexMatrix complex_matrix_value (bool = false) const;
 
   octave_value not (void) const { return octave_value (scalar == 0.0); }
diff --git a/src/ov-cx-mat.h b/src/ov-cx-mat.h
--- a/src/ov-cx-mat.h
+++ b/src/ov-cx-mat.h
@@ -107,19 +107,20 @@ public:
 
   bool valid_as_scalar_index (void) const;
   bool valid_as_zero_index (void) const;
 
   bool is_true (void) const;
 
   bool is_empty (void) const { return (rows () == 0 && columns () == 0); }
 
-  double double_value (bool) const;
+  double double_value (bool = false) const;
 
-  double scalar_value (bool) const { return double_value (); }
+  double scalar_value (bool frc_str_conv = false) const
+    { return double_value (frc_str_conv); }
 
   Matrix matrix_value (bool = false) const;
 
   Complex complex_value (bool = false) const;
 
   ComplexMatrix complex_matrix_value (bool = false) const;
 
   octave_value not (void) const { return octave_value (! matrix); }
diff --git a/src/ov-range.h b/src/ov-range.h
--- a/src/ov-range.h
+++ b/src/ov-range.h
@@ -122,26 +122,27 @@ public:
       return (range.nelem () == 1
 	      && ! xisnan (range.base ())
 	      && NINT (range.base ()) == 0);
     }
 
   // XXX DO ME XXX
   bool is_true (void) const;
 
-  double double_value (bool) const;
+  double double_value (bool = false) const;
 
-  double scalar_value (bool) const { return double_value (); }
+  double scalar_value (bool frc_str_conv = false) const
+    { return double_value (frc_str_conv); }
 
-  Matrix matrix_value (bool) const
+  Matrix matrix_value (bool = false) const
     { return range.matrix_value (); }
 
-  Complex complex_value (bool) const;
+  Complex complex_value (bool = false) const;
 
-  ComplexMatrix complex_matrix_value (bool) const
+  ComplexMatrix complex_matrix_value (bool = false) const
     { return range.matrix_value (); }
 
   Range range_value (void) const { return range; }
 
   octave_value not (void) const;
 
   octave_value uminus (void) const { return octave_value (- range); }
 
diff --git a/src/ov-re-mat.h b/src/ov-re-mat.h
--- a/src/ov-re-mat.h
+++ b/src/ov-re-mat.h
@@ -123,23 +123,25 @@ public:
   bool valid_as_scalar_index (void) const;
 
   bool valid_as_zero_index (void) const { return is_zero_by_zero (); }
 
   bool is_true (void) const;
 
   double double_value (bool = false) const;
 
-  double scalar_value (bool = false) const { return double_value (); }
+  double scalar_value (bool frc_str_conv = false) const
+    { return double_value (frc_str_conv); }
 
   Matrix matrix_value (bool = false) const { return matrix; }
 
   Complex complex_value (bool = false) const;
 
-  ComplexMatrix complex_matrix_value (bool = false) const { return matrix; }
+  ComplexMatrix complex_matrix_value (bool = false) const
+    { return matrix; }
 
   octave_value not (void) const { return octave_value (! matrix); }
 
   octave_value uminus (void) const { return octave_value (- matrix); }
 
   octave_value transpose (void) const
     { return octave_value (matrix.transpose ()); }
 
diff --git a/src/ov-scalar.h b/src/ov-scalar.h
--- a/src/ov-scalar.h
+++ b/src/ov-scalar.h
@@ -100,17 +100,18 @@ public:
     { return (! xisnan (scalar) && NINT (scalar) == 0); }
 
   bool is_true (void) const { return (scalar != 0.0); }
 
   double double_value (bool = false) const { return scalar; }
 
   double scalar_value (bool = false) const { return scalar; }
 
-  Matrix matrix_value (bool = false) const { return Matrix (1, 1, scalar); }
+  Matrix matrix_value (bool = false) const
+    { return Matrix (1, 1, scalar); }
 
   Complex complex_value (bool = false) const { return scalar; }
 
   ComplexMatrix complex_matrix_value (bool = false) const
     { return  ComplexMatrix (1, 1, Complex (scalar)); }
 
   octave_value not (void) const { return octave_value (! scalar); }
 
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -156,21 +156,17 @@ public:
   octave_value& operator () (Pix p) { return rep->operator () (p); }
 
   const octave_value& operator () (Pix p) const
     { return rep->operator () (p); }
 
   Pix first (void) const { return rep->first (); }
   void next (Pix& p) const { rep->next (p); }
   
-  operator void* () const
-  {
-    return (rep && rep->ok)
-      ? static_cast<void *> (-1) : static_cast<void *> (0);
-  }
+  operator bool () const { return (rep && rep->ok); }
 
 private:
 
   tm_row_const_rep *rep;
 };
 
 void
 tm_row_const::tm_row_const_rep::init (const tree_argument_list& row)
@@ -282,18 +278,17 @@ public:
   int rows (void) const { return nr; }
   int cols (void) const { return nc; }
 
   bool all_strings_p (void) const { return all_str; }
   bool some_strings_p (void) const { return some_str; }
   bool complex_p (void) const { return is_cmplx; }
   bool all_empty_p (void) const { return all_mt; }
 
-  operator void* () const
-    { return ok ? static_cast<void *> (-1) : static_cast<void *> (0); }
+  operator bool () const { return ok; }
 
 private:
 
   int nr;
   int nc;
 
   bool all_str;
   bool some_str;
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -557,22 +557,25 @@ symbol_table::name_list (int& count, con
 
   if (sort)
     names.qsort ();
 
   return names;
 }
 
 static int
-maybe_list_cmp_fcn (symbol_record **a_arg, symbol_record **b_arg)
+maybe_list_cmp_fcn (const void *a_arg, const void *b_arg)
 {
-  string a = (*a_arg)->name ();
-  string b = (*b_arg)->name ();
+  const symbol_record *a = *(X_CAST (const symbol_record **, a_arg));
+  const symbol_record *b = *(X_CAST (const symbol_record **, b_arg));
 
-  return a.compare (b);
+  string a_nm = a->name ();
+  string b_nm = b->name ();
+
+  return a_nm.compare (b_nm);
 }
 
 int
 symbol_table::maybe_list (const char *header, const string_vector& argv,
 			  ostream& os, bool show_verbose,
 			  unsigned type, unsigned scope)
 {
   int count;
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -101,42 +101,38 @@ Otherwise, FID is negative and MSG conta
 
   retval(1) = string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
-      double d_old = args(0).double_value ();
-      double d_new = args(1).double_value ();
+      octave_stream *old_stream = octave_stream_list::lookup (args(0));
+      octave_stream *new_stream = octave_stream_list::lookup (args(1));
 
       if (! error_state)
 	{
-	  if (D_NINT (d_old) == d_old && D_NINT (d_new) == d_new)
-	    {
-	      int i_old = NINT (d_old);
-	      int i_new = NINT (d_new);
+	  int i_old = old_stream->fileno ();
+	  int i_new = new_stream->fileno ();
 
-	      // XXX FIXME XXX -- are these checks sufficient?
-	      if (i_old >= 0 && i_new >= 0)
-		{
-		  string msg;
+	  if (i_old >= 0 && i_new >= 0)
+	    {
+	      string msg;
 
-		  int status = octave_syscalls::dup2 (i_old, i_new, msg);
+	      int status = octave_syscalls::dup2 (i_old, i_new, msg);
 
-		  retval(0) = static_cast<double> (status);
-		  retval(1) = msg;
-		}
-	      else
-		error ("dup2: invalid file id");
+	      retval(0) = static_cast<double> (status);
+	      retval(1) = msg;
 	    }
 	  else
-	    error ("dup2: arguments must be integer values");
+	    error ("dup2: invalid file id");
 	}
+      else
+	error ("dup2: invalid stream");
     }
   else
     print_usage ("dup2");
 
   return retval;
 }
 
 DEFUN (exec, args, ,
diff --git a/src/unwind-prot.h b/src/unwind-prot.h
--- a/src/unwind-prot.h
+++ b/src/unwind-prot.h
@@ -121,18 +121,17 @@ public:
 
 #define unwind_protect_int(i) \
   unwind_protect::save_int (&(i), (i))
 
 #define unwind_protect_str(s) \
   unwind_protect::save_str (&(s), (s))
 
 #define unwind_protect_ptr(p) \
-  unwind_protect::save_ptr (static_cast<void **> (&(p)), \
-			    static_cast<void *> (p))
+  unwind_protect::save_ptr (X_CAST (void **, &(p)), X_CAST (void *, (p)))
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
