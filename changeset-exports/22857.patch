# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1480706203 18000
#      Fri Dec 02 14:16:43 2016 -0500
# Node ID d90e0c79aa4545e2725dfc224f935e73303181d8
# Parent  d5b58e234c37b40a4a24dfb3e8f5aa663eccacf1
Backed out changeset d5b58e234c37

diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -172,16 +172,98 @@ namespace octave
           context.pop ();
       }
 
     private:
 
       std::stack<int> context;
     };
 
+    class token_cache
+    {
+    public:
+
+      // Store an "unlimited" number of tokens.
+      token_cache (size_t sz_arg = std::numeric_limits<size_t>::max ())
+        : buffer (), sz (sz_arg)
+      { }
+
+      void push (token *tok)
+      {
+        if (buffer.size () == sz)
+          pop ();
+
+        buffer.push_front (tok);
+      }
+
+      void pop (void)
+      {
+        if (! empty ())
+          {
+            delete buffer.back ();
+            buffer.pop_back ();
+          }
+      }
+
+      // Direct access.
+      token *at (size_t n)
+      {
+        return empty () ? 0 : buffer.at (n);
+      }
+
+      const token *at (size_t n) const
+      {
+        return empty () ? 0 : buffer.at (n);
+      }
+
+      // Most recently pushed.
+      token *front (void)
+      {
+        return empty () ? 0 : buffer.front ();
+      }
+
+      const token *front (void) const
+      {
+        return empty () ? 0 : buffer.front ();
+      }
+
+      token *back (void)
+      {
+        return empty () ? 0 : buffer.back ();
+      }
+
+      const token *back (void) const
+      {
+        return empty () ? 0 : buffer.back ();
+      }
+
+      // Number of elements currently in the buffer, max of sz.
+      size_t size (void) const { return buffer.size (); }
+
+      bool empty (void) const { return buffer.empty (); }
+
+      void clear (void)
+      {
+        while (! empty ())
+          pop ();
+      }
+
+    private:
+
+      std::deque<token *> buffer;
+
+      size_t sz;
+
+      // No copying!
+
+      token_cache (const token_cache&);
+
+      token_cache& operator = (const token_cache&);
+    };
+
     lexical_feedback (void)
       : end_of_input (false), at_beginning_of_statement (true),
         looking_at_anon_fcn_args (false), looking_at_return_list (false),
         looking_at_parameter_list (false), looking_at_decl_list (false),
         looking_at_initializer_expression (false),
         looking_at_matrix_or_assign_lhs (false),
         looking_for_object_index (false),
         looking_at_indirect_ref (false), parsing_class_method (false),
@@ -365,17 +447,17 @@ namespace octave
     // Track current symbol table scope and context.
     symbol_table_context symtab_context;
 
     // is the closest nesting level a square bracket, squiggly brace,
     // a paren, or an anonymous function body?
     bbp_nesting_level nesting_level;
 
     // Tokens generated by the lexer.
-    std::deque<token *> tokens;
+    token_cache tokens;
 
   private:
 
     // No copying!
 
     lexical_feedback (const lexical_feedback&);
 
     lexical_feedback& operator = (const lexical_feedback&);
@@ -765,8 +847,9 @@ namespace octave
 
     push_lexer (const push_lexer&);
 
     push_lexer& operator = (const push_lexer&);
   };
 }
 
 #endif
+
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -2140,36 +2140,40 @@ namespace octave
     symtab_context.clear ();
     nesting_level.reset ();
     tokens.clear ();
   }
 
   int
   lexical_feedback::previous_token_value (void) const
   {
-    return tokens.empty () ? 0 : tokens.front ()->token_value ();
+    const token *tok = tokens.front ();
+    return tok ? tok->token_value () : 0;
   }
 
   bool
   lexical_feedback::previous_token_value_is (int tok_val) const
   {
-    return tokens.empty () ? false : tokens.front ()->token_value_is (tok_val);
+    const token *tok = tokens.front ();
+    return tok ? tok->token_value_is (tok_val) : false;
   }
 
   void
   lexical_feedback::mark_previous_token_trailing_space (void)
   {
-    if (! tokens.empty () && ! previous_token_value_is ('\n'))
-      tokens.front ()->mark_trailing_space ();
+    token *tok = tokens.front ();
+    if (tok && ! previous_token_value_is ('\n'))
+      tok->mark_trailing_space ();
   }
 
   bool
   lexical_feedback::space_follows_previous_token (void) const
   {
-    return tokens.empty () ? false : tokens.front ()->space_follows_token ();
+    const token *tok = tokens.front ();
+    return tok ? tok->space_follows_token () : false;
   }
 
   bool
   lexical_feedback::previous_token_is_binop (void) const
   {
     int tok = previous_token_value ();
 
     return (tok == '+' || tok == '-' || tok == '@'
@@ -2185,35 +2189,34 @@ namespace octave
             || tok == EXPR_OR_OR || tok == LEFTDIV || tok == LEFTDIV_EQ
             || tok == MUL_EQ || tok == OR_EQ || tok == POW
             || tok == POW_EQ || tok == SUB_EQ);
   }
 
   bool
   lexical_feedback::previous_token_is_keyword (void) const
   {
-    return tokens.empty () ? false : tokens.front ()->is_keyword ();
+    const token *tok = tokens.front ();
+    return tok ? tok->is_keyword () : false;
   }
 
   bool
   lexical_feedback::previous_token_may_be_command (void) const
   {
-    return tokens.empty () ? false : tokens.front ()->may_be_command ();
+    const token *tok = tokens.front ();
+    return tok ? tok->may_be_command () : false;
   }
 
   void
   lexical_feedback::maybe_mark_previous_token_as_variable (void)
   {
-    if (! tokens.empty ())
-    {
-      token *tok = tokens.front ();
-
-      if (tok->is_symbol ())
-        pending_local_variables.insert (tok->symbol_name ());
-    }
+    token *tok = tokens.front ();
+
+    if (tok && tok->is_symbol ())
+      pending_local_variables.insert (tok->symbol_name ());
   }
 
   void
   lexical_feedback::mark_as_variables (const std::list<std::string>& lst)
   {
     for (std::list<std::string>::const_iterator p = lst.begin ();
          p != lst.end (); p++)
       {
@@ -3195,17 +3198,17 @@ namespace octave
     warn_language_extension (t + " used as operator");
   }
 
   void
   base_lexer::push_token (token *tok)
   {
     YYSTYPE *lval = yyget_lval (scanner);
     lval->tok_val = tok;
-    tokens.push_front (tok);
+    tokens.push (tok);
   }
 
   token *
   base_lexer::current_token (void)
   {
     YYSTYPE *lval = yyget_lval (scanner);
     return lval->tok_val;
   }
