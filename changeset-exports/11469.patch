# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1294605681 28800
#      Sun Jan 09 12:41:21 2011 -0800
# Node ID c776f063fefe4741f920f75e1dfdf4e566865c7a
# Parent  e1edf0ba3bcbe6482d1031742893ee9405cb7e94
Overhaul m-script files to use common variable name between code and documentation.

diff --git a/scripts/@ftp/ascii.m b/scripts/@ftp/ascii.m
--- a/scripts/@ftp/ascii.m
+++ b/scripts/@ftp/ascii.m
@@ -14,14 +14,14 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} ascii (@var{f})
 ## Put the FTP connection @var{f} into ascii mode.
-## @var{f} is an FTP object returned by the ftp function.
+## @var{f} is an FTP object returned by the @code{ftp} function.
 ## @end deftypefn
 
-function ascii (obj)
-  __ftp_ascii__ (obj.curlhandle);
+function ascii (f)
+  __ftp_ascii__ (f.curlhandle);
 endfunction
diff --git a/scripts/@ftp/binary.m b/scripts/@ftp/binary.m
--- a/scripts/@ftp/binary.m
+++ b/scripts/@ftp/binary.m
@@ -14,14 +14,14 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} binary (@var{f})
 ## Put the FTP connection @var{f} into binary mode.
-## @var{f} is an FTP object returned by the ftp function.
+## @var{f} is an FTP object returned by the @code{ftp} function.
 ## @end deftypefn
 
-function binary (obj)
-  __ftp_binary__ (obj.curlhandle);
+function binary (f)
+  __ftp_binary__ (f.curlhandle);
 endfunction
diff --git a/scripts/@ftp/cd.m b/scripts/@ftp/cd.m
--- a/scripts/@ftp/cd.m
+++ b/scripts/@ftp/cd.m
@@ -14,14 +14,14 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} cd (@var{f}, @var{path})
 ## Set the remote directory to @var{path} on the FTP connection @var{f}.
-## @var{f} is an FTP object returned by the ftp function.
+## @var{f} is an FTP object returned by the @code{ftp} function.
 ## @end deftypefn
 
-function cd (obj, path)
-  __ftp_cwd__ (obj.curlhandle, path);
+function cd (f, path)
+  __ftp_cwd__ (f.curlhandle, path);
 endfunction
diff --git a/scripts/@ftp/close.m b/scripts/@ftp/close.m
--- a/scripts/@ftp/close.m
+++ b/scripts/@ftp/close.m
@@ -13,15 +13,15 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} close (@var{f})
-## Close the FTP connection represented by given FTP object @var{f}.
-## @var{f} is an FTP object returned by the ftp function.
+## Close the FTP connection represented by the given FTP object @var{f}.
+## @var{f} is an FTP object returned by the @code{ftp} function.
 ## @end deftypefn
 
-function dir (obj)
-  __ftp_close__ (obj.curlhandle);
+function dir (f)
+  __ftp_close__ (f.curlhandle);
 endfunction
diff --git a/scripts/@ftp/delete.m b/scripts/@ftp/delete.m
--- a/scripts/@ftp/delete.m
+++ b/scripts/@ftp/delete.m
@@ -14,14 +14,14 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} delete (@var{f}, @var{file})
 ## Delete the remote file @var{file}, over the FTP connection @var{f}.
-## @var{f} is an FTP object returned by the ftp function.
+## @var{f} is an FTP object returned by the @code{ftp} function.
 ## @end deftypefn
 
-function delete (obj, file)
-  __ftp_delete__ (obj.curlhandle, file);
+function delete (f, file)
+  __ftp_delete__ (f.curlhandle, file);
 endfunction
diff --git a/scripts/@ftp/dir.m b/scripts/@ftp/dir.m
--- a/scripts/@ftp/dir.m
+++ b/scripts/@ftp/dir.m
@@ -12,20 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{lst} =} dir (@var{path})
+## @deftypefn {Function File} {@var{lst} =} dir (@var{f})
 ## List the current directory in verbose form for the FTP connection 
-## @var{f}.  @var{f} is an FTP object returned by the ftp function.
+## @var{f}.  @var{f} is an FTP object returned by the @code{ftp} function.
 ## @end deftypefn
 
-function lst = dir (obj)
+function lst = dir (f)
   if (nargout == 0)
-    __ftp_dir__ (obj.curlhandle);
+    __ftp_dir__ (f.curlhandle);
   else
-    lst = __ftp_dir__ (obj.curlhandle);
+    lst = __ftp_dir__ (f.curlhandle);
   endif
 endfunction
diff --git a/scripts/@ftp/ftp.m b/scripts/@ftp/ftp.m
--- a/scripts/@ftp/ftp.m
+++ b/scripts/@ftp/ftp.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{f}} = ftp (@var{host})
-## @deftypefnx {Function File} {@var{f}} = ftp (@var{host}, @var{username}, ## @var{password})
+## @deftypefnx {Function File} {@var{f}} = ftp (@var{host}, @var{username}, @var{password})
 ## Connect to the FTP server @var{host} with @var{username} and @var{password}.
 ## If @var{username} and @var{password} are not specified, user "anonymous"
 ## with no password is used.  The returned FTP object @var{f} represents the
 ## established FTP connection.
 ## @end deftypefn
 
 function obj = ftp (host, username = "anonymous", password = "")
   if (nargin == 0)
diff --git a/scripts/@ftp/mget.m b/scripts/@ftp/mget.m
--- a/scripts/@ftp/mget.m
+++ b/scripts/@ftp/mget.m
@@ -17,21 +17,21 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} mget (@var{f}, @var{file})
 ## @deftypefnx {Function File} {} mget (@var{f}, @var{dir})
 ## @deftypefnx {Function File} {} mget (@dots{}, @var{target})
 ## Downloads a remote file @var{file} or directory @var{dir} to the local
 ## directory on the FTP connection @var{f}.  @var{f} is an FTP object
-## returned by the ftp function. 
+## returned by the @code{ftp} function. 
 ##
 ## The arguments @var{file} and @var{dir} can include wildcards and any
 ## files or directories on the remote server that match will be downloaded.
 ##
 ## If a third argument @var{target} is given, then a single file or
 ## directory will be downloaded with the name @var{target} to the local
 ## directory.
 ## @end deftypefn
 
-function mget (obj, file)
-  __ftp_mget__ (obj.curlhandle, file);
+function mget (f, file)
+  __ftp_mget__ (f.curlhandle, file);
 endfunction
diff --git a/scripts/@ftp/mkdir.m b/scripts/@ftp/mkdir.m
--- a/scripts/@ftp/mkdir.m
+++ b/scripts/@ftp/mkdir.m
@@ -14,14 +14,14 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} mkdir (@var{f}, @var{path})
 ## Create the remote directory @var{path}, over the FTP connection @var{f}.
-## @var{f} is an FTP object returned by the ftp function.
+## @var{f} is an FTP object returned by the @code{ftp} function.
 ## @end deftypefn
 
-function mkdir (obj, path)
-  __ftp_mkdir__ (obj.curlhandle, path);
+function mkdir (f, path)
+  __ftp_mkdir__ (f.curlhandle, path);
 endfunction
diff --git a/scripts/@ftp/mput.m b/scripts/@ftp/mput.m
--- a/scripts/@ftp/mput.m
+++ b/scripts/@ftp/mput.m
@@ -21,15 +21,15 @@
 ## Upload the local file @var{file} into the current remote directory on
 ## the FTP connection @var{f}.  @var{f} is an FTP object returned by the
 ## ftp function. 
 ##
 ## The argument @var{file} is passed by the @dfn{glob} function and any
 ## files that match the wildcards in @var{file} will be uploaded.
 ## @end deftypefn
 
-function retval = mput (obj, file)
+function retval = mput (f, file)
   if (nargout == 0)
-    __ftp_mput__ (obj.curlhandle, file);
+    __ftp_mput__ (f.curlhandle, file);
   else
-    retval = __ftp_mput__ (obj.curlhandle, file);
+    retval = __ftp_mput__ (f.curlhandle, file);
   endif
 endfunction
diff --git a/scripts/@ftp/rename.m b/scripts/@ftp/rename.m
--- a/scripts/@ftp/rename.m
+++ b/scripts/@ftp/rename.m
@@ -18,11 +18,11 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} rename (@var{f}, @var{oldname}, @var{newname})
 ## Rename or move the remote file or directory @var{oldname} to @var{newname},
 ##  over the FTP connection @var{f}.  @var{f} is an FTP object returned by the
 ## ftp function.
 ## @end deftypefn
 
-function rename (obj, oldname, newname)
-  __ftp_rename__ (obj.curlhandle, oldname, newname);
+function rename (f, oldname, newname)
+  __ftp_rename__ (f.curlhandle, oldname, newname);
 endfunction
diff --git a/scripts/@ftp/rmdir.m b/scripts/@ftp/rmdir.m
--- a/scripts/@ftp/rmdir.m
+++ b/scripts/@ftp/rmdir.m
@@ -14,14 +14,14 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} rmdir (@var{f}, @var{path})
 ## Remove the remote directory @var{path}, over the FTP connection @var{f}.
-## @var{f} is an FTP object returned by the ftp function.
+## @var{f} is an FTP object returned by the @code{ftp} function.
 ## @end deftypefn
 
-function rmdir (obj, path)
-  __ftp_rmdir__ (obj.curlhandle, path);
+function rmdir (f, path)
+  __ftp_rmdir__ (f.curlhandle, path);
 endfunction
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,149 @@
+2011-01-09  Rik  <octave@nomad.inbox5.com>
+
+	* audio/loadaudio.m, audio/mu2lin.m, audio/saveaudio.m,
+	general/accumdim.m, general/bitget.m, general/bitset.m, general/del2.m,
+	general/isequal.m, general/isequalwithequalnans.m, general/logspace.m,
+	general/repmat.m, general/strerror.m, general/structfun.m,
+	geometry/delaunayn.m, geometry/dsearchn.m, image/ind2gray.m,
+	image/ind2rgb.m, image/rgb2ind.m, io/csvread.m, io/csvwrite.m,
+	linear-algebra/rref.m, linear-algebra/subspace.m,
+	linear-algebra/trace.m, miscellaneous/dir.m, miscellaneous/dos.m,
+	miscellaneous/menu.m, miscellaneous/perl.m, miscellaneous/unix.m,
+	path/savepath.m, plot/allchild.m, plot/diffuse.m, plot/fplot.m,
+	plot/refreshdata.m, plot/specular.m, plot/subplot.m,
+	polynomial/polyreduce.m, set/ismember.m, signal/arch_fit.m,
+	signal/arch_rnd.m, signal/arch_test.m, signal/diffpara.m,
+	signal/fftfilt.m, signal/filter2.m, signal/sinetone.m,
+	signal/spectral_xdf.m, signal/stft.m, signal/synthesis.m,
+	sparse/spfun.m, sparse/spones.m, sparse/spstats.m, sparse/treelayout.m,
+	sparse/treeplot.m, specfun/isprime.m,
+	statistics/distributions/expcdf.m, statistics/distributions/expinv.m,
+	statistics/distributions/exppdf.m, statistics/distributions/exprnd.m,
+	statistics/distributions/poisscdf.m,
+	statistics/distributions/poissinv.m,
+	statistics/distributions/poisspdf.m,
+	statistics/distributions/poissrnd.m,
+	statistics/tests/chisquare_test_independence.m,
+	statistics/tests/cor_test.m, statistics/tests/f_test_regression.m,
+	statistics/tests/t_test_regression.m, strings/base2dec.m,
+	strings/dec2base.m, strings/regexptranslate.m, strings/strjust.m,
+	strings/strmatch.m, time/asctime.m, time/datenum.m:
+	Use common names for variables in documentation and code.
+
+	* @ftp/ascii.m, @ftp/binary.m, @ftp/cd.m, @ftp/close.m, @ftp/delete.m,
+	@ftp/dir.m, @ftp/ftp.m, @ftp/mget.m, @ftp/mkdir.m, @ftp/mput.m,
+	@ftp/rename.m, @ftp/rmdir.m, general/chop.m, geometry/dsearch.m,
+	signal/spencer.m, specfun/primes.m, time/etime.m: Use common names for
+	variables in documentation and code.  Improve docstring
+
+	* elfun/acot.m, elfun/acoth.m, elfun/acsc.m, elfun/acsch.m,
+	elfun/asec.m, elfun/asech.m, elfun/cot.m, elfun/coth.m, elfun/csc.m,
+	elfun/csch.m, elfun/sec.m, elfun/sech.m: Use common names for variables
+	in documentation and code.  Change output variable to 'y' rather than
+	'w'.
+
+	* miscellaneous/bunzip2.m, miscellaneous/gunzip.m,
+	miscellaneous/unpack.m, miscellaneous/untar.m, miscellaneous/unzip.m:
+	Use common names for variables in documentation and code.  Use default
+	on input argument to simplify input validation.
+
+	* general/accumarray.m: Use common names for variables in
+	documentation, code and tests.
+
+	* geometry/inpolygon.m: Use common names for variables in
+	documentation, code and tests.  Improve docstring.
+
+	* general/bitcmp.m: Use common names for variables in documentation and
+	code.  Switch tests to %!test blocks rather than %!shared variables and
+	%!asserts for clarity.
+
+	* general/int2str.m: Switch to input variable name 'n' rather than 'x'.
+
+	* general/isdir.m: Switch to input variable name 'f' rather than 'x'.
+	Switch output variable to 'retval' rather than 'y'.
+
+	* general/perror.m: Switch to input variable name 'funcname' rather
+	than 'name'.  Use common names for variables in documentation and
+	code.
+
+	* general/rot90.m: Switch to input variable name 'A' rather than 'x'.
+	Break very long %!assert line into multiple asserts for readability.
+
+	* general/sortrows.m: Use common names for variables in documentation
+	and code.  Break very long %!assert line into multiple asserts for
+	readability.
+
+	* geometry/voronoin.m: Switch to input variable name 'options' rather
+	than 'opt'.
+
+	* help/lookfor.m: Switch to input variable name 'arg2' rather than
+	'extra'.
+
+	* image/brighten.m: Switch to input variable name 'arg1' rather than
+	'm'.  Eliminate CamelCase in output variable 'Rmap'.
+
+	* image/rgb2hsv.m: Switch to variable name 'hsv_map' rather than
+	'hsval'.
+
+	* image/saveimage.m: Switch to input variable name 'fname', rather than
+	'file'.  Use common names for variables in documentation and code.
+
+	* io/strread.m, io/textread.m, io/textscan.m: Switch to input variable
+	name 'format' rather than 'formatstr'
+
+	* miscellaneous/run.m: Switch to input variable 'script' rather than
+	's'.
+
+	* miscellaneous/ver.m: Switch to input variable 'package' rather than
+	'pack'.  Use default on input argument to simplify input validation.
+
+	* plot/saveas.m: Switch to input variable 'fmt' rather than 'ext'.
+	Improve docstring.
+
+	* plot/title.m: : Switch to input variable 'string' rather than 'title'.
+
+	* plot/uigetdir.m: Improve docstring.  Re-order input validation.
+	Eliminate unnecessary use of cellfun to compare strings.
+
+	* polynomial/polyder.m, polynomial/polyderiv.m: Switch ouput variable
+	name 'r' to 'd'.  Improve docstring.
+
+	* polynomial/polyint.m: Switch input variable name 'c' to 'p'.
+
+	* signal/fftconv.m: Switch input variable names to 'x','y' instead of
+	'a','b' for vectors.
+
+	* signal/fftshift.m, signal/ifftshift.m: Switch input variable name to
+	'x' instead of 'v'.
+
+	* sparse/etreeplot.m: Switch input variable name to 'A' rather than
+	'tree' for matrix.
+
+	* specfun/factor.m: Use common names for variables in documentation and
+	code.  Uncomment and re-instate test code.
+
+	* statistics/distributions/cauchy_cdf.m,
+	statistics/distributions/cauchy_inv.m,
+	statistics/distributions/cauchy_pdf.m,
+	statistics/distributions/cauchy_rnd.m: Switch to input variables
+	'location','scale' rather than 'lambda','sigma'.
+
+	* statistics/tests/manova.m: Switch to input variable 'x' rather than
+	'y'.
+
+	* strings/untabify.m: Switch to input variable 'dblank' rather than
+	'db'.
+
+	* time/datestr.m: Improve docstring
+
+	* time/weekday.m: Switch to input variable name 'format' rather than
+	'form'.  Improve docstring.
+
 2011-01-08  John Hunt  <huntj@gawab.com>
 
 	* plot/legend.m, plot/private/__plt__.m: legend with more than two
 	inline keys (bug 31991). Add/modifyy demos.
 
 2011-01-07  John W. Eaton  <jwe@octave.org>
 
 	* general/private/__isequal__.m: Compare objects as if they are
diff --git a/scripts/audio/loadaudio.m b/scripts/audio/loadaudio.m
--- a/scripts/audio/loadaudio.m
+++ b/scripts/audio/loadaudio.m
@@ -32,51 +32,51 @@
 ## @seealso{lin2mu, mu2lin, saveaudio, playaudio, setaudio, record}
 ## @end deftypefn
 
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 10 April 1994
 ## Adapted-By: jwe
 
-function X = loadaudio (name, ext, bit)
+function X = loadaudio (name, ext, bps)
 
   if (nargin == 0 || nargin > 3)
     print_usage ();
   endif
 
   if (nargin == 1)
     ext = "lin";
   endif
 
   if (nargin < 3)
-    bit = 8;
-  elseif (bit != 8 && bit != 16)
-    error ("loadaudio: bit must be either 8 or 16");
+    bps = 8;
+  elseif (bps != 8 && bps != 16)
+    error ("loadaudio: bps must be either 8 or 16");
   endif
 
   name = [name, ".", ext];
   num = fopen (name, "rb");
 
   if (strcmp (ext, "lin") || strcmp (ext, "raw") || strcmp (ext, "pcm"))
-    if (bit == 8)
+    if (bps == 8)
       [Y, c] = fread (num, inf, "uchar");
       X = Y - 127;
     else
       [X, c] = fread (num, inf, "short");
     endif
   elseif (strcmp (ext, "mu") || strcmp (ext, "au")
           || strcmp (ext, "snd") || strcmp(ext, "ul"))
     [Y, c] = fread (num, inf, "uchar");
     ## remove file header
     m = find (Y(1:64) == 0, 1, "last");
     if (! isempty (m))
       Y(1:m) = [];
     endif
-    X = mu2lin (Y, bit);
+    X = mu2lin (Y, bps);
   else
     fclose (num);
     error ("loadaudio: unsupported extension");
   endif
 
   fclose (num);
 
 endfunction
diff --git a/scripts/audio/mu2lin.m b/scripts/audio/mu2lin.m
--- a/scripts/audio/mu2lin.m
+++ b/scripts/audio/mu2lin.m
@@ -13,32 +13,32 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} mu2lin (@var{x}, @var{bps})
+## @deftypefn {Function File} {} mu2lin (@var{x}, @var{n})
 ## Convert audio data from mu-law to linear.  Mu-law values are 8-bit
 ## unsigned integers.  Linear values use @var{n}-bit signed integers
 ## or floating point values in the range -1@leq{}y@leq{}1 if @var{n} is 0.  If
 ## @var{n} is not specified it defaults to 8.
 ## @seealso{lin2mu, loadaudio, saveaudio}
 ## @end deftypefn
 
 ## Author:  Andreas Weingessel <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 18 October 1994
 ## Adapted-By: jwe
 
 function y = mu2lin (x, n)
 
   if (nargin == 1)
-    ## COMPATIBILITY -- bps defaults to 8 for Octave, 0 for Matlab
+    ## COMPATIBILITY -- n defaults to 8 for Octave, 0 for Matlab
     n = 8;
   elseif (nargin == 2)
     if (n != 0 && n != 8 && n != 16)
       error ("mu2lin: n must be either 0, 8, or 16");
     endif
   else
     print_usage ();
   endif
diff --git a/scripts/audio/saveaudio.m b/scripts/audio/saveaudio.m
--- a/scripts/audio/saveaudio.m
+++ b/scripts/audio/saveaudio.m
@@ -26,64 +26,64 @@
 ## 8, respectively.
 ## @seealso{lin2mu, mu2lin, loadaudio, playaudio, setaudio, record}
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 5 September 1994
 ## Adapted-By: jwe
 
-function saveaudio (name, X, ext, bit)
+function saveaudio (name, x, ext, bps)
 
   if (nargin < 2 || nargin > 4)
     print_usage ();
   endif
 
   if (nargin == 2)
     ext = "lin";
   endif
 
   if (nargin < 4)
-    bit = 8;
-  elseif (bit != 8 && bit != 16)
-    error ("saveaudio: bit must be either 8 or 16");
+    bps = 8;
+  elseif (bps != 8 && bps != 16)
+    error ("saveaudio: bps must be either 8 or 16");
   endif
 
-  [nr, nc] = size (X);
+  [nr, nc] = size (x);
   if (nc != 1)
     if (nr == 1)
-      X = X';
+      x = x';
       nr = nc;
     else
       error ("saveaudio: X must be a vector");
     endif
   endif
 
   num = fopen ([name, ".", ext], "wb");
 
   if (strcmp (ext, "lin") || strcmp (ext, "raw"))
-    if (bit == 8)
-      ld = max (abs (X));
+    if (bps == 8)
+      ld = max (abs (x));
       if (ld > 127)   # convert 16 to 8 bit
         if (ld < 16384)
           sc = 64 / ld;
         else
           sc = 1 / 256;
         endif
-        X = fix (X * sc);
+        x = fix (x * sc);
       endif
-      X = X + 127;
-      c = fwrite (num, X, "uchar");
+      x = x + 127;
+      c = fwrite (num, x, "uchar");
     else
-      c = fwrite (num, X, "short");
+      c = fwrite (num, x, "short");
     endif
   elseif (strcmp (ext, "mu") || strcmp (ext, "au")
           || strcmp (ext, "snd") || strcmp (ext, "ul"))
-    Y = lin2mu (X);
-    c = fwrite (num, Y, "uchar");
+    y = lin2mu (x);
+    c = fwrite (num, y, "uchar");
   else
     fclose (num);
     error ("saveaudio: unsupported extension");
   endif
 
   fclose (num);
 
 endfunction
diff --git a/scripts/elfun/acot.m b/scripts/elfun/acot.m
--- a/scripts/elfun/acot.m
+++ b/scripts/elfun/acot.m
@@ -20,23 +20,23 @@
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} acot (@var{x})
 ## Compute the inverse cotangent in radians for each element of @var{x}.
 ## @seealso{cot, acotd}
 ## @end deftypefn
 
 ## Author: jwe
 
-function w = acot (z)
+function y = acot (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  w = atan (1./z);
+  y = atan (1./x);
 
 endfunction
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! x = [rt3, 1, rt3/3, 0, -rt3/3, -1, -rt3];
 %! v = [pi/6, pi/4, pi/3, pi/2, -pi/3, -pi/4, -pi/6];
diff --git a/scripts/elfun/acoth.m b/scripts/elfun/acoth.m
--- a/scripts/elfun/acoth.m
+++ b/scripts/elfun/acoth.m
@@ -20,23 +20,23 @@
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} acoth (@var{x})
 ## Compute the inverse hyperbolic cotangent of each element of @var{x}.
 ## @seealso{coth}
 ## @end deftypefn
 
 ## Author: jwe
 
-function w = acoth (z)
+function y = acoth (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  w = atanh (1 ./ z);
+  y = atanh (1 ./ x);
 
 endfunction
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! v = -i*[pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6];
 %! x = i*[rt3, 1, rt3/3, -rt3/3, -1, -rt3];
diff --git a/scripts/elfun/acsc.m b/scripts/elfun/acsc.m
--- a/scripts/elfun/acsc.m
+++ b/scripts/elfun/acsc.m
@@ -20,23 +20,23 @@
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} acsc (@var{x})
 ## Compute the inverse cosecant in radians for each element of @var{x}.
 ## @seealso{csc, acscd}
 ## @end deftypefn
 
 ## Author: jwe
 
-function w = acsc (z)
+function y = acsc (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  w = asin (1 ./ z);
+  y = asin (1 ./ x);
 
 endfunction
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! v = [pi/6, pi/4, pi/3, pi/2, pi/3, pi/4, pi/6];
 %! x = [2, rt2, 2*rt3/3, 1, 2*rt3/3, rt2, 2];
diff --git a/scripts/elfun/acsch.m b/scripts/elfun/acsch.m
--- a/scripts/elfun/acsch.m
+++ b/scripts/elfun/acsch.m
@@ -20,23 +20,23 @@
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} acsch (@var{x})
 ## Compute the inverse hyperbolic cosecant of each element of @var{x}.
 ## @seealso{csch}
 ## @end deftypefn
 
 ## Author: jwe
 
-function w = acsch (z)
+function y = acsch (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  w = asinh (1 ./ z);
+  y = asinh (1 ./ x);
 
 endfunction
 
 %!test
 %! v = [pi/2*i, -pi/2*i];
 %! x = [-i, i];
 %! assert(all (abs (acsch (x) - v) < sqrt (eps)));
 
diff --git a/scripts/elfun/asec.m b/scripts/elfun/asec.m
--- a/scripts/elfun/asec.m
+++ b/scripts/elfun/asec.m
@@ -20,23 +20,23 @@
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} asec (@var{x})
 ## Compute the inverse secant in radians for each element of @var{x}.
 ## @seealso{sec, asecd}
 ## @end deftypefn
 
 ## Author: jwe
 
-function w = asec (z)
+function y = asec (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  w = acos (1 ./ z);
+  y = acos (1 ./ x);
 
 endfunction
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! v = [0, pi/6, pi/4, pi/3, 2*pi/3, 3*pi/4, 5*pi/6, pi];
 %! x = [1, 2*rt3/3, rt2, 2, -2, -rt2, -2*rt3/3, -1];
diff --git a/scripts/elfun/asech.m b/scripts/elfun/asech.m
--- a/scripts/elfun/asech.m
+++ b/scripts/elfun/asech.m
@@ -20,23 +20,23 @@
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} asech (@var{x})
 ## Compute the inverse hyperbolic secant of each element of @var{x}.
 ## @seealso{sech}
 ## @end deftypefn
 
 ## Author: jwe
 
-function w = asech (z)
+function y = asech (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  w = acosh (1 ./ z);
+  y = acosh (1 ./ x);
 
 endfunction
 
 %!test
 %! v = [0, pi*i];
 %! x = [1, -1];
 %! assert(all (abs (asech (x) - v) < sqrt (eps)));
 
diff --git a/scripts/elfun/cot.m b/scripts/elfun/cot.m
--- a/scripts/elfun/cot.m
+++ b/scripts/elfun/cot.m
@@ -20,23 +20,23 @@
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} cot (@var{x})
 ## Compute the cotangent for each element of @var{x} in radians.
 ## @seealso{acot, cotd, coth}
 ## @end deftypefn
 
 ## Author: jwe
 
-function w = cot (z)
+function y = cot (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  w = 1 ./ tan(z);
+  y = 1 ./ tan(x);
 
 endfunction
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! x = [pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6];
 %! v = [rt3, 1, rt3/3, 0, -rt3/3, -1, -rt3];
diff --git a/scripts/elfun/coth.m b/scripts/elfun/coth.m
--- a/scripts/elfun/coth.m
+++ b/scripts/elfun/coth.m
@@ -20,23 +20,23 @@
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} coth (@var{x})
 ## Compute the hyperbolic cotangent of each element of @var{x}.
 ## @seealso{acoth}
 ## @end deftypefn
 
 ## Author: jwe
 
-function w = coth (z)
+function y = coth (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  w = 1 ./ tanh (z);
+  y = 1 ./ tanh (x);
 
 endfunction
 
 %!test
 %! x = [pi/2*i, 3*pi/2*i];
 %! v = [0, 0];
 %! assert(all (abs (coth (x) - v) < sqrt (eps)));
 
diff --git a/scripts/elfun/csc.m b/scripts/elfun/csc.m
--- a/scripts/elfun/csc.m
+++ b/scripts/elfun/csc.m
@@ -20,23 +20,23 @@
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} csc (@var{x})
 ## Compute the cosecant for each element of @var{x} in radians.
 ## @seealso{acsc, cscd, csch}
 ## @end deftypefn
 
 ## Author: jwe
 
-function w = csc (z)
+function y = csc (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  w = 1 ./ sin(z);
+  y = 1 ./ sin(x);
 
 endfunction
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! x = [pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6];
 %! v = [2, rt2, 2*rt3/3, 1, 2*rt3/3, rt2, 2];
diff --git a/scripts/elfun/csch.m b/scripts/elfun/csch.m
--- a/scripts/elfun/csch.m
+++ b/scripts/elfun/csch.m
@@ -20,23 +20,23 @@
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} csch (@var{x})
 ## Compute the hyperbolic cosecant of each element of @var{x}.
 ## @seealso{acsch}
 ## @end deftypefn
 
 ## Author: jwe
 
-function w = csch (z)
+function y = csch (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  w = 1 ./ sinh(z);
+  y = 1 ./ sinh(x);
 
 endfunction
 
 %!test
 %! x = [pi/2*i, 3*pi/2*i];
 %! v = [-i, i];
 %! assert(all (abs (csch (x) - v) < sqrt (eps)));
 
diff --git a/scripts/elfun/sec.m b/scripts/elfun/sec.m
--- a/scripts/elfun/sec.m
+++ b/scripts/elfun/sec.m
@@ -20,23 +20,23 @@
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} sec (@var{x})
 ## Compute the secant for each element of @var{x} in radians.
 ## @seealso{asec, secd, sech}
 ## @end deftypefn
 
 ## Author: jwe
 
-function w = sec (z)
+function y = sec (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  w = 1 ./ cos(z);
+  y = 1 ./ cos(x);
 
 endfunction
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! x = [0, pi/6, pi/4, pi/3, 2*pi/3, 3*pi/4, 5*pi/6, pi];
 %! v = [1, 2*rt3/3, rt2, 2, -2, -rt2, -2*rt3/3, -1];
diff --git a/scripts/elfun/sech.m b/scripts/elfun/sech.m
--- a/scripts/elfun/sech.m
+++ b/scripts/elfun/sech.m
@@ -20,23 +20,23 @@
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} sech (@var{x})
 ## Compute the hyperbolic secant of each element of @var{x}.
 ## @seealso{asech}
 ## @end deftypefn
 
 ## Author: jwe
 
-function w = sech (z)
+function y = sech (x)
 
 if (nargin != 1)
     print_usage ();
   endif
 
-  w = 1 ./ cosh(z);
+  y = 1 ./ cosh(x);
 
 endfunction
 
 %!test
 %! x = [0, pi*i];
 %! v = [1, -1];
 %! assert(all (abs (sech (x) - v) < sqrt (eps)));
 
diff --git a/scripts/general/accumarray.m b/scripts/general/accumarray.m
--- a/scripts/general/accumarray.m
+++ b/scripts/general/accumarray.m
@@ -59,17 +59,17 @@
 ## case).
 ## If @var{func} is one of @code{@@sum} (default), @code{@@max}, @code{@@min}
 ## or @code{@@(x) @{x@}}, an optimized code path is used. 
 ## Note that for general reduction function the interpreter overhead can play a
 ## major part and it may be more efficient to do multiple accumarray calls and
 ## compute the results in a vectorized manner.
 ## @end deftypefn
 
-function A = accumarray (subs, val, sz = [], func = [], fillval = [], isspar = [])  
+function A = accumarray (subs, vals, sz = [], func = [], fillval = [], issparse = [])  
 
   if (nargin < 2 || nargin > 6)
     print_usage ();
   endif
 
   if (iscell (subs))
     subs = cellfun (@vec, subs, "uniformoutput", false);
     ndims = numel (subs);
@@ -79,21 +79,21 @@ function A = accumarray (subs, val, sz =
   else
     ndims = columns (subs);
   endif
 
   if (isempty (fillval))
     fillval = 0;
   endif
 
-  if (isempty (isspar))
-    isspar = false;
+  if (isempty (issparse))
+    issparse = false;
   endif
 
-  if (isspar)
+  if (issparse)
 
     ## Sparse case. Avoid linearizing the subscripts, because it could overflow.
 
     if (fillval != 0)
       error ("accumarray: fillval must be zero in the sparse case");
     endif
 
     ## Ensure subscripts are a two-column matrix.
@@ -103,46 +103,46 @@ function A = accumarray (subs, val, sz =
 
     ## Validate dimensions.
     if (ndims == 1)
       subs(:,2) = 1;
     elseif (ndims != 2)
       error ("accumarray: in the sparse case, needs 1 or 2 subscripts");
     endif
 
-    if (isnumeric (val) || islogical (val))
-      vals = double (val);
+    if (isnumeric (vals) || islogical (vals))
+      vals = double (vals);
     else
       error ("accumarray: in the sparse case, values must be numeric or logical");
     endif
 
     if (! (isempty (func) || func == @sum))
 
       ## Reduce values. This is not needed if we're about to sum them, because
       ## "sparse" can do that.
       
       ## Sort indices.
       [subs, idx] = sortrows (subs);
       n = rows (subs);
       ## Identify runs.
       jdx = find (any (diff (subs, 1, 1), 2));
       jdx = [jdx; n];
 
-      val = cellfun (func, mat2cell (val(:)(idx), diff ([0; jdx])));
+      vals = cellfun (func, mat2cell (vals(:)(idx), diff ([0; jdx])));
       subs = subs(jdx, :);
       mode = "unique";
     else
       mode = "sum";
     endif
 
     ## Form the sparse matrix.
     if (isempty (sz))
-      A = sparse (subs(:,1), subs(:,2), val, mode);
+      A = sparse (subs(:,1), subs(:,2), vals, mode);
     elseif (length (sz) == 2)
-      A = sparse (subs(:,1), subs(:,2), val, sz(1), sz(2), mode);
+      A = sparse (subs(:,1), subs(:,2), vals, sz(1), sz(2), mode);
     else
       error ("accumarray: dimensions mismatch")
     endif
 
   else
 
     ## Linearize subscripts.
     if (ndims > 1)
@@ -168,113 +168,113 @@ function A = accumarray (subs, val, sz =
     endif
 
 
     ## Some built-in reductions handled efficiently.
 
     if (isempty (func) || func == @sum)
       ## Fast summation.
       if (isempty (sz))
-        A = __accumarray_sum__ (subs, val);
+        A = __accumarray_sum__ (subs, vals);
       else
-        A = __accumarray_sum__ (subs, val, prod (sz));
+        A = __accumarray_sum__ (subs, vals, prod (sz));
         ## set proper shape.
         A = reshape (A, sz);
       endif
 
       ## we fill in nonzero fill value.
       if (fillval != 0)
         mask = true (size (A));
         mask(subs) = false;
         A(mask) = fillval;
       endif
     elseif (func == @max)
       ## Fast maximization.
 
-      if (isinteger (val))
-        zero = intmin (class (val));
-      elseif (islogical (val))
+      if (isinteger (vals))
+        zero = intmin (class (vals));
+      elseif (islogical (vals))
         zero = false;
-      elseif (fillval == 0 && all (val(:) >= 0))
+      elseif (fillval == 0 && all (vals(:) >= 0))
         ## This is a common case - fillval is zero, all numbers nonegative.
         zero = 0;
       else
         zero = NaN; # Neutral value.
       endif
 
       if (isempty (sz))
-        A = __accumarray_max__ (subs, val, zero);
+        A = __accumarray_max__ (subs, vals, zero);
       else
-        A = __accumarray_max__ (subs, val, zero, prod (sz));
+        A = __accumarray_max__ (subs, vals, zero, prod (sz));
         A = reshape (A, sz);
       endif
 
       if (fillval != zero && ! (isnan (fillval) || isnan (zero)))
         mask = true (size (A));
         mask(subs) = false;
         A(mask) = fillval;
       endif
     elseif (func == @min)
       ## Fast minimization.
 
-      if (isinteger (val))
-        zero = intmax (class (val));
-      elseif (islogical (val))
+      if (isinteger (vals))
+        zero = intmax (class (vals));
+      elseif (islogical (vals))
         zero = true;
       else
         zero = NaN; # Neutral value.
       endif
 
       if (isempty (sz))
-        A = __accumarray_min__ (subs, val, zero);
+        A = __accumarray_min__ (subs, vals, zero);
       else
-        A = __accumarray_min__ (subs, val, zero, prod (sz));
+        A = __accumarray_min__ (subs, vals, zero, prod (sz));
         A = reshape (A, sz);
       endif
 
       if (fillval != zero && ! (isnan (fillval) || isnan (zero)))
         mask = true (size (A));
         mask(subs) = false;
         A(mask) = fillval;
       endif
     else
 
       ## The general case. Reduce values. 
       n = rows (subs);
-      if (numel (val) == 1)
-        val = val(ones (1, n), 1);
+      if (numel (vals) == 1)
+        vals = vals(ones (1, n), 1);
       else
-        val = val(:);
+        vals = vals(:);
       endif
       
       ## Sort indices.
       [subs, idx] = sort (subs);
       ## Identify runs.
       jdx = find (subs(1:n-1) != subs(2:n));
       jdx = [jdx; n];
-      val = mat2cell (val(idx), diff ([0; jdx]));
+      vals = mat2cell (vals(idx), diff ([0; jdx]));
       ## Optimize the case when function is @(x) {x}, i.e. we just want to
       ## collect the values to cells.
       persistent simple_cell_str = func2str (@(x) {x});
       if (! strcmp (func2str (func), simple_cell_str))
-        val = cellfun (func, val);
+        vals = cellfun (func, vals);
       endif
       subs = subs(jdx);
 
       ## Construct matrix of fillvals.
-      if (iscell (val))
+      if (iscell (vals))
         A = cell (sz);
       elseif (fillval == 0)
-        A = zeros (sz, class (val));
+        A = zeros (sz, class (vals));
       else
         A = repmat (fillval, sz);
       endif
 
       ## Set the reduced values.
-      A(subs) = val;
+      A(subs) = vals;
     endif
   endif
 endfunction
 
 %!error (accumarray (1:5))
 %!error (accumarray ([1,2,3],1:2))
 %!assert (accumarray ([1;2;4;2;4],101:105), [101;206;0;208])
 %!assert (accumarray ([1,1,1;2,1,2;2,3,2;2,1,2;2,3,2],101:105),cat(3, [101,0,0;0,0,0],[0,0,0;206,0,208]))
@@ -284,26 +284,26 @@ endfunction
 %!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105,[2 4],@prod,0,true),sparse([1,2,2],[1,1,3],[101,10608,10815],2,4))
 %!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],1,[2,4]), [1,0,0,0;2,0,2,0])
 %!assert (accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105,[2,4],@(x)length(x)>1),[false,false,false,false;true,false,true,false])
 %!test
 %! A = accumarray ([1 1; 2 1; 2 3; 2 1; 2 3],101:105,[2,4],@(x){x});
 %! assert (A{2},[102;104])
 %!test
 %! subs = ceil (rand (2000, 3)*10);
-%! val = rand (2000, 1);
-%! assert (accumarray (subs, val, [], @max), accumarray (subs, val, [], @(x) max (x)));
+%! vals = rand (2000, 1);
+%! assert (accumarray (subs, vals, [], @max), accumarray (subs, vals, [], @(x) max (x)));
 %!test
 %! subs = ceil (rand (2000, 1)*100);
-%! val = rand (2000, 1);
-%! assert (accumarray (subs, val, [100, 1], @min, NaN), accumarray (subs, val, [100, 1], @(x) min (x), NaN));
+%! vals = rand (2000, 1);
+%! assert (accumarray (subs, vals, [100, 1], @min, NaN), accumarray (subs, vals, [100, 1], @(x) min (x), NaN));
 %!test
 %! subs = ceil (rand (2000, 2)*30);
 %! subsc = num2cell (subs, 1);
-%! val = rand (2000, 1);
-%! assert (accumarray (subsc, val, [], [], 0, true), accumarray (subs, val, [], [], 0, true));
+%! vals = rand (2000, 1);
+%! assert (accumarray (subsc, vals, [], [], 0, true), accumarray (subs, vals, [], [], 0, true));
 %!test
 %! subs = ceil (rand (2000, 3)*10);
 %! subsc = num2cell (subs, 1);
-%! val = rand (2000, 1);
-%! assert (accumarray (subsc, val, [], @max), accumarray (subs, val, [], @max));
+%! vals = rand (2000, 1);
+%! assert (accumarray (subsc, vals, [], @max), accumarray (subs, vals, [], @max));
 
 
diff --git a/scripts/general/accumdim.m b/scripts/general/accumdim.m
--- a/scripts/general/accumdim.m
+++ b/scripts/general/accumdim.m
@@ -47,17 +47,17 @@
 ## accumdim ([1, 2, 1, 2, 1], [7,-10,4;-5,-12,8;-12,2,8;-10,9,-3;-5,-3,-13])
 ## @result{} ans = [-10,-11,-1;-15,-3,5]
 ## @end group
 ## @end example
 ##
 ## @seealso{accumarray}
 ## @end deftypefn
 
-function A = accumdim (subs, val, dim, n = 0, func = [], fillval = 0)
+function A = accumdim (subs, vals, dim, n = 0, func = [], fillval = 0)
 
   if (nargin < 2 || nargin > 5)
     print_usage ();
   endif
 
   if (isempty (fillval))
     fillval = 0;
   endif
@@ -70,30 +70,30 @@ function A = accumdim (subs, val, dim, n
     m = max (subs);
     if (n == 0)
       n = m;
     elseif (n < m)
       error ("accumdim: N index out of range")
     endif
   endif
 
-  sz = size (val);
+  sz = size (vals);
 
   if (nargin < 3)
     [~, dim] = max (sz != 1); # first non-singleton dim
   elseif (! isindex (dim))
     error ("accumdim: DIM must be a valid dimension");
   elseif (dim > length (sz))
     sz(end+1:dim) = 1;
   endif
   sz(dim) = n;
  
   if (isempty (func) || func == @sum)
     ## Fast summation case.
-    A = __accumdim_sum__ (subs, val, dim, n);
+    A = __accumdim_sum__ (subs, vals, dim, n);
     
     ## Fill in nonzero fill value
     if (fillval != 0)
       mask = true (n, 1);
       mask(subs) = false;
       subsc = {':'}(ones (1, length (sz)));
       subsc{dim} = mask;
       A(subsc{:}) = fillval;
@@ -108,38 +108,38 @@ function A = accumdim (subs, val, dim, n
   ## Identify runs.
   jdx = find (subs(1:ns-1) != subs(2:ns));
   jdx = [jdx; ns];
   ## Collect common slices.
   szc = num2cell (sz);
   szc{dim} = diff ([0; jdx]);
   subsc = {':'}(ones (1, length (sz)));
   subsc{dim} = idx;
-  val = mat2cell (val(subsc{:}), szc{:});
+  vals = mat2cell (vals(subsc{:}), szc{:});
   ## Apply reductions. Special case min, max.
   if (func == @min || func == @max)
-    val = cellfun (func, val, {[]}, {dim}, "uniformoutput", false);
+    vals = cellfun (func, vals, {[]}, {dim}, "uniformoutput", false);
   else
-    val = cellfun (func, val, {dim}, "uniformoutput", false);
+    vals = cellfun (func, vals, {dim}, "uniformoutput", false);
   endif
   subs = subs(jdx);
 
   ## Concatenate reduced slices.
-  val = cat (dim, val{:});
+  vals = cat (dim, vals{:});
 
   ## Construct matrix of fillvals.
   if (fillval == 0)
-    A = zeros (sz, class (val));
+    A = zeros (sz, class (vals));
   else
     A = repmat (fillval, sz);
   endif
 
   ## Set the reduced values.
   subsc{dim} = subs;
-  A(subsc{:}) = val;
+  A(subsc{:}) = vals;
 
 endfunction
 
 %%test accumdim vs. accumarray
 
 %!shared a
 %! a = rand (5, 5, 5);
 
diff --git a/scripts/general/bitcmp.m b/scripts/general/bitcmp.m
--- a/scripts/general/bitcmp.m
+++ b/scripts/general/bitcmp.m
@@ -12,110 +12,112 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} bitcmp (@var{a}, @var{k})
-## Return the @var{k}-bit complement of integers in @var{a}.  If
+## @deftypefn {Function File} {} bitcmp (@var{A}, @var{k})
+## Return the @var{k}-bit complement of integers in @var{A}.  If
 ## @var{k} is omitted @code{k = log2 (bitmax) + 1} is assumed.
 ##
 ## @example
 ## @group
 ## bitcmp(7,4)
 ## @result{} 8
 ## dec2bin(11)
 ## @result{} 1011
 ## dec2bin(bitcmp(11, 6))
 ## @result{} 110100
 ## @end group
 ## @end example
 ## @seealso{bitand, bitor, bitxor, bitset, bitget, bitcmp, bitshift, bitmax}
 ## @end deftypefn
 
-## Liberally based of the version by Kai Habel from octave-forge
+## Liberally based on the version by Kai Habel from octave-forge
 
-function x = bitcmp (a, n)
+function C = bitcmp (A, k)
   
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
-  if (nargin == 2 && (! isscalar (n) || (floor (n) != n)))
+  if (nargin == 2 && (! isscalar (k) || (floor (k) != k)))
     error ("bitcmp: k must be a scalar integer");
   endif
 
-  if (isa (a, "double"))
+  if (isa (A, "double"))
     bmax = bitmax;
     amax = ceil (log2 (bmax));
   else
-    if (isa (a, "uint8"))
+    if (isa (A, "uint8"))
       amax = 8;
-    elseif (isa (a, "uint16"))
+    elseif (isa (A, "uint16"))
       amax = 16;
-    elseif (isa (a, "uint32"))
+    elseif (isa (A, "uint32"))
       amax = 32;
-    elseif (isa (a, "uint64"))
+    elseif (isa (A, "uint64"))
       amax = 64;
-    elseif (isa (a, "int8"))
+    elseif (isa (A, "int8"))
       amax = 8;
-    elseif (isa (a, "int16"))
+    elseif (isa (A, "int16"))
       amax = 16;
-    elseif (isa (a, "int32"))
+    elseif (isa (A, "int32"))
       amax = 32;
-    elseif (isa (a, "int64"))
+    elseif (isa (A, "int64"))
       amax = 64;
     else
-      error ("bitcmp: invalid class %s", class (a));
+      error ("bitcmp: invalid class %s", class (A));
     endif
-    bmax = intmax (class (a));
+    bmax = intmax (class (A));
   endif
 
-  if (nargin == 1 || n == amax)
-    x = bitxor (a, bmax);
+  if (nargin == 1 || k == amax)
+    C = bitxor (A, bmax);
   else
-    m = double (n);
+    m = double (k);
     if (any (m < 1) || any (m > amax))
-      error ("bitcmp: n must be in the range [1,%d]", amax);
+      error ("bitcmp: k must be in the range [1,%d]", amax);
     endif
-    mask = bitshift (bmax, n - amax);
-    x = bitxor (bitand (a, mask), mask);
+    mask = bitshift (bmax, k - amax);
+    C = bitxor (bitand (A, mask), mask);
   endif
 endfunction
 
-%!shared Amax,Bmax,A
+
+%!test
 %! Amax=53;
 %! Bmax = bitmax;
 %! A = bitshift(Bmax,-2);
-%!assert(bitcmp(A,Amax),bitor(bitshift(1,Amax-1),bitshift(1,Amax-2)));
-%!assert(bitcmp(A,Amax-1),bitshift(1,Amax-2));
-%!assert(bitcmp(A,Amax-2),0);
-%!shared Amax,Bmax,A
+%! assert(bitcmp(A,Amax),bitor(bitshift(1,Amax-1),bitshift(1,Amax-2)));
+%! assert(bitcmp(A,Amax-1),bitshift(1,Amax-2));
+%! assert(bitcmp(A,Amax-2),0);
+%!test
 %! Amax=8;
 %! Bmax = intmax('uint8');
 %! A = bitshift(Bmax,-2);
-%!assert(bitcmp(A,Amax),bitor(bitshift(uint8(1),Amax-1),bitshift(uint8(1),Amax-2)));
-%!assert(bitcmp(A,Amax-1),bitshift(uint8(1),Amax-2));
-%!assert(bitcmp(A,Amax-2),uint8(0));
-%!shared Amax,Bmax,A
+%! assert(bitcmp(A,Amax),bitor(bitshift(uint8(1),Amax-1),bitshift(uint8(1),Amax-2)));
+%! assert(bitcmp(A,Amax-1),bitshift(uint8(1),Amax-2));
+%! assert(bitcmp(A,Amax-2),uint8(0));
+%!test
 %! Amax=16;
 %! Bmax = intmax('uint16');
 %! A = bitshift(Bmax,-2);
-%!assert(bitcmp(A,Amax),bitor(bitshift(uint16(1),Amax-1),bitshift(uint16(1),Amax-2)));
-%!assert(bitcmp(A,Amax-1),bitshift(uint16(1),Amax-2));
-%!assert(bitcmp(A,Amax-2),uint16(0));
-%!shared Amax,Bmax,A
+%! assert(bitcmp(A,Amax),bitor(bitshift(uint16(1),Amax-1),bitshift(uint16(1),Amax-2)));
+%! assert(bitcmp(A,Amax-1),bitshift(uint16(1),Amax-2));
+%! assert(bitcmp(A,Amax-2),uint16(0));
+%!test
 %! Amax=32;
 %! Bmax = intmax('uint32');
 %! A = bitshift(Bmax,-2);
-%!assert(bitcmp(A,Amax),bitor(bitshift(uint32(1),Amax-1),bitshift(uint32(1),Amax-2)));
-%!assert(bitcmp(A,Amax-1),bitshift(uint32(1),Amax-2));
-%!assert(bitcmp(A,Amax-2),uint32(0));
-%!shared Amax,Bmax,A
+%! assert(bitcmp(A,Amax),bitor(bitshift(uint32(1),Amax-1),bitshift(uint32(1),Amax-2)));
+%! assert(bitcmp(A,Amax-1),bitshift(uint32(1),Amax-2));
+%! assert(bitcmp(A,Amax-2),uint32(0));
+%!test
 %! Amax=64;
 %! Bmax = intmax('uint64');
 %! A = bitshift(Bmax,-2);
-%!assert(bitcmp(A,Amax),bitor(bitshift(uint64(1),Amax-1),bitshift(uint64(1),Amax-2)));
-%!assert(bitcmp(A,Amax-1),bitshift(uint64(1),Amax-2));
-%!assert(bitcmp(A,Amax-2),uint64(0));
+%! assert(bitcmp(A,Amax),bitor(bitshift(uint64(1),Amax-1),bitshift(uint64(1),Amax-2)));
+%! assert(bitcmp(A,Amax-1),bitshift(uint64(1),Amax-2));
+%! assert(bitcmp(A,Amax-2),uint64(0));
+
diff --git a/scripts/general/bitget.m b/scripts/general/bitget.m
--- a/scripts/general/bitget.m
+++ b/scripts/general/bitget.m
@@ -12,32 +12,32 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{X} =} bitget (@var{a},@var{n})
-## Return the status of bit(s) @var{n} of unsigned integers in @var{a}
+## @deftypefn {Function File} {@var{c} =} bitget (@var{A},@var{n})
+## Return the status of bit(s) @var{n} of unsigned integers in @var{A}
 ## the lowest significant bit is @var{n} = 1.
 ##
 ## @example
 ## @group
 ## bitget (100, 8:-1:1)
 ## @result{} 0  1  1  0  0  1  0  0 
 ## @end group
 ## @end example
 ## @seealso{bitand, bitor, bitxor, bitset, bitcmp, bitshift, bitmax}
 ## @end deftypefn
 
 ## Liberally based of the version by Kai Habel from octave-forge
 
-function X = bitget (A, n)
+function C = bitget (A, n)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (isa (A, "double"))
     Amax = log2 (bitmax) + 1;
     _conv = @double;
@@ -71,10 +71,11 @@ function X = bitget (A, n)
     endif
   endif
 
   m = double (n(:));
   if (any (m < 1) || any (m > Amax))
     error ("bitget: n must be in the range [1,%d]", Amax);
   endif
 
-  X = bitand (A, bitshift (_conv (1), uint8 (n) - uint8 (1))) != _conv (0);
+  C = bitand (A, bitshift (_conv (1), uint8 (n) - uint8 (1))) != _conv (0);
+
 endfunction
diff --git a/scripts/general/bitset.m b/scripts/general/bitset.m
--- a/scripts/general/bitset.m
+++ b/scripts/general/bitset.m
@@ -12,41 +12,41 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{x} =} bitset (@var{a}, @var{n})
-## @deftypefnx {Function File} {@var{x} =} bitset (@var{a}, @var{n}, @var{v})
-## Set or reset bit(s) @var{n} of unsigned integers in @var{a}.
-## @var{v} = 0 resets and @var{v} = 1 sets the bits.
+## @deftypefn  {Function File} {@var{C} =} bitset (@var{A}, @var{n})
+## @deftypefnx {Function File} {@var{C} =} bitset (@var{A}, @var{n}, @var{val})
+## Set or reset bit(s) @var{n} of unsigned integers in @var{A}.
+## @var{val} = 0 resets and @var{val} = 1 sets the bits.
 ## The lowest significant bit is: @var{n} = 1
 ##
 ## @example
 ## @group
 ## dec2bin (bitset (10, 1))
 ## @result{} 1011
 ## @end group
 ## @end example
 ## @seealso{bitand, bitor, bitxor, bitget, bitcmp, bitshift, bitmax}
 ## @end deftypefn
 
-## Liberally based of the version by Kai Habel from octave-forge
+## Liberally based on the version by Kai Habel from octave-forge
 
-function X = bitset (A, n, value)
+function C = bitset (A, n, val)
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
   if (nargin == 2)
-    value = 1;
+    val = 1;
   endif
   
   if (isa (A, "double"))
     Bmax = bitmax;
     Amax = log2 (Bmax) + 1;
     _conv = @double;
   else
     if (isa (A, "uint8"))
@@ -80,15 +80,15 @@ function X = bitset (A, n, value)
   endif
 
   m = double (n(:));
   if (any (m < 1) || any (m > Amax))
     error ("bitset: n must be in the range [1,%d]", Amax);
   endif
 
   mask = bitshift (_conv (1), uint8 (n) - uint8 (1));
-  X = bitxor (A, bitand (A, mask));
+  C = bitxor (A, bitand (A, mask));
 
-  if (value)
-    X = bitor (A, mask);
+  if (val)
+    C = bitor (A, mask);
   endif
 
 endfunction
diff --git a/scripts/general/chop.m b/scripts/general/chop.m
--- a/scripts/general/chop.m
+++ b/scripts/general/chop.m
@@ -12,32 +12,32 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} chop (@var{x}, @var{d}, @var{u})
-## Truncate elements of @var{x} to @var{d} digits such that the
-## resulting digits are exactly divisible by @var{u}.  If @var{u} is not
+## @deftypefn {Function File} {} chop (@var{x}, @var{ndigits}, @var{base})
+## Truncate elements of @var{x} to a length of @var{ndigits} such that the
+## resulting numbers are exactly divisible by @var{base}.  If @var{base} is not
 ## specified it defaults to 10.
 ##
 ## @example
 ## @group
 ## chop (-pi, 5, 10)
 ##      @result{} -3.14200000000000
 ## chop (-pi, 5, 5)
 ##      @result{} -3.14150000000000
 ## @end group
 ## @end example
 ## @end deftypefn
 
-function retval = chop (x, digits, units = 10)
+function retval = chop (x, ndigits, base = 10)
 
   if (nargin == 2 || nargin == 3)
     tmp = abs (x);
 
     ## Avoid computing log (0).
     tmp(x == 0) = 1;
 
     ## Digits to the left of the decimal.
@@ -45,33 +45,34 @@ function retval = chop (x, digits, units
 
     ## The expression
     ##
     ##   round (x .* inflate)
     ##
     ## produces an integer that contains the digits we want to keep.
     ## Multiplying by deflate puts the decimal back where it belngs.
     ##
-    ## Further scaling and rounding with the units factor produces a
-    ## value with digits exactly divisible by units.  We skip that step
-    ## unless units was explicitly provided.
+    ## Further scaling and rounding with the base factor produces a
+    ## value with ndigits exactly divisible by base.  We skip that step
+    ## unless base was explicitly provided.
 
-    inflate = 10 .^ (digits - tmp);
-    deflate = 10 .^ (tmp - digits);
+    inflate = 10 .^ (ndigits - tmp);
+    deflate = 10 .^ (tmp - ndigits);
     if (nargin == 2)
       retval = deflate .* round (x .* inflate);
     else
-      retval = units .* deflate .* round (round (x .* inflate) ./ units);
+      retval = base .* deflate .* round (round (x .* inflate) ./ base);
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!assert (chop (e, 3), 2.72)
 %!assert (chop (e, 4), 2.718)
 %!assert (chop (e, 4, 5), 2.72)
 %!assert (chop (e, 4, 7), 2.716)
 %!assert (chop (-e, 3), -2.72)
 %!assert (chop (-e, 4), -2.718)
 %!assert (chop (-e, 4, 5), -2.72)
 %!assert (chop (-e, 4, 7), -2.716)
diff --git a/scripts/general/del2.m b/scripts/general/del2.m
--- a/scripts/general/del2.m
+++ b/scripts/general/del2.m
@@ -13,28 +13,28 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{d} =} del2 (@var{m})
-## @deftypefnx {Function File} {@var{d} =} del2 (@var{m}, @var{h})
-## @deftypefnx {Function File} {@var{d} =} del2 (@var{m}, @var{dx}, @var{dy}, @dots{})
+## @deftypefn  {Function File} {@var{d} =} del2 (@var{M})
+## @deftypefnx {Function File} {@var{d} =} del2 (@var{M}, @var{h})
+## @deftypefnx {Function File} {@var{d} =} del2 (@var{M}, @var{dx}, @var{dy}, @dots{})
 ##
 ## Calculate the discrete Laplace
 ## @tex
 ## operator $( \nabla^2 )$.
 ## @end tex
 ## @ifnottex
 ## operator.
 ## @end ifnottex
-## For a 2-dimensional matrix @var{m} this is defined as
+## For a 2-dimensional matrix @var{M} this is defined as
 ## @tex
 ## $$d = {1 \over 4} \left( {d^2 \over dx^2} M(x,y) + {d^2 \over dy^2} M(x,y) \right)$$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
 ##       1    / d^2            d^2         \
@@ -48,17 +48,17 @@
 ## derivatives over the additional higher dimensions.
 ##
 ## The spacing between evaluation points may be defined by @var{h}, which is a
 ## scalar defining the equidistant spacing in all dimensions.  Alternatively, 
 ## the spacing in each dimension may be defined separately by @var{dx},
 ## @var{dy}, etc.  A scalar spacing argument defines equidistant spacing, 
 ## whereas a vector argument can be used to specify variable spacing.  The
 ## length of the spacing vectors must match the respective dimension of
-## @var{m}.  The default spacing value is 1.
+## @var{M}.  The default spacing value is 1.
 ##
 ## At least 3 data points are needed for each dimension.  Boundary points are
 ## calculated from the linear extrapolation of interior points.
 ##
 ## @seealso{gradient, diff}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
diff --git a/scripts/general/int2str.m b/scripts/general/int2str.m
--- a/scripts/general/int2str.m
+++ b/scripts/general/int2str.m
@@ -43,37 +43,37 @@
 ##
 ## This function is not very flexible.  For better control over the
 ## results, use @code{sprintf} (@pxref{Formatted Output}). 
 ## @seealso{sprintf, num2str, mat2str}
 ## @end deftypefn
 
 ## Author: jwe
 
-function retval = int2str (x)
+function retval = int2str (n)
 
   if (nargin == 1)
-    x = round (real(x));
-    sz = size(x);
-    nd = ndims (x);
-    nc = columns (x);
+    n = round (real(n));
+    sz = size(n);
+    nd = ndims (n);
+    nc = columns (n);
     if (nc > 1)
       idx = cell ();
       for i = 1:nd
         idx{i} = 1:sz(i);
       endfor
       idx(2) = 1;
-      ifmt = get_fmt (x(idx{:}), 0);
+      ifmt = get_fmt (n(idx{:}), 0);
       idx(2) = 2:sz(2);
-      rfmt = get_fmt (x(idx{:}), 2);
+      rfmt = get_fmt (n(idx{:}), 2);
       fmt = cstrcat (ifmt, repmat (rfmt, 1, nc-1), "\n");
     else
-      fmt = cstrcat (get_fmt (x, 0), "\n");
+      fmt = cstrcat (get_fmt (n, 0), "\n");
     endif
-    tmp = sprintf (fmt, permute (x, [2, 1, 3 : nd]));
+    tmp = sprintf (fmt, permute (n, [2, 1, 3 : nd]));
     tmp(end) = "";
     retval = char (strsplit (tmp, "\n"));
   else
     print_usage ();
   endif
 
 endfunction
 
diff --git a/scripts/general/isdir.m b/scripts/general/isdir.m
--- a/scripts/general/isdir.m
+++ b/scripts/general/isdir.m
@@ -17,16 +17,16 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} isdir (@var{f})
 ## Return true if @var{f} is a directory.
 ## @seealso{is_absolute_filename, is_rooted_relative_filename}
 ## @end deftypefn
 
-function t = isdir (x)
+function retval = isdir (f)
   if (nargin == 1)
     ## Exist returns an integer but isdir should return a logical.
-    t = exist (x, "dir") == 7;
+    retval = (exist (f, "dir") == 7);
   else
     print_usage ("isdir");
   endif
 endfunction
diff --git a/scripts/general/isequal.m b/scripts/general/isequal.m
--- a/scripts/general/isequal.m
+++ b/scripts/general/isequal.m
@@ -17,20 +17,20 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} isequal (@var{x1}, @var{x2}, @dots{})
 ## Return true if all of @var{x1}, @var{x2}, @dots{} are equal.
 ## @seealso{isequalwithequalnans}
 ## @end deftypefn
 
-function retval = isequal (x, varargin)
+function retval = isequal (x1, varargin)
 
   if (nargin > 1)
-    retval = __isequal__ (false, x, varargin{:});
+    retval = __isequal__ (false, x1, varargin{:});
   else
     print_usage ();
   endif
 
 endfunction
 
 ## test size and shape
 %!assert(isequal([1,2,3,4],[1,2,3,4]), true)
diff --git a/scripts/general/isequalwithequalnans.m b/scripts/general/isequalwithequalnans.m
--- a/scripts/general/isequalwithequalnans.m
+++ b/scripts/general/isequalwithequalnans.m
@@ -18,20 +18,20 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} isequalwithequalnans (@var{x1}, @var{x2}, @dots{})
 ## Assuming NaN == NaN, return true if all of @var{x1}, @var{x2}, @dots{}
 ## are equal.
 ## @seealso{isequal}
 ## @end deftypefn
 
-function retval = isequalwithequalnans (x, varargin)
+function retval = isequalwithequalnans (x1, varargin)
 
   if (nargin > 1)
-    retval = __isequal__ (true, x, varargin{:});
+    retval = __isequal__ (true, x1, varargin{:});
   else
     print_usage ();
   endif
 
 endfunction
 
 ## test for equality
 %!assert(isequalwithequalnans({1,2,NaN,4},{1,2,NaN,4}), true)
diff --git a/scripts/general/logspace.m b/scripts/general/logspace.m
--- a/scripts/general/logspace.m
+++ b/scripts/general/logspace.m
@@ -56,36 +56,35 @@
 ##
 ## Also for compatibility with @sc{matlab}, return the second argument if 
 ## fewer than two values are requested.
 ## @seealso{linspace}
 ## @end deftypefn
 
 ## Author: jwe
 
-function retval = logspace (x1, x2, n)
+function retval = logspace (base, limit, n)
 
   if (nargin == 2)
     npoints = 50;
   elseif (nargin == 3)
     if (length (n) == 1)
       npoints = fix (n);
     else
       error ("logspace: arguments must be scalars");
     endif
   else
     print_usage ();
   endif
 
-  if (length (x1) == 1 && length (x2) == 1)
-    x2_tmp = x2;
-    if (x2 == pi)
-      x2_tmp = log10 (pi);
+  if (length (base) == 1 && length (limit) == 1)
+    if (limit == pi)
+      limit = log10 (pi);
     endif
-    retval = 10 .^ (linspace (x1, x2_tmp, npoints));
+    retval = 10 .^ (linspace (base, limit, npoints));
   else
     error ("logspace: arguments must be scalars");
   endif
 
 endfunction
 
 %!test
 %! x1 = logspace (1, 2);
diff --git a/scripts/general/perror.m b/scripts/general/perror.m
--- a/scripts/general/perror.m
+++ b/scripts/general/perror.m
@@ -13,27 +13,27 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} perror (@var{name}, @var{num})
-## Print the error message for function @var{name} corresponding to the
+## @deftypefn {Function File} {} perror (@var{funcname}, @var{num})
+## Print the error message for function @var{funcname} corresponding to the
 ## error number @var{num}.  This function is intended to be used to print
 ## useful error messages for those functions that return numeric error
 ## codes.
 ## @seealso{strerror}
 ## @end deftypefn
 
 ## Author: jwe
 
-function perror (name, err)
+function perror (funcname, num)
 
   if (nargin != 2)
     print_usage ();
   else
-    printf (strerror (name, err));
+    printf (strerror (funcname, num));
   endif
 
 endfunction
diff --git a/scripts/general/repmat.m b/scripts/general/repmat.m
--- a/scripts/general/repmat.m
+++ b/scripts/general/repmat.m
@@ -25,17 +25,17 @@
 ## @var{A} as each element.  If @var{n} is not specified, form an 
 ## @var{m} by @var{m} block matrix.
 ## @seealso{repelems}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@kienzle.powernet.co.uk>
 ## Created: July 2000
 
-function x = repmat (a, m, n)
+function x = repmat (A, m, n)
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
   if (nargin == 3)
     if (! (isscalar (m) && isscalar (n)))
       error ("repmat: with 3 arguments m and n must be scalar");
@@ -54,51 +54,51 @@ function x = repmat (a, m, n)
   endif
   
   if (all (idx < 0))
     error ("repmat: invalid dimensions");
   else
     idx = max (idx, 0);
   endif
 
-  if (numel (a) == 1)
+  if (numel (A) == 1)
     ## optimize the scalar fill case.
     if (any (idx == 0))
-      x = resize (a, idx);
+      x = resize (A, idx);
     else
-      x(1:prod (idx)) = a;
+      x(1:prod (idx)) = A;
       x = reshape (x, idx);
     endif
-  elseif (ndims (a) == 2 && length (idx) < 3)
-    if (issparse (a))
-      x = kron (ones (idx), a);
+  elseif (ndims (A) == 2 && length (idx) < 3)
+    if (issparse (A))
+      x = kron (ones (idx), A);
     else
       ## indexing is now faster, so we use it rather than kron.
-      m = rows (a); n = columns (a);
+      m = rows (A); n = columns (A);
       p = idx(1); q = idx(2);
-      x = reshape (a, m, 1, n, 1);
+      x = reshape (A, m, 1, n, 1);
       x = x(:, ones (1, p), :, ones (1, q));
       x = reshape (x, m*p, n*q);
     endif
   else
-    aidx = size (a);
+    aidx = size (A);
     ## ensure matching size
     idx(end+1:length (aidx)) = 1;
     aidx(end+1:length (idx)) = 1;
     ## create subscript array
     cidx = cell (2, length (aidx));
     for i = 1:length (aidx)
       cidx{1,i} = ':';
       cidx{2,i} = ones (1, idx (i));
     endfor
     aaidx = aidx;
     # add singleton dims
     aaidx(2,:) = 1;
-    a = reshape (a, aaidx(:));
-    x = reshape (a (cidx{:}), idx .* aidx);
+    A = reshape (A, aaidx(:));
+    x = reshape (A (cidx{:}), idx .* aidx);
   endif
 
 endfunction
 
 # Test various methods of providing size parameters
 %!shared x
 %! x = [1 2;3 4];
 %!assert(repmat(x, [1 1]), repmat(x, 1));
diff --git a/scripts/general/rot90.m b/scripts/general/rot90.m
--- a/scripts/general/rot90.m
+++ b/scripts/general/rot90.m
@@ -13,21 +13,21 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} rot90 (@var{x}, @var{n})
-## Return a copy of @var{x} with the elements rotated counterclockwise in
+## @deftypefn {Function File} {} rot90 (@var{A}, @var{k})
+## Return a copy of @var{A} with the elements rotated counterclockwise in
 ## 90-degree increments.  The second argument is optional, and specifies
 ## how many 90-degree rotations are to be applied (the default value is 1).
-## Negative values of @var{n} rotate the matrix in a clockwise direction.
+## Negative values of @var{k} rotate the matrix in a clockwise direction.
 ## For example,
 ##
 ## @example
 ## @group
 ## rot90 ([1, 2; 3, 4], -1)
 ##      @result{}  3  1
 ##          4  2
 ## @end group
@@ -48,63 +48,63 @@
 ## Due to the difficulty of defining an axis about which to rotate the 
 ## matrix @code{rot90} only work with 2-D arrays.  To rotate N-d arrays
 ## use @code{rotdim} instead.
 ## @seealso{rotdim, flipud, fliplr, flipdim}
 ## @end deftypefn
 
 ## Author: jwe
 
-function y = rot90 (x, k)
+function B = rot90 (A, k)
 
   if (nargin == 1 || nargin == 2)
     if (nargin < 2)
       k = 1;
     endif
 
-    if (ndims (x) > 2)
+    if (ndims (A) > 2)
       error ("rot90: Only works with 2-D arrays");
     endif
 
     if (imag (k) != 0 || fix (k) != k)
       error ("rot90: k must be an integer");
     endif
 
     k = rem (k, 4);
 
     if (k < 0)
       k = k + 4;
     endif
 
     if (k == 0)
-      y = x;
+      B = A;
     elseif (k == 1)
-      y = flipud (x.');
+      B = flipud (A.');
     elseif (k == 2)
-      y = flipud (fliplr (x));
+      B = flipud (fliplr (A));
     elseif (k == 3)
-      y = (flipud (x)).';
+      B = (flipud (A)).';
     else
       error ("rot90: internal error!");
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
 %!test
-%! x1 = [1, 2;
-%! 3, 4];
-%! x2 = [2, 4;
-%! 1, 3];
-%! x3 = [4, 3;
-%! 2, 1];
-%! x4 = [3, 1;
-%! 4, 2];
+%! x1 = [1, 2; 3, 4];
+%! x2 = [2, 4; 1, 3];
+%! x3 = [4, 3; 2, 1];
+%! x4 = [3, 1; 4, 2];
 %! 
-%! assert((rot90 (x1)== x2 && rot90 (x1, 2) == x3 && rot90 (x1, 3) == x4
-%! && rot90 (x1, 4) == x1 && rot90 (x1, 5) == x2 && rot90 (x1, -1) == x4));
+%! assert(rot90 (x1) == x2);
+%! assert(rot90 (x1, 2) == x3);
+%! assert(rot90 (x1, 3) == x4);
+%! assert(rot90 (x1, 4) == x1);
+%! assert(rot90 (x1, 5) == x2);
+%! assert(rot90 (x1, -1) == x4);
 
+%% Test input validation
 %!error rot90 ();
-
 %!error rot90 (1, 2, 3);
 
diff --git a/scripts/general/sortrows.m b/scripts/general/sortrows.m
--- a/scripts/general/sortrows.m
+++ b/scripts/general/sortrows.m
@@ -13,54 +13,54 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} sortrows (@var{a}, @var{c})
-## Sort the rows of the matrix @var{a} according to the order of the
+## @deftypefn {Function File} {} sortrows (@var{A}, @var{c})
+## Sort the rows of the matrix @var{A} according to the order of the
 ## columns specified in @var{c}.  If @var{c} is omitted, a
 ## lexicographical sort is used.  By default ascending order is used 
 ## however if elements of @var{c} are negative then the corresponding  
 ## column is sorted in descending order.
 ## @end deftypefn
 
 ## Author: Daniel Calvelo, Paul Kienzle
 ## Adapted-by: jwe
 
-function [s, i] = sortrows (m, c)
+function [s, i] = sortrows (A, c)
 
   default_mode = "ascend";
   other_mode = "descend";
 
-  if (issparse (m))
+  if (issparse (A))
     ## FIXME -- eliminate this case once __sort_rows_idx__ is fixed to
     ## handle sparse matrices.
     if (nargin == 1)
-      i = sort_rows_idx_generic (default_mode, other_mode, m);
+      i = sort_rows_idx_generic (default_mode, other_mode, A);
     else
-      i = sort_rows_idx_generic (default_mode, other_mode, m, c);
+      i = sort_rows_idx_generic (default_mode, other_mode, A, c);
     endif
   elseif (nargin == 1)
-    i = __sort_rows_idx__ (m, default_mode);
+    i = __sort_rows_idx__ (A, default_mode);
   elseif (all (c > 0))
-    i = __sort_rows_idx__ (m(:,c), default_mode);
+    i = __sort_rows_idx__ (A(:,c), default_mode);
   elseif (all (c < 0))
-    i = __sort_rows_idx__ (m(:,-c), other_mode);
+    i = __sort_rows_idx__ (A(:,-c), other_mode);
   else
     ## Otherwise, fall back to the old algorithm.
-    i = sort_rows_idx_generic (default_mode, other_mode, m, c);
+    i = sort_rows_idx_generic (default_mode, other_mode, A, c);
   endif
 
   ## Only bother to compute s if needed.
   if (isargout (1))
-    s = m(i,:);
+    s = A(i,:);
   endif
 
 endfunction
 
 function i = sort_rows_idx_generic (default_mode, other_mode, m, c)
 
   if (nargin == 3)
     indices = [1:size(m,2)]';
@@ -86,18 +86,18 @@ function i = sort_rows_idx_generic (defa
   for ii = 1:length (indices);
     [trash, idx] = sort (m(i, indices(ii)), mode{ii});
     i = i(idx);
   endfor
 
 endfunction
 
 
-%!shared m, c, x, idx, sx, sidx
+%!test
 %! m = [1, 1; 1, 2; 3, 6; 2, 7];
 %! c = [1, -2];
 %! [x, idx] = sortrows (m, c);
 %! [sx, sidx] = sortrows (sparse (m), c);
-%!assert (x, [1, 2; 1, 1; 2, 7; 3, 6]);
-%!assert (idx, [2; 1; 4; 3]);
-%!assert (issparse (sx));
-%!assert (x, full (sx));
-%!assert (idx, sidx);
+%! assert (x, [1, 2; 1, 1; 2, 7; 3, 6]);
+%! assert (idx, [2; 1; 4; 3]);
+%! assert (issparse (sx));
+%! assert (x, full (sx));
+%! assert (idx, sidx);
diff --git a/scripts/general/strerror.m b/scripts/general/strerror.m
--- a/scripts/general/strerror.m
+++ b/scripts/general/strerror.m
@@ -22,42 +22,42 @@
 ## Return the text of an error message for function @var{name}
 ## corresponding to the error number @var{num}.  This function is intended
 ## to be used to print useful error messages for those functions that
 ## return numeric error codes.
 ## @end deftypefn
 
 ## Author: jwe
 
-function msg = strerror (name, err)
+function msg = strerror (name, num)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (! ischar (name))
     error ("strerror: first argument must be a string");
   endif
 
-  if (! isscalar (err))
+  if (! isscalar (num))
     error ("strerror: second argument must be a scalar");
   endif
 
   if (strcmp (name, "fsolve"))
 
-    if (err == -2)
+    if (num == -2)
       msg = "input error\n";
-    elseif (err == -1)
+    elseif (num == -1)
       msg = "error encountered in user-supplied function\n";
-    elseif (err == 1)
+    elseif (num == 1)
       msg = "solution converged to requested tolerance\n";
-    elseif (err == 4)
+    elseif (num == 3)
+      msg = "iteration is not making good progress\n";
+    elseif (num == 4)
       msg = "iteration limit exceeded\n";
-    elseif (err == 3)
-      msg = "iteration is not making good progress\n";
     else
       error ("strerror: unrecognized error code for fsolve");
     endif
 
   else
 
     error ("strerror: unrecognized function name");
 
diff --git a/scripts/general/structfun.m b/scripts/general/structfun.m
--- a/scripts/general/structfun.m
+++ b/scripts/general/structfun.m
@@ -13,23 +13,23 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} structfun (@var{func}, @var{s})
+## @deftypefn  {Function File} {} structfun (@var{func}, @var{S})
 ## @deftypefnx {Function File} {[@var{a}, @dots{}] =} structfun (@dots{})
 ## @deftypefnx {Function File} {} structfun (@dots{}, "ErrorHandler", @var{errfunc})
 ## @deftypefnx {Function File} {} structfun (@dots{}, "UniformOutput", @var{val})
 ## 
 ## Evaluate the function named @var{name} on the fields of the structure
-## @var{s}.  The fields of @var{s} are passed to the function @var{func}
+## @var{S}.  The fields of @var{S} are passed to the function @var{func}
 ## individually.
 ##
 ## @code{structfun} accepts an arbitrary function @var{func} in the form of 
 ## an inline function, function handle, or the name of a function (in a 
 ## character string).  In the case of a character string argument, the 
 ## function must accept a single argument named @var{x}, and it must return 
 ## a string value.  If the function returns more than one argument, they are
 ## returned as separate output variables.
@@ -68,17 +68,17 @@
 ## "identifier", "message" and "index", giving respectively the error
 ## identifier, the error message, and the index into the input arguments
 ## of the element that caused the error.  For an example on how to use
 ## an error handler, @pxref{doc-cellfun, @code{cellfun}}. 
 ##
 ## @seealso{cellfun, arrayfun, spfun}
 ## @end deftypefn
 
-function varargout = structfun (fun, s, varargin);
+function varargout = structfun (func, S, varargin);
 
   if (nargin < 2)
     print_usage ();
   endif
 
   nargs = length (varargin);
 
   recognized_opts = {"UniformOutput", "ErrorHandler"};
@@ -98,20 +98,20 @@ function varargout = structfun (fun, s, 
     endif
   endwhile
 
   if (nargs > 0)
     error ("structfun: invalid options");
   endif
 
   varargout = cell (max ([nargout, 1]), 1);
-  [varargout{:}] = cellfun (fun, struct2cell (s), varargin{:});
+  [varargout{:}] = cellfun (func, struct2cell (S), varargin{:});
 
   if (! uniform_output)
-    varargout = cellfun (@cell2struct, varargout, {fieldnames(s)}, {1}, uo_str, false);
+    varargout = cellfun (@cell2struct, varargout, {fieldnames(S)}, {1}, uo_str, false);
   endif
 endfunction
 
 
 %!test
 %! s.name1 = "John Smith"; 
 %! s.name2 = "Jill Jones"; 
 %! l.name1 = "Smith";
diff --git a/scripts/geometry/delaunayn.m b/scripts/geometry/delaunayn.m
--- a/scripts/geometry/delaunayn.m
+++ b/scripts/geometry/delaunayn.m
@@ -12,24 +12,24 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{T} =} delaunayn (@var{P})
-## @deftypefnx {Function File} {@var{T} =} delaunayn (@var{P}, @var{opt})
+## @deftypefn  {Function File} {@var{t} =} delaunayn (@var{p})
+## @deftypefnx {Function File} {@var{t} =} delaunayn (@var{p}, @var{opt})
 ## Form the Delaunay triangulation for a set of points.
 ## The Delaunay triangulation is a tessellation of the convex hull of the
 ## points such that no n-sphere defined by the n-triangles contains
 ## any other points from the set.
-## The input matrix @var{P} of size @code{[n, dim]} contains @var{n}
-## points in a space of dimension dim.  The return matrix @var{T} has the
+## The input matrix @var{p} of size @code{[n, dim]} contains @math{n}
+## points in a space of dimension dim.  The return matrix @var{t} has the
 ## size @code{[m, dim+1]}.  It contains for each row a set of indices to
 ## the points, which describes a simplex of dimension dim.  For example,
 ## a 2d simplex is a triangle and 3d simplex is a tetrahedron.
 ## 
 ## Extra options for the underlying Qhull command can be specified by the
 ## second argument.  This argument is a cell array of strings.  The default
 ## options depend on the dimension of the input: 
 ## 
@@ -43,40 +43,40 @@
 ## is @code{@{"@w{}"@}}, then none of the default arguments are used by Qhull. 
 ## See the Qhull documentation for the available options. 
 ## 
 ## All options can also be specified as single string, for example
 ## @code{"Qt Qbb Qc Qz"}.
 ## 
 ## @end deftypefn
 
-function t = delaunayn (x, varargin)
+function t = delaunayn (p, varargin)
   if (nargin < 1)
     print_usage ();
   endif
 
-  t = __delaunayn__ (x, varargin{:});
+  t = __delaunayn__ (p, varargin{:});
 
-  if (isa (x, "single"))
+  if (isa (p, "single"))
     myeps = eps ("single");
   else
     myeps = eps;
   endif
 
   ## Try to remove the zero volume simplices. The volume of the i-th simplex is
-  ## given by abs(det(x(t(i,1:end-1),:)-x(t(i,2:end),:)))/prod(1:n) 
+  ## given by abs(det(p(t(i,1:end-1),:)-p(t(i,2:end),:)))/prod(1:n) 
   ## (reference http://en.wikipedia.org/wiki/Simplex). Any simplex with a 
   ## relative volume less than some arbitrary criteria is rejected. The 
   ## criteria we use is the volume of the simplex corresponding to an 
   ## orthogonal simplex is equal edge length all equal to the edge length of 
   ## the original simplex. If the relative volume is 1e3*eps then the simplex
   ## is rejected. Note division of the two volumes means that the factor 
   ## prod(1:n) is dropped.
   idx = [];
   [nt, n] = size (t);
   for i = 1:nt
-    X = x(t(i,1:end-1),:) - x(t(i,2:end),:);
+    X = p(t(i,1:end-1),:) - p(t(i,2:end),:);
     if (abs (det (X)) /  sqrt (sum (X .^ 2, 2)) < 1e3 * myeps)
      idx = [idx, i];
     endif
   endfor
   t(idx,:) = [];
 endfunction
diff --git a/scripts/geometry/dsearch.m b/scripts/geometry/dsearch.m
--- a/scripts/geometry/dsearch.m
+++ b/scripts/geometry/dsearch.m
@@ -16,21 +16,21 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{idx} =} dsearch (@var{x}, @var{y}, @var{tri}, @var{xi}, @var{yi})
 ## @deftypefnx {Function File} {@var{idx} =} dsearch (@var{x}, @var{y}, @var{tri}, @var{xi}, @var{yi}, @var{s})
 ## Returns the index @var{idx} or the closest point in @code{@var{x}, @var{y}}
 ## to the elements @code{[@var{xi}(:), @var{yi}(:)]}.  The variable @var{s} is
-## accepted but ignored for compatibility.
+## accepted for compatibility but is ignored.
 ## @seealso{dsearchn, tsearch}
 ## @end deftypefn
 
-function idx = dsearch (x, y, t, xi, yi, s)
+function idx = dsearch (x, y, tri, xi, yi, s)
   if (nargin < 5 || nargin > 6)
     print_usage ();
   endif
   idx = __dsearchn__ ([x(:), y(:)], [xi(:), yi(:)]);
 endfunction
 
 %!shared x, y, tri
 %! x = [-1;-1;1];
diff --git a/scripts/geometry/dsearchn.m b/scripts/geometry/dsearchn.m
--- a/scripts/geometry/dsearchn.m
+++ b/scripts/geometry/dsearchn.m
@@ -24,27 +24,27 @@
 ## Returns the index @var{idx} or the closest point in @var{x} to the elements
 ## @var{xi}.  If @var{outval} is supplied, then the values of @var{xi} that are
 ## not contained within one of the simplices @var{tri} are set to 
 ## @var{outval}.  Generally, @var{tri} is returned from @code{delaunayn 
 ## (@var{x})}.
 ## @seealso{dsearch, tsearch}
 ## @end deftypefn
 
-function [idx, d] = dsearchn (x, t, xi, outval)
+function [idx, d] = dsearchn (x, tri, xi, outval)
   if (nargin < 2 || nargin > 4)
     print_usage ();
   endif
 
   if (nargin == 2)
-    [idx, d] = __dsearchn__ (x, t);
+    [idx, d] = __dsearchn__ (x, tri);
   else
     [idx, d] = __dsearchn__ (x, xi);
     if (nargin == 4)
-      idx2 = isnan (tsearchn (x, t, xi));
+      idx2 = isnan (tsearchn (x, tri, xi));
       idx(idx2) = outval;
       d(idx2) = outval;
     endif
   endif
 endfunction
 
 %!shared x, tri
 %! x = [-1,-1;-1,1;1,-1]; 
diff --git a/scripts/geometry/inpolygon.m b/scripts/geometry/inpolygon.m
--- a/scripts/geometry/inpolygon.m
+++ b/scripts/geometry/inpolygon.m
@@ -13,120 +13,120 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{in}, @var{on}] =} inpolygon (@var{x}, @var{y}, @var{xv}, @var{xy})
+## @deftypefn {Function File} {[@var{in}, @var{on}] =} inpolygon (@var{x}, @var{y}, @var{xv}, @var{yv})
 ##
-## For a polygon defined by @code{(@var{xv}, @var{yv})} points, determine
+## For a polygon defined by vertex points @code{(@var{xv}, @var{yv})}, determine
 ## if the points @code{(@var{x}, @var{y})} are inside or outside the polygon.
 ## The variables @var{x}, @var{y}, must have the same dimension.  The optional
 ## output @var{on} gives the points that are on the polygon.
 ##
 ## @end deftypefn
 
 ## Author: Frederick (Rick) A Niles <niles@rickniles.com>
 ## Created: 14 November 2006
 
 ## Vectorized by Sren Hauberg <soren@hauberg.org>
 
 ## The method for determining if a point is in in a polygon is based on
 ## the algorithm shown on
 ## http://local.wasp.uwa.edu.au/~pbourke/geometry/insidepoly/ and is
 ## credited to Randolph Franklin.
 
-function [IN, ON] = inpolygon (X, Y, xv, yv)
+function [in, on] = inpolygon (x, y, xv, yv)
 
   if (nargin != 4)
     print_usage ();
   endif
 
-  if (! (isreal (X) && isreal (Y) && ismatrix (Y) && ismatrix (Y)
-         && size_equal (X, Y)))
+  if (! (isreal (x) && isreal (y) && ismatrix (y) && ismatrix (y)
+         && size_equal (x, y)))
     error ("inpolygon: first two arguments must be real matrices of same size");
   elseif (! (isreal (xv) && isreal (yv) && isvector (xv) && isvector (yv)
              && size_equal (xv, yv)))
     error ("inpolygon: last two arguments must be real vectors of same size");
   endif
 
   npol = length (xv);
   do_boundary = (nargout >= 2);
   
-  IN = zeros (size(X), "logical");
+  in = zeros (size(x), "logical");
   if (do_boundary) 
-    ON = zeros (size(X), "logical"); 
+    on = zeros (size(x), "logical"); 
   endif
   
   j = npol;
   for i = 1 : npol
     delta_xv = xv(j) - xv(i);
     delta_yv = yv(j) - yv(i);
-    ## distance = [distance from (X,Y) to edge] * length(edge)
-    distance = delta_xv .* (Y - yv(i)) - (X - xv(i)) .* delta_yv;
+    ## distance = [distance from (x,y) to edge] * length(edge)
+    distance = delta_xv .* (y - yv(i)) - (x - xv(i)) .* delta_yv;
     ##
-    ## is Y between the y-values of edge i,j
-    ##        AND (X,Y) on the left of the edge ?
-    idx1 = (((yv(i) <= Y & Y < yv(j)) | (yv(j) <= Y & Y < yv(i)))
+    ## is y between the y-values of edge i,j
+    ##        AND (x,y) on the left of the edge ?
+    idx1 = (((yv(i) <= y & y < yv(j)) | (yv(j) <= y & y < yv(i)))
             & 0 < distance.*delta_yv);
-    IN (idx1) = !IN (idx1);
+    in (idx1) = !in (idx1);
 
-    ## Check if (X,Y) are actually ON the boundary of the polygon.
+    ## Check if (x,y) are actually on the boundary of the polygon.
     if (do_boundary)
-       idx2 = (((yv(i) <= Y & Y <= yv(j)) | (yv(j) <= Y & Y <= yv(i)))
-               & ((xv(i) <= X & X <= xv(j)) | (xv(j) <= X & X <= xv(i)))
+       idx2 = (((yv(i) <= y & y <= yv(j)) | (yv(j) <= y & y <= yv(i)))
+               & ((xv(i) <= x & x <= xv(j)) | (xv(j) <= x & x <= xv(i)))
                & (0 == distance | !delta_xv));
-       ON (idx2) = true;
+       on (idx2) = true;
     endif
     j = i;
   endfor
 
 endfunction
 
 %!demo
 %!  xv=[ 0.05840, 0.48375, 0.69356, 1.47478, 1.32158, \
 %!       1.94545, 2.16477, 1.87639, 1.18218, 0.27615, \
 %!       0.05840 ];
 %!  yv=[ 0.60628, 0.04728, 0.50000, 0.50000, 0.02015, \
 %!       0.18161, 0.78850, 1.13589, 1.33781, 1.04650, \
 %!       0.60628 ];
 %! xa=[0:0.1:2.3];
 %! ya=[0:0.1:1.4];
 %! [x,y]=meshgrid(xa,ya);
-%! [IN,ON]=inpolygon(x,y,xv,yv);
+%! [in,on]=inpolygon(x,y,xv,yv);
 %! 
-%! inside=IN & !ON;
+%! inside=in & !on;
 %! plot(xv,yv)
 %! hold on
 %! plot(x(inside),y(inside),"@g")
-%! plot(x(~IN),y(~IN),"@m")
-%! plot(x(ON),y(ON),"@b")
+%! plot(x(~in),y(~in),"@m")
+%! plot(x(on),y(on),"@b")
 %! hold off
 %! disp("Green points are inside polygon, magenta are outside,");
 %! disp("and blue are on boundary.");
 
 %!demo
 %!  xv=[ 0.05840, 0.48375, 0.69356, 1.47478, 1.32158, \
 %!       1.94545, 2.16477, 1.87639, 1.18218, 0.27615, \
 %!       0.05840, 0.73295, 1.28913, 1.74221, 1.16023, \
 %!       0.73295, 0.05840 ];
 %!  yv=[ 0.60628, 0.04728, 0.50000, 0.50000, 0.02015, \
 %!       0.18161, 0.78850, 1.13589, 1.33781, 1.04650, \
 %!       0.60628, 0.82096, 0.67155, 0.96114, 1.14833, \
 %!       0.82096, 0.60628];
 %! xa=[0:0.1:2.3];
 %! ya=[0:0.1:1.4];
 %! [x,y]=meshgrid(xa,ya);
-%! [IN,ON]=inpolygon(x,y,xv,yv);
+%! [in,on]=inpolygon(x,y,xv,yv);
 %! 
-%! inside=IN & ~ ON;
+%! inside=in & ~ on;
 %! plot(xv,yv)
 %! hold on
 %! plot(x(inside),y(inside),"@g")
-%! plot(x(~IN),y(~IN),"@m")
-%! plot(x(ON),y(ON),"@b")
+%! plot(x(~in),y(~in),"@m")
+%! plot(x(on),y(on),"@b")
 %! hold off
 %! disp("Green points are inside polygon, magenta are outside,");
 %! disp("and blue are on boundary.");
 
diff --git a/scripts/geometry/voronoin.m b/scripts/geometry/voronoin.m
--- a/scripts/geometry/voronoin.m
+++ b/scripts/geometry/voronoin.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{C}, @var{F}] =} voronoin (@var{pts})
 ## @deftypefnx {Function File} {[@var{C}, @var{F}] =} voronoin (@var{pts}, @var{options})
-## computes n- dimensional Voronoi facets.  The input matrix @var{pts}
+## Compute N-dimensional Voronoi facets.  The input matrix @var{pts}
 ## of size [n, dim] contains n points of dimension dim.
 ## @var{C} contains the points of the Voronoi facets.  The list @var{F}
 ## contains for each facet the indices of the Voronoi points.
 ##
 ## A second optional argument, which must be a string, contains extra options
 ## passed to the underlying qhull command.  See the documentation for the
 ## Qhull library for details.
 ## @seealso{voronoin, delaunay, convhull}
@@ -32,28 +32,28 @@
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## First Release: 20/08/2000
 
 ## 2003-12-14 Rafael Laboissiere <rafael@laboissiere.net>
 ## Added optional second argument to pass options to the underlying
 ## qhull command
 
-function [C, F] = voronoin (pts, opt)
+function [C, F] = voronoin (pts, options)
 
   if (nargin != 1 && nargin != 2)
     print_usage ();
   endif
 
   [np, dims] = size (pts);
   if (np > dims)
     if (nargin == 1)
       [C, F, infi] = __voronoi__ (pts);
-    elseif ischar(opt)
-      [C, F, infi] = __voronoi__ (pts, opt);
+    elseif (ischar (options))
+      [C, F, infi] = __voronoi__ (pts, options);
     else
       error ("voronoin: second argument must be a string");
     endif
 
   else
     error ("voronoin: number of points must be greater than their dimension");
   endif
 endfunction
diff --git a/scripts/help/lookfor.m b/scripts/help/lookfor.m
--- a/scripts/help/lookfor.m
+++ b/scripts/help/lookfor.m
@@ -36,23 +36,23 @@
 ## sentence of the help text is dependent on the format of the
 ## function's help.  All Octave core functions are correctly
 ## formatted, but the same can not be guaranteed for external packages and
 ## user-supplied functions.  Therefore, the use of the '-all' argument may 
 ## be necessary to find related functions that are not a part of Octave.
 ## @seealso{help, doc, which}
 ## @end deftypefn
 
-function [out_fun, out_help_text] = lookfor (str, extra)
+function [out_fun, out_help_text] = lookfor (str, arg2)
   if (strcmpi (str, "-all"))
     ## The difference between using '-all' and not, is which part of the caches
     ## we search. The cache is organised such that its first column contains
     ## the function name, its second column contains the full help text, and its
     ## third column contains the first sentence of the help text.
-    str = extra;
+    str = arg2;
     search_type = 2; # when using caches, search its second column
   else
     search_type = 3; # when using caches, search its third column
   endif
   str = lower (str);
 
   ## Search functions, operators, and keywords that come with Octave
   cache_file = doc_cache_file ();
diff --git a/scripts/image/brighten.m b/scripts/image/brighten.m
--- a/scripts/image/brighten.m
+++ b/scripts/image/brighten.m
@@ -29,27 +29,29 @@
 ## written to the current colormap.
 ##
 ## The argument @var{beta} should be a scalar between -1 and 1,
 ## where a negative value darkens and a positive value brightens
 ## the colormap.
 ## @seealso{colormap}
 ## @end deftypefn
 
-function Rmap = brighten (m, beta)
+function rmap = brighten (arg1, beta)
   h = -1;
   if (nargin == 1)
-    beta = m;
+    beta = arg1;
     m = colormap;
     h = gcf ();
   elseif (nargin == 2)
-    if (ishandle (m))
-      h = m;
+    if (ishandle (arg1))
+      h = arg1;
       m = get (h, "colormap");
-    elseif (! ismatrix (m) || size (m, 2) != 3)
+    elseif (ismatrix (arg1) && columns (arg1) == 3)
+      m = arg1;
+    else
       error ("brighten: first argument must be an Nx3 matrix or a handle");
     endif
   else
     print_usage ();
   endif
 
   if (! isscalar (beta) || beta <= -1 || beta >= 1)
     error ("brighten: beta must be a scalar in the range (-1,1)");
@@ -63,12 +65,12 @@ function Rmap = brighten (m, beta)
 
   if (nargout == 0)
     if (ishandle (h))
       set (h, "colormap", m .^ gamma);
     else
       colormap (m .^ gamma);
     endif
   else
-    Rmap = m .^ gamma;
+    rmap = m .^ gamma;
   endif
 
 endfunction
diff --git a/scripts/image/ind2gray.m b/scripts/image/ind2gray.m
--- a/scripts/image/ind2gray.m
+++ b/scripts/image/ind2gray.m
@@ -24,27 +24,27 @@
 ## intensities.
 ## @seealso{gray2ind, rgb2ntsc, image, colormap}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
-function Y = ind2gray (X, map)
+function y = ind2gray (x, map)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   elseif (nargin == 1)
     map = colormap ();
   endif
 
-  [rows, cols] = size (X);
+  [rows, cols] = size (x);
 
   ## Convert colormap to intensity values (the first column of the
   ## result of the call to rgb2ntsc) and then replace indices in
   ## the input matrix with indexed values in the output matrix (indexed
   ## values are the result of indexing the intensity values by the
-  ## elements of X(:)).
+  ## elements of x(:)).
 
-  Y = reshape (((rgb2ntsc (map))(:,1))(X(:)), rows, cols);
+  y = reshape (((rgb2ntsc (map))(:,1))(x(:)), rows, cols);
 
 endfunction
diff --git a/scripts/image/ind2rgb.m b/scripts/image/ind2rgb.m
--- a/scripts/image/ind2rgb.m
+++ b/scripts/image/ind2rgb.m
@@ -14,60 +14,60 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{rgb} =} ind2rgb (@var{x}, @var{map})
-## @deftypefnx {Function File} {[@var{r}, @var{g}, @var{b}] =} ind2rgb (@var{x}, @var{map})
+## @deftypefnx {Function File} {[@var{R}, @var{R}, @var{R}] =} ind2rgb (@var{x}, @var{map})
 ## Convert an indexed image to red, green, and blue color components.
 ## If the colormap doesn't contain enough colors, pad it with the
 ## last color in the map.
 ## If @var{map} is omitted, the current colormap is used for the conversion.
 ## @seealso{rgb2ind, image, imshow, ind2gray, gray2ind}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
-function [R, G, B] = ind2rgb (X, map)
+function [R, G, B] = ind2rgb (x, map)
 
   ## Do we have the right number of inputs?
   if (nargin < 1 || nargin > 2)
     print_usage ();
   elseif (nargin == 1)
     map = colormap ();
   endif
 
   ## Check if X is an indexed image.
-  if (ndims (X) != 2 || any (X(:) != round (X(:))) || min (X(:)) < 1)
+  if (ndims (x) != 2 || any (x(:) != round (x(:))) || min (x(:)) < 1)
     error ("ind2rgb: first input argument must be an indexed image");
   endif
   
   ## Check the color map.
   if (ndims (map) != 2 || columns (map) != 3)
     error ("ind2rgb: second input argument must be a color map");
   endif
 
   ## Do we have enough colors in the color map?
-  maxidx = max (X(:));
+  maxidx = max (x(:));
   rm = rows (map);
   if (rm < maxidx)
     ## Pad with the last color in the map.
     pad = repmat (map(end,:), maxidx-rm, 1);
     map(end+1:maxidx, :) = pad;
   endif
   
   ## Compute result
-  [hi, wi] = size (X);
-  R = reshape (map (X(:), 1), hi, wi);
-  G = reshape (map (X(:), 2), hi, wi);
-  B = reshape (map (X(:), 3), hi, wi);
+  [hi, wi] = size (x);
+  R = reshape (map (x(:), 1), hi, wi);
+  G = reshape (map (x(:), 2), hi, wi);
+  B = reshape (map (x(:), 3), hi, wi);
 
   ## Use 3D array if only one output is requested.
   if (nargout <= 1)
     R(:,:,3) = B;
     R(:,:,2) = G;
   endif
 endfunction
diff --git a/scripts/image/rgb2hsv.m b/scripts/image/rgb2hsv.m
--- a/scripts/image/rgb2hsv.m
+++ b/scripts/image/rgb2hsv.m
@@ -13,32 +13,32 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{hsv_map} =} rgb2hsv (@var{rgb_map})
+## @deftypefn {Function File} {@var{hsv_map} =} rgb2hsv (@var{rgb})
 ## Transform a colormap or image from the RGB space to the HSV space.
 ##
 ## A color in the RGB space consists of the red, green and blue intensities.
 ##
 ## In the HSV space each color is represented by their hue, saturation
 ## and value (brightness).  Value gives the amount of light in the color.
 ## Hue describes the dominant wavelength. 
 ## Saturation is the amount of hue mixed into the color.
 ## @seealso{hsv2rgb}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
-function hsval = rgb2hsv (rgb)
+function hsv_map = rgb2hsv (rgb)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   ## If we have an image convert it into a color map.
   if (ismatrix (rgb) && ndims (rgb) == 3)
     is_image = true;
@@ -51,17 +51,17 @@ function hsval = rgb2hsv (rgb)
       high = double (intmax (C));
       rgb = (double (rgb) - low) / (high - low);
     endif
   else
     is_image = false;
   endif
 
   if (! ismatrix (rgb) || columns (rgb) != 3)
-    error ("rgb2hsv: argument must be a matrix of size n x 3");
+    error ("rgb2hsv: RGB_MAP must be a matrix of size n x 3");
   endif
 
   ## get the max and min
   s = min (rgb')';
   v = max (rgb')';
 
   ## set hue to zero for undefined values (gray has no hue)
   h = zeros (size (v));
@@ -88,16 +88,16 @@ function hsval = rgb2hsv (rgb)
   ## correct for negative red
   idx = (h < 0);
   h(idx) = 1+h(idx);
 
   ## set the saturation
   s(! notgray) = 0;
   s(notgray) = 1 - s(notgray) ./ v(notgray);
 
-  hsval = [h, s, v];
+  hsv_map = [h, s, v];
   
   ## If input was an image, convert it back into one.
   if (is_image)
-    hsval = reshape (hsval, Sz);
+    hsv_map = reshape (hsv_map, Sz);
   endif
 
 endfunction
diff --git a/scripts/image/rgb2ind.m b/scripts/image/rgb2ind.m
--- a/scripts/image/rgb2ind.m
+++ b/scripts/image/rgb2ind.m
@@ -14,28 +14,28 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{x}, @var{map}] =} rgb2ind (@var{rgb})
-## @deftypefnx {Function File} {[@var{x}, @var{map}] =} rgb2ind (@var{r}, @var{g}, @var{b})
+## @deftypefnx {Function File} {[@var{x}, @var{map}] =} rgb2ind (@var{R}, @var{G}, @var{B})
 ## Convert an RGB image to an Octave indexed image.
 ## @seealso{ind2rgb, rgb2ntsc}
 ## @end deftypefn
 
 ## Bugs: The color map may have duplicate entries.
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
-function [X, map] = rgb2ind (R, G, B)
+function [x, map] = rgb2ind (R, G, B)
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
   endif
   
   if (nargin == 1)
     rgb = R;
     if (length (size (rgb)) == 3 && size (rgb, 3) == 3)
@@ -48,19 +48,19 @@ function [X, map] = rgb2ind (R, G, B)
   endif
 
   if (! size_equal (R, G) || ! size_equal (R, B))
     error ("rgb2ind: arguments must all have the same size");
   endif
 
   [hi, wi] = size (R);
 
-  X = zeros (hi, wi);
+  x = zeros (hi, wi);
 
   map = zeros (hi*wi, 3);
 
   map(:,1) = R(:);
   map(:,2) = G(:);
   map(:,3) = B(:);
 
-  X(:) = 1:(hi*wi);
+  x(:) = 1:(hi*wi);
 
 endfunction
diff --git a/scripts/image/saveimage.m b/scripts/image/saveimage.m
--- a/scripts/image/saveimage.m
+++ b/scripts/image/saveimage.m
@@ -13,19 +13,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} saveimage (@var{file}, @var{x}, @var{fmt}, @var{map})
-## Save the matrix @var{x} to @var{file} in image format @var{fmt}.  Valid
-## values for @var{fmt} are
+## @deftypefn  {Function File} {} saveimage (@var{fname}, @var{img}, @var{fmt})
+## @deftypefnx {Function File} {} saveimage (@var{fname}, @var{img}, @var{fmt}, @var{map})
+## Save the matrix @var{img} to file @var{fname} in image format @var{fmt}.
+## Valid values for @var{fmt} are
 ##
 ## @table @code
 ## @item "img"
 ## Octave's image format.  The current colormap is also saved in the file.
 ##
 ## @item "ppm"
 ## Portable pixmap format.
 ##
@@ -69,17 +70,17 @@
 ##
 ## Permission to use, copy, modify, and distribute this software and its
 ## documentation for any purpose and without fee is hereby granted, provided
 ## that the above copyright notice appear in all copies and that both that
 ## copyright notice and this permission notice appear in supporting
 ## documentation.  This software is provided "as is" without express or
 ## implied warranty.
 
-function saveimage (filename, img, img_form, map)
+function saveimage (fname, img, fmt, map)
 
   if (nargin < 2 || nargin > 4)
     print_usage ();
   endif
 
   if (nargin < 4)
     if (size(img, 3) == 3)
       [img, map] = rgb2ind(img);
@@ -90,37 +91,37 @@ function saveimage (filename, img, img_f
 
   [map_nr, map_nc] = size (map);
 
   if (map_nc != 3)
     error ("saveimage: colormap should be an N x 3 matrix");
   endif
 
   if (nargin < 3)
-    img_form = "img";
-  elseif (! ischar (img_form))
+    fmt = "img";
+  elseif (! ischar (fmt))
     error ("saveimage: image format specification must be a string");
-  elseif (! (strcmp (img_form, "img")
-             || strcmp (img_form, "ppm")
-             || strcmp (img_form, "ps")))
+  elseif (! (strcmp (fmt, "img")
+             || strcmp (fmt, "ppm")
+             || strcmp (fmt, "ps")))
     error ("saveimage: unsupported image format specification");
   endif
 
   if (! ismatrix (img))
     warning ("image variable is not a matrix");
   endif
 
-  if (! ischar (filename))
-    error ("saveimage: file name must be a string");
+  if (! ischar (fname))
+    error ("saveimage: fname name must be a string");
   endif
 
   ## If we just want Octave image format, save and return.
 
-  if (strcmp (img_form, "img"))
-    save ("-text", filename, "map", "img");
+  if (strcmp (fmt, "img"))
+    save ("-text", fname, "map", "img");
     return;
   endif
 
   ## Convert to another format if requested.
 
   grey = all (map(:,1) == map(:,2) && map(:,1) == map (:,3));
 
   pbm = pgm = ppm = 0;
@@ -142,17 +143,17 @@ function saveimage (filename, img, img_f
   [img_nr, img_nc] = size (img);
 
   img_sz = img_nr * img_nc;
   img = reshape (img, img_sz, 1);
 
   img (img > map_nr) = map_nr;
   img (img <= 0) = 1;
 
-  if (strcmp (img_form, "ppm"))
+  if (strcmp (fmt, "ppm"))
 
     ## Would be nice to make this consistent with the line used by the
     ## load/save functions, but we need a good way to get username and
     ## hostname information.
 
     time_string = ctime (time ());
     time_string = time_string (1:length (time_string)-1);
     tagline = sprintf ("# Created by Octave %s, %s",
@@ -178,25 +179,25 @@ function saveimage (filename, img, img_f
       bwimg = postpad (reshape (map(img), img_nr, img_nc), k * 8, 0);
 
       b = kron (pow2 (7:-1:0)', ones (1, img_nc));
 
       for i = 1:k
         tmp(i,:) = sum (bwimg(8*(i-1)+1:8*i,:) .* b);
       endfor
 
-      fid = fopen (filename, "wb");
+      fid = fopen (fname, "wb");
       fprintf (fid, "P4\n%s\n%d %d\n", tagline, img_nr, img_nc);
       fwrite (fid, tmp, "uchar");
       fprintf (fid, "\n");
       fclose (fid);
 
     elseif (grey)
 
-      fid = fopen (filename, "wb");
+      fid = fopen (fname, "wb");
       fprintf (fid, "P5\n%s\n%d %d\n255\n", tagline, img_nr, img_nc);
       fwrite (fid, map(img), "uchar");
       fprintf (fid, "\n");
       fclose (fid);
 
     else
 
       img_idx = ((1:3:3*img_sz)+2)';
@@ -208,25 +209,25 @@ function saveimage (filename, img, img_f
       map_idx = map_idx - map_nr;
       tmap = map(map_idx);
       tmp(img_idx--) = tmap(img);
 
       map_idx = map_idx - map_nr;
       tmap = map(map_idx);
       tmp(img_idx--) = tmap(img);
 
-      fid = fopen (filename, "wb");
+      fid = fopen (fname, "wb");
       fprintf (fid, "P6\n%s\n%d %d\n255\n", tagline, img_nr, img_nc);
       fwrite (fid, tmp, "uchar");
       fprintf (fid, "\n");
       fclose (fid);
 
     endif
 
-  elseif (strcmp (img_form, "ps") == 1)
+  elseif (strcmp (fmt, "ps") == 1)
 
     if (! grey)
       error ("saveimage: must have a greyscale color map for conversion to PostScript");
     endif
 
     bps = 8;
     dpi = 300;
     pagewid = 612;
@@ -258,21 +259,21 @@ function saveimage (filename, img, img_f
       warning ("image too large for page, rescaling to %g", scale);
     endif
 
     llx = (pagewid - scols) / 2;
     lly = (pagehgt - srows) / 2;
     urx = llx + fix (scols + 0.5);
     ury = lly + fix (srows + 0.5);
 
-    fid = fopen (filename, "wb");
+    fid = fopen (fname, "wb");
 
     fprintf (fid, "%%!PS-Adobe-2.0 EPSF-2.0\n");
     fprintf (fid, "%%%%Creator: Octave %s (saveimage.m)\n", OCTAVE_VERSION);
-    fprintf (fid, "%%%%Title: %s\n", filename);
+    fprintf (fid, "%%%%Title: %s\n", fname);
     fprintf (fid, "%%%%Pages: 1\n");
     fprintf (fid, "%%%%BoundingBox: %d %d %d %d\n",
              fix (llx), fix (lly), fix (urx), fix (ury));
     fprintf (fid, "%%%%EndComments\n");
     fprintf (fid, "/readstring {\n");
     fprintf (fid, "  currentfile exch readhexstring pop\n");
     fprintf (fid, "} bind def\n");
     fprintf (fid, "/picstr %d string def\n",
diff --git a/scripts/io/csvread.m b/scripts/io/csvread.m
--- a/scripts/io/csvread.m
+++ b/scripts/io/csvread.m
@@ -25,11 +25,11 @@
 ##
 ## @example
 ## @var{x} = dlmread (@var{filename}, "," , @dots{})
 ## @end example
 ##
 ## @seealso{csvwrite, dlmread, dlmwrite}
 ## @end deftypefn
 
-function x = csvread (f, varargin)
-  x = dlmread (f, ",", varargin{:});
+function x = csvread (filename, varargin)
+  x = dlmread (filename, ",", varargin{:});
 endfunction
diff --git a/scripts/io/csvwrite.m b/scripts/io/csvwrite.m
--- a/scripts/io/csvwrite.m
+++ b/scripts/io/csvwrite.m
@@ -26,11 +26,11 @@
 ##
 ## @example
 ## dlmwrite (@var{filename}, @var{x}, ",", @dots{})
 ## @end example
 ##
 ## @seealso{csvread, dlmwrite, dlmread}
 ## @end deftypefn
 
-function csvwrite (f, m, varargin)
-  dlmwrite (f, m, ",", varargin{:});
+function csvwrite (filename, x, varargin)
+  dlmwrite (filename, x, ",", varargin{:});
 endfunction
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -94,23 +94,23 @@
 ##
 ## @item "emptyvalue"
 ## Parts of the output where no word is available is filled with @var{value}.
 ## @end table
 ##
 ## @seealso{textread, load, dlmread, fscanf}
 ## @end deftypefn
 
-function varargout = strread (str, formatstr = "%f", varargin)
+function varargout = strread (str, format = "%f", varargin)
   ## Check input
   if (nargin < 1)
     print_usage ();
   endif
  
-  if (!ischar (str) || !ischar (formatstr))
+  if (!ischar (str) || !ischar (format))
     error ("strread: first and second input arguments must be strings");
   endif
 
   ## Parse options
   comment_flag = false;
   numeric_fill_value = 0;
   white_spaces = " \n\r\t\b";
   delimiter_str = "";
@@ -145,20 +145,20 @@ function varargout = strread (str, forma
         warning ("strread: unknown property \"%s\"", varargin {n});
     endswitch
   endfor
   if (isempty (delimiter_str))
     delimiter_str = white_spaces;
   endif
 
   ## Parse format string
-  idx = strfind (formatstr, "%")';
-  specif = formatstr ([idx, idx+1]);
+  idx = strfind (format, "%")';
+  specif = format ([idx, idx+1]);
   nspecif = length (idx);
-  idx_star = strfind (formatstr, "%*");
+  idx_star = strfind (format, "%*");
   nfields = length (idx) - length (idx_star);
 
   if (max (nargout, 1) != nfields)
     error ("strread: the number of output variables must match that of format specifiers");
   endif
 
   ## Remove comments
   if (comment_flag)
@@ -182,18 +182,18 @@ function varargout = strread (str, forma
     endif
     len = length (str);
     c2len = length (comment_specif{2});
     str = cellslices (str, [1, cstop + c2len], [cstart - 1, len]);
     str = [str{:}];
   endif
 
   ## Determine the number of words per line
-  formatstr = strrep (formatstr, "%", " %");
-  [~, ~, ~, fmt_words] = regexp (formatstr, "[^\\s]+");
+  format = strrep (format, "%", " %");
+  [~, ~, ~, fmt_words] = regexp (format, "[^\\s]+");
 
   num_words_per_line = numel (fmt_words);
   for m = 1:numel(fmt_words)
     ## Convert formats such as "%Ns" to "%s" (see the FIXME below)
     if (length (fmt_words{m}) > 2)
       if (strcmp (fmt_words{m}(1:2), "%*"))
         fmt_words{m} = "%*";
       elseif (fmt_words{m}(1) == "%")
diff --git a/scripts/io/textread.m b/scripts/io/textread.m
--- a/scripts/io/textread.m
+++ b/scripts/io/textread.m
@@ -31,23 +31,23 @@
 ## supports one more:
 ## @itemize
 ## @item "headerlines":
 ## @end itemize
 ## The first @var{value} number of lines of @var{str} are skipped.
 ## @seealso{strread, load, dlmread, fscanf}
 ## @end deftypefn
 
-function varargout = textread (filename, formatstr = "%f", varargin)
+function varargout = textread (filename, format = "%f", varargin)
   ## Check input
   if (nargin < 1)
     print_usage ();
   endif
   
-  if (!ischar (filename) || !ischar (formatstr))
+  if (!ischar (filename) || !ischar (format))
     error ("textread: first and second input arguments must be strings");
   endif
 
   ## Read file
   fid = fopen (filename, "r");
   if (fid == -1)
     error ("textread: could not open '%s' for reading", filename);
   endif
@@ -58,10 +58,11 @@ function varargout = textread (filename,
     fskipl (fid, headerlines);
     varargin(headerlines:headerlines+1) = [];
   endif
   
   str = fread (fid, "char=>char").';
   fclose (fid);
   
   ## Call strread to make it do the real work
-  [varargout{1:max (nargout, 1)}] = strread (str, formatstr, varargin {:});
+  [varargout{1:max (nargout, 1)}] = strread (str, format, varargin {:});
+
 endfunction
diff --git a/scripts/io/textscan.m b/scripts/io/textscan.m
--- a/scripts/io/textscan.m
+++ b/scripts/io/textscan.m
@@ -45,23 +45,23 @@
 ## of format specifiers.
 ##
 ## The second output, @var{position}, provides the position, in characters,
 ## from the beginning of the file.
 ##
 ## @seealso{dlmread, fscanf, load, strread, textread}
 ## @end deftypefn
 
-function [c, p] = textscan (fid, formatstr, varargin)
+function [c, p] = textscan (fid, format, varargin)
 
   ## Check input
   if (nargin < 1)
     print_usage ();
-  elseif (nargin == 1 || isempty (formatstr))
-    formatstr = "%f";
+  elseif (nargin == 1 || isempty (format))
+    format = "%f";
   endif
 
   if (nargin > 2 && isnumeric (varargin{1}))
     nlines = varargin{1};
     args = varargin(2:end);
   else
     nlines = Inf;
     args = varargin;
@@ -69,17 +69,17 @@ function [c, p] = textscan (fid, formats
 
   if (! any (strcmpi (args, "emptyvalue")))
     ## Matlab returns NaNs for missing values
     args{end+1} = "emptyvalue";
     args{end+1} = NaN;
   endif
 
   if (isa (fid, "double") && fid > 0 || ischar (fid))
-    if (ischar (formatstr))
+    if (ischar (format))
       if (ischar (fid))
         if (nargout == 2)
           error ("textscan: cannot provide postion information for character input")
         endif
         str = fid;
       else
         ## Maybe skip header lines
         headerlines = find (strcmpi (args, "headerlines"), 1);
@@ -93,22 +93,22 @@ function [c, p] = textscan (fid, formats
             str = strcat (str, fgets (fid));
           endfor
             else
           str = fread (fid, "char=>char").';
         endif
       endif
 
       ## Determine the number of data fields
-      num_fields = numel (strfind (formatstr, "%")) - ...
-                   numel (idx_star = strfind (formatstr, "%*"));
+      num_fields = numel (strfind (format, "%")) - ...
+                   numel (idx_star = strfind (format, "%*"));
 
       ## Call strread to make it do the real work
       c = cell (1, num_fields);
-      [c{:}] = strread (str, formatstr, args{:});
+      [c{:}] = strread (str, format, args{:});
 
       if (ischar (fid) && isfinite (nlines))
         c = cellfun (@(x) x(1:nlines), c, "uniformoutput", false);
       endif
 
       if (nargout == 2)
         p = ftell (fid);
       endif
diff --git a/scripts/linear-algebra/rref.m b/scripts/linear-algebra/rref.m
--- a/scripts/linear-algebra/rref.m
+++ b/scripts/linear-algebra/rref.m
@@ -12,58 +12,58 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{r}, @var{k}] =} rref (@var{a}, @var{tol})
+## @deftypefn {Function File} {[@var{r}, @var{k}] =} rref (@var{A}, @var{tol})
 ##
-## Returns the reduced row echelon form of @var{a}.  @var{tol} defaults
-## to @code{eps * max (size (@var{a})) * norm (@var{a}, inf)}.
+## Returns the reduced row echelon form of @var{A}.  @var{tol} defaults
+## to @code{eps * max (size (@var{A})) * norm (@var{A}, inf)}.
 ##
 ## Called with two return arguments, @var{k} returns the vector of
 ## "bound variables", which are those columns on which elimination 
 ## has been performed.
 ##
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
-##         (based on a anonymous source from the public domain)
+##         (based on an anonymous source from the public domain)
 
-function [A, k] = rref (A, tolerance)
+function [A, k] = rref (A, tol)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (ndims (A) > 2)
     error ("rref: expecting matrix argument");
   endif
 
   [rows, cols] = size (A);
 
   if (nargin < 2)
     if (isa (A, "single"))
-      tolerance = eps ("single") * max (rows, cols) * norm (A, inf ("single"));
+      tol = eps ("single") * max (rows, cols) * norm (A, inf ("single"));
     else
-      tolerance = eps * max (rows, cols) * norm (A, inf);
+      tol = eps * max (rows, cols) * norm (A, inf);
     endif
   endif
 
   used = zeros (1, cols);
   r = 1;
   for c = 1:cols
     ## Find the pivot row
     [m, pivot] = max (abs (A(r:rows,c)));
     pivot = r + pivot - 1;
 
-    if (m <= tolerance)
+    if (m <= tol)
       ## Skip column c, making sure the approximately zero terms are
       ## actually zero.
       A (r:rows, c) = zeros (rows-r+1, 1);
     else
       ## keep track of bound variables
       used (1, c) = 1;
 
       ## Swap current row and pivot row
diff --git a/scripts/linear-algebra/subspace.m b/scripts/linear-algebra/subspace.m
--- a/scripts/linear-algebra/subspace.m
+++ b/scripts/linear-algebra/subspace.m
@@ -12,50 +12,50 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{angle} =} subspace (@var{a}, @var{B})
+## @deftypefn {Function File} {@var{angle} =} subspace (@var{A}, @var{B})
 ## Determine the largest principal angle between two subspaces
-## spanned by columns of matrices @var{a} and @var{b}.
+## spanned by the columns of matrices @var{A} and @var{B}.
 ## @end deftypefn
 
 ## Author: Jaroslav Hajek <highegg@gmail.com>
 
 ## reference:
 ## [1]  Andrew V. Knyazev, Merico E. Argentati:
 ##   Principal Angles between Subspaces in an A-Based Scalar Product: 
 ##  Algorithms and Perturbation Estimates.  
 ##  SIAM Journal on Scientific Computing, Vol. 23 no. 6, pp. 2008-2040
 ##
 ## other texts are also around...
 
-function ang = subspace (a, b)
+function ang = subspace (A, B)
 
   if (nargin != 2)
     print_usage ();
-  elseif (ndims (a) != 2 || ndims (b) != 2)
+  elseif (ndims (A) != 2 || ndims (B) != 2)
     error ("subspace: expecting A and B to be 2-dimensional arrays");
-  elseif (rows (a) != rows (b))
-    error ("subspace: column dimensions of a and b must match");
+  elseif (rows (A) != rows (B))
+    error ("subspace: column dimensions of A and B must match");
   endif
 
-  a = orth (a);
-  b = orth (b);
-  c = a'*b;
+  A = orth (A);
+  B = orth (B);
+  c = A'*B;
   scos = min (svd (c));
   if (scos^2 > 1/2)
-    if (columns (a) >= columns (b))
-      c = b - a*c;
+    if (columns (A) >= columns (B))
+      c = B - A*c;
     else
-      c = a - b*c';
+      c = A - B*c';
     endif
     ssin = max (svd (c));
     ang = asin (min (ssin, 1));
   else
     ang = acos (scos);
   endif
 
 endfunction
diff --git a/scripts/linear-algebra/trace.m b/scripts/linear-algebra/trace.m
--- a/scripts/linear-algebra/trace.m
+++ b/scripts/linear-algebra/trace.m
@@ -13,36 +13,36 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} trace (@var{a})
-## Compute the trace of @var{a}, @code{sum (diag (@var{a}))}.
+## @deftypefn {Function File} {} trace (@var{A})
+## Compute the trace of @var{A}, @code{sum (diag (@var{A}))}.
 ## @end deftypefn
 
 ## Author: jwe
 
-function y = trace (x)
+function y = trace (A)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  if (ndims (x) > 2)
+  if (ndims (A) > 2)
     error ("trace: only valid on 2-D objects");
-  elseif (isempty (x))
+  elseif (isempty (A))
     y = 0;
-  elseif (any (size (x) == 1))
-    y = x(1);
+  elseif (any (size (A) == 1))
+    y = A(1);
   else
-    y = sum (diag (x));
+    y = sum (diag (A));
   endif
 
 endfunction
 
 %!assert(trace ([1, 2; 3, 4]) == 5);
 %!assert(trace ([1, 2; 3, 4; 5, 6]) == 5);
 %!assert(trace ([1, 3, 5; 2, 4, 6]) == 5);
 %!assert(trace ([]), 0);
diff --git a/scripts/miscellaneous/bunzip2.m b/scripts/miscellaneous/bunzip2.m
--- a/scripts/miscellaneous/bunzip2.m
+++ b/scripts/miscellaneous/bunzip2.m
@@ -20,26 +20,22 @@
 ## @deftypefn {Function File} {} bunzip2 (@var{bzfile}, @var{dir})
 ## Unpack the bzip2 archive @var{bzfile} to the directory @var{dir}.  If
 ## @var{dir} is not specified, it defaults to the current directory.
 ## @seealso{unpack, bzip2, tar, untar, gzip, gunzip, zip, unzip}
 ## @end deftypefn
 
 ## Author: Bill Denney <denney@seas.upenn.edu>
 
-function varargout = bunzip2 (files, outputdir)
+function varargout = bunzip2 (bzfile, dir = ".")
 
-  if (! (nargin == 1 || nargin == 2))
+  if (nargin != 1 && nargin != 2)
     print_usage ();
   endif
 
-  if (nargin == 1)
-    outputdir = ".";
-  endif
-
   if (nargout > 0)
     varargout = cell (1, nargout);
-    [varargout{:}] = unpack (files, outputdir, mfilename ());
+    [varargout{:}] = unpack (bzfile, dir, mfilename ());
   else
-    unpack (files, outputdir, mfilename ());
+    unpack (bzfile, dir, mfilename ());
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/dir.m b/scripts/miscellaneous/dir.m
--- a/scripts/miscellaneous/dir.m
+++ b/scripts/miscellaneous/dir.m
@@ -47,37 +47,37 @@
 ## @seealso{ls, stat, lstat, readdir, glob, filesep}
 ## @end deftypefn
 
 ## Author: jwe
 
 ## FIXME -- this is quite slow for large directories, so perhaps
 ## it should be converted to C++.
 
-function retval = dir (file)
+function retval = dir (directory)
 
   if (nargin == 0)
-    file = ".";
+    directory = ".";
   elseif (nargin > 1)
     print_usage ();
   endif
 
   ## Prep the retval.
   info = struct (zeros (0, 1),
                  {"name", "date", "bytes", "isdir", "datenum", "statinfo"});
 
-  if (ischar (file))
-    if (strcmp (file, "*"))
-      file = ".";
+  if (ischar (directory))
+    if (strcmp (directory, "*"))
+      directory = ".";
     endif
-    if (strcmp (file, "."))
+    if (strcmp (directory, "."))
       flst = {"."};
       nf = 1;
     else
-      flst = glob (file);
+      flst = glob (directory);
       nf = length (flst);
     endif
 
     ## Determine the file list for the case where a single directory is
     ## specified.
     if (nf == 1)
       fn = flst{1};
       [st, err, msg] = stat (fn);
@@ -131,12 +131,12 @@ function retval = dir (file)
   ## Return the output arguments.
   if (nargout > 0)
     ## Return the requested structure.
     retval = info;
   elseif (length (info) > 0)
     ## Print the structure to the screen.
     printf ("%s", list_in_columns ({info.name}));
   else
-    warning ("dir: nonexistent file `%s'", file);
+    warning ("dir: nonexistent directory `%s'", directory);
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/dos.m b/scripts/miscellaneous/dos.m
--- a/scripts/miscellaneous/dos.m
+++ b/scripts/miscellaneous/dos.m
@@ -25,20 +25,20 @@
 ## @var{text}.  If the optional second argument @code{"-echo"} is given,
 ## then also send the output from the command to the standard output.
 ## @seealso{unix, isunix, ispc, system}
 ## @end deftypefn
 
 ## Author: octave-forge ???
 ## Adapted by: jwe
 
-function [status, text] = dos (cmd, echo_arg)
+function [status, text] = dos (command, echo_arg)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   elseif (! isunix ())
-    [status, text] = system (cmd);
+    [status, text] = system (command);
     if (nargin > 1 || nargout == 0)
       printf ("%s\n", text);
     endif
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/gunzip.m b/scripts/miscellaneous/gunzip.m
--- a/scripts/miscellaneous/gunzip.m
+++ b/scripts/miscellaneous/gunzip.m
@@ -15,33 +15,29 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} gunzip (@var{gzfile}, @var{dir})
 ## Unpack the gzip archive @var{gzfile} to the directory @var{dir}.  If
 ## @var{dir} is not specified, it defaults to the current directory.  If
-## the @var{gzfile} is a directory, all files in the directory will be
+## the @var{gzfile} is a directory, all gzfile in the directory will be
 ## recursively gunzipped.
 ## @seealso{unpack, bunzip2, tar, untar, gzip, gunzip, zip, unzip}
 ## @end deftypefn
 
 ## Author: Bill Denney <denney@seas.upenn.edu>
 
-function varargout = gunzip (files, outputdir)
+function varargout = gunzip (gzfile, dir = ".")
 
-  if (! (nargin == 1 || nargin == 2))
+  if (nargin != 1 && nargin != 2)
     print_usage ();
   endif
 
-  if (nargin == 1)
-    outputdir = ".";
-  endif
-
   if (nargout > 0)
     varargout = cell (1, nargout);
-    [varargout{:}] = unpack (files, outputdir, mfilename ());
+    [varargout{:}] = unpack (gzfile, dir, mfilename ());
   else
-    unpack (files, outputdir, mfilename ());
+    unpack (gzfile, dir, mfilename ());
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/menu.m b/scripts/miscellaneous/menu.m
--- a/scripts/miscellaneous/menu.m
+++ b/scripts/miscellaneous/menu.m
@@ -25,17 +25,17 @@
 ## programs.  There is no limit to the number of options that may be passed
 ## in, but it may be confusing to present more than will fit easily on one
 ## screen.
 ## @seealso{disp, printf, input}
 ## @end deftypefn
 
 ## Author: jwe
 
-function num = menu (t, varargin)
+function num = menu (title, varargin)
 
   if (nargin < 2)
     print_usage ();
   endif
 
   ## Force pending output to appear before the menu.
 
   fflush (stdout);
@@ -44,18 +44,18 @@ function num = menu (t, varargin)
   ## major confusion.
 
   save_page_screen_output = page_screen_output ();
 
   unwind_protect
 
     page_screen_output (0);
 
-    if (! isempty (t))
-      disp (t);
+    if (! isempty (title))
+      disp (title);
       printf ("\n");
     endif
 
     nopt = nargin - 1;
 
     while (1)
       for i = 1:nopt
         printf ("  [%2d] ", i);
diff --git a/scripts/miscellaneous/perl.m b/scripts/miscellaneous/perl.m
--- a/scripts/miscellaneous/perl.m
+++ b/scripts/miscellaneous/perl.m
@@ -21,24 +21,24 @@
 ## @deftypefnx {Function File} {[@var{output}, @var{status}] =} perl (@var{scriptfile}, @var{argument1}, @var{argument2}, @dots{})
 ## Invoke Perl script @var{scriptfile} with possibly a list of
 ## command line arguments.
 ## Returns output in @var{output} and status
 ## in @var{status}.
 ## @seealso{system}
 ## @end deftypefn
 
-function [output, status] = perl (script = "-e ''", varargin)
+function [output, status] = perl (scriptfile = "-e ''", varargin)
 
   ## VARARGIN is intialized to {}(1x0) if no additional arguments are
   ## supplied, so there is no need to check for it, or provide an
   ## initial value in the argument list of the function definition.
 
-  if (ischar (script)
+  if (ischar (scriptfile)
       && ((nargin != 1 && iscellstr (varargin))
-          || (nargin == 1 && ! isempty (script))))
-    [status, output] = system (cstrcat ("perl ", script,
+          || (nargin == 1 && ! isempty (scriptfile))))
+    [status, output] = system (cstrcat ("perl ", scriptfile,
                                         sprintf (" %s", varargin{:})));
   else
     error ("perl: invalid arguments");
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/run.m b/scripts/miscellaneous/run.m
--- a/scripts/miscellaneous/run.m
+++ b/scripts/miscellaneous/run.m
@@ -12,32 +12,32 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Command} {} run @var{f}
-## @deftypefnx {Function File} {} run (@var{f})
+## @deftypefn  {Command} {} run @var{script}
+## @deftypefnx {Function File} {} run (@var{script})
 ## Run scripts in the current workspace that are not necessarily on the
-## path.  If @var{f} is the script to run, including its path, then @code{run}
-## changes the directory to the directory where @var{f} is found.  @code{run}
+## path.  If @var{script} is the script to run, including its path, then @code{run}
+## changes the directory to the directory where @var{script} is found.  @code{run}
 ## then executes the script, and returns to the original directory.
 ## @seealso{system}
 ## @end deftypefn
 
-function run (s)
+function run (script)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  [d, f, ext] = fileparts (s);
+  [d, f, ext] = fileparts (script);
   if (! isempty (d))
     if (exist (d, "dir"))
       wd = pwd ();
       unwind_protect
         cd (d);
         if (! exist (cstrcat (f, ext), "file"))
           error ("run: file must exist and be a valid Octave script file");
         endif
@@ -45,16 +45,16 @@ function run (s)
                 "rethrow (lasterror ())");
       unwind_protect_cleanup
         cd (wd);
       end_unwind_protect
     else
       error ("run: the path %s doesn't exist", d);
     endif
   else
-    if (exist (s, "file"))
-      evalin ("caller", sprintf ("source (\"%s\");", s),
+    if (exist (script, "file"))
+      evalin ("caller", sprintf ("source (\"%s\");", script),
               "rethrow (lasterror ())");
     else
-      error ("run: %s not found", s);
+      error ("run: %s not found", script);
     endif
   endif
 endfunction
diff --git a/scripts/miscellaneous/unix.m b/scripts/miscellaneous/unix.m
--- a/scripts/miscellaneous/unix.m
+++ b/scripts/miscellaneous/unix.m
@@ -25,20 +25,20 @@
 ## @var{text}.  If the optional second argument @code{"-echo"} is given,
 ## then also send the output from the command to the standard output.
 ## @seealso{isunix, ispc, system}
 ## @end deftypefn
 
 ## Author: octave-forge ???
 ## Adapted by: jwe
 
-function [status, text] = unix (cmd, echo_arg)
+function [status, text] = unix (command, echo_arg)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   elseif (isunix ())
-    [status, text] = system (cmd);
+    [status, text] = system (command);
     if (nargin > 1 || nargout == 0)
       printf ("%s\n", text);
     endif
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/unpack.m b/scripts/miscellaneous/unpack.m
--- a/scripts/miscellaneous/unpack.m
+++ b/scripts/miscellaneous/unpack.m
@@ -12,44 +12,38 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{files} =} unpack (@var{file}, @var{dir})
+## @deftypefn  {Function File} {@var{files} =} unpack (@var{file})
+## @deftypefnx {Function File} {@var{files} =} unpack (@var{file}, @var{dir})
 ## @deftypefnx {Function File} {@var{files} =} unpack (@var{file}, @var{dir}, @var{filetype})
 ## Unpack the archive @var{file} based on its extension to the directory
 ## @var{dir}.  If @var{file} is a cellstr, then all files will be
 ## handled individually.  If @var{dir} is not specified, it defaults to
 ## the current directory.  It returns a list of @var{files}
 ## unpacked.  If a directory is in the file list, then the
 ## @var{filetype} to unpack must also be specified.
 ##
 ## The @var{files} includes the entire path to the output files.
 ## @seealso{bunzip2, tar, untar, gzip, gunzip, zip, unzip}
 ## @end deftypefn
 
 ## Author: Bill Denney <denney@seas.upenn.edu>
 
-function filelist = unpack (file, directory, filetype)
+function filelist = unpack (file, dir = ".", filetype = "")
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
-  if (nargin < 2)
-    directory = ".";
-  endif
-  if (nargin < 3)
-    filetype = "";
-  endif
-
   if (ischar (file))
     if (isdir (file))
       if (isempty (filetype))
         error ("unpack: filetype must be given for a directory");
       elseif (! any (strcmpi (filetype, "gunzip")))
         error ("unpack: filetype must be gunzip for a directory");
       endif
     else
@@ -59,46 +53,46 @@ function filelist = unpack (file, direct
       if (any (strcmpi ({".gz" ".Z" ".bz2" ".bz"}, ext)))
         [tmppathstr, tmpname, tmpext] = fileparts (name);
         if (strcmpi (tmpext, ".tar"))
           name = tmpname;
           ext = cstrcat (tmpext, ext);
         endif
       endif
 
-      ## If the file is a url, download it and then work with that
+      ## If the file is a URL, download it and then work with that
       ## file.
       if (! isempty (strfind (file, "://")))
-        ## FIXME -- the above is not a perfect test for a url
+        ## FIXME -- the above is not a perfect test for a URL
         urlfile = file;
         ## FIXME -- should we name the file that we download with the
-        ## same file name as the url requests?
+        ## same file name as the URL requests?
         tmpfile = cstrcat (tmpnam (), ext);
         [file, success, msg] = urlwrite (urlfile, tmpfile);
         if (! success)
           error ("unpack: could not get \"%s\": %s", urlfile, msg);
         endif
       endif
 
     endif
 
     ## canonicalize_file_name returns empty if the file isn't found, so
-    ## use that to check for existence
+    ## use that to check for existence.
     cfile = canonicalize_file_name (file);
 
     if (isempty (cfile))
       error ("unpack: file \"%s\" not found.", file);
     else
       file = cfile;
     endif
 
   elseif (iscellstr (file))
     files = {};
     for i = 1:numel (file)
-      tmpfiles = unpack (file{i}, directory);
+      tmpfiles = unpack (file{i}, dir);
       files = {files{:} tmpfiles{:}};
     endfor
 
     ## Return output if requested.
     if (nargout > 0)
       filelist = files;
     endif
 
@@ -147,42 +141,42 @@ function filelist = unpack (file, direct
 
   nodotext = ext(! ismember (ext, "."));
   
   origdir = pwd ();
 
   if (isfield (commandlist, nodotext))
     [commandv, commandq, parser, move] = deal (commandlist.(nodotext){:});
     cstartdir = canonicalize_file_name (origdir);
-    cenddir = canonicalize_file_name (directory);
+    cenddir = canonicalize_file_name (dir);
     needmove = move && ! strcmp (cstartdir, cenddir);
     if (nargout > 0 || needmove)
       command = commandv;
     else
       command = commandq;
     endif
   else
     warning ("unpack:filetype", "unrecognised file type, %s", ext);
     files = file;
     return;
   endif
 
   ## Create the directory if necessary.
-  s = stat (directory);
+  s = stat (dir);
   if (isempty (s))
-    [status, msg] = mkdir (directory);
+    [status, msg] = mkdir (dir);
     if (! status)
-      error ("unpack: mkdir failed to create %s: %s", directory, msg);
+      error ("unpack: mkdir failed to create %s: %s", dir, msg);
     endif
   elseif (! S_ISDIR (s.mode))
-    error ("unpack: %s: not a directory", directory);
+    error ("unpack: %s: not a directory", dir);
   endif
 
   unwind_protect
-    cd (directory);
+    cd (dir);
     [status, output] = system (sprintf (cstrcat (command, " 2>&1"), file));
   unwind_protect_cleanup
     cd (origdir);
   end_unwind_protect
 
   if (status)
     error ("unpack: unarchiving program exited with status: %d\n%s",
            status, output);
@@ -193,20 +187,20 @@ function filelist = unpack (file, direct
     ## FIXME -- will this need to change to a check for "\r\n" for windows?
     if (output(length (output)) == "\n")
       output(length (output)) = [];
     endif
     files = parser (strsplit (output, "\n"))';
 
     ## Move files if necessary
     if (needmove)
-      [st, msg, msgid] = movefile (files, directory);
+      [st, msg, msgid] = movefile (files, dir);
       if (! st)
         error ("unpack: unable to move files to \"%s\": %s",
-               directory, msg);
+               dir, msg);
       endif
 
       ## Fix the names for the files since they were moved.
       for i = 1:numel (files)
         files{i} = strrep (files{i}, cstartdir, cenddir);
       endfor
     endif
 
diff --git a/scripts/miscellaneous/untar.m b/scripts/miscellaneous/untar.m
--- a/scripts/miscellaneous/untar.m
+++ b/scripts/miscellaneous/untar.m
@@ -21,26 +21,22 @@
 ## Unpack the TAR archive @var{tarfile} to the directory @var{dir}.
 ## If @var{dir} is not specified, it defaults to the current directory.
 ## @seealso{unpack, bunzip2, tar, gzip, gunzip, zip, unzip}
 ## @end deftypefn
 
 ## Author: Sren Hauberg <hauberg@gmail.com>
 ## Adapted-By: jwe, Bill Denney
 
-function varargout = untar (files, outputdir)
+function varargout = untar (tarfile, dir = ".")
 
-  if (! (nargin == 1 || nargin == 2))
+  if (nargin != 1 && nargin != 2)
     print_usage ();
   endif
 
-  if (nargin == 1)
-    outputdir = ".";
-  endif
-
   if (nargout > 0)
     varargout = cell (1, nargout);
-    [varargout{:}] = unpack (files, outputdir, mfilename ());
+    [varargout{:}] = unpack (tarfile, dir, mfilename ());
   else
-    unpack (files, outputdir, mfilename ());
+    unpack (tarfile, dir, mfilename ());
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/unzip.m b/scripts/miscellaneous/unzip.m
--- a/scripts/miscellaneous/unzip.m
+++ b/scripts/miscellaneous/unzip.m
@@ -12,35 +12,32 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} unzip (@var{zipfile}, @var{dir})
+## @deftypefn  {Function File} {} unzip (@var{zipfile})
+## @deftypefnx {Function File} {} unzip (@var{zipfile}, @var{dir})
 ## Unpack the ZIP archive @var{zipfile} to the directory @var{dir}.
 ## If @var{dir} is not specified, it defaults to the current directory.
 ## @seealso{unpack, bunzip2, tar, untar, gzip, gunzip, zip}
 ## @end deftypefn
 
 ## Author: Sren Hauberg <hauberg@gmail.com>
 ## Adapted-By: jwe, Bill Denney
 
-function varargout = unzip (files, outputdir)
+function varargout = unzip (zipfile, dir = ".")
 
-  if (! (nargin == 1 || nargin == 2))
+  if (nargin != 1 && nargin != 2)
     print_usage ();
   endif
 
-  if (nargin == 1)
-    outputdir = ".";
-  endif
-
   if (nargout > 0)
     varargout = cell (1, nargout);
-    [varargout{:}] = unpack (files, outputdir, mfilename ());
+    [varargout{:}] = unpack (zipfile, dir, mfilename ());
   else
-    unpack (files, outputdir, mfilename ());
+    unpack (zipfile, dir, mfilename ());
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/ver.m b/scripts/miscellaneous/ver.m
--- a/scripts/miscellaneous/ver.m
+++ b/scripts/miscellaneous/ver.m
@@ -35,29 +35,25 @@
 ##
 ##   @item Revision
 ##   Revision of the package.
 ##
 ##   @item Date
 ##   Date respecting the version/revision.
 ## @end table
 ## @deftypefnx {Function File} {v =} ver (@code{"Octave"})
-## Return version information for Octave only..
-## @deftypefnx {Function File} {v =} ver (@var{pkg})
-## Return version information for the specified package @var{pkg}.
+## Return version information for Octave only.
+## @deftypefnx {Function File} {v =} ver (@var{package})
+## Return version information for @var{package}.
 ## @seealso{license, version}
 ## @end deftypefn
 
 ## Author: William Poetra Yoga Hadisoeseno <williampoetra@gmail.com>
 
-function varargout = ver (pack)
-
-  if (nargin == 0)
-    pack = "";
-  endif
+function varargout = ver (package = "")
 
   if (nargin > 1)
     print_usage ();
   endif
 
   ## Start with the version info for Octave
   ret = struct ("Name", "Octave", "Version", version,
                 "Release", [], "Date", []);
@@ -88,20 +84,20 @@ function varargout = ver (pack)
 
     ver_desc = sprintf ("%s\n%s%s\n%s%s\n%s%s\n%s\n", hbar, ver_line1, version,
                         ver_line2, octave_license, ver_line3, os_string, hbar);
 
     puts (ver_desc);
 
     pkg ("list");
   else
-    if (! isempty (pack))
+    if (! isempty (package))
       n = [];
       for r = 1:numel(ret)
-        if (strcmpi (ret(r).Name, pack))
+        if (strcmpi (ret(r).Name, package))
           n = r;
           break;
         endif
       endfor
       ret = ret(n);
     endif
     varargout{1} = ret;
   endif
diff --git a/scripts/path/savepath.m b/scripts/path/savepath.m
--- a/scripts/path/savepath.m
+++ b/scripts/path/savepath.m
@@ -22,37 +22,37 @@
 ## not set during Octave's initialization process, to @var{file}.
 ## If @var{file} is omitted, @file{~/.octaverc} is used.  If successful,
 ## @code{savepath} returns 0.
 ## @seealso{path, addpath, rmpath, genpath, pathdef, pathsep}
 ## @end deftypefn
 
 ## Author: Bill Denney <bill@givebillmoney.com>
 
-function varargout = savepath (savefile)
+function varargout = savepath (file)
 
   retval = 1;
 
   beginstring = "## Begin savepath auto-created section, do not edit";
   endstring   = "## End savepath auto-created section";
 
   if (nargin == 0)
-    savefile = fullfile ("~", ".octaverc");
+    file = fullfile ("~", ".octaverc");
   endif
 
   ## parse the file if it exists to see if we should replace a section
   ## or create a section
   startline = 0;
   endline = 0;
   filelines = {};
-  if (exist (savefile) == 2)
+  if (exist (file) == 2)
     ## read in all lines of the file
-    [fid, msg] = fopen (savefile, "rt");
+    [fid, msg] = fopen (file, "rt");
     if (fid < 0)
-      error ("savepath: could not open savefile, %s: %s", savefile, msg);
+      error ("savepath: could not open file, %s: %s", file, msg);
     endif
     unwind_protect
       linenum = 0;
       while (linenum >= 0)
         result = fgetl (fid);
         if (isnumeric (result))
           ## end at the end of file
           linenum = -1;
@@ -65,24 +65,24 @@ function varargout = savepath (savefile)
           elseif (strcmp (result, endstring))
             endline = linenum;
           endif
         endif
       endwhile
     unwind_protect_cleanup
       closeread = fclose (fid);
       if (closeread < 0)
-        error ("savepath: could not close savefile after reading, %s",
-               savefile);
+        error ("savepath: could not close file after reading, %s",
+               file);
       endif
     end_unwind_protect
   endif
 
   if (startline > endline || (startline > 0 && endline == 0))
-    error ("savepath: unable to parse file, %s", savefile);
+    error ("savepath: unable to parse file, %s", file);
   endif
 
   ## put the current savepath lines into the file
   if (isempty (filelines)
       || (startline == 1 && endline == length (filelines)))
     ## savepath is the entire file
     pre = post = {};
   elseif (endline == 0)
@@ -97,19 +97,19 @@ function varargout = savepath (savefile)
     post = {};
   else
     ## insert in the middle
     pre = filelines(1:startline-1);
     post = filelines(endline+1:end);
   endif
 
   ## write the results
-  [fid, msg] = fopen (savefile, "wt");
+  [fid, msg] = fopen (file, "wt");
   if (fid < 0)
-    error ("savepath: unable to open file for writing, %s, %s", savefile, msg);
+    error ("savepath: unable to open file for writing, %s, %s", file, msg);
   endif
   unwind_protect
     for i = 1:length (pre)
       fprintf (fid, "%s\n", pre{i})
     endfor
 
     ## Remove the portion of the path defined via the command line
     ## and/or the environment.
@@ -188,27 +188,27 @@ function varargout = savepath (savefile)
     fprintf (fid, "%s\n", endstring)
 
     for i = 1:length (post)
       fprintf (fid, "%s\n", post{i});
     endfor
   unwind_protect_cleanup
     closeread = fclose (fid);
     if (closeread < 0)
-      error ("savepath: could not close savefile after writing, %s", savefile);
+      error ("savepath: could not close savefile after writing, %s", file);
     elseif (nargin == 0)
-      warning ("savepath: current path saved to %s", savefile);
+      warning ("savepath: current path saved to %s", file);
     endif
   end_unwind_protect
 
   retval = 0;
 
   if (nargout == 1)
     varargout{1} = retval;
   endif
   
 endfunction  
 
 function path_elements = parsepath (p)
   pat = sprintf ('([^%s]+[%s$])', pathsep, pathsep);
-  [jnk1, jnk2, jnk3, path_elements] = regexpi (strcat (p, pathsep), pat);
+  [~, ~, ~, path_elements] = regexpi (strcat (p, pathsep), pat);
 endfunction
 
diff --git a/scripts/plot/allchild.m b/scripts/plot/allchild.m
--- a/scripts/plot/allchild.m
+++ b/scripts/plot/allchild.m
@@ -16,35 +16,35 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{h} =} allchild (@var{handles})
 ## Find all children, including hidden children, of a graphics object.
 ##
 ## This function is similar to @code{get (h, "children")}, but also
-## returns includes hidden objects.  If @var{handles} is a scalar,
+## returns hidden objects.  If @var{handles} is a scalar,
 ## @var{h} will be a vector.  Otherwise, @var{h} will be a cell matrix
 ## of the same size as @var{handles} and each cell will contain a
 ## vector of handles.
 ## @seealso{get, set, findall, findobj}
 ## @end deftypefn
 
 ## Author: Bill Denney <bill@denney.ws>
 
-function h = allchild (ha)
+function h = allchild (handles)
 
   shh = get (0, "showhiddenhandles");
   unwind_protect
     set (0, "showhiddenhandles", "on");
-    if (isscalar (ha))
-      h = get (ha, "children");
+    if (isscalar (handles))
+      h = get (handles, "children");
     else
-      h = cell (size (ha));
-      for i = 1:numel (ha)
-        h{i} = get (ha, "children");
+      h = cell (size (handles));
+      for i = 1:numel (handles)
+        h{i} = get (handles, "children");
       endfor
     endif
   unwind_protect_cleanup
     set (0, "showhiddenhandles", shh);
   end_unwind_protect
 
 endfunction
diff --git a/scripts/plot/diffuse.m b/scripts/plot/diffuse.m
--- a/scripts/plot/diffuse.m
+++ b/scripts/plot/diffuse.m
@@ -12,20 +12,20 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} diffuse (@var{sx}, @var{sy}, @var{sz}, @var{l})
+## @deftypefn {Function File} {} diffuse (@var{sx}, @var{sy}, @var{sz}, @var{lv})
 ## Calculate diffuse reflection strength of a surface defined by the normal
 ## vector elements @var{sx}, @var{sy}, @var{sz}. 
-## The light vector can be specified using parameter @var{L}.  It can be
+## The light vector can be specified using parameter @var{lv}.  It can be
 ## given as 2-element vector [azimuth, elevation] in degrees or as 3-element
 ## vector [lx, ly, lz]. 
 ## @seealso{specular, surfl}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 
 function retval = diffuse (sx, sy, sz, lv)
diff --git a/scripts/plot/fplot.m b/scripts/plot/fplot.m
--- a/scripts/plot/fplot.m
+++ b/scripts/plot/fplot.m
@@ -36,17 +36,17 @@
 ##    fplot ("[cos(x), sin(x)]", [0, 2*pi])
 ## @end group
 ## @end example
 ## @seealso{plot}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 
-function fplot (fn, limits, n, linespec)
+function fplot (fn, limits, n, fmt)
   if (nargin < 2 || nargin > 4)
     print_usage ();
   endif
 
   if (!isreal (limits) || (numel (limits) != 2 && numel (limits) != 4))
     error ("fplot: second input argument must be a real vector with 2 or 4 elements");
   endif
 
@@ -56,17 +56,17 @@ function fplot (fn, limits, n, linespec)
 
   have_linespec = true;
   if (nargin < 4) 
     have_linespec = false;
   endif
 
   if (ischar (n))
     have_linespec = true;
-    linespec = n;
+    fmt = n;
     n = 0.002;
   endif
 
   if (strcmp (typeinfo (fn), "inline function"))
     fn = vectorize (fn);
     nam = formula (fn);
   elseif (isa (fn, "function_handle"))
     nam = func2str (fn);
@@ -102,17 +102,17 @@ function fplot (fn, limits, n, linespec)
       y = feval (fn, x);
     endwhile 
   else
     x = linspace (limits(1), limits(2), n)';
     y = feval (fn, x);
   endif
 
   if (have_linespec)
-    plot (x, y, linespec);
+    plot (x, y, fmt);
   else
     plot (x, y);
   endif
 
   if (length (limits) > 2) 
     axis (limits);
   endif
 
diff --git a/scripts/plot/refreshdata.m b/scripts/plot/refreshdata.m
--- a/scripts/plot/refreshdata.m
+++ b/scripts/plot/refreshdata.m
@@ -45,35 +45,37 @@
 ##   pause(0.1)
 ##   y = sin (x + 0.1 * i);
 ##   refreshdata();
 ## endfor
 ## @end group
 ## @end example
 ## @end deftypefn
 
-function refreshdata (h, ws)
+function refreshdata (h, workspace)
 
   if (nargin == 0)
     h = gcf ();
-    ws = "base";
+    workspace = "base";
   else
     if (iscell (h))
       h = [h{:}];
     endif
     if (!all (ishandle (h)) || !all (strcmp (get (h, "type"), "figure")))
       error ("refreshdata: expecting a list of figure handles");
     endif
     if (nargin < 2)
-      ws = "base";
+      workspace = "base";
     else
-      if (!ischar (ws) || !(strcmpi (ws, "base") || strcmpi (ws, "caller")))
+      if (   !ischar (workspace) 
+          || !(strcmpi (workspace, "base")
+          || strcmpi (workspace, "caller")))
         error ("refreshdata: expecting workspace to be \"base\" or ""caller\"");
       else
-        ws = tolower (ws);
+        workspace = tolower (workspace);
       endif
     endif
   endif
 
   h = findall (h);
   objs = [];
   props = {};
 
@@ -88,17 +90,17 @@ function refreshdata (h, ws)
       objs  = [objs ; h(i)];
     endif
   endfor
 
   for i = 1 : length (objs)
     for j = 1 : length (props {i})
       expr = get (objs(i), props{i}{j});
       if (!isempty (expr))
-        val = evalin (ws, expr);
+        val = evalin (workspace, expr);
         prop =  props{i}{j}(1:end-6);
         if (! isequal (get (objs(i), prop), val))
           set (objs(i), props{i}{j}(1:end-6), val);
         endif
       endif
     endfor
   endfor
 endfunction
diff --git a/scripts/plot/saveas.m b/scripts/plot/saveas.m
--- a/scripts/plot/saveas.m
+++ b/scripts/plot/saveas.m
@@ -13,21 +13,21 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} saveas (@var{h}, @var{filename})
-## @deftypefnx {Function File} {} saveas (@var{h}, @var{filename}, @var{ext})
-## Save the graphic object @var{h} to file @var{filename} in graphic
-## format @var{ext}. 
+## @deftypefnx {Function File} {} saveas (@var{h}, @var{filename}, @var{fmt})
+## Save graphic object @var{h} to the file @var{filename} in graphic
+## format @var{fmt}. 
 ## 
-## @var{ext} should be one of the following formats:
+## @var{fmt} should be one of the following formats:
 ##
 ## @table @code
 ##   @item ps
 ##     Postscript
 ##
 ##   @item eps
 ##     Encapsulated Postscript
 ##
@@ -40,69 +40,69 @@
 ##   @item emf
 ##     Enhanced Meta File
 ##
 ##   @item pdf
 ##     Portable Document Format
 ## @end table
 ##
 ## All device formats specified in @code{print} may also be used.  If
-## @var{ext} is omitted it is extracted from @var{filename}.  The default
-## value is pdf.
+## @var{fmt} is omitted it is extracted from the extension of @var{filename}.
+## The default format is @code{"pdf"}.
 ##
 ## @example
 ## @group
 ## figure (1);
 ## clf ();
 ## surf (peaks);
 ## saveas(1, "figure1.png");
 ## @end group
 ## @end example
 ##
 ## @seealso{print}
 ## @end deftypefn
 
 ## Author: Kai Habel
 
-function  saveas (h, fname, fext = "pdf")
+function  saveas (h, filename, fmt = "pdf")
 
   if ((nargin != 2) && (nargin != 3))
     print_usage ();
   endif
 
   if (ishandle (h))
     if (isfigure (h))
       fig = h;
     else
       fig = ancestor (h, "figure");
     endif
   else
     error ("saveas: first argument H must be a graphics handle");
   endif
   
-  if (!ischar (fname))
+  if (!ischar (filename))
     error ("saveas: FILENAME must be a string");
   endif
 
   if (nargin == 2)
-    [~, ~, ext] = fileparts (fname);
+    [~, ~, ext] = fileparts (filename);
     if (!isempty (ext))
-      fext = ext(2:end);
+      fmt = ext(2:end);
     endif
   endif
 
   if (nargin == 3)
-    if (!ischar (fname))
+    if (!ischar (filename))
       error ("saveas: EXT must be a string");
     endif
 
-    [~, ~, ext] = fileparts (fname);
+    [~, ~, ext] = fileparts (filename);
 
     if (isempty (ext))
-      fname = strcat (fname, ".", fext);
+      filename = strcat (filename, ".", fmt);
     endif
   endif
 
-  prt_opt = strcat ("-d", tolower (fext));
+  prt_opt = strcat ("-d", tolower (fmt));
   
-  print (fname, prt_opt);
+  print (filename, prt_opt);
 
 endfunction
diff --git a/scripts/plot/specular.m b/scripts/plot/specular.m
--- a/scripts/plot/specular.m
+++ b/scripts/plot/specular.m
@@ -12,22 +12,22 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} specular (@var{sx}, @var{sy}, @var{sz}, @var{l}, @var{v})
-## @deftypefnx {Function File} {} specular (@var{sx}, @var{sy}, @var{sz}, @var{l}, @var{v}, @var{se})
+## @deftypefn  {Function File} {} specular (@var{sx}, @var{sy}, @var{sz}, @var{lv}, @var{vv})
+## @deftypefnx {Function File} {} specular (@var{sx}, @var{sy}, @var{sz}, @var{lv}, @var{vv}, @var{se})
 ## Calculate specular reflection strength of a surface defined by the normal
 ## vector elements @var{sx}, @var{sy}, @var{sz} using Phong's approximation. 
-## The light and view vectors can be specified using parameter @var{L} and
-## @var{V} respectively.
+## The light and view vectors can be specified using parameter @var{lv} and
+## @var{vv} respectively.
 ## Both can be given as 2-element vectors [azimuth, elevation] in degrees or as
 ## 3-element
 ## vector [x, y, z].  An optional 6th argument describes the specular exponent
 ## (spread) @var{se}.
 ## @seealso{surfl, diffuse}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -15,17 +15,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} subplot (@var{rows}, @var{cols}, @var{index})
 ## @deftypefnx {Function File} {} subplot (@var{rcn})
-## Set up a plot grid with @var{cols} by @var{rows} subwindows and plot
+## Set up a plot grid with @var{rows} by @var{cols} subwindows and plot
 ## in location given by @var{index}.
 ##
 ## If only one argument is supplied, then it must be a three digit value
 ## specifying the location in digits 1 (rows) and 2 (columns) and the plot
 ## index in digit 3.
 ##
 ## The plot index runs row-wise.  First all the columns in a row are filled
 ## and then the next row is filled.
@@ -55,17 +55,17 @@
 ##
 ## @end ifnottex
 ## @seealso{plot}
 ## @end deftypefn
 
 ## Author: Vinayak Dutt <Dutt.Vinayak@mayo.EDU>
 ## Adapted-By: jwe
 
-function h = subplot (rows, columns, index, varargin)
+function h = subplot (rows, cols, index, varargin)
 
   align_axes = false;
   replace_axes = false;
 
   if (! (nargin >= 3) && nargin != 1)
     print_usage ();
   elseif (nargin > 3)
     for n = 1:numel(varargin)
@@ -84,42 +84,42 @@ function h = subplot (rows, columns, ind
 
     if (! (isscalar (rows) && rows >= 0))
       error ("subplot: input rcn has to be a positive scalar");
     endif
 
     tmp = rows;
     index = rem (tmp, 10);
     tmp = (tmp - index) / 10;
-    columns = rem (tmp, 10);
-    tmp = (tmp - columns) / 10;
+    cols = rem (tmp, 10);
+    tmp = (tmp - cols) / 10;
     rows = rem (tmp, 10);
 
-  elseif (! (isscalar (columns) && isscalar (rows)))
-    error ("subplot: columns, and rows must be scalars");
-  elseif (any (index < 1) || any (index > rows*columns))
-    error ("subplot: index value must be greater than 1 and less than rows*columns")
+  elseif (! (isscalar (cols) && isscalar (rows)))
+    error ("subplot: cols, and rows must be scalars");
+  elseif (any (index < 1) || any (index > rows*cols))
+    error ("subplot: index value must be greater than 1 and less than rows*cols")
   endif
 
-  columns = round (columns);
+  cols = round (cols);
   rows = round (rows);
   index = round (index);
 
-  if (index > columns*rows)
-    error ("subplot: index must be less than columns*rows");
+  if (index > cols*rows)
+    error ("subplot: index must be less than cols*rows");
   endif
 
-  if (columns < 1 || rows < 1 || index < 1)
-    error ("subplot: columns,rows,index must be be positive");
+  if (cols < 1 || rows < 1 || index < 1)
+    error ("subplot: cols,rows,index must be be positive");
   endif
 
   units = get (0, "defaultaxesunits");
   unwind_protect
     set (0, "defaultaxesunits", "normalized")
-    pos = subplot_position (rows, columns, index, "position", units);
+    pos = subplot_position (rows, cols, index, "position", units);
 
     cf = gcf ();
 
     set (cf, "nextplot", "add");
 
     found = false;
     kids = get (cf, "children");
     for child = reshape (kids, 1, numel (kids))
@@ -158,18 +158,18 @@ function h = subplot (rows, columns, ind
           endif
         endif
       endif
     endfor
 
     if (found)
       set (cf, "currentaxes", tmp);
     else
-      pos = subplot_position (rows, columns, index, "outerposition", units);
-      pos2 = subplot_position (rows, columns, index, "position", units);
+      pos = subplot_position (rows, cols, index, "outerposition", units);
+      pos2 = subplot_position (rows, cols, index, "position", units);
       tmp = axes ("outerposition", pos, "position", pos2,
                   "activepositionproperty", "outerposition");
     endif
 
     if (align_axes && strcmp (get (cf, "__backend__"), "gnuplot"))
       set (tmp, "activepositionproperty", "position");
     endif
 
@@ -178,54 +178,54 @@ function h = subplot (rows, columns, ind
   end_unwind_protect
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
-function pos = subplot_position (rows, columns, index, position_property, units)
+function pos = subplot_position (rows, cols, index, position_property, units)
 
   ## For 1 row and 1 column return the usual default.
-  if (rows == 1 && columns == 1)
+  if (rows == 1 && cols == 1)
     if (strcmpi (position_property, "position"))
       pos = get (0, "defaultaxesposition");
     else
       pos = get (0, "defaultaxesouterposition");
     endif
     return
   endif
 
   ## This produces compatible behavior for the "position" property.
   margins.left   = 0.130;
   margins.right  = 0.095;
   margins.top    = 0.075;
   margins.bottom = 0.110;
   pc = 1 ./ [0.1860, (margins.left + margins.right - 1)];
-  margins.column = 1 ./ polyval (pc , columns);
+  margins.column = 1 ./ polyval (pc , cols);
   pr = 1 ./ [0.2282, (margins.top + margins.bottom - 1)];
   margins.row    = 1 ./ polyval (pr , rows);
 
   ## Calculate the width/height of the subplot axes.
-  width = 1 - margins.left - margins.right - (columns-1)*margins.column;
-  width = width / columns;
+  width = 1 - margins.left - margins.right - (cols-1)*margins.column;
+  width = width / cols;
   height = 1 - margins.top - margins.bottom - (rows-1)*margins.row;
   height = height / rows;
 
   if (strcmp (position_property, "outerposition") )
     ## Calculate the outerposition/position inset
     if (rows > 1)
       inset.top    = 8/420;
       inset.bottom = max (polyval ([0.1382,-0.0026], height), 16/420);
     else
       inset.bottom = margins.bottom;
       inset.top = margins.top;
     endif
-    if (columns > 1)
+    if (cols > 1)
       if (strcmpi (units, "normalized"))
         inset.right = max (polyval ([0.1200,-0.0014], width), 5/560);
       else
         inset.right = max (polyval ([0.1252,-0.0023], width), 5/560);
       endif
       inset.left   = 22/560;
     else
       inset.left  = margins.left;
@@ -233,18 +233,18 @@ function pos = subplot_position (rows, c
     endif
     ## Apply the inset to the geometries for the "position" property.
     margins.column = margins.column - inset.right - inset.left;
     margins.row = margins.row - inset.top - inset.bottom;
     width = width + inset.right + inset.left;
     height = height + inset.top + inset.bottom;
   endif
 
-  yp = fix ((index(:)-1)/columns);
-  xp = index(:) - yp*columns - 1;
+  yp = fix ((index(:)-1)/cols);
+  xp = index(:) - yp*cols - 1;
   yp = (rows - 1) - yp;
 
   x0 = xp .* (width + margins.column) + margins.left;
   y0 = yp .* (height + margins.row) + margins.bottom;
 
   if (strcmp (position_property, "outerposition") )
     x0 = x0 - inset.left;
     y0 = y0 - inset.bottom;
diff --git a/scripts/plot/title.m b/scripts/plot/title.m
--- a/scripts/plot/title.m
+++ b/scripts/plot/title.m
@@ -13,28 +13,28 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} title (@var{title})
-## @deftypefnx {Function File} {} title (@var{title}, @var{p1}, @var{v1}, @dots{})
+## @deftypefn  {Function File} {} title (@var{string})
+## @deftypefnx {Function File} {} title (@var{string}, @var{p1}, @var{v1}, @dots{})
 ## Create a title object and return a handle to it.
 ## @end deftypefn
 
 ## Author: jwe
 
-function h = title (s, varargin)
+function h = title (string, varargin)
 
   if (rem (nargin, 2) == 1)
     if (nargout > 0)
-      h = __axis_label__ ("title", s, varargin{:});
+      h = __axis_label__ ("title", string, varargin{:});
     else
-      __axis_label__ ("title", s, varargin{:});
+      __axis_label__ ("title", string, varargin{:});
     endif
   else
     print_usage ();
   endif
 
 endfunction
diff --git a/scripts/plot/uigetdir.m b/scripts/plot/uigetdir.m
--- a/scripts/plot/uigetdir.m
+++ b/scripts/plot/uigetdir.m
@@ -12,41 +12,43 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{dirname} =} uigetdir (@var{init_path}, @var{dialog_name})
+## @deftypefn  {Function File} {@var{dirname} =} uigetdir ()
 ## @deftypefnx {Function File} {@var{dirname} =} uigetdir (@var{init_path})
-## @deftypefnx {Function File} {@var{dirname} =} uigetdir ()
+## @deftypefnx {Function File} {@var{dirname} =} uigetdir (@var{init_path}, @var{dialog_name})
 ## Open a GUI dialog to select a directory. If @var{init_path} is not given
-## the working directory is taken. @var{dialog_name} can be used to
+## the current working directory is used. @var{dialog_name} optionally  be used to
 ## customize the dialog title.
 ## @end deftypefn
 
 ## Author: Kai Habel
 
-function [retdir] = uigetdir (init_path = pwd, name = "Choose directory?")
+function dirname = uigetdir (init_path = pwd, dialog_name = "Choose directory?")
 
-  if (!ischar(init_path) || !ischar(name))
-    error ("uigetdir: expecting string arguments.");
-  endif
-  
   if (nargin > 2)
     print_usage ();
   endif
 
-  if (any (cellfun(@(x)strcmp (x, "fltk"), available_backends)))
+  if (!ischar(init_path) || !ischar(name))
+    error ("uigetdir: INIT_PATH and DIALOG_NAME must be string arguments");
+  endif
+  
+
+  if (any (strcmp (available_backends(), "fltk")))
       if (!isdir (init_path))
         init_path = fileparts (init_path);
       endif
-      retdir = __fltk_uigetfile__ ("", name, init_path, [240, 120], "dir");
+      dirname = __fltk_uigetfile__ ("", dialog_name, init_path, [240, 120], "dir");
   else
     error ("uigetdir: fltk backend required.");
   endif
 
 endfunction
 
+
 %!demo 
 %! uigetdir(pwd, "Select Directory")
diff --git a/scripts/polynomial/polyder.m b/scripts/polynomial/polyder.m
--- a/scripts/polynomial/polyder.m
+++ b/scripts/polynomial/polyder.m
@@ -12,31 +12,32 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} polyder (@var{c})
-## @deftypefnx {Function File} {[@var{q}] =} polyder (@var{b}, @var{a})
-## @deftypefnx {Function File} {[@var{q}, @var{r}] =} polyder (@var{b}, @var{a})
-## See polyderiv.
+## @deftypefn  {Function File} {} polyderiv (@var{p})
+## @deftypefnx {Function File} {[@var{k}] =} polyderiv (@var{a}, @var{b})
+## @deftypefnx {Function File} {[@var{q}, @var{d}] =} polyderiv (@var{b}, @var{a})
+## An alias for @code{polyderiv}.
+## @seealso{polyderiv}
 ## @end deftypefn
 
 ## Author: John W. Eaton
 
-function [q, r] = polyder (p, a)
+function [q, d] = polyder (p, a)
 
   if (nargin == 1)
     q = polyderiv (p);
   elseif (nargin == 2)
     if (nargout == 2)
-      [q, r] = polyderiv (p, a);
+      [q, d] = polyderiv (p, a);
     else
       q = polyderiv (p, a);
     endif
   else
     print_usage ();
   endif
 
 endfunction
diff --git a/scripts/polynomial/polyderiv.m b/scripts/polynomial/polyderiv.m
--- a/scripts/polynomial/polyderiv.m
+++ b/scripts/polynomial/polyderiv.m
@@ -13,67 +13,68 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} polyderiv (@var{c})
-## @deftypefnx {Function File} {[@var{q}] =} polyderiv (@var{b}, @var{a})
-## @deftypefnx {Function File} {[@var{q}, @var{r}] =} polyderiv (@var{b}, @var{a})
+## @deftypefn  {Function File} {} polyderiv (@var{p})
+## @deftypefnx {Function File} {[@var{k}] =} polyderiv (@var{a}, @var{b})
+## @deftypefnx {Function File} {[@var{q}, @var{d}] =} polyderiv (@var{b}, @var{a})
 ## Return the coefficients of the derivative of the polynomial whose
-## coefficients are given by vector @var{c}.  If a pair of polynomials
-## is given @var{b} and @var{a}, the derivative of the product is
-## returned in @var{q}, or the quotient numerator in @var{q} and the
-## quotient denominator in @var{r}.
+## coefficients are given by the vector @var{p}.  If a pair of polynomials
+## is given, return the derivative of the product @math{@var{a}*@var{b}}.
+## If two inputs and two outputs are given, return the derivative of the 
+## polynomial quotient @math{@var{b}/@var{a}}.  The quotient numerator is 
+## in @var{q} and the denominator in @var{d}.
 ## @seealso{poly, polyint, polyreduce, roots, conv, deconv, residue,
 ## filter, polygcd, polyval, polyvalm}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
-function [q, r] = polyderiv (p, a)
+function [q, d] = polyderiv (p, a)
 
   if (nargin == 1 || nargin == 2)
     if (! isvector (p))
       error ("polyderiv: argument must be a vector");
     endif
     if (nargin == 2)
       if (! isvector (a))
         error ("polyderiv: argument must be a vector");
       endif
       if (nargout == 1) 
         ## derivative of p*a returns a single polynomial
         q = polyderiv (conv (p, a));
       else
         ## derivative of p/a returns numerator and denominator
-        r = conv (a, a);
+        d = conv (a, a);
         if (numel (p) == 1)
           q = -p * polyderiv (a);
         elseif (numel (a) == 1)
           q = a * polyderiv (p);
         else
           q = conv (polyderiv (p), a) - conv (p, polyderiv (a));
           q = polyreduce (q);
         endif
 
         ## remove common factors from numerator and denominator
-        x = polygcd (q, r);
+        x = polygcd (q, d);
         if (length(x) != 1)
           q = deconv (q, x);
-          r = deconv (r, x);
+          d = deconv (d, x);
         endif
 
         ## move all the gain into the numerator
-        q = q/r(1);
-        r = r/r(1);
+        q = q/d(1);
+        d = d/d(1);
       endif
     else
       lp = numel (p);
       if (lp == 1)
         q = 0;
         return;
       elseif (lp == 0)
         q = [];
diff --git a/scripts/polynomial/polyint.m b/scripts/polynomial/polyint.m
--- a/scripts/polynomial/polyint.m
+++ b/scripts/polynomial/polyint.m
@@ -12,29 +12,30 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} polyint (@var{c}, @var{k})
+## @deftypefn  {Function File} {} polyint (@var{p})
+## @deftypefnx {Function File} {} polyint (@var{p}, @var{k})
 ## Return the coefficients of the integral of the polynomial whose
-## coefficients are represented by the vector @var{c}.  The variable
+## coefficients are represented by the vector @var{p}.  The variable
 ## @var{k} is the constant of integration, which by default is set to zero.
 ## @seealso{poly, polyderiv, polyreduce, roots, conv, deconv, residue,
 ## filter, polyval, polyvalm}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
-function p = polyint (p, k)
+function retval = polyint (p, k)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (nargin == 1)
     k = 0;
   elseif (! isscalar (k))
@@ -43,20 +44,20 @@ function p = polyint (p, k)
 
   if (! (isvector (p) || isempty (p)))
     error ("polyint: argument must be a vector");
   endif
 
   lp = length (p);
 
   if (lp == 0)
-    p = [];
+    retval = [];
     return;
   endif
 
   if (rows (p) > 1)
     ## Convert to column vector
     p = p.';
   endif
 
-  p = [(p ./ [lp:-1:1]), k];
+  retval = [(p ./ [lp:-1:1]), k];
 
 endfunction
diff --git a/scripts/polynomial/polyreduce.m b/scripts/polynomial/polyreduce.m
--- a/scripts/polynomial/polyreduce.m
+++ b/scripts/polynomial/polyreduce.m
@@ -24,46 +24,44 @@
 ## @seealso{poly, roots, conv, deconv, residue, filter, polyval,
 ## polyvalm, polyderiv, polyint}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
-function p = polyreduce (p)
+function p = polyreduce (c)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  if (! (isvector (p) || isempty (p)))
-    error ("polyreduce: argument must be a vector");
+  if (!isvector (c) || isempty (c))
+    error ("polyreduce: C must be a non-empty vector");
   endif
 
-  if (! isempty (p))
+  if (! isempty (c))
 
-    index = find (p != 0);
+    index = find (c != 0);
 
     if (isempty (index))
       
       p = 0;
     
     else
 
-      p = p (index (1):length (p));
+      p = c(index (1):length (c));
 
     endif
 
   endif
 
 endfunction
 
 %!assert(all (all (polyreduce ([0, 0, 1, 2, 3]) == [1, 2, 3])));
 
 %!assert(all (all (polyreduce ([1, 2, 3, 0, 0]) == [1, 2, 3, 0, 0])));
 
 %!assert(all (all (polyreduce ([1, 0, 3]) == [1, 0, 3])));
 
-%!assert(isempty (polyreduce ([])));
-
 %!error polyreduce ([1, 2; 3, 4]);
 
diff --git a/scripts/set/ismember.m b/scripts/set/ismember.m
--- a/scripts/set/ismember.m
+++ b/scripts/set/ismember.m
@@ -13,49 +13,49 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{tf} =} ismember (@var{A}, @var{S}) 
-## @deftypefnx {Function File} {[@var{tf}, @var{S_idx}] =} ismember (@var{A}, @var{S}) 
-## @deftypefnx {Function File} {[@var{tf}, @var{S_idx}] =} ismember (@var{A}, @var{S}, "rows")
+## @deftypefn  {Function File} {@var{tf} =} ismember (@var{A}, @var{s}) 
+## @deftypefnx {Function File} {[@var{tf}, @var{S_idx}] =} ismember (@var{A}, @var{s}) 
+## @deftypefnx {Function File} {[@var{tf}, @var{S_idx}] =} ismember (@var{A}, @var{s}, "rows")
 ## Return a logical matrix @var{tf} with the same shape as @var{A} which is 
-## true (1) if @code{A(i,j)} is in @var{S} and false (0) if it is not.  If a
-## second output argument is requested, the index into @var{S} of each of the
+## true (1) if @code{A(i,j)} is in @var{s} and false (0) if it is not.  If a
+## second output argument is requested, the index into @var{s} of each of the
 ## matching elements is also returned. 
 ##
 ## @example
 ## @group
 ## a = [3, 10, 1];
 ## s = [0:9];
 ## [tf, s_idx] = ismember (a, s);
 ##      @result{} tf = [1, 0, 1]
 ##      @result{} s_idx = [4, 0, 2]
 ## @end group
 ## @end example
 ##
-## The inputs, @var{A} and @var{S}, may also be cell arrays.
+## The inputs, @var{A} and @var{s}, may also be cell arrays.
 ##
 ## @example
 ## @group
 ## a = @{'abc'@};
 ## s = @{'abc', 'def'@};
 ## [tf, s_idx] = ismember (a, s);
 ##      @result{} tf = [1, 0]
 ##      @result{} s_idx = [1, 0]
 ## @end group
 ## @end example
 ##
 ## With the optional third argument @code{"rows"}, and matrices 
-## @var{A} and @var{S} with the same number of columns, compare rows in
-## @var{A} with the rows in @var{S}.
+## @var{A} and @var{s} with the same number of columns, compare rows in
+## @var{A} with the rows in @var{s}.
 ##
 ## @example
 ## @group
 ## a = [1:3; 5:7; 4:6];
 ## s = [0:2; 1:3; 2:4; 3:5; 4:6];
 ## [tf, s_idx] = ismember(a, s, 'rows');
 ##      @result{} tf = logical ([1; 0; 1])
 ##      @result{} s_idx = [2; 0; 5];
@@ -66,58 +66,58 @@
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 ## Author: Sren Hauberg <hauberg@gmail.com>
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Adapted-by: jwe
 ## Reimplemented using lookup & unique: Jaroslav Hajek <highegg@gmail.com>
 
-function [tf, a_idx] = ismember (a, s, varargin) 
+function [tf, a_idx] = ismember (A, s, varargin) 
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
-  [a, s] = validargs ("ismember", a, s, varargin{:});
+  [A, s] = validargs ("ismember", A, s, varargin{:});
 
   if (nargin == 2)
     s = s(:);
     ## We do it this way, because we expect the array to be often sorted.
     if (issorted (s))
       is = [];
     else
       [s, is] = sort (s);
     endif
 
     ## sort out NaNs in table
     if (isreal (s) && ! isempty (s) && isnan (s(end)))
         s = s(1:end - sum (isnan (s)));
     endif
     
     if (nargout > 1)
-      a_idx = lookup (s, a, "m");
+      a_idx = lookup (s, A, "m");
       tf = logical (a_idx);
       if (! isempty (is))
         a_idx(tf) = is (a_idx(tf));
       endif
     else
-      tf = lookup (s, a, "b");
+      tf = lookup (s, A, "b");
     endif
 
   else
 
-    if (isempty (a) || isempty (s))
-      tf = false (rows (a), 1);
-      a_idx = zeros (rows (a), 1);
+    if (isempty (A) || isempty (s))
+      tf = false (rows (A), 1);
+      a_idx = zeros (rows (A), 1);
     else
 
       ## FIXME: lookup does not support "rows", so we just use unique.
-      [xx, ii, jj] = unique ([a; s], "rows", "last");
-      na = rows (a);
+      [xx, ii, jj] = unique ([A; s], "rows", "last");
+      na = rows (A);
       jj = ii(jj(1:na));
       tf = jj > na;
 
       if (nargout > 1)
         a_idx = max (0, jj - na);
       endif
 
     endif
diff --git a/scripts/signal/arch_fit.m b/scripts/signal/arch_fit.m
--- a/scripts/signal/arch_fit.m
+++ b/scripts/signal/arch_fit.m
@@ -46,72 +46,72 @@
 ## Optionally, one can specify the number of iterations @var{iter}, the
 ## updating factor @var{gamma}, and initial values @math{a0} and
 ## @math{b0} for the scoring algorithm.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Fit an ARCH regression model
 
-function [a, b] = arch_fit (y, X, p, ITER, gamma, a0, b0)
+function [a, b] = arch_fit (y, x, p, iter, gamma, a0, b0)
 
   if ((nargin < 3) || (nargin == 6) || (nargin > 7))
     print_usage ();
   endif
 
   if (! (isvector (y)))
     error ("arch_fit: y must be a vector");
   endif
 
   T   = length (y);
   y   = reshape (y, T, 1);
-  [rx, cx] = size (X);
+  [rx, cx] = size (x);
   if ((rx == 1) && (cx == 1))
-    X = autoreg_matrix (y, X);
+    x = autoreg_matrix (y, x);
   elseif (! (rx == T))
-    error ("arch_fit: either rows (X) == length (y), or X is a scalar");
+    error ("arch_fit: either rows (x) == length (y), or x is a scalar");
   endif
 
-  [T, k] = size (X);
+  [T, k] = size (x);
 
   if (nargin == 7)
     a   = a0;
     b   = b0;
-    e   = y - X * b;
+    e   = y - x * b;
   else
-    [b, v_b, e] = ols (y, X);
+    [b, v_b, e] = ols (y, x);
     a   = [v_b, (zeros (1, p))]';
     if (nargin < 5)
       gamma = 0.1;
       if (nargin < 4)
-        ITER = 50;
+        iter = 50;
       endif
     endif
   endif
 
   esq = e.^2;
   Z   = autoreg_matrix (esq, p);
 
-  for i = 1 : ITER;
+  for i = 1 : iter;
     h    = Z * a;
     tmp  = esq ./ h.^2 - 1 ./ h;
     s    = 1 ./ h(1:T-p);
     for j = 1 : p;
       s = s - a(j+1) * tmp(j+1:T-p+j);
     endfor
     r    = 1 ./ h(1:T-p);
     for j = 1:p;
       r = r + 2 * h(j+1:T-p+j).^2 .* esq(1:T-p);
     endfor
     r   = sqrt (r);
-    X_tilde = X(1:T-p, :) .* (r * ones (1,k));
+    X_tilde = x(1:T-p, :) .* (r * ones (1,k));
     e_tilde = e(1:T-p) .*s ./ r;
     delta_b = inv (X_tilde' * X_tilde) * X_tilde' * e_tilde;
     b   = b + gamma * delta_b;
-    e   = y - X * b;
+    e   = y - x * b;
     esq = e .^ 2;
     Z   = autoreg_matrix (esq, p);
     h   = Z * a;
     f   = esq ./ h - ones(T,1);
     Z_tilde = Z ./ (h * ones (1, p+1));
     delta_a = inv (Z_tilde' * Z_tilde) * Z_tilde' * f;
     a   = a + gamma * delta_a;
   endfor
diff --git a/scripts/signal/arch_rnd.m b/scripts/signal/arch_rnd.m
--- a/scripts/signal/arch_rnd.m
+++ b/scripts/signal/arch_rnd.m
@@ -36,26 +36,26 @@
 ## @smallexample
 ## h(t) = a(1) + a(2) * e(t-1)^2 + @dots{} + a(la) * e(t-la+1)^2
 ## @end smallexample
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Simulate an ARCH process
 
-function y = arch_rnd (a, b, T)
+function y = arch_rnd (a, b, t)
 
   if (nargin != 3)
     print_usage ();
   endif
 
   if (! ((min (size (a)) == 1) && (min (size (b)) == 1)))
     error ("arch_rnd: a and b must both be scalars or vectors");
   endif
-  if (! (isscalar (T) && (T > 0) && (rem (T, 1) == 0)))
+  if (! (isscalar (t) && (t > 0) && (rem (t, 1) == 0)))
     error ("arch_rnd: T must be a positive integer");
   endif
 
   if (! (a(1) > 0))
     error ("arch_rnd: a(1) must be positive");
   endif
   ## perhaps add a test for the roots of a(z) here ...
 
@@ -67,37 +67,37 @@ function y = arch_rnd (a, b, T)
   endif
 
   lb = length (b);
   b  = reshape (b, 1, lb);
   if (lb == 1)
     b  = [b, 0];
     lb = lb + 1;
   endif
-  M  = max([la, lb]);
+  m  = max([la, lb]);
 
-  e  = zeros (T, 1);
-  h  = zeros (T, 1);
-  y  = zeros (T, 1);
+  e  = zeros (t, 1);
+  h  = zeros (t, 1);
+  y  = zeros (t, 1);
 
   h(1) = a(1);
   e(1) = sqrt (h(1)) * randn;
   y(1) = b(1) + e(1);
 
-  for t = 2:M
+  for t = 2:m
     ta   = min ([t, la]);
     h(t) = a(1) + a(2:ta) * e(t-ta+1:t-1).^2;
     e(t) = sqrt (h(t)) * randn;
     tb   = min ([t, lb]);
     y(t) = b(1) + b(2:tb) * y(t-tb+1:t-1) + e(t);
   endfor
 
-  if (T > M)
-    for t = M+1:T
+  if (t > m)
+    for t = m+1:t
       h(t) = a(1) + a(2:la) * e(t-la+1:t-1).^2;
       e(t) = sqrt (h(t)) * randn;
       y(t) = b(1) + b(2:lb) * y(t-tb+1:t-1) + e(t);
     endfor
   endif
 
-  y = y(1:T);
+  y = y(1:t);
 
 endfunction
diff --git a/scripts/signal/arch_test.m b/scripts/signal/arch_test.m
--- a/scripts/signal/arch_test.m
+++ b/scripts/signal/arch_test.m
@@ -61,37 +61,37 @@
 ## minus the CDF of this distribution at LM) of the test.
 ##
 ## If no output argument is given, the @math{p}-value is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Test for conditional heteroscedascity
 
-function [pval, lm] = arch_test (y, X, p)
+function [pval, lm] = arch_test (y, x, p)
 
   if (nargin != 3)
     error ("arch_test: 3 input arguments required");
   endif
 
   if (! (isvector (y)))
     error ("arch_test: y must be a vector");
   endif
   T   = length (y);
   y   = reshape (y, T, 1);
-  [rx, cx] = size (X);
+  [rx, cx] = size (x);
   if ((rx == 1) && (cx == 1))
-    X = autoreg_matrix (y, X);
+    x = autoreg_matrix (y, x);
   elseif (! (rx == T))
     error ("arch_test: either rows(X) == length(y), or X is a scalar");
   endif
   if (! (isscalar(p) && (rem(p, 1) == 0) && (p > 0)))
     error ("arch_test: p must be a positive integer");
   endif
 
-  [b, v_b, e] = ols (y, X);
+  [b, v_b, e] = ols (y, x);
   Z    = autoreg_matrix (e.^2, p);
   f    = e.^2 / v_b - ones (T, 1);
   f    = Z' * f;
   lm   = f' * inv (Z'*Z) * f / 2;
   pval = 1 - chi2cdf (lm, p);
 
 endfunction
diff --git a/scripts/signal/diffpara.m b/scripts/signal/diffpara.m
--- a/scripts/signal/diffpara.m
+++ b/scripts/signal/diffpara.m
@@ -35,55 +35,55 @@
 ##
 ## Reference: P.J. Brockwell & R.A. Davis. @cite{Time Series:
 ## Theory and Methods}. Springer 1987.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Estimate the fractional differencing parameter
 
-function [d, D] = diffpara (X, a, b)
+function [d, dd] = diffpara (x, a, b)
 
   if ((nargin < 1) || (nargin > 3))
     print_usage ();
   else
-    if (isvector (X))
-      n = length (X);
+    if (isvector (x))
+      n = length (x);
       k = 1;
-      X = reshape (X, n, 1);
+      x = reshape (x, n, 1);
     else
-      [n, k] = size(X);
+      [n, k] = size(x);
     endif
     if (nargin == 1)
       a = 0.5 * sqrt (n);
       b = 1.5 * sqrt (n);
     elseif (nargin == 2)
       b = a;
       a = 1;
     endif
   endif
 
   if (! (isscalar (a) && isscalar (b)))
     error ("diffpara: a and b must be scalars");
   endif
 
-  D = zeros (b - a + 1, k);
+  dd = zeros (b - a + 1, k);
 
   for l = 1:k
 
     w = 2 * pi * (1 : n-1) / n;
 
     x = 2 * log (abs (1 - exp (-i*w)));
-    y = log (periodogram (X(2:n,l)));
+    y = log (periodogram (x(2:n,l)));
 
     x = center (x);
     y = center (y);
 
     for m = a:b
-      D(m-a+1) = - x(1:m) * y(1:m) / sumsq (x(1:m));
+      dd(m-a+1) = - x(1:m) * y(1:m) / sumsq (x(1:m));
     endfor
 
   endfor
 
-  d = mean (D);
+  d = mean (dd);
 
 endfunction
 
diff --git a/scripts/signal/fftconv.m b/scripts/signal/fftconv.m
--- a/scripts/signal/fftconv.m
+++ b/scripts/signal/fftconv.m
@@ -13,63 +13,64 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} fftconv (@var{a}, @var{b})
-## @deftypefnx {Function File} {} fftconv (@var{a}, @var{b}, @var{n})
+## @deftypefn  {Function File} {} fftconv (@var{x}, @var{y})
+## @deftypefnx {Function File} {} fftconv (@var{x}, @var{y}, @var{n})
 ## Convolve two vectors using the FFT for computation.
 ## 
-## @code{c = fftconv (@var{a}, @var{b})} returns a vector of length equal to
-## @code{length (@var{a}) + length (@var{b}) - 1}.
-## If @var{a} and @var{b} are the coefficient vectors of two polynomials, the
+## @code{c = fftconv (@var{x}, @var{y})} returns a vector of length equal to
+## @code{length (@var{x}) + length (@var{y}) - 1}.
+## If @var{x} and @var{y} are the coefficient vectors of two polynomials, the
 ## returned value is the coefficient vector of the product polynomial.
 ##
 ## The computation uses the FFT by calling the function @code{fftfilt}.  If
 ## the optional argument @var{n} is specified, an N-point FFT is used.
 ## @seealso{deconv, conv, conv2}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 3 September 1994
 ## Adapted-By: jwe
 
-function c = fftconv (a, b, N)
+function c = fftconv (x, y, n)
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
-  if (! (isvector (a) && isvector (b)))
+  if (! (isvector (x) && isvector (y)))
     error ("fftconv: both A and B must be vectors");
   endif
-  la = length (a);
-  lb = length (b);
+  la = length (x);
+  lb = length (y);
   if ((la == 1) || (lb == 1))
-    c = a * b;
+    c = x * y;
   else
     lc = la + lb - 1;
-    a(lc) = 0;
-    b(lc) = 0;
+    x(lc) = 0;
+    y(lc) = 0;
     if (nargin == 2)
-      c = fftfilt (a, b);
+      c = fftfilt (x, y);
     else
-      if (! isscalar (N))
+      if (! isscalar (n))
         error ("fftconv: N must be a scalar");
       endif
-      c = fftfilt (a, b, N);
+      c = fftfilt (x, y, n);
     endif
   endif
 
 endfunction
 
+
 %% FIXME: Borrow tests from conv.m.  May need a tolerance on the assert comparison
 %!test
 %!  x = ones(3,1);
 %!  y = ones(1,3);
 %!  b = 2;
 %!  c = 3;
 %!  assert (fftconv (x, x), [1; 2; 3; 2; 1], 5*eps);
 %!  assert (fftconv (y, y), [1, 2, 3, 2, 1], 5*eps);
diff --git a/scripts/signal/fftfilt.m b/scripts/signal/fftfilt.m
--- a/scripts/signal/fftfilt.m
+++ b/scripts/signal/fftfilt.m
@@ -28,17 +28,17 @@
 ##
 ## If @var{x} is a matrix, filter each column of the matrix.
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 3 September 1994
 ## Adapted-By: jwe
 
-function y = fftfilt (b, x, N)
+function y = fftfilt (b, x, n)
 
   ## If N is not specified explicitly, we do not use the overlap-add
   ## method at all because loops are really slow.  Otherwise, we only
   ## ensure that the number of points in the FFT is the smallest power
   ## of two larger than N and length(b).  This could result in length
   ## one blocks, but if the user knows better ...
 
   if (nargin < 2 || nargin > 3)
@@ -59,37 +59,37 @@ function y = fftfilt (b, x, N)
   endif
 
   l_b = r_b * c_b;
   b = reshape (b, l_b, 1);
 
   if (nargin == 2)
     ## Use FFT with the smallest power of 2 which is >= length (x) +
     ## length (b) - 1 as number of points ...
-    N = 2 ^ (ceil (log (r_x + l_b - 1) / log (2)));
-    B = fft (b, N);
-    y = ifft (fft (x, N) .* B(:,ones (1, c_x)));
+    n = 2 ^ (ceil (log (r_x + l_b - 1) / log (2)));
+    B = fft (b, n);
+    y = ifft (fft (x, n) .* B(:,ones (1, c_x)));
   else
     ## Use overlap-add method ...
-    if (! (isscalar (N)))
-      error ("fftfilt: N has to be a scalar");
+    if (! (isscalar (n)))
+      error ("fftfilt: n has to be a scalar");
     endif
-    N = 2 ^ (ceil (log (max ([N, l_b])) / log (2)));
-    L = N - l_b + 1;
-    B = fft (b, N);
+    n = 2 ^ (ceil (log (max ([n, l_b])) / log (2)));
+    L = n - l_b + 1;
+    B = fft (b, n);
     B = B(:,ones (c_x,1));
     R = ceil (r_x / L);
     y = zeros (r_x, c_x);
     for r = 1:R;
       lo = (r - 1) * L + 1;
       hi = min (r * L, r_x);
-      tmp = zeros (N, c_x);
+      tmp = zeros (n, c_x);
       tmp(1:(hi-lo+1),:) = x(lo:hi,:);
       tmp = ifft (fft (tmp) .* B);
-      hi  = min (lo+N-1, r_x);
+      hi  = min (lo+n-1, r_x);
       y(lo:hi,:) = y(lo:hi,:) + tmp(1:(hi-lo+1),:);
     endfor
   endif
 
   y = y(1:r_x,:);
   if (transpose)
     y = y.';
   endif
diff --git a/scripts/signal/fftshift.m b/scripts/signal/fftshift.m
--- a/scripts/signal/fftshift.m
+++ b/scripts/signal/fftshift.m
@@ -13,74 +13,74 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} fftshift (@var{v})
-## @deftypefnx {Function File} {} fftshift (@var{v}, @var{dim})
-## Perform a shift of the vector @var{v}, for use with the @code{fft}
+## @deftypefn  {Function File} {} fftshift (@var{x})
+## @deftypefnx {Function File} {} fftshift (@var{x}, @var{dim})
+## Perform a shift of the vector @var{x}, for use with the @code{fft}
 ## and @code{ifft} functions, in order the move the frequency 0 to the
 ## center of the vector or matrix.
 ##
-## If @var{v} is a vector of @math{N} elements corresponding to @math{N}
+## If @var{x} is a vector of @math{N} elements corresponding to @math{N}
 ## time samples spaced of @math{Dt} each, then @code{fftshift (fft
-## (@var{v}))} corresponds to frequencies
+## (@var{x}))} corresponds to frequencies
 ##
 ## @example
 ## f = ((1:N) - ceil(N/2)) / N / Dt
 ## @end example
 ##
-## If @var{v} is a matrix, the same holds for rows and columns.  If 
-## @var{v} is an array, then the same holds along each dimension.
+## If @var{x} is a matrix, the same holds for rows and columns.  If 
+## @var{x} is an array, then the same holds along each dimension.
 ##
 ## The optional @var{dim} argument can be used to limit the dimension
 ## along which the permutation occurs.
 ## @end deftypefn
 
 ## Author: Vincent Cautaerts <vincent@comf5.comm.eng.osaka-u.ac.jp>
 ## Created: July 1997
 ## Adapted-By: jwe
 
-function retval = fftshift (V, dim)
+function retval = fftshift (x, dim)
 
   retval = 0;
 
   if (nargin != 1 && nargin != 2)
     print_usage ();
   endif
 
   if (nargin == 2)
     if (!isscalar (dim))
       error ("fftshift: dimension must be an integer scalar");
     endif
-    nd = ndims (V);
-    sz = size (V);
+    nd = ndims (x);
+    sz = size (x);
     sz2 = ceil (sz(dim) / 2);
     idx = cell ();
     for i = 1:nd
       idx{i} = 1:sz(i);
     endfor
     idx{dim} = [sz2+1:sz(dim), 1:sz2];
-    retval = V (idx{:});
+    retval = x(idx{:});
   else
-    if (isvector (V))
-      x = length (V);
+    if (isvector (x))
+      x = length (x);
       xx = ceil (x/2);
-      retval = V([xx+1:x, 1:xx]);
-    elseif (ismatrix (V))
-      nd = ndims (V);
-      sz = size (V);
+      retval = x([xx+1:x, 1:xx]);
+    elseif (ismatrix (x))
+      nd = ndims (x);
+      sz = size (x);
       sz2 = ceil (sz ./ 2);
       idx = cell ();
       for i = 1:nd
         idx{i} = [sz2(i)+1:sz(i), 1:sz2(i)];
       endfor
-      retval = V (idx{:});
+      retval = x(idx{:});
     else
       error ("fftshift: expecting vector or matrix argument");
     endif
   endif
 
 endfunction
diff --git a/scripts/signal/filter2.m b/scripts/signal/filter2.m
--- a/scripts/signal/filter2.m
+++ b/scripts/signal/filter2.m
@@ -38,20 +38,21 @@
 ## reversed and @var{b} rotated 180 degrees.
 ## @seealso{conv2}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 ## 2001-02-08 
 ##    * initial release
 
-function Y = filter2 (B, X, shape)
+function y = filter2 (b, x, shape)
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
   if (nargin < 3)
     shape = "same";
   endif
 
-  [nr, nc] = size(B);
-  Y = conv2 (X, B(nr:-1:1, nc:-1:1), shape);
+  [nr, nc] = size(b);
+  y = conv2 (x, b(nr:-1:1, nc:-1:1), shape);
 endfunction
+
diff --git a/scripts/signal/ifftshift.m b/scripts/signal/ifftshift.m
--- a/scripts/signal/ifftshift.m
+++ b/scripts/signal/ifftshift.m
@@ -12,62 +12,62 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} ifftshift (@var{v})
-## @deftypefnx {Function File} {} ifftshift (@var{v}, @var{dim})
+## @deftypefn  {Function File} {} ifftshift (@var{x})
+## @deftypefnx {Function File} {} ifftshift (@var{x}, @var{dim})
 ## Undo the action of the @code{fftshift} function.  For even length 
-## @var{v}, @code{fftshift} is its own inverse, but odd lengths differ 
+## @var{x}, @code{fftshift} is its own inverse, but odd lengths differ 
 ## slightly.
 ## @end deftypefn
 
 ## Author: Vincent Cautaerts <vincent@comf5.comm.eng.osaka-u.ac.jp>
 ## Created: July 1997
 ## Adapted-By: jwe
 ## Modified-By: Paul Kienzle, converted from fftshift
 ## Modified-By: David Bateman, add NDArray capability and option dim arg
 
-function retval = ifftshift (V, dim)
+function retval = ifftshift (x, dim)
 
   retval = 0;
 
   if (nargin != 1 && nargin != 2)
     print_usage ();
   endif
 
   if (nargin == 2)
     if (! isscalar (dim))
       error ("ifftshift: dimension must be an integer scalar");
     endif
-    nd = ndims (V);
-    sz = size (V);
+    nd = ndims (x);
+    sz = size (x);
     sz2 = floor (sz(dim) / 2);
     idx = cell ();
     for i = 1:nd
       idx{i} = 1:sz(i);
     endfor
     idx{dim} = [sz2+1:sz(dim), 1:sz2];
-    retval = V (idx{:});
+    retval = x(idx{:});
   else
-    if (isvector (V))
-      x = length (V);
+    if (isvector (x))
+      x = length (x);
       xx = floor (x/2);
-      retval = V([xx+1:x, 1:xx]);
-    elseif (ismatrix (V))
-      nd = ndims (V);
-      sz = size (V);
+      retval = x([xx+1:x, 1:xx]);
+    elseif (ismatrix (x))
+      nd = ndims (x);
+      sz = size (x);
       sz2 = floor (sz ./ 2);
       idx = cell ();
       for i = 1:nd
         idx{i} = [sz2(i)+1:sz(i), 1:sz2(i)];
       endfor
-      retval = V (idx{:});
+      retval = x(idx{:});
     else
       error ("ifftshift: expecting vector or matrix argument");
     endif
   endif
 
 endfunction
diff --git a/scripts/signal/sinetone.m b/scripts/signal/sinetone.m
--- a/scripts/signal/sinetone.m
+++ b/scripts/signal/sinetone.m
@@ -24,44 +24,45 @@
 ## The arguments @var{freq} and @var{ampl} may be vectors of common size.
 ##
 ## Defaults are @var{rate} = 8000, @var{sec} = 1 and @var{ampl} = 64.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Compute a sine tone
 
-function retval = sinetone (f, r, s, a)
+function retval = sinetone (freq, rate, sec, ampl)
 
   if (nargin == 1)
-    r = 8000;
-    s = 1;
-    a = 64;
+    rate = 8000;
+    sec = 1;
+    ampl = 64;
   elseif (nargin == 2)
-    s = 1;
-    a = 64;
+    sec = 1;
+    ampl = 64;
   elseif (nargin == 3)
-    a = 64;
+    ampl = 64;
   elseif ((nargin < 1) || (nargin > 4))
     print_usage ();
   endif
 
-  [err, f, a] = common_size (f, a);
-  if (err || ! isvector (f))
+  [err, freq, ampl] = common_size (freq, ampl);
+  if (err || ! isvector (freq))
     error ("sinetone: freq and ampl must be vectors of common size");
   endif
 
-  if (! (isscalar (r) && isscalar (s)))
+  if (! (isscalar (rate) && isscalar (sec)))
     error ("sinetone: rate and sec must be scalars");
   endif
 
-  n = length (f);
-  ns = round (r * s);
+  n = length (freq);
+  ns = round (rate * sec);
 
   retval = zeros (ns, n);
 
   for k = 1:n
-    retval (:, k) = a(k) * sin (2 * pi * (1:ns) / r * f(k))';
+    retval (:, k) = ampl(k) * sin (2 * pi * (1:ns) / rate * freq(k))';
   endfor
 
 endfunction
 
+
 %!assert (size (sinetone (18e6, 150e6, 19550/150e6, 1)), [19550, 1]);
diff --git a/scripts/signal/spectral_xdf.m b/scripts/signal/spectral_xdf.m
--- a/scripts/signal/spectral_xdf.m
+++ b/scripts/signal/spectral_xdf.m
@@ -27,44 +27,37 @@
 ##
 ## If @var{win} is omitted, the triangle window is used.  If @var{b} is
 ## omitted, @code{1 / sqrt (length (@var{x}))} is used.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Spectral density estimation
 
-function retval = spectral_xdf (X, win, b)
+function retval = spectral_xdf (x, win, b)
 
-  xr = length (X);
+  xr = length (x);
 
-  if (columns (X) > 1)
-    X = X';
+  if (columns (x) > 1)
+    x = x';
   endif
 
   if (nargin < 3)
     b = 1 / ceil (sqrt (xr));
   endif
 
   if (nargin == 1)
     w = triangle_sw (xr, b);
   else
     win = str2func (cstrcat (win, "_sw"));
     w = feval (win, xr, b);
   endif
 
-  X = X - sum (X) / xr;
+  x = x - sum (x) / xr;
 
-  retval = (abs (fft (X)) / xr).^2;
+  retval = (abs (fft (x)) / xr).^2;
   retval = real (ifft (fft(retval) .* fft(w)));
 
   retval = [(zeros (xr, 1)), retval];
   retval(:, 1) = (0 : xr-1)' / xr;
 
 endfunction
 
-
-
-
-
-
-
-
diff --git a/scripts/signal/spencer.m b/scripts/signal/spencer.m
--- a/scripts/signal/spencer.m
+++ b/scripts/signal/spencer.m
@@ -14,51 +14,41 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} spencer (@var{x})
-## Return Spencer's 15 point moving average of every single column of
+## Return Spencer's 15 point moving average of each column of
 ## @var{x}.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Apply Spencer's 15-point MA filter
 
-function retval = spencer (X)
+function retval = spencer (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  [xr, xc] = size(X);
+  [xr, xc] = size(x);
 
   n = xr;
   c = xc;
 
-  if (isvector(X))
-   n = length(X);
+  if (isvector(x))
+   n = length(x);
    c = 1;
-   X = reshape(X, n, 1);
+   x = reshape(x, n, 1);
   endif
 
-  W = [-3, -6, -5, 3, 21, 46, 67, 74, 67, 46, 21, 3, -5, -6, -3] / 320;
+  w = [-3, -6, -5, 3, 21, 46, 67, 74, 67, 46, 21, 3, -5, -6, -3] / 320;
 
-  retval = fftfilt (W, X);
+  retval = fftfilt (w, x);
   retval = [zeros(7,c); retval(15:n,:); zeros(7,c);];
 
   retval = reshape(retval, xr, xc);
 
 endfunction
 
-
-
-
-
-
-
-
-
-
-
diff --git a/scripts/signal/stft.m b/scripts/signal/stft.m
--- a/scripts/signal/stft.m
+++ b/scripts/signal/stft.m
@@ -13,123 +13,123 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{y}, @var{c}] =} stft (@var{x}, @var{win_size}, @var{inc}, @var{num_coef}, @var{w_type})
+## @deftypefn {Function File} {[@var{y}, @var{c}] =} stft (@var{x}, @var{win_size}, @var{inc}, @var{num_coef}, @var{win_type})
 ## Compute the short-time Fourier transform of the vector @var{x} with
 ## @var{num_coef} coefficients by applying a window of @var{win_size} data
 ## points and an increment of @var{inc} points.
 ##
 ## Before computing the Fourier transform, one of the following windows
 ## is applied:
 ##
 ## @table @asis
 ## @item @nospell{hanning}
-## w_type = 1
+## win_type = 1
 ##
 ## @item @nospell{hamming}
-## w_type = 2
+## win_type = 2
 ##
 ## @item rectangle
-## w_type = 3
+## win_type = 3
 ## @end table
 ##
-## The window names can be passed as strings or by the @var{w_type} number.
+## The window names can be passed as strings or by the @var{win_type} number.
 ##
 ## If not all arguments are specified, the following defaults are used:
 ## @var{win_size} = 80, @var{inc} = 24, @var{num_coef} = 64, and
-## @var{w_type} = 1.
+## @var{win_type} = 1.
 ##
 ## @code{@var{y} = stft (@var{x}, @dots{})} returns the absolute values
 ## of the Fourier coefficients according to the @var{num_coef} positive
 ## frequencies.
 ##
 ## @code{[@var{y}, @var{c}] = stft (@code{x}, @dots{})} returns the
 ## entire STFT-matrix @var{y} and a 3-element vector @var{c} containing
 ## the window size, increment, and window type, which is needed by the
 ## synthesis function.
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Description: Short-Time Fourier Transform
 
-function [Y, c] = stft(X, win, inc, coef, w_type)
+function [y, c] = stft(x, win_size, inc, num_coef, win_type)
 
   ## Default values of unspecified arguments.
   if (nargin < 5)
-    w_type = 1;
+    win_type = 1;
     if (nargin < 4)
-      coef = 64;
+      num_coef = 64;
       if (nargin < 3)
         inc = 24;
         if (nargin < 2)
-          win = 80;
+          win_size = 80;
         endif
       endif
     endif
   elseif (nargin == 5)
-    if (ischar (w_type))
-      if (strcmp (w_type, "hanning"))
-        w_type = 1;
-      elseif (strcmp (w_type, "hamming"))
-        w_type = 2;
-      elseif (strcmp (w_type, "rectangle"))
-        w_type = 3;
+    if (ischar (win_type))
+      if (strcmp (win_type, "hanning"))
+        win_type = 1;
+      elseif (strcmp (win_type, "hamming"))
+        win_type = 2;
+      elseif (strcmp (win_type, "rectangle"))
+        win_type = 3;
       else
-        error ("stft: unknown window type `%s'", w_type);
+        error ("stft: unknown window type `%s'", win_type);
       endif
     endif
   else
     print_usage ();
   endif
 
   ## Check whether X is a vector.
-  [nr, nc] = size (X);
+  [nr, nc] = size (x);
   if (nc != 1)
     if (nr == 1)
-      X = X';
+      x = x';
       nr = nc;
     else
       error ("stft: X must be a vector");
     endif
   endif
 
-  num_coef = 2 * coef;
-  if (win > num_coef)
-    win = num_coef;
-    printf ("stft: window size adjusted to %f\n", win);
+  ncoef = 2 * num_coef;
+  if (win_size > ncoef)
+    win_size = ncoef;
+    printf ("stft: window size adjusted to %f\n", win_size);
   endif
-  num_win = fix ((nr - win) / inc);
+  num_win = fix ((nr - win_size) / inc);
 
   ## compute the window coefficients
-  if (w_type == 3)
+  if (win_type == 3)
     ## Rectangular window.
-    WIN_COEF = ones (win, 1);
-  elseif (w_type == 2)
+    win_coef = ones (win_size, 1);
+  elseif (win_type == 2)
     ## Hamming window.
-    WIN_COEF = hamming (win);
+    win_coef = hamming (win_size);
   else
     ## Hanning window.
-    WIN_COEF = hanning (win);
+    win_coef = hanning (win_size);
   endif
 
   ## Create a matrix Z whose columns contain the windowed time-slices.
-  Z = zeros (num_coef, num_win + 1);
+  z = zeros (ncoef, num_win + 1);
   start = 1;
   for i = 0:num_win
-    Z(1:win, i+1) = X(start:start+win-1) .* WIN_COEF;
+    z(1:win_size, i+1) = x(start:start+win_size-1) .* win_coef;
     start = start + inc;
   endfor
 
-  Y = fft (Z);
+  y = fft (z);
 
   if (nargout == 1)
-    Y = abs (Y(1:coef, :));
+    y = abs (y(1:num_coef, :));
   else
-    c = [win, inc, w_type];
+    c = [win_size, inc, win_type];
   endif
 
 endfunction
diff --git a/scripts/signal/synthesis.m b/scripts/signal/synthesis.m
--- a/scripts/signal/synthesis.m
+++ b/scripts/signal/synthesis.m
@@ -28,47 +28,46 @@
 ## @example
 ## [@var{y}, @var{c}] = stft (@var{x} , @dots{})
 ## @end example
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Description: Recover a signal from its short-term Fourier transform
 
-function X = synthesis (Y, c)
+function x = synthesis (y, c)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   [nr, nc] = size (c);
   if (nr * nc != 3)
     error ("synthesis: c must contain exactly 3 elements");
   endif
 
-  ## not necessary, enables better reading
-  win = c(1);
-  inc = c(2);
+  w_size = c(1);
+  inc    = c(2);
   w_type = c(3);
 
   if (w_type == 1)
-    H = hanning (win);
+    w_coeff = hanning (w_size);
   elseif (w_type == 2)
-    H = hamming (win);
+    w_coeff = hamming (w_size);
   elseif (w_type == 3)
-    H = ones (win, 1);
+    w_coeff = ones (w_size, 1);
   else
     error ("synthesis: window_type must be 1, 2, or 3");
   endif
 
-  Z = real (ifft (Y));
-  st = fix ((win-inc) / 2);
-  Z = Z(st:st+inc-1, :);
-  H = H(st:st+inc-1);
+  z = real (ifft (y));
+  st = fix ((w_size-inc) / 2);
+  z = z(st:st+inc-1, :);
+  w_coeff = w_coeff(st:st+inc-1);
 
-  nc = columns(Z);
+  nc = columns(z);
   for i = 1:nc
-    Z(:, i) = Z(:, i) ./ H;
+    z(:, i) = z(:, i) ./ w_coeff;
   endfor
 
-  X = reshape(Z, inc * nc, 1);
+  x = reshape(z, inc * nc, 1);
 
 endfunction
diff --git a/scripts/sparse/etreeplot.m b/scripts/sparse/etreeplot.m
--- a/scripts/sparse/etreeplot.m
+++ b/scripts/sparse/etreeplot.m
@@ -12,25 +12,25 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} etreeplot (@var{tree})
-## @deftypefnx {Function File} {} etreeplot (@var{tree}, @var{node_style}, @var{edge_style})
-## Plot the elimination tree of the matrix @var{s} or
-## @code{@var{s}+@var{s}'}  if @var{s} in non-symmetric.  The optional
-## parameters @var{line_style} and @var{edge_style} define the output
+## @deftypefn  {Function File} {} etreeplot (@var{A})
+## @deftypefnx {Function File} {} etreeplot (@var{A}, @var{node_style}, @var{edge_style})
+## Plot the elimination tree of the matrix @var{A} or
+## @code{@var{A}+@var{A}'} if @var{A} in not symmetric.  The optional
+## parameters @var{node_style} and @var{edge_style} define the output
 ## style.
 ## @seealso{treeplot, gplot}
 ## @end deftypefn
 
-function etreeplot (s, varargin)
+function etreeplot (A, varargin)
 
   if (nargin < 1)
     print_usage ();
   endif
 
-  treeplot (etree (s+s'), varargin{:});
+  treeplot (etree (A+A'), varargin{:});
 endfunction
diff --git a/scripts/sparse/spfun.m b/scripts/sparse/spfun.m
--- a/scripts/sparse/spfun.m
+++ b/scripts/sparse/spfun.m
@@ -13,37 +13,37 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{y} =} spfun (@var{f},@var{x})
-## Compute @code{f(@var{x})} for the non-zero values of @var{x}.
+## @deftypefn {Function File} {@var{y} =} spfun (@var{f},@var{S})
+## Compute @code{f(@var{S})} for the non-zero values of @var{S}.
 ## This results in a sparse matrix with the same structure as 
-## @var{x}.  The function @var{f} can be passed as a string, a
+## @var{S}.  The function @var{f} can be passed as a string, a
 ## function handle, or an inline function.
 ## @seealso{arrayfun, cellfun, structfun}
 ## @end deftypefn
 
-function t = spfun (f, s)
+function y = spfun (f, S)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  [i, j, v] = find (s);
-  [m, n] = size (s);
+  [i, j, v] = find (S);
+  [m, n] = size (S);
 
   if (isa (f, "function_handle") || isa (f, "inline function"))
-    t = sparse (i, j, f(v), m, n);
+    y = sparse (i, j, f(v), m, n);
   else
-    t = sparse(i, j, feval (f, v), m, n);
+    y = sparse(i, j, feval (f, v), m, n);
   endif
 
 endfunction
 
 %!assert(spfun('exp',[1,2;3,0]),sparse([exp(1),exp(2);exp(3),0]))
 %!assert(spfun('exp',sparse([1,2;3,0])),sparse([exp(1),exp(2);exp(3),0]))
 %!assert(spfun(@exp,[1,2;3,0]),sparse([exp(1),exp(2);exp(3),0]))
 %!assert(spfun(@exp,sparse([1,2;3,0])),sparse([exp(1),exp(2);exp(3),0]))
diff --git a/scripts/sparse/spones.m b/scripts/sparse/spones.m
--- a/scripts/sparse/spones.m
+++ b/scripts/sparse/spones.m
@@ -12,29 +12,29 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{y} =} spones (@var{x})
-## Replace the non-zero entries of @var{x} with ones.  This creates a
-## sparse matrix with the same structure as @var{x}.
+## @deftypefn {Function File} {@var{r} =} spones (@var{S})
+## Replace the non-zero entries of @var{S} with ones.  This creates a
+## sparse matrix with the same structure as @var{S}.
 ## @end deftypefn
 
-function s = spones (s)
+function r = spones (S)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  [i, j, v] = find (s);
-  [m, n] = size (s);
+  [i, j, v] = find (S);
+  [m, n] = size (S);
 
-  s = sparse (i, j, 1, m, n);
+  r = sparse (i, j, 1, m, n);
 
 endfunction
 
 %!assert(issparse(spones([1,2;3,0])))
 %!assert(spones([1,2;3,0]),sparse([1,1;1,0]))
 %!assert(spones(sparse([1,2;3,0])),sparse([1,1;1,0]))
diff --git a/scripts/sparse/spstats.m b/scripts/sparse/spstats.m
--- a/scripts/sparse/spstats.m
+++ b/scripts/sparse/spstats.m
@@ -12,27 +12,27 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {[@var{count}, @var{mean}, @var{var}] =} spstats (@var{s})
-## @deftypefnx {Function File} {[@var{count}, @var{mean}, @var{var}] =} spstats (@var{s}, @var{j})
-## Return the stats for the non-zero elements of the sparse matrix @var{s}.
+## @deftypefn  {Function File} {[@var{count}, @var{mean}, @var{var}] =} spstats (@var{S})
+## @deftypefnx {Function File} {[@var{count}, @var{mean}, @var{var}] =} spstats (@var{S}, @var{j})
+## Return the stats for the non-zero elements of the sparse matrix @var{S}.
 ## @var{count} is the number of non-zeros in each column, @var{mean}
 ## is the mean of the non-zeros in each column, and @var{var} is the  
 ## variance of the non-zeros in each column.
 ##
-## Called with two input arguments, if @var{s} is the data and @var{j}
+## Called with two input arguments, if @var{S} is the data and @var{j}
 ## is the bin number for the data, compute the stats for each bin.  In 
 ## this case, bins can contain data values of zero, whereas with 
-## @code{spstats (@var{s})} the zeros may disappear.
+## @code{spstats (@var{S})} the zeros may disappear.
 ## @end deftypefn
 
 function [count, mean, var] = spstats (S, j)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
@@ -52,13 +52,14 @@ function [count, mean, var] = spstats (S
   if (nargout > 2) 
     ## FIXME Variance with count = 0 or 1?
     diff = S - sparse (i, j, mean(j), n, m); 
     var = sum (diff .* diff) ./ (count - 1);
   endif
 
 endfunction
 
+
 %!test
 %! [n,m,v] = spstats([1 2 1 2 3 4],[2 2 1 1 1 1]);
 %! assert(n,sparse([4,2]));
 %! assert(m,sparse([10/4,3/2]),10*eps);
 %! assert(v,sparse([5/3,1/2]),10*eps);
diff --git a/scripts/sparse/treelayout.m b/scripts/sparse/treelayout.m
--- a/scripts/sparse/treelayout.m
+++ b/scripts/sparse/treelayout.m
@@ -12,19 +12,19 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} treelayout (@var{Tree})
-## @deftypefnx {Function File} {} treelayout (@var{Tree}, @var{permutation})
-## treelayout lays out a tree or a forest.  The first argument @var{Tree} is a
+## @deftypefn  {Function File} {} treelayout (@var{tree})
+## @deftypefnx {Function File} {} treelayout (@var{tree}, @var{permutation})
+## treelayout lays out a tree or a forest.  The first argument @var{tree} is a
 ## vector of
 ## predecessors, optional parameter @var{permutation} is an optional postorder
 ## permutation.
 ## The complexity of the algorithm is O(n) in
 ## terms of time and memory requirements.
 ## @seealso{etreeplot, gplot,treeplot}
 ## @end deftypefn
 
diff --git a/scripts/sparse/treeplot.m b/scripts/sparse/treeplot.m
--- a/scripts/sparse/treeplot.m
+++ b/scripts/sparse/treeplot.m
@@ -13,19 +13,19 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} treeplot (@var{tree})
-## @deftypefnx {Function File} {} treeplot (@var{tree}, @var{line_style}, @var{edge_style})
+## @deftypefnx {Function File} {} treeplot (@var{tree}, @var{node_style}, @var{edge_style})
 ## Produces a graph of tree or forest.  The first argument is vector of
-## predecessors, optional parameters @var{line_style} and @var{edge_style}
+## predecessors, optional parameters @var{node_style} and @var{edge_style}
 ## define the output style.  The complexity of the algorithm is O(n) in
 ## terms of is time and memory requirements.
 ## @seealso{etreeplot, gplot}
 ## @end deftypefn
 
 function treeplot (tree, node_s, edge_s)
 
   if (nargin < 1 || nargin > 3 || nargout > 0)
diff --git a/scripts/specfun/factor.m b/scripts/specfun/factor.m
--- a/scripts/specfun/factor.m
+++ b/scripts/specfun/factor.m
@@ -15,80 +15,81 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{p} =} factor (@var{q})
 ## @deftypefnx {Function File} {[@var{p}, @var{n}] =} factor (@var{q})
 ##
-## Return prime factorization of @var{q}.  That is, @code{prod (@var{p})
-## == @var{q}} and every element of @var{p} is a prime number.  If
-## @code{@var{q} == 1}, returns 1. 
+## Return prime factorization of @var{q}.  That is, 
+## @code{prod (@var{p}) == @var{q}} and every element of @var{p} is a prime
+## number.  If @code{@var{q} == 1}, return 1. 
 ##
 ## With two output arguments, return the unique primes @var{p} and
 ## their multiplicities.  That is, @code{prod (@var{p} .^ @var{n}) ==
 ## @var{q}}.
 ## @seealso{gcd, lcm}
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 
 ## 2002-01-28 Paul Kienzle
 ## * remove recursion; only check existing primes for multiplicity > 1
 ## * return multiplicity as suggested by Dirk Laurie
 ## * add error handling
 
-function [x, m] = factor (n)
+function [x, n] = factor (q)
 
   if (nargin < 1)
     print_usage ();
   endif
 
-  if (! isscalar (n) || n != fix (n))
-    error ("factor: n must be a scalar integer");
+  if (! isscalar (q) || q != fix (q))
+    error ("factor: q must be a scalar integer");
   endif
 
-  ## Special case of no primes less than sqrt(n).
-  if (n < 4)
-    x = n;
-    m = 1;
+  ## Special case of no primes less than sqrt(q).
+  if (q < 4)
+    x = q;
+    n = 1;
     return;
   endif 
 
   x = [];
-  ## There is at most one prime greater than sqrt(n), and if it exists,
+  ## There is at most one prime greater than sqrt(q), and if it exists,
   ## it has multiplicity 1, so no need to consider any factors greater
-  ## than sqrt(n) directly. [If there were two factors p1, p2 > sqrt(n),
-  ## then n >= p1*p2 > sqrt(n)*sqrt(n) == n. Contradiction.]
-  p = primes (sqrt (n));
-  while (n > 1)
-    ## Find prime factors in remaining n.
-    p = p (rem (n, p) == 0);
+  ## than sqrt(q) directly. [If there were two factors p1, p2 > sqrt(q),
+  ## then q >= p1*p2 > sqrt(q)*sqrt(q) == q. Contradiction.]
+  p = primes (sqrt (q));
+  while (q > 1)
+    ## Find prime factors in remaining q.
+    p = p (rem (q, p) == 0);
     if (isempty (p))
-      ## Can't be reduced further, so n must itself be a prime.
-      p = n;
+      ## Can't be reduced further, so q must itself be a prime.
+      p = q;
     endif
     x = [x, p];
-    ## Reduce n.
-    n = n / prod (p);
+    ## Reduce q.
+    q = q / prod (p);
   endwhile
   x = sort (x);
 
   ## Determine muliplicity.
   if (nargout > 1)
     idx = find ([0, x] != [x, 0]);
     x = x(idx(1:length(idx)-1));
-    m = diff (idx);
+    n = diff (idx);
   endif
 
 endfunction
 
-## test:
-##   assert(factor(1),1);
-##   for i=2:20
-##      p = factor(i);
-##      assert(prod(p),i);
-##      assert(all(isprime(p)));
-##      [p,n] = factor(i);
-##      assert(prod(p.^n),i);
-##      assert(all([0,p]!=[p,0]));
-##   end
+%!test
+%!  assert(factor(1),1);
+%!  for i=2:20
+%!     p = factor(i);
+%!     assert(prod(p),i);
+%!     assert(all(isprime(p)));
+%!     [p,n] = factor(i);
+%!     assert(prod(p.^n),i);
+%!     assert(all([0,p]!=[p,0]));
+%!  endfor
+
diff --git a/scripts/specfun/isprime.m b/scripts/specfun/isprime.m
--- a/scripts/specfun/isprime.m
+++ b/scripts/specfun/isprime.m
@@ -29,30 +29,30 @@
 ## @group
 ## isprime (1:6)
 ##     @result{} [0, 1, 1, 0, 1, 0]
 ## @end group
 ## @end example
 ## @seealso{primes, factor, gcd, lcm}
 ## @end deftypefn
 
-function t = isprime (n)
+function t = isprime (x)
 
   if (nargin == 1)
-    if (any ((n != floor (n) | n < 0)(:)))
+    if (any ((x != floor (x) | x < 0)(:)))
       error ("isprime: needs positive integers");
     endif
-    maxn = max (n(:));
+    maxn = max (x(:));
     ## generate prime table of suitable length.
     maxp = min (maxn, max (sqrt (maxn), 1e7)); # FIXME: threshold not optimized.
     pr = primes (maxp);
     ## quick search for table matches.
-    t = lookup (pr, n, "b");
+    t = lookup (pr, x, "b");
     ## take the rest.
-    m = n(n > maxp);
+    m = x(x > maxp);
     if (! isempty (m))
       ## there are still possible primes. filter them out by division.
       if (maxn <= intmax ("uint32"))
         m = uint32 (m);
       elseif (maxn <= intmax ("uint64"))
         m = uint64 (m);
       else
         warning ("isprime: too large integers being tested");
@@ -63,24 +63,25 @@ function t = isprime (n)
         if (length (m) < length (pr) / 10)
           break;
         endif
       endfor
       pr = pr(pr > p);
       mm = arrayfun (@(x) all (rem (x, pr)), m);
       m = m(mm);
       if (! isempty (m))
-        m = cast (sort (m), class (n));
-        t |= lookup (m, n, "b");
+        m = cast (sort (m), class (x));
+        t |= lookup (m, x, "b");
       endif
     endif
 
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!assert (isprime (4), logical (0));
 %!assert (isprime (3), logical (1));
 %!assert (isprime (magic (3)), logical ([0, 0, 0; 1, 1, 1; 0, 0, 1]));
 %!error isprime ()
 %!error isprime (1, 2)
diff --git a/scripts/specfun/primes.m b/scripts/specfun/primes.m
--- a/scripts/specfun/primes.m
+++ b/scripts/specfun/primes.m
@@ -19,76 +19,76 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} primes (@var{n})
 ##
 ## Return all primes up to @var{n}.  
 ##
 ## The algorithm used is the Sieve of Eratosthenes.
 ##
 ## Note that if you need a specific number of primes you can use the
-## fact the distance from one prime to the next is, on average,
+## fact that the distance from one prime to the next is, on average,
 ## proportional to the logarithm of the prime.  Integrating, one finds
 ## that there are about @math{k} primes less than
 ## @tex
 ## $k \log (5 k)$.
 ## @end tex
 ## @ifnottex
 ## k*log(5*k).
 ## @end ifnottex
 ## @seealso{list_primes, isprime}
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 ## Author: Francesco Potort
 ## Author: Dirk Laurie
 
-function x = primes (p)
+function x = primes (n)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  if (! isscalar (p))
+  if (! isscalar (n))
     error ("primes: n must be a scalar");
   endif
 
-  if (p > 100000)
+  if (n > 100000)
     ## Optimization: 1/6 less memory, and much faster (asymptotically)
     ## 100000 happens to be the cross-over point for Paul's machine;
     ## below this the more direct code below is faster.  At the limit
     ## of memory in Paul's machine, this saves .7 seconds out of 7 for
-    ## p = 3e6.  Hardly worthwhile, but Dirk reports better numbers.
-    lenm = floor ((p+1)/6);       # length of the 6n-1 sieve
-    lenp = floor ((p-1)/6);       # length of the 6n+1 sieve
+    ## n = 3e6.  Hardly worthwhile, but Dirk reports better numbers.
+    lenm = floor ((n+1)/6);       # length of the 6n-1 sieve
+    lenp = floor ((n-1)/6);       # length of the 6n+1 sieve
     sievem = true (1, lenm);      # assume every number of form 6n-1 is prime
     sievep = true (1, lenp);      # assume every number of form 6n+1 is prime
 
-    for i = 1:(sqrt(p)+1)/6       # check up to sqrt(p)
+    for i = 1:(sqrt(n)+1)/6       # check up to sqrt(n)
       if (sievem(i))              # if i is prime, eliminate multiples of i
         sievem(7*i-1:6*i-1:lenm) = false;
         sievep(5*i-1:6*i-1:lenp) = false;
       endif                       # if i is prime, eliminate multiples of i
       if (sievep(i))
         sievep(7*i+1:6*i+1:lenp) = false;
         sievem(5*i+1:6*i+1:lenm) = false;
       endif
     endfor
     x = sort([2, 3, 6*find(sievem)-1, 6*find(sievep)+1]);
-  elseif (p > 352)                # nothing magical about 352; must be >2
-    len = floor ((p-1)/2);        # length of the sieve
+  elseif (n > 352)                # nothing magical about 352; must be >2
+    len = floor ((n-1)/2);        # length of the sieve
     sieve = true (1, len);        # assume every odd number is prime
-    for i = 1:(sqrt(p)-1)/2       # check up to sqrt(p)
+    for i = 1:(sqrt(n)-1)/2       # check up to sqrt(n)
       if (sieve(i))               # if i is prime, eliminate multiples of i
         sieve(3*i+1:2*i+1:len) = false; # do it
       endif
     endfor
     x = [2, 1+2*find(sieve)];     # primes remaining after sieve
   else
     a = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, ...
          53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, ...
          109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, ...
          173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, ...
          233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, ...
          293, 307, 311, 313, 317, 331, 337, 347, 349];
-    x = a(a <= p);
+    x = a(a <= n);
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/cauchy_cdf.m b/scripts/statistics/distributions/cauchy_cdf.m
--- a/scripts/statistics/distributions/cauchy_cdf.m
+++ b/scripts/statistics/distributions/cauchy_cdf.m
@@ -13,21 +13,21 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} cauchy_cdf (@var{x}, @var{lambda}, @var{sigma})
+## @deftypefn {Function File} {} cauchy_cdf (@var{x}, @var{location}, @var{scale})
 ## For each element of @var{x}, compute the cumulative distribution
 ## function (CDF) at @var{x} of the Cauchy distribution with location
-## parameter @var{lambda} and scale parameter @var{sigma}.  Default
-## values are @var{lambda} = 0, @var{sigma} = 1. 
+## parameter @var{location} and scale parameter @var{scale}.  Default
+## values are @var{location} = 0, @var{scale} = 1. 
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of the Cauchy distribution
 
 function cdf = cauchy_cdf (x, location, scale)
 
   if (! (nargin == 1 || nargin == 3))
@@ -37,17 +37,17 @@ function cdf = cauchy_cdf (x, location, 
   if (nargin == 1)
     location = 0;
     scale = 1;
   endif
 
   if (!isscalar (location) || !isscalar (scale)) 
     [retval, x, location, scale] = common_size (x, location, scale);
     if (retval > 0)
-      error ("cauchy_cdf: x, lambda and sigma must be of common size or scalar");
+      error ("cauchy_cdf: x, location and scale must be of common size or scalar");
     endif
   endif
 
   sz = size (x);
   cdf = NaN (sz);
 
   k = find ((x > -Inf) & (x < Inf) & (location > -Inf) &
             (location < Inf) & (scale > 0) & (scale < Inf));
diff --git a/scripts/statistics/distributions/cauchy_inv.m b/scripts/statistics/distributions/cauchy_inv.m
--- a/scripts/statistics/distributions/cauchy_inv.m
+++ b/scripts/statistics/distributions/cauchy_inv.m
@@ -13,21 +13,21 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} cauchy_inv (@var{x}, @var{lambda}, @var{sigma})
+## @deftypefn {Function File} {} cauchy_inv (@var{x}, @var{location}, @var{scale})
 ## For each element of @var{x}, compute the quantile (the inverse of the
 ## CDF) at @var{x} of the Cauchy distribution with location parameter
-## @var{lambda} and scale parameter @var{sigma}.  Default values are
-## @var{lambda} = 0, @var{sigma} = 1. 
+## @var{location} and scale parameter @var{scale}.  Default values are
+## @var{location} = 0, @var{scale} = 1. 
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the Cauchy distribution
 
 function inv = cauchy_inv (x, location, scale)
 
   if (! (nargin == 1 || nargin == 3))
@@ -37,17 +37,17 @@ function inv = cauchy_inv (x, location, 
   if (nargin == 1)
     location = 0;
     scale = 1;
   endif
 
   if (!isscalar (location) || !isscalar (scale)) 
     [retval, x, location, scale] = common_size (x, location, scale);
     if (retval > 0)
-      error ("cauchy_inv: x, lambda and sigma must be of common size or scalar");
+      error ("cauchy_inv: x, location and scale must be of common size or scalar");
     endif
   endif
 
   sz = size (x);
   inv = NaN (sz);
 
   ok = ((location > -Inf) & (location < Inf) &
        (scale > 0) & (scale < Inf));
diff --git a/scripts/statistics/distributions/cauchy_pdf.m b/scripts/statistics/distributions/cauchy_pdf.m
--- a/scripts/statistics/distributions/cauchy_pdf.m
+++ b/scripts/statistics/distributions/cauchy_pdf.m
@@ -13,21 +13,21 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} cauchy_pdf (@var{x}, @var{lambda}, @var{sigma})
+## @deftypefn {Function File} {} cauchy_pdf (@var{x}, @var{location}, @var{scale})
 ## For each element of @var{x}, compute the probability density function
 ## (PDF) at @var{x} of the Cauchy distribution with location parameter
-## @var{lambda} and scale parameter @var{sigma} > 0.  Default values are
-## @var{lambda} = 0, @var{sigma} = 1. 
+## @var{location} and scale parameter @var{scale} > 0.  Default values are
+## @var{location} = 0, @var{scale} = 1. 
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the Cauchy distribution
 
 function pdf = cauchy_pdf (x, location, scale)
 
   if (! (nargin == 1 || nargin == 3))
@@ -37,17 +37,17 @@ function pdf = cauchy_pdf (x, location, 
   if (nargin == 1)
     location = 0;
     scale = 1;
   endif
 
   if (!isscalar (location) || !isscalar (scale)) 
     [retval, x, location, scale] = common_size (x, location, scale);
     if (retval > 0)
-      error ("cauchy_pdf: x, lambda and sigma must be of common size or scalar");
+      error ("cauchy_pdf: x, location and scale must be of common size or scalar");
     endif
   endif
 
   sz = size (x);
   pdf = NaN (sz);
 
   k = find ((x > -Inf) & (x < Inf) & (location > -Inf) &
             (location < Inf) & (scale > 0) & (scale < Inf));
diff --git a/scripts/statistics/distributions/cauchy_rnd.m b/scripts/statistics/distributions/cauchy_rnd.m
--- a/scripts/statistics/distributions/cauchy_rnd.m
+++ b/scripts/statistics/distributions/cauchy_rnd.m
@@ -13,79 +13,83 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} cauchy_rnd (@var{lambda}, @var{sigma}, @var{r}, @var{c})
-## @deftypefnx {Function File} {} cauchy_rnd (@var{lambda}, @var{sigma}, @var{sz})
+## @deftypefn  {Function File} {} cauchy_rnd (@var{location}, @var{scale}, @var{r}, @var{c})
+## @deftypefnx {Function File} {} cauchy_rnd (@var{location}, @var{scale}, @var{sz})
 ## Return an @var{r} by @var{c} or a @code{size (@var{sz})} matrix of 
-## random samples from the Cauchy distribution with parameters @var{lambda} 
-## and @var{sigma} which must both be scalar or of size @var{r} by @var{c}.
+## random samples from the Cauchy distribution with parameters @var{location} 
+## and @var{scale} which must both be scalar or of size @var{r} by @var{c}.
 ##
 ## If @var{r} and @var{c} are omitted, the size of the result matrix is
-## the common size of @var{lambda} and @var{sigma}.
+## the common size of @var{location} and @var{scale}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the Cauchy distribution
 
-function rnd = cauchy_rnd (l, scale, r, c)
+function rnd = cauchy_rnd (location, scale, r, c)
 
   if (nargin > 1)
-    if (!isscalar (l) || !isscalar (scale)) 
-      [retval, l, scale] = common_size (l, scale);
+    if (!isscalar (location) || !isscalar (scale)) 
+      [retval, location, scale] = common_size (location, scale);
       if (retval > 0)
-        error ("cauchy_rnd: lambda and sigma must be of common size or scalar");
+        error ("cauchy_rnd: location and scale must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("cauchy_rnd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("cauchy_rnd: c must be a positive integer");
     endif
     sz = [r, c];
 
-    if (any (size (l) != 1)
-        && (length (size (l)) != length (sz) || any (size (l) != sz)))
-      error ("cauchy_rnd: lambda and sigma must be scalar or of size [r, c]");
+    if (any (size (location) != 1)
+        && (length (size (location)) != length (sz)
+            || any (size (location) != sz)))
+      error ("cauchy_rnd: location and scale must be scalar or of size [r, c]");
     endif
   elseif (nargin == 3)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("cauchy_rnd: r must be a positive integer or vector");
     endif
 
-    if (any (size (l) != 1)
-        && (length (size (l)) != length (sz) || any (size (l) != sz)))
-      error ("cauchy_rnd: lambda and sigma must be scalar or of size sz");
+    if (any (size (location) != 1)
+        && (length (size (location)) != length (sz)
+        || any (size (location) != sz)))
+      error ("cauchy_rnd: location and scale must be scalar or of size sz");
     endif
   elseif (nargin == 2)
-    sz = size(l);
+    sz = size(location);
   else
     print_usage ();
   endif
 
-  if (isscalar (l) && isscalar (scale)) 
-    if (find (!(l > -Inf) | !(l < Inf) | !(scale > 0) | !(scale < Inf)))
+  if (isscalar (location) && isscalar (scale)) 
+    if (find (!(location > -Inf) | !(location < Inf)
+                | !(scale > 0) | !(scale < Inf)))
       rnd = NaN (sz);
     else
-      rnd = l - cot (pi * rand (sz)) .* scale;
+      rnd = location - cot (pi * rand (sz)) .* scale;
     endif
   else
     rnd = NaN (sz);
-    k = find ((l > -Inf) & (l < Inf) & (scale > 0) & (scale < Inf));
+    k = find ((location > -Inf) & (location < Inf) 
+              & (scale > 0) & (scale < Inf));
     if (any (k))
-      rnd(k) = l(k)(:) - cot (pi * rand (size (k))) .* scale(k)(:);
+      rnd(k) = location(k)(:) - cot (pi * rand (size (k))) .* scale(k)(:);
     endif
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/expcdf.m b/scripts/statistics/distributions/expcdf.m
--- a/scripts/statistics/distributions/expcdf.m
+++ b/scripts/statistics/distributions/expcdf.m
@@ -23,51 +23,51 @@
 ## mean @var{lambda}.
 ##
 ## The arguments can be of common size or scalar.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of the exponential distribution
 
-function cdf = expcdf (x, l)
+function cdf = expcdf (x, lambda)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  if (!isscalar (x) && !isscalar(l))
-    [retval, x, l] = common_size (x, l);
+  if (!isscalar (x) && !isscalar(lambda))
+    [retval, x, lambda] = common_size (x, lambda);
     if (retval > 0)
       error ("expcdf: x and lambda must be of common size or scalar");
     endif
   endif
 
   if (isscalar (x))
-    sz = size (l);
+    sz = size (lambda);
   else
     sz = size (x);
   endif
 
   cdf = zeros (sz);
 
-  k = find (isnan (x) | !(l > 0));
+  k = find (isnan (x) | !(lambda > 0));
   if (any (k))
     cdf(k) = NaN;
   endif
 
-  k = find ((x == Inf) & (l > 0));
+  k = find ((x == Inf) & (lambda > 0));
   if (any (k))
     cdf(k) = 1;
   endif
 
-  k = find ((x > 0) & (x < Inf) & (l > 0));
+  k = find ((x > 0) & (x < Inf) & (lambda > 0));
   if (any (k))
-    if isscalar (l)
-      cdf (k) = 1 - exp (- x(k) ./ l);
+    if isscalar (lambda)
+      cdf (k) = 1 - exp (- x(k) ./ lambda);
     elseif isscalar (x)
-      cdf (k) = 1 - exp (- x ./ l(k));
+      cdf (k) = 1 - exp (- x ./ lambda(k));
     else
-      cdf (k) = 1 - exp (- x(k) ./ l(k));
+      cdf (k) = 1 - exp (- x(k) ./ lambda(k));
     endif
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/expinv.m b/scripts/statistics/distributions/expinv.m
--- a/scripts/statistics/distributions/expinv.m
+++ b/scripts/statistics/distributions/expinv.m
@@ -21,52 +21,52 @@
 ## For each element of @var{x}, compute the quantile (the inverse of the
 ## CDF) at @var{x} of the exponential distribution with mean
 ## @var{lambda}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the exponential distribution
 
-function inv = expinv (x, l)
+function inv = expinv (x, lambda)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  if (!isscalar (x) && !isscalar(l))
-    [retval, x, l] = common_size (x, l);
+  if (!isscalar (x) && !isscalar(lambda))
+    [retval, x, lambda] = common_size (x, lambda);
     if (retval > 0)
       error ("expinv: x and lambda must be of common size or scalar");
     endif
   endif
 
   if (isscalar (x))
-    sz = size (l);
+    sz = size (lambda);
   else
     sz = size (x);
   endif
 
   inv = zeros (sz);
 
-  k = find (!(l > 0) | (x < 0) | (x > 1) | isnan (x));
+  k = find (!(lambda > 0) | (x < 0) | (x > 1) | isnan (x));
   if (any (k))
     inv(k) = NaN;
   endif
 
-  k = find ((x == 1) & (l > 0));
+  k = find ((x == 1) & (lambda > 0));
   if (any (k))
     inv(k) = Inf;
   endif
 
-  k = find ((x > 0) & (x < 1) & (l > 0));
+  k = find ((x > 0) & (x < 1) & (lambda > 0));
   if (any (k))
-    if isscalar (l)
-      inv(k) = - l .* log (1 - x(k));
+    if isscalar (lambda)
+      inv(k) = - lambda .* log (1 - x(k));
     elseif isscalar (x)
-      inv(k) = - l(k) .* log (1 - x);
+      inv(k) = - lambda(k) .* log (1 - x);
     else
-      inv(k) = - l(k) .* log (1 - x(k));
+      inv(k) = - lambda(k) .* log (1 - x(k));
     endif
   endif
 
 endfunction
 
diff --git a/scripts/statistics/distributions/exppdf.m b/scripts/statistics/distributions/exppdf.m
--- a/scripts/statistics/distributions/exppdf.m
+++ b/scripts/statistics/distributions/exppdf.m
@@ -20,45 +20,45 @@
 ## @deftypefn {Function File} {} exppdf (@var{x}, @var{lambda})
 ## For each element of @var{x}, compute the probability density function
 ## (PDF) of the exponential distribution with mean @var{lambda}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the exponential distribution
 
-function pdf = exppdf (x, l)
+function pdf = exppdf (x, lambda)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  if (!isscalar (x) && !isscalar(l))
-    [retval, x, l] = common_size (x, l);
+  if (!isscalar (x) && !isscalar(lambda))
+    [retval, x, lambda] = common_size (x, lambda);
     if (retval > 0)
       error ("exppdf: x and lambda must be of common size or scalar");
     endif
   endif
 
   if (isscalar (x))
-    sz = size (l);
+    sz = size (lambda);
   else
     sz = size (x);
   endif
   pdf = zeros (sz);
 
-  k = find (!(l > 0) | isnan (x));
+  k = find (!(lambda > 0) | isnan (x));
   if (any (k))
     pdf(k) = NaN;
   endif
 
-  k = find ((x > 0) & (x < Inf) & (l > 0));
+  k = find ((x > 0) & (x < Inf) & (lambda > 0));
   if (any (k))
-    if isscalar (l)
-      pdf(k) = exp (- x(k) ./ l) ./ l;
+    if isscalar (lambda)
+      pdf(k) = exp (- x(k) ./ lambda) ./ lambda;
     elseif isscalar (x)
-      pdf(k) = exp (- x ./ l(k)) ./ l(k);
+      pdf(k) = exp (- x ./ lambda(k)) ./ lambda(k);
     else
-      pdf(k) = exp (- x(k) ./ l(k)) ./ l(k);
+      pdf(k) = exp (- x(k) ./ lambda(k)) ./ lambda(k);
     endif
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/exprnd.m b/scripts/statistics/distributions/exprnd.m
--- a/scripts/statistics/distributions/exprnd.m
+++ b/scripts/statistics/distributions/exprnd.m
@@ -26,62 +26,62 @@
 ##
 ## If @var{r} and @var{c} are omitted, the size of the result matrix is
 ## the size of @var{lambda}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the exponential distribution
 
-function rnd = exprnd (l, r, c)
+function rnd = exprnd (lambda, r, c)
 
   if (nargin == 3)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("exprnd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("exprnd: c must be a positive integer");
     endif
     sz = [r, c];
 
-    if (any (size (l) != 1)
-        && (length (size (l)) != length (sz) || any (size (l) != sz)))
+    if (any (size (lambda) != 1)
+        && (length (size (lambda)) != length (sz) || any (size (lambda) != sz)))
       error ("exprnd: lambda must be scalar or of size [r, c]");
     endif
   elseif (nargin == 2)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("exprnd: r must be a positive integer or vector");
     endif
 
-    if (any (size (l) != 1)
-        && ((length (size (l)) != length (sz)) || any (size (l) != sz)))
+    if (any (size (lambda) != 1)
+        && ((length (size (lambda)) != length (sz)) || any (size (lambda) != sz)))
       error ("exprnd: lambda must be scalar or of size sz");
     endif
   elseif (nargin == 1)
-    sz = size (l);
+    sz = size (lambda);
   else
     print_usage ();
   endif
 
 
-  if (isscalar (l))
-    if ((l > 0) && (l < Inf))
-      rnd = rande(sz) * l;
+  if (isscalar (lambda))
+    if ((lambda > 0) && (lambda < Inf))
+      rnd = rande(sz) * lambda;
     else
       rnd = NaN (sz);
     endif
   else
     rnd = zeros (sz);
-    k = find (!(l > 0) | !(l < Inf));
+    k = find (!(lambda > 0) | !(lambda < Inf));
     if (any (k))
       rnd(k) = NaN;
     endif
-    k = find ((l > 0) & (l < Inf));
+    k = find ((lambda > 0) & (lambda < Inf));
     if (any (k))
-      rnd(k) = rande(size(k)) .* l(k);
+      rnd(k) = rande(size(k)) .* lambda(k);
     endif
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/poisscdf.m b/scripts/statistics/distributions/poisscdf.m
--- a/scripts/statistics/distributions/poisscdf.m
+++ b/scripts/statistics/distributions/poisscdf.m
@@ -21,43 +21,43 @@
 ## For each element of @var{x}, compute the cumulative distribution
 ## function (CDF) at @var{x} of the Poisson distribution with parameter
 ## lambda.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of the Poisson distribution
 
-function cdf = poisscdf (x, l)
+function cdf = poisscdf (x, lambda)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  if (!isscalar (l))
-    [retval, x, l] = common_size (x, l);
+  if (!isscalar (lambda))
+    [retval, x, lambda] = common_size (x, lambda);
     if (retval > 0)
       error ("poisscdf: x and lambda must be of common size or scalar");
     endif
   endif
 
   cdf = zeros (size (x));
 
-  k = find (isnan (x) | !(l > 0));
+  k = find (isnan (x) | !(lambda > 0));
   if (any (k))
     cdf(k) = NaN;
   endif
 
-  k = find ((x == Inf) & (l > 0));
+  k = find ((x == Inf) & (lambda > 0));
   if (any (k))
     cdf(k) = 1;
   endif
 
-  k = find ((x >= 0) & (x < Inf) & (l > 0));
+  k = find ((x >= 0) & (x < Inf) & (lambda > 0));
   if (any (k))
-    if (isscalar (l))
-      cdf(k) = 1 - gammainc (l, floor (x(k)) + 1);
+    if (isscalar (lambda))
+      cdf(k) = 1 - gammainc (lambda, floor (x(k)) + 1);
     else
-      cdf(k) = 1 - gammainc (l(k), floor (x(k)) + 1);
+      cdf(k) = 1 - gammainc (lambda(k), floor (x(k)) + 1);
     endif
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/poissinv.m b/scripts/statistics/distributions/poissinv.m
--- a/scripts/statistics/distributions/poissinv.m
+++ b/scripts/statistics/distributions/poissinv.m
@@ -21,56 +21,56 @@
 ## For each component of @var{x}, compute the quantile (the inverse of
 ## the CDF) at @var{x} of the Poisson distribution with parameter
 ## @var{lambda}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the Poisson distribution
 
-function inv = poissinv (x, l)
+function inv = poissinv (x, lambda)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  if (!isscalar (l))
-    [retval, x, l] = common_size (x, l);
+  if (!isscalar (lambda))
+    [retval, x, lambda] = common_size (x, lambda);
     if (retval > 0)
       error ("poissinv: x and lambda must be of common size or scalar");
     endif
   endif
 
   inv = zeros (size (x));
 
-  k = find ((x < 0) | (x > 1) | isnan (x) | !(l > 0));
+  k = find ((x < 0) | (x > 1) | isnan (x) | !(lambda > 0));
   if (any (k))
     inv(k) = NaN;
   endif
 
-  k = find ((x == 1) & (l > 0));
+  k = find ((x == 1) & (lambda > 0));
   if (any (k))
     inv(k) = Inf;
   endif
 
-  k = find ((x > 0) & (x < 1) & (l > 0));
+  k = find ((x > 0) & (x < 1) & (lambda > 0));
   if (any (k))
-    if (isscalar (l))
-      cdf = exp (-l) * ones (size (k));
+    if (isscalar (lambda))
+      cdf = exp (-lambda) * ones (size (k));
     else
-      cdf = exp (-l(k));
+      cdf = exp (-lambda(k));
     endif
     while (1)
       m = find (cdf < x(k));
       if (any (m))
         inv(k(m)) = inv(k(m)) + 1;
-        if (isscalar (l))
-          cdf(m) = cdf(m) + poisspdf (inv(k(m)), l);
+        if (isscalar (lambda))
+          cdf(m) = cdf(m) + poisspdf (inv(k(m)), lambda);
         else
-          cdf(m) = cdf(m) + poisspdf (inv(k(m)), l(k(m)));
+          cdf(m) = cdf(m) + poisspdf (inv(k(m)), lambda(k(m)));
         endif
       else
         break;
       endif
     endwhile
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/poisspdf.m b/scripts/statistics/distributions/poisspdf.m
--- a/scripts/statistics/distributions/poisspdf.m
+++ b/scripts/statistics/distributions/poisspdf.m
@@ -20,38 +20,38 @@
 ## @deftypefn {Function File} {} poisspdf (@var{x}, @var{lambda})
 ## For each element of @var{x}, compute the probability density function
 ## (PDF) at @var{x} of the poisson distribution with parameter @var{lambda}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the Poisson distribution
 
-function pdf = poisspdf (x, l)
+function pdf = poisspdf (x, lambda)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  if (!isscalar (l))
-    [retval, x, l] = common_size (x, l);
+  if (!isscalar (lambda))
+    [retval, x, lambda] = common_size (x, lambda);
     if (retval > 0)
       error ("poisspdf: x and lambda must be of common size or scalar");
     endif
   endif
 
   pdf = zeros (size (x));
 
-  k = find (!(l > 0) | isnan (x));
+  k = find (!(lambda > 0) | isnan (x));
   if (any (k))
     pdf(k) = NaN;
   endif
 
-  k = find ((x >= 0) & (x < Inf) & (x == round (x)) & (l > 0));
+  k = find ((x >= 0) & (x < Inf) & (x == round (x)) & (lambda > 0));
   if (any (k))
-    if (isscalar (l))
-      pdf(k) = exp (x(k) .* log (l) - l - gammaln (x(k) + 1));
+    if (isscalar (lambda))
+      pdf(k) = exp (x(k) .* log (lambda) - lambda - gammaln (x(k) + 1));
     else
-      pdf(k) = exp (x(k) .* log (l(k)) - l(k) - gammaln (x(k) + 1));
+      pdf(k) = exp (x(k) .* log (lambda(k)) - lambda(k) - gammaln (x(k) + 1));
     endif
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/poissrnd.m b/scripts/statistics/distributions/poissrnd.m
--- a/scripts/statistics/distributions/poissrnd.m
+++ b/scripts/statistics/distributions/poissrnd.m
@@ -24,66 +24,66 @@
 ##
 ## If @var{r} and @var{c} are omitted, the size of the result matrix is
 ## the size of @var{lambda}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the Poisson distribution
 
-function rnd = poissrnd (l, r, c)
+function rnd = poissrnd (lambda, r, c)
 
   if (nargin == 3)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("poissrnd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("poissrnd: c must be a positive integer");
     endif
     sz = [r, c];
 
-    if (any (size (l) != 1)
-        && ((length (size (l)) != length (sz)) || any (size (l) != sz)))
+    if (any (size (lambda) != 1)
+        && ((length (size (lambda)) != length (sz)) || any (size (lambda) != sz)))
       error ("poissrnd: lambda must be scalar or of size [r, c]");
     endif
   elseif (nargin == 2)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("poissrnd: r must be a positive integer or vector");
     endif
 
-    if (any (size (l) != 1)
-        && ((length (size (l)) != length (sz)) || any (size (l) != sz)))
+    if (any (size (lambda) != 1)
+        && ((length (size (lambda)) != length (sz)) || any (size (lambda) != sz)))
       error ("poissrnd: lambda must be scalar or of size sz");
     endif
   elseif (nargin == 1)
-    sz = size (l);
+    sz = size (lambda);
   else
     print_usage ();
   endif
 
-  if (isscalar (l))
+  if (isscalar (lambda))
 
-    if (!(l >= 0) || !(l < Inf))
+    if (!(lambda >= 0) || !(lambda < Inf))
       rnd = NaN (sz);
-    elseif (l > 0 && l < Inf)
-      rnd = randp(l, sz);
+    elseif (lambda > 0 && lambda < Inf)
+      rnd = randp(lambda, sz);
     else
       rnd = zeros (sz);
     endif
   else
     rnd = zeros (sz);
 
-    k = find (!(l >= 0) | !(l < Inf));
+    k = find (!(lambda >= 0) | !(lambda < Inf));
     if (any (k))
       rnd(k) = NaN;
     endif
 
-    k = find ((l > 0) & (l < Inf));
+    k = find ((lambda > 0) & (lambda < Inf));
     if (any (k))
-      rnd(k) = randp(l(k), size(k));
+      rnd(k) = randp(lambda(k), size(k));
     endif
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/chisquare_test_independence.m b/scripts/statistics/tests/chisquare_test_independence.m
--- a/scripts/statistics/tests/chisquare_test_independence.m
+++ b/scripts/statistics/tests/chisquare_test_independence.m
@@ -28,27 +28,27 @@
 ## test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Chi-square test for independence
 
-function [pval, chisq, df] = chisquare_test_independence (X)
+function [pval, chisq, df] = chisquare_test_independence (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  [r, s] = size (X);
+  [r, s] = size (x);
   df = (r - 1) * (s - 1);
-  n = sum (sum (X));
-  Y = sum (X')' * sum (X) / n;
-  X = (X - Y) .^2 ./ Y;
-  chisq = sum (sum (X));
+  n = sum (sum (x));
+  y = sum (x')' * sum (x) / n;
+  x = (x - y) .^2 ./ y;
+  chisq = sum (sum (x));
   pval  = 1 - chi2cdf (chisq, df);
 
   if (nargout == 0)
     printf("  pval: %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/cor_test.m b/scripts/statistics/tests/cor_test.m
--- a/scripts/statistics/tests/cor_test.m
+++ b/scripts/statistics/tests/cor_test.m
@@ -22,18 +22,18 @@
 ## Test whether two samples @var{x} and @var{y} come from uncorrelated
 ## populations.
 ##
 ## The optional argument string @var{alt} describes the alternative
 ## hypothesis, and can be @code{"!="} or @code{"<>"} (non-zero),
 ## @code{">"} (greater than 0), or @code{"<"} (less than 0).  The
 ## default is the two-sided case.
 ##
-## The optional argument string @var{method} specifies on which
-## correlation coefficient the test should be based.  If @var{method} is
+## The optional argument string @var{method} specifies which
+## correlation coefficient to use for testing.  If @var{method} is
 ## @code{"pearson"} (default), the (usual) Pearson's product moment
 ## correlation coefficient is used.  In this case, the data should come
 ## from a bivariate normal distribution.  Otherwise, the other two
 ## methods offer nonparametric alternatives.  If @var{method} is
 ## @code{"kendall"}, then Kendall's rank correlation tau is used.  If
 ## @var{method} is @code{"spearman"}, then Spearman's rank correlation
 ## rho is used.  Only the first character is necessary.
 ##
@@ -61,76 +61,76 @@
 ##
 ## If no output argument is given, the p-value is displayed.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Adapted-by: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Test for zero correlation
 
-function t = cor_test (X, Y, ALTERNATIVE, METHOD)
+function t = cor_test (x, y, alt, method)
 
   if ((nargin < 2) || (nargin > 4))
     print_usage ();
   endif
 
-  if (!isvector (X) || !isvector (Y) || length (X) != length (Y))
+  if (!isvector (x) || !isvector (y) || length (x) != length (y))
     error ("cor_test: X and Y must be vectors of the same length");
   endif
 
   if (nargin < 3)
-    ALTERNATIVE = "!=";
-  elseif (! ischar (ALTERNATIVE))
-    error ("cor_test: ALTERNATIVE must be a string");
+    alt = "!=";
+  elseif (! ischar (alt))
+    error ("cor_test: alt must be a string");
   endif
 
   if (nargin < 4)
-    METHOD = "pearson";
-  elseif (! ischar (METHOD))
+    method = "pearson";
+  elseif (! ischar (method))
     error ("cor_test: METHOD must be a string");
   endif
 
-  n = length (X);
-  m = METHOD (1);
+  n = length (x);
+  m = method (1);
 
   if (m == "p")
-    r = cor (X, Y);
+    r = cor (x, y);
     df = n - 2;
     t.method = "Pearson's product moment correlation";
     t.params = df;
     t.stat = sqrt (df) .* r / sqrt (1 - r.^2);
     t.dist = "t";
     cdf  = tcdf (t.stat, df);
   elseif (m == "k")
-    tau = kendall (X, Y);
+    tau = kendall (x, y);
     t.method = "Kendall's rank correlation tau";
     t.params = [];
     t.stat = tau / sqrt ((2 * (2*n+5)) / (9*n*(n-1)));
     t.dist = "stdnormal";
     cdf = stdnormal_cdf (t.stat);
   elseif (m == "s")
-    rho = spearman (X, Y);
+    rho = spearman (x, y);
     t.method = "Spearman's rank correlation rho";
     t.params = [];
     t.stat = sqrt (n-1) * (rho - 6/(n^3-n));
     t.dist = "stdnormal";
     cdf = stdnormal_cdf (t.stat);
   else
-    error ("cor_test: method `%s' not recognized", METHOD);
+    error ("cor_test: method `%s' not recognized", method);
   endif
 
-  if (strcmp (ALTERNATIVE, "!=") || strcmp (ALTERNATIVE, "<>"))
+  if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     t.pval = 2 * min (cdf, 1 - cdf);
-  elseif (strcmp (ALTERNATIVE, ">"))
+  elseif (strcmp (alt, ">"))
     t.pval = 1 - cdf;
-  elseif (strcmp (ALTERNATIVE, "<"))
+  elseif (strcmp (alt, "<"))
     t.pval = cdf;
   else
-    error ("cor_test: alternative `%s' not recognized", ALTERNATIVE);
+    error ("cor_test: alternative `%s' not recognized", alt);
   endif
 
-  t.alternative = ALTERNATIVE;
+  t.alternative = alt;
 
   if (nargout == 0)
     printf ("pval: %g\n", t.pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/f_test_regression.m b/scripts/statistics/tests/f_test_regression.m
--- a/scripts/statistics/tests/f_test_regression.m
+++ b/scripts/statistics/tests/f_test_regression.m
@@ -31,48 +31,48 @@
 ## If not given explicitly, @var{r} = 0.
 ##
 ## If no output argument is given, the p-value is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Test linear hypotheses in linear regression model
 
-function [pval, f, df_num, df_den] = f_test_regression (y, X, R, r)
+function [pval, f, df_num, df_den] = f_test_regression (y, x, rr, r)
 
   if (nargin < 3 || nargin > 4)
     print_usage ();
   endif
 
-  [T, k] = size (X);
+  [T, k] = size (x);
   if (! (isvector (y) && (length (y) == T)))
     error ("f_test_regression: y must be a vector of length rows (X)");
   endif
   y = reshape (y, T, 1);
 
-  [q, c_R ] = size (R);
+  [q, c_R ] = size (rr);
   if (c_R != k)
-    error ("f_test_regression: R must have as many columns as X");
+    error ("f_test_regression: rr must have as many columns as x");
   endif
 
   if (nargin == 4)
     s_r = size (r);
     if ((min (s_r) != 1) || (max (s_r) != q))
-      error ("f_test_regression: r must be a vector of length rows (R)");
+      error ("f_test_regression: r must be a vector of length rows (rr)");
     endif
     r = reshape (r, q, 1);
   else
     r = zeros (q, 1);
   endif
 
   df_num = q;
   df_den = T - k;
 
-  [b, v] = ols (y, X);
-  diff   = R * b - r;
-  f      = diff' * inv (R * inv (X' * X) * R') * diff / (q * v);
+  [b, v] = ols (y, x);
+  diff   = rr * b - r;
+  f      = diff' * inv (rr * inv (x' * x) * rr') * diff / (q * v);
   pval  = 1 - f_cdf (f, df_num, df_den);
 
   if (nargout == 0)
     printf ("  pval: %g\n", pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/manova.m b/scripts/statistics/tests/manova.m
--- a/scripts/statistics/tests/manova.m
+++ b/scripts/statistics/tests/manova.m
@@ -13,72 +13,72 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} manova (@var{y}, @var{g})
+## @deftypefn {Function File} {} manova (@var{x}, @var{g})
 ## Perform a one-way multivariate analysis of variance (MANOVA).  The
 ## goal is to test whether the p-dimensional population means of data
 ## taken from @var{k} different groups are all equal.  All data are
 ## assumed drawn independently from p-dimensional normal distributions
 ## with the same covariance matrix.
 ##
-## The data matrix is given by @var{y}.  As usual, rows are observations
+## The data matrix is given by @var{x}.  As usual, rows are observations
 ## and columns are variables.  The vector @var{g} specifies the
 ## corresponding group labels (e.g., numbers from 1 to @var{k}).
 ##
 ## The LR test statistic (Wilks' Lambda) and approximate p-values are
 ## computed and displayed.
 ## @end deftypefn
 
 ## Three test statistics (Wilks, Hotelling-Lawley, and Pillai-Bartlett)
 ## and corresponding approximate p-values are calculated and displayed.
 ## (Currently NOT because the f_cdf respectively betai code is too bad.)
 
 ## Author: TF <Thomas.Fuereder@ci.tuwien.ac.at>
 ## Adapted-By: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: One-way multivariate analysis of variance (MANOVA)
 
-function manova (Y, g)
+function manova (x, g)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  if (isvector (Y))
+  if (isvector (x))
     error ("manova: Y must not be a vector");
   endif
 
-  [n, p] = size (Y);
+  [n, p] = size (x);
 
   if (!isvector (g) || (length (g) != n))
     error ("manova: g must be a vector of length rows (Y)");
   endif
 
   s = sort (g);
   i = find (s (2:n) > s(1:(n-1)));
   k = length (i) + 1;
 
   if (k == 1)
     error ("manova: there should be at least 2 groups");
   else
     group_label = s ([1, (reshape (i, 1, k - 1) + 1)]);
   endif
 
-  Y = Y - ones (n, 1) * mean (Y);
-  SST = Y' * Y;
+  x = x - ones (n, 1) * mean (x);
+  SST = x' * x;
 
   s = zeros (1, p);
   SSB = zeros (p, p);
   for i = 1 : k;
-    v = Y (find (g == group_label (i)), :);
+    v = x (find (g == group_label (i)), :);
     s = sum (v);
     SSB = SSB + s' * s / rows (v);
   endfor
   n_b = k - 1;
 
   SSW = SST - SSB;
   n_w = n - k;
 
diff --git a/scripts/statistics/tests/t_test_regression.m b/scripts/statistics/tests/t_test_regression.m
--- a/scripts/statistics/tests/t_test_regression.m
+++ b/scripts/statistics/tests/t_test_regression.m
@@ -37,17 +37,17 @@
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Test one linear hypothesis in linear regression model
 
-function [pval, t, df] = t_test_regression (y, X, R, r, alt)
+function [pval, t, df] = t_test_regression (y, x, rr, r, alt)
 
   if (nargin == 3)
     r   = 0;
     alt = "!=";
   elseif (nargin == 4)
     if (ischar (r))
       alt = r;
       r   = 0;
@@ -59,30 +59,30 @@ function [pval, t, df] = t_test_regressi
   endif
 
   if (! isscalar (r))
     error ("t_test_regression: r must be a scalar");
   elseif (! ischar (alt))
     error ("t_test_regression: alt must be a string");
   endif
 
-  [T, k] = size (X);
+  [T, k] = size (x);
   if (! (isvector (y) && (length (y) == T)))
     error ("t_test_regression: y must be a vector of length rows (X)");
   endif
-  s      = size (R);
+  s      = size (rr);
   if (! ((max (s) == k) && (min (s) == 1)))
-    error ("t_test_regression: R must be a vector of length columns (X)");
+    error ("t_test_regression: rr must be a vector of length columns (X)");
   endif
 
-  R      = reshape (R, 1, k);
+  rr     = reshape (rr, 1, k);
   y      = reshape (y, T, 1);
-  [b, v] = ols (y, X);
+  [b, v] = ols (y, x);
   df     = T - k;
-  t      = (R * b - r) / sqrt (v * R * inv (X' * X) * R');
+  t      = (rr * b - r) / sqrt (v * rr * inv (x' * x) * rr');
   cdf    = tcdf (t, df);
 
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif strcmp (alt, ">")
     pval = 1 - cdf;
   elseif strcmp (alt, "<")
     pval = cdf;
diff --git a/scripts/strings/base2dec.m b/scripts/strings/base2dec.m
--- a/scripts/strings/base2dec.m
+++ b/scripts/strings/base2dec.m
@@ -12,33 +12,33 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} base2dec (@var{s}, @var{b})
-## Convert @var{s} from a string of digits in base @var{b} to a decimal
+## @deftypefn {Function File} {} base2dec (@var{s}, @var{base})
+## Convert @var{s} from a string of digits in base @var{base} to a decimal
 ## integer (base 10).
 ##
 ## @example
 ## @group
 ## base2dec ("11120", 3)
 ##      @result{} 123
 ## @end group
 ## @end example
 ##
 ## If @var{s} is a matrix, returns a column vector with one value per
 ## row of @var{s}.  If a row contains invalid symbols then the
 ## corresponding value will be NaN@.  Rows are right-justified before
 ## converting so that trailing spaces are ignored.
 ##
-## If @var{b} is a string, the characters of @var{b} are used as the
+## If @var{base} is a string, the characters of @var{base} are used as the
 ## symbols for the digits of @var{s}.  Space (' ') may not be used as a
 ## symbol.
 ##
 ## @example
 ## @group
 ## base2dec ("yyyzx", "xyz")
 ##      @result{} 123
 ## @end group
diff --git a/scripts/strings/dec2base.m b/scripts/strings/dec2base.m
--- a/scripts/strings/dec2base.m
+++ b/scripts/strings/dec2base.m
@@ -12,32 +12,32 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} dec2base (@var{d}, @var{b})
-## @deftypefnx {Function File} {} dec2base (@var{d}, @var{b}, @var{len})
-## Return a string of symbols in base @var{b} corresponding to
+## @deftypefn  {Function File} {} dec2base (@var{d}, @var{base})
+## @deftypefnx {Function File} {} dec2base (@var{d}, @var{base}, @var{len})
+## Return a string of symbols in base @var{base} corresponding to
 ## the non-negative integer @var{d}.
 ##
 ## @example
 ## @group
 ## dec2base (123, 3)
 ##      @result{} "11120"
 ## @end group
 ## @end example
 ##
 ## If @var{d} is a vector, return a string matrix with one row per value,
 ## padded with leading zeros to the width of the largest value.
 ##
-## If @var{b} is a string then the characters of @var{b} are used as
+## If @var{base} is a string then the characters of @var{base} are used as
 ## the symbols for the digits of @var{d}.  Space (' ') may not be used
 ## as a symbol.
 ##
 ## @example
 ## @group
 ## dec2base (123, "aei")
 ##      @result{} "eeeia"
 ## @end group
diff --git a/scripts/strings/regexptranslate.m b/scripts/strings/regexptranslate.m
--- a/scripts/strings/regexptranslate.m
+++ b/scripts/strings/regexptranslate.m
@@ -46,30 +46,30 @@
 ##      @result{} "12\.5"
 ## @end group
 ## @end example
 ##
 ## @end table
 ## @seealso{regexp, regexpi, regexprep}
 ## @end deftypefn
 
-function y = regexptranslate (op, x)
+function y = regexptranslate (op, s)
   
   if nargin != 2
     print_usage ();
   endif 
   
   if (ischar (op))
     op = tolower (op);
     if (strcmp ("wildcard", op))
-      y = regexprep (regexprep (regexprep (x, "\\.", "\\."), "\\*",
+      y = regexprep (regexprep (regexprep (s, "\\.", "\\."), "\\*",
                                 ".*"), "\\?", ".");
     elseif (strcmp ("escape", op))
       ch = {'\$', '\.', '\?', '\[', '\]'};
-      y = x;
+      y = s;
       for i = 1 : length (ch)
         y = regexprep (y, ch{i}, ch{i});
       endfor
     else
       error ("regexptranslate: unexpected operation");
     endif
   else
     error ("regexptranslate: expecting operation to be a string");
diff --git a/scripts/strings/strjust.m b/scripts/strings/strjust.m
--- a/scripts/strings/strjust.m
+++ b/scripts/strings/strjust.m
@@ -35,53 +35,53 @@
 ##           ab
 ##          abc
 ##         abcd
 ## @end group
 ## @end example
 ## @seealso{deblank, strrep, strtrim, untabify}
 ## @end deftypefn
 
-function y = strjust (x, just)
+function y = strjust (s, pos)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (nargin == 1)
-    just = "right";
+    pos = "right";
   else
-    just = tolower (just);
+    pos = tolower (pos);
   endif
 
-  if (ndims (x) != 2)
+  if (ndims (s) != 2)
     error ("strjust: input must be a string or character matrix");
   endif
 
-  if (isempty (x))
-    y = x;
+  if (isempty (s))
+    y = s;
   else
     ## Apparently, Matlab considers nulls to be blanks as well; however, does
     ## not preserve the nulls, but rather converts them to blanks.  That's a
     ## bit unexpected, but it allows simpler processing, because we can move
     ## just the nonblank characters. So we'll do the same here.
 
-    [nr, nc] = size (x);
+    [nr, nc] = size (s);
     ## Find the indices of all nonblanks.
-    nonbl = x != " " & x != "\0";
+    nonbl = s != " " & s != "\0";
     [idx, jdx] = find (nonbl);
 
-    if (strcmp (just, "right"))
+    if (strcmp (pos, "right"))
       ## We wish to find the maximum column index for each row. Because jdx is
       ## sorted, we can take advantage of the fact that assignment is processed
       ## sequentially and for duplicate indices the last value will remain.
       maxs = nc * ones (nr, 1);
       maxs(idx) = jdx;
       shift = nc - maxs;
-    elseif (strcmp (just, "left"))
+    elseif (strcmp (pos, "left"))
       ## See above for explanation.
       mins = ones (nr, 1);
       mins(flipud (idx(:))) = flipud (jdx(:));
       shift = 1 - mins;
     else
       ## Use both of the above.
       mins = ones (nr, 1);
       mins(flipud (idx(:))) = flipud (jdx(:));
@@ -90,17 +90,17 @@ function y = strjust (x, just)
       shift = floor ((nc + 1 - maxs - mins) / 2); 
     endif
 
     ## Adjust the column indices.
     jdx += shift (idx);
 
     ## Create a blank matrix and position the nonblank characters.
     y = " "(ones (1, nr), ones (1, nc));
-    y(sub2ind ([nr, nc], idx, jdx)) = x(nonbl);
+    y(sub2ind ([nr, nc], idx, jdx)) = s(nonbl);
   endif
 
 endfunction
 
 %!error <Invalid call to strjust> strjust();
 %!error <Invalid call to strjust> strjust(["a";"ab"], "center", 1);
 %!assert (strjust (["a"; "ab"; "abc"; "abcd"]),
 %!        ["   a";"  ab"; " abc"; "abcd"]);
diff --git a/scripts/strings/strmatch.m b/scripts/strings/strmatch.m
--- a/scripts/strings/strmatch.m
+++ b/scripts/strings/strmatch.m
@@ -14,21 +14,21 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} strmatch (@var{s}, @var{a}, "exact")
-## Return indices of entries of @var{a} that match the string @var{s}.
-## The second argument @var{a} may be a string matrix or a cell array of
+## @deftypefn {Function File} {} strmatch (@var{s}, @var{A}, "exact")
+## Return indices of entries of @var{A} that match the string @var{s}.
+## The second argument @var{A} may be a string matrix or a cell array of
 ## strings.  If the third argument @code{"exact"} is not given, then
-## @var{s} only needs to match @var{a} up to the length of @var{s}.
+## @var{s} only needs to match @var{A} up to the length of @var{s}.
 ## Trailing whitespace is ignored.
 ## Results are returned as a column vector. 
 ## For example:
 ##
 ## @example
 ## @group
 ## strmatch ("apple", "apple juice")
 ##      @result{} 1
diff --git a/scripts/strings/untabify.m b/scripts/strings/untabify.m
--- a/scripts/strings/untabify.m
+++ b/scripts/strings/untabify.m
@@ -45,25 +45,25 @@
 ## @end example
 ##
 ## @seealso{strjust, strsplit, deblank}
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2010-10-15
 
-function s = untabify (t, tw = 8, db = false)
+function s = untabify (t, tw = 8, dblank = false)
 
  if (nargin > 0 && nargin < 4 && (ischar (t) || iscellstr (t)))
    if (ischar (t))
      s = replace_tabs (t, tw);
    else
      s = cellfun (@(str) replace_tabs (str, tw), t, "uniformoutput", false);
    endif
-   if (db)
+   if (dblank)
      s = deblank (s);
    endif
  else
    print_usage ();
  endif
 
 endfunction
 
diff --git a/scripts/time/asctime.m b/scripts/time/asctime.m
--- a/scripts/time/asctime.m
+++ b/scripts/time/asctime.m
@@ -29,20 +29,20 @@
 ## @end group
 ## @end example
 ##
 ## This is equivalent to @code{ctime (time ())}.
 ## @end deftypefn
 
 ## Author: jwe
 
-function retval = asctime (t)
+function retval = asctime (tm_struct)
 
   if (nargin == 1)
-    retval = strftime ("%a %b %d %H:%M:%S %Y\n", t);
+    retval = strftime ("%a %b %d %H:%M:%S %Y\n", tm_struct);
   else
     print_usage ();
   endif
 
 endfunction
 
 %!test
 %! t = time ();
diff --git a/scripts/time/datenum.m b/scripts/time/datenum.m
--- a/scripts/time/datenum.m
+++ b/scripts/time/datenum.m
@@ -60,75 +60,75 @@
 ## @strong{Warning:} leap seconds are ignored.  A table of leap seconds
 ## is available on the Wikipedia entry for leap seconds.
 ## @seealso{date, clock, now, datestr, datevec, calendar, weekday}
 ## @end deftypefn
 
 ## Algorithm: Peter Baum (http://vsg.cape.com/~pbaum/date/date0.htm)
 ## Author: pkienzle <pkienzle@users.sf.net>
 
-function [days, secs] = datenum (Y, M, D, h, m, s)
+function [days, secs] = datenum (year, month, day, hour, minute, second)
 
   ## Days until start of month assuming year starts March 1.
   persistent monthstart = [306; 337; 0; 31; 61; 92; 122; 153; 184; 214; 245; 275];
 
-  if (nargin == 0 || (nargin > 2  && ischar (Y)) || nargin > 6)
+  if (nargin == 0 || (nargin > 2  && ischar (year)) || nargin > 6)
     print_usage ();
   endif
-  if (ischar (Y))
+  if (ischar (year))
     if (nargin < 2)
-      M = [];
+      month = [];
     endif
-    [Y, M, D, h, m, s] = datevec (Y, M);
+    [year, month, day, hour, minute, second] = datevec (year, month);
   else
-    if (nargin < 6) s = 0; endif
-    if (nargin < 5) m = 0; endif
-    if (nargin < 4) h = 0; endif
+    if (nargin < 6) second = 0; endif
+    if (nargin < 5) minute = 0; endif
+    if (nargin < 4) hour = 0; endif
     if (nargin == 1)
-      nc = columns (Y);
+      nc = columns (year);
       if (nc > 6 || nc < 3)
-        error ("datenum: expected date vector containing [Y, M, D, h, m, s]");
+        error ("datenum: expected date vector containing [year, month, day, hour, minute, second]");
       endif
-      s = m = h = 0;
-      if (nc >= 6) s = Y(:,6); endif
-      if (nc >= 5) m = Y(:,5); endif
-      if (nc >= 4) h = Y(:,4); endif
-      D = Y(:,3);
-      M = Y(:,2);
-      Y = Y(:,1);
+      second = minute = hour = 0;
+      if (nc >= 6) second = year(:,6); endif
+      if (nc >= 5) minute = year(:,5); endif
+      if (nc >= 4) hour = year(:,4); endif
+      day = year(:,3);
+      month = year(:,2);
+      year = year(:,1);
     endif 
   endif
 
-  M(M<1) = 1; ## For compatibility.  Otherwise allow negative months.
+  month(month<1) = 1; ## For compatibility.  Otherwise allow negative months.
 
   ## Set start of year to March by moving Jan. and Feb. to previous year.
   ## Correct for months > 12 by moving to subsequent years.
-  Y += fix ((M-14)/12);
+  year += fix ((month-14)/12);
 
   ## Lookup number of days since start of the current year.
-  if (numel (M) == 1 || numel (D) == 1)
-    ## Allow M or D to be scalar while other values may be vectors or
+  if (numel (month) == 1 || numel (day) == 1)
+    ## Allow month or day to be scalar while other values may be vectors or
     ## matrices.
-    D += monthstart (mod (M-1,12) + 1) + 60;
-    if (numel (M) > 1)
-      D = reshape (D, size (M));
+    day += monthstart (mod (month-1,12) + 1) + 60;
+    if (numel (month) > 1)
+      day = reshape (day, size (month));
     endif
   else
-    D += reshape (monthstart (mod (M-1,12) + 1), size (D)) + 60;
+    day += reshape (monthstart (mod (month-1,12) + 1), size (day)) + 60;
   endif
 
   ## Add number of days to the start of the current year. Correct
   ## for leap year every 4 years except centuries not divisible by 400.
-  D += 365*Y + floor (Y/4) - floor (Y/100) + floor (Y/400);
+  day += 365*year + floor (year/4) - floor (year/100) + floor (year/400);
 
   ## Add fraction representing current second of the day.
-  days = D + (h+(m+s/60)/60)/24;
+  days = day + (hour+(minute+second/60)/60)/24;
 
   ## Output seconds if asked so that etime can be more accurate
-  secs = 86400*D + h*3600 + m*60 + s;
+  secs = 86400*day + hour*3600 + minute*60 + second;
 
 endfunction
 
 %!shared part
 %! part = 0.514623842592593;
 %!assert(datenum(2001,5,19), 730990)
 %!assert(datenum([1417,6,12]), 517712)
 %!assert(datenum([2001,5,19;1417,6,12]), [730990;517712])
diff --git a/scripts/time/datestr.m b/scripts/time/datestr.m
--- a/scripts/time/datestr.m
+++ b/scripts/time/datestr.m
@@ -13,17 +13,19 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{str} =} datestr (@var{date}, [@var{f}, [@var{p}]])
+## @deftypefn  {Function File} {@var{str} =} datestr (@var{date})
+## @deftypefnx {Function File} {@var{str} =} datestr (@var{date}, @var{f})
+## @deftypefnx {Function File} {@var{str} =} datestr (@var{date}, @var{f}, @var{p})
 ## Format the given date/time according to the format @code{f} and return
 ## the result in @var{str}.  @var{date} is a serial date number (see
 ## @code{datenum}) or a date vector (see @code{datevec}).  The value of
 ## @var{date} may also be a string or cell array of strings.
 ##
 ## @var{f} can be an integer which corresponds to one of the codes in
 ## the table below, or a date format string.
 ##
diff --git a/scripts/time/etime.m b/scripts/time/etime.m
--- a/scripts/time/etime.m
+++ b/scripts/time/etime.m
@@ -12,19 +12,19 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} etime (@var{t1}, @var{t2})
-## Return the difference (in seconds) between two time values returned from
-## @code{clock}.  For example:
+## @deftypefn {Function File} {} etime (@var{t2}, @var{t1})
+## Return the difference in seconds between two time values returned from
+## @code{clock} (@math{@var{t2} - @var{t1}}).  For example:
 ##
 ## @example
 ## @group
 ## t0 = clock ();
 ## # many computations later@dots{}
 ## elapsed_time = etime (clock (), t0);
 ## @end group
 ## @end example
@@ -32,26 +32,26 @@
 ## @noindent
 ## will set the variable @code{elapsed_time} to the number of seconds since
 ## the variable @code{t0} was set.
 ## @seealso{tic, toc, clock, cputime}
 ## @end deftypefn
 
 ## Author: jwe
 
-function secs = etime (t1, t0)
+function secs = etime (t2, t1)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  [d1, s1] = datenum (t1);
-  [d0, s0] = datenum (t0);
+  [~, s2] = datenum (t2);
+  [~, s1] = datenum (t1);
 
-  secs = s1 - s0;
+  secs = s2 - s1;
 
 endfunction
 
 %!assert(etime([1900,12,31,23,59,59],[1901,1,1,0,0,0]),-1)
 %!assert(etime([1900,2,28,23,59,59],[1900,3,1,0,0,0]),-1)
 %!assert(etime([2000,2,28,23,59,59],[2000,3,1,0,0,0]),-86401)
 %!assert(etime([1996,2,28,23,59,59],[1996,3,1,0,0,0]),-86401)
 %!test
diff --git a/scripts/time/weekday.m b/scripts/time/weekday.m
--- a/scripts/time/weekday.m
+++ b/scripts/time/weekday.m
@@ -12,41 +12,42 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{n}, @var{s}] =} weekday (@var{d}, [@var{form}])
+## @deftypefn  {Function File} {[@var{n}, @var{s}] =} weekday (@var{d})
+## @deftypefnx {Function File} {[@var{n}, @var{s}] =} weekday (@var{d}, @var{format})
 ## Return the day of week as a number in @var{n} and a string in @var{s},
 ## for example @code{[1, "Sun"]}, @code{[2, "Mon"]}, @dots{}, or
 ## @code{[7, "Sat"]}.
 ##
 ## @var{d} is a serial date number or a date string.
 ##
-## If the string @var{form} is given and is @code{"long"}, @var{s} will
-## contain the full name of the weekday; otherwise (or if @var{form} is
+## If the string @var{format} is given and is @code{"long"}, @var{s} will
+## contain the full name of the weekday; otherwise (or if @var{format} is
 ## @code{"short"}), @var{s} will contain the abbreviated name of the weekday.
 ## @seealso{datenum, datevec, eomday}
 ## @end deftypefn
 
 ## Author: pkienzle <pkienzle@users.sf.net>
 ## Created: 10 October 2001 (CVS)
 ## Adapted-By: William Poetra Yoga Hadisoeseno <williampoetra@gmail.com>
 
-function [d, s] = weekday (d, form)
+function [d, s] = weekday (d, format)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (nargin < 2)
-    form = "short";
+    format = "short";
   endif
 
   if (iscell (d) || isnumeric (d))
     endsize = size (d);
   elseif (ischar (d))
     endsize = [size(d, 1), 1];
   endif
   if (ischar (d) || iscell (d))
@@ -54,17 +55,17 @@ function [d, s] = weekday (d, form)
     d = datenum (d);
   endif
   ## Find the offset from a known Sunday (2008-Jan-6), mod 7.
   d = floor (reshape (mod(d - 733048, 7), endsize));
   ## Make Saturdays a 7 and not a 0.
   d(!d) = 7;
 
   if (nargout > 1)
-    if (strcmpi (form, "long"))
+    if (strcmpi (format, "long"))
       names = {"Sunday" "Monday" "Tuesday" "Wednesday" "Thursday"
                "Friday" "Saturday"};
     else
       names = {"Sun" "Mon" "Tue" "Wed" "Thu" "Fri" "Sat"};
     endif
     s = strvcat (names(d));
   endif
 
