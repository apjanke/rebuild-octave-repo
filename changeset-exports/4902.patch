# HG changeset patch
# User jwe
# Date 1087238949 0
#      Mon Jun 14 18:49:09 2004 +0000
# Node ID bd043a433918b3c15c2e66578379eabe78078fa7
# Parent  35bfb4e0b96b18a66513fc851e2edda4d0c95ac6
[project @ 2004-06-14 18:46:20 by jwe]

diff --git a/liboctave/Array-i.cc b/liboctave/Array-i.cc
--- a/liboctave/Array-i.cc
+++ b/liboctave/Array-i.cc
@@ -19,26 +19,48 @@ along with Octave; see the file COPYING.
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include "oct-inttypes.h"
+
 // Instantiate Arrays of integer values.
 
 #include "Array.h"
 #include "Array.cc"
 
 INSTANTIATE_ARRAY_AND_ASSIGN (int);
 
 INSTANTIATE_ARRAY_ASSIGN (int, short);
 INSTANTIATE_ARRAY_ASSIGN (int, char);
 
+INSTANTIATE_ARRAY_AND_ASSIGN (octave_int8);
+INSTANTIATE_ARRAY_AND_ASSIGN (octave_int16);
+INSTANTIATE_ARRAY_AND_ASSIGN (octave_int32);
+INSTANTIATE_ARRAY_AND_ASSIGN (octave_int64);
+
+INSTANTIATE_ARRAY_AND_ASSIGN (octave_uint8);
+INSTANTIATE_ARRAY_AND_ASSIGN (octave_uint16);
+INSTANTIATE_ARRAY_AND_ASSIGN (octave_uint32);
+INSTANTIATE_ARRAY_AND_ASSIGN (octave_uint64);
+
+INSTANTIATE_ARRAY_CAT (octave_int8);
+INSTANTIATE_ARRAY_CAT (octave_int16);
+INSTANTIATE_ARRAY_CAT (octave_int32);
+INSTANTIATE_ARRAY_CAT (octave_int64);
+
+INSTANTIATE_ARRAY_CAT (octave_uint8);
+INSTANTIATE_ARRAY_CAT (octave_uint16);
+INSTANTIATE_ARRAY_CAT (octave_uint32);
+INSTANTIATE_ARRAY_CAT (octave_uint64);
+
 #include "Array2.h"
 
 template class Array2<int>;
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 template class DiagArray2<int>;
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -128,23 +128,22 @@ protected:
 	{
 	  --rep->count;
 	  rep = new ArrayRep (rep->length (), val);
 	}
       else
 	rep->fill (val);
     }
 
-  typename Array<T>::ArrayRep *rep;
-
 public:
 
-  // !!! WARNING !!! -- this is public because template friends don't
-  // work properly with versions of gcc earlier than 3.3.  You should
-  // not access this data member directly!
+  // !!! WARNING !!! -- these should be protected, not public.  You
+  // should not access these data members directly!
+
+  typename Array<T>::ArrayRep *rep;
 
   dim_vector dimensions;
 
 protected:
 
   idx_vector *idx;
   int idx_count;
 
@@ -161,16 +160,28 @@ private:
   typename Array<T>::ArrayRep *nil_rep (void) const
     {
       static typename Array<T>::ArrayRep *nr
 	= new typename Array<T>::ArrayRep ();
 
       return nr;
     }
 
+  template <class U>
+  T *
+  coerce (const U *a, int len)
+  {
+    T *retval = new T [len];
+
+    for (int i = 0; i < len; i++)
+      retval[i] = T (a[i]);
+
+    return retval;
+  }
+
 public:
 
   Array (void)
     : rep (nil_rep ()), dimensions (),
       idx (0), idx_count (0) { rep->count++; }
 
   explicit Array (int n)
     : rep (new typename Array<T>::ArrayRep (n)), dimensions (n),
@@ -178,16 +189,25 @@ public:
 
   explicit Array (int n, const T& val)
     : rep (new typename Array<T>::ArrayRep (n)), dimensions (n),
       idx (0), idx_count (0)
     {
       fill (val);
     }
 
+  // Type conversion case.
+  template <class U>
+  Array (const Array<U>& a)
+    : rep (new typename Array<T>::ArrayRep (coerce (a.data (), a.length ()), a.length ())),
+      dimensions (a.dimensions), idx (0), idx_count (0)
+    {
+    }
+
+  // No type conversion case.
   Array (const Array<T>& a)
     : rep (a.rep), dimensions (a.dimensions), idx (0), idx_count (0)
     {
       rep->count++;
     }
 
 public:
 
@@ -236,16 +256,18 @@ public:
   int dim2 (void) const { return dimensions(1); }
   int dim3 (void) const { return dimensions(2); }
 
   int rows (void) const { return dim1 (); }
   int cols (void) const { return dim2 (); }
   int columns (void) const { return dim2 (); }
   int pages (void) const { return dim3 (); }
 
+  size_t byte_size (void) const { return numel () * sizeof (T); }
+
   dim_vector dims (void) const { return dimensions; }
 
   Array<T> squeeze (void) const;
   
   void chop_trailing_singletons (void) 
   { dimensions.chop_trailing_singletons (); }
   
   static int get_size (int r, int c);
diff --git a/liboctave/ArrayN.h b/liboctave/ArrayN.h
--- a/liboctave/ArrayN.h
+++ b/liboctave/ArrayN.h
@@ -59,42 +59,58 @@ public:
 
   ArrayN (void) : Array<T> () { }
 
   ArrayN (const dim_vector& dv) : Array<T> (dv) { }
 
   ArrayN (const dim_vector& dv, const T& val)
     : Array<T> (dv) { fill (val); }
 
-  ArrayN (const Array2<T>& a) : Array<T> (a, a.dims ()) { }
+  template <class U>
+  explicit ArrayN (const Array2<U>& a) : Array<T> (a, a.dims ()) { }
 
-  ArrayN (const ArrayN<T>& a) : Array<T> (a, a.dims ()) { }
+  template <class U>
+  ArrayN (const ArrayN<U>& a) : Array<T> (a, a.dims ()) { }
 
-  ArrayN (const Array<T>& a) : Array<T> (a) { }
+  template <class U>
+  ArrayN (const Array<U>& a) : Array<T> (a) { }
 
-  ArrayN (const Array<T>& a, const dim_vector& dv) : Array<T> (a, dv) { }
+  template <class U>
+  ArrayN (const Array<U>& a, const dim_vector& dv)
+    : Array<T> (a, dv) { }
 
   ~ArrayN (void) { }
 
   ArrayN<T>& operator = (const ArrayN<T>& a)
     {
       if (this != &a)
 	Array<T>::operator = (a);
 
       return *this;
     }
 
+  ArrayN<T> reshape (const dim_vector& new_dims) const
+    { return Array<T>::reshape (new_dims); }
+
+  ArrayN<T> permute (const Array<int>& vec, bool inv = false) const
+    { return Array<T>::permute (vec, inv); }
+
+  ArrayN<T> ipermute (const Array<int>& vec) const
+    { return Array<T>::ipermute (vec); }
+
   void resize (const dim_vector& dv)
     { this->resize_no_fill (dv); }
 
   void resize (const dim_vector& dv, const T& val)
     { Array<T>::resize (dv, val); }
 
   ArrayN<T> squeeze (void) const { return Array<T>::squeeze (); }
 
+  ArrayN<T> transpose (void) const { return Array<T>::transpose (); }
+
   ArrayN<T>& insert (const ArrayN<T>& a, const dim_vector& dv)
     {
       Array<T>::insert (a, dv);
       return *this;
     }
 
   ArrayN<T>& insert (const ArrayN<T>& a, int r, int c)
   {
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -55,40 +55,16 @@ extern "C"
   F77_RET_T
   F77_FUNC (cfftf, CFFTF) (const int&, Complex*, Complex*);
 
   F77_RET_T
   F77_FUNC (cfftb, CFFTB) (const int&, Complex*, Complex*);
 }
 #endif
 
-// XXX FIXME XXX -- could we use a templated mixed-type copy function
-// here?
-
-ComplexNDArray::ComplexNDArray (const NDArray& a)
-  : MArrayN<Complex> (a.dims ())
-{
-  for (int i = 0; i < a.length (); i++)
-    elem (i) = a.elem (i);
-}
-
-ComplexNDArray::ComplexNDArray (const boolNDArray& a)
-  : MArrayN<Complex> (a.dims ())
-{
-  for (int i = 0; i < a.length (); i++)
-    elem (i) = a.elem (i);
-}
-
-ComplexNDArray::ComplexNDArray (const charNDArray& a)
-  : MArrayN<Complex> (a.dims ())
-{
-  for (int i = 0; i < a.length (); i++)
-    elem (i) = a.elem (i);
-}
-
 #if defined (HAVE_FFTW3)
 ComplexNDArray
 ComplexNDArray::fourier (int dim) const
 {
   dim_vector dv = dims ();
 
   if (dim > dv.length () || dim < 0)
     return ComplexNDArray ();
diff --git a/liboctave/CNDArray.h b/liboctave/CNDArray.h
--- a/liboctave/CNDArray.h
+++ b/liboctave/CNDArray.h
@@ -49,24 +49,16 @@ public:
     : MArrayN<Complex> (dv, val) { }
   
   ComplexNDArray (const ComplexNDArray& a) : MArrayN<Complex> (a) { }
 
   ComplexNDArray (const ComplexMatrix& a) : MArrayN<Complex> (a) { }
 
   ComplexNDArray (const MArrayN<Complex>& a) : MArrayN<Complex> (a) { }
 
-  ComplexNDArray (const ArrayN<Complex>& a) : MArrayN<Complex> (a) { }
-
-  explicit ComplexNDArray (const NDArray& a);
-
-  explicit ComplexNDArray (const boolNDArray& a);
-
-  explicit ComplexNDArray (const charNDArray& a);
-
   ComplexNDArray& operator = (const ComplexNDArray& a)
     {
       MArrayN<Complex>::operator = (a);
       return *this;
     }
 
   // unary operations
 
@@ -105,17 +97,17 @@ public:
   ComplexNDArray fourier2d (void) const;
   ComplexNDArray ifourier2d (void) const;
 
   ComplexNDArray fourierNd (void) const;
   ComplexNDArray ifourierNd (void) const;
 
   ComplexMatrix matrix_value (void) const;
 
-  ComplexNDArray squeeze (void) const { return ArrayN<Complex>::squeeze (); }
+  ComplexNDArray squeeze (void) const { return MArrayN<Complex>::squeeze (); }
 
   static void increment_index (Array<int>& ra_idx,
 			       const dim_vector& dimensions,
 			       int start_dimension = 0);
 
   static int compute_index (Array<int>& ra_idx,
 			    const dim_vector& dimensions);
 
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,61 @@
+2004-06-14  John W. Eaton  <jwe@octave.org>
+
+	* mx-base.h: Include headers for new int types.
+
+	* dNDArray.h, dNDArray.cc (NDArray::NDArray (const boolNDArray&),
+	NDArray::NDArray (const charNDArray&)): Delete.
+	(template <class U> explicit NDArray (const intNDArray<U>&)): New
+	constructor.
+	(NDArray::squeze): Call MArrayN::squeeze, not ArrayN::squeeze.
+
+	* chMatrix.h (CharMatrix::transpose): New forwarding functions for
+	return type conversion.
+
+	* ComplexNDArray.h, ComplexNDArray.cc
+	(ComplexNDArray::ComplexNDArray (const ArrayN<Complex>&),
+	(ComplexNDArray::ComplexNDArray (const NDArray&),
+	(ComplexNDArray::ComplexNDArray (const boolNDArray&),
+	(ComplexNDArray::ComplexNDArray (const charNDArray&)): Delete.
+	
+	(ComplexNDArray::squeze): Call MArrayN::squeeze, not ArrayN::squeeze.
+
+	* MArrayN.h:
+	(template <class U> explicit MArrayN<T>::MArrayN (const Array2<U>&),
+	(template <class U> MArrayN<T>::MArrayN (const ArrayN<U>&),
+	(template <class U> explicit MArrayN<T>::MArrayN (const MArray<U>&)):
+	New constructors.
+	(ArrayN<T>::reshape, ArrayN<T>::permute, ArrayN<T>::ipermute,
+	ArrayN<T>::squeeze):
+	New forwarding functions for return type conversion.
+
+	* ArrayN.h:
+	(template <class U> explicit ArrayN<T>::ArrayN (const Array2<U>&),
+	(template <class U> explicit ArrayN<T>::ArrayN (const ArrayN<U>&),
+	(template <class U> explicit ArrayN<T>::ArrayN (const Array<U>&),
+	(template <class U> explicit ArrayN<T>::ArrayN (const Array<U>&,
+	const dim_vector&)): New constructors.
+	(ArrayN<T>::reshape, ArrayN<T>::permute, ArrayN<T>::ipermute,
+	ArrayN<T>::transpose):
+	New forwarding functions for return type conversion.
+
+	* Array.h (template <class U> Array<T>::Array (const Array<U>&)):
+	New constructor.
+	(Array<T>::coerce, Array<T>::byte_size): New functions.
+
+	* Array-i.cc, MArray-i.cc: Instantiate new integer types.
+
+	* oct-inttypes.h, int16NDArray.h, int32NDArray.h, int64NDArray.h,
+	int8NDArray.h , intNDArray.h, uint16NDArray.h, uint32NDArray.h,
+	uint64NDArray.h, uint8NDArray.h, int16NDArray.cc, int32NDArray.cc,
+	int64NDArray.cc, int8NDArray.cc, intNDArray.cc, uint16NDArray.cc,
+	uint32NDArray.cc, uint64NDArray.cc, uint8NDArray.cc: New files.
+	* Makefile.in: Add them to the appropriate lists.
+
 2004-06-04  John W. Eaton  <jwe@octave.org>
 
 	* mx-inlines.cc (MX_ND_REDUCTION): New arg, RET_ELT_TYPE.  Use
 	"RET_ELT_TYPE ()" rather than "false" as fill value for retval
 	resize op.  Change all uses.
 
 2004-06-03  David Bateman  <dbateman@free.fr>
 
diff --git a/liboctave/MArray-i.cc b/liboctave/MArray-i.cc
--- a/liboctave/MArray-i.cc
+++ b/liboctave/MArray-i.cc
@@ -19,32 +19,81 @@ along with Octave; see the file COPYING.
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include "oct-inttypes.h"
+
 // Instantiate MArrays of int values.
 
 #include "MArray.h"
 #include "MArray.cc"
 
 template class MArray<int>;
 
 INSTANTIATE_MARRAY_FRIENDS (int)
 
+template class MArray<octave_int8>;
+template class MArray<octave_int16>;
+template class MArray<octave_int32>;
+template class MArray<octave_int64>;
+
+INSTANTIATE_MARRAY_FRIENDS (octave_int8)
+INSTANTIATE_MARRAY_FRIENDS (octave_int16)
+INSTANTIATE_MARRAY_FRIENDS (octave_int32)
+INSTANTIATE_MARRAY_FRIENDS (octave_int64)
+
+template class MArray<octave_uint8>;
+template class MArray<octave_uint16>;
+template class MArray<octave_uint32>;
+template class MArray<octave_uint64>;
+
+INSTANTIATE_MARRAY_FRIENDS (octave_uint8)
+INSTANTIATE_MARRAY_FRIENDS (octave_uint16)
+INSTANTIATE_MARRAY_FRIENDS (octave_uint32)
+INSTANTIATE_MARRAY_FRIENDS (octave_uint64)
+
 #include "MArray2.h"
 #include "MArray2.cc"
 
 template class MArray2<int>;
 
 INSTANTIATE_MARRAY2_FRIENDS (int)
 
+#include "MArrayN.h"
+#include "MArrayN.cc"
+
+template class MArrayN<int>;
+
+INSTANTIATE_MARRAYN_FRIENDS (int)
+
+template class MArrayN<octave_int8>;
+template class MArrayN<octave_int16>;
+template class MArrayN<octave_int32>;
+template class MArrayN<octave_int64>;
+
+INSTANTIATE_MARRAYN_FRIENDS (octave_int8)
+INSTANTIATE_MARRAYN_FRIENDS (octave_int16)
+INSTANTIATE_MARRAYN_FRIENDS (octave_int32)
+INSTANTIATE_MARRAYN_FRIENDS (octave_int64)
+
+template class MArrayN<octave_uint8>;
+template class MArrayN<octave_uint16>;
+template class MArrayN<octave_uint32>;
+template class MArrayN<octave_uint64>;
+
+INSTANTIATE_MARRAYN_FRIENDS (octave_uint8)
+INSTANTIATE_MARRAYN_FRIENDS (octave_uint16)
+INSTANTIATE_MARRAYN_FRIENDS (octave_uint32)
+INSTANTIATE_MARRAYN_FRIENDS (octave_uint64)
+
 #include "MDiagArray2.h"
 #include "MDiagArray2.cc"
 
 template class MDiagArray2<int>;
 
 INSTANTIATE_MDIAGARRAY2_FRIENDS (int)
 
 /*
diff --git a/liboctave/MArrayN.h b/liboctave/MArrayN.h
--- a/liboctave/MArrayN.h
+++ b/liboctave/MArrayN.h
@@ -51,29 +51,43 @@ protected:
 public:
   
   MArrayN (void) : ArrayN<T> () {}
   
   MArrayN (const dim_vector& dv) : ArrayN<T> (dv) { }
   
   MArrayN (const dim_vector& dv, const T& val) : ArrayN<T> (dv, val) { }
 
-  MArrayN (const Array2<T>& a) : ArrayN<T> (a) { }
+  template <class U>
+  explicit MArrayN (const Array2<U>& a) : ArrayN<T> (a) { }
 
-  MArrayN (const ArrayN<T>& a) : ArrayN<T> (a) { }
+  template <class U>
+  MArrayN (const ArrayN<U>& a) : ArrayN<T> (a) { }
 
-  MArrayN (const MArrayN<T>& a) : ArrayN<T> (a) { }
+  template <class U>
+  MArrayN (const MArrayN<U>& a) : ArrayN<T> (a) { }
 
   ~MArrayN (void) { }
 
   MArrayN<T>& operator = (const MArrayN<T>& a)
     {
       ArrayN<T>::operator = (a);
       return *this;
     }
+
+  MArrayN<T> reshape (const dim_vector& new_dims) const
+    { return ArrayN<T>::reshape (new_dims); }
+
+  MArrayN<T> permute (const Array<int>& vec, bool inv = false) const
+    { return ArrayN<T>::permute (vec, inv); }
+
+  MArrayN<T> ipermute (const Array<int>& vec) const
+    { return ArrayN<T>::ipermute (vec); }
+
+  MArrayN squeeze (void) const { return ArrayN<T>::squeeze (); }
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/Makefile.in b/liboctave/Makefile.in
--- a/liboctave/Makefile.in
+++ b/liboctave/Makefile.in
@@ -27,17 +27,19 @@ MATRIX_INC := Array.h Array2.h Array3.h 
 	MArray.h MArray2.h MDiagArray2.h Matrix.h MArrayN.h \
 	base-lu.h dim-vector.h mx-base.h mx-op-defs.h mx-ops.h \
 	mx-defs.h mx-ext.h CColVector.h CDiagMatrix.h CMatrix.h \
 	CNDArray.h CRowVector.h CmplxAEPBAL.h CmplxCHOL.h \
 	CmplxDET.h CmplxHESS.h CmplxLU.h CmplxQR.h CmplxQRP.h \
 	CmplxSCHUR.h CmplxSVD.h EIG.h boolMatrix.h boolNDArray.h \
 	chMatrix.h chNDArray.h dColVector.h dDiagMatrix.h dMatrix.h \
 	dNDArray.h dRowVector.h dbleAEPBAL.h dbleCHOL.h dbleDET.h \
-	dbleHESS.h dbleLU.h dbleQR.h dbleQRP.h dbleSCHUR.h dbleSVD.h
+	dbleHESS.h dbleLU.h dbleQR.h dbleQRP.h dbleSCHUR.h dbleSVD.h \
+	int8NDArray.h uint8NDArray.h int16NDArray.h uint16NDArray.h \
+	int32NDArray.h uint32NDArray.h int64NDArray.h uint64NDArray.h 
 
 MX_OP_INC := $(shell $(AWK) -f $(srcdir)/mk-ops.awk prefix=mx list_h_files=1 $(srcdir)/mx-ops)
 
 VX_OP_INC := $(shell $(AWK) -f $(srcdir)/mk-ops.awk prefix=vx list_h_files=1 $(srcdir)/vx-ops)
 
 OPTS_INC_DATA := DASPK-opts.in DASRT-opts.in DASSL-opts.in \
 	LSODE-opts.in NLEqn-opts.in ODESSA-opts.in Quad-opts.in
 
@@ -71,20 +73,22 @@ TI_SRC := Array-C.cc Array-b.cc Array-ch
 	Array-s.cc Array-so.cc Array-str.cc Array-idx-vec.cc \
 	MArray-C.cc MArray-ch.cc MArray-i.cc MArray-d.cc MArray-s.cc
 
 MATRIX_SRC := Array-flags.cc Array-util.cc CColVector.cc \
 	CDiagMatrix.cc CMatrix.cc CNDArray.cc CRowVector.cc \
 	CmplxAEPBAL.cc CmplxCHOL.cc CmplxDET.cc CmplxHESS.cc \
 	CmplxLU.cc CmplxQR.cc CmplxQRP.cc CmplxSCHUR.cc CmplxSVD.cc \
 	EIG.cc boolMatrix.cc boolNDArray.cc chMatrix.cc \
-	chNDArray.cc dColVector.cc  dDiagMatrix.cc dMatrix.cc \
+	chNDArray.cc dColVector.cc dDiagMatrix.cc dMatrix.cc \
 	dNDArray.cc dRowVector.cc dbleAEPBAL.cc dbleCHOL.cc \
 	dbleDET.cc dbleHESS.cc dbleLU.cc dbleQR.cc dbleQRP.cc \
-	dbleSCHUR.cc dbleSVD.cc
+	dbleSCHUR.cc dbleSVD.cc \
+	int8NDArray.cc uint8NDArray.cc int16NDArray.cc uint16NDArray.cc \
+	int32NDArray.cc uint32NDArray.cc int64NDArray.cc uint64NDArray.cc 
 
 MX_OP_SRC := $(shell $(AWK) -f $(srcdir)/mk-ops.awk prefix=mx list_cc_files=1 $(srcdir)/mx-ops)
 
 VX_OP_SRC := $(shell $(AWK) -f $(srcdir)/mk-ops.awk prefix=vx list_cc_files=1 $(srcdir)/vx-ops)
 
 LIBOCTAVE_CXX_SOURCES := Bounds.cc CollocWt.cc \
 	DASPK.cc DASRT.cc DASSL.cc FEGrid.cc LinConst.cc \
 	LPsolve.cc LSODE.cc NLEqn.cc ODES.cc ODESSA.cc \
diff --git a/liboctave/chMatrix.h b/liboctave/chMatrix.h
--- a/liboctave/chMatrix.h
+++ b/liboctave/chMatrix.h
@@ -55,16 +55,18 @@ public:
     {
       MArray2<char>::operator = (a);
       return *this;
     }
 
   bool operator == (const charMatrix& a) const;
   bool operator != (const charMatrix& a) const;
 
+  charMatrix transpose (void) const { return MArray2<char>::transpose (); }
+
   // destructive insert/delete/reorder operations
 
   charMatrix& insert (const char *s, int r, int c);
   charMatrix& insert (const charMatrix& a, int r, int c);
 
   std::string row_as_string (int, bool strip_ws = false, bool raw = false) const;
 
   // resize is the destructive equivalent for this one
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -477,30 +477,16 @@ NDArray::ifourierNd (void) const
       stride *= dv(i);
     }
 
   return retval;
 }
 
 #endif
 
-NDArray::NDArray (const boolNDArray& a)
-  : MArrayN<double> (a.dims ())
-{
-  for (int i = 0; i < a.length (); i++)
-    elem (i) = a.elem (i);
-}
-
-NDArray::NDArray (const charNDArray& a)
-  : MArrayN<double> (a.dims ())
-{
-  for (int i = 0; i < a.length (); i++)
-    elem (i) = a.elem (i);
-}
-
 // unary operations
 
 boolNDArray
 NDArray::operator ! (void) const
 {
   boolNDArray b (dims ());
 
   for (int i = 0; i < length (); i++)
diff --git a/liboctave/dNDArray.h b/liboctave/dNDArray.h
--- a/liboctave/dNDArray.h
+++ b/liboctave/dNDArray.h
@@ -24,16 +24,17 @@ Software Foundation, 59 Temple Place - S
 #define octave_NDArray_h 1
 
 #if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
 #pragma interface
 #endif
 
 #include "MArrayN.h"
 #include "dMatrix.h"
+#include "intNDArray.h"
 
 #include "mx-defs.h"
 #include "mx-op-defs.h"
 
 #include "data-conv.h"
 #include "mach-info.h"
 
 class
@@ -49,21 +50,18 @@ public:
     : MArrayN<double> (dv, val) { }
   
   NDArray (const NDArray& a) : MArrayN<double> (a) { }
 
   NDArray (const Matrix& a) : MArrayN<double> (a) { }
 
   NDArray (const MArrayN<double>& a) : MArrayN<double> (a) { }
 
-  NDArray (const ArrayN<double>& a) : MArrayN<double> (a) { }
-
-  explicit NDArray (const boolNDArray& a);
-
-  explicit NDArray (const charNDArray& a);
+  template <class U>
+  explicit NDArray (const intNDArray<U>& a) : MArrayN<double> (a) { }
 
   NDArray& operator = (const NDArray& a)
     {
       MArrayN<double>::operator = (a);
       return *this;
     }
 
   // unary operations
@@ -104,17 +102,17 @@ public:
   ComplexNDArray fourierNd (void) const;
   ComplexNDArray ifourierNd (void) const;
 
   friend NDArray real (const ComplexNDArray& a);
   friend NDArray imag (const ComplexNDArray& a);
 
   Matrix matrix_value (void) const;
 
-  NDArray squeeze (void) const { return ArrayN<double>::squeeze (); }
+  NDArray squeeze (void) const { return MArrayN<double>::squeeze (); }
 
   static void increment_index (Array<int>& ra_idx,
 			       const dim_vector& dimensions,
 			       int start_dimension = 0);
 
   static int compute_index (Array<int>& ra_idx,
 			    const dim_vector& dimensions);
 
diff --git a/liboctave/int16NDArray.cc b/liboctave/int16NDArray.cc
new file mode 100644
--- /dev/null
+++ b/liboctave/int16NDArray.cc
@@ -0,0 +1,59 @@
+// N-D Array  manipulations.
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "int16NDArray.h"
+
+#include "intNDArray.cc"
+
+template class intNDArray<octave_int16>;
+
+template
+std::ostream&
+operator << (std::ostream& os, const intNDArray<octave_int16>& a);
+
+template
+std::istream&
+operator >> (std::istream& is, intNDArray<octave_int16>& a);
+
+NDS_CMP_OPS (int16NDArray, , octave_int16, )
+NDS_BOOL_OPS (int16NDArray, octave_int16, octave_int16 (0))
+
+SND_CMP_OPS (octave_int16, , int16NDArray, )
+SND_BOOL_OPS (octave_int16, int16NDArray, octave_int16 (0))
+
+NDND_CMP_OPS (int16NDArray, , int16NDArray, )
+NDND_BOOL_OPS (int16NDArray, int16NDArray, octave_int16 (0))
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/int16NDArray.h b/liboctave/int16NDArray.h
new file mode 100644
--- /dev/null
+++ b/liboctave/int16NDArray.h
@@ -0,0 +1,53 @@
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if !defined (octave_int16NDArray_h)
+#define octave_int16NDArray_h 1
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma interface
+#endif
+
+#include "intNDArray.h"
+#include "mx-op-defs.h"
+#include "oct-inttypes.h"
+
+typedef intNDArray<octave_int16> int16NDArray;
+
+NDS_CMP_OP_DECLS (int16NDArray, octave_int16)
+NDS_BOOL_OP_DECLS (int16NDArray, octave_int16)
+
+SND_CMP_OP_DECLS (octave_int16, int16NDArray)
+SND_BOOL_OP_DECLS (octave_int16, int16NDArray)
+
+NDND_CMP_OP_DECLS (int16NDArray, int16NDArray)
+NDND_BOOL_OP_DECLS (int16NDArray, int16NDArray)
+
+MARRAY_FORWARD_DEFS (MArrayN, int16NDArray, octave_int16)
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/int32NDArray.cc b/liboctave/int32NDArray.cc
new file mode 100644
--- /dev/null
+++ b/liboctave/int32NDArray.cc
@@ -0,0 +1,59 @@
+// N-D Array  manipulations.
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "int32NDArray.h"
+
+#include "intNDArray.cc"
+
+template class intNDArray<octave_int32>;
+
+template
+std::ostream&
+operator << (std::ostream& os, const intNDArray<octave_int32>& a);
+
+template
+std::istream&
+operator >> (std::istream& is, intNDArray<octave_int32>& a);
+
+NDS_CMP_OPS (int32NDArray, , octave_int32, )
+NDS_BOOL_OPS (int32NDArray, octave_int32, octave_int32 (0))
+
+SND_CMP_OPS (octave_int32, , int32NDArray, )
+SND_BOOL_OPS (octave_int32, int32NDArray, octave_int32 (0))
+
+NDND_CMP_OPS (int32NDArray, , int32NDArray, )
+NDND_BOOL_OPS (int32NDArray, int32NDArray, octave_int32 (0))
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/int32NDArray.h b/liboctave/int32NDArray.h
new file mode 100644
--- /dev/null
+++ b/liboctave/int32NDArray.h
@@ -0,0 +1,53 @@
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if !defined (octave_int32NDArray_h)
+#define octave_int32NDArray_h 1
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma interface
+#endif
+
+#include "intNDArray.h"
+#include "mx-op-defs.h"
+#include "oct-inttypes.h"
+
+typedef intNDArray<octave_int32> int32NDArray;
+
+NDS_CMP_OP_DECLS (int32NDArray, octave_int32)
+NDS_BOOL_OP_DECLS (int32NDArray, octave_int32)
+
+SND_CMP_OP_DECLS (octave_int32, int32NDArray)
+SND_BOOL_OP_DECLS (octave_int32, int32NDArray)
+
+NDND_CMP_OP_DECLS (int32NDArray, int32NDArray)
+NDND_BOOL_OP_DECLS (int32NDArray, int32NDArray)
+
+MARRAY_FORWARD_DEFS (MArrayN, int32NDArray, octave_int32)
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/int64NDArray.cc b/liboctave/int64NDArray.cc
new file mode 100644
--- /dev/null
+++ b/liboctave/int64NDArray.cc
@@ -0,0 +1,59 @@
+// N-D Array  manipulations.
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "int64NDArray.h"
+
+#include "intNDArray.cc"
+
+template class intNDArray<octave_int64>;
+
+template
+std::ostream&
+operator << (std::ostream& os, const intNDArray<octave_int64>& a);
+
+template
+std::istream&
+operator >> (std::istream& is, intNDArray<octave_int64>& a);
+
+NDS_CMP_OPS (int64NDArray, , octave_int64, )
+NDS_BOOL_OPS (int64NDArray, octave_int64, octave_int64 (0))
+
+SND_CMP_OPS (octave_int64, , int64NDArray, )
+SND_BOOL_OPS (octave_int64, int64NDArray, octave_int64 (0))
+
+NDND_CMP_OPS (int64NDArray, , int64NDArray, )
+NDND_BOOL_OPS (int64NDArray, int64NDArray, octave_int64 (0))
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/int64NDArray.h b/liboctave/int64NDArray.h
new file mode 100644
--- /dev/null
+++ b/liboctave/int64NDArray.h
@@ -0,0 +1,53 @@
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if !defined (octave_int64NDArray_h)
+#define octave_int64NDArray_h 1
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma interface
+#endif
+
+#include "intNDArray.h"
+#include "mx-op-defs.h"
+#include "oct-inttypes.h"
+
+typedef intNDArray<octave_int64> int64NDArray;
+
+NDS_CMP_OP_DECLS (int64NDArray, octave_int64)
+NDS_BOOL_OP_DECLS (int64NDArray, octave_int64)
+
+SND_CMP_OP_DECLS (octave_int64, int64NDArray)
+SND_BOOL_OP_DECLS (octave_int64, int64NDArray)
+
+NDND_CMP_OP_DECLS (int64NDArray, int64NDArray)
+NDND_BOOL_OP_DECLS (int64NDArray, int64NDArray)
+
+MARRAY_FORWARD_DEFS (MArrayN, int64NDArray, octave_int64)
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/int8NDArray.cc b/liboctave/int8NDArray.cc
new file mode 100644
--- /dev/null
+++ b/liboctave/int8NDArray.cc
@@ -0,0 +1,59 @@
+// N-D Array  manipulations.
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "int8NDArray.h"
+
+#include "intNDArray.cc"
+
+template class intNDArray<octave_int8>;
+
+template
+std::ostream&
+operator << (std::ostream& os, const intNDArray<octave_int8>& a);
+
+template
+std::istream&
+operator >> (std::istream& is, intNDArray<octave_int8>& a);
+
+NDS_CMP_OPS (int8NDArray, , octave_int8, )
+NDS_BOOL_OPS (int8NDArray, octave_int8, octave_int8 (0))
+
+SND_CMP_OPS (octave_int8, , int8NDArray, )
+SND_BOOL_OPS (octave_int8, int8NDArray, octave_int8 (0))
+
+NDND_CMP_OPS (int8NDArray, , int8NDArray, )
+NDND_BOOL_OPS (int8NDArray, int8NDArray, octave_int8 (0))
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/int8NDArray.h b/liboctave/int8NDArray.h
new file mode 100644
--- /dev/null
+++ b/liboctave/int8NDArray.h
@@ -0,0 +1,53 @@
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if !defined (octave_int8NDArray_h)
+#define octave_int8NDArray_h 1
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma interface
+#endif
+
+#include "intNDArray.h"
+#include "mx-op-defs.h"
+#include "oct-inttypes.h"
+
+typedef intNDArray<octave_int8> int8NDArray;
+
+NDS_CMP_OP_DECLS (int8NDArray, octave_int8)
+NDS_BOOL_OP_DECLS (int8NDArray, octave_int8)
+
+SND_CMP_OP_DECLS (octave_int8, int8NDArray)
+SND_BOOL_OP_DECLS (octave_int8, int8NDArray)
+
+NDND_CMP_OP_DECLS (int8NDArray, int8NDArray)
+NDND_BOOL_OP_DECLS (int8NDArray, int8NDArray)
+
+MARRAY_FORWARD_DEFS (MArrayN, int8NDArray, octave_int8)
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/intNDArray.cc b/liboctave/intNDArray.cc
new file mode 100644
--- /dev/null
+++ b/liboctave/intNDArray.cc
@@ -0,0 +1,136 @@
+// N-D Array  manipulations.
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "Array-util.h"
+#include "mx-base.h"
+#include "lo-ieee.h"
+
+// unary operations
+
+template <class T>
+boolNDArray
+intNDArray<T>::operator ! (void) const
+{
+  boolNDArray b (dims ());
+
+  for (int i = 0; i < length (); i++)
+    b.elem (i) = ! elem (i);
+
+  return b;
+}
+
+// XXX FIXME XXX -- this is not quite the right thing.
+
+template <class T>
+boolNDArray
+intNDArray<T>::all (int dim) const
+{
+  MX_ND_ANY_ALL_REDUCTION (MX_ND_ALL_EVAL (elem (iter_idx) == T (0)), true);
+}
+
+template <class T>
+boolNDArray
+intNDArray<T>::any (int dim) const
+{
+  MX_ND_ANY_ALL_REDUCTION (MX_ND_ALL_EVAL (elem (iter_idx) == T (0)), false);
+}
+
+template <class T>
+int
+intNDArray<T>::cat (const intNDArray<T>& ra_arg, int dim, int iidx, int move)
+{
+  return ::cat_ra (*this, ra_arg, dim, iidx, move);  
+}
+
+template <class T>
+void
+intNDArray<T>::increment_index (Array<int>& ra_idx,
+			       const dim_vector& dimensions,
+			       int start_dimension)
+{
+  ::increment_index (ra_idx, dimensions, start_dimension);
+}
+
+template <class T>
+int 
+intNDArray<T>::compute_index (Array<int>& ra_idx,
+			      const dim_vector& dimensions)
+{
+  return ::compute_index (ra_idx, dimensions);
+}
+
+// This contains no information on the array structure !!!
+
+template <class T>
+std::ostream&
+operator << (std::ostream& os, const intNDArray<T>& a)
+{
+  int nel = a.nelem ();
+
+  for (int i = 0; i < nel; i++)
+    os << " " << a.elem (i) << "\n";
+
+  return os;
+}
+
+template <class T>
+std::istream&
+operator >> (std::istream& is, intNDArray<T>& a)
+{
+  int nel = a.nelem ();
+
+  if (nel < 1 )
+    is.clear (std::ios::badbit);
+  else
+    {
+      T tmp;
+
+      for (int i = 0; i < nel; i++)
+	{
+	  is >> tmp;
+
+	  if (is)
+	    a.elem (i) = tmp;
+	  else
+	    goto done;
+	}
+    }
+
+ done:
+
+  return is;
+}
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/intNDArray.h b/liboctave/intNDArray.h
new file mode 100644
--- /dev/null
+++ b/liboctave/intNDArray.h
@@ -0,0 +1,108 @@
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if !defined (octave_intNDArray_h)
+#define octave_intNDArray_h 1
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma interface
+#endif
+
+#include "MArrayN.h"
+#include "boolNDArray.h"
+
+template <class T>
+class
+intNDArray : public MArrayN<T>
+{
+public:
+  
+  intNDArray (void) : MArrayN<T> () { }
+
+  intNDArray (T val) : MArrayN<T> (dim_vector (1, 1), val) { }
+
+  intNDArray (const dim_vector& dv) : MArrayN<T> (dv) { }
+  
+  intNDArray (const dim_vector& dv, T val)
+    : MArrayN<T> (dv, val) { }
+  
+  template <class U>
+  explicit intNDArray (const Array<U>& a) : MArrayN<T> (a) { }
+
+  template <class U>
+  explicit intNDArray (const ArrayN<U>& a) : MArrayN<T> (a) { }
+
+  template <class U>
+  intNDArray (const MArrayN<U>& a) : MArrayN<T> (a) { }
+
+  template <class U>
+  intNDArray (const intNDArray<U>& a) : MArrayN<T> (a) { }
+
+  intNDArray& operator = (const intNDArray<T>& a)
+    {
+      MArrayN<T>::operator = (a);
+      return *this;
+    }
+
+  boolNDArray operator ! (void) const;
+
+  // XXX FIXME XXX -- this is not quite the right thing.
+
+  boolNDArray all (int dim = -1) const;
+  boolNDArray any (int dim = -1) const;
+  int cat (const intNDArray<T>& ra_arg, int dim, int iidx, int move);
+
+  intNDArray squeeze (void) const
+    { return intNDArray<T> (MArrayN<T>::squeeze ()); }
+
+  intNDArray transpose (void) const
+    { return intNDArray<T> (MArrayN<T>::transpose ()); }
+
+  static void increment_index (Array<int>& ra_idx,
+			       const dim_vector& dimensions,
+			       int start_dimension = 0);
+
+  static int compute_index (Array<int>& ra_idx,
+			    const dim_vector& dimensions);
+
+  static T resize_fill_value (void) { return 0; }
+
+protected:
+
+  intNDArray (T *d, dim_vector& dv) : MArrayN<T> (d, dv) { }
+};
+
+// i/o
+
+template <class T>
+std::ostream& operator << (std::ostream& os, const intNDArray<T>& a);
+
+template <class T>
+std::istream& operator >> (std::istream& is, intNDArray<T>& a);
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/lo-utils.h b/liboctave/lo-utils.h
--- a/liboctave/lo-utils.h
+++ b/liboctave/lo-utils.h
@@ -49,18 +49,18 @@ extern "C" void octave_qsort (void *base
 			      int (*cmp) (const void *, const void *));
 
 extern "C" char *oct_strptime (const char *buf, const char *format,
 			       struct tm *tm);
 
 extern double octave_read_double (std::istream& is);
 extern Complex octave_read_complex (std::istream& is);
 
-extern void octave_write_double (std::ostream& os, double d);
-extern void octave_write_complex (std::ostream& os, const Complex& c);
+extern void octave_write_double (std::ostream& os, double dval);
+extern void octave_write_complex (std::ostream& os, const Complex& cval);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-base.h b/liboctave/mx-base.h
--- a/liboctave/mx-base.h
+++ b/liboctave/mx-base.h
@@ -47,15 +47,25 @@ Software Foundation, 59 Temple Place - S
 
 // N-d Array classes.
 
 #include "boolNDArray.h"
 #include "chNDArray.h"
 #include "dNDArray.h"
 #include "CNDArray.h"
 
+#include "int8NDArray.h"
+#include "int16NDArray.h"
+#include "int32NDArray.h"
+#include "int64NDArray.h"
+
+#include "uint8NDArray.h"
+#include "uint16NDArray.h"
+#include "uint32NDArray.h"
+#include "uint64NDArray.h"
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/oct-inttypes.h b/liboctave/oct-inttypes.h
new file mode 100644
--- /dev/null
+++ b/liboctave/oct-inttypes.h
@@ -0,0 +1,291 @@
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if !defined (octave_inttypes_h)
+#define octave_inttypes_h 1
+
+#include <limits>
+
+#include <iostream>
+
+#include "data-conv.h"
+
+typedef signed char octave_int8_t;
+typedef TWO_BYTE_INT octave_int16_t;
+typedef FOUR_BYTE_INT octave_int32_t;
+typedef EIGHT_BYTE_INT octave_int64_t;
+
+typedef unsigned char octave_uint8_t;
+typedef unsigned TWO_BYTE_INT octave_uint16_t;
+typedef unsigned FOUR_BYTE_INT octave_uint32_t;
+typedef unsigned EIGHT_BYTE_INT octave_uint64_t;
+
+template <class T1, class T2>
+class
+octave_int_binop_traits
+{
+public:
+  // The return type for a T1 by T2 binary operation.
+  typedef T1 TR;
+};
+
+#define OCTAVE_INT_BINOP_TRAIT(T1, T2, T3) \
+  template<> \
+  class octave_int_binop_traits <T1, T2> \
+  { \
+  public: \
+    typedef T3 TR; \
+  }
+
+OCTAVE_INT_BINOP_TRAIT(octave_int8_t, octave_int8_t, octave_int8_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int8_t, octave_int16_t, octave_int8_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int8_t, octave_int32_t, octave_int8_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int8_t, octave_int64_t, octave_int8_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int8_t, octave_uint8_t, octave_int8_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int8_t, octave_uint16_t, octave_int8_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int8_t, octave_uint32_t, octave_int8_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int8_t, octave_uint64_t, octave_int8_t);
+
+OCTAVE_INT_BINOP_TRAIT(octave_int16_t, octave_int8_t, octave_int16_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int16_t, octave_int16_t, octave_int16_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int16_t, octave_int32_t, octave_int16_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int16_t, octave_int64_t, octave_int16_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int16_t, octave_uint8_t, octave_int16_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int16_t, octave_uint16_t, octave_int16_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int16_t, octave_uint32_t, octave_int16_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int16_t, octave_uint64_t, octave_int16_t);
+
+OCTAVE_INT_BINOP_TRAIT(octave_int32_t, octave_int8_t, octave_int32_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int32_t, octave_int16_t, octave_int32_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int32_t, octave_int32_t, octave_int32_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int32_t, octave_int64_t, octave_int32_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int32_t, octave_uint8_t, octave_int32_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int32_t, octave_uint16_t, octave_int32_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int32_t, octave_uint32_t, octave_int32_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int32_t, octave_uint64_t, octave_int32_t);
+
+OCTAVE_INT_BINOP_TRAIT(octave_int64_t, octave_int8_t, octave_int64_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int64_t, octave_int16_t, octave_int64_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int64_t, octave_int32_t, octave_int64_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int64_t, octave_int64_t, octave_int64_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int64_t, octave_uint8_t, octave_int64_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int64_t, octave_uint16_t, octave_int64_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int64_t, octave_uint32_t, octave_int64_t);
+OCTAVE_INT_BINOP_TRAIT(octave_int64_t, octave_uint64_t, octave_int64_t);
+
+OCTAVE_INT_BINOP_TRAIT(octave_uint8_t, octave_int8_t, octave_int8_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint8_t, octave_int16_t, octave_int8_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint8_t, octave_int32_t, octave_int8_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint8_t, octave_int64_t, octave_int8_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint8_t, octave_uint8_t, octave_uint8_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint8_t, octave_uint16_t, octave_uint8_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint8_t, octave_uint32_t, octave_uint8_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint8_t, octave_uint64_t, octave_uint8_t);
+
+OCTAVE_INT_BINOP_TRAIT(octave_uint16_t, octave_int8_t, octave_int16_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint16_t, octave_int16_t, octave_int16_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint16_t, octave_int32_t, octave_int16_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint16_t, octave_int64_t, octave_int16_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint16_t, octave_uint8_t, octave_uint16_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint16_t, octave_uint16_t, octave_uint16_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint16_t, octave_uint32_t, octave_uint16_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint16_t, octave_uint64_t, octave_uint16_t);
+
+OCTAVE_INT_BINOP_TRAIT(octave_uint32_t, octave_int8_t, octave_int32_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint32_t, octave_int16_t, octave_int32_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint32_t, octave_int32_t, octave_int32_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint32_t, octave_int64_t, octave_int32_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint32_t, octave_uint8_t, octave_uint32_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint32_t, octave_uint16_t, octave_uint32_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint32_t, octave_uint32_t, octave_uint32_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint32_t, octave_uint64_t, octave_uint32_t);
+
+OCTAVE_INT_BINOP_TRAIT(octave_uint64_t, octave_int8_t, octave_int64_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint64_t, octave_int16_t, octave_int64_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint64_t, octave_int32_t, octave_int64_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint64_t, octave_int64_t, octave_int64_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint64_t, octave_uint8_t, octave_uint64_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint64_t, octave_uint16_t, octave_uint64_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint64_t, octave_uint32_t, octave_uint64_t);
+OCTAVE_INT_BINOP_TRAIT(octave_uint64_t, octave_uint64_t, octave_uint64_t);
+
+template <class T1, class T2>
+inline T2
+octave_int_fit_to_range (const T1& x, const T2& mn, const T2& mx)
+{
+  return (x > mx ? mx : (x < mn ? mn : static_cast<T2> (x)));
+}
+
+#define OCTAVE_INT_FIT_TO_RANGE(r, T) \
+  octave_int_fit_to_range (r, std::numeric_limits<T>::min (), std::numeric_limits<T>::max ())
+
+#define OCTAVE_INT_MIN_VAL2(T1, T2) \
+  std::numeric_limits<typename octave_int_binop_traits<T1, T2>::TR>::min ()
+
+#define OCTAVE_INT_MAX_VAL2(T1, T2) \
+  std::numeric_limits<typename octave_int_binop_traits<T1, T2>::TR>::max ()
+
+#define OCTAVE_INT_FIT_TO_RANGE2(r, T1, T2) \
+  octave_int_fit_to_range (r, \
+                           OCTAVE_INT_MIN_VAL2 (T1, T2), \
+                           OCTAVE_INT_MAX_VAL2 (T1, T2))
+
+template <class T>
+class
+octave_int
+{
+public:
+
+  octave_int (void) : ival () { }
+
+  template <class U>
+  octave_int (U i) : ival (OCTAVE_INT_FIT_TO_RANGE (i, T)) { }
+
+  octave_int (bool b) : ival (b) { }
+
+  template <class U>
+  octave_int (const octave_int<U>& i)
+    : ival (OCTAVE_INT_FIT_TO_RANGE (i.value (), T)) { }
+
+  octave_int (const octave_int<T>& i) : ival (i.ival) { }
+
+  octave_int& operator = (const octave_int<T>& i)
+  {
+    ival = i.ival;
+    return *this;
+  }
+
+  ~octave_int (void) { }
+  
+  T value (void) const { return ival; }
+
+  bool operator ! (void) const { return ! ival; }
+
+  T operator + (void) const { return ival; }
+
+  T operator - (void) const
+  {
+    return std::numeric_limits<T>::is_signed ? -ival : 0;
+  }
+
+  operator double (void) const { return static_cast<double> (value ()); }
+
+  octave_int<T>& operator += (const octave_int<T>& x)
+  {
+    double t = static_cast<double> (value ());
+    double tx = static_cast<double> (x.value ());
+    ival = OCTAVE_INT_FIT_TO_RANGE (t + tx, T);
+    return *this;
+  }
+
+  octave_int<T>& operator -= (const octave_int<T>& x)
+  {
+    double t = static_cast<double> (value ());
+    double tx = static_cast<double> (x.value ());
+    ival = OCTAVE_INT_FIT_TO_RANGE (t - tx, T);
+    return *this;
+  }
+
+private:
+
+  T ival;
+};
+
+template <class T>
+std::ostream&
+operator << (std::ostream& os, const octave_int<T>& ival)
+{
+  os << ival.value ();
+  return os;
+}
+
+template <class T>
+std::istream&
+operator >> (std::istream& is, octave_int<T>& ival)
+{
+  T tmp = 0;
+  is >> tmp;
+  ival = tmp;
+  return is;
+}
+
+typedef octave_int<octave_int8_t> octave_int8;
+typedef octave_int<octave_int16_t> octave_int16;
+typedef octave_int<octave_int32_t> octave_int32;
+typedef octave_int<octave_int64_t> octave_int64;
+
+typedef octave_int<octave_uint8_t> octave_uint8;
+typedef octave_int<octave_uint16_t> octave_uint16;
+typedef octave_int<octave_uint32_t> octave_uint32;
+typedef octave_int<octave_uint64_t> octave_uint64;
+
+#define OCTAVE_INT_BIN_OP(OP) \
+ \
+  template <class T1, class T2> \
+  octave_int<typename octave_int_binop_traits<T1, T2>::TR> \
+  operator OP (const octave_int<T1>& x, const octave_int<T2>& y) \
+  { \
+    double tx = static_cast<double> (x.value ()); \
+    double ty = static_cast<double> (y.value ()); \
+    double r = tx OP ty; \
+    return OCTAVE_INT_FIT_TO_RANGE2 (r, T1, T2); \
+  } \
+
+OCTAVE_INT_BIN_OP(+)
+OCTAVE_INT_BIN_OP(-)
+OCTAVE_INT_BIN_OP(*)
+OCTAVE_INT_BIN_OP(/)
+
+#define OCTAVE_INT_CMP_OP(OP) \
+ \
+  template <class T1, class T2> \
+  bool \
+  operator OP (const octave_int<T1>& x, const octave_int<T2>& y) \
+  { \
+    return x.value () OP y.value (); \
+  } \
+
+OCTAVE_INT_CMP_OP (<)
+OCTAVE_INT_CMP_OP (<=)
+OCTAVE_INT_CMP_OP (>=)
+OCTAVE_INT_CMP_OP (>)
+OCTAVE_INT_CMP_OP (==)
+OCTAVE_INT_CMP_OP (!=)
+
+#undef OCTAVE_INT_TRAIT
+#undef OCTAVE_INT_BINOP_TRAIT
+#undef OCTAVE_INT_MIN_VAL
+#undef OCTAVE_INT_MAX_VAL
+#undef OCTAVE_INT_FIT_TO_RANGE
+#undef OCTAVE_INT_MIN_VAL2
+#undef OCTAVE_INT_MAX_VAL2
+#undef OCTAVE_INT_FIT_TO_RANGE2
+#undef OCTAVE_INT_BIN_OP
+#undef OCTAVE_INT_CMP_OP
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/uint16NDArray.cc b/liboctave/uint16NDArray.cc
new file mode 100644
--- /dev/null
+++ b/liboctave/uint16NDArray.cc
@@ -0,0 +1,59 @@
+// N-D Array  manipulations.
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "uint16NDArray.h"
+
+#include "intNDArray.cc"
+
+template class intNDArray<octave_uint16>;
+
+template
+std::ostream&
+operator << (std::ostream& os, const intNDArray<octave_uint16>& a);
+
+template
+std::istream&
+operator >> (std::istream& is, intNDArray<octave_uint16>& a);
+
+NDS_CMP_OPS (uint16NDArray, , octave_uint16, )
+NDS_BOOL_OPS (uint16NDArray, octave_uint16, octave_uint16 (0))
+
+SND_CMP_OPS (octave_uint16, , uint16NDArray, )
+SND_BOOL_OPS (octave_uint16, uint16NDArray, octave_uint16 (0))
+
+NDND_CMP_OPS (uint16NDArray, , uint16NDArray, )
+NDND_BOOL_OPS (uint16NDArray, uint16NDArray, octave_uint16 (0))
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/uint16NDArray.h b/liboctave/uint16NDArray.h
new file mode 100644
--- /dev/null
+++ b/liboctave/uint16NDArray.h
@@ -0,0 +1,53 @@
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if !defined (octave_uint16NDArray_h)
+#define octave_uint16NDArray_h 1
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma interface
+#endif
+
+#include "intNDArray.h"
+#include "mx-op-defs.h"
+#include "oct-inttypes.h"
+
+typedef intNDArray<octave_uint16> uint16NDArray;
+
+NDS_CMP_OP_DECLS (uint16NDArray, octave_uint16)
+NDS_BOOL_OP_DECLS (uint16NDArray, octave_uint16)
+
+SND_CMP_OP_DECLS (octave_uint16, uint16NDArray)
+SND_BOOL_OP_DECLS (octave_uint16, uint16NDArray)
+
+NDND_CMP_OP_DECLS (uint16NDArray, uint16NDArray)
+NDND_BOOL_OP_DECLS (uint16NDArray, uint16NDArray)
+
+MARRAY_FORWARD_DEFS (MArrayN, uint16NDArray, octave_uint16)
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/uint32NDArray.cc b/liboctave/uint32NDArray.cc
new file mode 100644
--- /dev/null
+++ b/liboctave/uint32NDArray.cc
@@ -0,0 +1,59 @@
+// N-D Array  manipulations.
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "uint32NDArray.h"
+
+#include "intNDArray.cc"
+
+template class intNDArray<octave_uint32>;
+
+template
+std::ostream&
+operator << (std::ostream& os, const intNDArray<octave_uint32>& a);
+
+template
+std::istream&
+operator >> (std::istream& is, intNDArray<octave_uint32>& a);
+
+NDS_CMP_OPS (uint32NDArray, , octave_uint32, )
+NDS_BOOL_OPS (uint32NDArray, octave_uint32, octave_uint32 (0))
+
+SND_CMP_OPS (octave_uint32, , uint32NDArray, )
+SND_BOOL_OPS (octave_uint32, uint32NDArray, octave_uint32 (0))
+
+NDND_CMP_OPS (uint32NDArray, , uint32NDArray, )
+NDND_BOOL_OPS (uint32NDArray, uint32NDArray, octave_uint32 (0))
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/uint32NDArray.h b/liboctave/uint32NDArray.h
new file mode 100644
--- /dev/null
+++ b/liboctave/uint32NDArray.h
@@ -0,0 +1,53 @@
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if !defined (octave_uint32NDArray_h)
+#define octave_uint32NDArray_h 1
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma interface
+#endif
+
+#include "intNDArray.h"
+#include "mx-op-defs.h"
+#include "oct-inttypes.h"
+
+typedef intNDArray<octave_uint32> uint32NDArray;
+
+NDS_CMP_OP_DECLS (uint32NDArray, octave_uint32)
+NDS_BOOL_OP_DECLS (uint32NDArray, octave_uint32)
+
+SND_CMP_OP_DECLS (octave_uint32, uint32NDArray)
+SND_BOOL_OP_DECLS (octave_uint32, uint32NDArray)
+
+NDND_CMP_OP_DECLS (uint32NDArray, uint32NDArray)
+NDND_BOOL_OP_DECLS (uint32NDArray, uint32NDArray)
+
+MARRAY_FORWARD_DEFS (MArrayN, uint32NDArray, octave_uint32)
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/uint64NDArray.cc b/liboctave/uint64NDArray.cc
new file mode 100644
--- /dev/null
+++ b/liboctave/uint64NDArray.cc
@@ -0,0 +1,59 @@
+// N-D Array  manipulations.
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "uint64NDArray.h"
+
+#include "intNDArray.cc"
+
+template class intNDArray<octave_uint64>;
+
+template
+std::ostream&
+operator << (std::ostream& os, const intNDArray<octave_uint64>& a);
+
+template
+std::istream&
+operator >> (std::istream& is, intNDArray<octave_uint64>& a);
+
+NDS_CMP_OPS (uint64NDArray, , octave_uint64, )
+NDS_BOOL_OPS (uint64NDArray, octave_uint64, octave_uint64 (0))
+
+SND_CMP_OPS (octave_uint64, , uint64NDArray, )
+SND_BOOL_OPS (octave_uint64, uint64NDArray, octave_uint64 (0))
+
+NDND_CMP_OPS (uint64NDArray, , uint64NDArray, )
+NDND_BOOL_OPS (uint64NDArray, uint64NDArray, octave_uint64 (0))
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/uint64NDArray.h b/liboctave/uint64NDArray.h
new file mode 100644
--- /dev/null
+++ b/liboctave/uint64NDArray.h
@@ -0,0 +1,53 @@
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if !defined (octave_uint64NDArray_h)
+#define octave_uint64NDArray_h 1
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma interface
+#endif
+
+#include "intNDArray.h"
+#include "mx-op-defs.h"
+#include "oct-inttypes.h"
+
+typedef intNDArray<octave_uint64> uint64NDArray;
+
+NDS_CMP_OP_DECLS (uint64NDArray, octave_uint64)
+NDS_BOOL_OP_DECLS (uint64NDArray, octave_uint64)
+
+SND_CMP_OP_DECLS (octave_uint64, uint64NDArray)
+SND_BOOL_OP_DECLS (octave_uint64, uint64NDArray)
+
+NDND_CMP_OP_DECLS (uint64NDArray, uint64NDArray)
+NDND_BOOL_OP_DECLS (uint64NDArray, uint64NDArray)
+
+MARRAY_FORWARD_DEFS (MArrayN, uint64NDArray, octave_uint64)
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/uint8NDArray.cc b/liboctave/uint8NDArray.cc
new file mode 100644
--- /dev/null
+++ b/liboctave/uint8NDArray.cc
@@ -0,0 +1,59 @@
+// N-D Array  manipulations.
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma implementation
+#endif
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "uint8NDArray.h"
+
+#include "intNDArray.cc"
+
+template class intNDArray<octave_uint8>;
+
+template
+std::ostream&
+operator << (std::ostream& os, const intNDArray<octave_uint8>& a);
+
+template
+std::istream&
+operator >> (std::istream& is, intNDArray<octave_uint8>& a);
+
+NDS_CMP_OPS (uint8NDArray, , octave_uint8, )
+NDS_BOOL_OPS (uint8NDArray, octave_uint8, octave_uint8 (0))
+
+SND_CMP_OPS (octave_uint8, , uint8NDArray, )
+SND_BOOL_OPS (octave_uint8, uint8NDArray, octave_uint8 (0))
+
+NDND_CMP_OPS (uint8NDArray, , uint8NDArray, )
+NDND_BOOL_OPS (uint8NDArray, uint8NDArray, octave_uint8 (0))
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
diff --git a/liboctave/uint8NDArray.h b/liboctave/uint8NDArray.h
new file mode 100644
--- /dev/null
+++ b/liboctave/uint8NDArray.h
@@ -0,0 +1,53 @@
+/*
+
+Copyright (C) 2004 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+
+*/
+
+#if !defined (octave_uint8NDArray_h)
+#define octave_uint8NDArray_h 1
+
+#if defined (__GNUG__) && defined (USE_PRAGMA_INTERFACE_IMPLEMENTATION)
+#pragma interface
+#endif
+
+#include "intNDArray.h"
+#include "mx-op-defs.h"
+#include "oct-inttypes.h"
+
+typedef intNDArray<octave_uint8> uint8NDArray;
+
+NDS_CMP_OP_DECLS (uint8NDArray, octave_uint8)
+NDS_BOOL_OP_DECLS (uint8NDArray, octave_uint8)
+
+SND_CMP_OP_DECLS (octave_uint8, uint8NDArray)
+SND_BOOL_OP_DECLS (octave_uint8, uint8NDArray)
+
+NDND_CMP_OP_DECLS (uint8NDArray, uint8NDArray)
+NDND_BOOL_OP_DECLS (uint8NDArray, uint8NDArray)
+
+MARRAY_FORWARD_DEFS (MArrayN, uint8NDArray, octave_uint8)
+
+#endif
+
+/*
+;;; Local Variables: ***
+;;; mode: C++ ***
+;;; End: ***
+*/
