# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1497036843 14400
#      Fri Jun 09 15:34:03 2017 -0400
# Node ID b6144e6dda9ea3ce075237d2cb55b04762426dd2
# Parent  10248986f14c1f7de2e5051de59187e04d676c96
allow bugs to be tagged as fixed in test suite

* test.m: Recognize <*BUG-ID> as a fixed bug in tests.  If they fail,
count them separately as regressions.
* __run_test_suite__.m: Report regressions separately.

diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -806,18 +806,21 @@ dimensionality as the other array.
 %!                 fun (f_type (x), f_type (y)));
 %!         assert (bsxfun (fun, f_type(y), f_type(x)), ...
 %!                 fun (f_type (y), f_type (x)));
 %!     endfor
 %!   endfor
 %! endfor
 
 ## Automatic broadcasting with zero length dimensions
-%!assert <47085> ([1 2 3] .+ zeros (0, 3), zeros (0, 3))
-%!assert <47085> (rand (3, 3, 1) .+ rand (3, 3, 0), zeros (3, 3, 0))
+%!assert <*47085> ([1 2 3] .+ zeros (0, 3), zeros (0, 3))
+%!assert <*47085> ([1 2 3] .+ zeros (0, 3), zeros (0, 3))
+%!assert <*47085> (rand (3, 3, 1) .+ rand (3, 3, 0), zeros (3, 3, 0))
+%!assert <*47085> (rand (3, 3, 1) .+ rand (3, 3, 0), zeros (3, 3, 0))
 
 ## In-place broadcasting with zero length dimensions
-%!test <47085>
+%!test <*47085>
+%!test <*47085>
 %! a = zeros (0, 3);
 %! a .+= [1 2 3];
 %! assert (a, zeros (0, 3));
 
 */
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -974,20 +974,24 @@ v = cellfun (@@det, a); # faster
 %!assert (cellfun (@factorial,{-1,3},"ErrorHandler",@(x,y) NaN), [NaN,6])
 %!assert (cellfun (@(x) x(2),{[1],[1,2]},"ErrorHandler",@(x,y) NaN), [NaN,2])
 %!test
 %! [a,b,c] = cellfun (@fileparts, {fullfile("a","b","c.d"), fullfile("e","f","g.h")}, "UniformOutput", false);
 %! assert (a, {fullfile("a","b"), fullfile("e","f")});
 %! assert (b, {"c", "g"});
 %! assert (c, {".d", ".h"});
 
-%!assert <40467> (cellfun (@isreal, {1 inf nan []}), [true, true, true, true])
-%!assert <40467> (cellfun (@isreal, {1 inf nan []}, "UniformOutput", false), {true, true, true, true})
-%!assert <40467> (cellfun (@iscomplex, {1 inf nan []}), [false, false, false, false])
-%!assert <40467> (cellfun (@iscomplex, {1 inf nan []}, "UniformOutput", false), {false, false, false, false})
+%!assert <*40467> (cellfun (@isreal, {1 inf nan []}), [true, true, true, true])
+%!assert <*40467> (cellfun (@isreal, {1 inf nan []}), [true, true, true, true])
+%!assert <*40467> (cellfun (@isreal, {1 inf nan []}, "UniformOutput", false), {true, true, true, true})
+%!assert <*40467> (cellfun (@isreal, {1 inf nan []}, "UniformOutput", false), {true, true, true, true})
+%!assert <*40467> (cellfun (@iscomplex, {1 inf nan []}), [false, false, false, false])
+%!assert <*40467> (cellfun (@iscomplex, {1 inf nan []}), [false, false, false, false])
+%!assert <*40467> (cellfun (@iscomplex, {1 inf nan []}, "UniformOutput", false), {false, false, false, false})
+%!assert <*40467> (cellfun (@iscomplex, {1 inf nan []}, "UniformOutput", false), {false, false, false, false})
 
 %!error cellfun (1)
 %!error cellfun ("isclass", 1)
 %!error cellfun ("size", 1)
 %!error cellfun (@sin, {[]}, "BadParam", false)
 %!error cellfun (@sin, {[]}, "UniformOuput")
 %!error cellfun (@sin, {[]}, "ErrorHandler")
 */
diff --git a/libinterp/corefcn/conv2.cc b/libinterp/corefcn/conv2.cc
--- a/libinterp/corefcn/conv2.cc
+++ b/libinterp/corefcn/conv2.cc
@@ -250,23 +250,27 @@ When the third argument is a matrix, ret
 %!assert (conv2 (A,B, "same"), C(3:5,3:6))
 %!assert (conv2 (A,B, "valid"), zeros (0, 0))
 %!assert (size (conv2 (B,A, "valid")), [3 2])
 
 ## Clear shared variables so they are not reported for tests below
 %!shared
 
 ## Test cases from Bug #34893
-%!assert <34893> (conv2 ([1:5;1:5], [1:2], "same"),
+%!assert <*34893> (conv2 ([1:5;1:5], [1:2], "same"),
+%!assert <*34893> (conv2 ([1:5;1:5], [1:2], "same"),
 %!                [4 7 10 13 10; 4 7 10 13 10])
-%!assert <34893> (conv2 ([1:5;1:5]', [1:2]', "same"),
+%!assert <*34893> (conv2 ([1:5;1:5]', [1:2]', "same"),
+%!assert <*34893> (conv2 ([1:5;1:5]', [1:2]', "same"),
 %!                [4 7 10 13 10; 4 7 10 13 10]')
-%!assert <34893> (conv2 ([1:5;1:5], [1:2], "valid"),
+%!assert <*34893> (conv2 ([1:5;1:5], [1:2], "valid"),
+%!assert <*34893> (conv2 ([1:5;1:5], [1:2], "valid"),
 %!                [4 7 10 13; 4 7 10 13])
-%!assert <34893> (conv2 ([1:5;1:5]', [1:2]', "valid"),
+%!assert <*34893> (conv2 ([1:5;1:5]', [1:2]', "valid"),
+%!assert <*34893> (conv2 ([1:5;1:5]', [1:2]', "valid"),
 %!                [4 7 10 13; 4 7 10 13]')
 
 %!test
 %! rand ("seed", 42);
 %! x = rand (100);
 %! y = ones (5);
 %! A = conv2 (x, y)(5:end-4,5:end-4);
 %! B = conv2 (x, y, "valid");
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -554,17 +554,18 @@ and @var{e} is an integer.  If
 %! assert (f, [0,-0.5; 0.5,-0.5; Inf,-Inf]);
 %! assert (e(1:2,:), [0,1;2,3]);
 
 %!test
 %! [f, e] = log2 (complex (zeros (3, 2), [0,-1; 2,-4; Inf,-Inf]));
 %! assert (f, complex (zeros (3, 2), [0,-0.5; 0.5,-0.5; Inf,-Inf]));
 %! assert (e(1:2,:), [0,1; 2,3]);
 
-%!assert <42583> (all (log2 (pow2 (-1074:1023)) == -1074:1023))
+%!assert <*42583> (all (log2 (pow2 (-1074:1023)) == -1074:1023))
+%!assert <*42583> (all (log2 (pow2 (-1074:1023)) == -1074:1023))
 */
 
 DEFUN (rem, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} rem (@var{x}, @var{y})
 Return the remainder of the division @code{@var{x} / @var{y}}.
 
 The remainder is computed using the expression
@@ -720,20 +721,23 @@ periodic, @code{mod} is a better choice.
 %! y = rem (sparse ([11 11 11 11]), xs);
 %! assert (nnz (y), 3);
 %! assert (y, sparse (rem (11, 0:3)));
 %!test
 %! y = rem (sparse ([0 0 0 0]), xs);
 %! assert (nnz (y), 1);
 %! assert (y, sparse ([NaN 0 0 0]));
 
-%!assert <45587> (signbit (rem (-0, 1)))
-%!assert <45587> (! signbit (rem (0, 1)))
-
-%!assert <42627> (rem (0.94, 0.01), 0.0)
+%!assert <*45587> (signbit (rem (-0, 1)))
+%!assert <*45587> (signbit (rem (-0, 1)))
+%!assert <*45587> (! signbit (rem (0, 1)))
+%!assert <*45587> (! signbit (rem (0, 1)))
+
+%!assert <*42627> (rem (0.94, 0.01), 0.0)
+%!assert <*42627> (rem (0.94, 0.01), 0.0)
 
 %!error rem (uint (8), int8 (5))
 %!error rem (uint8 ([1, 2]), uint8 ([3, 4, 5]))
 %!error rem ()
 %!error rem (1, 2, 3)
 %!error rem ([1, 2], [3, 4, 5])
 %!error rem (i, 1)
 */
@@ -899,20 +903,23 @@ negative numbers or when the values are 
 %!assert (mod (uint8 (5), 4), uint8 (1))
 %!assert (mod (5, uint8 (4)), uint8 (1))
 %!assert (mod (uint8 ([1:5]), 4), uint8 ([1,2,3,0,1]))
 
 ## non-integer real numbers
 %!assert (mod (2.1, 0.1), 0)
 %!assert (mod (2.1, 0.2), 0.1, eps)
 
-%!assert <45587> (signbit (mod (-0, 0)))
-%!assert <45587> (! signbit (mod (0, -0)))
-
-%!assert <42627> (mod (0.94, 0.01), 0.0)
+%!assert <*45587> (signbit (mod (-0, 0)))
+%!assert <*45587> (signbit (mod (-0, 0)))
+%!assert <*45587> (! signbit (mod (0, -0)))
+%!assert <*45587> (! signbit (mod (0, -0)))
+
+%!assert <*42627> (mod (0.94, 0.01), 0.0)
+%!assert <*42627> (mod (0.94, 0.01), 0.0)
 */
 
 #define DATA_REDUCTION(FCN)                                             \
                                                                         \
   int nargin = args.length ();                                          \
                                                                         \
   if (nargin < 1 || nargin > 2)                                         \
     print_usage ();                                                     \
@@ -1261,19 +1268,22 @@ Given a matrix argument, instead of a ve
 %!assert (diag (int8 ([1; 2; 3]), 2), int8 ([0, 0, 1, 0, 0; 0, 0, 0, 2, 0; 0, 0, 0, 0, 3; 0, 0, 0, 0, 0; 0, 0, 0, 0, 0]))
 %!assert (diag (int8 ([1; 2; 3]),-1), int8 ([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]))
 %!assert (diag (int8 ([1; 2; 3]),-2), int8 ([0, 0, 0, 0, 0; 0, 0, 0, 0, 0; 1, 0, 0, 0, 0; 0, 2, 0, 0, 0; 0, 0, 3, 0, 0]))
 
 %!assert (diag (int8 ([1, 0, 0; 0, 2, 0; 0, 0, 3])), int8 ([1; 2; 3]))
 %!assert (diag (int8 ([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]), 1), int8 ([1; 2; 3]))
 %!assert (diag (int8 ([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]), -1), int8 ([1; 2; 3]))
 
-%!assert <37411> (diag (diag ([5, 2, 3])(:,1)), diag([5 0 0 ]))
-%!assert <37411> (diag (diag ([5, 2, 3])(:,1), 2),  [0 0 5 0 0; zeros(4, 5)])
-%!assert <37411> (diag (diag ([5, 2, 3])(:,1), -2), [[0 0 5 0 0]', zeros(5, 4)])
+%!assert <*37411> (diag (diag ([5, 2, 3])(:,1)), diag([5 0 0 ]))
+%!assert <*37411> (diag (diag ([5, 2, 3])(:,1)), diag([5 0 0 ]))
+%!assert <*37411> (diag (diag ([5, 2, 3])(:,1), 2),  [0 0 5 0 0; zeros(4, 5)])
+%!assert <*37411> (diag (diag ([5, 2, 3])(:,1), 2),  [0 0 5 0 0; zeros(4, 5)])
+%!assert <*37411> (diag (diag ([5, 2, 3])(:,1), -2), [[0 0 5 0 0]', zeros(5, 4)])
+%!assert <*37411> (diag (diag ([5, 2, 3])(:,1), -2), [[0 0 5 0 0]', zeros(5, 4)])
 
 ## Test non-square size
 %!assert (diag ([1,2,3], 6, 3), [1 0 0; 0 2 0; 0 0 3; 0 0 0; 0 0 0; 0 0 0])
 %!assert (diag (1, 2, 3), [1,0,0; 0,0,0])
 %!assert (diag ({1}, 2, 3), {1,[],[]; [],[],[]})
 %!assert (diag ({1,2}, 3, 4), {1,[],[],[]; [],2,[],[]; [],[],[],[]})
 
 ## Test out-of-range diagonals
@@ -2197,17 +2207,18 @@ new matrices.  For example:
 %! assert (class (horzcat ("a", cell (1))), "cell");
 %! assert (class (horzcat ("a", true)), "char");
 %! assert (class (horzcat ("a", "a")), "char");
 
 %!assert (class (horzcat (cell (1), struct ("foo", "bar"))), "cell")
 
 %!error horzcat (struct ("foo", "bar"), cell (1))
 
-%!test <39041> assert (class (horzcat (cell(0), struct())), "cell")
+%!test <*39041> assert (class (horzcat (cell(0), struct())), "cell")
+%!test <*39041> assert (class (horzcat (cell(0), struct())), "cell")
 %!test <51086> assert (class (horzcat (struct(), cell(0))), "struct")
 */
 
 DEFUN (vertcat, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} vertcat (@var{array1}, @var{array2}, @dots{}, @var{arrayN})
 Return the vertical concatenation of N-D array objects, @var{array1},
 @var{array2}, @dots{}, @var{arrayN} along dimension 1.
@@ -2421,17 +2432,18 @@ cat (4, ones (2, 2), zeros (2, 2))
 
 %!assert (cat (3, [], [], 1, 2), cat (3, 1, 2))
 %!assert (cat (3, [], [], [1,2;3,4]), [1,2;3,4])
 %!assert (cat (4, [], [], [1,2;3,4]), [1,2;3,4])
 
 %!assert ([zeros(3,2,2); ones(1,2,2)], repmat ([0;0;0;1],[1,2,2]))
 %!assert ([zeros(3,2,2); ones(1,2,2)], vertcat (zeros (3,2,2), ones (1,2,2)))
 
-%!test <49759>
+%!test <*49759>
+%!test <*49759>
 %! A = [];
 %! B = {1; 2};
 %! assert (cat (1, A, B), {1; 2});
 %! assert (cat (2, A, B), {1; 2});
 
 %!error <dimension mismatch> cat (3, cat (3, [], []), [1,2;3,4])
 %!error <dimension mismatch> cat (3, zeros (0, 0, 2), [1,2;3,4])
 */
@@ -4223,17 +4235,18 @@ val = ones (m,n, "uint8")
 %!assert (size (ones (3, 4, 5, "int8")), [3, 4, 5])
 */
 
 /*
 ## Tests for bug #47298
 ## Matlab requires the size to be a row vector.  In that logic, it supports
 ## n to be a 1x0 vector (returns 0x0) but not a 0x1 vector.  Octave supports
 ## any vector and therefore must support 0x1, 1x0, and 0x0x1 (but not 0x1x1).
-%!test <47298>
+%!test <*47298>
+%!test <*47298>
 %! funcs = {@zeros, @ones, @inf, @nan, @NA, @i, @pi, @e};
 %! for idx = 1:numel (funcs)
 %!   func = funcs{idx};
 %!   assert (func (zeros (1, 0)), zeros (0, 0));
 %!   assert (func (zeros (0, 1)), zeros (0, 0));
 %!   assert (func (zeros (0, 1, 1)), zeros (0, 0));
 %!   fail ([func2str(func) " ([])"]);
 %!   fail ([func2str(func) " (zeros (0, 0, 1))"]);
diff --git a/libinterp/corefcn/dlmread.cc b/libinterp/corefcn/dlmread.cc
--- a/libinterp/corefcn/dlmread.cc
+++ b/libinterp/corefcn/dlmread.cc
@@ -546,33 +546,35 @@ such as text, are also replaced by the @
 %!   assert (dlmread (file, ",", 1, 0), [4 + 4i, 5, 6; 7, 8, 9; 10, 11, 12]);
 %!   assert (dlmread (file, ",", "A2.."), [4 + 4i, 5, 6; 7, 8, 9; 10, 11, 12]);
 %!   assert (dlmread (file, ",", 10, 0), []);
 %!   assert (dlmread (file, ",", 0, 10), []);
 %! unwind_protect_cleanup
 %!   unlink (file);
 %! end_unwind_protect
 
-%!test <42025>
+%!test <*42025>
+%!test <*42025>
 %! file = tempname ();
 %! unwind_protect
 %!   fid = fopen (file, "wt");
 %!   fwrite (fid, "    \n 1 2\n11 22\n ");
 %!   fclose (fid);
 %!
 %!   assert (dlmread (file), [1, 2; 11, 22]);
 %!   assert (dlmread (file, " "), [ 0,  0, 0, 0
 %!                                  0,  1, 2, 0
 %!                                 11, 22, 0, 0
 %!                                  0,  0, 0, 0]);
 %! unwind_protect_cleanup
 %!   unlink (file);
 %! end_unwind_protect
 
-%!test <50589>
+%!test <*50589>
+%!test <*50589>
 %! file = tempname ();
 %! unwind_protect
 %!   fid = fopen (file, "wt");
 %!   fwrite (fid, "1;2;3\n");
 %!   fwrite (fid, "1i;2I;3j;4J\n");
 %!   fwrite (fid, "4;5;6\n");
 %!   fwrite (fid, "-4i;+5I;-6j;+7J\n");
 %!   fclose (fid);
diff --git a/libinterp/corefcn/ellipj.cc b/libinterp/corefcn/ellipj.cc
--- a/libinterp/corefcn/ellipj.cc
+++ b/libinterp/corefcn/ellipj.cc
@@ -811,17 +811,18 @@ and 16.15), Dover, 1965.
 %!       0.9840560289645665155;
 %!       0.9307281387786906491;
 %!       0.8868188839812167635 ];
 %! [sn,cn,dn] = ellipj (u,m);
 %! assert (sn, S, 8*eps);
 %! assert (cn, C, 8*eps);
 %! assert (dn, D, 8*eps);
 
-%!test <43344>
+%!test <*43344>
+%!test <*43344>
 %! ## Test continuity of dn when cn is near zero
 %! m = 0.5;
 %! u = ellipke (0.5);
 %! x = [-1e-3, -1e-12, 0, 1e-12, 1e-3];
 %! [~, ~, dn] = ellipj (u + x, m);
 %! D = 1/sqrt (2) * ones (size (x));
 %! assert (dn, D, 1e-6);
 
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -1746,17 +1746,18 @@ disable escape sequence expansion use a 
       if (nargout > 0)
         retval = prev_msg;
     }
 
   return retval;
 }
 
 /*
-%!test <45753>
+%!test <*45753>
+%!test <*45753>
 %! warning ("error");
 %! assert (! isempty (help ("warning")));
 */
 
 octave_value_list
 set_warning_state (const std::string& id, const std::string& state)
 {
   octave_value_list args;
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -1756,87 +1756,93 @@ as the name of the function when reporti
 
 ## FIXME: This test fails (4/14/16)
 ## Test incomplete first data line
 %!#test
 %! R = textscan (['Empty1' char(10)], 'Empty%d %f');
 %! assert (R{1}, int32 (1));
 %! assert (isempty (R{2}), true);
 
-%!test <37023>
+%!test <*37023>
+%!test <*37023>
 %! data = textscan ("   1. 1 \n 2 3\n", '%f %f');
 %! assert (data{1}, [1; 2], 1e-15);
 %! assert (data{2}, [1; 3], 1e-15);
 
 ## Whitespace test using delimiter ";"
-%!test <37333>
+%!test <*37333>
+%!test <*37333>
 %! tc{1, 1} = "C:/code;";
 %! tc{1, end+1} = "C:/code/meas;";
 %! tc{1, end+1} = " C:/code/sim;";
 %! tc{1, end+1} = "C:/code/utils;";
 %! string = [tc{:}];
 %! c = textscan (string, "%s", "delimiter", ";");
 %! for k = 1:max (numel (c{1}), numel (tc))
 %!   lh = c{1}{k};
 %!   rh = tc{k};
 %!   rh(rh == ";") = "";
 %!   rh = strtrim (rh);
 %!   assert (strcmp (lh, rh));
 %! endfor
 
 ## Whitespace test, adding multipleDelimsAsOne true arg
-%!test <37333>
+%!test <*37333>
+%!test <*37333>
 %! tc{1, 1} = "C:/code;";
 %! tc{1, end+1} = " C:/code/meas;";
 %! tc{1, end+1} = "C:/code/sim;;";
 %! tc{1, end+1} = "C:/code/utils;";
 %! string = [tc{:}];
 %! c = textscan (string, "%s", "delimiter", ";", "multipleDelimsAsOne", 1);
 %! for k = 1:max (numel (c{1}), numel (tc))
 %!   lh = c{1}{k};
 %!   rh = tc{k};
 %!   rh(rh == ";") = "";
 %!   rh = strtrim (rh);
 %!   assert (strcmp (lh, rh));
 %! endfor
 
 ## Whitespace test (bug #37333), adding multipleDelimsAsOne false arg
-%!test <37333>
+%!test <*37333>
+%!test <*37333>
 %! tc{1, 1} = "C:/code;";
 %! tc{1, end+1} = " C:/code/meas;";
 %! tc{1, end+1} = "C:/code/sim;;";
 %! tc{1, end+1} = "";
 %! tc{1, end+1} = "C:/code/utils;";
 %! string = [tc{:}];
 %! c = textscan (string, "%s", "delimiter", ";", "multipleDelimsAsOne", 0);
 %! for k = 1:max (numel (c{1}), numel (tc))
 %!   lh = c{1}{k};
 %!   rh = tc{k};
 %!   rh(rh == ";") = "";
 %!   rh = strtrim (rh);
 %!   assert (strcmp (lh, rh));
 %! endfor
 
 ## Whitespace test (bug #37333) whitespace "" arg
-%!test <37333>
+%!test <*37333>
+%!test <*37333>
 %! tc{1, 1} = "C:/code;";
 %! tc{1, end+1} = " C:/code/meas;";
 %! tc{1, end+1} = "C:/code/sim;";
 %! tc{1, end+1} = "C:/code/utils;";
 %! string = [tc{:}];
 %! c = textscan (string, "%s", "delimiter", ";", "whitespace", "");
 %! for k = 1:max (numel (c{1}), numel (tc))
 %!   lh = c{1}{k};
 %!   rh = tc{k};
 %!   rh(rh == ";") = "";
 %!   assert (strcmp (lh, rh));
 %! endfor
 
 ## Whitespace test (bug #37333), whitespace " " arg
-%!test <37333>
+%!test <*37333>
+%!test <*37333>
 %! tc{1, 1} = "C:/code;";
 %! tc{1, end+1} = " C:/code/meas;";
 %! tc{1, end+1} = "C:/code/sim;";
 %! tc{1, end+1} = "C:/code/utils;";
 %! string = [tc{:}];
 %! c = textscan (string, "%s", "delimiter", ";", "whitespace", " ");
 %! for k = 1:max (numel (c{1}), numel (tc))
 %!   lh = c{1}{k};
@@ -1944,29 +1950,33 @@ as the name of the function when reporti
 %! msg1 = "textscan: EndOfLine must be at most one character or '\\r\\n'";
 %! try
 %!   C = textscan (fid, "%f", "EndOfLine", 33);
 %! end_try_catch;
 %! fclose (fid);
 %! unlink (f);
 %! assert (msg1, lasterr);
 
-%!assert <41824> (textscan ("123", "", "whitespace", " "){:}, 123);
+%!assert <*41824> (textscan ("123", "", "whitespace", " "){:}, 123);
+%!assert <*41824> (textscan ("123", "", "whitespace", " "){:}, 123);
 
 ## just test supplied emptyvalue
-%!assert <42343> (textscan (",NaN", "", "delimiter", "," ,"emptyValue" ,Inf),
+%!assert <*42343> (textscan (",NaN", "", "delimiter", "," ,"emptyValue" ,Inf),
+%!assert <*42343> (textscan (",NaN", "", "delimiter", "," ,"emptyValue" ,Inf),
 %!                {Inf, NaN})
 
 ## test padding with supplied emptyvalue
-%!test <42343>
+%!test <*42343>
+%!test <*42343>
 %! c = textscan (",1,,4\nInf,  ,NaN\n", "", "delimiter", ",",
 %!               "emptyvalue", -10);
 %! assert (cell2mat (c), [-10, 1, -10, 4; Inf, -10, NaN, -10]);
 
-%!test <42528>
+%!test <*42528>
+%!test <*42528>
 %! assert (textscan ("1i", ""){1},  0+1i);
 %! C = textscan ("3, 2-4i, NaN\n -i, 1, 23.4+2.2i\n 1+1 1+1j", "",
 %!               "delimiter", ",");
 %! assert (cell2mat (C), [3+0i, 2-4i, NaN+0i; 0-i,  1+0i, 23.4+2.2i; 1 1 1+1i]);
 
 %!test
 %! ## TreatAsEmpty
 %! C = textscan ("1,2,3,NN,5,6\n", "%d%d%d%f", "delimiter", ",",
@@ -1987,17 +1997,18 @@ as the name of the function when reporti
 ## Single-quoted escape sequences
 %!test
 %! str = "11\t12\t13\r21\t22\t23";
 %! c = textscan (str, "", "delimiter", '\t', "EndOfLine", '\r');
 %! assert (c{1}', [11, 21]);
 %! assert (c{2}', [12, 22]);
 %! assert (c{3}', [13, 23]);
 
-%!test <44750>
+%!test <*44750>
+%!test <*44750>
 %! c = textscan ("/home/foo/", "%s", "delimiter", "/",
 %!               "MultipleDelimsAsOne", 1);
 %! assert (c{1}, {"home"; "foo"});
 
 ## FIXME: Test still fails (4/13/2016).
 ## Allow cuddling %sliteral, but warn it is ambiguous
 %!#test
 %! C = textscan ("abcxyz51\nxyz83\n##xyz101", "%s xyz %d");
@@ -2009,17 +2020,18 @@ as the name of the function when reporti
 
 ## Test for false positives in check for non-supported format specifiers
 %!test
 %! c = textscan ("Total: 32.5 % (of cm values)",
 %!               "Total: %f %% (of cm values)");
 %! assert (c{1}, 32.5, 1e-5);
 
 ## Test various forms of string format specifiers
-%!test <45712>
+%!test <*45712>
+%!test <*45712>
 %! str = "14 :1 z:2 z:3 z:5 z:11";
 %! C = textscan (str, "%f %s %*s %3s %*3s %f", "delimiter", ":");
 %! assert (C, {14, {"1 z"}, {"3 z"}, 11});
 
 ## Bit width, fixed width conversion specifiers
 %!test
 %! str2 = "123456789012345 ";
 %! str2 = [str2 str2 str2 str2 str2 str2 str2 str2];
@@ -2098,17 +2110,18 @@ as the name of the function when reporti
 ## [..] and [^..] containing delimiters
 %!test
 %! cr = "ab cd efguv wx1Any\na ce gx yz2Trailing\n   3Junk";
 %! C = textscan (cr, "%[ abcdefg] %*[^0123456789] %s", "delimiter", " \n",
 %!                   "whitespace", "");
 %! assert (C{1}, {"ab cd efg"; "a ce g"; "   "});
 %! assert (C{2}, {"1Any"; "2Trailing"; "3Junk"});
 
-%!assert <36464> (textscan ("1 2 3 4 5 6", "%*n%n%*[^\n]"){1}, 2);
+%!assert <*36464> (textscan ("1 2 3 4 5 6", "%*n%n%*[^\n]"){1}, 2);
+%!assert <*36464> (textscan ("1 2 3 4 5 6", "%*n%n%*[^\n]"){1}, 2);
 
 ## test %[]] and %[^]]
 %!test
 %! assert (textscan ("345]", "%*[123456]%[]]"){1}{1}, "]");
 %! assert (textscan ("345]", "%*[^]]%s"){1}{1}, "]");
 
 ## Test that "-i" checks the next two characters
 %!test
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -7225,17 +7225,18 @@ axes::properties::calc_ticks_and_lims (a
       for (int i_above = 0; i_above < n_above; i_above++)
         tmp_mticks2(n_below+n_between+i_above) = tmp_ticks(n_ticks-1)
                                                  + (i_above + 1) * d_above;
       mticks = tmp_mticks2;
     }
 }
 
 /*
-%!test <45356>
+%!test <*45356>
+%!test <*45356>
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   plot (1:10);
 %!   xlim ([4.75, 8.5]);
 %!   tics = get (gca, "xtick");
 %!   assert (tics, [5 6 7 8]);
 %! unwind_protect_cleanup
 %!   close (hf);
diff --git a/libinterp/corefcn/hash.cc b/libinterp/corefcn/hash.cc
--- a/libinterp/corefcn/hash.cc
+++ b/libinterp/corefcn/hash.cc
@@ -194,28 +194,36 @@ hash ("md5", fileread (file));
 %!        ["38b060a751ac96384cd9327eb1b1e36a21fdb71114be07434c0cc", ...
 %!         "7bf63f6e1da274edebfe76f65fbd51ad2f14898b95b"]);
 %!assert (hash ("sha512", ""),
 %!        ["cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a", ...
 %!         "921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47", ...
 %!         "417a81a538327af927da3e"]);
 
 ## Test special character behavior
-%!assert <31689> (hash ("md2", "abc\0"), "5a636d615002a7874ac1c9e9a43361f7")
-%!assert <31689> (hash ("md4", "abc\0"), "0ee5201897ecb206c4eaba1d2da5224d")
-%!assert <31689> (hash ("md5", "abc\0"), "147a664a2ca9410911e61986d3f0d52a")
-%!assert <31689> (hash ("sha1", "abc\0"), "686483805ac47ca14e03514f7481a7973b401762")
-%!assert <31689> (hash ("sha224", "abc\0"),
+%!assert <*31689> (hash ("md2", "abc\0"), "5a636d615002a7874ac1c9e9a43361f7")
+%!assert <*31689> (hash ("md2", "abc\0"), "5a636d615002a7874ac1c9e9a43361f7")
+%!assert <*31689> (hash ("md4", "abc\0"), "0ee5201897ecb206c4eaba1d2da5224d")
+%!assert <*31689> (hash ("md4", "abc\0"), "0ee5201897ecb206c4eaba1d2da5224d")
+%!assert <*31689> (hash ("md5", "abc\0"), "147a664a2ca9410911e61986d3f0d52a")
+%!assert <*31689> (hash ("md5", "abc\0"), "147a664a2ca9410911e61986d3f0d52a")
+%!assert <*31689> (hash ("sha1", "abc\0"), "686483805ac47ca14e03514f7481a7973b401762")
+%!assert <*31689> (hash ("sha1", "abc\0"), "686483805ac47ca14e03514f7481a7973b401762")
+%!assert <*31689> (hash ("sha224", "abc\0"),
+%!assert <*31689> (hash ("sha224", "abc\0"),
 %!        "fbc8e47920e108bb1d0b631d18b36ae9b1549d28362aa15ebe960cfb");
-%!assert <31689> (hash ("sha256", "abc\0"),
+%!assert <*31689> (hash ("sha256", "abc\0"),
+%!assert <*31689> (hash ("sha256", "abc\0"),
 %!        "dc1114cd074914bd872cc1f9a23ec910ea2203bc79779ab2e17da25782a624fc");
-%!assert <31689> (hash ("sha384", "abc\0"),
+%!assert <*31689> (hash ("sha384", "abc\0"),
+%!assert <*31689> (hash ("sha384", "abc\0"),
 %!        ["eba81f2dfba4ec60d3f786c89d91b08e6c0b63d55986874378e385", ...
 %!         "e6fac587cce7a520ca9437290fe626cbf75c855e17"]);
-%!assert <31689> (hash ("sha512", "abc\0"),
+%!assert <*31689> (hash ("sha512", "abc\0"),
+%!assert <*31689> (hash ("sha512", "abc\0"),
 %!        ["7ce05eda233e545a2d5c626862a5ddaafb09b9d8ec3bec08aa458b", ...
 %!         "7c9e7d939d84a57d5a20d8a9002983aabae2457b19c50ba326bf5b", ...
 %!         "081f75b41342f42c3383"]);
 
 ## Test equivalence to deprecated md5sum offering file hashing
 %!test
 %! tfile = tempname ();
 %! fid = fopen (tfile, "wb");
diff --git a/libinterp/corefcn/mappers.cc b/libinterp/corefcn/mappers.cc
--- a/libinterp/corefcn/mappers.cc
+++ b/libinterp/corefcn/mappers.cc
@@ -369,17 +369,18 @@ Compute the inverse tangent in radians f
 %! assert (atan (x), v, sqrt (eps));
 
 %!test
 %! v = single ([0, pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6, 0]);
 %! x = single ([0, rt3/3, 1, rt3, -rt3, -1, -rt3/3, 0]);
 %! assert (atan (x), v, sqrt (eps ("single")));
 
 ## Test large magnitude arguments (bug #44310, bug #45507)
-%!test <44310>
+%!test <*44310>
+%!test <*44310>
 %! x = [1, -1, i, -i] .* 1e150;
 %! v = [pi/2, -pi/2, pi/2, -pi/2];
 %! assert (real (atan (x)), v);
 %! assert (imag (atan (x)), [0, 0, 0, 0], eps);
 
 %!error atan ()
 %!error atan (1, 2)
 */
@@ -404,17 +405,18 @@ Compute the inverse hyperbolic tangent f
 %! assert (atanh (x), v, sqrt (eps));
 
 %!test
 %! v = single ([0, 0]);
 %! x = single ([0, 0]);
 %! assert (atanh (x), v, sqrt (eps ("single")));
 
 ## Test large magnitude arguments (bug #44310, bug #45507)
-%!test <44310>
+%!test <*44310>
+%!test <*44310>
 %! x = [1, -1, i, -i] .* 1e150;
 %! v = [pi/2, pi/2, pi/2, -pi/2];
 %! assert (imag (atanh (x)), v);
 %! assert (real (atanh (x)), [0, 0, 0, 0], eps);
 
 %!error atanh ()
 %!error atanh (1, 2)
 */
diff --git a/libinterp/corefcn/max.cc b/libinterp/corefcn/max.cc
--- a/libinterp/corefcn/max.cc
+++ b/libinterp/corefcn/max.cc
@@ -860,18 +860,20 @@ the first index of the maximum value(s).
 %!test
 %! x = sparse ([1, 2, 3, 4]);  y = fliplr (x);
 %! assert (max (x, y), sparse ([4 3 3 4]));
 %! assert (max (x, 3), sparse ([3 3 3 4]));
 %! assert (max (2, x), sparse ([2 2 3 4]));
 %! assert (max (x, 2.1i), sparse ([2.1i 2.1i 3 4]));
 
 ## Test for bug #40743
-%!assert <40743> (max (zeros (1,0), ones (1,1)), zeros (1,0))
-%!assert <40743> (max (sparse (zeros (1,0)), sparse (ones (1,1))),
+%!assert <*40743> (max (zeros (1,0), ones (1,1)), zeros (1,0))
+%!assert <*40743> (max (zeros (1,0), ones (1,1)), zeros (1,0))
+%!assert <*40743> (max (sparse (zeros (1,0)), sparse (ones (1,1))),
+%!assert <*40743> (max (sparse (zeros (1,0)), sparse (ones (1,1))),
 %!                sparse (zeros (1,0)))
 
 %!error max ()
 %!error max (1, 2, 3, 4)
 %!error <DIM must be a valid dimension> max ([1 2; 3 4], [], -3)
 %!warning <second argument is ignored> max ([1 2 3 4], 2, 2);
 %!error <wrong type argument 'cell'> max ({1 2 3 4})
 %!error <cannot compute max \(cell, scalar\)> max ({1, 2, 3}, 2)
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -1161,17 +1161,18 @@ likely.
   return ovl (new octave_matrix (r, idx_vector (idx)));
 }
 
 /*
 %!assert (sort (randperm (20)), 1:20)
 %!assert (length (randperm (20,10)), 10)
 
 ## Test biggish N
-%!assert <39378> (length (randperm (30000^2, 100000)), 100000)
+%!assert <*39378> (length (randperm (30000^2, 100000)), 100000)
+%!assert <*39378> (length (randperm (30000^2, 100000)), 100000)
 
 %!test
 %! rand ("seed", 0);
 %! for i = 1:100
 %!   p = randperm (305, 30);
 %!   assert (length (unique (p)), 30);
 %! endfor
 */
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -975,17 +975,18 @@ are zero or more @qcode{'b'} characters 
 %! assert (nm(2).first, "James");
 %! assert (nm(2).last, "Rogers");
 
 ## Tests for named tokens
 %!test
 %! ## Parenthesis in named token (ie (int)) causes a problem
 %! assert (regexp ('qwe int asd', ['(?<typestr>(int))'], 'names'), struct ('typestr', 'int'));
 
-%!test <35683>
+%!test <*35683>
+%!test <*35683>
 %! ## Mix of named and unnamed tokens can cause segfault
 %! str = "abcde";
 %! ptn = '(?<T1>a)(\w+)(?<T2>d\w+)';
 %! tokens = regexp (str, ptn, "names");
 %! assert (isstruct (tokens) && numel (tokens) == 1);
 %! assert (tokens.T1, "a");
 %! assert (tokens.T2, "de");
 
@@ -1112,17 +1113,18 @@ are zero or more @qcode{'b'} characters 
 %! [a, b] = regexp (str, "[o]+", "match", "split");
 %! assert (a, {"oo"});
 %! assert (b, {"f", " bar"});
 
 %!assert (regexp ("\n", '\n'), 1)
 %!assert (regexp ("\n", "\n"), 1)
 
 # Test escape sequences are silently converted
-%!test <45407>
+%!test <*45407>
+%!test <*45407>
 %! assert (regexprep ('s', 's', 'x\.y'), 'x.y');
 %! assert (regexprep ('s', '(s)', 'x\$1y'), 'x$1y');
 %! assert (regexprep ('s', '(s)', 'x\\$1y'), 'x\sy');
 
 */
 
 DEFUN (regexpi, args, nargout,
        doc: /* -*- texinfo -*-
diff --git a/libinterp/corefcn/svd.cc b/libinterp/corefcn/svd.cc
--- a/libinterp/corefcn/svd.cc
+++ b/libinterp/corefcn/svd.cc
@@ -347,17 +347,18 @@ assert (a, u * s * v', 128 * eps);
 
 %!test
 %! a = zeros (5, 0);
 %! [u, s, v] = svd (a, 1);
 %! assert (size (u), [5, 0]);
 %! assert (size (s), [0, 0]);
 %! assert (size (v), [0, 0]);
 
-%!test <49309>
+%!test <*49309>
+%!test <*49309>
 %! [~,~,v] = svd ([1, 1, 1], 0);
 %! assert (size (v), [3 3]);
 %! [~,~,v] = svd ([1, 1, 1], "econ");
 %! assert (size (v), [3 1]);
 
 %!error svd ()
 %!error svd ([1, 2; 4, 5], 2, 3)
 %!error [u, v] = svd ([1, 2; 3, 4])
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -334,17 +334,18 @@ sparse matrices.
 %! assert (qd, sparse (eye (2)))
 %! assert (qv, [1 2])
 %!
 %! [rv, pv, qv] = chol (a, "Vector"); # check case sensitivity
 %! assert (r, rv, eps)
 %! assert (pd, pv)
 %! assert (qv, [1 2])
 
-%!testif HAVE_CHOLMOD <42587>
+%!testif HAVE_CHOLMOD <*42587>
+%!testif HAVE_CHOLMOD <*42587>
 %! A = sparse ([1 0 8;0 1 8;8 8 1]);
 %! [Q, p] = chol (A);
 %! assert (p != 0);
 
 %!error chol ()
 %!error <matrix must be positive definite> chol ([1, 2; 3, 4])
 %!error <requires square matrix> chol ([1, 2; 3, 4; 5, 6])
 %!error <optional arguments must be strings> chol (1, 2)
diff --git a/libinterp/dldfcn/symbfact.cc b/libinterp/dldfcn/symbfact.cc
--- a/libinterp/dldfcn/symbfact.cc
+++ b/libinterp/dldfcn/symbfact.cc
@@ -401,17 +401,18 @@ cleanup:
 %! assert (r, sparse (triu (true (3))));
 
 %!testif HAVE_CHOLMOD
 %! ## Test MODE "lower"
 %! A = sparse (magic (3));
 %! [~, ~, ~, ~, l] = symbfact (A, "sym", "lower");
 %! assert (l, sparse (tril (true (3))));
 
-%!testif HAVE_CHOLMOD <42587>
+%!testif HAVE_CHOLMOD <*42587>
+%!testif HAVE_CHOLMOD <*42587>
 %! ## singular matrix
 %! A = sparse ([1 0 8;0 1 8;8 8 1]);
 %! [count, h, parent, post, r] = symbfact (A);
 
 ## Test input validation
 %!testif HAVE_CHOLMOD
 %! fail ("symbfact ()");
 %! fail ("symbfact (1,2,3,4)");
diff --git a/libinterp/octave-value/ov-cx-diag.cc b/libinterp/octave-value/ov-cx-diag.cc
--- a/libinterp/octave-value/ov-cx-diag.cc
+++ b/libinterp/octave-value/ov-cx-diag.cc
@@ -247,10 +247,11 @@ octave_complex_diag_matrix::chk_valid_sc
 {
   bool retval = val.is_complex_scalar () || val.is_real_scalar ();
   if (retval)
     x = val.complex_value ();
   return retval;
 }
 
 /*
-%!assert <36368> (diag ([1+i, 1-i])^2 , diag ([2i, -2i]), 4*eps)
+%!assert <*36368> (diag ([1+i, 1-i])^2 , diag ([2i, -2i]), 4*eps)
+%!assert <*36368> (diag ([1+i, 1-i])^2 , diag ([2i, -2i]), 4*eps)
 */
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -1289,17 +1289,18 @@ octave_fcn_handle::load_hdf5 (octave_hdf
 
   warn_load ("hdf5");
 
   return false;
 #endif
 }
 
 /*
-%!test <33857>
+%!test <*33857>
+%!test <*33857>
 %! a = 2;
 %! f = @(x) a + x;
 %! g = @(x) 2 * x;
 %! hm = @version;
 %! hdld = @svd;
 %! hbi = @log2;
 %! f2 = f;
 %! g2 = g;
@@ -1341,17 +1342,18 @@ octave_fcn_handle::load_hdf5 (octave_hdf
 %!function [f2, g2, hm2, hdld2, hbi2] = fcn_handle_load_recurse (n, nm)
 %!  if (n == 0)
 %!    load (nm);
 %!  else
 %!    [f2, g2, hm2, hdld2, hbi2] = fcn_handle_load_recurse (n - 1, nm);
 %!  endif
 %!endfunction
 
-%!test <35876>
+%!test <*35876>
+%!test <*35876>
 %! a = 2;
 %! f = @(x) a + x;
 %! g = @(x) 2 * x;
 %! hm = @version;
 %! hdld = @svd;
 %! hbi = @log2;
 %! f2 = f;
 %! g2 = g;
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -3218,35 +3218,38 @@ Return true if @var{x} is a Java object.
 %!testif HAVE_JAVA; usejava ("jvm")
 %! assert (javaMethod ("binarySearch", "java.util.Arrays", [90 100 255], 255), 2);
 %! assert (javaMethod ("binarySearch", "java.util.Arrays", uint8 ([90 100 255]), uint8 (255)) < 0);
 %! assert (javaMethod ("binarySearch", "java.util.Arrays", uint8 ([90 100 128]), uint8 (128)) < 0);
 %! assert (javaMethod ("binarySearch", "java.util.Arrays", uint8 ([90 100 127]), uint8 (127)), 2);
 %! assert (javaMethod ("binarySearch", "java.util.Arrays", uint16 ([90 100 128]), uint16 (128)), 2);
 
 ## Check we can create objects that wrap java literals
-%!testif HAVE_JAVA; usejava ("jvm") <38821>
+%!testif HAVE_JAVA; usejava ("jvm") <*38821>
+%!testif HAVE_JAVA; usejava ("jvm") <*38821>
 %! assert (class (javaObject ("java.lang.Byte",     uint8 (1))), "java.lang.Byte");
 %! assert (class (javaObject ("java.lang.Byte",      int8 (1))), "java.lang.Byte");
 %! assert (class (javaObject ("java.lang.Short",   uint16 (1))), "java.lang.Short");
 %! assert (class (javaObject ("java.lang.Short",    int16 (1))), "java.lang.Short");
 %! assert (class (javaObject ("java.lang.Integer", uint32 (1))), "java.lang.Integer");
 %! assert (class (javaObject ("java.lang.Integer",  int32 (1))), "java.lang.Integer");
 %! assert (class (javaObject ("java.lang.Long",    uint64 (1))), "java.lang.Long");
 %! assert (class (javaObject ("java.lang.Long",     int64 (1))), "java.lang.Long");
 
 ## Test for automatic conversion of specific numeric classes
-%!testif HAVE_JAVA; usejava ("jvm") <48013>
+%!testif HAVE_JAVA; usejava ("jvm") <*48013>
+%!testif HAVE_JAVA; usejava ("jvm") <*48013>
 %! assert (javaMethod ("valueOf", "java.lang.Byte",     int8 (1)), 1)
 %! assert (javaMethod ("valueOf", "java.lang.Short",   int16 (1)), 1)
 %! assert (javaMethod ("valueOf", "java.lang.Integer", int32 (1)), 1)
 %! assert (javaMethod ("valueOf", "java.lang.Long",    int64 (1)), 1)
 %! assert (javaMethod ("valueOf", "java.lang.Float",  single (1)), 1)
 %! assert (javaMethod ("valueOf", "java.lang.Double", double (1)), 1)
 %! assert (class (javaMethod ("valueOf", "java.math.BigDecimal", double (1))), "java.math.BigDecimal")
 %! assert (class (javaMethod ("valueOf", "java.math.BigInteger",  int64 (1))), "java.math.BigInteger")
 
 ## Automatic conversion from string cell array into String[]
-%!testif HAVE_JAVA; usejava ("jvm") <45290>
+%!testif HAVE_JAVA; usejava ("jvm") <*45290>
+%!testif HAVE_JAVA; usejava ("jvm") <*45290>
 %! assert (javaMethod ("binarySearch", "java.util.Arrays", {"aaa", "bbb", "ccc", "zzz"}, "aaa"), 0);
 %! assert (javaMethod ("binarySearch", "java.util.Arrays", {"aaa", "bbb", "ccc", "zzz"}, "zzz"), 3);
 %! assert (javaMethod ("binarySearch", "java.util.Arrays", {"aaa", "bbb", "ccc", "zzz"}, "hhh") < 0);
 */
diff --git a/libinterp/parse-tree/pt-mat.cc b/libinterp/parse-tree/pt-mat.cc
--- a/libinterp/parse-tree/pt-mat.cc
+++ b/libinterp/parse-tree/pt-mat.cc
@@ -338,17 +338,18 @@ namespace octave
 %!assert (class (["a", double(1)]), "char")
 %!assert (class (["a", cell(1)]), "cell")
 %!assert (class (["a", true]), "char")
 %!assert (class (["a", "a"]), "char")
 
 %!assert (class ([cell(1), struct("foo", "bar")]), "cell")
 %!error [struct("foo", "bar"), cell(1)]
 
-%!test <39041> assert (class ([cell(0), struct()]), "cell")
+%!test <*39041> assert (class ([cell(0), struct()]), "cell")
+%!test <*39041> assert (class ([cell(0), struct()]), "cell")
 %!test <51086> assert (class ([struct(), cell(0)]), "struct")
 
 %!assert ([,1], 1)
 %!assert ([1,], 1)
 %!assert ([,1,], 1)
 %!assert ([,1,;;], 1)
 %!assert ([,1,;,;], 1)
 
diff --git a/scripts/general/accumarray.m b/scripts/general/accumarray.m
--- a/scripts/general/accumarray.m
+++ b/scripts/general/accumarray.m
@@ -435,17 +435,18 @@ endfunction
 %! vals = rand (2000, 1);
 %! assert (accumarray (subsc, vals, [], @max),
 %!         accumarray (subs, vals, [], @max));
 
 %!error (accumarray (1:5))
 %!error (accumarray ([1,2,3],1:2))
 
 ## Handle empty arrays
-%!test <47287>
+%!test <*47287>
+%!test <*47287>
 %! ## min, max, and sum are special cases within accumarray so test them.
 %! funcs = {@(x) length (x) > 1, @min, @max, @sum};
 %! for idx = 1:numel (funcs)
 %!   assert (accumarray (zeros (0, 1), [], [0 1] , funcs{idx}), zeros (0, 1));
 %!   assert (accumarray (zeros (0, 1), [], [1 0] , funcs{idx}), zeros (1, 0));
 %!   assert (accumarray (zeros (0, 1), [], [] , funcs{idx}), zeros (0, 1));
 %! endfor
 
diff --git a/scripts/general/bitset.m b/scripts/general/bitset.m
--- a/scripts/general/bitset.m
+++ b/scripts/general/bitset.m
@@ -96,17 +96,18 @@ endfunction
 %! pfx = {"", "u"};
 %! for i = 1:2
 %!   for prec = [8, 16, 32, 64]
 %!     fcn = str2func (sprintf ("%sint%d", pfx{i}, prec));
 %!     assert (bitset (fcn ([0, 10]), [3, 3]), fcn ([4, 14]));
 %!   endfor
 %! endfor
 
-%!assert <36458> (bitset (uint8 ([1, 2;3 4]), 1, [0 1; 0 1]),
+%!assert <*36458> (bitset (uint8 ([1, 2;3 4]), 1, [0 1; 0 1]),
+%!assert <*36458> (bitset (uint8 ([1, 2;3 4]), 1, [0 1; 0 1]),
 %!                uint8 ([0, 3; 2 5]))
 
 %!error bitset (1)
 %!error bitset (1, 2, 3, 4)
 %!error <A must be .= 0> bitset (-1, 2)
 %!error <invalid class char> bitset ("1", 2)
 %!error <N must be in the range \[1,53\]> bitset (0, 0)
 %!error <N must be in the range \[1,53\]> bitset (0, 55)
diff --git a/scripts/general/inputParser.m b/scripts/general/inputParser.m
--- a/scripts/general/inputParser.m
+++ b/scripts/general/inputParser.m
@@ -653,17 +653,18 @@ endclassdef
 %!test
 %! p2 = create_p2 ();
 %! parse (p2, "file", "foo", 80, "line", "circle", "verbose");
 %! r = p2.Results;
 %! assert ({r.req1, r.op1, r.op2, r.verbose, r.line},
 %!         {"file", "foo", 80,    true,      "circle"});
 
 ## We must not perform validation of default values
-%!test <45837>
+%!test <*45837>
+%!test <*45837>
 %! p = inputParser;
 %! p.addParameter ("Dir", [], @ischar);
 %! p.parse ();
 %! assert (p.Results.Dir, []);
 
 %!test
 %! p = inputParser;
 %! p.addParameter ("positive", -1, @(x) x > 5);
@@ -739,17 +740,18 @@ endclassdef
 %! p.parse ();
 %! assert (p.Results, struct ("foo", "bar"))
 %! p.parse ("foo", "qux");
 %! assert (p.Results, struct ("foo", "qux"))
 
 ## This behaviour means that a positional option can never be a string
 ## that is the name of a parameter key.  This is required for Matlab
 ## compatibility.
-%!test <50752>
+%!test <*50752>
+%!test <*50752>
 %! p = inputParser ();
 %! p.addOptional ("op1", "val");
 %! p.addParameter ("line", "tree");
 %! p.parse ("line", "circle");
 %! assert (p.Results, struct ("op1", "val", "line", "circle"))
 %!
 %! p = inputParser ();
 %! p.addOptional ("op1", "val1");
@@ -779,26 +781,28 @@ endclassdef
 %! fail ('p.parse ("line", 89)', "failed validation of LINE")
 %!
 %! p = inputParser ();
 %! p.addOptional ("op1", "val1");
 %! p.addParamValue ("line", "circle", @ischar);
 %! fail ('p.parse ("line", "line", 89)',
 %!       "non-string for Parameter name or Switch")
 
-%!test <50752>
+%!test <*50752>
+%!test <*50752>
 %! ## This fails in Matlab but works in Octave.  It is a bug there
 %! ## that we do not replicate.
 %! p = inputParser ();
 %! p.addOptional ("op1", "val1");
 %! p.addParameter ("line", "circle");
 %! p.parse ("line");
 %! assert (p.Results, struct ("op1", "line", "line", "circle"))
 
-%!test <50752>
+%!test <*50752>
+%!test <*50752>
 %! p = inputParser;
 %! p.addOptional ("op1", "val1");
 %! p.addSwitch ("line");
 %! p.parse ("line");
 %! assert (p.Results.op1, "val1")
 %! assert (p.Results.line, true)
 
 %!test
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -514,21 +514,24 @@ endfunction
 %! assert (interp2 (x,y,A,x,y,"linear"), A);
 %! assert (interp2 (x,y,A,x,y,"nearest"), A);
 
 %!test  # for Matlab-compatible rounding for 'nearest'
 %! X = meshgrid (1:4);
 %! assert (interp2 (X, 2.5, 2.5, "nearest"), 3);
 
 ## re-order monotonically decreasing
-%!assert <41838> (interp2 ([1 2 3], [3 2 1], magic (3), 2.5, 3), 3.5)
-%!assert <41838> (interp2 ([3 2 1], [1 2 3], magic (3), 1.5, 1), 3.5)
+%!assert <*41838> (interp2 ([1 2 3], [3 2 1], magic (3), 2.5, 3), 3.5)
+%!assert <*41838> (interp2 ([1 2 3], [3 2 1], magic (3), 2.5, 3), 3.5)
+%!assert <*41838> (interp2 ([3 2 1], [1 2 3], magic (3), 1.5, 1), 3.5)
+%!assert <*41838> (interp2 ([3 2 1], [1 2 3], magic (3), 1.5, 1), 3.5)
 
 ## Linear interpretation with vector XI doesn't lead to matrix output
-%!assert <49506> (interp2 ([2 3], [2 3 4], [1 2; 3 4; 5 6], [2 3], 3, "linear"), [3 4])
+%!assert <*49506> (interp2 ([2 3], [2 3 4], [1 2; 3 4; 5 6], [2 3], 3, "linear"), [3 4])
+%!assert <*49506> (interp2 ([2 3], [2 3 4], [1 2; 3 4; 5 6], [2 3], 3, "linear"), [3 4])
 
 %!shared z, zout, tol
 %! z = [1 3 5; 3 5 7; 5 7 9];
 %! zout = [1 2 3 4 5; 2 3 4 5 6; 3 4 5 6 7; 4 5 6 7 8; 5 6 7 8 9];
 %! tol = 2 * eps;
 %!
 %!assert (interp2 (z), zout, tol)
 %!assert (interp2 (z, "linear"), zout, tol)
diff --git a/scripts/general/interpft.m b/scripts/general/interpft.m
--- a/scripts/general/interpft.m
+++ b/scripts/general/interpft.m
@@ -118,17 +118,18 @@ endfunction
 
 %!shared n,y
 %! x = [0:10]';  y = sin(x);  n = length (x);
 %!assert (interpft (y, n), y, 20*eps)
 %!assert (interpft (y', n), y', 20*eps)
 %!assert (interpft ([y,y],n), [y,y], 20*eps)
 
 ## Test case with complex input
-%!test <39566>
+%!test <*39566>
+%!test <*39566>
 %! x = (1 + j) * [1:4]';
 %! y = ifft ([15 + 15*j; -6; -1.5 - 1.5*j; 0; -1.5 - 1.5*j; -6*j]);
 %! assert (interpft (x, 6), y, 10*eps);
 
 ## Test for correct spectral symmetry with even/odd lengths
 %!assert (max (abs (imag (interpft ([1:8], 20)))), 0, 20*eps)
 %!assert (max (abs (imag (interpft ([1:8], 21)))), 0, 21*eps)
 %!assert (max (abs (imag (interpft ([1:9], 20)))), 0, 20*eps)
diff --git a/scripts/general/num2str.m b/scripts/general/num2str.m
--- a/scripts/general/num2str.m
+++ b/scripts/general/num2str.m
@@ -242,19 +242,21 @@ endfunction
 %!shared
 
 ## FIXME: Integers greater than flintmax() - 1 should be masked to show just
 ##        16 digits of precision.
 %!test <36133>
 %! assert (num2str (1e23), "100000000000000000000000");
 
 ## Test for extra rows generated from newlines in format
-%!assert <44864> (rows (num2str (magic (3), "%3d %3d %3d\n")), 3)
+%!assert <*44864> (rows (num2str (magic (3), "%3d %3d %3d\n")), 3)
+%!assert <*44864> (rows (num2str (magic (3), "%3d %3d %3d\n")), 3)
 
-%!assert <45174> (num2str ([65 66 67], "%s"), "ABC")
+%!assert <*45174> (num2str ([65 66 67], "%s"), "ABC")
+%!assert <*45174> (num2str ([65 66 67], "%s"), "ABC")
 
 %!error num2str ()
 %!error num2str (1, 2, 3)
 %!error <X must be a numeric> num2str ({1})
 %!error <PRECISION must be a scalar integer .= 0> num2str (1, {1})
 %!error <PRECISION must be a scalar integer .= 0> num2str (1, ones (2))
 %!error <PRECISION must be a scalar integer .= 0> num2str (1, -1)
 %!error <PRECISION must be a scalar integer .= 0> num2str (1, 1.5)
diff --git a/scripts/general/postpad.m b/scripts/general/postpad.m
--- a/scripts/general/postpad.m
+++ b/scripts/general/postpad.m
@@ -101,14 +101,15 @@ endfunction
 %!assert (postpad ([1;2], 2, 2, 3), reshape ([1;2;2;2], 2, 1, 2))
 %!assert (postpad ([1,2], 2, 2, 3), reshape ([1,2,2,2], 1, 2, 2))
 
 %!assert (postpad ([1 2], 2), [1 2])
 %!assert (postpad ([1; 2], 2), [1; 2])
 %!assert (postpad ([1; 2], 2, 3, 2), [1 3; 2 3])
 
 %! ## Test with string concatenation
-%!assert <44162> (postpad ("Octave", 16, "x"), "Octavexxxxxxxxxx")
+%!assert <*44162> (postpad ("Octave", 16, "x"), "Octavexxxxxxxxxx")
+%!assert <*44162> (postpad ("Octave", 16, "x"), "Octavexxxxxxxxxx")
 %!assert (postpad ("Octave", 4), "Octa")
 
 %!error postpad ()
 %!error postpad (1)
 %!error postpad (1,2,3,4,5)
diff --git a/scripts/general/prepad.m b/scripts/general/prepad.m
--- a/scripts/general/prepad.m
+++ b/scripts/general/prepad.m
@@ -104,17 +104,18 @@ endfunction
 %!assert (prepad ([1; 2], 2, 3, 2), [3 1; 3 2])
 
 %!assert (prepad ([1,2], 2, 2, 1), [2,2;1,2])
 
 %!assert (prepad ([1,2], 2, 2, 3), reshape ([2,2,1,2], 1, 2, 2))
 %!assert (prepad ([1;2], 2, 2, 3), reshape ([2;2;1;2], 2, 1, 2))
 
 %! ## Test with string concatenation
-%!assert <44162> (prepad ("Octave", 16, "x"), "xxxxxxxxxxOctave")
+%!assert <*44162> (prepad ("Octave", 16, "x"), "xxxxxxxxxxOctave")
+%!assert <*44162> (prepad ("Octave", 16, "x"), "xxxxxxxxxxOctave")
 %!assert (prepad ("Octave", 4), "tave")
 
 ## FIXME: We need tests for multidimensional arrays.
 
 %!error prepad ()
 %!error prepad (1)
 %!error prepad (1,2,3,4,5)
 %!error <C must be empty or a scalar> prepad ([1,2], 2, ones (2))
diff --git a/scripts/general/rat.m b/scripts/general/rat.m
--- a/scripts/general/rat.m
+++ b/scripts/general/rat.m
@@ -154,12 +154,13 @@ function [n,d] = rat (x,tol)
 endfunction
 
 
 %!test
 %! [n, d] = rat ([0.5, 0.3, 1/3]);
 %! assert (n, [1, 3, 1]);
 %! assert (d, [2, 10, 3]);
 
-%!assert <43374> (eval (rat (0.75)), [0.75])
+%!assert <*43374> (eval (rat (0.75)), [0.75])
+%!assert <*43374> (eval (rat (0.75)), [0.75])
 
 %!error rat ()
 %!error rat (1, 2, 3)
diff --git a/scripts/geometry/rectint.m b/scripts/geometry/rectint.m
--- a/scripts/geometry/rectint.m
+++ b/scripts/geometry/rectint.m
@@ -89,20 +89,24 @@ endfunction
 ## no overlap - shared corner
 %!assert (rectint ([0 0 1 1], [1 1 2 2]), 0)
 ## no overlap - shared edge
 %!assert (rectint ([0 0 1 1], [0 1 2 2]), 0)
 ## Correct orientation of output
 %!assert (rectint ([0 0 1 1;0.5 0.5 1 1;-1 -1 2 2], [1 1 2 2]), [0;0.25;0])
 %!assert (rectint ([1 1 2 2], [0 0 1 1;0.5 0.5 1 1;-1 -1 2 2]), [0 0.25 0])
 
-%!assert <44904> (rectint ([0 0 5 5], [6 6 5 5]), 0)
-%!assert <44904> (rectint ([0 0 5 5], [0 6 5 5]), 0)
-%!assert <44904> (rectint ([0 0 5 5], [6 0 5 5]), 0)
-%!assert <44904> (rectint ([0 0 0 5 5 5], [0 0 6 5 5 5]), 0)
+%!assert <*44904> (rectint ([0 0 5 5], [6 6 5 5]), 0)
+%!assert <*44904> (rectint ([0 0 5 5], [6 6 5 5]), 0)
+%!assert <*44904> (rectint ([0 0 5 5], [0 6 5 5]), 0)
+%!assert <*44904> (rectint ([0 0 5 5], [0 6 5 5]), 0)
+%!assert <*44904> (rectint ([0 0 5 5], [6 0 5 5]), 0)
+%!assert <*44904> (rectint ([0 0 5 5], [6 0 5 5]), 0)
+%!assert <*44904> (rectint ([0 0 0 5 5 5], [0 0 6 5 5 5]), 0)
+%!assert <*44904> (rectint ([0 0 0 5 5 5], [0 0 6 5 5 5]), 0)
 
 ## Test volumes
 %!shared r1, r2, r3, r4, r5
 %! r1 = [  5   3 0  7   5 2];
 %! r2 = [  2   5 0  4   2 2];
 %! r3 = [ 10   7 0 10   3 2];
 %! r4 = [ 10  -5 0  5   7 2];
 %! r5 = [-10   0 0 40  11 2];
diff --git a/scripts/geometry/voronoi.m b/scripts/geometry/voronoi.m
--- a/scripts/geometry/voronoi.m
+++ b/scripts/geometry/voronoi.m
@@ -195,29 +195,32 @@ endfunction
 
 %!testif HAVE_QHULL
 %! phi = linspace (-pi, 3/4*pi, 8);
 %! [x,y] = pol2cart (phi, 1);
 %! [vx,vy] = voronoi (x,y);
 %! assert (vx(2,:), zeros (1, columns (vx)), eps);
 %! assert (vy(2,:), zeros (1, columns (vy)), eps);
 
-%!testif HAVE_QHULL <40996>
+%!testif HAVE_QHULL <*40996>
+%!testif HAVE_QHULL <*40996>
 %! ## Special case of just 2 points
 %! x = [0 1];  y = [1 0];
 %! [vx, vy] = voronoi (x,y);
 %! assert (vx, [-0.7; 1.7], eps);
 %! assert (vy, [-0.7; 1.7], eps);
 
-%!testif HAVE_QHULL <38295>
+%!testif HAVE_QHULL <*38295>
+%!testif HAVE_QHULL <*38295>
 %! x = [1,2,3];  y = [2,3,1];
 %! [vx, vy] = voronoi (x,y);
 %! assert (columns (vx), 3);
 
-%!testif HAVE_QHULL <37270>
+%!testif HAVE_QHULL <*37270>
+%!testif HAVE_QHULL <*37270>
 %! ## Duplicate points can cause an internal error
 %! x = [1,2,3, 3];  y = [2,3,1, 1];
 %! [vx, vy] = voronoi (x,y);
 
 
 ## Input validation tests
 %!error voronoi ()
 %!error voronoi (ones (3,1))
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -223,17 +223,18 @@ endfunction
 %!  h = image (x, -y, img);
 %!  title ("image (x, -y, img)");
 %!  ylabel ("limits = [-5.5, 5.5]");
 %! subplot (2,2,4);
 %!  h = image (-x, -y, img);
 %!  title ("image (-x, -y, img)");
 
 ## test hidden properties x/ydatamode
-%!test <42121>
+%!test <*42121>
+%!test <*42121>
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   nx = 64; ny = 64;
 %!   cdata = rand (ny, nx)*127;
 %!   hi = image (cdata);             # x/ydatamode is auto
 %!   assert (get (hi, "xdata"), [1 nx]);
 %!   assert (get (hi, "ydata"), [1 ny]);
 %!   set (hi, "cdata", cdata(1:2:end, 1:2:end));
diff --git a/scripts/image/imwrite.m b/scripts/image/imwrite.m
--- a/scripts/image/imwrite.m
+++ b/scripts/image/imwrite.m
@@ -225,16 +225,17 @@ endfunction
 %!      fclose (fid);
 %!    end_unwind_protect
 %!  unwind_protect_cleanup
 %!    unlink (filename);
 %!  end_unwind_protect
 %!endfunction
 
 ## BMP images must be saved uncompressed by default
-%!testif HAVE_MAGICK <45565>
+%!testif HAVE_MAGICK <*45565>
+%!testif HAVE_MAGICK <*45565>
 %! assert (get_bmp_compression ("", [], "BMP"), 0);
 %! assert (get_bmp_compression ("", [], "bmp"), 0);
 %! assert (get_bmp_compression (".BMP"), 0);
 %! assert (get_bmp_compression (".bmp"), 0);
 %! assert (get_bmp_compression (".bmp", [], "bmp"), 0);
 %! assert (get_bmp_compression ("", gray (256), "bmp"), 0);
 %! assert (get_bmp_compression (".bmp", gray (256), "Compression", "rle"), 1);
diff --git a/scripts/io/importdata.m b/scripts/io/importdata.m
--- a/scripts/io/importdata.m
+++ b/scripts/io/importdata.m
@@ -524,17 +524,18 @@ endfunction
 %! fputs (fid, "3.1\t-7.2\t0\r0.012\t6.5\t128");
 %! fclose (fid);
 %! [a,d,h] = importdata (fn, '\t');
 %! unlink (fn);
 %! assert (a, A);
 %! assert (d, "\t");
 %! assert (h, 0);
 
-%!test <43393>
+%!test <*43393>
+%!test <*43393>
 %! ## Distinguish double from complex when no delimiter is supplied
 %! fn  = tmpnam ();
 %! fid = fopen (fn, "w");
 %! fputs (fid, "2.0000e+02   4.0000e-04");
 %! fclose (fid);
 %! [a, d, h] = importdata (fn);
 %! unlink (fn);
 %! assert (a, [2e2, 4e-4]);
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -889,17 +889,18 @@ endfunction
 %!         {"Hello"; "World!"});
 %! assert (strread ("Hello World! % this is comment", "%s",...
 %!                  "commentstyle", "matlab"), ...
 %!         {"Hello"; "World!"});
 %! assert (strread ("Hello World! # this is comment", "%s",...
 %!                  "commentstyle", "shell"), ...
 %!         {"Hello"; "World!"});
 
-%!test <49454>
+%!test <*49454>
+%!test <*49454>
 %! assert (strread ("hello%foo\nworld, another%bar\r\nday", "%s", ...
 %!                  "commentstyle", "matlab", "delimiter", " ,"),...
 %!         {"hello"; "world"; "another"; "day"});
 
 %!test
 %! str = sprintf ("Tom 100 miles/hr\nDick 90 miles/hr\nHarry 80 miles/hr");
 %! fmt = "%s %f miles/hr";
 %! c = cell (1, 2);
@@ -918,23 +919,25 @@ endfunction
 %! assert (b, {"a"; "b"; "c"});
 %! [a, b] = strread ("10 a 20 b\n 30 c 40\n", "%d %s", 4);
 %! assert (a, int32 ([10; 20; 30; 40]));
 %! assert (b, {"a"; "b"; "c"; ""});
 %! [a, b] = strread ("10 a 20 b\n 30 c 40", "%d %s", 1);
 %! assert (a, int32 (10));
 %! assert (b, {"a"});
 
-%!test <33536>
+%!test <*33536>
+%!test <*33536>
 %! [a, b, c] = strread ("1,,2", "%s%s%s", "delimiter", ",");
 %! assert (a{1}, "1");
 %! assert (b{1}, "");
 %! assert (c{1}, "2");
 
-%!test <33536>
+%!test <*33536>
+%!test <*33536>
 %!test
 %! a = strread ("[SomeText]", "[%s", "delimiter", "]");
 %! assert (a{1}, "SomeText");
 
 %!test
 %! dat = "Data file.\r\n=  =  =  =  =\r\nCOMPANY    : <Company name>\r\n";
 %! a = strread (dat, "%s", "delimiter", "\n", "whitespace", "", "endofline", "\r\n");
 %! assert (a{2}, "=  =  =  =  =");
@@ -979,17 +982,18 @@ endfunction
 %!test
 %! str = "11, 12, 13,, 15\n21,, 23, 24, 25\n,, 33, 34, 35";
 %! [a b c d] = strread (str, "%f %f %f %f", "delimiter", ",", "multipledelimsasone", 1, "endofline", "\n");
 %! assert (a', [11, 21, NaN]);
 %! assert (b', [12, 23, 33]);
 %! assert (c', [13, 24, 34]);
 %! assert (d', [15, 25, 35]);
 
-%!assert <44750> (strread ('/home/foo/','%s','delimiter','/','MultipleDelimsAsOne',1),
+%!assert <*44750> (strread ('/home/foo/','%s','delimiter','/','MultipleDelimsAsOne',1),
+%!assert <*44750> (strread ('/home/foo/','%s','delimiter','/','MultipleDelimsAsOne',1),
 %!                {"home"; "foo"})
 
 ## delimiter as sq_string and dq_string
 %!assert (strread ("1\n2\n3", "%d", "delimiter", "\n"),
 %!        strread ("1\n2\n3", "%d", "delimiter", '\n'))
 
 ## whitespace as sq_string and dq_string
 %!assert (strread ("1\b2\r3\b4\t5", "%d", "whitespace", "\b\r\n\t"),
@@ -1036,54 +1040,60 @@ endfunction
 %! assert (a{1}, '1');
 %! assert (b, NaN);
 
 %!test
 %! [a, b] = strread (["Empty" char(10)], "Empty%f %f");
 %! assert (a, NaN);
 %! assert (b, NaN);
 
-%!test <35999>
+%!test <*35999>
+%!test <*35999>
 %! [a, b, c] = strread ("", "%f");
 %! assert (isempty (a));
 %! assert (isempty (b));
 %! assert (isempty (c));
 
-%!test <37023>
+%!test <*37023>
+%!test <*37023>
 %! [a, b] = strread (" 1. 1 \n  2 3 \n", "%f %f", "endofline", "\n");
 %! assert (a, [1; 2], 1e-15);
 %! assert (b, [1; 3], 1e-15);
 
 ## Test for no output arg (interactive use)
 %!assert (strread (",2,,4\n5,,7,", "", "delimiter", ","),
 %!        [NaN; 2; NaN; 4; 5; NaN; 7])
 
 ## Test #1 bug #42609
-%!test <42609>
+%!test <*42609>
+%!test <*42609>
 %! [a, b, c] = strread ("1 2 3\n4 5 6\n7 8 9\n", "%f %f %f\n");
 %! assert (a, [1; 4; 7]);
 %! assert (b, [2; 5; 8]);
 %! assert (c, [3; 6; 9]);
 
 ## Test #2 bug #42609
-%!test <42609>
+%!test <*42609>
+%!test <*42609>
 %! [a, b, c] = strread ("1 2\n3\n4 5\n6\n7 8\n9\n", "%f %f\n%f");
 %! assert (a, [1;4;7]);
 %! assert (b, [2; 5; 8]);
 %! assert (c, [3; 6; 9]);
 
 ## Test #3 bug #42609
-%!test <42609>
+%!test <*42609>
+%!test <*42609>
 %! [a, b, c] = strread ("1 2 3\n4 5 6\n7 8 9\n", '%f %f %f\n');
 %! assert (a, [1; 4; 7]);
 %! assert (b, [2; 5; 8]);
 %! assert (c, [3; 6; 9]);
 
 ## Test #4 bug #42609
-%!test <42609>
+%!test <*42609>
+%!test <*42609>
 %! [a, b, c] = strread ("1 2\n3\n4 5\n6\n7 8\n9\n", '%f %f\n%f');
 %! assert (a, [1;4;7]);
 %! assert (b, [2; 5; 8]);
 %! assert (c, [3; 6; 9]);
 
 ## Unsupported format specifiers
 %!error <format specifiers are not supported> strread ("a", "%c")
 %!error <format specifiers are not supported> strread ("a", "%*c %d")
@@ -1102,17 +1112,18 @@ endfunction
 
 ## Illegal format specifiers
 %!error <no valid format conversion specifiers> strread ("1.0", "%z")
 
 ## Test for false positives in check for non-supported format specifiers
 %!assert (strread ("Total: 32.5 % (of cm values)","Total: %f % (of cm values)"), 32.5, 1e-5)
 
 ## Test various forms of string format specifiers
-%!test <45712>
+%!test <*45712>
+%!test <*45712>
 %! str = "14 :1 z:2 z:3 z:5 z:11";
 %! [a, b, c, d] = strread (str, "%f %s %*s %3s %*3s %f", "delimiter", ":");
 %! assert ({a, b, c, d}, {14, {"1 z"}, {"3 z"}, 11});
 
 ## Allow cuddling %sliteral but warn that it is ambiguous
 %!warning <Ambiguous '%s' specifier immediately before literal in column 1>
 %! [a, b] = strread ("abcxyz51\nxyz83\n##xyz101", "%s xyz %d");
 %! assert (a([1 3]), {"abc"; "##"});
diff --git a/scripts/io/textread.m b/scripts/io/textread.m
--- a/scripts/io/textread.m
+++ b/scripts/io/textread.m
@@ -471,31 +471,33 @@ endfunction
 #%! d = rand (1, 4);
 #%! fprintf (fid, ",2,,4\n5,\n");
 #%! fclose (fid);
 #%! A = textread (f, "", "delimiter", ",");
 #%! unlink (f);
 #%! assert (A, [0 2 0 4; 5 0 0 0], 1e-6);
 
 ### Test endofline
-#%!test <45046>
+#%!test <*45046>
+#%!test <*45046>
 #%! f = tempname ();
 #%! fid = fopen (f, "w");
 #%! fprintf (fid, "a\rb\rc");
 #%! fclose (fid);
 #%! ## Test EOL detection
 #%! d = textread (f, "%s");
 #%! assert (d, {"a";"b";"c"});
 #%! ## Test explicit EOL specification (bug #45046)
 #%! d = textread (f, "%s", "endofline", "\r");
 #%! assert (d, {"a"; "b"; "c"});
 #%! unlink (f);
 
 ### Properly process single-quoted EOL args
-#%!test <46477>
+#%!test <*46477>
+#%!test <*46477>
 #%! f = tempname ();
 #%! fid = fopen (f, "w");
 #%! fprintf (fid, "hello, world!");
 #%! fclose (fid);
 #%! [a, b] = textread (f, "%s%s", "endofline", '\n');
 #%! assert (a{1}, "hello,");
 #%! assert (b{1}, "world!");
 
diff --git a/scripts/miscellaneous/orderfields.m b/scripts/miscellaneous/orderfields.m
--- a/scripts/miscellaneous/orderfields.m
+++ b/scripts/miscellaneous/orderfields.m
@@ -190,17 +190,18 @@ endfunction
 %! aa(2).x = {4, 5};
 %! bb.y = {6, 7};
 %! bb.x = 8;
 %! aa(2) = orderfields (bb, aa);
 %! assert (aa(2).x, 8);
 %! assert (aa(2).y{1}, 6);
 
 ## Corner case of empty struct
-%!assert <40224> (orderfields (struct ()), struct ())
+%!assert <*40224> (orderfields (struct ()), struct ())
+%!assert <*40224> (orderfields (struct ()), struct ())
 %!test
 %! s(2,2).a = 1;
 %! s(1,1).b = 2;
 %! s = resize (s, [1 0]);
 %! s2 = orderfields (s, {"b", "a"});
 %! assert (fieldnames (s2), {"b"; "a"});
 %! assert (size_equal (s, s2));
 
diff --git a/scripts/optimization/qp.m b/scripts/optimization/qp.m
--- a/scripts/optimization/qp.m
+++ b/scripts/optimization/qp.m
@@ -416,17 +416,18 @@ function [x, obj, INFO, lambda] = qp (x0
     INFO.solveiter = iter;
     INFO.info = info;
   endif
 
 endfunction
 
 
 ## Test infeasible initial guess
-%!testif HAVE_GLPK <40536>
+%!testif HAVE_GLPK <*40536>
+%!testif HAVE_GLPK <*40536>
 %!
 %! H = 1;  q = 0;                # objective: x -> 0.5 x^2
 %! A = 1;  lb = 1;  ub = +inf;   # constraint: x >= 1
 %! x0 = 0;                       # infeasible initial guess
 %!
 %! [x, obj_qp, INFO, lambda] = qp (x0, H, q, [], [], [], [], lb, A, ub);
 %!
 %! assert (isstruct (INFO) && isfield (INFO, "info") && (INFO.info == 0));
diff --git a/scripts/plot/appearance/axis.m b/scripts/plot/appearance/axis.m
--- a/scripts/plot/appearance/axis.m
+++ b/scripts/plot/appearance/axis.m
@@ -668,17 +668,18 @@ endfunction
 %!   loglog (a, -a);
 %!   axis tight;
 %!   assert (axis (), [1e-5, 10, -10, -1e-5]);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 ## Test 'axis tight' with differently oriented, differently numbered data vecs
-%!test <40036>
+%!test <*40036>
+%!test <*40036>
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   Z = peaks (linspace (-3, 3, 49), linspace (-2, 2, 29));
 %!   surf (Z);
 %!   axis tight;
 %!   assert (axis (), [1 49 1 29 min(Z(:)) max(Z(:))]);
 %! unwind_protect_cleanup
 %!   close (hf);
diff --git a/scripts/plot/appearance/grid.m b/scripts/plot/appearance/grid.m
--- a/scripts/plot/appearance/grid.m
+++ b/scripts/plot/appearance/grid.m
@@ -187,17 +187,18 @@ endfunction
 %! set (gca, "ztick", [0, exp(1), 5, 9.1, 10]);
 %! set (gca, "xminorgrid", "on");
 %! set (gca, "yminorgrid", "on");
 %! set (gca, "zminorgrid", "on");
 %! view (3);
 %! title ("Minor grid adapts to xticks (bug #45850)")
 
 ## linear scaling
-%!test <48533>
+%!test <*48533>
+%!test <*48533>
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   hax = axes ();
 %!   plot (1:10);
 %!   grid on
 %!   assert (get (hax, "xgrid"), "on");
 %!   assert (get (hax, "ygrid"), "on");
 %!   assert (get (hax, "zgrid"), "on");
@@ -246,17 +247,18 @@ endfunction
 %!   assert (get (hax, "xminorgrid"), "off");
 %!   assert (get (hax, "yminorgrid"), "off");
 %!   assert (get (hax, "zminorgrid"), "off");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 ## semilog scaling
-%!test <48533>
+%!test <*48533>
+%!test <*48533>
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   hax = axes ();
 %!   semilogy (1:100);
 %!   grid on
 %!   assert (get (hax, "xgrid"), "on");
 %!   assert (get (hax, "ygrid"), "on");
 %!   assert (get (hax, "zgrid"), "on");
diff --git a/scripts/plot/appearance/legend.m b/scripts/plot/appearance/legend.m
--- a/scripts/plot/appearance/legend.m
+++ b/scripts/plot/appearance/legend.m
@@ -1624,17 +1624,18 @@ endfunction
 %!   print (filename);
 %!   unlink (filename);
 %!   assert (get (h, "position"), position);
 %! unwind_protect_cleanup
 %!   close (h);
 %!   graphics_toolkit (toolkit);
 %! end_unwind_protect
 
-%!test <42035>
+%!test <*42035>
+%!test <*42035>
 %! h = figure ("visible", "off");
 %! unwind_protect
 %!   hax1 = subplot (1,2,1);
 %!   plot (1:10);
 %!   hax2 = subplot (1,2,2);
 %!   plot (1:10);
 %!   hleg1 = legend (hax1, "foo");
 %!   assert (get (hleg1, "userdata").handle, hax1);
diff --git a/scripts/plot/appearance/title.m b/scripts/plot/appearance/title.m
--- a/scripts/plot/appearance/title.m
+++ b/scripts/plot/appearance/title.m
@@ -108,17 +108,18 @@ endfunction
 %!   title ("Test FontSize Property", "fontsize", 16);
 %!   h = get (gca, "title");
 %!   assert (get (h, "string"), "Test FontSize Property");
 %!   assert (get (h, "fontsize"), 16);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
-%!test <49469>
+%!test <*49469>
+%!test <*49469>
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   ht = title ("Test FontSize Property");
 %!   set (gca, "fontname", "Liberation Serif")
 %!   set (gca, "fontsize", 13)
 %!   assert (get (ht, "fontname"), "Liberation Serif");
 %!   assert (get (ht, "fontsize"), 13 * get (gca, "titlefontsizemultiplier"));
 %! unwind_protect_cleanup
diff --git a/scripts/plot/draw/hist.m b/scripts/plot/draw/hist.m
--- a/scripts/plot/draw/hist.m
+++ b/scripts/plot/draw/hist.m
@@ -213,20 +213,23 @@ endfunction
 %!   assert (sum (hist ([1:n], n)), n);
 %!   assert (sum (hist ([1:n], [2:n-1])), n);
 %!   assert (sum (hist ([1:n], [1:n])), n);
 %!   assert (sum (hist ([1:n], 29)), n);
 %!   assert (sum (hist ([1:n], 30)), n);
 %! endfor
 %!assert (hist (1,1), 1)
 %!assert (size (hist (randn (750,240), 200)), [200,240])
-%!assert <42394> (isempty (hist (rand (10,2), 0:5, 1)), false)
-%!assert <42394> (isempty (hist (rand (10,2), 0:5, [1 1])), false)
+%!assert <*42394> (isempty (hist (rand (10,2), 0:5, 1)), false)
+%!assert <*42394> (isempty (hist (rand (10,2), 0:5, 1)), false)
+%!assert <*42394> (isempty (hist (rand (10,2), 0:5, [1 1])), false)
+%!assert <*42394> (isempty (hist (rand (10,2), 0:5, [1 1])), false)
 
-%!test <47707>
+%!test <*47707>
+%!test <*47707>
 %! y = [1  9  2  2  9  3  8  9  1  7  1  1  3  2  4  4  8  2  1  9  4  1 ...
 %!      2  3  1  1  6  5  5  3  9  9  1  1  8  7  7  2  4  1];
 %! [n, x] = hist (y, 10);
 %! [nn, xx] = hist (uint8 (y), 10);
 %! assert (nn, n)
 %! assert (xx, x)
 %!
 %! ## test again with N > 30 because there's a special case for it
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -401,17 +401,18 @@ endfunction
 %! assert (p, p1, 1e-12);
 %! assert (isempty (k));
 %! assert (e, [1; 2]);
 %! [br, ar] = residue (r, p, k);
 %! assert (br, b, 1e-12);
 %! assert (ar, a, 1e-12);
 
 ## The following test is due to Bernard Grung
-%!test <34266>
+%!test <*34266>
+%!test <*34266>
 %! z1 =  7.0372976777e6;
 %! p1 = -3.1415926536e9;
 %! p2 = -4.9964813512e8;
 %! r1 = -(1 + z1/p1)/(1 - p1/p2)/p2/p1;
 %! r2 = -(1 + z1/p2)/(1 - p2/p1)/p2/p1;
 %! r3 = (1 + (p2 + p1)/p2/p1*z1)/p2/p1;
 %! r4 = z1/p2/p1;
 %! r = [r1; r2; r3; r4];
@@ -419,22 +420,24 @@ endfunction
 %! k = [];
 %! e = [1; 1; 1; 2];
 %! b = [1, z1];
 %! a = [1, -(p1 + p2), p1*p2, 0, 0];
 %! [br, ar] = residue (r, p, k, e);
 %! assert (br, [0,0,b], 1e-7);
 %! assert (ar, a, 1e-8);
 
-%!test <49291>
+%!test <*49291>
+%!test <*49291>
 %! rf = [1e3, 2e3, 1e3, 2e3];
 %! cf = [316.2e-9, 50e-9, 31.6e-9, 5e-9];
 %! [num, den] = residue (1./cf,-1./(rf.*cf),0);
 %! assert (numel (num), 4);
 %! assert (numel (den), 5);
 %! assert (den(1), 1);
 
-%!test <51148>
+%!test <*51148>
+%!test <*51148>
 %! r = [1.0000e+18, 3.5714e+12, 2.2222e+11, 2.1739e+10];
 %! pin = [-1.9231e+15, -1.6234e+09, -4.1152e+07, -1.8116e+06];
 %! k = 0;
 %! [p, q] = residue (r, pin, k);
 %! assert (p(4), 4.6828e+42, -1e-5);
diff --git a/scripts/set/setdiff.m b/scripts/set/setdiff.m
--- a/scripts/set/setdiff.m
+++ b/scripts/set/setdiff.m
@@ -110,19 +110,25 @@ endfunction
 %!test
 %! a = [3, 1, 4, 1, 5];
 %! b = [1, 2, 3, 4];
 %! [c, ia] = setdiff (a, b');
 %! assert (c, [5]);
 %! assert (c, a(ia));
 
 ## Test output orientation compatibility
-%!assert <42577> (setdiff ([1:5], 2), [1,3,4,5])
-%!assert <42577> (setdiff ([1:5]', 2), [1;3;4;5])
-%!assert <42577> (setdiff ([1:5], [2:3]), [1,4,5])
-%!assert <42577> (setdiff ([1:5], [2:3]'), [1,4,5])
-%!assert <42577> (setdiff ([1:5]', [2:3]), [1;4;5])
-%!assert <42577> (setdiff ([1:5]', [2:3]'), [1;4;5])
+%!assert <*42577> (setdiff ([1:5], 2), [1,3,4,5])
+%!assert <*42577> (setdiff ([1:5], 2), [1,3,4,5])
+%!assert <*42577> (setdiff ([1:5]', 2), [1;3;4;5])
+%!assert <*42577> (setdiff ([1:5]', 2), [1;3;4;5])
+%!assert <*42577> (setdiff ([1:5], [2:3]), [1,4,5])
+%!assert <*42577> (setdiff ([1:5], [2:3]), [1,4,5])
+%!assert <*42577> (setdiff ([1:5], [2:3]'), [1,4,5])
+%!assert <*42577> (setdiff ([1:5], [2:3]'), [1,4,5])
+%!assert <*42577> (setdiff ([1:5]', [2:3]), [1;4;5])
+%!assert <*42577> (setdiff ([1:5]', [2:3]), [1;4;5])
+%!assert <*42577> (setdiff ([1:5]', [2:3]'), [1;4;5])
+%!assert <*42577> (setdiff ([1:5]', [2:3]'), [1;4;5])
 
 %!test
 %! a = rand (3,3,3);
 %! b = a(1);
 %! assert (setdiff (a, b), sort (a(2:end)'));
diff --git a/scripts/signal/fftshift.m b/scripts/signal/fftshift.m
--- a/scripts/signal/fftshift.m
+++ b/scripts/signal/fftshift.m
@@ -134,17 +134,18 @@ endfunction
 
 %!test
 %! x = "abcdefg";
 %! y = fftshift (x);
 %! assert (y, "efgabcd");
 %! assert (fftshift (y), "bcdefga");
 
 ## Test N-dimensional input
-%!test <45207>
+%!test <*45207>
+%!test <*45207>
 %! x = [0:3];
 %! x = x + x' + reshape (x, [1 1 4]);
 %! y1 = [4 5 2 3; 5 6 3 4; 2 3 0 1; 3 4 1 2];
 %! y = fftshift (x);
 %! assert (y, reshape ([y1 + 2, y1 + 3, y1, y1 + 1], [4 4 4]));
 %! assert (fftshift (y), x);
 
 ## Test input validation
diff --git a/scripts/signal/ifftshift.m b/scripts/signal/ifftshift.m
--- a/scripts/signal/ifftshift.m
+++ b/scripts/signal/ifftshift.m
@@ -119,17 +119,18 @@ endfunction
 
 %!test
 %! x = "efgabcd";
 %! y = ifftshift (x);
 %! assert (y, "abcdefg");
 %! assert (ifftshift (y), "defgabc");
 
 ## Test N-dimensional input
-%!test <45207>
+%!test <*45207>
+%!test <*45207>
 %! x = [0:3];
 %! x = x + x' + reshape (x, [1 1 4]);
 %! y1 = [4 5 2 3; 5 6 3 4; 2 3 0 1; 3 4 1 2];
 %! y = ifftshift (x);
 %! assert (y, reshape ([y1 + 2, y1 + 3, y1, y1 + 1], [4 4 4]));
 %! assert (ifftshift (y), x);
 
 ## Test input validation
diff --git a/scripts/specfun/nthroot.m b/scripts/specfun/nthroot.m
--- a/scripts/specfun/nthroot.m
+++ b/scripts/specfun/nthroot.m
@@ -89,17 +89,18 @@ endfunction
 
 %!assert (nthroot (-32, 5), -2)
 %!assert (nthroot (81, 4), 3)
 %!assert (nthroot (Inf, 4), Inf)
 %!assert (nthroot (-Inf, 7), -Inf)
 %!assert (nthroot (-Inf, -7), 0)
 
 ## This should not generate a division by zero warning
-%!test <43492>
+%!test <*43492>
+%!test <*43492>
 %! warnmsg = lastwarn ();
 %! assert (nthroot (0, 2), 0);
 %! assert (lastwarn (), warnmsg);
 
 ## Test input validation
 %!error nthroot ()
 %!error nthroot (1)
 %!error nthroot (1,2,3)
diff --git a/scripts/special-matrix/magic.m b/scripts/special-matrix/magic.m
--- a/scripts/special-matrix/magic.m
+++ b/scripts/special-matrix/magic.m
@@ -83,17 +83,18 @@ endfunction
 %! for i = 3:30
 %!   A = magic (i);
 %!   assert (norm(diff([sum(diag(A)),sum(diag(flipud(A))),sum(A),sum(A')])),0);
 %! endfor
 
 ## Not a magic square but we must return something (bug #46672).
 ## While one day we may change the actual return of magic (2),
 ## this properties still must be true.
-%!test <46672>
+%!test <*46672>
+%!test <*46672>
 %! m = magic (2);
 %! assert (size (m), [2 2]);
 %! assert (unique (m), [1; 2; 3; 4]);
 
 %!assert (magic (2), [4 3; 1 2])
 %!assert (isempty (magic (-1)))
 %!assert (isempty (magic (0)))
 %!assert (magic (1), 1)
diff --git a/scripts/statistics/base/median.m b/scripts/statistics/base/median.m
--- a/scripts/statistics/base/median.m
+++ b/scripts/statistics/base/median.m
@@ -113,18 +113,20 @@ endfunction
 
 ## Test multidimensional arrays
 %!shared a, b, x, y
 %! rand ("seed", 2);
 %! a = rand (2,3,4,5);
 %! b = rand (3,4,6,5);
 %! x = sort (a, 4);
 %! y = sort (b, 3);
-%!assert <35679> (median (a, 4), x(:, :, :, 3))
-%!assert <35679> (median (b, 3), (y(:, :, 3, :) + y(:, :, 4, :))/2)
+%!assert <*35679> (median (a, 4), x(:, :, :, 3))
+%!assert <*35679> (median (a, 4), x(:, :, :, 3))
+%!assert <*35679> (median (b, 3), (y(:, :, 3, :) + y(:, :, 4, :))/2)
+%!assert <*35679> (median (b, 3), (y(:, :, 3, :) + y(:, :, 4, :))/2)
 
 ## Test non-floating point types
 %!assert (median ([true, false]), true)
 %!assert (median (uint8 ([1, 3])), uint8 (2))
 %!assert (median (int8 ([1, 3, 4])), int8 (3))
 %!assert (median (single ([1, 3, 4])), single (3))
 %!assert (median (single ([1, 3, NaN])), single (NaN))
 
diff --git a/scripts/statistics/base/quantile.m b/scripts/statistics/base/quantile.m
--- a/scripts/statistics/base/quantile.m
+++ b/scripts/statistics/base/quantile.m
@@ -316,17 +316,18 @@ endfunction
 %! sx = [2, 3, 4];
 %! x = rand (sx);
 %! dim = 2;
 %! p = 0.5;
 %! yobs = quantile (x, p, dim);
 %! yexp = median (x, dim);
 %! assert (yobs, yexp);
 
-%!assert <45455> (quantile ([1 3 2], 0.5, 1), [1 3 2])
+%!assert <*45455> (quantile ([1 3 2], 0.5, 1), [1 3 2])
+%!assert <*45455> (quantile ([1 3 2], 0.5, 1), [1 3 2])
 
 ## Test input validation
 %!error quantile ()
 %!error quantile (1, 2, 3, 4, 5)
 %!error quantile (['A'; 'B'], 10)
 %!error quantile (1:10, [true, false])
 %!error quantile (1:10, ones (2,2))
 %!error quantile (1, 1, 1.5)
diff --git a/scripts/strings/base2dec.m b/scripts/strings/base2dec.m
--- a/scripts/strings/base2dec.m
+++ b/scripts/strings/base2dec.m
@@ -116,17 +116,18 @@ function out = base2dec (s, base)
 endfunction
 
 
 %!assert (base2dec ("11120", 3), 123)
 %!assert (base2dec ("yyyzx", "xyz"), 123)
 %!assert (base2dec ("-1", 2), NaN)
 %!assert (base2dec ({"A1", "1A"}, 16), [161; 26])
 
-%!assert <35621> (base2dec (["0"; "1"], 2), [0; 1])
+%!assert <*35621> (base2dec (["0"; "1"], 2), [0; 1])
+%!assert <*35621> (base2dec (["0"; "1"], 2), [0; 1])
 
 ## Test input validation
 %!error base2dec ()
 %!error base2dec ("11120")
 %!error base2dec ("11120", 3, 4)
 %!error base2dec ("11120", "1231")
 %!error base2dec ("11120", "12 3")
 %!error base2dec ("11120", ones (2))
diff --git a/scripts/strings/strcat.m b/scripts/strings/strcat.m
--- a/scripts/strings/strcat.m
+++ b/scripts/strings/strcat.m
@@ -146,16 +146,18 @@ endfunction
 ## test for scalar strings with vector strings
 %!assert (strcat (["a"; "b"], "c"), ["ac"; "bc"])
 
 ## test with cells with strings of differing lengths
 %!assert (all (strcmp (strcat ({"a", "bb"}, "ccc"), {"accc", "bbccc"})))
 %!assert (all (strcmp (strcat ("a", {"bb", "ccc"}), {"abb", "accc"})))
 
 ## test with a single string or cell input
-%!assert <49094> (strcat ("foo    "), "foo")
-%!assert <49094> (strcat ({"foo"}), {"foo"})
+%!assert <*49094> (strcat ("foo    "), "foo")
+%!assert <*49094> (strcat ("foo    "), "foo")
+%!assert <*49094> (strcat ({"foo"}), {"foo"})
+%!assert <*49094> (strcat ({"foo"}), {"foo"})
 
 %!assert (strcat (1), char (1))
 %!assert (strcat (1, 2), strcat (char (1), char (2)))
 %!assert (strcat ("", 2), strcat ([], char (2)))
 
 %!assert (strcat (), "")
diff --git a/scripts/strings/strmatch.m b/scripts/strings/strmatch.m
--- a/scripts/strings/strmatch.m
+++ b/scripts/strings/strmatch.m
@@ -109,17 +109,18 @@ endfunction
 %!assert (strmatch ("apple pie", "apple"), [])
 %!assert (strmatch ("a ", "a"), 1)
 %!assert (strmatch ("a", "a \0", "exact"), 1)
 %!assert (strmatch ("a b", {"a b", "a c", "c d"}), 1)
 %!assert (strmatch ("", {"", "foo", "bar", ""}), [1, 4])
 %!assert (strmatch ('', { '', '% comment', 'var a = 5', ''}, "exact"), [1,4])
 
 ## Weird Matlab corner cases
-%!test <49601>
+%!test <*49601>
+%!test <*49601>
 %! assert (strmatch (" ", " "), 1);
 %! assert (strmatch (" ", "   "), 1);
 %! assert (strmatch ("  ", " "), []);
 %! assert (strmatch ("  ", "  "), 1);
 
 ## Test input validation
 %!error <Invalid call to strmatch> strmatch ()
 %!error <Invalid call to strmatch> strmatch ("a")
diff --git a/scripts/strings/strsplit.m b/scripts/strings/strsplit.m
--- a/scripts/strings/strsplit.m
+++ b/scripts/strings/strsplit.m
@@ -292,20 +292,23 @@ endfunction
 %! assert (m, {" \t "});
 
 ## Compatibility
 %! assert (strsplit ("", "a"), {""});
 %! assert (strsplit ("a", "a"), {"", ""});
 %! assert (strsplit ("aa", "a"), {"", ""});
 %! assert (strsplit ("aaa", "a"), {"", ""});
 
-%!assert <44641> (strsplit ("xxx<yyy", "<"), {"xxx", "yyy"})
-%!assert <44641> (strsplit ('xxx\yyy', '\'), {"xxx", "yyy"})
+%!assert <*44641> (strsplit ("xxx<yyy", "<"), {"xxx", "yyy"})
+%!assert <*44641> (strsplit ("xxx<yyy", "<"), {"xxx", "yyy"})
+%!assert <*44641> (strsplit ('xxx\yyy', '\'), {"xxx", "yyy"})
+%!assert <*44641> (strsplit ('xxx\yyy', '\'), {"xxx", "yyy"})
 
-%!assert <47403> (strsplit ('xxx+yyy', '+'), {"xxx", "yyy"})
+%!assert <*47403> (strsplit ('xxx+yyy', '+'), {"xxx", "yyy"})
+%!assert <*47403> (strsplit ('xxx+yyy', '+'), {"xxx", "yyy"})
 
 ## Test input validation
 %!error strsplit ()
 %!error strsplit ("abc", "b", true, 4)
 %!error <invalid parameter name, 'foo'> strsplit ("abc", "b", "foo", "true")
 %!error <S and DEL must be string values> strsplit (123, "b")
 %!error <COLLAPSEDELIMITERS must be a scalar value> strsplit ("abc", "def", "collapsedelimiters", ones (3,3))
 %!error <Invalid DELIMITERTYPE> strsplit ("abc", "b", "delimitertype", "foobar")
diff --git a/scripts/testfun/__run_test_suite__.m b/scripts/testfun/__run_test_suite__.m
--- a/scripts/testfun/__run_test_suite__.m
+++ b/scripts/testfun/__run_test_suite__.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {} __run_test_suite__ (@var{fcndirs}, @var{fixedtestdirs})
 ## Undocumented internal function.
 ## @end deftypefn
 
-function [pass, fail, xfail, xbug, skip, rtskip] = __run_test_suite__ (fcndirs, fixedtestdirs)
+function [pass, fail, xfail, xbug, skip, rtskip, regress] = __run_test_suite__ (fcndirs, fixedtestdirs)
 
   testsdir = __octave_config_info__ ("octtestsdir");
   libinterptestdir = fullfile (testsdir, "libinterp");
   liboctavetestdir = fullfile (testsdir, "liboctave");
   fixedtestdir = fullfile (testsdir, "fixed");
   fcnfiledir = __octave_config_info__ ("fcnfiledir");
   if (nargin == 0)
     fcndirs = { liboctavetestdir, libinterptestdir, fcnfiledir };
@@ -48,47 +48,52 @@ function [pass, fail, xfail, xbug, skip,
     warning ("on", "quiet");
     warning ("off", "Octave:deprecated-function");
     try
       fid = fopen (logfile, "wt");
       if (fid < 0)
         error ("__run_test_suite__: could not open %s for writing", logfile);
       endif
       test ("", "explain", fid);
-      dp = dn = dxf = dxb = dsk = drtsk = 0;
+      dp = dn = dxf = dxb = dsk = drtsk = drgrs = 0;
       puts ("\nIntegrated test scripts:\n\n");
       for i = 1:length (fcndirs)
-        [p, n, xf, xb, sk, rtsk] = run_test_script (fid, fcndirs{i});
+        [p, n, xf, xb, sk, rtsk, rgrs] = run_test_script (fid, fcndirs{i});
         dp += p;
         dn += n;
         dxf += xf;
         dxb += xb;
         dsk += sk;
         drtsk += rtsk;
+        drgrs += rgrs;
       endfor
       puts ("\nFixed test scripts:\n\n");
       for i = 1:length (fixedtestdirs)
-        [p, n, xf, xb, sk, rtsk] = run_test_dir (fid, fixedtestdirs{i});
+        [p, n, xf, xb, sk, rtsk, rgrs] = run_test_dir (fid, fixedtestdirs{i});
         dp += p;
         dn += n;
         dxf += xf;
         dxb += xb;
         dsk += sk;
         drtsk += rtsk;
+        drgrs += rgrs;
       endfor
       puts ("\nSummary:\n\n");
-      nfail = dn - dp - dxf - dxb;
+      nfail = dn - dp - dxf - dxb - drgrs;
       printf ("  %-30s %6d\n", "PASS", dp);
       printf ("  %-30s %6d\n", "FAIL", nfail);
       if (dxf > 0)
         printf ("  %-30s %6d\n", "XFAIL (expected failure)", dxf);
       endif
       if (dxb > 0)
         printf ("  %-30s %6d\n", "XFAIL (reported bug)", dxb);
       endif
+      if (drgrs > 0)
+        printf ("  %-30s %6d\n", "XFAIL (regression)", drgrs);
+      endif
       if (dsk > 0)
         printf ("  %-30s %6d\n", "SKIPPED (feature)", dsk);
       endif
       if (drtsk > 0)
         printf ("  %-30s %6d\n", "SKIPPED (run-time condition)", drtsk);
       endif
       puts ("\n");
       printf ("See the file %s for additional details.\n", logfile);
@@ -134,45 +139,49 @@ function [pass, fail, xfail, xbug, skip,
 
   if (nargout > 0)
     pass = dp;
     fail = nfail;
     xfail = dxf;
     xbug = dxb;
     skip = dsk;
     rtskip = drtsk;
+    regress = drgrs;
   endif
 
 endfunction
 
 function print_test_file_name (nm)
   filler = repmat (".", 1, 60-length (nm));
   printf ("  %s %s", nm, filler);
 endfunction
 
-function print_pass_fail (p, n, xf, xb, sk, rtsk)
+function print_pass_fail (p, n, xf, xb, sk, rtsk, rgrs)
 
-  if ((n + sk + rtsk) > 0)
+  if ((n + sk + rtsk + rgrs) > 0)
     printf (" PASS   %4d/%-4d", p, n);
-    nfail = n - p - xf - xb;
+    nfail = n - p - xf - xb - rgrs;
     if (nfail > 0)
       printf ("\n%71s %3d", "FAIL ", nfail);
     endif
     if (sk > 0)
       printf ("\n%71s %3d", "(missing feature) SKIP ", sk);
     endif
     if (rtsk > 0)
       printf ("\n%71s %3d", "(run-time condition) SKIP ", rtsk);
     endif
-    if (xf > 0)
-      printf ("\n%71s %3d", "(expected failure) XFAIL", xf);
+    if (rgrs > 0)
+      printf ("\n%71s %3d", "(regression) XFAIL", rgrs);
     endif
     if (xb > 0)
       printf ("\n%71s %3d", "(reported bug) XFAIL", xb);
     endif
+    if (xf > 0)
+      printf ("\n%71s %3d", "(expected failure) XFAIL", xf);
+    endif
   endif
   puts ("\n");
 
 endfunction
 
 function retval = has_functions (f)
 
   n = length (f);
@@ -203,84 +212,87 @@ function retval = has_tests (f)
   str = fread (fid, "*char")';
   fclose (fid);
   retval = ! isempty (regexp (str,
                               '^%!(assert|error|fail|test|xtest|warning)',
                               'lineanchors', 'once'));
 
 endfunction
 
-function [dp, dn, dxf, dxb, dsk, drtsk] = run_test_dir (fid, d)
+function [dp, dn, dxf, dxb, dsk, drtsk, drgrs] = run_test_dir (fid, d)
   global files_with_tests;
   global files_with_no_tests;
 
   lst = dir (d);
-  dp = dn = dxf = dxb = dsk = drtsk = 0;
+  dp = dn = dxf = dxb = dsk = drtsk = drgrs = 0;
   for i = 1:length (lst)
     nm = lst(i).name;
     if (lst(i).isdir
         && nm(1) != "." && ! strcmp (nm, "private") && nm(1) != "@")
-      [p, n, xf, xb, sk, rtsk] = run_test_dir (fid, [d, filesep, nm]);
+      [p, n, xf, xb, sk, rtsk, rgrs] = run_test_dir (fid, [d, filesep, nm]);
       dp += p;
       dn += n;
       dxf += xf;
       dxb += xb;
       dsk += sk;
       drtsk += rtsk;
+      drgrs += rgrs;
     endif
   endfor
 
   saved_dir = pwd ();
   unwind_protect
     cd (d);
     for i = 1:length (lst)
       nm = lst(i).name;
       if (length (nm) > 4 && strcmpi (nm((end-3):end), ".tst"))
         p = n = xf = xb = sk = rtsk = 0;
         ffnm = fullfile (d, nm);
         if (has_tests (ffnm))
           print_test_file_name (nm);
-          [p, n, xf, xb, sk, rtsk] = test (nm, "quiet", fid);
-          print_pass_fail (p, n, xf, xb, sk, rtsk);
+          [p, n, xf, xb, sk, rtsk, rgrs] = test (nm, "quiet", fid);
+          print_pass_fail (p, n, xf, xb, sk, rtsk, rgrs);
           files_with_tests(end+1) = ffnm;
         else
           files_with_no_tests(end+1) = ffnm;
         endif
         dp += p;
         dn += n;
         dxf += xf;
         dxb += xb;
         dsk += sk;
         drtsk += rtsk;
+        drgrs += rgrs;
       endif
     endfor
   unwind_protect_cleanup
     cd (saved_dir);
   end_unwind_protect
 
 endfunction
 
-function [dp, dn, dxf, dxb, dsk, drtsk] = run_test_script (fid, d)
+function [dp, dn, dxf, dxb, dsk, drtsk, drgrs] = run_test_script (fid, d)
   global files_with_tests;
   global files_with_no_tests;
   global topsrcdir;
   global topbuilddir;
 
   lst = dir (d);
-  dp = dn = dxf = dxb = dsk = drtsk = 0;
+  dp = dn = dxf = dxb = dsk = drtsk = drgrs = 0;
   for i = 1:length (lst)
     nm = lst(i).name;
     if (lst(i).isdir && nm(1) != ".")
-      [p, n, xf, xb, sk, rtsk] = run_test_script (fid, [d, filesep, nm]);
+      [p, n, xf, xb, sk, rtsk, rgrs] = run_test_script (fid, [d, filesep, nm]);
       dp += p;
       dn += n;
       dxf += xf;
       dxb += xb;
       dsk += sk;
       drtsk += rtsk;
+      drgrs += rgrs;
     endif
   endfor
 
   for i = 1:length (lst)
     nm = lst(i).name;
     ## Ignore hidden files
     if (nm(1) == '.')
       continue
@@ -291,24 +303,25 @@ function [dp, dn, dxf, dxb, dsk, drtsk] 
             && (   strcmpi (nm((end-3):end), "-tst")
                 || strcmpi (nm((end-3):end), ".tst"))))
       p = n = xf = xb = 0;
       ## Only run if it contains %!test, %!assert, %!error, %!fail, or %!warning
       if (has_tests (f))
         tmp = strrep (f, [topsrcdir, filesep], "");
         tmp = strrep (tmp, [topbuilddir, filesep], "");
         print_test_file_name (tmp);
-        [p, n, xf, xb, sk, rtsk] = test (f, "quiet", fid);
-        print_pass_fail (p, n, xf, xb, sk, rtsk);
+        [p, n, xf, xb, sk, rtsk, rgrs] = test (f, "quiet", fid);
+        print_pass_fail (p, n, xf, xb, sk, rtsk, rgrs);
         dp += p;
         dn += n;
         dxf += xf;
         dxb += xb;
         dsk += sk;
         drtsk += rtsk;
+        drgrs += rgrs;
         files_with_tests(end+1) = f;
       else
         ## To reduce the list length, only mark .cc files that contain
         ## DEFUN definitions.
         files_with_no_tests(end+1) = f;
       endif
     endif
   endfor
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {} {} test @var{name}
 ## @deftypefnx {} {} test @var{name} quiet|normal|verbose
 ## @deftypefnx {} {} test ("@var{name}", "quiet|normal|verbose", @var{fid})
 ## @deftypefnx {} {} test ("@var{name}", "quiet|normal|verbose", @var{fname})
 ## @deftypefnx {} {@var{success} =} test (@dots{})
-## @deftypefnx {} {[@var{n}, @var{nmax}, @var{nxfail}, @var{nbug}, @var{nskip}, @var{nrtskip}] =} test (@dots{})
+## @deftypefnx {} {[@var{n}, @var{nmax}, @var{nxfail}, @var{nbug}, @var{nskip}, @var{nrtskip}, @var{nregression}] =} test (@dots{})
 ## @deftypefnx {} {[@var{code}, @var{idx}] =} test ("@var{name}", "grabdemo")
 ## @deftypefnx {} {} test ([], "explain", @var{fid})
 ## @deftypefnx {} {} test ([], "explain", @var{fname})
 ##
 ## Perform built-in self-tests from the first file in the loadpath matching
 ## @var{name}.
 ##
 ## @code{test} can be called in either command or functional form.  The exact
@@ -78,18 +78,19 @@
 ## @var{fid}.
 ##
 ## When called with just a single output argument @var{success}, @code{test}
 ## returns true if all of the tests were successful.  If called with more
 ## than one output argument then the number of successful tests (@var{n}),
 ## the total number of tests in the file (@var{nmax}), the number of xtest
 ## failures (@var{nxfail}), the number of tests failed due known bugs
 ## (@var{nbug}), the number of tests skipped due to missing features
-## (@var{nskip}), and the number of tests skipped due to run-time
-## conditions (@var{nrtskip}) are returned.
+## (@var{nskip}), the number of tests skipped due to run-time
+## conditions (@var{nrtskip}), and the number of regressions
+## (@var{nregression}) are returned.
 ##
 ## Example
 ##
 ## @example
 ## @group
 ## test sind
 ## @result{}
 ## PASSES 5 out of 5 tests
@@ -115,17 +116,17 @@
 ##
 ## @seealso{assert, fail, demo, example, error}
 ## @end deftypefn
 
 ## Programming Note: All variables for test() must use the internal prefix "__".
 ## Shared variables are eval'ed into the current workspace and therefore might
 ## collide with the names used in the test.m function itself.
 
-function [__n, __nmax, __nxfail, __nbug, __nskip, __nrtskip] = test (__name, __flag = "normal", __fid = [])
+function [__n, __nmax, __nxfail, __nbug, __nskip, __nrtskip, __nregression] = test (__name, __flag = "normal", __fid = [])
 
   ## Output from test is prefixed by a "key" to quickly understand the issue.
   persistent __signal_fail  = "!!!!! ";
   persistent __signal_empty = "????? ";
   persistent __signal_block = "***** ";
   persistent __signal_file  = ">>>>> ";
   persistent __signal_skip  = "----- ";
 
@@ -292,17 +293,17 @@ function [__n, __nmax, __nxfail, __nbug,
     disp ([__signal_file, __file]);
   endif
 
   ## Assume all tests will pass.
   __all_success = true;
 
   ## Process each block separately, initially with no shared variables.
   __tests = __successes = 0;
-  __xfail = __xbug = __xskip = __xrtskip = 0;
+  __xfail = __xbug = __xskip = __xrtskip = __xregression = 0;
   __shared = " ";
   __shared_r = " ";
   __clearfcn = "";
   for __i = 1:numel (__blockidx)-1
 
     ## FIXME: Should other global settings be similarly saved and restored?
     orig_wstate = warning ();
     unwind_protect
@@ -327,16 +328,17 @@ function [__n, __nmax, __nxfail, __nbug,
       endif
 
       ## Assume the block will succeed.
       __success = true;
       __msg = [];
       __istest = false;
       __isxtest = false;
       __bug_id = "";
+      __fixed_bug = false;
 
 ### DEMO
 
       ## If in __grabdemo mode, then don't process any other block type.
       ## So that the other block types don't have to worry about
       ## this __grabdemo mode, the demo block processor grabs all block
       ## types and skips those which aren't demo blocks.
 
@@ -429,20 +431,27 @@ function [__n, __nmax, __nxfail, __nbug,
 
 ### ENDFUNCTION
 
       elseif (strcmp (__type, "endfunction"))
         ## endfunction simply declares the end of a previous function block.
         ## There is no processing to be done here, just skip to next block.
         __code = "";
 
-### ASSERT/FAIL
+### ASSERT
+### ASSERT <BUG-ID>
+### FAIL
+### FAIL <BUG-ID>
+###
+###   BUG-ID is a bug number from the bug tracker.  A prefix of '*'
+###   indicates a bug that has been fixed.  Tests that fail for fixed
+###   bugs are reported as regressions.
 
       elseif (strcmp (__type, "assert") || strcmp (__type, "fail"))
-        [__bug_id, __code] = getbugid (__code);
+        [__bug_id, __code, __fixed_bug] = getbugid (__code);
         if (isempty (__bug_id))
           __istest = true;
         else
           __isxtest = true;
         endif
         ## Put the keyword back on the code.
         __code = [__type __code];
         ## The code will be evaluated below as a test block.
@@ -524,37 +533,45 @@ function [__n, __nmax, __nxfail, __nbug,
           end_try_catch
           clear __test__;
         endif
         ## Code already processed.
         __code = "";
 
 ### TESTIF HAVE_FEATURE
 ### TESTIF HAVE_FEATURE ; RUNTIME_CONDITION
-### TESTIF HAVE_FEATURE <bug-id>
-### TESTIF HAVE_FEATURE ; RUNTIME_CONDITION <bug-id>
+### TESTIF HAVE_FEATURE <BUG-ID>
+### TESTIF HAVE_FEATURE ; RUNTIME_CONDITION <BUG-ID>
 ###
 ###   HAVE_FEATURE is a comma- or whitespace separated list of
 ###   macro names that may be checked with __have_feature__.
 ###
 ###   RUNTIME_CONDITION is an expression to evaluate to check
 ###   whether some condition is met when the test is executed.  For
 ###   example, have_window_system.
+###
+###   BUG-ID is a bug number from the bug tracker.  A prefix of '*'
+###   indicates a bug that has been fixed.  Tests that fail for fixed
+###   bugs are reported as regressions.
 
       elseif (strcmp (__type, "testif"))
         __e = regexp (__code, '.$', 'lineanchors', 'once');
         ## Strip any comment and bug-id from testif line before
         ## looking for features
         __feat_line = strtok (__code(1:__e), '#%');
         __idx1 = index (__feat_line, "<");
         if (__idx1)
           __tmp = __feat_line(__idx1+1:end);
           __idx2 = index (__tmp, ">");
           if (__idx2)
             __bug_id = __tmp(1:__idx2-1);
+            if (strncmp (__bug_id, "*", 1))
+              __bug_id = __bug_id(2:end);
+              __fixed_bug = true;
+            endif
             __feat_line = __feat_line(1:__idx1-1);
           endif
         endif
         __idx = index (__feat_line, ";");
         if (__idx)
           __runtime_feat_test = __feat_line(__idx+1:end);
           __feat_line = __feat_line(1:__idx-1);
         else
@@ -578,32 +595,41 @@ function [__n, __nmax, __nxfail, __nbug,
           endif
         else
           __xskip += 1;
           __code = ""; # Skip the code.
           __msg = [__signal_skip "skipped test (missing feature)\n"];
         endif
 
 ### TEST
-### TEST <bug-id>
+### TEST <BUG-ID>
+###
+###   BUG-ID is a bug number from the bug tracker.  A prefix of '*'
+###   indicates a bug that has been fixed.  Tests that fail for fixed
+###   bugs are reported as regressions.
 
       elseif (strcmp (__type, "test"))
-        [__bug_id, __code] = getbugid (__code);
+        [__bug_id, __code, __fixed_bug] = getbugid (__code);
         if (! isempty (__bug_id))
           __isxtest = true;
         else
           __istest = true;
         endif
         ## Code will be evaluated below.
 
-### XTEST <bug-id>
+### XTEST
+### XTEST <BUG-ID>
+###
+###   BUG-ID is a bug number from the bug tracker.  A prefix of '*'
+###   indicates a bug that has been fixed.  Tests that fail for fixed
+###   bugs are reported as regressions.
 
       elseif (strcmp (__type, "xtest"))
         __isxtest = true;
-        [__bug_id, __code] = getbugid (__code);
+        [__bug_id, __code, __fixed_bug] = getbugid (__code);
         ## Code will be evaluated below.
 
 ### Comment block.
 
       elseif (strcmp (__block(1:1), "#"))
         __code = ""; # skip the code
 
 ### Unknown block.
@@ -631,24 +657,37 @@ function [__n, __nmax, __nxfail, __nbug,
           endif
         catch
           if (isempty (lasterr ()))
             error ("test: empty error text, probably Ctrl-C --- aborting");
           else
             __success = false;
             if (__isxtest)
               if (isempty (__bug_id))
-                __xfail += 1;
-                __msg = "known failure";
+                if (__fixed_bug)
+                  __xregression += 1;
+                  __msg = "regression";
+                else
+                  __xfail += 1;
+                  __msg = "known failure";
+                endif
               else
-                __xbug += 1;
+                if (__fixed_bug)
+                  __xregression += 1;
+                else
+                  __xbug += 1;
+                endif
                 if (all (isdigit (__bug_id)))
                   __bug_id = ["http://octave.org/testfailure/?" __bug_id];
                 endif
-                __msg = ["known bug: " __bug_id];
+                if (__fixed_bug)
+                  __msg = ["regression: " __bug_id];
+                else
+                  __msg = ["known bug: " __bug_id];
+                endif
               endif
             else
               __msg = "test failed";
             endif
             __msg = [__signal_fail __msg "\n" lasterr()];
           endif
         end_try_catch
         clear __test__;
@@ -734,22 +773,23 @@ function [__n, __nmax, __nxfail, __nbug,
       printf ("%s%s has no tests available\n", __signal_empty, __file);
     endif
   elseif (__grabdemo)
     __n    = __demo_code;
     __nmax = __demo_idx;
   elseif (nargout == 1)
     __n = __all_success;
   else
-    __n      = __successes;
-    __nmax   = __tests;
+    __n = __successes;
+    __nmax = __tests;
     __nxfail = __xfail;
-    __nbug   = __xbug;
-    __nskip  = __xskip;
+    __nbug = __xbug;
+    __nskip = __xskip;
     __nrtskip = __xrtskip;
+    __nregression = __xregression;
   endif
 
 endfunction
 
 
 ## Create structure with fieldnames the name of the input variables.
 function s = var2struct (varargin)
   for i = 1:nargin
@@ -798,26 +838,31 @@ function [pattern, id, rest] = getpatter
     endif
   elseif (strncmp (str, "id=", 3))
     [id, rest] = strtok (str(4:end));
   endif
 
 endfunction
 
 ## Strip <bug-id> from '<pattern> code'.
-function [bug_id, rest] = getbugid (str)
+function [bug_id, rest, fixed] = getbugid (str)
 
   bug_id = "";
-  id = [];
   rest = str;
+  fixed = false;
+
   str = trimleft (str);
   if (! isempty (str) && str(1) == "<")
     close = index (str, ">");
     if (close)
       bug_id = str(2:close-1);
+      if (strncmp (bug_id, "*", 1))
+        bug_id = bug_id(2:end);
+        fixed = true;
+      endif
       rest = str(close+1:end);
     endif
   endif
 
 endfunction
 
 
 ## Strip '.*prefix:' from '.*prefix: msg\n' and strip trailing blanks.
diff --git a/scripts/time/datestr.m b/scripts/time/datestr.m
--- a/scripts/time/datestr.m
+++ b/scripts/time/datestr.m
@@ -327,17 +327,18 @@ endfunction
 ## Accommodate this, although no other UNIX-based OS does this.
 %!test
 %! obs = toupper (datestr (testtime,14));
 %! assert (obs, " 2:33:17 AM");
 %!assert (datestr (testtime,15), "02:33")
 %!test
 %! obs = toupper (datestr (testtime,16));
 %! assert (obs, " 2:33 AM");
-%!test <48071>
+%!test <*48071>
+%!test <*48071>
 %! testtime2 = testtime;
 %! testtime2(4) = 15;
 %! obs = toupper (datestr (testtime2,16));
 %! assert (obs, " 3:33 PM");
 %!assert (datestr (testtime,17), "Q4-05")
 %!assert (datestr (testtime,18), "Q4")
 %!assert (datestr (testtime,19), "18/12")
 %!assert (datestr (testtime,20), "18/12/05")
diff --git a/scripts/time/datevec.m b/scripts/time/datevec.m
--- a/scripts/time/datevec.m
+++ b/scripts/time/datevec.m
@@ -357,17 +357,18 @@ endfunction
 %!assert (datevec ("06/01/2015 3:07:12.1 PM", "mm/dd/yyyy HH:MM:SS.FFF PM"),
 %!        [2015,6,1,15,7,12.1])
 %!assert (datevec ("06/01/2015 3:07:12.12 AM", "mm/dd/yyyy HH:MM:SS.FFF PM"),
 %!        [2015,6,1,3,7,12.12])
 %!assert (datevec ("06/01/2015 3:07:12.12 PM", "mm/dd/yyyy HH:MM:SS.FFF PM"),
 %!        [2015,6,1,15,7,12.12])
 
 ## Test structure of return value
-%!test <42334>
+%!test <*42334>
+%!test <*42334>
 %! [~, ~, d] = datevec ([1 2; 3 4]);
 %! assert (d, [1 2; 3 4]);
 
 ## Other tests
 %!assert (datenum (datevec ([-1e4:1e4])), [-1e4:1e4]')
 %!test
 %! t = linspace (-2e5, 2e5, 10993);
 %! assert (all (abs (datenum (datevec (t)) - t') < 1e-5));
