# HG changeset patch
# User Rik <rik@octave.org>
# Date 1391895300 28800
#      Sat Feb 08 13:35:00 2014 -0800
# Node ID e76d50d65278f53f40035b6a0ad3152fda2cc2c7
# Parent  92ec75319e736981fa93c1800aff24c5d23b876c
# Parent  888cd8f62c6799dddbd413a1c6b9369e3971bf61
maint: Periodic merge of gui-release to default.

diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -1650,17 +1650,17 @@ case $canonical_host_type in
   alpha*-dec-osf*)
     CPICFLAG=
     CXXPICFLAG=
     FPICFLAG=
     SH_LDFLAGS="-shared -Wl,-expect_unresolved -Wl,'*'"
   ;;
   *-*-darwin*)
     DL_LDFLAGS='-bundle -bundle_loader $(top_builddir)/libinterp/octave $(LDFLAGS)'
-    MKOCTFILE_DL_LDFLAGS='-bundle -bundle_loader $$BINDIR/octave-$$OCTAVE_VERSION$$EXEEXT'
+    MKOCTFILE_DL_LDFLAGS='-bundle -bundle_loader $(bindir)/octave-$(version)$(EXEEXT)'
     SH_LDFLAGS='-dynamiclib -single_module $(LDFLAGS)'
     case $canonical_host_type in
       powerpc-*)
         CXXPICFLAG=
         CPICFLAG=
         FPICFLAG=
       ;;
     esac
diff --git a/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.cpp b/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.cpp
--- a/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.cpp
+++ b/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.cpp
@@ -54,16 +54,17 @@ void QUnixTerminalImpl::initialize()
     font.setStyleHint(QFont::TypeWriter);
     font.setPointSize(11);
 #else
     QFont font = QFont("Monospace");
     font.setStyleHint(QFont::TypeWriter);
     font.setPointSize(10);
 #endif
     setTerminalFont(font);
+    setFocusPolicy (Qt::StrongFocus);
     setFocusProxy(m_terminalView);
     setFocus(Qt::OtherFocusReason);
 
     m_kpty = new KPty();
     m_kpty->open();
 
     m_terminalModel = new TerminalModel(m_kpty);
     m_terminalModel->setAutoClose(true);
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -912,77 +912,65 @@ main_window::read_settings (void)
       _current_directory_combo_box->addItem (curr_dirs.at (i));
     }
   emit settings_changed (settings);
 }
 
 void
 main_window::set_window_layout (QSettings *settings)
 {
-  QList<octave_dock_widget *> float_and_visible;
+#if ! defined (Q_OS_WIN32)
+  restoreState (settings->value ("MainWindow/windowState").toByteArray ());
+  restoreGeometry (settings->value ("MainWindow/geometry").toByteArray ());
+#endif
 
   // Restore the geometry of all dock-widgets
   foreach (octave_dock_widget *widget, dock_widget_list ())
     {
       QString name = widget->objectName ();
 
       if (! name.isEmpty ())
         {
           bool floating = settings->value
               ("DockWidgets/" + name + "Floating", false).toBool ();
           bool visible = settings->value
               ("DockWidgets/" + name + "Visible", true).toBool ();
 
-#if defined (Q_OS_WIN32)
           // If floating, make window from widget.
           if (floating)
             widget->make_window ();
           else if (! widget->parent ())  // should not be floating but is
             widget->make_widget (false); // no docking, just reparent
-#else
+#if ! defined (Q_OS_WIN32)
           // restore geometry
           QVariant val = settings->value ("DockWidgets/" + name);
           widget->restoreGeometry (val.toByteArray ());
 #endif
           // make widget visible if desired
           if (floating && visible)              // floating and visible
-            float_and_visible.append (widget);  // not show before main win
+            {
+              if (settings->value ("DockWidgets/" + widget->objectName () + "_minimized").toBool ())
+                widget->showMinimized ();
+              else
+                widget->setVisible (true);
+            }
           else
             {
               widget->make_widget ();
               widget->setVisible (visible);       // not floating -> show
             }
         }
     }
 
-#if ! defined (Q_OS_WIN32)
-  // show main first but minimized to avoid flickering,
-  // otherwise the name of a floating widget is shown in a global menu bar
-  showMinimized ();
-  // hide again, otherwise the geometry is not exactly restored
-  hide ();
-#endif
-  // restore geomoetry of main window
+#if defined (Q_OS_WIN32)
   restoreState (settings->value ("MainWindow/windowState").toByteArray ());
   restoreGeometry (settings->value ("MainWindow/geometry").toByteArray ());
-  // show main window
+#endif
+
   show ();
-
-  // show floating widgets after main win to ensure "Octave" in central menu
-  foreach (octave_dock_widget *widget, float_and_visible)
-    {
-#if ! defined (Q_OS_WIN32)
-      widget->make_window ();
-#endif
-      if (settings->value ("DockWidgets/" + widget->objectName () + "_minimized").toBool ())
-        widget->showMinimized ();
-      else
-        widget->setVisible (true);
-    }
-
 }
 
 void
 main_window::write_settings (void)
 {
   QSettings *settings = resource_manager::get_settings ();
   if (!settings)
     {
diff --git a/libgui/src/terminal-dock-widget.cc b/libgui/src/terminal-dock-widget.cc
--- a/libgui/src/terminal-dock-widget.cc
+++ b/libgui/src/terminal-dock-widget.cc
@@ -33,16 +33,18 @@ terminal_dock_widget::terminal_dock_widg
   terminal->setObjectName ("OctaveTerminal");
   terminal->setFocusPolicy (Qt::StrongFocus);
 
   setObjectName ("TerminalDockWidget");
   setWindowIcon (QIcon (":/actions/icons/logo.png"));
   set_title (tr ("Command Window"));
 
   setWidget (terminal);
+  setFocusProxy (terminal);
+  setFocusPolicy (Qt::StrongFocus);
 
   connect (terminal, SIGNAL (interrupt_signal (void)),
            this, SLOT (terminal_interrupt ()));
 }
 
 bool
 terminal_dock_widget::has_focus (void) const
 {
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -201,71 +201,63 @@ information.\n\
 
   if (issparse)
     {
       if (arg_is_empty < 0)
         return retval;
       else if (arg_is_empty > 0)
         return octave_value_list (5, SparseMatrix ());
 
-      ColumnVector Qinit;
-      if (nargout < 4)
-        {
-          Qinit.resize (nc);
-          for (octave_idx_type i = 0; i < nc; i++)
-            Qinit (i) = i;
-        }
-
       if (arg.is_real_type ())
         {
+
           SparseMatrix m = arg.sparse_matrix_value ();
 
-          switch (nargout)
+          if ( nargout < 4 )
             {
-            case 0:
-            case 1:
-            case 2:
-              {
-                SparseLU fact (m, Qinit, thres, false, true);
+
+              ColumnVector Qinit;
+              Qinit.resize (nc);
+              for (octave_idx_type i = 0; i < nc; i++)
+                Qinit (i) = i;
+              SparseLU fact (m, Qinit, thres, false, true);
 
-                if (nargout < 2)
+              if ( nargout < 2 )
                   retval(0) = fact.Y ();
-                else
-                  {
-                    PermMatrix P = fact.Pr_mat ();
-                    SparseMatrix L = P.transpose () * fact.L ();
-                    retval(1) = octave_value (fact.U (),
-                                              MatrixType (MatrixType::Upper));
+              else
+                {
+
+                  retval(1)
+                    = octave_value (
+                        fact.U () * fact.Pc_mat ().transpose (),                    
+                        MatrixType (MatrixType::Permuted_Upper,
+                                    nc, fact.col_perm ()));
 
-                    retval(0)
-                      = octave_value (L, MatrixType (MatrixType::Permuted_Lower,
-                                                     nr, fact.row_perm ()));
-                  }
-              }
-              break;
-
-            case 3:
-              {
-                SparseLU fact (m, Qinit, thres, false, true);
+                  PermMatrix P = fact.Pr_mat ();
+                  SparseMatrix L = fact.L ();
+                  if ( nargout < 3 )
+                      retval(0)
+                        = octave_value ( P.transpose () * L,
+                            MatrixType (MatrixType::Permuted_Lower,
+                                        nr, fact.row_perm ()));
+                  else
+                    {
+                      retval(0) = L;
+                      if ( vecout )
+                        retval(2) = fact.Pr_vec();
+                      else
+                        retval(2) = P;
+                    }
 
-                if (vecout)
-                  retval(2) = fact.Pr_vec ();
-                else
-                  retval(2) = fact.Pr_mat ();
+                }
 
-                retval(1) = octave_value (fact.U (),
-                                          MatrixType (MatrixType::Upper));
-                retval(0) = octave_value (fact.L (),
-                                          MatrixType (MatrixType::Lower));
-              }
-              break;
+            }
+          else
+            {
 
-            case 4:
-            default:
-              {
                 SparseLU fact (m, thres, scale);
 
                 if (scale)
                   retval(4) = fact.R ();
 
                 if (vecout)
                   {
                     retval(3) = fact.Pc_vec ();
@@ -275,67 +267,67 @@ information.\n\
                   {
                     retval(3) = fact.Pc_mat ();
                     retval(2) = fact.Pr_mat ();
                   }
                 retval(1) = octave_value (fact.U (),
                                           MatrixType (MatrixType::Upper));
                 retval(0) = octave_value (fact.L (),
                                           MatrixType (MatrixType::Lower));
-              }
-              break;
             }
+
         }
       else if (arg.is_complex_type ())
         {
           SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
-          switch (nargout)
+          if ( nargout < 4 )
             {
-            case 0:
-            case 1:
-            case 2:
-              {
-                SparseComplexLU fact (m, Qinit, thres, false, true);
+
+              ColumnVector Qinit;
+              Qinit.resize (nc);
+              for (octave_idx_type i = 0; i < nc; i++)
+                Qinit (i) = i;
+              SparseComplexLU fact (m, Qinit, thres, false, true);
+
+              if ( nargout < 2 )
 
-                if (nargout < 2)
                   retval(0) = fact.Y ();
-                else
-                  {
-                    PermMatrix P = fact.Pr_mat ();
-                    SparseComplexMatrix L = P.transpose () * fact.L ();
-                    retval(1) = octave_value (fact.U (),
-                                              MatrixType (MatrixType::Upper));
+
+              else
+                {
+
+                  retval(1)
+                    = octave_value (
+                        fact.U () * fact.Pc_mat ().transpose (),                    
+                        MatrixType (MatrixType::Permuted_Upper,
+                                    nc, fact.col_perm ()));
 
-                    retval(0)
-                      = octave_value (L, MatrixType (MatrixType::Permuted_Lower,
-                                                     nr, fact.row_perm ()));
-                  }
-              }
-              break;
-
-            case 3:
-              {
-                SparseComplexLU fact (m, Qinit, thres, false, true);
+                  PermMatrix P = fact.Pr_mat ();
+                  SparseComplexMatrix L = fact.L ();
+                  if ( nargout < 3 )
+                      retval(0)
+                        = octave_value ( P.transpose () * L,
+                            MatrixType (MatrixType::Permuted_Lower,
+                                        nr, fact.row_perm ()));
+                  else
+                    {
+                      retval(0) = L;
+                      if ( vecout )
+                        retval(2) = fact.Pr_vec();
+                      else
+                        retval(2) = P;
+                    }
 
-                if (vecout)
-                  retval(2) = fact.Pr_vec ();
-                else
-                  retval(2) = fact.Pr_mat ();
+                }
 
-                retval(1) = octave_value (fact.U (),
-                                          MatrixType (MatrixType::Upper));
-                retval(0) = octave_value (fact.L (),
-                                          MatrixType (MatrixType::Lower));
-              }
-              break;
+            }
+          else
+            {
 
-            case 4:
-            default:
-              {
                 SparseComplexLU fact (m, thres, scale);
 
                 if (scale)
                   retval(4) = fact.R ();
 
                 if (vecout)
                   {
                     retval(3) = fact.Pc_vec ();
@@ -345,19 +337,18 @@ information.\n\
                   {
                     retval(3) = fact.Pc_mat ();
                     retval(2) = fact.Pr_mat ();
                   }
                 retval(1) = octave_value (fact.U (),
                                           MatrixType (MatrixType::Upper));
                 retval(0) = octave_value (fact.L (),
                                           MatrixType (MatrixType::Lower));
-              }
-              break;
             }
+
         }
       else
         gripe_wrong_type_arg ("lu", arg);
     }
   else
     {
       if (arg_is_empty < 0)
         return retval;
@@ -577,16 +568,29 @@ information.\n\
 %!test
 %! [l u p] = lu (single ([1, 2; 3, 4; 5, 6]));
 %! assert (l, single ([1, 0; 1/5, 1; 3/5, 1/2]), sqrt (eps ("single")));
 %! assert (u, single ([5, 6; 0, 4/5]), sqrt (eps ("single")));
 %! assert (p(:,:), single ([0, 0, 1; 1, 0, 0; 0 1 0]), sqrt (eps ("single")));
 
 %!error lu ()
 %!error <can not define pivoting threshold> lu ([1, 2; 3, 4], 2)
+
+%!test
+%! Bi = [1 2 3 4 5 2 3 6 7 8 4 5 7 8 9];
+%! Bj = [1 3 4 5 6 7 8 9 11 12 13 14 15 16 17];
+%! Bv = [1 1 1 1 1 1 -1 1 1 1 1 -1 1 -1 1];
+%! B = sparse (Bi, Bj, Bv);
+%! [L, U] = lu (B);
+%! assert (L*U, B);
+%! [L, U, P] = lu(B);
+%! assert (P'*L*U, B);
+%! [L, U, P, Q] = lu (B);
+%! assert (P'*L*U*Q', B);
+
 */
 
 static
 bool check_lu_dims (const octave_value& l, const octave_value& u,
                     const octave_value& p)
 {
   octave_idx_type m = l.rows ();
   octave_idx_type k = u.rows ();
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -3976,39 +3976,41 @@ to produce a more readable output with l
 }
 
 DEFUN (fixed_point_format, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} fixed_point_format ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} fixed_point_format (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} fixed_point_format (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will\n\
-use a scaled format to print matrix values such that the largest\n\
-element may be written with a single leading digit with the scaling\n\
-factor is printed on the first line of output.  For example:\n\
+use a scaled format to print matrix values.\n\
+\n\
+The scaled format prints a scaling factor on the first line of output chosen\n\
+such that the largest matrix element can be written with a single leading\n\
+digit.  For example:\n\
 \n\
 @example\n\
 @group\n\
-octave:1> logspace (1, 7, 5)'\n\
+logspace (1, 7, 5)'\n\
 ans =\n\
 \n\
   1.0e+07  *\n\
 \n\
   0.00000\n\
   0.00003\n\
   0.00100\n\
   0.03162\n\
   1.00000\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
-Notice that first value appears to be zero when it is actually 1.  For\n\
-this reason, you should be careful when setting\n\
-@code{fixed_point_format} to a nonzero value.\n\
+Notice that the first value appears to be 0 when it is actually 1.  Because\n\
+of the possibilty for confusion you should be careful about enabling\n\
+@code{fixed_point_format}.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.  \n\
 The original variable value is restored when exiting the function.\n\
 @seealso{format, output_max_field_width, output_precision}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (fixed_point_format);
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -361,18 +361,18 @@ gen_matrix:
       else
         return octave_rand::nd_array (dims);
     }
 }
 
 DEFUN (rand, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} rand (@var{n})\n\
-@deftypefnx {Built-in Function} {} rand (@var{n}, @var{m}, @dots{})\n\
-@deftypefnx {Built-in Function} {} rand ([@var{n} @var{m} @dots{}])\n\
+@deftypefnx {Built-in Function} {} rand (@var{m}, @var{n}, @dots{})\n\
+@deftypefnx {Built-in Function} {} rand ([@var{m} @var{n} @dots{}])\n\
 @deftypefnx {Built-in Function} {@var{v} =} rand (\"state\")\n\
 @deftypefnx {Built-in Function} {} rand (\"state\", @var{v})\n\
 @deftypefnx {Built-in Function} {} rand (\"state\", \"reset\")\n\
 @deftypefnx {Built-in Function} {@var{v} =} rand (\"seed\")\n\
 @deftypefnx {Built-in Function} {} rand (\"seed\", @var{v})\n\
 @deftypefnx {Built-in Function} {} rand (\"seed\", \"reset\")\n\
 @deftypefnx {Built-in Function} {} rand (@dots{}, \"single\")\n\
 @deftypefnx {Built-in Function} {} rand (@dots{}, \"double\")\n\
@@ -548,18 +548,18 @@ classes.\n\
 %!assert (! isequal (__rand_sample__ (-1), __rand_sample__ (-2)))
 */
 
 static std::string current_distribution = octave_rand::distribution ();
 
 DEFUN (randn, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} randn (@var{n})\n\
-@deftypefnx {Built-in Function} {} randn (@var{n}, @var{m}, @dots{})\n\
-@deftypefnx {Built-in Function} {} randn ([@var{n} @var{m} @dots{}])\n\
+@deftypefnx {Built-in Function} {} randn (@var{m}, @var{n}, @dots{})\n\
+@deftypefnx {Built-in Function} {} randn ([@var{m} @var{n} @dots{}])\n\
 @deftypefnx {Built-in Function} {@var{v} =} randn (\"state\")\n\
 @deftypefnx {Built-in Function} {} randn (\"state\", @var{v})\n\
 @deftypefnx {Built-in Function} {} randn (\"state\", \"reset\")\n\
 @deftypefnx {Built-in Function} {@var{v} =} randn (\"seed\")\n\
 @deftypefnx {Built-in Function} {} randn (\"seed\", @var{v})\n\
 @deftypefnx {Built-in Function} {} randn (\"seed\", \"reset\")\n\
 @deftypefnx {Built-in Function} {} randn (@dots{}, \"single\")\n\
 @deftypefnx {Built-in Function} {} randn (@dots{}, \"double\")\n\
@@ -620,18 +620,18 @@ J. Statistical Software, vol 5, 2000,\n\
 %!   assert (skewness (x), 0, 0.02);
 %!   assert (kurtosis (x), 0, 0.04);
 %! endif
 */
 
 DEFUN (rande, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} rande (@var{n})\n\
-@deftypefnx {Built-in Function} {} rande (@var{n}, @var{m}, @dots{})\n\
-@deftypefnx {Built-in Function} {} rande ([@var{n} @var{m} @dots{}])\n\
+@deftypefnx {Built-in Function} {} rande (@var{m}, @var{n}, @dots{})\n\
+@deftypefnx {Built-in Function} {} rande ([@var{m} @var{n} @dots{}])\n\
 @deftypefnx {Built-in Function} {@var{v} =} rande (\"state\")\n\
 @deftypefnx {Built-in Function} {} rande (\"state\", @var{v})\n\
 @deftypefnx {Built-in Function} {} rande (\"state\", \"reset\")\n\
 @deftypefnx {Built-in Function} {@var{v} =} rande (\"seed\")\n\
 @deftypefnx {Built-in Function} {} rande (\"seed\", @var{v})\n\
 @deftypefnx {Built-in Function} {} rande (\"seed\", \"reset\")\n\
 @deftypefnx {Built-in Function} {} rande (@dots{}, \"single\")\n\
 @deftypefnx {Built-in Function} {} rande (@dots{}, \"double\")\n\
@@ -693,18 +693,18 @@ J. Statistical Software, vol 5, 2000,\n\
 %!   assert (skewness (x), 2, 0.06);
 %!   assert (kurtosis (x), 6, 0.7);
 %! endif
 */
 
 DEFUN (randg, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} randg (@var{n})\n\
-@deftypefnx {Built-in Function} {} randg (@var{n}, @var{m}, @dots{})\n\
-@deftypefnx {Built-in Function} {} randg ([@var{n} @var{m} @dots{}])\n\
+@deftypefnx {Built-in Function} {} randg (@var{m}, @var{n}, @dots{})\n\
+@deftypefnx {Built-in Function} {} randg ([@var{m} @var{n} @dots{}])\n\
 @deftypefnx {Built-in Function} {@var{v} =} randg (\"state\")\n\
 @deftypefnx {Built-in Function} {} randg (\"state\", @var{v})\n\
 @deftypefnx {Built-in Function} {} randg (\"state\", \"reset\")\n\
 @deftypefnx {Built-in Function} {@var{v} =} randg (\"seed\")\n\
 @deftypefnx {Built-in Function} {} randg (\"seed\", @var{v})\n\
 @deftypefnx {Built-in Function} {} randg (\"seed\", \"reset\")\n\
 @deftypefnx {Built-in Function} {} randg (@dots{}, \"single\")\n\
 @deftypefnx {Built-in Function} {} randg (@dots{}, \"double\")\n\
@@ -965,18 +965,18 @@ classes.\n\
 %!   assert (skewness (x), 2/sqrt (a), 0.05);
 %!   assert (kurtosis (x), 6/a,        0.2);
 %! endif
 */
 
 DEFUN (randp, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} randp (@var{l}, @var{n})\n\
-@deftypefnx {Built-in Function} {} randp (@var{l}, @var{n}, @var{m}, @dots{})\n\
-@deftypefnx {Built-in Function} {} randp (@var{l}, [@var{n} @var{m} @dots{}])\n\
+@deftypefnx {Built-in Function} {} randp (@var{l}, @var{m}, @var{n}, @dots{})\n\
+@deftypefnx {Built-in Function} {} randp (@var{l}, [@var{m} @var{n} @dots{}])\n\
 @deftypefnx {Built-in Function} {@var{v} =} randp (\"state\")\n\
 @deftypefnx {Built-in Function} {} randp (\"state\", @var{v})\n\
 @deftypefnx {Built-in Function} {} randp (\"state\", \"reset\")\n\
 @deftypefnx {Built-in Function} {@var{v} =} randp (\"seed\")\n\
 @deftypefnx {Built-in Function} {} randp (\"seed\", @var{v})\n\
 @deftypefnx {Built-in Function} {} randp (\"seed\", \"reset\")\n\
 @deftypefnx {Built-in Function} {} randp (@dots{}, \"single\")\n\
 @deftypefnx {Built-in Function} {} randp (@dots{}, \"double\")\n\
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -901,37 +901,35 @@ ANY_INCLUDING_NL (.|{NL})
 
 <DQ_STRING_START>"\\v" {
     curr_lexer->lexer_debug ("<DQ_STRING_START>\"\\\\v\"");
 
     curr_lexer->current_input_column += yyleng;
     curr_lexer->string_text += '\v';
   }
 
-<DQ_STRING_START>(\.\.\.){S}*{NL} |
-<DQ_STRING_START>(\.\.\.){S}*{CCHAR}{ANY_EXCEPT_NL}*{NL} {
-    curr_lexer->lexer_debug ("<DQ_STRING_START>(\\.\\.\\.){S}*{NL}|<DQ_STRING_START>(\\.\\.\\.){S}*{CCHAR}{ANY_EXCEPT_NL}*{NL}");
+<DQ_STRING_START>(\.\.\.){S}*{NL} {
+    curr_lexer->lexer_debug ("<DQ_STRING_START>(\\.\\.\\.){S}*{NL}");
 
     static const char *msg = "'...' continuations in double-quoted character strings are obsolete and will not be allowed in a future version of Octave; please use '\\' instead";
 
     std::string nm = curr_lexer->fcn_file_full_name;
 
     if (nm.empty ())
       warning_with_id ("Octave:deprecated-syntax", "%s", msg);
     else
       warning_with_id ("Octave:deprecated-syntax",
                        "%s; near line %d of file '%s'", msg,
                        curr_lexer->input_line_number, nm.c_str ());
 
     HANDLE_STRING_CONTINUATION;
   }
 
-<DQ_STRING_START>\\{S}+{NL} |
-<DQ_STRING_START>\\{S}*{CCHAR}{ANY_EXCEPT_NL}*{NL} {
-    curr_lexer->lexer_debug ("<DQ_STRING_START>\\\\{S}+{NL}|<DQ_STRING_START>\\\\{S}*{CCHAR}{ANY_EXCEPT_NL}*{NL}");
+<DQ_STRING_START>\\{S}+{NL} {
+    curr_lexer->lexer_debug ("<DQ_STRING_START>\\\\{S}+{NL}");
 
     static const char *msg = "white space and comments after continuation markers in double-quoted character strings are obsolete and will not be allowed in a future version of Octave";
 
     std::string nm = curr_lexer->fcn_file_full_name;
 
     if (nm.empty ())
       warning_with_id ("Octave:deprecated-syntax", "%s", msg);
     else
diff --git a/liboctave/numeric/sparse-base-lu.cc b/liboctave/numeric/sparse-base-lu.cc
--- a/liboctave/numeric/sparse-base-lu.cc
+++ b/liboctave/numeric/sparse-base-lu.cc
@@ -27,31 +27,31 @@ along with Octave; see the file COPYING.
 
 #include "sparse-base-lu.h"
 
 template <class lu_type, class lu_elt_type, class p_type, class p_elt_type>
 lu_type
 sparse_base_lu <lu_type, lu_elt_type, p_type, p_elt_type> :: Y (void) const
 {
   octave_idx_type nr = Lfact.rows ();
-  octave_idx_type nc = Ufact.rows ();
-  octave_idx_type rcmin = (nr > nc ? nr : nc);
+  octave_idx_type nz = Lfact.cols ();
+  octave_idx_type nc = Ufact.cols ();
 
-  lu_type Yout (nr, nc, Lfact.nnz () + Ufact.nnz ());
+  lu_type Yout (nr, nc, Lfact.nnz () + Ufact.nnz () - (nr<nz?nr:nz));
   octave_idx_type ii = 0;
   Yout.xcidx (0) = 0;
 
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = Ufact.cidx (j); i < Ufact.cidx (j + 1); i++)
         {
           Yout.xridx (ii) = Ufact.ridx (i);
           Yout.xdata (ii++) = Ufact.data (i);
         }
-      if (j < rcmin)
+      if (j < nz)
         {
           // Note the +1 skips the 1.0 on the diagonal
           for (octave_idx_type i = Lfact.cidx (j) + 1;
                i < Lfact.cidx (j +1); i++)
             {
               Yout.xridx (ii) = Lfact.ridx (i);
               Yout.xdata (ii++) = Lfact.data (i);
             }
diff --git a/scripts/general/interp1.m b/scripts/general/interp1.m
--- a/scripts/general/interp1.m
+++ b/scripts/general/interp1.m
@@ -17,66 +17,71 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{yi} =} interp1 (@var{x}, @var{y}, @var{xi})
 ## @deftypefnx {Function File} {@var{yi} =} interp1 (@var{y}, @var{xi})
 ## @deftypefnx {Function File} {@var{yi} =} interp1 (@dots{}, @var{method})
 ## @deftypefnx {Function File} {@var{yi} =} interp1 (@dots{}, @var{extrap})
+## @deftypefnx {Function File} {@var{yi} =} interp1 (@dots{}, "left")
+## @deftypefnx {Function File} {@var{yi} =} interp1 (@dots{}, "right")
 ## @deftypefnx {Function File} {@var{pp} =} interp1 (@dots{}, "pp")
 ##
-## One-dimensional interpolation.  Interpolates to determine the value of
-## @var{yi} at the points, @var{xi}.  If not specified, @var{x} is taken
-## to be the indices of @var{y}.  If @var{y} is a matrix or an N-dimensional
-## array, the interpolation is performed on each column of @var{y}.
+## One-dimensional interpolation.
+##
+## Interpolate input data to determine the value of @var{yi} at the points
+## @var{xi}.  If not specified, @var{x} is taken to be the indices of @var{y}.
+## If @var{y} is a matrix or an N-dimensional array, the interpolation is
+## performed on each column of @var{y}.
 ##
 ## Method is one of:
 ##
 ## @table @asis
 ## @item @qcode{"nearest"}
-## Return the nearest neighbor.
+## Return the nearest neighbor
 ##
 ## @item @qcode{"linear"}
 ## Linear interpolation from nearest neighbors
 ##
 ## @item @qcode{"pchip"}
 ## Piecewise cubic Hermite interpolating polynomial
 ##
 ## @item @qcode{"cubic"}
 ## Cubic interpolation (same as @code{pchip})
 ##
 ## @item @qcode{"spline"}
 ## Cubic spline interpolation---smooth first and second derivatives
 ## throughout the curve
 ## @end table
 ##
-## Appending '*' to the start of the above method forces @code{interp1}
+## Adding '*' to the start of any method above forces @code{interp1}
 ## to assume that @var{x} is uniformly spaced, and only @code{@var{x}(1)}
 ## and @code{@var{x}(2)} are referenced.  This is usually faster,
 ## and is never slower.  The default method is @qcode{"linear"}.
 ##
 ## If @var{extrap} is the string @qcode{"extrap"}, then extrapolate values
-## beyond the endpoints.  If @var{extrap} is a number, replace values beyond
-## the endpoints with that number.  If @var{extrap} is missing, assume NA.
+## beyond the endpoints using the current @var{method}.  If @var{extrap} is a
+## number, then replace values beyond the endpoints with that number.  When
+## unspecified, @var{extrap} defaults to NA.
 ##
-## If the string argument @qcode{"pp"} is specified, then @var{xi} should not be
-## supplied and @code{interp1} returns the piecewise polynomial that
-## can later be used with @code{ppval} to evaluate the interpolation.
+## If the string argument @qcode{"pp"} is specified, then @var{xi} should not
+## be supplied and @code{interp1} returns a piecewise polynomial object.  This 
+## object can later be used with @code{ppval} to evaluate the interpolation.
 ## There is an equivalence, such that @code{ppval (interp1 (@var{x},
 ## @var{y}, @var{method}, @qcode{"pp"}), @var{xi}) == interp1 (@var{x}, @var{y},
 ## @var{xi}, @var{method}, @qcode{"extrap"})}.
 ##
 ## Duplicate points in @var{x} specify a discontinuous interpolant.  There
 ## may be at most 2 consecutive points with the same value.
 ## If @var{x} is increasing, the default discontinuous interpolant is
 ## right-continuous.  If @var{x} is decreasing, the default discontinuous
 ## interpolant is left-continuous.
 ## The continuity condition of the interpolant may be specified by using
-## the options, @qcode{"-left"} or @qcode{"-right"}, to select a left-continuous
+## the options, @qcode{"left"} or @qcode{"right"}, to select a left-continuous
 ## or right-continuous interpolant, respectively.
 ## Discontinuous interpolation is only allowed for @qcode{"nearest"} and
 ## @qcode{"linear"} methods; in all other cases, the @var{x}-values must be
 ## unique.
 ##
 ## An example of the use of @code{interp1} is
 ##
 ## @example
@@ -90,17 +95,17 @@
 ## cub = interp1 (xp, yp, xf, "cubic");
 ## near = interp1 (xp, yp, xf, "nearest");
 ## plot (xf, yf, "r", xf, lin, "g", xf, spl, "b",
 ##       xf, cub, "c", xf, near, "m", xp, yp, "r*");
 ## legend ("original", "linear", "spline", "cubic", "nearest");
 ## @end group
 ## @end example
 ##
-## @seealso{interpft}
+## @seealso{interpft, interp2, interp3, interpn}
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 ## Date: 2000-03-25
 ##    added 'nearest' as suggested by Kai Habel
 ## 2000-07-17 Paul Kienzle
 ##    added '*' methods and matrix y
 ##    check for proper table lengths
@@ -113,30 +118,30 @@ function yi = interp1 (x, y, varargin)
     print_usage ();
   endif
 
   method = "linear";
   extrap = NA;
   xi = [];
   ispp = false;
   firstnumeric = true;
-  rightcontinuous = [];
+  rightcontinuous = NaN;
 
   if (nargin > 2)
     for i = 1:length (varargin)
       arg = varargin{i};
       if (ischar (arg))
         arg = tolower (arg);
         if (strcmp ("extrap", arg))
           extrap = "extrap";
         elseif (strcmp ("pp", arg))
           ispp = true;
-        elseif (any (strcmp ({"right", "-right"}, arg)))
+        elseif (strcmp (arg, "right") || strcmp (arg, "-right"))
           rightcontinuous = true;
-        elseif (any (strcmp ({"left", "-left"}, arg)))
+        elseif (strcmp (arg, "left") || strcmp (arg, "-left"))
           rightcontinuous = false;
         else
           method = arg;
         endif
       else
         if (firstnumeric)
           xi = arg;
           firstnumeric = false;
@@ -176,17 +181,17 @@ function yi = interp1 (x, y, varargin)
   endif
 
   ## check whether x is sorted; sort if not.
   if (! issorted (x, "either"))
     [x, p] = sort (x);
     y = y(p,:);
   endif
 
-  if (isempty (rightcontinuous))
+  if (isnan (rightcontinuous))
     ## If not specified, set the continuity condition
     if (x(end) < x(1))
       rightcontinuous = false;
     else
       rightcontinuous = true;
     endif
   endif
 
@@ -200,60 +205,68 @@ function yi = interp1 (x, y, varargin)
   starmethod = method(1) == "*";
 
   if (starmethod)
     dx = x(2) - x(1);
   else
     jumps = x(1:end-1) == x(2:end);
     have_jumps = any (jumps);
     if (have_jumps)
-      if (any (strcmp (method, {"nearest", "linear"})))
+      if (strcmp (method, "linear") || strcmp (method, ("nearest")))
         if (any (jumps(1:nx-2) & jumps(2:nx-1)))
-          error ("interp1: extra points in discontinuities");
+          warning ("interp1: multiple discontinuities at the same X value");
         endif
       else
         error ("interp1: discontinuities not supported for method '%s'", method);
       endif
     endif
   endif
 
   ## Proceed with interpolating by all methods.
   switch (method)
+
     case "nearest"
       pp = mkpp ([x(1); (x(1:nx-1)+x(2:nx))/2; x(nx)],
                  shiftdim (y, 1), szy(2:end));
       pp.orient = "first";
 
       if (ispp)
         yi = pp;
       else
         yi = ppval (pp, reshape (xi, szx));
       endif
+
     case "*nearest"
       pp = mkpp ([x(1), x(1)+[0.5:(nx-1)]*dx, x(nx)],
                  shiftdim (y, 1), szy(2:end));
       pp.orient = "first";
       if (ispp)
         yi = pp;
       else
         yi = ppval (pp, reshape (xi, szx));
       endif
+
     case "linear"
-      dy = diff (y);
-      dx = diff (x);
-      dx = repmat (dx, [1 size(dy)(2:end)]);
-      coefs = [(dy./dx).'(:), y(1:nx-1, :).'(:)];
+
       xx = x;
-
+      yy = y;
+      nxx = nx;
       if (have_jumps)
         ## Omit zero-size intervals.
-        coefs(jumps, :) = [];
+        yy(jumps, :) = [];
         xx(jumps) = [];
+        nxx = rows (xx);
       endif
 
+      dy = diff (yy);
+      dx = diff (xx);
+      dx = repmat (dx, [1 size(dy)(2:end)]);
+
+      coefs = [(dy./dx).'(:), yy(1:nxx-1, :).'(:)];
+
       pp = mkpp (xx, coefs, szy(2:end));
       pp.orient = "first";
 
       if (ispp)
         yi = pp;
       else
         yi = ppval (pp, reshape (xi, szx));
       endif
@@ -281,52 +294,53 @@ function yi = interp1 (x, y, varargin)
         yi.orient = "first";
       else
         y = shiftdim (y, 1);
         yi = pchip (x, y, reshape (xi, szx));
         if (! isvector (y))
           yi = shiftdim (yi, 1);
         endif
       endif
+
     case {"spline", "*spline"}
       if (nx == 2 || starmethod)
         x = linspace (x(1), x(nx), ny);
       endif
 
       if (ispp)
         y = shiftdim (reshape (y, szy), 1);
         yi = spline (x, y);
         yi.orient = "first";
       else
         y = shiftdim (y, 1);
         yi = spline (x, y, reshape (xi, szx));
         if (! isvector (y))
           yi = shiftdim (yi, 1);
         endif
       endif
+
     otherwise
       error ("interp1: invalid method '%s'", method);
+
   endswitch
 
-  if (! ispp)
-    if (! ischar (extrap))
-      ## determine which values are out of range and set them to extrap,
-      ## unless extrap == "extrap".
-      minx = min (x(1), x(nx));
-      maxx = max (x(1), x(nx));
+  if (! ispp && ! ischar (extrap))
+    ## determine which values are out of range and set them to extrap,
+    ## unless extrap == "extrap".
+    minx = min (x(1), x(nx));
+    maxx = max (x(1), x(nx));
 
-      outliers = xi < minx | ! (xi <= maxx); # this catches even NaNs
-      if (size_equal (outliers, yi))
-        yi(outliers) = extrap;
-        yi = reshape (yi, szx);
-      elseif (!isvector (yi))
-        yi(outliers, :) = extrap;
-      else
-        yi(outliers.') = extrap;
-      endif
+    outliers = xi < minx | ! (xi <= maxx); # this even catches NaNs
+    if (size_equal (outliers, yi))
+      yi(outliers) = extrap;
+      yi = reshape (yi, szx);
+    elseif (! isvector (yi))
+      yi(outliers, :) = extrap;
+    else
+      yi(outliers.') = extrap;
     endif
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
@@ -383,22 +397,22 @@ endfunction
 %! x = 0:0.5:3;
 %! x1 = [3 2 2 1];
 %! x2 = [1 2 2 3];
 %! y1 = [1 1 0 0];
 %! y2 = [0 0 1 1];
 %! h = plot (x, interp1 (x1, y1, x), 'b', x1, y1, 'sb');
 %! hold on
 %! g = plot (x, interp1 (x2, y2, x), 'r', x2, y2, '*r');
-%! xlim ([1 3])
-%! legend ([h(1), g(1)], {'left-continous', 'right-continuous'}, ...
-%!         'location', 'east')
+%! axis ([0.5 3.5 -0.5 1.5])
+%! legend ([h(1), g(1)], {'left-continuous', 'right-continuous'}, ...
+%!         'location', 'northwest')
 %! legend boxoff
 %! %--------------------------------------------------------
-%! % red curve is left-continuos and blue is right-continuous at x = 2
+%! % red curve is left-continuous and blue is right-continuous at x = 2
 
 ##FIXME: add test for n-d arguments here
 
 ## For each type of interpolated test, confirm that the interpolated
 ## value at the knots match the values at the knots.  Points away
 ## from the knots are requested, but only "nearest" and "linear"
 ## confirm they are the correct values.
 
@@ -589,36 +603,46 @@ endfunction
 %!assert (interp1 (xp,yp,xi,style),...
 %!        interp1 (fliplr (xp),fliplr (yp),xi,style),100*eps)
 %!assert (ppval (interp1 (xp,yp,style,"pp"),xi),
 %!        interp1 (xp,yp,xi,style,"extrap"),10*eps)
 %!error interp1 (1,1,1, style)
 ## ENDBLOCK
 ## ENDBLOCKTEST
 
-%!# test linear extrapolation
+## test extrapolation (linear)
 %!assert (interp1 ([1:5],[3:2:11],[0,6],"linear","extrap"), [1, 13], eps)
 %!assert (interp1 (xp, yp, [-1, max(xp)+1],"linear",5), [5, 5])
 
+## Basic sanity checks
 %!assert (interp1 (1:2,1:2,1.4,"nearest"), 1)
 %!assert (interp1 (1:2,1:2,1.4,"linear"), 1.4)
 %!assert (interp1 (1:4,1:4,1.4,"cubic"), 1.4)
-%!assert (interp1 (1:2,1:2,1.1, "spline"), 1.1)
+%!assert (interp1 (1:2,1:2,1.1,"spline"), 1.1)
 %!assert (interp1 (1:3,1:3,1.4,"spline"), 1.4)
 
 %!assert (interp1 (1:2:4,1:2:4,1.4,"*nearest"), 1)
 %!assert (interp1 (1:2:4,1:2:4,[0,1,1.4,3,4],"*linear"), [NA,1,1.4,3,NA])
 %!assert (interp1 (1:2:8,1:2:8,1.4,"*cubic"), 1.4)
 %!assert (interp1 (1:2,1:2,1.3, "*spline"), 1.3)
 %!assert (interp1 (1:2:6,1:2:6,1.4,"*spline"), 1.4)
 
 %!assert (interp1 ([3,2,1],[3,2,2],2.5), 2.5)
 
-%!assert (interp1 ([1,2,2,3,4],[0,1,4,2,1],[-1,1.5,2,2.5,3.5], "linear", "extrap"), [-2,0.5,4,3,1.5])
 %!assert (interp1 ([4,4,3,2,0],[0,1,4,2,1],[1.5,4,4.5], "linear"), [1.75,1,NA])
 %!assert (interp1 (0:4, 2.5), 1.5)
 
+## Left and Right discontinuities
+%!assert (interp1 ([1,2,2,3,4],[0,1,4,2,1],[-1,1.5,2,2.5,3.5], "linear", "extrap", "right"), [-8,2,4,3,1.5])
+%!assert (interp1 ([1,2,2,3,4],[0,1,4,2,1],[-1,1.5,2,2.5,3.5], "linear", "extrap", "left"), [-2,0.5,1,1.5,1.5])
+
+%% Test input validation
 %!error interp1 ()
-%!error interp1 (1,1,1, "linear")
-%!error interp1 (1,1,1, "*nearest")
-%!error interp1 (1,1,1, "*linear")
-%!error interp1 (1:2,1:2,1, "bogus")
+%!error interp1 (1,2,3,4,5,6,7)
+%!error <table too short> interp1 (1,1,1, "linear")
+%!error <table too short> interp1 (1,1,1, "*nearest")
+%!error <table too short> interp1 (1,1,1, "*linear")
+%!warning <multiple discontinuities> interp1 ([1 1 1 2], [1 2 3 4], 1);
+%!error <discontinuities not supported> interp1 ([1 1],[1 2],1, "pchip")
+%!error <discontinuities not supported> interp1 ([1 1],[1 2],1, "cubic")
+%!error <discontinuities not supported> interp1 ([1 1],[1 2],1, "spline")
+%!error <invalid method> interp1 (1:2,1:2,1, "bogus")
 
diff --git a/scripts/plot/util/figure.m b/scripts/plot/util/figure.m
--- a/scripts/plot/util/figure.m
+++ b/scripts/plot/util/figure.m
@@ -94,33 +94,40 @@ function h = figure (varargin)
       f = __go_figure__ (f, varargin{:});
     endif
     __add_default_menu__ (f);
   elseif (nargs > 0)
     set (f, varargin{:});
   endif
 
   set (0, "currentfigure", f);
-  ## When switching to figure N, make figure visible and on top of stack.
-  if (! init_new_figure)
+  ## When switching to figure N, make figure visible and on top of stack,
+  ## unless visibility is explicitly switched off
+  if (! init_new_figure && ! any (strcmpi (varargin(1:2:end), "visible")
+                                  && strcmpi (varargin(2:2:end), "off")))
     set (f, "visible", "on");
   endif
 
   if (nargout > 0)
     h = f;
   endif
 
 endfunction
 
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   assert (hf, gcf);
 %!   assert (isfigure (hf));
+%!   hf2 = figure (hf, "visible", "off");
+%!   assert (hf, hf2);
+%!   assert (hf2, gcf);
+%!   assert (isfigure (hf2));
+%!   assert (get (hf2, "visible"), "off");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!error <N must be figure handle or figure number> figure ({1})
 %!error <N must be figure handle or figure number> figure ([1 2])
 %!error <N must be figure handle or figure number> figure (-1)
 %!error <N must be figure handle or figure number> figure (1.5)
diff --git a/scripts/polynomial/ppval.m b/scripts/polynomial/ppval.m
--- a/scripts/polynomial/ppval.m
+++ b/scripts/polynomial/ppval.m
@@ -27,17 +27,17 @@
 ## @seealso{mkpp, unmkpp, spline, pchip}
 ## @end deftypefn
 
 function yi = ppval (pp, xi)
 
   if (nargin != 2)
     print_usage ();
   endif
-  if (! (isstruct (pp) && strcmp (pp.form, "pp")))
+  if (! (isstruct (pp) && isfield (pp, "form") && strcmp (pp.form, "pp")))
     error ("ppval: first argument must be a pp-form structure");
   endif
 
   ## Extract info.
   [x, P, n, k, d] = unmkpp (pp);
 
   ## dimension checks
   sxi = size (xi);
@@ -49,17 +49,17 @@ function yi = ppval (pp, xi)
 
   ## Determine intervals.
   xn = numel (xi);
   idx = lookup (x, xi, "lr");
 
   P = reshape (P, [d, n * k]);
   P = shiftdim (P, nd);
   P = reshape (P, [n, k, d]);
-  Pidx = P(idx(:), :);#2d matrix size x: coefs*prod(d) y: prod(sxi)
+  Pidx = P(idx(:), :);  # 2D matrix size: x = coefs*prod(d), y = prod(sxi)
 
   if (isvector (xi))
     Pidx = reshape (Pidx, [xn, k, d]);
     Pidx = shiftdim (Pidx, 1);
     dimvec = [d, xn];
   else
     Pidx = reshape (Pidx, [sxi, k, d]);
     Pidx = shiftdim (Pidx, length (sxi));
@@ -91,41 +91,51 @@ function yi = ppval (pp, xi)
   endif
 
   if (isvector (xi) && (d == 1))
     yi = reshape (yi, sxi);
   elseif (isfield (pp, "orient") && strcmp (pp.orient, "first"))
     yi = shiftdim (yi, nd);
   endif
 
-  ## FIXME: Why is this commented out, rather than just removed?
-  #if (d == 1)
-  #  yi = reshape (yi, sxi);
-  #endif
+  if (d == 1)
+    yi = reshape (yi, sxi);
+  endif
 
 endfunction
 
 
 %!shared b, c, pp, pp2, xi, abserr
 %! b = 1:3;
 %! c = ones (2);
 %! pp = mkpp (b, c);
 %! abserr = 1e-14;
 %! pp2 = mkpp (b, [c;c], 2);
 %! xi = [1.1 1.3 1.9 2.1];
+%!
 %!assert (ppval (pp, 1.1), 1.1, abserr)
 %!assert (ppval (pp, 2.1), 1.1, abserr)
 %!assert (ppval (pp, xi), [1.1 1.3 1.9 1.1], abserr)
 %!assert (ppval (pp, xi.'), [1.1 1.3 1.9 1.1].', abserr)
 %!assert (ppval (pp2, 1.1), [1.1;1.1], abserr)
 %!assert (ppval (pp2, 2.1), [1.1;1.1], abserr)
 %!assert (ppval (pp2, xi), [1.1 1.3 1.9 1.1;1.1 1.3 1.9 1.1], abserr)
 %!assert (ppval (pp2, xi'), [1.1 1.3 1.9 1.1;1.1 1.3 1.9 1.1], abserr)
 %!assert (size (ppval (pp2, [xi;xi])), [2 2 4])
+%!assert (ppval (mkpp([0 1],1), magic (3)), ones(3,3))
+%!
 %!test
 %! breaks = [0, 1, 2, 3];
 %! coefs = rand (6, 4);
 %! pp = mkpp (breaks, coefs, 2);
 %! ret = zeros (2, 4, 2);
 %! ret(:,:,1) = ppval (pp, breaks');
 %! ret(:,:,2) = ppval (pp, breaks');
 %! assert (ppval (pp, [breaks',breaks']), ret)
 
+%% Test input validation
+%!error ppval ()
+%!error ppval (1)
+%!error ppval (1,2,3)
+%!error <argument must be a pp-form structure> ppval (1,2)
+%!error <argument must be a pp-form structure> ppval (struct ("a", 1), 2)
+%!error <argument must be a pp-form structure> ppval (struct ("form", "ab"), 2)
+
