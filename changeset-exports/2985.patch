# HG changeset patch
# User jwe
# Date 863765752 0
#      Fri May 16 06:55:52 1997 +0000
# Node ID aa9d0c0e0458ef92acc6d87a1c8f23a9f0392d09
# Parent  84c33881d0bc337dae1ae5addf578deb0cb0502e
[project @ 1997-05-16 06:54:18 by jwe]

diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,10 +1,17 @@
 Fri May 16 00:07:11 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* unwind-prot.h, unwind-prot.cc: Make a bit more object-oriented.
+	Change all uses of unwind_protect stuff to match.
+
+	* pt-jump.h, pt-jump.cc (breaking, continuing, returning):
+	Make these flags static members of the corresponding class.
+	Change all uses.
+
 	* pt-assign.cc (tree_simple_assignment_expression::eval,
 	tree_multi_assignment_expression::eval): Clear lvalue index here.
 
 	* oct-lvalue.cc (octave_lvalue::assign): Don't clear index here.
 	* oct-lvalue.h (octave_lvalue::clear_index): New function.
 	(octave_lvalue::set_index): Rename from octave_lvalue::index.
 	Change all callers.
 
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -376,33 +376,33 @@ See also: rand")
 
   if (nargin > 2 || nargout > 1)
     print_usage ("randn");
   else
     {
       if (! initialized)
 	do_initialization ();
 
-      begin_unwind_frame ("randn");
+      unwind_protect::begin_frame ("randn");
 
       // This relies on the fact that elements are popped from the
       // unwind stack in the reverse of the order they are pushed
       // (i.e. current_distribution will be reset before calling
       // reset_rand_generator()).
 
-      add_unwind_protect (reset_rand_generator, 0);
+      unwind_protect::add (reset_rand_generator, 0);
       unwind_protect_int (current_distribution);
 
       current_distribution = normal_dist;
 
       F77_FCN (setcgn, SETCGN) (normal_dist);
 
       retval = do_rand (args, nargin);
 
-      run_unwind_frame ("randn");
+      unwind_protect::run_frame ("randn");
     }
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -149,28 +149,28 @@ print a directory listing")
 
   ls_buf << ends;
   char *ls_command = ls_buf.str ();
 
   iprocstream *cmd = new iprocstream (ls_command);
 
   delete [] ls_command;
 
-  add_unwind_protect (cleanup_iprocstream, cmd);
+  unwind_protect::add (cleanup_iprocstream, cmd);
 
   if (cmd && *cmd)
     {
       int ch;
       while ((ch = cmd->get ()) != EOF)
 	octave_stdout << (char) ch;
     }
   else
     error ("couldn't start process for ls!");
 
-  run_unwind_protect ();
+  unwind_protect::run ();
 
   return retval;
 }
 
 DEFALIAS (dir, ls);
 
 DEFUN (pwd, , nargout,
   "pwd (): print current working directory")
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -725,17 +725,17 @@ print cryptic yet witty messages")
 
 DEFUN_TEXT (type, args, nargout,
   "type NAME\n\
 \n\
 display the definition of each NAME that refers to a function")
 {
   octave_value_list retval;
 
-  begin_unwind_frame ("Ftype");
+  unwind_protect::begin_frame ("Ftype");
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("type");
 
   if (error_state)
     return retval;
 
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -1962,22 +1962,22 @@ save_mat_binary_data (ostream& os, const
       ComplexMatrix m_cmplx = tc.complex_matrix_value ();
       Matrix m = ::real(m_cmplx);
       os.write (m.data (), 8 * len);
       m = ::imag(m_cmplx);
       os.write (m.data (), 8 * len);
     }
   else if (tc.is_string ())
     {
-      begin_unwind_frame ("save_mat_binary_data");
+      unwind_protect::begin_frame ("save_mat_binary_data");
       unwind_protect_int (Vimplicit_str_to_num_ok);
       Vimplicit_str_to_num_ok = 1;
       Matrix m = tc.matrix_value ();
       os.write (m.data (), 8 * len);
-      run_unwind_frame ("save_mat_binary_data");
+      unwind_protect::run_frame ("save_mat_binary_data");
     }
   else if (tc.is_range ())
     {
       Range r = tc.range_value ();
       double base = r.base ();
       double inc = r.inc ();
       int nel = r.nelem ();
       for (int i = 0; i < nel; i++)
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -468,25 +468,25 @@ do_edit_history (int argc, const string_
 	edit_history_add_hist (line);
     }
 
   file.close ();
 
   // Turn on command echo, so the output from this will make better
   // sense.
 
-  begin_unwind_frame ("do_edit_history");
+  unwind_protect::begin_frame ("do_edit_history");
   unwind_protect_int (Vecho_executing_commands);
   unwind_protect_int (input_from_tmp_history_file);
   Vecho_executing_commands = ECHO_CMD_LINE;
   input_from_tmp_history_file = 1;
 
   parse_and_execute (name);
 
-  run_unwind_frame ("do_edit_history");
+  unwind_protect::run_frame ("do_edit_history");
 
   // Delete the temporary file.  Should probably be done with an
   // unwind_protect.
 
   unlink (name.c_str ());
 }
 
 static void
@@ -495,25 +495,25 @@ do_run_history (int argc, const string_v
   string name = mk_tmp_hist_file (argc, argv, 1, "run_history");
 
   if (name.empty ())
     return;
 
   // Turn on command echo so the output from this will make better
   // sense.
 
-  begin_unwind_frame ("do_run_history");
+  unwind_protect::begin_frame ("do_run_history");
   unwind_protect_int (Vecho_executing_commands);
   unwind_protect_int (input_from_tmp_history_file);
   Vecho_executing_commands = ECHO_CMD_LINE;
   input_from_tmp_history_file = 1;
 
   parse_and_execute (name);
 
-  run_unwind_frame ("do_run_history");
+  unwind_protect::run_frame ("do_run_history");
 
   // Delete the temporary file.
 
   // XXX FIXME XXX -- should probably be done using an unwind_protect.
 
   unlink (name.c_str ());
 }
 
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -210,17 +210,17 @@ initialize_pathsearch (void)
     octave_env::putenv ("TEXMF", odb);
 }
 
 // Initialize by reading startup files.
 
 static void
 execute_startup_files (void)
 {
-  begin_unwind_frame ("execute_startup_files");
+  unwind_protect::begin_frame ("execute_startup_files");
 
   // XXX FIXME XXX -- need to make it possible to set this in startup
   // files.
 
   unwind_protect_int (input_from_startup_file);
 
   input_from_startup_file = 1;
 
@@ -272,17 +272,17 @@ execute_startup_files (void)
 		home_rc_already_executed = 1;
 	    }
 	}
 
       if (! home_rc_already_executed)
 	parse_and_execute (local_rc, verbose);
     }
 
-  run_unwind_frame ("execute_startup_files");
+  unwind_protect::run_frame ("execute_startup_files");
 }
 
 // Usage message with extra help.
 
 static void
 verbose_usage (void)
 {
   cout << OCTAVE_NAME_VERSION_AND_COPYRIGHT "\n\
diff --git a/src/ov-list.cc b/src/ov-list.cc
--- a/src/ov-list.cc
+++ b/src/ov-list.cc
@@ -84,17 +84,17 @@ void
 octave_list::print (ostream& os, bool) const
 {
   print_raw (os);
 }
 
 void
 octave_list::print_raw (ostream& os, bool) const
 {
-  begin_unwind_frame ("octave_list_print");
+  unwind_protect::begin_frame ("octave_list_print");
 
   indent (os);
   os << "(";
   newline (os);
 
   increment_indent_level ();
 
   int n = lst.length ();
@@ -113,17 +113,17 @@ octave_list::print_raw (ostream& os, boo
     }
 
   decrement_indent_level ();
 
   indent (os);
   os << ")";
   newline (os);
 
-  run_unwind_frame ("octave_list_print");
+  unwind_protect::run_frame ("octave_list_print");
 }
 
 bool
 octave_list::print_name_tag (ostream& os, const string& name) const
 {
   indent (os);
   os << name << " =";
   newline (os);
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -82,17 +82,17 @@ octave_struct::print (ostream& os, bool)
 
 void
 octave_struct::print_raw (ostream& os, bool) const
 {
   // XXX FIXME XXX -- would be nice to print the output in some
   // standard order.  Maybe all substructures first, maybe
   // alphabetize entries, etc.
 
-  begin_unwind_frame ("octave_struct_print");
+  unwind_protect::begin_frame ("octave_struct_print");
 
   unwind_protect_int (Vstruct_levels_to_print);
 
   if (Vstruct_levels_to_print-- > 0)
     {
       indent (os);
       os << "{";
       newline (os);
@@ -114,17 +114,17 @@ octave_struct::print_raw (ostream& os, b
       newline (os);
     }
   else
     {
       os << " <structure>";
       newline (os);
     }
 
-  run_unwind_frame ("octave_struct_print");
+  unwind_protect::run_frame ("octave_struct_print");
 }
 
 bool
 octave_struct::print_name_tag (ostream& os, const string& name) const
 {
   indent (os);
   os << name << " =";
   newline (os);
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -34,16 +34,17 @@ Software Foundation, 59 Temple Place - S
 #include "defun.h"
 #include "error.h"
 #include "help.h"
 #include "input.h"
 #include "oct-obj.h"
 #include "ov-usr-fcn.h"
 #include "ov.h"
 #include "pager.h"
+#include "pt-jump.h"
 #include "pt-misc.h"
 #include "pt-pr-code.h"
 #include "pt-stmt.h"
 #include "pt-walk.h"
 #include "symtab.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 #include "utils.h"
@@ -52,22 +53,16 @@ Software Foundation, 59 Temple Place - S
 // If TRUE, variables returned from functions have default values even
 // if they are not explicitly initialized.
 static bool Vdefine_all_return_values;
 
 // If TRUE, the last computed value is returned from functions that
 // don't actually define any return variables.
 static bool Vreturn_last_computed_value;
 
-// Nonzero means we're breaking out of a loop or function body.
-extern int breaking;
-
-// Nonzero means we're returning from a function.
-extern int returning;
-
 // User defined functions.
 
 octave_allocator
 octave_user_function::allocator (sizeof (octave_user_function));
 
 int
 octave_user_function::t_id (-1);
 
@@ -242,52 +237,52 @@ octave_user_function::do_index_op (int n
   if (error_state)
     return retval;
 
   if (! cmd_list)
     return retval;
 
   int nargin = args.length ();
 
-  begin_unwind_frame ("func_eval");
+  unwind_protect::begin_frame ("func_eval");
 
   unwind_protect_int (call_depth);
   call_depth++;
 
   if (symtab_entry && ! symtab_entry->is_read_only ())
     {
       symtab_entry->protect ();
-      add_unwind_protect (unprotect_function, symtab_entry);
+      unwind_protect::add (unprotect_function, symtab_entry);
     }
 
   if (call_depth > 1)
     {
       sym_tab->push_context ();
-      add_unwind_protect (pop_symbol_table_context, sym_tab);
+      unwind_protect::add (pop_symbol_table_context, sym_tab);
 
       if (vr_list)
 	{
 	  // Push new vr_list.
 
 	  unwind_protect_ptr (vr_list);
 	  vr_list = new tree_va_return_list;
 
 	  // Clear and delete the new one before restoring the old
 	  // one.
 
-	  add_unwind_protect (delete_vr_list, vr_list);
+	  unwind_protect::add (delete_vr_list, vr_list);
 	}
     }
 
   if (vr_list)
     vr_list->clear ();
 
   // Force symbols to be undefined again when this function exits.
 
-  add_unwind_protect (clear_symbol_table, sym_tab);
+  unwind_protect::add (clear_symbol_table, sym_tab);
 
   // Save old and set current symbol table context, for
   // eval_undefined_error().
 
   unwind_protect_ptr (curr_sym_tab);
   curr_sym_tab = sym_tab;
 
   unwind_protect_ptr (curr_function);
@@ -340,38 +335,38 @@ octave_user_function::do_index_op (int n
     octave_value last_computed_value;
 
     if (! tmp.empty ())
       last_computed_value = tmp(0);
 
     if (echo_commands)
       print_code_function_trailer ();
 
-    if (returning)
-      returning = 0;
+    if (tree_return_command::returning)
+      tree_return_command::returning = 0;
 
-    if (breaking)
-      breaking--;
+    if (tree_break_command::breaking)
+      tree_break_command::breaking--;
 
     if (error_state)
       {
 	traceback_error ();
 	goto abort;
       }
     
     // Copy return values out.
 
     if (ret_list)
       retval = ret_list->convert_to_const_vector (vr_list);
     else if (Vreturn_last_computed_value)
       retval(0) = last_computed_value;
   }
 
  abort:
-  run_unwind_frame ("func_eval");
+  unwind_protect::run_frame ("func_eval");
 
   return retval;
 }
 
 void
 octave_user_function::traceback_error (void)
 {
   if (error_state >= 0)
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -300,30 +300,30 @@ octave_diary_stream::stream (void)
   return *instance;
 }
 
 void
 flush_octave_stdout (void)
 {
   if (! flushing_output_to_pager)
     {
-      begin_unwind_frame ("flush_octave_stdout");
+      unwind_protect::begin_frame ("flush_octave_stdout");
 
       unwind_protect_int (really_flush_to_pager);
       unwind_protect_int (flushing_output_to_pager);
 
       really_flush_to_pager = 1;
       flushing_output_to_pager = 1;
 
       octave_stdout.flush ();
 
       if (external_pager)
 	clear_external_pager ();
 
-      run_unwind_frame ("flush_octave_stdout");
+      unwind_protect::run_frame ("flush_octave_stdout");
     }
 }
 
 static void
 close_diary_file (void)
 {
   if (external_diary_file.is_open ())
     {
diff --git a/src/pt-assign.cc b/src/pt-assign.cc
--- a/src/pt-assign.cc
+++ b/src/pt-assign.cc
@@ -39,22 +39,16 @@ Software Foundation, 59 Temple Place - S
 #include "pager.h"
 #include "ov.h"
 #include "pt-arg-list.h"
 #include "pt-assign.h"
 #include "pt-pr-code.h"
 #include "pt-walk.h"
 #include "utils.h"
 
-// Nonzero means we're returning from a function.
-extern int returning;
-
-// Nonzero means we're breaking out of a loop or function body.
-extern int breaking;
-
 // TRUE means print the right hand side of an assignment instead of
 // the left.
 static bool Vprint_rhs_assign_val;
 
 // Simple assignment expressions.
 
 tree_simple_assignment::~tree_simple_assignment (void)
 {
diff --git a/src/pt-except.cc b/src/pt-except.cc
--- a/src/pt-except.cc
+++ b/src/pt-except.cc
@@ -23,32 +23,23 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-// Nonzero means we're breaking out of a loop or function body.
-extern int breaking;
-
-// Nonzero means we're jumping to the end of a loop.
-extern int continuing;
-
-// Nonzero means we're returning from a function.  Global because it
-// is also needed in tree-expr.cc.
-extern int returning;
-
 #include "error.h"
 #include "oct-lvalue.h"
 #include "ov.h"
 #include "pt-cmd.h"
 #include "pt-except.h"
 #include "pt-exp.h"
+#include "pt-jump.h"
 #include "pt-stmt.h"
 #include "pt-walk.h"
 #include "unwind-prot.h"
 #include "variables.h"
 
 // Simple exception handling.
 
 tree_try_catch_command::~tree_try_catch_command (void)
@@ -62,78 +53,78 @@ do_catch_code (void *ptr)
 {
   tree_statement_list *list = static_cast<tree_statement_list *> (ptr);
 
   // Set up for letting the user print any messages from errors that
   // occurred in the body of the try_catch statement.
 
   buffer_error_messages = 0;
   bind_global_error_variable ();
-  add_unwind_protect (clear_global_error_variable, 0);
+  unwind_protect::add (clear_global_error_variable, 0);
 
   // Similarly, if we have seen a return or break statement, allow all
   // the catch code to run before returning or handling the break.
   // We don't have to worry about continue statements because they can
   // only occur in loops.
 
-  unwind_protect_int (returning);
-  returning = 0;
+  unwind_protect_int (tree_return_command::returning);
+  tree_return_command::returning = 0;
 
-  unwind_protect_int (breaking);
-  breaking = 0;
+  unwind_protect_int (tree_break_command::breaking);
+  tree_break_command::breaking = 0;
 
   if (list)
     list->eval ();
 
   // This is the one for breaking.  (The unwind_protects are popped
   // off the stack in the reverse of the order they are pushed on).
 
   // XXX FIXME XXX -- inside a try-catch, should break work like
   // a return, or just jump to the end of the try_catch block?
   // The following code makes it just jump to the end of the block.
 
-  run_unwind_protect ();
-  if (breaking)
-    breaking--;
+  unwind_protect::run ();
+  if (tree_break_command::breaking)
+    tree_break_command::breaking--;
 
   // This is the one for returning.
 
-  if (returning)
-    discard_unwind_protect ();
+  if (tree_return_command::returning)
+    unwind_protect::discard ();
   else
-    run_unwind_protect ();
+    unwind_protect::run ();
 
-  run_unwind_protect ();
+  unwind_protect::run ();
 }
 
 void
 tree_try_catch_command::eval (void)
 {
-  begin_unwind_frame ("tree_try_catch::eval");
+  unwind_protect::begin_frame ("tree_try_catch::eval");
 
-  add_unwind_protect (do_catch_code, catch_code);
+  unwind_protect::add (do_catch_code, catch_code);
 
   if (catch_code)
     {
       unwind_protect_int (buffer_error_messages);
       buffer_error_messages = 1;
     }
 
   if (try_code)
     try_code->eval ();
 
   if (catch_code && error_state)
     {
       error_state = 0;
-      run_unwind_frame ("tree_try_catch::eval");
+      unwind_protect::run_frame ("tree_try_catch::eval");
     }
   else
     {
       error_state = 0;
-      discard_unwind_frame ("tree_try_catch::eval");
+      unwind_protect::discard_frame ("tree_try_catch::eval");
     }
 }
 
 void
 tree_try_catch_command::accept (tree_walker& tw)
 {
   tw.visit_try_catch_command (*this);
 }
@@ -159,62 +150,62 @@ do_unwind_protect_cleanup_code (void *pt
   unwind_protect_int (error_state);
   error_state = 0;
 
   // Similarly, if we have seen a return or break statement, allow all
   // the cleanup code to run before returning or handling the break.
   // We don't have to worry about continue statements because they can
   // only occur in loops.
 
-  unwind_protect_int (returning);
-  returning = 0;
+  unwind_protect_int (tree_return_command::returning);
+  tree_return_command::returning = 0;
 
-  unwind_protect_int (breaking);
-  breaking = 0;
+  unwind_protect_int (tree_break_command::breaking);
+  tree_break_command::breaking = 0;
 
   if (list)
     list->eval ();
 
   // This is the one for breaking.  (The unwind_protects are popped
   // off the stack in the reverse of the order they are pushed on).
 
   // XXX FIXME XXX -- inside an unwind_protect, should break work like
   // a return, or just jump to the end of the unwind_protect block?
   // The following code makes it just jump to the end of the block.
 
-  run_unwind_protect ();
-  if (breaking)
-    breaking--;
+  unwind_protect::run ();
+  if (tree_break_command::breaking)
+    tree_break_command::breaking--;
 
   // This is the one for returning.
 
-  if (returning)
-    discard_unwind_protect ();
+  if (tree_return_command::returning)
+    unwind_protect::discard ();
   else
-    run_unwind_protect ();
+    unwind_protect::run ();
 
   // We don't want to ignore errors that occur in the cleanup code, so
   // if an error is encountered there, leave error_state alone.
   // Otherwise, set it back to what it was before.
 
   if (error_state)
-    discard_unwind_protect ();
+    unwind_protect::discard ();
   else
-    run_unwind_protect ();
+    unwind_protect::run ();
 }
 
 void
 tree_unwind_protect_command::eval (void)
 {
-  add_unwind_protect (do_unwind_protect_cleanup_code, cleanup_code);
+  unwind_protect::add (do_unwind_protect_cleanup_code, cleanup_code);
 
   if (unwind_protect_code)
     unwind_protect_code->eval ();
 
-  run_unwind_protect ();
+  unwind_protect::run ();
 }
 
 void
 tree_unwind_protect_command::accept (tree_walker& tw)
 {
   tw.visit_unwind_protect_command (*this);
 }
 
diff --git a/src/pt-jump.cc b/src/pt-jump.cc
--- a/src/pt-jump.cc
+++ b/src/pt-jump.cc
@@ -23,62 +23,62 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-// Nonzero means we're breaking out of a loop or function body.
-int breaking = 0;
-
-// Nonzero means we're jumping to the end of a loop.
-int continuing = 0;
-
-// Nonzero means we're returning from a function.  Global because it
-// is also needed in tree-expr.cc.
-int returning = 0;
-
 #include "error.h"
 #include "pt-jump.h"
 #include "pt-walk.h"
 
 // Break.
 
+// Nonzero means we're breaking out of a loop or function body.
+int tree_break_command::breaking = 0;
+
 void
 tree_break_command::eval (void)
 {
   if (! error_state)
     breaking = 1;
 }
 
 void
 tree_break_command::accept (tree_walker& tw)
 {
   tw.visit_break_command (*this);
 }
 
 // Continue.
 
+// Nonzero means we're jumping to the end of a loop.
+int tree_continue_command::continuing = 0;
+
 void
 tree_continue_command::eval (void)
 {
   if (! error_state)
     continuing = 1;
 }
 
 void
 tree_continue_command::accept (tree_walker& tw)
 {
   tw.visit_continue_command (*this);
 }
 
 // Return.
 
+// Nonzero means we're returning from a function.  Global because it
+// is also needed in tree-expr.cc.
+int tree_return_command::returning = 0;
+
 void
 tree_return_command::eval (void)
 {
   if (! error_state)
     returning = 1;
 }
 
 void
diff --git a/src/pt-jump.h b/src/pt-jump.h
--- a/src/pt-jump.h
+++ b/src/pt-jump.h
@@ -41,16 +41,18 @@ public:
   tree_break_command (int l = -1, int c = -1)
     : tree_command (l, c) { }
 
   ~tree_break_command (void) { }
 
   void eval (void);
 
   void accept (tree_walker& tw);
+
+  static int breaking;
 };
 
 // Continue.
 
 class
 tree_continue_command : public tree_command
 {
 public:
@@ -58,16 +60,18 @@ public:
   tree_continue_command (int l = -1, int c = -1)
     : tree_command (l, c) { }
 
   ~tree_continue_command (void) { }
 
   void eval (void);
 
   void accept (tree_walker& tw);
+
+  static int continuing;
 };
 
 // Return.
 
 class
 tree_return_command : public tree_command
 {
 public:
@@ -75,16 +79,18 @@ public:
   tree_return_command (int l = -1, int c = -1)
     : tree_command (l, c) { }
 
   ~tree_return_command (void) { }
 
   void eval (void);
 
   void accept (tree_walker& tw);
+
+  static int returning;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/pt-loop.cc b/src/pt-loop.cc
--- a/src/pt-loop.cc
+++ b/src/pt-loop.cc
@@ -23,51 +23,45 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-// Nonzero means we're breaking out of a loop or function body.
-extern int breaking;
-
-// Nonzero means we're jumping to the end of a loop.
-extern int continuing;
-
-// Nonzero means we're returning from a function.  Global because it
-// is also needed in tree-expr.cc.
-extern int returning;
-
 #include "error.h"
 #include "gripes.h"
 #include "oct-map.h"
 #include "oct-lvalue.h"
 #include "ov.h"
 #include "pt-arg-list.h"
 #include "pt-cmd.h"
 #include "pt-exp.h"
+#include "pt-jump.h"
 #include "pt-loop.h"
 #include "pt-stmt.h"
 #include "pt-walk.h"
 
 // Decide if it's time to quit a for or while loop.
 static inline bool
 quit_loop_now (void)
 {
   // Maybe handle `continue N' someday...
 
-  if (continuing)
-    continuing--;
+  if (tree_continue_command::continuing)
+    tree_continue_command::continuing--;
 
-  bool quit = (error_state || returning || breaking || continuing);
+  bool quit = (error_state
+	       || tree_return_command::returning
+	       || tree_break_command::breaking
+	       || tree_continue_command::continuing);
 
-  if (breaking)
-    breaking--;
+  if (tree_break_command::breaking)
+    tree_break_command::breaking--;
 
   return quit;
 }
 
 // While.
 
 tree_while_command::~tree_while_command (void)
 {
diff --git a/src/pt-stmt.cc b/src/pt-stmt.cc
--- a/src/pt-stmt.cc
+++ b/src/pt-stmt.cc
@@ -34,31 +34,23 @@ Software Foundation, 59 Temple Place - S
 #include "error.h"
 #include "ov.h"
 #include "oct-lvalue.h"
 #include "input.h"
 #include "pager.h"
 #include "pt-cmd.h"
 #include "pt-id.h"
 #include "pt-idx.h"
+#include "pt-jump.h"
 #include "pt-pr-code.h"
 #include "pt-stmt.h"
 #include "pt-walk.h"
 #include "utils.h"
 #include "variables.h"
 
-// Nonzero means we're breaking out of a loop or function body.
-extern int breaking;
-
-// Nonzero means we're jumping to the end of a loop.
-extern int continuing;
-
-// Nonzero means we're returning from a function.
-extern int returning;
-
 // If TRUE, turn off printing of results in functions (as if a
 // semicolon has been appended to each statement).
 static bool Vsilent_functions;
 
 // A list of commands to be executed.
 
 tree_statement::~tree_statement (void)
 {
@@ -161,20 +153,21 @@ tree_statement_list::eval (bool silent, 
 	  bool silent_flag =
 	    silent ? true : (function_body ? Vsilent_functions : false);
 
 	  retval = elt->eval (silent_flag, nargout, function_body);
 
 	  if (error_state)
 	    break;
 
-	  if (breaking || continuing)
+	  if (tree_break_command::breaking
+	      || tree_continue_command::continuing)
 	    break;
 
-	  if (returning)
+	  if (tree_return_command::returning)
 	    break;
 	}
       else
 	error ("invalid statement found in statement list!");
     }
 
   return retval;
 }
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -62,36 +62,31 @@ Software Foundation, 59 Temple Place - S
 #include "oct-hist.h"
 #include "oct-map.h"
 #include "oct-obj.h"
 #include "pager.h"
 #include "parse.h"
 #include "pathsearch.h"
 #include "procstream.h"
 #include "ov.h"
+#include "pt-jump.h"
 #include "pt-plot.h"
 #include "pt-stmt.h"
 #include "sighandlers.h"
 #include "sysdep.h"
 #include "syswait.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 #include <version.h>
 
 // Nonzero means we print 
 static bool Vdefault_eval_print_flag = true;
 
-// Nonzero means we're breaking out of a loop or function body.
-extern int breaking;
-
-// Nonzero means we're returning from a function.
-extern int returning;
-
 // Nonzero means we are using readline.
 // (--no-line-editing)
 int line_editing = 1;
 
 // Nonzero means we printed messages about reading startup files.
 int reading_startup_message_printed = 0;
 
 // Nonzero means we are exiting via the builtin exit or quit functions.
@@ -111,23 +106,23 @@ int input_from_startup_file = 0;
 int input_from_command_line_file = 1;
 
 // Top level context (?)
 jmp_buf toplevel;
 
 void
 parse_and_execute (FILE *f)
 {
-  begin_unwind_frame ("parse_and_execute");
+  unwind_protect::begin_frame ("parse_and_execute");
   
   YY_BUFFER_STATE old_buf = current_buffer ();
   YY_BUFFER_STATE new_buf = create_buffer (f);
 
-  add_unwind_protect (restore_input_buffer, old_buf);
-  add_unwind_protect (delete_input_buffer, new_buf);
+  unwind_protect::add (restore_input_buffer, old_buf);
+  unwind_protect::add (delete_input_buffer, new_buf);
 
   switch_to_buffer (new_buf);
 
   unwind_protect_int (line_editing);
   unwind_protect_int (input_from_command_line_file);
 
   line_editing = 0;
   input_from_command_line_file = 0;
@@ -144,64 +139,65 @@ parse_and_execute (FILE *f)
       if (retval == 0 && global_command)
 	{
 	  global_command->eval ();
 
 	  delete global_command;
 
 	  global_command = 0;
 
-	  bool quit = (returning || breaking);
+	  bool quit = (tree_return_command::returning
+		       || tree_break_command::breaking);
 
-	  if (returning)
-	    returning = 0;
+	  if (tree_return_command::returning)
+	    tree_return_command::returning = 0;
 
-	  if (breaking)
-	    breaking--;
+	  if (tree_break_command::breaking)
+	    tree_break_command::breaking--;
 
 	  if (error_state)
 	    {
 	      error ("near line %d of file `%s'", input_line_number,
 		     curr_fcn_file_full_name.c_str ());
 
 	      break;
 	    }
 
 	  if (quit)
 	    break;
 	}
     }
   while (retval == 0);
 
-  run_unwind_frame ("parse_and_execute");
+  unwind_protect::run_frame ("parse_and_execute");
 }
 
 static void
 safe_fclose (void *f)
 {
   if (f)
     fclose (static_cast<FILE *> (f));
 }
 
 void
 parse_and_execute (const string& s, bool verbose, const char *warn_for)
 {
-  begin_unwind_frame ("parse_and_execute_2");
+  unwind_protect::begin_frame ("parse_and_execute_2");
 
   unwind_protect_int (reading_script_file);
   unwind_protect_str (curr_fcn_file_full_name);
 
   reading_script_file = 1;
   curr_fcn_file_full_name = s;
 
   FILE *f = get_input_from_file (s, 0);
 
   if (f)
     {
-      add_unwind_protect (safe_fclose, f);
+      unwind_protect::add (safe_fclose, f);
 
       unwind_protect_int (input_line_number);
       unwind_protect_int (current_input_column);
 
       input_line_number = 0;
       current_input_column = 1;
 
       if (verbose)
@@ -214,17 +210,17 @@ parse_and_execute (const string& s, bool
       parse_and_execute (f);
 
       if (verbose)
 	cout << "done." << endl;
     }
   else if (warn_for)
     error ("%s: unable to open file `%s'", warn_for, s.c_str ());
 
-  run_unwind_frame ("parse_and_execute_2");
+  unwind_protect::run_frame ("parse_and_execute_2");
 }
 
 int
 main_loop (void)
 {
   // Allow the user to interrupt us without exiting.
 
   octave_save_signal_mask ();
@@ -258,23 +254,24 @@ main_loop (void)
 	  global_command->eval ();
 
 	  delete global_command;
 
 	  global_command = 0;
 
 	  if (! (interactive || forced_interactive))
 	    {
-	      bool quit = (returning || breaking);
+	      bool quit = (tree_return_command::returning
+			   || tree_break_command::breaking);
 
-	      if (returning)
-		returning = 0;
+	      if (tree_return_command::returning)
+		tree_return_command::returning = 0;
 
-	      if (breaking)
-		breaking--;
+	      if (tree_break_command::breaking)
+		tree_break_command::breaking--;
 
 	      if (quit)
 		break;
 	    }
 
 	  if (error_state)
 	    {
 	      if (! (interactive || forced_interactive))
@@ -509,48 +506,48 @@ evaluate NAME as a function, passing ARG
     print_usage ("feval");
 
   return retval;
 }
 
 static octave_value_list
 eval_string (const string& s, bool silent, int& parse_status, int nargout)
 {
-  begin_unwind_frame ("eval_string");
+  unwind_protect::begin_frame ("eval_string");
 
   unwind_protect_int (get_input_from_eval_string);
   unwind_protect_int (input_from_command_line_file);
   unwind_protect_ptr (global_command);
   unwind_protect_str (current_eval_string);
 
   get_input_from_eval_string = 1;
   input_from_command_line_file = 0;
   current_eval_string = s;
 
   YY_BUFFER_STATE old_buf = current_buffer ();
   YY_BUFFER_STATE new_buf = create_buffer (0);
 
-  add_unwind_protect (restore_input_buffer, old_buf);
-  add_unwind_protect (delete_input_buffer, new_buf);
+  unwind_protect::add (restore_input_buffer, old_buf);
+  unwind_protect::add (delete_input_buffer, new_buf);
 
   switch_to_buffer (new_buf);
 
   unwind_protect_ptr (curr_sym_tab);
 
   reset_parser ();
 
   parse_status = yyparse ();
 
   // Important to reset the idea of where input is coming from before
   // trying to eval the command we just parsed -- it might contain the
   // name of an function file that still needs to be parsed!
 
   tree_statement_list *command = global_command;
 
-  run_unwind_frame ("eval_string");
+  unwind_protect::run_frame ("eval_string");
 
   octave_value_list retval;
 
   if (parse_status == 0 && command)
     {
       retval = command->eval (silent, nargout);
       delete command;
     }
@@ -592,17 +589,17 @@ Evaluate the string TRY as octave code. 
 string CATCH.")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
-      begin_unwind_frame ("Feval");
+      unwind_protect::begin_frame ("Feval");
 
       if (nargin > 1)
 	{
 	  unwind_protect_int (buffer_error_messages);
 	  buffer_error_messages = 1;
 	}
 
       int parse_status = 0;
@@ -614,24 +611,24 @@ string CATCH.")
 	{
 	  error_state = 0;
 
 	  // Set up for letting the user print any messages from
 	  // errors that occurred in the first part of this eval().
 
 	  buffer_error_messages = 0;
 	  bind_global_error_variable ();
-	  add_unwind_protect (clear_global_error_variable, 0);
+	  unwind_protect::add (clear_global_error_variable, 0);
 
 	  eval_string (args(1), 0, parse_status, nargout);
 
 	  retval = octave_value_list ();
 	}
 
-      run_unwind_frame ("Feval");
+      unwind_protect::run_frame ("Feval");
     }
   else
     print_usage ("eval");
 
   return retval;
 }
 
 // Execute a shell command.
@@ -644,17 +641,17 @@ cleanup_iprocstream (void *p)
 
 static octave_value_list
 run_command_and_return_output (const string& cmd_str)
 {
   octave_value_list retval;
 
   iprocstream *cmd = new iprocstream (cmd_str.c_str ());
 
-  add_unwind_protect (cleanup_iprocstream, cmd);
+  unwind_protect::add (cleanup_iprocstream, cmd);
 
   int status = 127;
 
   if (cmd && *cmd)
     {
       ostrstream output_buf;
 
       char ch;
@@ -677,17 +674,17 @@ run_command_and_return_output (const str
       retval(1) = static_cast<double> (status);
       retval(0) = msg;
 
       delete [] msg;
     }
   else
     error ("unable to start subprocess for `%s'", cmd_str.c_str ());
 
-  run_unwind_protect ();
+  unwind_protect::run ();
 
   return retval;
 }
 
 DEFUN (system, args, nargout,
   "system (STRING [, RETURN_OUTPUT] [, TYPE])\n\
 \n\
 Execute the shell command specified by STRING.\n\
diff --git a/src/unwind-prot.cc b/src/unwind-prot.cc
--- a/src/unwind-prot.cc
+++ b/src/unwind-prot.cc
@@ -35,140 +35,87 @@ Software Foundation, 59 Temple Place - S
 #include "SLStack.h"
 
 #include "CMatrix.h"
 
 #include "error.h"
 #include "unwind-prot.h"
 #include "utils.h"
 
-// XXX FIXME XXX -- this should really be static, but that causes
-// problems on some systems.
-SLStack <unwind_elem> unwind_protect_list;
-
-void
-add_unwind_protect (cleanup_func fptr, void *ptr)
-{
-  unwind_elem el (fptr, ptr);
-  unwind_protect_list.push (el);
-}
-
-void
-run_unwind_protect (void)
-{
-  unwind_elem el = unwind_protect_list.pop ();
-
-  cleanup_func f = el.fptr ();
-
-  if (f)
-    f (el.ptr ());
-}
+SLStack<unwind_elem> unwind_protect::list;
 
-void
-discard_unwind_protect (void)
-{
-  unwind_protect_list.pop ();
-}
-
-void
-begin_unwind_frame (const string& tag)
+class
+saved_variable
 {
-  unwind_elem elem (tag);
-  unwind_protect_list.push (elem);
-}
-
-void
-run_unwind_frame (const string& tag)
-{
-  while (! unwind_protect_list.empty ())
-    {
-      unwind_elem el = unwind_protect_list.pop ();
-
-      cleanup_func f = el.fptr ();
+public:
 
-      if (f)
-	f (el.ptr ());
-
-      if (tag == el.tag ())
-	break;
-    }
-}
-
-void
-discard_unwind_frame (const string& tag)
-{
-  while (! unwind_protect_list.empty ())
-    {
-      unwind_elem el = unwind_protect_list.pop ();
-
-      if (tag == el.tag ())
-	break;
-    }
-}
-
-void
-run_all_unwind_protects (void)
-{
-  while (! unwind_protect_list.empty ())
-    {
-      unwind_elem el = unwind_protect_list.pop ();
-
-      cleanup_func f = el.fptr ();
-
-      if (f)
-	f (el.ptr ());
-    }
-}
-
-void
-discard_all_unwind_protects (void)
-{
-  unwind_protect_list.clear ();
-}
-
-class saved_variable
-{
- public:
-  enum var_type { integer, string_type, generic_ptr, generic };
+  enum var_type
+  {
+    boolean,
+    integer,
+    string_type,
+    generic_ptr,
+    generic
+  };
 
   saved_variable (void);
+
+  saved_variable (bool *p, bool v);
+
   saved_variable (int *p, int v);
+
   saved_variable (string *p, const string& v);
+
   saved_variable (void **p, void *v);
+
   ~saved_variable (void);
 
   void restore_value (void);
 
- private:
+  static void restore (void *s);
+
+private:
+
   union
     {
+      bool *ptr_to_bool;
       int *ptr_to_int;
       void *gen_ptr;
       void **ptr_to_gen_ptr;
     };
 
   union
     {
+      bool bool_value;
       int int_value;
       const string *str_value;
       void *gen_ptr_value;
     };
 
   var_type type_tag;
+
   size_t size;
 };
 
 saved_variable::saved_variable (void)
 {
   gen_ptr = 0;
   gen_ptr_value = 0;
   type_tag = generic;
   size = 0;
 }
 
+saved_variable::saved_variable (bool *p, bool v)
+{
+  type_tag = integer;
+  ptr_to_bool = p;
+  bool_value = v;
+  size = sizeof (bool);  // Is this necessary?
+}
+
 saved_variable::saved_variable (int *p, int v)
 {
   type_tag = integer;
   ptr_to_int = p;
   int_value = v;
   size = sizeof (int);  // Is this necessary?
 }
 
@@ -205,16 +152,20 @@ saved_variable::~saved_variable (void)
     }
 }
 
 void
 saved_variable::restore_value (void)
 {
   switch (type_tag)
     {
+    case boolean:
+      *ptr_to_bool = bool_value;
+      break;
+
     case integer:
       *ptr_to_int = int_value;
       break;
 
     case string_type:
       (static_cast<string *> (gen_ptr)) -> assign (*str_value);
       break;
 
@@ -227,42 +178,129 @@ saved_variable::restore_value (void)
       break;
 
     default:
       panic_impossible ();
       break;
     }
 }
 
-static void
-restore_saved_variable (void *s)
+void
+saved_variable::restore (void *s)
 {
   saved_variable *sv = static_cast<saved_variable *> (s);
   sv->restore_value ();
   delete sv;
 }
 
 void
-unwind_protect_int_internal (int *ptr, int value)
+unwind_protect::add (unwind_elem::cleanup_func fptr, void *ptr)
+{
+  unwind_elem el (fptr, ptr);
+  list.push (el);
+}
+
+void
+unwind_protect::run (void)
+{
+  unwind_elem el = list.pop ();
+
+  unwind_elem::cleanup_func f = el.fptr ();
+
+  if (f)
+    f (el.ptr ());
+}
+
+void
+unwind_protect::discard (void)
 {
-  saved_variable *s = new saved_variable (ptr, value);
-  add_unwind_protect (restore_saved_variable, s);
+  list.pop ();
+}
+
+void
+unwind_protect::begin_frame (const string& tag)
+{
+  unwind_elem elem (tag);
+  list.push (elem);
+}
+
+void
+unwind_protect::run_frame (const string& tag)
+{
+  while (! list.empty ())
+    {
+      unwind_elem el = list.pop ();
+
+      unwind_elem::cleanup_func f = el.fptr ();
+
+      if (f)
+	f (el.ptr ());
+
+      if (tag == el.tag ())
+	break;
+    }
 }
 
 void
-unwind_protect_str_internal (string *ptr, const string& value)
+unwind_protect::discard_frame (const string& tag)
 {
-  saved_variable *s = new saved_variable (ptr, value);
-  add_unwind_protect (restore_saved_variable, s);
+  while (! list.empty ())
+    {
+      unwind_elem el = list.pop ();
+
+      if (tag == el.tag ())
+	break;
+    }
+}
+
+void
+unwind_protect::run_all (void)
+{
+  while (! list.empty ())
+    {
+      unwind_elem el = list.pop ();
+
+      unwind_elem::cleanup_func f = el.fptr ();
+
+      if (f)
+	f (el.ptr ());
+    }
 }
 
 void
-unwind_protect_ptr_internal (void **ptr, void *value)
+unwind_protect::discard_all (void)
+{
+  list.clear ();
+}
+
+void
+unwind_protect::save_bool (bool *ptr, bool value)
+{
+  saved_variable *s = new saved_variable (ptr, value);
+  add (saved_variable::restore, s);
+}
+
+void
+unwind_protect::save_int (int *ptr, int value)
 {
   saved_variable *s = new saved_variable (ptr, value);
-  add_unwind_protect (restore_saved_variable, s);
+  add (saved_variable::restore, s);
+}
+
+void
+unwind_protect::save_str (string *ptr, const string& value)
+{
+  saved_variable *s = new saved_variable (ptr, value);
+  add (saved_variable::restore, s);
+}
+
+void
+unwind_protect::save_ptr (void **ptr, void *value)
+{
+  saved_variable *s = new saved_variable (ptr, value);
+  add (saved_variable::restore, s);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/unwind-prot.h b/src/unwind-prot.h
--- a/src/unwind-prot.h
+++ b/src/unwind-prot.h
@@ -26,46 +26,25 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 #include <cstddef>
 
 #include <string>
 
-typedef void (*cleanup_func)(void *ptr);
-
-void add_unwind_protect (cleanup_func fptr, void *ptr);
-void run_unwind_protect (void);
-void discard_unwind_protect (void);
-void begin_unwind_frame (const string& tag);
-void run_unwind_frame (const string& tag);
-void discard_unwind_frame (const string& tag);
-void run_all_unwind_protects (void);
-void discard_all_unwind_protects (void);
-
-void unwind_protect_int_internal (int *ptr, int value);
-void unwind_protect_str_internal (string *ptr, const string& value);
-void unwind_protect_ptr_internal (void **ptr, void *value);
-void unwind_protect_var_internal (void *ptr, void *value, size_t size);
-
-#define unwind_protect_int(i) \
-  unwind_protect_int_internal (&(i), (i))
-
-#define unwind_protect_str(s) \
-  unwind_protect_str_internal (&(s), (s))
-
-#define unwind_protect_ptr(p) \
-  unwind_protect_ptr_internal (static_cast<void **> (&(p)), \
-			       static_cast<void *> (p))
+#include <SLStack.h>
 
 class
 unwind_elem
 {
- public:
+public:
+
+  typedef void (*cleanup_func) (void *ptr);
+
   unwind_elem (void)
     : ue_tag (), ue_fptr (0), ue_ptr (0) { }
 
   unwind_elem (const string &t)
     : ue_tag (t), ue_fptr (0), ue_ptr (0) { }
 
   unwind_elem (cleanup_func f, void *p)
     : ue_tag (), ue_fptr (f), ue_ptr (p) { }
@@ -85,21 +64,75 @@ unwind_elem
     }
 
   string tag (void) { return ue_tag; }
 
   cleanup_func fptr (void) { return ue_fptr; }
 
   void *ptr (void) { return ue_ptr; }
 
- private:
+private:
+
   string ue_tag;
+
   cleanup_func ue_fptr;
+
   void *ue_ptr;
 };
 
+class
+unwind_protect
+{
+public:
+
+  static void add (unwind_elem::cleanup_func fptr, void *ptr);
+
+  static void run (void);
+
+  static void discard (void);
+
+  static void begin_frame (const string& tag);
+
+  static void run_frame (const string& tag);
+
+  static void discard_frame (const string& tag);
+
+  static void run_all (void);
+
+  static void discard_all (void);
+
+  // Ways to save variables.
+
+  static void save_bool (bool *ptr, bool value);
+
+  static void save_int (int *ptr, int value);
+
+  static void save_str (string *ptr, const string& value);
+
+  static void save_ptr (void **ptr, void *value);
+
+  static void save_var (void *ptr, void *value, size_t size);
+
+  static SLStack<unwind_elem> list;
+};
+
+// We could get by without these macros, but they are nice to have...
+
+#define unwind_protect_bool(b) \
+  unwind_protect::save_bool (&(b), (b))
+
+#define unwind_protect_int(i) \
+  unwind_protect::save_int (&(i), (i))
+
+#define unwind_protect_str(s) \
+  unwind_protect::save_str (&(s), (s))
+
+#define unwind_protect_ptr(p) \
+  unwind_protect::save_ptr (static_cast<void **> (&(p)), \
+			    static_cast<void *> (p))
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -83,17 +83,17 @@ extern "C" int strncasecmp (const char*,
 // Top level context (?)
 extern jmp_buf toplevel;
 
 // Return to the main command loop in octave.cc.
 
 extern "C" void
 jump_to_top_level (void)
 {
-  run_all_unwind_protects ();
+  unwind_protect::run_all ();
 
   longjmp (toplevel, 1);
 }
 
 int
 almost_match (const string& std, const string& s, int min_match_len,
 	      int case_sens)
 {
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -741,73 +741,73 @@ static void
 restore_input_stream (void *f)
 {
   command_editor::set_input_stream (static_cast<FILE *> (f));
 }
 
 static int
 parse_fcn_file (bool exec_script, const string& ff)
 {
-  begin_unwind_frame ("parse_fcn_file");
+  unwind_protect::begin_frame ("parse_fcn_file");
 
   int script_file_executed = 0;
 
   // Open function file and parse.
 
   int old_reading_fcn_file_state = reading_fcn_file;
 
   FILE *in_stream = command_editor::get_input_stream ();
 
-  add_unwind_protect (restore_input_stream, in_stream);
+  unwind_protect::add (restore_input_stream, in_stream);
 
   unwind_protect_ptr (ff_instream);
 
   unwind_protect_int (line_editing);
   unwind_protect_int (input_line_number);
   unwind_protect_int (current_input_column);
   unwind_protect_int (reading_fcn_file);
 
   line_editing = 0;
   reading_fcn_file = 1;
   input_line_number = 0;
   current_input_column = 1;
 
   FILE *ffile = get_input_from_file (ff, 0);
 
-  add_unwind_protect (safe_fclose, ffile);
+  unwind_protect::add (safe_fclose, ffile);
 
   if (ffile)
     {
       // Check to see if this file defines a function or is just a
       // list of commands.
 
       if (is_function_file (ffile))
 	{
 	  // XXX FIXME XXX -- we shouldn't need both the
 	  // command_history object and the
 	  // Vsaving_history variable...
 	  command_history::ignore_entries ();
 
-	  add_unwind_protect (restore_command_history, 0);
+	  unwind_protect::add (restore_command_history, 0);
 
 	  unwind_protect_int (Vecho_executing_commands);
 	  unwind_protect_int (Vsaving_history);
 	  unwind_protect_int (reading_fcn_file);
 	  unwind_protect_int (input_from_command_line_file);
 
 	  Vecho_executing_commands = ECHO_OFF;
 	  Vsaving_history = 0;
 	  reading_fcn_file = 1;
 	  input_from_command_line_file = 0;
 
 	  YY_BUFFER_STATE old_buf = current_buffer ();
 	  YY_BUFFER_STATE new_buf = create_buffer (ffile);
 
-	  add_unwind_protect (restore_input_buffer, (void *) old_buf);
-	  add_unwind_protect (delete_input_buffer, (void *) new_buf);
+	  unwind_protect::add (restore_input_buffer, (void *) old_buf);
+	  unwind_protect::add (delete_input_buffer, (void *) new_buf);
 
 	  switch_to_buffer (new_buf);
 
 	  unwind_protect_ptr (curr_sym_tab);
 
 	  reset_parser ();
 
 	  help_buf = gobble_leading_white_space (ffile, true, true);
@@ -830,31 +830,31 @@ parse_fcn_file (bool exec_script, const 
 	  // proper value when we unwind from this frame.
 	  reading_fcn_file = old_reading_fcn_file_state;
 
 	  // XXX FIXME XXX -- we shouldn't need both the
 	  // command_history object and the
 	  // Vsaving_history variable...
 	  command_history::ignore_entries ();
 
-	  add_unwind_protect (restore_command_history, 0);
+	  unwind_protect::add (restore_command_history, 0);
 
 	  unwind_protect_int (Vsaving_history);
 	  unwind_protect_int (reading_script_file);
 
 	  Vsaving_history = 0;
 	  reading_script_file = 1;
 
 	  parse_and_execute (ffile);
 
 	  script_file_executed = 1;
 	}
     }
 
-  run_unwind_frame ("parse_fcn_file");
+  unwind_protect::run_frame ("parse_fcn_file");
 
   return script_file_executed;
 }
 
 static bool
 load_fcn_from_file (symbol_record *sym_rec, bool exec_script)
 {
   bool script_file_executed = false;
@@ -866,31 +866,31 @@ load_fcn_from_file (symbol_record *sym_r
       force_link_to_function (nm);
     }
   else
     {
       string ff = fcn_file_in_path (nm);
 
       // These are needed by yyparse.
 
-      begin_unwind_frame ("load_fcn_from_file");
+      unwind_protect::begin_frame ("load_fcn_from_file");
 
       unwind_protect_str (curr_fcn_file_name);
       unwind_protect_str (curr_fcn_file_full_name);
 
       curr_fcn_file_name = nm;
       curr_fcn_file_full_name = ff;
 
       if (ff.length () > 0)
 	script_file_executed = parse_fcn_file (exec_script, ff);
 
       if (! (error_state || script_file_executed))
 	force_link_to_function (nm);
 
-      run_unwind_frame ("load_fcn_from_file");
+      unwind_protect::run_frame ("load_fcn_from_file");
     }
 
   return script_file_executed;
 }
 
 bool
 lookup (symbol_record *sym_rec, bool exec_script)
 {
@@ -970,21 +970,21 @@ get_help_from_file (const string& path)
   string retval;
 
   if (! path.empty ())
     {
       FILE *fptr = fopen (path.c_str (), "r");
 
       if (fptr)
 	{
-	  add_unwind_protect (safe_fclose, (void *) fptr);
+	  unwind_protect::add (safe_fclose, (void *) fptr);
 
 	  retval = gobble_leading_white_space (fptr, true, true);
 
-	  run_unwind_protect ();
+	  unwind_protect::run ();
 	}
     }
 
   return retval;
 }
 
 // Variable values.
 
