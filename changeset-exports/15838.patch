# HG changeset patch
# User Michael Goffioul <michael.goffioul@gmail.com>
# Date 1356285602 18000
#      Sun Dec 23 13:00:02 2012 -0500
# Branch classdef
# Node ID 009984ecf41931cec0de4847f61c7a134dc1f025
# Parent  6ea536cb73603a1b0c7741ba6fe8ad6d98b486e8
# Parent  fe2cefaa772b70b866f00e9dec95a3c7e263c389
maint: periodic merge of default to classdef

diff --git a/.gitignore b/.gitignore
new file mode 100644
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,8 @@
+*~
+*.user
+*.o
+*.a
+Makefile*
+*.pdb
+debug/
+release/
diff --git a/.hgignore b/.hgignore
--- a/.hgignore
+++ b/.hgignore
@@ -3,22 +3,21 @@ syntax: regexp
 # to mean "at any directory" while the ^ idiom means "from the
 # project's top-level directory".
 
 # gnulib makes these silly backup files
 .~$
 
 # This directory gets created by gnulib during the build. 
 # It contains no Octave files.
-^gnulib/
+^libgnu/*
 
-# These directories mostly contain cruft during build time, but they
-# do contain some Octave code, so we gotta be a bit more careful about
+# This directory mostly contains cruft during build time, but it does
+# contain some Octave code, so we gotta be a bit more careful about
 # what we ignore here
-^libgnu/.*\.([hc]$|sin$|valgrind$|charset$|mk$)
 ^m4/(?!ax_).+\.m4$
 
 # Emacs tools create these
 (^|/)TAGS$
 (^|/)semantic.cache$
 
 (/|^)Makefile\.in$
 ^INSTALL$
diff --git a/.hgsub b/.hgsub
--- a/.hgsub
+++ b/.hgsub
@@ -1,2 +1,1 @@
 gnulib = [git]git://git.sv.gnu.org/gnulib
-libgui/qterminal = [git]https://code.google.com/p/qterminal/
diff --git a/.hgsubstate b/.hgsubstate
--- a/.hgsubstate
+++ b/.hgsubstate
@@ -1,2 +1,1 @@
-1af55d85d9762a679b4302d5995f05ccd883e956 gnulib
-0820083f7fe95d0088971b1233540c7827218e7c libgui/qterminal
+e657573866e8aded3b3b1461c346cf9ad02a5148 gnulib
diff --git a/Makefile.am b/Makefile.am
--- a/Makefile.am
+++ b/Makefile.am
@@ -38,16 +38,17 @@ EXTRA_DIST = \
   NEWS \
   README \
   bootstrap \
   build-aux/bootstrap_gnulib \
   build-aux/bootstrap_gnulib.conf \
   build-aux/mk-opts.pl \
   build-aux/mkinstalldirs \
   build-aux/move-if-change \
+  build-aux/OctJavaQry.class \
   etc/NEWS.1 \
   etc/NEWS.2 \
   etc/NEWS.3 \
   etc/OLD-ChangeLogs/ChangeLog \
   etc/OLD-ChangeLogs/ChangeLog.1 \
   etc/OLD-ChangeLogs/doc-ChangeLog \
   etc/OLD-ChangeLogs/libcruft-ChangeLog \
   etc/OLD-ChangeLogs/liboctave-ChangeLog \
diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -83,32 +83,74 @@ Summary of important user-visible change
     Octave:array-as-vector => Octave:array-to-vector
 
  ** The colormap function now provides new options--"list", "register",
     and "unregister"--to list all available colormap functions, and to
     add or remove a function name from the list of known colormap
     functions.  Packages that implement extra colormaps should use these
     commands with PKG_ADD and PKG_DEL statements.
 
+ ** The m-files in the image directory have been overhauled.
+
+    The principal benefit is that Octave will now no longer automatically
+    convert images stored with integers to doubles.  Storing images as uint8
+    or uint16 requires only 1/8 or 1/4 the memory of an image stored using
+    doubles.  For certain operations, such as fft2, the image must still be
+    converted to double in order to work.
+
+    Other changes include fixes to the way indexed images are read from a
+    colormap depending on the image class (integer images have a -1 offset to
+    the colormap row number).
+
  ** The datevec function has been extended for better Matlab compatibility.
     It now accepts string inputs in the following numerical formats: 12, 21,
     22, 26, 29, 31.  This is undocumented, but verifiable, Matlab behavior.
     In addition, the default for formats which do not specify a date is
     January 1st of the current year.  The previous default was the current day,
     month, and year.  This may produce changes in existing scripts.
 
+ ** The error function and its derivatives has been extended to accept complex
+    arguments.  The following functions now accept complex inputs:
+
+    erf  erfc  erfcx   
+
+    In addition two new error functions erfi (imaginary error function) and
+    dawson (scaled imaginary error function) have been added.
+
  ** The default name of the Octave crash dump file is now called
     octave-workspace instead of octave-core.
-      
+
+ ** The java package from Octave Forge is now part of core Octave.  The
+    following new functions are available for interacting with Java
+    directly from Octave:
+
+      java                  java_invoke
+      java2mat              java_new
+      javaArray             java_set
+      javaMethod            java_unsigned_conversion
+      javaObject            javaaddpath
+      java_convert_matrix   javaclasspath
+      java_debug            javafields
+      java_exit             javamem
+      java_get              javamethods
+      java_init             javarmpath
+
+    In addition, the following functions that use the Java interface
+    are now available (provided that Octave is compiled with support for
+    Java enabled):
+
+      helpdlg    listdlg   questdlg
+      inputdlg   msgbox    warndlg
+
  ** Other new functions added in 3.8.0:
 
-      betaincinv   erfcinv      lines      rgbplot
-      cmpermute    findfigs     polyeig    shrinkfaces
-      cmunique     fminsearch   splinefit
-      colorcube    iscolormap   tetramesh
+      betaincinv   dawson     fminsearch   rgbplot    
+      cmpermute    erfcinv    iscolormap   shrinkfaces
+      cmunique     erfi       lines        splinefit             
+      colorcube    findfigs   polyeig      tetramesh             
 
  ** Deprecated functions.
 
     The following functions were deprecated in Octave 3.4 and have been
     removed from Octave 3.8.
                                            
       autocor    dispatch              is_global    strerror
       autocov    fstat                 krylovb      values  
diff --git a/build-aux/OctJavaQry.class b/build-aux/OctJavaQry.class
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..f165d7eafe3c6b3523e8a822fa1862aed5119b07
GIT binary patch
literal 774
zc${rg%Wl&^6g|^C>^N?drX;jL11(UT010HnA_ytvp{gWxP@*nifyQB!x;S=l#z_4L
zK7b8d)@4x;i+%tfg}CDsqK0}g*K^M~ch0>tzkdHb1<*jlz#=Z|ST(SQD;ZqHH67~)
z#j=6xxS?Z1$EJ>(I&NvWtznBH{n+(g`Gg^1RrVQ@PlI=YA=h?&u@{XT5%#&`Q6@R!
zuFp`i-n0+-M_%{1Kdkp;==#H^5-#>6AH47I@fqLf1yMK<FI=_B*#o&ts#oDrO{q;R
zA;*x}ZSA+-?%18@8t#~|P|;8|aToUpQ@q+iFcK#2qo$#5;sG8qWMfhLS+~{SVOWl7
zp6i61YLB@*AS*Fr+qU~tPH__XH75w<9M71!V#v?BvYkUQkmpj<Mrm5&L&Uua)wJ64
zf@bCQdCk#8iV+Pqh^Sa`%6Ef$mr6-0DEO#J?F@zNhQU~bl3Z+A7fkp66vN5|)flv~
z+Ijw*zkk<+4Vd&q)VBbpE`ioO?bazWimB>%uw(k6$<msRlL=%{z{(l*Q!EAcs;6J@
zvYKcV7EX}(jOA}g7E(WuK7sZX4F%{kAoCYkQ-BczOA5$Nf#cYcI&%{`tr}8vY93jX
c$#8{?J|c9RTy#*vC1n+f@@kQ+6k}=W4~M0zR{#J2

diff --git a/build-aux/OctJavaQry.java b/build-aux/OctJavaQry.java
new file mode 100644
--- /dev/null
+++ b/build-aux/OctJavaQry.java
@@ -0,0 +1,23 @@
+// Code used by configure script to locate Java installation variables.
+// Only compiled code, OctJavaQry.class, is distributed.
+public class OctJavaQry
+{
+  public static void main (String[] args)
+  {
+    if (args.length > 0)
+    {
+      if (args[0].equals ("JAVA_HOME"))
+      {
+        System.out.println (System.getProperty ("java.home"));
+      }
+      else if (args[0].equals ("JAVA_LDPATH"))
+      {
+        System.out.println (System.getProperty ("java.library.path"));
+      }
+      else if (args[0].equals ("JAVA_BOOTPATH"))
+      {
+        System.out.println (System.getProperty ("sun.boot.library.path"));
+      }
+    }
+  }
+}
diff --git a/build-aux/common.mk b/build-aux/common.mk
--- a/build-aux/common.mk
+++ b/build-aux/common.mk
@@ -46,16 +46,17 @@ AR = @AR@
 ARFLAGS = @ARFLAGS@ 
 
 TEMPLATE_AR = @TEMPLATE_AR@
 TEMPLATE_ARFLAGS = @TEMPLATE_ARFLAGS@
 
 RANLIB = @RANLIB@
 
 LN_S = @LN_S@
+MKDIR_P = @MKDIR_P@
 
 MAKEINFO = @MAKEINFO@
 TEXI2DVI = @TEXI2DVI@
 TEXI2PDF = @TEXI2PDF@
 
 GHOSTSCRIPT = @GHOSTSCRIPT@
 
 DEFAULT_PAGER = @DEFAULT_PAGER@
@@ -219,16 +220,19 @@ GLPK_LIBS = @GLPK_LIBS@
 
 GRAPHICS_CFLAGS = @GRAPHICS_CFLAGS@
 GRAPHICS_LIBS = @GRAPHICS_LIBS@
 
 HDF5_CPPFLAGS = @HDF5_CPPFLAGS@
 HDF5_LDFLAGS = @HDF5_LDFLAGS@
 HDF5_LIBS = @HDF5_LIBS@
 
+JAVA_CPPFLAGS = @JAVA_CPPFLAGS@
+JAVA_LIBS = @JAVA_LIBS@
+
 LAPACK_LIBS = @LAPACK_LIBS@
 
 LLVM_CPPFLAGS = @LLVM_CPPFLAGS@
 LLVM_LDFLAGS = @LLVM_LDFLAGS@
 LLVM_LIBS = @LLVM_LIBS@
 
 MAGICK_CPPFLAGS = @MAGICK_CPPFLAGS@
 MAGICK_LDFLAGS = @MAGICK_LDFLAGS@
@@ -571,18 +575,19 @@ echo "making $@ from $<"
   -e "s|%OCTAVE_CONF_PTHREAD_CFLAGS%|\"${PTHREAD_CFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_PTHREAD_LIBS%|\"${PTHREAD_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_QHULL_CPPFLAGS%|\"${QHULL_CPPFLAGSS}\"|" \
   -e "s|%OCTAVE_CONF_QHULL_LDFLAGS%|\"${QHULL_LDFLAGSS}\"|" \
   -e "s|%OCTAVE_CONF_QHULL_LIBS%|\"${QHULL_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_QRUPDATE_CPPFLAGS%|\"${QRUPDATE_CPPFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_QRUPDATE_LDFLAGS%|\"${QRUPDATE_LDFLAGS}\"|" \
   -e "s|%OCTAVE_CONF_QRUPDATE_LIBS%|\"${QRUPDATE_LIBS}\"|" \
-  -e "s|%OCTAVE_CONF_QT_INCDIR%|\"${QT_INCDIR}\"|" \
-  -e "s|%OCTAVE_CONF_QT_LIBDIR%|\"${QT_LIBDIR}\"|" \
+  -e "s|%OCTAVE_CONF_QT_CPPFLAGS%|\"${QT_CPPFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_QT_LDFLAGS%|\"${QT_LDFLAGS}\"|" \
+  -e "s|%OCTAVE_CONF_QT_LIBS%|\"${QT_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_RANLIB%|\"${RANLIB}\"|" \
   -e "s|%OCTAVE_CONF_RDYNAMIC_FLAG%|\"${RDYNAMIC_FLAG}\"|" \
   -e "s|%OCTAVE_CONF_READLINE_LIBS%|\"${READLINE_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_REGEX_LIBS%|\"${REGEX_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_SED%|\"${SED}\"|" \
   -e "s|%OCTAVE_CONF_SHARED_LIBS%|\"${SHARED_LIBS}\"|" \
   -e "s|%OCTAVE_CONF_SHLEXT%|\"${SHLEXT}\"|" \
   -e "s|%OCTAVE_CONF_SHLLINKEXT%|\"${SHLLINKEXT}\"|" \
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -119,16 +119,37 @@ OCTAVE_SET_DEFAULT([imagedir], '$(datadi
 
 PKG_PROG_PKG_CONFIG
 
 ### Make configure args available for other uses.
 
 config_opts=$ac_configure_args
 AC_SUBST(config_opts)
 
+### Define the path to the shell on the host system.  Most systems will
+### ensure /bin/sh is the default shell so this can be safely ignored by
+### almost everyone.  However, when building for Android, for example,
+### this will need to be set.
+SHELL_PATH=/bin/sh
+AC_ARG_WITH([shell],
+  [AS_HELP_STRING([--with-shell=SHELL],
+    [use SHELL as the shell interpreter (default: /bin/sh)])])
+case $with_shell in
+  no)
+    AC_MSG_ERROR([A shell interpreter is required])
+  ;;
+  yes | "")
+  ;;
+  *)
+    SHELL_PATH=$with_shell
+  ;;
+esac
+AC_DEFINE_UNQUOTED([SHELL_PATH], ["$SHELL_PATH"],
+  [Define this to be the path to the shell command interpreter.])
+
 ### Enable bounds checking on element references within Octave's array and
 ### matrix classes.  This slows down some operations a bit, so it is turned off
 ### by default.
 
 BOUNDS_CHECKING=false
 AC_ARG_ENABLE([bounds-check],
   [AS_HELP_STRING([--enable-bounds-check],
     [enable bounds checking for indexing in internal array classes])],
@@ -949,20 +970,29 @@ if test -z "$OPENGL_LIBS"; then
   fi
 fi
 
 if test -n "$OPENGL_LIBS"; then
   AC_DEFINE(HAVE_OPENGL, 1, [Define to 1 if OpenGL is available.])
 
   ## Check for FreeType 2 library
 
-  AC_CHECK_FT2([9.0.3],
-    [AC_DEFINE(HAVE_FREETYPE, 1, [Define to 1 if you have FreeType library.])
-     XTRA_CXXFLAGS="$XTRA_CXXFLAGS $FT2_CFLAGS"],
-    [warn_freetype="FreeType library not found.  Native graphics will be disabled."])
+  PKG_CHECK_MODULES([FT2], [freetype2], [
+    min_ft2_version=9.03
+    AC_MSG_CHECKING([for FreeType -- version >= $min_ft2_version])
+    $PKG_CONFIG freetype2 --atleast-version=$min_ft2_version
+    ac_status=$?
+    if test $ac_status = 0; then
+      AC_MSG_RESULT(yes)
+      AC_DEFINE(HAVE_FREETYPE, 1, [Define to 1 if you have Freetype library.])
+      XTRA_CXXFLAGS="$XTRA_CXXFLAGS $FT2_CFLAGS"
+    else
+      AC_MSG_RESULT(no)
+      warn_freetype="FreeType library not found.  Native graphics will be disabled."
+    fi])
 
   if test -n "$warn_freetype"; then
     OCTAVE_CONFIGURE_WARNING([warn_freetype])
     native_graphics=false
   fi
 
   ## Check for fontconfig library
 
@@ -1094,17 +1124,17 @@ if test x"$enable_static" = x"yes"; then
   STATIC_LIBS=true
 else
   STATIC_LIBS=false
 fi
 
 XTRA_CRUFT_SH_LDFLAGS=
 if test $have_msvc = yes; then
   FLIBS="$FLIBS -lkernel32"
-  XTRA_CRUFT_SH_LDFLAGS="-Wl,-def:cruft.def"
+  XTRA_CRUFT_SH_LDFLAGS="-Wl,-def:cruft/cruft.def"
 fi
 AC_SUBST(XTRA_CRUFT_SH_LDFLAGS)
 
 ### Check for BLAS and LAPACK libraries:
 
 ## Need to adjust FFLAGS to include correct integer size.
 save_FFLAGS="$FFLAGS"
 FFLAGS="$FFLAGS $F77_INTEGER_8_FLAG"
@@ -2071,16 +2101,17 @@ OCTAVE_PROG_PERL
 OCTAVE_PROG_PYTHON
 
 OCTAVE_PROG_FLEX
 AC_SUBST([LEX_OUTPUT_ROOT], [lex.octave_])
 
 OCTAVE_PROG_BISON
 
 AC_PROG_LN_S
+AC_PROG_MKDIR_P
 
 AC_PROG_INSTALL
 INSTALL_SCRIPT='${INSTALL}'
 AC_SUBST(INSTALL_SCRIPT)
 
 OCTAVE_PROG_DESKTOP_FILE_INSTALL
 
 OCTAVE_PROG_GNUPLOT
@@ -2097,30 +2128,16 @@ OCTAVE_PROG_TEXI2PDF
 
 if test -n "$DOCDIR" && test -n "$warn_gnuplot"; then
   DOCDIR=
   warn_docs="building documentation disabled because gnuplot was not found; make dist will fail"
   OCTAVE_CONFIGURE_WARNING([warn_docs])
 fi
 AM_CONDITIONAL([AMCOND_BUILD_DOCS], [test -n "$DOCDIR"])
 
-### Even though we include config.h, we need to have the preprocessor
-### defines available in a variable for the testif feature of the
-### scripts/testfun/test.m function.  Use UGLY_DEFS to hold all the -D
-### options.  These are ultimately placed in the DEFS field of the
-### struct returned by octave_config_info, which is used by test.m.
-
-AC_OUTPUT_MAKE_DEFS
-
-### We have to insert extra levels of backslash quoting here so that
-### the right thing ends up in oct-conf.h.
-UGLY_DEFS=`echo $DEFS | $SED 's,\\",\\\\\\\\\\\\\\\\\\",g'`
-AC_MSG_NOTICE([defining UGLY_DEFS to be $UGLY_DEFS])
-AC_SUBST(UGLY_DEFS)
-
 ### Maybe add -Wall, -W, and -Wshadow to compiler flags now that we're
 ### done feature testing. 
 
 GCC_EXTRA_FLAGS="-Wall -W -Wshadow -Wformat -Wpointer-arith -Wmissing-prototypes -Wstrict-prototypes -Wwrite-strings -Wcast-align -Wcast-qual"
 
 GXX_EXTRA_FLAGS="-Wall -W -Wshadow -Wold-style-cast -Wformat -Wpointer-arith -Wwrite-strings -Wcast-align -Wcast-qual"
 
 try_extra_warning_flags=true
@@ -2171,83 +2188,354 @@ if $try_strict_warning_flags; then
       WARN_CXXFLAGS="$WARN_CXXFLAGS $flag";
       AC_MSG_RESULT([adding $flag to WARN_CXXFLAGS])])
   done
 fi
 
 AC_SUBST(WARN_CFLAGS)
 AC_SUBST(WARN_CXXFLAGS)
 
+### Check for Java.
+
+build_java=true
+AC_ARG_ENABLE([java],
+  [AS_HELP_STRING([--disable-java],
+    [disable Java interface])],
+  [if test "$enableval" = no; then
+     build_java=false
+   fi],
+  [])
+
+AC_ARG_WITH([java-homedir],
+  [AS_HELP_STRING([--with-java-homedir=DIR],
+    [Java JDK directory in DIR])],
+  [JAVA_HOMEDIR="$withval"])
+
+AC_ARG_WITH([java-includedir],
+  [AS_HELP_STRING([--with-java-includedir=DIR],
+    [look for java include file <jni.h> in DIR])],
+  [JAVA_CPPFLAGS="$withval"], [JAVA_CPPFLAGS=""])
+
+AC_ARG_WITH([java-libdir],
+  [AS_HELP_STRING([--with-java-libdir=DIR],
+    [look for java library libjvm in DIR])],
+  [JAVA_LDPATH="$withval"], [JAVA_LDPATH=""])
+
+## Grab JAVA_HOME from environment variable if it exists
+AC_ARG_VAR([JAVA_HOME], [path to Java JDK installation])
+## But --with-java-homedir option overrides environment variable
+if test -n "$JAVA_HOMEDIR"; then
+  JAVA_HOME=$JAVA_HOMEDIR
+fi
+JAVA=
+JAVAC=
+JAR=
+JAVA_LIBS=
+
+## Fake loop so that "break" can be used to skip code blocks.
+while test $build_java = true
+do
+  ## Unset build_java.  Variable is set only if all configuration tests pass.
+  build_java=false
+
+  ## Warn if JAVA_HOME is unset.  It is *strongly* advised to specify JAVA_HOME.
+  if test -z "$JAVA_HOME"; then
+    AC_MSG_WARN([JAVA_HOME environment variable not initialized.])
+    AC_MSG_WARN([Auto-detection will proceed but is unreliable.])
+  fi
+
+  ## Search for a viable Java executable.
+  if test -z "$JAVA_HOME"; then
+    JAVA_PATH="$PATH"
+  else
+    JAVA_PATH="${JAVA_HOME}$PATH_SEPARATOR${JAVA_HOME}/jre/bin$PATH_SEPARATOR${JAVA_HOME}/bin$PATH_SEPARATOR${JAVA_HOME}/../bin$PATH_SEPARATOR${PATH}"
+  fi
+  AC_PATH_PROG(JAVA, java, [], [$JAVA_PATH])
+
+  if test -z "$JAVA"; then
+    AC_MSG_WARN([No Java executable found.  Octave will not be able to call Java methods.])   
+    break
+  fi
+
+  if test -z "$JAVA_HOME"; then
+    ## Find JAVA_HOME for JRE by running java and querying properties.
+    JAVA_TMP_HOME="`\"$JAVA\" -classpath ${srcdir}/build-aux OctJavaQry JAVA_HOME`"
+    ## Strip directory back to top-level installation dir (JAVA_HOME for JDK).
+    JAVA_HOME="`echo $JAVA_TMP_HOME | sed -e 's|[[/\\]]bin[[/\\]]\?$||' | sed -e 's|[[/\\]]jre[[/\\]]\?$||'`"
+  fi
+
+  case $canonical_host_type in
+    *-mingw* | *-msdosmsvc*)
+      ## Under Win32 platform, we want JAVA_HOME to be in MSYS format, that is without
+      ## colon and backslashes, as it is also used as path separator. Use quoted paths
+      ## as Java may be installed in a path with whitespaces (e.g. C:\Program Files\Java\...).
+      if test -n "$JAVA_HOME"; then
+        JAVA_HOME="`cd \"$JAVA_HOME\" && pwd`"
+	## Maybe this will be useful in the future, as native Java won't probably
+	## understand MSYS paths.
+	JAVA_HOME_NATIVE="`cd \"$JAVA_HOME\" && pwd -W`"
+      fi
+    ;;
+    *)
+      JAVA_HOME_NATIVE="$JAVA_HOME"
+    ;;
+  esac
+
+  ## Amend search path for JAVAC and JAR.
+  if test -z "$JAVA_HOME"; then
+    JAVA_PATH="$PATH"
+  else
+    JAVA_PATH="${JAVA_HOME}$PATH_SEPARATOR${JAVA_HOME}/bin$PATH_SEPARATOR${JAVA_HOME}/../bin$PATH_SEPARATOR${PATH}"
+  fi
+
+  AC_PATH_PROG(JAVAC, javac, [], [$JAVA_PATH])
+  AC_PATH_PROG(JAR, jar, [], [$JAVA_PATH])
+
+  if test -z "$JAVAC" || test -z "$JAR"; then
+    AC_MSG_WARN([No javac compiler or jar executable found.  Octave will not be able to call Java methods.])
+    break
+  fi
+
+  ## Check Java version is recent enough.
+  AC_MSG_CHECKING([for Java version])
+  java_version=[`$"JAVA" -version 2>&1 | sed -n -e 's/^java version[^0-9"]*"\([^"]*\)"/\1/p'`]
+  AC_MSG_RESULT([$java_version])
+  java_major=[`echo $java_version | sed -e 's/^\([0-9][0-9]*\)\.\([0-9][0-9]*\)\..*$/\1/'`]
+  java_minor=[`echo $java_version | sed -e 's/^\([0-9][0-9]*\)\.\([0-9][0-9]*\)\..*$/\2/'`]
+  if test $java_major -ge 1 && test $java_minor -ge 5; then
+    :  # Version is ok.  Do nothing.
+  else
+    AC_MSG_WARN([Java version is too old (< 1.5).  Octave will not be able to call Java methods.])
+    break
+  fi
+
+  ## At this point Win32/MSVC systems have enough configuration data. We assume
+  ## that all appropriate variables (e.g. INCLUDE and LIB) have already the required
+  ## paths to compile and link against JDK.
+  case $canonical_host_type in
+    *-msdosmsvc*)
+      build_java=true
+      JAVA_LIBS=-ladvapi32
+      AC_DEFINE(HAVE_JAVA, 1,
+        [Define to 1 if Java is available and is at least version 1.5])
+      break
+    ;;
+    *-mingw*)
+      if test "$have_msvc" = "yes"; then
+        build_java=true
+        JAVA_LIBS=-ladvapi32
+        AC_DEFINE(HAVE_JAVA, 1,
+          [Define to 1 if Java is available and is at least version 1.5])
+        break
+      fi
+    ;;
+  esac
+
+  ## Determine which library file name to search for.
+  case $canonical_host_type in
+    *-darwin*)
+      jvmlib=libjvm.dylib
+    ;;
+    *-mingw* | *-cygwin*)
+      jvmlib=jvm.dll
+    ;;
+    *)
+      jvmlib=libjvm.so
+    ;;
+  esac
+
+  AC_MSG_CHECKING([for $jvmlib])
+
+  if test -z "$JAVA_LDPATH"; then
+    ## Run Java to try and determine library path to libjvm.so.
+    JAVA_TMP_LDPATH=`$JAVA -classpath ${srcdir}/build-aux OctJavaQry JAVA_LDPATH`
+    JAVA_TMP_LDPATH=`echo $JAVA_TMP_LDPATH | sed -e "s/${PATH_SEPARATOR}/ /g"`
+    for dir in $JAVA_TMP_LDPATH; do
+      if test -f "$dir/$jvmlib"; then
+        JAVA_LDPATH=$dir
+        break
+      fi
+    done
+  fi
+
+  if test -z "$JAVA_LDPATH"; then
+    ## Nothing found.  Try Java again using bootpath argument. 
+    JAVA_TMP_LDPATH=`$JAVA -classpath ${srcdir}/build-aux OctJavaQry JAVA_BOOTPATH`
+    JAVA_TMP_LDPATH="${JAVA_TMP_LDPATH} ${JAVA_TMP_LDPATH}/client ${JAVA_TMP_LDPATH}/server"
+    for dir in $JAVA_TMP_LDPATH; do
+      if test -f "$dir/$jvmlib"; then
+        JAVA_LDPATH=$dir
+        break
+      fi
+    done
+  fi
+
+  if test -z "$JAVA_LDPATH"; then
+    ## Java failed to find it's own library path.  Guess wildly.
+    JAVA_TMP_LDPATH=`ls -d $JAVA_HOME/jre/lib/*/client`
+    JAVA_TMP_LDPATH="${JAVA_TMP_LDPATH} `ls -d $JAVA_HOME/jre/lib/*/server`"
+    ## Add some paths that might work on Macs.
+    JAVA_TMP_LDPATH="${JAVA_TMP_LDPATH} ${JAVA_HOME}/../Libraries ${JAVA_HOME}/Libraries"
+    ## Add some paths that might work on MinGW
+    JAVA_TMP_LDPATH="${JAVA_TMP_LDPATH} ${JAVA_HOME}/bin/client ${JAVA_HOME}/bin/server"
+    for dir in $JAVA_TMP_LDPATH; do
+      if test -f "$dir/$jvmlib"; then
+        JAVA_LDPATH=$dir
+        break
+      fi
+    done
+  fi
+
+  ## Verify value passed in option --with-java-libdir
+  if test -n "$JAVA_LDPATH"; then
+    if test -f "${JAVA_LDPATH}/$jvmlib"; then
+      :  # libjvm found
+    else
+      JAVA_LDPATH=""
+    fi 
+  fi
+
+  if test -z "$JAVA_LDPATH"; then
+    AC_MSG_RESULT([not found])
+    AC_MSG_WARN([Library $jvmlib not found.  Octave will not be able to call Java methods.])
+    break
+  else
+    AC_MSG_RESULT([$JAVA_LDPATH])
+  fi
+
+  AC_MSG_CHECKING([for include file <jni.h>])
+
+  ## Java and JVM found.  Set up flags.
+  case $canonical_host_type in
+    *-darwin*)
+      ## Sneak the -framework flag into mkoctfile via LFLAGS
+      LFLAGS="$LFLAGS -framework JavaVM"
+      ## According to: http://developer.apple.com/unix/crossplatform.html
+      ## one must explicitly set the include path.
+      ## Unfortunately, the include path keeps moving around.
+      if test -n "$JAVA_CPPFLAGS"; then
+        JAVA_CPPFLAGS="-I${JAVA_CPPFLAGS}"
+      else
+        JAVA_CPPFLAGS="-I${JAVA_HOME}/include -I/System/Library/Frameworks/JavaVM.framework/Home/include -I/System/Library/Frameworks/JavaVM.framework/Versions/CurrentJDK/Headers -I/System/Library/Frameworks/JavaVM.framework/Versions/Current/Headers"
+      fi
+      JAVA_LIBS="-framework JavaVM"
+    ;;
+    *-mingw* | *-cygwin*)
+      if test -n "$JAVA_CPPFLAGS"; then
+        JAVA_CPPFLAGS="-I${JAVA_CPPFLAGS}/include -I${JAVA_CPPFLAGS}/include/win32"
+      else
+        JAVA_CPPFLAGS="-I${JAVA_HOME}/include -I${JAVA_HOME}/include/win32"
+      fi
+      JAVA_LIBS=-ladvapi32
+    ;;
+    *)
+      if test -n "$JAVA_CPPFLAGS"; then
+        JAVA_CPPFLAGS="-I${JAVA_CPPFLAGS}/include -I${JAVA_CPPFLAGS}/include/linux"
+      else
+        JAVA_CPPFLAGS="-I${JAVA_HOME}/include -I${JAVA_HOME}/include/linux"
+      fi
+    ;;
+  esac
+
+  ## Verify jni.h include file exists.
+	JNI_PATH=`echo $JAVA_CPPFLAGS | sed -e 's/-I//g'`
+  have_jni=false
+	for dir in $JNI_PATH; do 
+	  if test -f "${dir}/jni.h"; then have_jni=true; break; fi
+	done
+  if test $have_jni = true; then
+    AC_MSG_RESULT([$dir])
+  else
+    AC_MSG_RESULT([not found])
+    AC_MSG_WARN([Include file <jni.h> not found.  Octave will not be able to call Java methods.])
+    break
+  fi
+
+  ## Passed all configuration tests.  A workable Java installation was found.
+  build_java=true
+  AC_DEFINE(HAVE_JAVA, 1,
+    [Define to 1 if Java is available and is at least version 1.5])
+  break
+done
+
+AM_CONDITIONAL([AMCOND_HAVE_JAVA], [test $build_java = true])
+AC_SUBST(JAVA)
+AC_SUBST(JAVAC)
+AC_SUBST(JAR)
+AC_SUBST(JAVA_CPPFLAGS)
+AC_SUBST(JAVA_LIBS)
+AC_DEFINE_UNQUOTED([JAVA_HOME], ["$JAVA_HOME"], [Java home (top-level installation dir)])
+AC_DEFINE_UNQUOTED([JAVA_LDPATH], ["$JAVA_LDPATH"], [Java library path (libjvm)])
+
 ### GUI/Qt related tests.
 
-HAVE_QT=false
-QT_INCDIR=
-QT_LIBDIR=
+QT_CPPFLAGS=
+QT_LDFLAGS=
+QT_LIBS=
 win32_terminal=no
 build_gui=true
 GUIDIR=libgui
 AC_ARG_ENABLE([gui],
   [AS_HELP_STRING([--disable-gui], [don't build the GUI])],
   [if test "$enableval" = no; then build_gui=false; fi], [])
 
 if test $build_gui = true; then
   ## Check for Qt libraries
   PKG_CHECK_MODULES(QT, [QtCore, QtGui, QtNetwork],
     [],
     [AC_MSG_ERROR([Qt libraries are required to build the GUI])])
 
-  ## Check for Qt utility programs
-  AC_CHECK_PROGS(QMAKE, [qmake-qt5 qmake-qt4 qmake])
-  if test -z "$QMAKE"; then
-    AC_MSG_ERROR([qmake is required to build the GUI])
-  fi
-
-  QT_INCDIR=`$QMAKE -query QT_INSTALL_HEADERS | sed -e 's,\\\\,/,g'`
-  QT_LIBDIR=`$QMAKE -query QT_INSTALL_LIBS | sed -e 's,\\\\,/,g'`
-
-  if test "$QT_INCDIR" = "**Unknown**"; then
-    AC_MSG_ERROR([qmake >= Qt4 is required to build the GUI])
+  ## Retrieve Qt compilation and linker flags
+  QT_CPPFLAGS="`$PKG_CONFIG --cflags-only-I QtCore QtGui QtNetwork`"
+  QT_LDFLAGS="`$PKG_CONFIG --libs-only-L QtCore QtGui QtNetwork`"
+  QT_LIBS="`$PKG_CONFIG --libs-only-l QtCore QtGui QtNetwork`"
+
+  ## Check for Qt4
+  if ! `$PKG_CONFIG --atleast-version=4.0.0 QtCore`; then
+    AC_MSG_ERROR([Qt >= 4.0.0 is required to build the GUI])
   fi
 
   AC_CHECK_PROGS(MOC, [moc-qt5 moc-qt4 moc])
   AC_CHECK_PROGS(UIC, [uic-qt5 uic-qt4 uic])
   AC_CHECK_PROGS(RCC, [rcc])
   if test -z "$MOC" || test -z "$UIC" || test -z "$RCC"; then
     AC_MSG_ERROR([Qt utility programs moc, uic, and rcc are required to build the GUI])
   fi 
 
-  HAVE_QT=true
   AC_DEFINE(HAVE_QT, 1, 
-    [Define to 1 if Qt is available (libraries, developer header files, utility programs (qmake, moc, uic, and rcc))])
+    [Define to 1 if Qt is available (libraries, developer header files, utility programs (moc, uic, and rcc))])
 
   ## Check for Qscintilla library which is used in the GUI editor. 
   AC_CACHE_CHECK([whether Qscintilla library is installed],
     [octave_cv_lib_qscintilla],
     [save_CPPFLAGS="$CPPFLAGS"
     save_LDFLAGS="$LDFLAGS"
     save_LIBS="$LIBS"
-    CPPFLAGS="-I$QT_INCDIR -I$QT_INCDIR/Qt $CPPFLAGS"
-    LDFLAGS="-L$QT_LIBDIR $LDFLAGS"
-    LIBS="-lqscintilla2"
+    CPPFLAGS="$QT_CPPFLAGS $CPPFLAGS"
+    LDFLAGS="$QT_LDFLAGS $LDFLAGS"
+    LIBS="$QT_LIBS -lqscintilla2"
     AC_LANG_PUSH(C++)
     AC_LINK_IFELSE([AC_LANG_PROGRAM([[
       #include <Qsci/qscilexersql.h>
       ]], [[
       QsciLexerSQL sqlLexer(0);
       ]])],
       octave_cv_lib_qscintilla=yes,
       octave_cv_lib_qscintilla=no)
     CPPFLAGS="$save_CPPFLAGS"
     LDFLAGS="$save_LDFLAGS"
     LIBS="$save_LIBS"
     AC_LANG_POP([C++])
   ])
   if test $octave_cv_lib_qscintilla = no; then
     AC_MSG_ERROR([Qscintilla library is required to build the GUI])
   fi
+  ## Let's assume Qscintilla library is at the same location as
+  ## other regular Qt libraries.
+  QT_LIBS="$QT_LIBS -lqscintilla2"
 
   ## Check for Qt functions which have changed their API over time
   OCTAVE_CHECK_FUNC_FINDFIRST_MODERN
   OCTAVE_CHECK_FUNC_SETPLACEHOLDERTEXT
 
   AC_CHECK_FUNCS([setlocale], [],
                  [AC_MSG_ERROR([Missing function required to build GUI])])
 
@@ -2266,18 +2554,19 @@ if test $build_gui = true; then
       ;;
   esac
 else
   ## GUI disabled.  Eliminate building GUIDIR directory
   GUIDIR=
 fi
 AM_CONDITIONAL([AMCOND_BUILD_GUI], [test $build_gui = true])
 AM_CONDITIONAL([WIN32_TERMINAL], [test $win32_terminal = yes])
-AC_SUBST(QT_INCDIR)
-AC_SUBST(QT_LIBDIR)
+AC_SUBST(QT_CPPFLAGS)
+AC_SUBST(QT_LDFLAGS)
+AC_SUBST(QT_LIBS)
 AC_SUBST(GUIDIR)
 
 ### Run configure in subdirectories.
 
 export CC
 export CXX
 export F77
 
@@ -2443,16 +2732,31 @@ typedef OCTAVE_IDX_TYPE octave_idx_type;
 
 /* Tag indicating Octave config.h has been included */
 #define OCTAVE_CONFIG_INCLUDED 1
 ])
 
 dnl end of AH_BOTTOM
 dnl ------------------------------------------------------------
 
+### Make all AC_DEFINES available to testif feature of test.m function.
+### This must reside at the bottom of configure.ac after all AC_DEFINES
+### have been made.
+### Use UGLY_DEFS to hold all the -D options.  These are ultimately placed
+### in the DEFS field of the struct returned by octave_config_info, which
+### is used by test.m.
+
+AC_OUTPUT_MAKE_DEFS
+
+## We have to insert extra levels of backslash quoting here so that
+## the right thing ends up in oct-conf.h.
+UGLY_DEFS=`echo $DEFS | $SED 's,\\",\\\\\\\\\\\\\\\\\\",g'`
+AC_MSG_NOTICE([defining UGLY_DEFS to be $UGLY_DEFS])
+AC_SUBST(UGLY_DEFS)
+
 ### Do the substitutions in all the Makefiles.
 
 AC_SUBST(ac_config_files)
 AC_SUBST(ac_config_headers)
 
 AC_CONFIG_FILES([
   Makefile 
   doc/Makefile
@@ -2528,34 +2832,39 @@ Octave is now configured for $canonical_
   GLPK CPPFLAGS:               $GLPK_CPPFLAGS
   GLPK LDFLAGS:                $GLPK_LDFLAGS
   GLPK libraries:              $GLPK_LIBS
   graphics CFLAGS:             $GRAPHICS_CFLAGS
   graphics libraries:          $GRAPHICS_LIBS
   HDF5 CPPFLAGS:               $HDF5_CPPFLAGS
   HDF5 LDFLAGS:                $HDF5_LDFLAGS
   HDF5 libraries:              $HDF5_LIBS
+  Java home:                   $JAVA_HOME
+  Java JVM path:               $JAVA_LDPATH
+  Java CPPFLAGS:               $JAVA_CPPFLAGS
+  Java libraries:              $JAVA_LIBS
   LAPACK libraries:            $LAPACK_LIBS
   LLVM CPPFLAGS:               $LLVM_CPPFLAGS
   LLVM LDFLAGS:                $LLVM_LDFLAGS
   LLVM libraries:              $LLVM_LIBS
   Magick++ CPPFLAGS:           $MAGICK_CPPFLAGS
   Magick++ LDFLAGS:            $MAGICK_LDFLAGS
   Magick++ libraries:          $MAGICK_LIBS
   OPENGL libraries:            $OPENGL_LIBS
   PTHREAD flags:               $PTHREAD_CFLAGS
   PTHREAD libraries:           $PTHREAD_LIBS
   QHULL CPPFLAGS:              $QHULL_CPPFLAGS
   QHULL LDFLAGS:               $QHULL_LDFLAGS
   QHULL libraries:             $QHULL_LIBS
   QRUPDATE CPPFLAGS:           $QRUPDATE_CPPFLAGS
   QRUPDATE LDFLAGS:            $QRUPDATE_LDFLAGS
   QRUPDATE libraries:          $QRUPDATE_LIBS
-  Qt headers:                  $QT_INCDIR
-  Qt libraries:                $QT_LIBDIR
+  Qt CPPFLAGS:                 $QT_CPPFLAGS
+  Qt LDFLAGS:                  $QT_LDFLAGS
+  Qt libraries:                $QT_LIBS
   READLINE libraries:          $READLINE_LIBS
   REGEX libraries:             $REGEX_LIBS
   TERM libraries:              $TERM_LIBS
   UMFPACK CPPFLAGS:            $UMFPACK_CPPFLAGS
   UMFPACK LDFLAGS:             $UMFPACK_LDFLAGS
   UMFPACK libraries:           $UMFPACK_LIBS
   X11 include flags:           $X11_INCFLAGS
   X11 libraries:               $X11_LIBS
@@ -2563,16 +2872,17 @@ Octave is now configured for $canonical_
   Z LDFLAGS:                   $Z_LDFLAGS
   Z libraries:                 $Z_LIBS
 
   Default pager:               $DEFAULT_PAGER
   gnuplot:                     $GNUPLOT
 
   Build Octave GUI:                   $build_gui
   JIT compiler for loops:             $build_jit
+  Build Java interface:               $build_java
   Do internal array bounds checking:  $BOUNDS_CHECKING
   Use octave_allocator:               $USE_OCTAVE_ALLOCATOR
   Build static libraries:             $STATIC_LIBS
   Build shared libraries:             $SHARED_LIBS
   Dynamic Linking:                    $ENABLE_DYNAMIC_LINKING $DL_API_MSG
   Include support for GNU readline:   $USE_READLINE
   64-bit array dims and indexing:     $USE_64_BIT_IDX_T
 ])
diff --git a/doc/interpreter/Makefile.am b/doc/interpreter/Makefile.am
--- a/doc/interpreter/Makefile.am
+++ b/doc/interpreter/Makefile.am
@@ -78,22 +78,40 @@ EXAMPLE_FILES = \
   $(top_srcdir)/examples/unwinddemo.cc
 
 
 include images.mk
 
 $(srcdir)/images.mk: $(srcdir)/config-images.sh $(srcdir)/images.awk $(srcdir)/images
 	$(srcdir)/config-images.sh $(top_srcdir)
 
-IMAGES = \
+JAVA_IMAGES = \
+  java-images/image001.png \
+  java-images/image002.png \
+  java-images/image003.png \
+  java-images/image004.png \
+  java-images/image005.png \
+  java-images/image006.png \
+  java-images/image007.png \
+  java-images/image008.png \
+  java-images/image009.png
+
+BUILT_IMAGES = \
   $(IMAGES_EPS) \
   $(IMAGES_PDF) \
   $(IMAGES_PNG) \
   $(IMAGES_TXT)
 
+IMAGES = \
+  $(BUILT_IMAGES) \
+  $(JAVA_IMAGES)
+
+## FIXME: JAVA_IMAGES will eventually need to be added to the HTML build.
+##        It will require a different Makefile rule later because 
+##        JAVA_IMAGES live in a subdir rather than in the current directory.
 HTMLDIR_IMAGES = $(addprefix octave.html/, $(IMAGES_PNG))
 
 LOGOS = \
   octave_logo.eps \
   octave_logo.pdf
 
 MUNGED_TEXI_SRC = \
   arith.texi \
@@ -118,16 +136,17 @@ MUNGED_TEXI_SRC = \
   gui.texi \
   gpl.texi \
   grammar.texi \
   image.texi \
   install.texi \
   interp.texi \
   intro.texi \
   io.texi \
+  java.texi \
   linalg.texi \
   matrix.texi \
   nonlin.texi \
   numbers.texi \
   obsolete.texi \
   oop.texi \
   op-idx.texi \
   optim.texi \
@@ -265,12 +284,12 @@ EXTRA_DIST = \
   $(IMAGES) \
   $(IMAGES_SRC) \
   $(LOGOS) \
   $(TXI_SRC)
 
 clean-local:
 	rm -rf t2d_cache
 
-DISTCLEANFILES = $(BUILT_TEXINFOS) doc-cache
+DISTCLEANFILES = $(BUILT_TEXINFOS)
 
-MAINTAINERCLEANFILES = $(IMAGES)
+MAINTAINERCLEANFILES = $(BUILT_IMAGES) doc-cache
 
diff --git a/doc/interpreter/arith.txi b/doc/interpreter/arith.txi
--- a/doc/interpreter/arith.txi
+++ b/doc/interpreter/arith.txi
@@ -280,22 +280,26 @@ cos (pi/2)
 @DOCSTRING(betaln)
 
 @DOCSTRING(bincoeff)
 
 @DOCSTRING(commutation_matrix)
 
 @DOCSTRING(duplication_matrix)
 
+@DOCSTRING(dawson)
+
 @DOCSTRING(erf)
 
 @DOCSTRING(erfc)
 
 @DOCSTRING(erfcx)
 
+@DOCSTRING(erfi)
+
 @DOCSTRING(erfinv)
 
 @DOCSTRING(erfcinv)
 
 @DOCSTRING(gamma)
 
 @DOCSTRING(gammainc)
 
diff --git a/doc/interpreter/basics.txi b/doc/interpreter/basics.txi
--- a/doc/interpreter/basics.txi
+++ b/doc/interpreter/basics.txi
@@ -256,16 +256,22 @@ and disable the following warnings
 @group
 Octave:abbreviated-property-match
 Octave:fopen-file-in-path
 Octave:function-name-clash
 Octave:load-file-in-path
 @end group
 @end example
 
+@noindent
+Note that this does not enable the @code{Octave:matlab-incompatible}
+warning, which you might want if you want to be told about writing code
+that works in Octave but not Matlab (@pxref{doc-warning},
+@pxref{doc-warning_ids}).
+
 @item  --verbose
 @itemx -V
 @cindex @code{--verbose}
 @cindex @code{-V}
 Turn on verbose output.
 
 @item  --version
 @itemx -v
diff --git a/doc/interpreter/container.txi b/doc/interpreter/container.txi
--- a/doc/interpreter/container.txi
+++ b/doc/interpreter/container.txi
@@ -33,19 +33,19 @@ another data container, the comma separa
 * Comma Separated Lists::
 @end menu
 
 @node Structures
 @section Structures
 @cindex structures
 @cindex data structures
 
-Octave includes support for organizing data in structures.  The current
+Octave includes support for organizing data in structures. The current
 implementation uses an associative array with indices limited to
-strings, but the syntax is more like C-style structures.  
+strings, but the syntax is more like C-style structures.
 
 @menu
 * Basic Usage and Examples::
 * Structure Arrays::
 * Creating Structures::
 * Manipulating Structures::
 * Processing Data in Structures::
 @end menu
@@ -385,16 +385,38 @@ x
      @result{} x =
         @{
           a =  1
           field2 =  2
         @}
 @end group
 @end example
 
+@noindent
+Dynamic indexing also allows you to use arbitrary strings, not merely
+valid Octave identifiers (note that this does not work on @sc{Matlab}):
+
+@example
+@group
+a = "long field with spaces (and funny char$)";
+x.a = 1;
+x.(a) = 2;
+x
+     @result{} x =
+        @{
+          a =  1
+          long field with spaces (and funny char$) =  2
+        @}
+@end group
+@end example
+
+@noindent
+The warning id @code{Octave:matlab-incompatible} can be enabled to warn
+about this usage. @xref{doc-warning_ids}.
+
 More realistically, all of the functions that operate on strings can be used
 to build the correct field name before it is entered into the data structure.
 
 @example
 @group
 names = ["Bill"; "Mary"; "John"];
 ages  = [37; 26; 31];
 for i = 1:rows (names)
@@ -466,17 +488,17 @@ struct ("field1", @{@{1, "one"@}@}, "fie
         @{
           [1,1] =  1
           [1,2] = one
         @}
         
           field2 =  2
         @}
 @end group
- @end example       
+@end example
 
 @DOCSTRING(struct)
 
 The function @code{isstruct} can be used to test if an object is a
 structure or a structure array.
 
 @DOCSTRING(isstruct)
 
@@ -486,19 +508,19 @@ structure or a structure array.
 Other functions that can manipulate the fields of a structure are given below.
 
 @DOCSTRING(nfields)
 
 @DOCSTRING(fieldnames)
 
 @DOCSTRING(isfield)
 
-@DOCSTRING(getfield)
+@DOCSTRING(setfield)
 
-@DOCSTRING(setfield)
+@DOCSTRING(getfield)
 
 @DOCSTRING(rmfield)
 
 @DOCSTRING(orderfields)
 
 @DOCSTRING(substruct)
 
 @node Processing Data in Structures
diff --git a/doc/interpreter/contributors.in b/doc/interpreter/contributors.in
--- a/doc/interpreter/contributors.in
+++ b/doc/interpreter/contributors.in
@@ -88,16 +88,17 @@ William P. Y. Hadisoeseno
 Jaroslav Hajek
 Benjamin Hall
 Kim Hansen
 Søren Hauberg
 Dave Hawthorne
 Daniel Heiserer
 Martin Helm
 Stefan Hepp
+Martin Hepperle
 Jordi Gutiérrez Hermoso
 Yozo Hida
 Ryan Hinton
 Roman Hodek
 A. Scottedward Hodel
 Júlio Hoffimann
 Richard Allan Holcombe
 Tom Holroyd
@@ -164,16 +165,17 @@ Orestes Mas
 Axel Mathéi
 Makoto Matsumoto
 Tatsuro Matsuoka
 Laurent Mazet
 G. D. McBain
 Alexander Mamonov
 Christoph Mayer
 Júlio Hoffimann Mendes
+Ronald van der Meer
 Thorsten Meyer
 Petr Mikulik
 Mike Miller
 Stefan Monnier
 Antoine Moreau
 Kai P. Mueller
 Hannes Müller
 Victor Munoz
diff --git a/doc/interpreter/dynamic.txi b/doc/interpreter/dynamic.txi
--- a/doc/interpreter/dynamic.txi
+++ b/doc/interpreter/dynamic.txi
@@ -1114,17 +1114,17 @@ END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_COD
 @end example
 
 The disadvantage of this is that if the foreign code allocates any
 memory internally, then this memory might be lost during an interrupt,
 without being deallocated.  Therefore, ideally Octave itself should
 allocate any memory that is needed by the foreign code, with either the
 @nospell{fortran_vec} method or the @w{@code{OCTAVE_LOCAL_BUFFER}} macro.
 
-The Octave unwind_protect mechanism (@ref{The @code{unwind_protect} Statement})
+The Octave unwind_protect mechanism (@ref{The unwind_protect Statement})
 can also be used in oct-files.  In conjunction with the exception
 handling of Octave, it is important to enforce that certain code is run
 to allow variables, etc. to be restored even if an exception occurs.  An
 example of the use of this mechanism is
 
 @example
 @EXAMPLEFILE(unwinddemo.cc)
 @end example
diff --git a/doc/interpreter/errors.txi b/doc/interpreter/errors.txi
--- a/doc/interpreter/errors.txi
+++ b/doc/interpreter/errors.txi
@@ -39,17 +39,17 @@ An error is something that occurs when a
 it doesn't make sense to continue.  An example is when a function is
 called with too few input arguments.  In this situation the function
 should abort with an error message informing the user of the lacking
 input arguments.
 
 Since an error can occur during the evaluation of a program, it is
 very convenient to be able to detect that an error occurred, so that
 the error can be fixed.  This is possible with the @code{try} statement
-described in @ref{The @code{try} Statement}.
+described in @ref{The try Statement}.
 
 @menu
 * Raising Errors::
 * Catching Errors::
 * Recovering From Errors::
 @end menu
 
 @node Raising Errors
@@ -131,17 +131,17 @@ f ()
 @DOCSTRING(beep)
 
 @DOCSTRING(beep_on_error)
 
 @node Catching Errors
 @subsection Catching Errors
 
 When an error occurs, it can be detected and handled using the
-@code{try} statement as described in @ref{The @code{try} Statement}.
+@code{try} statement as described in @ref{The try Statement}.
 As an example, the following piece of code counts the number of errors
 that occurs during a @code{for} loop.
 
 @example
 @group
 number_of_errors = 0;
 for n = 1:100
   try
@@ -175,16 +175,49 @@ for n = 1:100
 endfor
 @end group
 @end example
 
 @DOCSTRING(lasterror)
 
 @DOCSTRING(lasterr)
 
+It is also possible to assign an identification string to an error.
+If an error has such an ID the user can catch this error
+as will be shown in the next example.  To assign an ID to an error,
+simply call @code{error} with two string arguments, where the first
+is the identification string, and the second is the actual error.  Note
+that error IDs are in the format "NAMESPACE:ERROR-NAME".  The namespace
+"Octave" is used for Octave's own errors.  Any other string is available
+as a namespace for user's own errors.
+
+The next example counts indexing errors. The errors are catched using the
+field identifier of the structure returned by the function @code{lasterror}.
+
+@example
+@group
+number_of_errors = 0;
+for n = 1:100
+  try
+    @dots{}
+  catch
+    id = lasterror.identifier;
+    if (strcmp (id, "Octave:invalid-indexing"))
+      number_of_errors++;
+    endif
+  end_try_catch
+endfor
+@end group
+@end example
+
+The functions distributed with Octave can issue one of the following
+errors.
+
+@DOCSTRING(error_ids)
+
 When an error has been handled it is possible to raise it again.  This
 can be useful when an error needs to be detected, but the program should
 still abort.  This is possible using the @code{rethrow} function.  The
 previous example can now be changed to count the number of errors
 related to the @samp{*} operator, but still abort if another kind of
 error occurs.
 
 @example
@@ -300,16 +333,21 @@ is the identification string, and the se
 that warning IDs are in the format "NAMESPACE:WARNING-NAME".  The namespace
 "Octave" is used for Octave's own warnings.  Any other string is available
 as a namespace for user's own warnings.
 
 @DOCSTRING(warning)
 
 @DOCSTRING(lastwarn)
 
+The functions distributed with Octave can issue one of the following
+warnings.
+
+@DOCSTRING(warning_ids)
+
 @node Enabling and Disabling Warnings
 @subsection Enabling and Disabling Warnings
 
 The @code{warning} function also allows you to control which warnings
 are actually printed to the screen.  If the @code{warning} function
 is called with a string argument that is either @code{"on"} or @code{"off"}
 all warnings will be enabled or disabled.
 
@@ -329,14 +367,9 @@ while the following won't issue a warnin
 @example
 @group
 warning ("off", "example:non-negative-variable");
 warning ("example:non-negative-variable", 
          "'a' must be non-negative.  Setting 'a' to zero.");
 @end group
 @end example
 
-The functions distributed with Octave can issue one of the following
-warnings.
 
-@DOCSTRING(warning_ids)
-
-
diff --git a/doc/interpreter/java-images/image001.png b/doc/interpreter/java-images/image001.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..d5ffef6d4345c4a12336e6ca5a03eeed7e6ca750
GIT binary patch
literal 14199
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
Df?*ZT

diff --git a/doc/interpreter/java-images/image002.png b/doc/interpreter/java-images/image002.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..8f1ae84942c80bf7d389e8e3bbc505222ab13df1
GIT binary patch
literal 24794
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
YrmUnmE@YW2)AsMm1-<jR=PZK%0|Q?C{Qv*}

diff --git a/doc/interpreter/java-images/image003.png b/doc/interpreter/java-images/image003.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..4ea78c63c5b7a12557daa52c7ed06e0723ff4613
GIT binary patch
literal 5332
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

diff --git a/doc/interpreter/java-images/image004.png b/doc/interpreter/java-images/image004.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..06de4cf8fff9b8a8e74679802bf396baebdb110d
GIT binary patch
literal 13008
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

diff --git a/doc/interpreter/java-images/image005.png b/doc/interpreter/java-images/image005.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..a443b7e054d71c9120a56ac2ff36253053c381c1
GIT binary patch
literal 14327
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

diff --git a/doc/interpreter/java-images/image006.png b/doc/interpreter/java-images/image006.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..3cf5e8fea3758c0b5a7f101a1f93e6cb3e813c52
GIT binary patch
literal 13754
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
b0YCtH##<Ti0e~0a;`93D+ZQ>KNU#3`DhE%d

diff --git a/doc/interpreter/java-images/image007.png b/doc/interpreter/java-images/image007.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..c9658c727e30a0278afdab266b7fb833b02baba0
GIT binary patch
literal 14931
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
DDl5iw

diff --git a/doc/interpreter/java-images/image008.png b/doc/interpreter/java-images/image008.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..0132fb753e79d4dce0fb8fe8c14f1c8c506277c1
GIT binary patch
literal 13497
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
I4>2D94_ZKbZ2$lO

diff --git a/doc/interpreter/java-images/image009.png b/doc/interpreter/java-images/image009.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..25ab16174c52fcc8f45f80f29428687214570a3e
GIT binary patch
literal 11198
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
UJ3qV?Bsp9T9y{>K5ts140Nz{d;Q#;t

diff --git a/doc/interpreter/java.txi b/doc/interpreter/java.txi
new file mode 100644
--- /dev/null
+++ b/doc/interpreter/java.txi
@@ -0,0 +1,1156 @@
+@c Copyright (C) 2010-2012 Martin Hepperle
+@c
+@c This file is part of Octave.
+@c
+@c Octave is free software; you can redistribute it and/or modify it
+@c under the terms of the GNU General Public License as published by the
+@c Free Software Foundation; either version 3 of the License, or (at
+@c your option) any later version.
+@c 
+@c Octave is distributed in the hope that it will be useful, but WITHOUT
+@c ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+@c FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+@c for more details.
+@c 
+@c You should have received a copy of the GNU General Public License
+@c along with Octave; see the file COPYING.  If not, see
+@c <http://www.gnu.org/licenses/>.
+
+@node Java Interface
+@chapter Java Interface
+
+@cindex using Octave with Java
+@cindex Java, using with Octave
+@cindex calling Java from Octave
+@cindex Java, calling from Octave
+@cindex calling Octave from Java
+@cindex  Octave, calling from Java
+
+The Java Interface is designed for calling Java functions from within Octave.
+If you want to do the reverse, and call Octave from within Java, try
+a library like 
+@code{javaOctave} (@url{http://kenai.com/projects/javaOctave}) or
+@code{joPas} (@url{http://jopas.sourceforge.net}). 
+
+@menu
+* Java Interface Functions::         
+* Dialog Box Functions::         
+* FAQ - Frequently asked Questions::  
+@end menu
+
+@node Java Interface Functions
+@section Java Interface Functions
+
+The following functions are the core of the Java Interface.  They provide
+a way to create a Java object, get and set its data fields, and call Java
+methods which return results to Octave. 
+
+@cindex object, creating a Java object
+@DOCSTRING(javaObject)
+
+@cindex fields, displaying available fields of a Java object
+FIXME: Need documentation on how fieldnames() is overloaded to return
+the methods of a Java object.
+
+@cindex field, returning value of Java object field
+FIXME: Need documentation on how to use structure-like indexing
+to get fields from Java object.
+
+@cindex field, setting value of Java object field
+FIXME: Need documentation on how to use structure-like indexing
+to set fields from Java object.
+
+@DOCSTRING(isjava)
+
+@cindex array, creating a Java array
+@DOCSTRING(javaArray)
+
+@cindex method, invoking a method of a Java object
+@DOCSTRING(javaMethod)
+
+@cindex methods, displaying available methods of a Java object
+FIXME: Need documentation on how methods() is overloaded to return
+the methods of a Java object.
+
+The following three functions are used to display and modify the
+class path used by the Java Virtual Machine.  This is entirely separate
+from Octave's PATH variable and is used by the JVM to find the correct
+code to execute.
+
+@cindex classpath, displaying
+@cindex classpath, dynamic
+@cindex dynamic classpath
+@cindex classpath, static
+@cindex static classpath
+@DOCSTRING(javaclasspath)
+
+@findex javaaddpath
+@cindex classpath, adding new path
+@cindex path, adding to classpath
+@cindex classpath, dynamic
+@cindex dynamic classpath, adding new path
+@DOCSTRING(javaaddpath)
+
+@cindex classpath, removing path
+@cindex path, removing from classpath
+@DOCSTRING(javarmpath)
+
+The following four functions provide information and control over the interface
+between Octave and the Java Virtual Machine.
+
+@DOCSTRING(usejava)
+
+@cindex memory, displaying Java memory status
+@DOCSTRING(javamem)
+
+@DOCSTRING(java_matrix_autoconversion)
+
+@DOCSTRING(java_unsigned_autoconversion)
+
+@DOCSTRING(debug_java)
+
+@node Dialog Box Functions
+@section Dialog Box Functions
+
+The following functions all use the Java Interface to provide some form
+of dialog box.
+
+@cindex dialog, displaying a warning dialog
+@DOCSTRING(msgbox)
+
+@cindex dialog, displaying an error dialog
+@DOCSTRING(errordlg)
+
+@cindex dialog, displaying a help dialog
+@DOCSTRING(helpdlg)
+
+@cindex dialog, displaying an input dialog
+@DOCSTRING(inputdlg)
+
+@cindex dialog, displaying a list dialog
+@DOCSTRING(listdlg)
+
+@cindex dialog, displaying a question dialog
+@DOCSTRING(questdlg)
+
+@cindex dialog, displaying a warning dialog
+@DOCSTRING(warndlg)
+
+@c ------------------------------------------------------------------------
+@node FAQ - Frequently asked Questions
+@section FAQ - Frequently asked Questions
+
+@menu
+* How to distinguish between Octave and Matlab?::  
+* How to make Java classes available?::  
+* How to create an instance of a Java class?::  
+* How can I handle memory limitations?::  
+* How to compile the java package in Octave?::  
+* Which @TeX{} symbols are implemented in the dialog functions?::  
+@end menu
+
+@c ------------------------------------------------------------------------
+@node How to distinguish between Octave and Matlab?
+@subsection How to distinguish between Octave and Matlab? 
+@anchor{doc-FAQ}
+@c - index -
+@cindex Octave and Matlab, how to distinguish between
+@c - index -
+
+Octave and @sc{matlab} are very similar, but handle Java slightly different. 
+Therefore it may be necessary to detect the environment and use the appropriate
+functions.  The following function can be used to detect the environment.  Due
+to the persistent variable it can be called repeatedly without a heavy
+performance hit. 
+
+Example: 
+
+@example
+@group
+%% 
+%% Return: true if the environment is Octave. 
+%% 
+function ret = isOctave 
+  persistent retval;  % speeds up repeated calls 
+
+  if isempty(retval)
+    retval = (exist('Octave_VERSION','builtin') > 0); 
+  end 
+
+  ret = retval; 
+end 
+@end group
+@end example
+
+@c ------------------------------------------------------------------------
+@node How to make Java classes available?
+@subsection How to make Java classes available to Octave?
+@c - index -
+@cindex classpath, setting
+@cindex classpath, difference between static and dynamic
+@cindex static classpath
+@cindex dynamic classpath
+@cindex @file{classpath.txt}
+@cindex classes, making available to Octave
+@c - index -
+
+Java finds classes by searching a @var{classpath}.  This is a list of Java
+archive files and/or directories containing class files.  In Octave and
+@sc{matlab} the @var{classpath} is composed of two parts:
+
+@itemize
+@item the @var{static classpath} is initialized once at startup of the JVM, and
+
+@item the @var{dynamic classpath} which can be modified at runtime.
+@end itemize
+
+Octave searches the @var{static classpath} first, then the @var{dynamic
+classpath}.  Classes appearing in the @var{static} as well as in the
+@var{dynamic classpath} will therefore be found in the @var{static classpath}
+and loaded from this location.  Classes which shall be used regularly or must
+be available to all users should be added to the @var{static classpath}.  The
+@var{static classpath} is populated once from the contents of a plain text file
+named @file{classpath.txt} when the Java Virtual Machine starts.  This file
+contains one line for each individual classpath to be added to the @var{static
+classpath}.  These lines can identify single class files, directories containing
+class files or Java archives with complete class file hierarchies.  Comment
+lines starting with a @code{#} or a @code{%} character are ignored.
+
+The search rules for the file @file{classpath.txt} are:
+
+@itemize
+@item First, Octave searches for the file @file{classpath.txt} in your home directory,
+If such a file is found, it is read and defines the initial @var{static
+classpath}.  Thus it is possible to build an initial static classpath on a 'per
+user' basis.
+
+@item Next, Octave looks for another file @file{classpath.txt} in the package
+installation directory.  This is where @file{javaclasspath.m} resides, usually
+something like @file{@dots{}\share\Octave\packages\java-1.2.8}.  You can find
+this directory by executing the command 
+
+@example
+pkg list
+@end example
+
+If this file exists, its contents is also appended to the static classpath.
+Note that the archives and class directories defined in this file will affect
+all users.
+@end itemize
+
+Classes which are used only by a specific script should be placed in the
+@var{dynamic classpath}.  This portion of the classpath can be modified at
+runtime using the @code{javaaddpath} and @code{javarmpath} functions. 
+
+Example: 
+
+@example
+octave> base_path = 'C:/Octave/java_files'; 
+
+octave> % add two JARchives to the dynamic classpath 
+octave> javaaddpath([base_path, '/someclasses.jar']); 
+octave> javaaddpath([base_path, '/moreclasses.jar']); 
+
+octave> % check the dynamic classpath 
+octave> p = javaclasspath; 
+octave> disp(p@{1@}); 
+C:/Octave/java_files/someclasses.jar
+octave> disp(p@{2@}); 
+C:/Octave/java_files/moreclasses.jar
+
+octave> % remove the first element from the classpath 
+octave> javarmpath([base_path, '/someclasses.jar']); 
+octave> p = javaclasspath; 
+octave> disp(p@{1@}); 
+C:/Octave/java_files/moreclasses.jar
+
+octave> % provoke an error
+octave> disp(p@{2@}); 
+error: A(I): Index exceeds matrix dimension. 
+@end example
+
+Another way to add files to the @var{dynamic classpath} exclusively for your
+user account is to use the file @file{.octaverc} which is stored in your home
+directory.  All Octave commands in this file are executed each time you start a
+new instance of Octave.  The following example adds the directory @file{octave}
+to Octave's search path and the archive @file{myclasses.jar} in this directory
+to the Java search path. 
+
+@example
+@group
+% content of .octaverc:
+addpath('~/octave');
+javaaddpath('~/octave/myclasses.jar');
+@end group
+@end example
+
+@c ------------------------------------------------------------------------
+@node How to create an instance of a Java class?
+@subsection How to create an instance of a Java class?
+@c - index -
+@cindex object, how to create
+@cindex instance, how to create
+@c - index -
+
+If your code shall work under Octave as well as @sc{matlab} you should use the
+function @code{javaObject} to create Java objects.  The function
+@code{java_new} is Octave specific and does not exist in the @sc{matlab}
+environment.
+
+Example 1, suitable for Octave but not for @sc{matlab}: 
+
+@example
+   Passenger = java_new('package.FirstClass', row, seat);
+@end example
+
+Example 2, which works in Octave as well as in @sc{matlab}: 
+
+@example
+   Passenger = javaObject('package.FirstClass', row, seat);
+@end example
+
+@c ------------------------------------------------------------------------
+@node How can I handle memory limitations?
+@subsection How can I handle memory limitations?
+@cindex memory, limitations
+
+In order to execute Java code Octave creates a Java Virtual Machine (JVM). 
+Such a JVM allocates a fixed amount of initial memory and may expand this pool
+up to a fixed maximum memory limit.  The default values depend on the Java
+version (see @ref{doc-javamem,,javamem}).  The memory pool is shared by all Java
+objects running in the JVM@.  This strict memory limit is intended mainly to
+avoid that runaway applications inside web browsers or in enterprise servers
+can consume all memory and crash the system.  When the maximum memory limit is
+hit, Java code will throw exceptions so that applications will fail or behave
+unexpectedly.
+
+In Octave as well as in @sc{matlab}, you can specify options for the creation
+of the JVM inside a file named @file{java.opts}.  This is a text file where you
+can enter lines containing @option{-X} and @option{-D} options handed to the
+JVM during initialization. 
+
+In Octave, the Java options file must be located in the directory where
+@file{javaclasspath.m} resides, i.e., the package installation directory,
+usually something like @file{@dots{}\share\Octave\packages\java-1.2.8}.  You can
+find this directory by executing 
+
+@example
+pkg list
+@end example
+
+In @sc{matlab}, the options file goes into the @file{MATLABROOT/bin/ARCH}
+directory or in your personal @sc{matlab} startup directory (can be determined
+by a @samp{pwd} command).  @var{MATLABROOT} is the @sc{matlab} root directory
+and @var{ARCH} is your system architecture, which you find by issuing the
+commands @samp{matlabroot} respectively @samp{computer('arch')}.
+
+The @option{-X} options allow you to increase the maximum amount of memory
+available to the JVM to 256 Megabytes by adding the following line to the
+@file{java.opts} file: 
+
+@example
+-Xmx256m 
+@end example
+
+The maximum possible amount of memory depends on your system.  On a Windows
+system with 2 Gigabytes main memory you should be able to set this maximum to
+about 1 Gigabyte.
+
+If your application requires a large amount of memory from the beginning, you
+can also specify the initial amount of memory allocated to the JVM@.  Adding
+the following line to the @file{java.opts} file starts the JVM with 64
+Megabytes of initial memory: 
+
+@example
+-Xms64m 
+@end example
+
+For more details on the available @option{-X} options of your Java Virtual
+Machine issue the command @samp{java -X} at the operating system command prompt
+and consult the Java documentation.
+
+
+The @option{-D} options can be used to define system properties which can then
+be used by Java classes inside Octave.  System properties can be retrieved by
+using the @code{getProperty()} methods of the @code{java.lang.System} class. 
+The following example line defines the property @var{MyProperty} and assigns it
+the string @code{12.34}. 
+
+@example
+-DMyProperty=12.34
+@end example
+
+The value of this property can then be retrieved as a string by a Java object
+or in Octave: 
+
+@example
+@group
+octave> javaMethod('java.lang.System', 'getProperty', 'MyProperty');
+ans = 12.34
+@end group
+@end example
+
+@seealso{javamem}
+
+@c ------------------------------------------------------------------------
+@node How to compile the java package in Octave?
+@subsection How to compile the java package in Octave?
+@c - index -
+@cindex package, how to compile?
+@cindex compiling the java package, how? 
+@cindex java package, how to compile?
+@cindex java package, how to install?
+@cindex java package, how to uninstall?
+@c - index -
+
+Most Octave installations come with the @var{java} package pre-installed.  In
+case you want to replace this package with a more recent version, you must
+perform the following steps: 
+
+@c ---------
+@menu
+* Uninstall the currently installed package @var{java}::  
+* Make sure that the build environment is configured properly::  
+* Compile and install the package in Octave::  
+* Test the java package installation::  
+@end menu
+
+@node Uninstall the currently installed package @var{java}
+@subsubsection Uninstall the currently installed package @var{java}
+Check whether the @var{java} package is already installed by issuing
+the @code{pkg list} command:
+
+@example
+@group
+octave> pkg list
+Package Name  | Version | Installation directory
+--------------+---------+-----------------------
+        java *|   1.2.8 | /home/octavio/octave/java-1.2.8
+octave> 
+@end group
+@end example
+
+@noindent
+If the @var{java} package appears in the list you must uninstall it first by
+issuing the command 
+
+@example
+@group
+octave> pkg uninstall java
+octave> pkg list
+@end group
+@end example
+
+Now the java package should not be listed anymore.  If you have used the
+@var{java} package during the current session of Octave, you have to exit and
+restart Octave before you can uninstall the package.  This is because the
+system keeps certain libraries in memory after they have been loaded once.
+
+@c ---------
+@node Make sure that the build environment is configured properly
+@subsubsection Make sure that the build environment is configured properly
+The installation process requires that the environment variable
+@w{@env{JAVA_HOME}} points to the Java Development Kit (JDK) on your computer. 
+
+@itemize @bullet
+@item
+Note that JDK is not equal to JRE (Java Runtime Environment).  The JDK home
+directory contains subdirectories with include, library and executable files
+which are required to compile the @var{java} package.  These files are not part
+of the JRE, so you definitely need the JDK. 
+
+@item
+Do not use backslashes but ordinary slashes in the path. 
+@end itemize
+
+Set the environment variable @w{@env{JAVA_HOME}} according to your local JDK
+installation.  Please adapt the path in the following examples according to the
+JDK installation on your system.  If you are using a Windows system that might
+be: 
+
+@example
+octave> setenv("JAVA_HOME","C:/Java/jdk1.6.0_21");
+@end example
+
+Note, that on both system types, Windows as well as Linux, you must use the
+forward slash '/' as the separator, not the backslash '\'.
+
+If you are using a Linux system this would look probably more like: 
+
+@example
+octave> setenv("JAVA_HOME","/usr/local/jdk1.6.0_21");
+@end example
+
+@c ---------
+@node Compile and install the package in Octave
+@subsubsection Compile and install the package in Octave
+If you have for example saved the package archive on your @file{z:} drive the
+command would be: 
+
+@example
+Octave> pkg install -verbose z:/java-1.2.8.tar.gz
+@end example
+
+@noindent
+or if you have Linux and the package file is stored in your home directory: 
+
+@example
+octave> pkg install -verbose ~/java-1.2.8.tar.gz
+@end example
+
+The option @option{-verbose} will produce some lengthy output, which should not
+show any errors (maybe a few warnings at best). 
+
+You can then produce a list of all installed packages: 
+
+@example
+octave> pkg list
+@end example
+
+This list of packages should now include the package @var{java}:
+
+@example
+@group
+octave> pkg list
+Package Name  | Version | Installation directory
+--------------+---------+-----------------------
+        java *|   1.2.8 | /home/octavio/octave/java-1.2.8
+octave> 
+@end group
+@end example
+
+@c ---------
+@node Test the java package installation
+@subsubsection Test the java package installation
+
+The following code creates a Java string object, which however is automatically
+converted to an Octave string: 
+
+@example
+@group
+octave> s = javaObject('java.lang.String', 'Hello OctaveString') 
+s = Hello OctaveString 
+@end group
+@end example
+
+Note that the java package automatically transforms the Java String object to
+an Octave string.  This means that you cannot apply Java String methods to the
+result. 
+
+This "auto boxing" scheme seems to be implemented for the following Java
+classes: 
+
+@itemize @bullet
+@item
+java.lang.Integer
+
+@item
+java.lang.Double 
+
+@item
+java.lang.Boolean 
+
+@item
+java.lang.String 
+@end itemize
+
+If you instead create an object for which no "auto-boxing" is implemented,
+@code{javaObject} returns the genuine Java object: 
+
+@example
+@group
+octave> v = javaObject('java.util.Vector') 
+v = 
+<Java object: java.util.Vector> 
+octave> v.add(12); 
+octave> v.get(0) 
+ans = 12 
+@end group
+@end example
+
+If you have created such a Java object, you can apply all methods of the Java
+class to the returned object.  Note also that for some objects you must specify
+an initializer: 
+
+@example
+@group
+% not: 
+octave> d = javaObject('java.lang.Double') 
+error: [java] java.lang.NoSuchMethodException: java.lang.Double 
+% but: 
+octave> d = javaObject('java.lang.Double',12.34) 
+d = 12.340 
+@end group
+@end example
+
+@c ------------------------------------------------------------------------
+@node Which @TeX{} symbols are implemented in the dialog functions?
+@subsection Which @TeX{} symbols are implemented in the dialog functions?
+@c - index -
+@cindex symbols, translation table
+@cindex @TeX{} symbols, translation table
+@cindex translation table for @TeX{} symbols
+@c - index -
+
+The dialog functions contain a translation table for @TeX{} like symbol codes. 
+Thus messages and labels can be tailored to show some common mathematical
+symbols or Greek characters.  No further @TeX{} formatting codes are supported.
+ The characters are translated to their Unicode equivalent.  However, not all
+characters may be displayable on your system.  This depends on the font used by
+the Java system on your computer.
+
+Each @TeX{} symbol code must be terminated by a space character to make it
+distinguishable from the surrounding text.  Therefore the string @samp{\alpha
+=12.0} will produce the desired result, whereas @samp{\alpha=12.0} would
+produce the literal text @var{'\alpha=12.0'}.
+
+@seealso{errordlg, helpdlg, inputdlg, listdlg, msgbox, questdlg, warndlg}
+
+@need 5000
+@c ---------------------------------
+@ifhtml
+@float Table
+The table below shows each @TeX{} character code and the corresponding Unicode
+character: 
+@multitable @columnfractions 0.18 0.1 0.05 0.18 0.1 0.05 0.18 0.1
+@item \alpha
+@tab 'α'
+@tab
+@tab \beta
+@tab 'β'
+@tab
+@tab \gamma
+@tab 'γ'
+@c ----------
+@item \delta
+@tab 'δ'
+@tab
+@tab \epsilon
+@tab 'ε'
+@tab
+@tab \zeta
+@tab 'ζ'
+@c ----------
+@item \eta
+@tab 'η'
+@tab
+@tab \theta
+@tab 'θ'
+@tab
+@tab \vartheta
+@tab 'ϑ'
+@c ----------
+@item \iota
+@tab 'ι'
+@tab
+@tab \kappa
+@tab 'κ'
+@tab
+@tab \lambda
+@tab 'λ'
+@c ----------
+@item \mu
+@tab 'μ'
+@tab
+@tab \nu
+@tab 'ν'
+@tab
+@tab \xi
+@tab 'ξ'
+@c ----------
+@item \pi
+@tab 'π'
+@tab
+@tab \rho
+@tab 'ρ'
+@tab
+@tab \sigma
+@tab 'σ'
+@c ----------
+@item \varsigma
+@tab 'ς'
+@tab
+@tab \tau
+@tab 'τ'
+@tab
+@tab \phi
+@tab 'φ'
+@c ----------
+@item \chi
+@tab 'χ'
+@tab
+@tab \psi
+@tab 'ψ'
+@tab
+@tab \omega
+@tab 'ω'
+@c ----------
+@item \upsilon
+@tab 'υ'
+@tab
+@tab \Gamma
+@tab 'Γ'
+@tab
+@tab \Delta
+@tab 'Δ'
+@c ----------
+@item \Theta
+@tab 'Θ'
+@tab
+@tab \Lambda
+@tab 'Λ'
+@tab
+@tab \Pi
+@tab 'Π'
+@c ----------
+@item \Xi
+@tab 'Ξ'
+@tab
+@tab \Sigma
+@tab 'Σ'
+@tab
+@tab \Upsilon
+@tab 'Υ'
+@c ----------
+@item \Phi
+@tab 'Φ'
+@tab
+@tab \Psi
+@tab 'Ψ'
+@tab
+@tab \Omega
+@tab 'Ω'
+@c ----------
+@item \Im
+@tab 'ℑ'
+@tab
+@tab \Re
+@tab 'ℜ'
+@tab
+@tab \leq
+@tab '≤'
+@c ----------
+@item \geq
+@tab '≥'
+@tab
+@tab \neq
+@tab '≠'
+@tab
+@tab \pm
+@tab '±'
+@c ----------
+@item \infty
+@tab '∞'
+@tab
+@tab \partial
+@tab '∂'
+@tab
+@tab \approx
+@tab '≈'
+@c ----------
+@item \circ
+@tab '∘'
+@tab
+@tab \bullet
+@tab '•'
+@tab
+@tab \times
+@tab '×'
+@c ----------
+@item \sim
+@tab '~'
+@tab
+@tab \nabla
+@tab '∇'
+@tab
+@tab \ldots
+@tab '…'
+@c ----------
+@item \exists
+@tab '∃'
+@tab
+@tab \neg
+@tab '¬'
+@tab
+@tab \aleph
+@tab 'ℵ'
+@c ----------
+@item \forall
+@tab '∀'
+@tab
+@tab \cong
+@tab '≅'
+@tab
+@tab \wp
+@tab '℘'
+@c ----------
+@item \propto
+@tab '∝'
+@tab
+@tab \otimes
+@tab '⊗'
+@tab
+@tab \oplus
+@tab '⊕'
+@c ----------
+@item \oslash
+@tab '⊘'
+@tab
+@tab \cap
+@tab '∩'
+@tab
+@tab \cup
+@tab '∪'
+@c ----------
+@item \ni
+@tab '∋'
+@tab
+@tab \in
+@tab '∈'
+@tab
+@tab \div
+@tab '÷'
+@c ----------
+@item \equiv
+@tab '≡'
+@tab
+@tab \int
+@tab '∫'
+@tab
+@tab \perp
+@tab '⊥'
+@c ----------
+@item \wedge
+@tab '∧'
+@tab
+@tab \vee
+@tab '∨'
+@tab
+@tab \supseteq
+@tab '⊇'
+@c ----------
+@item \supset
+@tab '⊃'
+@tab
+@tab \subseteq
+@tab '⊆'
+@tab
+@tab \subset
+@tab '⊂'
+@c ----------
+@item \clubsuit
+@tab '♣'
+@tab
+@tab \spadesuit
+@tab '♠'
+@tab
+@tab \heartsuit
+@tab '♥'
+@c ----------
+@item \diamondsuit
+@tab '♦'
+@tab
+@tab \copyright
+@tab '©'
+@tab
+@tab \leftarrow
+@tab '←'
+@c ----------
+@item \uparrow
+@tab '↑'
+@tab
+@tab \rightarrow
+@tab '→'
+@tab
+@tab \downarrow
+@tab '↓'
+@c ----------
+@item \leftrightarrow
+@tab '↔'
+@tab
+@tab \updownarrow
+@tab '↕'
+@tab
+@c ----------
+@end multitable
+@caption{@TeX{} character codes and the resulting symbols.}
+@end float
+@end ifhtml
+@c ---------------------------------
+@iftex
+@float Table
+The table below shows each @TeX{} character code and the corresponding Unicode character: 
+@multitable @columnfractions 0.18 0.1 0.05 0.18 0.1 0.05 0.18 0.1
+@headitem @TeX{} code
+@tab Symbol
+@tab
+@tab @TeX{} code
+@tab Symbol
+@tab
+@tab @TeX{} code
+@tab Symbol
+@c ----------
+@item \alpha
+@tab '@math{\alpha}'
+@tab
+@tab \beta
+@tab '@math{\beta}'
+@tab
+@tab \gamma
+@tab '@math{\gamma}'
+@c ----------
+@item \delta
+@tab '@math{\delta}'
+@tab
+@tab \epsilon
+@tab '@math{\epsilon}'
+@tab
+@tab \zeta
+@tab '@math{\zeta}'
+@c ----------
+@item \eta
+@tab '@math{\eta}'
+@tab
+@tab \theta
+@tab '@math{\theta}'
+@tab
+@tab \vartheta
+@tab '@math{\vartheta}'
+@c ----------
+@item \iota
+@tab '@math{\iota}'
+@tab
+@tab \kappa
+@tab '@math{\kappa}'
+@tab
+@tab \lambda
+@tab '@math{\lambda}'
+@c ----------
+@item \mu
+@tab '@math{\mu}'
+@tab
+@tab \nu
+@tab '@math{\nu}'
+@tab
+@tab \xi
+@tab '@math{\xi}'
+@c ----------
+@item \pi
+@tab '@math{\pi}'
+@tab
+@tab \rho
+@tab '@math{\rho}'
+@tab
+@tab \sigma
+@tab '@math{\sigma}'
+@c ----------
+@item \varsigma
+@tab '@math{\varsigma}'
+@tab
+@tab \tau
+@tab '@math{\tau}'
+@tab
+@tab \phi
+@tab '@math{\phi}'
+@c ----------
+@item \chi
+@tab '@math{\chi}'
+@tab
+@tab \psi
+@tab '@math{\psi}'
+@tab
+@tab \omega
+@tab '@math{\omega}'
+@c ----------
+@item \upsilon
+@tab '@math{\upsilon}'
+@tab
+@tab \Gamma
+@tab '@math{\Gamma}'
+@tab
+@tab \Delta
+@tab '@math{\Delta}'
+@c ----------
+@item \Theta
+@tab '@math{\Theta}'
+@tab
+@tab \Lambda
+@tab '@math{\Lambda}'
+@tab
+@tab \Pi
+@tab '@math{\Pi}'
+@c ----------
+@item \Xi
+@tab '@math{\Xi}'
+@tab
+@tab \Sigma
+@tab '@math{\Sigma}'
+@tab
+@tab \Upsilon
+@tab '@math{\Upsilon}'
+@c ----------
+@item \Phi
+@tab '@math{\Phi}'
+@tab
+@tab \Psi
+@tab '@math{\Psi}'
+@tab
+@tab \Omega
+@tab '@math{\Omega}'
+@c ----------
+@item \Im
+@tab '@math{\Im}'
+@tab
+@tab \Re
+@tab '@math{\Re}'
+@tab
+@tab \leq
+@tab '@math{\leq}'
+@c ----------
+@item \geq
+@tab '@math{\geq}'
+@tab
+@tab \neq
+@tab '@math{\neq}'
+@tab
+@tab \pm
+@tab '@math{\pm}'
+@c ----------
+@item \infty
+@tab '@math{\infty}'
+@tab
+@tab \partial
+@tab '@math{\partial}'
+@tab
+@tab \approx
+@tab '@math{\approx}'
+@c ----------
+@item \circ
+@tab '@math{\circ}'
+@tab
+@tab \bullet
+@tab '@math{\bullet}'
+@tab
+@tab \times
+@tab '@math{\times}'
+@c ----------
+@item \sim
+@tab '@math{\sim}'
+@tab
+@tab \nabla
+@tab '@math{\nabla}'
+@tab
+@tab \ldots
+@tab '@math{\ldots}'
+@c ----------
+@item \exists
+@tab '@math{\exists}'
+@tab
+@tab \neg
+@tab '@math{\neg}'
+@tab
+@tab \aleph
+@tab '@math{\aleph}'
+@c ----------
+@item \forall
+@tab '@math{\forall}'
+@tab
+@tab \cong
+@tab '@math{\cong}'
+@tab
+@tab \wp
+@tab '@math{\wp}'
+@c ----------
+@item \propto
+@tab '@math{\propto}'
+@tab
+@tab \otimes
+@tab '@math{\otimes}'
+@tab
+@tab \oplus
+@tab '@math{\oplus}'
+@c ----------
+@item \oslash
+@tab '@math{\oslash}'
+@tab
+@tab \cap
+@tab '@math{\cap}'
+@tab
+@tab \cup
+@tab '@math{\cup}'
+@c ----------
+@item \ni
+@tab '@math{\ni}'
+@tab
+@tab \in
+@tab '@math{\in}'
+@tab
+@tab \div
+@tab '@math{\div}'
+@c ----------
+@item \equiv
+@tab '@math{\equiv}'
+@tab
+@tab \int
+@tab '@math{\int}'
+@tab
+@tab \perp
+@tab '@math{\perp}'
+@c ----------
+@item \wedge
+@tab '@math{\wedge}'
+@tab
+@tab \vee
+@tab '@math{\vee}'
+@tab
+@tab \supseteq
+@tab '@math{\supseteq}'
+@c ----------
+@item \supset
+@tab '@math{\supset}'
+@tab
+@tab \subseteq
+@tab '@math{\subseteq}'
+@tab
+@tab \subset
+@tab '@math{\subset}'
+@c ----------
+@item \clubsuit
+@tab '@math{\clubsuit}'
+@tab
+@tab \spadesuit
+@tab '@math{\spadesuit}'
+@tab
+@tab \heartsuit
+@tab '@math{\heartsuit}'
+@c ----------
+@item \diamondsuit
+@tab '@math{\diamondsuit}'
+@tab
+@tab \copyright
+@tab '@math{\copyright}'
+@tab
+@tab \leftarrow
+@tab '@math{\leftarrow}'
+@c ----------
+@item \uparrow
+@tab '@math{\uparrow}'
+@tab
+@tab \rightarrow
+@tab '@math{\rightarrow}'
+@tab
+@tab \downarrow
+@tab '@math{\downarrow}'
+@c ----------
+@item \leftrightarrow
+@tab '@math{\leftrightarrow}'
+@tab
+@tab \updownarrow
+@tab '@math{\updownarrow}'
+@tab
+@c ----------
+@end multitable
+@caption{@TeX{} character codes and the resulting symbols.}
+@end float
+@end iftex
+@c ---------------------------------
diff --git a/doc/interpreter/octave.texi b/doc/interpreter/octave.texi
--- a/doc/interpreter/octave.texi
+++ b/doc/interpreter/octave.texi
@@ -172,16 +172,17 @@ It corresponds to GNU Octave version @va
 * Interpolation::
 * Geometry::
 * Signal Processing::           
 * Image Processing::            
 * Audio Processing::            
 * Object Oriented Programming::            
 * GUI Development::            
 * System Utilities::            
+* Java Interface:: 
 * Packages:: 
 * Dynamically Linked Functions::
 * Test and Demo Functions::
 * Tips and Standards::                        
 * Contributing Guidelines::
 * Obsolete Functions::
 * Trouble::                     If you have trouble installing Octave.
 * Installation::                How to configure, compile and install Octave.
@@ -361,25 +362,25 @@ Boolean Expressions
 
 Evaluation
 
 * Calling a Function by its Name::
 * Evaluation in a Different Context::
 
 Statements
 
-* The @code{if} Statement::            
-* The @code{switch} Statement::        
-* The @code{while} Statement::         
-* The @code{do-until} Statement::      
-* The @code{for} Statement::           
-* The @code{break} Statement::         
-* The @code{continue} Statement::      
-* The @code{unwind_protect} Statement::  
-* The @code{try} Statement::           
+* The if Statement::            
+* The switch Statement::        
+* The while Statement::         
+* The do-until Statement::      
+* The for Statement::           
+* The break Statement::         
+* The continue Statement::      
+* The unwind_protect Statement::  
+* The try Statement::           
 * Continuation Lines::          
 
 The @code{switch} Statement
 
 * Notes for the C Programmer::  
 
 The @code{for} Statement
 
@@ -904,16 +905,17 @@ Grammar and Parser
 @include interp.texi
 @include geometry.texi
 @include signal.texi
 @include image.texi
 @include audio.texi
 @include oop.texi
 @include gui.texi
 @include system.texi
+@include java.texi
 @include package.texi
 
 @c maybe add again later, if anyone every writes any really interesting
 @c fun stuff for Octave.
 @c
 @c @include amuse.texi
 
 @c ------------------------------------------------------------------------
diff --git a/doc/interpreter/stmt.txi b/doc/interpreter/stmt.txi
--- a/doc/interpreter/stmt.txi
+++ b/doc/interpreter/stmt.txi
@@ -41,30 +41,30 @@ but using the more specific keywords is 
 them, Octave is able to provide better diagnostics for mismatched or
 missing end tokens.
 
 The list of statements contained between keywords like @code{if} or
 @code{while} and the corresponding end statement is called the
 @dfn{body} of a control statement.
 
 @menu
-* The @code{if} Statement::            
-* The @code{switch} Statement::        
-* The @code{while} Statement::         
-* The @code{do-until} Statement::      
-* The @code{for} Statement::           
-* The @code{break} Statement::         
-* The @code{continue} Statement::      
-* The @code{unwind_protect} Statement::  
-* The @code{try} Statement::           
+* The if Statement::            
+* The switch Statement::        
+* The while Statement::         
+* The do-until Statement::      
+* The for Statement::           
+* The break Statement::         
+* The continue Statement::      
+* The unwind_protect Statement::  
+* The try Statement::           
 * Continuation Lines::          
 @end menu
 
-@node The @code{if} Statement
-@section The @code{if} Statement
+@node The if Statement
+@section The if Statement
 @cindex @code{if} statement
 @cindex @code{else} statement
 @cindex @code{elseif} statement
 @cindex @code{endif} statement
 
 The @code{if} statement is Octave's decision-making statement.  There
 are three basic forms of an @code{if} statement.  In its simplest form,
 it looks like this:
@@ -202,18 +202,18 @@ else
   endif
 @end group
 @end example
 
 @noindent
 using the indentation to show how Octave groups the statements.
 @xref{Functions and Scripts}.
 
-@node The @code{switch} Statement
-@section The @code{switch} Statement
+@node The switch Statement
+@section The switch Statement
 @cindex @code{switch} statement
 @cindex @code{case} statement
 @cindex @code{otherwise} statement
 @cindex @code{endswitch} statement
 
 It is very common to take different actions depending on the value of
 one variable.  This is possible using the @code{if} statement in the
 following way
@@ -380,18 +380,18 @@ switch (foo)
   case @{ 1, 2 @}
     doit ();
   @dots{}
 @end group
 @end example
 
 @end itemize
 
-@node The @code{while} Statement
-@section The @code{while} Statement
+@node The while Statement
+@section The while Statement
 @cindex @code{while} statement
 @cindex @code{endwhile} statement
 @cindex loop
 @cindex body of a loop
 
 In programming, a @dfn{loop} means a part of a program that is (or at least can
 be) executed two or more times in succession.
 
@@ -449,18 +449,18 @@ 10.  This is the case when @code{i} equa
 values in the sequence.  Then the @code{i++} increments the value of
 @code{i} and the loop repeats.  The loop terminates when @code{i}
 reaches 11.
 
 A newline is not required between the condition and the
 body; but using one makes the program clearer unless the body is very
 simple.
 
-@node The @code{do-until} Statement
-@section The @code{do-until} Statement
+@node The do-until Statement
+@section The do-until Statement
 @cindex @code{do-until} statement
 
 The @code{do-until} statement is similar to the @code{while} statement,
 except that it repeatedly executes a statement until a condition becomes
 true, and the test of the condition is at the end of the loop, so the
 body of the loop is always executed at least once.  As with the
 condition in an @code{if} statement, the condition in a @code{do-until}
 statement is considered true if its value is non-zero, and false if its
@@ -496,18 +496,18 @@ do
 until (i == 10)
 @end group
 @end example
 
 A newline is not required between the @code{do} keyword and the
 body; but using one makes the program clearer unless the body is very
 simple.
 
-@node The @code{for} Statement
-@section The @code{for} Statement
+@node The for Statement
+@section The for Statement
 @cindex @code{for} statement
 @cindex @code{endfor} statement
 
 The @code{for} statement makes it more convenient to count iterations of a
 loop.  The general form of the @code{for} statement looks like this:
 
 @example
 @group
@@ -653,18 +653,18 @@ The elements are not accessed in any par
 cycle through the list in a particular way, you will have to use the
 function @code{fieldnames} and sort the list yourself.
 
 The @var{key} variable may also be omitted.  If it is, the brackets are
 also optional.  This is useful for cycling through the values of all the
 structure elements when the names of the elements do not need to be
 known.
 
-@node The @code{break} Statement
-@section The @code{break} Statement
+@node The break Statement
+@section The break Statement
 @cindex @code{break} statement
 
 The @code{break} statement jumps out of the innermost @code{for} or
 @code{while} loop that encloses it.  The @code{break} statement may only
 be used within the body of a loop.  The following example finds the
 smallest divisor of a given integer, and also identifies prime numbers:
 
 @example
@@ -708,18 +708,18 @@ while (1)
   if (div*div > num)
     printf ("%d is prime\n", num);
     break;
   endif
 endwhile
 @end group
 @end example
 
-@node The @code{continue} Statement
-@section The @code{continue} Statement
+@node The continue Statement
+@section The continue Statement
 @cindex @code{continue} statement
 
 The @code{continue} statement, like @code{break}, is used only inside
 @code{for} or @code{while} loops.  It skips over the rest of the loop
 body, causing the next cycle around the loop to begin immediately.
 Contrast this with @code{break}, which jumps out of the loop altogether.
 Here is an example:
 
@@ -757,18 +757,18 @@ would probably write the loop like this:
 for x = vec
   if (rem (x, 2) == 0)
     printf ("%d\n", x);
   endif
 endfor
 @end group
 @end example
 
-@node The @code{unwind_protect} Statement
-@section The @code{unwind_protect} Statement
+@node The unwind_protect Statement
+@section The unwind_protect Statement
 @cindex @code{unwind_protect} statement
 @cindex @code{unwind_protect_cleanup}
 @cindex @code{end_unwind_protect}
 
 Octave supports a limited form of exception handling modelled after the
 unwind-protect form of Lisp.  
 
 The general form of an @code{unwind_protect} block looks like this:
@@ -808,18 +808,18 @@ end_unwind_protect
 
 @noindent
 Without @code{unwind_protect}, the value of @var{frobnosticate}
 would not be restored if an error occurs while evaluating the first part
 of the @code{unwind_protect} block because evaluation would stop at the
 point of the error and the statement to restore the value would not be
 executed.
 
-@node The @code{try} Statement
-@section The @code{try} Statement
+@node The try Statement
+@section The try Statement
 @cindex @code{try} statement
 @cindex @code{catch}
 @cindex @code{end_try_catch}
 
 In addition to unwind_protect, Octave supports another limited form of
 exception handling.
 
 The general form of a @code{try} block looks like this:
diff --git a/doc/interpreter/system.txi b/doc/interpreter/system.txi
--- a/doc/interpreter/system.txi
+++ b/doc/interpreter/system.txi
@@ -516,18 +516,16 @@ referred to as a @var{grp_struct}.
 @DOCSTRING(ver)
 
 @DOCSTRING(compare_versions)
 
 @DOCSTRING(license)
 
 @DOCSTRING(octave_config_info)
 
-@DOCSTRING(usejava)
-
 @DOCSTRING(getrusage)
 
 @node Hashing Functions
 @section Hashing Functions
 
 It is often necessary to find if two strings or files are
 identical.  This might be done by comparing them character by character
 and looking for differences.  However, this can be slow, and so comparing
diff --git a/doc/interpreter/vectorize.txi b/doc/interpreter/vectorize.txi
--- a/doc/interpreter/vectorize.txi
+++ b/doc/interpreter/vectorize.txi
@@ -630,17 +630,17 @@ endwhile
 @end example
 
 @item Avoid calling @code{eval} or @code{feval} excessively.
 Parsing input or looking up the name of a function in the symbol table are
 relatively expensive operations.
 
 If you are using @code{eval} merely as an exception handling mechanism, and not
 because you need to execute some arbitrary text, use the @code{try}
-statement instead.  @xref{The @code{try} Statement}.
+statement instead.  @xref{The try Statement}.
 
 @item Use @code{ignore_function_time_stamp} when appropriate.
 If you are calling lots of functions, and none of them will need to change
 during your run, set the variable @code{ignore_function_time_stamp} to
 @code{"all"}.  This will stop Octave from checking the time stamp of a function
 file to see if it has been updated while the program is being run.
 @end itemize
 
diff --git a/libgnu/Makefile.am b/libgnu/Makefile.am
deleted file mode 100644
--- a/libgnu/Makefile.am
+++ /dev/null
@@ -1,3131 +0,0 @@
-## DO NOT EDIT! GENERATED AUTOMATICALLY!
-## Process this file with automake to produce Makefile.in.
-# Copyright (C) 2002-2012 Free Software Foundation, Inc.
-#
-# This file is free software; you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation; either version 3 of the License, or
-# (at your option) any later version.
-#
-# This file is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with this file.  If not, see <http://www.gnu.org/licenses/>.
-#
-# As a special exception to the GNU General Public License,
-# this file may be distributed as part of a program that
-# contains a configuration script generated by Autoconf, under
-# the same distribution terms as the rest of that program.
-#
-# Generated by gnulib-tool.
-# Reproduce by: gnulib-tool --import --dir=. --local-dir=gl --lib=libgnu --source-base=libgnu --m4-base=m4 --doc-base=doc --tests-base=tests --aux-dir=build-aux --no-conditional-dependencies --libtool --macro-prefix=gl base64 canonicalize chdir close closedir copysign copysignf crypto/md5 dup2 fclose fcntl fflush filemode float floor floorf fnmatch fopen fseek ftell getcwd gethostname getopt-gnu gettimeofday glob isatty link lstat malloc-gnu mkdir mkfifo mkostemp mktime nanosleep nproc open opendir pathmax progname putenv readdir readlink realloc-gnu rename rmdir round roundf select sigaction signal sigprocmask sleep stat stddef stdint stdio strerror strftime strptime symlink sys_stat sys_time sys_times time times tmpfile trunc truncf unistd unlink vasprintf
-
-AUTOMAKE_OPTIONS = 1.5 gnits
-
-SUBDIRS =
-noinst_HEADERS =
-noinst_LIBRARIES =
-noinst_LTLIBRARIES =
-EXTRA_DIST =
-BUILT_SOURCES =
-SUFFIXES =
-MOSTLYCLEANFILES = core *.stackdump
-MOSTLYCLEANDIRS =
-CLEANFILES =
-DISTCLEANFILES =
-MAINTAINERCLEANFILES =
-
-AM_CPPFLAGS =
-AM_CFLAGS =
-
-noinst_LTLIBRARIES += libgnu.la
-
-libgnu_la_SOURCES =
-libgnu_la_LIBADD = $(gl_LTLIBOBJS)
-libgnu_la_DEPENDENCIES = $(gl_LTLIBOBJS)
-EXTRA_libgnu_la_SOURCES =
-libgnu_la_LDFLAGS = $(AM_LDFLAGS)
-libgnu_la_LDFLAGS += -no-undefined
-libgnu_la_LDFLAGS += $(COPYSIGNF_LIBM)
-libgnu_la_LDFLAGS += $(COPYSIGN_LIBM)
-libgnu_la_LDFLAGS += $(FLOORF_LIBM)
-libgnu_la_LDFLAGS += $(FLOOR_LIBM)
-libgnu_la_LDFLAGS += $(GETHOSTNAME_LIB)
-libgnu_la_LDFLAGS += $(LIBSOCKET)
-libgnu_la_LDFLAGS += $(LIB_NANOSLEEP)
-libgnu_la_LDFLAGS += $(LIB_SELECT)
-libgnu_la_LDFLAGS += $(LTLIBINTL)
-libgnu_la_LDFLAGS += $(ROUNDF_LIBM)
-libgnu_la_LDFLAGS += $(ROUND_LIBM)
-libgnu_la_LDFLAGS += $(TRUNCF_LIBM)
-libgnu_la_LDFLAGS += $(TRUNC_LIBM)
-
-## begin gnulib module alloca
-
-
-libgnu_la_LIBADD += @LTALLOCA@
-libgnu_la_DEPENDENCIES += @LTALLOCA@
-EXTRA_DIST += alloca.c
-
-EXTRA_libgnu_la_SOURCES += alloca.c
-
-## end   gnulib module alloca
-
-## begin gnulib module alloca-opt
-
-BUILT_SOURCES += $(ALLOCA_H)
-
-# We need the following in order to create <alloca.h> when the system
-# doesn't have one that works with the given compiler.
-if GL_GENERATE_ALLOCA_H
-alloca.h: alloca.in.h $(top_builddir)/config.status
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
-	  cat $(srcdir)/alloca.in.h; \
-	} > $@-t && \
-	mv -f $@-t $@
-else
-alloca.h: $(top_builddir)/config.status
-	rm -f $@
-endif
-MOSTLYCLEANFILES += alloca.h alloca.h-t
-
-EXTRA_DIST += alloca.in.h
-
-## end   gnulib module alloca-opt
-
-## begin gnulib module areadlink-with-size
-
-libgnu_la_SOURCES += areadlink-with-size.c
-
-EXTRA_DIST += areadlink.h
-
-## end   gnulib module areadlink-with-size
-
-## begin gnulib module at-internal
-
-
-EXTRA_DIST += openat-priv.h openat-proc.c
-
-EXTRA_libgnu_la_SOURCES += openat-proc.c
-
-## end   gnulib module at-internal
-
-## begin gnulib module base64
-
-libgnu_la_SOURCES += base64.h base64.c
-
-## end   gnulib module base64
-
-## begin gnulib module bitrotate
-
-libgnu_la_SOURCES += bitrotate.h
-
-## end   gnulib module bitrotate
-
-## begin gnulib module c-ctype
-
-libgnu_la_SOURCES += c-ctype.h c-ctype.c
-
-## end   gnulib module c-ctype
-
-## begin gnulib module canonicalize
-
-libgnu_la_SOURCES += canonicalize.c
-
-EXTRA_DIST += canonicalize.h
-
-## end   gnulib module canonicalize
-
-## begin gnulib module canonicalize-lgpl
-
-
-EXTRA_DIST += canonicalize-lgpl.c
-
-EXTRA_libgnu_la_SOURCES += canonicalize-lgpl.c
-
-## end   gnulib module canonicalize-lgpl
-
-## begin gnulib module chdir-long
-
-
-EXTRA_DIST += chdir-long.c chdir-long.h
-
-EXTRA_libgnu_la_SOURCES += chdir-long.c
-
-## end   gnulib module chdir-long
-
-## begin gnulib module cloexec
-
-libgnu_la_SOURCES += cloexec.c
-
-EXTRA_DIST += cloexec.h
-
-## end   gnulib module cloexec
-
-## begin gnulib module close
-
-
-EXTRA_DIST += close.c
-
-EXTRA_libgnu_la_SOURCES += close.c
-
-## end   gnulib module close
-
-## begin gnulib module closedir
-
-
-EXTRA_DIST += closedir.c dirent-private.h
-
-EXTRA_libgnu_la_SOURCES += closedir.c
-
-## end   gnulib module closedir
-
-## begin gnulib module configmake
-
-# Listed in the same order as the GNU makefile conventions, and
-# provided by autoconf 2.59c+.
-# The Automake-defined pkg* macros are appended, in the order
-# listed in the Automake 1.10a+ documentation.
-configmake.h: Makefile
-	$(AM_V_GEN)rm -f $@-t && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
-	  echo '#define PREFIX "$(prefix)"'; \
-	  echo '#define EXEC_PREFIX "$(exec_prefix)"'; \
-	  echo '#define BINDIR "$(bindir)"'; \
-	  echo '#define SBINDIR "$(sbindir)"'; \
-	  echo '#define LIBEXECDIR "$(libexecdir)"'; \
-	  echo '#define DATAROOTDIR "$(datarootdir)"'; \
-	  echo '#define DATADIR "$(datadir)"'; \
-	  echo '#define SYSCONFDIR "$(sysconfdir)"'; \
-	  echo '#define SHAREDSTATEDIR "$(sharedstatedir)"'; \
-	  echo '#define LOCALSTATEDIR "$(localstatedir)"'; \
-	  echo '#define INCLUDEDIR "$(includedir)"'; \
-	  echo '#define OLDINCLUDEDIR "$(oldincludedir)"'; \
-	  echo '#define DOCDIR "$(docdir)"'; \
-	  echo '#define INFODIR "$(infodir)"'; \
-	  echo '#define HTMLDIR "$(htmldir)"'; \
-	  echo '#define DVIDIR "$(dvidir)"'; \
-	  echo '#define PDFDIR "$(pdfdir)"'; \
-	  echo '#define PSDIR "$(psdir)"'; \
-	  echo '#define LIBDIR "$(libdir)"'; \
-	  echo '#define LISPDIR "$(lispdir)"'; \
-	  echo '#define LOCALEDIR "$(localedir)"'; \
-	  echo '#define MANDIR "$(mandir)"'; \
-	  echo '#define MANEXT "$(manext)"'; \
-	  echo '#define PKGDATADIR "$(pkgdatadir)"'; \
-	  echo '#define PKGINCLUDEDIR "$(pkgincludedir)"'; \
-	  echo '#define PKGLIBDIR "$(pkglibdir)"'; \
-	  echo '#define PKGLIBEXECDIR "$(pkglibexecdir)"'; \
-	} | sed '/""/d' > $@-t && \
-	mv -f $@-t $@
-
-BUILT_SOURCES += configmake.h
-CLEANFILES += configmake.h configmake.h-t
-
-## end   gnulib module configmake
-
-## begin gnulib module copysign
-
-
-EXTRA_DIST += copysign.c
-
-EXTRA_libgnu_la_SOURCES += copysign.c
-
-## end   gnulib module copysign
-
-## begin gnulib module copysignf
-
-
-EXTRA_DIST += copysignf.c
-
-EXTRA_libgnu_la_SOURCES += copysignf.c
-
-## end   gnulib module copysignf
-
-## begin gnulib module crypto/md5
-
-libgnu_la_SOURCES += md5.c
-
-EXTRA_DIST += md5.h
-
-## end   gnulib module crypto/md5
-
-## begin gnulib module dirent
-
-BUILT_SOURCES += dirent.h
-
-# We need the following in order to create <dirent.h> when the system
-# doesn't have one that works with the given compiler.
-dirent.h: dirent.in.h $(top_builddir)/config.status $(CXXDEFS_H) $(ARG_NONNULL_H) $(WARN_ON_USE_H)
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
-	  sed -e 's|@''GUARD_PREFIX''@|GL|g' \
-	      -e 's|@''HAVE_DIRENT_H''@|$(HAVE_DIRENT_H)|g' \
-	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
-	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
-	      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \
-	      -e 's|@''NEXT_DIRENT_H''@|$(NEXT_DIRENT_H)|g' \
-	      -e 's/@''GNULIB_OPENDIR''@/$(GNULIB_OPENDIR)/g' \
-	      -e 's/@''GNULIB_READDIR''@/$(GNULIB_READDIR)/g' \
-	      -e 's/@''GNULIB_REWINDDIR''@/$(GNULIB_REWINDDIR)/g' \
-	      -e 's/@''GNULIB_CLOSEDIR''@/$(GNULIB_CLOSEDIR)/g' \
-	      -e 's/@''GNULIB_DIRFD''@/$(GNULIB_DIRFD)/g' \
-	      -e 's/@''GNULIB_FDOPENDIR''@/$(GNULIB_FDOPENDIR)/g' \
-	      -e 's/@''GNULIB_SCANDIR''@/$(GNULIB_SCANDIR)/g' \
-	      -e 's/@''GNULIB_ALPHASORT''@/$(GNULIB_ALPHASORT)/g' \
-	      -e 's/@''HAVE_OPENDIR''@/$(HAVE_OPENDIR)/g' \
-	      -e 's/@''HAVE_READDIR''@/$(HAVE_READDIR)/g' \
-	      -e 's/@''HAVE_REWINDDIR''@/$(HAVE_REWINDDIR)/g' \
-	      -e 's/@''HAVE_CLOSEDIR''@/$(HAVE_CLOSEDIR)/g' \
-	      -e 's|@''HAVE_DECL_DIRFD''@|$(HAVE_DECL_DIRFD)|g' \
-	      -e 's|@''HAVE_DECL_FDOPENDIR''@|$(HAVE_DECL_FDOPENDIR)|g' \
-	      -e 's|@''HAVE_FDOPENDIR''@|$(HAVE_FDOPENDIR)|g' \
-	      -e 's|@''HAVE_SCANDIR''@|$(HAVE_SCANDIR)|g' \
-	      -e 's|@''HAVE_ALPHASORT''@|$(HAVE_ALPHASORT)|g' \
-	      -e 's|@''REPLACE_OPENDIR''@|$(REPLACE_OPENDIR)|g' \
-	      -e 's|@''REPLACE_CLOSEDIR''@|$(REPLACE_CLOSEDIR)|g' \
-	      -e 's|@''REPLACE_DIRFD''@|$(REPLACE_DIRFD)|g' \
-	      -e 's|@''REPLACE_FDOPENDIR''@|$(REPLACE_FDOPENDIR)|g' \
-	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
-	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
-	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)' \
-	      < $(srcdir)/dirent.in.h; \
-	} > $@-t && \
-	mv $@-t $@
-MOSTLYCLEANFILES += dirent.h dirent.h-t
-
-EXTRA_DIST += dirent.in.h
-
-## end   gnulib module dirent
-
-## begin gnulib module dirfd
-
-
-EXTRA_DIST += dirfd.c
-
-EXTRA_libgnu_la_SOURCES += dirfd.c
-
-## end   gnulib module dirfd
-
-## begin gnulib module dirname
-
-libgnu_la_SOURCES += dirname.c basename.c
-
-EXTRA_DIST += stripslash.c
-
-EXTRA_libgnu_la_SOURCES += stripslash.c
-
-## end   gnulib module dirname
-
-## begin gnulib module dirname-lgpl
-
-libgnu_la_SOURCES += dirname-lgpl.c basename-lgpl.c stripslash.c
-
-EXTRA_DIST += dirname.h
-
-## end   gnulib module dirname-lgpl
-
-## begin gnulib module dosname
-
-
-EXTRA_DIST += dosname.h
-
-## end   gnulib module dosname
-
-## begin gnulib module dup
-
-
-EXTRA_DIST += dup.c
-
-EXTRA_libgnu_la_SOURCES += dup.c
-
-## end   gnulib module dup
-
-## begin gnulib module dup2
-
-
-EXTRA_DIST += dup2.c
-
-EXTRA_libgnu_la_SOURCES += dup2.c
-
-## end   gnulib module dup2
-
-## begin gnulib module errno
-
-BUILT_SOURCES += $(ERRNO_H)
-
-# We need the following in order to create <errno.h> when the system
-# doesn't have one that is POSIX compliant.
-if GL_GENERATE_ERRNO_H
-errno.h: errno.in.h $(top_builddir)/config.status
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */' && \
-	  sed -e 's|@''GUARD_PREFIX''@|GL|g' \
-	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
-	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
-	      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \
-	      -e 's|@''NEXT_ERRNO_H''@|$(NEXT_ERRNO_H)|g' \
-	      -e 's|@''EMULTIHOP_HIDDEN''@|$(EMULTIHOP_HIDDEN)|g' \
-	      -e 's|@''EMULTIHOP_VALUE''@|$(EMULTIHOP_VALUE)|g' \
-	      -e 's|@''ENOLINK_HIDDEN''@|$(ENOLINK_HIDDEN)|g' \
-	      -e 's|@''ENOLINK_VALUE''@|$(ENOLINK_VALUE)|g' \
-	      -e 's|@''EOVERFLOW_HIDDEN''@|$(EOVERFLOW_HIDDEN)|g' \
-	      -e 's|@''EOVERFLOW_VALUE''@|$(EOVERFLOW_VALUE)|g' \
-	      < $(srcdir)/errno.in.h; \
-	} > $@-t && \
-	mv $@-t $@
-else
-errno.h: $(top_builddir)/config.status
-	rm -f $@
-endif
-MOSTLYCLEANFILES += errno.h errno.h-t
-
-EXTRA_DIST += errno.in.h
-
-## end   gnulib module errno
-
-## begin gnulib module error
-
-
-EXTRA_DIST += error.c error.h
-
-EXTRA_libgnu_la_SOURCES += error.c
-
-## end   gnulib module error
-
-## begin gnulib module exitfail
-
-libgnu_la_SOURCES += exitfail.c
-
-EXTRA_DIST += exitfail.h
-
-## end   gnulib module exitfail
-
-## begin gnulib module fchdir
-
-
-EXTRA_DIST += fchdir.c
-
-EXTRA_libgnu_la_SOURCES += fchdir.c
-
-## end   gnulib module fchdir
-
-## begin gnulib module fclose
-
-
-EXTRA_DIST += fclose.c
-
-EXTRA_libgnu_la_SOURCES += fclose.c
-
-## end   gnulib module fclose
-
-## begin gnulib module fcntl
-
-
-EXTRA_DIST += fcntl.c
-
-EXTRA_libgnu_la_SOURCES += fcntl.c
-
-## end   gnulib module fcntl
-
-## begin gnulib module fcntl-h
-
-BUILT_SOURCES += fcntl.h
-
-# We need the following in order to create <fcntl.h> when the system
-# doesn't have one that works with the given compiler.
-fcntl.h: fcntl.in.h $(top_builddir)/config.status $(CXXDEFS_H) $(ARG_NONNULL_H) $(WARN_ON_USE_H)
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
-	  sed -e 's|@''GUARD_PREFIX''@|GL|g' \
-	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
-	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
-	      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \
-	      -e 's|@''NEXT_FCNTL_H''@|$(NEXT_FCNTL_H)|g' \
-	      -e 's/@''GNULIB_FCNTL''@/$(GNULIB_FCNTL)/g' \
-	      -e 's/@''GNULIB_NONBLOCKING''@/$(GNULIB_NONBLOCKING)/g' \
-	      -e 's/@''GNULIB_OPEN''@/$(GNULIB_OPEN)/g' \
-	      -e 's/@''GNULIB_OPENAT''@/$(GNULIB_OPENAT)/g' \
-	      -e 's|@''HAVE_FCNTL''@|$(HAVE_FCNTL)|g' \
-	      -e 's|@''HAVE_OPENAT''@|$(HAVE_OPENAT)|g' \
-	      -e 's|@''REPLACE_FCNTL''@|$(REPLACE_FCNTL)|g' \
-	      -e 's|@''REPLACE_OPEN''@|$(REPLACE_OPEN)|g' \
-	      -e 's|@''REPLACE_OPENAT''@|$(REPLACE_OPENAT)|g' \
-	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
-	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
-	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)' \
-	      < $(srcdir)/fcntl.in.h; \
-	} > $@-t && \
-	mv $@-t $@
-MOSTLYCLEANFILES += fcntl.h fcntl.h-t
-
-EXTRA_DIST += fcntl.in.h
-
-## end   gnulib module fcntl-h
-
-## begin gnulib module fd-hook
-
-libgnu_la_SOURCES += fd-hook.c
-
-EXTRA_DIST += fd-hook.h
-
-## end   gnulib module fd-hook
-
-## begin gnulib module fdopendir
-
-
-EXTRA_DIST += fdopendir.c
-
-EXTRA_libgnu_la_SOURCES += fdopendir.c
-
-## end   gnulib module fdopendir
-
-## begin gnulib module fflush
-
-
-EXTRA_DIST += fflush.c stdio-impl.h
-
-EXTRA_libgnu_la_SOURCES += fflush.c
-
-## end   gnulib module fflush
-
-## begin gnulib module file-set
-
-libgnu_la_SOURCES += file-set.c
-
-EXTRA_DIST += file-set.h
-
-## end   gnulib module file-set
-
-## begin gnulib module filemode
-
-libgnu_la_SOURCES += filemode.c
-
-EXTRA_DIST += filemode.h
-
-## end   gnulib module filemode
-
-## begin gnulib module filename
-
-
-EXTRA_DIST += filename.h
-
-## end   gnulib module filename
-
-## begin gnulib module filenamecat-lgpl
-
-libgnu_la_SOURCES += filenamecat-lgpl.c
-
-EXTRA_DIST += filenamecat.h
-
-## end   gnulib module filenamecat-lgpl
-
-## begin gnulib module float
-
-BUILT_SOURCES += $(FLOAT_H)
-
-# We need the following in order to create <float.h> when the system
-# doesn't have one that works with the given compiler.
-if GL_GENERATE_FLOAT_H
-float.h: float.in.h $(top_builddir)/config.status
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */' && \
-	  sed -e 's|@''GUARD_PREFIX''@|GL|g' \
-	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
-	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
-	      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \
-	      -e 's|@''NEXT_FLOAT_H''@|$(NEXT_FLOAT_H)|g' \
-	      -e 's|@''REPLACE_ITOLD''@|$(REPLACE_ITOLD)|g' \
-	      < $(srcdir)/float.in.h; \
-	} > $@-t && \
-	mv $@-t $@
-else
-float.h: $(top_builddir)/config.status
-	rm -f $@
-endif
-MOSTLYCLEANFILES += float.h float.h-t
-
-EXTRA_DIST += float.c float.in.h itold.c
-
-EXTRA_libgnu_la_SOURCES += float.c itold.c
-
-## end   gnulib module float
-
-## begin gnulib module floor
-
-
-EXTRA_DIST += floor.c
-
-EXTRA_libgnu_la_SOURCES += floor.c
-
-## end   gnulib module floor
-
-## begin gnulib module floorf
-
-
-EXTRA_DIST += floor.c floorf.c
-
-EXTRA_libgnu_la_SOURCES += floor.c floorf.c
-
-## end   gnulib module floorf
-
-## begin gnulib module fnmatch
-
-BUILT_SOURCES += $(FNMATCH_H)
-
-# We need the following in order to create <fnmatch.h> when the system
-# doesn't have one that supports the required API.
-if GL_GENERATE_FNMATCH_H
-fnmatch.h: fnmatch.in.h $(top_builddir)/config.status $(ARG_NONNULL_H)
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
-	  sed -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
-	      < $(srcdir)/fnmatch.in.h; \
-	} > $@-t && \
-	mv -f $@-t $@
-else
-fnmatch.h: $(top_builddir)/config.status
-	rm -f $@
-endif
-MOSTLYCLEANFILES += fnmatch.h fnmatch.h-t
-
-EXTRA_DIST += fnmatch.c fnmatch.in.h fnmatch_loop.c
-
-EXTRA_libgnu_la_SOURCES += fnmatch.c fnmatch_loop.c
-
-## end   gnulib module fnmatch
-
-## begin gnulib module fopen
-
-
-EXTRA_DIST += fopen.c
-
-EXTRA_libgnu_la_SOURCES += fopen.c
-
-## end   gnulib module fopen
-
-## begin gnulib module fpurge
-
-
-EXTRA_DIST += fpurge.c stdio-impl.h
-
-EXTRA_libgnu_la_SOURCES += fpurge.c
-
-## end   gnulib module fpurge
-
-## begin gnulib module freading
-
-libgnu_la_SOURCES += freading.c
-
-EXTRA_DIST += freading.h stdio-impl.h
-
-## end   gnulib module freading
-
-## begin gnulib module fseek
-
-
-EXTRA_DIST += fseek.c
-
-EXTRA_libgnu_la_SOURCES += fseek.c
-
-## end   gnulib module fseek
-
-## begin gnulib module fseeko
-
-
-EXTRA_DIST += fseeko.c stdio-impl.h
-
-EXTRA_libgnu_la_SOURCES += fseeko.c
-
-## end   gnulib module fseeko
-
-## begin gnulib module fstat
-
-
-EXTRA_DIST += fstat.c
-
-EXTRA_libgnu_la_SOURCES += fstat.c
-
-## end   gnulib module fstat
-
-## begin gnulib module fstatat
-
-
-EXTRA_DIST += at-func.c fstatat.c openat-priv.h
-
-EXTRA_libgnu_la_SOURCES += at-func.c fstatat.c
-
-## end   gnulib module fstatat
-
-## begin gnulib module ftell
-
-
-EXTRA_DIST += ftell.c
-
-EXTRA_libgnu_la_SOURCES += ftell.c
-
-## end   gnulib module ftell
-
-## begin gnulib module ftello
-
-
-EXTRA_DIST += ftello.c stdio-impl.h
-
-EXTRA_libgnu_la_SOURCES += ftello.c
-
-## end   gnulib module ftello
-
-## begin gnulib module getcwd
-
-
-EXTRA_DIST += getcwd.c
-
-EXTRA_libgnu_la_SOURCES += getcwd.c
-
-## end   gnulib module getcwd
-
-## begin gnulib module getcwd-lgpl
-
-
-EXTRA_DIST += getcwd-lgpl.c
-
-EXTRA_libgnu_la_SOURCES += getcwd-lgpl.c
-
-## end   gnulib module getcwd-lgpl
-
-## begin gnulib module getdtablesize
-
-
-EXTRA_DIST += getdtablesize.c
-
-EXTRA_libgnu_la_SOURCES += getdtablesize.c
-
-## end   gnulib module getdtablesize
-
-## begin gnulib module gethostname
-
-
-EXTRA_DIST += gethostname.c w32sock.h
-
-EXTRA_libgnu_la_SOURCES += gethostname.c
-
-## end   gnulib module gethostname
-
-## begin gnulib module getlogin_r
-
-
-EXTRA_DIST += getlogin_r.c
-
-EXTRA_libgnu_la_SOURCES += getlogin_r.c
-
-## end   gnulib module getlogin_r
-
-## begin gnulib module getopt-posix
-
-BUILT_SOURCES += $(GETOPT_H)
-
-# We need the following in order to create <getopt.h> when the system
-# doesn't have one that works with the given compiler.
-getopt.h: getopt.in.h $(top_builddir)/config.status $(ARG_NONNULL_H)
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
-	  sed -e 's|@''GUARD_PREFIX''@|GL|g' \
-	      -e 's|@''HAVE_GETOPT_H''@|$(HAVE_GETOPT_H)|g' \
-	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
-	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
-	      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \
-	      -e 's|@''NEXT_GETOPT_H''@|$(NEXT_GETOPT_H)|g' \
-	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
-	      < $(srcdir)/getopt.in.h; \
-	} > $@-t && \
-	mv -f $@-t $@
-MOSTLYCLEANFILES += getopt.h getopt.h-t
-
-EXTRA_DIST += getopt.c getopt.in.h getopt1.c getopt_int.h
-
-EXTRA_libgnu_la_SOURCES += getopt.c getopt1.c
-
-## end   gnulib module getopt-posix
-
-## begin gnulib module gettext-h
-
-libgnu_la_SOURCES += gettext.h
-
-## end   gnulib module gettext-h
-
-## begin gnulib module gettimeofday
-
-
-EXTRA_DIST += gettimeofday.c
-
-EXTRA_libgnu_la_SOURCES += gettimeofday.c
-
-## end   gnulib module gettimeofday
-
-## begin gnulib module glob
-
-BUILT_SOURCES += $(GLOB_H)
-
-# We need the following in order to create <glob.h> when the system
-# doesn't have one that works with the given compiler.
-if GL_GENERATE_GLOB_H
-glob.h: glob.in.h $(top_builddir)/config.status $(CXXDEFS_H) $(ARG_NONNULL_H) $(WARN_ON_USE_H)
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
-	  sed -e 's|@''HAVE_SYS_CDEFS_H''@|$(HAVE_SYS_CDEFS_H)|g' \
-	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
-	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
-	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)' \
-	      < $(srcdir)/glob.in.h; \
-	} > $@-t && \
-	mv -f $@-t $@
-else
-glob.h: $(top_builddir)/config.status
-	rm -f $@
-endif
-MOSTLYCLEANFILES += glob.h glob.h-t
-
-EXTRA_DIST += glob-libc.h glob.c glob.in.h
-
-EXTRA_libgnu_la_SOURCES += glob.c
-
-## end   gnulib module glob
-
-## begin gnulib module hash
-
-libgnu_la_SOURCES += hash.c
-
-EXTRA_DIST += hash.h
-
-## end   gnulib module hash
-
-## begin gnulib module hash-pjw
-
-libgnu_la_SOURCES += hash-pjw.h hash-pjw.c
-
-## end   gnulib module hash-pjw
-
-## begin gnulib module hash-triple
-
-libgnu_la_SOURCES += hash-triple.c
-
-EXTRA_DIST += hash-triple.h
-
-## end   gnulib module hash-triple
-
-## begin gnulib module intprops
-
-
-EXTRA_DIST += intprops.h
-
-## end   gnulib module intprops
-
-## begin gnulib module isatty
-
-
-EXTRA_DIST += isatty.c
-
-EXTRA_libgnu_la_SOURCES += isatty.c
-
-## end   gnulib module isatty
-
-## begin gnulib module isnand-nolibm
-
-
-EXTRA_DIST += float+.h isnan.c isnand-nolibm.h isnand.c
-
-EXTRA_libgnu_la_SOURCES += isnan.c isnand.c
-
-## end   gnulib module isnand-nolibm
-
-## begin gnulib module isnanf-nolibm
-
-
-EXTRA_DIST += float+.h isnan.c isnanf-nolibm.h isnanf.c
-
-EXTRA_libgnu_la_SOURCES += isnan.c isnanf.c
-
-## end   gnulib module isnanf-nolibm
-
-## begin gnulib module isnanl-nolibm
-
-
-EXTRA_DIST += float+.h isnan.c isnanl-nolibm.h isnanl.c
-
-EXTRA_libgnu_la_SOURCES += isnan.c isnanl.c
-
-## end   gnulib module isnanl-nolibm
-
-## begin gnulib module link
-
-
-EXTRA_DIST += link.c
-
-EXTRA_libgnu_la_SOURCES += link.c
-
-## end   gnulib module link
-
-## begin gnulib module localcharset
-
-libgnu_la_SOURCES += localcharset.h localcharset.c
-
-# We need the following in order to install a simple file in $(libdir)
-# which is shared with other installed packages. We use a list of referencing
-# packages so that "make uninstall" will remove the file if and only if it
-# is not used by another installed package.
-# On systems with glibc-2.1 or newer, the file is redundant, therefore we
-# avoid installing it.
-
-all-local: charset.alias ref-add.sed ref-del.sed
-
-charset_alias = $(DESTDIR)$(libdir)/charset.alias
-charset_tmp = $(DESTDIR)$(libdir)/charset.tmp
-install-exec-local: install-exec-localcharset
-install-exec-localcharset: all-local
-	if test $(GLIBC21) = no; then \
-	  case '$(host_os)' in \
-	    darwin[56]*) \
-	      need_charset_alias=true ;; \
-	    darwin* | cygwin* | mingw* | pw32* | cegcc*) \
-	      need_charset_alias=false ;; \
-	    *) \
-	      need_charset_alias=true ;; \
-	  esac ; \
-	else \
-	  need_charset_alias=false ; \
-	fi ; \
-	if $$need_charset_alias; then \
-	  $(mkinstalldirs) $(DESTDIR)$(libdir) ; \
-	fi ; \
-	if test -f $(charset_alias); then \
-	  sed -f ref-add.sed $(charset_alias) > $(charset_tmp) ; \
-	  $(INSTALL_DATA) $(charset_tmp) $(charset_alias) ; \
-	  rm -f $(charset_tmp) ; \
-	else \
-	  if $$need_charset_alias; then \
-	    sed -f ref-add.sed charset.alias > $(charset_tmp) ; \
-	    $(INSTALL_DATA) $(charset_tmp) $(charset_alias) ; \
-	    rm -f $(charset_tmp) ; \
-	  fi ; \
-	fi
-
-uninstall-local: uninstall-localcharset
-uninstall-localcharset: all-local
-	if test -f $(charset_alias); then \
-	  sed -f ref-del.sed $(charset_alias) > $(charset_tmp); \
-	  if grep '^# Packages using this file: $$' $(charset_tmp) \
-	      > /dev/null; then \
-	    rm -f $(charset_alias); \
-	  else \
-	    $(INSTALL_DATA) $(charset_tmp) $(charset_alias); \
-	  fi; \
-	  rm -f $(charset_tmp); \
-	fi
-
-charset.alias: config.charset
-	$(AM_V_GEN)rm -f t-$@ $@ && \
-	$(SHELL) $(srcdir)/config.charset '$(host)' > t-$@ && \
-	mv t-$@ $@
-
-SUFFIXES += .sed .sin
-.sin.sed:
-	$(AM_V_GEN)rm -f t-$@ $@ && \
-	sed -e '/^#/d' -e 's/@''PACKAGE''@/$(PACKAGE)/g' $< > t-$@ && \
-	mv t-$@ $@
-
-CLEANFILES += charset.alias ref-add.sed ref-del.sed
-
-EXTRA_DIST += config.charset ref-add.sin ref-del.sin
-
-## end   gnulib module localcharset
-
-## begin gnulib module lseek
-
-
-EXTRA_DIST += lseek.c
-
-EXTRA_libgnu_la_SOURCES += lseek.c
-
-## end   gnulib module lseek
-
-## begin gnulib module lstat
-
-
-EXTRA_DIST += lstat.c
-
-EXTRA_libgnu_la_SOURCES += lstat.c
-
-## end   gnulib module lstat
-
-## begin gnulib module malloc-gnu
-
-
-EXTRA_DIST += malloc.c
-
-EXTRA_libgnu_la_SOURCES += malloc.c
-
-## end   gnulib module malloc-gnu
-
-## begin gnulib module malloc-posix
-
-
-EXTRA_DIST += malloc.c
-
-EXTRA_libgnu_la_SOURCES += malloc.c
-
-## end   gnulib module malloc-posix
-
-## begin gnulib module malloca
-
-libgnu_la_SOURCES += malloca.c
-
-EXTRA_DIST += malloca.h malloca.valgrind
-
-## end   gnulib module malloca
-
-## begin gnulib module math
-
-BUILT_SOURCES += math.h
-
-# We need the following in order to create <math.h> when the system
-# doesn't have one that works with the given compiler.
-math.h: math.in.h $(top_builddir)/config.status $(CXXDEFS_H) $(ARG_NONNULL_H) $(WARN_ON_USE_H)
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */' && \
-	  sed -e 's|@''GUARD_PREFIX''@|GL|g' \
-	      -e 's|@''INCLUDE_NEXT_AS_FIRST_DIRECTIVE''@|$(INCLUDE_NEXT_AS_FIRST_DIRECTIVE)|g' \
-	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
-	      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \
-	      -e 's|@''NEXT_AS_FIRST_DIRECTIVE_MATH_H''@|$(NEXT_AS_FIRST_DIRECTIVE_MATH_H)|g' \
-	      -e 's/@''GNULIB_ACOSF''@/$(GNULIB_ACOSF)/g' \
-	      -e 's/@''GNULIB_ACOSL''@/$(GNULIB_ACOSL)/g' \
-	      -e 's/@''GNULIB_ASINF''@/$(GNULIB_ASINF)/g' \
-	      -e 's/@''GNULIB_ASINL''@/$(GNULIB_ASINL)/g' \
-	      -e 's/@''GNULIB_ATANF''@/$(GNULIB_ATANF)/g' \
-	      -e 's/@''GNULIB_ATANL''@/$(GNULIB_ATANL)/g' \
-	      -e 's/@''GNULIB_ATAN2F''@/$(GNULIB_ATAN2F)/g' \
-	      -e 's/@''GNULIB_CBRT''@/$(GNULIB_CBRT)/g' \
-	      -e 's/@''GNULIB_CBRTF''@/$(GNULIB_CBRTF)/g' \
-	      -e 's/@''GNULIB_CBRTL''@/$(GNULIB_CBRTL)/g' \
-	      -e 's/@''GNULIB_CEIL''@/$(GNULIB_CEIL)/g' \
-	      -e 's/@''GNULIB_CEILF''@/$(GNULIB_CEILF)/g' \
-	      -e 's/@''GNULIB_CEILL''@/$(GNULIB_CEILL)/g' \
-	      -e 's/@''GNULIB_COPYSIGN''@/$(GNULIB_COPYSIGN)/g' \
-	      -e 's/@''GNULIB_COPYSIGNF''@/$(GNULIB_COPYSIGNF)/g' \
-	      -e 's/@''GNULIB_COPYSIGNL''@/$(GNULIB_COPYSIGNL)/g' \
-	      -e 's/@''GNULIB_COSF''@/$(GNULIB_COSF)/g' \
-	      -e 's/@''GNULIB_COSL''@/$(GNULIB_COSL)/g' \
-	      -e 's/@''GNULIB_COSHF''@/$(GNULIB_COSHF)/g' \
-	      -e 's/@''GNULIB_EXPF''@/$(GNULIB_EXPF)/g' \
-	      -e 's/@''GNULIB_EXPL''@/$(GNULIB_EXPL)/g' \
-	      -e 's/@''GNULIB_EXP2''@/$(GNULIB_EXP2)/g' \
-	      -e 's/@''GNULIB_EXP2F''@/$(GNULIB_EXP2F)/g' \
-	      -e 's/@''GNULIB_EXP2L''@/$(GNULIB_EXP2L)/g' \
-	      -e 's/@''GNULIB_EXPM1''@/$(GNULIB_EXPM1)/g' \
-	      -e 's/@''GNULIB_EXPM1F''@/$(GNULIB_EXPM1F)/g' \
-	      -e 's/@''GNULIB_EXPM1L''@/$(GNULIB_EXPM1L)/g' \
-	      -e 's/@''GNULIB_FABSF''@/$(GNULIB_FABSF)/g' \
-	      -e 's/@''GNULIB_FABSL''@/$(GNULIB_FABSL)/g' \
-	      -e 's/@''GNULIB_FLOOR''@/$(GNULIB_FLOOR)/g' \
-	      -e 's/@''GNULIB_FLOORF''@/$(GNULIB_FLOORF)/g' \
-	      -e 's/@''GNULIB_FLOORL''@/$(GNULIB_FLOORL)/g' \
-	      -e 's/@''GNULIB_FMA''@/$(GNULIB_FMA)/g' \
-	      -e 's/@''GNULIB_FMAF''@/$(GNULIB_FMAF)/g' \
-	      -e 's/@''GNULIB_FMAL''@/$(GNULIB_FMAL)/g' \
-	      -e 's/@''GNULIB_FMOD''@/$(GNULIB_FMOD)/g' \
-	      -e 's/@''GNULIB_FMODF''@/$(GNULIB_FMODF)/g' \
-	      -e 's/@''GNULIB_FMODL''@/$(GNULIB_FMODL)/g' \
-	      -e 's/@''GNULIB_FREXPF''@/$(GNULIB_FREXPF)/g' \
-	      -e 's/@''GNULIB_FREXP''@/$(GNULIB_FREXP)/g' \
-	      -e 's/@''GNULIB_FREXPL''@/$(GNULIB_FREXPL)/g' \
-	      -e 's/@''GNULIB_HYPOT''@/$(GNULIB_HYPOT)/g' \
-	      -e 's/@''GNULIB_HYPOTF''@/$(GNULIB_HYPOTF)/g' \
-	      -e 's/@''GNULIB_HYPOTL''@/$(GNULIB_HYPOTL)/g' \
-	      < $(srcdir)/math.in.h | \
-	  sed -e 's/@''GNULIB_ILOGB''@/$(GNULIB_ILOGB)/g' \
-	      -e 's/@''GNULIB_ILOGBF''@/$(GNULIB_ILOGBF)/g' \
-	      -e 's/@''GNULIB_ILOGBL''@/$(GNULIB_ILOGBL)/g' \
-	      -e 's/@''GNULIB_ISFINITE''@/$(GNULIB_ISFINITE)/g' \
-	      -e 's/@''GNULIB_ISINF''@/$(GNULIB_ISINF)/g' \
-	      -e 's/@''GNULIB_ISNAN''@/$(GNULIB_ISNAN)/g' \
-	      -e 's/@''GNULIB_ISNANF''@/$(GNULIB_ISNANF)/g' \
-	      -e 's/@''GNULIB_ISNAND''@/$(GNULIB_ISNAND)/g' \
-	      -e 's/@''GNULIB_ISNANL''@/$(GNULIB_ISNANL)/g' \
-	      -e 's/@''GNULIB_LDEXPF''@/$(GNULIB_LDEXPF)/g' \
-	      -e 's/@''GNULIB_LDEXPL''@/$(GNULIB_LDEXPL)/g' \
-	      -e 's/@''GNULIB_LOG''@/$(GNULIB_LOG)/g' \
-	      -e 's/@''GNULIB_LOGF''@/$(GNULIB_LOGF)/g' \
-	      -e 's/@''GNULIB_LOGL''@/$(GNULIB_LOGL)/g' \
-	      -e 's/@''GNULIB_LOG10''@/$(GNULIB_LOG10)/g' \
-	      -e 's/@''GNULIB_LOG10F''@/$(GNULIB_LOG10F)/g' \
-	      -e 's/@''GNULIB_LOG10L''@/$(GNULIB_LOG10L)/g' \
-	      -e 's/@''GNULIB_LOG1P''@/$(GNULIB_LOG1P)/g' \
-	      -e 's/@''GNULIB_LOG1PF''@/$(GNULIB_LOG1PF)/g' \
-	      -e 's/@''GNULIB_LOG1PL''@/$(GNULIB_LOG1PL)/g' \
-	      -e 's/@''GNULIB_LOG2''@/$(GNULIB_LOG2)/g' \
-	      -e 's/@''GNULIB_LOG2F''@/$(GNULIB_LOG2F)/g' \
-	      -e 's/@''GNULIB_LOG2L''@/$(GNULIB_LOG2L)/g' \
-	      -e 's/@''GNULIB_LOGB''@/$(GNULIB_LOGB)/g' \
-	      -e 's/@''GNULIB_LOGBF''@/$(GNULIB_LOGBF)/g' \
-	      -e 's/@''GNULIB_LOGBL''@/$(GNULIB_LOGBL)/g' \
-	      -e 's/@''GNULIB_MODF''@/$(GNULIB_MODF)/g' \
-	      -e 's/@''GNULIB_MODFF''@/$(GNULIB_MODFF)/g' \
-	      -e 's/@''GNULIB_MODFL''@/$(GNULIB_MODFL)/g' \
-	      -e 's/@''GNULIB_POWF''@/$(GNULIB_POWF)/g' \
-	      -e 's/@''GNULIB_REMAINDER''@/$(GNULIB_REMAINDER)/g' \
-	      -e 's/@''GNULIB_REMAINDERF''@/$(GNULIB_REMAINDERF)/g' \
-	      -e 's/@''GNULIB_REMAINDERL''@/$(GNULIB_REMAINDERL)/g' \
-	      -e 's/@''GNULIB_RINT''@/$(GNULIB_RINT)/g' \
-	      -e 's/@''GNULIB_RINTF''@/$(GNULIB_RINTF)/g' \
-	      -e 's/@''GNULIB_RINTL''@/$(GNULIB_RINTL)/g' \
-	      -e 's/@''GNULIB_ROUND''@/$(GNULIB_ROUND)/g' \
-	      -e 's/@''GNULIB_ROUNDF''@/$(GNULIB_ROUNDF)/g' \
-	      -e 's/@''GNULIB_ROUNDL''@/$(GNULIB_ROUNDL)/g' \
-	      -e 's/@''GNULIB_SIGNBIT''@/$(GNULIB_SIGNBIT)/g' \
-	      -e 's/@''GNULIB_SINF''@/$(GNULIB_SINF)/g' \
-	      -e 's/@''GNULIB_SINL''@/$(GNULIB_SINL)/g' \
-	      -e 's/@''GNULIB_SINHF''@/$(GNULIB_SINHF)/g' \
-	      -e 's/@''GNULIB_SQRTF''@/$(GNULIB_SQRTF)/g' \
-	      -e 's/@''GNULIB_SQRTL''@/$(GNULIB_SQRTL)/g' \
-	      -e 's/@''GNULIB_TANF''@/$(GNULIB_TANF)/g' \
-	      -e 's/@''GNULIB_TANL''@/$(GNULIB_TANL)/g' \
-	      -e 's/@''GNULIB_TANHF''@/$(GNULIB_TANHF)/g' \
-	      -e 's/@''GNULIB_TRUNC''@/$(GNULIB_TRUNC)/g' \
-	      -e 's/@''GNULIB_TRUNCF''@/$(GNULIB_TRUNCF)/g' \
-	      -e 's/@''GNULIB_TRUNCL''@/$(GNULIB_TRUNCL)/g' \
-	  | \
-	  sed -e 's|@''HAVE_ACOSF''@|$(HAVE_ACOSF)|g' \
-	      -e 's|@''HAVE_ACOSL''@|$(HAVE_ACOSL)|g' \
-	      -e 's|@''HAVE_ASINF''@|$(HAVE_ASINF)|g' \
-	      -e 's|@''HAVE_ASINL''@|$(HAVE_ASINL)|g' \
-	      -e 's|@''HAVE_ATANF''@|$(HAVE_ATANF)|g' \
-	      -e 's|@''HAVE_ATANL''@|$(HAVE_ATANL)|g' \
-	      -e 's|@''HAVE_ATAN2F''@|$(HAVE_ATAN2F)|g' \
-	      -e 's|@''HAVE_CBRT''@|$(HAVE_CBRT)|g' \
-	      -e 's|@''HAVE_CBRTF''@|$(HAVE_CBRTF)|g' \
-	      -e 's|@''HAVE_CBRTL''@|$(HAVE_CBRTL)|g' \
-	      -e 's|@''HAVE_COPYSIGN''@|$(HAVE_COPYSIGN)|g' \
-	      -e 's|@''HAVE_COPYSIGNL''@|$(HAVE_COPYSIGNL)|g' \
-	      -e 's|@''HAVE_COSF''@|$(HAVE_COSF)|g' \
-	      -e 's|@''HAVE_COSL''@|$(HAVE_COSL)|g' \
-	      -e 's|@''HAVE_COSHF''@|$(HAVE_COSHF)|g' \
-	      -e 's|@''HAVE_EXPF''@|$(HAVE_EXPF)|g' \
-	      -e 's|@''HAVE_EXPL''@|$(HAVE_EXPL)|g' \
-	      -e 's|@''HAVE_EXPM1''@|$(HAVE_EXPM1)|g' \
-	      -e 's|@''HAVE_EXPM1F''@|$(HAVE_EXPM1F)|g' \
-	      -e 's|@''HAVE_FABSF''@|$(HAVE_FABSF)|g' \
-	      -e 's|@''HAVE_FABSL''@|$(HAVE_FABSL)|g' \
-	      -e 's|@''HAVE_FMA''@|$(HAVE_FMA)|g' \
-	      -e 's|@''HAVE_FMAF''@|$(HAVE_FMAF)|g' \
-	      -e 's|@''HAVE_FMAL''@|$(HAVE_FMAL)|g' \
-	      -e 's|@''HAVE_FMODF''@|$(HAVE_FMODF)|g' \
-	      -e 's|@''HAVE_FMODL''@|$(HAVE_FMODL)|g' \
-	      -e 's|@''HAVE_FREXPF''@|$(HAVE_FREXPF)|g' \
-	      -e 's|@''HAVE_HYPOTF''@|$(HAVE_HYPOTF)|g' \
-	      -e 's|@''HAVE_HYPOTL''@|$(HAVE_HYPOTL)|g' \
-	      -e 's|@''HAVE_ILOGB''@|$(HAVE_ILOGB)|g' \
-	      -e 's|@''HAVE_ILOGBF''@|$(HAVE_ILOGBF)|g' \
-	      -e 's|@''HAVE_ILOGBL''@|$(HAVE_ILOGBL)|g' \
-	      -e 's|@''HAVE_ISNANF''@|$(HAVE_ISNANF)|g' \
-	      -e 's|@''HAVE_ISNAND''@|$(HAVE_ISNAND)|g' \
-	      -e 's|@''HAVE_ISNANL''@|$(HAVE_ISNANL)|g' \
-	      -e 's|@''HAVE_LDEXPF''@|$(HAVE_LDEXPF)|g' \
-	      -e 's|@''HAVE_LOGF''@|$(HAVE_LOGF)|g' \
-	      -e 's|@''HAVE_LOGL''@|$(HAVE_LOGL)|g' \
-	      -e 's|@''HAVE_LOG10F''@|$(HAVE_LOG10F)|g' \
-	      -e 's|@''HAVE_LOG10L''@|$(HAVE_LOG10L)|g' \
-	      -e 's|@''HAVE_LOG1P''@|$(HAVE_LOG1P)|g' \
-	      -e 's|@''HAVE_LOG1PF''@|$(HAVE_LOG1PF)|g' \
-	      -e 's|@''HAVE_LOG1PL''@|$(HAVE_LOG1PL)|g' \
-	      -e 's|@''HAVE_LOGBF''@|$(HAVE_LOGBF)|g' \
-	      -e 's|@''HAVE_LOGBL''@|$(HAVE_LOGBL)|g' \
-	      -e 's|@''HAVE_MODFF''@|$(HAVE_MODFF)|g' \
-	      -e 's|@''HAVE_MODFL''@|$(HAVE_MODFL)|g' \
-	      -e 's|@''HAVE_POWF''@|$(HAVE_POWF)|g' \
-	      -e 's|@''HAVE_REMAINDER''@|$(HAVE_REMAINDER)|g' \
-	      -e 's|@''HAVE_REMAINDERF''@|$(HAVE_REMAINDERF)|g' \
-	      -e 's|@''HAVE_RINT''@|$(HAVE_RINT)|g' \
-	      -e 's|@''HAVE_RINTL''@|$(HAVE_RINTL)|g' \
-	      -e 's|@''HAVE_SINF''@|$(HAVE_SINF)|g' \
-	      -e 's|@''HAVE_SINL''@|$(HAVE_SINL)|g' \
-	      -e 's|@''HAVE_SINHF''@|$(HAVE_SINHF)|g' \
-	      -e 's|@''HAVE_SQRTF''@|$(HAVE_SQRTF)|g' \
-	      -e 's|@''HAVE_SQRTL''@|$(HAVE_SQRTL)|g' \
-	      -e 's|@''HAVE_TANF''@|$(HAVE_TANF)|g' \
-	      -e 's|@''HAVE_TANL''@|$(HAVE_TANL)|g' \
-	      -e 's|@''HAVE_TANHF''@|$(HAVE_TANHF)|g' \
-	      -e 's|@''HAVE_DECL_ACOSL''@|$(HAVE_DECL_ACOSL)|g' \
-	      -e 's|@''HAVE_DECL_ASINL''@|$(HAVE_DECL_ASINL)|g' \
-	      -e 's|@''HAVE_DECL_ATANL''@|$(HAVE_DECL_ATANL)|g' \
-	      -e 's|@''HAVE_DECL_CBRTF''@|$(HAVE_DECL_CBRTF)|g' \
-	      -e 's|@''HAVE_DECL_CBRTL''@|$(HAVE_DECL_CBRTL)|g' \
-	      -e 's|@''HAVE_DECL_CEILF''@|$(HAVE_DECL_CEILF)|g' \
-	      -e 's|@''HAVE_DECL_CEILL''@|$(HAVE_DECL_CEILL)|g' \
-	      -e 's|@''HAVE_DECL_COPYSIGNF''@|$(HAVE_DECL_COPYSIGNF)|g' \
-	      -e 's|@''HAVE_DECL_COSL''@|$(HAVE_DECL_COSL)|g' \
-	      -e 's|@''HAVE_DECL_EXPL''@|$(HAVE_DECL_EXPL)|g' \
-	      -e 's|@''HAVE_DECL_EXP2''@|$(HAVE_DECL_EXP2)|g' \
-	      -e 's|@''HAVE_DECL_EXP2F''@|$(HAVE_DECL_EXP2F)|g' \
-	      -e 's|@''HAVE_DECL_EXP2L''@|$(HAVE_DECL_EXP2L)|g' \
-	      -e 's|@''HAVE_DECL_EXPM1L''@|$(HAVE_DECL_EXPM1L)|g' \
-	      -e 's|@''HAVE_DECL_FLOORF''@|$(HAVE_DECL_FLOORF)|g' \
-	      -e 's|@''HAVE_DECL_FLOORL''@|$(HAVE_DECL_FLOORL)|g' \
-	      -e 's|@''HAVE_DECL_FREXPL''@|$(HAVE_DECL_FREXPL)|g' \
-	      -e 's|@''HAVE_DECL_LDEXPL''@|$(HAVE_DECL_LDEXPL)|g' \
-	      -e 's|@''HAVE_DECL_LOGL''@|$(HAVE_DECL_LOGL)|g' \
-	      -e 's|@''HAVE_DECL_LOG10L''@|$(HAVE_DECL_LOG10L)|g' \
-	      -e 's|@''HAVE_DECL_LOG2''@|$(HAVE_DECL_LOG2)|g' \
-	      -e 's|@''HAVE_DECL_LOG2F''@|$(HAVE_DECL_LOG2F)|g' \
-	      -e 's|@''HAVE_DECL_LOG2L''@|$(HAVE_DECL_LOG2L)|g' \
-	      -e 's|@''HAVE_DECL_LOGB''@|$(HAVE_DECL_LOGB)|g' \
-	      -e 's|@''HAVE_DECL_REMAINDER''@|$(HAVE_DECL_REMAINDER)|g' \
-	      -e 's|@''HAVE_DECL_REMAINDERL''@|$(HAVE_DECL_REMAINDERL)|g' \
-	      -e 's|@''HAVE_DECL_RINTF''@|$(HAVE_DECL_RINTF)|g' \
-	      -e 's|@''HAVE_DECL_ROUND''@|$(HAVE_DECL_ROUND)|g' \
-	      -e 's|@''HAVE_DECL_ROUNDF''@|$(HAVE_DECL_ROUNDF)|g' \
-	      -e 's|@''HAVE_DECL_ROUNDL''@|$(HAVE_DECL_ROUNDL)|g' \
-	      -e 's|@''HAVE_DECL_SINL''@|$(HAVE_DECL_SINL)|g' \
-	      -e 's|@''HAVE_DECL_SQRTL''@|$(HAVE_DECL_SQRTL)|g' \
-	      -e 's|@''HAVE_DECL_TANL''@|$(HAVE_DECL_TANL)|g' \
-	      -e 's|@''HAVE_DECL_TRUNC''@|$(HAVE_DECL_TRUNC)|g' \
-	      -e 's|@''HAVE_DECL_TRUNCF''@|$(HAVE_DECL_TRUNCF)|g' \
-	      -e 's|@''HAVE_DECL_TRUNCL''@|$(HAVE_DECL_TRUNCL)|g' \
-	  | \
-	  sed -e 's|@''REPLACE_CBRTF''@|$(REPLACE_CBRTF)|g' \
-	      -e 's|@''REPLACE_CBRTL''@|$(REPLACE_CBRTL)|g' \
-	      -e 's|@''REPLACE_CEIL''@|$(REPLACE_CEIL)|g' \
-	      -e 's|@''REPLACE_CEILF''@|$(REPLACE_CEILF)|g' \
-	      -e 's|@''REPLACE_CEILL''@|$(REPLACE_CEILL)|g' \
-	      -e 's|@''REPLACE_EXPM1''@|$(REPLACE_EXPM1)|g' \
-	      -e 's|@''REPLACE_EXPM1F''@|$(REPLACE_EXPM1F)|g' \
-	      -e 's|@''REPLACE_EXP2''@|$(REPLACE_EXP2)|g' \
-	      -e 's|@''REPLACE_EXP2L''@|$(REPLACE_EXP2L)|g' \
-	      -e 's|@''REPLACE_FABSL''@|$(REPLACE_FABSL)|g' \
-	      -e 's|@''REPLACE_FLOOR''@|$(REPLACE_FLOOR)|g' \
-	      -e 's|@''REPLACE_FLOORF''@|$(REPLACE_FLOORF)|g' \
-	      -e 's|@''REPLACE_FLOORL''@|$(REPLACE_FLOORL)|g' \
-	      -e 's|@''REPLACE_FMA''@|$(REPLACE_FMA)|g' \
-	      -e 's|@''REPLACE_FMAF''@|$(REPLACE_FMAF)|g' \
-	      -e 's|@''REPLACE_FMAL''@|$(REPLACE_FMAL)|g' \
-	      -e 's|@''REPLACE_FMOD''@|$(REPLACE_FMOD)|g' \
-	      -e 's|@''REPLACE_FMODF''@|$(REPLACE_FMODF)|g' \
-	      -e 's|@''REPLACE_FMODL''@|$(REPLACE_FMODL)|g' \
-	      -e 's|@''REPLACE_FREXPF''@|$(REPLACE_FREXPF)|g' \
-	      -e 's|@''REPLACE_FREXP''@|$(REPLACE_FREXP)|g' \
-	      -e 's|@''REPLACE_FREXPL''@|$(REPLACE_FREXPL)|g' \
-	      -e 's|@''REPLACE_HUGE_VAL''@|$(REPLACE_HUGE_VAL)|g' \
-	      -e 's|@''REPLACE_HYPOT''@|$(REPLACE_HYPOT)|g' \
-	      -e 's|@''REPLACE_HYPOTF''@|$(REPLACE_HYPOTF)|g' \
-	      -e 's|@''REPLACE_HYPOTL''@|$(REPLACE_HYPOTL)|g' \
-	      -e 's|@''REPLACE_ILOGB''@|$(REPLACE_ILOGB)|g' \
-	      -e 's|@''REPLACE_ILOGBF''@|$(REPLACE_ILOGBF)|g' \
-	      -e 's|@''REPLACE_ISFINITE''@|$(REPLACE_ISFINITE)|g' \
-	      -e 's|@''REPLACE_ISINF''@|$(REPLACE_ISINF)|g' \
-	      -e 's|@''REPLACE_ISNAN''@|$(REPLACE_ISNAN)|g' \
-	      -e 's|@''REPLACE_ITOLD''@|$(REPLACE_ITOLD)|g' \
-	      -e 's|@''REPLACE_LDEXPL''@|$(REPLACE_LDEXPL)|g' \
-	      -e 's|@''REPLACE_LOG''@|$(REPLACE_LOG)|g' \
-	      -e 's|@''REPLACE_LOGF''@|$(REPLACE_LOGF)|g' \
-	      -e 's|@''REPLACE_LOGL''@|$(REPLACE_LOGL)|g' \
-	      -e 's|@''REPLACE_LOG10''@|$(REPLACE_LOG10)|g' \
-	      -e 's|@''REPLACE_LOG10F''@|$(REPLACE_LOG10F)|g' \
-	      -e 's|@''REPLACE_LOG10L''@|$(REPLACE_LOG10L)|g' \
-	      -e 's|@''REPLACE_LOG1P''@|$(REPLACE_LOG1P)|g' \
-	      -e 's|@''REPLACE_LOG1PF''@|$(REPLACE_LOG1PF)|g' \
-	      -e 's|@''REPLACE_LOG1PL''@|$(REPLACE_LOG1PL)|g' \
-	      -e 's|@''REPLACE_LOG2''@|$(REPLACE_LOG2)|g' \
-	      -e 's|@''REPLACE_LOG2F''@|$(REPLACE_LOG2F)|g' \
-	      -e 's|@''REPLACE_LOG2L''@|$(REPLACE_LOG2L)|g' \
-	      -e 's|@''REPLACE_LOGB''@|$(REPLACE_LOGB)|g' \
-	      -e 's|@''REPLACE_LOGBF''@|$(REPLACE_LOGBF)|g' \
-	      -e 's|@''REPLACE_LOGBL''@|$(REPLACE_LOGBL)|g' \
-	      -e 's|@''REPLACE_MODF''@|$(REPLACE_MODF)|g' \
-	      -e 's|@''REPLACE_MODFF''@|$(REPLACE_MODFF)|g' \
-	      -e 's|@''REPLACE_MODFL''@|$(REPLACE_MODFL)|g' \
-	      -e 's|@''REPLACE_NAN''@|$(REPLACE_NAN)|g' \
-	      -e 's|@''REPLACE_REMAINDER''@|$(REPLACE_REMAINDER)|g' \
-	      -e 's|@''REPLACE_REMAINDERF''@|$(REPLACE_REMAINDERF)|g' \
-	      -e 's|@''REPLACE_REMAINDERL''@|$(REPLACE_REMAINDERL)|g' \
-	      -e 's|@''REPLACE_ROUND''@|$(REPLACE_ROUND)|g' \
-	      -e 's|@''REPLACE_ROUNDF''@|$(REPLACE_ROUNDF)|g' \
-	      -e 's|@''REPLACE_ROUNDL''@|$(REPLACE_ROUNDL)|g' \
-	      -e 's|@''REPLACE_SIGNBIT''@|$(REPLACE_SIGNBIT)|g' \
-	      -e 's|@''REPLACE_SIGNBIT_USING_GCC''@|$(REPLACE_SIGNBIT_USING_GCC)|g' \
-	      -e 's|@''REPLACE_SQRTL''@|$(REPLACE_SQRTL)|g' \
-	      -e 's|@''REPLACE_TRUNC''@|$(REPLACE_TRUNC)|g' \
-	      -e 's|@''REPLACE_TRUNCF''@|$(REPLACE_TRUNCF)|g' \
-	      -e 's|@''REPLACE_TRUNCL''@|$(REPLACE_TRUNCL)|g' \
-	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
-	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
-	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)'; \
-	} > $@-t && \
-	mv $@-t $@
-MOSTLYCLEANFILES += math.h math.h-t
-
-EXTRA_DIST += math.in.h
-
-## end   gnulib module math
-
-## begin gnulib module mbrtowc
-
-
-EXTRA_DIST += mbrtowc.c
-
-EXTRA_libgnu_la_SOURCES += mbrtowc.c
-
-## end   gnulib module mbrtowc
-
-## begin gnulib module mbsinit
-
-
-EXTRA_DIST += mbsinit.c
-
-EXTRA_libgnu_la_SOURCES += mbsinit.c
-
-## end   gnulib module mbsinit
-
-## begin gnulib module mbsrtowcs
-
-
-EXTRA_DIST += mbsrtowcs-impl.h mbsrtowcs-state.c mbsrtowcs.c
-
-EXTRA_libgnu_la_SOURCES += mbsrtowcs-state.c mbsrtowcs.c
-
-## end   gnulib module mbsrtowcs
-
-## begin gnulib module memchr
-
-
-EXTRA_DIST += memchr.c memchr.valgrind
-
-EXTRA_libgnu_la_SOURCES += memchr.c
-
-## end   gnulib module memchr
-
-## begin gnulib module mempcpy
-
-
-EXTRA_DIST += mempcpy.c
-
-EXTRA_libgnu_la_SOURCES += mempcpy.c
-
-## end   gnulib module mempcpy
-
-## begin gnulib module memrchr
-
-
-EXTRA_DIST += memrchr.c
-
-EXTRA_libgnu_la_SOURCES += memrchr.c
-
-## end   gnulib module memrchr
-
-## begin gnulib module mkdir
-
-
-EXTRA_DIST += mkdir.c
-
-EXTRA_libgnu_la_SOURCES += mkdir.c
-
-## end   gnulib module mkdir
-
-## begin gnulib module mkfifo
-
-
-EXTRA_DIST += mkfifo.c
-
-EXTRA_libgnu_la_SOURCES += mkfifo.c
-
-## end   gnulib module mkfifo
-
-## begin gnulib module mkostemp
-
-
-EXTRA_DIST += mkostemp.c
-
-EXTRA_libgnu_la_SOURCES += mkostemp.c
-
-## end   gnulib module mkostemp
-
-## begin gnulib module mktime
-
-
-EXTRA_DIST += mktime-internal.h mktime.c
-
-EXTRA_libgnu_la_SOURCES += mktime.c
-
-## end   gnulib module mktime
-
-## begin gnulib module msvc-inval
-
-
-EXTRA_DIST += msvc-inval.c msvc-inval.h
-
-EXTRA_libgnu_la_SOURCES += msvc-inval.c
-
-## end   gnulib module msvc-inval
-
-## begin gnulib module msvc-nothrow
-
-
-EXTRA_DIST += msvc-nothrow.c msvc-nothrow.h
-
-EXTRA_libgnu_la_SOURCES += msvc-nothrow.c
-
-## end   gnulib module msvc-nothrow
-
-## begin gnulib module nanosleep
-
-
-EXTRA_DIST += nanosleep.c
-
-EXTRA_libgnu_la_SOURCES += nanosleep.c
-
-## end   gnulib module nanosleep
-
-## begin gnulib module nproc
-
-libgnu_la_SOURCES += nproc.c
-
-EXTRA_DIST += nproc.h
-
-## end   gnulib module nproc
-
-## begin gnulib module open
-
-
-EXTRA_DIST += open.c
-
-EXTRA_libgnu_la_SOURCES += open.c
-
-## end   gnulib module open
-
-## begin gnulib module openat
-
-
-EXTRA_DIST += openat-priv.h openat.c
-
-EXTRA_libgnu_la_SOURCES += openat.c
-
-## end   gnulib module openat
-
-## begin gnulib module openat-die
-
-libgnu_la_SOURCES += openat-die.c
-
-## end   gnulib module openat-die
-
-## begin gnulib module openat-h
-
-
-EXTRA_DIST += openat.h
-
-## end   gnulib module openat-h
-
-## begin gnulib module opendir
-
-
-EXTRA_DIST += dirent-private.h opendir.c
-
-EXTRA_libgnu_la_SOURCES += opendir.c
-
-## end   gnulib module opendir
-
-## begin gnulib module pathmax
-
-
-EXTRA_DIST += pathmax.h
-
-## end   gnulib module pathmax
-
-## begin gnulib module progname
-
-libgnu_la_SOURCES += progname.h progname.c
-
-## end   gnulib module progname
-
-## begin gnulib module putenv
-
-
-EXTRA_DIST += putenv.c
-
-EXTRA_libgnu_la_SOURCES += putenv.c
-
-## end   gnulib module putenv
-
-## begin gnulib module raise
-
-
-EXTRA_DIST += raise.c
-
-EXTRA_libgnu_la_SOURCES += raise.c
-
-## end   gnulib module raise
-
-## begin gnulib module readdir
-
-
-EXTRA_DIST += dirent-private.h readdir.c
-
-EXTRA_libgnu_la_SOURCES += readdir.c
-
-## end   gnulib module readdir
-
-## begin gnulib module readlink
-
-
-EXTRA_DIST += readlink.c
-
-EXTRA_libgnu_la_SOURCES += readlink.c
-
-## end   gnulib module readlink
-
-## begin gnulib module realloc-gnu
-
-
-EXTRA_DIST += realloc.c
-
-EXTRA_libgnu_la_SOURCES += realloc.c
-
-## end   gnulib module realloc-gnu
-
-## begin gnulib module realloc-posix
-
-
-EXTRA_DIST += realloc.c
-
-EXTRA_libgnu_la_SOURCES += realloc.c
-
-## end   gnulib module realloc-posix
-
-## begin gnulib module rename
-
-
-EXTRA_DIST += rename.c
-
-EXTRA_libgnu_la_SOURCES += rename.c
-
-## end   gnulib module rename
-
-## begin gnulib module rewinddir
-
-
-EXTRA_DIST += dirent-private.h rewinddir.c
-
-EXTRA_libgnu_la_SOURCES += rewinddir.c
-
-## end   gnulib module rewinddir
-
-## begin gnulib module rmdir
-
-
-EXTRA_DIST += rmdir.c
-
-EXTRA_libgnu_la_SOURCES += rmdir.c
-
-## end   gnulib module rmdir
-
-## begin gnulib module round
-
-
-EXTRA_DIST += round.c
-
-EXTRA_libgnu_la_SOURCES += round.c
-
-## end   gnulib module round
-
-## begin gnulib module roundf
-
-
-EXTRA_DIST += round.c roundf.c
-
-EXTRA_libgnu_la_SOURCES += round.c roundf.c
-
-## end   gnulib module roundf
-
-## begin gnulib module same
-
-libgnu_la_SOURCES += same.c
-
-EXTRA_DIST += same.h
-
-## end   gnulib module same
-
-## begin gnulib module same-inode
-
-
-EXTRA_DIST += same-inode.h
-
-## end   gnulib module same-inode
-
-## begin gnulib module save-cwd
-
-libgnu_la_SOURCES += save-cwd.c
-
-EXTRA_DIST += save-cwd.h
-
-## end   gnulib module save-cwd
-
-## begin gnulib module select
-
-
-EXTRA_DIST += select.c
-
-EXTRA_libgnu_la_SOURCES += select.c
-
-## end   gnulib module select
-
-## begin gnulib module sigaction
-
-
-EXTRA_DIST += sig-handler.h sigaction.c
-
-EXTRA_libgnu_la_SOURCES += sigaction.c
-
-## end   gnulib module sigaction
-
-## begin gnulib module signal-h
-
-BUILT_SOURCES += signal.h
-
-# We need the following in order to create <signal.h> when the system
-# doesn't have a complete one.
-signal.h: signal.in.h $(top_builddir)/config.status $(CXXDEFS_H) $(ARG_NONNULL_H) $(WARN_ON_USE_H)
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */' && \
-	  sed -e 's|@''GUARD_PREFIX''@|GL|g' \
-	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
-	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
-	      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \
-	      -e 's|@''NEXT_SIGNAL_H''@|$(NEXT_SIGNAL_H)|g' \
-	      -e 's|@''GNULIB_PTHREAD_SIGMASK''@|$(GNULIB_PTHREAD_SIGMASK)|g' \
-	      -e 's|@''GNULIB_RAISE''@|$(GNULIB_RAISE)|g' \
-	      -e 's/@''GNULIB_SIGNAL_H_SIGPIPE''@/$(GNULIB_SIGNAL_H_SIGPIPE)/g' \
-	      -e 's/@''GNULIB_SIGPROCMASK''@/$(GNULIB_SIGPROCMASK)/g' \
-	      -e 's/@''GNULIB_SIGACTION''@/$(GNULIB_SIGACTION)/g' \
-	      -e 's|@''HAVE_POSIX_SIGNALBLOCKING''@|$(HAVE_POSIX_SIGNALBLOCKING)|g' \
-	      -e 's|@''HAVE_PTHREAD_SIGMASK''@|$(HAVE_PTHREAD_SIGMASK)|g' \
-	      -e 's|@''HAVE_RAISE''@|$(HAVE_RAISE)|g' \
-	      -e 's|@''HAVE_SIGSET_T''@|$(HAVE_SIGSET_T)|g' \
-	      -e 's|@''HAVE_SIGINFO_T''@|$(HAVE_SIGINFO_T)|g' \
-	      -e 's|@''HAVE_SIGACTION''@|$(HAVE_SIGACTION)|g' \
-	      -e 's|@''HAVE_STRUCT_SIGACTION_SA_SIGACTION''@|$(HAVE_STRUCT_SIGACTION_SA_SIGACTION)|g' \
-	      -e 's|@''HAVE_TYPE_VOLATILE_SIG_ATOMIC_T''@|$(HAVE_TYPE_VOLATILE_SIG_ATOMIC_T)|g' \
-	      -e 's|@''HAVE_SIGHANDLER_T''@|$(HAVE_SIGHANDLER_T)|g' \
-	      -e 's|@''REPLACE_PTHREAD_SIGMASK''@|$(REPLACE_PTHREAD_SIGMASK)|g' \
-	      -e 's|@''REPLACE_RAISE''@|$(REPLACE_RAISE)|g' \
-	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
-	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
-	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)' \
-	      < $(srcdir)/signal.in.h; \
-	} > $@-t && \
-	mv $@-t $@
-MOSTLYCLEANFILES += signal.h signal.h-t
-
-EXTRA_DIST += signal.in.h
-
-## end   gnulib module signal-h
-
-## begin gnulib module signbit
-
-
-EXTRA_DIST += float+.h signbitd.c signbitf.c signbitl.c
-
-EXTRA_libgnu_la_SOURCES += signbitd.c signbitf.c signbitl.c
-
-## end   gnulib module signbit
-
-## begin gnulib module sigprocmask
-
-
-EXTRA_DIST += sigprocmask.c
-
-EXTRA_libgnu_la_SOURCES += sigprocmask.c
-
-## end   gnulib module sigprocmask
-
-## begin gnulib module size_max
-
-libgnu_la_SOURCES += size_max.h
-
-## end   gnulib module size_max
-
-## begin gnulib module sleep
-
-
-EXTRA_DIST += sleep.c
-
-EXTRA_libgnu_la_SOURCES += sleep.c
-
-## end   gnulib module sleep
-
-## begin gnulib module snippet/_Noreturn
-
-# Because this Makefile snippet defines a variable used by other
-# gnulib Makefile snippets, it must be present in all Makefile.am that
-# need it. This is ensured by the applicability 'all' defined above.
-
-_NORETURN_H=$(top_srcdir)/build-aux/snippet/_Noreturn.h
-
-EXTRA_DIST += $(top_srcdir)/build-aux/snippet/_Noreturn.h
-
-## end   gnulib module snippet/_Noreturn
-
-## begin gnulib module snippet/arg-nonnull
-
-# The BUILT_SOURCES created by this Makefile snippet are not used via #include
-# statements but through direct file reference. Therefore this snippet must be
-# present in all Makefile.am that need it. This is ensured by the applicability
-# 'all' defined above.
-
-BUILT_SOURCES += arg-nonnull.h
-# The arg-nonnull.h that gets inserted into generated .h files is the same as
-# build-aux/snippet/arg-nonnull.h, except that it has the copyright header cut
-# off.
-arg-nonnull.h: $(top_srcdir)/build-aux/snippet/arg-nonnull.h
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	sed -n -e '/GL_ARG_NONNULL/,$$p' \
-	  < $(top_srcdir)/build-aux/snippet/arg-nonnull.h \
-	  > $@-t && \
-	mv $@-t $@
-MOSTLYCLEANFILES += arg-nonnull.h arg-nonnull.h-t
-
-ARG_NONNULL_H=arg-nonnull.h
-
-EXTRA_DIST += $(top_srcdir)/build-aux/snippet/arg-nonnull.h
-
-## end   gnulib module snippet/arg-nonnull
-
-## begin gnulib module snippet/c++defs
-
-# The BUILT_SOURCES created by this Makefile snippet are not used via #include
-# statements but through direct file reference. Therefore this snippet must be
-# present in all Makefile.am that need it. This is ensured by the applicability
-# 'all' defined above.
-
-BUILT_SOURCES += c++defs.h
-# The c++defs.h that gets inserted into generated .h files is the same as
-# build-aux/snippet/c++defs.h, except that it has the copyright header cut off.
-c++defs.h: $(top_srcdir)/build-aux/snippet/c++defs.h
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	sed -n -e '/_GL_CXXDEFS/,$$p' \
-	  < $(top_srcdir)/build-aux/snippet/c++defs.h \
-	  > $@-t && \
-	mv $@-t $@
-MOSTLYCLEANFILES += c++defs.h c++defs.h-t
-
-CXXDEFS_H=c++defs.h
-
-EXTRA_DIST += $(top_srcdir)/build-aux/snippet/c++defs.h
-
-## end   gnulib module snippet/c++defs
-
-## begin gnulib module snippet/unused-parameter
-
-# The BUILT_SOURCES created by this Makefile snippet are not used via #include
-# statements but through direct file reference. Therefore this snippet must be
-# present in all Makefile.am that need it. This is ensured by the applicability
-# 'all' defined above.
-
-BUILT_SOURCES += unused-parameter.h
-# The unused-parameter.h that gets inserted into generated .h files is the same
-# as build-aux/snippet/unused-parameter.h, except that it has the copyright
-# header cut off.
-unused-parameter.h: $(top_srcdir)/build-aux/snippet/unused-parameter.h
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	sed -n -e '/GL_UNUSED_PARAMETER/,$$p' \
-	  < $(top_srcdir)/build-aux/snippet/unused-parameter.h \
-	  > $@-t && \
-	mv $@-t $@
-MOSTLYCLEANFILES += unused-parameter.h unused-parameter.h-t
-
-UNUSED_PARAMETER_H=unused-parameter.h
-
-EXTRA_DIST += $(top_srcdir)/build-aux/snippet/unused-parameter.h
-
-## end   gnulib module snippet/unused-parameter
-
-## begin gnulib module snippet/warn-on-use
-
-BUILT_SOURCES += warn-on-use.h
-# The warn-on-use.h that gets inserted into generated .h files is the same as
-# build-aux/snippet/warn-on-use.h, except that it has the copyright header cut
-# off.
-warn-on-use.h: $(top_srcdir)/build-aux/snippet/warn-on-use.h
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	sed -n -e '/^.ifndef/,$$p' \
-	  < $(top_srcdir)/build-aux/snippet/warn-on-use.h \
-	  > $@-t && \
-	mv $@-t $@
-MOSTLYCLEANFILES += warn-on-use.h warn-on-use.h-t
-
-WARN_ON_USE_H=warn-on-use.h
-
-EXTRA_DIST += $(top_srcdir)/build-aux/snippet/warn-on-use.h
-
-## end   gnulib module snippet/warn-on-use
-
-## begin gnulib module sockets
-
-libgnu_la_SOURCES += sockets.h sockets.c
-
-EXTRA_DIST += w32sock.h
-
-## end   gnulib module sockets
-
-## begin gnulib module stat
-
-
-EXTRA_DIST += stat.c
-
-EXTRA_libgnu_la_SOURCES += stat.c
-
-## end   gnulib module stat
-
-## begin gnulib module stdalign
-
-BUILT_SOURCES += $(STDALIGN_H)
-
-# We need the following in order to create <stdalign.h> when the system
-# doesn't have one that works.
-if GL_GENERATE_STDALIGN_H
-stdalign.h: stdalign.in.h $(top_builddir)/config.status
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
-	  cat $(srcdir)/stdalign.in.h; \
-	} > $@-t && \
-	mv $@-t $@
-else
-stdalign.h: $(top_builddir)/config.status
-	rm -f $@
-endif
-MOSTLYCLEANFILES += stdalign.h stdalign.h-t
-
-EXTRA_DIST += stdalign.in.h
-
-## end   gnulib module stdalign
-
-## begin gnulib module stdbool
-
-BUILT_SOURCES += $(STDBOOL_H)
-
-# We need the following in order to create <stdbool.h> when the system
-# doesn't have one that works.
-if GL_GENERATE_STDBOOL_H
-stdbool.h: stdbool.in.h $(top_builddir)/config.status
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
-	  sed -e 's/@''HAVE__BOOL''@/$(HAVE__BOOL)/g' < $(srcdir)/stdbool.in.h; \
-	} > $@-t && \
-	mv $@-t $@
-else
-stdbool.h: $(top_builddir)/config.status
-	rm -f $@
-endif
-MOSTLYCLEANFILES += stdbool.h stdbool.h-t
-
-EXTRA_DIST += stdbool.in.h
-
-## end   gnulib module stdbool
-
-## begin gnulib module stddef
-
-BUILT_SOURCES += $(STDDEF_H)
-
-# We need the following in order to create <stddef.h> when the system
-# doesn't have one that works with the given compiler.
-if GL_GENERATE_STDDEF_H
-stddef.h: stddef.in.h $(top_builddir)/config.status
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */' && \
-	  sed -e 's|@''GUARD_PREFIX''@|GL|g' \
-	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
-	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
-	      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \
-	      -e 's|@''NEXT_STDDEF_H''@|$(NEXT_STDDEF_H)|g' \
-	      -e 's|@''HAVE_WCHAR_T''@|$(HAVE_WCHAR_T)|g' \
-	      -e 's|@''REPLACE_NULL''@|$(REPLACE_NULL)|g' \
-	      < $(srcdir)/stddef.in.h; \
-	} > $@-t && \
-	mv $@-t $@
-else
-stddef.h: $(top_builddir)/config.status
-	rm -f $@
-endif
-MOSTLYCLEANFILES += stddef.h stddef.h-t
-
-EXTRA_DIST += stddef.in.h
-
-## end   gnulib module stddef
-
-## begin gnulib module stdint
-
-BUILT_SOURCES += $(STDINT_H)
-
-# We need the following in order to create <stdint.h> when the system
-# doesn't have one that works with the given compiler.
-if GL_GENERATE_STDINT_H
-stdint.h: stdint.in.h $(top_builddir)/config.status
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
-	  sed -e 's|@''GUARD_PREFIX''@|GL|g' \
-	      -e 's/@''HAVE_STDINT_H''@/$(HAVE_STDINT_H)/g' \
-	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
-	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
-	      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \
-	      -e 's|@''NEXT_STDINT_H''@|$(NEXT_STDINT_H)|g' \
-	      -e 's/@''HAVE_SYS_TYPES_H''@/$(HAVE_SYS_TYPES_H)/g' \
-	      -e 's/@''HAVE_INTTYPES_H''@/$(HAVE_INTTYPES_H)/g' \
-	      -e 's/@''HAVE_SYS_INTTYPES_H''@/$(HAVE_SYS_INTTYPES_H)/g' \
-	      -e 's/@''HAVE_SYS_BITYPES_H''@/$(HAVE_SYS_BITYPES_H)/g' \
-	      -e 's/@''HAVE_WCHAR_H''@/$(HAVE_WCHAR_H)/g' \
-	      -e 's/@''HAVE_LONG_LONG_INT''@/$(HAVE_LONG_LONG_INT)/g' \
-	      -e 's/@''HAVE_UNSIGNED_LONG_LONG_INT''@/$(HAVE_UNSIGNED_LONG_LONG_INT)/g' \
-	      -e 's/@''APPLE_UNIVERSAL_BUILD''@/$(APPLE_UNIVERSAL_BUILD)/g' \
-	      -e 's/@''BITSIZEOF_PTRDIFF_T''@/$(BITSIZEOF_PTRDIFF_T)/g' \
-	      -e 's/@''PTRDIFF_T_SUFFIX''@/$(PTRDIFF_T_SUFFIX)/g' \
-	      -e 's/@''BITSIZEOF_SIG_ATOMIC_T''@/$(BITSIZEOF_SIG_ATOMIC_T)/g' \
-	      -e 's/@''HAVE_SIGNED_SIG_ATOMIC_T''@/$(HAVE_SIGNED_SIG_ATOMIC_T)/g' \
-	      -e 's/@''SIG_ATOMIC_T_SUFFIX''@/$(SIG_ATOMIC_T_SUFFIX)/g' \
-	      -e 's/@''BITSIZEOF_SIZE_T''@/$(BITSIZEOF_SIZE_T)/g' \
-	      -e 's/@''SIZE_T_SUFFIX''@/$(SIZE_T_SUFFIX)/g' \
-	      -e 's/@''BITSIZEOF_WCHAR_T''@/$(BITSIZEOF_WCHAR_T)/g' \
-	      -e 's/@''HAVE_SIGNED_WCHAR_T''@/$(HAVE_SIGNED_WCHAR_T)/g' \
-	      -e 's/@''WCHAR_T_SUFFIX''@/$(WCHAR_T_SUFFIX)/g' \
-	      -e 's/@''BITSIZEOF_WINT_T''@/$(BITSIZEOF_WINT_T)/g' \
-	      -e 's/@''HAVE_SIGNED_WINT_T''@/$(HAVE_SIGNED_WINT_T)/g' \
-	      -e 's/@''WINT_T_SUFFIX''@/$(WINT_T_SUFFIX)/g' \
-	      < $(srcdir)/stdint.in.h; \
-	} > $@-t && \
-	mv $@-t $@
-else
-stdint.h: $(top_builddir)/config.status
-	rm -f $@
-endif
-MOSTLYCLEANFILES += stdint.h stdint.h-t
-
-EXTRA_DIST += stdint.in.h
-
-## end   gnulib module stdint
-
-## begin gnulib module stdio
-
-BUILT_SOURCES += stdio.h
-
-# We need the following in order to create <stdio.h> when the system
-# doesn't have one that works with the given compiler.
-stdio.h: stdio.in.h $(top_builddir)/config.status $(CXXDEFS_H) $(ARG_NONNULL_H) $(WARN_ON_USE_H)
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */' && \
-	  sed -e 's|@''GUARD_PREFIX''@|GL|g' \
-	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
-	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
-	      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \
-	      -e 's|@''NEXT_STDIO_H''@|$(NEXT_STDIO_H)|g' \
-	      -e 's/@''GNULIB_DPRINTF''@/$(GNULIB_DPRINTF)/g' \
-	      -e 's/@''GNULIB_FCLOSE''@/$(GNULIB_FCLOSE)/g' \
-	      -e 's/@''GNULIB_FDOPEN''@/$(GNULIB_FDOPEN)/g' \
-	      -e 's/@''GNULIB_FFLUSH''@/$(GNULIB_FFLUSH)/g' \
-	      -e 's/@''GNULIB_FGETC''@/$(GNULIB_FGETC)/g' \
-	      -e 's/@''GNULIB_FGETS''@/$(GNULIB_FGETS)/g' \
-	      -e 's/@''GNULIB_FOPEN''@/$(GNULIB_FOPEN)/g' \
-	      -e 's/@''GNULIB_FPRINTF''@/$(GNULIB_FPRINTF)/g' \
-	      -e 's/@''GNULIB_FPRINTF_POSIX''@/$(GNULIB_FPRINTF_POSIX)/g' \
-	      -e 's/@''GNULIB_FPURGE''@/$(GNULIB_FPURGE)/g' \
-	      -e 's/@''GNULIB_FPUTC''@/$(GNULIB_FPUTC)/g' \
-	      -e 's/@''GNULIB_FPUTS''@/$(GNULIB_FPUTS)/g' \
-	      -e 's/@''GNULIB_FREAD''@/$(GNULIB_FREAD)/g' \
-	      -e 's/@''GNULIB_FREOPEN''@/$(GNULIB_FREOPEN)/g' \
-	      -e 's/@''GNULIB_FSCANF''@/$(GNULIB_FSCANF)/g' \
-	      -e 's/@''GNULIB_FSEEK''@/$(GNULIB_FSEEK)/g' \
-	      -e 's/@''GNULIB_FSEEKO''@/$(GNULIB_FSEEKO)/g' \
-	      -e 's/@''GNULIB_FTELL''@/$(GNULIB_FTELL)/g' \
-	      -e 's/@''GNULIB_FTELLO''@/$(GNULIB_FTELLO)/g' \
-	      -e 's/@''GNULIB_FWRITE''@/$(GNULIB_FWRITE)/g' \
-	      -e 's/@''GNULIB_GETC''@/$(GNULIB_GETC)/g' \
-	      -e 's/@''GNULIB_GETCHAR''@/$(GNULIB_GETCHAR)/g' \
-	      -e 's/@''GNULIB_GETDELIM''@/$(GNULIB_GETDELIM)/g' \
-	      -e 's/@''GNULIB_GETLINE''@/$(GNULIB_GETLINE)/g' \
-	      -e 's/@''GNULIB_OBSTACK_PRINTF''@/$(GNULIB_OBSTACK_PRINTF)/g' \
-	      -e 's/@''GNULIB_OBSTACK_PRINTF_POSIX''@/$(GNULIB_OBSTACK_PRINTF_POSIX)/g' \
-	      -e 's/@''GNULIB_PCLOSE''@/$(GNULIB_PCLOSE)/g' \
-	      -e 's/@''GNULIB_PERROR''@/$(GNULIB_PERROR)/g' \
-	      -e 's/@''GNULIB_POPEN''@/$(GNULIB_POPEN)/g' \
-	      -e 's/@''GNULIB_PRINTF''@/$(GNULIB_PRINTF)/g' \
-	      -e 's/@''GNULIB_PRINTF_POSIX''@/$(GNULIB_PRINTF_POSIX)/g' \
-	      -e 's/@''GNULIB_PUTC''@/$(GNULIB_PUTC)/g' \
-	      -e 's/@''GNULIB_PUTCHAR''@/$(GNULIB_PUTCHAR)/g' \
-	      -e 's/@''GNULIB_PUTS''@/$(GNULIB_PUTS)/g' \
-	      -e 's/@''GNULIB_REMOVE''@/$(GNULIB_REMOVE)/g' \
-	      -e 's/@''GNULIB_RENAME''@/$(GNULIB_RENAME)/g' \
-	      -e 's/@''GNULIB_RENAMEAT''@/$(GNULIB_RENAMEAT)/g' \
-	      -e 's/@''GNULIB_SCANF''@/$(GNULIB_SCANF)/g' \
-	      -e 's/@''GNULIB_SNPRINTF''@/$(GNULIB_SNPRINTF)/g' \
-	      -e 's/@''GNULIB_SPRINTF_POSIX''@/$(GNULIB_SPRINTF_POSIX)/g' \
-	      -e 's/@''GNULIB_STDIO_H_NONBLOCKING''@/$(GNULIB_STDIO_H_NONBLOCKING)/g' \
-	      -e 's/@''GNULIB_STDIO_H_SIGPIPE''@/$(GNULIB_STDIO_H_SIGPIPE)/g' \
-	      -e 's/@''GNULIB_TMPFILE''@/$(GNULIB_TMPFILE)/g' \
-	      -e 's/@''GNULIB_VASPRINTF''@/$(GNULIB_VASPRINTF)/g' \
-	      -e 's/@''GNULIB_VDPRINTF''@/$(GNULIB_VDPRINTF)/g' \
-	      -e 's/@''GNULIB_VFPRINTF''@/$(GNULIB_VFPRINTF)/g' \
-	      -e 's/@''GNULIB_VFPRINTF_POSIX''@/$(GNULIB_VFPRINTF_POSIX)/g' \
-	      -e 's/@''GNULIB_VFSCANF''@/$(GNULIB_VFSCANF)/g' \
-	      -e 's/@''GNULIB_VSCANF''@/$(GNULIB_VSCANF)/g' \
-	      -e 's/@''GNULIB_VPRINTF''@/$(GNULIB_VPRINTF)/g' \
-	      -e 's/@''GNULIB_VPRINTF_POSIX''@/$(GNULIB_VPRINTF_POSIX)/g' \
-	      -e 's/@''GNULIB_VSNPRINTF''@/$(GNULIB_VSNPRINTF)/g' \
-	      -e 's/@''GNULIB_VSPRINTF_POSIX''@/$(GNULIB_VSPRINTF_POSIX)/g' \
-	      < $(srcdir)/stdio.in.h | \
-	  sed -e 's|@''HAVE_DECL_FPURGE''@|$(HAVE_DECL_FPURGE)|g' \
-	      -e 's|@''HAVE_DECL_FSEEKO''@|$(HAVE_DECL_FSEEKO)|g' \
-	      -e 's|@''HAVE_DECL_FTELLO''@|$(HAVE_DECL_FTELLO)|g' \
-	      -e 's|@''HAVE_DECL_GETDELIM''@|$(HAVE_DECL_GETDELIM)|g' \
-	      -e 's|@''HAVE_DECL_GETLINE''@|$(HAVE_DECL_GETLINE)|g' \
-	      -e 's|@''HAVE_DECL_OBSTACK_PRINTF''@|$(HAVE_DECL_OBSTACK_PRINTF)|g' \
-	      -e 's|@''HAVE_DECL_SNPRINTF''@|$(HAVE_DECL_SNPRINTF)|g' \
-	      -e 's|@''HAVE_DECL_VSNPRINTF''@|$(HAVE_DECL_VSNPRINTF)|g' \
-	      -e 's|@''HAVE_DPRINTF''@|$(HAVE_DPRINTF)|g' \
-	      -e 's|@''HAVE_FSEEKO''@|$(HAVE_FSEEKO)|g' \
-	      -e 's|@''HAVE_FTELLO''@|$(HAVE_FTELLO)|g' \
-	      -e 's|@''HAVE_PCLOSE''@|$(HAVE_PCLOSE)|g' \
-	      -e 's|@''HAVE_POPEN''@|$(HAVE_POPEN)|g' \
-	      -e 's|@''HAVE_RENAMEAT''@|$(HAVE_RENAMEAT)|g' \
-	      -e 's|@''HAVE_VASPRINTF''@|$(HAVE_VASPRINTF)|g' \
-	      -e 's|@''HAVE_VDPRINTF''@|$(HAVE_VDPRINTF)|g' \
-	      -e 's|@''REPLACE_DPRINTF''@|$(REPLACE_DPRINTF)|g' \
-	      -e 's|@''REPLACE_FCLOSE''@|$(REPLACE_FCLOSE)|g' \
-	      -e 's|@''REPLACE_FDOPEN''@|$(REPLACE_FDOPEN)|g' \
-	      -e 's|@''REPLACE_FFLUSH''@|$(REPLACE_FFLUSH)|g' \
-	      -e 's|@''REPLACE_FOPEN''@|$(REPLACE_FOPEN)|g' \
-	      -e 's|@''REPLACE_FPRINTF''@|$(REPLACE_FPRINTF)|g' \
-	      -e 's|@''REPLACE_FPURGE''@|$(REPLACE_FPURGE)|g' \
-	      -e 's|@''REPLACE_FREOPEN''@|$(REPLACE_FREOPEN)|g' \
-	      -e 's|@''REPLACE_FSEEK''@|$(REPLACE_FSEEK)|g' \
-	      -e 's|@''REPLACE_FSEEKO''@|$(REPLACE_FSEEKO)|g' \
-	      -e 's|@''REPLACE_FTELL''@|$(REPLACE_FTELL)|g' \
-	      -e 's|@''REPLACE_FTELLO''@|$(REPLACE_FTELLO)|g' \
-	      -e 's|@''REPLACE_GETDELIM''@|$(REPLACE_GETDELIM)|g' \
-	      -e 's|@''REPLACE_GETLINE''@|$(REPLACE_GETLINE)|g' \
-	      -e 's|@''REPLACE_OBSTACK_PRINTF''@|$(REPLACE_OBSTACK_PRINTF)|g' \
-	      -e 's|@''REPLACE_PERROR''@|$(REPLACE_PERROR)|g' \
-	      -e 's|@''REPLACE_POPEN''@|$(REPLACE_POPEN)|g' \
-	      -e 's|@''REPLACE_PRINTF''@|$(REPLACE_PRINTF)|g' \
-	      -e 's|@''REPLACE_REMOVE''@|$(REPLACE_REMOVE)|g' \
-	      -e 's|@''REPLACE_RENAME''@|$(REPLACE_RENAME)|g' \
-	      -e 's|@''REPLACE_RENAMEAT''@|$(REPLACE_RENAMEAT)|g' \
-	      -e 's|@''REPLACE_SNPRINTF''@|$(REPLACE_SNPRINTF)|g' \
-	      -e 's|@''REPLACE_SPRINTF''@|$(REPLACE_SPRINTF)|g' \
-	      -e 's|@''REPLACE_STDIO_READ_FUNCS''@|$(REPLACE_STDIO_READ_FUNCS)|g' \
-	      -e 's|@''REPLACE_STDIO_WRITE_FUNCS''@|$(REPLACE_STDIO_WRITE_FUNCS)|g' \
-	      -e 's|@''REPLACE_TMPFILE''@|$(REPLACE_TMPFILE)|g' \
-	      -e 's|@''REPLACE_VASPRINTF''@|$(REPLACE_VASPRINTF)|g' \
-	      -e 's|@''REPLACE_VDPRINTF''@|$(REPLACE_VDPRINTF)|g' \
-	      -e 's|@''REPLACE_VFPRINTF''@|$(REPLACE_VFPRINTF)|g' \
-	      -e 's|@''REPLACE_VPRINTF''@|$(REPLACE_VPRINTF)|g' \
-	      -e 's|@''REPLACE_VSNPRINTF''@|$(REPLACE_VSNPRINTF)|g' \
-	      -e 's|@''REPLACE_VSPRINTF''@|$(REPLACE_VSPRINTF)|g' \
-	      -e 's|@''ASM_SYMBOL_PREFIX''@|$(ASM_SYMBOL_PREFIX)|g' \
-	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
-	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
-	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)'; \
-	} > $@-t && \
-	mv $@-t $@
-MOSTLYCLEANFILES += stdio.h stdio.h-t
-
-EXTRA_DIST += stdio.in.h
-
-## end   gnulib module stdio
-
-## begin gnulib module stdlib
-
-BUILT_SOURCES += stdlib.h
-
-# We need the following in order to create <stdlib.h> when the system
-# doesn't have one that works with the given compiler.
-stdlib.h: stdlib.in.h $(top_builddir)/config.status $(CXXDEFS_H) \
-  $(_NORETURN_H) $(ARG_NONNULL_H) $(WARN_ON_USE_H)
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */' && \
-	  sed -e 's|@''GUARD_PREFIX''@|GL|g' \
-	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
-	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
-	      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \
-	      -e 's|@''NEXT_STDLIB_H''@|$(NEXT_STDLIB_H)|g' \
-	      -e 's/@''GNULIB__EXIT''@/$(GNULIB__EXIT)/g' \
-	      -e 's/@''GNULIB_ATOLL''@/$(GNULIB_ATOLL)/g' \
-	      -e 's/@''GNULIB_CALLOC_POSIX''@/$(GNULIB_CALLOC_POSIX)/g' \
-	      -e 's/@''GNULIB_CANONICALIZE_FILE_NAME''@/$(GNULIB_CANONICALIZE_FILE_NAME)/g' \
-	      -e 's/@''GNULIB_GETLOADAVG''@/$(GNULIB_GETLOADAVG)/g' \
-	      -e 's/@''GNULIB_GETSUBOPT''@/$(GNULIB_GETSUBOPT)/g' \
-	      -e 's/@''GNULIB_GRANTPT''@/$(GNULIB_GRANTPT)/g' \
-	      -e 's/@''GNULIB_MALLOC_POSIX''@/$(GNULIB_MALLOC_POSIX)/g' \
-	      -e 's/@''GNULIB_MBTOWC''@/$(GNULIB_MBTOWC)/g' \
-	      -e 's/@''GNULIB_MKDTEMP''@/$(GNULIB_MKDTEMP)/g' \
-	      -e 's/@''GNULIB_MKOSTEMP''@/$(GNULIB_MKOSTEMP)/g' \
-	      -e 's/@''GNULIB_MKOSTEMPS''@/$(GNULIB_MKOSTEMPS)/g' \
-	      -e 's/@''GNULIB_MKSTEMP''@/$(GNULIB_MKSTEMP)/g' \
-	      -e 's/@''GNULIB_MKSTEMPS''@/$(GNULIB_MKSTEMPS)/g' \
-	      -e 's/@''GNULIB_POSIX_OPENPT''@/$(GNULIB_POSIX_OPENPT)/g' \
-	      -e 's/@''GNULIB_PTSNAME''@/$(GNULIB_PTSNAME)/g' \
-	      -e 's/@''GNULIB_PTSNAME_R''@/$(GNULIB_PTSNAME_R)/g' \
-	      -e 's/@''GNULIB_PUTENV''@/$(GNULIB_PUTENV)/g' \
-	      -e 's/@''GNULIB_RANDOM''@/$(GNULIB_RANDOM)/g' \
-	      -e 's/@''GNULIB_RANDOM_R''@/$(GNULIB_RANDOM_R)/g' \
-	      -e 's/@''GNULIB_REALLOC_POSIX''@/$(GNULIB_REALLOC_POSIX)/g' \
-	      -e 's/@''GNULIB_REALPATH''@/$(GNULIB_REALPATH)/g' \
-	      -e 's/@''GNULIB_RPMATCH''@/$(GNULIB_RPMATCH)/g' \
-	      -e 's/@''GNULIB_SETENV''@/$(GNULIB_SETENV)/g' \
-	      -e 's/@''GNULIB_STRTOD''@/$(GNULIB_STRTOD)/g' \
-	      -e 's/@''GNULIB_STRTOLL''@/$(GNULIB_STRTOLL)/g' \
-	      -e 's/@''GNULIB_STRTOULL''@/$(GNULIB_STRTOULL)/g' \
-	      -e 's/@''GNULIB_SYSTEM_POSIX''@/$(GNULIB_SYSTEM_POSIX)/g' \
-	      -e 's/@''GNULIB_UNLOCKPT''@/$(GNULIB_UNLOCKPT)/g' \
-	      -e 's/@''GNULIB_UNSETENV''@/$(GNULIB_UNSETENV)/g' \
-	      -e 's/@''GNULIB_WCTOMB''@/$(GNULIB_WCTOMB)/g' \
-	      < $(srcdir)/stdlib.in.h | \
-	  sed -e 's|@''HAVE__EXIT''@|$(HAVE__EXIT)|g' \
-	      -e 's|@''HAVE_ATOLL''@|$(HAVE_ATOLL)|g' \
-	      -e 's|@''HAVE_CANONICALIZE_FILE_NAME''@|$(HAVE_CANONICALIZE_FILE_NAME)|g' \
-	      -e 's|@''HAVE_DECL_GETLOADAVG''@|$(HAVE_DECL_GETLOADAVG)|g' \
-	      -e 's|@''HAVE_GETSUBOPT''@|$(HAVE_GETSUBOPT)|g' \
-	      -e 's|@''HAVE_GRANTPT''@|$(HAVE_GRANTPT)|g' \
-	      -e 's|@''HAVE_MKDTEMP''@|$(HAVE_MKDTEMP)|g' \
-	      -e 's|@''HAVE_MKOSTEMP''@|$(HAVE_MKOSTEMP)|g' \
-	      -e 's|@''HAVE_MKOSTEMPS''@|$(HAVE_MKOSTEMPS)|g' \
-	      -e 's|@''HAVE_MKSTEMP''@|$(HAVE_MKSTEMP)|g' \
-	      -e 's|@''HAVE_MKSTEMPS''@|$(HAVE_MKSTEMPS)|g' \
-	      -e 's|@''HAVE_POSIX_OPENPT''@|$(HAVE_POSIX_OPENPT)|g' \
-	      -e 's|@''HAVE_PTSNAME''@|$(HAVE_PTSNAME)|g' \
-	      -e 's|@''HAVE_PTSNAME_R''@|$(HAVE_PTSNAME_R)|g' \
-	      -e 's|@''HAVE_RANDOM''@|$(HAVE_RANDOM)|g' \
-	      -e 's|@''HAVE_RANDOM_H''@|$(HAVE_RANDOM_H)|g' \
-	      -e 's|@''HAVE_RANDOM_R''@|$(HAVE_RANDOM_R)|g' \
-	      -e 's|@''HAVE_REALPATH''@|$(HAVE_REALPATH)|g' \
-	      -e 's|@''HAVE_RPMATCH''@|$(HAVE_RPMATCH)|g' \
-	      -e 's|@''HAVE_DECL_SETENV''@|$(HAVE_DECL_SETENV)|g' \
-	      -e 's|@''HAVE_STRTOD''@|$(HAVE_STRTOD)|g' \
-	      -e 's|@''HAVE_STRTOLL''@|$(HAVE_STRTOLL)|g' \
-	      -e 's|@''HAVE_STRTOULL''@|$(HAVE_STRTOULL)|g' \
-	      -e 's|@''HAVE_STRUCT_RANDOM_DATA''@|$(HAVE_STRUCT_RANDOM_DATA)|g' \
-	      -e 's|@''HAVE_SYS_LOADAVG_H''@|$(HAVE_SYS_LOADAVG_H)|g' \
-	      -e 's|@''HAVE_UNLOCKPT''@|$(HAVE_UNLOCKPT)|g' \
-	      -e 's|@''HAVE_DECL_UNSETENV''@|$(HAVE_DECL_UNSETENV)|g' \
-	      -e 's|@''REPLACE_CALLOC''@|$(REPLACE_CALLOC)|g' \
-	      -e 's|@''REPLACE_CANONICALIZE_FILE_NAME''@|$(REPLACE_CANONICALIZE_FILE_NAME)|g' \
-	      -e 's|@''REPLACE_MALLOC''@|$(REPLACE_MALLOC)|g' \
-	      -e 's|@''REPLACE_MBTOWC''@|$(REPLACE_MBTOWC)|g' \
-	      -e 's|@''REPLACE_MKSTEMP''@|$(REPLACE_MKSTEMP)|g' \
-	      -e 's|@''REPLACE_PTSNAME_R''@|$(REPLACE_PTSNAME_R)|g' \
-	      -e 's|@''REPLACE_PUTENV''@|$(REPLACE_PUTENV)|g' \
-	      -e 's|@''REPLACE_RANDOM_R''@|$(REPLACE_RANDOM_R)|g' \
-	      -e 's|@''REPLACE_REALLOC''@|$(REPLACE_REALLOC)|g' \
-	      -e 's|@''REPLACE_REALPATH''@|$(REPLACE_REALPATH)|g' \
-	      -e 's|@''REPLACE_SETENV''@|$(REPLACE_SETENV)|g' \
-	      -e 's|@''REPLACE_STRTOD''@|$(REPLACE_STRTOD)|g' \
-	      -e 's|@''REPLACE_UNSETENV''@|$(REPLACE_UNSETENV)|g' \
-	      -e 's|@''REPLACE_WCTOMB''@|$(REPLACE_WCTOMB)|g' \
-	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
-	      -e '/definition of _Noreturn/r $(_NORETURN_H)' \
-	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
-	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)'; \
-	} > $@-t && \
-	mv $@-t $@
-MOSTLYCLEANFILES += stdlib.h stdlib.h-t
-
-EXTRA_DIST += stdlib.in.h
-
-## end   gnulib module stdlib
-
-## begin gnulib module strcase
-
-
-EXTRA_DIST += strcasecmp.c strncasecmp.c
-
-EXTRA_libgnu_la_SOURCES += strcasecmp.c strncasecmp.c
-
-## end   gnulib module strcase
-
-## begin gnulib module strdup-posix
-
-
-EXTRA_DIST += strdup.c
-
-EXTRA_libgnu_la_SOURCES += strdup.c
-
-## end   gnulib module strdup-posix
-
-## begin gnulib module streq
-
-
-EXTRA_DIST += streq.h
-
-## end   gnulib module streq
-
-## begin gnulib module strerror
-
-
-EXTRA_DIST += strerror.c
-
-EXTRA_libgnu_la_SOURCES += strerror.c
-
-## end   gnulib module strerror
-
-## begin gnulib module strerror-override
-
-
-EXTRA_DIST += strerror-override.c strerror-override.h
-
-EXTRA_libgnu_la_SOURCES += strerror-override.c
-
-## end   gnulib module strerror-override
-
-## begin gnulib module strftime
-
-libgnu_la_SOURCES += strftime.c
-
-EXTRA_DIST += strftime.h
-
-## end   gnulib module strftime
-
-## begin gnulib module string
-
-BUILT_SOURCES += string.h
-
-# We need the following in order to create <string.h> when the system
-# doesn't have one that works with the given compiler.
-string.h: string.in.h $(top_builddir)/config.status $(CXXDEFS_H) $(ARG_NONNULL_H) $(WARN_ON_USE_H)
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */' && \
-	  sed -e 's|@''GUARD_PREFIX''@|GL|g' \
-	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
-	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
-	      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \
-	      -e 's|@''NEXT_STRING_H''@|$(NEXT_STRING_H)|g' \
-	      -e 's/@''GNULIB_FFSL''@/$(GNULIB_FFSL)/g' \
-	      -e 's/@''GNULIB_FFSLL''@/$(GNULIB_FFSLL)/g' \
-	      -e 's/@''GNULIB_MBSLEN''@/$(GNULIB_MBSLEN)/g' \
-	      -e 's/@''GNULIB_MBSNLEN''@/$(GNULIB_MBSNLEN)/g' \
-	      -e 's/@''GNULIB_MBSCHR''@/$(GNULIB_MBSCHR)/g' \
-	      -e 's/@''GNULIB_MBSRCHR''@/$(GNULIB_MBSRCHR)/g' \
-	      -e 's/@''GNULIB_MBSSTR''@/$(GNULIB_MBSSTR)/g' \
-	      -e 's/@''GNULIB_MBSCASECMP''@/$(GNULIB_MBSCASECMP)/g' \
-	      -e 's/@''GNULIB_MBSNCASECMP''@/$(GNULIB_MBSNCASECMP)/g' \
-	      -e 's/@''GNULIB_MBSPCASECMP''@/$(GNULIB_MBSPCASECMP)/g' \
-	      -e 's/@''GNULIB_MBSCASESTR''@/$(GNULIB_MBSCASESTR)/g' \
-	      -e 's/@''GNULIB_MBSCSPN''@/$(GNULIB_MBSCSPN)/g' \
-	      -e 's/@''GNULIB_MBSPBRK''@/$(GNULIB_MBSPBRK)/g' \
-	      -e 's/@''GNULIB_MBSSPN''@/$(GNULIB_MBSSPN)/g' \
-	      -e 's/@''GNULIB_MBSSEP''@/$(GNULIB_MBSSEP)/g' \
-	      -e 's/@''GNULIB_MBSTOK_R''@/$(GNULIB_MBSTOK_R)/g' \
-	      -e 's/@''GNULIB_MEMCHR''@/$(GNULIB_MEMCHR)/g' \
-	      -e 's/@''GNULIB_MEMMEM''@/$(GNULIB_MEMMEM)/g' \
-	      -e 's/@''GNULIB_MEMPCPY''@/$(GNULIB_MEMPCPY)/g' \
-	      -e 's/@''GNULIB_MEMRCHR''@/$(GNULIB_MEMRCHR)/g' \
-	      -e 's/@''GNULIB_RAWMEMCHR''@/$(GNULIB_RAWMEMCHR)/g' \
-	      -e 's/@''GNULIB_STPCPY''@/$(GNULIB_STPCPY)/g' \
-	      -e 's/@''GNULIB_STPNCPY''@/$(GNULIB_STPNCPY)/g' \
-	      -e 's/@''GNULIB_STRCHRNUL''@/$(GNULIB_STRCHRNUL)/g' \
-	      -e 's/@''GNULIB_STRDUP''@/$(GNULIB_STRDUP)/g' \
-	      -e 's/@''GNULIB_STRNCAT''@/$(GNULIB_STRNCAT)/g' \
-	      -e 's/@''GNULIB_STRNDUP''@/$(GNULIB_STRNDUP)/g' \
-	      -e 's/@''GNULIB_STRNLEN''@/$(GNULIB_STRNLEN)/g' \
-	      -e 's/@''GNULIB_STRPBRK''@/$(GNULIB_STRPBRK)/g' \
-	      -e 's/@''GNULIB_STRSEP''@/$(GNULIB_STRSEP)/g' \
-	      -e 's/@''GNULIB_STRSTR''@/$(GNULIB_STRSTR)/g' \
-	      -e 's/@''GNULIB_STRCASESTR''@/$(GNULIB_STRCASESTR)/g' \
-	      -e 's/@''GNULIB_STRTOK_R''@/$(GNULIB_STRTOK_R)/g' \
-	      -e 's/@''GNULIB_STRERROR''@/$(GNULIB_STRERROR)/g' \
-	      -e 's/@''GNULIB_STRERROR_R''@/$(GNULIB_STRERROR_R)/g' \
-	      -e 's/@''GNULIB_STRSIGNAL''@/$(GNULIB_STRSIGNAL)/g' \
-	      -e 's/@''GNULIB_STRVERSCMP''@/$(GNULIB_STRVERSCMP)/g' \
-	      < $(srcdir)/string.in.h | \
-	  sed -e 's|@''HAVE_FFSL''@|$(HAVE_FFSL)|g' \
-	      -e 's|@''HAVE_FFSLL''@|$(HAVE_FFSLL)|g' \
-	      -e 's|@''HAVE_MBSLEN''@|$(HAVE_MBSLEN)|g' \
-	      -e 's|@''HAVE_MEMCHR''@|$(HAVE_MEMCHR)|g' \
-	      -e 's|@''HAVE_DECL_MEMMEM''@|$(HAVE_DECL_MEMMEM)|g' \
-	      -e 's|@''HAVE_MEMPCPY''@|$(HAVE_MEMPCPY)|g' \
-	      -e 's|@''HAVE_DECL_MEMRCHR''@|$(HAVE_DECL_MEMRCHR)|g' \
-	      -e 's|@''HAVE_RAWMEMCHR''@|$(HAVE_RAWMEMCHR)|g' \
-	      -e 's|@''HAVE_STPCPY''@|$(HAVE_STPCPY)|g' \
-	      -e 's|@''HAVE_STPNCPY''@|$(HAVE_STPNCPY)|g' \
-	      -e 's|@''HAVE_STRCHRNUL''@|$(HAVE_STRCHRNUL)|g' \
-	      -e 's|@''HAVE_DECL_STRDUP''@|$(HAVE_DECL_STRDUP)|g' \
-	      -e 's|@''HAVE_DECL_STRNDUP''@|$(HAVE_DECL_STRNDUP)|g' \
-	      -e 's|@''HAVE_DECL_STRNLEN''@|$(HAVE_DECL_STRNLEN)|g' \
-	      -e 's|@''HAVE_STRPBRK''@|$(HAVE_STRPBRK)|g' \
-	      -e 's|@''HAVE_STRSEP''@|$(HAVE_STRSEP)|g' \
-	      -e 's|@''HAVE_STRCASESTR''@|$(HAVE_STRCASESTR)|g' \
-	      -e 's|@''HAVE_DECL_STRTOK_R''@|$(HAVE_DECL_STRTOK_R)|g' \
-	      -e 's|@''HAVE_DECL_STRERROR_R''@|$(HAVE_DECL_STRERROR_R)|g' \
-	      -e 's|@''HAVE_DECL_STRSIGNAL''@|$(HAVE_DECL_STRSIGNAL)|g' \
-	      -e 's|@''HAVE_STRVERSCMP''@|$(HAVE_STRVERSCMP)|g' \
-	      -e 's|@''REPLACE_STPNCPY''@|$(REPLACE_STPNCPY)|g' \
-	      -e 's|@''REPLACE_MEMCHR''@|$(REPLACE_MEMCHR)|g' \
-	      -e 's|@''REPLACE_MEMMEM''@|$(REPLACE_MEMMEM)|g' \
-	      -e 's|@''REPLACE_STRCASESTR''@|$(REPLACE_STRCASESTR)|g' \
-	      -e 's|@''REPLACE_STRCHRNUL''@|$(REPLACE_STRCHRNUL)|g' \
-	      -e 's|@''REPLACE_STRDUP''@|$(REPLACE_STRDUP)|g' \
-	      -e 's|@''REPLACE_STRSTR''@|$(REPLACE_STRSTR)|g' \
-	      -e 's|@''REPLACE_STRERROR''@|$(REPLACE_STRERROR)|g' \
-	      -e 's|@''REPLACE_STRERROR_R''@|$(REPLACE_STRERROR_R)|g' \
-	      -e 's|@''REPLACE_STRNCAT''@|$(REPLACE_STRNCAT)|g' \
-	      -e 's|@''REPLACE_STRNDUP''@|$(REPLACE_STRNDUP)|g' \
-	      -e 's|@''REPLACE_STRNLEN''@|$(REPLACE_STRNLEN)|g' \
-	      -e 's|@''REPLACE_STRSIGNAL''@|$(REPLACE_STRSIGNAL)|g' \
-	      -e 's|@''REPLACE_STRTOK_R''@|$(REPLACE_STRTOK_R)|g' \
-	      -e 's|@''UNDEFINE_STRTOK_R''@|$(UNDEFINE_STRTOK_R)|g' \
-	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
-	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
-	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)'; \
-	      < $(srcdir)/string.in.h; \
-	} > $@-t && \
-	mv $@-t $@
-MOSTLYCLEANFILES += string.h string.h-t
-
-EXTRA_DIST += string.in.h
-
-## end   gnulib module string
-
-## begin gnulib module strings
-
-BUILT_SOURCES += strings.h
-
-# We need the following in order to create <strings.h> when the system
-# doesn't have one that works with the given compiler.
-strings.h: strings.in.h $(top_builddir)/config.status $(CXXDEFS_H) $(WARN_ON_USE_H) $(ARG_NONNULL_H)
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */' && \
-	  sed -e 's|@''GUARD_PREFIX''@|GL|g' \
-	      -e 's|@''HAVE_STRINGS_H''@|$(HAVE_STRINGS_H)|g' \
-	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
-	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
-	      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \
-	      -e 's|@''NEXT_STRINGS_H''@|$(NEXT_STRINGS_H)|g' \
-	      -e 's|@''GNULIB_FFS''@|$(GNULIB_FFS)|g' \
-	      -e 's|@''HAVE_FFS''@|$(HAVE_FFS)|g' \
-	      -e 's|@''HAVE_STRCASECMP''@|$(HAVE_STRCASECMP)|g' \
-	      -e 's|@''HAVE_DECL_STRNCASECMP''@|$(HAVE_DECL_STRNCASECMP)|g' \
-	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
-	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
-	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)' \
-	      < $(srcdir)/strings.in.h; \
-	} > $@-t && \
-	mv $@-t $@
-MOSTLYCLEANFILES += strings.h strings.h-t
-
-EXTRA_DIST += strings.in.h
-
-## end   gnulib module strings
-
-## begin gnulib module strndup
-
-
-EXTRA_DIST += strndup.c
-
-EXTRA_libgnu_la_SOURCES += strndup.c
-
-## end   gnulib module strndup
-
-## begin gnulib module strnlen
-
-
-EXTRA_DIST += strnlen.c
-
-EXTRA_libgnu_la_SOURCES += strnlen.c
-
-## end   gnulib module strnlen
-
-## begin gnulib module strnlen1
-
-libgnu_la_SOURCES += strnlen1.h strnlen1.c
-
-## end   gnulib module strnlen1
-
-## begin gnulib module strptime
-
-
-EXTRA_DIST += strptime.c
-
-EXTRA_libgnu_la_SOURCES += strptime.c
-
-## end   gnulib module strptime
-
-## begin gnulib module symlink
-
-
-EXTRA_DIST += symlink.c
-
-EXTRA_libgnu_la_SOURCES += symlink.c
-
-## end   gnulib module symlink
-
-## begin gnulib module sys_select
-
-BUILT_SOURCES += sys/select.h
-
-# We need the following in order to create <sys/select.h> when the system
-# doesn't have one that works with the given compiler.
-sys/select.h: sys_select.in.h $(top_builddir)/config.status $(CXXDEFS_H) $(WARN_ON_USE_H)
-	$(AM_V_at)$(MKDIR_P) sys
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
-	  sed -e 's|@''GUARD_PREFIX''@|GL|g' \
-	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
-	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
-	      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \
-	      -e 's|@''NEXT_SYS_SELECT_H''@|$(NEXT_SYS_SELECT_H)|g' \
-	      -e 's|@''HAVE_SYS_SELECT_H''@|$(HAVE_SYS_SELECT_H)|g' \
-	      -e 's/@''GNULIB_PSELECT''@/$(GNULIB_PSELECT)/g' \
-	      -e 's/@''GNULIB_SELECT''@/$(GNULIB_SELECT)/g' \
-	      -e 's|@''HAVE_WINSOCK2_H''@|$(HAVE_WINSOCK2_H)|g' \
-	      -e 's|@''HAVE_PSELECT''@|$(HAVE_PSELECT)|g' \
-	      -e 's|@''REPLACE_PSELECT''@|$(REPLACE_PSELECT)|g' \
-	      -e 's|@''REPLACE_SELECT''@|$(REPLACE_SELECT)|g' \
-	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
-	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)' \
-	      < $(srcdir)/sys_select.in.h; \
-	} > $@-t && \
-	mv $@-t $@
-MOSTLYCLEANFILES += sys/select.h sys/select.h-t
-MOSTLYCLEANDIRS += sys
-
-EXTRA_DIST += sys_select.in.h
-
-## end   gnulib module sys_select
-
-## begin gnulib module sys_socket
-
-BUILT_SOURCES += sys/socket.h
-
-# We need the following in order to create <sys/socket.h> when the system
-# doesn't have one that works with the given compiler.
-sys/socket.h: sys_socket.in.h $(top_builddir)/config.status $(CXXDEFS_H) $(WARN_ON_USE_H) $(ARG_NONNULL_H)
-	$(AM_V_at)$(MKDIR_P) sys
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
-	  sed -e 's|@''GUARD_PREFIX''@|GL|g' \
-	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
-	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
-	      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \
-	      -e 's|@''NEXT_SYS_SOCKET_H''@|$(NEXT_SYS_SOCKET_H)|g' \
-	      -e 's|@''HAVE_SYS_SOCKET_H''@|$(HAVE_SYS_SOCKET_H)|g' \
-	      -e 's/@''GNULIB_CLOSE''@/$(GNULIB_CLOSE)/g' \
-	      -e 's/@''GNULIB_SOCKET''@/$(GNULIB_SOCKET)/g' \
-	      -e 's/@''GNULIB_CONNECT''@/$(GNULIB_CONNECT)/g' \
-	      -e 's/@''GNULIB_ACCEPT''@/$(GNULIB_ACCEPT)/g' \
-	      -e 's/@''GNULIB_BIND''@/$(GNULIB_BIND)/g' \
-	      -e 's/@''GNULIB_GETPEERNAME''@/$(GNULIB_GETPEERNAME)/g' \
-	      -e 's/@''GNULIB_GETSOCKNAME''@/$(GNULIB_GETSOCKNAME)/g' \
-	      -e 's/@''GNULIB_GETSOCKOPT''@/$(GNULIB_GETSOCKOPT)/g' \
-	      -e 's/@''GNULIB_LISTEN''@/$(GNULIB_LISTEN)/g' \
-	      -e 's/@''GNULIB_RECV''@/$(GNULIB_RECV)/g' \
-	      -e 's/@''GNULIB_SEND''@/$(GNULIB_SEND)/g' \
-	      -e 's/@''GNULIB_RECVFROM''@/$(GNULIB_RECVFROM)/g' \
-	      -e 's/@''GNULIB_SENDTO''@/$(GNULIB_SENDTO)/g' \
-	      -e 's/@''GNULIB_SETSOCKOPT''@/$(GNULIB_SETSOCKOPT)/g' \
-	      -e 's/@''GNULIB_SHUTDOWN''@/$(GNULIB_SHUTDOWN)/g' \
-	      -e 's/@''GNULIB_ACCEPT4''@/$(GNULIB_ACCEPT4)/g' \
-	      -e 's|@''HAVE_WINSOCK2_H''@|$(HAVE_WINSOCK2_H)|g' \
-	      -e 's|@''HAVE_WS2TCPIP_H''@|$(HAVE_WS2TCPIP_H)|g' \
-	      -e 's|@''HAVE_STRUCT_SOCKADDR_STORAGE''@|$(HAVE_STRUCT_SOCKADDR_STORAGE)|g' \
-	      -e 's|@''HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY''@|$(HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY)|g' \
-	      -e 's|@''HAVE_SA_FAMILY_T''@|$(HAVE_SA_FAMILY_T)|g' \
-	      -e 's|@''HAVE_ACCEPT4''@|$(HAVE_ACCEPT4)|g' \
-	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
-	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
-	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)' \
-	      < $(srcdir)/sys_socket.in.h; \
-	} > $@-t && \
-	mv -f $@-t $@
-MOSTLYCLEANFILES += sys/socket.h sys/socket.h-t
-MOSTLYCLEANDIRS += sys
-
-EXTRA_DIST += sys_socket.in.h
-
-## end   gnulib module sys_socket
-
-## begin gnulib module sys_stat
-
-BUILT_SOURCES += sys/stat.h
-
-# We need the following in order to create <sys/stat.h> when the system
-# has one that is incomplete.
-sys/stat.h: sys_stat.in.h $(top_builddir)/config.status $(CXXDEFS_H) $(ARG_NONNULL_H) $(WARN_ON_USE_H)
-	$(AM_V_at)$(MKDIR_P) sys
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
-	  sed -e 's|@''GUARD_PREFIX''@|GL|g' \
-	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
-	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
-	      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \
-	      -e 's|@''NEXT_SYS_STAT_H''@|$(NEXT_SYS_STAT_H)|g' \
-	      -e 's|@''WINDOWS_64_BIT_ST_SIZE''@|$(WINDOWS_64_BIT_ST_SIZE)|g' \
-	      -e 's/@''GNULIB_FCHMODAT''@/$(GNULIB_FCHMODAT)/g' \
-	      -e 's/@''GNULIB_FSTAT''@/$(GNULIB_FSTAT)/g' \
-	      -e 's/@''GNULIB_FSTATAT''@/$(GNULIB_FSTATAT)/g' \
-	      -e 's/@''GNULIB_FUTIMENS''@/$(GNULIB_FUTIMENS)/g' \
-	      -e 's/@''GNULIB_LCHMOD''@/$(GNULIB_LCHMOD)/g' \
-	      -e 's/@''GNULIB_LSTAT''@/$(GNULIB_LSTAT)/g' \
-	      -e 's/@''GNULIB_MKDIRAT''@/$(GNULIB_MKDIRAT)/g' \
-	      -e 's/@''GNULIB_MKFIFO''@/$(GNULIB_MKFIFO)/g' \
-	      -e 's/@''GNULIB_MKFIFOAT''@/$(GNULIB_MKFIFOAT)/g' \
-	      -e 's/@''GNULIB_MKNOD''@/$(GNULIB_MKNOD)/g' \
-	      -e 's/@''GNULIB_MKNODAT''@/$(GNULIB_MKNODAT)/g' \
-	      -e 's/@''GNULIB_STAT''@/$(GNULIB_STAT)/g' \
-	      -e 's/@''GNULIB_UTIMENSAT''@/$(GNULIB_UTIMENSAT)/g' \
-	      -e 's|@''HAVE_FCHMODAT''@|$(HAVE_FCHMODAT)|g' \
-	      -e 's|@''HAVE_FSTATAT''@|$(HAVE_FSTATAT)|g' \
-	      -e 's|@''HAVE_FUTIMENS''@|$(HAVE_FUTIMENS)|g' \
-	      -e 's|@''HAVE_LCHMOD''@|$(HAVE_LCHMOD)|g' \
-	      -e 's|@''HAVE_LSTAT''@|$(HAVE_LSTAT)|g' \
-	      -e 's|@''HAVE_MKDIRAT''@|$(HAVE_MKDIRAT)|g' \
-	      -e 's|@''HAVE_MKFIFO''@|$(HAVE_MKFIFO)|g' \
-	      -e 's|@''HAVE_MKFIFOAT''@|$(HAVE_MKFIFOAT)|g' \
-	      -e 's|@''HAVE_MKNOD''@|$(HAVE_MKNOD)|g' \
-	      -e 's|@''HAVE_MKNODAT''@|$(HAVE_MKNODAT)|g' \
-	      -e 's|@''HAVE_UTIMENSAT''@|$(HAVE_UTIMENSAT)|g' \
-	      -e 's|@''REPLACE_FSTAT''@|$(REPLACE_FSTAT)|g' \
-	      -e 's|@''REPLACE_FSTATAT''@|$(REPLACE_FSTATAT)|g' \
-	      -e 's|@''REPLACE_FUTIMENS''@|$(REPLACE_FUTIMENS)|g' \
-	      -e 's|@''REPLACE_LSTAT''@|$(REPLACE_LSTAT)|g' \
-	      -e 's|@''REPLACE_MKDIR''@|$(REPLACE_MKDIR)|g' \
-	      -e 's|@''REPLACE_MKFIFO''@|$(REPLACE_MKFIFO)|g' \
-	      -e 's|@''REPLACE_MKNOD''@|$(REPLACE_MKNOD)|g' \
-	      -e 's|@''REPLACE_STAT''@|$(REPLACE_STAT)|g' \
-	      -e 's|@''REPLACE_UTIMENSAT''@|$(REPLACE_UTIMENSAT)|g' \
-	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
-	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
-	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)' \
-	      < $(srcdir)/sys_stat.in.h; \
-	} > $@-t && \
-	mv $@-t $@
-MOSTLYCLEANFILES += sys/stat.h sys/stat.h-t
-MOSTLYCLEANDIRS += sys
-
-EXTRA_DIST += sys_stat.in.h
-
-## end   gnulib module sys_stat
-
-## begin gnulib module sys_time
-
-BUILT_SOURCES += sys/time.h
-
-# We need the following in order to create <sys/time.h> when the system
-# doesn't have one that works with the given compiler.
-sys/time.h: sys_time.in.h $(top_builddir)/config.status $(CXXDEFS_H) $(ARG_NONNULL_H) $(WARN_ON_USE_H)
-	$(AM_V_at)$(MKDIR_P) sys
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
-	  sed -e 's|@''GUARD_PREFIX''@|GL|g' \
-	      -e 's/@''HAVE_SYS_TIME_H''@/$(HAVE_SYS_TIME_H)/g' \
-	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
-	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
-	      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \
-	      -e 's|@''NEXT_SYS_TIME_H''@|$(NEXT_SYS_TIME_H)|g' \
-	      -e 's/@''GNULIB_GETTIMEOFDAY''@/$(GNULIB_GETTIMEOFDAY)/g' \
-	      -e 's|@''HAVE_WINSOCK2_H''@|$(HAVE_WINSOCK2_H)|g' \
-	      -e 's/@''HAVE_GETTIMEOFDAY''@/$(HAVE_GETTIMEOFDAY)/g' \
-	      -e 's/@''HAVE_STRUCT_TIMEVAL''@/$(HAVE_STRUCT_TIMEVAL)/g' \
-	      -e 's/@''REPLACE_GETTIMEOFDAY''@/$(REPLACE_GETTIMEOFDAY)/g' \
-	      -e 's/@''REPLACE_STRUCT_TIMEVAL''@/$(REPLACE_STRUCT_TIMEVAL)/g' \
-	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
-	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
-	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)' \
-	      < $(srcdir)/sys_time.in.h; \
-	} > $@-t && \
-	mv $@-t $@
-MOSTLYCLEANFILES += sys/time.h sys/time.h-t
-
-EXTRA_DIST += sys_time.in.h
-
-## end   gnulib module sys_time
-
-## begin gnulib module sys_times
-
-BUILT_SOURCES += sys/times.h
-
-# We need the following in order to create <sys/times.h> when the system
-# doesn't have one that works with the given compiler.
-sys/times.h: sys_times.in.h $(top_builddir)/config.status $(WARN_ON_USE_H) $(ARG_NONNULL_H)
-	$(AM_V_at)$(MKDIR_P) sys
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
-	  sed -e 's|@''GUARD_PREFIX''@|GL|g' \
-	      -e 's/@''HAVE_SYS_TIMES_H''@/$(HAVE_SYS_TIMES_H)/g' \
-	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
-	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
-	      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \
-	      -e 's|@''NEXT_SYS_TIMES_H''@|$(NEXT_SYS_TIMES_H)|g' \
-	      -e 's/@''GNULIB_TIMES''@/$(GNULIB_TIMES)/g' \
-	      -e 's|@''HAVE_STRUCT_TMS''@|$(HAVE_STRUCT_TMS)|g' \
-	      -e 's|@''HAVE_TIMES''@|$(HAVE_TIMES)|g' \
-	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
-	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)' \
-	      < $(srcdir)/sys_times.in.h; \
-	} > $@-t && \
-	mv $@-t $@
-MOSTLYCLEANFILES += sys/times.h sys/times.h-t
-MOSTLYCLEANDIRS += sys
-
-EXTRA_DIST += sys_times.in.h
-
-## end   gnulib module sys_times
-
-## begin gnulib module sys_types
-
-BUILT_SOURCES += sys/types.h
-
-# We need the following in order to create <sys/types.h> when the system
-# doesn't have one that works with the given compiler.
-sys/types.h: sys_types.in.h $(top_builddir)/config.status
-	$(AM_V_at)$(MKDIR_P) sys
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
-	  sed -e 's|@''GUARD_PREFIX''@|GL|g' \
-	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
-	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
-	      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \
-	      -e 's|@''NEXT_SYS_TYPES_H''@|$(NEXT_SYS_TYPES_H)|g' \
-	      -e 's|@''WINDOWS_64_BIT_OFF_T''@|$(WINDOWS_64_BIT_OFF_T)|g' \
-	      < $(srcdir)/sys_types.in.h; \
-	} > $@-t && \
-	mv $@-t $@
-MOSTLYCLEANFILES += sys/types.h sys/types.h-t
-
-EXTRA_DIST += sys_types.in.h
-
-## end   gnulib module sys_types
-
-## begin gnulib module sys_uio
-
-BUILT_SOURCES += sys/uio.h
-
-# We need the following in order to create <sys/uio.h> when the system
-# doesn't have one that works with the given compiler.
-sys/uio.h: sys_uio.in.h $(top_builddir)/config.status
-	$(AM_V_at)$(MKDIR_P) sys
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
-	  sed -e 's|@''GUARD_PREFIX''@|GL|g' \
-	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
-	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
-	      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \
-	      -e 's|@''NEXT_SYS_UIO_H''@|$(NEXT_SYS_UIO_H)|g' \
-	      -e 's|@''HAVE_SYS_UIO_H''@|$(HAVE_SYS_UIO_H)|g' \
-	      < $(srcdir)/sys_uio.in.h; \
-	} > $@-t && \
-	mv -f $@-t $@
-MOSTLYCLEANFILES += sys/uio.h sys/uio.h-t
-MOSTLYCLEANDIRS += sys
-
-EXTRA_DIST += sys_uio.in.h
-
-## end   gnulib module sys_uio
-
-## begin gnulib module tempname
-
-libgnu_la_SOURCES += tempname.c
-
-EXTRA_DIST += tempname.h
-
-## end   gnulib module tempname
-
-## begin gnulib module time
-
-BUILT_SOURCES += time.h
-
-# We need the following in order to create <time.h> when the system
-# doesn't have one that works with the given compiler.
-time.h: time.in.h $(top_builddir)/config.status $(CXXDEFS_H) $(ARG_NONNULL_H) $(WARN_ON_USE_H)
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */' && \
-	  sed -e 's|@''GUARD_PREFIX''@|GL|g' \
-	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
-	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
-	      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \
-	      -e 's|@''NEXT_TIME_H''@|$(NEXT_TIME_H)|g' \
-	      -e 's/@''GNULIB_MKTIME''@/$(GNULIB_MKTIME)/g' \
-	      -e 's/@''GNULIB_NANOSLEEP''@/$(GNULIB_NANOSLEEP)/g' \
-	      -e 's/@''GNULIB_STRPTIME''@/$(GNULIB_STRPTIME)/g' \
-	      -e 's/@''GNULIB_TIMEGM''@/$(GNULIB_TIMEGM)/g' \
-	      -e 's/@''GNULIB_TIME_R''@/$(GNULIB_TIME_R)/g' \
-	      -e 's|@''HAVE_DECL_LOCALTIME_R''@|$(HAVE_DECL_LOCALTIME_R)|g' \
-	      -e 's|@''HAVE_NANOSLEEP''@|$(HAVE_NANOSLEEP)|g' \
-	      -e 's|@''HAVE_STRPTIME''@|$(HAVE_STRPTIME)|g' \
-	      -e 's|@''HAVE_TIMEGM''@|$(HAVE_TIMEGM)|g' \
-	      -e 's|@''REPLACE_LOCALTIME_R''@|$(REPLACE_LOCALTIME_R)|g' \
-	      -e 's|@''REPLACE_MKTIME''@|$(REPLACE_MKTIME)|g' \
-	      -e 's|@''REPLACE_NANOSLEEP''@|$(REPLACE_NANOSLEEP)|g' \
-	      -e 's|@''REPLACE_TIMEGM''@|$(REPLACE_TIMEGM)|g' \
-	      -e 's|@''PTHREAD_H_DEFINES_STRUCT_TIMESPEC''@|$(PTHREAD_H_DEFINES_STRUCT_TIMESPEC)|g' \
-	      -e 's|@''SYS_TIME_H_DEFINES_STRUCT_TIMESPEC''@|$(SYS_TIME_H_DEFINES_STRUCT_TIMESPEC)|g' \
-	      -e 's|@''TIME_H_DEFINES_STRUCT_TIMESPEC''@|$(TIME_H_DEFINES_STRUCT_TIMESPEC)|g' \
-	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
-	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
-	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)' \
-	      < $(srcdir)/time.in.h; \
-	} > $@-t && \
-	mv $@-t $@
-MOSTLYCLEANFILES += time.h time.h-t
-
-EXTRA_DIST += time.in.h
-
-## end   gnulib module time
-
-## begin gnulib module time_r
-
-
-EXTRA_DIST += time_r.c
-
-EXTRA_libgnu_la_SOURCES += time_r.c
-
-## end   gnulib module time_r
-
-## begin gnulib module times
-
-
-EXTRA_DIST += times.c
-
-EXTRA_libgnu_la_SOURCES += times.c
-
-## end   gnulib module times
-
-## begin gnulib module tmpdir
-
-libgnu_la_SOURCES += tmpdir.h tmpdir.c
-
-## end   gnulib module tmpdir
-
-## begin gnulib module tmpfile
-
-
-EXTRA_DIST += tmpfile.c
-
-EXTRA_libgnu_la_SOURCES += tmpfile.c
-
-## end   gnulib module tmpfile
-
-## begin gnulib module trunc
-
-
-EXTRA_DIST += trunc.c
-
-EXTRA_libgnu_la_SOURCES += trunc.c
-
-## end   gnulib module trunc
-
-## begin gnulib module truncf
-
-
-EXTRA_DIST += trunc.c truncf.c
-
-EXTRA_libgnu_la_SOURCES += trunc.c truncf.c
-
-## end   gnulib module truncf
-
-## begin gnulib module unistd
-
-BUILT_SOURCES += unistd.h
-
-# We need the following in order to create an empty placeholder for
-# <unistd.h> when the system doesn't have one.
-unistd.h: unistd.in.h $(top_builddir)/config.status $(CXXDEFS_H) $(ARG_NONNULL_H) $(WARN_ON_USE_H)
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
-	  sed -e 's|@''GUARD_PREFIX''@|GL|g' \
-	      -e 's|@''HAVE_UNISTD_H''@|$(HAVE_UNISTD_H)|g' \
-	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
-	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
-	      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \
-	      -e 's|@''NEXT_UNISTD_H''@|$(NEXT_UNISTD_H)|g' \
-	      -e 's|@''WINDOWS_64_BIT_OFF_T''@|$(WINDOWS_64_BIT_OFF_T)|g' \
-	      -e 's/@''GNULIB_CHDIR''@/$(GNULIB_CHDIR)/g' \
-	      -e 's/@''GNULIB_CHOWN''@/$(GNULIB_CHOWN)/g' \
-	      -e 's/@''GNULIB_CLOSE''@/$(GNULIB_CLOSE)/g' \
-	      -e 's/@''GNULIB_DUP''@/$(GNULIB_DUP)/g' \
-	      -e 's/@''GNULIB_DUP2''@/$(GNULIB_DUP2)/g' \
-	      -e 's/@''GNULIB_DUP3''@/$(GNULIB_DUP3)/g' \
-	      -e 's/@''GNULIB_ENVIRON''@/$(GNULIB_ENVIRON)/g' \
-	      -e 's/@''GNULIB_EUIDACCESS''@/$(GNULIB_EUIDACCESS)/g' \
-	      -e 's/@''GNULIB_FACCESSAT''@/$(GNULIB_FACCESSAT)/g' \
-	      -e 's/@''GNULIB_FCHDIR''@/$(GNULIB_FCHDIR)/g' \
-	      -e 's/@''GNULIB_FCHOWNAT''@/$(GNULIB_FCHOWNAT)/g' \
-	      -e 's/@''GNULIB_FDATASYNC''@/$(GNULIB_FDATASYNC)/g' \
-	      -e 's/@''GNULIB_FSYNC''@/$(GNULIB_FSYNC)/g' \
-	      -e 's/@''GNULIB_FTRUNCATE''@/$(GNULIB_FTRUNCATE)/g' \
-	      -e 's/@''GNULIB_GETCWD''@/$(GNULIB_GETCWD)/g' \
-	      -e 's/@''GNULIB_GETDOMAINNAME''@/$(GNULIB_GETDOMAINNAME)/g' \
-	      -e 's/@''GNULIB_GETDTABLESIZE''@/$(GNULIB_GETDTABLESIZE)/g' \
-	      -e 's/@''GNULIB_GETGROUPS''@/$(GNULIB_GETGROUPS)/g' \
-	      -e 's/@''GNULIB_GETHOSTNAME''@/$(GNULIB_GETHOSTNAME)/g' \
-	      -e 's/@''GNULIB_GETLOGIN''@/$(GNULIB_GETLOGIN)/g' \
-	      -e 's/@''GNULIB_GETLOGIN_R''@/$(GNULIB_GETLOGIN_R)/g' \
-	      -e 's/@''GNULIB_GETPAGESIZE''@/$(GNULIB_GETPAGESIZE)/g' \
-	      -e 's/@''GNULIB_GETUSERSHELL''@/$(GNULIB_GETUSERSHELL)/g' \
-	      -e 's/@''GNULIB_GROUP_MEMBER''@/$(GNULIB_GROUP_MEMBER)/g' \
-	      -e 's/@''GNULIB_ISATTY''@/$(GNULIB_ISATTY)/g' \
-	      -e 's/@''GNULIB_LCHOWN''@/$(GNULIB_LCHOWN)/g' \
-	      -e 's/@''GNULIB_LINK''@/$(GNULIB_LINK)/g' \
-	      -e 's/@''GNULIB_LINKAT''@/$(GNULIB_LINKAT)/g' \
-	      -e 's/@''GNULIB_LSEEK''@/$(GNULIB_LSEEK)/g' \
-	      -e 's/@''GNULIB_PIPE''@/$(GNULIB_PIPE)/g' \
-	      -e 's/@''GNULIB_PIPE2''@/$(GNULIB_PIPE2)/g' \
-	      -e 's/@''GNULIB_PREAD''@/$(GNULIB_PREAD)/g' \
-	      -e 's/@''GNULIB_PWRITE''@/$(GNULIB_PWRITE)/g' \
-	      -e 's/@''GNULIB_READ''@/$(GNULIB_READ)/g' \
-	      -e 's/@''GNULIB_READLINK''@/$(GNULIB_READLINK)/g' \
-	      -e 's/@''GNULIB_READLINKAT''@/$(GNULIB_READLINKAT)/g' \
-	      -e 's/@''GNULIB_RMDIR''@/$(GNULIB_RMDIR)/g' \
-	      -e 's/@''GNULIB_SETHOSTNAME''@/$(GNULIB_SETHOSTNAME)/g' \
-	      -e 's/@''GNULIB_SLEEP''@/$(GNULIB_SLEEP)/g' \
-	      -e 's/@''GNULIB_SYMLINK''@/$(GNULIB_SYMLINK)/g' \
-	      -e 's/@''GNULIB_SYMLINKAT''@/$(GNULIB_SYMLINKAT)/g' \
-	      -e 's/@''GNULIB_TTYNAME_R''@/$(GNULIB_TTYNAME_R)/g' \
-	      -e 's/@''GNULIB_UNISTD_H_GETOPT''@/0$(GNULIB_GL_UNISTD_H_GETOPT)/g' \
-	      -e 's/@''GNULIB_UNISTD_H_NONBLOCKING''@/$(GNULIB_UNISTD_H_NONBLOCKING)/g' \
-	      -e 's/@''GNULIB_UNISTD_H_SIGPIPE''@/$(GNULIB_UNISTD_H_SIGPIPE)/g' \
-	      -e 's/@''GNULIB_UNLINK''@/$(GNULIB_UNLINK)/g' \
-	      -e 's/@''GNULIB_UNLINKAT''@/$(GNULIB_UNLINKAT)/g' \
-	      -e 's/@''GNULIB_USLEEP''@/$(GNULIB_USLEEP)/g' \
-	      -e 's/@''GNULIB_WRITE''@/$(GNULIB_WRITE)/g' \
-	      < $(srcdir)/unistd.in.h | \
-	  sed -e 's|@''HAVE_CHOWN''@|$(HAVE_CHOWN)|g' \
-	      -e 's|@''HAVE_DUP2''@|$(HAVE_DUP2)|g' \
-	      -e 's|@''HAVE_DUP3''@|$(HAVE_DUP3)|g' \
-	      -e 's|@''HAVE_EUIDACCESS''@|$(HAVE_EUIDACCESS)|g' \
-	      -e 's|@''HAVE_FACCESSAT''@|$(HAVE_FACCESSAT)|g' \
-	      -e 's|@''HAVE_FCHDIR''@|$(HAVE_FCHDIR)|g' \
-	      -e 's|@''HAVE_FCHOWNAT''@|$(HAVE_FCHOWNAT)|g' \
-	      -e 's|@''HAVE_FDATASYNC''@|$(HAVE_FDATASYNC)|g' \
-	      -e 's|@''HAVE_FSYNC''@|$(HAVE_FSYNC)|g' \
-	      -e 's|@''HAVE_FTRUNCATE''@|$(HAVE_FTRUNCATE)|g' \
-	      -e 's|@''HAVE_GETDTABLESIZE''@|$(HAVE_GETDTABLESIZE)|g' \
-	      -e 's|@''HAVE_GETGROUPS''@|$(HAVE_GETGROUPS)|g' \
-	      -e 's|@''HAVE_GETHOSTNAME''@|$(HAVE_GETHOSTNAME)|g' \
-	      -e 's|@''HAVE_GETLOGIN''@|$(HAVE_GETLOGIN)|g' \
-	      -e 's|@''HAVE_GETPAGESIZE''@|$(HAVE_GETPAGESIZE)|g' \
-	      -e 's|@''HAVE_GROUP_MEMBER''@|$(HAVE_GROUP_MEMBER)|g' \
-	      -e 's|@''HAVE_LCHOWN''@|$(HAVE_LCHOWN)|g' \
-	      -e 's|@''HAVE_LINK''@|$(HAVE_LINK)|g' \
-	      -e 's|@''HAVE_LINKAT''@|$(HAVE_LINKAT)|g' \
-	      -e 's|@''HAVE_PIPE''@|$(HAVE_PIPE)|g' \
-	      -e 's|@''HAVE_PIPE2''@|$(HAVE_PIPE2)|g' \
-	      -e 's|@''HAVE_PREAD''@|$(HAVE_PREAD)|g' \
-	      -e 's|@''HAVE_PWRITE''@|$(HAVE_PWRITE)|g' \
-	      -e 's|@''HAVE_READLINK''@|$(HAVE_READLINK)|g' \
-	      -e 's|@''HAVE_READLINKAT''@|$(HAVE_READLINKAT)|g' \
-	      -e 's|@''HAVE_SETHOSTNAME''@|$(HAVE_SETHOSTNAME)|g' \
-	      -e 's|@''HAVE_SLEEP''@|$(HAVE_SLEEP)|g' \
-	      -e 's|@''HAVE_SYMLINK''@|$(HAVE_SYMLINK)|g' \
-	      -e 's|@''HAVE_SYMLINKAT''@|$(HAVE_SYMLINKAT)|g' \
-	      -e 's|@''HAVE_UNLINKAT''@|$(HAVE_UNLINKAT)|g' \
-	      -e 's|@''HAVE_USLEEP''@|$(HAVE_USLEEP)|g' \
-	      -e 's|@''HAVE_DECL_ENVIRON''@|$(HAVE_DECL_ENVIRON)|g' \
-	      -e 's|@''HAVE_DECL_FCHDIR''@|$(HAVE_DECL_FCHDIR)|g' \
-	      -e 's|@''HAVE_DECL_FDATASYNC''@|$(HAVE_DECL_FDATASYNC)|g' \
-	      -e 's|@''HAVE_DECL_GETDOMAINNAME''@|$(HAVE_DECL_GETDOMAINNAME)|g' \
-	      -e 's|@''HAVE_DECL_GETLOGIN_R''@|$(HAVE_DECL_GETLOGIN_R)|g' \
-	      -e 's|@''HAVE_DECL_GETPAGESIZE''@|$(HAVE_DECL_GETPAGESIZE)|g' \
-	      -e 's|@''HAVE_DECL_GETUSERSHELL''@|$(HAVE_DECL_GETUSERSHELL)|g' \
-	      -e 's|@''HAVE_DECL_SETHOSTNAME''@|$(HAVE_DECL_SETHOSTNAME)|g' \
-	      -e 's|@''HAVE_DECL_TTYNAME_R''@|$(HAVE_DECL_TTYNAME_R)|g' \
-	      -e 's|@''HAVE_OS_H''@|$(HAVE_OS_H)|g' \
-	      -e 's|@''HAVE_SYS_PARAM_H''@|$(HAVE_SYS_PARAM_H)|g' \
-	  | \
-	  sed -e 's|@''REPLACE_CHOWN''@|$(REPLACE_CHOWN)|g' \
-	      -e 's|@''REPLACE_CLOSE''@|$(REPLACE_CLOSE)|g' \
-	      -e 's|@''REPLACE_DUP''@|$(REPLACE_DUP)|g' \
-	      -e 's|@''REPLACE_DUP2''@|$(REPLACE_DUP2)|g' \
-	      -e 's|@''REPLACE_FCHOWNAT''@|$(REPLACE_FCHOWNAT)|g' \
-	      -e 's|@''REPLACE_FTRUNCATE''@|$(REPLACE_FTRUNCATE)|g' \
-	      -e 's|@''REPLACE_GETCWD''@|$(REPLACE_GETCWD)|g' \
-	      -e 's|@''REPLACE_GETDOMAINNAME''@|$(REPLACE_GETDOMAINNAME)|g' \
-	      -e 's|@''REPLACE_GETLOGIN_R''@|$(REPLACE_GETLOGIN_R)|g' \
-	      -e 's|@''REPLACE_GETGROUPS''@|$(REPLACE_GETGROUPS)|g' \
-	      -e 's|@''REPLACE_GETPAGESIZE''@|$(REPLACE_GETPAGESIZE)|g' \
-	      -e 's|@''REPLACE_ISATTY''@|$(REPLACE_ISATTY)|g' \
-	      -e 's|@''REPLACE_LCHOWN''@|$(REPLACE_LCHOWN)|g' \
-	      -e 's|@''REPLACE_LINK''@|$(REPLACE_LINK)|g' \
-	      -e 's|@''REPLACE_LINKAT''@|$(REPLACE_LINKAT)|g' \
-	      -e 's|@''REPLACE_LSEEK''@|$(REPLACE_LSEEK)|g' \
-	      -e 's|@''REPLACE_PREAD''@|$(REPLACE_PREAD)|g' \
-	      -e 's|@''REPLACE_PWRITE''@|$(REPLACE_PWRITE)|g' \
-	      -e 's|@''REPLACE_READ''@|$(REPLACE_READ)|g' \
-	      -e 's|@''REPLACE_READLINK''@|$(REPLACE_READLINK)|g' \
-	      -e 's|@''REPLACE_RMDIR''@|$(REPLACE_RMDIR)|g' \
-	      -e 's|@''REPLACE_SLEEP''@|$(REPLACE_SLEEP)|g' \
-	      -e 's|@''REPLACE_SYMLINK''@|$(REPLACE_SYMLINK)|g' \
-	      -e 's|@''REPLACE_TTYNAME_R''@|$(REPLACE_TTYNAME_R)|g' \
-	      -e 's|@''REPLACE_UNLINK''@|$(REPLACE_UNLINK)|g' \
-	      -e 's|@''REPLACE_UNLINKAT''@|$(REPLACE_UNLINKAT)|g' \
-	      -e 's|@''REPLACE_USLEEP''@|$(REPLACE_USLEEP)|g' \
-	      -e 's|@''REPLACE_WRITE''@|$(REPLACE_WRITE)|g' \
-	      -e 's|@''UNISTD_H_HAVE_WINSOCK2_H''@|$(UNISTD_H_HAVE_WINSOCK2_H)|g' \
-	      -e 's|@''UNISTD_H_HAVE_WINSOCK2_H_AND_USE_SOCKETS''@|$(UNISTD_H_HAVE_WINSOCK2_H_AND_USE_SOCKETS)|g' \
-	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
-	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
-	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)'; \
-	} > $@-t && \
-	mv $@-t $@
-MOSTLYCLEANFILES += unistd.h unistd.h-t
-
-EXTRA_DIST += unistd.in.h
-
-## end   gnulib module unistd
-
-## begin gnulib module unistd-safer
-
-libgnu_la_SOURCES += dup-safer.c fd-safer.c pipe-safer.c
-
-EXTRA_DIST += unistd--.h unistd-safer.h
-
-## end   gnulib module unistd-safer
-
-## begin gnulib module unlink
-
-
-EXTRA_DIST += unlink.c
-
-EXTRA_libgnu_la_SOURCES += unlink.c
-
-## end   gnulib module unlink
-
-## begin gnulib module vasnprintf
-
-
-EXTRA_DIST += asnprintf.c float+.h printf-args.c printf-args.h printf-parse.c printf-parse.h vasnprintf.c vasnprintf.h
-
-EXTRA_libgnu_la_SOURCES += asnprintf.c printf-args.c printf-parse.c vasnprintf.c
-
-## end   gnulib module vasnprintf
-
-## begin gnulib module vasprintf
-
-
-EXTRA_DIST += asprintf.c vasprintf.c
-
-EXTRA_libgnu_la_SOURCES += asprintf.c vasprintf.c
-
-## end   gnulib module vasprintf
-
-## begin gnulib module verify
-
-
-EXTRA_DIST += verify.h
-
-## end   gnulib module verify
-
-## begin gnulib module wchar
-
-BUILT_SOURCES += wchar.h
-
-# We need the following in order to create <wchar.h> when the system
-# version does not work standalone.
-wchar.h: wchar.in.h $(top_builddir)/config.status $(CXXDEFS_H) $(ARG_NONNULL_H) $(WARN_ON_USE_H)
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
-	  sed -e 's|@''GUARD_PREFIX''@|GL|g' \
-	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
-	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
-	      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \
-	      -e 's|@''HAVE_FEATURES_H''@|$(HAVE_FEATURES_H)|g' \
-	      -e 's|@''NEXT_WCHAR_H''@|$(NEXT_WCHAR_H)|g' \
-	      -e 's|@''HAVE_WCHAR_H''@|$(HAVE_WCHAR_H)|g' \
-	      -e 's/@''GNULIB_BTOWC''@/$(GNULIB_BTOWC)/g' \
-	      -e 's/@''GNULIB_WCTOB''@/$(GNULIB_WCTOB)/g' \
-	      -e 's/@''GNULIB_MBSINIT''@/$(GNULIB_MBSINIT)/g' \
-	      -e 's/@''GNULIB_MBRTOWC''@/$(GNULIB_MBRTOWC)/g' \
-	      -e 's/@''GNULIB_MBRLEN''@/$(GNULIB_MBRLEN)/g' \
-	      -e 's/@''GNULIB_MBSRTOWCS''@/$(GNULIB_MBSRTOWCS)/g' \
-	      -e 's/@''GNULIB_MBSNRTOWCS''@/$(GNULIB_MBSNRTOWCS)/g' \
-	      -e 's/@''GNULIB_WCRTOMB''@/$(GNULIB_WCRTOMB)/g' \
-	      -e 's/@''GNULIB_WCSRTOMBS''@/$(GNULIB_WCSRTOMBS)/g' \
-	      -e 's/@''GNULIB_WCSNRTOMBS''@/$(GNULIB_WCSNRTOMBS)/g' \
-	      -e 's/@''GNULIB_WCWIDTH''@/$(GNULIB_WCWIDTH)/g' \
-	      -e 's/@''GNULIB_WMEMCHR''@/$(GNULIB_WMEMCHR)/g' \
-	      -e 's/@''GNULIB_WMEMCMP''@/$(GNULIB_WMEMCMP)/g' \
-	      -e 's/@''GNULIB_WMEMCPY''@/$(GNULIB_WMEMCPY)/g' \
-	      -e 's/@''GNULIB_WMEMMOVE''@/$(GNULIB_WMEMMOVE)/g' \
-	      -e 's/@''GNULIB_WMEMSET''@/$(GNULIB_WMEMSET)/g' \
-	      -e 's/@''GNULIB_WCSLEN''@/$(GNULIB_WCSLEN)/g' \
-	      -e 's/@''GNULIB_WCSNLEN''@/$(GNULIB_WCSNLEN)/g' \
-	      -e 's/@''GNULIB_WCSCPY''@/$(GNULIB_WCSCPY)/g' \
-	      -e 's/@''GNULIB_WCPCPY''@/$(GNULIB_WCPCPY)/g' \
-	      -e 's/@''GNULIB_WCSNCPY''@/$(GNULIB_WCSNCPY)/g' \
-	      -e 's/@''GNULIB_WCPNCPY''@/$(GNULIB_WCPNCPY)/g' \
-	      -e 's/@''GNULIB_WCSCAT''@/$(GNULIB_WCSCAT)/g' \
-	      -e 's/@''GNULIB_WCSNCAT''@/$(GNULIB_WCSNCAT)/g' \
-	      -e 's/@''GNULIB_WCSCMP''@/$(GNULIB_WCSCMP)/g' \
-	      -e 's/@''GNULIB_WCSNCMP''@/$(GNULIB_WCSNCMP)/g' \
-	      -e 's/@''GNULIB_WCSCASECMP''@/$(GNULIB_WCSCASECMP)/g' \
-	      -e 's/@''GNULIB_WCSNCASECMP''@/$(GNULIB_WCSNCASECMP)/g' \
-	      -e 's/@''GNULIB_WCSCOLL''@/$(GNULIB_WCSCOLL)/g' \
-	      -e 's/@''GNULIB_WCSXFRM''@/$(GNULIB_WCSXFRM)/g' \
-	      -e 's/@''GNULIB_WCSDUP''@/$(GNULIB_WCSDUP)/g' \
-	      -e 's/@''GNULIB_WCSCHR''@/$(GNULIB_WCSCHR)/g' \
-	      -e 's/@''GNULIB_WCSRCHR''@/$(GNULIB_WCSRCHR)/g' \
-	      -e 's/@''GNULIB_WCSCSPN''@/$(GNULIB_WCSCSPN)/g' \
-	      -e 's/@''GNULIB_WCSSPN''@/$(GNULIB_WCSSPN)/g' \
-	      -e 's/@''GNULIB_WCSPBRK''@/$(GNULIB_WCSPBRK)/g' \
-	      -e 's/@''GNULIB_WCSSTR''@/$(GNULIB_WCSSTR)/g' \
-	      -e 's/@''GNULIB_WCSTOK''@/$(GNULIB_WCSTOK)/g' \
-	      -e 's/@''GNULIB_WCSWIDTH''@/$(GNULIB_WCSWIDTH)/g' \
-	      < $(srcdir)/wchar.in.h | \
-	  sed -e 's|@''HAVE_WINT_T''@|$(HAVE_WINT_T)|g' \
-	      -e 's|@''HAVE_BTOWC''@|$(HAVE_BTOWC)|g' \
-	      -e 's|@''HAVE_MBSINIT''@|$(HAVE_MBSINIT)|g' \
-	      -e 's|@''HAVE_MBRTOWC''@|$(HAVE_MBRTOWC)|g' \
-	      -e 's|@''HAVE_MBRLEN''@|$(HAVE_MBRLEN)|g' \
-	      -e 's|@''HAVE_MBSRTOWCS''@|$(HAVE_MBSRTOWCS)|g' \
-	      -e 's|@''HAVE_MBSNRTOWCS''@|$(HAVE_MBSNRTOWCS)|g' \
-	      -e 's|@''HAVE_WCRTOMB''@|$(HAVE_WCRTOMB)|g' \
-	      -e 's|@''HAVE_WCSRTOMBS''@|$(HAVE_WCSRTOMBS)|g' \
-	      -e 's|@''HAVE_WCSNRTOMBS''@|$(HAVE_WCSNRTOMBS)|g' \
-	      -e 's|@''HAVE_WMEMCHR''@|$(HAVE_WMEMCHR)|g' \
-	      -e 's|@''HAVE_WMEMCMP''@|$(HAVE_WMEMCMP)|g' \
-	      -e 's|@''HAVE_WMEMCPY''@|$(HAVE_WMEMCPY)|g' \
-	      -e 's|@''HAVE_WMEMMOVE''@|$(HAVE_WMEMMOVE)|g' \
-	      -e 's|@''HAVE_WMEMSET''@|$(HAVE_WMEMSET)|g' \
-	      -e 's|@''HAVE_WCSLEN''@|$(HAVE_WCSLEN)|g' \
-	      -e 's|@''HAVE_WCSNLEN''@|$(HAVE_WCSNLEN)|g' \
-	      -e 's|@''HAVE_WCSCPY''@|$(HAVE_WCSCPY)|g' \
-	      -e 's|@''HAVE_WCPCPY''@|$(HAVE_WCPCPY)|g' \
-	      -e 's|@''HAVE_WCSNCPY''@|$(HAVE_WCSNCPY)|g' \
-	      -e 's|@''HAVE_WCPNCPY''@|$(HAVE_WCPNCPY)|g' \
-	      -e 's|@''HAVE_WCSCAT''@|$(HAVE_WCSCAT)|g' \
-	      -e 's|@''HAVE_WCSNCAT''@|$(HAVE_WCSNCAT)|g' \
-	      -e 's|@''HAVE_WCSCMP''@|$(HAVE_WCSCMP)|g' \
-	      -e 's|@''HAVE_WCSNCMP''@|$(HAVE_WCSNCMP)|g' \
-	      -e 's|@''HAVE_WCSCASECMP''@|$(HAVE_WCSCASECMP)|g' \
-	      -e 's|@''HAVE_WCSNCASECMP''@|$(HAVE_WCSNCASECMP)|g' \
-	      -e 's|@''HAVE_WCSCOLL''@|$(HAVE_WCSCOLL)|g' \
-	      -e 's|@''HAVE_WCSXFRM''@|$(HAVE_WCSXFRM)|g' \
-	      -e 's|@''HAVE_WCSDUP''@|$(HAVE_WCSDUP)|g' \
-	      -e 's|@''HAVE_WCSCHR''@|$(HAVE_WCSCHR)|g' \
-	      -e 's|@''HAVE_WCSRCHR''@|$(HAVE_WCSRCHR)|g' \
-	      -e 's|@''HAVE_WCSCSPN''@|$(HAVE_WCSCSPN)|g' \
-	      -e 's|@''HAVE_WCSSPN''@|$(HAVE_WCSSPN)|g' \
-	      -e 's|@''HAVE_WCSPBRK''@|$(HAVE_WCSPBRK)|g' \
-	      -e 's|@''HAVE_WCSSTR''@|$(HAVE_WCSSTR)|g' \
-	      -e 's|@''HAVE_WCSTOK''@|$(HAVE_WCSTOK)|g' \
-	      -e 's|@''HAVE_WCSWIDTH''@|$(HAVE_WCSWIDTH)|g' \
-	      -e 's|@''HAVE_DECL_WCTOB''@|$(HAVE_DECL_WCTOB)|g' \
-	      -e 's|@''HAVE_DECL_WCWIDTH''@|$(HAVE_DECL_WCWIDTH)|g' \
-	  | \
-	  sed -e 's|@''REPLACE_MBSTATE_T''@|$(REPLACE_MBSTATE_T)|g' \
-	      -e 's|@''REPLACE_BTOWC''@|$(REPLACE_BTOWC)|g' \
-	      -e 's|@''REPLACE_WCTOB''@|$(REPLACE_WCTOB)|g' \
-	      -e 's|@''REPLACE_MBSINIT''@|$(REPLACE_MBSINIT)|g' \
-	      -e 's|@''REPLACE_MBRTOWC''@|$(REPLACE_MBRTOWC)|g' \
-	      -e 's|@''REPLACE_MBRLEN''@|$(REPLACE_MBRLEN)|g' \
-	      -e 's|@''REPLACE_MBSRTOWCS''@|$(REPLACE_MBSRTOWCS)|g' \
-	      -e 's|@''REPLACE_MBSNRTOWCS''@|$(REPLACE_MBSNRTOWCS)|g' \
-	      -e 's|@''REPLACE_WCRTOMB''@|$(REPLACE_WCRTOMB)|g' \
-	      -e 's|@''REPLACE_WCSRTOMBS''@|$(REPLACE_WCSRTOMBS)|g' \
-	      -e 's|@''REPLACE_WCSNRTOMBS''@|$(REPLACE_WCSNRTOMBS)|g' \
-	      -e 's|@''REPLACE_WCWIDTH''@|$(REPLACE_WCWIDTH)|g' \
-	      -e 's|@''REPLACE_WCSWIDTH''@|$(REPLACE_WCSWIDTH)|g' \
-	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
-	      -e '/definition of _GL_ARG_NONNULL/r $(ARG_NONNULL_H)' \
-	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)'; \
-	} > $@-t && \
-	mv $@-t $@
-MOSTLYCLEANFILES += wchar.h wchar.h-t
-
-EXTRA_DIST += wchar.in.h
-
-## end   gnulib module wchar
-
-## begin gnulib module wctype-h
-
-BUILT_SOURCES += wctype.h
-
-# We need the following in order to create <wctype.h> when the system
-# doesn't have one that works with the given compiler.
-wctype.h: wctype.in.h $(top_builddir)/config.status $(CXXDEFS_H) $(WARN_ON_USE_H)
-	$(AM_V_GEN)rm -f $@-t $@ && \
-	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
-	  sed -e 's|@''GUARD_PREFIX''@|GL|g' \
-	      -e 's/@''HAVE_WCTYPE_H''@/$(HAVE_WCTYPE_H)/g' \
-	      -e 's|@''INCLUDE_NEXT''@|$(INCLUDE_NEXT)|g' \
-	      -e 's|@''PRAGMA_SYSTEM_HEADER''@|@PRAGMA_SYSTEM_HEADER@|g' \
-	      -e 's|@''PRAGMA_COLUMNS''@|@PRAGMA_COLUMNS@|g' \
-	      -e 's|@''NEXT_WCTYPE_H''@|$(NEXT_WCTYPE_H)|g' \
-	      -e 's/@''GNULIB_ISWBLANK''@/$(GNULIB_ISWBLANK)/g' \
-	      -e 's/@''GNULIB_WCTYPE''@/$(GNULIB_WCTYPE)/g' \
-	      -e 's/@''GNULIB_ISWCTYPE''@/$(GNULIB_ISWCTYPE)/g' \
-	      -e 's/@''GNULIB_WCTRANS''@/$(GNULIB_WCTRANS)/g' \
-	      -e 's/@''GNULIB_TOWCTRANS''@/$(GNULIB_TOWCTRANS)/g' \
-	      -e 's/@''HAVE_ISWBLANK''@/$(HAVE_ISWBLANK)/g' \
-	      -e 's/@''HAVE_ISWCNTRL''@/$(HAVE_ISWCNTRL)/g' \
-	      -e 's/@''HAVE_WCTYPE_T''@/$(HAVE_WCTYPE_T)/g' \
-	      -e 's/@''HAVE_WCTRANS_T''@/$(HAVE_WCTRANS_T)/g' \
-	      -e 's/@''HAVE_WINT_T''@/$(HAVE_WINT_T)/g' \
-	      -e 's/@''REPLACE_ISWBLANK''@/$(REPLACE_ISWBLANK)/g' \
-	      -e 's/@''REPLACE_ISWCNTRL''@/$(REPLACE_ISWCNTRL)/g' \
-	      -e 's/@''REPLACE_TOWLOWER''@/$(REPLACE_TOWLOWER)/g' \
-	      -e '/definitions of _GL_FUNCDECL_RPL/r $(CXXDEFS_H)' \
-	      -e '/definition of _GL_WARN_ON_USE/r $(WARN_ON_USE_H)' \
-	      < $(srcdir)/wctype.in.h; \
-	} > $@-t && \
-	mv $@-t $@
-MOSTLYCLEANFILES += wctype.h wctype.h-t
-
-EXTRA_DIST += wctype.in.h
-
-## end   gnulib module wctype-h
-
-## begin gnulib module xalloc
-
-libgnu_la_SOURCES += xmalloc.c
-
-EXTRA_DIST += xalloc.h
-
-## end   gnulib module xalloc
-
-## begin gnulib module xalloc-die
-
-libgnu_la_SOURCES += xalloc-die.c
-
-## end   gnulib module xalloc-die
-
-## begin gnulib module xalloc-oversized
-
-
-EXTRA_DIST += xalloc-oversized.h
-
-## end   gnulib module xalloc-oversized
-
-## begin gnulib module xgetcwd
-
-libgnu_la_SOURCES += xgetcwd.c
-
-EXTRA_DIST += xgetcwd.h
-
-## end   gnulib module xgetcwd
-
-## begin gnulib module xsize
-
-libgnu_la_SOURCES += xsize.h
-
-## end   gnulib module xsize
-
-## begin gnulib module xstrndup
-
-libgnu_la_SOURCES += xstrndup.h xstrndup.c
-
-## end   gnulib module xstrndup
-
-
-mostlyclean-local: mostlyclean-generic
-	@for dir in '' $(MOSTLYCLEANDIRS); do \
-	  if test -n "$$dir" && test -d $$dir; then \
-	    echo "rmdir $$dir"; rmdir $$dir; \
-	  fi; \
-	done; \
-	:
diff --git a/libgui/Makefile.am b/libgui/Makefile.am
--- a/libgui/Makefile.am
+++ b/libgui/Makefile.am
@@ -17,24 +17,16 @@
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, see
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
 AUTOMAKE_OPTIONS = subdir-objects
 
-QT_INCDIR = @QT_INCDIR@
-
-QT_LIBDIR = @QT_LIBDIR@
-
-QT_LIBS = -lQtCore -lQtGui -lQtNetwork -lqscintilla2
-
-QT_LDFLAGS = -L$(QT_LIBDIR)
-
 MOC_CPPFLAGS =
 
 octlib_LTLIBRARIES = liboctgui.la
 
 EXTRA_DIST = default-qt-settings
 
 CLEANFILES =
 
diff --git a/libgui/default-qt-settings b/libgui/default-qt-settings
--- a/libgui/default-qt-settings
+++ b/libgui/default-qt-settings
@@ -1,14 +1,13 @@
 [General]
 connectOnStartup=true
 showMessageOfTheDay=true
 showTopic=true
 autoIdentification=false
-nickServPassword=
 useCustomFileEditor=false
 customFileEditor=emacs
 showFilenames=true
 showFileSize=false
 showFileType=false
 showLastModified=false
 showHiddenFiles=false
 useAlternatingRowColors=true
@@ -18,20 +17,55 @@ proxyHostName=none
 proxyPort=8080
 proxyUserName=
 proxyPassword=
 
 [editor]
 showLineNumbers=true
 highlightCurrentLine=true
 codeCompletion=true
-fontName=Ubuntu Mono
-fontSize=12
-shortWindowTitle=true
-longWindowTitle=true
+fontName=Courier
+fontSize=10
+longWindowTitle=false
+restoreSession=false
+savedSessionTabs=@Invalid()
 
 [terminal]
 fontSize=10
-fontName=Andale Mono
+fontName=Courier
+cursorBlinking=true
+cursorType=ibeam
 
 [MainWindow]
-geometry=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\0\0\0\x31\0\0\0\x18\0\0\x4\xff\0\0\x3\xff\0\0\0\0\0\0\0\0\xff\xff\xff\xfe\xff\xff\xff\xfe\0\0\0\0\x2\0)
-windowState=@ByteArray(\0\0\0\xff\0\0\0\0\xfd\0\0\0\x1\0\0\0\x1\0\0\x4\xcf\0\0\x3\x91\xfc\x2\0\0\0\x1\xfc\0\0\0\x41\0\0\x3\x91\0\0\x1\xc7\0\xff\xff\xff\xfc\x1\0\0\0\x3\xfc\0\0\0\0\0\0\x1.\0\0\0R\0\xff\xff\xff\xfc\x2\0\0\0\x2\xfb\0\0\0\x1a\0W\0o\0r\0k\0s\0p\0\x61\0\x63\0\x65\0V\0i\0\x65\0w\x1\0\0\0\x41\0\0\x1\xe8\0\0\0k\0\xff\xff\xff\xfb\0\0\0\"\0H\0i\0s\0t\0o\0r\0y\0\x44\0o\0\x63\0k\0W\0i\0\x64\0g\0\x65\0t\x1\0\0\x2/\0\0\x1\xa3\0\0\0\x8c\0\xff\xff\xff\xfc\0\0\x1\x34\0\0\x2\x81\0\0\x2\x81\0\0\x2\x81\xfa\0\0\0\0\x2\0\0\0\x2\xfb\0\0\0$\0T\0\x65\0r\0m\0i\0n\0\x61\0l\0\x44\0o\0\x63\0k\0W\0i\0\x64\0g\0\x65\0t\x1\0\0\0\0\xff\xff\xff\xff\0\0\x1\xa9\0\xff\xff\xff\xfb\0\0\0\x14\0\x46\0i\0l\0\x65\0\x45\0\x64\0i\0t\0o\0r\x1\0\0\x1\xf0\0\0\x1\xe2\0\0\0j\0\xff\xff\xff\xfb\0\0\0\x1e\0\x46\0i\0l\0\x65\0s\0\x44\0o\0\x63\0k\0W\0i\0\x64\0g\0\x65\0t\x1\0\0\x3\xbb\0\0\x1\x14\0\0\0P\0\xff\xff\xff\0\0\0\0\0\0\x3\x91\0\0\0\x4\0\0\0\x4\0\0\0\b\0\0\0\b\xfc\0\0\0\x1\0\0\0\x2\0\0\0\x1\xff\xff\xff\xff\x1\0\0\0\0\xff\xff\xff\xff\0\0\0\0\0\0\0\0)
+geometry=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\0\0\0\0\0\0\0\x18\0\0\x3G\0\0\x2\xe9\0\0\0\x1\0\0\0\x33\0\0\x3\x46\0\0\x2\xe8\0\0\0\0\0\0)
+windowState=@ByteArray(\0\0\0\xff\0\0\0\0\xfd\0\0\0\x1\0\0\0\x1\0\0\x3\x46\0\0\x2x\xfc\x2\0\0\0\x1\xfc\0\0\0(\0\0\x2x\0\0\x1\xc5\0\xff\xff\xff\xfc\x1\0\0\0\x2\xfc\0\0\0\0\0\0\0\xe8\0\0\0R\0\xff\xff\xff\xfc\x2\0\0\0\x3\xfb\0\0\0\x1e\0\x46\0i\0l\0\x65\0s\0\x44\0o\0\x63\0k\0W\0i\0\x64\0g\0\x65\0t\x1\0\0\0(\0\0\0\xc9\0\0\0\x8d\0\xff\xff\xff\xfb\0\0\0\x1a\0W\0o\0r\0k\0s\0p\0\x61\0\x63\0\x65\0V\0i\0\x65\0w\x1\0\0\0\xf7\0\0\0\xd7\0\0\0k\0\xff\xff\xff\xfb\0\0\0\"\0H\0i\0s\0t\0o\0r\0y\0\x44\0o\0\x63\0k\0W\0i\0\x64\0g\0\x65\0t\x1\0\0\x1\xd4\0\0\0\xcc\0\0\0\x8a\0\xff\xff\xff\xfc\0\0\0\xee\0\0\x2X\0\0\x2X\0\xff\xff\xff\xfa\0\0\0\0\x2\0\0\0\x3\xfb\0\0\0$\0T\0\x65\0r\0m\0i\0n\0\x61\0l\0\x44\0o\0\x63\0k\0W\0i\0\x64\0g\0\x65\0t\x1\0\0\0\0\xff\xff\xff\xff\0\0\x1\xa9\0\xff\xff\xff\xfb\0\0\0\x14\0\x46\0i\0l\0\x65\0\x45\0\x64\0i\0t\0o\0r\x1\0\0\0\0\xff\xff\xff\xff\0\0\0h\0\xff\xff\xff\xfb\0\0\0.\0\x44\0o\0\x63\0u\0m\0\x65\0n\0t\0\x61\0t\0i\0o\0n\0\x44\0o\0\x63\0k\0W\0i\0\x64\0g\0\x65\0t\x1\0\0\0\0\xff\xff\xff\xff\0\0\0\xac\0\xff\xff\xff\0\0\0\0\0\0\x2x\0\0\0\x4\0\0\0\x4\0\0\0\b\0\0\0\b\xfc\0\0\0\x1\0\0\0\x2\0\0\0\x1\xff\xff\xff\xff\x1\0\0\0\0\xff\xff\xff\xff\0\0\0\0\0\0\0\0)
+current_directory_list=@Invalid()
+
+[DockWidgets]
+TerminalDockWidget=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\0\0\0\xee\0\0\0(\0\0\x3\x45\0\0\x2\x83\0\0\0\xee\0\0\0(\0\0\x3\x45\0\0\x2\x83\0\0\0\0\0\0)
+TerminalDockWidgetFloating=false
+TerminalDockWidgetVisible=true
+WorkspaceView=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\0\0\0\0\0\0\0\xf7\0\0\0\xe7\0\0\x1\xcd\0\0\0\0\0\0\0\xf7\0\0\0\xe7\0\0\x1\xcd\0\0\0\0\0\0)
+WorkspaceViewFloating=false
+WorkspaceViewVisible=true
+HistoryDockWidget=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\0\0\0\0\0\0\x1\xd4\0\0\0\xe7\0\0\x2\x9f\0\0\0\0\0\0\x1\xd4\0\0\0\xe7\0\0\x2\x9f\0\0\0\0\0\0)
+HistoryDockWidgetFloating=false
+HistoryDockWidgetVisible=true
+FilesDockWidget=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\0\0\0\0\0\0\0(\0\0\0\xe7\0\0\0\xf0\0\0\0\0\0\0\0(\0\0\0\xe7\0\0\0\xf0\0\0\0\0\0\0)
+FilesDockWidgetFloating=false
+FilesDockWidgetVisible=true
+DocumentationDockWidget=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\xff\xff\xfb\xb3\xff\xff\xfb\xb1\xff\xff\xfe\v\xff\xff\xfe\v\xff\xff\xfb\xb3\xff\xff\xfb\xb1\xff\xff\xfe\v\xff\xff\xfe\v\0\0\0\0\0\0)
+DocumentationDockWidgetFloating=false
+DocumentationDockWidgetVisible=true
+FileEditor=@ByteArray(\x1\xd9\xd0\xcb\0\x1\0\0\xff\xff\xfb\xb3\xff\xff\xfb\xb1\xff\xff\xfe\v\xff\xff\xfe\v\xff\xff\xfb\xb3\xff\xff\xfb\xb1\xff\xff\xfe\v\xff\xff\xfe\v\0\0\0\0\0\0)
+FileEditorFloating=false
+FileEditorVisible=true
+
+[workspaceview]
+local_collapsed=false
+global_collapsed=false
+persistent_collapsed=false
+column_state=@ByteArray(\0\0\0\xff\0\0\0\0\0\0\0\x1\0\0\0\x1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1\x90\0\0\0\x4\x1\0\0\x1\0\0\0\0\0\0\0\0\0\0\0\0\x64\xff\xff\xff\xff\0\0\0\x81\0\0\0\0\0\0\0\x1\0\0\x1\x90\0\0\0\x4\0\0\0\0)
+
+[filesdockwidget]
+sort_files_by_column=0
+sort_files_by_order=0
+column_state=@ByteArray(\0\0\0\xff\0\0\0\0\0\0\0\x1\0\0\0\0\0\0\0\0\x1\0\0\0\0\0\0\0\0\0\0\0\x4\xe\0\0\0\x3\0\0\0\x3\0\0\0\x64\0\0\0\x2\0\0\0\x64\0\0\0\x1\0\0\0\x64\0\0\0\xd4\0\0\0\x4\x1\x1\0\x1\0\0\0\0\0\0\0\0\0\0\0\0\x64\xff\xff\xff\xff\0\0\0\x81\0\0\0\0\0\0\0\x2\0\0\0\xd4\0\0\0\x1\0\0\0\0\0\0\0\0\0\0\0\x3\0\0\0\0)
diff --git a/libgui/link-deps.mk b/libgui/link-deps.mk
--- a/libgui/link-deps.mk
+++ b/libgui/link-deps.mk
@@ -2,20 +2,20 @@ include $(top_srcdir)/libinterp/link-dep
 
 if AMCOND_ENABLE_DYNAMIC_LINKING
   LIBOCTGUI_LINK_DEPS =
 else
   LIBOCTGUI_LINK_DEPS = $(DLDFCN_LIBS)
 endif
 
 LIBOCTGUI_LINK_DEPS += \
-  $(QT_LIBS)
+  @QT_LIBS@
 
 LIBOCTGUI_LINK_OPTS = \
-  $(QT_LDFLAGS)
+  @QT_LDFLAGS@
 
 if AMCOND_LINK_ALL_DEPS
   LIBOCTGUI_LINK_DEPS += $(LIBOCTINTERP_LINK_DEPS)
   LIBOCTGUI_LINK_OPTS += $(LIBOCTINTERP_LINK_OPTS)
 
   OCTAVE_GUI_LINK_DEPS = $(LIBOCTGUI_LINK_DEPS)
   OCTAVE_GUI_LINK_OPTS = $(LIBOCTGUI_LINK_OPTS)
 endif
diff --git a/libgui/qterminal-module.mk b/libgui/qterminal-module.mk
--- a/libgui/qterminal-module.mk
+++ b/libgui/qterminal-module.mk
@@ -30,19 +30,17 @@ noinst_HEADERS += \
 qterminal_libqterminal_la_MOC = \
   qterminal/libqterminal/moc-QTerminal.cc \
   qterminal/libqterminal/moc-QTerminalInterface.cc
 
 nodist_qterminal_libqterminal_la_SOURCES = $(qterminal_libqterminal_la_MOC)
 
 qterminal_libqterminal_la_CPPFLAGS = \
   $(AM_CPPFLAGS) \
-  -I$(QT_INCDIR) \
-  -I$(QT_INCDIR)/QtCore \
-  -I$(QT_INCDIR)/QtGui \
+  @QT_CPPFLAGS@ \
   -I$(srcdir)/qterminal/libqterminal
 
 qterminal_libqterminal_la_CFLAGS = $(AM_CFLAGS)
 
 qterminal_libqterminal_la_CXXFLAGS = $(AM_CXXFLAGS)
 
 if WIN32_TERMINAL
 
@@ -51,17 +49,17 @@ qterminal_libqterminal_la_SOURCES = \
   qterminal/libqterminal/win32/QWinTerminalImpl.cpp
 
 qterminal_libqterminal_la_MOC += \
   qterminal/libqterminal/win32/moc-QWinTerminalImpl.cc
 
 qterminal_libqterminal_la_CPPFLAGS += -DUNICODE
 
 # This flag is required to let MOC know about Q_OS_WIN32.
-MOC_CPPFLAGS += -DWIN32
+MOC_CPPFLAGS += -DQ_OS_WIN32
 
 else
 
 qterminal_libqterminal_la_SOURCES = \
   qterminal/libqterminal/unix/BlockArray.cpp \
   qterminal/libqterminal/unix/Emulation.cpp \
   qterminal/libqterminal/unix/Filter.cpp \
   qterminal/libqterminal/unix/History.cpp \
diff --git a/libgui/qterminal/libqterminal/LineFont.src b/libgui/qterminal/libqterminal/LineFont.src
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/LineFont.src
@@ -0,0 +1,786 @@
+#2500: single horizontal line
+2500
+     
+     
+-----
+     
+     
+
+#2501: triple horizontal line
+2501
+     
+-----
+-----
+-----
+     
+
+#2502: single vertical line
+2502
+  |  
+  |  
+  |  
+  |  
+  |  
+
+#2503: triple vertical line
+2503
+ ||| 
+ ||| 
+ ||| 
+ ||| 
+ ||| 
+
+#2504-250B are dashed - not handled
+
+#250C: top-left corner (lines on bottom + right)
+250C
+     
+     
+  .--
+  |  
+  |  
+
+#250D: as above, but top line triple-width
+250D
+     
+  .--
+  .--
+  |--
+  |  
+
+#250E: now the vert line triple-width
+250E
+     
+     
+ ..--
+ ||| 
+ ||| 
+
+#250F: and now both lines triple-width
+250F
+     
+ .___
+ |.--
+ ||._
+ ||| 
+
+#2510: top-right corner
+2510
+     
+     
+--.  
+  |  
+  |  
+
+2511
+     
+==.  
+==.  
+==|  
+  | 
+
+2512
+     
+     
+==.. 
+ ||| 
+ ||| 
+
+2513
+     
+===. 
+==.| 
+=.|| 
+ ||| 
+
+#2514: bottom-left corner
+2514
+  |  
+  |  
+  .==
+     
+     
+
+2515
+  |  
+  |==
+  |==
+  ===
+     
+
+
+2516
+ ||| 
+ ||| 
+ |.==
+     
+     
+
+2517
+ ||| 
+ ||.=
+ |.==
+ .===
+     
+
+#2518: bottm-right corner
+2518
+  |  
+  |  
+==.  
+     
+     
+
+2519
+  |  
+==|  
+==|  
+===  
+     
+
+
+251A
+ ||| 
+ ||| 
+==== 
+     
+     
+
+251B
+ ||| 
+=.|| 
+==.| 
+===. 
+     
+
+#251C: Join of vertical line and one from the right
+251C
+  |  
+  |  
+  |==
+  |  
+  |  
+
+251D
+  |  
+  |==
+  |==
+  |==
+  |  
+
+251E
+ ||| 
+ ||| 
+ ||==
+  |  
+  |  
+
+251F
+  |  
+  |  
+ ||==
+ ||| 
+ ||| 
+
+
+2520
+ ||| 
+ ||| 
+ ||==
+ ||| 
+ ||| 
+
+2521
+ ||| 
+ |||=
+ ||==
+ .|==
+  |  
+
+2522
+  |  
+ .|==
+ ||==
+ |||=
+ ||| 
+
+2523
+ ||| 
+ ||.=
+ ||==
+ ||.=
+ ||| 
+
+#2524: Join of vertical line and one from the left
+2524
+  |  
+  |  
+==|  
+  |  
+  |  
+
+2525
+  |  
+==|  
+==|  
+==|  
+  |  
+
+2526
+ ||| 
+ ||| 
+==+| 
+  |  
+  |  
+
+2527
+  |  
+  |  
+==+| 
+ ||| 
+ ||| 
+
+2528
+ ||| 
+ ||| 
+==+| 
+ ||| 
+ ||| 
+
+2529
+ ||| 
+=+|| 
+==+| 
+===+ 
+  |  
+
+252A
+  |  
+=+|| 
+==+| 
+===+ 
+ ||| 
+
+252B
+ |||
+=+|| 
+==+| 
+=+|| 
+ |||
+
+#252C: horizontal line joined to from below
+252C
+     
+     
+=====
+  |  
+  |  
+
+252D
+     
+===  
+==|==
+==|  
+  |  
+
+252E
+     
+  ===
+==|==
+  |==
+  |  
+
+252F
+     
+==+==
+==|==
+==|==
+  |  
+
+2530
+     
+=====
+=====
+==|==
+  |  
+
+2531
+     
+===| 
+==||=
+=||| 
+ ||| 
+
+2532
+     
+ |===
+=||==
+ ||==
+ ||  
+
+2533
+     
+=====
+==|==
+=+|+=
+ ||| 
+
+#2534: bottom line, connected to from top
+2534
+  |
+  |
+=====
+     
+     
+
+2535
+  |
+==|
+=====
+===  
+    
+
+2536
+  |
+  |==
+=====
+  ===
+     
+
+2537
+  |
+==|==
+=====
+=====
+     
+
+2538
+ |||
+ |||
+=====
+     
+     
+
+2539
+ |||
+==||
+=====
+===| 
+    
+
+
+253A
+ |||
+ ||==
+=|===
+ |===
+     
+
+253B
+ |||
+==|==
+=====
+=====
+     
+
+#253C: vertical + horizontal lines intersecting
+253C
+  |  
+  |  
+=====
+  |  
+  |
+
+253D
+  |  
+==|  
+=====
+==|  
+  |
+
+253E
+  |  
+  |==
+=====
+  |==
+  |
+
+253F
+  |  
+==|==
+=====
+==|==
+  |
+
+2540
+ ||| 
+ ||| 
+=====
+  |  
+  |
+
+2541
+  |  
+  |  
+=====
+ ||| 
+ |||
+
+2542
+ ||| 
+ ||| 
+=====
+ ||| 
+ |||
+
+2543
+ ||| 
+=|||
+=====
+==|+ 
+  |
+
+2544
+ ||| 
+ ||==
+=====
+  |==
+  |
+
+2545
+  |
+==|+ 
+=====
+=|||
+ ||| 
+
+2546
+  |
+  |==
+=====
+ ||==
+ ||| 
+
+2547
+ ||| 
+=|||=
+=====
+=|||=
+  | 
+
+2548
+  |  
+=|||=
+=====
+=|||=
+ |||
+
+2549
+ ||| 
+=||| 
+=====
+=||| 
+ |||
+
+254A
+ ||| 
+ |||=
+=====
+ |||=
+ |||
+
+254B
+ ||| 
+=|||=
+=====
+=|||=
+ |||
+
+#254C-254F are dashed
+2550
+     
+_____
+     
+_____
+     
+
+2551
+ | | 
+ | |
+ | |
+ | |
+ | |
+
+2552
+     
+  |--
+  |
+  |--
+  |
+
+2553
+     
+     
+ ----
+ | | 
+ | | 
+
+2554
+     
+ +---
+ |
+ + +-
+ | |
+
+2555
+     
+--+
+  |  
+--+  
+  |  
+
+2556
+    
+    
+-+-+
+ | |
+ | |
+
+2557
+     
+---+ 
+   | 
+-+ |
+ | |
+
+2558
+  |
+  +--
+  |
+  +--
+
+2559
+ | | 
+ | | 
+ +-+-
+     
+     
+
+255A
+ | | 
+ | +-
+ |   
+ +---
+     
+
+255B
+  |  
+--+  
+  | 
+--+  
+     
+
+255C
+ | | 
+ | | 
+-+-+ 
+    
+
+255D
+ | | 
+-+ | 
+   |
+---+
+    
+
+255E
+  |
+  +--
+  |
+  +--
+  |
+
+255F
+ | |
+ | |
+ | +-
+ | |
+ | |
+
+2560
+ | |
+ | +-
+ | |
+ | +-
+ | |
+
+2561
+  |
+--+
+  |
+--+
+  |
+
+2562
+ | | 
+ | |
+-+ +
+ | |
+ | |
+
+2563
+ | |
+-+ |
+   |
+-+ |
+ | |
+
+2564
+     
+-----
+     
+--+--
+  |
+
+2565
+     
+     
+-+-+-
+ | | 
+ | |
+
+2566
+     
+-----
+     
+-+ +-
+ | |
+
+2567
+  |  
+--+--
+     
+-----
+     
+
+2568
+ | | 
+ | | 
+-+-+-
+     
+     
+
+2569
+ | | 
+-+ +-
+     
+-----
+     
+
+256A
+  |  
+--+--
+  |  
+--+--
+  |
+
+256B
+ | | 
+ | | 
+-+-+-
+ | | 
+ | | 
+
+256C
+ | | 
+-+ +-
+
+-+ +-
+ | | 
+
+#256F-2570 are curly,
+#2571-2573 are slashes and X
+
+2574
+     
+     
+___  
+     
+     
+
+2575
+  |  
+  |  
+  |  
+     
+    
+
+2576
+     
+     
+  ___
+     
+     
+
+2577
+     
+    
+  |  
+  |  
+  |  
+
+2578
+     
+___  
+___  
+___  
+     
+
+2579
+ ||| 
+ ||| 
+ ||| 
+     
+    
+
+257A
+     
+  ___
+  ___
+  ___
+     
+
+257B
+     
+    
+ ||| 
+ ||| 
+ ||| 
+
+257C
+     
+  ___
+_____
+  ___
+     
+
+257D
+  |  
+  |  
+ ||| 
+ ||| 
+ ||| 
+
+257E
+     
+___  
+_____
+___  
+     
+
+257F
+ ||| 
+ ||| 
+ ||| 
+  |  
+  |  
diff --git a/libgui/qterminal/libqterminal/QTerminal b/libgui/qterminal/libqterminal/QTerminal
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/QTerminal
@@ -0,0 +1,23 @@
+/*
+
+Copyright (C) 2012 Michael Goffioul.
+Copyright (C) 2012 Jacob Dawid.
+
+This file is part of QTerminal.
+
+Foobar is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+QTerminal is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Foobar.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include "QTerminal.h"
diff --git a/libgui/qterminal/libqterminal/QTerminal.h b/libgui/qterminal/libqterminal/QTerminal.h
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/QTerminal.h
@@ -0,0 +1,50 @@
+/*
+
+Copyright (C) 2012 Michael Goffioul.
+Copyright (C) 2012 Jacob Dawid.
+
+This file is part of QTerminal.
+
+Foobar is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+QTerminal is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Foobar.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef QTERMINAL_H
+#define QTERMINAL_H
+
+#include <QtGlobal>
+
+#ifdef Q_OS_WIN32
+    #include "win32/QWinTerminalImpl.h"
+    class QTerminal : public QWinTerminalImpl
+    {
+        Q_OBJECT
+    public:
+        QTerminal(QWidget *parent = 0)
+            : QWinTerminalImpl(parent) { }
+        ~QTerminal() { }
+    };
+#else
+    #include "unix/QUnixTerminalImpl.h"
+    class QTerminal : public QUnixTerminalImpl
+    {
+        Q_OBJECT
+    public:
+        QTerminal(QWidget *parent = 0)
+            : QUnixTerminalImpl(parent) { }
+        ~QTerminal() { }
+    };
+#endif
+
+#endif // QTERMINAL_H
diff --git a/libgui/qterminal/libqterminal/QTerminalInterface.h b/libgui/qterminal/libqterminal/QTerminalInterface.h
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/QTerminalInterface.h
@@ -0,0 +1,77 @@
+/*
+
+Copyright (C) 2012 Michael Goffioul.
+Copyright (C) 2012 Jacob Dawid.
+
+This file is part of QTerminal.
+
+Foobar is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+QTerminal is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Foobar.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef QTERMINALINTERFACE_H
+#define QTERMINALINTERFACE_H
+
+#include <QWidget>
+#include <QMenu>
+
+class QTerminalInterface : public QWidget
+{
+    Q_OBJECT
+public:
+    QTerminalInterface(QWidget *parent = 0) : QWidget(parent) {
+      connect (this, SIGNAL(customContextMenuRequested(QPoint)),
+               this, SLOT(handleCustomContextMenuRequested(QPoint)));
+
+      setContextMenuPolicy (Qt::CustomContextMenu);
+
+      _contextMenu = new QMenu (this);
+      QAction *copyAction  = _contextMenu->addAction ("Copy");
+      QAction *pasteAction = _contextMenu->addAction ("Paste");
+
+      connect (copyAction, SIGNAL (triggered()), this, SLOT (copyClipboard()));
+      connect (pasteAction, SIGNAL (triggered()), this, SLOT (pasteClipboard()));
+    }
+    virtual ~QTerminalInterface() { }
+
+    virtual void setTerminalFont(const QFont& font) = 0;
+    virtual void setSize(int h, int v) = 0;
+    virtual void sendText(const QString& text) = 0;
+
+    enum CursorType {
+      UnderlineCursor,
+      BlockCursor,
+      IBeamCursor
+    };
+
+    virtual void setCursorType(CursorType type, bool blinking) {
+        // Provide empty default impl in order to avoid conflicts with the win impl.
+        Q_UNUSED(type);
+        Q_UNUSED(blinking);
+    }
+
+public slots:
+    virtual void copyClipboard() = 0;
+    virtual void pasteClipboard() = 0;
+
+    virtual void handleCustomContextMenuRequested(QPoint at) {
+      _contextMenu->move (mapToGlobal(at));
+      _contextMenu->show ();
+    }
+
+private:
+    QMenu *_contextMenu;
+};
+
+#endif // QTERMINALINTERFACE_H
diff --git a/libgui/qterminal/libqterminal/README b/libgui/qterminal/libqterminal/README
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/README
@@ -0,0 +1,7 @@
+lib.pro is a *.pro-file for qmake
+
+It produces static lib (libqtermwidget.a) only. 
+For creating shared lib (*.so) uncomment "dll" in "CONFIG" line in *.pro-file
+
+Library was tested both with HAVE_POSIX_OPENPT and HAVE_GETPT precompiler directives, 
+defined in "DEFINES" line. You should select variant which would be correct for your system.
\ No newline at end of file
diff --git a/libgui/qterminal/libqterminal/default.keytab b/libgui/qterminal/libqterminal/default.keytab
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/default.keytab
@@ -0,0 +1,128 @@
+# [README.default.Keytab] Buildin Keyboard Table
+#
+# To customize your keyboard, copy this file to something
+# ending with .keytab and change it to meet you needs.
+# Please read the README.KeyTab and the README.keyboard
+# in this case.
+#
+# --------------------------------------------------------------
+
+keyboard "Default (XFree 4)"
+
+# --------------------------------------------------------------
+#
+# Note that this particular table is a "risc" version made to
+# ease customization without bothering with obsolete details.
+# See VT100.keytab for the more hairy stuff.
+#
+# --------------------------------------------------------------
+
+# common keys
+
+key Escape             : "\E"
+
+key Tab   -Shift       : "\t"
+key Tab   +Shift+Ansi  : "\E[Z"
+key Tab   +Shift-Ansi  : "\t"
+key Backtab     +Ansi  : "\E[Z"
+key Backtab     -Ansi  : "\t"
+
+key Return-Shift-NewLine : "\r"
+key Return-Shift+NewLine : "\r\n"
+
+key Return+Shift         : "\EOM"
+
+# Backspace and Delete codes are preserving CTRL-H.
+
+key Backspace      : "\x7f"
+
+# Arrow keys in VT52 mode
+# shift up/down are reserved for scrolling.
+# shift left/right are reserved for switching between tabs (this is hardcoded).
+
+key Up   -Shift-Ansi : "\EA"
+key Down -Shift-Ansi : "\EB"
+key Right-Shift-Ansi : "\EC"
+key Left -Shift-Ansi : "\ED"
+
+# Arrow keys in ANSI mode with Application - and Normal Cursor Mode)
+
+key Up    -Shift-AnyMod+Ansi+AppCuKeys           : "\EOA"
+key Down  -Shift-AnyMod+Ansi+AppCuKeys           : "\EOB"
+key Right -Shift-AnyMod+Ansi+AppCuKeys           : "\EOC"
+key Left  -Shift-AnyMod+Ansi+AppCuKeys           : "\EOD"
+
+key Up    -Shift-AnyMod+Ansi-AppCuKeys           : "\E[A"
+key Down  -Shift-AnyMod+Ansi-AppCuKeys           : "\E[B"
+key Right -Shift-AnyMod+Ansi-AppCuKeys           : "\E[C"
+key Left  -Shift-AnyMod+Ansi-AppCuKeys           : "\E[D"
+
+key Up    -Shift+AnyMod+Ansi                     : "\E[1;*A"
+key Down  -Shift+AnyMod+Ansi                     : "\E[1;*B"
+key Right -Shift+AnyMod+Ansi                     : "\E[1;*C"
+key Left  -Shift+AnyMod+Ansi                     : "\E[1;*D"
+
+# other grey PC keys
+
+key Enter+NewLine : "\r\n"
+key Enter-NewLine : "\r"
+
+key Home        -AnyMod     -AppCuKeys           : "\E[H"  
+key End         -AnyMod     -AppCuKeys           : "\E[F"  
+key Home        -AnyMod     +AppCuKeys           : "\EOH"  
+key End         -AnyMod     +AppCuKeys           : "\EOF"  
+key Home        +AnyMod                          : "\E[1;*H"
+key End         +AnyMod                          : "\E[1;*F"
+
+key Insert      -AnyMod                          : "\E[2~"
+key Delete      -AnyMod                          : "\E[3~"
+key Insert      +AnyMod                          : "\E[2;*~"
+key Delete      +AnyMod                          : "\E[3;*~"
+
+key Prior -Shift-AnyMod                          : "\E[5~"
+key Next  -Shift-AnyMod                          : "\E[6~"
+key Prior -Shift+AnyMod                          : "\E[5;*~"
+key Next  -Shift+AnyMod                          : "\E[6;*~"
+
+# Function keys
+key F1          -AnyMod                          : "\EOP"
+key F2          -AnyMod                          : "\EOQ"
+key F3          -AnyMod                          : "\EOR"
+key F4          -AnyMod                          : "\EOS"
+key F5          -AnyMod                          : "\E[15~"
+key F6          -AnyMod                          : "\E[17~"
+key F7          -AnyMod                          : "\E[18~"
+key F8          -AnyMod                          : "\E[19~"
+key F9          -AnyMod                          : "\E[20~"
+key F10         -AnyMod                          : "\E[21~"
+key F11         -AnyMod                          : "\E[23~"
+key F12         -AnyMod                          : "\E[24~"
+
+key F1          +AnyMod                          : "\EO*P"
+key F2          +AnyMod                          : "\EO*Q"
+key F3          +AnyMod                          : "\EO*R"
+key F4          +AnyMod                          : "\EO*S"
+key F5          +AnyMod                          : "\E[15;*~"
+key F6          +AnyMod                          : "\E[17;*~"
+key F7          +AnyMod                          : "\E[18;*~"
+key F8          +AnyMod                          : "\E[19;*~"
+key F9          +AnyMod                          : "\E[20;*~"
+key F10         +AnyMod                          : "\E[21;*~"
+key F11         +AnyMod                          : "\E[23;*~"
+key F12         +AnyMod                          : "\E[24;*~"
+
+# Work around dead keys
+
+key Space +Control : "\x00"
+
+# Some keys are used by konsole to cause operations.
+# The scroll* operations refer to the history buffer.
+
+key Up    +Shift-AppScreen  : scrollLineUp
+key Prior +Shift-AppScreen  : scrollPageUp
+key Down  +Shift-AppScreen  : scrollLineDown
+key Next  +Shift-AppScreen  : scrollPageDown
+
+key ScrollLock     : scrollLock
+
+# keypad characters are not offered differently by Qt.
diff --git a/libgui/qterminal/libqterminal/kb-layouts/default.keytab b/libgui/qterminal/libqterminal/kb-layouts/default.keytab
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/kb-layouts/default.keytab
@@ -0,0 +1,133 @@
+# [README.default.Keytab] Buildin Keyboard Table
+#
+# To customize your keyboard, copy this file to something
+# ending with .keytab and change it to meet you needs.
+# Please read the README.KeyTab and the README.keyboard
+# in this case.
+#
+# --------------------------------------------------------------
+
+keyboard "Default (XFree 4)"
+
+# --------------------------------------------------------------
+#
+# Note that this particular table is a "risc" version made to
+# ease customization without bothering with obsolete details.
+# See VT100.keytab for the more hairy stuff.
+#
+# --------------------------------------------------------------
+
+# common keys
+
+key Escape             : "\E"
+
+key Tab   -Shift       : "\t"
+key Tab   +Shift+Ansi  : "\E[Z"
+key Tab   +Shift-Ansi  : "\t"
+key Backtab     +Ansi  : "\E[Z"
+key Backtab     -Ansi  : "\t"
+
+key Return-Shift-NewLine : "\r"
+key Return-Shift+NewLine : "\r\n"
+
+key Return+Shift         : "\EOM"
+
+# Backspace and Delete codes are preserving CTRL-H.
+
+key Backspace      : "\x7f"
+
+# Arrow keys in VT52 mode
+# shift up/down are reserved for scrolling.
+# shift left/right are reserved for switching between tabs (this is hardcoded).
+
+key Up   -Shift-Ansi : "\EA"
+key Down -Shift-Ansi : "\EB"
+key Right-Shift-Ansi : "\EC"
+key Left -Shift-Ansi : "\ED"
+
+# Arrow keys in ANSI mode with Application - and Normal Cursor Mode)
+
+key Up    -Shift-AnyMod+Ansi+AppCuKeys           : "\EOA"
+key Down  -Shift-AnyMod+Ansi+AppCuKeys           : "\EOB"
+key Right -Shift-AnyMod+Ansi+AppCuKeys           : "\EOC"
+key Left  -Shift-AnyMod+Ansi+AppCuKeys           : "\EOD"
+
+key Up    -Shift-AnyMod+Ansi-AppCuKeys           : "\E[A"
+key Down  -Shift-AnyMod+Ansi-AppCuKeys           : "\E[B"
+key Right -Shift-AnyMod+Ansi-AppCuKeys           : "\E[C"
+key Left  -Shift-AnyMod+Ansi-AppCuKeys           : "\E[D"
+
+key Up    -Shift+AnyMod+Ansi                     : "\E[1;*A"
+key Down  -Shift+AnyMod+Ansi                     : "\E[1;*B"
+key Right -Shift+AnyMod+Ansi                     : "\E[1;*C"
+key Left  -Shift+AnyMod+Ansi                     : "\E[1;*D"
+
+# other grey PC keys
+
+key Enter+NewLine : "\r\n"
+key Enter-NewLine : "\r"
+
+key Home        -AnyMod     -AppCuKeys           : "\E[H"  
+key End         -AnyMod     -AppCuKeys           : "\E[F"  
+key Home        -AnyMod     +AppCuKeys           : "\EOH"  
+key End         -AnyMod     +AppCuKeys           : "\EOF"  
+key Home        +AnyMod                          : "\E[1;*H"
+key End         +AnyMod                          : "\E[1;*F"
+
+key Insert      -AnyMod                          : "\E[2~"
+key Delete      -AnyMod                          : "\E[3~"
+key Insert      +AnyMod                          : "\E[2;*~"
+key Delete      +AnyMod                          : "\E[3;*~"
+
+key Prior -Shift-AnyMod                          : "\E[5~"
+key Next  -Shift-AnyMod                          : "\E[6~"
+key Prior -Shift+AnyMod                          : "\E[5;*~"
+key Next  -Shift+AnyMod                          : "\E[6;*~"
+
+# Function keys
+key F1          -AnyMod                          : "\EOP"
+key F2          -AnyMod                          : "\EOQ"
+key F3          -AnyMod                          : "\EOR"
+key F4          -AnyMod                          : "\EOS"
+key F5          -AnyMod                          : "\E[15~"
+key F6          -AnyMod                          : "\E[17~"
+key F7          -AnyMod                          : "\E[18~"
+key F8          -AnyMod                          : "\E[19~"
+key F9          -AnyMod                          : "\E[20~"
+key F10         -AnyMod                          : "\E[21~"
+key F11         -AnyMod                          : "\E[23~"
+key F12         -AnyMod                          : "\E[24~"
+
+key F1          +AnyMod                          : "\EO*P"
+key F2          +AnyMod                          : "\EO*Q"
+key F3          +AnyMod                          : "\EO*R"
+key F4          +AnyMod                          : "\EO*S"
+key F5          +AnyMod                          : "\E[15;*~"
+key F6          +AnyMod                          : "\E[17;*~"
+key F7          +AnyMod                          : "\E[18;*~"
+key F8          +AnyMod                          : "\E[19;*~"
+key F9          +AnyMod                          : "\E[20;*~"
+key F10         +AnyMod                          : "\E[21;*~"
+key F11         +AnyMod                          : "\E[23;*~"
+key F12         +AnyMod                          : "\E[24;*~"
+
+# Work around dead keys
+
+key Space +Control : "\x00"
+
+# Some keys are used by konsole to cause operations.
+# The scroll* operations refer to the history buffer.
+
+key Up    +Shift-AppScreen  : scrollLineUp
+key Prior +Shift-AppScreen  : scrollPageUp
+key Down  +Shift-AppScreen  : scrollLineDown
+key Next  +Shift-AppScreen  : scrollPageDown
+
+#key Up    +Shift  : scrollLineUp
+#key Prior +Shift  : scrollPageUp
+#key Down  +Shift  : scrollLineDown
+#key Next  +Shift  : scrollPageDown
+
+key ScrollLock     : scrollLock
+
+# keypad characters are not offered differently by Qt.
diff --git a/libgui/qterminal/libqterminal/kb-layouts/linux.keytab b/libgui/qterminal/libqterminal/kb-layouts/linux.keytab
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/kb-layouts/linux.keytab
@@ -0,0 +1,133 @@
+# [linux.keytab] Konsole Keyboard Table (Linux console keys)
+#
+# --------------------------------------------------------------
+
+# NOT TESTED, MAY NEED SOME CLEANUPS
+keyboard "Linux console"
+
+# --------------------------------------------------------------
+#
+# This configuration table allows to customize the
+# meaning of the keys.
+#
+# The syntax is that each entry has the form : 
+#
+#   "key" Keyname { ("+"|"-") Modename } ":" (String|Operation)
+#
+# Keynames are those defined in <qnamespace.h> with the
+# "Qt::Key_" removed. (We'd better insert the list here)
+#
+# Mode names are : 
+#
+# - Shift
+# - Alt
+# - Control
+#
+#   The VT100 emulation has two modes that can affect the
+#   sequences emitted by certain keys. These modes are
+#   under control of the client program.
+#   
+# - Newline     : effects Return and Enter key.
+# - Application : effects Up and Down key.
+#
+# - Ansi        : effects Up and Down key (This is for VT52, really).
+#
+# Operations are
+#
+# - scrollUpLine
+# - scrollUpPage
+# - scrollDownLine
+# - scrollDownPage
+#
+# - emitSelection
+#
+# If the key is not found here, the text of the
+# key event as provided by QT is emitted, possibly
+# preceeded by ESC if the Alt key is pressed.
+#
+# --------------------------------------------------------------
+
+key Escape : "\E"
+key Tab    : "\t"
+
+# VT100 can add an extra \n after return.
+# The NewLine mode is set by an escape sequence.
+
+key Return-NewLine : "\r"  
+key Return+NewLine : "\r\n"
+
+# Some desperately try to save the ^H.
+
+key Backspace : "\x7f"
+key Delete    : "\E[3~"
+
+# These codes are for the VT52 mode of VT100
+# The Ansi mode (i.e. VT100 mode) is set by
+# an escape sequence
+
+key Up   -Shift-Ansi : "\EA"
+key Down -Shift-Ansi : "\EB"
+key Right-Shift-Ansi : "\EC"
+key Left -Shift-Ansi : "\ED"
+
+# VT100 emits a mode bit together
+# with the arrow keys.The AppCuKeys
+# mode is set by an escape sequence.
+
+key Up   -Shift+Ansi+AppCuKeys : "\EOA"
+key Down -Shift+Ansi+AppCuKeys : "\EOB"
+key Right-Shift+Ansi+AppCuKeys : "\EOC"
+key Left -Shift+Ansi+AppCuKeys : "\EOD"
+
+key Up   -Shift+Ansi-AppCuKeys : "\E[A"
+key Down -Shift+Ansi-AppCuKeys : "\E[B"
+key Right-Shift+Ansi-AppCuKeys : "\E[C"
+key Left -Shift+Ansi-AppCuKeys : "\E[D"
+
+# linux functions keys F1-F5 differ from xterm
+
+key F1 : "\E[[A" 
+key F2 : "\E[[B" 
+key F3 : "\E[[C" 
+key F4 : "\E[[D" 
+key F5 : "\E[[E" 
+
+key F6     : "\E[17~" 
+key F7     : "\E[18~" 
+key F8     : "\E[19~" 
+key F9     : "\E[20~" 
+key F10    : "\E[21~" 
+key F11    : "\E[23~" 
+key F12    : "\E[24~" 
+
+key Home   : "\E[1~"  
+key End    : "\E[4~"  
+
+key Prior -Shift : "\E[5~"  
+key Next  -Shift : "\E[6~"  
+key Insert-Shift : "\E[2~"  
+
+# Keypad-Enter. See comment on Return above.
+
+key Enter+NewLine : "\r\n"
+key Enter-NewLine : "\r"  
+
+key Space +Control : "\x00"
+
+# some of keys are used by konsole.
+
+key Up    +Shift   : scrollLineUp
+key Prior +Shift   : scrollPageUp
+key Down  +Shift   : scrollLineDown
+key Next  +Shift   : scrollPageDown
+
+key ScrollLock     : scrollLock
+
+#----------------------------------------------------------
+
+# keypad characters as offered by Qt
+# cannot be recognized as such.
+
+#----------------------------------------------------------
+
+# Following other strings as emitted by konsole.
diff --git a/libgui/qterminal/libqterminal/kb-layouts/vt420pc.keytab b/libgui/qterminal/libqterminal/kb-layouts/vt420pc.keytab
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/kb-layouts/vt420pc.keytab
@@ -0,0 +1,163 @@
+# [vt420pc.keytab] Konsole Keyboard Table (VT420pc keys)
+# adapted by ferdinand gassauer f.gassauer@aon.at
+# Nov 2000
+#
+################################################################
+#
+# The escape sequences emmited by the 
+# keys Shift+F1 to Shift+F12 might not fit your needs
+#
+################# IMPORTANT NOTICE #############################
+# the key bindings (Kcontrol -> look and feel -> keybindgs) 
+# overrule the settings in this file. The key bindings might be 
+# changed by the user WITHOUT notification of the maintainer of
+# the keytab file. Konsole will not work as expected by 
+# the maintainer of the keytab file.
+################################################################
+#
+# --------------------------------------------------------------
+
+keyboard "DEC VT420 Terminal"
+
+# --------------------------------------------------------------
+#
+# This configuration table allows to customize the
+# meaning of the keys.
+#
+# The syntax is that each entry has the form : 
+#
+#   "key" Keyname { ("+"|"-") Modename } ":" (String|Operation)
+#
+# Keynames are those defined in <qnamespace.h> with the
+# "Qt::Key_" removed. (We'd better insert the list here)
+#
+# Mode names are : 
+#
+# - Shift
+# - Alt
+# - Control
+#
+#   The VT100 emulation has two modes that can affect the
+#   sequences emitted by certain keys. These modes are
+#   under control of the client program.
+#   
+# - Newline     : effects Return and Enter key.
+# - Application : effects Up and Down key.
+#
+# - Ansi        : effects Up and Down key (This is for VT52, really).
+#
+# Operations are
+#
+# - scrollUpLine
+# - scrollUpPage
+# - scrollDownLine
+# - scrollDownPage
+#
+# - emitSelection
+#
+# If the key is not found here, the text of the
+# key event as provided by QT is emitted, possibly
+# preceeded by ESC if the Alt key is pressed.
+#
+# --------------------------------------------------------------
+
+key Escape : "\E"
+key Tab    : "\t"
+key Backtab: "\E[Z"
+
+# VT100 can add an extra \n after return.
+# The NewLine mode is set by an escape sequence.
+
+key Return-NewLine : "\r"  
+key Return+NewLine : "\r\n"
+
+# Some desperately try to save the ^H.
+# may be not everyone wants this
+
+key Backspace : "\x08"  # Control H
+key Delete    : "\x7f"
+
+# These codes are for the VT420pc
+# The Ansi mode (i.e. VT100 mode) is set by
+# an escape sequence
+
+key Up   -Shift-Ansi : "\EA"
+key Down -Shift-Ansi : "\EB"
+key Right-Shift-Ansi : "\EC"
+key Left -Shift-Ansi : "\ED"
+
+# VT100 emits a mode bit together
+# with the arrow keys.The AppCuKeys
+# mode is set by an escape sequence.
+
+key Up   -Shift+Ansi+AppCuKeys : "\EOA"
+key Down -Shift+Ansi+AppCuKeys : "\EOB"
+key Right-Shift+Ansi+AppCuKeys : "\EOC"
+key Left -Shift+Ansi+AppCuKeys : "\EOD"
+
+key Up   -Shift+Ansi-AppCuKeys : "\E[A"
+key Down -Shift+Ansi-AppCuKeys : "\E[B"
+key Right-Shift+Ansi-AppCuKeys : "\E[C"
+key Left -Shift+Ansi-AppCuKeys : "\E[D"
+
+# function keys 
+
+key F1 -Shift    : "\E[11~"  
+key F2 -Shift    : "\E[12~"
+key F3 -Shift    : "\E[13~"
+key F4 -Shift    : "\E[14~"
+key F5 -Shift    : "\E[15~"
+key F6 -Shift    : "\E[17~"
+key F7 -Shift    : "\E[18~"
+key F8 -Shift    : "\E[19~"
+key F9 -Shift    : "\E[20~"
+key F10-Shift    : "\E[21~"
+key F11-Shift    : "\E[23~"
+key F12-Shift    : "\E[24~"  
+#
+# Shift F1-F12
+#
+key F1 +Shift    : "\E[11;2~"
+key F2 +Shift    : "\E[12;2~"
+key F3 +Shift    : "\E[13;2~"
+key F4 +Shift    : "\E[14;2~"
+key F5 +Shift    : "\E[15;2~"
+key F6 +Shift    : "\E[17;2~" 
+key F7 +Shift    : "\E[18;2~" 
+key F8 +Shift    : "\E[19;2~" 
+key F9 +Shift    : "\E[20;2~" 
+key F10+Shift    : "\E[21;2~" 
+key F11+Shift    : "\E[23;2~" 
+key F12+Shift    : "\E[24;2~" 
+
+key Home   : "\E[H"  
+key End    : "\E[F"  
+
+key Prior -Shift : "\E[5~"  
+key Next  -Shift : "\E[6~"  
+key Insert-Shift : "\E[2~"  
+
+# Keypad-Enter. See comment on Return above.
+
+key Enter+NewLine : "\r\n"
+key Enter-NewLine : "\r"  
+
+key Space +Control : "\x00"
+
+# some of keys are used by konsole.
+
+key Up    +Shift   : scrollLineUp
+key Prior +Shift   : scrollPageUp
+key Down  +Shift   : scrollLineDown
+key Next  +Shift   : scrollPageDown
+
+key ScrollLock     : scrollLock
+
+#----------------------------------------------------------
+
+# keypad characters as offered by Qt
+# cannot be recognized as such.
+
+#----------------------------------------------------------
+
+# Following other strings as emitted by konsole.
diff --git a/libgui/qterminal/libqterminal/libqterminal.pro b/libgui/qterminal/libqterminal/libqterminal.pro
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/libqterminal.pro
@@ -0,0 +1,68 @@
+TEMPLATE	= lib
+VERSION		= 0.1.0
+TARGET		= qterminal
+
+CONFIG		+= qt staticlib
+
+QT += core gui
+
+INCLUDEPATH	+= .
+
+unix {
+
+DEFINES 	+= HAVE_POSIX_OPENPT HAVE_PTY_H HAVE_OPENPTY
+#or DEFINES 	+= HAVE_GETPT
+
+HEADERS  = unix/BlockArray.h \
+           unix/Character.h \
+           unix/CharacterColor.h \
+           unix/Emulation.h \
+           unix/ExtendedDefaultTranslator.h \
+           unix/Filter.h \
+           unix/History.h \
+           unix/KeyboardTranslator.h \
+           unix/konsole_wcwidth.h \
+           unix/kpty.h \
+           unix/kpty_p.h \
+           unix/LineFont.h \
+           unix/QUnixTerminalImpl.h \
+           unix/Screen.h \
+           unix/ScreenWindow.h \
+           unix/TerminalCharacterDecoder.h \
+           unix/Vt102Emulation.h \
+         unix/SelfListener.h \
+           unix/TerminalModel.h \
+           unix/TerminalView.h
+
+SOURCES  = unix/BlockArray.cpp \
+           unix/Emulation.cpp \
+           unix/Filter.cpp \
+           unix/History.cpp \
+           unix/KeyboardTranslator.cpp \
+           unix/konsole_wcwidth.cpp \
+           unix/kpty.cpp \
+           unix/QUnixTerminalImpl.cpp \
+           unix/Screen.cpp \
+           unix/ScreenWindow.cpp \
+           unix/TerminalCharacterDecoder.cpp \
+           unix/Vt102Emulation.cpp \
+         unix/SelfListener.cpp \
+           unix/TerminalModel.cpp \
+           unix/TerminalView.cpp
+}
+
+win32 {
+HEADERS  = win32/QTerminalColors.h \
+       win32/QWinTerminalImpl.h
+
+SOURCES  = win32/QTerminalColors.cpp \
+       win32/QWinTerminalImpl.cpp
+}
+
+win32-msvc* {
+  include(../msvc.pri)
+}
+
+HEADERS  += QTerminal.h \
+       QTerminal \
+    QTerminalInterface.h
diff --git a/libgui/qterminal/libqterminal/unix/BlockArray.cpp b/libgui/qterminal/libqterminal/unix/BlockArray.cpp
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/BlockArray.cpp
@@ -0,0 +1,336 @@
+/*
+    This file is part of Konsole, an X terminal.
+    Copyright (C) 2000 by Stephan Kulow <coolo@kde.org>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+
+*/
+
+// Own
+#include "unix/BlockArray.h"
+
+#include <QtCore>
+
+// System
+#include <assert.h>
+#include <sys/mman.h>
+#include <sys/param.h>
+#include <unistd.h>
+#include <stdio.h>
+
+
+static int blocksize = 0;
+
+BlockArray::BlockArray()
+    : size(0),
+      current(size_t(-1)),
+      index(size_t(-1)),
+      lastmap(0),
+      lastmap_index(size_t(-1)),
+      lastblock(0), ion(-1),
+      length(0)
+{
+    // lastmap_index = index = current = size_t(-1);
+    if (blocksize == 0)
+        blocksize = ((sizeof(Block) / getpagesize()) + 1) * getpagesize();
+
+}
+
+BlockArray::~BlockArray()
+{
+    setHistorySize(0);
+    assert(!lastblock);
+}
+
+size_t BlockArray::append(Block *block)
+{
+    if (!size)
+        return size_t(-1);
+
+    ++current;
+    if (current >= size) current = 0;
+
+    int rc;
+    rc = lseek(ion, current * blocksize, SEEK_SET); if (rc < 0) { perror("HistoryBuffer::add.seek"); setHistorySize(0); return size_t(-1); }
+    rc = write(ion, block, blocksize); if (rc < 0) { perror("HistoryBuffer::add.write"); setHistorySize(0); return size_t(-1); }
+
+    length++;
+    if (length > size) length = size;
+
+    ++index;
+
+    delete block;
+    return current;
+}
+
+size_t BlockArray::newBlock()
+{
+    if (!size)
+        return size_t(-1);
+    append(lastblock);
+
+    lastblock = new Block();
+    return index + 1;
+}
+
+Block *BlockArray::lastBlock() const
+{
+    return lastblock;
+}
+
+bool BlockArray::has(size_t i) const
+{
+    if (i == index + 1)
+        return true;
+
+    if (i > index)
+        return false;
+    if (index - i >= length)
+        return false;
+    return true;
+}
+
+const Block* BlockArray::at(size_t i)
+{
+    if (i == index + 1)
+        return lastblock;
+
+    if (i == lastmap_index)
+        return lastmap;
+
+    if (i > index) {
+        qDebug() << "BlockArray::at() i > index\n";
+        return 0;
+    }
+    
+//     if (index - i >= length) {
+//         kDebug(1211) << "BlockArray::at() index - i >= length\n";
+//         return 0;
+//     }
+
+    size_t j = i; // (current - (index - i) + (index/size+1)*size) % size ;
+
+    assert(j < size);
+    unmap();
+
+    Block *block = (Block*)mmap(0, blocksize, PROT_READ, MAP_PRIVATE, ion, j * blocksize);
+
+    if (block == (Block*)-1) { perror("mmap"); return 0; }
+
+    lastmap = block;
+    lastmap_index = i;
+
+    return block;
+}
+
+void BlockArray::unmap()
+{
+    if (lastmap) {
+        int res = munmap((char*)lastmap, blocksize);
+        if (res < 0) perror("munmap");
+    }
+    lastmap = 0;
+    lastmap_index = size_t(-1);
+}
+
+bool BlockArray::setSize(size_t newsize)
+{
+    return setHistorySize(newsize * 1024 / blocksize);
+}
+
+bool BlockArray::setHistorySize(size_t newsize)
+{
+//    kDebug(1211) << "setHistorySize " << size << " " << newsize;
+
+    if (size == newsize)
+        return false;
+
+    unmap();
+
+    if (!newsize) {
+        delete lastblock;
+        lastblock = 0;
+        if (ion >= 0) close(ion);
+        ion = -1;
+        current = size_t(-1);
+        return true;
+    }
+
+    if (!size) {
+        FILE* tmp = tmpfile();
+        if (!tmp) {
+            perror("konsole: cannot open temp file.\n");
+        } else {
+            ion = dup(fileno(tmp));
+            if (ion<0) {
+                perror("konsole: cannot dup temp file.\n");
+                fclose(tmp);
+            }
+        }
+        if (ion < 0)
+            return false;
+
+        assert(!lastblock);
+
+        lastblock = new Block();
+        size = newsize;
+        return false;
+    }
+
+    if (newsize > size) {
+        increaseBuffer();
+        size = newsize;
+        return false;
+    } else {
+        decreaseBuffer(newsize);
+        if (ftruncate(ion, length*blocksize) == -1)
+		  perror("ftruncate");
+        size = newsize;
+
+        return true;
+    }
+}
+
+void moveBlock(FILE *fion, int cursor, int newpos, char *buffer2)
+{
+    int res = fseek(fion, cursor * blocksize, SEEK_SET);
+    if (res)
+        perror("fseek");
+    res = fread(buffer2, blocksize, 1, fion);
+    if (res != 1)
+        perror("fread");
+
+    res = fseek(fion, newpos * blocksize, SEEK_SET);
+    if (res)
+        perror("fseek");
+    res = fwrite(buffer2, blocksize, 1, fion);
+    if (res != 1)
+        perror("fwrite");
+    //    printf("moving block %d to %d\n", cursor, newpos);
+}
+
+void BlockArray::decreaseBuffer(size_t newsize)
+{
+    if (index < newsize) // still fits in whole
+        return;
+
+    int offset = (current - (newsize - 1) + size) % size;
+
+    if (!offset)
+        return;
+
+    // The Block constructor could do somthing in future...
+    char *buffer1 = new char[blocksize];
+
+    FILE *fion = fdopen(dup(ion), "w+b");
+    if (!fion) {
+        delete [] buffer1;
+        perror("fdopen/dup");
+        return;
+    }
+
+    int firstblock;
+    if (current <= newsize) {
+        firstblock = current + 1;
+    } else {
+        firstblock = 0;
+    }
+
+    size_t oldpos;
+    for (size_t i = 0, cursor=firstblock; i < newsize; i++) {
+        oldpos = (size + cursor + offset) % size;
+        moveBlock(fion, oldpos, cursor, buffer1);
+        if (oldpos < newsize) {
+            cursor = oldpos;
+        } else
+            cursor++;
+    }
+
+    current = newsize - 1;
+    length = newsize;
+
+    delete [] buffer1;
+
+    fclose(fion);
+
+}
+
+void BlockArray::increaseBuffer()
+{
+    if (index < size) // not even wrapped once
+        return;
+
+    int offset = (current + size + 1) % size;
+    if (!offset) // no moving needed
+        return;
+
+    // The Block constructor could do somthing in future...
+    char *buffer1 = new char[blocksize];
+    char *buffer2 = new char[blocksize];
+
+    int runs = 1;
+    int bpr = size; // blocks per run
+
+    if (size % offset == 0) {
+        bpr = size / offset;
+        runs = offset;
+    }
+
+    FILE *fion = fdopen(dup(ion), "w+b");
+    if (!fion) {
+        perror("fdopen/dup");
+	delete [] buffer1;
+	delete [] buffer2;
+        return;
+    }
+
+    int res;
+    for (int i = 0; i < runs; i++)
+    {
+        // free one block in chain
+        int firstblock = (offset + i) % size;
+        res = fseek(fion, firstblock * blocksize, SEEK_SET);
+        if (res)
+            perror("fseek");
+        res = fread(buffer1, blocksize, 1, fion);
+        if (res != 1)
+            perror("fread");
+        int newpos = 0;
+        for (int j = 1, cursor=firstblock; j < bpr; j++)
+        {
+            cursor = (cursor + offset) % size;
+            newpos = (cursor - offset + size) % size;
+            moveBlock(fion, cursor, newpos, buffer2);
+        }
+        res = fseek(fion, i * blocksize, SEEK_SET);
+        if (res)
+            perror("fseek");
+        res = fwrite(buffer1, blocksize, 1, fion);
+        if (res != 1)
+            perror("fwrite");
+    }
+    current = size - 1;
+    length = size;
+
+    delete [] buffer1;
+    delete [] buffer2;
+
+    fclose(fion);
+
+}
+
diff --git a/libgui/qterminal/libqterminal/unix/BlockArray.h b/libgui/qterminal/libqterminal/unix/BlockArray.h
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/BlockArray.h
@@ -0,0 +1,118 @@
+/*
+    This file is part of Konsole, an X terminal.
+    Copyright (C) 2000 by Stephan Kulow <coolo@kde.org>
+   
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef BLOCKARRAY_H
+#define BLOCKARRAY_H
+
+#include <unistd.h>
+
+#define BlockSize (1 << 12)
+#define ENTRIES   ((BlockSize - sizeof(size_t) ) / sizeof(unsigned char))
+
+struct Block {
+    Block() { size = 0; }
+    unsigned char data[ENTRIES];
+    size_t size;
+};
+
+// ///////////////////////////////////////////////////////
+
+class BlockArray {
+public:
+    /**
+    * Creates a history file for holding
+    * maximal size blocks. If more blocks
+    * are requested, then it drops earlier
+    * added ones.
+    */
+    BlockArray();
+
+    /// destructor
+    ~BlockArray();
+
+    /**
+    * adds the Block at the end of history.
+    * This may drop other blocks.
+    *
+    * The ownership on the block is transfered.
+    * An unique index number is returned for accessing
+    * it later (if not yet dropped then)
+    *
+    * Note, that the block may be dropped completely
+    * if history is turned off.
+    */
+    size_t append(Block *block);
+
+    /**
+    * gets the block at the index. Function may return
+    * 0 if the block isn't available any more.
+    *
+    * The returned block is strictly readonly as only
+    * maped in memory - and will be invalid on the next
+    * operation on this class.
+    */
+    const Block *at(size_t index);
+
+    /**
+    * reorders blocks as needed. If newsize is null,
+    * the history is emptied completely. The indices
+    * returned on append won't change their semantic,
+    * but they may not be valid after this call.
+    */
+    bool setHistorySize(size_t newsize);
+
+    size_t newBlock();
+
+    Block *lastBlock() const;
+
+    /**
+    * Convenient function to set the size in KBytes
+    * instead of blocks
+    */
+    bool setSize(size_t newsize);
+
+    size_t len() const { return length; }
+
+    bool has(size_t index) const;
+
+    size_t getCurrent() const { return current; }
+
+private:
+    void unmap();
+    void increaseBuffer();
+    void decreaseBuffer(size_t newsize);
+
+    size_t size;
+    // current always shows to the last inserted block
+    size_t current;
+    size_t index;
+
+    Block *lastmap;
+    size_t lastmap_index;
+    Block *lastblock;
+
+    int ion;
+    size_t length;
+
+};
+
+#endif
diff --git a/libgui/qterminal/libqterminal/unix/Character.h b/libgui/qterminal/libqterminal/unix/Character.h
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/Character.h
@@ -0,0 +1,205 @@
+/*
+    This file is part of Konsole, KDE's terminal.
+    
+    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
+    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef CHARACTER_H
+#define CHARACTER_H
+
+// Qt
+#include <QtCore/QHash>
+
+// Local
+#include "unix/CharacterColor.h"
+
+typedef unsigned char LineProperty;
+
+static const int LINE_DEFAULT		= 0;
+static const int LINE_WRAPPED 	 	= (1 << 0);
+static const int LINE_DOUBLEWIDTH  	= (1 << 1);
+static const int LINE_DOUBLEHEIGHT	= (1 << 2);
+
+#define DEFAULT_RENDITION  0
+#define RE_BOLD            (1 << 0)
+#define RE_BLINK           (1 << 1)
+#define RE_UNDERLINE       (1 << 2)
+#define RE_REVERSE         (1 << 3) // Screen only
+#define RE_INTENSIVE       (1 << 3) // Widget only
+#define RE_CURSOR          (1 << 4)
+#define RE_EXTENDED_CHAR   (1 << 5)
+
+/**
+ * A single character in the terminal which consists of a unicode character
+ * value, foreground and background colors and a set of rendition attributes
+ * which specify how it should be drawn.
+ */
+class Character
+{
+public:
+  /** 
+   * Constructs a new character.
+   *
+   * @param _c The unicode character value of this character.
+   * @param _f The foreground color used to draw the character.
+   * @param _b The color used to draw the character's background.
+   * @param _r A set of rendition flags which specify how this character is to be drawn.
+   */
+  inline Character(quint16 _c = ' ',
+            CharacterColor  _f = CharacterColor(COLOR_SPACE_DEFAULT,DEFAULT_FORE_COLOR),
+            CharacterColor  _b = CharacterColor(COLOR_SPACE_DEFAULT,DEFAULT_BACK_COLOR),
+            quint8  _r = DEFAULT_RENDITION)
+       : character(_c), rendition(_r), foregroundColor(_f), backgroundColor(_b) {}
+
+  union
+  {
+    /** The unicode character value for this character. */
+    quint16 character;
+    /** 
+     * Experimental addition which allows a single Character instance to contain more than
+     * one unicode character.
+     *
+     * charSequence is a hash code which can be used to look up the unicode
+     * character sequence in the ExtendedCharTable used to create the sequence.
+     */
+    quint16 charSequence; 
+  };
+
+  /** A combination of RENDITION flags which specify options for drawing the character. */
+  quint8  rendition;
+
+  /** The foreground color used to draw this character. */
+  CharacterColor  foregroundColor; 
+  /** The color used to draw this character's background. */
+  CharacterColor  backgroundColor;
+
+  /** 
+   * Returns true if this character has a transparent background when
+   * it is drawn with the specified @p palette.
+   */
+  bool   isTransparent(const ColorEntry* palette) const;
+  /**
+   * Returns true if this character should always be drawn in bold when
+   * it is drawn with the specified @p palette, independent of whether
+   * or not the character has the RE_BOLD rendition flag. 
+   */
+  bool   isBold(const ColorEntry* base) const;
+  
+  /** 
+   * Compares two characters and returns true if they have the same unicode character value,
+   * rendition and colors.
+   */
+  friend bool operator == (const Character& a, const Character& b);
+  /**
+   * Compares two characters and returns true if they have different unicode character values,
+   * renditions or colors.
+   */
+  friend bool operator != (const Character& a, const Character& b);
+};
+
+inline bool operator == (const Character& a, const Character& b)
+{ 
+  return a.character == b.character && 
+         a.rendition == b.rendition && 
+         a.foregroundColor == b.foregroundColor && 
+         a.backgroundColor == b.backgroundColor;
+}
+
+inline bool operator != (const Character& a, const Character& b)
+{
+  return    a.character != b.character || 
+            a.rendition != b.rendition || 
+            a.foregroundColor != b.foregroundColor || 
+            a.backgroundColor != b.backgroundColor;
+}
+
+inline bool Character::isTransparent(const ColorEntry* base) const
+{
+  return ((backgroundColor._colorSpace == COLOR_SPACE_DEFAULT) && 
+          base[backgroundColor._u+0+(backgroundColor._v?BASE_COLORS:0)].transparent)
+      || ((backgroundColor._colorSpace == COLOR_SPACE_SYSTEM) && 
+          base[backgroundColor._u+2+(backgroundColor._v?BASE_COLORS:0)].transparent);
+}
+
+inline bool Character::isBold(const ColorEntry* base) const
+{
+  return ((backgroundColor._colorSpace == COLOR_SPACE_DEFAULT) &&
+            base[backgroundColor._u+0+(backgroundColor._v?BASE_COLORS:0)].bold)
+      || ((backgroundColor._colorSpace == COLOR_SPACE_SYSTEM) &&
+            base[backgroundColor._u+2+(backgroundColor._v?BASE_COLORS:0)].bold);
+}
+
+extern unsigned short vt100_graphics[32];
+
+
+/**
+ * A table which stores sequences of unicode characters, referenced
+ * by hash keys.  The hash key itself is the same size as a unicode
+ * character ( ushort ) so that it can occupy the same space in
+ * a structure.
+ */
+class ExtendedCharTable
+{
+public:
+    /** Constructs a new character table. */
+    ExtendedCharTable();
+    ~ExtendedCharTable();
+
+    /**
+     * Adds a sequences of unicode characters to the table and returns
+     * a hash code which can be used later to look up the sequence
+     * using lookupExtendedChar()
+     *
+     * If the same sequence already exists in the table, the hash
+     * of the existing sequence will be returned.
+     *
+     * @param unicodePoints An array of unicode character points
+     * @param length Length of @p unicodePoints
+     */
+    ushort createExtendedChar(ushort* unicodePoints , ushort length);
+    /**
+     * Looks up and returns a pointer to a sequence of unicode characters
+     * which was added to the table using createExtendedChar().
+     *
+     * @param hash The hash key returned by createExtendedChar()
+     * @param length This variable is set to the length of the 
+     * character sequence.
+     *
+     * @return A unicode character sequence of size @p length.
+     */
+    ushort* lookupExtendedChar(ushort hash , ushort& length) const;
+
+    /** The global ExtendedCharTable instance. */
+    static ExtendedCharTable instance;
+private:
+    // calculates the hash key of a sequence of unicode points of size 'length'
+    ushort extendedCharHash(ushort* unicodePoints , ushort length) const;
+    // tests whether the entry in the table specified by 'hash' matches the 
+    // character sequence 'unicodePoints' of size 'length'
+    bool extendedCharMatch(ushort hash , ushort* unicodePoints , ushort length) const;
+    // internal, maps hash keys to character sequence buffers.  The first ushort
+    // in each value is the length of the buffer, followed by the ushorts in the buffer
+    // themselves.
+    QHash<ushort,ushort*> extendedCharTable;
+};
+
+#endif // CHARACTER_H
+
diff --git a/libgui/qterminal/libqterminal/unix/CharacterColor.h b/libgui/qterminal/libqterminal/unix/CharacterColor.h
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/CharacterColor.h
@@ -0,0 +1,292 @@
+/*
+    This file is part of Konsole, KDE's terminal.
+    
+    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
+    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef CHARACTERCOLOR_H
+#define CHARACTERCOLOR_H
+
+// Qt
+#include <QtGui/QColor>
+
+/** 
+ * An entry in a terminal display's color palette. 
+ *
+ * A color palette is an array of 16 ColorEntry instances which map
+ * system color indexes (from 0 to 15) into actual colors.
+ *
+ * Each entry can be set as bold, in which case any text
+ * drawn using the color should be drawn in bold.  
+ *
+ * Each entry can also be transparent, in which case the terminal
+ * display should avoid drawing the background for any characters
+ * using the entry as a background.
+ */
+class ColorEntry
+{
+public:
+  /** 
+   * Constructs a new color palette entry.
+   *
+   * @param c The color value for this entry.
+   * @param tr Specifies that the color should be transparent when used as a background color.
+   * @param b Specifies that text drawn with this color should be bold.
+   */
+  ColorEntry(QColor c, bool tr, bool b) : color(c), transparent(tr), bold(b) {}
+
+  /**
+   * Constructs a new color palette entry with an undefined color, and
+   * with the transparent and bold flags set to false.
+   */ 
+  ColorEntry() : transparent(false), bold(false) {} 
+ 
+  /**
+   * Sets the color, transparency and boldness of this color to those of @p rhs.
+   */ 
+  void operator=(const ColorEntry& rhs) 
+  { 
+       color = rhs.color; 
+       transparent = rhs.transparent; 
+       bold = rhs.bold; 
+  }
+
+  /** The color value of this entry for display. */
+  QColor color;
+
+  /** 
+   * If true character backgrounds using this color should be transparent. 
+   * This is not applicable when the color is used to render text.
+   */
+  bool   transparent;
+  /**
+   * If true characters drawn using this color should be bold.
+   * This is not applicable when the color is used to draw a character's background.
+   */
+  bool   bold;        
+};
+
+
+// Attributed Character Representations ///////////////////////////////
+
+// Colors
+
+#define BASE_COLORS   (2+8)
+#define INTENSITIES   2
+#define TABLE_COLORS  (INTENSITIES*BASE_COLORS)
+
+#define DEFAULT_FORE_COLOR 0
+#define DEFAULT_BACK_COLOR 1
+
+//a standard set of colors using black text on a white background.
+//defined in TerminalDisplay.cpp
+
+static const ColorEntry base_color_table[TABLE_COLORS] =
+{
+    // normal
+    ColorEntry(QColor(0x00,0x00,0x00), 1, 0 ), ColorEntry( QColor(0xFF,0xFF,0xFF), 0, 0 ), // Dfore, Dback
+    ColorEntry(QColor(0x00,0x00,0x00), 0, 0 ), ColorEntry( QColor(0xB2,0x18,0x18), 0, 0 ), // Black, Red
+    ColorEntry(QColor(0x18,0xB2,0x18), 0, 0 ), ColorEntry( QColor(0xB2,0x68,0x18), 0, 0 ), // Green, Yellow
+    ColorEntry(QColor(0x18,0x18,0xB2), 0, 0 ), ColorEntry( QColor(0xB2,0x18,0xB2), 0, 0 ), // Blue, Magenta
+    ColorEntry(QColor(0x18,0xB2,0xB2), 0, 0 ), ColorEntry( QColor(0xB2,0xB2,0xB2), 0, 0 ), // Cyan, White
+    // intensiv
+    ColorEntry(QColor(0x00,0x00,0x00), 0, 1 ), ColorEntry( QColor(0xFF,0xFF,0xFF), 1, 0 ),
+    ColorEntry(QColor(0x68,0x68,0x68), 0, 0 ), ColorEntry( QColor(0xFF,0x54,0x54), 0, 0 ),
+    ColorEntry(QColor(0x54,0xFF,0x54), 0, 0 ), ColorEntry( QColor(0xFF,0xFF,0x54), 0, 0 ),
+    ColorEntry(QColor(0x54,0x54,0xFF), 0, 0 ), ColorEntry( QColor(0xFF,0x54,0xFF), 0, 0 ),
+    ColorEntry(QColor(0x54,0xFF,0xFF), 0, 0 ), ColorEntry( QColor(0xFF,0xFF,0xFF), 0, 0 )
+};
+
+/* CharacterColor is a union of the various color spaces.
+
+   Assignment is as follows:
+
+   Type  - Space        - Values
+
+   0     - Undefined   - u:  0,      v:0        w:0
+   1     - Default     - u:  0..1    v:intense  w:0
+   2     - System      - u:  0..7    v:intense  w:0
+   3     - Index(256)  - u: 16..255  v:0        w:0
+   4     - RGB         - u:  0..255  v:0..256   w:0..256
+
+   Default colour space has two separate colours, namely
+   default foreground and default background colour.
+*/
+
+#define COLOR_SPACE_UNDEFINED   0
+#define COLOR_SPACE_DEFAULT     1
+#define COLOR_SPACE_SYSTEM      2
+#define COLOR_SPACE_256         3
+#define COLOR_SPACE_RGB         4
+
+/**
+ * Describes the color of a single character in the terminal.
+ */
+class CharacterColor
+{
+    friend class Character;
+
+public:
+  /** Constructs a new CharacterColor whoose color and color space are undefined. */
+  CharacterColor() 
+      : _colorSpace(COLOR_SPACE_UNDEFINED), 
+        _u(0), 
+        _v(0), 
+        _w(0) 
+  {}
+
+  /** 
+   * Constructs a new CharacterColor using the specified @p colorSpace and with 
+   * color value @p co
+   *
+   * The meaning of @p co depends on the @p colorSpace used.
+   *
+   * TODO : Document how @p co relates to @p colorSpace
+   *
+   * TODO : Add documentation about available color spaces.
+   */
+  CharacterColor(quint8 colorSpace, int co) 
+      : _colorSpace(colorSpace), 
+        _u(0), 
+        _v(0), 
+        _w(0)
+  {
+    switch (colorSpace)
+    {
+        case COLOR_SPACE_DEFAULT:
+            _u = co & 1;
+            break;
+        case COLOR_SPACE_SYSTEM:
+            _u = co & 7;
+            _v = (co >> 3) & 1;
+            break;
+        case COLOR_SPACE_256:  
+            _u = co & 255;
+            break;
+        case COLOR_SPACE_RGB:
+            _u = co >> 16;
+            _v = co >> 8;
+            _w = co;
+            break;
+        default:
+            _colorSpace = COLOR_SPACE_UNDEFINED;
+    }
+  }
+
+  /** 
+   * Returns true if this character color entry is valid.
+   */
+  bool isValid() 
+  {
+        return _colorSpace != COLOR_SPACE_UNDEFINED;
+  }
+    
+  /** 
+   * Toggles the value of this color between a normal system color and the corresponding intensive
+   * system color.
+   * 
+   * This is only applicable if the color is using the COLOR_SPACE_DEFAULT or COLOR_SPACE_SYSTEM
+   * color spaces.
+   */
+  void toggleIntensive();
+
+  /** 
+   * Returns the color within the specified color @palette
+   *
+   * The @p palette is only used if this color is one of the 16 system colors, otherwise
+   * it is ignored.
+   */
+  QColor color(const ColorEntry* palette) const;
+ 
+  /** 
+   * Compares two colors and returns true if they represent the same color value and
+   * use the same color space.
+   */
+  friend bool operator == (const CharacterColor& a, const CharacterColor& b);
+  /**
+   * Compares two colors and returns true if they represent different color values
+   * or use different color spaces.
+   */
+  friend bool operator != (const CharacterColor& a, const CharacterColor& b);
+
+private:
+  quint8 _colorSpace;
+
+  // bytes storing the character color 
+  quint8 _u; 
+  quint8 _v; 
+  quint8 _w; 
+};
+
+inline bool operator == (const CharacterColor& a, const CharacterColor& b)
+{ 
+    return a._colorSpace == b._colorSpace &&
+	       a._u == b._u &&
+	       a._v == b._v &&
+           a._w == b._w;
+}
+
+inline bool operator != (const CharacterColor& a, const CharacterColor& b)
+{
+    return !operator==(a,b);
+}
+
+inline const QColor color256(quint8 u, const ColorEntry* base)
+{
+  //   0.. 16: system colors
+  if (u <   8) return base[u+2            ].color; u -= 8;
+  if (u <   8) return base[u+2+BASE_COLORS].color; u -= 8;
+
+  //  16..231: 6x6x6 rgb color cube
+  if (u < 216) return QColor(255*((u/36)%6)/5,
+                             255*((u/ 6)%6)/5,
+                             255*((u/ 1)%6)/5); u -= 216;
+  
+  // 232..255: gray, leaving out black and white
+  int gray = u*10+8; return QColor(gray,gray,gray);
+}
+
+inline QColor CharacterColor::color(const ColorEntry* base) const
+{
+  switch (_colorSpace)
+  {
+    case COLOR_SPACE_DEFAULT: return base[_u+0+(_v?BASE_COLORS:0)].color;
+    case COLOR_SPACE_SYSTEM: return base[_u+2+(_v?BASE_COLORS:0)].color;
+    case COLOR_SPACE_256: return color256(_u,base);
+    case COLOR_SPACE_RGB: return QColor(_u,_v,_w);
+    case COLOR_SPACE_UNDEFINED: return QColor();
+  }
+
+  Q_ASSERT(false); // invalid color space
+
+  return QColor();
+}
+
+inline void CharacterColor::toggleIntensive()
+{
+  if (_colorSpace == COLOR_SPACE_SYSTEM || _colorSpace == COLOR_SPACE_DEFAULT)
+  {
+    _v = !_v;
+  }
+}
+
+#endif // CHARACTERCOLOR_H
+
diff --git a/libgui/qterminal/libqterminal/unix/Emulation.cpp b/libgui/qterminal/libqterminal/unix/Emulation.cpp
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/Emulation.cpp
@@ -0,0 +1,426 @@
+/*
+    This file is part of Konsole, an X terminal.
+
+    Copyright (C) 2007 Robert Knight <robertknight@gmail.com> 
+    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+    Copyright (C) 1996 by Matthias Ettrich <ettrich@kde.org>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+// Own
+#include "unix/Emulation.h"
+
+// System
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+// Qt
+#include <QtGui/QApplication>
+#include <QtGui/QClipboard>
+#include <QtCore/QHash>
+#include <QtGui/QKeyEvent>
+#include <QtCore/QRegExp>
+#include <QtCore/QTextStream>
+#include <QtCore/QThread>
+
+#include <QtCore/QTime>
+
+// Konsole
+#include "unix/KeyboardTranslator.h"
+#include "unix/Screen.h"
+#include "unix/TerminalCharacterDecoder.h"
+#include "unix/ScreenWindow.h"
+
+Emulation::Emulation() :
+  _currentScreen(0),
+  _codec(0),
+  _decoder(0),
+  _keyTranslator(0),
+  _usesMouse(false)
+{
+
+  // create screens with a default size
+  _screen[0] = new Screen(40,80);
+  _screen[1] = new Screen(40,80);
+  _currentScreen = _screen[0];
+
+  QObject::connect(&_bulkTimer1, SIGNAL(timeout()), this, SLOT(showBulk()) );
+  QObject::connect(&_bulkTimer2, SIGNAL(timeout()), this, SLOT(showBulk()) );
+   
+  // listen for mouse status changes
+  connect( this , SIGNAL(programUsesMouseChanged(bool)) , 
+           SLOT(usesMouseChanged(bool)) );
+}
+
+bool Emulation::programUsesMouse() const
+{
+    return _usesMouse;
+}
+
+void Emulation::usesMouseChanged(bool usesMouse)
+{
+    _usesMouse = usesMouse;
+}
+
+ScreenWindow* Emulation::createWindow()
+{
+    ScreenWindow* window = new ScreenWindow();
+    window->setScreen(_currentScreen);
+    _windows << window;
+
+    connect(window , SIGNAL(selectionChanged()),
+            this , SLOT(bufferedUpdate()));
+
+    connect(this , SIGNAL(outputChanged()),
+            window , SLOT(notifyOutputChanged()) );
+    return window;
+}
+
+/*!
+*/
+
+Emulation::~Emulation()
+{
+  QListIterator<ScreenWindow*> windowIter(_windows);
+
+  while (windowIter.hasNext())
+  {
+    delete windowIter.next();
+  }
+
+  delete _screen[0];
+  delete _screen[1];
+  delete _decoder;
+}
+
+/*! change between primary and alternate _screen
+*/
+
+void Emulation::setScreen(int n)
+{
+  Screen *old = _currentScreen;
+  _currentScreen = _screen[n&1];
+  if (_currentScreen != old) 
+  {
+     old->setBusySelecting(false);
+
+     // tell all windows onto this emulation to switch to the newly active _screen
+     QListIterator<ScreenWindow*> windowIter(_windows);
+     while ( windowIter.hasNext() )
+     {
+         windowIter.next()->setScreen(_currentScreen);
+     }
+  }
+}
+
+void Emulation::clearHistory()
+{
+    _screen[0]->setScroll( _screen[0]->getScroll() , false );
+}
+void Emulation::setHistory(const HistoryType& t)
+{
+  _screen[0]->setScroll(t);
+
+  showBulk();
+}
+
+const HistoryType& Emulation::history()
+{
+  return _screen[0]->getScroll();
+}
+
+void Emulation::setCodec(const QTextCodec * qtc)
+{
+  Q_ASSERT( qtc );
+
+  _codec = qtc;
+  delete _decoder;
+  _decoder = _codec->makeDecoder();
+
+  emit useUtf8Request(utf8());
+}
+
+void Emulation::setCodec(EmulationCodec codec)
+{
+    if ( codec == Utf8Codec )
+        setCodec( QTextCodec::codecForName("utf8") );
+    else if ( codec == LocaleCodec )
+        setCodec( QTextCodec::codecForLocale() );
+}
+
+void Emulation::setKeyBindings(const QString& name)
+{
+  _keyTranslator = KeyboardTranslatorManager::instance()->findTranslator(name);
+}
+
+QString Emulation::keyBindings()
+{
+  return _keyTranslator->name();
+}
+
+
+// Interpreting Codes ---------------------------------------------------------
+
+/*
+   This section deals with decoding the incoming character stream.
+   Decoding means here, that the stream is first separated into `tokens'
+   which are then mapped to a `meaning' provided as operations by the
+   `Screen' class.
+*/
+
+/*!
+*/
+
+void Emulation::receiveChar(int c)
+// process application unicode input to terminal
+// this is a trivial scanner
+{
+  c &= 0xff;
+  switch (c)
+  {
+    case '\b'      : _currentScreen->BackSpace();                 break;
+    case '\t'      : _currentScreen->Tabulate();                  break;
+    case '\n'      : _currentScreen->NewLine();                   break;
+    case '\r'      : _currentScreen->Return();                    break;
+    case 0x07      : emit stateSet(NOTIFYBELL);
+                     break;
+    default        : _currentScreen->ShowCharacter(c);            break;
+  };
+}
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                             Keyboard Handling                             */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+/*!
+*/
+
+void Emulation::sendKeyEvent( QKeyEvent* ev )
+{
+  emit stateSet(NOTIFYNORMAL);
+  
+  if (!ev->text().isEmpty())
+  { // A block of text
+    // Note that the text is proper unicode.
+    // We should do a conversion here, but since this
+    // routine will never be used, we simply emit plain ascii.
+    //emit sendBlock(ev->text().toAscii(),ev->text().length());
+    emit sendData(ev->text().toUtf8(),ev->text().length());
+  }
+}
+
+void Emulation::sendString(const char*,int)
+{
+    // default implementation does nothing
+}
+
+void Emulation::sendMouseEvent(int /*buttons*/, int /*column*/, int /*row*/, int /*eventType*/)
+{
+    // default implementation does nothing
+}
+
+// Unblocking, Byte to Unicode translation --------------------------------- --
+
+/*
+   We are doing code conversion from locale to unicode first.
+TODO: Character composition from the old code.  See #96536
+*/
+
+void Emulation::receiveData(const char* text, int length)
+{
+	emit stateSet(NOTIFYACTIVITY);
+
+	bufferedUpdate();
+    	
+        QString unicodeText = _decoder->toUnicode(text,length);
+
+	//send characters to terminal emulator
+        for (int i=0;i<unicodeText.length();i++)
+	{
+                receiveChar(unicodeText[i].unicode());
+	}
+}
+
+// Selection --------------------------------------------------------------- --
+
+void Emulation::writeToStream( TerminalCharacterDecoder* _decoder , 
+                               int startLine ,
+                               int endLine) 
+{
+  _currentScreen->writeToStream(_decoder,startLine,endLine);
+}
+
+int Emulation::lineCount()
+{
+    // sum number of lines currently on _screen plus number of lines in history
+    return _currentScreen->getLines() + _currentScreen->getHistLines();
+}
+
+// Refreshing -------------------------------------------------------------- --
+
+#define BULK_TIMEOUT1 10
+#define BULK_TIMEOUT2 40
+
+/*!
+*/
+void Emulation::showBulk()
+{
+    _bulkTimer1.stop();
+    _bulkTimer2.stop();
+
+    emit outputChanged();
+
+    _currentScreen->resetScrolledLines();
+    _currentScreen->resetDroppedLines();
+}
+
+void Emulation::bufferedUpdate()
+{
+   _bulkTimer1.setSingleShot(true);
+   _bulkTimer1.start(BULK_TIMEOUT1);
+   if (!_bulkTimer2.isActive())
+   {
+      _bulkTimer2.setSingleShot(true);
+      _bulkTimer2.start(BULK_TIMEOUT2);
+   }
+}
+
+char Emulation::getErase() const
+{
+  return '\b';
+}
+
+void Emulation::setImageSize(int lines, int columns)
+{
+  //kDebug() << "Resizing image to: " << lines << "by" << columns << QTime::currentTime().msec();
+  Q_ASSERT( lines > 0 );
+  Q_ASSERT( columns > 0 );
+
+  _screen[0]->resizeImage(lines,columns);
+  _screen[1]->resizeImage(lines,columns);
+
+  emit imageSizeChanged(lines,columns);
+
+  bufferedUpdate();
+}
+
+QSize Emulation::imageSize()
+{
+  return QSize(_currentScreen->getColumns(), _currentScreen->getLines());
+}
+
+ushort ExtendedCharTable::extendedCharHash(ushort* unicodePoints , ushort length) const
+{
+    ushort hash = 0;
+    for ( ushort i = 0 ; i < length ; i++ )
+    {
+        hash = 31*hash + unicodePoints[i];
+    }
+    return hash;
+}
+bool ExtendedCharTable::extendedCharMatch(ushort hash , ushort* unicodePoints , ushort length) const
+{
+    ushort* entry = extendedCharTable[hash];
+
+    // compare given length with stored sequence length ( given as the first ushort in the 
+    // stored buffer ) 
+    if ( entry == 0 || entry[0] != length ) 
+       return false;
+    // if the lengths match, each character must be checked.  the stored buffer starts at
+    // entry[1]
+    for ( int i = 0 ; i < length ; i++ )
+    {
+        if ( entry[i+1] != unicodePoints[i] )
+           return false; 
+    } 
+    return true;
+}
+ushort ExtendedCharTable::createExtendedChar(ushort* unicodePoints , ushort length)
+{
+    // look for this sequence of points in the table
+    ushort hash = extendedCharHash(unicodePoints,length);
+
+    // check existing entry for match
+    while ( extendedCharTable.contains(hash) )
+    {
+        if ( extendedCharMatch(hash,unicodePoints,length) )
+        {
+            // this sequence already has an entry in the table, 
+            // return its hash
+            return hash;
+        }
+        else
+        {
+            // if hash is already used by another, different sequence of unicode character
+            // points then try next hash
+            hash++;
+        }
+    }    
+
+    
+     // add the new sequence to the table and
+     // return that index
+    ushort* buffer = new ushort[length+1];
+    buffer[0] = length;
+    for ( int i = 0 ; i < length ; i++ )
+       buffer[i+1] = unicodePoints[i]; 
+    
+    extendedCharTable.insert(hash,buffer);
+
+    return hash;
+}
+
+ushort* ExtendedCharTable::lookupExtendedChar(ushort hash , ushort& length) const
+{
+    // lookup index in table and if found, set the length
+    // argument and return a pointer to the character sequence
+
+    ushort* buffer = extendedCharTable[hash];
+    if ( buffer )
+    {
+        length = buffer[0];
+        return buffer+1;
+    }
+    else
+    {
+        length = 0;
+        return 0;
+    }
+}
+
+ExtendedCharTable::ExtendedCharTable()
+{
+}
+ExtendedCharTable::~ExtendedCharTable()
+{
+    // free all allocated character buffers
+    QHashIterator<ushort,ushort*> iter(extendedCharTable);
+    while ( iter.hasNext() )
+    {
+        iter.next();
+        delete[] iter.value();
+    }
+}
+
+// global instance
+ExtendedCharTable ExtendedCharTable::instance;
diff --git a/libgui/qterminal/libqterminal/unix/Emulation.h b/libgui/qterminal/libqterminal/unix/Emulation.h
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/Emulation.h
@@ -0,0 +1,456 @@
+/*
+    This file is part of Konsole, an X terminal.
+    
+    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
+    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef EMULATION_H
+#define EMULATION_H
+
+// System
+#include <stdio.h>
+
+// Qt 
+#include <QtGui/QKeyEvent>
+
+#include <QtCore/QTextCodec>
+#include <QtCore/QTextStream>
+#include <QtCore/QTimer>
+
+class KeyboardTranslator;
+class HistoryType;
+class Screen;
+class ScreenWindow;
+class TerminalCharacterDecoder;
+
+/** 
+ * This enum describes the available states which 
+ * the terminal emulation may be set to.
+ *
+ * These are the values used by Emulation::stateChanged() 
+ */
+enum 
+{ 
+    /** The emulation is currently receiving user input. */
+    NOTIFYNORMAL=0, 
+    /** 
+     * The terminal program has triggered a bell event
+     * to get the user's attention.
+     */
+    NOTIFYBELL=1, 
+    /** 
+     * The emulation is currently receiving data from its 
+     * terminal input.
+     */
+    NOTIFYACTIVITY=2,
+
+    // unused here? 
+    NOTIFYSILENCE=3 
+};
+
+/**
+ * Base class for terminal emulation back-ends.
+ *
+ * The back-end is responsible for decoding an incoming character stream and 
+ * producing an output image of characters.
+ *
+ * When input from the terminal is received, the receiveData() slot should be called with
+ * the data which has arrived.  The emulation will process the data and update the 
+ * screen image accordingly.  The codec used to decode the incoming character stream
+ * into the unicode characters used internally can be specified using setCodec() 
+ *
+ * The size of the screen image can be specified by calling setImageSize() with the 
+ * desired number of lines and columns.  When new lines are added, old content
+ * is moved into a history store, which can be set by calling setHistory(). 
+ *
+ * The screen image can be accessed by creating a ScreenWindow onto this emulation 
+ * by calling createWindow().  Screen windows provide access to a section of the 
+ * output.  Each screen window covers the same number of lines and columns as the 
+ * image size returned by imageSize().  The screen window can be moved up and down
+ * and provides transparent access to both the current on-screen image and the 
+ * previous output.  The screen windows emit an outputChanged signal
+ * when the section of the image they are looking at changes.
+ * Graphical views can then render the contents of a screen window, listening for notifications
+ * of output changes from the screen window which they are associated with and updating 
+ * accordingly. 
+ *
+ * The emulation also is also responsible for converting input from the connected views such
+ * as keypresses and mouse activity into a character string which can be sent
+ * to the terminal program.  Key presses can be processed by calling the sendKeyEvent() slot,
+ * while mouse events can be processed using the sendMouseEvent() slot.  When the character
+ * stream has been produced, the emulation will emit a sendData() signal with a pointer
+ * to the character buffer.  This data should be fed to the standard input of the terminal
+ * process.  The translation of key presses into an output character stream is performed
+ * using a lookup in a set of key bindings which map key sequences to output
+ * character sequences.  The name of the key bindings set used can be specified using
+ * setKeyBindings()
+ *
+ * The emulation maintains certain state information which changes depending on the 
+ * input received.  The emulation can be reset back to its starting state by calling 
+ * reset().  
+ *
+ * The emulation also maintains an activity state, which specifies whether
+ * terminal is currently active ( when data is received ), normal
+ * ( when the terminal is idle or receiving user input ) or trying
+ * to alert the user ( also known as a "Bell" event ).  The stateSet() signal
+ * is emitted whenever the activity state is set.  This can be used to determine
+ * how long the emulation has been active/idle for and also respond to
+ * a 'bell' event in different ways.
+ */
+class Emulation : public QObject
+{ 
+Q_OBJECT
+
+public:
+ 
+   /** Constructs a new terminal emulation */ 
+   Emulation();
+  ~Emulation();
+
+  /**
+   * Creates a new window onto the output from this emulation.  The contents
+   * of the window are then rendered by views which are set to use this window using the
+   * TerminalDisplay::setScreenWindow() method.
+   */
+  ScreenWindow* createWindow();
+
+  /** Returns the size of the screen image which the emulation produces */
+  QSize imageSize();
+
+  /**
+   * Returns the total number of lines, including those stored in the history.
+   */ 
+  int lineCount();
+
+  
+  /** 
+   * Sets the history store used by this emulation.  When new lines
+   * are added to the output, older lines at the top of the screen are transferred to a history
+   * store.   
+   *
+   * The number of lines which are kept and the storage location depend on the 
+   * type of store.
+   */
+  void setHistory(const HistoryType&);
+  /** Returns the history store used by this emulation.  See setHistory() */
+  const HistoryType& history();
+  /** Clears the history scroll. */
+  void clearHistory();
+
+  /** 
+   * Copies the output history from @p startLine to @p endLine 
+   * into @p stream, using @p decoder to convert the terminal
+   * characters into text. 
+   *
+   * @param decoder A decoder which converts lines of terminal characters with 
+   * appearance attributes into output text.  PlainTextDecoder is the most commonly
+   * used decoder.
+   * @param startLine The first
+   */
+  virtual void writeToStream(TerminalCharacterDecoder* decoder,int startLine,int endLine);
+  
+  
+  /** Returns the codec used to decode incoming characters.  See setCodec() */
+  const QTextCodec* codec() { return _codec; }
+  /** Sets the codec used to decode incoming characters.  */
+  void setCodec(const QTextCodec*);
+
+  /** 
+   * Convenience method.  
+   * Returns true if the current codec used to decode incoming
+   * characters is UTF-8
+   */
+  bool utf8() { Q_ASSERT(_codec); return _codec->mibEnum() == 106; }
+  
+
+  /** TODO Document me */
+  virtual char getErase() const;
+
+  /** 
+   * Sets the key bindings used to key events
+   * ( received through sendKeyEvent() ) into character
+   * streams to send to the terminal.
+   */
+  void setKeyBindings(const QString& name);
+  /** 
+   * Returns the name of the emulation's current key bindings.
+   * See setKeyBindings()
+   */
+  QString keyBindings();
+
+  /** 
+   * Copies the current image into the history and clears the screen.
+   */
+  virtual void clearEntireScreen() =0;
+
+  /** Resets the state of the terminal. */
+  virtual void reset() =0;
+
+  /** 
+   * Returns true if the active terminal program wants
+   * mouse input events.
+   *
+   * The programUsesMouseChanged() signal is emitted when this
+   * changes.
+   */
+  bool programUsesMouse() const;
+
+public slots: 
+
+  /** Change the size of the emulation's image */
+  virtual void setImageSize(int lines, int columns);
+  
+  /** 
+   * Interprets a sequence of characters and sends the result to the terminal.
+   * This is equivalent to calling sendKeyEvent() for each character in @p text in succession.
+   */
+  virtual void sendText(const QString& text) = 0;
+
+  /** 
+   * Interprets a key press event and emits the sendData() signal with
+   * the resulting character stream. 
+   */
+  virtual void sendKeyEvent(QKeyEvent*);
+ 
+  /** 
+   * Converts information about a mouse event into an xterm-compatible escape
+   * sequence and emits the character sequence via sendData()
+   */
+  virtual void sendMouseEvent(int buttons, int column, int line, int eventType);
+  
+  /**
+   * Sends a string of characters to the foreground terminal process. 
+   *
+   * @param string The characters to send.  
+   * @param length Length of @p string or if set to a negative value, @p string will
+   * be treated as a null-terminated string and its length will be determined automatically.
+   */
+  virtual void sendString(const char* string, int length = -1) = 0;
+
+  /** 
+   * Processes an incoming stream of characters.  receiveData() decodes the incoming
+   * character buffer using the current codec(), and then calls receiveChar() for
+   * each unicode character in the resulting buffer.  
+   *
+   * receiveData() also starts a timer which causes the outputChanged() signal
+   * to be emitted when it expires.  The timer allows multiple updates in quick
+   * succession to be buffered into a single outputChanged() signal emission.
+   *
+   * @param buffer A string of characters received from the terminal program.
+   * @param len The length of @p buffer
+   */
+  void receiveData(const char* buffer,int len);
+
+signals:
+
+  /** 
+   * Emitted when a buffer of data is ready to send to the 
+   * standard input of the terminal.
+   *
+   * @param data The buffer of data ready to be sent
+   * @paran len The length of @p data in bytes
+   */
+  void sendData(const char* data,int len);
+
+  /** 
+   * Requests that sending of input to the emulation
+   * from the terminal process be suspended or resumed.
+   *
+   * @param suspend If true, requests that sending of 
+   * input from the terminal process' stdout be 
+   * suspended.  Otherwise requests that sending of
+   * input be resumed. 
+   */
+  void lockPtyRequest(bool suspend);
+
+  /**
+   * Requests that the pty used by the terminal process
+   * be set to UTF 8 mode.  
+   *
+   * TODO: More documentation
+   */
+  void useUtf8Request(bool);
+
+  /**
+   * Emitted when the activity state of the emulation is set.
+   *
+   * @param state The new activity state, one of NOTIFYNORMAL, NOTIFYACTIVITY
+   * or NOTIFYBELL
+   */
+  void stateSet(int state);
+
+
+  /**
+   * Requests that the color of the text used
+   * to represent the tabs associated with this
+   * emulation be changed.  This is a Konsole-specific
+   * extension from pre-KDE 4 times.
+   *
+   * TODO: Document how the parameter works.
+   */
+  void changeTabTextColorRequest(int color);
+
+  /** 
+   * This is emitted when the program running in the shell indicates whether or
+   * not it is interested in mouse events.
+   *
+   * @param usesMouse This will be true if the program wants to be informed about
+   * mouse events or false otherwise.
+   */
+  void programUsesMouseChanged(bool usesMouse);
+
+  /** 
+   * Emitted when the contents of the screen image change.
+   * The emulation buffers the updates from successive image changes,
+   * and only emits outputChanged() at sensible intervals when
+   * there is a lot of terminal activity.
+   *
+   * Normally there is no need for objects other than the screen windows
+   * created with createWindow() to listen for this signal.
+   *
+   * ScreenWindow objects created using createWindow() will emit their
+   * own outputChanged() signal in response to this signal. 
+   */
+  void outputChanged();
+
+  /**
+   * Emitted when the program running in the terminal wishes to update the 
+   * session's title.  This also allows terminal programs to customize other
+   * aspects of the terminal emulation display. 
+   *
+   * This signal is emitted when the escape sequence "\033]ARG;VALUE\007"
+   * is received in the input string, where ARG is a number specifying what
+   * should change and VALUE is a string specifying the new value.
+   *
+   * TODO:  The name of this method is not very accurate since this method
+   * is used to perform a whole range of tasks besides just setting
+   * the user-title of the session.    
+   *
+   * @param title Specifies what to change.
+   * <ul>
+   * <li>0 - Set window icon text and session title to @p newTitle</li>
+   * <li>1 - Set window icon text to @p newTitle</li>
+   * <li>2 - Set session title to @p newTitle</li>
+   * <li>11 - Set the session's default background color to @p newTitle,
+   *         where @p newTitle can be an HTML-style string (#RRGGBB) or a named
+   *         color (eg 'red', 'blue').  
+   *         See http://doc.trolltech.com/4.2/qcolor.html#setNamedColor for more
+   *         details.
+   * </li>
+   * <li>31 - Supposedly treats @p newTitle as a URL and opens it (NOT IMPLEMENTED)</li>
+   * <li>32 - Sets the icon associated with the session.  @p newTitle is the name 
+   *    of the icon to use, which can be the name of any icon in the current KDE icon
+   *    theme (eg: 'konsole', 'kate', 'folder_home')</li>
+   * </ul>
+   * @param newTitle Specifies the new title 
+   */
+
+  void titleChanged(int title,const QString& newTitle);
+
+  /**
+   * Emitted when the program running in the terminal changes the
+   * screen size.
+   */
+  void imageSizeChanged(int lineCount , int columnCount);
+
+  /** 
+   * Emitted when the terminal program requests to change various properties
+   * of the terminal display.  
+   *
+   * A profile change command occurs when a special escape sequence, followed
+   * by a string containing a series of name and value pairs is received.
+   * This string can be parsed using a ProfileCommandParser instance.
+   *
+   * @param text A string expected to contain a series of key and value pairs in
+   * the form:  name=value;name2=value2 ...
+   */
+  void profileChangeCommandReceived(const QString& text);
+
+protected:
+  virtual void setMode  (int mode) = 0;
+  virtual void resetMode(int mode) = 0;
+   
+ /** 
+   * Processes an incoming character.  See receiveData()
+   * @p ch A unicode character code. 
+   */
+  virtual void receiveChar(int ch);
+
+  /** 
+   * Sets the active screen.  The terminal has two screens, primary and alternate.
+   * The primary screen is used by default.  When certain interactive programs such
+   * as Vim are run, they trigger a switch to the alternate screen.
+   *
+   * @param index 0 to switch to the primary screen, or 1 to switch to the alternate screen
+   */
+  void setScreen(int index); 
+
+  enum EmulationCodec
+  {
+      LocaleCodec = 0,
+      Utf8Codec   = 1
+  };
+  void setCodec(EmulationCodec codec); // codec number, 0 = locale, 1=utf8
+
+
+  QList<ScreenWindow*> _windows;
+  
+  Screen* _currentScreen;  // pointer to the screen which is currently active, 
+                            // this is one of the elements in the screen[] array
+
+  Screen* _screen[2];      // 0 = primary screen ( used by most programs, including the shell
+                            //                      scrollbars are enabled in this mode )
+                            // 1 = alternate      ( used by vi , emacs etc.
+                            //                      scrollbars are not enabled in this mode )
+                            
+  
+  //decodes an incoming C-style character stream into a unicode QString using 
+  //the current text codec.  (this allows for rendering of non-ASCII characters in text files etc.)
+  const QTextCodec* _codec;
+  QTextDecoder* _decoder;
+
+  const KeyboardTranslator* _keyTranslator; // the keyboard layout
+
+protected slots:
+  /** 
+   * Schedules an update of attached views.
+   * Repeated calls to bufferedUpdate() in close succession will result in only a single update,
+   * much like the Qt buffered update of widgets. 
+   */
+  void bufferedUpdate();
+
+private slots: 
+
+  // triggered by timer, causes the emulation to send an updated screen image to each
+  // view
+  void showBulk(); 
+
+  void usesMouseChanged(bool usesMouse);
+
+private:
+
+  bool _usesMouse;
+  QTimer _bulkTimer1;
+  QTimer _bulkTimer2;
+  
+};
+
+#endif // ifndef EMULATION_H
diff --git a/libgui/qterminal/libqterminal/unix/ExtendedDefaultTranslator.h b/libgui/qterminal/libqterminal/unix/ExtendedDefaultTranslator.h
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/ExtendedDefaultTranslator.h
@@ -0,0 +1,74 @@
+"keyboard \"Default (XFree 4)\""
+"key Escape             : \"\\E\""
+"key Tab   -Shift       : \"\\t\"\n"
+"key Tab   +Shift+Ansi  : \"\\E[Z\"\n"
+"key Tab   +Shift-Ansi  : \"\\t\"\n"
+"key Backtab     +Ansi  : \"\\E[Z\"\n"
+"key Backtab     -Ansi  : \"\\t\"\n"
+"key Return-Shift-NewLine : \"\\r\"\n"
+"key Return-Shift+NewLine : \"\\r\\n\"\n"
+"key Return+Shift         : \"\\EOM\"\n"
+"key Backspace      : \"\\x7f\"\n"
+"key Up   -Shift-Ansi : \"\\EA\"\n"
+"key Down -Shift-Ansi : \"\\EB\"\n"
+"key Right-Shift-Ansi : \"\\EC\"\n"
+"key Left -Shift-Ansi : \"\\ED\"\n"
+"key Up    -Shift-AnyMod+Ansi+AppCuKeys           : \"\\EOA\"\n"
+"key Down  -Shift-AnyMod+Ansi+AppCuKeys           : \"\\EOB\"\n"
+"key Right -Shift-AnyMod+Ansi+AppCuKeys           : \"\\EOC\"\n"
+"key Left  -Shift-AnyMod+Ansi+AppCuKeys           : \"\\EOD\"\n"
+"key Up    -Shift-AnyMod+Ansi-AppCuKeys           : \"\\E[A\"\n"
+"key Down  -Shift-AnyMod+Ansi-AppCuKeys           : \"\\E[B\"\n"
+"key Right -Shift-AnyMod+Ansi-AppCuKeys           : \"\\E[C\"\n"
+"key Left  -Shift-AnyMod+Ansi-AppCuKeys           : \"\\E[D\"\n"
+"key Up    -Shift+AnyMod+Ansi                     : \"\\E[1;*A\"\n"
+"key Down  -Shift+AnyMod+Ansi                     : \"\\E[1;*B\"\n"
+"key Right -Shift+AnyMod+Ansi                     : \"\\E[1;*C\"\n"
+"key Left  -Shift+AnyMod+Ansi                     : \"\\E[1;*D\"\n"
+"key Enter+NewLine : \"\\r\\n\"\n"
+"key Enter-NewLine : \"\\r\"\n"
+"key Home        -AnyMod     -AppCuKeys           : \"\\E[H\"  \n"
+"key End         -AnyMod     -AppCuKeys           : \"\\E[F\"  \n"
+"key Home        -AnyMod     +AppCuKeys           : \"\\EOH\"  \n"
+"key End         -AnyMod     +AppCuKeys           : \"\\EOF\"  \n"
+"key Home        +AnyMod                          : \"\\E[1;*H\"\n"
+"key End         +AnyMod                          : \"\\E[1;*F\"\n"
+"key Insert      -AnyMod                          : \"\\E[2~\"\n"
+"key Delete      -AnyMod                          : \"\\E[3~\"\n"
+"key Insert      +AnyMod                          : \"\\E[2;*~\"\n"
+"key Delete      +AnyMod                          : \"\\E[3;*~\"\n"
+"key Prior -Shift-AnyMod                          : \"\\E[5~\"\n"
+"key Next  -Shift-AnyMod                          : \"\\E[6~\"\n"
+"key Prior -Shift+AnyMod                          : \"\\E[5;*~\"\n"
+"key Next  -Shift+AnyMod                          : \"\\E[6;*~\"\n"
+"key F1          -AnyMod                          : \"\\EOP\"\n"
+"key F2          -AnyMod                          : \"\\EOQ\"\n"
+"key F3          -AnyMod                          : \"\\EOR\"\n"
+"key F4          -AnyMod                          : \"\\EOS\"\n"
+"key F5          -AnyMod                          : \"\\E[15~\"\n"
+"key F6          -AnyMod                          : \"\\E[17~\"\n"
+"key F7          -AnyMod                          : \"\\E[18~\"\n"
+"key F8          -AnyMod                          : \"\\E[19~\"\n"
+"key F9          -AnyMod                          : \"\\E[20~\"\n"
+"key F10         -AnyMod                          : \"\\E[21~\"\n"
+"key F11         -AnyMod                          : \"\\E[23~\"\n"
+"key F12         -AnyMod                          : \"\\E[24~\"\n"
+"key F1          +AnyMod                          : \"\\EO*P\"\n"
+"key F2          +AnyMod                          : \"\\EO*Q\"\n"
+"key F3          +AnyMod                          : \"\\EO*R\"\n"
+"key F4          +AnyMod                          : \"\\EO*S\"\n"
+"key F5          +AnyMod                          : \"\\E[15;*~\"\n"
+"key F6          +AnyMod                          : \"\\E[17;*~\"\n"
+"key F7          +AnyMod                          : \"\\E[18;*~\"\n"
+"key F8          +AnyMod                          : \"\\E[19;*~\"\n"
+"key F9          +AnyMod                          : \"\\E[20;*~\"\n"
+"key F10         +AnyMod                          : \"\\E[21;*~\"\n"
+"key F11         +AnyMod                          : \"\\E[23;*~\"\n"
+"key F12         +AnyMod                          : \"\\E[24;*~\"\n"
+"key Space +Control : \"\\x00\"\n"
+"key Up    +Shift-AppScreen  : scrollLineUp\n"
+"key Prior +Shift-AppScreen  : scrollPageUp\n"
+"key Down  +Shift-AppScreen  : scrollLineDown\n"
+"key Next  +Shift-AppScreen  : scrollPageDown\n"
+"key ScrollLock     : scrollLock\n"
+"\0"
diff --git a/libgui/qterminal/libqterminal/unix/Filter.cpp b/libgui/qterminal/libqterminal/unix/Filter.cpp
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/Filter.cpp
@@ -0,0 +1,555 @@
+/*
+    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+// Own
+#include "unix/Filter.h"
+
+// System
+#include <iostream>
+
+// Qt
+#include <QtGui/QAction>
+#include <QtGui/QApplication>
+#include <QtGui/QClipboard>
+#include <QtCore/QString>
+
+#include <QtCore/QSharedData>
+#include <QtCore>
+
+// Konsole
+#include "unix/TerminalCharacterDecoder.h"
+
+FilterChain::~FilterChain()
+{
+    QMutableListIterator<Filter*> iter(*this);
+    
+    while ( iter.hasNext() )
+    {
+        Filter* filter = iter.next();
+        iter.remove();
+        delete filter;
+    }
+}
+
+void FilterChain::addFilter(Filter* filter)
+{
+    append(filter);
+}
+void FilterChain::removeFilter(Filter* filter)
+{
+    removeAll(filter);
+}
+bool FilterChain::containsFilter(Filter* filter)
+{
+    return contains(filter);
+}
+void FilterChain::reset()
+{
+    QListIterator<Filter*> iter(*this);
+    while (iter.hasNext())
+        iter.next()->reset();
+}
+void FilterChain::setBuffer(const QString* buffer , const QList<int>* linePositions)
+{
+    QListIterator<Filter*> iter(*this);
+    while (iter.hasNext())
+        iter.next()->setBuffer(buffer,linePositions);
+}
+void FilterChain::process()
+{
+    QListIterator<Filter*> iter(*this);
+    while (iter.hasNext())
+        iter.next()->process();
+}
+void FilterChain::clear()
+{
+    QList<Filter*>::clear();
+}
+Filter::HotSpot* FilterChain::hotSpotAt(int line , int column) const
+{
+    QListIterator<Filter*> iter(*this);
+    while (iter.hasNext())
+    {
+        Filter* filter = iter.next();
+        Filter::HotSpot* spot = filter->hotSpotAt(line,column);
+        if ( spot != 0 )
+        {
+            return spot;
+        }
+    }
+
+    return 0;
+}
+
+QList<Filter::HotSpot*> FilterChain::hotSpots() const
+{
+    QList<Filter::HotSpot*> list;
+    QListIterator<Filter*> iter(*this);
+    while (iter.hasNext())
+    {
+        Filter* filter = iter.next();
+        list << filter->hotSpots();
+    }
+    return list;
+}
+
+TerminalImageFilterChain::TerminalImageFilterChain()
+: _buffer(0)
+, _linePositions(0)
+{
+}
+
+TerminalImageFilterChain::~TerminalImageFilterChain()
+{
+    delete _buffer;
+    delete _linePositions;
+}
+
+void TerminalImageFilterChain::setImage(const Character* const image , int lines , int columns, const QVector<LineProperty>& lineProperties)
+{
+//qDebug("%s %d", __FILE__, __LINE__);
+    if (empty())
+        return;
+//qDebug("%s %d", __FILE__, __LINE__);
+
+    // reset all filters and hotspots
+    reset();
+//qDebug("%s %d", __FILE__, __LINE__);
+
+    PlainTextDecoder decoder;
+    decoder.setTrailingWhitespace(false);
+    
+//qDebug("%s %d", __FILE__, __LINE__);
+    // setup new shared buffers for the filters to process on
+    QString* newBuffer = new QString();
+    QList<int>* newLinePositions = new QList<int>();
+    setBuffer( newBuffer , newLinePositions );
+
+    // free the old buffers
+    delete _buffer;
+    delete _linePositions;
+
+    _buffer = newBuffer;
+    _linePositions = newLinePositions;
+
+    QTextStream lineStream(_buffer);
+    decoder.begin(&lineStream);
+
+    for (int i=0 ; i < lines ; i++)
+    {
+        _linePositions->append(_buffer->length());
+        decoder.decodeLine(image + i*columns,columns,LINE_DEFAULT);
+
+        // pretend that each line ends with a newline character.
+        // this prevents a link that occurs at the end of one line
+        // being treated as part of a link that occurs at the start of the next line
+        //
+        // the downside is that links which are spread over more than one line are not
+        // highlighted.  
+        //
+        // TODO - Use the "line wrapped" attribute associated with lines in a
+        // terminal image to avoid adding this imaginary character for wrapped
+        // lines
+        if ( !(lineProperties.value(i,LINE_DEFAULT) & LINE_WRAPPED) )
+        	lineStream << QChar('\n');
+    }
+    decoder.end();
+//    qDebug("%s %d", __FILE__, __LINE__);
+}
+
+Filter::Filter() :
+_linePositions(0),
+_buffer(0)
+{
+}
+
+Filter::~Filter()
+{
+    QListIterator<HotSpot*> iter(_hotspotList);
+    while (iter.hasNext())
+    {
+        delete iter.next();
+    }
+}
+void Filter::reset()
+{
+    _hotspots.clear();
+    _hotspotList.clear();
+}
+
+void Filter::setBuffer(const QString* buffer , const QList<int>* linePositions)
+{
+    _buffer = buffer;
+    _linePositions = linePositions;
+}
+
+void Filter::getLineColumn(int position , int& startLine , int& startColumn)
+{
+    Q_ASSERT( _linePositions );
+    Q_ASSERT( _buffer );
+
+
+    for (int i = 0 ; i < _linePositions->count() ; i++)
+    {
+        //kDebug() << "line position at " << i << " = " << _linePositions[i];
+        int nextLine = 0;
+
+        if ( i == _linePositions->count()-1 )
+        {
+            nextLine = _buffer->length() + 1;
+        }
+        else
+        {
+            nextLine = _linePositions->value(i+1);
+        }
+
+       // kDebug() << "pos - " << position << " line pos(" << i<< ") " << _linePositions->value(i) << 
+       //     " next = " << nextLine << " buffer len = " << _buffer->length();
+
+        if ( _linePositions->value(i) <= position && position < nextLine ) 
+        {
+            startLine = i;
+            startColumn = position - _linePositions->value(i);
+            return;
+        }
+    }
+}
+    
+
+/*void Filter::addLine(const QString& text)
+{
+    _linePositions << _buffer.length();
+    _buffer.append(text);
+}*/
+
+const QString* Filter::buffer()
+{
+    return _buffer;
+}
+Filter::HotSpot::~HotSpot()
+{
+}
+void Filter::addHotSpot(HotSpot* spot)
+{
+    _hotspotList << spot;
+
+    for (int line = spot->startLine() ; line <= spot->endLine() ; line++)
+    {
+        _hotspots.insert(line,spot);
+    }    
+}
+QList<Filter::HotSpot*> Filter::hotSpots() const
+{
+    return _hotspotList;
+}
+QList<Filter::HotSpot*> Filter::hotSpotsAtLine(int line) const
+{
+    return _hotspots.values(line);
+}
+
+Filter::HotSpot* Filter::hotSpotAt(int line , int column) const
+{
+    QListIterator<HotSpot*> spotIter(_hotspots.values(line));
+
+    while (spotIter.hasNext())
+    {
+        HotSpot* spot = spotIter.next();
+        
+        if ( spot->startLine() == line && spot->startColumn() > column )
+            continue;
+        if ( spot->endLine() == line && spot->endColumn() < column )
+            continue;
+       
+        return spot;
+    }
+
+    return 0;
+}
+
+Filter::HotSpot::HotSpot(int startLine , int startColumn , int endLine , int endColumn)
+    : _startLine(startLine)
+    , _startColumn(startColumn)
+    , _endLine(endLine)
+    , _endColumn(endColumn)
+    , _type(NotSpecified)
+{
+}
+QString Filter::HotSpot::tooltip() const
+{
+    return QString();
+}
+QList<QAction*> Filter::HotSpot::actions()
+{
+    return QList<QAction*>();
+}
+int Filter::HotSpot::startLine() const
+{
+    return _startLine;
+}
+int Filter::HotSpot::endLine() const
+{
+    return _endLine;
+}
+int Filter::HotSpot::startColumn() const
+{
+    return _startColumn;
+}
+int Filter::HotSpot::endColumn() const
+{
+    return _endColumn;
+}
+Filter::HotSpot::Type Filter::HotSpot::type() const
+{
+    return _type;
+}
+void Filter::HotSpot::setType(Type type)
+{
+    _type = type;
+}
+
+RegExpFilter::RegExpFilter()
+{
+}
+
+RegExpFilter::HotSpot::HotSpot(int startLine,int startColumn,int endLine,int endColumn)
+    : Filter::HotSpot(startLine,startColumn,endLine,endColumn)
+{
+    setType(Marker);
+}
+
+void RegExpFilter::HotSpot::activate(QObject*)
+{
+}
+
+void RegExpFilter::HotSpot::setCapturedTexts(const QStringList& texts)
+{
+    _capturedTexts = texts;
+}
+QStringList RegExpFilter::HotSpot::capturedTexts() const
+{
+    return _capturedTexts;
+}
+
+void RegExpFilter::setRegExp(const QRegExp& regExp) 
+{
+    _searchText = regExp;
+}
+QRegExp RegExpFilter::regExp() const
+{
+    return _searchText;
+}
+/*void RegExpFilter::reset(int)
+{
+    _buffer = QString();
+}*/
+void RegExpFilter::process()
+{
+    int pos = 0;
+    const QString* text = buffer();
+
+    Q_ASSERT( text );
+
+    // ignore any regular expressions which match an empty string.
+    // otherwise the while loop below will run indefinitely
+    static const QString emptyString("");
+    if ( _searchText.exactMatch(emptyString) )
+        return;
+
+    while(pos >= 0)
+    {
+        pos = _searchText.indexIn(*text,pos);
+
+        if ( pos >= 0 )
+        {
+
+            int startLine = 0;
+            int endLine = 0;
+            int startColumn = 0;
+            int endColumn = 0;
+
+            
+            //kDebug() << "pos from " << pos << " to " << pos + _searchText.matchedLength();
+            
+            getLineColumn(pos,startLine,startColumn);
+            getLineColumn(pos + _searchText.matchedLength(),endLine,endColumn);
+
+            //kDebug() << "start " << startLine << " / " << startColumn;
+            //kDebug() << "end " << endLine << " / " << endColumn;
+
+            RegExpFilter::HotSpot* spot = newHotSpot(startLine,startColumn,
+                                           endLine,endColumn);
+            spot->setCapturedTexts(_searchText.capturedTexts());
+
+            addHotSpot( spot );  
+            pos += _searchText.matchedLength();
+
+            // if matchedLength == 0, the program will get stuck in an infinite loop
+            Q_ASSERT( _searchText.matchedLength() > 0 );
+        }
+    }    
+}
+
+RegExpFilter::HotSpot* RegExpFilter::newHotSpot(int startLine,int startColumn,
+                                                int endLine,int endColumn)
+{
+    return new RegExpFilter::HotSpot(startLine,startColumn,
+                                                  endLine,endColumn);
+}
+RegExpFilter::HotSpot* UrlFilter::newHotSpot(int startLine,int startColumn,int endLine,
+                                                    int endColumn)
+{
+    return new UrlFilter::HotSpot(startLine,startColumn,
+                                               endLine,endColumn);
+}
+UrlFilter::HotSpot::HotSpot(int startLine,int startColumn,int endLine,int endColumn)
+: RegExpFilter::HotSpot(startLine,startColumn,endLine,endColumn)
+, _urlObject(new FilterObject(this))
+{
+    setType(Link);
+}
+QString UrlFilter::HotSpot::tooltip() const
+{
+    QString url = capturedTexts().first();
+
+    const UrlType kind = urlType();
+
+    if ( kind == StandardUrl )
+        return QString(); 
+    else if ( kind == Email )
+        return QString(); 
+    else
+        return QString();
+}
+UrlFilter::HotSpot::UrlType UrlFilter::HotSpot::urlType() const
+{
+    QString url = capturedTexts().first();
+    
+    if ( FullUrlRegExp.exactMatch(url) )
+        return StandardUrl;
+    else if ( EmailAddressRegExp.exactMatch(url) )
+        return Email;
+    else
+        return Unknown;
+}
+
+void UrlFilter::HotSpot::activate(QObject* object)
+{
+    QString url = capturedTexts().first();
+
+    const UrlType kind = urlType();
+
+    const QString& actionName = object ? object->objectName() : QString();
+
+    if ( actionName == "copy-action" )
+    {
+        //kDebug() << "Copying url to clipboard:" << url;
+
+        QApplication::clipboard()->setText(url);
+        return;
+    }
+
+    if ( !object || actionName == "open-action" )
+    {
+        if ( kind == StandardUrl )
+        {
+            // if the URL path does not include the protocol ( eg. "www.kde.org" ) then
+            // prepend http:// ( eg. "www.kde.org" --> "http://www.kde.org" )
+            if (!url.contains("://"))
+            {
+                url.prepend("http://");
+            }
+        } 
+        else if ( kind == Email )
+        {
+            url.prepend("mailto:");
+        }
+    
+//        new KRun(url,QApplication::activeWindow());
+    }
+}
+
+// Note:  Altering these regular expressions can have a major effect on the performance of the filters 
+// used for finding URLs in the text, especially if they are very general and could match very long
+// pieces of text.
+// Please be careful when altering them.
+
+//regexp matches:
+// full url:  
+// protocolname:// or www. followed by anything other than whitespaces, <, >, ' or ", and ends before whitespaces, <, >, ', ", ], !, comma and dot
+const QRegExp UrlFilter::FullUrlRegExp("(www\\.(?!\\.)|[a-z][a-z0-9+.-]*://)[^\\s<>'\"]+[^!,\\.\\s<>'\"\\]]");
+// email address:
+// [word chars, dots or dashes]@[word chars, dots or dashes].[word chars]
+const QRegExp UrlFilter::EmailAddressRegExp("\\b(\\w|\\.|-)+@(\\w|\\.|-)+\\.\\w+\\b");
+
+// matches full url or email address
+const QRegExp UrlFilter::CompleteUrlRegExp('('+FullUrlRegExp.pattern()+'|'+
+                                            EmailAddressRegExp.pattern()+')');
+
+UrlFilter::UrlFilter()
+{
+    setRegExp( CompleteUrlRegExp );
+}
+UrlFilter::HotSpot::~HotSpot()
+{
+    delete _urlObject;
+}
+void FilterObject::activated()
+{
+    _filter->activate(sender());
+}
+QList<QAction*> UrlFilter::HotSpot::actions()
+{
+    QList<QAction*> list;
+
+    const UrlType kind = urlType();
+
+    QAction* openAction = new QAction(_urlObject);
+    QAction* copyAction = new QAction(_urlObject);;
+
+    Q_ASSERT( kind == StandardUrl || kind == Email );
+
+    if ( kind == StandardUrl )
+    {
+        openAction->setText(("Open Link"));
+        copyAction->setText(("Copy Link Address"));
+    }
+    else if ( kind == Email )
+    {
+        openAction->setText(("Send Email To..."));
+        copyAction->setText(("Copy Email Address"));
+    }
+
+    // object names are set here so that the hotspot performs the
+    // correct action when activated() is called with the triggered
+    // action passed as a parameter.
+    openAction->setObjectName("open-action");
+    copyAction->setObjectName("copy-action");
+
+    QObject::connect( openAction , SIGNAL(triggered()) , _urlObject , SLOT(activated()) );
+    QObject::connect( copyAction , SIGNAL(triggered()) , _urlObject , SLOT(activated()) );
+
+    list << openAction;
+    list << copyAction;
+
+    return list; 
+}
+
+//#include "moc_Filter.cpp"
diff --git a/libgui/qterminal/libqterminal/unix/Filter.h b/libgui/qterminal/libqterminal/unix/Filter.h
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/Filter.h
@@ -0,0 +1,379 @@
+/*
+    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef FILTER_H
+#define FILTER_H
+
+// Qt
+#include <QtGui/QAction>
+#include <QtCore/QList>
+#include <QtCore/QObject>
+#include <QtCore/QStringList>
+#include <QtCore/QHash>
+#include <QtCore/QRegExp>
+
+// Local
+#include "unix/Character.h"
+
+/**
+ * A filter processes blocks of text looking for certain patterns (such as URLs or keywords from a list)
+ * and marks the areas which match the filter's patterns as 'hotspots'.
+ *
+ * Each hotspot has a type identifier associated with it ( such as a link or a highlighted section ),
+ * and an action.  When the user performs some activity such as a mouse-click in a hotspot area ( the exact
+ * action will depend on what is displaying the block of text which the filter is processing ), the hotspot's
+ * activate() method should be called.  Depending on the type of hotspot this will trigger a suitable response.
+ *
+ * For example, if a hotspot represents a URL then a suitable action would be opening that URL in a web browser.
+ * Hotspots may have more than one action, in which case the list of actions can be obtained using the 
+ * actions() method.
+ *
+ * Different subclasses of filter will return different types of hotspot.
+ * Subclasses must reimplement the process() method to examine a block of text and identify sections of interest.
+ * When processing the text they should create instances of Filter::HotSpot subclasses for sections of interest
+ * and add them to the filter's list of hotspots using addHotSpot()
+ */
+class Filter
+{
+public:
+    /**
+    * Represents an area of text which matched the pattern a particular filter has been looking for.
+    *
+    * Each hotspot has a type identifier associated with it ( such as a link or a highlighted section ),
+    * and an action.  When the user performs some activity such as a mouse-click in a hotspot area ( the exact
+    * action will depend on what is displaying the block of text which the filter is processing ), the hotspot's
+    * activate() method should be called.  Depending on the type of hotspot this will trigger a suitable response.
+    *
+    * For example, if a hotspot represents a URL then a suitable action would be opening that URL in a web browser.
+    * Hotspots may have more than one action, in which case the list of actions can be obtained using the 
+    * actions() method.  These actions may then be displayed in a popup menu or toolbar for example. 
+    */
+    class HotSpot
+    {
+    public:
+       /** 
+        * Constructs a new hotspot which covers the area from (@p startLine,@p startColumn) to (@p endLine,@p endColumn)
+        * in a block of text.
+        */
+       HotSpot(int startLine , int startColumn , int endLine , int endColumn);
+       virtual ~HotSpot();
+
+       enum Type
+       {
+            // the type of the hotspot is not specified
+            NotSpecified,
+            // this hotspot represents a clickable link
+            Link,
+            // this hotspot represents a marker
+            Marker
+       }; 
+
+       /** Returns the line when the hotspot area starts */
+       int startLine() const;
+       /** Returns the line where the hotspot area ends */
+       int endLine() const;
+       /** Returns the column on startLine() where the hotspot area starts */
+       int startColumn() const;
+       /** Returns the column on endLine() where the hotspot area ends */
+       int endColumn() const;
+       /** 
+        * Returns the type of the hotspot.  This is usually used as a hint for views on how to represent
+        * the hotspot graphically.  eg.  Link hotspots are typically underlined when the user mouses over them
+        */
+       Type type() const;
+       /** 
+        * Causes the an action associated with a hotspot to be triggered. 
+        *
+        * @param object The object which caused the hotspot to be triggered.  This is
+        * typically null ( in which case the default action should be performed ) or
+        * one of the objects from the actions() list.  In which case the associated
+        * action should be performed. 
+        */
+       virtual void activate(QObject* object = 0) = 0; 
+       /** 
+        * Returns a list of actions associated with the hotspot which can be used in a 
+        * menu or toolbar 
+        */
+       virtual QList<QAction*> actions();
+
+       /** 
+        * Returns the text of a tooltip to be shown when the mouse moves over the hotspot, or
+        * an empty string if there is no tooltip associated with this hotspot.
+        *
+        * The default implementation returns an empty string. 
+        */
+       virtual QString tooltip() const;
+
+    protected:
+       /** Sets the type of a hotspot.  This should only be set once */
+       void setType(Type type);
+
+    private:
+       int    _startLine;
+       int    _startColumn;
+       int    _endLine;
+       int    _endColumn;
+       Type _type;
+    
+    };
+
+    /** Constructs a new filter. */
+    Filter();
+    virtual ~Filter();
+
+    /** Causes the filter to process the block of text currently in its internal buffer */
+    virtual void process() = 0;
+
+    /** 
+     * Empties the filters internal buffer and resets the line count back to 0.
+     * All hotspots are deleted. 
+     */
+    void reset();
+
+    /** Adds a new line of text to the filter and increments the line count */
+    //void addLine(const QString& string);
+
+    /** Returns the hotspot which covers the given @p line and @p column, or 0 if no hotspot covers that area */
+    HotSpot* hotSpotAt(int line , int column) const;
+
+    /** Returns the list of hotspots identified by the filter */
+    QList<HotSpot*> hotSpots() const;
+
+    /** Returns the list of hotspots identified by the filter which occur on a given line */
+    QList<HotSpot*> hotSpotsAtLine(int line) const;
+
+    /** 
+     * TODO: Document me
+     */
+    void setBuffer(const QString* buffer , const QList<int>* linePositions);
+
+protected:
+    /** Adds a new hotspot to the list */
+    void addHotSpot(HotSpot*);
+    /** Returns the internal buffer */
+    const QString* buffer();
+    /** Converts a character position within buffer() to a line and column */
+    void getLineColumn(int position , int& startLine , int& startColumn);
+
+private:
+    QMultiHash<int,HotSpot*> _hotspots;
+    QList<HotSpot*> _hotspotList;
+    
+    const QList<int>* _linePositions;
+    const QString* _buffer;
+};
+
+/** 
+ * A filter which searches for sections of text matching a regular expression and creates a new RegExpFilter::HotSpot 
+ * instance for them.
+ *
+ * Subclasses can reimplement newHotSpot() to return custom hotspot types when matches for the regular expression
+ * are found. 
+ */
+class RegExpFilter : public Filter
+{
+public:
+    /** 
+     * Type of hotspot created by RegExpFilter.  The capturedTexts() method can be used to find the text
+     * matched by the filter's regular expression.
+     */
+    class HotSpot : public Filter::HotSpot
+    {
+    public:
+        HotSpot(int startLine, int startColumn, int endLine , int endColumn);
+        virtual void activate(QObject* object = 0);
+
+        /** Sets the captured texts associated with this hotspot */
+        void setCapturedTexts(const QStringList& texts);
+        /** Returns the texts found by the filter when matching the filter's regular expression */
+        QStringList capturedTexts() const;
+    private:
+        QStringList _capturedTexts;
+    };
+
+    /** Constructs a new regular expression filter */
+    RegExpFilter();
+
+    /** 
+     * Sets the regular expression which the filter searches for in blocks of text. 
+     *
+     * Regular expressions which match the empty string are treated as not matching
+     * anything. 
+     */
+    void setRegExp(const QRegExp& text);
+    /** Returns the regular expression which the filter searches for in blocks of text */
+    QRegExp regExp() const;
+
+    /** 
+     * Reimplemented to search the filter's text buffer for text matching regExp() 
+     *
+     * If regexp matches the empty string, then process() will return immediately
+     * without finding results. 
+     */
+    virtual void process();
+
+protected:
+    /** 
+     * Called when a match for the regular expression is encountered.  Subclasses should reimplement this
+     * to return custom hotspot types
+     */
+    virtual RegExpFilter::HotSpot* newHotSpot(int startLine,int startColumn,
+                                    int endLine,int endColumn);
+
+private:
+    QRegExp _searchText;
+};
+
+class FilterObject;
+
+/** A filter which matches URLs in blocks of text */
+class UrlFilter : public RegExpFilter 
+{
+public:
+    /** 
+     * Hotspot type created by UrlFilter instances.  The activate() method opens a web browser 
+     * at the given URL when called.
+     */
+    class HotSpot : public RegExpFilter::HotSpot 
+    {
+    public:
+        HotSpot(int startLine,int startColumn,int endLine,int endColumn);
+        virtual ~HotSpot();
+
+        virtual QList<QAction*> actions();
+
+        /** 
+         * Open a web browser at the current URL.  The url itself can be determined using
+         * the capturedTexts() method.
+         */
+        virtual void activate(QObject* object = 0);
+
+        virtual QString tooltip() const;
+    private:
+        enum UrlType
+        {
+            StandardUrl,
+            Email,
+            Unknown
+        };
+        UrlType urlType() const;
+
+        FilterObject* _urlObject;
+    };
+
+    UrlFilter();
+
+protected:
+    virtual RegExpFilter::HotSpot* newHotSpot(int,int,int,int);
+
+private:
+    
+    static const QRegExp FullUrlRegExp;
+    static const QRegExp EmailAddressRegExp;
+
+    // combined OR of FullUrlRegExp and EmailAddressRegExp
+    static const QRegExp CompleteUrlRegExp; 
+};
+
+class FilterObject : public QObject
+{
+Q_OBJECT
+public:
+    FilterObject(Filter::HotSpot* filter) : _filter(filter) {}
+private slots:
+    void activated();
+private:
+    Filter::HotSpot* _filter;
+};
+
+/** 
+ * A chain which allows a group of filters to be processed as one. 
+ * The chain owns the filters added to it and deletes them when the chain itself is destroyed.
+ *
+ * Use addFilter() to add a new filter to the chain.  
+ * When new text to be filtered arrives, use addLine() to add each additional
+ * line of text which needs to be processed and then after adding the last line, use
+ * process() to cause each filter in the chain to process the text.
+ *
+ * After processing a block of text, the reset() method can be used to set the filter chain's
+ * internal cursor back to the first line.
+ *
+ * The hotSpotAt() method will return the first hotspot which covers a given position.
+ *
+ * The hotSpots() and hotSpotsAtLine() method return all of the hotspots in the text and on
+ * a given line respectively.
+ */
+class FilterChain : protected QList<Filter*>
+{
+public:
+    virtual ~FilterChain();
+
+    /** Adds a new filter to the chain.  The chain will delete this filter when it is destroyed */
+    void addFilter(Filter* filter);
+    /** Removes a filter from the chain.  The chain will no longer delete the filter when destroyed */
+    void removeFilter(Filter* filter);
+    /** Returns true if the chain contains @p filter */
+    bool containsFilter(Filter* filter);
+    /** Removes all filters from the chain */
+    void clear();
+
+    /** Resets each filter in the chain */
+    void reset();
+    /**
+     * Processes each filter in the chain 
+     */
+    void process();
+
+    /** Sets the buffer for each filter in the chain to process. */
+    void setBuffer(const QString* buffer , const QList<int>* linePositions); 
+
+    /** Returns the first hotspot which occurs at @p line, @p column or 0 if no hotspot was found */
+    Filter::HotSpot* hotSpotAt(int line , int column) const;
+    /** Returns a list of all the hotspots in all the chain's filters */
+    QList<Filter::HotSpot*> hotSpots() const;
+    /** Returns a list of all hotspots at the given line in all the chain's filters */
+    QList<Filter::HotSpot> hotSpotsAtLine(int line) const;
+
+};
+
+/** A filter chain which processes character images from terminal displays */
+class TerminalImageFilterChain : public FilterChain
+{
+public:
+    TerminalImageFilterChain();
+    virtual ~TerminalImageFilterChain();
+
+    /**
+     * Set the current terminal image to @p image.
+     *
+     * @param image The terminal image
+     * @param lines The number of lines in the terminal image
+     * @param columns The number of columns in the terminal image
+     */
+    void setImage(const Character* const image , int lines , int columns,
+				  const QVector<LineProperty>& lineProperties);  
+
+private:
+    QString* _buffer;
+    QList<int>* _linePositions;
+};
+
+#endif //FILTER_H
diff --git a/libgui/qterminal/libqterminal/unix/History.cpp b/libgui/qterminal/libqterminal/unix/History.cpp
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/History.cpp
@@ -0,0 +1,696 @@
+/*
+    This file is part of Konsole, an X terminal.
+    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+// Own
+#include "unix/History.h"
+
+// System
+#include <iostream>
+#include <stdlib.h>
+#include <assert.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/mman.h>
+#include <unistd.h>
+#include <errno.h>
+
+
+// Reasonable line size
+#define LINE_SIZE	1024
+
+/*
+   An arbitrary long scroll.
+
+   One can modify the scroll only by adding either cells
+   or newlines, but access it randomly.
+
+   The model is that of an arbitrary wide typewriter scroll
+   in that the scroll is a serie of lines and each line is
+   a serie of cells with no overwriting permitted.
+
+   The implementation provides arbitrary length and numbers
+   of cells and line/column indexed read access to the scroll
+   at constant costs.
+
+KDE4: Can we use QTemporaryFile here, instead of KTempFile?
+
+FIXME: some complain about the history buffer comsuming the
+       memory of their machines. This problem is critical
+       since the history does not behave gracefully in cases
+       where the memory is used up completely.
+
+       I put in a workaround that should handle it problem
+       now gracefully. I'm not satisfied with the solution.
+
+FIXME: Terminating the history is not properly indicated
+       in the menu. We should throw a signal.
+
+FIXME: There is noticeable decrease in speed, also. Perhaps,
+       there whole feature needs to be revisited therefore.
+       Disadvantage of a more elaborated, say block-oriented
+       scheme with wrap around would be it's complexity.
+*/
+
+//FIXME: tempory replacement for tmpfile
+//       this is here one for debugging purpose.
+
+//#define tmpfile xTmpFile
+
+// History File ///////////////////////////////////////////
+
+/*
+  A Row(X) data type which allows adding elements to the end.
+*/
+
+HistoryFile::HistoryFile()
+  : ion(-1),
+    length(0),
+	fileMap(0)
+{
+  if (tmpFile.open())
+  { 
+    tmpFile.setAutoRemove(true);
+    ion = tmpFile.handle();
+  }
+}
+
+HistoryFile::~HistoryFile()
+{
+	if (fileMap)
+		unmap();
+}
+
+//TODO:  Mapping the entire file in will cause problems if the history file becomes exceedingly large,
+//(ie. larger than available memory).  HistoryFile::map() should only map in sections of the file at a time,
+//to avoid this.
+void HistoryFile::map()
+{
+	assert( fileMap == 0 );
+
+	fileMap = (char*)mmap( 0 , length , PROT_READ , MAP_PRIVATE , ion , 0 );
+
+    //if mmap'ing fails, fall back to the read-lseek combination
+    if ( fileMap == MAP_FAILED )
+    {
+            readWriteBalance = 0; 
+            fileMap = 0;
+            qDebug() << ": mmap'ing history failed.  errno = " << errno;
+    }
+}
+
+void HistoryFile::unmap()
+{
+	int result = munmap( fileMap , length );
+	assert( result == 0 );
+
+	fileMap = 0;
+}
+
+bool HistoryFile::isMapped()
+{
+	return (fileMap != 0);
+}
+
+void HistoryFile::add(const unsigned char* bytes, int len)
+{
+  if ( fileMap )
+		  unmap();
+		
+  readWriteBalance++;
+
+  int rc = 0;
+
+  rc = lseek(ion,length,SEEK_SET); if (rc < 0) { perror("HistoryFile::add.seek"); return; }
+  rc = write(ion,bytes,len);       if (rc < 0) { perror("HistoryFile::add.write"); return; }
+  length += rc;
+}
+
+void HistoryFile::get(unsigned char* bytes, int len, int loc)
+{
+  //count number of get() calls vs. number of add() calls.  
+  //If there are many more get() calls compared with add() 
+  //calls (decided by using MAP_THRESHOLD) then mmap the log
+  //file to improve performance.
+  readWriteBalance--;
+  if ( !fileMap && readWriteBalance < MAP_THRESHOLD )
+		  map();
+
+  if ( fileMap )
+  {
+	for (int i=0;i<len;i++)
+			bytes[i]=fileMap[loc+i];
+  }
+  else
+  {	
+  	int rc = 0;
+
+  	if (loc < 0 || len < 0 || loc + len > length)
+    	fprintf(stderr,"getHist(...,%d,%d): invalid args.\n",len,loc);
+  	rc = lseek(ion,loc,SEEK_SET); if (rc < 0) { perror("HistoryFile::get.seek"); return; }
+  	rc = read(ion,bytes,len);     if (rc < 0) { perror("HistoryFile::get.read"); return; }
+  }
+}
+
+int HistoryFile::len()
+{
+  return length;
+}
+
+
+// History Scroll abstract base class //////////////////////////////////////
+
+
+HistoryScroll::HistoryScroll(HistoryType* t)
+  : m_histType(t)
+{
+}
+
+HistoryScroll::~HistoryScroll()
+{
+  delete m_histType;
+}
+
+bool HistoryScroll::hasScroll()
+{
+  return true;
+}
+
+// History Scroll File //////////////////////////////////////
+
+/* 
+   The history scroll makes a Row(Row(Cell)) from
+   two history buffers. The index buffer contains
+   start of line positions which refere to the cells
+   buffer.
+
+   Note that index[0] addresses the second line
+   (line #1), while the first line (line #0) starts
+   at 0 in cells.
+*/
+
+HistoryScrollFile::HistoryScrollFile(const QString &logFileName)
+  : HistoryScroll(new HistoryTypeFile(logFileName)),
+  m_logFileName(logFileName)
+{
+}
+
+HistoryScrollFile::~HistoryScrollFile()
+{
+}
+ 
+int HistoryScrollFile::getLines()
+{
+  return index.len() / sizeof(int);
+}
+
+int HistoryScrollFile::getLineLen(int lineno)
+{
+  return (startOfLine(lineno+1) - startOfLine(lineno)) / sizeof(Character);
+}
+
+bool HistoryScrollFile::isWrappedLine(int lineno)
+{
+  if (lineno>=0 && lineno <= getLines()) {
+    unsigned char flag;
+    lineflags.get((unsigned char*)&flag,sizeof(unsigned char),(lineno)*sizeof(unsigned char));
+    return flag;
+  }
+  return false;
+}
+
+int HistoryScrollFile::startOfLine(int lineno)
+{
+  if (lineno <= 0) return 0;
+  if (lineno <= getLines())
+    { 
+	
+	if (!index.isMapped())
+			index.map();
+	
+	int res;
+    index.get((unsigned char*)&res,sizeof(int),(lineno-1)*sizeof(int));
+    return res;
+    }
+  return cells.len();
+}
+
+void HistoryScrollFile::getCells(int lineno, int colno, int count, Character res[])
+{
+  cells.get((unsigned char*)res,count*sizeof(Character),startOfLine(lineno)+colno*sizeof(Character));
+}
+
+void HistoryScrollFile::addCells(const Character text[], int count)
+{
+  cells.add((unsigned char*)text,count*sizeof(Character));
+}
+
+void HistoryScrollFile::addLine(bool previousWrapped)
+{
+  if (index.isMapped())
+		  index.unmap();
+
+  int locn = cells.len();
+  index.add((unsigned char*)&locn,sizeof(int));
+  unsigned char flags = previousWrapped ? 0x01 : 0x00;
+  lineflags.add((unsigned char*)&flags,sizeof(unsigned char));
+}
+
+
+// History Scroll Buffer //////////////////////////////////////
+HistoryScrollBuffer::HistoryScrollBuffer(unsigned int maxLineCount)
+  : HistoryScroll(new HistoryTypeBuffer(maxLineCount))
+   ,_historyBuffer()
+   ,_maxLineCount(0)
+   ,_usedLines(0)
+   ,_head(0)
+{
+  setMaxNbLines(maxLineCount);
+}
+
+HistoryScrollBuffer::~HistoryScrollBuffer()
+{
+    delete[] _historyBuffer;
+}
+
+void HistoryScrollBuffer::addCellsVector(const QVector<Character>& cells)
+{
+    _head++;
+    if ( _usedLines < _maxLineCount )
+        _usedLines++;
+
+    if ( _head >= _maxLineCount )
+    {
+        _head = 0;
+    }
+
+    _historyBuffer[bufferIndex(_usedLines-1)] = cells;
+    _wrappedLine[bufferIndex(_usedLines-1)] = false;
+}
+void HistoryScrollBuffer::addCells(const Character a[], int count)
+{
+  HistoryLine newLine(count);
+  qCopy(a,a+count,newLine.begin());
+
+  addCellsVector(newLine);
+}
+
+void HistoryScrollBuffer::addLine(bool previousWrapped)
+{
+    _wrappedLine[bufferIndex(_usedLines-1)] = previousWrapped;
+}
+
+int HistoryScrollBuffer::getLines()
+{
+    return _usedLines;
+}
+
+int HistoryScrollBuffer::getLineLen(int lineNumber)
+{
+  Q_ASSERT( lineNumber >= 0 && lineNumber < _maxLineCount );
+
+  if ( lineNumber < _usedLines )
+  {
+    return _historyBuffer[bufferIndex(lineNumber)].size();
+  }
+  else
+  {
+    return 0;
+  }
+}
+
+bool HistoryScrollBuffer::isWrappedLine(int lineNumber)
+{
+  Q_ASSERT( lineNumber >= 0 && lineNumber < _maxLineCount );
+    
+  if (lineNumber < _usedLines)
+  {
+    //kDebug() << "Line" << lineNumber << "wrapped is" << _wrappedLine[bufferIndex(lineNumber)];
+    return _wrappedLine[bufferIndex(lineNumber)];
+  }
+  else
+    return false;
+}
+
+void HistoryScrollBuffer::getCells(int lineNumber, int startColumn, int count, Character* buffer)
+{
+  if ( count == 0 ) return;
+
+  Q_ASSERT( lineNumber < _maxLineCount );
+
+  if (lineNumber >= _usedLines) 
+  {
+    memset(buffer, 0, count * sizeof(Character));
+    return;
+  }
+  
+  const HistoryLine& line = _historyBuffer[bufferIndex(lineNumber)];
+
+  //kDebug() << "startCol " << startColumn;
+  //kDebug() << "line.size() " << line.size();
+  //kDebug() << "count " << count;
+
+  Q_ASSERT( startColumn <= line.size() - count );
+    
+  memcpy(buffer, line.constData() + startColumn , count * sizeof(Character));
+}
+
+void HistoryScrollBuffer::setMaxNbLines(unsigned int lineCount)
+{
+    HistoryLine* oldBuffer = _historyBuffer;
+    HistoryLine* newBuffer = new HistoryLine[lineCount];
+    
+    for ( int i = 0 ; i < qMin(_usedLines,(int)lineCount) ; i++ )
+    {
+        newBuffer[i] = oldBuffer[bufferIndex(i)];
+    }
+    
+    _usedLines = qMin(_usedLines,(int)lineCount);
+    _maxLineCount = lineCount;
+    _head = ( _usedLines == _maxLineCount ) ? 0 : _usedLines-1;
+
+    _historyBuffer = newBuffer;
+    delete[] oldBuffer;
+
+    _wrappedLine.resize(lineCount);
+}
+
+int HistoryScrollBuffer::bufferIndex(int lineNumber)
+{
+    Q_ASSERT( lineNumber >= 0 );
+    Q_ASSERT( lineNumber < _maxLineCount );
+    Q_ASSERT( (_usedLines == _maxLineCount) || lineNumber <= _head );
+
+    if ( _usedLines == _maxLineCount )
+    {
+        return (_head+lineNumber+1) % _maxLineCount;
+    }
+    else
+    {   
+        return lineNumber;
+    }
+}
+
+
+// History Scroll None //////////////////////////////////////
+
+HistoryScrollNone::HistoryScrollNone()
+  : HistoryScroll(new HistoryTypeNone())
+{
+}
+
+HistoryScrollNone::~HistoryScrollNone()
+{
+}
+
+bool HistoryScrollNone::hasScroll()
+{
+  return false;
+}
+
+int  HistoryScrollNone::getLines()
+{
+  return 0;
+}
+
+int  HistoryScrollNone::getLineLen(int)
+{
+  return 0;
+}
+
+bool HistoryScrollNone::isWrappedLine(int /*lineno*/)
+{
+  return false;
+}
+
+void HistoryScrollNone::getCells(int, int, int, Character [])
+{
+}
+
+void HistoryScrollNone::addCells(const Character [], int)
+{
+}
+
+void HistoryScrollNone::addLine(bool)
+{
+}
+
+// History Scroll BlockArray //////////////////////////////////////
+
+HistoryScrollBlockArray::HistoryScrollBlockArray(size_t size)
+  : HistoryScroll(new HistoryTypeBlockArray(size))
+{
+  m_blockArray.setHistorySize(size); // nb. of lines.
+}
+
+HistoryScrollBlockArray::~HistoryScrollBlockArray()
+{
+}
+
+int  HistoryScrollBlockArray::getLines()
+{
+  return m_lineLengths.count();
+}
+
+int  HistoryScrollBlockArray::getLineLen(int lineno)
+{
+    if ( m_lineLengths.contains(lineno) )
+        return m_lineLengths[lineno];
+    else
+        return 0;
+}
+
+bool HistoryScrollBlockArray::isWrappedLine(int /*lineno*/)
+{
+  return false;
+}
+
+void HistoryScrollBlockArray::getCells(int lineno, int colno,
+                                       int count, Character res[])
+{
+  if (!count) return;
+
+  const Block *b = m_blockArray.at(lineno);
+
+  if (!b) {
+    memset(res, 0, count * sizeof(Character)); // still better than random data
+    return;
+  }
+
+  assert(((colno + count) * sizeof(Character)) < ENTRIES);
+  memcpy(res, b->data + (colno * sizeof(Character)), count * sizeof(Character));
+}
+
+void HistoryScrollBlockArray::addCells(const Character a[], int count)
+{
+  Block *b = m_blockArray.lastBlock();
+  
+  if (!b) return;
+
+  // put cells in block's data
+  assert((count * sizeof(Character)) < ENTRIES);
+
+  memset(b->data, 0, ENTRIES);
+
+  memcpy(b->data, a, count * sizeof(Character));
+  b->size = count * sizeof(Character);
+
+  size_t res = m_blockArray.newBlock();
+  assert (res > 0);
+  Q_UNUSED( res );
+
+  m_lineLengths.insert(m_blockArray.getCurrent(), count);
+}
+
+void HistoryScrollBlockArray::addLine(bool)
+{
+}
+
+//////////////////////////////////////////////////////////////////////
+// History Types
+//////////////////////////////////////////////////////////////////////
+
+HistoryType::HistoryType()
+{
+}
+
+HistoryType::~HistoryType()
+{
+}
+
+//////////////////////////////
+
+HistoryTypeNone::HistoryTypeNone()
+{
+}
+
+bool HistoryTypeNone::isEnabled() const
+{
+  return false;
+}
+
+HistoryScroll* HistoryTypeNone::scroll(HistoryScroll *old) const
+{
+  delete old;
+  return new HistoryScrollNone();
+}
+
+int HistoryTypeNone::maximumLineCount() const
+{
+  return 0;
+}
+
+//////////////////////////////
+
+HistoryTypeBlockArray::HistoryTypeBlockArray(size_t size)
+  : m_size(size)
+{
+}
+
+bool HistoryTypeBlockArray::isEnabled() const
+{
+  return true;
+}
+
+int HistoryTypeBlockArray::maximumLineCount() const
+{
+  return m_size;
+}
+
+HistoryScroll* HistoryTypeBlockArray::scroll(HistoryScroll *old) const
+{
+  delete old;
+  return new HistoryScrollBlockArray(m_size);
+}
+
+
+//////////////////////////////
+
+HistoryTypeBuffer::HistoryTypeBuffer(unsigned int nbLines)
+  : m_nbLines(nbLines)
+{
+}
+
+bool HistoryTypeBuffer::isEnabled() const
+{
+  return true;
+}
+
+int HistoryTypeBuffer::maximumLineCount() const
+{
+  return m_nbLines;
+}
+
+HistoryScroll* HistoryTypeBuffer::scroll(HistoryScroll *old) const
+{
+  if (old)
+  {
+    HistoryScrollBuffer *oldBuffer = dynamic_cast<HistoryScrollBuffer*>(old);
+    if (oldBuffer)
+    {
+       oldBuffer->setMaxNbLines(m_nbLines);
+       return oldBuffer;
+    }
+
+    HistoryScroll *newScroll = new HistoryScrollBuffer(m_nbLines);
+    int lines = old->getLines();
+    int startLine = 0;
+    if (lines > (int) m_nbLines)
+       startLine = lines - m_nbLines;
+
+    Character line[LINE_SIZE];
+    for(int i = startLine; i < lines; i++)
+    {
+       int size = old->getLineLen(i);
+       if (size > LINE_SIZE)
+       {
+          Character *tmp_line = new Character[size];
+          old->getCells(i, 0, size, tmp_line);
+          newScroll->addCells(tmp_line, size);
+          newScroll->addLine(old->isWrappedLine(i));
+          delete [] tmp_line;
+       }
+       else
+       {
+          old->getCells(i, 0, size, line);
+          newScroll->addCells(line, size);
+          newScroll->addLine(old->isWrappedLine(i));
+       }
+    }
+    delete old;
+    return newScroll;
+  }
+  return new HistoryScrollBuffer(m_nbLines);
+}
+
+//////////////////////////////
+
+HistoryTypeFile::HistoryTypeFile(const QString& fileName)
+  : m_fileName(fileName)
+{
+}
+
+bool HistoryTypeFile::isEnabled() const
+{
+  return true;
+}
+
+const QString& HistoryTypeFile::getFileName() const
+{
+  return m_fileName;
+}
+
+HistoryScroll* HistoryTypeFile::scroll(HistoryScroll *old) const
+{
+  if (dynamic_cast<HistoryFile *>(old)) 
+     return old; // Unchanged.
+
+  HistoryScroll *newScroll = new HistoryScrollFile(m_fileName);
+
+  Character line[LINE_SIZE];
+  int lines = (old != 0) ? old->getLines() : 0;
+  for(int i = 0; i < lines; i++)
+  {
+     int size = old->getLineLen(i);
+     if (size > LINE_SIZE)
+     {
+        Character *tmp_line = new Character[size];
+        old->getCells(i, 0, size, tmp_line);
+        newScroll->addCells(tmp_line, size);
+        newScroll->addLine(old->isWrappedLine(i));
+        delete [] tmp_line;
+     }
+     else
+     {
+        old->getCells(i, 0, size, line);
+        newScroll->addCells(line, size);
+        newScroll->addLine(old->isWrappedLine(i));
+     }
+  }
+
+  delete old;
+  return newScroll; 
+}
+
+int HistoryTypeFile::maximumLineCount() const
+{
+  return 0;
+}
diff --git a/libgui/qterminal/libqterminal/unix/History.h b/libgui/qterminal/libqterminal/unix/History.h
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/History.h
@@ -0,0 +1,330 @@
+/*
+    This file is part of Konsole, an X terminal.
+    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef HISTORY_H
+#define HISTORY_H
+
+// Qt
+#include <QtCore/QBitRef>
+#include <QtCore/QHash>
+#include <QtCore>
+
+// Konsole
+#include "unix/BlockArray.h"
+#include "unix/Character.h"
+
+
+class HistoryFile
+{
+public:
+  HistoryFile();
+  virtual ~HistoryFile();
+
+  virtual void add(const unsigned char* bytes, int len);
+  virtual void get(unsigned char* bytes, int len, int loc);
+  virtual int  len();
+
+  //mmaps the file in read-only mode
+  void map();
+  //un-mmaps the file
+  void unmap();
+  //returns true if the file is mmap'ed
+  bool isMapped();
+
+
+private:
+  int  ion;
+  int  length;
+  QTemporaryFile tmpFile;
+
+  //pointer to start of mmap'ed file data, or 0 if the file is not mmap'ed
+  char* fileMap;
+ 
+  //incremented whenver 'add' is called and decremented whenever
+  //'get' is called.
+  //this is used to detect when a large number of lines are being read and processed from the history
+  //and automatically mmap the file for better performance (saves the overhead of many lseek-read calls).
+  int readWriteBalance;
+
+  //when readWriteBalance goes below this threshold, the file will be mmap'ed automatically
+  static const int MAP_THRESHOLD = -1000;
+};
+
+//////////////////////////////////////////////////////////////////////
+
+//////////////////////////////////////////////////////////////////////
+// Abstract base class for file and buffer versions
+//////////////////////////////////////////////////////////////////////
+class HistoryType;
+
+class HistoryScroll
+{
+public:
+  HistoryScroll(HistoryType*);
+ virtual ~HistoryScroll();
+
+  virtual bool hasScroll();
+
+  // access to history
+  virtual int  getLines() = 0;
+  virtual int  getLineLen(int lineno) = 0;
+  virtual void getCells(int lineno, int colno, int count, Character res[]) = 0;
+  virtual bool isWrappedLine(int lineno) = 0;
+
+  // backward compatibility (obsolete)
+  Character   getCell(int lineno, int colno) { Character res; getCells(lineno,colno,1,&res); return res; }
+
+  // adding lines.
+  virtual void addCells(const Character a[], int count) = 0;
+  // convenience method - this is virtual so that subclasses can take advantage
+  // of QVector's implicit copying
+  virtual void addCellsVector(const QVector<Character>& cells)
+  {
+    addCells(cells.data(),cells.size());
+  }
+
+  virtual void addLine(bool previousWrapped=false) = 0;
+
+  //
+  // FIXME:  Passing around constant references to HistoryType instances
+  // is very unsafe, because those references will no longer
+  // be valid if the history scroll is deleted.
+  //
+  const HistoryType& getType() { return *m_histType; }
+
+protected:
+  HistoryType* m_histType;
+
+};
+
+
+//////////////////////////////////////////////////////////////////////
+// File-based history (e.g. file log, no limitation in length)
+//////////////////////////////////////////////////////////////////////
+
+class HistoryScrollFile : public HistoryScroll
+{
+public:
+  HistoryScrollFile(const QString &logFileName);
+  virtual ~HistoryScrollFile();
+
+  virtual int  getLines();
+  virtual int  getLineLen(int lineno);
+  virtual void getCells(int lineno, int colno, int count, Character res[]);
+  virtual bool isWrappedLine(int lineno);
+
+  virtual void addCells(const Character a[], int count);
+  virtual void addLine(bool previousWrapped=false);
+
+private:
+  int startOfLine(int lineno);
+
+  QString m_logFileName;
+  HistoryFile index; // lines Row(int)
+  HistoryFile cells; // text  Row(Character)
+  HistoryFile lineflags; // flags Row(unsigned char)
+};
+
+
+//////////////////////////////////////////////////////////////////////
+// Buffer-based history (limited to a fixed nb of lines)
+//////////////////////////////////////////////////////////////////////
+class HistoryScrollBuffer : public HistoryScroll
+{
+public:
+  typedef QVector<Character> HistoryLine;
+
+  HistoryScrollBuffer(unsigned int maxNbLines = 1000);
+  virtual ~HistoryScrollBuffer();
+
+  virtual int  getLines();
+  virtual int  getLineLen(int lineno);
+  virtual void getCells(int lineno, int colno, int count, Character res[]);
+  virtual bool isWrappedLine(int lineno);
+
+  virtual void addCells(const Character a[], int count);
+  virtual void addCellsVector(const QVector<Character>& cells);
+  virtual void addLine(bool previousWrapped=false);
+
+  void setMaxNbLines(unsigned int nbLines);
+  unsigned int maxNbLines() { return _maxLineCount; }
+  
+
+private:
+  int bufferIndex(int lineNumber);
+
+  HistoryLine* _historyBuffer;
+  QBitArray _wrappedLine;
+  int _maxLineCount;
+  int _usedLines;  
+  int _head;
+  
+  //QVector<histline*> m_histBuffer;
+  //QBitArray m_wrappedLine;
+  //unsigned int m_maxNbLines;
+  //unsigned int m_nbLines;
+  //unsigned int m_arrayIndex;
+  //bool         m_buffFilled;
+};
+
+/*class HistoryScrollBufferV2 : public HistoryScroll
+{
+public:
+  virtual int  getLines();
+  virtual int  getLineLen(int lineno);
+  virtual void getCells(int lineno, int colno, int count, Character res[]);
+  virtual bool isWrappedLine(int lineno);
+
+  virtual void addCells(const Character a[], int count);
+  virtual void addCells(const QVector<Character>& cells);
+  virtual void addLine(bool previousWrapped=false);
+
+};*/
+
+
+//////////////////////////////////////////////////////////////////////
+// Nothing-based history (no history :-)
+//////////////////////////////////////////////////////////////////////
+class HistoryScrollNone : public HistoryScroll
+{
+public:
+  HistoryScrollNone();
+  virtual ~HistoryScrollNone();
+
+  virtual bool hasScroll();
+
+  virtual int  getLines();
+  virtual int  getLineLen(int lineno);
+  virtual void getCells(int lineno, int colno, int count, Character res[]);
+  virtual bool isWrappedLine(int lineno);
+
+  virtual void addCells(const Character a[], int count);
+  virtual void addLine(bool previousWrapped=false);
+};
+
+//////////////////////////////////////////////////////////////////////
+// BlockArray-based history
+//////////////////////////////////////////////////////////////////////
+class HistoryScrollBlockArray : public HistoryScroll
+{
+public:
+  HistoryScrollBlockArray(size_t size);
+  virtual ~HistoryScrollBlockArray();
+
+  virtual int  getLines();
+  virtual int  getLineLen(int lineno);
+  virtual void getCells(int lineno, int colno, int count, Character res[]);
+  virtual bool isWrappedLine(int lineno);
+
+  virtual void addCells(const Character a[], int count);
+  virtual void addLine(bool previousWrapped=false);
+
+protected:
+  BlockArray m_blockArray;
+  QHash<int,size_t> m_lineLengths;
+};
+
+//////////////////////////////////////////////////////////////////////
+// History type
+//////////////////////////////////////////////////////////////////////
+
+class HistoryType
+{
+public:
+  HistoryType();
+  virtual ~HistoryType();
+
+  /**
+   * Returns true if the history is enabled ( can store lines of output )
+   * or false otherwise. 
+   */
+  virtual bool isEnabled()           const = 0;
+  /**
+   * Returns true if the history size is unlimited.
+   */
+  bool isUnlimited() const { return maximumLineCount() == 0; }
+  /**
+   * Returns the maximum number of lines which this history type
+   * can store or 0 if the history can store an unlimited number of lines.
+   */
+  virtual int maximumLineCount()    const = 0;
+
+  virtual HistoryScroll* scroll(HistoryScroll *) const = 0;
+};
+
+class HistoryTypeNone : public HistoryType
+{
+public:
+  HistoryTypeNone();
+
+  virtual bool isEnabled() const;
+  virtual int maximumLineCount() const;
+
+  virtual HistoryScroll* scroll(HistoryScroll *) const;
+};
+
+class HistoryTypeBlockArray : public HistoryType
+{
+public:
+  HistoryTypeBlockArray(size_t size);
+  
+  virtual bool isEnabled() const;
+  virtual int maximumLineCount() const;
+
+  virtual HistoryScroll* scroll(HistoryScroll *) const;
+
+protected:
+  size_t m_size;
+};
+
+
+class HistoryTypeFile : public HistoryType
+{
+public:
+  HistoryTypeFile(const QString& fileName=QString());
+
+  virtual bool isEnabled() const;
+  virtual const QString& getFileName() const;
+  virtual int maximumLineCount() const;
+
+  virtual HistoryScroll* scroll(HistoryScroll *) const;
+
+protected:
+  QString m_fileName;
+};
+
+
+class HistoryTypeBuffer : public HistoryType
+{
+public:
+  HistoryTypeBuffer(unsigned int nbLines);
+  
+  virtual bool isEnabled() const;
+  virtual int maximumLineCount() const;
+
+  virtual HistoryScroll* scroll(HistoryScroll *) const;
+
+protected:
+  unsigned int m_nbLines;
+};
+
+#endif // HISTORY_H
diff --git a/libgui/qterminal/libqterminal/unix/KeyboardTranslator.cpp b/libgui/qterminal/libqterminal/unix/KeyboardTranslator.cpp
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/KeyboardTranslator.cpp
@@ -0,0 +1,888 @@
+/*
+    This source file was part of Konsole, a terminal emulator.
+
+    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+// Own
+#include "unix/KeyboardTranslator.h"
+
+// System
+#include <ctype.h>
+#include <stdio.h>
+
+// Qt
+#include <QtCore/QBuffer>
+#include <QtCore/QFile>
+#include <QtCore/QFileInfo>
+#include <QtCore>
+#include <QtGui>
+
+//and this is default now translator - default.keytab from original Konsole
+const char* KeyboardTranslatorManager::defaultTranslatorText = 
+#include "ExtendedDefaultTranslator.h"
+;
+
+KeyboardTranslatorManager::KeyboardTranslatorManager()
+    : _haveLoadedAll(false)
+{
+}
+KeyboardTranslatorManager::~KeyboardTranslatorManager()
+{
+    qDeleteAll(_translators.values());
+}
+QString KeyboardTranslatorManager::findTranslatorPath(const QString& name)
+{
+    return QString("kb-layouts/" + name + ".keytab");
+}
+void KeyboardTranslatorManager::findTranslators()
+{
+    QDir dir("kb-layouts/");
+    QStringList filters;
+    filters << "*.keytab";
+    dir.setNameFilters(filters);
+    QStringList list = dir.entryList(filters); //(".keytab"); // = KGlobal::dirs()->findAllResources("data",
+    //                                 "konsole/*.keytab",
+    //                                 KStandardDirs::NoDuplicates);
+    list = dir.entryList(filters);
+    // add the name of each translator to the list and associated
+    // the name with a null pointer to indicate that the translator
+    // has not yet been loaded from disk
+    QStringListIterator listIter(list);
+    while (listIter.hasNext())
+    {
+        QString translatorPath = listIter.next();
+
+        QString name = QFileInfo(translatorPath).baseName();
+
+        if ( !_translators.contains(name) ) {
+            _translators.insert(name,0);
+	}
+    }
+    _haveLoadedAll = true;
+}
+
+const KeyboardTranslator* KeyboardTranslatorManager::findTranslator(const QString& name)
+{
+    if ( name.isEmpty() )
+        return defaultTranslator();
+
+    //here was smth wrong in original Konsole source
+    findTranslators();
+
+    if ( _translators.contains(name) && _translators[name] != 0 ) {
+        return _translators[name];
+    }
+
+    KeyboardTranslator* translator = loadTranslator(name);
+
+    if ( translator != 0 )
+        _translators[name] = translator;
+    else if ( !name.isEmpty() )
+        qWarning() << "Unable to load translator" << name;
+
+    return translator;
+}
+
+bool KeyboardTranslatorManager::saveTranslator(const KeyboardTranslator* translator)
+{
+    const QString path = ".keytab";// = KGlobal::dirs()->saveLocation("data","konsole/")+translator->name()
+    //           +".keytab";
+
+    qDebug() << "Saving translator to" << path;
+
+    QFile destination(path);
+    
+    if (!destination.open(QIODevice::WriteOnly | QIODevice::Text))
+    {
+        qWarning() << "Unable to save keyboard translation:" 
+                   << destination.errorString();
+
+        return false;
+    }
+
+    {
+        KeyboardTranslatorWriter writer(&destination);
+        writer.writeHeader(translator->description());
+
+        QListIterator<KeyboardTranslator::Entry> iter(translator->entries());
+        while ( iter.hasNext() )
+            writer.writeEntry(iter.next());
+    }
+
+    destination.close();
+
+    return true;
+}
+
+KeyboardTranslator* KeyboardTranslatorManager::loadTranslator(const QString& name)
+{
+    const QString& path = findTranslatorPath(name);
+
+    QFile source(path); 
+    
+    if (name.isEmpty() || !source.open(QIODevice::ReadOnly | QIODevice::Text))
+        return 0;
+
+    return loadTranslator(&source,name);
+}
+
+const KeyboardTranslator* KeyboardTranslatorManager::defaultTranslator()
+{
+    QBuffer textBuffer;
+    textBuffer.setData(defaultTranslatorText,strlen(defaultTranslatorText));
+
+    if (!textBuffer.open(QIODevice::ReadOnly))
+        return 0;
+
+    return loadTranslator(&textBuffer,"fallback");
+}
+
+KeyboardTranslator* KeyboardTranslatorManager::loadTranslator(QIODevice* source,const QString& name)
+{
+    KeyboardTranslator* translator = new KeyboardTranslator(name);
+    KeyboardTranslatorReader reader(source);
+    translator->setDescription( reader.description() );
+    
+    while ( reader.hasNextEntry() ) {
+        translator->addEntry(reader.nextEntry());
+    }	
+
+    source->close();
+
+    if ( !reader.parseError() )
+    {
+        return translator;
+    }
+    else
+    {
+        delete translator;
+        return 0;
+    }
+}
+
+KeyboardTranslatorWriter::KeyboardTranslatorWriter(QIODevice* destination)
+    : _destination(destination)
+{
+    Q_ASSERT( destination && destination->isWritable() );
+
+    _writer = new QTextStream(_destination);
+}
+KeyboardTranslatorWriter::~KeyboardTranslatorWriter()
+{
+    delete _writer;
+}
+void KeyboardTranslatorWriter::writeHeader( const QString& description )
+{
+    *_writer << "keyboard \"" << description << '\"' << '\n';
+}
+void KeyboardTranslatorWriter::writeEntry( const KeyboardTranslator::Entry& entry )
+{
+    QString result;
+
+    if ( entry.command() != KeyboardTranslator::NoCommand )
+        result = entry.resultToString();
+    else
+        result = '\"' + entry.resultToString() + '\"';
+
+    *_writer << "key " << entry.conditionToString() << " : " << result << '\n';
+}
+
+
+// each line of the keyboard translation file is one of:
+//
+// - keyboard "name"
+// - key KeySequence : "characters"
+// - key KeySequence : CommandName
+//
+// KeySequence begins with the name of the key ( taken from the Qt::Key enum )
+// and is followed by the keyboard modifiers and state flags ( with + or - in front
+// of each modifier or flag to indicate whether it is required ).  All keyboard modifiers
+// and flags are optional, if a particular modifier or state is not specified it is 
+// assumed not to be a part of the sequence.  The key sequence may contain whitespace
+//
+// eg:  "key Up+Shift : scrollLineUp"
+//      "key Next-Shift : "\E[6~"
+//
+// (lines containing only whitespace are ignored, parseLine assumes that comments have
+// already been removed)
+//
+
+KeyboardTranslatorReader::KeyboardTranslatorReader( QIODevice* source )
+    : _source(source)
+    , _hasNext(false)
+{
+    // read input until we find the description
+    while ( _description.isEmpty() && !source->atEnd() )
+    {
+        const QList<Token>& tokens = tokenize( QString(source->readLine()) );
+
+        if ( !tokens.isEmpty() && tokens.first().type == Token::TitleKeyword )
+        {
+            _description = (tokens[1].text.toUtf8());
+        }
+    }
+
+    readNext();
+}
+void KeyboardTranslatorReader::readNext() 
+{
+    // find next entry
+    while ( !_source->atEnd() )
+    {
+        const QList<Token>& tokens = tokenize( QString(_source->readLine()) );
+        if ( !tokens.isEmpty() && tokens.first().type == Token::KeyKeyword )
+        {
+            KeyboardTranslator::States flags = KeyboardTranslator::NoState;
+            KeyboardTranslator::States flagMask = KeyboardTranslator::NoState;
+            Qt::KeyboardModifiers modifiers = Qt::NoModifier;
+            Qt::KeyboardModifiers modifierMask = Qt::NoModifier;
+
+            int keyCode = Qt::Key_unknown;
+
+            decodeSequence(tokens[1].text.toLower(),
+                           keyCode,
+                           modifiers,
+                           modifierMask,
+                           flags,
+                           flagMask); 
+
+            KeyboardTranslator::Command command = KeyboardTranslator::NoCommand;
+            QByteArray text;
+
+            // get text or command
+            if ( tokens[2].type == Token::OutputText )
+            {
+                text = tokens[2].text.toLocal8Bit();
+            }
+            else if ( tokens[2].type == Token::Command )
+            {
+                // identify command
+                if (!parseAsCommand(tokens[2].text,command))
+                    qWarning() << "Command" << tokens[2].text << "not understood.";
+            }
+
+            KeyboardTranslator::Entry newEntry;
+            newEntry.setKeyCode( keyCode );
+            newEntry.setState( flags );
+            newEntry.setStateMask( flagMask );
+            newEntry.setModifiers( modifiers );
+            newEntry.setModifierMask( modifierMask );
+            newEntry.setText( text );
+            newEntry.setCommand( command );
+
+            _nextEntry = newEntry;
+
+            _hasNext = true;
+
+            return;
+        }
+    } 
+
+    _hasNext = false;
+}
+
+bool KeyboardTranslatorReader::parseAsCommand(const QString& text,KeyboardTranslator::Command& command) 
+{
+    if ( text.compare("erase",Qt::CaseInsensitive) == 0 )
+        command = KeyboardTranslator::EraseCommand;
+    else if ( text.compare("scrollpageup",Qt::CaseInsensitive) == 0 )
+        command = KeyboardTranslator::ScrollPageUpCommand;
+    else if ( text.compare("scrollpagedown",Qt::CaseInsensitive) == 0 )
+        command = KeyboardTranslator::ScrollPageDownCommand;
+    else if ( text.compare("scrolllineup",Qt::CaseInsensitive) == 0 )
+        command = KeyboardTranslator::ScrollLineUpCommand;
+    else if ( text.compare("scrolllinedown",Qt::CaseInsensitive) == 0 )
+        command = KeyboardTranslator::ScrollLineDownCommand;
+    else if ( text.compare("scrolllock",Qt::CaseInsensitive) == 0 )
+        command = KeyboardTranslator::ScrollLockCommand;
+    else
+    	return false;
+
+    return true;
+}
+
+bool KeyboardTranslatorReader::decodeSequence(const QString& text,
+                                              int& keyCode,
+                                              Qt::KeyboardModifiers& modifiers,
+                                              Qt::KeyboardModifiers& modifierMask,
+                                              KeyboardTranslator::States& flags,
+                                              KeyboardTranslator::States& flagMask)
+{
+    bool isWanted = true; 
+    bool endOfItem = false;
+    QString buffer;
+
+    Qt::KeyboardModifiers tempModifiers = modifiers;
+    Qt::KeyboardModifiers tempModifierMask = modifierMask;
+    KeyboardTranslator::States tempFlags = flags;
+    KeyboardTranslator::States tempFlagMask = flagMask;
+
+    for ( int i = 0 ; i < text.count() ; i++ )
+    {
+        const QChar& ch = text[i];
+        bool isLastLetter = ( i == text.count()-1 );
+
+        endOfItem = true;
+        if ( ch.isLetterOrNumber() )
+        {
+            endOfItem = false;
+            buffer.append(ch);
+        }
+
+        if ( (endOfItem || isLastLetter) && !buffer.isEmpty() )
+        {
+            Qt::KeyboardModifier itemModifier = Qt::NoModifier;
+            int itemKeyCode = 0;
+            KeyboardTranslator::State itemFlag = KeyboardTranslator::NoState;
+
+            if ( parseAsModifier(buffer,itemModifier) )
+            {
+                tempModifierMask |= itemModifier;
+
+                if ( isWanted )
+                    tempModifiers |= itemModifier;
+            }
+            else if ( parseAsStateFlag(buffer,itemFlag) )
+            {
+                tempFlagMask |= itemFlag;
+
+                if ( isWanted )
+                    tempFlags |= itemFlag;
+            }
+            else if ( parseAsKeyCode(buffer,itemKeyCode) )
+                keyCode = itemKeyCode;
+            else
+                qDebug() << "Unable to parse key binding item:" << buffer;
+
+            buffer.clear();
+        }
+
+        // check if this is a wanted / not-wanted flag and update the 
+        // state ready for the next item
+        if ( ch == '+' )
+            isWanted = true;
+        else if ( ch == '-' )
+            isWanted = false;
+    } 
+
+    modifiers = tempModifiers;
+    modifierMask = tempModifierMask;
+    flags = tempFlags;
+    flagMask = tempFlagMask;
+
+    return true;
+}
+
+bool KeyboardTranslatorReader::parseAsModifier(const QString& item , Qt::KeyboardModifier& modifier)
+{
+    if ( item == "shift" )
+        modifier = Qt::ShiftModifier;
+    else if ( item == "ctrl" || item == "control" )
+        modifier = Qt::ControlModifier;
+    else if ( item == "alt" )
+        modifier = Qt::AltModifier;
+    else if ( item == "meta" )
+        modifier = Qt::MetaModifier;
+    else if ( item == "keypad" )
+        modifier = Qt::KeypadModifier;
+    else
+        return false;
+
+    return true;
+}
+bool KeyboardTranslatorReader::parseAsStateFlag(const QString& item , KeyboardTranslator::State& flag)
+{
+    if ( item == "appcukeys" )
+        flag = KeyboardTranslator::CursorKeysState;
+    else if ( item == "ansi" )
+        flag = KeyboardTranslator::AnsiState;
+    else if ( item == "newline" )
+        flag = KeyboardTranslator::NewLineState;
+    else if ( item == "appscreen" )
+        flag = KeyboardTranslator::AlternateScreenState;
+    else if ( item == "anymod" )
+        flag = KeyboardTranslator::AnyModifierState;
+    else
+        return false;
+
+    return true;
+}
+bool KeyboardTranslatorReader::parseAsKeyCode(const QString& item , int& keyCode)
+{
+    QKeySequence sequence = QKeySequence::fromString(item);
+    if ( !sequence.isEmpty() )
+    {
+        keyCode = sequence[0];
+
+        if ( sequence.count() > 1 )
+        {
+            qDebug() << "Unhandled key codes in sequence: " << item;
+        }
+    }
+    // additional cases implemented for backwards compatibility with KDE 3
+    else if ( item == "prior" )
+        keyCode = Qt::Key_PageUp;
+    else if ( item == "next" )
+        keyCode = Qt::Key_PageDown;
+    else
+        return false;
+
+    return true;
+}
+
+QString KeyboardTranslatorReader::description() const
+{
+    return _description;
+}
+bool KeyboardTranslatorReader::hasNextEntry()
+{
+    return _hasNext;
+}
+KeyboardTranslator::Entry KeyboardTranslatorReader::createEntry( const QString& condition , 
+                                                                 const QString& result )
+{
+    QString entryString("keyboard \"temporary\"\nkey ");
+    entryString.append(condition);
+    entryString.append(" : ");
+
+    // if 'result' is the name of a command then the entry result will be that command,
+    // otherwise the result will be treated as a string to echo when the key sequence
+    // specified by 'condition' is pressed
+    KeyboardTranslator::Command command;
+    if (parseAsCommand(result,command))
+    	entryString.append(result);
+    else
+        entryString.append('\"' + result + '\"');
+
+    QByteArray array = entryString.toUtf8();
+
+    KeyboardTranslator::Entry entry;
+
+    QBuffer buffer(&array);
+    buffer.open(QIODevice::ReadOnly);
+    KeyboardTranslatorReader reader(&buffer);
+
+    if ( reader.hasNextEntry() )
+        entry = reader.nextEntry();
+
+    return entry;
+}
+
+KeyboardTranslator::Entry KeyboardTranslatorReader::nextEntry() 
+{
+    Q_ASSERT( _hasNext );
+
+
+    KeyboardTranslator::Entry entry = _nextEntry;
+
+    readNext();
+
+    return entry;
+}
+bool KeyboardTranslatorReader::parseError()
+{
+    return false;
+}
+QList<KeyboardTranslatorReader::Token> KeyboardTranslatorReader::tokenize(const QString& line)
+{
+    QString text = line.simplified();
+
+    // comment line: # comment
+    static QRegExp comment("\\#.*");
+    // title line: keyboard "title"
+    static QRegExp title("keyboard\\s+\"(.*)\"");
+    // key line: key KeySequence : "output"
+    // key line: key KeySequence : command
+    static QRegExp key("key\\s+([\\w\\+\\s\\-]+)\\s*:\\s*(\"(.*)\"|\\w+)");
+
+    QList<Token> list;
+
+    if ( text.isEmpty() || comment.exactMatch(text) )
+    {
+        return list;
+    }
+
+    if ( title.exactMatch(text) )
+    {
+        Token titleToken = { Token::TitleKeyword , QString() };
+        Token textToken = { Token::TitleText , title.capturedTexts()[1] };
+
+        list << titleToken << textToken;
+    }
+    else if  ( key.exactMatch(text) )
+    {
+        Token keyToken = { Token::KeyKeyword , QString() };
+        Token sequenceToken = { Token::KeySequence , key.capturedTexts()[1].remove(' ') };
+
+        list << keyToken << sequenceToken;
+
+        if ( key.capturedTexts()[3].isEmpty() )
+        {
+            // capturedTexts()[2] is a command
+            Token commandToken = { Token::Command , key.capturedTexts()[2] };
+            list << commandToken;    
+        }   
+        else
+        {
+            // capturedTexts()[3] is the output string
+            Token outputToken = { Token::OutputText , key.capturedTexts()[3] };
+            list << outputToken;
+        }     
+    }
+    else
+    {
+        qWarning() << "Line in keyboard translator file could not be understood:" << text;
+    }
+
+    return list;
+}
+
+QList<QString> KeyboardTranslatorManager::allTranslators() 
+{
+    if ( !_haveLoadedAll )
+    {
+        findTranslators();
+    }
+
+    return _translators.keys();
+}
+
+KeyboardTranslator::Entry::Entry()
+    : _keyCode(0)
+    , _modifiers(Qt::NoModifier)
+    , _modifierMask(Qt::NoModifier)
+    , _state(NoState)
+    , _stateMask(NoState)
+    , _command(NoCommand)
+{
+}
+
+bool KeyboardTranslator::Entry::operator==(const Entry& rhs) const
+{
+    return _keyCode == rhs._keyCode &&
+            _modifiers == rhs._modifiers &&
+            _modifierMask == rhs._modifierMask &&
+            _state == rhs._state &&
+            _stateMask == rhs._stateMask &&
+            _command == rhs._command &&
+            _text == rhs._text;
+}
+
+bool KeyboardTranslator::Entry::matches(int keyCode , 
+                                        Qt::KeyboardModifiers modifiers,
+                                        States state) const
+{
+    if ( _keyCode != keyCode )
+        return false;
+
+    if ( (modifiers & _modifierMask) != (_modifiers & _modifierMask) ) 
+        return false;
+
+    // if modifiers is non-zero, the 'any modifier' state is implicit
+    if ( modifiers != 0 )
+        state |= AnyModifierState;
+
+    if ( (state & _stateMask) != (_state & _stateMask) )
+        return false;
+
+    // special handling for the 'Any Modifier' state, which checks for the presence of 
+    // any or no modifiers.  In this context, the 'keypad' modifier does not count.
+    bool anyModifiersSet = modifiers != 0 && modifiers != Qt::KeypadModifier;
+    if ( _stateMask & KeyboardTranslator::AnyModifierState )
+    {
+        // test fails if any modifier is required but none are set
+        if ( (_state & KeyboardTranslator::AnyModifierState) && !anyModifiersSet )
+            return false;
+
+        // test fails if no modifier is allowed but one or more are set
+        if ( !(_state & KeyboardTranslator::AnyModifierState) && anyModifiersSet )
+            return false;
+    }
+
+    return true;
+}
+QByteArray KeyboardTranslator::Entry::escapedText(bool expandWildCards,Qt::KeyboardModifiers modifiers) const
+{
+    QByteArray result(text(expandWildCards,modifiers));
+
+    for ( int i = 0 ; i < result.count() ; i++ )
+    {
+        char ch = result[i];
+        char replacement = 0;
+
+        switch ( ch )
+        {
+        case 27 : replacement = 'E'; break;
+        case 8  : replacement = 'b'; break;
+        case 12 : replacement = 'f'; break;
+        case 9  : replacement = 't'; break;
+        case 13 : replacement = 'r'; break;
+        case 10 : replacement = 'n'; break;
+        default:
+            // any character which is not printable is replaced by an equivalent
+            // \xhh escape sequence (where 'hh' are the corresponding hex digits)
+            if ( !QChar(ch).isPrint() )
+                replacement = 'x';
+        }
+
+        if ( replacement == 'x' )
+        {
+            result.replace(i,1,"\\x"+QByteArray(1,ch).toInt(0, 16)); 
+        } else if ( replacement != 0 )
+        {
+            result.remove(i,1);
+            result.insert(i,'\\');
+            result.insert(i+1,replacement);
+        }
+    }
+
+    return result;
+}
+QByteArray KeyboardTranslator::Entry::unescape(const QByteArray& input) const
+{
+    QByteArray result(input);
+
+    for ( int i = 0 ; i < result.count()-1 ; i++ )
+    {
+
+        QByteRef ch = result[i];
+        if ( ch == '\\' )
+        {
+            char replacement[2] = {0,0};
+            int charsToRemove = 2;
+            bool escapedChar = true;
+
+            switch ( result[i+1] )
+            {
+            case 'E' : replacement[0] = 27; break;
+            case 'b' : replacement[0] = 8 ; break;
+            case 'f' : replacement[0] = 12; break;
+            case 't' : replacement[0] = 9 ; break;
+            case 'r' : replacement[0] = 13; break;
+            case 'n' : replacement[0] = 10; break;
+            case 'x' :
+            {
+                // format is \xh or \xhh where 'h' is a hexadecimal
+                // digit from 0-9 or A-F which should be replaced
+                // with the corresponding character value
+                char hexDigits[3] = {0};
+
+                if ( (i < result.count()-2) && isxdigit(result[i+2]) )
+                    hexDigits[0] = result[i+2];
+                if ( (i < result.count()-3) && isxdigit(result[i+3]) )
+                    hexDigits[1] = result[i+3];
+
+                int charValue = 0;
+                sscanf(hexDigits,"%x",&charValue);
+
+                replacement[0] = (char)charValue;
+
+                charsToRemove = 2 + strlen(hexDigits);
+            }
+            break;
+            default:
+                escapedChar = false;
+            }
+
+            if ( escapedChar )
+                result.replace(i,charsToRemove,replacement);
+        }
+    }
+    
+    return result;
+}
+
+void KeyboardTranslator::Entry::insertModifier( QString& item , int modifier ) const
+{
+    if ( !(modifier & _modifierMask) )
+        return;
+
+    if ( modifier & _modifiers )
+        item += '+';
+    else
+        item += '-';
+
+    if ( modifier == Qt::ShiftModifier )
+        item += "Shift";
+    else if ( modifier == Qt::ControlModifier )
+        item += "Ctrl";
+    else if ( modifier == Qt::AltModifier )
+        item += "Alt";
+    else if ( modifier == Qt::MetaModifier )
+        item += "Meta";
+    else if ( modifier == Qt::KeypadModifier )
+        item += "KeyPad";
+}
+void KeyboardTranslator::Entry::insertState( QString& item , int state ) const
+{
+    if ( !(state & _stateMask) )
+        return;
+
+    if ( state & _state )
+        item += '+' ;
+    else
+        item += '-' ;
+
+    if ( state == KeyboardTranslator::AlternateScreenState )
+        item += "AppScreen";
+    else if ( state == KeyboardTranslator::NewLineState )
+        item += "NewLine";
+    else if ( state == KeyboardTranslator::AnsiState )
+        item += "Ansi";
+    else if ( state == KeyboardTranslator::CursorKeysState )
+        item += "AppCuKeys";
+    else if ( state == KeyboardTranslator::AnyModifierState )
+        item += "AnyMod";
+}
+QString KeyboardTranslator::Entry::resultToString(bool expandWildCards,Qt::KeyboardModifiers modifiers) const
+{
+    if ( !_text.isEmpty() )
+        return escapedText(expandWildCards,modifiers);
+    else if ( _command == EraseCommand )
+        return "Erase";
+    else if ( _command == ScrollPageUpCommand )
+        return "ScrollPageUp";
+    else if ( _command == ScrollPageDownCommand )
+        return "ScrollPageDown";
+    else if ( _command == ScrollLineUpCommand )
+        return "ScrollLineUp";
+    else if ( _command == ScrollLineDownCommand )
+        return "ScrollLineDown";
+    else if ( _command == ScrollLockCommand )
+        return "ScrollLock";
+
+    return QString();
+}
+QString KeyboardTranslator::Entry::conditionToString() const
+{
+    QString result = QKeySequence(_keyCode).toString();
+
+    // add modifiers
+    insertModifier( result , Qt::ShiftModifier );
+    insertModifier( result , Qt::ControlModifier );
+    insertModifier( result , Qt::AltModifier );
+    insertModifier( result , Qt::MetaModifier ); 
+
+    // add states
+    insertState( result , KeyboardTranslator::AlternateScreenState );
+    insertState( result , KeyboardTranslator::NewLineState );
+    insertState( result , KeyboardTranslator::AnsiState );
+    insertState( result , KeyboardTranslator::CursorKeysState );
+    insertState( result , KeyboardTranslator::AnyModifierState );
+
+    return result;
+}
+
+KeyboardTranslator::KeyboardTranslator(const QString& name)
+    : _name(name)
+{
+}
+
+void KeyboardTranslator::setDescription(const QString& description) 
+{
+    _description = description;
+}
+QString KeyboardTranslator::description() const
+{
+    return _description;
+}
+void KeyboardTranslator::setName(const QString& name)
+{
+    _name = name;
+}
+QString KeyboardTranslator::name() const
+{
+    return _name;
+}
+
+QList<KeyboardTranslator::Entry> KeyboardTranslator::entries() const
+{
+    return _entries.values();
+}
+
+void KeyboardTranslator::addEntry(const Entry& entry)
+{
+    const int keyCode = entry.keyCode();
+    _entries.insertMulti(keyCode,entry);
+}
+void KeyboardTranslator::replaceEntry(const Entry& existing , const Entry& replacement)
+{
+    if ( !existing.isNull() )
+        _entries.remove(existing.keyCode());
+    _entries.insertMulti(replacement.keyCode(),replacement);
+}
+void KeyboardTranslator::removeEntry(const Entry& entry)
+{
+    _entries.remove(entry.keyCode());
+}
+KeyboardTranslator::Entry KeyboardTranslator::findEntry(int keyCode, Qt::KeyboardModifiers modifiers, States state) const
+{
+    if ( _entries.contains(keyCode) )
+    {
+        QList<Entry> entriesForKey = _entries.values(keyCode);
+        
+        QListIterator<Entry> iter(entriesForKey);
+
+        while (iter.hasNext())
+        {
+            const Entry& next = iter.next();
+            if ( next.matches(keyCode,modifiers,state) )
+                return next;
+        }
+
+        return Entry(); // entry not found
+    }
+    else
+    {
+        return Entry();
+    }
+    
+}
+void KeyboardTranslatorManager::addTranslator(KeyboardTranslator* translator)
+{
+    _translators.insert(translator->name(),translator);
+
+    if ( !saveTranslator(translator) )
+        qWarning() << "Unable to save translator" << translator->name()
+                   << "to disk.";
+}
+bool KeyboardTranslatorManager::deleteTranslator(const QString& name)
+{
+    Q_ASSERT( _translators.contains(name) );
+
+    // locate and delete
+    QString path = findTranslatorPath(name);
+    if ( QFile::remove(path) )
+    {
+        _translators.remove(name);
+        return true; 
+    }
+    else
+    {
+        qWarning() << "Failed to remove translator - " << path;
+        return false;
+    }
+}
+K_GLOBAL_STATIC( KeyboardTranslatorManager , theKeyboardTranslatorManager )
+KeyboardTranslatorManager* KeyboardTranslatorManager::instance()
+{
+    return theKeyboardTranslatorManager;
+}
diff --git a/libgui/qterminal/libqterminal/unix/KeyboardTranslator.h b/libgui/qterminal/libqterminal/unix/KeyboardTranslator.h
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/KeyboardTranslator.h
@@ -0,0 +1,650 @@
+/*
+    This source file is part of Konsole, a terminal emulator.
+
+    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef KEYBOARDTRANSLATOR_H
+#define KEYBOARDTRANSLATOR_H
+
+// Qt
+#include <QtCore/QHash>
+#include <QtCore/QList>
+#include <QtGui/QKeySequence>
+#include <QtCore/QMetaType>
+#include <QtCore/QVarLengthArray>
+#include <QtCore>
+
+typedef void (*CleanUpFunction)();
+
+/**
+ * @internal
+ *
+ * Helper class for K_GLOBAL_STATIC to clean up the object on library unload or application
+ * shutdown.
+ */
+class CleanUpGlobalStatic
+{
+    public:
+        CleanUpFunction func;
+
+        inline ~CleanUpGlobalStatic() { func(); }
+};
+
+
+//these directives are taken from the heart of kdecore
+
+# define K_GLOBAL_STATIC_STRUCT_NAME(NAME)
+
+#if QT_VERSION < 0x040400
+# define Q_BASIC_ATOMIC_INITIALIZER     Q_ATOMIC_INIT
+# define testAndSetOrdered              testAndSet
+#endif
+
+#define K_GLOBAL_STATIC(TYPE, NAME) K_GLOBAL_STATIC_WITH_ARGS(TYPE, NAME, ())
+
+#define K_GLOBAL_STATIC_WITH_ARGS(TYPE, NAME, ARGS)                            \
+static QBasicAtomicPointer<TYPE > _k_static_##NAME = Q_BASIC_ATOMIC_INITIALIZER(0); \
+static bool _k_static_##NAME##_destroyed;                                      \
+static struct K_GLOBAL_STATIC_STRUCT_NAME(NAME)                                \
+{                                                                              \
+    bool isDestroyed()                                                         \
+    {                                                                          \
+        return _k_static_##NAME##_destroyed;                                   \
+    }                                                                          \
+    inline operator TYPE*()                                                    \
+    {                                                                          \
+        return operator->();                                                   \
+    }                                                                          \
+    inline TYPE *operator->()                                                  \
+    {                                                                          \
+        if (!_k_static_##NAME) {                                               \
+            if (isDestroyed()) {                                               \
+            qFatal("Fatal Error: Accessed global static '%s *%s()' after destruction. " \
+             "Defined at %s:%d", #TYPE, #NAME, __FILE__, __LINE__);		\
+	     }                                                                  \
+	     TYPE *x = new TYPE ARGS;                                           \
+	     if (!_k_static_##NAME.testAndSetOrdered(0, x)                      \
+	         && _k_static_##NAME != x ) {                                   \
+	         delete x;                                                      \
+	     } else { 								\
+		static CleanUpGlobalStatic cleanUpObject = { destroy };	\
+	     }   								\
+	 }                                                                      \
+         return _k_static_##NAME;                                               \
+    }            								\
+    inline TYPE &operator*()                                                   \
+    {                                                                          \
+        return *operator->();                                                  \
+    }                                                                          \
+    static void destroy()                                                      \
+    {                                                                          \
+        _k_static_##NAME##_destroyed = true;                                   \
+        TYPE *x = _k_static_##NAME;                                            \
+        _k_static_##NAME = 0;                                                  \
+        delete x;                                                              \
+    }                                                                          \
+} NAME;
+								
+								
+
+
+
+class QIODevice;
+class QTextStream;
+
+/** 
+ * A convertor which maps between key sequences pressed by the user and the
+ * character strings which should be sent to the terminal and commands
+ * which should be invoked when those character sequences are pressed.
+ *
+ * Konsole supports multiple keyboard translators, allowing the user to
+ * specify the character sequences which are sent to the terminal
+ * when particular key sequences are pressed.
+ *
+ * A key sequence is defined as a key code, associated keyboard modifiers
+ * (Shift,Ctrl,Alt,Meta etc.) and state flags which indicate the state
+ * which the terminal must be in for the key sequence to apply.
+ */
+class KeyboardTranslator
+{
+public:
+    /** 
+     * The meaning of a particular key sequence may depend upon the state which
+     * the terminal emulation is in.  Therefore findEntry() may return a different
+     * Entry depending upon the state flags supplied.
+     *
+     * This enum describes the states which may be associated with with a particular
+     * entry in the keyboard translation entry.
+     */
+    enum State
+    {
+        /** Indicates that no special state is active */
+        NoState = 0,
+        /**
+         * TODO More documentation
+         */
+        NewLineState = 1,
+        /** 
+         * Indicates that the terminal is in 'Ansi' mode.
+         * TODO: More documentation
+         */
+        AnsiState = 2,
+        /**
+         * TODO More documentation
+         */
+        CursorKeysState = 4,
+        /**
+         * Indicates that the alternate screen ( typically used by interactive programs
+         * such as screen or vim ) is active 
+         */
+        AlternateScreenState = 8,
+        /** Indicates that any of the modifier keys is active. */ 
+        AnyModifierState = 16
+    };
+    Q_DECLARE_FLAGS(States,State)
+
+    /**
+     * This enum describes commands which are associated with particular key sequences.
+     */
+    enum Command
+    {
+        /** Indicates that no command is associated with this command sequence */
+        NoCommand = 0,
+        /** TODO Document me */
+        SendCommand = 1,
+        /** Scroll the terminal display up one page */
+        ScrollPageUpCommand = 2,
+        /** Scroll the terminal display down one page */
+        ScrollPageDownCommand = 4,
+        /** Scroll the terminal display up one line */
+        ScrollLineUpCommand = 8,
+        /** Scroll the terminal display down one line */
+        ScrollLineDownCommand = 16,
+        /** Toggles scroll lock mode */
+        ScrollLockCommand = 32,
+		/** Echos the operating system specific erase character. */
+		EraseCommand = 64
+    };
+    Q_DECLARE_FLAGS(Commands,Command)
+
+    /**
+     * Represents an association between a key sequence pressed by the user
+     * and the character sequence and commands associated with it for a particular
+     * KeyboardTranslator.
+     */
+    class Entry
+    {
+    public:
+        /** 
+         * Constructs a new entry for a keyboard translator.
+         */
+        Entry();
+
+        /** 
+         * Returns true if this entry is null.
+         * This is true for newly constructed entries which have no properties set. 
+         */
+        bool isNull() const;
+
+        /** Returns the commands associated with this entry */
+        Command command() const;
+        /** Sets the command associated with this entry. */
+        void setCommand(Command command);
+
+        /** 
+         * Returns the character sequence associated with this entry, optionally replacing 
+         * wildcard '*' characters with numbers to indicate the keyboard modifiers being pressed.
+         *
+         * TODO: The numbers used to replace '*' characters are taken from the Konsole/KDE 3 code.
+         * Document them. 
+         *
+         * @param expandWildCards Specifies whether wild cards (occurrences of the '*' character) in
+         * the entry should be replaced with a number to indicate the modifier keys being pressed. 
+         *
+         * @param modifiers The keyboard modifiers being pressed.
+         */
+        QByteArray text(bool expandWildCards = false,
+                        Qt::KeyboardModifiers modifiers = Qt::NoModifier) const;
+
+        /** Sets the character sequence associated with this entry */
+        void setText(const QByteArray& text);
+
+        /** 
+         * Returns the character sequence associated with this entry,
+         * with any non-printable characters replaced with escape sequences.
+         *
+         * eg. \\E for Escape, \\t for tab, \\n for new line.
+         *
+         * @param expandWildCards See text()
+         * @param modifiers See text()
+         */
+        QByteArray escapedText(bool expandWildCards = false,
+                               Qt::KeyboardModifiers modifiers = Qt::NoModifier) const;
+
+        /** Returns the character code ( from the Qt::Key enum ) associated with this entry */
+        int keyCode() const;
+        /** Sets the character code associated with this entry */
+        void setKeyCode(int keyCode);
+
+        /** 
+         * Returns a bitwise-OR of the enabled keyboard modifiers associated with this entry. 
+         * If a modifier is set in modifierMask() but not in modifiers(), this means that the entry
+         * only matches when that modifier is NOT pressed.
+         *
+         * If a modifier is not set in modifierMask() then the entry matches whether the modifier
+         * is pressed or not. 
+         */
+        Qt::KeyboardModifiers modifiers() const;
+
+        /** Returns the keyboard modifiers which are valid in this entry.  See modifiers() */
+        Qt::KeyboardModifiers modifierMask() const;
+
+        /** See modifiers() */
+        void setModifiers( Qt::KeyboardModifiers modifiers );
+        /** See modifierMask() and modifiers() */
+        void setModifierMask( Qt::KeyboardModifiers modifiers );
+
+        /** 
+         * Returns a bitwise-OR of the enabled state flags associated with this entry. 
+         * If flag is set in stateMask() but not in state(), this means that the entry only 
+         * matches when the terminal is NOT in that state.
+         *
+         * If a state is not set in stateMask() then the entry matches whether the terminal
+         * is in that state or not. 
+         */
+        States state() const;
+
+        /** Returns the state flags which are valid in this entry.  See state() */
+        States stateMask() const;
+
+        /** See state() */
+        void setState( States state );
+        /** See stateMask() */
+        void setStateMask( States mask );
+
+        /** 
+         * Returns the key code and modifiers associated with this entry 
+         * as a QKeySequence
+         */
+        //QKeySequence keySequence() const;
+
+        /** 
+         * Returns this entry's conditions ( ie. its key code, modifier and state criteria )
+         * as a string.
+         */
+        QString conditionToString() const;
+
+        /**
+         * Returns this entry's result ( ie. its command or character sequence )
+         * as a string.
+         *
+         * @param expandWildCards See text()
+         * @param modifiers See text()
+         */
+        QString resultToString(bool expandWildCards = false,
+                               Qt::KeyboardModifiers modifiers = Qt::NoModifier) const;
+
+        /** 
+         * Returns true if this entry matches the given key sequence, specified
+         * as a combination of @p keyCode , @p modifiers and @p state.
+         */
+        bool matches( int keyCode , 
+                      Qt::KeyboardModifiers modifiers , 
+                      States flags ) const;
+
+        bool operator==(const Entry& rhs) const;
+       
+    private:
+        void insertModifier( QString& item , int modifier ) const;
+        void insertState( QString& item , int state ) const;
+        QByteArray unescape(const QByteArray& text) const;
+
+        int _keyCode;
+        Qt::KeyboardModifiers _modifiers;
+        Qt::KeyboardModifiers _modifierMask;
+        States _state;
+        States _stateMask;
+
+        Command _command;
+        QByteArray _text;
+    };
+
+    /** Constructs a new keyboard translator with the given @p name */
+    KeyboardTranslator(const QString& name);
+   
+    //KeyboardTranslator(const KeyboardTranslator& other);
+
+    /** Returns the name of this keyboard translator */
+    QString name() const;
+
+    /** Sets the name of this keyboard translator */
+    void setName(const QString& name);
+
+    /** Returns the descriptive name of this keyboard translator */
+    QString description() const;
+
+    /** Sets the descriptive name of this keyboard translator */
+    void setDescription(const QString& description);
+
+    /**
+     * Looks for an entry in this keyboard translator which matches the given
+     * key code, keyboard modifiers and state flags.
+     * 
+     * Returns the matching entry if found or a null Entry otherwise ( ie.
+     * entry.isNull() will return true )
+     *
+     * @param keyCode A key code from the Qt::Key enum
+     * @param modifiers A combination of modifiers
+     * @param state Optional flags which specify the current state of the terminal
+     */
+    Entry findEntry(int keyCode , 
+                    Qt::KeyboardModifiers modifiers , 
+                    States state = NoState) const;
+
+    /** 
+     * Adds an entry to this keyboard translator's table.  Entries can be looked up according
+     * to their key sequence using findEntry()
+     */
+    void addEntry(const Entry& entry);
+
+    /**
+     * Replaces an entry in the translator.  If the @p existing entry is null,
+     * then this is equivalent to calling addEntry(@p replacement)
+     */
+    void replaceEntry(const Entry& existing , const Entry& replacement);
+
+    /**
+     * Removes an entry from the table.
+     */
+    void removeEntry(const Entry& entry);
+
+    /** Returns a list of all entries in the translator. */
+    QList<Entry> entries() const;
+
+private:
+
+    QHash<int,Entry> _entries; // entries in this keyboard translation,
+                                                 // entries are indexed according to
+                                                 // their keycode
+    QString _name;
+    QString _description;
+};
+Q_DECLARE_OPERATORS_FOR_FLAGS(KeyboardTranslator::States)
+Q_DECLARE_OPERATORS_FOR_FLAGS(KeyboardTranslator::Commands)
+
+/** 
+ * Parses the contents of a Keyboard Translator (.keytab) file and 
+ * returns the entries found in it.
+ *
+ * Usage example:
+ *
+ * @code
+ *  QFile source( "/path/to/keytab" );
+ *  source.open( QIODevice::ReadOnly );
+ *
+ *  KeyboardTranslator* translator = new KeyboardTranslator( "name-of-translator" );
+ *
+ *  KeyboardTranslatorReader reader(source);
+ *  while ( reader.hasNextEntry() )
+ *      translator->addEntry(reader.nextEntry());
+ *
+ *  source.close();
+ *
+ *  if ( !reader.parseError() )
+ *  {
+ *      // parsing succeeded, do something with the translator
+ *  } 
+ *  else
+ *  {
+ *      // parsing failed
+ *  }
+ * @endcode
+ */
+class KeyboardTranslatorReader
+{
+public:
+    /** Constructs a new reader which parses the given @p source */
+    KeyboardTranslatorReader( QIODevice* source );
+
+    /** 
+     * Returns the description text. 
+     * TODO: More documentation 
+     */
+    QString description() const;
+
+    /** Returns true if there is another entry in the source stream */
+    bool hasNextEntry();
+    /** Returns the next entry found in the source stream */
+    KeyboardTranslator::Entry nextEntry(); 
+
+    /** 
+     * Returns true if an error occurred whilst parsing the input or
+     * false if no error occurred.
+     */
+    bool parseError();
+
+    /**
+     * Parses a condition and result string for a translator entry
+     * and produces a keyboard translator entry.
+     *
+     * The condition and result strings are in the same format as in  
+     */
+    static KeyboardTranslator::Entry createEntry( const QString& condition ,
+                                                  const QString& result );
+private:
+    struct Token
+    {
+        enum Type
+        {
+            TitleKeyword,
+            TitleText,
+            KeyKeyword,
+            KeySequence,
+            Command,
+            OutputText
+        };
+        Type type;
+        QString text;
+    };
+    QList<Token> tokenize(const QString&);
+    void readNext();
+    bool decodeSequence(const QString& , 
+                                int& keyCode,
+                                Qt::KeyboardModifiers& modifiers,
+                                Qt::KeyboardModifiers& modifierMask,
+                                KeyboardTranslator::States& state,
+                                KeyboardTranslator::States& stateFlags);
+
+    static bool parseAsModifier(const QString& item , Qt::KeyboardModifier& modifier);
+    static bool parseAsStateFlag(const QString& item , KeyboardTranslator::State& state);
+    static bool parseAsKeyCode(const QString& item , int& keyCode);
+   	static bool parseAsCommand(const QString& text , KeyboardTranslator::Command& command);
+
+    QIODevice* _source;
+    QString _description;
+    KeyboardTranslator::Entry _nextEntry;
+    bool _hasNext;
+};
+
+/** Writes a keyboard translation to disk. */
+class KeyboardTranslatorWriter
+{
+public:
+    /** 
+     * Constructs a new writer which saves data into @p destination.
+     * The caller is responsible for closing the device when writing is complete.
+     */
+    KeyboardTranslatorWriter(QIODevice* destination);
+    ~KeyboardTranslatorWriter();
+
+    /** 
+     * Writes the header for the keyboard translator. 
+     * @param description Description of the keyboard translator. 
+     */
+    void writeHeader( const QString& description );
+    /** Writes a translator entry. */
+    void writeEntry( const KeyboardTranslator::Entry& entry ); 
+
+private:
+    QIODevice* _destination;  
+    QTextStream* _writer;
+};
+
+/**
+ * Manages the keyboard translations available for use by terminal sessions,
+ * see KeyboardTranslator.
+ */
+class KeyboardTranslatorManager
+{
+public:
+    /** 
+     * Constructs a new KeyboardTranslatorManager and loads the list of
+     * available keyboard translations.
+     *
+     * The keyboard translations themselves are not loaded until they are
+     * first requested via a call to findTranslator()
+     */
+    KeyboardTranslatorManager();
+    ~KeyboardTranslatorManager();
+
+    /**
+     * Adds a new translator.  If a translator with the same name 
+     * already exists, it will be replaced by the new translator.
+     *
+     * TODO: More documentation.
+     */
+    void addTranslator(KeyboardTranslator* translator);
+
+    /**
+     * Deletes a translator.  Returns true on successful deletion or false otherwise.
+     *
+     * TODO: More documentation
+     */
+    bool deleteTranslator(const QString& name);
+
+    /** Returns the default translator for Konsole. */
+    const KeyboardTranslator* defaultTranslator();
+
+    /** 
+     * Returns the keyboard translator with the given name or 0 if no translator
+     * with that name exists.
+     *
+     * The first time that a translator with a particular name is requested,
+     * the on-disk .keyboard file is loaded and parsed.  
+     */
+    const KeyboardTranslator* findTranslator(const QString& name);
+    /**
+     * Returns a list of the names of available keyboard translators.
+     *
+     * The first time this is called, a search for available 
+     * translators is started.
+     */
+    QList<QString> allTranslators();
+
+    /** Returns the global KeyboardTranslatorManager instance. */
+   static KeyboardTranslatorManager* instance();
+
+private:
+    static const char* defaultTranslatorText;
+    
+    void findTranslators(); // locate the available translators
+    KeyboardTranslator* loadTranslator(const QString& name); // loads the translator 
+                                                             // with the given name
+    KeyboardTranslator* loadTranslator(QIODevice* device,const QString& name);
+
+    bool saveTranslator(const KeyboardTranslator* translator);
+    QString findTranslatorPath(const QString& name);
+    
+    QHash<QString,KeyboardTranslator*> _translators; // maps translator-name -> KeyboardTranslator
+                                                     // instance
+    bool _haveLoadedAll;
+};
+
+inline int KeyboardTranslator::Entry::keyCode() const { return _keyCode; }
+inline void KeyboardTranslator::Entry::setKeyCode(int keyCode) { _keyCode = keyCode; }
+
+inline void KeyboardTranslator::Entry::setModifiers( Qt::KeyboardModifiers modifier ) 
+{ 
+    _modifiers = modifier;
+}
+inline Qt::KeyboardModifiers KeyboardTranslator::Entry::modifiers() const { return _modifiers; }
+
+inline void  KeyboardTranslator::Entry::setModifierMask( Qt::KeyboardModifiers mask ) 
+{ 
+   _modifierMask = mask; 
+}
+inline Qt::KeyboardModifiers KeyboardTranslator::Entry::modifierMask() const { return _modifierMask; }
+
+inline bool KeyboardTranslator::Entry::isNull() const
+{
+    return ( *this == Entry() );
+}
+
+inline void KeyboardTranslator::Entry::setCommand( Command command )
+{ 
+    _command = command; 
+}
+inline KeyboardTranslator::Command KeyboardTranslator::Entry::command() const { return _command; }
+
+inline void KeyboardTranslator::Entry::setText( const QByteArray& text )
+{ 
+    _text = unescape(text);
+}
+inline int oneOrZero(int value)
+{
+    return value ? 1 : 0;
+}
+inline QByteArray KeyboardTranslator::Entry::text(bool expandWildCards,Qt::KeyboardModifiers modifiers) const 
+{
+    QByteArray expandedText = _text;
+    
+    if (expandWildCards)
+    {
+        int modifierValue = 1;
+        modifierValue += oneOrZero(modifiers & Qt::ShiftModifier);
+        modifierValue += oneOrZero(modifiers & Qt::AltModifier)     << 1;
+        modifierValue += oneOrZero(modifiers & Qt::ControlModifier) << 2;
+
+        for (int i=0;i<_text.length();i++) 
+        {
+            if (expandedText[i] == '*')
+                expandedText[i] = '0' + modifierValue;
+        }
+    }
+
+    return expandedText; 
+}
+
+inline void KeyboardTranslator::Entry::setState( States state )
+{ 
+    _state = state; 
+}
+inline KeyboardTranslator::States KeyboardTranslator::Entry::state() const { return _state; }
+
+inline void KeyboardTranslator::Entry::setStateMask( States stateMask )
+{ 
+    _stateMask = stateMask; 
+}
+inline KeyboardTranslator::States KeyboardTranslator::Entry::stateMask() const { return _stateMask; }
+
+
+#endif // KEYBOARDTRANSLATOR_H
+
diff --git a/libgui/qterminal/libqterminal/unix/LineFont.h b/libgui/qterminal/libqterminal/unix/LineFont.h
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/LineFont.h
@@ -0,0 +1,21 @@
+// WARNING: Autogenerated by "fontembedder ./linefont.src".
+// You probably do not want to hand-edit this!
+
+static const quint32 LineChars[] = {
+	0x00007c00, 0x000fffe0, 0x00421084, 0x00e739ce, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00427000, 0x004e7380, 0x00e77800, 0x00ef7bc0, 
+	0x00421c00, 0x00439ce0, 0x00e73c00, 0x00e7bde0, 0x00007084, 0x000e7384, 0x000079ce, 0x000f7bce, 
+	0x00001c84, 0x00039ce4, 0x00003dce, 0x0007bdee, 0x00427084, 0x004e7384, 0x004279ce, 0x00e77884, 
+	0x00e779ce, 0x004f7bce, 0x00ef7bc4, 0x00ef7bce, 0x00421c84, 0x00439ce4, 0x00423dce, 0x00e73c84, 
+	0x00e73dce, 0x0047bdee, 0x00e7bde4, 0x00e7bdee, 0x00427c00, 0x0043fce0, 0x004e7f80, 0x004fffe0, 
+	0x004fffe0, 0x00e7fde0, 0x006f7fc0, 0x00efffe0, 0x00007c84, 0x0003fce4, 0x000e7f84, 0x000fffe4, 
+	0x00007dce, 0x0007fdee, 0x000f7fce, 0x000fffee, 0x00427c84, 0x0043fce4, 0x004e7f84, 0x004fffe4, 
+	0x00427dce, 0x00e77c84, 0x00e77dce, 0x0047fdee, 0x004e7fce, 0x00e7fde4, 0x00ef7f84, 0x004fffee, 
+	0x00efffe4, 0x00e7fdee, 0x00ef7fce, 0x00efffee, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 
+	0x000f83e0, 0x00a5294a, 0x004e1380, 0x00a57800, 0x00ad0bc0, 0x004390e0, 0x00a53c00, 0x00a5a1e0, 
+	0x000e1384, 0x0000794a, 0x000f0b4a, 0x000390e4, 0x00003d4a, 0x0007a16a, 0x004e1384, 0x00a5694a, 
+	0x00ad2b4a, 0x004390e4, 0x00a52d4a, 0x00a5a16a, 0x004f83e0, 0x00a57c00, 0x00ad83e0, 0x000f83e4, 
+	0x00007d4a, 0x000f836a, 0x004f93e4, 0x00a57d4a, 0x00ad836a, 0x00000000, 0x00000000, 0x00000000, 
+	0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00001c00, 0x00001084, 0x00007000, 0x00421000, 
+	0x00039ce0, 0x000039ce, 0x000e7380, 0x00e73800, 0x000e7f80, 0x00e73884, 0x0003fce0, 0x004239ce
+};
diff --git a/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.cpp b/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.cpp
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.cpp
@@ -0,0 +1,163 @@
+/*  Copyright (C) 2008 e_k (e_k@users.sourceforge.net)
+    Copyright (C) 2012 Jacob Dawid <jacob.dawid@googlemail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#include <QDebug>
+
+#include "unix/QUnixTerminalImpl.h"
+#include "unix/kpty.h"
+
+#include <termios.h>
+
+QUnixTerminalImpl::QUnixTerminalImpl(QWidget *parent)
+    : QTerminalInterface(parent) {
+    setMinimumSize(600, 400);
+    initialize();
+}
+
+void QUnixTerminalImpl::initialize()
+{
+    m_terminalView = new TerminalView(this);
+    m_terminalView->setKeyboardCursorShape(TerminalView::UnderlineCursor);
+    m_terminalView->setBlinkingCursor(true);
+    m_terminalView->setBellMode(TerminalView::NotifyBell);
+    m_terminalView->setTerminalSizeHint(true);
+    m_terminalView->setContextMenuPolicy(Qt::CustomContextMenu);
+    m_terminalView->setTripleClickMode(TerminalView::SelectWholeLine);
+    m_terminalView->setTerminalSizeStartup(true);
+    m_terminalView->setSize(80, 40);
+    m_terminalView->setScrollBarPosition(TerminalView::ScrollBarRight);
+
+    connect(m_terminalView, SIGNAL(customContextMenuRequested(QPoint)),
+            this, SLOT(handleCustomContextMenuRequested(QPoint)));
+
+#ifdef Q_OS_MAC
+    QFont font = QFont("Monaco");
+    font.setStyleHint(QFont::TypeWriter);
+    font.setPointSize(11);
+#else
+    QFont font = QFont("Monospace");
+    font.setStyleHint(QFont::TypeWriter);
+    font.setPointSize(10);
+#endif
+    setTerminalFont(font);
+    setFocusProxy(m_terminalView);
+    setFocus(Qt::OtherFocusReason);
+
+    m_kpty = new KPty();
+    m_kpty->open();
+
+    m_terminalModel = new TerminalModel(m_kpty);
+    m_terminalModel->setAutoClose(true);
+    m_terminalModel->setCodec(QTextCodec::codecForName("UTF-8"));
+    m_terminalModel->setHistoryType(HistoryTypeBuffer(1000));
+    m_terminalModel->setDarkBackground(true);
+    m_terminalModel->setKeyBindings("");
+    m_terminalModel->run();
+    m_terminalModel->addView(m_terminalView);
+    connectToPty();
+}
+
+void QUnixTerminalImpl::connectToPty()
+{
+    int fds = m_kpty->slaveFd();
+
+    dup2 (fds, STDIN_FILENO);
+    dup2 (fds, STDOUT_FILENO);
+    dup2 (fds, STDERR_FILENO);
+
+    if(!isatty(STDIN_FILENO)) {
+        qDebug("Error: stdin is not a tty.");
+    }
+
+    if(!isatty(STDOUT_FILENO)) {
+        qDebug("Error: stdout is not a tty.");
+    }
+
+    if(!isatty(STDERR_FILENO)) {
+        qDebug("Error: stderr is not a tty.");
+    }
+}
+
+QUnixTerminalImpl::~QUnixTerminalImpl()
+{
+    emit destroyed();
+}
+
+void QUnixTerminalImpl::setTerminalFont(const QFont &font)
+{
+    if(!m_terminalView)
+        return;
+    m_terminalView->setVTFont(font);
+}
+
+void QUnixTerminalImpl::setSize(int h, int v)
+{
+    if(!m_terminalView)
+        return;
+    m_terminalView->setSize(h, v);
+}
+
+void QUnixTerminalImpl::sendText(const QString& text)
+{
+    m_terminalModel->sendText(text);
+}
+
+void QUnixTerminalImpl::setCursorType(CursorType type, bool blinking)
+{
+    switch(type) {
+        case UnderlineCursor: m_terminalView->setKeyboardCursorShape(TerminalView::UnderlineCursor); break;
+        case BlockCursor: m_terminalView->setKeyboardCursorShape(TerminalView::BlockCursor); break;
+        case IBeamCursor: m_terminalView->setKeyboardCursorShape(TerminalView::IBeamCursor); break;
+    }
+    m_terminalView->setBlinkingCursor(blinking);
+}
+
+void QUnixTerminalImpl::focusInEvent(QFocusEvent *focusEvent)
+{
+    Q_UNUSED(focusEvent);
+    m_terminalView->updateImage();
+    m_terminalView->repaint();
+    m_terminalView->update();
+}
+
+void QUnixTerminalImpl::showEvent(QShowEvent *)
+{
+    m_terminalView->updateImage();
+    m_terminalView->repaint();
+    m_terminalView->update();
+}
+
+void QUnixTerminalImpl::resizeEvent(QResizeEvent*)
+{
+    m_terminalView->resize(this->size());
+    m_terminalView->updateImage();
+    m_terminalView->repaint();
+    m_terminalView->update();
+}
+
+void QUnixTerminalImpl::copyClipboard()
+{
+    m_terminalView->copyClipboard();
+}
+
+void QUnixTerminalImpl::pasteClipboard()
+{
+    m_terminalView->pasteClipboard();
+}
+
diff --git a/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.h b/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.h
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/QUnixTerminalImpl.h
@@ -0,0 +1,61 @@
+/*  Copyright (C) 2008 e_k (e_k@users.sourceforge.net)
+    Copyright (C) 2012 Jacob Dawid <jacob.dawid@googlemail.com>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+		    
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+			    
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+						    
+
+#ifndef Q_UNIXTERMINALIMPL
+#define Q_UNIXTERMINALIMPL
+
+#include <QtGui>
+#include "unix/kpty.h"
+#include "unix/TerminalModel.h"
+#include "unix/TerminalView.h"
+#include "QTerminalInterface.h"
+
+class QUnixTerminalImpl : public QTerminalInterface
+{
+    Q_OBJECT
+public:
+    QUnixTerminalImpl(QWidget *parent = 0);
+    virtual ~QUnixTerminalImpl();
+    
+    void setTerminalFont(const QFont &font); 
+    void setSize(int h, int v);
+    void sendText(const QString& text);
+
+    void setCursorType(CursorType type, bool blinking);
+
+public slots:
+    void copyClipboard();
+    void pasteClipboard();
+        
+protected:
+    void focusInEvent(QFocusEvent *focusEvent);
+    void showEvent(QShowEvent *);
+    virtual void resizeEvent(QResizeEvent *);   
+    
+private:
+    void initialize();
+    void connectToPty();
+
+    TerminalView *m_terminalView;
+    TerminalModel *m_terminalModel;
+    KPty *m_kpty;
+};
+
+#endif // Q_UNIXTERMINALIMPL
diff --git a/libgui/qterminal/libqterminal/unix/Screen.cpp b/libgui/qterminal/libqterminal/unix/Screen.cpp
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/Screen.cpp
@@ -0,0 +1,1566 @@
+/*
+    This file is part of Konsole, an X terminal.
+    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+// Own
+#include "unix/Screen.h"
+
+// Standard
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <assert.h>
+#include <string.h>
+#include <ctype.h>
+
+// Qt
+#include <QtCore/QTextStream>
+#include <QtCore/QDate>
+
+// Konsole
+#include "unix/konsole_wcwidth.h"
+#include "unix/TerminalCharacterDecoder.h"
+
+//FIXME: this is emulation specific. Use false for xterm, true for ANSI.
+//FIXME: see if we can get this from terminfo.
+#define BS_CLEARS false
+
+//Macro to convert x,y position on screen to position within an image.
+//
+//Originally the image was stored as one large contiguous block of 
+//memory, so a position within the image could be represented as an
+//offset from the beginning of the block.  For efficiency reasons this
+//is no longer the case.  
+//Many internal parts of this class still use this representation for parameters and so on,
+//notably moveImage() and clearImage().
+//This macro converts from an X,Y position into an image offset.
+#ifndef loc
+#define loc(X,Y) ((Y)*columns+(X))
+#endif
+
+
+Character Screen::defaultChar = Character(' ',
+					  CharacterColor(COLOR_SPACE_DEFAULT,DEFAULT_FORE_COLOR),
+					  CharacterColor(COLOR_SPACE_DEFAULT,DEFAULT_BACK_COLOR),
+					  DEFAULT_RENDITION);
+
+//#define REVERSE_WRAPPED_LINES  // for wrapped line debug
+
+Screen::Screen(int l, int c)
+  : lines(l),
+    columns(c),
+    screenLines(new ImageLine[lines+1] ),
+    _scrolledLines(0),
+    _droppedLines(0),
+    hist(new HistoryScrollNone()),
+    cuX(0), cuY(0),
+    cu_re(0),
+    tmargin(0), bmargin(0),
+    tabstops(0),
+    sel_begin(0), sel_TL(0), sel_BR(0),
+    sel_busy(false),
+    columnmode(false),
+    ef_fg(CharacterColor()), ef_bg(CharacterColor()), ef_re(0),
+    sa_cuX(0), sa_cuY(0),
+    sa_cu_re(0),
+    lastPos(-1)
+{
+  lineProperties.resize(lines+1);
+  for (int i=0;i<lines+1;i++)
+          lineProperties[i]=LINE_DEFAULT;
+
+  initTabStops();
+  clearSelection();
+  reset();
+}
+
+/*! Destructor
+*/
+
+Screen::~Screen()
+{
+  delete[] screenLines;
+  delete[] tabstops;
+  delete hist;
+}
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/* Normalized                    Screen Operations                           */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+// Cursor Setting --------------------------------------------------------------
+
+/*! \section Cursor
+
+    The `cursor' is a location within the screen that is implicitely used in
+    many operations. The operations within this section allow to manipulate
+    the cursor explicitly and to obtain it's value.
+
+    The position of the cursor is guarantied to be between (including) 0 and
+    `columns-1' and `lines-1'.
+*/
+
+/*!
+    Move the cursor up.
+
+    The cursor will not be moved beyond the top margin.
+*/
+
+void Screen::cursorUp(int n)
+//=CUU
+{
+  if (n == 0) n = 1; // Default
+  int stop = cuY < tmargin ? 0 : tmargin;
+  cuX = qMin(columns-1,cuX); // nowrap!
+  cuY = qMax(stop,cuY-n);
+}
+
+/*!
+    Move the cursor down.
+
+    The cursor will not be moved beyond the bottom margin.
+*/
+
+void Screen::cursorDown(int n)
+//=CUD
+{
+  if (n == 0) n = 1; // Default
+  int stop = cuY > bmargin ? lines-1 : bmargin;
+  cuX = qMin(columns-1,cuX); // nowrap!
+  cuY = qMin(stop,cuY+n);
+}
+
+/*!
+    Move the cursor left.
+
+    The cursor will not move beyond the first column.
+*/
+
+void Screen::cursorLeft(int n)
+//=CUB
+{
+  if (n == 0) n = 1; // Default
+  cuX = qMin(columns-1,cuX); // nowrap!
+  cuX = qMax(0,cuX-n);
+}
+
+/*!
+    Move the cursor left.
+
+    The cursor will not move beyond the rightmost column.
+*/
+
+void Screen::cursorRight(int n)
+//=CUF
+{
+  if (n == 0) n = 1; // Default
+  cuX = qMin(columns-1,cuX+n);
+}
+
+void Screen::setMargins(int top, int bot)
+//=STBM
+{
+  if (top == 0) top = 1;      // Default
+  if (bot == 0) bot = lines;  // Default
+  top = top - 1;              // Adjust to internal lineno
+  bot = bot - 1;              // Adjust to internal lineno
+  if ( !( 0 <= top && top < bot && bot < lines ) )
+  { qDebug()<<" setRegion("<<top<<","<<bot<<") : bad range.";
+    return;                   // Default error action: ignore
+  }
+  tmargin = top;
+  bmargin = bot;
+  cuX = 0;
+  cuY = getMode(MODE_Origin) ? top : 0;
+
+}
+
+int Screen::topMargin() const
+{
+    return tmargin;
+}
+int Screen::bottomMargin() const
+{
+    return bmargin;
+}
+
+void Screen::index()
+//=IND
+{
+  if (cuY == bmargin)
+  {
+    scrollUp(1);
+  }
+  else if (cuY < lines-1)
+    cuY += 1;
+}
+
+void Screen::reverseIndex()
+//=RI
+{
+  if (cuY == tmargin)
+     scrollDown(tmargin,1);
+  else if (cuY > 0)
+    cuY -= 1;
+}
+
+/*!
+    Move the cursor to the begin of the next line.
+
+    If cursor is on bottom margin, the region between the
+    actual top and bottom margin is scrolled up.
+*/
+
+void Screen::NextLine()
+//=NEL
+{
+  Return(); index();
+}
+
+void Screen::eraseChars(int n)
+{
+  if (n == 0) n = 1; // Default
+  int p = qMax(0,qMin(cuX+n-1,columns-1));
+  clearImage(loc(cuX,cuY),loc(p,cuY),' ');
+}
+
+void Screen::deleteChars(int n)
+{
+  Q_ASSERT( n >= 0 );
+
+  // always delete at least one char
+  if (n == 0) 
+      n = 1; 
+
+  // if cursor is beyond the end of the line there is nothing to do
+  if ( cuX >= screenLines[cuY].count() )
+      return;
+
+  if ( cuX+n >= screenLines[cuY].count() ) 
+       n = screenLines[cuY].count() - 1 - cuX;
+
+  Q_ASSERT( n >= 0 );
+  Q_ASSERT( cuX+n < screenLines[cuY].count() );
+
+  screenLines[cuY].remove(cuX,n);
+}
+
+void Screen::insertChars(int n)
+{
+  if (n == 0) n = 1; // Default
+
+  if ( screenLines[cuY].size() < cuX )
+    screenLines[cuY].resize(cuX);
+
+  screenLines[cuY].insert(cuX,n,' ');
+
+  if ( screenLines[cuY].count() > columns )
+      screenLines[cuY].resize(columns);
+}
+
+void Screen::deleteLines(int n)
+{
+  if (n == 0) n = 1; // Default
+  scrollUp(cuY,n);
+}
+
+/*! insert `n' lines at the cursor position.
+
+    The cursor is not moved by the operation.
+*/
+
+void Screen::insertLines(int n)
+{
+  if (n == 0) n = 1; // Default
+  scrollDown(cuY,n);
+}
+
+// Mode Operations -----------------------------------------------------------
+
+/*! Set a specific mode. */
+
+void Screen::setMode(int m)
+{
+  currParm.mode[m] = true;
+  switch(m)
+  {
+    case MODE_Origin : cuX = 0; cuY = tmargin; break; //FIXME: home
+  }
+}
+
+/*! Reset a specific mode. */
+
+void Screen::resetMode(int m)
+{
+  currParm.mode[m] = false;
+  switch(m)
+  {
+    case MODE_Origin : cuX = 0; cuY = 0; break; //FIXME: home
+  }
+}
+
+/*! Save a specific mode. */
+
+void Screen::saveMode(int m)
+{
+  saveParm.mode[m] = currParm.mode[m];
+}
+
+/*! Restore a specific mode. */
+
+void Screen::restoreMode(int m)
+{
+  currParm.mode[m] = saveParm.mode[m];
+}
+
+bool Screen::getMode(int m) const
+{
+  return currParm.mode[m];
+}
+
+void Screen::saveCursor()
+{
+  sa_cuX     = cuX;
+  sa_cuY     = cuY;
+  sa_cu_re   = cu_re;
+  sa_cu_fg   = cu_fg;
+  sa_cu_bg   = cu_bg;
+}
+
+void Screen::restoreCursor()
+{
+  cuX     = qMin(sa_cuX,columns-1);
+  cuY     = qMin(sa_cuY,lines-1);
+  cu_re   = sa_cu_re;
+  cu_fg   = sa_cu_fg;
+  cu_bg   = sa_cu_bg;
+  effectiveRendition();
+}
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                             Screen Operations                             */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+/*! Resize the screen image
+
+    The topmost left position is maintained, while lower lines
+    or right hand side columns might be removed or filled with
+    spaces to fit the new size.
+
+    The region setting is reset to the whole screen and the
+    tab positions reinitialized.
+
+    If the new image is narrower than the old image then text on lines
+    which extends past the end of the new image is preserved so that it becomes
+    visible again if the screen is later resized to make it larger.
+*/
+
+void Screen::resizeImage(int new_lines, int new_columns)
+{
+  if ((new_lines==lines) && (new_columns==columns)) return;
+
+  if (cuY > new_lines-1)
+  { // attempt to preserve focus and lines
+    bmargin = lines-1; //FIXME: margin lost
+    for (int i = 0; i < cuY-(new_lines-1); i++)
+    {
+      addHistLine(); scrollUp(0,1);
+    }
+  }
+
+  // create new screen lines and copy from old to new
+  
+   ImageLine* newScreenLines = new ImageLine[new_lines+1];
+   for (int i=0; i < qMin(lines-1,new_lines+1) ;i++)
+           newScreenLines[i]=screenLines[i];
+   for (int i=lines;(i > 0) && (i<new_lines+1);i++)
+           newScreenLines[i].resize( new_columns );
+   
+  lineProperties.resize(new_lines+1);
+  for (int i=lines;(i > 0) && (i<new_lines+1);i++)
+          lineProperties[i] = LINE_DEFAULT;
+
+  clearSelection();
+ 
+  delete[] screenLines; 
+  screenLines = newScreenLines;
+
+  lines = new_lines;
+  columns = new_columns;
+  cuX = qMin(cuX,columns-1);
+  cuY = qMin(cuY,lines-1);
+
+  // FIXME: try to keep values, evtl.
+  tmargin=0;
+  bmargin=lines-1;
+  initTabStops();
+  clearSelection();
+}
+
+void Screen::setDefaultMargins()
+{
+	tmargin = 0;
+	bmargin = lines-1;
+}
+
+
+/*
+   Clarifying rendition here and in the display.
+
+   currently, the display's color table is
+     0       1       2 .. 9    10 .. 17
+     dft_fg, dft_bg, dim 0..7, intensive 0..7
+
+   cu_fg, cu_bg contain values 0..8;
+   - 0    = default color
+   - 1..8 = ansi specified color
+
+   re_fg, re_bg contain values 0..17
+   due to the TerminalDisplay's color table
+
+   rendition attributes are
+
+      attr           widget screen
+      -------------- ------ ------
+      RE_UNDERLINE     XX     XX    affects foreground only
+      RE_BLINK         XX     XX    affects foreground only
+      RE_BOLD          XX     XX    affects foreground only
+      RE_REVERSE       --     XX
+      RE_TRANSPARENT   XX     --    affects background only
+      RE_INTENSIVE     XX     --    affects foreground only
+
+   Note that RE_BOLD is used in both widget
+   and screen rendition. Since xterm/vt102
+   is to poor to distinguish between bold
+   (which is a font attribute) and intensive
+   (which is a color attribute), we translate
+   this and RE_BOLD in falls eventually appart
+   into RE_BOLD and RE_INTENSIVE.
+*/
+
+void Screen::reverseRendition(Character& p) const
+{ 
+	CharacterColor f = p.foregroundColor; 
+	CharacterColor b = p.backgroundColor;
+  	
+	p.foregroundColor = b; 
+	p.backgroundColor = f; //p->r &= ~RE_TRANSPARENT;
+}
+
+void Screen::effectiveRendition()
+// calculate rendition
+{
+  //copy "current rendition" straight into "effective rendition", which is then later copied directly
+  //into the image[] array which holds the characters and their appearance properties.
+  //- The old version below filtered out all attributes other than underline and blink at this stage,
+  //so that they would not be copied into the image[] array and hence would not be visible by TerminalDisplay
+  //which actually paints the screen using the information from the image[] array.  
+  //I don't know why it did this, but I'm fairly sure it was the wrong thing to do.  The net result
+  //was that bold text wasn't printed in bold by Konsole.
+  ef_re = cu_re;
+  
+  //OLD VERSION:
+  //ef_re = cu_re & (RE_UNDERLINE | RE_BLINK);
+  
+  if (cu_re & RE_REVERSE)
+  {
+    ef_fg = cu_bg;
+    ef_bg = cu_fg;
+  }
+  else
+  {
+    ef_fg = cu_fg;
+    ef_bg = cu_bg;
+  }
+ 
+  if (cu_re & RE_BOLD)
+    ef_fg.toggleIntensive();
+}
+
+/*!
+    returns the image.
+
+    Get the size of the image by \sa getLines and \sa getColumns.
+
+    NOTE that the image returned by this function must later be
+    freed.
+
+*/
+
+void Screen::copyFromHistory(Character* dest, int startLine, int count) const
+{
+  Q_ASSERT( startLine >= 0 && count > 0 && startLine + count <= hist->getLines() );
+
+  for (int line = startLine; line < startLine + count; line++) 
+  {
+    const int length = qMin(columns,hist->getLineLen(line));
+    const int destLineOffset  = (line-startLine)*columns;
+
+    hist->getCells(line,0,length,dest + destLineOffset);
+
+    for (int column = length; column < columns; column++) 
+		dest[destLineOffset+column] = defaultChar;
+    
+	// invert selected text
+	if (sel_begin !=-1)
+	{
+    	for (int column = 0; column < columns; column++)
+    	{
+        	if (isSelected(column,line)) 
+			{
+          		reverseRendition(dest[destLineOffset + column]); 
+    		}
+  		}
+	}
+  }
+}
+
+void Screen::copyFromScreen(Character* dest , int startLine , int count) const
+{
+	Q_ASSERT( startLine >= 0 && count > 0 && startLine + count <= lines );
+
+    for (int line = startLine; line < (startLine+count) ; line++)
+    {
+       int srcLineStartIndex  = line*columns;
+	   int destLineStartIndex = (line-startLine)*columns;
+
+       for (int column = 0; column < columns; column++)
+       { 
+		 int srcIndex = srcLineStartIndex + column; 
+		 int destIndex = destLineStartIndex + column;
+
+         dest[destIndex] = screenLines[srcIndex/columns].value(srcIndex%columns,defaultChar);
+
+	     // invert selected text
+         if (sel_begin != -1 && isSelected(column,line + hist->getLines()))
+           reverseRendition(dest[destIndex]); 
+       }
+
+    }
+}
+
+void Screen::getImage( Character* dest, int size, int startLine, int endLine ) const
+{
+  Q_ASSERT( startLine >= 0 ); 
+  Q_ASSERT( endLine >= startLine && endLine < hist->getLines() + lines );
+
+  const int mergedLines = endLine - startLine + 1;
+
+  Q_ASSERT( size >= mergedLines * columns ); 
+  Q_UNUSED( size );
+
+  const int linesInHistoryBuffer = qBound(0,hist->getLines()-startLine,mergedLines);
+  const int linesInScreenBuffer = mergedLines - linesInHistoryBuffer;
+
+  // copy lines from history buffer
+  if (linesInHistoryBuffer > 0) {
+  	copyFromHistory(dest,startLine,linesInHistoryBuffer); 
+    }
+
+  // copy lines from screen buffer
+  if (linesInScreenBuffer > 0) {
+  	copyFromScreen(dest + linesInHistoryBuffer*columns,
+				   startLine + linesInHistoryBuffer - hist->getLines(),
+				   linesInScreenBuffer);
+    }				
+ 
+  // invert display when in screen mode
+  if (getMode(MODE_Screen))
+  {  
+    for (int i = 0; i < mergedLines*columns; i++)
+      reverseRendition(dest[i]); // for reverse display
+  }
+
+  // mark the character at the current cursor position
+  int cursorIndex = loc(cuX, cuY + linesInHistoryBuffer);
+  if(getMode(MODE_Cursor) && cursorIndex < columns*mergedLines)
+    dest[cursorIndex].rendition |= RE_CURSOR;
+}
+
+QVector<LineProperty> Screen::getLineProperties( int startLine , int endLine ) const
+{
+  Q_ASSERT( startLine >= 0 ); 
+  Q_ASSERT( endLine >= startLine && endLine < hist->getLines() + lines );
+
+	const int mergedLines = endLine-startLine+1;
+	const int linesInHistory = qBound(0,hist->getLines()-startLine,mergedLines);
+  const int linesInScreen = mergedLines - linesInHistory;
+
+  QVector<LineProperty> result(mergedLines);
+  int index = 0;
+
+  // copy properties for lines in history
+  for (int line = startLine; line < startLine + linesInHistory; line++) 
+  {
+		//TODO Support for line properties other than wrapped lines
+	  if (hist->isWrappedLine(line))
+	  {
+	  	result[index] = (LineProperty)(result[index] | LINE_WRAPPED);
+	  }
+    index++;
+  }
+  
+  // copy properties for lines in screen buffer
+  const int firstScreenLine = startLine + linesInHistory - hist->getLines();
+  for (int line = firstScreenLine; line < firstScreenLine+linesInScreen; line++)
+	{
+    result[index]=lineProperties[line];
+  	index++;
+	}
+
+  return result;
+}
+
+/*!
+*/
+
+void Screen::reset(bool clearScreen)
+{
+    setMode(MODE_Wrap  ); saveMode(MODE_Wrap  );  // wrap at end of margin
+  resetMode(MODE_Origin); saveMode(MODE_Origin);  // position refere to [1,1]
+  resetMode(MODE_Insert); saveMode(MODE_Insert);  // overstroke
+    setMode(MODE_Cursor);                         // cursor visible
+  resetMode(MODE_Screen);                         // screen not inverse
+  resetMode(MODE_NewLine);
+
+  tmargin=0;
+  bmargin=lines-1;
+
+  setDefaultRendition();
+  saveCursor();
+
+  if ( clearScreen )
+    clear();
+}
+
+/*! Clear the entire screen and home the cursor.
+*/
+
+void Screen::clear()
+{
+  clearEntireScreen();
+  home();
+}
+
+void Screen::BackSpace()
+{
+  cuX = qMin(columns-1,cuX); // nowrap!
+  cuX = qMax(0,cuX-1);
+ // if (BS_CLEARS) image[loc(cuX,cuY)].character = ' ';
+
+  if (screenLines[cuY].size() < cuX+1)
+          screenLines[cuY].resize(cuX+1);
+
+  if (BS_CLEARS) screenLines[cuY][cuX].character = ' ';
+}
+
+void Screen::Tabulate(int n)
+{
+  // note that TAB is a format effector (does not write ' ');
+  if (n == 0) n = 1;
+  while((n > 0) && (cuX < columns-1))
+  {
+    cursorRight(1); while((cuX < columns-1) && !tabstops[cuX]) cursorRight(1);
+    n--;
+  }
+}
+
+void Screen::backTabulate(int n)
+{
+  // note that TAB is a format effector (does not write ' ');
+  if (n == 0) n = 1;
+  while((n > 0) && (cuX > 0))
+  {
+     cursorLeft(1); while((cuX > 0) && !tabstops[cuX]) cursorLeft(1);
+     n--;
+  }
+}
+
+void Screen::clearTabStops()
+{
+  for (int i = 0; i < columns; i++) tabstops[i] = false;
+}
+
+void Screen::changeTabStop(bool set)
+{
+  if (cuX >= columns) return;
+  tabstops[cuX] = set;
+}
+
+void Screen::initTabStops()
+{
+  delete[] tabstops;
+  tabstops = new bool[columns];
+
+  // Arrg! The 1st tabstop has to be one longer than the other.
+  // i.e. the kids start counting from 0 instead of 1.
+  // Other programs might behave correctly. Be aware.
+  for (int i = 0; i < columns; i++) tabstops[i] = (i%8 == 0 && i != 0);
+}
+
+/*!
+   This behaves either as IND (Screen::Index) or as NEL (Screen::NextLine)
+   depending on the NewLine Mode (LNM). This mode also
+   affects the key sequence returned for newline ([CR]LF).
+*/
+
+void Screen::NewLine()
+{
+  if (getMode(MODE_NewLine)) Return();
+  index();
+}
+
+/*! put `c' literally onto the screen at the current cursor position.
+
+    VT100 uses the convention to produce an automatic newline (am)
+    with the *first* character that would fall onto the next line (xenl).
+*/
+
+void Screen::checkSelection(int from, int to)
+{
+  if (sel_begin == -1) return;
+  int scr_TL = loc(0, hist->getLines());
+  //Clear entire selection if it overlaps region [from, to]
+  if ( (sel_BR > (from+scr_TL) )&&(sel_TL < (to+scr_TL)) )
+  {
+    clearSelection();
+  }
+}
+
+void Screen::ShowCharacter(unsigned short c)
+{
+  // Note that VT100 does wrapping BEFORE putting the character.
+  // This has impact on the assumption of valid cursor positions.
+  // We indicate the fact that a newline has to be triggered by
+  // putting the cursor one right to the last column of the screen.
+
+  int w = konsole_wcwidth(c);
+
+  if (w <= 0)
+     return;
+
+  if (cuX+w > columns) {
+    if (getMode(MODE_Wrap)) {
+      lineProperties[cuY] = (LineProperty)(lineProperties[cuY] | LINE_WRAPPED);
+      NextLine();
+    }
+    else
+      cuX = columns-w;
+  }
+
+  // ensure current line vector has enough elements
+  int size = screenLines[cuY].size();
+  if (size == 0 && cuY > 0)
+  {
+          screenLines[cuY].resize( qMax(screenLines[cuY-1].size() , cuX+w) );
+  }
+  else
+  {
+    if (size < cuX+w)
+    {
+          screenLines[cuY].resize(cuX+w);
+    }
+  }
+
+  if (getMode(MODE_Insert)) insertChars(w);
+
+  lastPos = loc(cuX,cuY);
+
+  // check if selection is still valid.
+  checkSelection(cuX,cuY);
+
+  Character& currentChar = screenLines[cuY][cuX];
+
+  currentChar.character = c;
+  currentChar.foregroundColor = ef_fg;
+  currentChar.backgroundColor = ef_bg;
+  currentChar.rendition = ef_re;
+
+  int i = 0;
+  int newCursorX = cuX + w--;
+  while(w)
+  {
+     i++;
+   
+     if ( screenLines[cuY].size() < cuX + i + 1 )
+         screenLines[cuY].resize(cuX+i+1);
+     
+     Character& ch = screenLines[cuY][cuX + i];
+     ch.character = 0;
+     ch.foregroundColor = ef_fg;
+     ch.backgroundColor = ef_bg;
+     ch.rendition = ef_re;
+
+     w--;
+  }
+  cuX = newCursorX;
+}
+
+void Screen::compose(const QString& /*compose*/)
+{
+   Q_ASSERT( 0 /*Not implemented yet*/ );
+
+/*  if (lastPos == -1)
+     return;
+     
+  QChar c(image[lastPos].character);
+  compose.prepend(c);
+  //compose.compose(); ### FIXME!
+  image[lastPos].character = compose[0].unicode();*/
+}
+
+int Screen::scrolledLines() const
+{
+        return _scrolledLines;
+}
+int Screen::droppedLines() const
+{
+    return _droppedLines;
+}
+void Screen::resetDroppedLines()
+{
+    _droppedLines = 0;
+}
+void Screen::resetScrolledLines()
+{
+    //kDebug() << "scrolled lines reset";
+
+    _scrolledLines = 0;
+}
+
+// Region commands -------------------------------------------------------------
+
+void Screen::scrollUp(int n)
+{
+   if (n == 0) n = 1; // Default
+   if (tmargin == 0) addHistLine(); // hist.history
+   scrollUp(tmargin, n);
+}
+
+/*! scroll up `n' lines within current region.
+    The `n' new lines are cleared.
+    \sa setRegion \sa scrollDown
+*/
+
+QRect Screen::lastScrolledRegion() const
+{
+    return _lastScrolledRegion;
+}
+
+void Screen::scrollUp(int from, int n)
+{
+  if (n <= 0 || from + n > bmargin) return;
+
+  _scrolledLines -= n;
+  _lastScrolledRegion = QRect(0,tmargin,columns-1,(bmargin-tmargin));
+
+  //FIXME: make sure `tmargin', `bmargin', `from', `n' is in bounds.
+  moveImage(loc(0,from),loc(0,from+n),loc(columns-1,bmargin));
+  clearImage(loc(0,bmargin-n+1),loc(columns-1,bmargin),' ');
+}
+
+void Screen::scrollDown(int n)
+{
+   if (n == 0) n = 1; // Default
+   scrollDown(tmargin, n);
+}
+
+/*! scroll down `n' lines within current region.
+    The `n' new lines are cleared.
+    \sa setRegion \sa scrollUp
+*/
+
+void Screen::scrollDown(int from, int n)
+{
+
+  //kDebug() << "Screen::scrollDown( from: " << from << " , n: " << n << ")";
+  
+  _scrolledLines += n;
+
+//FIXME: make sure `tmargin', `bmargin', `from', `n' is in bounds.
+  if (n <= 0) return;
+  if (from > bmargin) return;
+  if (from + n > bmargin) n = bmargin - from;
+  moveImage(loc(0,from+n),loc(0,from),loc(columns-1,bmargin-n));
+  clearImage(loc(0,from),loc(columns-1,from+n-1),' ');
+}
+
+void Screen::setCursorYX(int y, int x)
+{
+  setCursorY(y); setCursorX(x);
+}
+
+void Screen::setCursorX(int x)
+{
+  if (x == 0) x = 1; // Default
+  x -= 1; // Adjust
+  cuX = qMax(0,qMin(columns-1, x));
+}
+
+void Screen::setCursorY(int y)
+{
+  if (y == 0) y = 1; // Default
+  y -= 1; // Adjust
+  cuY = qMax(0,qMin(lines  -1, y + (getMode(MODE_Origin) ? tmargin : 0) ));
+}
+
+void Screen::home()
+{
+  cuX = 0;
+  cuY = 0;
+}
+
+void Screen::Return()
+{
+  cuX = 0;
+}
+
+int Screen::getCursorX() const
+{
+  return cuX;
+}
+
+int Screen::getCursorY() const
+{
+  return cuY;
+}
+
+// Erasing ---------------------------------------------------------------------
+
+/*! \section Erasing
+
+    This group of operations erase parts of the screen contents by filling
+    it with spaces colored due to the current rendition settings.
+
+    Althought the cursor position is involved in most of these operations,
+    it is never modified by them.
+*/
+
+/*! fill screen between (including) `loca' (start) and `loce' (end) with spaces.
+
+    This is an internal helper functions. The parameter types are internal
+    addresses of within the screen image and make use of the way how the
+    screen matrix is mapped to the image vector.
+*/
+
+void Screen::clearImage(int loca, int loce, char c)
+{ 
+  int scr_TL=loc(0,hist->getLines());
+  //FIXME: check positions
+
+  //Clear entire selection if it overlaps region to be moved...
+  if ( (sel_BR > (loca+scr_TL) )&&(sel_TL < (loce+scr_TL)) )
+  {
+    clearSelection();
+  }
+
+  int topLine = loca/columns;
+  int bottomLine = loce/columns;
+
+  Character clearCh(c,cu_fg,cu_bg,DEFAULT_RENDITION);
+  
+  //if the character being used to clear the area is the same as the
+  //default character, the affected lines can simply be shrunk.
+  bool isDefaultCh = (clearCh == Character());
+
+  for (int y=topLine;y<=bottomLine;y++)
+  {
+        lineProperties[y] = 0;
+
+        int endCol = ( y == bottomLine) ? loce%columns : columns-1;
+        int startCol = ( y == topLine ) ? loca%columns : 0;
+
+        QVector<Character>& line = screenLines[y];
+
+        if ( isDefaultCh && endCol == columns-1 )
+        {
+            line.resize(startCol);
+        }
+        else
+        {
+            if (line.size() < endCol + 1)
+                line.resize(endCol+1);
+
+            Character* data = line.data();
+            for (int i=startCol;i<=endCol;i++)
+                data[i]=clearCh;
+        }
+  }
+}
+
+/*! move image between (including) `sourceBegin' and `sourceEnd' to 'dest'.
+    
+    The 'dest', 'sourceBegin' and 'sourceEnd' parameters can be generated using
+    the loc(column,line) macro.
+
+NOTE:  moveImage() can only move whole lines.
+
+    This is an internal helper functions. The parameter types are internal
+    addresses of within the screen image and make use of the way how the
+    screen matrix is mapped to the image vector.
+*/
+
+void Screen::moveImage(int dest, int sourceBegin, int sourceEnd)
+{
+  //kDebug() << "moving image from (" << (sourceBegin/columns) 
+  //    << "," << (sourceEnd/columns) << ") to " <<
+  //    (dest/columns);
+
+  Q_ASSERT( sourceBegin <= sourceEnd );
+ 
+  int lines=(sourceEnd-sourceBegin)/columns;
+
+  //move screen image and line properties:
+  //the source and destination areas of the image may overlap, 
+  //so it matters that we do the copy in the right order - 
+  //forwards if dest < sourceBegin or backwards otherwise.
+  //(search the web for 'memmove implementation' for details)
+  if (dest < sourceBegin)
+  {
+    for (int i=0;i<=lines;i++)
+    {
+        screenLines[ (dest/columns)+i ] = screenLines[ (sourceBegin/columns)+i ];
+        lineProperties[(dest/columns)+i]=lineProperties[(sourceBegin/columns)+i];
+    }
+  }
+  else
+  {
+    for (int i=lines;i>=0;i--)
+    {
+        screenLines[ (dest/columns)+i ] = screenLines[ (sourceBegin/columns)+i ];
+        lineProperties[(dest/columns)+i]=lineProperties[(sourceBegin/columns)+i];
+    }
+  }
+
+  if (lastPos != -1)
+  {
+     int diff = dest - sourceBegin; // Scroll by this amount
+     lastPos += diff;
+     if ((lastPos < 0) || (lastPos >= (lines*columns)))
+        lastPos = -1;
+  }
+     
+  // Adjust selection to follow scroll.
+  if (sel_begin != -1)
+  {
+     bool beginIsTL = (sel_begin == sel_TL);
+     int diff = dest - sourceBegin; // Scroll by this amount
+     int scr_TL=loc(0,hist->getLines());
+     int srca = sourceBegin+scr_TL; // Translate index from screen to global
+     int srce = sourceEnd+scr_TL; // Translate index from screen to global
+     int desta = srca+diff;
+     int deste = srce+diff;
+
+     if ((sel_TL >= srca) && (sel_TL <= srce))
+        sel_TL += diff;
+     else if ((sel_TL >= desta) && (sel_TL <= deste))
+        sel_BR = -1; // Clear selection (see below)
+
+     if ((sel_BR >= srca) && (sel_BR <= srce))
+        sel_BR += diff;
+     else if ((sel_BR >= desta) && (sel_BR <= deste))
+        sel_BR = -1; // Clear selection (see below)
+
+     if (sel_BR < 0)
+     {
+        clearSelection();
+     }
+     else
+     {
+        if (sel_TL < 0)
+           sel_TL = 0;
+     }
+
+     if (beginIsTL)
+        sel_begin = sel_TL;
+     else
+        sel_begin = sel_BR;
+  }
+}
+
+void Screen::clearToEndOfScreen()
+{
+  clearImage(loc(cuX,cuY),loc(columns-1,lines-1),' ');
+}
+
+void Screen::clearToBeginOfScreen()
+{
+  clearImage(loc(0,0),loc(cuX,cuY),' ');
+}
+
+void Screen::clearEntireScreen()
+{
+  // Add entire screen to history
+  for (int i = 0; i < (lines-1); i++)
+  {
+    addHistLine(); scrollUp(0,1);
+  }
+
+  clearImage(loc(0,0),loc(columns-1,lines-1),' ');
+}
+
+/*! fill screen with 'E'
+    This is to aid screen alignment
+*/
+
+void Screen::helpAlign()
+{
+  clearImage(loc(0,0),loc(columns-1,lines-1),'E');
+}
+
+void Screen::clearToEndOfLine()
+{
+  clearImage(loc(cuX,cuY),loc(columns-1,cuY),' ');
+}
+
+void Screen::clearToBeginOfLine()
+{
+  clearImage(loc(0,cuY),loc(cuX,cuY),' ');
+}
+
+void Screen::clearEntireLine()
+{
+  clearImage(loc(0,cuY),loc(columns-1,cuY),' ');
+}
+
+void Screen::setRendition(int re)
+{
+  cu_re |= re;
+  effectiveRendition();
+}
+
+void Screen::resetRendition(int re)
+{
+  cu_re &= ~re;
+  effectiveRendition();
+}
+
+void Screen::setDefaultRendition()
+{
+  setForeColor(COLOR_SPACE_DEFAULT,DEFAULT_FORE_COLOR);
+  setBackColor(COLOR_SPACE_DEFAULT,DEFAULT_BACK_COLOR);
+  cu_re   = DEFAULT_RENDITION;
+  effectiveRendition();
+}
+
+void Screen::setForeColor(int space, int color)
+{
+  cu_fg = CharacterColor(space, color);
+
+  if ( cu_fg.isValid() ) 
+    effectiveRendition();
+  else 
+    setForeColor(COLOR_SPACE_DEFAULT,DEFAULT_FORE_COLOR);
+}
+
+void Screen::setBackColor(int space, int color)
+{
+  cu_bg = CharacterColor(space, color);
+
+  if ( cu_bg.isValid() ) 
+    effectiveRendition();
+  else
+    setBackColor(COLOR_SPACE_DEFAULT,DEFAULT_BACK_COLOR);
+}
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                            Marking & Selection                            */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+void Screen::clearSelection()
+{
+  sel_BR = -1;
+  sel_TL = -1;
+  sel_begin = -1;
+}
+
+void Screen::getSelectionStart(int& column , int& line)
+{
+    if ( sel_TL != -1 )
+    {
+        column = sel_TL % columns;
+        line = sel_TL / columns; 
+    }
+    else
+    {
+        column = cuX + getHistLines();
+        line = cuY + getHistLines();
+    }
+}
+void Screen::getSelectionEnd(int& column , int& line)
+{
+    if ( sel_BR != -1 )
+    {
+        column = sel_BR % columns;
+        line = sel_BR / columns;
+    }
+    else
+    {
+        column = cuX + getHistLines();
+        line = cuY + getHistLines();
+    } 
+}
+void Screen::setSelectionStart(/*const ScreenCursor& viewCursor ,*/ const int x, const int y, const bool mode)
+{
+//  kDebug(1211) << "setSelBeginXY(" << x << "," << y << ")";
+  sel_begin = loc(x,y); //+histCursor) ;
+
+  /* FIXME, HACK to correct for x too far to the right... */
+  if (x == columns) sel_begin--;
+
+  sel_BR = sel_begin;
+  sel_TL = sel_begin;
+  columnmode = mode;
+}
+
+void Screen::setSelectionEnd( const int x, const int y)
+{
+//  kDebug(1211) << "setSelExtentXY(" << x << "," << y << ")";
+  if (sel_begin == -1) return;
+  int l =  loc(x,y); // + histCursor);
+
+  if (l < sel_begin)
+  {
+    sel_TL = l;
+    sel_BR = sel_begin;
+  }
+  else
+  {
+    /* FIXME, HACK to correct for x too far to the right... */
+    if (x == columns) l--;
+
+    sel_TL = sel_begin;
+    sel_BR = l;
+  }
+}
+
+bool Screen::isSelected( const int x,const int y) const
+{
+  if (columnmode) {
+    int sel_Left,sel_Right;
+    if ( sel_TL % columns < sel_BR % columns ) {
+      sel_Left = sel_TL; sel_Right = sel_BR;
+    } else {
+      sel_Left = sel_BR; sel_Right = sel_TL;
+    }
+    return ( x >= sel_Left % columns ) && ( x <= sel_Right % columns ) &&
+           ( y >= sel_TL / columns ) && ( y <= sel_BR / columns );
+            //( y+histCursor >= sel_TL / columns ) && ( y+histCursor <= sel_BR / columns );
+  }
+  else {
+  //int pos = loc(x,y+histCursor);
+  int pos = loc(x,y);
+  return ( pos >= sel_TL && pos <= sel_BR );
+  }
+}
+
+QString Screen::selectedText(bool preserveLineBreaks)
+{
+  QString result;
+  QTextStream stream(&result, QIODevice::ReadWrite);
+  
+  PlainTextDecoder decoder;
+  decoder.begin(&stream);
+  writeSelectionToStream(&decoder , preserveLineBreaks);
+  decoder.end();
+  
+  return result;
+}
+
+bool Screen::isSelectionValid() const
+{
+    return ( sel_TL >= 0 && sel_BR >= 0 );
+}
+
+void Screen::writeSelectionToStream(TerminalCharacterDecoder* decoder , 
+                                    bool preserveLineBreaks)
+{
+    // do nothing if selection is invalid
+    if ( !isSelectionValid() )
+        return;
+
+	int top = sel_TL / columns;	
+	int left = sel_TL % columns;
+
+	int bottom = sel_BR / columns;
+	int right = sel_BR % columns;
+
+    Q_ASSERT( top >= 0 && left >= 0 && bottom >= 0 && right >= 0 );
+
+    //kDebug() << "sel_TL = " << sel_TL;
+    //kDebug() << "columns = " << columns;
+
+	for (int y=top;y<=bottom;y++)
+	{
+			int start = 0;
+			if ( y == top || columnmode ) start = left;
+		
+			int count = -1;
+			if ( y == bottom || columnmode ) count = right - start + 1;
+
+            const bool appendNewLine = ( y != bottom );
+			copyLineToStream( y,
+                              start,
+                              count,
+                              decoder, 
+                              appendNewLine,
+                              preserveLineBreaks );
+	}	
+}
+
+
+void Screen::copyLineToStream(int line , 
+                              int start, 
+                              int count,
+                              TerminalCharacterDecoder* decoder,
+                              bool appendNewLine,
+                              bool preserveLineBreaks)
+{
+		//buffer to hold characters for decoding
+		//the buffer is static to avoid initialising every 
+        //element on each call to copyLineToStream
+		//(which is unnecessary since all elements will be overwritten anyway)
+		static const int MAX_CHARS = 1024;
+		static Character characterBuffer[MAX_CHARS];
+		
+		assert( count < MAX_CHARS );
+
+        LineProperty currentLineProperties = 0;
+
+		//determine if the line is in the history buffer or the screen image
+		if (line < hist->getLines())
+		{
+            const int lineLength = hist->getLineLen(line);
+
+            // ensure that start position is before end of line
+            start = qMin(start,qMax(0,lineLength-1));
+
+			//retrieve line from history buffer
+			if (count == -1)
+            {
+					count = lineLength-start;
+            }
+			else
+            {
+					count = qMin(start+count,lineLength)-start;
+            }
+
+            // safety checks
+            assert( start >= 0 );
+            assert( count >= 0 );    
+            assert( (start+count) <= hist->getLineLen(line) );
+
+			hist->getCells(line,start,count,characterBuffer);
+
+            if ( hist->isWrappedLine(line) )
+                currentLineProperties |= LINE_WRAPPED;
+		}
+		else
+		{
+			if ( count == -1 )
+					count = columns - start;
+
+            assert( count >= 0 );
+
+            const int screenLine = line-hist->getLines();
+
+            Character* data = screenLines[screenLine].data();
+            int length = screenLines[screenLine].count();
+
+			//retrieve line from screen image
+			for (int i=start;i < qMin(start+count,length);i++)
+			{
+			    characterBuffer[i-start] = data[i];
+            }
+
+            // count cannot be any greater than length
+			count = qBound(0,count,length-start);
+
+            Q_ASSERT( screenLine < lineProperties.count() );
+            currentLineProperties |= lineProperties[screenLine]; 
+		}
+
+		//do not decode trailing whitespace characters
+		for (int i=count-1 ; i >= 0; i--)
+				if (QChar(characterBuffer[i].character).isSpace())
+						count--;
+				else
+						break;
+
+        // add new line character at end
+        const bool omitLineBreak = (currentLineProperties & LINE_WRAPPED) ||
+                                   !preserveLineBreaks;
+
+        if ( !omitLineBreak && appendNewLine && (count+1 < MAX_CHARS) )
+        {
+            characterBuffer[count] = '\n';
+            count++;
+        }
+
+		//decode line and write to text stream	
+		decoder->decodeLine( (Character*) characterBuffer , 
+                             count, currentLineProperties );
+}
+
+// Method below has been removed because of its reliance on 'histCursor'
+// and I want to restrict the methods which have knowledge of the scroll position
+// to just those which deal with selection and supplying final screen images.
+//
+/*void Screen::writeToStream(QTextStream* stream , TerminalCharacterDecoder* decoder) {
+  sel_begin = 0;
+  sel_BR = sel_begin;
+  sel_TL = sel_begin;
+  setSelectionEnd(columns-1,lines-1+hist->getLines()-histCursor);
+  
+  writeSelectionToStream(stream,decoder);
+  
+  clearSelection();
+}*/
+
+void Screen::writeToStream(TerminalCharacterDecoder* decoder, int from, int to)
+{
+	sel_begin = loc(0,from);
+	sel_TL = sel_begin;
+	sel_BR = loc(columns-1,to);
+	writeSelectionToStream(decoder);
+	clearSelection();
+}
+
+QString Screen::getHistoryLine(int no)
+{
+  sel_begin = loc(0,no);
+  sel_TL = sel_begin;
+  sel_BR = loc(columns-1,no);
+  return selectedText(false);
+}
+
+void Screen::addHistLine()
+{
+  // add line to history buffer
+  // we have to take care about scrolling, too...
+
+  if (hasScroll())
+  {
+    int oldHistLines = hist->getLines();
+
+    hist->addCellsVector(screenLines[0]);
+    hist->addLine( lineProperties[0] & LINE_WRAPPED );
+
+    int newHistLines = hist->getLines();
+
+    bool beginIsTL = (sel_begin == sel_TL);
+
+    // If the history is full, increment the count
+    // of dropped lines
+    if ( newHistLines == oldHistLines )
+        _droppedLines++;
+
+    // Adjust selection for the new point of reference
+    if (newHistLines > oldHistLines)
+    {
+       if (sel_begin != -1)
+       {
+          sel_TL += columns;
+          sel_BR += columns;
+       }
+    }
+
+    if (sel_begin != -1)
+    {
+       // Scroll selection in history up
+       int top_BR = loc(0, 1+newHistLines);
+
+       if (sel_TL < top_BR)
+          sel_TL -= columns;
+
+       if (sel_BR < top_BR)
+          sel_BR -= columns;
+
+       if (sel_BR < 0)
+       {
+          clearSelection();
+       }
+       else
+       {
+          if (sel_TL < 0)
+             sel_TL = 0;
+       }
+
+       if (beginIsTL)
+          sel_begin = sel_TL;
+       else
+          sel_begin = sel_BR;
+    }
+  }
+
+}
+
+int Screen::getHistLines()
+{
+  return hist->getLines();
+}
+
+void Screen::setScroll(const HistoryType& t , bool copyPreviousScroll)
+{
+  clearSelection();
+
+  if ( copyPreviousScroll )
+    hist = t.scroll(hist);
+  else
+  {
+      HistoryScroll* oldScroll = hist;
+      hist = t.scroll(0);
+      delete oldScroll;
+  }
+}
+
+bool Screen::hasScroll()
+{
+  return hist->hasScroll();
+}
+
+const HistoryType& Screen::getScroll()
+{
+  return hist->getType();
+}
+
+void Screen::setLineProperty(LineProperty property , bool enable)
+{
+	if ( enable )
+	{
+		lineProperties[cuY] = (LineProperty)(lineProperties[cuY] | property);
+	}
+	else
+	{
+		lineProperties[cuY] = (LineProperty)(lineProperties[cuY] & ~property);
+	}
+}
+void Screen::fillWithDefaultChar(Character* dest, int count)
+{
+	for (int i=0;i<count;i++)
+		dest[i] = defaultChar;
+}
diff --git a/libgui/qterminal/libqterminal/unix/Screen.h b/libgui/qterminal/libqterminal/unix/Screen.h
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/Screen.h
@@ -0,0 +1,655 @@
+/*
+    This file is part of Konsole, KDE's terminal.
+
+    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
+    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef SCREEN_H
+#define SCREEN_H
+
+// Qt
+#include <QtCore/QRect>
+#include <QtCore/QTextStream>
+#include <QtCore/QVarLengthArray>
+
+// Konsole
+#include "unix/Character.h"
+#include "unix/History.h"
+
+#define MODE_Origin    0
+#define MODE_Wrap      1
+#define MODE_Insert    2
+#define MODE_Screen    3
+#define MODE_Cursor    4
+#define MODE_NewLine   5
+#define MODES_SCREEN   6
+
+struct ScreenParm
+{
+  int mode[MODES_SCREEN];
+};
+
+class TerminalCharacterDecoder;
+
+/**
+    \brief An image of characters with associated attributes.
+
+    The terminal emulation ( Emulation ) receives a serial stream of
+    characters from the program currently running in the terminal.
+    From this stream it creates an image of characters which is ultimately
+    rendered by the display widget ( TerminalDisplay ).  Some types of emulation
+    may have more than one screen image. 
+
+    getImage() is used to retrieve the currently visible image
+    which is then used by the display widget to draw the output from the
+    terminal. 
+
+    The number of lines of output history which are kept in addition to the current
+    screen image depends on the history scroll being used to store the output.  
+    The scroll is specified using setScroll()
+    The output history can be retrieved using writeToStream()
+
+    The screen image has a selection associated with it, specified using 
+    setSelectionStart() and setSelectionEnd().  The selected text can be retrieved
+    using selectedText().  When getImage() is used to retrieve the the visible image,
+    characters which are part of the selection have their colours inverted.   
+*/
+class Screen
+{
+public:
+    /** Construct a new screen image of size @p lines by @p columns. */
+    Screen(int lines, int columns);
+    ~Screen();
+
+    // VT100/2 Operations 
+    // Cursor Movement
+    
+    /** Move the cursor up by @p n lines. */
+    void cursorUp    (int n);
+    /** Move the cursor down by @p n lines. */
+    void cursorDown  (int n);
+    /** Move the cursor to the left by @p n columns. */
+    void cursorLeft  (int n);
+    /** Move the cursor to the right by @p n columns. */
+    void cursorRight (int n);
+    /** Position the cursor on line @p y. */
+    void setCursorY  (int y);
+    /** Position the cursor at column @p x. */
+    void setCursorX  (int x);
+    /** Position the cursor at line @p y, column @p x. */
+    void setCursorYX (int y, int x);
+    /**
+     * Sets the margins for scrolling the screen.
+     *
+     * @param topLine The top line of the new scrolling margin. 
+     * @param bottomLine The bottom line of the new scrolling margin. 
+     */
+    void setMargins  (int topLine , int bottomLine);
+    /** Returns the top line of the scrolling region. */ 
+    int topMargin() const;
+    /** Returns the bottom line of the scrolling region. */
+    int bottomMargin() const;
+
+    /** 
+     * Resets the scrolling margins back to the top and bottom lines
+     * of the screen.
+     */
+    void setDefaultMargins();
+    
+    /** 
+     * Moves the cursor down one line, if the MODE_NewLine mode 
+     * flag is enabled then the cursor is returned to the leftmost
+     * column first.
+     *
+     * Equivalent to NextLine() if the MODE_NewLine flag is set
+     * or index() otherwise. 
+     */
+    void NewLine     ();
+    /**
+     * Moves the cursor down one line and positions it at the beginning
+     * of the line.
+     */
+    void NextLine    ();
+
+    /** 
+     * Move the cursor down one line.  If the cursor is on the bottom
+     * line of the scrolling region (as returned by bottomMargin()) the
+     * scrolling region is scrolled up by one line instead.
+     */
+    void index       ();
+    /**
+     * Move the cursor up one line.  If the cursor is on the top line
+     * of the scrolling region (as returned by topMargin()) the scrolling
+     * region is scrolled down by one line instead.
+     */
+    void reverseIndex();
+    
+    /** 
+     * Scroll the scrolling region of the screen up by @p n lines. 
+     * The scrolling region is initially the whole screen, but can be changed 
+     * using setMargins()
+     */ 
+    void scrollUp(int n);
+    /**
+     * Scroll the scrolling region of the screen down by @p n lines.
+     * The scrolling region is initially the whole screen, but can be changed
+     * using setMargins()
+     */
+    void scrollDown(int n);
+    
+    /** 
+     * Moves the cursor to the beginning of the current line. 
+     * Equivalent to setCursorX(0)
+     */
+    void Return      ();
+    /** 
+     * Moves the cursor one column to the left and erases the character
+     * at the new cursor position.
+     */
+    void BackSpace   ();
+    /** 
+     * Moves the cursor @p n tab-stops to the right.
+     */
+    void Tabulate    (int n = 1);
+    /** 
+     * Moves the cursor @p n tab-stops to the left. 
+     */
+    void backTabulate(int n);
+    
+    // Editing
+    
+    /** 
+     * Erase @p n characters beginning from the current cursor position. 
+     * This is equivalent to over-writing @p n characters starting with the current
+     * cursor position with spaces.
+     * If @p n is 0 then one character is erased. 
+     */
+    void eraseChars  (int n);
+    /** 
+     * Delete @p n characters beginning from the current cursor position. 
+     * If @p n is 0 then one character is deleted. 
+     */
+    void deleteChars (int n);
+    /**
+     * Insert @p n blank characters beginning from the current cursor position.
+     * The position of the cursor is not altered.  
+     * If @p n is 0 then one character is inserted.
+     */
+    void insertChars (int n);
+    /** 
+     * Removes @p n lines beginning from the current cursor position.
+     * The position of the cursor is not altered.
+     * If @p n is 0 then one line is removed.
+     */
+    void deleteLines (int n);
+    /**
+     * Inserts @p lines beginning from the current cursor position.
+     * The position of the cursor is not altered.
+     * If @p n is 0 then one line is inserted.
+     */
+    void insertLines (int n);
+    /** Clears all the tab stops. */
+    void clearTabStops();
+    /**  Sets or removes a tab stop at the cursor's current column. */ 
+    void changeTabStop(bool set);
+   
+    /** Resets (clears) the specified screen @p mode. */
+    void resetMode   (int mode);
+    /** Sets (enables) the specified screen @p mode. */
+    void setMode     (int mode);
+    /** 
+     * Saves the state of the specified screen @p mode.  It can be restored
+     * using restoreMode()
+     */
+    void saveMode    (int mode);
+    /** Restores the state of a screen @p mode saved by calling saveMode() */
+    void restoreMode (int mode);
+    /** Returns whether the specified screen @p mode is enabled or not .*/
+    bool getMode     (int mode) const;
+   
+    /** 
+     * Saves the current position and appearence (text color and style) of the cursor. 
+     * It can be restored by calling restoreCursor() 
+     */ 
+    void saveCursor  ();
+    /** Restores the position and appearence of the cursor.  See saveCursor() */
+    void restoreCursor();
+   
+    /** Clear the whole screen, moving the current screen contents into the history first. */ 
+    void clearEntireScreen();
+    /** 
+     * Clear the area of the screen from the current cursor position to the end of 
+     * the screen.
+     */
+    void clearToEndOfScreen();
+    /**
+     * Clear the area of the screen from the current cursor position to the start
+     * of the screen.
+     */
+    void clearToBeginOfScreen();
+    /** Clears the whole of the line on which the cursor is currently positioned. */
+    void clearEntireLine();
+    /** Clears from the current cursor position to the end of the line. */
+    void clearToEndOfLine();
+    /** Clears from the current cursor position to the beginning of the line. */
+    void clearToBeginOfLine();
+    
+    /** Fills the entire screen with the letter 'E' */
+    void helpAlign   ();
+       
+    /** 
+     * Enables the given @p rendition flag.  Rendition flags control the appearence 
+     * of characters on the screen.
+     *
+     * @see Character::rendition
+     */  
+    void setRendition  (int rendition);
+    /**
+     * Disables the given @p rendition flag.  Rendition flags control the appearence
+     * of characters on the screen.
+     *
+     * @see Character::rendition
+     */
+    void resetRendition(int rendition);
+    
+    /** 
+     * Sets the cursor's foreground color.
+     * @param space The color space used by the @p color argument
+     * @param color The new foreground color.  The meaning of this depends on
+     * the color @p space used.
+     *
+     * @see CharacterColor
+     */
+    void setForeColor  (int space, int color);
+    /**
+     * Sets the cursor's background color.
+     * @param space The color space used by the @p color argumnet.
+     * @param color The new background color.  The meaning of this depends on
+     * the color @p space used.
+     *
+     * @see CharacterColor
+     */
+    void setBackColor  (int space, int color);
+    /** 
+     * Resets the cursor's color back to the default and sets the 
+     * character's rendition flags back to the default settings.
+     */
+    void setDefaultRendition();
+    
+    /** Returns the column which the cursor is positioned at. */
+    int  getCursorX() const;
+    /** Returns the line which the cursor is positioned on. */
+    int  getCursorY() const;
+   
+	/** TODO Document me */ 
+	void clear();
+    /** 
+     * Sets the position of the cursor to the 'home' position at the top-left
+     * corner of the screen (0,0) 
+     */
+    void home();
+    /**
+     * Resets the state of the screen.  This resets the various screen modes
+     * back to their default states.  The cursor style and colors are reset
+     * (as if setDefaultRendition() had been called)
+     *
+     * <ul>
+     * <li>Line wrapping is enabled.</li>
+     * <li>Origin mode is disabled.</li>
+     * <li>Insert mode is disabled.</li>
+     * <li>Cursor mode is enabled.  TODO Document me</li>
+     * <li>Screen mode is disabled. TODO Document me</li>
+     * <li>New line mode is disabled.  TODO Document me</li>
+     * </ul>
+     *
+     * If @p clearScreen is true then the screen contents are erased entirely, 
+     * otherwise they are unaltered.
+     */
+    void reset(bool clearScreen = true);
+   
+    /** 
+     * Displays a new character at the current cursor position. 
+     * 
+     * If the cursor is currently positioned at the right-edge of the screen and
+     * line wrapping is enabled then the character is added at the start of a new 
+     * line below the current one.
+     *
+     * If the MODE_Insert screen mode is currently enabled then the character 
+     * is inserted at the current cursor position, otherwise it will replace the 
+     * character already at the current cursor position.  
+     */ 
+    void ShowCharacter(unsigned short c);
+    
+    // Do composition with last shown character FIXME: Not implemented yet for KDE 4
+    void compose(const QString& compose);
+    
+    /** 
+     * Resizes the image to a new fixed size of @p new_lines by @p new_columns.  
+     * In the case that @p new_columns is smaller than the current number of columns,
+     * existing lines are not truncated.  This prevents characters from being lost
+     * if the terminal display is resized smaller and then larger again.
+     *
+     * (note that in versions of Konsole prior to KDE 4, existing lines were
+     *  truncated when making the screen image smaller)
+     */
+    void resizeImage(int new_lines, int new_columns);
+    
+    /**
+     * Returns the current screen image.  
+     * The result is an array of Characters of size [getLines()][getColumns()] which
+     * must be freed by the caller after use.
+     *
+     * @param dest Buffer to copy the characters into
+     * @param size Size of @p dest in Characters
+     * @param startLine Index of first line to copy
+     * @param endLine Index of last line to copy
+     */
+    void getImage( Character* dest , int size , int startLine , int endLine ) const;
+
+    /** 
+     * Returns the additional attributes associated with lines in the image.
+     * The most important attribute is LINE_WRAPPED which specifies that the 
+     * line is wrapped,
+     * other attributes control the size of characters in the line.
+     */
+    QVector<LineProperty> getLineProperties( int startLine , int endLine ) const;
+	
+
+    /** Return the number of lines. */
+    int  getLines()   { return lines; }
+    /** Return the number of columns. */
+    int  getColumns() { return columns; }
+    /** Return the number of lines in the history buffer. */
+    int  getHistLines ();
+    /** 
+     * Sets the type of storage used to keep lines in the history. 
+     * If @p copyPreviousScroll is true then the contents of the previous 
+     * history buffer are copied into the new scroll.
+     */
+    void setScroll(const HistoryType& , bool copyPreviousScroll = true);
+    /** Returns the type of storage used to keep lines in the history. */
+    const HistoryType& getScroll();
+    /** 
+     * Returns true if this screen keeps lines that are scrolled off the screen
+     * in a history buffer.
+     */
+    bool hasScroll();
+
+    /** 
+     * Sets the start of the selection.
+     *
+     * @param column The column index of the first character in the selection.
+     * @param line The line index of the first character in the selection.
+     * @param columnmode True if the selection is in column mode.
+     */
+    void setSelectionStart(const int column, const int line, const bool columnmode);
+    
+    /**
+     * Sets the end of the current selection.
+     *
+     * @param column The column index of the last character in the selection.
+     * @param line The line index of the last character in the selection. 
+     */ 
+    void setSelectionEnd(const int column, const int line);
+   
+    /**
+     * Retrieves the start of the selection or the cursor position if there
+     * is no selection.
+     */
+    void getSelectionStart(int& column , int& line);
+    
+    /**
+     * Retrieves the end of the selection or the cursor position if there
+     * is no selection.
+     */
+    void getSelectionEnd(int& column , int& line);
+
+    /** Clears the current selection */
+    void clearSelection();
+
+    void setBusySelecting(bool busy) { sel_busy = busy; }
+
+    /** 
+ 	 * 	Returns true if the character at (@p column, @p line) is part of the
+ 	 *  current selection. 
+ 	 */ 
+    bool isSelected(const int column,const int line) const;
+
+    /** 
+     * Convenience method.  Returns the currently selected text. 
+     * @param preserveLineBreaks Specifies whether new line characters should 
+     * be inserted into the returned text at the end of each terminal line.
+     */
+    QString selectedText(bool preserveLineBreaks);
+	    
+	/**
+	 * Copies part of the output to a stream.
+	 *
+	 * @param decoder A decoder which coverts terminal characters into text
+	 * @param from The first line in the history to retrieve
+	 * @param to The last line in the history to retrieve
+	 */
+	void writeToStream(TerminalCharacterDecoder* decoder, int from, int to);
+
+    /** 
+     * Sets the selection to line @p no in the history and returns
+     * the text of that line from the history buffer.
+     */
+    QString getHistoryLine(int no);
+
+	/**
+	 * Copies the selected characters, set using @see setSelBeginXY and @see setSelExtentXY
+	 * into a stream.
+	 *
+	 * @param decoder A decoder which converts terminal characters into text.  
+	 * PlainTextDecoder is the most commonly used decoder which coverts characters 
+	 * into plain text with no formatting.
+     * @param preserveLineBreaks Specifies whether new line characters should 
+     * be inserted into the returned text at the end of each terminal line. 
+	 */
+	void writeSelectionToStream(TerminalCharacterDecoder* decoder , bool
+                                preserveLineBreaks = true);
+
+    /** TODO Document me */
+    void checkSelection(int from, int to);
+
+	/** 
+	 * Sets or clears an attribute of the current line.
+	 * 
+	 * @param property The attribute to set or clear
+	 * Possible properties are:
+	 * LINE_WRAPPED:	 Specifies that the line is wrapped.
+	 * LINE_DOUBLEWIDTH: Specifies that the characters in the current line should be double the normal width.
+	 * LINE_DOUBLEHEIGHT:Specifies that the characters in the current line should be double the normal height.
+     *                   Double-height lines are formed of two lines containing the same characters,
+     *                   with both having the LINE_DOUBLEHEIGHT attribute.  This allows other parts of the 
+     *                   code to work on the assumption that all lines are the same height.
+	 *
+	 * @param enable true to apply the attribute to the current line or false to remove it
+	 */
+	void setLineProperty(LineProperty property , bool enable);
+
+
+    /** 
+     * Returns the number of lines that the image has been scrolled up or down by,
+     * since the last call to resetScrolledLines().
+     *
+     * a positive return value indicates that the image has been scrolled up,
+     * a negative return value indicates that the image has been scrolled down. 
+     */
+    int scrolledLines() const;
+
+    /**
+     * Returns the region of the image which was last scrolled.
+     *
+     * This is the area of the image from the top margin to the 
+     * bottom margin when the last scroll occurred.
+     */
+    QRect lastScrolledRegion() const;
+
+    /** 
+     * Resets the count of the number of lines that the image has been scrolled up or down by,
+     * see scrolledLines()
+     */
+    void resetScrolledLines();
+
+    /**
+     * Returns the number of lines of output which have been
+     * dropped from the history since the last call
+     * to resetDroppedLines()
+     *
+     * If the history is not unlimited then it will drop
+     * the oldest lines of output if new lines are added when
+     * it is full.  
+     */
+    int droppedLines() const;
+
+    /**
+     * Resets the count of the number of lines dropped from
+     * the history.
+     */
+    void resetDroppedLines();
+
+	/** 
+ 	 * Fills the buffer @p dest with @p count instances of the default (ie. blank)
+ 	 * Character style.
+ 	 */
+	static void fillWithDefaultChar(Character* dest, int count);
+
+private: 
+
+	//copies a line of text from the screen or history into a stream using a 
+	//specified character decoder
+	//line - the line number to copy, from 0 (the earliest line in the history) up to 
+	//		 hist->getLines() + lines - 1
+	//start - the first column on the line to copy
+	//count - the number of characters on the line to copy
+	//decoder - a decoder which coverts terminal characters (an Character array) into text
+    //appendNewLine - if true a new line character (\n) is appended to the end of the line
+	void copyLineToStream(int line, 
+                          int start, 
+                          int count, 
+                          TerminalCharacterDecoder* decoder,
+                          bool appendNewLine,
+                          bool preserveLineBreaks);
+	
+    //fills a section of the screen image with the character 'c'
+    //the parameters are specified as offsets from the start of the screen image.
+    //the loc(x,y) macro can be used to generate these values from a column,line pair.
+    void clearImage(int loca, int loce, char c);
+
+    //move screen image between 'sourceBegin' and 'sourceEnd' to 'dest'.
+    //the parameters are specified as offsets from the start of the screen image.
+    //the loc(x,y) macro can be used to generate these values from a column,line pair.
+    void moveImage(int dest, int sourceBegin, int sourceEnd);
+    
+    void scrollUp(int from, int i);
+    void scrollDown(int from, int i);
+
+    void addHistLine();
+
+    void initTabStops();
+
+    void effectiveRendition();
+    void reverseRendition(Character& p) const;
+
+    bool isSelectionValid() const;
+
+	// copies 'count' lines from the screen buffer into 'dest',
+	// starting from 'startLine', where 0 is the first line in the screen buffer
+	void copyFromScreen(Character* dest, int startLine, int count) const;
+	// copies 'count' lines from the history buffer into 'dest',
+	// starting from 'startLine', where 0 is the first line in the history
+	void copyFromHistory(Character* dest, int startLine, int count) const;
+
+
+    // screen image ----------------
+    int lines;
+    int columns;
+
+    typedef QVector<Character> ImageLine;      // [0..columns]
+    ImageLine*          screenLines;    // [lines]
+
+    int _scrolledLines;
+    QRect _lastScrolledRegion;
+
+    int _droppedLines;
+
+    QVarLengthArray<LineProperty,64> lineProperties;    
+	
+    // history buffer ---------------
+    HistoryScroll *hist;
+    
+    // cursor location
+    int cuX;
+    int cuY;
+
+    // cursor color and rendition info
+    CharacterColor cu_fg;      // foreground
+    CharacterColor cu_bg;      // background
+    quint8 cu_re;      // rendition
+
+    // margins ----------------
+    int tmargin;      // top margin
+    int bmargin;      // bottom margin
+
+    // states ----------------
+    ScreenParm currParm;
+
+    // ----------------------------
+
+    bool* tabstops;
+
+    // selection -------------------
+    int sel_begin; // The first location selected.
+    int sel_TL;    // TopLeft Location.
+    int sel_BR;    // Bottom Right Location.
+    bool sel_busy; // Busy making a selection.
+    bool columnmode;  // Column selection mode
+
+    // effective colors and rendition ------------
+    CharacterColor ef_fg;      // These are derived from
+    CharacterColor ef_bg;      // the cu_* variables above
+    quint8 ef_re;      // to speed up operation
+
+    //
+    // save cursor, rendition & states ------------
+    // 
+
+    // cursor location
+    int sa_cuX;
+    int sa_cuY;
+
+    // rendition info
+    quint8 sa_cu_re;
+    CharacterColor sa_cu_fg;
+    CharacterColor sa_cu_bg;
+    
+    // last position where we added a character
+    int lastPos;
+
+    // modes
+    ScreenParm saveParm;
+
+    static Character defaultChar;
+};
+
+#endif // SCREEN_H
diff --git a/libgui/qterminal/libqterminal/unix/ScreenWindow.cpp b/libgui/qterminal/libqterminal/unix/ScreenWindow.cpp
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/ScreenWindow.cpp
@@ -0,0 +1,294 @@
+/*
+    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+// Own
+#include "unix/ScreenWindow.h"
+
+// Qt
+#include <QtCore>
+
+// Konsole
+#include "unix/Screen.h"
+
+ScreenWindow::ScreenWindow(QObject* parent)
+    : QObject(parent)
+	, _windowBuffer(0)
+	, _windowBufferSize(0)
+	, _bufferNeedsUpdate(true)
+	, _windowLines(1)
+    , _currentLine(0)
+    , _trackOutput(true)
+    , _scrollCount(0)
+{
+}
+
+ScreenWindow::~ScreenWindow()
+{
+	delete[] _windowBuffer;
+}
+void ScreenWindow::setScreen(Screen* screen)
+{
+    Q_ASSERT( screen );
+
+    _screen = screen;
+}
+
+Screen* ScreenWindow::screen() const
+{
+    return _screen;
+}
+
+Character* ScreenWindow::getImage()
+{
+	// reallocate internal buffer if the window size has changed
+	int size = windowLines() * windowColumns();
+	if (_windowBuffer == 0 || _windowBufferSize != size) 
+	{
+		delete[] _windowBuffer;
+		_windowBufferSize = size;
+		_windowBuffer = new Character[size];
+		_bufferNeedsUpdate = true;
+	}
+
+	 if (!_bufferNeedsUpdate)
+		return _windowBuffer;
+ 
+	_screen->getImage(_windowBuffer,size,
+					  currentLine(),endWindowLine());
+
+	// this window may look beyond the end of the screen, in which 
+	// case there will be an unused area which needs to be filled
+	// with blank characters
+	fillUnusedArea();
+
+	_bufferNeedsUpdate = false;
+	return _windowBuffer;
+}
+
+void ScreenWindow::fillUnusedArea()
+{
+	int screenEndLine = _screen->getHistLines() + _screen->getLines() - 1;
+	int windowEndLine = currentLine() + windowLines() - 1;
+
+	int unusedLines = windowEndLine - screenEndLine;
+	int charsToFill = unusedLines * windowColumns();
+
+	Screen::fillWithDefaultChar(_windowBuffer + _windowBufferSize - charsToFill,charsToFill); 
+}
+
+// return the index of the line at the end of this window, or if this window 
+// goes beyond the end of the screen, the index of the line at the end
+// of the screen.
+//
+// when passing a line number to a Screen method, the line number should
+// never be more than endWindowLine()
+//
+int ScreenWindow::endWindowLine() const
+{
+	return qMin(currentLine() + windowLines() - 1,
+				lineCount() - 1);
+}
+QVector<LineProperty> ScreenWindow::getLineProperties()
+{
+    QVector<LineProperty> result = _screen->getLineProperties(currentLine(),endWindowLine());
+	
+	if (result.count() != windowLines())
+		result.resize(windowLines());
+
+	return result;
+}
+
+QString ScreenWindow::selectedText( bool preserveLineBreaks ) const
+{
+    return _screen->selectedText( preserveLineBreaks );
+}
+
+void ScreenWindow::getSelectionStart( int& column , int& line )
+{
+    _screen->getSelectionStart(column,line);
+    line -= currentLine();
+}
+void ScreenWindow::getSelectionEnd( int& column , int& line )
+{
+    _screen->getSelectionEnd(column,line);
+    line -= currentLine();
+}
+void ScreenWindow::setSelectionStart( int column , int line , bool columnMode )
+{
+    _screen->setSelectionStart( column , qMin(line + currentLine(),endWindowLine())  , columnMode);
+	
+	_bufferNeedsUpdate = true;
+    emit selectionChanged();
+}
+
+void ScreenWindow::setSelectionEnd( int column , int line )
+{
+    _screen->setSelectionEnd( column , qMin(line + currentLine(),endWindowLine()) );
+
+	_bufferNeedsUpdate = true;
+    emit selectionChanged();
+}
+
+bool ScreenWindow::isSelected( int column , int line )
+{
+    return _screen->isSelected( column , qMin(line + currentLine(),endWindowLine()) );
+}
+
+void ScreenWindow::clearSelection()
+{
+    _screen->clearSelection();
+
+    emit selectionChanged();
+}
+
+void ScreenWindow::setWindowLines(int lines)
+{
+	Q_ASSERT(lines > 0);
+	_windowLines = lines;
+}
+int ScreenWindow::windowLines() const
+{
+	return _windowLines;		
+}
+
+int ScreenWindow::windowColumns() const
+{
+    return _screen->getColumns();
+}
+
+int ScreenWindow::lineCount() const
+{
+    return _screen->getHistLines() + _screen->getLines();
+}
+
+int ScreenWindow::columnCount() const
+{
+    return _screen->getColumns();
+}
+
+QPoint ScreenWindow::cursorPosition() const
+{
+    QPoint position;
+    
+    position.setX( _screen->getCursorX() );
+    position.setY( _screen->getCursorY() );
+
+    return position; 
+}
+
+int ScreenWindow::currentLine() const
+{
+    return qBound(0,_currentLine,lineCount()-windowLines());
+}
+
+void ScreenWindow::scrollBy( RelativeScrollMode mode , int amount )
+{
+    if ( mode == ScrollLines )
+    {
+        scrollTo( currentLine() + amount );
+    }
+    else if ( mode == ScrollPages )
+    {
+        scrollTo( currentLine() + amount * ( windowLines() / 2 ) ); 
+    }
+}
+
+bool ScreenWindow::atEndOfOutput() const
+{
+    return currentLine() == (lineCount()-windowLines());
+}
+
+void ScreenWindow::scrollTo( int line )
+{
+	int maxCurrentLineNumber = lineCount() - windowLines();
+	line = qBound(0,line,maxCurrentLineNumber);
+
+    const int delta = line - _currentLine;
+    _currentLine = line;
+
+    // keep track of number of lines scrolled by,
+    // this can be reset by calling resetScrollCount()
+    _scrollCount += delta;
+
+    _bufferNeedsUpdate = true;
+
+    emit scrolled(_currentLine);
+}
+
+void ScreenWindow::setTrackOutput(bool trackOutput)
+{
+    _trackOutput = trackOutput;
+}
+
+bool ScreenWindow::trackOutput() const
+{
+    return _trackOutput;
+}
+
+int ScreenWindow::scrollCount() const
+{
+    return _scrollCount;
+}
+
+void ScreenWindow::resetScrollCount() 
+{
+    _scrollCount = 0;
+}
+
+QRect ScreenWindow::scrollRegion() const
+{
+	bool equalToScreenSize = windowLines() == _screen->getLines();
+
+	if ( atEndOfOutput() && equalToScreenSize )
+    	return _screen->lastScrolledRegion();
+	else
+		return QRect(0,0,windowColumns(),windowLines());
+}
+
+void ScreenWindow::notifyOutputChanged()
+{
+    // move window to the bottom of the screen and update scroll count
+    // if this window is currently tracking the bottom of the screen
+    if ( _trackOutput )
+    { 
+        _scrollCount -= _screen->scrolledLines();
+        _currentLine = qMax(0,_screen->getHistLines() - (windowLines()-_screen->getLines()));
+    }
+    else
+    {
+        // if the history is not unlimited then it may 
+        // have run out of space and dropped the oldest
+        // lines of output - in this case the screen
+        // window's current line number will need to 
+        // be adjusted - otherwise the output will scroll
+        _currentLine = qMax(0,_currentLine - 
+                              _screen->droppedLines());
+
+        // ensure that the screen window's current position does
+        // not go beyond the bottom of the screen
+        _currentLine = qMin( _currentLine , _screen->getHistLines() );
+    }
+
+	_bufferNeedsUpdate = true;
+
+    emit outputChanged(); 
+}
+
diff --git a/libgui/qterminal/libqterminal/unix/ScreenWindow.h b/libgui/qterminal/libqterminal/unix/ScreenWindow.h
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/ScreenWindow.h
@@ -0,0 +1,252 @@
+/*
+    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef SCREENWINDOW_H
+#define SCREENWINDOW_H
+
+// Qt
+#include <QtCore/QObject>
+#include <QtCore/QPoint>
+#include <QtCore/QRect>
+
+// Konsole
+#include "unix/Character.h"
+
+class Screen;
+
+/**
+ * Provides a window onto a section of a terminal screen.
+ * This window can then be rendered by a terminal display widget ( TerminalDisplay ).
+ *
+ * To use the screen window, create a new ScreenWindow() instance and associated it with 
+ * a terminal screen using setScreen().
+ * Use the scrollTo() method to scroll the window up and down on the screen.
+ * Call the getImage() method to retrieve the character image which is currently visible in the window.
+ *
+ * setTrackOutput() controls whether the window moves to the bottom of the associated screen when new
+ * lines are added to it.
+ *
+ * Whenever the output from the underlying screen is changed, the notifyOutputChanged() slot should
+ * be called.  This in turn will update the window's position and emit the outputChanged() signal
+ * if necessary.
+ */
+class ScreenWindow : public QObject
+{
+Q_OBJECT
+
+public:
+    /** 
+     * Constructs a new screen window with the given parent.
+     * A screen must be specified by calling setScreen() before calling getImage() or getLineProperties().
+     *
+     * You should not call this constructor directly, instead use the Emulation::createWindow() method
+     * to create a window on the emulation which you wish to view.  This allows the emulation
+     * to notify the window when the associated screen has changed and synchronize selection updates
+     * between all views on a session.
+     */
+    ScreenWindow(QObject* parent = 0);
+	virtual ~ScreenWindow();
+
+    /** Sets the screen which this window looks onto */
+    void setScreen(Screen* screen);
+    /** Returns the screen which this window looks onto */
+    Screen* screen() const;
+
+    /** 
+     * Returns the image of characters which are currently visible through this window
+     * onto the screen.
+     *
+     * The buffer is managed by the ScreenWindow instance and does not need to be
+     * deleted by the caller.
+     */
+    Character* getImage();
+
+    /**
+     * Returns the line attributes associated with the lines of characters which
+     * are currently visible through this window
+     */
+    QVector<LineProperty> getLineProperties();
+
+    /**
+     * Returns the number of lines which the region of the window
+     * specified by scrollRegion() has been scrolled by since the last call 
+     * to resetScrollCount().  scrollRegion() is in most cases the 
+     * whole window, but will be a smaller area in, for example, applications
+     * which provide split-screen facilities.
+     *
+     * This is not guaranteed to be accurate, but allows views to optimise
+     * rendering by reducing the amount of costly text rendering that
+     * needs to be done when the output is scrolled. 
+     */
+    int scrollCount() const;
+
+    /**
+     * Resets the count of scrolled lines returned by scrollCount()
+     */
+    void resetScrollCount();
+
+    /**
+     * Returns the area of the window which was last scrolled, this is 
+     * usually the whole window area.
+     *
+     * Like scrollCount(), this is not guaranteed to be accurate,
+     * but allows views to optimise rendering.
+     */
+    QRect scrollRegion() const;
+
+    /** 
+     * Sets the start of the selection to the given @p line and @p column within 
+     * the window.
+     */
+    void setSelectionStart( int column , int line , bool columnMode );
+    /**
+     * Sets the end of the selection to the given @p line and @p column within
+     * the window.
+     */
+    void setSelectionEnd( int column , int line ); 
+    /**
+     * Retrieves the start of the selection within the window.
+     */
+    void getSelectionStart( int& column , int& line );
+    /**
+     * Retrieves the end of the selection within the window.
+     */
+    void getSelectionEnd( int& column , int& line );
+    /**
+     * Returns true if the character at @p line , @p column is part of the selection.
+     */
+    bool isSelected( int column , int line );
+    /** 
+     * Clears the current selection
+     */
+    void clearSelection();
+
+	/** Sets the number of lines in the window */
+	void setWindowLines(int lines);
+    /** Returns the number of lines in the window */
+    int windowLines() const;
+    /** Returns the number of columns in the window */
+    int windowColumns() const;
+    
+    /** Returns the total number of lines in the screen */
+    int lineCount() const;
+    /** Returns the total number of columns in the screen */
+    int columnCount() const;
+
+    /** Returns the index of the line which is currently at the top of this window */
+    int currentLine() const;
+
+    /** 
+     * Returns the position of the cursor 
+     * within the window.
+     */
+    QPoint cursorPosition() const;
+
+    /** 
+     * Convenience method. Returns true if the window is currently at the bottom
+     * of the screen.
+     */
+    bool atEndOfOutput() const;
+
+    /** Scrolls the window so that @p line is at the top of the window */
+    void scrollTo( int line );
+
+    enum RelativeScrollMode
+    {
+        ScrollLines,
+        ScrollPages
+    };
+
+    /** 
+     * Scrolls the window relative to its current position on the screen.
+     *
+     * @param mode Specifies whether @p amount refers to the number of lines or the number
+     * of pages to scroll.    
+     * @param amount The number of lines or pages ( depending on @p mode ) to scroll by.  If
+     * this number is positive, the view is scrolled down.  If this number is negative, the view
+     * is scrolled up.
+     */
+    void scrollBy( RelativeScrollMode mode , int amount );
+
+    /** 
+     * Specifies whether the window should automatically move to the bottom
+     * of the screen when new output is added.
+     *
+     * If this is set to true, the window will be moved to the bottom of the associated screen ( see 
+     * screen() ) when the notifyOutputChanged() method is called.
+     */
+    void setTrackOutput(bool trackOutput);
+    /** 
+     * Returns whether the window automatically moves to the bottom of the screen as
+     * new output is added.  See setTrackOutput()
+     */
+    bool trackOutput() const;
+
+    /**
+     * Returns the text which is currently selected.
+     *
+     * @param preserveLineBreaks See Screen::selectedText()
+     */
+    QString selectedText( bool preserveLineBreaks ) const;
+
+public slots:
+    /** 
+     * Notifies the window that the contents of the associated terminal screen have changed.
+     * This moves the window to the bottom of the screen if trackOutput() is true and causes
+     * the outputChanged() signal to be emitted.
+     */
+    void notifyOutputChanged();
+
+signals:
+    /**
+     * Emitted when the contents of the associated terminal screen ( see screen() ) changes. 
+     */
+    void outputChanged();
+
+    /**
+     * Emitted when the screen window is scrolled to a different position.
+     * 
+     * @param line The line which is now at the top of the window.
+     */
+    void scrolled(int line);
+
+    /**
+     * Emitted when the selection is changed.
+     */
+    void selectionChanged();
+
+private:
+	int endWindowLine() const;
+	void fillUnusedArea();
+
+    Screen* _screen; // see setScreen() , screen()
+	Character* _windowBuffer;
+	int _windowBufferSize;
+	bool _bufferNeedsUpdate;
+
+	int  _windowLines;
+    int  _currentLine; // see scrollTo() , currentLine()
+    bool _trackOutput; // see setTrackOutput() , trackOutput() 
+    int  _scrollCount; // count of lines which the window has been scrolled by since
+                       // the last call to resetScrollCount()
+};
+
+#endif // SCREENWINDOW_H
diff --git a/libgui/qterminal/libqterminal/unix/SelfListener.cpp b/libgui/qterminal/libqterminal/unix/SelfListener.cpp
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/SelfListener.cpp
@@ -0,0 +1,38 @@
+/* qterminal - a terminal widget for Qt
+ * Copyright (C) 2011 Jacob Dawid (jacob.dawid@googlemail.com)
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "unix/SelfListener.h"
+
+SelfListener::SelfListener(int a, QObject *parent) :
+    QThread(parent) {
+    _a = a;
+}
+
+void SelfListener::run() {
+    char buf[4096];
+    int len;
+    bool running = true;
+    while(running) {
+         while((len = ::read(_a, buf, 4096)) > 0) {
+            buf[len] = 0; // Just in case.
+            emit recvData(buf, len);
+            msleep(30);
+         }
+         if(len < 0)
+           running = false;
+    }
+}
diff --git a/libgui/qterminal/libqterminal/unix/SelfListener.h b/libgui/qterminal/libqterminal/unix/SelfListener.h
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/SelfListener.h
@@ -0,0 +1,40 @@
+/* qterminal - a terminal widget for Qt
+ * Copyright (C) 2011 Jacob Dawid (jacob.dawid@googlemail.com)
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, either version 3 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef SELFLISTENER_H
+#define SELFLISTENER_H
+
+#include <QThread>
+#include <unistd.h>
+
+class SelfListener : public QThread
+{
+    Q_OBJECT
+public:
+    explicit SelfListener(int a, QObject *parent = 0);
+
+signals:
+    void recvData(const char* stdOutBuffer, int stdOutlen);
+
+public slots:
+
+protected:
+    void run();
+    int _a;
+};
+
+#endif // SELFLISTENER_H
diff --git a/libgui/qterminal/libqterminal/unix/TerminalCharacterDecoder.cpp b/libgui/qterminal/libqterminal/unix/TerminalCharacterDecoder.cpp
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/TerminalCharacterDecoder.cpp
@@ -0,0 +1,224 @@
+/*
+    This file is part of Konsole, an X terminal.
+    
+    Copyright (C) 2006 by Robert Knight <robertknight@gmail.com>
+    
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+// Own
+#include "unix/TerminalCharacterDecoder.h"
+
+// Qt
+#include <QtCore/QTextStream>
+
+PlainTextDecoder::PlainTextDecoder()
+ : _output(0)
+ , _includeTrailingWhitespace(true)
+{
+
+}
+void PlainTextDecoder::setTrailingWhitespace(bool enable)
+{
+    _includeTrailingWhitespace = enable;
+}
+bool PlainTextDecoder::trailingWhitespace() const
+{
+    return _includeTrailingWhitespace;
+}
+void PlainTextDecoder::begin(QTextStream* output)
+{
+   _output = output; 
+}
+void PlainTextDecoder::end()
+{
+    _output = 0;
+}
+void PlainTextDecoder::decodeLine(const Character* const characters, int count, LineProperty /*properties*/
+							 )
+{
+    Q_ASSERT( _output );
+
+	//TODO should we ignore or respect the LINE_WRAPPED line property?
+
+	//note:  we build up a QString and send it to the text stream rather writing into the text
+	//stream a character at a time because it is more efficient.
+	//(since QTextStream always deals with QStrings internally anyway)
+	QString plainText;
+	plainText.reserve(count);
+   
+    int outputCount = count;
+
+    // if inclusion of trailing whitespace is disabled then find the end of the
+    // line
+    if ( !_includeTrailingWhitespace )
+    {
+        for (int i = count-1 ; i >= 0 ; i--)
+        {
+            if ( characters[i].character != ' '  )
+                break;
+            else
+                outputCount--;
+        }
+    }
+
+	for (int i=0;i<outputCount;i++)
+	{
+		plainText.append( QChar(characters[i].character) );
+	}
+
+	*_output << plainText;
+}
+
+HTMLDecoder::HTMLDecoder() :
+        _output(0)
+	   ,_colorTable(base_color_table)
+       ,_innerSpanOpen(false)
+       ,_lastRendition(DEFAULT_RENDITION)
+{
+	
+}
+
+void HTMLDecoder::begin(QTextStream* output)
+{
+    _output = output;
+
+    QString text;
+
+	//open monospace span
+    openSpan(text,"font-family:monospace");
+
+    *output << text;
+}
+
+void HTMLDecoder::end()
+{
+    Q_ASSERT( _output );
+
+    QString text;
+
+    closeSpan(text);
+
+    *_output << text;
+
+    _output = 0;
+
+}
+
+//TODO: Support for LineProperty (mainly double width , double height)
+void HTMLDecoder::decodeLine(const Character* const characters, int count, LineProperty /*properties*/
+							)
+{
+    Q_ASSERT( _output );
+
+	QString text;
+
+	int spaceCount = 0;
+		
+	for (int i=0;i<count;i++)
+	{
+		QChar ch(characters[i].character);
+
+		//check if appearance of character is different from previous char
+		if ( characters[i].rendition != _lastRendition  ||
+		     characters[i].foregroundColor != _lastForeColor  ||
+			 characters[i].backgroundColor != _lastBackColor )
+		{
+			if ( _innerSpanOpen )
+					closeSpan(text);
+
+			_lastRendition = characters[i].rendition;
+			_lastForeColor = characters[i].foregroundColor;
+			_lastBackColor = characters[i].backgroundColor;
+			
+			//build up style string
+			QString style;
+
+			if ( _lastRendition & RE_BOLD ||
+                             (_colorTable && characters[i].isBold(_colorTable)) )
+					style.append("font-weight:bold;");
+
+
+			if ( _lastRendition & RE_UNDERLINE )
+					style.append("font-decoration:underline;");
+		
+			//colours - a colour table must have been defined first
+			if ( _colorTable )	
+			{
+				style.append( QString("color:%1;").arg(_lastForeColor.color(_colorTable).name() ) );
+
+				if (!characters[i].isTransparent(_colorTable))
+				{
+					style.append( QString("background-color:%1;").arg(_lastBackColor.color(_colorTable).name() ) );
+				}
+			}
+		
+			//open the span with the current style	
+			openSpan(text,style);
+			_innerSpanOpen = true;
+		}
+
+		//handle whitespace
+		if (ch.isSpace())
+			spaceCount++;
+		else
+			spaceCount = 0;
+		
+
+		//output current character
+		if (spaceCount < 2)
+		{
+			//escape HTML tag characters and just display others as they are
+			if ( ch == '<' )
+				text.append("&lt;");
+			else if (ch == '>')
+					text.append("&gt;");
+			else	
+					text.append(ch);
+		}
+		else
+		{
+			text.append("&nbsp;"); //HTML truncates multiple spaces, so use a space marker instead
+		}
+		
+	}
+
+	//close any remaining open inner spans
+	if ( _innerSpanOpen )
+		closeSpan(text);
+
+	//start new line
+	text.append("<br>");
+	
+	*_output << text;
+}
+
+void HTMLDecoder::openSpan(QString& text , const QString& style)
+{
+	text.append( QString("<span style=\"%1\">").arg(style) );
+}
+
+void HTMLDecoder::closeSpan(QString& text)
+{
+	text.append("</span>");
+}
+
+void HTMLDecoder::setColorTable(const ColorEntry* table)
+{
+	_colorTable = table;
+}
diff --git a/libgui/qterminal/libqterminal/unix/TerminalCharacterDecoder.h b/libgui/qterminal/libqterminal/unix/TerminalCharacterDecoder.h
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/TerminalCharacterDecoder.h
@@ -0,0 +1,134 @@
+/*
+    This file is part of Konsole, an X terminal.
+    
+    Copyright (C) 2006-7 by Robert Knight <robertknight@gmail.com>
+    
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU Lesser General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef TERMINAL_CHARACTER_DECODER_H
+#define TERMINAL_CHARACTER_DECODER_H
+
+#include "unix/Character.h"
+
+class QTextStream;
+
+/**
+ * Base class for terminal character decoders
+ *
+ * The decoder converts lines of terminal characters which consist of a unicode character, foreground
+ * and background colours and other appearance-related properties into text strings.
+ *
+ * Derived classes may produce either plain text with no other colour or appearance information, or
+ * they may produce text which incorporates these additional properties. 
+ */
+class TerminalCharacterDecoder
+{
+public:
+	virtual ~TerminalCharacterDecoder() {}
+
+    /** Begin decoding characters.  The resulting text is appended to @p output. */
+    virtual void begin(QTextStream* output) = 0;
+    /** End decoding. */
+    virtual void end() = 0;
+
+	/**
+	 * Converts a line of terminal characters with associated properties into a text string
+	 * and writes the string into an output QTextStream.
+	 *
+	 * @param characters An array of characters of length @p count.
+	 * @param properties Additional properties which affect all characters in the line
+	 * @param output The output stream which receives the decoded text
+	 */
+	virtual void decodeLine(const Character* const characters, 
+							int count,
+							LineProperty properties) = 0; 
+};
+
+/**
+ * A terminal character decoder which produces plain text, ignoring colours and other appearance-related
+ * properties of the original characters.
+ */
+class PlainTextDecoder : public TerminalCharacterDecoder
+{
+public:
+	PlainTextDecoder(); 
+
+    /** 
+     * Set whether trailing whitespace at the end of lines should be included 
+     * in the output.
+     * Defaults to true.
+     */
+    void setTrailingWhitespace(bool enable);
+    /**
+     * Returns whether trailing whitespace at the end of lines is included
+     * in the output.
+     */
+    bool trailingWhitespace() const;
+
+    virtual void begin(QTextStream* output);
+    virtual void end();
+
+	virtual void decodeLine(const Character* const characters,
+							int count,
+							LineProperty properties);	
+
+    
+private:
+    QTextStream* _output;
+    bool _includeTrailingWhitespace;
+};
+
+/**
+ * A terminal character decoder which produces pretty HTML markup
+ */
+class HTMLDecoder : public TerminalCharacterDecoder
+{
+public:
+	/** 
+	 * Constructs an HTML decoder using a default black-on-white color scheme.
+	 */
+	HTMLDecoder();
+
+	/**
+	 * Sets the colour table which the decoder uses to produce the HTML colour codes in its
+	 * output
+	 */
+	void setColorTable( const ColorEntry* table );
+		
+	virtual void decodeLine(const Character* const characters,
+							int count,
+							LineProperty properties);
+
+    virtual void begin(QTextStream* output);
+    virtual void end();
+
+private:
+	void openSpan(QString& text , const QString& style);
+	void closeSpan(QString& text);
+
+    QTextStream* _output;
+	const ColorEntry* _colorTable;
+    bool _innerSpanOpen; 
+	quint8 _lastRendition;
+	CharacterColor _lastForeColor;
+	CharacterColor _lastBackColor;
+
+};
+
+#endif
diff --git a/libgui/qterminal/libqterminal/unix/TerminalModel.cpp b/libgui/qterminal/libqterminal/unix/TerminalModel.cpp
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/TerminalModel.cpp
@@ -0,0 +1,414 @@
+/*
+    This file is part of Konsole
+
+    Copyright (C) 2006-2007 by Robert Knight <robertknight@gmail.com>
+    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+    Copyright (C) 2012 Jacob Dawid <jacob.dawid@googlemail.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+// Own
+#include "unix/TerminalModel.h"
+
+// Standard
+#include <assert.h>
+#include <stdlib.h>
+
+// Qt
+#include <QtGui/QApplication>
+#include <QtCore/QByteRef>
+#include <QtCore/QDir>
+#include <QtCore/QFile>
+#include <QtCore/QRegExp>
+#include <QtCore/QStringList>
+#include <QtCore>
+
+#include "unix/TerminalView.h"
+#include "unix/Vt102Emulation.h"
+
+TerminalModel::TerminalModel(KPty *kpty) :
+    _shellProcess(0)
+  , _emulation(0)
+  , _monitorActivity(false)
+  , _monitorSilence(false)
+  , _notifiedActivity(false)
+  , _autoClose(true)
+  , _wantedClose(false)
+  , _silenceSeconds(10)
+  , _addToUtmp(false)
+  , _fullScripting(false)
+  , _hasDarkBackground(false)
+{
+    _kpty = kpty;
+
+    //create emulation backend
+    _emulation = new Vt102Emulation();
+    connect( _emulation, SIGNAL( stateSet(int) ),
+             this, SLOT( activityStateSet(int) ) );
+    connect( _emulation, SIGNAL( changeTabTextColorRequest( int ) ),
+             this, SIGNAL( changeTabTextColorRequest( int ) ) );
+    connect( _emulation, SIGNAL(profileChangeCommandReceived(const QString&)),
+             this, SIGNAL( profileChangeCommandReceived(const QString&)) );
+    // TODO
+    // connect( _emulation,SIGNAL(imageSizeChanged(int,int)) , this ,
+    //        SLOT(onEmulationSizeChange(int,int)) );
+
+    _selfListener = new SelfListener(kpty->masterFd());
+    _selfListener->start();
+    connect( _selfListener, SIGNAL(recvData(const char*,int)),
+             this, SLOT(onReceiveBlock(const char*,int)), Qt::BlockingQueuedConnection);
+
+    connect( _emulation, SIGNAL(sendData(const char*,int))
+             ,this,SLOT(sendData(const char*,int)));
+
+    //connect( _emulation,SIGNAL(lockPtyRequest(bool)),_shellProcess,SLOT(lockPty(bool)) );
+    //connect( _emulation,SIGNAL(useUtf8Request(bool)),_shellProcess,SLOT(setUtf8Mode(bool)) );
+
+
+    //connect( _shellProcess,SIGNAL(done(int)), this, SLOT(done(int)) );
+
+    //setup timer for monitoring session activity
+    _monitorTimer = new QTimer(this);
+    _monitorTimer->setSingleShot(true);
+    connect(_monitorTimer, SIGNAL(timeout()), this, SLOT(monitorTimerDone()));
+}
+
+void TerminalModel::setDarkBackground(bool darkBackground)
+{
+    _hasDarkBackground = darkBackground;
+}
+bool TerminalModel::hasDarkBackground() const
+{
+    return _hasDarkBackground;
+}
+
+void TerminalModel::setCodec(QTextCodec* codec)
+{
+    emulation()->setCodec(codec);
+}
+
+QList<TerminalView*> TerminalModel::views() const
+{
+    return _views;
+}
+
+void TerminalModel::addView(TerminalView* widget)
+{
+    Q_ASSERT( !_views.contains(widget) );
+
+    _views.append(widget);
+
+    if ( _emulation != 0 )
+    {
+        // connect emulation - view signals and slots
+        connect( widget , SIGNAL(keyPressedSignal(QKeyEvent*)) , _emulation ,
+                 SLOT(sendKeyEvent(QKeyEvent*)) );
+        connect( widget , SIGNAL(mouseSignal(int,int,int,int)) , _emulation ,
+                 SLOT(sendMouseEvent(int,int,int,int)) );
+        connect( widget , SIGNAL(sendStringToEmu(const char*)) , _emulation ,
+                 SLOT(sendString(const char*)) );
+
+        // allow emulation to notify view when the foreground process
+        // indicates whether or not it is interested in mouse signals
+        connect( _emulation , SIGNAL(programUsesMouseChanged(bool)) , widget ,
+                 SLOT(setUsesMouse(bool)) );
+
+        widget->setUsesMouse( _emulation->programUsesMouse() );
+
+        widget->setScreenWindow(_emulation->createWindow());
+    }
+
+    //connect view signals and slots
+    QObject::connect( widget ,SIGNAL(changedContentSizeSignal(int,int)),this,
+                      SLOT(onViewSizeChange(int,int)));
+
+    QObject::connect( widget ,SIGNAL(destroyed(QObject*)) , this ,
+                      SLOT(viewDestroyed(QObject*)) );
+    //slot for close
+    //QObject::connect(this, SIGNAL(finished()), widget, SLOT(close()));
+}
+
+void TerminalModel::viewDestroyed(QObject* view)
+{
+    TerminalView* display = (TerminalView*)view;
+
+    Q_ASSERT( _views.contains(display) );
+
+    removeView(display);
+}
+
+void TerminalModel::sendData(const char *buf, int len)
+{
+    ssize_t bytesWritten = ::write(_kpty->masterFd(), buf, len);
+    (void)bytesWritten;
+}
+
+void TerminalModel::removeView(TerminalView* widget)
+{
+    _views.removeAll(widget);
+
+    disconnect(widget,0,this,0);
+
+    if ( _emulation != 0 )
+    {
+        // disconnect
+        //  - key presses signals from widget
+        //  - mouse activity signals from widget
+        //  - string sending signals from widget
+        //
+        //  ... and any other signals connected in addView()
+        disconnect( widget, 0, _emulation, 0);
+
+        // disconnect state change signals emitted by emulation
+        disconnect( _emulation , 0 , widget , 0);
+    }
+
+    // close the session automatically when the last view is removed
+    if ( _views.count() == 0 )
+    {
+        close();
+    }
+}
+
+void TerminalModel::run()
+{
+    emit started();
+}
+
+void TerminalModel::monitorTimerDone()
+{
+    //FIXME: The idea here is that the notification popup will appear to tell the user than output from
+    //the terminal has stopped and the popup will disappear when the user activates the session.
+    //
+    //This breaks with the addition of multiple views of a session.  The popup should disappear
+    //when any of the views of the session becomes active
+
+
+    //FIXME: Make message text for this notification and the activity notification more descriptive.
+    if (_monitorSilence) {
+        //    KNotification::event("Silence", ("Silence in session '%1'", _nameTitle), QPixmap(),
+        //                    QApplication::activeWindow(),
+        //                    KNotification::CloseWhenWidgetActivated);
+        emit stateChanged(NOTIFYSILENCE);
+    }
+    else
+    {
+        emit stateChanged(NOTIFYNORMAL);
+    }
+
+    _notifiedActivity=false;
+}
+
+void TerminalModel::activityStateSet(int state)
+{
+    if (state==NOTIFYBELL)
+    {
+        emit bellRequest("");
+    }
+    else if (state==NOTIFYACTIVITY)
+    {
+        if (_monitorSilence) {
+            _monitorTimer->start(_silenceSeconds*1000);
+        }
+
+        if ( _monitorActivity ) {
+            //FIXME:  See comments in Session::monitorTimerDone()
+            if (!_notifiedActivity) {
+                //        KNotification::event("Activity", ("Activity in session '%1'", _nameTitle), QPixmap(),
+                //                        QApplication::activeWindow(),
+                //        KNotification::CloseWhenWidgetActivated);
+                _notifiedActivity=true;
+            }
+        }
+    }
+
+    if ( state==NOTIFYACTIVITY && !_monitorActivity )
+        state = NOTIFYNORMAL;
+    if ( state==NOTIFYSILENCE && !_monitorSilence )
+        state = NOTIFYNORMAL;
+
+    emit stateChanged(state);
+}
+
+void TerminalModel::onViewSizeChange(int /*height*/, int /*width*/)
+{
+    updateTerminalSize();
+}
+void TerminalModel::onEmulationSizeChange(int lines , int columns)
+{
+    setSize( QSize(lines,columns) );
+}
+
+void TerminalModel::updateTerminalSize()
+{
+    QListIterator<TerminalView*> viewIter(_views);
+
+    int minLines = -1;
+    int minColumns = -1;
+
+    // minimum number of lines and columns that views require for
+    // their size to be taken into consideration ( to avoid problems
+    // with new view widgets which haven't yet been set to their correct size )
+    const int VIEW_LINES_THRESHOLD = 2;
+    const int VIEW_COLUMNS_THRESHOLD = 2;
+
+    //select largest number of lines and columns that will fit in all visible views
+    while ( viewIter.hasNext() )
+    {
+        TerminalView* view = viewIter.next();
+        if ( view->isHidden() == false &&
+             view->lines() >= VIEW_LINES_THRESHOLD &&
+             view->columns() >= VIEW_COLUMNS_THRESHOLD )
+        {
+            minLines = (minLines == -1) ? view->lines() : qMin( minLines , view->lines() );
+            minColumns = (minColumns == -1) ? view->columns() : qMin( minColumns , view->columns() );
+        }
+    }
+
+    // backend emulation must have a _terminal of at least 1 column x 1 line in size
+    if ( minLines > 0 && minColumns > 0 )
+    {
+        _emulation->setImageSize( minLines , minColumns );
+        _kpty->setWinSize (minLines, minColumns);
+        //_shellProcess->setWindowSize( minLines , minColumns );
+    }
+}
+
+void TerminalModel::refresh()
+{
+}
+
+void TerminalModel::close()
+{
+    _autoClose = true;
+    _wantedClose = true;
+}
+
+void TerminalModel::sendText(const QString &text) const
+{
+    _emulation->sendText(text);
+}
+
+TerminalModel::~TerminalModel()
+{
+    delete _emulation;
+}
+
+void TerminalModel::setProfileKey(const QString& key)
+{
+    _profileKey = key;
+    emit profileChanged(key);
+}
+QString TerminalModel::profileKey() const { return _profileKey; }
+
+void TerminalModel::done(int)
+{
+    emit finished();
+}
+
+Emulation* TerminalModel::emulation() const
+{
+    return _emulation;
+}
+
+QString TerminalModel::keyBindings() const
+{
+    return _emulation->keyBindings();
+}
+
+void TerminalModel::setKeyBindings(const QString &id)
+{
+    _emulation->setKeyBindings(id);
+}
+
+void TerminalModel::setHistoryType(const HistoryType &hType)
+{
+    _emulation->setHistory(hType);
+}
+
+const HistoryType& TerminalModel::historyType() const
+{
+    return _emulation->history();
+}
+
+void TerminalModel::clearHistory()
+{
+    _emulation->clearHistory();
+}
+
+// unused currently
+bool TerminalModel::isMonitorActivity() const { return _monitorActivity; }
+// unused currently
+bool TerminalModel::isMonitorSilence()  const { return _monitorSilence; }
+
+void TerminalModel::setMonitorActivity(bool _monitor)
+{
+    _monitorActivity=_monitor;
+    _notifiedActivity=false;
+
+    activityStateSet(NOTIFYNORMAL);
+}
+
+void TerminalModel::setMonitorSilence(bool _monitor)
+{
+    if (_monitorSilence==_monitor)
+        return;
+
+    _monitorSilence=_monitor;
+    if (_monitorSilence)
+    {
+        _monitorTimer->start(_silenceSeconds*1000);
+    }
+    else
+        _monitorTimer->stop();
+
+    activityStateSet(NOTIFYNORMAL);
+}
+
+void TerminalModel::setMonitorSilenceSeconds(int seconds)
+{
+    _silenceSeconds=seconds;
+    if (_monitorSilence) {
+        _monitorTimer->start(_silenceSeconds*1000);
+    }
+}
+
+void TerminalModel::setAddToUtmp(bool set)
+{
+    _addToUtmp = set;
+}
+
+void TerminalModel::onReceiveBlock(const char* buf, int len )
+{
+    _emulation->receiveData( buf, len );
+    emit receivedData( QString::fromLatin1( buf, len ) );
+}
+
+QSize TerminalModel::size()
+{
+    return _emulation->imageSize();
+}
+
+void TerminalModel::setSize(const QSize& size)
+{
+    if ((size.width() <= 1) || (size.height() <= 1))
+        return;
+
+    emit resizeRequest(size);
+}
diff --git a/libgui/qterminal/libqterminal/unix/TerminalModel.h b/libgui/qterminal/libqterminal/unix/TerminalModel.h
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/TerminalModel.h
@@ -0,0 +1,371 @@
+/*
+    This file is part of Konsole, an X terminal.
+
+    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
+    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+    Copyright (C) 2012 Jacob Dawid <jacob.dawid@googlemail.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef TERMINALMODEL_H
+#define TERMINALMODEL_H
+
+// Qt
+#include <QtCore/QStringList>
+#include <QtCore>
+#include <QWidget>
+
+#include "unix/SelfListener.h"
+
+// Konsole
+#include "unix/History.h"
+#include "unix/kpty.h"
+
+class KProcess;
+
+class Emulation;
+class PseudoTerminal;
+class TerminalView;
+
+/**
+ * Represents a terminal session consisting of a pseudo-teletype and a terminal emulation.
+ * The pseudo-teletype (or PTY) handles I/O between the terminal process and Konsole.
+ * The terminal emulation ( Emulation and subclasses ) processes the output stream from the
+ * PTY and produces a character image which is then shown on views connected to the session.
+ *
+ * Each Session can be connected to one or more views by using the addView() method.
+ * The attached views can then display output from the program running in the terminal
+ * or send input to the program in the terminal in the form of keypresses and mouse
+ * activity.
+ */
+class TerminalModel : public QObject {
+Q_OBJECT
+
+public:
+  Q_PROPERTY(QString keyBindings READ keyBindings WRITE setKeyBindings)
+  Q_PROPERTY(QSize size READ size WRITE setSize)
+
+  /**
+   * Constructs a new session.
+   *
+   * To start the terminal process, call the run() method,
+   * after specifying the program and arguments
+   * using setProgram() and setArguments()
+   *
+   * If no program or arguments are specified explicitly, the Session
+   * falls back to using the program specified in the SHELL environment
+   * variable.
+   */
+  TerminalModel(KPty *kpty);
+  ~TerminalModel();
+
+
+  /**
+   * Sets the profile associated with this session.
+   *
+   * @param profileKey A key which can be used to obtain the current
+   * profile settings from the SessionManager
+   */
+  void setProfileKey(const QString& profileKey);
+  /**
+   * Returns the profile key associated with this session.
+   * This can be passed to the SessionManager to obtain the current
+   * profile settings.
+   */
+  QString profileKey() const;
+
+  /**
+   * Adds a new view for this session.
+   *
+   * The viewing widget will display the output from the terminal and
+   * input from the viewing widget (key presses, mouse activity etc.)
+   * will be sent to the terminal.
+   *
+   * Views can be removed using removeView().  The session is automatically
+   * closed when the last view is removed.
+   */
+  void addView(TerminalView* widget);
+  /**
+   * Removes a view from this session.  When the last view is removed,
+   * the session will be closed automatically.
+   *
+   * @p widget will no longer display output from or send input
+   * to the terminal
+   */
+  void removeView(TerminalView* widget);
+
+  /**
+   * Returns the views connected to this session
+   */
+  QList<TerminalView*> views() const;
+
+  /**
+   * Returns the terminal emulation instance being used to encode / decode
+   * characters to / from the process.
+   */
+  Emulation*  emulation() const;
+
+
+
+  /**
+   * Sets the type of history store used by this session.
+   * Lines of output produced by the terminal are added
+   * to the history store.  The type of history store
+   * used affects the number of lines which can be
+   * remembered before they are lost and the storage
+   * (in memory, on-disk etc.) used.
+   */
+  void setHistoryType(const HistoryType& type);
+  /**
+   * Returns the type of history store used by this session.
+   */
+  const HistoryType& historyType() const;
+  /**
+   * Clears the history store used by this session.
+   */
+  void clearHistory();
+
+  /**
+   * Enables monitoring for activity in the session.
+   * This will cause notifySessionState() to be emitted
+   * with the NOTIFYACTIVITY state flag when output is
+   * received from the terminal.
+   */
+  void setMonitorActivity(bool);
+  /** Returns true if monitoring for activity is enabled. */
+  bool isMonitorActivity() const;
+
+  /**
+   * Enables monitoring for silence in the session.
+   * This will cause notifySessionState() to be emitted
+   * with the NOTIFYSILENCE state flag when output is not
+   * received from the terminal for a certain period of
+   * time, specified with setMonitorSilenceSeconds()
+   */
+  void setMonitorSilence(bool);
+  /**
+   * Returns true if monitoring for inactivity (silence)
+   * in the session is enabled.
+   */
+  bool isMonitorSilence()  const;
+  /** See setMonitorSilence() */
+  void setMonitorSilenceSeconds(int seconds);
+
+  /**
+   * Sets the key bindings used by this session.  The bindings
+   * specify how input key sequences are translated into
+   * the character stream which is sent to the terminal.
+   *
+   * @param id The name of the key bindings to use.  The
+   * names of available key bindings can be determined using the
+   * KeyboardTranslatorManager class.
+   */
+  void setKeyBindings(const QString& id);
+  /** Returns the name of the key bindings used by this session. */
+  QString keyBindings() const;
+
+
+  /** Specifies whether a utmp entry should be created for the pty used by this session. */
+  void setAddToUtmp(bool);
+
+  /**
+   * Specifies whether to close the session automatically when the terminal
+   * process terminates.
+   */
+  void setAutoClose(bool b) { _autoClose = b; }
+
+  /**
+   * Sends @p text to the current foreground terminal program.
+   */
+  void sendText(const QString& text) const;
+
+
+  /** Returns the terminal session's window size in lines and columns. */
+  QSize size();
+  /**
+   * Emits a request to resize the session to accommodate
+   * the specified window size.
+   *
+   * @param size The size in lines and columns to request.
+   */
+  void setSize(const QSize& size);
+
+  /** Sets the text codec used by this session's terminal emulation. */
+  void setCodec(QTextCodec* codec);
+
+  /**
+   * Sets whether the session has a dark background or not.  The session
+   * uses this information to set the COLORFGBG variable in the process's
+   * environment, which allows the programs running in the terminal to determine
+   * whether the background is light or dark and use appropriate colors by default.
+   *
+   * This has no effect once the session is running.
+   */
+  void setDarkBackground(bool darkBackground);
+  /**
+   * Returns true if the session has a dark background.
+   * See setDarkBackground()
+   */
+  bool hasDarkBackground() const;
+
+  /**
+   * Attempts to get the shell program to redraw the current display area.
+   * This can be used after clearing the screen, for example, to get the
+   * shell to redraw the prompt line.
+   */
+  void refresh();
+
+public slots:
+
+  /**
+   * Starts the terminal session.
+   *
+   * This creates the terminal process and connects the teletype to it.
+   */
+  void run();
+
+  /**
+   * Closes the terminal session.  This sends a hangup signal
+   * (SIGHUP) to the terminal process and causes the done(Session*)
+   * signal to be emitted.
+   */
+  void close();
+
+signals:
+
+  /** Emitted when the terminal process starts. */
+  void started();
+
+  /**
+   * Emitted when the terminal process exits.
+   */
+  void finished();
+
+  /**
+   * Emitted when output is received from the terminal process.
+   */
+  void receivedData( const QString& text );
+
+  /** Emitted when the session's title has changed. */
+  void titleChanged();
+
+  /** Emitted when the session's profile has changed. */
+  void profileChanged(const QString& profile);
+
+  /**
+   * Emitted when the activity state of this session changes.
+   *
+   * @param state The new state of the session.  This may be one
+   * of NOTIFYNORMAL, NOTIFYSILENCE or NOTIFYACTIVITY
+   */
+  void stateChanged(int state);
+
+  /** Emitted when a bell event occurs in the session. */
+  void bellRequest( const QString& message );
+
+  /**
+   * Requests that the color the text for any tabs associated with
+   * this session should be changed;
+   *
+   * TODO: Document what the parameter does
+   */
+  void changeTabTextColorRequest(int);
+
+  /**
+   * Requests that the background color of views on this session
+   * should be changed.
+   */
+  void changeBackgroundColorRequest(const QColor&);
+
+  /** TODO: Document me. */
+  void openUrlRequest(const QString& url);
+
+  /**
+   * Emitted when the terminal process requests a change
+   * in the size of the terminal window.
+   *
+   * @param size The requested window size in terms of lines and columns.
+   */
+  void resizeRequest(const QSize& size);
+
+  /**
+   * Emitted when a profile change command is received from the terminal.
+   *
+   * @param text The text of the command.  This is a string of the form
+   * "PropertyName=Value;PropertyName=Value ..."
+   */
+  void profileChangeCommandReceived(const QString& text);
+
+private slots:
+  void done(int);
+
+  void onReceiveBlock(const char* buffer, int len );
+  void monitorTimerDone();
+
+  void onViewSizeChange(int height, int width);
+  void onEmulationSizeChange(int lines , int columns);
+
+  void activityStateSet(int);
+
+  //automatically detach views from sessions when view is destroyed
+  void viewDestroyed(QObject* view);
+
+  void sendData(const char* buf, int len);
+
+private:
+
+  void updateTerminalSize();
+  WId windowId() const;
+
+  int            _uniqueIdentifier;
+
+  PseudoTerminal* _shellProcess;
+  Emulation*    _emulation;
+
+  QList<TerminalView*> _views;
+
+  bool           _monitorActivity;
+  bool           _monitorSilence;
+  bool           _notifiedActivity;
+  bool           _masterMode;
+  bool           _autoClose;
+  bool           _wantedClose;
+  QTimer*        _monitorTimer;
+
+  int            _silenceSeconds;
+
+  bool           _addToUtmp;
+  bool           _fullScripting;
+
+  int            _masterFd;
+  int            _slaveFd;
+
+  SelfListener  *_selfListener;
+  KPty         * _kpty;
+
+
+  QColor         _modifiedBackground; // as set by: echo -en '\033]11;Color\007
+
+  QString        _profileKey;
+
+  bool _hasDarkBackground;
+};
+
+
+#endif // TERMINALMODEL_H
diff --git a/libgui/qterminal/libqterminal/unix/TerminalView.cpp b/libgui/qterminal/libqterminal/unix/TerminalView.cpp
new file mode 100755
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/TerminalView.cpp
@@ -0,0 +1,2661 @@
+/*
+    This file is part of Konsole, a terminal emulator for KDE.
+
+    Copyright (C) 2006-7 by Robert Knight <robertknight@gmail.com>
+    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+    Copyright (C) 2012 Jacob Dawid <jacob.dawid@googlemail.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+// Own
+#include "unix/TerminalView.h"
+
+// Qt
+#include <QtGui/QApplication>
+#include <QtGui/QBoxLayout>
+#include <QtGui/QClipboard>
+#include <QtGui/QKeyEvent>
+#include <QtCore/QEvent>
+#include <QtCore/QTime>
+#include <QtCore/QFile>
+#include <QtGui/QGridLayout>
+#include <QtGui/QLabel>
+#include <QtGui/QLayout>
+#include <QtGui/QPainter>
+#include <QtGui/QPixmap>
+#include <QtGui/QScrollBar>
+#include <QtGui/QStyle>
+#include <QtCore>
+#include <QtGui>
+
+#include "unix/Filter.h"
+#include "unix/konsole_wcwidth.h"
+#include "unix/ScreenWindow.h"
+#include "unix/TerminalCharacterDecoder.h"
+
+#ifndef loc
+#define loc(X,Y) ((Y)*_columns+(X))
+#endif
+
+#define yMouseScroll 1
+
+#define REPCHAR   "ABCDEFGHIJKLMNOPQRSTUVWXYZ" \
+  "abcdefgjijklmnopqrstuvwxyz" \
+  "0123456789./+@"
+
+// scroll increment used when dragging selection at top/bottom of window.
+
+// static
+bool TerminalView::_antialiasText = true;
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                                Colors                                     */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+/* Note that we use ANSI color order (bgr), while IBMPC color order is (rgb)
+
+   Code        0       1       2       3       4       5       6       7
+   ----------- ------- ------- ------- ------- ------- ------- ------- -------
+   ANSI  (bgr) Black   Red     Green   Yellow  Blue    Magenta Cyan    White
+   IBMPC (rgb) Black   Blue    Green   Cyan    Red     Magenta Yellow  White
+*/
+
+ScreenWindow* TerminalView::screenWindow() const
+{
+  return _screenWindow;
+}
+void TerminalView::setScreenWindow(ScreenWindow* window)
+{
+  // disconnect existing screen window if any
+  if ( _screenWindow )
+    {
+      disconnect( _screenWindow , 0 , this , 0 );
+    }
+
+  _screenWindow = window;
+
+  if ( window )
+    {
+      //#warning "The order here is not specified - does it matter whether updateImage or updateLineProperties comes first?"
+      connect( _screenWindow , SIGNAL(outputChanged()) , this , SLOT(updateLineProperties()) );
+      connect( _screenWindow , SIGNAL(outputChanged()) , this , SLOT(updateImage()) );
+      window->setWindowLines(_lines);
+    }
+}
+
+const ColorEntry* TerminalView::colorTable() const
+{
+  return _colorTable;
+}
+
+void TerminalView::setColorTable(const ColorEntry table[])
+{
+  for (int i = 0; i < TABLE_COLORS; i++)
+    _colorTable[i] = table[i];
+
+  QPalette p = palette();
+  p.setColor( backgroundRole(), _colorTable[DEFAULT_BACK_COLOR].color );
+  setPalette( p );
+
+  // Avoid propagating the palette change to the scroll bar
+  _scrollBar->setPalette( QApplication::palette() );
+
+  update();
+}
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                                   Font                                    */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+/*
+   The VT100 has 32 special graphical characters. The usual vt100 extended
+   xterm fonts have these at 0x00..0x1f.
+
+   QT's iso mapping leaves 0x00..0x7f without any changes. But the graphicals
+   come in here as proper unicode characters.
+
+   We treat non-iso10646 fonts as VT100 extended and do the required mapping
+   from unicode to 0x00..0x1f. The remaining translation is then left to the
+   QCodec.
+*/
+
+static inline bool isLineChar(quint16 c) { return ((c & 0xFF80) == 0x2500);}
+static inline bool isLineCharString(const QString& string)
+{
+  return (string.length() > 0) && (isLineChar(string.at(0).unicode()));
+}
+
+
+// assert for i in [0..31] : vt100extended(vt100_graphics[i]) == i.
+
+unsigned short vt100_graphics[32] =
+{ // 0/8     1/9    2/10    3/11    4/12    5/13    6/14    7/15
+  0x0020, 0x25C6, 0x2592, 0x2409, 0x240c, 0x240d, 0x240a, 0x00b0,
+  0x00b1, 0x2424, 0x240b, 0x2518, 0x2510, 0x250c, 0x2514, 0x253c,
+  0xF800, 0xF801, 0x2500, 0xF803, 0xF804, 0x251c, 0x2524, 0x2534,
+  0x252c, 0x2502, 0x2264, 0x2265, 0x03C0, 0x2260, 0x00A3, 0x00b7
+};
+
+void TerminalView::fontChange(const QFont&)
+{
+  QFontMetrics fm(font());
+  _fontHeight = fm.height() + _lineSpacing;
+
+
+  // waba TerminalDisplay 1.123:
+  // "Base character width on widest ASCII character. This prevents too wide
+  //  characters in the presence of double wide (e.g. Japanese) characters."
+  // Get the width from representative normal width characters
+  _fontWidth = (double)fm.width(REPCHAR)/(double)strlen(REPCHAR);
+
+  _fixedFont = true;
+
+  int fw = fm.width(REPCHAR[0]);
+  for(unsigned int i=1; i< strlen(REPCHAR); i++)
+    {
+      if (fw != fm.width(REPCHAR[i]))
+        {
+          _fixedFont = false;
+          break;
+        }
+    }
+
+
+  if (_fontWidth < 1)
+    _fontWidth = 1;
+
+  _fontAscent = fm.ascent();
+
+  emit changedFontMetricSignal( _fontHeight, _fontWidth );
+  //parentWidget()->setFixedWidth(_fontWidth * 80 + _leftMargin);
+  propagateSize();
+  update();
+}
+
+void TerminalView::setVTFont(const QFont& f)
+{
+  QFont font = f;
+
+  QFontMetrics metrics(font);
+
+  if ( metrics.height() < height() && metrics.maxWidth() < width() )
+    {
+      // hint that text should be drawn without anti-aliasing.
+      // depending on the user's font configuration, this may not be respected
+      if (!_antialiasText)
+        font.setStyleStrategy( QFont::NoAntialias );
+
+      // experimental optimization.  Konsole assumes that the terminal is using a
+      // mono-spaced font, in which case kerning information should have an effect.
+      // Disabling kerning saves some computation when rendering text.
+      // font.setKerning(false);
+
+      QWidget::setFont(font);
+      fontChange(font);
+    }
+}
+
+void TerminalView::setFont(const QFont &)
+{
+  // ignore font change request if not coming from konsole itself
+}
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                         Constructor / Destructor                          */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+TerminalView::TerminalView(QWidget *parent)
+  :QWidget(parent)
+  ,_screenWindow(0)
+  ,_allowBell(true)
+  ,_gridLayout(0)
+  ,_fontHeight(1)
+  ,_fontWidth(1)
+  ,_fontAscent(1)
+  ,_lines(1)
+  ,_columns(1)
+  ,_usedLines(1)
+  ,_usedColumns(1)
+  ,_contentHeight(1)
+  ,_contentWidth(1)
+  ,_image(0)
+  ,_randomSeed(0)
+  ,_resizing(false)
+  ,_terminalSizeHint(false)
+  ,_terminalSizeStartup(true)
+  ,_actSel(0)
+  ,_wordSelectionMode(false)
+  ,_lineSelectionMode(false)
+  ,_preserveLineBreaks(false)
+  ,_columnSelectionMode(false)
+  ,_scrollbarLocation(NoScrollBar)
+  ,_wordCharacters(":@-./_~")
+  ,_bellMode(SystemBeepBell)
+  ,_blinking(false)
+  ,_cursorBlinking(false)
+  ,_hasBlinkingCursor(false)
+  ,_ctrlDrag(false)
+  ,_tripleClickMode(SelectWholeLine)
+  ,_isFixedSize(false)
+  ,_possibleTripleClick(false)
+  ,_resizeWidget(0)
+  ,_resizeTimer(0)
+  ,_outputSuspendedLabel(0)
+  ,_lineSpacing(0)
+  ,_colorsInverted(false)
+  ,_blendColor(qRgba(0,0,0,0xff))
+  ,_filterChain(new TerminalImageFilterChain())
+  ,_cursorShape(BlockCursor)
+  ,_readonly(false)
+{
+  // terminal applications are not designed with Right-To-Left in mind,
+  // so the layout is forced to Left-To-Right
+  setLayoutDirection(Qt::LeftToRight);
+
+  // The offsets are not yet calculated.
+  // Do not calculate these too often to be more smoothly when resizing
+  // konsole in opaque mode.
+  _topMargin = DEFAULT_TOP_MARGIN;
+  _leftMargin = DEFAULT_LEFT_MARGIN;
+
+  // create scroll bar for scrolling output up and down
+  // set the scroll bar's slider to occupy the whole area of the scroll bar initially
+  _scrollBar = new QScrollBar(this);
+  setScroll(0,0);
+  _scrollBar->setCursor( Qt::ArrowCursor );
+  connect(_scrollBar, SIGNAL(valueChanged(int)), this,
+          SLOT(scrollBarPositionChanged(int)));
+
+  // setup timers for blinking cursor and text
+  _blinkTimer   = new QTimer(this);
+  connect(_blinkTimer, SIGNAL(timeout()), this, SLOT(blinkEvent()));
+  _blinkCursorTimer   = new QTimer(this);
+  connect(_blinkCursorTimer, SIGNAL(timeout()), this, SLOT(blinkCursorEvent()));
+
+  //  QCursor::setAutoHideCursor( this, true );
+
+  setUsesMouse(true);
+  setColorTable(base_color_table);
+  setMouseTracking(true);
+
+  // Enable drag and drop
+  setAcceptDrops(true); // attempt
+  dragInfo.state = diNone;
+
+  setFocusPolicy( Qt::WheelFocus );
+
+  // enable input method support
+  setAttribute(Qt::WA_InputMethodEnabled, true);
+
+  // this is an important optimization, it tells Qt
+  // that TerminalDisplay will handle repainting its entire area.
+  setAttribute(Qt::WA_OpaquePaintEvent);
+
+  _gridLayout = new QGridLayout(this);
+  _gridLayout->setMargin(0);
+
+  setLayout( _gridLayout );
+}
+
+TerminalView::~TerminalView()
+{
+  qApp->removeEventFilter( this );
+
+  delete[] _image;
+
+  delete _gridLayout;
+  delete _outputSuspendedLabel;
+  delete _filterChain;
+}
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                             Display Operations                            */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+/**
+ A table for emulating the simple (single width) unicode drawing chars.
+ It represents the 250x - 257x glyphs. If it's zero, we can't use it.
+ if it's not, it's encoded as follows: imagine a 5x5 grid where the points are numbered
+ 0 to 24 left to top, top to bottom. Each point is represented by the corresponding bit.
+
+ Then, the pixels basically have the following interpretation:
+ _|||_
+ -...-
+ -...-
+ -...-
+ _|||_
+
+where _ = none
+      | = vertical line.
+      - = horizontal line.
+ */
+
+
+enum LineEncode
+{
+  TopL  = (1<<1),
+  TopC  = (1<<2),
+  TopR  = (1<<3),
+
+  LeftT = (1<<5),
+  Int11 = (1<<6),
+  Int12 = (1<<7),
+  Int13 = (1<<8),
+  RightT = (1<<9),
+
+  LeftC = (1<<10),
+  Int21 = (1<<11),
+  Int22 = (1<<12),
+  Int23 = (1<<13),
+  RightC = (1<<14),
+
+  LeftB = (1<<15),
+  Int31 = (1<<16),
+  Int32 = (1<<17),
+  Int33 = (1<<18),
+  RightB = (1<<19),
+
+  BotL  = (1<<21),
+  BotC  = (1<<22),
+  BotR  = (1<<23)
+};
+
+#include "LineFont.h"
+
+static void drawLineChar(QPainter& paint, int x, int y, int w, int h, uchar code)
+{
+  //Calculate cell midpoints, end points.
+  int cx = x + w/2;
+  int cy = y + h/2;
+  int ex = x + w - 1;
+  int ey = y + h - 1;
+
+  quint32 toDraw = LineChars[code];
+
+  //Top _lines:
+  if (toDraw & TopL)
+    paint.drawLine(cx-1, y, cx-1, cy-2);
+  if (toDraw & TopC)
+    paint.drawLine(cx, y, cx, cy-2);
+  if (toDraw & TopR)
+    paint.drawLine(cx+1, y, cx+1, cy-2);
+
+  //Bot _lines:
+  if (toDraw & BotL)
+    paint.drawLine(cx-1, cy+2, cx-1, ey);
+  if (toDraw & BotC)
+    paint.drawLine(cx, cy+2, cx, ey);
+  if (toDraw & BotR)
+    paint.drawLine(cx+1, cy+2, cx+1, ey);
+
+  //Left _lines:
+  if (toDraw & LeftT)
+    paint.drawLine(x, cy-1, cx-2, cy-1);
+  if (toDraw & LeftC)
+    paint.drawLine(x, cy, cx-2, cy);
+  if (toDraw & LeftB)
+    paint.drawLine(x, cy+1, cx-2, cy+1);
+
+  //Right _lines:
+  if (toDraw & RightT)
+    paint.drawLine(cx+2, cy-1, ex, cy-1);
+  if (toDraw & RightC)
+    paint.drawLine(cx+2, cy, ex, cy);
+  if (toDraw & RightB)
+    paint.drawLine(cx+2, cy+1, ex, cy+1);
+
+  //Intersection points.
+  if (toDraw & Int11)
+    paint.drawPoint(cx-1, cy-1);
+  if (toDraw & Int12)
+    paint.drawPoint(cx, cy-1);
+  if (toDraw & Int13)
+    paint.drawPoint(cx+1, cy-1);
+
+  if (toDraw & Int21)
+    paint.drawPoint(cx-1, cy);
+  if (toDraw & Int22)
+    paint.drawPoint(cx, cy);
+  if (toDraw & Int23)
+    paint.drawPoint(cx+1, cy);
+
+  if (toDraw & Int31)
+    paint.drawPoint(cx-1, cy+1);
+  if (toDraw & Int32)
+    paint.drawPoint(cx, cy+1);
+  if (toDraw & Int33)
+    paint.drawPoint(cx+1, cy+1);
+
+}
+
+void TerminalView::drawLineCharString(	QPainter& painter, int x, int y, const QString& str,
+                                       const Character* attributes)
+{
+  const QPen& currentPen = painter.pen();
+
+  if ( attributes->rendition & RE_BOLD )
+    {
+      QPen boldPen(currentPen);
+      boldPen.setWidth(3);
+      painter.setPen( boldPen );
+    }
+
+  for (int i=0 ; i < str.length(); i++)
+    {
+      uchar code = str[i].cell();
+      if (LineChars[code])
+        drawLineChar(painter, x + (_fontWidth*i), y, _fontWidth, _fontHeight, code);
+    }
+
+  painter.setPen( currentPen );
+}
+
+void TerminalView::setKeyboardCursorShape(KeyboardCursorShape shape)
+{
+  _cursorShape = shape;
+}
+TerminalView::KeyboardCursorShape TerminalView::keyboardCursorShape() const
+{
+  return _cursorShape;
+}
+void TerminalView::setKeyboardCursorColor(bool useForegroundColor, const QColor& color)
+{
+  if (useForegroundColor)
+    _cursorColor = QColor(); // an invalid color means that
+  // the foreground color of the
+  // current character should
+  // be used
+
+  else
+    _cursorColor = color;
+}
+QColor TerminalView::keyboardCursorColor() const
+{
+  return _cursorColor;
+}
+
+void TerminalView::drawBackground(QPainter& painter, const QRect& rect, const QColor& backgroundColor)
+{
+  // the area of the widget showing the contents of the terminal display is drawn
+  // using the background color from the color scheme set with setColorTable()
+  //
+  // the area of the widget behind the scroll-bar is drawn using the background
+  // brush from the scroll-bar's palette, to give the effect of the scroll-bar
+  // being outside of the terminal display and visual consistency with other KDE
+  // applications.
+  //
+  QRect scrollBarArea = _scrollBar->isVisible() ?
+        rect.intersected(_scrollBar->geometry()) :
+        QRect();
+
+  QRegion contentsRegion = QRegion(rect).subtracted(scrollBarArea);
+  QRect contentsRect = contentsRegion.boundingRect();
+
+  painter.fillRect(contentsRect, backgroundColor);
+  painter.fillRect(scrollBarArea,_scrollBar->palette().background());
+}
+
+void TerminalView::drawCursor(QPainter& painter,
+                              const QRect& rect,
+                              const QColor& foregroundColor,
+                              const QColor& /*backgroundColor*/,
+                              bool& invertCharacterColor)
+{
+  QRect cursorRect = rect;
+  cursorRect.setHeight(_fontHeight - _lineSpacing - 1);
+
+  if (!_cursorBlinking)
+    {
+      if ( _cursorColor.isValid() )
+        painter.setPen(_cursorColor);
+      else {
+          painter.setPen(foregroundColor);
+        }
+
+      if ( _cursorShape == BlockCursor )
+        {
+          // draw the cursor outline, adjusting the area so that
+          // it is draw entirely inside 'rect'
+          int penWidth = qMax(1,painter.pen().width());
+
+          painter.drawRect(cursorRect.adjusted(penWidth/2,
+                                               penWidth/2,
+                                               - penWidth/2 - penWidth%2,
+                                               - penWidth/2 - penWidth%2));
+          if ( hasFocus() )
+            {
+              painter.fillRect(cursorRect, _cursorColor.isValid() ? _cursorColor : foregroundColor);
+
+              if ( !_cursorColor.isValid() )
+                {
+                  // invert the colour used to draw the text to ensure that the character at
+                  // the cursor position is readable
+                  invertCharacterColor = true;
+                }
+            }
+        }
+      else if ( _cursorShape == UnderlineCursor )
+        painter.drawLine(cursorRect.left(),
+                         cursorRect.bottom(),
+                         cursorRect.right(),
+                         cursorRect.bottom());
+      else if ( _cursorShape == IBeamCursor )
+        painter.drawLine(cursorRect.left(),
+                         cursorRect.top(),
+                         cursorRect.left(),
+                         cursorRect.bottom());
+
+    }
+}
+
+void TerminalView::drawCharacters(QPainter& painter,
+                                  const QRect& rect,
+                                  const QString& text,
+                                  const Character* style,
+                                  bool invertCharacterColor)
+{
+  // don't draw text which is currently blinking
+  if ( _blinking && (style->rendition & RE_BLINK) )
+    return;
+
+  // setup bold and underline
+  bool useBold = style->rendition & RE_BOLD || style->isBold(_colorTable) || font().bold();
+  bool useUnderline = style->rendition & RE_UNDERLINE || font().underline();
+
+  QFont font = painter.font();
+  if (    font.bold() != useBold
+          || font.underline() != useUnderline )
+    {
+      font.setBold(useBold);
+      font.setUnderline(useUnderline);
+      painter.setFont(font);
+    }
+
+  const CharacterColor& textColor = ( invertCharacterColor ? style->backgroundColor : style->foregroundColor );
+  const QColor color = textColor.color(_colorTable);
+
+  QPen pen = painter.pen();
+  if ( pen.color() != color )
+    {
+      pen.setColor(color);
+      painter.setPen(color);
+    }
+  // draw text
+  if ( isLineCharString(text) ) {
+      drawLineCharString(painter,rect.x(),rect.y(),text,style);
+    }
+  else
+    {
+      // the drawText(rect,flags,string) overload is used here with null flags
+      // instead of drawText(rect,string) because the (rect,string) overload causes
+      // the application's default layout direction to be used instead of
+      // the widget-specific layout direction, which should always be
+      // Qt::LeftToRight for this widget
+      painter.drawText(rect,0,text);
+    }
+}
+
+void TerminalView::drawTextFragment(QPainter& painter ,
+                                    const QRect& rect,
+                                    const QString& text,
+                                    const Character* style)
+{
+  painter.save();
+
+  // setup painter
+  const QColor foregroundColor = style->foregroundColor.color(_colorTable);
+  const QColor backgroundColor = style->backgroundColor.color(_colorTable);
+
+  // draw background if different from the display's background color
+  if ( backgroundColor != palette().background().color() )
+    drawBackground(painter,rect,backgroundColor);
+
+  // draw cursor shape if the current character is the cursor
+  // this may alter the foreground and background colors
+  bool invertCharacterColor = false;
+
+  if ( style->rendition & RE_CURSOR )
+    drawCursor(painter,rect,foregroundColor,backgroundColor,invertCharacterColor);
+  // draw text
+  drawCharacters(painter,rect,text,style,invertCharacterColor);
+
+  painter.restore();
+}
+
+void TerminalView::setRandomSeed(uint randomSeed) { _randomSeed = randomSeed; }
+uint TerminalView::randomSeed() const { return _randomSeed; }
+
+#if 0
+/*!
+    Set XIM Position
+*/
+void TerminalDisplay::setCursorPos(const int curx, const int cury)
+{
+  QPoint tL  = contentsRect().topLeft();
+  int    tLx = tL.x();
+  int    tLy = tL.y();
+
+  int xpos, ypos;
+  ypos = _topMargin + tLy + _fontHeight*(cury-1) + _fontAscent;
+  xpos = _leftMargin + tLx + _fontWidth*curx;
+  //setMicroFocusHint(xpos, ypos, 0, _fontHeight); //### ???
+  // fprintf(stderr, "x/y = %d/%d\txpos/ypos = %d/%d\n", curx, cury, xpos, ypos);
+  _cursorLine = cury;
+  _cursorCol = curx;
+}
+#endif
+
+// scrolls the image by 'lines', down if lines > 0 or up otherwise.
+//
+// the terminal emulation keeps track of the scrolling of the character
+// image as it receives input, and when the view is updated, it calls scrollImage()
+// with the final scroll amount.  this improves performance because scrolling the
+// display is much cheaper than re-rendering all the text for the
+// part of the image which has moved up or down.
+// Instead only new lines have to be drawn
+//
+// note:  it is important that the area of the display which is
+// scrolled aligns properly with the character grid -
+// which has a top left point at (_leftMargin,_topMargin) ,
+// a cell width of _fontWidth and a cell height of _fontHeight).
+void TerminalView::scrollImage(int lines , const QRect& screenWindowRegion)
+{
+  // if the flow control warning is enabled this will interfere with the
+  // scrolling optimisations and cause artifacts.  the simple solution here
+  // is to just disable the optimisation whilst it is visible
+  if ( _outputSuspendedLabel && _outputSuspendedLabel->isVisible() ) {
+      return;
+    }
+
+  // constrain the region to the display
+  // the bottom of the region is capped to the number of lines in the display's
+  // internal image - 2, so that the height of 'region' is strictly less
+  // than the height of the internal image.
+  QRect region = screenWindowRegion;
+  region.setBottom( qMin(region.bottom(),this->_lines-2) );
+
+  if (    lines == 0
+          || _image == 0
+          || !region.isValid()
+          || (region.top() + abs(lines)) >= region.bottom()
+          || this->_lines <= region.height() ) return;
+
+  QRect scrollRect;
+
+  void* firstCharPos = &_image[ region.top() * this->_columns ];
+  void* lastCharPos = &_image[ (region.top() + abs(lines)) * this->_columns ];
+
+  int top = _topMargin + (region.top() * _fontHeight);
+  int linesToMove = region.height() - abs(lines);
+  int bytesToMove = linesToMove *
+      this->_columns *
+      sizeof(Character);
+
+  Q_ASSERT( linesToMove > 0 );
+  Q_ASSERT( bytesToMove > 0 );
+
+  //scroll internal image
+  if ( lines > 0 )
+    {
+      // check that the memory areas that we are going to move are valid
+      Q_ASSERT( (char*)lastCharPos + bytesToMove <
+                (char*)(_image + (this->_lines * this->_columns)) );
+
+      Q_ASSERT( (lines*this->_columns) < _imageSize );
+
+      //scroll internal image down
+      memmove( firstCharPos , lastCharPos , bytesToMove );
+
+      //set region of display to scroll, making sure that
+      //the region aligns correctly to the character grid
+      scrollRect = QRect( _leftMargin , top,
+                          this->_usedColumns * _fontWidth ,
+                          linesToMove * _fontHeight );
+    }
+  else
+    {
+      // check that the memory areas that we are going to move are valid
+      Q_ASSERT( (char*)firstCharPos + bytesToMove <
+                (char*)(_image + (this->_lines * this->_columns)) );
+
+      //scroll internal image up
+      memmove( lastCharPos , firstCharPos , bytesToMove );
+
+      //set region of the display to scroll, making sure that
+      //the region aligns correctly to the character grid
+      QPoint topPoint( _leftMargin , top + abs(lines)*_fontHeight );
+
+      scrollRect = QRect( topPoint ,
+                          QSize( this->_usedColumns*_fontWidth ,
+                                 linesToMove * _fontHeight ));
+    }
+
+  //scroll the display vertically to match internal _image
+  scroll( 0 , _fontHeight * (-lines) , scrollRect );
+}
+
+QRegion TerminalView::hotSpotRegion() const
+{
+  QRegion region;
+  foreach( Filter::HotSpot* hotSpot , _filterChain->hotSpots() )
+    {
+      QRect rect;
+      rect.setLeft(hotSpot->startColumn());
+      rect.setTop(hotSpot->startLine());
+      rect.setRight(hotSpot->endColumn());
+      rect.setBottom(hotSpot->endLine());
+
+      region |= imageToWidget(rect);
+    }
+  return region;
+}
+
+void TerminalView::processFilters()
+{
+  if (!_screenWindow)
+    return;
+
+  QRegion preUpdateHotSpots = hotSpotRegion();
+
+  // use _screenWindow->getImage() here rather than _image because
+  // other classes may call processFilters() when this display's
+  // ScreenWindow emits a scrolled() signal - which will happen before
+  // updateImage() is called on the display and therefore _image is
+  // out of date at this point
+  _filterChain->setImage( _screenWindow->getImage(),
+                          _screenWindow->windowLines(),
+                          _screenWindow->windowColumns(),
+                          _screenWindow->getLineProperties() );
+  _filterChain->process();
+
+  QRegion postUpdateHotSpots = hotSpotRegion();
+
+  update( preUpdateHotSpots | postUpdateHotSpots );
+}
+
+void TerminalView::updateImage()
+{
+  if ( !_screenWindow )
+    return;
+  updateLineProperties();
+
+  // optimization - scroll the existing image where possible and
+  // avoid expensive text drawing for parts of the image that
+  // can simply be moved up or down
+  scrollImage( _screenWindow->scrollCount() ,
+               _screenWindow->scrollRegion() );
+  _screenWindow->resetScrollCount();
+
+  Character* const newimg = _screenWindow->getImage();
+  int lines = _screenWindow->windowLines() + 1;
+  int columns = _screenWindow->windowColumns();
+
+  setScroll( _screenWindow->currentLine() , _screenWindow->lineCount() );
+
+  if (!_image)
+    updateImageSize(); // Create _image
+
+  Q_ASSERT( this->_usedLines <= this->_lines );
+  Q_ASSERT( this->_usedColumns <= this->_columns );
+
+  int y,x,len;
+
+  QPoint tL  = contentsRect().topLeft();
+
+  int    tLx = tL.x();
+  int    tLy = tL.y();
+  _hasBlinker = false;
+
+  CharacterColor cf;       // undefined
+  CharacterColor _clipboard;       // undefined
+  int cr  = -1;   // undefined
+
+  const int linesToUpdate = qMin(this->_lines, qMax(0,lines  ));
+  const int columnsToUpdate = qMin(this->_columns,qMax(0,columns));
+
+  QChar *disstrU = new QChar[columnsToUpdate];
+  char *dirtyMask = new char[columnsToUpdate+2];
+  QRegion dirtyRegion;
+
+  // debugging variable, this records the number of lines that are found to
+  // be 'dirty' ( ie. have changed from the old _image to the new _image ) and
+  // which therefore need to be repainted
+  int dirtyLineCount = 0;
+
+  for (y = 0; y < linesToUpdate; y++)
+    {
+      const Character*       currentLine = &_image[y*this->_columns];
+      const Character* const newLine = &newimg[y*columns];
+
+      bool updateLine = false;
+
+      // The dirty mask indicates which characters need repainting. We also
+      // mark surrounding neighbours dirty, in case the character exceeds
+      // its cell boundaries
+      memset(dirtyMask, 0, columnsToUpdate+2);
+
+      for( x = 0 ; x < columnsToUpdate ; x++)
+        {
+          if ( newLine[x] != currentLine[x] )
+            {
+              dirtyMask[x] = true;
+            }
+        }
+
+      if (!_resizing) // not while _resizing, we're expecting a paintEvent
+        for (x = 0; x < columnsToUpdate; x++)
+          {
+            _hasBlinker |= (newLine[x].rendition & RE_BLINK);
+
+            // Start drawing if this character or the next one differs.
+            // We also take the next one into account to handle the situation
+            // where characters exceed their cell width.
+            if (dirtyMask[x])
+              {
+                quint16 c = newLine[x+0].character;
+                if ( !c )
+                  continue;
+                int p = 0;
+                disstrU[p++] = c; //fontMap(c);
+                bool lineDraw = isLineChar(c);
+                bool doubleWidth = (x+1 == columnsToUpdate) ? false : (newLine[x+1].character == 0);
+                cr = newLine[x].rendition;
+                _clipboard = newLine[x].backgroundColor;
+                if (newLine[x].foregroundColor != cf) cf = newLine[x].foregroundColor;
+                int lln = columnsToUpdate - x;
+                for (len = 1; len < lln; len++)
+                  {
+                    const Character& ch = newLine[x+len];
+
+                    if (!ch.character)
+                      continue; // Skip trailing part of multi-col chars.
+
+                    bool nextIsDoubleWidth = (x+len+1 == columnsToUpdate) ? false : (newLine[x+len+1].character == 0);
+
+                    if (  ch.foregroundColor != cf ||
+                          ch.backgroundColor != _clipboard ||
+                          ch.rendition != cr ||
+                          !dirtyMask[x+len] ||
+                          isLineChar(c) != lineDraw ||
+                          nextIsDoubleWidth != doubleWidth )
+                      break;
+
+                    disstrU[p++] = c; //fontMap(c);
+                  }
+
+                QString unistr(disstrU, p);
+
+                bool saveFixedFont = _fixedFont;
+                if (lineDraw)
+                  _fixedFont = false;
+                if (doubleWidth)
+                  _fixedFont = false;
+
+                updateLine = true;
+
+                _fixedFont = saveFixedFont;
+                x += len - 1;
+              }
+
+          }
+
+      //both the top and bottom halves of double height _lines must always be redrawn
+      //although both top and bottom halves contain the same characters, only
+      //the top one is actually
+      //drawn.
+      if (_lineProperties.count() > y)
+        updateLine |= (_lineProperties[y] & LINE_DOUBLEHEIGHT);
+
+      // if the characters on the line are different in the old and the new _image
+      // then this line must be repainted.
+      if (updateLine)
+        {
+          dirtyLineCount++;
+
+          // add the area occupied by this line to the region which needs to be
+          // repainted
+          QRect dirtyRect = QRect( _leftMargin+tLx ,
+                                   _topMargin+tLy+_fontHeight*y ,
+                                   _fontWidth * columnsToUpdate ,
+                                   _fontHeight );
+
+          dirtyRegion |= dirtyRect;
+        }
+
+      // replace the line of characters in the old _image with the
+      // current line of the new _image
+      memcpy((void*)currentLine,(const void*)newLine,columnsToUpdate*sizeof(Character));
+    }
+
+  // if the new _image is smaller than the previous _image, then ensure that the area
+  // outside the new _image is cleared
+  if ( linesToUpdate < _usedLines )
+    {
+      dirtyRegion |= QRect(   _leftMargin+tLx ,
+                              _topMargin+tLy+_fontHeight*linesToUpdate ,
+                              _fontWidth * this->_columns ,
+                              _fontHeight * (_usedLines-linesToUpdate) );
+    }
+  _usedLines = linesToUpdate;
+
+  if ( columnsToUpdate < _usedColumns )
+    {
+      dirtyRegion |= QRect(   _leftMargin+tLx+columnsToUpdate*_fontWidth ,
+                              _topMargin+tLy ,
+                              _fontWidth * (_usedColumns-columnsToUpdate) ,
+                              _fontHeight * this->_lines );
+    }
+  _usedColumns = columnsToUpdate;
+
+  dirtyRegion |= _inputMethodData.previousPreeditRect;
+
+  // update the parts of the display which have changed
+  update(dirtyRegion);
+
+  if ( _hasBlinker && !_blinkTimer->isActive()) _blinkTimer->start( BLINK_DELAY );
+  if (!_hasBlinker && _blinkTimer->isActive()) { _blinkTimer->stop(); _blinking = false; }
+  delete[] dirtyMask;
+  delete[] disstrU;
+
+}
+
+void TerminalView::showResizeNotification()
+{
+  if (_terminalSizeHint && isVisible())
+    {
+      if (_terminalSizeStartup) {
+          _terminalSizeStartup=false;
+          return;
+        }
+      if (!_resizeWidget)
+        {
+          _resizeWidget = new QLabel(("Size: XXX x XXX"), this);
+          _resizeWidget->setMinimumWidth(_resizeWidget->fontMetrics().width(("Size: XXX x XXX")));
+          _resizeWidget->setMinimumHeight(_resizeWidget->sizeHint().height());
+          _resizeWidget->setAlignment(Qt::AlignCenter);
+
+          _resizeWidget->setStyleSheet("background-color:palette(window);border-style:solid;border-width:1px;border-color:palette(dark)");
+
+          _resizeTimer = new QTimer(this);
+          _resizeTimer->setSingleShot(true);
+          connect(_resizeTimer, SIGNAL(timeout()), _resizeWidget, SLOT(hide()));
+
+        }
+      QString sizeStr;
+      sizeStr.sprintf("Size: %d x %d", _columns, _lines);
+      _resizeWidget->setText(sizeStr);
+      _resizeWidget->move((width()-_resizeWidget->width())/2,
+                          (height()-_resizeWidget->height())/2+20);
+      _resizeWidget->show();
+      _resizeTimer->start(1000);
+    }
+}
+
+void TerminalView::setBlinkingCursor(bool blink)
+{
+  _hasBlinkingCursor=blink;
+
+  if (blink && !_blinkCursorTimer->isActive())
+    _blinkCursorTimer->start(BLINK_DELAY);
+
+  if (!blink && _blinkCursorTimer->isActive())
+    {
+      _blinkCursorTimer->stop();
+      if (_cursorBlinking)
+        blinkCursorEvent();
+      else
+        _cursorBlinking = false;
+    }
+}
+
+void TerminalView::paintEvent( QPaintEvent* pe )
+{
+  updateImage();
+  //qDebug("%s %d paintEvent", __FILE__, __LINE__);
+  QPainter paint(this);
+  //qDebug("%s %d paintEvent %d %d", __FILE__, __LINE__, paint.window().top(), paint.window().right());
+
+  foreach (QRect rect, (pe->region() & contentsRect()).rects())
+    {
+      drawBackground(paint,rect,palette().background().color());
+      drawContents(paint, rect);
+    }
+  //    drawBackground(paint,contentsRect(),palette().background().color(),	true /* use opacity setting */);
+  //    drawContents(paint, contentsRect());
+  drawInputMethodPreeditString(paint,preeditRect());
+  paintFilters(paint);
+  paint.end();
+}
+
+QPoint TerminalView::cursorPosition() const
+{
+  if (_screenWindow)
+    return _screenWindow->cursorPosition();
+  else
+    return QPoint(0,0);
+}
+
+QRect TerminalView::preeditRect() const
+{
+  const int preeditLength = string_width(_inputMethodData.preeditString);
+
+  if ( preeditLength == 0 )
+    return QRect();
+
+  return QRect(_leftMargin + _fontWidth*cursorPosition().x(),
+               _topMargin + _fontHeight*cursorPosition().y(),
+               _fontWidth*preeditLength,
+               _fontHeight);
+}
+
+void TerminalView::drawInputMethodPreeditString(QPainter& painter , const QRect& rect)
+{
+  if ( _inputMethodData.preeditString.isEmpty() ) {
+      return;
+    }
+  const QPoint cursorPos = cursorPosition();
+
+  bool invertColors = false;
+  const QColor background = _colorTable[DEFAULT_BACK_COLOR].color;
+  const QColor foreground = _colorTable[DEFAULT_FORE_COLOR].color;
+  const Character* style = &_image[loc(cursorPos.x(),cursorPos.y())];
+
+  drawBackground(painter,rect,background);
+  drawCursor(painter,rect,foreground,background,invertColors);
+  drawCharacters(painter,rect,_inputMethodData.preeditString,style,invertColors);
+
+  _inputMethodData.previousPreeditRect = rect;
+}
+
+FilterChain* TerminalView::filterChain() const
+{
+  return _filterChain;
+}
+
+void TerminalView::paintFilters(QPainter& painter)
+{
+  //qDebug("%s %d paintFilters", __FILE__, __LINE__);
+
+  // get color of character under mouse and use it to draw
+  // lines for filters
+  QPoint cursorPos = mapFromGlobal(QCursor::pos());
+  int cursorLine;
+  int cursorColumn;
+  getCharacterPosition( cursorPos , cursorLine , cursorColumn );
+  Character cursorCharacter = _image[loc(cursorColumn,cursorLine)];
+
+  painter.setPen( QPen(cursorCharacter.foregroundColor.color(colorTable())) );
+
+  // iterate over hotspots identified by the display's currently active filters
+  // and draw appropriate visuals to indicate the presence of the hotspot
+
+  QList<Filter::HotSpot*> spots = _filterChain->hotSpots();
+  QListIterator<Filter::HotSpot*> iter(spots);
+  while (iter.hasNext())
+    {
+      Filter::HotSpot* spot = iter.next();
+
+      for ( int line = spot->startLine() ; line <= spot->endLine() ; line++ )
+        {
+          int startColumn = 0;
+          int endColumn = _columns-1; // TODO use number of _columns which are actually
+          // occupied on this line rather than the width of the
+          // display in _columns
+
+          // ignore whitespace at the end of the lines
+          while ( QChar(_image[loc(endColumn,line)].character).isSpace() && endColumn > 0 )
+            endColumn--;
+
+          // increment here because the column which we want to set 'endColumn' to
+          // is the first whitespace character at the end of the line
+          endColumn++;
+
+          if ( line == spot->startLine() )
+            startColumn = spot->startColumn();
+          if ( line == spot->endLine() )
+            endColumn = spot->endColumn();
+
+          // subtract one pixel from
+          // the right and bottom so that
+          // we do not overdraw adjacent
+          // hotspots
+          //
+          // subtracting one pixel from all sides also prevents an edge case where
+          // moving the mouse outside a link could still leave it underlined
+          // because the check below for the position of the cursor
+          // finds it on the border of the target area
+          QRect r;
+          r.setCoords( startColumn*_fontWidth + 1, line*_fontHeight + 1,
+                       endColumn*_fontWidth - 1, (line+1)*_fontHeight - 1 );
+
+          // Underline link hotspots
+          if ( spot->type() == Filter::HotSpot::Link )
+            {
+              QFontMetrics metrics(font());
+
+              // find the baseline (which is the invisible line that the characters in the font sit on,
+              // with some having tails dangling below)
+              int baseline = r.bottom() - metrics.descent();
+              // find the position of the underline below that
+              int underlinePos = baseline + metrics.underlinePos();
+
+              if ( r.contains( mapFromGlobal(QCursor::pos()) ) )
+                painter.drawLine( r.left() , underlinePos ,
+                                  r.right() , underlinePos );
+            }
+          // Marker hotspots simply have a transparent rectanglular shape
+          // drawn on top of them
+          else if ( spot->type() == Filter::HotSpot::Marker )
+            {
+              //TODO - Do not use a hardcoded colour for this
+              painter.fillRect(r,QBrush(QColor(255,0,0,120)));
+            }
+        }
+    }
+}
+void TerminalView::drawContents(QPainter &paint, const QRect &rect)
+{
+  //qDebug("%s %d drawContents and rect x=%d y=%d w=%d h=%d", __FILE__, __LINE__, rect.x(), rect.y(),rect.width(),rect.height());
+
+  QPoint topLeft  = contentsRect().topLeft();
+  // Take the topmost vertical position for the view.
+  int topLeftY = topLeft.y();
+
+  // In Konsole, the view has been centered. Don't do that here, since there
+  // are strange hopping effects during a resize when the view does no match
+  // exactly the widget width.
+  // int topLeftX = (_contentWidth - _usedColumns * _fontWidth) / 2;
+  int topLeftX = 0;
+
+  int leftUpperX = qMin(_usedColumns-1, qMax(0, qRound((rect.left()   - topLeftX - _leftMargin ) / _fontWidth)));
+  int leftUpperY = qMin(_usedLines-1,  qMax(0, qRound((rect.top()    - topLeftY - _topMargin  ) / _fontHeight)));
+  int rightLowerX = qMin(_usedColumns-1, qMax(0, qRound((rect.right()  - topLeftX - _leftMargin ) / _fontWidth)));
+  int rightLowerY = qMin(_usedLines-1,  qMax(0, qRound((rect.bottom() - topLeftY - _topMargin  ) / _fontHeight)));
+
+  const int bufferSize = _usedColumns;
+  QChar *disstrU = new QChar[bufferSize];
+  for (int y = leftUpperY; y <= rightLowerY; y++)
+    {
+      quint16 c = _image[loc(leftUpperX,y)].character;
+      int x = leftUpperX;
+      if(!c && x)
+        x--; // Search for start of multi-column character
+      for (; x <= rightLowerX; x++)
+        {
+          int len = 1;
+          int p = 0;
+
+          // is this a single character or a sequence of characters ?
+          if ( _image[loc(x,y)].rendition & RE_EXTENDED_CHAR )
+            {
+              // sequence of characters
+              ushort extendedCharLength = 0;
+              ushort* chars = ExtendedCharTable::instance
+                  .lookupExtendedChar(_image[loc(x,y)].charSequence,extendedCharLength);
+              for ( int index = 0 ; index < extendedCharLength ; index++ )
+                {
+                  Q_ASSERT( p < bufferSize );
+                  disstrU[p++] = chars[index];
+                }
+            }
+          else
+            {
+              // single character
+              c = _image[loc(x,y)].character;
+              if (c)
+                {
+                  Q_ASSERT( p < bufferSize );
+                  disstrU[p++] = c; //fontMap(c);
+                }
+            }
+
+          bool lineDraw = isLineChar(c);
+          bool doubleWidth = (_image[ qMin(loc(x,y)+1,_imageSize) ].character == 0);
+          CharacterColor currentForeground = _image[loc(x,y)].foregroundColor;
+          CharacterColor currentBackground = _image[loc(x,y)].backgroundColor;
+          quint8 currentRendition = _image[loc(x,y)].rendition;
+
+          while (x+len <= rightLowerX &&
+                 _image[loc(x+len,y)].foregroundColor == currentForeground &&
+                 _image[loc(x+len,y)].backgroundColor == currentBackground &&
+                 _image[loc(x+len,y)].rendition == currentRendition &&
+                 (_image[ qMin(loc(x+len,y)+1,_imageSize) ].character == 0) == doubleWidth &&
+                 isLineChar( c = _image[loc(x+len,y)].character) == lineDraw) // Assignment!
+            {
+              if (c)
+                disstrU[p++] = c; //fontMap(c);
+              if (doubleWidth) // assert((_image[loc(x+len,y)+1].character == 0)), see above if condition
+                len++; // Skip trailing part of multi-column character
+              len++;
+            }
+          if ((x+len < _usedColumns) && (!_image[loc(x+len,y)].character))
+            len++; // Adjust for trailing part of multi-column character
+
+          bool save__fixedFont = _fixedFont;
+          if (lineDraw)
+            _fixedFont = false;
+          if (doubleWidth)
+            _fixedFont = false;
+          QString unistr(disstrU,p);
+
+          if (y < _lineProperties.size())
+            {
+              if (_lineProperties[y] & LINE_DOUBLEWIDTH) {
+                  paint.scale(2,1);
+                }
+
+              if (_lineProperties[y] & LINE_DOUBLEHEIGHT) {
+                  paint.scale(1,2);
+                }
+            }
+
+          // calculate the area in which the text will be drawn
+          QRect textArea = QRect( _leftMargin+topLeftX+_fontWidth*x ,
+                                  _topMargin+topLeftY+_fontHeight*y ,
+                                  _fontWidth*len,
+                                  _fontHeight);
+
+          // move the calculated area to take account of scaling applied to the painter.
+          // the position of the area from the origin (0,0) is scaled
+          // by the opposite of whatever
+          // transformation has been applied to the painter.  this ensures that
+          // painting does actually start from textArea.topLeft()
+          // (instead of textArea.topLeft() * painter-scale)
+          QMatrix inverted = paint.matrix().inverted();
+          textArea.moveCenter( inverted.map(textArea.center()) );
+
+
+          //paint text fragment
+          drawTextFragment(	paint,
+                              textArea,
+                              unistr,
+                              &_image[loc(x,y)] );
+
+
+          _fixedFont = save__fixedFont;
+
+          //reset back to single-width, single-height _lines
+          paint.resetMatrix();
+
+          if (y < _lineProperties.size()-1)
+            {
+              //double-height _lines are represented by two adjacent _lines
+              //containing the same characters
+              //both _lines will have the LINE_DOUBLEHEIGHT attribute.
+              //If the current line has the LINE_DOUBLEHEIGHT attribute,
+              //we can therefore skip the next line
+              if (_lineProperties[y] & LINE_DOUBLEHEIGHT)
+                y++;
+            }
+          x += len - 1;
+        } // for x
+    } // for y
+  delete [] disstrU;
+}
+
+void TerminalView::blinkEvent()
+{
+  _blinking = !_blinking;
+
+  //TODO:  Optimise to only repaint the areas of the widget
+  // where there is blinking text
+  // rather than repainting the whole widget.
+  update();
+}
+
+QRect TerminalView::imageToWidget(const QRect& imageArea) const
+{
+  //qDebug("%s %d imageToWidget", __FILE__, __LINE__);
+  QRect result;
+  result.setLeft( _leftMargin + _fontWidth * imageArea.left() );
+  result.setTop( _topMargin + _fontHeight * imageArea.top() );
+  result.setWidth( _fontWidth * imageArea.width() );
+  result.setHeight( _fontHeight * imageArea.height() );
+
+  return result;
+}
+
+void TerminalView::blinkCursorEvent()
+{
+  _cursorBlinking = !_cursorBlinking;
+
+  QRect cursorRect = imageToWidget( QRect(cursorPosition(),QSize(1,1)) );
+
+  update(cursorRect);
+}
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                                  Resizing                                 */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+void TerminalView::resizeEvent(QResizeEvent*)
+{
+  updateImageSize();
+}
+
+void TerminalView::propagateSize()
+{
+  if (_isFixedSize)
+    {
+      setSize(_columns, _lines);
+      QWidget::setFixedSize(sizeHint());
+      parentWidget()->adjustSize();
+      parentWidget()->setFixedSize(parentWidget()->sizeHint());
+      return;
+    }
+  if (_image)
+    updateImageSize();
+}
+
+void TerminalView::updateImageSize()
+{
+  //qDebug("%s %d updateImageSize", __FILE__, __LINE__);
+  Character* oldimg = _image;
+  int oldlin = _lines;
+  int oldcol = _columns;
+
+  makeImage();
+
+
+  // copy the old image to reduce flicker
+  int lines = qMin(oldlin,_lines);
+  int columns = qMin(oldcol,_columns);
+
+  //qDebug("%s %d updateImageSize", __FILE__, __LINE__);
+  if (oldimg)
+    {
+      for (int line = 0; line < lines; line++)
+        {
+          memcpy((void*)&_image[_columns*line],
+                 (void*)&oldimg[oldcol*line],columns*sizeof(Character));
+        }
+      delete[] oldimg;
+    }
+
+  //qDebug("%s %d updateImageSize", __FILE__, __LINE__);
+  if (_screenWindow)
+    _screenWindow->setWindowLines(_lines);
+
+  _resizing = (oldlin!=_lines) || (oldcol!=_columns);
+
+  if ( _resizing )
+    {
+      //qDebug("%s %d updateImageSize", __FILE__, __LINE__);
+      showResizeNotification();
+      emit changedContentSizeSignal(_contentHeight, _contentWidth); // expose resizeEvent
+    }
+  //qDebug("%s %d updateImageSize", __FILE__, __LINE__);
+
+  _resizing = false;
+}
+
+//showEvent and hideEvent are reimplemented here so that it appears to other classes that the
+//display has been resized when the display is hidden or shown.
+//
+//this allows
+//TODO: Perhaps it would be better to have separate signals for show and hide instead of using
+//the same signal as the one for a content size change
+void TerminalView::showEvent(QShowEvent*)
+{
+  emit changedContentSizeSignal(_contentHeight,_contentWidth);
+}
+void TerminalView::hideEvent(QHideEvent*)
+{
+  emit changedContentSizeSignal(_contentHeight,_contentWidth);
+}
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                                Scrollbar                                  */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+void TerminalView::scrollBarPositionChanged(int)
+{
+  if ( !_screenWindow )
+    return;
+
+  _screenWindow->scrollTo( _scrollBar->value() );
+
+  // if the thumb has been moved to the bottom of the _scrollBar then set
+  // the display to automatically track new output,
+  // that is, scroll down automatically
+  // to how new _lines as they are added
+  const bool atEndOfOutput = (_scrollBar->value() == _scrollBar->maximum());
+  _screenWindow->setTrackOutput( atEndOfOutput );
+
+  updateImage();
+}
+
+void TerminalView::setScroll(int cursor, int slines)
+{
+  //qDebug("%s %d setScroll", __FILE__, __LINE__);
+  // update _scrollBar if the range or value has changed,
+  // otherwise return
+  //
+  // setting the range or value of a _scrollBar will always trigger
+  // a repaint, so it should be avoided if it is not necessary
+  if ( _scrollBar->minimum() == 0                 &&
+       _scrollBar->maximum() == (slines - _lines) &&
+       _scrollBar->value()   == cursor )
+    {
+      return;
+    }
+
+  disconnect(_scrollBar, SIGNAL(valueChanged(int)), this, SLOT(scrollBarPositionChanged(int)));
+  _scrollBar->setRange(0,slines - _lines);
+  _scrollBar->setSingleStep(1);
+  _scrollBar->setPageStep(_lines);
+  _scrollBar->setValue(cursor);
+  connect(_scrollBar, SIGNAL(valueChanged(int)), this, SLOT(scrollBarPositionChanged(int)));
+}
+
+void TerminalView::setScrollBarPosition(ScrollBarPosition position)
+{
+  if (_scrollbarLocation == position) {
+      //      return;
+    }
+
+  if ( position == NoScrollBar )
+    _scrollBar->hide();
+  else
+    _scrollBar->show();
+
+  _topMargin = _leftMargin = 1;
+  _scrollbarLocation = position;
+
+  propagateSize();
+  update();
+}
+
+void TerminalView::mousePressEvent(QMouseEvent* ev)
+{
+  if ( _possibleTripleClick && (ev->button()==Qt::LeftButton) ) {
+      mouseTripleClickEvent(ev);
+      return;
+    }
+
+  if ( !contentsRect().contains(ev->pos()) ) return;
+
+  if ( !_screenWindow ) return;
+
+  int charLine;
+  int charColumn;
+  getCharacterPosition(ev->pos(),charLine,charColumn);
+  QPoint pos = QPoint(charColumn,charLine);
+
+  if ( ev->button() == Qt::LeftButton)
+    {
+      _lineSelectionMode = false;
+      _wordSelectionMode = false;
+
+      emit isBusySelecting(true); // Keep it steady...
+      // Drag only when the Control key is hold
+      bool selected = false;
+
+      // The receiver of the testIsSelected() signal will adjust
+      // 'selected' accordingly.
+      //emit testIsSelected(pos.x(), pos.y(), selected);
+
+      selected =  _screenWindow->isSelected(pos.x(),pos.y());
+
+      if ((!_ctrlDrag || ev->modifiers() & Qt::ControlModifier) && selected ) {
+          // The user clicked inside selected text
+          dragInfo.state = diPending;
+          dragInfo.start = ev->pos();
+        }
+      else {
+          // No reason to ever start a drag event
+          dragInfo.state = diNone;
+
+          _preserveLineBreaks = !( ( ev->modifiers() & Qt::ControlModifier ) && !(ev->modifiers() & Qt::AltModifier) );
+          _columnSelectionMode = (ev->modifiers() & Qt::AltModifier) && (ev->modifiers() & Qt::ControlModifier);
+
+          if (_mouseMarks || (ev->modifiers() & Qt::ShiftModifier))
+            {
+              _screenWindow->clearSelection();
+
+              //emit clearSelectionSignal();
+              pos.ry() += _scrollBar->value();
+              _iPntSel = _pntSel = pos;
+              _actSel = 1; // left mouse button pressed but nothing selected yet.
+
+            }
+          else
+            {
+              emit mouseSignal( 0, charColumn + 1, charLine + 1 +_scrollBar->value() -_scrollBar->maximum() , 0);
+            }
+        }
+    }
+  else if ( ev->button() == Qt::MidButton )
+    {
+      if ( _mouseMarks || (!_mouseMarks && (ev->modifiers() & Qt::ShiftModifier)) )
+        emitSelection(true,ev->modifiers() & Qt::ControlModifier);
+      else
+        emit mouseSignal( 1, charColumn +1, charLine +1 +_scrollBar->value() -_scrollBar->maximum() , 0);
+    }
+  else if ( ev->button() == Qt::RightButton )
+    {
+      if (_mouseMarks || (ev->modifiers() & Qt::ShiftModifier))
+        {
+          emit configureRequest( this,
+                                 ev->modifiers() & (Qt::ShiftModifier|Qt::ControlModifier),
+                                 ev->pos()
+                                 );
+        }
+      else
+        emit mouseSignal( 2, charColumn +1, charLine +1 +_scrollBar->value() -_scrollBar->maximum() , 0);
+    }
+
+  QWidget::mousePressEvent (ev);
+}
+
+QList<QAction*> TerminalView::filterActions(const QPoint& position)
+{
+  int charLine, charColumn;
+  getCharacterPosition(position,charLine,charColumn);
+
+  Filter::HotSpot* spot = _filterChain->hotSpotAt(charLine,charColumn);
+
+  return spot ? spot->actions() : QList<QAction*>();
+}
+
+void TerminalView::mouseMoveEvent(QMouseEvent* ev)
+{
+  int charLine = 0;
+  int charColumn = 0;
+
+  getCharacterPosition(ev->pos(),charLine,charColumn);
+
+  // handle filters
+  // change link hot-spot appearance on mouse-over
+  Filter::HotSpot* spot = _filterChain->hotSpotAt(charLine,charColumn);
+  if ( spot && spot->type() == Filter::HotSpot::Link)
+    {
+      QRect previousHotspotArea = _mouseOverHotspotArea;
+      _mouseOverHotspotArea.setCoords( qMin(spot->startColumn() , spot->endColumn()) * _fontWidth,
+                                       spot->startLine() * _fontHeight,
+                                       qMax(spot->startColumn() , spot->endColumn()) * _fontHeight,
+                                       (spot->endLine()+1) * _fontHeight );
+
+      // display tooltips when mousing over links
+      // TODO: Extend this to work with filter types other than links
+      const QString& tooltip = spot->tooltip();
+      if ( !tooltip.isEmpty() )
+        {
+          QToolTip::showText( mapToGlobal(ev->pos()) , tooltip , this , _mouseOverHotspotArea );
+        }
+
+      update( _mouseOverHotspotArea | previousHotspotArea );
+    }
+  else if ( _mouseOverHotspotArea.isValid() )
+    {
+      update( _mouseOverHotspotArea );
+      // set hotspot area to an invalid rectangle
+      _mouseOverHotspotArea = QRect();
+    }
+
+  // for auto-hiding the cursor, we need mouseTracking
+  if (ev->buttons() == Qt::NoButton ) return;
+
+  // if the terminal is interested in mouse movements
+  // then emit a mouse movement signal, unless the shift
+  // key is being held down, which overrides this.
+  if (!_mouseMarks && !(ev->modifiers() & Qt::ShiftModifier))
+    {
+      int button = 3;
+      if (ev->buttons() & Qt::LeftButton)
+        button = 0;
+      if (ev->buttons() & Qt::MidButton)
+        button = 1;
+      if (ev->buttons() & Qt::RightButton)
+        button = 2;
+
+
+      emit mouseSignal( button,
+                        charColumn + 1,
+                        charLine + 1 +_scrollBar->value() -_scrollBar->maximum(),
+                        1 );
+
+      return;
+    }
+
+  if (dragInfo.state == diPending)
+    {
+      // we had a mouse down, but haven't confirmed a drag yet
+      // if the mouse has moved sufficiently, we will confirm
+
+      int distance = 10; //KGlobalSettings::dndEventDelay();
+      if ( ev->x() > dragInfo.start.x() + distance || ev->x() < dragInfo.start.x() - distance ||
+           ev->y() > dragInfo.start.y() + distance || ev->y() < dragInfo.start.y() - distance)
+        {
+          // we've left the drag square, we can start a real drag operation now
+          emit isBusySelecting(false); // Ok.. we can breath again.
+
+          _screenWindow->clearSelection();
+          doDrag();
+        }
+      return;
+    }
+  else if (dragInfo.state == diDragging)
+    {
+      // this isn't technically needed because mouseMoveEvent is suppressed during
+      // Qt drag operations, replaced by dragMoveEvent
+      return;
+    }
+
+  if (_actSel == 0) return;
+
+  // don't extend selection while pasting
+  if (ev->buttons() & Qt::MidButton) return;
+
+  extendSelection( ev->pos() );
+}
+
+#if 0
+void TerminalDisplay::setSelectionEnd()
+{
+  extendSelection( _configureRequestPoint );
+}
+#endif
+
+void TerminalView::extendSelection(const QPoint& position) {
+  QPoint pos = position;
+
+  if (!_screenWindow) {
+      return;
+    }
+
+  QPoint tL  = contentsRect().topLeft();
+  int    tLx = tL.x();
+  int    tLy = tL.y();
+  int    scroll = _scrollBar->value();
+
+  // we're in the process of moving the mouse with the left button pressed
+  // the mouse cursor will kept caught within the bounds of the text in
+  // this widget.
+
+  // Adjust position within text area bounds. See FIXME above.
+  if (pos.x() < tLx + _leftMargin) {
+      pos.setX(tLx + _leftMargin);
+    }
+  if (pos.x() > tLx + _leftMargin + _usedColumns * _fontWidth - 1) {
+      pos.setX(tLx + _leftMargin + _usedColumns * _fontWidth);
+    }
+  if (pos.y() < tLy + _topMargin) {
+      pos.setY(tLy + _topMargin);
+    }
+  if (pos.y() > tLy + _topMargin + _usedLines * _fontHeight - 1) {
+      pos.setY(tLy + _topMargin + _usedLines * _fontHeight - 1);
+    }
+
+  if (pos.y() == tLy + _topMargin + _usedLines * _fontHeight - 1) {
+      _scrollBar->setValue(_scrollBar->value() + yMouseScroll); // scrollforward
+    }
+  if (pos.y() == tLy + _topMargin) {
+      _scrollBar->setValue(_scrollBar->value() - yMouseScroll); // scrollback
+    }
+
+  int charColumn = 0;
+  int charLine = 0;
+  getCharacterPosition(pos, charLine, charColumn);
+
+  QPoint here = QPoint(charColumn, charLine);
+  QPoint ohere(here);
+  QPoint _iPntSelCorr = _iPntSel;
+  _iPntSelCorr.ry() -= _scrollBar->value();
+  QPoint _pntSelCorr = _pntSel;
+  _pntSelCorr.ry() -= _scrollBar->value();
+  bool swapping = false;
+
+  if (_wordSelectionMode) {
+      // Extend to word boundaries
+      int i = 0;
+      int selClass = 0;
+
+      bool left_not_right = (here.y() < _iPntSelCorr.y() ||
+                             (here.y() == _iPntSelCorr.y() && here.x() < _iPntSelCorr.x()));
+      bool old_left_not_right = (_pntSelCorr.y() < _iPntSelCorr.y() ||
+                                 (_pntSelCorr.y() == _iPntSelCorr.y() && _pntSelCorr.x() < _iPntSelCorr.x()));
+      swapping = left_not_right != old_left_not_right;
+
+      // Find left (left_not_right ? from here : from start)
+      QPoint left = left_not_right ? here : _iPntSelCorr;
+      i = loc(left.x(), left.y());
+      if (i >= 0 && i <= _imageSize) {
+          selClass = charClass(_image[i].character);
+          while (((left.x() > 0) || (left.y() > 0 && (_lineProperties[left.y() - 1] & LINE_WRAPPED)))
+                 && charClass(_image[i - 1].character) == selClass) {
+              i--;
+              if (left.x() > 0) {
+                  left.rx()--;
+                } else {
+                  left.rx() = _usedColumns - 1;
+                  left.ry()--;
+                }
+            }
+        }
+
+      // Find left (left_not_right ? from start : from here)
+      QPoint right = left_not_right ? _iPntSelCorr : here;
+      i = loc(right.x(), right.y());
+      if (i >= 0 && i <= _imageSize) {
+          selClass = charClass(_image[i].character);
+          while (((right.x() < _usedColumns - 1) || (right.y() < _usedLines - 1 && (_lineProperties[right.y()] & LINE_WRAPPED)))
+                 && charClass(_image[i + 1].character) == selClass) {
+              i++;
+              if (right.x() < _usedColumns - 1) {
+                  right.rx()++;
+                } else {
+                  right.rx() = 0;
+                  right.ry()++;
+                }
+            }
+        }
+
+      // Pick which is start (ohere) and which is extension (here)
+      if (left_not_right) {
+          here = left;
+          ohere = right;
+        } else {
+          here = right;
+          ohere = left;
+        }
+      ohere.rx()++;
+    }
+
+  if (_lineSelectionMode) {
+      // Extend to complete line
+      bool above_not_below = (here.y() < _iPntSelCorr.y());
+
+      QPoint above = above_not_below ? here : _iPntSelCorr;
+      QPoint below = above_not_below ? _iPntSelCorr : here;
+
+      while (above.y() > 0 && (_lineProperties[above.y() - 1] & LINE_WRAPPED)) {
+          above.ry()--;
+        }
+      while (below.y() < _usedLines - 1 && (_lineProperties[below.y()] & LINE_WRAPPED)) {
+          below.ry()++;
+        }
+
+      above.setX(0);
+      below.setX(_usedColumns - 1);
+
+      // Pick which is start (ohere) and which is extension (here)
+      if (above_not_below) {
+          here = above;
+          ohere = below;
+        } else {
+          here = below;
+          ohere = above;
+        }
+
+      QPoint newSelBegin = QPoint(ohere.x(), ohere.y());
+      swapping = !(_tripleSelBegin == newSelBegin);
+      _tripleSelBegin = newSelBegin;
+
+      ohere.rx()++;
+    }
+
+  int offset = 0;
+  if (!_wordSelectionMode && !_lineSelectionMode) {
+      int i = 0;
+      int selClass = 0;
+
+      bool left_not_right = (here.y() < _iPntSelCorr.y() ||
+                             (here.y() == _iPntSelCorr.y() && here.x() < _iPntSelCorr.x()));
+      bool old_left_not_right = (_pntSelCorr.y() < _iPntSelCorr.y() ||
+                                 (_pntSelCorr.y() == _iPntSelCorr.y() && _pntSelCorr.x() < _iPntSelCorr.x()));
+      swapping = left_not_right != old_left_not_right;
+
+      // Find left (left_not_right ? from here : from start)
+      QPoint left = left_not_right ? here : _iPntSelCorr;
+
+      // Find left (left_not_right ? from start : from here)
+      QPoint right = left_not_right ? _iPntSelCorr : here;
+      if (right.x() > 0 && !_columnSelectionMode) {
+          i = loc(right.x(), right.y());
+          if (i >= 0 && i <= _imageSize) {
+              selClass = charClass(_image[i - 1].character);
+              if (selClass == ' ') {
+                  while (right.x() < _usedColumns - 1 && charClass(_image[i + 1].character) == selClass && (right.y() < _usedLines - 1) &&
+                         !(_lineProperties[right.y()] & LINE_WRAPPED)) {
+                      i++;
+                      right.rx()++;
+                    }
+                  if (right.x() < _usedColumns - 1) {
+                      right = left_not_right ? _iPntSelCorr : here;
+                    } else {
+                      right.rx()++;  // will be balanced later because of offset=-1;
+                    }
+                }
+            }
+        }
+
+      // Pick which is start (ohere) and which is extension (here)
+      if (left_not_right) {
+          here = left;
+          ohere = right;
+          offset = 0;
+        } else {
+          here = right;
+          ohere = left;
+          offset = -1;
+        }
+    }
+
+  if ((here == _pntSelCorr) && (scroll == _scrollBar->value())) {
+      return; // not moved
+    }
+
+  if (here == ohere) {
+      return; // It's not left, it's not right.
+    }
+
+  if (_actSel < 2 || swapping) {
+      if (_columnSelectionMode && !_lineSelectionMode && !_wordSelectionMode) {
+          _screenWindow->setSelectionStart(ohere.x(), ohere.y(), true);
+        } else {
+          _screenWindow->setSelectionStart(ohere.x() - 1 - offset , ohere.y(), false);
+        }
+
+    }
+
+  _actSel = 2; // within selection
+  _pntSel = here;
+  _pntSel.ry() += _scrollBar->value();
+
+  if (_columnSelectionMode && !_lineSelectionMode && !_wordSelectionMode) {
+      _screenWindow->setSelectionEnd(here.x(), here.y());
+    } else {
+      _screenWindow->setSelectionEnd(here.x() + offset, here.y());
+    }
+}
+
+void TerminalView::mouseReleaseEvent(QMouseEvent* ev)
+{
+  if ( !_screenWindow )
+    return;
+
+  int charLine;
+  int charColumn;
+  getCharacterPosition(ev->pos(),charLine,charColumn);
+
+  if ( ev->button() == Qt::LeftButton)
+    {
+      emit isBusySelecting(false);
+      if(dragInfo.state == diPending)
+        {
+          // We had a drag event pending but never confirmed.  Kill selection
+          _screenWindow->clearSelection();
+          //emit clearSelectionSignal();
+        }
+      else
+        {
+          if ( _actSel > 1 )
+            {
+              setSelection(  _screenWindow->selectedText(_preserveLineBreaks)  );
+            }
+
+          _actSel = 0;
+
+          //FIXME: emits a release event even if the mouse is
+          //       outside the range. The procedure used in `mouseMoveEvent'
+          //       applies here, too.
+
+          if (!_mouseMarks && !(ev->modifiers() & Qt::ShiftModifier))
+            emit mouseSignal( 3, // release
+                              charColumn + 1,
+                              charLine + 1 +_scrollBar->value() -_scrollBar->maximum() , 0);
+        }
+      dragInfo.state = diNone;
+    }
+
+
+  if ( !_mouseMarks &&
+       ((ev->button() == Qt::RightButton && !(ev->modifiers() & Qt::ShiftModifier))
+        || ev->button() == Qt::MidButton) )
+    {
+      emit mouseSignal( 3,
+                        charColumn + 1,
+                        charLine + 1 +_scrollBar->value() -_scrollBar->maximum() ,
+                        0);
+    }
+
+  QWidget::mouseReleaseEvent(ev);
+}
+
+void TerminalView::getCharacterPosition(const QPoint& widgetPoint,int& line,int& column) const
+{
+
+  column = (widgetPoint.x() + _fontWidth/2 -contentsRect().left()-_leftMargin) / _fontWidth;
+  line = (widgetPoint.y()-contentsRect().top()-_topMargin) / _fontHeight;
+
+  if ( line < 0 )
+    line = 0;
+  if ( column < 0 )
+    column = 0;
+
+  if ( line >= _usedLines )
+    line = _usedLines-1;
+
+  // the column value returned can be equal to _usedColumns, which
+  // is the position just after the last character displayed in a line.
+  //
+  // this is required so that the user can select characters in the right-most
+  // column (or left-most for right-to-left input)
+  if ( column > _usedColumns )
+    column = _usedColumns;
+}
+
+void TerminalView::updateLineProperties()
+{
+  if ( !_screenWindow )
+    return;
+
+  _lineProperties = _screenWindow->getLineProperties();
+}
+
+void TerminalView::mouseDoubleClickEvent(QMouseEvent* ev)
+{
+  if ( ev->button() != Qt::LeftButton) return;
+  if ( !_screenWindow ) return;
+
+  int charLine = 0;
+  int charColumn = 0;
+
+  getCharacterPosition(ev->pos(),charLine,charColumn);
+
+  QPoint pos(charColumn,charLine);
+
+  // pass on double click as two clicks.
+  if (!_mouseMarks && !(ev->modifiers() & Qt::ShiftModifier))
+    {
+      // Send just _ONE_ click event, since the first click of the double click
+      // was already sent by the click handler
+      emit mouseSignal( 0,
+                        pos.x()+1,
+                        pos.y()+1 +_scrollBar->value() -_scrollBar->maximum(),
+                        0 ); // left button
+      return;
+    }
+
+  _screenWindow->clearSelection();
+  QPoint bgnSel = pos;
+  QPoint endSel = pos;
+  int i = loc(bgnSel.x(),bgnSel.y());
+  _iPntSel = bgnSel;
+  _iPntSel.ry() += _scrollBar->value();
+
+  _wordSelectionMode = true;
+
+  // find word boundaries...
+  int selClass = charClass(_image[i].character);
+  {
+    // find the start of the word
+    int x = bgnSel.x();
+    while ( ((x>0) || (bgnSel.y()>0 && (_lineProperties[bgnSel.y()-1] & LINE_WRAPPED) ))
+            && charClass(_image[i-1].character) == selClass )
+      {
+        i--;
+        if (x>0)
+          x--;
+        else
+          {
+            x=_usedColumns-1;
+            bgnSel.ry()--;
+          }
+      }
+
+    bgnSel.setX(x);
+    _screenWindow->setSelectionStart( bgnSel.x() , bgnSel.y() , false );
+
+    // find the end of the word
+    i = loc( endSel.x(), endSel.y() );
+    x = endSel.x();
+    while( ((x<_usedColumns-1) || (endSel.y()<_usedLines-1 && (_lineProperties[endSel.y()] & LINE_WRAPPED) ))
+           && charClass(_image[i+1].character) == selClass )
+      {
+        i++;
+        if (x<_usedColumns-1)
+          x++;
+        else
+          {
+            x=0;
+            endSel.ry()++;
+          }
+      }
+
+    endSel.setX(x);
+
+    // In word selection mode don't select @ (64) if at end of word.
+    if ( ( QChar( _image[i].character ) == '@' ) && ( ( endSel.x() - bgnSel.x() ) > 0 ) )
+      endSel.setX( x - 1 );
+
+
+    _actSel = 2; // within selection
+
+    _screenWindow->setSelectionEnd( endSel.x() , endSel.y() );
+
+    setSelection( _screenWindow->selectedText(_preserveLineBreaks) );
+  }
+
+  _possibleTripleClick=true;
+
+  QTimer::singleShot(QApplication::doubleClickInterval(),this,
+                     SLOT(tripleClickTimeout()));
+}
+
+void TerminalView::wheelEvent( QWheelEvent* ev )
+{
+  if (ev->orientation() != Qt::Vertical)
+    return;
+
+  if ( _mouseMarks )
+    _scrollBar->event(ev);
+  else
+    {
+      int charLine;
+      int charColumn;
+      getCharacterPosition( ev->pos() , charLine , charColumn );
+
+      emit mouseSignal( ev->delta() > 0 ? 4 : 5,
+                        charColumn + 1,
+                        charLine + 1 +_scrollBar->value() -_scrollBar->maximum() ,
+                        0);
+    }
+}
+
+void TerminalView::tripleClickTimeout()
+{
+  _possibleTripleClick=false;
+}
+
+void TerminalView::mouseTripleClickEvent(QMouseEvent* ev)
+{
+  if ( !_screenWindow ) return;
+
+  int charLine;
+  int charColumn;
+  getCharacterPosition(ev->pos(),charLine,charColumn);
+  _iPntSel = QPoint(charColumn,charLine);
+
+  _screenWindow->clearSelection();
+
+  _lineSelectionMode = true;
+  _wordSelectionMode = false;
+
+  _actSel = 2; // within selection
+  emit isBusySelecting(true); // Keep it steady...
+
+  while (_iPntSel.y()>0 && (_lineProperties[_iPntSel.y()-1] & LINE_WRAPPED) )
+    _iPntSel.ry()--;
+
+  if (_tripleClickMode == SelectForwardsFromCursor) {
+      // find word boundary start
+      int i = loc(_iPntSel.x(),_iPntSel.y());
+      int selClass = charClass(_image[i].character);
+      int x = _iPntSel.x();
+
+      while ( ((x>0) ||
+               (_iPntSel.y()>0 && (_lineProperties[_iPntSel.y()-1] & LINE_WRAPPED) )
+               )
+              && charClass(_image[i-1].character) == selClass )
+        {
+          i--;
+          if (x>0)
+            x--;
+          else
+            {
+              x=_columns-1;
+              _iPntSel.ry()--;
+            }
+        }
+
+      _screenWindow->setSelectionStart( x , _iPntSel.y() , false );
+      _tripleSelBegin = QPoint( x, _iPntSel.y() );
+    }
+  else if (_tripleClickMode == SelectWholeLine) {
+      _screenWindow->setSelectionStart( 0 , _iPntSel.y() , false );
+      _tripleSelBegin = QPoint( 0, _iPntSel.y() );
+    }
+
+  while (_iPntSel.y()<_lines-1 && (_lineProperties[_iPntSel.y()] & LINE_WRAPPED) )
+    _iPntSel.ry()++;
+
+  _screenWindow->setSelectionEnd( _columns - 1 , _iPntSel.y() );
+
+  setSelection(_screenWindow->selectedText(_preserveLineBreaks));
+
+  _iPntSel.ry() += _scrollBar->value();
+
+  emit tripleClicked( _screenWindow->selectedText( _preserveLineBreaks ) );
+}
+
+
+bool TerminalView::focusNextPrevChild( bool next )
+{
+  if (next)
+    return false; // This disables changing the active part in konqueror
+  // when pressing Tab
+  return QWidget::focusNextPrevChild( next );
+}
+
+
+int TerminalView::charClass(quint16 ch) const
+{
+  QChar qch=QChar(ch);
+  if ( qch.isSpace() ) return ' ';
+
+  if ( qch.isLetterOrNumber() || _wordCharacters.contains(qch, Qt::CaseInsensitive ) )
+    return 'a';
+
+  // Everything else is weird
+  return 1;
+}
+
+void TerminalView::setWordCharacters(const QString& wc)
+{
+  _wordCharacters = wc;
+}
+
+void TerminalView::setUsesMouse(bool on)
+{
+  _mouseMarks = on;
+  setCursor( _mouseMarks ? Qt::IBeamCursor : Qt::ArrowCursor );
+}
+bool TerminalView::usesMouse() const
+{
+  return _mouseMarks;
+}
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                               Clipboard                                   */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+#undef KeyPress
+
+void TerminalView::emitSelection(bool useXselection,bool appendReturn)
+{
+  if ( !_screenWindow )
+    return;
+
+  // Paste Clipboard by simulating keypress events
+  QString text = QApplication::clipboard()->text(useXselection ? QClipboard::Selection :
+                                                                 QClipboard::Clipboard);
+  if(appendReturn)
+    text.append("\r");
+  if ( ! text.isEmpty() )
+    {
+      text.replace("\n", "\r");
+      QKeyEvent e(QEvent::KeyPress, 0, Qt::NoModifier, text);
+      emit keyPressedSignal(&e); // expose as a big fat keypress event
+
+      _screenWindow->clearSelection();
+    }
+}
+
+void TerminalView::setSelection(const QString& t)
+{
+  QApplication::clipboard()->setText(t, QClipboard::Selection);
+}
+
+void TerminalView::copyClipboard()
+{
+  if ( !_screenWindow )
+    return;
+
+  QString text = _screenWindow->selectedText(_preserveLineBreaks);
+  QApplication::clipboard()->setText(text);
+}
+
+void TerminalView::pasteClipboard()
+{
+  emitSelection(false,false);
+}
+
+void TerminalView::pasteSelection()
+{
+  emitSelection(true,false);
+}
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                                Keyboard                                   */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+void TerminalView::keyPressEvent( QKeyEvent* event )
+{
+  //qDebug("%s %d keyPressEvent and key is %d", __FILE__, __LINE__, event->key());
+
+  bool emitKeyPressSignal = true;
+
+  // Keyboard-based navigation
+  if ( event->modifiers() == Qt::ShiftModifier )
+    {
+      bool update = true;
+
+      if ( event->key() == Qt::Key_PageUp )
+        {
+          //qDebug("%s %d pageup", __FILE__, __LINE__);
+          _screenWindow->scrollBy( ScreenWindow::ScrollPages , -1 );
+        }
+      else if ( event->key() == Qt::Key_PageDown )
+        {
+          //qDebug("%s %d pagedown", __FILE__, __LINE__);
+          _screenWindow->scrollBy( ScreenWindow::ScrollPages , 1 );
+        }
+      else if ( event->key() == Qt::Key_Up )
+        {
+          //qDebug("%s %d keyup", __FILE__, __LINE__);
+          _screenWindow->scrollBy( ScreenWindow::ScrollLines , -1 );
+        }
+      else if ( event->key() == Qt::Key_Down )
+        {
+          //qDebug("%s %d keydown", __FILE__, __LINE__);
+          _screenWindow->scrollBy( ScreenWindow::ScrollLines , 1 );
+        }
+      else {
+          update = false;
+        }
+
+      if ( update )
+        {
+          //qDebug("%s %d updating", __FILE__, __LINE__);
+          _screenWindow->setTrackOutput( _screenWindow->atEndOfOutput() );
+
+          updateLineProperties();
+          updateImage();
+
+          // do not send key press to terminal
+          emitKeyPressSignal = false;
+        }
+    }
+
+  _screenWindow->setTrackOutput( true );
+
+  _actSel=0; // Key stroke implies a screen update, so TerminalDisplay won't
+  // know where the current selection is.
+
+  if (_hasBlinkingCursor)
+    {
+      _blinkCursorTimer->start(BLINK_DELAY);
+      if (_cursorBlinking)
+        blinkCursorEvent();
+      else
+        _cursorBlinking = false;
+    }
+
+  if ( emitKeyPressSignal && !_readonly )
+    emit keyPressedSignal(event);
+
+  if (_readonly) {
+      event->ignore();
+    }
+  else {
+      event->accept();
+    }
+}
+
+void TerminalView::inputMethodEvent( QInputMethodEvent* event )
+{
+  QKeyEvent keyEvent(QEvent::KeyPress,0,Qt::NoModifier,event->commitString());
+  emit keyPressedSignal(&keyEvent);
+
+  _inputMethodData.preeditString = event->preeditString();
+  update(preeditRect() | _inputMethodData.previousPreeditRect);
+
+  event->accept();
+}
+QVariant TerminalView::inputMethodQuery( Qt::InputMethodQuery query ) const
+{
+  const QPoint cursorPos = _screenWindow ? _screenWindow->cursorPosition() : QPoint(0,0);
+  switch ( query )
+    {
+    case Qt::ImMicroFocus:
+      return imageToWidget(QRect(cursorPos.x(),cursorPos.y(),1,1));
+      break;
+    case Qt::ImFont:
+      return font();
+      break;
+    case Qt::ImCursorPosition:
+      // return the cursor position within the current line
+      return cursorPos.x();
+      break;
+    case Qt::ImSurroundingText:
+      {
+        // return the text from the current line
+        QString lineText;
+        QTextStream stream(&lineText);
+        PlainTextDecoder decoder;
+        decoder.begin(&stream);
+        decoder.decodeLine(&_image[loc(0,cursorPos.y())],_usedColumns,_lineProperties[cursorPos.y()]);
+        decoder.end();
+        return lineText;
+      }
+      break;
+    case Qt::ImCurrentSelection:
+      return QString();
+      break;
+    default:
+      break;
+    }
+
+  return QVariant();
+}
+
+bool TerminalView::event( QEvent *e )
+{
+  if ( e->type() == QEvent::ShortcutOverride )
+    {
+      QKeyEvent* keyEvent = static_cast<QKeyEvent *>( e );
+
+      // a check to see if keyEvent->text() is empty is used
+      // to avoid intercepting the press of the modifier key on its own.
+      //
+      // this is important as it allows a press and release of the Alt key
+      // on its own to focus the menu bar, making it possible to
+      // work with the menu without using the mouse
+      if ( (keyEvent->modifiers() == Qt::AltModifier) &&
+           !keyEvent->text().isEmpty() )
+        {
+          keyEvent->accept();
+          return true;
+        }
+
+      // Override any of the following shortcuts because
+      // they are needed by the terminal
+      int keyCode = keyEvent->key() | keyEvent->modifiers();
+      switch ( keyCode )
+        {
+        // list is taken from the QLineEdit::event() code
+        case Qt::Key_Tab:
+        case Qt::Key_Delete:
+        case Qt::Key_Home:
+        case Qt::Key_End:
+        case Qt::Key_Backspace:
+        case Qt::Key_Left:
+        case Qt::Key_Right:
+          keyEvent->accept();
+          return true;
+        }
+    }
+  return QWidget::event( e );
+}
+
+void TerminalView::setBellMode(int mode)
+{
+  _bellMode=mode;
+}
+
+void TerminalView::enableBell()
+{
+  _allowBell = true;
+}
+
+void TerminalView::swapColorTable()
+{
+  ColorEntry color = _colorTable[1];
+  _colorTable[1]=_colorTable[0];
+  _colorTable[0]= color;
+  _colorsInverted = !_colorsInverted;
+  update();
+}
+
+void TerminalView::clearImage()
+{
+  // We initialize _image[_imageSize] too. See makeImage()
+  for (int i = 0; i <= _imageSize; i++)
+    {
+      _image[i].character = ' ';
+      _image[i].foregroundColor = CharacterColor(COLOR_SPACE_DEFAULT,
+                                                 DEFAULT_FORE_COLOR);
+      _image[i].backgroundColor = CharacterColor(COLOR_SPACE_DEFAULT,
+                                                 DEFAULT_BACK_COLOR);
+      _image[i].rendition = DEFAULT_RENDITION;
+    }
+}
+
+void TerminalView::calcGeometry()
+{
+  _scrollBar->resize(QApplication::style()->pixelMetric(QStyle::PM_ScrollBarExtent),
+                     contentsRect().height());
+  switch(_scrollbarLocation)
+    {
+    case NoScrollBar :
+      _leftMargin = DEFAULT_LEFT_MARGIN;
+      _contentWidth = contentsRect().width() - 2 * DEFAULT_LEFT_MARGIN;
+      break;
+    case ScrollBarLeft :
+      _leftMargin = DEFAULT_LEFT_MARGIN + _scrollBar->width();
+      _contentWidth = contentsRect().width() - 2 * DEFAULT_LEFT_MARGIN - _scrollBar->width();
+      _scrollBar->move(contentsRect().topLeft());
+      break;
+    case ScrollBarRight:
+      _leftMargin = DEFAULT_LEFT_MARGIN;
+      _contentWidth = contentsRect().width()  - 2 * DEFAULT_LEFT_MARGIN - _scrollBar->width();
+      _scrollBar->move(contentsRect().topRight() - QPoint(_scrollBar->width()-1,0));
+      break;
+    }
+
+  _topMargin = DEFAULT_TOP_MARGIN;
+  _contentHeight = contentsRect().height() - 2 * DEFAULT_TOP_MARGIN + /* mysterious */ 1;
+
+  if (!_isFixedSize)
+    {
+      // ensure that display is always at least one column wide
+      _columns = qMax(1,qRound(_contentWidth / _fontWidth));
+      _usedColumns = qMin(_usedColumns,_columns);
+
+      // ensure that display is always at least one line high
+      _lines = qMax(1, qRound(_contentHeight / _fontHeight));
+      _usedLines = qMin(_usedLines,_lines);
+    }
+}
+
+void TerminalView::makeImage()
+{
+  //qDebug("%s %d makeImage", __FILE__, __LINE__);
+  calcGeometry();
+
+  // confirm that array will be of non-zero size, since the painting code
+  // assumes a non-zero array length
+  Q_ASSERT( _lines > 0 && _columns > 0 );
+  Q_ASSERT( _usedLines <= _lines && _usedColumns <= _columns );
+
+  _imageSize=_lines*_columns;
+
+  // We over-commit one character so that we can be more relaxed in dealing with
+  // certain boundary conditions: _image[_imageSize] is a valid but unused position
+  _image = new Character[_imageSize+1];
+
+  clearImage();
+}
+
+// calculate the needed size
+void TerminalView::setSize(int columns, int lines)
+{
+  //FIXME - Not quite correct, a small amount of additional space
+  // will be used for margins, the scrollbar etc.
+  // we need to allow for this so that '_size' does allow
+  // enough room for the specified number of columns and lines to fit
+
+  QSize newSize = QSize( columns * _fontWidth  ,
+                         lines * _fontHeight   );
+
+  if ( newSize != size() )
+    {
+      _size = newSize;
+      updateGeometry();
+    }
+}
+
+void TerminalView::setFixedSize(int cols, int lins)
+{
+  _isFixedSize = true;
+
+  //ensure that display is at least one line by one column in size
+  _columns = qMax(1,cols);
+  _lines = qMax(1,lins);
+  _usedColumns = qMin(_usedColumns,_columns);
+  _usedLines = qMin(_usedLines,_lines);
+
+  if (_image)
+    {
+      delete[] _image;
+      makeImage();
+    }
+  setSize(cols, lins);
+  QWidget::setFixedSize(_size);
+}
+
+QSize TerminalView::sizeHint() const
+{
+  return _size;
+}
+
+
+/* --------------------------------------------------------------------- */
+/*                                                                       */
+/* Drag & Drop                                                           */
+/*                                                                       */
+/* --------------------------------------------------------------------- */
+
+void TerminalView::dragEnterEvent(QDragEnterEvent* event)
+{
+  if (event->mimeData()->hasFormat("text/plain"))
+    event->acceptProposedAction();
+}
+
+void TerminalView::dropEvent(QDropEvent* event)
+{
+  //  KUrl::List urls = KUrl::List::fromMimeData(event->mimeData());
+
+  QString dropText;
+  /*  if (!urls.isEmpty())
+  {
+    for ( int i = 0 ; i < urls.count() ; i++ )
+    {
+        KUrl url = KIO::NetAccess::mostLocalUrl( urls[i] , 0 );
+        QString urlText;
+
+        if (url.isLocalFile())
+            urlText = url.path();
+        else
+            urlText = url.url();
+
+        // in future it may be useful to be able to insert file names with drag-and-drop
+        // without quoting them (this only affects paths with spaces in)
+        urlText = KShell::quoteArg(urlText);
+
+        dropText += urlText;
+
+        if ( i != urls.count()-1 )
+            dropText += ' ';
+    }
+  }
+  else
+  {
+    dropText = event->mimeData()->text();
+  }
+*/
+  if(event->mimeData()->hasFormat("text/plain"))
+    {
+      emit sendStringToEmu(dropText.toLocal8Bit());
+    }
+}
+
+void TerminalView::doDrag()
+{
+  dragInfo.state = diDragging;
+  dragInfo.dragObject = new QDrag(this);
+  QMimeData *mimeData = new QMimeData;
+  mimeData->setText(QApplication::clipboard()->text(QClipboard::Selection));
+  dragInfo.dragObject->setMimeData(mimeData);
+  dragInfo.dragObject->start(Qt::CopyAction);
+  // Don't delete the QTextDrag object.  Qt will delete it when it's done with it.
+}
+
+void TerminalView::outputSuspended(bool suspended)
+{
+  //create the label when this function is first called
+  if (!_outputSuspendedLabel)
+    {
+      //This label includes a link to an English language website
+      //describing the 'flow control' (Xon/Xoff) feature found in almost
+      //all terminal emulators.
+      //If there isn't a suitable article available in the target language the link
+      //can simply be removed.
+      _outputSuspendedLabel = new QLabel( ("<qt>Output has been "
+                                           "<a href=\"http://en.wikipedia.org/wiki/XON\">suspended</a>"
+                                           " by pressing Ctrl+S."
+                                           "  Press <b>Ctrl+Q</b> to resume.</qt>"),
+                                          this );
+
+      QPalette palette(_outputSuspendedLabel->palette());
+
+      palette.setColor(QPalette::Normal, QPalette::WindowText, QColor(Qt::white));
+      palette.setColor(QPalette::Normal, QPalette::Window, QColor(Qt::black));
+      //            KColorScheme::adjustForeground(palette,KColorScheme::NeutralText);
+      //		KColorScheme::adjustBackground(palette,KColorScheme::NeutralBackground);
+      _outputSuspendedLabel->setPalette(palette);
+      _outputSuspendedLabel->setAutoFillBackground(true);
+      _outputSuspendedLabel->setBackgroundRole(QPalette::Base);
+      _outputSuspendedLabel->setFont(QApplication::font());
+      _outputSuspendedLabel->setMargin(5);
+
+      //enable activation of "Xon/Xoff" link in label
+      _outputSuspendedLabel->setTextInteractionFlags(Qt::LinksAccessibleByMouse |
+                                                     Qt::LinksAccessibleByKeyboard);
+      _outputSuspendedLabel->setOpenExternalLinks(true);
+      _outputSuspendedLabel->setVisible(false);
+
+      _gridLayout->addWidget(_outputSuspendedLabel);
+      _gridLayout->addItem( new QSpacerItem(0,0,QSizePolicy::Expanding,
+                                            QSizePolicy::Expanding),
+                            1,0);
+
+    }
+
+  _outputSuspendedLabel->setVisible(suspended);
+}
+
+uint TerminalView::lineSpacing() const
+{
+  return _lineSpacing;
+}
+
+void TerminalView::setLineSpacing(uint i)
+{
+  _lineSpacing = i;
+  setVTFont(font()); // Trigger an update.
+}
diff --git a/libgui/qterminal/libqterminal/unix/TerminalView.h b/libgui/qterminal/libqterminal/unix/TerminalView.h
new file mode 100755
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/TerminalView.h
@@ -0,0 +1,727 @@
+/*
+    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
+    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+    Copyright (C) 2012 Jacob Dawid <jacob.dawid@googlemail.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef TERMINALVIEW_H
+#define TERMINALVIEW_H
+
+// Qt
+#include <QtGui/QColor>
+#include <QtCore/QPointer>
+#include <QtGui/QWidget>
+
+// Konsole
+#include "unix/Filter.h"
+#include "unix/Character.h"
+
+class QDrag;
+class QDragEnterEvent;
+class QDropEvent;
+class QLabel;
+class QTimer;
+class QEvent;
+class QFrame;
+class QGridLayout;
+class QKeyEvent;
+class QScrollBar;
+class QShowEvent;
+class QHideEvent;
+class QWidget;
+
+extern unsigned short vt100_graphics[32];
+
+class ScreenWindow;
+
+/**
+ * A widget which displays output from a terminal emulation and sends input keypresses and mouse activity
+ * to the terminal.
+ *
+ * When the terminal emulation receives new output from the program running in the terminal,
+ * it will update the display by calling updateImage().
+ *
+ * TODO More documentation
+ */
+class TerminalView : public QWidget
+{
+   Q_OBJECT
+
+public:
+    /** Constructs a new terminal display widget with the specified parent. */
+    TerminalView(QWidget *parent = 0);
+    virtual ~TerminalView();
+
+    /** Returns the terminal color palette used by the display. */
+    const ColorEntry* colorTable() const;
+    /** Sets the terminal color palette used by the display. */
+    void setColorTable(const ColorEntry table[]);
+    /**
+     * Sets the seed used to generate random colors for the display
+     * (in color schemes that support them).
+     */
+    void setRandomSeed(uint seed);
+    /**
+     * Returns the seed used to generate random colors for the display
+     * (in color schemes that support them).
+     */
+    uint randomSeed() const;
+
+
+    /**
+     * This enum describes the location where the scroll bar is positioned in the display widget.
+     */
+    enum ScrollBarPosition
+    {
+        /** Do not show the scroll bar. */
+        NoScrollBar=0,
+        /** Show the scroll bar on the left side of the display. */
+        ScrollBarLeft=1,
+        /** Show the scroll bar on the right side of the display. */
+        ScrollBarRight=2
+    };
+    /**
+     * Specifies whether the terminal display has a vertical scroll bar, and if so whether it
+     * is shown on the left or right side of the display.
+     */
+    void setScrollBarPosition(ScrollBarPosition position);
+
+    /**
+     * Sets the current position and range of the display's scroll bar.
+     *
+     * @param cursor The position of the scroll bar's thumb.
+     * @param lines The maximum value of the scroll bar.
+     */
+    void setScroll(int cursor, int lines);
+
+    /**
+     * Returns the display's filter chain.  When the image for the display is updated,
+     * the text is passed through each filter in the chain.  Each filter can define
+     * hotspots which correspond to certain strings (such as URLs or particular words).
+     * Depending on the type of the hotspots created by the filter ( returned by Filter::Hotspot::type() )
+     * the view will draw visual cues such as underlines on mouse-over for links or translucent
+     * rectangles for markers.
+     *
+     * To add a new filter to the view, call:
+     *      viewWidget->filterChain()->addFilter( filterObject );
+     */
+    FilterChain* filterChain() const;
+
+    /**
+     * Updates the filters in the display's filter chain.  This will cause
+     * the hotspots to be updated to match the current image.
+     *
+     * WARNING:  This function can be expensive depending on the
+     * image size and number of filters in the filterChain()
+     *
+     * TODO - This API does not really allow efficient usage.  Revise it so
+     * that the processing can be done in a better way.
+     *
+     * eg:
+     *      - Area of interest may be known ( eg. mouse cursor hovering
+     *      over an area )
+     */
+    void processFilters();
+
+    /**
+     * Returns a list of menu actions created by the filters for the content
+     * at the given @p position.
+     */
+    QList<QAction*> filterActions(const QPoint& position);
+
+    /** Returns true if the cursor is set to blink or false otherwise. */
+    bool blinkingCursor() { return _hasBlinkingCursor; }
+    /** Specifies whether or not the cursor blinks. */
+    void setBlinkingCursor(bool blink);
+
+    void setCtrlDrag(bool enable) { _ctrlDrag=enable; }
+    bool ctrlDrag() { return _ctrlDrag; }
+
+   /**
+     *  This enum describes the methods for selecting text when
+    *  the user triple-clicks within the display.
+    */
+   enum TripleClickMode
+   {
+      /** Select the whole line underneath the cursor. */
+      SelectWholeLine,
+      /** Select from the current cursor position to the end of the line. */
+      SelectForwardsFromCursor
+   };
+    /** Sets how the text is selected when the user triple clicks within the display. */
+    void setTripleClickMode(TripleClickMode mode) { _tripleClickMode = mode; }
+   /** See setTripleClickSelectionMode() */
+    TripleClickMode tripleClickMode() { return _tripleClickMode; }
+
+    void setLineSpacing(uint);
+    uint lineSpacing() const;
+
+    void emitSelection(bool useXselection,bool appendReturn);
+
+    /**
+     * This enum describes the available shapes for the keyboard cursor.
+     * See setKeyboardCursorShape()
+     */
+    enum KeyboardCursorShape
+    {
+        /** A rectangular block which covers the entire area of the cursor character. */
+        BlockCursor,
+        /**
+         * A single flat line which occupies the space at the bottom of the cursor
+         * character's area.
+         */
+        UnderlineCursor,
+        /**
+         * An cursor shaped like the capital letter 'I', similar to the IBeam
+         * cursor used in Qt/KDE text editors.
+         */
+        IBeamCursor
+    };
+    /**
+     * Sets the shape of the keyboard cursor.  This is the cursor drawn
+     * at the position in the terminal where keyboard input will appear.
+     *
+     * In addition the terminal display widget also has a cursor for
+     * the mouse pointer, which can be set using the QWidget::setCursor()
+     * method.
+     *
+     * Defaults to BlockCursor
+     */
+    void setKeyboardCursorShape(KeyboardCursorShape shape);
+    /**
+     * Returns the shape of the keyboard cursor.  See setKeyboardCursorShape()
+     */
+    KeyboardCursorShape keyboardCursorShape() const;
+
+    /**
+     * Sets the color used to draw the keyboard cursor.
+     *
+     * The keyboard cursor defaults to using the foreground color of the character
+     * underneath it.
+     *
+     * @param useForegroundColor If true, the cursor color will change to match
+     * the foreground color of the character underneath it as it is moved, in this
+     * case, the @p color parameter is ignored and the color of the character
+     * under the cursor is inverted to ensure that it is still readable.
+     * @param color The color to use to draw the cursor.  This is only taken into
+     * account if @p useForegroundColor is false.
+     */
+    void setKeyboardCursorColor(bool useForegroundColor , const QColor& color);
+
+    /**
+     * Returns the color of the keyboard cursor, or an invalid color if the keyboard
+     * cursor color is set to change according to the foreground color of the character
+     * underneath it.
+     */
+    QColor keyboardCursorColor() const;
+
+    /**
+     * Returns the number of lines of text which can be displayed in the widget.
+     *
+     * This will depend upon the height of the widget and the current font.
+     * See fontHeight()
+     */
+    int  lines()   { return _lines;   }
+    /**
+     * Returns the number of characters of text which can be displayed on
+     * each line in the widget.
+     *
+     * This will depend upon the width of the widget and the current font.
+     * See fontWidth()
+     */
+    int  columns() { return _columns; }
+
+    /**
+     * Returns the height of the characters in the font used to draw the text in the display.
+     */
+    int  fontHeight()   { return _fontHeight;   }
+    /**
+     * Returns the width of the characters in the display.
+     * This assumes the use of a fixed-width font.
+     */
+    int  fontWidth()    { return _fontWidth; }
+
+    void setSize(int cols, int lins);
+    void setFixedSize(int cols, int lins);
+
+    // reimplemented
+    QSize sizeHint() const;
+
+    /**
+     * Sets which characters, in addition to letters and numbers,
+     * are regarded as being part of a word for the purposes
+     * of selecting words in the display by double clicking on them.
+     *
+     * The word boundaries occur at the first and last characters which
+     * are either a letter, number, or a character in @p wc
+     *
+     * @param wc An array of characters which are to be considered parts
+     * of a word ( in addition to letters and numbers ).
+     */
+    void setWordCharacters(const QString& wc);
+    /**
+     * Returns the characters which are considered part of a word for the
+     * purpose of selecting words in the display with the mouse.
+     *
+     * @see setWordCharacters()
+     */
+    QString wordCharacters() { return _wordCharacters; }
+
+    /**
+     * Sets the type of effect used to alert the user when a 'bell' occurs in the
+     * terminal session.
+     *
+     * The terminal session can trigger the bell effect by calling bell() with
+     * the alert message.
+     */
+    void setBellMode(int mode);
+    /**
+     * Returns the type of effect used to alert the user when a 'bell' occurs in
+     * the terminal session.
+     *
+     * See setBellMode()
+     */
+    int bellMode() { return _bellMode; }
+
+    /**
+     * This enum describes the different types of sounds and visual effects which
+     * can be used to alert the user when a 'bell' occurs in the terminal
+     * session.
+     */
+    enum BellMode
+    {
+        /** A system beep. */
+        SystemBeepBell=0,
+        /**
+         * KDE notification.  This may play a sound, show a passive popup
+         * or perform some other action depending on the user's settings.
+         */
+        NotifyBell=1,
+        /** A silent, visual bell (eg. inverting the display's colors briefly) */
+        VisualBell=2,
+        /** No bell effects */
+        NoBell=3
+    };
+
+    void setSelection(const QString &t);
+
+    /**
+     * Reimplemented.  Has no effect.  Use setVTFont() to change the font
+     * used to draw characters in the display.
+     */
+    virtual void setFont(const QFont &);
+
+
+    /** Returns the font used to draw characters in the display */
+    QFont getVTFont() { return font(); }
+
+    /**
+     * Sets the font used to draw the display.  Has no effect if @p font
+     * is larger than the size of the display itself.
+     */
+    void setVTFont(const QFont& font);
+
+
+    /**
+     * Specified whether terminal widget should be at read-only mode
+     * Defaults to false.
+     */
+    void setReadOnly( bool readonly) { _readonly = readonly; }
+
+    /**
+     * Specified whether anti-aliasing of text in the terminal display
+     * is enabled or not.  Defaults to enabled.
+     */
+    static void setAntialias( bool antialias ) { _antialiasText = antialias; }
+    /**
+     * Returns true if anti-aliasing of text in the terminal is enabled.
+     */
+    static bool antialias()                 { return _antialiasText;   }
+
+    /**
+     * Sets whether or not the current height and width of the
+     * terminal in lines and columns is displayed whilst the widget
+     * is being resized.
+     */
+    void setTerminalSizeHint(bool on) { _terminalSizeHint=on; }
+    /**
+     * Returns whether or not the current height and width of
+     * the terminal in lines and columns is displayed whilst the widget
+     * is being resized.
+     */
+    bool terminalSizeHint() { return _terminalSizeHint; }
+    /**
+     * Sets whether the terminal size display is shown briefly
+     * after the widget is first shown.
+     *
+     * See setTerminalSizeHint() , isTerminalSizeHint()
+     */
+    void setTerminalSizeStartup(bool on) { _terminalSizeStartup=on; }
+
+    /**
+     * Sets the terminal screen section which is displayed in this widget.
+     * When updateImage() is called, the display fetches the latest character image from the
+     * the associated terminal screen window.
+     *
+     * In terms of the model-view paradigm, the ScreenWindow is the model which is rendered
+     * by the TerminalDisplay.
+     */
+    void setScreenWindow( ScreenWindow* window );
+    /** Returns the terminal screen section which is displayed in this widget.  See setScreenWindow() */
+    ScreenWindow* screenWindow() const;
+
+public slots:
+
+    /**
+     * Causes the terminal display to fetch the latest character image from the associated
+     * terminal screen ( see setScreenWindow() ) and redraw the display.
+     */
+    void updateImage();
+    /**
+     * Causes the terminal display to fetch the latest line status flags from the
+     * associated terminal screen ( see setScreenWindow() ).
+     */
+    void updateLineProperties();
+
+    /** Copies the selected text to the clipboard. */
+    void copyClipboard();
+    /**
+     * Pastes the content of the clipboard into the
+     * display.
+     */
+    void pasteClipboard();
+    /**
+     * Pastes the content of the selection into the
+     * display.
+     */
+    void pasteSelection();
+
+	 /**
+	 * Causes the widget to display or hide a message informing the user that terminal
+	 * output has been suspended (by using the flow control key combination Ctrl+S)
+	 *
+	 * @param suspended True if terminal output has been suspended and the warning message should
+	 *				 	be shown or false to indicate that terminal output has been resumed and that
+	 *				 	the warning message should disappear.
+	 */
+	void outputSuspended(bool suspended);
+
+    /**
+     * Sets whether the program whoose output is being displayed in the view
+     * is interested in mouse events.
+     *
+     * If this is set to true, mouse signals will be emitted by the view when the user clicks, drags
+     * or otherwise moves the mouse inside the view.
+     * The user interaction needed to create selections will also change, and the user will be required
+     * to hold down the shift key to create a selection or perform other mouse activities inside the
+     * view area - since the program running in the terminal is being allowed to handle normal mouse
+     * events itself.
+     *
+     * @param usesMouse Set to true if the program running in the terminal is interested in mouse events
+     * or false otherwise.
+     */
+    void setUsesMouse(bool usesMouse);
+
+    /** See setUsesMouse() */
+    bool usesMouse() const;
+
+signals:
+
+    /**
+     * Emitted when the user presses a key whilst the terminal widget has focus.
+     */
+    void keyPressedSignal(QKeyEvent *e);
+
+    /**
+     * A mouse event occurred.
+     * @param button The mouse button (0 for left button, 1 for middle button, 2 for right button, 3 for release)
+     * @param column The character column where the event occurred
+     * @param line The character row where the event occurred
+     * @param eventType The type of event.  0 for a mouse press / release or 1 for mouse motion
+     */
+    void mouseSignal(int button, int column, int line, int eventType);
+    void changedFontMetricSignal(int height, int width);
+    void changedContentSizeSignal(int height, int width);
+
+    /**
+     * Emitted when the user right clicks on the display, or right-clicks with the Shift
+     * key held down if usesMouse() is true.
+     *
+     * This can be used to display a context menu.
+     */
+    void configureRequest( TerminalView*, int state, const QPoint& position );
+
+   void isBusySelecting(bool);
+   void sendStringToEmu(const char*);
+
+   void tripleClicked( const QString& text );
+
+protected:
+    virtual bool event( QEvent * );
+
+    virtual void paintEvent( QPaintEvent * );
+
+    virtual void showEvent(QShowEvent*);
+    virtual void hideEvent(QHideEvent*);
+    virtual void resizeEvent(QResizeEvent*);
+
+    virtual void fontChange(const QFont &font);
+
+    virtual void keyPressEvent(QKeyEvent* event);
+    virtual void mouseDoubleClickEvent(QMouseEvent* ev);
+    virtual void mousePressEvent( QMouseEvent* );
+    virtual void mouseReleaseEvent( QMouseEvent* );
+    virtual void mouseMoveEvent( QMouseEvent* );
+    virtual void extendSelection( const QPoint& pos );
+    virtual void wheelEvent( QWheelEvent* );
+
+    virtual bool focusNextPrevChild( bool next );
+
+    // drag and drop
+    virtual void dragEnterEvent(QDragEnterEvent* event);
+    virtual void dropEvent(QDropEvent* event);
+    void doDrag();
+    enum DragState { diNone, diPending, diDragging };
+
+    struct _dragInfo {
+      DragState       state;
+      QPoint          start;
+      QDrag           *dragObject;
+    } dragInfo;
+
+    virtual int charClass(quint16) const;
+
+    void clearImage();
+
+    void mouseTripleClickEvent(QMouseEvent* ev);
+
+    // reimplemented
+    virtual void inputMethodEvent ( QInputMethodEvent* event );
+    virtual QVariant inputMethodQuery( Qt::InputMethodQuery query ) const;
+
+protected slots:
+
+    void scrollBarPositionChanged(int value);
+    void blinkEvent();
+    void blinkCursorEvent();
+
+    //Renables bell noises and visuals.  Used to disable further bells for a short period of time
+    //after emitting the first in a sequence of bell events.
+    void enableBell();
+
+private slots:
+
+    void swapColorTable();
+    void tripleClickTimeout();  // resets possibleTripleClick
+
+private:
+
+    // -- Drawing helpers --
+
+    // divides the part of the display specified by 'rect' into
+    // fragments according to their colors and styles and calls
+    // drawTextFragment() to draw the fragments
+    void drawContents(QPainter &paint, const QRect &rect);
+    // draws a section of text, all the text in this section
+    // has a common color and style
+    void drawTextFragment(QPainter& painter, const QRect& rect,
+                          const QString& text, const Character* style);
+    // draws the background for a text fragment
+    // if useOpacitySetting is true then the color's alpha value will be set to
+    // the display's transparency (set with setOpacity()), otherwise the background
+    // will be drawn fully opaque
+    void drawBackground(QPainter& painter, const QRect& rect, const QColor& color);
+    // draws the cursor character
+    void drawCursor(QPainter& painter, const QRect& rect , const QColor& foregroundColor,
+                                       const QColor& backgroundColor , bool& invertColors);
+    // draws the characters or line graphics in a text fragment
+    void drawCharacters(QPainter& painter, const QRect& rect,  const QString& text,
+                                           const Character* style, bool invertCharacterColor);
+    // draws a string of line graphics
+   void drawLineCharString(QPainter& painter, int x, int y,
+                            const QString& str, const Character* attributes);
+
+    // draws the preedit string for input methods
+    void drawInputMethodPreeditString(QPainter& painter , const QRect& rect);
+
+    // --
+
+    // maps an area in the character image to an area on the widget
+    QRect imageToWidget(const QRect& imageArea) const;
+
+    // maps a point on the widget to the position ( ie. line and column )
+    // of the character at that point.
+    void getCharacterPosition(const QPoint& widgetPoint,int& line,int& column) const;
+
+    // the area where the preedit string for input methods will be draw
+    QRect preeditRect() const;
+
+    // shows a notification window in the middle of the widget indicating the terminal's
+    // current size in columns and lines
+    void showResizeNotification();
+
+    // scrolls the image by a number of lines.
+    // 'lines' may be positive ( to scroll the image down )
+    // or negative ( to scroll the image up )
+    // 'region' is the part of the image to scroll - currently only
+    // the top, bottom and height of 'region' are taken into account,
+    // the left and right are ignored.
+    void scrollImage(int lines , const QRect& region);
+
+    void calcGeometry();
+    void propagateSize();
+    void updateImageSize();
+    void makeImage();
+
+    void paintFilters(QPainter& painter);
+
+	// returns a region covering all of the areas of the widget which contain
+	// a hotspot
+	QRegion hotSpotRegion() const;
+
+	// returns the position of the cursor in columns and lines
+	QPoint cursorPosition() const;
+
+    // the window onto the terminal screen which this display
+    // is currently showing.
+    QPointer<ScreenWindow> _screenWindow;
+
+    bool _allowBell;
+
+    QGridLayout* _gridLayout;
+
+    bool _fixedFont; // has fixed pitch
+
+    double  _fontHeight;     // height
+    double  _fontWidth;     // width
+    //type double to decrease rounding errors
+
+    int  _fontAscent;     // ascend
+
+    int _leftMargin;    // offset
+    int _topMargin;    // offset
+
+    int _lines;      // the number of lines that can be displayed in the widget
+    int _columns;    // the number of columns that can be displayed in the widget
+
+    int _usedLines;  // the number of lines that are actually being used, this will be less
+                    // than 'lines' if the character image provided with setImage() is smaller
+                    // than the maximum image size which can be displayed
+
+    int _usedColumns; // the number of columns that are actually being used, this will be less
+                     // than 'columns' if the character image provided with setImage() is smaller
+                     // than the maximum image size which can be displayed
+
+    int _contentHeight;
+    int _contentWidth;
+    Character* _image; // [lines][columns]
+               // only the area [usedLines][usedColumns] in the image contains valid data
+
+    int _imageSize;
+    QVector<LineProperty> _lineProperties;
+
+    ColorEntry _colorTable[TABLE_COLORS];
+    uint _randomSeed;
+
+    bool _resizing;
+    bool _terminalSizeHint;
+    bool _terminalSizeStartup;
+    bool _mouseMarks;
+
+    QPoint  _iPntSel; // initial selection point
+    QPoint  _pntSel; // current selection point
+    QPoint  _tripleSelBegin; // help avoid flicker
+    int     _actSel; // selection state
+    bool    _wordSelectionMode;
+    bool    _lineSelectionMode;
+    bool    _preserveLineBreaks;
+    bool    _columnSelectionMode;
+
+    QClipboard*  _clipboard;
+    QScrollBar* _scrollBar;
+    ScrollBarPosition _scrollbarLocation;
+    QString     _wordCharacters;
+    int         _bellMode;
+
+    bool _blinking;   // hide text in paintEvent
+    bool _hasBlinker; // has characters to blink
+    bool _cursorBlinking;     // hide cursor in paintEvent
+    bool _hasBlinkingCursor;  // has blinking cursor enabled
+    bool _ctrlDrag;           // require Ctrl key for drag
+    TripleClickMode _tripleClickMode;
+    bool _isFixedSize; //Columns / lines are locked.
+    QTimer* _blinkTimer;  // active when hasBlinker
+    QTimer* _blinkCursorTimer;  // active when hasBlinkingCursor
+
+//    KMenu* _drop;
+    QString _dropText;
+    int _dndFileCount;
+
+    bool _possibleTripleClick;  // is set in mouseDoubleClickEvent and deleted
+                               // after QApplication::doubleClickInterval() delay
+
+
+    QLabel* _resizeWidget;
+    QTimer* _resizeTimer;
+
+   bool _flowControlWarningEnabled;
+
+    //widgets related to the warning message that appears when the user presses Ctrl+S to suspend
+    //terminal output - informing them what has happened and how to resume output
+    QLabel* _outputSuspendedLabel;
+
+    uint _lineSpacing;
+
+    bool _colorsInverted; // true during visual bell
+
+    QSize _size;
+
+    QRgb _blendColor;
+
+    // list of filters currently applied to the display.  used for links and
+    // search highlight
+    TerminalImageFilterChain* _filterChain;
+    QRect _mouseOverHotspotArea;
+
+    KeyboardCursorShape _cursorShape;
+
+    // custom cursor color.  if this is invalid then the foreground
+    // color of the character under the cursor is used
+    QColor _cursorColor;
+
+
+    struct InputMethodData
+    {
+        QString preeditString;
+        QRect previousPreeditRect;
+    };
+    InputMethodData _inputMethodData;
+
+    static bool _antialiasText;   // do we antialias or not
+
+    //the delay in milliseconds between redrawing blinking text
+    static const int BLINK_DELAY = 500;
+   static const int DEFAULT_LEFT_MARGIN = 2;
+   static const int DEFAULT_TOP_MARGIN = 2;
+
+    bool _readonly;
+};
+
+#endif // TERMINALVIEW_H
diff --git a/libgui/qterminal/libqterminal/unix/Vt102Emulation.cpp b/libgui/qterminal/libqterminal/unix/Vt102Emulation.cpp
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/Vt102Emulation.cpp
@@ -0,0 +1,1261 @@
+/*
+    This file is part of Konsole, an X terminal.
+    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+// Own
+#include "unix/Vt102Emulation.h"
+
+#if defined(__osf__) || defined(__APPLE__)
+#define AVOID_XKB
+#endif
+
+// this allows konsole to be compiled without XKB and XTEST extensions
+// even though it might be available on a particular system.
+#if defined(AVOID_XKB)
+#undef HAVE_XKB
+#endif
+
+// Standard
+#include <stdio.h>
+#include <unistd.h>
+#include <assert.h>
+
+// Qt
+#include <QtCore/QEvent>
+#include <QtGui/QKeyEvent>
+#include <QtCore/QByteRef>
+
+// Konsole
+#include "unix/KeyboardTranslator.h"
+#include "unix/Screen.h"
+
+#if defined(HAVE_XKB)
+void scrolllock_set_off();
+void scrolllock_set_on();
+#endif
+
+
+/* VT102 Terminal Emulation
+
+   This class puts together the screens, the pty and the widget to a
+   complete terminal emulation. Beside combining it's componentes, it
+   handles the emulations's protocol.
+
+   This module consists of the following sections:
+
+   - Constructor/Destructor
+   - Incoming Bytes Event pipeline
+   - Outgoing Bytes
+     - Mouse Events
+     - Keyboard Events
+   - Modes and Charset State
+   - Diagnostics
+*/
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                       Constructor / Destructor                            */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+
+Vt102Emulation::Vt102Emulation()
+    : Emulation(),
+     _titleUpdateTimer(new QTimer(this))
+{
+  _titleUpdateTimer->setSingleShot(true);
+
+  QObject::connect(_titleUpdateTimer , SIGNAL(timeout()) , this , SLOT(updateTitle()));
+
+  initTokenizer();
+  reset();
+}
+
+Vt102Emulation::~Vt102Emulation()
+{
+}
+
+void Vt102Emulation::clearEntireScreen()
+{
+  _currentScreen->clearEntireScreen();
+
+  bufferedUpdate();
+}
+
+void Vt102Emulation::reset()
+{
+  //kDebug(1211)<<"Vt102Emulation::reset() resetToken()";
+  resetToken();
+  //kDebug(1211)<<"Vt102Emulation::reset() resetModes()";
+  resetModes();
+  //kDebug(1211)<<"Vt102Emulation::reset() resetCharSet()";
+  resetCharset(0);
+  //kDebug(1211)<<"Vt102Emulation::reset() reset screen0()";
+  _screen[0]->reset();
+  //kDebug(1211)<<"Vt102Emulation::reset() resetCharSet()";
+  resetCharset(1);
+  //kDebug(1211)<<"Vt102Emulation::reset() reset _screen 1";
+  _screen[1]->reset();
+  //kDebug(1211)<<"Vt102Emulation::reset() setCodec()";
+  setCodec(LocaleCodec);
+  //kDebug(1211)<<"Vt102Emulation::reset() done";
+
+  bufferedUpdate();
+}
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                     Processing the incoming byte stream                   */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+/* Incoming Bytes Event pipeline
+
+   This section deals with decoding the incoming character stream.
+   Decoding means here, that the stream is first separated into `tokens'
+   which are then mapped to a `meaning' provided as operations by the
+   `Screen' class or by the emulation class itself.
+
+   The pipeline proceeds as follows:
+
+   - Tokenizing the ESC codes (onReceiveChar)
+   - VT100 code page translation of plain characters (applyCharset)
+   - Interpretation of ESC codes (tau)
+
+   The escape codes and their meaning are described in the
+   technical reference of this program.
+*/
+
+// Tokens ------------------------------------------------------------------ --
+
+/*
+   Since the tokens are the central notion if this section, we've put them
+   in front. They provide the syntactical elements used to represent the
+   terminals operations as byte sequences.
+
+   They are encodes here into a single machine word, so that we can later
+   switch over them easily. Depending on the token itself, additional
+   argument variables are filled with parameter values.
+
+   The tokens are defined below:
+
+   - CHR        - Printable characters     (32..255 but DEL (=127))
+   - CTL        - Control characters       (0..31 but ESC (= 27), DEL)
+   - ESC        - Escape codes of the form <ESC><CHR but `[]()+*#'>
+   - ESC_DE     - Escape codes of the form <ESC><any of `()+*#%'> C
+   - CSI_PN     - Escape codes of the form <ESC>'['     {Pn} ';' {Pn} C
+   - CSI_PS     - Escape codes of the form <ESC>'['     {Pn} ';' ...  C
+   - CSI_PR     - Escape codes of the form <ESC>'[' '?' {Pn} ';' ...  C
+   - CSI_PE     - Escape codes of the form <ESC>'[' '!' {Pn} ';' ...  C
+   - VT52       - VT52 escape codes
+                  - <ESC><Chr>
+                  - <ESC>'Y'{Pc}{Pc}
+   - XTE_HA     - Xterm hacks              <ESC>`]' {Pn} `;' {Text} <BEL>
+                  note that this is handled differently
+
+   The last two forms allow list of arguments. Since the elements of
+   the lists are treated individually the same way, they are passed
+   as individual tokens to the interpretation. Further, because the
+   meaning of the parameters are names (althought represented as numbers),
+   they are includes within the token ('N').
+
+*/
+
+#define TY_CONSTR(T,A,N) ( ((((int)N) & 0xffff) << 16) | ((((int)A) & 0xff) << 8) | (((int)T) & 0xff) )
+
+#define TY_CHR(   )     TY_CONSTR(0,0,0)
+#define TY_CTL(A  )     TY_CONSTR(1,A,0)
+#define TY_ESC(A  )     TY_CONSTR(2,A,0)
+#define TY_ESC_CS(A,B)  TY_CONSTR(3,A,B)
+#define TY_ESC_DE(A  )  TY_CONSTR(4,A,0)
+#define TY_CSI_PS(A,N)  TY_CONSTR(5,A,N)
+#define TY_CSI_PN(A  )  TY_CONSTR(6,A,0)
+#define TY_CSI_PR(A,N)  TY_CONSTR(7,A,N)
+
+#define TY_VT52(A  )    TY_CONSTR(8,A,0)
+
+#define TY_CSI_PG(A  )  TY_CONSTR(9,A,0)
+
+#define TY_CSI_PE(A  )  TY_CONSTR(10,A,0)
+
+// Tokenizer --------------------------------------------------------------- --
+
+/* The tokenizers state
+
+   The state is represented by the buffer (pbuf, ppos),
+   and accompanied by decoded arguments kept in (argv,argc).
+   Note that they are kept internal in the tokenizer.
+*/
+
+void Vt102Emulation::resetToken()
+{
+  ppos = 0; argc = 0; argv[0] = 0; argv[1] = 0;
+}
+
+void Vt102Emulation::addDigit(int dig)
+{
+  argv[argc] = 10*argv[argc] + dig;
+}
+
+void Vt102Emulation::addArgument()
+{
+  argc = qMin(argc+1,MAXARGS-1);
+  argv[argc] = 0;
+}
+
+void Vt102Emulation::pushToToken(int cc)
+{
+  pbuf[ppos] = cc;
+  ppos = qMin(ppos+1,MAXPBUF-1);
+}
+
+// Character Classes used while decoding
+
+#define CTL  1
+#define CHR  2
+#define CPN  4
+#define DIG  8
+#define SCS 16
+#define GRP 32
+#define CPS 64
+
+void Vt102Emulation::initTokenizer()
+{ int i; quint8* s;
+  for(i =  0;                      i < 256; i++) tbl[ i]  = 0;
+  for(i =  0;                      i <  32; i++) tbl[ i] |= CTL;
+  for(i = 32;                      i < 256; i++) tbl[ i] |= CHR;
+  for(s = (quint8*)"@ABCDGHILMPSTXZcdfry"; *s; s++) tbl[*s] |= CPN;
+// resize = \e[8;<row>;<col>t
+  for(s = (quint8*)"t"; *s; s++) tbl[*s] |= CPS;
+  for(s = (quint8*)"0123456789"        ; *s; s++) tbl[*s] |= DIG;
+  for(s = (quint8*)"()+*%"             ; *s; s++) tbl[*s] |= SCS;
+  for(s = (quint8*)"()+*#[]%"          ; *s; s++) tbl[*s] |= GRP;
+  resetToken();
+}
+
+/* Ok, here comes the nasty part of the decoder.
+
+   Instead of keeping an explicit state, we deduce it from the
+   token scanned so far. It is then immediately combined with
+   the current character to form a scanning decision.
+
+   This is done by the following defines.
+
+   - P is the length of the token scanned so far.
+   - L (often P-1) is the position on which contents we base a decision.
+   - C is a character or a group of characters (taken from 'tbl').
+
+   Note that they need to applied in proper order.
+*/
+
+#define lec(P,L,C) (p == (P) &&                     s[(L)]         == (C))
+#define lun(     ) (p ==  1  &&                       cc           >= 32 )
+#define les(P,L,C) (p == (P) && s[L] < 256  && (tbl[s[(L)]] & (C)) == (C))
+#define eec(C)     (p >=  3  &&        cc                          == (C))
+#define ees(C)     (p >=  3  && cc < 256 &&    (tbl[  cc  ] & (C)) == (C))
+#define eps(C)     (p >=  3  && s[2] != '?' && s[2] != '!' && s[2] != '>' && cc < 256 && (tbl[  cc  ] & (C)) == (C))
+#define epp( )     (p >=  3  && s[2] == '?'                              )
+#define epe( )     (p >=  3  && s[2] == '!'                              )
+#define egt(     ) (p >=  3  && s[2] == '>'                              )
+#define Xpe        (ppos>=2  && pbuf[1] == ']'                           )
+#define Xte        (Xpe                        &&     cc           ==  7 )
+#define ces(C)     (            cc < 256 &&    (tbl[  cc  ] & (C)) == (C) && !Xte)
+
+#define ESC 27
+#define CNTL(c) ((c)-'@')
+
+// process an incoming unicode character
+
+void Vt102Emulation::receiveChar(int cc)
+{
+  int i;
+  if (cc == 127) return; //VT100: ignore.
+
+  if (ces(    CTL))
+  { // DEC HACK ALERT! Control Characters are allowed *within* esc sequences in VT100
+    // This means, they do neither a resetToken nor a pushToToken. Some of them, do
+    // of course. Guess this originates from a weakly layered handling of the X-on
+    // X-off protocol, which comes really below this level.
+    if (cc == CNTL('X') || cc == CNTL('Z') || cc == ESC) resetToken(); //VT100: CAN or SUB
+    if (cc != ESC)    { tau( TY_CTL(cc+'@' ),   0,  0); return; }
+  }
+
+  pushToToken(cc); // advance the state
+
+  int* s = pbuf;
+  int  p = ppos;
+
+  if (getMode(MODE_Ansi)) // decide on proper action
+  {
+    if (lec(1,0,ESC)) {                                                       return; }
+    if (lec(1,0,ESC+128)) { s[0] = ESC; receiveChar('[');                   return; }
+    if (les(2,1,GRP)) {                                                       return; }
+    if (Xte         ) { XtermHack();                            resetToken(); return; }
+    if (Xpe         ) {                                                       return; }
+    if (lec(3,2,'?')) {                                                       return; }
+    if (lec(3,2,'>')) {                                                       return; }
+    if (lec(3,2,'!')) {                                                       return; }
+    if (lun(       )) { tau( TY_CHR(), applyCharset(cc), 0); resetToken(); return; }
+    if (lec(2,0,ESC)) { tau( TY_ESC(s[1]),   0,  0);       resetToken(); return; }
+    if (les(3,1,SCS)) { tau( TY_ESC_CS(s[1],s[2]),   0,  0);  resetToken(); return; }
+    if (lec(3,1,'#')) { tau( TY_ESC_DE(s[2]),   0,  0);       resetToken(); return; }
+    if (eps(    CPN)) { tau( TY_CSI_PN(cc), argv[0],argv[1]);   resetToken(); return; }
+
+// resize = \e[8;<row>;<col>t
+    if (eps(    CPS)) { tau( TY_CSI_PS(cc, argv[0]), argv[1], argv[2]);   resetToken(); return; }
+
+    if (epe(       )) { tau( TY_CSI_PE(cc),     0,  0);       resetToken(); return; }
+    if (ees(    DIG)) { addDigit(cc-'0');                                     return; }
+    if (eec(    ';')) { addArgument();                                        return; }
+    for (i=0;i<=argc;i++)
+    if ( epp(     ))  { tau( TY_CSI_PR(cc,argv[i]),   0,  0); }
+    else if(egt(    ))   { tau( TY_CSI_PG(cc     ),   0,  0); } // spec. case for ESC]>0c or ESC]>c
+    else if (cc == 'm' && argc - i >= 4 && (argv[i] == 38 || argv[i] == 48) && argv[i+1] == 2)
+    { // ESC[ ... 48;2;<red>;<green>;<blue> ... m -or- ESC[ ... 38;2;<red>;<green>;<blue> ... m
+      i += 2;
+      tau( TY_CSI_PS(cc, argv[i-2]), COLOR_SPACE_RGB, (argv[i] << 16) | (argv[i+1] << 8) | argv[i+2]);
+      i += 2;
+    }
+    else if (cc == 'm' && argc - i >= 2 && (argv[i] == 38 || argv[i] == 48) && argv[i+1] == 5)
+    { // ESC[ ... 48;5;<index> ... m -or- ESC[ ... 38;5;<index> ... m
+      i += 2;
+      tau( TY_CSI_PS(cc, argv[i-2]), COLOR_SPACE_256, argv[i]);
+    }
+    else              { tau( TY_CSI_PS(cc,argv[i]),   0,  0); }
+    resetToken();
+  }
+  else // mode VT52
+  {
+    if (lec(1,0,ESC))                                                      return;
+    if (les(1,0,CHR)) { tau( TY_CHR(       ), s[0],  0); resetToken(); return; }
+    if (lec(2,1,'Y'))                                                      return;
+    if (lec(3,1,'Y'))                                                      return;
+    if (p < 4)        { tau( TY_VT52(s[1]   ),   0,  0); resetToken(); return; }
+                        tau( TY_VT52(s[1]   ), s[2],s[3]); resetToken(); return;
+  }
+}
+
+void Vt102Emulation::XtermHack()
+{ int i,arg = 0;
+  for (i = 2; i < ppos && '0'<=pbuf[i] && pbuf[i]<'9' ; i++)
+    arg = 10*arg + (pbuf[i]-'0');
+  if (pbuf[i] != ';') { ReportErrorToken(); return; }
+  QChar *str = new QChar[ppos-i-2];
+  for (int j = 0; j < ppos-i-2; j++) str[j] = pbuf[i+1+j];
+  QString unistr(str,ppos-i-2);
+
+  // arg == 1 doesn't change the title. In XTerm it only changes the icon name
+  // (btw: arg=0 changes title and icon, arg=1 only icon, arg=2 only title
+//  emit changeTitle(arg,unistr);
+  _pendingTitleUpdates[arg] = unistr;
+  _titleUpdateTimer->start(20);
+
+  delete [] str;
+}
+
+void Vt102Emulation::updateTitle()
+{
+    QListIterator<int> iter( _pendingTitleUpdates.keys() );
+    while (iter.hasNext()) {
+        int arg = iter.next();
+        emit titleChanged( arg , _pendingTitleUpdates[arg] );
+    }
+
+    _pendingTitleUpdates.clear();
+}
+
+// Interpreting Codes ---------------------------------------------------------
+
+/*
+   Now that the incoming character stream is properly tokenized,
+   meaning is assigned to them. These are either operations of
+   the current _screen, or of the emulation class itself.
+
+   The token to be interpreteted comes in as a machine word
+   possibly accompanied by two parameters.
+
+   Likewise, the operations assigned to, come with up to two
+   arguments. One could consider to make up a proper table
+   from the function below.
+
+   The technical reference manual provides more information
+   about this mapping.
+*/
+
+void Vt102Emulation::tau( int token, int p, int q )
+{
+#if 0
+int N = (token>>0)&0xff;
+int A = (token>>8)&0xff;
+switch( N )
+{
+   case 0: printf("%c", (p < 128) ? p : '?');
+           break;
+   case 1: if (A == 'J') printf("\r");
+           else if (A == 'M') printf("\n");
+           else printf("CTL-%c ", (token>>8)&0xff);
+           break;
+   case 2: printf("ESC-%c ", (token>>8)&0xff);
+           break;
+   case 3: printf("ESC_CS-%c-%c ", (token>>8)&0xff, (token>>16)&0xff);
+           break;
+   case 4: printf("ESC_DE-%c ", (token>>8)&0xff);
+           break;
+   case 5: printf("CSI-PS-%c-%d", (token>>8)&0xff, (token>>16)&0xff );
+           break;
+   case 6: printf("CSI-PN-%c [%d]", (token>>8)&0xff, p);
+           break;
+   case 7: printf("CSI-PR-%c-%d", (token>>8)&0xff, (token>>16)&0xff );
+           break;
+   case 8: printf("VT52-%c", (token>>8)&0xff);
+           break;
+   case 9: printf("CSI-PG-%c", (token>>8)&0xff);
+           break;
+   case 10: printf("CSI-PE-%c", (token>>8)&0xff);
+           break;
+}
+#endif
+
+  switch (token)
+  {
+
+    case TY_CHR(         ) : _currentScreen->ShowCharacter        (p         ); break; //UTF16
+
+    //             127 DEL    : ignored on input
+
+    case TY_CTL('@'      ) : /* NUL: ignored                      */ break;
+    case TY_CTL('A'      ) : /* SOH: ignored                      */ break;
+    case TY_CTL('B'      ) : /* STX: ignored                      */ break;
+    case TY_CTL('C'      ) : /* ETX: ignored                      */ break;
+    case TY_CTL('D'      ) : /* EOT: ignored                      */ break;
+    case TY_CTL('E'      ) :      reportAnswerBack     (          ); break; //VT100
+    case TY_CTL('F'      ) : /* ACK: ignored                      */ break;
+    case TY_CTL('G'      ) : emit stateSet(NOTIFYBELL);
+                                break; //VT100
+    case TY_CTL('H'      ) : _currentScreen->BackSpace            (          ); break; //VT100
+    case TY_CTL('I'      ) : _currentScreen->Tabulate             (          ); break; //VT100
+    case TY_CTL('J'      ) : _currentScreen->NewLine              (          ); break; //VT100
+    case TY_CTL('K'      ) : _currentScreen->NewLine              (          ); break; //VT100
+    case TY_CTL('L'      ) : _currentScreen->NewLine              (          ); break; //VT100
+    case TY_CTL('M'      ) : _currentScreen->Return               (          ); break; //VT100
+
+    case TY_CTL('N'      ) :      useCharset           (         1); break; //VT100
+    case TY_CTL('O'      ) :      useCharset           (         0); break; //VT100
+
+    case TY_CTL('P'      ) : /* DLE: ignored                      */ break;
+    case TY_CTL('Q'      ) : /* DC1: XON continue                 */ break; //VT100
+    case TY_CTL('R'      ) : /* DC2: ignored                      */ break;
+    case TY_CTL('S'      ) : /* DC3: XOFF halt                    */ break; //VT100
+    case TY_CTL('T'      ) : /* DC4: ignored                      */ break;
+    case TY_CTL('U'      ) : /* NAK: ignored                      */ break;
+    case TY_CTL('V'      ) : /* SYN: ignored                      */ break;
+    case TY_CTL('W'      ) : /* ETB: ignored                      */ break;
+    case TY_CTL('X'      ) : _currentScreen->ShowCharacter        (    0x2592); break; //VT100
+    case TY_CTL('Y'      ) : /* EM : ignored                      */ break;
+    case TY_CTL('Z'      ) : _currentScreen->ShowCharacter        (    0x2592); break; //VT100
+    case TY_CTL('['      ) : /* ESC: cannot be seen here.         */ break;
+    case TY_CTL('\\'     ) : /* FS : ignored                      */ break;
+    case TY_CTL(']'      ) : /* GS : ignored                      */ break;
+    case TY_CTL('^'      ) : /* RS : ignored                      */ break;
+    case TY_CTL('_'      ) : /* US : ignored                      */ break;
+
+    case TY_ESC('D'      ) : _currentScreen->index                (          ); break; //VT100
+    case TY_ESC('E'      ) : _currentScreen->NextLine             (          ); break; //VT100
+    case TY_ESC('H'      ) : _currentScreen->changeTabStop        (true      ); break; //VT100
+    case TY_ESC('M'      ) : _currentScreen->reverseIndex         (          ); break; //VT100
+    case TY_ESC('Z'      ) :      reportTerminalType   (          ); break;
+    case TY_ESC('c'      ) :      reset                (          ); break;
+
+    case TY_ESC('n'      ) :      useCharset           (         2); break;
+    case TY_ESC('o'      ) :      useCharset           (         3); break;
+    case TY_ESC('7'      ) :      saveCursor           (          ); break;
+    case TY_ESC('8'      ) :      restoreCursor        (          ); break;
+
+    case TY_ESC('='      ) :          setMode      (MODE_AppKeyPad); break;
+    case TY_ESC('>'      ) :        resetMode      (MODE_AppKeyPad); break;
+    case TY_ESC('<'      ) :          setMode      (MODE_Ansi     ); break; //VT100
+
+    case TY_ESC_CS('(', '0') :      setCharset           (0,    '0'); break; //VT100
+    case TY_ESC_CS('(', 'A') :      setCharset           (0,    'A'); break; //VT100
+    case TY_ESC_CS('(', 'B') :      setCharset           (0,    'B'); break; //VT100
+
+    case TY_ESC_CS(')', '0') :      setCharset           (1,    '0'); break; //VT100
+    case TY_ESC_CS(')', 'A') :      setCharset           (1,    'A'); break; //VT100
+    case TY_ESC_CS(')', 'B') :      setCharset           (1,    'B'); break; //VT100
+
+    case TY_ESC_CS('*', '0') :      setCharset           (2,    '0'); break; //VT100
+    case TY_ESC_CS('*', 'A') :      setCharset           (2,    'A'); break; //VT100
+    case TY_ESC_CS('*', 'B') :      setCharset           (2,    'B'); break; //VT100
+
+    case TY_ESC_CS('+', '0') :      setCharset           (3,    '0'); break; //VT100
+    case TY_ESC_CS('+', 'A') :      setCharset           (3,    'A'); break; //VT100
+    case TY_ESC_CS('+', 'B') :      setCharset           (3,    'B'); break; //VT100
+
+    case TY_ESC_CS('%', 'G') :      setCodec             (Utf8Codec   ); break; //LINUX
+    case TY_ESC_CS('%', '@') :      setCodec             (LocaleCodec ); break; //LINUX
+
+    case TY_ESC_DE('3'      ) : /* Double height line, top half    */
+                                _currentScreen->setLineProperty( LINE_DOUBLEWIDTH , true );
+                                _currentScreen->setLineProperty( LINE_DOUBLEHEIGHT , true );
+                                    break;
+    case TY_ESC_DE('4'      ) : /* Double height line, bottom half */
+                                _currentScreen->setLineProperty( LINE_DOUBLEWIDTH , true );
+                                _currentScreen->setLineProperty( LINE_DOUBLEHEIGHT , true );
+                                    break;
+    case TY_ESC_DE('5'      ) : /* Single width, single height line*/
+                                _currentScreen->setLineProperty( LINE_DOUBLEWIDTH , false);
+                                _currentScreen->setLineProperty( LINE_DOUBLEHEIGHT , false);
+                                break;
+    case TY_ESC_DE('6'      ) : /* Double width, single height line*/
+                                _currentScreen->setLineProperty( LINE_DOUBLEWIDTH , true);
+                                _currentScreen->setLineProperty( LINE_DOUBLEHEIGHT , false);
+                                break;
+    case TY_ESC_DE('8'      ) : _currentScreen->helpAlign            (          ); break;
+
+// resize = \e[8;<row>;<col>t
+    case TY_CSI_PS('t',   8) : setImageSize( q /* colums */, p /* lines */ );    break;
+
+// change tab text color : \e[28;<color>t  color: 0-16,777,215
+    case TY_CSI_PS('t',   28) : emit changeTabTextColorRequest      ( p        );          break;
+
+    case TY_CSI_PS('K',   0) : _currentScreen->clearToEndOfLine     (          ); break;
+    case TY_CSI_PS('K',   1) : _currentScreen->clearToBeginOfLine   (          ); break;
+    case TY_CSI_PS('K',   2) : _currentScreen->clearEntireLine      (          ); break;
+    case TY_CSI_PS('J',   0) : _currentScreen->clearToEndOfScreen   (          ); break;
+    case TY_CSI_PS('J',   1) : _currentScreen->clearToBeginOfScreen (          ); break;
+    case TY_CSI_PS('J',   2) : _currentScreen->clearEntireScreen    (          ); break;
+    case TY_CSI_PS('g',   0) : _currentScreen->changeTabStop        (false     ); break; //VT100
+    case TY_CSI_PS('g',   3) : _currentScreen->clearTabStops        (          ); break; //VT100
+    case TY_CSI_PS('h',   4) : _currentScreen->    setMode      (MODE_Insert   ); break;
+    case TY_CSI_PS('h',  20) :          setMode      (MODE_NewLine  ); break;
+    case TY_CSI_PS('i',   0) : /* IGNORE: attached printer          */ break; //VT100
+    case TY_CSI_PS('l',   4) : _currentScreen->  resetMode      (MODE_Insert   ); break;
+    case TY_CSI_PS('l',  20) :        resetMode      (MODE_NewLine  ); break;
+    case TY_CSI_PS('s',   0) :      saveCursor           (          ); break;
+    case TY_CSI_PS('u',   0) :      restoreCursor        (          ); break;
+
+    case TY_CSI_PS('m',   0) : _currentScreen->setDefaultRendition  (          ); break;
+    case TY_CSI_PS('m',   1) : _currentScreen->  setRendition     (RE_BOLD     ); break; //VT100
+    case TY_CSI_PS('m',   4) : _currentScreen->  setRendition     (RE_UNDERLINE); break; //VT100
+    case TY_CSI_PS('m',   5) : _currentScreen->  setRendition     (RE_BLINK    ); break; //VT100
+    case TY_CSI_PS('m',   7) : _currentScreen->  setRendition     (RE_REVERSE  ); break;
+    case TY_CSI_PS('m',  10) : /* IGNORED: mapping related          */ break; //LINUX
+    case TY_CSI_PS('m',  11) : /* IGNORED: mapping related          */ break; //LINUX
+    case TY_CSI_PS('m',  12) : /* IGNORED: mapping related          */ break; //LINUX
+    case TY_CSI_PS('m',  22) : _currentScreen->resetRendition     (RE_BOLD     ); break;
+    case TY_CSI_PS('m',  24) : _currentScreen->resetRendition     (RE_UNDERLINE); break;
+    case TY_CSI_PS('m',  25) : _currentScreen->resetRendition     (RE_BLINK    ); break;
+    case TY_CSI_PS('m',  27) : _currentScreen->resetRendition     (RE_REVERSE  ); break;
+
+    case TY_CSI_PS('m',   30) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM,  0); break;
+    case TY_CSI_PS('m',   31) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM,  1); break;
+    case TY_CSI_PS('m',   32) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM,  2); break;
+    case TY_CSI_PS('m',   33) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM,  3); break;
+    case TY_CSI_PS('m',   34) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM,  4); break;
+    case TY_CSI_PS('m',   35) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM,  5); break;
+    case TY_CSI_PS('m',   36) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM,  6); break;
+    case TY_CSI_PS('m',   37) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM,  7); break;
+
+    case TY_CSI_PS('m',   38) : _currentScreen->setForeColor         (p,       q); break;
+
+    case TY_CSI_PS('m',   39) : _currentScreen->setForeColor         (COLOR_SPACE_DEFAULT,  0); break;
+
+    case TY_CSI_PS('m',   40) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM,  0); break;
+    case TY_CSI_PS('m',   41) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM,  1); break;
+    case TY_CSI_PS('m',   42) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM,  2); break;
+    case TY_CSI_PS('m',   43) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM,  3); break;
+    case TY_CSI_PS('m',   44) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM,  4); break;
+    case TY_CSI_PS('m',   45) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM,  5); break;
+    case TY_CSI_PS('m',   46) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM,  6); break;
+    case TY_CSI_PS('m',   47) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM,  7); break;
+
+    case TY_CSI_PS('m',   48) : _currentScreen->setBackColor         (p,       q); break;
+
+    case TY_CSI_PS('m',   49) : _currentScreen->setBackColor         (COLOR_SPACE_DEFAULT,  1); break;
+
+    case TY_CSI_PS('m',   90) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM,  8); break;
+    case TY_CSI_PS('m',   91) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM,  9); break;
+    case TY_CSI_PS('m',   92) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM, 10); break;
+    case TY_CSI_PS('m',   93) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM, 11); break;
+    case TY_CSI_PS('m',   94) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM, 12); break;
+    case TY_CSI_PS('m',   95) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM, 13); break;
+    case TY_CSI_PS('m',   96) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM, 14); break;
+    case TY_CSI_PS('m',   97) : _currentScreen->setForeColor         (COLOR_SPACE_SYSTEM, 15); break;
+
+    case TY_CSI_PS('m',  100) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM,  8); break;
+    case TY_CSI_PS('m',  101) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM,  9); break;
+    case TY_CSI_PS('m',  102) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM, 10); break;
+    case TY_CSI_PS('m',  103) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM, 11); break;
+    case TY_CSI_PS('m',  104) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM, 12); break;
+    case TY_CSI_PS('m',  105) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM, 13); break;
+    case TY_CSI_PS('m',  106) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM, 14); break;
+    case TY_CSI_PS('m',  107) : _currentScreen->setBackColor         (COLOR_SPACE_SYSTEM, 15); break;
+
+    case TY_CSI_PS('n',   5) :      reportStatus         (          ); break;
+    case TY_CSI_PS('n',   6) :      reportCursorPosition (          ); break;
+    case TY_CSI_PS('q',   0) : /* IGNORED: LEDs off                 */ break; //VT100
+    case TY_CSI_PS('q',   1) : /* IGNORED: LED1 on                  */ break; //VT100
+    case TY_CSI_PS('q',   2) : /* IGNORED: LED2 on                  */ break; //VT100
+    case TY_CSI_PS('q',   3) : /* IGNORED: LED3 on                  */ break; //VT100
+    case TY_CSI_PS('q',   4) : /* IGNORED: LED4 on                  */ break; //VT100
+    case TY_CSI_PS('x',   0) :      reportTerminalParms  (         2); break; //VT100
+    case TY_CSI_PS('x',   1) :      reportTerminalParms  (         3); break; //VT100
+
+    case TY_CSI_PN('@'      ) : _currentScreen->insertChars          (p         ); break;
+    case TY_CSI_PN('A'      ) : _currentScreen->cursorUp             (p         ); break; //VT100
+    case TY_CSI_PN('B'      ) : _currentScreen->cursorDown           (p         ); break; //VT100
+    case TY_CSI_PN('C'      ) : _currentScreen->cursorRight          (p         ); break; //VT100
+    case TY_CSI_PN('D'      ) : _currentScreen->cursorLeft           (p         ); break; //VT100
+    case TY_CSI_PN('G'      ) : _currentScreen->setCursorX           (p         ); break; //LINUX
+    case TY_CSI_PN('H'      ) : _currentScreen->setCursorYX          (p,      q); break; //VT100
+    case TY_CSI_PN('I'      ) : _currentScreen->Tabulate             (p         ); break;
+    case TY_CSI_PN('L'      ) : _currentScreen->insertLines          (p         ); break;
+    case TY_CSI_PN('M'      ) : _currentScreen->deleteLines          (p         ); break;
+    case TY_CSI_PN('P'      ) : _currentScreen->deleteChars          (p         ); break;
+    case TY_CSI_PN('S'      ) : _currentScreen->scrollUp             (p         ); break;
+    case TY_CSI_PN('T'      ) : _currentScreen->scrollDown           (p         ); break;
+    case TY_CSI_PN('X'      ) : _currentScreen->eraseChars           (p         ); break;
+    case TY_CSI_PN('Z'      ) : _currentScreen->backTabulate         (p         ); break;
+    case TY_CSI_PN('c'      ) :      reportTerminalType   (          ); break; //VT100
+    case TY_CSI_PN('d'      ) : _currentScreen->setCursorY           (p         ); break; //LINUX
+    case TY_CSI_PN('f'      ) : _currentScreen->setCursorYX          (p,      q); break; //VT100
+    case TY_CSI_PN('r'      ) :      setMargins           (p,      q); break; //VT100
+    case TY_CSI_PN('y'      ) : /* IGNORED: Confidence test          */ break; //VT100
+
+    case TY_CSI_PR('h',   1) :          setMode      (MODE_AppCuKeys); break; //VT100
+    case TY_CSI_PR('l',   1) :        resetMode      (MODE_AppCuKeys); break; //VT100
+    case TY_CSI_PR('s',   1) :         saveMode      (MODE_AppCuKeys); break; //FIXME
+    case TY_CSI_PR('r',   1) :      restoreMode      (MODE_AppCuKeys); break; //FIXME
+
+    case TY_CSI_PR('l',   2) :        resetMode      (MODE_Ansi     ); break; //VT100
+
+    case TY_CSI_PR('h',   3) : clearScreenAndSetColumns(132);          break; //VT100
+    case TY_CSI_PR('l',   3) : clearScreenAndSetColumns(80);           break; //VT100
+
+    case TY_CSI_PR('h',   4) : /* IGNORED: soft scrolling           */ break; //VT100
+    case TY_CSI_PR('l',   4) : /* IGNORED: soft scrolling           */ break; //VT100
+
+    case TY_CSI_PR('h',   5) : _currentScreen->    setMode      (MODE_Screen   ); break; //VT100
+    case TY_CSI_PR('l',   5) : _currentScreen->  resetMode      (MODE_Screen   ); break; //VT100
+
+    case TY_CSI_PR('h',   6) : _currentScreen->    setMode      (MODE_Origin   ); break; //VT100
+    case TY_CSI_PR('l',   6) : _currentScreen->  resetMode      (MODE_Origin   ); break; //VT100
+    case TY_CSI_PR('s',   6) : _currentScreen->   saveMode      (MODE_Origin   ); break; //FIXME
+    case TY_CSI_PR('r',   6) : _currentScreen->restoreMode      (MODE_Origin   ); break; //FIXME
+
+    case TY_CSI_PR('h',   7) : _currentScreen->    setMode      (MODE_Wrap     ); break; //VT100
+    case TY_CSI_PR('l',   7) : _currentScreen->  resetMode      (MODE_Wrap     ); break; //VT100
+    case TY_CSI_PR('s',   7) : _currentScreen->   saveMode      (MODE_Wrap     ); break; //FIXME
+    case TY_CSI_PR('r',   7) : _currentScreen->restoreMode      (MODE_Wrap     ); break; //FIXME
+
+    case TY_CSI_PR('h',   8) : /* IGNORED: autorepeat on            */ break; //VT100
+    case TY_CSI_PR('l',   8) : /* IGNORED: autorepeat off           */ break; //VT100
+    case TY_CSI_PR('s',   8) : /* IGNORED: autorepeat on            */ break; //VT100
+    case TY_CSI_PR('r',   8) : /* IGNORED: autorepeat off           */ break; //VT100
+
+    case TY_CSI_PR('h',   9) : /* IGNORED: interlace                */ break; //VT100
+    case TY_CSI_PR('l',   9) : /* IGNORED: interlace                */ break; //VT100
+    case TY_CSI_PR('s',   9) : /* IGNORED: interlace                */ break; //VT100
+    case TY_CSI_PR('r',   9) : /* IGNORED: interlace                */ break; //VT100
+
+    case TY_CSI_PR('h',  12) : /* IGNORED: Cursor blink             */ break; //att610
+    case TY_CSI_PR('l',  12) : /* IGNORED: Cursor blink             */ break; //att610
+    case TY_CSI_PR('s',  12) : /* IGNORED: Cursor blink             */ break; //att610
+    case TY_CSI_PR('r',  12) : /* IGNORED: Cursor blink             */ break; //att610
+
+    case TY_CSI_PR('h',  25) :          setMode      (MODE_Cursor   ); break; //VT100
+    case TY_CSI_PR('l',  25) :        resetMode      (MODE_Cursor   ); break; //VT100
+    case TY_CSI_PR('s',  25) :         saveMode      (MODE_Cursor   ); break; //VT100
+    case TY_CSI_PR('r',  25) :      restoreMode      (MODE_Cursor   ); break; //VT100
+
+    case TY_CSI_PR('h',  41) : /* IGNORED: obsolete more(1) fix     */ break; //XTERM
+    case TY_CSI_PR('l',  41) : /* IGNORED: obsolete more(1) fix     */ break; //XTERM
+    case TY_CSI_PR('s',  41) : /* IGNORED: obsolete more(1) fix     */ break; //XTERM
+    case TY_CSI_PR('r',  41) : /* IGNORED: obsolete more(1) fix     */ break; //XTERM
+
+    case TY_CSI_PR('h',  47) :          setMode      (MODE_AppScreen); break; //VT100
+    case TY_CSI_PR('l',  47) :        resetMode      (MODE_AppScreen); break; //VT100
+    case TY_CSI_PR('s',  47) :         saveMode      (MODE_AppScreen); break; //XTERM
+    case TY_CSI_PR('r',  47) :      restoreMode      (MODE_AppScreen); break; //XTERM
+
+    case TY_CSI_PR('h',  67) : /* IGNORED: DECBKM                   */ break; //XTERM
+    case TY_CSI_PR('l',  67) : /* IGNORED: DECBKM                   */ break; //XTERM
+    case TY_CSI_PR('s',  67) : /* IGNORED: DECBKM                   */ break; //XTERM
+    case TY_CSI_PR('r',  67) : /* IGNORED: DECBKM                   */ break; //XTERM
+
+    // XTerm defines the following modes:
+    // SET_VT200_MOUSE             1000
+    // SET_VT200_HIGHLIGHT_MOUSE   1001
+    // SET_BTN_EVENT_MOUSE         1002
+    // SET_ANY_EVENT_MOUSE         1003
+    //
+
+    //Note about mouse modes:
+    //There are four mouse modes which xterm-compatible terminals can support - 1000,1001,1002,1003
+    //Konsole currently supports mode 1000 (basic mouse press and release) and mode 1002 (dragging the mouse).
+    //TODO:  Implementation of mouse modes 1001 (something called hilight tracking) and
+    //1003 (a slight variation on dragging the mouse)
+    //
+
+    case TY_CSI_PR('h', 1000) :          setMode      (MODE_Mouse1000); break; //XTERM
+    case TY_CSI_PR('l', 1000) :        resetMode      (MODE_Mouse1000); break; //XTERM
+    case TY_CSI_PR('s', 1000) :         saveMode      (MODE_Mouse1000); break; //XTERM
+    case TY_CSI_PR('r', 1000) :      restoreMode      (MODE_Mouse1000); break; //XTERM
+
+    case TY_CSI_PR('h', 1001) : /* IGNORED: hilite mouse tracking    */ break; //XTERM
+    case TY_CSI_PR('l', 1001) :        resetMode      (MODE_Mouse1001); break; //XTERM
+    case TY_CSI_PR('s', 1001) : /* IGNORED: hilite mouse tracking    */ break; //XTERM
+    case TY_CSI_PR('r', 1001) : /* IGNORED: hilite mouse tracking    */ break; //XTERM
+
+    case TY_CSI_PR('h', 1002) :          setMode      (MODE_Mouse1002); break; //XTERM
+    case TY_CSI_PR('l', 1002) :        resetMode      (MODE_Mouse1002); break; //XTERM
+    case TY_CSI_PR('s', 1002) :         saveMode      (MODE_Mouse1002); break; //XTERM
+    case TY_CSI_PR('r', 1002) :      restoreMode      (MODE_Mouse1002); break; //XTERM
+
+    case TY_CSI_PR('h', 1003) :          setMode      (MODE_Mouse1003); break; //XTERM
+    case TY_CSI_PR('l', 1003) :        resetMode      (MODE_Mouse1003); break; //XTERM
+    case TY_CSI_PR('s', 1003) :         saveMode      (MODE_Mouse1003); break; //XTERM
+    case TY_CSI_PR('r', 1003) :      restoreMode      (MODE_Mouse1003); break; //XTERM
+    case TY_CSI_PR('h', 1034) : /* IGNORED: 8bitinput activation     */ break; //XTERM
+
+    case TY_CSI_PR('h', 1047) :          setMode      (MODE_AppScreen); break; //XTERM
+    case TY_CSI_PR('l', 1047) : _screen[1]->clearEntireScreen(); resetMode(MODE_AppScreen); break; //XTERM
+    case TY_CSI_PR('s', 1047) :         saveMode      (MODE_AppScreen); break; //XTERM
+    case TY_CSI_PR('r', 1047) :      restoreMode      (MODE_AppScreen); break; //XTERM
+
+    //FIXME: Unitoken: save translations
+    case TY_CSI_PR('h', 1048) :      saveCursor           (          ); break; //XTERM
+    case TY_CSI_PR('l', 1048) :      restoreCursor        (          ); break; //XTERM
+    case TY_CSI_PR('s', 1048) :      saveCursor           (          ); break; //XTERM
+    case TY_CSI_PR('r', 1048) :      restoreCursor        (          ); break; //XTERM
+
+    //FIXME: every once new sequences like this pop up in xterm.
+    //       Here's a guess of what they could mean.
+    case TY_CSI_PR('h', 1049) : saveCursor(); _screen[1]->clearEntireScreen(); setMode(MODE_AppScreen); break; //XTERM
+    case TY_CSI_PR('l', 1049) : resetMode(MODE_AppScreen); restoreCursor(); break; //XTERM
+
+    //FIXME: weird DEC reset sequence
+    case TY_CSI_PE('p'      ) : /* IGNORED: reset         (        ) */ break;
+
+    //FIXME: when changing between vt52 and ansi mode evtl do some resetting.
+    case TY_VT52('A'      ) : _currentScreen->cursorUp             (         1); break; //VT52
+    case TY_VT52('B'      ) : _currentScreen->cursorDown           (         1); break; //VT52
+    case TY_VT52('C'      ) : _currentScreen->cursorRight          (         1); break; //VT52
+    case TY_VT52('D'      ) : _currentScreen->cursorLeft           (         1); break; //VT52
+
+    case TY_VT52('F'      ) :      setAndUseCharset     (0,    '0'); break; //VT52
+    case TY_VT52('G'      ) :      setAndUseCharset     (0,    'B'); break; //VT52
+
+    case TY_VT52('H'      ) : _currentScreen->setCursorYX          (1,1       ); break; //VT52
+    case TY_VT52('I'      ) : _currentScreen->reverseIndex         (          ); break; //VT52
+    case TY_VT52('J'      ) : _currentScreen->clearToEndOfScreen   (          ); break; //VT52
+    case TY_VT52('K'      ) : _currentScreen->clearToEndOfLine     (          ); break; //VT52
+    case TY_VT52('Y'      ) : _currentScreen->setCursorYX          (p-31,q-31 ); break; //VT52
+    case TY_VT52('Z'      ) :      reportTerminalType   (           ); break; //VT52
+    case TY_VT52('<'      ) :          setMode      (MODE_Ansi     ); break; //VT52
+    case TY_VT52('='      ) :          setMode      (MODE_AppKeyPad); break; //VT52
+    case TY_VT52('>'      ) :        resetMode      (MODE_AppKeyPad); break; //VT52
+
+    case TY_CSI_PG('c'      ) :  reportSecondaryAttributes(          ); break; //VT100
+
+    default : ReportErrorToken();    break;
+  };
+}
+
+void Vt102Emulation::clearScreenAndSetColumns(int columnCount)
+{
+    setImageSize(_currentScreen->getLines(),columnCount);
+    clearEntireScreen();
+    setDefaultMargins();
+    _currentScreen->setCursorYX(0,0);
+}
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                          Terminal to Host protocol                        */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+/*
+   Outgoing bytes originate from several sources:
+
+   - Replies to Enquieries.
+   - Mouse Events
+   - Keyboard Events
+*/
+
+/*!
+*/
+
+void Vt102Emulation::sendString(const char* s , int length)
+{
+  if ( length >= 0 )
+    emit sendData(s,length);
+  else
+    emit sendData(s,strlen(s));
+}
+
+// Replies ----------------------------------------------------------------- --
+
+// This section copes with replies send as response to an enquiery control code.
+
+/*!
+*/
+
+void Vt102Emulation::reportCursorPosition()
+{ char tmp[20];
+  sprintf(tmp,"\033[%d;%dR",_currentScreen->getCursorY()+1,_currentScreen->getCursorX()+1);
+  sendString(tmp);
+}
+
+/*
+   What follows here is rather obsolete and faked stuff.
+   The correspondent enquieries are neverthenless issued.
+*/
+
+/*!
+*/
+
+void Vt102Emulation::reportTerminalType()
+{
+  // Primary device attribute response (Request was: ^[[0c or ^[[c (from TT321 Users Guide))
+  //   VT220:  ^[[?63;1;2;3;6;7;8c   (list deps on emul. capabilities)
+  //   VT100:  ^[[?1;2c
+  //   VT101:  ^[[?1;0c
+  //   VT102:  ^[[?6v
+  if (getMode(MODE_Ansi))
+    sendString("\033[?1;2c");     // I'm a VT100
+  else
+    sendString("\033/Z");         // I'm a VT52
+}
+
+void Vt102Emulation::reportSecondaryAttributes()
+{
+  // Seconday device attribute response (Request was: ^[[>0c or ^[[>c)
+  if (getMode(MODE_Ansi))
+    sendString("\033[>0;115;0c"); // Why 115?  ;)
+  else
+    sendString("\033/Z");         // FIXME I don't think VT52 knows about it but kept for
+                                  // konsoles backward compatibility.
+}
+
+void Vt102Emulation::reportTerminalParms(int p)
+// DECREPTPARM
+{ char tmp[100];
+  sprintf(tmp,"\033[%d;1;1;112;112;1;0x",p); // not really true.
+  sendString(tmp);
+}
+
+/*!
+*/
+
+void Vt102Emulation::reportStatus()
+{
+  sendString("\033[0n"); //VT100. Device status report. 0 = Ready.
+}
+
+/*!
+*/
+
+#define ANSWER_BACK "" // This is really obsolete VT100 stuff.
+
+void Vt102Emulation::reportAnswerBack()
+{
+  sendString(ANSWER_BACK);
+}
+
+// Mouse Handling ---------------------------------------------------------- --
+
+/*!
+    Mouse clicks are possibly reported to the client
+    application if it has issued interest in them.
+    They are normally consumed by the widget for copy
+    and paste, but may be propagated from the widget
+    when gui->setMouseMarks is set via setMode(MODE_Mouse1000).
+
+    `x',`y' are 1-based.
+    `ev' (event) indicates the button pressed (0-2)
+                 or a general mouse release (3).
+
+    eventType represents the kind of mouse action that occurred:
+        0 = Mouse button press or release
+    1 = Mouse drag
+*/
+
+void Vt102Emulation::sendMouseEvent( int cb, int cx, int cy , int eventType )
+{ char tmp[20];
+  if (  cx<1 || cy<1 ) return;
+  // normal buttons are passed as 0x20 + button,
+  // mouse wheel (buttons 4,5) as 0x5c + button
+  if (cb >= 4) cb += 0x3c;
+
+  //Mouse motion handling
+  if ( (getMode(MODE_Mouse1002) || getMode(MODE_Mouse1003)) && eventType == 1 )
+      cb += 0x20; //add 32 to signify motion event
+
+  sprintf(tmp,"\033[M%c%c%c",cb+0x20,cx+0x20,cy+0x20);
+  sendString(tmp);
+}
+
+// Keyboard Handling ------------------------------------------------------- --
+
+#define encodeMode(M,B) BITS(B,getMode(M))
+#define encodeStat(M,B) BITS(B,((ev->modifiers() & (M)) == (M)))
+
+void Vt102Emulation::sendText( const QString& text )
+{
+  if (!text.isEmpty()) {
+    QKeyEvent event(QEvent::KeyPress,
+                    0,
+                    Qt::NoModifier,
+                    text);
+    sendKeyEvent(&event); // expose as a big fat keypress event
+  }
+
+}
+
+void Vt102Emulation::sendKeyEvent( QKeyEvent* event )
+{
+    Qt::KeyboardModifiers modifiers = event->modifiers();
+    KeyboardTranslator::States states = KeyboardTranslator::NoState;
+
+    // get current states
+    if ( getMode(MODE_NewLine)  ) states |= KeyboardTranslator::NewLineState;
+    if ( getMode(MODE_Ansi)     ) states |= KeyboardTranslator::AnsiState;
+    if ( getMode(MODE_AppCuKeys)) states |= KeyboardTranslator::CursorKeysState;
+    if ( getMode(MODE_AppScreen)) states |= KeyboardTranslator::AlternateScreenState;
+
+    // lookup key binding
+    if ( _keyTranslator )
+    {
+    KeyboardTranslator::Entry entry = _keyTranslator->findEntry(
+                                                event->key() ,
+                                                modifiers,
+                                                states );
+
+        // send result to terminal
+        QByteArray textToSend;
+
+        // special handling for the Alt (aka. Meta) modifier.  pressing
+        // Alt+[Character] results in Esc+[Character] being sent
+        // (unless there is an entry defined for this particular combination
+        //  in the keyboard modifier)
+        bool wantsAltModifier = entry.modifiers() & entry.modifierMask() & Qt::AltModifier;
+        bool wantsAnyModifier = entry.state() & entry.stateMask() & KeyboardTranslator::AnyModifierState;
+
+        if ( modifiers & Qt::AltModifier && !(wantsAltModifier || wantsAnyModifier)
+             && !event->text().isEmpty() )
+        {
+            textToSend.prepend("\033");
+        }
+
+        if ( entry.command() != KeyboardTranslator::NoCommand )
+        {
+            if (entry.command() & KeyboardTranslator::EraseCommand)
+                textToSend += getErase();
+            // TODO command handling
+        }
+        else if ( !entry.text().isEmpty() )
+        {
+            textToSend += _codec->fromUnicode(entry.text(true,modifiers));
+        }
+        else
+            textToSend += _codec->fromUnicode(event->text());
+
+        sendData( textToSend.constData() , textToSend.length() );
+    }
+    else
+    {
+        // print an error message to the terminal if no key translator has been
+        // set
+        QString translatorError =  ("No keyboard translator available.  "
+                                         "The information needed to convert key presses "
+                                         "into characters to send to the terminal "
+                                         "is missing.");
+
+        reset();
+        receiveData( translatorError.toAscii().constData() , translatorError.count() );
+    }
+}
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                                VT100 Charsets                             */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+// Character Set Conversion ------------------------------------------------ --
+
+/*
+   The processing contains a VT100 specific code translation layer.
+   It's still in use and mainly responsible for the line drawing graphics.
+
+   These and some other glyphs are assigned to codes (0x5f-0xfe)
+   normally occupied by the latin letters. Since this codes also
+   appear within control sequences, the extra code conversion
+   does not permute with the tokenizer and is placed behind it
+   in the pipeline. It only applies to tokens, which represent
+   plain characters.
+
+   This conversion it eventually continued in TerminalDisplay.C, since
+   it might involve VT100 enhanced fonts, which have these
+   particular glyphs allocated in (0x00-0x1f) in their code page.
+*/
+
+#define CHARSET _charset[_currentScreen==_screen[1]]
+
+// Apply current character map.
+
+unsigned short Vt102Emulation::applyCharset(unsigned short c)
+{
+  if (CHARSET.graphic && 0x5f <= c && c <= 0x7e) return vt100_graphics[c-0x5f];
+  if (CHARSET.pound                && c == '#' ) return 0xa3; //This mode is obsolete
+  return c;
+}
+
+/*
+   "Charset" related part of the emulation state.
+   This configures the VT100 _charset filter.
+
+   While most operation work on the current _screen,
+   the following two are different.
+*/
+
+void Vt102Emulation::resetCharset(int scrno)
+{
+  _charset[scrno].cu_cs   = 0;
+  strncpy(_charset[scrno].charset,"BBBB",4);
+  _charset[scrno].sa_graphic = false;
+  _charset[scrno].sa_pound   = false;
+  _charset[scrno].graphic = false;
+  _charset[scrno].pound   = false;
+}
+
+void Vt102Emulation::setCharset(int n, int cs) // on both screens.
+{
+  _charset[0].charset[n&3] = cs; useCharset(_charset[0].cu_cs);
+  _charset[1].charset[n&3] = cs; useCharset(_charset[1].cu_cs);
+}
+
+void Vt102Emulation::setAndUseCharset(int n, int cs)
+{
+  CHARSET.charset[n&3] = cs;
+  useCharset(n&3);
+}
+
+void Vt102Emulation::useCharset(int n)
+{
+  CHARSET.cu_cs   = n&3;
+  CHARSET.graphic = (CHARSET.charset[n&3] == '0');
+  CHARSET.pound   = (CHARSET.charset[n&3] == 'A'); //This mode is obsolete
+}
+
+void Vt102Emulation::setDefaultMargins()
+{
+    _screen[0]->setDefaultMargins();
+    _screen[1]->setDefaultMargins();
+}
+
+void Vt102Emulation::setMargins(int t, int b)
+{
+  _screen[0]->setMargins(t, b);
+  _screen[1]->setMargins(t, b);
+}
+
+/*! Save the cursor position and the rendition attribute settings. */
+
+void Vt102Emulation::saveCursor()
+{
+  CHARSET.sa_graphic = CHARSET.graphic;
+  CHARSET.sa_pound   = CHARSET.pound; //This mode is obsolete
+  // we are not clear about these
+  //sa_charset = charsets[cScreen->_charset];
+  //sa_charset_num = cScreen->_charset;
+  _currentScreen->saveCursor();
+}
+
+/*! Restore the cursor position and the rendition attribute settings. */
+
+void Vt102Emulation::restoreCursor()
+{
+  CHARSET.graphic = CHARSET.sa_graphic;
+  CHARSET.pound   = CHARSET.sa_pound; //This mode is obsolete
+  _currentScreen->restoreCursor();
+}
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                                Mode Operations                            */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+/*
+   Some of the emulations state is either added to the state of the screens.
+
+   This causes some scoping problems, since different emulations choose to
+   located the mode either to the current _screen or to both.
+
+   For strange reasons, the extend of the rendition attributes ranges over
+   all screens and not over the actual _screen.
+
+   We decided on the precise precise extend, somehow.
+*/
+
+// "Mode" related part of the state. These are all booleans.
+
+void Vt102Emulation::resetModes()
+{
+  resetMode(MODE_Mouse1000); saveMode(MODE_Mouse1000);
+  resetMode(MODE_Mouse1001); saveMode(MODE_Mouse1001);
+  resetMode(MODE_Mouse1002); saveMode(MODE_Mouse1002);
+  resetMode(MODE_Mouse1003); saveMode(MODE_Mouse1003);
+
+  resetMode(MODE_AppScreen); saveMode(MODE_AppScreen);
+  // here come obsolete modes
+  resetMode(MODE_AppCuKeys); saveMode(MODE_AppCuKeys);
+  resetMode(MODE_NewLine  );
+    setMode(MODE_Ansi     );
+}
+
+void Vt102Emulation::setMode(int m)
+{
+  _currParm.mode[m] = true;
+  switch (m)
+  {
+    case MODE_Mouse1000:
+    case MODE_Mouse1001:
+    case MODE_Mouse1002:
+    case MODE_Mouse1003:
+        emit programUsesMouseChanged(false);
+    break;
+
+    case MODE_AppScreen : _screen[1]->clearSelection();
+                          setScreen(1);
+    break;
+  }
+  if (m < MODES_SCREEN || m == MODE_NewLine)
+  {
+    _screen[0]->setMode(m);
+    _screen[1]->setMode(m);
+  }
+}
+
+void Vt102Emulation::resetMode(int m)
+{
+  _currParm.mode[m] = false;
+  switch (m)
+  {
+    case MODE_Mouse1000 :
+    case MODE_Mouse1001 :
+    case MODE_Mouse1002 :
+    case MODE_Mouse1003 :
+        emit programUsesMouseChanged(true);
+    break;
+
+    case MODE_AppScreen : _screen[0]->clearSelection();
+                          setScreen(0);
+    break;
+  }
+  if (m < MODES_SCREEN || m == MODE_NewLine)
+  {
+    _screen[0]->resetMode(m);
+    _screen[1]->resetMode(m);
+  }
+}
+
+void Vt102Emulation::saveMode(int m)
+{
+  _saveParm.mode[m] = _currParm.mode[m];
+}
+
+void Vt102Emulation::restoreMode(int m)
+{
+  if (_saveParm.mode[m])
+      setMode(m);
+  else
+      resetMode(m);
+}
+
+bool Vt102Emulation::getMode(int m)
+{
+  return _currParm.mode[m];
+}
+
+char Vt102Emulation::getErase() const
+{
+  KeyboardTranslator::Entry entry = _keyTranslator->findEntry(
+                                            Qt::Key_Backspace,
+                                            0,
+                                            0);
+  if ( entry.text().count() > 0 )
+      return entry.text()[0];
+  else
+      return '\b';
+}
+
+/* ------------------------------------------------------------------------- */
+/*                                                                           */
+/*                               Diagnostic                                  */
+/*                                                                           */
+/* ------------------------------------------------------------------------- */
+
+/*! shows the contents of the scan buffer.
+
+    This functions is used for diagnostics. It is called by \e ReportErrorToken
+    to inform about strings that cannot be decoded or handled by the emulation.
+
+    \sa ReportErrorToken
+*/
+
+static void hexdump(int* s, int len)
+{ int i;
+  for (i = 0; i < len; i++)
+  {
+    if (s[i] == '\\')
+      printf("\\\\");
+    else
+    if ((s[i]) > 32 && s[i] < 127)
+      printf("%c",s[i]);
+    else
+      printf("\\%04x(hex)",s[i]);
+  }
+}
+
+void Vt102Emulation::scan_buffer_report() {
+  if (ppos == 0 || (ppos == 1 && (pbuf[0] & 0xff) >= 32)) {
+    return;
+  }
+  printf("token: ");
+  hexdump(pbuf,ppos);
+  printf("\n");
+}
+
+/*!
+*/
+
+void Vt102Emulation::ReportErrorToken()
+{
+#ifndef NDEBUG
+  printf("undecodable "); scan_buffer_report();
+#endif
+}
+
+
diff --git a/libgui/qterminal/libqterminal/unix/Vt102Emulation.h b/libgui/qterminal/libqterminal/unix/Vt102Emulation.h
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/Vt102Emulation.h
@@ -0,0 +1,187 @@
+/*
+    This file is part of Konsole, an X terminal.
+    
+    Copyright (C) 2007 by Robert Knight <robertknight@gmail.com>
+    Copyright (C) 1997,1998 by Lars Doelle <lars.doelle@on-line.de>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+    02110-1301  USA.
+*/
+
+#ifndef VT102EMULATION_H
+#define VT102EMULATION_H
+
+// Standard Library
+#include <stdio.h>
+
+// Qt 
+#include <QtGui/QKeyEvent>
+#include <QtCore/QHash>
+#include <QtCore/QTimer>
+
+// Konsole
+#include "unix/Emulation.h"
+#include "unix/Screen.h"
+
+#define MODE_AppScreen (MODES_SCREEN+0)
+#define MODE_AppCuKeys (MODES_SCREEN+1)
+#define MODE_AppKeyPad (MODES_SCREEN+2)
+#define MODE_Mouse1000 (MODES_SCREEN+3)
+#define MODE_Mouse1001 (MODES_SCREEN+4)
+#define MODE_Mouse1002 (MODES_SCREEN+5)
+#define MODE_Mouse1003 (MODES_SCREEN+6)
+#define MODE_Ansi      (MODES_SCREEN+7)
+#define MODE_total     (MODES_SCREEN+8)
+
+struct DECpar
+{
+  bool mode[MODE_total];
+};
+
+struct CharCodes
+{
+  // coding info
+  char charset[4]; //
+  int  cu_cs;      // actual charset.
+  bool graphic;    // Some VT100 tricks
+  bool pound  ;    // Some VT100 tricks
+  bool sa_graphic; // saved graphic
+  bool sa_pound;   // saved pound
+};
+
+/**
+ * Provides an xterm compatible terminal emulation based on the DEC VT102 terminal.
+ * A full description of this terminal can be found at http://vt100.net/docs/vt102-ug/
+ * 
+ * In addition, various additional xterm escape sequences are supported to provide 
+ * features such as mouse input handling.
+ * See http://rtfm.etla.org/xterm/ctlseq.html for a description of xterm's escape
+ * sequences. 
+ *
+ */
+class Vt102Emulation : public Emulation
+{ 
+Q_OBJECT
+
+public:
+
+  /** Constructs a new emulation */
+  Vt102Emulation();
+  ~Vt102Emulation();
+  
+  // reimplemented
+  virtual void clearEntireScreen();
+  virtual void reset();
+  
+  // reimplemented
+  virtual char getErase() const;
+  
+public slots: 
+
+  // reimplemented 
+  virtual void sendString(const char*,int length = -1);
+  virtual void sendText(const QString& text);
+  virtual void sendKeyEvent(QKeyEvent*);
+  virtual void sendMouseEvent( int buttons, int column, int line , int eventType );
+  
+protected:
+  // reimplemented
+  virtual void setMode    (int mode);
+  virtual void resetMode  (int mode);
+
+  // reimplemented 
+  virtual void receiveChar(int cc);
+  
+
+private slots:
+		
+  //causes changeTitle() to be emitted for each (int,QString) pair in pendingTitleUpdates
+  //used to buffer multiple title updates
+  void updateTitle();
+
+
+private:
+  unsigned short applyCharset(unsigned short c);
+  void setCharset(int n, int cs);
+  void useCharset(int n);
+  void setAndUseCharset(int n, int cs);
+  void saveCursor();
+  void restoreCursor();
+  void resetCharset(int scrno);
+
+  void setMargins(int top, int bottom);
+  //set margins for all screens back to their defaults
+  void setDefaultMargins();
+
+  // returns true if 'mode' is set or false otherwise
+  bool getMode    (int mode);
+  // saves the current boolean value of 'mode'
+  void saveMode   (int mode);
+  // restores the boolean value of 'mode' 
+  void restoreMode(int mode);
+  // resets all modes
+  void resetModes();
+
+  void resetToken();
+#define MAXPBUF 80
+  void pushToToken(int cc);
+  int pbuf[MAXPBUF]; //FIXME: overflow?
+  int ppos;
+#define MAXARGS 15
+  void addDigit(int dig);
+  void addArgument();
+  int argv[MAXARGS];
+  int argc;
+  void initTokenizer();
+  int tbl[256];
+
+  void scan_buffer_report(); //FIXME: rename
+  void ReportErrorToken();   //FIXME: rename
+
+  void tau(int code, int p, int q);
+  void XtermHack();
+
+  void reportTerminalType();
+  void reportSecondaryAttributes();
+  void reportStatus();
+  void reportAnswerBack();
+  void reportCursorPosition();
+  void reportTerminalParms(int p);
+
+  void onScrollLock();
+  void scrollLock(const bool lock);
+
+  // clears the screen and resizes it to the specified
+  // number of columns
+  void clearScreenAndSetColumns(int columnCount);
+
+  CharCodes _charset[2];
+
+  DECpar _currParm;
+  DECpar _saveParm;
+
+  //hash table and timer for buffering calls to the session instance 
+  //to update the name of the session
+  //or window title.
+  //these calls occur when certain escape sequences are seen in the 
+  //output from the terminal
+  QHash<int,QString> _pendingTitleUpdates;
+  QTimer* _titleUpdateTimer;
+  
+};
+
+#endif // VT102EMULATION_H
diff --git a/libgui/qterminal/libqterminal/unix/konsole_wcwidth.cpp b/libgui/qterminal/libqterminal/unix/konsole_wcwidth.cpp
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/konsole_wcwidth.cpp
@@ -0,0 +1,216 @@
+/* $XFree86: xc/programs/xterm/wcwidth.character,v 1.3 2001/07/29 22:08:16 tsi Exp $ */
+/*
+ * This is an implementation of wcwidth() and wcswidth() as defined in
+ * "The Single UNIX Specification, Version 2, The Open Group, 1997"
+ * <http://www.UNIX-systems.org/online.html>
+ *
+ * Markus Kuhn -- 2001-01-12 -- public domain
+ */
+
+#include "unix/konsole_wcwidth.h"
+
+struct interval {
+  unsigned short first;
+  unsigned short last;
+};
+
+/* auxiliary function for binary search in interval table */
+static int bisearch(quint16 ucs, const struct interval *table, int max) {
+  int min = 0;
+  int mid;
+
+  if (ucs < table[0].first || ucs > table[max].last)
+    return 0;
+  while (max >= min) {
+    mid = (min + max) / 2;
+    if (ucs > table[mid].last)
+      min = mid + 1;
+    else if (ucs < table[mid].first)
+      max = mid - 1;
+    else
+      return 1;
+  }
+
+  return 0;
+}
+
+
+/* The following functions define the column width of an ISO 10646
+ * character as follows:
+ *
+ *    - The null character (U+0000) has a column width of 0.
+ *
+ *    - Other C0/C1 control characters and DEL will lead to a return
+ *      value of -1.
+ *
+ *    - Non-spacing and enclosing combining characters (general
+ *      category code Mn or Me in the Unicode database) have a
+ *      column width of 0.
+ *
+ *    - Other format characters (general category code Cf in the Unicode
+ *      database) and ZERO WIDTH SPACE (U+200B) have a column width of 0.
+ *
+ *    - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF)
+ *      have a column width of 0.
+ *
+ *    - Spacing characters in the East Asian Wide (W) or East Asian
+ *      FullWidth (F) category as defined in Unicode Technical
+ *      Report #11 have a column width of 2.
+ *
+ *    - All remaining characters (including all printable
+ *      ISO 8859-1 and WGL4 characters, Unicode control characters,
+ *      etc.) have a column width of 1.
+ *
+ * This implementation assumes that quint16 characters are encoded
+ * in ISO 10646.
+ */
+
+int konsole_wcwidth(quint16 ucs)
+{
+  /* sorted list of non-overlapping intervals of non-spacing characters */
+  static const struct interval combining[] = {
+    { 0x0300, 0x034E }, { 0x0360, 0x0362 }, { 0x0483, 0x0486 },
+    { 0x0488, 0x0489 }, { 0x0591, 0x05A1 }, { 0x05A3, 0x05B9 },
+    { 0x05BB, 0x05BD }, { 0x05BF, 0x05BF }, { 0x05C1, 0x05C2 },
+    { 0x05C4, 0x05C4 }, { 0x064B, 0x0655 }, { 0x0670, 0x0670 },
+    { 0x06D6, 0x06E4 }, { 0x06E7, 0x06E8 }, { 0x06EA, 0x06ED },
+    { 0x070F, 0x070F }, { 0x0711, 0x0711 }, { 0x0730, 0x074A },
+    { 0x07A6, 0x07B0 }, { 0x0901, 0x0902 }, { 0x093C, 0x093C },
+    { 0x0941, 0x0948 }, { 0x094D, 0x094D }, { 0x0951, 0x0954 },
+    { 0x0962, 0x0963 }, { 0x0981, 0x0981 }, { 0x09BC, 0x09BC },
+    { 0x09C1, 0x09C4 }, { 0x09CD, 0x09CD }, { 0x09E2, 0x09E3 },
+    { 0x0A02, 0x0A02 }, { 0x0A3C, 0x0A3C }, { 0x0A41, 0x0A42 },
+    { 0x0A47, 0x0A48 }, { 0x0A4B, 0x0A4D }, { 0x0A70, 0x0A71 },
+    { 0x0A81, 0x0A82 }, { 0x0ABC, 0x0ABC }, { 0x0AC1, 0x0AC5 },
+    { 0x0AC7, 0x0AC8 }, { 0x0ACD, 0x0ACD }, { 0x0B01, 0x0B01 },
+    { 0x0B3C, 0x0B3C }, { 0x0B3F, 0x0B3F }, { 0x0B41, 0x0B43 },
+    { 0x0B4D, 0x0B4D }, { 0x0B56, 0x0B56 }, { 0x0B82, 0x0B82 },
+    { 0x0BC0, 0x0BC0 }, { 0x0BCD, 0x0BCD }, { 0x0C3E, 0x0C40 },
+    { 0x0C46, 0x0C48 }, { 0x0C4A, 0x0C4D }, { 0x0C55, 0x0C56 },
+    { 0x0CBF, 0x0CBF }, { 0x0CC6, 0x0CC6 }, { 0x0CCC, 0x0CCD },
+    { 0x0D41, 0x0D43 }, { 0x0D4D, 0x0D4D }, { 0x0DCA, 0x0DCA },
+    { 0x0DD2, 0x0DD4 }, { 0x0DD6, 0x0DD6 }, { 0x0E31, 0x0E31 },
+    { 0x0E34, 0x0E3A }, { 0x0E47, 0x0E4E }, { 0x0EB1, 0x0EB1 },
+    { 0x0EB4, 0x0EB9 }, { 0x0EBB, 0x0EBC }, { 0x0EC8, 0x0ECD },
+    { 0x0F18, 0x0F19 }, { 0x0F35, 0x0F35 }, { 0x0F37, 0x0F37 },
+    { 0x0F39, 0x0F39 }, { 0x0F71, 0x0F7E }, { 0x0F80, 0x0F84 },
+    { 0x0F86, 0x0F87 }, { 0x0F90, 0x0F97 }, { 0x0F99, 0x0FBC },
+    { 0x0FC6, 0x0FC6 }, { 0x102D, 0x1030 }, { 0x1032, 0x1032 },
+    { 0x1036, 0x1037 }, { 0x1039, 0x1039 }, { 0x1058, 0x1059 },
+    { 0x1160, 0x11FF }, { 0x17B7, 0x17BD }, { 0x17C6, 0x17C6 },
+    { 0x17C9, 0x17D3 }, { 0x180B, 0x180E }, { 0x18A9, 0x18A9 },
+    { 0x200B, 0x200F }, { 0x202A, 0x202E }, { 0x206A, 0x206F },
+    { 0x20D0, 0x20E3 }, { 0x302A, 0x302F }, { 0x3099, 0x309A },
+    { 0xFB1E, 0xFB1E }, { 0xFE20, 0xFE23 }, { 0xFEFF, 0xFEFF },
+    { 0xFFF9, 0xFFFB }
+  };
+
+  /* test for 8-bit control characters */
+  if (ucs == 0)
+    return 0;
+  if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0))
+    return -1;
+
+  /* binary search in table of non-spacing characters */
+  if (bisearch(ucs, combining,
+	       sizeof(combining) / sizeof(struct interval) - 1))
+    return 0;
+
+  /* if we arrive here, ucs is not a combining or C0/C1 control character */
+
+  return 1 +
+    (ucs >= 0x1100 &&
+     (ucs <= 0x115f ||                    /* Hangul Jamo init. consonants */
+      (ucs >= 0x2e80 && ucs <= 0xa4cf && (ucs & ~0x0011) != 0x300a &&
+       ucs != 0x303f) ||                  /* CJK ... Yi */
+      (ucs >= 0xac00 && ucs <= 0xd7a3) || /* Hangul Syllables */
+      (ucs >= 0xf900 && ucs <= 0xfaff) || /* CJK Compatibility Ideographs */
+      (ucs >= 0xfe30 && ucs <= 0xfe6f) || /* CJK Compatibility Forms */
+      (ucs >= 0xff00 && ucs <= 0xff5f) || /* Fullwidth Forms */
+      (ucs >= 0xffe0 && ucs <= 0xffe6) /* do not compare UINT16 with 0x20000 ||
+      (ucs >= 0x20000 && ucs <= 0x2ffff) */));
+}
+
+#if 0
+/*
+ * The following function is the same as konsole_wcwidth(), except that
+ * spacing characters in the East Asian Ambiguous (A) category as
+ * defined in Unicode Technical Report #11 have a column width of 2.
+ * This experimental variant might be useful for users of CJK legacy
+ * encodings who want to migrate to UCS. It is not otherwise
+ * recommended for general use.
+ */
+int konsole_wcwidth_cjk(quint16 ucs)
+{
+  /* sorted list of non-overlapping intervals of East Asian Ambiguous
+   * characters */
+  static const struct interval ambiguous[] = {
+    { 0x00A1, 0x00A1 }, { 0x00A4, 0x00A4 }, { 0x00A7, 0x00A8 },
+    { 0x00AA, 0x00AA }, { 0x00AD, 0x00AD }, { 0x00B0, 0x00B4 },
+    { 0x00B6, 0x00BA }, { 0x00BC, 0x00BF }, { 0x00C6, 0x00C6 },
+    { 0x00D0, 0x00D0 }, { 0x00D7, 0x00D8 }, { 0x00DE, 0x00E1 },
+    { 0x00E6, 0x00E6 }, { 0x00E8, 0x00EA }, { 0x00EC, 0x00ED },
+    { 0x00F0, 0x00F0 }, { 0x00F2, 0x00F3 }, { 0x00F7, 0x00FA },
+    { 0x00FC, 0x00FC }, { 0x00FE, 0x00FE }, { 0x0101, 0x0101 },
+    { 0x0111, 0x0111 }, { 0x0113, 0x0113 }, { 0x011B, 0x011B },
+    { 0x0126, 0x0127 }, { 0x012B, 0x012B }, { 0x0131, 0x0133 },
+    { 0x0138, 0x0138 }, { 0x013F, 0x0142 }, { 0x0144, 0x0144 },
+    { 0x0148, 0x014A }, { 0x014D, 0x014D }, { 0x0152, 0x0153 },
+    { 0x0166, 0x0167 }, { 0x016B, 0x016B }, { 0x01CE, 0x01CE },
+    { 0x01D0, 0x01D0 }, { 0x01D2, 0x01D2 }, { 0x01D4, 0x01D4 },
+    { 0x01D6, 0x01D6 }, { 0x01D8, 0x01D8 }, { 0x01DA, 0x01DA },
+    { 0x01DC, 0x01DC }, { 0x0251, 0x0251 }, { 0x0261, 0x0261 },
+    { 0x02C7, 0x02C7 }, { 0x02C9, 0x02CB }, { 0x02CD, 0x02CD },
+    { 0x02D0, 0x02D0 }, { 0x02D8, 0x02DB }, { 0x02DD, 0x02DD },
+    { 0x0391, 0x03A1 }, { 0x03A3, 0x03A9 }, { 0x03B1, 0x03C1 },
+    { 0x03C3, 0x03C9 }, { 0x0401, 0x0401 }, { 0x0410, 0x044F },
+    { 0x0451, 0x0451 }, { 0x2010, 0x2010 }, { 0x2013, 0x2016 },
+    { 0x2018, 0x2019 }, { 0x201C, 0x201D }, { 0x2020, 0x2021 },
+    { 0x2025, 0x2027 }, { 0x2030, 0x2030 }, { 0x2032, 0x2033 },
+    { 0x2035, 0x2035 }, { 0x203B, 0x203B }, { 0x2074, 0x2074 },
+    { 0x207F, 0x207F }, { 0x2081, 0x2084 }, { 0x20AC, 0x20AC },
+    { 0x2103, 0x2103 }, { 0x2105, 0x2105 }, { 0x2109, 0x2109 },
+    { 0x2113, 0x2113 }, { 0x2121, 0x2122 }, { 0x2126, 0x2126 },
+    { 0x212B, 0x212B }, { 0x2154, 0x2155 }, { 0x215B, 0x215B },
+    { 0x215E, 0x215E }, { 0x2160, 0x216B }, { 0x2170, 0x2179 },
+    { 0x2190, 0x2199 }, { 0x21D2, 0x21D2 }, { 0x21D4, 0x21D4 },
+    { 0x2200, 0x2200 }, { 0x2202, 0x2203 }, { 0x2207, 0x2208 },
+    { 0x220B, 0x220B }, { 0x220F, 0x220F }, { 0x2211, 0x2211 },
+    { 0x2215, 0x2215 }, { 0x221A, 0x221A }, { 0x221D, 0x2220 },
+    { 0x2223, 0x2223 }, { 0x2225, 0x2225 }, { 0x2227, 0x222C },
+    { 0x222E, 0x222E }, { 0x2234, 0x2237 }, { 0x223C, 0x223D },
+    { 0x2248, 0x2248 }, { 0x224C, 0x224C }, { 0x2252, 0x2252 },
+    { 0x2260, 0x2261 }, { 0x2264, 0x2267 }, { 0x226A, 0x226B },
+    { 0x226E, 0x226F }, { 0x2282, 0x2283 }, { 0x2286, 0x2287 },
+    { 0x2295, 0x2295 }, { 0x2299, 0x2299 }, { 0x22A5, 0x22A5 },
+    { 0x22BF, 0x22BF }, { 0x2312, 0x2312 }, { 0x2460, 0x24BF },
+    { 0x24D0, 0x24E9 }, { 0x2500, 0x254B }, { 0x2550, 0x2574 },
+    { 0x2580, 0x258F }, { 0x2592, 0x2595 }, { 0x25A0, 0x25A1 },
+    { 0x25A3, 0x25A9 }, { 0x25B2, 0x25B3 }, { 0x25B6, 0x25B7 },
+    { 0x25BC, 0x25BD }, { 0x25C0, 0x25C1 }, { 0x25C6, 0x25C8 },
+    { 0x25CB, 0x25CB }, { 0x25CE, 0x25D1 }, { 0x25E2, 0x25E5 },
+    { 0x25EF, 0x25EF }, { 0x2605, 0x2606 }, { 0x2609, 0x2609 },
+    { 0x260E, 0x260F }, { 0x261C, 0x261C }, { 0x261E, 0x261E },
+    { 0x2640, 0x2640 }, { 0x2642, 0x2642 }, { 0x2660, 0x2661 },
+    { 0x2663, 0x2665 }, { 0x2667, 0x266A }, { 0x266C, 0x266D },
+    { 0x266F, 0x266F }, { 0x300A, 0x300B }, { 0x301A, 0x301B },
+    { 0xE000, 0xF8FF }, { 0xFFFD, 0xFFFD }
+  };
+
+  /* binary search in table of non-spacing characters */
+  if (bisearch(ucs, ambiguous,
+	       sizeof(ambiguous) / sizeof(struct interval) - 1))
+    return 2;
+
+  return konsole_wcwidth(ucs);
+}
+#endif
+
+// single byte char: +1, multi byte char: +2
+int string_width( const QString &txt )
+{
+  int w = 0;
+  for ( int i = 0; i < txt.length(); ++i )
+     w += konsole_wcwidth( txt[ i ].unicode() );
+ return w;
+}
diff --git a/libgui/qterminal/libqterminal/unix/konsole_wcwidth.h b/libgui/qterminal/libqterminal/unix/konsole_wcwidth.h
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/konsole_wcwidth.h
@@ -0,0 +1,24 @@
+/* $XFree86: xc/programs/xterm/wcwidth.h,v 1.2 2001/06/18 19:09:27 dickey Exp $ */
+
+/* Markus Kuhn -- 2001-01-12 -- public domain */
+/* Adaptions for KDE by Waldo Bastian <bastian@kde.org> */
+/*
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>
+*/
+
+
+#ifndef	_KONSOLE_WCWIDTH_H_
+#define	_KONSOLE_WCWIDTH_H_
+
+// Qt
+#include <QtCore/QBool>
+#include <QtCore/QString>
+
+int konsole_wcwidth(quint16 ucs);
+#if 0
+int konsole_wcwidth_cjk(Q_UINT16 ucs);
+#endif
+
+int string_width( const QString &txt );
+
+#endif
diff --git a/libgui/qterminal/libqterminal/unix/kpty.cpp b/libgui/qterminal/libqterminal/unix/kpty.cpp
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/kpty.cpp
@@ -0,0 +1,484 @@
+/*
+
+   This file is part of the KDE libraries
+   Copyright (C) 2002 Waldo Bastian <bastian@kde.org>
+   Copyright (C) 2002-2003,2007 Oswald Buddenhagen <ossi@kde.org>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "unix/kpty_p.h"
+
+#ifdef __sgi
+#define __svr4__
+#endif
+
+#ifdef __osf__
+#define _OSF_SOURCE
+#include <float.h>
+#endif
+
+#ifdef _AIX
+#define _ALL_SOURCE
+#endif
+
+// __USE_XOPEN isn't defined by default in ICC
+// (needed for ptsname(), grantpt() and unlockpt())
+#ifdef __INTEL_COMPILER
+#  ifndef __USE_XOPEN
+#    define __USE_XOPEN
+#  endif
+#endif
+
+#include <sys/types.h>
+#include <sys/ioctl.h>
+#include <sys/time.h>
+#include <sys/resource.h>
+#include <sys/stat.h>
+#include <sys/param.h>
+
+#include <errno.h>
+#include <fcntl.h>
+#include <time.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <grp.h>
+
+#ifdef Q_OS_MAC
+# include <util.h>
+#else
+# if defined(HAVE_PTY_H)
+#  include <pty.h>
+# endif
+# ifdef HAVE_LIBUTIL_H
+#  include <libutil.h>
+# elif defined(HAVE_UTIL_H)
+#  include <util.h>
+# endif
+#endif
+
+/*
+#ifdef HAVE_UTEMPTER
+extern "C" {
+# include <utempter.h>
+}
+#else
+# include <utmp.h>
+# ifdef HAVE_UTMPX
+#  include <utmpx.h>
+# endif
+# if !defined(_PATH_UTMPX) && defined(_UTMPX_FILE)
+#  define _PATH_UTMPX _UTMPX_FILE
+# endif
+# if !defined(_PATH_WTMPX) && defined(_WTMPX_FILE)
+#  define _PATH_WTMPX _WTMPX_FILE
+# endif
+#endif
+*/
+
+/* for HP-UX (some versions) the extern C is needed, and for other
+   platforms it doesn't hurt */
+extern "C" {
+#include <termios.h>
+#if defined(HAVE_TERMIO_H)
+# include <termio.h> // struct winsize on some systems
+#endif
+}
+
+#if defined (_HPUX_SOURCE)
+# define _TERMIOS_INCLUDED
+# include <bsdtty.h>
+#endif
+
+#ifdef HAVE_SYS_STROPTS_H
+# include <sys/stropts.h>	// Defines I_PUSH
+# define _NEW_TTY_CTRL
+#endif
+
+#if defined (__FreeBSD__) || defined (__NetBSD__) || defined (__OpenBSD__) || defined (__bsdi__) || defined(__APPLE__) || defined (__DragonFly__)
+# define _tcgetattr(fd, ttmode) ioctl(fd, TIOCGETA, (char *)ttmode)
+#else
+# if defined(_HPUX_SOURCE) || defined(__Lynx__) || defined (__CYGWIN__)
+#  define _tcgetattr(fd, ttmode) tcgetattr(fd, ttmode)
+# else
+#  define _tcgetattr(fd, ttmode) ioctl(fd, TCGETS, (char *)ttmode)
+# endif
+#endif
+
+#if defined (__FreeBSD__) || defined (__NetBSD__) || defined (__OpenBSD__) || defined (__bsdi__) || defined(__APPLE__) || defined (__DragonFly__)
+# define _tcsetattr(fd, ttmode) ioctl(fd, TIOCSETA, (char *)ttmode)
+#else
+# if defined(_HPUX_SOURCE) || defined(__CYGWIN__)
+#  define _tcsetattr(fd, ttmode) tcsetattr(fd, TCSANOW, ttmode)
+# else
+#  define _tcsetattr(fd, ttmode) ioctl(fd, TCSETS, (char *)ttmode)
+# endif
+#endif
+
+#include <QtCore>
+
+// not defined on HP-UX for example
+#ifndef CTRL
+# define CTRL(x) ((x) & 037)
+#endif
+
+#define TTY_GROUP "tty"
+
+///////////////////////
+// private functions //
+///////////////////////
+
+//////////////////
+// private data //
+//////////////////
+
+KPtyPrivate::KPtyPrivate(KPty* parent) :
+    masterFd(-1), slaveFd(-1), ownMaster(true), q_ptr(parent)
+{
+}
+
+KPtyPrivate::KPtyPrivate(KPty *parent, int _masterFd, int _slaveFd):
+    masterFd(_masterFd), slaveFd(_slaveFd), ownMaster(true), q_ptr(parent)
+{
+}
+
+
+KPtyPrivate::~KPtyPrivate()
+{
+}
+
+#ifndef HAVE_OPENPTY
+bool KPtyPrivate::chownpty(bool)
+{
+//    return !QProcess::execute(KStandardDirs::findExe("kgrantpty"),
+//        QStringList() << (grant?"--grant":"--revoke") << QString::number(masterFd));
+    return true;
+}
+#endif
+
+/////////////////////////////
+// public member functions //
+/////////////////////////////
+
+KPty::KPty() :
+    d_ptr(new KPtyPrivate(this))
+{
+}
+
+KPty::KPty(int masterFd, int slaveFd) :
+    d_ptr(new KPtyPrivate(this, masterFd, slaveFd))
+{
+}
+
+KPty::KPty(KPtyPrivate *d) :
+    d_ptr(d)
+{
+    d_ptr->q_ptr = this;
+}
+
+KPty::~KPty()
+{
+    close();
+    delete d_ptr;
+}
+
+bool KPty::open()
+{
+  Q_D(KPty);
+
+  if (d->masterFd >= 0) {
+      return true;
+  }
+
+  d->ownMaster = true;
+
+  QByteArray ptyName;
+
+  // Find a master pty that we can open ////////////////////////////////
+
+  // Because not all the pty animals are created equal, they want to
+  // be opened by several different methods.
+
+  // We try, as we know them, one by one.
+
+#ifdef HAVE_OPENPTY
+
+  char ptsn[PATH_MAX];
+  if (::openpty( &d->masterFd, &d->slaveFd, ptsn, 0, 0))
+  {
+    d->masterFd = -1;
+    d->slaveFd = -1;
+    qWarning() << "Can't open a pseudo teletype";
+    return false;
+  }
+  d->ttyName = ptsn;
+
+#else
+
+#ifdef HAVE__GETPTY // irix
+
+  char *ptsn = _getpty(&d->masterFd, O_RDWR|O_NOCTTY, S_IRUSR|S_IWUSR, 0);
+  if (ptsn) {
+    d->ttyName = ptsn;
+    goto grantedpt;
+  }
+
+#elif defined(HAVE_PTSNAME) || defined(TIOCGPTN)
+
+#ifdef HAVE_POSIX_OPENPT
+  d->masterFd = ::posix_openpt(O_RDWR|O_NOCTTY);
+#elif defined(HAVE_GETPT)
+  d->masterFd = ::getpt();
+#elif defined(PTM_DEVICE)
+  d->masterFd = ::open(PTM_DEVICE, O_RDWR|O_NOCTTY);
+#else
+# error No method to open a PTY master detected.
+#endif
+  if (d->masterFd >= 0)
+  {
+#ifdef HAVE_PTSNAME
+    char *ptsn = ptsname(d->masterFd);
+    if (ptsn) {
+        d->ttyName = ptsn;
+#else
+    int ptyno;
+    if (!ioctl(d->masterFd, TIOCGPTN, &ptyno)) {
+        char buf[32];
+        sprintf(buf, "/dev/pts/%d", ptyno);
+        d->ttyName = buf;
+#endif
+#ifdef HAVE_GRANTPT
+        if (!grantpt(d->masterFd))
+           goto grantedpt;
+#else
+        goto gotpty;
+#endif
+    }
+    ::close(d->masterFd);
+    d->masterFd = -1;
+  }
+#endif // HAVE_PTSNAME || TIOCGPTN
+
+  // Linux device names, FIXME: Trouble on other systems?
+  for (const char* s3 = "pqrstuvwxyzabcde"; *s3; s3++)
+  {
+    for (const char* s4 = "0123456789abcdef"; *s4; s4++)
+    {
+      ptyName = QString().sprintf("/dev/pty%c%c", *s3, *s4).toAscii();
+      d->ttyName = QString().sprintf("/dev/tty%c%c", *s3, *s4).toAscii();
+
+      d->masterFd = ::open(ptyName.data(), O_RDWR);
+      if (d->masterFd >= 0)
+      {
+#ifdef Q_OS_SOLARIS
+        /* Need to check the process group of the pty.
+         * If it exists, then the slave pty is in use,
+         * and we need to get another one.
+         */
+        int pgrp_rtn;
+        if (ioctl(d->masterFd, TIOCGPGRP, &pgrp_rtn) == 0 || errno != EIO) {
+          ::close(d->masterFd);
+          d->masterFd = -1;
+          continue;
+        }
+#endif /* Q_OS_SOLARIS */
+        if (!access(d->ttyName.data(),R_OK|W_OK)) // checks availability based on permission bits
+        {
+          if (!geteuid())
+          {
+            struct group* p = getgrnam(TTY_GROUP);
+            if (!p)
+              p = getgrnam("wheel");
+            gid_t gid = p ? p->gr_gid : getgid ();
+
+		 if (!chown(d->ttyName.data(), getuid(), gid)) {
+			chmod(d->ttyName.data(), S_IRUSR|S_IWUSR|S_IWGRP);
+		 }
+	  }
+	  goto gotpty;
+	}
+	::close(d->masterFd);
+	d->masterFd = -1;
+		}
+	 }
+  }
+
+  qWarning() << "Can't open a pseudo teletype";
+  return false;
+
+ gotpty:
+  struct stat st;
+  if (stat(d->ttyName.data(), &st))
+    return false; // this just cannot happen ... *cough*  Yeah right, I just
+                  // had it happen when pty #349 was allocated.  I guess
+                  // there was some sort of leak?  I only had a few open.
+  if (((st.st_uid != getuid()) ||
+       (st.st_mode & (S_IRGRP|S_IXGRP|S_IROTH|S_IWOTH|S_IXOTH))) &&
+      !d->chownpty(true))
+  {
+    qWarning()
+      << "chownpty failed for device " << ptyName << "::" << d->ttyName
+      << "\nThis means the communication can be eavesdropped." << endl;
+  }
+
+#if defined(HAVE_GRANTPT) || defined(HAVE__GETPTY)
+ grantedpt:
+#endif
+
+#ifdef HAVE_REVOKE
+  revoke(d->ttyName.data());
+#endif
+
+#ifdef HAVE_UNLOCKPT
+  unlockpt(d->masterFd);
+#elif defined(TIOCSPTLCK)
+  int flag = 0;
+  ioctl(d->masterFd, TIOCSPTLCK, &flag);
+#endif
+
+  d->slaveFd = ::open(d->ttyName.data(), O_RDWR | O_NOCTTY);
+  if (d->slaveFd < 0)
+  {
+    qWarning() << "Can't open slave pseudo teletype";
+    ::close(d->masterFd);
+    d->masterFd = -1;
+    return false;
+  }
+
+#if (defined(__svr4__) || defined(__sgi__))
+  // Solaris
+  ioctl(d->slaveFd, I_PUSH, "ptem");
+  ioctl(d->slaveFd, I_PUSH, "ldterm");
+#endif
+
+#endif /* HAVE_OPENPTY */
+  fcntl(d->masterFd, F_SETFD, FD_CLOEXEC);
+  fcntl(d->slaveFd, F_SETFD, FD_CLOEXEC);
+
+  struct ::termios t;
+  tcGetAttr(&t);
+  t.c_lflag &= ~ECHOCTL;
+  tcSetAttr(&t);
+  return true;
+}
+
+void KPty::closeSlave()
+{
+    Q_D(KPty);
+
+    if (d->slaveFd < 0)
+        return;
+    ::close(d->slaveFd);
+    d->slaveFd = -1;
+}
+
+void KPty::close()
+{
+   Q_D(KPty);
+
+   if (d->masterFd < 0)
+      return;
+   closeSlave();
+   if (d->ownMaster) {
+#ifndef HAVE_OPENPTY
+   // don't bother resetting unix98 pty, it will go away after closing master anyway.
+   if (memcmp(d->ttyName.data(), "/dev/pts/", 9)) {
+      if (!geteuid()) {
+         struct stat st;
+         if (!stat(d->ttyName.data(), &st)) {
+            if (!chown(d->ttyName.data(), 0, st.st_gid == getgid() ? 0 : -1)) {
+              chmod(d->ttyName.data(), S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH);
+            }
+         }
+      } else {
+         fcntl(d->masterFd, F_SETFD, 0);
+         d->chownpty(false);
+      }
+   }
+   #endif
+   }
+   ::close(d->masterFd);
+   d->masterFd = -1;
+}
+
+// XXX Supposedly, tc[gs]etattr do not work with the master on Solaris.
+// Please verify.
+
+bool KPty::tcGetAttr(struct ::termios *ttmode) const
+{
+    Q_D(const KPty);
+
+    return _tcgetattr(d->masterFd, ttmode) == 0;
+}
+
+bool KPty::tcSetAttr(struct ::termios *ttmode)
+{
+    Q_D(KPty);
+
+    return _tcsetattr(d->masterFd, ttmode) == 0;
+}
+
+bool KPty::setWinSize(int lines, int columns)
+{
+    Q_D(KPty);
+
+    struct winsize winSize;
+    memset(&winSize, 0, sizeof(winSize));
+    winSize.ws_row = (unsigned short)lines;
+    winSize.ws_col = (unsigned short)columns;
+    return ioctl(d->masterFd, TIOCSWINSZ, (char *)&winSize) == 0;
+}
+
+bool KPty::setEcho(bool echo)
+{
+    struct ::termios ttmode;
+    if (!tcGetAttr(&ttmode))
+        return false;
+    if (!echo)
+        ttmode.c_lflag &= ~ECHO;
+    else
+        ttmode.c_lflag |= ECHO;
+    return tcSetAttr(&ttmode);
+}
+
+const char *KPty::ttyName() const
+{
+    Q_D(const KPty);
+
+    return d->ttyName.data();
+}
+
+int KPty::masterFd() const
+{
+    Q_D(const KPty);
+
+    return d->masterFd;
+}
+
+int KPty::slaveFd() const
+{
+    Q_D(const KPty);
+
+    return d->slaveFd;
+}
diff --git a/libgui/qterminal/libqterminal/unix/kpty.h b/libgui/qterminal/libqterminal/unix/kpty.h
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/kpty.h
@@ -0,0 +1,166 @@
+/* This file is part of the KDE libraries
+
+    Copyright (C) 2003,2007 Oswald Buddenhagen <ossi@kde.org>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef kpty_h
+#define kpty_h
+
+#include <QtCore>
+
+struct KPtyPrivate;
+struct termios;
+
+/**
+ * Provides primitives for opening & closing a pseudo TTY pair, assigning the
+ * controlling TTY, utmp registration and setting various terminal attributes.
+ */
+class KPty {
+    Q_DECLARE_PRIVATE(KPty)
+
+public:
+
+  /**
+   * Constructor
+   */
+  KPty();
+  KPty(int masterFd, int slaveFd);
+
+  /**
+   * Destructor:
+   *
+   *  If the pty is still open, it will be closed. Note, however, that
+   *  an utmp registration is @em not undone.
+  */
+  ~KPty();
+
+  /**
+   * Create a pty master/slave pair.
+   *
+   * @return true if a pty pair was successfully opened
+   */
+  bool open();
+
+  /**
+   * Close the pty master/slave pair.
+   */
+  void close();
+
+  /**
+   * Close the pty slave descriptor.
+   *
+   * When creating the pty, KPty also opens the slave and keeps it open.
+   * Consequently the master will never receive an EOF notification.
+   * Usually this is the desired behavior, as a closed pty slave can be
+   * reopened any time - unlike a pipe or socket. However, in some cases
+   * pipe-alike behavior might be desired.
+   *
+   * After this function was called, slaveFd() and setCTty() cannot be
+   * used.
+   */
+  void closeSlave();
+
+  /**
+   * Wrapper around tcgetattr(3).
+   *
+   * This function can be used only while the PTY is open.
+   * You will need an #include &lt;termios.h&gt; to do anything useful
+   * with it.
+   *
+   * @param ttmode a pointer to a termios structure.
+   *  Note: when declaring ttmode, @c struct @c ::termios must be used -
+   *  without the '::' some version of HP-UX thinks, this declares
+   *  the struct in your class, in your method.
+   * @return @c true on success, false otherwise
+   */
+  bool tcGetAttr(struct ::termios *ttmode) const;
+
+  /**
+   * Wrapper around tcsetattr(3) with mode TCSANOW.
+   *
+   * This function can be used only while the PTY is open.
+   *
+   * @param ttmode a pointer to a termios structure.
+   * @return @c true on success, false otherwise. Note that success means
+   *  that @em at @em least @em one attribute could be set.
+   */
+  bool tcSetAttr(struct ::termios *ttmode);
+
+  /**
+   * Change the logical (screen) size of the pty.
+   * The default is 24 lines by 80 columns.
+   *
+   * This function can be used only while the PTY is open.
+   *
+   * @param lines the number of rows
+   * @param columns the number of columns
+   * @return @c true on success, false otherwise
+   */
+  bool setWinSize(int lines, int columns);
+
+  /**
+   * Set whether the pty should echo input.
+   *
+   * Echo is on by default.
+   * If the output of automatically fed (non-interactive) PTY clients
+   * needs to be parsed, disabling echo often makes it much simpler.
+   *
+   * This function can be used only while the PTY is open.
+   *
+   * @param echo true if input should be echoed.
+   * @return @c true on success, false otherwise
+   */
+  bool setEcho(bool echo);
+
+  /**
+   * @return the name of the slave pty device.
+   *
+   * This function should be called only while the pty is open.
+   */
+  const char *ttyName() const;
+
+  /**
+   * @return the file descriptor of the master pty
+   *
+   * This function should be called only while the pty is open.
+   */
+  int masterFd() const;
+
+  /**
+   * @return the file descriptor of the slave pty
+   *
+   * This function should be called only while the pty slave is open.
+   */
+  int slaveFd() const;
+
+protected:
+  /**
+   * @internal
+   */
+  KPty(KPtyPrivate *d);
+
+  /**
+   * @internal
+   */
+  KPtyPrivate * const d_ptr;
+};
+
+#endif
+
diff --git a/libgui/qterminal/libqterminal/unix/kpty_p.h b/libgui/qterminal/libqterminal/unix/kpty_p.h
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/unix/kpty_p.h
@@ -0,0 +1,50 @@
+/* This file is part of the KDE libraries
+
+    Copyright (C) 2003,2007 Oswald Buddenhagen <ossi@kde.org>
+
+    Rewritten for QT4 by e_k <e_k at users.sourceforge.net>, Copyright (C)2008
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+
+#ifndef kpty_p_h
+#define kpty_p_h
+
+#include "unix/kpty.h"
+
+#include <QtCore/QByteArray>
+
+struct KPtyPrivate {
+    Q_DECLARE_PUBLIC(KPty)
+
+    KPtyPrivate(KPty* parent);
+    KPtyPrivate(KPty* parent, int masterFd, int slaveFd);
+
+    virtual ~KPtyPrivate();
+#ifndef HAVE_OPENPTY
+    bool chownpty(bool grant);
+#endif
+
+    int masterFd;
+    int slaveFd;
+    bool ownMaster:1;
+
+    QByteArray ttyName;
+
+    KPty *q_ptr;
+};
+
+#endif
diff --git a/libgui/qterminal/libqterminal/win32/QTerminalColors.cpp b/libgui/qterminal/libqterminal/win32/QTerminalColors.cpp
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/win32/QTerminalColors.cpp
@@ -0,0 +1,48 @@
+/*
+
+Copyright (C) 2011 Michael Goffioul.
+
+This file is part of QConsole.
+
+Foobar is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+QConsole is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Foobar.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+
+#include "QTerminalColors.h"
+
+//////////////////////////////////////////////////////////////////////////////
+
+QConsoleColors::QConsoleColors (void)
+    : QMap<int, QColor> ()
+{
+  (*this)[0]  = Qt::black;
+  (*this)[1]  = Qt::darkBlue;
+  (*this)[2]  = Qt::darkGreen;
+  (*this)[3]  = Qt::darkCyan;
+  (*this)[4]  = Qt::darkRed;
+  (*this)[5]  = Qt::darkMagenta;
+  (*this)[6]  = Qt::darkYellow;
+  (*this)[7]  = Qt::lightGray;
+  (*this)[8]  = Qt::darkGray;
+  (*this)[9]  = Qt::blue;
+  (*this)[10] = Qt::green;
+  (*this)[11] = Qt::cyan;
+  (*this)[12] = Qt::red;
+  (*this)[13] = Qt::magenta;
+  (*this)[14] = Qt::yellow;
+  (*this)[15] = Qt::white;
+}
diff --git a/libgui/qterminal/libqterminal/win32/QTerminalColors.h b/libgui/qterminal/libqterminal/win32/QTerminalColors.h
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/win32/QTerminalColors.h
@@ -0,0 +1,38 @@
+/*
+
+Copyright (C) 2011 Michael Goffioul.
+
+This file is part of QConsole.
+
+Foobar is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+QConsole is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Foobar.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef __QConsoleColors_h__
+#define __QConsoleColors_h__ 1
+
+#include <QColor>
+#include <QMap>
+
+//////////////////////////////////////////////////////////////////////////////
+
+class QConsoleColors : public QMap<int, QColor>
+{
+public:
+  QConsoleColors (void);
+};
+
+//////////////////////////////////////////////////////////////////////////////
+
+#endif // __QConsoleColors_h__
diff --git a/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.cpp b/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.cpp
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.cpp
@@ -0,0 +1,914 @@
+/*
+
+Copyright (C) 2011 Michael Goffioul.
+
+This file is part of QConsole.
+
+Foobar is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+QConsole is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Foobar.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#include <QApplication>
+#include <QColor>
+#include <QFont>
+#include <QHBoxLayout>
+#include <QPaintEvent>
+#include <QPainter>
+#include <QResizeEvent>
+#include <QScrollBar>
+#include <QtDebug>
+#include <QThread>
+#include <QTimer>
+
+#include <fcntl.h>
+#include <io.h>
+#include <stdio.h>
+#include <stdarg.h>
+#define WIN32_LEAN_AND_MEAN
+#define _WIN32_WINNT 0x0500 
+#include <windows.h>
+#include <cstring>
+
+#include "QWinTerminalImpl.h"
+#include "QTerminalColors.h"
+
+// Uncomment to log activity to LOGFILENAME
+// #define DEBUG_QCONSOLE
+#define LOGFILENAME "QConsole.log"
+// Uncomment to create hidden console window
+#define HIDDEN_CONSOLE
+
+#ifdef _MSC_VER
+# pragma warning(disable : 4996)
+#endif
+
+//////////////////////////////////////////////////////////////////////////////
+
+class QConsoleView : public QWidget
+{
+public:
+  QConsoleView (QWinTerminalImpl* parent = 0) : QWidget (parent), q (parent) { }
+  ~QConsoleView (void) { }
+
+protected:
+  void paintEvent (QPaintEvent* event) { q->viewPaintEvent (this, event); }
+  void resizeEvent (QResizeEvent* event) { q->viewResizeEvent (this, event); }
+
+private:
+  QWinTerminalImpl* q;
+};
+
+//////////////////////////////////////////////////////////////////////////////
+
+class QConsoleThread : public QThread
+{
+public:
+  QConsoleThread (QWinTerminalImpl* console) : QThread (console), q (console) { }
+
+protected:
+  void run (void)
+    { q->start (); }
+
+private:
+  QWinTerminalImpl* q;
+};
+
+//////////////////////////////////////////////////////////////////////////////
+
+class QConsolePrivate
+{
+  friend class QWinTerminalImpl;
+
+public:
+  QConsolePrivate (QWinTerminalImpl* parent, const QString& cmd = QString ());
+  ~QConsolePrivate (void);
+
+  void updateConsoleSize (bool sync = false);
+  void syncConsoleParameters (void);
+  void grabConsoleBuffer (CHAR_INFO* buf = 0);
+  void updateScrollBar (void);
+  void setScrollValue (int value);
+  void updateConsoleView (bool grab = true);
+  void monitorConsole (void);
+  void startCommand (void);
+  void sendConsoleText (const QString& s);
+
+  void log (const char* fmt, ...);
+
+  void closeStandardIO (int fd, DWORD stdHandleId, const char* name);
+  void setupStandardIO (DWORD stdHandleId, int fd, const char* name,
+                        const char* devName);
+
+private:
+  QWinTerminalImpl* q;
+
+private:
+  QFont m_font;
+  QColor m_backgroundColor;
+  QString m_command;
+  QConsoleColors m_colors;
+  bool m_inWheelEvent;
+  QString m_title;
+
+  QSize m_charSize;
+  QSize m_bufferSize;
+  QRect m_consoleRect;
+  QPoint m_cursorPos;
+
+  HANDLE m_stdOut;
+  HWND m_consoleWindow;
+  CHAR_INFO* m_buffer;
+  CHAR_INFO* m_tmpBuffer;
+  HANDLE m_process;
+
+  QConsoleView* m_consoleView;
+  QScrollBar* m_scrollBar;
+  QTimer* m_consoleWatcher;
+  QConsoleThread *m_consoleThread;
+};
+
+//////////////////////////////////////////////////////////////////////////////
+
+QConsolePrivate::QConsolePrivate (QWinTerminalImpl* parent, const QString& cmd)
+    : q (parent), m_command (cmd), m_process (NULL), m_inWheelEvent (false)
+{
+  log (NULL);
+
+  // Possibly detach from any existing console
+  log ("Detaching from existing console (if any)...\n");
+  FreeConsole ();
+  log ("Closing standard IO...\n");
+  closeStandardIO (0, STD_INPUT_HANDLE, "STDIN");
+  closeStandardIO (1, STD_OUTPUT_HANDLE, "STDOUT");
+  closeStandardIO (2, STD_ERROR_HANDLE, "STDERR");
+
+#ifdef HIDDEN_CONSOLE
+  HWINSTA hOrigSta, hNewSta;
+
+  // Create new (hidden) console
+  hOrigSta = GetProcessWindowStation ();
+  hNewSta = CreateWindowStation (NULL, 0, GENERIC_ALL, NULL);
+  log ("Current Windows station: %p.\nNew Windows station: %p.\n", hOrigSta,
+       hNewSta);
+  if (! SetProcessWindowStation (hNewSta))
+    log ("Failed to switch to new Windows station.\n");
+#endif
+  if (! AllocConsole ())
+    log ("Failed to create new console.\n");
+#ifdef HIDDEN_CONSOLE
+  if (! SetProcessWindowStation (hOrigSta))
+    log ("Failed to restore original Windows station.\n");
+  if (! CloseWindowStation (hNewSta))
+    log ("Failed to close new Windows station.\n");
+#endif
+
+  log ("New (hidden) console created.\n");
+
+  setupStandardIO (STD_INPUT_HANDLE,  0, "STDIN",  "CONIN$");
+  setupStandardIO (STD_OUTPUT_HANDLE, 1, "STDOUT", "CONOUT$");
+  setupStandardIO (STD_ERROR_HANDLE,  2, "STDERR", "CONOUT$");
+
+  log ("Standard input/output/error set up.\n");
+
+  *stdin = *(fdopen (0, "rb"));
+  *stdout = *(fdopen (1, "wb"));
+  *stderr = *(fdopen (2, "wb"));
+
+  log ("POSIX standard streams created.\n");
+
+  setvbuf (stdin, NULL, _IONBF, 0);
+  setvbuf (stdout, NULL, _IONBF, 0);
+  setvbuf (stderr, NULL, _IONBF, 0);
+
+  log ("POSIX standard stream buffers adjusted.\n");
+
+  HANDLE hStdOut = GetStdHandle (STD_OUTPUT_HANDLE);
+
+  log ("Console allocated: hStdOut: %p\n", hStdOut);
+
+  m_stdOut = hStdOut;
+  m_consoleWindow = GetConsoleWindow ();
+
+  // In case the console window hasn't been created hidden...
+  ShowWindow (m_consoleWindow, SW_HIDE);
+
+  CONSOLE_SCREEN_BUFFER_INFO sbi;
+
+  GetConsoleScreenBufferInfo (hStdOut, &sbi);
+  m_bufferSize = QSize (sbi.dwSize.X, qMax (sbi.dwSize.Y, (SHORT)500));
+  m_consoleRect = QRect (sbi.srWindow.Left, sbi.srWindow.Top,
+                         sbi.srWindow.Right - sbi.srWindow.Left + 1,
+                         sbi.srWindow.Bottom - sbi.srWindow.Top + 1);
+  m_cursorPos = QPoint (sbi.dwCursorPosition.X, sbi.dwCursorPosition.Y);
+
+  log ("Initial console parameters:\n");
+  log ("  buffer size: %d x %d\n", m_bufferSize.width (),
+       m_bufferSize.height ());
+  log ("  window: (%d, %d) -> (%d, %d) [%d x %d]\n",
+       m_consoleRect.left (), m_consoleRect.top (),
+       m_consoleRect.right (), m_consoleRect.bottom (),
+       m_consoleRect.width (), m_consoleRect.height ());
+
+  wchar_t titleBuf[260];
+  GetConsoleTitleW (titleBuf, sizeof (titleBuf));
+  q->setWindowTitle (QString::fromWCharArray (titleBuf));
+
+  m_font.setFamily ("Lucida Console");
+  m_font.setPointSize (9);
+  m_font.setStyleHint (QFont::TypeWriter);
+  m_backgroundColor = Qt::black;
+
+  m_buffer = m_tmpBuffer = 0;
+
+  m_consoleView = new QConsoleView (parent);
+  m_scrollBar = new QScrollBar (Qt::Vertical, parent);
+
+  QHBoxLayout* l = new QHBoxLayout (parent);
+  l->setContentsMargins (0, 0, 0, 0);
+  l->setSpacing (0);
+  l->addWidget (m_consoleView, 1);
+  l->addWidget (m_scrollBar, 0);
+
+  m_consoleView->setPalette (QPalette (m_backgroundColor));
+  m_consoleView->setAutoFillBackground (true);
+  m_consoleView->setFont (m_font);
+  parent->setFocusPolicy (Qt::StrongFocus);
+  parent->winId ();
+
+  updateScrollBar ();
+
+  m_consoleWatcher = new QTimer (parent);
+  m_consoleWatcher->setInterval (10);
+  m_consoleWatcher->setSingleShot (false);
+  
+  QObject::connect (m_scrollBar, SIGNAL (valueChanged (int)),
+                    q, SLOT (scrollValueChanged (int)));
+  QObject::connect (m_consoleWatcher, SIGNAL (timeout (void)),
+                    q, SLOT (monitorConsole (void)));
+
+  m_consoleWatcher->start ();
+
+  if (m_command.isEmpty ())
+    m_consoleThread = 0;
+  else
+    {
+      m_consoleThread = new QConsoleThread (q);
+      QObject::connect (m_consoleThread, SIGNAL (finished (void)),
+                        q, SIGNAL (terminated (void)));
+      m_consoleThread->start ();
+    }
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+QConsolePrivate::~QConsolePrivate (void)
+{
+  if (m_consoleThread && m_consoleThread->isRunning () && m_process)
+    {
+      TerminateProcess (m_process, (UINT)-1);
+      m_consoleThread->wait ();
+    }
+  if (m_buffer)
+    delete [] m_buffer;
+  if (m_tmpBuffer)
+    delete [] m_tmpBuffer;
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+void QConsolePrivate::setupStandardIO (DWORD stdHandleId, int targetFd,
+                                       const char* name, const char* devName)
+{
+  log ("Opening %s...\n", devName);
+
+  int fd = open (devName, _O_RDWR | _O_BINARY);
+
+  if (fd != -1)
+    {
+      if (fd != targetFd)
+        {
+          log ("Opened %s is not at target file descriptor %d, "
+               "duplicating...\n", name, targetFd);
+          if (dup2 (fd, targetFd) == -1)
+            log ("Failed to duplicate file descriptor: errno=%d.\n", errno);
+          if (close (fd) == -1)
+            log ("Failed to close original file descriptor: errno=%d.\n",
+                 errno);
+        }
+      else
+        log ("%s opened and assigned to file descriptor %d.\n", devName, fd);
+      if (! SetStdHandle (stdHandleId, (HANDLE) _get_osfhandle (targetFd)))
+        log ("Failed to re-assign %s: error=%08x.\n", name, GetLastError ());
+    }
+  else
+    log ("Failed to open %s: errno=%d.\n", devName, errno);
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+void QConsolePrivate::closeStandardIO (int fd, DWORD stdHandleId,
+                                       const char* name)
+{
+  if (close (fd) == -1)
+    log ("Failed to close file descriptor %d: errno=%d.\n", fd, errno);
+  if (! CloseHandle (GetStdHandle (stdHandleId)))
+    log ("Failed to close Win32 %s: error=%08x.\n", name, GetLastError ());
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+void QConsolePrivate::log (const char* fmt, ...)
+{
+#ifdef DEBUG_QCONSOLE
+  if (fmt)
+    {
+      va_list l;
+      FILE* flog = fopen (LOGFILENAME, "ab");
+
+      va_start (l, fmt);
+      vfprintf (flog, fmt, l);
+      va_end (l);
+      fclose (flog);
+    }
+  else
+    {
+      // Special case to re-initialize the log file
+      FILE* flog = fopen (LOGFILENAME, "w");
+      fclose (flog);
+    }
+#else
+  Q_UNUSED (fmt);
+#endif
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+void QConsolePrivate::updateConsoleSize (bool sync)
+{
+  QFontMetrics fm (m_font);
+  QSize winSize = m_consoleView->size ();
+
+  m_charSize.rwidth () = fm.maxWidth ();
+  m_charSize.rheight () = fm.lineSpacing ();
+
+  m_consoleRect.setWidth (winSize.width () / fm.maxWidth ());
+  m_consoleRect.setHeight (winSize.height () / fm.lineSpacing ());
+
+  m_bufferSize.rwidth () = m_consoleRect.width ();
+  m_bufferSize.rheight () = qMax (m_bufferSize.height (),
+                                  m_consoleRect.height ());
+
+  m_consoleRect.moveLeft (0);
+  if (m_consoleRect.bottom () >= m_bufferSize.height ())
+    m_consoleRect.moveTop (m_bufferSize.height () - m_consoleRect.height ());
+
+  log ("Console resized:\n");
+  log ("  widget size: %d x %d\n", winSize.width (), winSize.height ());
+  log ("  buffer size: %d x %d\n", m_bufferSize.width (),
+       m_bufferSize.height ());
+  log ("  window: (%d, %d) -> (%d, %d) [%d x %d]\n",
+       m_consoleRect.left (), m_consoleRect.top (),
+       m_consoleRect.right (), m_consoleRect.bottom (),
+       m_consoleRect.width (), m_consoleRect.height ());
+
+  if (sync)
+    syncConsoleParameters ();
+
+  updateScrollBar ();
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+void QConsolePrivate::syncConsoleParameters (void)
+{
+  CONSOLE_SCREEN_BUFFER_INFO sbi;
+  HANDLE hStdOut = m_stdOut;
+
+  GetConsoleScreenBufferInfo (hStdOut, &sbi);
+
+  COORD bs;
+  SMALL_RECT sr;
+
+  bs.X = sbi.dwSize.X;
+  bs.Y = m_bufferSize.height ();
+  sr.Left   = sbi.srWindow.Left;
+  sr.Right  = sbi.srWindow.Right;
+  sr.Top    = m_consoleRect.top ();
+  sr.Bottom = m_consoleRect.bottom ();
+
+  if (bs.Y > sbi.dwSize.Y)
+    {
+      SetConsoleScreenBufferSize (hStdOut, bs);
+      SetConsoleWindowInfo (hStdOut, TRUE, &sr);
+    }
+  else
+    {
+      SetConsoleWindowInfo (hStdOut, TRUE, &sr);
+      SetConsoleScreenBufferSize (hStdOut, bs);
+    }
+
+  bs.X = m_bufferSize.width ();
+  sr.Left  = m_consoleRect.left ();
+  sr.Right = m_consoleRect.right ();
+
+  if (bs.X > sbi.dwSize.X)
+    {
+      SetConsoleScreenBufferSize (hStdOut, bs);
+      SetConsoleWindowInfo (hStdOut, TRUE, &sr);
+    }
+  else
+    {
+      SetConsoleWindowInfo (hStdOut, TRUE, &sr);
+      SetConsoleScreenBufferSize (hStdOut, bs);
+    }
+
+  log ("Sync'ing console parameters:\n");
+  log ("  buffer size: %d x %d\n", bs.X, bs.Y);
+  log ("  window: (%d, %d) -> (%d, %d)\n",
+       sr.Left, sr.Top, sr.Right, sr.Bottom);
+
+  if (m_buffer)
+    delete [] m_buffer;
+  if (m_tmpBuffer)
+    delete [] m_tmpBuffer;
+
+  int bufSize = m_consoleRect.width () * m_consoleRect.height ();
+
+  m_buffer = new CHAR_INFO[bufSize];
+  m_tmpBuffer = new CHAR_INFO[bufSize];
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+void QConsolePrivate::grabConsoleBuffer (CHAR_INFO* buf)
+{
+  COORD bs, bc;
+  SMALL_RECT r;
+
+  bs.X = m_consoleRect.width ();
+  bs.Y = m_consoleRect.height ();
+  bc.X = 0;
+  bc.Y = 0;
+
+  r.Left   = m_consoleRect.left ();
+  r.Top    = m_consoleRect.top ();
+  r.Right  = m_consoleRect.right ();
+  r.Bottom = m_consoleRect.bottom ();
+
+  if (! ReadConsoleOutput (m_stdOut, (buf ? buf : m_buffer), bs, bc, &r))
+    qCritical ("cannot read console output");
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+void QConsolePrivate::updateScrollBar (void)
+{
+  m_scrollBar->setMinimum (0);
+  if (m_bufferSize.height () > m_consoleRect.height ())
+    m_scrollBar->setMaximum (m_bufferSize.height () - m_consoleRect.height ());
+  else
+    m_scrollBar->setMaximum (0);
+  m_scrollBar->setSingleStep (1);
+  m_scrollBar->setPageStep (m_consoleRect.height ());
+  m_scrollBar->setValue (m_consoleRect.top ());
+
+  log ("Scrollbar parameters updated: %d/%d/%d/%d\n",
+       m_scrollBar->minimum (), m_scrollBar->maximum (),
+       m_scrollBar->singleStep (), m_scrollBar->pageStep ());
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+void QConsolePrivate::setScrollValue (int value)
+{
+  if (value == m_consoleRect.top ())
+    return;
+
+  SMALL_RECT r;
+  HANDLE hStdOut = m_stdOut;
+
+  if (value + m_consoleRect.height () > m_bufferSize.height ())
+    value = m_bufferSize.height () - m_consoleRect.height ();
+
+  r.Left = m_consoleRect.left ();
+  r.Top = value;
+  r.Right = m_consoleRect.right ();
+  r.Bottom = value + m_consoleRect.height () - 1;
+
+  log ("Scrolling window: (%d, %d) -> (%d, %d) [%d x %d]\n",
+       r.Left, r.Top, r.Right, r.Bottom, 
+       r.Right - r.Left + 1, r.Bottom - r.Top + 1);
+
+  if (SetConsoleWindowInfo (hStdOut, TRUE, &r))
+    {
+      m_consoleRect.moveTop (value);
+      updateConsoleView ();
+    }
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+void QConsolePrivate::updateConsoleView (bool grab)
+{
+  if (grab)
+    grabConsoleBuffer ();
+  m_consoleView->update ();
+  m_consoleWatcher->start ();
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+void QConsolePrivate::monitorConsole (void)
+{
+  CONSOLE_SCREEN_BUFFER_INFO sbi;
+  HANDLE hStdOut = GetStdHandle (STD_OUTPUT_HANDLE);
+
+  static wchar_t titleBuf[260];
+
+  GetConsoleTitleW (titleBuf, sizeof (titleBuf));
+  QString title = QString::fromWCharArray (titleBuf);
+
+  if (title != m_title)
+    {
+      q->setWindowTitle (title);
+      emit q->titleChanged (title);
+    }
+
+  if (GetConsoleScreenBufferInfo (hStdOut, &sbi))
+    {
+      if (m_bufferSize.width () != sbi.dwSize.X
+          || m_bufferSize.height () != sbi.dwSize.Y)
+        {
+          // Buffer size changed
+          m_bufferSize.rwidth () = sbi.dwSize.X;
+          m_bufferSize.rheight () = sbi.dwSize.Y;
+          updateScrollBar ();
+        }
+
+      if (m_cursorPos.x () != sbi.dwCursorPosition.X
+          || m_cursorPos.y () != sbi.dwCursorPosition.Y)
+        {
+          // Cursor position changed
+          m_consoleView->update
+            ((m_cursorPos.x () - sbi.srWindow.Left) * m_charSize.width (),
+             (m_cursorPos.y () - sbi.srWindow.Top) * m_charSize.height (),
+             m_charSize.width (), m_charSize.height ());
+          m_cursorPos.rx () = sbi.dwCursorPosition.X;
+          m_cursorPos.ry () = sbi.dwCursorPosition.Y;
+          m_consoleView->update
+            ((m_cursorPos.x () - sbi.srWindow.Left) * m_charSize.width (),
+             (m_cursorPos.y () - sbi.srWindow.Top) * m_charSize.height (),
+             m_charSize.width (), m_charSize.height ());
+        }
+
+      if (m_consoleRect.left () != sbi.srWindow.Left
+          || m_consoleRect.right () != sbi.srWindow.Right
+          || m_consoleRect.top () != sbi.srWindow.Top
+          || m_consoleRect.bottom () != sbi.srWindow.Bottom)
+        {
+          // Console window changed
+          m_consoleRect = QRect (sbi.srWindow.Left, sbi.srWindow.Top,
+                                 sbi.srWindow.Right - sbi.srWindow.Left + 1,
+                                 sbi.srWindow.Bottom - sbi.srWindow.Top + 1);
+          updateScrollBar ();
+          updateConsoleView ();
+          return;
+        }
+
+      if (m_tmpBuffer && m_buffer)
+        {
+          grabConsoleBuffer (m_tmpBuffer);
+          if (memcmp (m_tmpBuffer, m_buffer,
+                      sizeof (CHAR_INFO) * m_consoleRect.width () *
+                      m_consoleRect.height ()))
+            {
+              // FIXME: compute the area to update based on the
+              // difference between the 2 buffers.
+              qSwap (m_buffer, m_tmpBuffer);
+              updateConsoleView (false);
+            }
+        }
+    }
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+void QConsolePrivate::startCommand (void)
+{
+  QString cmd = m_command;
+
+  if (cmd.isEmpty ())
+    cmd = qgetenv ("COMSPEC").constData ();
+
+  if (! cmd.isEmpty ())
+    {
+      STARTUPINFO si;
+      PROCESS_INFORMATION pi;
+
+      ZeroMemory (&si, sizeof (si));
+      si.cb = sizeof (si);
+      ZeroMemory (&pi, sizeof (pi));
+
+      if (CreateProcessW (NULL,
+                          (LPWSTR)cmd.unicode (),
+                          NULL,
+                          NULL,
+                          TRUE,
+                          0,
+                          NULL,
+                          NULL,
+                          &si,
+                          &pi))
+        {
+          CloseHandle (pi.hThread);
+          m_process = pi.hProcess;
+          WaitForSingleObject (m_process, INFINITE);
+          CloseHandle (m_process);
+          m_process = NULL;
+        }
+    }
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+void QConsolePrivate::sendConsoleText (const QString& s)
+{
+  // Send the string in chunks of 512 characters. Each character is
+  // translated into an equivalent keypress event.
+
+#define TEXT_CHUNK_SIZE 512
+
+  int len = s.length ();
+  INPUT_RECORD events[TEXT_CHUNK_SIZE];
+  DWORD nEvents = 0, written;
+  HANDLE hStdIn = GetStdHandle (STD_INPUT_HANDLE);
+
+  ZeroMemory (events, sizeof (events));
+
+  for (int i = 0; i < len; i++)
+    {
+      QChar c = s.at (i);
+
+      if (c == L'\r' || c == L'\n')
+        {
+          if (c == L'\r' && i < (len - 1) && s.at (i+1) == L'\n')
+            i++;
+          if (nEvents)
+            {
+              WriteConsoleInput (hStdIn, events, nEvents, &written);
+              nEvents = 0;
+              ZeroMemory (events, sizeof (events));
+            }
+          PostMessage (m_consoleWindow, WM_KEYDOWN, VK_RETURN, 0x001C0001);
+          PostMessage (m_consoleWindow, WM_KEYDOWN, VK_RETURN, 0xC01C0001);
+        }
+      else
+        {
+          events[nEvents].EventType                        = KEY_EVENT;
+          events[nEvents].Event.KeyEvent.bKeyDown          = TRUE;
+          events[nEvents].Event.KeyEvent.wRepeatCount      = 1;
+          events[nEvents].Event.KeyEvent.wVirtualKeyCode   =
+            LOBYTE (VkKeyScan (c.unicode ()));
+          events[nEvents].Event.KeyEvent.wVirtualScanCode  = 0;
+          events[nEvents].Event.KeyEvent.uChar.UnicodeChar = c.unicode ();
+          events[nEvents].Event.KeyEvent.dwControlKeyState = 0;
+          nEvents++;
+        }
+
+      if (nEvents == TEXT_CHUNK_SIZE
+          || (nEvents > 0 && i == (len - 1)))
+        {
+          WriteConsoleInput (hStdIn, events, nEvents, &written);
+          nEvents = 0;
+          ZeroMemory (events, sizeof (events));
+        }
+    }
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+QWinTerminalImpl::QWinTerminalImpl (QWidget* parent)
+    : QTerminalInterface (parent), d (new QConsolePrivate (this))
+{
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+QWinTerminalImpl::QWinTerminalImpl (const QString& cmd, QWidget* parent)
+    : QTerminalInterface (parent), d (new QConsolePrivate (this, cmd))
+{
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+QWinTerminalImpl::~QWinTerminalImpl (void)
+{
+  delete d;
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+void QWinTerminalImpl::viewResizeEvent (QConsoleView*, QResizeEvent*)
+{
+  d->updateConsoleSize (true);
+  d->grabConsoleBuffer ();
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+void QWinTerminalImpl::viewPaintEvent (QConsoleView* w, QPaintEvent* event)
+{
+  QPainter p (w);
+  int cw = d->m_charSize.width (), ch = d->m_charSize.height ();
+  int ascent, stride, cx1, cy1, cx2, cy2, x, y;
+  WORD attr = 0;
+  QString s;
+  bool hasChar = false;
+
+  QRect updateRect = event->rect ();
+
+  cx1 = updateRect.left () / cw;
+  cy1 = updateRect.top () / ch;
+  cx2 = qMin (d->m_consoleRect.width () - 1, updateRect.right () / cw);
+  cy2 = qMin (d->m_consoleRect.height () - 1, updateRect.bottom () / ch);
+
+  if (cx1 > d->m_consoleRect.width () - 1
+      || cy1 > d->m_consoleRect.height () - 1)
+    return;
+
+  p.setFont (d->m_font);
+  p.setPen (Qt::black);
+
+  ascent = p.fontMetrics ().ascent ();
+  stride = d->m_consoleRect.width ();
+
+  s.reserve (cx2 - cx1 + 1);
+  y = ascent + cy1 * ch;;
+
+  for (int j = cy1; j <= cy2; j++, y += ch)
+    {
+      // Reset string buffer and starting X coordinate
+      s.clear ();
+      hasChar = false;
+      x = cx1 * cw;
+
+      for (int i = cx1; i <= cx2; i++)
+        {
+          CHAR_INFO* ci = &(d->m_buffer[stride*j+i]);
+
+          if ((ci->Attributes & 0x00ff) != attr)
+            {
+              // Character attributes changed
+              if (! s.isEmpty ())
+                {
+                  // String buffer not empty -> draw it
+                  if (hasChar || (attr & 0x00f0))
+                    {
+                      if (attr & 0x00f0)
+                        p.fillRect (x, y-ascent, s.length () * cw, ch,
+                                    p.brush ());
+                      p.drawText (x, y, s);
+                    }
+                  x += (s.length () * cw);
+                  s.clear ();
+                  hasChar = false;
+                }
+              // Update current pen and store current attributes
+              // FIXME: what about background?
+              attr = (ci->Attributes & 0x00ff);
+              p.setPen (d->m_colors[attr & 0x000f]);
+              p.setBrush (d->m_colors[(attr >> 4) & 0x000f]);
+            }
+
+          // Append current character to the string buffer
+          s.append (ci->Char.UnicodeChar);
+          if (ci->Char.UnicodeChar != L' ')
+            hasChar = true;
+        }
+
+      if (! s.isEmpty () && (hasChar || (attr & 0x00f0)))
+        {
+          // Line end reached, but string buffer not empty -> draw it
+          // No need to update s or x, they will be reset on the next
+          // for-loop iteration
+          if (attr & 0x00f0)
+            p.fillRect (x, y-ascent, s.length () * cw, ch, p.brush ());
+          p.drawText (x, y, s);
+        }
+    }
+
+  // Draw cursor
+  p.setCompositionMode (QPainter::RasterOp_SourceXorDestination);
+  p.fillRect ((d->m_cursorPos.x () - d->m_consoleRect.x ()) * cw,
+              (d->m_cursorPos.y () - d->m_consoleRect.y ()) * ch,
+              cw, ch, d->m_colors[7]);
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+void QWinTerminalImpl::wheelEvent (QWheelEvent* event)
+{
+  if (! d->m_inWheelEvent)
+    {
+      // Forward to the scrollbar (avoid recursion)
+      d->m_inWheelEvent = true;
+      QApplication::sendEvent (d->m_scrollBar, event);
+      d->m_inWheelEvent = false;
+    }
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+bool QWinTerminalImpl::winEvent (MSG* msg, long* result)
+{
+  switch (msg->message)
+    {
+    case WM_KEYDOWN:
+    case WM_KEYUP:
+    //case WM_CHAR:
+      // Forward Win32 message to the console window
+      PostMessage (d->m_consoleWindow,
+                   msg->message,
+                   msg->wParam,
+                   msg->lParam);
+      result = 0;
+      return true;
+    default:
+      return false;
+    }
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+void QWinTerminalImpl::scrollValueChanged (int value)
+{
+  d->setScrollValue (value);
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+void QWinTerminalImpl::monitorConsole (void)
+{
+  d->monitorConsole ();
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+void QWinTerminalImpl::focusInEvent (QFocusEvent* event)
+{
+  QWidget::focusInEvent (event);
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+void QWinTerminalImpl::start (void)
+{
+  d->startCommand ();
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+void QWinTerminalImpl::sendText (const QString& s)
+{
+  d->sendConsoleText (s);
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+void QWinTerminalImpl::setTerminalFont (const QFont& f)
+{
+  d->m_font = f;
+  d->m_consoleView->setFont (f);
+  d->updateConsoleSize (true);
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+void QWinTerminalImpl::setSize (int columns, int lines)
+{
+  Q_UNUSED (columns);
+  Q_UNUSED (lines);
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+void QWinTerminalImpl::copyClipboard (void)
+{
+}
+
+//////////////////////////////////////////////////////////////////////////////
+
+void QWinTerminalImpl::pasteClipboard (void)
+{
+}
diff --git a/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.h b/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.h
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/libqterminal/win32/QWinTerminalImpl.h
@@ -0,0 +1,81 @@
+/*
+
+Copyright (C) 2011 Michael Goffioul.
+
+This file is part of QConsole.
+
+Foobar is free software: you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation, either version 3 of the License, or
+(at your option) any later version.
+
+QConsole is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Foobar.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+
+#ifndef __QConsole_h__
+#define __QConsole_h__ 1
+
+#include <QWidget>
+#include "QTerminalInterface.h"
+class QFocusEvent;
+class QKeyEvent;
+class QPaintEvent;
+class QResizeEvent;
+class QWheelEvent;
+
+class QConsolePrivate;
+class QConsoleThread;
+class QConsoleView;
+
+//////////////////////////////////////////////////////////////////////////////
+
+class QWinTerminalImpl : public QTerminalInterface
+{
+  Q_OBJECT
+  friend class QConsolePrivate;
+  friend class QConsoleThread;
+  friend class QConsoleView;
+
+public:
+  QWinTerminalImpl (QWidget* parent = 0);
+  QWinTerminalImpl (const QString& cmd, QWidget* parent = 0);
+  ~QWinTerminalImpl (void);
+
+  void setTerminalFont (const QFont& font);
+  void setSize (int columns, int lines);
+  void sendText (const QString& s);
+
+public slots:
+  void copyClipboard (void);
+  void pasteClipboard (void);
+
+signals:
+  void terminated (void);
+  void titleChanged (const QString&);
+
+protected:
+  void viewPaintEvent (QConsoleView*, QPaintEvent*);
+  void viewResizeEvent (QConsoleView*, QResizeEvent*);
+  void wheelEvent (QWheelEvent*);
+  void focusInEvent (QFocusEvent*);
+  bool winEvent (MSG*, long*);
+  virtual void start (void);
+
+private slots:
+  void scrollValueChanged (int value);
+  void monitorConsole (void);
+
+private:
+  QConsolePrivate* d;
+};
+
+//////////////////////////////////////////////////////////////////////////////
+
+#endif // __QConsole_h__
diff --git a/libgui/qterminal/msvc.pri b/libgui/qterminal/msvc.pri
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/msvc.pri
@@ -0,0 +1,11 @@
+CONFIG += release
+
+QMAKE_CXXFLAGS += -MP
+LIBDIR_SUFFIX = release
+
+msvc-debug {
+	QMAKE_CXXFLAGS_RELEASE += -Zi
+	QMAKE_CXXFLAGS_RELEASE -= -O2
+	QMAKE_LFLAGS_RELEASE += -debug
+	QMAKE_CLEAN += $(DESTDIR)$(QMAKE_TARGET).pdb
+}
diff --git a/libgui/qterminal/qterminal.pro b/libgui/qterminal/qterminal.pro
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/qterminal.pro
@@ -0,0 +1,2 @@
+TEMPLATE 	= subdirs
+SUBDIRS 	= libqterminal qterminal
diff --git a/libgui/qterminal/qterminal/README b/libgui/qterminal/qterminal/README
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/qterminal/README
@@ -0,0 +1,1 @@
+here is sample program which uses QTermWidet for displaying a terminal
\ No newline at end of file
diff --git a/libgui/qterminal/qterminal/main.cpp b/libgui/qterminal/qterminal/main.cpp
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/qterminal/main.cpp
@@ -0,0 +1,40 @@
+/*  Copyright (C) 2008 e_k (e_k@users.sourceforge.net)
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+		
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+				
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+*/
+						
+
+#include <QtCore>
+#include <QtGui>
+#include <QApplication>
+
+#include "QTerminal.h"
+
+int main(int argc, char *argv[])
+{
+    QApplication app(argc, argv);
+    QMainWindow *mainWindow = new QMainWindow();
+
+    QTerminal *terminal = new QTerminal();
+
+    mainWindow->setCentralWidget(terminal);
+    mainWindow->resize(600, 400);
+
+    mainWindow->show();    
+    return app.exec();
+} 
+
+  
diff --git a/libgui/qterminal/qterminal/qterminal.pro b/libgui/qterminal/qterminal/qterminal.pro
new file mode 100644
--- /dev/null
+++ b/libgui/qterminal/qterminal/qterminal.pro
@@ -0,0 +1,15 @@
+TEMPLATE	= app
+
+QT += core gui
+
+SOURCES 	= main.cpp
+INCLUDEPATH 	= ../libqterminal
+
+win32 {
+  win32-msvc*: include(../msvc.pri)
+  LIBS += -L../libqterminal/$$LIBDIR_SUFFIX \
+    -lqterminal -luser32 -lkernel32
+} else {
+  DEFINES += HAVE_PTY_H HAVE_OPENPTY
+  LIBS += -L../libqterminal -lqterminal -lutil
+}
diff --git a/libgui/src/history-dockwidget.cc b/libgui/src/history-dockwidget.cc
--- a/libgui/src/history-dockwidget.cc
+++ b/libgui/src/history-dockwidget.cc
@@ -195,17 +195,17 @@ history_dock_widget::update_history_call
 
       _history_model->insertRows (clientHistoryLength, elts_to_add);
 
       for (int i = clientHistoryLength; i < serverHistoryLength; i++)
         {
           std::string entry = command_history::get_entry (i);
 
           _history_model->setData (_history_model->index (i),
-                                   QString::fromStdString (entry));
+                      QString::fromLocal8Bit (entry.data (), entry.size ()));
         }
 
       // FIXME -- does this behavior make sense?  Calling
       // _history_list_view->scrollToBottom () here doesn't seem to
       // have any effect.  Instead, we need to request that action
       // and wait until the next event occurs in which no items
       // are added to the history list.
 
diff --git a/libgui/src/icons/graphic_logo_DocumentationDockWidget.png b/libgui/src/icons/graphic_logo_DocumentationDockWidget.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..ed9193dba51719dc53f2a6aa4bfaefac18feffa7
GIT binary patch
literal 1863
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
BX#fBK

diff --git a/libgui/src/icons/graphic_logo_FileEditor.png b/libgui/src/icons/graphic_logo_FileEditor.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..9d59099eb77f5478afa24210106eac548157d81c
GIT binary patch
literal 1566
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
QLjV8(07*qoM6N<$f{uIAi~s-t

diff --git a/libgui/src/icons/graphic_logo_FilesDockWidget.png b/libgui/src/icons/graphic_logo_FilesDockWidget.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..72617b8089ce019b0a220f0dba8120ffade169b4
GIT binary patch
literal 1595
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

diff --git a/libgui/src/icons/graphic_logo_HistoryDockWidget.png b/libgui/src/icons/graphic_logo_HistoryDockWidget.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..f832ffa441fb221f92acd3e42aaeea41024a5764
GIT binary patch
literal 1540
zc$@(Q2K)JmP)<h;3K|Lk000e1NJLTq001BW001Be1^@s6b9#F800001b5ch_0Itp)
z=>Px#24YJ`L;(K){{a7>y{D4^000SaNLh0L01FcU01FcV0GgZ_00007bV*G`2iyx7
z2ml;WM>S#q00o3eL_t(o!@ZYpXq{&n#(&rSyk{qElG=YJ-4cY+(bZaK%Ldv}Fb%j=
z+_bb~Xr&t>0jpzZE%l3=>%b2uv~wz~)hIF*MKmaz!=5oxJJf9*>!wLZ=N~q=+9h;J
zvnEYWa?W{fKb#~zNl#9aQoX;tFTBt5-q(9w_kBI@E#`@qr%$JnU`@fa$HYg2X|qYS
z!F0)_Au~O1(zC(zoEd#T|JaR@MTDw7-1=1Shl2EtVA>N*m<bb@i69Y7*yMHc{ul2a
z{L=2Z-j~g0ugI5FTDbYQJs~Z>%iW)du#5<fd%)x-hz`a8kpYZ?T;aV(_TCKaZf|d|
z_Dwz;NJRh^V|x^j0cp3=CL9qXV1Jd7Rpgau{9R6N^xI!PJ(YOZu3acCeB7%7nF4VI
zfRFs@)VApUAdvPr30cTd9`hq|Kl1Dy8_tyPX=`hnPCl(|1rSruJ3BioOR(XWry3*d
zBgPw$fw>bAVjTFE0*{^e<c9HC$-TY3eMWL0ca)yHye8T5Y&NSI0HXWtUZmAb1dHy`
zaPtT}`Qm48$z(DazcZ7W@v`pj?zt;`ekm?9aMKefmlR`cF=;8Wq`8{|8cu?LVQSrh
z0|yoaU_KVE08oHti@w#ZtYTvnvY(yYx%m=T8RZ}<u`vyxc6?}ME>-sdMd1=|$W5dt
zMmuM3>gecLQ1bcc2S|GEW_enCyr<`())Ngat0gc%5=iWQ?eLcIyQz=P3xB8}L$w-M
zNF-)@aM`L=`#xcBa##ORFLOu-7+JaU$mrPE@cHvY_whf7B$Y~irE$#~aQ9i(EPxe2
z?f7{8g$qNUuOvZhYwL7hm$%|v(bd&OXJ;o32Y>LLdk+$lBuUbMdyJCiuG%CCOXll@
zuCA`CAiBD`%3FS?q=%=9uxj#hAFmY0jvZtB_U-e2{S;H#Y*wFp$WIC1kz9>#mAas{
zwe<>{tpv2Aql0WVOELPNg6W>C0x(;Gg+7}>r~3=V$Y+x>dd2@SqVu-!_a&v`pU2H4
z%GWK_h^nzubT1fqQYaM87A7W|lT@mV48P2ZJ25v>2ov#*#nN0Y3PrC;OiJ?k{MX*;
z>w7qrB-aC;vs6t^HMOW@Mg>g0VQuc2_4o9yzoruSx}u|G<FEP6%b&j31JoxG&jswO
zn+_crOX_ZwTqtm{W>sx}ZPSkZ@BR6jNf6z)C=wEYTc70h87sHlemGG0p-FWnJQzw9
z^KE}gH(whG+?S4ZzqK_@!9wMR{c*3g?b#w{op4m@5cP#RmM=+hTVws=@)h!oy!s4-
z*`wrNdyd_|KfJN|{OQdh7Lqwz&ki3?gZG+rQ!x4Dued@GcjVq+Q@)P`Ul4%$(RcXN
zTR-Cc4GrKR9K-4F>+`C;uS3Ug27f*TTM>ktPzXjavG<l6cwkc#*Vm@!GaN=wJ<Zrp
zzR2o^21<X{fW(EtL9FWL{o7u5`R*9~T+v<8OCv#a=jh+gvE!*;e)q3;`S-;fbNPuR
zikdv#XRUGfg}I*{>TZ$g@gRM$Bn72OC>TMaDUPr<Kgg;$N}W%T@*)OISi)#Xvu5}o
z>^u87%Nm<5gOC^;7+^tXLEPW^$MER!`)-UwC*Ra^qDm$qcN{nu>gZ3^vm`N^>(bO+
z7f1zTBp*4So8ZIbSehS(5N1daV_cm7e>3x_FKyXL$4hTB5uFeq$S7x}G(+0-eUNAz
z@8gk|zRvpmSqhdaC3R<XZ0yXU0Aw;5F9Q9l<;7$TJ=ZmmXliJk1Tk5pVQPpqBayQr
zKg4Yp&aiIeKWy*Ktj)`m&&NxPJ&r9v-FFY%KV0*@6CpT_F79{dP8S;^NbYEIp2I=z
qV@2tw1L@U=zQ6B*f0hXgz<&WY?PDaf4M~3h0000<MNUMnLSTY_3hCDX

diff --git a/libgui/src/icons/graphic_logo_TerminalDockWidget.png b/libgui/src/icons/graphic_logo_TerminalDockWidget.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..707c0e1628a341001782eb34f90cec7c894f01f7
GIT binary patch
literal 1597
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

diff --git a/libgui/src/icons/graphic_logo_WorkspaceView.png b/libgui/src/icons/graphic_logo_WorkspaceView.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..1f727bf0f74bc0c8e5d1d1d23f49f5ffeffd4fa1
GIT binary patch
literal 2024
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
GLSTYVhtDnm

diff --git a/libgui/src/icons/letter_logo_DocumentationDockWidget.png b/libgui/src/icons/letter_logo_DocumentationDockWidget.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..fc69dce64993a4906bc5c99a55e379e3dda36ec2
GIT binary patch
literal 1811
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
Bag_i7

diff --git a/libgui/src/icons/letter_logo_FileEditor.png b/libgui/src/icons/letter_logo_FileEditor.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..f1346267374d7556080c8e9fb4868596fe0d3192
GIT binary patch
literal 1879
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
R|5X40002ovPDHLkV1nmcn_K_@

diff --git a/libgui/src/icons/letter_logo_FilesDockWidget.png b/libgui/src/icons/letter_logo_FilesDockWidget.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..539aed7163882bf4dc990b6cfe261e34401175d3
GIT binary patch
literal 1669
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
P00000NkvXXu0mjfrx+52

diff --git a/libgui/src/icons/letter_logo_HistoryDockWidget.png b/libgui/src/icons/letter_logo_HistoryDockWidget.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..df8099f4da979116b503edca617c2decabd99d6f
GIT binary patch
literal 1729
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
X@0){LQk?!k00000NkvXXu0mjfHLNDj

diff --git a/libgui/src/icons/letter_logo_TerminalDockWidget.png b/libgui/src/icons/letter_logo_TerminalDockWidget.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..1f23c74cf28e36acad285ff232eb4eaa3d3c6b62
GIT binary patch
literal 1816
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
GLSTYIOIl$7

diff --git a/libgui/src/icons/letter_logo_WorkspaceView.png b/libgui/src/icons/letter_logo_WorkspaceView.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..f7567a7b98c76cc8e0ef78cbc6eb9f2b0949c4c2
GIT binary patch
literal 1926
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
M07*qoM6N<$g0E1d_y7O^

diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -56,16 +56,46 @@ main_window::main_window (QWidget *p)
 {
   // We have to set up all our windows, before we finally launch octave.
   construct ();
   octave_link::launch_octave ();
 }
 
 main_window::~main_window ()
 {
+  // Clean up all dynamically created objects to ensure they are
+  // deleted before this main_window is.  Otherwise, some will be
+  // attached to a non-existent parent.
+
+  if (_octave_qt_event_listener)
+    delete _octave_qt_event_listener;
+
+  if (_file_editor)
+    delete _file_editor;
+
+  if (_terminal_dock_widget)
+    delete _terminal_dock_widget;
+
+  if (_terminal)
+    delete _terminal;
+
+  if (_status_bar)
+    delete _status_bar;
+
+  if (_documentation_dock_widget)
+    delete _documentation_dock_widget;
+
+  if (_files_dock_widget)
+    delete _files_dock_widget;
+
+  if (_history_dock_widget)
+    delete _history_dock_widget;
+
+  if (_workspace_view)
+    delete _workspace_view;
 }
 
 void
 main_window::new_file ()
 {
   _file_editor->request_new_file ();
   focus_editor ();
 }
@@ -180,16 +210,33 @@ main_window::notice_settings ()
   if (cursorType == "ibeam")
     _terminal->setCursorType(QTerminalInterface::IBeamCursor, cursorBlinking);
   else if (cursorType == "block")
     _terminal->setCursorType(QTerminalInterface::BlockCursor, cursorBlinking);
   else if (cursorType == "underline")
     _terminal->setCursorType(QTerminalInterface::UnderlineCursor,
                              cursorBlinking);
 
+  // the widget's icons (when floating)
+  int icon_set = settings->value ("DockWidgets/widget_icon_set",0).toInt ();
+  QString icon_prefix = QString (WIDGET_ICON_SET_PREFIX[icon_set]);
+  QString icon;
+  foreach (QObject *obj, children ())
+    {
+      QString name = obj->objectName ();
+      if (obj->inherits("QDockWidget") && ! name.isEmpty ())
+        { // if children is a dockwidget with a name
+          QDockWidget *widget = qobject_cast<QDockWidget *> (obj);
+          icon = icon_prefix;  // prefix or octave-logo
+          if (icon_set)        // > 0 : each widget has individual icon
+            icon = icon + name + QString(".png");
+          widget->setWindowIcon (QIcon (icon));
+        }
+    }
+
   resource_manager::update_network_settings ();
 }
 
 void
 main_window::prepare_for_quit ()
 {
   write_settings ();
 }
@@ -211,37 +258,56 @@ main_window::current_working_directory_h
   _current_directory_combo_box->insertItem (0,directory);  // add (on top)
   _current_directory_combo_box->setCurrentIndex (0);  // top is actual
   _files_dock_widget->set_current_directory (directory);
 }
 
 void
 main_window::change_current_working_directory ()
 {
-  QString selectedDirectory =
+  QString directory =
     QFileDialog::getExistingDirectory(this, tr ("Set working direcotry"));
 
-  if (!selectedDirectory.isEmpty ())
-    octave_link::post_event (this, &main_window::change_directory_callback,
-                             selectedDirectory.toStdString ());
+  if (!directory.isEmpty ())
+    {
+      std::string dir = directory.toLocal8Bit ().data ();
+      octave_link::post_event (this, &main_window::change_directory_callback,dir);
+    }
 }
 
 void
 main_window::set_current_working_directory (const QString& directory)
 {
-  octave_link::post_event (this, &main_window::change_directory_callback,
-                           directory.toStdString ());
+  QFileInfo fileInfo (directory);  // check whether this is an existing dir
+  if (fileInfo.exists () && fileInfo.isDir ())   // is dir and exists
+    {
+      std::string dir = directory.toLocal8Bit ().data ();
+      octave_link::post_event (this, &main_window::change_directory_callback,dir);
+    }
 }
 
 void
 main_window::current_working_directory_up ()
 {
   set_current_working_directory ("..");
 }
 
+// Slot that is called if return is pressed in the line edit of the combobox
+// -> a new or a directory that is already in the drop down list was entered
+void
+main_window::current_working_directory_entered ()
+{
+  QString dir = _current_directory_line_edit->text ();  // get new directory
+  int index = _current_directory_combo_box->findText (dir);  // already in list?
+  if ( index < 0 )  // directory not yet in list -> set directory
+    set_current_working_directory (dir);
+  // if directory already in list, combobox triggers signal activated ()
+  // to change directory
+}
+
 void
 main_window::focus_command_window ()
 {
   if (!_terminal_dock_widget->isVisible ())
     {
       _terminal_dock_widget->setVisible (true);
     }
 
@@ -473,36 +539,41 @@ main_window::construct ()
   _history_dock_widget      = new history_dock_widget (this);
   _history_dock_widget->setStatusTip (tr ("Browse and search the command history."));
   _files_dock_widget        = new files_dock_widget (this);
   _files_dock_widget->setStatusTip (tr ("Browse your files."));
   _documentation_dock_widget= new documentation_dock_widget (this);
   _documentation_dock_widget->setStatusTip (tr ("See the documentation for help."));
   _status_bar               = new QStatusBar (this);
 
+  _current_directory_line_edit = new QLineEdit (this);
   _current_directory_combo_box = new QComboBox (this);
-  _current_directory_combo_box->setFixedWidth (300);
+  _current_directory_combo_box->setFixedWidth (current_directory_width);
   _current_directory_combo_box->setEditable (true);
+  // setLineEdit takes ownership -> no need to delete line_edit in ~main_window
+  _current_directory_combo_box->setLineEdit (_current_directory_line_edit);
   _current_directory_combo_box->setInsertPolicy (QComboBox::InsertAtTop);
-  _current_directory_combo_box->setMaxVisibleItems (16);
-  _current_directory_combo_box->setMaxCount (16);
+  _current_directory_combo_box->setMaxVisibleItems (current_directory_max_visible);
+  _current_directory_combo_box->setMaxCount (current_directory_max_count);
 
-  _current_directory_tool_button = new QToolButton (this);
-  _current_directory_tool_button->setIcon (QIcon(":/actions/icons/search.png"));
+  QToolButton *current_directory_tool_button = new QToolButton (this);
+  current_directory_tool_button->setIcon (QIcon(":/actions/icons/search.png"));
 
-  _current_directory_up_tool_button = new QToolButton (this);
-  _current_directory_up_tool_button->setIcon (QIcon(":/actions/icons/up.png"));
+  QToolButton *current_directory_up_tool_button = new QToolButton (this);
+  current_directory_up_tool_button->setIcon (QIcon(":/actions/icons/up.png"));
 
   // Octave Terminal subwindow.
   _terminal = new QTerminal (this);
   _terminal->setObjectName ("OctaveTerminal");
   _terminal->setFocusPolicy (Qt::StrongFocus);
   _terminal_dock_widget = new terminal_dock_widget (_terminal, this);
-  _terminal_dock_widget->setWindowIcon (QIcon(":/actions/icons/terminal.png"));
 
+  // Create and set the central widget.  QMainWindow takes ownership of
+  // the widget (pointer) so there is no need to delete the object upon
+  // destroying this main_window.
   QWidget *dummyWidget = new QWidget ();
   dummyWidget->setObjectName ("CentralDummyWidget");
   dummyWidget->resize (10, 10);
   dummyWidget->setSizePolicy (QSizePolicy::Minimum, QSizePolicy::Minimum);
   dummyWidget->hide ();
   setCentralWidget (dummyWidget);
 
   _file_editor = new file_editor (_terminal, this);
@@ -739,29 +810,32 @@ main_window::construct ()
     = help_menu->addAction (tr ("Visit Octave Forge"));
   help_menu->addSeparator ();
 
   QAction * about_octave_action
     = help_menu->addAction (tr ("About Octave"));
 
   // Toolbars
   QToolBar *main_tool_bar = addToolBar ("Main");
+  main_tool_bar->setObjectName ("MainToolBar");
   main_tool_bar->addAction (new_script_action);
   main_tool_bar->addAction (open_action);
   main_tool_bar->addSeparator ();
   main_tool_bar->addAction (cut_action);
   main_tool_bar->addAction (copy_action);
   main_tool_bar->addAction (paste_action);
   main_tool_bar->addAction (undo_action);
   main_tool_bar->addAction (redo_action);
   main_tool_bar->addSeparator ();
+  // addWidget takes ownership of the objects so there is no
+  // need to delete these upon destroying this main_window.
   main_tool_bar->addWidget (new QLabel (tr ("Current Directory:")));
   main_tool_bar->addWidget (_current_directory_combo_box);
-  main_tool_bar->addWidget (_current_directory_tool_button);
-  main_tool_bar->addWidget (_current_directory_up_tool_button);
+  main_tool_bar->addWidget (current_directory_tool_button);
+  main_tool_bar->addWidget (current_directory_up_tool_button);
 
   connect (qApp,                        SIGNAL (aboutToQuit ()),
            this,                        SLOT   (prepare_for_quit ()));
   connect (preferences_action,          SIGNAL (triggered ()),
            this,                        SLOT   (process_settings_dialog_request ()));
   connect (exit_action,                 SIGNAL (triggered ()),
            this,                        SLOT   (close ()));
   connect (new_script_action,           SIGNAL (triggered ()),
@@ -831,26 +905,28 @@ main_window::construct ()
   connect (_history_dock_widget,        SIGNAL (command_double_clicked (QString)),
            this,                        SLOT   (handle_command_double_clicked (QString)));
   connect (save_workspace_action,       SIGNAL (triggered ()),
            this,                        SLOT   (handle_save_workspace_request ()));
   connect (load_workspace_action,       SIGNAL (triggered ()),
            this,                        SLOT   (handle_load_workspace_request ()));
   connect (clear_workspace_action,      SIGNAL (triggered ()),
            this,                        SLOT   (handle_clear_workspace_request ()));
-  connect (_current_directory_tool_button, SIGNAL (clicked ()),
+  connect (current_directory_tool_button, SIGNAL (clicked ()),
            this,                        SLOT   (change_current_working_directory ()));
-  connect (_current_directory_up_tool_button, SIGNAL (clicked ()),
+  connect (current_directory_up_tool_button, SIGNAL (clicked ()),
            this,                        SLOT   (current_working_directory_up()));
   connect (copy_action,                 SIGNAL (triggered()),
            _terminal,                   SLOT   (copyClipboard ()));
   connect (paste_action,                SIGNAL (triggered()),
            _terminal,                   SLOT   (pasteClipboard ()));
   connect (_current_directory_combo_box, SIGNAL (activated (QString)),
            this,                        SLOT (set_current_working_directory (QString)));
+  connect (_current_directory_line_edit, SIGNAL (returnPressed ()),
+           this,                        SLOT (current_working_directory_entered ()));
   connect (_debug_continue,             SIGNAL (triggered ()),
            this,                        SLOT (debug_continue ()));
   connect (_debug_step_into,            SIGNAL (triggered ()),
            this,                        SLOT (debug_step_into ()));
   connect (_debug_step_over,            SIGNAL (triggered ()),
            this,                        SLOT (debug_step_over ()));
   connect (_debug_step_out,             SIGNAL (triggered ()),
            this,                        SLOT (debug_step_out ()));
diff --git a/libgui/src/main-window.h b/libgui/src/main-window.h
--- a/libgui/src/main-window.h
+++ b/libgui/src/main-window.h
@@ -93,16 +93,17 @@ public slots:
   void show_about_octave ();
   void notice_settings ();
   void prepare_for_quit ();
   void reset_windows ();
   void current_working_directory_has_changed (const QString& directory);
   void change_current_working_directory ();
   void set_current_working_directory (const QString& directory);
   void current_working_directory_up ();
+  void current_working_directory_entered ();
 
   void focus_command_window ();
   void focus_command_history ();
   void focus_current_directory ();
   void focus_workspace ();
   void focus_editor ();
   void focus_documentation ();
 
@@ -161,18 +162,20 @@ private:
   history_dock_widget *     _history_dock_widget;
   files_dock_widget *       _files_dock_widget;
   terminal_dock_widget *    _terminal_dock_widget;
   documentation_dock_widget*_documentation_dock_widget;
 
   // Toolbars.
   QStatusBar *              _status_bar;
   QComboBox *               _current_directory_combo_box;
-  QToolButton *             _current_directory_tool_button;
-  QToolButton *             _current_directory_up_tool_button;
+  static const int        current_directory_width       = 300;
+  static const int        current_directory_max_visible = 16;
+  static const int        current_directory_max_count   = 16;
+  QLineEdit *               _current_directory_line_edit;
 
   octave_qt_event_listener *_octave_qt_event_listener;
 
   // Flag for closing whole application
   bool                      _closing;
 };
 
 #endif // MAINWINDOW_H
diff --git a/libgui/src/module.mk b/libgui/src/module.mk
--- a/libgui/src/module.mk
+++ b/libgui/src/module.mk
@@ -22,19 +22,31 @@ octave_gui_ICONS = \
   src/icons/editcopy.png \
   src/icons/editcut.png \
   src/icons/editpaste.png \
   src/icons/filenew.png \
   src/icons/fileopen.png \
   src/icons/filesaveas.png \
   src/icons/filesave.png \
   src/icons/find.png \
+  src/icons/graphic_logo_DocumentationDockWidget.png \
+  src/icons/graphic_logo_FileEditor.png \
+  src/icons/graphic_logo_FilesDockWidget.png \
+  src/icons/graphic_logo_HistoryDockWidget.png \
+  src/icons/graphic_logo_TerminalDockWidget.png \
+  src/icons/graphic_logo_WorkspaceView.png \
   src/icons/help_index.png \
   src/icons/icons_license \
   src/icons/jabber_protocol.png \
+  src/icons/letter_logo_DocumentationDockWidget.png \
+  src/icons/letter_logo_FileEditor.png \
+  src/icons/letter_logo_FilesDockWidget.png \
+  src/icons/letter_logo_HistoryDockWidget.png \
+  src/icons/letter_logo_TerminalDockWidget.png \
+  src/icons/letter_logo_WorkspaceView.png \
   src/icons/logo.png \
   src/icons/question.png \
   src/icons/redled.png \
   src/icons/redo.png \
   src/icons/search.png \
   src/icons/star.png \
   src/icons/stop.png \
   src/icons/terminal.png \
@@ -121,20 +133,17 @@ src_libgui_src_la_SOURCES = \
   src/workspace-model.cc \
   src/workspace-view.cc
 
 nodist_src_libgui_src_la_SOURCES = $(octave_gui_MOC) $(octave_gui_RC)
 
 src_libgui_src_la_CPPFLAGS = \
   $(AM_CPPFLAGS) \
   @OCTGUI_DLL_DEFS@ \
-  -I$(QT_INCDIR) \
-  -I$(QT_INCDIR)/QtCore \
-  -I$(QT_INCDIR)/QtGui \
-  -I$(QT_INCDIR)/QtNetwork \
+  @QT_CPPFLAGS@ \
   -I$(srcdir)/qterminal/libqterminal \
   -Isrc -I$(srcdir)/src \
   -I$(srcdir)/src/m-editor \
   -I$(srcdir)/src/octave-adapter \
   -I$(srcdir)/src/qtinfo \
   -I$(top_srcdir)/liboctave/cruft/misc \
   -I$(top_srcdir)/liboctave/array \
   -I$(top_builddir)/liboctave/numeric -I$(top_srcdir)/liboctave/numeric \
diff --git a/libgui/src/octave-gui.cc b/libgui/src/octave-gui.cc
--- a/libgui/src/octave-gui.cc
+++ b/libgui/src/octave-gui.cc
@@ -26,16 +26,17 @@ along with Octave; see the file COPYING.
 
 #include <QtGui/QApplication>
 #include <QTranslator>
 #include <QSettings>
 
 #include <iostream>
 
 #include "lo-utils.h"
+#include "oct-env.h"
 #include "syswait.h"
 
 #include "welcome-wizard.h"
 #include "resource-manager.h"
 #include "main-window.h"
 #include "octave-gui.h"
 
 // Dissociate from the controlling terminal, if any.
@@ -77,18 +78,16 @@ dissociate_terminal (void)
 #endif
 }
 
 int
 octave_start_gui (int argc, char *argv[])
 {
   dissociate_terminal ();
 
-  setenv ("GNUTERM", "qt", 1);
-
   QApplication application (argc, argv);
 
   while (true)
     {
       if (resource_manager::is_first_run ())
         {
           welcome_wizard welcomeWizard;
           welcomeWizard.exec ();
diff --git a/libgui/src/octave-qt-event-listener.cc b/libgui/src/octave-qt-event-listener.cc
--- a/libgui/src/octave-qt-event-listener.cc
+++ b/libgui/src/octave-qt-event-listener.cc
@@ -31,17 +31,17 @@ octave_qt_event_listener::octave_qt_even
   : QObject (p), octave_event_listener ()
 {
 }
 
 void
 octave_qt_event_listener::current_directory_has_changed (const std::string& directory)
 {
   emit current_directory_has_changed_signal
-    (QString::fromStdString (directory));
+    (QString::fromLocal8Bit (directory.data (), directory.size ()));
 }
 
 void
 octave_qt_event_listener::about_to_exit ()
 {
   qApp->quit ();
 }
 
diff --git a/libgui/src/resource-manager.h b/libgui/src/resource-manager.h
--- a/libgui/src/resource-manager.h
+++ b/libgui/src/resource-manager.h
@@ -23,16 +23,29 @@ along with Octave; see the file COPYING.
 #ifndef RESOURCEMANAGER_H
 #define RESOURCEMANAGER_H
 
 #include <QDesktopServices>
 #include <QIcon>
 #include <QMap>
 #include <QSettings>
 
+// constants for the widget's icons
+enum widget_icon_set
+  {
+    NO_ICON_SET = 0,
+    GRAPHIC_ICON_SET,
+    LETTER_ICON_SET
+  };
+static const char* WIDGET_ICON_SET_PREFIX[] =
+    {":/actions/icons/logo.png",
+     ":/actions/icons/graphic_logo_",
+     ":/actions/icons/letter_logo_"};
+
+
 class resource_manager
 {
 protected:
 
   resource_manager (void);
 
 public:
 
diff --git a/libgui/src/resource.qrc b/libgui/src/resource.qrc
--- a/libgui/src/resource.qrc
+++ b/libgui/src/resource.qrc
@@ -31,10 +31,22 @@
         <file>icons/bp_rm_all.png</file>
         <file>icons/bp_prev.png</file>
         <file>icons/bp_next.png</file>
         <file>icons/db_cont.png</file>
         <file>icons/db_step.png</file>
         <file>icons/db_step_in.png</file>
         <file>icons/db_step_out.png</file>
         <file>icons/db_stop.png</file>
+        <file>icons/letter_logo_FilesDockWidget.png</file>
+        <file>icons/letter_logo_FileEditor.png</file>
+        <file>icons/letter_logo_TerminalDockWidget.png</file>
+        <file>icons/letter_logo_HistoryDockWidget.png</file>
+        <file>icons/letter_logo_WorkspaceView.png</file>
+        <file>icons/letter_logo_DocumentationDockWidget.png</file>
+        <file>icons/graphic_logo_FilesDockWidget.png</file>
+        <file>icons/graphic_logo_FileEditor.png</file>
+        <file>icons/graphic_logo_TerminalDockWidget.png</file>
+        <file>icons/graphic_logo_HistoryDockWidget.png</file>
+        <file>icons/graphic_logo_WorkspaceView.png</file>
+        <file>icons/graphic_logo_DocumentationDockWidget.png</file>
     </qresource>
 </RCC>
diff --git a/libgui/src/settings-dialog.cc b/libgui/src/settings-dialog.cc
--- a/libgui/src/settings-dialog.cc
+++ b/libgui/src/settings-dialog.cc
@@ -33,16 +33,21 @@ settings_dialog::settings_dialog (QWidge
   QDialog (p), ui (new Ui::settings_dialog)
 {
   ui->setupUi (this);
 
   QSettings *settings = resource_manager::get_settings ();
 
   // FIXME -- what should happen if settings is 0?
 
+  int widget_icon_set = settings->value ("DockWidgets/widget_icon_set",0).toInt ();
+  ui->general_icon_octave-> setChecked (NO_ICON_SET == widget_icon_set);
+  ui->general_icon_graphic-> setChecked (GRAPHIC_ICON_SET == widget_icon_set);
+  ui->general_icon_letter-> setChecked (LETTER_ICON_SET == widget_icon_set);
+
   ui->useCustomFileEditor->setChecked (settings->value ("useCustomFileEditor").toBool ());
   ui->customFileEditor->setText (settings->value ("customFileEditor").toString ());
   ui->editor_showLineNumbers->setChecked (settings->value ("editor/showLineNumbers",true).toBool () );
   ui->editor_highlightCurrentLine->setChecked (settings->value ("editor/highlightCurrentLine",true).toBool () );
   ui->editor_codeCompletion->setChecked (settings->value ("editor/codeCompletion",true).toBool () );
   ui->editor_fontName->setCurrentFont (QFont (settings->value ("editor/fontName","Courier").toString()) );
   ui->editor_fontSize->setValue (settings->value ("editor/fontSize",10).toInt ());
   ui->editor_longWindowTitle->setChecked (settings->value ("editor/longWindowTitle",false).toBool ());
@@ -95,16 +100,22 @@ settings_dialog::~settings_dialog ()
 
 void
 settings_dialog::write_changed_settings ()
 {
   QSettings *settings = resource_manager::get_settings ();
 
   // FIXME -- what should happen if settings is 0?
 
+  int widget_icon_set = NO_ICON_SET;
+  if (ui->general_icon_letter->isChecked ())
+    widget_icon_set = LETTER_ICON_SET;
+  else if (ui->general_icon_graphic->isChecked ())
+    widget_icon_set = GRAPHIC_ICON_SET;
+  settings->setValue ("DockWidgets/widget_icon_set",widget_icon_set);
   settings->setValue ("useCustomFileEditor", ui->useCustomFileEditor->isChecked ());
   settings->setValue ("customFileEditor", ui->customFileEditor->text ());
   settings->setValue ("editor/showLineNumbers", ui->editor_showLineNumbers->isChecked ());
   settings->setValue ("editor/highlightCurrentLine", ui->editor_highlightCurrentLine->isChecked ());
   settings->setValue ("editor/codeCompletion", ui->editor_codeCompletion->isChecked ());
   settings->setValue ("editor/fontName", ui->editor_fontName->currentFont().family());
   settings->setValue ("editor/fontSize", ui->editor_fontSize->value());
   settings->setValue ("editor/longWindowTitle", ui->editor_longWindowTitle->isChecked());
diff --git a/libgui/src/settings-dialog.ui b/libgui/src/settings-dialog.ui
--- a/libgui/src/settings-dialog.ui
+++ b/libgui/src/settings-dialog.ui
@@ -29,16 +29,94 @@
    <string>Settings</string>
   </property>
   <layout class="QVBoxLayout" name="verticalLayout_2">
    <item>
     <widget class="QTabWidget" name="tabWidget">
      <property name="currentIndex">
       <number>0</number>
      </property>
+     <widget class="QWidget" name="tab_4">
+      <property name="enabled">
+       <bool>true</bool>
+      </property>
+      <attribute name="title">
+       <string>General</string>
+      </attribute>
+      <widget class="QGroupBox" name="groupBox">
+       <property name="geometry">
+        <rect>
+         <x>10</x>
+         <y>10</y>
+         <width>551</width>
+         <height>81</height>
+        </rect>
+       </property>
+       <property name="sizePolicy">
+        <sizepolicy hsizetype="Expanding" vsizetype="Minimum">
+         <horstretch>0</horstretch>
+         <verstretch>0</verstretch>
+        </sizepolicy>
+       </property>
+       <property name="title">
+        <string>Icon set for dock widget</string>
+       </property>
+       <property name="alignment">
+        <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignTop</set>
+       </property>
+       <property name="flat">
+        <bool>false</bool>
+       </property>
+       <property name="checkable">
+        <bool>false</bool>
+       </property>
+       <widget class="QRadioButton" name="general_icon_octave">
+        <property name="geometry">
+         <rect>
+          <x>0</x>
+          <y>20</y>
+          <width>151</width>
+          <height>21</height>
+         </rect>
+        </property>
+        <property name="text">
+         <string>Octave logo only</string>
+        </property>
+        <property name="checked">
+         <bool>true</bool>
+        </property>
+       </widget>
+       <widget class="QRadioButton" name="general_icon_letter">
+        <property name="geometry">
+         <rect>
+          <x>0</x>
+          <y>40</y>
+          <width>151</width>
+          <height>21</height>
+         </rect>
+        </property>
+        <property name="text">
+         <string>Letter icons</string>
+        </property>
+       </widget>
+       <widget class="QRadioButton" name="general_icon_graphic">
+        <property name="geometry">
+         <rect>
+          <x>0</x>
+          <y>60</y>
+          <width>151</width>
+          <height>21</height>
+         </rect>
+        </property>
+        <property name="text">
+         <string>Graphic  icons</string>
+        </property>
+       </widget>
+      </widget>
+     </widget>
      <widget class="QWidget" name="tab">
       <attribute name="title">
        <string>Editor</string>
       </attribute>
       <layout class="QVBoxLayout" name="verticalLayout_6">
        <item>
         <layout class="QVBoxLayout" name="verticalLayout_5">
          <item>
diff --git a/libgui/src/terminal-dockwidget.cc b/libgui/src/terminal-dockwidget.cc
--- a/libgui/src/terminal-dockwidget.cc
+++ b/libgui/src/terminal-dockwidget.cc
@@ -34,16 +34,30 @@ terminal_dock_widget::terminal_dock_widg
   setWindowTitle (tr ("Command Window"));
   setWidget (terminal);
 
   connect (this, SIGNAL (visibilityChanged (bool)), this, SLOT (handle_visibility_changed (bool)));
   // topLevelChanged is emitted when floating property changes (floating = true)
   connect (this, SIGNAL (topLevelChanged(bool)), this, SLOT(top_level_changed(bool)));
 }
 
+void
+terminal_dock_widget::closeEvent (QCloseEvent *e)
+{
+  emit active_changed (false);
+  QDockWidget::closeEvent (e);
+}
+
+void
+terminal_dock_widget::handle_visibility_changed (bool visible)
+{
+  if (visible)
+    emit active_changed (true);
+}
+
 // slot for signal that is emitted when floating property changes
 void
 terminal_dock_widget::top_level_changed (bool floating)
 {
   if(floating)
     {
       setWindowFlags(Qt::Window);  // make a window from the widget when floating
       show();                      // make it visible again since setWindowFlags hides it
diff --git a/libgui/src/terminal-dockwidget.h b/libgui/src/terminal-dockwidget.h
--- a/libgui/src/terminal-dockwidget.h
+++ b/libgui/src/terminal-dockwidget.h
@@ -31,18 +31,18 @@ class terminal_dock_widget : public QDoc
   Q_OBJECT
   public:
   terminal_dock_widget (QTerminal *terminal, QWidget *parent = 0);
 
 signals:
   void active_changed (bool active);
 
 public slots:
-  void handle_visibility_changed (bool visible)
-  {
-    if (visible)
-      emit active_changed (true);
-  }
+  void handle_visibility_changed (bool visible);
   /** Slot when floating property changes */
   void top_level_changed (bool floating);
+
+protected:
+  void closeEvent (QCloseEvent *event);
 };
 
+
 #endif // TERMINALDOCKWIDGET_H
diff --git a/libinterp/Makefile.am b/libinterp/Makefile.am
--- a/libinterp/Makefile.am
+++ b/libinterp/Makefile.am
@@ -211,19 +211,27 @@ ALL_DEF_FILES = $(SRC_DEF_FILES) $(DLDFC
 $(DEF_FILES): $(OPT_HANDLERS) $(OPT_INC)
 
 ## FIXME: The following two variables are deprecated and should be removed
 ##        in Octave version 3.12.
 DLL_CDEFS = @OCTINTERP_DLL_DEFS@
 DLL_CXXDEFS = @OCTINTERP_DLL_DEFS@
 
 ## Rule to build a DEF file from a .cc file
+##
+## FIXME -- This rule should be fixed to avoid using special
+## flags like JAVA_CPPFLAGS for every file.  How could it be written
+## so that it uses octave_value_liboctave_value_la_CPPFLAGS when
+## generating the octave-value/*.df files?
+## 
+## FIXME -- Shouldn't the build stop if CPP fails here?
 %.df: %.cc
 	$(CXXCPP) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
-	  $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) \
+	  $(AM_CPPFLAGS) $(JAVA_CPPFLAGS) $(CPPFLAGS) \
+	  $(AM_CXXFLAGS) $(CXXFLAGS) \
 	  -DMAKE_BUILTINS $< | $(srcdir)/mkdefs $(srcdir) $< > $@-t
 	mv $@-t $@
 
 ## Override Automake's rule that forces a .hh extension on us even
 ## though we don't want it.  It would be super awesome if automake
 ## would allow users to choose the header file extension.
 .yy.cc:
 	$(am__skipyacc) $(SHELL) $(YLWRAP) $< y.tab.c $@ y.tab.h $*.h y.output $*.output -- $(YACCCOMPILE)
@@ -278,20 +286,20 @@ if AMCOND_BUILD_DOCS
 all-local: $(OCT_STAMP_FILES) $(DLDFCN_PKG_ADD_FILE) .DOCSTRINGS
 else
 all-local: $(OCT_STAMP_FILES) $(DLDFCN_PKG_ADD_FILE)
 endif
 
 if AMCOND_BUILD_DOCS
 install-data-hook: install-oct install-built-in-docstrings
 else
-install-data-hook: install-oct
+install-data-hook: install-oct uninstall-built-in-docstrings
 endif
 
-uninstall-local: uninstall-oct
+uninstall-local: uninstall-oct uninstall-built-in-docstrings
 
 if AMCOND_ENABLE_DYNAMIC_LINKING
 install-oct:
 	$(top_srcdir)/build-aux/mkinstalldirs $(DESTDIR)$(octfiledir)
 	if [ -n "`cat $(DLDFCN_PKG_ADD_FILE)`" ]; then \
 	  $(INSTALL_DATA) $(DLDFCN_PKG_ADD_FILE) $(DESTDIR)$(octfiledir)/PKG_ADD; \
 	fi
 	cd $(DESTDIR)$(octlibdir) && \
@@ -317,18 +325,21 @@ uninstall-oct:
 	rm -f $(DESTDIR)$(octfiledir)/PKG_ADD
 endif
 .PHONY: install-oct uninstall-oct
 
 if AMCOND_BUILD_DOCS
 install-built-in-docstrings:
 	$(MKDIR_P) $(DESTDIR)$(octetcdir)
 	$(INSTALL_DATA) DOCSTRINGS $(DESTDIR)$(octetcdir)/built-in-docstrings
+
+uninstall-built-in-docstrings:
+	rm -f $(DESTDIR)$(octetcdir)/built-in-docstrings
 endif
-.PHONY: install-built-in-docstrings
+.PHONY: install-built-in-docstrings uninstall-built-in-docstrings
 
 CLEANFILES = \
   $(DLDFCN_PKG_ADD_FILE) \
   interpfcn/graphics-props.cc \
   parse-tree/oct-parse.output
 
 DISTCLEANFILES = \
   .DOCSTRINGS \
diff --git a/libinterp/corefcn/mappers.cc b/libinterp/corefcn/mappers.cc
--- a/libinterp/corefcn/mappers.cc
+++ b/libinterp/corefcn/mappers.cc
@@ -542,17 +542,17 @@ Compute the error function,\n\
               2        /\n\
 erf (z) = --------- *  | e^(-t^2) dt\n\
           sqrt (pi)    /\n\
                     t=0\n\
 @end group\n\
 @end example\n\
 \n\
 @end ifnottex\n\
-@seealso{erfc, erfcx, erfinv, erfcinv}\n\
+@seealso{erfc, erfcx, erfi, dawson, erfinv, erfcinv}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).erf ();
   else
     print_usage ();
 
@@ -579,29 +579,36 @@ erf (z) = --------- *  | e^(-t^2) dt\n\
 %!test
 %! x = single ([0,.5,1]);
 %! v = single ([0, .520499877813047, .842700792949715]);
 %! assert (erf (x), v, 1.e-6);
 %! assert (erf (-x), -v, 1.e-6);
 %! assert (erfc (x), 1-v, 1.e-6);
 %! assert (erfinv (v), x, 1.e-6);
 
+%!test
+%! x = [1+2i,-1+2i,1e-6+2e-6i,0+2i];
+%! v = [-0.53664356577857-5.04914370344703i, 0.536643565778565-5.04914370344703i, 0.112837916709965e-5+0.225675833419178e-5i, 18.5648024145755526i];
+%! assert (erf (x), v, -1.e-10);
+%! assert (erf (-x), -v, -1.e-10);
+%! assert (erfc (x), 1-v, -1.e-10);
+
 %!error erf ()
 %!error erf (1, 2)
 */
 
 DEFUN (erfinv, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erfinv (@var{x})\n\
 Compute the inverse error function, i.e., @var{y} such that\n\
 \n\
 @example\n\
 erf (@var{y}) == @var{x}\n\
 @end example\n\
-@seealso{erf, erfc, erfcx, erfcinv}\n\
+@seealso{erf, erfc, erfcx, erfi, dawson, erfcinv}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).erfinv ();
   else
     print_usage ();
 
@@ -629,17 +636,17 @@ erf (@var{y}) == @var{x}\n\
 DEFUN (erfcinv, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erfcinv (@var{x})\n\
 Compute the inverse complementary error function, i.e., @var{y} such that\n\
 \n\
 @example\n\
 erfc (@var{y}) == @var{x}\n\
 @end example\n\
-@seealso{erfc, erf, erfcx, erfinv}\n\
+@seealso{erfc, erf, erfcx, erfi, dawson, erfinv}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).erfcinv ();
   else
     print_usage ();
 
@@ -669,17 +676,17 @@ DEFUN (erfc, args, ,
 @deftypefn {Mapping Function} {} erfc (@var{z})\n\
 Compute the complementary error function,\n\
 @tex\n\
 $1 - {\\rm erf} (z)$.\n\
 @end tex\n\
 @ifnottex\n\
 @w{@code{1 - erf (@var{z})}}.\n\
 @end ifnottex\n\
-@seealso{erfcinv, erfcx, erf, erfinv}\n\
+@seealso{erfcinv, erfcx, erfi, dawson, erf, erfinv}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).erfc ();
   else
     print_usage ();
 
@@ -702,39 +709,125 @@ Compute the scaled complementary error f
 @tex\n\
 $$\n\
  e^{z^2} {\\rm erfc} (z) \\equiv e^{z^2} (1 - {\\rm erf} (z))\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
-exp (z^2) * erfc (x)\n\
+exp (z^2) * erfc (z)\n\
 @end example\n\
 \n\
 @end ifnottex\n\
-@seealso{erfc, erf, erfinv, erfcinv}\n\
+@seealso{erfc, erf, erfi, dawson, erfinv, erfcinv}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
     retval = args(0).erfcx ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-## FIXME: Need a test for erfcx
+
+%!test
+%! x = [1+2i,-1+2i,1e-6+2e-6i,0+2i];
+%! assert (erfcx (x), exp (x.^2) .* erfc(x), -1.e-10);
+
+%!test
+%! x = [100, 100+20i];
+%! v = [0.0056416137829894329, 0.0054246791754558-0.00108483153786434i];
+%! assert (erfcx (x), v, -1.e-10);
 
 %!error erfcx ()
 %!error erfcx (1, 2)
 */
 
+DEFUN (erfi, args, ,
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} erfi (@var{z})\n\
+Compute the imaginary error function,\n\
+@tex\n\
+$$\n\
+ -i {\\rm erf} (iz) \n\
+$$\n\
+@end tex\n\
+@ifnottex\n\
+\n\
+@example\n\
+-i * erf (i*z)\n\
+@end example\n\
+\n\
+@end ifnottex\n\
+@seealso{erfc, erf, erfcx, dawson, erfinv, erfcinv}\n\
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).erfi ();
+  else
+    print_usage ();
+
+  return retval;
+}
+
+/*
+
+%!test
+%! x = [-0.1, 0.1, 1, 1+2i,-1+2i,1e-6+2e-6i,0+2i];
+%! assert (erfi (x), -i * erf(i*x), -1.e-10);
+
+%!error erfi ()
+%!error erfi (1, 2)
+*/
+
+DEFUN (dawson, args, ,
+    "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} dawson (@var{z})\n\
+Compute the Dawson (scaled imaginary error) function,\n\
+@tex\n\
+$$\n\
+ {\\sqrt{\\pi} \\over 2} e^{-z^2} {\\rm erfi} (z) \\equiv -i {\\sqrt{\\pi} \\over 2} e^{-z^2} {\\rm erf} (iz)\n\
+$$\n\
+@end tex\n\
+@ifnottex\n\
+\n\
+@example\n\
+(sqrt (pi) / 2) * exp (-z^2) * erfi (z)\n\
+@end example\n\
+\n\
+@end ifnottex\n\
+@seealso{erfc, erf, erfcx, erfi, erfinv, erfcinv}\n\
+@end deftypefn")
+{
+  octave_value retval;
+  if (args.length () == 1)
+    retval = args(0).dawson ();
+  else
+    print_usage ();
+
+  return retval;
+}
+
+/*
+
+%!test
+%! x = [0.1, 1, 1+2i,-1+2i,1e-4+2e-4i,0+2i];
+%! v = [0.099335992397852861, 0.53807950691, -13.38892731648-11.828715104i, 13.38892731648-11.828715104i, 0.0001000000073333+0.000200000001333i, 48.160012114291i];
+%! assert (dawson (x), v, -1.e-10);
+%! assert (dawson (-x), -v, -1.e-10);
+
+%!error dawson ()
+%!error dawson (1, 2)
+*/
+
 DEFUN (exp, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} exp (@var{x})\n\
 Compute\n\
 @tex\n\
 $e^{x}$\n\
 @end tex\n\
 @ifnottex\n\
diff --git a/libinterp/corefcn/tril.cc b/libinterp/corefcn/tril.cc
--- a/libinterp/corefcn/tril.cc
+++ b/libinterp/corefcn/tril.cc
@@ -351,19 +351,19 @@ Return a new matrix formed by extracting
 or upper (@code{triu}) triangular part of the matrix @var{A}, and\n\
 setting all other elements to zero.  The second argument is optional,\n\
 and specifies how many diagonals above or below the main diagonal should\n\
 also be set to zero.\n\
 \n\
 The default value of @var{k} is zero, so that @code{triu} and\n\
 @code{tril} normally include the main diagonal as part of the result.\n\
 \n\
-If the value of @var{k} is negative, additional elements above (for\n\
-@code{tril}) or below (for @code{triu}) the main diagonal are also\n\
-selected.\n\
+If the value of @var{k} is nonzero integer, the selection of elements\
+starts at an offset of @var{k} diagonals above or below the main\
+diagonal; above for positive @var{k} and below for negative @var{k}.\
 \n\
 The absolute value of @var{k} must not be greater than the number of\n\
 sub-diagonals or super-diagonals.\n\
 \n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
diff --git a/libinterp/dldfcn/fftw.cc b/libinterp/dldfcn/fftw.cc
--- a/libinterp/dldfcn/fftw.cc
+++ b/libinterp/dldfcn/fftw.cc
@@ -262,8 +262,37 @@ they will not be efficient and the point
 #else
 
   warning ("fftw: this copy of Octave was not configured to use the FFTW3 planner");
 
 #endif
 
   return retval;
 }
+
+/*
+
+%!testif HAVE_FFTW
+%! def_method = fftw ("planner");
+%! unwind_protect
+%!   method = "estimate";
+%!   fftw ("planner", method);
+%!   assert (fftw ("planner"), method);
+%!   method = "measure";
+%!   fftw ("planner", method);
+%!   assert (fftw ("planner"), method);
+%!   method = "patient";
+%!   fftw ("planner", method);
+%!   assert (fftw ("planner"), method);
+%!   method = "exhaustive";
+%!   fftw ("planner", method);
+%!   assert (fftw ("planner"), method);
+%!   method = "hybrid";
+%!   fftw ("planner", method);
+%!   assert (fftw ("planner"), method);
+%! unwind_protect_cleanup
+%!   fftw ("planner", def_method);
+%! end_unwind_protect
+
+%!error <Invalid call to fftw> fftw ();
+%!error <Invalid call to fftw> fftw ("planner", "estimate", "measure");
+
+ */
diff --git a/libinterp/dldfcn/module-files b/libinterp/dldfcn/module-files
--- a/libinterp/dldfcn/module-files
+++ b/libinterp/dldfcn/module-files
@@ -4,17 +4,17 @@
 __fltk_uigetfile__.cc|$(GRAPHICS_CFLAGS) $(FT2_CPPFLAGS)|$(GRAPHICS_LDFLAGS) $(FT2_LDFLAGS)|$(GRAPHICS_LIBS) $(FT2_LIBS)
 __glpk__.cc|$(GLPK_CPPFLAGS)|$(GLPK_LDFLAGS)|$(GLPK_LIBS)
 __init_fltk__.cc|$(GRAPHICS_CFLAGS) $(FT2_CPPFLAGS)|$(GRAPHICS_LDFLAGS) $(FT2_LDFLAGS)|$(GRAPHICS_LIBS) $(FT2_LIBS)
 __init_gnuplot__.cc
 __magick_read__.cc|$(MAGICK_CPPFLAGS)|$(MAGICK_LDFLAGS)|$(MAGICK_LIBS)
 __voronoi__.cc|$(QHULL_CPPFLAGS)|$(QHULL_LDFLAGS)|$(QHULL_LIBS)
 amd.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
 ccolamd.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
-chol.cc
+chol.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
 colamd.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
 convhulln.cc|$(QHULL_CPPFLAGS)|$(QHULL_LDFLAGS)|$(QHULL_LIBS)
 dmperm.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
 eigs.cc|$(ARPACK_CPPFLAGS) $(SPARSE_XCPPFLAGS)|$(ARPACK_LDFLAGS) $(SPARSE_XLDFLAGS)|$(ARPACK_LIBS) $(SPARSE_XLIBS) $(LAPACK_LIBS) $(BLAS_LIBS)
 fftw.cc|$(FFTW_XCPPFLAGS)|$(FFTW_XLDFLAGS)|$(FFTW_XLIBS)
 qr.cc|$(QRUPDATE_CPPFLAGS) $(SPARSE_XCPPFLAGS)|$(QRUPDATE_LDFLAGS) $(SPARSE_XLDFLAGS)|$(QRUPDATE_LIBS) $(SPARSE_XLIBS)
 symbfact.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
 symrcm.cc|$(SPARSE_XCPPFLAGS)|$(SPARSE_XLDFLAGS)|$(SPARSE_XLIBS)
diff --git a/libinterp/interp-core/action-container.h b/libinterp/interp-core/action-container.h
--- a/libinterp/interp-core/action-container.h
+++ b/libinterp/interp-core/action-container.h
@@ -26,17 +26,16 @@ along with Octave; see the file COPYING.
 
 // This class allows registering actions in a list for later
 // execution, either explicitly or when the container goes out of
 // scope.
 
 // FIXME -- is there a better name for this class?
 
 class
-OCTINTERP_API
 action_container
 {
 public:
 
   // A generic unwind_protect element. Knows how to run itself and
   // discard itself.  Also, contains a pointer to the next element.
   class elem
   {
diff --git a/libinterp/interp-core/event-queue.h b/libinterp/interp-core/event-queue.h
--- a/libinterp/interp-core/event-queue.h
+++ b/libinterp/interp-core/event-queue.h
@@ -24,17 +24,16 @@ along with Octave; see the file COPYING.
 #define octave_event_queue_h 1
 
 #include <queue>
 #include <memory>
 
 #include "action-container.h"
 
 class
-OCTINTERP_API
 event_queue : public action_container
 {
 public:
 
   event_queue (void) : fifo () { }
 
   // Destructor should not raise an exception, so all actions
   // registered should be exception-safe (but setting error_state is
diff --git a/libinterp/interp-core/jit-ir.cc b/libinterp/interp-core/jit-ir.cc
--- a/libinterp/interp-core/jit-ir.cc
+++ b/libinterp/interp-core/jit-ir.cc
@@ -75,16 +75,26 @@ jit_block_list::insert_before (iterator 
 }
 
 void
 jit_block_list::insert_before (jit_block *loc, jit_block *ablock)
 {
   insert_before (loc->location (), ablock);
 }
 
+void
+jit_block_list::label (void)
+{
+  if (mlist.size ())
+    {
+      jit_block *block = mlist.back ();
+      block->label ();
+    }
+}
+
 std::ostream&
 jit_block_list::print (std::ostream& os, const std::string& header) const
 {
   os << "-------------------- " << header << " --------------------\n";
   return os << *this;
 }
 
 std::ostream&
@@ -464,25 +474,62 @@ jit_block::update_idom (size_t avisit_co
       idom = new_idom;
       return true;
     }
 
   return changed;
 }
 
 void
+jit_block::label (size_t avisit_count, size_t& number)
+{
+  if (visited (avisit_count))
+    return;
+
+  for (jit_use *use = first_use (); use; use = use->next ())
+    {
+      jit_block *pred = use->user_parent ();
+      pred->label (avisit_count, number);
+    }
+
+  mid = number++;
+}
+
+void
 jit_block::pop_all (void)
 {
   for (iterator iter = begin (); iter != end (); ++iter)
     {
       jit_instruction *instr = *iter;
       instr->pop_variable ();
     }
 }
 
+std::ostream&
+jit_block::print (std::ostream& os, size_t indent) const
+{
+  print_indent (os, indent);
+  short_print (os) << ":        %pred = ";
+  for (jit_use *use = first_use (); use; use = use->next ())
+    {
+      jit_block *pred = use->user_parent ();
+      os << *pred;
+      if (use->next ())
+        os << ", ";
+    }
+  os << std::endl;
+
+  for (const_iterator iter = begin (); iter != end (); ++iter)
+    {
+      jit_instruction *instr = *iter;
+      instr->print (os, indent + 1) << std::endl;
+    }
+  return os;
+}
+
 jit_block *
 jit_block::maybe_split (jit_factory& factory, jit_block_list& blocks,
                         jit_block *asuccessor)
 {
   if (successor_count () > 1)
     {
       jit_terminator *term = terminator ();
       size_t idx = term->successor_index (asuccessor);
@@ -646,16 +693,33 @@ jit_terminator::infer (void)
 llvm::TerminatorInst *
 jit_terminator::to_llvm (void) const
 {
   return llvm::cast<llvm::TerminatorInst> (jit_value::to_llvm ());
 }
 
 // -------------------- jit_call --------------------
 bool
+jit_call::needs_release (void) const
+{
+  if (type () && jit_typeinfo::get_release (type ()).valid ())
+    {
+      for (jit_use *use = first_use (); use; use = use->next ())
+        {
+          jit_assign *assign = dynamic_cast<jit_assign *> (use->user ());
+          if (assign && assign->artificial ())
+            return false;
+        }
+
+      return true;
+    }
+  return false;
+}
+
+bool
 jit_call::infer (void)
 {
   // FIXME: explain algorithm
   for (size_t i = 0; i < argument_count (); ++i)
     {
       already_infered[i] = argument_type (i);
       if (! already_infered[i])
         return false;
@@ -674,16 +738,43 @@ jit_call::infer (void)
     {
       stash_type (infered);
       return true;
     }
 
   return false;
 }
 
+// -------------------- jit_error_check --------------------
+std::string
+jit_error_check::variable_to_string (variable v)
+{
+  switch (v)
+    {
+    case var_error_state:
+      return "error_state";
+    case var_interrupt:
+      return "interrupt";
+    default:
+      panic_impossible ();
+    }
+}
+
+std::ostream&
+jit_error_check::print (std::ostream& os, size_t indent) const
+{
+  print_indent (os, indent) << "error_check " << variable_to_string (mvariable)
+                            << ", ";
+
+  if (has_check_for ())
+    os << "<for> " << *check_for () << ", ";
+  print_successor (os << "<normal> ", 1) << ", ";
+  return print_successor (os << "<error> ", 0);
+}
+
 // -------------------- jit_magic_end --------------------
 jit_magic_end::context::context (jit_factory& factory, jit_value *avalue,
                                  size_t aindex, size_t acount)
   : value (avalue), index (factory.create<jit_const_index> (aindex)),
     count (factory.create<jit_const_index> (acount))
 {}
 
 jit_magic_end::jit_magic_end (const std::vector<context>& full_context)
diff --git a/libinterp/interp-core/jit-ir.h b/libinterp/interp-core/jit-ir.h
--- a/libinterp/interp-core/jit-ir.h
+++ b/libinterp/interp-core/jit-ir.h
@@ -164,16 +164,18 @@ public:
   void insert_after (iterator iter, jit_block *ablock);
 
   void insert_after (jit_block *loc, jit_block *ablock);
 
   void insert_before (iterator iter, jit_block *ablock);
 
   void insert_before (jit_block *loc, jit_block *ablock);
 
+  void label (void);
+
   std::ostream& print (std::ostream& os, const std::string& header) const;
 
   std::ostream& print_dom (std::ostream& os) const;
 
   void push_back (jit_block *b);
 private:
   std::list<jit_block *> mlist;
 };
@@ -649,29 +651,17 @@ public:
 
   // label with a RPO walk
   void label (void)
   {
     size_t number = 0;
     label (mvisit_count, number);
   }
 
-  void label (size_t avisit_count, size_t& number)
-  {
-    if (visited (avisit_count))
-      return;
-
-    for (jit_use *use = first_use (); use; use = use->next ())
-      {
-        jit_block *pred = use->user_parent ();
-        pred->label (avisit_count, number);
-      }
-
-    mid = number++;
-  }
+  void label (size_t avisit_count, size_t& number);
 
   // See for idom computation algorithm
   // Cooper, Keith D.; Harvey, Timothy J; and Kennedy, Ken (2001).
   // "A Simple, Fast Dominance Algorithm"
   void compute_idom (jit_block& entry_block)
   {
     bool changed;
     entry_block.idom = &entry_block;
@@ -699,36 +689,17 @@ public:
   size_t dom_successor_count (void) const
   {
     return dom_succ.size ();
   }
 
   // call pop_varaible on all instructions
   void pop_all (void);
 
-  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
-  {
-    print_indent (os, indent);
-    short_print (os) << ":        %pred = ";
-    for (jit_use *use = first_use (); use; use = use->next ())
-      {
-        jit_block *pred = use->user_parent ();
-        os << *pred;
-        if (use->next ())
-          os << ", ";
-      }
-    os << std::endl;
-
-    for (const_iterator iter = begin (); iter != end (); ++iter)
-      {
-        jit_instruction *instr = *iter;
-        instr->print (os, indent + 1) << std::endl;
-      }
-    return os;
-  }
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const;
 
   jit_block *maybe_split (jit_factory& factory, jit_block_list& blocks,
                           jit_block *asuccessor);
 
   jit_block *maybe_split (jit_factory& factory, jit_block_list& blocks,
                           jit_block& asuccessor)
   {
     return maybe_split (factory, blocks, &asuccessor);
@@ -737,16 +708,18 @@ public:
   // print dominator infomration
   std::ostream& print_dom (std::ostream& os) const;
 
   virtual std::ostream& short_print (std::ostream& os) const
   {
     os << mname;
     if (mid != NO_ID)
       os << mid;
+    else
+      os << "!";
     return os;
   }
 
   llvm::BasicBlock *to_llvm (void) const;
 
   std::list<jit_block *>::iterator location (void) const
   { return mlocation; }
 
@@ -1198,20 +1171,17 @@ public:
     return overload ().can_error ();
   }
 
   const jit_function& overload (void) const
   {
     return moperation.overload (argument_types ());
   }
 
-  virtual bool needs_release (void) const
-  {
-    return type () && jit_typeinfo::get_release (type ()).valid ();
-  }
+  virtual bool needs_release (void) const;
 
   virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
   {
     print_indent (os, indent);
 
     if (use_count ())
       short_print (os) << " = ";
     os << "call " << moperation.name () << " (";
@@ -1228,43 +1198,63 @@ public:
   virtual bool infer (void);
 
   JIT_VALUE_ACCEPT;
 private:
   const jit_operation& moperation;
 };
 
 // FIXME: This is just ugly...
-// checks error_state, if error_state is false then goto the normal branche,
+// checks error_state, if error_state is false then goto the normal branch,
 // otherwise goto the error branch
 class
 jit_error_check : public jit_terminator
 {
 public:
-  jit_error_check (jit_call *acheck_for, jit_block *normal, jit_block *error)
-    : jit_terminator (2, error, normal, acheck_for) {}
+  // Which variable is the error check for?
+  enum variable
+    {
+      var_error_state,
+      var_interrupt
+    };
+
+  static std::string variable_to_string (variable v);
+
+  jit_error_check (variable var, jit_call *acheck_for, jit_block *normal,
+                   jit_block *error)
+    : jit_terminator (2, error, normal, acheck_for), mvariable (var) {}
+
+  jit_error_check (variable var, jit_block *normal, jit_block *error)
+    : jit_terminator (2, error, normal), mvariable (var) {}
+
+  variable check_variable (void) const { return mvariable; }
+
+  bool has_check_for (void) const
+  {
+    return argument_count () == 3;
+  }
 
   jit_call *check_for (void) const
   {
+    assert (has_check_for ());
     return static_cast<jit_call *> (argument (2));
   }
 
-  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
-  {
-    print_indent (os, indent) << "error_check " << *check_for () << ", ";
-    print_successor (os, 1) << ", ";
-    return print_successor (os, 0);
-  }
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const;
 
   JIT_VALUE_ACCEPT;
 protected:
   virtual bool check_alive (size_t idx) const
   {
+    if (! has_check_for ())
+      return true;
     return idx == 1 ? true : check_for ()->can_error ();
   }
+private:
+  variable mvariable;
 };
 
 // for now only handles the 1D case
 class
 jit_magic_end : public jit_instruction
 {
 public:
   class
diff --git a/libinterp/interp-core/jit-typeinfo.cc b/libinterp/interp-core/jit-typeinfo.cc
--- a/libinterp/interp-core/jit-typeinfo.cc
+++ b/libinterp/interp-core/jit-typeinfo.cc
@@ -628,18 +628,16 @@ jit_function::call (llvm::IRBuilderD& bu
 llvm::Value *
 jit_function::call (llvm::IRBuilderD& builder,
                     const std::vector<llvm::Value *>& in_args) const
 {
   if (! valid ())
     throw jit_fail_exception ("Call not implemented");
 
   assert (in_args.size () == args.size ());
-  llvm::Function *stacksave
-    = llvm::Intrinsic::getDeclaration (module, llvm::Intrinsic::stacksave);
   llvm::SmallVector<llvm::Value *, 10> llvm_args;
   llvm_args.reserve (in_args.size () + sret ());
 
   llvm::BasicBlock *insert_block = builder.GetInsertBlock ();
   llvm::Function *parent = insert_block->getParent ();
   assert (parent);
 
   // we insert allocas inside the prelude block to prevent stack overflows
@@ -1107,16 +1105,25 @@ jit_typeinfo::jit_typeinfo (llvm::Module
 
   // bind global variables
   lerror_state = new llvm::GlobalVariable (*module, bool_t, false,
                                            llvm::GlobalValue::ExternalLinkage,
                                            0, "error_state");
   engine->addGlobalMapping (lerror_state,
                             reinterpret_cast<void *> (&error_state));
 
+  // sig_atomic_type is going to be some sort of integer
+  sig_atomic_type = llvm::Type::getIntNTy (context, sizeof(sig_atomic_t) * 8);
+  loctave_interrupt_state
+    = new llvm::GlobalVariable (*module, sig_atomic_type, false,
+                                llvm::GlobalValue::ExternalLinkage, 0,
+                                "octave_interrupt_state");
+  engine->addGlobalMapping (loctave_interrupt_state,
+                            reinterpret_cast<void *> (&octave_interrupt_state));
+
   // generic call function
   {
     jit_type *int_t = intN (sizeof (octave_builtin::fcn) * 8);
     any_call = create_function (jit_convention::external, "octave_jit_call",
                                 any, int_t, int_t, any_ptr, int_t);
     any_call.add_mapping (engine, &octave_jit_call);
   }
 
@@ -1317,22 +1324,39 @@ jit_typeinfo::jit_typeinfo (llvm::Module
     llvm::Value *rhs = fn.argument (builder, 1);
 
     // FIXME: We need a better way of doing this, working with llvm's IR
     // directly is sort of a pain.
     llvm::Value *zero = builder.getInt32 (0);
     llvm::Value *one = builder.getInt32 (1);
     llvm::Value *two = builder.getInt32 (2);
     llvm::Value *three = builder.getInt32 (3);
+    llvm::Value *fzero = llvm::ConstantFP::get (scalar_t, 0);
+
+    // we are really dealing with a complex number OR a scalar. That is, if the
+    // complex component is 0, we really have a scalar. This matters in
+    // 0+0i * NaN
+    llvm::BasicBlock *complex_mul = fn.new_block ("complex_mul");
+    llvm::BasicBlock *real_mul = fn.new_block ("real_mul");
+    llvm::BasicBlock *ret_block = fn.new_block ("ret");
+    llvm::Value *temp = builder.CreateFCmpUEQ (complex_imag (lhs), fzero);
+    llvm::Value *temp2 = builder.CreateFCmpUEQ (complex_imag (rhs), fzero);
+    temp = builder.CreateAnd (temp, temp2);
+    builder.CreateCondBr (temp, real_mul, complex_mul);
+
+    builder.SetInsertPoint(real_mul);
+    temp = builder.CreateFMul (complex_real (lhs), complex_real (rhs));
+    llvm::Value *real_branch_ret = complex_new (temp, fzero);
+    builder.CreateBr (ret_block);
 
     llvm::Type *vec4 = llvm::VectorType::get (scalar_t, 4);
     llvm::Value *mlhs = llvm::UndefValue::get (vec4);
     llvm::Value *mrhs = mlhs;
-
-    llvm::Value *temp = complex_real (lhs);
+    builder.SetInsertPoint (complex_mul);
+    temp = complex_real (lhs);
     mlhs = builder.CreateInsertElement (mlhs, temp, zero);
     mlhs = builder.CreateInsertElement (mlhs, temp, two);
     temp = complex_imag (lhs);
     mlhs = builder.CreateInsertElement (mlhs, temp, one);
     mlhs = builder.CreateInsertElement (mlhs, temp, three);
 
     temp = complex_real (rhs);
     mrhs = builder.CreateInsertElement (mrhs, temp, zero);
@@ -1344,17 +1368,25 @@ jit_typeinfo::jit_typeinfo (llvm::Module
     llvm::Value *mres = builder.CreateFMul (mlhs, mrhs);
     llvm::Value *tlhs = builder.CreateExtractElement (mres, zero);
     llvm::Value *trhs = builder.CreateExtractElement (mres, one);
     llvm::Value *ret_real = builder.CreateFSub (tlhs, trhs);
 
     tlhs = builder.CreateExtractElement (mres, two);
     trhs = builder.CreateExtractElement (mres, three);
     llvm::Value *ret_imag = builder.CreateFAdd (tlhs, trhs);
-    fn.do_return (builder, complex_new (ret_real, ret_imag));
+    llvm::Value *complex_branch_ret = complex_new (ret_real, ret_imag);
+    builder.CreateBr (ret_block);
+
+    builder.SetInsertPoint (ret_block);
+    llvm::PHINode *merge = llvm::PHINode::Create(complex_t, 2);
+    builder.Insert (merge);
+    merge->addIncoming (real_branch_ret, real_mul);
+    merge->addIncoming (complex_branch_ret, complex_mul);
+    fn.do_return (builder, merge);
   }
 
   binary_ops[octave_value::op_mul].add_overload (fn);
   binary_ops[octave_value::op_el_mul].add_overload (fn);
 
   jit_function complex_div = create_function (jit_convention::external,
                                               "octave_jit_complex_div",
                                               complex, complex, complex);
@@ -1376,20 +1408,35 @@ jit_typeinfo::jit_typeinfo (llvm::Module
 
   fn = create_function (jit_convention::internal,
                         "octave_jit_*_scalar_complex", complex, scalar,
                         complex);
   jit_function mul_scalar_complex = fn;
   body = fn.new_block ();
   builder.SetInsertPoint (body);
   {
+    llvm::BasicBlock *complex_mul = fn.new_block ("complex_mul");
+    llvm::BasicBlock *scalar_mul = fn.new_block ("scalar_mul");
+
+    llvm::Value *fzero = llvm::ConstantFP::get (scalar_t, 0);
     llvm::Value *lhs = fn.argument (builder, 0);
-    llvm::Value *tlhs = complex_new (lhs, lhs);
     llvm::Value *rhs = fn.argument (builder, 1);
-    fn.do_return (builder, builder.CreateFMul (tlhs, rhs));
+
+    llvm::Value *cmp = builder.CreateFCmpUEQ (complex_imag (rhs), fzero);
+    builder.CreateCondBr (cmp, scalar_mul, complex_mul);
+
+    builder.SetInsertPoint (scalar_mul);
+    llvm::Value *temp = complex_real (rhs);
+    temp = builder.CreateFMul (lhs, temp);
+    fn.do_return (builder, complex_new (temp, fzero), false);
+
+
+    builder.SetInsertPoint (complex_mul);
+    temp = complex_new (lhs, lhs);
+    fn.do_return (builder, builder.CreateFMul (temp, rhs));
   }
   binary_ops[octave_value::op_mul].add_overload (fn);
   binary_ops[octave_value::op_el_mul].add_overload (fn);
 
 
   fn = mirror_binary (mul_scalar_complex);
   binary_ops[octave_value::op_mul].add_overload (fn);
   binary_ops[octave_value::op_el_mul].add_overload (fn);
@@ -1756,17 +1803,17 @@ jit_typeinfo::jit_typeinfo (llvm::Module
   fn = create_function (jit_convention::external, "octave_jit_create_undef",
                         any);
   create_undef_fn.add_overload (fn);
 
   casts[any->type_id ()].stash_name ("(any)");
   casts[scalar->type_id ()].stash_name ("(scalar)");
   casts[complex->type_id ()].stash_name ("(complex)");
   casts[matrix->type_id ()].stash_name ("(matrix)");
-  casts[any->type_id ()].stash_name ("(range)");
+  casts[range->type_id ()].stash_name ("(range)");
 
   // cast any <- matrix
   fn = create_function (jit_convention::external, "octave_jit_cast_any_matrix",
                         any, matrix);
   fn.add_mapping (engine, &octave_jit_cast_any_matrix);
   casts[any->type_id ()].add_overload (fn);
 
   // cast matrix <- any
@@ -2035,16 +2082,24 @@ jit_typeinfo::create_identity (jit_type 
 }
 
 llvm::Value *
 jit_typeinfo::do_insert_error_check (llvm::IRBuilderD& abuilder)
 {
   return abuilder.CreateLoad (lerror_state);
 }
 
+llvm::Value *
+jit_typeinfo::do_insert_interrupt_check (llvm::IRBuilderD& abuilder)
+{
+  llvm::LoadInst *val = abuilder.CreateLoad (loctave_interrupt_state);
+  val->setVolatile (true);
+  return abuilder.CreateICmpSGT (val, abuilder.getInt32 (0));
+}
+
 void
 jit_typeinfo::add_builtin (const std::string& name)
 {
   jit_type *btype = new_type (name, any, any->to_llvm (), true);
   builtins[name] = btype;
 
   octave_builtin *ov_builtin = find_builtin (name);
   if (ov_builtin)
@@ -2268,14 +2323,21 @@ jit_typeinfo::do_type_of (const octave_v
       if (ov.is_real_scalar ())
         return get_scalar ();
 
       if (ov.is_matrix_type ())
         return get_matrix ();
     }
 
   if (ov.is_complex_scalar ())
-    return get_complex ();
+    {
+      Complex cv = ov.complex_value ();
+
+      // We don't really represent complex values, instead we represent
+      // complex_or_scalar. If the imag value is zero, we assume a scalar.
+      if (cv.imag () == 0)
+        return get_complex ();
+    }
 
   return get_any ();
 }
 
 #endif
diff --git a/libinterp/interp-core/jit-typeinfo.h b/libinterp/interp-core/jit-typeinfo.h
--- a/libinterp/interp-core/jit-typeinfo.h
+++ b/libinterp/interp-core/jit-typeinfo.h
@@ -561,16 +561,21 @@ public:
     return instance->do_cast (to, from);
   }
 
   static llvm::Value *insert_error_check (llvm::IRBuilderD& bld)
   {
     return instance->do_insert_error_check (bld);
   }
 
+  static llvm::Value *insert_interrupt_check (llvm::IRBuilderD& bld)
+  {
+    return instance->do_insert_interrupt_check (bld);
+  }
+
   static const jit_operation& end (void)
   {
     return instance->end_fn;
   }
 
   static const jit_function& end (jit_value *value, jit_value *index,
                                   jit_value *count)
   {
@@ -687,16 +692,18 @@ private:
 #undef JIT_PARAM_ARGS
 #undef JIT_PARAMS
 #undef CREATE_FUNCTION
 
   jit_function create_identity (jit_type *type);
 
   llvm::Value *do_insert_error_check (llvm::IRBuilderD& bld);
 
+  llvm::Value *do_insert_interrupt_check (llvm::IRBuilderD& bld);
+
   void add_builtin (const std::string& name);
 
   void register_intrinsic (const std::string& name, size_t id,
                            jit_type *result, jit_type *arg0)
   {
     std::vector<jit_type *> args (1, arg0);
     register_intrinsic (name, id, result, args);
   }
@@ -742,16 +749,19 @@ private:
 
   static jit_typeinfo *instance;
 
   llvm::Module *module;
   llvm::ExecutionEngine *engine;
   int next_id;
 
   llvm::GlobalVariable *lerror_state;
+  llvm::GlobalVariable *loctave_interrupt_state;
+
+  llvm::Type *sig_atomic_type;
 
   std::vector<jit_type*> id_to_type;
   jit_type *any;
   jit_type *matrix;
   jit_type *scalar;
   jit_type *scalar_ptr; // a fake type for interfacing with C++
   jit_type *any_ptr; // a fake type for interfacing with C++
   jit_type *range;
diff --git a/libinterp/interp-core/oct-procbuf.cc b/libinterp/interp-core/oct-procbuf.cc
--- a/libinterp/interp-core/oct-procbuf.cc
+++ b/libinterp/interp-core/oct-procbuf.cc
@@ -37,16 +37,20 @@ along with Octave; see the file COPYING.
 #include "oct-syscalls.h"
 #include "sysdep.h"
 #include "variables.h"
 
 #include "defun.h"
 #include "gripes.h"
 #include "utils.h"
 
+#ifndef SHELL_PATH
+#define SHELL_PATH "/bin/sh"
+#endif
+
 // This class is based on the procbuf class from libg++, written by
 // Per Bothner, Copyright (C) 1993 Free Software Foundation.
 
 static octave_procbuf *octave_procbuf_list = 0;
 
 #ifndef BUFSIZ
 #define BUFSIZ 1024
 #endif
@@ -120,17 +124,17 @@ octave_procbuf::open (const char *comman
             {
               gnulib::fclose (fp);
               fp = 0;
             }
 
           octave_procbuf_list = octave_procbuf_list->next;
         }
 
-      execl ("/bin/sh", "sh", "-c", command, static_cast<void *> (0));
+      execl (SHELL_PATH, "sh", "-c", command, static_cast<void *> (0));
 
       exit (127);
     }
 
   gnulib::close (child_end);
 
   if (proc_pid < 0)
     {
diff --git a/libinterp/interp-core/pt-jit.cc b/libinterp/interp-core/pt-jit.cc
--- a/libinterp/interp-core/pt-jit.cc
+++ b/libinterp/interp-core/pt-jit.cc
@@ -22,26 +22,28 @@ along with Octave; see the file COPYING.
 
 #define __STDC_LIMIT_MACROS
 #define __STDC_CONSTANT_MACROS
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include "debug.h"
 #include "defun.h"
 #include "ov.h"
 #include "pt-all.h"
 #include "pt-jit.h"
+#include "sighandlers.h"
 #include "symtab.h"
 #include "variables.h"
 
-bool Venable_jit_debugging = false;
-
-bool Venable_jit_compiler = true;
+static bool Venable_jit_debugging = false;
+
+static bool Venable_jit_compiler = true;
 
 #ifdef HAVE_LLVM
 
 #include <llvm/Analysis/CallGraph.h>
 #include <llvm/Analysis/Passes.h>
 #include <llvm/Analysis/Verifier.h>
 #include <llvm/Bitcode/ReaderWriter.h>
 #include <llvm/LLVMContext.h>
@@ -55,29 +57,39 @@ bool Venable_jit_compiler = true;
 #include <llvm/Target/TargetData.h>
 #include <llvm/Transforms/IPO.h>
 #include <llvm/Transforms/Scalar.h>
 
 static llvm::IRBuilder<> builder (llvm::getGlobalContext ());
 
 static llvm::LLVMContext& context = llvm::getGlobalContext ();
 
+// -------------------- jit_break_exception --------------------
+
+// jit_break is thrown whenever a branch we are converting has only breaks or
+// continues. This is because all code that follows a break or continue is dead.
+class jit_break_exception : public std::exception {};
+
 // -------------------- jit_convert --------------------
 jit_convert::jit_convert (tree &tee, jit_type *for_bounds)
   : converting_function (false)
 {
   initialize (symbol_table::current_scope ());
 
   if (for_bounds)
     create_variable (next_for_bounds (false), for_bounds);
 
-  visit (tee);
+  try
+    {
+      visit (tee);
+    }
+  catch (const jit_break_exception&)
+    {}
 
   // breaks must have been handled by the top level loop
-  assert (! breaking);
   assert (breaks.empty ());
   assert (continues.empty ());
 
   block->append (factory.create<jit_branch> (final_block));
   blocks.push_back (final_block);
 
   for (variable_map::iterator iter = vmap.begin (); iter != vmap.end (); ++iter)
     {
@@ -114,42 +126,58 @@ jit_convert::jit_convert (octave_user_fu
 
           tree_decl_elt *elt = *piter;
           std::string name = elt->name ();
           create_variable (name, args[i]);
         }
     }
 
   jit_value *return_value = 0;
+  bool all_breaking = false;
   if (fcn.is_special_expr ())
     {
       tree_expression *expr = fcn.special_expr ();
       if (expr)
         {
           jit_variable *retvar = get_variable ("#return");
-          jit_value *retval = visit (expr);
+          jit_value *retval;
+          try
+            {
+              retval = visit (expr);
+            }
+          catch (const jit_break_exception&)
+            {}
+
+          if (breaks.size () || continues.size ())
+            throw jit_fail_exception ("break/continue not supported in "
+                                      "anonymous functions");
+
           block->append (factory.create<jit_assign> (retvar, retval));
           return_value = retvar;
         }
     }
   else
-    visit_statement_list (*fcn.body ());
-
-  // the user may use break or continue to exit the function. Because the
-  // function does not start as a loop, we can have one continue, one break, or
-  // a regular fallthrough to exit the function
-  if (continues.size ())
     {
-      assert (! continues.size ());
+      try
+        {
+          visit_statement_list (*fcn.body ());
+        }
+      catch (const jit_break_exception&)
+        {
+          all_breaking = true;
+        }
+
+      // the user may use break or continue to exit the function
       finish_breaks (final_block, continues);
+      finish_breaks (final_block, breaks);
     }
-  else if (breaks.size ())
-    finish_breaks (final_block, breaks);
-  else
+
+  if (! all_breaking)
     block->append (factory.create<jit_branch> (final_block));
+
   blocks.push_back (final_block);
   block = final_block;
 
   if (! return_value && rlist && rlist->size () == 1)
     {
       tree_decl_elt *elt = rlist->front ();
       return_value = get_variable (elt->name ());
     }
@@ -245,17 +273,17 @@ jit_convert::visit_binary_expression (tr
       result = create_checked (fn, lhsv, rhsv);
     }
 }
 
 void
 jit_convert::visit_break_command (tree_break_command&)
 {
   breaks.push_back (block);
-  breaking = true;
+  throw jit_break_exception ();
 }
 
 void
 jit_convert::visit_colon_expression (tree_colon_expression& expr)
 {
   // in the futher we need to add support for classes and deal with rvalues
   jit_value *base = visit (expr.base ());
   jit_value *limit = visit (expr.limit ());
@@ -270,17 +298,17 @@ jit_convert::visit_colon_expression (tre
   result = block->append (factory.create<jit_call> (jit_typeinfo::make_range, base,
                                             limit, increment));
 }
 
 void
 jit_convert::visit_continue_command (tree_continue_command&)
 {
   continues.push_back (block);
-  breaking = true;
+  throw jit_break_exception ();
 }
 
 void
 jit_convert::visit_global_command (tree_global_command&)
 {
   throw jit_fail_exception ();
 }
 
@@ -305,21 +333,19 @@ jit_convert::visit_decl_init_list (tree_
 void
 jit_convert::visit_simple_for_command (tree_simple_for_command& cmd)
 {
   // Note we do an initial check to see if the loop will run atleast once.
   // This allows us to get better type inference bounds on variables defined
   // and used only inside the for loop (e.g. the index variable)
 
   // If we are a nested for loop we need to store the previous breaks
-  assert (! breaking);
   unwind_protect prot;
   prot.protect_var (breaks);
   prot.protect_var (continues);
-  prot.protect_var (breaking);
   breaks.clear ();
   continues.clear ();
 
   // we need a variable for our iterator, because it is used in multiple blocks
   std::string iter_name = next_iterator ();
   jit_variable *iterator = factory.create<jit_variable> (iter_name);
   factory.create<jit_variable> (iter_name);
   vmap[iter_name] = iterator;
@@ -348,45 +374,63 @@ jit_convert::visit_simple_for_command (t
   // compute the syntactical iterator
   jit_call *idx_rhs = factory.create<jit_call> (jit_typeinfo::for_index,
                                                 control, iterator);
   block->append (idx_rhs);
   do_assign (cmd.left_hand_side (), idx_rhs);
 
   // do loop
   tree_statement_list *pt_body = cmd.body ();
-  pt_body->accept (*this);
-
-  if (breaking && continues.empty ())
+  bool all_breaking = false;
+  try
+    {
+      pt_body->accept (*this);
+    }
+  catch (const jit_break_exception&)
     {
-      // WTF are you doing user? Every branch was a continue, why did you have
-      // a loop??? Users are silly people...
-      finish_breaks (tail, breaks);
-      blocks.push_back (tail);
-      block = tail;
-      return;
+      if (continues.empty ())
+        {
+          // WTF are you doing user? Every branch was a break, why did you have
+          // a loop??? Users are silly people...
+          finish_breaks (tail, breaks);
+          blocks.push_back (tail);
+          block = tail;
+          return;
+        }
+
+      all_breaking = true;
     }
 
   // check our condition, continues jump to this block
   jit_block *check_block = factory.create<jit_block> ("for_check");
   blocks.push_back (check_block);
 
-  if (! breaking)
+  jit_block *interrupt_check = factory.create<jit_block> ("for_interrupt");
+  blocks.push_back (interrupt_check);
+
+  if (! all_breaking)
     block->append (factory.create<jit_branch> (check_block));
   finish_breaks (check_block, continues);
 
   block = check_block;
   const jit_operation& add_fn = jit_typeinfo::binary_op (octave_value::op_add);
   jit_value *one = factory.create<jit_const_index> (1);
   jit_call *iter_inc = factory.create<jit_call> (add_fn, iterator, one);
   block->append (iter_inc);
   block->append (factory.create<jit_assign> (iterator, iter_inc));
-  check = block->append (factory.create<jit_call> (jit_typeinfo::for_check, control,
-                                           iterator));
-  block->append (factory.create<jit_cond_branch> (check, body, tail));
+  check = block->append (factory.create<jit_call> (jit_typeinfo::for_check,
+                                                   control, iterator));
+  block->append (factory.create<jit_cond_branch> (check, interrupt_check,
+                                                  tail));
+
+  block = interrupt_check;
+  jit_error_check *ec
+    = factory.create<jit_error_check> (jit_error_check::var_interrupt,
+                                       body, final_block);
+  block->append (ec);
 
   // breaks will go to our tail
   blocks.push_back (tail);
   finish_breaks (tail, breaks);
   block = tail;
 }
 
 void
@@ -481,16 +525,23 @@ jit_convert::visit_if_command_list (tree
       else
         entry_blocks[i] = factory.create<jit_block> ("ifelse_cond");
     }
 
   jit_block *tail = factory.create<jit_block> ("if_tail");
   if (! last_else)
     entry_blocks[entry_blocks.size () - 1] = tail;
 
+
+  // each branch in the if statement will have different breaks/continues
+  block_list current_breaks = breaks;
+  block_list current_continues = continues;
+  breaks.clear ();
+  continues.clear ();
+
   size_t num_incomming = 0; // number of incomming blocks to our tail
   iter = lst.begin ();
   for (size_t i = 0; iter != lst.end (); ++iter, ++i)
     {
       tree_if_clause *tic = *iter;
       block = entry_blocks[i];
       assert (block);
 
@@ -510,35 +561,41 @@ jit_convert::visit_if_command_list (tree
           jit_instruction *br = factory.create<jit_cond_branch> (check, body,
                                                         entry_blocks[i + 1]);
           block->append (br);
           block = body;
         }
 
       tree_statement_list *stmt_lst = tic->commands ();
       assert (stmt_lst); // jwe: Can this be null?
-      stmt_lst->accept (*this);
-
-      if (breaking)
-        breaking = false;
-      else
+
+      try
         {
+          stmt_lst->accept (*this);
           ++num_incomming;
           block->append (factory.create<jit_branch> (tail));
         }
+      catch(const jit_break_exception&)
+        {}
+
+      current_breaks.splice (current_breaks.end (), breaks);
+      current_continues.splice (current_continues.end (), continues);
     }
 
+  breaks.splice (breaks.end (), current_breaks);
+  continues.splice (continues.end (), current_continues);
+
   if (num_incomming || ! last_else)
     {
       blocks.push_back (tail);
       block = tail;
     }
   else
     // every branch broke, so we don't have a tail
-    breaking = true;
+    throw jit_break_exception ();
 }
 
 void
 jit_convert::visit_index_expression (tree_index_expression& exp)
 {
   result = resolve (exp);
 }
 
@@ -565,27 +622,29 @@ jit_convert::visit_no_op_command (tree_n
 {
   throw jit_fail_exception ();
 }
 
 void
 jit_convert::visit_constant (tree_constant& tc)
 {
   octave_value v = tc.rvalue1 ();
-  if (v.is_real_scalar () && v.is_double_type () && ! v.is_complex_type ())
+  jit_type *ty = jit_typeinfo::type_of (v);
+
+  if (ty == jit_typeinfo::get_scalar ())
     {
       double dv = v.double_value ();
       result = factory.create<jit_const_scalar> (dv);
     }
-  else if (v.is_range ())
+  else if (ty == jit_typeinfo::get_range ())
     {
       Range rv = v.range_value ();
       result = factory.create<jit_const_range> (rv);
     }
-  else if (v.is_complex_scalar ())
+  else if (ty == jit_typeinfo::get_complex ())
     {
       Complex cv = v.complex_value ();
       result = factory.create<jit_const_complex> (cv);
     }
   else
     throw jit_fail_exception ("Unknown constant");
 }
 
@@ -706,19 +765,16 @@ jit_convert::visit_statement_list (tree_
 {
   for (tree_statement_list::iterator iter = lst.begin (); iter != lst.end();
        ++iter)
     {
       tree_statement *elt = *iter;
       // jwe: Can this ever be null?
       assert (elt);
       elt->accept (*this);
-
-      if (breaking)
-        break;
     }
 }
 
 void
 jit_convert::visit_switch_case (tree_switch_case&)
 {
   throw jit_fail_exception ();
 }
@@ -745,21 +801,19 @@ void
 jit_convert::visit_unwind_protect_command (tree_unwind_protect_command&)
 {
   throw jit_fail_exception ();
 }
 
 void
 jit_convert::visit_while_command (tree_while_command& wc)
 {
-  assert (! breaking);
   unwind_protect prot;
   prot.protect_var (breaks);
   prot.protect_var (continues);
-  prot.protect_var (breaking);
   breaks.clear ();
   continues.clear ();
 
   jit_block *cond_check = factory.create<jit_block> ("while_cond_check");
   block->append (factory.create<jit_branch> (cond_check));
   blocks.push_back (cond_check);
   block = cond_check;
 
@@ -771,24 +825,46 @@ jit_convert::visit_while_command (tree_w
   jit_block *body = factory.create<jit_block> ("while_body");
   blocks.push_back (body);
 
   jit_block *tail = factory.create<jit_block> ("while_tail");
   block->append (factory.create<jit_cond_branch> (check, body, tail));
   block = body;
 
   tree_statement_list *loop_body = wc.body ();
+  bool all_breaking = false;
   if (loop_body)
-    loop_body->accept (*this);
+    {
+      try
+        {
+          loop_body->accept (*this);
+        }
+      catch (const jit_break_exception&)
+        {
+          all_breaking = true;
+        }
+    }
 
   finish_breaks (tail, breaks);
-  finish_breaks (cond_check, continues);
-
-  if (! breaking)
-    block->append (factory.create<jit_branch> (cond_check));
+
+  if (! all_breaking || continues.size ())
+    {
+      jit_block *interrupt_check
+        = factory.create<jit_block> ("interrupt_check");
+      blocks.push_back (interrupt_check);
+      finish_breaks (interrupt_check, continues);
+      if (! all_breaking)
+        block->append (factory.create<jit_branch> (interrupt_check));
+
+      block = interrupt_check;
+      jit_error_check *ec
+        = factory.create<jit_error_check> (jit_error_check::var_interrupt,
+                                           cond_check, final_block);
+      block->append (ec);
+    }
 
   blocks.push_back (tail);
   block = tail;
 }
 
 void
 jit_convert::visit_do_until_command (tree_do_until_command&)
 {
@@ -797,34 +873,34 @@ jit_convert::visit_do_until_command (tre
 
 void
 jit_convert::initialize (symbol_table::scope_id s)
 {
   scope = s;
   iterator_count = 0;
   for_bounds_count = 0;
   short_count = 0;
-  breaking = false;
   jit_instruction::reset_ids ();
 
   entry_block = factory.create<jit_block> ("body");
   final_block = factory.create<jit_block> ("final");
   blocks.push_back (entry_block);
   entry_block->mark_alive ();
   block = entry_block;
 }
 
 jit_call *
 jit_convert::create_checked_impl (jit_call *ret)
 {
   block->append (ret);
 
   jit_block *normal = factory.create<jit_block> (block->name ());
-  jit_error_check *check = factory.create<jit_error_check> (ret, normal,
-                                                            final_block);
+  jit_error_check *check
+    = factory.create<jit_error_check> (jit_error_check::var_error_state, ret,
+                                       normal, final_block);
   block->append (check);
   blocks.push_back (normal);
   block = normal;
 
   return ret;
 }
 
 jit_variable *
@@ -1307,17 +1383,30 @@ void
 jit_convert_llvm::visit (jit_variable&)
 {
   throw jit_fail_exception ("ERROR: SSA construction should remove all variables");
 }
 
 void
 jit_convert_llvm::visit (jit_error_check& check)
 {
-  llvm::Value *cond = jit_typeinfo::insert_error_check (builder);
+  llvm::Value *cond;
+
+  switch (check.check_variable ())
+    {
+    case jit_error_check::var_error_state:
+      cond = jit_typeinfo::insert_error_check (builder);
+      break;
+    case jit_error_check::var_interrupt:
+      cond = jit_typeinfo::insert_interrupt_check (builder);
+      break;
+    default:
+      panic_impossible ();
+    }
+
   llvm::Value *br = builder.CreateCondBr (cond, check.successor_llvm (0),
                                           check.successor_llvm (1));
   check.stash_llvm (br);
 }
 
 void
 jit_convert_llvm::visit (jit_assign& assign)
 {
@@ -1383,17 +1472,17 @@ jit_infer::infer (void)
           if (jit_terminator *term = dynamic_cast<jit_terminator *> (next))
             append_users_term (term);
           else
             append_users (next);
         }
     }
 
   remove_dead ();
-  final_block ().label ();
+  blocks.label ();
   place_releases ();
   simplify_phi ();
 }
 
 void
 jit_infer::append_users (jit_value *v)
 {
   for (jit_use *use = v->first_use (); use; use = use->next ())
@@ -1417,17 +1506,17 @@ jit_infer::append_users_term (jit_termin
             push_worklist (sterm);
         }
     }
 }
 
 void
 jit_infer::construct_ssa (void)
 {
-  final_block ().label ();
+  blocks.label ();
   final_block ().compute_idom (entry_block ());
   entry_block ().compute_df ();
   entry_block ().create_dom_tree ();
 
   // insert phi nodes where needed, this is done on a per variable basis
   for (variable_map::const_iterator iter = vmap.begin (); iter != vmap.end ();
        ++iter)
     {
@@ -1788,17 +1877,17 @@ tree_jit::initialize (void)
 }
 
 bool
 tree_jit::do_execute (tree_simple_for_command& cmd, const octave_value& bounds)
 {
   const size_t MIN_TRIP_COUNT = 1000;
 
   size_t tc = trip_count (bounds);
-  if (! tc || ! initialize ())
+  if (! tc || ! initialize () || ! enabled ())
     return false;
 
   jit_info::vmap extra_vars;
   extra_vars["#for_bounds0"] = &bounds;
 
   jit_info *info = cmd.get_info ();
   if (! info || ! info->match (extra_vars))
     {
@@ -1811,17 +1900,17 @@ tree_jit::do_execute (tree_simple_for_co
     }
 
   return info->execute (extra_vars);
 }
 
 bool
 tree_jit::do_execute (tree_while_command& cmd)
 {
-  if (! initialize ())
+  if (! initialize () || ! enabled ())
     return false;
 
   jit_info *info = cmd.get_info ();
   if (! info || ! info->match ())
     {
       delete info;
       info = new jit_info (*this, cmd);
       cmd.stash_info (info);
@@ -1829,30 +1918,40 @@ tree_jit::do_execute (tree_while_command
 
   return info->execute ();
 }
 
 bool
 tree_jit::do_execute (octave_user_function& fcn, const octave_value_list& args,
                       octave_value_list& retval)
 {
-  if (! initialize ())
+  if (! initialize () || ! enabled ())
     return false;
 
   jit_function_info *info = fcn.get_info ();
     if (! info || ! info->match (args))
       {
         delete info;
         info = new jit_function_info (*this, fcn, args);
         fcn.stash_info (info);
       }
 
     return info->execute (args, retval);
 }
 
+bool
+tree_jit::enabled (void)
+{
+  // Ideally, we should only disable JIT if there is a breakpoint in the code we
+  // are about to run. However, we can't figure this out in O(1) time, so we
+  // conservatively check for the existence of any breakpoints.
+  return Venable_jit_compiler && ! bp_table::have_breakpoints ()
+    && ! Vdebug_on_interrupt && ! Vdebug_on_error;
+}
+
 size_t
 tree_jit::trip_count (const octave_value& bounds) const
 {
   if (bounds.is_range ())
     {
       Range rng = bounds.range_value ();
       return rng.nelem ();
     }
@@ -1898,18 +1997,17 @@ jit_function_info::jit_function_info (tr
       jit_convert conv (fcn, argument_types);
       jit_infer infer (conv.get_factory (), conv.get_blocks (),
                        conv.get_variable_map ());
       infer.infer ();
 
       if (Venable_jit_debugging)
         {
           jit_block_list& blocks = infer.get_blocks ();
-          jit_block *entry_block = blocks.front ();
-          entry_block->label ();
+          blocks.label ();
           std::cout << "-------------------- Compiling function ";
           std::cout << "--------------------\n";
 
           tree_print_code tpc (std::cout);
           tpc.visit_octave_user_function_header (fcn);
           tpc.visit_statement_list (*fcn.body ());
           tpc.visit_octave_user_function_trailer (fcn);
           blocks.print (std::cout, "octave jit ir");
@@ -2013,16 +2111,18 @@ jit_function_info::execute (const octave
       obv->grab ();
       args[i] = obv;
     }
 
   octave_base_value *ret = function (&args[0]);
   if (ret)
     retval(0) = octave_value (ret);
 
+  octave_quit ();
+
   return true;
 }
 
 bool
 jit_function_info::match (const octave_value_list& ov_args) const
 {
   if (! function)
     return true;
@@ -2081,16 +2181,18 @@ jit_info::execute (const vmap& extra_var
     {
       const std::string& name = arguments[i].first;
 
       // do not store for loop bounds temporary
       if (name.size () && name[0] != '#')
         symbol_table::varref (arguments[i].first) = real_arguments[i];
     }
 
+  octave_quit ();
+
   return true;
 }
 
 bool
 jit_info::match (const vmap& extra_vars) const
 {
   if (! function)
     return true;
@@ -2118,18 +2220,17 @@ jit_info::compile (tree_jit& tjit, tree&
       jit_infer infer (conv.get_factory (), conv.get_blocks (),
                        conv.get_variable_map ());
 
       infer.infer ();
 
       if (Venable_jit_debugging)
         {
           jit_block_list& blocks = infer.get_blocks ();
-          jit_block *entry_block = blocks.front ();
-          entry_block->label ();
+          blocks.label ();
           std::cout << "-------------------- Compiling tree --------------------\n";
           std::cout << tee.str_print_code () << std::endl;
           blocks.print (std::cout, "octave jit ir");
         }
 
       jit_factory& factory = conv.get_factory ();
       jit_convert_llvm to_llvm;
       llvm_function = to_llvm.convert_loop (tjit.get_module (),
@@ -2222,16 +2323,43 @@ variable value is restored when exiting 
   return octave_value ();
 #endif
 }
 
 /*
 Test some simple cases that compile.
 
 %!test
+%! for i=1:1e6
+%!   if i < 5
+%!     break
+%!   else
+%!     break
+%!   endif
+%! endfor
+%! assert (i, 1);
+
+%!test
+%! while 1
+%!   if 1
+%!     break
+%!  else
+%!    break
+%!  endif
+%! endwhile
+
+%!test
+%! for i=1:1e6
+%!   if i == 100
+%!     break
+%!   endif
+%! endfor
+%! assert (i, 100);
+
+%!test
 %! inc = 1e-5;
 %! result = 0;
 %! for ii = 0:inc:1
 %!   result = result + inc * (1/3 * ii * ii);
 %! endfor
 %! assert (abs (result - 1/9) < 1e-5);
 
 %!test
@@ -2239,16 +2367,45 @@ Test some simple cases that compile.
 %! result = 0;
 %! for ii = 0:inc:1
 %!   # the ^ operator's result is complex
 %!   result = result + inc * (1/3 * ii ^ 2);
 %! endfor
 %! assert (abs (result - 1/9) < 1e-5);
 
 %!test
+%! temp = 1+1i;
+%! nan = NaN;
+%! while 1
+%!   temp = temp - 1i;
+%!   temp = temp * nan;
+%!   break;
+%! endwhile
+%! assert (imag (temp), 0);
+
+%!test
+%! temp = 1+1i;
+%! nan = NaN+1i;
+%! while 1
+%!   nan = nan - 1i;
+%!   temp = temp - 1i;
+%!   temp = temp * nan;
+%!   break;
+%! endwhile
+%! assert (imag (temp), 0);
+
+%!test
+%! temp = 1+1i;
+%! while 1
+%!   temp = temp * 5;
+%!   break;
+%! endwhile
+%! assert (temp, 5+5i);
+
+%!test
 %! nr = 1001;
 %! mat = zeros (1, nr);
 %! for i = 1:nr
 %!   mat(i) = i;
 %! endfor
 %! assert (mat == 1:nr);
 
 %!test
diff --git a/libinterp/interp-core/pt-jit.h b/libinterp/interp-core/pt-jit.h
--- a/libinterp/interp-core/pt-jit.h
+++ b/libinterp/interp-core/pt-jit.h
@@ -226,18 +226,16 @@ private:
 
   jit_value *do_assign (const std::string& lhs, jit_value *rhs, bool print,
                         bool artificial = false);
 
   jit_value *visit (tree *tee) { return visit (*tee); }
 
   jit_value *visit (tree& tee);
 
-  bool breaking; // true if we are breaking OR continuing
-
   typedef std::list<jit_block *> block_list;
   block_list breaks;
   block_list continues;
 
   void finish_breaks (jit_block *dest, const block_list& lst);
 };
 
 // Convert from the low level Octave IR to LLVM
@@ -374,16 +372,18 @@ public:
 
   bool do_execute (tree_simple_for_command& cmd, const octave_value& bounds);
 
   bool do_execute (tree_while_command& cmd);
 
   bool do_execute (octave_user_function& fcn, const octave_value_list& args,
                    octave_value_list& retval);
 
+  bool enabled (void);
+
   size_t trip_count (const octave_value& bounds) const;
 
   llvm::Module *module;
   llvm::PassManager *module_pass_manager;
   llvm::FunctionPassManager *pass_manager;
   llvm::ExecutionEngine *engine;
 };
 
@@ -434,16 +434,9 @@ private:
   jited_function function;
   llvm::Function *llvm_function;
 
   std::vector<std::pair<std::string, bool> > arguments;
   type_bound_vector bounds;
 };
 
 #endif
-
-// If TRUE, enable JIT compiler debugging/tracing.
-extern bool Venable_jit_debugging;
-
-// If TRUE, enable JIT compiler.
-extern bool Venable_jit_compiler;
-
 #endif
diff --git a/libinterp/interpfcn/data.cc b/libinterp/interpfcn/data.cc
--- a/libinterp/interpfcn/data.cc
+++ b/libinterp/interpfcn/data.cc
@@ -2787,17 +2787,23 @@ effect.\n\
             MAKE_INT_BRANCH (int16);
             MAKE_INT_BRANCH (int32);
             MAKE_INT_BRANCH (int64);
             MAKE_INT_BRANCH (uint8);
             MAKE_INT_BRANCH (uint16);
             MAKE_INT_BRANCH (uint32);
             MAKE_INT_BRANCH (uint64);
 #undef MAKE_INT_BRANCH
-
+            // GAGME: Accursed Matlab compatibility...
+            case btyp_char:
+              if (isextra)
+                retval = arg.array_value (true).xsum (dim);
+              else
+                retval = arg.array_value (true).sum (dim);
+              break;
             case btyp_bool:
               if (arg.is_sparse_type ())
                 {
                   if (isnative)
                     retval = arg.sparse_bool_matrix_value ().any (dim);
                   else
                     retval = arg.sparse_bool_matrix_value ().sum (dim);
                 }
@@ -2869,16 +2875,19 @@ effect.\n\
 %!assert (sum (zeros (0, 2, "single"), 1), single ([0, 0]))
 %!assert (sum (zeros (0, 2, "single"), 2), zeros (0, 1, "single"))
 %!assert (sum (zeros (2, 2, 0, 3, "single")), zeros (1, 2, 0, 3, "single"))
 %!assert (sum (zeros (2, 2, 0, 3, "single"), 2), zeros (2, 1, 0, 3, "single"))
 %!assert (sum (zeros (2, 2, 0, 3, "single"), 3), zeros (2, 2, 1, 3, "single"))
 %!assert (sum (zeros (2, 2, 0, 3, "single"), 4), zeros (2, 2, 0, "single"))
 %!assert (sum (zeros (2, 2, 0, 3, "single"), 7), zeros (2, 2, 0, 3, "single"))
 
+;-)
+%!assert (sum ("Octave") + "8", sumsq (primes (17)))
+
 %!error sum ()
 */
 
 DEFUN (sumsq, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} sumsq (@var{x})\n\
 @deftypefnx {Built-in Function} {} sumsq (@var{x}, @var{dim})\n\
 Sum of squares of elements along dimension @var{dim}.  If @var{dim}\n\
diff --git a/libinterp/interpfcn/debug.cc b/libinterp/interpfcn/debug.cc
--- a/libinterp/interpfcn/debug.cc
+++ b/libinterp/interpfcn/debug.cc
@@ -789,31 +789,34 @@ do_dbtype (std::ostream& os, const std::
   else
     os << "dbtype: unknown function " << name << "\n";
 
   os.flush ();
 }
 
 DEFUN (dbtype, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} dbtype ()\n\
-@deftypefnx {Built-in Function} {} dbtype (\"startl:endl\")\n\
-@deftypefnx {Built-in Function} {} dbtype (\"startl:end\")\n\
-@deftypefnx {Built-in Function} {} dbtype (\"@var{func}\")\n\
-@deftypefnx {Built-in Function} {} dbtype (\"@var{func}\", \"startl\")\n\
-@deftypefnx {Built-in Function} {} dbtype (\"@var{func}\", \"startl:endl\")\n\
-@deftypefnx {Built-in Function} {} dbtype (\"@var{func}\", \"startl:end\")\n\
-When in debugging mode and called with no arguments, list the script file\n\
-being debugged with line numbers.  An optional range specification,\n\
-specified as a string, can be used to list only a portion of the file.\n\
-The special keyword \"end\" is a valid line number specification.\n\
+@deftypefn  {Command} {} dbtype\n\
+@deftypefnx {Command} {} dbtype @var{lineno}\n\
+@deftypefnx {Command} {} dbtype @var{startl:endl}\n\
+@deftypefnx {Command} {} dbtype @var{startl:end}\n\
+@deftypefnx {Command} {} dbtype @var{func}\n\
+@deftypefnx {Command} {} dbtype @var{func} @var{lineno}\n\
+@deftypefnx {Command} {} dbtype @var{func} @var{startl:endl}\n\
+@deftypefnx {Command} {} dbtype @var{func} @var{startl:end}\n\
+Display a script file with line numbers.\n\
 \n\
-When called with the name of a function, list that script file\n\
-with line numbers.\n\
-@seealso{dbstatus, dbstop}\n\
+When called with no arguments in debugging mode, display the script file\n\
+currently being debugged.  An optional range specification can be used to\n\
+list only a portion of the file.  The special keyword \"end\" is a valid\n\
+line number specification for the last line of the file.\n\
+\n\
+When called with the name of a function, list that script file with line\n\
+numbers.\n\
+@seealso{dbwhere, dbstatus, dbstop}\n\
 @end deftypefn")
 {
   octave_value retval;
   octave_user_code *dbg_fcn;
 
   int nargin = args.length ();
   string_vector argv = args.make_argv ("dbtype");
 
diff --git a/libinterp/interpfcn/error.cc b/libinterp/interpfcn/error.cc
--- a/libinterp/interpfcn/error.cc
+++ b/libinterp/interpfcn/error.cc
@@ -1938,32 +1938,34 @@ DEFUN (debug_on_error, args, nargout,
 Query or set the internal variable that controls whether Octave will try\n\
 to enter the debugger when an error is encountered.  This will also\n\
 inhibit printing of the normal traceback message (you will only see\n\
 the top-level error message).\n\
 \n\
 When called from inside a function with the \"local\" option, the variable is\n\
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
+@seealso{debug_on_warning, debug_on_interrupt}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (debug_on_error);
 }
 
 DEFUN (debug_on_warning, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} debug_on_warning ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} debug_on_warning (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} debug_on_warning (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will try\n\
 to enter the debugger when a warning is encountered.\n\
 \n\
 When called from inside a function with the \"local\" option, the variable is\n\
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
+@seealso{debug_on_error, debug_on_interrupt}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (debug_on_warning);
 }
 
 std::string
 last_error_message (void)
 {
diff --git a/libinterp/interpfcn/graphics.cc b/libinterp/interpfcn/graphics.cc
--- a/libinterp/interpfcn/graphics.cc
+++ b/libinterp/interpfcn/graphics.cc
@@ -132,26 +132,30 @@ validate_property_name (const std::strin
   return caseless_str ();
 }
 
 static Matrix
 jet_colormap (void)
 {
   Matrix cmap (64, 3, 0.0);
 
+  // Produce X in the same manner as linspace so that 
+  // jet_colormap and jet.m produce *exactly* the same result.
+  double delta = 1.0 / 63.0;
+
   for (octave_idx_type i = 0; i < 64; i++)
     {
       // This is the jet colormap.  It would be nice to be able
       // to feval the jet function but since there is a static
       // property object that includes a colormap_property
       // object, we need to initialize this before main is even
       // called, so calling an interpreted function is not
       // possible.
 
-      double x = i / 63.0;
+      double x = i*delta;
 
       if (x >= 3.0/8.0 && x < 5.0/8.0)
         cmap(i,0) = 4.0 * x - 3.0/2.0;
       else if (x >= 5.0/8.0 && x < 7.0/8.0)
         cmap(i,0) = 1.0;
       else if (x >= 7.0/8.0)
         cmap(i,0) = -4.0 * x + 9.0/2.0;
 
@@ -2036,23 +2040,22 @@ graphics_object::set (const Array<std::s
 %! h = plot (1:10, 10:-1:1, 1:10, 1:10);
 %! set (h, {"linewidth"}, {10, "x"; 5, "o"});
 */
 
 // Set properties given in a struct array
 void
 graphics_object::set (const octave_map& m)
 {
-  for (octave_map::const_iterator p = m.begin ();
-       p != m.end (); p++)
-    {
-      caseless_str name  = m.key (p);
-
-      octave_value val = octave_value (m.contents (p).elem (m.numel () - 1));
-
+  for (octave_idx_type p = 0; p < m.nfields (); p++)
+    {
+      caseless_str name  = m.keys ()[p];
+
+      octave_value val = octave_value (m.contents (name).elem (m.numel () - 1));
+      
       set_value_or_default (name, val);
 
       if (error_state)
         break;
     }
 }
 
 /*
@@ -2061,16 +2064,42 @@ graphics_object::set (const octave_map& 
 %! set (gcf, "visible", "off");
 %! h = plot (1:10, 10:-1:1);
 %! set (h, struct ("linewidth", 10, "marker", "x"));
 %! assert (get (h, "linewidth"), 10);
 %! assert (get (h, "marker"), "x");
 %! h = plot (1:10, 10:-1:1, 1:10, 1:10);
 %! set (h, struct ("linewidth", {5, 10}));
 %! assert (get (h, "linewidth"), {10; 10});
+## test ordering
+%!test
+%! markchanged = @(h, foobar, name) set (h, "userdata", [get(h,"userdata"); {name}]);
+%! figure (1, "visible", "off")
+%! clf ()
+%! h = line ();
+%! set (h, "userdata", {})
+%! addlistener (h, "color", {markchanged, "color"})
+%! addlistener (h, "linewidth", {markchanged, "linewidth"})
+%! # "linewidth" first
+%! props.linewidth = 2;
+%! props.color = "r";
+%! set (h, props);
+%! assert (get (h, "userdata"), fieldnames (props))
+%! clear props
+%! clf ()
+%! h = line ();
+%! set (h, "userdata", {})
+%! addlistener (h, "color", {markchanged, "color"})
+%! addlistener (h, "linewidth", {markchanged, "linewidth"})
+%! # "color" first
+%! props.color = "r";
+%! props.linewidth = 2;
+%! set (h, props);
+%! assert (get (h, "userdata"), fieldnames (props))
+%! close (1)
 */
 
 // Set a property to a value or to its (factory) default value.
 
 void
 graphics_object::set_value_or_default (const caseless_str& name,
                                        const octave_value& val)
 {
diff --git a/libinterp/interpfcn/graphics.in.h b/libinterp/interpfcn/graphics.in.h
--- a/libinterp/interpfcn/graphics.in.h
+++ b/libinterp/interpfcn/graphics.in.h
@@ -1389,17 +1389,17 @@ public:
       xmin (), xmax (), xminp (), xmaxp (),
       type_constraints (), size_constraints ()
     {
       get_data_limits ();
     }
 
   array_property (const std::string& nm, const graphics_handle& h,
                   const octave_value& m)
-    : base_property (nm, h), data (m),
+    : base_property (nm, h), data (m.is_sparse_type () ? m.full_value () : m),
       xmin (), xmax (), xminp (), xmaxp (),
       type_constraints (), size_constraints ()
     {
       get_data_limits ();
     }
 
   // This copy constructor is only intended to be used
   // internally to access min/max values; no need to
@@ -1449,22 +1449,24 @@ public:
       p->size_constraints = size_constraints;
 
       return p;
     }
 
 protected:
   bool do_set (const octave_value& v)
     {
-      if (validate (v))
+      octave_value tmp = v.is_sparse_type () ? v.full_value () : v;
+
+      if (validate (tmp))
         {
           // FIXME -- should we check for actual data change?
-          if (! is_equal (v))
+          if (! is_equal (tmp))
             {
-              data = v;
+              data = tmp;
 
               get_data_limits ();
 
               return true;
             }
         }
       else
         error ("invalid value for array property \"%s\"",
diff --git a/libinterp/interpfcn/help.h b/libinterp/interpfcn/help.h
--- a/libinterp/interpfcn/help.h
+++ b/libinterp/interpfcn/help.h
@@ -31,26 +31,26 @@ class string_vector;
 extern string_vector make_name_list (void);
 
 extern OCTINTERP_API std::string raw_help (const std::string&, bool&);
 
 extern OCTINTERP_API void install_built_in_docstrings (void);
 
 // Name of the doc cache file specified on the command line.
 // (--doc-cache-file file)
-extern std::string Vdoc_cache_file;
+extern OCTINTERP_API std::string Vdoc_cache_file;
 
 // Name of the file containing local Texinfo macros that are prepended
 // to doc strings before processing.
 // (--texi-macros-file)
-extern std::string Vtexi_macros_file;
+extern OCTINTERP_API std::string Vtexi_macros_file;
 
 // Name of the info file specified on command line.
 // (--info-file file)
-extern std::string Vinfo_file;
+extern OCTINTERP_API std::string Vinfo_file;
 
 // Name of the info reader we'd like to use.
 // (--info-program program)
-extern std::string Vinfo_program;
+extern OCTINTERP_API std::string Vinfo_program;
 
-extern std::string do_which (const std::string& name);
+extern OCTINTERP_API std::string do_which (const std::string& name);
 
 #endif
diff --git a/libinterp/interpfcn/oct-hist.cc b/libinterp/interpfcn/oct-hist.cc
--- a/libinterp/interpfcn/oct-hist.cc
+++ b/libinterp/interpfcn/oct-hist.cc
@@ -123,35 +123,62 @@ static std::string Vhistory_timestamp_fo
   = default_history_timestamp_format ();
 
 // Display, save, or load history.  Stolen and modified from bash.
 //
 // Arg of -w FILENAME means write file, arg of -r FILENAME
 // means read file, arg of -q means don't number lines.  Arg of N
 // means only display that many items.
 
-static void
-do_history (int argc, const string_vector& argv)
+static string_vector
+do_history (const octave_value_list& args, int nargout)
 {
-  int numbered_output = 1;
+  bool numbered_output = nargout == 0;
 
   unwind_protect frame;
 
+  string_vector hlist;
+
   frame.add_fcn (command_history::set_file, command_history::file ());
 
-  int i;
-  for (i = 1; i < argc; i++)
+  int nargin = args.length ();
+
+  // Number of history lines to show
+  int limit = -1;
+
+  for (octave_idx_type i = 0; i < nargin; i++)
     {
-      std::string option = argv[i];
+      octave_value arg = args(i);
+
+      std::string option;
+
+      if (arg.is_string ())
+        option = arg.string_value ();
+      else if (arg.is_numeric_type ())
+        {
+          limit = arg.int_value ();
+          continue;
+        }
+      else
+        {
+          gripe_wrong_type_arg ("history", arg);
+          return hlist;
+        }
 
       if (option == "-r" || option == "-w" || option == "-a"
           || option == "-n")
         {
-          if (i < argc - 1)
-            command_history::set_file (argv[i+1]);
+          if (i < nargin - 1 && args(i+1).is_string ())
+            command_history::set_file (args(++i).string_value ());
+          else
+            {
+              error ("history: expecting file name for %s option",
+                     option.c_str ());
+              return hlist;
+            }
 
           if (option == "-a")
             // Append 'new' lines to file.
             command_history::append ();
 
           else if (option == "-w")
             // Write entire history.
             command_history::write ();
@@ -162,53 +189,59 @@ do_history (int argc, const string_vecto
 
           else if (option == "-n")
             // Read 'new' history from file.
             command_history::read_range ();
 
           else
             panic_impossible ();
 
-          return;
+          return hlist;
         }
-      else if (argv[i] == "-q")
-        numbered_output = 0;
-      else if (argv[i] == "--")
+      else if (option == "-q")
+        numbered_output = false;
+      else if (option == "--")
         {
           i++;
           break;
         }
       else
-        break;
+        {
+          // The last argument found in the command list that looks like
+          // an integer will be used
+          int tmp;
+
+          if (sscanf (option.c_str (), "%d", &tmp) == 1)
+            limit = tmp;
+          else
+            {
+              if (option.length () > 0 && option[0] == '-')
+                error ("history: unrecognized option '%s'", option.c_str ());
+              else
+                error ("history: bad non-numeric arg '%s'", option.c_str ());
+
+              return  hlist;
+            }
+        }
     }
 
-  int limit = -1;
+  if (limit < 0)
+    limit = -limit;
 
-  if (i < argc)
-    {
-      if (sscanf (argv[i].c_str (), "%d", &limit) != 1)
-        {
-          if (argv[i][0] == '-')
-            error ("history: unrecognized option '%s'", argv[i].c_str ());
-          else
-            error ("history: bad non-numeric arg '%s'", argv[i].c_str ());
-
-          return;
-        }
-
-      if (limit < 0)
-        limit = -limit;
-    }
-
-  string_vector hlist = command_history::list (limit, numbered_output);
+  hlist = command_history::list (limit, numbered_output);
 
   int len = hlist.length ();
 
-  for (i = 0; i < len; i++)
-    octave_stdout << hlist[i] << "\n";
+  if (nargout == 0)
+    {
+      for (octave_idx_type i = 0; i < len; i++)
+        octave_stdout << hlist[i] << "\n";
+    }
+
+  return hlist;
 }
 
 // Read the edited history lines from STREAM and return them
 // one at a time.  This can read unlimited length lines.  The
 // caller should free the storage.
 
 static char *
 edit_history_readline (std::fstream& stream)
@@ -309,19 +342,38 @@ edit_history_add_hist (const std::string
       if (len > 0 && tmp[len-1] == '\n')
         tmp.resize (len - 1);
 
       if (! tmp.empty ())
         command_history::add (tmp);
     }
 }
 
+static bool
+get_int_arg (const octave_value& arg, int& val)
+{
+  bool ok = true;
+
+  if (arg.is_string ())
+    {
+      std::string tmp = arg.string_value ();
+
+      ok = sscanf (tmp.c_str (), "%d", &val) == 1;
+    }
+  else if (arg.is_numeric_type ())
+    val = arg.int_value ();
+  else
+    ok = false;
+
+  return ok;
+}
+
 static std::string
-mk_tmp_hist_file (int argc, const string_vector& argv,
-                  int insert_curr, const char *warn_for)
+mk_tmp_hist_file (const octave_value_list& args,
+                  bool insert_curr, const char *warn_for)
 {
   std::string retval;
 
   string_vector hlist = command_history::list ();
 
   int hist_count = hlist.length ();
 
   // The current command line is already part of the history list by
@@ -334,41 +386,44 @@ mk_tmp_hist_file (int argc, const string
 
   hist_count--;
 
   // If no numbers have been specified, the default is to edit the
   // last command in the history list.
 
   int hist_end = hist_count;
   int hist_beg = hist_count;
-  int reverse = 0;
+
+  bool reverse = false;
 
   // Process options.
 
-  int usage_error = 0;
-  if (argc == 3)
+  int nargin = args.length ();
+
+  bool usage_error = false;
+  if (nargin == 2)
     {
-      if (sscanf (argv[1].c_str (), "%d", &hist_beg) != 1
-          || sscanf (argv[2].c_str (), "%d", &hist_end) != 1)
-        usage_error = 1;
-      else
+      if (get_int_arg (args(0), hist_beg)
+          && get_int_arg (args(1), hist_end))
         {
           hist_beg--;
           hist_end--;
         }
+      else
+        usage_error = true;
     }
-  else if (argc == 2)
+  else if (nargin == 1)
     {
-      if (sscanf (argv[1].c_str (), "%d", &hist_beg) != 1)
-        usage_error = 1;
-      else
+      if (get_int_arg (args(0), hist_beg))
         {
           hist_beg--;
           hist_end = hist_beg;
         }
+      else
+        usage_error = true;
     }
 
   if (hist_beg < 0 || hist_end < 0 || hist_beg > hist_count
       || hist_end > hist_count)
     {
       error ("%s: history specification out of range", warn_for);
       return retval;
     }
@@ -379,17 +434,17 @@ mk_tmp_hist_file (int argc, const string
       return retval;
     }
 
   if (hist_end < hist_beg)
     {
       int t = hist_end;
       hist_end = hist_beg;
       hist_beg = t;
-      reverse = 1;
+      reverse = true;
     }
 
   std::string name = octave_tempnam ("", "oct-");
 
   std::fstream file (name.c_str (), std::ios::out);
 
   if (! file)
     {
@@ -416,19 +471,19 @@ mk_tmp_hist_file (int argc, const string
 
 static void
 unlink_cleanup (const char *file)
 {
   gnulib::unlink (file);
 }
 
 static void
-do_edit_history (int argc, const string_vector& argv)
+do_edit_history (const octave_value_list& args)
 {
-  std::string name = mk_tmp_hist_file (argc, argv, 0, "edit_history");
+  std::string name = mk_tmp_hist_file (args, false, "edit_history");
 
   if (name.empty ())
     return;
 
   // Call up our favorite editor on the file of commands.
 
   std::string cmd = VEDITOR;
   cmd.append (" \"");
@@ -484,19 +539,19 @@ do_edit_history (int argc, const string_
 
   Vecho_executing_commands = ECHO_CMD_LINE;
   input_from_tmp_history_file = true;
 
   source_file (name);
 }
 
 static void
-do_run_history (int argc, const string_vector& argv)
+do_run_history (const octave_value_list& args)
 {
-  std::string name = mk_tmp_hist_file (argc, argv, 1, "run_history");
+  std::string name = mk_tmp_hist_file (args, true, "run_history");
 
   if (name.empty ())
     return;
 
   // Turn on command echo so the output from this will make better
   // sense.
 
   unwind_protect frame;
@@ -565,31 +620,25 @@ only extracts commands 13 through 169.  
 the first command than the last command reverses the list of commands\n\
 before placing them in the buffer to be edited.  If both arguments are\n\
 omitted, the previous command in the history list is used.\n\
 @seealso{run_history}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  int argc = args.length () + 1;
-
-  string_vector argv = args.make_argv ("edit_history");
-
-  if (error_state)
-    return retval;
-
-  do_edit_history (argc, argv);
+  do_edit_history (args);
 
   return retval;
 }
 
-DEFUN (history, args, ,
+DEFUN (history, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Command} {} history options\n\
+@deftypefn {Command} history options\n\
+@deftypefnx {Built-in Function} {@var{h} = } history (@var{opt1}, @var{opt2}, @dots{})\n\
 If invoked with no arguments, @code{history} displays a list of commands\n\
 that you have executed.  Valid options are:\n\
 \n\
 @table @code\n\
 @item -w @var{file}\n\
 Write the current history to the file @var{file}.  If the name is\n\
 omitted, use the default history file (normally @file{~/.octave_hist}).\n\
 \n\
@@ -604,50 +653,42 @@ Display only the most recent @var{n} lin
 @item -q\n\
 Don't number the displayed lines of history.  This is useful for cutting\n\
 and pasting commands using the X Window System.\n\
 @end table\n\
 \n\
 For example, to display the five most recent commands that you have\n\
 typed without displaying line numbers, use the command\n\
 @kbd{history -q 5}.\n\
+\n\
+If invoked with a single output argument, the history will be saved to that\n\
+argument as a cell string and will not be output to screen.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
-  int argc = args.length () + 1;
+  octave_value retval;
 
-  string_vector argv = args.make_argv ("history");
+  string_vector hlist = do_history (args, nargout);
 
-  if (error_state)
-    return retval;
-
-  do_history (argc, argv);
+  if (nargout > 0)
+    retval = Cell (hlist);
 
   return retval;
 }
 
 DEFUN (run_history, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Command} {} run_history [@var{first}] [@var{last}]\n\
 Similar to @code{edit_history}, except that the editor is not invoked,\n\
 and the commands are simply executed as they appear in the history list.\n\
 @seealso{edit_history}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  int argc = args.length () + 1;
-
-  string_vector argv = args.make_argv ("run_history");
-
-  if (error_state)
-    return retval;
-
-  do_run_history (argc, argv);
+  do_run_history (args);
 
   return retval;
 }
 
 DEFUN (history_control, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} history_control ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} history_control (@var{new_val})\n\
diff --git a/libinterp/interpfcn/sighandlers.cc b/libinterp/interpfcn/sighandlers.cc
--- a/libinterp/interpfcn/sighandlers.cc
+++ b/libinterp/interpfcn/sighandlers.cc
@@ -56,17 +56,17 @@ along with Octave; see the file COPYING.
 // Nonzero means we have already printed a message for this series of
 // SIGPIPES.  We assume that the writer will eventually give up.
 int pipe_handler_error_count = 0;
 
 // TRUE means we can be interrupted.
 bool can_interrupt = false;
 
 // TRUE means we should try to enter the debugger on SIGINT.
-static bool Vdebug_on_interrupt = false;
+bool Vdebug_on_interrupt = false;
 
 // Allow users to avoid writing octave-workspace for SIGHUP (sent by
 // closing gnome-terminal, for example).  Note that this variable has
 // no effect if Vcrash_dumps_octave_core is FALSE.
 static bool Vsighup_dumps_octave_core = true;
 
 // Similar to Vsighup_dumps_octave_core, but for SIGTERM signal.
 static bool Vsigterm_dumps_octave_core = true;
@@ -973,16 +973,17 @@ DEFUN (debug_on_interrupt, args, nargout
 Query or set the internal variable that controls whether Octave will try\n\
 to enter debugging mode when it receives an interrupt signal (typically\n\
 generated with @kbd{C-c}).  If a second interrupt signal is received\n\
 before reaching the debugging mode, a normal interrupt will occur.\n\
 \n\
 When called from inside a function with the \"local\" option, the variable is\n\
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
+@seealso{debug_on_error, debug_on_warning}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (debug_on_interrupt);
 }
 
 /*
 %!test
 %! orig_val = debug_on_interrupt ();
diff --git a/libinterp/interpfcn/sighandlers.h b/libinterp/interpfcn/sighandlers.h
--- a/libinterp/interpfcn/sighandlers.h
+++ b/libinterp/interpfcn/sighandlers.h
@@ -169,9 +169,12 @@ private:
 
   static bool instance_ok (void);
 
   static octave_child_list_rep *instance;
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
 };
 
+// TRUE means we should try to enter the debugger on SIGINT.
+extern OCTINTERP_API bool Vdebug_on_interrupt;
+
 #endif
diff --git a/libinterp/interpfcn/toplev.cc b/libinterp/interpfcn/toplev.cc
--- a/libinterp/interpfcn/toplev.cc
+++ b/libinterp/interpfcn/toplev.cc
@@ -72,16 +72,20 @@ along with Octave; see the file COPYING.
 #include "sysdep.h"
 #include "syswait.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 #include "version.h"
 
+#ifndef SHELL_PATH
+#define SHELL_PATH "/bin/sh"
+#endif
+
 void (*octave_exit) (int) = ::exit;
 
 // TRUE means the quit() call is allowed.
 bool quit_allowed = true;
 
 // TRUE means we are exiting via the builtin exit or quit functions.
 bool quitting_gracefully = false;
 // This stores the exit status.
@@ -945,17 +949,17 @@ command shell that is started to run the
 
               if (pid < 0)
                 error ("system: fork failed -- can't create child process");
               else if (pid == 0)
                 {
                   // FIXME -- should probably replace this
                   // call with something portable.
 
-                  execl ("/bin/sh", "sh", "-c", cmd_str.c_str (),
+                  execl (SHELL_PATH, "sh", "-c", cmd_str.c_str (),
                          static_cast<void *> (0));
 
                   panic_impossible ();
                 }
               else
                 retval(0) = pid;
 #elif defined (__WIN32__)
               STARTUPINFO si;
@@ -1341,18 +1345,19 @@ specified option.\n\
       { false, "PTHREAD_CFLAGS", OCTAVE_CONF_PTHREAD_CFLAGS },
       { false, "PTHREAD_LIBS", OCTAVE_CONF_PTHREAD_LIBS },
       { false, "QHULL_CPPFLAGS", OCTAVE_CONF_QHULL_CPPFLAGS },
       { false, "QHULL_LDFLAGS", OCTAVE_CONF_QHULL_LDFLAGS },
       { false, "QHULL_LIBS", OCTAVE_CONF_QHULL_LIBS },
       { false, "QRUPDATE_CPPFLAGS", OCTAVE_CONF_QRUPDATE_CPPFLAGS },
       { false, "QRUPDATE_LDFLAGS", OCTAVE_CONF_QRUPDATE_LDFLAGS },
       { false, "QRUPDATE_LIBS", OCTAVE_CONF_QRUPDATE_LIBS },
-      { false, "QT_INCDIR", OCTAVE_CONF_QT_INCDIR },
-      { false, "QT_LIBDIR", OCTAVE_CONF_QT_LIBDIR },
+      { false, "QT_CPPFLAGS", OCTAVE_CONF_QT_CPPFLAGS },
+      { false, "QT_LDFLAGS", OCTAVE_CONF_QT_LDFLAGS },
+      { false, "QT_LIBS", OCTAVE_CONF_QT_LIBS },
       { false, "RANLIB", OCTAVE_CONF_RANLIB },
       { false, "RDYNAMIC_FLAG", OCTAVE_CONF_RDYNAMIC_FLAG },
       { false, "READLINE_LIBS", OCTAVE_CONF_READLINE_LIBS },
       { false, "REGEX_LIBS", OCTAVE_CONF_REGEX_LIBS },
       { false, "SED", OCTAVE_CONF_SED },
       { false, "SHARED_LIBS", OCTAVE_CONF_SHARED_LIBS },
       { false, "SHLEXT", OCTAVE_CONF_SHLEXT },
       { false, "SHLEXT_VER", OCTAVE_CONF_SHLEXT_VER },
diff --git a/libinterp/interpfcn/variables.cc b/libinterp/interpfcn/variables.cc
--- a/libinterp/interpfcn/variables.cc
+++ b/libinterp/interpfcn/variables.cc
@@ -277,17 +277,17 @@ generate_struct_completions (const std::
 
           discard_error_messages = true;
           discard_warning_messages = true;
 
           octave_value tmp = eval_string (prefix, true, parse_status);
 
           frame.run ();
 
-          if (tmp.is_defined () && tmp.is_map ())
+          if (tmp.is_defined () && (tmp.is_map () || tmp.is_java ()))
             names = tmp.map_keys ();
         }
     }
 
   return names;
 }
 
 // FIXME -- this will have to be much smarter to work
diff --git a/libinterp/link-deps.mk b/libinterp/link-deps.mk
--- a/libinterp/link-deps.mk
+++ b/libinterp/link-deps.mk
@@ -2,30 +2,29 @@ include $(top_srcdir)/liboctave/link-dep
 
 if AMCOND_ENABLE_DYNAMIC_LINKING
   LIBOCTINTERP_LINK_DEPS =
 else
   LIBOCTINTERP_LINK_DEPS = $(DLDFCN_LIBS)
 endif
 
 LIBOCTINTERP_LINK_DEPS += \
-  $(GRAPHICS_LIBS) \
   $(FT2_LIBS) \
   $(HDF5_LIBS) \
   $(Z_LIBS) \
   $(FFTW_XLIBS) \
   $(REGEX_LIBS) \
   $(OPENGL_LIBS) \
   $(X11_LIBS) \
   $(CARBON_LIBS) \
   $(LLVM_LIBS) \
+  $(JAVA_LIBS) \
   $(LAPACK_LIBS)
 
 LIBOCTINTERP_LINK_OPTS = \
-  $(GRAPHICS_LDFLAGS) \
   $(FT2_LDFLAGS) \
   $(HDF5_LDFLAGS) \
   $(Z_LDFLAGS) \
   $(REGEX_LDFLAGS) \
   $(FFTW_XLDFLAGS) \
   $(LLVM_LDFLAGS)
 
 OCT_LINK_DEPS =
diff --git a/libinterp/oct-conf.in.h b/libinterp/oct-conf.in.h
--- a/libinterp/oct-conf.in.h
+++ b/libinterp/oct-conf.in.h
@@ -477,22 +477,26 @@ along with Octave; see the file COPYING.
 #ifndef OCTAVE_CONF_QRUPDATE_LDFLAGS
 #define OCTAVE_CONF_QRUPDATE_LDFLAGS %OCTAVE_CONF_QRUPDATE_LDFLAGS%
 #endif
 
 #ifndef OCTAVE_CONF_QRUPDATE_LIBS
 #define OCTAVE_CONF_QRUPDATE_LIBS %OCTAVE_CONF_QRUPDATE_LIBS%
 #endif
 
-#ifndef OCTAVE_CONF_QT_INCDIR
-#define OCTAVE_CONF_QT_INCDIR %OCTAVE_CONF_QT_INCDIR%
+#ifndef OCTAVE_CONF_QT_CPPFLAGS
+#define OCTAVE_CONF_QT_CPPFLAGS %OCTAVE_CONF_QT_CPPFLAGS%
 #endif
 
-#ifndef OCTAVE_CONF_QT_LIBDIR
-#define OCTAVE_CONF_QT_LIBDIR %OCTAVE_CONF_QT_LIBDIR%
+#ifndef OCTAVE_CONF_QT_LDFLAGS
+#define OCTAVE_CONF_QT_LDFLAGS %OCTAVE_CONF_QT_LDFLAGS%
+#endif
+
+#ifndef OCTAVE_CONF_QT_LIBS
+#define OCTAVE_CONF_QT_LIBS %OCTAVE_CONF_QT_LIBS%
 #endif
 
 #ifndef OCTAVE_CONF_RANLIB
 #define OCTAVE_CONF_RANLIB %OCTAVE_CONF_RANLIB%
 #endif
 
 #ifndef OCTAVE_CONF_RDYNAMIC_FLAG
 #define OCTAVE_CONF_RDYNAMIC_FLAG %OCTAVE_CONF_RDYNAMIC_FLAG%
diff --git a/libinterp/octave-value/module.mk b/libinterp/octave-value/module.mk
--- a/libinterp/octave-value/module.mk
+++ b/libinterp/octave-value/module.mk
@@ -47,16 +47,17 @@ OCTAVE_VALUE_INC = \
   octave-value/ov-fcn-inline.h \
   octave-value/ov-fcn.h \
   octave-value/ov-float.h \
   octave-value/ov-flt-complex.h \
   octave-value/ov-flt-cx-diag.h \
   octave-value/ov-flt-cx-mat.h \
   octave-value/ov-flt-re-diag.h \
   octave-value/ov-flt-re-mat.h \
+  octave-value/ov-java.h \
   octave-value/ov-lazy-idx.h \
   octave-value/ov-mex-fcn.h \
   octave-value/ov-null-mat.h \
   octave-value/ov-oncleanup.h \
   octave-value/ov-perm.h \
   octave-value/ov-range.h \
   octave-value/ov-re-diag.h \
   octave-value/ov-re-mat.h \
@@ -105,16 +106,17 @@ OCTAVE_VALUE_SRC = \
   octave-value/ov-fcn-inline.cc \
   octave-value/ov-fcn.cc \
   octave-value/ov-float.cc \
   octave-value/ov-flt-complex.cc \
   octave-value/ov-flt-cx-diag.cc \
   octave-value/ov-flt-cx-mat.cc \
   octave-value/ov-flt-re-diag.cc \
   octave-value/ov-flt-re-mat.cc \
+  octave-value/ov-java.cc \
   octave-value/ov-lazy-idx.cc \
   octave-value/ov-mex-fcn.cc \
   octave-value/ov-null-mat.cc \
   octave-value/ov-oncleanup.cc \
   octave-value/ov-perm.cc \
   octave-value/ov-range.cc \
   octave-value/ov-re-diag.cc \
   octave-value/ov-re-mat.cc \
@@ -125,9 +127,19 @@ OCTAVE_VALUE_SRC = \
   octave-value/ov-usr-fcn.cc \
   octave-value/ov.cc \
   $(OV_INTTYPE_SRC) \
   $(OV_SPARSE_SRC)
 
 noinst_LTLIBRARIES += octave-value/liboctave-value.la
 
 octave_value_liboctave_value_la_SOURCES = $(OCTAVE_VALUE_SRC)
-octave_value_liboctave_value_la_CPPFLAGS = $(liboctinterp_la_CPPFLAGS)
+
+## FIXME -- maybe it would be better to limit the JAVA flags to
+## the compile commands for ov-java.cc?  Does JAVA_LIBS need to be
+## added to LIBOCTINTERP_LINK_DEPS (see libinterp/link-deps.mk)?
+## Should we have a separate set of JAVA_LDFLAGS?
+
+octave_value_liboctave_value_la_CPPFLAGS = \
+  $(liboctinterp_la_CPPFLAGS) \
+  $(JAVA_CPPFLAGS)
+
+octave_value_liboctave_value_la_LIBADD = $(JAVA_LIBS)
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -1189,16 +1189,18 @@ octave_base_value::get_umap_name (unary_
       "conj",
       "cos",
       "cosh",
       "erf",
       "erfinv",
       "erfcinv",
       "erfc",
       "erfcx",
+      "erfi",
+      "dawson",
       "exp",
       "expm1",
       "finite",
       "fix",
       "floor",
       "gamma",
       "imag",
       "isinf",
diff --git a/libinterp/octave-value/ov-base.h b/libinterp/octave-value/ov-base.h
--- a/libinterp/octave-value/ov-base.h
+++ b/libinterp/octave-value/ov-base.h
@@ -360,16 +360,18 @@ public:
   virtual bool is_sq_string (void) const { return false; }
 
   virtual bool is_range (void) const { return false; }
 
   virtual bool is_map (void) const { return false; }
 
   virtual bool is_object (void) const { return false; }
 
+  virtual bool is_java (void) const { return false; }
+
   virtual bool is_cs_list (void) const { return false; }
 
   virtual bool is_magic_colon (void) const { return false; }
 
   virtual bool is_all_va_args (void) const { return false; }
 
   virtual octave_value all (int = 0) const;
 
@@ -684,16 +686,18 @@ public:
       umap_conj,
       umap_cos,
       umap_cosh,
       umap_erf,
       umap_erfinv,
       umap_erfcinv,
       umap_erfc,
       umap_erfcx,
+      umap_erfi,
+      umap_dawson,
       umap_exp,
       umap_expm1,
       umap_finite,
       umap_fix,
       umap_floor,
       umap_gamma,
       umap_imag,
       umap_isinf,
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -40,16 +40,19 @@ along with Octave; see the file COPYING.
 #include "load-path.h"
 #include "ls-hdf5.h"
 #include "ls-oct-ascii.h"
 #include "ls-oct-binary.h"
 #include "ls-utils.h"
 #include "mxarray.h"
 #include "oct-lvalue.h"
 #include "ov-class.h"
+#ifdef HAVE_JAVA
+#include "ov-java.h"
+#endif
 #include "ov-fcn.h"
 #include "ov-usr-fcn.h"
 #include "pager.h"
 #include "parse.h"
 #include "pr-output.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 #include "variables.h"
@@ -1916,35 +1919,38 @@ octave_class::exemplar_info::compare (co
       error ("invalid comparison of class exemplar to non-class object");
     }
 
   return retval;
 }
 
 DEFUN (class, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} class (@var{expr})\n\
-@deftypefnx {Built-in Function} {} class (@var{s}, @var{id})\n\
-@deftypefnx {Built-in Function} {} class (@var{s}, @var{id}, @var{p}, @dots{})\n\
-Return the class of the expression @var{expr} or create a class with\n\
+@deftypefn  {Function File} {@var{classname} =} class (@var{obj})\n\
+@deftypefnx {Function File} {} class (@var{s}, @var{id})\n\
+@deftypefnx {Function File} {} class (@var{s}, @var{id}, @var{p}, @dots{})\n\
+Return the class of the object @var{obj} or create a class with\n\
 fields from structure @var{s} and name (string) @var{id}.  Additional\n\
 arguments name a list of parent classes from which the new class is\n\
 derived.\n\
+@seealso{typeinfo, isa}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     print_usage ();
   else if (nargin == 1)
+    // Called for class of object
     retval = args(0).class_name ();
   else
     {
+      // Called as class constructor
       octave_function *fcn = octave_call_stack::caller ();
 
       std::string id = args(1).string_value ();
 
       if (! error_state)
         {
           if (fcn)
             {
@@ -1991,16 +1997,28 @@ derived.\n\
         }
       else
         error ("class: ID (class name) must be a character string");
     }
 
   return retval;
 }
 
+/*
+%!assert (class (1.1), "double");
+%!assert (class (single (1.1)), "single");
+%!assert (class (uint8 (1)), "uint8");
+%!testif HAVE_JAVA
+%! jobj = javaObject ("java.lang.StringBuffer");
+%! assert (class (jobj), "java.lang.StringBuffer");
+
+%% Test Input Validation
+%!error class ()
+*/
+
 DEFUN (__isa_parent__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __isa_parent__ (@var{class}, @var{name})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
@@ -2098,57 +2116,43 @@ is a method of this class.\n\
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN (methods, args, nargout,
+DEFUN (__methods__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Built-in Function} {} methods (@var{x})\n\
-@deftypefnx {Built-in Function} {} methods (\"classname\")\n\
-Return a cell array containing the names of the methods for the\n\
-object @var{x} or the named class.\n\
+@deftypefn  {Built-in Function} {} __methods__ (@var{x})\n\
+@deftypefnx {Built-in Function} {} __methods__ (\"classname\")\n\
+Internal function.\n\
+\n\
+Implements @code{methods} for Octave class objects and classnames.\n\
+@seealso{methods}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  if (args.length () == 1)
-    {
-      octave_value arg = args(0);
-
-      std::string class_name;
+  // Input validation has already been done in methods.m.
+  octave_value arg = args(0);
 
-      if (arg.is_object ())
-        class_name = arg.class_name ();
-      else if (arg.is_string ())
-        class_name = arg.string_value ();
-      else
-        error ("methods: expecting object or class name as argument");
+  std::string class_name;
 
-      if (! error_state)
-        {
-          string_vector sv = load_path::methods (class_name);
-
-          if (nargout == 0)
-            {
-              octave_stdout << "Methods for class " << class_name << ":\n\n";
+  if (arg.is_object ())
+    class_name = arg.class_name ();
+  else if (arg.is_string ())
+    class_name = arg.string_value ();
 
-              sv.list_in_columns (octave_stdout);
-
-              octave_stdout << std::endl;
-            }
-          else
-            retval = Cell (sv);
-        }
+  if (! error_state)
+    {
+      string_vector sv = load_path::methods (class_name);
+      retval = Cell (sv);
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 static bool
 is_built_in_class (const std::string& cn)
 {
   static std::set<std::string> built_in_class_names;
diff --git a/libinterp/octave-value/ov-complex.cc b/libinterp/octave-value/ov-complex.cc
--- a/libinterp/octave-value/ov-complex.cc
+++ b/libinterp/octave-value/ov-complex.cc
@@ -426,16 +426,21 @@ octave_complex::map (unary_mapper_t umap
       SCALAR_MAPPER (acos, ::acos);
       SCALAR_MAPPER (acosh, ::acosh);
       SCALAR_MAPPER (angle, std::arg);
       SCALAR_MAPPER (arg, std::arg);
       SCALAR_MAPPER (asin, ::asin);
       SCALAR_MAPPER (asinh, ::asinh);
       SCALAR_MAPPER (atan, ::atan);
       SCALAR_MAPPER (atanh, ::atanh);
+      SCALAR_MAPPER (erf, ::erf);
+      SCALAR_MAPPER (erfc, ::erfc);
+      SCALAR_MAPPER (erfcx, ::erfcx);
+      SCALAR_MAPPER (erfi, ::erfi);
+      SCALAR_MAPPER (dawson, ::dawson);
       SCALAR_MAPPER (ceil, ::ceil);
       SCALAR_MAPPER (conj, std::conj);
       SCALAR_MAPPER (cos, std::cos);
       SCALAR_MAPPER (cosh, std::cosh);
       SCALAR_MAPPER (exp, std::exp);
       SCALAR_MAPPER (expm1, ::expm1);
       SCALAR_MAPPER (fix, ::fix);
       SCALAR_MAPPER (floor, ::floor);
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -772,16 +772,21 @@ octave_complex_matrix::map (unary_mapper
       ARRAY_MAPPER (acos, Complex, ::acos);
       ARRAY_MAPPER (acosh, Complex, ::acosh);
       ARRAY_MAPPER (angle, double, std::arg);
       ARRAY_MAPPER (arg, double, std::arg);
       ARRAY_MAPPER (asin, Complex, ::asin);
       ARRAY_MAPPER (asinh, Complex, ::asinh);
       ARRAY_MAPPER (atan, Complex, ::atan);
       ARRAY_MAPPER (atanh, Complex, ::atanh);
+      ARRAY_MAPPER (erf, Complex, ::erf);
+      ARRAY_MAPPER (erfc, Complex, ::erfc);
+      ARRAY_MAPPER (erfcx, Complex, ::erfcx);
+      ARRAY_MAPPER (erfi, Complex, ::erfi);
+      ARRAY_MAPPER (dawson, Complex, ::dawson);
       ARRAY_MAPPER (ceil, Complex, ::ceil);
       ARRAY_MAPPER (cos, Complex, std::cos);
       ARRAY_MAPPER (cosh, Complex, std::cosh);
       ARRAY_MAPPER (exp, Complex, std::exp);
       ARRAY_MAPPER (expm1, Complex, ::expm1);
       ARRAY_MAPPER (fix, Complex, ::fix);
       ARRAY_MAPPER (floor, Complex, ::floor);
       ARRAY_MAPPER (log, Complex, std::log);
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -898,16 +898,21 @@ octave_sparse_complex_matrix::map (unary
       ARRAY_MAPPER (acos, Complex, ::acos);
       ARRAY_MAPPER (acosh, Complex, ::acosh);
       ARRAY_MAPPER (angle, double, std::arg);
       ARRAY_MAPPER (arg, double, std::arg);
       ARRAY_MAPPER (asin, Complex, ::asin);
       ARRAY_MAPPER (asinh, Complex, ::asinh);
       ARRAY_MAPPER (atan, Complex, ::atan);
       ARRAY_MAPPER (atanh, Complex, ::atanh);
+      ARRAY_MAPPER (erf, Complex, ::erf);
+      ARRAY_MAPPER (erfc, Complex, ::erfc);
+      ARRAY_MAPPER (erfcx, Complex, ::erfcx);
+      ARRAY_MAPPER (erfi, Complex, ::erfi);
+      ARRAY_MAPPER (dawson, Complex, ::dawson);
       ARRAY_MAPPER (ceil, Complex, ::ceil);
       ARRAY_MAPPER (conj, Complex, std::conj<double>);
       ARRAY_MAPPER (cos, Complex, std::cos);
       ARRAY_MAPPER (cosh, Complex, std::cosh);
       ARRAY_MAPPER (exp, Complex, std::exp);
       ARRAY_MAPPER (expm1, Complex, ::expm1);
       ARRAY_MAPPER (fix, Complex, ::fix);
       ARRAY_MAPPER (floor, Complex, ::floor);
diff --git a/libinterp/octave-value/ov-float.cc b/libinterp/octave-value/ov-float.cc
--- a/libinterp/octave-value/ov-float.cc
+++ b/libinterp/octave-value/ov-float.cc
@@ -290,16 +290,18 @@ octave_float_scalar::map (unary_mapper_t
       SCALAR_MAPPER (asinh, ::asinhf);
       SCALAR_MAPPER (atan, ::atanf);
       SCALAR_MAPPER (atanh, rc_atanh);
       SCALAR_MAPPER (erf, ::erff);
       SCALAR_MAPPER (erfinv, ::erfinv);
       SCALAR_MAPPER (erfcinv, ::erfcinv);
       SCALAR_MAPPER (erfc, ::erfcf);
       SCALAR_MAPPER (erfcx, ::erfcx);
+      SCALAR_MAPPER (erfi, ::erfi);
+      SCALAR_MAPPER (dawson, ::dawson);
       SCALAR_MAPPER (gamma, xgamma);
       SCALAR_MAPPER (lgamma, rc_lgamma);
       SCALAR_MAPPER (cbrt, ::cbrtf);
       SCALAR_MAPPER (ceil, ::ceilf);
       SCALAR_MAPPER (cos, ::cosf);
       SCALAR_MAPPER (cosh, ::coshf);
       SCALAR_MAPPER (exp, ::expf);
       SCALAR_MAPPER (expm1, ::expm1f);
diff --git a/libinterp/octave-value/ov-flt-complex.cc b/libinterp/octave-value/ov-flt-complex.cc
--- a/libinterp/octave-value/ov-flt-complex.cc
+++ b/libinterp/octave-value/ov-flt-complex.cc
@@ -411,16 +411,21 @@ octave_float_complex::map (unary_mapper_
       SCALAR_MAPPER (acos, ::acos);
       SCALAR_MAPPER (acosh, ::acosh);
       SCALAR_MAPPER (angle, std::arg);
       SCALAR_MAPPER (arg, std::arg);
       SCALAR_MAPPER (asin, ::asin);
       SCALAR_MAPPER (asinh, ::asinh);
       SCALAR_MAPPER (atan, ::atan);
       SCALAR_MAPPER (atanh, ::atanh);
+      SCALAR_MAPPER (erf, ::erf);
+      SCALAR_MAPPER (erfc, ::erfc);
+      SCALAR_MAPPER (erfcx, ::erfcx);
+      SCALAR_MAPPER (erfi, ::erfi);
+      SCALAR_MAPPER (dawson, ::dawson);
       SCALAR_MAPPER (ceil, ::ceil);
       SCALAR_MAPPER (conj, std::conj);
       SCALAR_MAPPER (cos, std::cos);
       SCALAR_MAPPER (cosh, std::cosh);
       SCALAR_MAPPER (exp, std::exp);
       SCALAR_MAPPER (expm1, ::expm1);
       SCALAR_MAPPER (fix, ::fix);
       SCALAR_MAPPER (floor, ::floor);
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -739,16 +739,21 @@ octave_float_complex_matrix::map (unary_
       ARRAY_MAPPER (acos, FloatComplex, ::acos);
       ARRAY_MAPPER (acosh, FloatComplex, ::acosh);
       ARRAY_MAPPER (angle, float, std::arg);
       ARRAY_MAPPER (arg, float, std::arg);
       ARRAY_MAPPER (asin, FloatComplex, ::asin);
       ARRAY_MAPPER (asinh, FloatComplex, ::asinh);
       ARRAY_MAPPER (atan, FloatComplex, ::atan);
       ARRAY_MAPPER (atanh, FloatComplex, ::atanh);
+      ARRAY_MAPPER (erf, FloatComplex, ::erf);
+      ARRAY_MAPPER (erfc, FloatComplex, ::erfc);
+      ARRAY_MAPPER (erfcx, FloatComplex, ::erfcx);
+      ARRAY_MAPPER (erfi, FloatComplex, ::erfi);
+      ARRAY_MAPPER (dawson, FloatComplex, ::dawson);
       ARRAY_MAPPER (ceil, FloatComplex, ::ceil);
       ARRAY_MAPPER (cos, FloatComplex, std::cos);
       ARRAY_MAPPER (cosh, FloatComplex, std::cosh);
       ARRAY_MAPPER (exp, FloatComplex, std::exp);
       ARRAY_MAPPER (expm1, FloatComplex, ::expm1);
       ARRAY_MAPPER (fix, FloatComplex, ::fix);
       ARRAY_MAPPER (floor, FloatComplex, ::floor);
       ARRAY_MAPPER (log, FloatComplex, std::log);
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -778,16 +778,18 @@ octave_float_matrix::map (unary_mapper_t
       ARRAY_MAPPER (asinh, float, ::asinhf);
       ARRAY_MAPPER (atan, float, ::atanf);
       RC_ARRAY_MAPPER (atanh, FloatComplex, rc_atanh);
       ARRAY_MAPPER (erf, float, ::erff);
       ARRAY_MAPPER (erfinv, float, ::erfinv);
       ARRAY_MAPPER (erfcinv, float, ::erfcinv);
       ARRAY_MAPPER (erfc, float, ::erfcf);
       ARRAY_MAPPER (erfcx, float, ::erfcx);
+      ARRAY_MAPPER (erfi, float, ::erfi);
+      ARRAY_MAPPER (dawson, float, ::dawson);
       ARRAY_MAPPER (gamma, float, xgamma);
       RC_ARRAY_MAPPER (lgamma, FloatComplex, rc_lgamma);
       ARRAY_MAPPER (cbrt, float, ::cbrtf);
       ARRAY_MAPPER (ceil, float, ::ceilf);
       ARRAY_MAPPER (cos, float, ::cosf);
       ARRAY_MAPPER (cosh, float, ::coshf);
       ARRAY_MAPPER (exp, float, ::expf);
       ARRAY_MAPPER (expm1, float, ::expm1f);
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
new file mode 100644
--- /dev/null
+++ b/libinterp/octave-value/ov-java.cc
@@ -0,0 +1,2311 @@
+/*
+
+Copyright (C) 2007 Michael Goffioul
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "defun.h"
+#include "error.h"
+
+#if defined HAVE_JAVA
+
+#if defined (HAVE_WINDOWS_H)
+#include <windows.h>
+#endif
+
+#include <algorithm>
+#include <map>
+#include <iostream>
+#include <fstream>
+
+#include <clocale>
+
+#include "Cell.h"
+#include "cmd-edit.h"
+#include "defaults.h"
+#include "file-ops.h"
+#include "file-stat.h"
+#include "load-path.h"
+#include "oct-env.h"
+#include "oct-shlib.h"
+#include "ov-java.h"
+#include "parse.h"
+#include "variables.h"
+
+typedef jint (JNICALL *JNI_CreateJavaVM_t) (JavaVM **pvm, JNIEnv **penv, void *args);
+typedef jint (JNICALL *JNI_GetCreatedJavaVMs_t) (JavaVM **pvm, jsize bufLen, jsize *nVMs);
+
+extern "C"
+{
+  JNIEXPORT jboolean JNICALL
+  Java_org_octave_Octave_call (JNIEnv *, jclass, jstring, jobjectArray,
+                               jobjectArray);
+  JNIEXPORT void JNICALL
+  Java_org_octave_OctaveReference_doFinalize (JNIEnv *, jclass, jint);
+
+  JNIEXPORT void JNICALL
+  Java_org_octave_Octave_doInvoke (JNIEnv *, jclass, jint, jobjectArray);
+
+  JNIEXPORT void JNICALL
+  Java_org_octave_Octave_doEvalString (JNIEnv *, jclass, jstring);
+
+  JNIEXPORT jboolean JNICALL
+  Java_org_octave_Octave_needThreadedInvokation (JNIEnv *, jclass);
+}
+
+static JavaVM *jvm = 0;
+static bool jvm_attached = false;
+
+// Need to keep hold of the shared library handle until exit.
+static octave_shlib jvm_lib;
+
+static std::map<int,octave_value> listener_map;
+static std::map<int,octave_value> octave_ref_map;
+static int octave_java_refcount = 0;
+static long octave_thread_ID = -1;
+
+bool Vjava_matrix_autoconversion = false;
+bool Vjava_unsigned_autoconversion = true;
+bool Vdebug_java = false;
+
+class JVMArgs
+{
+public:
+
+  JVMArgs (void)
+  {
+    vm_args.version = JNI_VERSION_1_2;
+    vm_args.nOptions = 0;
+    vm_args.options = 0;
+    vm_args.ignoreUnrecognized = false;
+  }
+
+  ~JVMArgs (void)
+  {
+    clean ();
+  }
+
+  JavaVMInitArgs* to_args ()
+  {
+    update ();
+    return &vm_args;
+  }
+
+  void add (const std::string& opt)
+  {
+    java_opts.push_back (opt);
+  }
+
+  void read_java_opts (const std::string& filename)
+  {
+    std::ifstream js (filename.c_str ());
+
+    if (! js.bad () && ! js.fail ())
+      {
+        std::string line;
+
+        while (! js.eof () && ! js.fail ())
+          {
+            std::getline (js, line);
+            if (line.length () > 2
+                && (line.find ("-D") == 0 || line.find ("-X") == 0))
+              java_opts.push_back (line);
+            else if (line.length () > 0 && Vdebug_java)
+              std::cerr << "invalid JVM option, skipping: " << line << std::endl;
+          }
+      }
+  }
+
+private:
+
+  void clean (void)
+  {
+    if (vm_args.options != 0)
+      {
+        for (int i = 0; i < vm_args.nOptions; i++)
+          delete [] vm_args.options[i].optionString;
+        delete [] vm_args.options;
+
+        vm_args.options = 0;
+        vm_args.nOptions = 0;
+      }
+  }
+
+  void update (void)
+  {
+    clean ();
+
+    if (java_opts.size () > 0)
+      {
+        int index = 0;
+
+        vm_args.nOptions = java_opts.size ();
+        vm_args.options = new JavaVMOption [vm_args.nOptions];
+        for (std::list<std::string>::const_iterator it = java_opts.begin (); it != java_opts.end (); ++it)
+          {
+            if (Vdebug_java)
+              std::cout << *it << std::endl;
+            vm_args.options[index++].optionString = strsave ((*it).c_str ());
+          }
+        java_opts.clear ();
+      }
+  }
+
+private:
+
+  JavaVMInitArgs vm_args;
+
+  std::list<std::string> java_opts;
+};
+
+static dim_vector compute_array_dimensions (JNIEnv* jni_env, jobject obj);
+
+#ifdef __WIN32__
+static std::string
+read_registry_string (const std::string& key, const std::string& value)
+{
+  HKEY hkey;
+  DWORD len;
+
+  std::string retval;
+
+  if (! RegOpenKeyEx (HKEY_LOCAL_MACHINE, key.c_str (), 0, KEY_READ, &hkey))
+    {
+      if (! RegQueryValueEx (hkey, value.c_str (), 0, 0, 0, &len))
+        {
+          retval.resize (len);
+          if (RegQueryValueEx (hkey, value.c_str (), 0, 0, (LPBYTE)&retval[0], &len))
+            retval = "";
+          else if (retval[len-1] == '\0')
+            retval.resize (--len);
+        }
+      RegCloseKey (hkey);
+    }
+
+  return retval;
+}
+
+static std::string
+get_module_filename (HMODULE hMod)
+{
+  int n = 1024;
+  std::string retval (n, '\0');
+  bool found = false;
+
+  while (n < 65536)
+    {
+      int status = GetModuleFileName(hMod, &retval[0], n);
+
+      if (status < n)
+        {
+          retval.resize (n);
+          found = true;
+          break;
+        }
+      else
+        {
+          n *= 2;
+          retval.resize (n);
+        }
+    }
+  return (found ? retval : "");
+}
+
+static void
+set_dll_directory (const std::string& dir = "")
+{
+  typedef BOOL (WINAPI *dllfcn_t) (LPCTSTR path);
+
+  static dllfcn_t dllfcn = NULL;
+  static bool first = true;
+
+  if (! dllfcn && first)
+    {
+      HINSTANCE hKernel32 = GetModuleHandle ("kernel32");
+      dllfcn = reinterpret_cast<dllfcn_t> (GetProcAddress (hKernel32, "SetDllDirectoryA"));
+      first = false;
+    }
+
+  if (dllfcn)
+    dllfcn (dir.empty () ? NULL : dir.c_str ());
+}
+#endif
+
+static std::string
+initial_java_dir (void)
+{
+  static std::string java_dir;
+
+  if (java_dir.empty ())
+    {
+      java_dir = octave_env::getenv ("OCTAVE_JAVA_DIR");
+
+      if (java_dir.empty ())
+        java_dir = Vfcn_file_dir + file_ops::dir_sep_str () + "java";
+    }
+
+  return java_dir;
+}
+
+// Read the content of a file filename (usually "classpath.txt")
+//
+// Returns a string with all lines concatenated and separated
+// by the path separator character.
+// The return string also starts with a path separator so that
+// it can be appended easily to a base classpath.
+//
+// The file "classpath.txt" must contain single lines, each
+// with a classpath.
+// Comment lines starting with a '#' or a '%' in column 1 are allowed.
+
+static std::string
+read_classpath_txt (const std::string& filepath)
+{
+  std::string classpath;
+
+  std::ifstream fs (filepath.c_str ());
+
+  if (! fs.bad () && ! fs.fail ())
+    {
+      std::string line;
+
+      while (! fs.eof () && ! fs.fail ())
+        {
+          std::getline (fs, line);
+
+          if (line.length () > 0)
+            {
+              if (line[0] == '#' || line[0] == '%')
+                ; // skip comments
+              else
+                {
+                  // prepend separator character
+                  classpath.append (dir_path::path_sep_str ());
+
+                  // append content of line without whitespace
+                  int last = line.find_last_not_of (" \t\f\v\r\n");
+
+                  classpath.append (file_ops::tilde_expand (line.substr (0, last+1)));
+                }
+            }
+        }
+    }
+
+  return (classpath);
+}
+
+static std::string
+initial_class_path (void)
+{
+  std::string java_dir = initial_java_dir ();
+
+  std::string retval = java_dir;
+
+  // find octave.jar file
+  if (! retval.empty ())
+    {
+      std::string sep = file_ops::dir_sep_str ();
+
+      std::string jar_file = java_dir + sep + "octave.jar";
+
+      file_stat jar_exists (jar_file);
+
+      if (jar_exists)
+        {
+          // initialize static classpath to octave.jar
+          retval = jar_file;
+
+          // The base classpath has been set.
+          // Try to find an optional file specifying classpaths in 3 places.
+          // 1) Current directory
+          // 2) User's home directory
+          // 3) Octave installation directory where octave.jar resides
+
+          // The filename is "javaclasspath.txt", but historically
+          // has been "classpath.txt" so both are supported.
+          std::string cp_list[] = {"javaclasspath.txt", "classpath.txt"};
+
+          for (int i=0; i<2; i++)
+            {
+              std::string filename = cp_list[i];
+              std::string cp_file = filename;
+              file_stat   cp_exists;
+
+              // Try to find classpath file in the current directory.
+
+              cp_exists = file_stat (cp_file);
+              if (cp_exists)
+                {
+                  // File found.  Add its contents to the static classpath.
+                  std::string classpath = read_classpath_txt (cp_file);
+                  retval.append (classpath);
+                }
+
+              // Try to find classpath file in the user's home directory.
+
+              cp_file = "~" + sep + filename;
+              cp_file = file_ops::tilde_expand (cp_file);
+              cp_exists = file_stat (cp_file);
+              if (cp_exists)
+                {
+                  // File found.  Add its contents to the static classpath.
+                  std::string classpath = read_classpath_txt (cp_file);
+                  retval.append (classpath);
+                }
+
+              // Try to find classpath file in the Octave install directory.
+
+              cp_file = java_dir + sep + filename;
+              cp_exists = file_stat (cp_file);
+              if (cp_exists)
+                {
+                  // File found.  Add its contents to the static classpath.
+                  std::string classpath = read_classpath_txt (cp_file);
+                  retval.append (classpath);
+                }
+            }
+        }
+      else
+        throw std::string ("octave.jar does not exist: ") + jar_file;
+    }
+  else
+    throw std::string ("initial java dir is empty");
+
+  return retval;
+}
+
+static void
+initialize_jvm (void)
+{
+  // Most of the time JVM already exists and has been initialized.
+  if (jvm)
+    return;
+
+  JNIEnv *current_env;
+  const char *static_locale = setlocale (LC_ALL, NULL);
+  const std::string locale (static_locale);
+
+#if defined (__WIN32__)
+
+  HMODULE hMod = GetModuleHandle ("jvm.dll");
+  std::string jvm_lib_path;
+  std::string old_cwd;
+
+  if (hMod == NULL)
+    {
+      // In windows, find the location of the JRE from the registry
+      // and load the symbol from the dll.
+      std::string key, value;
+
+      key = "software\\javasoft\\java runtime environment";
+
+      value = octave_env::getenv ("JAVA_VERSION");
+      if (value.empty ())
+        {
+          value = "Currentversion";
+          std::string regval = read_registry_string (key,value);
+
+          if (regval.empty ())
+            throw std::string ("unable to find Java Runtime Environment: ") + key + "::" + value;
+          value = regval;
+        }
+
+      key = key + "\\" + value;
+      value = "RuntimeLib";
+      jvm_lib_path = read_registry_string (key, value);
+      if (jvm_lib_path.empty ())
+        throw std::string ("unable to find Java Runtime Environment: ") + key + "::" + value;
+
+      std::string jvm_bin_path;
+
+      value = "JavaHome";
+      jvm_bin_path = read_registry_string (key, value);
+      if (! jvm_bin_path.empty ())
+        {
+          jvm_bin_path = (jvm_bin_path + std::string ("\\bin"));
+
+          old_cwd = octave_env::get_current_directory ();
+
+          set_dll_directory (jvm_bin_path);
+          octave_env::chdir (jvm_bin_path);
+        }
+    }
+  else
+    {
+      // JVM seems to be already loaded, better to use that DLL instead
+      // of looking in the registry, to avoid opening a different JVM.
+      jvm_lib_path = get_module_filename (hMod);
+
+      if (jvm_lib_path.empty ())
+        throw std::string ("unable to find Java Runtime Environment");
+    }
+
+#else  // Not Win32 system
+
+  // JAVA_LDPATH determined by configure and set in config.h
+#if defined (__APPLE__)
+  std::string jvm_lib_path = JAVA_LDPATH + std::string ("/libjvm.dylib");
+#else
+  std::string jvm_lib_path = JAVA_LDPATH + std::string ("/libjvm.so");
+#endif
+
+#endif
+
+  jsize nVMs = 0;
+
+# if !defined (__APPLE__) && !defined (__MACH__)
+
+  octave_shlib lib (jvm_lib_path);
+
+  if (!lib)
+    throw std::string ("unable to load Java Runtime Environment from ") + jvm_lib_path;
+
+#if defined (__WIN32__)
+
+  set_dll_directory ();
+
+  if (! old_cwd.empty ())
+    octave_env::chdir (old_cwd);
+
+#endif
+
+  JNI_CreateJavaVM_t create_vm = reinterpret_cast<JNI_CreateJavaVM_t> (lib.search ("JNI_CreateJavaVM"));
+  JNI_GetCreatedJavaVMs_t get_vm = reinterpret_cast<JNI_GetCreatedJavaVMs_t> (lib.search ("JNI_GetCreatedJavaVMs"));
+
+  if (!create_vm)
+    throw std::string ("unable to find JNI_CreateJavaVM in ") + jvm_lib_path;
+
+  if (!get_vm)
+    throw std::string ("unable to find JNI_GetCreatedJavaVMs in ") + jvm_lib_path;
+
+  if (get_vm (&jvm, 1, &nVMs) == 0 && nVMs > 0)
+
+#else
+
+  // FIXME: There exists a problem on the Mac platform that
+  //   octave_shlib lib (jvm_lib_path)
+  // doesn't work with 'not-bundled' *.oct files.
+
+  if (JNI_GetCreatedJavaVMs (&jvm, 1, &nVMs) == 0 && nVMs > 0)
+
+#endif
+
+    {
+      // At least one JVM exists, try to attach to it
+
+      switch (jvm->GetEnv (reinterpret_cast<void **> (&current_env), JNI_VERSION_1_2))
+        {
+        case JNI_EDETACHED:
+          // Attach the current thread
+          JavaVMAttachArgs vm_args;
+          vm_args.version = JNI_VERSION_1_2;
+          vm_args.name = const_cast<char *> ("octave");
+          vm_args.group = NULL;
+          if (jvm->AttachCurrentThread (reinterpret_cast<void **> (&current_env), &vm_args) < 0)
+            throw std::string ("JVM internal error, unable to attach octave to existing JVM");
+          break;
+
+        case JNI_EVERSION:
+          throw std::string ("JVM internal error, the required JNI version is not supported");
+          break;
+
+        case JNI_OK:
+          // Don't do anything, the current thread is already attached to JVM
+          break;
+        }
+
+      jvm_attached = true;
+      //printf ("JVM attached\n");
+    }
+  else
+    {
+      // No JVM exists, create one
+
+      JVMArgs vm_args;
+
+      vm_args.add ("-Djava.class.path=" + initial_class_path ());
+      vm_args.add ("-Xrs");
+      vm_args.add ("-Djava.system.class.loader=org.octave.OctClassLoader");
+      vm_args.read_java_opts (initial_java_dir () + file_ops::dir_sep_str () + "java.opts");
+
+# if !defined (__APPLE__) && !defined (__MACH__)
+
+      if (create_vm (&jvm, &current_env, vm_args.to_args ()) != JNI_OK)
+        throw std::string ("unable to start Java VM in ")+jvm_lib_path;
+      //printf ("JVM created\n");
+    }
+
+  jvm_lib = lib;
+
+#else
+
+      if (JNI_CreateJavaVM (&jvm, reinterpret_cast<void **> (&current_env),
+                            vm_args.to_args ()) != JNI_OK)
+        throw std::string ("unable to start Java VM in ")+jvm_lib_path;
+
+    }
+
+#endif
+
+  setlocale (LC_ALL, locale.c_str ());
+}
+
+static void
+terminate_jvm (void)
+{
+  if (jvm)
+    {
+      if (jvm_attached)
+        jvm->DetachCurrentThread ();
+      else
+        jvm->DestroyJavaVM ();
+
+      jvm = 0;
+      jvm_attached = false;
+
+      if (jvm_lib)
+        jvm_lib.close ();
+    }
+}
+
+std::string
+jstring_to_string (JNIEnv* jni_env, jstring s)
+{
+  std::string retval;
+
+  if (jni_env)
+    {
+      const char *cstr = jni_env->GetStringUTFChars (s, 0);
+      retval = cstr;
+      jni_env->ReleaseStringUTFChars (s, cstr);
+    }
+
+  return retval;
+}
+
+std::string
+jstring_to_string (JNIEnv* jni_env, jobject obj)
+{
+  std::string retval;
+
+  if (jni_env && obj)
+    {
+      jclass_ref cls (jni_env, jni_env->FindClass ("java/lang/String"));
+      if (cls)
+        {
+          if (jni_env->IsInstanceOf (obj, cls))
+            retval = jstring_to_string (jni_env, reinterpret_cast<jstring> (obj));
+        }
+    }
+
+  return retval;
+}
+
+bool
+octave_java::is_java_string (void) const
+{
+  JNIEnv *current_env = thread_jni_env ();
+
+  if (current_env && java_object)
+    {
+      jclass_ref cls (current_env, current_env->FindClass ("java/lang/String"));
+      return current_env->IsInstanceOf (java_object, cls);
+    }
+
+  return false;
+}
+
+static octave_value
+check_exception (JNIEnv* jni_env)
+{
+  octave_value retval;
+
+  jthrowable_ref ex (jni_env, jni_env->ExceptionOccurred ());
+
+  if (ex)
+    {
+      if (Vdebug_java)
+        jni_env->ExceptionDescribe ();
+
+      jni_env->ExceptionClear ();
+
+      jclass_ref jcls (jni_env, jni_env->GetObjectClass (ex));
+      jmethodID mID = jni_env->GetMethodID (jcls, "toString", "()Ljava/lang/String;");
+      jstring_ref js (jni_env, reinterpret_cast<jstring> (jni_env->CallObjectMethod (ex, mID)));
+      std::string msg = jstring_to_string (jni_env, js);
+
+      error ("[java] %s", msg.c_str ());
+    }
+  else
+    retval = Matrix ();
+
+  return retval;
+}
+
+static jclass
+find_octave_class (JNIEnv *jni_env, const char *name)
+{
+  static std::string class_loader;
+  static jclass uiClass = 0;
+
+  jclass jcls = jni_env->FindClass (name);
+
+  if (jcls == 0)
+    {
+      jni_env->ExceptionClear ();
+
+      if (! uiClass)
+        {
+          if (class_loader.empty ())
+            {
+              jclass_ref syscls (jni_env, jni_env->FindClass ("java/lang/System"));
+              jmethodID mID = jni_env->GetStaticMethodID (syscls, "getProperty", "(Ljava/lang/String;)Ljava/lang/String;");
+              jstring_ref js (jni_env, jni_env->NewStringUTF ("octave.class.loader"));
+              js = reinterpret_cast<jstring> (jni_env->CallStaticObjectMethod (syscls, mID, jstring (js)));
+              class_loader = jstring_to_string (jni_env, jstring (js));
+              std::replace (class_loader.begin (), class_loader.end (), '.', '/');
+            }
+
+          jclass_ref uicls (jni_env, jni_env->FindClass (class_loader.c_str ()));
+
+          if (! uicls)
+            {
+              jni_env->ExceptionClear ();
+
+              /* Try the netbeans way */
+              std::replace (class_loader.begin (), class_loader.end (), '/', '.');
+              jclass_ref jcls2 (jni_env, jni_env->FindClass ("org/openide/util/Lookup"));
+              jmethodID mID = jni_env->GetStaticMethodID (jcls2, "getDefault", "()Lorg/openide/util/Lookup;");
+              jobject_ref lObj (jni_env, jni_env->CallStaticObjectMethod (jcls2, mID));
+              mID = jni_env->GetMethodID (jcls2, "lookup", "(Ljava/lang/Class;)Ljava/lang/Object;");
+              jclass_ref cLoaderCls (jni_env, jni_env->FindClass ("java/lang/ClassLoader"));
+              jobject_ref cLoader (jni_env, jni_env->CallObjectMethod (lObj, mID, jclass (cLoaderCls)));
+              mID = jni_env->GetMethodID (cLoaderCls, "loadClass", "(Ljava/lang/String;)Ljava/lang/Class;");
+              jstring_ref js (jni_env, jni_env->NewStringUTF (class_loader.c_str ()));
+              uicls = reinterpret_cast<jclass> (jni_env->CallObjectMethod (cLoader, mID, jstring (js)));
+            }
+
+          if (uicls)
+            uiClass = reinterpret_cast<jclass> (jni_env->NewGlobalRef (jclass (uicls)));
+        }
+
+      if (uiClass)
+        {
+          jmethodID mID = jni_env->GetStaticMethodID (uiClass, "findClass", "(Ljava/lang/String;)Ljava/lang/Class;");
+          jstring_ref js (jni_env, jni_env->NewStringUTF (name));
+          jcls = reinterpret_cast<jclass> (jni_env->CallStaticObjectMethod (uiClass, mID, jstring (js)));
+        }
+    }
+
+  return jcls;
+}
+
+static dim_vector
+compute_array_dimensions (JNIEnv* jni_env, jobject obj)
+{
+  jobjectArray_ref jobj (jni_env, reinterpret_cast<jobjectArray> (obj));
+  jclass_ref jcls (jni_env, jni_env->GetObjectClass (obj));
+  jclass_ref ccls (jni_env, jni_env->GetObjectClass (jcls));
+  jmethodID isArray_ID = jni_env->GetMethodID (ccls, "isArray", "()Z"),
+            getComponentType_ID = jni_env->GetMethodID (ccls, "getComponentType", "()Ljava/lang/Class;");
+
+  dim_vector dv (1, 1);
+  int idx = 0;
+
+  jobj.detach ();
+  while (jcls && jni_env->CallBooleanMethod (jcls, isArray_ID))
+    {
+      int len = (jobj ? jni_env->GetArrayLength (jobj) : 0);
+      if (idx >= dv.length ())
+        dv.resize (idx+1);
+      dv(idx) = len;
+      jcls = reinterpret_cast<jclass> (jni_env->CallObjectMethod (jcls, getComponentType_ID));
+      jobj = (len > 0 ? reinterpret_cast<jobjectArray> (jni_env->GetObjectArrayElement (jobj, 0)) : 0);
+      idx++;
+    }
+
+  return dv;
+}
+
+static jobject
+make_java_index (JNIEnv* jni_env, const octave_value_list& idx)
+{
+  jclass_ref ocls (jni_env, jni_env->FindClass ("[I"));
+  jobjectArray retval = jni_env->NewObjectArray (idx.length (), ocls, 0);
+
+  for (int i = 0; i < idx.length (); i++)
+    {
+      idx_vector v = idx(i).index_vector ();
+
+      if (! error_state)
+        {
+          jintArray_ref i_array (jni_env, jni_env->NewIntArray (v.length ()));
+          jint *buf = jni_env->GetIntArrayElements (i_array, 0);
+
+          for (int k = 0; k < v.length (); k++)
+            buf[k] = v(k);
+
+          jni_env->ReleaseIntArrayElements (i_array, buf, 0);
+          jni_env->SetObjectArrayElement (retval, i, i_array);
+
+          check_exception (jni_env);
+
+          if (error_state)
+            break;
+        }
+      else
+        break;
+    }
+
+  return retval;
+}
+
+static octave_value
+get_array_elements (JNIEnv* jni_env, jobject jobj,
+                    const octave_value_list& idx)
+{
+  octave_value retval;
+  jobject_ref resObj (jni_env);
+  jobject_ref java_idx (jni_env, make_java_index (jni_env, idx));
+
+  if (! error_state)
+    {
+      jclass_ref helperClass (jni_env, find_octave_class (jni_env, "org/octave/ClassHelper"));
+      jmethodID mID = jni_env->GetStaticMethodID (helperClass, "arraySubsref", "(Ljava/lang/Object;[[I)Ljava/lang/Object;");
+      resObj = jni_env->CallStaticObjectMethod (helperClass, mID, jobj, jobject (java_idx));
+    }
+
+  if (resObj)
+    retval = box (jni_env, resObj);
+  else
+    retval = check_exception (jni_env);
+
+  return retval;
+}
+
+static octave_value
+set_array_elements (JNIEnv* jni_env, jobject jobj,
+                    const octave_value_list& idx, const octave_value& rhs)
+{
+  octave_value retval;
+
+  jclass_ref rhsCls (jni_env);
+  jobject_ref resObj (jni_env), rhsObj (jni_env);
+  jobject_ref java_idx (jni_env, make_java_index (jni_env, idx));
+
+  if (! error_state && unbox (jni_env, rhs, rhsObj, rhsCls))
+    {
+      jclass_ref helperClass (jni_env, find_octave_class (jni_env, "org/octave/ClassHelper"));
+      jmethodID mID = jni_env->GetStaticMethodID (helperClass, "arraySubsasgn",
+          "(Ljava/lang/Object;[[ILjava/lang/Object;)Ljava/lang/Object;");
+      resObj = jni_env->CallStaticObjectMethod (helperClass, mID,
+          jobj, jobject (java_idx), jobject (rhsObj));
+    }
+
+  if (resObj)
+    retval = box (jni_env, resObj);
+  else
+    retval = check_exception (jni_env);
+
+  return retval;
+}
+
+static string_vector
+get_invoke_list (JNIEnv* jni_env, jobject jobj)
+{
+  std::list<std::string> name_list;
+
+  if (jni_env)
+    {
+      jclass_ref cls (jni_env, jni_env->GetObjectClass (jobj));
+      jclass_ref ccls (jni_env, jni_env->GetObjectClass (cls));
+      jmethodID getMethods_ID = jni_env->GetMethodID (ccls, "getMethods", "()[Ljava/lang/reflect/Method;"),
+        getFields_ID = jni_env->GetMethodID (ccls, "getFields", "()[Ljava/lang/reflect/Field;");
+      jobjectArray_ref mList (jni_env, reinterpret_cast<jobjectArray> (jni_env->CallObjectMethod (cls, getMethods_ID))),
+        fList (jni_env, reinterpret_cast<jobjectArray> (jni_env->CallObjectMethod (cls, getFields_ID)));
+      int mLen = jni_env->GetArrayLength (mList), fLen = jni_env->GetArrayLength (fList);
+      jclass_ref mCls (jni_env, jni_env->FindClass ("java/lang/reflect/Method")),
+        fCls (jni_env, jni_env->FindClass ("java/lang/reflect/Field"));
+      jmethodID m_getName_ID = jni_env->GetMethodID (mCls, "getName", "()Ljava/lang/String;"),
+        f_getName_ID = jni_env->GetMethodID (fCls, "getName", "()Ljava/lang/String;");
+
+      for (int i = 0; i < mLen; i++)
+        {
+          jobject_ref meth (jni_env, jni_env->GetObjectArrayElement (mList, i));
+          jstring_ref methName (jni_env, reinterpret_cast<jstring> (jni_env->CallObjectMethod (meth, m_getName_ID)));
+          name_list.push_back (jstring_to_string (jni_env, methName));
+        }
+
+      for (int i = 0; i < fLen; i++)
+        {
+          jobject_ref field (jni_env, jni_env->GetObjectArrayElement (fList, i));
+          jstring_ref fieldName (jni_env, reinterpret_cast<jstring> (jni_env->CallObjectMethod (field, f_getName_ID)));
+          name_list.push_back (jstring_to_string (jni_env, fieldName));
+        }
+    }
+
+  string_vector v (name_list);
+
+  return v.sort (true);
+}
+
+static octave_value
+convert_to_string (JNIEnv *jni_env, jobject java_object, bool force, char type)
+{
+  octave_value retval;
+
+  if (jni_env && java_object)
+    {
+      jclass_ref cls (jni_env, jni_env->FindClass ("java/lang/String"));
+
+      if (jni_env->IsInstanceOf (java_object, cls))
+        retval = octave_value (jstring_to_string (jni_env, java_object), type);
+      else if (force)
+        {
+          cls = jni_env->FindClass ("[Ljava/lang/String;");
+
+          if (jni_env->IsInstanceOf (java_object, cls))
+            {
+              jobjectArray array = reinterpret_cast<jobjectArray> (java_object);
+              int len = jni_env->GetArrayLength (array);
+              Cell c (len, 1);
+
+              for (int i = 0; i < len; i++)
+                {
+                  jstring_ref js (jni_env, reinterpret_cast<jstring> (jni_env->GetObjectArrayElement (array, i)));
+
+                  if (js)
+                    c(i) = octave_value (jstring_to_string (jni_env, js), type);
+                  else
+                    {
+                      c(i) = check_exception (jni_env);
+
+                      if (error_state)
+                        break;
+                    }
+                }
+
+              retval = octave_value (c);
+            }
+          else
+            {
+              cls = jni_env->FindClass ("java/lang/Object");
+              jmethodID mID = jni_env->GetMethodID (cls, "toString", "()Ljava/lang/String;");
+              jstring_ref js (jni_env, reinterpret_cast<jstring> (jni_env->CallObjectMethod (java_object, mID)));
+
+              if (js)
+                retval = octave_value (jstring_to_string (jni_env, js), type);
+              else
+                retval = check_exception (jni_env);
+            }
+        }
+      else
+        error ("unable to convert Java object to string");
+    }
+
+  return retval;
+}
+
+#define TO_JAVA(obj) dynamic_cast<octave_java*> ((obj).internal_rep ())
+
+octave_value
+box (JNIEnv* jni_env, jobject jobj, jclass jcls)
+{
+  octave_value retval;
+  jclass_ref cls (jni_env);
+
+  if (! jobj)
+    retval = Matrix ();
+
+  while (retval.is_undefined ())
+    {
+      // Convert a scalar of any numeric class (byte, short, integer, long,
+      // float, double) to a double value.  Matlab does the same thing.
+      cls = jni_env->FindClass ("java/lang/Number");
+      if (jni_env->IsInstanceOf (jobj, cls))
+        {
+          jmethodID m = jni_env->GetMethodID (cls, "doubleValue", "()D");
+          retval = jni_env->CallDoubleMethod (jobj, m);
+          break;
+        }
+
+      cls = jni_env->FindClass ("java/lang/Boolean");
+      if (jni_env->IsInstanceOf (jobj, cls))
+        {
+          jmethodID m = jni_env->GetMethodID (cls, "booleanValue", "()Z");
+          retval = (jni_env->CallBooleanMethod (jobj, m) ? true : false);
+          break;
+        }
+
+      cls = jni_env->FindClass ("java/lang/String");
+      if (jni_env->IsInstanceOf (jobj, cls))
+        {
+          retval = jstring_to_string (jni_env, jobj);
+          break;
+        }
+
+      cls = jni_env->FindClass ("java/lang/Character");
+      if (jni_env->IsInstanceOf (jobj, cls))
+        {
+          jmethodID m = jni_env->GetMethodID (cls, "charValue", "()C");
+          retval = jni_env->CallCharMethod (jobj, m);
+          retval = retval.convert_to_str (false, true); 
+          break;
+        }
+
+      if (Vjava_matrix_autoconversion)
+        {
+          cls = find_octave_class (jni_env, "org/octave/Matrix");
+
+          if (jni_env->IsInstanceOf (jobj, cls))
+            {
+              jmethodID mID = jni_env->GetMethodID (cls, "getDims", "()[I");
+              jintArray_ref iv (jni_env, reinterpret_cast<jintArray> (jni_env->CallObjectMethod (jobj, mID)));
+              jint *iv_data = jni_env->GetIntArrayElements (jintArray (iv), 0);
+              dim_vector dims;
+              dims.resize (jni_env->GetArrayLength (jintArray (iv)));
+
+              for (int i = 0; i < dims.length (); i++)
+                dims(i) = iv_data[i];
+
+              jni_env->ReleaseIntArrayElements (jintArray (iv), iv_data, 0);
+              mID = jni_env->GetMethodID (cls, "getClassName", "()Ljava/lang/String;");
+              jstring_ref js (jni_env, reinterpret_cast<jstring> (jni_env->CallObjectMethod (jobj, mID)));
+
+              std::string s = jstring_to_string (jni_env, js);
+
+              if (s == "double")
+                {
+                  NDArray m (dims);
+                  mID = jni_env->GetMethodID (cls, "toDouble", "()[D");
+                  jdoubleArray_ref dv (jni_env, reinterpret_cast<jdoubleArray> (jni_env->CallObjectMethod (jobj, mID)));
+                  jni_env->GetDoubleArrayRegion (dv, 0, m.length (), m.fortran_vec ());
+                  retval = m;
+                  break;
+                }
+              else if (s == "byte")
+                {
+                  if (Vjava_unsigned_autoconversion)
+                    {
+                      uint8NDArray m (dims);
+                      mID = jni_env->GetMethodID (cls, "toByte", "()[B");
+                      jbyteArray_ref dv (jni_env, reinterpret_cast<jbyteArray> (jni_env->CallObjectMethod (jobj, mID)));
+                      jni_env->GetByteArrayRegion (dv, 0, m.length (), reinterpret_cast<jbyte *> (m.fortran_vec ()));
+                      retval = m;
+                      break;
+                    }
+                  else
+                    {
+                      int8NDArray m (dims);
+                      mID = jni_env->GetMethodID (cls, "toByte", "()[B");
+                      jbyteArray_ref dv (jni_env, reinterpret_cast<jbyteArray> (jni_env->CallObjectMethod (jobj, mID)));
+                      jni_env->GetByteArrayRegion (dv, 0, m.length (), reinterpret_cast<jbyte *> (m.fortran_vec ()));
+                      retval = m;
+                      break;
+                    }
+                }
+              else if (s == "integer")
+                {
+                  if (Vjava_unsigned_autoconversion)
+                    {
+                      uint32NDArray m (dims);
+                      mID = jni_env->GetMethodID (cls, "toInt", "()[I");
+                      jintArray_ref dv (jni_env, reinterpret_cast<jintArray> (jni_env->CallObjectMethod (jobj, mID)));
+                      jni_env->GetIntArrayRegion (dv, 0, m.length (), reinterpret_cast<jint *> (m.fortran_vec ()));
+                      retval = m;
+                      break;
+                    }
+                  else
+                    {
+                      int32NDArray m (dims);
+                      mID = jni_env->GetMethodID (cls, "toInt", "()[I");
+                      jintArray_ref dv (jni_env, reinterpret_cast<jintArray> (jni_env->CallObjectMethod (jobj, mID)));
+                      jni_env->GetIntArrayRegion (dv, 0, m.length (), reinterpret_cast<jint *> (m.fortran_vec ()));
+                      retval = m;
+                      break;
+                    }
+                }
+            }
+        }
+
+      cls = find_octave_class (jni_env, "org/octave/OctaveReference");
+      if (jni_env->IsInstanceOf (jobj, cls))
+        {
+          jmethodID mID = jni_env->GetMethodID (cls, "getID", "()I");
+          int ID = jni_env->CallIntMethod (jobj, mID);
+          std::map<int,octave_value>::iterator it = octave_ref_map.find (ID);
+
+          if (it != octave_ref_map.end ())
+            retval = it->second;
+
+          break;
+        }
+
+      // No suitable class found.  Return a generic octave_java object
+      retval = octave_value (new octave_java (jobj, jcls));
+      break;
+    }
+
+  return retval;
+}
+
+octave_value
+box_more (JNIEnv* jni_env, jobject jobj, jclass jcls)
+{
+  octave_value retval = box (jni_env, jobj, jcls);
+
+  if (retval.is_java ())
+    {
+      retval = octave_value ();
+
+      jclass_ref cls (jni_env);
+
+      if (retval.is_undefined ())
+        {
+          cls = jni_env->FindClass ("[D");
+
+          if (jni_env->IsInstanceOf (jobj, cls))
+            {
+              jdoubleArray jarr = reinterpret_cast<jdoubleArray> (jobj);
+              int len = jni_env->GetArrayLength (jarr);
+
+              if (len > 0)
+                {
+                  Matrix m (1, len);
+                  jni_env->GetDoubleArrayRegion (jarr, 0, len, m.fortran_vec ());
+                  retval = m;
+                }
+              else
+                retval = Matrix ();
+            }
+        }
+
+      if (retval.is_undefined ())
+        {
+          cls = jni_env->FindClass ("[[D");
+
+          if (jni_env->IsInstanceOf (jobj, cls))
+            {
+              jobjectArray jarr = reinterpret_cast<jobjectArray> (jobj);
+              int rows = jni_env->GetArrayLength (jarr), cols = 0;
+
+              if (rows > 0)
+                {
+                  Matrix m;
+
+                  for (int r = 0; r < rows; r++)
+                    {
+                      jdoubleArray_ref row (jni_env, reinterpret_cast<jdoubleArray> (jni_env->GetObjectArrayElement (jarr, r)));
+
+                      if (m.length () == 0)
+                        {
+                          cols = jni_env->GetArrayLength (row);
+                          m.resize (cols, rows);
+                        }
+                      jni_env->GetDoubleArrayRegion (row, 0, cols, m.fortran_vec () + r * cols);
+                    }
+                  retval = m.transpose ();
+                }
+              else
+                retval = Matrix ();
+            }
+        }
+
+      if (retval.is_undefined ())
+        {
+          cls = jni_env->FindClass ("[Ljava/lang/String;");
+
+          if (jni_env->IsInstanceOf (jobj, cls))
+            {
+              jobjectArray jarr = reinterpret_cast<jobjectArray> (jobj);
+              int len = jni_env->GetArrayLength (jarr);
+              Cell m (len, 1);
+
+              for (int i = 0; i < len; i++)
+                {
+                  jstring_ref js (jni_env, reinterpret_cast<jstring> (jni_env->GetObjectArrayElement (jarr, i)));
+                  m(i) = jstring_to_string (jni_env, js);
+                }
+
+              retval = m;
+            }
+        }
+    }
+
+  if (retval.is_undefined ())
+    retval = octave_value (new octave_java (jobj, jcls));
+
+  return retval;
+}
+
+int
+unbox (JNIEnv* jni_env, const octave_value& val, jobject_ref& jobj,
+       jclass_ref& jcls)
+{
+  int found = 1;
+
+  if (val.is_java ())
+    {
+      octave_java *ovj = TO_JAVA (val);
+      jobj = ovj->to_java ();
+      jobj.detach ();
+      jcls = jni_env->GetObjectClass (jobj);
+    }
+  else if (val.is_string ())
+    {
+      std::string s = val.string_value ();
+
+      jobj = jni_env->NewStringUTF (s.c_str ());
+      jcls = jni_env->GetObjectClass (jobj);
+    }
+  else if (val.is_real_scalar ())
+    {
+      if (val.is_double_type ())
+        {
+          double dval = val.double_value ();
+          jclass_ref dcls (jni_env, jni_env->FindClass ("java/lang/Double"));
+          jfieldID fid = jni_env->GetStaticFieldID (dcls, "TYPE", "Ljava/lang/Class;");
+          jmethodID mid = jni_env->GetMethodID (dcls, "<init>", "(D)V");
+          jcls = reinterpret_cast<jclass> (jni_env->GetStaticObjectField (dcls, fid));
+          jobj = jni_env->NewObject (dcls, mid, dval);
+        }
+      else
+        {
+          float fval = val.float_scalar_value ();
+          jclass_ref fcls (jni_env, jni_env->FindClass ("java/lang/Float"));
+          jfieldID fid = jni_env->GetStaticFieldID (fcls, "TYPE", "Ljava/lang/Class;");
+          jmethodID mid = jni_env->GetMethodID (fcls, "<init>", "(F)V");
+          jcls = reinterpret_cast<jclass> (jni_env->GetStaticObjectField (fcls, fid));
+          jobj = jni_env->NewObject (fcls, mid, fval);
+        }
+    }
+  else if (val.is_integer_type () && val.is_scalar_type ())
+    {
+      int32_t ival = val.int32_scalar_value ();
+      jclass_ref icls (jni_env, jni_env->FindClass ("java/lang/Integer"));
+      jfieldID fid = jni_env->GetStaticFieldID (icls, "TYPE", "Ljava/lang/Class;");
+      jmethodID mid = jni_env->GetMethodID (icls, "<init>", "(I)V");
+      jcls = reinterpret_cast<jclass> (jni_env->GetStaticObjectField (icls, fid));
+      jobj = jni_env->NewObject (icls, mid, ival);
+    }
+  else if (val.is_bool_scalar ())
+   {
+      bool bval = val.bool_value ();
+      jclass_ref bcls (jni_env, jni_env->FindClass ("java/lang/Boolean"));
+      jfieldID fid = jni_env->GetStaticFieldID (bcls, "TYPE", "Ljava/lang/Class;");
+      jmethodID mid = jni_env->GetMethodID (bcls, "<init>", "(Z)V");
+      jcls = reinterpret_cast<jclass> (jni_env->GetStaticObjectField (bcls, fid));
+      jobj = jni_env->NewObject (bcls, mid, bval);
+   }
+  else if (val.is_empty ())
+    {
+      jobj = 0;
+      jcls = 0;
+      //jcls = jni_env->FindClass ("java/lang/Object");
+    }
+  else if (!Vjava_matrix_autoconversion
+           && ((val.is_real_matrix ()
+                && (val.rows () == 1 || val.columns () == 1))
+               || val.is_range ()))
+    {
+      Matrix m = val.matrix_value ();
+      jdoubleArray dv = jni_env->NewDoubleArray (m.length ());
+      //for (int i = 0; i < m.length (); i++)
+        jni_env->SetDoubleArrayRegion (dv, 0, m.length (), m.fortran_vec ());
+      jobj = dv;
+      jcls = jni_env->GetObjectClass (jobj);
+    }
+  else if (Vjava_matrix_autoconversion
+           && (val.is_matrix_type () || val.is_range ()) && val.is_real_type ())
+    {
+      jclass_ref mcls (jni_env, find_octave_class (jni_env, "org/octave/Matrix"));
+      dim_vector dims = val.dims ();
+      jintArray_ref iv (jni_env, jni_env->NewIntArray (dims.length ()));
+      jint *iv_data = jni_env->GetIntArrayElements (jintArray (iv), 0);
+
+      for (int i = 0; i < dims.length (); i++)
+        iv_data[i] = dims(i);
+
+      jni_env->ReleaseIntArrayElements (jintArray (iv), iv_data, 0);
+
+      if (val.is_double_type ())
+        {
+          NDArray m = val.array_value ();
+          jdoubleArray_ref dv (jni_env, jni_env->NewDoubleArray (m.length ()));
+          jni_env->SetDoubleArrayRegion (jdoubleArray (dv), 0, m.length (), m.fortran_vec ());
+          jmethodID mID = jni_env->GetMethodID (mcls, "<init>", "([D[I)V");
+          jobj = jni_env->NewObject (jclass (mcls), mID, jdoubleArray (dv), jintArray (iv));
+          jcls = jni_env->GetObjectClass (jobj);
+        }
+      else if (val.is_int8_type ())
+        {
+          int8NDArray m = val.int8_array_value ();
+          jbyteArray_ref bv (jni_env, jni_env->NewByteArray (m.length ()));
+          jni_env->SetByteArrayRegion (jbyteArray (bv), 0, m.length (), reinterpret_cast <jbyte *> (m.fortran_vec ()));
+          jmethodID mID = jni_env->GetMethodID (mcls, "<init>", "([B[I)V");
+          jobj = jni_env->NewObject (jclass (mcls), mID, jbyteArray (bv), jintArray (iv));
+          jcls = jni_env->GetObjectClass (jobj);
+        }
+      else if (val.is_uint8_type ())
+        {
+          uint8NDArray m = val.uint8_array_value ();
+          jbyteArray_ref bv (jni_env, jni_env->NewByteArray (m.length ()));
+          jni_env->SetByteArrayRegion (jbyteArray (bv), 0, m.length (), reinterpret_cast<jbyte *> (m.fortran_vec ()));
+          jmethodID mID = jni_env->GetMethodID (mcls, "<init>", "([B[I)V");
+          jobj = jni_env->NewObject (jclass (mcls), mID, jbyteArray (bv), jintArray (iv));
+          jcls = jni_env->GetObjectClass (jobj);
+        }
+      else if (val.is_int32_type ())
+        {
+          int32NDArray m = val.int32_array_value ();
+          jintArray_ref v (jni_env, jni_env->NewIntArray (m.length ()));
+          jni_env->SetIntArrayRegion (jintArray (v), 0, m.length (), reinterpret_cast<jint *> (m.fortran_vec ()));
+          jmethodID mID = jni_env->GetMethodID (mcls, "<init>", "([I[I)V");
+          jobj = jni_env->NewObject (jclass (mcls), mID, jintArray (v), jintArray (iv));
+          jcls = jni_env->GetObjectClass (jobj);
+        }
+      else
+        {
+          found = 0;
+          error ("cannot convert matrix of type `%s'", val.class_name ().c_str ());
+        }
+    }
+  else if (val.is_cellstr ())
+    {
+      Cell cellStr = val.cell_value ();
+      jclass_ref scls (jni_env, jni_env->FindClass ("java/lang/String"));
+      jobjectArray array = jni_env->NewObjectArray (cellStr.length (), scls, 0);
+      for (int i = 0; i < cellStr.length (); i++)
+        {
+          jstring_ref jstr (jni_env, jni_env->NewStringUTF (cellStr(i).string_value().c_str ()));
+          jni_env->SetObjectArrayElement (array, i, jstr);
+        }
+      jobj = array;
+      jcls = jni_env->GetObjectClass (jobj);
+    }
+  else
+    {
+      jclass rcls = find_octave_class (jni_env, "org/octave/OctaveReference");
+      jmethodID mID = jni_env->GetMethodID (rcls, "<init>", "(I)V");
+      int ID = octave_java_refcount++;
+
+      jobj = jni_env->NewObject (rcls, mID, ID);
+      jcls = rcls;
+      octave_ref_map[ID] = val;
+    }
+
+  return found;
+}
+
+int
+unbox (JNIEnv* jni_env, const octave_value_list& args,
+       jobjectArray_ref& jobjs, jobjectArray_ref& jclss)
+{
+  int found = 1;
+
+  jclass_ref ocls (jni_env, jni_env->FindClass ("java/lang/Object"));
+  jclass_ref ccls (jni_env, jni_env->FindClass ("java/lang/Class"));
+
+  if (! jobjs)
+    jobjs = jni_env->NewObjectArray (args.length (), ocls, 0);
+
+  if (! jclss)
+    jclss = jni_env->NewObjectArray (args.length (), ccls, 0);
+
+  for (int i = 0; i < args.length (); i++)
+    {
+      jobject_ref jobj (jni_env);
+      jclass_ref jcls (jni_env);
+
+      if (! unbox (jni_env, args(i), jobj, jcls))
+        {
+          found = 0;
+          break;
+        }
+
+      jni_env->SetObjectArrayElement (jobjs, i, jobj);
+      jni_env->SetObjectArrayElement (jclss, i, jcls);
+    }
+
+  return found;
+}
+
+static long
+get_current_thread_ID (JNIEnv *jni_env)
+{
+  if (jni_env)
+    {
+      jclass_ref cls (jni_env, jni_env->FindClass ("java/lang/Thread"));
+      jmethodID mID = jni_env->GetStaticMethodID (cls, "currentThread", "()Ljava/lang/Thread;");
+      jobject_ref jthread (jni_env, jni_env->CallStaticObjectMethod (cls, mID));
+
+      if (jthread)
+        {
+          jclass_ref jth_cls (jni_env, jni_env->GetObjectClass (jthread));
+          mID = jni_env->GetMethodID (jth_cls, "getId", "()J");
+          long result = jni_env->CallLongMethod (jthread, mID);
+          //printf ("current java thread ID = %ld\n", result);
+          return result;
+        }
+    }
+
+  return -1;
+}
+
+static int
+java_event_hook (void)
+{
+  JNIEnv *current_env = octave_java::thread_jni_env ();
+
+  if (current_env)
+    {
+      jclass_ref cls (current_env, find_octave_class (current_env, "org/octave/Octave"));
+      jmethodID mID = current_env->GetStaticMethodID (cls, "checkPendingAction", "()V");
+      current_env->CallStaticVoidMethod (cls, mID);
+    }
+
+  return 0;
+}
+
+static void
+initialize_java (void)
+{
+  if (! jvm)
+    {
+      try
+        {
+          initialize_jvm ();
+
+          JNIEnv *current_env = octave_java::thread_jni_env ();
+
+          command_editor::add_event_hook (java_event_hook);
+
+          octave_thread_ID = get_current_thread_ID (current_env);
+          //printf ("octave thread ID=%ld\n", octave_thread_ID);
+        }
+      catch (std::string msg)
+        {
+          error (msg.c_str ());
+        }
+    }
+}
+
+DEFUN (__java_init__, , ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} java_init ()\n\
+Internal function used @strong{only} when debugging Java interface.\n\
+Function will directly call initialize_java() to create an instance of a JVM.\n\
+@end deftypefn")
+{
+  octave_value retval;
+
+  retval = 0;
+  initialize_java ();
+  if (! error_state)
+    retval = 1;
+
+  return retval;
+}
+
+DEFUN (__java_exit__, , ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} java_exit ()\n\
+Internal function used @strong{only} when debugging Java interface.\n\
+Function will directly call terminate_jvm() to destroy the current JVM\n\
+instance.\n\
+@end deftypefn")
+{
+  octave_value retval;
+
+  terminate_jvm ();
+
+  return retval;
+}
+
+JNIEXPORT jboolean JNICALL
+Java_org_octave_Octave_call (JNIEnv *env, jclass, jstring funcName,
+                             jobjectArray argin, jobjectArray argout)
+{
+  std::string fname = jstring_to_string (env, funcName);
+
+  int nargout = env->GetArrayLength (argout);
+  int nargin = env->GetArrayLength (argin);
+
+  octave_value_list varargin, varargout;
+
+  for (int i = 0; i < nargin; i++)
+    varargin(i) = box (env, env->GetObjectArrayElement (argin, i), 0);
+
+  varargout = feval (fname, varargin, nargout);
+
+  if (! error_state)
+    {
+      jobjectArray_ref out_objs (env, argout), out_clss (env);
+
+      out_objs.detach ();
+
+      if (unbox (env, varargout, out_objs, out_clss))
+        return true;
+    }
+
+  return false;
+}
+
+JNIEXPORT void JNICALL
+Java_org_octave_OctaveReference_doFinalize (JNIEnv *, jclass, jint ID)
+{
+  octave_ref_map.erase (ID);
+}
+
+JNIEXPORT void JNICALL
+Java_org_octave_Octave_doInvoke (JNIEnv *env, jclass, jint ID,
+                                 jobjectArray args)
+{
+  std::map<int,octave_value>::iterator it = octave_ref_map.find (ID);
+
+  if (it != octave_ref_map.end ())
+    {
+      octave_value val = it->second;
+      int len = env->GetArrayLength (args);
+      octave_value_list oct_args;
+
+      for (int i = 0; i < len; i++)
+        {
+          jobject_ref jobj (env, env->GetObjectArrayElement (args, i));
+          oct_args(i) = box (env, jobj, 0);
+
+          if (error_state)
+            break;
+        }
+
+      if (! error_state)
+        {
+          BEGIN_INTERRUPT_WITH_EXCEPTIONS;
+
+          if (val.is_function_handle ())
+            {
+              octave_function *fcn = val.function_value ();
+              feval (fcn, oct_args);
+            }
+          else if (val.is_cell () && val.length () > 0
+                   && (val.rows () == 1 || val.columns () == 1)
+                   && val.cell_value()(0).is_function_handle ())
+            {
+              Cell c = val.cell_value ();
+              octave_function *fcn = c(0).function_value ();
+
+              for (int i=1; i<c.length (); i++)
+                oct_args(len+i-1) = c(i);
+
+              if (! error_state)
+                feval (fcn, oct_args);
+            }
+          else
+            error ("trying to invoke non-invocable object");
+
+          END_INTERRUPT_WITH_EXCEPTIONS;
+        }
+    }
+}
+
+JNIEXPORT void JNICALL
+Java_org_octave_Octave_doEvalString (JNIEnv *env, jclass, jstring cmd)
+{
+  std::string s = jstring_to_string (env, cmd);
+  int pstatus;
+  eval_string (s, false, pstatus, 0);
+}
+
+JNIEXPORT jboolean JNICALL
+Java_org_octave_Octave_needThreadedInvokation (JNIEnv *env, jclass)
+{
+  return (get_current_thread_ID (env) != octave_thread_ID);
+}
+
+// octave_java class definition
+
+DEFINE_OCTAVE_ALLOCATOR (octave_java);
+
+int octave_java::t_id (-1);
+
+const std::string octave_java::t_name ("octave_java");
+
+void
+octave_java::register_type (void)
+{
+  t_id = octave_value_typeinfo::register_type
+    (octave_java::t_name, "<unknown>", octave_value (new octave_java ()));
+}
+
+dim_vector
+octave_java::dims (void) const
+{
+  JNIEnv *current_env = thread_jni_env ();
+
+  if (current_env && java_object)
+    return compute_array_dimensions (current_env, java_object);
+  else
+    return dim_vector (1, 1);
+}
+
+JNIEnv *
+octave_java::thread_jni_env (void)
+{
+  JNIEnv *env = NULL;
+
+  if (jvm)
+    jvm->GetEnv (reinterpret_cast<void **> (&env), JNI_VERSION_1_2);
+
+  return env;
+}
+
+octave_value_list
+octave_java::subsref (const std::string& type,
+                      const std::list<octave_value_list>& idx, int nargout)
+{
+  octave_value_list retval;
+  int skip = 1;
+
+  JNIEnv *current_env = thread_jni_env ();
+
+  switch (type[0])
+    {
+    case '.':
+      if (type.length () > 1 && type[1] == '(')
+        {
+          octave_value_list ovl;
+          count++;
+          ovl(1) = octave_value (this);
+          ovl(0) = (idx.front ())(0);
+          std::list<octave_value_list>::const_iterator it = idx.begin ();
+          ovl.append (*++it);
+          retval = feval (std::string ("javaMethod"), ovl, 1);
+          skip++;
+        }
+      else
+        {
+          octave_value_list ovl;
+          count++;
+          ovl(0) = octave_value (this);
+          ovl(1) = (idx.front ())(0);
+          retval = feval (std::string ("__java_get__"), ovl, 1);
+        }
+      break;
+
+    case '(':
+      if (current_env)
+        retval = get_array_elements (current_env, to_java (), idx.front ());
+      break;
+
+    default:
+      error ("subsref: Java object cannot be indexed with %c", type[0]);
+      break;
+    }
+
+  if (idx.size () > 1 && type.length () > 1)
+    retval = retval(0).next_subsref (nargout, type, idx, skip);
+
+  return retval;
+}
+
+octave_value
+octave_java::subsasgn (const std::string& type,
+                       const std::list<octave_value_list>&idx,
+                       const octave_value &rhs)
+{
+  octave_value retval;
+
+  JNIEnv *current_env = thread_jni_env ();
+
+  switch (type[0])
+    {
+      case '.':
+        if (type.length () == 1)
+          {
+            // field assignment
+            octave_value_list ovl;
+            count++;
+            ovl(0) = octave_value (this);
+            ovl(1) = (idx.front ())(0);
+            ovl(2) = rhs;
+            feval ("__java_set__", ovl, 0);
+            if (! error_state)
+              {
+                count++;
+                retval = octave_value (this);
+              }
+          }
+        else if (type.length () > 2 && type[1] == '(')
+          {
+            std::list<octave_value_list> new_idx;
+            std::list<octave_value_list>::const_iterator it = idx.begin ();
+            new_idx.push_back (*it++);
+            new_idx.push_back (*it++);
+            octave_value_list u = subsref (type.substr (0, 2), new_idx, 1);
+            if (! error_state)
+              {
+                std::list<octave_value_list> next_idx (idx);
+                next_idx.erase (next_idx.begin ());
+                next_idx.erase (next_idx.begin ());
+                u(0).subsasgn (type.substr (2), next_idx, rhs);
+                if (! error_state)
+                  {
+                    count++;
+                    retval = octave_value (this);
+                  }
+              }
+          }
+        else if (type[1] == '.')
+          {
+            octave_value_list u = subsref (type.substr (0, 1), idx, 1);
+            if (! error_state)
+              {
+                std::list<octave_value_list> next_idx (idx);
+                next_idx.erase (next_idx.begin ());
+                u(0).subsasgn (type.substr (1), next_idx, rhs);
+                if (! error_state)
+                  {
+                    count++;
+                    retval = octave_value (this);
+                  }
+              }
+          }
+        else
+          error ("invalid indexing/assignment on Java object");
+        break;
+
+      case '(':
+        if (current_env)
+          {
+            set_array_elements (current_env, to_java (), idx.front (), rhs);
+            if (! error_state)
+              {
+                count++;
+                retval = octave_value (this);
+              }
+          }
+        break;
+
+      default:
+        error ("Java object cannot be indexed with %c", type[0]);
+        break;
+    }
+
+  return retval;
+}
+
+string_vector
+octave_java::map_keys (void) const
+{
+  JNIEnv *current_env = thread_jni_env ();
+
+  if (current_env)
+    return get_invoke_list (current_env, to_java ());
+  else
+    return string_vector ();
+}
+
+octave_value
+octave_java::convert_to_str_internal (bool, bool force, char type) const
+{
+  JNIEnv *current_env = thread_jni_env ();
+
+  if (current_env)
+    return convert_to_string (current_env, to_java (), force, type);
+  else
+    return octave_value ("");
+}
+
+octave_value
+octave_java::do_javaMethod (JNIEnv* jni_env, const std::string& name,
+                             const octave_value_list& args)
+{
+  octave_value retval;
+
+  if (jni_env)
+    {
+      jobjectArray_ref arg_objs (jni_env), arg_types (jni_env);
+      if (unbox (jni_env, args, arg_objs, arg_types))
+        {
+          jclass_ref helperClass (jni_env, find_octave_class (jni_env, "org/octave/ClassHelper"));
+          jmethodID mID = jni_env->GetStaticMethodID (helperClass, "invokeMethod",
+                                                      "(Ljava/lang/Object;Ljava/lang/String;[Ljava/lang/Object;[Ljava/lang/Class;)Ljava/lang/Object;");
+          jstring_ref methName (jni_env, jni_env->NewStringUTF (name.c_str ()));
+          jobjectArray_ref resObj (jni_env, reinterpret_cast<jobjectArray> (jni_env->CallStaticObjectMethod (helperClass, mID,
+                                                                                                             to_java (), jstring (methName), jobjectArray (arg_objs), jobjectArray (arg_types))));
+          if (resObj)
+            retval = box (jni_env, resObj);
+          else
+            retval = check_exception (jni_env);
+        }
+    }
+
+  return retval;
+}
+
+octave_value
+octave_java:: do_javaMethod (JNIEnv* jni_env,
+                              const std::string& class_name,
+                              const std::string& name,
+                              const octave_value_list& args)
+{
+  octave_value retval;
+
+  if (jni_env)
+    {
+      jobjectArray_ref arg_objs (jni_env), arg_types (jni_env);
+      if (unbox (jni_env, args, arg_objs, arg_types))
+        {
+          jclass_ref helperClass (jni_env, find_octave_class (jni_env, "org/octave/ClassHelper"));
+          jmethodID mID = jni_env->GetStaticMethodID (helperClass, "invokeStaticMethod",
+                                                      "(Ljava/lang/String;Ljava/lang/String;[Ljava/lang/Object;[Ljava/lang/Class;)Ljava/lang/Object;");
+          jstring_ref methName (jni_env, jni_env->NewStringUTF (name.c_str ()));
+          jstring_ref clsName (jni_env, jni_env->NewStringUTF (class_name.c_str ()));
+          jobject_ref resObj (jni_env, jni_env->CallStaticObjectMethod (helperClass, mID,
+                                                                        jstring (clsName), jstring (methName), jobjectArray (arg_objs), jobjectArray (arg_types)));
+          if (resObj)
+            retval = box (jni_env, resObj);
+          else
+            retval = check_exception (jni_env);
+        }
+    }
+
+  return retval;
+}
+
+octave_value
+octave_java::do_javaObject (JNIEnv* jni_env, const std::string& name,
+                             const octave_value_list& args)
+{
+  octave_value retval;
+
+  if (jni_env)
+    {
+      jobjectArray_ref arg_objs (jni_env), arg_types (jni_env);
+
+      if (unbox (jni_env, args, arg_objs, arg_types))
+        {
+          jclass_ref helperClass (jni_env, find_octave_class (jni_env, "org/octave/ClassHelper"));
+          jmethodID mID = jni_env->GetStaticMethodID (helperClass, "invokeConstructor",
+                                                      "(Ljava/lang/String;[Ljava/lang/Object;[Ljava/lang/Class;)Ljava/lang/Object;");
+          jstring_ref clsName (jni_env, jni_env->NewStringUTF (name.c_str ()));
+          jobject_ref resObj (jni_env, jni_env->CallStaticObjectMethod (helperClass, mID,
+                                                                        jstring (clsName), jobjectArray (arg_objs), jobjectArray (arg_types)));
+
+          if (resObj)
+            retval = octave_value (new octave_java (resObj, 0));
+          else
+            check_exception (jni_env);
+        }
+    }
+
+  return retval;
+}
+
+octave_value
+octave_java::do_java_get (JNIEnv* jni_env, const std::string& name)
+{
+  octave_value retval;
+
+  if (jni_env)
+    {
+      jclass_ref helperClass (jni_env, find_octave_class (jni_env, "org/octave/ClassHelper"));
+      jmethodID mID = jni_env->GetStaticMethodID (helperClass, "getField",
+          "(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;");
+      jstring_ref fName (jni_env, jni_env->NewStringUTF (name.c_str ()));
+      jobject_ref resObj (jni_env, jni_env->CallStaticObjectMethod (helperClass, mID,
+          to_java (), jstring (fName)));
+
+      if (resObj)
+        retval = box (jni_env, resObj);
+      else
+        retval = check_exception (jni_env);
+    }
+
+  return retval;
+}
+
+octave_value
+octave_java::do_java_get (JNIEnv* jni_env, const std::string& class_name,
+                          const std::string& name)
+{
+  octave_value retval;
+
+  if (jni_env)
+    {
+      jclass_ref helperClass (jni_env, find_octave_class (jni_env, "org/octave/ClassHelper"));
+      jmethodID mID = jni_env->GetStaticMethodID (helperClass, "getStaticField",
+          "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/Object;");
+      jstring_ref cName (jni_env, jni_env->NewStringUTF (class_name.c_str ()));
+      jstring_ref fName (jni_env, jni_env->NewStringUTF (name.c_str ()));
+      jobject_ref resObj (jni_env, jni_env->CallStaticObjectMethod (helperClass, mID,
+          jstring (cName), jstring (fName)));
+      if (resObj)
+        retval = box (jni_env, resObj);
+      else
+        retval = check_exception (jni_env);
+    }
+
+  return retval;
+}
+
+octave_value
+octave_java::do_java_set (JNIEnv* jni_env, const std::string& name,
+                          const octave_value& val)
+{
+  octave_value retval;
+
+  if (jni_env)
+    {
+      jobject_ref jobj (jni_env);
+      jclass_ref jcls (jni_env);
+
+      if (unbox (jni_env, val, jobj, jcls))
+        {
+          jclass_ref helperClass (jni_env, find_octave_class (jni_env, "org/octave/ClassHelper"));
+          jmethodID mID = jni_env->GetStaticMethodID (helperClass, "setField",
+                                                      "(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/Object;)V");
+          jstring_ref fName (jni_env, jni_env->NewStringUTF (name.c_str ()));
+          jni_env->CallStaticObjectMethod (helperClass, mID, to_java (), jstring (fName), jobject (jobj));
+          check_exception (jni_env);
+        }
+    }
+
+  return retval;
+}
+
+octave_value
+octave_java::do_java_set (JNIEnv* jni_env, const std::string& class_name,
+                          const std::string& name, const octave_value& val)
+{
+  octave_value retval;
+
+  if (jni_env)
+    {
+      jobject_ref jobj (jni_env);
+      jclass_ref jcls (jni_env);
+
+      if (unbox (jni_env, val, jobj, jcls))
+        {
+          jclass_ref helperClass (jni_env, find_octave_class (jni_env, "org/octave/ClassHelper"));
+          jmethodID mID = jni_env->GetStaticMethodID (helperClass, "setStaticField",
+                                                      "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/Object;)V");
+          jstring_ref cName (jni_env, jni_env->NewStringUTF (class_name.c_str ()));
+          jstring_ref fName (jni_env, jni_env->NewStringUTF (name.c_str ()));
+          jni_env->CallStaticObjectMethod (helperClass, mID, jstring (cName), jstring (fName), jobject (jobj));
+          check_exception (jni_env);
+        }
+    }
+
+  return retval;
+}
+
+#endif  // endif on HAVE_JAVA
+
+// DEFUN blocks below must be outside of HAVE_JAVA block so that
+// documentation strings are always available, even when functions are not.
+
+DEFUN (javaObject, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn  {Built-in Function} {@var{jobj} =} javaObject (@var{classname})\n\
+@deftypefnx {Built-in Function} {@var{jobj} =} javaObject (@var{classname}, @var{arg1}, @dots{})\n\
+Create a Java object of class @var{classsname}, by calling the class\n\
+constructor with the arguments @var{arg1}, @dots{}\n\
+\n\
+The first example below creates an uninitialized object,\n\
+while the second example supplies an initial argument to the constructor.\n\
+\n\
+@example\n\
+@group\n\
+x = javaObject (\"java.lang.StringBuffer\")\n\
+x = javaObject (\"java.lang.StringBuffer\", \"Initial string\")\n\
+@end group\n\
+@end example\n\
+\n\
+@seealso{javaMethod, javaArray}\n\
+@end deftypefn")
+{
+#ifdef HAVE_JAVA
+  octave_value retval;
+
+  initialize_java ();
+
+  if (! error_state)
+    {
+      JNIEnv *current_env = octave_java::thread_jni_env ();
+
+      if (args.length () > 0)
+        {
+          std::string classname = args(0).string_value ();
+          if (! error_state)
+            {
+              octave_value_list tmp;
+              for (int i=1; i<args.length (); i++)
+                tmp(i-1) = args(i);
+              retval = octave_java::do_javaObject (current_env, classname, tmp);
+            }
+          else
+            error ("javaObject: CLASSNAME must be a string");
+        }
+      else
+        print_usage ();
+    }
+
+  return retval;
+#else
+  error ("javaObject: Octave was not compiled with Java interface");
+  return octave_value ();
+#endif
+}
+
+/*
+%!testif HAVE_JAVA
+%% The tests below merely check if javaObject works at all. Whether it works
+%% properly, i.e. creates the right values, is a matter of Java itself
+%% Create a Short and check if it really is a short, i.e. whether it overflows
+%! assert (javaObject ("java.lang.Short", 40000).doubleValue < 0);
+*/
+
+DEFUN (javaMethod, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn  {Built-in Function} {@var{ret} =} javaMethod (@var{methodname}, @var{obj})\n\
+@deftypefnx {Built-in Function} {@var{ret} =} javaMethod (@var{methodname}, @var{obj}, @var{arg1}, @dots{})\n\
+Invoke the method @var{methodname} on the Java object @var{obj} with the\n\
+arguments @var{arg1}, @dots{}  For static methods, @var{obj} can be a string\n\
+representing the fully qualified name of the corresponding class.  The\n\
+function returns the result of the method invocation.\n\
+\n\
+When @var{obj} is a regular Java object, structure-like indexing can be\n\
+used as a shortcut syntax.  For instance, the two following statements are\n\
+equivalent\n\
+\n\
+@example\n\
+@group\n\
+  ret = javaMethod (\"method1\", x, 1.0, \"a string\")\n\
+  ret = x.method1 (1.0, \"a string\")\n\
+@end group\n\
+@end example\n\
+\n\
+@seealso{methods, javaObject}\n\
+@end deftypefn")
+{
+#ifdef HAVE_JAVA
+  octave_value retval;
+
+  initialize_java ();
+
+  if (! error_state)
+    {
+      JNIEnv *current_env = octave_java::thread_jni_env ();
+
+      if (args.length () > 1)
+        {
+          std::string methodname = args(0).string_value ();
+          if (! error_state)
+            {
+              octave_value_list tmp;
+              for (int i=2; i<args.length (); i++)
+                tmp(i-2) = args(i);
+
+              if (args(1).is_java ())
+                {
+                  octave_java *jobj = TO_JAVA (args(1));
+                  retval = jobj->do_javaMethod (current_env, methodname, tmp);
+                }
+              else if (args(1).is_string ())
+                {
+                  std::string cls = args(1).string_value ();
+                  retval = octave_java::do_javaMethod (current_env, cls, methodname, tmp);
+                }
+              else
+                error ("javaMethod: OBJ must be a Java object or a string");
+            }
+          else
+            error ("javaMethod: METHODNAME must be a string");
+        }
+      else
+        print_usage ();
+    }
+
+  return retval;
+#else
+  error ("javaMethod: Octave was not compiled with Java interface");
+  return octave_value ();
+#endif
+}
+
+/*
+%!testif HAVE_JAVA
+%% Check for valid first two Java version numbers
+%! jver = strsplit (javaMethod ('getProperty', 'java.lang.System', 'java.version'), '.');
+%! assert (isfinite (str2double (jver{1})) && isfinite (str2double (jver{2})));
+*/
+
+DEFUN (__java_get__, args, ,
+    "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{val} =} __java_get__ (@var{obj}, @var{name})\n\
+Get the value of the field @var{name} of the Java object @var{obj}.  For\n\
+static fields, @var{obj} can be a string representing the fully qualified\n\
+name of the corresponding class.\n\
+\n\
+When @var{obj} is a regular Java object, structure-like indexing can be\n\
+used as a shortcut syntax.  For instance, the two following statements are\n\
+equivalent\n\
+\n\
+@example\n\
+@group\n\
+  __java_get__ (x, \"field1\")\n\
+  x.field1\n\
+@end group\n\
+@end example\n\
+\n\
+@seealso{__java_set__, javaMethod, javaObject}\n\
+@end deftypefn")
+{
+#ifdef HAVE_JAVA
+  octave_value retval;
+
+  initialize_java ();
+
+  if (! error_state)
+    {
+      JNIEnv *current_env = octave_java::thread_jni_env ();
+
+      if (args.length () == 2)
+        {
+          std::string name = args(1).string_value ();
+          if (! error_state)
+            {
+              if (args(0).is_java ())
+                {
+                  octave_java *jobj = TO_JAVA (args(0));
+                  retval = jobj->do_java_get (current_env, name);
+                }
+              else if (args(0).is_string ())
+                {
+                  std::string cls = args(0).string_value ();
+                  retval = octave_java::do_java_get (current_env, cls, name);
+                }
+              else
+                error ("__java_get__: OBJ must be a Java object or a string");
+            }
+          else
+            error ("__java_get__: NAME must be a string");
+        }
+      else
+        print_usage ();
+    }
+
+  return retval;
+#else
+  error ("__java_get__: Octave was not compiled with Java interface");
+  return octave_value ();
+#endif
+}
+
+DEFUN (__java_set__, args, ,
+    "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {@var{obj} =} __java_set__ (@var{obj}, @var{name}, @var{val})\n\
+Set the value of the field @var{name} of the Java object @var{obj} to\n\
+@var{val}.  For static fields, @var{obj} can be a string representing the\n\
+fully qualified named of the corresponding Java class.\n\
+\n\
+When @var{obj} is a regular Java object, structure-like indexing can be\n\
+used as a shortcut syntax.  For instance, the two following statements are\n\
+equivalent\n\
+\n\
+@example\n\
+@group\n\
+  __java_set__ (x, \"field1\", val)\n\
+  x.field1 = val\n\
+@end group\n\
+@end example\n\
+\n\
+@seealso{__java_get__, javaMethod, javaObject}\n\
+@end deftypefn")
+{
+#ifdef HAVE_JAVA
+  octave_value retval;
+
+  initialize_java ();
+
+  if (! error_state)
+    {
+      JNIEnv *current_env = octave_java::thread_jni_env ();
+
+      if (args.length () == 3)
+        {
+          std::string name = args(1).string_value ();
+          if (! error_state)
+            {
+              if (args(0).is_java ())
+                {
+                  octave_java *jobj = TO_JAVA (args(0));
+                  retval = jobj->do_java_set (current_env, name, args(2));
+                }
+              else if (args(0).is_string ())
+                {
+                  std::string cls = args(0).string_value ();
+                  retval = octave_java::do_java_set (current_env, cls, name, args(2));
+                }
+              else
+                error ("__java_set__: OBJ must be a Java object or a string");
+            }
+          else
+            error ("__java_set__: NAME must be a string");
+        }
+      else
+        print_usage ();
+    }
+
+  return retval;
+#else
+  error ("__java_set__: Octave was not compiled with Java interface");
+  return octave_value ();
+#endif
+}
+
+DEFUN (java2mat, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} java2mat (@var{javaobj})\n\
+Undocumented internal function.\n\
+@end deftypefn")
+{
+#ifdef HAVE_JAVA
+  octave_value_list retval;
+
+  initialize_java ();
+
+  if (! error_state)
+    {
+      JNIEnv *current_env = octave_java::thread_jni_env ();
+
+      if (args.length () == 1)
+        {
+          if (args(0).is_java ())
+            {
+              octave_java *jobj = TO_JAVA (args(0));
+              retval(0) = box_more (current_env, jobj->to_java (), 0);
+            }
+          else
+            retval(0) = args(0);
+        }
+      else
+        print_usage ();
+    }
+
+  return retval;
+#else
+  error ("java2mat: Octave was not compiled with Java interface");
+  return octave_value ();
+#endif
+}
+
+DEFUN (java_matrix_autoconversion, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn  {Built-in Function} {@var{val} =} java_matrix_autoconversion ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} java_matrix_autoconversion (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} java_matrix_autoconversion (@var{new_val}, \"local\")\n\
+Query or set the internal variable that controls whether Java arrays are\n\
+automatically converted to Octave matrices.  The default value is false.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
+@seealso{java_unsigned_autoconversion, debug_java}\n\
+@end deftypefn")
+{
+#ifdef HAVE_JAVA
+  return SET_INTERNAL_VARIABLE (java_matrix_autoconversion);
+#else
+  error ("java_matrix_autoconversion: Octave was not compiled with Java interface");
+  return octave_value ();
+#endif
+}
+
+DEFUN (java_unsigned_autoconversion, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn  {Built-in Function} {@var{val} =} java_unsigned_autoconversion ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} java_unsigned_autoconversion (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} java_unsigned_autoconversion (@var{new_val}, \"local\")\n\
+Query or set the internal variable that controls how integer classes are\n\
+converted when @code{java_matrix_autoconversion} is enabled.  When enabled,\n\
+Java arrays of class Byte or Integer are converted to matrices of class\n\
+uint8 or uint32 respectively.  The default value is true.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
+@seealso{java_matrix_autoconversion, debug_java}\n\
+@end deftypefn")
+{
+#ifdef HAVE_JAVA
+  return SET_INTERNAL_VARIABLE (java_unsigned_autoconversion);
+#else
+  error ("java_unsigned_autoconversion: Octave was not compiled with Java interface");
+  return octave_value ();
+#endif
+}
+
+DEFUN (debug_java, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn  {Built-in Function} {@var{val} =} debug_java ()\n\
+@deftypefnx {Built-in Function} {@var{old_val} =} debug_java (@var{new_val})\n\
+@deftypefnx {Built-in Function} {} debug_java (@var{new_val}, \"local\")\n\
+Query or set the internal variable that determines whether extra debugging\n\
+information regarding the initialization of the JVM and any Java exceptions\n\
+is printed.\n\
+\n\
+When called from inside a function with the \"local\" option, the variable is\n\
+changed locally for the function and any subroutines it calls.  The original\n\
+variable value is restored when exiting the function.\n\
+@seealso{java_matrix_autoconversion, java_unsigned_autoconversion}\n\
+@end deftypefn")
+{
+#ifdef HAVE_JAVA
+  return SET_INTERNAL_VARIABLE (debug_java);
+#else
+  error ("debug_java: Octave was not compiled with Java interface");
+  return octave_value ();
+#endif
+}
+
+// Outside of #ifdef HAVE_JAVA because it is desirable to be able to
+// test for the presence of a Java object without having Java installed. 
+DEFUN (isjava, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} isjava (@var{x})\n\
+Return true if @var{x} is a Java object.\n\
+@seealso{class, typeinfo, isa, javaObject}\n\
+@end deftypefn")
+{
+  octave_value retval;
+
+  if (args.length () != 1)
+    print_usage ();
+  else
+    retval = args(0).is_java ();
+
+  return retval;
+}
+
diff --git a/libinterp/octave-value/ov-java.h b/libinterp/octave-value/ov-java.h
new file mode 100644
--- /dev/null
+++ b/libinterp/octave-value/ov-java.h
@@ -0,0 +1,321 @@
+/*
+
+Copyright (C) 2007 Michael Goffioul
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if !defined (octave_java_h)
+#define octave_java_h 1
+
+#include <jni.h>
+
+#include <oct-obj.h>
+#include <ov.h>
+
+template <class T>
+class java_local_ref
+{
+public:
+
+  java_local_ref (JNIEnv *_env)
+    : jobj (0), detached (false), env (_env) { }
+
+  java_local_ref (JNIEnv *_env, T obj)
+    : jobj (obj), detached (false), env (_env) { }
+
+  ~java_local_ref (void) { release (); }
+
+  T& operator= (T obj)
+  {
+    release ();
+    jobj = obj;
+    detached = false;
+    return jobj;
+  }
+
+  operator bool () const { return (jobj != 0); }
+  operator T () { return jobj; }
+
+  void detach (void) { detached = true; }
+
+private:
+
+  void release (void)
+  {
+    if (env && jobj && ! detached)
+      env->DeleteLocalRef (jobj);
+
+    jobj = 0;
+  }
+
+  java_local_ref (void)
+    : jobj (0), detached (false), env (0)
+  { }
+
+protected:
+  T jobj;
+  bool detached;
+  JNIEnv *env;
+};
+
+typedef java_local_ref<jobject> jobject_ref;
+typedef java_local_ref<jclass> jclass_ref;
+typedef java_local_ref<jstring> jstring_ref;
+typedef java_local_ref<jobjectArray> jobjectArray_ref;
+typedef java_local_ref<jintArray> jintArray_ref;
+typedef java_local_ref<jbyteArray> jbyteArray_ref;
+typedef java_local_ref<jdoubleArray> jdoubleArray_ref;
+typedef java_local_ref<jthrowable> jthrowable_ref;
+
+extern OCTINTERP_API std::string
+jstring_to_string (JNIEnv* jni_env, jstring s);
+
+extern OCTINTERP_API std::string
+jstring_to_string (JNIEnv* jni_env, jobject obj);
+
+extern OCTINTERP_API octave_value
+box (JNIEnv* jni_env, jobject jobj, jclass jcls = 0);
+
+extern OCTINTERP_API octave_value
+box_more (JNIEnv* jni_env, jobject jobj, jclass jcls = 0);
+
+extern OCTINTERP_API int
+unbox (JNIEnv* jni_env, const octave_value& val, jobject_ref& jobj,
+       jclass_ref& jcls);
+
+extern OCTINTERP_API int
+unbox (JNIEnv* jni_env, const octave_value_list& args,
+       jobjectArray_ref& jobjs, jobjectArray_ref& jclss);
+
+extern OCTINTERP_API bool Vjava_matrix_autoconversion;
+
+extern OCTINTERP_API bool Vjava_unsigned_autoconversion;
+
+extern OCTINTERP_API bool Vdebug_java;
+
+class OCTINTERP_API octave_java : public octave_base_value
+{
+public:
+
+  octave_java (void)
+    : octave_base_value (), java_object (0), java_class (0)
+  { }
+
+  octave_java (const octave_java& jobj)
+    : octave_base_value (jobj), java_object (0), java_class (0)
+  {
+    init (jobj.java_object, jobj.java_class);
+  }
+
+  octave_java (const jobject& obj, jclass cls = 0)
+    : octave_base_value (), java_object (0)
+  {
+    init (obj, cls);
+  }
+
+  ~octave_java (void) { release (); }
+
+  jobject to_java (void) const { return java_object; }
+  jclass to_class (void) const { return java_class; }
+
+  std::string java_class_name (void) const { return java_classname; }
+
+  octave_base_value* clone (void) const { return new octave_java (*this); }
+  octave_base_value* empty_clone (void) const { return new octave_java (); }
+
+  bool is_defined (void) const { return true; }
+
+  bool is_map (void) const { return false; }
+
+  bool is_java (void) const { return true; }
+
+  string_vector map_keys (void) const;
+
+  dim_vector dims (void) const;
+
+  void print (std::ostream& os, bool pr_as_read_syntax = false) const
+  {
+    os << "<Java object: " << java_classname << ">";
+    newline(os);
+  }
+
+  void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const
+  {
+    print(os, pr_as_read_syntax);
+  }
+
+  octave_value_list
+  subsref (const std::string& type,
+           const std::list<octave_value_list>& idx, int nargout);
+
+  octave_value
+  subsref (const std::string& type, const std::list<octave_value_list>& idx)
+  {
+    octave_value_list retval = subsref (type, idx, 1);
+    return (retval.length () > 0 ? retval(0) : octave_value ());
+  }
+
+  octave_value subsasgn (const std::string& type,
+                         const std::list<octave_value_list>& idx,
+                         const octave_value& rhs);
+
+  octave_value convert_to_str_internal (bool pad, bool force, char type) const;
+
+  bool is_java_string (void) const;
+
+  static JNIEnv* thread_jni_env (void);
+
+  octave_value do_javaMethod (JNIEnv* jni_env, const std::string& name,
+                              const octave_value_list& args);
+
+  octave_value
+  do_javaMethod (const std::string& name, const octave_value_list& args)
+  {
+    return do_javaMethod(thread_jni_env (), name, args);
+  }
+
+  static octave_value
+  do_javaMethod (JNIEnv* jni_env, const std::string& class_name,
+                 const std::string& name, const octave_value_list& args);
+
+  static octave_value
+  do_javaMethod (const std::string& class_name, const std::string& name,
+                 const octave_value_list& args)
+  {
+    return do_javaMethod(thread_jni_env (), class_name, name, args);
+  }
+
+  static octave_value
+  do_javaObject (JNIEnv* jni_env, const std::string& name,
+                 const octave_value_list& args);
+
+  static octave_value
+  do_javaObject (const std::string& name, const octave_value_list& args)
+  {
+    return do_javaObject (thread_jni_env (), name, args);
+  }
+
+  octave_value do_java_get (JNIEnv* jni_env, const std::string& name);
+
+  octave_value do_java_get (const std::string& name)
+  {
+    return do_java_get (thread_jni_env (), name);
+  }
+
+  static octave_value
+  do_java_get (JNIEnv* jni_env, const std::string& class_name,
+               const std::string& name);
+
+  static octave_value
+  do_java_get (const std::string& class_name, const std::string& name)
+  {
+    return do_java_get (thread_jni_env (), class_name, name);
+  }
+
+  octave_value do_java_set (JNIEnv* jni_env, const std::string& name,
+                            const octave_value& val);
+
+  octave_value do_java_set (const std::string& name, const octave_value& val)
+  {
+    return do_java_set (thread_jni_env (), name, val);
+  }
+
+  static octave_value
+  do_java_set (JNIEnv* jni_env, const std::string& class_name,
+               const std::string& name, const octave_value& val);
+
+  static octave_value
+  do_java_set (const std::string& class_name, const std::string& name,
+               const octave_value& val)
+  {
+    return do_java_set (thread_jni_env (), class_name, name, val);
+  }
+
+private:
+
+  void init (jobject jobj, jclass jcls)
+  {
+    JNIEnv *current_env = thread_jni_env ();
+
+    if (current_env)
+      {
+        if (jobj)
+          java_object = current_env->NewGlobalRef (jobj);
+
+        if (jcls)
+          java_class = reinterpret_cast<jclass> (current_env->NewGlobalRef (jcls));
+        else if (java_object)
+          {
+            jclass_ref ocls (current_env, current_env->GetObjectClass (java_object));
+            java_class = reinterpret_cast<jclass> (current_env->NewGlobalRef (jclass (ocls)));
+          }
+
+        if (java_class)
+          {
+            jclass_ref clsCls (current_env, current_env->GetObjectClass (java_class));
+            jmethodID mID = current_env->GetMethodID (clsCls, "getCanonicalName", "()Ljava/lang/String;");
+            jobject_ref resObj (current_env, current_env->CallObjectMethod (java_class, mID));
+            java_classname = jstring_to_string (current_env, resObj);
+          }
+      }
+  }
+
+  void release (void)
+  {
+    JNIEnv *current_env = thread_jni_env ();
+
+    if (current_env)
+      {
+        if (java_object)
+          current_env->DeleteGlobalRef (java_object);
+
+        if (java_class)
+          current_env->DeleteGlobalRef (java_class);
+
+        java_object = 0;
+        java_class = 0;
+      }
+  }
+
+private:
+
+  jobject java_object;
+
+  jclass java_class;
+
+  std::string java_classname;
+
+  DECLARE_OCTAVE_ALLOCATOR
+
+public:
+  int type_id (void) const { return t_id; }
+  std::string type_name (void) const { return t_name; }
+  std::string class_name (void) const { return java_classname; }
+
+  static int static_type_id (void) { return t_id; }
+  static std::string static_type_name (void) { return t_name; }
+  static std::string static_class_name (void) { return "<unknown>"; }
+  static void register_type (void);
+
+private:
+  static int t_id;
+  static const std::string t_name;
+};
+
+#endif
diff --git a/libinterp/octave-value/ov-oncleanup.cc b/libinterp/octave-value/ov-oncleanup.cc
--- a/libinterp/octave-value/ov-oncleanup.cc
+++ b/libinterp/octave-value/ov-oncleanup.cc
@@ -187,17 +187,17 @@ octave_oncleanup::print_raw (std::ostrea
 DEFUN (onCleanup, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{c} =} onCleanup (@var{action})\n\
 Create a special object that executes a given function upon destruction.\n\
 If the object is copied to multiple variables (or cell or struct array\n\
 elements) or returned from a function, @var{action} will be executed after\n\
 clearing the last copy of the object.  Note that if multiple local onCleanup\n\
 variables are created, the order in which they are called is unspecified.\n\
-For similar functionality @xref{The @code{unwind_protect} Statement}.\n\
+For similar functionality @xref{The unwind_protect Statement}.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = octave_value (new octave_oncleanup (args(0)));
   else
     print_usage ();
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -901,16 +901,18 @@ octave_matrix::map (unary_mapper_t umap)
       ARRAY_MAPPER (asinh, double, ::asinh);
       ARRAY_MAPPER (atan, double, ::atan);
       RC_ARRAY_MAPPER (atanh, Complex, rc_atanh);
       ARRAY_MAPPER (erf, double, ::erf);
       ARRAY_MAPPER (erfinv, double, ::erfinv);
       ARRAY_MAPPER (erfcinv, double, ::erfcinv);
       ARRAY_MAPPER (erfc, double, ::erfc);
       ARRAY_MAPPER (erfcx, double, ::erfcx);
+      ARRAY_MAPPER (erfi, double, ::erfi);
+      ARRAY_MAPPER (dawson, double, ::dawson);
       ARRAY_MAPPER (gamma, double, xgamma);
       RC_ARRAY_MAPPER (lgamma, Complex, rc_lgamma);
       ARRAY_MAPPER (cbrt, double, ::cbrt);
       ARRAY_MAPPER (ceil, double, ::ceil);
       ARRAY_MAPPER (cos, double, ::cos);
       ARRAY_MAPPER (cosh, double, ::cosh);
       ARRAY_MAPPER (exp, double, ::exp);
       ARRAY_MAPPER (expm1, double, ::expm1);
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -907,16 +907,19 @@ octave_sparse_matrix::map (unary_mapper_
       ARRAY_MAPPER (asin, Complex, rc_asin);
       ARRAY_MAPPER (asinh, double, ::asinh);
       ARRAY_MAPPER (atan, double, ::atan);
       ARRAY_MAPPER (atanh, Complex, rc_atanh);
       ARRAY_MAPPER (erf, double, ::erf);
       ARRAY_MAPPER (erfinv, double, ::erfinv);
       ARRAY_MAPPER (erfcinv, double, ::erfcinv);
       ARRAY_MAPPER (erfc, double, ::erfc);
+      ARRAY_MAPPER (erfcx, double, ::erfcx);
+      ARRAY_MAPPER (erfi, double, ::erfi);
+      ARRAY_MAPPER (dawson, double, ::dawson);
       ARRAY_MAPPER (gamma, double, xgamma);
       ARRAY_MAPPER (lgamma, Complex, rc_lgamma);
       ARRAY_MAPPER (cbrt, double, ::cbrt);
       ARRAY_MAPPER (ceil, double, ::ceil);
       ARRAY_MAPPER (cos, double, ::cos);
       ARRAY_MAPPER (cosh, double, ::cosh);
       ARRAY_MAPPER (exp, double, ::exp);
       ARRAY_MAPPER (expm1, double, ::expm1);
diff --git a/libinterp/octave-value/ov-scalar.cc b/libinterp/octave-value/ov-scalar.cc
--- a/libinterp/octave-value/ov-scalar.cc
+++ b/libinterp/octave-value/ov-scalar.cc
@@ -306,16 +306,18 @@ octave_scalar::map (unary_mapper_t umap)
       SCALAR_MAPPER (asinh, ::asinh);
       SCALAR_MAPPER (atan, ::atan);
       SCALAR_MAPPER (atanh, rc_atanh);
       SCALAR_MAPPER (erf, ::erf);
       SCALAR_MAPPER (erfinv, ::erfinv);
       SCALAR_MAPPER (erfcinv, ::erfcinv);
       SCALAR_MAPPER (erfc, ::erfc);
       SCALAR_MAPPER (erfcx, ::erfcx);
+      SCALAR_MAPPER (erfi, ::erfi);
+      SCALAR_MAPPER (dawson, ::dawson);
       SCALAR_MAPPER (gamma, xgamma);
       SCALAR_MAPPER (lgamma, rc_lgamma);
       SCALAR_MAPPER (cbrt, ::cbrt);
       SCALAR_MAPPER (ceil, ::ceil);
       SCALAR_MAPPER (cos, ::cos);
       SCALAR_MAPPER (cosh, ::cosh);
       SCALAR_MAPPER (exp, ::exp);
       SCALAR_MAPPER (expm1, ::expm1);
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -80,17 +80,18 @@ octave_struct::dotref (const octave_valu
 
   octave_map::const_iterator p = map.seek (nm);
 
   if (p != map.end ())
     retval = map.contents (p);
   else if (auto_add)
     retval = (numel () == 0) ? Cell (dim_vector (1, 1)) : Cell (dims ());
   else
-    error ("structure has no member '%s'", nm.c_str ());
+    error_with_id ("Octave:invalid-indexing", 
+                   "structure has no member '%s'", nm.c_str ());
 
   return retval;
 }
 
 #if 0
 static void
 gripe_invalid_index1 (void)
 {
@@ -111,16 +112,32 @@ gripe_invalid_index_type (const std::str
 }
 
 static void
 gripe_failed_assignment (void)
 {
   error ("assignment to structure element failed");
 }
 
+static void
+maybe_warn_invalid_field_name (const std::string& key, const char *who)
+{
+  if (! valid_identifier (key))
+    {
+      if (who)
+        warning_with_id ("Octave:matlab-incompatible",
+                         "%s: invalid structure field name '%s'",
+                         who, key.c_str ());
+      else
+        warning_with_id ("Octave:matlab-incompatible",
+                         "invalid structure field name '%s'",
+                         key.c_str ());
+    }
+}
+
 octave_value_list
 octave_struct::subsref (const std::string& type,
                         const std::list<octave_value_list>& idx,
                         int nargout)
 {
   octave_value_list retval;
 
   int skip = 1;
@@ -300,16 +317,21 @@ octave_struct::subsasgn (const std::stri
                 octave_value_list t_idx = *p;
 
                 octave_value_list key_idx = *++p;
 
                 assert (key_idx.length () == 1);
 
                 std::string key = key_idx(0).string_value ();
 
+                maybe_warn_invalid_field_name (key, "subsasgn");
+
+                if (error_state)
+                  return retval;
+
                 std::list<octave_value_list> next_idx (idx);
 
                 // We handled two index elements, so subsasgn to
                 // needs to skip both of them.
 
                 next_idx.erase (next_idx.begin ());
                 next_idx.erase (next_idx.begin ());
 
@@ -358,16 +380,21 @@ octave_struct::subsasgn (const std::stri
         case '.':
           {
             octave_value_list key_idx = idx.front ();
 
             assert (key_idx.length () == 1);
 
             std::string key = key_idx(0).string_value ();
 
+            maybe_warn_invalid_field_name (key, "subsasgn");
+
+            if (error_state)
+              return retval;
+
             std::list<octave_value_list> next_idx (idx);
 
             next_idx.erase (next_idx.begin ());
 
             std::string next_type = type.substr (1);
 
             Cell tmpc (1, 1);
             octave_map::iterator pkey = map.seek (key);
@@ -426,16 +453,21 @@ octave_struct::subsasgn (const std::stri
                 std::list<octave_value_list>::const_iterator p = idx.begin ();
                 octave_value_list key_idx = *++p;
                 octave_value_list idxf = idx.front ();
 
                 assert (key_idx.length () == 1);
 
                 std::string key = key_idx(0).string_value ();
 
+                maybe_warn_invalid_field_name (key, "subsasgn");
+
+                if (error_state)
+                  return retval;
+
                 if (! error_state)
                   {
                     if (t_rhs.is_cs_list ())
                       {
                         Cell tmp_cell = Cell (t_rhs.list_value ());
 
                         // Inquire the proper shape of the RHS.
 
@@ -525,16 +557,21 @@ octave_struct::subsasgn (const std::stri
         case '.':
           {
             octave_value_list key_idx = idx.front ();
 
             assert (key_idx.length () == 1);
 
             std::string key = key_idx(0).string_value ();
 
+            maybe_warn_invalid_field_name (key, "subsasgn");
+
+            if (error_state)
+              return retval;
+
             if (t_rhs.is_cs_list ())
               {
                 Cell tmp_cell = Cell (t_rhs.list_value ());
 
                 // The shape of the RHS is irrelevant, we just want
                 // the number of elements to agree and to preserve the
                 // shape of the left hand side of the assignment.
 
@@ -1088,24 +1125,32 @@ octave_struct::fast_elem_insert (octave_
 }
 DEFINE_OCTAVE_ALLOCATOR(octave_scalar_struct);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA(octave_scalar_struct, "scalar struct", "struct");
 
 octave_value
 octave_scalar_struct::dotref (const octave_value_list& idx, bool auto_add)
 {
+  octave_value retval;
+
   assert (idx.length () == 1);
 
   std::string nm = idx(0).string_value ();
 
-  octave_value retval = map.getfield (nm);
+  maybe_warn_invalid_field_name (nm, "subsref");
+
+  if (error_state)
+    return retval;
+
+  retval = map.getfield (nm);
 
   if (! auto_add && retval.is_undefined ())
-    error ("structure has no member '%s'", nm.c_str ());
+    error_with_id ("Octave:invalid-indexing",
+                   "structure has no member '%s'", nm.c_str ());
 
   return retval;
 }
 
 octave_value
 octave_scalar_struct::subsref (const std::string& type,
                                const std::list<octave_value_list>& idx)
 {
@@ -1213,16 +1258,21 @@ octave_scalar_struct::subsasgn (const st
       octave_value t_rhs = rhs;
 
       octave_value_list key_idx = idx.front ();
 
       assert (key_idx.length () == 1);
 
       std::string key = key_idx(0).string_value ();
 
+      maybe_warn_invalid_field_name (key, "subsasgn");
+
+      if (error_state)
+        return retval;
+
       if (n > 1)
         {
           std::list<octave_value_list> next_idx (idx);
 
           next_idx.erase (next_idx.begin ());
 
           std::string next_type = type.substr (1);
 
@@ -1694,27 +1744,65 @@ octave_scalar_struct::fast_elem_insert_s
       return true;
     }
   else
     return false;
 }
 
 DEFUN (struct, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} struct (\"field\", @var{value}, \"field\", @var{value}, @dots{})\n\
+@deftypefn {Built-in Function} {} struct (@var{field1}, @var{value1}, @var{field2}, @var{value2}, @dots{})\n\
 \n\
-Create a structure and initialize its value.\n\
+Create a scalar or array structure and initialize its values. The\n\
+@var{field1}, @var{field2}, @dots{} variables are strings giving the\n\
+names of the fields and the @var{value1}, @var{value2}, @dots{}\n\
+variables can be any type.\n\
 \n\
 If the values are cell arrays, create a structure array and initialize\n\
 its values.  The dimensions of each cell array of values must match.\n\
 Singleton cells and non-cell values are repeated so that they fill\n\
 the entire array.  If the cells are empty, create an empty structure\n\
 array with the specified field names.\n\
 \n\
 If the argument is an object, return the underlying struct.\n\
+\n\
+Observe that the syntax is optimized for struct @strong{arrays}. Consider the\n\
+following examples:\n\
+\n\
+@example\n\
+@group\n\
+struct (\"foo\", 1)\n\
+  @result{} scalar structure containing the fields:\n\
+    foo =  1\n\
+\n\
+struct (\"foo\", @{@})\n\
+  @result{} 0x0 struct array containing the fields:\n\
+    foo\n\
+\n\
+struct (\"foo\", @{ @{@} @})\n\
+  @result{} scalar structure containing the fields:\n\
+    foo = @{@}(0x0)\n\
+\n\
+struct (\"foo\", @{1, 2, 3@})\n\
+  @result{} 1x3 struct array containing the fields:\n\
+    foo\n\
+\n\
+@end group\n\
+@end example\n\
+\n\
+@noindent\n\
+The first case is an ordinary scalar struct, one field, one value. The\n\
+second produces an empty struct array with one field and no values, since\n\
+s being passed an empty cell array of struct array values. When the value is\n\
+a cell array containing a single entry, this becomes a scalar struct with\n\
+that single entry as the value of the field. That single entry happens\n\
+to be an empty cell array.\n\
+\n\
+Finally, if the value is a non-scalar cell array, then @code{struct}\n\
+produces a struct @strong{array}.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   // struct ([]) returns an empty struct.
 
@@ -1800,21 +1888,20 @@ If the argument is an object, return the
     {
       // Get key.
 
       std::string key (args(i).string_value ());
 
       if (error_state)
         return retval;
 
-      if (! valid_identifier (key))
-        {
-          error ("struct: invalid structure field name '%s'", key.c_str ());
-          return retval;
-        }
+      maybe_warn_invalid_field_name (key, "struct");
+
+      if (error_state)
+        return retval;
 
       // Value may be v, { v }, or { v1, v2, ... }
       // In the first two cases, we need to create a cell array of
       // the appropriate dimensions filled with v.  In the last case,
       // the cell array has already been determined to be of the
       // correct dimensions.
 
       if (args(i+1).is_cell ())
@@ -1871,59 +1958,43 @@ Return true if @var{x} is a structure or
   if (args.length () == 1)
     retval = args(0).is_map ();
   else
     print_usage ();
 
   return retval;
 }
 
-DEFUN (fieldnames, args, ,
+DEFUN (__fieldnames__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} fieldnames (@var{struct})\n\
-Return a cell array of strings naming the elements of the structure\n\
-@var{struct}.  It is an error to call @code{fieldnames} with an\n\
-argument that is not a structure.\n\
+@deftypefn  {Built-in Function} {} __fieldnames__ (@var{struct})\n\
+@deftypefnx {Built-in Function} {} __fieldnames__ (@var{obj})\n\
+Internal function.\n\
+\n\
+Implements @code{fieldnames()} for structures and Octave objects.\n\
+@seealso{fieldnames}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length ();
-
-  if (nargin == 1)
-    {
-      octave_value arg = args(0);
-
-      if (arg.is_map () || arg.is_object ())
-        {
-          octave_map m = arg.map_value ();
-
-          string_vector keys = m.fieldnames ();
-
-          if (keys.length () == 0)
-            retval = Cell (0, 1);
-          else
-            retval = Cell (keys);
-        }
-      else
-        gripe_wrong_type_arg ("fieldnames", args(0));
-    }
+  // Input validation has already been done in fieldnames.m.
+  octave_value arg = args(0);
+
+  octave_map m = arg.map_value ();
+
+  string_vector keys = m.fieldnames ();
+
+  if (keys.length () == 0)
+    retval = Cell (0, 1);
   else
-    print_usage ();
+    retval = Cell (keys);
 
   return retval;
 }
 
-/*
-## test preservation of fieldname order
-%!test
-%! x(3).d=1;  x(2).a=2; x(1).b=3;  x(2).c=3;
-%! assert (fieldnames (x), {"d"; "a"; "b"; "c"});
-*/
-
 DEFUN (isfield, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isfield (@var{x}, @var{name})\n\
 Return true if the @var{x} is a structure and it\n\
 includes an element named @var{name}.  If @var{name} is a cell\n\
 array of strings then a logical array of equal dimension is returned.\n\
 @end deftypefn")
 {
diff --git a/libinterp/octave-value/ov-typeinfo.cc b/libinterp/octave-value/ov-typeinfo.cc
--- a/libinterp/octave-value/ov-typeinfo.cc
+++ b/libinterp/octave-value/ov-typeinfo.cc
@@ -698,10 +698,19 @@ currently installed data types.\n\
 %!test
 %! [l, u, p] = lu (rand (3));
 %! assert (typeinfo (p), "permutation matrix");
 
 %!assert (typeinfo ([]), "null_matrix")
 %!assert (typeinfo (""), "null_string")
 %!assert (typeinfo (''), "null_sq_string")
 
+%!test
+%! cvar = onCleanup (@() "");
+%! assert (typeinfo (cvar), "onCleanup");
+
+%!testif HAVE_JAVA
+%! x = javaObject ("java.lang.StringBuffer");
+%! assert (typeinfo (x), "octave_java");
+
+## Test input validation
 %!error typeinfo ("foo", 1)
 */
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -377,17 +377,17 @@ octave_user_function::do_multi_index_op 
 
   if (error_state)
     return retval;
 
   if (! cmd_list)
     return retval;
 
 #ifdef HAVE_LLVM
-  if (Venable_jit_compiler && is_special_expr ()
+  if (is_special_expr ()
       && tree_jit::execute (*this, args, retval))
     return retval;
 #endif
 
   int nargin = args.length ();
 
   unwind_protect frame;
 
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -72,16 +72,19 @@ along with Octave; see the file COPYING.
 #include "ov-builtin.h"
 #include "ov-dld-fcn.h"
 #include "ov-usr-fcn.h"
 #include "ov-fcn-handle.h"
 #include "ov-fcn-inline.h"
 #include "ov-typeinfo.h"
 #include "ov-null-mat.h"
 #include "ov-lazy-idx.h"
+#ifdef HAVE_JAVA
+#include "ov-java.h"
+#endif
 
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "pager.h"
 #include "parse.h"
 #include "pr-output.h"
 #include "symtab.h"
@@ -2750,16 +2753,19 @@ install_types (void)
   octave_float_complex_matrix::register_type ();
   octave_float_complex_diag_matrix::register_type ();
   octave_perm_matrix::register_type ();
   octave_null_matrix::register_type ();
   octave_null_str::register_type ();
   octave_null_sq_str::register_type ();
   octave_lazy_index::register_type ();
   octave_oncleanup::register_type ();
+#ifdef HAVE_JAVA
+  octave_java::register_type ();
+#endif
 }
 
 DEFUN (sizeof, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} sizeof (@var{val})\n\
 Return the size of @var{val} in bytes.\n\
 @seealso{whos}\n\
 @end deftypefn")
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -558,16 +558,19 @@ public:
     { return rep->is_range (); }
 
   bool is_map (void) const
     { return rep->is_map (); }
 
   bool is_object (void) const
     { return rep->is_object (); }
 
+  bool is_java (void) const
+    { return rep->is_java (); }
+
   bool is_cs_list (void) const
     { return rep->is_cs_list (); }
 
   bool is_magic_colon (void) const
     { return rep->is_magic_colon (); }
 
   bool is_null_value (void) const
     { return rep->is_null_value (); }
@@ -1121,16 +1124,18 @@ public:
   MAPPER_FORWARD (conj)
   MAPPER_FORWARD (cos)
   MAPPER_FORWARD (cosh)
   MAPPER_FORWARD (erf)
   MAPPER_FORWARD (erfinv)
   MAPPER_FORWARD (erfcinv)
   MAPPER_FORWARD (erfc)
   MAPPER_FORWARD (erfcx)
+  MAPPER_FORWARD (erfi)
+  MAPPER_FORWARD (dawson)
   MAPPER_FORWARD (exp)
   MAPPER_FORWARD (expm1)
   MAPPER_FORWARD (finite)
   MAPPER_FORWARD (fix)
   MAPPER_FORWARD (floor)
   MAPPER_FORWARD (gamma)
   MAPPER_FORWARD (imag)
   MAPPER_FORWARD (isinf)
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -167,16 +167,19 @@ static const char *usage_string =
 static const char *short_opts = "+HVdfhip:qvx";
 
 // The code to evaluate at startup (--eval CODE)
 static std::string code_to_eval;
 
 // If TRUE, don't exit after evaluating code given by --eval option.
 static bool persist = false;
 
+// If TRUE, the GUI should be started.
+static bool start_gui = false;
+
 // Long options.  See the comments in getopt.h for the meanings of the
 // fields in this structure.
 #define BUILT_IN_DOCSTRINGS_FILE_OPTION 1
 #define DOC_CACHE_FILE_OPTION 2
 #define EVAL_OPTION 3
 #define EXEC_PATH_OPTION 4
 #define FORCE_GUI_OPTION 5
 #define IMAGE_PATH_OPTION 6
@@ -1026,21 +1029,18 @@ octave_execute_interpreter (void)
 
   quitting_gracefully = true;
 
   clean_up_and_exit (retval);
 
   return 0;
 }
 
-// Return int instead of bool because this function is declared
-// extern "C".
-
-int
-octave_starting_gui (void)
+static bool
+check_starting_gui (void)
 {
   if (no_window_system || ! display_info::display_available ())
     return false;
 
   if (force_gui_option)
     return true;
 
   if (no_gui_option)
@@ -1065,16 +1065,47 @@ octave_starting_gui (void)
   int remaining_args = octave_cmdline_argc - last_arg_idx;
 
   if (! code_to_eval.empty () || remaining_args > 0)
     return false;
 
   return true;
 }
 
+// Return int instead of bool because this function is declared
+// extern "C".
+
+int
+octave_starting_gui (void)
+{
+  start_gui = check_starting_gui ();
+  return start_gui;
+}
+
+DEFUN (isguirunning, args, ,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} isguirunning ()\n\
+Return true if Octave is running in GUI mode and false otherwise.\n\
+@end deftypefn")
+{
+  octave_value retval;
+
+  if (args.length () == 0)
+    retval = start_gui;
+  else
+    print_usage ();
+
+  return retval;
+}
+
+/*
+%!assert (islogical (isguirunning ()))
+%!error isguirunning (1)
+*/
+
 DEFUN (argv, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} argv ()\n\
 Return the command line arguments passed to Octave.  For example,\n\
 if you invoked Octave using the command\n\
 \n\
 @example\n\
 octave --no-line-editing --silent\n\
diff --git a/libinterp/parse-tree/pt-assign.cc b/libinterp/parse-tree/pt-assign.cc
--- a/libinterp/parse-tree/pt-assign.cc
+++ b/libinterp/parse-tree/pt-assign.cc
@@ -33,16 +33,17 @@ along with Octave; see the file COPYING.
 #include "input.h"
 #include "oct-obj.h"
 #include "oct-lvalue.h"
 #include "pager.h"
 #include "ov.h"
 #include "pt-arg-list.h"
 #include "pt-bp.h"
 #include "pt-assign.h"
+#include "pt-eval.h"
 #include "pt-walk.h"
 #include "utils.h"
 #include "variables.h"
 
 // Simple assignment expressions.
 
 // FIXME -- the following variable and the function that uses it
 // should be removed from some future version of Octave.
@@ -242,17 +243,18 @@ tree_simple_assignment::rvalue1 (int)
 
                   if (! error_state)
                     {
                       if (etype == octave_value::op_asn_eq)
                         retval = rhs_val;
                       else
                         retval = ult.value ();
 
-                      if (print_result ())
+                      if (print_result ()
+                          && tree_evaluator::statement_printing_enabled ())
                         {
                           // We clear any index here so that we can
                           // get the new value of the referenced
                           // object below, instead of the indexed
                           // value (which should be the same as the
                           // right hand side value).
 
                           ult.clear_index ();
@@ -454,17 +456,18 @@ tree_multi_assignment::rvalue (int)
                     }
                   else
                     error ("element number %d undefined in return list", k+1);
                 }
             }
 
           if (error_state)
             break;
-          else if (print_result ())
+          else if (print_result ()
+                   && tree_evaluator::statement_printing_enabled ())
             {
               // We clear any index here so that we can get
               // the new value of the referenced object below,
               // instead of the indexed value (which should be
               // the same as the right hand side value).
 
               ult.clear_index ();
 
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -127,16 +127,23 @@ tree_evaluator::visit_continue_command (
 void
 tree_evaluator::reset_debug_state (void)
 {
   debug_mode = bp_table::have_breakpoints () || Vdebugging;
 
   dbstep_flag = 0;
 }
 
+bool
+tree_evaluator::statement_printing_enabled (void)
+{
+  return ! (Vsilent_functions && (statement_context == function
+                                  || statement_context == script));
+}
+
 static inline void
 do_global_init (tree_decl_elt& elt)
 {
   tree_identifier *id = elt.ident ();
 
   if (id)
     {
       id->mark_global ();
@@ -302,17 +309,17 @@ tree_evaluator::visit_simple_for_command
 
   in_loop_command = true;
 
   tree_expression *expr = cmd.control_expr ();
 
   octave_value rhs = expr->rvalue1 ();
 
 #if HAVE_LLVM
-  if (Venable_jit_compiler && tree_jit::execute (cmd, rhs))
+  if (tree_jit::execute (cmd, rhs))
     return;
 #endif
 
   if (error_state || rhs.is_undefined ())
     return;
 
   {
     tree_expression *lhs = cmd.left_hand_side ();
@@ -718,20 +725,16 @@ tree_evaluator::visit_statement (tree_st
         {
           if (cmd)
             cmd->accept (*this);
           else
             {
               if (debug_mode)
                 do_breakpoint (expr->is_breakpoint ());
 
-              if ((statement_context == function || statement_context == script)
-                  && Vsilent_functions)
-                expr->set_print_flag (false);
-
               // FIXME -- maybe all of this should be packaged in
               // one virtual function that returns a flag saying whether
               // or not the expression will take care of binding ans and
               // printing the result.
 
               // FIXME -- it seems that we should just have to
               // call expr->rvalue1 () and that should take care of
               // everything, binding ans as necessary?
@@ -745,17 +748,18 @@ tree_evaluator::visit_statement (tree_st
                   do_bind_ans = (! id->is_variable ());
                 }
               else
                 do_bind_ans = (! expr->is_assignment_expression ());
 
               octave_value tmp_result = expr->rvalue1 (0);
 
               if (do_bind_ans && ! (error_state || tmp_result.is_undefined ()))
-                bind_ans (tmp_result, expr->print_result ());
+                bind_ans (tmp_result, expr->print_result ()
+                          && statement_printing_enabled ());
 
               //              if (tmp_result.is_defined ())
               //                result_values(0) = tmp_result;
             }
         }
       catch (octave_execution_exception)
         {
           gripe_library_execution_error ();
@@ -1045,17 +1049,17 @@ tree_evaluator::visit_unwind_protect_com
 
 void
 tree_evaluator::visit_while_command (tree_while_command& cmd)
 {
   if (error_state)
     return;
 
 #if HAVE_LLVM
-  if (Venable_jit_compiler && tree_jit::execute (cmd))
+  if (tree_jit::execute (cmd))
     return;
 #endif
 
   unwind_protect frame;
 
   frame.protect_var (in_loop_command);
 
   in_loop_command = true;
@@ -1137,59 +1141,55 @@ tree_evaluator::do_breakpoint (tree_stat
 }
 
 void
 tree_evaluator::do_breakpoint (bool is_breakpoint,
                                bool is_end_of_fcn_or_script) const
 {
   bool break_on_this_statement = false;
 
-  // Don't decrement break flag unless we are in the same frame as we
-  // were when we saw the "dbstep N" command.
-
-  if (dbstep_flag > 1)
-    {
-      if (octave_call_stack::current_frame () == current_frame)
-        {
-          // Don't allow dbstep N to step past end of current frame.
-
-          if (is_end_of_fcn_or_script)
-            dbstep_flag = 1;
-          else
-            dbstep_flag--;
-        }
-    }
-
   if (octave_debug_on_interrupt_state)
     {
       break_on_this_statement = true;
 
       octave_debug_on_interrupt_state = false;
 
       current_frame = octave_call_stack::current_frame ();
     }
   else if (is_breakpoint)
     {
       break_on_this_statement = true;
 
       dbstep_flag = 0;
 
       current_frame = octave_call_stack::current_frame ();
     }
-  else if (dbstep_flag == 1)
+  else if (dbstep_flag > 0)
     {
       if (octave_call_stack::current_frame () == current_frame)
         {
-          // We get here if we are doing a "dbstep" or a "dbstep N"
-          // and the count has reached 1 and we are in the current
-          // debugging frame.
+          if (dbstep_flag == 1 || is_end_of_fcn_or_script)
+            {
+              // We get here if we are doing a "dbstep" or a "dbstep N" and the
+              // count has reached 1 so that we must stop and return to debug
+              // prompt.  Alternatively, "dbstep N" has been used but the end
+              // of the frame has been reached so we stop at the last line and
+              // return to prompt.
+
+              break_on_this_statement = true;
 
-          break_on_this_statement = true;
+              dbstep_flag = 0;
+            }
+          else
+            {
+              // Executing "dbstep N".  Decrease N by one and continue.
 
-          dbstep_flag = 0;
+              dbstep_flag--;
+            }
+
         }
     }
   else if (dbstep_flag == -1)
     {
       // We get here if we are doing a "dbstep in".
 
       break_on_this_statement = true;
 
diff --git a/libinterp/parse-tree/pt-eval.h b/libinterp/parse-tree/pt-eval.h
--- a/libinterp/parse-tree/pt-eval.h
+++ b/libinterp/parse-tree/pt-eval.h
@@ -133,16 +133,18 @@ public:
   void visit_unwind_protect_command (tree_unwind_protect_command&);
 
   void visit_while_command (tree_while_command&);
 
   void visit_do_until_command (tree_do_until_command&);
 
   static void reset_debug_state (void);
 
+  static bool statement_printing_enabled (void);
+
   // If > 0, stop executing at the (N-1)th stopping point, counting
   //         from the the current execution point in the current frame.
   //
   // If < 0, stop executing at the next possible stopping point.
   static int dbstep_flag;
 
   // The number of the stack frame we are currently debugging.
   static size_t current_frame;
diff --git a/libinterp/parse-tree/pt-exp.h b/libinterp/parse-tree/pt-exp.h
--- a/libinterp/parse-tree/pt-exp.h
+++ b/libinterp/parse-tree/pt-exp.h
@@ -82,16 +82,19 @@ public:
                                     const std::list<octave_lvalue> *lvalue_list);
 
   virtual octave_lvalue lvalue (void);
 
   int paren_count (void) const { return num_parens; }
 
   bool is_postfix_indexed (void) const { return postfix_indexed; }
 
+  // Check if the result of the expression should be printed.
+  // Should normally be used in conjunction with
+  // tree_evaluator::statement_printing_enabled.
   bool print_result (void) const { return print_flag; }
 
   virtual std::string oper (void) const { return "<unknown>"; }
 
   virtual std::string name (void) const { return "<unknown>"; }
 
   virtual std::string original_text (void) const;
 
diff --git a/libinterp/parse-tree/pt-id.cc b/libinterp/parse-tree/pt-id.cc
--- a/libinterp/parse-tree/pt-id.cc
+++ b/libinterp/parse-tree/pt-id.cc
@@ -25,16 +25,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #include "error.h"
 #include "oct-obj.h"
 #include "oct-lvalue.h"
 #include "pager.h"
 #include "pt-bp.h"
 #include "pt-const.h"
+#include "pt-eval.h"
 #include "pt-id.h"
 #include "pt-walk.h"
 #include "symtab.h"
 #include "utils.h"
 #include "variables.h"
 
 // Symbols from the symbol table.
 
@@ -83,17 +84,18 @@ tree_identifier::rvalue (int nargout)
       if (val.is_function () && ! is_postfix_indexed ())
         {
           octave_value_list tmp_args;
 
           retval = val.do_multi_index_op (nargout, tmp_args);
         }
       else
         {
-          if (print_result () && nargout == 0)
+          if (print_result () && nargout == 0
+              && tree_evaluator::statement_printing_enabled ())
             val.print_with_name (octave_stdout, name ());
 
           retval = val;
         }
     }
   else if (sym->is_added_static ())
     static_workspace_error ();
   else
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -211,22 +211,17 @@ tree_index_expression::get_struct_index
     {
       tree_expression *df = *p_dyn_field;
 
       if (df)
         {
           octave_value t = df->rvalue1 ();
 
           if (! error_state)
-            {
-              fn = t.string_value ();
-
-              if (! valid_identifier (fn))
-                ::error ("invalid structure field name '%s'", fn.c_str ());
-            }
+            fn = t.string_value ();
         }
       else
         panic_impossible ();
     }
 
   return fn;
 }
 
diff --git a/liboctave/Makefile.am b/liboctave/Makefile.am
--- a/liboctave/Makefile.am
+++ b/liboctave/Makefile.am
@@ -80,17 +80,17 @@ include numeric/module.mk
 include operators/module.mk
 include system/module.mk
 include util/module.mk
 
 ## liboctave merely collects a bunch of compiled convenience libraries.
 ## It has no source code itself.
 liboctave_la_SOURCES = 
 
-liboctave_la_CPPFLAGS = @OCTAVE_DLL_DEFS@ $(AM_CPPFLAGS)
+liboctave_la_CPPFLAGS = @OCTAVE_DLL_DEFS@ @CRUFT_DLL_DEFS@ $(AM_CPPFLAGS)
 
 include link-deps.mk
 
 # Dummy C++ source to force C++ linking.
 nodist_EXTRA_liboctave_la_SOURCES = dummy.cc
 
 liboctave_la_LIBADD = \
   array/libarray.la \
@@ -108,13 +108,14 @@ liboctave_current = 1
 liboctave_revision = 1
 liboctave_age = 0
 
 liboctave_version_info = $(liboctave_current):$(liboctave_revision):$(liboctave_age)
 
 liboctave_la_LDFLAGS = \
   -version-info $(liboctave_version_info) \
   $(NO_UNDEFINED_LDFLAG) \
+  @XTRA_CRUFT_SH_LDFLAGS@ \
   -bindir $(bindir) \
   $(LIBOCTAVE_LINK_OPTS)
 
 DISTCLEANFILES += $(BUILT_INCS)
 
diff --git a/liboctave/array/Sparse.h b/liboctave/array/Sparse.h
--- a/liboctave/array/Sparse.h
+++ b/liboctave/array/Sparse.h
@@ -82,22 +82,22 @@ protected:
       : d (0), r (0), c (new octave_idx_type [n+1]), nzmx (0), nrows (n),
       ncols (n), count (1)
       {
         for (octave_idx_type i = 0; i < n + 1; i++)
           c[i] = 0;
       }
 
     SparseRep (octave_idx_type nr, octave_idx_type nc, octave_idx_type nz = 0)
-      : d (new T [nz]), r (new octave_idx_type [nz]),
+      : d (nz > 0 ? new T [nz] : 0),
+      r (nz > 0 ? new octave_idx_type [nz] : 0),
       c (new octave_idx_type [nc+1]), nzmx (nz), nrows (nr),
       ncols (nc), count (1)
       {
-        c[nc] = nz;
-        for (octave_idx_type i = 0; i < nc; i++)
+        for (octave_idx_type i = 0; i < nc + 1; i++)
           c[i] = 0;
       }
 
     SparseRep (const SparseRep& a)
       : d (new T [a.nzmx]), r (new octave_idx_type [a.nzmx]),
       c (new octave_idx_type [a.ncols + 1]),
       nzmx (a.nzmx), nrows (a.nrows), ncols (a.ncols), count (1)
       {
diff --git a/liboctave/cruft/Faddeeva/Faddeeva.cc b/liboctave/cruft/Faddeeva/Faddeeva.cc
new file mode 100644
--- /dev/null
+++ b/liboctave/cruft/Faddeeva/Faddeeva.cc
@@ -0,0 +1,2515 @@
+//  -*- mode:c++; tab-width:2; indent-tabs-mode:nil;  -*-
+
+/* Copyright (c) 2012 Massachusetts Institute of Technology
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ */
+
+/* (Note that this file can be compiled with either C++, in which
+    case it uses C++ std::complex<double>, or C, in which case it
+    uses C99 double complex.) */
+
+/* Available at: http://ab-initio.mit.edu/Faddeeva
+
+   Computes various error functions (erf, erfc, erfi, erfcx), 
+   including the Dawson integral, in the complex plane, based
+   on algorithms for the computation of the Faddeeva function 
+              w(z) = exp(-z^2) * erfc(-i*z).
+   Given w(z), the error functions are mostly straightforward
+   to compute, except for certain regions where we have to
+   switch to Taylor expansions to avoid cancellation errors
+   [e.g. near the origin for erf(z)].
+
+   To compute the Faddeeva function, we use a combination of two
+   algorithms:
+
+   For sufficiently large |z|, we use a continued-fraction expansion
+   for w(z) similar to those described in:
+
+      Walter Gautschi, "Efficient computation of the complex error
+      function," SIAM J. Numer. Anal. 7(1), pp. 187-198 (1970)
+
+      G. P. M. Poppe and C. M. J. Wijers, "More efficient computation
+      of the complex error function," ACM Trans. Math. Soft. 16(1),
+      pp. 38-46 (1990).
+
+   Unlike those papers, however, we switch to a completely different
+   algorithm for smaller |z|:
+
+      Mofreh R. Zaghloul and Ahmed N. Ali, "Algorithm 916: Computing the
+      Faddeyeva and Voigt Functions," ACM Trans. Math. Soft. 38(2), 15
+      (2011).
+
+   (I initially used this algorithm for all z, but it turned out to be
+    significantly slower than the continued-fraction expansion for
+    larger |z|.  On the other hand, it is competitive for smaller |z|, 
+    and is significantly more accurate than the Poppe & Wijers code
+    in some regions, e.g. in the vicinity of z=1+1i.)
+
+   Note that this is an INDEPENDENT RE-IMPLEMENTATION of these algorithms,
+   based on the description in the papers ONLY.  In particular, I did
+   not refer to the authors' Fortran or Matlab implementations, respectively,
+   (which are under restrictive ACM copyright terms and therefore unusable
+    in free/open-source software).
+
+   Steven G. Johnson, Massachusetts Institute of Technology
+   http://math.mit.edu/~stevenj
+   October 2012.
+
+    -- Note that Algorithm 916 assumes that the erfc(x) function, 
+       or rather the scaled function erfcx(x) = exp(x*x)*erfc(x),
+       is supplied for REAL arguments x.   I originally used an
+       erfcx routine derived from DERFC in SLATEC, but I have
+       since replaced it with a much faster routine written by
+       me which uses a combination of continued-fraction expansions
+       and a lookup table of Chebyshev polynomials.  For speed,
+       I implemented a similar algorithm for Im[w(x)] of real x,
+       since this comes up frequently in the other error functions.
+
+   A small test program is included the end, which checks
+   the w(z) etc. results against several known values.  To compile
+   the test function, compile with -DTEST_FADDEEVA (that is,
+   #define TEST_FADDEEVA).
+
+   If HAVE_CONFIG_H is #defined (e.g. by compiling with -DHAVE_CONFIG_H),
+   then we #include "config.h", which is assumed to be a GNU autoconf-style
+   header defining HAVE_* macros to indicate the presence of features. In
+   particular, if HAVE_ISNAN and HAVE_ISINF are #defined, we use those
+   functions in math.h instead of defining our own, and if HAVE_ERF and/or
+   HAVE_ERFC are defined we use those functions from <cmath> for erf and
+   erfc of real arguments, respectively, instead of defining our own.
+
+   REVISION HISTORY:
+       4 October 2012: Initial public release (SGJ)
+       5 October 2012: Revised (SGJ) to fix spelling error,
+                       start summation for large x at round(x/a) (> 1)
+                       rather than ceil(x/a) as in the original
+                       paper, which should slightly improve performance
+                       (and, apparently, slightly improves accuracy)
+      19 October 2012: Revised (SGJ) to fix bugs for large x, large -y,
+                       and 15<x<26. Performance improvements. Prototype
+                       now supplies default value for relerr.
+      24 October 2012: Switch to continued-fraction expansion for
+                       sufficiently large z, for performance reasons.
+                       Also, avoid spurious overflow for |z| > 1e154.
+                       Set relerr argument to min(relerr,0.1).
+      27 October 2012: Enhance accuracy in Re[w(z)] taken by itself,
+                       by switching to Alg. 916 in a region near
+                       the real-z axis where continued fractions
+                       have poor relative accuracy in Re[w(z)].  Thanks
+                       to M. Zaghloul for the tip.
+      29 October 2012: Replace SLATEC-derived erfcx routine with
+                       completely rewritten code by me, using a very
+                       different algorithm which is much faster.
+      30 October 2012: Implemented special-case code for real z
+                       (where real part is exp(-x^2) and imag part is
+                        Dawson integral), using algorithm similar to erfx.
+                       Export ImFaddeeva_w function to make Dawson's
+                       integral directly accessible.
+      3 November 2012: Provide implementations of erf, erfc, erfcx,
+                       and Dawson functions in Faddeeva:: namespace,
+                       in addition to Faddeeva::w.  Provide header
+                       file Faddeeva.hh.
+      4 November 2012: Slightly faster erf for real arguments.
+                       Updated MATLAB and Octave plugins.
+     27 November 2012: Support compilation with either C++ or
+                       plain C (using C99 complex numbers).
+                       For real x, use standard-library erf(x)
+                       and erfc(x) if available (for C99 or C++11).
+                       #include "config.h" if HAVE_CONFIG_H is #defined.
+     15 December 2012: Portability fixes (copysign, Inf/NaN creation),
+                       use CMPLX/__builtin_complex if available in C,
+                       slight accuracy improvements to erf and dawson
+                       functions near the origin.  Use gnulib functions
+                       if GNULIB_NAMESPACE is defined.
+*/
+
+/////////////////////////////////////////////////////////////////////////
+/* If this file is compiled as a part of a larger project,
+   support using an autoconf-style config.h header file
+   (with various "HAVE_*" #defines to indicate features)
+   if HAVE_CONFIG_H is #defined (in GNU autotools style). */
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+/////////////////////////////////////////////////////////////////////////
+// macros to allow us to use either C++ or C (with C99 features)
+
+#ifdef __cplusplus
+
+#  include "Faddeeva.hh"
+
+#  include <cfloat>
+#  include <cmath>
+#  include <limits>
+using namespace std;
+
+// use std::numeric_limits, since 1./0. and 0./0. fail with some compilers (MS)
+#  define Inf numeric_limits<double>::infinity()
+#  define NaN numeric_limits<double>::quiet_NaN()
+
+typedef complex<double> cmplx;
+
+// Use C-like complex syntax, since the C syntax is more restrictive
+#  define cexp(z) exp(z)
+#  define creal(z) real(z)
+#  define cimag(z) imag(z)
+#  define cpolar(r,t) polar(r,t)
+
+#  define C(a,b) cmplx(a,b)
+
+#  define FADDEEVA(name) Faddeeva::name
+#  define FADDEEVA_RE(name) Faddeeva::name
+
+// isnan/isinf were introduced in C++11
+#  if (__cplusplus < 201103L) && (!defined(HAVE_ISNAN) || !defined(HAVE_ISINF))
+static inline bool my_isnan(double x) { return x != x; }
+#    define isnan my_isnan
+static inline bool my_isinf(double x) { return 1/x == 0.; }
+#    define isinf my_isinf
+#  elif (__cplusplus >= 201103L)
+// g++ gets confused between the C and C++ isnan/isinf functions
+#    define isnan std::isnan
+#    define isinf std::isinf
+#  endif
+
+// copysign was introduced in C++11 (and is also in POSIX and C99)
+#  if defined(_WIN32) || defined(__WIN32__)
+#    define copysign _copysign // of course MS had to be different
+#  elif defined(GNULIB_NAMESPACE) // we are using using gnulib <cmath>
+#    define copysign GNULIB_NAMESPACE::copysign
+#  elif (__cplusplus < 201103L) && !defined(HAVE_COPYSIGN) && !defined(__linux__) && !(defined(__APPLE__) && defined(__MACH__)) && !defined(_AIX)
+static inline double my_copysign(double x, double y) { return y<0 ? -x : x; }
+#    define copysign my_copysign
+#  endif
+
+// If we are using the gnulib <cmath> (e.g. in the GNU Octave sources),
+// gnulib generates a link warning if we use ::floor instead of gnulib::floor.
+// This warning is completely innocuous because the only difference between
+// gnulib::floor and the system ::floor (and only on ancient OSF systems)
+// has to do with floor(-0), which doesn't occur in the usage below, but
+// the Octave developers prefer that we silence the warning.
+#  ifdef GNULIB_NAMESPACE
+#    define floor GNULIB_NAMESPACE::floor
+#  endif
+
+#else // !__cplusplus, i.e. pure C (requires C99 features)
+
+#  include "Faddeeva.h"
+
+#  define _GNU_SOURCE // enable GNU libc NAN extension if possible
+
+#  include <float.h>
+#  include <math.h>
+
+typedef double complex cmplx;
+
+#  define FADDEEVA(name) Faddeeva_ ## name
+#  define FADDEEVA_RE(name) Faddeeva_ ## name ## _re
+
+/* Constructing complex numbers like 0+i*NaN is problematic in C99
+   without the C11 CMPLX macro, because 0.+I*NAN may give NaN+i*NAN if
+   I is a complex (rather than imaginary) constant.  For some reason,
+   however, it works fine in (pre-4.7) gcc if I define Inf and NaN as
+   1/0 and 0/0 (and only if I compile with optimization -O1 or more),
+   but not if I use the INFINITY or NAN macros. */
+
+/* __builtin_complex was introduced in gcc 4.7, but the C11 CMPLX macro
+   may not be defined unless we are using a recent (2012) version of
+   glibc and compile with -std=c11... note that icc lies about being
+   gcc and probably doesn't have this builtin(?), so exclude icc explicitly */
+#  if !defined(CMPLX) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 7)) && !(defined(__ICC) || defined(__INTEL_COMPILER))
+#    define CMPLX(a,b) __builtin_complex((double) (a), (double) (b))
+#  endif
+
+#  ifdef CMPLX // C11
+#    define C(a,b) CMPLX(a,b)
+#    define Inf INFINITY // C99 infinity
+#    ifdef NAN // GNU libc extension
+#      define NaN NAN
+#    else
+#      define NaN (0./0.) // NaN
+#    endif
+#  else
+#    define C(a,b) ((a) + I*(b))
+#    define Inf (1./0.) 
+#    define NaN (0./0.) 
+#  endif
+
+static inline cmplx cpolar(double r, double t)
+{
+  if (r == 0.0 && !isnan(t))
+    return 0.0;
+  else
+    return C(r * cos(t), r * sin(t));
+}
+
+#endif // !__cplusplus, i.e. pure C (requires C99 features)
+
+/////////////////////////////////////////////////////////////////////////
+// Auxiliary routines to compute other special functions based on w(z)
+
+// compute erfcx(z) = exp(z^2) erfz(z)
+cmplx FADDEEVA(erfcx)(cmplx z, double relerr)
+{
+  return FADDEEVA(w)(C(-cimag(z), creal(z)), relerr);
+}
+
+// compute the error function erf(x)
+double FADDEEVA_RE(erf)(double x)
+{
+#if !defined(__cplusplus)
+  return erf(x); // C99 supplies erf in math.h
+#elif (__cplusplus >= 201103L) || defined(HAVE_ERF)
+  return ::erf(x); // C++11 supplies std::erf in cmath
+#else
+  double mx2 = -x*x;
+  if (mx2 < -750) // underflow
+    return (x >= 0 ? 1.0 : -1.0);
+
+  if (x >= 0) {
+    if (x < 8e-2) goto taylor;
+    return 1.0 - exp(mx2) * FADDEEVA_RE(erfcx)(x);
+  }
+  else { // x < 0
+    if (x > -8e-2) goto taylor;
+    return exp(mx2) * FADDEEVA_RE(erfcx)(-x) - 1.0;
+  }
+
+  // Use Taylor series for small |x|, to avoid cancellation inaccuracy
+  //   erf(x) = 2/sqrt(pi) * x * (1 - x^2/3 + x^4/10 - x^6/42 + x^8/216 + ...)
+ taylor:
+  return x * (1.1283791670955125739
+              + mx2 * (0.37612638903183752464
+                       + mx2 * (0.11283791670955125739
+                                + mx2 * (0.026866170645131251760
+                                         + mx2 * 0.0052239776254421878422))));
+#endif
+}
+
+// compute the error function erf(z)
+cmplx FADDEEVA(erf)(cmplx z, double relerr)
+{
+  double x = creal(z), y = cimag(z);
+
+  if (y == 0)
+    return C(FADDEEVA_RE(erf)(x),
+             y); // preserve sign of 0
+  if (x == 0) // handle separately for speed & handling of y = Inf or NaN
+    return C(x, // preserve sign of 0
+             /* handle y -> Inf limit manually, since
+                exp(y^2) -> Inf but Im[w(y)] -> 0, so
+                IEEE will give us a NaN when it should be Inf */
+             y*y > 720 ? (y > 0 ? Inf : -Inf)
+             : exp(y*y) * FADDEEVA(w_im)(y));
+  
+  double mRe_z2 = (y - x) * (x + y); // Re(-z^2), being careful of overflow
+  double mIm_z2 = -2*x*y; // Im(-z^2)
+  if (mRe_z2 < -750) // underflow
+    return (x >= 0 ? 1.0 : -1.0);
+
+  /* Handle positive and negative x via different formulas,
+     using the mirror symmetries of w, to avoid overflow/underflow
+     problems from multiplying exponentially large and small quantities. */
+  if (x >= 0) {
+    if (x < 8e-2) {
+      if (fabs(y) < 1e-2)
+        goto taylor;
+      else if (fabs(mIm_z2) < 5e-3 && x < 5e-3)
+        goto taylor_erfi;
+    }
+    /* don't use complex exp function, since that will produce spurious NaN
+       values when multiplying w in an overflow situation. */
+    return 1.0 - exp(mRe_z2) *
+      (C(cos(mIm_z2), sin(mIm_z2))
+       * FADDEEVA(w)(C(-y,x), relerr));
+  }
+  else { // x < 0
+    if (x > -8e-2) { // duplicate from above to avoid fabs(x) call
+      if (fabs(y) < 1e-2)
+        goto taylor;
+      else if (fabs(mIm_z2) < 5e-3 && x > -5e-3)
+        goto taylor_erfi;
+    }
+    else if (isnan(x))
+      return C(NaN, y == 0 ? 0 : NaN);
+    /* don't use complex exp function, since that will produce spurious NaN
+       values when multiplying w in an overflow situation. */
+    return exp(mRe_z2) *
+      (C(cos(mIm_z2), sin(mIm_z2))
+       * FADDEEVA(w)(C(y,-x), relerr)) - 1.0;
+  }
+
+  // Use Taylor series for small |z|, to avoid cancellation inaccuracy
+  //   erf(z) = 2/sqrt(pi) * z * (1 - z^2/3 + z^4/10 - z^6/42 + z^8/216 + ...)
+ taylor:
+  {
+    cmplx mz2 = C(mRe_z2, mIm_z2); // -z^2
+    return z * (1.1283791670955125739
+                + mz2 * (0.37612638903183752464
+                         + mz2 * (0.11283791670955125739
+                                  + mz2 * (0.026866170645131251760
+                                          + mz2 * 0.0052239776254421878422))));
+  }
+
+  /* for small |x| and small |xy|, 
+     use Taylor series to avoid cancellation inaccuracy:
+       erf(x+iy) = erf(iy)
+          + 2*exp(y^2)/sqrt(pi) *
+            [ x * (1 - x^2 * (1+2y^2)/3 + x^4 * (3+12y^2+4y^4)/30 + ... 
+              - i * x^2 * y * (1 - x^2 * (3+2y^2)/6 + ...) ]
+     where:
+        erf(iy) = exp(y^2) * Im[w(y)]
+  */
+ taylor_erfi:
+  {
+    double x2 = x*x, y2 = y*y;
+    double expy2 = exp(y2);
+    return C
+      (expy2 * x * (1.1283791670955125739
+                    - x2 * (0.37612638903183752464
+                            + 0.75225277806367504925*y2)
+                    + x2*x2 * (0.11283791670955125739
+                               + y2 * (0.45135166683820502956
+                                       + 0.15045055561273500986*y2))),
+       expy2 * (FADDEEVA(w_im)(y)
+                - x2*y * (1.1283791670955125739 
+                          - x2 * (0.56418958354775628695 
+                                  + 0.37612638903183752464*y2))));
+  }
+}
+
+// erfi(z) = -i erf(iz)
+cmplx FADDEEVA(erfi)(cmplx z, double relerr)
+{
+  cmplx e = FADDEEVA(erf)(C(-cimag(z),creal(z)), relerr);
+  return C(cimag(e), -creal(e));
+}
+
+// erfi(x) = -i erf(ix)
+double FADDEEVA_RE(erfi)(double x)
+{
+  return x*x > 720 ? (x > 0 ? Inf : -Inf)
+    : exp(x*x) * FADDEEVA(w_im)(x);
+}
+
+// erfc(x) = 1 - erf(x)
+double FADDEEVA_RE(erfc)(double x)
+{
+#if !defined(__cplusplus)
+  return erfc(x); // C99 supplies erfc in math.h
+#elif (__cplusplus >= 201103L) || defined(HAVE_ERFC)
+  return ::erfc(x); // C++11 supplies std::erfc in cmath
+#else
+  if (x*x > 750) // underflow
+    return (x >= 0 ? 0.0 : 2.0);
+  return x >= 0 ? exp(-x*x) * FADDEEVA_RE(erfcx)(x) 
+    : 2. - exp(-x*x) * FADDEEVA_RE(erfcx)(-x);
+#endif
+}
+
+// erfc(z) = 1 - erf(z)
+cmplx FADDEEVA(erfc)(cmplx z, double relerr)
+{
+  double x = creal(z), y = cimag(z);
+
+  if (x == 0.)
+    return C(1,
+             /* handle y -> Inf limit manually, since
+                exp(y^2) -> Inf but Im[w(y)] -> 0, so
+                IEEE will give us a NaN when it should be Inf */
+             y*y > 720 ? (y > 0 ? -Inf : Inf)
+             : -exp(y*y) * FADDEEVA(w_im)(y));
+  if (y == 0.) {
+    if (x*x > 750) // underflow
+      return C(x >= 0 ? 0.0 : 2.0,
+               -y); // preserve sign of 0
+    return C(x >= 0 ? exp(-x*x) * FADDEEVA_RE(erfcx)(x) 
+             : 2. - exp(-x*x) * FADDEEVA_RE(erfcx)(-x),
+             -y); // preserve sign of zero
+  }
+
+  double mRe_z2 = (y - x) * (x + y); // Re(-z^2), being careful of overflow
+  double mIm_z2 = -2*x*y; // Im(-z^2)
+  if (mRe_z2 < -750) // underflow
+    return (x >= 0 ? 0.0 : 2.0);
+
+  if (x >= 0)
+    return cexp(C(mRe_z2, mIm_z2))
+      * FADDEEVA(w)(C(-y,x), relerr);
+  else
+    return 2.0 - cexp(C(mRe_z2, mIm_z2))
+      * FADDEEVA(w)(C(y,-x), relerr);
+}
+
+// compute Dawson(x) = sqrt(pi)/2  *  exp(-x^2) * erfi(x)
+double FADDEEVA_RE(Dawson)(double x)
+{
+  const double spi2 = 0.8862269254527580136490837416705725913990; // sqrt(pi)/2
+  return spi2 * FADDEEVA(w_im)(x);
+}
+
+// compute Dawson(z) = sqrt(pi)/2  *  exp(-z^2) * erfi(z)
+cmplx FADDEEVA(Dawson)(cmplx z, double relerr)
+{
+  const double spi2 = 0.8862269254527580136490837416705725913990; // sqrt(pi)/2
+  double x = creal(z), y = cimag(z);
+
+  // handle axes separately for speed & proper handling of x or y = Inf or NaN
+  if (y == 0)
+    return C(spi2 * FADDEEVA(w_im)(x),
+             -y); // preserve sign of 0
+  if (x == 0) {
+    double y2 = y*y;
+    if (y2 < 2.5e-5) { // Taylor expansion
+      return C(x, // preserve sign of 0
+               y * (1.
+                    + y2 * (0.6666666666666666666666666666666666666667
+                            + y2 * 0.26666666666666666666666666666666666667)));
+    }
+    return C(x, // preserve sign of 0
+             spi2 * (y >= 0 
+                     ? exp(y2) - FADDEEVA_RE(erfcx)(y)
+                     : FADDEEVA_RE(erfcx)(-y) - exp(y2)));
+  }
+
+  double mRe_z2 = (y - x) * (x + y); // Re(-z^2), being careful of overflow
+  double mIm_z2 = -2*x*y; // Im(-z^2)
+  cmplx mz2 = C(mRe_z2, mIm_z2); // -z^2
+
+  /* Handle positive and negative x via different formulas,
+     using the mirror symmetries of w, to avoid overflow/underflow
+     problems from multiplying exponentially large and small quantities. */
+  if (y >= 0) {
+    if (y < 5e-3) {
+      if (fabs(x) < 5e-3)
+        goto taylor;
+      else if (fabs(mIm_z2) < 5e-3)
+        goto taylor_realaxis;
+    }
+    cmplx res = cexp(mz2) - FADDEEVA(w)(z, relerr);
+    return spi2 * C(-cimag(res), creal(res));
+  }
+  else { // y < 0
+    if (y > -5e-3) { // duplicate from above to avoid fabs(x) call
+      if (fabs(x) < 5e-3)
+        goto taylor;
+      else if (fabs(mIm_z2) < 5e-3)
+        goto taylor_realaxis;
+    }
+    else if (isnan(y))
+      return C(x == 0 ? 0 : NaN, NaN);
+    cmplx res = FADDEEVA(w)(-z, relerr) - cexp(mz2);
+    return spi2 * C(-cimag(res), creal(res));
+  }
+
+  // Use Taylor series for small |z|, to avoid cancellation inaccuracy
+  //     dawson(z) = z - 2/3 z^3 + 4/15 z^5 + ...
+ taylor:
+  return z * (1.
+              + mz2 * (0.6666666666666666666666666666666666666667
+                       + mz2 * 0.2666666666666666666666666666666666666667));
+
+  /* for small |y| and small |xy|, 
+     use Taylor series to avoid cancellation inaccuracy:
+       dawson(x + iy)
+        = D + y^2 (D + x - 2Dx^2)
+            + y^4 (D/2 + 5x/6 - 2Dx^2 - x^3/3 + 2Dx^4/3)
+        + iy [ (1-2Dx) + 2/3 y^2 (1 - 3Dx - x^2 + 2Dx^3)
+              + y^4/15 (4 - 15Dx - 9x^2 + 20Dx^3 + 2x^4 - 4Dx^5) ] + ...
+     where D = dawson(x) 
+
+     However, for large |x|, 2Dx -> 1 which gives cancellation problems in
+     this series (many of the leading terms cancel).  So, for large |x|,
+     we need to substitute a continued-fraction expansion for D.
+
+        dawson(x) = 0.5 / (x-0.5/(x-1/(x-1.5/(x-2/(x-2.5/(x...))))))
+
+     The 6 terms shown here seems to be the minimum needed to be
+     accurate as soon as the simpler Taylor expansion above starts
+     breaking down.  Using this 6-term expansion, factoring out the
+     denominator, and simplifying with Maple, we obtain:
+
+      Re dawson(x + iy) * (-15 + 90x^2 - 60x^4 + 8x^6) / x
+        = 33 - 28x^2 + 4x^4 + y^2 (18 - 4x^2) + 4 y^4
+      Im dawson(x + iy) * (-15 + 90x^2 - 60x^4 + 8x^6) / y
+        = -15 + 24x^2 - 4x^4 + 2/3 y^2 (6x^2 - 15) - 4 y^4
+
+     Finally, for |x| > 5e7, we can use a simpler 1-term continued-fraction
+     expansion for the real part, and a 2-term expansion for the imaginary
+     part.  (This avoids overflow problems for huge |x|.)  This yields:
+     
+     Re dawson(x + iy) = [1 + y^2 (1 + y^2/2 - (xy)^2/3)] / (2x)
+     Im dawson(x + iy) = y [ -1 - 2/3 y^2 + y^4/15 (2x^2 - 4) ] / (2x^2 - 1)
+
+ */
+ taylor_realaxis:
+  {
+    double x2 = x*x;
+    if (x2 > 1600) { // |x| > 40
+      double y2 = y*y;
+      if (x2 > 25e14) {// |x| > 5e7
+        double xy2 = (x*y)*(x*y);
+        return C((0.5 + y2 * (0.5 + 0.25*y2
+                              - 0.16666666666666666667*xy2)) / x,
+                 y * (-1 + y2 * (-0.66666666666666666667
+                                 + 0.13333333333333333333*xy2
+                                 - 0.26666666666666666667*y2))
+                 / (2*x2 - 1));
+      }
+      return (1. / (-15 + x2*(90 + x2*(-60 + 8*x2)))) *
+        C(x * (33 + x2 * (-28 + 4*x2)
+               + y2 * (18 - 4*x2 + 4*y2)),
+          y * (-15 + x2 * (24 - 4*x2)
+               + y2 * (4*x2 - 10 - 4*y2)));
+    }
+    else {
+      double D = spi2 * FADDEEVA(w_im)(x);
+      double x2 = x*x, y2 = y*y;
+      return C
+        (D + y2 * (D + x - 2*D*x2)
+         + y2*y2 * (D * (0.5 - x2 * (2 - 0.66666666666666666667*x2))
+                    + x * (0.83333333333333333333
+                           - 0.33333333333333333333 * x2)),
+         y * (1 - 2*D*x
+              + y2 * 0.66666666666666666667 * (1 - x2 - D*x * (3 - 2*x2))
+              + y2*y2 * (0.26666666666666666667 -
+                         x2 * (0.6 - 0.13333333333333333333 * x2)
+                         - D*x * (1 - x2 * (1.3333333333333333333
+                                            - 0.26666666666666666667 * x2)))));
+    }
+  }
+}
+
+/////////////////////////////////////////////////////////////////////////
+
+// return sinc(x) = sin(x)/x, given both x and sin(x) 
+// [since we only use this in cases where sin(x) has already been computed]
+static inline double sinc(double x, double sinx) { 
+  return fabs(x) < 1e-4 ? 1 - (0.1666666666666666666667)*x*x : sinx / x; 
+}
+
+// sinh(x) via Taylor series, accurate to machine precision for |x| < 1e-2
+static inline double sinh_taylor(double x) {
+  return x * (1 + (x*x) * (0.1666666666666666666667
+                           + 0.00833333333333333333333 * (x*x)));
+}
+
+static inline double sqr(double x) { return x*x; }
+
+// precomputed table of expa2n2[n-1] = exp(-a2*n*n)
+// for double-precision a2 = 0.26865... in FADDEEVA(w), below.
+static const double expa2n2[] = {
+  7.64405281671221563e-01,
+  3.41424527166548425e-01,
+  8.91072646929412548e-02,
+  1.35887299055460086e-02,
+  1.21085455253437481e-03,
+  6.30452613933449404e-05,
+  1.91805156577114683e-06,
+  3.40969447714832381e-08,
+  3.54175089099469393e-10,
+  2.14965079583260682e-12,
+  7.62368911833724354e-15,
+  1.57982797110681093e-17,
+  1.91294189103582677e-20,
+  1.35344656764205340e-23,
+  5.59535712428588720e-27,
+  1.35164257972401769e-30,
+  1.90784582843501167e-34,
+  1.57351920291442930e-38,
+  7.58312432328032845e-43,
+  2.13536275438697082e-47,
+  3.51352063787195769e-52,
+  3.37800830266396920e-57,
+  1.89769439468301000e-62,
+  6.22929926072668851e-68,
+  1.19481172006938722e-73,
+  1.33908181133005953e-79,
+  8.76924303483223939e-86,
+  3.35555576166254986e-92,
+  7.50264110688173024e-99,
+  9.80192200745410268e-106,
+  7.48265412822268959e-113,
+  3.33770122566809425e-120,
+  8.69934598159861140e-128,
+  1.32486951484088852e-135,
+  1.17898144201315253e-143,
+  6.13039120236180012e-152,
+  1.86258785950822098e-160,
+  3.30668408201432783e-169,
+  3.43017280887946235e-178,
+  2.07915397775808219e-187,
+  7.36384545323984966e-197,
+  1.52394760394085741e-206,
+  1.84281935046532100e-216,
+  1.30209553802992923e-226,
+  5.37588903521080531e-237,
+  1.29689584599763145e-247,
+  1.82813078022866562e-258,
+  1.50576355348684241e-269,
+  7.24692320799294194e-281,
+  2.03797051314726829e-292,
+  3.34880215927873807e-304,
+  0.0 // underflow (also prevents reads past array end, below)
+};
+
+/////////////////////////////////////////////////////////////////////////
+
+cmplx FADDEEVA(w)(cmplx z, double relerr)
+{
+  if (creal(z) == 0.0)
+    return C(FADDEEVA_RE(erfcx)(cimag(z)), 
+             creal(z)); // give correct sign of 0 in cimag(w)
+  else if (cimag(z) == 0)
+    return C(exp(-sqr(creal(z))),
+             FADDEEVA(w_im)(creal(z)));
+
+  double a, a2, c;
+  if (relerr <= DBL_EPSILON) {
+    relerr = DBL_EPSILON;
+    a = 0.518321480430085929872; // pi / sqrt(-log(eps*0.5))
+    c = 0.329973702884629072537; // (2/pi) * a;
+    a2 = 0.268657157075235951582; // a^2
+  }
+  else {
+    const double pi = 3.14159265358979323846264338327950288419716939937510582;
+    if (relerr > 0.1) relerr = 0.1; // not sensible to compute < 1 digit
+    a = pi / sqrt(-log(relerr*0.5));
+    c = (2/pi)*a;
+    a2 = a*a;
+  }
+  const double x = fabs(creal(z));
+  const double y = cimag(z), ya = fabs(y);
+
+  cmplx ret = 0.; // return value
+
+  double sum1 = 0, sum2 = 0, sum3 = 0, sum4 = 0, sum5 = 0;
+
+#define USE_CONTINUED_FRACTION 1 // 1 to use continued fraction for large |z|
+
+#if USE_CONTINUED_FRACTION
+  if (ya > 7 || (x > 6  // continued fraction is faster
+                 /* As pointed out by M. Zaghloul, the continued
+                    fraction seems to give a large relative error in
+                    Re w(z) for |x| ~ 6 and small |y|, so use
+                    algorithm 816 in this region: */
+                 && (ya > 0.1 || (x > 8 && ya > 1e-10) || x > 28))) {
+    
+    /* Poppe & Wijers suggest using a number of terms
+           nu = 3 + 1442 / (26*rho + 77)
+       where rho = sqrt((x/x0)^2 + (y/y0)^2) where x0=6.3, y0=4.4.
+       (They only use this expansion for rho >= 1, but rho a little less
+        than 1 seems okay too.)
+       Instead, I did my own fit to a slightly different function
+       that avoids the hypotenuse calculation, using NLopt to minimize
+       the sum of the squares of the errors in nu with the constraint
+       that the estimated nu be >= minimum nu to attain machine precision.
+       I also separate the regions where nu == 2 and nu == 1. */
+    const double ispi = 0.56418958354775628694807945156; // 1 / sqrt(pi)
+    double xs = y < 0 ? -creal(z) : creal(z); // compute for -z if y < 0
+    if (x + ya > 4000) { // nu <= 2
+      if (x + ya > 1e7) { // nu == 1, w(z) = i/sqrt(pi) / z
+        // scale to avoid overflow
+        if (x > ya) {
+          double yax = ya / xs; 
+          double denom = ispi / (xs + yax*ya);
+          ret = C(denom*yax, denom);
+        }
+        else if (isinf(ya))
+          return ((isnan(x) || y < 0) 
+                  ? C(NaN,NaN) : C(0,0));
+        else {
+          double xya = xs / ya;
+          double denom = ispi / (xya*xs + ya);
+          ret = C(denom, denom*xya);
+        }
+      }
+      else { // nu == 2, w(z) = i/sqrt(pi) * z / (z*z - 0.5)
+        double dr = xs*xs - ya*ya - 0.5, di = 2*xs*ya;
+        double denom = ispi / (dr*dr + di*di);
+        ret = C(denom * (xs*di-ya*dr), denom * (xs*dr+ya*di));
+      }
+    }
+    else { // compute nu(z) estimate and do general continued fraction
+      const double c0=3.9, c1=11.398, c2=0.08254, c3=0.1421, c4=0.2023; // fit
+      double nu = floor(c0 + c1 / (c2*x + c3*ya + c4));
+      double wr = xs, wi = ya;
+      for (nu = 0.5 * (nu - 1); nu > 0.4; nu -= 0.5) {
+        // w <- z - nu/w:
+        double denom = nu / (wr*wr + wi*wi);
+        wr = xs - wr * denom;
+        wi = ya + wi * denom;
+      }
+      { // w(z) = i/sqrt(pi) / w:
+        double denom = ispi / (wr*wr + wi*wi);
+        ret = C(denom*wi, denom*wr);
+      }
+    }
+    if (y < 0) {
+      // use w(z) = 2.0*exp(-z*z) - w(-z), 
+      // but be careful of overflow in exp(-z*z) 
+      //                                = exp(-(xs*xs-ya*ya) -2*i*xs*ya) 
+      return 2.0*cexp(C((ya-xs)*(xs+ya), 2*xs*y)) - ret;
+    }
+    else
+      return ret;
+  }
+#else // !USE_CONTINUED_FRACTION
+  if (x + ya > 1e7) { // w(z) = i/sqrt(pi) / z, to machine precision
+    const double ispi = 0.56418958354775628694807945156; // 1 / sqrt(pi)
+    double xs = y < 0 ? -creal(z) : creal(z); // compute for -z if y < 0
+    // scale to avoid overflow
+    if (x > ya) {
+      double yax = ya / xs; 
+      double denom = ispi / (xs + yax*ya);
+      ret = C(denom*yax, denom);
+    }
+    else {
+      double xya = xs / ya;
+      double denom = ispi / (xya*xs + ya);
+      ret = C(denom, denom*xya);
+    }
+    if (y < 0) {
+      // use w(z) = 2.0*exp(-z*z) - w(-z), 
+      // but be careful of overflow in exp(-z*z) 
+      //                                = exp(-(xs*xs-ya*ya) -2*i*xs*ya) 
+      return 2.0*cexp(C((ya-xs)*(xs+ya), 2*xs*y)) - ret;
+    }
+    else
+      return ret;
+  }
+#endif // !USE_CONTINUED_FRACTION 
+
+  /* Note: The test that seems to be suggested in the paper is x <
+     sqrt(-log(DBL_MIN)), about 26.6, since otherwise exp(-x^2)
+     underflows to zero and sum1,sum2,sum4 are zero.  However, long
+     before this occurs, the sum1,sum2,sum4 contributions are
+     negligible in double precision; I find that this happens for x >
+     about 6, for all y.  On the other hand, I find that the case
+     where we compute all of the sums is faster (at least with the
+     precomputed expa2n2 table) until about x=10.  Furthermore, if we
+     try to compute all of the sums for x > 20, I find that we
+     sometimes run into numerical problems because underflow/overflow
+     problems start to appear in the various coefficients of the sums,
+     below.  Therefore, we use x < 10 here. */
+  else if (x < 10) {
+    double prod2ax = 1, prodm2ax = 1;
+    double expx2;
+
+    if (isnan(y))
+      return C(y,y);
+    
+    /* Somewhat ugly copy-and-paste duplication here, but I see significant
+       speedups from using the special-case code with the precomputed
+       exponential, and the x < 5e-4 special case is needed for accuracy. */
+
+    if (relerr == DBL_EPSILON) { // use precomputed exp(-a2*(n*n)) table
+      if (x < 5e-4) { // compute sum4 and sum5 together as sum5-sum4
+        const double x2 = x*x;
+        expx2 = 1 - x2 * (1 - 0.5*x2); // exp(-x*x) via Taylor
+        // compute exp(2*a*x) and exp(-2*a*x) via Taylor, to double precision
+        const double ax2 = 1.036642960860171859744*x; // 2*a*x
+        const double exp2ax =
+          1 + ax2 * (1 + ax2 * (0.5 + 0.166666666666666666667*ax2));
+        const double expm2ax =
+          1 - ax2 * (1 - ax2 * (0.5 - 0.166666666666666666667*ax2));
+        for (int n = 1; 1; ++n) {
+          const double coef = expa2n2[n-1] * expx2 / (a2*(n*n) + y*y);
+          prod2ax *= exp2ax;
+          prodm2ax *= expm2ax;
+          sum1 += coef;
+          sum2 += coef * prodm2ax;
+          sum3 += coef * prod2ax;
+          
+          // really = sum5 - sum4
+          sum5 += coef * (2*a) * n * sinh_taylor((2*a)*n*x);
+          
+          // test convergence via sum3
+          if (coef * prod2ax < relerr * sum3) break;
+        }
+      }
+      else { // x > 5e-4, compute sum4 and sum5 separately
+        expx2 = exp(-x*x);
+        const double exp2ax = exp((2*a)*x), expm2ax = 1 / exp2ax;
+        for (int n = 1; 1; ++n) {
+          const double coef = expa2n2[n-1] * expx2 / (a2*(n*n) + y*y);
+          prod2ax *= exp2ax;
+          prodm2ax *= expm2ax;
+          sum1 += coef;
+          sum2 += coef * prodm2ax;
+          sum4 += (coef * prodm2ax) * (a*n);
+          sum3 += coef * prod2ax;
+          sum5 += (coef * prod2ax) * (a*n);
+          // test convergence via sum5, since this sum has the slowest decay
+          if ((coef * prod2ax) * (a*n) < relerr * sum5) break;
+        }
+      }
+    }
+    else { // relerr != DBL_EPSILON, compute exp(-a2*(n*n)) on the fly
+      const double exp2ax = exp((2*a)*x), expm2ax = 1 / exp2ax;
+      if (x < 5e-4) { // compute sum4 and sum5 together as sum5-sum4
+        const double x2 = x*x;
+        expx2 = 1 - x2 * (1 - 0.5*x2); // exp(-x*x) via Taylor
+        for (int n = 1; 1; ++n) {
+          const double coef = exp(-a2*(n*n)) * expx2 / (a2*(n*n) + y*y);
+          prod2ax *= exp2ax;
+          prodm2ax *= expm2ax;
+          sum1 += coef;
+          sum2 += coef * prodm2ax;
+          sum3 += coef * prod2ax;
+          
+          // really = sum5 - sum4
+          sum5 += coef * (2*a) * n * sinh_taylor((2*a)*n*x);
+          
+          // test convergence via sum3
+          if (coef * prod2ax < relerr * sum3) break;
+        }
+      }
+      else { // x > 5e-4, compute sum4 and sum5 separately
+        expx2 = exp(-x*x);
+        for (int n = 1; 1; ++n) {
+          const double coef = exp(-a2*(n*n)) * expx2 / (a2*(n*n) + y*y);
+          prod2ax *= exp2ax;
+          prodm2ax *= expm2ax;
+          sum1 += coef;
+          sum2 += coef * prodm2ax;
+          sum4 += (coef * prodm2ax) * (a*n);
+          sum3 += coef * prod2ax;
+          sum5 += (coef * prod2ax) * (a*n);
+          // test convergence via sum5, since this sum has the slowest decay
+          if ((coef * prod2ax) * (a*n) < relerr * sum5) break;
+        }
+      }
+    }
+    const double expx2erfcxy = // avoid spurious overflow for large negative y
+      y > -6 // for y < -6, erfcx(y) = 2*exp(y*y) to double precision
+      ? expx2*FADDEEVA_RE(erfcx)(y) : 2*exp(y*y-x*x);
+    if (y > 5) { // imaginary terms cancel
+      const double sinxy = sin(x*y);
+      ret = (expx2erfcxy - c*y*sum1) * cos(2*x*y)
+        + (c*x*expx2) * sinxy * sinc(x*y, sinxy);
+    }
+    else {
+      double xs = creal(z);
+      const double sinxy = sin(xs*y);
+      const double sin2xy = sin(2*xs*y), cos2xy = cos(2*xs*y);
+      const double coef1 = expx2erfcxy - c*y*sum1;
+      const double coef2 = c*xs*expx2;
+      ret = C(coef1 * cos2xy + coef2 * sinxy * sinc(xs*y, sinxy),
+              coef2 * sinc(2*xs*y, sin2xy) - coef1 * sin2xy);
+    }
+  }
+  else { // x large: only sum3 & sum5 contribute (see above note)    
+    if (isnan(x))
+      return C(x,x);
+    if (isnan(y))
+      return C(y,y);
+
+#if USE_CONTINUED_FRACTION
+    ret = exp(-x*x); // |y| < 1e-10, so we only need exp(-x*x) term
+#else
+    if (y < 0) {
+      /* erfcx(y) ~ 2*exp(y*y) + (< 1) if y < 0, so
+         erfcx(y)*exp(-x*x) ~ 2*exp(y*y-x*x) term may not be negligible
+         if y*y - x*x > -36 or so.  So, compute this term just in case.
+         We also need the -exp(-x*x) term to compute Re[w] accurately
+         in the case where y is very small. */
+      ret = cpolar(2*exp(y*y-x*x) - exp(-x*x), -2*creal(z)*y);
+    }
+    else
+      ret = exp(-x*x); // not negligible in real part if y very small
+#endif
+    // (round instead of ceil as in original paper; note that x/a > 1 here)
+    double n0 = floor(x/a + 0.5); // sum in both directions, starting at n0
+    double dx = a*n0 - x;
+    sum3 = exp(-dx*dx) / (a2*(n0*n0) + y*y);
+    sum5 = a*n0 * sum3;
+    double exp1 = exp(4*a*dx), exp1dn = 1;
+    int dn;
+    for (dn = 1; n0 - dn > 0; ++dn) { // loop over n0-dn and n0+dn terms
+      double np = n0 + dn, nm = n0 - dn;
+      double tp = exp(-sqr(a*dn+dx));
+      double tm = tp * (exp1dn *= exp1); // trick to get tm from tp
+      tp /= (a2*(np*np) + y*y);
+      tm /= (a2*(nm*nm) + y*y);
+      sum3 += tp + tm;
+      sum5 += a * (np * tp + nm * tm);
+      if (a * (np * tp + nm * tm) < relerr * sum5) goto finish;
+    }
+    while (1) { // loop over n0+dn terms only (since n0-dn <= 0)
+      double np = n0 + dn++;
+      double tp = exp(-sqr(a*dn+dx)) / (a2*(np*np) + y*y);
+      sum3 += tp;
+      sum5 += a * np * tp;
+      if (a * np * tp < relerr * sum5) goto finish;
+    }
+  }
+ finish:
+  return ret + C((0.5*c)*y*(sum2+sum3), 
+                 (0.5*c)*copysign(sum5-sum4, creal(z)));
+}
+
+/////////////////////////////////////////////////////////////////////////
+
+/* erfcx(x) = exp(x^2) erfc(x) function, for real x, written by
+   Steven G. Johnson, October 2012.
+
+   This function combines a few different ideas.
+
+   First, for x > 50, it uses a continued-fraction expansion (same as
+   for the Faddeeva function, but with algebraic simplifications for z=i*x).
+
+   Second, for 0 <= x <= 50, it uses Chebyshev polynomial approximations,
+   but with two twists:
+
+      a) It maps x to y = 4 / (4+x) in [0,1].  This simple transformation,
+         inspired by a similar transformation in the octave-forge/specfun
+         erfcx by Soren Hauberg, results in much faster Chebyshev convergence
+         than other simple transformations I have examined.
+
+      b) Instead of using a single Chebyshev polynomial for the entire
+         [0,1] y interval, we break the interval up into 100 equal
+         subintervals, with a switch/lookup table, and use much lower
+         degree Chebyshev polynomials in each subinterval. This greatly
+         improves performance in my tests.
+
+   For x < 0, we use the relationship erfcx(-x) = 2 exp(x^2) - erfc(x),
+   with the usual checks for overflow etcetera.
+
+   Performance-wise, it seems to be substantially faster than either
+   the SLATEC DERFC function [or an erfcx function derived therefrom]
+   or Cody's CALERF function (from netlib.org/specfun), while
+   retaining near machine precision in accuracy.  */
+
+/* Given y100=100*y, where y = 4/(4+x) for x >= 0, compute erfc(x).
+
+   Uses a look-up table of 100 different Chebyshev polynomials
+   for y intervals [0,0.01], [0.01,0.02], ...., [0.99,1], generated
+   with the help of Maple and a little shell script.   This allows
+   the Chebyshev polynomials to be of significantly lower degree (about 1/4)
+   compared to fitting the whole [0,1] interval with a single polynomial. */
+static double erfcx_y100(double y100)
+{
+  switch ((int) y100) {
+case 0: {
+double t = 2*y100 - 1;
+return 0.70878032454106438663e-3 + (0.71234091047026302958e-3 + (0.35779077297597742384e-5 + (0.17403143962587937815e-7 + (0.81710660047307788845e-10 + (0.36885022360434957634e-12 + 0.15917038551111111111e-14 * t) * t) * t) * t) * t) * t;
+}
+case 1: {
+double t = 2*y100 - 3;
+return 0.21479143208285144230e-2 + (0.72686402367379996033e-3 + (0.36843175430938995552e-5 + (0.18071841272149201685e-7 + (0.85496449296040325555e-10 + (0.38852037518534291510e-12 + 0.16868473576888888889e-14 * t) * t) * t) * t) * t) * t;
+}
+case 2: {
+double t = 2*y100 - 5;
+return 0.36165255935630175090e-2 + (0.74182092323555510862e-3 + (0.37948319957528242260e-5 + (0.18771627021793087350e-7 + (0.89484715122415089123e-10 + (0.40935858517772440862e-12 + 0.17872061464888888889e-14 * t) * t) * t) * t) * t) * t;
+}
+case 3: {
+double t = 2*y100 - 7;
+return 0.51154983860031979264e-2 + (0.75722840734791660540e-3 + (0.39096425726735703941e-5 + (0.19504168704300468210e-7 + (0.93687503063178993915e-10 + (0.43143925959079664747e-12 + 0.18939926435555555556e-14 * t) * t) * t) * t) * t) * t;
+}
+case 4: {
+double t = 2*y100 - 9;
+return 0.66457513172673049824e-2 + (0.77310406054447454920e-3 + (0.40289510589399439385e-5 + (0.20271233238288381092e-7 + (0.98117631321709100264e-10 + (0.45484207406017752971e-12 + 0.20076352213333333333e-14 * t) * t) * t) * t) * t) * t;
+}
+case 5: {
+double t = 2*y100 - 11;
+return 0.82082389970241207883e-2 + (0.78946629611881710721e-3 + (0.41529701552622656574e-5 + (0.21074693344544655714e-7 + (0.10278874108587317989e-9 + (0.47965201390613339638e-12 + 0.21285907413333333333e-14 * t) * t) * t) * t) * t) * t;
+}
+case 6: {
+double t = 2*y100 - 13;
+return 0.98039537275352193165e-2 + (0.80633440108342840956e-3 + (0.42819241329736982942e-5 + (0.21916534346907168612e-7 + (0.10771535136565470914e-9 + (0.50595972623692822410e-12 + 0.22573462684444444444e-14 * t) * t) * t) * t) * t) * t;
+}
+case 7: {
+double t = 2*y100 - 15;
+return 0.11433927298290302370e-1 + (0.82372858383196561209e-3 + (0.44160495311765438816e-5 + (0.22798861426211986056e-7 + (0.11291291745879239736e-9 + (0.53386189365816880454e-12 + 0.23944209546666666667e-14 * t) * t) * t) * t) * t) * t;
+}
+case 8: {
+double t = 2*y100 - 17;
+return 0.13099232878814653979e-1 + (0.84167002467906968214e-3 + (0.45555958988457506002e-5 + (0.23723907357214175198e-7 + (0.11839789326602695603e-9 + (0.56346163067550237877e-12 + 0.25403679644444444444e-14 * t) * t) * t) * t) * t) * t;
+}
+case 9: {
+double t = 2*y100 - 19;
+return 0.14800987015587535621e-1 + (0.86018092946345943214e-3 + (0.47008265848816866105e-5 + (0.24694040760197315333e-7 + (0.12418779768752299093e-9 + (0.59486890370320261949e-12 + 0.26957764568888888889e-14 * t) * t) * t) * t) * t) * t;
+}
+case 10: {
+double t = 2*y100 - 21;
+return 0.16540351739394069380e-1 + (0.87928458641241463952e-3 + (0.48520195793001753903e-5 + (0.25711774900881709176e-7 + (0.13030128534230822419e-9 + (0.62820097586874779402e-12 + 0.28612737351111111111e-14 * t) * t) * t) * t) * t) * t;
+}
+case 11: {
+double t = 2*y100 - 23;
+return 0.18318536789842392647e-1 + (0.89900542647891721692e-3 + (0.50094684089553365810e-5 + (0.26779777074218070482e-7 + (0.13675822186304615566e-9 + (0.66358287745352705725e-12 + 0.30375273884444444444e-14 * t) * t) * t) * t) * t) * t;
+}
+case 12: {
+double t = 2*y100 - 25;
+return 0.20136801964214276775e-1 + (0.91936908737673676012e-3 + (0.51734830914104276820e-5 + (0.27900878609710432673e-7 + (0.14357976402809042257e-9 + (0.70114790311043728387e-12 + 0.32252476000000000000e-14 * t) * t) * t) * t) * t) * t;
+}
+case 13: {
+double t = 2*y100 - 27;
+return 0.21996459598282740954e-1 + (0.94040248155366777784e-3 + (0.53443911508041164739e-5 + (0.29078085538049374673e-7 + (0.15078844500329731137e-9 + (0.74103813647499204269e-12 + 0.34251892320000000000e-14 * t) * t) * t) * t) * t) * t;
+}
+case 14: {
+double t = 2*y100 - 29;
+return 0.23898877187226319502e-1 + (0.96213386835900177540e-3 + (0.55225386998049012752e-5 + (0.30314589961047687059e-7 + (0.15840826497296335264e-9 + (0.78340500472414454395e-12 + 0.36381553564444444445e-14 * t) * t) * t) * t) * t) * t;
+}
+case 15: {
+double t = 2*y100 - 31;
+return 0.25845480155298518485e-1 + (0.98459293067820123389e-3 + (0.57082915920051843672e-5 + (0.31613782169164830118e-7 + (0.16646478745529630813e-9 + (0.82840985928785407942e-12 + 0.38649975768888888890e-14 * t) * t) * t) * t) * t) * t;
+}
+case 16: {
+double t = 2*y100 - 33;
+return 0.27837754783474696598e-1 + (0.10078108563256892757e-2 + (0.59020366493792212221e-5 + (0.32979263553246520417e-7 + (0.17498524159268458073e-9 + (0.87622459124842525110e-12 + 0.41066206488888888890e-14 * t) * t) * t) * t) * t) * t;
+}
+case 17: {
+double t = 2*y100 - 35;
+return 0.29877251304899307550e-1 + (0.10318204245057349310e-2 + (0.61041829697162055093e-5 + (0.34414860359542720579e-7 + (0.18399863072934089607e-9 + (0.92703227366365046533e-12 + 0.43639844053333333334e-14 * t) * t) * t) * t) * t) * t;
+}
+case 18: {
+double t = 2*y100 - 37;
+return 0.31965587178596443475e-1 + (0.10566560976716574401e-2 + (0.63151633192414586770e-5 + (0.35924638339521924242e-7 + (0.19353584758781174038e-9 + (0.98102783859889264382e-12 + 0.46381060817777777779e-14 * t) * t) * t) * t) * t) * t;
+}
+case 19: {
+double t = 2*y100 - 39;
+return 0.34104450552588334840e-1 + (0.10823541191350532574e-2 + (0.65354356159553934436e-5 + (0.37512918348533521149e-7 + (0.20362979635817883229e-9 + (0.10384187833037282363e-11 + 0.49300625262222222221e-14 * t) * t) * t) * t) * t) * t;
+}
+case 20: {
+double t = 2*y100 - 41;
+return 0.36295603928292425716e-1 + (0.11089526167995268200e-2 + (0.67654845095518363577e-5 + (0.39184292949913591646e-7 + (0.21431552202133775150e-9 + (0.10994259106646731797e-11 + 0.52409949102222222221e-14 * t) * t) * t) * t) * t) * t;
+}
+case 21: {
+double t = 2*y100 - 43;
+return 0.38540888038840509795e-1 + (0.11364917134175420009e-2 + (0.70058230641246312003e-5 + (0.40943644083718586939e-7 + (0.22563034723692881631e-9 + (0.11642841011361992885e-11 + 0.55721092871111111110e-14 * t) * t) * t) * t) * t) * t;
+}
+case 22: {
+double t = 2*y100 - 45;
+return 0.40842225954785960651e-1 + (0.11650136437945673891e-2 + (0.72569945502343006619e-5 + (0.42796161861855042273e-7 + (0.23761401711005024162e-9 + (0.12332431172381557035e-11 + 0.59246802364444444445e-14 * t) * t) * t) * t) * t) * t;
+}
+case 23: {
+double t = 2*y100 - 47;
+return 0.43201627431540222422e-1 + (0.11945628793917272199e-2 + (0.75195743532849206263e-5 + (0.44747364553960993492e-7 + (0.25030885216472953674e-9 + (0.13065684400300476484e-11 + 0.63000532853333333334e-14 * t) * t) * t) * t) * t) * t;
+}
+case 24: {
+double t = 2*y100 - 49;
+return 0.45621193513810471438e-1 + (0.12251862608067529503e-2 + (0.77941720055551920319e-5 + (0.46803119830954460212e-7 + (0.26375990983978426273e-9 + (0.13845421370977119765e-11 + 0.66996477404444444445e-14 * t) * t) * t) * t) * t) * t;
+}
+case 25: {
+double t = 2*y100 - 51;
+return 0.48103121413299865517e-1 + (0.12569331386432195113e-2 + (0.80814333496367673980e-5 + (0.48969667335682018324e-7 + (0.27801515481905748484e-9 + (0.14674637611609884208e-11 + 0.71249589351111111110e-14 * t) * t) * t) * t) * t) * t;
+}
+case 26: {
+double t = 2*y100 - 53;
+return 0.50649709676983338501e-1 + (0.12898555233099055810e-2 + (0.83820428414568799654e-5 + (0.51253642652551838659e-7 + (0.29312563849675507232e-9 + (0.15556512782814827846e-11 + 0.75775607822222222221e-14 * t) * t) * t) * t) * t) * t;
+}
+case 27: {
+double t = 2*y100 - 55;
+return 0.53263363664388864181e-1 + (0.13240082443256975769e-2 + (0.86967260015007658418e-5 + (0.53662102750396795566e-7 + (0.30914568786634796807e-9 + (0.16494420240828493176e-11 + 0.80591079644444444445e-14 * t) * t) * t) * t) * t) * t;
+}
+case 28: {
+double t = 2*y100 - 57;
+return 0.55946601353500013794e-1 + (0.13594491197408190706e-2 + (0.90262520233016380987e-5 + (0.56202552975056695376e-7 + (0.32613310410503135996e-9 + (0.17491936862246367398e-11 + 0.85713381688888888890e-14 * t) * t) * t) * t) * t) * t;
+}
+case 29: {
+double t = 2*y100 - 59;
+return 0.58702059496154081813e-1 + (0.13962391363223647892e-2 + (0.93714365487312784270e-5 + (0.58882975670265286526e-7 + (0.34414937110591753387e-9 + (0.18552853109751857859e-11 + 0.91160736711111111110e-14 * t) * t) * t) * t) * t) * t;
+}
+case 30: {
+double t = 2*y100 - 61;
+return 0.61532500145144778048e-1 + (0.14344426411912015247e-2 + (0.97331446201016809696e-5 + (0.61711860507347175097e-7 + (0.36325987418295300221e-9 + (0.19681183310134518232e-11 + 0.96952238400000000000e-14 * t) * t) * t) * t) * t) * t;
+}
+case 31: {
+double t = 2*y100 - 63;
+return 0.64440817576653297993e-1 + (0.14741275456383131151e-2 + (0.10112293819576437838e-4 + (0.64698236605933246196e-7 + (0.38353412915303665586e-9 + (0.20881176114385120186e-11 + 0.10310784480000000000e-13 * t) * t) * t) * t) * t) * t;
+}
+case 32: {
+double t = 2*y100 - 65;
+return 0.67430045633130393282e-1 + (0.15153655418916540370e-2 + (0.10509857606888328667e-4 + (0.67851706529363332855e-7 + (0.40504602194811140006e-9 + (0.22157325110542534469e-11 + 0.10964842115555555556e-13 * t) * t) * t) * t) * t) * t;
+}
+case 33: {
+double t = 2*y100 - 67;
+return 0.70503365513338850709e-1 + (0.15582323336495709827e-2 + (0.10926868866865231089e-4 + (0.71182482239613507542e-7 + (0.42787405890153386710e-9 + (0.23514379522274416437e-11 + 0.11659571751111111111e-13 * t) * t) * t) * t) * t) * t;
+}
+case 34: {
+double t = 2*y100 - 69;
+return 0.73664114037944596353e-1 + (0.16028078812438820413e-2 + (0.11364423678778207991e-4 + (0.74701423097423182009e-7 + (0.45210162777476488324e-9 + (0.24957355004088569134e-11 + 0.12397238257777777778e-13 * t) * t) * t) * t) * t) * t;
+}
+case 35: {
+double t = 2*y100 - 71;
+return 0.76915792420819562379e-1 + (0.16491766623447889354e-2 + (0.11823685320041302169e-4 + (0.78420075993781544386e-7 + (0.47781726956916478925e-9 + (0.26491544403815724749e-11 + 0.13180196462222222222e-13 * t) * t) * t) * t) * t) * t;
+}
+case 36: {
+double t = 2*y100 - 73;
+return 0.80262075578094612819e-1 + (0.16974279491709504117e-2 + (0.12305888517309891674e-4 + (0.82350717698979042290e-7 + (0.50511496109857113929e-9 + (0.28122528497626897696e-11 + 0.14010889635555555556e-13 * t) * t) * t) * t) * t) * t;
+}
+case 37: {
+double t = 2*y100 - 75;
+return 0.83706822008980357446e-1 + (0.17476561032212656962e-2 + (0.12812343958540763368e-4 + (0.86506399515036435592e-7 + (0.53409440823869467453e-9 + (0.29856186620887555043e-11 + 0.14891851591111111111e-13 * t) * t) * t) * t) * t) * t;
+}
+case 38: {
+double t = 2*y100 - 77;
+return 0.87254084284461718231e-1 + (0.17999608886001962327e-2 + (0.13344443080089492218e-4 + (0.90900994316429008631e-7 + (0.56486134972616465316e-9 + (0.31698707080033956934e-11 + 0.15825697795555555556e-13 * t) * t) * t) * t) * t) * t;
+}
+case 39: {
+double t = 2*y100 - 79;
+return 0.90908120182172748487e-1 + (0.18544478050657699758e-2 + (0.13903663143426120077e-4 + (0.95549246062549906177e-7 + (0.59752787125242054315e-9 + (0.33656597366099099413e-11 + 0.16815130613333333333e-13 * t) * t) * t) * t) * t) * t;
+}
+case 40: {
+double t = 2*y100 - 81;
+return 0.94673404508075481121e-1 + (0.19112284419887303347e-2 + (0.14491572616545004930e-4 + (0.10046682186333613697e-6 + (0.63221272959791000515e-9 + (0.35736693975589130818e-11 + 0.17862931591111111111e-13 * t) * t) * t) * t) * t) * t;
+}
+case 41: {
+double t = 2*y100 - 83;
+return 0.98554641648004456555e-1 + (0.19704208544725622126e-2 + (0.15109836875625443935e-4 + (0.10567036667675984067e-6 + (0.66904168640019354565e-9 + (0.37946171850824333014e-11 + 0.18971959040000000000e-13 * t) * t) * t) * t) * t) * t;
+}
+case 42: {
+double t = 2*y100 - 85;
+return 0.10255677889470089531e0 + (0.20321499629472857418e-2 + (0.15760224242962179564e-4 + (0.11117756071353507391e-6 + (0.70814785110097658502e-9 + (0.40292553276632563925e-11 + 0.20145143075555555556e-13 * t) * t) * t) * t) * t) * t;
+}
+case 43: {
+double t = 2*y100 - 87;
+return 0.10668502059865093318e0 + (0.20965479776148731610e-2 + (0.16444612377624983565e-4 + (0.11700717962026152749e-6 + (0.74967203250938418991e-9 + (0.42783716186085922176e-11 + 0.21385479360000000000e-13 * t) * t) * t) * t) * t) * t;
+}
+case 44: {
+double t = 2*y100 - 89;
+return 0.11094484319386444474e0 + (0.21637548491908170841e-2 + (0.17164995035719657111e-4 + (0.12317915750735938089e-6 + (0.79376309831499633734e-9 + (0.45427901763106353914e-11 + 0.22696025653333333333e-13 * t) * t) * t) * t) * t) * t;
+}
+case 45: {
+double t = 2*y100 - 91;
+return 0.11534201115268804714e0 + (0.22339187474546420375e-2 + (0.17923489217504226813e-4 + (0.12971465288245997681e-6 + (0.84057834180389073587e-9 + (0.48233721206418027227e-11 + 0.24079890062222222222e-13 * t) * t) * t) * t) * t) * t;
+}
+case 46: {
+double t = 2*y100 - 93;
+return 0.11988259392684094740e0 + (0.23071965691918689601e-2 + (0.18722342718958935446e-4 + (0.13663611754337957520e-6 + (0.89028385488493287005e-9 + (0.51210161569225846701e-11 + 0.25540227111111111111e-13 * t) * t) * t) * t) * t) * t;
+}
+case 47: {
+double t = 2*y100 - 95;
+return 0.12457298393509812907e0 + (0.23837544771809575380e-2 + (0.19563942105711612475e-4 + (0.14396736847739470782e-6 + (0.94305490646459247016e-9 + (0.54366590583134218096e-11 + 0.27080225920000000000e-13 * t) * t) * t) * t) * t) * t;
+}
+case 48: {
+double t = 2*y100 - 97;
+return 0.12941991566142438816e0 + (0.24637684719508859484e-2 + (0.20450821127475879816e-4 + (0.15173366280523906622e-6 + (0.99907632506389027739e-9 + (0.57712760311351625221e-11 + 0.28703099555555555556e-13 * t) * t) * t) * t) * t) * t;
+}
+case 49: {
+double t = 2*y100 - 99;
+return 0.13443048593088696613e0 + (0.25474249981080823877e-2 + (0.21385669591362915223e-4 + (0.15996177579900443030e-6 + (0.10585428844575134013e-8 + (0.61258809536787882989e-11 + 0.30412080142222222222e-13 * t) * t) * t) * t) * t) * t;
+}
+case 50: {
+double t = 2*y100 - 101;
+return 0.13961217543434561353e0 + (0.26349215871051761416e-2 + (0.22371342712572567744e-4 + (0.16868008199296822247e-6 + (0.11216596910444996246e-8 + (0.65015264753090890662e-11 + 0.32210394506666666666e-13 * t) * t) * t) * t) * t) * t;
+}
+case 51: {
+double t = 2*y100 - 103;
+return 0.14497287157673800690e0 + (0.27264675383982439814e-2 + (0.23410870961050950197e-4 + (0.17791863939526376477e-6 + (0.11886425714330958106e-8 + (0.68993039665054288034e-11 + 0.34101266222222222221e-13 * t) * t) * t) * t) * t) * t;
+}
+case 52: {
+double t = 2*y100 - 105;
+return 0.15052089272774618151e0 + (0.28222846410136238008e-2 + (0.24507470422713397006e-4 + (0.18770927679626136909e-6 + (0.12597184587583370712e-8 + (0.73203433049229821618e-11 + 0.36087889048888888890e-13 * t) * t) * t) * t) * t) * t;
+}
+case 53: {
+double t = 2*y100 - 107;
+return 0.15626501395774612325e0 + (0.29226079376196624949e-2 + (0.25664553693768450545e-4 + (0.19808568415654461964e-6 + (0.13351257759815557897e-8 + (0.77658124891046760667e-11 + 0.38173420035555555555e-13 * t) * t) * t) * t) * t) * t;
+}
+case 54: {
+double t = 2*y100 - 109;
+return 0.16221449434620737567e0 + (0.30276865332726475672e-2 + (0.26885741326534564336e-4 + (0.20908350604346384143e-6 + (0.14151148144240728728e-8 + (0.82369170665974313027e-11 + 0.40360957457777777779e-13 * t) * t) * t) * t) * t) * t;
+}
+case 55: {
+double t = 2*y100 - 111;
+return 0.16837910595412130659e0 + (0.31377844510793082301e-2 + (0.28174873844911175026e-4 + (0.22074043807045782387e-6 + (0.14999481055996090039e-8 + (0.87348993661930809254e-11 + 0.42653528977777777779e-13 * t) * t) * t) * t) * t) * t;
+}
+case 56: {
+double t = 2*y100 - 113;
+return 0.17476916455659369953e0 + (0.32531815370903068316e-2 + (0.29536024347344364074e-4 + (0.23309632627767074202e-6 + (0.15899007843582444846e-8 + (0.92610375235427359475e-11 + 0.45054073102222222221e-13 * t) * t) * t) * t) * t) * t;
+}
+case 57: {
+double t = 2*y100 - 115;
+return 0.18139556223643701364e0 + (0.33741744168096996041e-2 + (0.30973511714709500836e-4 + (0.24619326937592290996e-6 + (0.16852609412267750744e-8 + (0.98166442942854895573e-11 + 0.47565418097777777779e-13 * t) * t) * t) * t) * t) * t;
+}
+case 58: {
+double t = 2*y100 - 117;
+return 0.18826980194443664549e0 + (0.35010775057740317997e-2 + (0.32491914440014267480e-4 + (0.26007572375886319028e-6 + (0.17863299617388376116e-8 + (0.10403065638343878679e-10 + 0.50190265831111111110e-13 * t) * t) * t) * t) * t) * t;
+}
+case 59: {
+double t = 2*y100 - 119;
+return 0.19540403413693967350e0 + (0.36342240767211326315e-2 + (0.34096085096200907289e-4 + (0.27479061117017637474e-6 + (0.18934228504790032826e-8 + (0.11021679075323598664e-10 + 0.52931171733333333334e-13 * t) * t) * t) * t) * t) * t;
+}
+case 60: {
+double t = 2*y100 - 121;
+return 0.20281109560651886959e0 + (0.37739673859323597060e-2 + (0.35791165457592409054e-4 + (0.29038742889416172404e-6 + (0.20068685374849001770e-8 + (0.11673891799578381999e-10 + 0.55790523093333333334e-13 * t) * t) * t) * t) * t) * t;
+}
+case 61: {
+double t = 2*y100 - 123;
+return 0.21050455062669334978e0 + (0.39206818613925652425e-2 + (0.37582602289680101704e-4 + (0.30691836231886877385e-6 + (0.21270101645763677824e-8 + (0.12361138551062899455e-10 + 0.58770520160000000000e-13 * t) * t) * t) * t) * t) * t;
+}
+case 62: {
+double t = 2*y100 - 125;
+return 0.21849873453703332479e0 + (0.40747643554689586041e-2 + (0.39476163820986711501e-4 + (0.32443839970139918836e-6 + (0.22542053491518680200e-8 + (0.13084879235290858490e-10 + 0.61873153262222222221e-13 * t) * t) * t) * t) * t) * t;
+}
+case 63: {
+double t = 2*y100 - 127;
+return 0.22680879990043229327e0 + (0.42366354648628516935e-2 + (0.41477956909656896779e-4 + (0.34300544894502810002e-6 + (0.23888264229264067658e-8 + (0.13846596292818514601e-10 + 0.65100183751111111110e-13 * t) * t) * t) * t) * t) * t;
+}
+case 64: {
+double t = 2*y100 - 129;
+return 0.23545076536988703937e0 + (0.44067409206365170888e-2 + (0.43594444916224700881e-4 + (0.36268045617760415178e-6 + (0.25312606430853202748e-8 + (0.14647791812837903061e-10 + 0.68453122631111111110e-13 * t) * t) * t) * t) * t) * t;
+}
+case 65: {
+double t = 2*y100 - 131;
+return 0.24444156740777432838e0 + (0.45855530511605787178e-2 + (0.45832466292683085475e-4 + (0.38352752590033030472e-6 + (0.26819103733055603460e-8 + (0.15489984390884756993e-10 + 0.71933206364444444445e-13 * t) * t) * t) * t) * t) * t;
+}
+case 66: {
+double t = 2*y100 - 133;
+return 0.25379911500634264643e0 + (0.47735723208650032167e-2 + (0.48199253896534185372e-4 + (0.40561404245564732314e-6 + (0.28411932320871165585e-8 + (0.16374705736458320149e-10 + 0.75541379822222222221e-13 * t) * t) * t) * t) * t) * t;
+}
+case 67: {
+double t = 2*y100 - 135;
+return 0.26354234756393613032e0 + (0.49713289477083781266e-2 + (0.50702455036930367504e-4 + (0.42901079254268185722e-6 + (0.30095422058900481753e-8 + (0.17303497025347342498e-10 + 0.79278273368888888890e-13 * t) * t) * t) * t) * t) * t;
+}
+case 68: {
+double t = 2*y100 - 137;
+return 0.27369129607732343398e0 + (0.51793846023052643767e-2 + (0.53350152258326602629e-4 + (0.45379208848865015485e-6 + (0.31874057245814381257e-8 + (0.18277905010245111046e-10 + 0.83144182364444444445e-13 * t) * t) * t) * t) * t) * t;
+}
+case 69: {
+double t = 2*y100 - 139;
+return 0.28426714781640316172e0 + (0.53983341916695141966e-2 + (0.56150884865255810638e-4 + (0.48003589196494734238e-6 + (0.33752476967570796349e-8 + (0.19299477888083469086e-10 + 0.87139049137777777779e-13 * t) * t) * t) * t) * t) * t;
+}
+case 70: {
+double t = 2*y100 - 141;
+return 0.29529231465348519920e0 + (0.56288077305420795663e-2 + (0.59113671189913307427e-4 + (0.50782393781744840482e-6 + (0.35735475025851713168e-8 + (0.20369760937017070382e-10 + 0.91262442613333333334e-13 * t) * t) * t) * t) * t) * t;
+}
+case 71: {
+double t = 2*y100 - 143;
+return 0.30679050522528838613e0 + (0.58714723032745403331e-2 + (0.62248031602197686791e-4 + (0.53724185766200945789e-6 + (0.37827999418960232678e-8 + (0.21490291930444538307e-10 + 0.95513539182222222221e-13 * t) * t) * t) * t) * t) * t;
+}
+case 72: {
+double t = 2*y100 - 145;
+return 0.31878680111173319425e0 + (0.61270341192339103514e-2 + (0.65564012259707640976e-4 + (0.56837930287837738996e-6 + (0.40035151353392378882e-8 + (0.22662596341239294792e-10 + 0.99891109760000000000e-13 * t) * t) * t) * t) * t) * t;
+}
+case 73: {
+double t = 2*y100 - 147;
+return 0.33130773722152622027e0 + (0.63962406646798080903e-2 + (0.69072209592942396666e-4 + (0.60133006661885941812e-6 + (0.42362183765883466691e-8 + (0.23888182347073698382e-10 + 0.10439349811555555556e-12 * t) * t) * t) * t) * t) * t;
+}
+case 74: {
+double t = 2*y100 - 149;
+return 0.34438138658041336523e0 + (0.66798829540414007258e-2 + (0.72783795518603561144e-4 + (0.63619220443228800680e-6 + (0.44814499336514453364e-8 + (0.25168535651285475274e-10 + 0.10901861383111111111e-12 * t) * t) * t) * t) * t) * t;
+}
+case 75: {
+double t = 2*y100 - 151;
+return 0.35803744972380175583e0 + (0.69787978834882685031e-2 + (0.76710543371454822497e-4 + (0.67306815308917386747e-6 + (0.47397647975845228205e-8 + (0.26505114141143050509e-10 + 0.11376390933333333333e-12 * t) * t) * t) * t) * t) * t;
+}
+case 76: {
+double t = 2*y100 - 153;
+return 0.37230734890119724188e0 + (0.72938706896461381003e-2 + (0.80864854542670714092e-4 + (0.71206484718062688779e-6 + (0.50117323769745883805e-8 + (0.27899342394100074165e-10 + 0.11862637614222222222e-12 * t) * t) * t) * t) * t) * t;
+}
+case 77: {
+double t = 2*y100 - 155;
+return 0.38722432730555448223e0 + (0.76260375162549802745e-2 + (0.85259785810004603848e-4 + (0.75329383305171327677e-6 + (0.52979361368388119355e-8 + (0.29352606054164086709e-10 + 0.12360253370666666667e-12 * t) * t) * t) * t) * t) * t;
+}
+case 78: {
+double t = 2*y100 - 157;
+return 0.40282355354616940667e0 + (0.79762880915029728079e-2 + (0.89909077342438246452e-4 + (0.79687137961956194579e-6 + (0.55989731807360403195e-8 + (0.30866246101464869050e-10 + 0.12868841946666666667e-12 * t) * t) * t) * t) * t) * t;
+}
+case 79: {
+double t = 2*y100 - 159;
+return 0.41914223158913787649e0 + (0.83456685186950463538e-2 + (0.94827181359250161335e-4 + (0.84291858561783141014e-6 + (0.59154537751083485684e-8 + (0.32441553034347469291e-10 + 0.13387957943111111111e-12 * t) * t) * t) * t) * t) * t;
+}
+case 80: {
+double t = 2*y100 - 161;
+return 0.43621971639463786896e0 + (0.87352841828289495773e-2 + (0.10002929142066799966e-3 + (0.89156148280219880024e-6 + (0.62480008150788597147e-8 + (0.34079760983458878910e-10 + 0.13917107176888888889e-12 * t) * t) * t) * t) * t) * t;
+}
+case 81: {
+double t = 2*y100 - 163;
+return 0.45409763548534330981e0 + (0.91463027755548240654e-2 + (0.10553137232446167258e-3 + (0.94293113464638623798e-6 + (0.65972492312219959885e-8 + (0.35782041795476563662e-10 + 0.14455745872000000000e-12 * t) * t) * t) * t) * t) * t;
+}
+case 82: {
+double t = 2*y100 - 165;
+return 0.47282001668512331468e0 + (0.95799574408860463394e-2 + (0.11135019058000067469e-3 + (0.99716373005509038080e-6 + (0.69638453369956970347e-8 + (0.37549499088161345850e-10 + 0.15003280712888888889e-12 * t) * t) * t) * t) * t) * t;
+}
+case 83: {
+double t = 2*y100 - 167;
+return 0.49243342227179841649e0 + (0.10037550043909497071e-1 + (0.11750334542845234952e-3 + (0.10544006716188967172e-5 + (0.73484461168242224872e-8 + (0.39383162326435752965e-10 + 0.15559069118222222222e-12 * t) * t) * t) * t) * t) * t;
+}
+case 84: {
+double t = 2*y100 - 169;
+return 0.51298708979209258326e0 + (0.10520454564612427224e-1 + (0.12400930037494996655e-3 + (0.11147886579371265246e-5 + (0.77517184550568711454e-8 + (0.41283980931872622611e-10 + 0.16122419680000000000e-12 * t) * t) * t) * t) * t) * t;
+}
+case 85: {
+double t = 2*y100 - 171;
+return 0.53453307979101369843e0 + (0.11030120618800726938e-1 + (0.13088741519572269581e-3 + (0.11784797595374515432e-5 + (0.81743383063044825400e-8 + (0.43252818449517081051e-10 + 0.16692592640000000000e-12 * t) * t) * t) * t) * t) * t;
+}
+case 86: {
+double t = 2*y100 - 173;
+return 0.55712643071169299478e0 + (0.11568077107929735233e-1 + (0.13815797838036651289e-3 + (0.12456314879260904558e-5 + (0.86169898078969313597e-8 + (0.45290446811539652525e-10 + 0.17268801084444444444e-12 * t) * t) * t) * t) * t) * t;
+}
+case 87: {
+double t = 2*y100 - 175;
+return 0.58082532122519320968e0 + (0.12135935999503877077e-1 + (0.14584223996665838559e-3 + (0.13164068573095710742e-5 + (0.90803643355106020163e-8 + (0.47397540713124619155e-10 + 0.17850211608888888889e-12 * t) * t) * t) * t) * t) * t;
+}
+case 88: {
+double t = 2*y100 - 177;
+return 0.60569124025293375554e0 + (0.12735396239525550361e-1 + (0.15396244472258863344e-3 + (0.13909744385382818253e-5 + (0.95651595032306228245e-8 + (0.49574672127669041550e-10 + 0.18435945564444444444e-12 * t) * t) * t) * t) * t) * t;
+}
+case 89: {
+double t = 2*y100 - 179;
+return 0.63178916494715716894e0 + (0.13368247798287030927e-1 + (0.16254186562762076141e-3 + (0.14695084048334056083e-5 + (0.10072078109604152350e-7 + (0.51822304995680707483e-10 + 0.19025081422222222222e-12 * t) * t) * t) * t) * t) * t;
+}
+case 90: {
+double t = 2*y100 - 181;
+return 0.65918774689725319200e0 + (0.14036375850601992063e-1 + (0.17160483760259706354e-3 + (0.15521885688723188371e-5 + (0.10601827031535280590e-7 + (0.54140790105837520499e-10 + 0.19616655146666666667e-12 * t) * t) * t) * t) * t) * t;
+}
+case 91: {
+double t = 2*y100 - 183;
+return 0.68795950683174433822e0 + (0.14741765091365869084e-1 + (0.18117679143520433835e-3 + (0.16392004108230585213e-5 + (0.11155116068018043001e-7 + (0.56530360194925690374e-10 + 0.20209663662222222222e-12 * t) * t) * t) * t) * t) * t;
+}
+case 92: {
+double t = 2*y100 - 185;
+return 0.71818103808729967036e0 + (0.15486504187117112279e-1 + (0.19128428784550923217e-3 + (0.17307350969359975848e-5 + (0.11732656736113607751e-7 + (0.58991125287563833603e-10 + 0.20803065333333333333e-12 * t) * t) * t) * t) * t) * t;
+}
+case 93: {
+double t = 2*y100 - 187;
+return 0.74993321911726254661e0 + (0.16272790364044783382e-1 + (0.20195505163377912645e-3 + (0.18269894883203346953e-5 + (0.12335161021630225535e-7 + (0.61523068312169087227e-10 + 0.21395783431111111111e-12 * t) * t) * t) * t) * t) * t;
+}
+case 94: {
+double t = 2*y100 - 189;
+return 0.78330143531283492729e0 + (0.17102934132652429240e-1 + (0.21321800585063327041e-3 + (0.19281661395543913713e-5 + (0.12963340087354341574e-7 + (0.64126040998066348872e-10 + 0.21986708942222222222e-12 * t) * t) * t) * t) * t) * t;
+}
+case 95: {
+double t = 2*y100 - 191;
+return 0.81837581041023811832e0 + (0.17979364149044223802e-1 + (0.22510330592753129006e-3 + (0.20344732868018175389e-5 + (0.13617902941839949718e-7 + (0.66799760083972474642e-10 + 0.22574701262222222222e-12 * t) * t) * t) * t) * t) * t;
+}
+case 96: {
+double t = 2*y100 - 193;
+return 0.85525144775685126237e0 + (0.18904632212547561026e-1 + (0.23764237370371255638e-3 + (0.21461248251306387979e-5 + (0.14299555071870523786e-7 + (0.69543803864694171934e-10 + 0.23158593688888888889e-12 * t) * t) * t) * t) * t) * t;
+}
+case 97: {
+double t = 2*y100 - 195;
+return 0.89402868170849933734e0 + (0.19881418399127202569e-1 + (0.25086793128395995798e-3 + (0.22633402747585233180e-5 + (0.15008997042116532283e-7 + (0.72357609075043941261e-10 + 0.23737194737777777778e-12 * t) * t) * t) * t) * t) * t;
+}
+case 98: {
+double t = 2*y100 - 197;
+return 0.93481333942870796363e0 + (0.20912536329780368893e-1 + (0.26481403465998477969e-3 + (0.23863447359754921676e-5 + (0.15746923065472184451e-7 + (0.75240468141720143653e-10 + 0.24309291271111111111e-12 * t) * t) * t) * t) * t) * t;
+}
+case 99: {
+double t = 2*y100 - 199;
+return 0.97771701335885035464e0 + (0.22000938572830479551e-1 + (0.27951610702682383001e-3 + (0.25153688325245314530e-5 + (0.16514019547822821453e-7 + (0.78191526829368231251e-10 + 0.24873652355555555556e-12 * t) * t) * t) * t) * t) * t;
+}
+  }
+  // we only get here if y = 1, i.e. |x| < 4*eps, in which case
+  // erfcx is within 1e-15 of 1..
+  return 1.0;
+}
+
+double FADDEEVA_RE(erfcx)(double x)
+{
+  if (x >= 0) {
+    if (x > 50) { // continued-fraction expansion is faster
+      const double ispi = 0.56418958354775628694807945156; // 1 / sqrt(pi)
+      if (x > 5e7) // 1-term expansion, important to avoid overflow
+        return ispi / x;
+      /* 5-term expansion (rely on compiler for CSE), simplified from:
+                ispi / (x+0.5/(x+1/(x+1.5/(x+2/x))))  */
+      return ispi*((x*x) * (x*x+4.5) + 2) / (x * ((x*x) * (x*x+5) + 3.75));
+    }
+    return erfcx_y100(400/(4+x));
+  }
+  else
+    return x < -26.7 ? HUGE_VAL : (x < -6.1 ? 2*exp(x*x) 
+                                   : 2*exp(x*x) - erfcx_y100(400/(4-x)));
+}
+
+/////////////////////////////////////////////////////////////////////////
+/* Compute a scaled Dawson integral 
+            FADDEEVA(w_im)(x) = 2*Dawson(x)/sqrt(pi)
+   equivalent to the imaginary part w(x) for real x.
+
+   Uses methods similar to the erfcx calculation above: continued fractions
+   for large |x|, a lookup table of Chebyshev polynomials for smaller |x|,
+   and finally a Taylor expansion for |x|<0.01.
+   
+   Steven G. Johnson, October 2012. */
+
+/* Given y100=100*y, where y = 1/(1+x) for x >= 0, compute w_im(x).
+
+   Uses a look-up table of 100 different Chebyshev polynomials
+   for y intervals [0,0.01], [0.01,0.02], ...., [0.99,1], generated
+   with the help of Maple and a little shell script.   This allows
+   the Chebyshev polynomials to be of significantly lower degree (about 1/30)
+   compared to fitting the whole [0,1] interval with a single polynomial. */
+static double w_im_y100(double y100, double x) {
+  switch ((int) y100) {
+    case 0: {
+      double t = 2*y100 - 1;
+      return 0.28351593328822191546e-2 + (0.28494783221378400759e-2 + (0.14427470563276734183e-4 + (0.10939723080231588129e-6 + (0.92474307943275042045e-9 + (0.89128907666450075245e-11 + 0.92974121935111111110e-13 * t) * t) * t) * t) * t) * t;
+    }
+    case 1: {
+      double t = 2*y100 - 3;
+      return 0.85927161243940350562e-2 + (0.29085312941641339862e-2 + (0.15106783707725582090e-4 + (0.11716709978531327367e-6 + (0.10197387816021040024e-8 + (0.10122678863073360769e-10 + 0.10917479678400000000e-12 * t) * t) * t) * t) * t) * t;
+    }
+    case 2: {
+      double t = 2*y100 - 5;
+      return 0.14471159831187703054e-1 + (0.29703978970263836210e-2 + (0.15835096760173030976e-4 + (0.12574803383199211596e-6 + (0.11278672159518415848e-8 + (0.11547462300333495797e-10 + 0.12894535335111111111e-12 * t) * t) * t) * t) * t) * t;
+    }
+    case 3: {
+      double t = 2*y100 - 7;
+      return 0.20476320420324610618e-1 + (0.30352843012898665856e-2 + (0.16617609387003727409e-4 + (0.13525429711163116103e-6 + (0.12515095552507169013e-8 + (0.13235687543603382345e-10 + 0.15326595042666666667e-12 * t) * t) * t) * t) * t) * t;
+    }
+    case 4: {
+      double t = 2*y100 - 9;
+      return 0.26614461952489004566e-1 + (0.31034189276234947088e-2 + (0.17460268109986214274e-4 + (0.14582130824485709573e-6 + (0.13935959083809746345e-8 + (0.15249438072998932900e-10 + 0.18344741882133333333e-12 * t) * t) * t) * t) * t) * t;
+    }
+    case 5: {
+      double t = 2*y100 - 11;
+      return 0.32892330248093586215e-1 + (0.31750557067975068584e-2 + (0.18369907582308672632e-4 + (0.15761063702089457882e-6 + (0.15577638230480894382e-8 + (0.17663868462699097951e-10 + (0.22126732680711111111e-12 + 0.30273474177737853668e-14 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 6: {
+      double t = 2*y100 - 13;
+      return 0.39317207681134336024e-1 + (0.32504779701937539333e-2 + (0.19354426046513400534e-4 + (0.17081646971321290539e-6 + (0.17485733959327106250e-8 + (0.20593687304921961410e-10 + (0.26917401949155555556e-12 + 0.38562123837725712270e-14 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 7: {
+      double t = 2*y100 - 15;
+      return 0.45896976511367738235e-1 + (0.33300031273110976165e-2 + (0.20423005398039037313e-4 + (0.18567412470376467303e-6 + (0.19718038363586588213e-8 + (0.24175006536781219807e-10 + (0.33059982791466666666e-12 + 0.49756574284439426165e-14 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 8: {
+      double t = 2*y100 - 17;
+      return 0.52640192524848962855e-1 + (0.34139883358846720806e-2 + (0.21586390240603337337e-4 + (0.20247136501568904646e-6 + (0.22348696948197102935e-8 + (0.28597516301950162548e-10 + (0.41045502119111111110e-12 + 0.65151614515238361946e-14 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 9: {
+      double t = 2*y100 - 19;
+      return 0.59556171228656770456e-1 + (0.35028374386648914444e-2 + (0.22857246150998562824e-4 + (0.22156372146525190679e-6 + (0.25474171590893813583e-8 + (0.34122390890697400584e-10 + (0.51593189879111111110e-12 + 0.86775076853908006938e-14 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 10: {
+      double t = 2*y100 - 21;
+      return 0.66655089485108212551e-1 + (0.35970095381271285568e-2 + (0.24250626164318672928e-4 + (0.24339561521785040536e-6 + (0.29221990406518411415e-8 + (0.41117013527967776467e-10 + (0.65786450716444444445e-12 + 0.11791885745450623331e-13 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 11: {
+      double t = 2*y100 - 23;
+      return 0.73948106345519174661e-1 + (0.36970297216569341748e-2 + (0.25784588137312868792e-4 + (0.26853012002366752770e-6 + (0.33763958861206729592e-8 + (0.50111549981376976397e-10 + (0.85313857496888888890e-12 + 0.16417079927706899860e-13 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 12: {
+      double t = 2*y100 - 25;
+      return 0.81447508065002963203e-1 + (0.38035026606492705117e-2 + (0.27481027572231851896e-4 + (0.29769200731832331364e-6 + (0.39336816287457655076e-8 + (0.61895471132038157624e-10 + (0.11292303213511111111e-11 + 0.23558532213703884304e-13 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 13: {
+      double t = 2*y100 - 27;
+      return 0.89166884027582716628e-1 + (0.39171301322438946014e-2 + (0.29366827260422311668e-4 + (0.33183204390350724895e-6 + (0.46276006281647330524e-8 + (0.77692631378169813324e-10 + (0.15335153258844444444e-11 + 0.35183103415916026911e-13 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 14: {
+      double t = 2*y100 - 29;
+      return 0.97121342888032322019e-1 + (0.40387340353207909514e-2 + (0.31475490395950776930e-4 + (0.37222714227125135042e-6 + (0.55074373178613809996e-8 + (0.99509175283990337944e-10 + (0.21552645758222222222e-11 + 0.55728651431872687605e-13 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 15: {
+      double t = 2*y100 - 31;
+      return 0.10532778218603311137e0 + (0.41692873614065380607e-2 + (0.33849549774889456984e-4 + (0.42064596193692630143e-6 + (0.66494579697622432987e-8 + (0.13094103581931802337e-9 + (0.31896187409777777778e-11 + 0.97271974184476560742e-13 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 16: {
+      double t = 2*y100 - 33;
+      return 0.11380523107427108222e0 + (0.43099572287871821013e-2 + (0.36544324341565929930e-4 + (0.47965044028581857764e-6 + (0.81819034238463698796e-8 + (0.17934133239549647357e-9 + (0.50956666166186293627e-11 + (0.18850487318190638010e-12 + 0.79697813173519853340e-14 * t) * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 17: {
+      double t = 2*y100 - 35;
+      return 0.12257529703447467345e0 + (0.44621675710026986366e-2 + (0.39634304721292440285e-4 + (0.55321553769873381819e-6 + (0.10343619428848520870e-7 + (0.26033830170470368088e-9 + (0.87743837749108025357e-11 + (0.34427092430230063401e-12 + 0.10205506615709843189e-13 * t) * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 18: {
+      double t = 2*y100 - 37;
+      return 0.13166276955656699478e0 + (0.46276970481783001803e-2 + (0.43225026380496399310e-4 + (0.64799164020016902656e-6 + (0.13580082794704641782e-7 + (0.39839800853954313927e-9 + (0.14431142411840000000e-10 + 0.42193457308830027541e-12 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 19: {
+      double t = 2*y100 - 39;
+      return 0.14109647869803356475e0 + (0.48088424418545347758e-2 + (0.47474504753352150205e-4 + (0.77509866468724360352e-6 + (0.18536851570794291724e-7 + (0.60146623257887570439e-9 + (0.18533978397305276318e-10 + (0.41033845938901048380e-13 - 0.46160680279304825485e-13 * t) * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 20: {
+      double t = 2*y100 - 41;
+      return 0.15091057940548936603e0 + (0.50086864672004685703e-2 + (0.52622482832192230762e-4 + (0.95034664722040355212e-6 + (0.25614261331144718769e-7 + (0.80183196716888606252e-9 + (0.12282524750534352272e-10 + (-0.10531774117332273617e-11 - 0.86157181395039646412e-13 * t) * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 21: {
+      double t = 2*y100 - 43;
+      return 0.16114648116017010770e0 + (0.52314661581655369795e-2 + (0.59005534545908331315e-4 + (0.11885518333915387760e-5 + (0.33975801443239949256e-7 + (0.82111547144080388610e-9 + (-0.12357674017312854138e-10 + (-0.24355112256914479176e-11 - 0.75155506863572930844e-13 * t) * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 22: {
+      double t = 2*y100 - 45;
+      return 0.17185551279680451144e0 + (0.54829002967599420860e-2 + (0.67013226658738082118e-4 + (0.14897400671425088807e-5 + (0.40690283917126153701e-7 + (0.44060872913473778318e-9 + (-0.52641873433280000000e-10 - 0.30940587864543343124e-11 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 23: {
+      double t = 2*y100 - 47;
+      return 0.18310194559815257381e0 + (0.57701559375966953174e-2 + (0.76948789401735193483e-4 + (0.18227569842290822512e-5 + (0.41092208344387212276e-7 + (-0.44009499965694442143e-9 + (-0.92195414685628803451e-10 + (-0.22657389705721753299e-11 + 0.10004784908106839254e-12 * t) * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 24: {
+      double t = 2*y100 - 49;
+      return 0.19496527191546630345e0 + (0.61010853144364724856e-2 + (0.88812881056342004864e-4 + (0.21180686746360261031e-5 + (0.30652145555130049203e-7 + (-0.16841328574105890409e-8 + (-0.11008129460612823934e-9 + (-0.12180794204544515779e-12 + 0.15703325634590334097e-12 * t) * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 25: {
+      double t = 2*y100 - 51;
+      return 0.20754006813966575720e0 + (0.64825787724922073908e-2 + (0.10209599627522311893e-3 + (0.22785233392557600468e-5 + (0.73495224449907568402e-8 + (-0.29442705974150112783e-8 + (-0.94082603434315016546e-10 + (0.23609990400179321267e-11 + 0.14141908654269023788e-12 * t) * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 26: {
+      double t = 2*y100 - 53;
+      return 0.22093185554845172146e0 + (0.69182878150187964499e-2 + (0.11568723331156335712e-3 + (0.22060577946323627739e-5 + (-0.26929730679360840096e-7 + (-0.38176506152362058013e-8 + (-0.47399503861054459243e-10 + (0.40953700187172127264e-11 + 0.69157730376118511127e-13 * t) * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 27: {
+      double t = 2*y100 - 55;
+      return 0.23524827304057813918e0 + (0.74063350762008734520e-2 + (0.12796333874615790348e-3 + (0.18327267316171054273e-5 + (-0.66742910737957100098e-7 + (-0.40204740975496797870e-8 + (0.14515984139495745330e-10 + (0.44921608954536047975e-11 - 0.18583341338983776219e-13 * t) * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 28: {
+      double t = 2*y100 - 57;
+      return 0.25058626331812744775e0 + (0.79377285151602061328e-2 + (0.13704268650417478346e-3 + (0.11427511739544695861e-5 + (-0.10485442447768377485e-6 + (-0.34850364756499369763e-8 + (0.72656453829502179208e-10 + (0.36195460197779299406e-11 - 0.84882136022200714710e-13 * t) * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 29: {
+      double t = 2*y100 - 59;
+      return 0.26701724900280689785e0 + (0.84959936119625864274e-2 + (0.14112359443938883232e-3 + (0.17800427288596909634e-6 + (-0.13443492107643109071e-6 + (-0.23512456315677680293e-8 + (0.11245846264695936769e-9 + (0.19850501334649565404e-11 - 0.11284666134635050832e-12 * t) * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 30: {
+      double t = 2*y100 - 61;
+      return 0.28457293586253654144e0 + (0.90581563892650431899e-2 + (0.13880520331140646738e-3 + (-0.97262302362522896157e-6 + (-0.15077100040254187366e-6 + (-0.88574317464577116689e-9 + (0.12760311125637474581e-9 + (0.20155151018282695055e-12 - 0.10514169375181734921e-12 * t) * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 31: {
+      double t = 2*y100 - 63;
+      return 0.30323425595617385705e0 + (0.95968346790597422934e-2 + (0.12931067776725883939e-3 + (-0.21938741702795543986e-5 + (-0.15202888584907373963e-6 + (0.61788350541116331411e-9 + (0.11957835742791248256e-9 + (-0.12598179834007710908e-11 - 0.75151817129574614194e-13 * t) * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 32: {
+      double t = 2*y100 - 65;
+      return 0.32292521181517384379e0 + (0.10082957727001199408e-1 + (0.11257589426154962226e-3 + (-0.33670890319327881129e-5 + (-0.13910529040004008158e-6 + (0.19170714373047512945e-8 + (0.94840222377720494290e-10 + (-0.21650018351795353201e-11 - 0.37875211678024922689e-13 * t) * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 33: {
+      double t = 2*y100 - 67;
+      return 0.34351233557911753862e0 + (0.10488575435572745309e-1 + (0.89209444197248726614e-4 + (-0.43893459576483345364e-5 + (-0.11488595830450424419e-6 + (0.28599494117122464806e-8 + (0.61537542799857777779e-10 - 0.24935749227658002212e-11 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 34: {
+      double t = 2*y100 - 69;
+      return 0.36480946642143669093e0 + (0.10789304203431861366e-1 + (0.60357993745283076834e-4 + (-0.51855862174130669389e-5 + (-0.83291664087289801313e-7 + (0.33898011178582671546e-8 + (0.27082948188277716482e-10 + (-0.23603379397408694974e-11 + 0.19328087692252869842e-13 * t) * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 35: {
+      double t = 2*y100 - 71;
+      return 0.38658679935694939199e0 + (0.10966119158288804999e-1 + (0.27521612041849561426e-4 + (-0.57132774537670953638e-5 + (-0.48404772799207914899e-7 + (0.35268354132474570493e-8 + (-0.32383477652514618094e-11 + (-0.19334202915190442501e-11 + 0.32333189861286460270e-13 * t) * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 36: {
+      double t = 2*y100 - 73;
+      return 0.40858275583808707870e0 + (0.11006378016848466550e-1 + (-0.76396376685213286033e-5 + (-0.59609835484245791439e-5 + (-0.13834610033859313213e-7 + (0.33406952974861448790e-8 + (-0.26474915974296612559e-10 + (-0.13750229270354351983e-11 + 0.36169366979417390637e-13 * t) * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 37: {
+      double t = 2*y100 - 75;
+      return 0.43051714914006682977e0 + (0.10904106549500816155e-1 + (-0.43477527256787216909e-4 + (-0.59429739547798343948e-5 + (0.17639200194091885949e-7 + (0.29235991689639918688e-8 + (-0.41718791216277812879e-10 + (-0.81023337739508049606e-12 + 0.33618915934461994428e-13 * t) * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 38: {
+      double t = 2*y100 - 77;
+      return 0.45210428135559607406e0 + (0.10659670756384400554e-1 + (-0.78488639913256978087e-4 + (-0.56919860886214735936e-5 + (0.44181850467477733407e-7 + (0.23694306174312688151e-8 + (-0.49492621596685443247e-10 + (-0.31827275712126287222e-12 + 0.27494438742721623654e-13 * t) * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 39: {
+      double t = 2*y100 - 79;
+      return 0.47306491195005224077e0 + (0.10279006119745977570e-1 + (-0.11140268171830478306e-3 + (-0.52518035247451432069e-5 + (0.64846898158889479518e-7 + (0.17603624837787337662e-8 + (-0.51129481592926104316e-10 + (0.62674584974141049511e-13 + 0.20055478560829935356e-13 * t) * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 40: {
+      double t = 2*y100 - 81;
+      return 0.49313638965719857647e0 + (0.97725799114772017662e-2 + (-0.14122854267291533334e-3 + (-0.46707252568834951907e-5 + (0.79421347979319449524e-7 + (0.11603027184324708643e-8 + (-0.48269605844397175946e-10 + (0.32477251431748571219e-12 + 0.12831052634143527985e-13 * t) * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 41: {
+      double t = 2*y100 - 83;
+      return 0.51208057433416004042e0 + (0.91542422354009224951e-2 + (-0.16726530230228647275e-3 + (-0.39964621752527649409e-5 + (0.88232252903213171454e-7 + (0.61343113364949928501e-9 + (-0.42516755603130443051e-10 + (0.47910437172240209262e-12 + 0.66784341874437478953e-14 * t) * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 42: {
+      double t = 2*y100 - 85;
+      return 0.52968945458607484524e0 + (0.84400880445116786088e-2 + (-0.18908729783854258774e-3 + (-0.32725905467782951931e-5 + (0.91956190588652090659e-7 + (0.14593989152420122909e-9 + (-0.35239490687644444445e-10 + 0.54613829888448694898e-12 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 43: {
+      double t = 2*y100 - 87;
+      return 0.54578857454330070965e0 + (0.76474155195880295311e-2 + (-0.20651230590808213884e-3 + (-0.25364339140543131706e-5 + (0.91455367999510681979e-7 + (-0.23061359005297528898e-9 + (-0.27512928625244444444e-10 + 0.54895806008493285579e-12 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 44: {
+      double t = 2*y100 - 89;
+      return 0.56023851910298493910e0 + (0.67938321739997196804e-2 + (-0.21956066613331411760e-3 + (-0.18181127670443266395e-5 + (0.87650335075416845987e-7 + (-0.51548062050366615977e-9 + (-0.20068462174044444444e-10 + 0.50912654909758187264e-12 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 45: {
+      double t = 2*y100 - 91;
+      return 0.57293478057455721150e0 + (0.58965321010394044087e-2 + (-0.22841145229276575597e-3 + (-0.11404605562013443659e-5 + (0.81430290992322326296e-7 + (-0.71512447242755357629e-9 + (-0.13372664928000000000e-10 + 0.44461498336689298148e-12 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 46: {
+      double t = 2*y100 - 93;
+      return 0.58380635448407827360e0 + (0.49717469530842831182e-2 + (-0.23336001540009645365e-3 + (-0.51952064448608850822e-6 + (0.73596577815411080511e-7 + (-0.84020916763091566035e-9 + (-0.76700972702222222221e-11 + 0.36914462807972467044e-12 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 47: {
+      double t = 2*y100 - 95;
+      return 0.59281340237769489597e0 + (0.40343592069379730568e-2 + (-0.23477963738658326185e-3 + (0.34615944987790224234e-7 + (0.64832803248395814574e-7 + (-0.90329163587627007971e-9 + (-0.30421940400000000000e-11 + 0.29237386653743536669e-12 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 48: {
+      double t = 2*y100 - 97;
+      return 0.59994428743114271918e0 + (0.30976579788271744329e-2 + (-0.23308875765700082835e-3 + (0.51681681023846925160e-6 + (0.55694594264948268169e-7 + (-0.91719117313243464652e-9 + (0.53982743680000000000e-12 + 0.22050829296187771142e-12 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 49: {
+      double t = 2*y100 - 99;
+      return 0.60521224471819875444e0 + (0.21732138012345456060e-2 + (-0.22872428969625997456e-3 + (0.92588959922653404233e-6 + (0.46612665806531930684e-7 + (-0.89393722514414153351e-9 + (0.31718550353777777778e-11 + 0.15705458816080549117e-12 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 50: {
+      double t = 2*y100 - 101;
+      return 0.60865189969791123620e0 + (0.12708480848877451719e-2 + (-0.22212090111534847166e-3 + (0.12636236031532793467e-5 + (0.37904037100232937574e-7 + (-0.84417089968101223519e-9 + (0.49843180828444444445e-11 + 0.10355439441049048273e-12 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 51: {
+      double t = 2*y100 - 103;
+      return 0.61031580103499200191e0 + (0.39867436055861038223e-3 + (-0.21369573439579869291e-3 + (0.15339402129026183670e-5 + (0.29787479206646594442e-7 + (-0.77687792914228632974e-9 + (0.61192452741333333334e-11 + 0.60216691829459295780e-13 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 52: {
+      double t = 2*y100 - 105;
+      return 0.61027109047879835868e0 + (-0.43680904508059878254e-3 + (-0.20383783788303894442e-3 + (0.17421743090883439959e-5 + (0.22400425572175715576e-7 + (-0.69934719320045128997e-9 + (0.67152759655111111110e-11 + 0.26419960042578359995e-13 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 53: {
+      double t = 2*y100 - 107;
+      return 0.60859639489217430521e0 + (-0.12305921390962936873e-2 + (-0.19290150253894682629e-3 + (0.18944904654478310128e-5 + (0.15815530398618149110e-7 + (-0.61726850580964876070e-9 + 0.68987888999111111110e-11 * t) * t) * t) * t) * t) * t;
+    }
+    case 54: {
+      double t = 2*y100 - 109;
+      return 0.60537899426486075181e0 + (-0.19790062241395705751e-2 + (-0.18120271393047062253e-3 + (0.19974264162313241405e-5 + (0.10055795094298172492e-7 + (-0.53491997919318263593e-9 + (0.67794550295111111110e-11 - 0.17059208095741511603e-13 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 55: {
+      double t = 2*y100 - 111;
+      return 0.60071229457904110537e0 + (-0.26795676776166354354e-2 + (-0.16901799553627508781e-3 + (0.20575498324332621581e-5 + (0.51077165074461745053e-8 + (-0.45536079828057221858e-9 + (0.64488005516444444445e-11 - 0.29311677573152766338e-13 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 56: {
+      double t = 2*y100 - 113;
+      return 0.59469361520112714738e0 + (-0.33308208190600993470e-2 + (-0.15658501295912405679e-3 + (0.20812116912895417272e-5 + (0.93227468760614182021e-9 + (-0.38066673740116080415e-9 + (0.59806790359111111110e-11 - 0.36887077278950440597e-13 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 57: {
+      double t = 2*y100 - 115;
+      return 0.58742228631775388268e0 + (-0.39321858196059227251e-2 + (-0.14410441141450122535e-3 + (0.20743790018404020716e-5 + (-0.25261903811221913762e-8 + (-0.31212416519526924318e-9 + (0.54328422462222222221e-11 - 0.40864152484979815972e-13 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 58: {
+      double t = 2*y100 - 117;
+      return 0.57899804200033018447e0 + (-0.44838157005618913447e-2 + (-0.13174245966501437965e-3 + (0.20425306888294362674e-5 + (-0.53330296023875447782e-8 + (-0.25041289435539821014e-9 + (0.48490437205333333334e-11 - 0.42162206939169045177e-13 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 59: {
+      double t = 2*y100 - 119;
+      return 0.56951968796931245974e0 + (-0.49864649488074868952e-2 + (-0.11963416583477567125e-3 + (0.19906021780991036425e-5 + (-0.75580140299436494248e-8 + (-0.19576060961919820491e-9 + (0.42613011928888888890e-11 - 0.41539443304115604377e-13 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 60: {
+      double t = 2*y100 - 121;
+      return 0.55908401930063918964e0 + (-0.54413711036826877753e-2 + (-0.10788661102511914628e-3 + (0.19229663322982839331e-5 + (-0.92714731195118129616e-8 + (-0.14807038677197394186e-9 + (0.36920870298666666666e-11 - 0.39603726688419162617e-13 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 61: {
+      double t = 2*y100 - 123;
+      return 0.54778496152925675315e0 + (-0.58501497933213396670e-2 + (-0.96582314317855227421e-4 + (0.18434405235069270228e-5 + (-0.10541580254317078711e-7 + (-0.10702303407788943498e-9 + (0.31563175582222222222e-11 - 0.36829748079110481422e-13 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 62: {
+      double t = 2*y100 - 125;
+      return 0.53571290831682823999e0 + (-0.62147030670760791791e-2 + (-0.85782497917111760790e-4 + (0.17553116363443470478e-5 + (-0.11432547349815541084e-7 + (-0.72157091369041330520e-10 + (0.26630811607111111111e-11 - 0.33578660425893164084e-13 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 63: {
+      double t = 2*y100 - 127;
+      return 0.52295422962048434978e0 + (-0.65371404367776320720e-2 + (-0.75530164941473343780e-4 + (0.16613725797181276790e-5 + (-0.12003521296598910761e-7 + (-0.42929753689181106171e-10 + (0.22170894940444444444e-11 - 0.30117697501065110505e-13 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 64: {
+      double t = 2*y100 - 129;
+      return 0.50959092577577886140e0 + (-0.68197117603118591766e-2 + (-0.65852936198953623307e-4 + (0.15639654113906716939e-5 + (-0.12308007991056524902e-7 + (-0.18761997536910939570e-10 + (0.18198628922666666667e-11 - 0.26638355362285200932e-13 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 65: {
+      double t = 2*y100 - 131;
+      return 0.49570040481823167970e0 + (-0.70647509397614398066e-2 + (-0.56765617728962588218e-4 + (0.14650274449141448497e-5 + (-0.12393681471984051132e-7 + (0.92904351801168955424e-12 + (0.14706755960177777778e-11 - 0.23272455351266325318e-13 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 66: {
+      double t = 2*y100 - 133;
+      return 0.48135536250935238066e0 + (-0.72746293327402359783e-2 + (-0.48272489495730030780e-4 + (0.13661377309113939689e-5 + (-0.12302464447599382189e-7 + (0.16707760028737074907e-10 + (0.11672928324444444444e-11 - 0.20105801424709924499e-13 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 67: {
+      double t = 2*y100 - 135;
+      return 0.46662374675511439448e0 + (-0.74517177649528487002e-2 + (-0.40369318744279128718e-4 + (0.12685621118898535407e-5 + (-0.12070791463315156250e-7 + (0.29105507892605823871e-10 + (0.90653314645333333334e-12 - 0.17189503312102982646e-13 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 68: {
+      double t = 2*y100 - 137;
+      return 0.45156879030168268778e0 + (-0.75983560650033817497e-2 + (-0.33045110380705139759e-4 + (0.11732956732035040896e-5 + (-0.11729986947158201869e-7 + (0.38611905704166441308e-10 + (0.68468768305777777779e-12 - 0.14549134330396754575e-13 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 69: {
+      double t = 2*y100 - 139;
+      return 0.43624909769330896904e0 + (-0.77168291040309554679e-2 + (-0.26283612321339907756e-4 + (0.10811018836893550820e-5 + (-0.11306707563739851552e-7 + (0.45670446788529607380e-10 + (0.49782492549333333334e-12 - 0.12191983967561779442e-13 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 70: {
+      double t = 2*y100 - 141;
+      return 0.42071877443548481181e0 + (-0.78093484015052730097e-2 + (-0.20064596897224934705e-4 + (0.99254806680671890766e-6 + (-0.10823412088884741451e-7 + (0.50677203326904716247e-10 + (0.34200547594666666666e-12 - 0.10112698698356194618e-13 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 71: {
+      double t = 2*y100 - 143;
+      return 0.40502758809710844280e0 + (-0.78780384460872937555e-2 + (-0.14364940764532853112e-4 + (0.90803709228265217384e-6 + (-0.10298832847014466907e-7 + (0.53981671221969478551e-10 + (0.21342751381333333333e-12 - 0.82975901848387729274e-14 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 72: {
+      double t = 2*y100 - 145;
+      return 0.38922115269731446690e0 + (-0.79249269708242064120e-2 + (-0.91595258799106970453e-5 + (0.82783535102217576495e-6 + (-0.97484311059617744437e-8 + (0.55889029041660225629e-10 + (0.10851981336888888889e-12 - 0.67278553237853459757e-14 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 73: {
+      double t = 2*y100 - 147;
+      return 0.37334112915460307335e0 + (-0.79519385109223148791e-2 + (-0.44219833548840469752e-5 + (0.75209719038240314732e-6 + (-0.91848251458553190451e-8 + (0.56663266668051433844e-10 + (0.23995894257777777778e-13 - 0.53819475285389344313e-14 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 74: {
+      double t = 2*y100 - 149;
+      return 0.35742543583374223085e0 + (-0.79608906571527956177e-2 + (-0.12530071050975781198e-6 + (0.68088605744900552505e-6 + (-0.86181844090844164075e-8 + (0.56530784203816176153e-10 + (-0.43120012248888888890e-13 - 0.42372603392496813810e-14 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 75: {
+      double t = 2*y100 - 151;
+      return 0.34150846431979618536e0 + (-0.79534924968773806029e-2 + (0.37576885610891515813e-5 + (0.61419263633090524326e-6 + (-0.80565865409945960125e-8 + (0.55684175248749269411e-10 + (-0.95486860764444444445e-13 - 0.32712946432984510595e-14 * t) * t) * t) * t) * t) * t) * t;
+    }
+    case 76: {
+      double t = 2*y100 - 153;
+      return 0.32562129649136346824e0 + (-0.79313448067948884309e-2 + (0.72539159933545300034e-5 + (0.55195028297415503083e-6 + (-0.75063365335570475258e-8 + (0.54281686749699595941e-10 - 0.13545424295111111111e-12 * t) * t) * t) * t) * t) * t;
+    }
+    case 77: {
+      double t = 2*y100 - 155;
+      return 0.30979191977078391864e0 + (-0.78959416264207333695e-2 + (0.10389774377677210794e-4 + (0.49404804463196316464e-6 + (-0.69722488229411164685e-8 + (0.52469254655951393842e-10 - 0.16507860650666666667e-12 * t) * t) * t) * t) * t) * t;
+    }
+    case 78: {
+      double t = 2*y100 - 157;
+      return 0.29404543811214459904e0 + (-0.78486728990364155356e-2 + (0.13190885683106990459e-4 + (0.44034158861387909694e-6 + (-0.64578942561562616481e-8 + (0.50354306498006928984e-10 - 0.18614473550222222222e-12 * t) * t) * t) * t) * t) * t;
+    }
+    case 79: {
+      double t = 2*y100 - 159;
+      return 0.27840427686253660515e0 + (-0.77908279176252742013e-2 + (0.15681928798708548349e-4 + (0.39066226205099807573e-6 + (-0.59658144820660420814e-8 + (0.48030086420373141763e-10 - 0.20018995173333333333e-12 * t) * t) * t) * t) * t) * t;
+    }
+    case 80: {
+      double t = 2*y100 - 161;
+      return 0.26288838011163800908e0 + (-0.77235993576119469018e-2 + (0.17886516796198660969e-4 + (0.34482457073472497720e-6 + (-0.54977066551955420066e-8 + (0.45572749379147269213e-10 - 0.20852924954666666667e-12 * t) * t) * t) * t) * t) * t;
+    }
+    case 81: {
+      double t = 2*y100 - 163;
+      return 0.24751539954181029717e0 + (-0.76480877165290370975e-2 + (0.19827114835033977049e-4 + (0.30263228619976332110e-6 + (-0.50545814570120129947e-8 + (0.43043879374212005966e-10 - 0.21228012028444444444e-12 * t) * t) * t) * t) * t) * t;
+    }
+    case 82: {
+      double t = 2*y100 - 165;
+      return 0.23230087411688914593e0 + (-0.75653060136384041587e-2 + (0.21524991113020016415e-4 + (0.26388338542539382413e-6 + (-0.46368974069671446622e-8 + (0.40492715758206515307e-10 - 0.21238627815111111111e-12 * t) * t) * t) * t) * t) * t;
+    }
+    case 83: {
+      double t = 2*y100 - 167;
+      return 0.21725840021297341931e0 + (-0.74761846305979730439e-2 + (0.23000194404129495243e-4 + (0.22837400135642906796e-6 + (-0.42446743058417541277e-8 + (0.37958104071765923728e-10 - 0.20963978568888888889e-12 * t) * t) * t) * t) * t) * t;
+    }
+    case 84: {
+      double t = 2*y100 - 169;
+      return 0.20239979200788191491e0 + (-0.73815761980493466516e-2 + (0.24271552727631854013e-4 + (0.19590154043390012843e-6 + (-0.38775884642456551753e-8 + (0.35470192372162901168e-10 - 0.20470131678222222222e-12 * t) * t) * t) * t) * t) * t;
+    }
+    case 85: {
+      double t = 2*y100 - 171;
+      return 0.18773523211558098962e0 + (-0.72822604530339834448e-2 + (0.25356688567841293697e-4 + (0.16626710297744290016e-6 + (-0.35350521468015310830e-8 + (0.33051896213898864306e-10 - 0.19811844544000000000e-12 * t) * t) * t) * t) * t) * t;
+    }
+    case 86: {
+      double t = 2*y100 - 173;
+      return 0.17327341258479649442e0 + (-0.71789490089142761950e-2 + (0.26272046822383820476e-4 + (0.13927732375657362345e-6 + (-0.32162794266956859603e-8 + (0.30720156036105652035e-10 - 0.19034196304000000000e-12 * t) * t) * t) * t) * t) * t;
+    }
+    case 87: {
+      double t = 2*y100 - 175;
+      return 0.15902166648328672043e0 + (-0.70722899934245504034e-2 + (0.27032932310132226025e-4 + (0.11474573347816568279e-6 + (-0.29203404091754665063e-8 + (0.28487010262547971859e-10 - 0.18174029063111111111e-12 * t) * t) * t) * t) * t) * t;
+    }
+    case 88: {
+      double t = 2*y100 - 177;
+      return 0.14498609036610283865e0 + (-0.69628725220045029273e-2 + (0.27653554229160596221e-4 + (0.92493727167393036470e-7 + (-0.26462055548683583849e-8 + (0.26360506250989943739e-10 - 0.17261211260444444444e-12 * t) * t) * t) * t) * t) * t;
+    }
+    case 89: {
+      double t = 2*y100 - 179;
+      return 0.13117165798208050667e0 + (-0.68512309830281084723e-2 + (0.28147075431133863774e-4 + (0.72351212437979583441e-7 + (-0.23927816200314358570e-8 + (0.24345469651209833155e-10 - 0.16319736960000000000e-12 * t) * t) * t) * t) * t) * t;
+    }
+    case 90: {
+      double t = 2*y100 - 181;
+      return 0.11758232561160626306e0 + (-0.67378491192463392927e-2 + (0.28525664781722907847e-4 + (0.54156999310046790024e-7 + (-0.21589405340123827823e-8 + (0.22444150951727334619e-10 - 0.15368675584000000000e-12 * t) * t) * t) * t) * t) * t;
+    }
+    case 91: {
+      double t = 2*y100 - 183;
+      return 0.10422112945361673560e0 + (-0.66231638959845581564e-2 + (0.28800551216363918088e-4 + (0.37758983397952149613e-7 + (-0.19435423557038933431e-8 + (0.20656766125421362458e-10 - 0.14422990012444444444e-12 * t) * t) * t) * t) * t) * t;
+    }
+    case 92: {
+      double t = 2*y100 - 185;
+      return 0.91090275493541084785e-1 + (-0.65075691516115160062e-2 + (0.28982078385527224867e-4 + (0.23014165807643012781e-7 + (-0.17454532910249875958e-8 + (0.18981946442680092373e-10 - 0.13494234691555555556e-12 * t) * t) * t) * t) * t) * t;
+    }
+    case 93: {
+      double t = 2*y100 - 187;
+      return 0.78191222288771379358e-1 + (-0.63914190297303976434e-2 + (0.29079759021299682675e-4 + (0.97885458059415717014e-8 + (-0.15635596116134296819e-8 + (0.17417110744051331974e-10 - 0.12591151763555555556e-12 * t) * t) * t) * t) * t) * t;
+    }
+    case 94: {
+      double t = 2*y100 - 189;
+      return 0.65524757106147402224e-1 + (-0.62750311956082444159e-2 + (0.29102328354323449795e-4 + (-0.20430838882727954582e-8 + (-0.13967781903855367270e-8 + (0.15958771833747057569e-10 - 0.11720175765333333333e-12 * t) * t) * t) * t) * t) * t;
+    }
+    case 95: {
+      double t = 2*y100 - 191;
+      return 0.53091065838453612773e-1 + (-0.61586898417077043662e-2 + (0.29057796072960100710e-4 + (-0.12597414620517987536e-7 + (-0.12440642607426861943e-8 + (0.14602787128447932137e-10 - 0.10885859114666666667e-12 * t) * t) * t) * t) * t) * t;
+    }
+    case 96: {
+      double t = 2*y100 - 193;
+      return 0.40889797115352738582e-1 + (-0.60426484889413678200e-2 + (0.28953496450191694606e-4 + (-0.21982952021823718400e-7 + (-0.11044169117553026211e-8 + (0.13344562332430552171e-10 - 0.10091231402844444444e-12 * t) * t) * t) * t) * t) * t;
+    }
+  case 97: case 98:
+  case 99: case 100: { // use Taylor expansion for small x (|x| <= 0.0309...)
+      //  (2/sqrt(pi)) * (x - 2/3 x^3  + 4/15 x^5  - 8/105 x^7 + 16/945 x^9) 
+      double x2 = x*x;
+      return x * (1.1283791670955125739
+                  - x2 * (0.75225277806367504925
+                          - x2 * (0.30090111122547001970
+                                  - x2 * (0.085971746064420005629
+                                          - x2 * 0.016931216931216931217))));
+    }
+  }
+  /* Since 0 <= y100 < 101, this is only reached if x is NaN,
+     in which case we should return NaN. */
+  return NaN;
+}
+
+double FADDEEVA(w_im)(double x)
+{
+  if (x >= 0) {
+    if (x > 45) { // continued-fraction expansion is faster
+      const double ispi = 0.56418958354775628694807945156; // 1 / sqrt(pi)
+      if (x > 5e7) // 1-term expansion, important to avoid overflow
+        return ispi / x;
+      /* 5-term expansion (rely on compiler for CSE), simplified from:
+                ispi / (x-0.5/(x-1/(x-1.5/(x-2/x))))  */
+      return ispi*((x*x) * (x*x-4.5) + 2) / (x * ((x*x) * (x*x-5) + 3.75));
+    }
+    return w_im_y100(100/(1+x), x);
+  }
+  else { // = -FADDEEVA(w_im)(-x)
+    if (x < -45) { // continued-fraction expansion is faster
+      const double ispi = 0.56418958354775628694807945156; // 1 / sqrt(pi)
+      if (x < -5e7) // 1-term expansion, important to avoid overflow
+        return ispi / x;
+      /* 5-term expansion (rely on compiler for CSE), simplified from:
+                ispi / (x-0.5/(x-1/(x-1.5/(x-2/x))))  */
+      return ispi*((x*x) * (x*x-4.5) + 2) / (x * ((x*x) * (x*x-5) + 3.75));
+    }
+    return -w_im_y100(100/(1-x), -x);
+  }
+}
+
+/////////////////////////////////////////////////////////////////////////
+
+// Compile with -DTEST_FADDEEVA to compile a little test program
+#ifdef TEST_FADDEEVA
+
+#ifdef __cplusplus
+#  include <cstdio>
+#else
+#  include <stdio.h>
+#endif
+
+// compute relative error |b-a|/|a|, handling case of NaN and Inf,
+static double relerr(double a, double b) {
+  if (isnan(a) || isnan(b) || isinf(a) || isinf(b)) {
+    if ((isnan(a) && !isnan(b)) || (!isnan(a) && isnan(b)) ||
+        (isinf(a) && !isinf(b)) || (!isinf(a) && isinf(b)) ||
+        (isinf(a) && isinf(b) && a*b < 0))
+      return Inf; // "infinite" error
+    return 0; // matching infinity/nan results counted as zero error
+  }
+  if (a == 0)
+    return b == 0 ? 0 : Inf;
+  else
+    return fabs((b-a) / a);
+}
+
+int main(void) {
+  double errmax_all = 0;
+  {
+    printf("############# w(z) tests #############\n");
+#define NTST 57 // define instead of const for C compatibility
+    cmplx z[NTST] = {
+      C(624.2,-0.26123),
+      C(-0.4,3.),
+      C(0.6,2.),
+      C(-1.,1.),
+      C(-1.,-9.),
+      C(-1.,9.),
+      C(-0.0000000234545,1.1234),
+      C(-3.,5.1),
+      C(-53,30.1),
+      C(0.0,0.12345),
+      C(11,1),
+      C(-22,-2),
+      C(9,-28),
+      C(21,-33),
+      C(1e5,1e5),
+      C(1e14,1e14),
+      C(-3001,-1000),
+      C(1e160,-1e159),
+      C(-6.01,0.01),
+      C(-0.7,-0.7),
+      C(2.611780000000000e+01, 4.540909610972489e+03),
+      C(0.8e7,0.3e7),
+      C(-20,-19.8081),
+      C(1e-16,-1.1e-16),
+      C(2.3e-8,1.3e-8),
+      C(6.3,-1e-13),
+      C(6.3,1e-20),
+      C(1e-20,6.3),
+      C(1e-20,16.3),
+      C(9,1e-300),
+      C(6.01,0.11),
+      C(8.01,1.01e-10),
+      C(28.01,1e-300),
+      C(10.01,1e-200),
+      C(10.01,-1e-200),
+      C(10.01,0.99e-10),
+      C(10.01,-0.99e-10),
+      C(1e-20,7.01),
+      C(-1,7.01),
+      C(5.99,7.01),
+      C(1,0),
+      C(55,0),
+      C(-0.1,0),
+      C(1e-20,0),
+      C(0,5e-14),
+      C(0,51),
+      C(Inf,0),
+      C(-Inf,0),
+      C(0,Inf),
+      C(0,-Inf),
+      C(Inf,Inf),
+      C(Inf,-Inf),
+      C(NaN,NaN),
+      C(NaN,0),
+      C(0,NaN),
+      C(NaN,Inf),
+      C(Inf,NaN)
+    };
+    cmplx w[NTST] = { /* w(z), computed with WolframAlpha
+                                   ... note that WolframAlpha is problematic
+                                   some of the above inputs, so I had to
+                                   use the continued-fraction expansion
+                                   in WolframAlpha in some cases, or switch
+                                   to Maple */
+      C(-3.78270245518980507452677445620103199303131110e-7,
+        0.000903861276433172057331093754199933411710053155),
+      C(0.1764906227004816847297495349730234591778719532788,
+        -0.02146550539468457616788719893991501311573031095617),
+      C(0.2410250715772692146133539023007113781272362309451,
+        0.06087579663428089745895459735240964093522265589350),
+      C(0.30474420525691259245713884106959496013413834051768,
+        -0.20821893820283162728743734725471561394145872072738),
+      C(7.317131068972378096865595229600561710140617977e34,
+        8.321873499714402777186848353320412813066170427e34),
+      C(0.0615698507236323685519612934241429530190806818395,
+        -0.00676005783716575013073036218018565206070072304635),
+      C(0.3960793007699874918961319170187598400134746631,
+        -5.593152259116644920546186222529802777409274656e-9),
+      C(0.08217199226739447943295069917990417630675021771804,
+        -0.04701291087643609891018366143118110965272615832184),
+      C(0.00457246000350281640952328010227885008541748668738,
+        -0.00804900791411691821818731763401840373998654987934),
+      C(0.8746342859608052666092782112565360755791467973338452,
+        0.),
+      C(0.00468190164965444174367477874864366058339647648741,
+        0.0510735563901306197993676329845149741675029197050),
+      C(-0.0023193175200187620902125853834909543869428763219,
+        -0.025460054739731556004902057663500272721780776336),
+      C(9.11463368405637174660562096516414499772662584e304,
+        3.97101807145263333769664875189354358563218932e305),
+      C(-4.4927207857715598976165541011143706155432296e281,
+        -2.8019591213423077494444700357168707775769028e281),
+      C(2.820947917809305132678577516325951485807107151e-6,
+        2.820947917668257736791638444590253942253354058e-6),
+      C(2.82094791773878143474039725787438662716372268e-15,
+        2.82094791773878143474039725773333923127678361e-15),
+      C(-0.0000563851289696244350147899376081488003110150498,
+        -0.000169211755126812174631861529808288295454992688),
+      C(-5.586035480670854326218608431294778077663867e-162,
+        5.586035480670854326218608431294778077663867e-161),
+      C(0.00016318325137140451888255634399123461580248456,
+        -0.095232456573009287370728788146686162555021209999),
+      C(0.69504753678406939989115375989939096800793577783885,
+        -1.8916411171103639136680830887017670616339912024317),
+      C(0.0001242418269653279656612334210746733213167234822,
+        7.145975826320186888508563111992099992116786763e-7),
+      C(2.318587329648353318615800865959225429377529825e-8,
+        6.182899545728857485721417893323317843200933380e-8),
+      C(-0.0133426877243506022053521927604277115767311800303,
+        -0.0148087097143220769493341484176979826888871576145),
+      C(1.00000000000000012412170838050638522857747934,
+        1.12837916709551279389615890312156495593616433e-16),
+      C(0.9999999853310704677583504063775310832036830015,
+        2.595272024519678881897196435157270184030360773e-8),
+      C(-1.4731421795638279504242963027196663601154624e-15,
+        0.090727659684127365236479098488823462473074709),
+      C(5.79246077884410284575834156425396800754409308e-18,
+        0.0907276596841273652364790985059772809093822374),
+      C(0.0884658993528521953466533278764830881245144368,
+        1.37088352495749125283269718778582613192166760e-22),
+      C(0.0345480845419190424370085249304184266813447878,
+        2.11161102895179044968099038990446187626075258e-23),
+      C(6.63967719958073440070225527042829242391918213e-36,
+        0.0630820900592582863713653132559743161572639353),
+      C(0.00179435233208702644891092397579091030658500743634,
+        0.0951983814805270647939647438459699953990788064762),
+      C(9.09760377102097999924241322094863528771095448e-13,
+        0.0709979210725138550986782242355007611074966717),
+      C(7.2049510279742166460047102593255688682910274423e-304,
+        0.0201552956479526953866611812593266285000876784321),
+      C(3.04543604652250734193622967873276113872279682e-44,
+        0.0566481651760675042930042117726713294607499165),
+      C(3.04543604652250734193622967873276113872279682e-44,
+        0.0566481651760675042930042117726713294607499165),
+      C(0.5659928732065273429286988428080855057102069081e-12,
+        0.056648165176067504292998527162143030538756683302),
+      C(-0.56599287320652734292869884280802459698927645e-12,
+        0.0566481651760675042929985271621430305387566833029),
+      C(0.0796884251721652215687859778119964009569455462,
+        1.11474461817561675017794941973556302717225126e-22),
+      C(0.07817195821247357458545539935996687005781943386550,
+        -0.01093913670103576690766705513142246633056714279654),
+      C(0.04670032980990449912809326141164730850466208439937,
+        0.03944038961933534137558064191650437353429669886545),
+      C(0.36787944117144232159552377016146086744581113103176,
+        0.60715770584139372911503823580074492116122092866515),
+      C(0,
+        0.010259688805536830986089913987516716056946786526145),
+      C(0.99004983374916805357390597718003655777207908125383,
+        -0.11208866436449538036721343053869621153527769495574),
+      C(0.99999999999999999999999999999999999999990000,
+        1.12837916709551257389615890312154517168802603e-20),
+      C(0.999999999999943581041645226871305192054749891144158,
+        0),
+      C(0.0110604154853277201542582159216317923453996211744250,
+        0),
+      C(0,0),
+      C(0,0),
+      C(0,0),
+      C(Inf,0),
+      C(0,0),
+      C(NaN,NaN),
+      C(NaN,NaN),
+      C(NaN,NaN),
+      C(NaN,0),
+      C(NaN,NaN),
+      C(NaN,NaN)
+    };
+    double errmax = 0;
+    for (int i = 0; i < NTST; ++i) {
+      cmplx fw = FADDEEVA(w)(z[i],0.);
+      double re_err = relerr(creal(w[i]), creal(fw));
+      double im_err = relerr(cimag(w[i]), cimag(fw));
+      printf("w(%g%+gi) = %g%+gi (vs. %g%+gi), re/im rel. err. = %0.2g/%0.2g)\n",
+             creal(z[i]),cimag(z[i]), creal(fw),cimag(fw), creal(w[i]),cimag(w[i]),
+             re_err, im_err);
+      if (re_err > errmax) errmax = re_err;
+      if (im_err > errmax) errmax = im_err;
+    }
+    if (errmax > 1e-13) {
+      printf("FAILURE -- relative error %g too large!\n", errmax);
+      return 1;
+    }
+    printf("SUCCESS (max relative error = %g)\n", errmax);
+    if (errmax > errmax_all) errmax_all = errmax;
+  }
+  {
+#undef NTST
+#define NTST 41 // define instead of const for C compatibility
+    cmplx z[NTST] = {
+      C(1,2),
+      C(-1,2),
+      C(1,-2),
+      C(-1,-2),
+      C(9,-28),
+      C(21,-33),
+      C(1e3,1e3),
+      C(-3001,-1000),
+      C(1e160,-1e159),
+      C(5.1e-3, 1e-8),
+      C(-4.9e-3, 4.95e-3),
+      C(4.9e-3, 0.5),
+      C(4.9e-4, -0.5e1),
+      C(-4.9e-5, -0.5e2),
+      C(5.1e-3, 0.5),
+      C(5.1e-4, -0.5e1),
+      C(-5.1e-5, -0.5e2),
+      C(1e-6,2e-6),
+      C(0,2e-6),
+      C(0,2),
+      C(0,20),
+      C(0,200),
+      C(Inf,0),
+      C(-Inf,0),
+      C(0,Inf),
+      C(0,-Inf),
+      C(Inf,Inf),
+      C(Inf,-Inf),
+      C(NaN,NaN),
+      C(NaN,0),
+      C(0,NaN),
+      C(NaN,Inf),
+      C(Inf,NaN),
+      C(1e-3,NaN),
+      C(7e-2,7e-2),
+      C(7e-2,-7e-4),
+      C(-9e-2,7e-4),
+      C(-9e-2,9e-2),
+      C(-7e-4,9e-2),
+      C(7e-2,0.9e-2),
+      C(7e-2,1.1e-2)
+    };
+    cmplx w[NTST] = { // erf(z[i]), evaluated with Maple
+      C(-0.5366435657785650339917955593141927494421,
+        -5.049143703447034669543036958614140565553),
+      C(0.5366435657785650339917955593141927494421,
+        -5.049143703447034669543036958614140565553),
+      C(-0.5366435657785650339917955593141927494421,
+        5.049143703447034669543036958614140565553),
+      C(0.5366435657785650339917955593141927494421,
+        5.049143703447034669543036958614140565553),
+      C(0.3359473673830576996788000505817956637777e304,
+        -0.1999896139679880888755589794455069208455e304),
+      C(0.3584459971462946066523939204836760283645e278,
+        0.3818954885257184373734213077678011282505e280),
+      C(0.9996020422657148639102150147542224526887,
+        0.00002801044116908227889681753993542916894856),
+      C(-1, 0),
+      C(1, 0),
+      C(0.005754683859034800134412990541076554934877,
+        0.1128349818335058741511924929801267822634e-7),
+      C(-0.005529149142341821193633460286828381876955,
+        0.005585388387864706679609092447916333443570),
+      C(0.007099365669981359632319829148438283865814,
+        0.6149347012854211635026981277569074001219),
+      C(0.3981176338702323417718189922039863062440e8,
+        -0.8298176341665249121085423917575122140650e10),
+      C(-Inf,
+        -Inf),
+      C(0.007389128308257135427153919483147229573895,
+        0.6149332524601658796226417164791221815139),
+      C(0.4143671923267934479245651547534414976991e8,
+        -0.8298168216818314211557046346850921446950e10),
+      C(-Inf,
+        -Inf),
+      C(0.1128379167099649964175513742247082845155e-5,
+        0.2256758334191777400570377193451519478895e-5),
+      C(0,
+        0.2256758334194034158904576117253481476197e-5),
+      C(0,
+        18.56480241457555259870429191324101719886),
+      C(0,
+        0.1474797539628786202447733153131835124599e173),
+      C(0,
+        Inf),
+      C(1,0),
+      C(-1,0),
+      C(0,Inf),
+      C(0,-Inf),
+      C(NaN,NaN),
+      C(NaN,NaN),
+      C(NaN,NaN),
+      C(NaN,0),
+      C(0,NaN),
+      C(NaN,NaN),
+      C(NaN,NaN),
+      C(NaN,NaN),
+      C(0.07924380404615782687930591956705225541145,
+        0.07872776218046681145537914954027729115247),
+      C(0.07885775828512276968931773651224684454495,
+        -0.0007860046704118224342390725280161272277506),
+      C(-0.1012806432747198859687963080684978759881,
+        0.0007834934747022035607566216654982820299469),
+      C(-0.1020998418798097910247132140051062512527,
+        0.1010030778892310851309082083238896270340),
+      C(-0.0007962891763147907785684591823889484764272,
+        0.1018289385936278171741809237435404896152),
+      C(0.07886408666470478681566329888615410479530,
+        0.01010604288780868961492224347707949372245),
+      C(0.07886723099940260286824654364807981336591,
+        0.01235199327873258197931147306290916629654)
+    };
+#define TST(f,isc)                                                      \
+    printf("############# " #f "(z) tests #############\n");            \
+    double errmax = 0;                                                  \
+    for (int i = 0; i < NTST; ++i) {                                    \
+      cmplx fw = FADDEEVA(f)(z[i],0.);                  \
+      double re_err = relerr(creal(w[i]), creal(fw));                   \
+      double im_err = relerr(cimag(w[i]), cimag(fw));                   \
+      printf(#f "(%g%+gi) = %g%+gi (vs. %g%+gi), re/im rel. err. = %0.2g/%0.2g)\n", \
+             creal(z[i]),cimag(z[i]), creal(fw),cimag(fw), creal(w[i]),cimag(w[i]), \
+             re_err, im_err);                                           \
+      if (re_err > errmax) errmax = re_err;                             \
+      if (im_err > errmax) errmax = im_err;                             \
+    }                                                                   \
+    if (errmax > 1e-13) {                                               \
+      printf("FAILURE -- relative error %g too large!\n", errmax);      \
+      return 1;                                                         \
+    }                                                                   \
+    printf("Checking " #f "(x) special case...\n");                     \
+    for (int i = 0; i < 10000; ++i) {                                   \
+      double x = pow(10., -300. + i * 600. / (10000 - 1));              \
+      double re_err = relerr(FADDEEVA_RE(f)(x),                         \
+                             creal(FADDEEVA(f)(C(x,x*isc),0.)));        \
+      if (re_err > errmax) errmax = re_err;                             \
+      re_err = relerr(FADDEEVA_RE(f)(-x),                               \
+                      creal(FADDEEVA(f)(C(-x,x*isc),0.)));              \
+      if (re_err > errmax) errmax = re_err;                             \
+    }                                                                   \
+    {                                                                   \
+      double re_err = relerr(FADDEEVA_RE(f)(Inf),                       \
+                             creal(FADDEEVA(f)(C(Inf,0.),0.))); \
+      if (re_err > errmax) errmax = re_err;                             \
+      re_err = relerr(FADDEEVA_RE(f)(-Inf),                             \
+                      creal(FADDEEVA(f)(C(-Inf,0.),0.)));               \
+      if (re_err > errmax) errmax = re_err;                             \
+      re_err = relerr(FADDEEVA_RE(f)(NaN),                              \
+                      creal(FADDEEVA(f)(C(NaN,0.),0.)));                \
+      if (re_err > errmax) errmax = re_err;                             \
+    }                                                                   \
+    if (errmax > 1e-13) {                                               \
+      printf("FAILURE -- relative error %g too large!\n", errmax);      \
+      return 1;                                                         \
+    }                                                                   \
+    printf("SUCCESS (max relative error = %g)\n", errmax);              \
+    if (errmax > errmax_all) errmax_all = errmax
+
+    TST(erf, 1e-20);
+  }
+  {
+    // since erfi just calls through to erf, just one test should
+    // be sufficient to make sure I didn't screw up the signs or something
+#undef NTST
+#define NTST 1 // define instead of const for C compatibility
+    cmplx z[NTST] = { C(1.234,0.5678) };
+    cmplx w[NTST] = { // erfi(z[i]), computed with Maple
+      C(1.081032284405373149432716643834106923212,
+        1.926775520840916645838949402886591180834)
+    };
+    TST(erfi, 0);
+  }
+  {
+    // since erfcx just calls through to w, just one test should
+    // be sufficient to make sure I didn't screw up the signs or something
+#undef NTST
+#define NTST 1 // define instead of const for C compatibility
+    cmplx z[NTST] = { C(1.234,0.5678) };
+    cmplx w[NTST] = { // erfcx(z[i]), computed with Maple
+      C(0.3382187479799972294747793561190487832579,
+        -0.1116077470811648467464927471872945833154)
+    };
+    TST(erfcx, 0);
+  }
+  {
+#undef NTST
+#define NTST 30 // define instead of const for C compatibility
+    cmplx z[NTST] = {
+      C(1,2),
+      C(-1,2),
+      C(1,-2),
+      C(-1,-2),
+      C(9,-28),
+      C(21,-33),
+      C(1e3,1e3),
+      C(-3001,-1000),
+      C(1e160,-1e159),
+      C(5.1e-3, 1e-8),
+      C(0,2e-6),
+      C(0,2),
+      C(0,20),
+      C(0,200),
+      C(2e-6,0),
+      C(2,0),
+      C(20,0),
+      C(200,0),
+      C(Inf,0),
+      C(-Inf,0),
+      C(0,Inf),
+      C(0,-Inf),
+      C(Inf,Inf),
+      C(Inf,-Inf),
+      C(NaN,NaN),
+      C(NaN,0),
+      C(0,NaN),
+      C(NaN,Inf),
+      C(Inf,NaN),
+      C(88,0)
+    };
+    cmplx w[NTST] = { // erfc(z[i]), evaluated with Maple
+      C(1.536643565778565033991795559314192749442,
+        5.049143703447034669543036958614140565553),
+      C(0.4633564342214349660082044406858072505579,
+        5.049143703447034669543036958614140565553),
+      C(1.536643565778565033991795559314192749442,
+        -5.049143703447034669543036958614140565553),
+      C(0.4633564342214349660082044406858072505579,
+        -5.049143703447034669543036958614140565553),
+      C(-0.3359473673830576996788000505817956637777e304,
+        0.1999896139679880888755589794455069208455e304),
+      C(-0.3584459971462946066523939204836760283645e278,
+        -0.3818954885257184373734213077678011282505e280),
+      C(0.0003979577342851360897849852457775473112748,
+        -0.00002801044116908227889681753993542916894856),
+      C(2, 0),
+      C(0, 0),
+      C(0.9942453161409651998655870094589234450651,
+        -0.1128349818335058741511924929801267822634e-7),
+      C(1,
+        -0.2256758334194034158904576117253481476197e-5),
+      C(1,
+        -18.56480241457555259870429191324101719886),
+      C(1,
+        -0.1474797539628786202447733153131835124599e173),
+      C(1, -Inf),
+      C(0.9999977432416658119838633199332831406314,
+        0),
+      C(0.004677734981047265837930743632747071389108,
+        0),
+      C(0.5395865611607900928934999167905345604088e-175,
+        0),
+      C(0, 0),
+      C(0, 0),
+      C(2, 0),
+      C(1, -Inf),
+      C(1, Inf),
+      C(NaN, NaN),
+      C(NaN, NaN),
+      C(NaN, NaN),
+      C(NaN, 0),
+      C(1, NaN),
+      C(NaN, NaN),
+      C(NaN, NaN),
+      C(0,0)
+    };
+    TST(erfc, 1e-20);
+  }
+  {
+#undef NTST
+#define NTST 48 // define instead of const for C compatibility
+    cmplx z[NTST] = {
+      C(2,1),
+      C(-2,1),
+      C(2,-1),
+      C(-2,-1),
+      C(-28,9),
+      C(33,-21),
+      C(1e3,1e3),
+      C(-1000,-3001),
+      C(1e-8, 5.1e-3),
+      C(4.95e-3, -4.9e-3),
+      C(5.1e-3, 5.1e-3),
+      C(0.5, 4.9e-3),
+      C(-0.5e1, 4.9e-4),
+      C(-0.5e2, -4.9e-5),
+      C(0.5e3, 4.9e-6),
+      C(0.5, 5.1e-3),
+      C(-0.5e1, 5.1e-4),
+      C(-0.5e2, -5.1e-5),
+      C(1e-6,2e-6),
+      C(2e-6,0),
+      C(2,0),
+      C(20,0),
+      C(200,0),
+      C(0,4.9e-3),
+      C(0,-5.1e-3),
+      C(0,2e-6),
+      C(0,-2),
+      C(0,20),
+      C(0,-200),
+      C(Inf,0),
+      C(-Inf,0),
+      C(0,Inf),
+      C(0,-Inf),
+      C(Inf,Inf),
+      C(Inf,-Inf),
+      C(NaN,NaN),
+      C(NaN,0),
+      C(0,NaN),
+      C(NaN,Inf),
+      C(Inf,NaN),
+      C(39, 6.4e-5),
+      C(41, 6.09e-5),
+      C(4.9e7, 5e-11),
+      C(5.1e7, 4.8e-11),
+      C(1e9, 2.4e-12),
+      C(1e11, 2.4e-14),
+      C(1e13, 2.4e-16),
+      C(1e300, 2.4e-303)
+    };
+    cmplx w[NTST] = { // dawson(z[i]), evaluated with Maple
+      C(0.1635394094345355614904345232875688576839,
+        -0.1531245755371229803585918112683241066853),
+      C(-0.1635394094345355614904345232875688576839,
+        -0.1531245755371229803585918112683241066853),
+      C(0.1635394094345355614904345232875688576839,
+        0.1531245755371229803585918112683241066853),
+      C(-0.1635394094345355614904345232875688576839,
+        0.1531245755371229803585918112683241066853),
+      C(-0.01619082256681596362895875232699626384420,
+        -0.005210224203359059109181555401330902819419),
+      C(0.01078377080978103125464543240346760257008,
+        0.006866888783433775382193630944275682670599),
+      C(-0.5808616819196736225612296471081337245459,
+        0.6688593905505562263387760667171706325749),
+      C(Inf,
+        -Inf),
+      C(0.1000052020902036118082966385855563526705e-7,
+        0.005100088434920073153418834680320146441685),
+      C(0.004950156837581592745389973960217444687524,
+        -0.004899838305155226382584756154100963570500),
+      C(0.005100176864319675957314822982399286703798,
+        0.005099823128319785355949825238269336481254),
+      C(0.4244534840871830045021143490355372016428,
+        0.002820278933186814021399602648373095266538),
+      C(-0.1021340733271046543881236523269967674156,
+        -0.00001045696456072005761498961861088944159916),
+      C(-0.01000200120119206748855061636187197886859,
+        0.9805885888237419500266621041508714123763e-8),
+      C(0.001000002000012000023960527532953151819595,
+        -0.9800058800588007290937355024646722133204e-11),
+      C(0.4244549085628511778373438768121222815752,
+        0.002935393851311701428647152230552122898291),
+      C(-0.1021340732357117208743299813648493928105,
+        -0.00001088377943049851799938998805451564893540),
+      C(-0.01000200120119126652710792390331206563616,
+        0.1020612612857282306892368985525393707486e-7),
+      C(0.1000000000007333333333344266666666664457e-5,
+        0.2000000000001333333333323199999999978819e-5),
+      C(0.1999999999994666666666675199999999990248e-5,
+        0),
+      C(0.3013403889237919660346644392864226952119,
+        0),
+      C(0.02503136792640367194699495234782353186858,
+        0),
+      C(0.002500031251171948248596912483183760683918,
+        0),
+      C(0,0.004900078433419939164774792850907128053308),
+      C(0,-0.005100088434920074173454208832365950009419),
+      C(0,0.2000000000005333333333341866666666676419e-5),
+      C(0,-48.16001211429122974789822893525016528191),
+      C(0,0.4627407029504443513654142715903005954668e174),
+      C(0,-Inf),
+      C(0,0),
+      C(-0,0),
+      C(0, Inf),
+      C(0, -Inf),
+      C(NaN, NaN),
+      C(NaN, NaN),
+      C(NaN, NaN),
+      C(NaN, 0),
+      C(0, NaN),
+      C(NaN, NaN),
+      C(NaN, NaN),
+      C(0.01282473148489433743567240624939698290584,
+        -0.2105957276516618621447832572909153498104e-7),
+      C(0.01219875253423634378984109995893708152885,
+        -0.1813040560401824664088425926165834355953e-7),
+      C(0.1020408163265306334945473399689037886997e-7,
+        -0.1041232819658476285651490827866174985330e-25),
+      C(0.9803921568627452865036825956835185367356e-8,
+        -0.9227220299884665067601095648451913375754e-26),
+      C(0.5000000000000000002500000000000000003750e-9,
+        -0.1200000000000000001800000188712838420241e-29),
+      C(5.00000000000000000000025000000000000000000003e-12,
+        -1.20000000000000000000018000000000000000000004e-36),
+      C(5.00000000000000000000000002500000000000000000e-14,
+        -1.20000000000000000000000001800000000000000000e-42),
+      C(5e-301, 0)
+    };
+    TST(Dawson, 1e-20);
+  }
+  printf("#####################################\n");
+  printf("SUCCESS (max relative error = %g)\n", errmax_all);
+}
+
+#endif
diff --git a/liboctave/cruft/Faddeeva/Faddeeva.hh b/liboctave/cruft/Faddeeva/Faddeeva.hh
new file mode 100644
--- /dev/null
+++ b/liboctave/cruft/Faddeeva/Faddeeva.hh
@@ -0,0 +1,62 @@
+/* Copyright (c) 2012 Massachusetts Institute of Technology
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
+ * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
+ * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
+ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
+ */
+
+/* Available at: http://ab-initio.mit.edu/Faddeeva
+
+   Header file for Faddeeva.cc; see that file for more information. */
+
+#ifndef FADDEEVA_HH
+#define FADDEEVA_HH 1
+
+#include <complex>
+
+namespace Faddeeva {
+
+// compute w(z) = exp(-z^2) erfc(-iz) [ Faddeeva / scaled complex error func ]
+extern std::complex<double> w(std::complex<double> z,double relerr=0);
+extern double w_im(double x); // special-case code for Im[w(x)] of real x
+
+// Various functions that we can compute with the help of w(z)
+
+// compute erfcx(z) = exp(z^2) erfc(z)
+extern std::complex<double> erfcx(std::complex<double> z, double relerr=0);
+extern double erfcx(double x); // special case for real x
+
+// compute erf(z), the error function of complex arguments
+extern std::complex<double> erf(std::complex<double> z, double relerr=0);
+extern double erf(double x); // special case for real x
+
+// compute erfi(z) = -i erf(iz), the imaginary error function
+extern std::complex<double> erfi(std::complex<double> z, double relerr=0);
+extern double erfi(double x); // special case for real x
+
+// compute erfc(z) = 1 - erf(z), the complementary error function
+extern std::complex<double> erfc(std::complex<double> z, double relerr=0);
+extern double erfc(double x); // special case for real x
+
+// compute Dawson(z) = sqrt(pi)/2  *  exp(-z^2) * erfi(z)
+extern std::complex<double> Dawson(std::complex<double> z, double relerr=0);
+extern double Dawson(double x); // special case for real x
+
+} // namespace Faddeeva
+
+#endif // FADDEEVA_HH
diff --git a/liboctave/cruft/Faddeeva/module.mk b/liboctave/cruft/Faddeeva/module.mk
new file mode 100644
--- /dev/null
+++ b/liboctave/cruft/Faddeeva/module.mk
@@ -0,0 +1,3 @@
+EXTRA_DIST += Faddeeva/module.mk
+
+libcruft_la_SOURCES += Faddeeva/Faddeeva.cc Faddeeva/Faddeeva.hh
diff --git a/liboctave/cruft/Makefile.am b/liboctave/cruft/Makefile.am
--- a/liboctave/cruft/Makefile.am
+++ b/liboctave/cruft/Makefile.am
@@ -42,16 +42,17 @@ libcruft_la_DEPENDENCIES = cruft.def
 
 octinclude_HEADERS =
 
 include amos/module.mk
 include blas-xtra/module.mk
 include daspk/module.mk
 include dasrt/module.mk
 include dassl/module.mk
+include Faddeeva/module.mk
 include fftpack/module.mk
 include lapack-xtra/module.mk
 include misc/module.mk
 include odepack/module.mk
 include ordered-qz/module.mk
 include quadpack/module.mk
 include ranlib/module.mk
 include slatec-err/module.mk
diff --git a/liboctave/numeric/lo-specfun.cc b/liboctave/numeric/lo-specfun.cc
--- a/liboctave/numeric/lo-specfun.cc
+++ b/liboctave/numeric/lo-specfun.cc
@@ -45,16 +45,18 @@ along with Octave; see the file COPYING.
 #include "lo-specfun.h"
 #include "mx-inlines.cc"
 #include "lo-mappers.h"
 
 #ifndef M_PI
 #define M_PI 3.14159265358979323846
 #endif
 
+#include "Faddeeva.hh"
+
 extern "C"
 {
   F77_RET_T
   F77_FUNC (zbesj, ZBESJ) (const double&, const double&, const double&,
                            const octave_idx_type&, const octave_idx_type&,
                            double*, double*, octave_idx_type&,
                            octave_idx_type&);
 
@@ -282,16 +284,92 @@ float
 erfcf (float x)
 {
   float retval;
   F77_XFCN (xerfc, XERFC, (x, retval));
   return retval;
 }
 #endif
 
+// Complex error function from the Faddeeva package
+Complex
+erf (const Complex& x)
+{
+  return Faddeeva::erf (x);
+}
+FloatComplex
+erf (const FloatComplex& x)
+{
+  Complex xd (real (x), imag (x));
+  Complex ret = Faddeeva::erf (xd, std::numeric_limits<float>::epsilon ());
+  return FloatComplex (real (ret), imag (ret));
+}
+
+// Complex complementary error function from the Faddeeva package
+Complex
+erfc (const Complex& x)
+{
+  return Faddeeva::erfc (x);
+}
+FloatComplex
+erfc (const FloatComplex& x)
+{
+  Complex xd (real (x), imag (x));
+  Complex ret = Faddeeva::erfc (xd, std::numeric_limits<float>::epsilon ());
+  return FloatComplex (real (ret), imag (ret));
+}
+
+// Real and complex scaled complementary error function from Faddeeva package
+float erfcx (float x) { return Faddeeva::erfcx(x); }
+double erfcx (double x) { return Faddeeva::erfcx(x); }
+Complex
+erfcx (const Complex& x)
+{
+  return Faddeeva::erfcx (x);
+}
+FloatComplex
+erfcx (const FloatComplex& x)
+{
+  Complex xd (real (x), imag (x));
+  Complex ret = Faddeeva::erfcx (xd, std::numeric_limits<float>::epsilon ());
+  return FloatComplex (real (ret), imag (ret));
+}
+
+// Real and complex imaginary error function from Faddeeva package
+float erfi (float x) { return Faddeeva::erfi(x); }
+double erfi (double x) { return Faddeeva::erfi(x); }
+Complex
+erfi (const Complex& x)
+{
+  return Faddeeva::erfi (x);
+}
+FloatComplex
+erfi (const FloatComplex& x)
+{
+  Complex xd (real (x), imag (x));
+  Complex ret = Faddeeva::erfi (xd, std::numeric_limits<float>::epsilon ());
+  return FloatComplex (real (ret), imag (ret));
+}
+
+// Real and complex Dawson function (= scaled erfi) from Faddeeva package
+float dawson (float x) { return Faddeeva::Dawson(x); }
+double dawson (double x) { return Faddeeva::Dawson(x); }
+Complex
+dawson (const Complex& x)
+{
+  return Faddeeva::Dawson (x);
+}
+FloatComplex
+dawson (const FloatComplex& x)
+{
+  Complex xd (real (x), imag (x));
+  Complex ret = Faddeeva::Dawson (xd, std::numeric_limits<float>::epsilon ());
+  return FloatComplex (real (ret), imag (ret));
+}
+
 double
 xgamma (double x)
 {
   double result;
 
   if (xisnan (x))
     result = x;
   else if ((x <= 0 && D_NINT (x) == x) || xisinf (x))
@@ -3024,116 +3102,16 @@ double erfcinv (double x)
   return do_erfcinv (x, true);
 }
 
 float erfcinv (float x)
 {
   return do_erfcinv (x, false);
 }
 
-// Implementation based on the Fortran code by W.J.Cody
-// see http://www.netlib.org/specfun/erf.
-// Templatized and simplified workflow.
-
-// FIXME: Maybe this should be globally visible.
-static inline float erfc (float x) { return erfcf (x); }
-
-template <class T>
-static T
-erfcx_impl (T x)
-{
-  static const T c[] =
-    {
-      5.64188496988670089e-1,8.88314979438837594,
-      6.61191906371416295e+1,2.98635138197400131e+2,
-      8.81952221241769090e+2,1.71204761263407058e+3,
-      2.05107837782607147e+3,1.23033935479799725e+3,
-      2.15311535474403846e-8
-    };
-
-  static const T d[] =
-    {
-      1.57449261107098347e+1,1.17693950891312499e+2,
-      5.37181101862009858e+2,1.62138957456669019e+3,
-      3.29079923573345963e+3,4.36261909014324716e+3,
-      3.43936767414372164e+3,1.23033935480374942e+3
-    };
-
-  static const T p[] =
-    {
-      3.05326634961232344e-1,3.60344899949804439e-1,
-      1.25781726111229246e-1,1.60837851487422766e-2,
-      6.58749161529837803e-4,1.63153871373020978e-2
-    };
-
-  static const T q[] =
-    {
-      2.56852019228982242,1.87295284992346047,
-      5.27905102951428412e-1,6.05183413124413191e-2,
-      2.33520497626869185e-3
-    };
-
-  static const T sqrpi = 5.6418958354775628695e-1;
-  static const T xhuge = sqrt (1.0 / std::numeric_limits<T>::epsilon ());
-  static const T xneg = -sqrt (log (std::numeric_limits<T>::max ()/2.0));
-
-  double y = fabs (x), result;
-  if (x < xneg)
-    result = octave_Inf;
-  else if (y <= 0.46875)
-    result = std::exp (x*x) * erfc (x);
-  else
-    {
-      if (y <= 4.0)
-        {
-          double xnum = c[8]*y, xden = y;
-          for (int i = 0; i < 7; i++)
-            {
-              xnum = (xnum + c[i]) * y;
-              xden = (xden + d[i]) * y;
-            }
-
-          result = (xnum + c[7]) / (xden + d[7]);
-        }
-      else if (y <= xhuge)
-        {
-          double y2 = 1/(y*y), xnum = p[5]*y2, xden = y2;
-          for (int i = 0; i < 4; i++)
-            {
-              xnum = (xnum + p[i]) * y2;
-              xden = (xden + q[i]) * y2;
-            }
-
-          result = y2 * (xnum + p[4]) / (xden + q[4]);
-          result = (sqrpi - result) / y;
-        }
-      else
-        result = sqrpi / y;
-
-      // Fix up negative argument.
-      if (x < 0)
-        {
-          double y2 = ceil (x / 16.0) * 16.0, del = (x-y2)*(x+y2);
-          result = 2*(std::exp (y2*y2) * std::exp (del)) - result;
-        }
-    }
-
-  return result;
-}
-
-double erfcx (double x)
-{
-  return erfcx_impl (x);
-}
-
-float erfcx (float x)
-{
-  return erfcx_impl (x);
-}
-
 //
 //  Incomplete Beta function ratio
 //
 //  Algorithm based on the one by John Burkardt.
 //  See http://people.sc.fsu.edu/~jburkardt/cpp_src/asa109/asa109.html
 //
 //  The original code is distributed under the GNU LGPL v3 license.
 //
diff --git a/liboctave/numeric/lo-specfun.h b/liboctave/numeric/lo-specfun.h
--- a/liboctave/numeric/lo-specfun.h
+++ b/liboctave/numeric/lo-specfun.h
@@ -51,20 +51,24 @@ extern OCTAVE_API double asinh (double);
 
 #if !defined (HAVE_ATANH)
 extern OCTAVE_API double atanh (double);
 #endif
 
 #if !defined (HAVE_ERF)
 extern OCTAVE_API double erf (double);
 #endif
+extern OCTAVE_API Complex erf (const Complex& x);
+extern OCTAVE_API FloatComplex erf (const FloatComplex& x);
 
 #if !defined (HAVE_ERFC)
 extern OCTAVE_API double erfc (double);
 #endif
+extern OCTAVE_API Complex erfc (const Complex& x);
+extern OCTAVE_API FloatComplex erfc (const FloatComplex& x);
 
 #if !defined (HAVE_ACOSHF)
 extern OCTAVE_API float acoshf (float);
 #endif
 
 #if !defined (HAVE_ASINHF)
 extern OCTAVE_API float asinhf (float);
 #endif
@@ -573,18 +577,30 @@ extern OCTAVE_API Complex rc_log1p (doub
 extern OCTAVE_API FloatComplex rc_log1p (float);
 
 extern OCTAVE_API double erfinv (double x);
 extern OCTAVE_API float erfinv (float x);
 
 extern OCTAVE_API double erfcinv (double x);
 extern OCTAVE_API float erfcinv (float x);
 
+extern OCTAVE_API float erfcx (float x);
 extern OCTAVE_API double erfcx (double x);
-extern OCTAVE_API float erfcx (float x);
+extern OCTAVE_API Complex erfcx (const Complex& x);
+extern OCTAVE_API FloatComplex erfcx (const FloatComplex& x);
+
+extern OCTAVE_API float erfi (float x);
+extern OCTAVE_API double erfi (double x);
+extern OCTAVE_API Complex erfi (const Complex& x);
+extern OCTAVE_API FloatComplex erfi (const FloatComplex& x);
+
+extern OCTAVE_API float dawson (float x);
+extern OCTAVE_API double dawson (double x);
+extern OCTAVE_API Complex dawson (const Complex& x);
+extern OCTAVE_API FloatComplex dawson (const FloatComplex& x);
 
 extern OCTAVE_API double betaincinv (double x, double a, double b);
 extern OCTAVE_API Array<double> betaincinv (double x, double a, const Array<double>& b);
 extern OCTAVE_API Array<double> betaincinv (double x, const Array<double>& a, double b);
 extern OCTAVE_API Array<double> betaincinv (double x, const Array<double>& a, const Array<double>& b);
 extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, double a, double b);
 extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, double a, double b);
 extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, double a, const Array<double>& b);
diff --git a/liboctave/numeric/module.mk b/liboctave/numeric/module.mk
--- a/liboctave/numeric/module.mk
+++ b/liboctave/numeric/module.mk
@@ -174,11 +174,12 @@ TEMPLATE_SRC += \
 	mv $@-t $@
 
 noinst_LTLIBRARIES += numeric/libnumeric.la
 
 numeric_libnumeric_la_SOURCES = $(NUMERIC_SRC)
 numeric_libnumeric_la_CPPFLAGS = \
   $(liboctave_la_CPPFLAGS) \
   $(ARPACK_CPPFLAGS) \
+  -I$(srcdir)/cruft/Faddeeva \
   $(FFTW_XCPPFLAGS) \
   $(SPARSE_XCPPFLAGS)
 
diff --git a/liboctave/numeric/oct-fftw.h b/liboctave/numeric/oct-fftw.h
--- a/liboctave/numeric/oct-fftw.h
+++ b/liboctave/numeric/oct-fftw.h
@@ -220,24 +220,24 @@ public:
       ? instance->do_create_plan (rank, dims, howmany, stride, dist, in, out)
       : dummy;
   }
 
   static FftwMethod method (void)
   {
     static FftwMethod dummy;
 
-    return instance_ok () ? instance->method () : dummy;
+    return instance_ok () ? instance->do_method () : dummy;
   }
 
   static FftwMethod method (FftwMethod _meth)
   {
     static FftwMethod dummy;
 
-    return instance_ok () ? instance->method (_meth) : dummy;
+    return instance_ok () ? instance->do_method (_meth) : dummy;
   }
 
 private:
 
   // No copying!
 
   octave_float_fftw_planner (const octave_float_fftw_planner&);
 
diff --git a/liboctave/util/oct-shlib.cc b/liboctave/util/oct-shlib.cc
--- a/liboctave/util/oct-shlib.cc
+++ b/liboctave/util/oct-shlib.cc
@@ -70,25 +70,25 @@ octave_shlib::shlib_rep::shlib_rep (cons
       ("Octave:warn-future-time-stamp",
        "timestamp on file %s is in the future", file.c_str ());
 }
 
 bool
 octave_shlib::shlib_rep::is_out_of_date (void) const
 {
   file_stat fs (file);
-  return fs.is_newer (tm_loaded);
+  return (fs && fs.is_newer (tm_loaded));
 }
 
 void
 octave_shlib::shlib_rep::fake_reload (void)
 {
   // We can't actually reload the library, but we'll pretend we did.
   file_stat fs (file);
-  if (fs.is_newer (tm_loaded))
+  if (fs && fs.is_newer (tm_loaded))
     {
       tm_loaded = fs.mtime ();
 
       (*current_liboctave_warning_handler)
         ("library %s not reloaded due to existing references", file.c_str ());
     }
 }
 
diff --git a/liboctave/util/regexp.cc b/liboctave/util/regexp.cc
--- a/liboctave/util/regexp.cc
+++ b/liboctave/util/regexp.cc
@@ -421,21 +421,17 @@ regexp::match (const std::string& buffer
   return retval;
 }
 
 bool
 regexp::is_match (const std::string& buffer)
 {
   regexp::match_data rx_lst = match (buffer);
 
-  regexp::match_data::const_iterator p = rx_lst.begin ();
-
-  std::string match_string = p->match_string ();
-
-  return ! match_string.empty ();
+  return rx_lst.size () > 0;
 }
 
 Array<bool>
 regexp::is_match (const string_vector& buffer)
 {
   octave_idx_type len = buffer.length ();
 
   Array<bool> retval (dim_vector (len, 1));
diff --git a/m4/acinclude.m4 b/m4/acinclude.m4
--- a/m4/acinclude.m4
+++ b/m4/acinclude.m4
@@ -148,17 +148,17 @@ dnl new (17 inputs).
 dnl FIXME: This test uses a version number.  It potentially could
 dnl        be re-written to actually call the function, but is it worth it?
 dnl
 AC_DEFUN([OCTAVE_CHECK_FUNC_FINDFIRST_MODERN], [
   AC_CACHE_CHECK([whether Qscintilla FindFirst uses 17 input arguments],
     [octave_cv_func_findfirst_modern],
     [AC_LANG_PUSH(C++)
     ac_octave_save_CPPFLAGS="$CPPFLAGS"
-    CPPFLAGS="-I$QT_INCDIR -I$QT_INCDIR/Qt $CPPFLAGS"
+    CPPFLAGS="$QT_CPPFLAGS $CPPFLAGS"
     AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
         #include <Qsci/qsciglobal.h>
         ]], [[
         #if QSCINTILLA_VERSION < 0x020600
         #error Old FindFirst function found.
         #endif
         ]])],
       octave_cv_func_findfirst_modern=yes,
@@ -226,17 +226,17 @@ dnl Check whether Qscintilla SetPlacehol
 dnl FIXME: This test uses a version number.  It potentially could
 dnl        be re-written to actually call the function, but is it worth it?
 dnl
 AC_DEFUN([OCTAVE_CHECK_FUNC_SETPLACEHOLDERTEXT], [
   AC_CACHE_CHECK([whether Qt has SetPlaceholderText function],
     [octave_cv_func_setplaceholdertext],
     [AC_LANG_PUSH(C++)
     ac_octave_save_CPPFLAGS="$CPPFLAGS"
-    CPPFLAGS="-I$QT_INCDIR $CPPFLAGS"
+    CPPFLAGS="$QT_CPPFLAGS $CPPFLAGS"
     AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
         #include <Qt/qglobal.h>
         ]], [[
         #if QT_VERSION < 0x040700
         #error No SetPlacholderText function available.
         #endif
         ]])],
       octave_cv_func_setplaceholdertext=yes,
@@ -1761,207 +1761,9 @@ AC_DEFUN([OCTAVE_UNORDERED_MAP_HEADERS],
       [Define to 1 if unordered_map requires the use of tr1 namespace.])
   fi
 ])
 
 dnl         End of macros written by Octave developers
 dnl ------------------------------------------------------------
 dnl
 
-dnl
-dnl    The following macros were taken from other sources. 
-dnl ------------------------------------------------------------
-
-dnl
-dnl Configure paths for FreeType2
-dnl Marcelo Magallon 2001-10-26, based on gtk.m4 by Owen Taylor
-dnl
-dnl Copyright 2001, 2003 by
-dnl David Turner, Robert Wilhelm, and Werner Lemberg.
-dnl
-dnl This file is part of the FreeType project, and may only be used, modified,
-dnl and distributed under the terms of the FreeType project license,
-dnl LICENSE.TXT.  By continuing to use, modify, or distribute this file you
-dnl indicate that you have read the license and understand and accept it
-dnl fully.
-dnl
-dnl As a special exception to the FreeType project license, this file may be
-dnl distributed as part of a program that contains a configuration script
-dnl generated by Autoconf, under the same distribution terms as the rest of
-dnl that program.
-dnl
-dnl serial 2
-dnl
-dnl AC_CHECK_FT2([MINIMUM-VERSION [, ACTION-IF-FOUND [, ACTION-IF-NOT-FOUND]]])
-dnl Test for FreeType 2, and define FT2_CFLAGS and FT2_LIBS.
-dnl MINIMUM-VERSION is what libtool reports; the default is `7.0.1' (this is
-dnl FreeType 2.0.4).
-dnl
-AC_DEFUN([AC_CHECK_FT2], [
-  dnl
-  dnl Get the cflags and libraries from the freetype-config script
-  dnl
-  AC_ARG_WITH([ft-prefix],
-    [AS_HELP_STRING([--with-ft-prefix=PREFIX],
-                   [Prefix where FreeType is installed (optional)])],
-    [ft_config_prefix="$withval"],
-    [ft_config_prefix=""])
- 
-  AC_ARG_WITH([ft-exec-prefix],
-    [AS_HELP_STRING([--with-ft-exec-prefix=PREFIX],
-                   [Exec prefix where FreeType is installed (optional)])],
-    [ft_config_exec_prefix="$withval"],
-    [ft_config_exec_prefix=""])
-
-  AC_ARG_ENABLE([freetypetest],
-    [AS_HELP_STRING([--disable-freetypetest],
-                    [Do not try to compile and run a test FreeType program])],
-    [],
-    [enable_fttest=yes])
-
-  if test x$ft_config_exec_prefix != x ; then
-    ft_config_args="$ft_config_args --exec-prefix=$ft_config_exec_prefix"
-    if test x${FT2_CONFIG+set} != xset ; then
-      FT2_CONFIG=$ft_config_exec_prefix/bin/freetype-config
-    fi
-  fi
-
-  if test x$ft_config_prefix != x ; then
-    ft_config_args="$ft_config_args --prefix=$ft_config_prefix"
-    if test x${FT2_CONFIG+set} != xset ; then
-      FT2_CONFIG=$ft_config_prefix/bin/freetype-config
-    fi
-  fi
-
-  AC_PATH_PROG([FT2_CONFIG], [freetype-config], [no])
-
-  min_ft_version=m4_if([$1], [], [7.0.1], [$1])
-  AC_MSG_CHECKING([for FreeType -- version >= $min_ft_version])
-  no_ft=""
-  if test "$FT2_CONFIG" = "no" ; then
-    no_ft=yes
-  else
-    FT2_CFLAGS=`$FT2_CONFIG $ft_config_args --cflags`
-    FT2_LIBS=`$FT2_CONFIG $ft_config_args --libs`
-    ft_config_major_version=`$FT2_CONFIG $ft_config_args --version | \
-      sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\1/'`
-    ft_config_minor_version=`$FT2_CONFIG $ft_config_args --version | \
-      sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\2/'`
-    ft_config_micro_version=`$FT2_CONFIG $ft_config_args --version | \
-      sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\3/'`
-    ft_min_major_version=`echo $min_ft_version | \
-      sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\1/'`
-    ft_min_minor_version=`echo $min_ft_version | \
-      sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\2/'`
-    ft_min_micro_version=`echo $min_ft_version | \
-      sed 's/\([[0-9]]*\).\([[0-9]]*\).\([[0-9]]*\)/\3/'`
-    if test x$enable_fttest = xyes ; then
-      ft_config_is_lt=""
-      if test $ft_config_major_version -lt $ft_min_major_version ; then
-        ft_config_is_lt=yes
-      else
-        if test $ft_config_major_version -eq $ft_min_major_version ; then
-          if test $ft_config_minor_version -lt $ft_min_minor_version ; then
-            ft_config_is_lt=yes
-          else
-            if test $ft_config_minor_version -eq $ft_min_minor_version ; then
-              if test $ft_config_micro_version -lt $ft_min_micro_version ; then
-                ft_config_is_lt=yes
-              fi
-            fi
-          fi
-        fi
-      fi
-      if test x$ft_config_is_lt = xyes ; then
-        no_ft=yes
-      else
-        ac_save_CFLAGS="$CFLAGS"
-        ac_save_LIBS="$LIBS"
-        CFLAGS="$CFLAGS $FT2_CFLAGS"
-        LIBS="$FT2_LIBS $LIBS"
-        dnl
-        dnl Sanity checks for the results of freetype-config to some extent.
-        dnl
-        AC_RUN_IFELSE([
-          AC_LANG_SOURCE([[
-
-#include <ft2build.h>
-#include FT_FREETYPE_H
-#include <stdio.h>
-#include <stdlib.h>
-
-int
-main()
-{
-  FT_Library library;
-  FT_Error  error;
-
-  error = FT_Init_FreeType(&library);
-
-  if (error)
-    return 1;
-  else
-  {
-    FT_Done_FreeType(library);
-    return 0;
-  }
-}
-
-              ]]
-            )],
-            [],
-            [no_ft=yes],
-            [echo $ECHO_N "cross compiling; assuming OK... $ECHO_C"])
-
-        CFLAGS="$ac_save_CFLAGS"
-        LIBS="$ac_save_LIBS"
-      fi             dnl test $ft_config_version -lt $ft_min_version
-    fi               dnl test x$enable_fttest = xyes
-  fi                 dnl test "$FT2_CONFIG" = "no"
-
-  if test x$no_ft = x ; then
-    AC_MSG_RESULT([yes])
-    m4_if([$2], [], [:], [$2])
-  else
-    AC_MSG_RESULT([no])
-    if test "$FT2_CONFIG" = "no" ; then
-      warn_ft2_config = "
-
-The freetype-config script installed by FreeType 2 could not be found.
-If FreeType 2 was installed in PREFIX, make sure PREFIX/bin is in your
-path, or set the FT2_CONFIG environment variable to the full path to
-freetype-config.
-"
-      OCTAVE_CONFIGURE_WARNING([warn_ft2_config])
-    else
-      if test x$ft_config_is_lt = xyes ; then
-        warn_ft2_too_old="
-
-Your installed version of the FreeType 2 library is too old. If you
-have different versions of FreeType 2, make sure that correct values
-for --with-ft-prefix or --with-ft-exec-prefix are used, or set the
-FT2_CONFIG environment variable to the full path to freetype-config.
-"
-        OCTAVE_CONFIGURE_WARNING([warn_ft2_too_old])
-      else
-        warn_ft2_failed="
-
-The FreeType test program failed to run. If your system uses shared
-libraries and they are installed outside the normal system library
-path, make sure the variable LD_LIBRARY_PATH (or whatever is
-appropiate for your system) is correctly set.
-"
-        OCTAVE_CONFIGURE_WARNING([warn_ft2_failed])
-      fi
-    fi
-
-    FT2_CFLAGS=""
-    FT2_LIBS=""
-    m4_if([$3], [], [:], [$3])
-  fi
-
-  AC_SUBST([FT2_CFLAGS])
-  AC_SUBST([FT2_LIBS])
-])
-dnl end of freetype2.m4
-
-
 ##############################################################################
diff --git a/run-octave.in b/run-octave.in
--- a/run-octave.in
+++ b/run-octave.in
@@ -75,13 +75,14 @@ if [ $# -gt 0 ]; then
   elif [ "x$1" = "x-cli" ]; then
     octave_executable="$builddir/src/octave-cli"
     shift
   fi
 fi
 
 OCTAVE_SITE_INITFILE="$top_srcdir/scripts/startup/main-rcfile" \
 OCTAVE_DEFAULT_QT_SETTINGS="$top_srcdir/libgui/default-qt-settings" \
+OCTAVE_JAVA_DIR="$builddir/scripts/java" \
   exec $builddir/libtool --mode=execute $driver \
     "$octave_executable" --no-init-path --path="$LOADPATH" \
     --image-path="$IMAGEPATH" --doc-cache-file="$DOCFILE" \
     --built-in-docstrings-file="$BUILT_IN_DOCSTRINGS_FILE" \
     --texi-macros-file="$TEXIMACROSFILE" --info-file="$INFOFILE" "$@"
diff --git a/scripts/Makefile.am b/scripts/Makefile.am
--- a/scripts/Makefile.am
+++ b/scripts/Makefile.am
@@ -19,38 +19,45 @@
 # <http://www.gnu.org/licenses/>.
 
 include $(top_srcdir)/build-aux/common.mk
 
 AUTOMAKE_OPTIONS = subdir-objects
 
 EXTRA_DIST =
 
+CLEANFILES =
+
+DISTCLEANFILES =
+
 FCN_FILE_DIRS =
 
 FCN_FILES =
 
 GEN_FCN_FILES =
 
 PKG_ADD_FILES =
 
 DIRSTAMP_FILES =
 
 IMAGES =
 
+JAR_FILES =
+
 ## Read subdirs to set all variables above
 include @ftp/module.mk
 include audio/module.mk
 include deprecated/module.mk
 include elfun/module.mk
 include general/module.mk
 include geometry/module.mk
 include help/module.mk
 include image/module.mk
 include io/module.mk
+include java/module.mk
 include linear-algebra/module.mk
 include miscellaneous/module.mk
 include optimization/module.mk
 include path/module.mk
 include pkg/module.mk
 include plot/module.mk
 include polynomial/module.mk
 include prefs/module.mk
@@ -63,26 +70,26 @@ include startup/module.mk
 include statistics/base/module.mk
 include statistics/distributions/module.mk
 include statistics/models/module.mk
 include statistics/tests/module.mk
 include strings/module.mk
 include testfun/module.mk
 include time/module.mk
 
-nobase_fcnfile_DATA = $(FCN_FILES) $(GEN_FCN_FILES)
+nobase_fcnfile_DATA = $(FCN_FILES) $(GEN_FCN_FILES) $(JAR_FILES)
 
 image_DATA = $(IMAGES)
 
 FCN_FILES_IN = $(GEN_FCN_FILES:.m=.in)
 
 if AMCOND_BUILD_DOCS
-all-local: $(GEN_FCN_FILES) $(PKG_ADD_FILES) .DOCSTRINGS
+all-local: $(GEN_FCN_FILES) $(PKG_ADD_FILES) $(JAR_FILES) .DOCSTRINGS
 else
-all-local: $(GEN_FCN_FILES) $(PKG_ADD_FILES)
+all-local: $(GEN_FCN_FILES) $(PKG_ADD_FILES) $(JAR_FILES)
 endif
 
 octave_dirstamp = $(am__leading_dot)dirstamp
 
 @ftp/PKG_ADD: $(@ftp_FCN_FILES) $(@ftp_GEN_FCN_FILES) @ftp/$(octave_dirstamp) mk-pkg-add
 	$(srcdir)/mk-pkg-add $(srcdir) $(@ftp_FCN_FILES) -- $(@ftp_GEN_FCN_FILES) > $@-t
 	mv $@-t $@
 
@@ -113,16 +120,20 @@ help/PKG_ADD: $(help_FCN_FILES) $(help_G
 image/PKG_ADD: $(image_FCN_FILES) $(image_GEN_FCN_FILES) image/$(octave_dirstamp) mk-pkg-add
 	$(srcdir)/mk-pkg-add $(srcdir) $(image_FCN_FILES) -- $(image_GEN_FCN_FILES) > $@-t
 	mv $@-t $@
 
 io/PKG_ADD: $(io_FCN_FILES) $(io_GEN_FCN_FILES) io/$(octave_dirstamp) mk-pkg-add
 	$(srcdir)/mk-pkg-add $(srcdir) $(io_FCN_FILES) -- $(io_GEN_FCN_FILES) > $@-t
 	mv $@-t $@
 
+java/PKG_ADD: $(java_FCN_FILES) $(java_GEN_FCN_FILES) java/$(octave_dirstamp) mk-pkg-add
+	$(srcdir)/mk-pkg-add $(srcdir) $(java_FCN_FILES) -- $(java_GEN_FCN_FILES) > $@-t
+	mv $@-t $@
+
 linear-algebra/PKG_ADD: $(linear_algebra_FCN_FILES) $(linear_algebra_GEN_FCN_FILES) linear-algebra/$(octave_dirstamp) mk-pkg-add
 	$(srcdir)/mk-pkg-add $(srcdir) $(linear_algebra_FCN_FILES) -- $(linear_algebra_GEN_FCN_FILES) > $@-t
 	mv $@-t $@
 
 miscellaneous/PKG_ADD: $(miscellaneous_FCN_FILES) $(miscellaneous_GEN_FCN_FILES) miscellaneous/$(octave_dirstamp) mk-pkg-add
 	$(srcdir)/mk-pkg-add $(srcdir) $(miscellaneous_FCN_FILES) -- $(miscellaneous_GEN_FCN_FILES) > $@-t
 	mv $@-t $@
 
@@ -206,16 +217,17 @@ time/PKG_ADD: $(time_FCN_FILES) $(time_G
 $(audio_GEN_FCN_FILES): audio/$(octave_dirstamp)
 $(deprecated_GEN_FCN_FILES): deprecated/$(octave_dirstamp)
 $(elfun_GEN_FCN_FILES): elfun/$(octave_dirstamp)
 $(general_GEN_FCN_FILES): general/$(octave_dirstamp)
 $(geometry_GEN_FCN_FILES): geometry/$(octave_dirstamp)
 $(help_GEN_FCN_FILES): help/$(octave_dirstamp)
 $(image_GEN_FCN_FILES): image/$(octave_dirstamp)
 $(io_GEN_FCN_FILES): io/$(octave_dirstamp)
+$(java_GEN_FCN_FILES): java/$(octave_dirstamp)
 $(linear_algebra_GEN_FCN_FILES): linear-algebra/$(octave_dirstamp)
 $(miscellaneous_GEN_FCN_FILES): miscellaneous/$(octave_dirstamp)
 $(optimization_GEN_FCN_FILES): optimization/$(octave_dirstamp)
 $(path_GEN_FCN_FILES): path/$(octave_dirstamp)
 $(pkg_GEN_FCN_FILES): pkg/$(octave_dirstamp)
 $(plot_GEN_FCN_FILES): plot/$(octave_dirstamp)
 $(polynomial_GEN_FCN_FILES): polynomial/$(octave_dirstamp)
 $(prefs_GEN_FCN_FILES): prefs/$(octave_dirstamp)
@@ -255,16 +267,19 @@ help/$(octave_dirstamp):
 	$(MKDIR_P) help
 	: > help/$(octave_dirstamp)
 image/$(octave_dirstamp):
 	$(MKDIR_P) image
 	: > image/$(octave_dirstamp)
 io/$(octave_dirstamp):
 	$(MKDIR_P) io
 	: > io/$(octave_dirstamp)
+java/$(octave_dirstamp):
+	$(MKDIR_P) java
+	: > java/$(octave_dirstamp)
 linear-algebra/$(octave_dirstamp):
 	$(MKDIR_P) linear-algebra
 	: > linear-algebra/$(octave_dirstamp)
 miscellaneous/$(octave_dirstamp):
 	$(MKDIR_P) miscellaneous
 	: > miscellaneous/$(octave_dirstamp)
 optimization/$(octave_dirstamp):
 	$(MKDIR_P) optimization
@@ -427,15 +442,20 @@ EXTRA_DIST += \
   $(IMAGES) \
   $(FCN_FILES) \
   $(FCN_FILES_IN) \
   $(GEN_FCN_FILES) \
   DOCSTRINGS \
   mkdoc.pl \
   mk-pkg-add
 
-DISTCLEANFILES = \
+DISTCLEANFILES += \
   .DOCSTRINGS \
   DOCSTRINGS \
   $(PKG_ADD_FILES) \
   $(DIRSTAMP_FILES) \
   $(GEN_FCN_FILES)
 
+distclean-local:
+	if [ "x$(srcdir)" != "x." ]; then \
+	  rm $(java_JAVA_IMAGES); \
+	fi
+	
diff --git a/scripts/deprecated/java_convert_matrix.m b/scripts/deprecated/java_convert_matrix.m
new file mode 100644
--- /dev/null
+++ b/scripts/deprecated/java_convert_matrix.m
@@ -0,0 +1,48 @@
+## Copyright (C) 2012 Rik Wehbring
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Built-in Function} {@var{val} =} java_convert_matrix ()
+## @deftypefnx {Built-in Function} {@var{old_val} =} java_convert_matrix (@var{new_val})
+## @deftypefnx {Built-in Function} {} java_convert_matrix (@var{new_val}, \"local\")
+## Query or set the internal variable that controls whether Java arrays are
+## automatically converted to Octave matrices.  The default value is false.
+## 
+## When called from inside a function with the \"local\" option, the variable is
+## changed locally for the function and any subroutines it calls.  The original
+## variable value is restored when exiting the function.
+## @seealso{java_matrix_autoconversion, java_unsigned_conversion, java_debug}
+## @end deftypefn
+
+function old_val = java_convert_matrix (varargin)
+
+  persistent warned = false;
+  if (! warned)
+    warned = true;
+    warning ("Octave:deprecated-function",
+             "java_convert_matrix is obsolete and will be removed from a future version of Octave; use java_matrix_autoconversion instead");
+  endif
+
+  if (nargin > 2)
+    print_usage ();
+  endif
+
+  old_val = java_matrix_autoconversion (varargin{:});
+
+endfunction
+
diff --git a/scripts/deprecated/java_debug.m b/scripts/deprecated/java_debug.m
new file mode 100644
--- /dev/null
+++ b/scripts/deprecated/java_debug.m
@@ -0,0 +1,49 @@
+## Copyright (C) 2012 Rik Wehbring
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Built-in Function} {@var{val} =} java_debug ()
+## @deftypefnx {Built-in Function} {@var{old_val} =} java_debug (@var{new_val})
+## @deftypefnx {Built-in Function} {} java_debug (@var{new_val}, \"local\")
+## Query or set the internal variable that determines whether extra debugging
+## information regarding the initialization of the JVM and any Java exceptions
+## is printed.
+## 
+## When called from inside a function with the \"local\" option, the variable is
+## changed locally for the function and any subroutines it calls.  The original
+## variable value is restored when exiting the function.
+## @seealso{debug_java, java_convert_matrix, java_unsigned_conversion}
+## @end deftypefn
+
+function old_val = java_debug (varargin)
+
+  persistent warned = false;
+  if (! warned)
+    warned = true;
+    warning ("Octave:deprecated-function",
+             "java_debug is obsolete and will be removed from a future version of Octave; use debug_java instead");
+  endif
+
+  if (nargin > 2)
+    print_usage ();
+  endif
+
+  old_val = debug_java (varargin{:});
+
+endfunction
+
diff --git a/scripts/deprecated/java_get.m b/scripts/deprecated/java_get.m
new file mode 100644
--- /dev/null
+++ b/scripts/deprecated/java_get.m
@@ -0,0 +1,63 @@
+## Copyright (C) 2012 Rik Wehbring
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn {Loadable Function} {@var{val} =} java_get (@var{obj}, @var{name})
+## Get the value of the field @var{name} of the Java object @var{obj}.  For
+## static fields, @var{obj} can be a string representing the fully qualified
+## name of the corresponding class.
+## 
+## When @var{obj} is a regular Java object, structure-like indexing can be
+## used as a shortcut syntax.  For instance, the two following statements are
+## equivalent
+## 
+## @example
+## @group
+##   java_get (x, "field1")
+##   x.field1
+## @end group
+## @end example
+## 
+## @seealso{java_set, javaMethod, javaObject}
+## @end deftypefn
+
+function retval = java_get (obj, name)
+
+  persistent warned = false;
+  if (! warned)
+    warned = true;
+    warning ("Octave:deprecated-function",
+             "java_get is obsolete and will be removed from a future version of Octave; use structure-like indexing instead");
+  endif
+
+  if (nargin != 2)
+    print_usage ();
+  endif
+
+  if (isjava (obj))
+    retval = obj.(name);
+  elseif (ischar (obj))
+    ## FIXME: Need a solution for getting static fields of class
+    ##        which does not depend on __java_get__ which will be removed.
+    retval = __java_get__ (obj, name);
+  else
+    error ("java_get: OBJ must be a Java object");
+  endif
+
+endfunction
+
diff --git a/scripts/deprecated/java_invoke.m b/scripts/deprecated/java_invoke.m
new file mode 100644
--- /dev/null
+++ b/scripts/deprecated/java_invoke.m
@@ -0,0 +1,57 @@
+## Copyright (C) 2007 Michael Goffioul
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Built-in Function} {@var{ret} =} java_invoke (@var{obj}, @var{methodname})
+## @deftypefnx {Built-in Function} {@var{ret} =} java_invoke (@var{obj}, @var{methodname}, @var{arg1}, @dots{})
+## Invoke the method @var{methodname} on the Java object @var{obj} with the
+## arguments @var{arg1}, @dots{}  For static methods, @var{obj} can be a
+## string representing the fully qualified name of the corresponding class. 
+## The function returns the result of the method invocation.
+## 
+## When @var{obj} is a regular Java object, structure-like indexing can be
+## used as a shortcut syntax.  For instance, the two following statements are
+## equivalent
+## 
+## @example
+## @group
+##   ret = java_invoke (x, \"method1\", 1.0, \"a string\")
+##   ret = x.method1 (1.0, \"a string\")
+## @end group
+## @end example
+## 
+## @seealso{javaMethod, javaObject}
+## @end deftypefn
+
+function retval = java_invoke (obj, methodname, varargin)
+
+  persistent warned = false;
+  if (! warned)
+    warned = true;
+    warning ("Octave:deprecated-function",
+             "java_invoke is obsolete and will be removed from a future version of Octave, please use javaMethod instead");
+  endif
+  
+  if (nargin < 2)
+    print_usage ();
+  endif
+
+  retval = javaMethod (methodname, obj, varargin{:});
+
+endfunction
+
diff --git a/scripts/deprecated/java_new.m b/scripts/deprecated/java_new.m
new file mode 100644
--- /dev/null
+++ b/scripts/deprecated/java_new.m
@@ -0,0 +1,51 @@
+## Copyright (C) 2012 Rik Wehbring
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Loadable Function} {@var{obj} =} java_new (@var{name})
+## @deftypefnx {Loadable Function} {@var{obj} =} java_new (@var{name}, @var{arg1}, @dots{})
+## Create a Java object of class @var{name}, by calling the class constructor
+## with the arguments @var{arg1}, @dots{}
+## 
+## @example
+## @group
+##   x = java_new ("java.lang.StringBuffer")
+##   x = java_new ("java.lang.StringBuffer", "Initial string")
+## @end group
+## @end example
+## 
+## @seealso{javaObject, javaMethod}
+## @end deftypefn
+
+function retval = java_new (varargin)
+
+  persistent warned = false;
+  if (! warned)
+    warned = true;
+    warning ("Octave:deprecated-function",
+             "java_new is obsolete and will be removed from a future version of Octave; please use javaObject instead");
+  endif
+
+  if (nargin < 1)
+    print_usage ();
+  endif
+
+  retval = javaObject (varargin{:});
+
+endfunction
+
diff --git a/scripts/deprecated/java_set.m b/scripts/deprecated/java_set.m
new file mode 100644
--- /dev/null
+++ b/scripts/deprecated/java_set.m
@@ -0,0 +1,63 @@
+## Copyright (C) 2012 Rik Wehbring
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn {Loadable Function} {@var{obj} =} java_set (@var{obj}, @var{name}, @var{val})
+## Set the value of the field @var{name} of the Java object @var{obj} to
+## @var{val}.  For static fields, @var{obj} can be a string representing the
+## fully qualified named of the corresponding Java class.
+## 
+## When @var{obj} is a regular Java object, structure-like indexing can be
+## used as a shortcut syntax.  For instance, the two following statements are
+## equivalent
+## 
+## @example
+## @group
+##   java_set (x, "field1", val)
+##   x.field1 = val
+## @end group
+## @end example
+## 
+## @seealso{java_get, javaMethod, javaObject}
+## @end deftypefn
+
+function retval = java_set (obj, name, val)
+
+  persistent warned = false;
+  if (! warned)
+    warned = true;
+    warning ("Octave:deprecated-function",
+             "java_set is obsolete and will be removed from a future version of Octave; use structure-like indexing instead");
+  endif
+
+  if (nargin != 3)
+    print_usage ();
+  endif
+
+  if (isjava (obj))
+    obj.(name) = val;
+  elseif (ischar (obj))
+    ## FIXME: Need a solution for getting static fields of class
+    ##        which does not depend on __java_set__ which will be removed.
+    retval = __java_set__ (obj, name, val);
+  else
+    error ("java_set: OBJ must be a Java object");
+  endif
+
+endfunction
+
diff --git a/scripts/deprecated/java_unsigned_conversion.m b/scripts/deprecated/java_unsigned_conversion.m
new file mode 100644
--- /dev/null
+++ b/scripts/deprecated/java_unsigned_conversion.m
@@ -0,0 +1,50 @@
+## Copyright (C) 2012 Rik Wehbring
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Built-in Function} {@var{val} =} java_unsigned_conversion ()
+## @deftypefnx {Built-in Function} {@var{old_val} =} java_unsigned_conversion (@var{new_val})
+## @deftypefnx {Built-in Function} {} java_unsigned_conversion (@var{new_val}, \"local\")
+## Query or set the internal variable that controls how integer classes are
+## converted when Java matrix autoconversion is enabled.  When enabled, Java
+## arrays of class Byte or Integer are converted to matrices of class uint8 or
+## uint32 respectively.
+## 
+## When called from inside a function with the \"local\" option, the variable is
+## changed locally for the function and any subroutines it calls.  The original
+## variable value is restored when exiting the function.
+## @seealso{java_unsigned_autoconversion, java_convert_matrix, debug_java}
+## @end deftypefn
+
+function old_val = java_unsigned_conversion (varargin)
+
+  persistent warned = false;
+  if (! warned)
+    warned = true;
+    warning ("Octave:deprecated-function",
+             "java_unsigned_conversion is obsolete and will be removed from a future version of Octave; use java_unsigned_autoconversion instead");
+  endif
+
+  if (nargin > 2)
+    print_usage ();
+  endif
+
+  old_val = java_unsigned_autoconversion (varargin{:});
+
+endfunction
+
diff --git a/scripts/deprecated/javafields.m b/scripts/deprecated/javafields.m
new file mode 100644
--- /dev/null
+++ b/scripts/deprecated/javafields.m
@@ -0,0 +1,54 @@
+## Copyright (C) 2007 Michael Goffioul
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {} javafields (@var{javaobj})
+## @deftypefnx {Function File} {} javafields ("@var{classname}")
+## @deftypefnx {Function File} {@var{fld_names} =} javafields (@dots{})
+## Return the fields of a Java object or Java class in the form of a cell 
+## array of strings.  If no output is requested, print the result
+## to the standard output.
+## @seealso{fieldnames, methods, javaObject}
+## @end deftypefn
+
+function fld_names = javafields (javaobj)
+
+  persistent warned = false;
+  if (! warned)
+    warned = true;
+    warning ("Octave:deprecated-function",
+             "javafields is obsolete and will be removed from a future version of Octave, please use fieldnames instead");
+  endif
+  
+  if (nargin != 1)
+    print_usage ();
+  endif
+  
+  c_methods = javaMethod ("getFields", "org.octave.ClassHelper", javaobj);
+  method_list = strsplit (c_methods, ';');
+
+  if (nargout == 0)
+    if (! isempty (method_list))
+      disp (method_list);
+    endif
+  else
+    fld_names = cellstr (method_list);
+  endif
+
+endfunction
+
diff --git a/scripts/deprecated/javamethods.m b/scripts/deprecated/javamethods.m
new file mode 100644
--- /dev/null
+++ b/scripts/deprecated/javamethods.m
@@ -0,0 +1,54 @@
+## Copyright (C) 2007 Michael Goffioul
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {} javamethods (@var{javaobj})
+## @deftypefnx {Function File} {} javamethods ("@var{classname}")
+## @deftypefnx {Function File} {@var{mtd_names} =} javamethods (@dots{})
+## Return the methods of a Java object or Java class in the form of a cell 
+## array of strings.  If no output is requested, print the result to the
+## standard output.
+## @seealso{methods, fieldnames, javaMethod, javaObject}
+## @end deftypefn
+
+function mtd_names = javamethods (classname)
+
+  persistent warned = false;
+  if (! warned)
+    warned = true;
+    warning ("Octave:deprecated-function",
+             "javamethods is obsolete and will be removed from a future version of Octave, please use methods instead");
+  endif
+  
+  if (nargin != 1)
+    print_usage ();
+  endif
+
+  cls_methods = javaMethod ("getMethods", "org.octave.ClassHelper", classname);
+  method_list = strsplit (cls_methods, ';');
+
+  if (nargout == 0)
+    if (! isempty (method_list))
+      disp (method_list);
+    endif
+  else
+    mtd_names = cellstr (method_list);
+  endif
+
+endfunction
+
diff --git a/scripts/deprecated/module.mk b/scripts/deprecated/module.mk
--- a/scripts/deprecated/module.mk
+++ b/scripts/deprecated/module.mk
@@ -1,17 +1,26 @@
 FCN_FILE_DIRS += deprecated
 
 deprecated_FCN_FILES = \
   deprecated/__error_text__.m \
   deprecated/cor.m \
   deprecated/corrcoef.m \
   deprecated/cut.m \
+  deprecated/java_debug.m \
   deprecated/error_text.m \
   deprecated/isstr.m \
+  deprecated/java_convert_matrix.m \
+  deprecated/java_get.m \
+  deprecated/java_invoke.m \
+  deprecated/java_new.m \
+  deprecated/java_unsigned_conversion.m \
+  deprecated/java_set.m \
+  deprecated/javafields.m \
+  deprecated/javamethods.m \
   deprecated/polyderiv.m \
   deprecated/setstr.m \
   deprecated/shell_cmd.m \
   deprecated/studentize.m \
   deprecated/sylvester_matrix.m
 
 FCN_FILES += $(deprecated_FCN_FILES)
 
diff --git a/scripts/general/fieldnames.m b/scripts/general/fieldnames.m
new file mode 100644
--- /dev/null
+++ b/scripts/general/fieldnames.m
@@ -0,0 +1,78 @@
+## Copyright (C) 2012 Rik Wehbring
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {@var{names} =} fieldnames (@var{struct})
+## @deftypefnx {Function File} {@var{names} =} fieldnames (@var{obj})
+## @deftypefnx {Function File} {@var{names} =} fieldnames (@var{javaobj})
+## @deftypefnx {Function File} {@var{names} =} fieldnames ("@var{jclassname}")
+## Return a cell array of strings with the names of the fields in the
+## specified input.
+##
+## When the input is a structure @var{struct}, the names are the elements
+## of the structure.
+##
+## When the input is an Octave object @var{obj}, the names are the public
+## properties of the object.
+##
+## When the input is a Java object @var{javaobj} or Java classname
+## @var{jclassname}) the name are the public data elements of the object or
+## class.
+## @seealso{struct, methods}
+## @end deftypefn
+
+function names = fieldnames (obj)
+  
+  if (nargin != 1)
+    print_usage ();
+  endif
+  
+  if (isstruct (obj) || isobject (obj))
+    ## Call internal C++ function for structs or Octave objects
+    names = __fieldnames__ (obj);
+  elseif (isjava (obj) || ischar (obj))
+    ## FIXME: Function prototype that excepts java obj exists, but doesn't
+    ##        work if obj is java.lang.String.  Convert obj to classname.
+    if (! ischar (obj))
+      obj = class (obj);
+    endif
+    names_str = javaMethod ("getFields", "org.octave.ClassHelper", obj);
+    names = strsplit (names_str, ';');
+  else
+    error ("fieldnames: Invalid input argument"); 
+  endif
+
+endfunction
+
+
+## test preservation of fieldname order
+%!test
+%! x(3).d=1;  x(2).a=2;  x(1).b=3;  x(2).c=3;
+%! assert (fieldnames (x), {"d"; "a"; "b"; "c"});
+
+## test empty structure
+%!test
+%! s = struct ();
+%! assert (fieldnames (s), cell (0, 1));
+
+## test Java classname
+%!testif HAVE_JAVA 
+%! names = fieldnames ("java.lang.Double");
+%! search = strfind (names, "java.lang.Double.MAX_VALUE");
+%! assert (! isempty ([search{:}]));
+
diff --git a/scripts/general/isa.m b/scripts/general/isa.m
--- a/scripts/general/isa.m
+++ b/scripts/general/isa.m
@@ -12,45 +12,54 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} isa (@var{obj}, @var{class})
-## Return true if @var{obj} is an object from the class @var{class}.
+## @deftypefn {Function File} {} isa (@var{obj}, @var{classname})
+## Return true if @var{obj} is an object from the class @var{classname}.
+##
+## @var{classname} may also be one of the following class categories: 
+##
+## @table @asis
+## @item "float"
+## Floating point value comprising classes "double" and "single".
+##
+## @item "integer"
+## Integer value comprising classes (u)int8, (u)int16, (u)int32, (u)int64.
+##
+## @item "numeric"
+## Numeric value comprising either a floating point or integer value.
+## @end table
 ## @seealso{class, typeinfo}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 ## Adapted-by: jwe
 
-function retval = isa (obj, cname)
+function retval = isa (obj, classname)
 
   if (nargin != 2)
     print_usage ();
   endif
 
-  persistent float_classes = {"double", "single"};
-
-  persistent fnum_classes = {"double", "single", ...
-                             "uint8", "uint16", "uint32", "uint64", ...
-                             "int8", "int16", "int32", "int64"};
-
-  if (strcmp (cname, "float"))
-    retval = any (strcmp (class (obj), float_classes));
-  elseif (strcmp (cname, "numeric"))
-    retval = any (strcmp (class (obj), fnum_classes));
+  if (strcmp (classname, "float"))
+    retval = isfloat (obj);
+  elseif (strcmp (classname, "integer"))
+    retval = isinteger (obj);
+  elseif (strcmp (classname, "numeric"))
+    retval = isnumeric (obj);
   else
-    class_of_x = class (obj);
-    retval = strcmp (class_of_x, cname);
+    class_of_obj = class (obj);
+    retval = strcmp (class_of_obj, classname);
     if (! retval && isobject (obj))
-      retval = __isa_parent__ (obj, cname);
+      retval = __isa_parent__ (obj, classname);
     endif
   endif
 
 endfunction
 
 
 %!assert (isa ("char", "float"), false)
 %!assert (isa (logical (1), "float"), false)
@@ -71,16 +80,19 @@ endfunction
 %!assert (isa (int8 (13), "numeric"), true)
 %!assert (isa (int16 (13), "numeric"), true)
 %!assert (isa (int32 (13), "numeric"), true)
 %!assert (isa (int64 (13), "numeric"), true)
 %!assert (isa (uint8 (13), "numeric"), true)
 %!assert (isa (uint16 (13), "numeric"), true)
 %!assert (isa (uint32 (13), "numeric"), true)
 %!assert (isa (uint64 (13), "numeric"), true)
+%!assert (isa (uint8 (13), "integer"), true)
+%!assert (isa (double (13), "integer"), false)
+%!assert (isa (single (13), "integer"), false)
 
 %!assert (isa (double (13), "double"))
 %!assert (isa (single (13), "single"))
 %!assert (isa (int8 (13), "int8"))
 %!assert (isa (int16 (13), "int16"))
 %!assert (isa (int32 (13), "int32"))
 %!assert (isa (int64 (13), "int64"))
 %!assert (isa (uint8 (13), "uint8"))
diff --git a/scripts/general/logspace.m b/scripts/general/logspace.m
--- a/scripts/general/logspace.m
+++ b/scripts/general/logspace.m
@@ -80,20 +80,20 @@ function retval = logspace (base, limit,
 endfunction
 
 
 %!test
 %! x1 = logspace (1, 2);
 %! x2 = logspace (1, 2, 10.1);
 %! x3 = logspace (1, -2, 10);
 %! x4 = logspace (1, pi, 10);
-%! assert (size (x1) == [1, 50] && x1(1) == 10 && x1(50) == 100);
-%! assert (size (x2) == [1, 10] && x2(1) == 10 && x2(10) == 100);
-%! assert (size (x3) == [1, 10] && x3(1) == 10 && x3(10) == 0.01);
-%! assert (size (x4) == [1, 10] && x4(1) == 10 && abs (x4(10) - pi) < sqrt (eps));
+%! assert (size (x1) == [1, 50] && abs (x1(1) - 10) < eps && abs (x1(50) - 100) < eps);
+%! assert (size (x2) == [1, 10] && abs (x2(1) - 10) < eps && abs (x2(10) - 100) < eps);
+%! assert (size (x3) == [1, 10] && abs (x3(1) - 10) < eps && abs (x3(10) - 0.01) < eps);
+%! assert (size (x4) == [1, 10] && abs (x4(1) - 10) < eps && abs (x4(10) - pi) < sqrt (eps));
 
 %% Test input validation
 %!error logspace ()
 %!error logspace (1, 2, 3, 4)
 %!error logspace ([1, 2; 3, 4], 5, 6)
 %!error logspace (1, [1, 2; 3, 4], 6)
 %!error logspace (1, 2, [1, 2; 3, 4])
 
diff --git a/scripts/general/methods.m b/scripts/general/methods.m
new file mode 100644
--- /dev/null
+++ b/scripts/general/methods.m
@@ -0,0 +1,79 @@
+## Copyright (C) 2012 Rik Wehbring
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {} methods (@var{obj})
+## @deftypefnx {Function File} {} methods ("@var{classname}")
+## @deftypefnx {Function File} {@var{mtds} =} methods (@dots{})
+##
+## Return a cell array containing the names of the methods for the
+## object @var{obj} or the named class @var{classname}.
+## @var{obj} may be an Octave class object or a Java object.
+##
+## @seealso{fieldnames}
+## @end deftypefn
+
+function mtds = methods (obj)
+  
+  if (nargin != 1)
+    print_usage ();
+  endif
+  
+  if (isobject (obj))
+    ## Call internal C++ function for Octave objects
+    mtds_list = __methods__ (obj);
+  elseif (ischar (obj))
+    ## Could be a classname for an Octave class or Java class.
+    ## Try Octave class first.
+    mtds_list = __methods__ (obj);
+    if (isempty (mtds_list))
+      mtds_str = javaMethod ("getMethods", "org.octave.ClassHelper", obj);
+      mtds_list = strsplit (mtds_str, ';');
+    endif
+  elseif (isjava (obj))
+    ## FIXME: Function prototype that excepts java obj exists, but doesn't
+    ##        work if obj is java.lang.String.  Convert obj to classname.
+    obj = class (obj);
+    mtds_str = javaMethod ("getMethods", "org.octave.ClassHelper", obj);
+    mtds_list = strsplit (mtds_str, ';');
+  else
+    error ("methods: Invalid input argument");
+  endif
+
+  if (nargout == 0)
+    classname = ifelse (ischar (obj), obj, class (obj));
+    printf ("Methods for class %s:\n", classname);
+    disp (list_in_columns (mtds_list));
+  else
+    mtds = mtds_list;
+  endif
+
+endfunction
+
+
+## test Octave classname
+%!test
+%! mtds = methods ("ftp");
+%! assert (mtds{1}, "ascii");
+
+## test Java classname
+%!testif HAVE_JAVA 
+%! mtds = methods ("java.lang.Double");
+%! search = strfind (mtds, "java.lang.Double valueOf");
+%! assert (! isempty ([search{:}]));
+
diff --git a/scripts/general/module.mk b/scripts/general/module.mk
--- a/scripts/general/module.mk
+++ b/scripts/general/module.mk
@@ -23,16 +23,17 @@ general_FCN_FILES = \
   general/cplxpair.m \
   general/cumtrapz.m \
   general/curl.m \
   general/dblquad.m \
   general/deal.m \
   general/del2.m \
   general/display.m \
   general/divergence.m \
+  general/fieldnames.m \
   general/flipdim.m \
   general/fliplr.m \
   general/flipud.m \
   general/genvarname.m \
   general/gradient.m \
   general/idivide.m \
   general/int2str.m \
   general/interp1.m \
@@ -47,16 +48,17 @@ general_FCN_FILES = \
   general/isequal.m \
   general/isequalwithequalnans.m \
   general/isrow.m \
   general/isscalar.m \
   general/issquare.m \
   general/isvector.m \
   general/loadobj.m \
   general/logspace.m \
+  general/methods.m \
   general/nargchk.m \
   general/narginchk.m \
   general/nargoutchk.m \
   general/nthargout.m \
   general/nextpow2.m \
   general/num2str.m \
   general/pol2cart.m \
   general/polyarea.m \
diff --git a/scripts/general/num2str.m b/scripts/general/num2str.m
--- a/scripts/general/num2str.m
+++ b/scripts/general/num2str.m
@@ -78,18 +78,24 @@ function retval = num2str (x, arg)
         fmt = arg;
       elseif (isnumeric (arg) && isscalar (arg) && arg >= 0)
         fmt = sprintf ("%%%d.%dg", arg+7, arg);
       else
         error ("num2str: PRECISION must be a scalar integer >= 0");
       endif
     else
       if (isnumeric (x))
-        ## Setup a suitable format string
-        dgt = floor (log10 (max (abs (x(:)))));
+        ## Setup a suitable format string, ignoring inf entries
+        dgt = floor (log10 (max (abs (x(!isinf (x(:)))))));
+
+        ## If the whole input array is inf...
+        if (isempty (dgt))
+          dgt = 0;
+        endif
+
         if (any (x(:) != fix (x(:))))
           ## Floating point input
           dgt = max (dgt + 4, 5);   # Keep 4 sig. figures after decimal point
           dgt = min (dgt, 16);      # Cap significant digits at 16
           fmt = sprintf ("%%%d.%dg", dgt+7+any (x(:) < 0), dgt);
         else
           ## Integer input
           dgt = max (dgt + 1, 1);
@@ -164,16 +170,18 @@ endfunction
 %!assert (num2str (1.234 + 27.3i), "1.234+27.3i")
 %!assert (num2str ([true false true]), "1  0  1");
 
 %!assert (num2str (19440606), "19440606")
 %!assert (num2str (2^33), "8589934592")
 %!assert (num2str (-2^33), "-8589934592")
 %!assert (num2str (2^33+1i), "8589934592+1i")
 %!assert (num2str (-2^33+1i), "-8589934592+1i")
+%!assert (num2str (inf), "Inf")
+%!assert (num2str (nan), "NaN")
 
 ## FIXME: Integers greater than bitmax() should be masked to show just
 ##        16 digits of precision.
 %!xtest
 %! assert (num2str (1e23), "100000000000000000000000");
 
 %!error num2str ()
 %!error num2str (1, 2, 3)
diff --git a/scripts/general/quadgk.m b/scripts/general/quadgk.m
--- a/scripts/general/quadgk.m
+++ b/scripts/general/quadgk.m
@@ -136,17 +136,17 @@ function [q, err] = quadgk (f, a, b, var
     abstol = 1e-10;
     reltol = 1e-5;
     waypoints = [];
     maxint = 650;
     trace = false;
 
     if (nargin > 3)
       if (! ischar (varargin{1}))
-        if (!isempty (varargin{1}))
+        if (! isempty (varargin{1}))
           abstol = varargin{1};
           reltol = 0;
         endif
         if (nargin > 4)
           trace = varargin{2};
         endif
         if (nargin > 5)
           error ("quadgk: can not pass additional arguments to user function");
@@ -165,76 +165,76 @@ function [q, err] = quadgk (f, a, b, var
               if (isreal (waypoints))
                 waypoints (waypoints < a | waypoints > b) = [];
               endif
             elseif (strcmpi (str, "maxintervalcount"))
               maxint = varargin{idx++};
             elseif (strcmpi (str, "trace"))
               trace = varargin{idx++};
             else
-              error ("quadgk: unknown property %s", str);
+              error ("quadgk: unknown property '%s'", str);
             endif
           else
-            error ("quadgk: expecting property to be a string");
+            error ("quadgk: property PROP must be a string");
           endif
         endwhile
         if (idx != nargin - 2)
-          error ("quadgk: expecting properties in pairs");
+          error ("quadgk: property/value must occur in pairs");
         endif
       endif
     endif
 
     ## Convert function given as a string to a function handle
     if (ischar (f))
       f = @(x) feval (f, x);
     endif
 
     ## Use variable subsitution to weaken endpoint singularities and to
-    ## perform integration with endpoints at infinity. No transform for
-    ## contour integrals
+    ## perform integration with endpoints at infinity.  No transform for
+    ## contour integrals.
     if (iscomplex (a) || iscomplex (b) || iscomplex (waypoints))
       ## contour integral, no transform
       subs = [a; waypoints; b];
       h = sum (abs (diff (subs)));
       h0 = h;
       trans = @(t) t;
     elseif (isinf (a) && isinf (b))
-      ## Standard Infinite to finite integral transformation.
+      ## Standard infinite to finite integral transformation.
       ##   \int_{-\infinity_^\infinity f(x) dx = \int_-1^1 f (g(t)) g'(t) dt
       ## where
       ##   g(t)  = t / (1 - t^2)
       ##   g'(t) =  (1 + t^2) / (1 - t^2) ^ 2
       ## waypoint transform is then
       ##   t =  (2 * g(t)) ./ (1 + sqrt(1 + 4 * g(t) .^ 2))
-      if (!isempty (waypoints))
+      if (! isempty (waypoints))
         trans = @(x) (2 * x) ./ (1 + sqrt (1 + 4 * x .^ 2));
         subs = [-1; trans(waypoints); 1];
       else
         subs = linspace (-1, 1, 11)';
       endif
       h = 2;
       h0 = b - a;
       trans = @(t) t ./ (1 - t.^2);
       f = @(t) f (t ./ (1 - t .^ 2)) .* (1 + t .^ 2) ./ ((1 - t .^ 2) .^ 2);
-    elseif (isinf(a))
+    elseif (isinf (a))
       ## Formula defined in Shampine paper as two separate steps. One to
       ## weaken singularity at finite end, then a second to transform to
       ## a finite interval. The singularity weakening transform is
       ##   \int_{-\infinity}^b f(x) dx =
       ##               - \int_{-\infinity}^0 f (b - t^2) 2 t dt
       ## (note minus sign) and the finite interval transform is
       ##   \int_{-\infinity}^0 f(b - t^2)  2 t dt =
       ##                  \int_{-1}^0 f (b - g(s) ^ 2) 2 g(s) g'(s) ds
       ## where
       ##   g(s)  = s / (1 + s)
       ##   g'(s) = 1 / (1 + s) ^ 2
       ## waypoint transform is then
       ##   t = sqrt (b - x)
       ##   s =  - t / (t + 1)
-      if (!isempty (waypoints))
+      if (! isempty (waypoints))
         tmp = sqrt (b - waypoints);
         trans = @(x)  - x ./ (x + 1);
         subs = [-1; trans(tmp); 0];
       else
         subs = linspace (-1, 0, 11)';
       endif
       h = 1;
       h0 = b - a;
@@ -249,17 +249,17 @@ function [q, err] = quadgk (f, a, b, var
       ##  \int_0^\infinity f(a + t^2)  2 t dt =
       ##           \int_0^1 f (a + g(s) ^ 2) 2 g(s) g'(s) ds
       ## where
       ##   g(s)  = s / (1 - s)
       ##   g'(s) = 1 / (1 - s) ^ 2
       ## waypoint transform is then
       ##   t = sqrt (x - a)
       ##   s = t / (t + 1)
-      if (!isempty (waypoints))
+      if (! isempty (waypoints))
         tmp = sqrt (waypoints - a);
         trans = @(x) x ./ (x + 1);
         subs = [0; trans(tmp); 1];
       else
         subs = linspace (0, 1, 11)';
       endif
       h = 1;
       h0 = b - a;
@@ -292,109 +292,106 @@ function [q, err] = quadgk (f, a, b, var
 
     ## Split interval into at least 10 subinterval with a 15 point
     ## Gauss-Kronrod rule giving a minimum of 150 function evaluations
     while (length (subs) < 11)
       subs = [subs' ; subs(1:end-1)' + diff(subs') ./ 2, NaN](:)(1 : end - 1);
     endwhile
     subs = [subs(1:end-1), subs(2:end)];
 
-    warn_state = warning ("query", "Octave:divide-by-zero");
+    ## Singularity will cause divide by zero warnings.
+    ## Turn off warning locally for quadgk function only.
+    warning ("off", "Octave:divide-by-zero", "local");
+
+    warn_id = "Octave:quadgk:warning-termination";
 
-    unwind_protect
-      ## Singularity will cause divide by zero warnings
-      warning ("off", "Octave:divide-by-zero");
+    ## Initial evaluation of the integrand on the subintervals
+    [q_subs, q_errs] = __quadgk_eval__ (f, subs);
+    q0 = sum (q_subs);
+    err0 = sum (q_errs);
+
+    if (isa (a, "single") || isa (b, "single") || isa (waypoints, "single"))
+      myeps = eps ("single");
+    else
+      myeps = eps;
+    endif
 
-      ## Initial evaluation of the integrand on the subintervals
-      [q_subs, q_errs] = __quadgk_eval__ (f, subs);
-      q0 = sum (q_subs);
-      err0 = sum (q_errs);
+    first = true;
+    while (true)
+      ## Check for subintervals that are too small. Test must be
+      ## performed in untransformed subintervals. What is a good
+      ## value for this test. Shampine suggests 100*eps
+      if (any (abs (diff (trans (subs), [], 2) / h0) < 100 * myeps))
+        q = q0;
+        err = err0;
+        break;
+      endif
 
-      if (isa (a, "single") || isa (b, "single") || isa (waypoints, "single"))
-        myeps = eps ("single");
-      else
-        myeps = eps;
+      ## Quit if any evaluations are not finite (Inf or NaN)
+      if (any (! isfinite (q_subs)))
+        warning (warn_id, "quadgk: non finite integrand encountered");
+        q = q0;
+        err = err0;
+        break;
+      endif
+
+      tol = max (abstol, reltol .* abs (q0));
+
+      ## If the global error estimate is meet exit
+      if (err0 < tol)
+        q = q0;
+        err = err0;
+        break;
       endif
 
-      first = true;
-      while (true)
-        ## Check for subintervals that are too small. Test must be
-        ## performed in untransformed subintervals. What is a good
-        ## value for this test. Shampine suggests 100*eps
-        if (any (abs (diff (trans (subs), [], 2) / h0) < 100 * myeps))
-          q = q0;
-          err = err0;
-          break;
-        endif
+      ## Accept the subintervals that meet the convergence criteria
+      idx = find (abs (q_errs) < tol .* abs (diff (subs, [], 2)) ./ h);
+      if (first)
+        q = sum (q_subs (idx));
+        err = sum (q_errs(idx));
+        first = false;
+      else
+        q0 = q + sum (q_subs);
+        err0 = err + sum (q_errs);
+        q += sum (q_subs (idx));
+        err += sum (q_errs(idx));
+      endif
+      subs(idx,:) = [];
 
-        ## Quit if any evaluations are not finite (Inf or NaN)
-        if (any (! isfinite (q_subs)))
-          warning ("quadgk: non finite integrand encountered");
-          q = q0;
-          err = err0;
-          break;
-        endif
+      ## If no remaining subintervals exit
+      if (rows (subs) == 0)
+        break;
+      endif
 
-        tol = max (abstol, reltol .* abs (q0));
-
-        ## If the global error estimate is meet exit
-        if (err0 < tol)
-          q = q0;
-          err = err0;
-          break;
-        endif
+      if (trace)
+        disp ([rows(subs), err, q0]);
+      endif
 
-        ## Accept the subintervals that meet the convergence criteria
-        idx = find (abs (q_errs) < tol .* abs (diff (subs, [], 2)) ./ h);
-        if (first)
-          q = sum (q_subs (idx));
-          err = sum (q_errs(idx));
-          first = false;
-        else
-          q0 = q + sum (q_subs);
-          err0 = err + sum (q_errs);
-          q += sum (q_subs (idx));
-          err += sum (q_errs(idx));
-        endif
-        subs(idx,:) = [];
-
-        ## If no remaining subintervals exit
-        if (rows (subs) == 0)
-          break;
-        endif
-
-        if (trace)
-          disp ([rows(subs), err, q0]);
-        endif
+      ## Split remaining subintervals in two
+      mid = (subs(:,2) + subs(:,1)) ./ 2;
+      subs = [subs(:,1), mid; mid, subs(:,2)];
 
-        ## Split remaining subintervals in two
-        mid = (subs(:,2) + subs(:,1)) ./ 2;
-        subs = [subs(:,1), mid; mid, subs(:,2)];
-
-        ## If the maximum subinterval count is met accept remaining
-        ## subinterval and exit
-        if (rows (subs) > maxint)
-          warning ("quadgk: maximum interval count (%d) met", maxint);
-          q += sum (q_subs);
-          err += sum (q_errs);
-          break;
-        endif
+      ## If the maximum subinterval count is met accept remaining
+      ## subinterval and exit
+      if (rows (subs) > maxint)
+        warning (warn_id, "quadgk: maximum interval count (%d) met", maxint);
+        q += sum (q_subs);
+        err += sum (q_errs);
+        break;
+      endif
 
-        ## Evaluation of the integrand on the remaining subintervals
-        [q_subs, q_errs] = __quadgk_eval__ (f, subs);
-      endwhile
+      ## Evaluation of the integrand on the remaining subintervals
+      [q_subs, q_errs] = __quadgk_eval__ (f, subs);
+    endwhile
 
-      if (err > max (abstol, reltol * abs (q)))
-        warning ("quadgk: Error tolerance not met. Estimated error %g", err);
-      endif
-    unwind_protect_cleanup
-      if (strcmp (warn_state.state, "on"))
-        warning ("on", "Octave:divide-by-zero");
-      endif
-    end_unwind_protect
+    if (err > max (abstol, reltol * abs (q)))
+      warning (warn_id,
+               "quadgk: Error tolerance not met.  Estimated error %g", err);
+    endif
+
   endif
 endfunction
 
 function [q, err] = __quadgk_eval__ (f, subs)
   ## A (15,7) point pair of Gauss-Konrod quadrature rules. The abscissa
   ## and weights are copied directly from dqk15w.f from quadpack
 
   persistent abscissa = [-0.9914553711208126e+00, -0.9491079123427585e+00, ...
@@ -455,9 +452,8 @@ endfunction
 %!assert (quadgk (@(z) log (z),1+1i,1+1i, "WayPoints", [1-1i, -1,-1i, -1+1i]), -pi * 1i, 1e-6)
 
 %!assert (quadgk (@(x) exp (-x .^ 2),-Inf,Inf), sqrt (pi), 1e-6)
 %!assert (quadgk (@(x) exp (-x .^ 2),-Inf,0), sqrt (pi)/2, 1e-6)
 
 %error (quadgk (@sin))
 %error (quadgk (@sin, -pi))
 %error (quadgk (@sin, -pi, pi, "DummyArg"))
-
diff --git a/scripts/help/__makeinfo__.m b/scripts/help/__makeinfo__.m
--- a/scripts/help/__makeinfo__.m
+++ b/scripts/help/__makeinfo__.m
@@ -111,17 +111,17 @@ function [retval, status] = __makeinfo__
   endif
 
   ## Create the final TeXinfo input string
   text = sprintf ("\\input texinfo\n\n%s\n\n@bye\n", text);
 
   unwind_protect
     ## Write Texinfo to tmp file
     template = "octave-help-XXXXXX";
-    [fid, name] = mkstemp (fullfile (P_tmpdir, template), true);
+    [fid, name] = mkstemp (fullfile (tempdir, template), true);
     if (fid < 0)
       error ("__makeinfo__: could not create temporary file");
     endif
     fwrite (fid, text);
     fclose (fid);
 
     ## Take action depending on output type
     switch (lower (output_type))
diff --git a/scripts/image/autumn.m b/scripts/image/autumn.m
--- a/scripts/image/autumn.m
+++ b/scripts/image/autumn.m
@@ -32,17 +32,17 @@
 ## PKG_DEL: colormap ("unregister", "autumn");
 
 function map = autumn (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
-      error ("autumn: argument must be a scalar");
+      error ("autumn: N must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [1, 0, 0];
   elseif (n > 1)
diff --git a/scripts/image/bone.m b/scripts/image/bone.m
--- a/scripts/image/bone.m
+++ b/scripts/image/bone.m
@@ -32,17 +32,17 @@
 ## PKG_DEL: colormap ("unregister", "bone");
 
 function map = bone (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
-      error ("bone: argument must be a scalar");
+      error ("bone: N must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [0.125, 0.125, 0.125];
   elseif (n > 1)
diff --git a/scripts/image/brighten.m b/scripts/image/brighten.m
--- a/scripts/image/brighten.m
+++ b/scripts/image/brighten.m
@@ -28,32 +28,35 @@
 ## The argument @var{beta} must be a scalar between -1 and 1, where a
 ## negative value darkens and a positive value brightens the colormap.
 ##
 ## If no output is specified then the result is written to the current colormap.
 ## @seealso{colormap, contrast}
 ## @end deftypefn
 
 function rmap = brighten (arg1, beta)
+
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+  endif
+
   h = -1;
   if (nargin == 1)
     beta = arg1;
-    m = colormap;
+    m = colormap ();
     h = gcf ();
-  elseif (nargin == 2)
+  else
     if (ishandle (arg1))
       h = arg1;
       m = get (h, "colormap");
-    elseif (ismatrix (arg1) && columns (arg1) == 3)
+    elseif (iscolormap (arg1))
       m = arg1;
     else
-      error ("brighten: first argument must be an Nx3 matrix or a handle");
+      error ("brighten: first argument must be a colormap or a graphics handle");
     endif
-  else
-    print_usage ();
   endif
 
   if (! isscalar (beta) || beta <= -1 || beta >= 1)
     error ("brighten: BETA must be a scalar in the range (-1,1)");
   endif
 
   if (beta > 0)
     gamma = 1 - beta;
@@ -67,8 +70,27 @@ function rmap = brighten (arg1, beta)
     else
       colormap (m .^ gamma);
     endif
   else
     rmap = m .^ gamma;
   endif
 
 endfunction
+
+
+%!demo
+%! ## First figure uses default grayscale colormap
+%! figure;
+%! colormap (gray (64));
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! title ("default grayscale colormap");
+%! pos = get (gcf, "position");
+%! pos(1) += pos(3) + 25;
+%! ## Second figure uses brightened grayscale colormap
+%! figure ("position", pos);
+%! colormap (gray (64));
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! brighten (0.5);
+%! title ("grayscale colormap brightened by 0.5");
+
diff --git a/scripts/image/cmpermute.m b/scripts/image/cmpermute.m
--- a/scripts/image/cmpermute.m
+++ b/scripts/image/cmpermute.m
@@ -20,18 +20,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{Y}, @var{newmap}] =} cmpermute (@var{X}, @var{map})
 ## @deftypefnx {Function File} {[@var{Y}, @var{newmap}] =} cmpermute (@var{X}, @var{map}, @var{index})
 ## Reorder colors in a colormap.
 ##
 ## When called with only two arguments, @code{cmpermute} randomly rearranges
 ## the colormap @var{map} and returns a new colormap @var{newmap}.  It also
 ## returns the indexed image @var{Y} which is the equivalent of the original
-## input image @var{X} when displayed using @var{newmap}.  The input image
-## @var{X} must be an indexed image of class uint8 or double.
+## input image @var{X} when displayed using @var{newmap}.  
 ##
 ## When called with an optional third argument the order of colors in the
 ## new colormap is defined by @var{index}.
 ##
 ## @strong{Caution:} @code{index} should not have repeated elements or the
 ## function will fail.
 ##
 ## @end deftypefn
@@ -39,19 +38,19 @@
 ## Author:  Josep Mones i Teixidor <jmones@puntbarra.com>
 
 function [Y, newmap] = cmpermute (X, map, index)
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
-  ## FIXME: Matlab only accepts 2 types.  Expand to uint16 & single??
-  if (! (isa (X, "uint8") || isa (X, "double")))
-    error ("cmpermute: X must be of class uint8 or double");
+  cls = class (X);
+  if (! any (strcmp (cls, {"uint8", "uint16", "single", "double"})))
+    error ("cmpermute: invalid data type '%s'", cls);
   endif
 
   if (! isreal (X) || issparse (X)
       || (isfloat (X) && (any (X(:) < 1 || any (X(:) != fix (X(:)))))))
     error ("cmpermute: X must be an indexed image");
   endif
 
   if (! iscolormap (map))
@@ -66,23 +65,27 @@ function [Y, newmap] = cmpermute (X, map
 
   ## new colormap
   newmap = map(index,:);
 
   ## build reverse index
   rindex = zeros (size (index));
   rindex(index) = 1:length (index);
  
-  ## adapt indices
-  if (isa (X, "uint8"))
-    rindex = uint8 (rindex-1);
+  ## preserve class of input image in output
+  if (strcmp (cls, "double")) 
+    Y = rindex(X);
+  elseif (strcmp (cls, "single")) 
+    rindex = single (rindex);
+    Y = rindex(X);
+  else
+    ## adapt indices
+    rindex = feval (cls, rindex - 1);
     ## 0-based indices
-    Y = rindex(double (X) + 1);
-  else
-    Y = rindex(X);
+    Y = rindex(single (X) + 1);
   endif
 
 endfunction
 
 
 %!demo
 %! [Y, newmap] = cmpermute ([1:4], hot (4), 4:-1:1)
 %! ## colormap will be arranged in reverse order (so will image)
@@ -121,17 +124,17 @@ endfunction
 %! ## we expect a reversed colormap
 %! assert (newmap (rows (newmap):-1:1,:), map);
 %! ## we expect reversed indices in image
 %! assert (X, max (Y(:)) + 1 - Y);
 
 ## Test input validation
 %!error cmpermute ()
 %!error cmpermute (1,2,3,4)
-%!error <X must be of class uint8> cmpermute (uint16 (magic (16)), jet (256))
+%!error <invalid data type 'uint32'> cmpermute (uint32 (magic (16)), jet (256))
 %!error <X must be an indexed image> cmpermute (1+i, jet (256))
 %!error <X must be an indexed image> cmpermute (sparse (1), jet (256))
 %!error <X must be an indexed image> cmpermute (0, jet (256))
 %!error <X must be an indexed image> cmpermute (1.5, jet (256))
 %!error <MAP must be a valid colormap> cmpermute (1, "a")
 %!error <MAP must be a valid colormap> cmpermute (1, i)
 %!error <MAP must be a valid colormap> cmpermute (1, ones (3,3,3))
 %!error <MAP must be a valid colormap> cmpermute (1, ones (3,2))
diff --git a/scripts/image/cmunique.m b/scripts/image/cmunique.m
--- a/scripts/image/cmunique.m
+++ b/scripts/image/cmunique.m
@@ -56,31 +56,30 @@
 
 function [Y, newmap] = cmunique (X, map)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   cls = class (X);
-  ## FIXME: Documentation accepts only 3 classes.  Could easily add 'single'.
-  if (! any (isa (X, {"uint8", "uint16", "double"})))
+  if (! any (strcmp (cls, {"uint8", "uint16", "single", "double"})))
     error ("cmunique: X is of invalid data type '%s'", cls);
   endif
 
   if (nargin == 2)
     ## (X, map) case
     if (! iscolormap (map))
       error ("cmunique: MAP must be a valid colormap");
     endif
     [newmap,i,j] = unique (map, "rows");  # calculate unique colormap
-    if (isa (X, "double"))
+    if (isfloat (X))
       Y = j(X);               # find new indices
     else
-      Y = j(double (X) + 1);  # find new indices
+      Y = j(double (X) + 1);  # find new indices, switch to 1-based index
     endif
   else
     switch (size (X,3))
       case (1)
         ## I case
         [newmap,i,j] = unique (X);               # calculate unique colormap
         newmap = repmat (newmap,1,3);            # get a RGB colormap
         Y = reshape (j, rows (X), columns (X));  # Y is j reshaped
@@ -90,23 +89,23 @@ function [Y, newmap] = cmunique (X, map)
         map = [X(:,:,1)(:), X(:,:,2)(:), X(:,:,3)(:)];
         [newmap,i,j] = unique (map, "rows");     # calculate unique colormap
         Y = reshape (j, rows (X), columns (X));  # Y is j reshaped
       otherwise
         error ("cmunique: X is not a valid image");
     endswitch
     
     ## if image was uint8 or uint16 we have to convert newmap to [0,1] range
-    if (! isa (X, "double"))
-      newmap = double (newmap) / double (intmax (class (X)));
+    if (isinteger (X))
+      newmap = double (newmap) / double (intmax (cls));
     endif
   endif
 
   if (rows (newmap) <= 256)
-    ## convert Y to uint8 (0-based indices then)
+    ## convert Y to uint8 and 0-based indexing
     Y = uint8 (Y-1);
   endif
 
 endfunction
 
 
 %!demo
 %! [Y, newmap] = cmunique ([1:4;5:8], [hot(4);hot(4)])
@@ -179,24 +178,24 @@ endfunction
 %! assert (Id, newmap(:,1)(Y+1));
 %! assert (Id, newmap(:,2)(Y+1));
 %! assert (Id, newmap(:,3)(Y+1));
 
 ## Random uint16 I image
 %!test
 %! I = uint16 (rand (10,10)*65535);
 %! Id = double (I) / 65535;
-%! [Y,newmap] = cmunique (I);
-%! assert (Id,newmap (:,1)(Y+1));
-%! assert (Id,newmap (:,2)(Y+1));
-%! assert (Id,newmap (:,3)(Y+1));
+%! [Y, newmap] = cmunique (I);
+%! assert (Id, newmap(:,1)(Y+1));
+%! assert (Id, newmap(:,2)(Y+1));
+%! assert (Id, newmap(:,3)(Y+1));
 
 ## Test input validation
 %!error cmpermute ()
 %!error cmpermute (1,2,3)
-%!error <X is of invalid data type> cmunique (single (magic (16)))
+%!error <X is of invalid data type> cmunique (uint32 (magic (16)))
 %!error <MAP must be a valid colormap> cmunique (1, "a")
 %!error <MAP must be a valid colormap> cmunique (1, i)
 %!error <MAP must be a valid colormap> cmunique (1, ones (3,3,3))
 %!error <MAP must be a valid colormap> cmunique (1, ones (3,2))
 %!error <MAP must be a valid colormap> cmunique (1, [-1 1 1])
 %!error <MAP must be a valid colormap> cmunique (1, [2 1 1])
 
diff --git a/scripts/image/colorcube.m b/scripts/image/colorcube.m
--- a/scripts/image/colorcube.m
+++ b/scripts/image/colorcube.m
@@ -30,17 +30,17 @@
 ## @end deftypefn
 
 function map = colorcube (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
-      error ("colorcube: argument must be a scalar");
+      error ("colorcube: N must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n < 9)
     map = gray (n);
     return;
diff --git a/scripts/image/colormap.m b/scripts/image/colormap.m
--- a/scripts/image/colormap.m
+++ b/scripts/image/colormap.m
@@ -17,18 +17,18 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{cmap} =} colormap ()
 ## @deftypefnx {Function File} {@var{cmap} =} colormap (@var{map})
 ## @deftypefnx {Function File} {@var{cmap} =} colormap ("default")
 ## @deftypefnx {Function File} {@var{cmap} =} colormap ("list")
-## @deftypefnx {Function File} {@var{cmap} =} colormap ("register", "name")
-## @deftypefnx {Function File} {@var{cmap} =} colormap ("unregister", "name")
+## @deftypefnx {Function File} {@var{cmap} =} colormap ("register", "@var{name}")
+## @deftypefnx {Function File} {@var{cmap} =} colormap ("unregister", "@var{name}")
 ## Query or set the current colormap.
 ##
 ## @code{colormap (@var{map})} sets the current colormap to @var{map}.  The
 ## colormap should be an @var{n} row by 3 column matrix.  The columns
 ## contain red, green, and blue intensities respectively.  All entries
 ## must be between 0 and 1 inclusive.  The new colormap is returned.
 ##
 ## @code{colormap ("default")} restores the default colormap (the
@@ -63,21 +63,22 @@ function cmap = colormap (map, name)
         cmap = map_list;
         return;
       else
         map = feval (map);
       endif
     endif
 
     if (! isempty (map))
-      if (columns (map) != 3)
-        error ("colormap: MAP must have 3 columns: [R,G,B]");
+      if (! (isnumeric (map) && isreal (map)
+             && ndims (map) == 2 && columns (map) == 3))
+        error ("colormap: MAP must be a real-valued N x 3 ([R,G,B]) matrix");
       endif
-      if (min (min (map)) < 0 || max (max (map)) > 1)
-        error ("colormap: MAP must have values in [0,1]");
+      if (any (map(:) < 0) || any (map(:) > 1))
+        error ("colormap: all MAP values must be in the range [0,1]");
       endif
       ## Set the new color map
       set (gcf (), "colormap", map);
     endif
 
   elseif (nargin == 2)
     if (! ischar (map) || all (! strcmp (map, {"register", "unregister"})))
       print_usage ();
@@ -91,8 +92,11 @@ function cmap = colormap (map, name)
   endif
 
   ## Return current color map.
   if (nargout > 0 || (nargout == 0 && nargin == 0))
     cmap = get (gcf (), "colormap");
   endif
 
 endfunction
+
+
+%% FIXME: Need some demos/tests
diff --git a/scripts/image/contrast.m b/scripts/image/contrast.m
--- a/scripts/image/contrast.m
+++ b/scripts/image/contrast.m
@@ -12,53 +12,53 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{map} =} contrast (@var{x})
-## @deftypefnx {Function File} {@var{map} =} contrast (@var{x}, @var{n})
+## @deftypefn  {Function File} {@var{cmap} =} contrast (@var{x})
+## @deftypefnx {Function File} {@var{cmap} =} contrast (@var{x}, @var{n})
 ## Return a gray colormap that maximizes the contrast in an image.  The
 ## returned colormap will have @var{n} rows.  If @var{n} is not defined
 ## then the size of the current colormap is used.
 ## @seealso{colormap, brighten}
 ## @end deftypefn
 
-function map = contrast (x, n)
+function cmap = contrast (x, n)
 
   if (nargin == 1)
-    n = rows (colormap);
+    n = rows (colormap ());
   elseif (nargin == 2)
     if (! isscalar (n))
       error ("contrast: N must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   x = x(:);
   minx = min (x);
-  map = find (diff (sort ([round(n * ((x - minx) ./ (max(x) - minx))); [0:n]'])));
-  minm = min (map);
-  map = (map - minm) ./ (max (map) - minm);
-  map = [map, map, map];
+  cmap = find (diff (sort ([round(n * ((x - minx) ./ (max(x) - minx))); [0:n]'])));
+  minm = min (cmap);
+  cmap = (cmap - minm) ./ (max (cmap) - minm);
+  cmap = [cmap, cmap, cmap];
 
 endfunction
 
 
 %!demo
-%! clf;
+%! figure;
 %! img = reshape (1:100, 10, 10);
 %! imagesc (img);
 %! colormap (gray (64));
 %! title ("Image with default 64 gray levels");
 %! pos = get (gcf, "position");
-%! pos(1) += pos(3) + 15;
+%! pos(1) += pos(3) + 25;
 %! figure ("position", pos); 
 %! colormap (contrast (img, 10));
 %! imagesc (img);
 %! title ("Image with contrast enhanced");
 
 %!assert (contrast (1:100,10), [([0:9]/9)',([0:9]/9)',([0:9]/9)'], 1e-10)
 
diff --git a/scripts/image/cool.m b/scripts/image/cool.m
--- a/scripts/image/cool.m
+++ b/scripts/image/cool.m
@@ -31,17 +31,17 @@
 ## PKG_DEL: colormap ("unregister", "cool");
 
 function map = cool (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
-      error ("cool: argument must be a scalar");
+      error ("cool: N must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [0, 1, 1];
   elseif (n > 1)
diff --git a/scripts/image/copper.m b/scripts/image/copper.m
--- a/scripts/image/copper.m
+++ b/scripts/image/copper.m
@@ -32,17 +32,17 @@
 ## PKG_DEL: colormap ("unregister", "copper");
 
 function map = copper (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
-      error ("copper: argument must be a scalar");
+      error ("copper: N must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [0, 0, 0];
   elseif (n > 1)
diff --git a/scripts/image/flag.m b/scripts/image/flag.m
--- a/scripts/image/flag.m
+++ b/scripts/image/flag.m
@@ -32,17 +32,17 @@
 ## PKG_DEL: colormap ("unregister", "flag");
 
 function map = flag (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
-      error ("flag: argument must be a scalar");
+      error ("flag: N must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [1, 0, 0];
   elseif (n > 1)
diff --git a/scripts/image/gmap40.m b/scripts/image/gmap40.m
--- a/scripts/image/gmap40.m
+++ b/scripts/image/gmap40.m
@@ -32,17 +32,17 @@
 ## PKG_DEL: colormap ("unregister", "gmap40");
 
 function map = gmap40 (n)
 
   if (nargin == 0)
     n = 6;
   elseif (nargin == 1)
     if (! isscalar (n))
-      error ("gmap40: argument must be a scalar");
+      error ("gmap40: N must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n > 1)
     C = [1, 0, 0; 0, 1, 0; 0, 0, 1; 1, 1, 0; 1, 0, 1; 0, 1, 1];
     map = C(rem (0:(n-1), 6) + 1, :);
diff --git a/scripts/image/gray.m b/scripts/image/gray.m
--- a/scripts/image/gray.m
+++ b/scripts/image/gray.m
@@ -34,17 +34,17 @@
 ## PKG_DEL: colormap ("unregister", "gray");
 
 function map = gray (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
-      error ("gray: argument must be a scalar");
+      error ("gray: N must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [0, 0, 0];
   elseif (n > 1)
diff --git a/scripts/image/gray2ind.m b/scripts/image/gray2ind.m
--- a/scripts/image/gray2ind.m
+++ b/scripts/image/gray2ind.m
@@ -12,53 +12,98 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {[@var{img} =} gray2ind (@var{I})
-## @deftypefnx {Function File} {[@var{img} =} gray2ind (@var{I}, @var{n})
-## @deftypefnx {Function File} {[@var{img}, @var{map} =} gray2ind (@dots{})
-## Convert a gray scale intensity image to an Octave indexed image.
+## @deftypefn  {Function File} {@var{img} =} gray2ind (@var{I})
+## @deftypefnx {Function File} {@var{img} =} gray2ind (@var{I}, @var{n})
+## @deftypefnx {Function File} {@var{img} =} gray2ind (@var{BW})
+## @deftypefnx {Function File} {@var{img} =} gray2ind (@var{BW}, @var{n})
+## @deftypefnx {Function File} {[@var{img}, @var{map}] =} gray2ind (@dots{})
+## Convert a grayscale or binary intensity image to an indexed image.
+## 
 ## The indexed image will consist of @var{n} different intensity values.
-## If not given @var{n} defaults to 64.
-## @seealso{ind2gray, rgb2ind} 
+## If not given @var{n} defaults to 64 for grayscale images or 2 for
+## binary black and white images.
+##
+## The output @var{img} is of class uint8 if @var{n} is less than or
+## equal to 256; Otherwise the return class is uint16.
+## @seealso{ind2gray, rgb2ind}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
-function [X, map] = gray2ind (I, n = 64)
-  ## Check input
+function [I, map] = gray2ind (I, n = 64)
+
   if (nargin < 1 || nargin > 2)
     print_usage ();
-  endif
-  C = class (I);
-  if (! ismatrix (I) || ndims (I) != 2)
-    error ("gray2ind: first input argument must be a gray scale image");
+  elseif (! isreal (I) || issparse (I))
+    error ("gray2ind: I must be a grayscale or binary image");
+  elseif (! isscalar (n) || n < 1 || n > 65536)
+    error ("gray2ind: N must be a positive integer in the range [1, 65536]");
+  elseif (! ismatrix (I) || ndims (I) != 2)
+    error ("gray2ind: I must be a grayscale or binary image");
   endif
-  if (! isscalar (n) || n < 0)
-    error ("gray2ind: second input argument must be a positive integer");
+
+  ## default n is different if image is logical
+  if (nargin == 1 && islogical (I))
+    n = 2;
   endif
-  ints = {"uint8", "uint16", "int8", "int16"};
-  floats = {"double", "single"};
-  if (! ismember (C, {ints{:}, floats{:}}))
-    error ("gray2ind: invalid data type '%s'", C);
-  endif
-  if (ismember (C, floats) && (min (I(:)) < 0 || max (I(:)) > 1))
+
+  cls = class (I);
+  if (! any (strcmp (cls, {"logical", "uint8", "uint16", "int16", "single", "double"})))
+    error ("gray2ind: invalid data type '%s'", cls);
+  elseif (isfloat (I) && (min (I(:) < 0) || max (I(:) > 1)))
     error ("gray2ind: floating point images may only contain values between 0 and 1");
   endif
 
-  ## Convert data
   map = gray (n);
-  ## If @var{I} is an integer matrix convert it to a double matrix with values in [0, 1]
-  if (ismember (C, ints))
-    low = double (intmin (C));
-    high = double (intmax (C));
-    I = (double (I) - low) / (high - low);
+
+  ## Set up scale factor
+  if (isinteger (I))
+    low   = double (intmin (cls));
+    scale = double (intmax (cls)) - low;
+    I = double (I) - low;
+  else
+    scale = 1;
   endif
-  X = round (I*(n-1)) + 1;
+  I *= (n-1)/scale;
+
+  ## Note: no separate call to round () necessary because
+  ##       type conversion does that automatically.
+  if (n < 256)
+    I = uint8 (I);
+  else
+    I = uint16 (I);
+  endif
 
 endfunction
+
+
+%!assert (gray2ind ([0 0.25 0.5 1]), uint8 ([0 16 32 63]))
+%!assert (gray2ind ([0 0.25 0.5 1], 400), uint16 ([0 100 200 399]))
+%!assert (gray2ind (logical ([1 0 0 1])), uint8 ([1 0 0 1]))
+%!assert (gray2ind (uint8 ([0 64 128 192 255])), uint8 ([0 16 32 47 63]))
+
+%!test
+%! i2g = ind2gray (1:100, gray (100));
+%! g2i = gray2ind (i2g, 100);
+%! assert (g2i, uint8 (0:99));
+
+%% Test input validation
+%!error gray2ind ()
+%!error gray2ind (1,2,3)
+%!error <I must be a grayscale or binary image> gray2ind ({1})
+%!error <I must be a grayscale or binary image> gray2ind ([1+i])
+%!error <I must be a grayscale or binary image> gray2ind (sparse ([1]))
+%!error <N must be a positive integer> gray2ind (1, ones (2,2))
+%!error <N must be a positive integer> gray2ind (1, 0)
+%!error <N must be a positive integer> gray2ind (1, 65537)
+%!error <invalid data type> gray2ind (uint32 (1))
+%!error <values between 0 and 1> gray2ind (-1)
+%!error <values between 0 and 1> gray2ind (2)
+
diff --git a/scripts/image/hot.m b/scripts/image/hot.m
--- a/scripts/image/hot.m
+++ b/scripts/image/hot.m
@@ -32,17 +32,17 @@
 ## PKG_DEL: colormap ("unregister", "hot");
 
 function map = hot (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
-      error ("hot: argument must be a scalar");
+      error ("hot: N must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [1, 1, 1];
   elseif (n > 1)
diff --git a/scripts/image/hsv.m b/scripts/image/hsv.m
--- a/scripts/image/hsv.m
+++ b/scripts/image/hsv.m
@@ -36,17 +36,17 @@
 ## PKG_DEL: colormap ("unregister", "hsv");
 
 function map = hsv (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
-      error ("hsv: argument must be a scalar");
+      error ("hsv: N must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [1, 0, 0];
   elseif (n > 1)
diff --git a/scripts/image/hsv2rgb.m b/scripts/image/hsv2rgb.m
--- a/scripts/image/hsv2rgb.m
+++ b/scripts/image/hsv2rgb.m
@@ -16,16 +16,23 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{rgb_map} =} hsv2rgb (@var{hsv_map})
 ## @deftypefnx {Function File} {@var{rgb_img} =} hsv2rgb (@var{hsv_img})
 ## Transform a colormap or image from hue-saturation-value (HSV) space to
 ## red-green-blue (RGB) space.
+##
+## A color in HSV space is represented by hue, saturation and value
+## (brightness) levels.  Value gives the amount of light in the color.  Hue
+## describes the dominant wavelength.  Saturation is the amount of hue mixed
+## into the color.
+##
+## A color in the RGB space consists of red, green, and blue intensities.
 ## @seealso{rgb2hsv, ind2rgb, ntsc2rgb}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
 function rgb_map = hsv2rgb (hsv_map)
 
@@ -33,57 +40,90 @@ function rgb_map = hsv2rgb (hsv_map)
   ## x = (1-sat)*val+sat*val*f_x(hue)
   ## where f_x(hue) is a piecewise defined function for
   ## each color with f_r(hue-2/3) = f_g(hue) = f_b(hue-1/3).
 
   if (nargin != 1)
     print_usage ();
   endif
 
+  cls = class (hsv_map);
+  if (! any (strcmp (cls, {"uint8", "uint16", "single", "double"})))
+    error ("hsv2rgb: invalid data type '%s'", cls);
+  elseif (isfloat (hsv_map) && (any (hsv_map(:) < 0) || any (hsv_map(:) > 1)))
+    error ("hsv2rgb: floating point images may only contain values between 0 and 1");
+  endif
+
   ## If we have an image convert it into a color map.
-  if (ismatrix (hsv_map) && ndims (hsv_map) == 3)
+  if (isreal (hsv_map) && ndims (hsv_map) == 3)
     is_image = true;
-    Sz = size (hsv_map);
+    sz = size (hsv_map);
     hsv_map = [hsv_map(:,:,1)(:), hsv_map(:,:,2)(:), hsv_map(:,:,3)(:)];
     ## Convert to a double image.
     if (isinteger (hsv_map))
-      C = class (hsv_map);
-      low = double (intmin (C));
-      high = double (intmax (C));
+      low = double (intmin (cls));
+      high = double (intmax (cls));
       hsv_map = (double (hsv_map) - low) / (high - low);
     endif
   else
     is_image = false;
   endif
 
-  if (! ismatrix (hsv_map) || columns (hsv_map) != 3)
-    error ("hsv2rgb: argument must be a matrix of size nx3");
+  if (! isreal (hsv_map) || columns (hsv_map) != 3 || issparse (hsv_map))
+    error ("hsv2rgb: input must be a matrix of size Nx3 or MxNx3");
   endif
 
-  ## set values <0 to 0 and >1 to 1
-  hsv_map = (hsv_map >= 0 & hsv_map <= 1) .* hsv_map ...
-      + (hsv_map < 0) .* 0 + (hsv_map > 1);
-
-  ## fill rgb map with v*(1-s)
-  rgb_map = kron ([1, 1, 1], hsv_map(:,3) .* (1 - hsv_map(:,2)));
+  ## FIXME: Currently input is validated and an error results if values
+  ##        are outside range [0, 1].  We could also simply allow those values
+  ##        and re-instate this code to produce saturating semantics.
+  ## Trim map to range [0, 1]
+  #hsv_map(hsv_map < 0) = 0;
+  #hsv_map(hsv_map > 1) = 1;
 
-  ## red(hue-2/3)=green(hue)=blue(hue-1/3)
-  ## apply modulo 1 for red and blue
-  t = hsv_map(:,1);
-  tp = t';
-  hue = [(tp - 2/3 - floor (t - 2/3)');
-         tp;
-         (tp - 1/3 - floor (t - 1/3)')]';
+  h = hsv_map(:,1);
+  s = hsv_map(:,2);
+  v = hsv_map(:,3);
+  ## Prefill rgb map with v*(1-s)
+  rgb_map = repmat (v .* (1 - s), 1, 3);
+
+  ## red = hue-2/3 : green = hue : blue = hue-1/3
+  ## Apply modulo 1 for red and blue to keep within range [0, 1]
+  hue = [mod(h - 2/3, 1), h , mod(h - 1/3, 1)];
 
   ## factor s*v -> f
-  f = kron ([1, 1, 1], hsv_map(:,2)) .* kron ([1, 1, 1], hsv_map(:,3));
+  f = repmat (s .* v, 1, 3);
 
-  ## add s*v* hue-function to rgb map
-  rgb_map = rgb_map +  f .* (6 * (hue < 1/6) .* hue
-                    + (hue >= 1/6 & hue < 1/2)
-                    + (hue >= 1/2 & hue < 2/3) .* (4 - 6 * hue));
+  ## add s*v*hue-function to rgb map
+  rgb_map += f .* (6 * (hue < 1/6) .* hue
+             + (hue >= 1/6 & hue < 1/2)
+             + (hue >= 1/2 & hue < 2/3) .* (4 - 6 * hue));
 
+  ## FIXME: hsv2rgb does not preserve class of image.
+  ##        Should it also convert back to uint8, uint16 for integer images?
   ## If input was an image, convert it back into one.
   if (is_image)
-    rgb_map = reshape (rgb_map, Sz);
+    rgb_map = reshape (rgb_map, sz);
   endif
 
 endfunction
+
+
+%% Test pure colors
+%!assert (hsv2rgb ([0 1 1]), [1 0 0])
+%!assert (hsv2rgb ([1 1 1]), [1 0 0])
+%!assert (hsv2rgb ([1/3 1 1]), [0 1 0])
+%!assert (hsv2rgb ([2/3 1 1]), [0 0 1])
+
+%!test
+%! hsv_map = rand (64, 3);
+%! assert (rgb2hsv (hsv2rgb (hsv_map)), hsv_map, 1e-6);
+
+%!test
+%! hsv_img = rand (64, 64, 3);
+%! assert (rgb2hsv (hsv2rgb (hsv_img)), hsv_img, 1e-6);
+
+%% Test input validation
+%!error hsv2rgb ()
+%!error hsv2rgb (1,2)
+%!error <invalid data type> hsv2rgb ({1})
+%!error <must be a matrix of size Nx3> hsv2rgb (ones (2,2))
+%!error <must be a matrix of size Nx3> hsv2rgb (sparse (ones(1,3)))
+
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -14,85 +14,80 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} image (@var{img})
 ## @deftypefnx {Function File} {} image (@var{x}, @var{y}, @var{img})
+## @deftypefnx {Function File} {} image (@dots{}, "@var{property}", @var{value}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} image (@dots{})
-## Display a matrix as a color image.
+## Display a matrix as an indexed color image.
 ##
 ## The elements of @var{img} are indices into the current colormap.
-## The axis values corresponding to the matrix elements are specified in
-## @var{x} and @var{y}.  If you are using gnuplot 4.1 or earlier, these
-## variables are ignored.
+## @var{x} and @var{y} are optional 2-element vectors, @w{@code{[min, max]}},
+## which specify the range for the axis labels.  If a range is specified as
+## @w{@code{[max, min]}} then the image will be reversed along that axis.  For
+## convenience, @var{x} and @var{y} may be specified as N-element vectors
+## matching the length of the data in @var{img}.  However, only the first and
+## last elements will be used to determine the axis limits.
+## @strong{Warning:} @var{x} and @var{y} are ignored when using gnuplot 4.0
+## or earlier.
 ##
 ## The optional return value @var{h} is a graphics handle to the image.
 ##
 ## Implementation Note: The origin (0, 0) for images is located in the
 ## upper left.  For ordinary plots, the origin is located in the lower
 ## left.  Octave handles this inversion by plotting the data normally,
 ## and then reversing the direction of the y-axis by setting the
 ## @code{ydir} property to "reverse".  This has implications whenever
 ## an image and an ordinary plot need to be overlaid.  The recommended
 ## solution is to display the image and then plot the reversed ydata
-## using, for example, @code{flipud (ydata,1)}.
+## using, for example, @code{flipud (ydata)}.
 ##
 ## @seealso{imshow, imagesc, colormap}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
-function retval = image (varargin)
+function h = image (varargin)
 
   [ax, varargin, nargin] = __plt_get_axis_arg__ ("image", varargin{:});
 
-  firstnonnumeric = Inf;
-  for i = 1 : nargin
-    if (! isnumeric (varargin{i}))
-      firstnonnumeric = i;
-      break;
-    endif
-  endfor
-
-  if (nargin == 0 || firstnonnumeric == 1)
+  chararg = find (cellfun ("isclass", varargin, "char"), 1, "first");
+  
+  if (nargin == 0 || chararg == 1)
     img = imread ("default.img");
     x = y = [];
-  elseif (nargin == 1 || firstnonnumeric == 2)
+  elseif (nargin == 1 || chararg == 2)
     img = varargin{1};
     x = y = [];
-  elseif (nargin == 2 || firstnonnumeric == 3)
+  elseif (nargin == 2 || chararg == 3)
     print_usage ();
   else
     x = varargin{1};
     y = varargin{2};
     img = varargin{3};
-    firstnonnumeric = 4;
-  endif
-
-  if (iscomplex (img))
-    warning ("image: only showing real part of complex image");
-    img = real (img);
+    chararg = 4;
   endif
 
   oldax = gca ();
   unwind_protect
     axes (ax);
-    h = __img__ (x, y, img, varargin {firstnonnumeric:end});
+    htmp = __img__ (x, y, img, varargin{chararg:end});
     set (ax, "layer", "top");
   unwind_protect_cleanup
     axes (oldax);
   end_unwind_protect
 
   if (nargout > 0)
-    retval = h;
+    h = htmp;
   endif
 
 endfunction
 
 ## Generic image creation.
 ##
 ## The axis values corresponding to the matrix elements are specified in
 ## @var{x} and @var{y}.  If you're not using gnuplot 4.2 or later, these
@@ -105,144 +100,110 @@ endfunction
 function h = __img__ (x, y, img, varargin)
   
   newplot ();
 
   if (isempty (img))
     error ("__img__: matrix is empty");
   endif
 
+  ## FIXME: Hack for integer formats which use zero-based indexing
+  ##        Hack favors correctness of display over size of image in memory.
+  ##        True fix will be done in C++ code. 
+  if (ndims (img) == 2 && (isinteger (img) || islogical (img)))
+    img = single (img) + 1;
+  endif
+
   if (isempty (x))
     x = [1, columns(img)];
   endif
 
   if (isempty (y))
     y = [1, rows(img)];
   endif
 
-  xdata = [x(1), x(end)];
-  ydata = [y(1), y(end)];
+  xdata = x([1, end]);
+  ydata = y([1, end]);
 
-  dx = diff (x);
-  dy = diff (y);
-  dx = std (dx) / mean (abs (dx));
-  dy = std (dy) / mean (abs (dy));
-  tol = 100*eps;
-  if (any (dx > tol) || any (dy > tol))
-    warning ("Image does not map to non-linearly spaced coordinates");
+  if (numel (x) > 2 && numel (y) > 2)
+    ## Test data for non-linear spacing which is unsupported
+    ## FIXME: Need a better check on linearity
+    tol = 100*eps;
+    dx = diff (x);
+    dy = diff (y);
+    dx = std (dx) / mean (abs (dx));
+    dy = std (dy) / mean (abs (dy));
+    if (any (dx > tol) || any (dy > tol))
+      warning ("image: non-linear X, Y data is ignored.  IMG will be shown with linear mapping");
+    endif
   endif
 
   ca = gca ();
 
-  tmp = __go_image__ (ca, "cdata", img, "xdata", xdata, "ydata", ydata,
-                    "cdatamapping", "direct", varargin {:});
+  htmp = __go_image__ (ca, "cdata", img, "xdata", xdata, "ydata", ydata,
+                       "cdatamapping", "direct", varargin {:});
 
-  px = __image_pixel_size__ (tmp);
+  px = __image_pixel_size__ (htmp);
 
   if (xdata(2) < xdata(1))
-    xdata = xdata(2:-1:1);
+    xdata = fliplr (xdata);
   elseif (xdata(2) == xdata(1))
     xdata = xdata(1) + [0, columns(img)-1];
   endif
   if (ydata(2) < ydata(1))
-    ydata = ydata(2:-1:1);
+    ydata = fliplr (ydata);
   elseif (ydata(2) == ydata(1))
     ydata = ydata(1) + [0, rows(img)-1];
   endif
   xlim = xdata + [-px(1), px(1)];
   ylim = ydata + [-px(2), px(2)];
 
   ## FIXME -- how can we do this and also get the {x,y}limmode
   ## properties to remain "auto"?  I suppose this adjustment should
   ## happen automatically in axes::update_axis_limits instead of
   ## explicitly setting the values here.  But then what information is
   ## available to axes::update_axis_limits to determine that the
   ## adjustment is necessary?
   set (ca, "xlim", xlim, "ylim", ylim);
 
   if (ndims (img) == 3)
     if (isinteger (img))
-      c = class (img);
-      mn = intmin (c);
-      mx = intmax (c);
+      cls = class (img);
+      mn = intmin (cls);
+      mx = intmax (cls);
       set (ca, "clim", double ([mn, mx]));
     endif
   endif
 
   set (ca, "view", [0, 90]);
 
   if (strcmp (get (ca, "nextplot"), "replace"))
     # Always reverse y-axis for images, unless hold is on
     set (ca, "ydir", "reverse");
   endif
 
   if (nargout > 0)
-    h = tmp;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
-%! colormap ("default");
+%! colormap (jet (21));
 %! img = 1 ./ hilb (11);
-%! x = -5:5;
-%! y = x;
+%! x = y = -5:5;
 %! subplot (2,2,1);
-%!  h = image (abs(x), abs(y), img);
-%!  set (h, "cdatamapping", "scaled");
-%!  ylabel ("limits = [4.5, 15.5]");
-%!  title ("image (abs(x), abs(y), img)");
+%!  h = image (x, y, img);
+%!  ylabel ("limits = [-5.5, 5.5]");
+%!  title ("image (x, y, img)");
 %! subplot (2,2,2);
 %!  h = image (-x, y, img);
-%!  set (h, "cdatamapping", "scaled");
 %!  title ("image (-x, y, img)");
 %! subplot (2,2,3);
 %!  h = image (x, -y, img);
-%!  set (h, "cdatamapping", "scaled");
 %!  title ("image (x, -y, img)");
 %!  ylabel ("limits = [-5.5, 5.5]");
 %! subplot (2,2,4);
 %!  h = image (-x, -y, img);
-%!  set (h, "cdatamapping", "scaled");
 %!  title ("image (-x, -y, img)");
 
-%!demo
-%! clf;
-%! colormap ("default");
-%! g = 0.1:0.1:10;
-%! h = g'*g;
-%! imagesc (g, g, sin (h));
-%! hold on;
-%! imagesc (g, g+12, cos (h/2));
-%! axis ([0 10 0 22]);
-%! hold off;
-%! title ("two consecutive images");
-
-%!demo
-%! clf;
-%! colormap ("default");
-%! g = 0.1:0.1:10;
-%! h = g'*g;
-%! imagesc (g, g, sin (h));
-%! hold all;
-%! plot (g, 11.0 * ones (size (g)));
-%! imagesc (g, g+12, cos (h/2));
-%! axis ([0 10 0 22]);
-%! hold off;
-%! title ("image, line, image");
-
-%!demo
-%! clf;
-%! colormap ("default");
-%! g = 0.1:0.1:10;
-%! h = g'*g;
-%! plot (g, 10.5 * ones (size (g)));
-%! hold all;
-%! imagesc (g, g, sin (h));
-%! plot (g, 11.0 * ones (size (g)));
-%! imagesc (g, g+12, cos (h/2));
-%! plot (g, 11.5 * ones (size (g)));
-%! axis ([0 10 0 22]);
-%! hold off;
-%! title ("line, image, line, image, line");
-
diff --git a/scripts/image/imagesc.m b/scripts/image/imagesc.m
--- a/scripts/image/imagesc.m
+++ b/scripts/image/imagesc.m
@@ -12,110 +12,143 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} imagesc (@var{A})
-## @deftypefnx {Function File} {} imagesc (@var{x}, @var{y}, @var{A})
-## @deftypefnx {Function File} {} imagesc (@dots{}, @var{limits})
+## @deftypefn  {Function File} {} imagesc (@var{img})
+## @deftypefnx {Function File} {} imagesc (@var{x}, @var{y}, @var{img})
+## @deftypefnx {Function File} {} imagesc (@dots{}, @var{climits})
 ## @deftypefnx {Function File} {} imagesc (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} imagesc (@dots{})
-## Display a scaled version of the matrix @var{A} as a color image.  The
+## Display a scaled version of the matrix @var{img} as a color image.  The
 ## colormap is scaled so that the entries of the matrix occupy the entire
-## colormap.  If @var{limits} = [@var{lo}, @var{hi}] are given, then that
+## colormap.  If @code{@var{climits} = [@var{lo}, @var{hi}]} is given, then that
 ## range is set to the "clim" of the current axes.
 ##
 ## The axis values corresponding to the matrix elements are specified in
 ## @var{x} and @var{y}, either as pairs giving the minimum and maximum
 ## values for the respective axes, or as values for each row and column
-## of the matrix @var{A}.
+## of the matrix @var{img}.
 ##
 ## The optional return value @var{h} is a graphics handle to the image.
 ## @seealso{image, imshow, caxis}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
-function retval = imagesc (varargin)
+function h = imagesc (varargin)
 
-  if (nargin < 1)
+  if (nargin < 1 || nargin > 4)
     print_usage ();
   elseif (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin{1};
-    if (! strcmp (get (h, "type"), "axes"))
+    harg = varargin{1};
+    if (! strcmp (get (harg, "type"), "axes"))
       error ("imagesc: expecting first argument to be an axes object");
     endif
     oldh = gca ();
     unwind_protect
       axes (h);
-      tmp = __imagesc__ (h, varargin{2:end});
+      htmp = __imagesc__ (harg, varargin{2:end});
     unwind_protect_cleanup
       axes (oldh);
     end_unwind_protect
   else
-    tmp = __imagesc__ (gca (), varargin{:});
+    htmp = __imagesc__ (gca (), varargin{:});
   endif
 
   if (nargout > 0)
-    retval = tmp;
+    h = htmp;
+  endif
+
+endfunction
+
+function h = __imagesc__ (ax, x, y, img, climits)
+
+  if (nargin == 2)
+    img = x;
+    x = y = climits = [];
+  elseif (nargin == 3)
+    img = x;
+    climits = y;
+    x = y = [];
+  elseif (nargin == 4 && ! isscalar (x) && ! isscalar (y) && ! isscalar (img))
+    climits = [];
+  endif
+
+  h = image (ax, x, y, img);
+  set (h, "cdatamapping", "scaled");
+
+  ## use given climits or guess them from the matrix
+  if (numel (climits) == 2 && climits(1) <= climits(2))
+    set (ax, "clim", climits);
+  elseif (! isempty (climits))
+    error ("imagesc: CLIMITS must be in form [lo, hi]");
   endif
 
 endfunction
 
-function ret = __imagesc__ (ax, x, y, A, limits, DEPRECATEDZOOM)
+
+%!demo
+%! clf;
+%! colormap ("default");
+%! img = 1 ./ hilb (11);
+%! x = y = -5:5;
+%! subplot (2,2,1);
+%!  h = imagesc (x, y, img);
+%!  ylabel ("limits = [-5.5, 5.5]");
+%!  title ("imagesc (x, y, img)");
+%! subplot (2,2,2);
+%!  h = imagesc (-x, y, img);
+%!  title ("imagesc (-x, y, img)");
+%! subplot (2,2,3);
+%!  h = imagesc (x, -y, img);
+%!  title ("imagesc (x, -y, img)");
+%!  ylabel ("limits = [-5.5, 5.5]");
+%! subplot (2,2,4);
+%!  h = imagesc (-x, -y, img);
+%!  title ("imagesc (-x, -y, img)");
 
-  ## Deprecated zoom.  Remove this hunk of code if old zoom argument
-  ## is outmoded.
-  if ((nargin == 3 && isscalar (y))
-      || (nargin == 4 && (isscalar (y) || isscalar (A)))
-      || (nargin == 5 && isscalar (limits))
-      || nargin == 6)
-    warning ("image: zoom argument ignored -- use GUI features");
-  endif
-  if (nargin == 6)
-    if (isscalar (limits))
-      limits = DEPRECATEDZOOM;
-    endif
-    nargin = 5;
-  endif
-  if (nargin == 5 && isscalar (limits))
-    nargin = 4;
-  endif
-  if (nargin == 4 && (isscalar (y) || isscalar (A)))
-    if (isscalar (y))
-      y = A;
-    endif
-    nargin = 3;
-  endif
-  if (nargin == 3 && isscalar (y))
-    nargin = 2;
-  endif
+%!demo
+%! clf;
+%! colormap ("default");
+%! g = 0.1:0.1:10;
+%! h = g'*g;
+%! imagesc (g, g, sin (h));
+%! hold on;
+%! imagesc (g, g+12, cos (h/2));
+%! axis ([0 10 0 22]);
+%! hold off;
+%! title ("two consecutive images");
 
-  if (nargin < 2 || nargin > 5)
-    print_usage ();
-  elseif (nargin == 2)
-    A = x;
-    x = y = limits = [];
-  elseif (nargin == 3)
-    A = x;
-    limits = y;
-    x = y = [];
-  elseif (nargin == 4 && ! isscalar (x) && ! isscalar (y) && ! isscalar (A))
-    limits = [];
-  endif
+%!demo
+%! clf;
+%! colormap ("default");
+%! g = 0.1:0.1:10;
+%! h = g'*g;
+%! imagesc (g, g, sin (h));
+%! hold all;
+%! plot (g, 11.0 * ones (size (g)));
+%! imagesc (g, g+12, cos (h/2));
+%! axis ([0 10 0 22]);
+%! hold off;
+%! title ("image, line, image");
 
-  ret = image (ax, x, y, A);
-  set (ret, "cdatamapping", "scaled");
+%!demo
+%! clf;
+%! colormap ("default");
+%! g = 0.1:0.1:10;
+%! h = g'*g;
+%! plot (g, 10.5 * ones (size (g)));
+%! hold all;
+%! imagesc (g, g, sin (h));
+%! plot (g, 11.0 * ones (size (g)));
+%! imagesc (g, g+12, cos (h/2));
+%! plot (g, 11.5 * ones (size (g)));
+%! axis ([0 10 0 22]);
+%! hold off;
+%! title ("line, image, line, image, line");
 
-  ## use given limits or guess them from the matrix
-  if (length (limits) == 2 && limits(2) >= limits(1))
-    set (ax, "clim", limits);
-  elseif (! isempty (limits))
-    error ("imagesc: expected data LIMITS to be [lo, hi]");
-  endif
-
-endfunction
diff --git a/scripts/image/imfinfo.m b/scripts/image/imfinfo.m
--- a/scripts/image/imfinfo.m
+++ b/scripts/image/imfinfo.m
@@ -66,60 +66,58 @@
 ## Time in 1/100ths of a second (0 to 65535) which must expire before displaying
 ## the next image in an animated sequence.
 ##
 ## @item AnimationIterations
 ## Number of iterations to loop an animation (e.g., Netscape loop extension)
 ## for.
 ##
 ## @item ByteOrder
-## Endian option for formats that support it.  Is either @code{"little-endian"},
+## Endian option for formats that support it.  Value is @code{"little-endian"},
 ## @code{"big-endian"}, or @code{"undefined"}.
 ##
 ## @item Gamma
 ## Gamma level of the image.  The same color image displayed on two different
 ## workstations may look different due to differences in the display monitor.
 ##
 ## @item Matte
 ## @code{true} if the image has transparency.
 ##
 ## @item ModulusDepth
 ## Image modulus depth (minimum number of bits required to support
-## red/green/blue
-## components without loss of accuracy).
+## red/green/blue components without loss of accuracy).
 ##
 ## @item Quality
 ## JPEG/MIFF/PNG compression level.
 ##
 ## @item QuantizeColors
 ## Preferred number of colors in the image.
 ##
 ## @item ResolutionUnits
-## Units of image resolution.  Is either @code{"pixels per inch"},
+## Units of image resolution.  Value is @code{"pixels per inch"},
 ## @code{"pixels per centimeter"}, or @code{"undefined"}.
 ##
 ## @item ColorType
-## Image type.  Is either @code{"grayscale"}, @code{"indexed"},
-## @code{"truecolor"},
-## or @code{"undefined"}.
+## Image type.  Value is @code{"grayscale"}, @code{"indexed"},
+## @code{"truecolor"}, or @code{"undefined"}.
 ##
 ## @item View
 ## FlashPix viewing parameters.
 ## @end table
 ##
-## @seealso{imread, imwrite}
+## @seealso{imread, imwrite, imshow}
 ## @end deftypefn
 
 function info = imfinfo (filename)
 
   if (nargin < 1)
     print_usage ();
   endif
 
-  if (!ischar (filename))
+  if (! ischar (filename))
     error ("imfinfo: FILENAME must be a string");
   endif
 
   filename = tilde_expand (filename);
 
   delete_file = false;
 
   unwind_protect
diff --git a/scripts/image/imwrite.m b/scripts/image/imwrite.m
--- a/scripts/image/imwrite.m
+++ b/scripts/image/imwrite.m
@@ -130,17 +130,17 @@ function imwrite (img, varargin)
   map_class = class (map);
   nd = ndims (img);
 
   if (isempty (map))
     if (any (strcmp (img_class, {"logical", "uint8", "uint16", "double"})))
       if ((nd == 2 || nd == 3) && strcmp (img_class, "double"))
         img = uint8 (img * 255);
       endif
-      ## FIXME -- should we handle color images w/ alpha channel here?
+      ## FIXME: should we handle color images with alpha channel here?
       if (nd == 3 && size (img, 3) < 3)
         error ("imwrite: invalid dimensions for truecolor image");
       endif
       if (nd > 5)
         error ("imwrite: invalid %d-dimensional image data", nd);
       endif
     else
       error ("imwrite: %s: invalid class for truecolor image", img_class);
@@ -160,18 +160,18 @@ function imwrite (img, varargin)
       endif
     else
       error ("imwrite: %s: invalid class for indexed image data", img_class);
     endif
     if (! iscolormap (map))
       error ("imwrite: invalid indexed image colormap");
     endif
 
-    ## FIXME -- we should really be writing indexed images here but
-    ## __magick_write__ needs to be fixed to handle them.
+    ## FIXME: we should really be writing indexed images here but
+    ##        __magick_write__ needs to be fixed to handle them.
 
     [r, g, b] = ind2rgb (img, map);
     tmp = uint8 (cat (3, r, g, b) * 255);
 
     if (has_param_list)
       __magick_write__ (filename, fmt, tmp, options);
       ## __magick_write__ (filename, fmt, img, map, options);
     else
diff --git a/scripts/image/ind2gray.m b/scripts/image/ind2gray.m
--- a/scripts/image/ind2gray.m
+++ b/scripts/image/ind2gray.m
@@ -12,39 +12,79 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} ind2gray (@var{x})
-## @deftypefnx {Function File} {} ind2gray (@var{x}, @var{map})
-## Convert a color indexed image to a gray scale intensity image.
-## If @var{map} is omitted, the current colormap is used to determine the
-## intensities.
+## @deftypefn {Function File} {@var{I} =} ind2gray (@var{x}, @var{map})
+## Convert a color indexed image to a grayscale intensity image.
+##
+## The image @var{x} must be an indexed image which will be converted using the
+## colormap @var{cmap}.  If @var{cmap} does not contain enough colors for the
+## image, pixels in @var{x} outside the range are mapped to the last color in
+## the map before conversion to grayscale.
+##
+## The output @var{I} is of the same class as the input @var{x} and may be
+## one of @code{uint8}, @code{uint16}, @code{single}, or @code{double}.
+##
+## Implementation Note: There are several ways of converting colors to
+## grayscale intensities.  This functions uses the luminance value obtained
+## from @code{rgb2ntsc} which is @code{I = 0.299*R + 0.587*G + 0.114*B}.  
+## Other possibilities include the value component from @code{rgb2hsv} or
+## using a single color channel from @code{ind2rgb}.
 ## @seealso{gray2ind, ind2rgb}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
-function y = ind2gray (x, map)
+function I = ind2gray (x, map)
+
+  if (nargin != 2)
+    print_usage ();
+  endif
+  [x, map] = ind2x ("ind2gray", x, map);
+
+  ## Convert colormap to luminance intensity values 
+  map *= [0.29894; 0.58704; 0.11402];
 
-  if (nargin < 1 || nargin > 2)
-    print_usage ();
-  elseif (nargin == 1)
-    map = colormap ();
+  ## Convert colormap to same class as that of input so that reshape
+  ## will produce output of the same type as the input.
+  cls = class (x);
+  if (isinteger (x))
+    ## if we later add support for int16 images, this will not work. Look into
+    ## im2int16 from image package for such case
+    map *= intmax (cls);
+  elseif (strcmp (cls, "single"))
+    map = single (map);
   endif
 
-  [rows, cols] = size (x);
-
-  ## Convert colormap to intensity values (the first column of the
-  ## result of the call to rgb2ntsc) and then replace indices in
-  ## the input matrix with indexed values in the output matrix (indexed
-  ## values are the result of indexing the intensity values by the
-  ## elements of x(:)).
-
-  y = reshape (((rgb2ntsc (map))(:,1))(x(:)), rows, cols);
+  ## Replace indices in the input matrix with the indexed luminance value.
+  I = reshape (map(x(:)), size (x));
 
 endfunction
+
+
+%!shared i2g
+%! i2g = ind2gray (1:100, gray (100));
+%!assert (i2g, 0:1/99:1, eps);
+%!assert (gray2ind (i2g, 100), uint8 (0:99));
+
+%% Test input validation
+%!error ind2gray ()
+%!error ind2gray (1)
+%!error ind2gray (1,2,3)
+%!error <X must be an indexed image> ind2gray ({1}, jet (64))
+%!error <X must be an indexed image> ind2gray (1+i, jet (64))
+%!error <X must be an indexed image> ind2gray (sparse (1), jet (64))
+%!error <X must be an indexed image> ind2gray (0, jet (64))
+%!error <X must be an indexed image> ind2gray (1.1, jet (64))
+%!error <MAP must be a valid colormap> ind2gray (1, {1})
+%!error <MAP must be a valid colormap> ind2gray (1, 1+i)
+%!error <MAP must be a valid colormap> ind2gray (1, ones (2,2,2))
+%!error <MAP must be a valid colormap> ind2gray (1, ones (2,4))
+%!error <MAP must be a valid colormap> ind2gray (1, [-1])
+%!error <MAP must be a valid colormap> ind2gray (1, [2])
+
diff --git a/scripts/image/ind2rgb.m b/scripts/image/ind2rgb.m
--- a/scripts/image/ind2rgb.m
+++ b/scripts/image/ind2rgb.m
@@ -12,62 +12,88 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{rgb} =} ind2rgb (@var{x})
-## @deftypefnx {Function File} {@var{rgb} =} ind2rgb (@var{x}, @var{map})
-## @deftypefnx {Function File} {[@var{R}, @var{G}, @var{B}] =} ind2rgb (@dots{})
+## @deftypefn  {Function File} {@var{rgb} =} ind2rgb (@var{x}, @var{map})
+## @deftypefnx {Function File} {[@var{R}, @var{G}, @var{B}] =} ind2rgb (@var{x}, @var{map})
 ## Convert an indexed image to red, green, and blue color components.
-## If the colormap doesn't contain enough colors, pad it with the
-## last color in the map.
-## If @var{map} is omitted, the current colormap is used for the conversion.
+##
+## The image @var{x} must be an indexed image which will be converted using the
+## colormap @var{map}.  If @var{map} does not contain enough colors for the
+## image, pixels in @var{x} outside the range are mapped to the last color in
+## the map.
+##
+## The output may be a single RGB image (MxNx3 matrix where M and N are the
+## original image @var{x} dimensions, one for each of the red, green and blue
+## channels).  Alternatively, the individual red, green, and blue color matrices
+## of size MxN may be returned.
+##
 ## @seealso{rgb2ind, ind2gray, hsv2rgb, ntsc2rgb}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function [R, G, B] = ind2rgb (x, map)
 
-  ## Do we have the right number of inputs?
-  if (nargin < 1 || nargin > 2)
+  if (nargin != 2)
     print_usage ();
-  elseif (nargin == 1)
-    map = colormap ();
-  endif
-
-  ## Check if X is an indexed image.
-  if (ndims (x) != 2 || any (x(:) != fix (x(:))) || min (x(:)) < 1)
-    error ("ind2rgb: X must be an indexed image");
   endif
-
-  ## Check the color map.
-  if (! iscolormap (map))
-    error ("ind2rgb: MAP must be a valid colormap");
-  endif
-
-  ## Do we have enough colors in the color map?
-  maxidx = max (x(:));
-  rm = rows (map);
-  if (rm < maxidx)
-    ## Pad with the last color in the map.
-    pad = repmat (map(end,:), maxidx-rm, 1);
-    map(end+1:maxidx, :) = pad;
-  endif
+  [x, map] = ind2x ("ind2rgb", x, map);
 
   ## Compute result
-  [hi, wi] = size (x);
-  R = reshape (map (x(:), 1), hi, wi);
-  G = reshape (map (x(:), 2), hi, wi);
-  B = reshape (map (x(:), 3), hi, wi);
+  [row, col] = size (x);
+  R = reshape (map(x(:), 1), row, col);
+  G = reshape (map(x(:), 2), row, col);
+  B = reshape (map(x(:), 3), row, col);
 
   ## Use 3D array if only one output is requested.
   if (nargout <= 1)
+    R(:,:,2) = G;
     R(:,:,3) = B;
-    R(:,:,2) = G;
   endif
+
 endfunction
+
+
+%!shared img, map, ergb, rgb, r, g, b
+%! img = [2 4 5; 3 2 5; 1 2 4];
+%! map = [0.0  0.0  0.0
+%!        0.2  0.4  0.6
+%!        0.4  0.4  0.5
+%!        0.3  0.7  1.0
+%!        0.1  0.5  0.8];
+%! ergb(:,:,1) = [0.2 0.3 0.1; 0.4 0.2 0.1; 0.0 0.2 0.3];
+%! ergb(:,:,2) = [0.4 0.7 0.5; 0.4 0.4 0.5; 0.0 0.4 0.7];
+%! ergb(:,:,3) = [0.6 1.0 0.8; 0.5 0.6 0.8; 0.0 0.6 1.0];
+%! ## test basic usage with 1 and 3 outputs
+%! [rgb] = ind2rgb (img, map);
+%! [r, g, b] = ind2rgb (img, map);
+%!assert (ergb, rgb);
+%!assert (ergb, reshape ([r(:) g(:) b(:)], [size(img) 3]));
+%! ## test correction for integers
+%! img = uint8 (img -1);
+%! [rgb] = ind2rgb (img, map);
+%!assert (ergb, rgb);
+%! ## check it fails when image is a float with an index value of 0
+%!fail ("[rgb] = ind2rgb (double(img), map)")
+
+%% Test input validation
+%!error ind2rgb ()
+%!error ind2rgb (1,2,3)
+%!error <X must be an indexed image> ind2rgb ({1}, jet (64))
+%!error <X must be an indexed image> ind2rgb (1+i, jet (64))
+%!error <X must be an indexed image> ind2rgb (sparse (1), jet (64))
+%!error <X must be an indexed image> ind2rgb (0, jet (64))
+%!error <X must be an indexed image> ind2rgb (1.1, jet (64))
+%!error <MAP must be a valid colormap> ind2rgb (1, {1})
+%!error <MAP must be a valid colormap> ind2rgb (1, 1+i)
+%!error <MAP must be a valid colormap> ind2rgb (1, ones (2,2,2))
+%!error <MAP must be a valid colormap> ind2rgb (1, ones (2,4))
+%!error <MAP must be a valid colormap> ind2rgb (1, [-1])
+%!error <MAP must be a valid colormap> ind2rgb (1, [2])
+
diff --git a/scripts/image/iscolormap.m b/scripts/image/iscolormap.m
--- a/scripts/image/iscolormap.m
+++ b/scripts/image/iscolormap.m
@@ -15,38 +15,39 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} iscolormap (@var{cmap})
 ## Return true if @var{cmap} is a colormap.
 ##
-## A colormap is an @var{n} row by 3 column matrix.  The columns contain red,
-## green, and blue intensities respectively.  All entries must be between 0
-## and 1 inclusive.
-##
+## A colormap is a real matrix with @var{n} rows and 3 columns.
+## Each row represents a single color.  The columns contain red, green,
+## and blue intensities respectively.  All entries must be between 0 and 1
+## inclusive.
 ## @seealso{colormap, rgbplot}
 ## @end deftypefn
 
 ## Author: Carnë Draug <carandraug+dev@gmail.com>
 
 function retval = iscolormap (cmap)
 
   if (nargin != 1)
     print_usage;
   endif
 
   retval = (isnumeric (cmap) && isreal (cmap) &&
-            columns (cmap) == 3 && ndims (cmap) == 2 && isa (cmap, "double") &&
+            ndims (cmap) == 2 && columns (cmap) == 3 && isa (cmap, "double") &&
             min (cmap(:)) >= 0 && max (cmap(:)) <= 1);
 
 endfunction
 
 
 %!assert (iscolormap (jet (64)))
 %!assert (iscolormap ({0 1 0}), false)
 %!assert (iscolormap ([0 1i 0]), false)
+%!assert (iscolormap (ones (3,3,3)), false)
 %!assert (iscolormap (ones (3,4)), false)
-%!assert (iscolormap (ones (3,3,3)), false)
 %!assert (iscolormap (single (jet (64))), false)
 %!assert (iscolormap ([0 0 -2]), false)
 %!assert (iscolormap ([0 0 2]), false)
+
diff --git a/scripts/image/jet.m b/scripts/image/jet.m
--- a/scripts/image/jet.m
+++ b/scripts/image/jet.m
@@ -32,17 +32,17 @@
 ## PKG_DEL: colormap ("unregister", "jet");
 
 function map = jet (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
-      error ("jet: argument must be a scalar");
+      error ("jet: N must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [0, 1, 1];
   elseif (n > 1)
diff --git a/scripts/image/lines.m b/scripts/image/lines.m
--- a/scripts/image/lines.m
+++ b/scripts/image/lines.m
@@ -31,17 +31,17 @@
 ## PKG_DEL: colormap ("unregister", "lines");
 
 function map = lines (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
-      error ("lines: argument must be a scalar");
+      error ("lines: N must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [0, 0, 1];
   elseif (n > 1)
diff --git a/scripts/image/module.mk b/scripts/image/module.mk
--- a/scripts/image/module.mk
+++ b/scripts/image/module.mk
@@ -1,10 +1,13 @@
 FCN_FILE_DIRS += image
 
+image_PRIVATE_FCN_FILES = \
+  image/private/ind2x.m
+
 image_FCN_FILES = \
   image/autumn.m \
   image/bone.m \
   image/brighten.m \
   image/cmpermute.m \
   image/cmunique.m \
   image/colorcube.m \
   image/colormap.m \
@@ -37,17 +40,18 @@ image_FCN_FILES = \
   image/rgb2hsv.m \
   image/rgb2ind.m \
   image/rgb2ntsc.m \
   image/rgbplot.m \
   image/spinmap.m \
   image/spring.m \
   image/summer.m \
   image/white.m \
-  image/winter.m
+  image/winter.m \
+  $(image_PRIVATE_FCN_FILES)
 
 IMAGES += \
   image/default.img
 
 FCN_FILES += $(image_FCN_FILES)
 
 PKG_ADD_FILES += image/PKG_ADD
 
diff --git a/scripts/image/ntsc2rgb.m b/scripts/image/ntsc2rgb.m
--- a/scripts/image/ntsc2rgb.m
+++ b/scripts/image/ntsc2rgb.m
@@ -15,55 +15,88 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{rgb_map} =} ntsc2rgb (@var{yiq_map})
 ## @deftypefnx {Function File} {@var{rgb_img} =} ntsc2rgb (@var{yiq_img})
 ## Transform a colormap or image from luminance-chrominance (NTSC) space to
-## red-green-blue (RGB) space.
+## red-green-blue (RGB) color space.
+##
+## Implementation Note:
+## The conversion matrix is chosen to be the inverse of the
+## matrix used for rgb2ntsc such that
+##
+## @example
+## x == ntsc2rgb (rgb2ntsc (x))
+## @end example
+##
+## @sc{matlab} uses a slightly different matrix where rounding
+## means the equality above does not hold.
 ## @seealso{rgb2ntsc, hsv2rgb, ind2rgb}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function rgb = ntsc2rgb (yiq)
 
   if (nargin != 1)
     print_usage ();
   endif
 
+  if (! isa (yiq, "double"))
+    error ("ntsc2rgb: YIQ must be of type double");
+  endif
+
   ## If we have an image convert it into a color map.
   if (ismatrix (yiq) && ndims (yiq) == 3)
     is_image = true;
-    Sz = size (yiq);
+    sz = size (yiq);
     yiq = [yiq(:,:,1)(:), yiq(:,:,2)(:), yiq(:,:,3)(:)];
-    ## Convert to a double image.
-    if (isinteger (yiq))
-      C = class (yiq);
-      low = double (intmin (C));
-      high = double (intmax (C));
-      yiq = (double (yiq) - low) / (high - low);
-    endif
   else
     is_image = false;
   endif
 
-  if (! ismatrix (yiq) || columns (yiq) != 3)
-    error ("ntsc2rgb: argument must be a matrix of size Nx3 or NxMx3");
+  if (! isreal (yiq) || columns (yiq) != 3 || issparse (yiq))
+    error ("ntsc2rgb: input must be a matrix of size Nx3 or NxMx3");
   endif
 
-  ## Convert data
+  ## Conversion matrix constructed from 'inv (rgb2ntsc matrix)'.
+  ## See programming notes in rgb2ntsc.m.  Note: Matlab matrix for inverse
+  ## is slightly different.  We prefer this matrix so that
+  ## x == ntsc2rgb (rgb2ntsc (x)) rather than maintaining strict compatibility
+  ## with Matlab.
   trans = [ 1.0,      1.0,      1.0;
             0.95617, -0.27269, -1.10374;
-            0.62143, -0.64681, 1.70062 ];
+            0.62143, -0.64681,  1.70062 ];
 
   rgb = yiq * trans;
 
   ## If input was an image, convert it back into one.
   if (is_image)
-    rgb = reshape (rgb, Sz);
+    rgb = reshape (rgb, sz);
   endif
 
 endfunction
+
+
+%% Test pure R, G, B colors
+%!assert (ntsc2rgb ([.299  .596  .211]), [1 0 0], 1e-5)
+%!assert (ntsc2rgb ([.587 -.274 -.523]), [0 1 0], 1e-5)
+%!assert (ntsc2rgb ([.114 -.322  .312]), [0 0 1], 1e-5)
+
+%!test
+%! rgb_map = rand (64, 3);
+%! assert (ntsc2rgb (rgb2ntsc (rgb_map)), rgb_map, 1e-3);
+
+%!test
+%! rgb_img = rand (64, 64, 3);
+%! assert (ntsc2rgb (rgb2ntsc (rgb_img)), rgb_img, 1e-3);
+
+%% Test input validation
+%!error ntsc2rgb ()
+%!error ntsc2rgb (1,2)
+%!error <YIQ must be of type double> ntsc2rgb (uint8 (1))
+%!error <must be a matrix of size Nx3 or NxMx3> ntsc2rgb (ones (2,2))
+
diff --git a/scripts/image/ocean.m b/scripts/image/ocean.m
--- a/scripts/image/ocean.m
+++ b/scripts/image/ocean.m
@@ -34,17 +34,17 @@
 ## PKG_DEL: colormap ("unregister", "ocean");
 
 function map = ocean (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
-      error ("ocean: argument must be a scalar");
+      error ("ocean: N must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [0, 0, 0];
   elseif (n > 1)
diff --git a/scripts/image/pink.m b/scripts/image/pink.m
--- a/scripts/image/pink.m
+++ b/scripts/image/pink.m
@@ -32,17 +32,17 @@
 ## PKG_DEL: colormap ("unregister", "pink");
 
 function map = pink (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
-      error ("pink: argument must be a scalar");
+      error ("pink: N must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = sqrt ([1/3, 1/3, 1/3]);
   elseif (n > 1)
diff --git a/scripts/image/prism.m b/scripts/image/prism.m
--- a/scripts/image/prism.m
+++ b/scripts/image/prism.m
@@ -32,17 +32,17 @@
 ## PKG_DEL: colormap ("unregister", "prism");
 
 function map = prism (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
-      error ("prism: argument must be a scalar");
+      error ("prism: N must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [1 0 0];
   elseif (n > 1)
diff --git a/scripts/image/private/ind2x.m b/scripts/image/private/ind2x.m
new file mode 100644
--- /dev/null
+++ b/scripts/image/private/ind2x.m
@@ -0,0 +1,55 @@
+## Copyright (C) 1994-2012 John W. Eaton
+## Copyright (C) 2012 Carnë Draug
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## private function for the ind2XXX functions which have a lot of code in common
+
+function [x, map] = ind2x (caller, x, map)
+
+  ## Check if X is an indexed image.
+  if (ndims (x) != 2 || issparse (x) || (isfloat (x) && ! isindex (x)) ||
+      ! any (strcmp (class (x), {"uint8", "uint16", "single", "double"})))
+    error ("%s: X must be an indexed image", caller);
+  endif
+
+  ## Check if map is a valid colormap.
+  if (! iscolormap (map))
+    error ("%s: MAP must be a valid colormap", caller);
+  endif
+
+  ## Do we have enough colors in the color map?
+  ## there's an offset of 1 when the indexed image is an integer class so we fix
+  ## it now and convert it to float only if really necessary and even then only
+  ## to single precision since that is enough for both uint8 and uint16.
+  maxidx = max (x(:));
+  if (isinteger (x))
+    if (maxidx == intmax (class (x)))
+      x = single (x);
+    endif
+    x      += 1;
+    maxidx += 1;
+  endif
+
+  num_colors = rows (map);
+  if (num_colors < maxidx)
+    ## Pad with the last color in the map for matlab compatibility
+    pad = repmat (map(end,:), maxidx - num_colors, 1);
+    map(end+1:maxidx, :) = pad;
+  endif
+
+endfunction
diff --git a/scripts/image/rainbow.m b/scripts/image/rainbow.m
--- a/scripts/image/rainbow.m
+++ b/scripts/image/rainbow.m
@@ -35,17 +35,17 @@
 ## PKG_DEL: colormap ("unregister", "rainbow");
 
 function map = rainbow (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
-      error ("rainbow: argument must be a scalar");
+      error ("rainbow: N must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [1, 0, 0];
   elseif (n > 1)
diff --git a/scripts/image/rgb2hsv.m b/scripts/image/rgb2hsv.m
--- a/scripts/image/rgb2hsv.m
+++ b/scripts/image/rgb2hsv.m
@@ -19,58 +19,64 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{hsv_map} =} rgb2hsv (@var{rgb})
 ## @deftypefnx {Function File} {@var{hsv_map} =} rgb2hsv (@var{rgb})
 ## Transform a colormap or image from red-green-blue (RGB) space to
 ## hue-saturation-value (HSV) space.
 ##
 ## A color in the RGB space consists of red, green, and blue intensities.
 ##
-## A color in HSV space is represented by hue, saturation and value
+## A color in HSV space is represented by hue, saturation, and value
 ## (brightness) levels.  Value gives the amount of light in the color.  Hue
 ## describes the dominant wavelength.  Saturation is the amount of hue mixed
 ## into the color.
 ## @seealso{hsv2rgb, rgb2ind, rgb2ntsc}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
 function hsv_map = rgb2hsv (rgb)
 
   if (nargin != 1)
     print_usage ();
   endif
 
+  cls = class (rgb);
+  if (! any (strcmp (cls, {"uint8", "uint16", "single", "double"})))
+    error ("rgb2hsv: invalid data type '%s'", cls);
+  elseif (isfloat (rgb) && (any (rgb(:) < 0) || any (rgb(:) > 1)))
+    error ("rgb2hsv: floating point images may only contain values between 0 and 1");
+  endif
+
   ## If we have an image convert it into a color map.
-  if (ismatrix (rgb) && ndims (rgb) == 3)
+  if (isreal (rgb) && ndims (rgb) == 3)
     is_image = true;
-    Sz = size (rgb);
+    sz = size (rgb);
     rgb = [rgb(:,:,1)(:), rgb(:,:,2)(:), rgb(:,:,3)(:)];
     ## Convert to a double image.
     if (isinteger (rgb))
-      C = class (rgb);
-      low = double (intmin (C));
-      high = double (intmax (C));
+      low = double (intmin (cls));
+      high = double (intmax (cls));
       rgb = (double (rgb) - low) / (high - low);
     endif
   else
     is_image = false;
   endif
 
-  if (! ismatrix (rgb) || columns (rgb) != 3)
-    error ("rgb2hsv: RGB_MAP must be a matrix of size n x 3");
+  if (! ismatrix (rgb) || columns (rgb) != 3 || issparse (rgb))
+    error ("rgb2hsv: input must be a matrix of size Nx3 or MxNx3");
   endif
 
-  ## get the max and min
-  s = min (rgb')';
-  v = max (rgb')';
+  ## get the max and min for each row
+  s = min (rgb, [], 2);
+  v = max (rgb, [], 2);
 
   ## set hue to zero for undefined values (gray has no hue)
-  h = zeros (size (v));
+  h = zeros (rows (rgb), 1);
   notgray = (s != v);
 
   ## blue hue
   idx = (v == rgb(:,3) & notgray);
   if (any (idx))
     h(idx) = 2/3 + 1/6 * (rgb(idx,1) - rgb(idx,2)) ./ (v(idx) - s(idx));
   endif
 
@@ -80,25 +86,46 @@ function hsv_map = rgb2hsv (rgb)
     h(idx) = 1/3 + 1/6 * (rgb(idx,3) - rgb(idx,1)) ./ (v(idx) - s(idx));
   endif
 
   ## red hue
   idx = (v == rgb(:,1) & notgray);
   if (any (idx))
     h(idx) =       1/6 * (rgb(idx,2) - rgb(idx,3)) ./ (v(idx) - s(idx));
   endif
-
-  ## correct for negative red
-  idx = (h < 0);
-  h(idx) = 1+h(idx);
+  h(h < 0) += 1;   # correct for negative red
 
   ## set the saturation
   s(! notgray) = 0;
   s(notgray) = 1 - s(notgray) ./ v(notgray);
 
   hsv_map = [h, s, v];
 
+  ## FIXME: rgb2hsv does not preserve class of image.
+  ##        Should it also convert back to uint8, uint16 for integer images?
   ## If input was an image, convert it back into one.
   if (is_image)
-    hsv_map = reshape (hsv_map, Sz);
+    hsv_map = reshape (hsv_map, sz);
   endif
 
 endfunction
+
+
+%% Test pure colors and gray
+%!assert (rgb2hsv ([1 0 0]), [0 1 1])
+%!assert (rgb2hsv ([0 1 0]), [1/3 1 1])
+%!assert (rgb2hsv ([0 0 1]), [2/3 1 1])
+%!assert (rgb2hsv ([0.5 0.5 0.5]), [0 0 0.5])
+
+%!test
+%! rgb_map = rand (64, 3);
+%! assert (hsv2rgb (rgb2hsv (rgb_map)), rgb_map, 1e-6);
+
+%!test
+%! rgb_img = rand (64, 64, 3);
+%! assert (hsv2rgb (rgb2hsv (rgb_img)), rgb_img, 1e-6);
+
+%% Test input validation
+%!error rgb2hsv ()
+%!error rgb2hsv (1,2)
+%!error <invalid data type 'cell'> rgb2hsv ({1})
+%!error <must be a matrix of size Nx3> rgb2hsv (ones (2,2))
+
diff --git a/scripts/image/rgb2ind.m b/scripts/image/rgb2ind.m
--- a/scripts/image/rgb2ind.m
+++ b/scripts/image/rgb2ind.m
@@ -1,9 +1,10 @@
 ## Copyright (C) 1994-2012 John W. Eaton
+## Copyright (C) 2012 Carnë Draug
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -14,52 +15,79 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{x}, @var{map}] =} rgb2ind (@var{rgb})
 ## @deftypefnx {Function File} {[@var{x}, @var{map}] =} rgb2ind (@var{R}, @var{G}, @var{B})
-## Convert an image in red-green-blue (RGB) space to an indexed image.
+## Convert an image in red-green-blue (RGB) color space to an indexed image.
 ## @seealso{ind2rgb, rgb2hsv, rgb2ntsc}
 ## @end deftypefn
 
-## Bugs: The color map may have duplicate entries.
+## FIXME: This function has a very different syntax than the Matlab
+##        one of the same name.
+##        Octave function does not support N, MAP, DITHER, or TOL arguments.
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function [x, map] = rgb2ind (R, G, B)
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
   endif
 
   if (nargin == 1)
     rgb = R;
-    if (length (size (rgb)) == 3 && size (rgb, 3) == 3)
+    if (ndims (rgb) != 3 || size (rgb, 3) != 3)
+      error ("rgb2ind: argument is not an RGB image");
+    else
       R = rgb(:,:,1);
       G = rgb(:,:,2);
       B = rgb(:,:,3);
-    else
-      error ("rgb2ind: argument is not an RGB image");
     endif
-  endif
-
-  if (! size_equal (R, G) || ! size_equal (R, B))
-    error ("rgb2ind: arguments must all have the same size");
+  elseif (! size_equal (R, G, B))
+    error ("rgb2ind: R, G, and B must have the same size");
   endif
 
-  [hi, wi] = size (R);
+  x = reshape (1:numel (R), size (R));
 
-  x = zeros (hi, wi);
-
-  map = zeros (hi*wi, 3);
+  map    = unique ([R(:) G(:) B(:)], "rows");
+  [~, x] = ismember ([R(:) G(:) B(:)], map, "rows");
+  x      = reshape (x, size (R));
 
-  map(:,1) = R(:);
-  map(:,2) = G(:);
-  map(:,3) = B(:);
+  ## a colormap is of class double and values between 0 and 1
+  switch (class (R))
+    case {"single", "double", "logical"}
+      ## do nothing, return the same
+    case {"uint8", "uint16"}
+      map = double (map) / double (intmax (class (R)));
+    case "int16"
+      map = (double (im) + 32768) / 65535;
+    otherwise
+      error ("unsupported image class %s", im_class);
+  endswitch
 
-  x(:) = 1:(hi*wi);
+  ## we convert to the smallest class necessary to encode the image. Matlab
+  ## documentation does not mention what it does when uint16 is not enough...
+  ## When an indexed image is of integer class, there's a -1 offset to the
+  ## colormap, hence the adjustment
+  if (rows (map) < 256)
+    x = uint8 (x - 1);
+  elseif (rows (map) < 65536)
+    x = uint16 (x - 1);
+  else
+    ## leave it as double
+  endif
 
 endfunction
+
+
+%% FIXME: Need some functional tests or %!demo blocks
+
+%% Test input validation
+%!error rgb2ind ()
+%!error rgb2ind (1,2)
+%!error rgb2ind (1,2,3,4)
+
diff --git a/scripts/image/rgb2ntsc.m b/scripts/image/rgb2ntsc.m
--- a/scripts/image/rgb2ntsc.m
+++ b/scripts/image/rgb2ntsc.m
@@ -14,56 +14,105 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{yiq_map} =} rgb2ntsc (@var{rgb_map})
 ## @deftypefnx {Function File} {@var{yiq_img} =} rgb2ntsc (@var{rgb_img})
-## Transform a colormap or image from red-green-blue (RGB) space to
-## luminance-chrominance (NTSC) space.
+## Transform a colormap or image from red-green-blue (RGB) color space to
+## luminance-chrominance (NTSC) space.  The input may be of class uint8,
+## uint16, single, or double.  The output is of class double.
+##
+## Implementation Note:
+## The reference matrix for the transformation is
+##
+## @example
+## @group
+## /Y\     0.299  0.587  0.114  /R\ 
+## |I|  =  0.596 -0.274 -0.322  |G| 
+## \Q/     0.211 -0.523  0.312  \B/ 
+## @end group
+## @end example
+##
+## @noindent
+## as documented in @url{http://en.wikipedia.org/wiki/YIQ} and truncated to 3
+## significant figures.  Note: The FCC version of NTSC uses only 2
+## significant digits and is slightly different.
 ## @seealso{ntsc2rgb, rgb2hsv, rgb2ind}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function yiq = rgb2ntsc (rgb)
 
   if (nargin != 1)
     print_usage ();
   endif
 
+  cls = class (rgb);
+  if (! any (strcmp (cls, {"uint8", "uint16", "single", "double"})))
+    error ("rgb2ntsc: invalid data type '%s'", cls);
+  elseif (isfloat (rgb) && (any (rgb(:) < 0) || any (rgb(:) > 1)))
+    error ("rgb2ntsc: floating point images may only contain values between 0 and 1");
+  endif
+
   ## If we have an image convert it into a color map.
-  if (ismatrix (rgb) && ndims (rgb) == 3)
+  if (isreal (rgb) && ndims (rgb) == 3)
     is_image = true;
-    Sz = size (rgb);
+    sz = size (rgb);
     rgb = [rgb(:,:,1)(:), rgb(:,:,2)(:), rgb(:,:,3)(:)];
     ## Convert to a double image.
     if (isinteger (rgb))
-      C = class (rgb);
-      low = double (intmin (C));
-      high = double (intmax (C));
+      low = double (intmin (cls));
+      high = double (intmax (cls));
       rgb = (double (rgb) - low) / (high - low);
+    elseif (isa (rgb, "single"))
+      rgb = double (rgb);
     endif
   else
     is_image = false;
   endif
 
-  if (! ismatrix (rgb) || columns (rgb) != 3)
-    error ("rgb2ntsc: argument must be a matrix of size Nx3 or NxMx3");
+  if (! isreal (rgb) || columns (rgb) != 3 || issparse (rgb))
+    error ("rgb2ntsc: input must be a matrix of size Nx3 or NxMx3");
   endif
 
-  ## Convert data
+  ## Reference matrix for transformation from http://en.wikipedia.org/wiki/YIQ
+  ## and truncated to 3 significant figures.  Matlab uses this matrix for their
+  ## conversion.
   trans = [ 0.299,  0.596,  0.211;
             0.587, -0.274, -0.523;
             0.114, -0.322,  0.312 ];
 
+  ## Convert data. 
   yiq = rgb * trans;
 
   ## If input was an image, convert it back into one.
   if (is_image)
-    yiq = reshape (yiq, Sz);
+    yiq = reshape (yiq, sz);
   endif
 
 endfunction
+
+
+%% Test pure RED, GREEN, BLUE colors
+%assert (rgb2ntsc ([1 0 0]), [.299  .587  .114])
+%assert (rgb2ntsc ([0 1 0]), [.596 -.274 -.322])
+%assert (rgb2ntsc ([1 0 1]), [.211 -.523  .312])
+
+%!test
+%! rgb_map = rand (64, 3);
+%! assert (ntsc2rgb (rgb2ntsc (rgb_map)), rgb_map, 1e-3);
+
+%!test
+%! rgb_img = rand (64, 64, 3);
+%! assert (ntsc2rgb (rgb2ntsc (rgb_img)), rgb_img, 1e-3);
+
+%% Test input validation
+%!error rgb2ntsc ()
+%!error rgb2ntsc (1,2)
+%!error <invalid data type 'cell'> rgb2ntsc ({1})
+%!error <must be a matrix of size Nx3 or NxMx3> rgb2ntsc (ones (2,2))
+
diff --git a/scripts/image/rgbplot.m b/scripts/image/rgbplot.m
--- a/scripts/image/rgbplot.m
+++ b/scripts/image/rgbplot.m
@@ -1,9 +1,10 @@
 ## Copyright (C) 2012 Rik Wehbring
+## Copyright (C) 2012 Carnë Draug
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -13,49 +14,77 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} rgbplot (@var{cmap})
-## @deftypefnx {Function File} {@var{h} =} rgbplot (@var{cmap})
+## @deftypefnx {Function File} {} rgbplot (@var{cmap}, @var{style})
+## @deftypefnx {Function File} {@var{h} =} rgbplot (@dots{})
 ## Plot the components of a colormap.
 ##
-## The first column is plotted in red, the second column in green, and
-## the third column in blue.  The values are between 0 and 1 and represent
-## the intensity of the RGB components in the given indexed color.
+## Two different @var{style}s are available for displaying the @var{cmap}:
+##
+## @table @asis
+## @item profile (default)
+## Plot the RGB line profile of the colormap for each of the channels (red,
+## green and blue) with the plot lines colored appropriately.  Each line
+## represents the intensity of each RGB components across the colormap.
+##
+## @item composite
+## Draw the colormap across the X-axis so that the actual index colors are
+## visible rather than the individual color components.
+##
+## @end table
 ##
 ## The optional return value @var{h} is a graphics handle to the created plot.
 ##
+## Run @code{demo rgbplot} to see an example of @code{rgbplot} and each style
+## option.
 ## @seealso{colormap}
 ## @end deftypefn
 
-function retval = rgbplot (cmap)
+function h = rgbplot (cmap, style)
 
-  if (nargin != 1)
+  if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (! iscolormap (cmap))
-    error ("rgbplot: CMAP must be a colormap");
+    error ("rgbplot: CMAP must be a valid colormap");
+  elseif (! ischar (style))
+    error ("rgbplot: STYLE must be a string");
   endif
 
-  h = plot (cmap(:,1),"r", cmap(:,2),"g", cmap(:,3),"b");
-  set (gca, 'ytick', 0:0.1:1);
+  switch (tolower (style))
+    case "profile"
+      htmp = plot (cmap(:,1),"r", cmap(:,2),"g", cmap(:,3),"b");
+      set (gca, 'ytick', 0:0.1:1);
+    case "composite"
+      htmp = image (1:rows(cmap));
+      set (gca, 'ytick', []);
+      colormap (cmap);
+    otherwise
+      error ("rgbplot: unknown style `%s'", style);
+  endswitch
   xlabel ("color index");
 
   if (nargout > 0)
-    retval = h;
+    h = htmp;
   endif
 
 endfunction
 
 
 %!demo
 %! clf;
-%! rgbplot (ocean);
+%! subplot (1, 2, 1);
+%! rgbplot (ocean, "profile");
+%! subplot (1, 2, 2);
+%! rgbplot (ocean, "composite");
 
-%%test input validation
+%% Test input validation
 %!error rgbplot ()
 %!error rgbplot (1,2)
-%!error <CMAP must be a colormap> rgbplot ({0 1 0})
+%!error <CMAP must be a valid colormap> rgbplot ({0 1 0})
+
diff --git a/scripts/image/spring.m b/scripts/image/spring.m
--- a/scripts/image/spring.m
+++ b/scripts/image/spring.m
@@ -31,17 +31,17 @@
 ## PKG_DEL: colormap ("unregister", "spring");
 
 function map = spring (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
-      error ("spring: argument must be a scalar");
+      error ("spring: N must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [1, 0, 1];
   elseif (n > 1)
diff --git a/scripts/image/summer.m b/scripts/image/summer.m
--- a/scripts/image/summer.m
+++ b/scripts/image/summer.m
@@ -32,17 +32,17 @@
 ## PKG_DEL: colormap ("unregister", "summer");
 
 function map = summer (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
-      error ("summer: argument must be a scalar");
+      error ("summer: N must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [0, 0.5, 0.4];
   elseif (n > 1)
diff --git a/scripts/image/white.m b/scripts/image/white.m
--- a/scripts/image/white.m
+++ b/scripts/image/white.m
@@ -31,17 +31,17 @@
 ## PKG_DEL: colormap ("unregister", "white");
 
 function map = white (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
-      error ("white: argument must be a scalar");
+      error ("white: N must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   map = ones (n, 3);
 
 endfunction
diff --git a/scripts/image/winter.m b/scripts/image/winter.m
--- a/scripts/image/winter.m
+++ b/scripts/image/winter.m
@@ -31,17 +31,17 @@
 ## PKG_DEL: colormap ("unregister", "winter");
 
 function map = winter (n)
 
   if (nargin == 0)
     n = rows (colormap);
   elseif (nargin == 1)
     if (! isscalar (n))
-      error ("winter: argument must be a scalar");
+      error ("winter: N must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
     map = [0, 0, 1];
   elseif (n > 1)
diff --git a/scripts/io/importdata.m b/scripts/io/importdata.m
--- a/scripts/io/importdata.m
+++ b/scripts/io/importdata.m
@@ -254,31 +254,40 @@ function [output, delimiter, header_rows
     delimiter_pattern = ' +';
   endif
   for i=(header_rows+1):length(file_content_rows)
     data_columns = max (data_columns,
                         length (regexp (file_content_rows{i},
                                         delimiter_pattern, "split")));
   endfor
 
+  ## FIXME: Make it behave like Matlab when importing a table where a whole
+  ## column is text only. E.g.
+  ##    abc  12  34
+  ##    def  56  78
+  ## This would give a 3x2 data matrix with the left column = nan(2,1), and 
+  ## the text would end up in textdata.
+  ## In Matlab the data matrix would only be a 2x2 matrix, see example at:
+  ## http://www.mathworks.se/help/matlab/import_export/import-numeric-data-and-header-text-from-a-text-file.html
+
   ## Go through the data and put it in either output.data or
   ## output.textdata depending on if it is numeric or not.
   output.data = NaN (length (file_content_rows) - header_rows, data_columns);
   for i=(header_rows+1):length(file_content_rows)
     ## Only use the row if it contains anything other than white-space
     ## characters.
     if (any (file_content_rows{i} != " "))
       row_data = regexp (file_content_rows{i}, delimiter_pattern, "split");
 
       for j=1:length(row_data)
         ## Try to convert the column to a number, if it works put it in
         ## output.data, otherwise in output.textdata
         if (!isempty (row_data{j}))
           data_numeric = str2double (row_data{j});
-          if (!isempty (data_numeric))
+          if (!isnan (data_numeric))
             output.data(i-header_rows, j) = data_numeric;
           else
             output.textdata{i,j} = row_data{j};
           endif
         endif
       endfor
 
     endif
@@ -382,16 +391,29 @@ endfunction
 %! fclose (fid);
 %! [a,d,h] = importdata (fn, "\\t");
 %! unlink (fn);
 %! assert (a, A);
 %! assert (d, "\t");
 %! assert (h, 0);
 
 %!test
+%! # Complex numbers
+%! A = [3.1 -7.2 0-3.4i; 0.012 -6.5+7.2i 128];
+%! fn  = tmpnam ();
+%! fid = fopen (fn, "w");
+%! fputs (fid, "3.1\t-7.2\t0-3.4i\n0.012\t-6.5+7.2i\t128");
+%! fclose (fid);
+%! [a,d,h] = importdata (fn, "\\t");
+%! unlink (fn);
+%! assert (a, A);
+%! assert (d, "\t");
+%! assert (h, 0);
+
+%!test
 %! # Missing values
 %! A = [3.1 NaN 0; 0.012 6.5 128];
 %! fn  = tmpnam ();
 %! fid = fopen (fn, "w");
 %! fputs (fid, "3.1\t\t0\n0.012\t6.5\t128");
 %! fclose (fid);
 %! [a,d,h] = importdata (fn, "\\t");
 %! unlink (fn);
diff --git a/scripts/java/dlgtest.m b/scripts/java/dlgtest.m
new file mode 100644
--- /dev/null
+++ b/scripts/java/dlgtest.m
@@ -0,0 +1,205 @@
+%
+% Test the dlg... functions of the Octave-Java bridge
+%
+% Once the Java bridge works OK this function should be dropped from core octave
+%
+% Author: Martin Hepperle
+% Version August 2010
+% Adapted for core Octave Philip Nienhuis 2012
+%
+function dlgtest
+
+  answer = 1;
+  while (answer > 0 )
+
+    disp('');
+    disp('0 ... STOP');
+    disp('1 ... listdlg tests');
+    disp('2 ... errordlg tests');
+    disp('3 ... warndlg tests');
+    disp('4 ... helpdlg tests');
+    disp('5 ... inputdlg tests');
+    disp('6 ... TeX code tests');
+    
+    answer = str2num(input ('Run which test?   [0] > ','s'));
+
+    disp('');
+    
+    switch answer
+      case 1
+        test_listdlg();
+      case 2
+        test_errordlg();
+      case 3
+        test_warndlg();
+      case 4
+        test_helpdlg();
+      case 5
+        test_inputdlg();
+      case 6
+        test_TeXCodes();
+    end
+  end
+
+   %   d = javaObject('javax.swing.JDialog');
+   %   cp = d.getContentPane;
+   %   b = javaObject('javax.swing.JButton','OK');
+   %   cp.add(b);
+   %   d.pack;
+   %   d.setVisible(true);
+
+
+   page_screen_output(1);
+
+end
+
+function test_listdlg
+
+   %-----------------------------------------------
+   disp('- test listdlg with selectionmode single. No caption, no prompt.');
+   itemlist = {'An item \\alpha', 'another', 'yet another'};
+   s = listdlg ( 'ListString',itemlist, 'SelectionMode','Single' );
+   imax = numel (s);
+   for i=1:1:imax
+      disp(['Selected: ',num2str(i),': ', itemlist{s(i)}]);
+   end
+
+   %-----------------------------------------------
+   disp('- test listdlg with selectionmode and preselection. Has caption and two lines prompt.');
+   s = listdlg ( 'ListString',itemlist, ...
+                 'SelectionMode','Multiple', ...
+                 'Name','Selection Dialog', ...
+                 'InitialValue',[1,2,3,4],
+                 'PromptString',{'Select an item...', '...or multiple items'} );
+   imax = numel (s);
+   for i=1:1:imax
+      disp(['Selected: ',num2str(i),': ', itemlist{s(i)}]);
+   end
+
+end
+
+function test_errordlg
+   %-----------------------------------------------
+   disp('- test errordlg with prompt only.');
+   errordlg('Oops, an expected error occured');
+   %-----------------------------------------------
+   disp('- test errordlg with prompt and caption.');
+   errordlg('Oops another error','This is a very long and informative caption');
+end
+
+function test_warndlg
+   %-----------------------------------------------
+   disp('- test warndlg with prompt only.');
+   warndlg('Oh, a warning occured');
+   %-----------------------------------------------
+   disp('- test warndlg with prompt and caption.');
+   warndlg('Oh, No...','This is the last Warning');
+end
+
+function test_helpdlg
+   %-----------------------------------------------
+   disp('- test helpdlg with a help message only.');
+   helpdlg("Below, you should see 3 lines:\nline #1\nline #2, and\nline #3.");
+   %-----------------------------------------------
+   disp('- test helpdlg with help message and caption.');
+   helpdlg('You should see a single line.','A help dialog');
+end
+
+function test_inputdlg
+   %-----------------------------------------------
+   disp('- test inputdlg with prompt and caption only.');
+   prompt = {'Width','Height','Depth'};
+   dims = inputdlg ( prompt, 'Enter Box Dimensions' );
+   if isempty(dims)
+      helpdlg('Canceled by user', 'Information');
+   else
+      volume  = str2num(dims{1}) * str2num(dims{2}) * str2num(dims{3});
+      surface = 2 * (str2num(dims{1}) * str2num(dims{2}) + ...
+                     str2num(dims{2}) * str2num(dims{3}) + ...
+                     str2num(dims{1}) * str2num(dims{3}));
+      helpdlg(sprintf('Results:\nVolume = %.3f\nSurface = %.3f', volume, surface), 'Box Dimensions');
+   end
+
+   %-----------------------------------------------
+   disp('- test inputdlg with prescribed scalar (2 lines per text field) and defaults.');
+   prompt = {'Width','Height','Depth'};
+   default = {'1.1','2.2','3.3'};
+   rc = 2;
+   dims = inputdlg ( prompt, 'Enter Box Dimensions',rc,default );
+   if isempty(dims)
+      helpdlg('Canceled by user', 'Information');
+   else
+      volume  = str2num(dims{1}) * str2num(dims{2}) * str2num(dims{3});
+      surface = 2 * (str2num(dims{1}) * str2num(dims{2}) + ...
+                     str2num(dims{2}) * str2num(dims{3}) + ...
+                     str2num(dims{1}) * str2num(dims{3}));
+      helpdlg(sprintf('Results:\nVolume = %.3f\nSurface = %.3f', volume, surface), 'Box Dimensions');
+   end
+   %-----------------------------------------------
+   disp('- test inputdlg with prescribed vector [1,2,3] for # of lines per text field and defaults.');
+   prompt = {'Width','Height','Depth'};
+   default = {'1.10', '2.10', '3.10'};
+   rc = [1,2,3];  % NOTE: must be an array
+   dims = inputdlg ( prompt, 'Enter Box Dimensions',rc,default );
+   if isempty(dims)
+      helpdlg('Canceled by user', 'Information');
+   else
+      volume  = str2num(dims{1}) * str2num(dims{2}) * str2num(dims{3});
+      surface = 2 * (str2num(dims{1}) * str2num(dims{2}) + ...
+                     str2num(dims{2}) * str2num(dims{3}) + ...
+                     str2num(dims{1}) * str2num(dims{3}));
+      helpdlg(sprintf('Results:\nVolume = %.3f\nSurface = %.3f', volume, surface), 'Box Dimensions');
+   end
+   %-----------------------------------------------
+   disp('- test inputdlg with prescribed row by column sizes and defaults.');
+   prompt = {'Width','Height','Depth'};
+   default = {'1.10', '2.20', '3.30'};
+   rc = [1,10; 2,20; 3,30];  % NOTE: must be an array
+   dims = inputdlg ( prompt, 'Enter Box Dimensions',rc,default );
+   if isempty(dims)
+      helpdlg('Canceled by user', 'Information');
+   else
+      volume  = str2num(dims{1}) * str2num(dims{2}) * str2num(dims{3});
+      surface = 2 * (str2num(dims{1}) * str2num(dims{2}) + ...
+                     str2num(dims{2}) * str2num(dims{3}) + ...
+                     str2num(dims{1}) * str2num(dims{3}));
+      helpdlg(sprintf('Results:\nVolume = %.3f\nSurface = %.3f', volume, surface), 'Box Dimensions');
+   end
+end
+
+%% show a table of TeX symbol codes and the resulting Unicode character
+function test_TeXCodes
+   %-----------------------------------------------
+   disp('- test TeX code to Unicode translation.');
+
+   msgbox ( ['\\alpha  = ''\alpha ''      \\beta  = ''\beta ''      \\gamma  = ''\gamma ''', 10, ...
+             '\\delta  = ''\delta ''      \\epsilon  = ''\epsilon ''      \\zeta  = ''\zeta ''', 10, ...
+             '\\eta  = ''\eta ''      \\theta  = ''\theta ''      \\vartheta  = ''\vartheta ''', 10, ...
+             '\\iota  = ''\iota ''      \\kappa  = ''\kappa ''      \\lambda  = ''\lambda ''', 10, ...
+             '\\mu  = ''\mu ''      \\nu  = ''\nu ''      \\xi  = ''\xi ''', 10, ...
+             '\\pi  = ''\pi ''      \\rho  = ''\rho ''      \\sigma  = ''\sigma ''', 10, ...
+             '\\varsigma  = ''\varsigma ''      \\tau  = ''\tau ''      \\phi  = ''\phi ''', 10, ...
+             '\\chi  = ''\chi ''      \\psi  = ''\psi ''      \\omega  = ''\omega ''', 10, ...
+             '\\upsilon  = ''\upsilon ''      \\Gamma  = ''\Gamma ''      \\Delta  = ''\Delta ''', 10, ...
+             '\\Theta  = ''\Theta ''      \\Lambda  = ''\Lambda ''      \\Pi  = ''\Pi ''', 10, ...
+             '\\Xi  = ''\Xi ''      \\Sigma  = ''\Sigma ''      \\Upsilon  = ''\Upsilon ''', 10, ...
+             '\\Phi  = ''\Phi ''      \\Psi  = ''\Psi ''      \\Omega  = ''\Omega ''', 10, ...
+             '\\Im  = ''\Im ''      \\Re  = ''\Re ''      \\leq  = ''\leq ''', 10, ...
+             '\\geq  = ''\geq ''      \\neq  = ''\neq ''      \\pm  = ''\pm ''', 10, ...
+             '\\infty  = ''\infty ''      \\partial  = ''\partial ''      \\approx  = ''\approx ''', 10, ...
+             '\\circ  = ''\circ ''      \\bullet  = ''\bullet ''      \\times  = ''\times ''', 10, ...
+             '\\sim  = ''\sim ''      \\nabla  = ''\nabla ''      \\ldots  = ''\ldots ''', 10, ...
+             '\\exists  = ''\exists ''      \\neg  = ''\neg ''      \\aleph  = ''\aleph ''', 10, ...
+             '\\forall  = ''\forall ''      \\cong  = ''\cong ''      \\wp  = ''\wp ''', 10, ...
+             '\\propto  = ''\propto ''      \\otimes  = ''\otimes ''      \\oplus  = ''\oplus ''', 10, ...
+             '\\oslash  = ''\oslash ''      \\cap  = ''\cap ''      \\cup  = ''\cup ''', 10, ...
+             '\\ni  = ''\ni ''      \\in  = ''\in ''      \\div  = ''\div ''', 10, ...
+             '\\equiv  = ''\equiv ''      \\int  = ''\int ''      \\perp  = ''\perp ''', 10, ...
+             '\\wedge  = ''\wedge ''      \\vee  = ''\vee ''      \\supseteq  = ''\supseteq ''', 10, ...
+             '\\supset  = ''\supset ''      \\subseteq  = ''\subseteq ''      \\subset  = ''\subset ''', 10, ...
+             '\\clubsuit  = ''\clubsuit ''      \\spadesuit  = ''\spadesuit ''      \\heartsuit  = ''\heartsuit ''', 10, ...
+             '\\diamondsuit  = ''\diamondsuit ''      \\copyright  = ''\copyright ''      \\leftarrow  = ''\leftarrow ''', 10, ...
+             '\\uparrow  = ''\uparrow ''      \\rightarrow  = ''\rightarrow ''      \\downarrow  = ''\downarrow ''', 10, ...
+             '\\leftrightarrow  = ''\leftrightarrow ''      \\updownarrow  = ''\updownarrow '''], ...
+             'TeX symbol code table Test');
+end
diff --git a/scripts/java/errordlg.m b/scripts/java/errordlg.m
new file mode 100644
--- /dev/null
+++ b/scripts/java/errordlg.m
@@ -0,0 +1,55 @@
+## Copyright (C) 2010 Martin Hepperle
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {@var{h} =} errordlg (@var{msg})
+## @deftypefnx {Function File} {@var{h} =} errordlg (@var{msg}, @var{title})
+## Display @var{msg} using an error dialog box.
+##
+## The message may have multiple lines separated by newline characters
+## ("\n"), or it may be a cellstr array with one element for each
+## line.  The optional input @var{title} (character string) can be used to
+## set the dialog caption.  The default title is "Error Dialog".
+##
+## The return value is always 1.
+## @seealso{helpdlg, inputdlg, listdlg, msgbox, questdlg, warndlg}
+## @end deftypefn
+
+function h = errordlg (msg, title = "Error Dialog")
+
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+  endif
+
+  if (! ischar (msg))
+    if (iscell (msg))
+      msg = sprintf ("%s\n", msg{:});
+      msg(end) = "";
+    else
+      error ("errordlg: MSG must be a string or cellstr array");
+    endif
+  endif
+
+  if (! ischar (title))
+    error ("errordlg: TITLE must be a character string");
+  endif
+
+  h = javaMethod ("errordlg", "org.octave.JDialogBox", msg, title);
+
+endfunction
+
diff --git a/scripts/java/helpdlg.m b/scripts/java/helpdlg.m
new file mode 100644
--- /dev/null
+++ b/scripts/java/helpdlg.m
@@ -0,0 +1,55 @@
+## Copyright (C) 2010 Martin Hepperle
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {@var{h} =} helpdlg (@var{msg})
+## @deftypefnx {Function File} {@var{h} =} helpdlg (@var{msg}, @var{title})
+## Display @var{msg} in a help dialog box.
+##
+## The message may have multiple lines separated by newline characters
+## ("\n"), or it may be a cellstr array with one element for each
+## line.  The optional input @var{title} (character string) can be used to
+## set the dialog caption.  The default title is "Help Dialog".
+##
+## The return value is always 1.
+## @seealso{errordlg, inputdlg, listdlg, msgbox, questdlg, warndlg}
+## @end deftypefn
+
+function h = helpdlg (msg, title = "Help Dialog")
+
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+  endif
+
+  if (! ischar (msg))
+    if (iscell (msg))
+      msg = sprintf ("%s\n", msg{:});
+      msg(end) = "";
+    else
+      error ("helpdlg: MSG must be a string or cellstr array");
+    endif
+  endif
+
+  if (! ischar (title))
+    error ("helpdlg: TITLE must be a character string");
+  endif
+
+  h = javaMethod ("helpdlg", "org.octave.JDialogBox", msg, title);
+
+endfunction
+
diff --git a/scripts/java/inputdlg.m b/scripts/java/inputdlg.m
new file mode 100644
--- /dev/null
+++ b/scripts/java/inputdlg.m
@@ -0,0 +1,138 @@
+## Copyright (C) 2010 Martin Hepperle
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {@var{cstr} =} inputdlg (@var{prompt})
+## @deftypefnx {Function File} {@var{cstr} =} inputdlg (@var{prompt}, @var{title})
+## @deftypefnx {Function File} {@var{cstr} =} inputdlg (@var{prompt}, @var{title}, @var{rowscols})
+## @deftypefnx {Function File} {@var{cstr} =} inputdlg (@var{prompt}, @var{title}, @var{rowscols}, @var{defaults})
+## Return user input from a multi-textfield dialog box in a cell array
+## of strings, or an empty cell array if the dialog is closed by the
+## Cancel button.
+##
+## Inputs:
+##
+## @table @var
+## @item prompt
+## A cell array with strings labeling each text field.  This input is required. 
+##
+## @item title
+## String to use for the caption of the dialog.  The default is "Input Dialog".
+##
+## @item rowscols
+## Specifies the size of the text fields and can take three forms:
+##
+## @enumerate
+## @item a scalar value which defines the number of rows used for each
+## text field.
+##
+## @item a vector which defines the individual number of rows
+## used for each text field. 
+##
+## @item a matrix which defines the individual number of rows and
+## columns used for each text field.  In the matrix each row describes
+## a single text field.  The first column specifies the number of input
+## rows to use and the second column specifies the text field width.
+## @end enumerate
+##
+## @item defaults
+## A list of default values to place in each text fields.  It must be
+## a cell array of strings with the same size as @var{prompt}.
+## @end table
+## @seealso{errordlg, helpdlg, listdlg, msgbox, questdlg, warndlg}
+## @end deftypefn
+
+function cstr = inputdlg (prompt, title = "Input Dialog", varargin)
+
+  if (nargin < 1 || nargin > 4)
+    print_usage ();
+  endif
+
+  if (iscell (prompt))
+    ## Silently extract only char elements
+    prompt = prompt(cellfun ("ischar", prompt));
+  elseif (ischar (prompt))
+    prompt = {prompt};
+  else
+    error ("inputdlg: PROMPT must be a character string or cellstr array");
+  endif
+
+  if (! ischar (title))
+    error ("inputdlg: TITLE must be a character string");
+  endif
+
+  switch (numel (varargin))
+    case 0
+      linespec = 1;
+      defaults = cellstr (cell (size (prompt)));
+
+    case 1
+      linespec = varargin{1};
+      defaults = cellstr (cell (size (prompt)));
+
+    case 2
+      linespec = varargin{1};
+      defaults = varargin{2};
+  endswitch
+
+  ## specification of text field sizes as in Matlab 
+  ## Matlab requires a matrix for linespec, not a cell array...
+  ## rc = [1,10; 2,20; 3,30];
+  ##     c1  c2
+  ## r1  1   10   first  text field is 1x10
+  ## r2  2   20   second text field is 2x20
+  ## r3  3   30   third  text field is 3x30
+  if (isscalar (linespec))
+    ## only scalar value in lineTo, copy from linespec and add defaults
+    rowscols = zeros (columns (prompt), 2);
+    ## cols
+    rowscols(:,2) = 25;
+    rowscols(:,1) = linespec;
+  elseif (isvector (linespec))
+      ## only one column in lineTo, copy from vector linespec and add defaults
+      rowscols = zeros (columns (prompt), 2);
+      ## rows from colum vector linespec, columns are set to default
+      rowscols(:,2) = 25;
+      rowscols(:,1) = linespec(:);
+  elseif (ismatrix (linespec))
+    if (rows (linespec) == columns (prompt) && columns (linespec) == 2)
+      ## (rows x columns) match, copy array linespec
+      rowscols = linespec;
+    else
+      error ("inputdlg: ROWSCOLS matrix does not match size of PROMPT");
+    endif
+
+  else
+    ## dunno
+    error ("inputdlg: unknown form of ROWSCOLS argument");
+  endif
+  
+  ## convert numeric values in defaults cell array to strings
+  defs = cellfun (@num2str, defaults, "UniformOutput", false);
+  rc = arrayfun (@num2str, rowscols, "UniformOutput", false);
+
+  user_inputs = javaMethod ("inputdlg", "org.octave.JDialogBox",
+                             prompt, title, rc, defs);
+  
+   if (isempty (user_inputs))
+     cstr = {};
+   else
+     cstr = cellstr (user_inputs);
+   endif
+
+endfunction
diff --git a/scripts/java/javaArray.m b/scripts/java/javaArray.m
new file mode 100644
--- /dev/null
+++ b/scripts/java/javaArray.m
@@ -0,0 +1,54 @@
+## Copyright (C) 2007 Michael Goffioul
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {@var{jary} =} javaArray (@var{classname}, @var{sz})
+## @deftypefnx {Function File} {@var{jary} =} javaArray (@var{classname}, @var{m}, @var{n}, @dots{})
+##
+## Create a Java array of size @var{sz} with elements of class
+## @var{classname}.  @var{classname} may be a Java object representing a class
+## or a string containing the fully qualified class name.  The size of
+## the object may also be specified with individual integer arguments
+## @var{m}, @var{n}, etc.
+##
+## The generated array is uninitialized.  All elements are set to null
+## if @var{classname} is a reference type, or to a default value (usually 0)
+## if @var{classname} is a primitive type.
+##
+## Sample code:
+##
+## @example
+## @group
+## jary = javaArray ("java.lang.String", 2, 2);
+## jary(1,1) = "Hello";
+## @end group
+## @end example
+## @seealso{javaObject}
+## @end deftypefn
+
+function retval = javaArray (classname, varargin)
+
+  if (nargin < 2)
+    print_usage ();
+  endif
+
+  retval = javaMethod ("createArray", "org.octave.ClassHelper",
+                        classname, [varargin{:}]);
+
+endfunction
+
diff --git a/scripts/java/javaaddpath.m b/scripts/java/javaaddpath.m
new file mode 100644
--- /dev/null
+++ b/scripts/java/javaaddpath.m
@@ -0,0 +1,59 @@
+## Copyright (C) 2007 Michael Goffioul
+## Copyright (C) 2010 Martin Hepperle
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {} javaaddpath (@var{clspath})
+## @deftypefnx {Function File} {} javaaddpath (@var{clspath1}, @dots{})
+## Add @var{clspath} to the dynamic class path of the Java virtual
+## machine.  @var{clspath} may either be a directory where @file{.class}
+## files are found, or a @file{.jar} file containing Java classes.
+## Multiple paths may be added at once by specifying additional arguments.
+## @seealso{javarmpath, javaclasspath}
+## @end deftypefn
+
+function javaaddpath (varargin)
+
+  if (nargin < 1)
+    print_usage ();
+  endif
+
+  for i = 1:numel (varargin)
+    clspath = varargin{i};
+    if (! ischar (clspath))
+      error ("javaaddpath: CLSPATH must be a string");
+    endif
+
+    new_path = canonicalize_file_name (tilde_expand (clspath));
+    if (exist (new_path, "dir"))
+      if (new_path(end) != filesep ())
+        new_path = [new_path, filesep()];
+      endif
+    elseif (! exist (new_path, "file"))
+      error ("javaaddpath: CLSPATH does not exist: %s", clspath);
+    endif
+
+    success = javaMethod ("addClassPath", "org.octave.ClassHelper", new_path);
+
+    if (! success)
+      warning ("javaaddpath: failed to add '%s' to Java classpath", new_path);
+    endif
+  endfor 
+   
+endfunction
+
diff --git a/scripts/java/javaclasspath.m b/scripts/java/javaclasspath.m
new file mode 100644
--- /dev/null
+++ b/scripts/java/javaclasspath.m
@@ -0,0 +1,125 @@
+## Copyright (C) 2007 Michael Goffioul
+## Copyright (C) 2010 Martin Hepperle
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {} javaclasspath ()
+## @deftypefnx {Function File} {@var{dpath} =} javaclasspath ()
+## @deftypefnx {Function File} {[@var{dpath}, @var{spath}] =} javaclasspath ()
+## @deftypefnx {Function File} {@var{clspath} =} javaclasspath (@var{what})
+## Return the class path of the Java virtual machine in the form of a cell
+## array of strings. 
+##
+## If called with no inputs:
+##
+## @itemize
+## @item If no output is requested, the dynamic and static classpaths are printed 
+## to the standard output.
+##
+## @item If one output value @var{dpath} is requested, the result is
+## the dynamic classpath.
+##
+## @item If two output values@var{dpath} and @var{spath} are 
+## requested, the first variable will contain the dynamic classpath and
+## the second will be contain the static classpath.
+## @end itemize
+## 
+## If called with a single input parameter @var{what}:
+##
+## @table @asis
+## @item "-dynamic"
+## Return the dynamic classpath.
+##
+## @item "-static"
+## Return the static classpath.
+##
+## @item "-all"
+## Return both the static and dynamic classpath in a single cellstr.
+## @end table
+## @seealso{javaaddpath, javarmpath}
+## @end deftypefn
+
+function varargout = javaclasspath (which)
+
+  ## dynamic classpath
+  dynamic_path = javaMethod ("getClassPath", "org.octave.ClassHelper");
+  dynamic_path_list = strsplit (dynamic_path, pathsep ());
+
+  ## static classpath
+  static_path = javaMethod ("getProperty", "java.lang.System", "java.class.path");
+  static_path_list = strsplit (static_path, pathsep ());
+  if (numel (static_path_list) > 1)
+    ## remove first element (which is .../octave.jar)
+    static_path_list(1) = [];
+  else
+    static_path_list = {};
+  endif
+
+  switch (nargin)
+    case 0
+      switch (nargout)
+        case 0
+          disp_path_list ("STATIC", static_path_list)
+          disp ("");
+          disp_path_list ("DYNAMIC", dynamic_path_list)
+
+        case 1
+          varargout{1} = cellstr (dynamic_path_list);
+
+        case 2
+          varargout{1} = cellstr (dynamic_path_list);
+          varargout{2} = cellstr (static_path_list);
+      endswitch
+        
+    case 1
+      switch (nargout)
+        case 0
+          if (strcmp (which, "-static"))
+            disp_path_list ("STATIC", static_path_list)
+          elseif (strcmp (which, "-dynamic"))
+            disp_path_list ("DYNAMIC", dynamic_path_list)
+          elseif (strcmp (which, "-all") == 1)
+            disp_path_list ("STATIC", static_path_list)
+            disp ("");
+            disp_path_list ("DYNAMIC", dynamic_path_list)
+          endif
+
+        case 1
+          if (strcmp (which, "-static") == 1)
+            varargout{1} = cellstr (static_path_list);
+          elseif (strcmp (which, "-dynamic") == 1)
+            varargout{1} = cellstr (dynamic_path_list);
+          elseif (strcmp (which, "-all") == 1)
+            varargout{1} = cellstr ([static_path_list, dynamic_path_list]);
+          endif
+      endswitch
+  endswitch
+  
+endfunction
+
+## Display cell array of paths
+
+function disp_path_list (which, path_list)
+  printf ("   %s JAVA PATH\n\n", which);
+  if (numel (path_list) > 0)
+    printf ("      %s\n", path_list{:});
+  else
+    printf ("      - empty -\n");
+  endif
+endfunction
+
diff --git a/scripts/java/javamem.m b/scripts/java/javamem.m
new file mode 100644
--- /dev/null
+++ b/scripts/java/javamem.m
@@ -0,0 +1,93 @@
+## Copyright (C) 2010 Philip Nienhuis
+## 
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {} javamem ()
+## @deftypefnx {Function File} {@var{jmem} =} javamem ()
+## Show the current memory usage of the Java virtual machine (JVM)
+## and run the garbage collector.
+##
+## When no return argument is given the info is printed to the screen.
+## Otherwise, the output cell array @var{jmem} contains Maximum, Total,
+## and Free memory (in bytes).
+##
+## All Java-based routines are run in the JVM's shared memory pool,
+## a dedicated and separate part of memory claimed by the JVM from
+## your computer's total memory (which comprises physical RAM and
+## virtual memory / swap space on hard disk).
+##
+## The maximum allowable memory usage can be set using the file java.opts
+## (in the same subdirectory where javaaddpath.m lives, see 
+## "which javaaddpath".  Usually that is:
+##
+## @file{OCTAVE_HOME/share/octave/OCTAVE_VERSION/m/java/}
+##
+## java.opts is a plain text file with one option per line.  The
+## default initial memory size and default maximum memory size (which
+## are both system dependent) can be overridden like so:
+##
+## @nospell{-Xms64m}
+##
+## @nospell{-Xmx512m}
+##
+## (in megabytes in this example.)
+## You can adapt these values to your own requirements if your system
+## has limited available physical memory or if you get Java memory
+## errors.
+##
+## "Total memory" is what the operating system has currently assigned
+## to the JVM and depends on actual and active memory usage.
+## "Free memory" is self-explanatory.  During operation of Java-based
+## Octave functions the amount of Total and Free memory will vary,
+## due to Java's own cleaning up and your operating system's memory
+## management.
+## @end deftypefn
+
+## Author: Philip Nienhuis
+## Created: 2010-03-25
+## Updates: 
+## 2010-03-26 Changed name to javamem & indentation to double spaces
+## 2010-08-25 Corrected text on java memory assignments
+## 2010-09-05 Further overhauled help text
+
+function jmem = javamem ()
+
+  rt = javaMethod ("getRuntime", "java.lang.Runtime");
+  rt.gc;
+  jvmem = cell (3, 1);
+  jvmem{1} = rt.maxMemory ();
+  jvmem{2} = rt.totalMemory ();
+  jvmem{3} = rt.freeMemory ();
+
+  if (nargout == 0)
+    printf ("\nJava virtual machine (JVM) memory info:\n");
+    printf ("Maximum available memory:        %5d MiB;\n",
+            jvmem{1} / 1024 / 1024);
+    printf ("   (...running garbage collector...)\n");
+    printf ("OK, current status:\n");
+    printf ("Total memory in virtual machine: %5d MiB;\n",
+            jvmem{2} / 1024 / 1024);
+    printf ("Free memory in virtual machine:  %5d MiB;\n",
+            jvmem{3} / 1024 / 1024);
+    printf ("%d CPUs available.\n", rt.availableProcessors ());
+  else
+    jmem = jvmem;
+  endif
+
+endfunction
+
diff --git a/scripts/java/javarmpath.m b/scripts/java/javarmpath.m
new file mode 100644
--- /dev/null
+++ b/scripts/java/javarmpath.m
@@ -0,0 +1,58 @@
+## Copyright (C) 2007 Michael Goffioul
+## Copyright (C) 2010 Martin Hepperle
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {} javarmpath (@var{clspath})
+## @deftypefnx {Function File} {} javarmpath (@var{clspath1}, @dots{})
+## Remove @var{clspath} from the dynamic class path of the Java virtual
+## machine.  @var{clspath} may either be a directory where @file{.class}
+## files are found, or a @file{.jar} file containing Java classes.
+## Multiple paths may be removed at once by specifying additional arguments.
+## @seealso{javaaddpath, javaclasspath}
+## @end deftypefn
+
+function javarmpath (varargin)
+
+  if (nargin < 1)
+    print_usage ();
+  endif
+
+  for i = 1:numel (varargin)
+    clspath = varargin{i};
+    if (! ischar (clspath))
+      error ("javarmpath: CLSPATH must be a string");
+    endif
+
+    old_path = canonicalize_file_name (tilde_expand (clspath));
+    if (exist (old_path, "dir"))
+      if (old_path(end) != filesep ())
+        old_path = [old_path, filesep()];
+      endif
+    endif
+
+    success = javaMethod ("removeClassPath", "org.octave.ClassHelper",
+                           old_path);
+
+    if (! success)
+      warning ("javarmpath: %s: not found in Java classpath", old_path);
+    endif
+  endfor
+
+endfunction
+
diff --git a/scripts/java/listdlg.m b/scripts/java/listdlg.m
new file mode 100644
--- /dev/null
+++ b/scripts/java/listdlg.m
@@ -0,0 +1,142 @@
+## Copyright (C) 2010 Martin Hepperle
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn {Function File} {[@var{sel}, @var{ok}] =} listdlg (@var{key}, @var{value}, @dots{})
+## Return user inputs from a list dialog box in a vector of 
+## selection indices @var{sel} and a flag @var{ok} indicating how the
+## user closed the dialog box.  The value of @var{ok} is 1 if the user
+## closed the box with the OK button, otherwise it is 0 and @var{sel} is
+## empty.
+##
+## The indices in @var{sel} are 1 based.
+##
+## The arguments are specified in form of @var{key}, @var{value} pairs. 
+## The @code{"ListString"} argument pair must be specified.
+##
+## Valid @var{key} and @var{value} pairs are:
+##
+## @table @code
+## @item "ListString"
+##    a cell array of strings comprising the content of the list.
+##
+## @item "SelectionMode"
+##    can be either @code{"Single"} or @code{"Multiple"} (default).
+##
+## @item "ListSize"
+##    a vector with two elements @var{width} and @var{height} defining
+##    the size of the list field in pixels.  Default is [160 300].
+##
+## @item "InitialValue"
+##    a vector containing 1-based indices of preselected elements.  Default
+##    is 1 (first item).
+##
+## @item "Name"
+##    a string to be used as the dialog caption.  Default is "".
+##
+## @item "PromptString"
+##    a cell array of strings to be displayed above the list field.  Default
+##    is @{@}.
+##
+## @item "OKString"
+##    a string used to label the OK button.  Default is "OK".
+##
+## @item "CancelString"
+##    a string used to label the Cancel button.  Default is "Cancel".
+## @end table
+##
+## Example:
+##
+## @example
+## @group
+## [sel, ok] = listdlg ("ListString", @{"An item", "another", "yet another"@},
+##                      "SelectionMode", "Multiple");
+## if (ok == 1)
+##   for i = 1:numel (sel)
+##     disp (sel(i));
+##   endfor
+## endif
+## @end group
+## @end example
+##
+## @seealso{errordlg, helpdlg, inputdlg, msgbox, questdlg, warndlg}
+## @end deftypefn
+
+function varargout = listdlg (varargin)
+
+   if (nargin < 2)
+     print_usage ();
+   endif
+   
+   listcell = {""};
+   selmode = "multiple";
+   listsize = [160, 300];
+   initialvalue = 1;
+   name = "";
+   prompt = {""};
+   okstring = "OK";
+   cancelstring = "Cancel";
+   
+   ## handle key, value pairs
+   for i = 1:2:nargin-1
+     if strcmp (varargin{i}, "ListString")
+       listcell = varargin{i+1};
+     elseif strcmp (varargin{i}, "SelectionMode")
+       selmode = varargin{i+1};
+     elseif strcmp (varargin{i}, "ListSize")
+       listsize = varargin{i+1};
+     elseif strcmp (varargin{i}, "InitialValue")
+       initialvalue = varargin{i+1};
+     elseif strcmp (varargin{i}, "Name")
+       name = varargin{i+1};
+     elseif strcmp (varargin{i}, "PromptString")
+       prompt = varargin{i+1};
+     elseif strcmp (varargin{i}, "OKString")
+       okstring = varargin{i+1};
+     elseif strcmp (varargin{i}, "CancelString")
+       cancelstring = varargin{i+1};
+     endif
+   endfor
+
+   ## make sure prompt strings are a cell array
+   if (! iscell (prompt))
+     prompt = {prompt};
+   endif
+
+   ## make sure listcell strings are a cell array
+   if (! iscell (listcell))
+     listcell = {listcell};
+   endif
+   
+   ## transform matrices to cell arrays of strings
+   ## swap width and height to correct calling format for JDialogBox
+   listsize = {num2str(listsize(2)), num2str(listsize(1))};
+   initialvalue = arrayfun (@num2str, initialvalue, "UniformOutput", false);
+   
+   ret = javaMethod ("listdlg", "org.octave.JDialogBox", listcell,
+                      selmode, listsize, initialvalue, name, prompt,
+                      okstring, cancelstring);
+
+   if (numel (ret) > 0)
+     varargout = {ret, 1};
+   else
+     varargout = {{}, 0};
+   endif
+
+endfunction
+
diff --git a/scripts/java/module.mk b/scripts/java/module.mk
new file mode 100644
--- /dev/null
+++ b/scripts/java/module.mk
@@ -0,0 +1,83 @@
+FCN_FILE_DIRS += java
+
+java_FCN_FILES = \
+  java/dlgtest.m \
+  java/errordlg.m \
+  java/helpdlg.m \
+  java/inputdlg.m \
+  java/javaArray.m \
+  java/javaaddpath.m \
+  java/javaclasspath.m \
+  java/javamem.m \
+  java/javarmpath.m \
+  java/listdlg.m \
+  java/msgbox.m \
+  java/questdlg.m \
+  java/usejava.m \
+  java/warndlg.m
+
+FCN_FILES += $(java_FCN_FILES)
+
+PKG_ADD_FILES += java/PKG_ADD
+
+DIRSTAMP_FILES += java/$(octave_dirstamp)
+
+if AMCOND_HAVE_JAVA
+JAR_FILES += java/octave.jar
+endif
+
+org_octave_dir = org/octave
+
+if AMCOND_HAVE_JAVA
+JAVA_SRC = \
+  $(org_octave_dir)/ClassHelper.java \
+  $(org_octave_dir)/OctClassLoader.java \
+  $(org_octave_dir)/Octave.java \
+  $(org_octave_dir)/OctaveReference.java \
+  $(org_octave_dir)/Matrix.java \
+  $(org_octave_dir)/JDialogBox.java \
+  $(org_octave_dir)/DlgListener.java \
+  $(org_octave_dir)/TeXtranslator.java \
+  $(org_octave_dir)/TeXcode.java
+endif
+
+JAVA_CLASSES = $(JAVA_SRC:.java=.class)
+
+JAVA_IMAGES = \
+  $(org_octave_dir)/images/question.png \
+  $(org_octave_dir)/images/error.png \
+  $(org_octave_dir)/images/warning.png \
+  $(org_octave_dir)/images/information.png \
+  $(org_octave_dir)/images/octave.png
+
+java_JAVA_SRC = $(addprefix java/, $(JAVA_SRC))
+
+java_JAVA_CLASSES = $(addprefix java/, $(JAVA_CLASSES))
+
+java_JAVA_IMAGES = $(addprefix java/, $(JAVA_IMAGES))
+
+srcdir_java_JAVA_IMAGES = $(addprefix $(srcdir)/java/, $(JAVA_IMAGES))
+
+%.class : %.java
+	$(MKDIR_P) java/$(org_octave_dir)
+	( cd $(srcdir)/java; "$(JAVAC)" -source 1.3 -target 1.3 -d $(abs_builddir)/java $(org_octave_dir)/$(<F) )
+
+java/images.stamp: $(srcdir_java_JAVA_IMAGES)
+	if [ "x$(srcdir)" != "x." ]; then \
+	  $(MKDIR_P) java/$(org_octave_dir)/images; \
+	  cp $(srcdir_java_JAVA_IMAGES) java/$(org_octave_dir)/images; \
+	fi
+	touch $@
+
+if AMCOND_HAVE_JAVA
+java/octave.jar: java/images.stamp $(java_JAVA_CLASSES)
+	( cd java; "$(JAR)" cf octave.jar.t $(JAVA_CLASSES) $(JAVA_IMAGES) )
+	mv $@.t $@
+endif
+
+EXTRA_DIST += $(JAR_FILES) $(java_JAVA_SRC) $(java_JAVA_IMAGES)
+
+CLEANFILES += $(JAR_FILES) $(java_JAVA_CLASSES)
+
+DISTCLEANFILES += java/images.stamp
+
diff --git a/scripts/java/msgbox.m b/scripts/java/msgbox.m
new file mode 100644
--- /dev/null
+++ b/scripts/java/msgbox.m
@@ -0,0 +1,76 @@
+## Copyright (C) 2010 Martin Hepperle
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {@var{h} =} msgbox (@var{msg})
+## @deftypefnx {Function File} {@var{h} =} msgbox (@var{msg}, @var{title})
+## @deftypefnx {Function File} {@var{h} =} msgbox (@var{msg}, @var{title}, @var{icon})
+## Display @var{msg} using a message dialog box. 
+##
+## The message may have multiple lines separated by newline characters
+## (@code{"\n"}), or it may be a cellstr array with one element for each
+## line.  The optional input @var{title} (character string) can be used to
+## decorate the dialog caption.
+##
+## The optional argument @var{icon} selects a dialog icon. 
+## It can be one of @code{"none"} (default), @code{"error"}, @code{"help"} or
+## @code{"warn"}.
+##
+## The return value is always 1.
+## @seealso{errordlg, helpdlg, inputdlg, listdlg, questdlg, warndlg}
+## @end deftypefn
+
+function h = msgbox (msg, title = "", icon)
+
+  if (nargin < 1 || nargin > 3)
+    print_usage ();
+  endif
+
+  if (! ischar (msg))
+    if (iscell (msg))
+      msg = sprintf ("%s\n", msg{:});
+      msg(end) = "";
+    else
+      error ("msgbox: MSG must be a character string or cellstr array");
+    endif
+  endif
+
+  if (! ischar (title))
+    error ("msgbox: TITLE must be a character string");
+  endif
+  
+  dlg = "emptydlg";
+  if (nargin == 3)
+    switch (icon)
+      case "error"
+        dlg = "errordlg";
+      case "help"
+        dlg = "helpdlg";
+      case "warn"
+        dlg = "warndlg";
+      case "none"
+        dlg = "emptydlg";
+      otherwise
+        error ("msgbox: ICON is not a valid type");
+    endswitch
+  endif
+
+  h = javaMethod (dlg, "org.octave.JDialogBox", msg, title);
+
+endfunction
+
diff --git a/scripts/java/org/octave/ClassHelper.java b/scripts/java/org/octave/ClassHelper.java
new file mode 100644
--- /dev/null
+++ b/scripts/java/org/octave/ClassHelper.java
@@ -0,0 +1,946 @@
+/*
+
+Copyright (C) 2007 Michael Goffioul
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or (at
+your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+package org.octave;
+
+import java.lang.reflect.*;
+
+public class ClassHelper
+{
+  private static OctClassLoader loader;
+
+  static
+  {
+    ClassLoader l = ClassHelper.class.getClassLoader ();
+    loader = (l instanceof OctClassLoader ? (OctClassLoader) l :
+              new OctClassLoader (l));
+  }
+
+
+  /**
+   * Add the given path to the classpath.
+   * @param name String - path to addd to the classpath
+   * @return boolean - true if the given path exists and was added to the classpath.
+   * @throws Exception
+   */
+  public static boolean addClassPath (String name)
+    throws Exception
+  {
+    boolean found = false;
+    java.io.File f = new java.io.File (name);
+    if (f.exists ())
+      {
+        loader.addClassPath (name);
+        found = true;
+      }
+    return (found);
+  }
+
+
+  // new -MH-
+  /**
+   *
+   * @param name String - path to remove from classpath.
+   * @return boolean - true if the given path existed in the classpath before it was removed.
+   * @throws Exception
+   */
+  public static boolean removeClassPath (String name)
+    throws Exception
+  {
+    boolean found = false;
+    java.io.File f = new java.io.File (name);
+    java.net.URL urlToRemove = f.toURI ().toURL ();
+    // save urls in current class path
+    java.net.URL[] urls = loader.getURLs ();
+
+    // create a completely new class loader because java.net.URLClassLoader has no removeClassPath() method
+    ClassLoader l = ClassHelper.class.getClassLoader ();
+    loader = (l instanceof OctClassLoader ? (OctClassLoader) l :
+              new OctClassLoader (l));
+
+    // add the previous urls back, except for the one
+    for (int i = 0; i < urls.length; i++)
+      {
+        java.net.URL url = urls[i];
+        if (!url.equals (urlToRemove))
+          {
+            loader.addURL (url);
+          }
+        else
+          {
+            // path to remove
+            found = true;
+          }
+      }
+
+    return (found);
+  }
+
+
+  public static String getClassPath ()
+  {
+    StringBuffer buf = new StringBuffer ();
+    String pathSep = System.getProperty ("path.separator");
+    java.net.URL[] urls = loader.getURLs ();
+
+    for (int i = 0; i < urls.length; i++)
+      {
+        try
+          {
+            java.io.File f = new java.io.File (urls[i].toURI ());
+            if (buf.length () > 0)
+              {
+                buf.append (pathSep);
+              }
+            buf.append (f.toString ());
+          }
+        catch (java.net.URISyntaxException ex)
+          {}
+      }
+    return buf.toString ();
+  }
+
+
+  // new -MH-
+  // return list of methods for given class name
+  public static String getMethods (String classname)
+    throws ClassNotFoundException
+  {
+    return (getMethods (Class.forName (classname)));
+  }
+
+
+  // new -MH-
+  // return list of methods for given class instance
+  public static String getMethods (Object obj)
+    throws ClassNotFoundException
+  {
+    return (getMethods (obj.getClass ()));
+  }
+
+
+  // new -MH-
+  // return list of methods for given class
+  public static String getMethods (Class klass)
+  {
+    StringBuffer sb = new StringBuffer ();
+
+    Method theMethod[] = klass.getMethods ();
+    for (int i = 0; i < theMethod.length; i++)
+      {
+        if (i > 0)
+          {
+            sb.append (";");
+          }
+        sb.append (theMethod[i].getReturnType ().getCanonicalName ());
+        sb.append (" ");
+        sb.append (theMethod[i].getName ());
+        sb.append ("(");
+
+        Class theParameter[] = theMethod[i].getParameterTypes ();
+        for (int j = 0; j < theParameter.length; j++)
+          {
+            if (j > 0)
+              {
+                sb.append (", ");
+              }
+            sb.append (theParameter[j].getCanonicalName ());
+          }
+        sb.append (")");
+
+        Class theExceptions[] = theMethod[i].getExceptionTypes ();
+        if (theExceptions.length > 0)
+          {
+            sb.append (" throws ");
+            for (int j = 0; j < theExceptions.length; j++)
+              {
+                if (j > 0)
+                  {
+                    sb.append (", ");
+                  }
+                sb.append (theExceptions[j].getCanonicalName ());
+              }
+          }
+      }
+
+    return (sb.toString ());
+  }
+
+
+  // new -MH-
+  // return list of fields for given class
+  public static String getFields (Class klass)
+  {
+    StringBuffer sb = new StringBuffer ();
+
+    Field theField[] = klass.getFields ();
+    for (int i = 0; i < theField.length; i++)
+      {
+        if (i > 0)
+          {
+            sb.append (";");
+          }
+        sb.append (theField[i].toString ());
+      }
+
+    return (sb.toString ());
+  }
+
+
+  // new -MH-
+  // return list of fields for given class name
+  public static String getFields (String classname)
+    throws ClassNotFoundException
+  {
+    return (getFields (Class.forName (classname)));
+  }
+
+
+  // new -MH-
+  // return list of fields for given class instance
+  public static String getFields (Object obj)
+    throws ClassNotFoundException
+  {
+    return (getFields (obj.getClass ()));
+  }
+
+
+  public static Method findMethod (Class cls, String name, Class[] argTypes)
+  {
+    try
+      {
+        return cls.getMethod (name, argTypes);
+      }
+    catch (Exception e)
+      {
+        Method[] mList = cls.getMethods ();
+        Method m;
+        for (int i = 0; i < mList.length; i++)
+          {
+            m = mList[i];
+            if (m.getName ().equals (name)
+                && m.getParameterTypes ().length == argTypes.length
+                && isCallableFrom (m, argTypes))
+              {
+                return m;
+              }
+          }
+        return null;
+      }
+  }
+
+
+  public static Constructor findConstructor (Class cls, Class[] argTypes)
+  {
+    try
+      {
+        return cls.getConstructor (argTypes);
+      }
+    catch (Exception e)
+      {
+        Constructor[] cList = cls.getConstructors ();
+        //System.out.println("# constructors: " + cList.length);
+        Constructor c;
+        for (int i = 0; i < cList.length; i++)
+          {
+            //System.out.println("Considering constructor: " + cList[i]);
+            c = cList[i];
+            if (c.getParameterTypes ().length == argTypes.length
+                && isCallableFrom (c, argTypes))
+              {
+                return c;
+              }
+          }
+        return null;
+      }
+  }
+
+
+  private static Object invokeMethod (Method m, Object target, Object[] args)
+    throws Exception
+  {
+    try
+      {
+        return m.invoke (target, args);
+      }
+    catch (IllegalAccessException ex)
+      {
+        String mName = m.getName ();
+        Class[] pTypes = m.getParameterTypes ();
+        Class currClass = target.getClass ();
+
+        while (currClass != null)
+          {
+            try
+              {
+                Method meth = currClass.getMethod (mName, pTypes);
+                if (!meth.equals (m))
+                  {
+                    return meth.invoke (target, args);
+                  }
+              }
+            catch (NoSuchMethodException ex2)
+              {}
+            catch (IllegalAccessException ex2)
+              {}
+
+            Class[] ifaceList = currClass.getInterfaces ();
+            for (int i = 0; i < ifaceList.length; i++)
+              {
+                try
+                  {
+                    Method meth = ifaceList[i].getMethod (mName, pTypes);
+                    return meth.invoke (target, args);
+                  }
+                catch (NoSuchMethodException ex2)
+                  {}
+                catch (IllegalAccessException ex2)
+                  {}
+              }
+
+            currClass = currClass.getSuperclass ();
+          }
+
+        throw ex;
+      }
+  }
+
+
+  public static Object invokeMethod (Object target, String name,
+                                     Object[] args, Class[] argTypes)
+    throws Throwable
+  {
+    Method m = findMethod (target.getClass (), name, argTypes);
+    if (m != null)
+      {
+        try
+          {
+            Object result = invokeMethod (m, target,
+                                          castArguments (args, argTypes,
+                                                         m.getParameterTypes ()));
+            return result;
+          }
+        catch (InvocationTargetException ex)
+          {
+            throw ex.getCause ();
+          }
+      }
+    else
+      {
+        throw new NoSuchMethodException (name);
+      }
+  }
+
+
+  public static Object invokeStaticMethod (String cls, String name,
+                                           Object[] args, Class[] argTypes)
+    throws Throwable
+  {
+    Method m = findMethod (Class.forName (cls, true, loader), name,
+                           argTypes);
+    if (m != null)
+      {
+        try
+          {
+            Object result = m.invoke (null,
+                                      castArguments (args, argTypes,
+                                                     m.getParameterTypes ()));
+            return result;
+          }
+        catch (InvocationTargetException ex)
+          {
+            throw ex.getCause ();
+          }
+      }
+    else
+      {
+        throw new NoSuchMethodException (name);
+      }
+  }
+
+
+  public static Object invokeConstructor (String cls, Object[] args,
+                                          Class[] argTypes)
+    throws Throwable
+  {
+    Constructor c = findConstructor (Class.forName (cls, true, loader),
+                                     argTypes);
+    if (c != null)
+      {
+        try
+          {
+            Object result = c.newInstance (castArguments (args, argTypes,
+                                                          c.getParameterTypes ()));
+            return result;
+          }
+        catch (InvocationTargetException ex)
+          {
+            throw ex.getCause ();
+          }
+      }
+    else
+      {
+        throw new NoSuchMethodException (cls);
+      }
+  }
+
+
+  public static Object getField (Object target, String name)
+    throws Throwable
+  {
+    try
+      {
+        Field f = target.getClass ().getField (name);
+        return f.get (target);
+      }
+    catch (NoSuchFieldException ex)
+      {
+        try
+          {
+            return invokeMethod (target, name, new Object[0], new Class[0]);
+          }
+        catch (NoSuchMethodException ex2)
+          {
+            throw ex;
+          }
+      }
+  }
+
+
+  public static Object getStaticField (String cls, String name)
+    throws Throwable
+  {
+    try
+      {
+        Field f = Class.forName (cls, true, loader).getField (name);
+        return f.get (null);
+      }
+    catch (NoSuchFieldException ex)
+      {
+        try
+          {
+            return invokeStaticMethod (cls, name, new Object[0], new Class[0]);
+          }
+        catch (NoSuchMethodException ex2)
+          {
+            throw ex;
+          }
+      }
+  }
+
+
+  public static void setField (Object target, String name, Object value)
+    throws Exception
+  {
+    Field f = target.getClass ().getField (name);
+    f.set (target, castArgument (value, value.getClass (), f.getType ()));
+  }
+
+
+  public static void setStaticField (String cls, String name, Object value)
+    throws Exception
+  {
+    Field f = Class.forName (cls, true, loader).getField (name);
+    f.set (null, castArgument (value, value.getClass (), f.getType ()));
+  }
+
+
+  private static boolean isCallableFrom (Method m, Class[] argTypes)
+  {
+    Class[] expTypes = m.getParameterTypes ();
+    for (int i = 0; i < argTypes.length; i++)
+      {
+        if (!isCallableFrom (expTypes[i], argTypes[i]))
+          {
+            return false;
+          }
+      }
+    return true;
+  }
+
+
+  private static boolean isCallableFrom (Constructor c, Class[] argTypes)
+  {
+    Class[] expTypes = c.getParameterTypes ();
+    for (int i = 0; i < argTypes.length; i++)
+      {
+        if (!isCallableFrom (expTypes[i], argTypes[i]))
+          {
+            return false;
+          }
+      }
+    return true;
+  }
+
+
+  private static boolean isCallableFrom (Class expCls, Class argCls)
+  {
+    //System.out.println("isCallableFrom: "+expCls.getCanonicalName() + " <=? " + argCls.getCanonicalName());
+    if (argCls == null)
+      {
+        return!expCls.isPrimitive ();
+      }
+    else if (expCls.isAssignableFrom (argCls))
+      {
+        return true;
+      }
+    else if ((isNumberClass (expCls) || isBooleanClass (expCls))
+             && isNumberClass (argCls))
+      {
+        return true;
+      }
+    else if (isCharClass (expCls) && argCls.equals (Character.class))
+      {
+        /*
+          modified into a more strict check to avoid char to string matching
+          to avoid matching method signatureslike
+          java_method(char) with octave_call('a String')
+          Date: 28-08-2010
+          Author: Martin Hepperle
+        */
+        return true;
+      }
+    else if (isStringClass (expCls) && argCls.equals (String.class))
+      {
+        /*
+          added for strict String to String matching
+          java_method(String) with octave_call('a String')
+          but not
+          java_method(char) with octave_call('a String')
+          Date: 28-08-2010
+          Author: Martin Hepperle
+        */
+        return true;
+      }
+    else if (expCls.isArray () && argCls.isArray ()
+             && isCallableFrom (expCls.getComponentType (),
+                                argCls.getComponentType ()))
+      {
+        return true;
+      }
+    else if (expCls.equals (Object.class) && argCls.isPrimitive ())
+      {
+        return true;
+      }
+    else
+      {
+        return false;
+      }
+  }
+
+
+  private static boolean isNumberClass (Class cls)
+  {
+    return (cls.equals (Integer.TYPE) || cls.equals (Integer.class)
+            || cls.equals (Short.TYPE) || cls.equals (Short.class)
+            || cls.equals (Long.TYPE) || cls.equals (Long.class)
+            || cls.equals (Float.TYPE) || cls.equals (Float.class)
+            || cls.equals (Double.TYPE) || cls.equals (Double.class));
+  }
+
+
+  private static boolean isBooleanClass (Class cls)
+  {
+    return (cls.equals (Boolean.class) || cls.equals (Boolean.TYPE));
+  }
+
+
+  private static boolean isCharClass (Class cls)
+  {
+    return (cls.equals (Character.class) || cls.equals (Character.TYPE));
+  }
+
+
+  /**
+   * Check whether the supplied class is a String class.
+   *
+   * Added for more strict char/string mathicng of method signatures
+   * Date: 28-08-2010
+   * Author: Martin Hepperle
+   * @param cls Class - the class to check
+   * @return boolean - true if clas is of class java.lang.String
+   */
+  private static boolean isStringClass (Class cls)
+  {
+    return (
+            cls.equals (String.class)
+            );
+  }
+
+
+  private static Object[] castArguments (Object[] args, Class[] argTypes,
+                                         Class[] expTypes)
+  {
+    for (int i = 0; i < args.length; i++)
+      {
+        args[i] = castArgument (args[i], argTypes[i], expTypes[i]);
+      }
+    return args;
+  }
+
+
+  private static Object castArgument (Object obj, Class type, Class expType)
+  {
+    // System.out.println("expType:"+expType.getCanonicalName() + " <= type:" + type.getCanonicalName());
+    if (type == null || expType.isAssignableFrom (type))
+      {
+        return obj;
+      }
+    else if (isNumberClass (expType))
+      {
+        if (expType.equals (Integer.TYPE) || expType.equals (Integer.class))
+          {
+            return new Integer (((Number) obj).intValue ());
+          }
+        else if (expType.equals (Double.TYPE) || expType.equals (Double.class))
+          {
+            return new Double (((Number) obj).doubleValue ());
+          }
+        else if (expType.equals (Short.TYPE) || expType.equals (Short.class))
+          {
+            return new Short (((Number) obj).shortValue ());
+          }
+        else if (expType.equals (Long.TYPE) || expType.equals (Long.class))
+          {
+            return new Long (((Number) obj).longValue ());
+          }
+      }
+    else if (isBooleanClass (expType))
+      {
+        return new Boolean (((Number) obj).intValue () != 0);
+      }
+    else if (isCharClass (expType))
+      {
+        String s = obj.toString ();
+        if (s.length () != 1)
+          {
+            throw new ClassCastException ("cannot cast " + s + " to character");
+          }
+        return new Character (s.charAt (0));
+      }
+    else if (expType.isArray () && type.isArray ())
+      {
+        return castArray (obj, type.getComponentType (),
+                          expType.getComponentType ());
+      }
+    else if (type.isPrimitive ())
+      {
+        return obj;
+      }
+    return null;
+  }
+
+
+  private static Object castArray (Object obj, Class elemType,
+                                   Class elemExpType)
+  {
+    int len = Array.getLength (obj);
+    Object result = Array.newInstance (elemExpType, len);
+    for (int i = 0; i < len; i++)
+      {
+        Array.set (result, i,
+                   castArgument (Array.get (obj, i), elemType, elemExpType));
+      }
+    return result;
+  }
+
+
+  private static int getArrayClassNDims (Class cls)
+  {
+    if (cls != null && cls.isArray ())
+      {
+        return (1 + getArrayClassNDims (cls.getComponentType ()));
+      }
+    else
+      {
+        return 0;
+      }
+  }
+
+
+  private static Class getArrayElemClass (Class cls)
+  {
+    if (cls.isArray ())
+      {
+        return getArrayElemClass (cls.getComponentType ());
+      }
+    else
+      {
+        return cls;
+      }
+  }
+
+
+  private static Object getArrayElements (Object array, int[][] idx,
+                                          int offset,
+                                          int ndims, Class elemType)
+  {
+    if (offset >= ndims)
+      {
+        Object elem = Array.get (array, idx[offset][0]);
+        if (offset < idx.length - 1)
+          {
+            return getArrayElements (elem, idx, offset + 1, ndims, elemType);
+          }
+        else
+          {
+            return elem;
+          }
+      }
+    else
+      {
+        Class compType = elemType.getComponentType ();
+        Object retval = Array.newInstance (compType, idx[offset].length);
+        for (int i = 0; i < idx[offset].length; i++)
+          {
+            Object elem = Array.get (array, idx[offset][i]);
+            if (offset < idx.length - 1)
+              {
+                elem = getArrayElements (elem, idx, offset + 1, ndims, compType);
+              }
+            Array.set (retval, i, elem);
+          }
+        return retval;
+      }
+  }
+
+
+  public static Object arraySubsref (Object obj, int[][] idx)
+    throws Exception
+  {
+    if (!obj.getClass ().isArray ())
+      {
+        throw new IllegalArgumentException ("not a Java array");
+      }
+
+    if (idx.length == 1)
+      {
+        if (idx[0].length == 1)
+          {
+            return Array.get (obj, idx[0][0]);
+          }
+        else
+          {
+            Object retval = Array.newInstance (obj.getClass ().
+                                               getComponentType (),
+                                               idx[0].length);
+            for (int i = 0; i < idx[0].length; i++)
+              {
+                Array.set (retval, i, Array.get (obj, idx[0][i]));
+              }
+            return retval;
+          }
+      }
+    else
+      {
+        int[] dims = new int[idx.length];
+        for (int i = 0; i < idx.length; i++)
+          {
+            dims[i] = idx[i].length;
+          }
+
+        if (dims.length != getArrayClassNDims (obj.getClass ()))
+          {
+            throw new IllegalArgumentException ("index size mismatch");
+          }
+
+        /* resolve leading singletons */
+        Object theObj = obj;
+        int offset = 0;
+        while (dims[offset] == 1)
+          {
+            theObj = Array.get (theObj, idx[offset][0]);
+            offset = offset + 1;
+            if (offset >= dims.length)
+              {
+                return theObj;
+              }
+          }
+        if (offset > 0)
+          {
+            int[][] new_idx = new int[idx.length - offset][];
+            System.arraycopy (idx, offset, new_idx, 0, idx.length - offset);
+            return arraySubsref (theObj, new_idx);
+          }
+
+        /* chop trailing singletons */
+        int ndims = dims.length;
+        while (ndims > 1 && dims[ndims - 1] == 1)
+          {
+            ndims--;
+          }
+
+        /* create result array */
+        Class elemClass = theObj.getClass ();
+        for (int i = 0; i <= (dims.length - ndims); i++)
+          {
+            elemClass = elemClass.getComponentType ();
+          }
+        Object retval = Array.newInstance (elemClass, dims[0]);
+
+        /* fill-in array */
+        for (int i = 0; i < idx[0].length; i++)
+          {
+            Object elem = getArrayElements (Array.get (theObj, idx[0][i]),
+                                            idx, 1, ndims, elemClass);
+            Array.set (retval, i, elem);
+          }
+
+        return retval;
+      }
+  }
+
+
+  private static Object setArrayElements (Object array, int[][] idx,
+                                          int offset, int ndims, Object rhs)
+    throws Exception
+  {
+    if (offset >= ndims)
+      {
+        if (offset < idx.length - 1)
+          {
+            setArrayElements (Array.get (array, idx[offset][0]), idx,
+                              offset + 1, ndims, rhs);
+          }
+        else
+          {
+            Array.set (array, idx[offset][0], rhs);
+          }
+        return array;
+      }
+    else
+      {
+        for (int i = 0; i < idx[offset].length; i++)
+          {
+            if (offset < idx.length - 1)
+              {
+                setArrayElements (Array.get (array, idx[offset][i]), idx,
+                                  offset + 1, ndims, Array.get (rhs, i));
+              }
+            else
+              {
+                Array.set (array, idx[offset][i], Array.get (rhs, i));
+              }
+          }
+        return array;
+      }
+  }
+
+
+  public static Object arraySubsasgn (Object obj, int[][] idx, Object rhs)
+    throws Exception
+  {
+    if (!obj.getClass ().isArray ())
+      {
+        throw new IllegalArgumentException ("not a Java array");
+      }
+
+    if (idx.length == 1)
+      {
+        if (idx[0].length == 1)
+          {
+            Array.set (obj, idx[0][0], rhs);
+          }
+        else
+          {
+            for (int i = 0; i < idx[0].length; i++)
+              {
+                Array.set (obj, idx[0][i], Array.get (rhs, i));
+              }
+          }
+        return obj;
+      }
+    else
+      {
+        int[] dims = new int[idx.length];
+        for (int i = 0; i < idx.length; i++)
+          {
+            dims[i] = idx[i].length;
+          }
+
+        if (dims.length != getArrayClassNDims (obj.getClass ()))
+          {
+            throw new IllegalArgumentException ("index size mismatch");
+          }
+
+        /* resolve leading singletons */
+        Object theObj = obj;
+        int offset = 0;
+        while (dims[offset] == 1 && offset < (dims.length - 1))
+          {
+            theObj = Array.get (theObj, idx[offset][0]);
+            offset = offset + 1;
+          }
+        if (offset > 0)
+          {
+            int[][] new_idx = new int[idx.length - offset][];
+            System.arraycopy (idx, offset, new_idx, 0, idx.length - offset);
+            arraySubsasgn (theObj, new_idx, rhs);
+            return obj;
+          }
+
+        /* chop trailing singletons */
+        int ndims = dims.length;
+        while (ndims > 1 && dims[ndims - 1] == 1)
+          {
+            ndims--;
+          }
+
+        for (int i = 0; i < idx[0].length; i++)
+          {
+            setArrayElements (Array.get (theObj, idx[0][i]), idx, 1, ndims,
+                              Array.get (rhs, i));
+          }
+
+        return obj;
+      }
+  }
+
+
+  public static Object createArray (Object cls, int[] dims)
+    throws Exception
+  {
+    Class theClass;
+    if (cls instanceof Class)
+      {
+        theClass = (Class) cls;
+      }
+    else if (cls instanceof String)
+      {
+        theClass = Class.forName ((String) cls, true, loader);
+      }
+    else
+      {
+        throw new IllegalArgumentException ("invalid class specification " +
+                                            cls);
+      }
+
+    return Array.newInstance (theClass, dims);
+  }
+
+
+  public static Object createArray (Object cls, int length)
+    throws Exception
+  {
+    return createArray (cls, new int[] {length});
+  }
+}
diff --git a/scripts/java/org/octave/DlgListener.java b/scripts/java/org/octave/DlgListener.java
new file mode 100644
--- /dev/null
+++ b/scripts/java/org/octave/DlgListener.java
@@ -0,0 +1,164 @@
+/*
+
+Copyright (C) 2010 Martin Hepperle
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or (at
+your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+package org.octave;
+
+import java.awt.event.*;
+import javax.swing.*;
+
+/**
+ * <p>Implements button click actions for dialog box functions</p>
+ *
+ * <p>Copyright (c) 2010 Martin Hepperle</p>
+ *
+ * @author Martin Hepperle
+ * @version 1.0
+ */
+public class DlgListener
+  extends WindowAdapter implements ActionListener, KeyListener
+{
+  // the parent frame of the dialog
+  JDialogBox m_Parent;
+
+  public DlgListener (JDialogBox d)
+  {
+    m_Parent = d;
+  }
+
+
+  //
+  // --- extension of the WindowAdapter class ---
+  //
+  /**
+   * Called when the user clicks the close button on the window frame.
+   *
+   * @param e WindowEvent
+   */
+  public void windowClosing (WindowEvent e)
+  {
+    m_Parent.closeDialog (JDialogBox.CLOSE_CANCEL);
+  }
+
+  public void windowOpened(WindowEvent e)
+  {
+    m_Parent.setFocus();
+  }
+
+
+  //
+  // --- implementation of the ActionListener interface ---
+  //
+  /**
+   * Called when the user clicks a button in the dialog.
+   * Closes the dialog when either a button with an
+   * action command OK, CANCEL or NO is pressed.
+   *
+   * @param e ActionEvent
+   */
+  public void actionPerformed (ActionEvent e)
+  {
+    if (e.getActionCommand ().equals ("OK"))
+      {
+        m_Parent.closeDialog (JDialogBox.CLOSE_OK);
+      }
+    else if (e.getActionCommand ().equals ("CANCEL"))
+      {
+        m_Parent.closeDialog (JDialogBox.CLOSE_CANCEL);
+      }
+    else if (e.getActionCommand ().equals ("NO"))
+      {
+        m_Parent.closeDialog (JDialogBox.CLOSE_NO);
+      }
+    else if (e.getActionCommand ().equals ("SELALL"))
+      {
+        m_Parent.SelectAll ();
+      }
+  }
+
+
+  //
+  // --- implementation of the KeyListener interface ---
+  //
+  /**
+   * Closes the dialog when the ENTER or ESCAPE keys are released.
+   *
+   * @param e KeyEvent
+   */
+  public void keyTyped (KeyEvent e)
+  {
+    if (e.getKeyCode () == KeyEvent.VK_ESCAPE)
+      {
+        m_Parent.closeDialog (JDialogBox.CLOSE_CANCEL);
+      }
+  }
+
+
+  /**
+   * @param e KeyEvent
+   */
+  public void keyPressed (KeyEvent e)
+  {
+    if (e.getSource ().getClass ().equals (JTextArea.class))
+      {
+        JTextArea ta = (JTextArea) e.getSource ();
+        if (e.getKeyCode () == KeyEvent.VK_ENTER)
+          {
+            char c[] = ta.getText ().toCharArray ();
+            int nLines = 1;
+            for (int i = 0; i < c.length; i++)
+              {
+                if (c[i] == '\n')
+                  {
+                    nLines++;
+                  }
+              }
+
+            if (nLines >= ta.getRows ())
+              {
+                e.consume ();
+              }
+          }
+        else if (e.getKeyCode () == KeyEvent.VK_TAB)
+          {
+            e.consume ();
+
+            if ((e.getModifiersEx () & KeyEvent.SHIFT_DOWN_MASK) ==
+                KeyEvent.SHIFT_DOWN_MASK)
+              {
+                ta.transferFocusBackward();
+              }
+            else
+              {
+                ta.transferFocus ();
+              }
+          }
+      }
+  }
+
+
+  /**
+   * @param e KeyEvent
+   */
+  public void keyReleased (KeyEvent e)
+  {
+  }
+}
diff --git a/scripts/java/org/octave/JDialogBox.java b/scripts/java/org/octave/JDialogBox.java
new file mode 100644
--- /dev/null
+++ b/scripts/java/org/octave/JDialogBox.java
@@ -0,0 +1,991 @@
+/*
+
+Copyright (C) 2010 Martin Hepperle
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or (at
+your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+package org.octave;
+
+import java.net.*;
+import java.util.*;
+
+import java.awt.*;
+import javax.swing.*;
+
+/**
+ * <p>Implementation of various dialog box functions</p>
+ *
+ * <p>The following functions are provided for being called via
+ * Octave script files:</p>
+ * <ul>
+ * <li>errordlg</li>
+ * <li>helpdlg</li>
+ * <li>inputdlg</li>
+ * </ul>
+ *
+ * <p>Copyright (c) 2010 Martin Hepperle</p>
+ *
+ * @author Martin Hepperle
+ * @version 1.0
+ */
+public class JDialogBox
+{
+  public static final int CLOSE_OK = 1;
+  public static final int CLOSE_NO = 2;
+  public static final int CLOSE_CANCEL = 3;
+
+  // dialog type
+  public static int FLAG_LABEL = 1;
+  public static int FLAG_TEXT = 2;
+  public static int FLAG_INPUT = 4;
+  public static int FLAG_LIST = 8;
+  // icon selection
+  public static int FLAG_QUESTION = 32;
+  public static int FLAG_ERROR = 64;
+  public static int FLAG_WARNING = 128;
+  public static int FLAG_INFORMATION = 256;
+
+  public static int DLG_QUEST = FLAG_QUESTION | FLAG_TEXT;
+  public static int DLG_INPUT = FLAG_QUESTION | FLAG_INPUT;
+  public static int DLG_LIST = FLAG_QUESTION | FLAG_LIST;
+
+  private final static String m_OK = "OK";
+  private final static String m_Yes = "Yes";
+  private final static String m_No = "No";
+  private final static String m_Cancel = "Cancel";
+
+  private JButton m_ButtonNO;
+  private JButton m_ButtonOK;
+  private JButton m_ButtonCANCEL;
+  private JButton m_Focus;
+  private JTextArea m_TextField[];
+  private JList m_List;
+  private JFrame m_ParentFrame;
+  private int m_CloseMethod;
+
+  // ------------------------------------
+  // implementation of listdlg function
+  // ------------------------------------
+
+  /**
+   *
+   * @param listcell String[] - a array of strings, one for each list entry
+   * @param selmode String
+   * @param sizecell Object[]
+   * @param initialcell Object[]
+   * @param name String
+   * @param promptcell String[]
+   * @param okstring String
+   * @param cancelstring String
+   * @return String[]
+   */
+  public static int[] listdlg (String[] listcell,
+                               String selmode,
+                               Object[] sizecell,
+                               Object[] initialcell,
+                               String name,
+                               String[] promptcell,
+                               String okstring,
+                               String cancelstring)
+  {
+    JDialogBox d = new JDialogBox ();
+    d.genericdlg (promptcell, listcell, name, selmode,
+                  DLG_LIST,
+                  sizecell, initialcell, okstring, null, cancelstring);
+    return (d.getSelectedIndices ());
+  }
+
+
+  // ------------------------------------
+  // implementation of inputdlg function
+  // -------------------------------------
+
+  /**
+   * Implements a variation of the inputdlg function.
+   *
+   * @param prompt String[] - an array of text strings to be used as labels.
+   * @param title String - a text string to be used to label the dialog caption.
+   * @param RowsCols int - defines the width of the text fields in columns.
+   * @param defaults Object[] - an array of text strings or numbers to be
+   * placed into the text fields as default values.
+   * @return String[] - an array of text strings containing the content of the
+   * text fields.
+   */
+  public static String[] inputdlg (String[] prompt,
+                                   String title,
+                                   Object[] RowsCols,
+                                   Object[] defaults)
+  {
+    JDialogBox d = new JDialogBox ();
+    d.genericdlg (prompt, null, title, "on",
+                  FLAG_INPUT | FLAG_QUESTION,
+                  RowsCols, defaults, m_OK, null, m_Cancel);
+    return (d.getInput ());
+  }
+
+
+  /**
+   * Extract the current content from the text fields of an inputdlg.
+   *
+   * @return String[] - the text contained in the fields of an inputdlg.
+   * null if the dialog was cancelled.
+   */
+  private String[] getInput ()
+  {
+    String s[] = null;
+
+    if (m_CloseMethod == CLOSE_OK)
+      {
+        s = new String[m_TextField.length];
+
+        for (int i = 0; i < s.length; i++)
+          {
+            s[i] = new String (m_TextField[i].getText ());
+          }
+      }
+
+    return (s);
+  }
+
+
+  private String getResult ()
+  {
+    String s = null;
+
+    if (m_CloseMethod == CLOSE_OK)
+      {
+        s = m_ButtonOK.getText ();
+      }
+    else if (m_CloseMethod == CLOSE_CANCEL)
+      {
+        s = m_ButtonCANCEL.getText ();
+      }
+    else
+      {
+        s = m_ButtonNO.getText ();
+      }
+
+    return (s);
+  }
+
+
+  /**
+   * Extract the current content from the text fields of an inputdlg.
+   *
+   * @return String[] - the text contained in the fields of an inputdlg.
+   * null if the dialog was cancelled.
+   */
+  private String[] getSelection ()
+  {
+    String s[] = null;
+
+    if (m_CloseMethod == CLOSE_OK)
+      {
+        int selection[] = m_List.getSelectedIndices ();
+
+        s = new String[selection.length];
+
+        for (int i = 0; i < s.length; i++)
+          {
+
+            // s[i] = new String (Integer.toString(selection[i]));
+            s[i] = (m_List.getSelectedValues ()[i]).toString ();
+          }
+      }
+
+    return (s);
+  }
+
+
+  private int[] getSelectedIndices ()
+  {
+    int s[] = null;
+
+    if (m_CloseMethod == CLOSE_OK)
+      {
+        s = m_List.getSelectedIndices ();
+        for (int i = 0; i < s.length; i++)
+          {
+
+            // translate to 1 based indices
+            s[i] = s[i] + 1;
+          }
+      }
+
+    return (s);
+  }
+
+
+  public void SelectAll ()
+  {
+    if (null != m_List)
+      {
+        m_List.setSelectionInterval (0, m_List.getModel ().getSize () - 1);
+      }
+  }
+
+
+  // -------------------------------------
+  // implementation of helpdlg function
+  // -------------------------------------
+
+  /**
+   * Implements a simple helpdlg with default text and caption. Not very useful.
+   *
+   * Octave > helpdlg('helpstring','title')
+   *
+   * Called via helpdlg.m.
+   *
+   * @param helpstring String - a message string to be presented to the user.
+   * The string can have embedded newline (\n) characters to break the message
+   * into multiple lines.
+   * @param title String - a text string to be used to label the dialog caption.
+   * @return int - always 1
+   */
+  public static int helpdlg (String helpstring, String title)
+  {
+    JDialogBox d = new JDialogBox ();
+    String s[] = new String[1];
+    s[0] = helpstring;
+    return (d.genericdlg (s, null, title, "on",
+                          FLAG_TEXT | FLAG_INFORMATION, null, null,
+                          m_OK, null, m_Cancel));
+  }
+
+
+  // -------------------------------------
+  // implementation of emptydlg function
+  // -------------------------------------
+
+  /**
+   * Implements a simple helpdlg with default text and caption. Not very useful.
+   *
+   * Octave > emptydlg('messagestring','title')
+   *
+   * Called via dlgbox.m.
+   *
+   * @param messagestring String - a message string to be presented to the user.
+   * The string can have embedded newline (\n) characters to break the message
+   * into multiple lines.
+   * @param title String - a text string to be used to label the dialog caption.
+   * @return int - always 1
+   */
+  public static int emptydlg (String helpstring, String title)
+  {
+    JDialogBox d = new JDialogBox ();
+    String s[] = new String[1];
+    s[0] = helpstring;
+    return (d.genericdlg (s, null, title, "on",
+                          FLAG_TEXT, null, null,
+                          m_OK, null, m_Cancel));
+  }
+
+
+  // -------------------------------------------
+  // implementation of questdlg related functions
+  // -------------------------------------------
+
+  /**
+   * Implements a simple questdlg with default text and caption. Not very useful.
+   *
+   * @param question String - the question to be presented
+   * @param title String - the caption
+   * @param options String[] - 'str1', 'str2', 'str3', 'default'
+   * @return String - the caption of the button pressed by the user
+   */
+  public static String questdlg (String question,
+                                 String title,
+                                 String[] options)
+  {
+    JDialogBox d = new JDialogBox ();
+    String s[] = new String[1];
+    s[0] = question;
+    d.genericdlg (s, options, title, "on",
+                  DLG_QUEST, null, null,
+                  options[0], options[1], options[2]);
+    return (d.getResult ());
+  }
+
+
+  // -------------------------------------
+  // implementation of errordlg function
+  // -------------------------------------
+
+  /**
+   * Implements a simple errordlg with default text and caption. Not very useful.
+   *
+   * @param errorstring String - the error message to display.
+   * @param dlgname String - the caption of the dialog box.
+   * @return int - always 1
+   */
+  public static int errordlg (String errorstring, String dlgname)
+  {
+    JDialogBox d = new JDialogBox ();
+    String s[] = new String[1];
+    s[0] = errorstring;
+    return (d.genericdlg (s, null, dlgname, "on", FLAG_TEXT | FLAG_ERROR,
+                          null, null,
+                          m_OK, null, m_Cancel));
+  }
+
+
+  // -------------------------------------------
+  // implementation of warndlg related functions
+  // -------------------------------------------
+
+  /**
+   * Implements a simple warndlg with default text and caption. Not very useful.
+   *
+   * Called via warndlg.m.
+   *
+   * @param errorstring String - the message to be presented to the user.
+   * @param dlgname String - the caption of the dialog box.
+   * @return int - always 1
+   */
+  public static int warndlg (String errorstring, String dlgname)
+  {
+    JDialogBox d = new JDialogBox ();
+    String s[] = new String[1];
+    s[0] = errorstring;
+    return (d.genericdlg (s, null, dlgname, "on", FLAG_TEXT | FLAG_WARNING,
+                          null, null,
+                          m_OK, null, m_Cancel));
+  }
+
+
+  // -------------------------------------
+  // generic dlg function
+  // -------------------------------------
+  /**
+   * A generic dialog creation and display function.
+   *
+   * @param message String[]
+   * @param list String[]
+   * @param caption String
+   * @param on String
+   * @param flag int
+   * @param RowsCols Object[]
+   * @param defaults Object[]
+   * @param okstring String
+   * @param nostring String
+   * @param cancelstring String
+   * @return int
+   */
+  public int genericdlg (String message[],
+                         String list[],
+                         String caption,
+                         String on,
+                         int flag,
+                         Object[] RowsCols,
+                         Object[] defaults,
+                         String okstring,
+                         String nostring,
+                         String cancelstring)
+  {
+    TeXtranslator theTranslator = new TeXtranslator ();
+    setSystemLnF (true);
+
+    caption = theTranslator.replace (caption);
+
+    m_ButtonNO = null;
+    m_ButtonOK = null;
+    m_ButtonCANCEL = null;
+
+    // create a modal dialog with an empty frame as its parent
+    m_ParentFrame = new JFrame ();
+
+    // --- trick to bring dialog to the front
+    // In Windows, the dialog is not brought to the foreground, but hidden
+    // behind the Octave window as long as the parent frame is not visible.
+    // To avoid that the frame is visible, we move it outside of the screen.
+    m_ParentFrame.setBounds (Toolkit.getDefaultToolkit ().getScreenSize ().
+                             width + 100,
+                             Toolkit.getDefaultToolkit ().getScreenSize ().
+                             height + 100, 1, 1);
+    m_ParentFrame.setVisible (true);
+    //-- end of trick
+
+    JDialog dlg;
+    dlg = new JDialog (m_ParentFrame);
+    dlg.setTitle (caption);
+
+    dlg.setModal (true);
+    dlg.setDefaultCloseOperation (JDialog.DISPOSE_ON_CLOSE);
+
+    DlgListener theListener = new DlgListener (this);
+
+    Container d = dlg.getContentPane ();
+    d.setLayout (new BorderLayout (8, 8));
+
+    // spacer
+    d.add (new JLabel (" "), BorderLayout.NORTH);
+    d.add (new JLabel ("  "), BorderLayout.EAST);
+
+    JPanel p = new JPanel ();
+
+    if (FLAG_LABEL == (FLAG_LABEL & flag))
+      {
+        // a single line label
+        JLabel l = new JLabel (theTranslator.replace (message[0]));
+        p.add (l);
+      }
+    else if (FLAG_TEXT == (FLAG_TEXT & flag))
+      {
+        String msg = theTranslator.replace (message[0]);
+        // a multi-line text display for helpdlg
+        StringTokenizer st = new StringTokenizer (msg, "\n");
+
+        int nRows = (null == RowsCols) ? 1 :
+          Integer.parseInt (RowsCols[0].toString ());
+        nRows = Math.max (nRows, st.countTokens ());
+        int nCols = Math.max (1, msg.length () / nRows);
+
+        p.setLayout (new GridLayout (message.length, 1));
+        JTextArea ta = new JTextArea (msg, nRows, nCols);
+        ta.setEditable (false);
+        ta.setFocusable (false);
+        ta.setOpaque (false);
+        // replace ugly monospaced font
+        ta.setFont (p.getFont ());
+        p.add (ta);
+      }
+    else if (FLAG_INPUT == (FLAG_INPUT & flag))
+      {
+        // a multi label/textfield entry dialog for inputdlg
+        GridBagConstraints gbc = new GridBagConstraints ();
+        gbc.insets.top = 4;
+        gbc.insets.left = 8;
+        gbc.gridx = 0;
+        gbc.anchor = GridBagConstraints.NORTHWEST;
+
+        p.setLayout (new GridBagLayout ());
+        m_TextField = new JTextArea[message.length];
+
+        // default values
+        int nRows = 1;
+        int nCols = 10;
+
+        for (int i = 0; i < message.length; i++)
+          {
+            String msg = theTranslator.replace (message[i]);
+            JLabel l = new JLabel (msg);
+            l.setHorizontalAlignment (Label.LEFT);
+            gbc.gridy = 2 * i;
+            p.add (l, gbc);
+            /**
+             * @todo CHECK handling of RowsCols for inputdlg
+             */
+            if (RowsCols != null)
+              {
+                if (RowsCols.length == 2 * message.length)
+                  {
+                    nRows = Integer.parseInt (RowsCols[i].toString ());
+                    nCols = Integer.parseInt (RowsCols[RowsCols.length / 2 +
+                                                       i].toString ());
+                  }
+              }
+
+            m_TextField[i] = new JTextArea ("", Math.max (nRows, 1), nCols);
+            // avoid resizing
+            m_TextField[i].setPreferredSize (new Dimension (Math.max (nRows,
+                                                                      1), nCols));
+            m_TextField[i].setAutoscrolls (false);
+            m_TextField[i].setFont (p.getFont ());
+            m_TextField[i].setBorder (new javax.swing.border.EtchedBorder ());
+            m_TextField[i].addKeyListener (theListener);
+
+            gbc.gridy = 2 * i + 1;
+            p.add (m_TextField[i], gbc);
+          }
+
+        if (defaults != null)
+          {
+            if (defaults.length == message.length)
+              {
+                for (int i = 0; i < message.length; i++)
+                  {
+                    String def = theTranslator.replace (defaults[i].toString ());
+                    m_TextField[i].setText (def);
+                  }
+              }
+          }
+      }
+    else if (DLG_LIST == (DLG_LIST & flag))
+      {
+        GridBagConstraints gbc = new GridBagConstraints ();
+        gbc.insets.top = 4;
+        gbc.insets.left = 8;
+        gbc.gridx = 0;
+        gbc.anchor = GridBagConstraints.NORTHWEST;
+
+        p.setLayout (new GridBagLayout ());
+
+        for (int i = 0; i < message.length; i++)
+          {
+            // a single line label
+            String msg = theTranslator.replace (message[i]);
+            JLabel l = new JLabel (msg);
+            gbc.gridy = i;
+            p.add (l, gbc);
+          }
+
+        String lst[] = new String[list.length];
+
+        for (int i = 0; i < list.length; i++)
+          {
+            lst[i] = theTranslator.replace (list[i]);
+          }
+        m_List = new JList (lst);
+
+        // replace ugly monospaced font
+        m_List.setFont (p.getFont ());
+
+        m_List.setMinimumSize (new Dimension (Math.max (1,
+                                                        Integer.parseInt (RowsCols[0].toString ())),
+                                              Math.max (1,
+                                                        Integer.parseInt (RowsCols[1].toString ()))));
+        m_List.setPreferredSize (new Dimension (Math.max (1,
+                                                          Integer.parseInt (RowsCols[1].toString ())),
+                                                Math.max (1,
+                                                          Integer.parseInt (RowsCols[0].toString ()))));
+        m_List.setBorder (new javax.swing.border.EtchedBorder ());
+
+        gbc.gridy = message.length;
+        gbc.fill = GridBagConstraints.HORIZONTAL;
+        p.add (m_List, gbc);
+
+        if (on.toLowerCase ().equals ("single"))
+          {
+            // single selection list
+            m_List.setSelectionMode (ListSelectionModel.SINGLE_SELECTION);
+
+            m_List.setSelectedIndex (Integer.parseInt (
+                                                       defaults[0].toString ()) - 1);
+          }
+        else
+          {
+            // multiple selection possible
+            m_List.setSelectionMode (ListSelectionModel.
+                                     MULTIPLE_INTERVAL_SELECTION);
+
+            int selection[] = new int[defaults.length];
+            for (int i = 0; i < defaults.length; i++)
+              {
+                selection[i] = Integer.parseInt (defaults[i].toString ()) - 1;
+              }
+            m_List.setSelectedIndices (selection);
+
+            JButton b = new JButton ("Select All");
+            b.setActionCommand ("SELALL");
+            b.addActionListener (theListener);
+            gbc.gridy = message.length + 1;
+            gbc.fill = GridBagConstraints.HORIZONTAL;
+            p.add (b, gbc);
+          }
+
+      }
+
+    // prepare icon, if any
+    String sIconFile = null;
+    String sIconResource = null;
+    Icon theIcon = null;
+
+    if (FLAG_ERROR == (FLAG_ERROR & flag))
+      {
+        sIconFile = "images/error.png";
+        // Java for Windows
+        sIconResource = "OptionPane.errorIcon";
+        // Java for Linux does not offer these standard icons...
+      }
+    else if (FLAG_WARNING == (FLAG_WARNING & flag))
+      {
+        sIconFile = "images/warning.png";
+        // Java for Windows
+        sIconResource = "OptionPane.warningIcon";
+        // Java for Linux does not offer these standard icons...
+      }
+    else if (FLAG_QUESTION == (FLAG_QUESTION & flag))
+      {
+        sIconFile = "images/question.png";
+        // Java for Windows
+        sIconResource = "OptionPane.questionIcon";
+        // Java for Linux does not offer these standard icons...
+      }
+    else if (FLAG_INFORMATION == (FLAG_INFORMATION & flag))
+      {
+        sIconFile = "images/information.png";
+        // Java for Windows
+        sIconResource = "OptionPane.informationIcon";
+        // Java for Linux does not offer these standard icons...
+      }
+
+    // first try to find the UIManager specific icon to fit look and feel
+    // Note: the Windows XP look and feel offers 50 icons.
+    if (sIconResource != null)
+      {
+        UIDefaults df = UIManager.getLookAndFeelDefaults ();
+        theIcon = df.getIcon (sIconResource);
+      }
+
+    // fallback on bitmap image resource if icon was not found
+    if (theIcon == null &&
+        sIconFile != null)
+      {
+        URL theResource = JDialogBox.class.getResource (sIconFile);
+        if (theResource != null)
+          {
+            theIcon = new ImageIcon (theResource);
+          }
+      }
+
+    if (theIcon != null)
+      {
+        // dummy panel to provide space around icon
+        JPanel pi = new JPanel (new GridLayout (1, 3));
+        pi.add (new JLabel ());
+        pi.add (new JLabel (theIcon));
+        pi.add (new JLabel ());
+        d.add (pi, BorderLayout.WEST);
+
+        // use Octave icon if available. otherwise use dialog icon
+        Icon theOctaveIcon = getOctaveIcon ();
+        prepareFrameIcon (m_ParentFrame,
+                          theOctaveIcon == null ? theIcon : theOctaveIcon);
+      }
+
+    d.add (p, BorderLayout.CENTER);
+
+    // button bar (2 rows of 3 columns each
+
+    p = new JPanel ();
+    p.setLayout (new java.awt.GridLayout (2, 3));
+
+    // spacer row
+    p.add (new JLabel ());
+    p.add (new JLabel ());
+    p.add (new JLabel ());
+
+    if (DLG_QUEST == (DLG_QUEST & flag))
+      {
+        // questdlg with empty option[2]: only two buttons
+        if (nostring.length () < 1)
+          {
+            // spacer: left
+            p.add (new JLabel ());
+          }
+      }
+    else
+      {
+        // spacer: left
+        p.add (new JLabel ());
+      }
+
+    m_ButtonOK = new JButton (theTranslator.replace (okstring));
+    m_ButtonOK.setActionCommand ("OK");
+    m_ButtonOK.addActionListener (theListener);
+    m_Focus = m_ButtonOK;
+    p.add (m_ButtonOK);
+
+    if (DLG_QUEST == (DLG_QUEST & flag))
+      {
+        // questdlg with empty option[2]: only two buttons
+        if (nostring.length () > 01)
+          {
+            // questdlg has three buttons
+            m_ButtonNO = new JButton (theTranslator.replace (nostring));
+            m_ButtonNO.setActionCommand ("NO");
+            m_ButtonNO.addActionListener (theListener);
+            p.add (m_ButtonNO);
+            if (DLG_QUEST == (DLG_QUEST & flag))
+              {
+                // select default button
+                if (list[3].equals (nostring))
+                  {
+                    m_Focus = m_ButtonNO;
+                  }
+              }
+          }
+      }
+
+    if (DLG_INPUT == (DLG_INPUT & flag) ||
+        DLG_LIST == (DLG_LIST & flag) ||
+        DLG_QUEST == (DLG_QUEST & flag))
+      {
+        m_ButtonCANCEL = new JButton (theTranslator.replace (cancelstring));
+        m_ButtonCANCEL.setActionCommand ("CANCEL");
+        m_ButtonCANCEL.addActionListener (theListener);
+        p.add (m_ButtonCANCEL);
+        if (DLG_QUEST == (DLG_QUEST & flag))
+          {
+            // select default button
+            if (list[3].equals (cancelstring))
+              {
+                m_Focus = m_ButtonCANCEL;
+              }
+          }
+      }
+    else
+      {
+        // spacer: right
+        p.add (new JLabel ());
+      }
+
+    d.add (p, BorderLayout.SOUTH);
+    dlg.pack ();
+
+    dlg.addWindowListener (theListener);
+
+    if (on.equals ("on"))
+      {
+        m_ParentFrame.setAlwaysOnTop (true);
+      }
+
+    // center dialog on screen
+    Dimension dlgSize = dlg.getSize ();
+    Dimension screenSize = Toolkit.getDefaultToolkit ().getScreenSize ();
+
+    dlg.setLocation ((screenSize.width - dlgSize.width) / 2,
+                     (screenSize.height - dlgSize.height) / 2);
+
+    dlg.setVisible (true);
+    dlg.requestFocus ();
+
+    m_ParentFrame.setVisible (false);
+
+    return (1);
+  }
+
+
+  /**
+   *
+   * @return Icon - null if icon was not found
+   */
+  private Icon getOctaveIcon ()
+  {
+    Icon theIcon = null;
+    URL theResource = JDialogBox.class.getResource ("images/octave.png");
+    if (theResource != null)
+      {
+        theIcon = new ImageIcon (theResource);
+      }
+    return theIcon;
+  }
+
+
+  /**
+   * Replace the standard Java frame icon with an Octave Icon.
+   *
+   * @param theFrame Frame - the Frame to decorate
+   * @param theIcon Icon - the icon to use if octave icon is not found.
+   */
+  private void prepareFrameIcon (Frame theFrame, Icon theIcon)
+  {
+    // prepare icon for upper left corner of Frame window
+    // maybe there is a simpler way to achieve this
+    int w = theIcon.getIconWidth ();
+    int h = theIcon.getIconHeight ();
+    // Frame must be made displayable by packing it for createImage() to succeed
+    theFrame.pack ();
+    Image theImage = theFrame.createImage (w, h);
+    theIcon.paintIcon (theFrame, theImage.getGraphics (), 0, 0);
+    theFrame.setIconImage (theImage);
+  }
+
+
+  /**
+   * Select Look and Feel
+   *
+   * @param bSystemLnF boolean - if true, the current systesm Look&Feel is used,
+   * otherwise the Swing/Metal cross platform Look&Feel is used.
+   */
+  private void setSystemLnF (boolean bSystemLnF)
+  {
+    try
+      {
+        if (bSystemLnF)
+          {
+            // switch from Swing LnF to local system LnF
+            UIManager.setLookAndFeel (UIManager.
+                                      getSystemLookAndFeelClassName ());
+          }
+        else
+          {
+            // use Swing LnF
+            UIManager.setLookAndFeel (UIManager.
+                                      getCrossPlatformLookAndFeelClassName ());
+          }
+      }
+    catch (Exception exception)
+      {
+        exception.printStackTrace ();
+      }
+  }
+
+
+  /**
+   * Called when the dialog is closed. Allows for specific cleanup actions.
+   *
+   * @param closeMethod int - OctaveDialog.CLOSE_OK, OctaveDialog.CLOSE_CANCEL
+   */
+  public void closeDialog (int closeMethod)
+  {
+    m_CloseMethod = closeMethod;
+    m_ParentFrame.dispose ();
+  }
+
+
+  public void setFocus ()
+  {
+    if (null != m_Focus)
+      {
+        m_Focus.requestFocus ();
+        m_ParentFrame.getRootPane ().setDefaultButton (m_Focus);
+        m_ParentFrame.setAlwaysOnTop (true);
+      }
+  }
+
+
+  /**
+   * Tests the dialogs
+   *
+   * @param args String[] - not used.
+   */
+  public static void main (String[] args)
+  {
+    TeXtranslator t = new TeXtranslator();
+
+    if (false)
+      {
+        // find out key names of icon UI resources
+        UIDefaults df = UIManager.getLookAndFeelDefaults ();
+
+        for (Enumeration e = df.keys (); e.hasMoreElements ();)
+          {
+            String s = e.nextElement ().toString ();
+
+            if (s.toLowerCase ().contains ("icon"))
+              {
+                System.out.println (s);
+              }
+          }
+      }
+
+    try
+      {
+        Class[] argTypes = new Class[1];
+        argTypes[0] = String.class;
+
+        java.lang.reflect.Constructor c = ClassHelper.findConstructor (java.lang.StringBuffer.class,
+                                                                       argTypes);
+        Object argValues[] = new Object[1];
+        argValues[0] = new String("initial value");
+        Object sb = c.newInstance(argValues);
+        System.out.println(sb.toString());
+
+        ClassHelper.invokeMethod(sb,"append",argValues,argTypes);
+        System.out.println(sb.toString());
+
+        argValues = new Object[2];
+        argTypes = new Class[2];
+        argTypes[0] =  Integer.class;
+        argTypes[1] = String.class;
+        argValues[0] = new Integer(0);
+        argValues[1] = new String("inserted");
+
+        ClassHelper.invokeMethod(sb,"insert",argValues,argTypes);
+        System.out.println(sb.toString());
+      }
+    catch (Throwable e)
+      {}
+
+    if (true)
+      {
+        return;
+      }
+
+    helpdlg ("If you need help\nyou should ask for help\nif someone is around\notherwise you are on your own.",
+             "Information");
+
+    String[] options = new String[4];
+    options[0] = "Yeah \\vartheta is too low";
+    options[1] = "Maybe";
+    options[2] = "Nay \\vartheta is too high";
+    options[3] = "Maybe";
+
+    System.out.println (questdlg ("Is it too cold?", "Temperature", options));
+
+    // test variants of errordlg
+    // does not affect layering of dialog
+    errordlg ("Background error!", "Error");
+
+    // test variants of helpdlg
+
+    // test variants of inputdlg
+    String prompt[] = new String[2];
+    prompt[0] = "Question 1";
+    prompt[1] = "Question 2";
+    String defaults[] = new String[2];
+    defaults[0] = "1.1";
+    defaults[1] = "2.2";
+    String title = "Enter values";
+
+    Integer rc[] = new Integer[2 * 2];
+    rc[0] = new Integer (1);
+    rc[1] = new Integer (2);
+    rc[2] = new Integer (10);
+    rc[3] = new Integer (20);
+
+    inputdlg (prompt, title, rc, defaults);
+
+    String listcell[] = new String[4];
+    listcell[0] = "a \\alpha";
+    listcell[1] = "b \\beta";
+    listcell[2] = "c \\gamma";
+    listcell[3] = "d \\delta";
+
+    Integer size[] = new Integer[2];
+    size[0] = new Integer (80);
+    size[1] = new Integer (100);
+
+    Integer initial[] = new Integer[2];
+    initial[0] = new Integer (4);
+    initial[1] = new Integer (2);
+
+    String promptcell[] = new String[2];
+    promptcell[0] = "Select something";
+    promptcell[1] = "(or even more than one thing)";
+
+    int idx[] = listdlg (listcell,
+                         "Multiple",
+                         size,
+                         initial,
+                         "name",
+                         promptcell,
+                         "okstring",
+                         "cancelstring");
+
+    if (idx != null)
+      {
+        for (int i = 0; i < idx.length; i++)
+          {
+            System.out.println (idx[i]);
+          }
+      }
+  }
+}
diff --git a/scripts/java/org/octave/Matrix.java b/scripts/java/org/octave/Matrix.java
new file mode 100644
--- /dev/null
+++ b/scripts/java/org/octave/Matrix.java
@@ -0,0 +1,361 @@
+/*
+
+Copyright (C) 2007 Michael Goffioul
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or (at
+your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+package org.octave;
+
+import java.nio.*;
+import java.text.DecimalFormat;
+
+public class Matrix
+{
+  private int[] dims;
+  private Buffer data;
+  private Object cache = null;
+
+  public Matrix ()
+  {
+    this (new double[0], new int[] {0, 0});
+  }
+
+  public Matrix (double[] data)
+  {
+    this (data, new int[] {1, data.length});
+  }
+
+  public Matrix (double[][] data)
+  {
+    int m = data.length;
+    int n = (m > 0 ? data[0].length : 0);
+    int idx = 0;
+    double[] buf = new double[m*n];
+		
+    for (int j = 0; j < n; j++)
+      for (int i = 0; i < m; i++)
+        buf[idx++] = data[i][j];
+    this.data = DoubleBuffer.wrap(buf);
+    this.dims = new int[] {m, n};
+    this.cache = data;
+  }
+
+  public Matrix (double[][][] data)
+  {
+    int m = data.length;
+    int n = (m > 0 ? data[0].length : 0);
+    int p = (n > 0 ? data[0][0].length : 0);
+    int idx = 0;
+    double[] buf = new double[m*n*p];
+
+    for (int k = 0; k < p; k++)
+      for (int j = 0; j < n; j++)
+        for (int i = 0; i < m; i++)
+          buf[idx++] = data[i][j][k];
+    this.data = DoubleBuffer.wrap(buf);
+    this.dims = new int[] {m, n, p};
+    this.cache = data;
+  }
+
+  public Matrix (double[] data, int[] dims)
+  {
+    this.dims = dims;
+    this.data = DoubleBuffer.wrap(data);
+  }
+
+  public Matrix (byte[] data, int[] dims)
+  {
+    this.dims = dims;
+    this.data = ByteBuffer.wrap(data);
+  }
+
+  public Matrix (int[] data, int[] dims)
+  {
+    this.dims = dims;
+    this.data = IntBuffer.wrap(data);
+  }
+
+  public double[] toDouble ()
+  {
+    if (data instanceof DoubleBuffer)
+      return ((DoubleBuffer)data).array ();
+    else
+      throw new ClassCastException ("matrix is not of type `double'");
+  }
+
+  public byte[] toByte ()
+  {
+    if (data instanceof ByteBuffer)
+      return ((ByteBuffer)data).array ();
+    else
+      throw new ClassCastException ("matrix is not of type `byte'");
+  }
+
+  public int[] toInt ()
+  {
+    if (data instanceof IntBuffer)
+      return ((IntBuffer)data).array ();
+    else
+      throw new ClassCastException ("matrix is not of type `integer'");
+  }
+
+  public int getNDims ()
+  {
+    return (dims == null ? 0 : dims.length);
+  }
+
+  public int getDim (int index)
+  {
+    return (dims == null || index < 0 || index >= dims.length ? -1 : dims[index]);
+  }
+
+  public int[] getDims ()
+  {
+    return dims;
+  }
+
+  public String getClassName ()
+  {
+    if (data instanceof DoubleBuffer)
+      return "double";
+    else if (data instanceof IntBuffer)
+      return "integer";
+    else if (data instanceof ByteBuffer)
+      return "byte";
+    else
+      return "unknown";
+  }
+
+  public String toString ()
+  {
+    if (dims == null || data == null)
+      return "null";
+
+    String s = "";
+
+    if (dims.length == 2 && dims[0] == 1 && dims[1] <= 5)
+      {
+        if (data instanceof DoubleBuffer)
+          {
+            DoubleBuffer b = (DoubleBuffer)data;
+            DecimalFormat fmt = new DecimalFormat ("0.0000 ");
+            for (int i = 0; i < b.capacity (); i++)
+              s += fmt.format (b.get (i));
+          }
+        else if (data instanceof IntBuffer)
+          {
+            IntBuffer b = (IntBuffer)data;
+            for (int i = 0; i < b.capacity (); i++)
+              s += (Integer.toString (b.get (i)) + " ");
+          }
+        else if (data instanceof ByteBuffer)
+          {
+            ByteBuffer b = (ByteBuffer)data;
+            for (int i = 0; i < b.capacity (); i++)
+              s += (Byte.toString (b.get (i)) + " ");
+          }
+        s = ("[ " + s + "]");
+      }
+    else if (dims.length == 2 && dims[0] == 0 && dims[1] == 0)
+      s = "[ ]";
+    else
+      {
+        for (int i = 0; i < dims.length; i++)
+          if (i == 0)
+            s = Integer.toString (dims[i]);
+          else
+            s += (" by " + Integer.toString (dims[i]));
+        s = ("[ (" + s + ") array of " + getClassName () + " ]");
+      }
+
+    return s;
+  }
+
+  public static Object ident (Object o)
+  {
+    System.out.println (o);
+    return o;
+  }
+
+  public boolean equals (Object value)
+  {
+    if (value instanceof Matrix)
+      {
+        Matrix m = (Matrix)value;
+        if (!java.util.Arrays.equals (dims, m.dims))
+          return false;
+        return data.equals (m.data);
+      }
+    else
+      return false;
+  }
+
+  public boolean isEmpty ()
+  {
+    return (data == null || dims == null || data.capacity () == 0);
+  }
+
+  public boolean isVector ()
+  {
+    return (dims.length == 1 ||
+            (dims.length == 2 && (dims[0] == 1 || dims[1] == 1 ||
+                                  (dims[0] == 0 && dims[1] == 0))));
+  }
+
+  public int getLength ()
+  {
+    return data.capacity ();
+  }
+
+  public double[] asDoubleVector ()
+  {
+    if (data instanceof DoubleBuffer)
+      return toDouble ();
+    else
+      System.out.println ("Warning: invalid conversion to double vector");
+    return null;
+  }
+
+  public double[][] asDoubleMatrix ()
+  {
+    if (cache != null)
+      {
+        try { return (double[][])cache; }
+        catch (ClassCastException e) { }
+      }
+
+    if (data instanceof DoubleBuffer && dims.length == 2)
+      {
+        double[][] m = new double[dims[0]][dims[1]];
+        double[] data = ((DoubleBuffer)this.data).array ();
+        int idx = 0;
+        if (data.length > 0)
+          for (int j = 0; j < m[0].length; j++)
+            for (int i = 0; i < m.length; i++)
+              m[i][j] = data[idx++];
+        cache = m;
+        return m;
+      }
+    else
+      System.out.println ("Warning: invalid conversion to double matrix");
+
+    return null;
+  }
+	
+  public double[][][] asDoubleMatrix3 ()
+  {
+    if (cache != null)
+      {
+        try { return (double[][][])cache; }
+        catch (ClassCastException e) { }
+      }
+
+    if (data instanceof DoubleBuffer && dims.length == 3)
+      {
+        double[][][] m = new double[dims[0]][dims[1]][dims[2]];
+        double[] data = ((DoubleBuffer)this.data).array ();
+        int idx = 0;
+        if (data.length > 0)
+          for (int k = 0; k < dims[2]; k++)
+            for (int j = 0; j < dims[1]; j++)
+              for (int i = 0; i < dims[0]; i++)
+                m[i][j][k] = data[idx++];
+        cache = m;
+        return m;
+      }
+    else
+      System.out.println ("Warning: invalid conversion to double array");
+
+    return null;
+  }
+
+  public int[][] asIntMatrix ()
+  {
+    if (cache != null)
+      {
+        try { return (int[][])cache; }
+        catch (ClassCastException e) { }
+      }
+
+    if (data instanceof IntBuffer && dims.length == 2)
+      {
+        int[][] m = new int[dims[0]][dims[1]];
+        int[] data = ((IntBuffer)this.data).array ();
+        int idx = 0;
+        if (data.length > 0)
+          for (int j = 0; j < m[0].length; j++)
+            for (int i = 0; i < m.length; i++)
+              m[i][j] = data[idx++];
+        cache = m;
+        return m;
+      }
+    else
+      System.out.println ("Warning: invalid conversion to integer matrix");
+
+    return null;
+  }
+
+  public double minValue ()
+  {
+    double val = Double.POSITIVE_INFINITY;
+
+    if (data instanceof DoubleBuffer)
+      {
+        double[] buf = ((DoubleBuffer)data).array ();
+        for (int i = 0; i < buf.length; i++)
+          if (buf[i] < val)
+            val = buf[i];
+      }
+    else if (data instanceof ByteBuffer)
+      {
+        byte[] buf = ((ByteBuffer)data).array ();
+        for (int i = 0; i < buf.length; i++)
+          if (buf[i] < val)
+            val = buf[i];
+      }
+    else
+      System.out.println ("Warning: cannot compute min value for array of type `" + getClassName () + "'");
+
+    return val;
+  }
+
+  public double maxValue ()
+  {
+    double val = Double.NEGATIVE_INFINITY;
+
+    if (data instanceof DoubleBuffer)
+      {
+        double[] buf = ((DoubleBuffer)data).array ();
+        for (int i = 0; i < buf.length; i++)
+          if (buf[i] > val)
+            val = buf[i];
+      }
+    else if (data instanceof ByteBuffer)
+      {
+        byte[] buf = ((ByteBuffer)data).array ();
+        for (int i = 0; i <buf.length; i++)
+          if (buf[i] > val)
+            val = buf[i];
+      }
+    else
+      System.out.println ("Warning: cannot compute max value for array of type `" + getClassName () + "'");
+
+    return val;
+  }
+}
diff --git a/scripts/java/org/octave/OctClassLoader.java b/scripts/java/org/octave/OctClassLoader.java
new file mode 100644
--- /dev/null
+++ b/scripts/java/org/octave/OctClassLoader.java
@@ -0,0 +1,74 @@
+/*
+
+Copyright (C) 2007 Michael Goffioul
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or (at
+your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+package org.octave;
+
+import java.io.File;
+
+public class OctClassLoader extends java.net.URLClassLoader
+{
+  public OctClassLoader ()
+  {
+    super (new java.net.URL[0]);
+  }
+
+  public OctClassLoader (ClassLoader parent)
+  {
+    super (new java.net.URL[0], parent);
+  }
+
+  protected Class findClass (String name) throws ClassNotFoundException
+  {
+    //System.out.println ("Looking for class " + name);
+    return super.findClass (name);
+  }
+
+  protected String findLibrary (String libname)
+  {
+    // Look dynamically into java.library.path, because Sun VM does
+    // not do it (seems to cache initial java.library.path instead)
+
+    String[] paths = System.getProperty ("java.library.path").split (File.pathSeparator);
+
+    libname = System.mapLibraryName (libname);
+    for (int i = 0; i < paths.length; i++)
+      {
+        File f = new File (paths[i], libname);
+        if (f.exists ())
+          return f.getAbsolutePath ();
+      }
+
+    return null;
+  }
+
+  public void addClassPath (String name) throws Exception
+  {
+    java.io.File f = new java.io.File (name);
+    addURL (f.toURI ().toURL ());
+  }
+
+  // new -MH-
+  public void addURL (java.net.URL url)
+  {
+    super.addURL (url);
+  }
+}
diff --git a/scripts/java/org/octave/Octave.java b/scripts/java/org/octave/Octave.java
new file mode 100644
--- /dev/null
+++ b/scripts/java/org/octave/Octave.java
@@ -0,0 +1,220 @@
+/*
+
+Copyright (C) 2007 Michael Goffioul
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or (at
+your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+package org.octave;
+
+import java.util.*;
+
+public class Octave
+{
+  private static Object notifyObject = null;
+  private static Object[] args = null;
+  private static LinkedList invokeList = new LinkedList ();
+  private static LinkedList waitList = new LinkedList ();
+
+  public native static boolean call (String name, Object[] argin, Object[] argout);
+  public native static void doInvoke (int ID, Object[] args);
+  public native static void doEvalString (String cmd);
+  public native static boolean needThreadedInvokation ();
+
+  public static void checkPendingAction ()
+  {
+    if (notifyObject != null)
+      {
+        synchronized (notifyObject)
+          {
+            if (notifyObject instanceof OctaveReference)
+              doInvoke (((OctaveReference)notifyObject).getID (), args);
+            else if (notifyObject instanceof String)
+              doEvalString ((String)notifyObject);
+            notifyObject.notifyAll ();
+          }
+        notifyObject = null;
+        args = null;
+      }
+
+    Object obj;
+    Object[] objArgs;
+
+    while (true)
+      {
+        obj = null;
+        objArgs = null;
+
+        synchronized (invokeList)
+          {
+            if (invokeList.size () > 0)
+              {
+                obj = invokeList.remove ();
+                if (obj instanceof OctaveReference)
+                  objArgs = (Object[])invokeList.remove ();
+              }
+          }
+
+        if (obj != null)
+          {
+            if (obj instanceof Runnable)
+              ((Runnable)obj).run ();
+            else if (obj instanceof OctaveReference)
+              doInvoke (((OctaveReference)obj).getID (), objArgs);
+            else if (obj instanceof String)
+              doEvalString ((String)obj);
+          }
+        else
+          break;
+      }
+    /*
+      synchronized (invokeList)
+      {
+      while (invokeList.size () > 0)
+      {
+      Object obj = invokeList.remove ();
+      if (obj instanceof Runnable)
+      ((Runnable)obj).run ();
+      if (obj instanceof OctaveReference)
+      {
+      Object[] objArgs = (Object[])invokeList.remove ();
+      doInvoke (((OctaveReference)obj).getID (), objArgs);
+      }
+      else if (obj instanceof String)
+      doEvalString ((String)obj);
+      }
+      }
+    */
+  }
+
+  private static void checkWaitState ()
+  {
+    if (waitList.size () > 0)
+      {
+        Object wObj = waitList.getFirst ();
+        synchronized (wObj)
+          {
+            wObj.notifyAll ();
+          }
+      }
+  }
+
+  public static void invokeAndWait (OctaveReference ref, Object[] invokeArgs)
+  {
+    if (needThreadedInvokation ())
+      {
+        synchronized (ref)
+          {
+            notifyObject = ref;
+            args = invokeArgs;
+            try { checkWaitState (); ref.wait (); }
+            catch (InterruptedException e) {}
+          }
+      }
+    else
+      doInvoke (ref.getID (), invokeArgs);
+  }
+
+  public static void evalAndWait (String cmd)
+  {
+    if (needThreadedInvokation ())
+      {
+        synchronized (cmd)
+          {
+            notifyObject = cmd;
+            args = null;
+            try { checkWaitState (); cmd.wait (); }
+            catch (InterruptedException e) {}
+          }
+      }
+    else
+      doEvalString (cmd);
+  }
+
+  public static void invokeLater (Runnable r)
+  {
+    if (needThreadedInvokation ())
+      synchronized (invokeList)
+        {
+          invokeList.add (r);
+          checkWaitState ();
+        }
+    else
+      r.run ();
+  }
+
+  public static void invokeLater (OctaveReference ref, Object[] invokeArgs)
+  {
+    if (needThreadedInvokation ())
+      synchronized (invokeList)
+        {
+          invokeList.add (ref);
+          invokeList.add (invokeArgs);
+          checkWaitState ();
+        }
+    else
+      doInvoke (ref.getID (), invokeArgs);
+  }
+
+  public static void evalLater (String cmd)
+  {
+    if (needThreadedInvokation ())
+      synchronized (invokeList)
+        {
+          invokeList.add (cmd);
+          checkWaitState ();
+        }
+    else
+      doEvalString (cmd);
+  }
+
+  public static void waitFor (Object wObj)
+  {
+    waitList.add (0, wObj);
+    synchronized (wObj)
+      {
+        while (waitList.size () > 0 && waitList.getFirst () == wObj)
+          {
+            try { wObj.wait (); }
+            catch (InterruptedException e) {}
+            checkPendingAction ();
+          }
+      }
+  }
+
+  public static void endWaitFor (Object obj)
+  {
+    boolean isCurrentWaitObject = (waitList.size () > 0 && waitList.getFirst () == obj);
+
+    waitList.remove (obj);
+    if (needThreadedInvokation () && isCurrentWaitObject)
+      synchronized (obj)
+        {
+          obj.notifyAll ();
+        }
+  }
+
+  public static Object do_test (String name, Object arg0) throws Exception
+  {
+    Object[] argin = new Object[] { arg0 };
+    Object[] argout = new Object[1];
+    if (call (name, argin, argout))
+      return argout[0];
+    throw new Exception ("octave call failed");
+  }
+}
diff --git a/scripts/java/org/octave/OctaveReference.java b/scripts/java/org/octave/OctaveReference.java
new file mode 100644
--- /dev/null
+++ b/scripts/java/org/octave/OctaveReference.java
@@ -0,0 +1,64 @@
+/*
+
+Copyright (C) 2007 Michael Goffioul
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or (at
+your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+package org.octave;
+
+public class OctaveReference
+{
+  private int ID;
+
+  public OctaveReference (int ID)
+  {
+    this.ID = ID;
+  }
+
+  private native static void doFinalize (int ID);
+
+  protected void finalize () throws Throwable
+  {
+    doFinalize (this.ID);
+  }
+
+  public String toString ()
+  {
+    return ("<octave reference " + this.ID + ">");
+  }
+
+  public int getID ()
+  {
+    return this.ID;
+  }
+
+  public Object invoke (Object[] args)
+  {
+    //System.out.println ("OctaveReference::invoke");
+    Octave.doInvoke (this.ID, args);
+    return null;
+  }
+
+  public synchronized Object invokeAndWait (Object[] args)
+  {
+    //System.out.println ("OctaveReference::invokeandWait");
+    Octave.invokeAndWait (this, args);
+    return null;
+  }
+}
diff --git a/scripts/java/org/octave/TeXcode.java b/scripts/java/org/octave/TeXcode.java
new file mode 100644
--- /dev/null
+++ b/scripts/java/org/octave/TeXcode.java
@@ -0,0 +1,37 @@
+/*
+
+Copyright (C) 2010 Martin Hepperle
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or (at
+your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+// A class to hold a TeX character code -> Unicode translation pair.
+
+package org.octave;
+
+public class TeXcode
+{
+  protected String tex;
+  protected char ucode;
+
+  public TeXcode (String t, char u)
+  {
+    tex = t;
+    ucode = u;
+  }
+}
diff --git a/scripts/java/org/octave/TeXtranslator.java b/scripts/java/org/octave/TeXtranslator.java
new file mode 100644
--- /dev/null
+++ b/scripts/java/org/octave/TeXtranslator.java
@@ -0,0 +1,262 @@
+/*
+
+Copyright (C) 2010 Martin Hepperle
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 3 of the License, or (at
+your option) any later version.
+
+Octave is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+// A primitive TeX character translator.  Provides methods to translate
+// a subset of TeX symbol strings into their aequivalent Unicode
+// representation.
+//
+// Note that not all Unicode character sets contain all these characters.
+// Suitable Windows fonts are e.g.:
+//   - Lucida Sans Unicode
+//   - Arial Unicode MS
+//   - MS Mincho
+
+package org.octave;
+
+public class TeXtranslator
+{
+  private TeXcode m_texTable[] =
+    {
+      // lower case
+      new TeXcode ("alpha", '\u03B1'),
+      new TeXcode ("beta", '\u03B2'),
+      new TeXcode ("gamma", '\u03B3'),
+      new TeXcode ("delta", '\u03B4'),
+      new TeXcode ("epsilon", '\u03B5'),
+      new TeXcode ("zeta", '\u03B6'),
+      new TeXcode ("eta", '\u03B7'),
+      new TeXcode ("theta", '\u03B8'),
+      new TeXcode ("vartheta", '\u03D1'),
+      new TeXcode ("iota", '\u03B9'),
+      new TeXcode ("kappa", '\u03BA'),
+      new TeXcode ("lambda", '\u03BB'),
+      new TeXcode ("mu", '\u03BC'),
+      new TeXcode ("nu", '\u03BD'),
+      new TeXcode ("xi", '\u03BE'),
+      new TeXcode ("pi", '\u03C0'),
+      new TeXcode ("rho", '\u03C1'),
+      new TeXcode ("sigma", '\u03C3'),
+      new TeXcode ("varsigma", '\u03C2'),
+      new TeXcode ("tau", '\u03C4'),
+      new TeXcode ("phi", '\u03C6'),
+      new TeXcode ("chi", '\u03C7'),
+      new TeXcode ("psi", '\u03C8'),
+      new TeXcode ("omega", '\u03C9'),
+      new TeXcode ("upsilon", '\u03C5'),
+      // upper case
+      new TeXcode ("Gamma", '\u0393'),
+      new TeXcode ("Delta", '\u0394'),
+      new TeXcode ("Theta", '\u0398'),
+      new TeXcode ("Lambda", '\u039B'),
+      new TeXcode ("Pi", '\u03A0'),
+      new TeXcode ("Xi", '\u039E'),
+      new TeXcode ("Sigma", '\u03A3'),
+      new TeXcode ("Upsilon", '\u03A5'),
+      new TeXcode ("Phi", '\u03A6'),
+      new TeXcode ("Psi", '\u03A8'),
+      new TeXcode ("Omega", '\u03A9'),
+      // complex
+      new TeXcode ("Im", '\u2111'),
+      new TeXcode ("Re", '\u211c'),
+      // special
+      new TeXcode ("leq", '\u2264'),
+      new TeXcode ("geq", '\u2265'),
+      new TeXcode ("neq", '\u2260'),
+      new TeXcode ("pm", '\u00B1'),
+      new TeXcode ("infty", '\u221E'),
+      new TeXcode ("partial", '\u2202'),
+      new TeXcode ("approx", '\u2248'),
+      new TeXcode ("circ", '\u2218'),
+      new TeXcode ("bullet", '\u2022'),
+      new TeXcode ("times", '\u00D7'),
+      new TeXcode ("sim", '\u007E'),
+      new TeXcode ("nabla", '\u2207'),
+      new TeXcode ("ldots", '\u2026'),
+      new TeXcode ("exists", '\u2203'),
+      new TeXcode ("neg", '\u00AC'),
+      new TeXcode ("aleph", '\u2135'),
+      new TeXcode ("forall", '\u2200'),
+      new TeXcode ("cong", '\u2245'),
+      new TeXcode ("wp", '\u2118'),
+      new TeXcode ("propto", '\u221D'),
+      new TeXcode ("otimes", '\u2297'),
+      new TeXcode ("oplus", '\u2295'),
+      new TeXcode ("oslash", '\u2298'),
+      new TeXcode ("cap", '\u2229'),
+      new TeXcode ("cup", '\u222A'),
+      new TeXcode ("ni", '\u220B'),
+      new TeXcode ("in", '\u2208'),
+      new TeXcode ("div", '\u00F7'),
+      new TeXcode ("equiv", '\u2261'),
+      new TeXcode ("int", '\u222B'),
+      new TeXcode ("perp", '\u22A5'),
+      new TeXcode ("wedge", '\u2227'),
+      new TeXcode ("vee", '\u2228'),
+      // sets
+      new TeXcode ("supseteq", '\u2287'),
+      new TeXcode ("supset", '\u2283'),
+      new TeXcode ("subseteq", '\u2286'),
+      new TeXcode ("subset", '\u2282'),
+      // cards
+      new TeXcode ("clubsuit", '\u2663'),
+      new TeXcode ("spadesuit", '\u2660'),
+      new TeXcode ("heartsuit", '\u2665'),
+      new TeXcode ("diamondsuit", '\u2666'),
+      new TeXcode ("copyright", '\u00A9'),
+      // arrows
+      new TeXcode ("leftarrow", '\u2190'),
+      new TeXcode ("uparrow", '\u2191'),
+      new TeXcode ("rightarrow", '\u2192'),
+      new TeXcode ("downarrow", '\u2193'),
+      new TeXcode ("leftrightarrow", '\u2194'),
+      new TeXcode ("updownarrow", '\u2195'),
+    };
+
+   public TeXtranslator ()
+   {
+     /* DEBUG: output table to file
+     try
+       {
+         java.io.PrintWriter pwTeX = new java.io.PrintWriter ("z:/tex.txt", "UTF-8");
+         java.io.PrintWriter pwHTML = new java.io.PrintWriter ("z:/html.txt", "UTF-8");
+         java.io.PrintWriter pwOctave = new java.io.PrintWriter ("z:/octave.txt", "UTF-8");
+         pwOctave.print ("msgbox ( [");
+         int i = 0;
+         for (int k = 0; k < m_texTable.length; k++)
+           {
+             if (i++ == 0)
+               {
+                 pwTeX.print ("@item ");
+                 pwHTML.print ("@item ");
+                 pwOctave.print ("          '");
+               }
+             else
+               {
+                 pwTeX.print ("@tab ");
+                 pwHTML.print ("@tab ");
+                 pwOctave.print ("   ");
+               }
+             pwTeX.println ("\\" + m_texTable[k].tex);
+             pwTeX.println ("@tab '@math{\\" + m_texTable[k].tex + "}'");
+             pwHTML.println ("\\" + m_texTable[k].tex);
+             pwHTML.println ("@tab '" + m_texTable[k].ucode + "'");
+             pwOctave.print ("\\\\" + m_texTable[k].tex+" ");
+             pwOctave.print (" = ''\\" + m_texTable[k].tex + " ''");
+             if (i == 3)
+               {
+                 pwTeX.println ("@c ----------");
+                 pwHTML.println ("@c ----------");
+                 pwOctave.println ("', 10, ...");
+                 i=0;
+               }
+             else
+               {
+                 pwTeX.println ("@tab");
+                 pwHTML.println ("@tab");
+                 pwOctave.print ("   ");
+               }
+           }
+         pwOctave.print ("']);");
+         pwTeX.close ();
+         pwHTML.close ();
+         pwOctave.close ();
+       }
+     catch (Exception e)
+       {
+         ;
+       }
+      /* */
+   }
+
+
+  /*
+    NOT YET TRANSLATED
+    o
+    rfloor
+    lceil
+    lfloor
+    cdot
+    prime
+    0
+    rceil
+    surd
+    mid
+    varpi
+    langle
+    rangle
+  */
+
+  public String replace (String s)
+  {
+    StringBuffer sb = new StringBuffer (s);
+    // append trailing blank
+    sb.append (' ');
+
+    int i = 0;
+    do
+      {
+        // 26 08 2010 MH szatt search at index i
+        i = sb.indexOf ("\\", i);
+        if (i > -1)
+          {
+            int j = sb.indexOf (" ", i);
+            if (j > i)
+              {
+                String token = sb.substring (i + 1, j);
+
+                for (int k = 0; k < m_texTable.length; k++)
+                  {
+                    if (m_texTable[k].tex.equals (token))
+                      {
+                        sb.replace (i, j + 1,
+                                    Character.toString (m_texTable[k].ucode));
+                        break;
+                      }
+                  }
+                if (sb.charAt (i) == '\\')
+                  {
+                    // backslash sztill there: not found
+                    if (sb.charAt (i + 1) == 'n')
+                      {
+                        // newline
+                        sb.replace (i, i + 2, "\n");
+                      }
+                    else if (sb.charAt (i + 1) == '\\')
+                      {
+                        // backslash
+                        sb.replace (i, i + 2, "\\");
+                      }
+                  }
+
+                // 26 08 2010 MH
+                // advance i to avoid deadlock in case of incorrect escape
+                // sequences like \\\\alpha (double backslash) or
+                // \\bogus (unknown escape sequence)
+                i++;
+              }
+          }
+      }
+    while (i > -1);
+    // finall: remove trailing blank
+    return (sb.substring (0, sb.length () - 1).toString ());
+  }
+}
diff --git a/scripts/java/org/octave/images/error.png b/scripts/java/org/octave/images/error.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..75fe9106973d938e3b7849f7dd1916dd674d72ba
GIT binary patch
literal 1205
zc$~#ji%(Nm82@hHrEP3Qy0)-!A#513AZ3sdWbwA;O=Zxs&^SP7s2~Oq#EDwrQen_y
zT`_B*KwQUbz)%@knA;%UATKA$B%{jIMbw!v#~gE8(j|kl<Mv1F<ecC4``%y9Irg0F
zG)aIe001Nz>B$BxDSSu)8>3ryei92#nP$HR;L75gT*psXSJtJN>WtNg>Q0o@T0m1;
zZMKjZl_g~sgQcYOWX%mr5&%Kx=<`xm0SpGi69A!5h}digz~=ywk&!<GTmUEn$O6y<
zAiNO<Km_3jz`eEs&S6z1o5h%zh)$nI(a}jsNlvE|1qLE6_b#@}<?8^yU=kjV#A3wf
zqxkqQ0Y1R#+uL|hR8-X8-#-oD_xsV=v&dv}VWUJch%q#DWMpK0eSHCQp>PTy4U@RI
zGXP#py1P+G2x@6THrqJB7ue!<F9XzIa`2!LBSj4k4x-M^Va%n{j*bpKpZ_c798OnP
zm&fCwF)t`Uxw*(-xC8JuRyCRyfO`N-05nZ|z23&gMpRaYIy#U@gzD>2VWCc^TLEx5
z90<Dx22fSi7EZL=QB)MNT9L;ilgW@)iz+HAD=W*(%aPZMdU{Z7EXvPEt*uC@JOc0o
zP6-P`sj2urr_D<jv7qY=*+%sLE=b^Jl>xB!WF%|y>hGF|7r1`U_k&*2{aJ*(GnNK3
zGqNv{x{(>eO47D(uxp0d0<wU&xz{(o`Xp0Joh-?`cr4_-79g6hLqoNCXd@z5DR5m0
zI&p0A&iv?3k{%Ccst2xnckf;jaamE%M-QBuH0=ig$qWDEaXdlNiniq)Z+yHIXjD^B
zqNX44bo*ACzcB=geYoafxJCpIHM9wZc8}sU;7H#m{`U1Aa(tz-TBoeV%*}T4uZXD_
z8?F;0S$m}a&Ic81+{3n=#g938et)g)mXFPm4iV3K#VYI3GwHm|fX&}5{=QH70#eVe
z7yrnp)CJHNF|hn!-2JDu)||jLHQ>2bj3~ZI!3LJ#Yhr3P7^GB!ggM70Z!N@O_fZ9N
zv-MSZy?b1NJzYH0M6BR<vom#!2QLa~Z>w#p1o3csc3S=pDP<C`)yDaP=DS@V&P+V|
zx0#&XY@5>`k6&vNd@Ev2WF8NjTYpNh1X)$PCU(h;%!QXNZs(<N<+2+GPd=yG`0YY!
ztM8rp4aF!9J7RC1<G31fKVs?U@I_7QXJd%52QFp%0UBm<qxwDcyNz#A@No2{96i&2
z?G-%nZN2vXn7mfsO)?MnESjsHwHAiqh|9q(S1(nru29U(>%BTxXlvq&S1;TvO1YY9
tr|Bk1k0^TUPu$}keX609HU?2N0Ws;HWLGTB1><iF87bMxm$k*Ve*if99-ROH

diff --git a/scripts/java/org/octave/images/information.png b/scripts/java/org/octave/images/information.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..4246920a6171aaa8d30190391e4403789217012c
GIT binary patch
literal 963
zc%17D@N?(olHy`uVBq!ia0vp^4nVBH!3-p)I`?e@QY`6?zK#qG>ra@ocD)4hB}-f*
zN`mv#O3D+9QW+dm@{>{(JaZG%Q-e|yQz{EjrrIztFop&Agt+opuugf?>V4mM=G$)h
zDLi5soEm!t=DzE1dsQkJ!0vKSyWwTNNFqnVV{i5C{Jb`-7I$R3URCMe5^j1~l>aok
z|8>LC_cKjyODas`(LODxb6zm@Nr2o0p2=@oA|5(!{J7lho^I`nZ1o-dQq^4U_w<*&
zpVjfI!sxcR`#rtbNA60CdA;r%l{`ya`(e?vHyxo5?JJ+BmpxD6b72d5U@hRsrm~i=
z^<`=BLz|LkN$R`!B?>reUS#QB6H=JLE8V~y_sE0CidAVoZ^5$|y<0*B&tkRD3T8hI
zce<zP_rT2co{m&4m*yb>$Ghsv%lP<R*$i%ph{SOS$8aoqKW*ZhrlyyLYFqh5;yDC^
z*!kVr)_hpF=-pK9bAr*2TxD9h`JCA#iaDL{X*t|g(>g9N|J@|18ZO-{LUMgPigS21
zj|vn%i<6(sll~+)@{yD32L8~8cI!VbvAwGd4FA8I&3*%^qLLuL;Q#an3^mtJzW~N>
zsi%u$NX4xrjU@sMECS3+*?^=Svx?D<q>5OVqaUOg1RQ?wa7+-mbloIn`tfXFs(NVL
z(0J7-@OH1I(0WD&#+K_0!tT<AmIoE~fb_;OE9ESm(`z~DBS>onZ%1;WsF8UxM5k$k
zz3(M^{~3}{jcqqnKFTE8f;HZ2IWpmq?t#+>JFYV{FdWKvu!(lurtohH2hah$2~R%@
z3Leb|nPIMAF#WWW#D0(o_Zj@+{h1^Gfb`cf|G6Y8^07Tp5u~VLzH96328bFq{Zc_w
zu$q5Nt%^ERG=)K$T@EnF=`u2@3OO(Y#w=lE5jYBQe##=-CC-aVpw3Tt>b>E)*lDQq
z4`^tI9`1}31v}qfHe#liQRHKPPoQB6`Wl-z7`}X9%AnBjLHdEfx#Z<f`am98WFf`K
h)RDx@fJE>xG$lk{-#7cq7hv==c)I$ztaD0e0su9Tqz(W8

diff --git a/scripts/java/org/octave/images/octave.png b/scripts/java/org/octave/images/octave.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..030f44d2584ef9f0cfaec03d68ebd16642fe1302
GIT binary patch
literal 1463
zc$^(m2~<-@6n+0gAcUlXEV5Wl5fDL95ELrq{78t2Y+(zF6ax}A2`IAb@gPWLvn(Ql
zwU%(iMoIxwR6xW)0izXK(c)56h=@wvSZkwX`stiA^UlnBGxxsx<`waMcQ9yXGyq`m
zxa<JZGM6S*gIw9?iU&xe8OQQr0kkN#Qi@-Zd($+}(6qpm*tE>3R1vUZQldpno;WH_
z6d;O<$=-ic<OYD{^1XvRv3tlk3_<L3NVvc57!uSXZUJ&hN9NTCI10>54Pp1e<L;JY
z2ws20rq#f|2~JYj(hdm0wm#Dm1a9{rZ30F=!o1op9^pfaSm`3LrCwDC!Y84B3UU_d
zClUOs2GJsx_-V}^1a?J?KqQnP{A)GtuQpFd@Y_6f1c5{L%4h_v8d?&9qc0$R)?0#>
zry}rpvsa2Bc+Tt~33_q^dBRZzmY@|65N#B}@Vwn&1T!-bG0TWRz#g~AL0JALd<=nC
z2W1+8Z9K5&4U!RY2x-hA*pLQ$rosLM%&XSMB5N@+mLSa!B;o?}%^F4_;LYe3AaFVY
zum8~*N8tN3t{&n07hz*PbUoJbLvZk2YBQo|ASj(Pi$|bR!SqM)o1#V|YAMnt$vB9!
zWe98{A>@kvUi5_oxmF-(c@I~|p&KzH5x75vhaU{GP~3C3JpdZlcx+Zs)}v^J!p456
zl{*}BG9Ls2fsfDNIZK~9E~O;cngEATc*twYNK(Hh#@_utFc7PaB_*lX3pkB{^$8^j
zDJi!GB8?l*8z(-S=+niM)P#KKt^Ht~LQ{{RpKe-MFxui=nqbx(Tc7iUSr;;-46-(A
zoLsv>+)F0|nlie4qs$_@t68h)Sg)R*<c8!|Ma}s)7C+bk=}uLPv=X{66)8JE5vJuB
zQ*_p`G2-%MvYSODi7q!EP>3S!<W0KE1+w8g7s^E7Xl0Rqdv8DcXbgrI_S|F+c2yf#
z>>i5~%B7M9YJh*-ZAR6KDhidUl^OC^xC2Hhw>DkF;cyuCySxl`Fz;8?8c5}O%v_VS
zw!wav+Ghm?9<m@OVkW{Nxk%YTbYBE6Mru-%@ZD@KL%R7+hO^`F$Y+&)6XPQkb1Z=5
zEToJIHQL%}rj5aQwx9P?vIx#Z@d5lX>0(lflmw-t!nS~Z*0DNU`E9xqA3fCDTglu;
z(xpn7oK-P(N249{WtEM(23OjDS#zb!NfBV}s~?sN(SO_-qv5t83yQ7EW#zo;jF{+*
z&!ToZ`5PNg`e|z!lB`~~=NWNrJ8>gJ%h?y399)kTzMxF!8(Pj}VVZjR2iv}(aamDq
zwVAmAl5?#^S%os*SsM4qj#XtqUUs?QV1~Kgq8$D*M}K^$ey?Mg>n-c*V!{r0n;F#v
zQq6U@<;x~4{QNWhuNCG}c|4vd;Y18Sew$%<rw(Z9X|x;<&%id}8ZJpm?D@GWnu$qF
z(4|V2zxms^zpcsi2}(es;0d!iu=e;>-^)K07h9bYtPk~a;x8%sUUrK2>LteT7GA8N
zISaj?DP_+caUGY!PSyXfb6N2<Hhd3uM_@d|#!)Qp(PCF!{jqj-DYXYQ=R$pXnpVX|
zO>=p)JlM`cmqgnw{c}_7jl5tR(}V;4eW7^<bbj{fj+*lIBwD-1-EvO&;ifdOv9i{t
zP#QK9mEzMaHRW~AOV#a2Jn&GZ3UAEf&gy#2V65g=%lv>?_Z9r>!hI{r0BJaGkSP}b
zysN&e-F~&nOEc}T0XWfA-V}AlopftDc)m(4q3Y-q74D-E*xE7^mmWcbnekE;+%l`S
zUl7tvsI<J+Iws$>ydnAfMq%huvy7gJl#TREQT6E9)YK7omFkE)`N^43Ri+^$h}F1K
iN#O48R#sN-o`7k=qr&T7xzciAY4ALK+0EO9dH(_6kXd;E

diff --git a/scripts/java/org/octave/images/question.png b/scripts/java/org/octave/images/question.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..3098763a86700200907fe01a2adb0b8820ee6451
GIT binary patch
literal 1778
zc$~#ljX%{_7=NyN>Ed2)ADdLG?q*Fj(_N+6+Sb(zw~>#~(#xdVDy^v-p;hYVEu>JA
zmn7vS8;Q|XRIay$66$J9tD8cM66Gc7yWibEvGaM(dCupY=lP!R`JR_ZXD551!4v}`
z60VRfb78%dtztfxZR3|lD_O_eX1mgss37{l*s3_~<Yt-6N}_!;iI@<gQLz3Qk)MR9
z$CK!*1fog15`Ilm6LHDe(QWx!fGn5JV_W)$DANkCz<69Z<W8W;pSgYu%FL$hobA9t
zZA?>G0H$Mvk3J5%Lf8?hyBUV4;if+NreJsv;0@RTy6B<Hh2$4X%hr*1-~qrA_!w_Z
zFet(RwX11w7~QIz1Iz{NS)6;dq-mmE%npEu?hi2XA;!pcs{=3tZ<YW8yr5HOC?<h=
zT4?Mkp-XGy9rUh)M%#&Eh*U%xA`hZIq5z^HT^iJ3V+dO7Z2rU$6KOEe8`E^)wHkba
z4!W)0gE3(S4~xvT9Xl(0FU5kXhzW-69K-+<sK=Bri6GG0Yw`)2HyNj6vC9LI`@!~C
zvgE}Jx32*mI_d~G*}zv0LzcsX23p`S+ZdE|)(9`@VxAF8W8-d*@8G>2zj%S=!ycGo
zW5I6E0-sHVzVf0yo0WcBt^{nox_4X2FJ7hlwqM`B<HmuXRe|2+2X|H++EvLYs)KxP
z2K&~8_|=B`*M$Y#4&PfJv9BR=f5VXjO;Le&j~-MXJJcK<bU!AzB{rn>cxc;+u(r7H
zzvCkwo{H2Y9C@4=)t+?pX>v@*>DaE6<6UP?bf?Dkq@C<NcdGAv!t?aR7a2(}Gm{6h
zQU))ad7Yg)^jq3+&bg7?^KUL@jOAs%y_7Yce*p#ADEt*gIk=n)<wX=<!j*hnEkH>j
zt`*_>W!zArtQe}RC@(?9HB?<k^$q+{hMVQ6sX%Qd>Z)+N8ufqRPAwYh(0B_?w{f=~
z>IO77;(inUyoVMwTAR`KCmyum?^Zng3y<2Md4Tpuc%s46$LMHB=M!{2MRzB9p5dQv
z^!A|dA3X0v|8u;2fq{Mu4&c=whF)WM2qVK79l@JXjE!M@9Pi$NEivvrhuLFb_P98?
z;{PpVqwBDZNT*}PGF!L3De`Q4?x~W)!F9QcG@-7e*z=BfW^mqgF=N)K>sY5=-P%$l
zlCE7lS#D$!C%7d0x?~?i6%w)iDyRE3G7<l_SY^g@b8};|k~e=&Vn!m+ymxuveI1Uz
zzW&*|{=110*<OZGKGxROt5<tldJtdi$ThRB@|LPnA5~gdKA0=?BKwt0!nxes*tN<9
zGya2@GhbJc>A^3~=4WI`%NlL+(wG)entt$Tq8{-?PLpg3=m*V{zRvc}X{PI(%}yIF
zD6dgdC9$bHne_CWMNv`3#S<1snbc%RtvLQ^`Yi%>;SG9{(qMtY*WYK$R{ww@e*OEN
z!}Cs7$=UC2leOyM;mH~G)%Dd6%gck3S|b-9|I}P{%fV&BJuRv?lM^@Jy)0x}VVv)e
zyh-7bM)DAFNr!)$Q!*r8EGaGQUn)@ewa4T-L{;u&0Us-Z($mc)Go`Oe7kybe(?ahr
z1H-6IT7eW(=&tcRCM+!MQT4s~tw!M-;)J$Q#JHv99V`9isj2?{N~M^4vay-V6Geye
zd`MPi;#^jC$iR7VBQIAgK;9k=f1zrcS!}A5+pCyLBIy+&B~zqBF>ieYNBQ4oQ}k>q
zg#AU;+q7hAj)^QtNS(E^Yufzhy#gb<2)hXV79ktSLb_4~t$(YXvf}pIzB!Zf&D-C0
z%zrtBMYa)A=F&B$UzCYC{)rs-^oe37Kb)hctriIib}bv%k688QOHF>HS+lw3<rZ^h
zsZ0&>wVCb$Su-z-GgY?4r^`4x@^JUfpR`JUF5PHylK-=+n@OrRw=v9`k)su0yVNOu
zL&0<&W4N%`b0a@rX)2e;+O07bNfY%HM>=<#ld+DQ+p~3&P1zIpVoN<q@~n?Ifo8J!
zgkp8P=Mrt8yFg>P%Gp`8oMRwz-jX>xl)c0%QoSm6Irclo*~dpKmOCxWTjCk~FUDV`
AV*mgE

diff --git a/scripts/java/org/octave/images/warning.png b/scripts/java/org/octave/images/warning.png
new file mode 100644
index e69de29bb2d1d6434b8b29ae775ad8c2e48c5391..3c7edfb31faf7dba138ec6d3014dfa4bd91dbb8d
GIT binary patch
literal 1508
zc$~$Qi&Ila6o>cTn*<UPNdl$`qLZpT1VmmUttgieP*i9DEl?Qckq4n;5lRI+T7mM2
zf(}AZ5L6zKLJ>+MYQbuGh=@`}Ml_;r6|F_9)u93*xw*H?U(ub}bLPyM^V{#t+1*33
z$W0uU0}BAa3EwP@h8~AoY>h!%6>{_<bTn0PL@)q9+*n6H{1V2Z?9jOEm<(lhPI8t4
z1j{p06yosR$tp#(B3ZsKb661w0Fo!$wmsC(k3tYKcOQ+QmQK%LBvqM~MiHcMY#fw7
z1VB4MZXwA10Nf$S(Ajy+LaB>NPz#y$>;+~fS6C>yL_(2NAwhZo5CTBD*%JNg4NRdi
zF;s3YHBT@}>LfuSZSClsiDo7_WA`wEVgv@#Cmz$v%Bb$k=<W=RAQMa$%w$;{A5Re!
zIz7WKETs5+s<DwWlk~UKSY{@aqSe;Ivl_NVU@u-ml7RjDsiw1#x%6ruYN3K|-A2u%
z)wlsmNkz0;>h@jOLi~5FC_%9aie<9Uj#Z)qgP76G17NE56xwwWn<rpMGnyeVVl>ln
z9N8Fznk)!G+5P?m^4Q+`)%xjkj!KQbdAmlXwmDr7;f2SmQKM;t(X=!~$~0MmDk`C6
z9Qej|o?y%x6R-SYKWkj8Yi7-vJg*Pi&&(-*Jin;5&HnyF>r36JVM1UuGoqrgwst0*
z)Yv_BHFSB|(UCFK|GPi{eX9xpY-hMMczf<dO3M&dQCaF^)Y;s8*NRw+8FfD6Vfi)7
zonAkDJl2Cs0t2cL8rKtJxhs}qGu^qOK|@))F0|-crU-EH0JiI#y|Oh*RzAr}DWCJI
z+H-#~Up3gl7w2^@kvVcz9ejuMRl~zJKKR;*f&@H~*A|@z`qS}9O)cBT0M>Zg`KQ|Y
z#_r&$kWJ^D0gdaAO*<yajROPyk`O1Sk3^i;7e?}&y&f?;KTC~bbMZL#X5Kx4l4(mv
zS`fWbsl2MbEiu%Ah0G}PQ;ZI{Q~8|o2Nm>__5a-RSbcPm36MfHzB)$Zbugfxo+Y@>
z)9Z_iUv1<Y0+EF(Znk$Uv!oh$_ikJ+Vag>A>jW+kq#1GSJ4rmn?IaEPu0u+mon3=Y
zo;Ee$Sy&?ksPzEg<R}srdx5ZTbvpY|I*%vDwCwSkue_UJ^ImMt-Ut4+R<9T$;1|pi
zYV<rD_<VSLiSGt<K{`Cr!>v~e5F9g<DHIJ1W5B;jLfC_lA$6j67KX4jW$eoLET7I2
zQN8X9m*<*}Wl)r}C#OKjW%=V3C-Nf%a?}9!B4vq8E?&L!NsEt_s2<JCUwPtC-Lg>-
zAMX@WjtJ=(4w4;`nmn*M3B<esHk2d1+9#<lhm+y|k{p(*J?QAl=rgSdekr2ijOx~*
zk4sq%ZC2LekwW{y=ly)vm&hn>YdNA9V~I8MQg1D`fPeQwua?#&k^`4cseV*nP@UB5
z*4JLz;J5%es^Pz<{q>?#wl(b-W47pA&BpbY{ED;S*egyoeSYOxTzw5QS{ILAd8%r5
zOBpI@b%2*eSkF6)xkcg5o4-bUD}NS@f}kM!0p4B@Ity~TkNGuL*NGJsD_dmtspq@8
zMs{daf>nKuLRc#J{%%x3WTpq46_$6}i+8?jBvy9h!JTW(0+{{aZ+x9=+e7_3j8i^2
zxfbaGLRMH@6`aD+!=Wo~{<bS2BCfdTOi<mKGlPlO@B8yEZ-JycE~urCri||EyIa)h
z={?=8`<%6tGHWjWlY8uusfm@&eebthWhnmaVb$FPs0P_Jeo8TLOgC^%Tk;79&qF{`
W>LQS{6Z-?cdJrBODeaIX75oP~Ex-c+

diff --git a/scripts/java/questdlg.m b/scripts/java/questdlg.m
new file mode 100644
--- /dev/null
+++ b/scripts/java/questdlg.m
@@ -0,0 +1,101 @@
+## Copyright (C) 2010 Martin Hepperle
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {@var{btn} =} questdlg (@var{msg})
+## @deftypefnx {Function File} {@var{btn} =} questdlg (@var{msg}, @var{title})
+## @deftypefnx {Function File} {@var{btn} =} questdlg (@var{msg}, @var{title}, @var{default})
+## @deftypefnx {Function File} {@var{btn} =} questdlg (@var{msg}, @var{title}, @var{btn1}, @var{btn2}, @var{default})
+## @deftypefnx {Function File} {@var{btn} =} questdlg (@var{msg}, @var{title}, @var{btn1}, @var{btn2}, @var{btn3}, @var{default})
+## Display @var{msg} using a question dialog box and return the caption
+## of the activated button.
+##
+## The dialog may contain two or three buttons which will all close the dialog.
+##
+## The message may have multiple lines separated by newline characters
+## (@code{"\n"}), or it may be a cellstr array with one element for each
+## line.  The optional @var{title} (character string) can be used to
+## decorate the dialog caption.
+##
+## The string @var{default} identifies the default button, 
+## which is activated by pressing the @kbd{ENTER} key.
+## It must match one of the strings given in @var{btn1}, @var{btn2} or
+## @var{btn3}.
+##
+## If only @var{msg} and @var{title} are specified, three buttons with
+## the default captions "Yes", "No", and "Cancel" are used.
+##
+## If only two button captions, @var{btn1} and @var{btn2}, are specified 
+## the dialog will have only these two buttons.
+##
+## @seealso{errordlg, helpdlg, inputdlg, listdlg, warndlg}
+## @end deftypefn
+
+function btn = questdlg (msg, title = "Question Dialog", varargin)
+
+  if (nargin < 1 || nargin > 6)
+    print_usage ();
+  endif
+  
+  if (! ischar (msg))
+    if (iscell (msg))
+      msg = sprintf ("%s\n", msg{:});
+      msg(end) = "";
+    else
+      error ("questdlg: MSG must be a character string or cellstr array");
+    endif
+  endif
+
+  if (! ischar (title))
+    error ("questdlg: TITLES must be a character string");
+  endif
+
+  options{1} = "Yes";      # button1
+  options{2} = "No";       # button2
+  options{3} = "Cancel";   # button3
+  options{4} = "Yes";      # default
+
+  switch (numel (varargin))
+    case 1
+      ## default button string
+      options{4} = varargin{1};  # default
+
+    case 3
+      ## two buttons and default button string
+      options{1} = varargin{1};  # button1
+      options{2} = "";           # not used, no middle button
+      options{3} = varargin{2};  # button3
+      options{4} = varargin{3};  # default
+
+    case 4
+      ## three buttons and default button string
+      options{1} = varargin{1};  # button1
+      options{2} = varargin{2};  # button2
+      options{3} = varargin{3};  # button3
+      options{4} = varargin{4};  # default
+
+    otherwise
+      print_usage ();
+
+  endswitch
+
+  btn = javaMethod ("questdlg", "org.octave.JDialogBox", msg,
+                     title, options);
+
+endfunction
+
diff --git a/scripts/miscellaneous/usejava.m b/scripts/java/usejava.m
rename from scripts/miscellaneous/usejava.m
rename to scripts/java/usejava.m
--- a/scripts/miscellaneous/usejava.m
+++ b/scripts/java/usejava.m
@@ -33,57 +33,60 @@
 ## @item "jvm"
 ## Java Virtual Machine.
 ##
 ## @item "swing"
 ## Swing components for lightweight GUIs.
 ## @end table
 ##
 ## @code{usejava} determines if specific Java features are available in an
-## Octave session.  This function is provided for compatibility with scripts
-## which may alter their behavior based on the availability of Java.  The
-## feature "desktop" always returns @code{false} as Octave has no Java-based
-## desktop.  Other features may be available if the Octave-Forge Java package
-## has been installed.
+## Octave session.  This function is provided for scripts which may alter
+## their behavior based on the availability of Java.  The feature "desktop"
+## always returns @code{false} as Octave has no Java-based desktop.  Other
+## features may be available if Octave was compiled with the Java Interface
+## and Java is installed.
 ## @end deftypefn
 
 function retval = usejava (feature)
 
   if (nargin != 1 || ! ischar (feature))
     print_usage ();
   endif
 
   retval = false;
 
   switch feature
-    ## For each feature, try javamethods() on a Java class of a feature
+    ## For each feature, try methods() on a Java class of a feature
     case "awt"
       try
-        dum = javamethods ("java.awt.Frame");
+        dum = methods ("java.awt.Frame");
         retval = true;
       end_try_catch
     case "desktop"
       ## Octave has no Java based GUI/desktop, leave retval = false
     case "jvm"
       try
-        dum = javamethods ("java.lang.Runtime");
+        dum = methods ("java.lang.Runtime");
         retval = true;
       end_try_catch
     case "swing"
       try
-        dum = javamethods ("javax.swing.Popup");
+        dum = methods ("javax.swing.Popup");
         retval = true;
       end_try_catch
     otherwise
       error ("usejava: unrecognized feature '%s'", feature);
   endswitch
 
 endfunction
 
 
 %!assert (usejava ("desktop"), false)
 
+%!testif HAVE_JAVA
+%! assert (usejava ("jvm"), true);
+
 %% Test input validation
 %!error usejava ()
 %!error usejava (1, 2)
 %!error usejava (1)
 %!error <unrecognized feature> usejava ("abc")
 
diff --git a/scripts/java/warndlg.m b/scripts/java/warndlg.m
new file mode 100644
--- /dev/null
+++ b/scripts/java/warndlg.m
@@ -0,0 +1,54 @@
+## Copyright (C) 2010 Martin Hepperle
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {@var{h} =} warndlg (@var{msg})
+## @deftypefnx {Function File} {@var{h} =} warndlg (@var{msg}, @var{title})
+## Display @var{msg} using a warning dialog box. 
+##
+## The message may have multiple lines separated by newline characters
+## ("\n"), or it may be a cellstr array with one element for each
+## line.  The optional input @var{title} (character string) can be used to
+## set the dialog caption.  The default title is "Warning Dialog".
+##
+## @seealso{helpdlg, inputdlg, listdlg, questdlg}
+## @end deftypefn
+
+function retval = warndlg (msg, title = "Warning Dialog")
+
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+  endif
+
+  if (! ischar (msg))
+    if (iscell (msg))
+      msg = sprintf ("%s\n", msg{:});
+      msg(end) = "";
+    else
+      error ("warndlg: MSG must be a string or cellstr array");
+    endif
+  endif
+
+  if (! ischar (title))
+    error ("warndlg: TITLE must be a character string");
+  endif
+
+  retval = javaMethod ("warndlg", "org.octave.JDialogBox", msg, title);
+
+endfunction
+
diff --git a/scripts/miscellaneous/bzip2.m b/scripts/miscellaneous/bzip2.m
--- a/scripts/miscellaneous/bzip2.m
+++ b/scripts/miscellaneous/bzip2.m
@@ -44,19 +44,19 @@ endfunction
 
 
 %!xtest
 %! # test for correct cleanup of temporary files
 %! unwind_protect
 %!   filename = tmpnam;
 %!   dummy    = 1;
 %!   save (filename, "dummy");
-%!   n_tmpfiles_before = length (find (strncmp ("oct-", cellstr (ls (P_tmpdir)), 4)));
+%!   n_tmpfiles_before = length (find (strncmp ("oct-", cellstr (ls (tempdir)), 4)));
 %!   entry = bzip2 (filename);
-%!   n_tmpfiles_after = length (find (strncmp ("oct-", cellstr (ls (P_tmpdir)), 4)));
+%!   n_tmpfiles_after = length (find (strncmp ("oct-", cellstr (ls (tempdir)), 4)));
 %!   if (n_tmpfiles_before != n_tmpfiles_after)
 %!     error ("bzip2 has not cleaned up temporary files correctly!");
 %!   endif
 %! unwind_protect_cleanup
 %!   delete (filename);
 %!   [path, basename, extension] = fileparts (filename);
 %!   delete ([basename, extension, ".bz2"]);
 %! end_unwind_protect
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -481,24 +481,28 @@ function ret = edit (varargin)
 
         text = cstrcat (comment, body);
       case "m"
         ## If we are editing a function defined on the fly, paste the
         ## code.
         if (any (exists == [2, 103]))
           body = type (name){1};
         else
-          body = cstrcat ("function [ ret ] = ", name, " ()\n\nendfunction\n");
+          body = cstrcat ("function [ret] = ", name, " ()\n\nendfunction\n");
         endif
         if (isempty (head))
-          comment = cstrcat ("## ", name, "\n\n",
+          comment = cstrcat ("## -*- texinfo -*- \n## @deftypefn {Function File}", 
+                             "{@var{ret} =}", name, "(@var{x}, @var{y})\n##\n",
+                             "## @seealso{}\n## @end deftypefn\n\n",
                              "## ", strrep (tail, "\n", "\n## "), "\n\n");
         else
           comment = cstrcat ("## ", strrep (head,"\n","\n## "), "\n\n", ...
-                             "## ", name, "\n\n", ...
+                             "## -*- texinfo -*- \n## @deftypefn {Function File}", 
+                             "{@var{ret} =}", name, "(@var{x}, @var{y})\n##\n",
+                             "## @seealso{}\n## @end deftypefn\n\n",
                              "## ", strrep (tail, "\n", "\n## "), "\n\n");
         endif
         text = cstrcat (comment, body);
     endswitch
 
     ## Write the initial file (if there is anything to write)
     fid = fopen (fileandpath, "wt");
     if (fid < 0)
diff --git a/scripts/miscellaneous/error_ids.m b/scripts/miscellaneous/error_ids.m
new file mode 100644
--- /dev/null
+++ b/scripts/miscellaneous/error_ids.m
@@ -0,0 +1,55 @@
+## Copyright (C) 2012 Juan Pablo Carbajal
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @cindex error ids
+##
+## @table @code
+## @item Octave:invalid-context
+## Indicates the error was generated by an operation that cannot be executed in
+## the scope from which it was called.  For example, the function
+## @code{print_usage ()} when called from the Octave prompt raises this error.
+##
+## @item Octave:invalid-input-arg
+## Indicates that a function was called with invalid input arguments.
+##
+## @item Octave:invalid-fun-call
+## Indicates that a function was called in an incorrect way, e.g., wrong number
+## of input arguments.
+##
+## @item Octave:invalid-indexing
+## Indicates that a data-type was indexed incorrectly, e.g., real-value index
+## for arrays, non-existent field of a structure.
+##
+## @item Octave:bad-alloc
+## Indicates that memory couldn't be allocated.
+##
+## @item Octave:undefined-function
+## Indicates a call to a function that is not defined. The function may
+## exist but Octave is unable to find it in the search path.
+##
+## @end table
+
+
+function error_ids ()
+  help ("error_ids");
+endfunction
+
+
+## Remove from test statistics.  No real tests possible
+%!assert (1)
diff --git a/scripts/miscellaneous/getfield.m b/scripts/miscellaneous/getfield.m
--- a/scripts/miscellaneous/getfield.m
+++ b/scripts/miscellaneous/getfield.m
@@ -13,38 +13,22 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{v1}, @dots{}] =} getfield (@var{s}, @var{key}, @dots{})
-## Extract a field from a structure (or a nested structure).  For example:
-##
-## @example
-## @group
-## ss(1,2).fd(3).b = 5;
-## getfield (ss, @{1,2@}, "fd", @{3@}, "b")
-##    @result{} 5
-## @end group
-## @end example
+## @deftypefn {Function File} {[@var{val}] =} getfield (@var{s}, @var{field})
+## @deftypefnx {Function File} {[@var{val}] =} getfield (@var{s}, @var{idx1}, @var{field1}, @var{idx2}, @var{field2}, @dots{})
+## Extract a field from a structure (or a nested structure). The syntax
+## is the same as @code{setfield}, except it omits the final @var{val}
+## argument, returning this value instead of setting it.
 ##
-## Note that the function call in the previous example is equivalent to
-## the expression
-##
-## @example
-## @group
-## i1 = @{1,2@}; i2 = "fd"; i3 = @{3@}; i4= "b";
-## ss(i1@{:@}).(i2)(i3@{:@}).(i4)
-##    @result{} 5
-##
-## @end group
-## @end example
 ## @seealso{setfield, rmfield, isfield, isstruct, fieldnames, struct}
 ## @end deftypefn
 
 ## Author: Etienne Grossmann <etienne@cs.uky.edu>
 
 function obj = getfield (s, varargin)
   if (nargin < 2)
     print_usage ();
diff --git a/scripts/miscellaneous/ls.m b/scripts/miscellaneous/ls.m
--- a/scripts/miscellaneous/ls.m
+++ b/scripts/miscellaneous/ls.m
@@ -51,17 +51,17 @@ function retval = ls (varargin)
   endif
 
   if (nargin > 0)
     args = tilde_expand (varargin);
     if (ispc () && ! isunix ())
       ## shell (cmd.exe) on MinGW uses '^' as escape character
       args = regexprep (args, '([^\w.*? -])', '^$1');
     else
-      args = regexprep (args, '([^\w.*? -])', '\$1');
+      args = regexprep (args, '([^\w.*? -])', '\\$1');
     endif
     args = sprintf ("%s ", args{:});
   else
     args = "";
   endif
 
   cmd = sprintf ("%s %s", __ls_command__, args);
 
diff --git a/scripts/miscellaneous/module.mk b/scripts/miscellaneous/module.mk
--- a/scripts/miscellaneous/module.mk
+++ b/scripts/miscellaneous/module.mk
@@ -15,16 +15,17 @@ miscellaneous_FCN_FILES = \
   miscellaneous/computer.m \
   miscellaneous/copyfile.m \
   miscellaneous/debug.m \
   miscellaneous/delete.m \
   miscellaneous/dir.m \
   miscellaneous/dos.m \
   miscellaneous/dump_prefs.m \
   miscellaneous/edit.m \
+  miscellaneous/error_ids.m \
 	miscellaneous/fact.m \
   miscellaneous/fileattrib.m \
   miscellaneous/fileparts.m \
   miscellaneous/fullfile.m \
   miscellaneous/getappdata.m \
   miscellaneous/getfield.m \
   miscellaneous/gunzip.m \
   miscellaneous/gzip.m \
@@ -63,17 +64,16 @@ miscellaneous_FCN_FILES = \
   miscellaneous/symvar.m \
   miscellaneous/tar.m \
   miscellaneous/tempdir.m \
   miscellaneous/tempname.m \
   miscellaneous/unix.m \
   miscellaneous/unpack.m \
   miscellaneous/untar.m \
   miscellaneous/unzip.m \
-  miscellaneous/usejava.m \
   miscellaneous/ver.m \
   miscellaneous/version.m \
   miscellaneous/warning_ids.m \
   miscellaneous/what.m \
   miscellaneous/xor.m \
   miscellaneous/zip.m \
   $(miscellaneous_PRIVATE_FCN_FILES)
 
diff --git a/scripts/miscellaneous/recycle.m b/scripts/miscellaneous/recycle.m
--- a/scripts/miscellaneous/recycle.m
+++ b/scripts/miscellaneous/recycle.m
@@ -12,23 +12,23 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{current_state}} recycle ()
-## @deftypefnx {Function File} {@var{old_state}} recycle (@var{new_state})
+## @deftypefn  {Function File} {@var{current_state} =} recycle ()
+## @deftypefnx {Function File} {@var{old_state} =} recycle (@var{new_state})
 ## Query or set the preference for recycling deleted files.
 ##
-## Recycling files instead of permanently deleting them is currently not
-## implemented in Octave.  To help avoid accidental data loss it
-## is an error to attempt enable file recycling.
+## Recycling files, instead of permanently deleting them, is not currently
+## implemented in Octave.  To help avoid accidental data loss an error
+## will be raised if an attempt is made to enable file recycling.
 ## @seealso{delete}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = recycle (state)
 
   persistent current_state = "off";
diff --git a/scripts/miscellaneous/setfield.m b/scripts/miscellaneous/setfield.m
--- a/scripts/miscellaneous/setfield.m
+++ b/scripts/miscellaneous/setfield.m
@@ -13,35 +13,90 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{k1}, @dots{}, @var{v1}] =} setfield (@var{s}, @var{k1}, @var{v1}, @dots{})
-## Set a field member in a (nested) structure array.  For example:
+## @deftypefn {Function File} {@var{s} =} setfield (@var{s}, @var{field}, @var{val})
+## @deftypefnx {Function File} {@var{s} =} setfield (@var{s}, @var{idx1}, @var{field1}, @var{idx2}, @var{field2}, @dots{}, @var{val})
+##
+## Set a field member @var{field} in a structure @var{s} equal to @var{val}.  For example:
 ##
 ## @example
 ## @group
-## oo(1,1).f0 = 1;
-## oo = setfield (oo, @{1,2@}, "fd", @{3@}, "b", 6);
-## oo(1,2).fd(3).b == 6
-##      @result{} ans = 1
+## @var{s} = struct ();
+## @var{s} = setfield (@var{s}, "foo bar", 42);
 ## @end group
 ## @end example
 ##
+## @noindent
+## This is equivalent to
+##
+## @example
+## @var{s}.("foo bar") = 42;
+## @end example
+##
+## @noindent
+## Note that ordinary structure syntax @code{@var{s}.foo bar = 42} cannot be
+## used here, as the field name is not a valid Octave identifier. Using
+## arbitrary strings for field name is incompatible with @sc{Matlab}, so
+## this usage will warn if the @code{Octave:matlab-incompatible} warning
+## is set. @xref{doc-warning_ids}.
+##
+## With the second calling form, set a field on a structure array,
+## possibly nested, with successive nested indices @var{idx1},
+## @var{idx2}, @dots{} and fields @var{field1}, @var{field2}, @dots{}
+## The indices must be cells containing the desired index at this
+## nesting depth.
+##
+## Thus consider instead,
+##
+## @example
+## @group
+## @var{s} = struct ("baz", 42);
+## setfield (@var{s}, @{1@}, "foo", @{1@}, "bar", 5)
+##     @result{} ans =
+##     scalar structure containing the fields:
+##       baz =  42
+##       foo =
+##         scalar structure containing the fields:
+##           bar =  54
+## @end group
+## @end example
+##
+## Here we first have an ordinary structure array with one field
+## @code{baz} set to 42. Then we set another field in a nested scalar structure
+## indexing with two single cells containing the unique desired indices.
+##
+## Finally an example with nested structure arrays,
+##
+## @example
+## @group
+## @var{sa}.foo = 1;
+## @var{sa} = setfield (@var{sa}, @{2@}, "bar", @{3@}, "baz", 6);
+## @var{sa}(2).bar(3)
+##      @result{} ans =
+##      scalar structure containing the fields:
+##        baz =  6
+## @end group
+## @end example
+##
+## Here @var{sa} is a structure array whose field @code{fd} at elements
+## 1 and 2 field is in turn
+## another structure array whose third element is a structure
+##
 ## Note that the same result as in the above example could be achieved by:
 ##
 ## @example
 ## @group
-## i1 = @{1,2@}; i2 = "fd"; i3 = @{3@}; i4 = "b";
-## oo(i1@{:@}).(i2)(i3@{:@}).(i4) == 6
-##      @result{} ans = 1
+## @var{SA}.foo = 1;
+## @var{SA}(2).bar(3).baz = 6
 ## @end group
 ## @end example
 ## @seealso{getfield, rmfield, isfield, isstruct, fieldnames, struct}
 ## @end deftypefn
 
 ## Author:  Etienne Grossmann <etienne@cs.uky.edu>
 
 function obj = setfield (obj, varargin)
diff --git a/scripts/miscellaneous/warning_ids.m b/scripts/miscellaneous/warning_ids.m
--- a/scripts/miscellaneous/warning_ids.m
+++ b/scripts/miscellaneous/warning_ids.m
@@ -126,16 +126,22 @@
 ## Warn when performing broadcasting operations.  By default, this is
 ## enabled.  See @ref{Broadcasting} in the chapter Vectorization and Faster
 ## Code Execution of the manual.
 ##
 ## @item Octave:built-in-variable-assignment
 ## By default, the @code{Octave:built-in-variable-assignment} warning is
 ## enabled.
 ##
+## @item Octave:deprecated-keyword
+## If the @code{Octave:deprecated-keyword} warning is enabled, a
+## warning is issued when Octave encounters a keyword that is obsolete and
+## scheduled for removal from Octave.
+## By default, the @code{Octave:deprecated-keyword} warning is enabled.
+##
 ## @item Octave:divide-by-zero
 ## If the @code{Octave:divide-by-zero} warning is enabled, a
 ## warning is issued when Octave encounters a division by zero.
 ## By default, the @code{Octave:divide-by-zero} warning is enabled.
 ##
 ## @item Octave:fopen-file-in-path
 ## By default, the @code{Octave:fopen-file-in-path} warning is enabled.
 ##
@@ -165,16 +171,18 @@
 ##
 ## @item Octave:logical-conversion
 ## By default, the @code{Octave:logical-conversion} warning is enabled.
 ##
 ## @item Octave:matlab-incompatible
 ## Print warnings for Octave language features that may cause
 ## compatibility problems with @sc{matlab}.
 ## By default, the @code{Octave:matlab-incompatible} warning is disabled.
+## The --traditional or --braindead startup options for Octave may also
+## be of use, @xref{Command Line Options}.
 ##
 ## @item Octave:md5sum-file-in-path
 ## By default, the @code{Octave:md5sum-file-in-path} warning is enabled.
 ##
 ## @item Octave:missing-glyph
 ## By default, the @code{Octave:missing-glyph} warning is enabled.
 ##
 ## @item Octave:missing-semicolon
@@ -235,31 +243,40 @@
 ## do_braindead_shortcircuit_evaluation (1)
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## if you would like to enable this short-circuit evaluation in
 ## Octave.  Note that the @code{&&} and @code{||} operators always short
 ## circuit in both Octave and @sc{matlab}, so it's only necessary to
-## enable @sc{matlab}-style short-circuiting it's too arduous to modify
+## enable @sc{matlab}-style short-circuiting if it's too arduous to modify
 ## existing code that relies on this behavior.
 ## By default, the @code{Octave:possible-matlab-short-circuit-operator} warning
 ## is enabled.
 ##
 ## @item Octave:precedence-change
 ## If the @code{Octave:precedence-change} warning is enabled, Octave
 ## will warn about possible changes in the meaning of some code due to
 ## changes in precedence for some operators.  Precedence changes have
 ## typically been made for @sc{matlab} compatibility.
 ## By default, the @code{Octave:precedence-change} warning is enabled.
 ##
 ## @item Octave:recursive-path-search
 ## By default, the @code{Octave:recursive-path-search} warning is enabled.
 ##
+## @item Octave:remove-init-dir
+## The @code{path} function changes the search path that Octave uses
+## to find functions.  It is possible to set the path to a value which
+## excludes Octave's own built-in functions.  If the
+## @code{Octave:remove-init-dir} warning is enabled then Octave will warn
+## when the @code{path} function has been used in a way that may render
+## Octave unworkable.
+## By default, the @code{Octave:remove-init-dir} warning is enabled.
+##
 ## @item Octave:reload-forces-clear
 ## If several functions have been loaded from the same file, Octave must
 ## clear all the functions before any one of them can be reloaded.  If
 ## the @code{Octave:reload-forces-clear} warning is enabled, Octave will
 ## warn you when this happens, and print a list of the additional
 ## functions that it is forced to clear.
 ## By default, the @code{Octave:reload-forces-clear} warning is enabled.
 ##
diff --git a/scripts/optimization/fminbnd.m b/scripts/optimization/fminbnd.m
--- a/scripts/optimization/fminbnd.m
+++ b/scripts/optimization/fminbnd.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 ##
 ## Author: Jaroslav Hajek <highegg@gmail.com>
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{x}, @var{fval}, @var{info}, @var{output}] =} fminbnd (@var{fun}, @var{a}, @var{b}, @var{options})
 ## Find a minimum point of a univariate function.
-## 
+##
 ## @var{fun} should be a function handle or name.  @var{a}, @var{b} specify a
 ## starting interval.  @var{options} is a structure specifying additional
 ## options.  Currently, @code{fminbnd} recognizes these options:
 ## "FunValCheck", "OutputFcn", "TolX", "MaxIter", "MaxFunEvals".  For a
 ## description of these options, see @ref{doc-optimset,,optimset}.
 ##
 ## On exit, the function returns @var{x}, the approximate minimum point
 ## and @var{fval}, the function value thereof.
@@ -69,18 +69,17 @@ function [x, fval, info, output] = fminb
   if (nargin < 2 || nargin > 4)
     print_usage ();
   endif
 
   if (ischar (fun))
     fun = str2func (fun, "global");
   endif
 
-  ## TODO
-  ## displev = optimget (options, "Display", "notify");
+  displ = optimget (options, "Display", "notify");
   funvalchk = strcmpi (optimget (options, "FunValCheck", "off"), "on");
   outfcn = optimget (options, "OutputFcn");
   tolx = optimget (options, "TolX", 1e-8);
   maxiter = optimget (options, "MaxIter", Inf);
   maxfev = optimget (options, "MaxFunEvals", Inf);
 
   if (funvalchk)
     ## Replace fun with a guarded version.
@@ -96,30 +95,37 @@ function [x, fval, info, output] = fminb
   c = 0.5*(3 - sqrt (5));
   a = xmin; b = xmax;
   v = a + c*(b-a);
   w = x = v;
   e = 0;
   fv = fw = fval = fun (x);
   nfev++;
 
+  ## Only for display purposes.
+  iter(1).funccount = nfev;
+  iter(1).x = x;
+  iter(1).fx = fval;
+
   while (niter < maxiter && nfev < maxfev)
     xm = 0.5*(a+b);
     ## FIXME: the golden section search can actually get closer than sqrt(eps)
     ## sometimes.  Sometimes not, it depends on the function.  This is the
     ## strategy from the Netlib code.  Something yet smarter would be good.
     tol = 2 * sqrteps * abs (x) + tolx / 3;
     if (abs (x - xm) <= (2*tol - 0.5*(b-a)))
       info = 1;
       break;
     endif
 
     if (abs (e) > tol)
       dogs = false;
       ## Try inverse parabolic step.
+      iter(niter+1).procedure = "parabolic";
+
       r = (x - w)*(fval - fv);
       q = (x - v)*(fval - fw);
       p = (x - v)*q - (x - w)*r;
       q = 2*(q - r);
       p *= -sign (q);
       q = abs (q);
       r = e;
       e = d;
@@ -136,66 +142,95 @@ function [x, fval, info, output] = fminb
       else
         dogs = true;
       endif
     else
       dogs = true;
     endif
     if (dogs)
       ## Default to golden section step.
+
+      ## WARNING: This is also the "initial" procedure following
+      ## MATLAB nomenclature. After the loop we'll fix the string
+      ## for the first step.
+      iter(niter+1).procedure = "golden";
+
       e = ifelse (x >= xm, a - x, b - x);
       d = c * e;
     endif
 
-     ## f must not be evaluated too close to x.
-     u = x + max (abs (d), tol) * (sign (d) + (d == 0));
+    ## f must not be evaluated too close to x.
+    u = x + max (abs (d), tol) * (sign (d) + (d == 0));
+    fu = fun (u);
+
+    niter++;
 
-     fu = fun (u);
-     nfev++;
-     niter++;
+    iter(niter).funccount = nfev++;
+    iter(niter).x = u;
+    iter(niter).fx = fu;
 
-     ## update  a, b, v, w, and x
+    ## update  a, b, v, w, and x
 
-     if (fu <= fval)
-       if (u < x)
-         b = x;
-       else
-         a = x;
-       endif
-       v = w; fv = fw;
-       w = x; fw = fval;
-       x = u; fval = fu;
-     else
-       ## The following if-statement was originally executed even if fu == fval.
-       if (u < x)
-         a = u;
-       else
-         b = u;
-       endif
-       if (fu <= fw || w == x)
-         v = w; fv = fw;
-         w = u; fw = fu;
-       elseif (fu <= fv || v == x || v == w)
-         v = u;
-         fv = fu;
-       endif
-     endif
+    if (fu <= fval)
+      if (u < x)
+        b = x;
+      else
+        a = x;
+      endif
+      v = w; fv = fw;
+      w = x; fw = fval;
+      x = u; fval = fu;
+    else
+      ## The following if-statement was originally executed even if fu == fval.
+      if (u < x)
+        a = u;
+      else
+        b = u;
+      endif
+      if (fu <= fw || w == x)
+        v = w; fv = fw;
+        w = u; fw = fu;
+      elseif (fu <= fv || v == x || v == w)
+        v = u;
+        fv = fu;
+      endif
+    endif
 
     ## If there's an output function, use it now.
     if (outfcn)
       optv.funccount = nfev;
       optv.fval = fval;
       optv.iteration = niter;
       if (outfcn (x, optv, "iter"))
         info = -1;
         break;
       endif
     endif
   endwhile
 
+  ## Fix the first step procedure.
+  iter(1).procedure = "initial";
+
+  ## Handle the "Display" option
+  switch displ
+    case "iter"
+      print_formatted_table (iter);
+      print_exit_msg (info, struct("TolX", tolx, "fx", fval));
+    case "notify"
+      if (info == 0)
+        print_exit_msg (info, struct("fx",fval));
+      endif
+    case "final"
+      print_exit_msg (info, struct("TolX", tolx, "fx", fval));
+    case "off"
+      "skip";
+    otherwise
+      warning ("unknown option for Display: '%s'", displ);
+  endswitch
+
   output.iterations = niter;
   output.funcCount = nfev;
   output.bracket = [a, b];
   ## FIXME: bracketf possibly unavailable.
 
 endfunction
 
 ## An assistant function that evaluates a function handle and checks for
@@ -205,16 +240,46 @@ function fx = guarded_eval (fun, x)
   fx = fx(1);
   if (! isreal (fx))
     error ("fminbnd:notreal", "fminbnd: non-real value encountered");
   elseif (isnan (fx))
     error ("fminbnd:isnan", "fminbnd: NaN value encountered");
   endif
 endfunction
 
+## A hack for printing a formatted table
+function print_formatted_table (table)
+  printf ("\n Func-count     x          f(x)         Procedure\n");
+  for row=table
+    printf("%5.5s        %7.7s    %8.8s\t%s\n",
+           int2str (row.funccount), num2str (row.x,"%.5f"),
+           num2str (row.fx,"%.6f"), row.procedure);
+  endfor
+  printf ("\n");
+endfunction
+
+## Print either a success termination message or bad news
+function print_exit_msg (info, opt=struct())
+  printf ("");
+  switch info
+    case 1
+      printf ("Optimization terminated:\n");
+      printf (" the current x satisfies the termination criteria using OPTIONS.TolX of %e\n", opt.TolX);
+    case 0
+      printf ("Exiting: Maximum number of iterations has been exceeded\n");
+      printf ("         - increase MaxIter option.\n");
+      printf ("         Current function value: %.6f\n", opt.fx);
+    case -1
+      "FIXME"; ## FIXME: what's the message MATLAB prints for this case?
+    otherwise
+      error ("internal error - fminbnd() is bug, sorry!");
+  endswitch
+  printf ("\n");
+endfunction
+
 
 %!shared opt0
 %! opt0 = optimset ("tolx", 0);
 %!assert (fminbnd (@cos, pi/2, 3*pi/2, opt0), pi, 10*sqrt (eps))
 %!assert (fminbnd (@(x) (x - 1e-3)^4, -1, 1, opt0), 1e-3, 10e-3*sqrt (eps))
 %!assert (fminbnd (@(x) abs (x-1e7), 0, 1e10, opt0), 1e7, 10e7*sqrt (eps))
 %!assert (fminbnd (@(x) x^2 + sin (2*pi*x), 0.4, 1, opt0), fzero (@(x) 2*x + 2*pi*cos (2*pi*x), [0.4, 1], opt0), sqrt (eps))
 
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -743,17 +743,17 @@ endfunction
 %! x_opt = [-1.717143501952599;
 %!           1.595709610928535;
 %!           1.827245880097156;
 %!          -0.763643103133572;
 %!          -0.763643068453300];
 %!
 %! obj_opt = 0.0539498477702739;
 %!
-%! assert (x, x_opt, 5*sqrt (eps));
+%! assert (x, x_opt, 8*sqrt (eps));
 %! assert (obj, obj_opt, sqrt (eps));
 
 %% Test input validation
 %!error sqp ()
 %!error sqp (1)
 %!error sqp (1,2,3,4,5,6,7,8,9)
 %!error sqp (1,2,3,4,5)
 %!error sqp (ones (2,2))
diff --git a/scripts/plot/__gnuplot_drawnow__.m b/scripts/plot/__gnuplot_drawnow__.m
--- a/scripts/plot/__gnuplot_drawnow__.m
+++ b/scripts/plot/__gnuplot_drawnow__.m
@@ -328,17 +328,19 @@ function enhanced = gnuplot_set_term (pl
   endif
 
 endfunction
 
 function term = gnuplot_default_term (plot_stream)
   term = getenv ("GNUTERM");
   ## If not specified, guess the terminal type.
   if (isempty (term) || ! __gnuplot_has_terminal__ (term, plot_stream))
-    if (ismac ())
+    if (isguirunning () && __gnuplot_has_terminal__ ("qt", plot_stream))
+      term = "qt";
+    elseif (ismac ())
       term = "aqua";
     elseif (! isunix ())
       term = "windows";
     elseif (! isempty (getenv ("DISPLAY")))
       term = "x11";
     else
       term = "dumb";
     endif
diff --git a/scripts/plot/copyobj.m b/scripts/plot/copyobj.m
--- a/scripts/plot/copyobj.m
+++ b/scripts/plot/copyobj.m
@@ -36,31 +36,41 @@ function hnew = copyobj (horig, hparent 
   if (! ishandle (horig) || nargin > 2)
     print_usage ();
   elseif (! ishandle (hparent))
     hparent = figure (fix (hparent));
   elseif (! any (strcmpi (get (hparent).type, partypes)))
     print_usage ();
   endif
 
+  ## current figure and axes
+  cf = gcf ();
+  ca = gca ();
+  
   ## compatibility of input handles
   kididx = find (strcmp (alltypes, get (horig).type));
   paridx = find (strcmp (alltypes, get (hparent).type));
 
   if (kididx <= paridx)
     error ("copyobj: %s object can't be children to %s.",
            alltypes{kididx}, alltypes{paridx});
   elseif (nargin == 1)
     str = hdl2struct (horig);
     hnew = struct2hdl (str);
   else
     str = hdl2struct (horig);
     hnew = struct2hdl (str, hparent);
   endif
 
+  ## reset current figure (and eventually axes) to original
+  set (0, "currentfigure", cf);
+  if (get (hnew, "parent") == cf)
+    set (cf, "currentaxes", ca)
+  endif
+  
 endfunction
 
 
 %!demo
 %! hdl = figure (1234);
 %! clf;
 %! hold on;
 %! x = 1:10;
diff --git a/scripts/plot/private/__go_draw_axes__.m b/scripts/plot/private/__go_draw_axes__.m
--- a/scripts/plot/private/__go_draw_axes__.m
+++ b/scripts/plot/private/__go_draw_axes__.m
@@ -2143,22 +2143,22 @@ function do_tics_1 (ticmode, tics, mtics
       endif
       if (ischar (labels))
         labels = permute (cellstr (labels), [2, 1]);
       endif
       if (iscellstr (labels))
         k = 1;
         ntics = numel (tics);
         nlabels = numel (labels);
-        fprintf (plot_stream, "set format %s \"%%s\";\n", ax);
+        fprintf (plot_stream, "set format %s \"%%g\";\n", ax);
         if (mirror)
-          fprintf (plot_stream, "set %stics %s %s %s mirror (", ax,
+          fprintf (plot_stream, "set %stics add %s %s %s mirror (", ax,
                    tickdir, ticklength, axispos);
         else
-          fprintf (plot_stream, "set %stics %s %s %s nomirror (", ax,
+          fprintf (plot_stream, "set %stics add %s %s %s nomirror (", ax,
                    tickdir, ticklength, axispos);
         endif
 
         labels = regexprep (labels, '%', "%%");
         for i = 1:ntics
           fprintf (plot_stream, " \"%s\" %.15g", labels{k++}, tics(i));
           if (i < ntics)
             fputs (plot_stream, ", ");
@@ -2168,17 +2168,17 @@ function do_tics_1 (ticmode, tics, mtics
           endif
         endfor
         fprintf (plot_stream, ") %s %s;\n", colorspec, fontspec);
         if (strcmp (mtics, "on"))
           fprintf (plot_stream, "set m%stics %d;\n", ax, num_mtics);
         else
           fprintf (plot_stream, "unset m%stics;\n", ax);
         endif
-     else
+      else
         error ("__go_draw_axes__: unsupported type of ticklabel");
       endif
     else
       fprintf (plot_stream, "set format %s \"%s\";\n", ax, fmt);
       if (mirror)
         fprintf (plot_stream, "set %stics %s %s %s mirror (", ax, tickdir,
                  ticklength, axispos);
       else
diff --git a/scripts/plot/private/__print_parse_opts__.m b/scripts/plot/private/__print_parse_opts__.m
--- a/scripts/plot/private/__print_parse_opts__.m
+++ b/scripts/plot/private/__print_parse_opts__.m
@@ -135,17 +135,17 @@ function arg_st = __print_parse_opts__ (
           error ("print: improper syntax, or value, for GraphicsAlphaBits");
         endif
       elseif ((length (arg) > 2) && arg(1:2) == "-G")
         arg_st.ghostscript.binary = file_in_path (getenv ("PATH"), arg(3:end));
         if (isempty (arg_st.ghostscript.binary))
           error ("print: Ghostscript binary ""%s"" could not be located",
                  arg(3:end));
         else
-          arg_st.ghostscript_binary = __quote_path__ (arg_st.ghostscript_binary);
+          arg_st.ghostscript.binary = __quote_path__ (arg_st.ghostscript.binary);
         endif
       elseif (length (arg) > 2 && arg(1:2) == "-F")
         idx = rindex (arg, ":");
         if (idx)
           arg_st.font = arg(3:idx-1);
           arg_st.fontsize = str2num (arg(idx+1:end));
         else
           arg_st.font = arg(3:end);
@@ -472,17 +472,17 @@ function gs = __ghostscript_binary__ ()
     else
       gs_binaries = {};
     endif
     if (isunix ())
       ## Unix - Includes Mac OSX and Cygwin.
       gs_binaries = horzcat (gs_binaries, {"gs", "gs.exe"});
     else
       ## pc - Includes Win32 and mingw.
-      gs_binaries = horzcat (gs_binaries, {"gs.exe", "gswin32c.exe", "mgs.exe"});
+      gs_binaries = horzcat (gs_binaries, {"gs.exe", "gswin32c.exe", "gswin64c.exe", "mgs.exe"});
     endif
     n = 0;
     while (n < numel (gs_binaries) && isempty (ghostscript_binary))
       n = n + 1;
       ghostscript_binary = file_in_path (getenv ("PATH"), gs_binaries{n});
     endwhile
     if (warn_on_no_ghostscript && isempty (ghostscript_binary))
       warning ("print:noghostscript",
diff --git a/scripts/plot/private/__quiver__.m b/scripts/plot/private/__quiver__.m
--- a/scripts/plot/private/__quiver__.m
+++ b/scripts/plot/private/__quiver__.m
@@ -206,22 +206,29 @@ function hg = __quiver__ (varargin)
         h1 = plot ([x.'; xend.'; NaN(1, length (x))](:),
                    [y.'; yend.'; NaN(1, length (y))](:),
                    "parent", hg);
       endif
     endif
 
     xtmp = x + uu(:) .* (1 - arrowsize);
     ytmp = y + vv(:) .* (1 - arrowsize);
-    xarrw1 = xtmp + (y - yend) * arrowsize / 3;
-    xarrw2 = xtmp - (y - yend) * arrowsize / 3;
-    yarrw1 = ytmp - (x - xend) * arrowsize / 3;
-    yarrw2 = ytmp + (x - xend) * arrowsize / 3;
+
     if (is3d)
+      xarrw1 = xtmp + sqrt((y - yend).^2 + (z - zend).^2) * arrowsize / 3;
+      xarrw2 = xtmp - sqrt((y - yend).^2 + (z - zend).^2) * arrowsize / 3;
+      yarrw1 = ytmp - sqrt((x - xend).^2 + (z - zend).^2) * arrowsize / 3;
+      yarrw2 = ytmp + sqrt((x - xend).^2 + (z - zend).^2) * arrowsize / 3;
+
       zarrw1 = zarrw2 = zend - ww(:) * arrowsize;
+    else
+      xarrw1 = xtmp + (y - yend) * arrowsize / 3;
+      xarrw2 = xtmp - (y - yend) * arrowsize / 3;
+      yarrw1 = ytmp - (x - xend) * arrowsize / 3;
+      yarrw2 = ytmp + (x - xend) * arrowsize / 3;
     endif
 
     if (have_line_spec)
       if (isfield (linespec, "marker")
           && ! strncmp (linespec.marker, "none", 4))
         if (is3d)
           h2 = plot3 ([xarrw1.'; xend.'; xarrw2.'; NaN(1, length (x))](:),
                       [yarrw1.'; yend.'; yarrw2.'; NaN(1, length (y))](:),
diff --git a/scripts/plot/struct2hdl.m b/scripts/plot/struct2hdl.m
--- a/scripts/plot/struct2hdl.m
+++ b/scripts/plot/struct2hdl.m
@@ -87,16 +87,35 @@ function [h, pout] = struct2hdl (s, p=[]
   endif
   ## read parent (last column) in p and remove it if duplicate
   par = p(2,end);
   tst = find (p(2,:) == par);
   if (numel (tst) > 1)
     p = p(1:2, 1:(tst(end)-1));
   endif
 
+  ## Place the "*mode" properties as the end to avoid having the updaters
+  ## change the mode to "manual" when the value is "auto".
+  names = fieldnames (s.properties);
+  n = strncmp (cellfun (@fliplr, names, "uniformoutput", false), "edom", 4);
+  n = (n | strcmp (names, "activepositionproperty"));
+  names = [names(!n); names(n)];
+  if (strcmp (s.type, "axes"))
+    n_pos = find (strcmp (names, "position") | strcmp (names, "outerposition"));
+    if (strcmp (s.properties.activepositionproperty, "position"))
+      names{n_pos(1)} = "outerposition";
+      names{n_pos(2)} = "position";
+    else
+      names{n_pos(1)} = "position";
+      names{n_pos(2)} = "outerposition";
+    endif
+  endif
+  ## Reorder the properties with the mode properties coming last
+  s.properties = orderfields (s.properties, names);
+
   ## create object
   if (strcmp (s.type, "root"))
     h = 0;
     s.properties = rmfield (s.properties, ...
                               {"callbackobject", "commandwindowsize", ...
                                "screendepth", "screenpixelsperinch", ...
                                "screensize"});
   elseif (strcmp (s.type, "figure"))
diff --git a/scripts/set/powerset.m b/scripts/set/powerset.m
--- a/scripts/set/powerset.m
+++ b/scripts/set/powerset.m
@@ -14,48 +14,57 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} powerset (@var{a})
 ## @deftypefnx {Function File} {} powerset (@var{a}, "rows")
+## Compute the powerset (all subsets) of the set @var{a}.
 ##
-## Return a cell array containing all subsets of the set @var{a}.
+## The set @var{a} must be a numerical matrix or a cell array of strings.  The
+## output will always be a cell array of either vectors or strings.
 ##
+## With the optional second argument @code{"rows"}, each row of the set @var{a}
+## is considered one element of the set.  As a result, @var{a} must then be a
+## numerical 2D matrix.
+##
+## @seealso{unique, union, setxor, setdiff, ismember}
 ## @end deftypefn
-## @seealso{unique, union, setxor, setdiff, ismember}
 
 function p = powerset (a, byrows_arg)
 
   byrows = false;
 
   if (nargin == 2)
     if (! strcmpi (byrows_arg, "rows"))
-      error ('powerset: expecting third argument to be "rows"');
+      error ('powerset: expecting second argument to be "rows"');
     elseif (iscell (a))
       warning ('powerset: "rows" not valid for cell arrays');
     else
       byrows = true;
     endif
   elseif (nargin != 1)
     print_usage ();
   endif
+  if (iscell (a) && ! iscellstr (a))
+    error ("powerset: cell arrays can only used for character strings");
+  endif
 
   if (byrows)
     a = unique (a, byrows_arg);
     n = rows (a);
   else
     a = unique (a);
     n = numel (a);
   endif
 
   if (n == 0)
-    p = [];
+    p = {};
   else
     if (n > 32)
       error ("powerset: not implemented for more than 32 elements");
     endif
 
     ## Logical rep
     b = reshape (bitunpack (uint32 (0:2^n-1)), 32, 2^n)(1:n,:);
     ## Convert to indices and lengths.
@@ -72,13 +81,17 @@ function p = powerset (a, byrows_arg)
         p = mat2cell (a(i), k, 1);
       endif
     endif
   endif
 
 endfunction
 
 
-%!test
+%!shared c, p
 %! c = sort (cellstr ({ [], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]}));
 %! p = sort (cellstr (powerset ([1, 2, 3])));
-%! assert (p, c);
+%!assert (p, c);
+%! c = sort (cellstr ({ [], [1:3], [2:4], [3:5], [1:3; 2:4], [1:3; 3:5], [2:4; 3:5], [1:3; 2:4; 3:5]}));
+%! p = sort (cellstr (powerset ([1:3;2:4;3:5], "rows")));
+%!assert (p,c);
+%!assert (powerset([]), {});  # always return a cell array
 
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -168,18 +168,25 @@ function [__ret1, __ret2, __ret3, __ret4
       __file = __file{1};
     endif
   endif
   if (isempty (__file))
     if (__grabdemo)
       __ret1 = "";
       __ret2 = -1;
     else
-      if (exist (__name) == 3)
+      ftype = exist (__name);
+      if (ftype == 3)
         fprintf (__fid, "%s%s source code with tests for dynamically linked function not found\n", __signal_empty, __name);
+      elseif (ftype == 5)
+        fprintf (__fid, "%s%s is a built-in function\n", __signal_empty, __name);
+      elseif (any (strcmp (__operators__ (), __name)))
+        fprintf (__fid, "%s%s is an operator\n", __signal_empty, __name);
+      elseif (any (strcmp (__keywords__ (), __name)))
+        fprintf (__fid, "%s%s is a keyword\n", __signal_empty, __name);
       else
         fprintf (__fid, "%s%s does not exist in path\n", __signal_empty, __name);
       endif
       fflush (__fid);
       if (nargout > 0)
         __ret1 = __ret2 = 0;
       endif
     endif
