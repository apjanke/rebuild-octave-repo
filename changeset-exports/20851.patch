# HG changeset patch
# User Mike Miller <mtmiller@octave.org>
# Date 1449934150 18000
#      Sat Dec 12 10:29:10 2015 -0500
# Node ID 0828bf20d10519cc398660c2696bf4e99c3d2313
# Parent  b36aa3044bcaeb41b7c9d95143a01d372004b7c1
maint: Refactor C++ calls to print_usage to resemble m-files (2015 code sprint)

* chol.cc (Fcholupdate, Fcholinsert, Fcholdelete, Fcholshift): Reverse nargin
checking logic to call print_usage higher in the function.
* qr.cc (Fqrupdate, Fqrinsert, Fqrdelete, Fqrshift): Likewise.

diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -585,115 +585,113 @@ If @var{info} is not present, an error m
   octave_value_list retval;
 
   if (nargin > 3 || nargin < 2)
     print_usage ();
 
   octave_value argr = args(0);
   octave_value argu = args(1);
 
-  if (argr.is_numeric_type () && argu.is_numeric_type ()
-      && (nargin < 3 || args(2).is_string ()))
-    {
-      octave_idx_type n = argr.rows ();
-
-      std::string op = (nargin < 3) ? "+" : args(2).string_value ();
-
-      bool down = op == "-";
+  if (! argr.is_numeric_type () || ! argu.is_numeric_type ()
+      || (nargin > 2 && ! args(2).is_string ()))
+    print_usage ();
 
-      if (down || op == "+")
-        if (argr.columns () == n && argu.rows () == n && argu.columns () == 1)
-          {
-            int err = 0;
-            if (argr.is_single_type () || argu.is_single_type ())
-              {
-                if (argr.is_real_type () && argu.is_real_type ())
-                  {
-                    // real case
-                    FloatMatrix R = argr.float_matrix_value ();
-                    FloatColumnVector u = argu.float_column_vector_value ();
+  octave_idx_type n = argr.rows ();
 
-                    FloatCHOL fact;
-                    fact.set (R);
+  std::string op = (nargin < 3) ? "+" : args(2).string_value ();
+
+  bool down = op == "-";
 
-                    if (down)
-                      err = fact.downdate (u);
-                    else
-                      fact.update (u);
+  if (down || op == "+")
+    if (argr.columns () == n && argu.rows () == n && argu.columns () == 1)
+      {
+        int err = 0;
+        if (argr.is_single_type () || argu.is_single_type ())
+          {
+            if (argr.is_real_type () && argu.is_real_type ())
+              {
+                // real case
+                FloatMatrix R = argr.float_matrix_value ();
+                FloatColumnVector u = argu.float_column_vector_value ();
 
-                    retval(0) = get_chol_r (fact);
-                  }
+                FloatCHOL fact;
+                fact.set (R);
+
+                if (down)
+                  err = fact.downdate (u);
                 else
-                  {
-                    // complex case
-                    FloatComplexMatrix R = argr.float_complex_matrix_value ();
-                    FloatComplexColumnVector u =
-                      argu.float_complex_column_vector_value ();
+                  fact.update (u);
 
-                    FloatComplexCHOL fact;
-                    fact.set (R);
-
-                    if (down)
-                      err = fact.downdate (u);
-                    else
-                      fact.update (u);
-
-                    retval(0) = get_chol_r (fact);
-                  }
+                retval(0) = get_chol_r (fact);
               }
             else
               {
-                if (argr.is_real_type () && argu.is_real_type ())
-                  {
-                    // real case
-                    Matrix R = argr.matrix_value ();
-                    ColumnVector u = argu.column_vector_value ();
+                // complex case
+                FloatComplexMatrix R = argr.float_complex_matrix_value ();
+                FloatComplexColumnVector u =
+                  argu.float_complex_column_vector_value ();
 
-                    CHOL fact;
-                    fact.set (R);
+                FloatComplexCHOL fact;
+                fact.set (R);
 
-                    if (down)
-                      err = fact.downdate (u);
-                    else
-                      fact.update (u);
-
-                    retval(0) = get_chol_r (fact);
-                  }
+                if (down)
+                  err = fact.downdate (u);
                 else
-                  {
-                    // complex case
-                    ComplexMatrix R = argr.complex_matrix_value ();
-                    ComplexColumnVector u = argu.complex_column_vector_value ();
-
-                    ComplexCHOL fact;
-                    fact.set (R);
+                  fact.update (u);
 
-                    if (down)
-                      err = fact.downdate (u);
-                    else
-                      fact.update (u);
-
-                    retval(0) = get_chol_r (fact);
-                  }
+                retval(0) = get_chol_r (fact);
               }
-
-            if (nargout > 1)
-              retval(1) = err;
-            else if (err == 1)
-              error ("cholupdate: downdate violates positiveness");
-            else if (err == 2)
-              error ("cholupdate: singular matrix");
           }
         else
-          error ("cholupdate: dimension mismatch between R and U");
-      else
-        error ("cholupdate: OP must be \"+\" or \"-\"");
-    }
+          {
+            if (argr.is_real_type () && argu.is_real_type ())
+              {
+                // real case
+                Matrix R = argr.matrix_value ();
+                ColumnVector u = argu.column_vector_value ();
+
+                CHOL fact;
+                fact.set (R);
+
+                if (down)
+                  err = fact.downdate (u);
+                else
+                  fact.update (u);
+
+                retval(0) = get_chol_r (fact);
+              }
+            else
+              {
+                // complex case
+                ComplexMatrix R = argr.complex_matrix_value ();
+                ComplexColumnVector u = argu.complex_column_vector_value ();
+
+                ComplexCHOL fact;
+                fact.set (R);
+
+                if (down)
+                  err = fact.downdate (u);
+                else
+                  fact.update (u);
+
+                retval(0) = get_chol_r (fact);
+              }
+          }
+
+        if (nargout > 1)
+          retval(1) = err;
+        else if (err == 1)
+          error ("cholupdate: downdate violates positiveness");
+        else if (err == 2)
+          error ("cholupdate: singular matrix");
+      }
+    else
+      error ("cholupdate: dimension mismatch between R and U");
   else
-    print_usage ();
+    error ("cholupdate: OP must be \"+\" or \"-\"");
 
   return retval;
 }
 
 /*
 %!shared A, u, Ac, uc
 %! A = [  0.436997  -0.131721   0.124120  -0.061673 ;
 %!       -0.131721   0.738529   0.019851  -0.140295 ;
@@ -783,101 +781,99 @@ If @var{info} is not present, an error m
 
   if (args.length () != 3)
     print_usage ();
 
   octave_value argr = args(0);
   octave_value argj = args(1);
   octave_value argu = args(2);
 
-  if (argr.is_numeric_type () && argu.is_numeric_type ()
-      && argj.is_real_scalar ())
-    {
-      octave_idx_type n = argr.rows ();
-      octave_idx_type j = argj.scalar_value ();
+  if (! argr.is_numeric_type () || ! argu.is_numeric_type ()
+      || ! argj.is_real_scalar ())
+    print_usage ();
 
-      if (argr.columns () == n && argu.rows () == n+1 && argu.columns () == 1)
-        {
-          if (j > 0 && j <= n+1)
-            {
-              int err = 0;
-              if (argr.is_single_type () || argu.is_single_type ())
-                {
-                  if (argr.is_real_type () && argu.is_real_type ())
-                    {
-                      // real case
-                      FloatMatrix R = argr.float_matrix_value ();
-                      FloatColumnVector u = argu.float_column_vector_value ();
+  octave_idx_type n = argr.rows ();
+  octave_idx_type j = argj.scalar_value ();
 
-                      FloatCHOL fact;
-                      fact.set (R);
-                      err = fact.insert_sym (u, j-1);
+  if (argr.columns () == n && argu.rows () == n+1 && argu.columns () == 1)
+    {
+      if (j > 0 && j <= n+1)
+        {
+          int err = 0;
+          if (argr.is_single_type () || argu.is_single_type ())
+            {
+              if (argr.is_real_type () && argu.is_real_type ())
+                {
+                  // real case
+                  FloatMatrix R = argr.float_matrix_value ();
+                  FloatColumnVector u = argu.float_column_vector_value ();
 
-                      retval(0) = get_chol_r (fact);
-                    }
-                  else
-                    {
-                      // complex case
-                      FloatComplexMatrix R = argr.float_complex_matrix_value ();
-                      FloatComplexColumnVector u =
-                        argu.float_complex_column_vector_value ();
+                  FloatCHOL fact;
+                  fact.set (R);
+                  err = fact.insert_sym (u, j-1);
 
-                      FloatComplexCHOL fact;
-                      fact.set (R);
-                      err = fact.insert_sym (u, j-1);
-
-                      retval(0) = get_chol_r (fact);
-                    }
+                  retval(0) = get_chol_r (fact);
                 }
               else
                 {
-                  if (argr.is_real_type () && argu.is_real_type ())
-                    {
-                      // real case
-                      Matrix R = argr.matrix_value ();
-                      ColumnVector u = argu.column_vector_value ();
-
-                      CHOL fact;
-                      fact.set (R);
-                      err = fact.insert_sym (u, j-1);
+                  // complex case
+                  FloatComplexMatrix R = argr.float_complex_matrix_value ();
+                  FloatComplexColumnVector u =
+                    argu.float_complex_column_vector_value ();
 
-                      retval(0) = get_chol_r (fact);
-                    }
-                  else
-                    {
-                      // complex case
-                      ComplexMatrix R = argr.complex_matrix_value ();
-                      ComplexColumnVector u =
-                        argu.complex_column_vector_value ();
-
-                      ComplexCHOL fact;
-                      fact.set (R);
-                      err = fact.insert_sym (u, j-1);
+                  FloatComplexCHOL fact;
+                  fact.set (R);
+                  err = fact.insert_sym (u, j-1);
 
-                      retval(0) = get_chol_r (fact);
-                    }
+                  retval(0) = get_chol_r (fact);
                 }
-
-              if (nargout > 1)
-                retval(1) = err;
-              else if (err == 1)
-                error ("cholinsert: insertion violates positiveness");
-              else if (err == 2)
-                error ("cholinsert: singular matrix");
-              else if (err == 3)
-                error ("cholinsert: diagonal element must be real");
             }
           else
-            error ("cholinsert: index J out of range");
+            {
+              if (argr.is_real_type () && argu.is_real_type ())
+                {
+                  // real case
+                  Matrix R = argr.matrix_value ();
+                  ColumnVector u = argu.column_vector_value ();
+
+                  CHOL fact;
+                  fact.set (R);
+                  err = fact.insert_sym (u, j-1);
+
+                  retval(0) = get_chol_r (fact);
+                }
+              else
+                {
+                  // complex case
+                  ComplexMatrix R = argr.complex_matrix_value ();
+                  ComplexColumnVector u =
+                    argu.complex_column_vector_value ();
+
+                  ComplexCHOL fact;
+                  fact.set (R);
+                  err = fact.insert_sym (u, j-1);
+
+                  retval(0) = get_chol_r (fact);
+                }
+            }
+
+          if (nargout > 1)
+            retval(1) = err;
+          else if (err == 1)
+            error ("cholinsert: insertion violates positiveness");
+          else if (err == 2)
+            error ("cholinsert: singular matrix");
+          else if (err == 3)
+            error ("cholinsert: diagonal element must be real");
         }
       else
-        error ("cholinsert: dimension mismatch between R and U");
+        error ("cholinsert: index J out of range");
     }
   else
-    print_usage ();
+    error ("cholinsert: dimension mismatch between R and U");
 
   return retval;
 }
 
 /*
 %!test
 %! u2 = [  0.35080 ;
 %!         0.63930 ;
@@ -1027,84 +1023,82 @@ triangular, return the Cholesky@tie{}fac
   octave_value_list retval;
 
   if (args.length () != 2)
     print_usage ();
 
   octave_value argr = args(0);
   octave_value argj = args(1);
 
-  if (argr.is_numeric_type () && argj.is_real_scalar ())
-    {
-      octave_idx_type n = argr.rows ();
-      octave_idx_type j = argj.scalar_value ();
+  if (! argr.is_numeric_type () || ! argj.is_real_scalar ())
+    print_usage ();
 
-      if (argr.columns () == n)
-        {
-          if (j > 0 && j <= n)
-            {
-              if (argr.is_single_type ())
-                {
-                  if (argr.is_real_type ())
-                    {
-                      // real case
-                      FloatMatrix R = argr.float_matrix_value ();
+  octave_idx_type n = argr.rows ();
+  octave_idx_type j = argj.scalar_value ();
 
-                      FloatCHOL fact;
-                      fact.set (R);
-                      fact.delete_sym (j-1);
+  if (argr.columns () == n)
+    {
+      if (j > 0 && j <= n)
+        {
+          if (argr.is_single_type ())
+            {
+              if (argr.is_real_type ())
+                {
+                  // real case
+                  FloatMatrix R = argr.float_matrix_value ();
 
-                      retval(0) = get_chol_r (fact);
-                    }
-                  else
-                    {
-                      // complex case
-                      FloatComplexMatrix R = argr.float_complex_matrix_value ();
+                  FloatCHOL fact;
+                  fact.set (R);
+                  fact.delete_sym (j-1);
 
-                      FloatComplexCHOL fact;
-                      fact.set (R);
-                      fact.delete_sym (j-1);
-
-                      retval(0) = get_chol_r (fact);
-                    }
+                  retval(0) = get_chol_r (fact);
                 }
               else
                 {
-                  if (argr.is_real_type ())
-                    {
-                      // real case
-                      Matrix R = argr.matrix_value ();
-
-                      CHOL fact;
-                      fact.set (R);
-                      fact.delete_sym (j-1);
+                  // complex case
+                  FloatComplexMatrix R = argr.float_complex_matrix_value ();
 
-                      retval(0) = get_chol_r (fact);
-                    }
-                  else
-                    {
-                      // complex case
-                      ComplexMatrix R = argr.complex_matrix_value ();
+                  FloatComplexCHOL fact;
+                  fact.set (R);
+                  fact.delete_sym (j-1);
 
-                      ComplexCHOL fact;
-                      fact.set (R);
-                      fact.delete_sym (j-1);
-
-                      retval(0) = get_chol_r (fact);
-                    }
+                  retval(0) = get_chol_r (fact);
                 }
             }
           else
-            error ("choldelete: index J out of range");
+            {
+              if (argr.is_real_type ())
+                {
+                  // real case
+                  Matrix R = argr.matrix_value ();
+
+                  CHOL fact;
+                  fact.set (R);
+                  fact.delete_sym (j-1);
+
+                  retval(0) = get_chol_r (fact);
+                }
+              else
+                {
+                  // complex case
+                  ComplexMatrix R = argr.complex_matrix_value ();
+
+                  ComplexCHOL fact;
+                  fact.set (R);
+                  fact.delete_sym (j-1);
+
+                  retval(0) = get_chol_r (fact);
+                }
+            }
         }
       else
-        error ("choldelete: matrix R must be square");
+        error ("choldelete: index J out of range");
     }
   else
-    print_usage ();
+    error ("choldelete: matrix R must be square");
 
   return retval;
 }
 
 /*
 %!test
 %! R = chol (A);
 %!
@@ -1160,88 +1154,86 @@ triangular, return the Cholesky@tie{}fac
 
   if (args.length () != 3)
     print_usage ();
 
   octave_value argr = args(0);
   octave_value argi = args(1);
   octave_value argj = args(2);
 
-  if (argr.is_numeric_type ()
-      && argi.is_real_scalar () && argj.is_real_scalar ())
-    {
-      octave_idx_type n = argr.rows ();
-      octave_idx_type i = argi.scalar_value ();
-      octave_idx_type j = argj.scalar_value ();
+  if (! argr.is_numeric_type () || ! argi.is_real_scalar ()
+      || ! argj.is_real_scalar ())
+    print_usage ();
+
+  octave_idx_type n = argr.rows ();
+  octave_idx_type i = argi.scalar_value ();
+  octave_idx_type j = argj.scalar_value ();
 
-      if (argr.columns () == n)
+  if (argr.columns () == n)
+    {
+      if (j > 0 && j <= n+1 && i > 0 && i <= n+1)
         {
-          if (j > 0 && j <= n+1 && i > 0 && i <= n+1)
+
+          if (argr.is_single_type () && argi.is_single_type ()
+              && argj.is_single_type ())
             {
-
-              if (argr.is_single_type () && argi.is_single_type ()
-                  && argj.is_single_type ())
+              if (argr.is_real_type ())
                 {
-                  if (argr.is_real_type ())
-                    {
-                      // real case
-                      FloatMatrix R = argr.float_matrix_value ();
-
-                      FloatCHOL fact;
-                      fact.set (R);
-                      fact.shift_sym (i-1, j-1);
+                  // real case
+                  FloatMatrix R = argr.float_matrix_value ();
 
-                      retval(0) = get_chol_r (fact);
-                    }
-                  else
-                    {
-                      // complex case
-                      FloatComplexMatrix R = argr.float_complex_matrix_value ();
+                  FloatCHOL fact;
+                  fact.set (R);
+                  fact.shift_sym (i-1, j-1);
 
-                      FloatComplexCHOL fact;
-                      fact.set (R);
-                      fact.shift_sym (i-1, j-1);
-
-                      retval(0) = get_chol_r (fact);
-                    }
+                  retval(0) = get_chol_r (fact);
                 }
               else
                 {
-                  if (argr.is_real_type ())
-                    {
-                      // real case
-                      Matrix R = argr.matrix_value ();
-
-                      CHOL fact;
-                      fact.set (R);
-                      fact.shift_sym (i-1, j-1);
+                  // complex case
+                  FloatComplexMatrix R = argr.float_complex_matrix_value ();
 
-                      retval(0) = get_chol_r (fact);
-                    }
-                  else
-                    {
-                      // complex case
-                      ComplexMatrix R = argr.complex_matrix_value ();
+                  FloatComplexCHOL fact;
+                  fact.set (R);
+                  fact.shift_sym (i-1, j-1);
 
-                      ComplexCHOL fact;
-                      fact.set (R);
-                      fact.shift_sym (i-1, j-1);
-
-                      retval(0) = get_chol_r (fact);
-                    }
+                  retval(0) = get_chol_r (fact);
                 }
             }
           else
-            error ("cholshift: index I or J is out of range");
+            {
+              if (argr.is_real_type ())
+                {
+                  // real case
+                  Matrix R = argr.matrix_value ();
+
+                  CHOL fact;
+                  fact.set (R);
+                  fact.shift_sym (i-1, j-1);
+
+                  retval(0) = get_chol_r (fact);
+                }
+              else
+                {
+                  // complex case
+                  ComplexMatrix R = argr.complex_matrix_value ();
+
+                  ComplexCHOL fact;
+                  fact.set (R);
+                  fact.shift_sym (i-1, j-1);
+
+                  retval(0) = get_chol_r (fact);
+                }
+            }
         }
       else
-        error ("cholshift: R must be a square matrix");
+        error ("cholshift: index I or J is out of range");
     }
   else
-    print_usage ();
+    error ("cholshift: R must be a square matrix");
 
   return retval;
 }
 
 /*
 %!test
 %! R = chol (A);
 %!
diff --git a/libinterp/dldfcn/qr.cc b/libinterp/dldfcn/qr.cc
--- a/libinterp/dldfcn/qr.cc
+++ b/libinterp/dldfcn/qr.cc
@@ -761,96 +761,94 @@ economized (R is square).\n\
   if (args.length () != 4)
     print_usage ();
 
   octave_value argq = args(0);
   octave_value argr = args(1);
   octave_value argu = args(2);
   octave_value argv = args(3);
 
-  if (argq.is_numeric_type () && argr.is_numeric_type ()
-      && argu.is_numeric_type () && argv.is_numeric_type ())
+  if (! argq.is_numeric_type () || ! argr.is_numeric_type ()
+      || ! argu.is_numeric_type () || ! argv.is_numeric_type ())
+    print_usage ();
+
+  if (check_qr_dims (argq, argr, true))
     {
-      if (check_qr_dims (argq, argr, true))
+      if (argq.is_real_type ()
+          && argr.is_real_type ()
+          && argu.is_real_type ()
+          && argv.is_real_type ())
         {
-          if (argq.is_real_type ()
-              && argr.is_real_type ()
-              && argu.is_real_type ()
-              && argv.is_real_type ())
+          // all real case
+          if (argq.is_single_type ()
+              || argr.is_single_type ()
+              || argu.is_single_type ()
+              || argv.is_single_type ())
             {
-              // all real case
-              if (argq.is_single_type ()
-                  || argr.is_single_type ()
-                  || argu.is_single_type ()
-                  || argv.is_single_type ())
-                {
-                  FloatMatrix Q = argq.float_matrix_value ();
-                  FloatMatrix R = argr.float_matrix_value ();
-                  FloatMatrix u = argu.float_matrix_value ();
-                  FloatMatrix v = argv.float_matrix_value ();
-
-                  FloatQR fact (Q, R);
-                  fact.update (u, v);
+              FloatMatrix Q = argq.float_matrix_value ();
+              FloatMatrix R = argr.float_matrix_value ();
+              FloatMatrix u = argu.float_matrix_value ();
+              FloatMatrix v = argv.float_matrix_value ();
 
-                  retval(1) = get_qr_r (fact);
-                  retval(0) = fact.Q ();
-                }
-              else
-                {
-                  Matrix Q = argq.matrix_value ();
-                  Matrix R = argr.matrix_value ();
-                  Matrix u = argu.matrix_value ();
-                  Matrix v = argv.matrix_value ();
+              FloatQR fact (Q, R);
+              fact.update (u, v);
 
-                  QR fact (Q, R);
-                  fact.update (u, v);
-
-                  retval(1) = get_qr_r (fact);
-                  retval(0) = fact.Q ();
-                }
+              retval(1) = get_qr_r (fact);
+              retval(0) = fact.Q ();
             }
           else
             {
-              // complex case
-              if (argq.is_single_type ()
-                  || argr.is_single_type ()
-                  || argu.is_single_type ()
-                  || argv.is_single_type ())
-                {
-                  FloatComplexMatrix Q = argq.float_complex_matrix_value ();
-                  FloatComplexMatrix R = argr.float_complex_matrix_value ();
-                  FloatComplexMatrix u = argu.float_complex_matrix_value ();
-                  FloatComplexMatrix v = argv.float_complex_matrix_value ();
-
-                  FloatComplexQR fact (Q, R);
-                  fact.update (u, v);
+              Matrix Q = argq.matrix_value ();
+              Matrix R = argr.matrix_value ();
+              Matrix u = argu.matrix_value ();
+              Matrix v = argv.matrix_value ();
 
-                  retval(1) = get_qr_r (fact);
-                  retval(0) = fact.Q ();
-                }
-              else
-                {
-                  ComplexMatrix Q = argq.complex_matrix_value ();
-                  ComplexMatrix R = argr.complex_matrix_value ();
-                  ComplexMatrix u = argu.complex_matrix_value ();
-                  ComplexMatrix v = argv.complex_matrix_value ();
+              QR fact (Q, R);
+              fact.update (u, v);
 
-                  ComplexQR fact (Q, R);
-                  fact.update (u, v);
-
-                  retval(1) = get_qr_r (fact);
-                  retval(0) = fact.Q ();
-                }
+              retval(1) = get_qr_r (fact);
+              retval(0) = fact.Q ();
             }
         }
       else
-        error ("qrupdate: Q and R dimensions don't match");
+        {
+          // complex case
+          if (argq.is_single_type ()
+              || argr.is_single_type ()
+              || argu.is_single_type ()
+              || argv.is_single_type ())
+            {
+              FloatComplexMatrix Q = argq.float_complex_matrix_value ();
+              FloatComplexMatrix R = argr.float_complex_matrix_value ();
+              FloatComplexMatrix u = argu.float_complex_matrix_value ();
+              FloatComplexMatrix v = argv.float_complex_matrix_value ();
+
+              FloatComplexQR fact (Q, R);
+              fact.update (u, v);
+
+              retval(1) = get_qr_r (fact);
+              retval(0) = fact.Q ();
+            }
+          else
+            {
+              ComplexMatrix Q = argq.complex_matrix_value ();
+              ComplexMatrix R = argr.complex_matrix_value ();
+              ComplexMatrix u = argu.complex_matrix_value ();
+              ComplexMatrix v = argv.complex_matrix_value ();
+
+              ComplexQR fact (Q, R);
+              fact.update (u, v);
+
+              retval(1) = get_qr_r (fact);
+              retval(0) = fact.Q ();
+            }
+        }
     }
   else
-    error ("qrupdate: Q, R, U, and V must be numeric");
+    error ("qrupdate: Q and R dimensions don't match");
 
   return retval;
 }
 
 /*
 %!shared A, u, v, Ac, uc, vc
 %! A = [0.091364  0.613038  0.999083;
 %!      0.594638  0.425302  0.603537;
@@ -947,131 +945,129 @@ If @var{orient} is @qcode{\"row\"}, full
   if (nargin < 4 || nargin > 5)
     print_usage ();
 
   octave_value argq = args(0);
   octave_value argr = args(1);
   octave_value argj = args(2);
   octave_value argx = args(3);
 
-  if (argq.is_numeric_type () && argr.is_numeric_type ()
-      && argx.is_numeric_type ()
-      && (nargin < 5 || args(4).is_string ()))
-    {
-      std::string orient = (nargin < 5) ? "col" : args(4).string_value ();
+  if (! argq.is_numeric_type () || ! argr.is_numeric_type ()
+      || ! argx.is_numeric_type ()
+      || (nargin > 4 && ! args(4).is_string ()))
+    print_usage ();
 
-      bool col = orient == "col";
+  std::string orient = (nargin < 5) ? "col" : args(4).string_value ();
+
+  bool col = orient == "col";
 
-      if (col || orient == "row")
-        if (check_qr_dims (argq, argr, col)
-            && (col || argx.rows () == 1))
+  if (col || orient == "row")
+    if (check_qr_dims (argq, argr, col)
+        && (col || argx.rows () == 1))
+      {
+        if (check_index (argj, col))
           {
-            if (check_index (argj, col))
+            MArray<octave_idx_type> j
+              = argj.octave_idx_type_vector_value ();
+
+            octave_idx_type one = 1;
+
+            if (argq.is_real_type ()
+                && argr.is_real_type ()
+                && argx.is_real_type ())
               {
-                MArray<octave_idx_type> j
-                  = argj.octave_idx_type_vector_value ();
-
-                octave_idx_type one = 1;
-
-                if (argq.is_real_type ()
-                    && argr.is_real_type ()
-                    && argx.is_real_type ())
+                // real case
+                if (argq.is_single_type ()
+                    || argr.is_single_type ()
+                    || argx.is_single_type ())
                   {
-                    // real case
-                    if (argq.is_single_type ()
-                        || argr.is_single_type ()
-                        || argx.is_single_type ())
-                      {
-                        FloatMatrix Q = argq.float_matrix_value ();
-                        FloatMatrix R = argr.float_matrix_value ();
-                        FloatMatrix x = argx.float_matrix_value ();
+                    FloatMatrix Q = argq.float_matrix_value ();
+                    FloatMatrix R = argr.float_matrix_value ();
+                    FloatMatrix x = argx.float_matrix_value ();
 
-                        FloatQR fact (Q, R);
-
-                        if (col)
-                          fact.insert_col (x, j-one);
-                        else
-                          fact.insert_row (x.row (0), j(0)-one);
-
-                        retval(1) = get_qr_r (fact);
-                        retval(0) = fact.Q ();
+                    FloatQR fact (Q, R);
 
-                      }
+                    if (col)
+                      fact.insert_col (x, j-one);
                     else
-                      {
-                        Matrix Q = argq.matrix_value ();
-                        Matrix R = argr.matrix_value ();
-                        Matrix x = argx.matrix_value ();
-
-                        QR fact (Q, R);
+                      fact.insert_row (x.row (0), j(0)-one);
 
-                        if (col)
-                          fact.insert_col (x, j-one);
-                        else
-                          fact.insert_row (x.row (0), j(0)-one);
+                    retval(1) = get_qr_r (fact);
+                    retval(0) = fact.Q ();
 
-                        retval(1) = get_qr_r (fact);
-                        retval(0) = fact.Q ();
-
-                      }
                   }
                 else
                   {
-                    // complex case
-                    if (argq.is_single_type ()
-                        || argr.is_single_type ()
-                        || argx.is_single_type ())
-                      {
-                        FloatComplexMatrix Q =
-                          argq.float_complex_matrix_value ();
-                        FloatComplexMatrix R =
-                          argr.float_complex_matrix_value ();
-                        FloatComplexMatrix x =
-                          argx.float_complex_matrix_value ();
+                    Matrix Q = argq.matrix_value ();
+                    Matrix R = argr.matrix_value ();
+                    Matrix x = argx.matrix_value ();
 
-                        FloatComplexQR fact (Q, R);
-
-                        if (col)
-                          fact.insert_col (x, j-one);
-                        else
-                          fact.insert_row (x.row (0), j(0)-one);
+                    QR fact (Q, R);
 
-                        retval(1) = get_qr_r (fact);
-                        retval(0) = fact.Q ();
-                      }
+                    if (col)
+                      fact.insert_col (x, j-one);
                     else
-                      {
-                        ComplexMatrix Q = argq.complex_matrix_value ();
-                        ComplexMatrix R = argr.complex_matrix_value ();
-                        ComplexMatrix x = argx.complex_matrix_value ();
-
-                        ComplexQR fact (Q, R);
+                      fact.insert_row (x.row (0), j(0)-one);
 
-                        if (col)
-                          fact.insert_col (x, j-one);
-                        else
-                          fact.insert_row (x.row (0), j(0)-one);
+                    retval(1) = get_qr_r (fact);
+                    retval(0) = fact.Q ();
 
-                        retval(1) = get_qr_r (fact);
-                        retval(0) = fact.Q ();
-                      }
                   }
-
               }
             else
-              error ("qrinsert: invalid index J");
+              {
+                // complex case
+                if (argq.is_single_type ()
+                    || argr.is_single_type ()
+                    || argx.is_single_type ())
+                  {
+                    FloatComplexMatrix Q =
+                      argq.float_complex_matrix_value ();
+                    FloatComplexMatrix R =
+                      argr.float_complex_matrix_value ();
+                    FloatComplexMatrix x =
+                      argx.float_complex_matrix_value ();
+
+                    FloatComplexQR fact (Q, R);
+
+                    if (col)
+                      fact.insert_col (x, j-one);
+                    else
+                      fact.insert_row (x.row (0), j(0)-one);
+
+                    retval(1) = get_qr_r (fact);
+                    retval(0) = fact.Q ();
+                  }
+                else
+                  {
+                    ComplexMatrix Q = argq.complex_matrix_value ();
+                    ComplexMatrix R = argr.complex_matrix_value ();
+                    ComplexMatrix x = argx.complex_matrix_value ();
+
+                    ComplexQR fact (Q, R);
+
+                    if (col)
+                      fact.insert_col (x, j-one);
+                    else
+                      fact.insert_row (x.row (0), j(0)-one);
+
+                    retval(1) = get_qr_r (fact);
+                    retval(0) = fact.Q ();
+                  }
+              }
+
           }
         else
-          error ("qrinsert: dimension mismatch");
+          error ("qrinsert: invalid index J");
+      }
+    else
+      error ("qrinsert: dimension mismatch");
 
-      else
-        error ("qrinsert: ORIENT must be \"col\" or \"row\"");
-    }
   else
-    print_usage ();
+    error ("qrinsert: ORIENT must be \"col\" or \"row\"");
 
   return retval;
 }
 
 /*
 %!test
 %! [Q,R] = qr (A);
 %! [Q,R] = qrinsert (Q, R, 3, u);
@@ -1162,118 +1158,116 @@ If @var{orient} is @qcode{\"row\"}, full
 
   if (nargin < 3 || nargin > 4)
     print_usage ();
 
   octave_value argq = args(0);
   octave_value argr = args(1);
   octave_value argj = args(2);
 
-  if (argq.is_numeric_type () && argr.is_numeric_type ()
-      && (nargin < 4 || args(3).is_string ()))
-    {
-      std::string orient = (nargin < 4) ? "col" : args(3).string_value ();
+  if (! argq.is_numeric_type () || ! argr.is_numeric_type ()
+      || (nargin > 3 && ! args(3).is_string ()))
+    print_usage ();
+
+  std::string orient = (nargin < 4) ? "col" : args(3).string_value ();
 
-      bool col = orient == "col";
+  bool col = orient == "col";
 
-      if (col || orient == "row")
-        if (check_qr_dims (argq, argr, col))
+  if (col || orient == "row")
+    if (check_qr_dims (argq, argr, col))
+      {
+        if (check_index (argj, col))
           {
-            if (check_index (argj, col))
-              {
-                MArray<octave_idx_type> j
-                  = argj.octave_idx_type_vector_value ();
+            MArray<octave_idx_type> j
+              = argj.octave_idx_type_vector_value ();
+
+            octave_idx_type one = 1;
 
-                octave_idx_type one = 1;
-
-                if (argq.is_real_type ()
-                    && argr.is_real_type ())
+            if (argq.is_real_type ()
+                && argr.is_real_type ())
+              {
+                // real case
+                if (argq.is_single_type ()
+                    || argr.is_single_type ())
                   {
-                    // real case
-                    if (argq.is_single_type ()
-                        || argr.is_single_type ())
-                      {
-                        FloatMatrix Q = argq.float_matrix_value ();
-                        FloatMatrix R = argr.float_matrix_value ();
+                    FloatMatrix Q = argq.float_matrix_value ();
+                    FloatMatrix R = argr.float_matrix_value ();
 
-                        FloatQR fact (Q, R);
-
-                        if (col)
-                          fact.delete_col (j-one);
-                        else
-                          fact.delete_row (j(0)-one);
+                    FloatQR fact (Q, R);
 
-                        retval(1) = get_qr_r (fact);
-                        retval(0) = fact.Q ();
-                      }
+                    if (col)
+                      fact.delete_col (j-one);
                     else
-                      {
-                        Matrix Q = argq.matrix_value ();
-                        Matrix R = argr.matrix_value ();
+                      fact.delete_row (j(0)-one);
 
-                        QR fact (Q, R);
-
-                        if (col)
-                          fact.delete_col (j-one);
-                        else
-                          fact.delete_row (j(0)-one);
-
-                        retval(1) = get_qr_r (fact);
-                        retval(0) = fact.Q ();
-                      }
+                    retval(1) = get_qr_r (fact);
+                    retval(0) = fact.Q ();
                   }
                 else
                   {
-                    // complex case
-                    if (argq.is_single_type ()
-                        || argr.is_single_type ())
-                      {
-                        FloatComplexMatrix Q =
-                          argq.float_complex_matrix_value ();
-                        FloatComplexMatrix R =
-                          argr.float_complex_matrix_value ();
+                    Matrix Q = argq.matrix_value ();
+                    Matrix R = argr.matrix_value ();
 
-                        FloatComplexQR fact (Q, R);
-
-                        if (col)
-                          fact.delete_col (j-one);
-                        else
-                          fact.delete_row (j(0)-one);
+                    QR fact (Q, R);
 
-                        retval(1) = get_qr_r (fact);
-                        retval(0) = fact.Q ();
-                      }
+                    if (col)
+                      fact.delete_col (j-one);
                     else
-                      {
-                        ComplexMatrix Q = argq.complex_matrix_value ();
-                        ComplexMatrix R = argr.complex_matrix_value ();
+                      fact.delete_row (j(0)-one);
 
-                        ComplexQR fact (Q, R);
-
-                        if (col)
-                          fact.delete_col (j-one);
-                        else
-                          fact.delete_row (j(0)-one);
-
-                        retval(1) = get_qr_r (fact);
-                        retval(0) = fact.Q ();
-                      }
+                    retval(1) = get_qr_r (fact);
+                    retval(0) = fact.Q ();
                   }
               }
             else
-              error ("qrdelete: invalid index J");
+              {
+                // complex case
+                if (argq.is_single_type ()
+                    || argr.is_single_type ())
+                  {
+                    FloatComplexMatrix Q =
+                      argq.float_complex_matrix_value ();
+                    FloatComplexMatrix R =
+                      argr.float_complex_matrix_value ();
+
+                    FloatComplexQR fact (Q, R);
+
+                    if (col)
+                      fact.delete_col (j-one);
+                    else
+                      fact.delete_row (j(0)-one);
+
+                    retval(1) = get_qr_r (fact);
+                    retval(0) = fact.Q ();
+                  }
+                else
+                  {
+                    ComplexMatrix Q = argq.complex_matrix_value ();
+                    ComplexMatrix R = argr.complex_matrix_value ();
+
+                    ComplexQR fact (Q, R);
+
+                    if (col)
+                      fact.delete_col (j-one);
+                    else
+                      fact.delete_row (j(0)-one);
+
+                    retval(1) = get_qr_r (fact);
+                    retval(0) = fact.Q ();
+                  }
+              }
           }
         else
-          error ("qrdelete: dimension mismatch");
+          error ("qrdelete: invalid index J");
+      }
+    else
+      error ("qrdelete: dimension mismatch");
 
-      else
-        error ("qrdelete: ORIENT must be \"col\" or \"row\"");
-    }
   else
-    print_usage ();
+    error ("qrdelete: ORIENT must be \"col\" or \"row\"");
 
   return retval;
 }
 
 /*
 %!test
 %! AA = [0.091364  0.613038  0.027504  0.999083;
 %!       0.594638  0.425302  0.562834  0.603537;
@@ -1411,89 +1405,87 @@ of @w{@var{A}(:,p)}, where @w{p} is the 
   if (args.length () != 4)
     print_usage ();
 
   octave_value argq = args(0);
   octave_value argr = args(1);
   octave_value argi = args(2);
   octave_value argj = args(3);
 
-  if (argq.is_numeric_type () && argr.is_numeric_type ())
+  if (! argq.is_numeric_type () || ! argr.is_numeric_type ())
+    print_usage ();
+
+  if (check_qr_dims (argq, argr, true))
     {
-      if (check_qr_dims (argq, argr, true))
+      if (check_index (argi) && check_index (argj))
         {
-          if (check_index (argi) && check_index (argj))
+          octave_idx_type i = argi.int_value ();
+          octave_idx_type j = argj.int_value ();
+
+          if (argq.is_real_type ()
+              && argr.is_real_type ())
             {
-              octave_idx_type i = argi.int_value ();
-              octave_idx_type j = argj.int_value ();
-
-              if (argq.is_real_type ()
-                  && argr.is_real_type ())
+              // all real case
+              if (argq.is_single_type ()
+                  && argr.is_single_type ())
                 {
-                  // all real case
-                  if (argq.is_single_type ()
-                      && argr.is_single_type ())
-                    {
-                      FloatMatrix Q = argq.float_matrix_value ();
-                      FloatMatrix R = argr.float_matrix_value ();
-
-                      FloatQR fact (Q, R);
-                      fact.shift_cols (i-1, j-1);
+                  FloatMatrix Q = argq.float_matrix_value ();
+                  FloatMatrix R = argr.float_matrix_value ();
 
-                      retval(1) = get_qr_r (fact);
-                      retval(0) = fact.Q ();
-                    }
-                  else
-                    {
-                      Matrix Q = argq.matrix_value ();
-                      Matrix R = argr.matrix_value ();
+                  FloatQR fact (Q, R);
+                  fact.shift_cols (i-1, j-1);
 
-                      QR fact (Q, R);
-                      fact.shift_cols (i-1, j-1);
-
-                      retval(1) = get_qr_r (fact);
-                      retval(0) = fact.Q ();
-                    }
+                  retval(1) = get_qr_r (fact);
+                  retval(0) = fact.Q ();
                 }
               else
                 {
-                  // complex case
-                  if (argq.is_single_type ()
-                      && argr.is_single_type ())
-                    {
-                      FloatComplexMatrix Q = argq.float_complex_matrix_value ();
-                      FloatComplexMatrix R = argr.float_complex_matrix_value ();
-
-                      FloatComplexQR fact (Q, R);
-                      fact.shift_cols (i-1, j-1);
+                  Matrix Q = argq.matrix_value ();
+                  Matrix R = argr.matrix_value ();
 
-                      retval(1) = get_qr_r (fact);
-                      retval(0) = fact.Q ();
-                    }
-                  else
-                    {
-                      ComplexMatrix Q = argq.complex_matrix_value ();
-                      ComplexMatrix R = argr.complex_matrix_value ();
+                  QR fact (Q, R);
+                  fact.shift_cols (i-1, j-1);
 
-                      ComplexQR fact (Q, R);
-                      fact.shift_cols (i-1, j-1);
-
-                      retval(1) = get_qr_r (fact);
-                      retval(0) = fact.Q ();
-                    }
+                  retval(1) = get_qr_r (fact);
+                  retval(0) = fact.Q ();
                 }
             }
           else
-            error ("qrshift: invalid index I or J");
+            {
+              // complex case
+              if (argq.is_single_type ()
+                  && argr.is_single_type ())
+                {
+                  FloatComplexMatrix Q = argq.float_complex_matrix_value ();
+                  FloatComplexMatrix R = argr.float_complex_matrix_value ();
+
+                  FloatComplexQR fact (Q, R);
+                  fact.shift_cols (i-1, j-1);
+
+                  retval(1) = get_qr_r (fact);
+                  retval(0) = fact.Q ();
+                }
+              else
+                {
+                  ComplexMatrix Q = argq.complex_matrix_value ();
+                  ComplexMatrix R = argr.complex_matrix_value ();
+
+                  ComplexQR fact (Q, R);
+                  fact.shift_cols (i-1, j-1);
+
+                  retval(1) = get_qr_r (fact);
+                  retval(0) = fact.Q ();
+                }
+            }
         }
       else
-        error ("qrshift: dimensions mismatch");
+        error ("qrshift: invalid index I or J");
     }
   else
-    error ("qrshift: Q and R must be numeric");
+    error ("qrshift: dimensions mismatch");
 
   return retval;
 }
 
 /*
 %!test
 %! AA = A.';
 %! i = 2;  j = 4;  p = [1:i-1, shift(i:j,-1), j+1:5];
