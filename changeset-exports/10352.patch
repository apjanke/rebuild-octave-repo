# HG changeset patch
# User Jaroslav Hajek <highegg@gmail.com>
# Date 1266937947 -3600
#      Tue Feb 23 16:12:27 2010 +0100
# Node ID a3635bc1ea19c34cf6010b2d9fd14660b3d4c456
# Parent  5150ceb4dbb4d10dd019c68f131019745ddd8cac
remove Array2

diff --git a/liboctave/Array-C.cc b/liboctave/Array-C.cc
--- a/liboctave/Array-C.cc
+++ b/liboctave/Array-C.cc
@@ -87,20 +87,16 @@ safe_comparator (sortmode mode, const Ar
 
   return result;
 }
 
 INSTANTIATE_ARRAY_SORT (Complex);
 
 INSTANTIATE_ARRAY (Complex, OCTAVE_API);
 
-#include "Array2.h"
-
-template class OCTAVE_API Array2<Complex>;
-
 template OCTAVE_API std::ostream& operator << (std::ostream&, const Array<Complex>&);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 #ifdef _MSC_VER
 template class OCTAVE_API DiagArray2<Complex>::Proxy;
 #endif
diff --git a/liboctave/Array-b.cc b/liboctave/Array-b.cc
--- a/liboctave/Array-b.cc
+++ b/liboctave/Array-b.cc
@@ -103,18 +103,14 @@ octave_sort<bool>::sort (bool *data, oct
 {
   do_bool_partition<true> (data, idx, nel);
 }
 
 INSTANTIATE_ARRAY_SORT (bool);
 
 INSTANTIATE_ARRAY (bool, OCTAVE_API);
 
-#include "Array2.h"
-
-template class OCTAVE_API Array2<bool>;
-
 template OCTAVE_API std::ostream& operator << (std::ostream&, const Array<bool>&);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 template class OCTAVE_API DiagArray2<bool>;
diff --git a/liboctave/Array-ch.cc b/liboctave/Array-ch.cc
--- a/liboctave/Array-ch.cc
+++ b/liboctave/Array-ch.cc
@@ -30,18 +30,14 @@ along with Octave; see the file COPYING.
 #include "Array.h"
 #include "Array.cc"
 #include "oct-sort.cc"
 
 INSTANTIATE_ARRAY_SORT (char);
 
 INSTANTIATE_ARRAY (char, OCTAVE_API);
 
-#include "Array2.h"
-
-template class OCTAVE_API Array2<char>;
-
 template OCTAVE_API std::ostream& operator << (std::ostream&, const Array<char>&);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 template class OCTAVE_API DiagArray2<char>;
diff --git a/liboctave/Array-d.cc b/liboctave/Array-d.cc
--- a/liboctave/Array-d.cc
+++ b/liboctave/Array-d.cc
@@ -154,20 +154,16 @@ Array<double>::is_sorted (sortmode mode)
 
   return mode;
 }
 
 INSTANTIATE_ARRAY_SORT (double);
 
 INSTANTIATE_ARRAY (double, OCTAVE_API);
 
-#include "Array2.h"
-
-template class OCTAVE_API Array2<double>;
-
 template OCTAVE_API std::ostream& operator << (std::ostream&, const Array<double>&);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 #ifdef _MSC_VER
 template class OCTAVE_API DiagArray2<double>::Proxy;
 #endif
diff --git a/liboctave/Array-f.cc b/liboctave/Array-f.cc
--- a/liboctave/Array-f.cc
+++ b/liboctave/Array-f.cc
@@ -154,20 +154,16 @@ Array<float>::is_sorted (sortmode mode) 
 
   return mode;
 }
 
 INSTANTIATE_ARRAY_SORT (float);
 
 INSTANTIATE_ARRAY (float, OCTAVE_API);
 
-#include "Array2.h"
-
-template class OCTAVE_API Array2<float>;
-
 template OCTAVE_API std::ostream& operator << (std::ostream&, const Array<float>&);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 #ifdef _MSC_VER
 template class OCTAVE_API DiagArray2<float>::Proxy;
 #endif
diff --git a/liboctave/Array-fC.cc b/liboctave/Array-fC.cc
--- a/liboctave/Array-fC.cc
+++ b/liboctave/Array-fC.cc
@@ -88,20 +88,16 @@ safe_comparator (sortmode mode, const Ar
 
   return result;
 }
 
 INSTANTIATE_ARRAY_SORT (FloatComplex);
 
 INSTANTIATE_ARRAY (FloatComplex, OCTAVE_API);
 
-#include "Array2.h"
-
-template class OCTAVE_API Array2<FloatComplex>;
-
 template OCTAVE_API std::ostream& operator << (std::ostream&, const Array<FloatComplex>&);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 #ifdef _MSC_VER
 template class OCTAVE_API DiagArray2<FloatComplex>::Proxy;
 #endif
diff --git a/liboctave/Array-i.cc b/liboctave/Array-i.cc
--- a/liboctave/Array-i.cc
+++ b/liboctave/Array-i.cc
@@ -63,16 +63,12 @@ INSTANTIATE_ARRAY_SORT (octave_uint16);
 INSTANTIATE_ARRAY_SORT (octave_uint32);
 INSTANTIATE_ARRAY_SORT (octave_uint64);
 
 INSTANTIATE_ARRAY (octave_uint8, OCTAVE_API);
 INSTANTIATE_ARRAY (octave_uint16, OCTAVE_API);
 INSTANTIATE_ARRAY (octave_uint32, OCTAVE_API);
 INSTANTIATE_ARRAY (octave_uint64, OCTAVE_API);
 
-#include "Array2.h"
-
-template class OCTAVE_API Array2<int>;
-
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 template class OCTAVE_API DiagArray2<int>;
diff --git a/liboctave/Array-s.cc b/liboctave/Array-s.cc
--- a/liboctave/Array-s.cc
+++ b/liboctave/Array-s.cc
@@ -33,16 +33,12 @@ along with Octave; see the file COPYING.
 #define INLINE_ASCENDING_SORT
 #define INLINE_DESCENDING_SORT
 #include "oct-sort.cc"
 
 INSTANTIATE_ARRAY_SORT (short);
 
 INSTANTIATE_ARRAY (short, OCTAVE_API);
 
-#include "Array2.h"
-
-template class Array2<short>;
-
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 template class DiagArray2<short>;
diff --git a/liboctave/Array-voidp.cc b/liboctave/Array-voidp.cc
--- a/liboctave/Array-voidp.cc
+++ b/liboctave/Array-voidp.cc
@@ -30,15 +30,11 @@ along with Octave; see the file COPYING.
 
 #include "Array.h"
 #include "Array.cc"
 
 NO_INSTANTIATE_ARRAY_SORT (void *);
 
 INSTANTIATE_ARRAY (void *, OCTAVE_API);
 
-#include "Array2.h"
-
-template class OCTAVE_API Array2<void *>;
-
 #include "Array3.h"
 
 template class OCTAVE_API Array3<void *>;
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -46,20 +46,41 @@ along with Octave; see the file COPYING.
 // One dimensional array class.  Handles the reference counting for
 // all the derived classes.
 
 template <class T>
 Array<T>::Array (const Array<T>& a, const dim_vector& dv)
   : rep (a.rep), dimensions (dv), 
     slice_data (a.slice_data), slice_len (a.slice_len)
 {
-  if (dv.numel () != a.numel ())
+  if (dimensions.safe_numel () != a.numel ())
     {
-      std::string dimensions_str = dimensions.str ();
-      std::string new_dims_str = dv.str ();
+      std::string dimensions_str = a.dimensions.str ();
+      std::string new_dims_str = dimensions.str ();
+
+      (*current_liboctave_error_handler)
+        ("reshape: can't reshape %s array to %s array",
+         dimensions_str.c_str (), new_dims_str.c_str ());
+    }
+
+  // This goes here because if an exception is thrown by the above,
+  // destructor will be never called.
+  rep->count++;
+  dimensions.chop_trailing_singletons ();
+}
+
+template <class T>
+Array<T>::Array (const Array<T>& a, octave_idx_type nr, octave_idx_type nc)
+  : rep (a.rep), dimensions (nr, nc), 
+    slice_data (a.slice_data), slice_len (a.slice_len)
+{
+  if (dimensions.safe_numel () != a.numel ())
+    {
+      std::string dimensions_str = a.dimensions.str ();
+      std::string new_dims_str = dimensions.str ();
 
       (*current_liboctave_error_handler)
         ("reshape: can't reshape %s array to %s array",
          dimensions_str.c_str (), new_dims_str.c_str ());
     }
 
   // This goes here because if an exception is thrown by the above,
   // destructor will be never called.
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -239,16 +239,18 @@ public:
       slice_len = rep->len;
       fill (val);
       dimensions.chop_trailing_singletons ();
     }
 
   // Reshape constructor.
   Array (const Array<T>& a, const dim_vector& dv);
 
+  Array (const Array<T>& a, octave_idx_type nr, octave_idx_type nc);
+
   // Type conversion case.
   template <class U>
   Array (const Array<U>& a)
     : rep (new typename Array<T>::ArrayRep (coerce (a.data (), a.length ()), a.length ())),
       dimensions (a.dims ())
     {
       slice_data = rep->data;
       slice_len = rep->len;
@@ -508,16 +510,19 @@ public:
 
   // Give this array as a column vector: A(:).
   Array<T> linearize (void) const;
 
   // Extract a slice from this array as a column vector: A(:)(lo+1:up).
   // Must be 0 <= lo && up <= numel. May be up < lo.
   Array<T> linear_slice (octave_idx_type lo, octave_idx_type up) const;
 
+  Array<T> reshape (octave_idx_type nr, octave_idx_type nc) const
+    { return Array<T> (*this, nr, nc); }
+
   Array<T> reshape (const dim_vector& new_dims) const
     { return Array<T> (*this, new_dims); }
 
   Array<T> permute (const Array<octave_idx_type>& vec, bool inv = false) const;
   Array<T> ipermute (const Array<octave_idx_type>& vec) const
     { return permute (vec, true); }
 
   bool is_square (void) const { return (dim1 () == dim2 ()); }
diff --git a/liboctave/Array2.h b/liboctave/Array2.h
--- a/liboctave/Array2.h
+++ b/liboctave/Array2.h
@@ -20,142 +20,17 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_Array2_h)
 #define octave_Array2_h 1
 
-#include <cassert>
-#include <climits>
-#include <cstdlib>
-
 #include "Array.h"
-#include "lo-error.h"
-#include "lo-math.h"
-
-class idx_vector;
-
-// Two dimensional array class.
-
-template <class T>
-class
-Array2 : public Array<T>
-{
-protected:
-
-  Array2 (T *d, octave_idx_type r, octave_idx_type c) : Array<T> (d, dim_vector (r, c)) { }
-
-public:
-
-  Array2 (void) : Array<T> (dim_vector (0, 0)) { }
-
-  Array2 (octave_idx_type r, octave_idx_type c) : Array<T> (dim_vector (r, c)) { }
-
-  Array2 (octave_idx_type r, octave_idx_type c, const T& val)
-    : Array<T> (dim_vector (r, c), val) { }
-
-  Array2 (const dim_vector& dv) : Array<T> (dv) 
-    { 
-      if (dv.length () != 2)
-        (*current_liboctave_error_handler) ("too many dimensions");
-    }
-
-  Array2 (const dim_vector& dv, const T& val) : Array<T> (dv) 
-    { 
-      if (dv.length () != 2)
-        (*current_liboctave_error_handler) ("too many dimensions");
-      else
-        Array<T>::fill (val); 
-    }
-
-  Array2 (const Array2<T>& a) : Array<T> (a, a.dims ()) { }
-
-  Array2 (const Array<T>& a, octave_idx_type r, octave_idx_type c)
-    : Array<T> (a, dim_vector (r, c)) { }
-
-  template <class U>
-  Array2 (const Array<U>& a) : Array<T> (a) { }
-
-  template <class U>
-  Array2 (const Array<U>& a, const dim_vector& dv)
-    : Array<T> (a, dv) { }
-
-  ~Array2 (void) { }
-
-  Array2<T>& operator = (const Array2<T>& a)
-    {
-      if (this != &a)
-        Array<T>::operator = (a);
-
-      return *this;
-    }
+#define Array2 Array
 
-  void resize (octave_idx_type r, octave_idx_type c)
-    { Array<T>::resize (r, c, Array<T>::resize_fill_value ()); }
-
-  void resize (octave_idx_type r, octave_idx_type c, const T& val)
-    { Array<T>::resize (r, c, val); }
-
-  Array2<T>& insert (const Array2<T>& a, octave_idx_type r, octave_idx_type c)
-    {
-      Array<T>::insert (a, r, c);
-      return *this;
-    }
-
-  Array2<T> transpose (void) const
-    {
-      Array<T> tmp = Array<T>::transpose ();
-      return Array2<T> (tmp, tmp.rows (), tmp.columns ());
-    }
-
-  Array2<T> hermitian (T (*fcn) (const T&) = 0) const
-    {
-      Array<T> tmp = Array<T>::hermitian (fcn);
-      return Array2<T> (tmp, tmp.rows (), tmp.columns ());
-    }
-
-  Array2<T> index (const idx_vector& i, bool resize_ok = false,
-                   const T& rfv = Array<T>::resize_fill_value ()) const
-    {
-      Array<T> tmp = Array<T>::index (i, resize_ok, rfv);
-      return Array2<T> (tmp, tmp.rows (), tmp.columns ());
-    }
-
-  Array2<T> index (const idx_vector& i, const idx_vector& j, bool resize_ok = false,
-                   const T& rfv = Array<T>::resize_fill_value ()) const
-    {
-      Array<T> tmp = Array<T>::index (i, j, resize_ok, rfv);
-      return Array2<T> (tmp, tmp.rows (), tmp.columns ());
-    }
-
-  Array2<T> sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
-    {
-      Array<T> tmp = Array<T>::sort (dim, mode);
-      return Array2<T> (tmp, tmp.rows (), tmp.columns ());
-    }
-
-  Array2<T> sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
-                 sortmode mode = ASCENDING) const
-    {
-      Array<T> tmp = Array<T>::sort (sidx, dim, mode);
-      return Array2<T> (tmp, tmp.rows (), tmp.columns ());
-    }
-
-  Array2<T> diag (octave_idx_type k) const
-  {
-    return Array<T>::diag (k);
-  }
-
-  // FIXME: should go away.
-  template <class U>
-  Array2<U>
-  map (U (&fcn) (T)) const
-  { return Array<T>::template map<U> (fcn); }
-
-  template <class U>
-  Array2<U>
-  map (U (&fcn) (const T&)) const
-  { return Array<T>::template map<U> (fcn); }
-};
+// If we're with GNU C++, issue a warning.
+#ifdef __GNUC__
+#warning Using Array2<T> is deprecated. Use Array<T> directly.
+#endif
 
 #endif
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -2389,17 +2389,18 @@ ComplexMatrix::solve (MatrixType &typ, c
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b,
                       octave_idx_type& info, double& rcon,
                       solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
 
   ComplexMatrix tmp (b);
-  return solve (typ, tmp, info, rcon, sing_handler, transt).column(static_cast<octave_idx_type> (0));
+  tmp = solve (typ, tmp, info, rcon, sing_handler, true, transt);
+  return tmp.column(static_cast<octave_idx_type> (0));
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const Matrix& b) const
 {
   octave_idx_type info;
   double rcon;
   return solve (b, info, rcon, 0);
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -19,17 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_ComplexMatrix_h)
 #define octave_ComplexMatrix_h 1
 
-#include "Array2.h"
 #include "MArray.h"
 #include "MDiagArray2.h"
 #include "MatrixType.h"
 
 #include "mx-defs.h"
 #include "mx-op-decl.h"
 #include "oct-cmplx.h"
 #include "DET.h"
@@ -58,19 +57,16 @@ public:
     : MArray<Complex> (dv.redim (2), val) { }
 
   ComplexMatrix (const ComplexMatrix& a) : MArray<Complex> (a) { }
 
   template <class U>
   ComplexMatrix (const MArray<U>& a) : MArray<Complex> (a.as_matrix ()) { }
 
   template <class U>
-  ComplexMatrix (const Array2<U>& a) : MArray<Complex> (a) { }
-
-  template <class U>
   ComplexMatrix (const Array<U>& a) : MArray<Complex> (a.as_matrix ()) { }
 
   ComplexMatrix (const Matrix& re, const Matrix& im);
 
   explicit ComplexMatrix (const Matrix& a);
 
   explicit ComplexMatrix (const RowVector& rv);
 
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -842,17 +842,17 @@ ComplexNDArray::insert (const ComplexNDA
 }
 
 ComplexMatrix
 ComplexNDArray::matrix_value (void) const
 {
   ComplexMatrix retval;
 
   if (ndims () == 2)
-      retval = ComplexMatrix (Array2<Complex> (*this));
+      retval = ComplexMatrix (Array<Complex> (*this));
   else
     (*current_liboctave_error_handler)
       ("invalid conversion of ComplexNDArray to ComplexMatrix");
 
   return retval;
 }
 
 void
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,50 @@
+2010-02-24  Jaroslav Hajek  <highegg@gmail.com>
+
+	* Array.cc (Array::Array (const Array&, octave_idx_type,
+	octave_idx_type): New ctor.
+	(Array::reshape (octave_idx_type, octave_idx_type): New method.
+	* Array.h: Declare them.
+	* Array2.h: Deprecate Array2, make it a #define for Array.
+
+	* Array-C.cc: Remove Array2 instantiation.
+	* Array-b.cc: Ditto.
+	* Array-ch.cc: Ditto.
+	* Array-d.cc: Ditto.
+	* Array-f.cc: Ditto.
+	* Array-fC.cc: Ditto.
+	* Array-i.cc: Ditto.
+	* Array-s.cc: Ditto.
+	* Array-voidp.cc: Ditto.
+
+	* CMatrix.cc: Use Array instead of Array2 everywhere.
+	* CMatrix.h: Ditto.
+	* CNDArray.cc: Ditto.
+	* DiagArray2.cc: Ditto.
+	* DiagArray2.h: Ditto.
+	* MDiagArray2.h: Ditto.
+	* Sparse.cc: Ditto.
+	* Sparse.h: Ditto.
+	* boolMatrix.h: Ditto.
+	* boolNDArray.cc: Ditto.
+	* chMatrix.h: Ditto.
+	* chNDArray.cc: Ditto.
+	* dMatrix.cc: Ditto.
+	* dMatrix.h: Ditto.
+	* dNDArray.cc: Ditto.
+	* fCMatrix.cc: Ditto.
+	* fCMatrix.h: Ditto.
+	* fCNDArray.cc: Ditto.
+	* fMatrix.cc: Ditto.
+	* fMatrix.h: Ditto.
+	* fNDArray.cc: Ditto.
+	* lo-specfun.cc: Ditto.
+	* lo-specfun.h: Ditto.
+
 2010-02-23  Jaroslav Hajek  <highegg@gmail.com>
 
 	* chMatrix.h (charMatrix): Base on Array<char>.
 	* chMatrix.cc (charMatrix): Update.
 	* boolMatrix.h (boolMatrix): Ditto.
 	* boolMatrix.h (boolMatrix): Update.
 
 2010-02-23  Jaroslav Hajek  <highegg@gmail.com>
diff --git a/liboctave/DiagArray2.cc b/liboctave/DiagArray2.cc
--- a/liboctave/DiagArray2.cc
+++ b/liboctave/DiagArray2.cc
@@ -147,16 +147,16 @@ DiagArray2<T>::resize (octave_idx_type r
   if (r != dim1 () || c != dim2 ())
     {
       Array<T>::resize (std::min (r, c), 1, rfv);
       d1 = r; d2 = c;
     }
 }
 
 template <class T>
-DiagArray2<T>::operator Array2<T> (void) const
+DiagArray2<T>::operator Array<T> (void) const
 {
-  Array2<T> result (dim1 (), dim2 ());
+  Array<T> result (dim1 (), dim2 ());
   for (octave_idx_type i = 0, len = length (); i < len; i++)
     result.xelem (i, i) = dgelem (i);
 
   return result;
 }
diff --git a/liboctave/DiagArray2.h b/liboctave/DiagArray2.h
--- a/liboctave/DiagArray2.h
+++ b/liboctave/DiagArray2.h
@@ -25,17 +25,16 @@ along with Octave; see the file COPYING.
 
 #if !defined (octave_DiagArray2_h)
 #define octave_DiagArray2_h 1
 
 #include <cassert>
 #include <cstdlib>
 
 #include "Array.h"
-#include "Array2.h"
 #include "lo-error.h"
 
 // A two-dimensional array with diagonal elements only.
 // Idea and example code for Proxy class and functions from:
 //
 // From: kanze@us-es.sel.de (James Kanze)
 // Subject: Re: How to overload [] to do READ/WRITE differently ?
 // Message-ID: <KANZE.93Nov29151407@slsvhdt.us-es.sel.de>
@@ -214,17 +213,17 @@ public:
     { return Array<T>::xelem (i); }
 
   void resize (octave_idx_type n, octave_idx_type m, 
                const T& rfv = Array<T>::resize_fill_value ());
 
   DiagArray2<T> transpose (void) const;
   DiagArray2<T> hermitian (T (*fcn) (const T&) = 0) const;
 
-  operator Array2<T> (void) const;
+  operator Array<T> (void) const;
 
   const T *data (void) const { return Array<T>::data (); }
 
   const T *fortran_vec (void) const { return Array<T>::fortran_vec (); }
 
   T *fortran_vec (void) { return Array<T>::fortran_vec (); }
 
   void print_info (std::ostream& os, const std::string& prefix) const
diff --git a/liboctave/MDiagArray2.h b/liboctave/MDiagArray2.h
--- a/liboctave/MDiagArray2.h
+++ b/liboctave/MDiagArray2.h
@@ -68,17 +68,17 @@ public:
   MDiagArray2<T>& operator = (const MDiagArray2<T>& a)
     {
       DiagArray2<T>::operator = (a);
       return *this;
     }
 
   operator MArray<T> () const
     {
-      return DiagArray2<T>::operator Array2<T> ();
+      return DiagArray2<T>::operator Array<T> ();
     }
 
   octave_idx_type nnz (void) const
     {
       octave_idx_type retval = 0;
 
       const T *d = this->data ();
 
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -544,46 +544,16 @@ Sparse<T>::Sparse (const Array<T>& a, co
 
           while (cx < nc) 
             xcidx (++cx) = ii + 1;
         }
     }
 }
 
 template <class T>
-Sparse<T>::Sparse (const Array2<T>& a)
-  : dimensions (a.dims ()), idx (0), idx_count (0)
-{
-  octave_idx_type nr = rows ();
-  octave_idx_type nc = cols ();
-  octave_idx_type len = a.length ();
-  octave_idx_type new_nzmx = 0;
-
-  // First count the number of non-zero terms
-  for (octave_idx_type i = 0; i < len; i++)
-    if (a(i) != T ())
-      new_nzmx++;
-
-  rep = new typename Sparse<T>::SparseRep (nr, nc, new_nzmx);
-
-  octave_idx_type ii = 0;
-  xcidx(0) = 0;
-  for (octave_idx_type j = 0; j < nc; j++)
-    {
-      for (octave_idx_type i = 0; i < nr; i++)
-        if (a.elem (i,j) != T ())
-          {
-            xdata(ii) = a.elem (i,j);
-            xridx(ii++) = i;
-          }
-      xcidx(j+1) = ii;
-    }
-}
-
-template <class T>
 Sparse<T>::Sparse (const Array<T>& a)
   : dimensions (a.dims ()), idx (0), idx_count (0)
 {
   if (dimensions.length () > 2)
     (*current_liboctave_error_handler)
       ("Sparse::Sparse (const Array<T>&): dimension mismatch");
   else
     {
diff --git a/liboctave/Sparse.h b/liboctave/Sparse.h
--- a/liboctave/Sparse.h
+++ b/liboctave/Sparse.h
@@ -26,17 +26,16 @@ along with Octave; see the file COPYING.
 #define octave_Sparse_h 1
 
 #include <cassert>
 #include <cstddef>
 
 #include <iosfwd>
 
 #include "Array.h"
-#include "Array2.h"
 #include "dim-vector.h"
 #include "lo-error.h"
 #include "lo-utils.h"
 
 #include "oct-sort.h"
 
 class idx_vector;
 
@@ -219,17 +218,16 @@ public:
 
   Sparse (const Array<T>& a, const Array<octave_idx_type>& r, const Array<octave_idx_type>& c,
           octave_idx_type nr, octave_idx_type nc, bool sum_terms);
 
   Sparse (const Array<T>& a, const Array<double>& r, const Array<double>& c,
           octave_idx_type nr, octave_idx_type nc, bool sum_terms);
 
   // Sparsify a normal matrix
-  Sparse (const Array2<T>& a);
   Sparse (const Array<T>& a);
 
   virtual ~Sparse (void);
 
   Sparse<T>& operator = (const Sparse<T>& a);
 
   // Note that nzmax and capacity are the amount of storage for
   // non-zero elements, while nnz is the actual number of non-zero
diff --git a/liboctave/boolMatrix.h b/liboctave/boolMatrix.h
--- a/liboctave/boolMatrix.h
+++ b/liboctave/boolMatrix.h
@@ -35,17 +35,17 @@ boolMatrix : public Array<bool>
 {
 public:
 
   boolMatrix (void) : Array<bool> () { }
   boolMatrix (octave_idx_type r, octave_idx_type c) : Array<bool> (r, c) { }
   boolMatrix (octave_idx_type r, octave_idx_type c, bool val) : Array<bool> (r, c, val) { }
   boolMatrix (const dim_vector& dv) : Array<bool> (dv) { }
   boolMatrix (const dim_vector& dv, bool val) : Array<bool> (dv, val) { }
-  boolMatrix (const Array<bool>& a) : Array<bool> (a) { }
+  boolMatrix (const Array<bool>& a) : Array<bool> (a.as_matrix ()) { }
   boolMatrix (const boolMatrix& a) : Array<bool> (a) { }
 
   boolMatrix& operator = (const boolMatrix& a)
     {
       Array<bool>::operator = (a);
       return *this;
     }
 
diff --git a/liboctave/boolNDArray.cc b/liboctave/boolNDArray.cc
--- a/liboctave/boolNDArray.cc
+++ b/liboctave/boolNDArray.cc
@@ -106,38 +106,17 @@ boolNDArray::insert (const boolNDArray& 
   return *this;
 }
 
 
 
 boolMatrix
 boolNDArray::matrix_value (void) const
 {
-  boolMatrix retval;
-
-  int nd = ndims ();
-
-  switch (nd)
-    {
-    case 1:
-      retval = boolMatrix (Array2<bool> (*this, dimensions(0), 1));
-      break;
-
-    case 2:
-      retval = boolMatrix (Array2<bool> (*this, dimensions(0),
-                                         dimensions(1)));
-      break;
-
-    default:
-      (*current_liboctave_error_handler)
-        ("invalid conversion of boolNDArray to boolMatrix");
-      break;
-    }
-
-  return retval;
+  return *this;
 }
 
 void
 boolNDArray::increment_index (Array<octave_idx_type>& ra_idx,
                               const dim_vector& dimensions,
                               int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
diff --git a/liboctave/chMatrix.h b/liboctave/chMatrix.h
--- a/liboctave/chMatrix.h
+++ b/liboctave/chMatrix.h
@@ -40,17 +40,17 @@ friend class ComplexMatrix;
 
 public:
 
   charMatrix (void) : Array<char> () { }
   charMatrix (octave_idx_type r, octave_idx_type c) : Array<char> (r, c) { }
   charMatrix (octave_idx_type r, octave_idx_type c, char val) : Array<char> (r, c, val) { }
   charMatrix (const dim_vector& dv) : Array<char> (dv) { }
   charMatrix (const dim_vector& dv, char val) : Array<char> (dv, val) { }
-  charMatrix (const Array<char>& a) : Array<char> (a) { }
+  charMatrix (const Array<char>& a) : Array<char> (a.as_matrix ()) { }
   charMatrix (const charMatrix& a) : Array<char> (a) { }
   charMatrix (char c);
   charMatrix (const char *s);
   charMatrix (const std::string& s);
   charMatrix (const string_vector& s);
 
   charMatrix& operator = (const charMatrix& a)
     {
diff --git a/liboctave/chNDArray.cc b/liboctave/chNDArray.cc
--- a/liboctave/chNDArray.cc
+++ b/liboctave/chNDArray.cc
@@ -104,38 +104,17 @@ charNDArray::insert (const charNDArray& 
 {
   Array<char>::insert (a, ra_idx);
   return *this;
 }
 
 charMatrix
 charNDArray::matrix_value (void) const
 {
-  charMatrix retval;
-
-  int nd = ndims ();
-
-  switch (nd)
-    {
-    case 1:
-      retval = charMatrix (Array2<char> (*this, dimensions(0), 1));
-      break;
-
-    case 2:
-      retval = charMatrix (Array2<char> (*this, dimensions(0),
-                                               dimensions(1)));
-      break;
-
-    default:
-      (*current_liboctave_error_handler)
-        ("invalid conversion of charNDArray to charMatrix");
-      break;
-    }
-
-  return retval;
+  return *this;
 }
 
 void
 charNDArray::increment_index (Array<octave_idx_type>& ra_idx,
                               const dim_vector& dimensions,
                               int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -2045,17 +2045,18 @@ Matrix::solve (MatrixType &typ, const Co
   return solve (typ, b, info, rcon, 0);
 }
 
 ColumnVector
 Matrix::solve (MatrixType &typ, const ColumnVector& b, octave_idx_type& info,
                double& rcon, solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   Matrix tmp (b);
-  return solve (typ, tmp, info, rcon, sing_handler, transt).column(static_cast<octave_idx_type> (0));
+  tmp = solve (typ, tmp, info, rcon, sing_handler, true, transt);
+  return tmp.column(static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
 Matrix::solve (MatrixType &typ, const ComplexColumnVector& b) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (typ, b);
 }
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -20,17 +20,16 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_Matrix_int_h)
 #define octave_Matrix_int_h 1
 
 #include "MArray.h"
-#include "Array2.h"
 #include "MDiagArray2.h"
 #include "MatrixType.h"
 
 #include "mx-defs.h"
 #include "mx-op-decl.h"
 #include "DET.h"
 
 class
@@ -55,19 +54,16 @@ public:
   Matrix (const dim_vector& dv, double val) : MArray<double> (dv.redim (2), val) { }
 
   Matrix (const Matrix& a) : MArray<double> (a) { }
 
   template <class U>
   Matrix (const MArray<U>& a) : MArray<double> (a.as_matrix ()) { }
 
   template <class U>
-  Matrix (const Array2<U>& a) : MArray<double> (a) { }
-
-  template <class U>
   Matrix (const Array<U>& a) : MArray<double> (a.as_matrix ()) { }
 
   explicit Matrix (const RowVector& rv);
 
   explicit Matrix (const ColumnVector& cv);
 
   explicit Matrix (const DiagMatrix& a);
 
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -909,17 +909,17 @@ NDArray::isfinite (void) const
 }
 
 Matrix
 NDArray::matrix_value (void) const
 {
   Matrix retval;
 
   if (ndims () == 2)
-      retval = Matrix (Array2<double> (*this));
+      retval = Matrix (Array<double> (*this));
   else
     (*current_liboctave_error_handler)
       ("invalid conversion of NDArray to Matrix");
 
   return retval;
 }
 
 void
diff --git a/liboctave/fCMatrix.cc b/liboctave/fCMatrix.cc
--- a/liboctave/fCMatrix.cc
+++ b/liboctave/fCMatrix.cc
@@ -2382,17 +2382,18 @@ FloatComplexMatrix::solve (MatrixType &t
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
                       octave_idx_type& info, float& rcon,
                       solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
 
   FloatComplexMatrix tmp (b);
-  return solve (typ, tmp, info, rcon, sing_handler, transt).column(static_cast<octave_idx_type> (0));
+  tmp = solve (typ, tmp, info, rcon, sing_handler, true, transt);
+  return tmp.column(static_cast<octave_idx_type> (0));
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (b, info, rcon, 0);
diff --git a/liboctave/fCMatrix.h b/liboctave/fCMatrix.h
--- a/liboctave/fCMatrix.h
+++ b/liboctave/fCMatrix.h
@@ -57,19 +57,16 @@ public:
     : MArray<FloatComplex> (dv.redim (2), val) { }
 
   FloatComplexMatrix (const FloatComplexMatrix& a) : MArray<FloatComplex> (a) { }
 
   template <class U>
   FloatComplexMatrix (const MArray<U>& a) : MArray<FloatComplex> (a.as_matrix ()) { }
 
   template <class U>
-  FloatComplexMatrix (const Array2<U>& a) : MArray<FloatComplex> (a) { }
-
-  template <class U>
   FloatComplexMatrix (const Array<U>& a) : MArray<FloatComplex> (a.as_matrix ()) { }
 
   explicit FloatComplexMatrix (const FloatMatrix& a);
 
   explicit FloatComplexMatrix (const FloatRowVector& rv);
 
   explicit FloatComplexMatrix (const FloatColumnVector& cv);
 
diff --git a/liboctave/fCNDArray.cc b/liboctave/fCNDArray.cc
--- a/liboctave/fCNDArray.cc
+++ b/liboctave/fCNDArray.cc
@@ -837,17 +837,17 @@ FloatComplexNDArray::insert (const Float
 }
 
 FloatComplexMatrix
 FloatComplexNDArray::matrix_value (void) const
 {
   FloatComplexMatrix retval;
 
   if (ndims () == 2)
-      retval = FloatComplexMatrix (Array2<FloatComplex> (*this));
+      retval = FloatComplexMatrix (Array<FloatComplex> (*this));
   else
     (*current_liboctave_error_handler)
       ("invalid conversion of FloatComplexNDArray to FloatComplexMatrix");
 
   return retval;
 }
 
 void
diff --git a/liboctave/fMatrix.cc b/liboctave/fMatrix.cc
--- a/liboctave/fMatrix.cc
+++ b/liboctave/fMatrix.cc
@@ -2044,17 +2044,18 @@ FloatMatrix::solve (MatrixType &typ, con
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b, octave_idx_type& info,
                float& rcon, solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   FloatMatrix tmp (b);
-  return solve (typ, tmp, info, rcon, sing_handler, transt).column(static_cast<octave_idx_type> (0));
+  tmp = solve (typ, tmp, info, rcon, sing_handler, true, transt);
+  return tmp.column(static_cast<octave_idx_type> (0));
 }
 
 FloatComplexColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (typ, b);
 }
diff --git a/liboctave/fMatrix.h b/liboctave/fMatrix.h
--- a/liboctave/fMatrix.h
+++ b/liboctave/fMatrix.h
@@ -19,17 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_FloatMatrix_int_h)
 #define octave_FloatMatrix_int_h 1
 
-#include "Array2.h"
 #include "MArray.h"
 #include "MDiagArray2.h"
 #include "MatrixType.h"
 
 #include "mx-defs.h"
 #include "mx-op-decl.h"
 #include "DET.h"
 
@@ -55,19 +54,16 @@ public:
   FloatMatrix (const dim_vector& dv, float val) : MArray<float> (dv.redim (2), val) { }
 
   FloatMatrix (const FloatMatrix& a) : MArray<float> (a) { }
 
   template <class U>
   FloatMatrix (const MArray<U>& a) : MArray<float> (a.as_matrix ()) { }
 
   template <class U>
-  FloatMatrix (const Array2<U>& a) : MArray<float> (a) { }
-
-  template <class U>
   FloatMatrix (const Array<U>& a) : MArray<float> (a.as_matrix ()) { }
 
   explicit FloatMatrix (const FloatRowVector& rv);
 
   explicit FloatMatrix (const FloatColumnVector& cv);
 
   explicit FloatMatrix (const FloatDiagMatrix& a);
 
diff --git a/liboctave/fNDArray.cc b/liboctave/fNDArray.cc
--- a/liboctave/fNDArray.cc
+++ b/liboctave/fNDArray.cc
@@ -867,17 +867,17 @@ FloatNDArray::isfinite (void) const
 }
 
 FloatMatrix
 FloatNDArray::matrix_value (void) const
 {
   FloatMatrix retval;
 
   if (ndims () == 2)
-      retval = FloatMatrix (Array2<float> (*this));
+      retval = FloatMatrix (Array<float> (*this));
   else
     (*current_liboctave_error_handler)
       ("invalid conversion of FloatNDArray to FloatMatrix");
 
   return retval;
 }
 
 void
diff --git a/liboctave/lo-specfun.cc b/liboctave/lo-specfun.cc
--- a/liboctave/lo-specfun.cc
+++ b/liboctave/lo-specfun.cc
@@ -994,17 +994,17 @@ do_bessel (dptr f, const char *, double 
 
   retval = f (x, alpha, (scaled ? 2 : 1), ierr);
 
   return retval;
 }
 
 static inline ComplexMatrix
 do_bessel (dptr f, const char *, double alpha, const ComplexMatrix& x,
-           bool scaled, Array2<octave_idx_type>& ierr)
+           bool scaled, Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = x.rows ();
   octave_idx_type nc = x.cols ();
 
   ComplexMatrix retval (nr, nc);
 
   ierr.resize (nr, nc);
 
@@ -1012,17 +1012,17 @@ do_bessel (dptr f, const char *, double 
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = f (x(i,j), alpha, (scaled ? 2 : 1), ierr(i,j));
 
   return retval;
 }
 
 static inline ComplexMatrix
 do_bessel (dptr f, const char *, const Matrix& alpha, const Complex& x,
-           bool scaled, Array2<octave_idx_type>& ierr)
+           bool scaled, Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = alpha.rows ();
   octave_idx_type nc = alpha.cols ();
 
   ComplexMatrix retval (nr, nc);
 
   ierr.resize (nr, nc);
 
@@ -1030,17 +1030,17 @@ do_bessel (dptr f, const char *, const M
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = f (x, alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
 
   return retval;
 }
 
 static inline ComplexMatrix
 do_bessel (dptr f, const char *fn, const Matrix& alpha,
-           const ComplexMatrix& x, bool scaled, Array2<octave_idx_type>& ierr)
+           const ComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr)
 {
   ComplexMatrix retval;
 
   octave_idx_type x_nr = x.rows ();
   octave_idx_type x_nc = x.cols ();
 
   octave_idx_type alpha_nr = alpha.rows ();
   octave_idx_type alpha_nc = alpha.cols ();
@@ -1118,17 +1118,17 @@ do_bessel (dptr f, const char *fn, const
     (*current_liboctave_error_handler)
       ("%s: the sizes of alpha and x must conform", fn);
 
   return retval;
 }
 
 static inline ComplexMatrix
 do_bessel (dptr f, const char *, const RowVector& alpha,
-           const ComplexColumnVector& x, bool scaled, Array2<octave_idx_type>& ierr)
+           const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = x.length ();
   octave_idx_type nc = alpha.length ();
 
   ComplexMatrix retval (nr, nc);
 
   ierr.resize (nr, nc);
 
@@ -1144,33 +1144,33 @@ do_bessel (dptr f, const char *, const R
   name (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define SM_BESSEL(name, fcn) \
   ComplexMatrix \
   name (double alpha, const ComplexMatrix& x, bool scaled, \
-        Array2<octave_idx_type>& ierr) \
+        Array<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define MS_BESSEL(name, fcn) \
   ComplexMatrix \
   name (const Matrix& alpha, const Complex& x, bool scaled, \
-        Array2<octave_idx_type>& ierr) \
+        Array<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define MM_BESSEL(name, fcn) \
   ComplexMatrix \
   name (const Matrix& alpha, const ComplexMatrix& x, bool scaled, \
-        Array2<octave_idx_type>& ierr) \
+        Array<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define SN_BESSEL(name, fcn) \
   ComplexNDArray \
   name (double alpha, const ComplexNDArray& x, bool scaled, \
         Array<octave_idx_type>& ierr) \
@@ -1192,17 +1192,17 @@ do_bessel (dptr f, const char *, const R
         Array<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define RC_BESSEL(name, fcn) \
   ComplexMatrix \
   name (const RowVector& alpha, const ComplexColumnVector& x, bool scaled, \
-        Array2<octave_idx_type>& ierr) \
+        Array<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define ALL_BESSEL(name, fcn) \
   SS_BESSEL (name, fcn) \
   SM_BESSEL (name, fcn) \
   MS_BESSEL (name, fcn) \
@@ -1591,17 +1591,17 @@ do_bessel (fptr f, const char *, float a
 
   retval = f (x, alpha, (scaled ? 2 : 1), ierr);
 
   return retval;
 }
 
 static inline FloatComplexMatrix
 do_bessel (fptr f, const char *, float alpha, const FloatComplexMatrix& x,
-           bool scaled, Array2<octave_idx_type>& ierr)
+           bool scaled, Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = x.rows ();
   octave_idx_type nc = x.cols ();
 
   FloatComplexMatrix retval (nr, nc);
 
   ierr.resize (nr, nc);
 
@@ -1609,17 +1609,17 @@ do_bessel (fptr f, const char *, float a
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = f (x(i,j), alpha, (scaled ? 2 : 1), ierr(i,j));
 
   return retval;
 }
 
 static inline FloatComplexMatrix
 do_bessel (fptr f, const char *, const FloatMatrix& alpha, const FloatComplex& x,
-           bool scaled, Array2<octave_idx_type>& ierr)
+           bool scaled, Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = alpha.rows ();
   octave_idx_type nc = alpha.cols ();
 
   FloatComplexMatrix retval (nr, nc);
 
   ierr.resize (nr, nc);
 
@@ -1627,17 +1627,17 @@ do_bessel (fptr f, const char *, const F
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = f (x, alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
 
   return retval;
 }
 
 static inline FloatComplexMatrix
 do_bessel (fptr f, const char *fn, const FloatMatrix& alpha,
-           const FloatComplexMatrix& x, bool scaled, Array2<octave_idx_type>& ierr)
+           const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr)
 {
   FloatComplexMatrix retval;
 
   octave_idx_type x_nr = x.rows ();
   octave_idx_type x_nc = x.cols ();
 
   octave_idx_type alpha_nr = alpha.rows ();
   octave_idx_type alpha_nc = alpha.cols ();
@@ -1715,17 +1715,17 @@ do_bessel (fptr f, const char *fn, const
     (*current_liboctave_error_handler)
       ("%s: the sizes of alpha and x must conform", fn);
 
   return retval;
 }
 
 static inline FloatComplexMatrix
 do_bessel (fptr f, const char *, const FloatRowVector& alpha,
-           const FloatComplexColumnVector& x, bool scaled, Array2<octave_idx_type>& ierr)
+           const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = x.length ();
   octave_idx_type nc = alpha.length ();
 
   FloatComplexMatrix retval (nr, nc);
 
   ierr.resize (nr, nc);
 
@@ -1741,33 +1741,33 @@ do_bessel (fptr f, const char *, const F
   name (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define SM_BESSEL(name, fcn) \
   FloatComplexMatrix \
   name (float alpha, const FloatComplexMatrix& x, bool scaled, \
-        Array2<octave_idx_type>& ierr) \
+        Array<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define MS_BESSEL(name, fcn) \
   FloatComplexMatrix \
   name (const FloatMatrix& alpha, const FloatComplex& x, bool scaled, \
-        Array2<octave_idx_type>& ierr) \
+        Array<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define MM_BESSEL(name, fcn) \
   FloatComplexMatrix \
   name (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled, \
-        Array2<octave_idx_type>& ierr) \
+        Array<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define SN_BESSEL(name, fcn) \
   FloatComplexNDArray \
   name (float alpha, const FloatComplexNDArray& x, bool scaled, \
         Array<octave_idx_type>& ierr) \
@@ -1789,17 +1789,17 @@ do_bessel (fptr f, const char *, const F
         Array<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define RC_BESSEL(name, fcn) \
   FloatComplexMatrix \
   name (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled, \
-        Array2<octave_idx_type>& ierr) \
+        Array<octave_idx_type>& ierr) \
   { \
     return do_bessel (fcn, #name, alpha, x, scaled, ierr); \
   }
 
 #define ALL_BESSEL(name, fcn) \
   SS_BESSEL (name, fcn) \
   SM_BESSEL (name, fcn) \
   MS_BESSEL (name, fcn) \
@@ -1888,34 +1888,34 @@ biry (const Complex& z, bool deriv, bool
 
   if (zi == 0.0 && (! scaled || zr >= 0.0))
     ai = 0.0;
 
   return bessel_return_value (Complex (ar, ai), ierr);
 }
 
 ComplexMatrix
-airy (const ComplexMatrix& z, bool deriv, bool scaled, Array2<octave_idx_type>& ierr)
+airy (const ComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = z.rows ();
   octave_idx_type nc = z.cols ();
 
   ComplexMatrix retval (nr, nc);
 
   ierr.resize (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = airy (z(i,j), deriv, scaled, ierr(i,j));
 
   return retval;
 }
 
 ComplexMatrix
-biry (const ComplexMatrix& z, bool deriv, bool scaled, Array2<octave_idx_type>& ierr)
+biry (const ComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = z.rows ();
   octave_idx_type nc = z.cols ();
 
   ComplexMatrix retval (nr, nc);
 
   ierr.resize (nr, nc);
 
@@ -2018,34 +2018,34 @@ biry (const FloatComplex& z, bool deriv,
 
   if (zi == 0.0 && (! scaled || zr >= 0.0))
     ai = 0.0;
 
   return bessel_return_value (FloatComplex (ar, ai), ierr);
 }
 
 FloatComplexMatrix
-airy (const FloatComplexMatrix& z, bool deriv, bool scaled, Array2<octave_idx_type>& ierr)
+airy (const FloatComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = z.rows ();
   octave_idx_type nc = z.cols ();
 
   FloatComplexMatrix retval (nr, nc);
 
   ierr.resize (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = airy (z(i,j), deriv, scaled, ierr(i,j));
 
   return retval;
 }
 
 FloatComplexMatrix
-biry (const FloatComplexMatrix& z, bool deriv, bool scaled, Array2<octave_idx_type>& ierr)
+biry (const FloatComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = z.rows ();
   octave_idx_type nc = z.cols ();
 
   FloatComplexMatrix retval (nr, nc);
 
   ierr.resize (nr, nc);
 
diff --git a/liboctave/lo-specfun.h b/liboctave/lo-specfun.h
--- a/liboctave/lo-specfun.h
+++ b/liboctave/lo-specfun.h
@@ -22,17 +22,16 @@ along with Octave; see the file COPYING.
 */
 
 #if !defined (octave_liboctave_specfun_h)
 #define octave_liboctave_specfun_h 1
 
 #include "oct-cmplx.h"
 #include "Array.h"
 
-template <class T> class Array2;
 class Matrix;
 class ComplexMatrix;
 class NDArray;
 class ComplexNDArray;
 class RowVector;
 class ComplexColumnVector;
 class FloatMatrix;
 class FloatComplexMatrix;
@@ -125,85 +124,85 @@ besselk (double alpha, const Complex& x,
 extern OCTAVE_API Complex
 besselh1 (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
 
 extern OCTAVE_API Complex
 besselh2 (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselj (double alpha, const ComplexMatrix& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 bessely (double alpha, const ComplexMatrix& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besseli (double alpha, const ComplexMatrix& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselk (double alpha, const ComplexMatrix& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselh1 (double alpha, const ComplexMatrix& x, bool scaled,
-          Array2<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselh2 (double alpha, const ComplexMatrix& x, bool scaled,
-          Array2<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselj (const Matrix& alpha, const Complex& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 bessely (const Matrix& alpha, const Complex& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besseli (const Matrix& alpha, const Complex& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselk (const Matrix& alpha, const Complex& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselh1 (const Matrix& alpha, const Complex& x, bool scaled,
-          Array2<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselh2 (const Matrix& alpha, const Complex& x, bool scaled,
-          Array2<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselj (const Matrix& alpha, const ComplexMatrix& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 bessely (const Matrix& alpha, const ComplexMatrix& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besseli (const Matrix& alpha, const ComplexMatrix& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselk (const Matrix& alpha, const ComplexMatrix& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselh1 (const Matrix& alpha, const ComplexMatrix& x, bool scaled,
-          Array2<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselh2 (const Matrix& alpha, const ComplexMatrix& x, bool scaled,
-          Array2<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besselj (double alpha, const ComplexNDArray& x, bool scaled,
          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 bessely (double alpha, const ComplexNDArray& x, bool scaled,
          Array<octave_idx_type>& ierr);
@@ -269,37 +268,37 @@ besselh1 (const NDArray& alpha, const Co
           Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 besselh2 (const NDArray& alpha, const ComplexNDArray& x, bool scaled,
           Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselj (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 bessely (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besseli (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselk (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselh1 (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
-          Array2<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselh2 (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
-          Array2<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplex
 besselj (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr);
 
 extern OCTAVE_API FloatComplex
 bessely (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr);
 
 extern OCTAVE_API FloatComplex
@@ -311,85 +310,85 @@ besselk (float alpha, const FloatComplex
 extern OCTAVE_API FloatComplex
 besselh1 (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr);
 
 extern OCTAVE_API FloatComplex
 besselh2 (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselj (float alpha, const FloatComplexMatrix& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 bessely (float alpha, const FloatComplexMatrix& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besseli (float alpha, const FloatComplexMatrix& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselk (float alpha, const FloatComplexMatrix& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselh1 (float alpha, const FloatComplexMatrix& x, bool scaled,
-          Array2<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselh2 (float alpha, const FloatComplexMatrix& x, bool scaled,
-          Array2<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselj (const FloatMatrix& alpha, const FloatComplex& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 bessely (const FloatMatrix& alpha, const FloatComplex& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besseli (const FloatMatrix& alpha, const FloatComplex& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselk (const FloatMatrix& alpha, const FloatComplex& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselh1 (const FloatMatrix& alpha, const FloatComplex& x, bool scaled,
-          Array2<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselh2 (const FloatMatrix& alpha, const FloatComplex& x, bool scaled,
-          Array2<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselj (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 bessely (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besseli (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselk (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselh1 (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled,
-          Array2<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselh2 (const FloatMatrix& alpha, const FloatComplexMatrix& x, bool scaled,
-          Array2<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselj (float alpha, const FloatComplexNDArray& x, bool scaled,
          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 bessely (float alpha, const FloatComplexNDArray& x, bool scaled,
          Array<octave_idx_type>& ierr);
@@ -455,61 +454,61 @@ besselh1 (const FloatNDArray& alpha, con
           Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselh2 (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled,
           Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselj (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 bessely (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besseli (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselk (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled,
-         Array2<octave_idx_type>& ierr);
+         Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselh1 (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled,
-          Array2<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselh2 (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled,
-          Array2<octave_idx_type>& ierr);
+          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API Complex airy (const Complex& z, bool deriv, bool scaled, octave_idx_type& ierr);
 extern OCTAVE_API Complex biry (const Complex& z, bool deriv, bool scaled, octave_idx_type& ierr);
 
 extern OCTAVE_API ComplexMatrix
-airy (const ComplexMatrix& z, bool deriv, bool scaled, Array2<octave_idx_type>& ierr);
+airy (const ComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
-biry (const ComplexMatrix& z, bool deriv, bool scaled, Array2<octave_idx_type>& ierr);
+biry (const ComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 airy (const ComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
 biry (const ComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplex airy (const FloatComplex& z, bool deriv, bool scaled, octave_idx_type& ierr);
 extern OCTAVE_API FloatComplex biry (const FloatComplex& z, bool deriv, bool scaled, octave_idx_type& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
-airy (const FloatComplexMatrix& z, bool deriv, bool scaled, Array2<octave_idx_type>& ierr);
+airy (const FloatComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
-biry (const FloatComplexMatrix& z, bool deriv, bool scaled, Array2<octave_idx_type>& ierr);
+biry (const FloatComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 airy (const FloatComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 biry (const FloatComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API double betainc (double x, double a, double b);
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,18 @@
+2010-02-24  Jaroslav Hajek  <highegg@gmail.com>
+
+	* TEMPLATE-INST/Array-tc.cc: Remove Array2 instantiation.
+	* DLD-FUNCTIONS/besselj.cc: Use Array instead of Array2.
+	* DLD-FUNCTIONS/tril.cc: Ditto.
+	* data.cc: Ditto.
+	* ov-typeinfo.cc: Ditto.
+	* ov-typeinfo.h: Ditto.
+	* pr-output.cc: Ditto.
+
 2010-02-23  Jaroslav Hajek  <highegg@gmail.com>
 
 	* ov-bool-mat.h (octave_bool_matrix::octave_bool_matrix (const
 	Array<bool>&)): New ctor.
 	* ov-ch-mat.h (octave_char_matrix::octave_char_matrix (const
 	Array<char>&)): New ctor.
 	* ov-str-mat.h (octave_char_matrix_str::octave_char_matrix_str (const
 	Array<char>&)): New ctor.
diff --git a/src/DLD-FUNCTIONS/besselj.cc b/src/DLD-FUNCTIONS/besselj.cc
--- a/src/DLD-FUNCTIONS/besselj.cc
+++ b/src/DLD-FUNCTIONS/besselj.cc
@@ -164,17 +164,17 @@ do_bessel (enum bessel_type type, const 
 
                   if (! error_state)
                     {
                       FloatComplexColumnVector cx = 
                         x_arg.float_complex_column_vector_value ();
 
                       if (! error_state)
                         {
-                          Array2<octave_idx_type> ierr;
+                          Array<octave_idx_type> ierr;
                           octave_value result;
 
                           DO_BESSEL (type, ralpha, cx, scaled, ierr, result);
 
                           if (nargout > 1)
                             retval(1) = NDArray (ierr);
 
                           retval(0) = result;
@@ -299,17 +299,17 @@ do_bessel (enum bessel_type type, const 
 
                   if (! error_state)
                     {
                       ComplexColumnVector cx = 
                         x_arg.complex_column_vector_value ();
 
                       if (! error_state)
                         {
-                          Array2<octave_idx_type> ierr;
+                          Array<octave_idx_type> ierr;
                           octave_value result;
 
                           DO_BESSEL (type, ralpha, cx, scaled, ierr, result);
 
                           if (nargout > 1)
                             retval(1) = NDArray (ierr);
 
                           retval(0) = result;
diff --git a/src/DLD-FUNCTIONS/tril.cc b/src/DLD-FUNCTIONS/tril.cc
--- a/src/DLD-FUNCTIONS/tril.cc
+++ b/src/DLD-FUNCTIONS/tril.cc
@@ -44,17 +44,17 @@ do_tril (const Array<T>& a, octave_idx_t
   const T *avec = a.fortran_vec ();
   octave_idx_type zero = 0;
 
   if (pack)
     {
       octave_idx_type j1 = std::min (std::max (zero, k), nc); 
       octave_idx_type j2 = std::min (std::max (zero, nr + k), nc);
       octave_idx_type n = j1 * nr + ((j2 - j1) * (nr-(j1-k) + nr-(j2-1-k))) / 2;
-      Array<T> r (n);
+      Array<T> r (n, 1);
       T *rvec = r.fortran_vec ();
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_idx_type ii = std::min (std::max (zero, j - k), nr);
           rvec = std::copy (avec + ii, avec + nr, rvec);
           avec += nr;
         }
 
@@ -85,17 +85,17 @@ do_triu (const Array<T>& a, octave_idx_t
   const T *avec = a.fortran_vec ();
   octave_idx_type zero = 0;
 
   if (pack)
     {
       octave_idx_type j1 = std::min (std::max (zero, k), nc); 
       octave_idx_type j2 = std::min (std::max (zero, nr + k), nc);
       octave_idx_type n = ((j2 - j1) * ((j1+1-k) + (j2-k))) / 2 + (nc - j2) * nr;
-      Array<T> r (n);
+      Array<T> r (n, 1);
       T *rvec = r.fortran_vec ();
       for (octave_idx_type j = 0; j < nc; j++)
         {
           octave_idx_type ii = std::min (std::max (zero, j + 1 - k), nr);
           rvec = std::copy (avec, avec + ii, rvec);
           avec += nr;
         }
 
diff --git a/src/TEMPLATE-INST/Array-tc.cc b/src/TEMPLATE-INST/Array-tc.cc
--- a/src/TEMPLATE-INST/Array-tc.cc
+++ b/src/TEMPLATE-INST/Array-tc.cc
@@ -25,19 +25,15 @@ along with Octave; see the file COPYING.
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "Array.h"
 #include "Array.cc"
 
-#include "Array2.h"
-
 #include "ov.h"
 
 #include "oct-sort.cc"
 
 NO_INSTANTIATE_ARRAY_SORT (octave_value);
 
 INSTANTIATE_ARRAY (octave_value, OCTINTERP_API);
-
-template class OCTINTERP_API Array2<octave_value>;
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -4886,56 +4886,31 @@ by an empty argument.\n\
     }
 
   if (error_state)
     {
       error ("reshape: invalid arguments");
       return retval;
     }
 
-  // Remove trailing singletons in new_size, but leave at least 2
-  // elements.
-
-  int n = new_size.length ();
-
-  while (n > 2)
+  dim_vector new_dims = dim_vector::alloc (new_size.length ());
+
+  for (octave_idx_type i = 0; i < new_size.length (); i++)
     {
-      if (new_size(n-1) == 1)
-        n--;
+      if (new_size(i) < 0)
+        {
+          error ("reshape: size must be nonnegative");
+          break;
+        }
       else
-        break;
-    }
-
-  if (n < 2)
-    {
-      error ("reshape: expecting size to be vector with at least 2 elements");
-      return retval;
+        new_dims(i) = new_size(i);
     }
 
-  dim_vector new_dims;
-
-  new_dims.resize (n);
-
-  for (octave_idx_type i = 0; i < n; i++)
-    new_dims(i) = new_size(i);
-
-  octave_value arg = args(0);
-
-  dim_vector dims = arg.dims ();
-
-  if (new_dims.numel () == dims.numel ())
-    retval = (new_dims == dims) ? arg : arg.reshape (new_dims);
-  else
-    {
-      std::string dims_str = dims.str ();
-      std::string new_dims_str = new_dims.str ();
-
-      error ("reshape: can't reshape %s array to %s array",
-             dims_str.c_str (), new_dims_str.c_str ());
-    }
+  if (! error_state)
+    retval = args(0).reshape (new_dims);
 
   return retval;
 }
 
 /*
 
 %!assert(size (reshape (ones (4, 4), 2, 8)), [2, 8])
 %!assert(size (reshape (ones (4, 4), 8, 2)), [8, 2])
diff --git a/src/ov-typeinfo.cc b/src/ov-typeinfo.cc
--- a/src/ov-typeinfo.cc
+++ b/src/ov-typeinfo.cc
@@ -32,17 +32,16 @@ along with Octave; see the file COPYING.
 
 const int
 octave_value_typeinfo::init_tab_sz (16);
 
 octave_value_typeinfo *
 octave_value_typeinfo::instance (0);
 
 #include <Array.h>
-#include <Array2.h>
 #include <Array3.h>
 
 bool
 octave_value_typeinfo::instance_ok (void)
 {
   bool retval = true;
   if (! instance)
     instance = new octave_value_typeinfo ();
diff --git a/src/ov-typeinfo.h b/src/ov-typeinfo.h
--- a/src/ov-typeinfo.h
+++ b/src/ov-typeinfo.h
@@ -22,17 +22,16 @@ along with Octave; see the file COPYING.
 */
 
 #if !defined (octave_value_typeinfo_h)
 #define octave_value_typeinfo_h 1
 
 #include <string>
 
 #include "Array.h"
-#include "Array2.h"
 #include "Array3.h"
 
 #include "ov.h"
 
 class string_vector;
 
 class
 OCTINTERP_API
@@ -217,39 +216,39 @@ private:
   int num_types;
 
   Array<std::string> types;
 
   Array<octave_value> vals;
 
   Array<void *> unary_class_ops;
 
-  Array2<void *> unary_ops;
+  Array<void *> unary_ops;
 
-  Array2<void *> non_const_unary_ops;
+  Array<void *> non_const_unary_ops;
 
   Array<void *> binary_class_ops;
 
   Array3<void *> binary_ops;
 
   Array<void *> compound_binary_class_ops;
 
   Array3<void *> compound_binary_ops;
 
-  Array2<void *> cat_ops;
+  Array<void *> cat_ops;
 
   Array3<void *> assign_ops;
 
-  Array2<void *> assignany_ops;
+  Array<void *> assignany_ops;
 
-  Array2<int> pref_assign_conv;
+  Array<int> pref_assign_conv;
 
-  Array2<void *> type_conv_ops;
+  Array<void *> type_conv_ops;
 
-  Array2<void *> widening_ops;
+  Array<void *> widening_ops;
 
   int do_register_type (const std::string&, const std::string&,
                         const octave_value&);
 
   bool do_register_unary_class_op (octave_value::unary_op, unary_class_op_fcn);
 
   bool do_register_unary_op (octave_value::unary_op, int, unary_op_fcn);
 
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -1888,17 +1888,17 @@ octave_print_internal (std::ostream& os,
  \
               idx(0) = idx_vector (':'); \
               idx(1) = idx_vector (':'); \
  \
               for (int k = 2; k < ndims; k++) \
                 idx(k) = idx_vector (ra_idx(k)); \
  \
               octave_value page \
-                = MAT_T (Array2<ELT_T> (nda.index (idx), nr, nc)); \
+                = MAT_T (Array<ELT_T> (nda.index (idx), nr, nc)); \
  \
               page.print_with_name (os, nm); \
  \
               if (i < m) \
                 NDA_T::increment_index (ra_idx, dims, 2); \
             } \
         } \
     } \
@@ -2721,17 +2721,17 @@ octave_print_internal (std::ostream& os,
           Array<idx_vector> idx (ndims, 1);
 
           idx(0) = idx_vector (':');
           idx(1) = idx_vector (':');
 
           for (int k = 2; k < ndims; k++)
             idx(k) = idx_vector (ra_idx(k));
 
-          Array2<std::string> page (nda.index (idx), nr, nc);
+          Array<std::string> page (nda.index (idx), nr, nc);
 
           // FIXME -- need to do some more work to put these
           // in neatly aligned columns...
 
           octave_idx_type n_rows = page.rows ();
           octave_idx_type n_cols = page.cols ();
 
           os << nm << " =\n\n";
@@ -2988,17 +2988,17 @@ octave_print_internal_template (std::ost
           Array<idx_vector> idx (ndims, 1);
 
           idx(0) = idx_vector (':');
           idx(1) = idx_vector (':');
 
           for (int k = 2; k < ndims; k++)
             idx(k) = idx_vector (ra_idx(k));
 
-          Array2<T> page (nda.index (idx), nr, nc);
+          Array<T> page (nda.index (idx), nr, nc);
 
           for (octave_idx_type ii = 0; ii < nr; ii++)
             {
               for (octave_idx_type jj = 0; jj < nc; jj++)
                 {
                   octave_quit ();
 
                   pr_plus_format (os, page(ii,jj));
@@ -3093,17 +3093,17 @@ octave_print_internal_template (std::ost
           Array<idx_vector> idx (ndims, 1);
 
           idx(0) = idx_vector (':');
           idx(1) = idx_vector (':');
 
           for (int k = 2; k < ndims; k++)
             idx(k) = idx_vector (ra_idx(k));
 
-          Array2<T> page (nda.index (idx), nr, nc);
+          Array<T> page (nda.index (idx), nr, nc);
 
           if (free_format)
             {
               if (pr_as_read_syntax)
                 os << "[\n";
 
               for (octave_idx_type ii = 0; ii < nr; ii++)
                 {
