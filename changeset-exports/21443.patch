# HG changeset patch
# User Rik <rik@octave.org>
# Date 1457745137 28800
#      Fri Mar 11 17:12:17 2016 -0800
# Node ID acd6e203031d942e6454b9508099289b1f4c9726
# Parent  78edcabed9539b3d70d5772bd11d19087d6c63c4
Alter BIST tests stop emitting warnings during runtests invocation.

* hsv2rgb.m, rgb2hsv.m, rgb2ntsc.m: Use intended variable of 'int8' rather
than 'uint16'.

* strread.m: Change %!test to %!warning to verify, but swallow, emitted
warning.  Wrap test to < 80 characters.  Place comments about bugs
above %!test block.  Use %!assert blocks rather than %!test, followed
by assert.  Add missing semicolons.

* ode23.m: Clean up file to follow Octave guidelines for indentation.
Use '#' for comments which follow code on a line.
Use 'warning ("off", ..., "local")' to temporarily disable warning messages
during BIST testing.

* ode45.m: Add %!error tests at end of file.
Use 'warning ("off", ..., "local")' to temporarily disable warning messages
during BIST testing.

* pcg.m: Change %!test to %!warning to verify, but swallow, emitted warning.

* hankel.m: Change %!test to %!warning to verify, but swallow, emitted warning.

diff --git a/scripts/image/hsv2rgb.m b/scripts/image/hsv2rgb.m
--- a/scripts/image/hsv2rgb.m
+++ b/scripts/image/hsv2rgb.m
@@ -177,17 +177,17 @@ endfunction
 %! assert (size (rgb), [10 10 3])
 
 %!test
 %! rgb = hsv2rgb (randi ([0 65535], 10, 10, 3, "uint16"));
 %! assert (class (rgb), "double")
 %! assert (size (rgb), [10 10 3])
 
 %!test
-%! rgb = hsv2rgb (randi ([-128 127], 10, 10, 3, "uint16"));
+%! rgb = hsv2rgb (randi ([-128 127], 10, 10, 3, "int8"));
 %! assert (class (rgb), "double")
 %! assert (size (rgb), [10 10 3])
 
 %!test
 %! hsv_double = reshape ([2/3 1/3 1 0 1 1 1 0, 1 1 1 1], [2 2 3]);
 %! hsv_uint8  = reshape (uint8 ([170 85 255 0 255 255 255 0 255 255 255 255]),
 %!                       [2 2 3]);
 %! hsv_int16 = int16 (double (hsv_double * uint16 (65535)) -32768);
diff --git a/scripts/image/rgb2hsv.m b/scripts/image/rgb2hsv.m
--- a/scripts/image/rgb2hsv.m
+++ b/scripts/image/rgb2hsv.m
@@ -153,22 +153,23 @@ endfunction
 %! assert (size (hsv), [10 10 3])
 
 %!test
 %! hsv = rgb2hsv (randi ([0 65535], 10, 10, 3, "uint16"));
 %! assert (class (hsv), "double")
 %! assert (size (hsv), [10 10 3])
 
 %!test
-%! hsv = rgb2hsv (randi ([-128 127], 10, 10, 3, "uint16"));
+%! hsv = rgb2hsv (randi ([-128 127], 10, 10, 3, "int8"));
 %! assert (class (hsv), "double")
 %! assert (size (hsv), [10 10 3])
 
 %!test
 %! rgb_double = reshape ([1 0 1 .5 1 1 0 .5 0 1 1 .5], [2 2 3]);
 %! rgb_uint8  = reshape (uint8 ([255 0 255 128 255 255 0 128 0 255 255 128]),
 %!                       [2 2 3]);
 %! rgb_int16 = int16 (double (rgb_double * uint16 (65535)) -32768);
 %! expected = reshape ([1/6 1/2 5/6 0 1 1 1 0 1 1 1 .5], [2 2 3]);
 %!
 %! assert (rgb2hsv (rgb_double), expected)
 %! assert (rgb2hsv (rgb_uint8), expected, 0.005)
 %! assert (rgb2hsv (single (rgb_double)), single (expected))
+
diff --git a/scripts/image/rgb2ntsc.m b/scripts/image/rgb2ntsc.m
--- a/scripts/image/rgb2ntsc.m
+++ b/scripts/image/rgb2ntsc.m
@@ -131,17 +131,17 @@ endfunction
 %! assert (size (ntsc), [10 10 3])
 
 %!test
 %! ntsc = rgb2ntsc (randi ([0 65535], 10, 10, 3, "uint16"));
 %! assert (class (ntsc), "double")
 %! assert (size (ntsc), [10 10 3])
 
 %!test
-%! ntsc = rgb2ntsc (randi ([-128 127], 10, 10, 3, "uint16"));
+%! ntsc = rgb2ntsc (randi ([-128 127], 10, 10, 3, "int8"));
 %! assert (class (ntsc), "double")
 %! assert (size (ntsc), [10 10 3])
 
 %!test
 %! rgb_double = reshape ([1 0 0 0 0 1 0 0 0 0 1 0], [2 2 3]);
 %! rgb_uint8  = reshape (uint8 ([255 0 0 0 0 255 0 0 0 0 255 0]),
 %!                       [2 2 3]);
 %! rgb_int16 = int16 (double (rgb_double * uint16 (65535)) -32768);
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -865,33 +865,33 @@ endfunction
 
 %!test
 %! str = "# comment\n# comment\n1 2 3";
 %! [a, b] = strread (str, "%n %s", "commentstyle", "shell", "endofline", "\n");
 %! assert (a, [1; 3]);
 %! assert (b, {"2"});
 
 %!test
-%! assert (strread ("Hello World! // this is comment", "%s",...
-%! "commentstyle", "c++"), ...
-%! {"Hello"; "World!"});
+%! assert (strread ("Hello World! // this is comment", "%s",
+%!                  "commentstyle", "c++"),
+%!         {"Hello"; "World!"});
 %! assert (strread ("Hello World! % this is comment", "%s",...
-%! "commentstyle", "matlab"), ...
-%! {"Hello"; "World!"});
+%!                  "commentstyle", "matlab"), ...
+%!         {"Hello"; "World!"});
 %! assert (strread ("Hello World! # this is comment", "%s",...
-%! "commentstyle", "shell"), ...
-%! {"Hello"; "World!"});
+%!                  "commentstyle", "shell"), ...
+%!         {"Hello"; "World!"});
 
 %!test
 %! str = sprintf ("Tom 100 miles/hr\nDick 90 miles/hr\nHarry 80 miles/hr");
 %! fmt = "%s %f miles/hr";
 %! c = cell (1, 2);
 %! [c{:}] = strread (str, fmt);
-%! assert (c{1}, {"Tom"; "Dick"; "Harry"})
-%! assert (c{2}, [100; 90; 80])
+%! assert (c{1}, {"Tom"; "Dick"; "Harry"});
+%! assert (c{2}, [100; 90; 80]);
 
 %!test
 %! a = strread ("a b c, d e, , f", "%s", "delimiter", ",");
 %! assert (a, {"a b c"; "d e"; ""; "f"});
 
 %! ## Format repeat counters w & w/o trailing EOL even within partly read files
 %!test
 %! [a, b] = strread ("10 a 20 b\n 30 c 40", "%d %s", 4);
@@ -899,25 +899,25 @@ endfunction
 %! assert (b, {"a"; "b"; "c"});
 %! [a, b] = strread ("10 a 20 b\n 30 c 40\n", "%d %s", 4);
 %! assert (a, int32 ([10; 20; 30; 40]));
 %! assert (b, {"a"; "b"; "c"; ""});
 %! [a, b] = strread ("10 a 20 b\n 30 c 40", "%d %s", 1);
 %! assert (a, int32 (10));
 %! assert (b, {"a"});
 
+## Bug #33536
 %!test
-%! ## Bug #33536
 %! [a, b, c] = strread ("1,,2", "%s%s%s", "delimiter", ",");
 %! assert (a{1}, "1");
 %! assert (b{1}, "");
 %! assert (c{1}, "2");
 
+## Bug #33536
 %!test
-%! ## Bug #33536
 %! a = strread ("[SomeText]", "[%s", "delimiter", "]");
 %! assert (a{1}, "SomeText");
 
 %!test
 %! dat = "Data file.\r\n=  =  =  =  =\r\nCOMPANY    : <Company name>\r\n";
 %! a = strread (dat, "%s", "delimiter", "\n", "whitespace", "", "endofline", "\r\n");
 %! assert (a{2}, "=  =  =  =  =");
 %! assert (double (a{3}(end-5:end)), [32 110 97 109 101 62]);
@@ -927,127 +927,124 @@ endfunction
 %! assert (c, int32 (3));
 %! assert (d, NaN);
 
 %!test
 %! [a, b, c, d] = strread ("1,2,3,,5,6\n", "%d%d%f%d", "delimiter", ",");
 %! assert (c, [3; NaN]);
 %! assert (d, int32 ([0; 0]));
 
+## Default format (= %f)
 %!test
-%! ## Default format (= %f)
 %! [a, b, c] = strread ("0.12 0.234 0.3567");
 %! assert (a, 0.12);
 %! assert (b, 0.234);
 %! assert (c, 0.3567);
 
 %!test
 %! [a, b] = strread ("0.41 8.24 3.57 6.24 9.27", "%f%f", 2, "delimiter", " ");
 %! assert (a, [0.41; 3.57]);
 
+## TreatAsEmpty
 %!test
-%! ## TreatAsEmpty
 %! [a, b, c, d] = strread ("1,2,3,NN,5,6\n", "%d%d%d%f", "delimiter", ",", "TreatAsEmpty", "NN");
 %! assert (c, int32 ([3; 0]));
 %! assert (d, [NaN; NaN]);
 
+## No delimiters at all besides EOL.  Plain reading numbers & strings
 %!test
-%! ## No delimiters at all besides EOL.  Plain reading numbers & strings
 %! str = "Text1Text2Text\nText398Text4Text\nText57Text";
 %! [a, b] = strread (str, "Text%dText%1sText");
 %! assert (a, int32 ([1; 398; 57]));
 %! assert (b(1:2), {"2"; "4"});
 %! assert (isempty (b{3}), true);
 
 ## MultipleDelimsAsOne
 %!test
 %! str = "11, 12, 13,, 15\n21,, 23, 24, 25\n,, 33, 34, 35";
 %! [a b c d] = strread (str, "%f %f %f %f", "delimiter", ",", "multipledelimsasone", 1, "endofline", "\n");
 %! assert (a', [11, 21, NaN]);
 %! assert (b', [12, 23, 33]);
 %! assert (c', [13, 24, 34]);
 %! assert (d', [15, 25, 35]);
 
 ## Bug #44750
-%!test
-%! assert (strread ('/home/foo/','%s','delimiter','/','MultipleDelimsAsOne',1), ...
-%!         {"home"; "foo"});
+%!assert (strread ('/home/foo/','%s','delimiter','/','MultipleDelimsAsOne',1),
+%!        {"home"; "foo"})
 
 ## delimiter as sq_string and dq_string
-%!test
-%! assert (strread ("1\n2\n3", "%d", "delimiter", "\n"),
-%!         strread ("1\n2\n3", "%d", "delimiter", '\n'))
+%!assert (strread ("1\n2\n3", "%d", "delimiter", "\n"),
+%!        strread ("1\n2\n3", "%d", "delimiter", '\n'))
 
 ## whitespace as sq_string and dq_string
-%!test
-%! assert (strread ("1\b2\r3\b4\t5", "%d", "whitespace", "\b\r\n\t"),
-%!         strread ("1\b2\r3\b4\t5", "%d", "whitespace", '\b\r\n\t'))
+%!assert (strread ("1\b2\r3\b4\t5", "%d", "whitespace", "\b\r\n\t"),
+%!        strread ("1\b2\r3\b4\t5", "%d", "whitespace", '\b\r\n\t'))
 
 %!test
 %! str =  "0.31 0.86 0.94\n 0.60 0.72 0.87";
 %! fmt = "%f %f %f";
 %! args = {"delimiter", " ", "endofline", "\n", "whitespace", " "};
 %! [a, b, c] = strread (str, fmt, args{:});
-%! assert (a, [0.31; 0.60], 0.01)
-%! assert (b, [0.86; 0.72], 0.01)
-%! assert (c, [0.94; 0.87], 0.01)
+%! assert (a, [0.31; 0.60], 0.01);
+%! assert (b, [0.86; 0.72], 0.01);
+%! assert (c, [0.94; 0.87], 0.01);
 
 %!test
 %! str =  "0.31,0.86,0.94\n0.60,0.72,0.87";
 %! fmt = "%f %f %f";
 %! args = {"delimiter", ",", "endofline", "\n", "whitespace", " "};
 %! [a, b, c] = strread (str, fmt, args{:});
-%! assert (a, [0.31; 0.60], 0.01)
-%! assert (b, [0.86; 0.72], 0.01)
-%! assert (c, [0.94; 0.87], 0.01)
+%! assert (a, [0.31; 0.60], 0.01);
+%! assert (b, [0.86; 0.72], 0.01);
+%! assert (c, [0.94; 0.87], 0.01);
 
 %!test
 %! str =  "0.31 0.86 0.94\n 0.60 0.72 0.87";
 %! fmt = "%f %f %f";
 %! args = {"delimiter", ",", "endofline", "\n", "whitespace", " "};
 %! [a, b, c] = strread (str, fmt, args{:});
-%! assert (a, [0.31; 0.60], 0.01)
-%! assert (b, [0.86; 0.72], 0.01)
-%! assert (c, [0.94; 0.87], 0.01)
+%! assert (a, [0.31; 0.60], 0.01);
+%! assert (b, [0.86; 0.72], 0.01);
+%! assert (c, [0.94; 0.87], 0.01);
 
 %!test
 %! str =  "0.31, 0.86, 0.94\n 0.60, 0.72, 0.87";
 %! fmt = "%f %f %f";
 %! args = {"delimiter", ",", "endofline", "\n", "whitespace", " "};
 %! [a, b, c] = strread (str, fmt, args{:});
-%! assert (a, [0.31; 0.60], 0.01)
-%! assert (b, [0.86; 0.72], 0.01)
-%! assert (c, [0.94; 0.87], 0.01)
+%! assert (a, [0.31; 0.60], 0.01);
+%! assert (b, [0.86; 0.72], 0.01);
+%! assert (c, [0.94; 0.87], 0.01);
 
 %!test
 %! [a, b] = strread (["Empty 1" char(10)], "Empty%s %f");
 %! assert (a{1}, '1');
 %! assert (b, NaN);
 
 %!test
 %! [a, b] = strread (["Empty" char(10)], "Empty%f %f");
 %! assert (a, NaN);
 %! assert (b, NaN);
 
+## Bug #35999
 %!test
-%! ## Bug #35999
 %! [a, b, c] = strread ("", "%f");
 %! assert (isempty (a));
 %! assert (isempty (b));
 %! assert (isempty (c));
 
+## Bug #37023
 %!test
-%! ## bug #37023
 %! [a, b] = strread (" 1. 1 \n  2 3 \n", "%f %f", "endofline", "\n");
 %! assert (a, [1; 2], 1e-15);
 %! assert (b, [1; 3], 1e-15);
 
 ## Test for no output arg (interactive use)
-%!test
-%! assert (strread (",2,,4\n5,,7,", "", "delimiter", ","), [NaN; 2; NaN; 4; 5; NaN; 7]);
+%!assert (strread (",2,,4\n5,,7,", "", "delimiter", ","),
+%!        [NaN; 2; NaN; 4; 5; NaN; 7])
 
 ## Test #1 bug #42609
 %!test
 %! [a, b, c] = strread ("1 2 3\n4 5 6\n7 8 9\n", "%f %f %f\n");
 %! assert (a, [1; 4; 7]);
 %! assert (b, [2; 5; 8]);
 %! assert (c, [3; 6; 9]);
 
@@ -1068,45 +1065,42 @@ endfunction
 ## Test #4 bug #42609
 %!test
 %! [a, b, c] = strread ("1 2\n3\n4 5\n6\n7 8\n9\n", '%f %f\n%f');
 %! assert (a, [1;4;7]);
 %! assert (b, [2; 5; 8]);
 %! assert (c, [3; 6; 9]);
 
 ## Unsupported format specifiers
-%!test
 %!error <format specifiers are not supported> strread ("a", "%c")
 %!error <format specifiers are not supported> strread ("a", "%*c %d")
 %!error <format specifiers are not supported> strread ("a", "%q")
 %!error <format specifiers are not supported> strread ("a", "%*q %d")
 %!error <format specifiers are not supported> strread ("a", "%[a]")
 %!error <format specifiers are not supported> strread ("a", "%*[a] %d")
 %!error <format specifiers are not supported> strread ("a", "%[^a]")
 %!error <format specifiers are not supported> strread ("a", "%*[^a] %d")
 %!error <format specifiers are not supported> strread ("a", "%d8")
 %!error <format specifiers are not supported> strread ("a", "%*d8 %s")
 %!error <format specifiers are not supported> strread ("a", "%f64")
 %!error <format specifiers are not supported> strread ("a", "%*f64 %s")
 %!error <format specifiers are not supported> strread ("a", "%u32")
 %!error <format specifiers are not supported> strread ("a", "%*u32 %d")
 
 ## Illegal format specifiers
-%!test
-%!error <no valid format conversion specifiers> strread ("1.0", "%z");
+%!error <no valid format conversion specifiers> strread ("1.0", "%z")
 
 ## Test for false positives in check for non-supported format specifiers
-%!test
-%! assert (strread ("Total: 32.5 % (of cm values)","Total: %f % (of cm values)"), 32.5, 1e-5);
+%!assert (strread ("Total: 32.5 % (of cm values)","Total: %f % (of cm values)"), 32.5, 1e-5)
 
 ## Test various forms of string format specifiers (bug #45712)
 %!test
 %! str = "14 :1 z:2 z:3 z:5 z:11";
 %! [a, b, c, d] = strread (str, "%f %s %*s %3s %*3s %f", "delimiter", ":");
 %! assert ({a, b, c, d}, {14, {"1 z"}, {"3 z"}, 11});
 
-## Allow cuddling %sliteral but warn it is ambiguous
-%!test
+## Allow cuddling %sliteral but warn that it is ambiguous
+%!warning <Ambiguous '%s' specifier immediately before literal in column 1>
 %! [a, b] = strread ("abcxyz51\nxyz83\n##xyz101", "%s xyz %d");
 %! assert (a([1 3]), {"abc"; "##"});
 %! assert (isempty (a{2}), true);
 %! assert (b, int32([51; 83; 101]));
 
diff --git a/scripts/ode/ode23.m b/scripts/ode/ode23.m
--- a/scripts/ode/ode23.m
+++ b/scripts/ode/ode23.m
@@ -81,17 +81,17 @@
 ## row of @var{y} contains the values of all unknowns at the time value
 ## contained in the corresponding row in @var{t}.
 ##
 ## Example: Solve the @nospell{Van der Pol} equation
 ##
 ## @example
 ## @group
 ## fvdp = @@(@var{t},@var{y}) [@var{y}(2); (1 - @var{y}(1)^2) * @var{y}(2) - @var{y}(1)];
-## [@var{t},@var{y}] = ode23 (fvdp, [0 20], [2 0]);
+## [@var{t},@var{y}] = ode23 (fvdp, [0, 20], [2, 0]);
 ## @end group
 ## @end example
 ## @seealso{odeset, odeget}
 ## @end deftypefn
 
 ## ChangeLog:
 ##   20010703 the function file "ode23.m" was written by Marc Compere
 ##     under the GPL for the use with this software. This function has been
@@ -122,17 +122,17 @@ function varargout = ode23 (fun, trange,
       odeopts = ode_struct_value_check ("ode23", varargin{1}, "ode23");
       odeopts.funarguments = {};
     endif
   else  # nargin == 3
     odeopts = odeset ();
     odeopts.funarguments = {};
   endif
 
-  if (! isvector (trange) || ! isnumeric (trange))
+  if (! isnumeric (trange) || ! isvector (trange))
     error ("Octave:invalid-input-arg",
            "ode23: TRANGE must be a numeric vector");
   endif
 
   TimeStepNumber = odeget (odeopts, "TimeStepNumber", [], "fast");
   TimeStepSize = odeget (odeopts, "TimeStepSize", [], "fast");
   if (length (trange) < 2
       && (isempty (TimeStepSize) || isempty (TimeStepNumber)))
@@ -141,17 +141,17 @@ function varargout = ode23 (fun, trange,
   elseif (trange(2) == trange(1))
     error ("Octave:invalid-input-arg",
            "ode23: invalid time span, TRANGE(1) == TRANGE(2)");
   else
     odeopts.direction = sign (trange(2) - trange(1));
   endif
   trange = trange(:);
 
-  if (! isvector (init) || ! isnumeric (init))
+  if (! isnumeric (init) || ! isvector (init))
     error ("Octave:invalid-input-arg",
            "ode23: INIT must be a numeric vector");
   endif
   init = init(:);
 
   if (ischar (fun))
     try
       fun = str2func (fun);
@@ -307,17 +307,17 @@ function varargout = ode23 (fun, trange,
              "ode23: option \"MaxOrder\" is ignored by this solver\n");
   endif
 
   if (! isempty (odeopts.BDF))
     warning ("Octave:invalid-input-arg",
              "ode23: option \"BDF\" is ignored by this solver\n");
   endif
 
-  ## Starting the initialisation of the core solver ode23
+  ## Starting the initialization of the core solver ode23
 
   if (havemasshandle)   # Handle only the dynamic mass matrix,
     if (massdependence) # constant mass matrices have already
       mass = @(t,x) odeopts.Mass (t, x, odeopts.funarguments{:});
       fun = @(t,x) mass (t, x, odeopts.funarguments{:}) ...
         \ fun (t, x, odeopts.funarguments{:});
     else                 # if (massdependence == false)
       mass = @(t) odeopts.Mass (t, odeopts.funarguments{:});
@@ -351,19 +351,19 @@ function varargout = ode23 (fun, trange,
   endif
 
   ## Print additional information if option Stats is set
   if (strcmp (odeopts.Stats, "on"))
     havestats = true;
     nsteps    = solution.cntloop-2;              # cntloop from 2..end
     nfailed   = (solution.cntcycles-1)-nsteps+1; # cntcycl from 1..end
     nfevals   = 3 * (solution.cntcycles-1);      # number of ode evaluations
-    ndecomps  = 0;                               # number of LU decompositions
-    npds      = 0;                               # number of partial derivatives
-    nlinsols  = 0;                               # no. of solutions of linear systems
+    ndecomps  = 0;  # number of LU decompositions
+    npds      = 0;  # number of partial derivatives
+    nlinsols  = 0;  # no. of solutions of linear systems
     ## Print cost statistics if no output argument is given
     if (nargout == 0)
       printf ("Number of successful steps: %d\n", nsteps);
       printf ("Number of failed attempts:  %d\n", nfailed);
       printf ("Number of function calls:   %d\n", nfevals);
     endif
   else
     havestats = false;
@@ -406,23 +406,23 @@ endfunction
 
 ## We are using the "Van der Pol" implementation for all tests that are done
 ## for this function.
 ## For further tests we also define a reference solution (computed at high
 ## accuracy)
 %!function ydot = fpol (t, y)  # The Van der Pol
 %! ydot = [y(2); (1 - y(1)^2) * y(2) - y(1)];
 %!endfunction
-%!function ref = fref ()         # The computed reference sol
+%!function ref = fref ()       # The computed reference sol
 %! ref = [0.32331666704577, -1.83297456798624];
 %!endfunction
-%!function jac = fjac (t, y, varargin) # its Jacobian
+%!function jac = fjac (t, y, varargin)  # its Jacobian
 %! jac = [0, 1; -1 - 2 * y(1) * y(2), 1 - y(1)^2];
 %!endfunction
-%!function jac = fjcc (t, y, varargin) # sparse type
+%!function jac = fjcc (t, y, varargin)  # sparse type
 %! jac = sparse ([0, 1; -1 - 2 * y(1) * y(2), 1 - y(1)^2])
 %!endfunction
 %!function [val, trm, dir] = feve (t, y, varargin)
 %! val = fpol (t, y, varargin);    # We use the derivatives
 %! trm = zeros (2,1);              # that's why component 2
 %! dir = ones (2,1);               # seems to not be exact
 %!endfunction
 %!function [val, trm, dir] = fevn (t, y, varargin)
@@ -444,145 +444,149 @@ endfunction
 %!   out = false;
 %! elseif (regexp (char (flag), "done") == 1)
 %!   if (any (size (t) != [1, 1])) error ("\"fout\" step \"done\""); endif
 %! else
 %!   error ("\"fout\" invalid flag");
 %! endif
 %!endfunction
 %!
-%! ## Turn off output of warning messages for all tests,
-%! ## turn them on again after the last test is called
-%!test
-%! warning ("off", "Octave:invalid-input-arg", "local");
-%!error ## ouput argument
-%!  B = ode23 (1, [0 25], [3 15 1]);
-%!error ## input argument number one
-%!  [t, y] = ode23 (1, [0 25], [3 15 1]);
-%!error ## input argument number two
-%!  [t, y] = ode23 (@fpol, 1, [3 15 1]);
-%!test ## two output arguments
-%!  [t, y] = ode23 (@fpol, [0 2], [2 0]);
-%!  assert ([t(end), y(end,:)], [2, fref], 1e-3);
-%!test ## anonymous function instead of real function
-%!  fvdb = @(t,y) [y(2); (1 - y(1)^2) * y(2) - y(1)];
-%!  [t, y] = ode23 (fvdb, [0 2], [2 0]);
-%!  assert ([t(end), y(end,:)], [2, fref], 1e-3);
-%!test ## extra input arguments passed through
-%!  [t, y] = ode23 (@fpol, [0 2], [2 0], 12, 13, "KL");
-%!  assert ([t(end), y(end,:)], [2, fref], 1e-3);
-%!test ## empty OdePkg structure *but* extra input arguments
-%!  opt = odeset;
-%!  [t, y] = ode23 (@fpol, [0 2], [2 0], opt, 12, 13, "KL");
-%!  assert ([t(end), y(end,:)], [2, fref], 1e-2);
-%!error ## strange OdePkg structure
-%!  opt = struct ("foo", 1);
-%!  [t, y] = ode23 (@fpol, [0 2], [2 0], opt);
-%!test ## Solve vdp in fixed step sizes
-%!  opt = odeset("TimeStepSize",0.1);
-%!  [t, y] = ode23 (@fpol, [0,2], [2 0], opt);
-%!  assert (t(:), [0:0.1:2]', 1e-3);
-%!test ## Solve another anonymous function below zero
-%!  ref = [0, 14.77810590694212];
-%!  [t, y] = ode23 (@(t,y) y, [-2 0], 2);
-%!  assert ([t(end), y(end,:)], ref, 1e-2);
-%!test ## InitialStep option
-%!  opt = odeset ("InitialStep", 1e-8);
-%!  [t, y] = ode23 (@fpol, [0 0.2], [2 0], opt);
-%!  assert ([t(2)-t(1)], [1e-8], 1e-9);
-%!test ## MaxStep option
-%!  opt = odeset ("MaxStep", 1e-3);
-%!  sol = ode23 (@fpol, [0 0.2], [2 0], opt);
-%!  assert ([sol.x(5)-sol.x(4)], [1e-3], 1e-4);
-%!test ## Solve in backward direction starting at t=0
-%!  ref = [-1.205364552835178, 0.951542399860817];
-%!  sol = ode23 (@fpol, [0 -2], [2 0]);
-%!  assert ([sol.x(end), sol.y(end,:)], [-2, ref], 5e-3);
-%!test ## Solve in backward direction starting at t=2
-%!  ref = [-1.205364552835178, 0.951542399860817];
-%!  sol = ode23 (@fpol, [2 0 -2], fref);
-%!  assert ([sol.x(end), sol.y(end,:)], [-2, ref], 2e-2);
-%!test ## Solve another anonymous function in backward direction
-%!  ref = [-1, 0.367879437558975];
-%!  sol = ode23 (@(t,y) y, [0 -1], 1);
-%!  assert ([sol.x(end), sol.y(end,:)], ref, 1e-2);
-%!test ## Solve another anonymous function below zero
-%!  ref = [0, 14.77810590694212];
-%!  sol = ode23 (@(t,y) y, [-2 0], 2);
-%!  assert ([sol.x(end), sol.y(end,:)], ref, 1e-2);
-%!test ## Solve in backward direction starting at t=0 with MaxStep option
-%!  ref = [-1.205364552835178, 0.951542399860817];
-%!  opt = odeset ("MaxStep", 1e-3);
-%!  sol = ode23 (@fpol, [0 -2], [2 0], opt);
-%!  assert ([abs(sol.x(8)-sol.x(7))], [1e-3], 1e-3);
-%!  assert ([sol.x(end), sol.y(end,:)], [-2, ref], 1e-3);
-%!test ## AbsTol option
-%!  opt = odeset ("AbsTol", 1e-5);
-%!  sol = ode23 (@fpol, [0 2], [2 0], opt);
-%!  assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
-%!test ## AbsTol and RelTol option
-%!  opt = odeset ("AbsTol", 1e-8, "RelTol", 1e-8);
-%!  sol = ode23 (@fpol, [0 2], [2 0], opt);
-%!  assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
-%!test ## RelTol and NormControl option -- higher accuracy
-%!  opt = odeset ("RelTol", 1e-8, "NormControl", "on");
-%!  sol = ode23 (@fpol, [0 2], [2 0], opt);
-%!  assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-4);
-%!test ## Keeps initial values while integrating
-%!  opt = odeset ("NonNegative", 2);
-%!  sol = ode23 (@fpol, [0 2], [2 0], opt);
-%!  assert ([sol.x(end), sol.y(end,:)], [2, 2, 0], 1e-1);
-%!test ## Details of OutputSel and Refine can't be tested
-%!  opt = odeset ("OutputFcn", @fout, "OutputSel", 1, "Refine", 5);
-%!  sol = ode23 (@fpol, [0 2], [2 0], opt);
-%!test ## Stats must add further elements in sol
-%!  opt = odeset ("Stats", "on");
-%!  sol = ode23 (@fpol, [0 2], [2 0], opt);
-%!  assert (isfield (sol, "stats"));
-%!  assert (isfield (sol.stats, "nsteps"));
-%!test ## Events option add further elements in sol
-%!  opt = odeset ("Events", @feve);
-%!  sol = ode23 (@fpol, [0 10], [2 0], opt);
-%!  assert (isfield (sol, "ie"));
-%!  assert (sol.ie(1), 2);
-%!  assert (isfield (sol, "xe"));
-%!  assert (isfield (sol, "ye"));
-%!test ## Events option, now stop integration
-%!  opt = odeset ("Events", @fevn, "NormControl", "on");
-%!  sol = ode23 (@fpol, [0 10], [2 0], opt);
-%!  assert ([sol.ie, sol.xe, sol.ye], ...
-%!    [2.0, 2.496110, -0.830550, -2.677589], .5e-1);
-%!test ## Events option, five output arguments
-%!  opt = odeset ("Events", @fevn, "NormControl", "on");
-%!  [t, y, vxe, ye, vie] = ode23 (@fpol, [0 10], [2 0], opt);
-%!  assert ([vie, vxe, ye], ...
-%!    [2.0, 2.496110, -0.830550, -2.677589], 1e-1);
-%!
-%!test ## Mass option as function
-%!  opt = odeset ("Mass", @fmas);
-%!  sol = ode23 (@fpol, [0 2], [2 0], opt);
-%!  assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
-%!test ## Mass option as matrix
-%!  opt = odeset ("Mass", eye (2,2));
-%!  sol = ode23 (@fpol, [0 2], [2 0], opt);
-%!  assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
-%!test ## Mass option as sparse matrix
-%!  opt = odeset ("Mass", sparse (eye (2,2)));
-%!  sol = ode23 (@fpol, [0 2], [2 0], opt);
-%!  assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
-%!test ## Mass option as function and sparse matrix
-%!  opt = odeset ("Mass", @fmsa);
-%!  sol = ode23 (@fpol, [0 2], [2 0], opt);
-%!  assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
-%!test ## Mass option as function and MStateDependence
-%!  opt = odeset ("Mass", @fmas, "MStateDependence", "strong");
-%!  sol = ode23 (@fpol, [0 2], [2 0], opt);
-%!  assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
+%!test  # two output arguments
+%! [t, y] = ode23 (@fpol, [0 2], [2 0]);
+%! assert ([t(end), y(end,:)], [2, fref], 1e-3);
+%!test  # anonymous function instead of real function
+%! fvdb = @(t,y) [y(2); (1 - y(1)^2) * y(2) - y(1)];
+%! [t, y] = ode23 (fvdb, [0 2], [2 0]);
+%! assert ([t(end), y(end,:)], [2, fref], 1e-3);
+%!test  # extra input arguments passed through
+%! [t, y] = ode23 (@fpol, [0 2], [2 0], 12, 13, "KL");
+%! assert ([t(end), y(end,:)], [2, fref], 1e-3);
+%!test  # empty OdePkg structure *but* extra input arguments
+%! opt = odeset;
+%! [t, y] = ode23 (@fpol, [0 2], [2 0], opt, 12, 13, "KL");
+%! assert ([t(end), y(end,:)], [2, fref], 1e-2);
+%!test  # Solve vdp in fixed step sizes
+%! opt = odeset("TimeStepSize",0.1);
+%! [t, y] = ode23 (@fpol, [0,2], [2 0], opt);
+%! assert (t(:), [0:0.1:2]', 1e-3);
+%!test  # Solve another anonymous function below zero
+%! ref = [0, 14.77810590694212];
+%! [t, y] = ode23 (@(t,y) y, [-2 0], 2);
+%! assert ([t(end), y(end,:)], ref, 1e-2);
+%!test  # InitialStep option
+%! opt = odeset ("InitialStep", 1e-8);
+%! [t, y] = ode23 (@fpol, [0 0.2], [2 0], opt);
+%! assert ([t(2)-t(1)], [1e-8], 1e-9);
+%!test  # MaxStep option
+%! opt = odeset ("MaxStep", 1e-3);
+%! sol = ode23 (@fpol, [0 0.2], [2 0], opt);
+%! assert ([sol.x(5)-sol.x(4)], [1e-3], 1e-4);
+%!test  # Solve in backward direction starting at t=0
+%! ref = [-1.205364552835178, 0.951542399860817];
+%! sol = ode23 (@fpol, [0 -2], [2 0]);
+%! assert ([sol.x(end), sol.y(end,:)], [-2, ref], 5e-3);
+%!test  # Solve in backward direction starting at t=2
+%! ref = [-1.205364552835178, 0.951542399860817];
+%! sol = ode23 (@fpol, [2 0 -2], fref);
+%! assert ([sol.x(end), sol.y(end,:)], [-2, ref], 2e-2);
+%!test  # Solve another anonymous function in backward direction
+%! ref = [-1, 0.367879437558975];
+%! sol = ode23 (@(t,y) y, [0 -1], 1);
+%! assert ([sol.x(end), sol.y(end,:)], ref, 1e-2);
+%!test  # Solve another anonymous function below zero
+%! ref = [0, 14.77810590694212];
+%! sol = ode23 (@(t,y) y, [-2 0], 2);
+%! assert ([sol.x(end), sol.y(end,:)], ref, 1e-2);
+%!test  # Solve in backward direction starting at t=0 with MaxStep option
+%! ref = [-1.205364552835178, 0.951542399860817];
+%! opt = odeset ("MaxStep", 1e-3);
+%! sol = ode23 (@fpol, [0 -2], [2 0], opt);
+%! assert ([abs(sol.x(8)-sol.x(7))], [1e-3], 1e-3);
+%! assert ([sol.x(end), sol.y(end,:)], [-2, ref], 1e-3);
+%!test  # AbsTol option
+%! opt = odeset ("AbsTol", 1e-5);
+%! sol = ode23 (@fpol, [0 2], [2 0], opt);
+%! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
+%!test  # AbsTol and RelTol option
+%! opt = odeset ("AbsTol", 1e-8, "RelTol", 1e-8);
+%! sol = ode23 (@fpol, [0 2], [2 0], opt);
+%! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
+%!test  # RelTol and NormControl option -- higher accuracy
+%! opt = odeset ("RelTol", 1e-8, "NormControl", "on");
+%! sol = ode23 (@fpol, [0 2], [2 0], opt);
+%! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-4);
+%!test  # Keeps initial values while integrating
+%! opt = odeset ("NonNegative", 2);
+%! sol = ode23 (@fpol, [0 2], [2 0], opt);
+%! assert ([sol.x(end), sol.y(end,:)], [2, 2, 0], 1e-1);
+%!test  # Details of OutputSel and Refine can't be tested
+%! opt = odeset ("OutputFcn", @fout, "OutputSel", 1, "Refine", 5);
+%! sol = ode23 (@fpol, [0 2], [2 0], opt);
+%!test  # Stats must add further elements in sol
+%! opt = odeset ("Stats", "on");
+%! sol = ode23 (@fpol, [0 2], [2 0], opt);
+%! assert (isfield (sol, "stats"));
+%! assert (isfield (sol.stats, "nsteps"));
+%!test  # Events option add further elements in sol
+%! opt = odeset ("Events", @feve);
+%! sol = ode23 (@fpol, [0 10], [2 0], opt);
+%! assert (isfield (sol, "ie"));
+%! assert (sol.ie(1), 2);
+%! assert (isfield (sol, "xe"));
+%! assert (isfield (sol, "ye"));
+%!test  # Events option, now stop integration
+%! warning ("off", "integrate_adaptive:unexpected_termination", "local");
+%! opt = odeset ("Events", @fevn, "NormControl", "on");
+%! sol = ode23 (@fpol, [0 10], [2 0], opt);
+%! assert ([sol.ie, sol.xe, sol.ye], ...
+%!   [2.0, 2.496110, -0.830550, -2.677589], .5e-1);
+%!test  # Events option, five output arguments
+%! warning ("off", "integrate_adaptive:unexpected_termination", "local");
+%! opt = odeset ("Events", @fevn, "NormControl", "on");
+%! [t, y, vxe, ye, vie] = ode23 (@fpol, [0 10], [2 0], opt);
+%! assert ([vie, vxe, ye], [2.0, 2.496110, -0.830550, -2.677589], 1e-1);
+%!test  # Mass option as function
+%! opt = odeset ("Mass", @fmas);
+%! sol = ode23 (@fpol, [0 2], [2 0], opt);
+%! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
+%!test  # Mass option as matrix
+%! opt = odeset ("Mass", eye (2,2));
+%! sol = ode23 (@fpol, [0 2], [2 0], opt);
+%! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
+%!test  # Mass option as sparse matrix
+%! opt = odeset ("Mass", sparse (eye (2,2)));
+%! sol = ode23 (@fpol, [0 2], [2 0], opt);
+%! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
+%!test  # Mass option as function and sparse matrix
+%! opt = odeset ("Mass", @fmsa);
+%! sol = ode23 (@fpol, [0 2], [2 0], opt);
+%! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
+%!test  # Mass option as function and MStateDependence
+%! opt = odeset ("Mass", @fmas, "MStateDependence", "strong");
+%! sol = ode23 (@fpol, [0 2], [2 0], opt);
+%! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
 %!
 %! ## test for MvPattern option is missing
 %! ## test for InitialSlope option is missing
 %! ## test for MaxOrder option is missing
-%!
-%!  warning ("on", "Octave:InvalidArgument");
 
-## Local Variables: ***
-## mode: octave ***
-## End: ***
+## Test input validation
+%!error ode23 ()
+%!error ode23 (1)
+%!error ode23 (1,2)
+%!error <TRANGE must be a numeric>
+%!  ode23 (@fpol, {[0 25]}, [3 15 1]);
+%!error <TRANGE must be a .* vector>
+%!  ode23 (@fpol, [0 25; 25 0], [3 15 1]);
+%!error <TRANGE must contain at least 2 elements>
+%!  ode23 (@fpol, [1], [3 15 1]);
+%!error <invalid time span>
+%!  ode23 (@fpol, [1 1], [3 15 1]);
+%!error <INIT must be a numeric>
+%!  ode23 (@fpol, [0 25], {[3 15 1]});
+%!error <INIT must be a .* vector>
+%!  ode23 (@fpol, [0 25], [3 15 1; 3 15 1]);
+%!error <FUN must be a valid function handle>
+%!  ode23 (1, [0 25], [3 15 1]);
+%!error  # strange ODEOPT structure
+%!  opt = struct ("foo", 1);
+%!  [t, y] = ode23 (@fpol, [0 2], [2 0], opt);
+
diff --git a/scripts/ode/ode45.m b/scripts/ode/ode45.m
--- a/scripts/ode/ode45.m
+++ b/scripts/ode/ode45.m
@@ -72,17 +72,17 @@
 ## contains an index indicating which Event function was triggered in the case
 ## of multiple Event functions.
 ##
 ## Example: Solve the @nospell{Van der Pol} equation
 ##
 ## @example
 ## @group
 ## fvdp = @@(@var{t},@var{y}) [@var{y}(2); (1 - @var{y}(1)^2) * @var{y}(2) - @var{y}(1)];
-## [@var{t},@var{y}] = ode45 (fvdp, [0 20], [2 0]);
+## [@var{t},@var{y}] = ode45 (fvdp, [0, 20], [2, 0]);
 ## @end group
 ## @end example
 ## @seealso{odeset, odeget}
 ## @end deftypefn
 
 function varargout = ode45 (fun, trange, init, varargin)
 
   if (nargin < 3)
@@ -105,17 +105,17 @@ function varargout = ode45 (fun, trange,
       odeopts = ode_struct_value_check ("ode45", varargin{1}, "ode45");
       odeopts.funarguments = {};
     endif
   else  # nargin == 3
     odeopts = odeset ();
     odeopts.funarguments = {};
   endif
 
-  if (! isvector (trange) || ! isnumeric (trange))
+  if (! isnumeric (trange) || ! isvector (trange))
     error ("Octave:invalid-input-arg",
            "ode45: TRANGE must be a numeric vector");
   endif
 
   TimeStepNumber = odeget (odeopts, "TimeStepNumber", [], "fast");
   TimeStepSize = odeget (odeopts, "TimeStepSize", [], "fast");
   if (length (trange) < 2
       && (isempty (TimeStepSize) || isempty (TimeStepNumber)))
@@ -124,17 +124,17 @@ function varargout = ode45 (fun, trange,
   elseif (trange(1) == trange(2))
     error ("Octave:invalid-input-arg",
            "ode45: invalid time span, TRANGE(1) == TRANGE(2)");
   else
     odeopts.direction = sign (trange(2) - trange(1));
   endif
   trange = trange(:);
 
-  if (! isvector (init) || ! isnumeric (init))
+  if (! isnumeric (init) || ! isvector (init))
     error ("Octave:invalid-input-arg",
            "ode45: INIT must be a numeric vector");
   endif
   init = init(:);
 
   if (ischar (fun))
     try
       fun = str2func (fun);
@@ -291,17 +291,17 @@ function varargout = ode45 (fun, trange,
              "ode45: option 'MaxOrder' is ignored by this solver\n");
   endif
 
   if (! isempty (odeopts.BDF))
     warning ("Octave:invalid-input-arg",
              "ode45: option 'BDF' is ignored by this solver\n");
   endif
 
-  ## Starting the initialisation of the core solver ode45
+  ## Starting the initialization of the core solver ode45
 
   if (havemasshandle)   # Handle only the dynamic mass matrix,
     if (massdependence) # constant mass matrices have already
       mass = @(t,x) odeopts.Mass (t, x, odeopts.funarguments{:});
       fun = @(t,x) mass (t, x, odeopts.funarguments{:}) ...
              \ fun (t, x, odeopts.funarguments{:});
     else                 # if (massdependence == false)
       mass = @(t) odeopts.Mass (t, odeopts.funarguments{:});
@@ -391,27 +391,27 @@ endfunction
 
 ## We are using the "Van der Pol" implementation for all tests that are done
 ## for this function.
 ## For further tests we also define a reference solution (computed at high
 ## accuracy)
 %!function ydot = fpol (t, y)  # The Van der Pol
 %! ydot = [y(2); (1 - y(1)^2) * y(2) - y(1)];
 %!endfunction
-%!function ref = fref ()         # The computed reference solution
+%!function ref = fref ()       # The computed reference solution
 %! ref = [0.32331666704577, -1.83297456798624];
 %!endfunction
-%!function jac = fjac (t, y, varargin) # its Jacobian
+%!function jac = fjac (t, y, varargin)  # its Jacobian
 %! jac = [0, 1; -1 - 2 * y(1) * y(2), 1 - y(1)^2];
 %!endfunction
-%!function jac = fjcc (t, y, varargin) # sparse type
+%!function jac = fjcc (t, y, varargin)  # sparse type
 %! jac = sparse ([0, 1; -1 - 2 * y(1) * y(2), 1 - y(1)^2])
 %!endfunction
 %!function [val, trm, dir] = feve (t, y, varargin)
-%! val = fpol (t, y, varargin);  # We use the derivatives
+%! val = fpol (t, y, varargin);    # We use the derivatives
 %! trm = zeros (2,1);              # that's why component 2
 %! dir = ones (2,1);               # seems to not be exact
 %!endfunction
 %!function [val, trm, dir] = fevn (t, y, varargin)
 %! val = fpol (t, y, varargin);    # We use the derivatives
 %! trm = ones (2,1);               # that's why component 2
 %! dir = ones (2,1);               # seems to not be exact
 %!endfunction
@@ -429,26 +429,16 @@ endfunction
 %!   out = false;
 %! elseif (regexp (char (flag), 'done') == 1)
 %!   if (any (size (t) != [1, 1])) error ('"fout" step "done"'); endif
 %! else
 %!   error ('"fout" invalid flag');
 %! endif
 %!endfunction
 %!
-%! ## Turn off output of warning messages for all tests,
-%! ## turn them on again after the last test is called
-%!test
-%! warning ("off", "Octave:invalid-input-arg", "local");
-%!error  # first input arg is not a function
-%! [t, y] = ode45 (1, [0 25], [3 15 1]);
-%!error  # input argument number one as name of non existing function
-%! [t, y] = ode45 ("non-existing-function", [0 25], [3 15 1]);
-%!error  # input argument number two
-%! [t, y] = ode45 (@fpol, 1, [3 15 1]);
 %!test  # two output arguments
 %! [t, y] = ode45 (@fpol, [0 2], [2 0]);
 %! assert ([t(end), y(end,:)], [2, fref], 1e-2);
 %!test  # not too many steps
 %! [t, y] = ode45 (@fpol, [0 2], [2 0]);
 %! assert (size (t) < 20);
 %!test  # anonymous function instead of real function
 %! fvdb = @(t,y) [y(2); (1 - y(1)^2) * y(2) - y(1)];
@@ -459,19 +449,16 @@ endfunction
 %! assert ([t(end), y(end,:)], [2, fref], 1e-2);
 %!test  # extra input arguments passed through
 %! [t, y] = ode45 (@fpol, [0 2], [2 0], 12, 13, "KL");
 %! assert ([t(end), y(end,:)], [2, fref], 1e-2);
 %!test  # empty ODEOPT structure *but* extra input arguments
 %! opt = odeset;
 %! [t, y] = ode45 (@fpol, [0 2], [2 0], opt, 12, 13, "KL");
 %! assert ([t(end), y(end,:)], [2, fref], 1e-2);
-%!error  # strange ODEOPT structure
-%! opt = struct ("foo", 1);
-%! [t, y] = ode45 (@fpol, [0 2], [2 0], opt);
 %!test  # Solve vdp in fixed step sizes
 %! opt = odeset("TimeStepSize", 0.1);
 %! [t, y] = ode45 (@fpol, [0,2], [2 0], opt);
 %! assert (t(:), [0:0.1:2]', 1e-2);
 %!test  # Solve another anonymous function below zero
 %! vref = [0, 14.77810590694212];
 %! [t, y] = ode45 (@(t,y) y, [-2 0], 2);
 %! assert ([t(end), y(end,:)], vref, 1e-1);
@@ -542,21 +529,23 @@ endfunction
 %!test  # Events option add further elements in sol
 %! opt = odeset ("Events", @feve);
 %! sol = ode45 (@fpol, [0 10], [2 0], opt);
 %! assert (isfield (sol, "ie"));
 %! assert (sol.ie(1), 2);
 %! assert (isfield (sol, "xe"));
 %! assert (isfield (sol, "ye"));
 %!test  # Events option, now stop integration
+%! warning ("off", "integrate_adaptive:unexpected_termination", "local");
 %! opt = odeset ("Events", @fevn, "NormControl", "on");
 %! sol = ode45 (@fpol, [0 10], [2 0], opt);
 %! assert ([sol.ie, sol.xe, sol.ye],
 %!         [2.0, 2.496110, -0.830550, -2.677589], 6e-1);
 %!test  # Events option, five output arguments
+%! warning ("off", "integrate_adaptive:unexpected_termination", "local");
 %! opt = odeset ("Events", @fevn, "NormControl", "on");
 %! [t, y, vxe, ye, vie] = ode45 (@fpol, [0 10], [2 0], opt);
 %! assert ([vie, vxe, ye],
 %!         [2.0, 2.496110, -0.830550, -2.677589], 6e-1);
 %!test  # Mass option as function
 %! opt = odeset ("Mass", @fmas);
 %! sol = ode45 (@fpol, [0 2], [2 0], opt);
 %! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
@@ -571,8 +560,30 @@ endfunction
 %!test  # Mass option as function and sparse matrix
 %! opt = odeset ("Mass", @fmsa);
 %! sol = ode45 (@fpol, [0 2], [2 0], opt);
 %! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
 %!test  # Mass option as function and MStateDependence
 %! opt = odeset ("Mass", @fmas, "MStateDependence", "strong");
 %! sol = ode45 (@fpol, [0 2], [2 0], opt);
 %! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
+
+%!error ode45 ()
+%!error ode45 (1)
+%!error ode45 (1,2)
+%!error <TRANGE must be a numeric>
+%!  ode45 (@fpol, {[0 25]}, [3 15 1]);
+%!error <TRANGE must be a .* vector>
+%!  ode45 (@fpol, [0 25; 25 0], [3 15 1]);
+%!error <TRANGE must contain at least 2 elements>
+%!  ode45 (@fpol, [1], [3 15 1]);
+%!error <invalid time span>
+%!  ode45 (@fpol, [1 1], [3 15 1]);
+%!error <INIT must be a numeric>
+%!  ode45 (@fpol, [0 25], {[3 15 1]});
+%!error <INIT must be a .* vector>
+%!  ode45 (@fpol, [0 25], [3 15 1; 3 15 1]);
+%!error <FUN must be a valid function handle>
+%!  ode45 (1, [0 25], [3 15 1]);
+%!error  # strange ODEOPT structure
+%! opt = struct ("foo", 1);
+%! [t, y] = ode45 (@fpol, [0 2], [2 0], opt);
+
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -489,18 +489,18 @@ endfunction
 %! A = diag ([1:N]); b = rand (N, 1);
 %! X = A \ b;  # X is the true solution
 %! [x, flag] = pcg (A, b, [], N+1);
 %! assert (norm (x - X) / norm (X), 0, 1e-10);
 %! assert (flag, 0);
 
 %!test
 %! ## solve small indefinite diagonal system
-%! ## despite A is indefinite, the iteration continues and converges
-%! ## indefiniteness of A is detected
+%! ## Despite A being indefinite, the iteration continues and converges.
+%! ## The indefiniteness of A is detected.
 %!
 %! N = 10;
 %! A = diag([1:N] .* (-ones(1, N) .^ 2)); b = rand (N, 1);
 %! X = A \ b;  # X is the true solution
 %! [x, flag] = pcg (A, b, [], N+1);
 %! assert (norm (x - X) / norm (X), 0, 1e-10);
 %! assert (flag, 3);
 
@@ -514,20 +514,19 @@ endfunction
 %! endfor
 %! b = ones (N, 1);
 %! X = A \ b;  # X is the true solution
 %! [x, flag, relres, iter, resvec, eigest] = pcg (A, b, 1e-12);
 %! assert (flag);
 %! assert (relres > 1.0);
 %! assert (iter, 20); # should perform max allowable default number of iterations
 
-%!test
-%! ## solve tridiagonal system with 'perfect' preconditioner
-%! ## which converges in one iteration, so the eigest does not
-%! ## work and issues a warning
+%!warning <iteration converged too fast>
+%! ## solve tridiagonal system with "perfect" preconditioner which converges
+%! ## in one iteration, so the eigest does not work and issues a warning.
 %!
 %! N = 100;
 %! A = zeros (N, N);
 %! for i = 1 : N - 1  # form 1-D Laplacian matrix
 %!   A(i:i+1, i:i+1) = [2 -1; -1 2];
 %! endfor
 %! b = ones (N, 1);
 %! X = A \ b;  # X is the true solution
diff --git a/scripts/special-matrix/hankel.m b/scripts/special-matrix/hankel.m
--- a/scripts/special-matrix/hankel.m
+++ b/scripts/special-matrix/hankel.m
@@ -85,15 +85,16 @@ endfunction
 
 
 %!assert (hankel (1), [1])
 %!assert (hankel ([1, 2]), [1, 2; 2, 0])
 %!assert (hankel ([1, 2], [2; -1; -3]), [1, 2, -1; 2, -1, -3])
 %!assert (hankel (1:3), [1,2,3;2,3,0;3,0,0])
 %!assert (hankel (1:3,3:6), [1,2,3,4;2,3,4,5;3,4,5,6])
 %!assert (hankel (1:3,3:4), [1,2;2,3;3,4])
-%!assert (hankel (1:3,4:6), [1,2,3;2,3,5;3,5,6])
+%!warning <column wins anti-diagonal conflict>
+%!  assert (hankel (1:3,4:6), [1,2,3;2,3,5;3,5,6]);
 
 %!error hankel ()
 %!error hankel (1, 2, 3)
 %!error <C must be a vector> hankel ([1, 2; 3, 4])
 %!error <C and R must be vectors> hankel (1:4, [1, 2; 3, 4])
 
