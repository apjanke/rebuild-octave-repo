# HG changeset patch
# User jwe
# Date 1174704456 0
#      Sat Mar 24 02:47:36 2007 +0000
# Node ID 2110cc251779eea685e68fad0711e5ec62932490
# Parent  3f79532415b556a30ab75c43ce7a657e149fff3a
[project @ 2007-03-24 02:47:36 by jwe]

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,13 +1,17 @@
 2007-03-23  John W. Eaton  <jwe@octave.org>
 
-	* control/base/bode.m, quaternion/demoquat.m,
-	quaternion/qcoordinate_plot.m, statistics/base/qqplot.m,
-	statistics/base/ppplot.m, sparse/spy.m:
+	* general/interp2.m, general/bicubic.m, control/base/rldemo.m,
+	control/hinf/hinfdemo.m, control/hinf/dhinfdemo.m,
+	control/base/nyquist.m, control/base/nichols.m,
+	control/base/frdemo.m, signal/freqz_plot.m,
+	control/base/__stepimp__.m, control/base/bode.m,
+	quaternion/demoquat.m, quaternion/qcoordinate_plot.m,
+	statistics/base/qqplot.m, statistics/base/ppplot.m, sparse/spy.m:
 	Update plotting code.
 
 	* control/base/bode.m: Unwrap phase angle.
 
 	* miscellaneous/dump_prefs.m: Remove automatic_replot from the list.
 
 	* plot/axis.m: Don't check automatic_replot, or call replot.
 
diff --git a/scripts/control/base/__stepimp__.m b/scripts/control/base/__stepimp__.m
--- a/scripts/control/base/__stepimp__.m
+++ b/scripts/control/base/__stepimp__.m
@@ -32,169 +32,178 @@
 ## @end deftypefn
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: October 2, 1997
 ## based on lsim.m of Scottedward Hodel
 
 function [y, t] = __stepimp__ (sitype, sys, inp, tstop, n)
 
-  if (sitype == 1)         IMPULSE = 0;
-  elseif (sitype == 2)     IMPULSE = 1;
-  else                     error("__stepimp__: invalid sitype argument.")
+  if (sitype == 1)
+    IMPULSE = 0;
+  elseif (sitype == 2)
+    IMPULSE = 1;
+  else
+    error ("__stepimp__: invalid sitype argument");
   endif
-  sys = sysupdate(sys,"ss");
+  sys = sysupdate (sys, "ss");
 
   USE_DEF = 0;   # default tstop and n if we have to give up
   N_MIN = 50;    # minimum number of points
   N_MAX = 2000;  # maximum number of points
   T_DEF = 10.0;  # default simulation time
 
   ## collect useful information about the system
-  [ncstates,ndstates,NIN,NOUT] = sysdimensions(sys);
-  TSAMPLE = sysgettsam(sys);
+  [ncstates, ndstates, NIN, NOUT] = sysdimensions (sys);
+  TSAMPLE = sysgettsam (sys);
 
-  if (nargin < 3)                      inp = 1;
-  elseif (inp < 1 | inp > NIN)         error("Argument inp out of range")
+  if (nargin < 3)
+    inp = 1;
+  elseif (inp < 1 || inp > NIN)
+    error ("__stepimp__: argument inp out of range");
   endif
 
-  DIGITAL = is_digital(sys);
+  DIGITAL = is_digital (sys);
   if (DIGITAL)
     NSTATES = ndstates;
     if (TSAMPLE < eps)
-      error("__stepimp__: sampling time of discrete system too small.")
+      error ("__stepimp__: sampling time of discrete system too small")
     endif
-  else        NSTATES = ncstates;       endif
+  else
+    NSTATES = ncstates;
+  endif
   if (NSTATES < 1)
-    error("step: pure gain block (n_states < 1), step response is trivial");
+    error ("__stepimp__: pure gain block (n_states < 1), step response is trivial");
   endif
   if (nargin < 5)
     ## we have to compute the time when the system reaches steady state
     ## and the step size
-    ev = eig(sys2ss(sys));
+    ev = eig (sys2ss (sys));
     if (DIGITAL)
       ## perform bilinear transformation on poles in z
       for i = 1:NSTATES
         pole = ev(i);
         if (abs(pole + 1) < 1.0e-10)
           ev(i) = 0;
         else
           ev(i) = 2 / TSAMPLE * (pole - 1) / (pole + 1);
         endif
       endfor
     endif
     ## remove poles near zero from eigenvalue array ev
     nk = NSTATES;
     for i = 1:NSTATES
-      if (abs(real(ev(i))) < 1.0e-10)
+      if (abs (real (ev(i))) < 1.0e-10)
         ev(i) = 0;
         nk = nk - 1;
       endif
     endfor
     if (nk == 0)
       USE_DEF = 1;
       ## printf("##STEPIMP-DEBUG: using defaults.\n");
     else
-      ev = ev(find(ev));
-      x = max(abs(ev));
+      ev = ev(find (ev));
+      x = max (abs (ev));
       t_step = 0.2 * pi / x;
-      x = min(abs(real(ev)));
+      x = min (abs (real (ev)));
       t_sim = 5.0 / x;
       ## round up
-      yy = 10^(ceil(log10(t_sim)) - 1);
-      t_sim = yy * ceil(t_sim / yy);
+      yy = 10^(ceil (log10 (t_sim)) - 1);
+      t_sim = yy * ceil (t_sim / yy);
       ## printf("##STEPIMP-DEBUG: nk=%d   t_step=%f  t_sim=%f\n",
       ##   nk, t_step, t_sim);
     endif
   endif
 
   if (DIGITAL)
     ## ---- sampled system
     if (nargin == 5)
-      n = round(n);
+      n = round (n);
       if (n < 2)
-        error("__stepimp__: n must not be less than 2.")
+        error ("__stepimp__: n must not be less than 2.")
       endif
     else
       if (nargin == 4)
         ## n is unknown
       elseif (nargin >= 1)
         ## tstop and n are unknown
         if (USE_DEF)
           tstop = (N_MIN - 1) * TSAMPLE;
         else
           tstop = t_sim;
         endif
       endif
-      n = floor(tstop / TSAMPLE) + 1;
-      if (n < 2)  n = 2;  endif
+      n = floor (tstop / TSAMPLE) + 1;
+      if (n < 2)
+	n = 2;
+      endif
       if (n > N_MAX)
         n = N_MAX;
-        printf("Hint: number of samples limited to %d by default.\n", \
-               N_MAX);
-        printf("  ==> increase \"n\" parameter for longer simulations.\n");
+        printf ("Hint: number of samples limited to %d by default.\n", \
+		N_MAX);
+        printf ("  ==> increase \"n\" parameter for longer simulations.\n");
       endif
     endif
     tstop = (n - 1) * TSAMPLE;
     t_step = TSAMPLE;
   else
     ## ---- continuous system
     if (nargin == 5)
-      n = round(n);
+      n = round (n);
       if (n < 2)
         error("step: n must not be less than 2.")
       endif
       t_step = tstop / (n - 1);
     else
       if (nargin == 4)
         ## only n in unknown
         if (USE_DEF)
           n = N_MIN;
           t_step = tstop / (n - 1);
         else
-          n = floor(tstop / t_step) + 1;
+          n = floor (tstop / t_step) + 1;
         endif
       else
         ## tstop and n are unknown
         if (USE_DEF)
           tstop = T_DEF;
           n = N_MIN;
           t_step = tstop / (n - 1);
         else
           tstop = t_sim;
-          n = floor(tstop / t_step) + 1;
+          n = floor (tstop / t_step) + 1;
         endif
       endif
       if (n < N_MIN)
         n = N_MIN;
         t_step = tstop / (n - 1);
       endif
       if (n > N_MAX)
         tstop = (n - 1) * t_step;
         t_step = tstop / (N_MAX - 1);
         n = N_MAX;
       endif
     endif
     tstop = (n - 1) * t_step;
-    [jnk,B] = sys2ss(sys);
+    [jnk,B] = sys2ss (sys);
     B = B(:,inp);
-    sys = c2d(sys, t_step);
+    sys = c2d (sys, t_step);
   endif
   ## printf("##STEPIMP-DEBUG: t_step=%f n=%d  tstop=%f\n", t_step, n, tstop);
 
   F = sys.a;
   G = sys.b(:,inp);
   C = sys.c;
   D = sys.d(:,inp);
-  y = zeros(NOUT, n);
-  t = linspace(0, tstop, n);
+  y = zeros (NOUT, n);
+  t = linspace (0, tstop, n);
 
   if (IMPULSE)
-    if (!DIGITAL && (D'*D > 0))
-      error("impulse: D matrix is nonzero, impulse response infinite.")
+    if (! DIGITAL && D'*D > 0)
+      error ("impulse: D matrix is nonzero, impulse response infinite.")
     endif
     if (DIGITAL)
       y(:,1) = D / t_step;
       x = G / t_step;
     else
       x = B;
       y(:,1) = C * x;
       x = F * x;
@@ -202,76 +211,61 @@ function [y, t] = __stepimp__ (sitype, s
     for i = 2:n
       y(:,i) = C * x;
       x = F * x;
     endfor
     if (DIGITAL)
       y *= t_step; 
     endif 
   else
-    x = zeros(NSTATES, 1);
+    x = zeros (NSTATES, 1);
     for i = 1:n
       y(:,i) = C * x + D;
       x = F * x + G;
     endfor
   endif
   
-  save_automatic_replot = automatic_replot;
-  unwind_protect
-    automatic_replot(0);
-    if(nargout == 0)
-      ## Plot the information
-      oneplot();
-      __gnuplot_set__ nogrid
-      __gnuplot_set__ nologscale
-      __gnuplot_set__ autoscale
-      __gnuplot_set__ nokey
-      if (IMPULSE)
-	gm = zeros(NOUT, 1);
-	tt = "impulse";
+  if (nargout == 0)
+    if (IMPULSE)
+      gm = zeros (NOUT, 1);
+      tt = "impulse";
+    else
+      ssys = ss (F, G, C, D, t_step);
+      gm = dcgain (ssys);
+      tt = "step";
+    endif
+    ncols = floor (sqrt (NOUT));
+    nrows = ceil (NOUT / ncols);
+    for i = 1:NOUT
+      subplot (nrows, ncols, i);
+      if (DIGITAL)
+	[ts, ys] = stairs (t, y(i,:));
+	ts = ts(1:2*n-2)';
+	ys = ys(1:2*n-2)';
+	if (length (gm) > 0)
+	  yy = [ys; gm(i)*ones(size(ts))];
+	else
+	  yy = ys;
+	endif
+	plot (ts, yy);
+	grid ("on");
+	xlabel ("time [s]");
+	ylabel ("y(t)");
       else
-	ssys = ss(F, G, C, D, t_step);
-	gm = dcgain(ssys);
-	tt = "step";
-      endif
-      ncols = floor(sqrt(NOUT));
-      nrows = ceil(NOUT / ncols);
-      if (ncols > 1 || nrows > 1)
-	clearplot();
+	if (length (gm) > 0)
+	  yy = [y(i,:); gm(i)*ones(size(t))];
+	else
+	  yy = y(i,:);
+	endif
+	plot (t, yy);
+	grid ("on");
+	xlabel ("time [s]");
+	ylabel ("y(t)");
       endif
-      for i = 1:NOUT
-	subplot(nrows, ncols, i);
-	title(sprintf("%s: | %s -> %s", tt,sysgetsignals(sys,"in",inp,1), ...
-		      sysgetsignals(sys,"out",i,1)));
-	if (DIGITAL)
-	  [ts, ys] = stairs(t, y(i,:));
-	  ts = ts(1:2*n-2)';  ys = ys(1:2*n-2)';
-	  if (length(gm) > 0)
-	    yy = [ys; gm(i)*ones(size(ts))];
-	  else
-	    yy = ys;
-	  endif
-	  grid("on");
-	  xlabel("time [s]");
-	  ylabel("y(t)");
-	  plot(ts, yy);
-	else
-	  if (length(gm) > 0)
-	    yy = [y(i,:); gm(i)*ones(size(t))];
-	  else
-	    yy = y(i,:);
-	  endif
-	  grid("on");
-	  xlabel("time [s]");
-	  ylabel("y(t)");
-	  plot(t, yy);
-	endif
-      endfor
-      ## leave gnuplot in multiplot mode is bad style
-      oneplot();
-      y=[];
-      t=[];
-    endif
-    ## printf("##STEPIMP-DEBUG: gratulations, successfull completion.\n");
-  unwind_protect_cleanup
-    automatic_replot(save_automatic_replot);
-  end_unwind_protect
+      title (sprintf ("%s: | %s -> %s", tt,
+		      sysgetsignals (sys, "in", inp, 1),
+		      sysgetsignals (sys, "out", i, 1)));
+    endfor
+    y = [];
+    t = [];
+  endif
+  ## printf("##STEPIMP-DEBUG: gratulations, successfull completion.\n");
 endfunction  
diff --git a/scripts/control/base/frdemo.m b/scripts/control/base/frdemo.m
--- a/scripts/control/base/frdemo.m
+++ b/scripts/control/base/frdemo.m
@@ -541,19 +541,17 @@ function frdemo ()
           disp(cmd);
           eval(cmd);
           disp("\nTo examine the new discrete poles and zeros, use the command:");
           cmd = "sysout(dsys3,""zp"")";
           disp(cmd);
           eval(cmd);
           disp("\nTo view the system's nyquist plot, execute the following");
           disp("commands:\n");
-          cmd = "__gnuplot_set__ xrange [-4:2];";
-          disp(cmd); eval(cmd);
-          cmd = "__gnuplot_set__ yrange [-2.5:2.5];";
+          cmd = "axis ([-4, 2, -2.5, 2.5]);";
           disp(cmd); eval(cmd);
           cmd = "nyquist(dsys3);";
           run_cmd;
           disp("Notice that the asymptotes swamp out the behavior of the plot")
           disp("near the origin.  You may use interactive nyquist plots")
           disp("to \"zoom in\" on a plot as follows:")
 
           cmd = "atol = 1;";
diff --git a/scripts/control/base/nichols.m b/scripts/control/base/nichols.m
--- a/scripts/control/base/nichols.m
+++ b/scripts/control/base/nichols.m
@@ -63,83 +63,84 @@
 ## @itemx phase
 ## The magnitude and phase of the frequency response @math{G(jw)} or 
 ## @math{G(exp(jwT))} at the selected frequency values.
 ## @item w
 ## The vector of frequency values used.
 ## @end table
 ## If no output arguments are given, @command{nichols} plots the results to the screen.
 ## Descriptive labels are automatically placed. See @command{xlabel}, 
-## @command{ylabel}, @command{title}, and @command{replot}.
+## @command{ylabel}, and @command{title}.
 ##
 ## Note: if the requested plot is for an @acronym{MIMO} system, @var{mag} is set to
 ## @iftex
 ## @tex
 ## $ \Vert G(jw) \Vert $ or $ \Vert G( {\rm exp}(jwT) \Vert $
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## ||G(jw)|| or ||G(exp(jwT))||
 ## @end ifinfo
 ## and phase information is not computed.
 ## @end deftypefn
 
 function [mag, phase, w] = nichols (sys, w, outputs, inputs)
 
   ## check number of input arguments given
-  if (nargin < 1 | nargin > 4)
+  if (nargin < 1 || nargin > 4)
     print_usage ();
   endif
-  if(nargin < 2)
+  if (nargin < 2)
     w = [];
   endif
-  if(nargin < 3)
+  if (nargin < 3)
     outputs = [];
   endif
-  if(nargin < 4)
+  if (nargin < 4)
     inputs = [];
   endif
 
   [f, w, sys] = __bodquist__ (sys, w, outputs, inputs, "nichols");
 
-  [stname,inname,outname] = sysgetsignals(sys);
-  systsam = sysgettsam(sys);
+  [stname,inname,outname] = sysgetsignals (sys);
+  systsam = sysgettsam (sys);
 
   ## Get the magnitude and phase of f.
-  mag = abs(f);
-  phase = arg(f)*180.0/pi;
+  mag = abs (f);
+  phase = arg (f)*180.0/pi;
 
   if (nargout < 1),
     ## Plot the information
-    oneplot();
-    __gnuplot_set__ autoscale;
-    __gnuplot_set__ nokey;
-    clearplot();
-    grid("on");
-    __gnuplot_set__ data style lines;
-    if(is_digital(sys))
+
+    if (max (mag) > 0)
+      plot (phase, 20 * log10 (mag));
+      ylabel ("Gain in dB");
+    else
+      plot (phase, mag);
+      ylabel ("Gain |Y/U|")
+    endif
+
+    grid ("on");
+
+    if (is_digital (sys))
       tistr = "(exp(jwT)) ";
     else
       tistr = "(jw)";
     endif
-    xlabel("Phase (deg)");
-    if(is_siso(sys))
-      title(["Nichols plot of |[Y/U]",tistr,"|, u=", ...
-        sysgetsignals(sys,"in",1,1), ", y=",sysgetsignals(sys,"out",1,1)]);
+
+    xlabel ("Phase (deg)");
+
+    if (is_siso (sys))
+      title (sprintf ("Nichols plot of |[Y/U]%s|, u=%s, y=%s", tistr,
+		      sysgetsignals (sys, "in", 1, 1),
+		      sysgetsignals (sys, "out", 1, 1));
     else
-      title([ "||Y(", tistr, ")/U(", tistr, ")||"]);
-      printf("MIMO plot from\n%s\nto\n%s\n",__outlist__(inname,"    "), ...
-        __outlist__(outname,"       "));
-    endif
-    if(max(mag) > 0)
-      ylabel("Gain in dB");
-      md = 20*log10(mag);
-    else
-      ylabel("Gain |Y/U|")
-      md = mag;
+      title ([ "||Y(", tistr, ")/U(", tistr, ")||"]);
+      printf ("MIMO plot from\n%s\nto\n%s\n", __outlist__ (inname, "    "),
+              __outlist__ (outname, "       "));
     endif
 
-    axvec = axis2dlim([vec(phase),vec(md)]);
-    axis(axvec);
-    plot(phase,md);
+    axis (axis2dlim ([phase(:), md(:)]));
+
     mag = phase = w = [];
   endif
+
 endfunction
diff --git a/scripts/control/base/nyquist.m b/scripts/control/base/nyquist.m
--- a/scripts/control/base/nyquist.m
+++ b/scripts/control/base/nyquist.m
@@ -100,112 +100,112 @@ function [realp, imagp, w] = nyquist (sy
 
   ## Both bode and nyquist share the same introduction, so the common
   ## parts are in a file called __bodquist__.m.  It contains the part that
   ## finds the number of arguments, determines whether or not the system
   ## is SISO, andd computes the frequency response.  Only the way the
   ## response is plotted is different between the two functions.
 
   ## check number of input arguments given
-  if (nargin < 1 | nargin > 5)
+  if (nargin < 1 || nargin > 5)
     print_usage ();
   endif
-  if(nargin < 2)
+  if (nargin < 2)
     w = [];
   endif
-  if(nargin < 3)
+  if (nargin < 3)
     outputs = [];
   endif
-  if(nargin < 4)
+  if (nargin < 4)
     inputs = [];
   endif
-  if(nargin < 5)
+  if (nargin < 5)
     atol = 0;
-  elseif(!(is_sample(atol) | atol == 0))
-    error("atol must be a nonnegative scalar.")
+  elseif (! (is_sample (atol) || atol == 0))
+    error ("nyquist: atol must be a nonnegative scalar")
   endif
 
   ## signal to __bodquist__ who's calling
 
   [f, w, sys] = __bodquist__ (sys, w, outputs, inputs, "nyquist");
 
   ## Get the real and imaginary part of f.
-  realp = real(f);
-  imagp = imag(f);
+  realp = real (f);
+  imagp = imag (f);
 
   ## No output arguments, then display plot, otherwise return data.
   if (nargout == 0)
     dnplot = 0;
-    while(!dnplot)
-      oneplot();
-      __gnuplot_set__ key;
-      clearplot();
+    while (! dnplot)
+      plot (realp, imagp, "- ;+w;", realp, -imagp, "-@ ;-w;");
+
       grid ("on");
-      __gnuplot_set__ data style lines;
 
-      if(is_digital(sys))
+      if (is_digital (sys))
         tstr = " G(e^{jw}) ";
       else
         tstr = " G(jw) ";
       endif
-      xlabel(["Re(",tstr,")"]);
-      ylabel(["Im(",tstr,")"]);
+      xlabel (sprintf ("Re(%s)", tstr));
+      ylabel (sprintf ("Im(%s)", tstr));
 
-      [stn, inn, outn] = sysgetsignals(sys);
-      if(is_siso(sys))
-        title(sprintf("Nyquist plot from %s to %s, w (rad/s) in [%e, %e]", ...
-          inn{1}, outn{1}, w(1), w(length(w))) )
+      [stn, inn, outn] = sysgetsignals (sys);
+      if (is_siso (sys))
+        title (sprintf ("Nyquist plot from %s to %s, w (rad/s) in [%e, %e]",
+			inn{1}, outn{1}, w(1), w(end)));
       endif
 
-      __gnuplot_set__ nologscale xy;
-
-      axis(axis2dlim([[vec(realp),vec(imagp)];[vec(realp),-vec(imagp)]]));
-      plot(realp,imagp,"- ;+w;",realp,-imagp,"-@ ;-w;");
+      axis (axis2dlim ([[realp(:), imagp(:)]; [realp(:), -imagp(:)]]));
 
       ## check for interactive plots
       dnplot = 1; # assume done; will change later if atol is satisfied
-      if(atol > 0 & length(f) > 2)
+      if (atol > 0 && length (f) > 2)
 
         ## check for asymptotes
-        fmax = max(abs(f));
-        fi = find(abs(f) == fmax, 1, "last");
+        fmax = max (abs (f));
+        fi = find (abs (f) == fmax, 1, "last");
 
         ## compute angles from point to point
-        df = diff(f);
-        th = atan2(real(df),imag(df))*180/pi;
+        df = diff (f);
+        th = atan2 (real (df), imag (df)) * 180 / pi;
 
         ## get angle at fmax
-        if(fi == length(f)) fi = fi-1; endif
+        if (fi == length(f))
+	  fi = fi-1;
+	endif
         thm = th(fi);
 
         ## now locate consecutive angles within atol of thm
-        ith_same = find(abs(th - thm) < atol);
-        ichk = union(fi,find(diff(ith_same) == 1));
+        ith_same = find (abs (th - thm) < atol);
+        ichk = union (fi, find (diff (ith_same) == 1));
 
         ## locate max, min consecutive indices in ichk
-        loval = max(complement(ichk,1:fi));
-        if(isempty(loval)) loval = fi;
-        else               loval = loval + 1;   endif
+        loval = max (complement (ichk, 1:fi));
+        if (isempty (loval))
+	  loval = fi;
+        else
+          loval = loval + 1;
+	endif
 
-        hival = min(complement(ichk,fi:length(th)));
-        if(isempty(hival))  hival = fi+1;      endif
+        hival = min (complement (ichk, fi:length(th)));
+        if (isempty (hival))
+	  hival = fi+1;
+	endif
 
-        keep_idx = complement(loval:hival,1:length(w));
+        keep_idx = complement (loval:hival, 1:length(w));
 
-        if(length(keep_idx))
-          resp = input("Remove asymptotes and zoom in (y or n): ",1);
-          if(resp(1) == "y")
+        if (length (keep_idx))
+          resp = input ("Remove asymptotes and zoom in (y or n): ", 1);
+          if (resp(1) == "y")
             dnplot = 0;                 # plot again
             w = w(keep_idx);
             f = f(keep_idx);
-            realp = real(f);
-            imagp = imag(f);
+            realp = real (f);
+            imagp = imag (f);
           endif
         endif
 
      endif
-    endwhile
-    w = [];
-    realp=[];
-    imagp=[];
-  endif
+   endwhile
+   w = realp = imagp = [];
+ endif
 
 endfunction
diff --git a/scripts/control/base/pzmap.m b/scripts/control/base/pzmap.m
--- a/scripts/control/base/pzmap.m
+++ b/scripts/control/base/pzmap.m
@@ -32,58 +32,58 @@
 ## @item pol
 ## @item zer
 ## if omitted, the poles and zeros are plotted on the screen.
 ## otherwise, @var{pol} and @var{zer} are returned as the 
 ## system poles and zeros (see @command{sys2zp} for a preferable function call).
 ## @end table
 ## @end deftypefn
 
-function [zer, pol]=pzmap (sys)
+function [zer, pol] = pzmap (sys)
 
-  if(nargin != 1)
+  if (nargin != 1)
     print_usage ();
-  elseif (!isstruct(sys));
-    error("sys must be in system format");
+  elseif (! isstruct (sys));
+    error ("pzmap: sys must be in system format");
   endif
 
-  [zer,pol] = sys2zp(sys);
+  [zer, pol] = sys2zp (sys);
 
   ## force to column vectors, split into real, imaginary parts
   zerdata = poldata = [];
-  if(length(zer))
-    zer = reshape(zer,length(zer),1);
+  if (length (zer))
+    zer = reshape (zer, length (zer), 1);
     zerdata = [real(zer(:,1)), imag(zer(:,1))];
   endif
-  if(length(pol))
-    pol = reshape(pol,length(pol),1);
+  if (length (pol))
+    pol = reshape (pol, length (pol), 1);
     poldata = [real(pol(:,1)), imag(pol(:,1))];
   endif
 
   ## determine continuous or discrete plane
   vars = "sz";
-  varstr = vars(is_digital(sys) + 1);
+  varstr = vars(is_digital (sys) + 1);
 
   ## Plot the data
-  __gnuplot_set__ nologscale xy;
-  if(is_siso(sys))
-    title(sprintf("Pole-zero map from %s to %s", ...
-	 sysgetsignals(sys,"in",1,1), sysgetsignals(sys,"out",1,1) ));
+
+  if (length (zer) == 0)
+    plot (poldata(:,1), poldata(:,2), "@12 ;poles (no zeros);");
+  elseif (length (pol) == 0)
+    plot (zerdata(:,1), zerdata(:,2), "@31 ;zeros (no poles);");
+  else
+    plot (zerdata(:,1), zerdata(:,2), "@31 ;zeros;",
+	  poldata(:,1), poldata(:,2), "@12 ;poles;");
   endif
-  xlabel(["Re(",varstr,")"]);
-  ylabel(["Im(",varstr,")"]);
-  grid;
+
+  if (is_siso (sys))
+    title (sprintf ("Pole-zero map from %s to %s",
+		    sysgetsignals (sys, "in", 1, 1),
+		    sysgetsignals (sys, "out", 1, 1)));
+  endif
+
+  xlabel (sprintf ("Re(%s)", varstr));
+  ylabel (sprintf ("Im(%s)", varstr));
+  grid ("on");
 
   ## compute axis limits
-  axis(axis2dlim([zerdata;poldata]));
-  grid
-  ## finally, plot the data
-  if(length(zer) == 0)
-    plot(poldata(:,1), poldata(:,2),"@12 ;poles (no zeros);");
-  elseif(length(pol) == 0)
-    plot(zerdata(:,1), zerdata(:,2),"@31 ;zeros (no poles);");
-  else
-    plot(zerdata(:,1), zerdata(:,2),"@31 ;zeros;", ...
-	poldata(:,1), poldata(:,2),"@12 ;poles;");
-  endif
-  replot
+  axis (axis2dlim ([zerdata; poldata]));
 
 endfunction
diff --git a/scripts/control/base/rldemo.m b/scripts/control/base/rldemo.m
--- a/scripts/control/base/rldemo.m
+++ b/scripts/control/base/rldemo.m
@@ -31,17 +31,16 @@ function rldemo ()
   while (1)
     clc
     k = menu("Octave Root Locus Demo", ...
         "Display continuous system's open loop poles and zeros (pzmap)", ...
         "Display discrete system's open loop poles and zeros (pzmap)", ...
         "Display root locus diagram of SISO continuous system (rlocus)", ...
         "Display root locus diagram of SISO discrete system (rlocus)", ...
         "Return to main demo menu");
-    __gnuplot_set__ autoscale
     if (k == 1)
       clc
       help pzmap
       prompt
 
       clc
       disp("Display continuous system's open loop poles and zeros (pzmap)\n");
       disp("Example #1, Consider the following continuous transfer function:");
diff --git a/scripts/control/hinf/dhinfdemo.m b/scripts/control/hinf/dhinfdemo.m
--- a/scripts/control/hinf/dhinfdemo.m
+++ b/scripts/control/hinf/dhinfdemo.m
@@ -146,18 +146,18 @@ if (length(yn) >= 1)
     gwx = sysprune(GWC, 1, 1);
     mag1 = bode(gwx, ww);
     if (columns(mag1) > 1);  mag1 = mag1';  endif
     gwx = sysprune(GWC, 2, 1);
     mag2 = bode(gwx, ww);
     if (columns(mag2) > 1);  mag2 = mag2';  endif
     figure(fig_n)
     fig_n = fig_n + 1;
-    __gnuplot_set__ grid
     loglog(ww, [mag1 mag2]);
+    grid ("on");
   endif
 endif
 
 Kd = c2d(K, "bi", Ts);
 GG = buildssic([1 2; 2 1], [], [1 2], [-2], Gd, Kd);
 disp(" o closed loop poles...");
 damp(GG);
 
diff --git a/scripts/control/hinf/hinfdemo.m b/scripts/control/hinf/hinfdemo.m
--- a/scripts/control/hinf/hinfdemo.m
+++ b/scripts/control/hinf/hinfdemo.m
@@ -396,18 +396,18 @@ switch (sys_type)
         gwx = sysprune(GWC, 1, 1);
         mag1 = bode(gwx, ww);
         if (columns(mag1) > 1);  mag1 = mag1';  endif
         gwx = sysprune(GWC, 2, 1);
         mag2 = bode(gwx, ww);
         if (columns(mag2) > 1);  mag2 = mag2';  endif
         figure(fig_n)
         fig_n = fig_n + 1;
-        __gnuplot_set__ grid
         loglog(ww, [mag1 mag2]);
+        grid ("on");
       endif
     endif
 
     Kd = c2d(K, "bi", Ts);
     GG = buildssic([1 2; 2 1], [], [1 2], [-2], Gd, Kd);
     disp(" o closed loop poles...");
     damp(GG);
 
diff --git a/scripts/general/bicubic.m b/scripts/general/bicubic.m
--- a/scripts/general/bicubic.m
+++ b/scripts/general/bicubic.m
@@ -189,10 +189,9 @@ endfunction
 
 %!demo
 %! A=[13,-1,12;5,4,3;1,6,2];
 %! x=[0,1,4]+10; y=[-10,-9,-8];
 %! xi=linspace(min(x),max(x),17);
 %! yi=linspace(min(y),max(y),26);
 %! mesh(xi,yi,bicubic(x,y,A,xi,yi));
 %! [x,y] = meshgrid(x,y);
-%! __gnuplot_raw__ ("set nohidden3d;\n")
 %! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -234,37 +234,34 @@ endfunction
 
 %!demo
 %! A=[13,-1,12;5,4,3;1,6,2];
 %! x=[0,1,4]; y=[10,11,12];
 %! xi=linspace(min(x),max(x),17);
 %! yi=linspace(min(y),max(y),26)';
 %! mesh(xi,yi,interp2(x,y,A,xi,yi,'linear'));
 %! [x,y] = meshgrid(x,y); 
-%! __gnuplot_raw__ ("set nohidden3d;\n")
 %! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! A=[13,-1,12;5,4,3;1,6,2];
 %! x=[0,1,4]; y=[10,11,12];
 %! xi=linspace(min(x),max(x),17);
 %! yi=linspace(min(y),max(y),26)';
 %! mesh(xi,yi,interp2(x,y,A,xi,yi,'nearest'));
 %! [x,y] = meshgrid(x,y); 
-%! __gnuplot_raw__ ("set nohidden3d;\n")
 %! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
 
 %!#demo
 %! A=[13,-1,12;5,4,3;1,6,2];
 %! x=[0,1,2]; y=[10,11,12];
 %! xi=linspace(min(x),max(x),17);
 %! yi=linspace(min(y),max(y),26);
 %! mesh(xi,yi,interp2(x,y,A,xi,yi,'cubic'));
 %! [x,y] = meshgrid(x,y); 
-%! __gnuplot_raw__ ("set nohidden3d;\n")
 %! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
 
 %!test % simple test
 %!  x = [1,2,3];
 %!  y = [4,5,6,7];
 %!  [X, Y] = meshgrid(x,y);
 %!  Orig = X.^2 + Y.^3;
 %!  xi = [1.2,2, 1.5];
diff --git a/scripts/plot/__errplot__.m b/scripts/plot/__errplot__.m
--- a/scripts/plot/__errplot__.m
+++ b/scripts/plot/__errplot__.m
@@ -21,17 +21,17 @@
 ## @deftypefn {Function File} {} __errplot__ (@var{args})
 ## Really plot errorbar plots. User interface in function errorbar.
 ##
 ## @example
 ## __errplot__ (@var{arg1}, @var{arg2}, ..., @var{fmt})
 ## @end example
 ##
 ## @seealso{semilogx, semilogy, loglog, polar, mesh, contour, __pltopt__,
-## bar, stairs, errorbar, replot, xlabel, ylabel, title}
+## bar, stairs, errorbar, xlabel, ylabel, title}
 ## @end deftypefn
 
 ## Created: 18.7.2000
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
 function h = __errplot__ (fstr, p, a1, a2, a3, a4, a5, a6)
 
diff --git a/scripts/plot/bar.m b/scripts/plot/bar.m
--- a/scripts/plot/bar.m
+++ b/scripts/plot/bar.m
@@ -37,17 +37,17 @@
 ## @example
 ## [xb, yb] = bar (x, y);
 ## plot (xb, yb);
 ## @end example
 ##
 ## @noindent
 ## are equivalent.
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## stairs, replot, xlabel, ylabel, title}
+## stairs, xlabel, ylabel, title}
 ## @end deftypefn
 
 ## Author: jwe
 
 function [xb, yb] = bar (x, y)
 
   if (nargin == 1)
     if (isvector (x))
diff --git a/scripts/plot/errorbar.m b/scripts/plot/errorbar.m
--- a/scripts/plot/errorbar.m
+++ b/scripts/plot/errorbar.m
@@ -97,17 +97,17 @@
 ## @example
 ## errorbar(@var{x}, @var{y}, @var{lx}, @var{ux}, @var{ly}, @var{uy}, "~>")
 ## @end example
 ##
 ## xyerrorbar plot of @var{y} versus @var{x} where @var{x} errorbars
 ## are drawn from @var{x}-@var{lx} to @var{x}+@var{ux} and @var{y} errorbars
 ## from @var{y}-@var{ly} to @var{y}+@var{uy}.
 ## @seealso{semilogx, semilogy, loglog, polar, mesh, contour, __pltopt__,
-## bar, stairs, replot, xlabel, ylabel, title}
+## bar, stairs, xlabel, ylabel, title}
 ## @end deftypefn
 
 ## Created: 18.7.2000
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
 function errorbar (varargin)
 
diff --git a/scripts/plot/grid.m b/scripts/plot/grid.m
--- a/scripts/plot/grid.m
+++ b/scripts/plot/grid.m
@@ -24,17 +24,17 @@
 ## The argument may be either @code{"on"} or @code{"off"}.  If it is
 ## omitted, the the current grid state is toggled.
 ##
 ## If @var{arg} is @code{"minor"} then the minor grid is toggled. When
 ## using a minor grid a second argument @var{arg2} is allowed, which can
 ## be either @code{"on"} or @code{"off"} to explicitly set the state of
 ## the minor grid.
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## bar, stairs, replot, xlabel, ylabel, title}
+## bar, stairs, xlabel, ylabel, title}
 ## @end deftypefn
 
 ## Author: jwe
 
 ## PKG_ADD: mark_as_command grid
 
 function grid (x, y)
 
diff --git a/scripts/plot/loglog.m b/scripts/plot/loglog.m
--- a/scripts/plot/loglog.m
+++ b/scripts/plot/loglog.m
@@ -18,17 +18,17 @@
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} loglog (@var{args})
 ## Make a two-dimensional plot using log scales for both axes.  See the
 ## description of @code{plot} for a description of the arguments that
 ## @code{loglog} will accept.
 ## @seealso{plot, semilogy, loglog, polar, mesh, contour, bar, stairs,
-## replot, xlabel, ylabel, title}
+## xlabel, ylabel, title}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = loglog (varargin)
 
   newplot ();
 
diff --git a/scripts/plot/loglogerr.m b/scripts/plot/loglogerr.m
--- a/scripts/plot/loglogerr.m
+++ b/scripts/plot/loglogerr.m
@@ -28,17 +28,17 @@
 ## @end example
 ##
 ## @noindent
 ## which produces a double logarithm plot of @var{y} versus @var{x} 
 ## with errors in the @var{y}-scale defined by @var{ey} and the plot
 ## format defined by @var{fmt}. See errorbar for available formats and 
 ## additional information.
 ## @seealso{errorbar, semilogxerr, semilogyerr, polar, mesh, contour, 
-## __pltopt__, bar, stairs, replot, xlabel, ylabel, title}
+## __pltopt__, bar, stairs, xlabel, ylabel, title}
 ## @end deftypefn
 
 ## Created: 20.2.2001
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
 function retval = loglogerr (varargin)
 
diff --git a/scripts/plot/plot.m b/scripts/plot/plot.m
--- a/scripts/plot/plot.m
+++ b/scripts/plot/plot.m
@@ -155,17 +155,17 @@
 ## @example
 ## t = 0:0.1:6.3;
 ## plot (t, cos(t), "-;cos(t);", t, sin(t), "+3;sin(t);");
 ## @end example
 ##
 ## This will plot the cosine and sine functions and label them accordingly
 ## in the key.
 ## @seealso{semilogx, semilogy, loglog, polar, mesh, contour, __pltopt__
-## bar, stairs, errorbar, replot, xlabel, ylabel, title, print}
+## bar, stairs, errorbar, xlabel, ylabel, title, print}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = plot (varargin)
 
   newplot ();
 
diff --git a/scripts/plot/plot3.m b/scripts/plot/plot3.m
--- a/scripts/plot/plot3.m
+++ b/scripts/plot/plot3.m
@@ -82,17 +82,17 @@
 ## @group
 ##    z = [0:0.05:5];
 ##    plot3(cos(2*pi*z), sin(2*pi*z), z, ";helix;");
 ##    plot3(z, exp(2i*pi*z), ";complex sinusoid;");
 ## @end group
 ## @end example
 ##
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour, __pltopt__
-## bar, stairs, errorbar, replot, xlabel, ylabel, title, print}
+## bar, stairs, errorbar, xlabel, ylabel, title, print}
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 ##         (modified from __plt__.m)
 
 function retval = plot3 (varargin)
 
   x_set = 0;
diff --git a/scripts/plot/polar.m b/scripts/plot/polar.m
--- a/scripts/plot/polar.m
+++ b/scripts/plot/polar.m
@@ -19,17 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} polar (@var{theta}, @var{rho}, @var{fmt})
 ## Make a two-dimensional plot given polar the coordinates @var{theta} and
 ## @var{rho}.
 ##
 ## The optional third argument specifies the line type.
 ## @seealso{plot, semilogx, semilogy, loglog, mesh, contour, bar,
-## stairs, replot, xlabel, ylabel, title}
+## stairs, xlabel, ylabel, title}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = polar (varargin)
 
   newplot ();
 
diff --git a/scripts/plot/semilogx.m b/scripts/plot/semilogx.m
--- a/scripts/plot/semilogx.m
+++ b/scripts/plot/semilogx.m
@@ -18,17 +18,17 @@
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} semilogx (@var{args})
 ## Make a two-dimensional plot using a log scale for the @var{x} axis.  See
 ## the description of @code{plot} for a description of the arguments
 ## that @code{semilogx} will accept.
 ## @seealso{plot, semilogy, loglog, polar, mesh, contour, bar, stairs,
-## replot, xlabel, ylabel, title}
+## xlabel, ylabel, title}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = semilogx (varargin)
 
   newplot ();
 
diff --git a/scripts/plot/semilogxerr.m b/scripts/plot/semilogxerr.m
--- a/scripts/plot/semilogxerr.m
+++ b/scripts/plot/semilogxerr.m
@@ -28,17 +28,17 @@
 ## @end example
 ##
 ## @noindent
 ## which produces a semi-logarithm plot of @var{y} versus @var{x}
 ## with errors in the @var{y}-scale defined by @var{ey} and the plot
 ## format defined by @var{fmt}. See errorbar for available formats and 
 ## additional information.
 ## @seealso{errorbar, loglogerr semilogyerr, polar, mesh, contour, __pltopt__, 
-## bar, stairs, replot, xlabel, ylabel, title}
+## bar, stairs, xlabel, ylabel, title}
 ## @end deftypefn
 
 ## Created: 20.2.2001
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
 function retval = semilogxerr (varargin)
 
diff --git a/scripts/plot/semilogy.m b/scripts/plot/semilogy.m
--- a/scripts/plot/semilogy.m
+++ b/scripts/plot/semilogy.m
@@ -18,17 +18,17 @@
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} semilogy (@var{args})
 ## Make a two-dimensional plot using a log scale for the @var{y} axis.  See
 ## the description of @code{plot} for a description of the arguments
 ## that @code{semilogy} will accept.
 ## @seealso{plot, semilogx, loglog, polar, mesh, contour, bar, stairs,
-## replot, xlabel, ylabel, title}
+## xlabel, ylabel, title}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = semilogy (varargin)
 
   newplot ();
 
diff --git a/scripts/plot/semilogyerr.m b/scripts/plot/semilogyerr.m
--- a/scripts/plot/semilogyerr.m
+++ b/scripts/plot/semilogyerr.m
@@ -28,17 +28,17 @@
 ## @end example
 ##
 ## @noindent
 ## which produces a semi-logarithm plot of @var{y} versus @var{x}
 ## with errors in the @var{y}-scale defined by @var{ey} and the plot
 ## format defined by @var{fmt}. See errorbar for available formats and 
 ## additional information.
 ## @seealso{errorbar, loglogerr semilogxerr, polar, mesh, contour, __pltopt__, 
-## bar, stairs, replot, xlabel, ylabel, title}
+## bar, stairs,  xlabel, ylabel, title}
 ## @end deftypefn
 
 ## Created: 20.2.2001
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
 function retval = semilogyerr (varargin)
 
diff --git a/scripts/plot/shg.m b/scripts/plot/shg.m
--- a/scripts/plot/shg.m
+++ b/scripts/plot/shg.m
@@ -16,19 +16,19 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} shg
 ##
 ## Show the graph window.  Currently, this is the same as executing
-## replot.
+## @code{drawnow}.
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## bar, stairs, replot, xlabel, ylabel}
+## bar, stairs, xlabel, ylabel}
 ## @end deftypefn
 
 ## Author: jwe
 
 function shg ()
 
   if (nargin != 0)
     warning ("shg: ignoring extra arguments");
diff --git a/scripts/plot/stairs.m b/scripts/plot/stairs.m
--- a/scripts/plot/stairs.m
+++ b/scripts/plot/stairs.m
@@ -37,17 +37,17 @@
 ## @example
 ## [xs, ys] = stairs (x, y);
 ## plot (xs, ys);
 ## @end example
 ##
 ## @noindent
 ## are equivalent.
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## bar, replot, xlabel, ylabel, title}
+## bar, xlabel, ylabel, title}
 ## @end deftypefn
 
 ## Author: jwe
 
 function [xs, ys] = stairs (x, y)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -15,31 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} subplot (@var{rows}, @var{cols}, @var{index})
 ## @deftypefnx {Function File} {} subplot (@var{rcn})
-## Sets @code{gnuplot} in multiplot mode and plots in location
-## given by index (there are @var{cols} by @var{rows} subwindows).
-##
-## Input:
-##
-## @table @var
-## @item rows
-## Number of rows in subplot grid.
-##
-## @item columns
-## Number of columns in subplot grid.
-##
-## @item index
-## Index of subplot where to make the next plot.
-## @end table
+## Set up a plot grid with @var{cols} by @var{rows} subwindows and plot
+## in location given by @var{index}.
 ##
 ## If only one argument is supplied, then it must be a three digit value
 ## specifying the location in digits 1 (rows) and 2 (columns) and the plot
 ## index in digit 3.
 ##
 ## The plot index runs row-wise.  First all the columns in a row are filled
 ## and then the next row is filled.
 ##
diff --git a/scripts/plot/xlabel.m b/scripts/plot/xlabel.m
--- a/scripts/plot/xlabel.m
+++ b/scripts/plot/xlabel.m
@@ -16,21 +16,19 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} xlabel (@var{string})
 ## @deftypefnx {Function File} {} ylabel (@var{string})
 ## @deftypefnx {Function File} {} zlabel (@var{string})
-## Specify x, y, and z axis labels for the plot.  If you already have a plot
-## displayed, use the command @code{replot} to redisplay it with the new
-## labels.
+## Specify x, y, and z axis labels for the plot.
 ## @seealso{plot, semilogx, semilogy, loglog, polar, mesh, contour,
-## bar, stairs, replot, ylabel, title}
+## bar, stairs,  ylabel, title}
 ## @end deftypefn
 
 ## Author: jwe
 
 function h = xlabel (varargin)
 
   if (rem (nargin, 2) == 1)
     if (nargout > 0)
diff --git a/scripts/signal/freqz_plot.m b/scripts/signal/freqz_plot.m
--- a/scripts/signal/freqz_plot.m
+++ b/scripts/signal/freqz_plot.m
@@ -19,77 +19,42 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} freqz_plot (@var{w}, @var{h})
 ## Plot the pass band, stop band and phase response of @var{h}.
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 
-function freqz_plot(w,h)
+function freqz_plot (w, h)
 
     n = length (w);
 
     ## ## exclude zero-frequency
     ## h = h (2 : length (h));
     ## w = w (2 : length (w));
     ## n = n-1;
 
     mag = 20 * log10 (abs (h));
     phase = unwrap (arg (h));
     maxmag = max (mag);
 
-    unwind_protect
-
-      ## Protect graph state.
-
-      replot_state = automatic_replot;
-      automatic_replot(0);
-
-      subplot (311);
-      __gnuplot_set__ lmargin 10;
-      axis ("labely");
-      xlabel ("");
-      grid ("on");
-      axis ([ w(1), w(n), maxmag-3, maxmag ]);
-      plot (w, mag, ";Pass band (dB);");
+    subplot (3, 1, 1);
+    plot (w, mag, ";Pass band (dB);");
+    grid ("on");
+    axis ([w(1), w(n), maxmag-3, maxmag], "labely");
 
-      subplot (312);
-      axis ("labely");
-      title ("");
-      xlabel ("");
-      __gnuplot_set__ tmargin 0;
-      grid ("on");
-      if (maxmag - min (mag) > 100)
-      	axis ([ w(1), w(n), maxmag-100, maxmag ]);
-      else
-      	axis ("autoy");
-      endif
-      plot (w, mag, ";Stop band (dB);");
-      
-      subplot (313);
-      axis ("label");
-      title ("");
-      grid ("on");
-      axis ("autoy");
-      xlabel ("Frequency");
-      axis ([ w(1), w(n) ]);
-      plot (w, phase*360/(2*pi), ";Phase (degrees);");
-      
-    unwind_protect_cleanup
+    subplot (3, 1, 2);
+    plot (w, mag, ";Stop band (dB);");
+    grid ("on");
+    if (maxmag - min (mag) > 100)
+      axis ([w(1), w(n), maxmag-100, maxmag], "labely");
+    else
+      axis ("autoy", "labely");
+    endif
 
-      ## Restore graph state.
-
-      ## FIXME -- if automatic_replot is non-zero, this will
-      ## mess up the graph, however if we don't do it here then the user
-      ## will have to do it themselves.
-
-      grid ("off");
-      axis ("auto", "label");
-      __gnuplot_set__ lmargin;
-      __gnuplot_set__ tmargin;
-      oneplot ();
-
-      automatic_replot(replot_state);
-
-    end_unwind_protect
+    subplot (3, 1, 3);
+    plot (w, phase*360/(2*pi), ";Phase (degrees);");
+    grid ("on");
+    xlabel ("Frequency");
+    axis ([w(1), w(n)], "autoy", "label");
 
 endfunction
