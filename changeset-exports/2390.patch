# HG changeset patch
# User jwe
# Date 845148218 0
#      Sat Oct 12 19:23:38 1996 +0000
# Node ID c2c1482c34c895241b5f707b5697c9ce3271081a
# Parent  3db75e5cdf7c2dff195cd748d2d3f7dfc72d776d
[project @ 1996-10-12 19:13:23 by jwe]

diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -31,21 +31,21 @@ INSTALL_DATA = @INSTALL_DATA@
 %.c : %.l
 
 %.cc : %.l
 	$(LEX) $(LFLAGS) $< > $(@F)
 
 XALL_CXXFLAGS_1 = $(subst -fexternal-templates, , $(ALL_CXXFLAGS))
 XALL_CXXFLAGS = $(subst -fno-implicit-templates, , $(XALL_CXXFLAGS_1))
 
-%.def : %.cc
+%.df : %.cc
 	@echo making $@ from $<
 	@$(CXXCPP) -c $(CPPFLAGS) $(XALL_CXXFLAGS) -DMAKE_BUILTINS $< \
-	  | $(srcdir)/mkdefs > $@.tmp
-	@mv $@.tmp $@
+	  | $(srcdir)/mkdefs > $@.t
+	@mv $@.t $@
 
 # How to make a .oct file from a .o file:
 
 ifeq ($(OCTAVE_LITE), true)
   ifdef CXXPICFLAG
     %.oct : pic/%.o
 	  $(CXX) -shared -o $@ $< \
 	    $(OCTAVE_LFLAGS) \
@@ -78,63 +78,71 @@ ifeq ($(OCTAVE_LITE), true)
   endif
   ifeq ($(WITH_DYNAMIC_LINKING), false)
     DLD_STATIC_OBJ := $(DLD_OBJ)
   endif
 else
   DLD_STATIC_OBJ := $(DLD_OBJ)
 endif
 
-INCLUDES := arith-ops.h builtins.h data.h defun.h defun-dld.h \
+INCLUDES := builtins.h data.h defun.h defun-dld.h \
 	defun-int.h dirfns.h dynamic-ld.h error.h file-io.h \
 	fn-cache.h gripes.h help.h input.h lex.h load-save.h \
 	mappers.h oct.h oct-fstrm.h oct-hist.h oct-iostrm.h \
 	oct-map.h oct-obj.h oct-prcstrm.h oct-procbuf.h \
 	oct-stdstrm.h oct-stream.h oct-strstrm.h pager.h parse.h \
 	pathlen.h pr-output.h procstream.h pt-base.h pt-cmd.h \
 	pt-const.h pt-exp-base.h pt-exp.h pt-fcn.h pt-fvc-base.h \
 	pt-fvc.h pt-mat.h pt-misc.h pt-mvr-base.h pt-mvr.h \
 	pt-plot.h pt-pr-code.h pt-walk.h sighandlers.h symtab.h \
 	syscalls.h sysdep.h systime.h syswait.h token.h toplev.h \
 	unwind-prot.h utils.h variables.h version.h \
 	xdiv.h xpow.h Map.h SLStack.h Stack.h \
-	matrix.h complex-matrix.h char-matrix.h struct.h scalar.h \
-	range.h complex.h all-va-args.h magic-colon.h base-value.h \
-	char-matrix-str.h value.h
+	ov-re-mat.h ov-cx-mat.h ov-ch-mat.h ov-struct.h ov-scalar.h \
+	ov-range.h ov-complex.h ov-va-args.h ov-colon.h ov-base.h \
+	ov-str-mat.h ov.h ov-typeinfo.h ops.h \
+	op-cm-cm.h op-cm-cs.h op-cm-m.h op-cm-s.h op-cs-cm.h \
+	op-cs-cs.h op-cs-m.h op-cs-s.h op-m-cm.h op-m-cs.h \
+	op-m-m.h op-m-s.h op-s-cm.h op-s-cs.h op-s-m.h op-s-s.h \
+	op-str-str.h
 
 TI_SRC := Array-oc.cc Array-os.cc Array-tc.cc Map-fnc.cc Map-tc.cc \
 	SLList-expr.cc SLList-misc.cc SLList-plot.cc SLList-str.cc \
 	SLList-tc.cc SLList-tm.cc SLStack-i.cc SLStack-pc.cc \
 	SLStack-str.cc SLStack-sym.cc SLStack-tok.cc SLStack-ue.cc \
 	SLStack-ui.cc
 
 TI_OBJ := $(patsubst %.cc, %.o, $(TI_SRC))
 
 TI_PICOBJ := $(TI_OBJ)
 ifeq ($(SHARED_LIBS), true)
   ifdef CXXPICFLAG
     TI_PICOBJ := $(addprefix pic/, $(TI_OBJ))
   endif
 endif
 
-SOURCES := arith-ops.cc data.cc defaults.cc dirfns.cc dynamic-ld.cc \
+SOURCES := data.cc defaults.cc dirfns.cc dynamic-ld.cc \
 	error.cc file-io.cc fn-cache.cc gripes.cc help.cc input.cc \
 	lex.l load-save.cc mappers.cc oct-fstrm.cc oct-hist.cc \
 	oct-iostrm.cc oct-map.cc oct-obj.cc oct-prcstrm.cc \
 	oct-procbuf.cc oct-stdstrm.cc oct-stream.cc oct-strstrm.cc \
 	pager.cc parse.y pr-output.cc procstream.cc \
 	pt-base.cc pt-cmd.cc pt-const.cc pt-exp-base.cc pt-exp.cc \
 	pt-fcn.cc pt-fvc-base.cc pt-fvc.cc pt-mat.cc pt-misc.cc \
 	pt-mvr-base.cc pt-mvr.cc pt-plot.cc pt-pr-code.cc resource.cc \
 	sighandlers.cc strcasecmp.c strncase.c strfns.cc strftime.c \
 	symtab.cc syscalls.cc sysdep.cc timefns.cc token.cc toplev.cc \
 	unwind-prot.cc utils.cc variables.cc xdiv.cc xpow.cc \
-	base-value.cc char-matrix.cc matrix.cc complex-matrix.cc \
-	range.cc scalar.cc complex.cc char-matrix-str.cc struct.cc \
-	value.cc
+	ov-base.cc ov-ch-mat.cc ov-re-mat.cc ov-cx-mat.cc ov-range.cc \
+	ov-scalar.cc ov-complex.cc ov-str-mat.cc ov-struct.cc \
+	ov-va-args.cc ov-colon.cc ov.cc ov-typeinfo.cc ops.cc \
+	op-cm-cm.cc op-cm-cs.cc op-cm-m.cc op-cm-s.cc op-cs-cm.cc \
+	op-cs-cs.cc op-cs-m.cc op-cs-s.cc op-m-cm.cc op-m-cs.cc \
+	op-m-m.cc op-m-s.cc op-s-cm.cc op-s-cs.cc op-s-m.cc op-s-s.cc \
+	op-str-str.cc
 
 TEMPLATE_SRC = Map.cc SLStack.cc
 
 OBJECTS_4 := $(SOURCES)
 OBJECTS_3 := $(patsubst %.l, %.o, $(OBJECTS_4))
 OBJECTS_2 := $(patsubst %.y, %.o, $(OBJECTS_3))
 OBJECTS_1 := $(patsubst %.c, %.o, $(OBJECTS_2))
 OBJECTS := $(patsubst %.cc, %.o, $(OBJECTS_1))
@@ -153,19 +161,19 @@ DEP_SOURCES_3 := $(SOURCES) $(DLD_SRC) $
 DEP_SOURCES_2 := $(patsubst %.l, %.cc, $(DEP_SOURCES_3))
 DEP_SOURCES_1 := $(patsubst %.y, %.cc, $(DEP_SOURCES_2))
 DEP_SOURCES := $(patsubst %.c, %.d, $(DEP_SOURCES_1))
 MAKEDEPS := $(patsubst %.cc, %.d, $(DEP_SOURCES))
 
 DEF_FILES_5 := $(SOURCES) $(DLD_SRC) $(TI_SRC)
 DEF_FILES_4 := $(addprefix $(srcdir)/, $(DEF_FILES_5))
 DEF_FILES_3 := $(notdir $(shell grep -l "^DEFUN" $(DEF_FILES_4)))
-DEF_FILES_2 := $(patsubst %.y, %.def, $(DEF_FILES_3))
-DEF_FILES_1 := $(patsubst %.l, %.def, $(DEF_FILES_2))
-DEF_FILES := $(patsubst %.cc, %.def, $(DEF_FILES_1))
+DEF_FILES_2 := $(patsubst %.y, %.df, $(DEF_FILES_3))
+DEF_FILES_1 := $(patsubst %.l, %.df, $(DEF_FILES_2))
+DEF_FILES := $(patsubst %.cc, %.df, $(DEF_FILES_1))
 
 OCTAVE_LFLAGS = -L../liboctave -L../libcruft -L../readline \
 	-L../kpathsea -L../glob -L../dlfcn -L. $(RLD_FLAG)
 
 OCTAVE_LIBS = -loctinterp -loctave -ltinst -lcruft \
 	$(LIBPLPLOT) -lreadline -lkpathsea -lglob $(LIBDLFCN)
 
 LIBS_TO_INSTALL = liboctinterp.a libtinst.a
@@ -236,18 +244,18 @@ stamp-tinst: $(TI_PICOBJ)
 	    $(SH_TERMLIBS) $(SH_LIBS) -lg++ ; \
 	else \
 	  true ; \
 	fi
 	touch stamp-tinst
 
 builtins.cc: $(DEF_FILES) mkbuiltins
 	@echo making $@ from $(DEF_FILES)
-	@$(srcdir)/mkbuiltins $(DEF_FILES) > $@.tmp
-	@$(top_srcdir)/move-if-change $@.tmp $@
+	@$(srcdir)/mkbuiltins $(DEF_FILES) > $@.t
+	@$(top_srcdir)/move-if-change $@.t $@
 
 $(DEF_FILES): mkdefs defun-int.h defun-dld.h defun.h defaults.h oct-conf.h
 
 $(MAKEDEPS): defaults.h oct-gperf.h oct-conf.h
 
 check: all
 .PHONY: check
 
@@ -312,17 +320,17 @@ uninstall:
 
 tags: $(SOURCES) $(DLD_SRC) $(TI_SRC)
 	ctags $(SOURCES) $(DLD_SRC) $(TI_SRC)
 
 TAGS: $(SOURCES) $(DLD_SRC) $(TI_SRC)
 	etags $(SOURCES) $(DLD_SRC) $(TI_SRC)
 
 clean:
-	rm -f *.a *.o *.d *.def pic/*.o builtins.cc defaults.h oct-conf.h
+	rm -f *.a *.o *.d *.df pic/*.o builtins.cc defaults.h oct-conf.h
 	if $(SHARED_LIBS); then rm -f *.$(SHLEXT); fi
 .PHONY: clean
 
 mostlyclean:
 	rm -f *.o pic/*.o
 .PHONY: mostlyclean
 
 distclean: clean
@@ -335,23 +343,23 @@ maintainer-clean: distclean
 	rm -f tags TAGS y.tab.c y.tab.h y.output yy.lex.c lex.cc parse.cc
 	rm -f oct-gperf.h stamp-picdir stamp-tinst stamp-interp stamp-prereq
 	-rmdir pic
 .PHONY: maintainer-clean
 
 local-dist: parse.cc lex.cc oct-gperf.h
 	ln $(DISTFILES) ../`cat ../.fname`/src
 	rm -f parse.cc lex.cc y.tab.h y.output yy.lex.c
-	rm -f oct-gperf.h defaults.h oct-conf.h *.d *.def
+	rm -f oct-gperf.h defaults.h oct-conf.h *.d *.df
 .PHONY: local-dist
 
 dist: parse.cc lex.cc oct-gperf.h
 	ln $(DISTFILES) ../`cat ../.fname`/src
 	rm -f parse.cc lex.cc y.tab.h y.output yy.lex.c
-	rm -f oct-gperf.h defaults.h oct-conf.h *.d *.def builtins.cc
+	rm -f oct-gperf.h defaults.h oct-conf.h *.d *.df builtins.cc
 .PHONY: dist
 
 conf-dist:
 	ln octave.cc Makefile.in ../`cat ../.fname`/src
 .PHONY: conf-dist
 
 # Special rules -- these files need special things to be defined.
 
@@ -359,18 +367,18 @@ defaults.h: defaults.h.in ../Makeconf Ma
 	@$(do-subst-default-vals)
 
 oct-conf.h: oct-conf.h.in ../Makeconf Makefile
 	@$(do-subst-config-vals)
 
 oct-gperf.h: octave.gperf
 	@echo "making $@ from $<"
 	@gperf -a -C -E -H octave_kw_hash -g -N octave_kw_lookup -p -t \
-	  $< > $@.tmp
-	@$(top_srcdir)/move-if-change $@.tmp $@
+	  $< > $@.t
+	@$(top_srcdir)/move-if-change $@.t $@
 
 check: all
 .PHONY: check
 
 # If missing, GNU make attempts to create them in the reverse of the
 # order in which they are listed here.  We rely on that fact to ensure
 # that defaults.h is created before trying to create the .d files.
 # Hmm.  I wonder if we can count on that...
diff --git a/src/defaults.cc b/src/defaults.cc
--- a/src/defaults.cc
+++ b/src/defaults.cc
@@ -41,17 +41,17 @@ Software Foundation, Inc.
 #include <unistd.h>
 #endif
 
 #include "defaults.h"
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
-#include "pt-const.h"
+#include "ov.h"
 #include "toplev.h"
 #include "variables.h"
 #include "version.h"
 
 string Voctave_home;
 
 string Vbin_dir;
 string Vlib_dir;
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -39,33 +39,108 @@ Software Foundation, 59 Temple Place - S
 #include <SLList.h>
 
 #include "Array-flags.h"
 
 #include "mx-base.h"
 #include "Range.h"
 #include "str-vec.h"
 
-#include "arith-ops.h"
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "idx-vector.h"
 #include "mappers.h"
 #include "oct-map.h"
 #include "oct-obj.h"
 #include "pager.h"
 #include "pr-output.h"
 #include "sysdep.h"
 #include "pt-const.h"
 #include "pt-walk.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
+Octave_map
+tree_constant::map_value (void) const
+{
+  return val.map_value ();
+}
+
+void
+tree_constant::print (void)
+{
+}
+
+#if 0
+octave_value
+tree_constant::assign_map_element (SLList<string>&, const octave_value&)
+{
+  octave_value retval;
+  error ("tree_constant::assign_map_element(): not implemented");
+  return retval;
+}
+
+octave_value
+tree_constant::assign_map_element (SLList<string>&, const octave_value_list&,
+				   const octave_value&)
+{
+  octave_value retval;
+  error ("tree_constant::assign_map_element(): not implemented");
+  return retval;
+}
+#endif
+
+octave_value
+tree_constant::eval (bool print_result)
+{
+  if (print_result)
+    val.print ();
+
+  return val;
+}
+
+octave_value_list
+tree_constant::eval (bool, int, const octave_value_list& idx)
+{
+  octave_value_list retval;
+
+  if (idx.length () >  0)
+    retval (0) = index (idx);
+  else
+    retval (0) = val;
+
+  return retval;
+}
+
+octave_value
+tree_constant::lookup_map_element (const string&, bool, bool)
+{
+  octave_value retval;
+  error ("tree_constant::lookup_map_element() not implemented");
+  return retval;
+}
+
+octave_value
+tree_constant::lookup_map_element (SLList<string>&, bool, bool)
+{
+  octave_value retval;
+  error ("tree_constant::lookup_map_element() not implemented");
+  return retval;
+}
+
+void
+tree_constant::accept (tree_walker& tw)
+{
+  tw.visit_constant (*this);
+}
+
+#if 0
+
 #ifndef OCT_VAL_REP
 #define OCT_VAL_REP octave_value::octave_value_rep
 #endif
 
 #ifndef MAX
 #define MAX(a,b) ((a) > (b) ? (a) : (b))
 #endif
 
@@ -81,84 +156,16 @@ Software Foundation, 59 Temple Place - S
 // OCT_VAL_REP class.
 
 // Pointer to the blocks of memory we manage.
 static OCT_VAL_REP *tc_rep_newlist = 0;
 
 // Multiplier for allocating new blocks.
 static const int tc_rep_newlist_grow_size = 128;
 
-// If TRUE, allow assignments like
-//
-//   octave> A(1) = 3; A(2) = 5
-//
-// for A already defined and a matrix type.
-static bool Vdo_fortran_indexing;
-
-// Should we allow things like:
-//
-//   octave> 'abc' + 0
-//   97 98 99
-//
-// to happen?  A positive value means yes.  A negative value means
-// yes, but print a warning message.  Zero means it should be
-// considered an error.
-int Vimplicit_str_to_num_ok;
-
-// Should we allow silent conversion of complex to real when a real
-// type is what we're really looking for?  A positive value means yes.
-// A negative value means yes, but print a warning message.  Zero
-// means it should be considered an error.
-static int Vok_to_lose_imaginary_part;
-
-// If TRUE, create column vectors when doing assignments like:
-//
-//   octave> A(1) = 3; A(2) = 5
-//
-// (for A undefined).  Only matters when resize_on_range_error is also
-// TRUE.
-static bool Vprefer_column_vectors;
-
-// If TRUE, prefer logical (zore-one) indexing over normal indexing
-// when there is a conflice.  For example, given a = [2, 3], the
-// expression  a ([1, 1]) would return [2 3] (instead of [2 2], which
-// would be returned if prefer_zero_one_indxing were FALSE).
-static bool Vprefer_zero_one_indexing;
-
-// If TRUE, print the name along with the value.
-static bool Vprint_answer_id_name;
-
-// Should operations on empty matrices return empty matrices or an
-// error?  A positive value means yes.  A negative value means yes,
-// but print a warning message.  Zero means it should be considered an
-// error.
-int Vpropagate_empty_matrices;
-
-// If TRUE, resize matrices when performing and indexed assignment and
-// the indices are outside the current bounds.
-bool Vresize_on_range_error;
-
-// How many levels of structure elements should we print?
-static int Vstruct_levels_to_print;
-
-// Indentation level for structures.
-static int struct_indent = 0;
-
-static void
-increment_struct_indent (void)
-{
-  struct_indent += 2;
-}
-
-static void
-decrement_struct_indent (void)
-{
-  struct_indent -= 2;
-}
-
 // XXX FIXME XXX -- these should be member functions.
 
 static bool
 any_element_is_complex (const ComplexMatrix& a)
 {
   int nr = a.rows ();
   int nc = a.columns ();
 
@@ -276,117 +283,16 @@ octave_value::operator = (const octave_v
       if (--rep->count <= 0)
 	delete rep;
       rep = a.rep;
       rep->count++;
     }
   return *this;  
 }
 
-octave_value
-octave_value::lookup_map_element (const string& ref, bool insert,
-				   bool silent)
-{
-  octave_value retval;
-
-  if (! ref.empty ())
-    {
-      SLList<string> list;
-
-      size_t beg = 0;
-      size_t end;
-
-      do
-	{
-	  end = ref.find ('.', beg);
-
-	  string tmp = (end == NPOS)
-	    ? ref.substr (beg) : ref.substr (beg, end - beg);
-
-	  list.append (tmp);
-	}
-      while (end != NPOS && (beg = end + 1));
-
-      retval = lookup_map_element (list, insert, silent);
-    }
-
-  return retval;
-}
-
-octave_value
-octave_value::lookup_map_element (SLList<string>& list, bool insert,
-				   bool silent)
-{
-  octave_value retval;
-
-  octave_value_rep *tmp_rep = rep;
-
-  Pix p = list.first ();
-  while (p)
-    {
-      string elt = list (p);
-
-      list.next (p);
-
-      octave_value tmp;
-
-      tmp = tmp_rep->lookup_map_element (elt, insert, silent);
-
-      if (error_state)
-	break;
-
-      tmp_rep = tmp.rep;
-
-      if (! p)
-	retval = tmp;
-    }
-
-  return retval;
-}
-
-void
-octave_value::print (void)
-{
-  print (octave_stdout);
-}
-
-void
-octave_value::print_with_name (const string& name, bool print_padding)
-{
-  print_with_name (octave_stdout, name, print_padding);
-}
-
-void
-octave_value::print_with_name (ostream& output_buf, const string& name,
-			       bool print_padding) 
-{
-  bool pad_after = false;
-
-  if (Vprint_answer_id_name)
-    {
-      if (print_as_scalar ())
-	output_buf << name << " = ";
-      else if (print_as_structure ())
-	{
-	  pad_after = true;
-	  output_buf << name << " =";
-	}
-      else
-	{
-	  pad_after = true;
-	  output_buf << name << " =\n\n";
-	}
-    }
-
-  print (output_buf);
-
-  if (print_padding && pad_after)
-    output_buf << "\n";
-}
-
 // Simple structure assignment.
 
 void
 octave_value::make_unique (void)
 {
   if (rep->count > 1)
     {
       --rep->count;
@@ -495,525 +401,16 @@ octave_value::eval (bool print, int, con
     retval(0) = *this;
 
   if (retval(0).is_defined ())
     retval(0).eval (print);
 
   return retval;
 }
 
-void
-octave_value::accept (tree_walker& tw)
-{
-  tw.visit_octave_value (*this);
-}
-
-// The real representation of constants.
-
-OCT_VAL_REP::octave_value_rep (void)
-{
-  type_tag = unknown_constant;
-}
-
-OCT_VAL_REP::octave_value_rep (double d)
-{
-  scalar = d;
-  type_tag = scalar_constant;
-}
-
-// XXX FIXME XXX -- perhaps these constructors should just do the
-// obvious thing and then call maybe_mutate() instead of duplicating
-// most of that logic several times here...
-
-OCT_VAL_REP::octave_value_rep (const Matrix& m)
-{
-  if (m.rows () == 1 && m.columns () == 1)
-    {
-      scalar = m (0, 0);
-      type_tag = scalar_constant;
-    }
-  else
-    {
-      matrix = new Matrix (m);
-      type_tag = matrix_constant;
-    }
-}
-
-OCT_VAL_REP::octave_value_rep (const DiagMatrix& d)
-{
-  if (d.rows () == 1 && d.columns () == 1)
-    {
-      scalar = d (0, 0);
-      type_tag = scalar_constant;
-    }
-  else
-    {
-      matrix = new Matrix (d);
-      type_tag = matrix_constant;
-    }
-}
-
-OCT_VAL_REP::octave_value_rep (const RowVector& v, int prefer_column_vector)
-{
-  int len = v.capacity ();
-  if (len == 1)
-    {
-      scalar = v (0);
-      type_tag = scalar_constant;
-    }
-  else
-    {
-      int pcv = (prefer_column_vector < 0)
-	? Vprefer_column_vectors
-	  : prefer_column_vector;
-
-      if (pcv)
-	{
-	  Matrix m (len, 1);
-	  for (int i = 0; i < len; i++)
-	    m (i, 0) = v (i);
-	  matrix = new Matrix (m);
-	  type_tag = matrix_constant;
-	}
-      else
-	{
-	  Matrix m (1, len);
-	  for (int i = 0; i < len; i++)
-	    m (0, i) = v (i);
-	  matrix = new Matrix (m);
-	  type_tag = matrix_constant;
-	}
-    }
-}
-
-OCT_VAL_REP::octave_value_rep (const ColumnVector& v, int prefer_column_vector)
-{
-  int len = v.capacity ();
-  if (len == 1)
-    {
-      scalar = v (0);
-      type_tag = scalar_constant;
-    }
-  else
-    {
-      int pcv = (prefer_column_vector < 0)
-	? Vprefer_column_vectors
-	  : prefer_column_vector;
-
-      if (pcv)
-	{
-	  Matrix m (len, 1);
-	  for (int i = 0; i < len; i++)
-	    m (i, 0) = v (i);
-	  matrix = new Matrix (m);
-	  type_tag = matrix_constant;
-	}
-      else
-	{
-	  Matrix m (1, len);
-	  for (int i = 0; i < len; i++)
-	    m (0, i) = v (i);
-	  matrix = new Matrix (m);
-	  type_tag = matrix_constant;
-	}
-    }
-}
-
-OCT_VAL_REP::octave_value_rep (const Complex& c)
-{
-  if (::imag (c) == 0.0)
-    {
-      scalar = ::real (c);
-      type_tag = scalar_constant;
-    }
-  else
-    {
-      complex_scalar = new Complex (c);
-      type_tag = complex_scalar_constant;
-    }
-}
-
-OCT_VAL_REP::octave_value_rep (const ComplexMatrix& m)
-{
-  if (m.rows () == 1 && m.columns () == 1)
-    {
-      Complex c = m (0, 0);
-
-      if (::imag (c) == 0.0)
-	{
-	  scalar = ::real (c);
-	  type_tag = scalar_constant;
-	}
-      else
-	{
-	  complex_scalar = new Complex (c);
-	  type_tag = complex_scalar_constant;
-	}
-    }
-  else if (! any_element_is_complex (*complex_matrix))
-    {
-      matrix = new Matrix (::real (m));
-      type_tag = matrix_constant;
-    }
-  else
-    {
-      complex_matrix = new ComplexMatrix (m);
-      type_tag = complex_matrix_constant;
-    }
-}
-
-OCT_VAL_REP::octave_value_rep (const ComplexDiagMatrix& d)
-{
-  if (d.rows () == 1 && d.columns () == 1)
-    {
-      Complex c = d (0, 0);
-
-      if (::imag (c) == 0.0)
-	{
-	  scalar = ::real (c);
-	  type_tag = scalar_constant;
-	}
-      else
-	{
-	  complex_scalar = new Complex (c);
-	  type_tag = complex_scalar_constant;
-	}
-    }
-  else if (! any_element_is_complex (d))
-    {
-      matrix = new Matrix (::real (d));
-      type_tag = matrix_constant;
-    }
-  else
-    {
-      complex_matrix = new ComplexMatrix (d);
-      type_tag = complex_matrix_constant;
-    }
-}
-
-OCT_VAL_REP::octave_value_rep (const ComplexRowVector& v,
-			   int prefer_column_vector) 
-{
-  int len = v.capacity ();
-  if (len == 1)
-    {
-      Complex c = v (0);
-
-      if (::imag (c) == 0.0)
-	{
-	  scalar = ::real (c);
-	  type_tag = scalar_constant;
-	}
-      else
-	{
-	  complex_scalar = new Complex (c);
-	  type_tag = complex_scalar_constant;
-	}
-    }
-  else
-    {
-      int pcv = (prefer_column_vector < 0)
-	? Vprefer_column_vectors
-	  : prefer_column_vector;
-
-      if (pcv)
-	{
-	  if (! any_element_is_complex (v))
-	    {
-	      Matrix m (len, 1);
-	      for (int i = 0; i < len; i++)
-		m (i, 0) = ::real (v (i));
-	      matrix = new Matrix (m);
-	      type_tag = matrix_constant;
-	    }
-	  else
-	    {
-	      ComplexMatrix m (len, 1);
-	      for (int i = 0; i < len; i++)
-		m (i, 0) = v (i);
-	      complex_matrix = new ComplexMatrix (m);
-	      type_tag = complex_matrix_constant;
-	    }
-	}
-      else
-	{
-	  if (! any_element_is_complex (v))
-	    {
-	      Matrix m (len, 1);
-	      for (int i = 0; i < len; i++)
-		m (0, i) = ::real (v (i));
-	      matrix = new Matrix (m);
-	      type_tag = matrix_constant;
-	    }
-	  else
-	    {
-	      ComplexMatrix m (1, len);
-	      for (int i = 0; i < len; i++)
-		m (0, i) = v (i);
-	      complex_matrix = new ComplexMatrix (m);
-	      type_tag = complex_matrix_constant;
-	    }
-	}
-    }
-}
-
-OCT_VAL_REP::octave_value_rep (const ComplexColumnVector& v, int
-			   prefer_column_vector)
-{
-  int len = v.capacity ();
-  if (len == 1)
-    {
-      Complex c = v (0);
-
-      if (::imag (c) == 0.0)
-	{
-	  scalar = ::real (c);
-	  type_tag = scalar_constant;
-	}
-      else
-	{
-	  complex_scalar = new Complex (c);
-	  type_tag = complex_scalar_constant;
-	}
-    }
-  else
-    {
-      int pcv = (prefer_column_vector < 0)
-	? Vprefer_column_vectors
-	  : prefer_column_vector;
-
-      if (pcv)
-	{
-	  if (! any_element_is_complex (v))
-	    {
-	      Matrix m (len, 1);
-	      for (int i = 0; i < len; i++)
-		m (i, 0) = ::real (v (i));
-	      matrix = new Matrix (m);
-	      type_tag = matrix_constant;
-	    }
-	  else
-	    {
-	      ComplexMatrix m (len, 1);
-	      for (int i = 0; i < len; i++)
-		m (i, 0) = v (i);
-	      complex_matrix = new ComplexMatrix (m);
-	      type_tag = complex_matrix_constant;
-	    }
-	}
-      else
-	{
-	  if (! any_element_is_complex (v))
-	    {
-	      Matrix m (len, 1);
-	      for (int i = 0; i < len; i++)
-		m (0, i) = ::real (v (i));
-	      matrix = new Matrix (m);
-	      type_tag = matrix_constant;
-	    }
-	  else
-	    {
-	      ComplexMatrix m (1, len);
-	      for (int i = 0; i < len; i++)
-		m (0, i) = v (i);
-	      complex_matrix = new ComplexMatrix (m);
-	      type_tag = complex_matrix_constant;
-	    }
-	}
-    }
-}
-
-OCT_VAL_REP::octave_value_rep (const char *s)
-{
-  char_matrix = new charMatrix (s);
-  type_tag = char_matrix_constant_str;
-}
-
-OCT_VAL_REP::octave_value_rep (const string& s)
-{
-  char_matrix = new charMatrix (s);
-  type_tag = char_matrix_constant_str;
-}
-
-OCT_VAL_REP::octave_value_rep (const string_vector& s)
-{
-  int nr = s.length ();
-  int nc = s.max_length ();
-  char_matrix = new charMatrix (nr, nc, 0);
-  for (int i = 0; i < nr; i++)
-    {
-      nc = s[i].length ();
-      for (int j = 0; j < nc; j++)
-	(*char_matrix) (i, j) = s[i][j];
-    }
-  type_tag = char_matrix_constant_str;
-}
-
-OCT_VAL_REP::octave_value_rep (const charMatrix& chm, bool is_str)
-{
-  char_matrix = new charMatrix (chm);
-  type_tag = is_str ? char_matrix_constant_str : char_matrix_constant;
-}
-
-OCT_VAL_REP::octave_value_rep (double b, double l, double i)
-{
-  range = new Range (b, l, i);
-  int nel = range->nelem ();
-  if (nel > 1)
-    type_tag = range_constant;
-  else
-    {
-      delete range;
-      if (nel == 1)
-	{
-	  scalar = b;
-	  type_tag = scalar_constant;
-	}
-      else if (nel == 0)
-	{
-	  matrix = new Matrix ();
-	  type_tag = matrix_constant;
-	}
-      else
-	{
-	  type_tag = unknown_constant;
-	  if (nel == -1)
-	    ::error ("number of elements in range exceeds INT_MAX");
-	  else
-	    ::error ("invalid range");
-	}
-    }
-}
-
-OCT_VAL_REP::octave_value_rep (const Range& r)
-{
-  int nel = r.nelem ();
-  if (nel > 1)
-    {
-      range = new Range (r);
-      type_tag = range_constant;
-    }
-  else if (nel == 1)
-    {
-      scalar = r.base ();
-      type_tag = scalar_constant;
-    }
-  else if (nel == 0)
-    {
-      matrix = new Matrix ();
-      type_tag = matrix_constant;
-    }
-  else
-    {
-      type_tag = unknown_constant;
-      if (nel == -1)
-	::error ("number of elements in range exceeds INT_MAX");
-      else
-	::error ("invalid range");
-    }
-}
-
-OCT_VAL_REP::octave_value_rep (const Octave_map& m)
-{
-  a_map = new Octave_map (m);
-  type_tag = map_constant;
-}
-
-OCT_VAL_REP::octave_value_rep (OCT_VAL_REP::constant_type t)
-{
-  assert (t == magic_colon || t == all_va_args);
-  type_tag = t;
-}
-
-OCT_VAL_REP::octave_value_rep (const octave_value_rep& t)
-{
-  type_tag = t.type_tag;
-
-  switch (t.type_tag)
-    {
-    case unknown_constant:
-      break;
-
-    case scalar_constant:
-      scalar = t.scalar;
-      break;
-
-    case matrix_constant:
-      matrix = new Matrix (*(t.matrix));
-      break;
-
-    case char_matrix_constant:
-      char_matrix = new charMatrix (*(t.char_matrix));
-      break;
-
-    case char_matrix_constant_str:
-      char_matrix = new charMatrix (*(t.char_matrix));
-      break;
-
-    case complex_matrix_constant:
-      complex_matrix = new ComplexMatrix (*(t.complex_matrix));
-      break;
-
-    case complex_scalar_constant:
-      complex_scalar = new Complex (*(t.complex_scalar));
-      break;
-
-    case range_constant:
-      range = new Range (*(t.range));
-      break;
-
-    case map_constant:
-      a_map = new Octave_map (*(t.a_map));
-      break;
-
-    case magic_colon:
-    case all_va_args:
-      break;
-    }
-
-  orig_text = t.orig_text;
-}
-
-OCT_VAL_REP::~octave_value_rep (void)
-{
-  switch (type_tag)
-    {
-    case matrix_constant:
-      delete matrix;
-      break;
-
-    case complex_scalar_constant:
-      delete complex_scalar;
-      break;
-
-    case complex_matrix_constant:
-      delete complex_matrix;
-      break;
-
-    case char_matrix_constant:
-    case char_matrix_constant_str:
-      delete char_matrix;
-      break;
-
-    case range_constant:
-      delete range;
-      break;
-
-    case map_constant:
-      delete a_map;
-      break;
-
-    case unknown_constant:
-    case scalar_constant:
-    case magic_colon:
-    case all_va_args:
-      break;
-    }
-}
-
 void *
 OCT_VAL_REP::operator new (size_t size)
 {
   assert (size == sizeof (OCT_VAL_REP));
 
   if (! tc_rep_newlist)
     {
       int block_size = tc_rep_newlist_grow_size * sizeof (OCT_VAL_REP);
@@ -1035,88 +432,16 @@ OCT_VAL_REP::operator new (size_t size)
 void
 OCT_VAL_REP::operator delete (void *p, size_t /* size */)
 {
   OCT_VAL_REP *tmp = (OCT_VAL_REP *) p;
   tmp->freeptr = tc_rep_newlist;
   tc_rep_newlist = tmp;
 }
 
-int
-OCT_VAL_REP::rows (void) const
-{
-  int retval = -1;
-
-  switch (type_tag)
-    {
-    case scalar_constant:
-    case complex_scalar_constant:
-      retval = 1;
-      break;
-
-    case char_matrix_constant:
-    case char_matrix_constant_str:
-      retval = char_matrix->rows ();
-      break;
-
-    case range_constant:
-      retval = (columns () > 0);
-      break;
-
-    case matrix_constant:
-      retval = matrix->rows ();
-      break;
-
-    case complex_matrix_constant:
-      retval = complex_matrix->rows ();
-      break;
-
-    default:
-      break;
-    }
-
-  return retval;
-}
-
-int
-OCT_VAL_REP::columns (void) const
-{
-  int retval = -1;
-
-  switch (type_tag)
-    {
-    case scalar_constant:
-    case complex_scalar_constant:
-      retval = 1;
-      break;
-
-    case matrix_constant:
-      retval = matrix->columns ();
-      break;
-
-    case complex_matrix_constant:
-      retval = complex_matrix->columns ();
-      break;
-
-    case char_matrix_constant:
-    case char_matrix_constant_str:
-      retval = char_matrix->columns ();
-      break;
-
-    case range_constant:
-      retval = range->nelem ();
-      break;
-
-    default:
-      break;
-    }
-
-  return retval;
-}
-
 octave_value
 OCT_VAL_REP::all (void) const
 {
   octave_value retval;
 
   if (error_state)
     return retval;
 
@@ -1127,32 +452,16 @@ OCT_VAL_REP::all (void) const
       if (error_state)
 	return retval;
 
       return tmp.all ();
     }
 
   switch (type_tag)
     {
-    case scalar_constant:
-      retval = (double) (scalar != 0.0);
-      break;
-
-    case matrix_constant:
-      retval = matrix->all ();
-      break;
-
-    case complex_scalar_constant:
-      retval = (double) (*complex_scalar != 0.0);
-      break;
-
-    case complex_matrix_constant:
-      retval = complex_matrix->all ();
-      break;
-
     default:
       gripe_wrong_type_arg ("all", *this);
       break;
     }
 
   return retval;
 }
 
@@ -1171,324 +480,102 @@ OCT_VAL_REP::any (void) const
       if (error_state)
 	return retval;
 
       return tmp.any ();
     }
 
   switch (type_tag)
     {
-    case scalar_constant:
-      retval = (double) (scalar != 0.0);
-      break;
-
-    case matrix_constant:
-      retval = matrix->any ();
-      break;
-
-    case complex_scalar_constant:
-      retval = (double) (*complex_scalar != 0.0);
-      break;
-
-    case complex_matrix_constant:
-      retval = complex_matrix->any ();
-      break;
-
     default:
       gripe_wrong_type_arg ("any", *this);
       break;
     }
 
   return retval;
 }
 
-bool
-OCT_VAL_REP::valid_as_scalar_index (void) const
-{
-  return (type_tag == magic_colon
-	  || (type_tag == scalar_constant 
-	      && ! xisnan (scalar)
-	      && NINT (scalar) == 1)
-	  || (type_tag == range_constant
-	      && range->nelem () == 1
-	      && ! xisnan (range->base ())
-	      && NINT (range->base ()) == 1));
-}
-
-bool
-OCT_VAL_REP::valid_as_zero_index (void) const
-{
-  return ((type_tag == scalar_constant
-	   && ! xisnan (scalar)
-	   && NINT (scalar) == 0)
-	  || (type_tag == matrix_constant
-	      && matrix->rows () == 0
-	      && matrix->columns () == 0)
-	  || (type_tag == range_constant
-	      && range->nelem () == 1
-	      && ! xisnan (range->base ())
-	      && NINT (range->base ()) == 0));
-}
-
-bool
-OCT_VAL_REP::is_true (void) const
-{
-  int retval = false;
-
-  if (error_state)
-    return retval;
-
-  if (! is_numeric_type ())
-    {
-      octave_value tmp = make_numeric ();
-
-      if (error_state)
-	return retval;
-
-      return tmp.is_true ();
-    }
-
-  switch (type_tag)
-    {
-    case scalar_constant:
-      retval = (scalar != 0.0);
-      break;
-
-    case matrix_constant:
-      {
-	Matrix m = (matrix->all ()) . all ();
-	retval = (m.rows () == 1
-		  && m.columns () == 1
-		  && m (0, 0) != 0.0);
-      }
-      break;
-
-    case complex_scalar_constant:
-      retval = (*complex_scalar != 0.0);
-      break;
-
-    case complex_matrix_constant:
-      {
-	Matrix m = (complex_matrix->all ()) . all ();
-	retval = (m.rows () == 1
-		  && m.columns () == 1
-		  && m (0, 0) != 0.0);
-      }
-      break;
-
-    default:
-      gripe_wrong_type_arg (0, *this);
-      break;
-    }
-
-  return retval;
-}
-
-static void
-warn_implicit_conversion (const char *from, const char *to)
-{
-  warning ("implicit conversion from %s to %s", from, to);
-}
-
 // XXX FIXME XXX -- we need a better way of handling conversions.
 
 double
 OCT_VAL_REP::double_value (bool force_string_conv) const
 {
   double retval = octave_NaN;
 
   switch (type_tag)
     {
-    case scalar_constant:
-      retval = scalar;
-      break;
-
-    case matrix_constant:
-      {
-	if (Vdo_fortran_indexing && rows () > 0 && columns () > 0)
-	  retval = (*matrix) (0, 0);
-	else
-	  gripe_invalid_conversion ("real matrix", "real scalar");
-      }
-      break;
-
-    case complex_matrix_constant:
-    case complex_scalar_constant:
-      {
-	int flag = Vok_to_lose_imaginary_part;
-
-	if (flag < 0)
-	  warn_implicit_conversion ("complex scalar", "real scalar");
-
-	if (flag)
-	  {
-	    if (type_tag == complex_scalar_constant)
-	      retval = ::real (*complex_scalar);
-	    else if (type_tag == complex_matrix_constant)
-	      {
-		if (Vdo_fortran_indexing
-		    && rows () > 0 && columns () > 0)
-		  retval = ::real ((*complex_matrix) (0, 0));
-		else
-		  gripe_invalid_conversion ("complex matrix", "real scalar");
-	      }
-	    else
-	      panic_impossible ();
-	  }
-	else
-	  gripe_invalid_conversion ("complex scalar", "real scalar");
-      }
-      break;
-
-    case char_matrix_constant:
-      {
-	int len = char_matrix->rows ();
-	if ((char_matrix->rows () == 1 && len == 1)
-	    || (len > 1 && Vdo_fortran_indexing))
-	  retval = toascii ((int) (*char_matrix) (0, 0));
-	else
-	  gripe_invalid_conversion ("char matrix", "real scalar");
-      }
-      break;
-
     case char_matrix_constant_str:
       {
 	int flag = force_string_conv;
 	if (! flag)
 	  flag = Vimplicit_str_to_num_ok;
 
 	if (flag < 0)
-	  warn_implicit_conversion ("string", "real scalar");
+	  gripe_implicit_conversion ("string", "real scalar");
 
 	int len = char_matrix->rows ();
 	if (flag
 	    && ((char_matrix->rows () == 1 && len == 1)
 		|| (len > 1 && Vdo_fortran_indexing)))
 	  retval = toascii ((int) (*char_matrix) (0, 0));
 	else
 	  gripe_invalid_conversion ("string", "real scalar");
       }
       break;
 
-    case range_constant:
-      {
-	int nel = range->nelem ();
-	if (nel == 1 || (nel > 1 && Vdo_fortran_indexing))
-	  retval = range->base ();
-	else
-	  gripe_invalid_conversion ("range", "real scalar");
-      }
-      break;
-
     default:
-      gripe_invalid_conversion (type_as_string (), "real scalar");
+      gripe_invalid_conversion (type_name (), "real scalar");
       break;
     }
 
   return retval;
 }
 
 Matrix
 OCT_VAL_REP::matrix_value (bool force_string_conv) const
 {
   Matrix retval;
 
   switch (type_tag)
     {
-    case scalar_constant:
-      retval = Matrix (1, 1, scalar);
-      break;
-
-    case matrix_constant:
-      retval = *matrix;
-      break;
-
-    case complex_scalar_constant:
-    case complex_matrix_constant:
-      {
-	int flag = Vok_to_lose_imaginary_part;
-	if (flag < 0)
-	  warn_implicit_conversion ("complex matrix", "real matrix");
-
-	if (flag)
-	  {
-	    if (type_tag == complex_scalar_constant)
-	      retval = Matrix (1, 1, ::real (*complex_scalar));
-	    else if (type_tag == complex_matrix_constant)
-	      retval = ::real (*complex_matrix);
-	    else
-	      panic_impossible ();
-	  }
-	else
-	  gripe_invalid_conversion ("complex matrix", "real matrix");
-      }
-      break;
-
     case char_matrix_constant:
       retval = Matrix (*char_matrix);
       break;
 
     case char_matrix_constant_str:
       {
 	int flag = force_string_conv;
 	if (! flag)
 	  flag = Vimplicit_str_to_num_ok;
 
 	if (flag < 0)
-	  warn_implicit_conversion ("string", "real matrix");
+	  gripe_implicit_conversion ("string", "real matrix");
 
 	if (flag)
 	  retval = Matrix (*char_matrix);
 	else
 	  gripe_invalid_conversion ("string", "real matrix");
       }
       break;
 
-    case range_constant:
-      retval = range->matrix_value ();
-      break;
-
     default:
-      gripe_invalid_conversion (type_as_string (), "real matrix");
+      gripe_invalid_conversion (type_name (), "real matrix");
       break;
     }
 
   return retval;
 }
 
 Complex
 OCT_VAL_REP::complex_value (bool force_string_conv) const
 {
   Complex retval (octave_NaN, octave_NaN);
 
   switch (type_tag)
     {
-    case complex_scalar_constant:
-      retval = *complex_scalar;
-      break;
-
-    case scalar_constant:
-      retval = scalar;
-      break;
-
-    case complex_matrix_constant:
-    case matrix_constant:
-      {
-	if (Vdo_fortran_indexing && rows () > 0 && columns () > 0)
-	  {
-	    if (type_tag == complex_matrix_constant)
-	      retval = (*complex_matrix) (0, 0);
-	    else
-	      retval = (*matrix) (0, 0);
-	  }
-	else
-	  gripe_invalid_conversion ("real matrix", "real scalar");
-      }
-      break;
-
     case char_matrix_constant:
       {
 	int len = char_matrix->cols ();
 	if ((char_matrix->rows () == 1 && len == 1)
 	    || (len > 1 && Vdo_fortran_indexing))
 	  retval = toascii ((int) (*char_matrix) (0, 0));
 	else
 	  gripe_invalid_conversion ("char matrix", "complex scalar");
@@ -1497,95 +584,65 @@ OCT_VAL_REP::complex_value (bool force_s
 
     case char_matrix_constant_str:
       {
 	int flag = force_string_conv;
 	if (! flag)
 	  flag = Vimplicit_str_to_num_ok;
 
 	if (flag < 0)
-	  warn_implicit_conversion ("string", "complex scalar");
+	  gripe_implicit_conversion ("string", "complex scalar");
 
 	int len = char_matrix->cols ();
 	if (flag
 	    && ((char_matrix->rows () == 1 && len == 1)
 		|| (len > 1 && Vdo_fortran_indexing)))
 	  retval = toascii ((int) (*char_matrix) (0, 0));
 	else
 	  gripe_invalid_conversion ("string", "complex scalar");
       }
       break;
 
-    case range_constant:
-      {
-	int nel = range->nelem ();
-	if (nel == 1 || (nel > 1 && Vdo_fortran_indexing))
-	  retval = range->base ();
-	else
-	  gripe_invalid_conversion ("range", "complex scalar");
-      }
-      break;
-
     default:
-      gripe_invalid_conversion (type_as_string (), "complex scalar");
+      gripe_invalid_conversion (type_name (), "complex scalar");
       break;
     }
 
   return retval;
 }
 
 ComplexMatrix
 OCT_VAL_REP::complex_matrix_value (bool force_string_conv) const
 {
   ComplexMatrix retval;
 
   switch (type_tag)
     {
-    case scalar_constant:
-      retval = ComplexMatrix (1, 1, Complex (scalar));
-      break;
-
-    case complex_scalar_constant:
-      retval = ComplexMatrix (1, 1, *complex_scalar);
-      break;
-
-    case matrix_constant:
-      retval = ComplexMatrix (*matrix);
-      break;
-
-    case complex_matrix_constant:
-      retval = *complex_matrix;
-      break;
-
     case char_matrix_constant:
       retval = ComplexMatrix (*char_matrix);
       break;
 
     case char_matrix_constant_str:
       {
 	int flag = force_string_conv;
 	if (! flag)
 	  flag = Vimplicit_str_to_num_ok;
 
 	if (flag < 0)
-	  warn_implicit_conversion ("string", "complex matrix");
+	  gripe_implicit_conversion ("string", "complex matrix");
 
 	if (flag)
 	  retval = ComplexMatrix (*char_matrix);
 	else
 	  gripe_invalid_conversion ("complex", "real matrix");
       }
       break;
 
-    case range_constant:
-      retval = range->matrix_value ();
-      break;
-
     default:
-      gripe_invalid_conversion (type_as_string (), "complex matrix");
+      gripe_invalid_conversion (type_name (), "complex matrix");
       break;
     }
 
   return retval;
 }
 
 // XXX FIXME XXX -- this needs to try to do some conversions...
 
@@ -1602,84 +659,55 @@ OCT_VAL_REP::char_matrix_value (bool for
     {
     case char_matrix_constant:
     case char_matrix_constant_str:
       retval = *char_matrix;
       break;
 
     default:
       if (! (rows () == 0 && columns () == 0))
-	gripe_invalid_conversion (type_as_string (), "string");
+	gripe_invalid_conversion (type_name (), "string");
       break;
     }
 
   return retval;
 }
 
 charMatrix
 OCT_VAL_REP::all_strings (void) const
 {
   if (type_tag == char_matrix_constant_str)
     return *char_matrix;
   else
     {
-      gripe_invalid_conversion (type_as_string (), "string");
+      gripe_invalid_conversion (type_name (), "string");
       return 0;
     }
 }
 
 string
 OCT_VAL_REP::string_value (void) const
 {
   string retval;
 
   if (type_tag == char_matrix_constant_str)
     retval = char_matrix->row_as_string (0);  // XXX FIXME??? XXX
   else
-    gripe_invalid_conversion (type_as_string (), "string");
+    gripe_invalid_conversion (type_name (), "string");
 
   return retval;
 }
 
-Range
-OCT_VAL_REP::range_value (void) const
-{
-  assert (type_tag == range_constant);
-  return *range;
-}
-
 Octave_map
 OCT_VAL_REP::map_value (void) const
 {
   assert (type_tag == map_constant);
   return *a_map;
 }
 
-octave_value&
-OCT_VAL_REP::lookup_map_element (const string& name, bool insert, bool silent)
-{
-  static octave_value retval;
-
-  if (type_tag == map_constant)
-    {
-      Pix idx = a_map->seek (name);
-
-      if (idx)
-	return a_map->contents (idx);
-      else if (insert)
-	return (*a_map) [name];
-      else if (! silent)
-	error ("structure has no member `%s'", name.c_str ());
-    }
-  else if (! silent)
-    error ("invalid structure access attempted");
-
-  return retval;
-}
-
 // This could be made more efficient by doing all the work here rather
 // than relying on matrix_value() to do any possible type conversions.
 
 ColumnVector
 OCT_VAL_REP::vector_value (bool force_string_conv,
 		      bool force_vector_conversion) const
 {
   ColumnVector retval;
@@ -1880,17 +908,17 @@ OCT_VAL_REP::convert_to_str (void) const
       retval = octave_value (*char_matrix, 1);
       break;
 
     case char_matrix_constant_str:
       retval = octave_value (*char_matrix, 1);
       break;
 
     default:
-      gripe_invalid_conversion (type_as_string (), "string");
+      gripe_invalid_conversion (type_name (), "string");
       break;
     }
 
   return retval;
 }
 
 void
 OCT_VAL_REP::convert_to_row_or_column_vector (void)
@@ -2097,17 +1125,17 @@ OCT_VAL_REP::force_numeric (bool force_s
 	  {
 	    type_tag = scalar_constant;
 	    scalar = range->base ();
 	  }
       }
       break;
 
     default:
-      gripe_invalid_conversion (type_as_string (), "numeric type");
+      gripe_invalid_conversion (type_name (), "numeric type");
       break;
     }
 }
 
 octave_value
 OCT_VAL_REP::make_numeric (bool force_string_conv) const
 {
   octave_value retval;
@@ -2136,17 +1164,17 @@ OCT_VAL_REP::make_numeric (bool force_st
 
     case char_matrix_constant_str:
       {
 	int flag = force_string_conv;
 	if (! flag)
 	  flag = Vimplicit_str_to_num_ok;
 
 	if (flag < 0)
-	  warn_implicit_conversion ("string", "char matrix");
+	  gripe_implicit_conversion ("string", "char matrix");
 
 	if (flag)
 	  {
 	    retval = octave_value (*char_matrix, true);
 	    retval.force_numeric (force_string_conv);
 	  }
 	else
 	  gripe_invalid_conversion ("string", "char matrix");
@@ -2154,131 +1182,24 @@ OCT_VAL_REP::make_numeric (bool force_st
       break;
 
     case range_constant:
       retval = *range;
       retval.force_numeric (force_string_conv);
       break;
 
     default:
-      gripe_invalid_conversion (type_as_string (), "numeric value");
+      gripe_invalid_conversion (type_name (), "numeric value");
       break;
     }
 
   return retval;
 }
 
 void
-OCT_VAL_REP::bump_value (tree_expression::type etype)
-{
-  switch (etype)
-    {
-    case tree_expression::increment:
-      switch (type_tag)
-	{
-	case scalar_constant:
-	  scalar++;
-	  break;
-
-	case matrix_constant:
-	  *matrix = *matrix + 1.0;
-	  break;
-
-	case complex_scalar_constant:
-	  *complex_scalar = *complex_scalar + 1.0;
-	  break;
-
-	case complex_matrix_constant:
-	  *complex_matrix = *complex_matrix + 1.0;
-	  break;
-
-	case range_constant:
-	  range->set_base (range->base () + 1.0);
-	  range->set_limit (range->limit () + 1.0);
-	  break;
-
-	default:
-	  gripe_wrong_type_arg ("operator ++", type_as_string ());
-	  break;
-	}
-      break;
-
-    case tree_expression::decrement:
-      switch (type_tag)
-	{
-	case scalar_constant:
-	  scalar--;
-	  break;
-
-	case matrix_constant:
-	  *matrix = *matrix - 1.0;
-	  break;
-
-	case range_constant:
-	  range->set_base (range->base () - 1.0);
-	  range->set_limit (range->limit () - 1.0);
-	  break;
-
-	default:
-	  gripe_wrong_type_arg ("operator --", type_as_string ());
-	  break;
-	}
-      break;
-
-    default:
-      panic_impossible ();
-      break;
-    }
-}
-
-void
-OCT_VAL_REP::resize (int i, int j)
-{
-  switch (type_tag)
-    {
-    case matrix_constant:
-      matrix->resize (i, j);
-      break;
-
-    case complex_matrix_constant:
-      complex_matrix->resize (i, j);
-      break;
-
-    default:
-      gripe_wrong_type_arg ("resize", type_as_string ());
-      break;
-    }
-}
-
-void
-OCT_VAL_REP::resize (int i, int j, double val)
-{
-  switch (type_tag)
-    {
-    case matrix_constant:
-      matrix->resize (i, j, val);
-      break;
-
-    case complex_matrix_constant:
-      complex_matrix->resize (i, j, val);
-      break;
-
-    default:
-      gripe_wrong_type_arg ("resize", type_as_string ());
-      break;
-    }
-}
-
-void
-OCT_VAL_REP::stash_original_text (const string &s)
-{
-  orig_text = s;
-}
-
-void
 OCT_VAL_REP::maybe_mutate (void)
 {
   switch (type_tag)
     {
     case complex_scalar_constant:
       if (::imag (*complex_scalar) == 0.0)
 	{
 	  double d = ::real (*complex_scalar);
@@ -2352,50 +1273,16 @@ OCT_VAL_REP::maybe_mutate (void)
 }
 
 void
 OCT_VAL_REP::print (ostream& output_buf)
 {
   if (error_state)
     return;
 
-  switch (type_tag)
-    {
-    case scalar_constant:
-      octave_print_internal (output_buf, scalar, false);
-      break;
-
-    case matrix_constant:
-      octave_print_internal (output_buf, *matrix, false,
-			     struct_indent);
-      break;
-
-    case complex_scalar_constant:
-      octave_print_internal (output_buf, *complex_scalar, false);
-      break;
-
-    case complex_matrix_constant:
-      octave_print_internal (output_buf, *complex_matrix, false,
-			     struct_indent);
-      break;
-
-    case char_matrix_constant:
-      octave_print_internal (output_buf, *char_matrix, false,
-			     struct_indent);
-      break;
-
-    case char_matrix_constant_str:
-      octave_print_internal (output_buf, *char_matrix, false, true,
-			     struct_indent);
-      break;
-
-    case range_constant:
-      octave_print_internal (output_buf, *range, false, struct_indent);
-      break;
-
     case map_constant:
       {
 	// XXX FIXME XXX -- would be nice to print the output in some
 	// standard order.  Maybe all substructures first, maybe
 	// alphabetize entries, etc.
 
 	begin_unwind_frame ("OCT_VAL_REP_print");
 
@@ -2448,325 +1335,16 @@ OCT_VAL_REP::print (ostream& output_buf)
 	    output_buf.form ("%*s%s", struct_indent, "", "}\n");
 	  }
 	else
 	  output_buf << " <structure>\n";
 
 	run_unwind_frame ("OCT_VAL_REP_print");
       }
       break;
-
-    case unknown_constant:
-    case magic_colon:
-    case all_va_args:
-      panic_impossible ();
-      break;
-    }
-}
-
-void
-OCT_VAL_REP::gripe_wrong_type_arg (const char *name,
-			      const octave_value_rep& tcr) const
-{
-  if (name)
-    ::error ("%s: wrong type argument `%s'", name, tcr.type_as_string ());
-  else
-    ::error ("wrong type argument `%s'", name, tcr.type_as_string ());
-}
-
-char *
-OCT_VAL_REP::type_as_string (void) const
-{
-  switch (type_tag)
-    {
-    case scalar_constant:
-      return "real scalar";
-
-    case matrix_constant:
-      return "real matrix";
-
-    case complex_scalar_constant:
-      return "complex scalar";
-
-    case complex_matrix_constant:
-      return "complex matrix";
-
-    case char_matrix_constant:
-      return "char matrix";
-
-    case char_matrix_constant_str:
-      return "string";
-
-    case range_constant:
-      return "range";
-
-    case map_constant:
-      return "structure";
-
-    default:
-      return "<unknown type>";
-    }
-}
-
-octave_value
-do_binary_op (octave_value& a, octave_value& b, tree_expression::type t)
-{
-  octave_value retval;
-
-  bool first_empty = (a.rows () == 0 || a.columns () == 0);
-  bool second_empty = (b.rows () == 0 || b.columns () == 0);
-
-  if (first_empty || second_empty)
-    {
-      int flag = Vpropagate_empty_matrices;
-      if (flag < 0)
-	warning ("binary operation on empty matrix");
-      else if (flag == 0)
-	{
-	  ::error ("invalid binary operation on empty matrix");
-	  return retval;
-	}
-    }
-
-  int force = (a.is_string () && b.is_string ()
-	       && (t == tree_expression::cmp_lt
-		   || t == tree_expression::cmp_le
-		   || t == tree_expression::cmp_eq
-		   || t == tree_expression::cmp_ge
-		   || t == tree_expression::cmp_gt
-		   || t == tree_expression::cmp_ne));
-
-  octave_value tmp_a = a.make_numeric (force);
-
-  if (error_state)
-    return retval;
-
-  octave_value tmp_b = b.make_numeric (force);
-
-  if (error_state)
-    return retval;
-
-  OCT_VAL_REP::constant_type a_type = tmp_a.const_type ();
-  OCT_VAL_REP::constant_type b_type = tmp_b.const_type ();
-
-  double d1, d2;
-  Matrix m1, m2;
-  Complex c1, c2;
-  ComplexMatrix cm1, cm2;
-
-  switch (a_type)
-    {
-    case OCT_VAL_REP::scalar_constant:
-
-      d1 = tmp_a.double_value ();
-
-      switch (b_type)
-	{
-	case OCT_VAL_REP::scalar_constant:
-	  d2 = tmp_b.double_value ();
-	  retval = do_binary_op (d1, d2, t);
-	  break;
-
-	case OCT_VAL_REP::matrix_constant:
-	case OCT_VAL_REP::char_matrix_constant:
-	  m2 = tmp_b.matrix_value ();
-	  retval = do_binary_op (d1, m2, t);
-	  break;
-
-	case OCT_VAL_REP::complex_scalar_constant:
-	  c2 = tmp_b.complex_value ();
-	  retval = do_binary_op (d1, c2, t);
-	  break;
-
-	case OCT_VAL_REP::complex_matrix_constant:
-	  cm2 = tmp_b.complex_matrix_value ();
-	  retval = do_binary_op (d1, cm2, t);
-	  break;
-
-	default:
-	  gripe_wrong_type_arg_for_binary_op (tmp_b);
-	  break;
-	}
-      break;
-
-    case OCT_VAL_REP::matrix_constant:
-    case OCT_VAL_REP::char_matrix_constant:
-
-      m1 = tmp_a.matrix_value ();
-
-      switch (b_type)
-	{
-	case OCT_VAL_REP::scalar_constant:
-	  d2 = tmp_b.double_value ();
-	  retval = do_binary_op (m1, d2, t);
-	  break;
-
-	case OCT_VAL_REP::matrix_constant:
-	case OCT_VAL_REP::char_matrix_constant:
-	  m2 = tmp_b.matrix_value ();
-	  retval = do_binary_op (m1, m2, t);
-	  break;
-
-	case OCT_VAL_REP::complex_scalar_constant:
-	  c2 = tmp_b.complex_value ();
-	  retval = do_binary_op (m1, c2, t);
-	  break;
-
-	case OCT_VAL_REP::complex_matrix_constant:
-	  cm2 = tmp_b.complex_matrix_value ();
-	  retval = do_binary_op (m1, cm2, t);
-	  break;
-
-	default:
-	  gripe_wrong_type_arg_for_binary_op (tmp_b);
-	  break;
-	}
-      break;
-
-    case OCT_VAL_REP::complex_scalar_constant:
-
-      c1 = tmp_a.complex_value ();
-
-      switch (b_type)
-	{
-	case OCT_VAL_REP::scalar_constant:
-	  d2 = tmp_b.double_value ();
-	  retval = do_binary_op (c1, d2, t);
-	  break;
-
-	case OCT_VAL_REP::matrix_constant:
-	case OCT_VAL_REP::char_matrix_constant:
-	  m2 = tmp_b.matrix_value ();
-	  retval = do_binary_op (c1, m2, t);
-	  break;
-
-	case OCT_VAL_REP::complex_scalar_constant:
-	  c2 = tmp_b.complex_value ();
-	  retval = do_binary_op (c1, c2, t);
-	  break;
-
-	case OCT_VAL_REP::complex_matrix_constant:
-	  cm2 = tmp_b.complex_matrix_value ();
-	  retval = do_binary_op (c1, cm2, t);
-	  break;
-
-	default:
-	  gripe_wrong_type_arg_for_binary_op (tmp_b);
-	  break;
-	}
-      break;
-
-    case OCT_VAL_REP::complex_matrix_constant:
-
-      cm1 = tmp_a.complex_matrix_value ();
-
-      switch (b_type)
-	{
-	case OCT_VAL_REP::scalar_constant:
-	  d2 = tmp_b.double_value ();
-	  retval = do_binary_op (cm1, d2, t);
-	  break;
-
-	case OCT_VAL_REP::matrix_constant:
-	case OCT_VAL_REP::char_matrix_constant:
-	  m2 = tmp_b.matrix_value ();
-	  retval = do_binary_op (cm1, m2, t);
-	  break;
-
-	case OCT_VAL_REP::complex_scalar_constant:
-	  c2 = tmp_b.complex_value ();
-	  retval = do_binary_op (cm1, c2, t);
-	  break;
-
-	case OCT_VAL_REP::complex_matrix_constant:
-	  cm2 = tmp_b.complex_matrix_value ();
-	  retval = do_binary_op (cm1, cm2, t);
-	  break;
-
-	default:
-	  gripe_wrong_type_arg_for_binary_op (tmp_b);
-	  break;
-	}
-      break;
-
-    default:
-      gripe_wrong_type_arg_for_binary_op (tmp_a);
-      break;
-    }
-
-  return retval;
-}
-
-octave_value
-do_unary_op (octave_value& a, tree_expression::type t)
-{
-  octave_value retval;
-
-  if (a.rows () == 0 || a.columns () == 0)
-    {
-      int flag = Vpropagate_empty_matrices;
-      if (flag < 0)
-	warning ("unary operation on empty matrix");
-      else if (flag == 0)
-	{
-	  ::error ("invalid unary operation on empty matrix");
-	  return retval;
-	}
-    }
-
-  // XXX FIXME XXX -- it is very unlikely that this is the correct
-  // place for this special case...
-
-  if (a.const_type () == OCT_VAL_REP::char_matrix_constant_str
-      && (t == tree_expression::transpose
-	  || t == tree_expression::hermitian))
-    {
-      charMatrix chm = a.all_strings ();
-
-      if (! error_state)
-	retval = octave_value (chm.transpose (), true);
-    }
-  else
-    {
-      octave_value tmp_a = a.make_numeric ();
-
-      if (error_state)
-	return retval;
-
-      switch (tmp_a.const_type ())
-	{
-	case OCT_VAL_REP::scalar_constant:
-	  retval = do_unary_op (tmp_a.double_value (), t);
-	  break;
-
-	case OCT_VAL_REP::matrix_constant:
-	  {
-	    Matrix m = tmp_a.matrix_value ();
-	    retval = do_unary_op (m, t);
-	  }
-	  break;
-
-	case OCT_VAL_REP::complex_scalar_constant:
-	  retval = do_unary_op (tmp_a.complex_value (), t);
-	  break;
-
-	case OCT_VAL_REP::complex_matrix_constant:
-	  {
-	    ComplexMatrix m = tmp_a.complex_matrix_value ();
-	    retval = do_unary_op (m, t);
-	  }
-	  break;
-
-	default:
-	  gripe_wrong_type_arg_for_unary_op (tmp_a);
-	  break;
-	}
-    }
-
-  return retval;
 }
 
 // Indexing operations for the tree-constant representation class.
 
 void
 OCT_VAL_REP::clear_index (void)
 {
   switch (type_tag)
@@ -2940,17 +1518,17 @@ OCT_VAL_REP::set_index (const octave_val
 
     case matrix_constant:
     case complex_matrix_constant:
     case char_matrix_constant:
     case char_matrix_constant_str:
       break;
 
     default:
-      ::error ("indexing %s type not implemented", type_as_string ());
+      ::error ("indexing %s type not implemented", type_name ());
       break;
     }
 
   if (! error_state)
     {
       int n = args.length ();
 
       for (int i = 0; i < n; i++)
@@ -3053,17 +1631,17 @@ OCT_VAL_REP::do_index (const octave_valu
 		if (tmp.rows () == 0 && tmp.columns () == 0)
 		  tmp.resize (1, 0);
 
 		retval = octave_value (tmp, 1);
 	      }
 	      break;
 
 	    default:
-	      error ("can't index %s variables", type_as_string ());
+	      error ("can't index %s variables", type_name ());
 	      break;
 	    }
 
 	  // We may have converted this value from a scalar to a
 	  // matrix to allow indexing to work.
 
 	  if (! error_state)
 	    maybe_mutate ();
@@ -3265,155 +1843,15 @@ OCT_VAL_REP::assign (octave_value& rhs, 
 
   // Do the right thing for assignments like `x(1) = pi' when x is
   // undefined before the assignment.
 
   if (is_matrix_type () || is_range ())
     maybe_mutate ();
 }
 
-bool
-OCT_VAL_REP::print_as_scalar (void)
-{
-  int nr = rows ();
-  int nc = columns ();
-
-  return (is_scalar_type ()
-	  || (is_string () && nr <= 1)
-	  || (is_matrix_type ()
-	      && ((nr == 1 && nc == 1)
-		  || nr == 0
-		  || nc == 0)));
-}
-
-bool
-OCT_VAL_REP::print_as_structure (void)
-{
-  return is_map ();
-}
-
-static int
-do_fortran_indexing (void)
-{
-  Vdo_fortran_indexing = check_preference ("do_fortran_indexing");
-
-  liboctave_dfi_flag = Vdo_fortran_indexing;
-
-  return 0;
-}
-
-static int
-implicit_str_to_num_ok (void)
-{
-  Vimplicit_str_to_num_ok = check_preference ("implicit_str_to_num_ok");
-
-  return 0;
-}
-
-static int
-ok_to_lose_imaginary_part (void)
-{
-  Vok_to_lose_imaginary_part = check_preference ("ok_to_lose_imaginary_part");
-
-  return 0;
-}
-
-static int
-prefer_column_vectors (void)
-{
-  Vprefer_column_vectors
-    = check_preference ("prefer_column_vectors");
-
-  liboctave_pcv_flag = Vprefer_column_vectors;
-
-  return 0;
-}
-
-static int
-prefer_zero_one_indexing (void)
-{
-  Vprefer_zero_one_indexing = check_preference ("prefer_zero_one_indexing");
-
-  liboctave_pzo_flag = Vprefer_zero_one_indexing;
-
-  return 0;
-}
-
-static int
-print_answer_id_name (void)
-{
-  Vprint_answer_id_name = check_preference ("print_answer_id_name");
-
-  return 0;
-}
-
-static int
-propagate_empty_matrices (void)
-{
-  Vpropagate_empty_matrices = check_preference ("propagate_empty_matrices");
-
-  return 0;
-}
-
-static int
-resize_on_range_error (void)
-{
-  Vresize_on_range_error = check_preference ("resize_on_range_error");
-
-  liboctave_rre_flag = Vresize_on_range_error;
-
-  return 0;
-}
-
-static int
-struct_levels_to_print (void)
-{
-  double val;
-  if (builtin_real_scalar_variable ("struct_levels_to_print", val)
-      && ! xisnan (val))
-    {
-      int ival = NINT (val);
-      if (ival >= 0 && (double) ival == val)
-	{
-	  Vstruct_levels_to_print = ival;
-	  return 0;
-	}
-    }
-  gripe_invalid_value_specified ("struct_levels_to_print");
-  return -1;
-}
-
-void
-symbols_of_pt_const (void)
-{
-  DEFVAR (do_fortran_indexing, 0.0, 0, do_fortran_indexing,
-    "allow single indices for matrices");
-
-  DEFVAR (implicit_str_to_num_ok, 0.0, 0, implicit_str_to_num_ok,
-    "allow implicit string to number conversion");
-
-  DEFVAR (ok_to_lose_imaginary_part, "warn", 0, ok_to_lose_imaginary_part,
-    "silently convert from complex to real by dropping imaginary part");
-
-  DEFVAR (prefer_column_vectors, 1.0, 0, prefer_column_vectors,
-    "prefer column/row vectors");
-
-  DEFVAR (prefer_zero_one_indexing, 0.0, 0, prefer_zero_one_indexing,
-    "when there is a conflict, prefer zero-one style indexing");
-
-  DEFVAR (print_answer_id_name, 1.0, 0, print_answer_id_name,
-    "set output style to print `var_name = ...'");
-
-  DEFVAR (propagate_empty_matrices, 1.0, 0, propagate_empty_matrices,
-    "operations on empty matrices return an empty matrix, not an error");
-
-  DEFVAR (resize_on_range_error, 1.0, 0, resize_on_range_error,
-    "enlarge matrices on assignment");
-
-  DEFVAR (struct_levels_to_print, 2.0, 0, struct_levels_to_print,
-    "number of levels of structure elements to print");
-}
+#endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -22,314 +22,36 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_tree_const_h)
 #define octave_tree_const_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
-#include <cstdlib>
-
 #include <string>
 
 class ostream;
 
 #include "Range.h"
 #include "mx-base.h"
 #include "str-vec.h"
 
 #include "pt-fvc.h"
 
 class Octave_map;
 class octave_value_list;
 
 class tree_walker;
 
-// Constants.
+#include "ov.h"
 
 class
-octave_value : public tree_fvc
+tree_constant : public tree_fvc
 {
-private:
-
-// The actual representation of the octave_value.
-
-  class
-  octave_value_rep
-  {
-  public:
-
-    enum constant_type
-      {
-	unknown_constant,
-	scalar_constant,
-	matrix_constant,
-	complex_scalar_constant,
-	complex_matrix_constant,
-	char_matrix_constant,
-	char_matrix_constant_str,
-	range_constant,
-	map_constant,
-	magic_colon,
-	all_va_args,
-      };
-
-    enum force_orient
-      {
-	no_orient,
-	row_orient,
-	column_orient,
-      };
-
-    octave_value_rep (void);
-
-    octave_value_rep (double d);
-    octave_value_rep (const Matrix& m);
-    octave_value_rep (const DiagMatrix& d);
-    octave_value_rep (const RowVector& v, int pcv);
-    octave_value_rep (const ColumnVector& v, int pcv);
-
-    octave_value_rep (const Complex& c);
-    octave_value_rep (const ComplexMatrix& m);
-    octave_value_rep (const ComplexDiagMatrix& d);
-    octave_value_rep (const ComplexRowVector& v, int pcv);
-    octave_value_rep (const ComplexColumnVector& v, int pcv);
-
-    octave_value_rep (const char *s);
-    octave_value_rep (const string& s);
-    octave_value_rep (const string_vector& s);
-    octave_value_rep (const charMatrix& chm, bool is_string);
-
-    octave_value_rep (double base, double limit, double inc);
-    octave_value_rep (const Range& r);
-
-    octave_value_rep (const Octave_map& m);
-
-    octave_value_rep (octave_value_rep::constant_type t);
-
-    octave_value_rep (const octave_value_rep& t);
-
-    ~octave_value_rep (void);
-
-    void *operator new (size_t size);
-    void operator delete (void *p, size_t size);
-
-    int rows (void) const;
-    int columns (void) const;
-
-    bool is_defined (void) const
-      { return type_tag != unknown_constant; }
-
-    bool is_undefined (void) const
-      { return type_tag == unknown_constant; }
-
-    bool is_unknown (void) const
-      { return type_tag == unknown_constant; }
-
-    bool is_real_scalar (void) const
-      { return type_tag == scalar_constant; }
-
-    bool is_real_matrix (void) const
-      { return type_tag == matrix_constant; }
-
-    bool is_complex_scalar (void) const
-      { return type_tag == complex_scalar_constant; }
-
-    bool is_complex_matrix (void) const
-      { return type_tag == complex_matrix_constant; }
-
-    bool is_char_matrix (void) const
-      { return type_tag == char_matrix_constant; }
-
-    bool is_string (void) const
-      { return type_tag == char_matrix_constant_str; }
-
-    bool is_range (void) const
-      { return type_tag == range_constant; }
-
-    bool is_map (void) const
-      { return type_tag == map_constant; }
-
-    bool is_magic_colon (void) const
-      { return type_tag == magic_colon; }
-
-    bool is_all_va_args (void) const
-      { return type_tag == all_va_args; }
-
-    octave_value all (void) const;
-    octave_value any (void) const;
-
-    bool is_real_type (void) const
-      {
-	return (type_tag == scalar_constant
-		|| type_tag == matrix_constant
-		|| type_tag == range_constant
-		|| type_tag == char_matrix_constant
-		|| type_tag == char_matrix_constant_str);
-      }
-
-    bool is_complex_type (void) const
-      {
-	return (type_tag == complex_matrix_constant
-		|| type_tag == complex_scalar_constant);
-      }
-
-    // Would be nice to get rid of the next four functions:
-
-    bool is_scalar_type (void) const
-      {
-	return (type_tag == scalar_constant
-		|| type_tag == complex_scalar_constant);
-      }
-
-    bool is_matrix_type (void) const
-      {
-	return (type_tag == matrix_constant
-		|| type_tag == complex_matrix_constant);
-      }
-
-    bool is_numeric_type (void) const
-      {
-	return (type_tag == scalar_constant
-		|| type_tag == matrix_constant
-		|| type_tag == complex_matrix_constant
-		|| type_tag == complex_scalar_constant);
-      }
-
-    bool valid_as_scalar_index (void) const;
-    bool valid_as_zero_index (void) const;
-
-    bool is_true (void) const;
-
-    bool is_empty (void) const
-      {
-	return ((! (is_magic_colon ()
-		    || is_all_va_args ()
-		    || is_unknown ()))
-		&& (rows () == 0
-		    || columns () == 0));
-      }
-
-    double double_value (bool frc_str_conv = false) const;
-    Matrix matrix_value (bool frc_str_conv = false) const;
-    Complex complex_value (bool frc_str_conv = false) const;
-    ComplexMatrix complex_matrix_value (bool frc_str_conv = false) const;
-    charMatrix char_matrix_value (bool frc_str_conv = false) const;
-    charMatrix all_strings (void) const;
-    string string_value (void) const;
-    Range range_value (void) const;
-    Octave_map map_value (void) const;
-
-    octave_value& lookup_map_element (const string& name,
-				       bool insert = false,
-				       bool silent = false);
-
-    ColumnVector vector_value (bool frc_str_conv = false,
-			       bool frc_vec_conv = false) const;
-
-    ComplexColumnVector
-    complex_vector_value (bool frc_str_conv = false,
-			  bool frc_vec_conv = false) const;
-
-    octave_value convert_to_str (void) const;
-
-    void convert_to_row_or_column_vector (void);
-
-    void bump_value (tree_expression::type);
-
-    void resize (int i, int j);
-    void resize (int i, int j, double val);
-
-    void stash_original_text (const string& s);
-
-    string original_text (void) { return orig_text; }
-
-    void maybe_mutate (void);
-
-    void print (void);
-    void print (ostream& os);
-
-    void gripe_wrong_type_arg (const char *name,
-			       const octave_value_rep& tcr) const;
-
-    char *type_as_string (void) const;
-
-    // Binary and unary operations.
-
-    friend octave_value do_binary_op (octave_value& a, octave_value& b,
-				      tree_expression::type t);
-
-    friend octave_value do_unary_op (octave_value& a,
-				     tree_expression::type t);
-
-    // We want to eliminate this.
-
-    constant_type const_type (void) const { return type_tag; }
-
-    // We want to get rid of these too:
-
-    void force_numeric (bool frc_str_conv = false);
-    octave_value make_numeric (bool frc_str_conv = false) const;
-
-    // But not this.
-
-    void convert_to_matrix_type (bool make_complex);
-
-    // Indexing and assignment.
-
-    void clear_index (void);
-
-    // void set_index (double d);
-    void set_index (const Range& r);
-    void set_index (const ColumnVector& v);
-    void set_index (const Matrix& m);
-    void set_index (char c);
-
-    void set_index (const octave_value_list& args,
-		    bool rhs_is_complex = false);
-
-    octave_value do_index (const octave_value_list& args);
-
-    void maybe_widen (constant_type t);
-
-    void assign (octave_value& rhs, const octave_value_list& args);
-
-    bool print_as_scalar (void);
-
-    bool print_as_structure (void);
-
-    // Data.
-
-    union
-      {
-	double scalar;			// A real scalar constant.
-	Matrix *matrix;			// A real matrix constant.
-	Complex *complex_scalar;	// A real scalar constant.
-	ComplexMatrix *complex_matrix;	// A real matrix constant.
-	charMatrix *char_matrix;	// A character string constant.
-	Range *range;			// A set of evenly spaced values.
-	Octave_map *a_map;		// An associative array.
-
-	octave_value_rep *freeptr;	// For custom memory management.
-      };
-
-    constant_type type_tag;
-
-    int count;
-
-    string orig_text;
-  };
-
-  union
-    {
-      octave_value *freeptr;  // For custom memory management.
-      octave_value_rep *rep;  // The real representation.
-    };
-
 public:
 
   enum magic_colon { magic_colon_t };
   enum all_va_args { all_va_args_t };
 
   // Constructors.  It is possible to create the following types of
   // constants:
   //
@@ -348,361 +70,334 @@ public:
   //                  ComplexColumnVector
   // char matrix      charMatrix
   // string           char* (null terminated)
   //                  string
   //                  charMatrix
   // range            double, double, double
   //                  Range
   // map              Octave_map
-  // magic colon      octave_value::magic_colon
-  // all_va_args      octave_value::all_va_args
+  // magic colon      tree_constant::magic_colon
+  // all_va_args      tree_constant::all_va_args
 
-  octave_value (void) : tree_fvc ()
-    { rep = new octave_value_rep (); rep->count = 1; }
+  tree_constant (void)
+    : tree_fvc (), val (), orig_text () { }
+
+  tree_constant (double d, int l = -1, int c = -1)
+    : tree_fvc (l, c), val (d), orig_text () { }
 
-  octave_value (double d, int l = -1, int c = -1) : tree_fvc (l, c)
-    { rep = new octave_value_rep (d); rep->count = 1; }
+  tree_constant (const Matrix& m)
+    : tree_fvc (), val (m), orig_text () { }
 
-  octave_value (const Matrix& m) : tree_fvc ()
-    { rep = new octave_value_rep (m); rep->count = 1; }
+  tree_constant (const DiagMatrix& d)
+    : tree_fvc (), val (d), orig_text () { }
 
-  octave_value (const DiagMatrix& d) : tree_fvc ()
-    { rep = new octave_value_rep (d); rep->count = 1; }
+  tree_constant (const RowVector& v, int pcv = -1)
+    : tree_fvc (), val (v, pcv), orig_text () { }
 
-  octave_value (const RowVector& v, int pcv = -1) : tree_fvc ()
-    { rep = new octave_value_rep (v, pcv); rep->count = 1; }
+  tree_constant (const ColumnVector& v, int pcv = -1)
+    : tree_fvc (), val (v, pcv), orig_text () { }
 
-  octave_value (const ColumnVector& v, int pcv = -1) : tree_fvc ()
-    { rep = new octave_value_rep (v, pcv); rep->count = 1; }
+  tree_constant (const Complex& C, int l = -1, int c = -1)
+    : tree_fvc (l, c), val (C), orig_text () { }
+
+  tree_constant (const ComplexMatrix& m)
+    : tree_fvc (), val (m), orig_text () { }
 
-  octave_value (const Complex& C, int l = -1, int c = -1) : tree_fvc (l, c)
-    { rep = new octave_value_rep (C); rep->count = 1; }
+  tree_constant (const ComplexDiagMatrix& d)
+    : tree_fvc (), val (d), orig_text () { }
+
+  tree_constant (const ComplexRowVector& v, int pcv = -1)
+    : tree_fvc (), val (v, pcv), orig_text () { }
 
-  octave_value (const ComplexMatrix& m) : tree_fvc ()
-    { rep = new octave_value_rep (m); rep->count = 1; }
+  tree_constant (const ComplexColumnVector& v, int pcv = -1)
+    : tree_fvc (), val (v, pcv), orig_text () { }
 
-  octave_value (const ComplexDiagMatrix& d) : tree_fvc ()
-    { rep = new octave_value_rep (d); rep->count = 1; }
+  tree_constant (const char *s, int l = -1, int c = -1)
+    : tree_fvc (l, c), val (s), orig_text () { }
 
-  octave_value (const ComplexRowVector& v, int pcv = -1) : tree_fvc ()
-    { rep = new octave_value_rep (v, pcv); rep->count = 1; }
+  tree_constant (const string& s, int l = -1, int c = -1)
+    : tree_fvc (l, c), val (s), orig_text () { }
 
-  octave_value (const ComplexColumnVector& v, int pcv = -1) : tree_fvc () 
-    { rep = new octave_value_rep (v, pcv); rep->count = 1; }
+  tree_constant (const string_vector& s, int l = -1, int c = -1)
+    : tree_fvc (l, c), val (s), orig_text () { }
+
+  tree_constant (const charMatrix& chm, bool is_string = false)
+    : tree_fvc (), val (chm, is_string), orig_text () { }
 
-  octave_value (const char *s, int l = -1, int c = -1) : tree_fvc (l, c)
-    { rep = new octave_value_rep (s); rep->count = 1; }
+  tree_constant (double base, double limit, double inc)
+    : tree_fvc (), val (base, limit, inc), orig_text () { }
 
-  octave_value (const string& s, int l = -1, int c = -1) : tree_fvc (l, c)
-    { rep = new octave_value_rep (s); rep->count = 1; }
+  tree_constant (const Range& r)
+    : tree_fvc (), val (r), orig_text () { }
 
-  octave_value (const string_vector& s, int l = -1, int c = -1)
-    : tree_fvc (l, c)
-    { rep = new octave_value_rep (s); rep->count = 1; }
+  tree_constant (const Octave_map& m)
+    : tree_fvc (), val (m), orig_text () { }
 
-  octave_value (const charMatrix& chm, bool is_string = false) : tree_fvc ()
-    { rep = new octave_value_rep (chm, is_string); rep->count = 1; }
+  tree_constant (tree_constant::magic_colon, int l = -1, int c = -1)
+    : tree_fvc (l, c), val (octave_value::magic_colon_t), orig_text () { }
 
-  octave_value (double base, double limit, double inc) : tree_fvc ()
-    { rep = new octave_value_rep (base, limit, inc); rep->count = 1; }
+  tree_constant (tree_constant::all_va_args, int l = -1, int c = -1)
+    : tree_fvc (l, c), val (octave_value::all_va_args_t), orig_text () { }
 
-  octave_value (const Range& r) : tree_fvc ()
-    { rep = new octave_value_rep (r); rep->count = 1; }
+  tree_constant (const octave_value& v, int l = -1, int c = -1)
+    : tree_fvc (l, c), val (v), orig_text () { }
 
-  octave_value (const Octave_map& m) : tree_fvc ()
-    { rep = new octave_value_rep (m); rep->count = 1; }
+  tree_constant (const tree_constant& a)
+    : tree_fvc (a), val (a.val), orig_text () { }
 
-  octave_value (octave_value::magic_colon) : tree_fvc ()
+  ~tree_constant (void) { }
+
+  tree_constant& operator = (const tree_constant& a)
     {
-      octave_value_rep::constant_type tmp;
-      tmp = octave_value_rep::magic_colon;
-      rep = new octave_value_rep (tmp);
-      rep->count = 1;
+      if (this != &a)
+	{
+	  tree_fvc::operator = (a);
+	  val = a.val;
+	}
+      return *this;
     }
 
-  octave_value (octave_value::all_va_args) : tree_fvc ()
-    {
-      octave_value_rep::constant_type tmp;
-      tmp = octave_value_rep::all_va_args;
-      rep = new octave_value_rep (tmp);
-      rep->count = 1;
-    }
-
-  // Copy constructor.
-
-  octave_value (const octave_value& a) : tree_fvc ()
-    { rep = a.rep; rep->count++; }
-
-  // Delete the representation of this constant if the count drops to
-  // zero.
-
-  ~octave_value (void);
-
+#if 0
   void *operator new (size_t size);
   void operator delete (void *p, size_t size);
-
-  // Simple assignment.
-
-  octave_value operator = (const octave_value& a);
+#endif
 
   // Indexed assignment.
 
-  octave_value assign (octave_value& rhs, const octave_value_list& args)
+  octave_value index (const octave_value_list& idx) const
+    { return val.index (idx); }
+
+  octave_value& reference (void)
     {
-      if (rep->count > 1)
-	{
-	  --rep->count;
-	  rep = new octave_value_rep (*rep);
-	  rep->count = 1;
-	}
-
-      rep->assign (rhs, args);
-
-      return *this;
+      val.make_unique ();
+      return val;
     }
 
+  octave_value value (void) const
+    {
+      return val;
+    }
+
+  octave_value assign (const octave_value_list& idx, const octave_value& rhs)
+    {
+      val.assign (idx, rhs);
+      return val;
+    }
+
+#if 0
   // Simple structure assignment.
 
   octave_value assign_map_element (SLList<string>& list,
-				    octave_value& rhs);
+				   const octave_value& rhs);
 
   // Indexed structure assignment.
 
   octave_value assign_map_element (SLList<string>& list,
-				    octave_value& rhs,
-				    const octave_value_list& args);
+				   const octave_value_list& args,
+				   const octave_value& rhs);
+#endif
 
   // Type.  It would be nice to eliminate the need for this.
 
   bool is_constant (void) const { return true; }
 
   // Size.
 
-  int rows (void) const { return rep->rows (); }
-  int columns (void) const { return rep->columns (); }
+  int rows (void) const { return val.rows (); }
+  int columns (void) const { return val.columns (); }
 
   // Does this constant have a type?  Both of these are provided since
   // it is sometimes more natural to write is_undefined() instead of
   // ! is_defined().
 
-  bool is_defined (void) const { return rep->is_defined (); }
-  bool is_undefined (void) const { return rep->is_undefined (); }
+  bool is_defined (void) const { return val.is_defined (); }
+  bool is_undefined (void) const { return val.is_undefined (); }
 
   // Is this constant a particular type, or does it belong to a
   // particular class of types?
 
-  bool is_unknown (void) const { return rep->is_unknown (); }
-  bool is_real_scalar (void) const { return rep->is_real_scalar (); }
-  bool is_real_matrix (void) const { return rep->is_real_matrix (); }
-  bool is_complex_scalar (void) const { return rep->is_complex_scalar (); }
-  bool is_complex_matrix (void) const { return rep->is_complex_matrix (); }
-  bool is_char_matrix (void) const { return rep->is_char_matrix (); }
-  bool is_string (void) const { return rep->is_string (); }
-  bool is_range (void) const { return rep->is_range (); }
-  bool is_map (void) const { return rep->is_map (); }
-  bool is_magic_colon (void) const { return rep->is_magic_colon (); }
-  bool is_all_va_args (void) const { return rep->is_all_va_args (); }
+  bool is_real_scalar (void) const { return val.is_real_scalar (); }
+  bool is_real_matrix (void) const { return val.is_real_matrix (); }
+  bool is_complex_scalar (void) const { return val.is_complex_scalar (); }
+  bool is_complex_matrix (void) const { return val.is_complex_matrix (); }
+  bool is_char_matrix (void) const { return val.is_char_matrix (); }
+  bool is_string (void) const { return val.is_string (); }
+  bool is_range (void) const { return val.is_range (); }
+  bool is_map (void) const { return val.is_map (); }
+  bool is_magic_colon (void) const { return val.is_magic_colon (); }
+  bool is_all_va_args (void) const { return val.is_all_va_args (); }
 
   // Are any or all of the elements in this constant nonzero?
 
-  octave_value all (void) const { return rep->all (); }
-  octave_value any (void) const { return rep->any (); }
+  octave_value all (void) const { return val.all (); }
+  octave_value any (void) const { return val.any (); }
 
   // Other type stuff.
 
-  bool is_real_type (void) const { return rep->is_real_type (); }
+  bool is_real_type (void) const { return val.is_real_type (); }
 
-  bool is_complex_type (void) const { return rep->is_complex_type (); }
+  bool is_complex_type (void) const { return val.is_complex_type (); }
 
-  bool is_scalar_type (void) const { return rep->is_scalar_type (); }
-  bool is_matrix_type (void) const { return rep->is_matrix_type (); }
+  bool is_scalar_type (void) const { return val.is_scalar_type (); }
+  bool is_matrix_type (void) const { return val.is_matrix_type (); }
 
   bool is_numeric_type (void) const
-    { return rep->is_numeric_type (); }
+    { return val.is_numeric_type (); }
 
   bool valid_as_scalar_index (void) const
-    { return rep->valid_as_scalar_index (); }
+    { return val.valid_as_scalar_index (); }
 
   bool valid_as_zero_index (void) const
-    { return rep->valid_as_zero_index (); }
+    { return val.valid_as_zero_index (); }
 
   // Does this constant correspond to a truth value?
 
-  bool is_true (void) const { return rep->is_true (); }
+  bool is_true (void) const { return val.is_true (); }
 
   // Is at least one of the dimensions of this constant zero?
 
   bool is_empty (void) const
-    { return rep->is_empty (); }
+    { return val.is_empty (); }
 
   // Are the dimensions of this constant zero by zero?
 
   bool is_zero_by_zero (void) const
-    {
-      return ((! (is_magic_colon () || is_all_va_args () || is_unknown ()))
-	      && rows () == 0 && columns () == 0);
-    } 
+    { return val.is_zero_by_zero (); }
 
   // Values.
 
   double double_value (bool frc_str_conv = false) const
-    { return rep->double_value (frc_str_conv); }
+    { return val.double_value (frc_str_conv); }
 
   Matrix matrix_value (bool frc_str_conv = false) const
-    { return rep->matrix_value (frc_str_conv); }
+    { return val.matrix_value (frc_str_conv); }
 
   Complex complex_value (bool frc_str_conv = false) const
-    { return rep->complex_value (frc_str_conv); }
+    { return val.complex_value (frc_str_conv); }
 
   ComplexMatrix complex_matrix_value (bool frc_str_conv = false) const
-    { return rep->complex_matrix_value (frc_str_conv); }
+    { return val.complex_matrix_value (frc_str_conv); }
 
   charMatrix char_matrix_value (bool frc_str_conv = false) const
-    { return rep->char_matrix_value (frc_str_conv); }
+    { return val.char_matrix_value (frc_str_conv); }
 
   charMatrix all_strings (void) const
-    { return rep->all_strings (); }
+    { return val.all_strings (); }
 
   string string_value (void) const
-    { return rep->string_value (); }
+    { return val.string_value (); }
 
   Range range_value (void) const
-    { return rep->range_value (); }
+    { return val.range_value (); }
 
   Octave_map map_value (void) const;
 
   octave_value lookup_map_element (const string& ref,
 				    bool insert = false,
 				    bool silent = false);
 
   octave_value lookup_map_element (SLList<string>& list,
 				    bool insert = false,
 				    bool silent = false);
 
   ColumnVector vector_value (bool /* frc_str_conv */ = false,
 			     bool /* frc_vec_conv */ = false) const 
-    { return rep->vector_value (); }
+    { return val.vector_value (); }
 
   ComplexColumnVector
   complex_vector_value (bool /* frc_str_conv */ = false,
 			bool /* frc_vec_conv */ = false) const
-    { return rep->complex_vector_value (); }
+    { return val.complex_vector_value (); }
 
   // Binary and unary operations.
 
   friend octave_value do_binary_op (octave_value& a, octave_value& b,
-				     tree_expression::type t);
+				    tree_expression::type t);
 
   friend octave_value do_unary_op (octave_value& a,
-				    tree_expression::type t);
+				   tree_expression::type t);
 
   // Conversions.  These should probably be private.  If a user of this
   // class wants a certain kind of constant, he should simply ask for
   // it, and we should convert it if possible.
 
   octave_value convert_to_str (void) const
-    { return rep->convert_to_str (); }
+    { return val.convert_to_str (); }
 
   void convert_to_row_or_column_vector (void)
-    { rep->convert_to_row_or_column_vector (); }
+    { val.convert_to_row_or_column_vector (); }
 
   // Increment or decrement this constant.
 
-  void bump_value (tree_expression::type et)
-    {
-      if (rep->count > 1)
-	{
-	  --rep->count;
-	  rep = new octave_value_rep (*rep);
-	  rep->count = 1;
-	}
+  void increment (void) { val.increment (); }
 
-      rep->bump_value (et);
-    }
+  void decrement (void) { val.decrement (); }
 
   void print (void);
-  void print (ostream& os) { rep->print (os); }
+  void print (ostream& os) { val.print (os); }
 
   void print_with_name (const string& name, bool print_padding = true);
   void print_with_name (ostream& os, const string& name,
 			bool print_padding = true);
 
-  // Evaluate this constant, possibly converting complex to real, or
-  // matrix to scalar, etc.
-
-  octave_value eval (bool print_result)
-    {
-      if (print_result)
-	{
-	  rep->maybe_mutate ();  // XXX FIXME XXX -- is this necessary?
-	  print ();
-	}
-
-      return *this;
-    }
+  octave_value eval (bool print_result);
 
   octave_value_list eval (bool, int, const octave_value_list&);
 
   // Store the original text corresponding to this constant for later
   // pretty printing.
 
-  void stash_original_text (const string& s)
-    { rep->stash_original_text (s); }
+  void stash_original_text (const string& s) { orig_text = s; }
 
-  string original_text (void) { return rep->original_text (); }
+  string original_text (void) { return orig_text; }
 
   void accept (tree_walker& tw);
 
-  char *type_as_string (void) const
-    { return rep->type_as_string (); }
-
-  // We really do need this, and it should be private:
+  string type_name (void) const { return val.type_name (); }
 
 private:
 
-  void make_unique (void);
+  octave_value val;
 
+  string orig_text;
+
+#if 0
   octave_value_rep *make_unique_map (void);
 
   // We want to eliminate this, or at least make it private.
 
   octave_value_rep::constant_type const_type (void) const
     { return rep->const_type (); }
+#endif
 
   void convert_to_matrix_type (bool make_complex)
-    { rep->convert_to_matrix_type (make_complex); }
+    { val.convert_to_matrix_type (make_complex); }
 
   // Can we make these go away?
 
   // These need better names, since a range really is a numeric type.
 
   void force_numeric (bool frc_str_conv = false)
-    { rep->force_numeric (frc_str_conv); }
+    { val.force_numeric (frc_str_conv); }
 
-  octave_value make_numeric (bool frc_str_conv = false) const
+  octave_value make_numeric (bool frc_str_conv = false) const;
+#if 0
     {
       if (is_numeric_type ())
 	return *this;
       else
 	return rep->make_numeric (frc_str_conv);
     }
-
-  bool print_as_scalar (void) { return rep->print_as_scalar (); }
-
-  bool print_as_structure (void) { return rep->print_as_structure (); }
-};
+#endif
 
-extern int Vimplicit_str_to_num_ok;
-
-extern int Vpropagate_empty_matrices;
+  bool print_as_scalar (void) { return val.print_as_scalar (); }
 
-extern bool Vresize_on_range_error;
-
-extern void symbols_of_pt_const (void);
+  bool print_as_structure (void) { return val.print_as_structure (); }
+};
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pt-fvc-base.cc b/src/pt-fvc-base.cc
--- a/src/pt-fvc-base.cc
+++ b/src/pt-fvc-base.cc
@@ -29,57 +29,68 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include <ctime>
 
 #include <SLList.h>
 
 #include "error.h"
 #include "oct-obj.h"
-#include "pt-const.h"
+#include "ov.h"
 #include "pt-fvc-base.h"
 
 // A base class for objects that can be evaluated with argument lists.
 
-octave_value
-tree_fvc::assign (octave_value&, const octave_value_list&)
+#if 0
+octave_value&
+tree_fvc::assign (const octave_value_list&, const octave_value&)
 {
+  static octave_value foo;
   panic_impossible ();
-  return octave_value ();
+  return foo;
 }
+#endif
 
 string
 tree_fvc::name (void) const
 {
   string retval;
   panic_impossible ();
   return retval;
 }
 
 void
-tree_fvc::bump_value (tree_expression::type)
+tree_fvc::increment (void)
 {
   panic_impossible ();
 }
 
+void
+tree_fvc::decrement (void)
+{
+  panic_impossible ();
+}
+
+#if 0
 octave_value
 tree_fvc::lookup_map_element (SLList<string>&, bool, bool)
 {
   static octave_value retval;
 
   int l = line ();
   int c = column ();
 
   if (l == -1 && c == -1)
     ::error ("invalid structure reference");
   else
     ::error ("invalid structure reference near line %d column %d", l, c);
 
   return retval;
 }
+#endif
 
 time_t
 tree_fvc::time_parsed (void)
 {
   panic_impossible ();
   return 0;
 }
 
diff --git a/src/pt-fvc-base.h b/src/pt-fvc-base.h
--- a/src/pt-fvc-base.h
+++ b/src/pt-fvc-base.h
@@ -41,30 +41,38 @@ class octave_value_list;
 #include "pt-mvr-base.h"
 
 // A base class for objects that can be evaluated with argument lists.
 
 class
 tree_fvc : public tree_multi_val_ret
 {
 public:
-  tree_fvc (int l = -1, int c = -1) : tree_multi_val_ret (l, c) { }
+
+  tree_fvc (int l = -1, int c = -1)
+    : tree_multi_val_ret (l, c) { }
 
   ~tree_fvc (void) { }
 
-  virtual octave_value assign (octave_value& t,
-				const octave_value_list& args);
+#if 0
+  virtual octave_value& assign (const octave_value_list& args,
+				const octave_value& t); 
+#endif
 
   virtual string name (void) const;
 
-  virtual void bump_value (tree_expression::type);
+  virtual void increment (void);
 
+  virtual void decrement (void);
+
+#if 0
   virtual octave_value lookup_map_element (SLList<string>& list,
 					    bool insert = false,
 					    bool silent = false);
+#endif
 
   virtual string fcn_file_name (void)
     { return string (); }
 
   virtual time_t time_parsed (void);
 
   virtual bool is_system_fcn_file (void) const
     { return false; }
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -43,17 +43,17 @@ Software Foundation, 59 Temple Place - S
 
 // Variables and functions.
 
 symbol_def::symbol_def (void)
 {
   init_state ();
 }
 
-symbol_def::symbol_def (octave_value *t)
+symbol_def::symbol_def (tree_constant *t)
 {
   init_state ();
   definition = t;
   type = USER_VARIABLE;
 }
 
 symbol_def::symbol_def (tree_builtin *t, unsigned fcn_type)
 {
@@ -129,18 +129,25 @@ symbol_def::is_builtin_variable (void) c
 }
 
 int
 symbol_def::is_builtin_function (void) const
 {
   return (type & BUILTIN_FUNCTION);
 }
 
+// XXX FIXME XXX
+int
+symbol_def::is_map_element (const string& /* elts */) const
+{
+  return 0;
+}
+
 void
-symbol_def::define (octave_value *t)
+symbol_def::define (tree_constant *t)
 {
   definition = t;
   if (! is_builtin_variable ())
     type = USER_VARIABLE;
 }
 
 void
 symbol_def::define (tree_builtin *t, unsigned fcn_type)
@@ -301,16 +308,22 @@ symbol_record::is_user_variable (void) c
 }
 
 int
 symbol_record::is_builtin_variable (void) const
 {
   return definition ? definition->is_builtin_variable () : 0;
 }
 
+int
+symbol_record::is_map_element (const string& elts) const
+{
+  return definition ? definition->is_map_element (elts) : 0;
+}
+
 unsigned
 symbol_record::type (void) const
 {
   return definition ? definition->type : 0;
 }
 
 int
 symbol_record::is_defined (void) const
@@ -364,17 +377,17 @@ symbol_record::make_eternal (void)
 
 void
 symbol_record::set_sv_function (sv_Function f)
 {
   sv_fcn = f;
 }
 
 int
-symbol_record::define (octave_value *t)
+symbol_record::define (tree_constant *t)
 {
   if (is_variable () && read_only_error ())
     return 0;
 
   tree_fvc *saved_def = 0;
   if (! definition)
     {
       definition = new symbol_def ();
@@ -392,26 +405,33 @@ symbol_record::define (octave_value *t)
     }
 
   definition->define (t);
 
   if (sv_fcn && sv_fcn () < 0)
     {
       // Would be nice to be able to avoid this cast.  XXX FIXME XXX
 
-      definition->define ((octave_value *) saved_def);
+      definition->define ((tree_constant *) saved_def);
       return 0;
     }
 
   delete saved_def;
 
   return 1;
 }
 
 int
+symbol_record::define (const octave_value& v)
+{
+  tree_constant *t = new tree_constant (v);
+  return define (t);
+}
+
+int
 symbol_record::define (tree_builtin *t, int text_fcn)
 {
   if (read_only_error ())
     return 0;
 
   if (is_variable ())
     {
       symbol_def *old_def = pop_def ();
@@ -459,44 +479,46 @@ symbol_record::define (tree_function *t,
   symbol_def *new_def = new symbol_def (t, fcn_type);
   push_def (new_def);
   definition->count = 1;
 
   return 1;
 }
 
 int
-symbol_record::define_as_fcn (octave_value *t)
+symbol_record::define_as_fcn (const octave_value& v)
 {
   if (is_variable () && read_only_error ())
     return 0;
 
   if (is_variable ())
     {
       symbol_def *old_def = pop_def ();
       maybe_delete (old_def);
     }
 
   if (is_function ())
     {
       symbol_def *old_def = pop_def ();
       maybe_delete (old_def);
     }
 
+  tree_constant *t = new tree_constant (v);
   symbol_def *new_def = new symbol_def (t);
   push_def (new_def);
   definition->count = 1;
   definition->type = symbol_def::BUILTIN_FUNCTION;
 
   return 1;
 }
 
 int
-symbol_record::define_builtin_var (octave_value *t)
+symbol_record::define_builtin_var (const octave_value& v)
 {
+  tree_constant *t = new tree_constant (v);
   define (t);
   if (is_variable ())
     definition->type = symbol_def::BUILTIN_VARIABLE;
   return 1;
 }
 
 void
 symbol_record::document (const string& h)
@@ -565,16 +587,53 @@ symbol_record::mark_as_linked_to_global 
 }
 
 int
 symbol_record::is_linked_to_global (void) const
 {
   return linked_to_global;
 }
 
+octave_value
+symbol_record::variable_value (void) const
+{
+  octave_value retval;
+
+  if (is_variable ())
+    {
+      tree_constant *tmp = (tree_constant *) def ();
+      retval = tmp->value ();
+    }
+
+  return retval;
+}
+
+octave_value&
+symbol_record::variable_reference (void)
+{
+  if (is_function ())
+    clear ();
+
+  if (! is_defined ())
+    {
+      if (! (is_formal_parameter () || is_linked_to_global ()))
+	link_to_builtin_variable (this);
+
+      if (! is_defined ())
+	{
+	  tree_constant *tmp = new tree_constant ();
+	  define (tmp);
+	}
+    }
+
+  tree_constant *tmp = (tree_constant *) def ();
+
+  return tmp->reference ();
+}
+
 symbol_record *
 symbol_record::next (void) const
 {
   return next_elem;
 }
 
 void
 symbol_record::chain (symbol_record *s)
@@ -673,17 +732,17 @@ symbol_record_info::symbol_record_info (
   init_state ();
 
   type = sr.type ();
 
   if (sr.is_variable () && sr.is_defined ())
     {
       // Would be nice to avoid this cast.  XXX FIXME XXX
 
-      octave_value *tmp = (octave_value *) sr.def ();
+      tree_constant *tmp = (tree_constant *) sr.def ();
       if (tmp->is_real_scalar ())
 	const_type = SR_INFO_SCALAR;
       else if (tmp->is_complex_scalar ())
 	const_type = SR_INFO_COMPLEX_SCALAR;
       else if (tmp->is_real_matrix ())
 	const_type = SR_INFO_MATRIX;
       else if (tmp->is_complex_matrix ())
 	const_type = SR_INFO_COMPLEX_MATRIX;
@@ -771,17 +830,17 @@ symbol_record_info::hides_fcn (void) con
 
 int
 symbol_record_info::hides_builtin (void) const
 {
   return (hides & SR_INFO_BUILTIN_FUNCTION);
 }
 
 string
-symbol_record_info::type_as_string (void) const
+symbol_record_info::type_name (void) const
 {
   if (type == symbol_def::USER_FUNCTION)
     return "user function";
   else if (type == symbol_def::BUILTIN_FUNCTION)
     return "builtin function";
   else
     {
       if (const_type == SR_INFO_SCALAR)
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -37,17 +37,17 @@ Software Foundation, 59 Temple Place - S
 
 // Must be multiple of 2.
 #define HASH_TABLE_SIZE 1024
 #define HASH_MASK (HASH_TABLE_SIZE - 1)
 
 class tree;
 class tree_fvc;
 class tree_builtin;
-class octave_value;
+class tree_constant;
 class tree_function;
 
 class string_vector;
 
 class symbol_def;
 class symbol_record;
 class symbol_record_info;
 class symbol_table;
@@ -57,32 +57,33 @@ class symbol_table;
 class symbol_def
 {
   friend class symbol_record;
   friend class symbol_record_info;
 
 public:
 
   symbol_def (void);
-  symbol_def (octave_value *t);
+  symbol_def (tree_constant *t);
   symbol_def (tree_builtin *t, unsigned fcn_type = 0);
   symbol_def (tree_function *t, unsigned fcn_type = 0);
 
   ~symbol_def (void);
 
   int is_variable (void) const;
   int is_function (void) const;
   int is_text_function (void) const;
   int is_mapper_function (void) const;
   int is_user_variable (void) const;
   int is_user_function (void) const;
   int is_builtin_variable (void) const;
   int is_builtin_function (void) const;
+  int is_map_element (const string& elts) const;
 
-  void define (octave_value *t);
+  void define (tree_constant *t);
   void define (tree_builtin *t, unsigned fcn_type = 0);
   void define (tree_function *t, unsigned fcn_type = 0);
 
   void protect (void);
   void unprotect (void);
   void make_eternal (void);
 
   tree_fvc *def (void) const;
@@ -141,47 +142,52 @@ public:
   int is_function (void) const;
   int is_user_function (void) const;
   int is_text_function (void) const;
   int is_mapper_function (void) const;
   int is_builtin_function (void) const;
   int is_variable (void) const;
   int is_user_variable (void) const;
   int is_builtin_variable (void) const;
+  int is_map_element (const string& elts) const;
 
   unsigned type (void) const;
 
   int is_defined (void) const;
   int is_read_only (void) const;
   int is_eternal (void) const;
 
   void protect (void);
   void unprotect (void);
   void make_eternal (void);
 
   void set_sv_function (sv_Function f);
 
-  int define (octave_value *t);
+  int define (tree_constant *t);
+  int define (const octave_value& v);
   int define (tree_builtin *t, int text_fcn = 0);
   int define (tree_function *t, int text_fcn = 0);
-  int define_as_fcn (octave_value *t);
-  int define_builtin_var (octave_value *t);
+  int define_as_fcn (const octave_value& v);
+  int define_builtin_var (const octave_value& v);
 
   void document (const string& h);
 
   int clear (void);
 
   void alias (symbol_record *s, int force = 0);
 
   void mark_as_formal_parameter (void);
   int is_formal_parameter (void) const;
 
   void mark_as_linked_to_global (void);
   int is_linked_to_global (void) const;
 
+  octave_value variable_value (void) const;
+  octave_value& variable_reference (void);
+
   symbol_record *next (void) const;
 
   void chain (symbol_record *s);
 
   void push_context (void);
   void pop_context (void);
 
 private:
@@ -225,17 +231,17 @@ public:
 
   symbol_record_info& operator = (const symbol_record_info& s);
 
   int is_defined (void) const;
   int is_read_only (void) const;
   int is_eternal (void) const;
   int hides_fcn (void) const;
   int hides_builtin (void) const;
-  string type_as_string (void) const;
+  string type_name (void) const;
   int is_function (void) const;
   int rows (void) const;
   int columns (void) const;
   string name (void) const;
 
   enum HIDES
     {
       SR_INFO_NONE = 0,
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -40,17 +40,16 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include <readline/readline.h>
 
 #include "file-ops.h"
 #include "oct-glob.h"
 #include "str-vec.h"
 
-#include "arith-ops.h"
 #include "defaults.h"
 #include "data.h"
 #include "defun.h"
 #include "dirfns.h"
 #include "dynamic-ld.h"
 #include "error.h"
 #include "file-io.h"
 #include "fn-cache.h"
@@ -107,16 +106,70 @@ static int Vsaving_history;
 symbol_table *top_level_sym_tab = 0;
 
 // Symbol table for the current scope.
 symbol_table *curr_sym_tab = 0;
 
 // Symbol table for global symbols.
 symbol_table *global_sym_tab = 0;
 
+octave_variable_reference::octave_variable_reference (tree_indirect_ref *i)
+  : id (0), indir (i)
+{
+  if (indir->is_identifier_only ())
+    {
+      id = indir->ident ();
+      indir = 0;
+    }
+}
+
+void
+octave_variable_reference::assign (const octave_value& rhs)
+{
+  if (id)
+    id->assign (rhs);
+  else if (indir)
+    {
+      octave_value& ult = indir->reference ();
+      ult = rhs;
+    }
+  else
+    panic_impossible ();
+}
+
+void
+octave_variable_reference::assign (const octave_value_list& idx,
+				   const octave_value& rhs)
+{
+  if (id)
+    id->assign (idx, rhs);
+  else if (indir)
+    {
+      octave_value& ult = indir->reference ();
+      ult.assign (idx, rhs);
+    }
+  else
+    panic_impossible ();
+}
+
+octave_value
+octave_variable_reference::value (void)
+{
+  octave_value retval;
+
+  if (id)
+    retval = id->value ();
+  else if (indir)
+    retval = indir->value ();
+  else
+    panic_impossible ();
+
+  return retval;
+}
+  
 // Initialization.
 
 // Create the initial symbol tables and set the current scope at the
 // top level.
 
 void
 initialize_symbol_tables (void)
 {
@@ -286,32 +339,18 @@ returns:\n\
   symbol_record *sr = curr_sym_tab->lookup (name, 0, 0);
   if (! sr)
     sr = global_sym_tab->lookup (name, 0, 0);
 
   retval = 0.0;
 
   if (sr && sr->is_variable () && sr->is_defined ())
     {
-      retval = 1.0;
-      tree_fvc *def = sr->def ();
-
-      if (! struct_elts.empty ())
-	{
-	  retval = 0.0;
-	  if (def->is_constant ())
-	    {
-	      octave_value *tmp = (octave_value *) def;
-
-	      octave_value ult	= tmp->lookup_map_element (struct_elts, 0, 1);
-
-	      if (ult.is_defined ())
-		retval = 1.0;
-	    }
-	}
+      if (struct_elts.empty () || sr->is_map_element (struct_elts))
+	retval = 1.0;
     }
   else if (sr && sr->is_builtin_function ())
     {
       retval = 5.0;
     }
   else if (sr && sr->is_user_function ())
     {
       retval = 2.0;
@@ -842,31 +881,31 @@ link_to_global_variable (symbol_record *
     }
 
   // There must be a better way to do this.   XXX FIXME XXX
 
   if (sr->is_variable ())
     {
       // Would be nice not to have this cast.  XXX FIXME XXX
 
-      octave_value *tmp = (octave_value *) sr->def ();
+      tree_constant *tmp = (tree_constant *) sr->def ();
       if (tmp)
-	tmp = new octave_value (*tmp);
+	tmp = new tree_constant (*tmp);
       else
-	tmp = new octave_value ();
+	tmp = new tree_constant ();
       gsr->define (tmp);
     }
   else
     sr->clear ();
 
   // If the global symbol is currently defined as a function, we need
   // to hide it with a variable.
 
   if (gsr->is_function ())
-    gsr->define ((octave_value *) 0);
+    gsr->define ((tree_constant *) 0);
 
   sr->alias (gsr, 1);
   sr->mark_as_linked_to_global ();
 }
 
 // Make the definition of the symbol record sr be the same as the
 // definition of the builtin variable of the same name.
 
@@ -981,17 +1020,17 @@ make_name_list (void)
 static void
 print_symbol_info_line (ostream& os, const symbol_record_info& s)
 {
   os << (s.is_read_only () ? " -" : " w");
   os << (s.is_eternal () ? "- " : "d ");
 #if 0
   os << (s.hides_fcn () ? "f" : (s.hides_builtin () ? "F" : "-"));
 #endif
-  os.form ("  %-16s", s.type_as_string ().c_str ());
+  os.form ("  %-16s", s.type_name ().c_str ());
   if (s.is_function ())
     os << "      -      -";
   else
     {
       os.form ("%7d", s.rows ());
       os.form ("%7d", s.columns ());
     }
   os << "  " << s.name () << "\n";
@@ -1276,17 +1315,18 @@ install_builtin_variable (const builtin_
     install_builtin_variable_as_function (v.name, v.value, v.protect,
 					  v.eternal, v.help_string);
   else
     bind_builtin_variable (v.name, v.value, v.protect, v.eternal,
 			   v.sv_function, v.help_string);
 }
 
 void
-install_builtin_variable_as_function (const string& name, octave_value *val,
+install_builtin_variable_as_function (const string& name,
+				      const octave_value& val,
 				      int protect, int eternal,
 				      const string& help)
 {
   symbol_record *sym_rec = global_sym_tab->lookup (name, 1);
   sym_rec->unprotect ();
 
   string tmp_help = help.empty () ? sym_rec->help () : help;
 
@@ -1340,17 +1380,17 @@ bind_nargin_and_nargout (symbol_table *s
 #endif
 
 void
 bind_ans (const octave_value& val, int print)
 {
   static symbol_record *sr = global_sym_tab->lookup ("ans", 1, 0);
 
   tree_identifier *ans_id = new tree_identifier (sr);
-  octave_value *tmp = new octave_value (val);
+  tree_constant *tmp = new tree_constant (val);
 
   // XXX FIXME XXX -- making ans_id static, passing its address to
   // tree_simple_assignment_expression along with a flag to not delete
   // it seems to create a memory leak.  Hmm.
 
   tree_simple_assignment_expression tmp_ass (ans_id, tmp, false, true);
 
   tmp_ass.eval (print);
@@ -1383,17 +1423,17 @@ clear_global_error_variable (void *)
 
 // Give a global variable a definition.  This will insert the symbol
 // in the global table if necessary.
 
 // How is this different than install_builtin_variable?  Are both
 // functions needed?
 
 void
-bind_builtin_variable (const string& varname, octave_value *val,
+bind_builtin_variable (const string& varname, const octave_value& val,
 		       int protect, int eternal, sv_Function sv_fcn,
 		       const string& help)
 {
   symbol_record *sr = global_sym_tab->lookup (varname, 1, 0);
 
   // It is a programming error for a builtin symbol to be missing.
   // Besides, we just inserted it, so it must be there.
 
@@ -1414,25 +1454,16 @@ bind_builtin_variable (const string& var
     sr->protect ();
 
   if (eternal)
     sr->make_eternal ();
 
   sr->document (help);
 }
 
-void
-bind_builtin_variable (const string& varname, const octave_value& val,
-		       int protect, int eternal, sv_Function sv_fcn,
-		       const string& help)
-{
-  octave_value *tc = new octave_value (val);
-  bind_builtin_variable (varname, tc, protect, eternal, sv_fcn, help);
-}
-
 // XXX FIXME XXX -- some of these should do their own checking to be
 // able to provide more meaningful warning or error messages.
 
 static int
 echo_executing_commands (void)
 {
   Vecho_executing_commands = check_preference ("echo_executing_commands"); 
 
@@ -1551,34 +1582,33 @@ directory specification");
 
   DEFVAR (saving_history, 1.0, 0, saving_history,
     "save command history");
 }
 
 void
 install_builtin_variables (void)
 {
-  symbols_of_arith_ops ();
   symbols_of_data ();
   symbols_of_defaults ();
   symbols_of_dirfns ();
   symbols_of_error ();
   symbols_of_file_io ();
   symbols_of_help ();
   symbols_of_input ();
   symbols_of_lex ();
   symbols_of_load_save ();
   symbols_of_pager ();
   symbols_of_parse ();
   symbols_of_pr_output ();
-  symbols_of_pt_const ();
   symbols_of_pt_fcn ();
   symbols_of_pt_mat ();
   symbols_of_pt_plot ();
   symbols_of_syscalls ();
+  symbols_of_value ();
   symbols_of_variables ();
 }
 
 // Deleting names from the symbol tables.
 
 DEFUN_TEXT (clear, args, ,
   "clear [-x] [name ...]\n\
 \n\
diff --git a/src/variables.h b/src/variables.h
--- a/src/variables.h
+++ b/src/variables.h
@@ -22,42 +22,76 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_variables_h)
 #define octave_variables_h 1
 
 class symbol_record;
 class symbol_table;
 
 class tree_fvc;
+class tree_identifier;
+class tree_indirect_ref;
 class octave_value;
 class octave_value_list;
 class string_vector;
 
 #include <string>
 
+#include "ov.h"
+
 struct builtin_mapper_function;
 
 typedef int (*sv_Function)(void);
 
 struct builtin_variable
 {
-  builtin_variable (const string& n, octave_value *v, int iaf, int p,
+  builtin_variable (const string& n, const octave_value& v, int iaf, int p,
 		    int e, sv_Function svf, const string& h)
     : name (n), value (v), install_as_function (iaf), protect (p),
       eternal (e), sv_function (svf), help_string (h) { }
 
   string name;
-  octave_value *value;
+  octave_value value;
   int install_as_function;
   int protect;
   int eternal;
   sv_Function sv_function;
   string help_string;
 };
 
+class
+octave_variable_reference
+{
+public:
+
+  octave_variable_reference (tree_identifier *i) : id (i), indir (0) { }
+
+  octave_variable_reference (tree_indirect_ref *i);
+
+  ~octave_variable_reference (void) { }
+
+  void assign (const octave_value&);
+
+  void assign (const octave_value_list&, const octave_value&);
+
+  octave_value value (void);
+
+private:
+
+  tree_identifier *id;
+
+  tree_indirect_ref *indir;
+
+  // No copying!
+
+  octave_variable_reference (const octave_variable_reference&);
+
+  octave_variable_reference& operator = (const octave_variable_reference&);
+};
+
 typedef octave_value_list (*Octave_builtin_fcn)(const octave_value_list&, int);
 
 struct builtin_function
 {
   builtin_function (const string& n, int itf, Octave_builtin_fcn f,
 		    const string& h)
     : name (n), is_text_fcn (itf), fcn (f), help_string (h) { }
 
@@ -98,38 +132,34 @@ extern string_vector make_name_list (voi
 
 extern void install_builtin_mapper (const builtin_mapper_function& mf);
 
 extern void install_builtin_function (const builtin_function& gf);
 
 extern void install_builtin_variable (const builtin_variable& v);
 
 extern void
-install_builtin_variable_as_function
-  (const string& name, octave_value *val, int protect = 0,
-   int eternal = 0, const string& help = string ());
+install_builtin_variable_as_function (const string& name,
+				      const octave_value& val,
+				      int protect = 0, int eternal = 0,
+				      const string& help = string ());
 
 extern void alias_builtin (const string& alias, const string& name);
 
 #if 0
 extern void bind_nargin_and_nargout (symbol_table *sym_tab,
 				     int nargin, int nargout);
 #endif
 
 extern void bind_ans (const octave_value& val, int print);
 
 extern void bind_global_error_variable (void);
 
 extern void clear_global_error_variable (void *);
 
-extern void bind_builtin_variable (const string&, octave_value *,
-				   int protect = 0, int eternal = 0,
-				   sv_Function f = (sv_Function) 0,
-				   const string& help = string ());
-
 extern void bind_builtin_variable (const string&, const octave_value&,
 				   int protect = 0, int eternal = 0,
 				   sv_Function f = (sv_Function) 0,
 				   const string& help = string ());
 
 extern void install_builtin_variables (void);
 
 // Symbol table for symbols at the top level.
