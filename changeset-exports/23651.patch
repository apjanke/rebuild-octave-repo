# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1497891752 14400
#      Mon Jun 19 13:02:32 2017 -0400
# Node ID 5c6cceef132bdad56daa528060377ce33b935ec1
# Parent  7b187892a25a2f139122b0b2328dae8ddaba3e23
don't use singleton for cdef_manager object

* ov-classdef.h, ov-classdef.cc (cdef_manager): Don't use singleton
pattern.  Change all uses.
(cdef_manager::m_meta_class, cdef_manager::m_meta_property,
cdef_manager::m_meta_method, cdef_manager::m_meta_package,
cdef_manager::m_meta): New data members.

(cdef_manager::meta_class, cdef_manager::meta_property,
cdef_manager::meta_method, cdef_manager::meta_package,
cdef_manager::meta): New functions.

(cdef_class::meta_class, cdef_class::meta_property,
cdef_class::meta_method, cdef_class::meta_package):
Delete static functions.

(cdef_package::meta): Delete static function.

(cdef_class::_meta_class, cdef_class::_meta_property,
cdef_class::_meta_method, cdef_class::_meta_package,
cdef_package::_meta): Delete static data members.

(cdef_manager::initialize): New function, adapted from install_classdef.

* interpreter.h, interpreter.cc (interpreter::m_cdef_manager):
New data member.
(interpreter::get_cdef_manager): New function.
(interpreter::interpreter): Initialize m_cdef_manager object instead
of calling install_classdef.

* interpreter-private.h, interpreter-private.cc
(__get_cdef_manager__): New function.

diff --git a/libinterp/corefcn/interpreter-private.cc b/libinterp/corefcn/interpreter-private.cc
--- a/libinterp/corefcn/interpreter-private.cc
+++ b/libinterp/corefcn/interpreter-private.cc
@@ -23,19 +23,20 @@ along with Octave; see the file COPYING.
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include <string>
 
 #include "call-stack.h"
 #include "error.h"
-#include "load-path.h"
 #include "interpreter-private.h"
 #include "interpreter.h"
+#include "load-path.h"
+#include "ov-classdef.h"
 #include "symtab.h"
 
 namespace octave
 {
   interpreter& __get_interpreter__ (const std::string& who)
   {
     interpreter *interp = interpreter::the_interpreter ();
 
@@ -94,9 +95,16 @@ namespace octave
   }
 
   call_stack& __get_call_stack__ (const std::string& who)
   {
     interpreter& interp = __get_interpreter__ (who);
 
     return interp.get_call_stack ();
   }
+
+  cdef_manager& __get_cdef_manager__ (const std::string& who)
+  {
+    interpreter& interp = __get_interpreter__ (who);
+
+    return interp.get_cdef_manager ();
+  }
 }
diff --git a/libinterp/corefcn/interpreter-private.h b/libinterp/corefcn/interpreter-private.h
--- a/libinterp/corefcn/interpreter-private.h
+++ b/libinterp/corefcn/interpreter-private.h
@@ -24,23 +24,25 @@ along with Octave; see the file COPYING.
 #define octave_interpreter_private_h 1
 
 #include "octave-config.h"
 
 #include <string>
 
 #include "symtab.h"
 
+class cdef_manager;
+
 namespace octave
 {
-  class call_stack;
   class interpreter;
   class dynamic_loader;
   class load_path;
   class tree_evaluator;
+  class call_stack;
 
   extern interpreter& __get_interpreter__ (const std::string& who);
 
   extern dynamic_loader& __get_dynamic_loader__ (const std::string& who);
 
   extern load_path& __get_load_path__ (const std::string& who);
 
   extern symbol_table& __get_symbol_table__ (const std::string& who);
@@ -48,11 +50,13 @@ namespace octave
   extern symbol_table::scope *__get_current_scope__ (const std::string& who);
 
   extern symbol_table::scope *
   __require_current_scope__ (const std::string& who);
 
   extern tree_evaluator& __get_evaluator__ (const std::string& who);
 
   extern call_stack& __get_call_stack__ (const std::string& who);
+
+  extern cdef_manager& __get_cdef_manager__ (const std::string& who);
 }
 
 #endif
diff --git a/libinterp/corefcn/interpreter.cc b/libinterp/corefcn/interpreter.cc
--- a/libinterp/corefcn/interpreter.cc
+++ b/libinterp/corefcn/interpreter.cc
@@ -372,16 +372,17 @@ namespace octave
   // path.
 
   interpreter::interpreter (application *app_context)
     : m_app_context (app_context),
       m_dynamic_loader (*this),
       m_load_path (),
       m_symbol_table (),
       m_evaluator (*this),
+      m_cdef_manager (*this),
       m_interactive (false),
       m_read_site_files (true),
       m_read_init_files (m_app_context != 0),
       m_verbose (false),
       m_inhibit_startup_message (false),
       m_load_path_initialized (false),
       m_history_initialized (false),
       m_initialized (false)
@@ -434,17 +435,17 @@ namespace octave
     initialize_file_io ();
 
     install_types ();
 
     install_ops ();
 
     install_builtins ();
 
-    install_classdef (*this);
+    m_cdef_manager.initialize ();
 
     bool line_editing = false;
     bool traditional = false;
 
     if (m_app_context)
       {
         // Embedded interpeters don't execute command line options.
         const cmdline_options& options = m_app_context->options ();
diff --git a/libinterp/corefcn/interpreter.h b/libinterp/corefcn/interpreter.h
--- a/libinterp/corefcn/interpreter.h
+++ b/libinterp/corefcn/interpreter.h
@@ -27,16 +27,17 @@ along with Octave; see the file COPYING.
 
 #include <string>
 
 #include "quit.h"
 #include "str-vec.h"
 
 #include "dynamic-ld.h"
 #include "load-path.h"
+#include "ov-classdef.h"
 #include "pt-eval.h"
 #include "symtab.h"
 
 extern OCTINTERP_API bool quit_allowed;
 
 // TRUE means we are ready to interpret commands, but not everything
 // is ready for interactive use.
 extern OCTINTERP_API bool octave_interpreter_ready;
@@ -153,16 +154,21 @@ namespace octave
 
     symbol_table::scope * get_current_scope (void);
     symbol_table::scope * require_current_scope (const std::string& who);
 
     call_stack& get_call_stack (void);
 
     tree_evaluator& get_evaluator (void);
 
+    cdef_manager& get_cdef_manager (void)
+    {
+      return m_cdef_manager;
+    }
+
     static void recover_from_exception (void);
 
     static void add_atexit_function (const std::string& fname);
 
     static bool remove_atexit_function (const std::string& fname);
 
     static interpreter * the_interpreter (void) { return instance; }
 
@@ -191,16 +197,18 @@ namespace octave
     dynamic_loader m_dynamic_loader;
 
     load_path m_load_path;
 
     symbol_table m_symbol_table;
 
     tree_evaluator m_evaluator;
 
+    cdef_manager m_cdef_manager;
+
     // TRUE means this is an interactive interpreter (forced or not).
     bool m_interactive;
 
     bool m_read_site_files;
 
     bool m_read_init_files;
 
     bool m_verbose;
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -578,18 +578,20 @@ symbol_table::fcn_info::fcn_info_rep::lo
   (const std::string& dispatch_type)
 {
   octave_value retval;
 
   if (full_name () == dispatch_type)
     retval = load_class_constructor ();
   else
     {
-      octave_function *cm = cdef_manager::find_method_symbol (name,
-                                                              dispatch_type);
+      cdef_manager& cdm
+        = octave::__get_cdef_manager__ ("symbol_table::fcn_info::fcn_info_rep::load_class_method");
+
+      octave_function *cm = cdm.find_method_symbol (name, dispatch_type);
 
       if (cm)
         retval = octave_value (cm);
 
       if (! retval.is_defined ())
         {
           std::string dir_name;
 
@@ -1182,18 +1184,20 @@ octave_value
 symbol_table::fcn_info::fcn_info_rep::find_package (void)
 {
   // FIXME: implement correct way to check out of date package
   //if (package.is_defined ())
   //  out_of_date_check (package);
 
   if (package.is_undefined ())
     {
-      octave_function *fcn =
-        cdef_manager::find_package_symbol (full_name ());
+      cdef_manager& cdm
+        = octave::__get_cdef_manager__ ("symbol_table::fcn_info::fcn_info_rep::find_package");
+
+      octave_function *fcn = cdm.find_package_symbol (full_name ());
 
       if (fcn)
         package = octave_value (fcn);
     }
 
   return package;
 }
 
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -146,18 +146,19 @@ make_fcn_handle (const octave_value& fcn
 
   return retval;
 }
 
 static cdef_class
 lookup_class (const std::string& name, bool error_if_not_found = true,
               bool load_if_not_found = true)
 {
-  return cdef_manager::find_class (name, error_if_not_found,
-                                   load_if_not_found);
+  cdef_manager& cdm = octave::__get_cdef_manager__ ("lookup_class");
+
+  return cdm.find_class (name, error_if_not_found, load_if_not_found);
 }
 
 static cdef_class
 lookup_class (const cdef_class& cls)
 {
   // FIXME: placeholder for the time being, the purpose
   //        is to centralized any class update activity here.
 
@@ -641,17 +642,20 @@ handle_delete (const octave_value_list& 
 }
 
 static cdef_class
 make_class (const std::string& name,
             const std::list<cdef_class>& super_list = std::list<cdef_class> ())
 {
   cdef_class cls (name, super_list);
 
-  cls.set_class (cdef_class::meta_class ());
+  cdef_manager& cdm = octave::__get_cdef_manager__ ("make_class");
+
+  cls.set_class (cdm.meta_class ());
+
   cls.put ("Abstract", false);
   cls.put ("ConstructOnLoad", false);
   cls.put ("ContainingPackage", Matrix ());
   cls.put ("Description", "");
   cls.put ("DetailedDescription", "");
   cls.put ("Events", Cell ());
   cls.put ("Hidden", false);
   cls.put ("InferiorClasses", Cell ());
@@ -685,17 +689,17 @@ make_class (const std::string& name,
                name.c_str ());
 
       cls.put ("HandleCompatible", all_handle_compatible);
       if (has_handle_class)
         cls.mark_as_handle_class ();
     }
 
   if (! name.empty ())
-    cdef_manager::register_class (cls);
+    cdm.register_class (cls);
 
   return cls;
 }
 
 static cdef_class
 make_class (const std::string& name, const cdef_class& super)
 {
   return make_class (name, std::list<cdef_class> (1, super));
@@ -716,17 +720,20 @@ static cdef_property
 make_property (const cdef_class& cls, const std::string& name,
                const octave_value& get_method = Matrix (),
                const std::string& get_access = "public",
                const octave_value& set_method = Matrix (),
                const std::string& set_access = "public")
 {
   cdef_property prop (name);
 
-  prop.set_class (cdef_class::meta_property ());
+  cdef_manager& cdm = octave::__get_cdef_manager__ ("make_property");
+
+  prop.set_class (cdm.meta_property ());
+
   prop.put ("Description", "");
   prop.put ("DetailedDescription", "");
   prop.put ("Abstract", false);
   prop.put ("Constant", false);
   prop.put ("GetAccess", get_access);
   prop.put ("SetAccess", set_access);
   prop.put ("Dependent", false);
   prop.put ("Transient", false);
@@ -757,17 +764,20 @@ make_attribute (const cdef_class& cls, c
 
 static cdef_method
 make_method (const cdef_class& cls, const std::string& name,
              const octave_value& fcn,const std::string& m_access = "public",
              bool is_static = false)
 {
   cdef_method meth (name);
 
-  meth.set_class (cdef_class::meta_method ());
+  cdef_manager& cdm = octave::__get_cdef_manager__ ("make_method");
+
+  meth.set_class (cdm.meta_method ());
+
   meth.put ("Abstract", false);
   meth.put ("Access", m_access);
   meth.put ("DefiningClass", to_ov (cls));
   meth.put ("Description", "");
   meth.put ("DetailedDescription", "");
   meth.put ("Hidden", false);
   meth.put ("Sealed", true);
   meth.put ("Static", is_static);
@@ -804,24 +814,27 @@ make_method (const cdef_class& cls, cons
 }
 
 static cdef_package
 make_package (const std::string& nm,
               const std::string& parent = "")
 {
   cdef_package pack (nm);
 
-  pack.set_class (cdef_class::meta_package ());
+  cdef_manager& cdm = octave::__get_cdef_manager__ ("make_package");
+
+  pack.set_class (cdm.meta_package ());
+
   if (parent.empty ())
     pack.put ("ContainingPackage", Matrix ());
   else
-    pack.put ("ContainingPackage", to_ov (cdef_manager::find_package (parent)));
+    pack.put ("ContainingPackage", to_ov (cdm.find_package (parent)));
 
   if (! nm.empty ())
-    cdef_manager::register_package (pack);
+    cdm.register_package (pack);
 
   return pack;
 }
 
 //----------------------------------------------------------------------------
 
 int octave_classdef::t_id (-1);
 
@@ -2309,17 +2322,20 @@ cdef_class::cdef_class_rep::meta_subsref
     retval = retval(0).next_subsref (nargout, type, idx, skip);
 
   return retval;
 }
 
 void
 cdef_class::cdef_class_rep::meta_release (void)
 {
-  cdef_manager::unregister_class (wrap ());
+  cdef_manager& cdm
+    = octave::__get_cdef_manager__ ("cdef_class::cdef_class_rep::meta_release");
+
+  cdm.unregister_class (wrap ());
 }
 
 void
 cdef_class::cdef_class_rep::initialize_object (cdef_object& obj)
 {
   // Populate the object with default property values
 
   std::list<cdef_class> super_classes = lookup_classes (
@@ -2405,43 +2421,46 @@ cdef_class::cdef_class_rep::construct_ob
     {
       // This code path is only used to create empty meta objects
       // as filler for the empty values within a meta object array.
 
       cdef_class this_cls = wrap ();
 
       static cdef_object empty_class;
 
-      if (this_cls == cdef_class::meta_class ())
+      cdef_manager& cdm
+        = octave::__get_cdef_manager__ ("cdef_class::cdef_class_rep::construct_object");
+
+      if (this_cls == cdm.meta_class ())
         {
           if (! empty_class.ok ())
             empty_class = make_class ("", std::list<cdef_class> ());
           obj = empty_class;
         }
-      else if (this_cls == cdef_class::meta_property ())
+      else if (this_cls == cdm.meta_property ())
         {
           static cdef_property empty_property;
 
           if (! empty_class.ok ())
             empty_class = make_class ("", std::list<cdef_class> ());
           if (! empty_property.ok ())
             empty_property = make_property (empty_class, "");
           obj = empty_property;
         }
-      else if (this_cls == cdef_class::meta_method ())
+      else if (this_cls == cdm.meta_method ())
         {
           static cdef_method empty_method;
 
           if (! empty_class.ok ())
             empty_class = make_class ("", std::list<cdef_class> ());
           if (! empty_method.ok ())
             empty_method = make_method (empty_class, "", octave_value ());
           obj = empty_method;
         }
-      else if (this_cls == cdef_class::meta_package ())
+      else if (this_cls == cdm.meta_package ())
         {
           static cdef_package empty_package;
 
           if (! empty_package.ok ())
             empty_package = make_package ("");
           obj = empty_package;
         }
       else
@@ -2545,17 +2564,20 @@ cdef_class::make_meta_class (octave::int
     }
 
   retval = ::make_class (full_class_name, slist);
 
   // Package owning this class
 
   if (! t->package_name ().empty ())
     {
-      cdef_package pack = cdef_manager::find_package (t->package_name ());
+      cdef_manager& cdm
+        = octave::__get_cdef_manager__ ("cdef_class::make_meta_class");
+
+      cdef_package pack = cdm.find_package (t->package_name ());
 
       if (pack.ok ())
         retval.put ("ContainingPackage", to_ov (pack));
     }
 
   // Class attributes
 
   octave::tree_evaluator& tw = interp.get_evaluator ();
@@ -3077,17 +3099,19 @@ cdef_method::cdef_method_rep::meta_subsr
     retval = retval(0).next_subsref (nargout, type, idx, 1);
 
   return retval;
 }
 
 static cdef_package
 lookup_package (const std::string& name)
 {
-  return cdef_manager::find_package (name);
+  cdef_manager& cdm = octave::__get_cdef_manager__ ("lookup_package");
+
+  return cdm.find_package (name);
 }
 
 static octave_value_list
 package_fromName (const octave_value_list& args, int /* nargout */)
 {
   octave_value_list retval;
 
   if (args.length () != 1)
@@ -3153,21 +3177,22 @@ package_getAllPackages (octave::interpre
                         const octave_value_list& /* args */, int /* nargout */)
 {
   std::map<std::string, cdef_package> toplevel_packages;
 
   octave::load_path& lp = interp.get_load_path ();
 
   std::list<std::string> names = lp.get_all_package_names ();
 
-  toplevel_packages["meta"] = cdef_manager::find_package ("meta", false,
-                                                          false);
+  cdef_manager& cdm = octave::__get_cdef_manager__ ("package_getAllPackages");
+
+  toplevel_packages["meta"] = cdm.find_package ("meta", false, false);
 
   for (const auto& nm : names)
-    toplevel_packages[nm] = cdef_manager::find_package (nm, false, true);
+    toplevel_packages[nm] = cdm.find_package (nm, false, true);
 
   Cell c (toplevel_packages.size (), 1);
 
   int i = 0;
 
   for (const auto& nm_pkg : toplevel_packages)
     c(i++,0) = to_ov (nm_pkg.second);
 
@@ -3307,284 +3332,391 @@ void
 cdef_package::cdef_package_rep::meta_release (void)
 {
   // FIXME: Do we really want to unregister the package, as it
   //        could still be referenced by classes or sub-packages?
   //        If the package object is recreated later on, it won't
   //        match the one already referenced by those classes or
   //        sub-packages.
 
-  //cdef_manager::unregister_package (wrap ());
+  cdef_manager& cdm
+    = octave::__get_cdef_manager__ ("cdef_package::cdef_package_rep::meta_release");
+
+  cdm.unregister_package (wrap ());
 }
 
-cdef_class cdef_class::_meta_class = cdef_class ();
-cdef_class cdef_class::_meta_property = cdef_class ();
-cdef_class cdef_class::_meta_method = cdef_class ();
-cdef_class cdef_class::_meta_package = cdef_class ();
-
-cdef_package cdef_package::_meta = cdef_package ();
+//----------------------------------------------------------------------------
 
 void
-install_classdef (octave::interpreter& interp)
+cdef_manager::initialize (void)
 {
   octave_classdef::register_type ();
 
   // bootstrap
-  cdef_class handle = make_class ("handle");
-
-  cdef_class meta_class
-    = cdef_class::_meta_class
-    = make_meta_class ("meta.class", handle);
-
-  handle.set_class (meta_class);
-  meta_class.set_class (meta_class);
+  cdef_class tmp_handle = make_class ("handle");
+
+  cdef_class tmp_meta_class
+    = m_meta_class
+    = make_meta_class ("meta.class", tmp_handle);
+
+  tmp_handle.set_class (tmp_meta_class);
+  tmp_meta_class.set_class (tmp_meta_class);
 
   // meta classes
-  cdef_class meta_property
-    = cdef_class::_meta_property
-    = make_meta_class ("meta.property", handle);
-
-  cdef_class meta_method
-    = cdef_class::_meta_method
-    = make_meta_class ("meta.method", handle);
-
-  cdef_class meta_package
-    = cdef_class::_meta_package
-    = make_meta_class ("meta.package", handle);
-
-  cdef_class meta_event
-    = make_meta_class ("meta.event", handle);
-
-  cdef_class meta_dynproperty
-    = make_meta_class ("meta.dynamicproperty", handle);
+  cdef_class tmp_meta_property
+    = m_meta_property
+    = make_meta_class ("meta.property", tmp_handle);
+
+  cdef_class tmp_meta_method
+    = m_meta_method
+    = make_meta_class ("meta.method", tmp_handle);
+
+  cdef_class tmp_meta_package
+    = m_meta_package
+    = make_meta_class ("meta.package", tmp_handle);
+
+  cdef_class tmp_meta_event
+    = make_meta_class ("meta.event", tmp_handle);
+
+  cdef_class tmp_meta_dynproperty
+    = make_meta_class ("meta.dynamicproperty", tmp_handle);
 
   // meta.class properties
-  meta_class.install_property (make_attribute (meta_class, "Abstract"));
-  meta_class.install_property (make_attribute (meta_class, "ConstructOnLoad"));
-  meta_class.install_property (make_property  (meta_class, "ContainingPackage"));
-  meta_class.install_property (make_property  (meta_class, "Description"));
-  meta_class.install_property (make_property  (meta_class, "DetailedDescription"));
-  meta_class.install_property (make_property  (meta_class, "Events"));
-  meta_class.install_property (make_attribute (meta_class, "HandleCompatible"));
-  meta_class.install_property (make_attribute (meta_class, "Hidden"));
-  meta_class.install_property
-      (make_property (meta_class, "InferiorClasses",
-                      make_fcn_handle (class_get_inferiorclasses, "meta.class>get.InferiorClasses"),
-                      "public", Matrix (), "private"));
-  meta_class.install_property
-      (make_property  (meta_class, "Methods",
-                       make_fcn_handle (class_get_methods, "meta.class>get.Methods"),
-                       "public", Matrix (), "private"));
-  meta_class.install_property
-      (make_property  (meta_class, "MethodList",
-                       make_fcn_handle (class_get_methods, "meta.class>get.MethodList"),
-                       "public", Matrix (), "private"));
-  meta_class.install_property (make_attribute (meta_class, "Name"));
-  meta_class.install_property
-      (make_property  (meta_class, "Properties",
-                       make_fcn_handle (class_get_properties, "meta.class>get.Properties"),
-                       "public", Matrix (), "private"));
-  meta_class.install_property
-      (make_property  (meta_class, "PropertyList",
-                       make_fcn_handle (class_get_properties, "meta.class>get.PropertyList"),
-                       "public", Matrix (), "private"));
-  meta_class.install_property (make_attribute (meta_class, "Sealed"));
-  meta_class.install_property
-      (make_property (meta_class, "SuperClasses",
-                      make_fcn_handle (class_get_superclasses, "meta.class>get.SuperClasses"),
-                      "public", Matrix (), "private"));
-  meta_class.install_property
-      (make_property (meta_class, "SuperClassList",
-                      make_fcn_handle (class_get_superclasses, "meta.class>get.SuperClassList"),
-                      "public", Matrix (), "private"));
+  tmp_meta_class.install_property
+    (make_attribute (tmp_meta_class, "Abstract"));
+
+  tmp_meta_class.install_property
+    (make_attribute (tmp_meta_class, "ConstructOnLoad"));
+
+  tmp_meta_class.install_property
+    (make_property  (tmp_meta_class, "ContainingPackage"));
+
+  tmp_meta_class.install_property
+    (make_property  (tmp_meta_class, "Description"));
+
+  tmp_meta_class.install_property
+    (make_property  (tmp_meta_class, "DetailedDescription"));
+
+  tmp_meta_class.install_property
+    (make_property  (tmp_meta_class, "Events"));
+
+  tmp_meta_class.install_property
+    (make_attribute (tmp_meta_class, "HandleCompatible"));
+
+  tmp_meta_class.install_property
+    (make_attribute (tmp_meta_class, "Hidden"));
+
+  tmp_meta_class.install_property
+    (make_property (tmp_meta_class, "InferiorClasses",
+                    make_fcn_handle (class_get_inferiorclasses,
+                                     "meta.class>get.InferiorClasses"),
+                    "public", Matrix (), "private"));
+
+  tmp_meta_class.install_property
+    (make_property (tmp_meta_class, "Methods",
+                    make_fcn_handle (class_get_methods,
+                                     "meta.class>get.Methods"),
+                    "public", Matrix (), "private"));
+
+  tmp_meta_class.install_property
+    (make_property (tmp_meta_class, "MethodList",
+                     make_fcn_handle (class_get_methods,
+                                      "meta.class>get.MethodList"),
+                    "public", Matrix (), "private"));
+
+  tmp_meta_class.install_property (make_attribute (tmp_meta_class, "Name"));
+
+  tmp_meta_class.install_property
+    (make_property (tmp_meta_class, "Properties",
+                    make_fcn_handle (class_get_properties,
+                                     "meta.class>get.Properties"),
+                    "public", Matrix (), "private"));
+
+  tmp_meta_class.install_property
+    (make_property (tmp_meta_class, "PropertyList",
+                    make_fcn_handle (class_get_properties,
+                                     "meta.class>get.PropertyList"),
+                    "public", Matrix (), "private"));
+
+  tmp_meta_class.install_property (make_attribute (tmp_meta_class, "Sealed"));
+
+  tmp_meta_class.install_property
+    (make_property (tmp_meta_class, "SuperClasses",
+                    make_fcn_handle (class_get_superclasses,
+                                     "meta.class>get.SuperClasses"),
+                    "public", Matrix (), "private"));
+
+  tmp_meta_class.install_property
+    (make_property (tmp_meta_class, "SuperClassList",
+                    make_fcn_handle (class_get_superclasses,
+                                     "meta.class>get.SuperClassList"),
+                    "public", Matrix (), "private"));
+
   // meta.class methods
-  meta_class.install_method (make_method (meta_class, "fromName", class_fromName,
-                                          "public", true));
-  meta_class.install_method (make_method (meta_class, "fevalStatic",
-                                          class_fevalStatic,
-                                          "public", false));
-  meta_class.install_method (make_method (meta_class, "getConstant",
-                                          class_getConstant,
-                                          "public", false));
-  meta_class.install_method (make_method (meta_class, "eq", class_eq));
-  meta_class.install_method (make_method (meta_class, "ne", class_ne));
-  meta_class.install_method (make_method (meta_class, "lt", class_lt));
-  meta_class.install_method (make_method (meta_class, "le", class_le));
-  meta_class.install_method (make_method (meta_class, "gt", class_gt));
-  meta_class.install_method (make_method (meta_class, "ge", class_ge));
+  tmp_meta_class.install_method
+    (make_method (tmp_meta_class, "fromName", class_fromName, "public", true));
+
+  tmp_meta_class.install_method
+    (make_method (tmp_meta_class, "fevalStatic", class_fevalStatic, "public",
+                  false));
+
+  tmp_meta_class.install_method
+    (make_method (tmp_meta_class, "getConstant", class_getConstant, "public",
+                  false));
+
+  tmp_meta_class.install_method (make_method (tmp_meta_class, "eq", class_eq));
+  tmp_meta_class.install_method (make_method (tmp_meta_class, "ne", class_ne));
+  tmp_meta_class.install_method (make_method (tmp_meta_class, "lt", class_lt));
+  tmp_meta_class.install_method (make_method (tmp_meta_class, "le", class_le));
+  tmp_meta_class.install_method (make_method (tmp_meta_class, "gt", class_gt));
+  tmp_meta_class.install_method (make_method (tmp_meta_class, "ge", class_ge));
 
   // meta.method properties
-  meta_method.install_property (make_attribute (meta_method, "Abstract"));
-  meta_method.install_property (make_attribute (meta_method, "Access"));
-  meta_method.install_property (make_attribute (meta_method, "DefiningClass"));
-  meta_method.install_property (make_attribute (meta_method, "Description"));
-  meta_method.install_property (make_attribute (meta_method, "DetailedDescription"));
-  meta_method.install_property (make_attribute (meta_method, "Hidden"));
-  meta_method.install_property (make_attribute (meta_method, "Name"));
-  meta_method.install_property (make_attribute (meta_method, "Sealed"));
-  meta_method.install_property (make_attribute (meta_method, "Static"));
+  tmp_meta_method.install_property
+    (make_attribute (tmp_meta_method, "Abstract"));
+
+  tmp_meta_method.install_property
+    (make_attribute (tmp_meta_method, "Access"));
+
+  tmp_meta_method.install_property
+    (make_attribute (tmp_meta_method, "DefiningClass"));
+
+  tmp_meta_method.install_property
+    (make_attribute (tmp_meta_method, "Description"));
+
+  tmp_meta_method.install_property
+    (make_attribute (tmp_meta_method, "DetailedDescription"));
+
+  tmp_meta_method.install_property
+    (make_attribute (tmp_meta_method, "Hidden"));
+
+  tmp_meta_method.install_property
+    (make_attribute (tmp_meta_method, "Name"));
+
+  tmp_meta_method.install_property
+    (make_attribute (tmp_meta_method, "Sealed"));
+
+  tmp_meta_method.install_property
+    (make_attribute (tmp_meta_method, "Static"));
 
   // meta.property properties
-  meta_property.install_property (make_attribute (meta_property, "Name"));
-  meta_property.install_property (make_attribute (meta_property, "Description"));
-  meta_property.install_property (make_attribute (meta_property, "DetailedDescription"));
-  meta_property.install_property (make_attribute (meta_property, "Abstract"));
-  meta_property.install_property (make_attribute (meta_property, "Constant"));
-  meta_property.install_property (make_attribute (meta_property, "GetAccess"));
-  meta_property.install_property (make_attribute (meta_property, "SetAccess"));
-  meta_property.install_property (make_attribute (meta_property, "Dependent"));
-  meta_property.install_property (make_attribute (meta_property, "Transient"));
-  meta_property.install_property (make_attribute (meta_property, "Hidden"));
-  meta_property.install_property (make_attribute (meta_property, "GetObservable"));
-  meta_property.install_property (make_attribute (meta_property, "SetObservable"));
-  meta_property.install_property (make_attribute (meta_property, "GetMethod"));
-  meta_property.install_property (make_attribute (meta_property, "SetMethod"));
-  meta_property.install_property (make_attribute (meta_property, "DefiningClass"));
-  meta_property.install_property
-      (make_property (meta_property, "DefaultValue",
-                      make_fcn_handle (property_get_defaultvalue, "meta.property>get.DefaultValue"),
-                      "public", Matrix (), "private"));
-  meta_property.install_property (make_attribute (meta_property, "HasDefault"));
+  tmp_meta_property.install_property
+    (make_attribute (tmp_meta_property, "Name"));
+
+  tmp_meta_property.install_property
+    (make_attribute (tmp_meta_property, "Description"));
+
+  tmp_meta_property.install_property
+    (make_attribute (tmp_meta_property, "DetailedDescription"));
+
+  tmp_meta_property.install_property
+    (make_attribute (tmp_meta_property, "Abstract"));
+
+  tmp_meta_property.install_property
+    (make_attribute (tmp_meta_property, "Constant"));
+
+  tmp_meta_property.install_property
+    (make_attribute (tmp_meta_property, "GetAccess"));
+
+  tmp_meta_property.install_property
+    (make_attribute (tmp_meta_property, "SetAccess"));
+
+  tmp_meta_property.install_property
+    (make_attribute (tmp_meta_property, "Dependent"));
+
+  tmp_meta_property.install_property
+    (make_attribute (tmp_meta_property, "Transient"));
+
+  tmp_meta_property.install_property
+    (make_attribute (tmp_meta_property, "Hidden"));
+
+  tmp_meta_property.install_property
+    (make_attribute (tmp_meta_property, "GetObservable"));
+
+  tmp_meta_property.install_property
+    (make_attribute (tmp_meta_property, "SetObservable"));
+
+  tmp_meta_property.install_property
+    (make_attribute (tmp_meta_property, "GetMethod"));
+
+  tmp_meta_property.install_property
+    (make_attribute (tmp_meta_property, "SetMethod"));
+
+  tmp_meta_property.install_property
+    (make_attribute (tmp_meta_property, "DefiningClass"));
+
+  tmp_meta_property.install_property
+    (make_property (tmp_meta_property, "DefaultValue",
+                    make_fcn_handle (property_get_defaultvalue,
+                                     "meta.property>get.DefaultValue"),
+                    "public", Matrix (), "private"));
+
+  tmp_meta_property.install_property
+    (make_attribute (tmp_meta_property, "HasDefault"));
+
   // meta.property events
   // FIXME: add events
 
   // handle methods
-  handle.install_method (make_method (handle, "delete", handle_delete));
+
+  tmp_handle.install_method
+    (make_method (tmp_handle, "delete", handle_delete));
 
   // meta.package properties
-  meta_package.install_property (make_attribute (meta_package, "Name"));
-  meta_package.install_property (make_property  (meta_package, "ContainingPackage"));
-  meta_package.install_property
-      (make_property (meta_package, "ClassList",
-                      make_fcn_handle (package_get_classes, "meta.package>get.ClassList"),
-                      "public", Matrix (), "private"));
-  meta_package.install_property
-      (make_property (meta_package, "Classes",
-                      make_fcn_handle (package_get_classes, "meta.package>get.Classes"),
-                      "public", Matrix (), "private"));
-  meta_package.install_property
-      (make_property (meta_package, "FunctionList",
-                      make_fcn_handle (package_get_functions, "meta.package>get.FunctionList"),
-                      "public", Matrix (), "private"));
-  meta_package.install_property
-      (make_property (meta_package, "Functions",
-                      make_fcn_handle (package_get_functions, "meta.package>get.Functions"),
-                      "public", Matrix (), "private"));
-  meta_package.install_property
-      (make_property (meta_package, "PackageList",
-                      make_fcn_handle (package_get_packages, "meta.package>get.PackageList"),
-                      "public", Matrix (), "private"));
-  meta_package.install_property
-      (make_property (meta_package, "Packages",
-                      make_fcn_handle (package_get_packages, "meta.package>get.Packages"),
-                      "public", Matrix (), "private"));
-  meta_package.install_method (make_method (meta_package, "fromName", package_fromName,
-                                            "public", true));
-  meta_package.install_method (make_method (meta_package, "getAllPackages", package_getAllPackages,
-                                            "public", true));
+
+  tmp_meta_package.install_property
+    (make_attribute (tmp_meta_package, "Name"));
+
+  tmp_meta_package.install_property
+    (make_property  (tmp_meta_package, "ContainingPackage"));
+
+  tmp_meta_package.install_property
+    (make_property (tmp_meta_package, "ClassList",
+                    make_fcn_handle (package_get_classes,
+                                     "meta.package>get.ClassList"),
+                    "public", Matrix (), "private"));
+
+  tmp_meta_package.install_property
+    (make_property (tmp_meta_package, "Classes",
+                    make_fcn_handle (package_get_classes,
+                                     "meta.package>get.Classes"),
+                    "public", Matrix (), "private"));
+
+  tmp_meta_package.install_property
+    (make_property (tmp_meta_package, "FunctionList",
+                    make_fcn_handle (package_get_functions,
+                                     "meta.package>get.FunctionList"),
+                    "public", Matrix (), "private"));
+
+  tmp_meta_package.install_property
+    (make_property (tmp_meta_package, "Functions",
+                    make_fcn_handle (package_get_functions,
+                                     "meta.package>get.Functions"),
+                    "public", Matrix (), "private"));
+
+  tmp_meta_package.install_property
+    (make_property (tmp_meta_package, "PackageList",
+                      make_fcn_handle (package_get_packages,
+                                       "meta.package>get.PackageList"),
+                    "public", Matrix (), "private"));
+
+  tmp_meta_package.install_property
+    (make_property (tmp_meta_package, "Packages",
+                    make_fcn_handle (package_get_packages,
+                                     "meta.package>get.Packages"),
+                    "public", Matrix (), "private"));
+
+  tmp_meta_package.install_method
+    (make_method (tmp_meta_package, "fromName", package_fromName,
+                  "public", true));
+
+  tmp_meta_package.install_method
+    (make_method (tmp_meta_package, "getAllPackages", package_getAllPackages,
+                  "public", true));
 
   // create "meta" package
-  cdef_package package_meta = cdef_package::_meta = make_package ("meta");
-  package_meta.install_class (meta_class,       "class");
-  package_meta.install_class (meta_property,    "property");
-  package_meta.install_class (meta_method,      "method");
-  package_meta.install_class (meta_package,     "package");
-  package_meta.install_class (meta_event,       "event");
-  package_meta.install_class (meta_dynproperty, "dynproperty");
-
-  symbol_table& symtab = interp.get_symbol_table ();
+  cdef_package package_meta
+    = m_meta
+    = make_package ("meta");
+
+  package_meta.install_class (tmp_meta_class, "class");
+  package_meta.install_class (tmp_meta_property, "property");
+  package_meta.install_class (tmp_meta_method, "method");
+  package_meta.install_class (tmp_meta_package, "package");
+  package_meta.install_class (tmp_meta_event, "event");
+  package_meta.install_class (tmp_meta_dynproperty, "dynproperty");
+
+  symbol_table& symtab = m_interpreter.get_symbol_table ();
 
   // install built-in classes into the symbol table
   symtab.install_built_in_function
-    ("meta.class", octave_value (meta_class.get_constructor_function ()));
-  symtab.install_built_in_function
-    ("meta.method", octave_value (meta_method.get_constructor_function ()));
+    ("meta.class",
+     octave_value (tmp_meta_class.get_constructor_function ()));
+
   symtab.install_built_in_function
-    ("meta.property", octave_value (meta_property.get_constructor_function ()));
-  symtab.install_built_in_function
-    ("meta.package", octave_value (meta_package.get_constructor_function ()));
-  symtab.install_built_in_function
-    ("meta.event", octave_value (meta_event.get_constructor_function ()));
+    ("meta.method",
+     octave_value (tmp_meta_method.get_constructor_function ()));
+
   symtab.install_built_in_function
-    ("meta.dynproperty", octave_value (meta_dynproperty.get_constructor_function ()));
-}
-
-//----------------------------------------------------------------------------
-
-cdef_manager *cdef_manager::instance = nullptr;
-
-void
-cdef_manager::create_instance (void)
-{
-  instance = new cdef_manager ();
-
-  if (instance)
-    singleton_cleanup_list::add (cleanup_instance);
+    ("meta.property",
+     octave_value (tmp_meta_property.get_constructor_function ()));
+
+  symtab.install_built_in_function
+    ("meta.package",
+     octave_value (tmp_meta_package.get_constructor_function ()));
+
+  symtab.install_built_in_function
+    ("meta.event",
+     octave_value (tmp_meta_event.get_constructor_function ()));
+
+  symtab.install_built_in_function
+    ("meta.dynproperty",
+     octave_value (tmp_meta_dynproperty.get_constructor_function ()));
 }
 
 cdef_class
-cdef_manager::do_find_class (const std::string& name,
-                             bool error_if_not_found, bool load_if_not_found)
+cdef_manager::find_class (const std::string& name, bool error_if_not_found,
+                          bool load_if_not_found)
 {
-  std::map<std::string, cdef_class>::iterator it = all_classes.find (name);
-
-  if (it == all_classes.end ())
+  std::map<std::string, cdef_class>::iterator it = m_all_classes.find (name);
+
+  if (it == m_all_classes.end ())
     {
       if (load_if_not_found)
         {
           octave_value ov_cls;
 
           size_t pos = name.rfind ('.');
 
           if (pos == std::string::npos)
             {
               symbol_table& symtab
-                = octave::__get_symbol_table__ ("cdef_manager::do_find_class");
+                = octave::__get_symbol_table__ ("cdef_manager::find_class");
 
               ov_cls = symtab.find (name);
             }
           else
             {
               std::string pack_name = name.substr (0, pos);
 
-              cdef_package pack = do_find_package (pack_name, false, true);
+              cdef_package pack = find_package (pack_name, false, true);
 
               if (pack.ok ())
                 ov_cls = pack.find (name.substr (pos+1));
             }
 
           if (ov_cls.is_defined ())
-            it = all_classes.find (name);
+            it = m_all_classes.find (name);
         }
     }
 
-  if (it == all_classes.end ())
+  if (it == m_all_classes.end ())
     {
       if (error_if_not_found)
         error ("class not found: %s", name.c_str ());
     }
   else
     {
       cdef_class cls = it->second;
 
       if (! cls.is_builtin ())
         cls = lookup_class (cls);
 
       if (cls.ok ())
         return cls;
       else
-        all_classes.erase (it);
+        m_all_classes.erase (it);
     }
 
   return cdef_class ();
 }
 
-octave_function*
-cdef_manager::do_find_method_symbol (const std::string& method_name,
-                                     const std::string& class_name)
+octave_function *
+cdef_manager::find_method_symbol (const std::string& method_name,
+                                  const std::string& class_name)
 {
   octave_function *retval = nullptr;
 
   cdef_class cls = find_class (class_name, false, false);
 
   if (cls.ok ())
     {
       cdef_method meth = cls.find_method (method_name);
@@ -3592,36 +3724,35 @@ cdef_manager::do_find_method_symbol (con
       if (meth.ok ())
         retval = new octave_classdef_meta (meth);
     }
 
   return retval;
 }
 
 cdef_package
-cdef_manager::do_find_package (const std::string& name,
-                               bool error_if_not_found,
-                               bool load_if_not_found)
+cdef_manager::find_package (const std::string& name, bool error_if_not_found,
+                            bool load_if_not_found)
 {
   cdef_package retval;
 
   std::map<std::string, cdef_package>::const_iterator it
-    = all_packages.find (name);
-
-  if (it != all_packages.end ())
+    = m_all_packages.find (name);
+
+  if (it != m_all_packages.end ())
     {
       retval = it->second;
 
       if (! retval.ok ())
         error ("invalid package `%s'", name.c_str ());
     }
   else
     {
       octave::load_path& lp
-        = octave::__get_load_path__ ("cdef_manager::do_find_package");
+        = octave::__get_load_path__ ("cdef_manager::find_package");
 
       if (load_if_not_found && lp.find_package (name))
         {
           size_t pos = name.find ('.');
 
           if (pos == std::string::npos)
             retval = make_package (name, "");
           else
@@ -3633,18 +3764,18 @@ cdef_manager::do_find_package (const std
         }
       else if (error_if_not_found)
         error ("unknown package `%s'", name.c_str ());
     }
 
   return retval;
 }
 
-octave_function*
-cdef_manager::do_find_package_symbol (const std::string& pack_name)
+octave_function *
+cdef_manager::find_package_symbol (const std::string& pack_name)
 {
   octave_function *retval = nullptr;
 
   cdef_package pack = find_package (pack_name, false);
 
   if (pack.ok ())
     retval = new octave_classdef_meta (pack);
 
diff --git a/libinterp/octave-value/ov-classdef.h b/libinterp/octave-value/ov-classdef.h
--- a/libinterp/octave-value/ov-classdef.h
+++ b/libinterp/octave-value/ov-classdef.h
@@ -5,17 +5,17 @@ Copyright (C) 2012-2017 Michael Goffioul
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 3 of the License, or
 (at your option) any later version.
 
 Octave is distributed in the hope that it will be useful, but
-WITHOUT ANY WARRANTY; without even the implied warranty of
+qWITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
@@ -27,17 +27,16 @@ along with Octave; see the file COPYING.
 
 #include <map>
 #include <set>
 #include <string>
 
 #include "oct-map.h"
 #include "oct-refcount.h"
 #include "ov-base.h"
-#include "symtab.h"
 
 class cdef_object;
 class cdef_class;
 class cdef_property;
 class cdef_method;
 class cdef_package;
 
 namespace octave
@@ -51,17 +50,21 @@ namespace octave
 // cdef_object, such that it can contain cdef_object objects.
 class
 cdef_object_rep
 {
 public:
   friend class cdef_object;
 
 public:
-  cdef_object_rep (void) : refcount (1) { }
+
+  cdef_object_rep (void) : refcount (1)
+  { }
+
+  cdef_object_rep& operator = (const cdef_object_rep&) = delete;
 
   virtual ~cdef_object_rep (void) = default;
 
   virtual cdef_class get_class (void) const;
 
   virtual void set_class (const cdef_class&)
   { err_invalid_object ("set_class"); }
 
@@ -164,45 +167,44 @@ public:
   {
     if (--refcount == static_count ())
       destroy ();
   }
 
   virtual dim_vector dims (void) const { return dim_vector (); }
 
 protected:
+
   // Reference count
   octave::refcount<octave_idx_type> refcount;
 
 protected:
-  // Restricted copying
+
+  // Restricted copying.
+
   cdef_object_rep (const cdef_object_rep&)
-    : refcount (1) { }
+    : refcount (1)
+  { }
 
 private:
-  // No assignment
-  cdef_object_rep& operator = (const cdef_object_rep& );
 
   OCTAVE_NORETURN void err_invalid_object (const char *who) const
   { error ("%s: invalid object", who); }
 };
 
 class
 cdef_object
 {
 public:
   // FIXME: use a null object
   cdef_object (void)
     : rep (new cdef_object_rep ()) { }
 
   cdef_object (const cdef_object& obj)
-    : rep (obj.rep)
-  {
-    rep->refcount++;
-  }
+    : rep (obj.rep) { rep->refcount++; }
 
   cdef_object (cdef_object_rep *r)
     : rep (r) { }
 
   virtual ~cdef_object (void)
   { rep->release (); }
 
   cdef_object& operator = (const cdef_object& obj)
@@ -561,23 +563,23 @@ private:
 
 class
 cdef_meta_object : public cdef_object
 {
 public:
   cdef_meta_object (void)
     : cdef_object () { }
 
+  // Object consistency is checked in sub-classes.
   cdef_meta_object (const cdef_meta_object& obj)
     : cdef_object (obj) { }
 
   cdef_meta_object (cdef_meta_object_rep *r)
     : cdef_object (r) { }
 
-  // Object consistency is checked in sub-classes.
   cdef_meta_object (const cdef_object& obj)
     : cdef_object (obj) { }
 
   ~cdef_meta_object (void) = default;
 
   bool is_class (void) const { return get_rep ()->is_class (); }
 
   bool is_property (void) const { return get_rep ()->is_property (); }
@@ -855,21 +857,16 @@ public:
 
   bool is_handle_class (void) const
   { return get_rep ()->is_handle_class (); }
 
   void mark_as_meta_class (void) { get_rep ()->mark_as_meta_class (); }
 
   bool is_meta_class (void) const { return get_rep ()->is_meta_class (); }
 
-  static const cdef_class& meta_class (void) { return _meta_class; }
-  static const cdef_class& meta_property (void) { return _meta_property; }
-  static const cdef_class& meta_method (void) { return _meta_method; }
-  static const cdef_class& meta_package (void) { return _meta_package; }
-
   void register_object (void) { get_rep ()->register_object (); }
 
   void unregister_object (void) { get_rep ()->unregister_object (); }
 
 public:
   enum
   {
     property_normal,
@@ -883,21 +880,16 @@ private:
 
   const cdef_class_rep * get_rep (void) const
   { return dynamic_cast<const cdef_class_rep *> (cdef_object::get_rep ()); }
 
   friend bool operator == (const cdef_class&, const cdef_class&);
   friend bool operator != (const cdef_class&, const cdef_class&);
   friend bool operator < (const cdef_class&, const cdef_class&);
 
-  static cdef_class _meta_class;
-  static cdef_class _meta_property;
-  static cdef_class _meta_method;
-  static cdef_class _meta_package;
-
   friend void install_classdef (octave::interpreter& interp);
 };
 
 inline bool
 operator == (const cdef_class& clsa, const cdef_class& clsb)
 // FIXME: is this really the right way to check class equality?
 { return (clsa.get_rep () == clsb.get_rep ()); }
 
@@ -1371,27 +1363,23 @@ public:
 
   Cell get_packages (void) const
   { return get_rep ()->get_packages (); }
 
   std::string get_name (void) const { return get_rep ()->get_name (); }
 
   octave_value find (const std::string& nm) { return get_rep ()->find (nm); }
 
-  static const cdef_package& meta (void) { return _meta; }
-
 private:
   cdef_package_rep * get_rep (void)
   { return dynamic_cast<cdef_package_rep *> (cdef_object::get_rep ()); }
 
   const cdef_package_rep * get_rep (void) const
   { return dynamic_cast<const cdef_package_rep *> (cdef_object::get_rep ()); }
 
-  static cdef_package _meta;
-
   friend void install_classdef (octave::interpreter& interp);
 };
 
 class
 octave_classdef : public octave_base_value
 {
 public:
   octave_classdef (void)
@@ -1518,145 +1506,87 @@ to_cdef (const cdef_object& obj)
 
 OCTINTERP_API void install_classdef (octave::interpreter& interp);
 
 class
 cdef_manager
 {
 public:
 
-  static cdef_class find_class (const std::string& name,
-                                bool error_if_not_found = true,
-                                bool load_if_not_found = true)
-  {
-    if (instance_ok ())
-      return instance->do_find_class (name, error_if_not_found,
-                                      load_if_not_found);
+  cdef_manager (octave::interpreter& interp)
+    : m_interpreter (interp), m_all_classes (), m_all_packages (),
+      m_meta_class (), m_meta_property (), m_meta_method (),
+      m_meta_package (), m_meta ()
+  { }
+
+  // No copying!
+
+  cdef_manager (const cdef_manager&) = delete;
+
+  cdef_manager& operator = (const cdef_manager&) = delete;
+
+  ~cdef_manager (void) = default;
 
-    return cdef_class ();
-  }
+  void initialize (void);
+
+  cdef_class find_class (const std::string& name, bool error_if_not_found = true,
+                         bool load_if_not_found = true);
+
+  octave_function * find_method_symbol (const std::string& method_name,
+                                        const std::string& class_name);
 
-  static octave_function * find_method_symbol (const std::string& method_name,
-      const std::string& class_name)
+  cdef_package find_package (const std::string& name,
+                             bool error_if_not_found = true,
+                             bool load_if_not_found = true);
+
+  octave_function * find_package_symbol (const std::string& pack_name);
+
+  void register_class (const cdef_class& cls)
   {
-    if (instance_ok ())
-      return instance->do_find_method_symbol (method_name, class_name);
-
-    return 0;
-  }
-
-  static cdef_package find_package (const std::string& name,
-                                    bool error_if_not_found = true,
-                                    bool load_if_not_found = true)
-  {
-    if (instance_ok ())
-      return instance->do_find_package (name, error_if_not_found,
-                                        load_if_not_found);
-
-    return cdef_package ();
+    m_all_classes[cls.get_name ()] = cls;
   }
 
-  static octave_function * find_package_symbol (const std::string& pack_name)
+  void unregister_class (const cdef_class& cls)
   {
-    if (instance_ok ())
-      return instance->do_find_package_symbol (pack_name);
-
-    return 0;
+    m_all_classes.erase(cls.get_name ());
   }
 
-  static void register_class (const cdef_class& cls)
+  void register_package (const cdef_package& pkg)
   {
-    if (instance_ok ())
-      instance->do_register_class (cls);
+    m_all_packages[pkg.get_name ()] = pkg;
   }
 
-  static void unregister_class (const cdef_class& cls)
+  void unregister_package (const cdef_package& pkg)
   {
-    if (instance_ok ())
-      instance->do_unregister_class (cls);
+    m_all_packages.erase (pkg.get_name ());
   }
 
-  static void register_package (const cdef_package& pkg)
-  {
-    if (instance_ok ())
-      instance->do_register_package (pkg);
-  }
+  const cdef_class& meta_class (void) const { return m_meta_class; }
+  const cdef_class& meta_property (void) const { return m_meta_property; }
+  const cdef_class& meta_method (void) const { return m_meta_method; }
+  const cdef_class& meta_package (void) const { return m_meta_package; }
 
-  static void unregister_package (const cdef_package& pkg)
-  {
-    if (instance_ok ())
-      instance->do_unregister_package (pkg);
-  }
+  const cdef_package& meta (void) const { return m_meta; }
 
 private:
 
-  cdef_manager (void) { }
-
-  cdef_manager (const cdef_manager&);
-
-  cdef_manager& operator = (const cdef_manager&);
-
-  ~cdef_manager (void) = default;
-
-  static void create_instance (void);
-
-  static bool instance_ok (void)
-  {
-    bool retval = true;
-
-    if (! instance)
-      create_instance ();
-
-    if (! instance)
-      error ("unable to create cdef_manager!");
-
-    return retval;
-  }
-
-  static void cleanup_instance (void)
-  {
-    delete instance;
-
-    instance = 0;
-  }
-
-  cdef_class do_find_class (const std::string& name, bool error_if_not_found,
-                            bool load_if_not_found);
-
-  octave_function * do_find_method_symbol (const std::string& method_name,
-                                           const std::string& class_name);
-
-  cdef_package do_find_package (const std::string& name,
-                                bool error_if_not_found,
-                                bool load_if_not_found);
-
-  octave_function * do_find_package_symbol (const std::string& pack_name);
-
-  void do_register_class (const cdef_class& cls)
-  { all_classes[cls.get_name ()] = cls; }
-
-  void do_unregister_class (const cdef_class& cls)
-  { all_classes.erase(cls.get_name ()); }
-
-  void do_register_package (const cdef_package& pkg)
-  { all_packages[pkg.get_name ()] = pkg; }
-
-  void do_unregister_package (const cdef_package& pkg)
-  { all_packages.erase(pkg.get_name ()); }
-
-private:
-
-  // The single cdef_manager instance
-  static cdef_manager *instance;
+  octave::interpreter& m_interpreter;
 
   // All registered/loaded classes
-  std::map<std::string, cdef_class> all_classes;
+  std::map<std::string, cdef_class> m_all_classes;
 
   // All registered/loaded packages
-  std::map<std::string, cdef_package> all_packages;
+  std::map<std::string, cdef_package> m_all_packages;
+
+  cdef_class m_meta_class;
+  cdef_class m_meta_property;
+  cdef_class m_meta_method;
+  cdef_class m_meta_package;
+
+  cdef_package m_meta;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
