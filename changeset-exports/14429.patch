# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1330892470 28800
#      Sun Mar 04 12:21:10 2012 -0800
# Node ID eff4a5933e28539ebcb120d0f42c715d94e7511f
# Parent  099bd779466c599a3fb545d155d1e6a1b98b4d59
Update %!tests in src/ directory with Octave coding conventions.

* data.cc, defaults.cc, dirfns.cc, file-io.cc, graphics.cc, mappers.cc,
oct-map.cc, octave.cc, ov-base.cc, ov-bool-mat.cc, ov-cell.cc,
ov-fcn-handle.cc, ov-fcn-inline.cc, ov-flt-re-mat.cc, ov-int16.cc, ov-int32.cc,
ov-int64.cc, ov-int8.cc, ov-null-mat.cc, ov-oncleanup.cc, ov-range.cc,
ov-re-mat.cc, ov-struct.cc, ov-typeinfo.cc, ov-uint16.cc, ov-uint32.cc,
ov-uint64.cc, ov-uint8.cc, ov.cc, pr-output.cc, pt-binop.cc, pt-eval.cc,
pt-idx.cc, pt-mat.cc, sighandlers.cc, strfns.cc, symtab.cc, syscalls.cc,
sysdep.cc, toplev.cc, utils.cc, variables.cc: Update %!tests in src/ directory
with Octave coding conventions.

diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -127,37 +127,35 @@ If the optional argument @var{dim} is su
 @var{dim}.\n\
 @seealso{any}\n\
 @end deftypefn")
 {
   ANY_ALL (all);
 }
 
 /*
-
 %!test
 %! x = ones (3);
 %! x(1,1) = 0;
-%! assert((all (all (rand (3) + 1) == [1, 1, 1]) == 1
-%! && all (all (x) == [0, 1, 1]) == 1
-%! && all (x, 1) == [0, 1, 1]
-%! && all (x, 2) == [0; 1; 1]));
+%! assert (all (all (rand (3) + 1) == [1, 1, 1]) == 1);
+%! assert (all (all (x) == [0, 1, 1]) == 1);
+%! assert (all (x, 1) == [0, 1, 1]);
+%! assert (all (x, 2) == [0; 1; 1]);
 
 %!test
-%! x = ones (3, 'single');
+%! x = ones (3, "single");
 %! x(1,1) = 0;
-%! assert((all (all (single (rand (3) + 1)) == [1, 1, 1]) == 1
-%! && all (all (x) == [0, 1, 1]) == 1
-%! && all (x, 1) == [0, 1, 1]
-%! && all (x, 2) == [0; 1; 1]));
-
-%!error <Invalid call to all> all ();
-%!error <Invalid call to all> all (1, 2, 3);
-
- */
+%! assert (all (all (single (rand (3) + 1)) == [1, 1, 1]) == 1);
+%! assert (all (all (x) == [0, 1, 1]) == 1);
+%! assert (all (x, 1) == [0, 1, 1]);
+%! assert (all (x, 2) == [0; 1; 1]);
+
+%!error all ()
+%!error all (1, 2, 3)
+*/
 
 DEFUN (any, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} any (@var{x})\n\
 @deftypefnx {Built-in Function} {} any (@var{x}, @var{dim})\n\
 For a vector argument, return true (logical 1) if any element of the vector\n\
 is nonzero.\n\
 \n\
@@ -183,37 +181,35 @@ any (eye (2, 4), 2)\n\
 @end example\n\
 @seealso{all}\n\
 @end deftypefn")
 {
   ANY_ALL (any);
 }
 
 /*
-
 %!test
 %! x = zeros (3);
 %! x(3,3) = 1;
-%! assert((all (any (x) == [0, 0, 1]) == 1
-%! && all (any (ones (3)) == [1, 1, 1]) == 1
-%! && any (x, 1) == [0, 0, 1]
-%! && any (x, 2) == [0; 0; 1]));
+%! assert (all (any (x) == [0, 0, 1]) == 1);
+%! assert (all (any (ones (3)) == [1, 1, 1]) == 1);
+%! assert (any (x, 1) == [0, 0, 1]);
+%! assert (any (x, 2) == [0; 0; 1]);
 
 %!test
-%! x = zeros (3,'single');
+%! x = zeros (3, "single");
 %! x(3,3) = 1;
-%! assert((all (any (x) == [0, 0, 1]) == 1
-%! && all (any (ones (3, 'single')) == [1, 1, 1]) == 1
-%! && any (x, 1) == [0, 0, 1]
-%! && any (x, 2) == [0; 0; 1]));
-
-%!error <Invalid call to any> any ();
-%!error <Invalid call to any> any (1, 2, 3);
-
- */
+%! assert (all (any (x) == [0, 0, 1]) == 1);
+%! assert (all (any (ones (3, "single")) == [1, 1, 1]) == 1);
+%! assert (any (x, 1) == [0, 0, 1]);
+%! assert (any (x, 2) == [0; 0; 1]);
+
+%!error any ()
+%!error any (1, 2, 3)
+*/
 
 // These mapping functions may also be useful in other places, eh?
 
 DEFUN (atan2, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atan2 (@var{y}, @var{x})\n\
 Compute atan (@var{y} / @var{x}) for corresponding elements of @var{y}\n\
 and @var{x}.  Signal an error if @var{y} and @var{x} do not match in size\n\
@@ -278,29 +274,28 @@ and orientation.\n\
 %!assert (size (atan2 (1, 2)), [1, 1])
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! v = [0, pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6, 0];
 %! y = [0, rt3, 1, rt3, -rt3, -1, -rt3, 0];
 %! x = [1, 3, 1, 1, 1, 1, 3, 1];
-%! assert(atan2 (y, x), v, sqrt (eps));
+%! assert (atan2 (y, x), v, sqrt (eps));
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
-%! v = single([0, pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6, 0]);
-%! y = single([0, rt3, 1, rt3, -rt3, -1, -rt3, 0]);
-%! x = single([1, 3, 1, 1, 1, 1, 3, 1]);
-%! assert(atan2 (y, x), v, sqrt (eps('single')));
-
-%!error <Invalid call to atan2> atan2 ();
-%!error <Invalid call to atan2> atan2 (1, 2, 3);
-
+%! v = single ([0, pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6, 0]);
+%! y = single ([0, rt3, 1, rt3, -rt3, -1, -rt3, 0]);
+%! x = single ([1, 3, 1, 1, 1, 1, 3, 1]);
+%! assert (atan2 (y, x), v, sqrt (eps ("single")));
+
+%!error atan2 ()
+%!error atan2 (1, 2, 3)
 */
 
 
 static octave_value
 do_hypot (const octave_value& x, const octave_value& y)
 {
   octave_value retval;
 
@@ -392,18 +387,18 @@ hypot (hypot (hypot (@var{x}, @var{y}), 
 }
 
 /*
 %!assert (size (hypot (zeros (0, 2), zeros (0, 2))), [0, 2])
 %!assert (size (hypot (rand (2, 3, 4), zeros (2, 3, 4))), [2, 3, 4])
 %!assert (size (hypot (rand (2, 3, 4), 1)), [2, 3, 4])
 %!assert (size (hypot (1, rand (2, 3, 4))), [2, 3, 4])
 %!assert (size (hypot (1, 2)), [1, 1])
-%!assert (hypot (1:10, 1:10), sqrt(2) * [1:10], 16*eps)
-%!assert (hypot (single(1:10), single(1:10)), single(sqrt(2) * [1:10]));
+%!assert (hypot (1:10, 1:10), sqrt (2) * [1:10], 16*eps)
+%!assert (hypot (single (1:10), single (1:10)), single (sqrt (2) * [1:10]))
 */
 
 template<typename T, typename ET>
 void
 map_2_xlog2 (const Array<T>& x, Array<T>& f, Array<ET>& e)
 {
   f = Array<T>(x.dims ());
   e = Array<ET>(x.dims ());
@@ -493,26 +488,26 @@ and @var{e} is an integer.  If\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert(log2 ([1/4, 1/2, 1, 2, 4]), [-2, -1, 0, 1, 2]);
-%!assert(log2(Inf), Inf);
-%!assert(isnan(log2(NaN)));
-%!assert(log2(4*i), 2 + log2(1*i));
-%!assert(log2(complex(0,Inf)), Inf + log2(i));
+%!assert (log2 ([1/4, 1/2, 1, 2, 4]), [-2, -1, 0, 1, 2])
+%!assert (log2 (Inf), Inf)
+%!assert (isnan (log2 (NaN)))
+%!assert (log2 (4*i), 2 + log2 (1*i))
+%!assert (log2 (complex (0,Inf)), Inf + log2 (i))
 
 %!test
 %! [f, e] = log2 ([0,-1; 2,-4; Inf,-Inf]);
 %! assert (f, [0,-0.5; 0.5,-0.5; Inf,-Inf]);
-%! assert (e(1:2,:), [0,1;2,3])
+%! assert (e(1:2,:), [0,1;2,3]);
 
 %!test
 %! [f, e] = log2 (complex (zeros (3, 2), [0,-1; 2,-4; Inf,-Inf]));
 %! assert (f, complex (zeros (3, 2), [0,-0.5; 0.5,-0.5; Inf,-Inf]));
 %! assert (e(1:2,:), [0,1; 2,3]);
 */
 
 DEFUN (rem, args, ,
@@ -615,31 +610,31 @@ agree, or if either of the arguments is 
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
-%!assert(rem ([1, 2, 3; -1, -2, -3], 2), [1, 0, 1; -1, 0, -1]);
-%!assert(rem ([1, 2, 3; -1, -2, -3], 2 * ones (2, 3)),[1, 0, 1; -1, 0, -1]);
-%!error rem ();
-%!error rem (1, 2, 3);
-%!error rem ([1, 2], [3, 4, 5]);
-%!error rem (i, 1);
-%!assert(rem (uint8([1, 2, 3; -1, -2, -3]), uint8 (2)), uint8([1, 0, 1; -1, 0, -1]));
-%!assert(uint8(rem ([1, 2, 3; -1, -2, -3], 2 * ones (2, 3))),uint8([1, 0, 1; -1, 0, -1]));
-%!error rem (uint(8),int8(5));
-%!error rem (uint8([1, 2]), uint8([3, 4, 5]));
-
+%!assert (rem ([1, 2, 3; -1, -2, -3], 2), [1, 0, 1; -1, 0, -1])
+%!assert (rem ([1, 2, 3; -1, -2, -3], 2 * ones (2, 3)),[1, 0, 1; -1, 0, -1])
+%!assert (rem (uint8 ([1, 2, 3; -1, -2, -3]), uint8 (2)), uint8 ([1, 0, 1; -1, 0, -1]))
+%!assert (uint8 (rem ([1, 2, 3; -1, -2, -3], 2 * ones (2, 3))),uint8 ([1, 0, 1; -1, 0, -1]))
+
+%!error rem (uint (8), int8 (5))
+%!error rem (uint8 ([1, 2]), uint8 ([3, 4, 5]))
+%!error rem ()
+%!error rem (1, 2, 3)
+%!error rem ([1, 2], [3, 4, 5])
+%!error rem (i, 1)
 */
 
 /*
+
 %!assert (size (fmod (zeros (0, 2), zeros (0, 2))), [0, 2])
 %!assert (size (fmod (rand (2, 3, 4), zeros (2, 3, 4))), [2, 3, 4])
 %!assert (size (fmod (rand (2, 3, 4), 1)), [2, 3, 4])
 %!assert (size (fmod (1, rand (2, 3, 4))), [2, 3, 4])
 %!assert (size (fmod (1, 2)), [1, 1])
 */
 
 DEFALIAS (fmod, rem)
@@ -749,58 +744,58 @@ either of the arguments is complex.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 ## empty input test
-%!assert (isempty(mod([], [])));
+%!assert (isempty (mod ([], [])))
 
 ## x mod y, y != 0 tests
-%!assert (mod(5, 3), 2);
-%!assert (mod(-5, 3), 1);
-%!assert (mod(0, 3), 0);
-%!assert (mod([-5, 5, 0], [3, 3, 3]), [1, 2, 0]);
-%!assert (mod([-5; 5; 0], [3; 3; 3]), [1; 2; 0]);
-%!assert (mod([-5, 5; 0, 3], [3, 3 ; 3, 1]), [1, 2 ; 0, 0]);
+%!assert (mod (5, 3), 2)
+%!assert (mod (-5, 3), 1)
+%!assert (mod (0, 3), 0)
+%!assert (mod ([-5, 5, 0], [3, 3, 3]), [1, 2, 0])
+%!assert (mod ([-5; 5; 0], [3; 3; 3]), [1; 2; 0])
+%!assert (mod ([-5, 5; 0, 3], [3, 3 ; 3, 1]), [1, 2 ; 0, 0])
 
 ## x mod 0 tests
-%!assert (mod(5, 0), 5);
-%!assert (mod(-5, 0), -5);
-%!assert (mod([-5, 5, 0], [3, 0, 3]), [1, 5, 0]);
-%!assert (mod([-5; 5; 0], [3; 0; 3]), [1; 5; 0]);
-%!assert (mod([-5, 5; 0, 3], [3, 0 ; 3, 1]), [1, 5 ; 0, 0]);
-%!assert (mod([-5, 5; 0, 3], [0, 0 ; 0, 0]), [-5, 5; 0, 3]);
+%!assert (mod (5, 0), 5)
+%!assert (mod (-5, 0), -5)
+%!assert (mod ([-5, 5, 0], [3, 0, 3]), [1, 5, 0])
+%!assert (mod ([-5; 5; 0], [3; 0; 3]), [1; 5; 0])
+%!assert (mod ([-5, 5; 0, 3], [3, 0 ; 3, 1]), [1, 5 ; 0, 0])
+%!assert (mod ([-5, 5; 0, 3], [0, 0 ; 0, 0]), [-5, 5; 0, 3])
 
 ## mixed scalar/matrix tests
-%!assert (mod([-5, 5; 0, 3], 0), [-5, 5; 0, 3]);
-%!assert (mod([-5, 5; 0, 3], 3), [1, 2; 0, 0]);
-%!assert (mod(-5,[0,0; 0,0]), [-5, -5; -5, -5]);
-%!assert (mod(-5,[3,0; 3,1]), [1, -5; 1, 0]);
-%!assert (mod(-5,[3,2; 3,1]), [1, 1; 1, 0]);
+%!assert (mod ([-5, 5; 0, 3], 0), [-5, 5; 0, 3])
+%!assert (mod ([-5, 5; 0, 3], 3), [1, 2; 0, 0])
+%!assert (mod (-5, [0,0; 0,0]), [-5, -5; -5, -5])
+%!assert (mod (-5, [3,0; 3,1]), [1, -5; 1, 0])
+%!assert (mod (-5, [3,2; 3,1]), [1, 1; 1, 0])
 
 ## integer types
-%!assert (mod(uint8(5),uint8(4)),uint8(1))
-%!assert (mod(uint8([1:5]),uint8(4)),uint8([1,2,3,0,1]))
-%!assert (mod(uint8([1:5]),uint8(0)),uint8([1:5]))
-%!error (mod(uint8(5),int8(4)))
+%!assert (mod (uint8 (5), uint8 (4)), uint8 (1))
+%!assert (mod (uint8 ([1:5]), uint8 (4)), uint8 ([1,2,3,0,1]))
+%!assert (mod (uint8 ([1:5]), uint8 (0)), uint8 ([1:5]))
+%!error (mod (uint8 (5), int8 (4)))
 
 ## mixed integer/real types
-%!assert (mod(uint8(5),4),uint8(1))
-%!assert (mod(5,uint8(4)),uint8(1))
-%!assert (mod(uint8([1:5]),4),uint8([1,2,3,0,1]))
+%!assert (mod (uint8 (5), 4), uint8 (1))
+%!assert (mod (5, uint8 (4)), uint8 (1))
+%!assert (mod (uint8 ([1:5]), 4), uint8 ([1,2,3,0,1]))
 
 ## non-integer real numbers
 %!assert (mod (2.1, 0.1), 0)
 %!assert (mod (2.1, 0.2), 0.1, eps)
 */
 
-// FIXME Need to convert the reduction functions of this file for single precision
+// FIXME: Need to convert the reduction functions of this file for single precision
 
 #define NATIVE_REDUCTION_1(FCN, TYPE, DIM) \
   (arg.is_ ## TYPE ## _type ()) \
     { \
       TYPE ## NDArray tmp = arg. TYPE ##_array_value (); \
       \
       if (! error_state) \
         { \
@@ -1063,36 +1058,34 @@ Cumulative product of elements along dim
 \n\
 @seealso{prod, cumsum}\n\
 @end deftypefn")
 {
   DATA_REDUCTION (cumprod);
 }
 
 /*
-
-%!assert (cumprod ([1, 2, 3]), [1, 2, 6]);
-%!assert (cumprod ([-1; -2; -3]), [-1; 2; -6]);
-%!assert (cumprod ([i, 2+i, -3+2i, 4]), [i, -1+2i, -1-8i, -4-32i]);
-%!assert (cumprod ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i]), [1, 2, 3; i, 4i, 9i; -1+i, -8+8i, -27+27i]);
-
-%!assert (cumprod (single([1, 2, 3])), single([1, 2, 6]));
-%!assert (cumprod (single([-1; -2; -3])), single([-1; 2; -6]));
-%!assert (cumprod (single([i, 2+i, -3+2i, 4])), single([i, -1+2i, -1-8i, -4-32i]));
-%!assert (cumprod (single([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i])), single([1, 2, 3; i, 4i, 9i; -1+i, -8+8i, -27+27i]));
-
-%!error <Invalid call to cumprod> cumprod ();
-
-%!assert (cumprod ([2, 3; 4, 5], 1), [2, 3; 8, 15]);
-%!assert (cumprod ([2, 3; 4, 5], 2), [2, 6; 4, 20]);
-
-%!assert (cumprod (single([2, 3; 4, 5]), 1), single([2, 3; 8, 15]));
-%!assert (cumprod (single([2, 3; 4, 5]), 2), single([2, 6; 4, 20]));
-
- */
+%!assert (cumprod ([1, 2, 3]), [1, 2, 6])
+%!assert (cumprod ([-1; -2; -3]), [-1; 2; -6])
+%!assert (cumprod ([i, 2+i, -3+2i, 4]), [i, -1+2i, -1-8i, -4-32i])
+%!assert (cumprod ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i]), [1, 2, 3; i, 4i, 9i; -1+i, -8+8i, -27+27i])
+
+%!assert (cumprod (single ([1, 2, 3])), single ([1, 2, 6]))
+%!assert (cumprod (single ([-1; -2; -3])), single ([-1; 2; -6]))
+%!assert (cumprod (single ([i, 2+i, -3+2i, 4])), single ([i, -1+2i, -1-8i, -4-32i]))
+%!assert (cumprod (single ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i])), single ([1, 2, 3; i, 4i, 9i; -1+i, -8+8i, -27+27i]))
+
+%!assert (cumprod ([2, 3; 4, 5], 1), [2, 3; 8, 15])
+%!assert (cumprod ([2, 3; 4, 5], 2), [2, 6; 4, 20])
+
+%!assert (cumprod (single ([2, 3; 4, 5]), 1), single ([2, 3; 8, 15]))
+%!assert (cumprod (single ([2, 3; 4, 5]), 2), single ([2, 6; 4, 20]))
+
+%!error cumprod ()
+*/
 
 DEFUN (cumsum, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} cumsum (@var{x})\n\
 @deftypefnx {Built-in Function} {} cumsum (@var{x}, @var{dim})\n\
 @deftypefnx {Built-in Function} {} cumsum (@dots{}, \"native\")\n\
 @deftypefnx {Built-in Function} {} cumsum (@dots{}, \"double\")\n\
 @deftypefnx {Built-in Function} {} cumsum (@dots{}, \"extra\")\n\
@@ -1214,36 +1207,34 @@ See @code{sum} for an explanation of the
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
-%!assert (cumsum ([1, 2, 3]), [1, 3, 6]);
-%!assert (cumsum ([-1; -2; -3]), [-1; -3; -6]);
-%!assert (cumsum ([i, 2+i, -3+2i, 4]), [i, 2+2i, -1+4i, 3+4i]);
-%!assert (cumsum ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i]), [1, 2, 3; 1+i, 2+2i, 3+3i; 2+2i, 4+4i, 6+6i]);
-
-%!assert (cumsum (single([1, 2, 3])), single([1, 3, 6]));
-%!assert (cumsum (single([-1; -2; -3])), single([-1; -3; -6]));
-%!assert (cumsum (single([i, 2+i, -3+2i, 4])), single([i, 2+2i, -1+4i, 3+4i]));
-%!assert (cumsum (single([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i])), single([1, 2, 3; 1+i, 2+2i, 3+3i; 2+2i, 4+4i, 6+6i]));
-
-%!error <Invalid call to cumsum> cumsum ();
-
-%!assert (cumsum ([1, 2; 3, 4], 1), [1, 2; 4, 6]);
-%!assert (cumsum ([1, 2; 3, 4], 2), [1, 3; 3, 7]);
-
-%!assert (cumsum (single([1, 2; 3, 4]), 1), single([1, 2; 4, 6]));
-%!assert (cumsum (single([1, 2; 3, 4]), 2), single([1, 3; 3, 7]));
-
- */
+%!assert (cumsum ([1, 2, 3]), [1, 3, 6])
+%!assert (cumsum ([-1; -2; -3]), [-1; -3; -6])
+%!assert (cumsum ([i, 2+i, -3+2i, 4]), [i, 2+2i, -1+4i, 3+4i])
+%!assert (cumsum ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i]), [1, 2, 3; 1+i, 2+2i, 3+3i; 2+2i, 4+4i, 6+6i])
+
+%!assert (cumsum (single ([1, 2, 3])), single ([1, 3, 6]))
+%!assert (cumsum (single ([-1; -2; -3])), single ([-1; -3; -6]))
+%!assert (cumsum (single ([i, 2+i, -3+2i, 4])), single ([i, 2+2i, -1+4i, 3+4i]))
+%!assert (cumsum (single ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i])), single ([1, 2, 3; 1+i, 2+2i, 3+3i; 2+2i, 4+4i, 6+6i]))
+
+%!assert (cumsum ([1, 2; 3, 4], 1), [1, 2; 4, 6])
+%!assert (cumsum ([1, 2; 3, 4], 2), [1, 3; 3, 7])
+
+%!assert (cumsum (single ([1, 2; 3, 4]), 1), single ([1, 2; 4, 6]))
+%!assert (cumsum (single ([1, 2; 3, 4]), 2), single ([1, 3; 3, 7]))
+
+%!error cumsum ()
+*/
 
 DEFUN (diag, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{M} =} diag (@var{v})\n\
 @deftypefnx {Built-in Function} {@var{M} =} diag (@var{v}, @var{k})\n\
 @deftypefnx {Built-in Function} {@var{M} =} diag (@var{v}, @var{m}, @var{n})\n\
 @deftypefnx {Built-in Function} {@var{v} =} diag (@var{M})\n\
 @deftypefnx {Built-in Function} {@var{v} =} diag (@var{M}, @var{k})\n\
@@ -1303,114 +1294,110 @@ Given a matrix argument, instead of a ve
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
-%!assert(full (diag ([1; 2; 3])), [1, 0, 0; 0, 2, 0; 0, 0, 3]);
-%!assert(diag ([1; 2; 3], 1), [0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]);
-%!assert(diag ([1; 2; 3], 2), [0, 0, 1, 0, 0; 0, 0, 0, 2, 0; 0, 0, 0, 0, 3; 0, 0, 0, 0, 0; 0, 0, 0, 0, 0]);
-%!assert(diag ([1; 2; 3],-1), [0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]);
-%!assert(diag ([1; 2; 3],-2), [0, 0, 0, 0, 0; 0, 0, 0, 0, 0; 1, 0, 0, 0, 0; 0, 2, 0, 0, 0; 0, 0, 3, 0, 0]);
-
-%!assert(diag ([1, 0, 0; 0, 2, 0; 0, 0, 3]), [1; 2; 3]);
-%!assert(diag ([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0], 1), [1; 2; 3]);
-%!assert(diag ([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0], -1), [1; 2; 3]);
-%!assert(diag (ones(1, 0), 2), zeros (2));
-%!assert(diag (1:3, 4, 2), [1, 0; 0, 2; 0, 0; 0, 0]);
-
-%!assert(full (diag (single([1; 2; 3]))), single([1, 0, 0; 0, 2, 0; 0, 0, 3]));
-%!assert(diag (single([1; 2; 3]), 1), single([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]));
-%!assert(diag (single([1; 2; 3]), 2), single([0, 0, 1, 0, 0; 0, 0, 0, 2, 0; 0, 0, 0, 0, 3; 0, 0, 0, 0, 0; 0, 0, 0, 0, 0]));
-%!assert(diag (single([1; 2; 3]),-1), single([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]));
-%!assert(diag (single([1; 2; 3]),-2), single([0, 0, 0, 0, 0; 0, 0, 0, 0, 0; 1, 0, 0, 0, 0; 0, 2, 0, 0, 0; 0, 0, 3, 0, 0]));
-
-%!assert(diag (single([1, 0, 0; 0, 2, 0; 0, 0, 3])), single([1; 2; 3]));
-%!assert(diag (single([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]), 1), single([1; 2; 3]));
-%!assert(diag (single([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]), -1), single([1; 2; 3]));
-
-%!assert(diag (int8([1; 2; 3])), int8([1, 0, 0; 0, 2, 0; 0, 0, 3]));
-%!assert(diag (int8([1; 2; 3]), 1), int8([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]));
-%!assert(diag (int8([1; 2; 3]), 2), int8([0, 0, 1, 0, 0; 0, 0, 0, 2, 0; 0, 0, 0, 0, 3; 0, 0, 0, 0, 0; 0, 0, 0, 0, 0]));
-%!assert(diag (int8([1; 2; 3]),-1), int8([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]));
-%!assert(diag (int8([1; 2; 3]),-2), int8([0, 0, 0, 0, 0; 0, 0, 0, 0, 0; 1, 0, 0, 0, 0; 0, 2, 0, 0, 0; 0, 0, 3, 0, 0]));
-
-%!assert(diag (int8([1, 0, 0; 0, 2, 0; 0, 0, 3])), int8([1; 2; 3]));
-%!assert(diag (int8([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]), 1), int8([1; 2; 3]));
-%!assert(diag (int8([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]), -1), int8([1; 2; 3]));
-
-%% Test input validation
-%!error <Invalid call to diag> diag ();
-%!error <Invalid call to diag> diag (1,2,3,4);
-%!error diag (ones (2), 3, 3);
-%!error diag (1:3, -4, 3);
-
- */
+%!assert (full (diag ([1; 2; 3])), [1, 0, 0; 0, 2, 0; 0, 0, 3])
+%!assert (diag ([1; 2; 3], 1), [0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0])
+%!assert (diag ([1; 2; 3], 2), [0, 0, 1, 0, 0; 0, 0, 0, 2, 0; 0, 0, 0, 0, 3; 0, 0, 0, 0, 0; 0, 0, 0, 0, 0])
+%!assert (diag ([1; 2; 3],-1), [0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0])
+%!assert (diag ([1; 2; 3],-2), [0, 0, 0, 0, 0; 0, 0, 0, 0, 0; 1, 0, 0, 0, 0; 0, 2, 0, 0, 0; 0, 0, 3, 0, 0])
+
+%!assert (diag ([1, 0, 0; 0, 2, 0; 0, 0, 3]), [1; 2; 3])
+%!assert (diag ([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0], 1), [1; 2; 3])
+%!assert (diag ([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0], -1), [1; 2; 3])
+%!assert (diag (ones (1, 0), 2), zeros (2))
+%!assert (diag (1:3, 4, 2), [1, 0; 0, 2; 0, 0; 0, 0])
+
+%!assert (full (diag (single ([1; 2; 3]))), single ([1, 0, 0; 0, 2, 0; 0, 0, 3]))
+%!assert (diag (single ([1; 2; 3]), 1), single ([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]))
+%!assert (diag (single ([1; 2; 3]), 2), single ([0, 0, 1, 0, 0; 0, 0, 0, 2, 0; 0, 0, 0, 0, 3; 0, 0, 0, 0, 0; 0, 0, 0, 0, 0]))
+%!assert (diag (single ([1; 2; 3]),-1), single ([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]))
+%!assert (diag (single ([1; 2; 3]),-2), single ([0, 0, 0, 0, 0; 0, 0, 0, 0, 0; 1, 0, 0, 0, 0; 0, 2, 0, 0, 0; 0, 0, 3, 0, 0]))
+
+%!assert (diag (single ([1, 0, 0; 0, 2, 0; 0, 0, 3])), single ([1; 2; 3]))
+%!assert (diag (single ([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]), 1), single ([1; 2; 3]))
+%!assert (diag (single ([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]), -1), single ([1; 2; 3]))
+
+%!assert (diag (int8 ([1; 2; 3])), int8 ([1, 0, 0; 0, 2, 0; 0, 0, 3]))
+%!assert (diag (int8 ([1; 2; 3]), 1), int8 ([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]))
+%!assert (diag (int8 ([1; 2; 3]), 2), int8 ([0, 0, 1, 0, 0; 0, 0, 0, 2, 0; 0, 0, 0, 0, 3; 0, 0, 0, 0, 0; 0, 0, 0, 0, 0]))
+%!assert (diag (int8 ([1; 2; 3]),-1), int8 ([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]))
+%!assert (diag (int8 ([1; 2; 3]),-2), int8 ([0, 0, 0, 0, 0; 0, 0, 0, 0, 0; 1, 0, 0, 0, 0; 0, 2, 0, 0, 0; 0, 0, 3, 0, 0]))
+
+%!assert (diag (int8 ([1, 0, 0; 0, 2, 0; 0, 0, 3])), int8 ([1; 2; 3]))
+%!assert (diag (int8 ([0, 1, 0, 0; 0, 0, 2, 0; 0, 0, 0, 3; 0, 0, 0, 0]), 1), int8 ([1; 2; 3]))
+%!assert (diag (int8 ([0, 0, 0, 0; 1, 0, 0, 0; 0, 2, 0, 0; 0, 0, 3, 0]), -1), int8 ([1; 2; 3]))
+
+## Test input validation
+%!error diag ()
+%!error diag (1,2,3,4)
+%!error diag (ones (2), 3, 3)
+%!error diag (1:3, -4, 3)
+*/
 
 DEFUN (prod, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} prod (@var{x})\n\
 @deftypefnx {Built-in Function} {} prod (@var{x}, @var{dim})\n\
 Product of elements along dimension @var{dim}.  If @var{dim} is\n\
 omitted, it defaults to the first non-singleton dimension.\n\
 @seealso{cumprod, sum}\n\
 @end deftypefn")
 {
   DATA_REDUCTION (prod);
 }
 
 /*
-
-%!assert (prod ([1, 2, 3]), 6);
-%!assert (prod ([-1; -2; -3]), -6);
-%!assert (prod ([i, 2+i, -3+2i, 4]), -4 - 32i);
-%!assert (prod ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i]), [-1+i, -8+8i, -27+27i]);
-
-%!assert (prod (single([1, 2, 3])), single(6));
-%!assert (prod (single([-1; -2; -3])), single(-6));
-%!assert (prod (single([i, 2+i, -3+2i, 4])), single(-4 - 32i));
-%!assert (prod (single([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i])), single([-1+i, -8+8i, -27+27i]));
-
-%!error <Invalid call to prod> prod ();
-
-%!assert (prod ([1, 2; 3, 4], 1), [3, 8]);
-%!assert (prod ([1, 2; 3, 4], 2), [2; 12]);
-%!assert (prod (zeros (1, 0)), 1);
-%!assert (prod (zeros (1, 0), 1), zeros (1, 0));
-%!assert (prod (zeros (1, 0), 2), 1);
-%!assert (prod (zeros (0, 1)), 1);
-%!assert (prod (zeros (0, 1), 1), 1);
-%!assert (prod (zeros (0, 1), 2), zeros (0, 1));
-%!assert (prod (zeros (2, 0)), zeros (1, 0));
-%!assert (prod (zeros (2, 0), 1), zeros (1, 0));
-%!assert (prod (zeros (2, 0), 2), [1; 1]);
-%!assert (prod (zeros (0, 2)), [1, 1]);
-%!assert (prod (zeros (0, 2), 1), [1, 1]);
-%!assert (prod (zeros (0, 2), 2), zeros(0, 1));
-
-%!assert (prod (single([1, 2; 3, 4]), 1), single([3, 8]));
-%!assert (prod (single([1, 2; 3, 4]), 2), single([2; 12]));
-%!assert (prod (zeros (1, 0, 'single')), single(1));
-%!assert (prod (zeros (1, 0, 'single'), 1), zeros (1, 0, 'single'));
-%!assert (prod (zeros (1, 0, 'single'), 2), single(1));
-%!assert (prod (zeros (0, 1, 'single')), single(1));
-%!assert (prod (zeros (0, 1, 'single'), 1), single(1));
-%!assert (prod (zeros (0, 1, 'single'), 2), zeros (0, 1, 'single'));
-%!assert (prod (zeros (2, 0, 'single')), zeros (1, 0, 'single'));
-%!assert (prod (zeros (2, 0, 'single'), 1), zeros (1, 0, 'single'));
-%!assert (prod (zeros (2, 0, 'single'), 2), single([1; 1]));
-%!assert (prod (zeros (0, 2, 'single')), single([1, 1]));
-%!assert (prod (zeros (0, 2, 'single'), 1), single([1, 1]));
-%!assert (prod (zeros (0, 2, 'single'), 2), zeros(0, 1, 'single'));
-
- */
+%!assert (prod ([1, 2, 3]), 6)
+%!assert (prod ([-1; -2; -3]), -6)
+%!assert (prod ([i, 2+i, -3+2i, 4]), -4 - 32i)
+%!assert (prod ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i]), [-1+i, -8+8i, -27+27i])
+
+%!assert (prod (single ([1, 2, 3])), single (6))
+%!assert (prod (single ([-1; -2; -3])), single (-6))
+%!assert (prod (single ([i, 2+i, -3+2i, 4])), single (-4 - 32i))
+%!assert (prod (single ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i])), single ([-1+i, -8+8i, -27+27i]))
+
+%!assert (prod ([1, 2; 3, 4], 1), [3, 8])
+%!assert (prod ([1, 2; 3, 4], 2), [2; 12])
+%!assert (prod (zeros (1, 0)), 1)
+%!assert (prod (zeros (1, 0), 1), zeros (1, 0))
+%!assert (prod (zeros (1, 0), 2), 1)
+%!assert (prod (zeros (0, 1)), 1)
+%!assert (prod (zeros (0, 1), 1), 1)
+%!assert (prod (zeros (0, 1), 2), zeros (0, 1))
+%!assert (prod (zeros (2, 0)), zeros (1, 0))
+%!assert (prod (zeros (2, 0), 1), zeros (1, 0))
+%!assert (prod (zeros (2, 0), 2), [1; 1])
+%!assert (prod (zeros (0, 2)), [1, 1])
+%!assert (prod (zeros (0, 2), 1), [1, 1])
+%!assert (prod (zeros (0, 2), 2), zeros (0, 1))
+
+%!assert (prod (single ([1, 2; 3, 4]), 1), single ([3, 8]))
+%!assert (prod (single ([1, 2; 3, 4]), 2), single ([2; 12]))
+%!assert (prod (zeros (1, 0, "single")), single (1))
+%!assert (prod (zeros (1, 0, "single"), 1), zeros (1, 0, "single"))
+%!assert (prod (zeros (1, 0, "single"), 2), single (1))
+%!assert (prod (zeros (0, 1, "single")), single (1))
+%!assert (prod (zeros (0, 1, "single"), 1), single (1))
+%!assert (prod (zeros (0, 1, "single"), 2), zeros (0, 1, "single"))
+%!assert (prod (zeros (2, 0, "single")), zeros (1, 0, "single"))
+%!assert (prod (zeros (2, 0, "single"), 1), zeros (1, 0, "single"))
+%!assert (prod (zeros (2, 0, "single"), 2), single ([1; 1]))
+%!assert (prod (zeros (0, 2, "single")), single ([1, 1]))
+%!assert (prod (zeros (0, 2, "single"), 1), single ([1, 1]))
+%!assert (prod (zeros (0, 2, "single"), 2), zeros (0, 1, "single"))
+
+%!error prod ()
+*/
 
 static bool
 all_scalar_1x1 (const octave_value_list& args)
 {
   int n_args = args.length ();
   for (int i = 0; i < n_args; i++)
     if (args(i).numel () != 1)
       return false;
@@ -1870,204 +1857,205 @@ new matrices.  For example:\n\
 @end example\n\
 @seealso{cat, vertcat}\n\
 @end deftypefn")
 {
   return do_cat (args, -2, "horzcat");
 }
 
 /*
-%% test concatenation with all zero matrices
-%!assert(horzcat ('', 65*ones(1,10)), 'AAAAAAAAAA');
-%!assert(horzcat (65*ones(1,10), ''), 'AAAAAAAAAA');
-
-%!assert (class (horzcat (int64(1), int64(1))), 'int64')
-%!assert (class (horzcat (int64(1), int32(1))), 'int64')
-%!assert (class (horzcat (int64(1), int16(1))), 'int64')
-%!assert (class (horzcat (int64(1), int8(1))), 'int64')
-%!assert (class (horzcat (int64(1), uint64(1))), 'int64')
-%!assert (class (horzcat (int64(1), uint32(1))), 'int64')
-%!assert (class (horzcat (int64(1), uint16(1))), 'int64')
-%!assert (class (horzcat (int64(1), uint8(1))), 'int64')
-%!assert (class (horzcat (int64(1), single(1))), 'int64')
-%!assert (class (horzcat (int64(1), double(1))), 'int64')
-%!assert (class (horzcat (int64(1), cell(1))), 'cell')
-%!assert (class (horzcat (int64(1), true)), 'int64')
-%!assert (class (horzcat (int64(1), 'a')), 'char')
-
-%!assert (class (horzcat (int32(1), int64(1))), 'int32')
-%!assert (class (horzcat (int32(1), int32(1))), 'int32')
-%!assert (class (horzcat (int32(1), int16(1))), 'int32')
-%!assert (class (horzcat (int32(1), int8(1))), 'int32')
-%!assert (class (horzcat (int32(1), uint64(1))), 'int32')
-%!assert (class (horzcat (int32(1), uint32(1))), 'int32')
-%!assert (class (horzcat (int32(1), uint16(1))), 'int32')
-%!assert (class (horzcat (int32(1), uint8(1))), 'int32')
-%!assert (class (horzcat (int32(1), single(1))), 'int32')
-%!assert (class (horzcat (int32(1), double(1))), 'int32')
-%!assert (class (horzcat (int32(1), cell(1))), 'cell')
-%!assert (class (horzcat (int32(1), true)), 'int32')
-%!assert (class (horzcat (int32(1), 'a')), 'char')
-
-%!assert (class (horzcat (int16(1), int64(1))), 'int16')
-%!assert (class (horzcat (int16(1), int32(1))), 'int16')
-%!assert (class (horzcat (int16(1), int16(1))), 'int16')
-%!assert (class (horzcat (int16(1), int8(1))), 'int16')
-%!assert (class (horzcat (int16(1), uint64(1))), 'int16')
-%!assert (class (horzcat (int16(1), uint32(1))), 'int16')
-%!assert (class (horzcat (int16(1), uint16(1))), 'int16')
-%!assert (class (horzcat (int16(1), uint8(1))), 'int16')
-%!assert (class (horzcat (int16(1), single(1))), 'int16')
-%!assert (class (horzcat (int16(1), double(1))), 'int16')
-%!assert (class (horzcat (int16(1), cell(1))), 'cell')
-%!assert (class (horzcat (int16(1), true)), 'int16')
-%!assert (class (horzcat (int16(1), 'a')), 'char')
-
-%!assert (class (horzcat (int8(1), int64(1))), 'int8')
-%!assert (class (horzcat (int8(1), int32(1))), 'int8')
-%!assert (class (horzcat (int8(1), int16(1))), 'int8')
-%!assert (class (horzcat (int8(1), int8(1))), 'int8')
-%!assert (class (horzcat (int8(1), uint64(1))), 'int8')
-%!assert (class (horzcat (int8(1), uint32(1))), 'int8')
-%!assert (class (horzcat (int8(1), uint16(1))), 'int8')
-%!assert (class (horzcat (int8(1), uint8(1))), 'int8')
-%!assert (class (horzcat (int8(1), single(1))), 'int8')
-%!assert (class (horzcat (int8(1), double(1))), 'int8')
-%!assert (class (horzcat (int8(1), cell(1))), 'cell')
-%!assert (class (horzcat (int8(1), true)), 'int8')
-%!assert (class (horzcat (int8(1), 'a')), 'char')
-
-%!assert (class (horzcat (uint64(1), int64(1))), 'uint64')
-%!assert (class (horzcat (uint64(1), int32(1))), 'uint64')
-%!assert (class (horzcat (uint64(1), int16(1))), 'uint64')
-%!assert (class (horzcat (uint64(1), int8(1))), 'uint64')
-%!assert (class (horzcat (uint64(1), uint64(1))), 'uint64')
-%!assert (class (horzcat (uint64(1), uint32(1))), 'uint64')
-%!assert (class (horzcat (uint64(1), uint16(1))), 'uint64')
-%!assert (class (horzcat (uint64(1), uint8(1))), 'uint64')
-%!assert (class (horzcat (uint64(1), single(1))), 'uint64')
-%!assert (class (horzcat (uint64(1), double(1))), 'uint64')
-%!assert (class (horzcat (uint64(1), cell(1))), 'cell')
-%!assert (class (horzcat (uint64(1), true)), 'uint64')
-%!assert (class (horzcat (uint64(1), 'a')), 'char')
-
-%!assert (class (horzcat (uint32(1), int64(1))), 'uint32')
-%!assert (class (horzcat (uint32(1), int32(1))), 'uint32')
-%!assert (class (horzcat (uint32(1), int16(1))), 'uint32')
-%!assert (class (horzcat (uint32(1), int8(1))), 'uint32')
-%!assert (class (horzcat (uint32(1), uint64(1))), 'uint32')
-%!assert (class (horzcat (uint32(1), uint32(1))), 'uint32')
-%!assert (class (horzcat (uint32(1), uint16(1))), 'uint32')
-%!assert (class (horzcat (uint32(1), uint8(1))), 'uint32')
-%!assert (class (horzcat (uint32(1), single(1))), 'uint32')
-%!assert (class (horzcat (uint32(1), double(1))), 'uint32')
-%!assert (class (horzcat (uint32(1), cell(1))), 'cell')
-%!assert (class (horzcat (uint32(1), true)), 'uint32')
-%!assert (class (horzcat (uint32(1), 'a')), 'char')
-
-%!assert (class (horzcat (uint16(1), int64(1))), 'uint16')
-%!assert (class (horzcat (uint16(1), int32(1))), 'uint16')
-%!assert (class (horzcat (uint16(1), int16(1))), 'uint16')
-%!assert (class (horzcat (uint16(1), int8(1))), 'uint16')
-%!assert (class (horzcat (uint16(1), uint64(1))), 'uint16')
-%!assert (class (horzcat (uint16(1), uint32(1))), 'uint16')
-%!assert (class (horzcat (uint16(1), uint16(1))), 'uint16')
-%!assert (class (horzcat (uint16(1), uint8(1))), 'uint16')
-%!assert (class (horzcat (uint16(1), single(1))), 'uint16')
-%!assert (class (horzcat (uint16(1), double(1))), 'uint16')
-%!assert (class (horzcat (uint16(1), cell(1))), 'cell')
-%!assert (class (horzcat (uint16(1), true)), 'uint16')
-%!assert (class (horzcat (uint16(1), 'a')), 'char')
-
-%!assert (class (horzcat (uint8(1), int64(1))), 'uint8')
-%!assert (class (horzcat (uint8(1), int32(1))), 'uint8')
-%!assert (class (horzcat (uint8(1), int16(1))), 'uint8')
-%!assert (class (horzcat (uint8(1), int8(1))), 'uint8')
-%!assert (class (horzcat (uint8(1), uint64(1))), 'uint8')
-%!assert (class (horzcat (uint8(1), uint32(1))), 'uint8')
-%!assert (class (horzcat (uint8(1), uint16(1))), 'uint8')
-%!assert (class (horzcat (uint8(1), uint8(1))), 'uint8')
-%!assert (class (horzcat (uint8(1), single(1))), 'uint8')
-%!assert (class (horzcat (uint8(1), double(1))), 'uint8')
-%!assert (class (horzcat (uint8(1), cell(1))), 'cell')
-%!assert (class (horzcat (uint8(1), true)), 'uint8')
-%!assert (class (horzcat (uint8(1), 'a')), 'char')
-
-%!assert (class (horzcat (single(1), int64(1))), 'int64')
-%!assert (class (horzcat (single(1), int32(1))), 'int32')
-%!assert (class (horzcat (single(1), int16(1))), 'int16')
-%!assert (class (horzcat (single(1), int8(1))), 'int8')
-%!assert (class (horzcat (single(1), uint64(1))), 'uint64')
-%!assert (class (horzcat (single(1), uint32(1))), 'uint32')
-%!assert (class (horzcat (single(1), uint16(1))), 'uint16')
-%!assert (class (horzcat (single(1), uint8(1))), 'uint8')
-%!assert (class (horzcat (single(1), single(1))), 'single')
-%!assert (class (horzcat (single(1), double(1))), 'single')
-%!assert (class (horzcat (single(1), cell(1))), 'cell')
-%!assert (class (horzcat (single(1), true)), 'single')
-%!assert (class (horzcat (single(1), 'a')), 'char')
-
-%!assert (class (horzcat (double(1), int64(1))), 'int64')
-%!assert (class (horzcat (double(1), int32(1))), 'int32')
-%!assert (class (horzcat (double(1), int16(1))), 'int16')
-%!assert (class (horzcat (double(1), int8(1))), 'int8')
-%!assert (class (horzcat (double(1), uint64(1))), 'uint64')
-%!assert (class (horzcat (double(1), uint32(1))), 'uint32')
-%!assert (class (horzcat (double(1), uint16(1))), 'uint16')
-%!assert (class (horzcat (double(1), uint8(1))), 'uint8')
-%!assert (class (horzcat (double(1), single(1))), 'single')
-%!assert (class (horzcat (double(1), double(1))), 'double')
-%!assert (class (horzcat (double(1), cell(1))), 'cell')
-%!assert (class (horzcat (double(1), true)), 'double')
-%!assert (class (horzcat (double(1), 'a')), 'char')
-
-%!assert (class (horzcat (cell(1), int64(1))), 'cell')
-%!assert (class (horzcat (cell(1), int32(1))), 'cell')
-%!assert (class (horzcat (cell(1), int16(1))), 'cell')
-%!assert (class (horzcat (cell(1), int8(1))), 'cell')
-%!assert (class (horzcat (cell(1), uint64(1))), 'cell')
-%!assert (class (horzcat (cell(1), uint32(1))), 'cell')
-%!assert (class (horzcat (cell(1), uint16(1))), 'cell')
-%!assert (class (horzcat (cell(1), uint8(1))), 'cell')
-%!assert (class (horzcat (cell(1), single(1))), 'cell')
-%!assert (class (horzcat (cell(1), double(1))), 'cell')
-%!assert (class (horzcat (cell(1), cell(1))), 'cell')
-%!assert (class (horzcat (cell(1), true)), 'cell')
-%!assert (class (horzcat (cell(1), 'a')), 'cell')
-
-%!assert (class (horzcat (true, int64(1))), 'int64')
-%!assert (class (horzcat (true, int32(1))), 'int32')
-%!assert (class (horzcat (true, int16(1))), 'int16')
-%!assert (class (horzcat (true, int8(1))), 'int8')
-%!assert (class (horzcat (true, uint64(1))), 'uint64')
-%!assert (class (horzcat (true, uint32(1))), 'uint32')
-%!assert (class (horzcat (true, uint16(1))), 'uint16')
-%!assert (class (horzcat (true, uint8(1))), 'uint8')
-%!assert (class (horzcat (true, single(1))), 'single')
-%!assert (class (horzcat (true, double(1))), 'double')
-%!assert (class (horzcat (true, cell(1))), 'cell')
-%!assert (class (horzcat (true, true)), 'logical')
-%!assert (class (horzcat (true, 'a')), 'char')
-
-%!assert (class (horzcat ('a', int64(1))), 'char')
-%!assert (class (horzcat ('a', int32(1))), 'char')
-%!assert (class (horzcat ('a', int16(1))), 'char')
-%!assert (class (horzcat ('a', int8(1))), 'char')
-%!assert (class (horzcat ('a', int64(1))), 'char')
-%!assert (class (horzcat ('a', int32(1))), 'char')
-%!assert (class (horzcat ('a', int16(1))), 'char')
-%!assert (class (horzcat ('a', int8(1))), 'char')
-%!assert (class (horzcat ('a', single(1))), 'char')
-%!assert (class (horzcat ('a', double(1))), 'char')
-%!assert (class (horzcat ('a', cell(1))), 'cell')
-%!assert (class (horzcat ('a', true)), 'char')
-%!assert (class (horzcat ('a', 'a')), 'char')
-
-%!assert (class (horzcat (cell(1), struct('foo', 'bar'))), 'cell')
-%!error horzcat (struct('foo', 'bar'), cell(1));
+## Test concatenation with all zero matrices
+%!assert (horzcat ("", 65*ones (1,10)), "AAAAAAAAAA");
+%!assert (horzcat (65*ones (1,10), ""), "AAAAAAAAAA");
+
+%!assert (class (horzcat (int64 (1), int64 (1))), "int64")
+%!assert (class (horzcat (int64 (1), int32 (1))), "int64")
+%!assert (class (horzcat (int64 (1), int16 (1))), "int64")
+%!assert (class (horzcat (int64 (1), int8 (1))), "int64")
+%!assert (class (horzcat (int64 (1), uint64 (1))), "int64")
+%!assert (class (horzcat (int64 (1), uint32 (1))), "int64")
+%!assert (class (horzcat (int64 (1), uint16 (1))), "int64")
+%!assert (class (horzcat (int64 (1), uint8 (1))), "int64")
+%!assert (class (horzcat (int64 (1), single (1))), "int64")
+%!assert (class (horzcat (int64 (1), double (1))), "int64")
+%!assert (class (horzcat (int64 (1), cell (1))), "cell")
+%!assert (class (horzcat (int64 (1), true)), "int64")
+%!assert (class (horzcat (int64 (1), "a")), "char")
+
+%!assert (class (horzcat (int32 (1), int64 (1))), "int32")
+%!assert (class (horzcat (int32 (1), int32 (1))), "int32")
+%!assert (class (horzcat (int32 (1), int16 (1))), "int32")
+%!assert (class (horzcat (int32 (1), int8 (1))), "int32")
+%!assert (class (horzcat (int32 (1), uint64 (1))), "int32")
+%!assert (class (horzcat (int32 (1), uint32 (1))), "int32")
+%!assert (class (horzcat (int32 (1), uint16 (1))), "int32")
+%!assert (class (horzcat (int32 (1), uint8 (1))), "int32")
+%!assert (class (horzcat (int32 (1), single (1))), "int32")
+%!assert (class (horzcat (int32 (1), double (1))), "int32")
+%!assert (class (horzcat (int32 (1), cell (1))), "cell")
+%!assert (class (horzcat (int32 (1), true)), "int32")
+%!assert (class (horzcat (int32 (1), "a")), "char")
+
+%!assert (class (horzcat (int16 (1), int64 (1))), "int16")
+%!assert (class (horzcat (int16 (1), int32 (1))), "int16")
+%!assert (class (horzcat (int16 (1), int16 (1))), "int16")
+%!assert (class (horzcat (int16 (1), int8 (1))), "int16")
+%!assert (class (horzcat (int16 (1), uint64 (1))), "int16")
+%!assert (class (horzcat (int16 (1), uint32 (1))), "int16")
+%!assert (class (horzcat (int16 (1), uint16 (1))), "int16")
+%!assert (class (horzcat (int16 (1), uint8 (1))), "int16")
+%!assert (class (horzcat (int16 (1), single (1))), "int16")
+%!assert (class (horzcat (int16 (1), double (1))), "int16")
+%!assert (class (horzcat (int16 (1), cell (1))), "cell")
+%!assert (class (horzcat (int16 (1), true)), "int16")
+%!assert (class (horzcat (int16 (1), "a")), "char")
+
+%!assert (class (horzcat (int8 (1), int64 (1))), "int8")
+%!assert (class (horzcat (int8 (1), int32 (1))), "int8")
+%!assert (class (horzcat (int8 (1), int16 (1))), "int8")
+%!assert (class (horzcat (int8 (1), int8 (1))), "int8")
+%!assert (class (horzcat (int8 (1), uint64 (1))), "int8")
+%!assert (class (horzcat (int8 (1), uint32 (1))), "int8")
+%!assert (class (horzcat (int8 (1), uint16 (1))), "int8")
+%!assert (class (horzcat (int8 (1), uint8 (1))), "int8")
+%!assert (class (horzcat (int8 (1), single (1))), "int8")
+%!assert (class (horzcat (int8 (1), double (1))), "int8")
+%!assert (class (horzcat (int8 (1), cell (1))), "cell")
+%!assert (class (horzcat (int8 (1), true)), "int8")
+%!assert (class (horzcat (int8 (1), "a")), "char")
+
+%!assert (class (horzcat (uint64 (1), int64 (1))), "uint64")
+%!assert (class (horzcat (uint64 (1), int32 (1))), "uint64")
+%!assert (class (horzcat (uint64 (1), int16 (1))), "uint64")
+%!assert (class (horzcat (uint64 (1), int8 (1))), "uint64")
+%!assert (class (horzcat (uint64 (1), uint64 (1))), "uint64")
+%!assert (class (horzcat (uint64 (1), uint32 (1))), "uint64")
+%!assert (class (horzcat (uint64 (1), uint16 (1))), "uint64")
+%!assert (class (horzcat (uint64 (1), uint8 (1))), "uint64")
+%!assert (class (horzcat (uint64 (1), single (1))), "uint64")
+%!assert (class (horzcat (uint64 (1), double (1))), "uint64")
+%!assert (class (horzcat (uint64 (1), cell (1))), "cell")
+%!assert (class (horzcat (uint64 (1), true)), "uint64")
+%!assert (class (horzcat (uint64 (1), "a")), "char")
+
+%!assert (class (horzcat (uint32 (1), int64 (1))), "uint32")
+%!assert (class (horzcat (uint32 (1), int32 (1))), "uint32")
+%!assert (class (horzcat (uint32 (1), int16 (1))), "uint32")
+%!assert (class (horzcat (uint32 (1), int8 (1))), "uint32")
+%!assert (class (horzcat (uint32 (1), uint64 (1))), "uint32")
+%!assert (class (horzcat (uint32 (1), uint32 (1))), "uint32")
+%!assert (class (horzcat (uint32 (1), uint16 (1))), "uint32")
+%!assert (class (horzcat (uint32 (1), uint8 (1))), "uint32")
+%!assert (class (horzcat (uint32 (1), single (1))), "uint32")
+%!assert (class (horzcat (uint32 (1), double (1))), "uint32")
+%!assert (class (horzcat (uint32 (1), cell (1))), "cell")
+%!assert (class (horzcat (uint32 (1), true)), "uint32")
+%!assert (class (horzcat (uint32 (1), "a")), "char")
+
+%!assert (class (horzcat (uint16 (1), int64 (1))), "uint16")
+%!assert (class (horzcat (uint16 (1), int32 (1))), "uint16")
+%!assert (class (horzcat (uint16 (1), int16 (1))), "uint16")
+%!assert (class (horzcat (uint16 (1), int8 (1))), "uint16")
+%!assert (class (horzcat (uint16 (1), uint64 (1))), "uint16")
+%!assert (class (horzcat (uint16 (1), uint32 (1))), "uint16")
+%!assert (class (horzcat (uint16 (1), uint16 (1))), "uint16")
+%!assert (class (horzcat (uint16 (1), uint8 (1))), "uint16")
+%!assert (class (horzcat (uint16 (1), single (1))), "uint16")
+%!assert (class (horzcat (uint16 (1), double (1))), "uint16")
+%!assert (class (horzcat (uint16 (1), cell (1))), "cell")
+%!assert (class (horzcat (uint16 (1), true)), "uint16")
+%!assert (class (horzcat (uint16 (1), "a")), "char")
+
+%!assert (class (horzcat (uint8 (1), int64 (1))), "uint8")
+%!assert (class (horzcat (uint8 (1), int32 (1))), "uint8")
+%!assert (class (horzcat (uint8 (1), int16 (1))), "uint8")
+%!assert (class (horzcat (uint8 (1), int8 (1))), "uint8")
+%!assert (class (horzcat (uint8 (1), uint64 (1))), "uint8")
+%!assert (class (horzcat (uint8 (1), uint32 (1))), "uint8")
+%!assert (class (horzcat (uint8 (1), uint16 (1))), "uint8")
+%!assert (class (horzcat (uint8 (1), uint8 (1))), "uint8")
+%!assert (class (horzcat (uint8 (1), single (1))), "uint8")
+%!assert (class (horzcat (uint8 (1), double (1))), "uint8")
+%!assert (class (horzcat (uint8 (1), cell (1))), "cell")
+%!assert (class (horzcat (uint8 (1), true)), "uint8")
+%!assert (class (horzcat (uint8 (1), "a")), "char")
+
+%!assert (class (horzcat (single (1), int64 (1))), "int64")
+%!assert (class (horzcat (single (1), int32 (1))), "int32")
+%!assert (class (horzcat (single (1), int16 (1))), "int16")
+%!assert (class (horzcat (single (1), int8 (1))), "int8")
+%!assert (class (horzcat (single (1), uint64 (1))), "uint64")
+%!assert (class (horzcat (single (1), uint32 (1))), "uint32")
+%!assert (class (horzcat (single (1), uint16 (1))), "uint16")
+%!assert (class (horzcat (single (1), uint8 (1))), "uint8")
+%!assert (class (horzcat (single (1), single (1))), "single")
+%!assert (class (horzcat (single (1), double (1))), "single")
+%!assert (class (horzcat (single (1), cell (1))), "cell")
+%!assert (class (horzcat (single (1), true)), "single")
+%!assert (class (horzcat (single (1), "a")), "char")
+
+%!assert (class (horzcat (double (1), int64 (1))), "int64")
+%!assert (class (horzcat (double (1), int32 (1))), "int32")
+%!assert (class (horzcat (double (1), int16 (1))), "int16")
+%!assert (class (horzcat (double (1), int8 (1))), "int8")
+%!assert (class (horzcat (double (1), uint64 (1))), "uint64")
+%!assert (class (horzcat (double (1), uint32 (1))), "uint32")
+%!assert (class (horzcat (double (1), uint16 (1))), "uint16")
+%!assert (class (horzcat (double (1), uint8 (1))), "uint8")
+%!assert (class (horzcat (double (1), single (1))), "single")
+%!assert (class (horzcat (double (1), double (1))), "double")
+%!assert (class (horzcat (double (1), cell (1))), "cell")
+%!assert (class (horzcat (double (1), true)), "double")
+%!assert (class (horzcat (double (1), "a")), "char")
+
+%!assert (class (horzcat (cell (1), int64 (1))), "cell")
+%!assert (class (horzcat (cell (1), int32 (1))), "cell")
+%!assert (class (horzcat (cell (1), int16 (1))), "cell")
+%!assert (class (horzcat (cell (1), int8 (1))), "cell")
+%!assert (class (horzcat (cell (1), uint64 (1))), "cell")
+%!assert (class (horzcat (cell (1), uint32 (1))), "cell")
+%!assert (class (horzcat (cell (1), uint16 (1))), "cell")
+%!assert (class (horzcat (cell (1), uint8 (1))), "cell")
+%!assert (class (horzcat (cell (1), single (1))), "cell")
+%!assert (class (horzcat (cell (1), double (1))), "cell")
+%!assert (class (horzcat (cell (1), cell (1))), "cell")
+%!assert (class (horzcat (cell (1), true)), "cell")
+%!assert (class (horzcat (cell (1), "a")), "cell")
+
+%!assert (class (horzcat (true, int64 (1))), "int64")
+%!assert (class (horzcat (true, int32 (1))), "int32")
+%!assert (class (horzcat (true, int16 (1))), "int16")
+%!assert (class (horzcat (true, int8 (1))), "int8")
+%!assert (class (horzcat (true, uint64 (1))), "uint64")
+%!assert (class (horzcat (true, uint32 (1))), "uint32")
+%!assert (class (horzcat (true, uint16 (1))), "uint16")
+%!assert (class (horzcat (true, uint8 (1))), "uint8")
+%!assert (class (horzcat (true, single (1))), "single")
+%!assert (class (horzcat (true, double (1))), "double")
+%!assert (class (horzcat (true, cell (1))), "cell")
+%!assert (class (horzcat (true, true)), "logical")
+%!assert (class (horzcat (true, "a")), "char")
+
+%!assert (class (horzcat ("a", int64 (1))), "char")
+%!assert (class (horzcat ("a", int32 (1))), "char")
+%!assert (class (horzcat ("a", int16 (1))), "char")
+%!assert (class (horzcat ("a", int8 (1))), "char")
+%!assert (class (horzcat ("a", int64 (1))), "char")
+%!assert (class (horzcat ("a", int32 (1))), "char")
+%!assert (class (horzcat ("a", int16 (1))), "char")
+%!assert (class (horzcat ("a", int8 (1))), "char")
+%!assert (class (horzcat ("a", single (1))), "char")
+%!assert (class (horzcat ("a", double (1))), "char")
+%!assert (class (horzcat ("a", cell (1))), "cell")
+%!assert (class (horzcat ("a", true)), "char")
+%!assert (class (horzcat ("a", "a")), "char")
+
+%!assert (class (horzcat (cell (1), struct ("foo", "bar"))), "cell")
+
+%!error horzcat (struct ("foo", "bar"), cell (1))
 */
 
 DEFUN (vertcat, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} vertcat (@var{array1}, @var{array2}, @dots{}, @var{arrayN})\n\
 Return the vertical concatenation of N-D array objects, @var{array1},\n\
 @var{array2}, @dots{}, @var{arrayN} along dimension 1.\n\
 \n\
@@ -2080,18 +2068,18 @@ new matrices.  For example:\n\
 @seealso{cat, horzcat}\n\
 @end deftypefn")
 {
   return do_cat (args, -1, "vertcat");
 }
 
 /*
 %!test
-%! c = {'foo'; 'bar'; 'bazoloa'};
-%! assert (vertcat (c, 'a', 'bc', 'def'), {'foo'; 'bar'; 'bazoloa'; 'a'; 'bc'; 'def'});
+%! c = {"foo"; "bar"; "bazoloa"};
+%! assert (vertcat (c, "a", "bc", "def"), {"foo"; "bar"; "bazoloa"; "a"; "bc"; "def"});
 */
 
 DEFUN (cat, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} cat (@var{dim}, @var{array1}, @var{array2}, @dots{}, @var{arrayN})\n\
 Return the concatenation of N-D array objects, @var{array1},\n\
 @var{array2}, @dots{}, @var{arrayN} along dimension @var{dim}.\n\
 \n\
@@ -2153,157 +2141,156 @@ cat (4, ones (2, 2), zeros (2, 2))\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
 %!function ret = __testcat (t1, t2, tr, cmplx)
-%! assert (cat (1, cast ([], t1), cast([], t2)), cast ([], tr));
-%!
-%! assert (cat (1, cast (1, t1), cast (2, t2)), cast ([1; 2], tr));
-%! assert (cat (1, cast (1, t1), cast ([2; 3], t2)), cast ([1; 2; 3], tr));
-%! assert (cat (1, cast ([1; 2], t1), cast (3, t2)), cast ([1; 2; 3], tr));
-%! assert (cat (1, cast ([1; 2], t1), cast ([3; 4], t2)), cast ([1; 2; 3; 4], tr));
-%! assert (cat (2, cast (1, t1), cast (2, t2)), cast ([1, 2], tr));
-%! assert (cat (2, cast (1, t1), cast ([2, 3], t2)), cast ([1, 2, 3], tr));
-%! assert (cat (2, cast ([1, 2], t1), cast (3, t2)), cast ([1, 2, 3], tr));
-%! assert (cat (2, cast ([1, 2], t1), cast ([3, 4], t2)), cast ([1, 2, 3, 4], tr));
-%!
-%! assert ([cast(1, t1); cast(2, t2)], cast ([1; 2], tr));
-%! assert ([cast(1, t1); cast([2; 3], t2)], cast ([1; 2; 3], tr));
-%! assert ([cast([1; 2], t1); cast(3, t2)], cast ([1; 2; 3], tr));
-%! assert ([cast([1; 2], t1); cast([3; 4], t2)], cast ([1; 2; 3; 4], tr));
-%! assert ([cast(1, t1), cast(2, t2)], cast ([1, 2], tr));
-%! assert ([cast(1, t1), cast([2, 3], t2)], cast ([1, 2, 3], tr));
-%! assert ([cast([1, 2], t1), cast(3, t2)], cast ([1, 2, 3], tr));
-%! assert ([cast([1, 2], t1), cast([3, 4], t2)], cast ([1, 2, 3, 4], tr));
-%!
-%! if (nargin == 3 || cmplx)
-%!   assert (cat (1, cast (1i, t1), cast (2, t2)), cast ([1i; 2], tr));
-%!   assert (cat (1, cast (1i, t1), cast ([2; 3], t2)), cast ([1i; 2; 3], tr));
-%!   assert (cat (1, cast ([1i; 2], t1), cast (3, t2)), cast ([1i; 2; 3], tr));
-%!   assert (cat (1, cast ([1i; 2], t1), cast ([3; 4], t2)), cast ([1i; 2; 3; 4], tr));
-%!   assert (cat (2, cast (1i, t1), cast (2, t2)), cast ([1i, 2], tr));
-%!   assert (cat (2, cast (1i, t1), cast ([2, 3], t2)), cast ([1i, 2, 3], tr));
-%!   assert (cat (2, cast ([1i, 2], t1), cast (3, t2)), cast ([1i, 2, 3], tr));
-%!   assert (cat (2, cast ([1i, 2], t1), cast ([3, 4], t2)), cast ([1i, 2, 3, 4], tr));
-%!
-%!   assert ([cast(1i, t1); cast(2, t2)], cast ([1i; 2], tr));
-%!   assert ([cast(1i, t1); cast([2; 3], t2)], cast ([1i; 2; 3], tr));
-%!   assert ([cast([1i; 2], t1); cast(3, t2)], cast ([1i; 2; 3], tr));
-%!   assert ([cast([1i; 2], t1); cast([3; 4], t2)], cast ([1i; 2; 3; 4], tr));
-%!   assert ([cast(1i, t1), cast(2, t2)], cast ([1i, 2], tr));
-%!   assert ([cast(1i, t1), cast([2, 3], t2)], cast ([1i, 2, 3], tr));
-%!   assert ([cast([1i, 2], t1), cast(3, t2)], cast ([1i, 2, 3], tr));
-%!   assert ([cast([1i, 2], t1), cast([3, 4], t2)], cast ([1i, 2, 3, 4], tr));
-%!
-%!   assert (cat (1, cast (1, t1), cast (2i, t2)), cast ([1; 2i], tr));
-%!   assert (cat (1, cast (1, t1), cast ([2i; 3], t2)), cast ([1; 2i; 3], tr));
-%!   assert (cat (1, cast ([1; 2], t1), cast (3i, t2)), cast ([1; 2; 3i], tr));
-%!   assert (cat (1, cast ([1; 2], t1), cast ([3i; 4], t2)), cast ([1; 2; 3i; 4], tr));
-%!   assert (cat (2, cast (1, t1), cast (2i, t2)), cast ([1, 2i], tr));
-%!   assert (cat (2, cast (1, t1), cast ([2i, 3], t2)), cast ([1, 2i, 3], tr));
-%!   assert (cat (2, cast ([1, 2], t1), cast (3i, t2)), cast ([1, 2, 3i], tr));
-%!   assert (cat (2, cast ([1, 2], t1), cast ([3i, 4], t2)), cast ([1, 2, 3i, 4], tr));
-%!
-%!   assert ([cast(1, t1); cast(2i, t2)], cast ([1; 2i], tr));
-%!   assert ([cast(1, t1); cast([2i; 3], t2)], cast ([1; 2i; 3], tr));
-%!   assert ([cast([1; 2], t1); cast(3i, t2)], cast ([1; 2; 3i], tr));
-%!   assert ([cast([1; 2], t1); cast([3i; 4], t2)], cast ([1; 2; 3i; 4], tr));
-%!   assert ([cast(1, t1), cast(2i, t2)], cast ([1, 2i], tr));
-%!   assert ([cast(1, t1), cast([2i, 3], t2)], cast ([1, 2i, 3], tr));
-%!   assert ([cast([1, 2], t1), cast(3i, t2)], cast ([1, 2, 3i], tr));
-%!   assert ([cast([1, 2], t1), cast([3i, 4], t2)], cast ([1, 2, 3i, 4], tr));
-%!
-%!   assert (cat (1, cast (1i, t1), cast (2i, t2)), cast ([1i; 2i], tr));
-%!   assert (cat (1, cast (1i, t1), cast ([2i; 3], t2)), cast ([1i; 2i; 3], tr));
-%!   assert (cat (1, cast ([1i; 2], t1), cast (3i, t2)), cast ([1i; 2; 3i], tr));
-%!   assert (cat (1, cast ([1i; 2], t1), cast ([3i; 4], t2)), cast ([1i; 2; 3i; 4], tr));
-%!   assert (cat (2, cast (1i, t1), cast (2i, t2)), cast ([1i, 2i], tr));
-%!   assert (cat (2, cast (1i, t1), cast ([2i, 3], t2)), cast ([1i, 2i, 3], tr));
-%!   assert (cat (2, cast ([1i, 2], t1), cast (3i, t2)), cast ([1i, 2, 3i], tr));
-%!   assert (cat (2, cast ([1i, 2], t1), cast ([3i, 4], t2)), cast ([1i, 2, 3i, 4], tr));
-%!
-%!   assert ([cast(1i, t1); cast(2i, t2)], cast ([1i; 2i], tr));
-%!   assert ([cast(1i, t1); cast([2i; 3], t2)], cast ([1i; 2i; 3], tr));
-%!   assert ([cast([1i; 2], t1); cast(3i, t2)], cast ([1i; 2; 3i], tr));
-%!   assert ([cast([1i; 2], t1); cast([3i; 4], t2)], cast ([1i; 2; 3i; 4], tr));
-%!   assert ([cast(1i, t1), cast(2i, t2)], cast ([1i, 2i], tr));
-%!   assert ([cast(1i, t1), cast([2i, 3], t2)], cast ([1i, 2i, 3], tr));
-%!   assert ([cast([1i, 2], t1), cast(3i, t2)], cast ([1i, 2, 3i], tr));
-%!   assert ([cast([1i, 2], t1), cast([3i, 4], t2)], cast ([1i, 2, 3i, 4], tr));
-%! endif
-%! ret = true;
+%!  assert (cat (1, cast ([], t1), cast([], t2)), cast ([], tr));
+%! 
+%!  assert (cat (1, cast (1, t1), cast (2, t2)), cast ([1; 2], tr));
+%!  assert (cat (1, cast (1, t1), cast ([2; 3], t2)), cast ([1; 2; 3], tr));
+%!  assert (cat (1, cast ([1; 2], t1), cast (3, t2)), cast ([1; 2; 3], tr));
+%!  assert (cat (1, cast ([1; 2], t1), cast ([3; 4], t2)), cast ([1; 2; 3; 4], tr));
+%!  assert (cat (2, cast (1, t1), cast (2, t2)), cast ([1, 2], tr));
+%!  assert (cat (2, cast (1, t1), cast ([2, 3], t2)), cast ([1, 2, 3], tr));
+%!  assert (cat (2, cast ([1, 2], t1), cast (3, t2)), cast ([1, 2, 3], tr));
+%!  assert (cat (2, cast ([1, 2], t1), cast ([3, 4], t2)), cast ([1, 2, 3, 4], tr));
+%! 
+%!  assert ([cast(1, t1); cast(2, t2)], cast ([1; 2], tr));
+%!  assert ([cast(1, t1); cast([2; 3], t2)], cast ([1; 2; 3], tr));
+%!  assert ([cast([1; 2], t1); cast(3, t2)], cast ([1; 2; 3], tr));
+%!  assert ([cast([1; 2], t1); cast([3; 4], t2)], cast ([1; 2; 3; 4], tr));
+%!  assert ([cast(1, t1), cast(2, t2)], cast ([1, 2], tr));
+%!  assert ([cast(1, t1), cast([2, 3], t2)], cast ([1, 2, 3], tr));
+%!  assert ([cast([1, 2], t1), cast(3, t2)], cast ([1, 2, 3], tr));
+%!  assert ([cast([1, 2], t1), cast([3, 4], t2)], cast ([1, 2, 3, 4], tr));
+%! 
+%!  if (nargin == 3 || cmplx)
+%!    assert (cat (1, cast (1i, t1), cast (2, t2)), cast ([1i; 2], tr));
+%!    assert (cat (1, cast (1i, t1), cast ([2; 3], t2)), cast ([1i; 2; 3], tr));
+%!    assert (cat (1, cast ([1i; 2], t1), cast (3, t2)), cast ([1i; 2; 3], tr));
+%!    assert (cat (1, cast ([1i; 2], t1), cast ([3; 4], t2)), cast ([1i; 2; 3; 4], tr));
+%!    assert (cat (2, cast (1i, t1), cast (2, t2)), cast ([1i, 2], tr));
+%!    assert (cat (2, cast (1i, t1), cast ([2, 3], t2)), cast ([1i, 2, 3], tr));
+%!    assert (cat (2, cast ([1i, 2], t1), cast (3, t2)), cast ([1i, 2, 3], tr));
+%!    assert (cat (2, cast ([1i, 2], t1), cast ([3, 4], t2)), cast ([1i, 2, 3, 4], tr));
+%! 
+%!    assert ([cast(1i, t1); cast(2, t2)], cast ([1i; 2], tr));
+%!    assert ([cast(1i, t1); cast([2; 3], t2)], cast ([1i; 2; 3], tr));
+%!    assert ([cast([1i; 2], t1); cast(3, t2)], cast ([1i; 2; 3], tr));
+%!    assert ([cast([1i; 2], t1); cast([3; 4], t2)], cast ([1i; 2; 3; 4], tr));
+%!    assert ([cast(1i, t1), cast(2, t2)], cast ([1i, 2], tr));
+%!    assert ([cast(1i, t1), cast([2, 3], t2)], cast ([1i, 2, 3], tr));
+%!    assert ([cast([1i, 2], t1), cast(3, t2)], cast ([1i, 2, 3], tr));
+%!    assert ([cast([1i, 2], t1), cast([3, 4], t2)], cast ([1i, 2, 3, 4], tr));
+%! 
+%!    assert (cat (1, cast (1, t1), cast (2i, t2)), cast ([1; 2i], tr));
+%!    assert (cat (1, cast (1, t1), cast ([2i; 3], t2)), cast ([1; 2i; 3], tr));
+%!    assert (cat (1, cast ([1; 2], t1), cast (3i, t2)), cast ([1; 2; 3i], tr));
+%!    assert (cat (1, cast ([1; 2], t1), cast ([3i; 4], t2)), cast ([1; 2; 3i; 4], tr));
+%!    assert (cat (2, cast (1, t1), cast (2i, t2)), cast ([1, 2i], tr));
+%!    assert (cat (2, cast (1, t1), cast ([2i, 3], t2)), cast ([1, 2i, 3], tr));
+%!    assert (cat (2, cast ([1, 2], t1), cast (3i, t2)), cast ([1, 2, 3i], tr));
+%!    assert (cat (2, cast ([1, 2], t1), cast ([3i, 4], t2)), cast ([1, 2, 3i, 4], tr));
+%! 
+%!    assert ([cast(1, t1); cast(2i, t2)], cast ([1; 2i], tr));
+%!    assert ([cast(1, t1); cast([2i; 3], t2)], cast ([1; 2i; 3], tr));
+%!    assert ([cast([1; 2], t1); cast(3i, t2)], cast ([1; 2; 3i], tr));
+%!    assert ([cast([1; 2], t1); cast([3i; 4], t2)], cast ([1; 2; 3i; 4], tr));
+%!    assert ([cast(1, t1), cast(2i, t2)], cast ([1, 2i], tr));
+%!    assert ([cast(1, t1), cast([2i, 3], t2)], cast ([1, 2i, 3], tr));
+%!    assert ([cast([1, 2], t1), cast(3i, t2)], cast ([1, 2, 3i], tr));
+%!    assert ([cast([1, 2], t1), cast([3i, 4], t2)], cast ([1, 2, 3i, 4], tr));
+%! 
+%!    assert (cat (1, cast (1i, t1), cast (2i, t2)), cast ([1i; 2i], tr));
+%!    assert (cat (1, cast (1i, t1), cast ([2i; 3], t2)), cast ([1i; 2i; 3], tr));
+%!    assert (cat (1, cast ([1i; 2], t1), cast (3i, t2)), cast ([1i; 2; 3i], tr));
+%!    assert (cat (1, cast ([1i; 2], t1), cast ([3i; 4], t2)), cast ([1i; 2; 3i; 4], tr));
+%!    assert (cat (2, cast (1i, t1), cast (2i, t2)), cast ([1i, 2i], tr));
+%!    assert (cat (2, cast (1i, t1), cast ([2i, 3], t2)), cast ([1i, 2i, 3], tr));
+%!    assert (cat (2, cast ([1i, 2], t1), cast (3i, t2)), cast ([1i, 2, 3i], tr));
+%!    assert (cat (2, cast ([1i, 2], t1), cast ([3i, 4], t2)), cast ([1i, 2, 3i, 4], tr));
+%! 
+%!    assert ([cast(1i, t1); cast(2i, t2)], cast ([1i; 2i], tr));
+%!    assert ([cast(1i, t1); cast([2i; 3], t2)], cast ([1i; 2i; 3], tr));
+%!    assert ([cast([1i; 2], t1); cast(3i, t2)], cast ([1i; 2; 3i], tr));
+%!    assert ([cast([1i; 2], t1); cast([3i; 4], t2)], cast ([1i; 2; 3i; 4], tr));
+%!    assert ([cast(1i, t1), cast(2i, t2)], cast ([1i, 2i], tr));
+%!    assert ([cast(1i, t1), cast([2i, 3], t2)], cast ([1i, 2i, 3], tr));
+%!    assert ([cast([1i, 2], t1), cast(3i, t2)], cast ([1i, 2, 3i], tr));
+%!    assert ([cast([1i, 2], t1), cast([3i, 4], t2)], cast ([1i, 2, 3i, 4], tr));
+%!  endif
+%!  ret = true;
 %!endfunction
 
-%!assert (__testcat('double', 'double', 'double'))
-%!assert (__testcat('single', 'double', 'single'))
-%!assert (__testcat('double', 'single', 'single'))
-%!assert (__testcat('single', 'single', 'single'))
-
-%!assert (__testcat('double', 'int8', 'int8', false))
-%!assert (__testcat('int8', 'double', 'int8', false))
-%!assert (__testcat('single', 'int8', 'int8', false))
-%!assert (__testcat('int8', 'single', 'int8', false))
-%!assert (__testcat('int8', 'int8', 'int8', false))
-%!assert (__testcat('double', 'int16', 'int16', false))
-%!assert (__testcat('int16', 'double', 'int16', false))
-%!assert (__testcat('single', 'int16', 'int16', false))
-%!assert (__testcat('int16', 'single', 'int16', false))
-%!assert (__testcat('int16', 'int16', 'int16', false))
-%!assert (__testcat('double', 'int32', 'int32', false))
-%!assert (__testcat('int32', 'double', 'int32', false))
-%!assert (__testcat('single', 'int32', 'int32', false))
-%!assert (__testcat('int32', 'single', 'int32', false))
-%!assert (__testcat('int32', 'int32', 'int32', false))
-%!assert (__testcat('double', 'int64', 'int64', false))
-%!assert (__testcat('int64', 'double', 'int64', false))
-%!assert (__testcat('single', 'int64', 'int64', false))
-%!assert (__testcat('int64', 'single', 'int64', false))
-%!assert (__testcat('int64', 'int64', 'int64', false))
-
-%!assert (__testcat('double', 'uint8', 'uint8', false))
-%!assert (__testcat('uint8', 'double', 'uint8', false))
-%!assert (__testcat('single', 'uint8', 'uint8', false))
-%!assert (__testcat('uint8', 'single', 'uint8', false))
-%!assert (__testcat('uint8', 'uint8', 'uint8', false))
-%!assert (__testcat('double', 'uint16', 'uint16', false))
-%!assert (__testcat('uint16', 'double', 'uint16', false))
-%!assert (__testcat('single', 'uint16', 'uint16', false))
-%!assert (__testcat('uint16', 'single', 'uint16', false))
-%!assert (__testcat('uint16', 'uint16', 'uint16', false))
-%!assert (__testcat('double', 'uint32', 'uint32', false))
-%!assert (__testcat('uint32', 'double', 'uint32', false))
-%!assert (__testcat('single', 'uint32', 'uint32', false))
-%!assert (__testcat('uint32', 'single', 'uint32', false))
-%!assert (__testcat('uint32', 'uint32', 'uint32', false))
-%!assert (__testcat('double', 'uint64', 'uint64', false))
-%!assert (__testcat('uint64', 'double', 'uint64', false))
-%!assert (__testcat('single', 'uint64', 'uint64', false))
-%!assert (__testcat('uint64', 'single', 'uint64', false))
-%!assert (__testcat('uint64', 'uint64', 'uint64', false))
+%!assert (__testcat ("double", "double", "double"))
+%!assert (__testcat ("single", "double", "single"))
+%!assert (__testcat ("double", "single", "single"))
+%!assert (__testcat ("single", "single", "single"))
+
+%!assert (__testcat ("double", "int8", "int8", false))
+%!assert (__testcat ("int8", "double", "int8", false))
+%!assert (__testcat ("single", "int8", "int8", false))
+%!assert (__testcat ("int8", "single", "int8", false))
+%!assert (__testcat ("int8", "int8", "int8", false))
+%!assert (__testcat ("double", "int16", "int16", false))
+%!assert (__testcat ("int16", "double", "int16", false))
+%!assert (__testcat ("single", "int16", "int16", false))
+%!assert (__testcat ("int16", "single", "int16", false))
+%!assert (__testcat ("int16", "int16", "int16", false))
+%!assert (__testcat ("double", "int32", "int32", false))
+%!assert (__testcat ("int32", "double", "int32", false))
+%!assert (__testcat ("single", "int32", "int32", false))
+%!assert (__testcat ("int32", "single", "int32", false))
+%!assert (__testcat ("int32", "int32", "int32", false))
+%!assert (__testcat ("double", "int64", "int64", false))
+%!assert (__testcat ("int64", "double", "int64", false))
+%!assert (__testcat ("single", "int64", "int64", false))
+%!assert (__testcat ("int64", "single", "int64", false))
+%!assert (__testcat ("int64", "int64", "int64", false))
+
+%!assert (__testcat ("double", "uint8", "uint8", false))
+%!assert (__testcat ("uint8", "double", "uint8", false))
+%!assert (__testcat ("single", "uint8", "uint8", false))
+%!assert (__testcat ("uint8", "single", "uint8", false))
+%!assert (__testcat ("uint8", "uint8", "uint8", false))
+%!assert (__testcat ("double", "uint16", "uint16", false))
+%!assert (__testcat ("uint16", "double", "uint16", false))
+%!assert (__testcat ("single", "uint16", "uint16", false))
+%!assert (__testcat ("uint16", "single", "uint16", false))
+%!assert (__testcat ("uint16", "uint16", "uint16", false))
+%!assert (__testcat ("double", "uint32", "uint32", false))
+%!assert (__testcat ("uint32", "double", "uint32", false))
+%!assert (__testcat ("single", "uint32", "uint32", false))
+%!assert (__testcat ("uint32", "single", "uint32", false))
+%!assert (__testcat ("uint32", "uint32", "uint32", false))
+%!assert (__testcat ("double", "uint64", "uint64", false))
+%!assert (__testcat ("uint64", "double", "uint64", false))
+%!assert (__testcat ("single", "uint64", "uint64", false))
+%!assert (__testcat ("uint64", "single", "uint64", false))
+%!assert (__testcat ("uint64", "uint64", "uint64", false))
 
 %!assert (cat (3, [], [1,2;3,4]), [1,2;3,4])
 %!assert (cat (3, [1,2;3,4], []), [1,2;3,4])
 %!assert (cat (3, [], [1,2;3,4], []), [1,2;3,4])
 %!assert (cat (3, [], [], []), zeros (0, 0, 3))
 
 %!assert (cat (3, [], [], 1, 2), cat (3, 1, 2))
 %!assert (cat (3, [], [], [1,2;3,4]), [1,2;3,4])
 %!assert (cat (4, [], [], [1,2;3,4]), [1,2;3,4])
+
+%!assert ([zeros(3,2,2); ones(1,2,2)], repmat ([0;0;0;1],[1,2,2]) )
+%!assert ([zeros(3,2,2); ones(1,2,2)], vertcat (zeros (3,2,2), ones (1,2,2)) )
+
 %!error <dimension mismatch> cat (3, cat (3, [], []), [1,2;3,4])
 %!error <dimension mismatch> cat (3, zeros (0, 0, 2), [1,2;3,4])
-
-%!assert ([zeros(3,2,2); ones(1,2,2)], repmat([0;0;0;1],[1,2,2]) )
-%!assert ([zeros(3,2,2); ones(1,2,2)], vertcat(zeros(3,2,2), ones(1,2,2)) )
-
 */
 
 static octave_value
 do_permute (const octave_value_list& args, bool inv)
 {
   octave_value retval;
 
   if (args.length () == 2 && args(1).length () >= args(1).ndims ())
@@ -2798,74 +2785,72 @@ effect.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
-%!assert (sum([true,true]), 2)
-%!assert (sum([true,true],'native'), true)
-%!assert (sum(int8([127,10,-20])), 117);
-%!assert (sum(int8([127,10,-20]),'native'), int8(107));
-
-%!assert(sum ([1, 2, 3]), 6)
-%!assert(sum ([-1; -2; -3]), -6);
-%!assert(sum ([i, 2+i, -3+2i, 4]), 3+4i);
-%!assert(sum ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i]), [2+2i, 4+4i, 6+6i]);
-
-%!assert(sum (single([1, 2, 3])), single(6))
-%!assert(sum (single([-1; -2; -3])), single(-6));
-%!assert(sum (single([i, 2+i, -3+2i, 4])), single(3+4i));
-%!assert(sum (single([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i])), single([2+2i, 4+4i, 6+6i]));
-
-%!error <Invalid call to sum> sum ();
-
-%!assert (sum ([1, 2; 3, 4], 1), [4, 6]);
-%!assert (sum ([1, 2; 3, 4], 2), [3; 7]);
-%!assert (sum (zeros (1, 0)), 0);
-%!assert (sum (zeros (1, 0), 1), zeros(1, 0));
-%!assert (sum (zeros (1, 0), 2), 0);
-%!assert (sum (zeros (0, 1)), 0);
-%!assert (sum (zeros (0, 1), 1), 0);
-%!assert (sum (zeros (0, 1), 2), zeros(0, 1));
-%!assert (sum (zeros (2, 0)),  zeros(1, 0));
-%!assert (sum (zeros (2, 0), 1), zeros(1, 0));
-%!assert (sum (zeros (2, 0), 2),  [0; 0]);
-%!assert (sum (zeros (0, 2)), [0, 0]);
-%!assert (sum (zeros (0, 2), 1), [0, 0]);
-%!assert (sum (zeros (0, 2), 2), zeros(0, 1));
-%!assert (sum (zeros (2, 2, 0, 3)), zeros(1, 2, 0, 3));
-%!assert (sum (zeros (2, 2, 0, 3), 2), zeros(2, 1, 0, 3));
-%!assert (sum (zeros (2, 2, 0, 3), 3), zeros(2, 2, 1, 3));
-%!assert (sum (zeros (2, 2, 0, 3), 4), zeros(2, 2, 0));
-%!assert (sum (zeros (2, 2, 0, 3), 7), zeros(2, 2, 0, 3));
-
-%!assert (sum (single([1, 2; 3, 4]), 1), single([4, 6]));
-%!assert (sum (single([1, 2; 3, 4]), 2), single([3; 7]));
-%!assert (sum (zeros (1, 0, 'single')), single(0));
-%!assert (sum (zeros (1, 0, 'single'), 1), zeros(1, 0, 'single'));
-%!assert (sum (zeros (1, 0, 'single'), 2), single(0));
-%!assert (sum (zeros (0, 1, 'single')), single(0));
-%!assert (sum (zeros (0, 1, 'single'), 1), single(0));
-%!assert (sum (zeros (0, 1, 'single'), 2), zeros(0, 1, 'single'));
-%!assert (sum (zeros (2, 0, 'single')),  zeros(1, 0, 'single'));
-%!assert (sum (zeros (2, 0, 'single'), 1), zeros(1, 0, 'single'));
-%!assert (sum (zeros (2, 0, 'single'), 2),  single([0; 0]));
-%!assert (sum (zeros (0, 2, 'single')), single([0, 0]));
-%!assert (sum (zeros (0, 2, 'single'), 1), single([0, 0]));
-%!assert (sum (zeros (0, 2, 'single'), 2), zeros(0, 1, 'single'));
-%!assert (sum (zeros (2, 2, 0, 3, 'single')), zeros(1, 2, 0, 3, 'single'));
-%!assert (sum (zeros (2, 2, 0, 3, 'single'), 2), zeros(2, 1, 0, 3, 'single'));
-%!assert (sum (zeros (2, 2, 0, 3, 'single'), 3), zeros(2, 2, 1, 3, 'single'));
-%!assert (sum (zeros (2, 2, 0, 3, 'single'), 4), zeros(2, 2, 0, 'single'));
-%!assert (sum (zeros (2, 2, 0, 3, 'single'), 7), zeros(2, 2, 0, 3, 'single'));
-
+%!assert (sum ([true,true]), 2)
+%!assert (sum ([true,true],"native"), true)
+%!assert (sum (int8 ([127,10,-20])), 117)
+%!assert (sum (int8 ([127,10,-20]),'native'), int8 (107))
+
+%!assert (sum ([1, 2, 3]), 6)
+%!assert (sum ([-1; -2; -3]), -6)
+%!assert (sum ([i, 2+i, -3+2i, 4]), 3+4i)
+%!assert (sum ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i]), [2+2i, 4+4i, 6+6i])
+
+%!assert (sum (single ([1, 2, 3])), single (6))
+%!assert (sum (single ([-1; -2; -3])), single (-6))
+%!assert (sum (single ([i, 2+i, -3+2i, 4])), single (3+4i))
+%!assert (sum (single ([1, 2, 3; i, 2i, 3i; 1+i, 2+2i, 3+3i])), single ([2+2i, 4+4i, 6+6i]))
+
+%!assert (sum ([1, 2; 3, 4], 1), [4, 6])
+%!assert (sum ([1, 2; 3, 4], 2), [3; 7])
+%!assert (sum (zeros (1, 0)), 0)
+%!assert (sum (zeros (1, 0), 1), zeros (1, 0))
+%!assert (sum (zeros (1, 0), 2), 0)
+%!assert (sum (zeros (0, 1)), 0)
+%!assert (sum (zeros (0, 1), 1), 0)
+%!assert (sum (zeros (0, 1), 2), zeros (0, 1))
+%!assert (sum (zeros (2, 0)),  zeros (1, 0))
+%!assert (sum (zeros (2, 0), 1), zeros (1, 0))
+%!assert (sum (zeros (2, 0), 2),  [0; 0])
+%!assert (sum (zeros (0, 2)), [0, 0])
+%!assert (sum (zeros (0, 2), 1), [0, 0])
+%!assert (sum (zeros (0, 2), 2), zeros (0, 1))
+%!assert (sum (zeros (2, 2, 0, 3)), zeros (1, 2, 0, 3))
+%!assert (sum (zeros (2, 2, 0, 3), 2), zeros (2, 1, 0, 3))
+%!assert (sum (zeros (2, 2, 0, 3), 3), zeros (2, 2, 1, 3))
+%!assert (sum (zeros (2, 2, 0, 3), 4), zeros (2, 2, 0))
+%!assert (sum (zeros (2, 2, 0, 3), 7), zeros (2, 2, 0, 3))
+
+%!assert (sum (single ([1, 2; 3, 4]), 1), single ([4, 6]))
+%!assert (sum (single ([1, 2; 3, 4]), 2), single ([3; 7]))
+%!assert (sum (zeros (1, 0, "single")), single (0))
+%!assert (sum (zeros (1, 0, "single"), 1), zeros (1, 0, "single"))
+%!assert (sum (zeros (1, 0, "single"), 2), single (0))
+%!assert (sum (zeros (0, 1, "single")), single (0))
+%!assert (sum (zeros (0, 1, "single"), 1), single (0))
+%!assert (sum (zeros (0, 1, "single"), 2), zeros (0, 1, "single"))
+%!assert (sum (zeros (2, 0, "single")),  zeros (1, 0, "single"))
+%!assert (sum (zeros (2, 0, "single"), 1), zeros (1, 0, "single"))
+%!assert (sum (zeros (2, 0, "single"), 2),  single ([0; 0]))
+%!assert (sum (zeros (0, 2, "single")), single ([0, 0]))
+%!assert (sum (zeros (0, 2, "single"), 1), single ([0, 0]))
+%!assert (sum (zeros (0, 2, "single"), 2), zeros (0, 1, "single"))
+%!assert (sum (zeros (2, 2, 0, 3, "single")), zeros (1, 2, 0, 3, "single"))
+%!assert (sum (zeros (2, 2, 0, 3, "single"), 2), zeros (2, 1, 0, 3, "single"))
+%!assert (sum (zeros (2, 2, 0, 3, "single"), 3), zeros (2, 2, 1, 3, "single"))
+%!assert (sum (zeros (2, 2, 0, 3, "single"), 4), zeros (2, 2, 0, "single"))
+%!assert (sum (zeros (2, 2, 0, 3, "single"), 7), zeros (2, 2, 0, 3, "single"))
+
+%!error sum ()
 */
 
 DEFUN (sumsq, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} sumsq (@var{x})\n\
 @deftypefnx {Built-in Function} {} sumsq (@var{x}, @var{dim})\n\
 Sum of squares of elements along dimension @var{dim}.  If @var{dim}\n\
 is omitted, it defaults to the first non-singleton dimension.\n\
@@ -2880,34 +2865,32 @@ sum (x .* conj (x), dim)\n\
 but it uses less memory and avoids calling @code{conj} if @var{x} is real.\n\
 @seealso{sum}\n\
 @end deftypefn")
 {
   DATA_REDUCTION (sumsq);
 }
 
 /*
-
-%!assert(sumsq ([1, 2, 3]), 14)
-%!assert(sumsq ([-1; -2; 4i]), 21);
-%!assert(sumsq ([1, 2, 3; 2, 3, 4; 4i, 6i, 2]), [21, 49, 29]);
-
-%!assert(sumsq (single([1, 2, 3])), single(14))
-%!assert(sumsq (single([-1; -2; 4i])), single(21));
-%!assert(sumsq (single([1, 2, 3; 2, 3, 4; 4i, 6i, 2])), single([21, 49, 29]));
-
-%!error <Invalid call to sumsq> sumsq ();
-
-%!assert (sumsq ([1, 2; 3, 4], 1), [10, 20]);
-%!assert (sumsq ([1, 2; 3, 4], 2), [5; 25]);
-
-%!assert (sumsq (single([1, 2; 3, 4]), 1), single([10, 20]));
-%!assert (sumsq (single([1, 2; 3, 4]), 2), single([5; 25]));
-
- */
+%!assert (sumsq ([1, 2, 3]), 14)
+%!assert (sumsq ([-1; -2; 4i]), 21)
+%!assert (sumsq ([1, 2, 3; 2, 3, 4; 4i, 6i, 2]), [21, 49, 29])
+
+%!assert (sumsq (single ([1, 2, 3])), single (14))
+%!assert (sumsq (single ([-1; -2; 4i])), single (21))
+%!assert (sumsq (single ([1, 2, 3; 2, 3, 4; 4i, 6i, 2])), single ([21, 49, 29]))
+
+%!assert (sumsq ([1, 2; 3, 4], 1), [10, 20])
+%!assert (sumsq ([1, 2; 3, 4], 2), [5; 25])
+
+%!assert (sumsq (single ([1, 2; 3, 4]), 1), single ([10, 20]))
+%!assert (sumsq (single ([1, 2; 3, 4]), 2), single ([5; 25]))
+
+%!error sumsq ()
+*/
 
 DEFUN (islogical, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} islogical (@var{x})\n\
 @deftypefnx {Built-in Function} {} isbool (@var{x})\n\
 Return true if @var{x} is a logical object.\n\
 @seealso{isfloat, isinteger, ischar, isnumeric, isa}\n\
 @end deftypefn")
@@ -2920,30 +2903,28 @@ Return true if @var{x} is a logical obje
     print_usage ();
 
   return retval;
 }
 
 DEFALIAS (isbool, islogical);
 
 /*
-
-%!assert (islogical(true), true)
-%!assert (islogical(false), true)
-%!assert (islogical([true, false]), true)
-%!assert (islogical(1), false)
-%!assert (islogical(1i), false)
-%!assert (islogical([1,1]), false)
-%!assert (islogical(single(1)), false)
-%!assert (islogical(single(1i)), false)
-%!assert (islogical(single([1,1])), false)
-%!assert (islogical(sparse ([true, false])), true)
-%!assert (islogical(sparse ([1, 0])), false)
-
- */
+%!assert (islogical (true), true)
+%!assert (islogical (false), true)
+%!assert (islogical ([true, false]), true)
+%!assert (islogical (1), false)
+%!assert (islogical (1i), false)
+%!assert (islogical ([1,1]), false)
+%!assert (islogical (single (1)), false)
+%!assert (islogical (single (1i)), false)
+%!assert (islogical (single ([1,1])), false)
+%!assert (islogical (sparse ([true, false])), true)
+%!assert (islogical (sparse ([1, 0])), false)
+*/
 
 DEFUN (isinteger, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isinteger (@var{x})\n\
 Return true if @var{x} is an integer object (int8, uint8, int16, etc.).\n\
 Note that @w{@code{isinteger (14)}} is false because numeric constants in\n\
 Octave are double precision floating point values.\n\
 @seealso{isfloat, ischar, islogical, isnumeric, isa}\n\
@@ -3338,31 +3319,29 @@ numeric.\n\
     retval = args(0).is_numeric_type ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
-%!assert (isnumeric(1), true)
-%!assert (isnumeric(1i), true)
-%!assert (isnumeric([1,1]), true)
-%!assert (isnumeric(single(1)), true)
-%!assert (isnumeric(single(1i)), true)
-%!assert (isnumeric(single([1,1])), true)
-%!assert (isnumeric(int8(1)), true)
-%!assert (isnumeric(uint8([1,1])), true)
-%!assert (isnumeric("Hello World"), false)
-%!assert (isnumeric(true), false)
-%!assert (isnumeric(false), false)
-%!assert (isnumeric([true, false]), false)
-%!assert (isnumeric(sparse ([true, false])), false)
-
+%!assert (isnumeric (1), true)
+%!assert (isnumeric (1i), true)
+%!assert (isnumeric ([1,1]), true)
+%!assert (isnumeric (single (1)), true)
+%!assert (isnumeric (single (1i)), true)
+%!assert (isnumeric (single ([1,1])), true)
+%!assert (isnumeric (int8 (1)), true)
+%!assert (isnumeric (uint8 ([1,1])), true)
+%!assert (isnumeric ("Hello World"), false)
+%!assert (isnumeric (true), false)
+%!assert (isnumeric (false), false)
+%!assert (isnumeric ([true, false]), false)
+%!assert (isnumeric (sparse ([true, false])), false)
 */
 
 DEFUN (ismatrix, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ismatrix (@var{a})\n\
 Return true if @var{a} is a numeric, logical, or character matrix.\n\
 Scalars (1x1 matrices) and vectors (@nospell{1xN} or @nospell{Nx1} matrices)\n\
 are subsets of the more general N-dimensional matrix and @code{ismatrix}\n\
@@ -3380,40 +3359,38 @@ will return true for these objects as we
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
-%!assert(ismatrix ([]));
-%!assert(ismatrix (1));
-%!assert(ismatrix ([1, 2, 3]));
-%!assert(ismatrix ([1, 2; 3, 4]));
-%!assert(ismatrix (zeros (3, 2, 4)));
-
-%!assert(ismatrix (single([])));
-%!assert(ismatrix (single(1)));
-%!assert(ismatrix (single([1, 2, 3])));
-%!assert(ismatrix (single([1, 2; 3, 4])));
-
-%!assert(ismatrix ("t"));
-%!assert(ismatrix ("test"));
-%!assert(ismatrix (["test"; "ing"]));
+%!assert (ismatrix ([]))
+%!assert (ismatrix (1))
+%!assert (ismatrix ([1, 2, 3]))
+%!assert (ismatrix ([1, 2; 3, 4]))
+%!assert (ismatrix (zeros (3, 2, 4)))
+
+%!assert (ismatrix (single ([])))
+%!assert (ismatrix (single (1)))
+%!assert (ismatrix (single ([1, 2, 3])))
+%!assert (ismatrix (single ([1, 2; 3, 4])))
+
+%!assert (ismatrix ("t"))
+%!assert (ismatrix ("test"))
+%!assert (ismatrix (["test"; "ing"]))
 
 %!test
 %! s.a = 1;
-%! assert(ismatrix (s), false);
-
-%!error <Invalid call to ismatrix> ismatrix ();
-%!error <Invalid call to ismatrix> ismatrix ([1, 2; 3, 4], 2);
-
- */
+%! assert (ismatrix (s), false);
+
+%!error ismatrix ()
+%!error ismatrix ([1, 2; 3, 4], 2)
+*/
 
 static octave_value
 fill_matrix (const octave_value_list& args, int val, const char *fcn)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
@@ -3857,33 +3834,31 @@ val = ones (m,n, \"uint8\")\n\
 @end example\n\
 @seealso{zeros}\n\
 @end deftypefn")
 {
   return fill_matrix (args, 1, "ones");
 }
 
 /*
-
-%!assert(ones (3), [1, 1, 1; 1, 1, 1; 1, 1, 1]);
-%!assert(ones (2, 3), [1, 1, 1; 1, 1, 1]);
-%!assert(ones (3, 2), [1, 1; 1, 1; 1, 1]);
-%!assert(size (ones (3, 4, 5)),  [3, 4, 5]);
-
-%!assert(ones (3,'single'), single([1, 1, 1; 1, 1, 1; 1, 1, 1]));
-%!assert(ones (2, 3,'single'), single([1, 1, 1; 1, 1, 1]));
-%!assert(ones (3, 2,'single'), single([1, 1; 1, 1; 1, 1]));
-%!assert(size (ones (3, 4, 5, 'single')),  [3, 4, 5]);
-
-%!assert(ones (3,'int8'), int8([1, 1, 1; 1, 1, 1; 1, 1, 1]));
-%!assert(ones (2, 3,'int8'), int8([1, 1, 1; 1, 1, 1]));
-%!assert(ones (3, 2,'int8'), int8([1, 1; 1, 1; 1, 1]));
-%!assert(size (ones (3, 4, 5, 'int8')),  [3, 4, 5]);
-
- */
+%!assert (ones (3), [1, 1, 1; 1, 1, 1; 1, 1, 1])
+%!assert (ones (2, 3), [1, 1, 1; 1, 1, 1])
+%!assert (ones (3, 2), [1, 1; 1, 1; 1, 1])
+%!assert (size (ones (3, 4, 5)), [3, 4, 5])
+
+%!assert (ones (3, "single"), single ([1, 1, 1; 1, 1, 1; 1, 1, 1]))
+%!assert (ones (2, 3, "single"), single ([1, 1, 1; 1, 1, 1]))
+%!assert (ones (3, 2, "single"), single ([1, 1; 1, 1; 1, 1]))
+%!assert (size (ones (3, 4, 5, "single")), [3, 4, 5])
+
+%!assert (ones (3, "int8"), int8 ([1, 1, 1; 1, 1, 1; 1, 1, 1]))
+%!assert (ones (2, 3, "int8"), int8 ([1, 1, 1; 1, 1, 1]))
+%!assert (ones (3, 2, "int8"), int8 ([1, 1; 1, 1; 1, 1]))
+%!assert (size (ones (3, 4, 5, "int8")), [3, 4, 5])
+*/
 
 DEFUN (zeros, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} zeros (@var{n})\n\
 @deftypefnx {Built-in Function} {} zeros (@var{m}, @var{n})\n\
 @deftypefnx {Built-in Function} {} zeros (@var{m}, @var{n}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} zeros ([@var{m} @var{n} @dots{}])\n\
 @deftypefnx {Built-in Function} {} zeros (@dots{}, @var{class})\n\
@@ -3901,33 +3876,31 @@ val = zeros (m,n, \"uint8\")\n\
 @end example\n\
 @seealso{ones}\n\
 @end deftypefn")
 {
   return fill_matrix (args, 0, "zeros");
 }
 
 /*
-
-%!assert(zeros (3), [0, 0, 0; 0, 0, 0; 0, 0, 0]);
-%!assert(zeros (2, 3), [0, 0, 0; 0, 0, 0]);
-%!assert(zeros (3, 2), [0, 0; 0, 0; 0, 0]);
-%!assert(size (zeros (3, 4, 5)),  [3, 4, 5]);
-
-%!assert(zeros (3,'single'), single([0, 0, 0; 0, 0, 0; 0, 0, 0]));
-%!assert(zeros (2, 3,'single'), single([0, 0, 0; 0, 0, 0]));
-%!assert(zeros (3, 2,'single'), single([0, 0; 0, 0; 0, 0]));
-%!assert(size (zeros (3, 4, 5, 'single')),  [3, 4, 5]);
-
-%!assert(zeros (3,'int8'), int8([0, 0, 0; 0, 0, 0; 0, 0, 0]));
-%!assert(zeros (2, 3,'int8'), int8([0, 0, 0; 0, 0, 0]));
-%!assert(zeros (3, 2,'int8'), int8([0, 0; 0, 0; 0, 0]));
-%!assert(size (zeros (3, 4, 5, 'int8')),  [3, 4, 5]);
-
- */
+%!assert (zeros (3), [0, 0, 0; 0, 0, 0; 0, 0, 0])
+%!assert (zeros (2, 3), [0, 0, 0; 0, 0, 0])
+%!assert (zeros (3, 2), [0, 0; 0, 0; 0, 0])
+%!assert (size (zeros (3, 4, 5)), [3, 4, 5])
+
+%!assert (zeros (3, "single"), single ([0, 0, 0; 0, 0, 0; 0, 0, 0]))
+%!assert (zeros (2, 3, "single"), single ([0, 0, 0; 0, 0, 0]))
+%!assert (zeros (3, 2, "single"), single ([0, 0; 0, 0; 0, 0]))
+%!assert (size (zeros (3, 4, 5, "single")), [3, 4, 5])
+
+%!assert (zeros (3, "int8"), int8 ([0, 0, 0; 0, 0, 0; 0, 0, 0]))
+%!assert (zeros (2, 3, "int8"), int8 ([0, 0, 0; 0, 0, 0]))
+%!assert (zeros (3, 2, "int8"), int8 ([0, 0; 0, 0; 0, 0]))
+%!assert (size (zeros (3, 4, 5, "int8")), [3, 4, 5])
+*/
 
 DEFUN (Inf, args, ,
   "-*- texinfo -*-\n\
 @c List other form of function in documentation index\n\
 @findex inf\n\
 \n\
 @deftypefn  {Built-in Function} {} Inf\n\
 @deftypefnx {Built-in Function} {} Inf (@var{n})\n\
@@ -3960,33 +3933,31 @@ either \"double\" or \"single\".\n\
 {
   return fill_matrix (args, lo_ieee_inf_value (),
                       lo_ieee_float_inf_value (), "Inf");
 }
 
 DEFALIAS (inf, Inf);
 
 /*
-
-%!assert(inf (3), [Inf, Inf, Inf; Inf, Inf, Inf; Inf, Inf, Inf]);
-%!assert(inf (2, 3), [Inf, Inf, Inf; Inf, Inf, Inf]);
-%!assert(inf (3, 2), [Inf, Inf; Inf, Inf; Inf, Inf]);
-%!assert(size (inf (3, 4, 5)),  [3, 4, 5]);
-
-%!assert(inf (3,'single'), single([Inf, Inf, Inf; Inf, Inf, Inf; Inf, Inf, Inf]));
-%!assert(inf (2, 3,'single'), single([Inf, Inf, Inf; Inf, Inf, Inf]));
-%!assert(inf (3, 2,'single'), single([Inf, Inf; Inf, Inf; Inf, Inf]));
-%!assert(size (inf (3, 4, 5, 'single')),  [3, 4, 5]);
-
-%!error(inf (3,'int8'));
-%!error(inf (2, 3,'int8'));
-%!error(inf (3, 2,'int8'));
-%!error(inf (3, 4, 5, 'int8'));
-
- */
+%!assert (inf (3), [Inf, Inf, Inf; Inf, Inf, Inf; Inf, Inf, Inf])
+%!assert (inf (2, 3), [Inf, Inf, Inf; Inf, Inf, Inf])
+%!assert (inf (3, 2), [Inf, Inf; Inf, Inf; Inf, Inf])
+%!assert (size (inf (3, 4, 5)), [3, 4, 5])
+
+%!assert (inf (3, "single"), single ([Inf, Inf, Inf; Inf, Inf, Inf; Inf, Inf, Inf]))
+%!assert (inf (2, 3, "single"), single ([Inf, Inf, Inf; Inf, Inf, Inf]))
+%!assert (inf (3, 2, "single"), single ([Inf, Inf; Inf, Inf; Inf, Inf]))
+%!assert (size (inf (3, 4, 5, "single")), [3, 4, 5])
+
+%!error (inf (3, "int8"))
+%!error (inf (2, 3, "int8"))
+%!error (inf (3, 2, "int8"))
+%!error (inf (3, 4, 5, "int8"))
+*/
 
 DEFUN (NaN, args, ,
   "-*- texinfo -*-\n\
 @c List other form of function in documentation index\n\
 @findex nan\n\
 \n\
 @deftypefn  {Built-in Function} {} NaN\n\
 @deftypefnx {Built-in Function} {} NaN (@var{n})\n\
@@ -4021,32 +3992,31 @@ either \"double\" or \"single\".\n\
 {
   return fill_matrix (args, lo_ieee_nan_value (),
                       lo_ieee_float_nan_value (), "NaN");
 }
 
 DEFALIAS (nan, NaN);
 
 /*
-%!assert(NaN (3), [NaN, NaN, NaN; NaN, NaN, NaN; NaN, NaN, NaN]);
-%!assert(NaN (2, 3), [NaN, NaN, NaN; NaN, NaN, NaN]);
-%!assert(NaN (3, 2), [NaN, NaN; NaN, NaN; NaN, NaN]);
-%!assert(size (NaN (3, 4, 5)),  [3, 4, 5]);
-
-%!assert(NaN (3,'single'), single([NaN, NaN, NaN; NaN, NaN, NaN; NaN, NaN, NaN]));
-%!assert(NaN (2, 3,'single'), single([NaN, NaN, NaN; NaN, NaN, NaN]));
-%!assert(NaN (3, 2,'single'), single([NaN, NaN; NaN, NaN; NaN, NaN]));
-%!assert(size (NaN (3, 4, 5, 'single')),  [3, 4, 5]);
-
-%!error(NaN (3,'int8'));
-%!error(NaN (2, 3,'int8'));
-%!error(NaN (3, 2,'int8'));
-%!error(NaN (3, 4, 5, 'int8'));
-
- */
+%!assert (NaN (3), [NaN, NaN, NaN; NaN, NaN, NaN; NaN, NaN, NaN])
+%!assert (NaN (2, 3), [NaN, NaN, NaN; NaN, NaN, NaN])
+%!assert (NaN (3, 2), [NaN, NaN; NaN, NaN; NaN, NaN])
+%!assert (size (NaN (3, 4, 5)), [3, 4, 5])
+
+%!assert (NaN (3, "single"), single ([NaN, NaN, NaN; NaN, NaN, NaN; NaN, NaN, NaN]))
+%!assert (NaN (2, 3, "single"), single ([NaN, NaN, NaN; NaN, NaN, NaN]))
+%!assert (NaN (3, 2, "single"), single ([NaN, NaN; NaN, NaN; NaN, NaN]))
+%!assert (size (NaN (3, 4, 5, "single")), [3, 4, 5])
+
+%!error (NaN (3, "int8"))
+%!error (NaN (2, 3, "int8"))
+%!error (NaN (3, 2, "int8"))
+%!error (NaN (3, 4, 5, "int8"))
+*/
 
 DEFUN (e, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} e\n\
 @deftypefnx {Built-in Function} {} e (@var{n})\n\
 @deftypefnx {Built-in Function} {} e (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} e (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} e (@dots{}, @var{class})\n\
@@ -4166,39 +4136,36 @@ either \"double\" or \"single\".\n\
     }
   else
     retval = fill_matrix (args, DBL_EPSILON, FLT_EPSILON, "eps");
 
   return retval;
 }
 
 /*
-
-%!assert(eps(1/2),2^(-53))
-%!assert(eps(1),2^(-52))
-%!assert(eps(2),2^(-51))
-%!assert(eps(realmax),2^971)
-%!assert(eps(0),2^(-1074))
-%!assert(eps(realmin/2),2^(-1074))
-%!assert(eps(realmin/16),2^(-1074))
-%!assert(eps(Inf),NaN)
-%!assert(eps(NaN),NaN)
-%!assert(eps(single(1/2)),single(2^(-24)))
-%!assert(eps(single(1)),single(2^(-23)))
-%!assert(eps(single(2)),single(2^(-22)))
-%!assert(eps(realmax('single')),single(2^104))
-%!assert(eps(single(0)),single(2^(-149)))
-%!assert(eps(realmin('single')/2),single(2^(-149)))
-%!assert(eps(realmin('single')/16),single(2^(-149)))
-%!assert(eps(single(Inf)),single(NaN))
-%!assert(eps(single(NaN)),single(NaN))
-
+%!assert (eps (1/2), 2^(-53))
+%!assert (eps (1), 2^(-52))
+%!assert (eps (2), 2^(-51))
+%!assert (eps (realmax), 2^971)
+%!assert (eps (0), 2^(-1074))
+%!assert (eps (realmin/2), 2^(-1074))
+%!assert (eps (realmin/16), 2^(-1074))
+%!assert (eps (Inf), NaN)
+%!assert (eps (NaN), NaN)
+%!assert (eps (single (1/2)), single (2^(-24)))
+%!assert (eps (single (1)), single (2^(-23)))
+%!assert (eps (single (2)), single (2^(-22)))
+%!assert (eps (realmax ("single")), single (2^104))
+%!assert (eps (single (0)), single (2^(-149)))
+%!assert (eps (realmin ("single")/2), single (2^(-149)))
+%!assert (eps (realmin ("single")/16), single (2^(-149)))
+%!assert (eps (single (Inf)), single (NaN))
+%!assert (eps (single (NaN)), single (NaN))
 */
 
-
 DEFUN (pi, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} pi\n\
 @deftypefnx {Built-in Function} {} pi (@var{n})\n\
 @deftypefnx {Built-in Function} {} pi (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} pi (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} pi (@dots{}, @var{class})\n\
 Return a scalar, matrix, or N-dimensional array whose elements are all equal\n\
@@ -4363,21 +4330,19 @@ either \"double\" or \"single\".\n\
 @seealso{isna}\n\
 @end deftypefn")
 {
   return fill_matrix (args, lo_ieee_na_value (),
                       lo_ieee_float_na_value (), "NA");
 }
 
 /*
-
-%!assert(single(NA('double')),NA('single'))
-%!assert(double(NA('single')),NA('double'))
-
- */
+%!assert (single (NA ("double")), NA ("single"))
+%!assert (double (NA ("single")), NA ("double"))
+*/
 
 DEFUN (false, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} false (@var{x})\n\
 @deftypefnx {Built-in Function} {} false (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} false (@var{n}, @var{m}, @var{k}, @dots{})\n\
 Return a matrix or N-dimensional array whose elements are all logical 0.\n\
 If invoked with a single scalar integer argument, return a square\n\
@@ -4616,31 +4581,28 @@ These odd definitions are for compatibil
     default:
       print_usage ();
       break;
     }
 
   return retval;
 }
 
-
 /*
-
-%!assert (full (eye(3)), [1, 0, 0; 0, 1, 0; 0, 0, 1]);
-%!assert (full (eye(2, 3)), [1, 0, 0; 0, 1, 0]);
-
-%!assert (full (eye(3,'single')), single([1, 0, 0; 0, 1, 0; 0, 0, 1]));
-%!assert (full (eye(2, 3,'single')), single([1, 0, 0; 0, 1, 0]));
-
-%!assert (eye(3,'int8'), int8([1, 0, 0; 0, 1, 0; 0, 0, 1]));
-%!assert (eye(2, 3,'int8'), int8([1, 0, 0; 0, 1, 0]));
-
-%!error <Invalid call to eye> eye (1, 2, 3);
-
- */
+%!assert (full (eye (3)), [1, 0, 0; 0, 1, 0; 0, 0, 1])
+%!assert (full (eye (2, 3)), [1, 0, 0; 0, 1, 0])
+
+%!assert (full (eye (3,"single")), single ([1, 0, 0; 0, 1, 0; 0, 0, 1]))
+%!assert (full (eye (2, 3,"single")), single ([1, 0, 0; 0, 1, 0]))
+
+%!assert (eye (3, "int8"), int8 ([1, 0, 0; 0, 1, 0; 0, 0, 1]))
+%!assert (eye (2, 3, "int8"), int8 ([1, 0, 0; 0, 1, 0]))
+
+%!error eye (1, 2, 3)
+*/
 
 template <class MT>
 static octave_value
 do_linspace (const octave_value& base, const octave_value& limit,
              octave_idx_type n)
 {
   typedef typename MT::column_vector_type CVT;
   typedef typename MT::element_type T;
@@ -4739,34 +4701,30 @@ if fewer than two values are requested.\
   else
     error ("linspace: N must be an integer");
 
   return retval;
 }
 
 
 /*
-
 %!test
 %! x1 = linspace (1, 2);
 %! x2 = linspace (1, 2, 10);
 %! x3 = linspace (1, -2, 10);
-%! assert((size (x1) == [1, 100] && x1(1) == 1 && x1(100) == 2
-%! && size (x2) == [1, 10] && x2(1) == 1 && x2(10) == 2
-%! && size (x3) == [1, 10] && x3(1) == 1 && x3(10) == -2));
-
-
-% assert(linspace ([1, 2; 3, 4], 5, 6), linspace (1, 5, 6));
-
-%!error <Invalid call to linspace> linspace ();
-%!error <Invalid call to linspace> linspace (1, 2, 3, 4);
-
-%!test
-%! fail("linspace ([1, 2; 3, 4], 5, 6)","warning");
-
+%! assert (size (x1) == [1, 100] && x1(1) == 1 && x1(100) == 2);
+%! assert (size (x2) == [1, 10] && x2(1) == 1 && x2(10) == 2);
+%! assert (size (x3) == [1, 10] && x3(1) == 1 && x3(10) == -2);
+
+%#assert (linspace ([1, 2; 3, 4], 5, 6), linspace (1, 5, 6))
+
+%!fail ("linspace ([1, 2; 3, 4], 5, 6)", "warning")
+
+%!error linspace ()
+%!error linspace (1, 2, 3, 4)
 */
 
 // FIXME -- should accept dimensions as separate args for N-d
 // arrays as well as 1-d and 2-d arrays.
 
 DEFUN (resize, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} resize (@var{x}, @var{m})\n\
@@ -4972,35 +4930,33 @@ the unspecified dimension.\n\
 
   if (! error_state)
     retval = args(0).reshape (new_dims);
 
   return retval;
 }
 
 /*
-
-%!assert(size (reshape (ones (4, 4), 2, 8)), [2, 8])
-%!assert(size (reshape (ones (4, 4), 8, 2)), [8, 2])
-%!assert(size (reshape (ones (15, 4), 1, 60)), [1, 60])
-%!assert(size (reshape (ones (15, 4), 60, 1)), [60, 1])
-
-%!assert(size (reshape (ones (4, 4, 'single'), 2, 8)), [2, 8])
-%!assert(size (reshape (ones (4, 4, 'single'), 8, 2)), [8, 2])
-%!assert(size (reshape (ones (15, 4, 'single'), 1, 60)), [1, 60])
-%!assert(size (reshape (ones (15, 4, 'single'), 60, 1)), [60, 1])
+%!assert (size (reshape (ones (4, 4), 2, 8)), [2, 8])
+%!assert (size (reshape (ones (4, 4), 8, 2)), [8, 2])
+%!assert (size (reshape (ones (15, 4), 1, 60)), [1, 60])
+%!assert (size (reshape (ones (15, 4), 60, 1)), [60, 1])
+
+%!assert (size (reshape (ones (4, 4, "single"), 2, 8)), [2, 8])
+%!assert (size (reshape (ones (4, 4, "single"), 8, 2)), [8, 2])
+%!assert (size (reshape (ones (15, 4, "single"), 1, 60)), [1, 60])
+%!assert (size (reshape (ones (15, 4, "single"), 60, 1)), [60, 1])
 
 %!test
 %! s.a = 1;
-%! fail("reshape (s, 2, 3)");
-
-%!error <Invalid call to reshape> reshape ();
-%!error reshape (1, 2, 3, 4);
-
- */
+%! fail ("reshape (s, 2, 3)");
+
+%!error reshape ()
+%!error reshape (1, 2, 3, 4)
+*/
 
 DEFUN (vec, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{v} =} vec (@var{x})\n\
 @deftypefnx {Built-in Function} {@var{v} =} vec (@var{x}, @var{dim})\n\
 Return the vector obtained by stacking the columns of the matrix @var{x}\n\
 one above the other.  Without @var{dim} this is equivalent to\n\
 @code{@var{x}(:)}.  If @var{dim} is supplied, the dimensions of @var{v}\n\
@@ -5044,30 +5000,28 @@ This is equivalent to @code{shiftdim (@v
           retval = retval.reshape (new_dims);
         }
     }
 
   return retval;
 }
 
 /*
-
-%!assert(vec ([1, 2; 3, 4]), [1; 3; 2; 4])
-%!assert(vec ([1, 3, 2, 4]), [1; 3; 2; 4]);
-%!assert(vec ([1, 2, 3, 4], 2), [1, 2, 3, 4]);
-%!assert(vec ([1, 2; 3, 4]), vec ([1, 2; 3, 4], 1));
-%!assert(vec ([1, 2; 3, 4], 1), [1; 3; 2; 4]);
-%!assert(vec ([1, 2; 3, 4], 2), [1, 3, 2, 4]);
-%!assert(vec ([1, 3; 2, 4], 3), reshape ([1, 2, 3, 4], 1, 1, 4));
-%!assert(vec ([1, 3; 2, 4], 3), shiftdim (vec ([1, 3; 2, 4]), -2));
-
-%!error vec ();
-%!error vec (1, 2, 3);
-%!error vec ([1, 2; 3, 4], 0);
-
+%!assert (vec ([1, 2; 3, 4]), [1; 3; 2; 4])
+%!assert (vec ([1, 3, 2, 4]), [1; 3; 2; 4])
+%!assert (vec ([1, 2, 3, 4], 2), [1, 2, 3, 4])
+%!assert (vec ([1, 2; 3, 4]), vec ([1, 2; 3, 4], 1))
+%!assert (vec ([1, 2; 3, 4], 1), [1; 3; 2; 4])
+%!assert (vec ([1, 2; 3, 4], 2), [1, 3, 2, 4])
+%!assert (vec ([1, 3; 2, 4], 3), reshape ([1, 2, 3, 4], 1, 1, 4))
+%!assert (vec ([1, 3; 2, 4], 3), shiftdim (vec ([1, 3; 2, 4]), -2))
+
+%!error vec ()
+%!error vec (1, 2, 3)
+%!error vec ([1, 2; 3, 4], 0)
 */
 
 DEFUN (squeeze, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} squeeze (@var{x})\n\
 Remove singleton dimensions from @var{x} and return the result.\n\
 Note that for compatibility with @sc{matlab}, all objects have\n\
 a minimum of two dimensions and row vectors are left unchanged.\n\
@@ -5222,63 +5176,63 @@ the norms of each column and return a ro
     print_usage ();
 
   return retval;
 }
 
 /*
 %!shared x
 %! x = [1, -3, 4, 5, -7];
-%!assert(norm(x,1), 20);
-%!assert(norm(x,2), 10);
-%!assert(norm(x,3), 8.24257059961711, -4*eps);
-%!assert(norm(x,Inf), 7);
-%!assert(norm(x,-Inf), 1);
-%!assert(norm(x,"inf"), 7);
-%!assert(norm(x,"fro"), 10, -eps);
-%!assert(norm(x), 10);
-%!assert(norm([1e200, 1]), 1e200);
-%!assert(norm([3+4i, 3-4i, sqrt(31)]), 9, -4*eps);
+%!assert (norm (x,1), 20)
+%!assert (norm (x,2), 10)
+%!assert (norm (x,3), 8.24257059961711, -4*eps)
+%!assert (norm (x,Inf), 7)
+%!assert (norm (x,-Inf), 1)
+%!assert (norm (x,"inf"), 7)
+%!assert (norm (x,"fro"), 10, -eps)
+%!assert (norm (x), 10)
+%!assert (norm ([1e200, 1]), 1e200)
+%!assert (norm ([3+4i, 3-4i, sqrt(31)]), 9, -4*eps)
 %!shared m
 %! m = magic (4);
-%!assert(norm(m,1), 34);
-%!assert(norm(m,2), 34, -eps);
-%!assert(norm(m,Inf), 34);
-%!assert(norm(m,"inf"), 34);
+%!assert (norm (m,1), 34)
+%!assert (norm (m,2), 34, -eps)
+%!assert (norm (m,Inf), 34)
+%!assert (norm (m,"inf"), 34)
 %!shared m2, flo, fhi
 %! m2 = [1,2;3,4];
 %! flo = 1e-300;
 %! fhi = 1e+300;
-%!assert (norm(flo*m2,"fro"), sqrt(30)*flo, -eps)
-%!assert (norm(fhi*m2,"fro"), sqrt(30)*fhi, -eps)
+%!assert (norm (flo*m2,"fro"), sqrt (30)*flo, -eps)
+%!assert (norm (fhi*m2,"fro"), sqrt (30)*fhi, -eps)
 
 %!shared x
-%! x = single([1, -3, 4, 5, -7]);
-%!assert(norm(x,1), single(20));
-%!assert(norm(x,2), single(10));
-%!assert(norm(x,3), single(8.24257059961711), -4*eps('single'));
-%!assert(norm(x,Inf), single(7));
-%!assert(norm(x,-Inf), single(1));
-%!assert(norm(x,"inf"), single(7));
-%!assert(norm(x,"fro"), single(10), -eps('single'));
-%!assert(norm(x), single(10));
-%!assert(norm(single([1e200, 1])), single(1e200));
-%!assert(norm(single([3+4i, 3-4i, sqrt(31)])), single(9), -4*eps('single'));
+%! x = single ([1, -3, 4, 5, -7]);
+%!assert (norm (x,1), single (20))
+%!assert (norm (x,2), single (10))
+%!assert (norm (x,3), single (8.24257059961711), -4*eps ("single"))
+%!assert (norm (x,Inf), single (7))
+%!assert (norm (x,-Inf), single (1))
+%!assert (norm (x,"inf"), single (7))
+%!assert (norm (x,"fro"), single (10), -eps ("single"))
+%!assert (norm (x), single (10))
+%!assert (norm (single ([1e200, 1])), single (1e200))
+%!assert (norm (single ([3+4i, 3-4i, sqrt(31)])), single (9), -4*eps ("single"))
 %!shared m
-%! m = single(magic (4));
-%!assert(norm(m,1), single(34));
-%!assert(norm(m,2), single(34), -eps('single'));
-%!assert(norm(m,Inf), single(34));
-%!assert(norm(m,"inf"), single(34));
+%! m = single (magic (4));
+%!assert (norm (m,1), single (34))
+%!assert (norm (m,2), single (34), -eps ("single"))
+%!assert (norm (m,Inf), single (34))
+%!assert (norm (m,"inf"), single (34))
 %!shared m2, flo, fhi
-%! m2 = single([1,2;3,4]);
-%! flo = single(1e-300);
-%! fhi = single(1e+300);
-%!assert (norm(flo*m2,"fro"), single(sqrt(30)*flo), -eps('single'))
-%!assert (norm(fhi*m2,"fro"), single(sqrt(30)*fhi), -eps('single'))
+%! m2 = single ([1,2;3,4]);
+%! flo = single (1e-300);
+%! fhi = single (1e+300);
+%!assert (norm (flo*m2,"fro"), single (sqrt (30)*flo), -eps ("single"))
+%!assert (norm (fhi*m2,"fro"), single (sqrt (30)*fhi), -eps ("single"))
 */
 
 static octave_value
 unary_op_defun_body (octave_value::unary_op op,
                      const octave_value_list& args)
 {
   octave_value retval;
   if (args.length () == 1)
@@ -5325,68 +5279,64 @@ Return the transpose of @var{x}.\n\
 This function and @xcode{x.'} are equivalent.\n\
 @seealso{ctranspose}\n\
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_transpose, args);
 }
 
 /*
-
-%!assert (2.', 2);
-%!assert (2i.',2i);
-%!assert ([1:4].',[1;2;3;4]);
-%!assert ([1;2;3;4].',[1:4]);
-%!assert ([1,2;3,4].',[1,3;2,4]);
-%!assert ([1,2i;3,4].',[1,3;2i,4]);
-
-%!assert (transpose ([1,2;3,4]),[1,3;2,4]);
-
-%!assert (single(2).', single(2));
-%!assert (single(2i).',single(2i));
-%!assert (single([1:4]).',single([1;2;3;4]));
-%!assert (single([1;2;3;4]).',single([1:4]));
-%!assert (single([1,2;3,4]).',single([1,3;2,4]));
-%!assert (single([1,2i;3,4]).',single([1,3;2i,4]));
-
-%!assert (transpose (single([1,2;3,4])),single([1,3;2,4]));
-
+%!assert (2.', 2)
+%!assert (2i.', 2i)
+%!assert ([1:4].', [1;2;3;4])
+%!assert ([1;2;3;4].', [1:4])
+%!assert ([1,2;3,4].', [1,3;2,4])
+%!assert ([1,2i;3,4].', [1,3;2i,4])
+
+%!assert (transpose ([1,2;3,4]), [1,3;2,4])
+
+%!assert (single (2).', single (2))
+%!assert (single (2i).', single (2i))
+%!assert (single ([1:4]).', single ([1;2;3;4]))
+%!assert (single ([1;2;3;4]).', single ([1:4]))
+%!assert (single ([1,2;3,4]).', single ([1,3;2,4]))
+%!assert (single ([1,2i;3,4]).', single ([1,3;2i,4]))
+
+%!assert (transpose (single ([1,2;3,4])), single ([1,3;2,4]))
 */
 
 DEFUN (ctranspose, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ctranspose (@var{x})\n\
 Return the complex conjugate transpose of @var{x}.\n\
 This function and @xcode{x'} are equivalent.\n\
 @seealso{transpose}\n\
 @end deftypefn")
 {
   return unary_op_defun_body (octave_value::op_hermitian, args);
 }
 
 /*
-
-%!assert (2', 2);
-%!assert (2i',-2i);
-%!assert ([1:4]',[1;2;3;4]);
-%!assert ([1;2;3;4]',[1:4]);
-%!assert ([1,2;3,4]',[1,3;2,4]);
-%!assert ([1,2i;3,4]',[1,3;-2i,4]);
-
-%!assert (ctranspose ([1,2i;3,4]),[1,3;-2i,4]);
-
-%!assert (single(2)', single(2));
-%!assert (single(2i)',single(-2i));
-%!assert (single([1:4])',single([1;2;3;4]));
-%!assert (single([1;2;3;4])',single([1:4]));
-%!assert (single([1,2;3,4])',single([1,3;2,4]));
-%!assert (single([1,2i;3,4])',single([1,3;-2i,4]));
-
-%!assert (ctranspose (single([1,2i;3,4])),single([1,3;-2i,4]));
-
+%!assert (2', 2)
+%!assert (2i', -2i)
+%!assert ([1:4]', [1;2;3;4])
+%!assert ([1;2;3;4]', [1:4])
+%!assert ([1,2;3,4]', [1,3;2,4])
+%!assert ([1,2i;3,4]', [1,3;-2i,4])
+
+%!assert (ctranspose ([1,2i;3,4]), [1,3;-2i,4])
+
+%!assert (single (2)', single (2))
+%!assert (single (2i)', single (-2i))
+%!assert (single ([1:4])', single ([1;2;3;4]))
+%!assert (single ([1;2;3;4])', single ([1:4]))
+%!assert (single ([1,2;3,4])', single ([1,3;2,4]))
+%!assert (single ([1,2i;3,4])', single ([1,3;-2i,4]))
+
+%!assert (ctranspose (single ([1,2i;3,4])), single ([1,3;-2i,4]))
 */
 
 static octave_value
 binary_op_defun_body (octave_value::binary_op op,
                       const octave_value_list& args)
 {
   octave_value retval;
 
@@ -5999,190 +5949,188 @@ ordered lists.\n\
     }
   else
     retval(0) = arg.sort (dim, smode);
 
   return retval;
 }
 
 /*
-
-%% Double
+## Double
 %!assert (sort ([NaN, 1, -1, 2, Inf]), [-1, 1, 2, Inf, NaN])
 %!assert (sort ([NaN, 1, -1, 2, Inf], 1), [NaN, 1, -1, 2, Inf])
 %!assert (sort ([NaN, 1, -1, 2, Inf], 2), [-1, 1, 2, Inf, NaN])
 %!assert (sort ([NaN, 1, -1, 2, Inf], 3), [NaN, 1, -1, 2, Inf])
 %!assert (sort ([NaN, 1, -1, 2, Inf], "ascend"), [-1, 1, 2, Inf, NaN])
 %!assert (sort ([NaN, 1, -1, 2, Inf], 2, "ascend"), [-1, 1, 2, Inf, NaN])
 %!assert (sort ([NaN, 1, -1, 2, Inf], "descend"), [NaN, Inf, 2, 1, -1])
 %!assert (sort ([NaN, 1, -1, 2, Inf], 2, "descend"), [NaN, Inf, 2, 1, -1])
 %!assert (sort ([3, 1, 7, 5; 8, 2, 6, 4]), [3, 1, 6, 4; 8, 2, 7, 5])
 %!assert (sort ([3, 1, 7, 5; 8, 2, 6, 4], 1), [3, 1, 6, 4; 8, 2, 7, 5])
 %!assert (sort ([3, 1, 7, 5; 8, 2, 6, 4], 2), [1, 3, 5, 7; 2, 4, 6, 8])
 %!assert (sort (1), 1)
 
 %!test
 %! [v, i] = sort ([NaN, 1, -1, Inf, 1]);
-%! assert (v, [-1, 1, 1, Inf, NaN])
-%! assert (i, [3, 2, 5, 4, 1])
-
-%% Complex
+%! assert (v, [-1, 1, 1, Inf, NaN]);
+%! assert (i, [3, 2, 5, 4, 1]);
+
+## Complex
 %!assert (sort ([NaN, 1i, -1, 2, Inf]), [1i, -1, 2, Inf, NaN])
 %!assert (sort ([NaN, 1i, -1, 2, Inf], 1), [NaN, 1i, -1, 2, Inf])
 %!assert (sort ([NaN, 1i, -1, 2, Inf], 2), [1i, -1, 2, Inf, NaN])
 %!assert (sort ([NaN, 1i, -1, 2, Inf], 3), [NaN, 1i, -1, 2, Inf])
 %!assert (sort ([NaN, 1i, -1, 2, Inf], "ascend"), [1i, -1, 2, Inf, NaN])
 %!assert (sort ([NaN, 1i, -1, 2, Inf], 2, "ascend"), [1i, -1, 2, Inf, NaN])
 %!assert (sort ([NaN, 1i, -1, 2, Inf], "descend"), [NaN, Inf, 2, -1, 1i])
 %!assert (sort ([NaN, 1i, -1, 2, Inf], 2, "descend"), [NaN, Inf, 2, -1, 1i])
 %!assert (sort ([3, 1i, 7, 5; 8, 2, 6, 4]), [3, 1i, 6, 4; 8, 2, 7, 5])
 %!assert (sort ([3, 1i, 7, 5; 8, 2, 6, 4], 1), [3, 1i, 6, 4; 8, 2, 7, 5])
 %!assert (sort ([3, 1i, 7, 5; 8, 2, 6, 4], 2), [1i, 3, 5, 7; 2, 4, 6, 8])
 %!assert (sort (1i), 1i)
 
 %!test
 %! [v, i] = sort ([NaN, 1i, -1, Inf, 1, 1i]);
-%! assert (v, [1, 1i, 1i, -1, Inf, NaN])
-%! assert (i, [5, 2, 6, 3, 4, 1])
-
-%% Single
-%!assert (sort (single([NaN, 1, -1, 2, Inf])), single([-1, 1, 2, Inf, NaN]))
-%!assert (sort (single([NaN, 1, -1, 2, Inf]), 1), single([NaN, 1, -1, 2, Inf]))
-%!assert (sort (single([NaN, 1, -1, 2, Inf]), 2), single([-1, 1, 2, Inf, NaN]))
-%!assert (sort (single([NaN, 1, -1, 2, Inf]), 3), single([NaN, 1, -1, 2, Inf]))
-%!assert (sort (single([NaN, 1, -1, 2, Inf]), "ascend"), single([-1, 1, 2, Inf, NaN]))
-%!assert (sort (single([NaN, 1, -1, 2, Inf]), 2, "ascend"), single([-1, 1, 2, Inf, NaN]))
-%!assert (sort (single([NaN, 1, -1, 2, Inf]), "descend"), single([NaN, Inf, 2, 1, -1]))
-%!assert (sort (single([NaN, 1, -1, 2, Inf]), 2, "descend"), single([NaN, Inf, 2, 1, -1]))
-%!assert (sort (single([3, 1, 7, 5; 8, 2, 6, 4])), single([3, 1, 6, 4; 8, 2, 7, 5]))
-%!assert (sort (single([3, 1, 7, 5; 8, 2, 6, 4]), 1), single([3, 1, 6, 4; 8, 2, 7, 5]))
-%!assert (sort (single([3, 1, 7, 5; 8, 2, 6, 4]), 2), single([1, 3, 5, 7; 2, 4, 6, 8]))
-%!assert (sort (single(1)), single(1))
+%! assert (v, [1, 1i, 1i, -1, Inf, NaN]);
+%! assert (i, [5, 2, 6, 3, 4, 1]);
+
+## Single
+%!assert (sort (single ([NaN, 1, -1, 2, Inf])), single ([-1, 1, 2, Inf, NaN]))
+%!assert (sort (single ([NaN, 1, -1, 2, Inf]), 1), single ([NaN, 1, -1, 2, Inf]))
+%!assert (sort (single ([NaN, 1, -1, 2, Inf]), 2), single ([-1, 1, 2, Inf, NaN]))
+%!assert (sort (single ([NaN, 1, -1, 2, Inf]), 3), single ([NaN, 1, -1, 2, Inf]))
+%!assert (sort (single ([NaN, 1, -1, 2, Inf]), "ascend"), single ([-1, 1, 2, Inf, NaN]))
+%!assert (sort (single ([NaN, 1, -1, 2, Inf]), 2, "ascend"), single ([-1, 1, 2, Inf, NaN]))
+%!assert (sort (single ([NaN, 1, -1, 2, Inf]), "descend"), single ([NaN, Inf, 2, 1, -1]))
+%!assert (sort (single ([NaN, 1, -1, 2, Inf]), 2, "descend"), single ([NaN, Inf, 2, 1, -1]))
+%!assert (sort (single ([3, 1, 7, 5; 8, 2, 6, 4])), single ([3, 1, 6, 4; 8, 2, 7, 5]))
+%!assert (sort (single ([3, 1, 7, 5; 8, 2, 6, 4]), 1), single ([3, 1, 6, 4; 8, 2, 7, 5]))
+%!assert (sort (single ([3, 1, 7, 5; 8, 2, 6, 4]), 2), single ([1, 3, 5, 7; 2, 4, 6, 8]))
+%!assert (sort (single (1)), single (1))
 
 %!test
-%! [v, i] = sort (single([NaN, 1, -1, Inf, 1]));
-%! assert (v, single([-1, 1, 1, Inf, NaN]))
-%! assert (i, [3, 2, 5, 4, 1])
-
-%% Single Complex
-%!assert (sort (single([NaN, 1i, -1, 2, Inf])), single([1i, -1, 2, Inf, NaN]))
-%!assert (sort (single([NaN, 1i, -1, 2, Inf]), 1), single([NaN, 1i, -1, 2, Inf]))
-%!assert (sort (single([NaN, 1i, -1, 2, Inf]), 2), single([1i, -1, 2, Inf, NaN]))
-%!assert (sort (single([NaN, 1i, -1, 2, Inf]), 3), single([NaN, 1i, -1, 2, Inf]))
-%!assert (sort (single([NaN, 1i, -1, 2, Inf]), "ascend"), single([1i, -1, 2, Inf, NaN]))
-%!assert (sort (single([NaN, 1i, -1, 2, Inf]), 2, "ascend"), single([1i, -1, 2, Inf, NaN]))
-%!assert (sort (single([NaN, 1i, -1, 2, Inf]), "descend"), single([NaN, Inf, 2, -1, 1i]))
-%!assert (sort (single([NaN, 1i, -1, 2, Inf]), 2, "descend"), single([NaN, Inf, 2, -1, 1i]))
-%!assert (sort (single([3, 1i, 7, 5; 8, 2, 6, 4])), single([3, 1i, 6, 4; 8, 2, 7, 5]))
-%!assert (sort (single([3, 1i, 7, 5; 8, 2, 6, 4]), 1), single([3, 1i, 6, 4; 8, 2, 7, 5]))
-%!assert (sort (single([3, 1i, 7, 5; 8, 2, 6, 4]), 2), single([1i, 3, 5, 7; 2, 4, 6, 8]))
-%!assert (sort (single(1i)),single( 1i))
+%! [v, i] = sort (single ([NaN, 1, -1, Inf, 1]));
+%! assert (v, single ([-1, 1, 1, Inf, NaN]));
+%! assert (i, [3, 2, 5, 4, 1]);
+
+## Single Complex
+%!assert (sort (single ([NaN, 1i, -1, 2, Inf])), single ([1i, -1, 2, Inf, NaN]))
+%!assert (sort (single ([NaN, 1i, -1, 2, Inf]), 1), single ([NaN, 1i, -1, 2, Inf]))
+%!assert (sort (single ([NaN, 1i, -1, 2, Inf]), 2), single ([1i, -1, 2, Inf, NaN]))
+%!assert (sort (single ([NaN, 1i, -1, 2, Inf]), 3), single ([NaN, 1i, -1, 2, Inf]))
+%!assert (sort (single ([NaN, 1i, -1, 2, Inf]), "ascend"), single ([1i, -1, 2, Inf, NaN]))
+%!assert (sort (single ([NaN, 1i, -1, 2, Inf]), 2, "ascend"), single ([1i, -1, 2, Inf, NaN]))
+%!assert (sort (single ([NaN, 1i, -1, 2, Inf]), "descend"), single ([NaN, Inf, 2, -1, 1i]))
+%!assert (sort (single ([NaN, 1i, -1, 2, Inf]), 2, "descend"), single ([NaN, Inf, 2, -1, 1i]))
+%!assert (sort (single ([3, 1i, 7, 5; 8, 2, 6, 4])), single ([3, 1i, 6, 4; 8, 2, 7, 5]))
+%!assert (sort (single ([3, 1i, 7, 5; 8, 2, 6, 4]), 1), single ([3, 1i, 6, 4; 8, 2, 7, 5]))
+%!assert (sort (single ([3, 1i, 7, 5; 8, 2, 6, 4]), 2), single ([1i, 3, 5, 7; 2, 4, 6, 8]))
+%!assert (sort (single (1i)), single (1i))
 
 %!test
-%! [v, i] = sort (single([NaN, 1i, -1, Inf, 1, 1i]));
-%! assert (v, single([1, 1i, 1i, -1, Inf, NaN]))
-%! assert (i, [5, 2, 6, 3, 4, 1])
-
-%% Bool
+%! [v, i] = sort (single ([NaN, 1i, -1, Inf, 1, 1i]));
+%! assert (v, single ([1, 1i, 1i, -1, Inf, NaN]));
+%! assert (i, [5, 2, 6, 3, 4, 1]);
+
+## Bool
 %!assert (sort ([true, false, true, false]), [false, false, true, true])
 %!assert (sort ([true, false, true, false], 1), [true, false, true, false])
 %!assert (sort ([true, false, true, false], 2), [false, false, true, true])
 %!assert (sort ([true, false, true, false], 3), [true, false, true, false])
 %!assert (sort ([true, false, true, false], "ascend"), [false, false, true, true])
 %!assert (sort ([true, false, true, false], 2, "ascend"), [false, false, true, true])
 %!assert (sort ([true, false, true, false], "descend"), [true, true, false, false])
 %!assert (sort ([true, false, true, false], 2, "descend"), [true, true, false, false])
 %!assert (sort (true), true)
 
 %!test
 %! [v, i] = sort ([true, false, true, false]);
-%! assert (v, [false, false, true, true])
-%! assert (i, [2, 4, 1, 3])
-
-%% Sparse Double
+%! assert (v, [false, false, true, true]);
+%! assert (i, [2, 4, 1, 3]);
+
+## Sparse Double
 %!assert (sort (sparse ([0, NaN, 1, 0, -1, 2, Inf])), sparse ([-1, 0, 0, 1, 2, Inf, NaN]))
 %!assert (sort (sparse ([0, NaN, 1, 0, -1, 2, Inf]), 1), sparse ([0, NaN, 1, 0, -1, 2, Inf]))
 %!assert (sort (sparse ([0, NaN, 1, 0, -1, 2, Inf]), 2), sparse ([-1, 0, 0, 1, 2, Inf, NaN]))
 %!assert (sort (sparse ([0, NaN, 1, 0, -1, 2, Inf]), 3), sparse ([0, NaN, 1, 0, -1, 2, Inf]))
 %!assert (sort (sparse ([0, NaN, 1, 0, -1, 2, Inf]), "ascend"), sparse ([-1, 0, 0, 1, 2, Inf, NaN]))
 %!assert (sort (sparse ([0, NaN, 1, 0, -1, 2, Inf]), 2, "ascend"), sparse ([-1, 0, 0, 1, 2, Inf, NaN]))
 %!assert (sort (sparse ([0, NaN, 1, 0, -1, 2, Inf]), "descend"), sparse ([NaN, Inf, 2, 1, 0, 0, -1]))
 %!assert (sort (sparse ([0, NaN, 1, 0, -1, 2, Inf]), 2, "descend"), sparse ([NaN, Inf, 2, 1, 0, 0, -1]))
 
 %!shared a
 %! a = randn (10, 10);
-%! a (a < 0) = 0;
+%! a(a < 0) = 0;
 %!assert (sort (sparse (a)), sparse (sort (a)))
 %!assert (sort (sparse (a), 1), sparse (sort (a, 1)))
 %!assert (sort (sparse (a), 2), sparse (sort (a, 2)))
 %!test
 %! [v, i] = sort (a);
 %! [vs, is] = sort (sparse (a));
-%! assert (vs, sparse (v))
-%! assert (is, i)
-
-%% Sparse Complex
+%! assert (vs, sparse (v));
+%! assert (is, i);
+
+## Sparse Complex
 %!assert (sort (sparse ([0, NaN, 1i, 0, -1, 2, Inf])), sparse ([0, 0, 1i, -1, 2, Inf, NaN]))
 %!assert (sort (sparse ([0, NaN, 1i, 0, -1, 2, Inf]), 1), sparse ([0, NaN, 1i, 0, -1, 2, Inf]))
 %!assert (sort (sparse ([0, NaN, 1i, 0, -1, 2, Inf]), 2), sparse ([0, 0, 1i, -1, 2, Inf, NaN]))
 %!assert (sort (sparse ([0, NaN, 1i, 0, -1, 2, Inf]), 3), sparse ([0, NaN, 1i, 0, -1, 2, Inf]))
 %!assert (sort (sparse ([0, NaN, 1i, 0, -1, 2, Inf]), "ascend"), sparse ([0, 0, 1i, -1, 2, Inf, NaN]))
 %!assert (sort (sparse ([0, NaN, 1i, 0, -1, 2, Inf]), 2, "ascend"), sparse ([0, 0, 1i, -1, 2, Inf, NaN]))
 %!assert (sort (sparse ([0, NaN, 1i, 0, -1, 2, Inf]), "descend"), sparse ([NaN, Inf, 2, -1, 1i, 0, 0]))
 %!assert (sort (sparse ([0, NaN, 1i, 0, -1, 2, Inf]), 2, "descend"), sparse ([NaN, Inf, 2, -1, 1i, 0, 0]))
 
 %!shared a
 %! a = randn (10, 10);
-%! a (a < 0) = 0;
+%! a(a < 0) = 0;
 %! a = 1i * a;
 %!assert (sort (sparse (a)), sparse (sort (a)))
 %!assert (sort (sparse (a), 1), sparse (sort (a, 1)))
 %!assert (sort (sparse (a), 2), sparse (sort (a, 2)))
 %!test
 %! [v, i] = sort (a);
 %! [vs, is] = sort (sparse (a));
-%! assert (vs, sparse (v))
-%! assert (is, i)
-
-%% Sparse Bool
+%! assert (vs, sparse (v));
+%! assert (is, i);
+
+## Sparse Bool
 %!assert (sort (sparse ([true, false, true, false])), sparse ([false, false, true, true]))
-%!assert (sort (sparse([true, false, true, false]), 1), sparse ([true, false, true, false]))
+%!assert (sort (sparse ([true, false, true, false]), 1), sparse ([true, false, true, false]))
 %!assert (sort (sparse ([true, false, true, false]), 2), sparse ([false, false, true, true]))
 %!assert (sort (sparse ([true, false, true, false]), 3), sparse ([true, false, true, false]))
-%!assert (sort (sparse ([true, false, true, false]), "ascend"), sparse([false, false, true, true]))
-%!assert (sort (sparse ([true, false, true, false]), 2, "ascend"), sparse([false, false, true, true]))
+%!assert (sort (sparse ([true, false, true, false]), "ascend"), sparse ([false, false, true, true]))
+%!assert (sort (sparse ([true, false, true, false]), 2, "ascend"), sparse ([false, false, true, true]))
 %!assert (sort (sparse ([true, false, true, false]), "descend"), sparse ([true, true, false, false]))
-%!assert (sort (sparse ([true, false, true, false]), 2, "descend"), sparse([true, true, false, false]))
+%!assert (sort (sparse ([true, false, true, false]), 2, "descend"), sparse ([true, true, false, false]))
 
 %!test
-%! [v, i] = sort (sparse([true, false, true, false]));
-%! assert (v, sparse([false, false, true, true]))
-%! assert (i, [2, 4, 1, 3])
-
-%% Cell string array
+%! [v, i] = sort (sparse ([true, false, true, false]));
+%! assert (v, sparse ([false, false, true, true]));
+%! assert (i, [2, 4, 1, 3]);
+
+## Cell string array
 %!shared a, b, c
 %! a = {"Alice", "Cecile", "Eric", "Barry", "David"};
 %! b = {"Alice", "Barry", "Cecile", "David", "Eric"};
 %! c = {"Eric", "David", "Cecile", "Barry", "Alice"};
-%!assert (sort (a), b);
+%!assert (sort (a), b)
 %!assert (sort (a, 1), a)
 %!assert (sort (a, 2), b)
 %!assert (sort (a, 3), a)
 %!assert (sort (a, "ascend"), b)
 %!assert (sort (a, 2, "ascend"), b)
 %!assert (sort (a, "descend"), c)
 %!assert (sort (a, 2, "descend"), c)
 
 %!test
 %! [v, i] = sort (a);
-%! assert (i, [1, 4, 2, 5, 3])
-
-%!error <Invalid call to sort> sort ();
-%!error <Invalid call to sort> sort (1, 2, 3, 4);
-
+%! assert (i, [1, 4, 2, 5, 3]);
+
+%!error sort ()
+%!error sort (1, 2, 3, 4)
 */
 
 // Sort the rows of the matrix @var{a} according to the order
 // specified by @var{mode}, which can either be `ascend' or `descend'
 // and return the index vector corresponding to the sort order.
 //
 // This function does not yet support sparse matrices.
 
@@ -6335,42 +6283,42 @@ This function does not support sparse ma
 }
 
 /*
 %!shared sm, um, sv, uv
 %! sm = [1, 2; 3, 4];
 %! um = [3, 1; 2, 4];
 %! sv = [1, 2, 3, 4];
 %! uv = [2, 1, 4, 3];
-%!assert(issorted (sm, "rows"));
-%!assert(!issorted (um, "rows"));
-%!assert(issorted (sv));
-%!assert(!issorted (uv));
-%!assert(issorted (sv'));
-%!assert(!issorted (uv'));
-%!assert(issorted (sm, "rows", "ascending"));
-%!assert(!issorted (um, "rows", "ascending"));
-%!assert(issorted (sv, "ascending"));
-%!assert(!issorted (uv, "ascending"));
-%!assert(issorted (sv', "ascending"));
-%!assert(!issorted (uv', "ascending"));
-%!assert(!issorted (sm, "rows", "descending"));
-%!assert(issorted (flipud (sm), "rows", "descending"));
-%!assert(!issorted (sv, "descending"));
-%!assert(issorted (fliplr (sv), "descending"));
-%!assert(!issorted (sv', "descending"));
-%!assert(issorted (fliplr (sv)', "descending"));
-%!assert(!issorted (um, "rows", "either"));
-%!assert(!issorted (uv, "either"));
-%!assert(issorted (sm, "rows", "either"));
-%!assert(issorted (flipud (sm), "rows", "either"));
-%!assert(issorted (sv, "either"));
-%!assert(issorted (fliplr (sv), "either"));
-%!assert(issorted (sv', "either"));
-%!assert(issorted (fliplr (sv)', "either"));
+%!assert (issorted (sm, "rows"))
+%!assert (!issorted (um, "rows"))
+%!assert (issorted (sv))
+%!assert (!issorted (uv))
+%!assert (issorted (sv'))
+%!assert (!issorted (uv'))
+%!assert (issorted (sm, "rows", "ascending"))
+%!assert (!issorted (um, "rows", "ascending"))
+%!assert (issorted (sv, "ascending"))
+%!assert (!issorted (uv, "ascending"))
+%!assert (issorted (sv', "ascending"))
+%!assert (!issorted (uv', "ascending"))
+%!assert (!issorted (sm, "rows", "descending"))
+%!assert (issorted (flipud (sm), "rows", "descending"))
+%!assert (!issorted (sv, "descending"))
+%!assert (issorted (fliplr (sv), "descending"))
+%!assert (!issorted (sv', "descending"))
+%!assert (issorted (fliplr (sv)', "descending"))
+%!assert (!issorted (um, "rows", "either"))
+%!assert (!issorted (uv, "either"))
+%!assert (issorted (sm, "rows", "either"))
+%!assert (issorted (flipud (sm), "rows", "either"))
+%!assert (issorted (sv, "either"))
+%!assert (issorted (fliplr (sv), "either"))
+%!assert (issorted (sv', "either"))
+%!assert (issorted (fliplr (sv)', "either"))
 */
 
 DEFUN (nth_element, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} nth_element (@var{x}, @var{n})\n\
 @deftypefnx {Built-in Function} {} nth_element (@var{x}, @var{n}, @var{dim})\n\
 Select the n-th smallest element of a vector, using the ordering defined by\n\
 @code{sort}.  In other words, the result is equivalent to\n\
@@ -7066,31 +7014,26 @@ an empty matrix is returned.\n\
       if (! error_state)
         retval = do_diff (args(0), order, dim);
     }
 
   return retval;
 }
 
 /*
-
 %!assert (diff ([1, 2, 3, 4]), [1, 1, 1])
 %!assert (diff ([1, 3, 7, 19], 2), [2, 8])
 %!assert (diff ([1, 2; 5, 4; 8, 7; 9, 6; 3, 1]), [4, 2; 3, 3; 1, -1; -6, -5])
 %!assert (diff ([1, 2; 5, 4; 8, 7; 9, 6; 3, 1], 3), [-1, -5; -5, 0])
-%!assert (isempty (diff (1)));
-
-%!error diff ([1, 2; 3, 4], -1);
-
-%!error diff ("foo");
-
-%!error diff ();
-
-%!error diff (1, 2, 3, 4);
-
+%!assert (isempty (diff (1)))
+
+%!error diff ()
+%!error diff (1, 2, 3, 4)
+%!error diff ("foo")
+%!error diff ([1, 2; 3, 4], -1)
 */
 
 template <class T>
 static Array<T>
 do_repelems (const Array<T>& src, const Array<octave_idx_type>& rep)
 {
   Array<T> retval;
 
diff --git a/src/defaults.cc b/src/defaults.cc
--- a/src/defaults.cc
+++ b/src/defaults.cc
@@ -420,24 +420,25 @@ changed locally for the function and any
 variable value is restored when exiting the function.\n\
 @seealso{edit_history}\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (EDITOR);
 }
 
 /*
-%!error (EDITOR (1, 2));
 %!test
 %! orig_val = EDITOR ();
 %! old_val = EDITOR ("X");
 %! assert (orig_val, old_val);
 %! assert (EDITOR (), "X");
 %! EDITOR (orig_val);
 %! assert (EDITOR (), orig_val);
+
+%!error (EDITOR (1, 2))
 */
 
 DEFUN (EXEC_PATH, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} EXEC_PATH ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} EXEC_PATH (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} EXEC_PATH (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies a colon separated\n\
@@ -455,24 +456,25 @@ variable value is restored when exiting 
 
   if (args.length () > 0)
     set_exec_path (VEXEC_PATH);
 
   return retval;
 }
 
 /*
-%!error (EXEC_PATH (1, 2));
 %!test
 %! orig_val = EXEC_PATH ();
 %! old_val = EXEC_PATH ("X");
 %! assert (orig_val, old_val);
 %! assert (EXEC_PATH (), "X");
 %! EXEC_PATH (orig_val);
 %! assert (EXEC_PATH (), orig_val);
+
+%!error (EXEC_PATH (1, 2))
 */
 
 DEFUN (IMAGE_PATH, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} IMAGE_PATH ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} IMAGE_PATH (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} IMAGE_PATH (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies a colon separated\n\
@@ -482,24 +484,25 @@ When called from inside a function with 
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (IMAGE_PATH);
 }
 
 /*
-%!error (IMAGE_PATH (1, 2));
 %!test
 %! orig_val = IMAGE_PATH ();
 %! old_val = IMAGE_PATH ("X");
 %! assert (orig_val, old_val);
 %! assert (IMAGE_PATH (), "X");
 %! IMAGE_PATH (orig_val);
 %! assert (IMAGE_PATH (), orig_val);
+
+%!error (IMAGE_PATH (1, 2))
 */
 
 DEFUN (OCTAVE_HOME, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} OCTAVE_HOME ()\n\
 Return the name of the top-level Octave installation directory.\n\
 @end deftypefn")
 {
@@ -509,18 +512,18 @@ Return the name of the top-level Octave 
     retval = Voctave_home;
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error OCTAVE_HOME (1);
-%!assert (ischar (OCTAVE_HOME ()));
+%!assert (ischar (OCTAVE_HOME ()))
+%!error OCTAVE_HOME (1)
 */
 
 DEFUNX ("OCTAVE_VERSION", FOCTAVE_VERSION, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} OCTAVE_VERSION ()\n\
 Return the version number of Octave, as a string.\n\
 @end deftypefn")
 {
@@ -532,11 +535,11 @@ Return the version number of Octave, as 
     retval = OCTAVE_VERSION;
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error OCTAVE_VERSION (1);
-%!assert (ischar (OCTAVE_VERSION ()));
+%!assert (ischar (OCTAVE_VERSION ()))
+%!error OCTAVE_VERSION (1)
 */
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -612,45 +612,44 @@ glob (\"file[12]\")\n\
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%!  tmpdir = tmpnam;
-%!  filename = {"file1", "file2", "file3", "myfile1", "myfile1b"};
-%!  if (mkdir (tmpdir))
-%!    cwd = pwd;
-%!    cd (tmpdir);
-%!    if strcmp (canonicalize_file_name (pwd), ...
-%!               canonicalize_file_name (tmpdir))
-%!      a = 0;
-%!      for n = 1:5
-%!        save (filename{n}, "a");
-%!      endfor
-%!    else
-%!      rmdir (tmpdir);
-%!      error ("Couldn't change to temporary dir");
-%!    endif
-%!  else
-%!    error ("Couldn't create temporary directory");
-%!  endif
-%!  result1 = glob ("*file1");
-%!  result2 = glob ("myfile?");
-%!  result3 = glob ("file[12]");
-%!  for n = 1:5
-%!    delete (filename{n});
-%!  endfor
-%!  cd (cwd);
-%!  rmdir (tmpdir);
-%!  assert (result1, {"file1"; "myfile1"});
-%!  assert (result2, {"myfile1"});
-%!  assert (result3, {"file1"; "file2"});
+%! tmpdir = tmpnam;
+%! filename = {"file1", "file2", "file3", "myfile1", "myfile1b"};
+%! if (mkdir (tmpdir))
+%!   cwd = pwd;
+%!   cd (tmpdir);
+%!   if strcmp (canonicalize_file_name (pwd), canonicalize_file_name (tmpdir))
+%!     a = 0;
+%!     for n = 1:5
+%!       save (filename{n}, "a");
+%!     endfor
+%!   else
+%!     rmdir (tmpdir);
+%!     error ("Couldn't change to temporary dir");
+%!   endif
+%! else
+%!   error ("Couldn't create temporary directory");
+%! endif
+%! result1 = glob ("*file1");
+%! result2 = glob ("myfile?");
+%! result3 = glob ("file[12]");
+%! for n = 1:5
+%!   delete (filename{n});
+%! endfor
+%! cd (cwd);
+%! rmdir (tmpdir);
+%! assert (result1, {"file1"; "myfile1"});
+%! assert (result2, {"myfile1"});
+%! assert (result3, {"file1"; "file2"});
 */
 
 DEFUNX ("fnmatch", Ffnmatch, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} fnmatch (@var{pattern}, @var{string})\n\
 Return 1 or zero for each element of @var{string} that matches any of\n\
 the elements of the string array @var{pattern}, using the rules of\n\
 filename pattern matching.  For example:\n\
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -1139,17 +1139,17 @@ complete description of the syntax of th
             {
               std::locale oldloc;
               try
                 {
                   // Use args(2) val as the new locale setting. Keep
                   // old val for restoring afterwards.
                   oldloc = 
                     os.imbue (std::locale (args(2).string_value ().c_str ()));
-                  
+
                 }
               catch (std::runtime_error)
                 {
                   // Display a warning if the specified locale is unknown
                   warning ("fscanf: invalid locale. Try `locale -a' for a list of supported values.");
                   oldloc = std::locale::classic ();
                 }
               retval = os.oscanf (args(1), who);
@@ -1327,18 +1327,18 @@ is returned in @var{pos}.\n\
         print_usage ();
     }
 
   return retval;
 }
 
 /*
 %!test
-%! assert(sscanf('1,2', '%f', 'C'), 1)
-%! assert(sscanf('1,2', '%f', 'fr_FR'), 1.2)
+%! assert (sscanf ("1,2", "%f", "C"), 1)
+%! assert (sscanf ("1,2", "%f", "fr_FR"), 1.2)
 */
 
 DEFUN (scanf, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{val}, @var{count}, @var{errmsg}] =} scanf (@var{template}, @var{size})\n\
 @deftypefnx {Built-in Function} {[@var{v1}, @var{v2}, @dots{}, @var{count}] =} scanf (@var{template}, @var{locale})\n\
 This is equivalent to calling @code{fscanf} with @var{fid} = @code{stdin}.\n\
 \n\
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -1962,23 +1962,23 @@ graphics_object::set (const octave_value
             error ("set: expecting argument %d to be a property name", i);
         }
     }
   else
     error ("set: invalid number of arguments");
 }
 
 /*
-%!# test set with name, value pairs
+## test set with name, value pairs
 %!test
-%!  set(gcf, "visible", "off");
-%!  h = plot (1:10, 10:-1:1);
-%!  set (h, "linewidth", 10, "marker", "x");
-%!  assert (get (h, "linewidth"), 10);
-%!  assert (get (h, "marker"), "x");
+%! set (gcf, "visible", "off");
+%! h = plot (1:10, 10:-1:1);
+%! set (h, "linewidth", 10, "marker", "x");
+%! assert (get (h, "linewidth"), 10);
+%! assert (get (h, "marker"), "x");
 */
 
 // Set properties given in two cell arrays containing names and values.
 void
 graphics_object::set (const Array<std::string>& names,
                       const Cell& values, octave_idx_type row)
 {
   if (names.numel () != values.columns ())
@@ -1997,44 +1997,44 @@ graphics_object::set (const Array<std::s
       set_value_or_default (name, val);
 
       if (error_state)
         break;
     }
 }
 
 /*
-%!# test set with cell array arguments
+## test set with cell array arguments
 %!test
-%!  set (gcf, "visible", "off");
-%!  h = plot (1:10, 10:-1:1);
-%!  set (h, {"linewidth", "marker"}, {10, "x"});
-%!  assert (get(h, "linewidth"), 10);
-%!  assert (get(h, "marker"), "x");
-
-%!# test set with multiple handles and cell array arguments
+%! set (gcf, "visible", "off");
+%! h = plot (1:10, 10:-1:1);
+%! set (h, {"linewidth", "marker"}, {10, "x"});
+%! assert (get (h, "linewidth"), 10);
+%! assert (get (h, "marker"), "x");
+
+## test set with multiple handles and cell array arguments
 %!test
-%!  set (gcf, "visible", "off");
-%!  h = plot (1:10, 10:-1:1, 1:10, 1:10);
-%!  set (h, {"linewidth", "marker"}, {10, "x"; 5, "o"});
-%!  assert (get (h, "linewidth"), {10; 5});
-%!  assert (get (h, "marker"), {"x"; "o"});
-%!  set (h, {"linewidth", "marker"}, {10, "x"});
-%!  assert (get (h, "linewidth"), {10; 10});
-%!  assert (get (h, "marker"), {"x"; "x"});
+%! set (gcf, "visible", "off");
+%! h = plot (1:10, 10:-1:1, 1:10, 1:10);
+%! set (h, {"linewidth", "marker"}, {10, "x"; 5, "o"});
+%! assert (get (h, "linewidth"), {10; 5});
+%! assert (get (h, "marker"), {"x"; "o"});
+%! set (h, {"linewidth", "marker"}, {10, "x"});
+%! assert (get (h, "linewidth"), {10; 10});
+%! assert (get (h, "marker"), {"x"; "x"});
 
 %!error <set: number of graphics handles must match number of value rows>
-%!  set (gcf, "visible", "off");
-%!  h = plot (1:10, 10:-1:1, 1:10, 1:10);
-%!  set (h, {"linewidth", "marker"}, {10, "x"; 5, "o"; 7, "."});
+%! set (gcf, "visible", "off");
+%! h = plot (1:10, 10:-1:1, 1:10, 1:10);
+%! set (h, {"linewidth", "marker"}, {10, "x"; 5, "o"; 7, "."});
 
 %!error <set: number of names must match number of value columns>
-%!  set (gcf, "visible", "off");
-%!  h = plot (1:10, 10:-1:1, 1:10, 1:10);
-%!  set (h, {"linewidth"}, {10, "x"; 5, "o"});
+%! set (gcf, "visible", "off");
+%! h = plot (1:10, 10:-1:1, 1:10, 1:10);
+%! set (h, {"linewidth"}, {10, "x"; 5, "o"});
 */
 
 // Set properties given in a struct array
 void
 graphics_object::set (const octave_map& m)
 {
   for (octave_map::const_iterator p = m.begin ();
        p != m.end (); p++)
@@ -2046,26 +2046,26 @@ graphics_object::set (const octave_map& 
       set_value_or_default (name, val);
 
       if (error_state)
         break;
     }
 }
 
 /*
-%!# test set with struct arguments
+## test set with struct arguments
 %!test
-%!  set (gcf, "visible", "off");
-%!  h = plot (1:10, 10:-1:1);
-%!  set (h, struct ("linewidth", 10, "marker", "x"));
-%!  assert (get (h, "linewidth"), 10);
-%!  assert (get (h, "marker"), "x");
-%!  h = plot (1:10, 10:-1:1, 1:10, 1:10);
-%!  set (h, struct ("linewidth", {5, 10}));
-%!  assert (get(h, "linewidth"), {10; 10});
+%! set (gcf, "visible", "off");
+%! h = plot (1:10, 10:-1:1);
+%! set (h, struct ("linewidth", 10, "marker", "x"));
+%! assert (get (h, "linewidth"), 10);
+%! assert (get (h, "marker"), "x");
+%! h = plot (1:10, 10:-1:1, 1:10, 1:10);
+%! set (h, struct ("linewidth", {5, 10}));
+%! assert (get (h, "linewidth"), {10; 10});
 */
 
 // Set a property to a value or to its (factory) default value.
 
 void
 graphics_object::set_value_or_default (const caseless_str& name,
                                        const octave_value& val)
 {
@@ -2096,25 +2096,25 @@ graphics_object::set_value_or_default (c
       else
         rep->set (name, val);
     }
   else
     rep->set (name, val);
 }
 
 /*
-%!# test setting of default values
+## test setting of default values
 %!test
-%!  set (gcf, "visible", "off");
-%!  h = plot (1:10, 10:-1:1);
-%!  set (0, "defaultlinelinewidth", 20);
-%!  set (h, "linewidth", "default");
-%!  assert (get (h, "linewidth"), 20);
-%!  set (h, "linewidth", "factory");
-%!  assert (get (h, "linewidth"), 0.5);
+%! set (gcf, "visible", "off");
+%! h = plot (1:10, 10:-1:1);
+%! set (0, "defaultlinelinewidth", 20);
+%! set (h, "linewidth", "default");
+%! assert (get (h, "linewidth"), 20);
+%! set (h, "linewidth", "factory");
+%! assert (get (h, "linewidth"), 0.5);
 */
 
 static double
 make_handle_fraction (void)
 {
   static double maxrand = RAND_MAX + 2.0;
 
   return (rand () + 1.0) / maxrand;
@@ -3050,29 +3050,29 @@ root_figure::properties::get_boundingbox
   Matrix pos = Matrix (1, 4, 0);
   pos(2) = screen_size(0);
   pos(3) = screen_size(1);
   return pos;
 }
 
 /*
 %!test
-%! set (0, "units", "pixels")
+%! set (0, "units", "pixels");
 %! sz = get (0, "screensize") - [1, 1, 0, 0];
 %! dpi = get (0, "screenpixelsperinch");
-%! set (0, "units", "inches")
-%! assert (get (0, "screensize"), sz / dpi, 0.5 / dpi) 
-%! set (0, "units", "centimeters")
-%! assert (get (0, "screensize"), sz / dpi * 2.54, 0.5 / dpi * 2.54)
-%! set (0, "units", "points")
-%! assert (get (0, "screensize"), sz / dpi * 72, 0.5 / dpi * 72)
-%! set (0, "units", "normalized")
-%! assert (get (0, "screensize"), [0.0, 0.0, 1.0, 1.0])
-%! set (0, "units", "pixels")
-%! assert (get (0, "screensize"), sz + [1, 1, 0, 0])
+%! set (0, "units", "inches");
+%! assert (get (0, "screensize"), sz / dpi, 0.5 / dpi);
+%! set (0, "units", "centimeters");
+%! assert (get (0, "screensize"), sz / dpi * 2.54, 0.5 / dpi * 2.54);
+%! set (0, "units", "points");
+%! assert (get (0, "screensize"), sz / dpi * 72, 0.5 / dpi * 72);
+%! set (0, "units", "normalized");
+%! assert (get (0, "screensize"), [0.0, 0.0, 1.0, 1.0]);
+%! set (0, "units", "pixels");
+%! assert (get (0, "screensize"), sz + [1, 1, 0, 0]);
 */
 
 void
 root_figure::properties::remove_child (const graphics_handle& gh)
 {
   gh_manager::pop_figure (gh);
 
   graphics_handle cf = gh_manager::current_figure ();
@@ -3676,32 +3676,33 @@ figure::properties::update_paperorientat
       paperposition.set (octave_value (pos));
     }
 }
 
 /*
 %!test
 %! figure (1, "visible", false);
 %! tol = 100 * eps ();
-%! set (gcf (), "paperorientation", "PORTRAIT")
-%! set (gcf (), "paperunits", "inches")
-%! set (gcf (), "papertype", "USletter")
-%! assert (get (gcf (), "papersize"), [8.5, 11.0], tol)
-%! set (gcf (), "paperorientation", "Landscape")
-%! assert (get (gcf (), "papersize"), [11.0, 8.5], tol)
-%! set (gcf (), "paperunits", "centimeters")
-%! assert (get (gcf (), "papersize"), [11.0, 8.5] * 2.54, tol)
+%! ## UPPER case and MiXed case is part of test and should not be changed.
+%! set (gcf (), "paperorientation", "PORTRAIT");
+%! set (gcf (), "paperunits", "inches");
+%! set (gcf (), "papertype", "USletter");
+%! assert (get (gcf (), "papersize"), [8.5, 11.0], tol);
+%! set (gcf (), "paperorientation", "Landscape");
+%! assert (get (gcf (), "papersize"), [11.0, 8.5], tol);
+%! set (gcf (), "paperunits", "centimeters");
+%! assert (get (gcf (), "papersize"), [11.0, 8.5] * 2.54, tol);
 %! set (gcf (), "papertype", "a4");
-%! assert (get (gcf (), "papersize"), [29.7, 21.0], tol)
-%! set (gcf (), "paperunits", "inches", "papersize", [8.5, 11.0])
-%! assert (get (gcf (), "papertype"), "usletter")
-%! assert (get (gcf (), "paperorientation"), "portrait")
-%! set (gcf (), "papersize", [11.0, 8.5])
-%! assert (get (gcf (), "papertype"), "usletter")
-%! assert (get (gcf (), "paperorientation"), "landscape")
+%! assert (get (gcf (), "papersize"), [29.7, 21.0], tol);
+%! set (gcf (), "paperunits", "inches", "papersize", [8.5, 11.0]);
+%! assert (get (gcf (), "papertype"), "usletter");
+%! assert (get (gcf (), "paperorientation"), "portrait");
+%! set (gcf (), "papersize", [11.0, 8.5]);
+%! assert (get (gcf (), "papertype"), "usletter");
+%! assert (get (gcf (), "paperorientation"), "landscape");
 */
 
 void
 figure::properties::set_units (const octave_value& v)
 {
   if (! error_state)
     {
       caseless_str old_units = get_units ();
@@ -3717,23 +3718,23 @@ void
 figure::properties::update_units (const caseless_str& old_units)
 {
   position.set (convert_position (get_position ().matrix_value (), old_units,
                                   get_units (), screen_size_pixels ()), false);
 }
 
 /*
 %!test
-%! figure (1, "visible", false)
-%! set (0, "units", "pixels")
+%! figure (1, "visible", false);
+%! set (0, "units", "pixels");
 %! rsz = get (0, "screensize");
-%! set (gcf (), "units", "pixels")
+%! set (gcf (), "units", "pixels");
 %! fsz = get (gcf (), "position");
-%! set (gcf (), "units", "normalized")
-%! assert (get (gcf (), "position"), (fsz - [1, 1, 0, 0]) ./ rsz([3, 4, 3, 4]))
+%! set (gcf (), "units", "normalized");
+%! assert (get (gcf (), "position"), (fsz - [1, 1, 0, 0]) ./ rsz([3, 4, 3, 4]));
 */
 
 std::string
 figure::properties::get_title (void) const
 {
   if (is_numbertitle ())
     {
       std::ostringstream os;
@@ -4963,29 +4964,31 @@ axes::properties::update_ticklength (voi
 
   update_xlabel_position ();
   update_ylabel_position ();
   update_zlabel_position ();
   update_title_position ();
 }
 
 /*
+## FIXME: A demo can't be called in a C++ file.  This should be made a test
+## or moved to a .m file where it can be called.
 %!demo
-%!  clf
-%!  subplot (2, 1, 1)
-%!  plot (rand (3))
-%!  xlabel xlabel
-%!  ylabel ylabel
-%!  title title
-%!  subplot (2, 1, 2)
-%!  plot (rand (3))
-%!  set (gca, "ticklength", get (gca, "ticklength") * 2, "tickdir", "out")
-%!  xlabel xlabel
-%!  ylabel ylabel
-%!  title title
+%! clf;
+%! subplot (2,1,1);
+%! plot (rand (3));
+%! xlabel xlabel;
+%! ylabel ylabel;
+%! title title;
+%! subplot (2,1,2);
+%! plot (rand (3));
+%! set (gca, "ticklength", get (gca, "ticklength") * 2, "tickdir", "out");
+%! xlabel xlabel;
+%! ylabel ylabel;
+%! title title;
 */
 
 static bool updating_xlabel_position = false;
 
 void
 axes::properties::update_xlabel_position (void)
 {
   if (updating_xlabel_position)
@@ -8603,17 +8606,17 @@ values or lists respectively.\n\
             retval = vals;
         }
     }
 
   return retval;
 }
 
 /*
-%!assert (get (findobj (0, 'Tag', 'nonexistenttag'), 'nonexistentproperty'), [])
+%!assert (get (findobj (0, "Tag", "nonexistenttag"), "nonexistentproperty"), [])
 */
 
 // Return all properties from the graphics handle @var{h}.
 // If @var{h} is a vector, return a cell array including the
 // property values or lists respectively.
 
 DEFUN (__get__, args, ,
   "-*- texinfo -*-\n\
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -107,17 +107,17 @@ Compute the inverse cosine in radians fo
 %!test
 %! x = [1, rt3/2, rt2/2, 1/2, 0, -1/2, -rt2/2, -rt3/2, -1];
 %! v = [0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi];
 %! assert (acos (x), v, sqrt (eps));
 
 %!test
 %! x = single ([1, rt3/2, rt2/2, 1/2, 0, -1/2, -rt2/2, -rt3/2, -1]);
 %! v = single ([0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi]);
-%! assert (acos (x), v, sqrt (eps ('single')));
+%! assert (acos (x), v, sqrt (eps ("single")));
 
 %!error acos ()
 %!error acos (1, 2)
 */
 
 DEFUN (acosh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} acosh (@var{x})\n\
@@ -138,17 +138,17 @@ Compute the inverse hyperbolic cosine fo
 %!test
 %! x = [1, 0, -1, 0];
 %! v = [0, pi/2*i, pi*i, pi/2*i];
 %! assert (acosh (x), v, sqrt (eps));
 
 %!test
 %! x = single ([1, 0, -1, 0]);
 %! v = single ([0, pi/2*i, pi*i, pi/2*i]);
-%! assert (acosh (x), v, sqrt (eps ('single')));
+%! assert (acosh (x), v, sqrt (eps ("single")));
 
 %!error acosh ()
 %!error acosh (1, 2)
 */
 
 DEFUN (angle, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} angle (@var{z})\n\
@@ -208,17 +208,17 @@ arg (3 + 4i)\n\
 %!test
 %! if (ismac ())
 %!   ## Avoid failing for a MacOS feature
 %!   assert (arg (single (-1)), single (pi), 2*eps (single (1)));
 %! else
 %!   assert (arg (single (-1)), single (pi));
 %! endif
 %!assert (arg (single (-i)), single (-pi/2))
-%!assert (arg (single ([1, i; -1, -i])), single ([0, pi/2; pi, -pi/2]), 2e1*eps ('single'))
+%!assert (arg (single ([1, i; -1, -i])), single ([0, pi/2; pi, -pi/2]), 2e1*eps ("single"))
 
 %!error arg ()
 %!error arg (1, 2)
 */
 
 DEFUN (asin, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} asin (@var{x})\n\
@@ -267,17 +267,17 @@ Compute the inverse hyperbolic sine for 
 %!test
 %! v = [0, pi/2*i, 0, -pi/2*i];
 %! x = [0, i, 0, -i];
 %! assert (asinh (x), v,  sqrt (eps));
 
 %!test
 %! v = single ([0, pi/2*i, 0, -pi/2*i]);
 %! x = single ([0, i, 0, -i]);
-%! assert (asinh (x), v,  sqrt (eps ('single')));
+%! assert (asinh (x), v,  sqrt (eps ("single")));
 
 %!error asinh ()
 %!error asinh (1, 2)
 */
 
 DEFUN (atan, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atan (@var{x})\n\
@@ -302,17 +302,17 @@ Compute the inverse tangent in radians f
 %!test
 %! v = [0, pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6, 0];
 %! x = [0, rt3/3, 1, rt3, -rt3, -1, -rt3/3, 0];
 %! assert (atan (x), v, sqrt (eps));
 
 %!test
 %! v = single ([0, pi/6, pi/4, pi/3, -pi/3, -pi/4, -pi/6, 0]);
 %! x = single ([0, rt3/3, 1, rt3, -rt3, -1, -rt3/3, 0]);
-%! assert (atan (x), v, sqrt (eps ('single')));
+%! assert (atan (x), v, sqrt (eps ("single")));
 
 %!error atan ()
 %!error atan (1, 2)
 */
 
 DEFUN (atanh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atanh (@var{x})\n\
@@ -333,17 +333,17 @@ Compute the inverse hyperbolic tangent f
 %!test
 %! v = [0, 0];
 %! x = [0, 0];
 %! assert (atanh (x), v, sqrt (eps));
 
 %!test
 %! v = single ([0, 0]);
 %! x = single ([0, 0]);
-%! assert (atanh (x), v, sqrt (eps ('single')));
+%! assert (atanh (x), v, sqrt (eps ("single")));
 
 %!error atanh ()
 %!error atanh (1, 2)
 */
 
 DEFUN (cbrt, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} cbrt (@var{x})\n\
@@ -397,26 +397,26 @@ ceil ([-2.7, 2.7])\n\
     retval = args(0).ceil ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%% double precision
+## double precision
 %!assert (ceil ([2, 1.1, -1.1, -1]), [2, 2, -1, -1])
 
-%% complex double precison
+## complex double precison
 %!assert (ceil ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i]), [2+2i, 2+2i, -1-i, -1-i])
 
-%% single precision
+## single precision
 %!assert (ceil (single ([2, 1.1, -1.1, -1])), single ([2, 2, -1, -1]))
 
-%% complex single precision
+## complex single precision
 %!assert (ceil (single ([2+2i, 1.1+1.1i, -1.1-1.1i, -1-i])), single ([2+2i, 2+2i, -1-i, -1-i]))
 
 %!error ceil ()
 %!error ceil (1, 2)
 */
 
 DEFUN (conj, args, ,
     "-*- texinfo -*-\n\
@@ -483,17 +483,17 @@ Compute the cosine for each element of @
 %! v = [1, rt3/2, rt2/2, 1/2, 0, -1/2, -rt2/2, -rt3/2, -1];
 %! assert (cos (x), v, sqrt (eps));
 
 %!test
 %! rt2 = sqrt (2);
 %! rt3 = sqrt (3);
 %! x = single ([0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi]);
 %! v = single ([1, rt3/2, rt2/2, 1/2, 0, -1/2, -rt2/2, -rt3/2, -1]);
-%! assert (cos (x), v, sqrt (eps ('single')));
+%! assert (cos (x), v, sqrt (eps ("single")));
 
 %!error cos ()
 %!error cos (1, 2)
 */
 
 DEFUN (cosh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} cosh (@var{x})\n\
@@ -514,17 +514,17 @@ Compute the hyperbolic cosine for each e
 %!test
 %! x = [0, pi/2*i, pi*i, 3*pi/2*i];
 %! v = [1, 0, -1, 0];
 %! assert (cosh (x), v, sqrt (eps));
 
 %!test
 %! x = single ([0, pi/2*i, pi*i, 3*pi/2*i]);
 %! v = single ([1, 0, -1, 0]);
-%! assert (cosh (x), v, sqrt (eps ('single')));
+%! assert (cosh (x), v, sqrt (eps ("single")));
 
 %!error cosh ()
 %!error cosh (1, 2)
 */
 
 DEFUN (erf, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erf (@var{z})\n\
@@ -563,32 +563,32 @@ erf (z) = (2/sqrt (pi)) | e^(-t^2) dt\n\
 /*
 %!test
 %! a = -1i*sqrt (-1/(6.4187*6.4187));
 %! assert (erf (a), erf (real (a)));
 
 %!test
 %! x = [0,.5,1];
 %! v = [0, .520499877813047, .842700792949715];
-%! assert (all (abs (erf (x)-v) < 1.e-10));
-%! assert (all (abs (erf (-x)+v) < 1.e-10));
-%! assert (all (abs (erfc (x)+v-1) < 1.e-10));
-%! assert (all (abs (erfinv (v)-x) < 1.e-10));
+%! assert (erf (x), v, 1.e-10);
+%! assert (erf (-x), -v, 1.e-10);
+%! assert (erfc (x), 1-v, 1.e-10);
+%! assert (erfinv (v), x, 1.e-10);
 
 %!test
 %! a = -1i*sqrt (single (-1/(6.4187*6.4187)));
 %! assert (erf (a), erf (real (a)));
 
 %!test
 %! x = single ([0,.5,1]);
 %! v = single ([0, .520499877813047, .842700792949715]);
-%! assert (all (abs (erf (x)-v) < 1.e-6));
-%! assert (all (abs (erf (-x)+v) < 1.e-6));
-%! assert (all (abs (erfc (x)+v-1) < 1.e-6));
-%! assert (all (abs (erfinv (v)-x) < 1.e-6));
+%! assert (erf (x), v, 1.e-6);
+%! assert (erf (-x), -v, 1.e-6);
+%! assert (erfc (x), 1-v, 1.e-6);
+%! assert (erfinv (v), x, 1.e-6);
 
 %!error erf ()
 %!error erf (1, 2)
 */
 
 DEFUN (erfinv, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} erfinv (@var{x})\n\
@@ -605,26 +605,26 @@ erf (@var{y}) == @var{x}\n\
     retval = args(0).erfinv ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%% middle region
+## middle region
 %!assert (erf (erfinv ([-0.9 -0.3 0 0.4 0.8])), [-0.9 -0.3 0 0.4 0.8], eps)
 %!assert (erf (erfinv (single ([-0.9 -0.3 0 0.4 0.8]))), single ([-0.9 -0.3 0 0.4 0.8]), 1e-8)
-%% tail region
+## tail region
 %!assert (erf (erfinv ([-0.999 -0.99 0.9999 0.99999])), [-0.999 -0.99 0.9999 0.99999], eps)
 %!assert (erf (erfinv (single ([-0.999 -0.99 0.9999 0.99999]))), single ([-0.999 -0.99 0.9999 0.99999]), 1e-8)
-%% backward - loss of accuracy
+## backward - loss of accuracy
 %!assert (erfinv (erf ([-3 -1 -0.4 0.7 1.3 2.8])), [-3 -1 -0.4 0.7 1.3 2.8], -1e-12)
 %!assert (erfinv (erf (single ([-3 -1 -0.4 0.7 1.3 2.8]))), single ([-3 -1 -0.4 0.7 1.3 2.8]), -1e-4)
-%% exceptional
+## exceptional
 %!assert (erfinv ([-1, 1, 1.1, -2.1]), [-Inf, Inf, NaN, NaN])
 %!error erfinv (1+2i)
 
 %!error erfinv ()
 %!error erfinv (1, 2)
 */
 
 DEFUN (erfc, args, ,
@@ -682,17 +682,17 @@ exp (z^2) * erfc (x)\n\
     retval = args(0).erfcx ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%% FIXME: Need a test for erfcx
+## FIXME: Need a test for erfcx
 
 %!error erfcx ()
 %!error erfcx (1, 2)
 */
 
 DEFUN (exp, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} exp (@var{x})\n\
@@ -715,18 +715,18 @@ exponential, see @ref{Linear Algebra}.\n
     print_usage ();
 
   return retval;
 }
 
 /*
 %!assert (exp ([0, 1, -1, -1000]), [1, e, 1/e, 0], sqrt (eps))
 %!assert (exp (1+i), e * (cos (1) + sin (1) * i), sqrt (eps))
-%!assert (exp (single ([0, 1, -1, -1000])), single ([1, e, 1/e, 0]), sqrt (eps ('single')))
-%!assert (exp (single (1+i)), single (e * (cos (1) + sin (1) * i)), sqrt (eps ('single')))
+%!assert (exp (single ([0, 1, -1, -1000])), single ([1, e, 1/e, 0]), sqrt (eps ("single")))
+%!assert (exp (single (1+i)), single (e * (cos (1) + sin (1) * i)), sqrt (eps ("single")))
 
 %!assert (exp ([Inf, -Inf, NaN]), [Inf 0 NaN])
 %!assert (exp (single ([Inf, -Inf, NaN])), single ([Inf 0 NaN]))
 
 %!error exp ()
 %!error exp (1, 2)
 */
 
@@ -919,17 +919,17 @@ gamma (z) = | t^(z-1) exp (-t) dt.\n\
 
 %!test
 %! a = single (-1i*sqrt (-1/(6.4187*6.4187)));
 %! assert (gamma (a), gamma (real (a)));
 
 %!test
 %! x = single ([.5, 1, 1.5, 2, 3, 4, 5]);
 %! v = single ([sqrt(pi), 1, .5*sqrt(pi), 1, 2, 6, 24]);
-%! assert (gamma (x), v, sqrt (eps ('single')));
+%! assert (gamma (x), v, sqrt (eps ("single")));
 
 %!test
 %! x = [-1, 0, 1, Inf];
 %! v = [Inf, Inf, 1, Inf];
 %! assert (gamma (x), v);
 %! assert (gamma (single (x)), single (v));
 
 %!error gamma ()
@@ -956,17 +956,17 @@ Return the imaginary part of @var{z} as 
 %!assert (imag (1), 0)
 %!assert (imag (i), 1)
 %!assert (imag (1+i), 1)
 %!assert (imag ([i, 1; 1, i]), full (eye (2)))
 
 %!assert (imag (single (1)), single (0))
 %!assert (imag (single (i)), single (1))
 %!assert (imag (single (1+i)), single (1))
-%!assert (imag (single ([i, 1; 1, i])), full (eye (2,'single')))
+%!assert (imag (single ([i, 1; 1, i])), full (eye (2,"single")))
 
 %!error imag ()
 %!error imag (1, 2)
 */
 
 DEFUNX ("isalnum", Fisalnum, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isalnum (@var{s})\n\
@@ -987,17 +987,17 @@ letters or digits and false where they a
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii ("A":"Z") + 1) = true;
 %! result(toascii ("0":"9") + 1) = true;
 %! result(toascii ("a":"z") + 1) = true;
-%! assert (all (isalnum (charset) == result));
+%! assert (isalnum (charset), result);
 
 %!error isalnum ()
 %!error isalnum (1, 2)
 */
 
 DEFUNX ("isalpha", Fisalpha, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isalpha (@var{s})\n\
@@ -1017,17 +1017,17 @@ letters and false where they are not.  T
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii ("A":"Z") + 1) = true;
 %! result(toascii ("a":"z") + 1) = true;
-%! assert (all (isalpha (charset) == result));
+%! assert (isalpha (charset), result);
 
 %!error isalpha ()
 %!error isalpha (1, 2)
 */
 
 DEFUNX ("isascii", Fisascii, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isascii (@var{s})\n\
@@ -1044,17 +1044,17 @@ not.\n\
 
   return retval;
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = true (1, 128);
-%! assert (all (isascii (charset) == result));
+%! assert (isascii (charset), result);
 
 %!error isascii ()
 %!error isascii (1, 2)
 */
 
 DEFUNX ("iscntrl", Fiscntrl, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} iscntrl (@var{s})\n\
@@ -1073,17 +1073,17 @@ control characters and false where they 
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(1:32) = true;
 %! result(128) = true;
-%! assert (all (iscntrl (charset) == result));
+%! assert (iscntrl (charset), result);
 
 %!error iscntrl ()
 %!error iscntrl (1, 2)
 */
 
 DEFUNX ("isdigit", Fisdigit, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isdigit (@var{s})\n\
@@ -1101,17 +1101,17 @@ decimal digits (0-9) and false where the
   return retval;
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii ("0":"9") + 1) = true;
-%! assert (all (isdigit (charset) == result));
+%! assert (isdigit (charset), result);
 
 %!error isdigit ()
 %!error isdigit (1, 2)
 */
 
 DEFUN (isinf, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isinf (@var{x})\n\
@@ -1172,17 +1172,17 @@ not.\n\
   return retval;
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(34:127) = true;
-%! assert (all (isgraph (charset) == result));
+%! assert (isgraph (charset), result);
 
 %!error isgraph ()
 %!error isgraph (1, 2)
 */
 
 DEFUNX ("islower", Fislower, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} islower (@var{s})\n\
@@ -1200,17 +1200,17 @@ lowercase letters and false where they a
   return retval;
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii ("a":"z") + 1) = true;
-%! assert (all (islower (charset) == result));
+%! assert (islower (charset), result);
 
 %!error islower ()
 %!error islower (1, 2)
 */
 
 DEFUN (isna, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isna (@var{x})\n\
@@ -1313,17 +1313,17 @@ are not.\n\
   return retval;
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(33:127) = true;
-%! assert (all (isprint (charset) == result));
+%! assert (isprint (charset), result);
 
 %!error isprint ()
 %!error isprint (1, 2)
 */
 
 DEFUNX ("ispunct", Fispunct, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} ispunct (@var{s})\n\
@@ -1344,17 +1344,17 @@ punctuation characters and false where t
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(34:48) = true;
 %! result(59:65) = true;
 %! result(92:97) = true;
 %! result(124:127) = true;
-%! assert (all (ispunct (charset) == result));
+%! assert (ispunct (charset), result);
 
 %!error ispunct ()
 %!error ispunct (1, 2)
 */
 
 DEFUNX ("isspace", Fisspace, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isspace (@var{s})\n\
@@ -1373,17 +1373,17 @@ vertical tab) and false where they are n
   return retval;
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii (" \f\n\r\t\v") + 1) = true;
-%! assert (all (isspace (charset) == result));
+%! assert (isspace (charset), result);
 
 %!error isspace ()
 %!error isspace (1, 2)
 */
 
 DEFUNX ("isupper", Fisupper, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isupper (@var{s})\n\
@@ -1401,17 +1401,17 @@ uppercase letters and false where they a
   return retval;
 }
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii ("A":"Z") + 1) = true;
-%! assert (all (isupper (charset) == result));
+%! assert (isupper (charset), result);
 
 %!error isupper ()
 %!error isupper (1, 2)
 */
 
 DEFUNX ("isxdigit", Fisxdigit, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isxdigit (@var{s})\n\
@@ -1431,17 +1431,17 @@ hexadecimal digits (0-9 and @nospell{a-f
 
 /*
 %!test
 %! charset = char (0:127);
 %! result = false (1, 128);
 %! result(toascii ("A":"F") + 1) = true;
 %! result(toascii ("0":"9") + 1) = true;
 %! result(toascii ("a":"f") + 1) = true;
-%! assert (all (isxdigit (charset) == result));
+%! assert (isxdigit (charset), result);
 
 %!error isxdigit ()
 %!error isxdigit (1, 2)
 */
 
 DEFUN (lgamma, args, ,
     "-*- texinfo -*-\n\
 @deftypefn  {Mapping Function} {} lgamma (@var{x})\n\
@@ -1457,40 +1457,40 @@ Return the natural logarithm of the gamm
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
 %! a = -1i*sqrt (-1/(6.4187*6.4187));
-%! assert (lgamma(a), lgamma(real(a)));
+%! assert (lgamma (a), lgamma (real (a)));
 
 %!test
 %! x = [.5, 1, 1.5, 2, 3, 4, 5];
 %! v = [sqrt(pi), 1, .5*sqrt(pi), 1, 2, 6, 24];
-%! assert (lgamma(x), log(v), sqrt (eps))
+%! assert (lgamma (x), log (v), sqrt (eps))
 
 %!test
 %! a = single (-1i*sqrt (-1/(6.4187*6.4187)));
-%! assert (lgamma(a), lgamma(real(a)));
+%! assert (lgamma (a), lgamma (real (a)));
 
 %!test
 %! x = single ([.5, 1, 1.5, 2, 3, 4, 5]);
 %! v = single ([sqrt(pi), 1, .5*sqrt(pi), 1, 2, 6, 24]);
-%! assert (lgamma(x), log(v), sqrt (eps ('single')))
+%! assert (lgamma (x), log (v), sqrt (eps ("single")))
 
 %!test
 %! x = [-1, 0, 1, Inf];
 %! v = [Inf, Inf, 0, Inf];
-%! assert (lgamma(x), v);
-%! assert (lgamma(single (x)), single (v));
+%! assert (lgamma (x), v);
+%! assert (lgamma (single (x)), single (v));
 
-%!error lgamma()
-%!error lgamma(1,2)
+%!error lgamma ()
+%!error lgamma (1,2)
 */
 
 DEFUN (log, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log (@var{x})\n\
 Compute the natural logarithm,\n\
 @tex\n\
 $\\ln{(x)},$\n\
@@ -1509,20 +1509,20 @@ matrix logarithm, see @ref{Linear Algebr
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!assert (log ([1, e, e^2]), [0, 1, 2], sqrt (eps))
-%!assert (log ([-0.5, -1.5, -2.5]), log([0.5, 1.5, 2.5]) + pi*1i, sqrt (eps))
+%!assert (log ([-0.5, -1.5, -2.5]), log ([0.5, 1.5, 2.5]) + pi*1i, sqrt (eps))
 
-%!assert (log (single ([1, e, e^2])), single ([0, 1, 2]), sqrt (eps ('single')))
-%!assert (log (single ([-0.5, -1.5, -2.5])), single (log([0.5, 1.5, 2.5]) + pi*1i), 4*eps ('single'))
+%!assert (log (single ([1, e, e^2])), single ([0, 1, 2]), sqrt (eps ("single")))
+%!assert (log (single ([-0.5, -1.5, -2.5])), single (log ([0.5, 1.5, 2.5]) + pi*1i), 4*eps ("single"))
 
 %!error log ()
 %!error log (1, 2)
 */
 
 DEFUN (log10, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log10 (@var{x})\n\
@@ -1536,17 +1536,17 @@ Compute the base-10 logarithm of each el
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!assert (log10 ([0.01, 0.1, 1, 10, 100]), [-2, -1, 0, 1, 2], sqrt (eps))
-%!assert (log10 (single ([0.01, 0.1, 1, 10, 100])), single ([-2, -1, 0, 1, 2]), sqrt (eps ('single')))
+%!assert (log10 (single ([0.01, 0.1, 1, 10, 100])), single ([-2, -1, 0, 1, 2]), sqrt (eps ("single")))
 
 %!error log10 ()
 %!error log10 (1, 2)
 */
 
 DEFUN (log1p, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log1p (@var{x})\n\
@@ -1567,17 +1567,17 @@ accurately in the neighborhood of zero.\
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!assert (log1p ([0, 2*eps, -2*eps]), [0, 2*eps, -2*eps], 1e-29)
-%!assert (log1p (single ([0, 2*eps, -2*eps])), single([0, 2*eps, -2*eps]), 1e-29)
+%!assert (log1p (single ([0, 2*eps, -2*eps])), single ([0, 2*eps, -2*eps]), 1e-29)
 
 %!error log1p ()
 %!error log1p (1, 2)
 */
 
 DEFUN (real, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} real (@var{z})\n\
@@ -1598,17 +1598,17 @@ Return the real part of @var{z}.\n\
 %!assert (real (1), 1)
 %!assert (real (i), 0)
 %!assert (real (1+i), 1)
 %!assert (real ([1, i; i, 1]), full (eye (2)))
 
 %!assert (real (single (1)), single (1))
 %!assert (real (single (i)), single (0))
 %!assert (real (single (1+i)), single (1))
-%!assert (real (single ([1, i; i, 1])), full (eye (2,'single')))
+%!assert (real (single ([1, i; i, 1])), full (eye (2,"single")))
 
 %!error real ()
 %!error real (1, 2)
 */
 
 DEFUN (round, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} round (@var{x})\n\
@@ -1768,17 +1768,17 @@ Compute the sine for each element of @va
 %!test
 %! x = [0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi];
 %! v = [0, 1/2, rt2/2, rt3/2, 1, rt3/2, rt2/2, 1/2, 0];
 %! assert (sin (x), v, sqrt (eps));
 
 %!test
 %! x = single ([0, pi/6, pi/4, pi/3, pi/2, 2*pi/3, 3*pi/4, 5*pi/6, pi]);
 %! v = single ([0, 1/2, rt2/2, rt3/2, 1, rt3/2, rt2/2, 1/2, 0]);
-%! assert (sin (x), v, sqrt (eps ('single')));
+%! assert (sin (x), v, sqrt (eps ("single")));
 
 %!error sin ()
 %!error sin (1, 2)
 */
 
 DEFUN (sinh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sinh (@var{x})\n\
@@ -1799,17 +1799,17 @@ Compute the hyperbolic sine for each ele
 %!test
 %! x = [0, pi/2*i, pi*i, 3*pi/2*i];
 %! v = [0, i, 0, -i];
 %! assert (sinh (x), v, sqrt (eps));
 
 %!test
 %! x = single ([0, pi/2*i, pi*i, 3*pi/2*i]);
 %! v = single ([0, i, 0, -i]);
-%! assert (sinh (x), v, sqrt (eps ('single')));
+%! assert (sinh (x), v, sqrt (eps ("single")));
 
 %!error sinh ()
 %!error sinh (1, 2)
 */
 
 DEFUN (sqrt, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sqrt (@var{x})\n\
@@ -1831,18 +1831,18 @@ a complex result is returned.  To comput
 /*
 %!assert (sqrt (4), 2)
 %!assert (sqrt (-1), i)
 %!assert (sqrt (1+i), exp (0.5 * log (1+i)), sqrt (eps))
 %!assert (sqrt ([4, -4; i, 1-i]), [2, 2i; exp(0.5 * log (i)), exp(0.5 * log (1-i))], sqrt (eps))
 
 %!assert (sqrt (single (4)), single (2))
 %!assert (sqrt (single (-1)), single (i))
-%!assert (sqrt (single (1+i)), single (exp (0.5 * log (1+i))), sqrt (eps ('single')))
-%!assert (sqrt (single ([4, -4; i, 1-i])), single ([2, 2i; exp(0.5 * log (i)), exp(0.5 * log (1-i))]), sqrt (eps ('single')))
+%!assert (sqrt (single (1+i)), single (exp (0.5 * log (1+i))), sqrt (eps ("single")))
+%!assert (sqrt (single ([4, -4; i, 1-i])), single ([2, 2i; exp(0.5 * log (i)), exp(0.5 * log (1-i))]), sqrt (eps ("single")))
 
 %!error sqrt ()
 %!error sqrt (1, 2)
 */
 
 DEFUN (tan, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} tan (@var{z})\n\
@@ -1867,17 +1867,17 @@ Compute the tangent for each element of 
 %!test
 %! x = [0, pi/6, pi/4, pi/3, 2*pi/3, 3*pi/4, 5*pi/6, pi];
 %! v = [0, rt3/3, 1, rt3, -rt3, -1, -rt3/3, 0];
 %! assert (tan (x), v,  sqrt (eps));
 
 %!test
 %! x = single ([0, pi/6, pi/4, pi/3, 2*pi/3, 3*pi/4, 5*pi/6, pi]);
 %! v = single ([0, rt3/3, 1, rt3, -rt3, -1, -rt3/3, 0]);
-%! assert (tan (x), v,  sqrt (eps ('single')));
+%! assert (tan (x), v,  sqrt (eps ("single")));
 
 %!error tan ()
 %!error tan (1, 2)
 */
 
 DEFUN (tanh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} tanh (@var{x})\n\
@@ -1898,17 +1898,17 @@ Compute hyperbolic tangent for each elem
 %!test
 %! x = [0, pi*i];
 %! v = [0, 0];
 %! assert (tanh (x), v, sqrt (eps));
 
 %!test
 %! x = single ([0, pi*i]);
 %! v = single ([0, 0]);
-%! assert (tanh (x), v, sqrt (eps ('single')));
+%! assert (tanh (x), v, sqrt (eps ("single")));
 
 %!error tanh ()
 %!error tanh (1, 2)
 */
 
 DEFUNX ("toascii", Ftoascii, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} toascii (@var{s})\n\
@@ -1969,35 +1969,35 @@ tolower (\"MiXeD cAsE 123\")\n\
     print_usage ();
 
   return retval;
 }
 
 DEFALIAS (lower, tolower);
 
 /*
-%!assert (tolower("OCTAVE"), "octave")
-%!assert (tolower("123OCTave!_&"), "123octave!_&")
-%!assert (tolower({"ABC", "DEF", {"GHI", {"JKL"}}}), {"abc", "def", {"ghi", {"jkl"}}})
-%!assert (tolower(["ABC"; "DEF"]), ["abc"; "def"])
-%!assert (tolower({["ABC"; "DEF"]}), {["abc";"def"]})
-%!assert (tolower(68), "d")
-%!assert (tolower({[68, 68; 68, 68]}), {["dd";"dd"]})
+%!assert (tolower ("OCTAVE"), "octave")
+%!assert (tolower ("123OCTave!_&"), "123octave!_&")
+%!assert (tolower ({"ABC", "DEF", {"GHI", {"JKL"}}}), {"abc", "def", {"ghi", {"jkl"}}})
+%!assert (tolower (["ABC"; "DEF"]), ["abc"; "def"])
+%!assert (tolower ({["ABC"; "DEF"]}), {["abc";"def"]})
+%!assert (tolower (68), "d")
+%!assert (tolower ({[68, 68; 68, 68]}), {["dd";"dd"]})
 %!test
-%!  a(3,3,3,3) = "D";
-%!  assert(tolower(a)(3,3,3,3), "d");
+%! a(3,3,3,3) = "D";
+%! assert (tolower (a)(3,3,3,3), "d");
 
 %!test
 %! charset = char (0:127);
 %! result = charset;
-%! result(toascii ("A":"Z") + 1) = result(toascii ("a":"z") + 1);
-%! assert (all (tolower (charset) == result));
+%! result (toascii ("A":"Z") + 1) = result (toascii ("a":"z") + 1);
+%! assert (tolower (charset), result);
 
-%!error <Invalid call to tolower> tolower()
-%!error <Invalid call to tolower> lower()
+%!error <Invalid call to tolower> lower ()
+%!error <Invalid call to tolower> tolower ()
 %!error tolower (1, 2)
 */
 
 DEFUNX ("toupper", Ftoupper, args, ,
     "-*- texinfo -*-\n\
 @deftypefn  {Mapping Function} {} toupper (@var{s})\n\
 @deftypefnx {Mapping Function} {} upper (@var{s})\n\
 Return a copy of the string or cell string @var{s}, with each lowercase\n\
@@ -2028,24 +2028,24 @@ DEFALIAS (upper, toupper);
 %!assert (toupper ("octave"), "OCTAVE")
 %!assert (toupper ("123OCTave!_&"), "123OCTAVE!_&")
 %!assert (toupper ({"abc", "def", {"ghi", {"jkl"}}}), {"ABC", "DEF", {"GHI", {"JKL"}}})
 %!assert (toupper (["abc"; "def"]), ["ABC"; "DEF"])
 %!assert (toupper ({["abc"; "def"]}), {["ABC";"DEF"]})
 %!assert (toupper (100), "D")
 %!assert (toupper ({[100, 100; 100, 100]}), {["DD";"DD"]})
 %!test
-%!  a(3,3,3,3) = "d";
-%!  assert(toupper (a)(3,3,3,3), "D");
+%! a(3,3,3,3) = "d";
+%! assert (toupper (a)(3,3,3,3), "D");
 %!test
 %! charset = char (0:127);
 %! result = charset;
-%! result(toascii  ("a":"z") + 1) = result(toascii  ("A":"Z") + 1);
-%! assert (all (toupper (charset) == result));
+%! result (toascii  ("a":"z") + 1) = result (toascii  ("A":"Z") + 1);
+%! assert (toupper (charset), result);
 
-%!error <Invalid call to toupper> toupper()
-%!error <Invalid call to toupper> upper()
+%!error <Invalid call to toupper> toupper ()
+%!error <Invalid call to toupper> upper ()
 %!error toupper (1, 2)
 */
 
 DEFALIAS (gammaln, lgamma);
 
 DEFALIAS (finite, isfinite);
diff --git a/src/oct-map.cc b/src/oct-map.cc
--- a/src/oct-map.cc
+++ b/src/oct-map.cc
@@ -443,20 +443,20 @@ octave_map::squeeze (void) const
     retval.xvals[i] = xvals[i].squeeze ();
 
   retval.optimize_dimensions ();
 
   return retval;
 }
 
 /*
-%!# test preservation of xkeys by squeeze
+## test preservation of xkeys by squeeze
 %!test
-%!  x(1,1,1,1).d = 10; x(3,5,1,7).a = "b"; x(2,4,1,7).f = 27;
-%!  assert (fieldnames (squeeze (x)), {"d"; "a"; "f"});
+%! x(1,1,1,1).d = 10;  x(3,5,1,7).a = "b";  x(2,4,1,7).f = 27;
+%! assert (fieldnames (squeeze (x)), {"d"; "a"; "f"});
 */
 
 octave_map
 octave_map::permute (const Array<int>& vec, bool inv) const
 {
   octave_map retval (xkeys);
   octave_idx_type nf = nfields ();
 
@@ -477,20 +477,20 @@ octave_map::permute (const Array<int>& v
     }
 
   retval.optimize_dimensions ();
 
   return retval;
 }
 
 /*
-%!# test preservation of key order by permute
+## test preservation of key order by permute
 %!test
-%!  x(1,1,1,1).d = 10; x(3,5,1,7).a = "b"; x(2,4,1,7).f = 27;
-%!  assert (fieldnames (permute (x, [3, 4, 1, 2])), {"d"; "a"; "f"});
+%! x(1,1,1,1).d = 10;  x(3,5,1,7).a = "b";  x(2,4,1,7).f = 27;
+%! assert (fieldnames (permute (x, [3, 4, 1, 2])), {"d"; "a"; "f"});
 */
 
 octave_map
 octave_map::transpose (void) const
 {
   assert (ndims () == 2);
 
   octave_map retval (xkeys);
@@ -502,22 +502,22 @@ octave_map::transpose (void) const
     retval.xvals[i] = xvals[i].transpose ();
 
   retval.optimize_dimensions ();
 
   return retval;
 }
 
 /*
-%!# test preservation of key order by transpose
+## test preservation of key order by transpose
 %!test
-%!  x(1,1).d = 10; x(3,5).a = "b"; x(2,4).f = 27;
-%!  assert (fieldnames (transpose (x)), {"d"; "a"; "f"});
-%!  assert (fieldnames (x'), {"d"; "a"; "f"});
-%!  assert (fieldnames (x.'), {"d"; "a"; "f"});
+%! x(1,1).d = 10;  x(3,5).a = "b";  x(2,4).f = 27;
+%! assert (fieldnames (transpose (x)), {"d"; "a"; "f"});
+%! assert (fieldnames (x'), {"d"; "a"; "f"});
+%! assert (fieldnames (x.'), {"d"; "a"; "f"});
 */
 
 octave_map
 octave_map::reshape (const dim_vector& dv) const
 {
   octave_map retval (xkeys);
   retval.dimensions = dv;
 
@@ -537,20 +537,20 @@ octave_map::reshape (const dim_vector& d
     }
 
   retval.optimize_dimensions ();
 
   return retval;
 }
 
 /*
-%!# test preservation of key order by reshape
+## test preservation of key order by reshape
 %!test
-%!  x(1,1).d = 10; x(4,6).a = "b"; x(2,4).f = 27;
-%!  assert (fieldnames (reshape (x, 3, 8)), {"d"; "a"; "f"});
+%! x(1,1).d = 10;  x(4,6).a = "b";  x(2,4).f = 27;
+%! assert (fieldnames (reshape (x, 3, 8)), {"d"; "a"; "f"});
 */
 
 void
 octave_map::resize (const dim_vector& dv, bool fill)
 {
   octave_idx_type nf = nfields ();
   if (nf > 0)
     {
@@ -799,33 +799,33 @@ octave_map::cat (int dim, octave_idx_typ
 
       retval.optimize_dimensions ();
     }
 
   return retval;
 }
 
 /*
-%!# test preservation of key order by concatenation
+## test preservation of key order by concatenation
 %!test
-%!  x(1, 1).d = 10; x(4, 6).a = "b"; x(2, 4).f = 27;
-%!  y(1, 6).f = 11; y(1, 6).a = "c"; y(1, 6).d = 33;
-%!  assert (fieldnames ([x; y]), {"d"; "a"; "f"});
+%! x(1, 1).d = 10;  x(4, 6).a = "b";  x(2, 4).f = 27;
+%! y(1, 6).f = 11;  y(1, 6).a = "c";  y(1, 6).d = 33;
+%! assert (fieldnames ([x; y]), {"d"; "a"; "f"});
 
 %!test
-%!  s = struct ();
-%!  sr = [s,s];
-%!  sc = [s;s];
-%!  sm = [s,s;s,s];
-%!  assert (nfields (sr), 0);
-%!  assert (nfields (sc), 0);
-%!  assert (nfields (sm), 0);
-%!  assert (size (sr), [1, 2]);
-%!  assert (size (sc), [2, 1]);
-%!  assert (size (sm), [2, 2]);
+%! s = struct ();
+%! sr = [s,s];
+%! sc = [s;s];
+%! sm = [s,s;s,s];
+%! assert (nfields (sr), 0);
+%! assert (nfields (sc), 0);
+%! assert (nfields (sm), 0);
+%! assert (size (sr), [1, 2]);
+%! assert (size (sc), [2, 1]);
+%! assert (size (sm), [2, 2]);
 */
 
 octave_map
 octave_map::index (const idx_vector& i, bool resize_ok) const
 {
   octave_map retval (xkeys);
   octave_idx_type nf = nfields ();
 
@@ -1245,20 +1245,20 @@ octave_map::delete_elements (const octav
         break;
     }
 
   if (! error_state)
     delete_elements (ia);
 }
 
 /*
-%!# test preservation of key order by indexing
+## test preservation of key order by indexing
 %!test
-%!  x(1, 1).d = 10; x(4, 6).a = "b"; x(2, 4).f = 27;
-%!  assert (fieldnames (x([1, 2], [2:5])), {"d"; "a"; "f"});
+%! x(1, 1).d = 10;  x(4, 6).a = "b";  x(2, 4).f = 27;
+%! assert (fieldnames (x([1, 2], [2:5])), {"d"; "a"; "f"});
 */
 
 octave_map
 octave_map::concat (const octave_map& rb, const Array<octave_idx_type>& ra_idx)
 {
   if (nfields () == rb.nfields ())
     {
       for (const_iterator pa = begin (); pa != end (); pa++)
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -977,18 +977,18 @@ for an example of how to create an execu
     retval = Cell (octave_argv);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error argv (1);
-%!assert (iscellstr (argv ()));
+%!assert (iscellstr (argv ()))
+%!error argv (1)
 */
 
 DEFUN (program_invocation_name, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} program_invocation_name ()\n\
 Return the name that was typed at the shell prompt to run Octave.\n\
 \n\
 If executing a script from the command line (e.g., @code{octave foo.m})\n\
@@ -1004,18 +1004,18 @@ how to create an executable Octave scrip
     retval = octave_program_invocation_name;
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error program_invocation_name (1);
-%!assert (ischar (program_invocation_name ()));
+%!assert (ischar (program_invocation_name ()))
+%!error program_invocation_name (1)
 */
 
 DEFUN (program_name, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} program_name ()\n\
 Return the last component of the value returned by\n\
 @code{program_invocation_name}.\n\
 @seealso{program_invocation_name}\n\
@@ -1027,11 +1027,11 @@ Return the last component of the value r
     retval = octave_program_name;
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error program_name (1);
-%!assert (ischar (program_name ()));
+%!assert (ischar (program_name ()))
+%!error program_name (1)
 */
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -1553,19 +1553,18 @@ When called from inside a function with 
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (sparse_auto_mutate);
 }
 
 /*
-
 %!test
- s = speye(3);
- sparse_auto_mutate (false);
- s(:, 1) = 1;
- assert (typeinfo (s), "sparse matrix");
- sparse_auto_mutate (true);
- s(1, :) = 1;
- assert (typeinfo (s), "matrix");
-
+%! s = speye (3);
+%! sparse_auto_mutate (false);
+%! s(:, 1) = 1;
+%! assert (typeinfo (s), "sparse matrix");
+%! sparse_auto_mutate (true);
+%! s(1, :) = 1;
+%! assert (typeinfo (s), "matrix");
+%! sparse_auto_mutate (false);
 */
diff --git a/src/ov-bool-mat.cc b/src/ov-bool-mat.cc
--- a/src/ov-bool-mat.cc
+++ b/src/ov-bool-mat.cc
@@ -572,18 +572,17 @@ Convert @var{x} to logical type.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!shared m, s, c
+%!test
 %! m = eye (2) != 0;
 %! s = !0;
 %! c = {"double", "single", "int8", "int16", "int32", "int64", "uint8", "uint16", "uint32", "uint64", "logical"};
-%!test
 %! for i = 1:numel (c)
 %!   assert (logical (eye (2, c{i})), m)
 %!   assert (logical (eye (1, c{i})), s)
 %! endfor
 */
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -1466,24 +1466,24 @@ c(2,1,:)(:)\n\
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%!  keys = cellstr (char (floor (rand (11,10)*24+65)))';
-%!  vals = cellfun(@(x) mat2cell(rand (19,1), ones (19,1), 1), ...
-%!           mat2cell([1:11]', ones(11,1), 1), "uniformoutput", false)';
-%!  s = struct ([keys; vals]{:});
-%!  t = cell2struct ([vals{:}], keys, 2);
-%!  assert (s, t);
-%!  assert (struct2cell (s), [vals{:}]');
-%!  assert (fieldnames (s), keys');
+%! keys = cellstr (char (floor (rand (11,10)*24+65)))';
+%! vals = cellfun (@(x) mat2cell (rand (19,1), ones (19,1), 1), ...
+%!          mat2cell ([1:11]', ones (11,1), 1), "uniformoutput", false)';
+%! s = struct ([keys; vals]{:});
+%! t = cell2struct ([vals{:}], keys, 2);
+%! assert (s, t);
+%! assert (struct2cell (s), [vals{:}]');
+%! assert (fieldnames (s), keys');
 */
 
 mxArray *
 octave_cell::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (dims ());
 
   mxArray **elts = static_cast<mxArray **> (retval->get_data ());
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -1283,50 +1283,48 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
   H5Gclose (group_hid);
 
   return success;
 }
 
 #endif
 
 /*
-
 %!test
 %! a = 2;
 %! f = @(x) a + x;
 %! g = @(x) 2 * x;
 %! hm = @version;
 %! hdld = @svd;
 %! hbi = @log2;
 %! f2 = f;
 %! g2 = g;
 %! hm2 = hm;
 %! hdld2 = hdld;
 %! hbi2 = hbi;
 %! modes = {"-text", "-binary"};
-%! if (!isempty(findstr(octave_config_info ("DEFS"),"HAVE_HDF5")))
+%! if (!isempty (findstr (octave_config_info ("DEFS"), "HAVE_HDF5")))
 %!   modes(end+1) = "-hdf5";
 %! endif
 %! for i = 1:numel (modes)
 %!   mode = modes{i};
-%!   nm = tmpnam();
+%!   nm = tmpnam ();
 %!   unwind_protect
 %!     save (mode, nm, "f2", "g2", "hm2", "hdld2", "hbi2");
 %!     clear f2 g2 hm2 hdld2 hbi2
 %!     load (nm);
-%!     assert (f(2),f2(2));
-%!     assert (g(2),g2(2));
-%!     assert (g(3),g2(3));
+%!     assert (f (2), f2 (2));
+%!     assert (g (2), g2 (2));
+%!     assert (g (3), g2 (3));
 %!     unlink (nm);
 %!     save (mode, nm, "f2", "g2", "hm2", "hdld2", "hbi2");
 %!   unwind_protect_cleanup
 %!     unlink (nm);
 %!   end_unwind_protect
 %! endfor
-
 */
 
 void
 octave_fcn_handle::print (std::ostream& os, bool pr_as_read_syntax) const
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
@@ -1587,17 +1585,17 @@ make_fcn_handle (const std::string& nm, 
 %!      "/", "mrdivide";
 %!      "^", "mpower";
 %!      "\\", "mldivide";
 %!      "<", "lt";
 %!      ">", "gt";
 %!      "&", "and";
 %!      "|", "or"};
 %! for i = 1:rows (x)
-%!   assert (functions (str2func (x{i,1})).function, x{i,2})
+%!   assert (functions (str2func (x{i,1})).function, x{i,2});
 %! endfor
 */
 
 DEFUN (functions, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} functions (@var{fcn_handle})\n\
 Return a struct containing information about the function handle\n\
 @var{fcn_handle}.\n\
@@ -1754,31 +1752,29 @@ are ignored in the lookup.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
 %!function y = __testrecursionfunc (f, x, n)
 %!  if (nargin < 3)
 %!    n = 0;
 %!  endif
 %!  if (n > 2)
 %!    y = f (x);
 %!  else
 %!    n++;
-%!    y = __testrecursionfunc (@(x) f(2*x), x, n);
+%!    y = __testrecursionfunc (@(x) f (2*x), x, n);
 %!  endif
 %!endfunction
 %!
 %!assert (__testrecursionfunc (@(x) x, 1), 8)
-
 */
 
 DEFUN (is_function_handle, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_function_handle (@var{x})\n\
 Return true if @var{x} is a function handle.\n\
 @seealso{isa, typeinfo, class}\n\
 @end deftypefn")
@@ -1797,22 +1793,21 @@ Return true if @var{x} is a function han
 
 /*
 %!shared fh
 %! fh = @(x) x;
 
 %!assert (is_function_handle (fh))
 %!assert (! is_function_handle ({fh}))
 %!assert (! is_function_handle (1))
-%!error is_function_handle ();
-%!error is_function_handle (1, 2);
 
+%!error is_function_handle ()
+%!error is_function_handle (1, 2)
 */
 
-
 octave_fcn_binder::octave_fcn_binder (const octave_value& f,
                                       const octave_value& root,
                                       const octave_value_list& templ,
                                       const std::vector<int>& mask,
                                       int exp_nargin)
 : octave_fcn_handle (f), root_handle (root), arg_template (templ),
   arg_mask (mask), expected_nargin (exp_nargin)
 {
diff --git a/src/ov-fcn-inline.cc b/src/ov-fcn-inline.cc
--- a/src/ov-fcn-inline.cc
+++ b/src/ov-fcn-inline.cc
@@ -820,19 +820,19 @@ If the second argument is an integer @va
   return retval;
 }
 
 /*
 %!shared fn
 %! fn = inline ("x.^2 + 1");
 %!assert (feval (fn, 6), 37)
 %!assert (fn (6), 37)
-%% FIXME: Need tests for other 2 calling forms of inline()
+## FIXME: Need tests for other 2 calling forms of inline()
 
-%% Test input validation 
+## Test input validation 
 %!error inline ()
 %!error <STR argument must be a string> inline (1)
 %!error <N must be an integer> inline ("2", ones (2,2))
 %!error <N must be a positive integer> inline ("2", -1)
 %!error <expecting string arguments> inline ("2", "x", -1, "y")
 */
 
 DEFUN (formula, args, ,
@@ -862,17 +862,17 @@ Note that @code{char (@var{fun})} is equ
 
   return retval;
 }
 
 /*
 %!assert (formula (fn), "x.^2 + 1")
 %!assert (formula (fn), char (fn))
 
-%% Test input validation
+## Test input validation
 %!error formula ()
 %!error formula (1, 2)
 %!error <FUN must be an inline function> formula (1)
 */
 
 DEFUN (argnames, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} argnames (@var{fun})\n\
@@ -909,17 +909,17 @@ the arguments of the inline function @va
   return retval;
 }
 
 /*
 %!assert (argnames (fn), {"x"})
 %!assert (argnames (inline ("1e-3*y + 2e4*z")), {"y"; "z"})
 %!assert (argnames (inline ("2", 2)), {"x"; "P1"; "P2"})
 
-%% Test input validation
+## Test input validation
 %!error argnames ()
 %!error argnames (1, 2)
 %!error <FUN must be an inline function> argnames (1)
 */
 
 DEFUN (vectorize, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} vectorize (@var{fun})\n\
@@ -1007,14 +1007,13 @@ quadv (fcn, 0, 3)\n\
 /*
 %!assert (char (vectorize (fn)), "x.^2 + 1")
 %!assert (char (vectorize (inline ("1e-3*y + 2e4*z"))), "1e-3.*y + 2e4.*z")
 %!assert (char (vectorize (inline ("2**x^5"))), "2.**x.^5")
 %!assert (vectorize ("x.^2 + 1"), "x.^2 + 1")
 %!assert (vectorize ("1e-3*y + 2e4*z"), "1e-3.*y + 2e4.*z")
 %!assert (vectorize ("2**x^5"), "2.**x.^5")
 
-%% Test input validation
+## Test input validation
 %!error vectorize ()
 %!error vectorize (1, 2)
 %!error <FUN must be a string or inline function> vectorize (1)
 */
-
diff --git a/src/ov-flt-re-mat.cc b/src/ov-flt-re-mat.cc
--- a/src/ov-flt-re-mat.cc
+++ b/src/ov-flt-re-mat.cc
@@ -836,17 +836,16 @@ Convert @var{x} to single precision type
     }
   else
     print_usage ();
 
   return octave_value ();
 }
 
 /*
-
 %!assert (class (single(1)), "single")
 %!assert (class (single(1 + i)), "single")
 %!assert (class (single (int8 (1))), "single")
 %!assert (class (single (uint8 (1))), "single")
 %!assert (class (single (int16 (1))), "single")
 %!assert (class (single (uint16 (1))), "single")
 %!assert (class (single (int32 (1))), "single")
 %!assert (class (single (uint32 (1))), "single")
@@ -860,11 +859,9 @@ Convert @var{x} to single precision type
 %! y = single (x);
 %! assert (class (x), "double");
 %! assert (class (y), "single");
 %!test
 %! x = diag ([i 3 2]);
 %! y = single (x);
 %! assert (class (x), "double");
 %! assert (class (y), "single");
-
 */
-
diff --git a/src/ov-int16.cc b/src/ov-int16.cc
--- a/src/ov-int16.cc
+++ b/src/ov-int16.cc
@@ -79,18 +79,15 @@ DEFUN (int16, args, ,
 @deftypefn {Built-in Function} {} int16 (@var{x})\n\
 Convert @var{x} to 16-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int16);
 }
 
 /*
-
 %!assert (class (int16 (1)), "int16")
 %!assert (int16 (1.25), int16 (1))
 %!assert (int16 (1.5), int16 (2))
 %!assert (int16 (-1.5), int16 (-2))
 %!assert (int16 (2^17), int16 (2^16-1))
 %!assert (int16 (-2^17), int16 (-2^16))
-
 */
-
diff --git a/src/ov-int32.cc b/src/ov-int32.cc
--- a/src/ov-int32.cc
+++ b/src/ov-int32.cc
@@ -79,18 +79,15 @@ DEFUN (int32, args, ,
 @deftypefn {Built-in Function} {} int32 (@var{x})\n\
 Convert @var{x} to 32-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int32);
 }
 
 /*
-
 %!assert (class (int32 (1)), "int32")
 %!assert (int32 (1.25), int32 (1))
 %!assert (int32 (1.5), int32 (2))
 %!assert (int32 (-1.5), int32 (-2))
 %!assert (int32 (2^33), int32 (2^32-1))
 %!assert (int32 (-2^33), int32 (-2^32))
-
 */
-
diff --git a/src/ov-int64.cc b/src/ov-int64.cc
--- a/src/ov-int64.cc
+++ b/src/ov-int64.cc
@@ -79,18 +79,15 @@ DEFUN (int64, args, ,
 @deftypefn {Built-in Function} {} int64 (@var{x})\n\
 Convert @var{x} to 64-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int64);
 }
 
 /*
-
 %!assert (class (int64 (1)), "int64")
 %!assert (int64 (1.25), int64 (1))
 %!assert (int64 (1.5), int64 (2))
 %!assert (int64 (-1.5), int64 (-2))
 %!assert (int64 (2^65), int64 (2^64-1))
 %!assert (int64 (-2^65), int64 (-2^64))
-
 */
-
diff --git a/src/ov-int8.cc b/src/ov-int8.cc
--- a/src/ov-int8.cc
+++ b/src/ov-int8.cc
@@ -79,17 +79,15 @@ DEFUN (int8, args, ,
 @deftypefn {Built-in Function} {} int8 (@var{x})\n\
 Convert @var{x} to 8-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (int8);
 }
 
 /*
-
 %!assert (class (int8 (1)), "int8")
 %!assert (int8 (1.25), int8 (1))
 %!assert (int8 (1.5), int8 (2))
 %!assert (int8 (-1.5), int8 (-2))
 %!assert (int8 (2^9), int8 (2^8-1))
 %!assert (int8 (-2^9), int8 (-2^8))
-
 */
diff --git a/src/ov-null-mat.cc b/src/ov-null-mat.cc
--- a/src/ov-null-mat.cc
+++ b/src/ov-null-mat.cc
@@ -115,21 +115,19 @@ This should give an error if @code{I} is
     retval = args(0).is_null_value ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
 %!assert (isnull ([]), true)
 %!assert (isnull ([1]), false)
 %!assert (isnull (zeros (0,3)), false)
 %!assert (isnull (""), true)
 %!assert (isnull ("A"), false)
 %!assert (isnull (''), true)
 %!assert (isnull ('A'), false)
 %!test
 %! x = [];
 %! assert (isnull (x), false);
-
 */
diff --git a/src/ov-oncleanup.cc b/src/ov-oncleanup.cc
--- a/src/ov-oncleanup.cc
+++ b/src/ov-oncleanup.cc
@@ -206,22 +206,20 @@ For similar functionality @xref{The @cod
     retval = octave_value (new octave_oncleanup (args(0)));
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
 %!test
 %! old_wstate = warning ("query");
 %! unwind_protect
 %!   trigger = onCleanup (@() warning ("on", "__MY_WARNING__"));
 %!   warning ("off", "__MY_WARNING__");
 %!   assert ((warning ("query", "__MY_WARNING__")).state, "off");
-%!   clear trigger
+%!   clear trigger;
 %!   assert ((warning ("query", "__MY_WARNING__")).state, "on");
 %! unwind_protect_cleanup
 %!   warning (old_wstate);
 %! end_unwind_protect
-
 */
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -665,17 +665,17 @@ variable value is restored when exiting 
 
 /*
 %!test
 %! x = 0:10;
 %! save = allow_noninteger_range_as_index ();
 %! warn_state = warning ("query", "Octave:noninteger-range-as-index");
 %! unwind_protect
 %!   allow_noninteger_range_as_index (false);
-%!   fail ('x(2.1:5)');
+%!   fail ("x(2.1:5)");
 %!   assert (x(2:5), 1:4);
 %!   allow_noninteger_range_as_index (true);
 %!   warning ("off", "Octave:noninteger-range-as-index");
 %!   assert (x(2.49:5), 1:3);
 %!   assert (x(2.5:5), 2:4);
 %!   assert (x(2.51:5), 2:4);
 %! unwind_protect_cleanup
 %!   allow_noninteger_range_as_index (save);
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -976,17 +976,16 @@ Convert @var{x} to double precision type
     }
   else
     print_usage ();
 
   return octave_value ();
 }
 
 /*
-
 %!assert (class (double (single (1))), "double")
 %!assert (class (double (single (1 + i))), "double")
 %!assert (class (double (int8 (1))), "double")
 %!assert (class (double (uint8 (1))), "double")
 %!assert (class (double (int16 (1))), "double")
 %!assert (class (double (uint16 (1))), "double")
 %!assert (class (double (int32 (1))), "double")
 %!assert (class (double (uint32 (1))), "double")
@@ -1005,10 +1004,9 @@ Convert @var{x} to double precision type
 %! y = double (x);
 %! assert (class (x), "single");
 %! assert (class (y), "double");
 %!test
 %! x = diag (single ([i 3 2]));
 %! y = double (x);
 %! assert (class (x), "single");
 %! assert (class (y), "double");
-
 */
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -244,17 +244,18 @@ octave_struct::subsref (const std::strin
   if (idx.size () > 1)
     retval = retval.next_subsref (auto_add, type, idx, skip);
 
   return retval;
 }
 
 /*
 %!test
-%! x(1).a.a = 1; x(2).a.a = 2;
+%! x(1).a.a = 1;
+%! x(2).a.a = 2;
 %! assert (size (x), [1, 2]);
 %! assert (x(1).a.a, 1);
 %! assert (x(2).a.a, 2);
 */
 
 octave_value
 octave_struct::numeric_conv (const octave_value& val,
                              const std::string& type)
@@ -686,35 +687,16 @@ octave_struct::print_name_tag (std::ostr
 }
 
 static bool
 scalar (const dim_vector& dims)
 {
   return dims.length () == 2 && dims (0) == 1 && dims (1) == 1;
 }
 
-/*
-%!shared x
-%! x(1).a=1; x(2).a=2; x(1).b=3; x(2).b=3;
-%!assert(struct('a',1,'b',3),x(1))
-%!assert(isempty(x([])))
-%!assert(isempty(struct('a',{},'b',{})))
-%!assert(struct('a',{1,2},'b',{3,3}),x)
-%!assert(struct('a',{1,2},'b',3),x)
-%!assert(struct('a',{1,2},'b',{3}),x)
-%!assert(struct('b',3,'a',{1,2}),x)
-%!assert(struct('b',{3},'a',{1,2}),x)
-%!test x=struct([]);
-%!assert(size(x),[0,0]);
-%!assert(isstruct(x));
-%!assert(isempty(fieldnames(x)));
-%!fail("struct('a',{1,2},'b',{1,2,3})","dimensions of parameter 2 do not match those of parameter 4")
-%!fail("struct(1,2,3,4)","struct: expecting alternating \"field\", VALUE pairs");
-%!fail("struct('1',2,'3')","struct: expecting alternating \"field\", VALUE pairs");
-*/
 
 bool
 octave_struct::save_ascii (std::ostream& os)
 {
   octave_map m = map_value ();
 
   octave_idx_type nf = m.nfields ();
 
@@ -1184,17 +1166,18 @@ octave_scalar_struct::subsref (const std
   else
     retval = to_array ().subsref (type, idx, auto_add);
 
   return retval;
 }
 
 /*
 %!test
-%! x(1).a.a = 1; x(2).a.a = 2;
+%! x(1).a.a = 1;
+%! x(2).a.a = 2;
 %! assert (size (x), [1, 2]);
 %! assert (x(1).a.a, 1);
 %! assert (x(2).a.a, 2);
 */
 
 octave_value
 octave_scalar_struct::numeric_conv (const octave_value& val,
                                     const std::string& type)
@@ -1707,35 +1690,16 @@ octave_scalar_struct::fast_elem_insert_s
   if (btyp == btyp_struct)
     {
       *(reinterpret_cast<const octave_scalar_map **>(where)) = &map;
       return true;
     }
   else
     return false;
 }
-/*
-%!shared x
-%! x(1).a=1; x(2).a=2; x(1).b=3; x(2).b=3;
-%!assert(struct('a',1,'b',3),x(1))
-%!assert(isempty(x([])))
-%!assert(isempty(struct('a',{},'b',{})))
-%!assert(struct('a',{1,2},'b',{3,3}),x)
-%!assert(struct('a',{1,2},'b',3),x)
-%!assert(struct('a',{1,2},'b',{3}),x)
-%!assert(struct('b',3,'a',{1,2}),x)
-%!assert(struct('b',{3},'a',{1,2}),x)
-%!test x=struct([]);
-%!assert(size(x),[0,0]);
-%!assert(isstruct(x));
-%!assert(isempty(fieldnames(x)));
-%!fail("struct('a',{1,2},'b',{1,2,3})","dimensions of parameter 2 do not match those of parameter 4")
-%!fail("struct(1,2,3,4)","struct: expecting alternating \"field\", VALUE pairs");
-%!fail("struct('1',2,'3')","struct: expecting alternating \"field\", VALUE pairs");
-*/
 
 DEFUN (struct, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} struct (\"field\", @var{value}, \"field\", @var{value}, @dots{})\n\
 \n\
 Create a structure and initialize its value.\n\
 \n\
 If the values are cell arrays, create a structure array and initialize\n\
@@ -1869,16 +1833,36 @@ If the argument is an object, return the
 
       if (error_state)
         return retval;
     }
 
   return octave_value (map);
 }
 
+/*
+%!shared x
+%! x(1).a=1;  x(2).a=2;  x(1).b=3;  x(2).b=3;
+%!assert (struct ("a",1, "b",3), x(1))
+%!assert (isempty (x([])))
+%!assert (isempty (struct ("a",{}, "b",{})))
+%!assert (struct ("a",{1,2}, "b",{3,3}), x)
+%!assert (struct ("a",{1,2}, "b",3), x)
+%!assert (struct ("a",{1,2}, "b",{3}), x)
+%!assert (struct ("b",3, "a",{1,2}), x)
+%!assert (struct ("b",{3}, "a",{1,2}), x)
+%!test x = struct ([]);
+%!assert (size (x), [0,0])
+%!assert (isstruct (x))
+%!assert (isempty (fieldnames (x)))
+%!fail ('struct ("a",{1,2},"b",{1,2,3})', 'dimensions of parameter 2 do not match those of parameter 4')
+%!fail ('struct (1,2,3,4)', 'struct: expecting alternating "field", VALUE pairs')
+%!fail ('struct ("1",2,"3")', 'struct: expecting alternating "field", VALUE pairs')
+*/
+
 DEFUN (isstruct, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isstruct (@var{x})\n\
 Return true if @var{x} is a structure or a structure array.\n\
 @seealso{ismatrix, iscell, isa}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -1923,20 +1907,20 @@ argument that is not a structure.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!# test preservation of fieldname order
+## test preservation of fieldname order
 %!test
-%!  x(3).d=1; x(2).a=2; x(1).b=3; x(2).c=3;
-%!  assert(fieldnames(x), {"d"; "a"; "b"; "c"});
+%! x(3).d=1;  x(2).a=2; x(1).b=3;  x(2).c=3;
+%! assert (fieldnames (x), {"d"; "a"; "b"; "c"});
 */
 
 DEFUN (isfield, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isfield (@var{x}, @var{name})\n\
 Return true if the @var{x} is a structure and it\n\
 includes an element named @var{name}.  If @var{name} is a cell\n\
 array of strings then a logical array of equal dimension is returned.\n\
@@ -2007,25 +1991,25 @@ Return the number of fields of the struc
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!# test isfield
+## test isfield
 %!test
-%!  x(3).d=1; x(2).a=2; x(1).b=3; x(2).c=3;
-%!  assert (isfield (x, 'b'));
-%!assert (isfield (struct('a', '1'), 'a'));
-%!assert (isfield ({1}, 'c'), false);
-%!assert (isfield (struct('a', '1'), 10), false);
-%!assert (isfield (struct('a', 'b'), "a "), false);
-%!assert (isfield (struct('a', 1, 'b', 2), {'a', 'c'}), [true, false]);
+%! x(3).d=1;  x(2).a=2;  x(1).b=3;  x(2).c=3;
+%! assert (isfield (x, "b"));
+%!assert (isfield (struct("a", "1"), "a"))
+%!assert (isfield ({1}, "c"), false)
+%!assert (isfield (struct("a", "1"), 10), false)
+%!assert (isfield (struct("a", "b"), "a "), false)
+%!assert (isfield (struct("a", 1, "b", 2), {"a", "c"}), [true, false])
 */
 
 DEFUN (cell2struct, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} cell2struct (@var{cell}, @var{fields}, @var{dim})\n\
 Convert @var{cell} to a structure.  The number of fields in @var{fields}\n\
 must match the number of elements in @var{cell} along dimension @var{dim},\n\
 that is @code{numel (@var{fields}) == size (@var{cell}, @var{dim})}.\n\
@@ -2133,25 +2117,25 @@ A(1)\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!# test cell2struct versus struct2cell
+## test cell2struct versus struct2cell
 %!test
-%!  keys = cellstr (char (floor (rand (100,10)*24+65)))';
-%!  vals = mat2cell(rand (100,1), ones (100,1), 1)';
-%!  s = struct ([keys; vals]{:});
-%!  t = cell2struct (vals, keys, 2);
-%!  assert (s, t);
-%!  assert (struct2cell (s), vals');
-%!  assert (fieldnames (s), keys');
+%! keys = cellstr (char (floor (rand (100,10)*24+65)))';
+%! vals = mat2cell (rand (100,1), ones (100,1), 1)';
+%! s = struct ([keys; vals]{:});
+%! t = cell2struct (vals, keys, 2);
+%! assert (s, t);
+%! assert (struct2cell (s), vals');
+%! assert (fieldnames (s), keys');
 
 %!assert (cell2struct ({1; 2}, {"a"; "b"}), struct ("a", 1, "b", 2));
 */
 
 
 // So we can call Fcellstr directly.
 extern octave_value_list Fcellstr (const octave_value_list& args, int);
 
@@ -2199,22 +2183,22 @@ the named fields.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!# test rmfield
+## test rmfield
 %!test
-%!  x(3).d=1; x(2).a=2; x(1).b=3; x(2).c=3; x(6).f="abc123";
-%!  y = rmfield (x, {"a", "f"});
-%!  assert (fieldnames (y), {"d"; "b"; "c"});
-%!  assert (size (y), [1, 6]);
+%! x(3).d=1;  x(2).a=2;  x(1).b=3;  x(2).c=3;  x(6).f="abc123";
+%! y = rmfield (x, {"a", "f"});
+%! assert (fieldnames (y), {"d"; "b"; "c"});
+%! assert (size (y), [1, 6]);
 */
 
 DEFUN (struct_levels_to_print, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} struct_levels_to_print ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} struct_levels_to_print (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} struct_levels_to_print (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the number of\n\
diff --git a/src/ov-typeinfo.cc b/src/ov-typeinfo.cc
--- a/src/ov-typeinfo.cc
+++ b/src/ov-typeinfo.cc
@@ -615,77 +615,93 @@ currently installed data types.\n\
     retval = args(0).type_name ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error typeinfo ("foo", 1);
+%!assert (iscellstr (typeinfo ()))
 
-%!assert (iscellstr (typeinfo ()));
+%!assert (typeinfo ({"cell"}), "cell")
 
-%!assert (typeinfo (false), "bool");
-%!assert (typeinfo ([true, false]), "bool matrix");
-
-%!assert (typeinfo (1:2), "range");
+%!assert (typeinfo (1), "scalar")
+%!assert (typeinfo (double (1)), "scalar")
+%!assert (typeinfo (i), "complex scalar")
 
-%!assert (typeinfo ("string"), "string");
-%!assert (typeinfo ('string'), "sq_string");
-
+%!assert (typeinfo ([1, 2]), "matrix")
+%!assert (typeinfo (double ([1, 2])), "matrix")
 %!assert (typeinfo (diag ([1, 2])), "diagonal matrix")
+%!assert (typeinfo ([i, 2]), "complex matrix")
 %!assert (typeinfo (diag ([i, 2])), "complex diagonal matrix")
-%!assert (typeinfo (single (diag ([1, 2]))), "float diagonal matrix")
-%!assert (typeinfo (single (diag ([i, 2]))), "float complex diagonal matrix")
-%!assert (typeinfo (diag (single ([1, 2]))), "float diagonal matrix")
-%!assert (typeinfo (diag (single ([i, 2]))), "float complex diagonal matrix")
+
+%!assert (typeinfo (1:2), "range")
 
-%!assert (typeinfo ([]), "null_matrix");
-%!assert (typeinfo (""), "null_string");
-%!assert (typeinfo (''), "null_sq_string");
+%!assert (typeinfo (false), "bool")
+%!assert (typeinfo ([true, false]), "bool matrix")
+
+%!assert (typeinfo ("string"), "string")
+%!assert (typeinfo ('string'), "sq_string")
 
-%!assert (typeinfo (1), "scalar");
-%!assert (typeinfo (double (1)), "scalar");
-%!assert (typeinfo ([1, 2]), "matrix");
-%!assert (typeinfo (double ([1, 2])), "matrix");
-
-%!assert (typeinfo (i), "complex scalar");
-%!assert (typeinfo ([i, 2]), "complex matrix");
-
-%!assert (typeinfo (single (1)), "float scalar");
-%!assert (typeinfo (single ([1, 2])), "float matrix");
+%!assert (typeinfo (int8 (1)), "int8 scalar")
+%!assert (typeinfo (int16 (1)), "int16 scalar")
+%!assert (typeinfo (int32 (1)), "int32 scalar")
+%!assert (typeinfo (int64 (1)), "int64 scalar")
+%!assert (typeinfo (uint8 (1)), "uint8 scalar")
+%!assert (typeinfo (uint16 (1)), "uint16 scalar")
+%!assert (typeinfo (uint32 (1)), "uint32 scalar")
+%!assert (typeinfo (uint64 (1)), "uint64 scalar")
 
-%!assert (typeinfo (single (i)), "float complex scalar");
-%!assert (typeinfo (single ([i, 2])), "float complex matrix");
-
-%!assert (typeinfo (sparse (eye (10))), "sparse matrix");
-%!assert (typeinfo (sparse (i * eye (10))), "sparse complex matrix");
-%!assert (typeinfo (logical (sparse (i * eye (10)))), "sparse bool matrix");
+%!assert (typeinfo (int8 ([1,2])), "int8 matrix")
+%!assert (typeinfo (int16 ([1,2])), "int16 matrix")
+%!assert (typeinfo (int32 ([1,2])), "int32 matrix")
+%!assert (typeinfo (int64 ([1,2])), "int64 matrix")
+%!assert (typeinfo (uint8 ([1,2])), "uint8 matrix")
+%!assert (typeinfo (uint16 ([1,2])), "uint16 matrix")
+%!assert (typeinfo (uint32 ([1,2])), "uint32 matrix")
+%!assert (typeinfo (uint64 ([1,2])), "uint64 matrix")
 
-%!assert (typeinfo (int8 (1)), "int8 scalar");
-%!assert (typeinfo (int16 (1)), "int16 scalar");
-%!assert (typeinfo (int32 (1)), "int32 scalar");
-%!assert (typeinfo (int64 (1)), "int64 scalar");
-%!assert (typeinfo (uint8 (1)), "uint8 scalar");
-%!assert (typeinfo (uint16 (1)), "uint16 scalar");
-%!assert (typeinfo (uint32 (1)), "uint32 scalar");
-%!assert (typeinfo (uint64 (1)), "uint64 scalar");
+%!assert (typeinfo (sparse ([true, false])), "sparse bool matrix")
+%!assert (typeinfo (logical (sparse (i * eye (10)))), "sparse bool matrix")
+%!assert (typeinfo (sparse ([1,2])), "sparse matrix")
+%!assert (typeinfo (sparse (eye (10))), "sparse matrix")
+%!assert (typeinfo (sparse ([i,2])), "sparse complex matrix")
+%!assert (typeinfo (sparse (i * eye (10))), "sparse complex matrix")
+
+%!test
+%! s(2).a = 1;
+%! assert (typeinfo (s), "struct");
 
 %!test
 %! s.a = 1;
 %! assert (typeinfo (s), "scalar struct");
 
-%!test
-%! s(2).a = 1;
-%! assert (typeinfo (s), "struct");
+## FIXME: This doesn't work as a test for comma-separated list
+%!#test
+%! clist = {1, 2, 3};
+%! assert (typeinfo (clist{:}), "cs-list");
 
-%!assert (typeinfo ({"cell"}), "cell");
+%!assert (typeinfo (@sin), "function handle")
+%!assert (typeinfo (@(x) x), "function handle")
+
+%!assert (typeinfo (inline ("x^2")), "inline function")
 
-%!assert (typeinfo (@sin), "function handle");
-%!assert (typeinfo (@(x) x), "function handle");
+%!assert (typeinfo (single (1)), "float scalar")
+%!assert (typeinfo (single (i)), "float complex scalar")
+%!assert (typeinfo (single ([1, 2])), "float matrix")
 
-%!assert (typeinfo (inline ('x^2')), "inline function");
+%!assert (typeinfo (single (diag ([1, 2]))), "float diagonal matrix")
+%!assert (typeinfo (diag (single ([1, 2]))), "float diagonal matrix")
+%!assert (typeinfo (single (diag ([i, 2]))), "float complex diagonal matrix")
+%!assert (typeinfo (diag (single ([i, 2]))), "float complex diagonal matrix")
 
+%!assert (typeinfo (eye(3)(:,[1 3 2])), "permutation matrix")
 %!test
 %! [l, u, p] = lu (rand (3));
 %! assert (typeinfo (p), "permutation matrix");
+
+%!assert (typeinfo ([]), "null_matrix")
+%!assert (typeinfo (""), "null_string")
+%!assert (typeinfo (''), "null_sq_string")
+
+%!error typeinfo ("foo", 1)
 */
diff --git a/src/ov-uint16.cc b/src/ov-uint16.cc
--- a/src/ov-uint16.cc
+++ b/src/ov-uint16.cc
@@ -79,18 +79,15 @@ DEFUN (uint16, args, ,
 @deftypefn {Built-in Function} {} uint16 (@var{x})\n\
 Convert @var{x} to unsigned 16-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint16);
 }
 
 /*
-
 %!assert (class (uint16 (1)), "uint16")
 %!assert (uint16 (1.25), uint16 (1))
 %!assert (uint16 (1.5), uint16 (2))
 %!assert (uint16 (-1.5), uint16 (0))
 %!assert (uint16 (2^17), uint16 (2^16-1))
 %!assert (uint16 (-2^17), uint16 (0))
-
 */
-
diff --git a/src/ov-uint32.cc b/src/ov-uint32.cc
--- a/src/ov-uint32.cc
+++ b/src/ov-uint32.cc
@@ -79,17 +79,15 @@ DEFUN (uint32, args, ,
 @deftypefn {Built-in Function} {} uint32 (@var{x})\n\
 Convert @var{x} to unsigned 32-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint32);
 }
 
 /*
-
 %!assert (class (uint32 (1)), "uint32")
 %!assert (uint32 (1.25), uint32 (1))
 %!assert (uint32 (1.5), uint32 (2))
 %!assert (uint32 (-1.5), uint32 (0))
 %!assert (uint32 (2^33), uint32 (2^32-1))
 %!assert (uint32 (-2^33), uint32 (0))
-
 */
diff --git a/src/ov-uint64.cc b/src/ov-uint64.cc
--- a/src/ov-uint64.cc
+++ b/src/ov-uint64.cc
@@ -79,17 +79,15 @@ DEFUN (uint64, args, ,
 @deftypefn {Built-in Function} {} uint64 (@var{x})\n\
 Convert @var{x} to unsigned 64-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint64);
 }
 
 /*
-
 %!assert (class (uint64 (1)), "uint64")
 %!assert (uint64 (1.25), uint64 (1))
 %!assert (uint64 (1.5), uint64 (2))
 %!assert (uint64 (-1.5), uint64 (0))
 %!assert (uint64 (2^65), uint64 (2^64-1))
 %!assert (uint64 (-2^65), uint64 (0))
-
 */
diff --git a/src/ov-uint8.cc b/src/ov-uint8.cc
--- a/src/ov-uint8.cc
+++ b/src/ov-uint8.cc
@@ -79,17 +79,15 @@ DEFUN (uint8, args, ,
 @deftypefn {Built-in Function} {} uint8 (@var{x})\n\
 Convert @var{x} to unsigned 8-bit integer type.\n\
 @end deftypefn")
 {
   OCTAVE_TYPE_CONV_BODY (uint8);
 }
 
 /*
-
 %!assert (class (uint8 (1)), "uint8")
 %!assert (uint8 (1.25), uint8 (1))
 %!assert (uint8 (1.5), uint8 (2))
 %!assert (uint8 (-1.5), uint8 (0))
 %!assert (uint8 (2^9), uint8 (2^8-1))
 %!assert (uint8 (-2^9), uint8 (0))
-
 */
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -2939,17 +2939,17 @@ and @samp{subs}, return @var{rhs}.\n\
 %! a = subsasgn (a, idx2, 0);
 %! a = subsasgn (a, idx3, 0);
 %!# a = subsasgn (a, idx4, 0);
 %! b = [0    6   11   16    0
 %!      0    0   12    0    0
 %!      0    8    0   18    0
 %!      0    0   14    0    0
 %!      0   10   15   20    0];
-%! assert (a,b);
+%! assert (a, b);
 
 %!test
 %! c = num2cell (reshape ([1:25],5,5));
 %! idx1 = substruct  ("{}", {3, 3});
 %! idx2 = substruct  ("()", {2:2:5, 2:2:5});
 %! idx3 = substruct  ("()", {":", [1,5]});
 %! idx2p = substruct ("{}", {2:2:5, 2:2:5});
 %! idx3p = substruct ("{}", {":", [1,5]});
@@ -2984,17 +2984,16 @@ and @samp{subs}, return @var{rhs}.\n\
 %! s = subsasgn (s, idx1, "Hello");
 %! s = subsasgn (s, idx2, "There");
 %! s = subsasgn (s, idx3, 163);
 %!# s = subsasgn (s, idx4, 163);
 %! t.a = "Hello";
 %! t.b = "There";
 %! t.c = 163;
 %! assert (s, t);
-
 */
 
 DEFUN (is_sq_string, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_sq_string (@var{x})\n\
 Return true if @var{x} is a single-quoted character string.\n\
 @seealso{is_dq_string, ischar}\n\
 @end deftypefn")
@@ -3005,20 +3004,21 @@ Return true if @var{x} is a single-quote
     retval = args(0).is_sq_string ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert (is_sq_string ('foo'), true);
-%!assert (is_sq_string ("foo"), false);
-%!assert (is_sq_string (1.0), false);
-%!assert (is_sq_string ({2.0}), false);
+%!assert (is_sq_string ('foo'), true)
+%!assert (is_sq_string ("foo"), false)
+%!assert (is_sq_string (1.0), false)
+%!assert (is_sq_string ({2.0}), false)
+
 %!error is_sq_string ()
 %!error is_sq_string ('foo', 2)
 */
 
 DEFUN (is_dq_string, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_dq_string (@var{x})\n\
 Return true if @var{x} is a double-quoted character string.\n\
@@ -3031,15 +3031,16 @@ Return true if @var{x} is a double-quote
     retval = args(0).is_dq_string ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert (is_dq_string ("foo"), true);
-%!assert (is_dq_string ('foo'), false);
-%!assert (is_dq_string (1.0), false);
-%!assert (is_dq_string ({2.0}), false);
+%!assert (is_dq_string ("foo"), true)
+%!assert (is_dq_string ('foo'), false)
+%!assert (is_dq_string (1.0), false)
+%!assert (is_dq_string ({2.0}), false)
+
 %!error is_dq_string ()
 %!error is_dq_string ("foo", 2)
 */
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -3550,22 +3550,22 @@ Note that the output from @code{fdisp} a
 
 %!test
 %! foo.real = pi * ones (3,20,3);
 %! foo.complex = pi * ones (3,20,3) + 1i;
 %! foo.char = repmat ("- Hello World -", [3, 20]);
 %! foo.cell = {foo.real, foo.complex, foo.char};
 %! fields = fieldnames (foo);
 %! for f = 1:numel(fields)
-%!   format loose
+%!   format loose;
 %!   loose = disp (foo.(fields{f}));
-%!   format compact
+%!   format compact;
 %!   compact = disp (foo.(fields{f}));
 %!   expected = strrep (loose, "\n\n", "\n");
-%!   assert (expected, compact)
+%!   assert (expected, compact);
 %! endfor
 */
 
 static void
 init_format_state (void)
 {
   free_format = false;
   plus_format = false;
diff --git a/src/pt-binop.cc b/src/pt-binop.cc
--- a/src/pt-binop.cc
+++ b/src/pt-binop.cc
@@ -297,22 +297,19 @@ When called from inside a function with 
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (do_braindead_shortcircuit_evaluation);
 }
 
 /*
-
 %!test
 %! x = 0;
 %! do_braindead_shortcircuit_evaluation (0);
 %! if (1 | (x = 1))
 %! endif
 %! assert (x, 1);
 %! do_braindead_shortcircuit_evaluation (1);
 %! if (1 | (x = 0))
 %! endif
 %! assert (x, 1);
-
 */
-
diff --git a/src/pt-eval.cc b/src/pt-eval.cc
--- a/src/pt-eval.cc
+++ b/src/pt-eval.cc
@@ -1202,24 +1202,25 @@ When called from inside a function with 
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (max_recursion_depth);
 }
 
 /*
-%!error (max_recursion_depth (1, 2));
 %!test
 %! orig_val = max_recursion_depth ();
 %! old_val = max_recursion_depth (2*orig_val);
 %! assert (orig_val, old_val);
 %! assert (max_recursion_depth (), 2*orig_val);
 %! max_recursion_depth (orig_val);
 %! assert (max_recursion_depth (), orig_val);
+
+%!error (max_recursion_depth (1, 2))
 */
 
 DEFUN (silent_functions, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} silent_functions ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} silent_functions (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} silent_functions (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether internal\n\
@@ -1231,17 +1232,18 @@ When called from inside a function with 
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (silent_functions);
 }
 
 /*
-%!error (silent_functions (1, 2));
 %!test
 %! orig_val = silent_functions ();
 %! old_val = silent_functions (! orig_val);
 %! assert (orig_val, old_val);
 %! assert (silent_functions (), ! orig_val);
 %! silent_functions (orig_val);
 %! assert (silent_functions (), orig_val);
+
+%!error (silent_functions (1, 2))
 */
diff --git a/src/pt-idx.cc b/src/pt-idx.cc
--- a/src/pt-idx.cc
+++ b/src/pt-idx.cc
@@ -596,23 +596,23 @@ tree_index_expression::lvalue (void)
 
     }
 
   return retval;
 }
 
 /*
 %!test
-%! clear x
-%! clear y
+%! clear x;
+%! clear y;
 %! y = 3;
 %! x(y(end)) = 1;
 %! assert (x, [0, 0, 1]);
-%! clear x
-%! clear y
+%! clear x;
+%! clear y;
 %! y = {3};
 %! x(y{end}) = 1;
 %! assert (x, [0, 0, 1]);
 
 %!test
 %! x = {1, 2, 3};
 %! [x{:}] = deal (4, 5, 6);
 %! assert (x, {4, 5, 6});
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -1188,208 +1188,208 @@ tree_matrix::dup (symbol_table::scope_id
 
 void
 tree_matrix::accept (tree_walker& tw)
 {
   tw.visit_matrix (*this);
 }
 
 /*
-%% test concatenation with all zero matrices
-%!assert([ '' 65*ones(1,10) ], 'AAAAAAAAAA');
-%!assert([ 65*ones(1,10) '' ], 'AAAAAAAAAA');
+## test concatenation with all zero matrices
+%!assert ([ "" 65*ones(1,10) ], "AAAAAAAAAA");
+%!assert ([ 65*ones(1,10) "" ], "AAAAAAAAAA");
 
 %!test
-%! c = {'foo'; 'bar'; 'bazoloa'};
-%! assert ([c; 'a'; 'bc'; 'def'], {'foo'; 'bar'; 'bazoloa'; 'a'; 'bc'; 'def'});
+%! c = {"foo"; "bar"; "bazoloa"};
+%! assert ([c; "a"; "bc"; "def"], {"foo"; "bar"; "bazoloa"; "a"; "bc"; "def"});
 
-%!assert (class ([int64(1), int64(1)]), 'int64')
-%!assert (class ([int64(1), int32(1)]), 'int64')
-%!assert (class ([int64(1), int16(1)]), 'int64')
-%!assert (class ([int64(1), int8(1)]), 'int64')
-%!assert (class ([int64(1), uint64(1)]), 'int64')
-%!assert (class ([int64(1), uint32(1)]), 'int64')
-%!assert (class ([int64(1), uint16(1)]), 'int64')
-%!assert (class ([int64(1), uint8(1)]), 'int64')
-%!assert (class ([int64(1), single(1)]), 'int64')
-%!assert (class ([int64(1), double(1)]), 'int64')
-%!assert (class ([int64(1), cell(1)]), 'cell')
-%!assert (class ([int64(1), true]), 'int64')
-%!assert (class ([int64(1), 'a']), 'char')
+%!assert (class ([int64(1), int64(1)]), "int64")
+%!assert (class ([int64(1), int32(1)]), "int64")
+%!assert (class ([int64(1), int16(1)]), "int64")
+%!assert (class ([int64(1), int8(1)]), "int64")
+%!assert (class ([int64(1), uint64(1)]), "int64")
+%!assert (class ([int64(1), uint32(1)]), "int64")
+%!assert (class ([int64(1), uint16(1)]), "int64")
+%!assert (class ([int64(1), uint8(1)]), "int64")
+%!assert (class ([int64(1), single(1)]), "int64")
+%!assert (class ([int64(1), double(1)]), "int64")
+%!assert (class ([int64(1), cell(1)]), "cell")
+%!assert (class ([int64(1), true]), "int64")
+%!assert (class ([int64(1), "a"]), "char")
 
-%!assert (class ([int32(1), int64(1)]), 'int32')
-%!assert (class ([int32(1), int32(1)]), 'int32')
-%!assert (class ([int32(1), int16(1)]), 'int32')
-%!assert (class ([int32(1), int8(1)]), 'int32')
-%!assert (class ([int32(1), uint64(1)]), 'int32')
-%!assert (class ([int32(1), uint32(1)]), 'int32')
-%!assert (class ([int32(1), uint16(1)]), 'int32')
-%!assert (class ([int32(1), uint8(1)]), 'int32')
-%!assert (class ([int32(1), single(1)]), 'int32')
-%!assert (class ([int32(1), double(1)]), 'int32')
-%!assert (class ([int32(1), cell(1)]), 'cell')
-%!assert (class ([int32(1), true]), 'int32')
-%!assert (class ([int32(1), 'a']), 'char')
+%!assert (class ([int32(1), int64(1)]), "int32")
+%!assert (class ([int32(1), int32(1)]), "int32")
+%!assert (class ([int32(1), int16(1)]), "int32")
+%!assert (class ([int32(1), int8(1)]), "int32")
+%!assert (class ([int32(1), uint64(1)]), "int32")
+%!assert (class ([int32(1), uint32(1)]), "int32")
+%!assert (class ([int32(1), uint16(1)]), "int32")
+%!assert (class ([int32(1), uint8(1)]), "int32")
+%!assert (class ([int32(1), single(1)]), "int32")
+%!assert (class ([int32(1), double(1)]), "int32")
+%!assert (class ([int32(1), cell(1)]), "cell")
+%!assert (class ([int32(1), true]), "int32")
+%!assert (class ([int32(1), "a"]), "char")
 
-%!assert (class ([int16(1), int64(1)]), 'int16')
-%!assert (class ([int16(1), int32(1)]), 'int16')
-%!assert (class ([int16(1), int16(1)]), 'int16')
-%!assert (class ([int16(1), int8(1)]), 'int16')
-%!assert (class ([int16(1), uint64(1)]), 'int16')
-%!assert (class ([int16(1), uint32(1)]), 'int16')
-%!assert (class ([int16(1), uint16(1)]), 'int16')
-%!assert (class ([int16(1), uint8(1)]), 'int16')
-%!assert (class ([int16(1), single(1)]), 'int16')
-%!assert (class ([int16(1), double(1)]), 'int16')
-%!assert (class ([int16(1), cell(1)]), 'cell')
-%!assert (class ([int16(1), true]), 'int16')
-%!assert (class ([int16(1), 'a']), 'char')
+%!assert (class ([int16(1), int64(1)]), "int16")
+%!assert (class ([int16(1), int32(1)]), "int16")
+%!assert (class ([int16(1), int16(1)]), "int16")
+%!assert (class ([int16(1), int8(1)]), "int16")
+%!assert (class ([int16(1), uint64(1)]), "int16")
+%!assert (class ([int16(1), uint32(1)]), "int16")
+%!assert (class ([int16(1), uint16(1)]), "int16")
+%!assert (class ([int16(1), uint8(1)]), "int16")
+%!assert (class ([int16(1), single(1)]), "int16")
+%!assert (class ([int16(1), double(1)]), "int16")
+%!assert (class ([int16(1), cell(1)]), "cell")
+%!assert (class ([int16(1), true]), "int16")
+%!assert (class ([int16(1), "a"]), "char")
 
-%!assert (class ([int8(1), int64(1)]), 'int8')
-%!assert (class ([int8(1), int32(1)]), 'int8')
-%!assert (class ([int8(1), int16(1)]), 'int8')
-%!assert (class ([int8(1), int8(1)]), 'int8')
-%!assert (class ([int8(1), uint64(1)]), 'int8')
-%!assert (class ([int8(1), uint32(1)]), 'int8')
-%!assert (class ([int8(1), uint16(1)]), 'int8')
-%!assert (class ([int8(1), uint8(1)]), 'int8')
-%!assert (class ([int8(1), single(1)]), 'int8')
-%!assert (class ([int8(1), double(1)]), 'int8')
-%!assert (class ([int8(1), cell(1)]), 'cell')
-%!assert (class ([int8(1), true]), 'int8')
-%!assert (class ([int8(1), 'a']), 'char')
+%!assert (class ([int8(1), int64(1)]), "int8")
+%!assert (class ([int8(1), int32(1)]), "int8")
+%!assert (class ([int8(1), int16(1)]), "int8")
+%!assert (class ([int8(1), int8(1)]), "int8")
+%!assert (class ([int8(1), uint64(1)]), "int8")
+%!assert (class ([int8(1), uint32(1)]), "int8")
+%!assert (class ([int8(1), uint16(1)]), "int8")
+%!assert (class ([int8(1), uint8(1)]), "int8")
+%!assert (class ([int8(1), single(1)]), "int8")
+%!assert (class ([int8(1), double(1)]), "int8")
+%!assert (class ([int8(1), cell(1)]), "cell")
+%!assert (class ([int8(1), true]), "int8")
+%!assert (class ([int8(1), "a"]), "char")
 
-%!assert (class ([uint64(1), int64(1)]), 'uint64')
-%!assert (class ([uint64(1), int32(1)]), 'uint64')
-%!assert (class ([uint64(1), int16(1)]), 'uint64')
-%!assert (class ([uint64(1), int8(1)]), 'uint64')
-%!assert (class ([uint64(1), uint64(1)]), 'uint64')
-%!assert (class ([uint64(1), uint32(1)]), 'uint64')
-%!assert (class ([uint64(1), uint16(1)]), 'uint64')
-%!assert (class ([uint64(1), uint8(1)]), 'uint64')
-%!assert (class ([uint64(1), single(1)]), 'uint64')
-%!assert (class ([uint64(1), double(1)]), 'uint64')
-%!assert (class ([uint64(1), cell(1)]), 'cell')
-%!assert (class ([uint64(1), true]), 'uint64')
-%!assert (class ([uint64(1), 'a']), 'char')
+%!assert (class ([uint64(1), int64(1)]), "uint64")
+%!assert (class ([uint64(1), int32(1)]), "uint64")
+%!assert (class ([uint64(1), int16(1)]), "uint64")
+%!assert (class ([uint64(1), int8(1)]), "uint64")
+%!assert (class ([uint64(1), uint64(1)]), "uint64")
+%!assert (class ([uint64(1), uint32(1)]), "uint64")
+%!assert (class ([uint64(1), uint16(1)]), "uint64")
+%!assert (class ([uint64(1), uint8(1)]), "uint64")
+%!assert (class ([uint64(1), single(1)]), "uint64")
+%!assert (class ([uint64(1), double(1)]), "uint64")
+%!assert (class ([uint64(1), cell(1)]), "cell")
+%!assert (class ([uint64(1), true]), "uint64")
+%!assert (class ([uint64(1), "a"]), "char")
 
-%!assert (class ([uint32(1), int64(1)]), 'uint32')
-%!assert (class ([uint32(1), int32(1)]), 'uint32')
-%!assert (class ([uint32(1), int16(1)]), 'uint32')
-%!assert (class ([uint32(1), int8(1)]), 'uint32')
-%!assert (class ([uint32(1), uint64(1)]), 'uint32')
-%!assert (class ([uint32(1), uint32(1)]), 'uint32')
-%!assert (class ([uint32(1), uint16(1)]), 'uint32')
-%!assert (class ([uint32(1), uint8(1)]), 'uint32')
-%!assert (class ([uint32(1), single(1)]), 'uint32')
-%!assert (class ([uint32(1), double(1)]), 'uint32')
-%!assert (class ([uint32(1), cell(1)]), 'cell')
-%!assert (class ([uint32(1), true]), 'uint32')
-%!assert (class ([uint32(1), 'a']), 'char')
+%!assert (class ([uint32(1), int64(1)]), "uint32")
+%!assert (class ([uint32(1), int32(1)]), "uint32")
+%!assert (class ([uint32(1), int16(1)]), "uint32")
+%!assert (class ([uint32(1), int8(1)]), "uint32")
+%!assert (class ([uint32(1), uint64(1)]), "uint32")
+%!assert (class ([uint32(1), uint32(1)]), "uint32")
+%!assert (class ([uint32(1), uint16(1)]), "uint32")
+%!assert (class ([uint32(1), uint8(1)]), "uint32")
+%!assert (class ([uint32(1), single(1)]), "uint32")
+%!assert (class ([uint32(1), double(1)]), "uint32")
+%!assert (class ([uint32(1), cell(1)]), "cell")
+%!assert (class ([uint32(1), true]), "uint32")
+%!assert (class ([uint32(1), "a"]), "char")
 
-%!assert (class ([uint16(1), int64(1)]), 'uint16')
-%!assert (class ([uint16(1), int32(1)]), 'uint16')
-%!assert (class ([uint16(1), int16(1)]), 'uint16')
-%!assert (class ([uint16(1), int8(1)]), 'uint16')
-%!assert (class ([uint16(1), uint64(1)]), 'uint16')
-%!assert (class ([uint16(1), uint32(1)]), 'uint16')
-%!assert (class ([uint16(1), uint16(1)]), 'uint16')
-%!assert (class ([uint16(1), uint8(1)]), 'uint16')
-%!assert (class ([uint16(1), single(1)]), 'uint16')
-%!assert (class ([uint16(1), double(1)]), 'uint16')
-%!assert (class ([uint16(1), cell(1)]), 'cell')
-%!assert (class ([uint16(1), true]), 'uint16')
-%!assert (class ([uint16(1), 'a']), 'char')
+%!assert (class ([uint16(1), int64(1)]), "uint16")
+%!assert (class ([uint16(1), int32(1)]), "uint16")
+%!assert (class ([uint16(1), int16(1)]), "uint16")
+%!assert (class ([uint16(1), int8(1)]), "uint16")
+%!assert (class ([uint16(1), uint64(1)]), "uint16")
+%!assert (class ([uint16(1), uint32(1)]), "uint16")
+%!assert (class ([uint16(1), uint16(1)]), "uint16")
+%!assert (class ([uint16(1), uint8(1)]), "uint16")
+%!assert (class ([uint16(1), single(1)]), "uint16")
+%!assert (class ([uint16(1), double(1)]), "uint16")
+%!assert (class ([uint16(1), cell(1)]), "cell")
+%!assert (class ([uint16(1), true]), "uint16")
+%!assert (class ([uint16(1), "a"]), "char")
 
-%!assert (class ([uint8(1), int64(1)]), 'uint8')
-%!assert (class ([uint8(1), int32(1)]), 'uint8')
-%!assert (class ([uint8(1), int16(1)]), 'uint8')
-%!assert (class ([uint8(1), int8(1)]), 'uint8')
-%!assert (class ([uint8(1), uint64(1)]), 'uint8')
-%!assert (class ([uint8(1), uint32(1)]), 'uint8')
-%!assert (class ([uint8(1), uint16(1)]), 'uint8')
-%!assert (class ([uint8(1), uint8(1)]), 'uint8')
-%!assert (class ([uint8(1), single(1)]), 'uint8')
-%!assert (class ([uint8(1), double(1)]), 'uint8')
-%!assert (class ([uint8(1), cell(1)]), 'cell')
-%!assert (class ([uint8(1), true]), 'uint8')
-%!assert (class ([uint8(1), 'a']), 'char')
+%!assert (class ([uint8(1), int64(1)]), "uint8")
+%!assert (class ([uint8(1), int32(1)]), "uint8")
+%!assert (class ([uint8(1), int16(1)]), "uint8")
+%!assert (class ([uint8(1), int8(1)]), "uint8")
+%!assert (class ([uint8(1), uint64(1)]), "uint8")
+%!assert (class ([uint8(1), uint32(1)]), "uint8")
+%!assert (class ([uint8(1), uint16(1)]), "uint8")
+%!assert (class ([uint8(1), uint8(1)]), "uint8")
+%!assert (class ([uint8(1), single(1)]), "uint8")
+%!assert (class ([uint8(1), double(1)]), "uint8")
+%!assert (class ([uint8(1), cell(1)]), "cell")
+%!assert (class ([uint8(1), true]), "uint8")
+%!assert (class ([uint8(1), "a"]), "char")
 
-%!assert (class ([single(1), int64(1)]), 'int64')
-%!assert (class ([single(1), int32(1)]), 'int32')
-%!assert (class ([single(1), int16(1)]), 'int16')
-%!assert (class ([single(1), int8(1)]), 'int8')
-%!assert (class ([single(1), uint64(1)]), 'uint64')
-%!assert (class ([single(1), uint32(1)]), 'uint32')
-%!assert (class ([single(1), uint16(1)]), 'uint16')
-%!assert (class ([single(1), uint8(1)]), 'uint8')
-%!assert (class ([single(1), single(1)]), 'single')
-%!assert (class ([single(1), double(1)]), 'single')
-%!assert (class ([single(1), cell(1)]), 'cell')
-%!assert (class ([single(1), true]), 'single')
-%!assert (class ([single(1), 'a']), 'char')
+%!assert (class ([single(1), int64(1)]), "int64")
+%!assert (class ([single(1), int32(1)]), "int32")
+%!assert (class ([single(1), int16(1)]), "int16")
+%!assert (class ([single(1), int8(1)]), "int8")
+%!assert (class ([single(1), uint64(1)]), "uint64")
+%!assert (class ([single(1), uint32(1)]), "uint32")
+%!assert (class ([single(1), uint16(1)]), "uint16")
+%!assert (class ([single(1), uint8(1)]), "uint8")
+%!assert (class ([single(1), single(1)]), "single")
+%!assert (class ([single(1), double(1)]), "single")
+%!assert (class ([single(1), cell(1)]), "cell")
+%!assert (class ([single(1), true]), "single")
+%!assert (class ([single(1), "a"]), "char")
 
-%!assert (class ([double(1), int64(1)]), 'int64')
-%!assert (class ([double(1), int32(1)]), 'int32')
-%!assert (class ([double(1), int16(1)]), 'int16')
-%!assert (class ([double(1), int8(1)]), 'int8')
-%!assert (class ([double(1), uint64(1)]), 'uint64')
-%!assert (class ([double(1), uint32(1)]), 'uint32')
-%!assert (class ([double(1), uint16(1)]), 'uint16')
-%!assert (class ([double(1), uint8(1)]), 'uint8')
-%!assert (class ([double(1), single(1)]), 'single')
-%!assert (class ([double(1), double(1)]), 'double')
-%!assert (class ([double(1), cell(1)]), 'cell')
-%!assert (class ([double(1), true]), 'double')
-%!assert (class ([double(1), 'a']), 'char')
+%!assert (class ([double(1), int64(1)]), "int64")
+%!assert (class ([double(1), int32(1)]), "int32")
+%!assert (class ([double(1), int16(1)]), "int16")
+%!assert (class ([double(1), int8(1)]), "int8")
+%!assert (class ([double(1), uint64(1)]), "uint64")
+%!assert (class ([double(1), uint32(1)]), "uint32")
+%!assert (class ([double(1), uint16(1)]), "uint16")
+%!assert (class ([double(1), uint8(1)]), "uint8")
+%!assert (class ([double(1), single(1)]), "single")
+%!assert (class ([double(1), double(1)]), "double")
+%!assert (class ([double(1), cell(1)]), "cell")
+%!assert (class ([double(1), true]), "double")
+%!assert (class ([double(1), "a"]), "char")
 
-%!assert (class ([cell(1), int64(1)]), 'cell')
-%!assert (class ([cell(1), int32(1)]), 'cell')
-%!assert (class ([cell(1), int16(1)]), 'cell')
-%!assert (class ([cell(1), int8(1)]), 'cell')
-%!assert (class ([cell(1), uint64(1)]), 'cell')
-%!assert (class ([cell(1), uint32(1)]), 'cell')
-%!assert (class ([cell(1), uint16(1)]), 'cell')
-%!assert (class ([cell(1), uint8(1)]), 'cell')
-%!assert (class ([cell(1), single(1)]), 'cell')
-%!assert (class ([cell(1), double(1)]), 'cell')
-%!assert (class ([cell(1), cell(1)]), 'cell')
-%!assert (class ([cell(1), true]), 'cell')
-%!assert (class ([cell(1), 'a']), 'cell')
+%!assert (class ([cell(1), int64(1)]), "cell")
+%!assert (class ([cell(1), int32(1)]), "cell")
+%!assert (class ([cell(1), int16(1)]), "cell")
+%!assert (class ([cell(1), int8(1)]), "cell")
+%!assert (class ([cell(1), uint64(1)]), "cell")
+%!assert (class ([cell(1), uint32(1)]), "cell")
+%!assert (class ([cell(1), uint16(1)]), "cell")
+%!assert (class ([cell(1), uint8(1)]), "cell")
+%!assert (class ([cell(1), single(1)]), "cell")
+%!assert (class ([cell(1), double(1)]), "cell")
+%!assert (class ([cell(1), cell(1)]), "cell")
+%!assert (class ([cell(1), true]), "cell")
+%!assert (class ([cell(1), "a"]), "cell")
 
-%!assert (class ([true, int64(1)]), 'int64')
-%!assert (class ([true, int32(1)]), 'int32')
-%!assert (class ([true, int16(1)]), 'int16')
-%!assert (class ([true, int8(1)]), 'int8')
-%!assert (class ([true, uint64(1)]), 'uint64')
-%!assert (class ([true, uint32(1)]), 'uint32')
-%!assert (class ([true, uint16(1)]), 'uint16')
-%!assert (class ([true, uint8(1)]), 'uint8')
-%!assert (class ([true, single(1)]), 'single')
-%!assert (class ([true, double(1)]), 'double')
-%!assert (class ([true, cell(1)]), 'cell')
-%!assert (class ([true, true]), 'logical')
-%!assert (class ([true, 'a']), 'char')
+%!assert (class ([true, int64(1)]), "int64")
+%!assert (class ([true, int32(1)]), "int32")
+%!assert (class ([true, int16(1)]), "int16")
+%!assert (class ([true, int8(1)]), "int8")
+%!assert (class ([true, uint64(1)]), "uint64")
+%!assert (class ([true, uint32(1)]), "uint32")
+%!assert (class ([true, uint16(1)]), "uint16")
+%!assert (class ([true, uint8(1)]), "uint8")
+%!assert (class ([true, single(1)]), "single")
+%!assert (class ([true, double(1)]), "double")
+%!assert (class ([true, cell(1)]), "cell")
+%!assert (class ([true, true]), "logical")
+%!assert (class ([true, "a"]), "char")
 
-%!assert (class (['a', int64(1)]), 'char')
-%!assert (class (['a', int32(1)]), 'char')
-%!assert (class (['a', int16(1)]), 'char')
-%!assert (class (['a', int8(1)]), 'char')
-%!assert (class (['a', int64(1)]), 'char')
-%!assert (class (['a', int32(1)]), 'char')
-%!assert (class (['a', int16(1)]), 'char')
-%!assert (class (['a', int8(1)]), 'char')
-%!assert (class (['a', single(1)]), 'char')
-%!assert (class (['a', double(1)]), 'char')
-%!assert (class (['a', cell(1)]), 'cell')
-%!assert (class (['a', true]), 'char')
-%!assert (class (['a', 'a']), 'char')
+%!assert (class (["a", int64(1)]), "char")
+%!assert (class (["a", int32(1)]), "char")
+%!assert (class (["a", int16(1)]), "char")
+%!assert (class (["a", int8(1)]), "char")
+%!assert (class (["a", int64(1)]), "char")
+%!assert (class (["a", int32(1)]), "char")
+%!assert (class (["a", int16(1)]), "char")
+%!assert (class (["a", int8(1)]), "char")
+%!assert (class (["a", single(1)]), "char")
+%!assert (class (["a", double(1)]), "char")
+%!assert (class (["a", cell(1)]), "cell")
+%!assert (class (["a", true]), "char")
+%!assert (class (["a", "a"]), "char")
 
-%!assert (class ([cell(1), struct('foo', 'bar')]), 'cell')
-%!error [struct('foo', 'bar'), cell(1)];
+%!assert (class ([cell(1), struct("foo", "bar")]), "cell")
+%!error [struct("foo", "bar"), cell(1)]
 */
 
 DEFUN (string_fill_char, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} string_fill_char ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} string_fill_char (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} string_fill_char (@var{new_val}, \"local\")\n\
 Query or set the internal variable used to pad all rows of a character\n\
@@ -1410,21 +1410,22 @@ When called from inside a function with 
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (string_fill_char);
 }
 
 /*
-%!error (string_fill_char (1, 2));
-%% string_fill_char() function call must be outside of %!test block
-%% due to the way a %!test block is wrapped inside a function
+## string_fill_char() function call must be outside of %!test block
+## due to the way a %!test block is wrapped inside a function
 %!shared orig_val, old_val
 %! orig_val = string_fill_char ();
 %! old_val  = string_fill_char ("X");
 %!test
 %! assert (orig_val, old_val);
 %! assert (string_fill_char (), "X");
 %! assert (["these"; "are"; "strings"], ["theseXX"; "areXXXX"; "strings"]);
 %! string_fill_char (orig_val);
 %! assert (string_fill_char (), orig_val);
+
+%!error (string_fill_char (1, 2))
 */
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -952,19 +952,20 @@ Return a structure containing Unix signa
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error SIG (1);
-%!assert (isstruct (SIG ()));
-%!assert (! isempty (SIG ()));
+%!assert (isstruct (SIG ()))
+%!assert (! isempty (SIG ()))
+
+%!error SIG (1)
 */
 
 DEFUN (debug_on_interrupt, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} debug_on_interrupt ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} debug_on_interrupt (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} debug_on_interrupt (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will try\n\
@@ -976,24 +977,25 @@ When called from inside a function with 
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (debug_on_interrupt);
 }
 
 /*
-%!error (debug_on_interrupt (1, 2));
 %!test
 %! orig_val = debug_on_interrupt ();
 %! old_val = debug_on_interrupt (! orig_val);
 %! assert (orig_val, old_val);
 %! assert (debug_on_interrupt (), ! orig_val);
 %! debug_on_interrupt (orig_val);
 %! assert (debug_on_interrupt (), orig_val);
+
+%!error (debug_on_interrupt (1, 2))
 */
 
 DEFUN (sighup_dumps_octave_core, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} sighup_dumps_octave_core ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} sighup_dumps_octave_core (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} sighup_dumps_octave_core (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave tries\n\
@@ -1004,24 +1006,25 @@ When called from inside a function with 
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (sighup_dumps_octave_core);
 }
 
 /*
-%!error (sighup_dumps_octave_core (1, 2));
 %!test
 %! orig_val = sighup_dumps_octave_core ();
 %! old_val = sighup_dumps_octave_core (! orig_val);
 %! assert (orig_val, old_val);
 %! assert (sighup_dumps_octave_core (), ! orig_val);
 %! sighup_dumps_octave_core (orig_val);
 %! assert (sighup_dumps_octave_core (), orig_val);
+
+%!error (sighup_dumps_octave_core (1, 2))
 */
 
 DEFUN (sigterm_dumps_octave_core, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} sigterm_dumps_octave_core ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} sigterm_dumps_octave_core (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} sigterm_dumps_octave_core (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave tries\n\
@@ -1032,17 +1035,18 @@ When called from inside a function with 
 changed locally for the function and any subroutines it calls.  The original\n\
 variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (sigterm_dumps_octave_core);
 }
 
 /*
-%!error (sigterm_dumps_octave_core (1, 2));
 %!test
 %! orig_val = sigterm_dumps_octave_core ();
 %! old_val = sigterm_dumps_octave_core (! orig_val);
 %! assert (orig_val, old_val);
 %! assert (sigterm_dumps_octave_core (), ! orig_val);
 %! sigterm_dumps_octave_core (orig_val);
 %! assert (sigterm_dumps_octave_core (), orig_val);
+
+%!error (sigterm_dumps_octave_core (1, 2))
 */
diff --git a/src/strfns.cc b/src/strfns.cc
--- a/src/strfns.cc
+++ b/src/strfns.cc
@@ -147,33 +147,33 @@ char ([97, 98, 99], \"\", @{\"98\", \"99
       retval = octave_value (result, '\'');
     }
 
   return retval;
 }
 
 /*
 %!assert (char (), '');
-%!assert (char (100) == "d");
-%!assert (all(char (100,100) == ["d";"d"]));
-%!assert (all(char ({100,100}) == ["d";"d"]));
-%!assert (all(char ([100,100]) == ["dd"]));
-%!assert (all(char ({100,{100}}) == ["d";"d"]));
-%!assert (all(char (100, [], 100) == ["d";" ";"d"]))
-%!assert (all(char ({100, [], 100}) == ["d";" ";"d"]))
-%!assert (all(char ({100,{100, {""}}}) == ["d";"d";" "]))
-%!assert (all(char (["a";"be"], {"c", 100}) == ["a";"be";"c";"d"]))
-%!assert(strcmp (char ("a", "bb", "ccc"), ["a  "; "bb "; "ccc"]));
-%!assert(strcmp (char ([65, 83, 67, 73, 73]), "ASCII"));
+%!assert (char (100), "d");
+%!assert (char (100,100), ["d";"d"])
+%!assert (char ({100,100}), ["d";"d"])
+%!assert (char ([100,100]), ["dd"])
+%!assert (char ({100,{100}}), ["d";"d"])
+%!assert (char (100, [], 100), ["d";" ";"d"])
+%!assert (char ({100, [], 100}), ["d";" ";"d"])
+%!assert (char ({100,{100, {""}}}), ["d";"d";" "])
+%!assert (char (["a";"be"], {"c", 100}), ["a";"be";"c";"d"])
+%!assert (char ("a", "bb", "ccc"), ["a  "; "bb "; "ccc"])
+%!assert (char ([65, 83, 67, 73, 73]), "ASCII")
 
 %!test
 %! x = char ("foo", "bar", "foobar");
-%! assert((strcmp (x(1,:), "foo   ")
-%! && strcmp (x(2,:), "bar   ")
-%! && strcmp (x(3,:), "foobar")));
+%! assert (x(1,:), "foo   ");
+%! assert (x(2,:), "bar   ");
+%! assert (x(3,:), "foobar");
 */
 
 DEFUN (strvcat, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} strvcat (@var{x})\n\
 @deftypefnx {Built-in Function} {} strvcat (@var{x}, @dots{})\n\
 @deftypefnx {Built-in Function} {} strvcat (@var{s1}, @var{s2}, @dots{})\n\
 @deftypefnx {Built-in Function} {} strvcat (@var{cell_array})\n\
@@ -281,28 +281,29 @@ strvcat ([97, 98, 99], \"\", @{\"98\", \
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error <Invalid call to strvcat> strvcat()
 %!assert (strvcat (""), "");
 %!assert (strvcat (100) == "d");
-%!assert (all(strvcat (100,100) == ["d";"d"]));
-%!assert (all(strvcat ({100,100}) == ["d";"d"]));
-%!assert (all(strvcat ([100,100]) == ["dd"]));
-%!assert (all(strvcat ({100,{100}}) == ["d";"d"]));
-%!assert (all(strvcat (100, [], 100) == ["d";"d"]))
-%!assert (all(strvcat ({100, [], 100}) == ["d";"d"]))
-%!assert (all(strvcat ({100,{100, {""}}}) == ["d";"d"]))
-%!assert (all(strvcat (["a";"be"], {"c", 100}) == ["a";"be";"c";"d"]))
-%!assert(strcmp (strvcat ("a", "bb", "ccc"), ["a  "; "bb "; "ccc"]));
+%!assert (strvcat (100,100), ["d";"d"])
+%!assert (strvcat ({100,100}), ["d";"d"])
+%!assert (strvcat ([100,100]), ["dd"])
+%!assert (strvcat ({100,{100}}), ["d";"d"])
+%!assert (strvcat (100, [], 100), ["d";"d"])
+%!assert (strvcat ({100, [], 100}), ["d";"d"])
+%!assert (strvcat ({100,{100, {""}}}), ["d";"d"])
+%!assert (strvcat (["a";"be"], {"c", 100}), ["a";"be";"c";"d"])
+%!assert (strvcat ("a", "bb", "ccc"), ["a  "; "bb "; "ccc"])
+
+%!error strvcat ()
 */
 
 
 DEFUN (ischar, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ischar (@var{x})\n\
 Return true if @var{x} is a character array.\n\
 @seealso{isfloat, isinteger, islogical, isnumeric, iscellstr, isa}\n\
@@ -316,29 +317,30 @@ Return true if @var{x} is a character ar
     retval = args(0).is_string ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert (ischar ("a"), logical (1));
-%!assert (ischar (["ab";"cd"]), logical (1));
-%!assert (ischar ({"ab"}), logical (0));
-%!assert (ischar (1), logical (0));
-%!assert(ischar ([1, 2]), logical (0));
-%!assert(ischar ([]), logical (0));
-%!assert(ischar ([1, 2; 3, 4]), logical (0));
-%!assert(ischar (""), logical (1));
-%!assert(ischar ("test"), logical (1));
-%!assert(ischar (["test"; "ing"]), logical (1));
-%!assert(ischar (struct ("foo", "bar")), logical (0));
-%!error <Invalid call to ischar> ischar ();
-%!error <Invalid call to ischar> ischar ("test", 1);
+%!assert (ischar ("a"), true)
+%!assert (ischar (["ab";"cd"]), true)
+%!assert (ischar ({"ab"}), false)
+%!assert (ischar (1), false)
+%!assert (ischar ([1, 2]), false)
+%!assert (ischar ([]), false)
+%!assert (ischar ([1, 2; 3, 4]), false)
+%!assert (ischar (""), true)
+%!assert (ischar ("test"), true)
+%!assert (ischar (["test"; "ing"]), true)
+%!assert (ischar (struct ("foo", "bar")), false)
+
+%!error ischar ()
+%!error ischar ("test", 1)
 */
 
 static octave_value
 do_strcmp_fun (const octave_value& arg0, const octave_value& arg1,
                octave_idx_type n, const char *fcn_name,
                bool (*array_op) (const charNDArray&, const charNDArray&, octave_idx_type),
                bool (*str_op) (const std::string&, const std::string&, octave_idx_type))
 
@@ -584,61 +586,61 @@ This is just the opposite of the corresp
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error <Invalid call to strcmp> strcmp ();
-%!error <Invalid call to strcmp> strcmp ("foo", "bar", 3);
-%!
 %!shared x
-%!  x = char (zeros (0, 2));
-%!assert (strcmp ('', x) == false);
-%!assert (strcmp (x, '') == false);
-%!assert (strcmp (x, x) == true);
-## %!assert (strcmp ({''}, x) == true);
-## %!assert (strcmp ({x}, '') == false);
-## %!assert (strcmp ({x}, x) == true);
-## %!assert (strcmp ('', {x}) == false);
-## %!assert (strcmp (x, {''}) == false);
-## %!assert (strcmp (x, {x}) == true);
-## %!assert (all (strcmp ({x; x}, '') == [false; false]));
-## %!assert (all (strcmp ({x; x}, {''}) == [false; false]));
-## %!assert (all (strcmp ('', {x; x}) == [false; false]));
-## %!assert (all (strcmp ({''}, {x; x}) == [false; false]));
-%!assert (strcmp ({'foo'}, x) == false);
-%!assert (strcmp ({'foo'}, 'foo') == true);
-%!assert (strcmp ({'foo'}, x) == false);
-%!assert (strcmp (x, {'foo'}) == false);
-%!assert (strcmp ('foo', {'foo'}) == true);
-%!assert (strcmp (x, {'foo'}) == false);
+%! x = char (zeros (0, 2));
+%!assert (strcmp ("", x), false)
+%!assert (strcmp (x, ""), false)
+%!assert (strcmp (x, x), true)
+## %!assert (strcmp ({""}, x), true)
+## %!assert (strcmp ({x}, ""), false)
+## %!assert (strcmp ({x}, x), true)
+## %!assert (strcmp ("", {x}), false)
+## %!assert (strcmp (x, {""}), false)
+## %!assert (strcmp (x, {x}), true)
+## %!assert (strcmp ({x; x}, ""), [false; false])
+## %!assert (strcmp ({x; x}, {""}), [false; false])
+## %!assert (strcmp ("", {x; x}), [false; false])
+## %!assert (strcmp ({""}, {x; x}), [false; false])
+%!assert (strcmp ({"foo"}, x), false)
+%!assert (strcmp ({"foo"}, "foo"), true)
+%!assert (strcmp ({"foo"}, x), false)
+%!assert (strcmp (x, {"foo"}), false)
+%!assert (strcmp ("foo", {"foo"}), true)
+%!assert (strcmp (x, {"foo"}), false)
 %!shared y
-%!  y = char (zeros (2, 0));
-%!assert (strcmp ('', y) == false);
-%!assert (strcmp (y, '') == false);
-%!assert (strcmp (y, y) == true);
-%!assert (all (strcmp ({''}, y) == [true; true]));
-%!assert (strcmp ({y}, '') == true);
-%!assert (all (strcmp ({y}, y) == [true; true]));
-%!assert (all (strcmp ('', {y}) == [true; true]));
-%!assert (all (strcmp (y, {''}) == [true; true]));
-%!assert (all (strcmp (y, {y}) == [true; true]));
-%!assert (all (strcmp ({y; y}, '') == [true; true]));
-%!assert (all (strcmp ({y; y}, {''}) == [true; true]));
-%!assert (all (strcmp ('', {y; y}) == [true; true]));
-%!assert (all (strcmp ({''}, {y; y}) == [true; true]));
-%!assert (all (strcmp ({'foo'}, y) == [false; false]));
-%!assert (all (strcmp ({'foo'}, y) == [false; false]));
-%!assert (all (strcmp (y, {'foo'}) == [false; false]));
-%!assert (all (strcmp (y, {'foo'}) == [false; false]));
-%!assert (strcmp ("foobar", "foobar"), true);
-%!assert (strcmp ("fooba", "foobar"), false);
+%! y = char (zeros (2, 0));
+%!assert (strcmp ("", y), false)
+%!assert (strcmp (y, ""), false)
+%!assert (strcmp (y, y), true)
+%!assert (strcmp ({""}, y), [true; true])
+%!assert (strcmp ({y}, ""), true)
+%!assert (strcmp ({y}, y), [true; true])
+%!assert (strcmp ("", {y}), true)
+%!assert (strcmp (y, {""}), [true; true])
+%!assert (strcmp (y, {y}), [true; true])
+%!assert (strcmp ({y; y}, ""), [true; true])
+%!assert (strcmp ({y; y}, {""}), [true; true])
+%!assert (strcmp ("", {y; y}), [true; true])
+%!assert (strcmp ({""}, {y; y}), [true; true])
+%!assert (strcmp ({"foo"}, y), [false; false])
+%!assert (strcmp ({"foo"}, y), [false; false])
+%!assert (strcmp (y, {"foo"}), [false; false])
+%!assert (strcmp (y, {"foo"}), [false; false])
+%!assert (strcmp ("foobar", "foobar"), true)
+%!assert (strcmp ("fooba", "foobar"), false)
+
+%!error strcmp ()
+%!error strcmp ("foo", "bar", 3)
 */
 
 // Apparently, Matlab ignores the dims with strncmp. It also
 static bool
 strncmp_array_op (const charNDArray& s1, const charNDArray& s2, octave_idx_type n)
 {
   octave_idx_type l1 = s1.numel (), l2 = s2.numel ();
   return (n > 0 && n <= l1 && n <= l2
@@ -707,25 +709,26 @@ This is just the opposite of the corresp
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error <Invalid call to strncmp> strncmp ();
-%!error <Invalid call to strncmp> strncmp ("abc", "def");
-%!assert (strncmp ("abce", "abc", 3) == 1)
-%!assert (strncmp (100, 100, 1) == 0)
-%!assert (all (strncmp ("abce", {"abcd", "bca", "abc"}, 3) == [1, 0, 1]))
-%!assert (all (strncmp ("abc",  {"abcd", "bca", "abc"}, 4) == [0, 0, 0]))
-%!assert (all (strncmp ({"abcd", "bca", "abc"},"abce", 3) == [1, 0, 1]))
-%!assert (all (strncmp ({"abcd", "bca", "abc"},{"abcd", "bca", "abe"}, 3) == [1, 1, 0]))
-%!assert (all (strncmp("abc", {"abcd", 10}, 2) == [1, 0]))
+%!assert (strncmp ("abce", "abc", 3), true)
+%!assert (strncmp (100, 100, 1), false)
+%!assert (strncmp ("abce", {"abcd", "bca", "abc"}, 3), logical ([1, 0, 1]))
+%!assert (strncmp ("abc",  {"abcd", "bca", "abc"}, 4), logical ([0, 0, 0]))
+%!assert (strncmp ({"abcd", "bca", "abc"},"abce", 3), logical ([1, 0, 1]))
+%!assert (strncmp ({"abcd", "bca", "abc"},{"abcd", "bca", "abe"}, 3), logical ([1, 1, 0]))
+%!assert (strncmp ("abc", {"abcd", 10}, 2), logical ([1, 0]))
+
+%!error strncmp ()
+%!error strncmp ("abc", "def")
 */
 
 // case-insensitive character equality functor
 struct icmp_char_eq : public std::binary_function<char, char, bool>
 {
   bool operator () (char x, char y) const
     { return std::toupper (x) == std::toupper (y); }
 };
@@ -778,17 +781,17 @@ This is just the opposite of the corresp
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert (strcmpi("abc123", "ABC123"), logical(1));
+%!assert (strcmpi ("abc123", "ABC123"), true)
 */
 
 // Like strncmp.
 static bool
 strncmpi_array_op (const charNDArray& s1, const charNDArray& s2, octave_idx_type n)
 {
   octave_idx_type l1 = s1.numel (), l2 = s2.numel ();
   return (n > 0 && n <= l1 && n <= l2
@@ -845,17 +848,17 @@ This is just the opposite of the corresp
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!assert (strncmpi("abc123", "ABC456", 3), logical(1));
+%!assert (strncmpi ("abc123", "ABC456", 3), true)
 */
 
 DEFUN (list_in_columns, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} list_in_columns (@var{arg}, @var{width})\n\
 Return a string containing the elements of @var{arg} listed in\n\
 columns with an overall maximum width of @var{width}.  The argument\n\
 @var{arg} must be a cell array of character strings or a character array.\n\
@@ -918,20 +921,21 @@ whos ans\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error <Invalid call to list_in_columns> list_in_columns ();
-%!error <Invalid call to list_in_columns> list_in_columns (["abc", "def"], 20, 2);
-%!error <invalid conversion from string to real scalar> list_in_columns (["abc", "def"], "a");
+%!test
+%! input  = {"abc", "def", "ghijkl", "mnop", "qrs", "tuv"};
+%! result = "abc     mnop\ndef     qrs\nghijkl  tuv\n";
+%! assert (list_in_columns (input, 20), result);
 %!test
-%!  input  = {"abc", "def", "ghijkl", "mnop", "qrs", "tuv"};
-%!  result = "abc     mnop\ndef     qrs\nghijkl  tuv\n";
-%!  assert (list_in_columns (input, 20) == result);
-%!test
-%!  input  = ["abc"; "def"; "ghijkl"; "mnop"; "qrs"; "tuv"];
-%!  result = "abc     mnop  \ndef     qrs   \nghijkl  tuv   \n";
-%!  assert (list_in_columns (input, 20) == result);
+%! input  = ["abc"; "def"; "ghijkl"; "mnop"; "qrs"; "tuv"];
+%! result = "abc     mnop  \ndef     qrs   \nghijkl  tuv   \n";
+%! assert (list_in_columns (input, 20), result);
+
+%!error list_in_columns ()
+%!error list_in_columns (["abc", "def"], 20, 2)
+%!error <invalid conversion from string to real scalar> list_in_columns (["abc", "def"], "a")
 */
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -1526,21 +1526,20 @@ need to recompiled.\n\
 %! state = ignore_function_time_stamp ("all");
 %! assert (state, old_state);
 %! assert (ignore_function_time_stamp (), "all");
 %! state = ignore_function_time_stamp ("system");
 %! assert (state, "all");
 %! assert (ignore_function_time_stamp (), "system");
 %! ignore_function_time_stamp (old_state);
 
-%% Test input validation
+## Test input validation
 %!error (ignore_function_time_stamp ("all", "all"))
 %!error (ignore_function_time_stamp ("UNKNOWN_VALUE"))
 %!error (ignore_function_time_stamp (42))
-
 */
 
 DEFUN (__current_scope__, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{scope}, @var{context}]} __dump_symtab_info__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -364,56 +364,54 @@ exit status, it will linger until Octave
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-
 %!test
-%!  if (isunix())
-%!    [in, out, pid] = popen2 ("sort", "-r");
-%!    EAGAIN = errno ("EAGAIN");
-%!  else
-%!    [in, out, pid] = popen2 ("sort", "/R");
-%!    EAGAIN = errno ("EINVAL");
-%!  endif
-%!  fputs (in, "these\nare\nsome\nstrings\n");
-%!  fclose (in);
-%!  done = false;
-%!  str = {};
-%!  idx = 0;
-%!  errs = 0;
-%!  do
-%!     if (!isunix())
-%!       errno (0);
-%!     endif
-%!     s = fgets (out);
-%!     if (ischar (s))
-%!       idx++;
-%!       str{idx} = s;
-%!     elseif (errno () == EAGAIN)
-%!       fclear (out);
-%!       sleep (0.1);
-%!       if (++errs == 100)
-%!         done = true;
-%!       endif
-%!     else
+%! if (isunix ())
+%!   [in, out, pid] = popen2 ("sort", "-r");
+%!   EAGAIN = errno ("EAGAIN");
+%! else
+%!   [in, out, pid] = popen2 ("sort", "/R");
+%!   EAGAIN = errno ("EINVAL");
+%! endif
+%! fputs (in, "these\nare\nsome\nstrings\n");
+%! fclose (in);
+%! done = false;
+%! str = {};
+%! idx = 0;
+%! errs = 0;
+%! do
+%!   if (!isunix ())
+%!     errno (0);
+%!   endif
+%!   s = fgets (out);
+%!   if (ischar (s))
+%!     idx++;
+%!     str{idx} = s;
+%!   elseif (errno () == EAGAIN)
+%!     fclear (out);
+%!     sleep (0.1);
+%!     if (++errs == 100)
 %!       done = true;
 %!     endif
-%!  until (done)
-%!  fclose (out);
-%!  if (isunix())
-%!    assert(str,{"these\n","strings\n","some\n","are\n"})
-%!  else
-%!    assert(str,{"these\r\n","strings\r\n","some\r\n","are\r\n"})
-%!  end
-
+%!   else
+%!     done = true;
+%!   endif
+%! until (done)
+%! fclose (out);
+%! if (isunix ())
+%!   assert(str, {"these\n","strings\n","some\n","are\n"});
+%! else
+%!   assert(str, {"these\r\n","strings\r\n","some\r\n","are\r\n"});
+%! endif
 */
 
 DEFUNX ("fcntl", Ffcntl, args, ,
  "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} fcntl (@var{fid}, @var{request}, @var{arg})\n\
 Change the properties of the open file @var{fid}.  The following values\n\
 may be passed as @var{request}:\n\
 \n\
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -603,17 +603,17 @@ Set the value of the environment variabl
     print_usage ();
 
   return retval;
 }
 
 DEFALIAS (setenv, putenv);
 
 /*
-%!assert (ischar (getenv ("OCTAVE_HOME")));
+%!assert (ischar (getenv ("OCTAVE_HOME")))
 %!test
 %! setenv ("dummy_variable_that_cannot_matter", "foobar");
 %! assert (getenv ("dummy_variable_that_cannot_matter"), "foobar");
 */
 
 // FIXME -- perhaps kbhit should also be able to print a prompt?
 
 DEFUN (kbhit, args, ,
@@ -717,19 +717,20 @@ clc;\n\
       flush_octave_stdout ();
       octave_kbhit ();
     }
 
   return retval;
 }
 
 /*
-%!error (pause (1, 2));
 %!test
 %! pause (1);
+
+%!error (pause (1, 2))
 */
 
 DEFUN (sleep, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} sleep (@var{seconds})\n\
 Suspend the execution of the program for the given number of seconds.\n\
 @end deftypefn")
 {
@@ -752,20 +753,21 @@ Suspend the execution of the program for
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error (sleep ());
-%!error (sleep (1, 2));
 %!test
 %! sleep (1);
+
+%!error (sleep ())
+%!error (sleep (1, 2))
 */
 
 DEFUN (usleep, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} usleep (@var{microseconds})\n\
 Suspend the execution of the program for the given number of\n\
 microseconds.  On systems where it is not possible to sleep for periods\n\
 of time less than one second, @code{usleep} will pause the execution for\n\
@@ -795,20 +797,21 @@ of time less than one second, @code{usle
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error (usleep ());
-%!error (usleep (1, 2));
 %!test
 %! usleep (1000);
+
+%!error (usleep ())
+%!error (usleep (1, 2))
 */
 
 // FIXME -- maybe this should only return 1 if IEEE floating
 // point functions really work.
 
 DEFUN (isieee, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isieee ()\n\
@@ -818,32 +821,32 @@ for floating point calculations.  No act
 {
   oct_mach_info::float_format flt_fmt = oct_mach_info::native_float_format ();
 
   return octave_value (flt_fmt == oct_mach_info::flt_fmt_ieee_little_endian
                        || flt_fmt == oct_mach_info::flt_fmt_ieee_big_endian);
 }
 
 /*
-%!assert (islogical (isieee ()));
+%!assert (islogical (isieee ()))
 */
 
 DEFUN (native_float_format, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} native_float_format ()\n\
 Return the native floating point format as a string\n\
 @end deftypefn")
 {
   oct_mach_info::float_format flt_fmt = oct_mach_info::native_float_format ();
 
   return octave_value (oct_mach_info::float_format_as_string (flt_fmt));
 }
 
 /*
-%!assert (ischar (native_float_format ()));
+%!assert (ischar (native_float_format ()))
 */
 
 DEFUN (tilde_expand, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} tilde_expand (@var{string})\n\
 Perform tilde expansion on @var{string}.  If @var{string} begins with a\n\
 tilde character, (@samp{~}), all of the characters preceding the first\n\
 slash (or all characters, if there is no slash) are treated as a\n\
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -1479,22 +1479,23 @@ specified option.\n\
     retval = m;
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error octave_config_info (1, 2);
-%!assert (ischar (octave_config_info ("version")));
+%!assert (ischar (octave_config_info ("version")))
 %!test
 %! x = octave_config_info ();
 %! assert (isstruct (x));
 %! assert (! isempty (x));
+
+%!error octave_config_info (1, 2)
 */
 
 #if defined (__GNUG__) && defined (DEBUG_NEW_DELETE)
 
 int debug_new_delete = 0;
 
 typedef void (*vfp)(void);
 extern vfp __new_handler;
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -112,24 +112,24 @@ Return true if @var{name} is a valid var
     retval = valid_identifier (argv[1]) && ! is_keyword (argv[1]);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error isvarname ();
-%!error isvarname ("foo", "bar");
+%!assert (isvarname ("foo"), true)
+%!assert (isvarname ("_foo"), true)
+%!assert (isvarname ("_1"), true)
+%!assert (isvarname ("1foo"), false)
+%!assert (isvarname (""), false)
 
-%!assert (isvarname ("foo"), true);
-%!assert (isvarname ("_foo"), true);
-%!assert (isvarname ("_1"), true);
-%!assert (isvarname ("1foo"), false);
-%!assert (isvarname (""), false);
+%!error isvarname ()
+%!error isvarname ("foo", "bar");
 */
 
 // Return TRUE if F and G are both names for the same file.
 
 bool
 same_file (const std::string& f, const std::string& g)
 {
   return same_file_internal (f, g);
@@ -334,31 +334,31 @@ name in the path.  If no files are found
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error file_in_loadpath ();
-%!error file_in_loadpath ("foo", "bar", 1);
-
 %!test
 %! f = file_in_loadpath ("plot.m");
 %! assert (ischar (f));
 %! assert (! isempty (f));
 
 %!test
 %! f = file_in_loadpath ("$$probably_!!_not_&&_a_!!_file$$");
 %! assert (f, "");
 
 %!test
 %! lst = file_in_loadpath ("$$probably_!!_not_&&_a_!!_file$$", "all");
 %! assert (lst, {});
+
+%!error file_in_loadpath ()
+%!error file_in_loadpath ("foo", "bar", 1)
 */
 
 DEFUN (file_in_path, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} file_in_path (@var{path}, @var{file})\n\
 @deftypefnx {Built-in Function} {} file_in_path (@var{path}, @var{file}, \"all\")\n\
 Return the absolute name of @var{file} if it can be found in\n\
 @var{path}.  The value of @var{path} should be a colon-separated list of\n\
@@ -417,32 +417,32 @@ name in the path.  If no files are found
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error file_in_path ();
-%!error file_in_path ("foo");
-%!error file_in_path ("foo", "bar", "baz", 1);
-
 %!test
 %! f = file_in_path (path (), "plot.m");
 %! assert (ischar (f));
 %! assert (! isempty (f));
 
 %!test
 %! f = file_in_path (path (), "$$probably_!!_not_&&_a_!!_file$$");
 %! assert (f, "");
 
 %!test
 %! lst = file_in_path (path (), "$$probably_!!_not_&&_a_!!_file$$", "all");
 %! assert (lst, {});
+
+%!error file_in_path ()
+%!error file_in_path ("foo")
+%!error file_in_path ("foo", "bar", "baz", 1)
 */
 
 std::string
 file_in_path (const std::string& name, const std::string& suffix)
 {
   std::string nm = name;
 
   if (! suffix.empty ())
@@ -669,29 +669,29 @@ Convert special characters in @var{strin
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error do_string_escapes ();
-%!error do_string_escapes ("foo", "bar");
+%!assert (do_string_escapes ('foo\nbar'), "foo\nbar")
+%!assert (do_string_escapes ("foo\\nbar"), "foo\nbar")
+%!assert (do_string_escapes ("foo\\nbar"), ["foo", char(10), "bar"])
+%!assert ("foo\nbar", ["foo", char(10), "bar"])
 
-%!assert (do_string_escapes ('foo\nbar'), "foo\nbar");
-%!assert (do_string_escapes ("foo\\nbar"), "foo\nbar");
-%!assert (do_string_escapes ("foo\\nbar"), ["foo", char(10), "bar"]);
-%!assert ("foo\nbar", ["foo", char(10), "bar"]);
+%!assert (do_string_escapes ('\a\b\f\n\r\t\v'), "\a\b\f\n\r\t\v")
+%!assert (do_string_escapes ("\\a\\b\\f\\n\\r\\t\\v"), "\a\b\f\n\r\t\v")
+%!assert (do_string_escapes ("\\a\\b\\f\\n\\r\\t\\v"),
+%!        char ([7, 8, 12, 10, 13, 9, 11]))
+%!assert ("\a\b\f\n\r\t\v", char ([7, 8, 12, 10, 13, 9, 11]))
 
-%!assert (do_string_escapes ('\a\b\f\n\r\t\v'), "\a\b\f\n\r\t\v");
-%!assert (do_string_escapes ("\\a\\b\\f\\n\\r\\t\\v"), "\a\b\f\n\r\t\v");
-%!assert (do_string_escapes ("\\a\\b\\f\\n\\r\\t\\v"),
-%!        char ([7, 8, 12, 10, 13, 9, 11]));
-%!assert ("\a\b\f\n\r\t\v", char ([7, 8, 12, 10, 13, 9, 11]));
+%!error do_string_escapes ()
+%!error do_string_escapes ("foo", "bar")
 */
 
 const char *
 undo_string_escape (char c)
 {
   if (! c)
     return "";
 
@@ -791,27 +791,27 @@ representation.\n\
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error undo_string_escapes ();
-%!error undo_string_escapes ("foo", "bar");
+%!assert (undo_string_escapes ("foo\nbar"), 'foo\nbar')
+%!assert (undo_string_escapes ("foo\nbar"), "foo\\nbar")
+%!assert (undo_string_escapes (["foo", char(10), "bar"]), "foo\\nbar")
 
-%!assert (undo_string_escapes ("foo\nbar"), 'foo\nbar');
-%!assert (undo_string_escapes ("foo\nbar"), "foo\\nbar");
-%!assert (undo_string_escapes (["foo", char(10), "bar"]), "foo\\nbar");
+%!assert (undo_string_escapes ("\a\b\f\n\r\t\v"), '\a\b\f\n\r\t\v')
+%!assert (undo_string_escapes ("\a\b\f\n\r\t\v"), "\\a\\b\\f\\n\\r\\t\\v")
+%!assert (undo_string_escapes (char ([7, 8, 12, 10, 13, 9, 11])),
+%!        "\\a\\b\\f\\n\\r\\t\\v")
 
-%!assert (undo_string_escapes ("\a\b\f\n\r\t\v"), '\a\b\f\n\r\t\v');
-%!assert (undo_string_escapes ("\a\b\f\n\r\t\v"), "\\a\\b\\f\\n\\r\\t\\v");
-%!assert (undo_string_escapes (char ([7, 8, 12, 10, 13, 9, 11])),
-%!        "\\a\\b\\f\\n\\r\\t\\v");
+%!error undo_string_escapes ()
+%!error undo_string_escapes ("foo", "bar")
 */
 
 DEFUN (is_absolute_filename, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_absolute_filename (@var{file})\n\
 Return true if @var{file} is an absolute filename.\n\
 @seealso{is_rooted_relative_filename, make_absolute_filename, isdir}\n\
 @end deftypefn")
@@ -823,20 +823,20 @@ Return true if @var{file} is an absolute
               && octave_env::absolute_pathname (args(0).string_value ()));
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error is_absolute_filename ();
-%!error is_absolute_filename ("foo", "bar");
+## FIXME: We need system-dependent tests here.
 
-FIXME -- we need system-dependent tests here.
+%!error is_absolute_filename ()
+%!error is_absolute_filename ("foo", "bar")
 */
 
 DEFUN (is_rooted_relative_filename, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_rooted_relative_filename (@var{file})\n\
 Return true if @var{file} is a rooted-relative filename.\n\
 @seealso{is_absolute_filename, make_absolute_filename, isdir}\n\
 @end deftypefn")
@@ -848,20 +848,20 @@ Return true if @var{file} is a rooted-re
               && octave_env::rooted_relative_pathname (args(0).string_value ()));
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error is_rooted_relative_filename ();
-%!error is_rooted_relative_filename ("foo", "bar");
+## FIXME: We need system-dependent tests here.
 
-FIXME -- we need system-dependent tests here.
+%!error is_rooted_relative_filename ()
+%!error is_rooted_relative_filename ("foo", "bar")
 */
 
 DEFUN (make_absolute_filename, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} make_absolute_filename (@var{file})\n\
 Return the full name of @var{file}, relative to the current directory.\n\
 @seealso{is_absolute_filename, is_rooted_relative_filename, isdir}\n\
 @end deftypefn")
@@ -879,20 +879,20 @@ Return the full name of @var{file}, rela
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error make_absolute_filename ();
-%!error make_absolute_filename ("foo", "bar");
+## FIXME: We need system-dependent tests here.
 
-FIXME -- we need system-dependent tests here.
+%!error make_absolute_filename ()
+%!error make_absolute_filename ("foo", "bar")
 */
 
 DEFUN (find_dir_in_path, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} find_dir_in_path (@var{dir})\n\
 @deftypefnx {Built-in Function} {} find_dir_in_path (@var{dir}, \"all\")\n\
 Return the full name of the path element matching @var{dir}.  The\n\
 match is performed at the end of each path element.  For example, if\n\
@@ -926,20 +926,20 @@ containing all name matches rather than 
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error find_dir_in_path ();
-%!error find_dir_in_path ("foo", "bar", 1);
+## FIXME: We need system-dependent tests here.
 
-FIXME -- need to create tests using current path, pathsep, and dirsep.
+%!error find_dir_in_path ()
+%!error find_dir_in_path ("foo", "bar", 1)
 */
 
 DEFUNX ("errno", Ferrno, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{err} =} errno ()\n\
 @deftypefnx {Built-in Function} {@var{err} =} errno (@var{val})\n\
 @deftypefnx {Built-in Function} {@var{err} =} errno (@var{name})\n\
 Return the current value of the system-dependent variable errno,\n\
@@ -977,28 +977,28 @@ if @var{name} is not found.\n\
     retval = octave_errno::get ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error errno ("foo", 1);
-
-%!assert (isnumeric (errno ()));
+%!assert (isnumeric (errno ()))
 
 %!test
 %! lst = errno_list ();
 %! fns = fieldnames (lst);
 %! oldval = errno (fns{1});
 %! assert (isnumeric (oldval));
 %! errno (oldval);
 %! newval = errno ();
 %! assert (oldval, newval);
+
+%!error errno ("foo", 1)
 */
 
 DEFUN (errno_list, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} errno_list ()\n\
 Return a structure containing the system-dependent errno values.\n\
 @end deftypefn")
 {
@@ -1008,19 +1008,19 @@ Return a structure containing the system
     retval = octave_errno::list ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
-%!error errno_list ("foo");
+%!assert (isstruct (errno_list ()))
 
-%!assert (isstruct (errno_list ()));
+%!error errno_list ("foo")
 */
 
 static void
 check_dimensions (octave_idx_type& nr, octave_idx_type& nc, const char *warnfor)
 {
   if (nr < 0 || nc < 0)
     {
       warning_with_id ("Octave:neg-dim-as-zero",
@@ -1326,21 +1326,21 @@ subsequent indexing using @var{ind} will
           retval = false;
         }
     }
 
   return retval;
 }
 
 /*
-%!error isindex ();
+%!assert (isindex ([1, 2, 3]))
+%!assert (isindex (1:3))
+%!assert (isindex ([1, 2, -3]), false)
 
-%!assert (isindex ([1, 2, 3]));
-%!assert (isindex (1:3));
-%!assert (isindex ([1, 2, -3]), false);
+%!error isindex ()
 */
 
 octave_value_list
 do_simple_cellfun (octave_value_list (*fun) (const octave_value_list&, int),
                    const char *fun_name, const octave_value_list& args,
                    int nargout)
 {
   octave_value_list new_args = args, retval;
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -575,27 +575,27 @@ Check only for directories.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%!  if (isunix ())
-%!    assert (exist ("/tmp") == 7);
-%!    assert (exist ("/tmp", "file") == 7);
-%!    assert (exist ("/tmp", "dir") == 7);
-%!    assert (exist ("/bin/sh") == 2);
-%!    assert (exist ("/bin/sh", "file") == 2);
-%!    assert (exist ("/bin/sh", "dir") == 0);
-%!    assert (exist ("/dev/null") == 2);
-%!    assert (exist ("/dev/null", "file") == 2);
-%!    assert (exist ("/dev/null", "dir") == 0);
-%!  endif
+%! if (isunix ())
+%!   assert (exist ("/tmp") == 7);
+%!   assert (exist ("/tmp", "file") == 7);
+%!   assert (exist ("/tmp", "dir") == 7);
+%!   assert (exist ("/bin/sh") == 2);
+%!   assert (exist ("/bin/sh", "file") == 2);
+%!   assert (exist ("/bin/sh", "dir") == 0);
+%!   assert (exist ("/dev/null") == 2);
+%!   assert (exist ("/dev/null", "file") == 2);
+%!   assert (exist ("/dev/null", "dir") == 0);
+%! endif
 */
 
 octave_value
 lookup_function_handle (const std::string& nm)
 {
   octave_value val = symbol_table::varval (nm);
 
   return val.is_function_handle () ? val : octave_value ();
