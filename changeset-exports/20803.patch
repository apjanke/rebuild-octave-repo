# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1449256001 18000
#      Fri Dec 04 14:06:41 2015 -0500
# Node ID c22206c1a88fbf11bdb6c9dfbfb2840a1ff09247
# Parent  8bb38ba1bad6b4a1d246ee36edd5918d877ad03b
eliminate return statements after calls to print_usage

* __ilu__.cc, besselj.cc, conv2.cc, error.cc, getgrent.cc,
getpwent.cc, help.cc, load-path.cc, sparse.cc:
Eliminate return statements after calls to print_usage.

* mode.m: Fix test.

diff --git a/libinterp/corefcn/__ilu__.cc b/libinterp/corefcn/__ilu__.cc
--- a/libinterp/corefcn/__ilu__.cc
+++ b/libinterp/corefcn/__ilu__.cc
@@ -135,20 +135,17 @@ Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
   std::string milu;
 
   if (nargout > 2 || nargin < 1 || nargin > 2)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   // In ILU0 algorithm the zero-pattern of the input matrix is preserved so
   // it's structure does not change during the algorithm.  The same input
   // matrix is used to build the output matrix due to that fact.
   octave_value_list param_list;
   if (! args(0).is_complex_type ())
     {
       SparseMatrix sm = args(0).sparse_matrix_value ();
@@ -475,20 +472,17 @@ Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
   std::string milu = "off";
   double droptol = 0;
 
   if (nargout != 2 || nargin < 1 || nargin > 3)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   // Don't repeat input validation of arguments done in ilu.m
   if (nargin >= 2)
     droptol = args(1).double_value ();
 
   if (nargin == 3)
     milu = args(2).string_value ();
 
@@ -953,20 +947,17 @@ Undocumented internal function.\n\
   octave_value_list retval;
 
   int nargin = args.length ();
   std::string milu = "";
   double droptol = 0, thresh = 1;
   double udiag = 0;
 
   if (nargout < 2 || nargout > 3 || nargin < 1 || nargin > 5)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   // Don't repeat input validation of arguments done in ilu.m
   if (nargin >= 2)
     droptol = args(1).double_value ();
 
   if (nargin >= 3)
     thresh = args(2).double_value ();
 
diff --git a/libinterp/corefcn/besselj.cc b/libinterp/corefcn/besselj.cc
--- a/libinterp/corefcn/besselj.cc
+++ b/libinterp/corefcn/besselj.cc
@@ -80,63 +80,123 @@ enum bessel_type
 octave_value_list
 do_bessel (enum bessel_type type, const char *fn,
            const octave_value_list& args, int nargout)
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
-  if (nargin == 2 || nargin == 3)
+  if (nargin < 2 || nargin > 3)
+    print_usage ();
+
+  bool scaled = false;
+  if (nargin == 3)
     {
-      bool scaled = false;
-      if (nargin == 3)
+      octave_value opt_arg = args(2);
+      bool rpt_error = false;
+
+      if (! opt_arg.is_scalar_type ())
+        rpt_error = true;
+      else if (opt_arg.is_numeric_type ())
         {
-          octave_value opt_arg = args(2);
-          bool rpt_error = false;
+          double opt_val = opt_arg.double_value ();
+          if (opt_val != 0.0 && opt_val != 1.0)
+            rpt_error = true;
+          scaled = (opt_val == 1.0);
+        }
+      else if (opt_arg.is_bool_type ())
+        scaled = opt_arg.bool_value ();
 
-          if (! opt_arg.is_scalar_type ())
-            rpt_error = true;
-          else if (opt_arg.is_numeric_type ())
+      if (rpt_error)
+        {
+          error ("%s: OPT must be 0 (or false) or 1 (or true)", fn);
+          return retval;
+        }
+    }
+
+  octave_value alpha_arg = args(0);
+  octave_value x_arg = args(1);
+
+  if (alpha_arg.is_single_type () || x_arg.is_single_type ())
+    {
+      if (alpha_arg.is_scalar_type ())
+        {
+          float alpha = args(0).xfloat_value ("%s: ALPHA must be a scalar or matrix", fn);
+
+          if (x_arg.is_scalar_type ())
             {
-              double opt_val = opt_arg.double_value ();
-              if (opt_val != 0.0 && opt_val != 1.0)
-                rpt_error = true;
-              scaled = (opt_val == 1.0);
+              FloatComplex x = x_arg.xfloat_complex_value ("%s: X must be a scalar or matrix", fn);
+
+              octave_idx_type ierr;
+              octave_value result;
+
+              DO_BESSEL (type, alpha, x, scaled, ierr, result);
+
+              if (nargout > 1)
+                retval(1) = static_cast<float> (ierr);
+
+              retval(0) = result;
             }
-          else if (opt_arg.is_bool_type ())
-            scaled = opt_arg.bool_value ();
+          else
+            {
+              FloatComplexNDArray x
+                = x_arg.xfloat_complex_array_value ("%s: X must be a scalar or matrix", fn);
 
-          if (rpt_error)
-            {
-              error ("%s: OPT must be 0 (or false) or 1 (or true)", fn);
-              return retval;
+              Array<octave_idx_type> ierr;
+              octave_value result;
+
+              DO_BESSEL (type, alpha, x, scaled, ierr, result);
+
+              if (nargout > 1)
+                retval(1) = NDArray (ierr);
+
+              retval(0) = result;
             }
         }
+      else
+        {
+          dim_vector dv0 = args(0).dims ();
+          dim_vector dv1 = args(1).dims ();
 
-      octave_value alpha_arg = args(0);
-      octave_value x_arg = args(1);
+          bool args0_is_row_vector = (dv0(1) == dv0.numel ());
+          bool args1_is_col_vector = (dv1(0) == dv1.numel ());
+
+          if (args0_is_row_vector && args1_is_col_vector)
+            {
+              FloatRowVector ralpha = args(0).xfloat_row_vector_value ("%s: ALPHA must be a scalar or matrix", fn);
 
-      if (alpha_arg.is_single_type () || x_arg.is_single_type ())
-        {
-          if (alpha_arg.is_scalar_type ())
+              FloatComplexColumnVector cx =
+                x_arg.xfloat_complex_column_vector_value ("%s: X must be a scalar or matrix", fn);
+
+              Array<octave_idx_type> ierr;
+              octave_value result;
+
+              DO_BESSEL (type, ralpha, cx, scaled, ierr, result);
+
+              if (nargout > 1)
+                retval(1) = NDArray (ierr);
+
+              retval(0) = result;
+            }
+          else
             {
-              float alpha = args(0).xfloat_value ("%s: ALPHA must be a scalar or matrix", fn);
+              FloatNDArray alpha = args(0).xfloat_array_value ("%s: ALPHA must be a scalar or matrix", fn);
 
               if (x_arg.is_scalar_type ())
                 {
                   FloatComplex x = x_arg.xfloat_complex_value ("%s: X must be a scalar or matrix", fn);
 
-                  octave_idx_type ierr;
+                  Array<octave_idx_type> ierr;
                   octave_value result;
 
                   DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
                   if (nargout > 1)
-                    retval(1) = static_cast<float> (ierr);
+                    retval(1) = NDArray (ierr);
 
                   retval(0) = result;
                 }
               else
                 {
                   FloatComplexNDArray x
                     = x_arg.xfloat_complex_array_value ("%s: X must be a scalar or matrix", fn);
 
@@ -146,94 +206,93 @@ do_bessel (enum bessel_type type, const 
                   DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
                   if (nargout > 1)
                     retval(1) = NDArray (ierr);
 
                   retval(0) = result;
                 }
             }
+        }
+    }
+  else
+    {
+      if (alpha_arg.is_scalar_type ())
+        {
+          double alpha = args(0).xdouble_value ("%s: ALPHA must be a scalar or matrix", fn);
+
+          if (x_arg.is_scalar_type ())
+            {
+              Complex x = x_arg.xcomplex_value ("%s: X must be a scalar or matrix", fn);
+
+              octave_idx_type ierr;
+              octave_value result;
+
+              DO_BESSEL (type, alpha, x, scaled, ierr, result);
+
+              if (nargout > 1)
+                retval(1) = static_cast<double> (ierr);
+
+              retval(0) = result;
+            }
           else
             {
-              dim_vector dv0 = args(0).dims ();
-              dim_vector dv1 = args(1).dims ();
-
-              bool args0_is_row_vector = (dv0(1) == dv0.numel ());
-              bool args1_is_col_vector = (dv1(0) == dv1.numel ());
-
-              if (args0_is_row_vector && args1_is_col_vector)
-                {
-                  FloatRowVector ralpha = args(0).xfloat_row_vector_value ("%s: ALPHA must be a scalar or matrix", fn);
-
-                  FloatComplexColumnVector cx =
-                    x_arg.xfloat_complex_column_vector_value ("%s: X must be a scalar or matrix", fn);
+              ComplexNDArray x = x_arg.xcomplex_array_value ("%s: X must be a scalar or matrix", fn);
 
-                  Array<octave_idx_type> ierr;
-                  octave_value result;
-
-                  DO_BESSEL (type, ralpha, cx, scaled, ierr, result);
-
-                  if (nargout > 1)
-                    retval(1) = NDArray (ierr);
-
-                  retval(0) = result;
-                }
-              else
-                {
-                  FloatNDArray alpha = args(0).xfloat_array_value ("%s: ALPHA must be a scalar or matrix", fn);
+              Array<octave_idx_type> ierr;
+              octave_value result;
 
-                  if (x_arg.is_scalar_type ())
-                    {
-                      FloatComplex x = x_arg.xfloat_complex_value ("%s: X must be a scalar or matrix", fn);
-
-                      Array<octave_idx_type> ierr;
-                      octave_value result;
-
-                      DO_BESSEL (type, alpha, x, scaled, ierr, result);
-
-                      if (nargout > 1)
-                        retval(1) = NDArray (ierr);
+              DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
-                      retval(0) = result;
-                    }
-                  else
-                    {
-                      FloatComplexNDArray x
-                        = x_arg.xfloat_complex_array_value ("%s: X must be a scalar or matrix", fn);
+              if (nargout > 1)
+                retval(1) = NDArray (ierr);
 
-                      Array<octave_idx_type> ierr;
-                      octave_value result;
-
-                      DO_BESSEL (type, alpha, x, scaled, ierr, result);
-
-                      if (nargout > 1)
-                        retval(1) = NDArray (ierr);
-
-                      retval(0) = result;
-                    }
-                }
+              retval(0) = result;
             }
         }
       else
         {
-          if (alpha_arg.is_scalar_type ())
+          dim_vector dv0 = args(0).dims ();
+          dim_vector dv1 = args(1).dims ();
+
+          bool args0_is_row_vector = (dv0(1) == dv0.numel ());
+          bool args1_is_col_vector = (dv1(0) == dv1.numel ());
+
+          if (args0_is_row_vector && args1_is_col_vector)
             {
-              double alpha = args(0).xdouble_value ("%s: ALPHA must be a scalar or matrix", fn);
+              RowVector ralpha = args(0).xrow_vector_value ("%s: ALPHA must be a scalar or matrix", fn);
+
+              ComplexColumnVector cx =
+                x_arg.xcomplex_column_vector_value ("%s: X must be a scalar or matrix", fn);
+
+              Array<octave_idx_type> ierr;
+              octave_value result;
+
+              DO_BESSEL (type, ralpha, cx, scaled, ierr, result);
+
+              if (nargout > 1)
+                retval(1) = NDArray (ierr);
+
+              retval(0) = result;
+            }
+          else
+            {
+              NDArray alpha = args(0).xarray_value ("%s: ALPHA must be a scalar or matrix", fn);
 
               if (x_arg.is_scalar_type ())
                 {
                   Complex x = x_arg.xcomplex_value ("%s: X must be a scalar or matrix", fn);
 
-                  octave_idx_type ierr;
+                  Array<octave_idx_type> ierr;
                   octave_value result;
 
                   DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
                   if (nargout > 1)
-                    retval(1) = static_cast<double> (ierr);
+                    retval(1) = NDArray (ierr);
 
                   retval(0) = result;
                 }
               else
                 {
                   ComplexNDArray x = x_arg.xcomplex_array_value ("%s: X must be a scalar or matrix", fn);
 
                   Array<octave_idx_type> ierr;
@@ -242,79 +301,18 @@ do_bessel (enum bessel_type type, const 
                   DO_BESSEL (type, alpha, x, scaled, ierr, result);
 
                   if (nargout > 1)
                     retval(1) = NDArray (ierr);
 
                   retval(0) = result;
                 }
             }
-          else
-            {
-              dim_vector dv0 = args(0).dims ();
-              dim_vector dv1 = args(1).dims ();
-
-              bool args0_is_row_vector = (dv0(1) == dv0.numel ());
-              bool args1_is_col_vector = (dv1(0) == dv1.numel ());
-
-              if (args0_is_row_vector && args1_is_col_vector)
-                {
-                  RowVector ralpha = args(0).xrow_vector_value ("%s: ALPHA must be a scalar or matrix", fn);
-
-                  ComplexColumnVector cx =
-                    x_arg.xcomplex_column_vector_value ("%s: X must be a scalar or matrix", fn);
-
-                  Array<octave_idx_type> ierr;
-                  octave_value result;
-
-                  DO_BESSEL (type, ralpha, cx, scaled, ierr, result);
-
-                  if (nargout > 1)
-                    retval(1) = NDArray (ierr);
-
-                  retval(0) = result;
-                }
-              else
-                {
-                  NDArray alpha = args(0).xarray_value ("%s: ALPHA must be a scalar or matrix", fn);
-
-                  if (x_arg.is_scalar_type ())
-                    {
-                      Complex x = x_arg.xcomplex_value ("%s: X must be a scalar or matrix", fn);
-
-                      Array<octave_idx_type> ierr;
-                      octave_value result;
-
-                      DO_BESSEL (type, alpha, x, scaled, ierr, result);
-
-                      if (nargout > 1)
-                        retval(1) = NDArray (ierr);
-
-                      retval(0) = result;
-                    }
-                  else
-                    {
-                      ComplexNDArray x = x_arg.xcomplex_array_value ("%s: X must be a scalar or matrix", fn);
-
-                      Array<octave_idx_type> ierr;
-                      octave_value result;
-
-                      DO_BESSEL (type, alpha, x, scaled, ierr, result);
-
-                      if (nargout > 1)
-                        retval(1) = NDArray (ierr);
-
-                      retval(0) = result;
-                    }
-                }
-            }
         }
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 DEFUN (besselj, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{j}, @var{ierr}] =} besselj (@var{alpha}, @var{x}, @var{opt})\n\
 @deftypefnx {Built-in Function} {[@var{y}, @var{ierr}] =} bessely (@var{alpha}, @var{x}, @var{opt})\n\
@@ -420,21 +418,24 @@ DEFUN (besselh, args, nargout,
 @deftypefn {Built-in Function} {[@var{h}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})\n\
 See besselj.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
+  if (nargin < 2 || nargin > 4)
+    print_usage ();
+
   if (nargin == 2)
     {
       retval = do_bessel (BESSEL_H1, "besselh", args, nargout);
     }
-  else if (nargin == 3 || nargin == 4)
+  else
     {
       octave_idx_type kind = args(1).xint_value ("besselh: invalid value of K");
 
       octave_value_list tmp_args;
 
       if (nargin == 4)
         tmp_args(2) = args(3);
 
@@ -443,18 +444,16 @@ See besselj.\n\
 
       if (kind == 1)
         retval = do_bessel (BESSEL_H1, "besselh", tmp_args, nargout);
       else if (kind == 2)
         retval = do_bessel (BESSEL_H2, "besselh", tmp_args, nargout);
       else
         error ("besselh: K must be 1 or 2");
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 DEFUN (airy, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{a}, @var{ierr}] =} airy (@var{k}, @var{z}, @var{opt})\n\
 Compute Airy functions of the first and second kind, and their derivatives.\n\
@@ -500,69 +499,67 @@ Error---no computation, algorithm termin
 return @code{NaN}.\n\
 @end enumerate\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
-  if (nargin > 0 && nargin < 4)
-    {
-      bool scale = (nargin == 3);
+  if (nargin < 1 || nargin > 3)
+    print_usage ();
 
-      int kind = 0;
+  bool scale = (nargin == 3);
 
-      if (nargin > 1)
-        {
-          kind = args(0).xint_value ("airy: K must be an integer value");
+  int kind = 0;
 
-          if (kind < 0 || kind > 3)
-            error ("airy: K must be 0, 1, 2, or 3");
-        }
-
-      int idx = nargin == 1 ? 0 : 1;
+  if (nargin > 1)
+    {
+      kind = args(0).xint_value ("airy: K must be an integer value");
 
-      if (args(idx).is_single_type ())
-        {
-          FloatComplexNDArray z = args(idx).xfloat_complex_array_value ("airy: Z must be a complex matrix");
+      if (kind < 0 || kind > 3)
+        error ("airy: K must be 0, 1, 2, or 3");
+    }
 
-          Array<octave_idx_type> ierr;
-          octave_value result;
+  int idx = nargin == 1 ? 0 : 1;
 
-          if (kind > 1)
-            result = biry (z, kind == 3, scale, ierr);
-          else
-            result = airy (z, kind == 1, scale, ierr);
+  if (args(idx).is_single_type ())
+    {
+      FloatComplexNDArray z = args(idx).xfloat_complex_array_value ("airy: Z must be a complex matrix");
 
-          if (nargout > 1)
-            retval(1) = NDArray (ierr);
-
-          retval(0) = result;
-        }
-      else
-        {
-          ComplexNDArray z = args(idx).xcomplex_array_value ("airy: Z must be a complex matrix");
+      Array<octave_idx_type> ierr;
+      octave_value result;
 
-          Array<octave_idx_type> ierr;
-          octave_value result;
+      if (kind > 1)
+        result = biry (z, kind == 3, scale, ierr);
+      else
+        result = airy (z, kind == 1, scale, ierr);
 
-          if (kind > 1)
-            result = biry (z, kind == 3, scale, ierr);
-          else
-            result = airy (z, kind == 1, scale, ierr);
+      if (nargout > 1)
+        retval(1) = NDArray (ierr);
 
-          if (nargout > 1)
-            retval(1) = NDArray (ierr);
-
-          retval(0) = result;
-        }
+      retval(0) = result;
     }
   else
-    print_usage ();
+    {
+      ComplexNDArray z = args(idx).xcomplex_array_value ("airy: Z must be a complex matrix");
+
+      Array<octave_idx_type> ierr;
+      octave_value result;
+
+      if (kind > 1)
+        result = biry (z, kind == 3, scale, ierr);
+      else
+        result = airy (z, kind == 1, scale, ierr);
+
+      if (nargout > 1)
+        retval(1) = NDArray (ierr);
+
+      retval(0) = result;
+    }
 
   return retval;
 }
 
 /*
 ## Test values computed with GP/PARI version 2.3.3
 %!shared alpha, x, jx, yx, ix, kx, nix
 %!
diff --git a/libinterp/corefcn/conv2.cc b/libinterp/corefcn/conv2.cc
--- a/libinterp/corefcn/conv2.cc
+++ b/libinterp/corefcn/conv2.cc
@@ -66,63 +66,51 @@ When the third argument is a matrix, ret
 {
   octave_value retval;
   octave_value tmp;
   int nargin = args.length ();
   std::string shape = "full";   // default
   bool separable = false;
   convn_type ct;
 
-  if (nargin < 2)
-    {
-      print_usage ();
-      return retval;
-    }
-  else if (nargin == 3)
+  if (nargin < 2 || nargin > 4)
+    print_usage ();
+
+  if (nargin == 3)
     {
       if (args(2).is_string ())
         shape = args(2).string_value ();
       else
         separable = true;
     }
-  else if (nargin >= 4)
+  else if (nargin == 4)
     {
       separable = true;
       shape = args(3).string_value ();
     }
 
   if (args(0).ndims () > 2 || args(1).ndims () > 2)
-    {
-      error ("conv2: A and B must be 1-D vectors or 2-D matrices");
-      return retval;
-    }
+    error ("conv2: A and B must be 1-D vectors or 2-D matrices");
 
   if (shape == "full")
     ct = convn_full;
   else if (shape == "same")
     ct = convn_same;
   else if (shape == "valid")
     ct = convn_valid;
   else
-    {
-      error ("conv2: SHAPE type not valid");
-      print_usage ();
-      return retval;
-    }
+    error ("conv2: SHAPE type not valid");
 
   if (separable)
     {
       // If user requests separable, check first two params are vectors
 
       if (! (1 == args(0).rows () || 1 == args(0).columns ())
           || ! (1 == args(1).rows () || 1 == args(1).columns ()))
-        {
-          print_usage ();
-          return retval;
-        }
+        error ("conv2: arguments must be vectors for separable option");
 
       if (args(0).is_single_type () || args(1).is_single_type ()
           || args(2).is_single_type ())
         {
           if (args(0).is_complex_type () || args(1).is_complex_type ()
               || args(2).is_complex_type ())
             {
               FloatComplexMatrix a (args(2).float_complex_matrix_value ());
@@ -319,35 +307,29 @@ The size of the result is @code{max (siz
 {
   octave_value retval;
   octave_value tmp;
   int nargin = args.length ();
   std::string shape = "full";   // default
   convn_type ct;
 
   if (nargin < 2 || nargin > 3)
-    {
-      print_usage ();
-      return retval;
-    }
-  else if (nargin == 3)
+    print_usage ();
+
+  if (nargin == 3)
     shape = args(2).xstring_value ("convn: SHAPE must be a string");
 
   if (shape == "full")
     ct = convn_full;
   else if (shape == "same")
     ct = convn_same;
   else if (shape == "valid")
     ct = convn_valid;
   else
-    {
-      error ("convn: SHAPE type not valid");
-      print_usage ();
-      return retval;
-    }
+    error ("convn: SHAPE type not valid");
 
   if (args(0).is_single_type () || args(1).is_single_type ())
     {
       if (args(0).is_complex_type () || args(1).is_complex_type ())
         {
           FloatComplexNDArray a (args(0).float_complex_array_value ());
           if (args(1).is_real_type ())
             {
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -887,143 +887,143 @@ Reissue a previous error as defined by @
 @var{err} is a structure that must contain at least the @qcode{\"message\"}\n\
 and @qcode{\"identifier\"} fields.  @var{err} can also contain a field\n\
 @qcode{\"stack\"} that gives information on the assumed location of the\n\
 error.  Typically @var{err} is returned from @code{lasterror}.\n\
 @seealso{lasterror, lasterr, error}\n\
 @end deftypefn")
 {
   octave_value retval;
+
   int nargin = args.length ();
 
   if (nargin != 1)
     print_usage ();
-  else
-    {
-      const octave_scalar_map err = args(0).scalar_map_value ();
+
+  const octave_scalar_map err = args(0).scalar_map_value ();
 
-      if (err.contains ("message") && err.contains ("identifier"))
-        {
-          std::string msg = err.contents ("message").string_value ();
-          std::string id = err.contents ("identifier").string_value ();
-          int len = msg.length ();
+  if (err.contains ("message") && err.contains ("identifier"))
+    {
+      std::string msg = err.contents ("message").string_value ();
+      std::string id = err.contents ("identifier").string_value ();
+      int len = msg.length ();
+
+      std::string file;
+      std::string nm;
+      int l = -1;
+      int c = -1;
 
-          std::string file;
-          std::string nm;
-          int l = -1;
-          int c = -1;
+      octave_map err_stack = initialize_last_error_stack ();
+
+      if (err.contains ("stack"))
+        {
+          err_stack = err.contents ("stack").map_value ();
 
-          octave_map err_stack = initialize_last_error_stack ();
+          if (err_stack.numel () > 0)
+            {
+              if (err_stack.contains ("file"))
+                file = err_stack.contents ("file")(0).string_value ();
 
-          if (err.contains ("stack"))
-            {
-              err_stack = err.contents ("stack").map_value ();
+              if (err_stack.contains ("name"))
+                nm = err_stack.contents ("name")(0).string_value ();
 
-              if (err_stack.numel () > 0)
-                {
-                  if (err_stack.contains ("file"))
-                    file = err_stack.contents ("file")(0).string_value ();
+              if (err_stack.contains ("line"))
+                l = err_stack.contents ("line")(0).nint_value ();
 
-                  if (err_stack.contains ("name"))
-                    nm = err_stack.contents ("name")(0).string_value ();
-
-                  if (err_stack.contains ("line"))
-                    l = err_stack.contents ("line")(0).nint_value ();
+              if (err_stack.contains ("column"))
+                c = err_stack.contents ("column")(0).nint_value ();
+            }
+        }
 
-                  if (err_stack.contains ("column"))
-                    c = err_stack.contents ("column")(0).nint_value ();
-                }
+      // Ugh.
+      char *tmp_msg = strsave (msg.c_str ());
+      if (tmp_msg[len-1] == '\n')
+        {
+          if (len > 1)
+            {
+              tmp_msg[len - 1] = '\0';
+              rethrow_error (id.c_str (), "%s\n", tmp_msg);
             }
+        }
+      else
+        rethrow_error (id.c_str (), "%s", tmp_msg);
+      delete [] tmp_msg;
 
-          // Ugh.
-          char *tmp_msg = strsave (msg.c_str ());
-          if (tmp_msg[len-1] == '\n')
+      // FIXME: is this the right thing to do for Vlast_error_stack?
+      //        Should it be saved and restored with unwind_protect?
+
+      Vlast_error_stack = err_stack;
+
+      if (err.contains ("stack"))
+        {
+          if (file.empty ())
             {
-              if (len > 1)
+              if (nm.empty ())
                 {
-                  tmp_msg[len - 1] = '\0';
-                  rethrow_error (id.c_str (), "%s\n", tmp_msg);
-                }
-            }
-          else
-            rethrow_error (id.c_str (), "%s", tmp_msg);
-          delete [] tmp_msg;
-
-          // FIXME: is this the right thing to do for Vlast_error_stack?
-          //        Should it be saved and restored with unwind_protect?
-
-          Vlast_error_stack = err_stack;
-
-          if (err.contains ("stack"))
-            {
-              if (file.empty ())
-                {
-                  if (nm.empty ())
+                  if (l > 0)
                     {
-                      if (l > 0)
-                        {
-                          if (c > 0)
-                            pr_where_1 (std::cerr,
-                                        "error: near line %d, column %d",
-                                        l, c);
-                          else
-                            pr_where_1 (std::cerr, "error: near line %d", l);
-                        }
-                    }
-                  else
-                    {
-                      if (l > 0)
-                        {
-                          if (c > 0)
-                            pr_where_1 (std::cerr,
-                                        "error: called from '%s' near line %d, column %d",
-                                        nm.c_str (), l, c);
-                          else
-                            pr_where_1 (std::cerr,
-                                        "error: called from '%d' near line %d",
-                                        nm.c_str (), l);
-                        }
+                      if (c > 0)
+                        pr_where_1 (std::cerr,
+                                    "error: near line %d, column %d",
+                                    l, c);
+                      else
+                        pr_where_1 (std::cerr, "error: near line %d", l);
                     }
                 }
               else
                 {
-                  if (nm.empty ())
+                  if (l > 0)
                     {
-                      if (l > 0)
-                        {
-                          if (c > 0)
-                            pr_where_1 (std::cerr,
-                                        "error: in file %s near line %d, column %d",
-                                        file.c_str (), l, c);
-                          else
-                            pr_where_1 (std::cerr,
-                                        "error: in file %s near line %d",
-                                        file.c_str (), l);
-                        }
+                      if (c > 0)
+                        pr_where_1 (std::cerr,
+                                    "error: called from '%s' near line %d, column %d",
+                                    nm.c_str (), l, c);
+                      else
+                        pr_where_1 (std::cerr,
+                                    "error: called from '%d' near line %d",
+                                    nm.c_str (), l);
                     }
-                  else
+                }
+            }
+          else
+            {
+              if (nm.empty ())
+                {
+                  if (l > 0)
                     {
-                      if (l > 0)
-                        {
-                          if (c > 0)
-                            pr_where_1 (std::cerr,
-                                        "error: called from '%s' in file %s near line %d, column %d",
-                                        nm.c_str (), file.c_str (), l, c);
-                          else
-                            pr_where_1 (std::cerr,
-                                        "error: called from '%d' in file %s near line %d",
-                                        nm.c_str (), file.c_str (), l);
-                        }
+                      if (c > 0)
+                        pr_where_1 (std::cerr,
+                                    "error: in file %s near line %d, column %d",
+                                    file.c_str (), l, c);
+                      else
+                        pr_where_1 (std::cerr,
+                                    "error: in file %s near line %d",
+                                    file.c_str (), l);
+                    }
+                }
+              else
+                {
+                  if (l > 0)
+                    {
+                      if (c > 0)
+                        pr_where_1 (std::cerr,
+                                    "error: called from '%s' in file %s near line %d, column %d",
+                                    nm.c_str (), file.c_str (), l, c);
+                      else
+                        pr_where_1 (std::cerr,
+                                    "error: called from '%d' in file %s near line %d",
+                                    nm.c_str (), file.c_str (), l);
                     }
                 }
             }
         }
-      else
-        error ("rethrow: ERR structure must contain the fields 'message and 'identifier'");
     }
+  else
+    error ("rethrow: ERR structure must contain the fields 'message and 'identifier'");
+
   return retval;
 }
 
 // Determine whether the first argument to error or warning function
 // should be handled as the message identifier or as the format string.
 
 static bool
 maybe_extract_message_id (const std::string& caller,
@@ -1164,60 +1164,58 @@ disable escape sequence expansion use a 
   int nargin = args.length ();
 
   octave_value_list nargs = args;
 
   std::string id;
 
   if (nargin == 0)
     print_usage ();
-  else
-    {
-      bool have_fmt = false;
+
+  bool have_fmt = false;
 
-      if (nargin == 1 && args(0).is_map ())
-        {
-          // empty struct is not an error.  return and resume calling function.
-          if (args(0).is_empty ())
-            return retval;
+  if (nargin == 1 && args(0).is_map ())
+    {
+      // empty struct is not an error.  return and resume calling function.
+      if (args(0).is_empty ())
+        return retval;
 
-          octave_value_list tmp;
+      octave_value_list tmp;
 
-          octave_scalar_map m = args(0).scalar_map_value ();
+      octave_scalar_map m = args(0).scalar_map_value ();
 
-          // empty struct is not an error.  return and resume calling function.
-          if (m.nfields () == 0)
-            return retval;
+      // empty struct is not an error.  return and resume calling function.
+      if (m.nfields () == 0)
+        return retval;
 
-          if (m.contains ("message"))
-            {
-              octave_value c = m.getfield ("message");
+      if (m.contains ("message"))
+        {
+          octave_value c = m.getfield ("message");
 
-              if (c.is_string ())
-                nargs(0) = c.string_value ();
-            }
+          if (c.is_string ())
+            nargs(0) = c.string_value ();
+        }
 
-          if (m.contains ("identifier"))
-            {
-              octave_value c = m.getfield ("identifier");
+      if (m.contains ("identifier"))
+        {
+          octave_value c = m.getfield ("identifier");
 
-              if (c.is_string ())
-                id = c.string_value ();
-            }
+          if (c.is_string ())
+            id = c.string_value ();
+        }
 
-          // FIXME: also need to handle "stack" field in error structure,
-          //        but that will require some more significant surgery on
-          //        handle_message, error_with_id, etc.
-        }
-      else
-        have_fmt = maybe_extract_message_id ("error", args, nargs, id);
+      // FIXME: also need to handle "stack" field in error structure,
+      //        but that will require some more significant surgery on
+      //        handle_message, error_with_id, etc.
+    }
+  else
+    have_fmt = maybe_extract_message_id ("error", args, nargs, id);
 
-      handle_message (error_with_id, id.c_str (), "unspecified error",
-                      nargs, have_fmt);
-    }
+  handle_message (error_with_id, id.c_str (), "unspecified error",
+                  nargs, have_fmt);
 
   return retval;
 }
 
 static octave_scalar_map
 warning_query (const std::string& id_arg)
 {
   octave_scalar_map retval;
@@ -1830,131 +1828,126 @@ The last error structure may be set by p
 as input.  Any fields of @var{err} that match those above are set while any\n\
 unspecified fields are initialized with default values.\n\
 \n\
 If @code{lasterror} is called with the argument @qcode{\"reset\"}, all\n\
 fields are set to their default values.\n\
 @seealso{lasterr, error, lastwarn}\n\
 @end deftypefn")
 {
-  octave_value retval;
   int nargin = args.length ();
 
-  if (nargin < 2)
-    {
-      octave_scalar_map err;
+  if (nargin > 1)
+    print_usage ();
 
-      err.assign ("message", Vlast_error_message);
-      err.assign ("identifier", Vlast_error_id);
+  octave_scalar_map err;
 
-      err.assign ("stack", octave_value (Vlast_error_stack));
+  err.assign ("message", Vlast_error_message);
+  err.assign ("identifier", Vlast_error_id);
 
-      if (nargin == 1)
+  err.assign ("stack", octave_value (Vlast_error_stack));
+
+  if (nargin == 1)
+    {
+      if (args(0).is_string ())
         {
-          if (args(0).is_string ())
+          if (args(0).string_value () == "reset")
             {
-              if (args(0).string_value () == "reset")
-                {
-                  Vlast_error_message = std::string ();
-                  Vlast_error_id = std::string ();
+              Vlast_error_message = std::string ();
+              Vlast_error_id = std::string ();
 
-                  Vlast_error_stack = initialize_last_error_stack ();
-                }
-              else
-                error ("lasterror: unrecognized string argument");
+              Vlast_error_stack = initialize_last_error_stack ();
             }
-          else if (args(0).is_map ())
+          else
+            error ("lasterror: unrecognized string argument");
+        }
+      else if (args(0).is_map ())
+        {
+          octave_scalar_map new_err = args(0).scalar_map_value ();
+          octave_scalar_map new_err_stack;
+          std::string new_error_message;
+          std::string new_error_id;
+          std::string new_error_file;
+          std::string new_error_name;
+          int new_error_line = -1;
+          int new_error_column = -1;
+
+          if (new_err.contains ("message"))
             {
-              octave_scalar_map new_err = args(0).scalar_map_value ();
-              octave_scalar_map new_err_stack;
-              std::string new_error_message;
-              std::string new_error_id;
-              std::string new_error_file;
-              std::string new_error_name;
-              int new_error_line = -1;
-              int new_error_column = -1;
+              const std::string tmp =
+                new_err.getfield ("message").string_value ();
+              new_error_message = tmp;
+            }
 
-              if (new_err.contains ("message"))
+          if (new_err.contains ("identifier"))
+            {
+              const std::string tmp =
+                new_err.getfield ("identifier").string_value ();
+              new_error_id = tmp;
+            }
+
+          if (new_err.contains ("stack"))
+            {
+              new_err_stack =
+                new_err.getfield ("stack").scalar_map_value ();
+
+              if (new_err_stack.contains ("file"))
                 {
                   const std::string tmp =
-                    new_err.getfield ("message").string_value ();
-                  new_error_message = tmp;
-                }
-
-              if (new_err.contains ("identifier"))
-                {
-                  const std::string tmp =
-                    new_err.getfield ("identifier").string_value ();
-                  new_error_id = tmp;
+                    new_err_stack.getfield ("file").string_value ();
+                  new_error_file = tmp;
                 }
 
-              if (new_err.contains ("stack"))
+              if (new_err_stack.contains ("name"))
                 {
-                  new_err_stack =
-                    new_err.getfield ("stack").scalar_map_value ();
-
-                  if (new_err_stack.contains ("file"))
-                    {
-                      const std::string tmp =
-                        new_err_stack.getfield ("file").string_value ();
-                      new_error_file = tmp;
-                    }
+                  const std::string tmp =
+                    new_err_stack.getfield ("name").string_value ();
+                  new_error_name = tmp;
+                }
 
-                  if (new_err_stack.contains ("name"))
-                    {
-                      const std::string tmp =
-                        new_err_stack.getfield ("name").string_value ();
-                      new_error_name = tmp;
-                    }
-
-                  if (new_err_stack.contains ("line"))
-                    {
-                      const int tmp =
-                        new_err_stack.getfield ("line").nint_value ();
-                      new_error_line = tmp;
-                    }
-
-                  if (new_err_stack.contains ("column"))
-                    {
-                      const int tmp =
-                        new_err_stack.getfield ("column").nint_value ();
-                      new_error_column = tmp;
-                    }
+              if (new_err_stack.contains ("line"))
+                {
+                  const int tmp =
+                    new_err_stack.getfield ("line").nint_value ();
+                  new_error_line = tmp;
                 }
 
-              Vlast_error_message = new_error_message;
-              Vlast_error_id = new_error_id;
-
-              if (new_err.contains ("stack"))
+              if (new_err_stack.contains ("column"))
                 {
-                  new_err_stack.setfield ("file", new_error_file);
-                  new_err_stack.setfield ("name", new_error_name);
-                  new_err_stack.setfield ("line", new_error_line);
-                  new_err_stack.setfield ("column", new_error_column);
-                  Vlast_error_stack = new_err_stack;
-                }
-              else
-                {
-                  // No stack field.  Fill it in with backtrace info.
-                  octave_idx_type curr_frame = -1;
-
-                  Vlast_error_stack
-                    = octave_call_stack::backtrace (0, curr_frame);
+                  const int tmp =
+                    new_err_stack.getfield ("column").nint_value ();
+                  new_error_column = tmp;
                 }
             }
-          else
-            error ("lasterror: argument must be a structure or a string");
-        }
+
+          Vlast_error_message = new_error_message;
+          Vlast_error_id = new_error_id;
 
-      retval = err;
+          if (new_err.contains ("stack"))
+            {
+              new_err_stack.setfield ("file", new_error_file);
+              new_err_stack.setfield ("name", new_error_name);
+              new_err_stack.setfield ("line", new_error_line);
+              new_err_stack.setfield ("column", new_error_column);
+              Vlast_error_stack = new_err_stack;
+            }
+          else
+            {
+              // No stack field.  Fill it in with backtrace info.
+              octave_idx_type curr_frame = -1;
+
+              Vlast_error_stack
+                = octave_call_stack::backtrace (0, curr_frame);
+            }
+        }
+      else
+        error ("lasterror: argument must be a structure or a string");
     }
-  else
-    print_usage ();
 
-  return retval;
+  return octave_value (err);
 }
 
 DEFUN (lasterr, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{msg}, @var{msgid}] =} lasterr ()\n\
 @deftypefnx {Built-in Function} {} lasterr (@var{msg})\n\
 @deftypefnx {Built-in Function} {} lasterr (@var{msg}, @var{msgid})\n\
 Query or set the last error message.\n\
@@ -1967,37 +1960,35 @@ With one argument, set the last error me
 With two arguments, also set the last message identifier.\n\
 @seealso{lasterror, error, lastwarn}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
 
-  if (argc < 4)
-    {
-      string_vector argv = args.make_argv ("lasterr");
+  if (argc > 3)
+    print_usage ();
 
-      std::string prev_error_id = Vlast_error_id;
-      std::string prev_error_message = Vlast_error_message;
+  string_vector argv = args.make_argv ("lasterr");
 
-      if (argc > 2)
-        Vlast_error_id = argv(2);
+  std::string prev_error_id = Vlast_error_id;
+  std::string prev_error_message = Vlast_error_message;
 
-      if (argc > 1)
-        Vlast_error_message = argv(1);
+  if (argc > 2)
+    Vlast_error_id = argv(2);
+
+  if (argc > 1)
+    Vlast_error_message = argv(1);
 
-      if (argc == 1 || nargout > 0)
-        {
-          retval(1) = prev_error_id;
-          retval(0) = prev_error_message;
-        }
+  if (argc == 1 || nargout > 0)
+    {
+      retval(1) = prev_error_id;
+      retval(0) = prev_error_message;
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 DEFUN (lastwarn, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {[@var{msg}, @var{msgid}] =} lastwarn ()\n\
 @deftypefnx {Built-in Function} {} lastwarn (@var{msg})\n\
@@ -2012,37 +2003,35 @@ With one argument, set the last warning 
 With two arguments, also set the last message identifier.\n\
 @seealso{warning, lasterror, lasterr}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
 
-  if (argc < 4)
-    {
-      string_vector argv = args.make_argv ("lastwarn");
+  if (argc > 3)
+    print_usage ();
 
-      std::string prev_warning_id = Vlast_warning_id;
-      std::string prev_warning_message = Vlast_warning_message;
+  string_vector argv = args.make_argv ("lastwarn");
 
-      if (argc > 2)
-        Vlast_warning_id = argv(2);
+  std::string prev_warning_id = Vlast_warning_id;
+  std::string prev_warning_message = Vlast_warning_message;
 
-      if (argc > 1)
-        Vlast_warning_message = argv(1);
+  if (argc > 2)
+    Vlast_warning_id = argv(2);
+
+  if (argc > 1)
+    Vlast_warning_message = argv(1);
 
-      if (argc == 1 || nargout > 0)
-        {
-          retval(1) = prev_warning_id;
-          retval(0) = prev_warning_message;
-        }
+  if (argc == 1 || nargout > 0)
+    {
+      retval(1) = prev_warning_id;
+      retval(0) = prev_warning_message;
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 /* FIXME: Deprecated in 4.0 and scheduled for removal in 4.4 */
 DEFUN (__usage__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} usage (@var{msg})\n\
diff --git a/libinterp/corefcn/getgrent.cc b/libinterp/corefcn/getgrent.cc
--- a/libinterp/corefcn/getgrent.cc
+++ b/libinterp/corefcn/getgrent.cc
@@ -68,150 +68,131 @@ DEFUN (getgrent, args, ,
 Return an entry from the group database, opening it if necessary.\n\
 \n\
 Once the end of data has been reached, @code{getgrent} returns 0.\n\
 @seealso{setgrent, endgrent}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = std::string ();
-  retval(0) = 0;
+  if (args.length () != 0)
+    print_usage ();
 
-  int nargin = args.length ();
+  std::string msg;
 
-  if (nargin == 0)
-    {
-      std::string msg;
+  // octave_group::getgrent may set msg.
+  octave_value val = mk_gr_map (octave_group::getgrent (msg));
 
-      retval(1) = msg;
-      retval(0) = mk_gr_map (octave_group::getgrent (msg));
-    }
-  else
-    print_usage ();
+  retval(1) = msg;
+  retval(0) = val;
 
   return retval;
 }
 
 DEFUN (getgrgid, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{grp_struct} =} getgrgid (@var{gid}).\n\
 Return the first entry from the group database with the group ID\n\
 @var{gid}.\n\
 \n\
 If the group ID does not exist in the database, @code{getgrgid} returns 0.\n\
 @seealso{getgrnam}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = std::string ();
-  retval(0) = 0;
+  if (args.length () != 1)
+    print_usage ();
 
-  int nargin = args.length ();
+  double dval = args(0).double_value ();
 
-  if (nargin == 1)
+  if (D_NINT (dval) == dval)
     {
-      double dval = args(0).double_value ();
+      gid_t gid = static_cast<gid_t> (dval);
 
-      if (D_NINT (dval) == dval)
-        {
-          gid_t gid = static_cast<gid_t> (dval);
+      std::string msg;
 
-          std::string msg;
+      // octave_group::getgrgid may set msg.
+      octave_value val = mk_gr_map (octave_group::getgrgid (gid, msg));
 
-          retval(1) = msg;
-          retval(0) = mk_gr_map (octave_group::getgrgid (gid, msg));
-        }
-      else
-        error ("getgrgid: GID must be an integer");
+      retval(1) = msg;
+      retval(0) = val;
     }
+
   else
-    print_usage ();
+    error ("getgrgid: GID must be an integer");
 
   return retval;
 }
 
 DEFUN (getgrnam, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{grp_struct} =} getgrnam (@var{name})\n\
 Return the first entry from the group database with the group name\n\
 @var{name}.\n\
 \n\
 If the group name does not exist in the database, @code{getgrnam} returns 0.\n\
 @seealso{getgrgid}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = std::string ();
-  retval(0) = 0;
+  if (args.length () != 1)
+    print_usage ();
 
-  int nargin = args.length ();
+  std::string s = args(0).string_value ();
 
-  if (nargin == 1)
-    {
-      std::string s = args(0).string_value ();
-
-      std::string msg;
+  std::string msg;
 
-      retval(1) = msg;
-      retval(0) = mk_gr_map (octave_group::getgrnam (s.c_str (), msg));
-    }
-  else
-    print_usage ();
+  // octave_group::getgrnam may set msg.
+  octave_value val = mk_gr_map (octave_group::getgrnam (s.c_str (), msg));
+
+  retval(1) = msg;
+  retval(0) = val;
 
   return retval;
 }
 
 DEFUN (setgrent, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} setgrent ()\n\
 Return the internal pointer to the beginning of the group database.\n\
 @seealso{getgrent, endgrent}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = std::string ();
-  retval(0) = -1.0;
+  if (args.length () != 0)
+    print_usage ();
 
-  int nargin = args.length ();
+  std::string msg;
 
-  if (nargin == 0)
-    {
-      std::string msg;
+  // octave_group::setgrent may set msg.
+  int status = octave_group::setgrent (msg);
 
-      retval(1) = msg;
-      retval(0) = static_cast<double> (octave_group::setgrent (msg));
-    }
-  else
-    print_usage ();
+  retval(1) = msg;
+  retval(0) = static_cast<double> (status);
 
   return retval;
 }
 
 DEFUN (endgrent, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} endgrent ()\n\
 Close the group database.\n\
 @seealso{getgrent, setgrent}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = std::string ();
-  retval(0) = -1.0;
+  if (args.length () != 0)
+    print_usage ();
 
-  int nargin = args.length ();
+  std::string msg;
 
-  if (nargin == 0)
-    {
-      std::string msg;
+  // octave_group::endgrent may set msg.
+  int status = octave_group::endgrent (msg);
 
-      retval(1) = msg;
-      retval(0) = static_cast<double> (octave_group::endgrent (msg));
-    }
-  else
-    print_usage ();
+  retval(1) = msg;
+  retval(0) = static_cast<double> (status);
 
   return retval;
 }
diff --git a/libinterp/corefcn/getpwent.cc b/libinterp/corefcn/getpwent.cc
--- a/libinterp/corefcn/getpwent.cc
+++ b/libinterp/corefcn/getpwent.cc
@@ -72,150 +72,130 @@ Return a structure containing an entry f
 opening it if necessary.\n\
 \n\
 Once the end of the data has been reached, @code{getpwent} returns 0.\n\
 @seealso{setpwent, endpwent}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = std::string ();
-  retval(0) = 0;
+  if (args.length () != 0)
+    print_usage ();
 
-  int nargin = args.length ();
+  std::string msg;
 
-  if (nargin == 0)
-    {
-      std::string msg;
+  // octave_passwd::getpwent may set msg.
+  octave_value val = mk_pw_map (octave_passwd::getpwent (msg));
 
-      retval(1) = msg;
-      retval(0) = mk_pw_map (octave_passwd::getpwent (msg));
-    }
-  else
-    print_usage ();
+  retval(1) = msg;
+  retval(0) = val;
 
   return retval;
 }
 
 DEFUN (getpwuid, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{pw_struct} =} getpwuid (@var{uid}).\n\
 Return a structure containing the first entry from the password database\n\
 with the user ID @var{uid}.\n\
 \n\
 If the user ID does not exist in the database, @code{getpwuid} returns 0.\n\
 @seealso{getpwnam}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = std::string ();
-  retval(0) = 0;
+  if (args.length () != 1)
+    print_usage ();
 
-  int nargin = args.length ();
-
-  if (nargin == 1)
-    {
-      double dval = args(0).double_value ();
+  double dval = args(0).double_value ();
 
-      if (D_NINT (dval) == dval)
-        {
-          uid_t uid = static_cast<uid_t> (dval);
+  if (D_NINT (dval) == dval)
+    {
+      uid_t uid = static_cast<uid_t> (dval);
 
-          std::string msg;
+      std::string msg;
 
-          retval(1) = msg;
-          retval(0) = mk_pw_map (octave_passwd::getpwuid (uid, msg));
-        }
-      else
-        error ("getpwuid: UID must be an integer");
+      // octave_passwd::getpwuid may set msg.
+      octave_value val = mk_pw_map (octave_passwd::getpwuid (uid, msg));
+
+      retval(1) = msg;
+      retval(0) = val;
     }
   else
-    print_usage ();
+    error ("getpwuid: UID must be an integer");
 
   return retval;
 }
 
 DEFUN (getpwnam, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{pw_struct} =} getpwnam (@var{name})\n\
 Return a structure containing the first entry from the password database\n\
 with the user name @var{name}.\n\
 \n\
 If the user name does not exist in the database, @code{getpwname} returns 0.\n\
 @seealso{getpwuid}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = std::string ();
-  retval(0) = 0.0;
+  if (args.length () != 1)
+    print_usage ();
 
-  int nargin = args.length ();
+  std::string s = args(0).string_value ();
 
-  if (nargin == 1)
-    {
-      std::string s = args(0).string_value ();
-
-      std::string msg;
+  std::string msg;
 
-      retval(1) = msg;
-      retval(0) = mk_pw_map (octave_passwd::getpwnam (s, msg));
-    }
-  else
-    print_usage ();
+  // octave_passwd::getpwnam may set msg.
+  octave_value val = mk_pw_map (octave_passwd::getpwnam (s, msg));
+
+  retval(1) = msg;
+  retval(0) = val;
 
   return retval;
 }
 
 DEFUN (setpwent, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} setpwent ()\n\
 Return the internal pointer to the beginning of the password database.\n\
 @seealso{getpwent, endpwent}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = std::string ();
-  retval(0) = -1.0;
+  if (args.length () != 0)
+    print_usage ();
 
-  int nargin = args.length ();
+  std::string msg;
 
-  if (nargin == 0)
-    {
-      std::string msg;
+  // octave_passwd::setpwent may set msg.
+  int status = octave_passwd::setpwent (msg);
 
-      retval(1) = msg;
-      retval(0) = static_cast<double> (octave_passwd::setpwent (msg));
-    }
-  else
-    print_usage ();
+  retval(1) = msg;
+  retval(0) = static_cast<double> (status);
 
   return retval;
 }
 
 DEFUN (endpwent, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} endpwent ()\n\
 Close the password database.\n\
 @seealso{getpwent, setpwent}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = std::string ();
-  retval(0) = -1.0;
+  if (args.length () != 0)
+    print_usage ();
 
-  int nargin = args.length ();
+  std::string msg;
 
-  if (nargin == 0)
-    {
-      std::string msg;
+  // octave_passwd::endpwent may set msg.
+  int status = octave_passwd::endpwent (msg);
 
-      retval(1) = msg;
-      retval(0) = static_cast<double> (octave_passwd::endpwent (msg));
-    }
-  else
-    print_usage ();
+  retval(1) = msg;
+  retval(0) = static_cast<double> (status);
 
   return retval;
 }
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -1086,30 +1086,28 @@ Return the raw help text of function @va
 The raw help text is returned in @var{text} and the format in @var{format}\n\
 The format is a string which is one of @qcode{\"texinfo\"},\n\
 @qcode{\"html\"}, or @qcode{\"plain text\"}.\n\
 @seealso{get_help_text_from_file}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  if (args.length () == 1)
-    {
-      const std::string name = args(0).xstring_value ("get_help_text: NAME must be a string");
+  if (args.length () != 1)
+    print_usage ();
 
-      std::string text;
-      std::string format;
+  const std::string name = args(0).xstring_value ("get_help_text: NAME must be a string");
 
-      do_get_help_text (name, text, format);
+  std::string text;
+  std::string format;
 
-      retval(1) = format;
-      retval(0) = text;
-    }
-  else
-    print_usage ();
+  do_get_help_text (name, text, format);
+
+  retval(1) = format;
+  retval(0) = text;
 
   return retval;
 }
 
 static void
 do_get_help_text_from_file (const std::string& fname, std::string& text,
                             std::string& format)
 {
@@ -1151,30 +1149,28 @@ Return the raw help text from the file @
 The raw help text is returned in @var{text} and the format in @var{format}\n\
 The format is a string which is one of @qcode{\"texinfo\"},\n\
 @qcode{\"html\"}, or @qcode{\"plain text\"}.\n\
 @seealso{get_help_text}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  if (args.length () == 1)
-    {
-      const std::string fname = args(0).xstring_value ("get_help_text_from_file: NAME must be a string");
+  if (args.length () != 1)
+    print_usage ();
 
-      std::string text;
-      std::string format;
+  const std::string fname = args(0).xstring_value ("get_help_text_from_file: NAME must be a string");
 
-      do_get_help_text_from_file (fname, text, format);
+  std::string text;
+  std::string format;
 
-      retval(1) = format;
-      retval(0) = text;
-    }
-  else
-    print_usage ();
+  do_get_help_text_from_file (fname, text, format);
+
+  retval(1) = format;
+  retval(0) = text;
 
   return retval;
 }
 
 // Return a cell array of strings containing the names of all
 // operators.
 
 DEFUN (__operators__, , ,
@@ -1283,53 +1279,47 @@ do_which (const std::string& name)
 }
 
 DEFUN (__which__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __which__ (@var{name}, @dots{})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   string_vector argv = args.make_argv ("which");
 
   int argc = argv.numel ();
 
-  if (argc > 1)
-    {
-      octave_map m (dim_vector (1, argc-1));
-
-      Cell names (1, argc-1);
-      Cell files (1, argc-1);
-      Cell types (1, argc-1);
-
-      for (int i = 1; i < argc; i++)
-        {
-          std::string name = argv[i];
-
-          std::string type;
-
-          std::string file = do_which (name, type);
-
-          names(i-1) = name;
-          files(i-1) = file;
-          types(i-1) = type;
-        }
-
-      m.assign ("name", names);
-      m.assign ("file", files);
-      m.assign ("type", types);
-
-      retval = m;
-    }
-  else
+  if (argc < 2)
     print_usage ();
 
-  return retval;
+  octave_map m (dim_vector (1, argc-1));
+
+  Cell names (1, argc-1);
+  Cell files (1, argc-1);
+  Cell types (1, argc-1);
+
+  for (int i = 1; i < argc; i++)
+    {
+      std::string name = argv[i];
+
+      std::string type;
+
+      std::string file = do_which (name, type);
+
+      names(i-1) = name;
+      files(i-1) = file;
+      types(i-1) = type;
+    }
+
+  m.assign ("name", names);
+  m.assign ("file", files);
+  m.assign ("type", types);
+
+  return octave_value (m);
 }
 
 // FIXME: Are we sure this function always does the right thing?
 inline bool
 file_is_in_dir (const std::string filename, const std::string dir)
 {
   if (filename.find (dir) == 0)
     {
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -2244,35 +2244,36 @@ Return a path constructed from @var{dir}
 If additional string parameters are given, the resulting path will exclude\n\
 directories with those names.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   octave_idx_type nargin = args.length ();
 
+  if (nargin == 0)
+    print_usage ();
+
   if (nargin == 1)
     {
       std::string dirname = args(0).xstring_value ("genpath: DIR must be a string");
 
       retval = genpath (dirname);
     }
-  else if (nargin > 1)
+  else
     {
       std::string dirname = args(0).xstring_value ("genpath: all arguments must be strings");
 
       string_vector skip (nargin - 1);
 
       for (octave_idx_type i = 1; i < nargin; i++)
         skip[i-1] = args(i).xstring_value ("genpath: all arguments must be strings");
 
       retval = genpath (dirname, skip);
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 static void
 rehash_internal (void)
 {
   load_path::update ();
@@ -2414,86 +2415,84 @@ addpath (\"dir1:/dir2:~/dir3\")\n\
   // Originally written by Bill Denney and Etienne Grossman.  Heavily
   // modified and translated to C++ by jwe.
 
   if (nargout > 0)
     retval = load_path::path ();
 
   int nargin = args.length ();
 
-  if (nargin > 0)
+  if (nargin == 0)
+    print_usage ();
+
+  bool append = false;
+
+  octave_value option_arg = args(nargin-1);
+
+  if (option_arg.is_string ())
     {
-      bool append = false;
-
-      octave_value option_arg = args(nargin-1);
-
-      if (option_arg.is_string ())
+      std::string option = option_arg.string_value ();
+
+      if (option == "-end")
         {
-          std::string option = option_arg.string_value ();
-
-          if (option == "-end")
-            {
-              append = true;
-              nargin--;
-            }
-          else if (option == "-begin")
-            nargin--;
+          append = true;
+          nargin--;
         }
-      else if (option_arg.is_numeric_type ())
+      else if (option == "-begin")
+        nargin--;
+    }
+  else if (option_arg.is_numeric_type ())
+    {
+      int val = option_arg.xint_value ("addpath: OPTION must be '-begin'/0 or '-end'/1");
+
+      if (val == 0)
+        nargin--;
+      else if (val == 1)
         {
-          int val = option_arg.xint_value ("addpath: OPTION must be '-begin'/0 or '-end'/1");
-
-          if (val == 0)
-            nargin--;
-          else if (val == 1)
-            {
-              append = true;
-              nargin--;
-            }
-          else
-            {
-              error ("addpath: OPTION must be '-begin'/0 or '-end'/1");
-              return retval;
-            }
+          append = true;
+          nargin--;
         }
-
-      bool need_to_update = false;
-
-      for (int i = 0; i < nargin; i++)
+      else
         {
-          std::string arg = args(i).xstring_value ("addpath: all arguments must be strings");
-
-          std::list<std::string> dir_elts = split_path (arg);
-
-          if (! append)
-            std::reverse (dir_elts.begin (), dir_elts.end ());
-
-          for (std::list<std::string>::const_iterator p = dir_elts.begin ();
-               p != dir_elts.end ();
-               p++)
-            {
-              std::string dir = *p;
-
-              //dir = regexprep (dir_elts{j}, '//+', "/");
-              //dir = regexprep (dir, '/$', "");
-
-              if (append)
-                load_path::append (dir, true);
-              else
-                load_path::prepend (dir, true);
-
-              need_to_update = true;
-            }
+          error ("addpath: OPTION must be '-begin'/0 or '-end'/1");
+          return retval;
         }
-
-      if (need_to_update)
-        rehash_internal ();
     }
-  else
-    print_usage ();
+
+  bool need_to_update = false;
+
+  for (int i = 0; i < nargin; i++)
+    {
+      std::string arg = args(i).xstring_value ("addpath: all arguments must be strings");
+
+      std::list<std::string> dir_elts = split_path (arg);
+
+      if (! append)
+        std::reverse (dir_elts.begin (), dir_elts.end ());
+
+      for (std::list<std::string>::const_iterator p = dir_elts.begin ();
+           p != dir_elts.end ();
+           p++)
+        {
+          std::string dir = *p;
+
+          //dir = regexprep (dir_elts{j}, '//+', "/");
+          //dir = regexprep (dir, '/$', "");
+
+          if (append)
+            load_path::append (dir, true);
+          else
+            load_path::prepend (dir, true);
+
+          need_to_update = true;
+        }
+    }
+
+  if (need_to_update)
+    rehash_internal ();
 
   return retval;
 }
 
 DEFUN (rmpath, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} rmpath (@var{dir1}, @dots{})\n\
 Remove @var{dir1}, @dots{} from the current function search path.\n\
@@ -2512,46 +2511,44 @@ rmpath (\"dir1:/dir2:~/dir3\")\n\
 
   octave_value retval;
 
   if (nargout > 0)
     retval = load_path::path ();
 
   int nargin = args.length ();
 
-  if (nargin > 0)
+  if (nargin == 0)
+    print_usage ();
+
+  bool need_to_update = false;
+
+  for (int i = 0; i < nargin; i++)
     {
-      bool need_to_update = false;
-
-      for (int i = 0; i < nargin; i++)
+      std::string arg = args(i).xstring_value ("rmpath: all arguments must be strings");
+      std::list<std::string> dir_elts = split_path (arg);
+
+      for (std::list<std::string>::const_iterator p = dir_elts.begin ();
+           p != dir_elts.end ();
+           p++)
         {
-          std::string arg = args(i).xstring_value ("rmpath: all arguments must be strings");
-          std::list<std::string> dir_elts = split_path (arg);
-
-          for (std::list<std::string>::const_iterator p = dir_elts.begin ();
-               p != dir_elts.end ();
-               p++)
-            {
-              std::string dir = *p;
-
-              //dir = regexprep (dir_elts{j}, '//+', "/");
-              //dir = regexprep (dir, '/$', "");
-
-              if (! load_path::remove (dir))
-                warning ("rmpath: %s: not found", dir.c_str ());
-              else
-                need_to_update = true;
-            }
+          std::string dir = *p;
+
+          //dir = regexprep (dir_elts{j}, '//+', "/");
+          //dir = regexprep (dir, '/$', "");
+
+          if (! load_path::remove (dir))
+            warning ("rmpath: %s: not found", dir.c_str ());
+          else
+            need_to_update = true;
         }
-
-      if (need_to_update)
-        rehash_internal ();
     }
-  else
-    print_usage ();
+
+  if (need_to_update)
+    rehash_internal ();
 
   return retval;
 }
 
 DEFUN (__dump_load_path__, , , "")
 {
   load_path::display (octave_stdout);
 
diff --git a/libinterp/corefcn/sparse.cc b/libinterp/corefcn/sparse.cc
--- a/libinterp/corefcn/sparse.cc
+++ b/libinterp/corefcn/sparse.cc
@@ -44,22 +44,19 @@ along with Octave; see the file COPYING.
 DEFUN (issparse, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} issparse (@var{x})\n\
 Return true if @var{x} is a sparse matrix.\n\
 @seealso{ismatrix}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
-    {
-      print_usage ();
-      return octave_value ();
-    }
-  else
-    return octave_value (args(0).is_sparse_type ());
+    print_usage ();
+
+  return octave_value (args(0).is_sparse_type ());
 }
 
 DEFUN (sparse, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{s} =} sparse (@var{a})\n\
 @deftypefnx {Built-in Function} {@var{s} =} sparse (@var{i}, @var{j}, @var{sv}, @var{m}, @var{n})\n\
 @deftypefnx {Built-in Function} {@var{s} =} sparse (@var{i}, @var{j}, @var{sv})\n\
 @deftypefnx {Built-in Function} {@var{s} =} sparse (@var{m}, @var{n})\n\
@@ -123,16 +120,19 @@ Compressed Column Sparse (rows = 3, cols
 @end group\n\
 @end example\n\
 @seealso{full, accumarray, spalloc, spdiags, speye, spones, sprand, sprandn, sprandsym, spconvert, spfun}\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
+  if (nargin == 0 || nargin > 6)
+    print_usage ();
+
   // Temporarily disable sparse_auto_mutate if set (it's obsolete anyway).
   unwind_protect frame;
   frame.protect_var (Vsparse_auto_mutate);
   Vsparse_auto_mutate = false;
 
   if (nargin == 1)
     {
       octave_value arg = args(0);
@@ -183,18 +183,16 @@ Compressed Column Sparse (rows = 3, cols
 
       if (nargin == 5)
         {
           get_dimensions (args(3), args(4), "sparse", m, n);
 
           if (m < 0 || n < 0)
             error ("sparse: dimensions must be non-negative");
         }
-      else if (nargin != 3)
-        print_usage ();
 
       int k = 0;    // index we're checking when index_vector throws
       try
         {
           idx_vector i = args(0).index_vector ();
           k = 1;
           idx_vector j = args(1).index_vector ();
 
@@ -255,29 +253,28 @@ it is possible to efficiently build a pr
 contiguous block of columns.\n\
 \n\
 The amount of pre-allocated memory for a given matrix may be queried using\n\
 the function @code{nzmax}.\n\
 @seealso{nzmax, sparse}\n\
 @end deftypefn")
 {
   octave_value retval;
+
   int nargin = args.length ();
 
-  if (nargin == 2 || nargin == 3)
-    {
-      octave_idx_type m = args(0).idx_type_value ();
-      octave_idx_type n = args(1).idx_type_value ();
-      octave_idx_type nz = 0;
+  if (nargin < 2 || nargin > 3)
+    print_usage ();
+
+  octave_idx_type m = args(0).idx_type_value ();
+  octave_idx_type n = args(1).idx_type_value ();
+  octave_idx_type nz = 0;
 
-      if (nargin == 3)
-        nz = args(2).idx_type_value ();
+  if (nargin == 3)
+    nz = args(2).idx_type_value ();
 
-      if (m >= 0 && n >= 0 && nz >= 0)
-        retval = SparseMatrix (dim_vector (m, n), nz);
-      else
-        error ("spalloc: M,N,NZ must be non-negative");
-    }
+  if (m >= 0 && n >= 0 && nz >= 0)
+    retval = SparseMatrix (dim_vector (m, n), nz);
   else
-    print_usage ();
+    error ("spalloc: M,N,NZ must be non-negative");
 
   return retval;
 }
diff --git a/scripts/statistics/base/mode.m b/scripts/statistics/base/mode.m
--- a/scripts/statistics/base/mode.m
+++ b/scripts/statistics/base/mode.m
@@ -106,21 +106,22 @@ endfunction
 %! assert (c, {[1;2;3;4;5],[2],[2;3],[2],[1;2;3;4;5]});
 %!test
 %! [m, f, c] = mode (toeplitz (1:5), 2);
 %! assert (m, [1;2;2;2;1]);
 %! assert (f, [1;2;2;2;1]);
 %! assert (c, {[1;2;3;4;5];[2];[2;3];[2];[1;2;3;4;5]});
 %!test
 %! a = sprandn (32, 32, 0.05);
+%! sp0 = sparse (0);
 %! [m, f, c] = mode (a);
 %! [m2, f2, c2] = mode (full (a));
 %! assert (m, sparse (m2));
 %! assert (f, sparse (f2));
-%! c_exp(1:length (a)) = { sparse (0) };
+%! c_exp(1:length (a)) = { sp0 };
 %! assert (c ,c_exp);
 %! assert (c2,c_exp );
 
 %!assert (mode ([2,3,1,2,3,4],1),[2,3,1,2,3,4])
 %!assert (mode ([2,3,1,2,3,4],2),2)
 %!assert (mode ([2,3,1,2,3,4]),2)
 %!assert (mode (single ([2,3,1,2,3,4])), single (2))
 %!assert (mode (int8 ([2,3,1,2,3,4])), int8 (2))
