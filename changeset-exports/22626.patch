# HG changeset patch
# User Rik <rik@octave.org>
# Date 1476596369 25200
#      Sat Oct 15 22:39:29 2016 -0700
# Branch stable
# Node ID 869c02fde46c3c22d408f3926ef2f71424862014
# Parent  081a201b77c750671556d581482a446d0f4d0379
Further clean-up of ode functions.

* scripts/ode/private/AbsRel_Norm.m: Renamed to AbsRel_norm.m

* scripts/ode/module.mk: Add AbsRel_norm.m to build system.

* ode23.m, ode45.m: Remove extra comma from Copyright statement.
Add ode45 to @seealso links in docstring.
Add FIXME notes for questionable code.
Use numel instead of length for clarity.
Use space after function name and opening parenthesis.
Wrap long lines to less than 80 characters.
Change odemergeopts function call to match new prototype.
Use single quotes to simplify strings that contain double quotes.
Use 2-space indent in %!function blocks.

* odeget.m: Remove extra comma from Copyright statement.
Use double quote in preference to single quote.
Delete whitespace at end of lines.

* odeplot.m: Re-write docstring.  Include @seealso links in docstring.
Declare all persistent variables in a single declaration.
Use in-place += operator for efficiency.
Add FIXME notes for questionable code.

* odeset.m: Remove extra comma from Copyright statement.
Add additional calling form with 1 output and 0 inputs to docstring.
Add FIXME notes for questionable code.
Delete whitespace at end of lines.
* odeset.m(print_options): Use single quotes to simplify strings with double
quotes.  Put default value of option first in list.

* integrate_adaptive.m: Wrap long lines < 80 characters.
Delete whitespace at end of lines.
Correct indentation of declared values after '='.

* kahan.m: Reise docstring.

* ode_event_handler.m: Use retval in docstring to match functin prototype.
Delete unnecessary comments.

* odedefaults.m: Remove extra comma from Copyright statement.
Match variable names in docstring to function prototype.
Use space after function name and before opening parenthesis.
Delete whitespace at end of lines.

* odemergeopts.m: Remove extra comma from Copyright statement.
Delete extra space in function prototype.
Change function prototype to have "caller" as first argument to match rest of
Octave.

* runge_kutta_23.m: Clean up declaration of persistent variables.
Correct misspellings in comments.

* runge_kutta_45_dorpri.m: Put description of input arguments before output
arguments in docstring.
 Clean up declaration of persistent variables.

* runge_kutta_interpolate.m: Use double quotes in preference to single quotes.
Eliminate line continuations for code that would fit on a single line.
Remove obsolete code that calls non-existent functions.
Capitalize Hermite in comments.
Cleanup declaration of persistent variables.

* starting_stepsize.m: Replace calls to AbsRel_Norm with AbsRel_norm.

diff --git a/scripts/ode/module.mk b/scripts/ode/module.mk
--- a/scripts/ode/module.mk
+++ b/scripts/ode/module.mk
@@ -1,14 +1,14 @@
 FCN_FILE_DIRS += \
   scripts/ode \
   scripts/ode/private
 
 scripts_ode_PRIVATE_FCN_FILES = \
-  scripts/ode/private/AbsRel_Norm.m \
+  scripts/ode/private/AbsRel_norm.m \
   scripts/ode/private/integrate_adaptive.m \
   scripts/ode/private/kahan.m \
   scripts/ode/private/odedefaults.m \
   scripts/ode/private/odemergeopts.m \
   scripts/ode/private/ode_event_handler.m \
   scripts/ode/private/runge_kutta_23.m \
   scripts/ode/private/runge_kutta_45_dorpri.m \
   scripts/ode/private/runge_kutta_interpolate.m \
diff --git a/scripts/ode/ode23.m b/scripts/ode/ode23.m
--- a/scripts/ode/ode23.m
+++ b/scripts/ode/ode23.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2016, Carlo de Falco
-## Copyright (C) 2016, Francesco Faccio <francesco.faccio@mail.polimi.it>
+## Copyright (C) 2016 Carlo de Falco
+## Copyright (C) 2016 Francesco Faccio <francesco.faccio@mail.polimi.it>
 ## Copyright (C) 2014-2016 Jacopo Corno <jacopo.corno@gmail.com>
 ## Copyright (C) 2013-2016 Roberto Porcu' <roberto.porcu@polimi.it>
 ## Copyright (C) 2006-2016 Thomas Treichl <treichl@users.sourceforge.net>
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
@@ -81,19 +81,20 @@
 ## Example: Solve the @nospell{Van der Pol} equation
 ##
 ## @example
 ## @group
 ## fvdp = @@(@var{t},@var{y}) [@var{y}(2); (1 - @var{y}(1)^2) * @var{y}(2) - @var{y}(1)];
 ## [@var{t},@var{y}] = ode23 (fvdp, [0, 20], [2, 0]);
 ## @end group
 ## @end example
-## @seealso{odeset, odeget}
+## @seealso{odeset, odeget, ode45}
 ## @end deftypefn
 
+## FIXME: We store ChangeLog information in Mercurial.  Can this be deleted?
 ## ChangeLog:
 ##   20010703 the function file "ode23.m" was written by Marc Compere
 ##     under the GPL for the use with this software.  This function has been
 ##     taken as a base for the following implementation.
 ##   20060810, Thomas Treichl
 ##     This function was adapted to the new syntax that is used by the
 ##     new OdePkg for Octave and is compatible to Matlab's ode23.
 
@@ -106,35 +107,35 @@ function varargout = ode23 (fun, trange,
   order  = 3;
   solver = "ode23";
 
   if (nargin >= 4)
     if (! isstruct (varargin{1}))
       ## varargin{1:len} are parameters for fun
       odeopts = odeset ();
       funarguments = varargin;
-    elseif (length (varargin) > 1)
+    elseif (numel (varargin) > 1)
       ## varargin{1} is an ODE options structure opt
       odeopts = varargin{1};
-      funarguments = {varargin{2:length(varargin)}};
+      funarguments = {varargin{2:numel (varargin)}};
     else  # if (isstruct (varargin{1}))
       odeopts = varargin{1};
       funarguments = {};
     endif
   else  # nargin == 3
     odeopts = odeset ();
     funarguments = {};
   endif
 
   if (! isnumeric (trange) || ! isvector (trange))
     error ("Octave:invalid-input-arg",
            "ode23: TRANGE must be a numeric vector");
   endif
 
-  if (length (trange) < 2)
+  if (numel (trange) < 2)
     error ("Octave:invalid-input-arg",
            "ode23: TRANGE must contain at least 2 elements");
   elseif (trange(2) == trange(1))
     error ("Octave:invalid-input-arg",
            "ode23: invalid time span, TRANGE(1) == TRANGE(2)");
   else
     direction = sign (trange(2) - trange(1));
   endif
@@ -153,110 +154,105 @@ function varargout = ode23 (fun, trange,
       warning (lasterr);
     end_try_catch
   endif
   if (! isa (fun, "function_handle"))
     error ("Octave:invalid-input-arg",
            "ode23: FUN must be a valid function handle");
   endif
 
-
   ## Start preprocessing, have a look which options are set in odeopts,
-  ## check if an invalid or unused option is set
-
-
+  ## check if an invalid or unused option is set.
+  ## FIXME: Why persistent?  Won't these have different values for every
+  ##        run of ode23?
   persistent defaults   = [];
   persistent classes    = [];
   persistent attributes = [];
 
-
-  [defaults, classes, attributes] = odedefaults (numel (init), trange(1),
-                                                 trange(end));
+  [defaults, classes, attributes] = odedefaults (numel (init),
+                                                 trange(1), trange(end));
 
   defaults   = rmfield (defaults,   {"Jacobian", "JPattern", "Vectorized", ...
                                      "MvPattern", "MassSingular", ...
                                      "InitialSlope", "MaxOrder", "BDF"});
   classes    = rmfield (classes,    {"Jacobian", "JPattern", "Vectorized", ...
                                      "MvPattern", "MassSingular", ...
                                      "InitialSlope", "MaxOrder", "BDF"});
   attributes = rmfield (attributes, {"Jacobian", "JPattern", "Vectorized", ...
                                      "MvPattern", "MassSingular", ...
                                      "InitialSlope", "MaxOrder", "BDF"});
 
-  odeopts = odemergeopts (odeopts, defaults, classes, attributes, 'ode23');
+  odeopts = odemergeopts ("ode23", odeopts, defaults, classes, attributes);
 
   odeopts.funarguments = funarguments;
   odeopts.direction    = direction;
 
   if (! isempty (odeopts.NonNegative))
     if (isempty (odeopts.Mass))
       odeopts.havenonnegative = true;
     else
       odeopts.havenonnegative = false;
       warning ("Octave:invalid-input-arg",
-               ["ode23: option \"NonNegative\" is ignored", ...
+               ['ode23: option "NonNegative" is ignored', ...
                 " when mass matrix is set\n"]);
     endif
   else
     odeopts.havenonnegative = false;
   endif
 
   if (isempty (odeopts.OutputFcn) && nargout == 0)
     odeopts.OutputFcn = @odeplot;
     odeopts.haveoutputfunction = true;
   else
     odeopts.haveoutputfunction = ! isempty (odeopts.OutputFcn);
   endif
 
   if (isempty (odeopts.InitialStep))
     odeopts.InitialStep = odeopts.direction * ...
-                          starting_stepsize (order, fun, trange(1),
-                                             init, odeopts.AbsTol,
-                                             odeopts.RelTol,
-                                             strcmp (odeopts.NormControl,
-                                                     "on"), odeopts.funarguments);
+                          starting_stepsize (order, fun, trange(1), init,
+                                             odeopts.AbsTol, odeopts.RelTol,
+                                             strcmp (odeopts.NormControl, "on"),
+                                             odeopts.funarguments);
   endif
 
-
   if (! isempty (odeopts.Mass) && isnumeric (odeopts.Mass))
     havemasshandle = false;
     mass = odeopts.Mass;    # constant mass
   elseif (isa (odeopts.Mass, "function_handle"))
     havemasshandle = true;  # mass defined by a function handle
   else  # no mass matrix - creating a diag-matrix of ones for mass
     havemasshandle = false; # mass = diag (ones (length (init), 1), 0);
   endif
 
-
   ## Starting the initialization of the core solver ode23
 
   if (havemasshandle)   # Handle only the dynamic mass matrix,
-    if (! strcmp (odeopts.MStateDependence, "none")) # constant mass matrices have already
+    if (! strcmp (odeopts.MStateDependence, "none"))
+      ## FIXME: How is this comment supposed to end?
+      ## constant mass matrices have already
       mass = @(t,x) odeopts.Mass (t, x, odeopts.funarguments{:});
       fun = @(t,x) mass (t, x, odeopts.funarguments{:}) ...
-            \ fun (t, x, odeopts.funarguments{:});
-    else                 # if ((! strcmp (odeopts.MStateDependence, "none")) == false)
+                   \ fun (t, x, odeopts.funarguments{:});
+    else
       mass = @(t) odeopts.Mass (t, odeopts.funarguments{:});
       fun = @(t,x) mass (t, odeopts.funarguments{:}) ...
-            \ fun (t, x, odeopts.funarguments{:});
+                   \ fun (t, x, odeopts.funarguments{:});
     endif
   endif
 
-
-  solution = integrate_adaptive (@runge_kutta_23, ...
+  solution = integrate_adaptive (@runge_kutta_23,
                                  order, fun, trange, init, odeopts);
 
-
   ## Postprocessing, do whatever when terminating integration algorithm
   if (odeopts.haveoutputfunction)  # Cleanup plotter
-    feval (odeopts.OutputFcn, solution.t(end), ...
+    feval (odeopts.OutputFcn, solution.t(end),
            solution.x(end,:)', "done", odeopts.funarguments{:});
   endif
   if (! isempty (odeopts.Events))   # Cleanup event function handling
-    ode_event_handler (odeopts.Events, solution.t(end), ...
+    ode_event_handler (odeopts.Events, solution.t(end),
                        solution.x(end,:)', "done", odeopts.funarguments{:});
   endif
 
   ## Print additional information if option Stats is set
   if (strcmp (odeopts.Stats, "on"))
     nsteps    = solution.cntloop;             # cntloop from 2..end
     nfailed   = solution.cntcycles - nsteps;  # cntcycl from 1..end
     nfevals   = 3 * solution.cntcycles + 1;   # number of ode evaluations
@@ -302,17 +298,16 @@ function varargout = ode23 (fun, trange,
       varargout{5} = solution.event{2};  # Index info which event occurred
     endif
   endif
 
 endfunction
 
 
 %!demo
-%!
 %! ## Demonstrate convergence order for ode23
 %! tol = 1e-5 ./ 10.^[0:8];
 %! for i = 1 : numel (tol)
 %!   opt = odeset ("RelTol", tol(i), "AbsTol", realmin);
 %!   [t, y] = ode23 (@(t, y) -y, [0, 1], 1, opt);
 %!   h(i) = 1 / (numel (t) - 1);
 %!   err(i) = norm (y .* exp (t) - 1, Inf);
 %! endfor
@@ -331,55 +326,55 @@ endfunction
 %! title ("Convergence plot for ode23");
 %! legend ("imposed tolerance", "ode23 (relative) error",
 %!         "order 2", "order 3", "location", "northwest");
 
 ## We are using the "Van der Pol" implementation for all tests that are done
 ## for this function.
 ## For further tests we also define a reference solution (computed at high
 ## accuracy)
-%!function ydot = fpol (t, y)  # The Van der Pol
-%! ydot = [y(2); (1 - y(1)^2) * y(2) - y(1)];
+%!function ydot = fpol (t, y)  # The Van der Pol ODE
+%!  ydot = [y(2); (1 - y(1)^2) * y(2) - y(1)];
 %!endfunction
 %!function ref = fref ()       # The computed reference sol
-%! ref = [0.32331666704577, -1.83297456798624];
+%!  ref = [0.32331666704577, -1.83297456798624];
 %!endfunction
 %!function jac = fjac (t, y, varargin)  # its Jacobian
-%! jac = [0, 1; -1 - 2 * y(1) * y(2), 1 - y(1)^2];
+%!  jac = [0, 1; -1 - 2 * y(1) * y(2), 1 - y(1)^2];
 %!endfunction
 %!function jac = fjcc (t, y, varargin)  # sparse type
-%! jac = sparse ([0, 1; -1 - 2 * y(1) * y(2), 1 - y(1)^2]);
+%!  jac = sparse ([0, 1; -1 - 2 * y(1) * y(2), 1 - y(1)^2]);
 %!endfunction
 %!function [val, trm, dir] = feve (t, y, varargin)
-%! val = fpol (t, y, varargin);    # We use the derivatives
-%! trm = zeros (2,1);              # that's why component 2
-%! dir = ones (2,1);               # seems to not be exact
+%!  val = fpol (t, y, varargin);    # We use the derivatives
+%!  trm = zeros (2,1);              # that's why component 2
+%!  dir = ones (2,1);               # does not seem to be exact
 %!endfunction
 %!function [val, trm, dir] = fevn (t, y, varargin)
-%! val = fpol (t, y, varargin);    # We use the derivatives
-%! trm = ones (2,1);               # that's why component 2
-%! dir = ones (2,1);               # seems to not be exact
+%!  val = fpol (t, y, varargin);    # We use the derivatives
+%!  trm = ones (2,1);               # that's why component 2
+%!  dir = ones (2,1);               # does not seem to be exact
 %!endfunction
 %!function mas = fmas (t, y, varargin)
-%! mas = [1, 0; 0, 1];             # Dummy mass matrix for tests
+%!  mas = [1, 0; 0, 1];             # Dummy mass matrix for tests
 %!endfunction
 %!function mas = fmsa (t, y, varargin)
-%! mas = sparse ([1, 0; 0, 1]);    # A sparse dummy matrix
+%!  mas = sparse ([1, 0; 0, 1]);    # A sparse dummy matrix
 %!endfunction
 %!function out = fout (t, y, flag, varargin)
-%! if (regexp (char (flag), "init") == 1)
-%!   if (any (size (t) != [2, 1])) error ("\"fout\" step \"init\""); endif
-%! elseif (isempty (flag))
-%!   if (any (size (t) != [1, 1])) error ("\"fout\" step \"calc\""); endif
-%!   out = false;
-%! elseif (regexp (char (flag), "done") == 1)
-%!   if (any (size (t) != [1, 1])) error ("\"fout\" step \"done\""); endif
-%! else
-%!   error ("\"fout\" invalid flag");
-%! endif
+%!  if (regexp (char (flag), "init") == 1)
+%!    if (any (size (t) != [2, 1])) error ('"fout" step "init"'); endif
+%!  elseif (isempty (flag))
+%!    if (any (size (t) != [1, 1])) error ('"fout" step "calc"'); endif
+%!    out = false;
+%!  elseif (regexp (char (flag), "done") == 1)
+%!    if (any (size (t) != [1, 1])) error ('"fout" step "done"'); endif
+%!  else
+%!    error ('"fout" invalid flag');
+%!  endif
 %!endfunction
 %!
 %!test  # two output arguments
 %! [t, y] = ode23 (@fpol, [0 2], [2 0]);
 %! assert ([t(end), y(end,:)], [2, fref], 1e-3);
 %!test  # anonymous function instead of real function
 %! fvdb = @(t,y) [y(2); (1 - y(1)^2) * y(2) - y(1)];
 %! [t, y] = ode23 (fvdb, [0 2], [2 0]);
@@ -482,32 +477,26 @@ endfunction
 %!test  # Mass option as function and sparse matrix
 %! opt = odeset ("Mass", @fmsa);
 %! sol = ode23 (@fpol, [0 2], [2 0], opt);
 %! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
 %!test  # Mass option as function and MStateDependence
 %! opt = odeset ("Mass", @fmas, "MStateDependence", "strong");
 %! sol = ode23 (@fpol, [0 2], [2 0], opt);
 %! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
-%!
-%! ## test for MvPattern option is missing
-%! ## test for InitialSlope option is missing
-%! ## test for MaxOrder option is missing
+
+## FIXME: Missing tests.
+## test for MvPattern option is missing
+## test for InitialSlope option is missing
+## test for MaxOrder option is missing
 
 ## Test input validation
 %!error ode23 ()
 %!error ode23 (1)
 %!error ode23 (1,2)
-%!error <TRANGE must be a numeric>
-%!  ode23 (@fpol, {[0 25]}, [3 15 1]);
-%!error <TRANGE must be a .* vector>
-%!  ode23 (@fpol, [0 25; 25 0], [3 15 1]);
-%!error <TRANGE must contain at least 2 elements>
-%!  ode23 (@fpol, [1], [3 15 1]);
-%!error <invalid time span>
-%!  ode23 (@fpol, [1 1], [3 15 1]);
-%!error <INIT must be a numeric>
-%!  ode23 (@fpol, [0 25], {[3 15 1]});
-%!error <INIT must be a .* vector>
-%!  ode23 (@fpol, [0 25], [3 15 1; 3 15 1]);
-%!error <FUN must be a valid function handle>
-%!  ode23 (1, [0 25], [3 15 1]);
+%!error <TRANGE must be a numeric> ode23 (@fpol, {[0 25]}, [3 15 1])
+%!error <TRANGE must be a .* vector> ode23 (@fpol, [0 25; 25 0], [3 15 1])
+%!error <TRANGE must contain at least 2 elements> ode23 (@fpol, [1], [3 15 1])
+%!error <invalid time span>  ode23 (@fpol, [1 1], [3 15 1])
+%!error <INIT must be a numeric> ode23 (@fpol, [0 25], {[3 15 1]})
+%!error <INIT must be a .* vector> ode23 (@fpol, [0 25], [3 15 1; 3 15 1])
+%!error <FUN must be a valid function handle> ode23 (1, [0 25], [3 15 1])
 
diff --git a/scripts/ode/ode45.m b/scripts/ode/ode45.m
--- a/scripts/ode/ode45.m
+++ b/scripts/ode/ode45.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2016, Carlo de Falco
-## Copyright (C) 2016, Francesco Faccio <francesco.faccio@mail.polimi.it>
+## Copyright (C) 2016 Carlo de Falco
+## Copyright (C) 2016 Francesco Faccio <francesco.faccio@mail.polimi.it>
 ## Copyright (C) 2014-2016 Jacopo Corno <jacopo.corno@gmail.com>
 ## Copyright (C) 2013-2016 Roberto Porcu' <roberto.porcu@polimi.it>
 ## Copyright (C) 2006-2012 Thomas Treichl <treichl@users.sourceforge.net>
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
@@ -72,53 +72,52 @@
 ## Example: Solve the @nospell{Van der Pol} equation
 ##
 ## @example
 ## @group
 ## fvdp = @@(@var{t},@var{y}) [@var{y}(2); (1 - @var{y}(1)^2) * @var{y}(2) - @var{y}(1)];
 ## [@var{t},@var{y}] = ode45 (fvdp, [0, 20], [2, 0]);
 ## @end group
 ## @end example
-## @seealso{odeset, odeget}
+## @seealso{odeset, odeget, ode23}
 ## @end deftypefn
 
 function varargout = ode45 (fun, trange, init, varargin)
 
   if (nargin < 3)
     print_usage ();
   endif
 
   order  = 5;  # runge_kutta_45_dorpri uses local extrapolation
   solver = "ode45";
 
   if (nargin >= 4)
     if (! isstruct (varargin{1}))
       ## varargin{1:len} are parameters for fun
       odeopts = odeset ();
       funarguments = varargin;
-    elseif (length (varargin) > 1)
+    elseif (numel (varargin) > 1)
       ## varargin{1} is an ODE options structure opt
       odeopts = varargin{1};
-      funarguments = {varargin{2:length(varargin)}};
+      funarguments = {varargin{2:numel (varargin)}};
     else  # if (isstruct (varargin{1}))
       odeopts = varargin{1};
       funarguments = {};
     endif
   else  # nargin == 3
     odeopts = odeset ();
     funarguments = {};
   endif
 
   if (! isnumeric (trange) || ! isvector (trange))
     error ("Octave:invalid-input-arg",
            "ode45: TRANGE must be a numeric vector");
   endif
 
-
-  if (length (trange) < 2)
+  if (numel (trange) < 2)
     error ("Octave:invalid-input-arg",
            "ode45: TRANGE must contain at least 2 elements");
   elseif (trange(1) == trange(2))
     error ("Octave:invalid-input-arg",
            "ode45: invalid time span, TRANGE(1) == TRANGE(2)");
   else
     direction = sign (trange(2) - trange(1));
   endif
@@ -137,110 +136,104 @@ function varargout = ode45 (fun, trange,
       warning (lasterr);
     end_try_catch
   endif
   if (! isa (fun, "function_handle"))
     error ("Octave:invalid-input-arg",
            "ode45: FUN must be a valid function handle");
   endif
 
-
   ## Start preprocessing, have a look which options are set in odeopts,
   ## check if an invalid or unused option is set
-
+  ## FIXME: Why persistent when it is changed with every run of ode45?
   persistent defaults   = [];
   persistent classes    = [];
   persistent attributes = [];
 
+  [defaults, classes, attributes] = odedefaults (numel (init),
+                                                 trange(1), trange(end));
 
-  [defaults, classes, attributes] = odedefaults (numel (init), trange(1),
-                                                 trange(end));
-
-  defaults   = odeset (defaults, 'Refine', 4);
+  defaults   = odeset (defaults, "Refine", 4);
   defaults   = rmfield (defaults,   {"Jacobian", "JPattern", "Vectorized", ...
                                      "MvPattern", "MassSingular", ...
                                      "InitialSlope", "MaxOrder", "BDF"});
   classes    = rmfield (classes,    {"Jacobian", "JPattern", "Vectorized", ...
                                      "MvPattern", "MassSingular", ...
                                      "InitialSlope", "MaxOrder", "BDF"});
   attributes = rmfield (attributes, {"Jacobian", "JPattern", "Vectorized", ...
                                      "MvPattern", "MassSingular", ...
                                      "InitialSlope", "MaxOrder", "BDF"});
 
-  odeopts = odemergeopts (odeopts, defaults, classes, attributes, 'ode45');
+  odeopts = odemergeopts ("ode45", odeopts, defaults, classes, attributes);
 
   odeopts.funarguments = funarguments;
   odeopts.direction    = direction;
 
   if (! isempty (odeopts.NonNegative))
     if (isempty (odeopts.Mass))
       odeopts.havenonnegative = true;
     else
       odeopts.havenonnegative = false;
       warning ("Octave:invalid-input-arg",
-               ["ode45: option 'NonNegative' is ignored", ...
+               ['ode45: option "NonNegative" is ignored', ...
                 " when mass matrix is set\n"]);
     endif
   else
     odeopts.havenonnegative = false;
   endif
 
   if (isempty (odeopts.OutputFcn) && nargout == 0)
     odeopts.OutputFcn = @odeplot;
     odeopts.haveoutputfunction = true;
   else
     odeopts.haveoutputfunction = ! isempty (odeopts.OutputFcn);
   endif
 
   if (isempty (odeopts.InitialStep))
     odeopts.InitialStep = odeopts.direction * ...
-                          starting_stepsize (order, fun, trange(1),
-                                             init, odeopts.AbsTol,
-                                             odeopts.RelTol,
-                                             strcmp (odeopts.NormControl,
-                                                     "on"), odeopts.funarguments);
+                          starting_stepsize (order, fun, trange(1), init,
+                                             odeopts.AbsTol, odeopts.RelTol,
+                                             strcmp (odeopts.NormControl, "on"),
+                                             odeopts.funarguments);
   endif
 
-
   if (! isempty (odeopts.Mass) && isnumeric (odeopts.Mass))
     havemasshandle = false;
     mass = odeopts.Mass;  # constant mass
   elseif (isa (odeopts.Mass, "function_handle"))
     havemasshandle = true;    # mass defined by a function handle
   else  # no mass matrix - creating a diag-matrix of ones for mass
     havemasshandle = false;   # mass = diag (ones (length (init), 1), 0);
   endif
 
-
   ## Starting the initialization of the core solver ode45
 
   if (havemasshandle)   # Handle only the dynamic mass matrix,
-    if (! strcmp (odeopts.MStateDependence, "none")) # constant mass matrices have already
+    if (! strcmp (odeopts.MStateDependence, "none"))
+      ### constant mass matrices have already
       mass = @(t,x) odeopts.Mass (t, x, odeopts.funarguments{:});
       fun = @(t,x) mass (t, x, odeopts.funarguments{:}) ...
-            \ fun (t, x, odeopts.funarguments{:});
-    else                 # if ((! strcmp (odeopts.MStateDependence, "none")) == false)
+                   \ fun (t, x, odeopts.funarguments{:});
+    else
       mass = @(t) odeopts.Mass (t, odeopts.funarguments{:});
       fun = @(t,x) mass (t, odeopts.funarguments{:}) ...
-            \ fun (t, x, odeopts.funarguments{:});
+                   \ fun (t, x, odeopts.funarguments{:});
     endif
   endif
 
-
   solution = integrate_adaptive (@runge_kutta_45_dorpri,
                                  order, fun, trange, init, odeopts);
 
-
   ## Postprocessing, do whatever when terminating integration algorithm
   if (odeopts.haveoutputfunction)  # Cleanup plotter
-    feval (odeopts.OutputFcn, solution.t(end), ...
+    feval (odeopts.OutputFcn, solution.t(end),
            solution.x(end,:)', "done", odeopts.funarguments{:});
   endif
   if (! isempty (odeopts.Events))   # Cleanup event function handling
-    ode_event_handler (odeopts.Events, solution.t(end), ...
+    ode_event_handler (odeopts.Events, solution.t(end),
                        solution.x(end,:)', "done", odeopts.funarguments{:});
   endif
 
   ## Print additional information if option Stats is set
   if (strcmp (odeopts.Stats, "on"))
     nsteps    = solution.cntloop;             # cntloop from 2..end
     nfailed   = solution.cntcycles - nsteps;  # cntcycl from 1..end
     nfevals   = 6 * solution.cntcycles + 1;   # number of ode evaluations
@@ -286,84 +279,83 @@ function varargout = ode45 (fun, trange,
       varargout{5} = solution.event{2};  # Index info which event occurred
     endif
   endif
 
 endfunction
 
 
 %!demo
-%!
 %! ## Demonstrate convergence order for ode45
 %! tol = 1e-5 ./ 10.^[0:8];
 %! for i = 1 : numel (tol)
 %!   opt = odeset ("RelTol", tol(i), "AbsTol", realmin);
 %!   [t, y] = ode45 (@(t, y) -y, [0, 1], 1, opt);
 %!   h(i) = 1 / (numel (t) - 1);
 %!   err(i) = norm (y .* exp (t) - 1, Inf);
 %! endfor
 %!
 %! ## Estimate order numerically
 %! p = diff (log (err)) ./ diff (log (h))
 %!
 %! ## Estimate order visually
 %! loglog (h, tol, "-ob",
 %!         h, err, "-b",
 %!         h, (h/h(end)) .^ 4 .* tol(end), "k--",
-%!         h, (h/h(end)) .^ 5 .* tol(end), "k-")
+%!         h, (h/h(end)) .^ 5 .* tol(end), "k-");
 %! axis tight
 %! xlabel ("h");
 %! ylabel ("err(h)");
 %! title ("Convergence plot for ode45");
 %! legend ("imposed tolerance", "ode45 (relative) error",
 %!         "order 4", "order 5", "location", "northwest");
 
-## We are using the "Van der Pol" implementation for all tests that are done
+## We are using the Van der Pol equation for all tests that are done
 ## for this function.
 ## For further tests we also define a reference solution (computed at high
 ## accuracy)
-%!function ydot = fpol (t, y)  # The Van der Pol
-%! ydot = [y(2); (1 - y(1)^2) * y(2) - y(1)];
+%!function ydot = fpol (t, y)  # The Van der Pol ODE
+%!  ydot = [y(2); (1 - y(1)^2) * y(2) - y(1)];
 %!endfunction
 %!function ref = fref ()       # The computed reference solution
-%! ref = [0.32331666704577, -1.83297456798624];
+%!  ref = [0.32331666704577, -1.83297456798624];
 %!endfunction
 %!function jac = fjac (t, y, varargin)  # its Jacobian
-%! jac = [0, 1; -1 - 2 * y(1) * y(2), 1 - y(1)^2];
+%!  jac = [0, 1; -1 - 2 * y(1) * y(2), 1 - y(1)^2];
 %!endfunction
 %!function jac = fjcc (t, y, varargin)  # sparse type
-%! jac = sparse ([0, 1; -1 - 2 * y(1) * y(2), 1 - y(1)^2]);
+%!  jac = sparse ([0, 1; -1 - 2 * y(1) * y(2), 1 - y(1)^2]);
 %!endfunction
 %!function [val, trm, dir] = feve (t, y, varargin)
-%! val = fpol (t, y, varargin);    # We use the derivatives
-%! trm = zeros (2,1);              # that's why component 2
-%! dir = ones (2,1);               # seems to not be exact
+%!  val = fpol (t, y, varargin);    # We use the derivatives
+%!  trm = zeros (2,1);              # that's why component 2
+%!  dir = ones (2,1);               # does not seem to be exact
 %!endfunction
 %!function [val, trm, dir] = fevn (t, y, varargin)
-%! val = fpol (t, y, varargin);    # We use the derivatives
-%! trm = ones (2,1);               # that's why component 2
-%! dir = ones (2,1);               # seems to not be exact
+%!  val = fpol (t, y, varargin);    # We use the derivatives
+%!  trm = ones (2,1);               # that's why component 2
+%!  dir = ones (2,1);               # does not seem to be exact
 %!endfunction
 %!function mas = fmas (t, y, varargin)
-%! mas = [1, 0; 0, 1];            # Dummy mass matrix for tests
+%!  mas = [1, 0; 0, 1];            # Dummy mass matrix for tests
 %!endfunction
 %!function mas = fmsa (t, y, varargin)
-%! mas = sparse ([1, 0; 0, 1]);   # A sparse dummy matrix
+%!  mas = sparse ([1, 0; 0, 1]);   # A sparse dummy matrix
 %!endfunction
 %!function out = fout (t, y, flag, varargin)
-%! if (regexp (char (flag), 'init') == 1)
-%!   if (any (size (t) != [2, 1])) error ('"fout" step "init"'); endif
-%! elseif (isempty (flag))
-%!   if (any (size (t) != [1, 1])) error ('"fout" step "calc"'); endif
-%!   out = false;
-%! elseif (regexp (char (flag), 'done') == 1)
-%!   if (any (size (t) != [1, 1])) error ('"fout" step "done"'); endif
-%! else
-%!   error ('"fout" invalid flag');
-%! endif
+%!  if (regexp (char (flag), "init") == 1)
+%!    if (any (size (t) != [2, 1])) error ('"fout" step "init"'); endif
+%!  elseif (isempty (flag))
+%!    if (any (size (t) != [1, 1])) error ('"fout" step "calc"'); endif
+%!    out = false;
+%!  elseif (regexp (char (flag), 'done') == 1)
+%!    if (any (size (t) != [1, 1])) error ('"fout" step "done"'); endif
+%!  else
+%!    error ('"fout" invalid flag');
+%!  endif
 %!endfunction
 %!
 %!test  # two output arguments
 %! [t, y] = ode45 (@fpol, [0 2], [2 0]);
 %! assert ([t(end), y(end,:)], [2, fref], 1e-2);
 %!test  # not too many steps
 %! [t, y] = ode45 (@fpol, [0 2], [2 0]);
 %! assert (size (t) < 20);
@@ -484,26 +476,24 @@ endfunction
 %! opt = odeset ("Mass", @fmsa);
 %! sol = ode45 (@fpol, [0 2], [2 0], opt);
 %! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
 %!test  # Mass option as function and MStateDependence
 %! opt = odeset ("Mass", @fmas, "MStateDependence", "strong");
 %! sol = ode45 (@fpol, [0 2], [2 0], opt);
 %! assert ([sol.x(end), sol.y(end,:)], [2, fref], 1e-3);
 
+## FIXME: Missing tests.
+## test for MvPattern option is missing
+## test for InitialSlope option is missing
+## test for MaxOrder option is missing
+
 %!error ode45 ()
 %!error ode45 (1)
 %!error ode45 (1,2)
-%!error <TRANGE must be a numeric>
-%!  ode45 (@fpol, {[0 25]}, [3 15 1]);
-%!error <TRANGE must be a .* vector>
-%!  ode45 (@fpol, [0 25; 25 0], [3 15 1]);
-%!error <TRANGE must contain at least 2 elements>
-%!  ode45 (@fpol, [1], [3 15 1]);
-%!error <invalid time span>
-%!  ode45 (@fpol, [1 1], [3 15 1]);
-%!error <INIT must be a numeric>
-%!  ode45 (@fpol, [0 25], {[3 15 1]});
-%!error <INIT must be a .* vector>
-%!  ode45 (@fpol, [0 25], [3 15 1; 3 15 1]);
-%!error <FUN must be a valid function handle>
-%!  ode45 (1, [0 25], [3 15 1]);
+%!error <TRANGE must be a numeric> ode45 (@fpol, {[0 25]}, [3 15 1])
+%!error <TRANGE must be a .* vector> ode45 (@fpol, [0 25; 25 0], [3 15 1])
+%!error <TRANGE must contain at least 2 elements> ode45 (@fpol, [1], [3 15 1])
+%!error <invalid time span> ode45 (@fpol, [1 1], [3 15 1])
+%!error <INIT must be a numeric> ode45 (@fpol, [0 25], {[3 15 1]})
+%!error <INIT must be a .* vector> ode45 (@fpol, [0 25], [3 15 1; 3 15 1])
+%!error <FUN must be a valid function handle> ode45 (1, [0 25], [3 15 1])
 
diff --git a/scripts/ode/odeget.m b/scripts/ode/odeget.m
--- a/scripts/ode/odeget.m
+++ b/scripts/ode/odeget.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2016, Carlo de Falco
-## Copyright (C) 2016, Francesco Faccio <francesco.faccio@mail.polimi.it>
+## Copyright (C) 2016 Carlo de Falco
+## Copyright (C) 2016 Francesco Faccio <francesco.faccio@mail.polimi.it>
 ## Copyright (C) 2013-2016 Roberto Porcu' <roberto.porcu@polimi.it>
 ## Copyright (C) 2006-2012 Thomas Treichl <treichl@users.sourceforge.net>
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
@@ -36,29 +36,29 @@
 ## @var{default} instead.
 ## @seealso{odeset}
 ## @end deftypefn
 
 ## FIXME: 4th input argument "opt" is undocumented.
 
 function val = odeget (ode_opt, field, default = [], opt = "")
 
-  validateattributes (ode_opt, {'struct'}, {'nonempty'});
-  validateattributes (field, {'char'}, {'nonempty'});
-  
+  validateattributes (ode_opt, {"struct"}, {"nonempty"});
+  validateattributes (field, {"char"}, {"nonempty"});
+
   if (! isfield (ode_opt, field))
-    error ('Octave:odeget:InvalidPropName',
+    error ("Octave:odeget:InvalidPropName",
            'odeget: Unrecognized property name "%s".', field);
   else
     val = ode_opt.(field);
-    if (isempty (val)) 
+    if (isempty (val))
       val = default;
     endif
   endif
-  
+
 endfunction
 
 
 %!demo
 %! # Return the manually changed value RelTol of the ODE options
 %! # structure A.  If RelTol wouldn't have been changed then an
 %! # empty matrix value would have been returned.
 %!
@@ -68,17 +68,17 @@ endfunction
 %!assert (odeget (odeset (), "RelTol"), [])
 %!assert (odeget (odeset ("RelTol", 10), "RelTol"), 10)
 %!assert (odeget (odeset (), "RelTol", 10), 10)
 %!assert (odeget (odeset (), "Stats"), [])
 %!assert (odeget (odeset (), "Stats", "on"), "on")
 %!assert (odeget (odeset (), "Mass"), [])
 %!assert (odeget (odeset (), "AbsTol", 1e-9), 1e-9)
 %!assert (odeget (odeset ("AbsTol", 1e-9), "AbsTol", []), 1e-9)
-%!assert (odeget (odeset ('foo', 42), 'foo'), 42)
+%!assert (odeget (odeset ("foo", 42), "foo"), 42)
 
 %!error odeget ()
 %!error odeget (1)
 %!error odeget (1,2,3,4,5)
 %!error odeget (1, "opt1")
 %!error odeget (struct ("opt1", 1), 1)
-%!error odeget (struct ("opt1", 1), "foo");
+%!error odeget (struct ("opt1", 1), "foo")
 
diff --git a/scripts/ode/odeplot.m b/scripts/ode/odeplot.m
--- a/scripts/ode/odeplot.m
+++ b/scripts/ode/odeplot.m
@@ -14,89 +14,95 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## Author: Thomas Treichl <treichl@users.sourceforge.net>
 
 ## -*- texinfo -*-
-## @deftypefn {} {[@var{ret}] =} odeplot (@var{t}, @var{y}, @var{flag})
+## @deftypefn {} {@var{ret} =} odeplot (@var{t}, @var{y}, @var{flag})
 ##
-## Open a new figure window and plot the results from the variable @var{y} of
-## type column vector over time while solving.  The types and the values of
-## the input parameter @var{t} and the output parameter @var{ret} depend on
-## the input value @var{flag} that is of type string.  If @var{flag} is
+## Open a new figure window and plot input @var{y} over time during the
+## solving of an ode problem.
+##
+## The input @var{y} is a column vector.  The types and values of the input
+## parameter @var{t} and output parameter @var{ret} depend on the input
+## @var{flag} that is of type string.  If @var{flag} is
 ##
 ## @table @option
-## @item  @qcode{"init"}
-## then @var{t} must be a double column vector of length 2 with the first and
-## the last time step and nothing is returned from this function,
+## @item @qcode{"init"}
+## then @var{t} must be a column vector of length 2 with the first and
+## the last time step;  Nothing is returned from this function.
 ##
-## @item  @qcode{""}
-## then @var{t} must be a double scalar specifying the actual time step and
-## the return value is false (resp. value 0) for @qcode{"not stop solving"},
+## @item @qcode{""}
+## then @var{t} must be a scalar double specifying the actual time step;
+## The return value is false (resp. value 0) for @qcode{"not stop solving"}.
 ##
-## @item  @qcode{"done"}
-## then @var{t} must be a double scalar specifying the last time step and
-## nothing is returned from this function.
+## @item @qcode{"done"}
+## then @var{t} must be a scalar double specifying the last time step;
+## Nothing is returned from this function.
 ## @end table
 ##
 ## This function is called by an ode solver function if it was specified in
-## an options structure with the @code{odeset}.  This function is an
-## internal helper function therefore it should never be necessary that this
-## function is called directly by a user.  There is only little error
-## detection implemented in this function file to achieve the highest
-## performance.
+## an options structure with @code{odeset}.  This function is an internal
+## helper function; It should never be necessary for this function to be
+## directly called by a user.  There is only minimal error detection
+## implemented in order to to achieve the highest performance.
 ##
 ## For example, solve an anonymous implementation of the
 ## @nospell{@qcode{"Van der Pol"}} equation and display the results while
 ## solving
 ##
 ## @example
 ## @group
 ## fvdb = @@(t,y) [y(2); (1 - y(1)^2) * y(2) - y(1)];
 ##
 ## opt = odeset ("OutputFcn", @@odeplot, "RelTol", 1e-6);
 ## sol = ode45 (fvdb, [0 20], [2 0], opt);
 ## @end group
 ## @end example
-## @end deftypefn
 ##
 ## @seealso{odeset, odeget}
+## @end deftypefn
 
 function ret = odeplot (t, y, flag, varargin)
 
   ## No input argument check is done for a higher processing speed
-  persistent fig; persistent told;
-  persistent yold; persistent counter;
+  persistent fig told yold counter;
 
   if (strcmp (flag, "init"))
     ## Nothing to return, t is either the time slot [tstart tstop]
-    ## or [t0, t1, ..., tn], y is the inital value vector "init"
-    fig = figure; told = t(1,1); yold = y(:,1);
+    ## or [t0, t1, ..., tn], y is the initial value vector "init"
     counter = 1;
+    fig = figure ();
+    told = t(1,1);
+    yold = y(:,1);
 
   elseif (isempty (flag))
     ## Return something, either false for "not stopping
     ## the integration" or true for "stopping the integration"
-    counter = counter + 1; figure (fig);
+    counter += 1;
+    figure (fig);
     told(counter,1) = t(1,1);
     yold(:,counter) = y(:,1);
+    ## FIXME: Why not use '.' rather than 'o' and skip the markersize?
+    ## FIXME: Why not just update the xdata, ydata properties?
+    ##        Calling plot involves a lot of overhead.
     plot (told, yold, "-o", "markersize", 1); drawnow;
     ret = false;
 
   elseif (strcmp (flag, "done"))
-    ## Cleanup has to be done, clear the persistent variables because
-    ## we don't need them anymore
+    ## Cleanup after ode solver has finished.
     clear ("figure", "told", "yold", "counter");
 
   endif
 
 endfunction
 
 
 %!demo
-%! % solve an anonymous implementation of the "Van der Pol" equation
-%! % and display the results while solving
+%! # Solve an anonymous implementation of the Van der Pol equation
+%! # and display the results while solving
 %! fvdb = @(t,y) [y(2); (1 - y(1)^2) * y(2) - y(1)];
 %! opt = odeset ("OutputFcn", @odeplot, "RelTol", 1e-6);
 %! sol = ode45 (fvdb, [0 20], [2 0], opt);
+
diff --git a/scripts/ode/odeset.m b/scripts/ode/odeset.m
--- a/scripts/ode/odeset.m
+++ b/scripts/ode/odeset.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2016, Carlo de Falco
-## Copyright (C) 2016, Francesco Faccio <francesco.faccio@mail.polimi.it>
+## Copyright (C) 2016 Carlo de Falco
+## Copyright (C) 2016 Francesco Faccio <francesco.faccio@mail.polimi.it>
 ## Copyright (C) 2013-2016 Roberto Porcu' <roberto.porcu@polimi.it>
 ## Copyright (C) 2006-2012 Thomas Treichl <treichl@users.sourceforge.net>
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
@@ -15,129 +15,136 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {} {} odeset ()
+## @deftypefn  {} {@var{odestruct} =} odeset ()
 ## @deftypefnx {} {@var{odestruct} =} odeset (@var{"field1"}, @var{value1}, @var{"field2"}, @var{value2}, @dots{})
 ## @deftypefnx {} {@var{odestruct} =} odeset (@var{oldstruct}, @var{"field1"}, @var{value1}, @var{"field2"}, @var{value2}, @dots{})
 ## @deftypefnx {} {@var{odestruct} =} odeset (@var{oldstruct}, @var{newstruct})
+## @deftypefnx {} {} odeset ()
 ##
 ## Create or modify an ODE options structure.
 ##
-## When called without an input argument, return a new ODE options structure
-## that contains all possible fields initialized to their default values.
+## When called with no input argument and one output argument, return a new ODE
+## options structure that contains all possible fields initialized to their
+## default values.  If no output argument is requested, display a list of
+## the common ODE solver options along with their default value.
 ##
 ## If called with string input arguments @var{"field1"}, @var{"field2"},
 ## @dots{} identifying valid ODE options then return a new ODE options
 ## structure with all possible fields initialized @strong{and} set the values
 ## of the fields @var{"field1"}, @var{"field2"}, @dots{} to the values
 ## @var{value1}, @var{value2}, @dots{}
 ##
 ## If called with an input structure @var{oldstruct} then overwrite the values
 ## of the options @var{"field1"}, @var{"field2"}, @dots{} with new values
 ## @var{value1}, @var{value2}, @dots{} and return the modified structure.
 ##
 ## When called with two input ODE options structures @var{oldstruct} and
 ## @var{newstruct} overwrite all values from the structure @var{oldstruct} with
 ## new values from the structure @var{newstruct}.  Empty values in
 ## @var{newstruct} will not overwrite values in @var{oldstruct}.
+##
 ## @seealso{odeget}
 ## @end deftypefn
 
 function odestruct = odeset (varargin)
 
   persistent p;
 
   if (isempty (p))
-
     p = inputParser ();
     p.addParameter ("AbsTol", []);
     p.addParameter ("BDF", []);
     p.addParameter ("Events", []);
     p.addParameter ("InitialSlope", []);
     p.addParameter ("InitialStep", []);
     p.addParameter ("Jacobian", []);
     p.addParameter ("JConstant", []);
     p.addParameter ("JPattern", []);
     p.addParameter ("Mass", []);
+    ## FIXME: MassConstant does not appear in Matlab documentation for odeset
     p.addParameter ("MassConstant", []);
     p.addParameter ("MassSingular", []);
     p.addParameter ("MaxOrder", []);
     p.addParameter ("MaxStep", []);
     p.addParameter ("MStateDependence", []);
     p.addParameter ("MvPattern", []);
     p.addParameter ("NonNegative", []);
     p.addParameter ("NormControl", []);
     p.addParameter ("OutputFcn", []);
     p.addParameter ("OutputSel", []);
     p.addParameter ("Refine", []);
     p.addParameter ("RelTol", []);
     p.addParameter ("Stats", []);
     p.addParameter ("Vectorized", []);
     p.KeepUnmatched = true;
-    
   endif
 
   if (nargin == 0 && nargout == 0)
     print_options ();
   else
     p.parse (varargin{:});
     odestruct = p.Results;
     odestruct_extra = p.Unmatched;
 
-    s1 = cellfun (@(x) ifelse (iscell(x), {x}, x),
-                  struct2cell(odestruct),
-                  'UniformOutput', false);
+    ## FIXME: For speed, shouldn't this merge of structures only occur
+    ##        when there is something in odestruct_extra?
+    ## FIXME: Should alphabetical order of fieldnames be maintained
+    ##        by using sort?
+    s1 = cellfun (@(x) ifelse (iscell (x), {x}, x),
+                  struct2cell (odestruct),
+                  "UniformOutput", false);
 
-    s2 = cellfun (@(x) ifelse (iscell(x), {x}, x),
-                  struct2cell(odestruct_extra),
-                  'UniformOutput', false);
-    
+    s2 = cellfun (@(x) ifelse (iscell (x), {x}, x),
+                  struct2cell (odestruct_extra),
+                  "UniformOutput", false);
+
     C = [fieldnames(odestruct)       s1;
          fieldnames(odestruct_extra) s2];
-    
+
     odestruct = struct (C'{:});
   endif
-  
+
 endfunction
 
 ## function to print all possible options
 function print_options ()
 
   disp ("List of the most common ODE solver options.");
   disp ("Default values are in square brackets.");
   disp ("");
-  disp ("             AbsTol:  scalar or vector, >0, [1e-6]");
-  disp ("                BDF:  binary, {'on', ['off']}");
-  disp ("             Events:  function_handle, []");
-  disp ("       InitialSlope:  vector, []");
-  disp ("        InitialStep:  scalar, >0, []");
-  disp ("           Jacobian:  matrix or function_handle, []");
-  disp ("          JConstant:  binary, {'on', ['off']}");
-  disp ("           JPattern:  sparse matrix, []");
-  disp ("               Mass:  matrix or function_handle, []");
-  disp ("       MassConstant:  binary, {'on', ['off']}");
-  disp ("       MassSingular:  switch, {'yes', ['maybe'], 'no'}");
-  disp ("           MaxOrder:  switch, {1, 2, 3, 4, [5]}");
-  disp ("            MaxStep:  scalar, >0, []");
-  disp ("   MStateDependence:  switch, {'none', ['weak'], 'strong'}");
-  disp ("          MvPattern:  sparse matrix, []");
-  disp ("        NonNegative:  vector of integers, []");
-  disp ("        NormControl:  binary, {'on', ['off']}");
-  disp ("          OutputFcn:  function_handle, []");
-  disp ("          OutputSel:  scalar or vector, []");
-  disp ("             Refine:  scalar, integer, >0, []");
-  disp ("             RelTol:  scalar, >0, [1e-3]");
-  disp ("              Stats:  binary, {'on', ['off']}");
-  disp ("         Vectorized:  binary, {'on', ['off']}");
+  disp ('             AbsTol:  scalar or vector, >0, [1e-6]');
+  disp ('                BDF:  binary, {["off"], "on"}');
+  disp ('             Events:  function_handle, []');
+  disp ('       InitialSlope:  vector, []');
+  disp ('        InitialStep:  scalar, >0, []');
+  disp ('           Jacobian:  matrix or function_handle, []');
+  disp ('          JConstant:  binary, {["off"], "on"}');
+  disp ('           JPattern:  sparse matrix, []');
+  disp ('               Mass:  matrix or function_handle, []');
+  disp ('       MassConstant:  binary, {["off"], "on"}');
+  disp ('       MassSingular:  switch, {["maybe"], "no", "yes"}');
+  disp ('           MaxOrder:  switch, {[5], 1, 2, 3, 4, }');
+  disp ('            MaxStep:  scalar, >0, []');
+  disp ('   MStateDependence:  switch, {["weak"], "none", "strong"}');
+  disp ('          MvPattern:  sparse matrix, []');
+  disp ('        NonNegative:  vector of integers, []');
+  disp ('        NormControl:  binary, {["off"], "on"}');
+  disp ('          OutputFcn:  function_handle, []');
+  disp ('          OutputSel:  scalar or vector, []');
+  disp ('             Refine:  scalar, integer, >0, []');
+  disp ('             RelTol:  scalar, >0, [1e-3]');
+  disp ('              Stats:  binary, {["off"], "on"}');
+  disp ('         Vectorized:  binary, {["off"], "on"}');
 
 endfunction
 
 
 %!demo
 %! # A new ODE options structure with default values is created.
 %!
 %! odeoptA = odeset ();
@@ -187,13 +194,12 @@ endfunction
 %! end_unwind_protect
 
 ## Test input validation
 %!error <argument 'OPT1' is not a valid parameter> odeset ("opt1")
 %!error  odeset (1, 1)
 %!error <argument 'OPT1' is not a valid parameter> odeset (odeset (), "opt1")
 %!error  odeset (odeset (), 1, 1)
 
-##FIXME: Add not exact match option 
+## FIXME: Add inexact match option
 ## %!warning <no exact match for 'Rel'.  Assuming 'RelTol'> odeset ("Rel", 1);
 ## %!error <Possible fields found: InitialSlope, InitialStep> odeset ("Initial", 1)
 
-
diff --git a/scripts/ode/private/AbsRel_Norm.m b/scripts/ode/private/AbsRel_norm.m
rename from scripts/ode/private/AbsRel_Norm.m
rename to scripts/ode/private/AbsRel_norm.m
--- a/scripts/ode/private/AbsRel_Norm.m
+++ b/scripts/ode/private/AbsRel_norm.m
@@ -13,24 +13,24 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {} {retval =} AbsRel_Norm (@var{x}, @var{x_old}, @var{AbsTol}, @var{RelTol}, @var{normcoontrol}, @var{y})
+## @deftypefn {} {retval =} AbsRel_norm (@var{x}, @var{x_old}, @var{AbsTol}, @var{RelTol}, @var{normcoontrol}, @var{y})
 ## Undocumented internal function.
 ## @end deftypefn
 
-function retval = AbsRel_Norm (x, x_old, AbsTol, RelTol, normcontrol, y = zeros (size (x)))
+function retval = AbsRel_norm (x, x_old, AbsTol, RelTol, normcontrol, y = zeros (size (x)))
 
   n = numel (x);
-  
+
   sc = AbsTol + max (abs (x), abs (x_old)) .* RelTol;
   if (normcontrol)
     retval = max (abs (x - y) ./ sc);
   else
     retval = sqrt ((1 / n) * sumsq ((x - y) ./ sc));
   endif
 
 endfunction
diff --git a/scripts/ode/private/integrate_adaptive.m b/scripts/ode/private/integrate_adaptive.m
--- a/scripts/ode/private/integrate_adaptive.m
+++ b/scripts/ode/private/integrate_adaptive.m
@@ -16,20 +16,20 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {@var{solution} =} integrate_adaptive (@var{@@stepper}, @var{order}, @var{@@func}, @var{tspan}, @var{x0}, @var{options})
 ##
 ## This function file can be called by an ODE solver function in order to
-## integrate the set of ODEs on the interval @var{[t0, t1]} with an
-## adaptive timestep.
+## integrate the set of ODEs on the interval @var{[t0, t1]} with an adaptive
+## timestep.
 ##
-## The function returns a structure @var{solution} with two fieldss: @var{t}
+## The function returns a structure @var{solution} with two fields: @var{t}
 ## and @var{y}.  @var{t} is a column vector and contains the time stamps.
 ## @var{y} is a matrix in which each column refers to a different unknown
 ## of the problem and the row number is the same as the @var{t} row number.
 ## Thus, each row of the matrix @var{y} contains the values of all unknowns at
 ## the time value contained in the corresponding row in @var{t}.
 ##
 ## The first input argument must be a function handle or inline function
 ## representing the stepper, i.e., the function responsible for step-by-step
@@ -56,32 +56,32 @@
 ## interval, i.e., @var{[tspan(1), tspan(end)]} and all intermediate elements
 ## are taken as times at which the solution is required.
 ##
 ## The fifth argument represents the initial conditions for the ODEs and the
 ## last input argument contains some options that may be needed for the
 ## stepper.
 ##
 ## @end deftypefn
-##
-## @seealso{ode45, ode23}
 
 function solution = integrate_adaptive (stepper, order, func, tspan, x0,
                                         options)
 
   fixed_times = numel (tspan) > 2;
 
   t_new = t_old = t = tspan(1);
   x_new = x_old = x = x0(:);
 
   ## Get first initial timestep
   dt = options.InitialStep;
   if (isempty (dt))
-    dt = starting_stepsize (order, func, t, x, options.AbsTol, options.RelTol,
-                            strcmp (options.NormControl, "on"), options.funarguments);
+    dt = starting_stepsize (order, func, t, x,
+                            options.AbsTol, options.RelTol,
+                            strcmp (options.NormControl, "on"),
+                            options.funarguments);
   endif
 
   dir = options.direction;
   dt = dir * min (abs (dt), options.MaxStep);
 
   options.comp = 0.0;
 
   ## Factor multiplying the stepsize guess
@@ -113,32 +113,33 @@ function solution = integrate_adaptive (
   solution.cntloop = 0;
   solution.cntcycles = 0;
   solution.cntsave = 2;
   solution.unhandledtermination = true;
   ireject = 0;
 
   k_vals = [];
   iout = istep = 1;
-  
+
   while (dir * t_old < dir * tspan(end))
 
     ## Compute integration step from t_old to t_new = t_old + dt
     [t_new, options.comp] = kahan (t_old, options.comp, dt);
     [t_new, x_new, x_est, new_k_vals] = ...
-    stepper (func, t_old, x_old, dt, options, k_vals, t_new);
+      stepper (func, t_old, x_old, dt, options, k_vals, t_new);
 
     solution.cntcycles += 1;
 
     if (options.havenonnegative)
       x_new(nn, end) = abs (x_new(nn, end));
       x_est(nn, end) = abs (x_est(nn, end));
     endif
 
-    err = AbsRel_Norm (x_new, x_old, options.AbsTol, options.RelTol,
+    ## FIXME: Take strcmp out of while loop and calculate just once
+    err = AbsRel_norm (x_new, x_old, options.AbsTol, options.RelTol,
                        strcmp (options.NormControl, "on"), x_est);
 
     ## Accept solution only if err <= 1.0
     if (err <= 1)
 
       solution.cntloop += 1;
       ireject = 0;              # Clear reject counter
 
@@ -148,32 +149,32 @@ function solution = integrate_adaptive (
         t_caught = find ((dir * tspan(iout:end) > dir * t_old)
                          & (dir * tspan(iout:end) <= dir * t_new));
         t_caught = t_caught + iout - 1;
 
         if (! isempty (t_caught))
           t(t_caught) = tspan(t_caught);
           iout = max (t_caught);
           x(:, t_caught) = ...
-          runge_kutta_interpolate (order, [t_old t_new], [x_old x_new],
-                                   t(t_caught), new_k_vals, dt, func,
-                                   options.funarguments);
+            runge_kutta_interpolate (order, [t_old t_new], [x_old x_new],
+                                     t(t_caught), new_k_vals, dt, func,
+                                     options.funarguments);
 
           istep += 1;
 
           ## Call Events function only if a valid result has been found.
           ## Stop integration if eventbreak is true.
           if (! isempty (options.Events))
             break_loop = false;
             for idenseout = 1:numel (t_caught)
               id = t_caught(idenseout);
               td = t(id);
               solution.event = ...
-              ode_event_handler (options.Events, t(id), x(:, id), [],
-                                 options.funarguments{:});
+                ode_event_handler (options.Events, t(id), x(:, id), [],
+                                   options.funarguments{:});
               if (! isempty (solution.event{1}) && solution.event{1} == 1)
                 t(id) = solution.event{3}(end);
                 t = t(1:id);
                 x(:, id) = solution.event{4}(end, :).';
                 x = x(:,1:id);
                 solution.unhandledtermination = false;
                 break_loop = true;
                 break;
@@ -186,61 +187,61 @@ function solution = integrate_adaptive (
 
           ## Call OutputFcn only if a valid result has been found.
           ## Stop integration if function returns false.
           if (options.haveoutputfunction)
             cnt = options.Refine + 1;
             approxtime = linspace (t_old, t_new, cnt);
             approxvals = interp1 ([t_old, t(t_caught), t_new],
                                   [x_old, x(:, t_caught), x_new] .',
-                                  approxtime, 'linear') .';
+                                  approxtime, "linear") .';
             if (! isempty (options.OutputSel))
               approxvals = approxvals(options.OutputSel, :);
             endif
             for ii = 1:numel (approxtime)
               pltret = feval (options.OutputFcn, approxtime(ii),
                               approxvals(:, ii), [],
                               options.funarguments{:});
             endfor
             if (pltret)  # Leave main loop
               solution.unhandledtermination = false;
               break;
             endif
           endif
 
         endif
 
-      else
+      else   # not fixed times
 
         t(++istep)  = t_new;
         x(:, istep) = x_new;
         iout = istep;
 
         ## Call Events function only if a valid result has been found.
         ## Stop integration if eventbreak is true.
         if (! isempty (options.Events))
           solution.event = ...
-          ode_event_handler (options.Events, t(istep), x(:, istep), [],
-                             options.funarguments{:});
+            ode_event_handler (options.Events, t(istep), x(:, istep), [],
+                               options.funarguments{:});
           if (! isempty (solution.event{1}) && solution.event{1} == 1)
             t(istep) = solution.event{3}(end);
             x(:, istep) = solution.event{4}(end, :).';
             solution.unhandledtermination = false;
             break;
           endif
         endif
 
         ## Call OutputFcn only if a valid result has been found.
         ## Stop integration if function returns false.
         if (options.haveoutputfunction)
           cnt = options.Refine + 1;
           approxtime = linspace (t_old, t_new, cnt);
           approxvals = interp1 ([t_old, t_new],
                                 [x_old, x_new] .',
-                                approxtime, 'linear') .';
+                                approxtime, "linear") .';
           if (! isempty (options.OutputSel))
             approxvals = approxvals(options.OutputSel, :);
           endif
           for ii = 1:numel (approxtime)
             pltret = feval (options.OutputFcn, approxtime(ii),
                             approxvals(:, ii), [], options.funarguments{:});
           endfor
           if (pltret)  # Leave main loop
@@ -251,22 +252,22 @@ function solution = integrate_adaptive (
 
       endif
 
       ## move to next time-step
       t_old = t_new;
       x_old = x_new;
       k_vals = new_k_vals;
 
-    else
+    else  # error condition
 
       ireject += 1;
 
-      ## Stop solving because, in the last 5,000 steps, no successful valid
-      ## value has been found
+      ## Stop solving if, in the last 5,000 steps, no successful valid
+      ## value has been found.
       if (ireject >= 5_000)
         error (["integrate_adaptive: Solving was not successful. ", ...
                 " The iterative integration loop exited at time", ...
                 " t = %f before the endpoint at tend = %f was reached. ", ...
                 " This happened because the iterative integration loop", ...
                 " did not find a valid solution at this time stamp. ", ...
                 " Try to reduce the value of 'InitialStep' and/or", ...
                 " 'MaxStep' with the command 'odeset'.\n"],
@@ -275,20 +276,20 @@ function solution = integrate_adaptive (
 
     endif
 
     ## Compute next timestep, formula taken from Hairer
     err += eps;  # avoid divisions by zero
     dt *= min (facmax, max (facmin, fac * (1 / err)^(1 / (order + 1))));
     dt = dir * min (abs (dt), options.MaxStep);
     if (! (abs (dt) > eps (t (end))))
-      break
+      break;
     endif
-    
-    ## make sure we don't go past tpan(end)
+
+    ## Make sure we don't go past tpan(end)
     dt = dir * min (abs (dt), abs (tspan(end) - t_old));
 
   endwhile
 
   ## Check if integration of the ode has been successful
   if (dir * t(end) < dir * tspan(end))
     if (solution.unhandledtermination == true)
       warning ("integrate_adaptive:unexpected_termination",
diff --git a/scripts/ode/private/kahan.m b/scripts/ode/private/kahan.m
--- a/scripts/ode/private/kahan.m
+++ b/scripts/ode/private/kahan.m
@@ -22,24 +22,24 @@
 ##
 ## This function implements the Kahan summation algorithm, also known as
 ## compensated summation.
 ##
 ## The algorithm significantly reduces the numerical error in the total
 ## obtained by adding a sequence of finite precision floating point numbers,
 ## compared to the straightforward approach.  For more details
 ## see @url{http://en.wikipedia.org/wiki/Kahan_summation_algorithm}.
-## This function is called by @code{integrate_adaptive} and
-## @code{integrate_const} to better catch equality comparisons.
+## This function is called by @code{integrate_adaptive} to better catch
+## equality comparisons.
 ##
-## The first input argument is the variable that will contain the summation,
-## so that is also returned as first output argument in order to reuse it in
-## next calls to @code{kahan} function.
+## The first input argument is the variable that will contain the summation.
+## This variable is also returned as the first output argument in order to
+## reuse it in subsequent calls to @code{kahan} function.
 ##
-## The second input argument contains the compensation term and it is returned
+## The second input argument contains the compensation term and is returned
 ## as the second output argument so that it can be reused in future calls of
 ## the same summation.
 ##
 ## The third input argument @var{term} is the variable to be added to
 ## @var{sum}.
 ## @end deftypefn
 
 function [sum, comp] = kahan (sum, comp, term)
diff --git a/scripts/ode/private/ode_event_handler.m b/scripts/ode/private/ode_event_handler.m
--- a/scripts/ode/private/ode_event_handler.m
+++ b/scripts/ode/private/ode_event_handler.m
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {} {@var{sol} =} ode_event_handler (@var{@@evtfun}, @var{t}, @var{y}, @var{flag}, @var{par1}, @var{par2}, @dots{})
+## @deftypefn {} {@var{retval} =} ode_event_handler (@var{@@evtfun}, @var{t}, @var{y}, @var{flag}, @var{par1}, @var{par2}, @dots{})
 ##
 ## Return the solution of the event function that is specified as the first
 ## input argument @var{@@evtfun} in the form of a function handle.
 ##
 ## The second input argument @var{t} is of type double scalar and
 ## specifies the time of the event evaluation, the third input argument
 ## @var{y} either is of type double column vector (for ODEs and DAEs) and
 ## specifies the solutions or is of type cell array (for IDEs and DDEs) and
@@ -31,34 +31,32 @@
 ##
 ## @table @option
 ## @item  @qcode{"init"}
 ## then initialize internal persistent variables of the function
 ## @code{ode_event_handler} and return an empty cell array of size 4,
 ##
 ## @item  @qcode{"calc"}
 ## then do the evaluation of the event function and return the solution
-## @var{sol} as type cell array of size 4,
+## @var{retval} as type cell array of size 4,
 ##
 ## @item  @qcode{"done"}
 ## then cleanup internal variables of the function
 ## @code{ode_event_handler} and return an empty cell array of size 4.
 ## @end table
 ##
 ## Optionally if further input arguments @var{par1}, @var{par2}, @dots{} of
 ## any type are given then pass these parameters through
 ## @code{ode_event_handler} to the event function.
 ##
 ## This function is an ODE internal helper function therefore it should
 ## never be necessary that this function is called directly by a user.  There
 ## is only little error detection implemented in this function file to
 ## achieve the highest performance.
 ## @end deftypefn
-##
-## @seealso{odepkg}
 
 function retval = ode_event_handler (evtfun, t, y, flag = "", varargin)
 
   ## No error handling has been implemented in this function to achieve
   ## the highest performance available.
 
   ## retval{1} is true (to terminate) or false (to continue)
   ## retval{2} is the index information for which an event occurred
@@ -67,17 +65,16 @@ function retval = ode_event_handler (evt
 
   ## These persistent variables store the results and time value from the
   ## processing in the previous time stamp.
   ## evtold  the results from the event function
   ## told    the time stamp
   ## yold    the ODE result
   ## retcell the return values cell array
   ## evtcnt  the counter for how often this function has been called
-  ## has been called
   persistent evtold told yold retcell evtcnt;
 
   ## Call the event function if an event function has been defined to
   ## initialize the internal variables of the event function and to get
   ## a value for evtold.
   if (strcmp (flag, "init"))
 
     if (! iscell (y))
diff --git a/scripts/ode/private/odedefaults.m b/scripts/ode/private/odedefaults.m
--- a/scripts/ode/private/odedefaults.m
+++ b/scripts/ode/private/odedefaults.m
@@ -1,10 +1,10 @@
-## Copyright (C) 2016, Carlo de Falco
-## Copyright (C) 2016, Francesco Faccio <francesco.faccio@mail.polimi.it>
+## Copyright (C) 2016 Carlo de Falco
+## Copyright (C) 2016 Francesco Faccio <francesco.faccio@mail.polimi.it>
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -13,48 +13,48 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {} {[@var{d}, @var{c}, @var{a}] =} odedefaults (@var{n}, @var{t0}, @var{tf})
+## @deftypefn {} {[@var{defaults}, @var{classes}, @var{attributes}] =} odedefaults (@var{n}, @var{t0}, @var{tf})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function [defaults, classes, attributes] = odedefaults (n, t0, tf)
 
   persistent defaults = struct ("AbsTol", 1e-6,
                                 "BDF", "off",
                                 "Events", [],
-                                "InitialSlope", zeros(n,1),
+                                "InitialSlope", zeros (n,1),
                                 "InitialStep", [],
                                 "Jacobian", [],
                                 "JConstant", "off",
                                 "JPattern", [],
                                 "Mass", [],
                                 "MassConstant", "off",
                                 "MassSingular", "maybe",
                                 "MaxOrder", 5,
                                 "MaxStep", 0.1 * abs (t0-tf),
                                 "MStateDependence", "weak",
                                 "MvPattern", [],
                                 "NonNegative", [],
                                 "NormControl", "off",
                                 "OutputFcn", [],
                                 "OutputSel", [],
-                                "Refine", 1,  
+                                "Refine", 1,
                                 "RelTol", 1e-3,
                                 "Stats", "off",
                                 "Vectorized", "off");
-  
+
   defaults.MaxStep = (0.1 * abs (t0-tf));
-  
+
   persistent classes = struct ("AbsTol", {{"float"}},
                                "BDF", "char",
                                "Events", {{"function_handle"}},
                                "InitialSlope", {{"float"}},
                                "InitialStep", {{"float"}},
                                "Jacobian", {{"float", "function_handle", "cell"}},
                                "JConstant", "char",
                                "JPattern", {{"float"}},
@@ -68,17 +68,17 @@ function [defaults, classes, attributes]
                                "NonNegative", {{"float"}},
                                "NormControl", "char",
                                "OutputFcn", {{"function_handle"}},
                                "OutputSel", {{"float"}},
                                "Refine", {{"float"}},
                                "RelTol", {{"float"}},
                                "Stats", "char",
                                "Vectorized", "char");
-  
+
   persistent attributes = struct ("AbsTol", {{"real", "vector", "positive"}},
                                   "BDF", {{"on", "off"}},
                                   "Events", {{}},
                                   "InitialSlope", {{"real", "vector", "numel", n}},
                                   "InitialStep", {{"positive", "scalar"}},
                                   "Jacobian", {{}},
                                   "JConstant", {{"on", "off"}},
                                   "JPattern", {{"vector"}},
@@ -94,8 +94,9 @@ function [defaults, classes, attributes]
                                   "OutputFcn", {{}},
                                   "OutputSel", {{"vector", "integer", "positive",...
                                                  ">", 0, "<=", n}},
                                   "Refine", {{"scalar", ">", 0, "integer"}},
                                   "RelTol", {{"scalar", "positive", "real"}},
                                   "Stats", {{"on", "off"}},
                                   "Vectorized", {{"on", "off"}});
 endfunction
+
diff --git a/scripts/ode/private/odemergeopts.m b/scripts/ode/private/odemergeopts.m
--- a/scripts/ode/private/odemergeopts.m
+++ b/scripts/ode/private/odemergeopts.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2016, Francesco Faccio <francesco.faccio@mail.polimi.it>
+## Copyright (C) 2016 Francesco Faccio <francesco.faccio@mail.polimi.it>
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
@@ -11,32 +11,35 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-function options = odemergeopts  (useroptions, options, classes,
-                                  attributes, fun_name);
+function options = odemergeopts (caller, useroptions, options, classes,
+                                 attributes);
 
   for [value, key] = options;
 
     if (isfield (useroptions, key) && ! isempty (useroptions.(key)))
 
       if (! strcmp (classes.(key), "char"))
         validateattributes (useroptions.(key), classes.(key),
-                            attributes.(key), fun_name, key);
+                            attributes.(key), caller, key);
 
       elseif (ischar (useroptions.(key)))
-        validatestring (useroptions.(key), attributes.(key), fun_name, key);
+        validatestring (useroptions.(key), attributes.(key), caller, key);
 
       else
         error ("Octave:invalid-input-arg",
-               [fun_name ": invalid value assigned to field '%s'"], key);
+               [caller ": invalid value assigned to field '%s'"], key);
       endif
 
       options.(key) = useroptions.(key);
 
     endif
+
   endfor
+
 endfunction
+
diff --git a/scripts/ode/private/runge_kutta_23.m b/scripts/ode/private/runge_kutta_23.m
--- a/scripts/ode/private/runge_kutta_23.m
+++ b/scripts/ode/private/runge_kutta_23.m
@@ -60,22 +60,22 @@
 ## @seealso{runge_kutta_45_dorpri}
 ## @end deftypefn
 
 function [t_next, x_next, x_est, k] = runge_kutta_23 (f, t, x, dt,
                                                       options = [],
                                                       k_vals = [],
                                                       t_next = t + dt)
 
-  persistent a = [0           0          0;
-                  1/2         0          0;
-                  0           3/4        0];
-  persistent b = [0 1/2 3/4 1];
-  persistent c = [(2/9) (1/3) (4/9)];
-  persistent c_prime = [(7/24) (1/4) (1/3) (1/8)];
+  persistent a = [0   0   0;
+                  1/2 0   0;
+                  0   3/4 0];
+  persistent b = [0, 1/2, 3/4, 1];
+  persistent c = [2/9, 1/3, 4/9];
+  persistent c_prime = [7/24, 1/4, 1/3, 1/8];
 
   s = t + dt * b;
   cc = dt * c;
   aa = dt * a;
   k = zeros (rows (x), 4);
 
   if (! isempty (options))  # extra arguments for function evaluator
     args = options.funarguments;
@@ -87,21 +87,22 @@ function [t_next, x_next, x_est, k] = ru
     k(:,1) = k_vals(:,end);  # FSAL property
   else
     k(:,1) = feval (f, t, x, args{:});
   endif
 
   k(:,2) = feval (f, s(2), x + k(:,1) * aa(2, 1).', args{:});
   k(:,3) = feval (f, s(3), x + k(:,2) * aa(3, 2).', args{:});
 
-  ## compute new time and new values for the unkwnowns
+  ## compute new time and new values for the unknowns
   ## t_next = t + dt;
-  x_next = x + k(:,1:3) * cc(:); # 3rd order approximation
+  x_next = x + k(:,1:3) * cc(:);  # 3rd order approximation
 
   ## if the estimation of the error is required
   if (nargout >= 3)
     ## new solution to be compared with the previous one
     k(:,4) = feval (f, t_next, x_next, args{:});
     cc_prime = dt * c_prime;
     x_est = x + k * cc_prime(:);
   endif
 
 endfunction
+
diff --git a/scripts/ode/private/runge_kutta_45_dorpri.m b/scripts/ode/private/runge_kutta_45_dorpri.m
--- a/scripts/ode/private/runge_kutta_45_dorpri.m
+++ b/scripts/ode/private/runge_kutta_45_dorpri.m
@@ -22,61 +22,61 @@
 ## @deftypefnx {} {[@var{t_next}, @var{x_next}, @var{x_est}] =} runge_kutta_45_dorpri (@var{@@fun}, @var{t}, @var{x}, @var{dt}, @var{options}, @var{k_vals_in})
 ## @deftypefnx {} {[@var{t_next}, @var{x_next}, @var{x_est}, @var{k_vals_out}] =} runge_kutta_45_dorpri (@var{@@fun}, @var{t}, @var{x}, @var{dt}, @var{options}, @var{k_vals_in})
 ##
 ## This function can be used to integrate a system of ODEs with a given initial
 ## condition @var{x} from @var{t} to @var{t+dt} with the Dormand-Prince method.
 ## For the definition of this method see
 ## @url{http://en.wikipedia.org/wiki/Dormand%E2%80%93Prince_method}.
 ##
-## First output argument is the final integration time value.
-##
-## Second output parameter is the higher order computed solution at time
-## @var{t_next} (local extrapolation).
-##
-## Third output parameter is a lower order solution for the estimation of the
-## error.
-##
-## Fourth output parameter is matrix containing the Runge-Kutta evaluations
-## to use in an FSAL scheme or for dense output.
-##
 ## First input argument is the function describing the system of ODEs to be
 ## integrated.
 ##
 ## Second input parameter is the first extreme of integration interval.
 ##
 ## Third input argument is the initial condition of the system.
 ##
 ## Fourth input argument is the timestep, that is the length of the
 ## integration interval.
 ##
 ## Fifth input parameter is optional and describes a set of options useful to
 ## adapt the computation to what is needed.
 ##
 ## Sixth input parameter is optional and describes the Runge-Kutta evaluations
 ## of the previous step to use in an FSAL scheme.
-## @end deftypefn
+##
+## First output argument is the final integration time value.
+##
+## Second output parameter is the higher order computed solution at time
+## @var{t_next} (local extrapolation).
 ##
-## @seealso{odepkg}
+## Third output parameter is a lower order solution for the estimation of the
+## error.
+##
+## Fourth output parameter is matrix containing the Runge-Kutta evaluations
+## to use in an FSAL scheme or for dense output.
+## @end deftypefn
 
 function [t_next, x_next, x_est, k] = runge_kutta_45_dorpri (f, t, x, dt,
                                                              options = [],
                                                              k_vals = [],
                                                              t_next = t + dt)
 
   persistent a = [0           0          0           0        0          0;
                   1/5         0          0           0        0          0;
                   3/40        9/40       0           0        0          0;
                   44/45      -56/15      32/9        0        0          0;
                   19372/6561 -25360/2187 64448/6561 -212/729  0          0;
                   9017/3168  -355/33     46732/5247  49/176  -5103/18656 0];
-  persistent b = [0 1/5 3/10 4/5 8/9 1 1];
-  persistent c = [(35/384) 0 (500/1113) (125/192) (-2187/6784) (11/84)];
-  persistent c_prime = [(5179/57600) 0 (7571/16695) (393/640), ...
-                        (-92097/339200) (187/2100)  (1/40)];
+  persistent b = [0, 1/5, 3/10, 4/5, 8/9, 1, 1];
+  persistent c = [35/384, 0, 500/1113, 125/192, -2187/6784, 11/84];
+  persistent c_prime = [5179/57600, 0, 7571/16695, 393/640, ...
+                        -92097/339200, 187/2100, 1/40];
+  ## FIXME: Which source is c_prime derived from?
+  ##        Can't the Shampine clause be deleted if it will never be used?
   ## According to Shampine 1986:
   ## persistent c_prime = [(1951/21600) 0 (22642/50085) (451/720), ...
   ##                       (-12231/42400) (649/6300) (1/60)];
 
   s = t + dt * b;
   cc = dt * c;
   aa = dt * a;
   k = zeros (rows (x), 7);
diff --git a/scripts/ode/private/runge_kutta_interpolate.m b/scripts/ode/private/runge_kutta_interpolate.m
--- a/scripts/ode/private/runge_kutta_interpolate.m
+++ b/scripts/ode/private/runge_kutta_interpolate.m
@@ -16,87 +16,89 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 function u_interp = runge_kutta_interpolate (order, z, u, t, k_vals, dt, func, args)
 
   switch (order)
 
-    ## FIXME: Can interpolations for orders 1-4 simply be deleted? 2015-10-14.
-
     case 1
-      u_interp = interp1 (z, u', t, 'linear');
+      u_interp = interp1 (z, u', t, "linear");
 
     case 2
       if (! isempty (k_vals))
         der = k_vals(:,1);
       else
         der = feval (func, z(1) , u(:,1), args);
       endif
       u_interp = quadratic_interpolation (z, u, der, t);
+
     case 3
-      u_interp = ...
-      hermite_cubic_interpolation (z, u, k_vals, t);
+      u_interp = hermite_cubic_interpolation (z, u, k_vals, t);
+
+    ## FIXME: Do we need an algorithm for order = 4?
     #{
     case 4
       ## if ode45 is used without local extrapolation this function
       ## doesn't require a new function evaluation.
       u_interp = dorpri_interpolation ([z(i-1) z(i)],
                                        [u(:,i-1) u(:,i)],
                                        k_vals, tspan(counter));
     #}
     case 5
       ## ode45 with Dormand-Prince scheme:
       u_interp = hermite_quartic_interpolation (z, u, k_vals, t);
 
-      ## it is also possible to do a new function evaluation and use
-      ## the quintic hermite interpolator
-      ## f_half = feval (func, t+1/2*dt, u_half,
-      ##                 options.funarguments{:});
-      ## u_interp =
-      ##   hermite_quintic_interpolation ([z(i-1) z(i)],
-      ##                                  [u(:,i-1) u_half u(:,i)],
-      ##                                  [k_vals(:,1) f_half ...
-      ##                                   k_vals(:,end)],
-      ##                                  tspan(counter));
-
     otherwise
       warning (["High order interpolation not yet implemented: ", ...
                 "using cubic interpolation instead"]);
       der(:,1) = feval (func, z(1), u(:,1), args);
       der(:,2) = feval (func, z(2), u(:,2), args);
       u_interp = hermite_cubic_interpolation (z, u, der, t);
 
   endswitch
 
 endfunction
 
 ## The function below can be used in an ODE solver to interpolate the solution
-## at the time t_out using 2th order hermite interpolation.
+## at the time t_out using 2nd order Hermite interpolation.
 function x_out = quadratic_interpolation (t, x, der, t_out)
 
   # coefficients of the parabola
   a = -(x(:,1) - x(:,2) - der(:).*(t(1)-t(2))) / (t(1) - t(2))^2;
   b = der(:) - 2*t(1).*a;
   c = x(:,1) - a*t(1)^2 - b*t(1);
 
-  # evauate in t_out
+  # evaluate in t_out
   x_out = a*t_out.^2 + b*t_out + c;
 
 endfunction
 
 ## The function below can be used in an ODE solver to interpolate the
-## solution at the time t_out using 4th order hermite interpolation.
+## solution at the time t_out using 3rd order Hermite interpolation.
+function x_out = hermite_cubic_interpolation (t, x, der, t_out)
+
+  dt = (t(2) - t(1));
+  s = (t_out - t(1)) / dt;
+  x_out = ((1 + 2*s) .* (1-s).^2) .* x(:,1) + ...
+          (s .* (1-s).^2 * dt   ) .* der(:,1) + ...
+          ((3-2*s) .* s.^2      ) .* x(:,2) + ...
+          ((s-1) .* s.^2   * dt ) .* der(:,2);
+
+endfunction
+
+## The function below can be used in an ODE solver to interpolate the
+## solution at the time t_out using 4th order Hermite interpolation.
 function x_out = hermite_quartic_interpolation (t, x, der, t_out)
 
   persistent coefs_u_half = ...
-  [(6025192743/30085553152), 0, (51252292925/65400821598), ...
-   (-2691868925/45128329728), (187940372067/1594534317056), ...
-   (-1776094331/19743644256), (11237099/235043384)].';
+    [6025192743/30085553152; 0; 51252292925/65400821598;
+     -2691868925/45128329728; 187940372067/1594534317056;
+     -1776094331/19743644256; 11237099/235043384];
 
   ## 4th order approximation of y in t+dt/2 as proposed by Shampine in
   ## Lawrence, Shampine, "Some Practical Runge-Kutta Formulas", 1986.
   dt = t(2) - t(1);
   u_half = x(:,1) + (1/2) * dt * (der(:,1:7) * coefs_u_half);
 
   ## Rescale time on [0,1]
   s = (t_out - t(1)) / dt;
@@ -111,21 +113,8 @@ function x_out = hermite_quartic_interpo
   x_out = (1   - 11*s.^2 + 18*s.^3 -  8*s.^4) .* x(:,1) + ...
           (  s -  4*s.^2 +  5*s.^3 -  2*s.^4) .* (dt * der(:,1)) + ...
           (      16*s.^2 - 32*s.^3 + 16*s.^4) .* u_half + ...
           (    -  5*s.^2 + 14*s.^3 -  8*s.^4) .* x(:,2) + ...
           (         s.^2 -  3*s.^3 +  2*s.^4) .* (dt * der(:,end));
 
 endfunction
 
-## The function below can be used in an ODE solver to interpolate the
-## solution at the time t_out using 3rd order hermite interpolation.
-function x_out = hermite_cubic_interpolation (t, x, der, t_out)
-
-  dt = (t(2) - t(1));
-  s = (t_out - t(1)) / dt;
-  x_out = ((1 + 2*s) .* (1-s).^2) .* x(:,1) + ...
-          (s .* (1-s).^2 * dt   ) .* der(:,1) + ...
-          ((3-2*s) .* s.^2      ) .* x(:,2) + ...
-          ((s-1) .* s.^2   * dt ) .* der(:,2);
-
-endfunction
-
diff --git a/scripts/ode/private/starting_stepsize.m b/scripts/ode/private/starting_stepsize.m
--- a/scripts/ode/private/starting_stepsize.m
+++ b/scripts/ode/private/starting_stepsize.m
@@ -35,41 +35,41 @@
 ##
 ## @seealso{odepkg}
 
 function h = starting_stepsize (order, func, t0, x0,
                                 AbsTol, RelTol, normcontrol,
                                 args = {})
 
   ## compute norm of initial conditions
-  d0 = AbsRel_Norm (x0, x0, AbsTol, RelTol, normcontrol);
+  d0 = AbsRel_norm (x0, x0, AbsTol, RelTol, normcontrol);
 
   ## compute norm of the function evaluated at initial conditions
   y = func (t0, x0, args{:});
   if (iscell (y))
     y = y{1};
   endif
-  d1 = AbsRel_Norm (y, y, AbsTol, RelTol, normcontrol);
+  d1 = AbsRel_norm (y, y, AbsTol, RelTol, normcontrol);
 
   if (d0 < 1e-5 || d1 < 1e-5)
     h0 = 1e-6;
   else
     h0 = .01 * (d0 / d1);
   endif
 
   ## compute one step of Explicit-Euler
   x1 = x0 + h0 * y;
 
   ## approximate the derivative norm
   yh = func (t0+h0, x1, args{:});
   if (iscell (yh))
     yh = yh{1};
   endif
   d2 = (1 / h0) * ...
-       AbsRel_Norm (yh - y, yh - y, AbsTol, RelTol, normcontrol);
+       AbsRel_norm (yh - y, yh - y, AbsTol, RelTol, normcontrol);
 
   if (max (d1, d2) <= 1e-15)
     h1 = max (1e-6, h0 * 1e-3);
   else
     h1 = (1e-2 / max (d1, d2)) ^(1 / (order+1));
   endif
 
   h = min (100 * h0, h1);
