# HG changeset patch
# User Rik <rik@octave.org>
# Date 1448252717 28800
#      Sun Nov 22 20:25:17 2015 -0800
# Node ID 418ae0cb752f40522488282efcef4ec52e6d5d0b
# Parent  e44d904ac52506042d1390c650a98b28a75cbb6b
Replace ++,-- with in-place operators for performance.

* inputParser.m, int2str.m, interp2.m, interp3.m, interpn.m, __isequal__.m,
voronoi.m, imshow.m, jet.m, __imread__.m, __imwrite__.m, imwrite_filename.m,
dlmwrite.m, importdata.m, strread.m, krylov.m, fact.m, genvarname.m, fminbnd.m,
fminsearch.m, fminunc.m, fsolve.m, fzero.m, lsqnonneg.m, pqpnonneg.m, qp.m,
sqp.m, annotation.m, legend.m, orient.m, __bar__.m, __contour__.m, __patch__.m,
__plt__.m, __scatter__.m, rectangle.m, surfc.m, figure.m, hdl2struct.m, pan.m,
__gnuplot_draw_axes__.m, __gnuplot_ginput__.m, rotate3d.m, struct2hdl.m,
zoom.m, freqz.m, periodogram.m, gmres.m, pcg.m, pcr.m, __sprand__.m,
sprandsym.m, treelayout.m, treeplot.m, hadamard.m, hilb.m, iqr.m, assert.m,
test.m: Replace ++,-- with in-place operators for performance.

diff --git a/scripts/general/inputParser.m b/scripts/general/inputParser.m
--- a/scripts/general/inputParser.m
+++ b/scripts/general/inputParser.m
@@ -352,18 +352,18 @@ classdef inputParser < handle
         opt = this.Optional{++idx};
         in  = varargin{++vidx};
         if (! opt.val (in))
           ## If it does not match there's two options:
           ##    1) input is actually wrong and we should error;
           ##    2) it's a ParamValue or Switch name and we should use the
           ##       the default for the rest.
           if (ischar (in))
-            idx--;
-            vidx--;
+            idx -= 1;
+            vidx -= 1;
             break
           else
             this.error (sprintf ("failed validation of %s",
                                  toupper (opt.name)));
           endif
         endif
         this.Results.(opt.name) = in;
       endwhile
diff --git a/scripts/general/int2str.m b/scripts/general/int2str.m
--- a/scripts/general/int2str.m
+++ b/scripts/general/int2str.m
@@ -100,17 +100,17 @@ function fmt = get_fmt (x, sep)
     if (isempty (t))
       ## Only zeros, Inf, and NaN.
       fmt = sprintf ("%%%dd", min_fw);
     else
       ## Could have anything.
       tfw = floor (log10 (double (abs (t)))) + 1 + sep;
       fw = max (tfw);
       if (any (t(tfw == fw) < 0))
-        fw++;
+        fw += 1;
       endif
       fmt = sprintf ("%%%dd", max (fw, min_fw));
     endif
   endif
 
 endfunction
 
 
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -93,17 +93,17 @@ function ZI = interp2 (varargin)
     if (! isnumeric (varargin{end}) || ! isscalar (varargin{end}))
       error ("interp2: EXTRAP must be a numeric scalar");
     endif
     extrap = varargin{end};
     method = varargin{end-1};
     nargs -= 2;
   elseif (ischar (varargin{end}))
     method = varargin{end};
-    nargs--;
+    nargs -= 1;
   endif
   if (method(1) == "*")
     warning ("interp2: ignoring unsupported '*' flag to METHOD");
     method(1) = [];
   endif
   method = validatestring (method, ...
     {"nearest", "linear", "pchip", "cubic", "spline"});
 
diff --git a/scripts/general/interp3.m b/scripts/general/interp3.m
--- a/scripts/general/interp3.m
+++ b/scripts/general/interp3.m
@@ -96,17 +96,17 @@ function vi = interp3 (varargin)
     if (! isnumeric (varargin{end}) || ! isscalar (varargin{end}))
       error ("interp3: EXTRAPVAL must be a numeric scalar");
     endif
     extrapval = varargin{end};
     method = varargin{end-1};
     nargs -= 2;
   elseif (ischar (varargin{end}))
     method = varargin{end};
-    nargs--;
+    nargs -= 1;
   endif
 
   if (method(1) == "*")
     warning ("interp3: ignoring unsupported '*' flag to METHOD");
     method(1) = [];
   endif
   method = validatestring (method, ...
     {"nearest", "linear", "cubic", "spline"});
diff --git a/scripts/general/interpn.m b/scripts/general/interpn.m
--- a/scripts/general/interpn.m
+++ b/scripts/general/interpn.m
@@ -86,17 +86,17 @@ function vi = interpn (varargin)
     if (! isnumeric (varargin{end}) || ! isscalar (varargin{end}))
       error ("interpn: EXTRAPVAL must be a numeric scalar");
     endif
     extrapval = varargin{end};
     method = varargin{end-1};
     nargs -= 2;
   elseif (ischar (varargin{end}))
     method = varargin{end};
-    nargs--;
+    nargs -= 1;
   endif
 
   if (method(1) == "*")
     warning ("interpn: ignoring unsupported '*' flag to METHOD");
     method(1) = [];
   endif
   method = validatestring (method, ...
     {"nearest", "linear", "pchip", "cubic", "spline"});
diff --git a/scripts/general/private/__isequal__.m b/scripts/general/private/__isequal__.m
--- a/scripts/general/private/__isequal__.m
+++ b/scripts/general/private/__isequal__.m
@@ -94,40 +94,40 @@ function t = __isequal__ (nans_compare_e
       l_fn_x = numfields (x);
       fn_v = cellfun ("fieldnames", varargin, "uniformoutput", false);
       t = all (l_fn_x == cellfun ("numel", fn_v));
 
       ## Test that all the names are equal.
       idx = 0;
       s_fn_x = sort (fn_x);
       while (t && idx < l_v)
-        idx++;
+        idx += 1;
         ## We'll allow the fieldnames to be in a different order.
         t = all (strcmp (s_fn_x, sort (fn_v{idx})));
       endwhile
 
       idx = 0;
       while (t && idx < l_fn_x)
         ## Test that all field values are equal.
-        idx++;
+        idx += 1;
         args = cell (1, 2+l_v);
         args(1:2) = {nans_compare_equal, {x.(fn_x{idx})}};
         for argn = 1:l_v
           args{argn+2} = {varargin{argn}.(fn_x{idx})};
         endfor
         ## Minimize function calls by calling for all the arguments at once.
         t = __isequal__ (args{:});
       endwhile
 
     elseif (iscell (x))
       ## Check that each element of a cell is equal.
       l_x = numel (x);
       idx = 0;
       while (t && idx < l_x)
-        idx++;
+        idx += 1;
         args = cell (1, 2+l_v);
         args(1:2) = {nans_compare_equal, x{idx}};
         args(3:end) = [cellindexmat(varargin, idx){:}];
 
         t = __isequal__ (args{:});
       endwhile
 
     elseif (ischar (x) && all (cellfun ("isclass", varargin, "char")))
diff --git a/scripts/geometry/voronoi.m b/scripts/geometry/voronoi.m
--- a/scripts/geometry/voronoi.m
+++ b/scripts/geometry/voronoi.m
@@ -78,33 +78,33 @@ function [vx, vy] = voronoi (varargin)
 
   narg = 1;
   hax = NaN;
   if (isscalar (varargin{1}) && ishandle (varargin{1}))
     hax = varargin{1};
     if (! isaxes (hax))
       error ("voronoi: HAX argument must be an axes object");
     endif
-    narg++;
+    narg += 1;
   endif
 
   if (nargin < 1 + narg || nargin > 3 + narg)
     print_usage ();
   endif
 
   x = varargin{narg++};
   y = varargin{narg++};
 
   opts = {};
   if (narg <= nargin)
     if (iscell (varargin{narg}))
       opts = varargin(narg++);
     elseif (isnumeric (varargin{narg}))
       ## Accept, but ignore, the triangulation
-      narg++;
+      narg += 1;
     endif
   endif
 
   linespec = {"b"};
   if (narg <= nargin && ischar (varargin{narg}))
     linespec = varargin(narg);
   endif
 
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -121,52 +121,52 @@ function h = imshow (im, varargin)
         endif
       elseif (! isempty (arg))
         error ("imshow: argument number %d is invalid", narg);
       endif
     elseif (ischar (arg))
       switch (tolower (arg))
         case "border"
           warning ("imshow: border argument is not implemented");
-          narg++;
+          narg += 1;
         case "colormap"
           map = varargin{narg++};
           if (iscolormap (map) && min (map) >= 0 || max (map) <= 1)
             colormap (map);
           else
             error ("imshow: invalid colormap");
           endif
         case "displayrange"
           display_range = varargin{narg++};
         case {"initialmagnification"}
           warning ("imshow: zoom argument ignored -- use GUI features");
-          narg++;
+          narg += 1;
         case "parent"
           prop_val_args(end+(1:2)) = {"parent", varargin{narg++}};
           if (! isaxes (prop_val_args{end}))
             error ("imshow: parent must be an axes handle");
           endif
         case "reduce"
           warning ("imshow: reduce argument is not implemented");
-          narg++;
+          narg += 1;
         case "xdata"
           xdata = varargin{narg++};
           if (! isvector (xdata))
             error ("imshow: xdata must be a vector")
           endif
           xdata = [xdata(1) xdata(end)];
         case "ydata"
           ydata = varargin{narg++};
           if (! isvector (ydata))
             error ("imshow: ydata must be a vector")
           endif
           ydata = [ydata(1) ydata(end)];
         otherwise
           warning ("imshow: unrecognized property %s", arg);
-          narg++;
+          narg += 1;
       endswitch
     else
       error ("imshow: argument number %d is invalid", narg);
     endif
   endwhile
 
   ## Check for complex images.
   if (iscomplex (im))
diff --git a/scripts/image/jet.m b/scripts/image/jet.m
--- a/scripts/image/jet.m
+++ b/scripts/image/jet.m
@@ -44,17 +44,17 @@ function map = jet (n = rows (colormap (
     map = [0, 1, 1];
   elseif (n == 2)
     map = [0, 0, 1
            0, 1, 1];
   elseif (n > 2)
     nel = ceil (n/4);           # number of elements
     idx1 = ceil (3/8 * n) + 1;  # ~3/8*n for large n
     if (mod (n, 8) == 2)
-      idx1++;
+      idx1 += 1;
     endif
     idx2 = idx1 + nel - 1;      # ~5/8*n for large n
     idx3 = min (idx2 + nel, n); # ~7/8*n for large n
 
     r = zeros (n, 1);
     r(idx1:idx2, 1) = [1:nel] / nel;
     r(idx2:idx3, 1) = 1;
     nel2 = n - idx3;
diff --git a/scripts/image/private/__imread__.m b/scripts/image/private/__imread__.m
--- a/scripts/image/private/__imread__.m
+++ b/scripts/image/private/__imread__.m
@@ -54,17 +54,17 @@ function varargout = __imread__ (filenam
   ## pair style. When defining it here, the string "all" is invalid though.
   ## Also, for matlab compatibility, if index is defined both as an option here
   ## and parameter/value pair, silently ignore the first.
   if (nargin >= offset + 1 && ! ischar (varargin{offset}))
     if (! is_valid_index_option (options.index))
       error ("imread: IDX must be a numeric vector");
     endif
     options.index = varargin{offset};
-    offset++;
+    offset += 1;
   endif
 
   if (rem (numel (varargin) - offset + 1, 2) != 0)
     error ("imread: no pair for all arguments (odd number left over)");
   endif
 
   ## Check key/value options.
   indexes = cellfun ("isclass", varargin, "char");
diff --git a/scripts/image/private/__imwrite__.m b/scripts/image/private/__imwrite__.m
--- a/scripts/image/private/__imwrite__.m
+++ b/scripts/image/private/__imwrite__.m
@@ -141,17 +141,17 @@ function __imwrite__ (img, varargin)
         ## to make it loop only once. See
         ## https://sourceforge.net/p/graphicsmagick/bugs/249/
         ## There is also the problem of setting this when there is only
         ## a single frame. See
         ## https://sourceforge.net/p/graphicsmagick/bugs/248/
         if (isinf (options.loopcount))
           options.loopcount = 0;
         elseif (options.loopcount == 0 || options.loopcount == 1)
-          options.loopcount++;
+          options.loopcount += 1;
         endif
         options.loopcount = floor (options.loopcount);
 
       case "quality",
         options.quality = param_list{idx+1};
         if (! isnumeric (options.quality) || ! isscalar (options.quality)
             || options.quality < 0 || options.quality > 100)
           error ("imwrite: value for %s option must be a scalar between 0 and 100",
diff --git a/scripts/image/private/imwrite_filename.m b/scripts/image/private/imwrite_filename.m
--- a/scripts/image/private/imwrite_filename.m
+++ b/scripts/image/private/imwrite_filename.m
@@ -47,17 +47,17 @@ function [filename, ext, cmap, options] 
   ## if we have an odd number of leftover arguments, and the next argument
   ## is a string, we consider it the file extension. Otherwise we will
   ## extract what we can from the previously found filename.
   options_idx = filename_idx + 1;
   if (numel (varargin) > filename_idx
       && rem (length (varargin) - filename_idx, 2) != 0
       && ischar (varargin{filename_idx + 1}))
     ext = varargin{filename_idx + 1};
-    options_idx++;
+    options_idx += 1;
   else
     [~, ~, ext] = fileparts (filename);
     if (! isempty (ext))
       ## remove dot from extension
       ext = ext(2:end);
     endif
   endif
 
diff --git a/scripts/io/dlmwrite.m b/scripts/io/dlmwrite.m
--- a/scripts/io/dlmwrite.m
+++ b/scripts/io/dlmwrite.m
@@ -102,17 +102,17 @@ function dlmwrite (file, M, varargin)
   else
     precision = "%.16g";
   endif
   opentype = "wt";
 
   ## process the input arguments
   i = 0;
   while (i < length (varargin))
-    i++;
+    i += 1;
     if (strcmpi (varargin{i}, "delimiter"))
       delim = varargin{++i};
     elseif (strcmpi (varargin{i}, "newline"))
       newline = varargin{++i};
       if (strcmpi (newline, "unix"))
         newline = "\n";
       elseif (strcmpi (newline, "pc"))
         newline = "\r\n";
@@ -126,17 +126,17 @@ function dlmwrite (file, M, varargin)
     elseif (strcmpi (varargin{i}, "precision"))
       precision = varargin{++i};
       if (! strcmpi (class (precision), "char"))
         precision = sprintf ("%%.%gg", precision);
       endif
     elseif (strcmpi (varargin{i}, "-append"))
       opentype = "at";
     elseif (strcmpi (varargin{i}, "append"))
-      i++;
+      i += 1;
       if (strcmpi (varargin{i}, "on"))
         opentype = "at";
       elseif (strcmpi (varargin{i}, "off"))
         opentype = "wt";
       else
         error ('dlmwrite: append must be "on" or "off"');
       endif
     else
diff --git a/scripts/io/importdata.m b/scripts/io/importdata.m
--- a/scripts/io/importdata.m
+++ b/scripts/io/importdata.m
@@ -186,17 +186,17 @@ function [output, delimiter, header_rows
 
     if (delimiter == " ")
       row_entries = regexp (strtrim (row), ' +', 'split');
     else
       row_entries = ostrsplit (row, delimiter);
     endif
     row_data = str2double (row_entries);
     if (all (isnan (row_data)) || header_rows < num_header_rows)
-      header_rows++;
+      header_rows += 1;
       output.textdata{end+1, 1} = row;
     else
       if (! isempty (output.textdata))
         if (delimiter == " ")
           output.colheaders = regexp (strtrim (output.textdata{end}),
                                       ' +', 'split');
         else
           output.colheaders = ostrsplit (output.textdata{end}, delimiter);
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -384,17 +384,17 @@ function varargout = strread (str, forma
         cidx(1) = []; # Drop the first one if orphaned.
       endif
       cstop = cstop(cidx);
     endif
     len = length (str);
     c2len = length (comment_end);
     if (cstop + c2len == len)
       ## Ignore last char of to-the-end-of-line comments
-      c2len++;
+      c2len += 1;
     end
     str = cellslices (str, [1, cstop + c2len], [cstart - 1, len]);
     str = [str{:}];
   endif
 
   if (! isempty (white_spaces))
     ## For numeric fields, whitespace is always a delimiter, but not for text
     ## fields
@@ -722,32 +722,32 @@ function varargout = strread (str, forma
       ## FIXME: Add support for formats like "<%s>", "%[a-zA-Z]"
       ##        Someone with regexp experience is needed.
       switch (fmt_words{m}(1:min (2, length (fmt_words{m}))))
         case "%s"
           if (pad_out)
             data(end+1:num_lines) = {""};
           endif
           varargout{k} = data';
-          k++;
+          k += 1;
         case {"%d", "%u", "%f", "%n"}
           n = cellfun ("isempty", data);
           ### FIXME: Erroneously formatted data lead to NaN, not an error
           data = str2double (data);
           if (! isempty (regexp (fmt_words{m}, "%[du]")))
             ## Cast to integer
             ## FIXME: NaNs will be transformed into zeros
             data = int32 (data);
           endif
           data(n) = numeric_fill_value;
           if (pad_out)
             data(end+1:num_lines) = numeric_fill_value;
           endif
           varargout{k} = data.';
-          k++;
+          k += 1;
         case {"%0", "%1", "%2", "%3", "%4", "%5", "%6", "%7", "%8", "%9"}
           sw = regexp (fmt_words{m}, '\d', "once");
           ew = regexp (fmt_words{m}, '[nfudsq]') - 1;
           nfmt = ostrsplit (fmt_words{m}(2:ew), ".");
           swidth = str2double (nfmt{1});
           switch (fmt_words{m}(ew+1))
             case {"d", "u", "f", "n"}
               n = cellfun ("isempty", data);
@@ -762,23 +762,23 @@ function varargout = strread (str, forma
                 sprec = str2double (nfmt{2});
                 data = 10^-sprec * round (10^sprec * data);
               elseif (! isempty (regexp (fmt_words{m}, "[du]")))
                 ## Cast to integer
                 ## FIXME: NaNs will be transformed into zeros
                 data = int32 (data);
               endif
               varargout{k} = data.';
-              k++;
+              k += 1;
             case "s"
               if (pad_out)
                 data(end+1:num_lines) = {""};
               endif
               varargout{k} = strtrunc (data, swidth)';
-              k++;
+              k += 1;
             otherwise
           endswitch
         case {"%*", "%*s"}
           ## skip the word
         otherwise
           ## Ensure descriptive content is consistent.
           ## Test made a bit lax to accomodate for incomplete last lines
           n = find (! cellfun ("isempty", data));
diff --git a/scripts/linear-algebra/krylov.m b/scripts/linear-algebra/krylov.m
--- a/scripts/linear-algebra/krylov.m
+++ b/scripts/linear-algebra/krylov.m
@@ -110,17 +110,17 @@ function [Uret, H, nu] = krylov (A, V, k
 
   ## Set up vector of pivot points.
   pivot_vec = 1:na;
 
   iter = 0;
   alpha = [];
   nh = 0;
   while (length (alpha) < na) && (columns (V) > 0) && (iter < k)
-    iter++;
+    iter += 1;
 
     ## Get orthogonal basis of V.
     jj = 1;
     while (jj <= columns (V) && length (alpha) < na)
       ## Index of next Householder reflection.
       nu = length (alpha)+1;
 
       short_pv = pivot_vec(nu:na);
@@ -132,17 +132,17 @@ function [Uret, H, nu] = krylov (A, V, k
         nv = columns (V);
         if (jj != nv)
           [V(:,jj), V(:,nv)] = swap (V(:,jj), V(:,nv));
           ## FIXME: H columns should be swapped too.
           ##        Not done since Block Hessenberg structure is lost anyway.
         endif
         V = V(:,1:(nv-1));
         ## One less reflection.
-        nu--;
+        nu -= 1;
       else
         ## New householder reflection.
         if (pflg)
           ## Locate max magnitude element in short_q.
           asq = abs (short_q);
           maxv = max (asq);
           maxidx = find (asq == maxv, 1);
           pivot_idx = short_pv(maxidx);
@@ -166,17 +166,17 @@ function [Uret, H, nu] = krylov (A, V, k
         ## Reduce V per the reflection.
         V(idx,:) = V(idx,:) - av*hv*(hv' * V(idx,:));
         if(iter > 1)
           ## FIXME: not done correctly for block case.
           H(nu,nu-1) = V(pivot_vec(nu),jj);
         endif
 
         ## Advance to next column of V.
-        jj++;
+        jj += 1;
       endif
     endwhile
 
     ## Check for oversize V (due to full rank).
     if ((columns (V) > na) && (length (alpha) == na))
       ## Trim to size.
       V = V(:,1:na);
     elseif (columns(V) > na)
diff --git a/scripts/miscellaneous/fact.m b/scripts/miscellaneous/fact.m
--- a/scripts/miscellaneous/fact.m
+++ b/scripts/miscellaneous/fact.m
@@ -273,20 +273,20 @@ function out = wordwrap (w)
   out = "\n";
   i = 1;
   numwords = numel (wc);
   while (i <= numwords);
     line = wc{i};
     while (i < numwords
            && length (newline = [line " " wc{i+1}]) < ncol)
       line = newline;
-      i++;
+      i += 1;
     endwhile
     out = [out, line, "\n"];
-    i++;
+    i += 1;
   endwhile
   out = [out, "\n"];
 endfunction
 
 
 ## Mark file as being tested.  No real test needed for a documentation .m file
 %!assert (1)
 
diff --git a/scripts/miscellaneous/genvarname.m b/scripts/miscellaneous/genvarname.m
--- a/scripts/miscellaneous/genvarname.m
+++ b/scripts/miscellaneous/genvarname.m
@@ -155,17 +155,17 @@ function varname = genvarname (str, excl
     if (excluded && isdigit (str{i}(end)))
       ## if it is not unique and ends with a digit, add an underscore to
       ## make the variable name more readable ("x1_1" instead of "x11")
       str{i} = [str{i}, "_"];
     endif
     varname(i) = str(i);
     idx = 0;
     while (excluded)
-      idx++;
+      idx += 1;
       varname{i} = sprintf ("%s%d", str{i}, idx);
       excluded = any (strcmp (varname{i}, exclusions));
     endwhile
     exclusions(end+1) = varname(i);
   endfor
 
   if (strinput)
     varname = varname{1};
diff --git a/scripts/optimization/fminbnd.m b/scripts/optimization/fminbnd.m
--- a/scripts/optimization/fminbnd.m
+++ b/scripts/optimization/fminbnd.m
@@ -101,17 +101,17 @@ function [x, fval, info, output] = fminb
   sqrteps = eps (class (xmin + xmax));
 
   c = 0.5*(3 - sqrt (5));
   a = xmin; b = xmax;
   v = a + c*(b-a);
   w = x = v;
   e = 0;
   fv = fw = fval = fun (x);
-  nfev++;
+  nfev += 1;
 
   ## Only for display purposes.
   iter(1).funccount = nfev;
   iter(1).x = x;
   iter(1).fx = fval;
 
   while (niter < maxiter && nfev < maxfev)
     xm = 0.5*(a+b);
@@ -164,17 +164,17 @@ function [x, fval, info, output] = fminb
       e = ifelse (x >= xm, a - x, b - x);
       d = c * e;
     endif
 
     ## f must not be evaluated too close to x.
     u = x + max (abs (d), tol) * (sign (d) + (d == 0));
     fu = fun (u);
 
-    niter++;
+    niter += 1;
 
     iter(niter).funccount = nfev++;
     iter(niter).x = u;
     iter(niter).fx = fu;
 
     ## update  a, b, v, w, and x
 
     if (fu < fval)
diff --git a/scripts/optimization/fminsearch.m b/scripts/optimization/fminsearch.m
--- a/scripts/optimization/fminsearch.m
+++ b/scripts/optimization/fminsearch.m
@@ -206,17 +206,17 @@ function [x, fmax, nf] = nmsmax (fun, x,
   [~,j] = sort (f);
   j = j(n+1:-1:1);
   f = f(j);
   V = V(:,j);
 
   alpha = 1;  beta = 1/2;  gamma = 2;
 
   while (1)   # Outer (and only) loop.
-    k++;
+    k += 1;
 
     if (k > maxiter)
       msg = "Exceeded maximum iterations...quitting\n";
       break;
     endif
 
     fmax = f(1);
     if (fmax > fmax_old)
diff --git a/scripts/optimization/fminunc.m b/scripts/optimization/fminunc.m
--- a/scripts/optimization/fminunc.m
+++ b/scripts/optimization/fminunc.m
@@ -291,17 +291,17 @@ function [x, fval, info, output, grad, h
         endif
       endif
 
       if (ratio >= 1e-4)
         ## Successful iteration.
         x += s;
         xn = norm (dg .* x);
         fval = fval1;
-        nsuciter++;
+        nsuciter += 1;
         suc = true;
       endif
 
       niter += 1;
 
       ## FIXME: should outputfcn be called only after a successful iteration?
       if (! isempty (outfcn))
         optimvalues.iter = niter;
diff --git a/scripts/optimization/fsolve.m b/scripts/optimization/fsolve.m
--- a/scripts/optimization/fsolve.m
+++ b/scripts/optimization/fsolve.m
@@ -231,17 +231,17 @@ function [x, fvec, info, output, fjac] =
     ## Calculate function value and Jacobian (possibly via FD).
     if (has_jac)
       [fvec, fjac] = fcn (reshape (x, xsiz));
       ## If the Jacobian is sparse, disable Broyden updating.
       if (issparse (fjac))
         updating = false;
       endif
       fvec = fvec(:);
-      nfev++;
+      nfev += 1;
     else
       fjac = __fdjac__ (fcn, reshape (x, xsiz), fvec, typicalx, cdif);
       nfev += (1 + cdif) * length (x);
     endif
 
     ## For square and overdetermined systems, we update a QR
     ## factorization of the Jacobian to avoid solving a full system in each
     ## step. In this case, we pass a triangular matrix to __dogleg__.
@@ -306,17 +306,17 @@ function [x, fvec, info, output, fjac] =
 
       sn = norm (dg .* s);
       if (niter == 1)
         delta = min (delta, sn);
       endif
 
       fvec1 = fcn (reshape (x + s, xsiz)) (:);
       fn1 = norm (fvec1);
-      nfev++;
+      nfev += 1;
 
       if (fn1 < fn)
         ## Scaled actual reduction.
         actred = 1 - (fn1/fn)^2;
       else
         actred = -1;
       endif
 
@@ -328,46 +328,46 @@ function [x, fvec, info, output, fjac] =
       else
         prered = 0;
         ratio = 0;
       endif
 
       ## Update delta.
       if (ratio < min (max (0.1, 0.8*lastratio), 0.9))
         nsuc = 0;
-        nfail++;
+        nfail += 1;
         delta *= decfac;
         decfac ^= 1.4142;
         if (delta <= 1e1*macheps*xn)
           ## Trust region became uselessly small.
           info = -3;
           break;
         endif
       else
         lastratio = ratio;
         decfac = 0.5;
         nfail = 0;
-        nsuc++;
+        nsuc += 1;
         if (abs (1-ratio) <= 0.1)
           delta = 1.4142*sn;
         elseif (ratio >= 0.5 || nsuc > 1)
           delta = max (delta, 1.4142*sn);
         endif
       endif
 
       if (ratio >= 1e-4)
         ## Successful iteration.
         x += s;
         xn = norm (dg .* x);
         fvec = fvec1;
         fn = fn1;
-        nsuciter++;
+        nsuciter += 1;
       endif
 
-      niter++;
+      niter += 1;
 
       ## FIXME: should outputfcn be only called after a successful iteration?
       if (! isempty (outfcn))
         optimvalues.iter = niter;
         optimvalues.funccount = nfev;
         optimvalues.fval = fn;
         optimvalues.searchdirection = s;
         state = 'iter';
diff --git a/scripts/optimization/fzero.m b/scripts/optimization/fzero.m
--- a/scripts/optimization/fzero.m
+++ b/scripts/optimization/fzero.m
@@ -271,17 +271,17 @@ function [x, fval, info, output] = fzero
       c = (a + b)/2;
     else
       c = max (a + delta, min (b - delta, c));
     endif
 
     ## Calculate new point.
     x = c;
     fval = fc = fun (c);
-    niter++; nfev++;
+    niter += 1; nfev += 1;
 
     ## Modification 2: skip inverse cubic interpolation if
     ## nonmonotonicity is detected.
     if (sign (fc - fa) * sign (fc - fb) >= 0)
       ## The new point broke monotonicity.
       ## Disable inverse cubic.
       fe = fc;
     else
diff --git a/scripts/optimization/lsqnonneg.m b/scripts/optimization/lsqnonneg.m
--- a/scripts/optimization/lsqnonneg.m
+++ b/scripts/optimization/lsqnonneg.m
@@ -112,17 +112,17 @@ function [x, resnorm, residual, exitflag
     [q, r] = qr (c(:,p), 0);
   endif
 
   iter = 0;
 
   ## LH3: test for completion.
   while (iter < max_iter)
     while (iter < max_iter)
-      iter++;
+      iter += 1;
 
       ## LH6: compute the positive matrix and find the min norm solution
       ## of the positive problem.
       if (useqr)
         xtmp = r \ q'*d;
       else
         xtmp = c(:,p) \ d;
       endif
diff --git a/scripts/optimization/pqpnonneg.m b/scripts/optimization/pqpnonneg.m
--- a/scripts/optimization/pqpnonneg.m
+++ b/scripts/optimization/pqpnonneg.m
@@ -106,17 +106,17 @@ function [x, minval, exitflag, output, l
   r = chol (c(p, p));
   usechol = true;
 
   iter = 0;
 
   ## LH3: test for completion.
   while (iter < max_iter)
     while (iter < max_iter)
-      iter++;
+      iter += 1;
 
       ## LH6: compute the positive matrix and find the min norm solution
       ## of the positive problem.
       if (usechol)
         xtmp = -(r \ (r' \ d(p)));
       else
         xtmp = -(c(p,p) \ d(p));
       endif
diff --git a/scripts/optimization/qp.m b/scripts/optimization/qp.m
--- a/scripts/optimization/qp.m
+++ b/scripts/optimization/qp.m
@@ -119,17 +119,17 @@ function [x, obj, INFO, lambda] = qp (x0
   if (nargin == 1 && ischar (x0) && strcmp (x0, "defaults"))
     x = optimset ("MaxIter", 200);
     return;
   endif
 
   nargs = nargin;
   if (nargs > 2 && isstruct (varargin{end}))
     options = varargin{end};
-    nargs--;
+    nargs -= 1;
   else
     options = struct ();
   endif
 
   if (nargs != 2 && nargs != 3 && nargs != 5 && nargs != 7 && nargs != 10)
     print_usage ();
   endif
 
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -535,17 +535,17 @@ function [merit, obj, globals] = phi_L1 
   ci = feval (ci_fun, x);
 
   idx = ci < 0;
 
   con = [ce; ci(idx)];
 
   if (isempty (obj))
     obj = feval (obj_fun, x);
-    globals.nfun++;
+    globals.nfun += 1;
   endif
 
   merit = obj;
   t = norm (con, 1) / mu;
 
   if (! isempty (t))
     merit += t;
   endif
diff --git a/scripts/plot/appearance/annotation.m b/scripts/plot/appearance/annotation.m
--- a/scripts/plot/appearance/annotation.m
+++ b/scripts/plot/appearance/annotation.m
@@ -156,26 +156,26 @@ function varargout = annotation (varargi
     print_usage ();
   endif
 
 
   ## Parent figure
   if (isfigure (varargin{1}))
     hf = varargin{1};
     varargin = varargin(2:end);
-    nargin--;
+    nargin -= 1;
   endif
 
   ## Annotation type
   types = {"line", "arrow", "doublearrow", "textarrow", ...
            "textbox", "ellipse", "rectangle"};
   if (ischar (varargin{1}))
     objtype = varargin{1};
     varargin(1) = [];
-    nargin--;
+    nargin -= 1;
   else
     print_usage ();
   endif
 
   switch (objtype)
     case types(1:4)
 
       if (nargin == 0)
diff --git a/scripts/plot/appearance/legend.m b/scripts/plot/appearance/legend.m
--- a/scripts/plot/appearance/legend.m
+++ b/scripts/plot/appearance/legend.m
@@ -190,17 +190,17 @@ function [hleg, hleg_obj, hplot, labels]
 
   ## Process old way of specifying location with a number rather than a string.
   if (nargs > 0)
     pos = varargin{nargs};
     if (isnumeric (pos) && isscalar (pos) && pos == fix (pos))
       if (pos >= -1 && pos <= 4)
         location = [{"northeastoutside", "best", "northeast",
                      "northwest", "southwest", "southeast"}] {pos + 2};
-        nargs--;
+        nargs -= 1;
       else
         error ("legend: invalid location specified");
       endif
     endif
   endif
 
   ## Find location and orientation property/value pairs
   while (nargs > 1)
@@ -250,47 +250,47 @@ function [hleg, hleg_obj, hplot, labels]
     if (ischar (arg))
       if (rows (arg) == 1)
         str = tolower (strtrim (arg));
         switch (str)
           case "off"
             delete_leg = true;
           case "hide"
             show = "off";
-            nargs--;
+            nargs -= 1;
           case "show"
             if (! isempty (hlegend))
               show = "on";
             else
               show = "create";
               textpos = "right";
             endif
-            nargs--;
+            nargs -= 1;
           case "toggle"
             if (isempty (hlegend))
               show = "create";
               textpos = "right";
             elseif (strcmp (get (hlegend, "visible"), "off"))
               show = "on";
             else
               show = "off";
             endif
-            nargs--;
+            nargs -= 1;
           case "boxon"
             box = "on";
-            nargs--;
+            nargs -= 1;
           case "boxoff"
             box = "off";
-            nargs--;
+            nargs -= 1;
           case "left"
             textpos = "left";
-            nargs--;
+            nargs -= 1;
           case "right"
             textpos = "right";
-            nargs--;
+            nargs -= 1;
         endswitch
       else
         ## Character matrix of labels
         varargin = cellstr (arg);
         nargs = numel (varargin);
       endif
     elseif (iscellstr (arg))
       ## Cell array of labels
@@ -926,26 +926,26 @@ function [hleg, hleg_obj, hplot, labels]
               ## FIXME: Need listeners, as for line objects.
 
           endswitch
 
           set (texthandle(k), "position",
                               [(txoffset + xk * xstep) / lpos(3), ...
                                (lpos(4) - yoffset - yk * ystep) / lpos(4)]);
           if (strcmp (orientation, "vertical"))
-            yk++;
+            yk += 1;
             if (yk > num1)
               yk = 0;
-              xk++;
+              xk += 1;
             endif
           else
-            xk++;
+            xk += 1;
             if (xk > num1)
               xk = 0;
-              yk++;
+              yk += 1;
             endif
           endif
         endfor
 
         ## Add an invisible text object to original axis
         ## that when it is destroyed will remove the legend
         props = {"parent", ca(1), "tag", "legend", ...
                  "handlevisibility", "off", "visible", "off", ...
diff --git a/scripts/plot/appearance/orient.m b/scripts/plot/appearance/orient.m
--- a/scripts/plot/appearance/orient.m
+++ b/scripts/plot/appearance/orient.m
@@ -49,17 +49,17 @@
 
 function retval = orient (varargin)
 
   nargs = nargin;
 
   if (nargs > 0 && numel (varargin{1}) == 1 && isfigure (varargin{1}))
     cf = varargin{1};
     varargin(1) = [];
-    nargs--;
+    nargs -= 1;
   else
     cf = gcf ();
   endif
 
   if (nargs > 1)
     print_usage ();
   endif
 
diff --git a/scripts/plot/draw/private/__bar__.m b/scripts/plot/draw/private/__bar__.m
--- a/scripts/plot/draw/private/__bar__.m
+++ b/scripts/plot/draw/private/__bar__.m
@@ -64,38 +64,38 @@ function varargout = __bar__ (vertical, 
     idx = 2;
   endif
 
   newargs = {};
   have_line_spec = false;
   while (idx <= nargin)
     if (ischar (varargin{idx}) && strcmpi (varargin{idx}, "grouped"))
       group = true;
-      idx++;
+      idx += 1;
     elseif (ischar (varargin{idx}) && strcmpi (varargin{idx}, "stacked"))
       group = false;
-      idx++;
+      idx += 1;
     elseif (ischar (varargin{idx}) && strcmpi (varargin{idx}, "histc"))
       group = true;
       histc = true;
-      idx++;
+      idx += 1;
     elseif (ischar (varargin{idx}) && strcmpi (varargin{idx}, "hist"))
       group = true;
       histc = false;
-      idx++;
+      idx += 1;
     else
       if ((ischar (varargin{idx}) || iscellstr (varargin{idx}))
           && ! have_line_spec)
         [linespec, valid] = __pltopt__ (func, varargin{idx}, false);
         if (valid)
           have_line_spec = true;
           ## FIXME: strange parse error requires semicolon to be spaced
           ##        away from closing ']' on next line.
           newargs = [{"facecolor", linespec.color}, newargs] ;
-          idx++;
+          idx += 1;
           continue;
         endif
       endif
       if (isscalar (varargin{idx}))
         width = varargin{idx++};
       elseif (idx == nargin)
         newargs = [newargs, varargin(idx++)];
       elseif (ischar (varargin{idx})
diff --git a/scripts/plot/draw/private/__contour__.m b/scripts/plot/draw/private/__contour__.m
--- a/scripts/plot/draw/private/__contour__.m
+++ b/scripts/plot/draw/private/__contour__.m
@@ -59,17 +59,17 @@ function [c, hg] = __contour__ (varargin
           opts(end+(1:2)) = varargin(i:i+1);
           varargin(i:i+1) = [];
         else
           error ("__contour__: Uneven number of PROP/VAL pairs");
         endif
       endif
 
     else  # skip numeric arguments
-      i++;
+      i += 1;
     endif
   endwhile
 
   if (length (varargin) < 5)
     z1 = varargin{3};
     x1 = 1 : columns (z1);
     y1 = 1 : rows (z1);
   else
@@ -228,17 +228,17 @@ function add_patch_children (hg)
   if (strcmp (filled, "on"))
 
     lvl_eps = get_lvl_eps (lev);
 
     ## Decode contourc output format.
     i = 1;
     ncont = 0;
     while (i < columns (c))
-      ncont++;
+      ncont += 1;
       cont_lev(ncont) = c(1, i);
       cont_len(ncont) = c(2, i);
       cont_idx(ncont) = i+1;
       ii = i + (1:cont_len(ncont));
       cont_area(ncont) = polyarea (c(1, ii), c(2, ii));
       i += cont_len(ncont) + 1;
     endwhile
 
@@ -259,17 +259,17 @@ function add_patch_children (hg)
           curr_ct_len = cont_len(pa_idx);
           ## get contour
           curr_ct = c(:, curr_ct_idx:curr_ct_idx+curr_ct_len-1);
           b_vec = (a+1):len;
           next_ct_pt_vec = c(:, cont_idx(lvl_idx(b_vec)));
           in = inpolygon (next_ct_pt_vec(1,:), next_ct_pt_vec(2,:),
                           curr_ct(1, :), curr_ct(2, :));
           mark(b_vec(in)) = ! mark(b_vec(in));
-          a++;
+          a += 1;
         endwhile
         if (numel (mark) > 0)
           ## All marked contours describe a hole in a larger contour of
           ## the same level and must be filled with colour of level below.
           ma_idx = lvl_idx(mark);
           if (k > 1)
             ## Find color of level below.
             tmp = find (abs (cont_lev - lev(k - 1)) < lvl_eps);
diff --git a/scripts/plot/draw/private/__patch__.m b/scripts/plot/draw/private/__patch__.m
--- a/scripts/plot/draw/private/__patch__.m
+++ b/scripts/plot/draw/private/__patch__.m
@@ -70,17 +70,17 @@ function [h, failed] = __patch__ (p, var
         endif
       elseif (nargin > 2 && all (is_numeric_arg(1:2)))
         x = varargin{1};
         y = varargin{2};
         z = [];
         iarg = 3;
         if (rem (nargin - iarg, 2) == 1)
           c = varargin{iarg};
-          iarg++;
+          iarg += 1;
         else
           c = [];
         endif
       endif
 
       if (isvector (x))
         x = x(:);
         y = y(:);
diff --git a/scripts/plot/draw/private/__plt__.m b/scripts/plot/draw/private/__plt__.m
--- a/scripts/plot/draw/private/__plt__.m
+++ b/scripts/plot/draw/private/__plt__.m
@@ -81,27 +81,27 @@ function retval = __plt__ (caller, h, va
                     "three dimensions"], caller)
           warned_callers(end+1) = caller;
         endif
       endif
       if (isnumeric (next_arg) && ndims (next_arg) > 2)
         error ("%s: plot arrays must have less than 2 dimensions", caller)
       endif
 
-      nargs--;
+      nargs -= 1;
 
       if (ischar (next_arg) || iscellstr (next_arg))
         if (x_set)
           [options, valid] = __pltopt__ (caller, next_arg, false);
           if (! valid)
             if (nargs == 0)
               error ("%s: properties must appear followed by a value", caller);
             endif
             properties = [properties, [next_cell, varargin(k++)]];
-            nargs--;
+            nargs -= 1;
             continue;
           else
             while (nargs > 0 && ischar (varargin{k}))
               if (nargs < 2)
                 error ("%s: properties must appear followed by a value",
                        caller);
               endif
               properties = [properties, varargin(k:k+1)];
diff --git a/scripts/plot/draw/private/__scatter__.m b/scripts/plot/draw/private/__scatter__.m
--- a/scripts/plot/draw/private/__scatter__.m
+++ b/scripts/plot/draw/private/__scatter__.m
@@ -37,17 +37,17 @@ function hg = __scatter__ (varargin)
   endif
 
   if (istart <= nargin)
     s = varargin{istart}(:);
     if (isempty (s) || ischar (s))
       s = 6;
     endif
     if (! ischar (varargin{istart}))
-      istart++;
+      istart += 1;
     endif
   else
     s = 6;
   endif
 
   ## Remove NaNs
   idx = isnan (x) | isnan (y) | isnan (s);
   if (nd == 3)
@@ -74,17 +74,17 @@ function hg = __scatter__ (varargin)
     c = varargin{istart};
     if (isvector (c) && columns (c) != 3)
       c = c(:);
     endif
   elseif (firstnonnumeric == istart && ischar (varargin{istart})
           && ! (   strcmpi (varargin{istart}, "filled")
                 || strcmpi (varargin{istart}, "fill")))
     c = varargin{istart};
-    firstnonnumeric++;
+    firstnonnumeric += 1;
   else
     c = [];
   endif
 
   ## Validate inputs
   if (nd == 2 && ! size_equal (x, y))
     error ([fcn ": X and Y must have the same size"]);
   elseif (nd == 3 && ! size_equal (x, y, z))
diff --git a/scripts/plot/draw/rectangle.m b/scripts/plot/draw/rectangle.m
--- a/scripts/plot/draw/rectangle.m
+++ b/scripts/plot/draw/rectangle.m
@@ -114,20 +114,20 @@ function hg = __rectangle__ (hax, vararg
         varargin(iarg:iarg+1) = [];
       elseif (strcmpi (arg, "facecolor"))
         fc = varargin{iarg+1};
         varargin(iarg:iarg+1) = [];
       elseif (strcmpi (arg, "parent"))
         parent = varargin{iarg+1};
         varargin(iarg:iarg+1) = [];
       else
-        iarg++;
+        iarg += 1;
       endif
     else
-      iarg++;
+      iarg += 1;
     endif
   endwhile
 
   if (numel (curv2) == 1)
     [a, ai] = min (pos(3:4));
     [b, bi] = max (pos(3:4));
     if (ai < bi)
       curv = [curv2, curv2 .* a ./ b];
diff --git a/scripts/plot/draw/surfc.m b/scripts/plot/draw/surfc.m
--- a/scripts/plot/draw/surfc.m
+++ b/scripts/plot/draw/surfc.m
@@ -88,17 +88,17 @@ function h = surfc (varargin)
 
     drawnow ();
 
     ## don't pass string arguments to __contour__()
     stop_idx = find (cellfun ("isclass", varargin, "char"), 1);
     if (isempty (stop_idx))
       stop_idx = nargin;
     else
-      stop_idx--;
+      stop_idx -= 1;
     endif
 
     if (stop_idx - 1 == 1 || stop_idx - 1 == 3)
       ## Don't pass a color matrix c to __contour__
       stop_idx -= 1;
     endif
 
     zmin = get (hax, "zlim")(1);
diff --git a/scripts/plot/util/figure.m b/scripts/plot/util/figure.m
--- a/scripts/plot/util/figure.m
+++ b/scripts/plot/util/figure.m
@@ -52,22 +52,22 @@ function h = figure (varargin)
     arg = varargin{1};
     if (ischar (arg))
       arg = str2double (arg);
     endif
     if (isscalar (arg) && isfigure (arg))
       f = arg;
       init_new_figure = false;
       varargin(1) = [];
-      nargs--;
+      nargs -= 1;
     elseif (isscalar (arg) && isnumeric (arg) && arg > 0 && arg == fix (arg))
       f = arg;
       init_new_figure = true;
       varargin(1) = [];
-      nargs--;
+      nargs -= 1;
     else
       error ("figure: N must be figure handle or figure number");
     endif
   endif
 
   if (rem (nargs, 2) == 1)
     error ("figure: PROPERTY/VALUE arguments must be in pairs");
   endif
diff --git a/scripts/plot/util/hdl2struct.m b/scripts/plot/util/hdl2struct.m
--- a/scripts/plot/util/hdl2struct.m
+++ b/scripts/plot/util/hdl2struct.m
@@ -54,63 +54,63 @@ function s = hdl2struct (h)
   lg = findobj (h, "-depth", 1, "tag", "legend");
   cb = findobj (h, "-depth", 1, "tag", "colorbar");
   ui = findobj (h, "-depth", 1, "type", "uimenu");
   nkids = length (kids);
   ii = 0;
   while (nkids)
     if (! any (kids (nkids) == lg) && ! any (kids (nkids) == cb)
           && ! any (kids (nkids) == ui) && ! strcmp (main.type, "hggroup"))
-      ii++;
+      ii += 1;
       s.children(ii) = hdl2struct (kids(nkids));
     endif
-    nkids--;
+    nkids -= 1;
   endwhile
 
   ## add non "children" children objects (title, xlabel, ...) and
   ## hggroup children and tag theim in "special"
   special = [];
   if (strcmp (main.type, "hggroup"))
     special = main.children;
   endif
   special = [special getspecial(h)];
   nsp = length (special);
   while (nsp)
-    ii++;
+    ii += 1;
     s.children(ii) = hdl2struct (special(nsp));
     s.special(nsp) = ii;
-    nsp--;
+    nsp -= 1;
   endwhile
 
   ## look for legends and colorbars among "main"'s brothers and add them
   ## to the children list
   if (strcmp (main.type, "axes"))
     par = main.parent;
     lg = findobj (par, "-depth", 1, "tag", "legend");
     if (! isempty (lg))
       idx = arrayfun (@(x) get(x).userdata.handle(end) == h, lg);
       lg = lg(find (idx));
     endif
     nlg = length (lg);
     if (nlg == 1)
-      ii++;
+      ii += 1;
       s.children(ii) = hdl2struct (lg);
     elseif (nlg > 1)
       error ("hdl2struct: more than one legend found");
     endif
 
     cb = findobj (par, "-depth", 1, "tag", "colorbar");
     if (! isempty (cb))
       idx = arrayfun (@(x) get(x).axes == h, cb);
       cb = cb(find (idx));
     endif
 
     ncb = length (cb);
     if (ncb == 1)
-      ii++;
+      ii += 1;
       s.children(ii) = hdl2struct (cb);
     elseif (nlg > 1)
       error ("hdl2struct: more than one colorbar found");
     endif
   endif
 
   set (0, "showhiddenhandles", hiddenh);
 
@@ -147,21 +147,21 @@ function prpstr = getprops (h)
             "currentcharacter", "currentobject","tightinset", ...
             "currentpoint", "extent"};
 
   nflds = length (fields);
   ii = 0;
   while (nflds)
     prop = fields{nflds};
     val = obj.(fields{nflds});
-    ii++;
+    ii += 1;
     if (! any (strcmp (prop, forbid)))
       prpstr.(prop) = val;
     endif
-    nflds--;
+    nflds -= 1;
   endwhile
 
   ## hidden properties
   hidden = {"autopos_tag", "looseinset"};
   for ii = 1:numel (hidden)
     if (isprop (h, hidden{ii}))
       prpstr.(hidden{ii}) = get (h, hidden{ii});
     endif
diff --git a/scripts/plot/util/pan.m b/scripts/plot/util/pan.m
--- a/scripts/plot/util/pan.m
+++ b/scripts/plot/util/pan.m
@@ -52,17 +52,17 @@ function pan (varargin)
   if (nargin == 1 && nargout > 0 && isfigure (varargin{1}))
     error ("pan: syntax 'handle = pan (hfig)' not implemented");
   endif
 
   if (nargs == 2)
     hfig = varargin{1};
     if (isfigure (hfig))
       varargin(1) = [];
-      nargs--;
+      nargs -= 1;
     else
       error ("pan: invalid figure handle HFIG");
     endif
   endif
 
   if (isnan (hfig))
     hfig = gcf ();
   endif
diff --git a/scripts/plot/util/private/__gnuplot_draw_axes__.m b/scripts/plot/util/private/__gnuplot_draw_axes__.m
--- a/scripts/plot/util/private/__gnuplot_draw_axes__.m
+++ b/scripts/plot/util/private/__gnuplot_draw_axes__.m
@@ -489,17 +489,17 @@ function __gnuplot_draw_axes__ (h, plot_
         img_xdata = obj.xdata;
         img_ydata = obj.ydata;
 
         if (ndims (img_data) == 3)
           truecolor = true;
         elseif (strcmpi (obj.cdatamapping, "direct"))
           cdatadirect = true;
         endif
-        data_idx++;
+        data_idx += 1;
         is_image_data(data_idx) = true;
         parametric(data_idx) = false;
         have_cdata(data_idx) = false;
         have_3d_patch(data_idx) = false;
 
         if (img_xdata(2) < img_xdata(1))
           img_xdata = img_xdata(2:-1:1);
           img_data = img_data(:,end:-1:1,:);
@@ -559,17 +559,17 @@ function __gnuplot_draw_axes__ (h, plot_
 
       case "line"
         if (strcmp (obj.linestyle, "none")
             && (! isfield (obj, "marker")
                 || (isfield (obj, "marker")
                     && strcmp (obj.marker, "none"))))
           continue;
         endif
-        data_idx++;
+        data_idx += 1;
         is_image_data(data_idx) = false;
         parametric(data_idx) = true;
         have_cdata(data_idx) = false;
         have_3d_patch(data_idx) = false;
         if (isempty (obj.displayname))
           titlespec{data_idx} = "title \"\"";
         else
           tmp = undo_string_escapes (
@@ -603,29 +603,29 @@ function __gnuplot_draw_axes__ (h, plot_
 
         style = do_linestyle_command (obj, obj.color, data_idx, mono,
                                       plot_stream, errbars);
 
         withclause{data_idx} = sprintf ("with %s linestyle %d",
                                         style{1}, data_idx);
 
         if (length (style) > 1)
-          data_idx++;
+          data_idx += 1;
           is_image_data(data_idx) = is_image_data(data_idx - 1);
           parametric(data_idx) = parametric(data_idx - 1);
           have_cdata(data_idx) = have_cdata(data_idx - 1);
           have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
           titlespec{data_idx} = "title \"\"";
           usingclause{data_idx} = usingclause{data_idx - 1};
           data{data_idx} = data{data_idx - 1};
           withclause{data_idx} = sprintf ("with %s linestyle %d",
                                           style{2}, data_idx);
         endif
         if (length (style) > 2)
-          data_idx++;
+          data_idx += 1;
           is_image_data(data_idx) = is_image_data(data_idx - 1);
           parametric(data_idx) = parametric(data_idx - 1);
           have_cdata(data_idx) = have_cdata(data_idx - 1);
           have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
           titlespec{data_idx} = "title \"\"";
           usingclause{data_idx} = usingclause{data_idx - 1};
           data{data_idx} = data{data_idx - 1};
           withclause{data_idx} = sprintf ("with %s linestyle %d",
@@ -666,31 +666,31 @@ function __gnuplot_draw_axes__ (h, plot_
              if (isnan (hidden_removal))
                hidden_removal = true;
              endif
              if (nd == 3)
                if (numel (xcol) > 3)
                  error ("__gnuplot_draw_axes__: gnuplot (as of v4.2) only supports 3-D filled triangular patches");
                else
                  if (isnan (data_3d_idx))
-                   data_idx++;
+                   data_idx += 1;
                    data_3d_idx = data_idx;
                    is_image_data(data_idx) = false;
                    parametric(data_idx) = false;
                    have_cdata(data_idx) = true;
                    have_3d_patch(data_idx) = true;
                    withclause{data_3d_idx} = sprintf ("with pm3d");
                    usingclause{data_3d_idx} =  "using 1:2:3:4";
                    data{data_3d_idx} = [];
                  endif
                  local_idx = data_3d_idx;
                  ccdat = NaN;
                endif
              else
-               data_idx++;
+               data_idx += 1;
                local_idx = data_idx;
                is_image_data(data_idx) = false;
                parametric(data_idx) = false;
                have_cdata(data_idx) = false;
                have_3d_patch(data_idx) = false;
              endif
 
              if (i > 1 || isempty (obj.displayname))
@@ -802,17 +802,17 @@ function __gnuplot_draw_axes__ (h, plot_
          endif
 
          ## patch outline
          if (!(strcmp (obj.edgecolor, "none")
                 && (strcmp (obj.marker, "none")
                     || (strcmp (obj.markeredgecolor, "none")
                         && strcmp (obj.markerfacecolor, "none")))))
 
-           data_idx++;
+           data_idx += 1;
            is_image_data(data_idx) = false;
            parametric(data_idx) = false;
            have_cdata(data_idx) = false;
            have_3d_patch(data_idx) = false;
            titlespec{data_idx} = "title \"\"";
            usingclause{data_idx} = sprintf ("record=%d", numel (obj.xdata));
 
            if (isfield (obj, "markersize"))
@@ -959,17 +959,17 @@ function __gnuplot_draw_axes__ (h, plot_
                                         style, lw, pt2, lt, ps,
                                         colorspec);
              else
                facesame = false;
                if (! isempty (style))
                  tmpwith{sidx} = sprintf ("with %s %s %s %s",
                                           style, lw, lt,
                                           colorspec);
-                 sidx++;
+                 sidx += 1;
                endif
                if (isnumeric (obj.markerfacecolor) && ! mono)
                  colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
                                       round (255*obj.markerfacecolor));
                endif
                style = "points";
                if (isfield (obj, "markersize"))
                  if (length (mdat) == nc)
@@ -1014,17 +1014,17 @@ function __gnuplot_draw_axes__ (h, plot_
                endif
              else
                if (! isempty (style))
                  if (length (tmpwith) < sidx || isempty (tmpwith{sidx}))
                    tmpwith{sidx} = sprintf ("with %s %s %s %s",
                                             style, lw, lt,
                                             colorspec);
                  endif
-                 sidx++;
+                 sidx += 1;
                endif
 
                if (! isempty (pt))
                  if (! mono)
                    if (strcmp (obj.markeredgecolor, "auto"))
                      colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
                                           round (255*color));
                    elseif (isnumeric (obj.markeredgecolor) && ! mono)
@@ -1090,45 +1090,45 @@ function __gnuplot_draw_axes__ (h, plot_
                else
                  data{data_idx} = [xcol, ycol]';
                endif
                usingclause{data_idx} = sprintf ("record=%d using ($1):($2)", columns (data{data_idx}));
              endif
            endif
 
            if (length (tmpwith) > 1)
-             data_idx++;
+             data_idx += 1;
              is_image_data(data_idx) = is_image_data(data_idx - 1);
              parametric(data_idx) = parametric(data_idx - 1);
              have_cdata(data_idx) = have_cdata(data_idx - 1);
              have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
              titlespec{data_idx} = "title \"\"";
              usingclause{data_idx} = usingclause{data_idx - 1};
              data{data_idx} = data{data_idx - 1};
              withclause{data_idx} = tmpwith{2};
            endif
            if (length (tmpwith) > 2)
-             data_idx++;
+             data_idx += 1;
              is_image_data(data_idx) = is_image_data(data_idx - 1);
              parametric(data_idx) = parametric(data_idx - 1);
              have_cdata(data_idx) = have_cdata(data_idx - 1);
              have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
              titlespec{data_idx} = "title \"\"";
              usingclause{data_idx} = usingclause{data_idx - 1};
              data{data_idx} = data{data_idx - 1};
              withclause{data_idx} = tmpwith{3};
            endif
          endif
        endfor
 
       case "surface"
         view_map = true;
         if (! (strcmp (obj.edgecolor, "none")
                && strcmp (obj.facecolor, "none")))
-          data_idx++;
+          data_idx += 1;
           is_image_data(data_idx) = false;
           parametric(data_idx) = false;
           have_cdata(data_idx) = true;
           have_3d_patch(data_idx) = false;
           style = do_linestyle_command (obj, obj.edgecolor,
                                         data_idx, mono,
                                         plot_stream);
 
@@ -1178,17 +1178,17 @@ function __gnuplot_draw_axes__ (h, plot_
             len = 4 * xlen;
             zz = zeros (ylen, len);
             k = 1;
             for kk = 1:4:len
               zz(:,kk)   = xdat(:,k);
               zz(:,kk+1) = ydat(:,k);
               zz(:,kk+2) = zdat(:,k);
               zz(:,kk+3) = cdat(:,k);
-              k++;
+              k += 1;
             endfor
             data{data_idx} = zz.';
           endif
 
           if (doing_interp_color)
             interp_str = "interpolate 0, 0";
           else
             ## No interpolation of facecolors.
@@ -1265,34 +1265,34 @@ function __gnuplot_draw_axes__ (h, plot_
           if (length (style) > 1)
             len = 3 * xlen;
             zz = zeros (ylen, len);
             k = 1;
             for kk = 1:3:len
               zz(:,kk)   = xdat(:,k);
               zz(:,kk+1) = ydat(:,k);
               zz(:,kk+2) = zdat(:,k);
-              k++;
+              k += 1;
             endfor
             zz = zz.';
 
-            data_idx++;
+            data_idx += 1;
             is_image_data(data_idx) = is_image_data(data_idx - 1);
             parametric(data_idx) = parametric(data_idx - 1);
             have_cdata(data_idx) = false;
             have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
             titlespec{data_idx} = "title \"\"";
             usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3)", ylen, xlen);
             data{data_idx} = zz;
             withclause{data_idx} = sprintf ("with %s linestyle %d",
                                             style{2}, data_idx);
 
           endif
           if (length (style) > 2)
-            data_idx++;
+            data_idx += 1;
             is_image_data(data_idx) = is_image_data(data_idx - 1);
             parametric(data_idx) = parametric(data_idx - 1);
             have_cdata(data_idx) = false;
             have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
             titlespec{data_idx} = "title \"\"";
             usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3)", ylen, xlen);
             data{data_idx} = zz;
             withclause{data_idx} = sprintf ("with %s linestyle %d",
@@ -1302,21 +1302,21 @@ function __gnuplot_draw_axes__ (h, plot_
             if (isempty (zz))
               len = 3 * xlen;
               zz = zeros (ylen, len);
               k = 1;
               for kk = 1:3:len
                 zz(:,kk)   = xdat(:,k);
                 zz(:,kk+1) = ydat(:,k);
                 zz(:,kk+2) = zdat(:,k);
-                k++;
+                k += 1;
               endfor
               zz = zz.';
             endif
-            data_idx++;
+            data_idx += 1;
             is_image_data(data_idx) = is_image_data(data_idx - 1);
             parametric(data_idx) = parametric(data_idx - 1);
             have_cdata(data_idx) = false;
             have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
             titlespec{data_idx} = "title \"\"";
             usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3)", ylen, xlen);
             data{data_idx} = zz;
             withclause{data_idx} = sprintf ("with points linestyle %d",
@@ -1874,18 +1874,18 @@ function style = do_linestyle_command (o
         endif
       else
         facesame = false;
         if (! found_style)
           fputs (plot_stream, " default");
         endif
         fputs (plot_stream, ";\n");
         if (! isempty (style{sidx}))
-          sidx++;
-          idx++;
+          sidx += 1;
+          idx += 1;
         else
           fputs (plot_stream, ";\n");
         endif
         fprintf (plot_stream, "set style line %d default;\n", idx);
         fprintf (plot_stream, "set style line %d", idx);
         if (isnumeric (obj.markerfacecolor) && ! mono)
           fprintf (plot_stream, " linecolor rgb \"#%02x%02x%02x\"",
                    round (255*obj.markerfacecolor));
@@ -1917,18 +1917,18 @@ function style = do_linestyle_command (o
           endif
         endif
       else
         if (! found_style)
           fputs (plot_stream, " default");
         endif
         fputs (plot_stream, ";\n");
         if (! isempty (style{sidx}))
-          sidx++;
-          idx++;
+          sidx += 1;
+          idx += 1;
         else
           fputs (plot_stream, ";\n");
         endif
         fprintf (plot_stream, "set style line %d default;\n", idx);
         fprintf (plot_stream, "set style line %d", idx);
         if (! mono)
           if (strcmp (obj.markeredgecolor, "auto"))
             fprintf (plot_stream, " linecolor rgb \"#%02x%02x%02x\"",
@@ -2434,36 +2434,36 @@ function str = __tex2enhanced__ (str, fn
         si = 1;
         l1 = strfind (str(s(i) + p + 1:end),'}');
         li = 1;
         while (li <= length (l1) && si <= length (s1))
           if (l1(li) < s1(si))
             if (li == si)
               break;
             endif
-            li++;
+            li += 1;
           else
-            si++;
+            si += 1;
           endif
         endwhile
         l1 = l1(min (length (l1), si));
         if (s(i) + l1 + 1 == s(i+1))
           if (str(s(i + 1) + p + 1) == "{")
             s2 = strfind (str(s(i + 1) + p + 2:end),'{');
             si = 1;
             l2 = strfind (str(s(i + 1) + p + 1:end),'}');
             li = 1;
             while (li <= length (l2) && si <= length (s2))
               if (l2(li) < s2(si))
                 if (li == si)
                   break;
                 endif
-                li++;
+                li += 1;
               else
-                si++;
+                si += 1;
               endif
             endwhile
             l2 = l2(min (length (l2), si));
             if (length_string (str(s(i)+p+2:s(i)+p+l1-1)) <=
                 length_string (str(s(i+1)+p+2:s(i+1)+p+l2-1)))
               ## Shortest already first!
               str = [str(1:s(i)+p-1) "@" str(s(i)+p:end)];
             else
@@ -2472,32 +2472,32 @@ function str = __tex2enhanced__ (str, fn
                      str(s(i)+p:s(i)+p+l1), str(s(i+1)+p+l2+1:end)];
             endif
           else
             ## Have to swap sub/super-script to get shortest first.
             str = [str(1:s(i)+p-1), "@", str(s(i+1)+p:s(i+1)+p+1), ...
                    str(s(i)+p:s(i)+p+l1), str(s(i+1)+p+2:end)];
           endif
           i += 2;
-          p++;
+          p += 1;
         else
-          i++;
+          i += 1;
         endif
       else
         if (s(i+1) == s(i) + 2)
           ## Shortest already first!
           str = [str(1:s(i)+p-1) "@" str(s(i)+p:end)];
-          p++;
+          p += 1;
           i += 2;
         else
-          i++;
+          i += 1;
         endif
       endif
     else
-      i++;
+      i += 1;
     endif
   endwhile
 
 endfunction
 
 function l = length_string (s)
   l = length (s) - length (strfind (s,'{')) - length (strfind (s,'}'));
   m = regexp (s, '/([\w-]+|[\w-]+=\d+)', 'matches');
diff --git a/scripts/plot/util/private/__gnuplot_ginput__.m b/scripts/plot/util/private/__gnuplot_ginput__.m
--- a/scripts/plot/util/private/__gnuplot_ginput__.m
+++ b/scripts/plot/util/private/__gnuplot_ginput__.m
@@ -69,17 +69,17 @@ function [x, y, button] = __gnuplot_ginp
       error ("ginput: Can not open fifo (%s)", msg);
     endif
   endif
 
   unwind_protect
 
     k = 0;
     while (true)
-      k++;
+      k += 1;
 
       ## Notes: MOUSE_* can be undefined if user closes gnuplot by "q"
       ## or Alt-F4. Further, this abrupt close also requires the leading
       ## "\n" on the next line.
       if (use_mkfifo)
         fprintf (ostream, "set print \"%s\";\n", gpin_name);
         fflush (ostream);
         [gpin, err] = fopen (gpin_name, "r");
diff --git a/scripts/plot/util/rotate3d.m b/scripts/plot/util/rotate3d.m
--- a/scripts/plot/util/rotate3d.m
+++ b/scripts/plot/util/rotate3d.m
@@ -47,17 +47,17 @@ function rotate3d (varargin)
   if (nargin == 1 && nargout > 0 && isfigure (varargin{1}))
     error ("rotate3d: syntax 'handle = rotate3d (hfig)' not implemented");
   endif
 
   if (nargs == 2)
     hfig = varargin{1};
     if (isfigure (hfig))
       varargin(1) = [];
-      nargs--;
+      nargs -= 1;
     else
       error ("rotate3d: invalid figure handle HFIG");
     endif
   endif
 
   if (isnan (hfig))
     hfig = gcf ();
   endif
diff --git a/scripts/plot/util/struct2hdl.m b/scripts/plot/util/struct2hdl.m
--- a/scripts/plot/util/struct2hdl.m
+++ b/scripts/plot/util/struct2hdl.m
@@ -157,21 +157,21 @@ function [h, pout] = struct2hdl (s, p=[]
   endif
 
   ## children
   p = [p [s.handle; h]];  # [original; new]
   kids = s.children;
   nkids = length (kids);
   ii = 0;
   while (nkids)
-    ii++;
+    ii += 1;
     if (! any (ii == s.special))
       [h2, p] = struct2hdl (s.children(ii), [p [s.handle; h]], hilev);
     endif
-    nkids--;
+    nkids -= 1;
   endwhile
 
   ## paste properties
   setprops (s, h, p, hilev);
 
   pout = p;
 
 endfunction
@@ -582,17 +582,17 @@ function setprops (s, h, p, hilev)
       while (nf)
         field = fields{nf};
         idx = find (hdls == vals{nf});
         spec = specs(idx);
         if (isprop (h, field))
            h2 = get (h , field);
            set (h2, spec.properties);
         endif
-        nf--;
+        nf -= 1;
       endwhile
 
       ## If hggroup children  were created by high level functions,
       ## copy only usefull properties.
       if (hilev)
         if (strcmp (s.type, "hggroup"))
           nold = numel (s.children);
           nnew = numel (get (h).children);
@@ -602,17 +602,17 @@ function setprops (s, h, p, hilev)
             ii = 1;
             while (ii <= nnew)
               try
                 set (hnew (ii), "displayname", ...
                      s.children(ii).properties.displayname);
               catch
                 sprintf ("struct2hdl: couldn't set hggroup children #%d props.", ii);
               end_try_catch
-              ii++;
+              ii += 1;
             endwhile
 
           else
             error ("struct2hdl: non-conformant number of children in hgggroup");
           endif
         endif
       endif
     endif
diff --git a/scripts/plot/util/zoom.m b/scripts/plot/util/zoom.m
--- a/scripts/plot/util/zoom.m
+++ b/scripts/plot/util/zoom.m
@@ -68,17 +68,17 @@ function zoom (varargin)
     error ("zoom: syntax 'handle = zoom (hfig)' not implemented");
   endif
 
   hfig = NaN;
   if (nargs == 2)
     hfig = varargin{1};
     if (isfigure (hfig))
       varargin(1) = [];
-      nargs--;
+      nargs -= 1;
     else
       error ("zoom: invalid figure handle HFIG");
     endif
   endif
 
   if (isnan (hfig))
     hfig = gcf ();
   endif
diff --git a/scripts/signal/freqz.m b/scripts/signal/freqz.m
--- a/scripts/signal/freqz.m
+++ b/scripts/signal/freqz.m
@@ -160,17 +160,17 @@ function [h_r, f_r] = freqz (b, a, n, re
       if (plot_output)
         f = Fs * (0:n).' / N;    # do 1 more for the plot
       else
         f = Fs * (0:n-1).' / N;
       endif
     else
       N = 2*n;
       if (plot_output)
-        n++;
+        n += 1;
       endif
       f = Fs * (0:n-1).' / N;
     endif
 
     pad_sz = N*ceil (k/N);
     b = postpad (b, pad_sz);
     a = postpad (a, pad_sz);
 
diff --git a/scripts/signal/periodogram.m b/scripts/signal/periodogram.m
--- a/scripts/signal/periodogram.m
+++ b/scripts/signal/periodogram.m
@@ -93,17 +93,17 @@ function [pxx, f] = periodogram (x, vara
       switch (j)
         case 2
           window = varargin{k};
         case 3
           nfft   = varargin{k};
         case 4
           fs     = varargin{k};
       endswitch
-      j++;
+      j += 1;
     endif
   endfor
 
   if (! isvector (x))
     error ("periodogram: X must be a real or complex vector");
   endif
   x = x(:);  # Use column vectors from now on
 
diff --git a/scripts/sparse/gmres.m b/scripts/sparse/gmres.m
--- a/scripts/sparse/gmres.m
+++ b/scripts/sparse/gmres.m
@@ -174,18 +174,18 @@ function [x, flag, relres, it, resvec] =
     x = x_old + V(:, 1:restart_it) * Y(1:restart_it);
 
     resvec(iter+1) = presn;
     if (norm (x - x_old, inf) <= eps)
       flag = 3;  # Stagnation: no change between iterations
       break;
     endif
 
-    restart_it++ ;
-    iter++;
+    restart_it += 1;
+    iter += 1;
   endwhile
 
   if (nargout > 1)
     ## Calculate extra outputs as requested
     relres = presn / prec_b_norm;
     if (relres <= rtol)
       flag = 0;  # Converged to solution within tolerance
     endif
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -314,17 +314,17 @@ function [x, flag, relres, iter, resvec,
     r -= alpha * w;
     if (nargout > 5 && iter > 2)
       T(iter-1:iter, iter-1:iter) = T(iter-1:iter, iter-1:iter) + ...
           [1 sqrt(beta); sqrt(beta) beta]./oldalpha;
       ## EVS = eig (T(2:iter-1,2:iter-1));
       ## fprintf (stderr,"PCG condest: %g (iteration: %d)\n", max (EVS)/min (EVS),iter);
     endif
     resvec(iter,1) = norm (r);
-    iter++;
+    iter += 1;
   endwhile
 
   if (nargout > 5)
     if (matrix_positive_definite)
       if (iter > 3)
         T = T(2:iter-2,2:iter-2);
         l = eig (T);
         eigest = [min(l), max(l)];
diff --git a/scripts/sparse/pcr.m b/scripts/sparse/pcr.m
--- a/scripts/sparse/pcr.m
+++ b/scripts/sparse/pcr.m
@@ -270,17 +270,17 @@ function [x, flag, relres, iter, resvec]
     q = t - alpha0*q - alpha1*q_old;
 
     s_old = s;
     p_old = p_temp;
     q_old = q_temp;
     b_bot_old = b_bot;
 
     resvec(iter) = abs (norm (r));
-    iter++;
+    iter += 1;
   endwhile
 
   flag = 0;
   relres = resvec(iter-1) ./ resvec(1);
   iter -= 2;
   if (iter >= maxit-2)
     flag = 1;
     if (nargout < 2)
diff --git a/scripts/sparse/private/__sprand__.m b/scripts/sparse/private/__sprand__.m
--- a/scripts/sparse/private/__sprand__.m
+++ b/scripts/sparse/private/__sprand__.m
@@ -65,17 +65,17 @@ function S = __sprand__ (varargin)
         ## Generate 1% more random values than necessary in order to reduce the
         ## probability that there are less than k distinct values; maybe a
         ## better strategy could be used but I don't think it's worth the price.
 
         ## actual number of entries in S
         k = min (length (idx), k);
         j = floor ((idx(1:k) - 1) / m);
         i = idx(1:k) - j * m;
-        j++;
+        j += 1;
       else
         idx = randperm (mn, k);
         [i, j] = ind2sub ([m, n], idx);
       endif
 
       S = sparse (i, j, randfun (k, 1), m, n);
 
     elseif (nargin == 6)
diff --git a/scripts/sparse/sprandsym.m b/scripts/sparse/sprandsym.m
--- a/scripts/sparse/sprandsym.m
+++ b/scripts/sparse/sprandsym.m
@@ -129,17 +129,17 @@ function r = pick_rand_diag (n, k)
   d = [mod(k,2):2:min(n,k)-2];
   m = (k - d)/2;
   q = (n - d).*(n - d - 1).*m ./ (d + 2)./(d + 1)./(a - m + 1);
 
   ## Slight modification from discussion above: pivot around the max in
   ## order to avoid overflow (underflow is fine, just means effectively
   ## zero probabilities).
   [~, midx] = max (cumsum (log (q))) ;
-  midx++;
+  midx += 1;
   lc = fliplr (cumprod (1./q(midx-1:-1:1)));
   rc = cumprod (q(midx:end));
 
   ## Now c = t(i)/t(midx), so c > 1 == [].
   c = [lc, 1, rc];
   s = sum (c);
   p = c/s;
 
diff --git a/scripts/sparse/treelayout.m b/scripts/sparse/treelayout.m
--- a/scripts/sparse/treelayout.m
+++ b/scripts/sparse/treelayout.m
@@ -139,24 +139,24 @@ function [x_coordinate, y_coordinate, he
       endif
 
       ## Add to idx the vector of parent descendants.
       stk = [stk; [idx', ones(fliplr(size(idx))) * par_number]];
 
       ## We are in top level separator when we have one child and the
       ## flag is 1
       if (columns (idx) == 1 && top_level == 1)
-        s++;
+        s += 1;
       else
         ## We aren't in top level separator now.
         top_level = 0;
       endif
       ## If there is not any descendant of "parent node":
       if (stk(end,2) != par_number)
-       left_most++;
+       left_most += 1;
        x_coordinate_r(par_number) = left_most;
        max_ht = min (max_ht, level);
        if (length (stk) > 1 && find ((shift (stk,1) - stk) == 0) > 1
            && stk(end,2) != stk(end-1,2))
           ## Return to the nearest branching the position to return
           ## position is the position on the stack, where should be
           ## started further search (there are two nodes which has the
           ## same parent node).
@@ -184,17 +184,17 @@ function [x_coordinate, y_coordinate, he
         if (par_number != -1)
           y_coordinate(par_number) = level;
           x_coordinate_l(par_number) = left_most + 1;
         endif
       else
 
         ## There were descendants of "parent nod" choose the last of
         ## them and go on through it.
-        level--;
+        level -= 1;
         par_number = stk(end,1);
         y_coordinate(par_number) = level;
         x_coordinate_l(par_number) = left_most + 1;
       endif
     endwhile
 
     ## Calculate the x coordinates (the known values are the position
     ## of most left and most right descendants).
diff --git a/scripts/sparse/treeplot.m b/scripts/sparse/treeplot.m
--- a/scripts/sparse/treeplot.m
+++ b/scripts/sparse/treeplot.m
@@ -113,17 +113,17 @@ function treeplot (tree, node_style = "k
     stk = [stk; [idx', ones(fliplr(size(idx)))*par_number]];
     ## Add to stack the records relevant to parent descandant s.
     if (par_number != 0)
       skelet = [skelet; ([ones(size(idx))*par_number; idx])(:)];
     endif
 
     ## If there is not any descendant of "parent node":
     if (stk(end,2) != par_number)
-      left_most++;
+      left_most += 1;
       x_coordinate_r(par_number) = left_most;
       max_ht = min (max_ht, level);
       if (length (stk) > 1 && find ((shift (stk,1) - stk) == 0) > 1
           && stk(end,2) != stk(end-1,2))
         ## Return to the nearest branching the position to return
         ## position is the position on the stack, where should be
         ## started further search (there are two nodes which has the
         ## same parent node).
@@ -145,17 +145,17 @@ function treeplot (tree, node_style = "k
       if (par_number != -1)
         skelet = [skelet; stk(end,2); par_number];
         y_coordinate(par_number) = level;
         x_coordinate_l(par_number) = left_most + 1;
       endif
     else
       ## There were descendants of "parent nod" choose the last of
       ## them and go on through it.
-      level--;
+      level -= 1;
       par_number = stk(end,1);
       y_coordinate(par_number) = level;
       x_coordinate_l(par_number) = left_most + 1;
     endif
   endwhile
 
   ## Calculate the x coordinates (the known values are the position
   ## of most left and most right descendants).
diff --git a/scripts/special-matrix/hadamard.m b/scripts/special-matrix/hadamard.m
--- a/scripts/special-matrix/hadamard.m
+++ b/scripts/special-matrix/hadamard.m
@@ -63,17 +63,17 @@ function h = hadamard (n)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   ## Find k if n = 2^k*p.
   k = 0;
   while (n > 1 && fix (n/2) == n/2)
-    k++;
+    k += 1;
     n /= 2;
   endwhile
 
   ## Find base hadamard.
   ## Except for n=2^k, need a multiple of 4.
   if (n != 1)
     k -= 2;
   endif
diff --git a/scripts/special-matrix/hilb.m b/scripts/special-matrix/hilb.m
--- a/scripts/special-matrix/hilb.m
+++ b/scripts/special-matrix/hilb.m
@@ -60,17 +60,17 @@ function retval = hilb (n)
   elseif (! isscalar (n))
     error ("hilb: N must be a scalar integer");
   endif
 
   retval = zeros (n);
   tmp = 1:n;
   for i = 1:n
     retval(i, :) = 1.0 ./ tmp;
-    tmp++;
+    tmp += 1;
   endfor
 
 endfunction
 
 
 %!assert (hilb (2), [1, 1/2; 1/2, 1/3])
 %!assert (hilb (3), [1, 1/2, 1/3; 1/2, 1/3, 1/4; 1/3, 1/4, 1/5])
 
diff --git a/scripts/statistics/base/iqr.m b/scripts/statistics/base/iqr.m
--- a/scripts/statistics/base/iqr.m
+++ b/scripts/statistics/base/iqr.m
@@ -68,17 +68,17 @@ function y = iqr (x, dim)
     y = zeros (sz);
   endif
   stride = prod (sz(1:dim-1));
   for i = 1 : nel / n;
     offset = i;
     offset2 = 0;
     while (offset > stride)
       offset -= stride;
-      offset2++;
+      offset2 += 1;
     endwhile
     offset += offset2 * stride * n;
     rng = [0 : n-1] * stride + offset;
 
     y(i) = diff (empirical_inv ([1/4, 3/4], x(rng)));
   endfor
 
 endfunction
diff --git a/scripts/testfun/assert.m b/scripts/testfun/assert.m
--- a/scripts/testfun/assert.m
+++ b/scripts/testfun/assert.m
@@ -72,17 +72,17 @@ function assert (cond, varargin)
     print_usage ();
   endif
 
   persistent call_depth = -1;
   persistent errmsg;
 
   unwind_protect
 
-    call_depth++;
+    call_depth += 1;
 
     if (call_depth == 0)
       errmsg = "";
     endif
 
     if (nargin == 1 || (nargin > 1 && islogical (cond) && ischar (varargin{1})))
       if ((! isnumeric (cond) && ! islogical (cond))
           || isempty (cond) || ! all (cond(:)))
@@ -394,17 +394,17 @@ function assert (cond, varargin)
           errmsg = [errmsg "\n"];
         endif
         errmsg = [errmsg, pprint(argin, err)];
       endif
 
     endif
 
   unwind_protect_cleanup
-    call_depth--;
+    call_depth -= 1;
   end_unwind_protect
 
   if (call_depth == -1)
     ## Last time through.  If there were any errors on any pass, raise a flag.
     if (! isempty (errmsg))
       error (errmsg);
     endif
   endif
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -532,17 +532,17 @@ function [__n, __nmax, __nxfail, __nskip
         __feat_line = strtok (__code(1:__e), '#%');
         __feat = regexp (__feat_line, '\w+', 'match');
         __feat = strrep (__feat, "HAVE_", "");
         __have_feat = __have_feature__ (__feat);
         if (__have_feat)
           __istest = true;
           __code = __code(__e + 1 : end);
         else
-          __xskip++;
+          __xskip += 1;
           __istest = false;
           __code = ""; # Skip the code.
           __msg = [__signal_skip "skipped test\n"];
         endif
 
 ### TEST
 
       elseif (strcmp (__type, "test"))
@@ -583,17 +583,17 @@ function [__n, __nmax, __nxfail, __nskip
             eval (sprintf ("%s__test__(%s);", __shared_r, __shared));
           else
             error (["Functions embedded in %!test blocks are not allowed.\n", ...
                     "Use the %!function/%!endfunction syntax instead to define shared functions for testing.\n"]);
           endif
         catch
           if (strcmp (__type, "xtest"))
             __msg = [__signal_fail "known failure\n" lasterr()];
-            __xfail++;
+            __xfail += 1;
             __success = false;
           else
             __msg = [__signal_fail "test failed\n" lasterr()];
             __success = false;
           endif
           if (isempty (lasterr ()))
             error ("test: empty error text, probably Ctrl-C --- aborting");
           endif
@@ -697,17 +697,17 @@ function pos = function_name (def)
   right = find (def(1:right-1) != " ", 1, "last");
 
   ## Find the beginning of the name.
   left = max ([find(def(1:right)==" ", 1, "last"), ...
                find(def(1:right)=="=", 1, "last")]);
   if (isempty (left))
     return;
   endif
-  left++;
+  left += 1;
 
   ## Return the end points of the name.
   pos = [left, right];
 endfunction
 
 ## Strip <pattern> from '<pattern> code'.
 ## Also handles 'id=ID code'
 function [pattern, id, rest] = getpattern (str)
