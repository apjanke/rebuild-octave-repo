# HG changeset patch
# User jwe
# Date 1112224738 0
#      Wed Mar 30 23:18:58 2005 +0000
# Node ID deed800e7beffe98e0865c4d9adb7ca99f38be74
# Parent  462fd886f33f4bbe5d4fff39ee4b242c0c0263c0
[project @ 2005-03-30 23:18:58 by jwe]

diff --git a/liboctave/CColVector.cc b/liboctave/CColVector.cc
--- a/liboctave/CColVector.cc
+++ b/liboctave/CColVector.cc
@@ -497,43 +497,43 @@ ComplexColumnVector::apply (c_c_Mapper f
 Complex
 ComplexColumnVector::min (void) const
 {
   int len = length ();
   if (len == 0)
     return 0.0;
 
   Complex res = elem (0);
-  double absres = abs (res);
+  double absres = std::abs (res);
 
   for (int i = 1; i < len; i++)
-    if (abs (elem (i)) < absres)
+    if (std::abs (elem (i)) < absres)
       {
 	res = elem (i);
-	absres = abs (res);
+	absres = std::abs (res);
       }
 
   return res;
 }
 
 Complex
 ComplexColumnVector::max (void) const
 {
   int len = length ();
   if (len == 0)
     return 0.0;
 
   Complex res = elem (0);
-  double absres = abs (res);
+  double absres = std::abs (res);
 
   for (int i = 1; i < len; i++)
-    if (abs (elem (i)) > absres)
+    if (std::abs (elem (i)) > absres)
       {
 	res = elem (i);
-	absres = abs (res);
+	absres = std::abs (res);
       }
 
   return res;
 }
 
 // i/o
 
 std::ostream&
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -1,8 +1,10 @@
+#define STD_OCTAVE std
+
 // Matrix manipulations.
 /*
 
 Copyright (C) 1996, 1997 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
@@ -991,17 +993,17 @@ ComplexMatrix::inverse (int& info, doubl
 
       if (f77_exception_encountered) 
 	{
 	  (*current_liboctave_error_handler)
 	    ("unrecoverable error in zgetri");
 	  return retval;
 	}
 
-      lwork = static_cast<int> (real(z(0)));
+      lwork = static_cast<int> (STD_OCTAVE::real(z(0)));
       lwork = (lwork <  2 *nc ? 2*nc : lwork);
       z.resize (lwork);
       Complex *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm;
@@ -1500,22 +1502,22 @@ ComplexMatrix::determinant (int& info, d
 	      else 
 		{
 		  Complex d[2] = { 1., 0.};
 		  for (int i=0; i<nc; i++) 
 		    {
 		      if (ipvt(i) != (i+1)) d[0] = -d[0];
 		      d[0] = d[0] * atmp(i,i);
 		      if (d[0] == 0.) break;
-		      while (::abs(d[0]) < 1.) 
+		      while (STD_OCTAVE::abs(d[0]) < 1.) 
 			{
 			  d[0] = 10. * d[0];
 			  d[1] = d[1] - 1.0;
 			}
-		      while (::abs(d[0]) >= 10.) 
+		      while (STD_OCTAVE::abs(d[0]) >= 10.) 
 			{
 			  d[0] = 0.1 * d[0];
 			  d[1] = d[1] + 1.0;
 			}
 		    }
 		  retval = ComplexDET (d);
 		}
 	    }
@@ -1912,17 +1914,17 @@ ComplexMatrix::lssolve (const ComplexMat
 				 nrr, ps, rcond, rank,
 				 work.fortran_vec (), lwork, prwork,
 				 info));
 
       if (f77_exception_encountered)
 	(*current_liboctave_error_handler) ("unrecoverable error in zgelss");
       else
 	{
-	  lwork = static_cast<int> (real (work(0)));
+	  lwork = static_cast<int> (STD_OCTAVE::real (work(0)));
 	  work.resize (lwork);
 
 	  F77_XFCN (zgelss, ZGELSS, (m, n, nrhs, tmp_data, m, presult,
 				     nrr, ps, rcond, rank,
 				     work.fortran_vec (), lwork,
 				     prwork, info));
 
 	  if (f77_exception_encountered)
@@ -2025,17 +2027,17 @@ ComplexMatrix::lssolve (const ComplexCol
 				 nrr, ps, rcond, rank,
 				 work.fortran_vec (), lwork, prwork,
 				 info));
 
       if (f77_exception_encountered)
 	(*current_liboctave_error_handler) ("unrecoverable error in zgelss");
       else
 	{
-	  lwork = static_cast<int> (real (work(0)));
+	  lwork = static_cast<int> (STD_OCTAVE::real (work(0)));
 	  work.resize (lwork);
 
 	  F77_XFCN (zgelss, ZGELSS, (m, n, nrhs, tmp_data, m, presult,
 				     nrr, ps, rcond, rank,
 				     work.fortran_vec (), lwork,
 				     prwork, info));
 
 	  if (f77_exception_encountered)
@@ -2521,17 +2523,17 @@ ComplexMatrix::all_elements_are_real (vo
 {
   int nr = rows ();
   int nc = cols ();
 
   for (int j = 0; j < nc; j++)
     {
       for (int i = 0; i < nr; i++)
 	{
-	  double ip = imag (elem (i, j));
+	  double ip = STD_OCTAVE::imag (elem (i, j));
 
 	  if (ip != 0.0 || lo_ieee_signbit (ip))
 	    return false;
 	}
     }
 
   return true;
 }
@@ -2545,18 +2547,18 @@ ComplexMatrix::all_integers (double& max
 {
   int nr = rows ();
   int nc = cols ();
 
   if (nr > 0 && nc > 0)
     {
       Complex val = elem (0, 0);
 
-      double r_val = real (val);
-      double i_val = imag (val);
+      double r_val = STD_OCTAVE::real (val);
+      double i_val = STD_OCTAVE::imag (val);
 
       max_val = r_val;
       min_val = r_val;
 
       if (i_val > max_val)
 	max_val = i_val;
 
       if (i_val < max_val)
@@ -2565,18 +2567,18 @@ ComplexMatrix::all_integers (double& max
   else
     return false;
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
 	Complex val = elem (i, j);
 
-	double r_val = real (val);
-	double i_val = imag (val);
+	double r_val = STD_OCTAVE::real (val);
+	double i_val = STD_OCTAVE::imag (val);
 
 	if (r_val > max_val)
 	  max_val = r_val;
 
 	if (i_val > max_val)
 	  max_val = i_val;
 
 	if (r_val < min_val)
@@ -2598,18 +2600,18 @@ ComplexMatrix::too_large_for_float (void
   int nr = rows ();
   int nc = cols ();
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
 	Complex val = elem (i, j);
 
-	double r_val = real (val);
-	double i_val = imag (val);
+	double r_val = STD_OCTAVE::real (val);
+	double i_val = STD_OCTAVE::imag (val);
 
 	if (r_val > FLT_MAX
 	    || i_val > FLT_MAX
 	    || r_val < FLT_MIN
 	    || i_val < FLT_MIN)
 	  return true;
       }
 
@@ -2676,17 +2678,17 @@ Matrix ComplexMatrix::abs (void) const
 {
   int nr = rows ();
   int nc = cols ();
 
   Matrix retval (nr, nc);
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
-      retval (i, j) = ::abs (elem (i, j));
+      retval (i, j) = STD_OCTAVE::abs (elem (i, j));
 
   return retval;
 }
 
 ComplexColumnVector
 ComplexMatrix::diag (void) const
 {
   return diag (0);
@@ -2737,17 +2739,17 @@ bool
 ComplexMatrix::row_is_real_only (int i) const
 {
   bool retval = true;
 
   int nc = columns ();
 
   for (int j = 0; j < nc; j++)
     {
-      if (imag (elem (i, j)) != 0.0)
+      if (STD_OCTAVE::imag (elem (i, j)) != 0.0)
 	{
 	  retval = false;
 	  break;
 	}
     }
 
   return retval;	      
 }
@@ -2756,17 +2758,17 @@ bool
 ComplexMatrix::column_is_real_only (int j) const
 {
   bool retval = true;
 
   int nr = rows ();
 
   for (int i = 0; i < nr; i++)
     {
-      if (imag (elem (i, j)) != 0.0)
+      if (STD_OCTAVE::imag (elem (i, j)) != 0.0)
 	{
 	  retval = false;
 	  break;
 	}
     }
 
   return retval;	      
 }
@@ -2802,29 +2804,29 @@ ComplexMatrix::row_min (Array<int>& idx_
 	  double abs_min = octave_NaN;
 
 	  for (idx_j = 0; idx_j < nc; idx_j++)
 	    {
 	      tmp_min = elem (i, idx_j);
 
 	      if (! octave_is_NaN_or_NA (tmp_min))
 		{
-		  abs_min = real_only ? real (tmp_min) : ::abs (tmp_min);
+		  abs_min = real_only ? STD_OCTAVE::real (tmp_min) : STD_OCTAVE::abs (tmp_min);
 		  break;
 		}
 	    }
 
 	  for (int j = idx_j+1; j < nc; j++)
 	    {
 	      Complex tmp = elem (i, j);
 
 	      if (octave_is_NaN_or_NA (tmp))
 		continue;
 
-	      double abs_tmp = real_only ? real (tmp) : ::abs (tmp);
+	      double abs_tmp = real_only ? STD_OCTAVE::real (tmp) : STD_OCTAVE::abs (tmp);
 
 	      if (abs_tmp < abs_min)
 		{
 		  idx_j = j;
 		  tmp_min = tmp;
 		  abs_min = abs_tmp;
 		}
 	    }
@@ -2876,29 +2878,29 @@ ComplexMatrix::row_max (Array<int>& idx_
 	  double abs_max = octave_NaN;
 
 	  for (idx_j = 0; idx_j < nc; idx_j++)
 	    {
 	      tmp_max = elem (i, idx_j);
 
 	      if (! octave_is_NaN_or_NA (tmp_max))
 		{
-		  abs_max = real_only ? real (tmp_max) : ::abs (tmp_max);
+		  abs_max = real_only ? STD_OCTAVE::real (tmp_max) : STD_OCTAVE::abs (tmp_max);
 		  break;
 		}
 	    }
 
 	  for (int j = idx_j+1; j < nc; j++)
 	    {
 	      Complex tmp = elem (i, j);
 
 	      if (octave_is_NaN_or_NA (tmp))
 		continue;
 
-	      double abs_tmp = real_only ? real (tmp) : ::abs (tmp);
+	      double abs_tmp = real_only ? STD_OCTAVE::real (tmp) : STD_OCTAVE::abs (tmp);
 
 	      if (abs_tmp > abs_max)
 		{
 		  idx_j = j;
 		  tmp_max = tmp;
 		  abs_max = abs_tmp;
 		}
 	    }
@@ -2950,29 +2952,29 @@ ComplexMatrix::column_min (Array<int>& i
 	  double abs_min = octave_NaN;
 
 	  for (idx_i = 0; idx_i < nr; idx_i++)
 	    {
 	      tmp_min = elem (idx_i, j);
 
 	      if (! octave_is_NaN_or_NA (tmp_min))
 		{
-		  abs_min = real_only ? real (tmp_min) : ::abs (tmp_min);
+		  abs_min = real_only ? STD_OCTAVE::real (tmp_min) : STD_OCTAVE::abs (tmp_min);
 		  break;
 		}
 	    }
 
 	  for (int i = idx_i+1; i < nr; i++)
 	    {
 	      Complex tmp = elem (i, j);
 
 	      if (octave_is_NaN_or_NA (tmp))
 		continue;
 
-	      double abs_tmp = real_only ? real (tmp) : ::abs (tmp);
+	      double abs_tmp = real_only ? STD_OCTAVE::real (tmp) : STD_OCTAVE::abs (tmp);
 
 	      if (abs_tmp < abs_min)
 		{
 		  idx_i = i;
 		  tmp_min = tmp;
 		  abs_min = abs_tmp;
 		}
 	    }
@@ -3024,29 +3026,29 @@ ComplexMatrix::column_max (Array<int>& i
 	  double abs_max = octave_NaN;
 
 	  for (idx_i = 0; idx_i < nr; idx_i++)
 	    {
 	      tmp_max = elem (idx_i, j);
 
 	      if (! octave_is_NaN_or_NA (tmp_max))
 		{
-		  abs_max = real_only ? real (tmp_max) : ::abs (tmp_max);
+		  abs_max = real_only ? STD_OCTAVE::real (tmp_max) : STD_OCTAVE::abs (tmp_max);
 		  break;
 		}
 	    }
 
 	  for (int i = idx_i+1; i < nr; i++)
 	    {
 	      Complex tmp = elem (i, j);
 
 	      if (octave_is_NaN_or_NA (tmp))
 		continue;
 
-	      double abs_tmp = real_only ? real (tmp) : ::abs (tmp);
+	      double abs_tmp = real_only ? STD_OCTAVE::real (tmp) : STD_OCTAVE::abs (tmp);
 
 	      if (abs_tmp > abs_max)
 		{
 		  idx_i = i;
 		  tmp_max = tmp;
 		  abs_max = abs_tmp;
 		}
 	    }
@@ -3305,27 +3307,27 @@ min (const ComplexMatrix& a, const Compl
   ComplexMatrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     {
       int columns_are_real_only = 1;
       for (int i = 0; i < nr; i++)
 	{
 	  OCTAVE_QUIT;
-	  if (imag (a (i, j)) != 0.0 || imag (b (i, j)) != 0.0)
+	  if (STD_OCTAVE::imag (a (i, j)) != 0.0 || STD_OCTAVE::imag (b (i, j)) != 0.0)
 	    {
 	      columns_are_real_only = 0;
 	      break;
 	    }
 	}
 
       if (columns_are_real_only)
 	{
 	  for (int i = 0; i < nr; i++)
-	    result (i, j) = xmin (real (a (i, j)), real (b (i, j)));
+	    result (i, j) = xmin (STD_OCTAVE::real (a (i, j)), STD_OCTAVE::real (b (i, j)));
 	}
       else
 	{
 	  for (int i = 0; i < nr; i++)
 	    {
 	      OCTAVE_QUIT;
 	      result (i, j) = xmin (a (i, j), b (i, j));
 	    }
@@ -3393,50 +3395,50 @@ max (const ComplexMatrix& a, const Compl
   ComplexMatrix result (nr, nc);
 
   for (int j = 0; j < nc; j++)
     {
       int columns_are_real_only = 1;
       for (int i = 0; i < nr; i++)
 	{
 	  OCTAVE_QUIT;
-	  if (imag (a (i, j)) != 0.0 || imag (b (i, j)) != 0.0)
+	  if (STD_OCTAVE::imag (a (i, j)) != 0.0 || STD_OCTAVE::imag (b (i, j)) != 0.0)
 	    {
 	      columns_are_real_only = 0;
 	      break;
 	    }
 	}
 
       if (columns_are_real_only)
 	{
 	  for (int i = 0; i < nr; i++)
 	    {
 	      OCTAVE_QUIT;
-	      result (i, j) = xmax (real (a (i, j)), real (b (i, j)));
+	      result (i, j) = xmax (STD_OCTAVE::real (a (i, j)), STD_OCTAVE::real (b (i, j)));
 	    }
 	}
       else
 	{
 	  for (int i = 0; i < nr; i++)
 	    {
 	      OCTAVE_QUIT;
 	      result (i, j) = xmax (a (i, j), b (i, j));
 	    }
 	}
     }
 
   return result;
 }
 
-MS_CMP_OPS(ComplexMatrix, real, Complex, real)
+MS_CMP_OPS(ComplexMatrix, STD_OCTAVE::real, Complex, STD_OCTAVE::real)
 MS_BOOL_OPS(ComplexMatrix, Complex, 0.0)
 
-SM_CMP_OPS(Complex, real, ComplexMatrix, real)
+SM_CMP_OPS(Complex, STD_OCTAVE::real, ComplexMatrix, STD_OCTAVE::real)
 SM_BOOL_OPS(Complex, ComplexMatrix, 0.0)
 
-MM_CMP_OPS(ComplexMatrix, real, ComplexMatrix, real)
+MM_CMP_OPS(ComplexMatrix, STD_OCTAVE::real, ComplexMatrix, STD_OCTAVE::real)
 MM_BOOL_OPS(ComplexMatrix, ComplexMatrix, 0.0)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -513,17 +513,17 @@ ComplexNDArray::any_element_is_inf_or_na
 
 bool
 ComplexNDArray::all_elements_are_real (void) const
 {
   int nel = nelem ();
 
   for (int i = 0; i < nel; i++)
     {
-      double ip = imag (elem (i));
+      double ip = std::imag (elem (i));
 
       if (ip != 0.0 || lo_ieee_signbit (ip))
 	return false;
     }
 
   return true;
 }
 
@@ -535,18 +535,18 @@ bool
 ComplexNDArray::all_integers (double& max_val, double& min_val) const
 {
   int nel = nelem ();
 
   if (nel > 0)
     {
       Complex val = elem (0);
 
-      double r_val = real (val);
-      double i_val = imag (val);
+      double r_val = std::real (val);
+      double i_val = std::imag (val);
       
       max_val = r_val;
       min_val = r_val;
 
       if (i_val > max_val)
 	max_val = i_val;
 
       if (i_val < max_val)
@@ -554,18 +554,18 @@ ComplexNDArray::all_integers (double& ma
     }
   else
     return false;
 
   for (int i = 0; i < nel; i++)
     {
       Complex val = elem (i);
 
-      double r_val = real (val);
-      double i_val = imag (val);
+      double r_val = std::real (val);
+      double i_val = std::imag (val);
 
       if (r_val > max_val)
 	max_val = r_val;
 
       if (i_val > max_val)
 	max_val = i_val;
 
       if (r_val < min_val)
@@ -585,18 +585,18 @@ bool
 ComplexNDArray::too_large_for_float (void) const
 {
   int nel = nelem ();
 
   for (int i = 0; i < nel; i++)
     {
       Complex val = elem (i);
 
-      double r_val = real (val);
-      double i_val = imag (val);
+      double r_val = std::real (val);
+      double i_val = std::imag (val);
 
       if (r_val > FLT_MAX
 	  || i_val > FLT_MAX
 	  || r_val < FLT_MIN
 	  || i_val < FLT_MIN)
 	return true;
     }
 
@@ -610,18 +610,18 @@ ComplexNDArray::all (int dim) const
     (MX_ND_ALL_EVAL (elem (iter_idx) == Complex (0, 0)), true);
 }
 
 boolNDArray
 ComplexNDArray::any (int dim) const
 {
   MX_ND_ANY_ALL_REDUCTION
     (MX_ND_ANY_EVAL (elem (iter_idx) != Complex (0, 0)
-		     && ! (lo_ieee_isnan (::real (elem (iter_idx)))
-			   || lo_ieee_isnan (::imag (elem (iter_idx))))),
+		     && ! (lo_ieee_isnan (std::real (elem (iter_idx)))
+			   || lo_ieee_isnan (std::imag (elem (iter_idx))))),
 		     false);
 }
 
 ComplexNDArray
 ComplexNDArray::cumprod (int dim) const
 {
   MX_ND_CUMULATIVE_OP (ComplexNDArray, Complex, Complex (1, 0), *);
 }
@@ -637,17 +637,17 @@ ComplexNDArray::prod (int dim) const
 {
   MX_ND_COMPLEX_OP_REDUCTION (*= elem (iter_idx), Complex (1, 0));
 }
 
 ComplexNDArray
 ComplexNDArray::sumsq (int dim) const
 {
   MX_ND_COMPLEX_OP_REDUCTION
-    (+= imag (elem (iter_idx))
+    (+= std::imag (elem (iter_idx))
      ? elem (iter_idx) * conj (elem (iter_idx))
      : std::pow (elem (iter_idx), 2), Complex (0, 0));
 }
 
 ComplexNDArray 
 ComplexNDArray::sum (int dim) const
 {
   MX_ND_COMPLEX_OP_REDUCTION (+= elem (iter_idx), Complex (0, 0));
@@ -731,29 +731,29 @@ ComplexNDArray::max (ArrayN<int>& idx_ar
       double abs_max = octave_NaN;
 
       for (idx_j = 0; idx_j < x_len; idx_j++)
 	{
 	  tmp_max = elem (idx_j * x_stride + x_offset);
 	  
 	  if (! octave_is_NaN_or_NA (tmp_max))
 	    {
-	      abs_max = ::abs(tmp_max);
+	      abs_max = std::abs(tmp_max);
 	      break;
 	    }
 	}
 
       for (int j = idx_j+1; j < x_len; j++)
 	{
 	  Complex tmp = elem (j * x_stride + x_offset);
 
 	  if (octave_is_NaN_or_NA (tmp))
 	    continue;
 
-	  double abs_tmp = ::abs (tmp);
+	  double abs_tmp = std::abs (tmp);
 
 	  if (abs_tmp > abs_max)
 	    {
 	      idx_j = j;
 	      tmp_max = tmp;
 	      abs_max = abs_tmp;
 	    }
 	}
@@ -823,29 +823,29 @@ ComplexNDArray::min (ArrayN<int>& idx_ar
       double abs_min = octave_NaN;
 
       for (idx_j = 0; idx_j < x_len; idx_j++)
 	{
 	  tmp_min = elem (idx_j * x_stride + x_offset);
 	  
 	  if (! octave_is_NaN_or_NA (tmp_min))
 	    {
-	      abs_min = ::abs(tmp_min);
+	      abs_min = std::abs(tmp_min);
 	      break;
 	    }
 	}
 
       for (int j = idx_j+1; j < x_len; j++)
 	{
 	  Complex tmp = elem (j * x_stride + x_offset);
 
 	  if (octave_is_NaN_or_NA (tmp))
 	    continue;
 
-	  double abs_tmp = ::abs (tmp);
+	  double abs_tmp = std::abs (tmp);
 
 	  if (abs_tmp < abs_min)
 	    {
 	      idx_j = j;
 	      tmp_min = tmp;
 	      abs_min = abs_tmp;
 	    }
 	}
@@ -868,17 +868,17 @@ ComplexNDArray::min (ArrayN<int>& idx_ar
 NDArray
 ComplexNDArray::abs (void) const
 {
   NDArray retval (dims ());
 
   int nel = nelem ();
 
   for (int i = 0; i < nel; i++)
-    retval(i) = ::abs (elem (i));
+    retval(i) = std::abs (elem (i));
       
   return retval;
 }
 
 ComplexNDArray&
 ComplexNDArray::insert (const NDArray& a, int r, int c)
 {
   dim_vector a_dv = a.dims ();
@@ -1155,22 +1155,22 @@ max (const ComplexNDArray& a, const Comp
     {
       OCTAVE_QUIT;
       result (i) = xmax (a (i), b (i));
     }
 
   return result;
 }
 
-NDS_CMP_OPS(ComplexNDArray, real, Complex, real)
+NDS_CMP_OPS(ComplexNDArray, std::real, Complex, std::real)
 NDS_BOOL_OPS(ComplexNDArray, Complex, 0.0)
 
-SND_CMP_OPS(Complex, real, ComplexNDArray, real)
+SND_CMP_OPS(Complex, std::real, ComplexNDArray, std::real)
 SND_BOOL_OPS(Complex, ComplexNDArray, 0.0)
 
-NDND_CMP_OPS(ComplexNDArray, real, ComplexNDArray, real)
+NDND_CMP_OPS(ComplexNDArray, std::real, ComplexNDArray, std::real)
 NDND_BOOL_OPS(ComplexNDArray, ComplexNDArray, 0.0)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/CRowVector.cc b/liboctave/CRowVector.cc
--- a/liboctave/CRowVector.cc
+++ b/liboctave/CRowVector.cc
@@ -403,43 +403,43 @@ ComplexRowVector::apply (c_c_Mapper f)
 Complex
 ComplexRowVector::min (void) const
 {
   int len = length ();
   if (len == 0)
     return Complex (0.0);
 
   Complex res = elem (0);
-  double absres = abs (res);
+  double absres = std::abs (res);
 
   for (int i = 1; i < len; i++)
-    if (abs (elem (i)) < absres)
+    if (std::abs (elem (i)) < absres)
       {
 	res = elem (i);
-	absres = abs (res);
+	absres = std::abs (res);
       }
 
   return res;
 }
 
 Complex
 ComplexRowVector::max (void) const
 {
   int len = length ();
   if (len == 0)
     return Complex (0.0);
 
   Complex res = elem (0);
-  double absres = abs (res);
+  double absres = std::abs (res);
 
   for (int i = 1; i < len; i++)
-    if (abs (elem (i)) > absres)
+    if (std::abs (elem (i)) > absres)
       {
 	res = elem (i);
-	absres = abs (res);
+	absres = std::abs (res);
       }
 
   return res;
 }
 
 // i/o
 
 std::ostream&
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,20 @@
+2005-03-30  John W. Eaton  <jwe@octave.org>
+
+	* liboctave/CColVector.cc, liboctave/CNDArray.cc,
+	liboctave/CRowVector.cc: Use std:: for Complex functions instead
+	of relying on wrappers from oct-cmplx.h.
+
+	* oct-cmplx.h: Provide typedef only.
+
+	* DiagArray2.cc (xelem): Don't use initializer for static data.
+	* DiagArray2.h (DiagArray<T>::Proxy::operator T ()):
+	Likewise.
+
 2005-03-26  John W. Eaton  <jwe@octave.org>
 
 	* cmd-edit.cc (do_readline): Wrap call to ::octave_rl_readline
 	with {BEGIN,END}_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE.
 
 2005-03-15  John W. Eaton  <jwe@octave.org>
 
 	* Makefile.in (MATRIX_INC): Remove oct-spparms.h from the list.
diff --git a/liboctave/DiagArray2.h b/liboctave/DiagArray2.h
--- a/liboctave/DiagArray2.h
+++ b/liboctave/DiagArray2.h
@@ -77,17 +77,17 @@ private:
       }
 
     operator T () const
       {
 	if (object && i == j)
 	  return object->get (i);
 	else
 	  {
-	    static T foo (0);
+	    static T foo;
 	    return foo;
 	  }
       }
 
   private:
 
     // XXX FIXME XXX -- this is declared private to keep the user from
     // taking the address of a Proxy.  Maybe it should be implemented
diff --git a/liboctave/oct-cmplx.h b/liboctave/oct-cmplx.h
--- a/liboctave/oct-cmplx.h
+++ b/liboctave/oct-cmplx.h
@@ -18,154 +18,19 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #if !defined (octave_oct_cmplx_h)
 #define octave_oct_cmplx_h 1
 
-// By using this file instead of <complex>, we can easily avoid buggy
-// implementations of the standard complex data type (if needed).
-
 #include <complex>
 
 typedef std::complex<double> Complex;
 
-#if defined (CXX_ISO_COMPLIANT_LIBRARY)
-
-// If namespaces don't work, we will end up with some infinite looping.
-
-inline double
-real (const Complex& z)
-{
-  return std::real (z);
-}
-
-inline double
-imag (const Complex& z)
-{
-  return std::imag (z);
-}
-
-inline double
-abs (const Complex& z)
-{
-  return std::abs (z);
-}
-
-inline double
-arg (const Complex& z)
-{
-  return std::arg (z);
-}
-
-inline double
-norm (const Complex& z)
-{
-  return std::norm (z);
-}
-
-inline Complex
-conj (const Complex& z)
-{
-  return std::conj (z);
-}
-
-inline Complex
-polar (const double& x, const double& y);
-
-inline Complex
-cos (const Complex& z)
-{
-  return std::cos (z);
-}
-
-inline Complex
-cosh (const Complex& z)
-{
-  return std::cosh (z);
-}
-
-inline Complex
-exp (const Complex& z)
-{
-  return std::exp (z);
-}
-
-inline Complex
-log (const Complex& z)
-{
-  return std::log (z);
-}
-
-inline Complex
-log10 (const Complex& z)
-{
-  return std::log10 (z);
-}
-
-inline Complex
-pow (const Complex& z, int n)
-{
-  return std::pow (z, n);
-}
-
-inline Complex
-pow (const Complex& z, const double& x)
-{
-  // XXX FIXME XXX -- this should not be needed, but it avoids a bug
-  // in some versions of libstdc++ (3.3.x and possibly others).
-
-  return std::pow (z, Complex (x));
-}
-
-inline Complex
-pow (const Complex& z1, const Complex& z2)
-{
-  return std::pow (z1, z2);
-}
-
-inline Complex
-pow (const double& x, const Complex& z)
-{
-  return std::pow (x, z);
-}
-
-inline Complex
-sin (const Complex& z)
-{
-  return std::sin (z);
-}
-
-inline Complex
-sinh (const Complex& z)
-{
-  return std::sinh (z);
-}
-
-inline Complex
-sqrt (const Complex& z)
-{
-  return std::sqrt (z);
-}
-
-inline Complex
-tan (const Complex& z)
-{
-  return std::tan (z);
-}
-
-inline Complex
-tanh (const Complex& z)
-{
-  return std::tanh (z);
-}
-
-#endif
-
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,15 @@
+2005-03-30  John W. Eaton  <jwe@octave.org>
+
+	* src/ov-complex.cc, src/ov-cx-mat.cc, src/xpow.cc: Use std:: for
+	Complex functions instead of relying on wrappers from oct-cmplx.h.
+
+	* oct-stream.cc (octave_scan): Initialize c1 to EOF.
+
 2005-03-29  John W. Eaton  <jwe@octave.org>
 
 	* utils.cc (get_dimensions): Produce error instead of warning if
 	given a matrix argument.
 
 	* load-save.cc (Fload, Fsave): Also accept -V4 option.
 
 	* ls-hdf5.h (hdf5_fstreambase::hdf5_fstreambase,
diff --git a/src/ov-complex.h b/src/ov-complex.h
--- a/src/ov-complex.h
+++ b/src/ov-complex.h
@@ -1,8 +1,9 @@
+#define OCTAVE_STD std
 /*
 
 Copyright (C) 1996, 1997 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
@@ -73,18 +74,18 @@ public:
 
   octave_value *try_narrowing_conversion (void);
 
   octave_value do_index_op (const octave_value_list& idx, int resize_ok);
 
   octave_value any (int = 0) const
     {
       return (scalar != Complex (0, 0)
-	      && ! (lo_ieee_isnan (::real (scalar))
-		    || lo_ieee_isnan (::imag (scalar))));
+	      && ! (lo_ieee_isnan (OCTAVE_STD::real (scalar))
+		    || lo_ieee_isnan (OCTAVE_STD::imag (scalar))));
     }
 
   bool is_complex_scalar (void) const { return true; }
 
   bool is_complex_type (void) const { return true; }
 
   // XXX FIXME XXX ???
   bool valid_as_scalar_index (void) const { return false; }
diff --git a/src/ov-cx-mat.cc b/src/ov-cx-mat.cc
--- a/src/ov-cx-mat.cc
+++ b/src/ov-cx-mat.cc
@@ -68,17 +68,17 @@ octave_complex_matrix::try_narrowing_con
 
       int nr = cm.rows ();
       int nc = cm.cols ();
 
       if (nr == 1 && nc == 1)
 	{
 	  Complex c = matrix (0, 0);
 
-	  if (imag (c) == 0.0)
+	  if (std::imag (c) == 0.0)
 	    retval = new octave_scalar (std::real (c));
 	  else
 	    retval = new octave_complex (c);
 	}
       else if (nr == 0 || nc == 0)
 	retval = new octave_matrix (Matrix (nr, nc));
       else if (cm.all_elements_are_real ())
 	retval = new octave_matrix (::real (cm));
@@ -211,18 +211,18 @@ strip_infnan (const ComplexMatrix& m)
     {
       for (int j = 0; j < nc; j++)
 	{
 	  Complex c = m (i, j);
 	  if (xisnan (c))
 	    goto next_row;
 	  else
 	    {
-	      double re = real (c);
-	      double im = imag (c);
+	      double re = std::real (c);
+	      double im = std::imag (c);
 
 	      re = xisinf (re) ? (re > 0 ? OCT_RBV : -OCT_RBV) : re;
 	      im = xisinf (im) ? (im > 0 ? OCT_RBV : -OCT_RBV) : im;
 
 	      retval (k, j) = Complex (re, im);
 	    }
 	}
       k++;
diff --git a/src/xpow.cc b/src/xpow.cc
--- a/src/xpow.cc
+++ b/src/xpow.cc
@@ -65,26 +65,22 @@ xisint (double x)
 //                  +---+---+----+----+
 
 // -*- 1 -*-
 octave_value
 xpow (double a, double b)
 {
   if (a < 0.0 && static_cast<int> (b) != b)
     {
-      // XXX FIXME XXX -- avoid apparent GNU libm bug by converting
-      // A and B to complex instead of just A.
+      Complex atmp (a);
 
-      Complex atmp (a);
-      Complex btmp (b);
-
-      return pow (atmp, btmp);
+      return std::pow (atmp, b);
     }
   else
-    return pow (a, b);
+    return std::pow (a, b);
 }
 
 // -*- 2 -*-
 octave_value
 xpow (double a, const Matrix& b)
 {
   octave_value retval;
 
@@ -97,36 +93,36 @@ xpow (double a, const Matrix& b)
     {
       EIG b_eig (b);
       ComplexColumnVector lambda (b_eig.eigenvalues ());
       ComplexMatrix Q (b_eig.eigenvectors ());
 
       for (int i = 0; i < nr; i++)
 	{
 	  Complex elt = lambda (i);
-	  if (imag (elt) == 0.0)
-	    lambda (i) = pow (a, real (elt));
+	  if (std::imag (elt) == 0.0)
+	    lambda (i) = std::pow (a, std::real (elt));
 	  else
-	    lambda (i) = pow (a, elt);
+	    lambda (i) = std::pow (a, elt);
 	}
       ComplexDiagMatrix D (lambda);
 
       retval = ComplexMatrix (Q * D * Q.inverse ());
     }
 
   return retval;
 }
 
 // -*- 3 -*-
 octave_value
 xpow (double a, const Complex& b)
 {
   Complex result;
   Complex atmp (a);
-  result = pow (atmp, b);
+  result = std::pow (atmp, b);
   return result;
 }
 
 // -*- 4 -*-
 octave_value
 xpow (double a, const ComplexMatrix& b)
 {
   octave_value retval;
@@ -140,20 +136,20 @@ xpow (double a, const ComplexMatrix& b)
     {
       EIG b_eig (b);
       ComplexColumnVector lambda (b_eig.eigenvalues ());
       ComplexMatrix Q (b_eig.eigenvectors ());
 
       for (int i = 0; i < nr; i++)
 	{
 	  Complex elt = lambda (i);
-	  if (imag (elt) == 0.0)
-	    lambda (i) = pow (a, real (elt));
+	  if (std::imag (elt) == 0.0)
+	    lambda (i) = std::pow (a, std::real (elt));
 	  else
-	    lambda (i) = pow (a, elt);
+	    lambda (i) = std::pow (a, elt);
 	}
       ComplexDiagMatrix D (lambda);
 
       retval = ComplexMatrix (Q * D * Q.inverse ());
     }
 
   return retval;
 }
@@ -221,17 +217,17 @@ xpow (const Matrix& a, double b)
 	}
       else
 	{
 	  EIG a_eig (a);
 	  ComplexColumnVector lambda (a_eig.eigenvalues ());
 	  ComplexMatrix Q (a_eig.eigenvectors ());
 
 	  for (int i = 0; i < nr; i++)
-	    lambda (i) = pow (lambda (i), b);
+	    lambda (i) = std::pow (lambda (i), b);
 
 	  ComplexDiagMatrix D (lambda);
 
 	  retval = ComplexMatrix (Q * D * Q.inverse ());
 	}
     }
 
   return retval;
@@ -250,36 +246,36 @@ xpow (const Matrix& a, const Complex& b)
     error ("for A^b, A must be square");
   else
     {
       EIG a_eig (a);
       ComplexColumnVector lambda (a_eig.eigenvalues ());
       ComplexMatrix Q (a_eig.eigenvectors ());
 
       for (int i = 0; i < nr; i++)
-	lambda (i) = pow (lambda (i), b);
+	lambda (i) = std::pow (lambda (i), b);
 
       ComplexDiagMatrix D (lambda);
 
       retval = ComplexMatrix (Q * D * Q.inverse ());
     }
 
   return retval;
 }
 
 // -*- 7 -*-
 octave_value
 xpow (const Complex& a, double b)
 {
   Complex result;
 
   if (xisint (b))
-    result = pow (a, static_cast<int> (b));
+    result = std::pow (a, static_cast<int> (b));
   else
-    result = pow (a, b);
+    result = std::pow (a, b);
 
   return result;
 }
 
 // -*- 8 -*-
 octave_value
 xpow (const Complex& a, const Matrix& b)
 {
@@ -294,35 +290,35 @@ xpow (const Complex& a, const Matrix& b)
     {
       EIG b_eig (b);
       ComplexColumnVector lambda (b_eig.eigenvalues ());
       ComplexMatrix Q (b_eig.eigenvectors ());
 
       for (int i = 0; i < nr; i++)
 	{
 	  Complex elt = lambda (i);
-	  if (imag (elt) == 0.0)
-	    lambda (i) = pow (a, real (elt));
+	  if (std::imag (elt) == 0.0)
+	    lambda (i) = std::pow (a, std::real (elt));
 	  else
-	    lambda (i) = pow (a, elt);
+	    lambda (i) = std::pow (a, elt);
 	}
       ComplexDiagMatrix D (lambda);
 
       retval = ComplexMatrix (Q * D * Q.inverse ());
     }
 
   return retval;
 }
 
 // -*- 9 -*-
 octave_value
 xpow (const Complex& a, const Complex& b)
 {
   Complex result;
-  result = pow (a, b);
+  result = std::pow (a, b);
   return result;
 }
 
 // -*- 10 -*-
 octave_value
 xpow (const Complex& a, const ComplexMatrix& b)
 {
   octave_value retval;
@@ -336,20 +332,20 @@ xpow (const Complex& a, const ComplexMat
     {
       EIG b_eig (b);
       ComplexColumnVector lambda (b_eig.eigenvalues ());
       ComplexMatrix Q (b_eig.eigenvectors ());
 
       for (int i = 0; i < nr; i++)
 	{
 	  Complex elt = lambda (i);
-	  if (imag (elt) == 0.0)
-	    lambda (i) = pow (a, real (elt));
+	  if (std::imag (elt) == 0.0)
+	    lambda (i) = std::pow (a, std::real (elt));
 	  else
-	    lambda (i) = pow (a, elt);
+	    lambda (i) = std::pow (a, elt);
 	}
       ComplexDiagMatrix D (lambda);
 
       retval = ComplexMatrix (Q * D * Q.inverse ());
     }
 
   return retval;
 }
@@ -417,17 +413,17 @@ xpow (const ComplexMatrix& a, double b)
 	}
       else
 	{
 	  EIG a_eig (a);
 	  ComplexColumnVector lambda (a_eig.eigenvalues ());
 	  ComplexMatrix Q (a_eig.eigenvectors ());
 
 	  for (int i = 0; i < nr; i++)
-	    lambda (i) = pow (lambda (i), b);
+	    lambda (i) = std::pow (lambda (i), b);
 
 	  ComplexDiagMatrix D (lambda);
 
 	  retval = ComplexMatrix (Q * D * Q.inverse ());
 	}
     }
 
   return retval;
@@ -446,17 +442,17 @@ xpow (const ComplexMatrix& a, const Comp
     error ("for A^b, A must be square");
   else
     {
       EIG a_eig (a);
       ComplexColumnVector lambda (a_eig.eigenvalues ());
       ComplexMatrix Q (a_eig.eigenvectors ());
 
       for (int i = 0; i < nr; i++)
-	lambda (i) = pow (lambda (i), b);
+	lambda (i) = std::pow (lambda (i), b);
 
       ComplexDiagMatrix D (lambda);
 
       retval = ComplexMatrix (Q * D * Q.inverse ());
     }
 
   return retval;
 }
@@ -504,29 +500,29 @@ elem_xpow (double a, const Matrix& b)
   if (a < 0.0 && ! b.all_integers (d1, d2))
     {
       Complex atmp (a);
       ComplexMatrix result (nr, nc);
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  {
 	    OCTAVE_QUIT;
-	    result (i, j) = pow (atmp, b (i, j));
+	    result (i, j) = std::pow (atmp, b (i, j));
 	  }
 
       retval = result;
     }
   else
     {
       Matrix result (nr, nc);
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  {
 	    OCTAVE_QUIT;
-	    result (i, j) = pow (a, b (i, j));
+	    result (i, j) = std::pow (a, b (i, j));
 	  }
 
       retval = result;
     }
 
   return retval;
 }
 
@@ -538,17 +534,17 @@ elem_xpow (double a, const ComplexMatrix
   int nc = b.cols ();
 
   ComplexMatrix result (nr, nc);
   Complex atmp (a);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
-	result (i, j) = pow (atmp, b (i, j));
+	result (i, j) = std::pow (atmp, b (i, j));
       }
 
   return result;
 }
 
 // -*- 3 -*-
 octave_value
 elem_xpow (const Matrix& a, double b)
@@ -561,35 +557,31 @@ elem_xpow (const Matrix& a, double b)
   if (static_cast<int> (b) != b && a.any_element_is_negative ())
     {
       ComplexMatrix result (nr, nc);
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  {
 	    OCTAVE_QUIT;
       
-	    // XXX FIXME XXX -- avoid apparent GNU libm bug by
-	    // converting A and B to complex instead of just A.
+	    Complex atmp (a (i, j));
 
-	    Complex atmp (a (i, j));
-	    Complex btmp (b);
-
-	    result (i, j) = pow (atmp, btmp);
+	    result (i, j) = std::pow (atmp, b);
 	  }
 
       retval = result;
     }
   else
     {
       Matrix result (nr, nc);
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  {
 	    OCTAVE_QUIT;
-	    result (i, j) = pow (a (i, j), b);
+	    result (i, j) = std::pow (a (i, j), b);
 	  }
 
       retval = result;
     }
 
   return retval;
 }
 
@@ -632,30 +624,30 @@ done:
       ComplexMatrix complex_result (nr, nc);
 
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  {
 	    OCTAVE_QUIT;
 	    Complex atmp (a (i, j));
 	    Complex btmp (b (i, j));
-	    complex_result (i, j) = pow (atmp, btmp);
+	    complex_result (i, j) = std::pow (atmp, btmp);
 	  }
 
       retval = complex_result;
     }
   else
     {
       Matrix result (nr, nc);
 
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  {
 	    OCTAVE_QUIT;
-	    result (i, j) = pow (a (i, j), b (i, j));
+	    result (i, j) = std::pow (a (i, j), b (i, j));
 	  }
 
       retval = result;
     }
 
   return retval;
 }
 
@@ -666,17 +658,17 @@ elem_xpow (const Matrix& a, const Comple
   int nr = a.rows ();
   int nc = a.cols ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
-	result (i, j) = pow (Complex (a (i, j)), b);
+	result (i, j) = std::pow (Complex (a (i, j)), b);
       }
 
   return result;
 }
 
 // -*- 6 -*-
 octave_value
 elem_xpow (const Matrix& a, const ComplexMatrix& b)
@@ -693,17 +685,17 @@ elem_xpow (const Matrix& a, const Comple
       return octave_value ();
     }
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
-	result (i, j) = pow (Complex (a (i, j)), b (i, j));
+	result (i, j) = std::pow (Complex (a (i, j)), b (i, j));
       }
 
   return result;
 }
 
 // -*- 7 -*-
 octave_value
 elem_xpow (const Complex& a, const Matrix& b)
@@ -713,19 +705,19 @@ elem_xpow (const Complex& a, const Matri
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	double btmp = b (i, j);
 	if (xisint (btmp))
-	  result (i, j) = pow (a, static_cast<int> (btmp));
+	  result (i, j) = std::pow (a, static_cast<int> (btmp));
 	else
-	  result (i, j) = pow (a, btmp);
+	  result (i, j) = std::pow (a, btmp);
       }
 
   return result;
 }
 
 // -*- 8 -*-
 octave_value
 elem_xpow (const Complex& a, const ComplexMatrix& b)
@@ -733,17 +725,17 @@ elem_xpow (const Complex& a, const Compl
   int nr = b.rows ();
   int nc = b.cols ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
-	result (i, j) = pow (a, b (i, j));
+	result (i, j) = std::pow (a, b (i, j));
       }
 
   return result;
 }
 
 // -*- 9 -*-
 octave_value
 elem_xpow (const ComplexMatrix& a, double b)
@@ -754,26 +746,26 @@ elem_xpow (const ComplexMatrix& a, doubl
   ComplexMatrix result (nr, nc);
 
   if (xisint (b))
     {
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  {
 	    OCTAVE_QUIT;
-	    result (i, j) = pow (a (i, j), static_cast<int> (b));
+	    result (i, j) = std::pow (a (i, j), static_cast<int> (b));
 	  }
     }
   else
     {
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  {
 	    OCTAVE_QUIT;
-	    result (i, j) = pow (a (i, j), b);
+	    result (i, j) = std::pow (a (i, j), b);
 	  }
     }
 
   return result;
 }
 
 // -*- 10 -*-
 octave_value
@@ -793,19 +785,19 @@ elem_xpow (const ComplexMatrix& a, const
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
 	double btmp = b (i, j);
 	if (xisint (btmp))
-	  result (i, j) = pow (a (i, j), static_cast<int> (btmp));
+	  result (i, j) = std::pow (a (i, j), static_cast<int> (btmp));
 	else
-	  result (i, j) = pow (a (i, j), btmp);
+	  result (i, j) = std::pow (a (i, j), btmp);
       }
 
   return result;
 }
 
 // -*- 11 -*-
 octave_value
 elem_xpow (const ComplexMatrix& a, const Complex& b)
@@ -813,17 +805,17 @@ elem_xpow (const ComplexMatrix& a, const
   int nr = a.rows ();
   int nc = a.cols ();
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
-	result (i, j) = pow (a (i, j), b);
+	result (i, j) = std::pow (a (i, j), b);
       }
 
   return result;
 }
 
 // -*- 12 -*-
 octave_value
 elem_xpow (const ComplexMatrix& a, const ComplexMatrix& b)
@@ -840,17 +832,17 @@ elem_xpow (const ComplexMatrix& a, const
       return octave_value ();
     }
 
   ComplexMatrix result (nr, nc);
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       {
 	OCTAVE_QUIT;
-	result (i, j) = pow (a (i, j), b (i, j));
+	result (i, j) = std::pow (a (i, j), b (i, j));
       }
 
   return result;
 }
 
 // Safer pow functions that work elementwise for N-d arrays.
 //
 //       op2 \ op1:   s   nd  cs   cnd
@@ -890,28 +882,28 @@ elem_xpow (double a, const NDArray& b)
 
   if (a < 0.0 && ! b.all_integers (d1, d2))
     {
       Complex atmp (a);
       ComplexNDArray result (b.dims ());
       for (int i = 0; i < b.length (); i++)
 	{
 	  OCTAVE_QUIT;
-	  result(i) = pow (atmp, b(i));
+	  result(i) = std::pow (atmp, b(i));
 	}
 
       retval = result;
     }
   else
     {
       NDArray result (b.dims ());
       for (int i = 0; i < b.length (); i++)
 	{
 	  OCTAVE_QUIT;
-	  result (i) = pow (a, b(i));
+	  result (i) = std::pow (a, b(i));
 	}
 
       retval = result;
     }
 
   return retval;
 }
 
@@ -919,17 +911,17 @@ elem_xpow (double a, const NDArray& b)
 octave_value
 elem_xpow (double a, const ComplexNDArray& b)
 {
   ComplexNDArray result (b.dims ());
   Complex atmp (a);
   for (int i = 0; i < b.length (); i++)
     {
       OCTAVE_QUIT;
-      result(i) = pow (atmp, b(i));
+      result(i) = std::pow (atmp, b(i));
     }
 
   return result;
 }
 
 // -*- 3 -*-
 octave_value
 elem_xpow (const NDArray& a, double b)
@@ -939,35 +931,31 @@ elem_xpow (const NDArray& a, double b)
   if (static_cast<int> (b) != b && a.any_element_is_negative ())
     {
       ComplexNDArray result (a.dims ());
 
       for (int i = 0; i < a.length (); i++)
 	{
 	  OCTAVE_QUIT;
 
-	  // XXX FIXME XXX -- avoid apparent GNU libm bug by
-	  // converting A and B to complex instead of just A.
+	  Complex atmp (a (i));
 
-	  Complex atmp (a (i));
-	  Complex btmp (b);
-
-	  result(i) = pow (atmp, btmp);
+	  result(i) = std::pow (atmp, b);
 	}
 
       retval = result;
     }
   else
     {
       NDArray result (a.dims ());
 
       for (int i = 0; i < a.length (); i++)
 	{
 	  OCTAVE_QUIT;
-	  result(i) = pow (a(i), b);
+	  result(i) = std::pow (a(i), b);
 	}
 
       retval = result;
     }
 
   return retval;
 }
 
@@ -1008,29 +996,29 @@ done:
     {
       ComplexNDArray complex_result (a_dims);
 
       for (int i = 0; i < len; i++)
 	{
 	  OCTAVE_QUIT;
 	  Complex atmp (a(i));
 	  Complex btmp (b(i));
-	  complex_result(i) = pow (atmp, btmp);
+	  complex_result(i) = std::pow (atmp, btmp);
 	}
 
       retval = complex_result;
     }
   else
     {
       NDArray result (a_dims);
 
       for (int i = 0; i < len; i++)
 	{
 	  OCTAVE_QUIT;
-	  result(i) = pow (a(i), b(i));
+	  result(i) = std::pow (a(i), b(i));
 	}
 
       retval = result;
     }
 
   return retval;
 }
 
@@ -1038,17 +1026,17 @@ done:
 octave_value
 elem_xpow (const NDArray& a, const Complex& b)
 {
   ComplexNDArray result (a.dims ());
 
   for (int i = 0; i < a.length (); i++)
     {
       OCTAVE_QUIT;
-      result(i) = pow (Complex (a(i)), b);
+      result(i) = std::pow (Complex (a(i)), b);
     }
 
   return result;
 }
 
 // -*- 6 -*-
 octave_value
 elem_xpow (const NDArray& a, const ComplexNDArray& b)
@@ -1061,74 +1049,74 @@ elem_xpow (const NDArray& a, const Compl
       gripe_nonconformant ("operator .^", a_dims, b_dims);
       return octave_value ();
     }
 
   ComplexNDArray result (a_dims);
   for (int i = 0; i < a.length (); i++)
     {
       OCTAVE_QUIT;
-      result(i) = pow (Complex (a(i)), b(i));
+      result(i) = std::pow (Complex (a(i)), b(i));
     }
 
   return result;
 }
 
 // -*- 7 -*-
 octave_value
 elem_xpow (const Complex& a, const NDArray& b)
 {
   ComplexNDArray result (b.dims ());
   for (int i = 0; i < b.length (); i++)
     {
       OCTAVE_QUIT;
       double btmp = b(i);
       if (xisint (btmp))
-	result(i) = pow (a, static_cast<int> (btmp));
+	result(i) = std::pow (a, static_cast<int> (btmp));
       else
-	result(i) = pow (a, btmp);
+	result(i) = std::pow (a, btmp);
     }
 
   return result;
 }
 
 // -*- 8 -*-
 octave_value
 elem_xpow (const Complex& a, const ComplexNDArray& b)
 {
   ComplexNDArray result (b.dims ());
   for (int i = 0; i < b.length (); i++)
     {
       OCTAVE_QUIT;
-      result(i) = pow (a, b(i));
+      result(i) = std::pow (a, b(i));
     }
 
   return result;
 }
 
 // -*- 9 -*-
 octave_value
 elem_xpow (const ComplexNDArray& a, double b)
 {
   ComplexNDArray result (a.dims ());
 
   if (xisint (b))
     {
       for (int i = 0; i < a.length (); i++)
 	{
 	  OCTAVE_QUIT;
-	  result(i) = pow (a(i), static_cast<int> (b));
+	  result(i) = std::pow (a(i), static_cast<int> (b));
 	}
     }
   else
     {
       for (int i = 0; i < a.length (); i++)
 	{
 	  OCTAVE_QUIT;
-	  result(i) = pow (a(i), b);
+	  result(i) = std::pow (a(i), b);
 	}
     }
 
   return result;
 }
 
 // -*- 10 -*-
 octave_value
@@ -1144,33 +1132,33 @@ elem_xpow (const ComplexNDArray& a, cons
     }
 
   ComplexNDArray result (a_dims);
   for (int i = 0; i < a.length (); i++)
     {
       OCTAVE_QUIT;
       double btmp = b(i);
       if (xisint (btmp))
-	result(i) = pow (a(i), static_cast<int> (btmp));
+	result(i) = std::pow (a(i), static_cast<int> (btmp));
       else
-	result(i) = pow (a(i), btmp);
+	result(i) = std::pow (a(i), btmp);
     }
 
   return result;
 }
 
 // -*- 11 -*-
 octave_value
 elem_xpow (const ComplexNDArray& a, const Complex& b)
 {
   ComplexNDArray result (a.dims ());
   for (int i = 0; i < a.length (); i++)
     {
       OCTAVE_QUIT;
-      result(i) = pow (a(i), b);
+      result(i) = std::pow (a(i), b);
     }
 
   return result;
 }
 
 // -*- 12 -*-
 octave_value
 elem_xpow (const ComplexNDArray& a, const ComplexNDArray& b)
@@ -1183,17 +1171,17 @@ elem_xpow (const ComplexNDArray& a, cons
       gripe_nonconformant ("operator .^", a_dims, b_dims);
       return octave_value ();
     }
 
   ComplexNDArray result (a_dims);
   for (int i = 0; i < a.length (); i++)
     {
       OCTAVE_QUIT;
-      result(i) = pow (a(i), b(i));
+      result(i) = std::pow (a(i), b(i));
     }
 
   return result;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
