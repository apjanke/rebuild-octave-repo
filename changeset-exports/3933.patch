# HG changeset patch
# User jwe
# Date 1021432861 0
#      Wed May 15 03:21:01 2002 +0000
# Node ID f9ea3dcf58ee016c06040d361d2c9a54bffbd921
# Parent  2e2e32198722822c3e34c1780e12a8a2f59d54e8
[project @ 2002-05-15 03:21:00 by jwe]

diff --git a/liboctave/Array-idx.h b/liboctave/Array-idx.h
--- a/liboctave/Array-idx.h
+++ b/liboctave/Array-idx.h
@@ -64,23 +64,24 @@ Array<T>::value (void)
 
   clear_index ();
 
   return retval;
 }
 
 template <class T>
 Array<T>
-Array<T>::index (idx_vector& idx_arg) const
+Array<T>::index (idx_vector& idx_arg, int resize_ok,
+		 const T& resize_fill_value) const
 {
   Array<T> retval;
 
   int len = length ();
 
-  int n = idx_arg.freeze (len, "vector");
+  int n = idx_arg.freeze (len, "vector", resize_ok);
 
   if (idx_arg)
     {
       if (idx_arg.is_colon_equiv (len))
 	{
 	  retval = *this;
 	}
       else if (n == 0)
@@ -95,17 +96,20 @@ Array<T>::index (idx_vector& idx_arg) co
 	}
       else
 	{
 	  retval.resize (n);
 
 	  for (int i = 0; i < n; i++)
 	    {
 	      int ii = idx_arg.elem (i);
-	      retval.elem (i) = elem (ii);
+	      if (ii > len)
+		retval.elem (i) = resize_fill_value;
+	      else
+		retval.elem (i) = elem (ii);
 	    }
 	}
     }
 
   // idx_vector::freeze() printed an error message for us.
 
   return retval;
 }
diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -180,13 +180,23 @@ template <class T>
 T&
 Array<T>::range_error (const char *fcn, int n)
 {
   (*current_liboctave_error_handler) ("%s (%d): range error", fcn, n);
   static T foo;
   return foo;
 }
 
+template <class T>
+void
+Array<T>::print_info (std::ostream& os, const std::string& prefix) const
+{
+  os << prefix << "rep address: " << rep << "\n"
+     << prefix << "rep->len:    " << rep->len << "\n"
+     << prefix << "rep->data:   " << static_cast<void *> (rep->data) << "\n"
+     << prefix << "rep->count:  " << rep->count << "\n";
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -25,16 +25,18 @@ Software Foundation, 59 Temple Place - S
 #define octave_Array_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 #include <cassert>
 
+#include <iostream>
+
 #include "lo-utils.h"
 
 class idx_vector;
 
 // For now, define this here if it is not already defined.  Not doing
 // this can result in bugs that are very hard to find.
 
 #ifndef HEAVYWEIGHT_INDEXING
@@ -227,34 +229,39 @@ public:
       make_unique ();
 
       rep->qsort (compare);
 
       return *this;
     }
 
 #ifdef HEAVYWEIGHT_INDEXING
+
   void set_max_indices (int mi) { max_indices = mi; }
 
   void clear_index (void);
 
   void set_index (const idx_vector& i);
 
   int index_count (void) const { return idx_count; }
 
   idx_vector *get_idx (void) const { return idx; }
 
   void maybe_delete_elements (idx_vector& i);
 
   Array<T> value (void);
 
-  Array<T> index (idx_vector& i) const;
+  Array<T> index (idx_vector& i, int resize_ok = 0,
+		  const T& rfv = Array<T>::resize_fill_value ()) const;
+
 #endif
 
   static T resize_fill_value (void) { return static_cast<T> (0); }
+
+  void print_info (std::ostream& os, const std::string& prefix) const;
 };
 
 template <class LT, class RT>
 int
 assign (Array<LT>& lhs, const Array<RT>& rhs, const LT& resize_fill_value);
 
 template <class LT, class RT>
 int
diff --git a/liboctave/Array2-idx.h b/liboctave/Array2-idx.h
--- a/liboctave/Array2-idx.h
+++ b/liboctave/Array2-idx.h
@@ -51,49 +51,52 @@ Array2<T>::value (void)
 
   clear_index ();
 
   return retval;
 }
 
 template <class T>
 Array2<T>
-Array2<T>::index (idx_vector& idx_arg) const
+Array2<T>::index (idx_vector& idx_arg, int resize_ok,
+		  const T& resize_fill_value) const
 {
   Array2<T> retval;
 
   int nr = d1;
   int nc = d2;
 
+  int orig_len = nr * nc;
+
   int idx_orig_rows = idx_arg.orig_rows ();
   int idx_orig_columns = idx_arg.orig_columns ();
 
   if (idx_arg.is_colon ())
     {
       // Fast magic colon processing.
 
       int result_nr = nr * nc;
       int result_nc = result_nr ? 1 : 0;
 
       retval = Array2<T> (*this, result_nr, result_nc);
     }
   else if (nr == 1 && nc == 1)
     {
-      Array<T> tmp = Array<T>::index (idx_arg);
+      Array<T> tmp = Array<T>::index (idx_arg, resize_ok);
 
       if (tmp.length () != 0)
 	retval = Array2<T> (tmp, idx_orig_rows, idx_orig_columns);
       else
 	retval = Array2<T> (tmp, 0, 0);
     }
   else if (nr == 1 || nc == 1)
     {
       int result_is_column_vector = (nc == 1);
 
-      Array<T> tmp = Array<T>::index (idx_arg);
+      Array<T> tmp = Array<T>::index (idx_arg, resize_ok);
 
       int len = tmp.length ();
 
       if (len == 0)
 	retval = Array2<T> (0, 0);
       else
 	{
 	  if (result_is_column_vector)
@@ -105,63 +108,71 @@ Array2<T>::index (idx_vector& idx_arg) c
   else if (liboctave_dfi_flag
 	   || (idx_arg.one_zero_only ()
 	       && idx_orig_rows == nr
 	       && idx_orig_columns == nc))
     {
       // This code is only for indexing matrices.  The vector
       // cases are handled above.
 
-      idx_arg.freeze (nr * nc, "matrix");
+      idx_arg.freeze (nr * nc, "matrix", resize_ok);
 
       if (idx_arg)
 	{
 	  int result_nr = idx_orig_rows;
 	  int result_nc = idx_orig_columns;
 
 	  if (idx_arg.one_zero_only ())
 	    {
 	      result_nr = idx_arg.ones_count ();
 	      result_nc = (result_nr > 0 ? 1 : 0);
 	    }
 
 	  retval.resize (result_nr, result_nc);
 
+
+
 	  int k = 0;
 	  for (int j = 0; j < result_nc; j++)
 	    {
 	      for (int i = 0; i < result_nr; i++)
 		{
 		  int ii = idx_arg.elem (k++);
-		  int fr = ii % nr;
-		  int fc = (ii - fr) / nr;
-		  retval.elem (i, j) = elem (fr, fc);
+		  if (ii > orig_len)
+		    retval.elem (i, j) = resize_fill_value;
+		  else
+		    {
+		      int fr = ii % nr;
+		      int fc = (ii - fr) / nr;
+		      retval.elem (i, j) = elem (fr, fc);
+		    }
 		}
 	    }
 	}
       // idx_vector::freeze() printed an error message for us.
     }
   else
     (*current_liboctave_error_handler)
       ("single index only valid for row or column vector");
 
   return retval;
 }
 
 template <class T>
 Array2<T>
-Array2<T>::index (idx_vector& idx_i, idx_vector& idx_j) const
+Array2<T>::index (idx_vector& idx_i, idx_vector& idx_j, int resize_ok,
+		  const T& resize_fill_value) const
 {
   Array2<T> retval;
 
   int nr = d1;
   int nc = d2;
 
-  int n = idx_i.freeze (nr, "row");
-  int m = idx_j.freeze (nc, "column");
+  int n = idx_i.freeze (nr, "row", resize_ok);
+  int m = idx_j.freeze (nc, "column", resize_ok);
 
   if (idx_i && idx_j)
     {
       if (idx_i.orig_empty () || idx_j.orig_empty () || n == 0 || m == 0)
 	{
 	  retval.resize (n, m);
 	}
       else if (idx_i.is_colon_equiv (nr) && idx_j.is_colon_equiv (nc))
@@ -173,17 +184,20 @@ Array2<T>::index (idx_vector& idx_i, idx
 	  retval.resize (n, m);
 
 	  for (int j = 0; j < m; j++)
 	    {
 	      int jj = idx_j.elem (j);
 	      for (int i = 0; i < n; i++)
 		{
 		  int ii = idx_i.elem (i);
-		  retval.elem (i, j) = elem (ii, jj);
+		  if (ii > nr || jj > nc)
+		    retval.elem (i, j) = resize_fill_value;
+		  else
+		    retval.elem (i, j) = elem (ii, jj);
 		}
 	    }
 	}
     }
 
   // idx_vector::freeze() printed an error message for us.
 
   return retval;
diff --git a/liboctave/Array2.cc b/liboctave/Array2.cc
--- a/liboctave/Array2.cc
+++ b/liboctave/Array2.cc
@@ -232,13 +232,24 @@ Array2<T>::transpose (void) const
     }
   else
     {
       // Fast transpose for vectors and empty matrices
       return Array2<T> (*this, d2, d1);
     }
 }
 
+template <class T>
+void
+Array2<T>::print_info (std::ostream& os, const std::string& prefix) const
+{
+  os << "\n"
+     << prefix << "rows: " << rows () << "\n"
+     << prefix << "cols: " << cols () << "\n";
+
+  Array<T>::print_info (os, prefix + "  ");
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/Array2.h b/liboctave/Array2.h
--- a/liboctave/Array2.h
+++ b/liboctave/Array2.h
@@ -169,26 +169,32 @@ public:
 
   Array2<T>& insert (const Array2<T>& a, int r, int c);
 
   bool is_square (void) const { return (d1 == d2); }
 
   Array2<T> transpose (void) const;
 
 #ifdef HEAVYWEIGHT_INDEXING
+
   void maybe_delete_elements (idx_vector& i);
 
   void maybe_delete_elements (idx_vector& i, idx_vector& j);
 
   Array2<T> value (void);
 
-  Array2<T> index (idx_vector& i) const;
+  Array2<T> index (idx_vector& i, int resize_ok = 0,
+		   const T& rfv = Array<T>::resize_fill_value ()) const;
 
-  Array2<T> index (idx_vector& i, idx_vector& j) const;
+  Array2<T> index (idx_vector& i, idx_vector& j, int resize_ok = 0,
+		   const T& rfv = Array<T>::resize_fill_value ()) const;
+
 #endif
+
+  void print_info (std::ostream& os, const std::string& prefix) const;
 };
 
 template <class LT, class RT>
 int
 assign (Array2<LT>& lhs, const Array2<RT>& rhs, const LT& resize_fill_value);
 
 template <class LT, class RT>
 int
diff --git a/liboctave/ArrayN-idx.h b/liboctave/ArrayN-idx.h
--- a/liboctave/ArrayN-idx.h
+++ b/liboctave/ArrayN-idx.h
@@ -65,36 +65,37 @@ ArrayN<T>::value (void)
 
   clear_index ();
 
   return retval;
 }
 
 template <class T>
 ArrayN<T>
-ArrayN<T>::index (idx_vector& idx) const
+ArrayN<T>::index (idx_vector& idx, int resize_ok,
+		  const T& resize_fill_value) const
 {
   ArrayN<T> retval;
   assert (0);
   return retval;
 }
 
 static inline Array<int>
-freeze (Array<idx_vector>& idx, const Array<int>& dimensions)
+freeze (Array<idx_vector>& idx, const Array<int>& dimensions, int resize_ok)
 {
   Array<int> retval;
 
   int n = idx.length ();
 
   assert (n == dimensions.length ());
 
   retval.resize (n);
 
   for (int i = 0; i < n; i++)
-    retval(i) = idx(i).freeze (dimensions(i), "XXX FIXME XXX");
+    retval(i) = idx(i).freeze (dimensions(i), "XXX FIXME XXX", resize_ok);
 
   return retval;
 }
 
 static inline bool
 all_ok (const Array<idx_vector>& idx)
 {
   bool retval = true;
@@ -194,23 +195,24 @@ get_elt_idx (const Array<idx_vector>& id
   for (int i = 0; i < n; i++)
     retval(i) = idx(result_idx(i));
 
   return retval;
 }
 
 template <class T>
 ArrayN<T>
-ArrayN<T>::index (Array<idx_vector>& arr_idx) const
+ArrayN<T>::index (Array<idx_vector>& arr_idx, int resize_ok,
+		  const T& resize_fill_value) const
 {
   ArrayN<T> retval;
 
   int n_dims = dimensions.length ();
 
-  Array<int> frozen_lengths = freeze (arr_idx, dimensions);
+  Array<int> frozen_lengths = freeze (arr_idx, dimensions, resize_ok);
 
   if (frozen_lengths.length () == n_dims)
     {
       if (all_ok (arr_idx))
 	{
 	  if (any_orig_empty (arr_idx))
 	    {
 	      retval.resize (frozen_lengths);
@@ -234,17 +236,20 @@ ArrayN<T>::index (Array<idx_vector>& arr
 	      int n = Array<T>::get_size (frozen_lengths);
 
 	      Array<int> result_idx (n_dims, 0);
 
 	      for (int i = 0; i < n; i++)
 		{
 		  Array<int> elt_idx = get_elt_idx (result_idx);
 
-		  retval.elem (result_idx) = elem (elt_idx);
+		  if (elt_idx > orig_len)
+		    retval.elem (result_idx) = resize_fill_value;
+		  else
+		    retval.elem (result_idx) = elem (elt_idx);
 
 		  increment_index (result_idx, frozen_lengths);
 		}
 #endif
 	    }
 	}
       // idx_vector::freeze() printed an error message for us.
     }
diff --git a/liboctave/ArrayN.h b/liboctave/ArrayN.h
--- a/liboctave/ArrayN.h
+++ b/liboctave/ArrayN.h
@@ -174,19 +174,22 @@ public:
 
   ArrayN<T>& insert (const ArrayN<T>& a, const Array<int>& dims);
 
 #ifdef HEAVYWEIGHT_INDEXING
   void maybe_delete_elements (Array<idx_vector>& idx);
 
   ArrayN<T> value (void);
 
-  ArrayN<T> index (idx_vector& idx) const;
+  ArrayN<T> index (idx_vector& idx, int resize_ok = 0,
+		   const T& rfv = Array<T>::resize_fill_value ()) const;
 
-  ArrayN<T> index (Array<idx_vector>& idx) const;
+  ArrayN<T> index (Array<idx_vector>& idx, int resize_ok = 0,
+		   const T& rfv = Array<T>::resize_fill_value ()) const;
+
 #endif
 };
 
 template <class LT, class RT>
 int
 assign (ArrayN<LT>& lhs, const ArrayN<RT>& rhs, const LT& resize_fill_value);
 
 template <class LT, class RT>
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -268,16 +268,18 @@ public:
   ComplexRowVector column_min (Array<int>& index) const;
   ComplexRowVector column_max (Array<int>& index) const;
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const ComplexMatrix& a);
   friend std::istream& operator >> (std::istream& is, ComplexMatrix& a);
 
+  static Complex resize_fill_value (void) { return Complex (0.0, 0.0); }
+
 private:
 
   ComplexMatrix (Complex *d, int r, int c) : MArray2<Complex> (d, r, c) { }
 };
 
 ComplexMatrix Givens (const Complex&, const Complex&);
 
 ComplexMatrix Sylvester (const ComplexMatrix&, const ComplexMatrix&,
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,38 @@
+2002-05-14  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* oct-rl-edit.c (OCTAVE_RL_SAVE_STRING): New macro.
+	(octave_rl_set_name, octave_rl_set_basic_quote_characters): Use it.
+	(octave_rl_set_basic_word_break_characters,
+	octave_rl_set_completer_word_break_characters): New functions.
+	* oct-rl-edit.h: Provide decls.
+	* cmd-edit.cc (gnu_readline::do_set_basic_word_break_characters,
+	gnu_readline::do_set_completer_word_break_characters): New functions.
+	(command_editor::set_basic_quote_characters,
+	command_editor::set_completion_append_character): New static functions.
+	* cmd-edit.h: Provide decls.
+	(command_editor::do_set_basic_word_break_characters,
+	command_editor::do_set_completer_word_break_characters):
+	New virtual functions.
+
+	* CMatrix.h, boolMatrix.h, chMatrix.h, dMatrix.h
+	(resize_fill_value): New static function.
+
+	* Array-idx.h (Array<T>::index): New args, resize_ok and
+	resize_fill_value.
+	* Array2-idx.h (Array2<T>::index): Likewise.
+	* ArrayN-idx.h (ArrayN<T>::index): Likewise.
+
+	* Array2.cc (Array<T>::print_info): New function.
+	* Array2.h: Provide decl.
+
+	* Array.cc (Array<T>::print_info): New function.
+	* Array.h: Provide decl.
+
 2002-05-03  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* idx-vector.h (idx_vector::idx_vector (int)): New function.
 	(idx_vector_rep::idx_vector_rep (int)): New decl.
 	* idx-vector.cc (idx_vector_rep::idx_vector_rep (int)): New function.
 
 	* Array.h (Array<T>::resize_fill_value (void)): New static function.
 	(assign (Array<LT>&, const Array<RT>&)): Use it.
diff --git a/liboctave/boolMatrix.h b/liboctave/boolMatrix.h
--- a/liboctave/boolMatrix.h
+++ b/liboctave/boolMatrix.h
@@ -69,16 +69,18 @@ public:
 
 #if 0
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const Matrix& a);
   friend std::istream& operator >> (std::istream& is, Matrix& a);
 #endif
 
+  static bool resize_fill_value (void) { return false; }
+
 private:
 
   boolMatrix (bool *b, int r, int c) : Array2<bool> (b, r, c) { }
 };
 
 MM_CMP_OP_DECLS (boolMatrix, boolMatrix)
 
 #endif
diff --git a/liboctave/chMatrix.h b/liboctave/chMatrix.h
--- a/liboctave/chMatrix.h
+++ b/liboctave/chMatrix.h
@@ -76,16 +76,18 @@ public:
 
 #if 0
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const Matrix& a);
   friend std::istream& operator >> (std::istream& is, Matrix& a);
 #endif
 
+  static char resize_fill_value (void) { return '\0'; }
+
 private:
 
   charMatrix (char *ch, int r, int c) : MArray2<char> (ch, r, c) { }
 };
 
 #endif
 
 /*
diff --git a/liboctave/cmd-edit.cc b/liboctave/cmd-edit.cc
--- a/liboctave/cmd-edit.cc
+++ b/liboctave/cmd-edit.cc
@@ -88,16 +88,20 @@ public:
   void do_resize_terminal (void);
 
   std::string newline_chars (void);
 
   void do_restore_terminal_state (void);
 
   void do_blink_matching_paren (bool flag);
 
+  void do_set_basic_word_break_characters (const std::string& s);
+
+  void do_set_completer_word_break_characters (const std::string& s);
+
   void do_set_basic_quote_characters (const std::string& s);
 
   void do_set_completion_append_character (char c);
 
   void do_set_completion_function (completion_fcn f);
 
   completion_fcn do_get_completion_function (void) const;
 
@@ -265,16 +269,28 @@ gnu_readline::do_restore_terminal_state 
 
 void
 gnu_readline::do_blink_matching_paren (bool flag)
 {
   ::octave_rl_enable_paren_matching (flag ? 1 : 0);
 }
 
 void
+gnu_readline::do_set_basic_word_break_characters (const std::string& s)
+{
+  ::octave_rl_set_basic_word_break_characters (s.c_str ());
+}
+
+void
+gnu_readline::do_set_completer_word_break_characters (const std::string& s)
+{
+  ::octave_rl_set_completer_word_break_characters (s.c_str ());
+}
+
+void
 gnu_readline::do_set_basic_quote_characters (const std::string& s)
 {
   ::octave_rl_set_basic_quote_characters (s.c_str ());
 }
 
 void
 gnu_readline::do_set_completion_append_character (char c)
 {
@@ -630,16 +646,30 @@ command_editor::restore_terminal_state (
 void
 command_editor::blink_matching_paren (bool flag)
 {
   if (instance_ok ())
     instance->do_blink_matching_paren (flag);
 }
 
 void
+command_editor::set_basic_word_break_characters (const std::string& s)
+{
+  if (instance_ok ())
+    instance->do_set_basic_word_break_characters (s);
+}
+
+void
+command_editor::set_completer_word_break_characters (const std::string& s)
+{
+  if (instance_ok ())
+    instance->do_set_completer_word_break_characters (s);
+}
+
+void
 command_editor::set_basic_quote_characters (const std::string& s)
 {
   if (instance_ok ())
     instance->do_set_basic_quote_characters (s);
 }
 
 void
 command_editor::set_completion_append_character (char c)
diff --git a/liboctave/cmd-edit.h b/liboctave/cmd-edit.h
--- a/liboctave/cmd-edit.h
+++ b/liboctave/cmd-edit.h
@@ -68,16 +68,22 @@ public:
   static void resize_terminal (void);
 
   static std::string decode_prompt_string (const std::string& s);
 
   static void restore_terminal_state (void);
 
   static void blink_matching_paren (bool flag);
 
+  static void command_editor::set_basic_word_break_characters
+    (const std::string& s);
+
+  static void command_editor::set_completer_word_break_characters
+    (const std::string& s);
+
   static void set_basic_quote_characters (const std::string& s);
 
   static void set_completion_append_character (char c);
 
   static void set_completion_function (completion_fcn f);
 
   static completion_fcn get_completion_function (void);
 
@@ -154,16 +160,20 @@ protected:
   virtual std::string do_decode_prompt_string (const std::string&);
 
   virtual std::string newline_chars (void) { return "\n"; } 
 
   virtual void do_restore_terminal_state (void) { }
 
   virtual void do_blink_matching_paren (bool) { }
 
+  virtual void do_set_basic_word_break_characters (const std::string&) { }
+
+  virtual void do_set_completer_word_break_characters (const std::string&) { }
+
   virtual void do_set_basic_quote_characters (const std::string&) { }
 
   virtual void do_set_completion_append_character (char) { }
 
   virtual void do_set_completion_function (completion_fcn) { }
 
   virtual completion_fcn do_get_completion_function (void) const { return 0; }
 
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -228,16 +228,18 @@ public:
   friend std::istream& operator >> (std::istream& is, Matrix& a);
 
   int read (std::istream& is, int nr, int nc, oct_data_conv::data_type dt,
 	    int skip, oct_mach_info::float_format flt_fmt);
 
   int write (std::ostream& os, oct_data_conv::data_type dt, int skip,
 	     oct_mach_info::float_format flt_fmt);
 
+  static double resize_fill_value (void) { return 0; }
+
 private:
 
   Matrix (double *d, int r, int c) : MArray2<double> (d, r, c) { }
 };
 
 extern Matrix Givens (double, double);
 
 extern Matrix Sylvester (const Matrix&, const Matrix&, const Matrix&);
diff --git a/liboctave/oct-rl-edit.c b/liboctave/oct-rl-edit.c
--- a/liboctave/oct-rl-edit.c
+++ b/liboctave/oct-rl-edit.c
@@ -28,16 +28,29 @@ Software Foundation, 59 Temple Place - S
 
 #include <stdio.h>
 #include <stdlib.h>
 
 #include <readline/readline.h>
 
 #include "oct-rl-edit.h"
 
+#define OCTAVE_RL_SAVE_STRING(ss, s) \
+  static char *ss = 0; \
+ \
+  if (ss) \
+    { \
+      free (ss); \
+      ss = 0; \
+    } \
+ \
+  ss = malloc (strlen (s) + 1); \
+ \
+  strcpy (ss, s)
+
 int
 octave_rl_screen_height (void)
 {
   int rows, cols;
   rl_get_screen_size (&rows, &cols);
   return rows;
 }
 
@@ -118,27 +131,17 @@ octave_rl_clear_undo_list (void)
 
       rl_undo_list = 0;
     }
 }
 
 void
 octave_rl_set_name (const char *n)
 {
-  static char *nm = 0;
-
-  if (nm)
-    {
-      free (nm);
-      nm = 0;
-    }
-
-  nm = malloc (strlen (n + 1));
-
-  strcpy (nm, n);
+  OCTAVE_RL_SAVE_STRING (nm, n);
 
   rl_readline_name = nm;
 
   /* Since we've already called rl_initialize, we need to re-read the
      init file to take advantage of the conditional parsing feature
      based on rl_readline_name; */
 
   rl_re_read_init_file (0, 0);
@@ -179,29 +182,35 @@ octave_rl_read_init_file (const char *f)
 {
   if (f && *f)
     rl_read_init_file (f);
   else
     rl_re_read_init_file (0, 0);
 }
 
 void
+octave_rl_set_basic_word_break_characters (const char *s)
+{
+  OCTAVE_RL_SAVE_STRING (ss, s);
+
+  rl_basic_word_break_characters = ss;
+}
+
+void
+octave_rl_set_completer_word_break_characters (const char *s)
+{
+  OCTAVE_RL_SAVE_STRING (ss, s);
+
+  rl_completer_word_break_characters = ss;
+}
+
+void
 octave_rl_set_basic_quote_characters (const char *s)
 {
-  static char *ss = 0;
-
-  if (ss)
-    {
-      free (ss);
-      ss = 0;
-    }
-
-  ss = malloc (strlen (s) + 1);
-
-  strcpy (ss, s);
+  OCTAVE_RL_SAVE_STRING (ss, s);
 
   rl_basic_quote_characters = ss;
 }
 
 void
 octave_rl_set_completion_append_character (char c)
 {
   rl_completion_append_character = c;
diff --git a/liboctave/oct-rl-edit.h b/liboctave/oct-rl-edit.h
--- a/liboctave/oct-rl-edit.h
+++ b/liboctave/oct-rl-edit.h
@@ -67,16 +67,20 @@ extern void octave_rl_set_input_stream (
 extern FILE *octave_rl_get_input_stream (void);
 
 extern void octave_rl_set_output_stream (FILE *);
 
 extern FILE *octave_rl_get_output_stream (void);
 
 extern void octave_rl_read_init_file (const char *);
 
+extern void octave_rl_set_basic_word_break_characters (const char *);
+
+extern void octave_rl_set_completer_word_break_characters (const char *);
+
 extern void octave_rl_set_basic_quote_characters (const char *);
 
 extern void octave_rl_set_completion_append_character (char);
 
 extern void
 octave_rl_set_completion_function (rl_attempted_completion_fcn_ptr);
 
 extern void octave_rl_set_startup_hook (rl_startup_hook_fcn_ptr);
diff --git a/src/Cell.h b/src/Cell.h
--- a/src/Cell.h
+++ b/src/Cell.h
@@ -47,22 +47,32 @@ public:
     : Array2<octave_value> (1, 1, val) { }
 
   Cell (int n, int m, const octave_value& val = octave_value ())
     : Array2<octave_value> (n, m, val) { }
 
   Cell (const Array2<octave_value>& c)
     : Array2<octave_value> (c) { }
 
+  Cell (const Array<octave_value>& c, int nr, int nc)
+    : Array2<octave_value> (c, nr, nc) { }
+
   Cell (const Cell& c)
     : Array2<octave_value> (c) { }
 
-  boolMatrix all(void) const { return boolMatrix();} //FIXME
-  boolMatrix any(void) const {return boolMatrix();}  //FIXME
-  bool is_true(void) const {return false;} //FIXME
+  // XXX FIXME XXX
+  boolMatrix all (void) const { return boolMatrix (); }
+
+  // XXX FIXME XXX
+  boolMatrix any (void) const { return boolMatrix (); }
+
+  // XXX FIXME XXX
+  bool is_true (void) const { return false; }
+
+  static octave_value resize_fill_value (void) { return octave_value (); }
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,23 +1,227 @@
+2002-05-14  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* ov.h (octave_value::get_count): Now const.
+
+	* ov.h, ov.cc (octave_value::do_non_const_unary_op,
+	octave_value::assign): Idx is now a list of octave_value_list
+	objects.
+
+	* ov-base.cc, ov-base.h	(octave_base_value::do_struct_elt_index_op,
+	octave_base_value::struct_elt_ref): Delete.
+	* ov-struct.cc, ov-struct.h (octave_sruct::do_struct_elt_index_op,
+	octave_struct::struct_elt_ref): Delete.
+	* ov.cc, ov.h (octave_value::do_struct_elt_index_op,
+	octave_value::struct_elt_ref, octave_value::assign_struct_elt,
+	octave_value::convert_and_assign, octave_value::try_assignment,
+	octave_value::try_assignment_with_conversion,
+	octave_value::simple_assign): Delete.
+
+	* parse.y (make_index_expression): Type is now a single
+	character.  Change all callers.  If expr is already an index
+	expression, append index to it.
+	(make_indirect_ref): Likewise.
+
+	* pt-pr-code.cc (octave_print_internal (std::ostream&, const
+	Cell&, bool, int)): Now just a dummy function, panic if called.
+
+	* pt-idx.cc (tree_index_expression::make_arg_struct): New function.
+	(tree_index_expression::type): Delete enum, rename from itype, now
+	a string.
+	(tree_index_expression::arg_nm): Now a list of string_vector objects.
+	(tree_index_expression::idx): Now a list of tree_argument_list*
+	objects.
+	(tree_index_expression::is_index_expression): Always return true.
+	(tree_index_expression::apend, make_value_list, make_subs_cell):
+	New functions.
+	
+	* pt-pr-code.cc (visit_index_expression): Handle new definition of
+	tree_index_expression object.
+	* pt-check.cc (visit_index_expression): Likewise.
+	* pt-bp.cc (visit_index_expression): Likewise.
+
+	* ov-usr-fcn.h (octave_user_function::restore_args_passed):
+	Clear args_passed even if nothing was saved.
+
+	* ov-base.cc (octave_base_value::subsasgn,
+	octave_base_value::map_keys, octave_base_value::print_info):
+	New functions.
+
+	* ov.h, ov.cc (octave_value::map_keys, octave_value::print_info,
+	octave_value::subsref, octave_value::subsasgn,
+	octave_value::numeric_assign, octave_value::next_subsref):
+	New functions.
+	(octave_value::empty_conv): New static function.
+	(octave_value (octave_value *, int)): New arg, count.
+
+	* ov-base-mat.cc (octave_base_matrix<MT>::subsref,
+	octave_base_matrix<MT>::subsasgn): New functions.
+	* ov-base-mat.h: Provide decls.
+
+	* ov-builtin.cc (octave_builtin::subsref): New function.
+	* ov-builtin.h: Provide decl.
+
+	* ov-range.cc (octave_range::subsref): New function.
+	* ov-range.h: Provide decl.
+
+	* ov-cell.cc (octave_cell::subsref, octave_cell::subsasgn,
+	octave_cell::list_value, octave_cell::print,
+	octave_cell::print_raw, octave_cell::print_name_tag): New functions.
+	* ov-cell.h: Provide decls.
+
+	* ov-struct.cc (octave_struct::dotref, octave_struct::subsref,
+	octave_struct::subsasgn, gripe_invalid_index,
+	gripe_invalid_index_for_assignment, grip_invalid_index_type,
+	gripe_failed_assignment): New functions.
+	(octave_struct::numeric_conv): New static function.
+	* ov-struct.h: Provide decls.
+	(octave_struct::is_constant): Return true.
+	(octave_struct::map_keys): New function.
+
+	* ov-list.cc (octave_list::subsref, octave_list::subsasgn):
+	New functions.
+	* ov-list.h: Provide decls.
+
+	* ov-usr-fcn.cc (octave_user_function::subsref,
+	octave_user_function::print_symtab_info): New functions.
+	* ov-usr-fcn.h: Provide decl.
+
+	* ov-mapper.cc (octave_mapper::subsref): New function.
+	* ov-mapper.h: Provide decl.
+
+	* ov-base.cc (octave_base_value::subsref,
+	octave_base_value::subsasgn): New functions.
+	* ov-base.h: Provide decls.
+
+	* ov-base.cc (octave_base_value::do_index_op): New arg, resize_ok.
+	* ov-base-mat.cc (octave_base_matrix<MT>::do_index_op): Likewise.
+	* ov-base-nd-array.cc (octave_base_nd_array<AT>::do_index_op): Ditto.
+	* ov-bool-mat.cc (octave_bool::do_index_op): Ditto.
+	* ov-str-mat.cc (octave_char_matrix_str::do_index_op): Ditto.
+	* ov-range.cc (octave_range::do_index_op): Ditto.
+	* ov-list.cc (octave_list::do_index_op): Ditto.
+	* ov.cc (octave_value::do_index_op): Ditto.
+	
+	* ov-base-mat.cc (octave_base_matrix<MT>::print_info): New function.
+
+	* ov-base-mat.h (octave_base_matrix<MT>::empty_clone): New function.
+	* ov-base-nd-array.h (octave_base_nd_array<AT>::empty_clone): Ditto.
+	* ov-base.h (octave_base_value::empty_clone): Ditto.
+	* ov-bool-mat.h (octave_bool::empty_clone): Ditto.
+	* ov-ch-mat.h (octave_char_matrix::empty_clone): Likewise.
+	* ov-colon.h (octave_magic_colon::empty_clone): Likewise.
+	* ov-complex.h (octave_complex::empty_clone): Likewise.
+	* ov-cx-mat.h (octave_complex_matrix::empty_clone): Likewise.
+	* ov-fcn.cc (octave_function::empty_clone): Likewise.
+	* ov-file.h (octave_file::empty_clone): Likewise.
+	* ov-range.h (octave_range::empty_clone): Likewise.
+	* ov-list.h (octave_list::empty_clone): Likewise.
+	* ov-re-mat.h (octave_matrix::empty_clone): Likewise.
+	* ov-re-nd-array.h (octave_double_nd_array::empty_clone): Likewise.
+	* ov-str-mat.h (octave_char_matrix_str::empty_clone): Likewise.
+	* ov-struct.h (octave_struct::empty_clone): Likewise.
+	* ov-va_args.h (octave_all_va_args::empty_clone): Likewise.
+	* ov.h (octave_value::empty_clone): Likewise.
+
+	* ov-base-mat.h (octave_base_matrix<MT>::clone): Now const.
+	* ov-base-nd-array.h (octave_base_nd_array<AT>::clone): Likewise.
+	* ov-base.h (octave_base_value::clone): Likewise.
+	* ov-bool-mat.h (octave_bool::clone): Likewise.
+	* ov-ch-mat.h (octave_char_matrix::clone): Likewise.
+	* ov-colon.h (octave_magic_colon::clone): Likewise.
+	* ov-complex.h (octave_complex::clone): Likewise.
+	* ov-cx-mat.h (octave_complex_matrix::clone): Likewise.
+	* ov-fcn.h (octave_function::clone): Likewise.
+	* ov-file.h (octave_file::clone): Likewise.
+	* ov-range.h (octave_range::clone): Likewise.
+	* ov-list.h (octave_list::clone): Likewise.
+	* ov-re-mat.h (octave_matrix::clone): Likewise.
+	* ov-re-nd-array.h (octave_double_nd_array::clone): Likewise.
+	* ov-str-mat.h (octave_char_matrix_str::clone): Likewise.
+	* ov-struct.h (octave_struct::clone): Likewise.
+	* ov-va_args.h (octave_all_va_args::clone): Likewise.
+	* ov.h (octave_value::clone): Likewise.
+
+	* oct-lvalue.cc (octave_lvalue::assign, octave_lvalue::set_index,
+	octave_lvalue::do_unary_op): Idx is now a list of indices.  Simplify.
+	* oct-lvalue.h (octave_lvalue::value): Simplify.
+	(octave_lvalue::struct_elt_names): Delete data member.
+	(octave_lvalue::type): Now string
+	Update decls.
+
+	* pt-exp.h (tree_expression::is_indirect_ref):
+	Delete virtual function.
+
+	* pt-plot.cc (subplot::extract_plot_data): Use subsref, instead of
+	do_index_op.
+
+	* pt-stmt.cc (tree_statement::eval): Don't try to avoid binding
+	ans for structure references.
+
+	* symtab.cc (symbol_record::symbol_def::print_info): Rename from
+	symbol_record::symbol_def::dump_symbol_info.
+	(symbol_record::print_info): Rename from
+	symbol_record::dump_symbol_info.  Now const..
+	(symbol_record::print_symbol_info_line): Now const.
+	(symbol_table::print_info): Rename from print_stats.  Accept
+	ostream arg.  Now const.  Print more info.
+	* symtab.h: Update decls.
+
+	* toplev.cc (octave_config_info): Indexing a map now returns a
+	list, but we only want to return the first element.
+
+	* variables.cc (generate_struct_completions, looks_like_struct):
+	Simplify using eval_string.
+	(F__print_symtab_info__): Rename from F__dump_symtab_info__.
+	Handle "top-level" and individual function names in addition to
+	"global".
+	(F__print_symbol_info__): Rename from F___dump_symbol_info__.
+
+	* octave.cc (intern_argv): Built-in variable argv is now a cell array.
+
+	* ov-complex.cc (valid_scalar_indices): Delete.
+	* ov-scalar.cc (valid_scalar_indices): Delete.
+
+	* oct-obj.cc (octave_value_list::valid_scalar_indices): New function.
+	(octave_value_list::index): New arg, resize_ok.
+	* oct-obj.h: Provide decls.
+
+	* oct-map.cc (Octave_map::keys): Rename from make_name_list.
+	Change all uses.
+	(Octave_map::assign, Octave_map::index): New functions.
+	* oct-map.h: Provide decls.
+
+	* data.cc (Fstruct_contains): Use map_value instead of
+	do_struct_elt_index_op.
+
+	* Cell.h (Cell (const Array2<octave_value>&, int, int)):
+	New constructor.
+	(Cell::resize_fill_value): New static function.
+
+	* input.cc (initialize_command_input): Set basic and completer
+	word break characters.
+
 2002-05-07  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* ov.h (octave_value::subsref): New function.
+	* ov-base.cc (octave_base_value::subsref): Likewise.
+
 	* ov-struct.cc (octave_struct::print_raw): Print scalar struct
 	arrays more compactly.
 
 	* DLD-FUNCTIONS/time.cc (extract_tm): Handle new struct array def.
 
 	* oct-map.cc (Octave_map::array_len): New data member.
 	(Octave_map::operator[], Octave_map::contsnts): Return
 	octave_value_list, not Octave_value.  Change callers as necessary.
 	(Octave_map::assign): New function.
 	(Octave_map::array_length): New fucntion.
 	* oct-obj.cc (octave_value_list::assign): New function.
 	
-
 2002-05-06  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* TEMPLATE-INST/Map-oct-obj.cc: New file.
 	* Makefile.in (TI_XSRC): Add it to the list.
 
 	* oct-map.h (Octave_map): Make CHMap<octave_value_list> a data
 	member instead of deriving from CHMap<octave_value>, in
 	preparation for structure arrays.
diff --git a/src/Map.h b/src/Map.h
--- a/src/Map.h
+++ b/src/Map.h
@@ -70,17 +70,17 @@ public:
   int length (void) const { return count; }	// current number of items
   int empty (void) const { return count == 0; }
 
   virtual int contains (const std::string& key) const;  // is key mapped?
 
   virtual void clear (void);			// delete all items
 	      
   virtual C& operator [] (const std::string& key) = 0;  // access contents by key
-	      
+
   virtual void del (const std::string& key) = 0;	// delete entry
 	      
   virtual Pix first (void) const = 0;		// Pix of first item or 0
   virtual void next (Pix& i) const = 0;		// advance to next or 0
   virtual std::string key (Pix i) const = 0;		// access key at i
   virtual C& contents (Pix i) const = 0;	// access contents at i
 
   virtual int owns (Pix i) const;		// is i a valid Pix  ?
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -844,17 +844,17 @@ argument that is not a structure.\n\
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       if (args (0).is_map ())
 	{
 	  Octave_map m = args(0).map_value ();
-	  retval(0) = m.make_name_list ();
+	  retval(0) = m.keys ();
 	}
       else
 	gripe_wrong_type_arg ("struct_elements", args (0));
     }
   else
     print_usage ("struct_elements");
 
   return retval;
@@ -876,19 +876,21 @@ the second must be a string.\n\
     {
       retval = 0.0;
 
       // XXX FIXME XXX -- should this work for all types that can do
       // structure reference operations?
 
       if (args(0).is_map () && args(1).is_string ())
 	{
-	  std::string s = args(1).string_value ();
-	  octave_value tmp = args(0).do_struct_elt_index_op (s, true);
-	  retval = static_cast<double> (tmp.is_defined ());
+	  std::string key = args(1).string_value ();
+
+	  Octave_map m = args(0).map_value ();
+
+	  retval = static_cast<double> (m.contains (key));
 	}
       else
 	print_usage ("struct_contains");
     }
   else
     print_usage ("struct_contains");
 
   return retval;
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -471,16 +471,25 @@ generate_completion (const std::string& 
 void
 initialize_command_input (void)
 {
   // If we are using readline, this allows conditional parsing of the
   // .inputrc file.
 
   command_editor::set_name ("Octave");
 
+  // XX FIXME XXX -- this needs to include a comma too, but that
+  // causes trouble for the new struct element completion code.
+
+  static char *s = "\t\n !\"\'*+-/:;<=>[\\]^`~";
+
+  command_editor::set_basic_word_break_characters (s);
+
+  command_editor::set_completer_word_break_characters (s);
+
   command_editor::set_basic_quote_characters ("\"");
 
   command_editor::set_completion_function (generate_completion);
 }
 
 static bool
 match_sans_spaces (const std::string& standard, const std::string& test)
 {
diff --git a/src/oct-lvalue.cc b/src/oct-lvalue.cc
--- a/src/oct-lvalue.cc
+++ b/src/oct-lvalue.cc
@@ -27,68 +27,46 @@ Software Foundation, 59 Temple Place - S
 #include "error.h"
 #include "oct-obj.h"
 #include "oct-lvalue.h"
 #include "ov.h"
 
 void
 octave_lvalue::assign (octave_value::assign_op op, const octave_value& rhs)
 {
-  octave_value saved_val;
-
-  if (chg_fcn)
-    saved_val = *val;
+  octave_value tmp (idx.empty ()
+		    ? val->assign (op, rhs)
+		    : val->assign (op, type, idx, rhs));
 
-  if (idx.empty ())
-    {
-      if (struct_elt_name.empty ())
-	val->assign (op, rhs);
-      else
-	val->assign_struct_elt (op, struct_elt_name, rhs);
-    }
-  else
-    {
-      if (struct_elt_name.empty ())
-	val->assign (op, idx, rhs);
-      else
-	val->assign_struct_elt (op, struct_elt_name, idx, rhs);
-    }
-
-  if (chg_fcn && ! error_state && chg_fcn () < 0)
-    *val = saved_val;
+  if (! (error_state || chg_fcn && chg_fcn () < 0))
+    *val = tmp;
 }
 
 void
-octave_lvalue::set_index (const octave_value_list& i,
-			  tree_index_expression::type t)
+octave_lvalue::set_index (const std::string& t,
+			  const SLList<octave_value_list>& i)
 {
   if (! index_set)
     {
+      type = t;
       idx = i;
-      itype = t;
       index_set = true;
     }
   else
     error ("invalid index expression in assignment");
 }
 
 void
 octave_lvalue::do_unary_op (octave_value::unary_op op)
 {
-  octave_value saved_val;
-
-  if (chg_fcn)
-    saved_val = *val;
+  octave_value tmp (idx.empty ()
+		    ? val->do_non_const_unary_op (op)
+		    : val->do_non_const_unary_op (op, type, idx));
 
-  if (idx.empty ())
-    val->do_non_const_unary_op (op);
-  else
-    val->do_non_const_unary_op (op, idx);
-
-  if (chg_fcn && ! error_state && chg_fcn () < 0)
-    *val = saved_val;
+  if (! (error_state || chg_fcn && chg_fcn () < 0))
+    *val = tmp;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/oct-lvalue.h b/src/oct-lvalue.h
--- a/src/oct-lvalue.h
+++ b/src/oct-lvalue.h
@@ -23,51 +23,48 @@ Software Foundation, 59 Temple Place - S
 #if !defined (octave_lvalue_h)
 #define octave_lvalue_h 1
 
 class octave_value;
 class octave_value_list;
 
 #include <string>
 
+#include "SLList.h"
+
 #include "oct-obj.h"
 #include "pt-idx.h"
 #include "symtab.h"
 
 // XXX FIXME XXX -- eliminate the following kluge?
 
 // This variable is used when creating dummy octave_lvalue objects.
 static octave_value dummy_val;
 
 class
 octave_lvalue
 {
 public:
 
   octave_lvalue (octave_value *v = &dummy_val,
 		 symbol_record::change_function f = 0)
-    : val (v), idx (), chg_fcn (f), struct_elt_name (), index_set (false) { }
-
-  octave_lvalue (octave_value *v, const std::string& nm,
-		 symbol_record::change_function f = 0)
-    : val (v), idx (), chg_fcn (f), struct_elt_name (nm), index_set (false) { }
+    : val (v), type (), idx (), chg_fcn (f), index_set (false) { }
 
   octave_lvalue (const octave_lvalue& vr)
-    : val (vr.val), idx (vr.idx), itype (vr.itype), chg_fcn (vr.chg_fcn),
-      struct_elt_name (vr.struct_elt_name), index_set (vr.index_set) { }
+    : val (vr.val), type (vr.type), idx (vr.idx), chg_fcn (vr.chg_fcn),
+      index_set (vr.index_set) { }
 
   octave_lvalue& operator = (const octave_lvalue& vr)
     {
       if (this != &vr)
 	{
 	  val = vr.val;
+	  type = vr.type;
 	  idx = vr.idx;
-	  itype = vr.itype;
 	  chg_fcn = vr.chg_fcn;
-	  struct_elt_name = vr.struct_elt_name;
 	  index_set = vr.index_set;
 	}
 
       return *this;
     }
 
   ~octave_lvalue (void) { }
 
@@ -76,53 +73,35 @@ public:
   bool is_undefined (void) { return val->is_undefined (); }
 
   bool is_map (void) { return val->is_map (); }
 
   void define (const octave_value& v) { *val = v; }
 
   void assign (octave_value::assign_op, const octave_value&);
 
-  octave_lvalue struct_elt_ref (const std::string& nm)
-    {
-      val->make_unique ();
-      return val->struct_elt_ref (nm);
-    }
+  void set_index (const std::string& t, const SLList<octave_value_list>& i);
 
-  void set_index (const octave_value_list& i,
-		  tree_index_expression::type t
-		    = tree_index_expression::unknown);
-
-  void clear_index (void) { idx = octave_value_list (); }
+  void clear_index (void) { type = std::string (); idx.clear (); }
 
   void do_unary_op (octave_value::unary_op op);
 
   octave_value value (void)
-    {
-      return struct_elt_name.empty ()
-	? (idx.empty ()
-	   ? *val
-	   : val->do_index_op (idx))
-	: (idx.empty ()
-	   ? val->do_struct_elt_index_op (struct_elt_name)
-	   : val->do_struct_elt_index_op (struct_elt_name, idx));
-    }
+    { return idx.empty () ? *val : val->subsref (type, idx); }
 
 private:
 
   octave_value *val;
 
-  octave_value_list idx;
+  std::string type;
 
-  tree_index_expression::type itype;
+  SLList<octave_value_list> idx;
 
   symbol_record::change_function chg_fcn;
 
-  std::string struct_elt_name;
-
   bool index_set;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/oct-map.cc b/src/oct-map.cc
--- a/src/oct-map.cc
+++ b/src/oct-map.cc
@@ -30,17 +30,17 @@ Software Foundation, 59 Temple Place - S
 
 #include "error.h"
 #include "str-vec.h"
 
 #include "oct-map.h"
 #include "utils.h"
 
 string_vector
-Octave_map::make_name_list (void)
+Octave_map::keys (void) const
 {
   int len = length ();
 
   string_vector names (len);
 
   int i = 0;
   for (Pix p = first (); p != 0; next (p))
     names[i++] = key (p);
@@ -82,13 +82,49 @@ Octave_map::assign (const idx_vector& id
 	}
 
       map[key] = tmp;
     }
 
   return *this;
 }
 
+Octave_map&
+Octave_map::assign (const std::string& key, const octave_value_list& rhs)
+{
+  if (map.empty ())
+    map[key] = rhs;
+  else
+    {
+      octave_value_list tmp = map.contents (map.first ());
+
+      if (tmp.length () == rhs.length ())
+	map[key] = rhs;
+      else
+	error ("invalid structure assignment");
+    }
+
+  return *this;
+}
+
+Octave_map
+Octave_map::index (idx_vector& idx)
+{
+  Octave_map retval;
+
+  for (Pix p = first (); p != 0; next (p))
+    {
+      octave_value_list tmp = contents(p).index (idx);
+
+      if (error_state)
+	break;
+
+      retval[key(p)] = tmp;
+    }
+
+  return error_state ? Octave_map () : retval;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/oct-map.h b/src/oct-map.h
--- a/src/oct-map.h
+++ b/src/oct-map.h
@@ -77,23 +77,27 @@ Octave_map
   octave_value_list& contents (Pix p) const { return map.contents (p); }
 
   Pix seek (const std::string& key) const { return map.seek (key); }
 
   int contains (const std::string& key) const { return map.contains (key); }
 
   void clear (void) { map.clear (); }
 
-  string_vector make_name_list (void);
+  string_vector keys (void) const;
 
   int array_length () const;
 
   Octave_map& assign (const idx_vector& idx, const std::string& key,
 		      const octave_value_list& rhs);
 
+  Octave_map& assign (const std::string& key, const octave_value_list& rhs);
+
+  Octave_map index (idx_vector& idx);
+
 private:
 
   // The map of names to values.
   CHMap<octave_value_list> map;
 
   // The current size of this struct array;
   mutable int array_len;
 };
diff --git a/src/oct-obj.cc b/src/oct-obj.cc
--- a/src/oct-obj.cc
+++ b/src/oct-obj.cc
@@ -29,16 +29,28 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "error.h"
 #include "oct-obj.h"
 
 octave_allocator
 octave_value_list::allocator (sizeof (octave_value_list));
 
+bool
+octave_value_list::valid_scalar_indices (void) const
+{
+  int n = data.length ();
+
+  for (int i = 0; i < n; i++)
+    if (! data(i).valid_as_scalar_index ())
+      return false;
+
+  return true;
+}
+
 octave_value_list&
 octave_value_list::prepend (const octave_value& val)
 {
   int n = length ();
 
   resize (n + 1);
 
   while (n > 0)
@@ -132,19 +144,19 @@ octave_value_list::splice (int offset, i
 
   for (int i = offset + rep_length; i < len; i++)
     retval(k++) = elem (i);
 
   return retval;
 }
 
 octave_value_list
-octave_value_list::index (idx_vector& i) const
+octave_value_list::index (idx_vector& i, int resize_ok) const
 {
-  return octave_value_list (data.index (i));
+  return octave_value_list (data.index (i, resize_ok, octave_value ()));
 }
 
 octave_value_list&
 octave_value_list::assign (const idx_vector& i,
 			   const octave_value_list& rhs)
 {
   data.set_index (i);
   ::assign (data, rhs.data);
diff --git a/src/oct-obj.h b/src/oct-obj.h
--- a/src/oct-obj.h
+++ b/src/oct-obj.h
@@ -106,16 +106,18 @@ public:
   octave_value_list& operator = (const octave_value_list& obj)
     {
       if (this != &obj)
 	data = obj.data;
 
       return *this;
     }
 
+  bool valid_scalar_indices (void) const;
+
   // Assignment will resize on range errors.
 
   octave_value& operator () (int n) { return elem (n); }
 
   octave_value operator () (int n) const { return elem (n); }
 
   int length (void) const { return data.length (); }
 
@@ -131,17 +133,17 @@ public:
 
   octave_value_list& append (const octave_value_list& lst);
 
   octave_value_list& reverse (void);
 
   octave_value_list splice (int offset, int length,
 			    const octave_value_list& lst) const;
 
-  octave_value_list index (idx_vector& i) const;
+  octave_value_list index (idx_vector& i, int resize_ok = 0) const;
 
   octave_value_list& assign (const idx_vector& i,
 			     const octave_value_list& rhs);
 
   bool all_strings_p (void) const;
 
   string_vector make_argv (const std::string&) const;
 
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -46,16 +46,17 @@ Software Foundation, 59 Temple Place - S
 #include "f77-fcn.h"
 #include "file-stat.h"
 #include "lo-error.h"
 #include "oct-env.h"
 #include "pathsearch.h"
 #include "str-vec.h"
 
 #include <defaults.h>
+#include "Cell.h"
 #include "defun.h"
 #include "error.h"
 #include "file-io.h"
 #include "input.h"
 #include "lex.h"
 #include "oct-hist.h"
 #include "oct-obj.h"
 #include "ops.h"
@@ -154,24 +155,28 @@ long_options long_opts[] =
 // Store the command-line options for later use.
 
 static void
 intern_argv (int argc, char **argv)
 {
   bind_builtin_variable ("nargin", static_cast<double> (argc-1),
 			 true, true, 0);
 
-  octave_value_list octave_argv;
+  Cell octave_argv;
 
   if (argc > 1)
     {
+      Array<octave_value> tmp (argc-1);
+
       // Skip program name in argv.
-      while (--argc > 0)
-	octave_argv(argc-1) = octave_value (*(argv+argc));
+      int i = argc;
+      while (--i > 0)
+	tmp(i-1) = octave_value (*(argv+i));
 
+      octave_argv = Cell (tmp, argc-1, 1);
     }
 
   bind_builtin_constant ("argv", octave_argv, true, true);
   bind_builtin_constant ("__argv__", octave_argv, true, true);
 }
 
 static void
 initialize_pathsearch (void)
diff --git a/src/ov-base-mat.cc b/src/ov-base-mat.cc
--- a/src/ov-base-mat.cc
+++ b/src/ov-base-mat.cc
@@ -25,45 +25,114 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
 
+#include "Cell.h"
 #include "oct-obj.h"
+#include "oct-map.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "pr-output.h"
 
 template <class MT>
 octave_value
-octave_base_matrix<MT>::do_index_op (const octave_value_list& idx)
+octave_base_matrix<MT>::subsref (const std::string type,
+				 const SLList<octave_value_list>& idx)
+{
+  octave_value retval;
+
+  switch (type[0])
+    {
+    case '(':
+      retval = do_index_op (idx.front ());
+      break;
+
+    case '{':
+    case '.':
+      {
+	std::string nm = type_name ();
+	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+      }
+      break;
+
+    default:
+      panic_impossible ();
+    }
+
+  return retval.next_subsref (type, idx);
+}
+
+template <class MT>
+octave_value
+octave_base_matrix<MT>::subsasgn (const std::string type,
+				  const SLList<octave_value_list>& idx,
+				  const octave_value& rhs)
+{
+  octave_value retval;
+
+  switch (type[0])
+    {
+    case '(':
+      {
+	if (type.length () == 1)
+	  retval = numeric_assign (type, idx, rhs);
+	else
+	  {
+	    std::string nm = type_name ();
+	    error ("in indexed assignment of %s, last rhs index must be ()",
+		   nm.c_str ());
+	  }
+      }
+      break;
+
+    case '{':
+    case '.':
+      {
+	std::string nm = type_name ();
+	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+      }
+      break;
+
+    default:
+      panic_impossible ();
+    }
+
+  return retval;
+}
+
+template <class MT>
+octave_value
+octave_base_matrix<MT>::do_index_op (const octave_value_list& idx,
+				     int resize_ok)
 {
   octave_value retval;
 
   int len = idx.length ();
 
   switch (len)
     {
     case 2:
       {
 	idx_vector i = idx (0).index_vector ();
 	idx_vector j = idx (1).index_vector ();
 
-	retval = MT (matrix.index (i, j));
+	retval = MT (matrix.index (i, j, resize_ok, MT::resize_fill_value ()));
       }
       break;
 
     case 1:
       {
 	idx_vector i = idx (0).index_vector ();
 
-	retval = MT (matrix.index (i));
+	retval = MT (matrix.index (i, resize_ok, MT::resize_fill_value ()));
       }
       break;
 
     default:
       {
 	std::string n = type_name ();
 
 	error ("invalid number of indices (%d) for %s value",
@@ -157,25 +226,27 @@ void
 octave_base_matrix<MT>::print (std::ostream& os, bool pr_as_read_syntax) const
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 
 template <class MT>
 void
-octave_base_matrix<MT>::print_raw (std::ostream& os, bool pr_as_read_syntax) const
+octave_base_matrix<MT>::print_raw (std::ostream& os,
+				   bool pr_as_read_syntax) const
 {
   octave_print_internal (os, matrix, pr_as_read_syntax,
 			 current_print_indent_level ());
 }
 
 template <class MT>
 bool
-octave_base_matrix<MT>::print_name_tag (std::ostream& os, const std::string& name) const
+octave_base_matrix<MT>::print_name_tag (std::ostream& os,
+					const std::string& name) const
 {
   bool retval = false;
 
   indent (os);
 
   if (print_as_scalar ())
     os << name << " = ";
   else
@@ -184,13 +255,21 @@ octave_base_matrix<MT>::print_name_tag (
       newline (os);
       newline (os);
       retval = true;
     }
 
   return retval;
 }
 
+template <class MT>
+void
+octave_base_matrix<MT>::print_info (std::ostream& os,
+				    const std::string& prefix) const
+{
+  matrix.print_info (os, prefix);
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-base-mat.h b/src/ov-base-mat.h
--- a/src/ov-base-mat.h
+++ b/src/ov-base-mat.h
@@ -58,19 +58,30 @@ public:
   octave_base_matrix (const MT& m)
     : octave_base_value (), matrix (m) { }
 
   octave_base_matrix (const octave_base_matrix& m)
     : octave_base_value (), matrix (m.matrix) { }
 
   ~octave_base_matrix (void) { }
 
-  octave_value *clone (void) { return new octave_base_matrix (*this); }
+  octave_value *clone (void) const { return new octave_base_matrix (*this); }
+  octave_value *empty_clone (void) const { return new octave_base_matrix (); }
+
+  octave_value subsref (const std::string type,
+			const SLList<octave_value_list>& idx);
 
-  octave_value do_index_op (const octave_value_list& idx);
+  octave_value subsasgn (const std::string type,
+			 const SLList<octave_value_list>& idx,
+			 const octave_value& rhs);
+
+  octave_value do_index_op (const octave_value_list& idx, int resize_ok);
+
+  octave_value do_index_op (const octave_value_list& idx)
+    { return do_index_op (idx, 0); }
 
   void assign (const octave_value_list& idx, const MT& rhs);
 
   int rows (void) const { return matrix.rows (); }
   int columns (void) const { return matrix.columns (); }
 
   int length (void) const
   {
@@ -96,16 +107,18 @@ public:
   virtual bool print_as_scalar (void) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool print_name_tag (std::ostream& os, const std::string& name) const;
 
+  void print_info (std::ostream& os, const std::string& prefix) const;
+
 protected:
 
   MT matrix;
 };
 
 #endif
 
 /*
diff --git a/src/ov-base-nd-array.cc b/src/ov-base-nd-array.cc
--- a/src/ov-base-nd-array.cc
+++ b/src/ov-base-nd-array.cc
@@ -45,35 +45,36 @@ idx_list_to_idx_array (const octave_valu
   for (int i = 0; i < n; i++)
     retval(i) = idx(i).index_vector ();
 
   return retval;
 }
 
 template <class AT>
 octave_value
-octave_base_nd_array<AT>::do_index_op (const octave_value_list& idx)
+octave_base_nd_array<AT>::do_index_op (const octave_value_list& idx,
+				       int resize_ok)
 {
   octave_value retval;
 
   int len = idx.length ();
 
   if (len > 1)
     {
       Array<idx_vector> i = idx_list_to_idx_array (idx);
 
       retval
-	= octave_value (new octave_base_nd_array<AT> (AT (array.index (i))));
+	= octave_value (new octave_base_nd_array<AT> (AT (array.index (i, resize_ok))));
     }
   else if (len == 1)
     {
       idx_vector i = idx(0).index_vector ();
 
       retval
-	= octave_value (new octave_base_nd_array<AT> (AT (array.index (i))));
+	= octave_value (new octave_base_nd_array<AT> (AT (array.index (i, resize_ok))));
     }
   else
     {
       std::string n = type_name ();
 
       error ("invalid number of indices (%d) for %s value",
 	     len, n.c_str ());
     }
diff --git a/src/ov-base-nd-array.h b/src/ov-base-nd-array.h
--- a/src/ov-base-nd-array.h
+++ b/src/ov-base-nd-array.h
@@ -58,19 +58,20 @@ public:
   octave_base_nd_array (const AT& a)
     : octave_base_value (), array (a) { }
 
   octave_base_nd_array (const octave_base_nd_array& a)
     : octave_base_value (), array (a.array) { }
 
   ~octave_base_nd_array (void) { }
 
-  octave_value *clone (void) { return new octave_base_nd_array (*this); }
+  octave_value *clone (void) const { return new octave_base_nd_array (*this); }
+  octave_value *empty_clone (void) const { return new octave_base_nd_array (); }
 
-  octave_value do_index_op (const octave_value_list& idx);
+  octave_value do_index_op (const octave_value_list& idx, int resize_ok);
 
   bool is_matrix_type (void) const { return false; }
 
   bool is_numeric_type (void) const { return true; }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
diff --git a/src/ov-base-scalar.cc b/src/ov-base-scalar.cc
--- a/src/ov-base-scalar.cc
+++ b/src/ov-base-scalar.cc
@@ -26,38 +26,115 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
 
 #include "ov-base.h"
+#include "ov-cx-mat.h"
+#include "ov-re-mat.h"
 #include "ov-base-scalar.h"
 #include "pr-output.h"
 
 template <class ST>
+octave_value
+octave_base_scalar<ST>::subsref (const std::string type,
+				 const SLList<octave_value_list>& idx)
+{
+  octave_value retval;
+
+  switch (type[0])
+    {
+    case '(':
+      retval = do_index_op (idx.front ());
+      break;
+
+    case '{':
+    case '.':
+      {
+	std::string nm = type_name ();
+	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+      }
+      break;
+
+    default:
+      panic_impossible ();
+    }
+
+  return retval.next_subsref (type, idx);
+}
+
+template <class ST>
+octave_value
+octave_base_scalar<ST>::subsasgn (const std::string type,
+				  const SLList<octave_value_list>& idx,
+				  const octave_value& rhs)
+{
+  octave_value retval;
+
+  switch (type[0])
+    {
+    case '(':
+      {
+	if (type.length () == 1)
+	  {
+	    if (idx.front().valid_scalar_indices ()
+		&& rhs.is_scalar_type ()
+		&& rhs.is_numeric_type ())
+	      retval = rhs;
+	    else
+	      retval = numeric_assign (type, idx, rhs);
+	  }
+	else
+	  {
+	    std::string nm = type_name ();
+	    error ("in indexed assignment of %s, last rhs index must be ()",
+		   nm.c_str ());
+	  }
+      }
+      break;
+
+    case '{':
+    case '.':
+      {
+	std::string nm = type_name ();
+	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+      }
+      break;
+
+    default:
+      panic_impossible ();
+    }
+
+  return retval;
+}
+
+template <class ST>
 void
 octave_base_scalar<ST>::print (std::ostream& os, bool pr_as_read_syntax) const
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 
 template <class ST>
 void
-octave_base_scalar<ST>::print_raw (std::ostream& os, bool pr_as_read_syntax) const
+octave_base_scalar<ST>::print_raw (std::ostream& os,
+				   bool pr_as_read_syntax) const
 {
   indent (os);
   octave_print_internal (os, scalar, pr_as_read_syntax);
 }
 
 template <class ST>
 bool
-octave_base_scalar<ST>::print_name_tag (std::ostream& os, const std::string& name) const
+octave_base_scalar<ST>::print_name_tag (std::ostream& os,
+					const std::string& name) const
 {
   indent (os);
   os << name << " = ";
   return false;    
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/ov-base-scalar.h b/src/ov-base-scalar.h
--- a/src/ov-base-scalar.h
+++ b/src/ov-base-scalar.h
@@ -54,16 +54,23 @@ public:
   octave_base_scalar (const ST& s)
     : octave_base_value (), scalar (s) { }
 
   octave_base_scalar (const octave_base_scalar& s)
     : octave_base_value (), scalar (s.scalar) { }
 
   ~octave_base_scalar (void) { }
 
+  octave_value subsref (const std::string type,
+			const SLList<octave_value_list>& idx);
+
+  octave_value subsasgn (const std::string type,
+			 const SLList<octave_value_list>& idx,
+			 const octave_value& rhs);
+
   int rows (void) const { return 1; }
 
   int columns (void) const { return 1; }
 
   int length (void) const { return 1; }
 
   bool is_constant (void) const { return true; }
 
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -48,17 +48,35 @@ Software Foundation, 59 Temple Place - S
 #include "ov-re-mat.h"
 #include "ov-scalar.h"
 #include "ov-str-mat.h"
 #include "variables.h"
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_base_value, "<unknown type>");
 
 octave_value
-octave_base_value::do_index_op (const octave_value_list&)
+octave_base_value::subsref (const std::string,
+			    const SLList<octave_value_list>&)
+{
+  std::string nm = type_name ();
+  error ("can't perform indexing operations for %s type", nm.c_str ());
+  return octave_value ();
+}
+
+octave_value_list
+octave_base_value::subsref (const std::string,
+			    const SLList<octave_value_list>&, int)
+{
+  std::string nm = type_name ();
+  error ("can't perform indexing operations for %s type", nm.c_str ());
+  return octave_value ();
+}
+
+octave_value
+octave_base_value::do_index_op (const octave_value_list&, int)
 {
   std::string nm = type_name ();
   error ("can't perform indexing operations for %s type", nm.c_str ());
   return octave_value ();
 }
 
 octave_value_list
 octave_base_value::do_multi_index_op (int, const octave_value_list&)
@@ -72,42 +90,38 @@ idx_vector
 octave_base_value::index_vector (void) const
 {
   std::string nm = type_name ();
   error ("%s type invalid as index value", nm.c_str ());
   return idx_vector ();
 }
 
 octave_value
-octave_base_value::do_struct_elt_index_op (const std::string&,
-					   const octave_value_list&,
-					   bool)
-{
-  std::string nm = type_name ();
-  error ("can't perform indexed structure reference operations for %s type",
-	 nm.c_str ());
-  return octave_value ();
-}
-
-octave_value
-octave_base_value::do_struct_elt_index_op (const std::string&, bool)
+octave_base_value::subsasgn (const std::string type,
+			     const SLList<octave_value_list>& idx,
+			     const octave_value& rhs)
 {
-  std::string nm = type_name ();
-  error ("can't perform structure reference operations for %s type",
-	 nm.c_str ());
-  return octave_value ();
-}
+  octave_value retval;
 
-octave_lvalue
-octave_base_value::struct_elt_ref (octave_value *, const std::string&)
-{
-  std::string nm = type_name ();
-  error ("can't perform structure reference operations for %s type",
-	 nm.c_str ());
-  return octave_lvalue ();
+  if (is_defined ())
+    {
+      std::string nm = type_name ();
+      error ("can't perform indexed assignment for %s type", nm.c_str ());
+    }
+  else
+    {
+      // Create new object of appropriate type for given index and rhs
+      // types and then call subsasgn again for that object.
+
+      octave_value tmp = octave_value::empty_conv (type, rhs);
+
+      retval = tmp.subsasgn (type, idx, rhs);
+    }
+
+  return retval;
 }
 
 octave_value
 octave_base_value::convert_to_str (void) const
 {
   gripe_wrong_type_arg ("octave_base_value::convert_to_str ()",
 			type_name ());
   return octave_value ();
@@ -138,16 +152,23 @@ octave_base_value::print_name_tag (std::
 {
   indent (os);
   os << name << " =";
   newline (os);
   newline (os);
   return true;
 }
 
+void
+octave_base_value::print_info (std::ostream& os,
+			       const std::string& prefix) const
+{
+  os << "no info for type: " << type_name () << "\n";
+}
+
 int
 octave_base_value::int_value (bool require_int, bool frc_str_conv) const
 {
   int retval = 0;
 
   double d = double_value (frc_str_conv);
 
   if (! error_state)
@@ -266,16 +287,24 @@ octave_base_value::range_value (void) co
 Octave_map
 octave_base_value::map_value (void) const
 {
   Octave_map retval;
   gripe_wrong_type_arg ("octave_base_value::map_value()", type_name ());
   return retval;
 }
 
+string_vector
+octave_base_value::map_keys (void) const
+{
+  string_vector retval;
+  gripe_wrong_type_arg ("octave_base_value::map_keys()", type_name ());
+  return retval;
+}
+
 octave_stream
 octave_base_value::stream_value (void) const
 {
   octave_stream retval;
   gripe_wrong_type_arg ("octave_base_value::stream_value()", type_name ());
   return retval;
 }
 
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -57,38 +57,45 @@ public:
   octave_base_value (void)
     : octave_value (octave_xvalue ()) { }
 
   octave_base_value (const octave_base_value&)
     : octave_value (octave_xvalue ()) { }
 
   ~octave_base_value (void) { }
 
-  octave_value *clone (void) { return new octave_base_value (*this); }
+  octave_value *clone (void) const { return new octave_base_value (*this); }
+  octave_value *empty_clone (void) const { return new octave_base_value (); }
 
   type_conv_fcn numeric_conversion_function (void) const
     { return static_cast<type_conv_fcn> (0); }
 
   octave_value *try_narrowing_conversion (void)
     { return static_cast<octave_value *> (0); }
 
-  octave_value do_index_op (const octave_value_list& idx);
+  octave_value subsref (const std::string type,
+			const SLList<octave_value_list>& idx);
+
+  octave_value_list subsref (const std::string type,
+			     const SLList<octave_value_list>& idx,
+			     int nargout);
+
+  octave_value do_index_op (const octave_value_list& idx, int resize_ok);
+
+  octave_value do_index_op (const octave_value_list& idx)
+    { return do_index_op (idx, 0); }
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& idx);
 
   idx_vector index_vector (void) const;
 
-  octave_value
-  do_struct_elt_index_op (const std::string& nm, const octave_value_list& idx,
-			  bool silent);
-
-  octave_value do_struct_elt_index_op (const std::string& nm, bool silent);
-
-  octave_lvalue struct_elt_ref (octave_value *parent, const std::string& nm);
+  octave_value subsasgn (const std::string type,
+			 const SLList<octave_value_list>& idx,
+			 const octave_value& rhs);
 
   int rows (void) const { return -1; }
 
   int columns (void) const { return -1; }
 
   int length (void) const { return -1; }
 
   bool is_defined (void) const { return false; }
@@ -179,16 +186,18 @@ public:
   string_vector all_strings (void) const;
 
   std::string string_value (void) const;
 
   Range range_value (void) const;
 
   Octave_map map_value (void) const;
 
+  string_vector map_keys (void) const;
+
   octave_stream stream_value (void) const;
 
   int stream_number (void) const;
 
   octave_function *function_value (bool silent);
 
   octave_value_list list_value (void) const;
 
@@ -201,16 +210,18 @@ public:
   void convert_to_row_or_column_vector (void);
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool print_name_tag (std::ostream& os, const std::string& name) const;
 
+  void print_info (std::ostream& os, const std::string& prefix) const;
+
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
 /*
diff --git a/src/ov-bool-mat.h b/src/ov-bool-mat.h
--- a/src/ov-bool-mat.h
+++ b/src/ov-bool-mat.h
@@ -61,17 +61,18 @@ public:
   octave_bool_matrix (const Array2<bool>& a)
     : octave_base_matrix<boolMatrix> (a) { }
 
   octave_bool_matrix (const octave_bool_matrix& bm)
     : octave_base_matrix<boolMatrix> (bm) { }
 
   ~octave_bool_matrix (void) { }
 
-  octave_value *clone (void) { return new octave_bool_matrix (*this); }
+  octave_value *clone (void) const { return new octave_bool_matrix (*this); }
+  octave_value *empty_clone (void) const { return new octave_bool_matrix (); }
 
   type_conv_fcn numeric_conversion_function (void) const;
 
   octave_value *try_narrowing_conversion (void);
 
   idx_vector index_vector (void) const { return idx_vector (matrix); }
 
   bool is_bool_matrix (void) const { return true; }
diff --git a/src/ov-bool.cc b/src/ov-bool.cc
--- a/src/ov-bool.cc
+++ b/src/ov-bool.cc
@@ -71,17 +71,17 @@ valid_scalar_indices (const octave_value
   for (int i = 0; i < nargin; i++)
     if (! args(i).valid_as_scalar_index ())
       return false;
 
   return true;
 }
 
 octave_value
-octave_bool::do_index_op (const octave_value_list& idx)
+octave_bool::do_index_op (const octave_value_list& idx, int resize_ok)
 {
   octave_value retval;
 
   if (valid_scalar_indices (idx))
     retval = scalar;
   else
     {
       // XXX FIXME XXX -- this doesn't solve the problem of
@@ -91,17 +91,17 @@ octave_bool::do_index_op (const octave_v
       // and similar constructions.  Hmm...
 
       // XXX FIXME XXX -- using this constructor avoids narrowing the
       // 1x1 matrix back to a scalar value.  Need a better solution
       // to this problem.
 
       octave_value tmp (new octave_matrix (matrix_value ()));
 
-      retval = tmp.do_index_op (idx);
+      retval = tmp.do_index_op (idx, resize_ok);
     }
 
   return retval;
 }
 
 octave_value
 octave_bool::convert_to_str (void) const
 {
diff --git a/src/ov-bool.h b/src/ov-bool.h
--- a/src/ov-bool.h
+++ b/src/ov-bool.h
@@ -59,21 +59,22 @@ public:
   octave_bool (bool b)
     : octave_base_scalar<bool> (b) { }
 
   octave_bool (const octave_bool& s)
     : octave_base_scalar<bool> (s) { }
 
   ~octave_bool (void) { }
 
-  octave_value *clone (void) { return new octave_bool (*this); }
+  octave_value *clone (void) const { return new octave_bool (*this); }
+  octave_value *empty_clone (void) const { return new octave_bool (); }
 
   type_conv_fcn numeric_conversion_function (void) const;
 
-  octave_value do_index_op (const octave_value_list& idx);
+  octave_value do_index_op (const octave_value_list& idx, int resize_ok);
 
   idx_vector index_vector (void) const { return idx_vector (scalar); }
 
   bool is_real_scalar (void) const { return true; }
 
   bool is_bool_type (void) const { return true; }
 
   bool is_real_type (void) const { return true; }
diff --git a/src/ov-builtin.cc b/src/ov-builtin.cc
--- a/src/ov-builtin.cc
+++ b/src/ov-builtin.cc
@@ -47,16 +47,47 @@ any_arg_is_magic_colon (const octave_val
   for (int i = 0; i < nargin; i++)
     if (args(i).is_magic_colon ())
       return true;
 
   return false;
 }
 
 octave_value_list
+octave_builtin::subsref (const std::string type,
+			 const SLList<octave_value_list>& idx,
+			 int nargout)
+{
+  octave_value_list retval;
+
+  switch (type[0])
+    {
+    case '(':
+      retval = do_multi_index_op (nargout, idx.front ());
+      break;
+
+    case '{':
+    case '.':
+      {
+	std::string nm = type_name ();
+	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+      }
+      break;
+
+    default:
+      panic_impossible ();
+    }
+
+  return retval;
+
+  // XXX FIXME XXX
+  //  return retval.next_subsref (type, idx);
+}
+
+octave_value_list
 octave_builtin::do_multi_index_op (int nargout, const octave_value_list& args)
 {
   octave_value_list retval;
 
   if (error_state)
     return retval;
 
   if (any_arg_is_magic_colon (args))
diff --git a/src/ov-builtin.h b/src/ov-builtin.h
--- a/src/ov-builtin.h
+++ b/src/ov-builtin.h
@@ -45,16 +45,20 @@ public:
   typedef octave_value_list (*fcn) (const octave_value_list&, int);
 
   octave_builtin (fcn ff, const std::string& nm = std::string (),
 		  const std::string& ds = std::string ())
     : octave_function (nm, ds), f (ff) { }
 
   ~octave_builtin (void) { }
 
+  octave_value_list subsref (const std::string type,
+			     const SLList<octave_value_list>& idx,
+			     int nargout);
+
   octave_function *function_value (bool) { return this; }
 
   bool is_builtin_function (void) const { return true; }
 
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
 protected:
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -45,25 +45,262 @@ Software Foundation, 59 Temple Place - S
 #include "ov-scalar.h"
 
 template class octave_base_matrix<Cell>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_cell);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_cell, "cell");
 
+octave_value
+octave_cell::subsref (const std::string type,
+		      const SLList<octave_value_list>& idx)
+{
+  octave_value retval;
+
+  switch (type[0])
+    {
+    case '(':
+      retval = do_index_op (idx.front ());
+      break;
+
+    case '{':
+      {
+	octave_value tmp = do_index_op (idx.front ());
+
+	Cell tcell = tmp.cell_value ();
+
+	if (tcell.length () == 1)
+	  retval = tcell(0,0);
+	else
+	  {
+	    int nr = tcell.rows ();
+	    int nc = tcell.columns ();
+	    octave_value_list lst (nr * nc, octave_value ());
+	    int k = 0;
+	    for (int j = 0; j < nc; j++)
+	      for (int i = 0; i < nr; i++)
+		lst(k++) = tcell(i,j);
+	    retval = lst;
+	  }
+      }
+      break;
+
+    case '.':
+      {
+	std::string nm = type_name ();
+	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+      }
+      break;
+
+    default:
+      panic_impossible ();
+    }
+
+  return retval.next_subsref (type, idx);
+}
+
+octave_value
+octave_cell::subsasgn (const std::string type,
+		       const SLList<octave_value_list>& idx,
+		       const octave_value& rhs)
+{
+  octave_value retval;
+
+  int n = type.length ();
+
+  octave_value t_rhs = rhs;
+
+  if (n > 1)
+    {
+      switch (type[0])
+	{
+	case '(':
+	  {
+	    octave_value tmp = do_index_op (idx.front (), true);
+
+	    if (! tmp.is_defined ())
+	      tmp = octave_value::empty_conv (type.substr (1), rhs);
+
+	    if (! error_state)
+	      {
+		SLList<octave_value_list> next_idx (idx);
+
+		next_idx.remove_front ();
+
+		t_rhs = tmp.subsasgn (type.substr (1), next_idx, rhs);
+	      }
+	  }
+	  break;
+
+	case '{':
+	  {
+	    octave_value tmp = do_index_op (idx.front (), true);
+
+	    if (! tmp.is_defined ())
+	      tmp = octave_value::empty_conv (type.substr (1), rhs);
+
+	    Cell tcell = tmp.cell_value ();
+
+	    if (! error_state && tcell.length () == 1)
+	      {
+		tmp = tcell(0,0);
+
+		SLList<octave_value_list> next_idx (idx);
+
+		next_idx.remove_front ();
+
+		t_rhs = tmp.subsasgn (type.substr (1), next_idx, rhs);
+	      }
+	  }
+	  break;
+
+	case '.':
+	  {
+	    std::string nm = type_name ();
+	    error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+	  }
+	  break;
+
+	default:
+	  panic_impossible ();
+	}
+    }
+
+  switch (type[0])
+    {
+    case '(':
+      {
+	octave_value_list i = idx.front ();
+
+	if (t_rhs.is_cell ())
+	  octave_base_matrix<Cell>::assign (i, t_rhs.cell_value ());
+	else
+	  octave_base_matrix<Cell>::assign (i, Cell (t_rhs));
+
+	retval = octave_value (this, count + 1);
+      }
+      break;
+
+    case '{':
+      {
+	octave_value_list i = idx.front ();
+
+	octave_base_matrix<Cell>::assign (i, Cell (t_rhs));
+
+	retval = octave_value (this, count + 1);
+      }
+      break;
+
+    case '.':
+      {
+	std::string nm = type_name ();
+	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+      }
+      break;
+
+    default:
+      panic_impossible ();
+    }
+
+  return retval;
+}
+
 void
 octave_cell::assign (const octave_value_list& idx, const octave_value& rhs)
 {
   if (rhs.is_cell ())
     octave_base_matrix<Cell>::assign (idx, rhs.cell_value ());
   else
     octave_base_matrix<Cell>::assign (idx, Cell (rhs));
 }
 
+octave_value_list
+octave_cell::list_value (void) const
+{
+  octave_value_list retval;
+
+  int nr = rows ();
+  int nc = columns ();
+
+  if (nr == 1 && nc > 0)
+    {
+      retval.resize (nc);
+
+      for (int i = 0; i < nc; i++)
+	retval(i) = matrix(0,i);
+    }
+  else if (nc == 1 && nr > 0)
+    {
+      retval.resize (nr);
+
+      for (int i = 0; i < nr; i++)
+	retval(i) = matrix(i,0);
+    }
+  else
+    error ("invalid conversion from cell array to list");
+
+  return retval;
+}
+
+void
+octave_cell::print (std::ostream& os, bool) const
+{
+  print_raw (os);
+}
+
+void
+octave_cell::print_raw (std::ostream& os, bool) const
+{
+  int nr = rows ();
+  int nc = columns ();
+
+  if (nr > 0 && nc > 0)
+    {
+      indent (os);
+      os << "{";
+      newline (os);
+
+      increment_indent_level ();
+
+      for (int j = 0; j < nc; j++)
+	{
+	  for (int i = 0; i < nr; i++)
+	    {
+	      std::ostrstream buf;
+	      buf << "[" << i+1 << "," << j+1 << "]" << std::ends;
+	      const char *nm = buf.str ();
+
+	      octave_value val = matrix(i,j);
+
+	      val.print_with_name (os, nm);
+
+	      delete [] nm;
+	    }
+	}
+
+      decrement_indent_level ();
+
+      indent (os);
+      os << "}";
+      newline (os);
+    }
+  else
+    os << "{}";
+}
+
+bool
+octave_cell::print_name_tag (std::ostream& os, const std::string& name) const
+{
+  indent (os);
+  os << name << " =";
+  newline (os);
+  return false;
+}
+
 DEFUN (iscell, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} iscell (@var{x})\n\
 Return true if @var{x} is a cell array object.  Otherwise, return\n\
 false.\n\
 @end deftypefn")
 {
   octave_value retval;
diff --git a/src/ov-cell.h b/src/ov-cell.h
--- a/src/ov-cell.h
+++ b/src/ov-cell.h
@@ -61,28 +61,44 @@ public:
 
   octave_cell (const octave_cell& c)
     : octave_base_matrix<Cell> (c) { }
 
   ~octave_cell (void) { }
 
   void assign (const octave_value_list& idx, const octave_value& rhs);
 
-  octave_value *clone (void) { return new octave_cell (*this); }
+  octave_value *clone (void) const { return new octave_cell (*this); }
+  octave_value *empty_clone (void) const { return new octave_cell (); }
 
 #if 0
   octave_value *try_narrowing_conversion (void);
 #endif
 
+  octave_value subsref (const std::string type,
+			const SLList<octave_value_list>& idx);
+
+  octave_value subsasgn (const std::string type,
+			 const SLList<octave_value_list>& idx,
+			 const octave_value& rhs);
+
   bool is_defined (void) const { return true; }
 
   bool is_cell (void) const { return true; }
 
   Cell cell_value (void) const { return matrix; }
 
+  octave_value_list list_value (void) const;
+
+  void print (std::ostream& os, bool pr_as_read_syntax = false) const;
+
+  void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
+
+  bool print_name_tag (std::ostream& os, const std::string& name) const;
+
 private:
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
diff --git a/src/ov-ch-mat.h b/src/ov-ch-mat.h
--- a/src/ov-ch-mat.h
+++ b/src/ov-ch-mat.h
@@ -71,17 +71,18 @@ public:
   octave_char_matrix (const string_vector& s)
     : octave_base_matrix<charMatrix> (s) { }
 
   octave_char_matrix (const octave_char_matrix& chm)
     : octave_base_matrix<charMatrix> (chm) { }
 
   ~octave_char_matrix (void) { }
 
-  octave_value *clone (void) { return new octave_char_matrix (*this); }
+  octave_value *clone (void) const { return new octave_char_matrix (*this); }
+  octave_value *empty_clone (void) const { return new octave_char_matrix (); }
 
   bool is_char_matrix (void) const { return true; }
   bool is_real_matrix (void) const { return true; }
 
   bool is_real_type (void) const { return true; }
 
   bool valid_as_scalar_index (void) const;
 
diff --git a/src/ov-colon.h b/src/ov-colon.h
--- a/src/ov-colon.h
+++ b/src/ov-colon.h
@@ -50,17 +50,18 @@ public:
   octave_magic_colon (void)
     : octave_base_value () { }
 
   octave_magic_colon (const octave_magic_colon&)
     : octave_base_value () { }
 
   ~octave_magic_colon (void) { }
 
-  octave_value *clone (void) { return new octave_magic_colon (*this); }
+  octave_value *clone (void) const { return new octave_magic_colon (*this); }
+  octave_value *empty_clone (void) const { return new octave_magic_colon (); }
 
   idx_vector index_vector (void) const { return idx_vector (':'); }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
 
   bool is_magic_colon (void) const { return true; }
diff --git a/src/ov-complex.cc b/src/ov-complex.cc
--- a/src/ov-complex.cc
+++ b/src/ov-complex.cc
@@ -55,50 +55,38 @@ octave_complex::try_narrowing_conversion
   octave_value *retval = 0;
 
   if (imag (scalar) == 0.0)
     retval = new octave_scalar (real (scalar));
 
   return retval;
 }
 
-static inline bool
-valid_scalar_indices (const octave_value_list& args)
-{
-  int nargin = args.length ();
-
-  for (int i = 0; i < nargin; i++)
-    if (! args(i).valid_as_scalar_index ())
-      return false;
-
-  return true;
-}
-
 octave_value
-octave_complex::do_index_op (const octave_value_list& idx)
+octave_complex::do_index_op (const octave_value_list& idx, int resize_ok)
 {
   octave_value retval;
 
-  if (valid_scalar_indices (idx))
+  if (idx.valid_scalar_indices ())
     retval = scalar;
   else
     {
       // XXX FIXME XXX -- this doesn't solve the problem of
       //
       //   a = i; a([1,1], [1,1], [1,1])
       //
       // and similar constructions.  Hmm...
 
       // XXX FIXME XXX -- using this constructor avoids narrowing the
       // 1x1 matrix back to a scalar value.  Need a better solution
       // to this problem.
 
       octave_value tmp (new octave_complex_matrix (complex_matrix_value ()));
 
-      retval = tmp.do_index_op (idx);
+      retval = tmp.do_index_op (idx, resize_ok);
     }
 
   return retval;
 }
 
 double
 octave_complex::double_value (bool force_conversion) const
 {
diff --git a/src/ov-complex.h b/src/ov-complex.h
--- a/src/ov-complex.h
+++ b/src/ov-complex.h
@@ -59,21 +59,22 @@ public:
   octave_complex (const Complex& c)
     : octave_base_scalar<Complex> (c) { }
 
   octave_complex (const octave_complex& c)
     : octave_base_scalar<Complex> (c) { }
 
   ~octave_complex (void) { }
 
-  octave_value *clone (void) { return new octave_complex (*this); }
+  octave_value *clone (void) const { return new octave_complex (*this); }
+  octave_value *empty_clone (void) const { return new octave_complex (); }
 
   octave_value *try_narrowing_conversion (void);
 
-  octave_value do_index_op (const octave_value_list& idx);
+  octave_value do_index_op (const octave_value_list& idx, int resize_ok);
 
   bool is_complex_scalar (void) const { return true; }
 
   bool is_complex_type (void) const { return true; }
 
   // XXX FIXME XXX ???
   bool valid_as_scalar_index (void) const { return false; }
   bool valid_as_zero_index (void) const { return false; }
diff --git a/src/ov-cx-mat.h b/src/ov-cx-mat.h
--- a/src/ov-cx-mat.h
+++ b/src/ov-cx-mat.h
@@ -68,17 +68,18 @@ public:
   octave_complex_matrix (const ComplexColumnVector& v)
     : octave_base_matrix<ComplexMatrix> (ComplexMatrix (v)) { }
 
   octave_complex_matrix (const octave_complex_matrix& cm)
     : octave_base_matrix<ComplexMatrix> (cm) { }
 
   ~octave_complex_matrix (void) { }
 
-  octave_value *clone (void) { return new octave_complex_matrix (*this); }
+  octave_value *clone (void) const { return new octave_complex_matrix (*this); }
+  octave_value *empty_clone (void) const { return new octave_complex_matrix (); }
 
   octave_value *try_narrowing_conversion (void);
 
   void assign (const octave_value_list& idx, const ComplexMatrix& rhs)
     { octave_base_matrix<ComplexMatrix>::assign (idx, rhs); }
 
   void assign (const octave_value_list& idx, const Matrix& rhs);
 
diff --git a/src/ov-fcn.cc b/src/ov-fcn.cc
--- a/src/ov-fcn.cc
+++ b/src/ov-fcn.cc
@@ -29,17 +29,24 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #include "error.h"
 #include "ov-fcn.h"
 
 DEFINE_OCTAVE_ALLOCATOR (octave_function);
 
 octave_function *
-octave_function::clone (void)
+octave_function::clone (void) const
+{
+  panic_impossible ();
+  return 0;
+}
+
+octave_function *
+octave_function::empty_clone (void) const
 {
   panic_impossible ();
   return 0;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/ov-fcn.h b/src/ov-fcn.h
--- a/src/ov-fcn.h
+++ b/src/ov-fcn.h
@@ -45,19 +45,18 @@ octave_function : public octave_base_val
 {
 public:
 
   octave_function (const octave_function& f)
     : octave_base_value (), my_name (f.my_name), doc (f.doc) { }
 
   ~octave_function (void) { }
 
-  // This should only be called for derived types.
-
-  octave_function *clone (void);
+  octave_function *clone (void) const;
+  octave_function *empty_clone (void) const;
 
   bool is_defined (void) const { return true; }
 
   bool is_function (void) const { return true; }
 
   virtual bool is_dynamically_loaded_function (void) const { return false; }
 
   virtual bool is_system_fcn_file (void) const { return false; }
diff --git a/src/ov-file.h b/src/ov-file.h
--- a/src/ov-file.h
+++ b/src/ov-file.h
@@ -55,17 +55,18 @@ public:
   octave_file (const octave_stream& s, int n)
     : octave_base_value (), stream (s), number (n) { }
 
   octave_file (const octave_file& f)
     : octave_base_value (), stream (f.stream), number (f.number) { }
 
   ~octave_file (void) { }
 
-  octave_value *clone (void) { return new octave_file (*this); }
+  octave_value *clone (void) const { return new octave_file (*this); }
+  octave_value *empty_clone (void) const { return new octave_file (); }
 
   type_conv_fcn numeric_conversion_function (void) const;
 
   double double_value (bool) const { return static_cast<double> (number); }
 
   double scalar_value (bool) const { return static_cast<double> (number); }
 
   octave_stream stream_value (void) const { return stream; }
diff --git a/src/ov-list.cc b/src/ov-list.cc
--- a/src/ov-list.cc
+++ b/src/ov-list.cc
@@ -38,32 +38,160 @@ Software Foundation, 59 Temple Place - S
 #include "ov-list.h"
 #include "unwind-prot.h"
 
 DEFINE_OCTAVE_ALLOCATOR (octave_list);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_list, "list");
 
 octave_value
-octave_list::do_index_op (const octave_value_list& idx)
+octave_list::subsref (const std::string type,
+		      const SLList<octave_value_list>& idx)
+{
+  octave_value retval;
+
+  switch (type[0])
+    {
+    case '(':
+      {
+	octave_value_list tmp_idx = idx.front ();
+
+	if (tmp_idx.length () == 1)
+	  {
+	    idx_vector i = tmp_idx (0).index_vector ();
+
+	    retval = octave_value_list (lst.index (i));
+	  }
+	else
+	  error ("only one index allowed for lists");
+      }
+      break;
+
+    case '{':
+      {
+	octave_value_list tmp_idx = idx.front ();
+
+	if (tmp_idx.length () == 1)
+	  {
+	    idx_vector i = tmp_idx (0).index_vector ();
+
+	    octave_value_list tmp = lst.index (i);
+
+	    if (tmp.length () == 1)
+	      retval = tmp(0);
+	  }
+	else
+	  error ("only one index allowed for lists");
+      }
+      break;
+
+    case '.':
+      {
+	std::string nm = type_name ();
+	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+      }
+      break;
+
+    default:
+      panic_impossible ();
+    }
+
+  return retval.next_subsref (type, idx);
+}
+
+octave_value
+octave_list::do_index_op (const octave_value_list& idx, int resize_ok)
 {
   octave_value retval;
 
   if (idx.length () == 1)
     {
       idx_vector i = idx (0).index_vector ();
 
-      retval = octave_value_list (lst.index (i));
+      retval = octave_value_list (lst.index (i, resize_ok));
     }
   else
     error ("lists may only be indexed by a single scalar");
 
   return retval;
 }
 
+octave_value
+octave_list::subsasgn (const std::string type,
+		       const SLList<octave_value_list>& idx,
+		       const octave_value& rhs)
+{
+  octave_value retval;
+
+  int n = type.length ();
+
+  octave_value t_rhs = rhs;
+
+  if (n > 1)
+    {
+      switch (type[0])
+	{
+	case '(':
+	  {
+	    octave_value tmp = do_index_op (idx.front (), true);
+
+	    if (! tmp.is_defined ())
+	      tmp = octave_value::empty_conv (type.substr (1), rhs);
+
+	    if (! error_state)
+	      {
+		SLList<octave_value_list> next_idx (idx);
+
+		next_idx.remove_front ();
+
+		t_rhs = tmp.subsasgn (type.substr (1), next_idx, rhs);
+	      }
+	  }
+	  break;
+
+	case '{':
+	case '.':
+	  {
+	    std::string nm = type_name ();
+	    error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+	  }
+	  break;
+
+	default:
+	  panic_impossible ();
+	}
+    }
+
+  switch (type[0])
+    {
+    case '(':
+      {
+	octave_value_list i = idx.front ();
+
+	assign (i, t_rhs);
+
+	retval = octave_value (this, count + 1);
+      }
+      break;
+
+    case '{':
+    case '.':
+      {
+	std::string nm = type_name ();
+	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+      }
+      break;
+
+    default:
+      panic_impossible ();
+    }
+
+  return retval;
+}
+
 void
 octave_list::assign (const octave_value_list& idx, const octave_value& rhs)
 {
   if (idx.length () == 1)
     {
       int i = idx(0).int_value (true);
 
       if (! error_state)
diff --git a/src/ov-list.h b/src/ov-list.h
--- a/src/ov-list.h
+++ b/src/ov-list.h
@@ -56,19 +56,27 @@ public:
   octave_list (const octave_value_list& l)
     : octave_base_value (), lst (l) { }
 
   octave_list (const octave_list& l)
     : octave_base_value (), lst (l.lst) { }
 
   ~octave_list (void) { }
 
-  octave_value *clone (void) { return new octave_list (*this); }
+  octave_value *clone (void) const { return new octave_list (*this); }
+  octave_value *empty_clone (void) const { return new octave_list (); }
+
+  octave_value subsref (const std::string type,
+			const SLList<octave_value_list>& idx);
 
-  octave_value do_index_op (const octave_value_list& idx);
+  octave_value do_index_op (const octave_value_list& idx, int resize_ok);
+
+  octave_value subsasgn (const std::string type,
+			 const SLList<octave_value_list>& idx,
+			 const octave_value& rhs);
 
   void assign (const octave_value_list& idx, const octave_value& rhs);
 
   int length (void) const { return lst.length (); }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
diff --git a/src/ov-mapper.cc b/src/ov-mapper.cc
--- a/src/ov-mapper.cc
+++ b/src/ov-mapper.cc
@@ -226,16 +226,47 @@ octave_mapper::apply (const octave_value
       else
 	gripe_wrong_type_arg ("mapper", arg);
     }
 
   return retval;
 }
 
 octave_value_list
+octave_mapper::subsref (const std::string type,
+			const SLList<octave_value_list>& idx,
+			int nargout)
+{
+  octave_value_list retval;
+
+  switch (type[0])
+    {
+    case '(':
+      retval = do_multi_index_op (nargout, idx.front ());
+      break;
+
+    case '{':
+    case '.':
+      {
+	std::string nm = type_name ();
+	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+      }
+      break;
+
+    default:
+      panic_impossible ();
+    }
+
+  return retval;
+
+  // XXX FIXME XXX
+  //  return retval.next_subsref (type, idx);
+}
+
+octave_value_list
 octave_mapper::do_multi_index_op (int, const octave_value_list& args)
 {
   octave_value retval;
 
   if (error_state)
     return retval;
 
   int nargin = args.length ();
diff --git a/src/ov-mapper.h b/src/ov-mapper.h
--- a/src/ov-mapper.h
+++ b/src/ov-mapper.h
@@ -58,16 +58,20 @@ public:
       d_b_map_fcn (db), c_b_map_fcn (cb),
       d_d_map_fcn (dd), d_c_map_fcn (dc), c_c_map_fcn (cc),
       lower_limit (ll), upper_limit (ul), flag (f) { }
 
   ~octave_mapper (void) { }
 
   octave_function *function_value (bool) { return this; }
 
+  octave_value_list subsref (const std::string type,
+			     const SLList<octave_value_list>& idx,
+			     int nargout);
+
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
 private:
 
   octave_mapper (void);
 
   octave_mapper (const octave_mapper& m);
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -30,16 +30,17 @@ Software Foundation, 59 Temple Place - S
 
 #include <iostream>
 
 #include "lo-ieee.h"
 #include "lo-utils.h"
 
 #include "gripes.h"
 #include "ops.h"
+#include "oct-obj.h"
 #include "ov-range.h"
 #include "ov-re-mat.h"
 #include "ov-scalar.h"
 #include "pr-output.h"
 
 DEFINE_OCTAVE_ALLOCATOR (octave_range);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_range, "range");
@@ -76,31 +77,58 @@ octave_range::try_narrowing_conversion (
     default:
       break;
     }
 
   return retval;
 }
 
 octave_value
-octave_range::do_index_op (const octave_value_list& idx)
+octave_range::subsref (const std::string type,
+		       const SLList<octave_value_list>& idx)
+{
+  octave_value retval;
+
+  switch (type[0])
+    {
+    case '(':
+      retval = do_index_op (idx.front ());
+      break;
+
+    case '{':
+    case '.':
+      {
+	std::string nm = type_name ();
+	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+      }
+      break;
+
+    default:
+      panic_impossible ();
+    }
+
+  return retval.next_subsref (type, idx);
+}
+
+octave_value
+octave_range::do_index_op (const octave_value_list& idx, int resize_ok)
 {
   // XXX FIXME XXX -- this doesn't solve the problem of
   //
   //   a = 1:5; a(1, 1, 1)
   //
   // and similar constructions.  Hmm...
 
   // XXX FIXME XXX -- using this constructor avoids possibly narrowing
   // the range to a scalar value.  Need a better solution to this
   // problem.
 
   octave_value tmp (new octave_matrix (range.matrix_value ()));
 
-  return tmp.do_index_op (idx);
+  return tmp.do_index_op (idx, resize_ok);
 }
 
 double
 octave_range::double_value (bool) const
 {
   double retval = octave_NaN;
 
   int nel = range.nelem ();
diff --git a/src/ov-range.h b/src/ov-range.h
--- a/src/ov-range.h
+++ b/src/ov-range.h
@@ -35,16 +35,17 @@ Software Foundation, 59 Temple Place - S
 #include "Range.h"
 
 #include "lo-mappers.h"
 #include "lo-utils.h"
 #include "mx-base.h"
 #include "oct-alloc.h"
 #include "str-vec.h"
 
+#include "SLList.h"
 #include "error.h"
 #include "ov-base.h"
 #include "ov-typeinfo.h"
 
 class Octave_map;
 class octave_value_list;
 
 class tree_walker;
@@ -73,23 +74,30 @@ public:
 	  ::error ("invalid range");
       }
 
   octave_range (const octave_range& r)
     : octave_base_value (), range (r.range) { }
 
   ~octave_range (void) { }
 
-  octave_value *clone (void) { return new octave_range (*this); }
+  octave_value *clone (void) const { return new octave_range (*this); }
+  octave_value *empty_clone (void) const { return new octave_range (); }
 
   type_conv_fcn numeric_conversion_function (void) const;
 
   octave_value *try_narrowing_conversion (void);
 
-  octave_value do_index_op (const octave_value_list& idx);
+  octave_value subsref (const std::string type,
+			const SLList<octave_value_list>& idx);
+
+  octave_value do_index_op (const octave_value_list& idx, int resize_ok);
+
+  octave_value do_index_op (const octave_value_list& idx)
+    { return do_index_op (idx, 0); }
 
   idx_vector index_vector (void) const { return idx_vector (range); }
 
   int rows (void) const { return (columns () > 0); }
   int columns (void) const { return range.nelem (); }
 
   int length (void) const { return range.nelem (); }
 
diff --git a/src/ov-re-mat.h b/src/ov-re-mat.h
--- a/src/ov-re-mat.h
+++ b/src/ov-re-mat.h
@@ -68,17 +68,18 @@ public:
   octave_matrix (const ColumnVector& v)
     : octave_base_matrix<Matrix> (Matrix (v)) { }
 
   octave_matrix (const octave_matrix& m)
     : octave_base_matrix<Matrix> (m) { }
 
   ~octave_matrix (void) { }
 
-  octave_value *clone (void) { return new octave_matrix (*this); }
+  octave_value *clone (void) const { return new octave_matrix (*this); }
+  octave_value *empty_clone (void) const { return new octave_matrix (); }
 
   octave_value *try_narrowing_conversion (void);
 
   idx_vector index_vector (void) const { return idx_vector (matrix); }
 
   bool is_real_matrix (void) const { return true; }
 
   bool is_real_type (void) const { return true; }
diff --git a/src/ov-re-nd-array.h b/src/ov-re-nd-array.h
--- a/src/ov-re-nd-array.h
+++ b/src/ov-re-nd-array.h
@@ -55,17 +55,18 @@ public:
   octave_double_nd_array (const ArrayN<double>& a)
     : octave_base_nd_array<ArrayN<double> > (a) { }
 
   octave_double_nd_array (const octave_double_nd_array& a)
     : octave_base_nd_array<ArrayN<double> > (a) { }
 
   ~octave_double_nd_array (void) { }
 
-  octave_value *clone (void) { return new octave_double_nd_array (*this); }
+  octave_value *clone (void) const { return new octave_double_nd_array (*this); }
+  octave_value *empty_clone (void) const { return new octave_double_nd_array (); }
 
 #if 0
   octave_value *try_narrowing_conversion (void);
 
   void assign (const octave_value_list& idx, const Matrix& rhs);
 
   idx_vector index_vector (void) const { return idx_vector (matrix); }
 
diff --git a/src/ov-scalar.cc b/src/ov-scalar.cc
--- a/src/ov-scalar.cc
+++ b/src/ov-scalar.cc
@@ -44,50 +44,38 @@ Software Foundation, 59 Temple Place - S
 #include "xpow.h"
 
 template class octave_base_scalar<double>;
 
 DEFINE_OCTAVE_ALLOCATOR (octave_scalar);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_scalar, "scalar");
 
-static inline bool
-valid_scalar_indices (const octave_value_list& args)
-{
-  int nargin = args.length ();
-
-  for (int i = 0; i < nargin; i++)
-    if (! args(i).valid_as_scalar_index ())
-      return false;
-
-  return true;
-}
-
 octave_value
-octave_scalar::do_index_op (const octave_value_list& idx)
+octave_scalar::do_index_op (const octave_value_list& idx, int resize_ok)
 {
   octave_value retval;
 
-  if (valid_scalar_indices (idx))
+  if (idx.valid_scalar_indices ())
     retval = scalar;
   else
     {
       // XXX FIXME XXX -- this doesn't solve the problem of
       //
       //   a = 1; a([1,1], [1,1], [1,1])
       //
       // and similar constructions.  Hmm...
 
       // XXX FIXME XXX -- using this constructor avoids narrowing the
       // 1x1 matrix back to a scalar value.  Need a better solution
       // to this problem.
 
       octave_value tmp (new octave_matrix (matrix_value ()));
 
-      retval = tmp.do_index_op (idx);
+      retval = tmp.do_index_op (idx, resize_ok);
     }
 
   return retval;
 }
 
 octave_value
 octave_scalar::convert_to_str (void) const
 {
diff --git a/src/ov-scalar.h b/src/ov-scalar.h
--- a/src/ov-scalar.h
+++ b/src/ov-scalar.h
@@ -60,19 +60,20 @@ public:
   octave_scalar (double d)
     : octave_base_scalar<double> (d) { }
 
   octave_scalar (const octave_scalar& s)
     : octave_base_scalar<double> (s) { }
 
   ~octave_scalar (void) { }
 
-  octave_value *clone (void) { return new octave_scalar (*this); }
+  octave_value *clone (void) const { return new octave_scalar (*this); }
+  octave_value *empty_clone (void) const { return new octave_scalar (); }
 
-  octave_value do_index_op (const octave_value_list& idx);
+  octave_value do_index_op (const octave_value_list& idx, int resize_ok);
 
   idx_vector index_vector (void) const { return idx_vector (scalar); }
 
   bool is_real_scalar (void) const { return true; }
 
   bool is_real_type (void) const { return true; }
 
   bool valid_as_scalar_index (void) const
diff --git a/src/ov-str-mat.cc b/src/ov-str-mat.cc
--- a/src/ov-str-mat.cc
+++ b/src/ov-str-mat.cc
@@ -57,38 +57,40 @@ default_numeric_conversion_function (con
 
 type_conv_fcn
 octave_char_matrix_str::numeric_conversion_function (void) const
 {
   return default_numeric_conversion_function;
 }
 
 octave_value
-octave_char_matrix_str::do_index_op (const octave_value_list& idx)
+octave_char_matrix_str::do_index_op (const octave_value_list& idx,
+				     int resize_ok)
 {
   octave_value retval;
 
   int len = idx.length ();
 
   switch (len)
     {
     case 2:
       {
 	idx_vector i = idx (0).index_vector ();
 	idx_vector j = idx (1).index_vector ();
 
-	retval = octave_value (charMatrix (matrix.index (i, j)), true);
+	retval = octave_value (charMatrix (matrix.index (i, j, resize_ok)),
+			       true);
       }
       break;
 
     case 1:
       {
 	idx_vector i = idx (0).index_vector ();
 
-	retval = octave_value (charMatrix (matrix.index (i)), true);
+	retval = octave_value (charMatrix (matrix.index (i, resize_ok)), true);
       }
       break;
 
     default:
       error ("invalid number of indices (%d) for matrix value", len);
       break;
     }
 
diff --git a/src/ov-str-mat.h b/src/ov-str-mat.h
--- a/src/ov-str-mat.h
+++ b/src/ov-str-mat.h
@@ -74,21 +74,22 @@ public:
   octave_char_matrix_str (const octave_char_matrix& chm)
     : octave_char_matrix (chm) { }
 
   octave_char_matrix_str (const octave_char_matrix_str& chms)
     : octave_char_matrix (chms) { }
 
   ~octave_char_matrix_str (void) { }
 
-  octave_value *clone (void) { return new octave_char_matrix_str (*this); }
+  octave_value *clone (void) const { return new octave_char_matrix_str (*this); }
+  octave_value *empty_clone (void) const { return new octave_char_matrix_str (); }
 
   type_conv_fcn numeric_conversion_function (void) const;
 
-  octave_value do_index_op (const octave_value_list& idx);
+  octave_value do_index_op (const octave_value_list& idx, int resize_ok);
 
   void assign (const octave_value_list& idx, const charMatrix& rhs);
 
   bool is_string (void) const { return true; }
 
   bool is_real_type (void) const { return Vimplicit_str_to_num_ok; }
 
   bool is_matrix_type (void) const { return Vimplicit_str_to_num_ok; }
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -25,56 +25,346 @@ Software Foundation, 59 Temple Place - S
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
 
+#include "Cell.h"
 #include "error.h"
 #include "oct-lvalue.h"
 #include "ov-list.h"
 #include "ov-struct.h"
 #include "unwind-prot.h"
 #include "variables.h"
 
 DEFINE_OCTAVE_ALLOCATOR(octave_struct);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA(octave_struct, "struct");
 
-octave_value
-octave_struct::do_struct_elt_index_op (const std::string& nm,
-				       const octave_value_list& idx,
-				       bool silent)
+octave_value_list
+octave_struct::dotref (const octave_value_list& idx)
 {
-  // XXX DO_ME XXX
-  return octave_value ();
-}
+  octave_value_list retval;
+
+  assert (idx.length () == 1);
 
-octave_value
-octave_struct::do_struct_elt_index_op (const std::string& nm, bool silent)
-{
-  octave_value retval;
+  std::string nm = idx(0).string_value ();
+
+  Pix p = map.seek (nm);
 
-  Pix idx = map.seek (nm);
-
-  if (idx)
-    retval = map.contents (idx);
-  else if (! silent)
+  if (p)
+    retval = map.contents (p);
+  else
     error ("structure has no member `%s'", nm.c_str ());
 
   return retval;
 }
 
-octave_lvalue
-octave_struct::struct_elt_ref (octave_value *, const std::string& nm)
+static void
+gripe_invalid_index (void)
+{
+  error ("invalid index for structure array");
+}
+
+static void
+gripe_invalid_index_for_assignment (void)
+{
+  error ("invalid index for structure array assignment");
+}
+
+static void
+gripe_invalid_index_type (const std::string& nm, char t)
+{
+  error ("%s cannot be indexed with %c", nm.c_str (), t);
+}
+
+static void
+gripe_failed_assignment (void)
+{
+  error ("assignment to structure element failed");
+}
+
+octave_value
+octave_struct::subsref (const std::string type,
+			const SLList<octave_value_list>& idx)
+{
+  octave_value retval;
+
+  int skip = 1;
+
+  switch (type[0])
+    {
+    case '(':
+      {
+	if (type.length () > 1 && type[1] == '.')
+	  {
+	    Pix p = idx.first ();
+	    idx.next (p);
+	    octave_value_list key_idx = idx(p);
+
+	    octave_value_list tmp = dotref (key_idx);
+
+	    if (! error_state)
+	      {
+		octave_value_list t_idx = idx.front ();
+
+		if (t_idx.length () == 1)
+		  {
+		    idx_vector i = t_idx(0).index_vector ();
+		    octave_value_list t = tmp.index (i);
+
+		    retval = (t.length () == 1) ? t(0) : octave_value (t);
+
+		    // We handled two index elements, so tell
+		    // next_subsref to skip both of them.
+
+		    skip++;
+		  }
+		else
+		  gripe_invalid_index ();
+	      }
+	  }
+	else
+	  {
+	    octave_value_list t_idx = idx.front ();
+
+	    if (t_idx.length () == 1)
+	      {
+		idx_vector i = t_idx(0).index_vector ();
+		retval = map.index (i);
+	      }
+	    else
+	      gripe_invalid_index ();
+	  }
+      }
+      break;
+
+    case '.':
+      {
+	octave_value_list t = dotref (idx.front ());
+
+	retval = (t.length () == 1) ? t(0) : octave_value (t);
+      }
+      break;
+
+    case '{':
+      gripe_invalid_index_type (type_name (), type[0]);
+      break;
+
+    default:
+      panic_impossible ();
+    }
+
+  if (! error_state)
+    retval = retval.next_subsref (type, idx, skip);
+
+  return retval;
+}
+
+octave_value
+octave_struct::numeric_conv (const octave_value_list& val,
+			     const std::string& type)
+{
+  octave_value retval;
+
+  if (val.length () == 1)
+    {
+      retval = val(0);
+
+      if (type.length () > 0 && type[0] == '.' && ! retval.is_map ())
+	retval = Octave_map ();
+    }
+  else
+    gripe_invalid_index_for_assignment ();
+
+  return retval;
+}
+
+octave_value
+octave_struct::subsasgn (const std::string type,
+			 const SLList<octave_value_list>& idx,
+			 const octave_value& rhs)
 {
-  // XXX FIXME XXX -- struct array
-  return octave_lvalue (&map[nm](0));
+  octave_value retval;
+
+  int n = type.length ();
+
+  octave_value t_rhs = rhs;
+
+  if (n > 1 && ! (type.length () == 2 && type[0] == '(' && type[1] == '.'))
+    {
+      switch (type[0])
+	{
+	case '(':
+	  {
+	    if (type.length () > 1 && type[1] == '.')
+	      {
+		Pix p = idx.first ();
+		octave_value_list t_idx = idx(p);
+
+		if (t_idx.length () == 1)
+		  {
+		    idx.next (p);
+		    octave_value_list key_idx = idx(p);
+
+		    assert (key_idx.length () == 1);
+
+		    std::string key = key_idx(0).string_value ();
+
+		    octave_value u;
+
+		    if (! map.contains (key))
+		      u = octave_value::empty_conv (type.substr (2), rhs);
+		    else
+		      {
+			octave_value_list map_val = map[key];
+
+			octave_value_list t_idx = idx.front ();
+
+			idx_vector i = t_idx(0).index_vector ();
+
+			octave_value_list map_elt = map_val.index (i, true);
+
+			u = numeric_conv (map_elt, type.substr (2));
+		      }
+
+		    if (! error_state)
+		      {
+			SLList<octave_value_list> next_idx (idx);
+
+			// We handled two index elements, so subsasgn to
+			// needs to skip both of them.
+
+			next_idx.remove_front ();
+			next_idx.remove_front ();
+
+			t_rhs = u.subsasgn (type.substr (2), next_idx, rhs);
+		      }
+		  }
+		else
+		  gripe_invalid_index_for_assignment ();
+	      }
+	    else
+	      gripe_invalid_index_for_assignment ();
+	  }
+	  break;
+
+	case '.':
+	  {
+	    octave_value_list key_idx = idx.front ();
+
+	    assert (key_idx.length () == 1);
+
+	    std::string key = key_idx(0).string_value ();
+
+	    octave_value u;
+
+	    if (! map.contains (key))
+	      u = octave_value::empty_conv (type.substr (1), rhs);
+	    else
+	      {
+		octave_value_list map_val = map[key];
+
+		u = numeric_conv (map_val, type.substr (1));
+	      }
+
+	    if (! error_state)
+	      {
+		SLList<octave_value_list> next_idx (idx);
+
+		next_idx.remove_front ();
+
+		t_rhs = u.subsasgn (type.substr (1), next_idx, rhs);
+	      }
+	  }
+	  break;
+
+	case '{':
+	  gripe_invalid_index_type (type_name (), type[0]);
+	  break;
+
+	default:
+	  panic_impossible ();
+	}
+    }
+
+  if (! error_state)
+    {
+      switch (type[0])
+	{
+	case '(':
+	  {
+	    if (n > 1 && type[1] == '.')
+	      {
+		Pix p = idx.first ();
+		idx.next (p);
+		octave_value_list key_idx = idx(p);
+
+		assert (key_idx.length () == 1);
+
+		std::string key = key_idx(0).string_value ();
+
+		if (! error_state)
+		  {
+		    octave_value_list t_idx = idx.front ();
+
+		    if (t_idx.length () == 1)
+		      {
+			idx_vector i = t_idx(0).index_vector ();
+
+			map.assign (i, key, t_rhs);
+
+			if (! error_state)
+			  retval = octave_value (this, count + 1);
+			else
+			  gripe_failed_assignment ();
+		      }
+		    else
+		      gripe_invalid_index_for_assignment ();
+		  }
+		else
+		  gripe_failed_assignment ();
+	      }
+	    else
+	      gripe_invalid_index_for_assignment ();
+	  }
+	  break;
+
+	case '.':
+	  {
+	    octave_value_list key_idx = idx.front ();
+
+	    assert (key_idx.length () == 1);
+
+	    std::string key = key_idx(0).string_value ();
+
+	    map.assign (key, t_rhs);
+
+	    if (! error_state)
+	      retval = octave_value (this, count + 1);
+	    else
+	      gripe_failed_assignment ();
+	  }
+	  break;
+
+	case '{':
+	  gripe_invalid_index_type (type_name (), type[0]);
+	  break;
+
+	default:
+	  panic_impossible ();
+	}
+    }
+  else
+    gripe_failed_assignment ();
+
+  return retval;
 }
 
 void
 octave_struct::print (std::ostream& os, bool) const
 {
   print_raw (os);
 }
 
diff --git a/src/ov-struct.h b/src/ov-struct.h
--- a/src/ov-struct.h
+++ b/src/ov-struct.h
@@ -59,34 +59,41 @@ public:
   octave_struct (const Octave_map& m)
     : octave_base_value (), map (m) { }
 
   octave_struct (const octave_struct& s)
     : octave_base_value (), map (s.map) { }
 
   ~octave_struct (void) { }
 
-  octave_value *clone (void) { return new octave_struct (*this); }
+  octave_value *clone (void) const { return new octave_struct (*this); }
+  octave_value *empty_clone (void) const { return new octave_struct (); }
+
+  octave_value_list dotref (const octave_value_list& idx);
 
-  octave_value
-  do_struct_elt_index_op (const std::string& nm, const octave_value_list& idx,
-			  bool silent);
+  octave_value subsref (const std::string type,
+			const SLList<octave_value_list>& idx);
 
-  octave_value do_struct_elt_index_op (const std::string& nm, bool silent);
+  static octave_value numeric_conv (const octave_value_list& val,
+				    const std::string& type);
 
-  octave_lvalue struct_elt_ref (octave_value *parent, const std::string& nm);
+  octave_value subsasgn (const std::string type,
+			 const SLList<octave_value_list>& idx,
+			 const octave_value& rhs);
 
   bool is_defined (void) const { return true; }
 
-  bool is_constant (void) const { return false; }
+  bool is_constant (void) const { return true; }
 
   bool is_map (void) const { return true; }
 
   Octave_map map_value (void) const { return map; }
 
+  string_vector map_keys (void) const { return map.keys (); }
+
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool print_name_tag (std::ostream& os, const std::string& name) const;
 
 private:
 
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -252,16 +252,47 @@ restore_args_passed (void *fcn)
 static void
 unprotect_function (void *sr_arg)
 {
   symbol_record *sr = static_cast<symbol_record *> (sr_arg);
   sr->unprotect ();
 }
 
 octave_value_list
+octave_user_function::subsref (const std::string type,
+			       const SLList<octave_value_list>& idx,
+			       int nargout)
+{
+  octave_value_list retval;
+
+  switch (type[0])
+    {
+    case '(':
+      retval = do_multi_index_op (nargout, idx.front ());
+      break;
+
+    case '{':
+    case '.':
+      {
+	std::string nm = type_name ();
+	error ("%s cannot be indexed with %c", nm.c_str (), type[0]);
+      }
+      break;
+
+    default:
+      panic_impossible ();
+    }
+
+  return retval;
+
+  // XXX FIXME XXX
+  //  return retval.next_subsref (type, idx);
+}
+
+octave_value_list
 octave_user_function::do_multi_index_op (int nargout,
 					 const octave_value_list& args)
 {
   octave_value_list retval;
 
   if (error_state)
     return retval;
 
@@ -445,16 +476,25 @@ octave_user_function::traceback_error (v
 
 void
 octave_user_function::accept (tree_walker& tw)
 {
   tw.visit_octave_user_function (*this);
 }
 
 void
+octave_user_function::print_symtab_info (std::ostream& os) const
+{
+  if (sym_tab)
+    sym_tab->print_info (os);
+  else
+    warning ("%s: no symbol table info!", fcn_name.c_str ());
+}
+
+void
 octave_user_function::print_code_function_header (void)
 {
   tree_print_code tpc (octave_stdout, Vps4);
 
   tpc.visit_octave_user_function_header (*this);
 }
 
 void
diff --git a/src/ov-usr-fcn.h b/src/ov-usr-fcn.h
--- a/src/ov-usr-fcn.h
+++ b/src/ov-usr-fcn.h
@@ -122,20 +122,26 @@ public:
       if (call_depth > 1)
 	saved_args.push (args_passed);
 
       args_passed = args;
     }
 
   void restore_args_passed (void)
     {
-      if (! saved_args.empty ())
+      if (saved_args.empty ())
+	args_passed = octave_value_list ();
+      else
 	args_passed = saved_args.pop ();
     }
 
+  octave_value_list subsref (const std::string type,
+			     const SLList<octave_value_list>& idx,
+			     int nargout);
+
   octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& args);
 
   void traceback_error (void);
 
   tree_parameter_list *parameter_list (void) { return param_list; }
 
   tree_parameter_list *return_list (void) { return ret_list; }
@@ -143,16 +149,18 @@ public:
   tree_statement_list *body (void) { return cmd_list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
   void accept (tree_walker& tw);
 
+  void print_symtab_info (std::ostream& os) const;
+
 private:
 
   octave_user_function (void);
 
   octave_user_function (const octave_user_function& m);
 
   // List of arguments for this function.  These are local variables.
   tree_parameter_list *param_list;
diff --git a/src/ov-va-args.h b/src/ov-va-args.h
--- a/src/ov-va-args.h
+++ b/src/ov-va-args.h
@@ -50,17 +50,18 @@ public:
   octave_all_va_args (void)
     : octave_base_value () { }
 
   octave_all_va_args (const octave_all_va_args&)
     : octave_base_value () { }
 
   ~octave_all_va_args (void) { }
 
-  octave_value *clone (void) { return new octave_all_va_args (*this); }
+  octave_value *clone (void) const { return new octave_all_va_args (*this); }
+  octave_value *empty_clone (void) const { return new octave_all_va_args (); }
 
   bool is_defined (void) const { return true; }
 
   bool is_all_va_args (void) const { return true; }
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -27,17 +27,16 @@ Software Foundation, 59 Temple Place - S
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "Array-flags.h"
 #include "str-vec.h"
 
 #include "oct-obj.h"
-#include "oct-lvalue.h"
 #include "ov.h"
 #include "ov-base.h"
 #include "ov-bool.h"
 #include "ov-bool-mat.h"
 #include "ov-cell.h"
 #include "ov-scalar.h"
 #include "ov-re-mat.h"
 #include "ov-complex.h"
@@ -503,20 +502,20 @@ octave_value::octave_value (octave_value
 }
 
 octave_value::octave_value (octave_value::all_va_args)
   : rep (new octave_all_va_args ())
 {
   rep->count = 1;
 }
 
-octave_value::octave_value (octave_value *new_rep)
+octave_value::octave_value (octave_value *new_rep, int count)
   : rep (new_rep)
 {
-  rep->count = 1;
+  rep->count = count;
 }
 
 octave_value::~octave_value (void)
 {
 #if defined (MDEBUG)
   std::cerr << "~octave_value: rep: " << rep
 	    << " rep->count: " << rep->count << "\n";
 #endif
@@ -524,17 +523,17 @@ octave_value::~octave_value (void)
   if (rep && --rep->count == 0)
     {
       delete rep;
       rep = 0;
     }
 }
 
 octave_value *
-octave_value::clone (void)
+octave_value::clone (void) const
 {
   panic_impossible ();
   return 0;
 }
 
 void
 octave_value::maybe_mutate (void)
 {
@@ -546,44 +545,131 @@ octave_value::maybe_mutate (void)
 	delete rep;
 
       rep = tmp;
       rep->count = 1;
     }    
 }
 
 octave_value_list
+octave_value::subsref (const std::string type,
+		       const SLList<octave_value_list>& idx, int nargout)
+{
+  if (is_constant ())
+    return rep->subsref (type, idx);
+  else
+    return rep->subsref (type, idx, nargout);
+}
+
+octave_value
+octave_value::next_subsref (const std::string type,
+			    const SLList<octave_value_list>& idx,
+			    int skip) 
+{
+  assert (skip > 0);
+
+  if (idx.length () > skip)
+    {
+      SLList<octave_value_list> new_idx (idx);
+      for (int i = 0; i < skip; i++)
+	new_idx.remove_front ();
+      return subsref (type.substr (skip), new_idx);
+    }
+  else
+    return *this;
+}
+
+octave_value_list
 octave_value::do_multi_index_op (int nargout, const octave_value_list& idx)
 {
   return rep->do_multi_index_op (nargout, idx);
 }
 
 static void
-gripe_no_conversion (const std::string& on, const std::string& tn1, const std::string& tn2)
+gripe_no_conversion (const std::string& on, const std::string& tn1,
+		     const std::string& tn2)
 {
   error ("operator %s: no conversion for assignment of `%s' to indexed `%s'",
 	 on.c_str (), tn2.c_str (), tn1.c_str ());
 }
 
+#if 0
 static void
-gripe_assign_failed (const std::string& on, const std::string& tn1, const std::string& tn2)
+gripe_assign_failed (const std::string& on, const std::string& tn1,
+		     const std::string& tn2)
 {
   error ("assignment failed for `%s %s %s'",
 	 tn1.c_str (), on.c_str (), tn2.c_str ());
 }
+#endif
 
 static void
-gripe_assign_failed_or_no_method (const std::string& on, const std::string& tn1,
+gripe_assign_failed_or_no_method (const std::string& on,
+				  const std::string& tn1,
 				  const std::string& tn2)
 {
   error ("assignment failed, or no method for `%s %s %s'",
 	 tn1.c_str (), on.c_str (), tn2.c_str ());
 }
 
-void
+octave_value
+octave_value::subsasgn (const std::string type,
+			const SLList<octave_value_list>& idx,
+			const octave_value& rhs)
+{
+  return rep->subsasgn (type, idx, rhs);
+}
+
+octave_value
+octave_value::assign (assign_op op, const std::string type,
+		      const SLList<octave_value_list>& idx,
+		      const octave_value& rhs)
+{
+  octave_value retval;
+
+  make_unique ();
+
+  octave_value t_rhs = rhs;
+
+  if (op != op_asn_eq)
+    {
+      // XXX FIXME XXX -- only do the following stuff if we can't find
+      // a specific function to call to handle the op= operation for
+      // the types we have.
+
+      octave_value t = subsref (type, idx);
+
+      if (! error_state)
+	{
+	  binary_op binop = op_eq_to_binary_op (op);
+
+	  if (! error_state)
+	    t_rhs = do_binary_op (binop, t, rhs);
+	}
+    }
+
+  if (! error_state)
+    {
+      if (type[0] == '.' && ! is_map ())
+	{
+	  octave_value tmp = Octave_map ();
+	  retval = tmp.subsasgn (type, idx, t_rhs);
+	}
+      else
+	retval = subsasgn (type, idx, t_rhs);
+    }
+
+  if (error_state)
+    gripe_assign_failed_or_no_method (assign_op_as_string (op),
+				      type_name (), rhs.type_name ());
+
+  return retval;
+}
+
+const octave_value&
 octave_value::assign (assign_op op, const octave_value& rhs)
 {
   if (op == op_asn_eq)
     operator = (rhs);
   else
     {
       // XXX FIXME XXX -- only do the following stuff if we can't find
       // a specific function to call to handle the op= operation for
@@ -598,129 +684,18 @@ octave_value::assign (assign_op op, cons
 	  if (! error_state)
 	    operator = (t);
 	}
 
       if (error_state)
 	gripe_assign_failed_or_no_method (assign_op_as_string (op),
 					  type_name (), rhs.type_name ());
     }
-}
 
-void
-octave_value::simple_assign (octave_value::assign_op orig_op,
-			     const octave_value_list& idx,
-			     const octave_value& rhs)
-{
-  make_unique ();
-
-  bool assignment_ok = try_assignment (op_asn_eq, idx, rhs);
-
-  if (! (error_state || assignment_ok))
-    {
-      assignment_ok = try_assignment_with_conversion (op_asn_eq, idx, rhs);
-
-      if (! (error_state || assignment_ok))
-	gripe_no_conversion (assign_op_as_string (orig_op),
-			     type_name (), rhs.type_name ());
-    }
-}
-
-void
-octave_value::assign (octave_value::assign_op op,
-		      const octave_value_list& idx,
-		      const octave_value& rhs)
-{
-  if (Vresize_on_range_error || is_defined ())
-    {
-      if (op == op_asn_eq)
-	simple_assign (op, idx, rhs);
-      else
-	{
-	  // XXX FIXME XXX -- only do the following stuff if we can't
-	  // find a specific function to call to handle the op=
-	  // operation for the types we have.
-
-	  octave_value t1 = *this;
-
-	  t1 = t1.do_index_op (idx);
-
-	  if (! error_state)
-	    {
-	      binary_op binop = op_eq_to_binary_op (op);
-
-	      if (! error_state)
-		{
-		  octave_value t2 = do_binary_op (binop, t1, rhs);
-
-		  if (! error_state)
-		    {
-		      simple_assign (op, idx, t2);
-
-		      if (error_state)
-			gripe_assign_failed (assign_op_as_string (op),
-					     type_name (), rhs.type_name ());
-		    }
-		  else
-		    gripe_assign_failed_or_no_method (assign_op_as_string (op),
-						      type_name (),
-						      rhs.type_name ());
-		}
-	      else
-		gripe_assign_failed_or_no_method (assign_op_as_string (op),
-						  type_name (),
-						  rhs.type_name ());
-	    }
-	  else
-	    gripe_assign_failed (assign_op_as_string (op),
-				 type_name (), rhs.type_name ());
-	}
-
-      if (! error_state)
-	maybe_mutate ();
-    }
-  else
-    {
-      error ("indexed assignment to previously undefined variables");
-      error ("is only possible when resize_on_range_error is true");
-    }
-}
-
-void
-octave_value::assign_struct_elt (assign_op op, const std::string& elt_nm,
-				 const octave_value& rhs)
-{
-  make_unique ();
-
-  rep->assign_struct_elt (op, elt_nm, rhs);
-}
-
-
-void
-octave_value::assign_struct_elt (assign_op op, const std::string& elt_nm,
-				 const octave_value_list& idx,
-				 const octave_value& rhs)
-{
-  make_unique ();
-
-  rep->assign_struct_elt (op, elt_nm, idx, rhs);
-}
-
-octave_lvalue
-octave_value::struct_elt_ref (const std::string& nm)
-{
-  return rep->struct_elt_ref (this, nm);
-}
-
-octave_lvalue
-octave_value::struct_elt_ref (octave_value *, const std::string&)
-{
-  panic_impossible ();
-
-  return octave_lvalue ();
+  return *this;
 }
 
 Cell
 octave_value::cell_value (void) const
 {
   return rep->cell_value ();
 }
 
@@ -975,196 +950,146 @@ octave_value::print_with_name (std::ostr
 static void
 gripe_indexed_assignment (const std::string& tn1, const std::string& tn2)
 {
   error ("assignment of `%s' to indexed `%s' not implemented",
 	 tn2.c_str (), tn1.c_str ());
 }
 
 static void
-gripe_assign_conversion_failed (const std::string& tn1, const std::string& tn2)
+gripe_assign_conversion_failed (const std::string& tn1,
+				const std::string& tn2)
 {
   error ("type conversion for assignment of `%s' to indexed `%s' failed",
 	 tn2.c_str (), tn1.c_str ());
 }
 
-bool
-octave_value::convert_and_assign (octave_value::assign_op op,
-				  const octave_value_list& idx,
-				  const octave_value& rhs)
-{
-  bool assignment_ok = false;
-
-  int t_lhs = type_id ();
-  int t_rhs = rhs.type_id ();
-
-  int t_result
-    = octave_value_typeinfo::lookup_pref_assign_conv (t_lhs, t_rhs);
-
-  if (t_result >= 0)
-    {
-      type_conv_fcn cf
-	= octave_value_typeinfo::lookup_widening_op (t_lhs, t_result);
-
-      if (cf)
-	{
-	  octave_value *tmp = cf (*rep);
-
-	  if (tmp)
-	    {
-	      octave_value *old_rep = rep;
-	      rep = tmp;
-	      rep->count = 1;
-
-	      assignment_ok = try_assignment (op, idx, rhs);
-
-	      if (! assignment_ok && old_rep)
-		{
-		  if (--rep->count == 0)
-		    delete rep;
-
-		  rep = old_rep;
-		  old_rep = 0;
-		}
-
-	      if (old_rep && --old_rep->count == 0)
-		delete old_rep;
-	    }
-	  else
-	    gripe_assign_conversion_failed (type_name (), rhs.type_name ());
-	}
-      else
-	gripe_indexed_assignment (type_name (), rhs.type_name ());
-    }
-
-  return (assignment_ok && ! error_state);
-}
-
-bool
-octave_value::try_assignment_with_conversion (octave_value::assign_op op,
-					      const octave_value_list& idx,
-					      const octave_value& rhs)
-{
-  bool assignment_ok = convert_and_assign (op, idx, rhs);
-
-  if (! (error_state || assignment_ok))
-    {
-      octave_value tmp_rhs;
-      type_conv_fcn cf_rhs = rhs.numeric_conversion_function ();
-
-      if (cf_rhs)
-	{
-	  octave_value *tmp = cf_rhs (*rhs.rep);
-
-	  if (tmp)
-	    tmp_rhs = octave_value (tmp);
-	  else
-	    {
-	      gripe_assign_conversion_failed (type_name (), rhs.type_name ());
-	      return false;
-	    }
-	}
-      else
-	tmp_rhs = rhs;
-
-      octave_value *old_rep = 0;
-      type_conv_fcn cf_this = numeric_conversion_function ();
-
-      if (cf_this)
-	{
-	  old_rep = rep;
-
-	  octave_value *tmp = cf_this (*rep);
-
-	  if (tmp)
-	    {
-	      rep = tmp;
-	      rep->count = 1;
-	    }
-	  else
-	    {
-	      gripe_assign_conversion_failed (type_name (), rhs.type_name ());
-	      return false;
-	    }
-	}
-
-      if (cf_this || cf_rhs)
-	{
-	  assignment_ok = try_assignment (op, idx, tmp_rhs);
-
-	  if (! (error_state || assignment_ok))
-	    assignment_ok = convert_and_assign (op, idx, tmp_rhs);
-	}
-
-      if (! assignment_ok && old_rep)
-	{
-	  if (--rep->count == 0)
-	    delete rep;
-
-	  rep = old_rep;
-	  old_rep = 0;
-	}
-
-      if (old_rep && --old_rep->count == 0)
-	delete old_rep;
-    }
-
-  return (assignment_ok && ! error_state);
-}
-
-bool
-octave_value::try_assignment (octave_value::assign_op op,
-			      const octave_value_list& idx,
+octave_value
+octave_value::numeric_assign (const std::string type,
+			      const SLList<octave_value_list>& idx,
 			      const octave_value& rhs)
 {
-  bool retval = false;
+  octave_value retval;
 
   int t_lhs = type_id ();
   int t_rhs = rhs.type_id ();
 
   assign_op_fcn f
-    = octave_value_typeinfo::lookup_assign_op (op, t_lhs, t_rhs);
+    = octave_value_typeinfo::lookup_assign_op (op_asn_eq, t_lhs, t_rhs);
+
+  bool done = false;
 
   if (f)
     {
-      f (*rep, idx, *(rhs.rep));
+      f (*this, idx.front (), rhs.get_rep ());
 
-      retval = (! error_state);
+      done = (! error_state);
     }
+
+  if (done)
+    retval = octave_value (this, count + 1);
   else
     {
-      f = octave_value_typeinfo::lookup_assignany_op (op, t_lhs);
+      int t_result
+	= octave_value_typeinfo::lookup_pref_assign_conv (t_lhs, t_rhs);
+
+      if (t_result >= 0)
+	{
+	  type_conv_fcn cf
+	    = octave_value_typeinfo::lookup_widening_op (t_lhs, t_result);
+
+	  if (cf)
+	    {
+	      octave_value *tmp (cf (*this));
 
-      if (f)
+	      if (tmp)
+		{
+		  retval = tmp->subsasgn (type, idx, rhs);
+
+		  done = (! error_state);
+		}
+	      else
+		gripe_assign_conversion_failed (type_name (),
+						rhs.type_name ());
+	    }
+	  else
+	    gripe_indexed_assignment (type_name (), rhs.type_name ());
+	}
+
+      if (! (done || error_state))
 	{
-	  f (*rep, idx, rhs);
+	  octave_value tmp_rhs;
+	  type_conv_fcn cf_rhs = rhs.numeric_conversion_function ();
+
+	  if (cf_rhs)
+	    {
+	      octave_value *tmp = cf_rhs (rhs.get_rep ());
+
+	      if (tmp)
+		tmp_rhs = octave_value (tmp);
+	      else
+		{
+		  gripe_assign_conversion_failed (type_name (),
+						  rhs.type_name ());
+		  return octave_value ();
+		}
+	    }
+	  else
+	    tmp_rhs = rhs;
+
+	  type_conv_fcn cf_this = numeric_conversion_function ();
+
+	  octave_value *tmp_lhs = this;
 
-	  retval = (! error_state);
+	  if (cf_this)
+	    {
+	      octave_value *tmp = cf_this (*this);
+
+	      if (tmp)
+		tmp_lhs = tmp;
+	      else
+		{
+		  gripe_assign_conversion_failed (type_name (),
+						  rhs.type_name ());
+		  return octave_value ();
+		}
+	    }
+
+	  if (cf_this || cf_rhs)
+	    {
+	      retval = tmp_lhs->subsasgn (type, idx, tmp_rhs);
+
+	      done = (! error_state);
+	    }
+	  else
+	    gripe_no_conversion (assign_op_as_string (op_asn_eq),
+				 type_name (), rhs.type_name ());
 	}
     }
 
   return retval;
 }
 
 static void
-gripe_binary_op (const std::string& on, const std::string& tn1, const std::string& tn2)
+gripe_binary_op (const std::string& on, const std::string& tn1,
+		 const std::string& tn2)
 {
   error ("binary operator `%s' not implemented for `%s' by `%s' operations",
 	 on.c_str (), tn1.c_str (), tn2.c_str ());
 }
 
 static void
 gripe_binary_op_conv (const std::string& on)
 {
   error ("type conversion failed for binary operator `%s'", on.c_str ());
 }
 
 octave_value
-do_binary_op (octave_value::binary_op op, const octave_value& v1,
-	      const octave_value& v2)
+do_binary_op (octave_value::binary_op op,
+	      const octave_value& v1, const octave_value& v2)
 {
   octave_value retval;
 
   int t1 = v1.type_id ();
   int t2 = v2.type_id ();
 
   binary_op_fcn f = octave_value_typeinfo::lookup_binary_op (op, t1, t2);
 
@@ -1228,16 +1153,26 @@ do_binary_op (octave_value::binary_op op
       else
 	gripe_binary_op (octave_value::binary_op_as_string (op),
 			 v1.type_name (), v2.type_name ());
     }
 
   return retval;
 }
 
+void
+octave_value::print_info (std::ostream& os, const std::string& prefix) const
+{
+  os << prefix << "type_name: " << type_name () << "\n"
+     << prefix << "count:     " << get_count () << "\n"
+     << prefix << "rep info:  ";
+
+  rep->print_info (os, prefix + " ");
+}
+
 static void
 gripe_unary_op (const std::string& on, const std::string& tn)
 {
   error ("unary operator `%s' not implemented for `%s' operands",
 	 on.c_str (), tn.c_str ());
 }
 
 static void
@@ -1286,24 +1221,25 @@ do_unary_op (octave_value::unary_op op, 
 	gripe_unary_op (octave_value::unary_op_as_string (op),
 			v.type_name ());
     }
 
   return retval;
 }
 
 static void
-gripe_unary_op_conversion_failed (const std::string& op, const std::string& tn)
+gripe_unary_op_conversion_failed (const std::string& op,
+				  const std::string& tn)
 {
   error ("operator %s: type conversion for `%s' failed",
 	 op.c_str (), tn.c_str ());
 }
 
-void
-octave_value::do_non_const_unary_op (octave_value::unary_op op)
+const octave_value&
+octave_value::do_non_const_unary_op (unary_op op)
 {
   octave_value retval;
 
   int t = type_id ();
 
   non_const_unary_op_fcn f
     = octave_value_typeinfo::lookup_non_const_unary_op (op, t);
 
@@ -1354,40 +1290,60 @@ octave_value::do_non_const_unary_op (oct
 	    }
 	  else
 	    gripe_unary_op_conversion_failed
 	      (octave_value::unary_op_as_string (op), type_name ());
 	}
       else
 	gripe_unary_op (octave_value::unary_op_as_string (op), type_name ());
     }
+
+  return *this;
 }
 
+#if 0
 static void
-gripe_unary_op_failed_or_no_method (const std::string& on, const std::string& tn)
+gripe_unary_op_failed_or_no_method (const std::string& on,
+				    const std::string& tn) 
 {
   error ("operator %s: no method, or unable to evaluate for %s operand",
 	 on.c_str (), tn.c_str ());
 }
+#endif
 
 void
-octave_value::do_non_const_unary_op (octave_value::unary_op op,
-				     const octave_value_list& idx)
+octave_value::do_non_const_unary_op (unary_op op, const octave_value_list& idx)
 {
-  // XXX FIXME XXX -- only do the following stuff if we can't find a
-  // specific function to call to handle the op= operation for the
-  // types we have.
+  abort ();
+}
+
+octave_value
+octave_value::do_non_const_unary_op (unary_op op, const std::string type,
+				     const SLList<octave_value_list>& idx)
+{
+  octave_value retval;
+
+  if (idx.empty ())
+    {
+      do_non_const_unary_op (op);
 
-  assign_op assop = unary_op_to_assign_op (op);
+      retval = *this;
+    }
+  else
+    {
+      // XXX FIXME XXX -- only do the following stuff if we can't find a
+      // specific function to call to handle the op= operation for the
+      // types we have.
 
-  if (! error_state)
-    assign (assop, idx, 1.0);
-  else
-    gripe_unary_op_failed_or_no_method (unary_op_as_string (op),
-					type_name ());
+      assign_op assop = unary_op_to_assign_op (op);
+
+      retval = assign (assop, type, idx, 1.0);
+    }
+
+  return retval;
 }
 
 // Current indentation.
 int octave_value::curr_print_indent_level = 0;
 
 // TRUE means we are at the beginning of a line.
 bool octave_value::beginning_of_line = true;
 
@@ -1516,16 +1472,52 @@ octave_value::op_eq_to_binary_op (assign
 	std::string on = assign_op_as_string (op);
 	error ("operator %s: no binary operator found", on.c_str ());
       }
     }
 
   return binop;
 }
 
+octave_value
+octave_value::empty_conv (const std::string& type, const octave_value& rhs)
+{
+  octave_value retval;
+
+  if (type.length () > 0)
+    {
+      switch (type[0])
+	{
+	case '(':
+	  {
+	    if (type.length () > 1 && type[1] == '.')
+	      retval = Octave_map ();
+	    else
+	      retval = octave_value (rhs.empty_clone ());
+	  }
+	  break;
+
+	case '{':
+	  retval = Cell ();
+	  break;
+
+	case '.':
+	  retval = Octave_map ();
+	  break;
+
+	default:
+	  panic_impossible ();
+	}
+    }
+  else
+    retval = octave_value (rhs.empty_clone ());
+
+  return retval;
+}
+
 void
 install_types (void)
 {
   octave_base_value::register_type ();
   octave_cell::register_type ();
   octave_scalar::register_type ();
   octave_complex::register_type ();
   octave_matrix::register_type ();
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -33,16 +33,18 @@ Software Foundation, 59 Temple Place - S
 #include <string>
 
 #include "Range.h"
 #include "idx-vector.h"
 #include "mx-base.h"
 #include "oct-alloc.h"
 #include "str-vec.h"
 
+#include "SLList.h"
+
 class Cell;
 class Octave_map;
 class octave_stream;
 class octave_function;
 class octave_value_list;
 class octave_lvalue;
 
 // Constants.
@@ -142,16 +144,19 @@ public:
   };
 
   static std::string unary_op_as_string (unary_op);
 
   static std::string binary_op_as_string (binary_op);
 
   static std::string assign_op_as_string (assign_op);
 
+  static octave_value empty_conv (const std::string& type,
+				  const octave_value& rhs = octave_value ());
+
   enum magic_colon { magic_colon_t };
   enum all_va_args { all_va_args_t };
 
   octave_value (void);
   octave_value (double d);
   octave_value (const Cell& m);
   octave_value (const Matrix& m);
   octave_value (const DiagMatrix& d);
@@ -173,35 +178,38 @@ public:
   octave_value (const Range& r);
   octave_value (const Octave_map& m);
   octave_value (const octave_stream& s, int n);
   octave_value (octave_function *f);
   octave_value (const octave_value_list& m);
   octave_value (octave_value::magic_colon);
   octave_value (octave_value::all_va_args);
 
-  octave_value (octave_value *new_rep);
+  octave_value (octave_value *new_rep, int count = 1);
 
   // Copy constructor.
 
   octave_value (const octave_value& a)
     {
       rep = a.rep;
       rep->count++;
     }
 
+  // This should only be called for derived types.
+
+  virtual octave_value *clone (void) const;
+
+  virtual octave_value *empty_clone (void) const
+    { return rep->empty_clone (); }
+
   // Delete the representation of this constant if the count drops to
   // zero.
 
   virtual ~octave_value (void);
 
-  // This should only be called for derived types.
-
-  virtual octave_value *clone (void);
-
   void make_unique (void)
     {
       if (rep->count > 1)
 	{
 	  --rep->count;
 	  rep = rep->clone ();
 	  rep->count = 1;
 	}
@@ -218,64 +226,70 @@ public:
 
 	  rep = a.rep;
 	  rep->count++;
 	}
 
       return *this;
     }
 
-  int get_count (void) { return rep->count; }
+  int get_count (void) const { return rep->count; }
 
   virtual type_conv_fcn numeric_conversion_function (void) const
     { return rep->numeric_conversion_function (); }
 
   void maybe_mutate (void);
 
   virtual octave_value *try_narrowing_conversion (void)
     { return rep->try_narrowing_conversion (); }
 
-  virtual octave_value do_index_op (const octave_value_list& idx)
-    { return rep->do_index_op (idx); }
+  virtual octave_value subsref (const std::string type,
+				const SLList<octave_value_list>& idx)
+    { return rep->subsref (type, idx); }
+
+  octave_value subsref (const std::string type, const octave_value_list& idx)
+    {
+      SLList<octave_value_list> i;
+
+      i.append (idx);
+
+      return rep->subsref (type, i);
+    }
+
+  virtual octave_value_list subsref (const std::string type,
+				     const SLList<octave_value_list>& idx,
+    				     int nargout);
+
+  octave_value next_subsref (const std::string type, const
+			     SLList<octave_value_list>& idx,
+			     int skip = 1);
+
+  virtual octave_value do_index_op (const octave_value_list& idx,
+				    int resize_ok)
+    { return rep->do_index_op (idx, resize_ok); }
+
+  octave_value do_index_op (const octave_value_list& idx)
+    { return do_index_op (idx, 0); }
 
   virtual octave_value_list
   do_multi_index_op (int nargout, const octave_value_list& idx);
 
-  void assign (assign_op, const octave_value& rhs);
-
-  void assign (assign_op, const octave_value_list& idx,
-	       const octave_value& rhs);
+  virtual octave_value subsasgn (const std::string type,
+				 const SLList<octave_value_list>& idx,
+				 const octave_value& rhs);
 
-  virtual void
-  assign_struct_elt (assign_op, const std::string& elt_nm,
-		     const octave_value& rhs);
+  octave_value assign (assign_op op, const std::string type,
+		       const SLList<octave_value_list>& idx,
+		       const octave_value& rhs);
 
-  virtual void
-  assign_struct_elt (assign_op, const std::string& elt_nm,
-		     const octave_value_list& idx,
-		     const octave_value& rhs);
+  const octave_value& assign (assign_op, const octave_value& rhs);
 
   virtual idx_vector index_vector (void) const
     { return rep->index_vector (); }
 
-  virtual octave_value
-  do_struct_elt_index_op (const std::string& nm, bool silent = false)
-    { return rep->do_struct_elt_index_op (nm, silent); }
-
-  virtual octave_value
-  do_struct_elt_index_op (const std::string& nm,
-			  const octave_value_list& idx,
-			  bool silent = false)
-    { return rep->do_struct_elt_index_op (nm, idx, silent); }
-
-  octave_lvalue struct_elt_ref (const std::string& nm);
-
-  virtual octave_lvalue
-  struct_elt_ref (octave_value *parent, const std::string& nm);
-
   // Size.
 
   virtual int rows (void) const
     { return rep->rows (); }
 
   virtual int columns (void) const
     { return rep->columns (); }
 
@@ -428,16 +442,19 @@ public:
   virtual std::string string_value (void) const
     { return rep->string_value (); }
 
   virtual Range range_value (void) const
     { return rep->range_value (); }
 
   virtual Octave_map map_value (void) const;
 
+  virtual string_vector map_keys (void) const
+    { return rep->map_keys (); }
+
   virtual octave_stream stream_value (void) const;
 
   virtual int stream_number (void) const;
 
   virtual octave_function *function_value (bool silent = false);
 
   virtual octave_value_list list_value (void) const;
 
@@ -490,34 +507,45 @@ public:
 			bool print_padding = true) const;
 
   virtual int type_id (void) const { return rep->type_id (); }
 
   virtual std::string type_name (void) const { return rep->type_name (); }
 
   // Unary and binary operations.
 
-  friend octave_value do_unary_op (octave_value::unary_op,
-				   const octave_value&);
+  friend octave_value do_unary_op (unary_op op,
+				   const octave_value& a);
 
-  void do_non_const_unary_op (octave_value::unary_op);
+  const octave_value& do_non_const_unary_op (unary_op op);
+
+  void do_non_const_unary_op (unary_op op, const octave_value_list& idx);
 
-  void do_non_const_unary_op (octave_value::unary_op,
-			      const octave_value_list& idx);
+  octave_value do_non_const_unary_op (unary_op op, const std::string type,
+				      const SLList<octave_value_list>& idx);
 
-  friend octave_value do_binary_op (octave_value::binary_op,
-				    const octave_value&,
-				    const octave_value&);
+  friend octave_value do_binary_op (binary_op op,
+				    const octave_value& a,
+				    const octave_value& b);
 
   const octave_value& get_rep (void) const { return *rep; }
 
+  virtual void print_info (std::ostream& os,
+			   const std::string& prefix = std::string ()) const;
+
 protected:
 
   octave_value (const octave_xvalue&) : rep (0) { }
 
+  // This should only be called for derived types.
+
+  octave_value numeric_assign (const std::string type,
+			       const SLList<octave_value_list>& idx,
+			       const octave_value& rhs);
+
   void reset_indent_level (void) const
     { curr_print_indent_level = 0; }
 
   void increment_indent_level (void) const
     { curr_print_indent_level += 2; }
 
   void decrement_indent_level (void) const
     { curr_print_indent_level -= 2; }
@@ -526,44 +554,31 @@ protected:
     { return curr_print_indent_level; }
 
   void newline (std::ostream& os) const;
 
   void indent (std::ostream& os) const;
 
   void reset (void) const;
 
-private:
-
   union
     {
       octave_value *rep;      // The real representation.
       int count;              // A reference count.
     };
 
-  bool convert_and_assign (assign_op, const octave_value_list& idx,
-			   const octave_value& rhs);
-
-  bool try_assignment_with_conversion (assign_op,
-				       const octave_value_list& idx,
-				       const octave_value& rhs);
-
-  bool try_assignment (assign_op, const octave_value_list& idx,
-		       const octave_value& rhs);
+private:
 
   static int curr_print_indent_level;
   static bool beginning_of_line;
 
   assign_op unary_op_to_assign_op (unary_op op);
 
   binary_op op_eq_to_binary_op (assign_op op);
 
-  void simple_assign (assign_op orig_op, const octave_value_list& idx,
-		      const octave_value& rhs);
-
   DECLARE_OCTAVE_ALLOCATOR
 };
 
 #define OV_UNOP_FN(name) \
   inline octave_value \
   name (const octave_value& a) \
   { \
     return do_unary_op (octave_value::name, a); \
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -275,18 +275,18 @@ finish_function (tree_parameter_list *re
 		 octave_user_function *fcn, octave_comment_list *lc);
 
 // Reset state after parsing function.
 static void
 recover_from_parsing_function (void);
 
 // Make an index expression.
 static tree_index_expression *
-make_index_expression (tree_expression *expr, tree_argument_list *args,
-		       tree_index_expression::type);
+make_index_expression (tree_expression *expr,
+		       tree_argument_list *args, char type);
 
 // Make an indirect reference expression.
 static tree_index_expression *
 make_indirect_ref (tree_expression *expr, const std::string&);
 
 // Make a declaration command.
 static tree_decl_command *
 make_decl_command (int tok, token *tok_val, tree_decl_init_list *lst);
@@ -692,35 +692,23 @@ arg_list	: expression
 
 parsing_indir	: // empty
 		  { lexer_flags.looking_at_indirect_ref = true; }
 		;
 
 postfix_expr	: primary_expr
 		  { $$ = $1; }
 		| postfix_expr '(' ')'
-		  {
-		    $$ = make_index_expression ($1, 0,
-						tree_index_expression::paren);
-		  }
+		  { $$ = make_index_expression ($1, 0, '('); }
 		| postfix_expr '(' arg_list ')'
-		  {
-		    $$ = make_index_expression ($1, $3,
-						tree_index_expression::paren);
-		  }
+		  { $$ = make_index_expression ($1, $3, '('); }
 		| postfix_expr '{' '}'
-		  {
-		    $$ = make_index_expression ($1, 0,
-						tree_index_expression::brace);
-		  }
+		  { $$ = make_index_expression ($1, 0, '{'); }
 		| postfix_expr '{' arg_list '}'
-		  {
-		    $$ = make_index_expression ($1, $3,
-						tree_index_expression::brace);
-		  }
+		  { $$ = make_index_expression ($1, $3, '{'); }
 		| postfix_expr PLUS_PLUS
 		  { $$ = make_postfix_op (PLUS_PLUS, $1, $2); }
 		| postfix_expr MINUS_MINUS
 		  { $$ = make_postfix_op (MINUS_MINUS, $1, $2); }
 		| postfix_expr QUOTE
 		  { $$ = make_postfix_op (QUOTE, $1, $2); }
 		| postfix_expr TRANSPOSE
 		  { $$ = make_postfix_op (TRANSPOSE, $1, $2); }
@@ -847,20 +835,17 @@ assign_expr	: assign_lhs '=' expression
 		  { $$ = make_assign_op (ELEFTDIV_EQ, $1, $2, $3); }
 		| assign_lhs AND_EQ expression
 		  { $$ = make_assign_op (AND_EQ, $1, $2, $3); }
 		| assign_lhs OR_EQ expression
 		  { $$ = make_assign_op (OR_EQ, $1, $2, $3); }
 		;
 
 word_list_cmd	: identifier word_list
-		  {
-		    $$ = make_index_expression ($1, $2,
-						tree_index_expression::paren);
-		  }
+		  { $$ = make_index_expression ($1, $2, '('); }
 		;
 
 word_list	: TEXT
 		  {
 		    tree_constant *tmp = make_constant (TEXT, $1);
 		    $$ = new tree_argument_list (tmp);
 		  }
 		| word_list TEXT
@@ -2586,41 +2571,59 @@ recover_from_parsing_function (void)
   lexer_flags.looking_at_return_list = false;
   lexer_flags.looking_at_parameter_list = false;
 }
 
 // Make an index expression.
 
 static tree_index_expression *
 make_index_expression (tree_expression *expr, tree_argument_list *args,
-		       tree_index_expression::type t)
+		       char type)
 {
   tree_index_expression *retval = 0;
 
   int l = expr->line ();
   int c = expr->column ();
 
   expr->mark_postfix_indexed ();
 
-  retval =  new tree_index_expression (expr, args, l, c, t);
+  if (expr->is_index_expression ())
+    {
+      tree_index_expression *tmp = static_cast<tree_index_expression *> (expr);
+
+      tmp->append (args, type);
+
+      retval = tmp;
+    }
+  else
+    retval = new tree_index_expression (expr, args, l, c, type);
 
   return retval;
 }
 
 // Make an indirect reference expression.
 
 static tree_index_expression *
 make_indirect_ref (tree_expression *expr, const std::string& elt)
 {
   tree_index_expression *retval = 0;
 
   int l = expr->line ();
   int c = expr->column ();
 
-  retval = new tree_index_expression (expr, elt, l, c);
+  if (expr->is_index_expression ())
+    {
+      tree_index_expression *tmp = static_cast<tree_index_expression *> (expr);
+
+      tmp->append (elt);
+
+      retval = tmp;
+    }
+  else
+    retval = new tree_index_expression (expr, elt, l, c);
 
   lexer_flags.looking_at_indirect_ref = false;
 
   return retval;
 }
 
 // Make a declaration command.
 
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -33,22 +33,22 @@ Software Foundation, 59 Temple Place - S
 #include <iostream>
 #include <strstream>
 #include <string>
 
 #include "CMatrix.h"
 #include "Range.h"
 #include "cmd-edit.h"
 #include "dMatrix.h"
-#include "Cell.h"
 #include "lo-mappers.h"
 #include "mach-info.h"
 #include "oct-cmplx.h"
 #include "str-vec.h"
 
+#include "Cell.h"
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "oct-stream.h"
 #include "pager.h"
 #include "pr-output.h"
 #include "sysdep.h"
@@ -1750,47 +1750,20 @@ octave_print_internal (std::ostream& os,
 	os << " ]";
     }
   else
     {
       os << "sorry, printing char matrices not implemented yet\n";
     }
 }
 
-void
-octave_print_internal (std::ostream& os, const Cell& cell_val,
-		       bool pr_as_read_syntax, int extra_indent)
+extern void
+octave_print_internal (std::ostream&, const Cell&, bool, int, bool)
 {
-  int nr = cell_val.rows ();
-  int nc = cell_val.columns();
-
-  if (nr > 0 && nc > 0)
-    {
-      os << "{\n";
-
-      for (int j = 0; j < nc; j++)
-	{
-	  for (int i = 0; i < nr; i++)
-	    {
-	      std::ostrstream buf;
-	      buf << "[" << i+1 << "," << j+1 << "]" << std::ends;
-	      const char *nm = buf.str ();
-
-	      octave_value val = cell_val(i,j);
-
-	      val.print_with_name (os, nm);
-
-	      delete [] nm;
-	    }
-	}
-
-      os << "}";
-    }
-  else
-    os << "{}";
+  panic_impossible ();
 }
 
 DEFUN (disp, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} disp (@var{x})\n\
 Display the value of @var{x}.  For example,\n\
 \n\
 @example\n\
diff --git a/src/pr-output.h b/src/pr-output.h
--- a/src/pr-output.h
+++ b/src/pr-output.h
@@ -64,19 +64,20 @@ octave_print_internal (std::ostream& os,
 
 extern void
 octave_print_internal (std::ostream& os, const charMatrix& chm,
 		       bool pr_as_read_syntax = false,
 		       int extra_indent = 0,
 		       bool pr_as_string = false);
 
 extern void
-octave_print_internal (std::ostream& os, const Cell& c,
+octave_print_internal (std::ostream& os, const Cell& cell,
 		       bool pr_as_read_syntax = false,
-		       int extra_indent = 0);
+		       int extra_indent = 0,
+		       bool pr_as_string = false);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pt-assign.h b/src/pt-assign.h
--- a/src/pt-assign.h
+++ b/src/pt-assign.h
@@ -54,25 +54,23 @@ public:
   tree_simple_assignment (tree_expression *le, tree_expression *re,
 			  bool plhs = false, int l = -1, int c = -1,
 			  octave_value::assign_op t = octave_value::op_asn_eq)
     : tree_expression (l, c), lhs (le), rhs (re), preserve (plhs),
       etype (t) { }
 
   ~tree_simple_assignment (void);
 
-  bool rvalue_ok (void) const
-    { return true; }
+  bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
-  bool is_assignment_expression (void) const
-    { return true; }
+  bool is_assignment_expression (void) const { return true; }
 
   void eval_error (void);
 
   std::string oper (void) const;
 
   tree_expression *left_hand_side (void) { return lhs; }
 
   tree_expression *right_hand_side (void) { return rhs; }
@@ -122,21 +120,19 @@ public:
   tree_multi_assignment (tree_argument_list *lst, tree_expression *r,
 			 bool plhs = false, int l = -1, int c = -1,
 			  octave_value::assign_op t = octave_value::op_asn_eq)
     : tree_expression (l, c), lhs (lst), rhs (r), preserve (plhs),
       etype (t) { }
 
   ~tree_multi_assignment (void);
 
-  bool is_assignment_expression (void) const
-    { return true; }
+  bool is_assignment_expression (void) const { return true; }
 
-  bool rvalue_ok (void) const
-    { return true; }
+  bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   void eval_error (void);
 
   std::string oper (void) const;
diff --git a/src/pt-binop.h b/src/pt-binop.h
--- a/src/pt-binop.h
+++ b/src/pt-binop.h
@@ -57,18 +57,17 @@ public:
     : tree_expression (l, c), op_lhs (a), op_rhs (b), etype (t) { }
 
   ~tree_binary_expression (void)
     {
       delete op_lhs;
       delete op_rhs;
     }
 
-  bool rvalue_ok (void) const
-    { return true; }
+  bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   void eval_error (void);
 
   std::string oper (void) const;
@@ -114,18 +113,17 @@ public:
     : tree_binary_expression (l, c), etype (t) { }
 
   tree_boolean_expression (tree_expression *a, tree_expression *b,
 			   int l = -1, int c = -1, type t = unknown)
     : tree_binary_expression (a, b, l, c), etype (t) { }
 
   ~tree_boolean_expression (void) { }
 
-  bool rvalue_ok (void) const
-    { return true; }
+  bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   std::string oper (void) const;
 
 private:
diff --git a/src/pt-bp.cc b/src/pt-bp.cc
--- a/src/pt-bp.cc
+++ b/src/pt-bp.cc
@@ -340,32 +340,31 @@ tree_breakpoint::visit_if_command_list (
 }
 
 void 
 tree_breakpoint::visit_index_expression (tree_index_expression& cmd)
 {
   if (found)
     return;
 
-  if (cmd.expr_type () == tree_index_expression::dot)
-    {
-      if (cmd.line () >= line)
-	take_action (cmd);
-    }
-  else
+  tree_expression *expr = cmd.expression ();
+
+  if (expr && expr->line () >= line)
+    take_action (*expr);
+
+  SLList<tree_argument_list *> lst = cmd.arg_lists ();
+
+  if (! lst.empty ())
     {
-      tree_expression *expr = cmd.expression ();
-
-      if (expr && expr->line () >= line)
-	take_action (*expr);
+      for (Pix p = lst.first (); p != 0; lst.next (p))
+	{
+	  tree_argument_list *elt = lst(p);
 
-      tree_argument_list *lst = cmd.arg_list ();
-
-      if (lst)
-	lst->accept (*this);
+	  elt->accept (*this);
+	}
     }
 }
 
 void 
 tree_breakpoint::visit_matrix (tree_matrix& mat)
 {
   if (found)
     return;
diff --git a/src/pt-cell.h b/src/pt-cell.h
--- a/src/pt-cell.h
+++ b/src/pt-cell.h
@@ -45,18 +45,17 @@ class
 tree_cell : public tree_matrix
 {
 public:
 
   tree_cell (tree_argument_list *row = 0, int line = -1, int column = -1) : tree_matrix (row, line, column) { }
 
   ~tree_cell (void) { }
 
-  bool rvalue_ok (void) const
-    { return true; }
+  bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int);
 
   void accept (tree_walker& tw);
 
 private:
diff --git a/src/pt-check.cc b/src/pt-check.cc
--- a/src/pt-check.cc
+++ b/src/pt-check.cc
@@ -243,20 +243,29 @@ tree_checker::visit_if_command_list (tre
 void
 tree_checker::visit_index_expression (tree_index_expression& expr)
 {
   tree_expression *e = expr.expression ();
 
   if (e)
     e->accept (*this);
 
-  tree_argument_list *list = expr.arg_list ();
+  SLList<tree_argument_list *> lst = expr.arg_lists ();
+
+  Pix p = lst.first ();
 
-  if (list)
-    list->accept (*this);
+  while (p)
+    {
+      tree_argument_list *elt = lst (p);
+
+      if (elt)
+	elt->accept (*this);
+
+      lst.next (p);
+    }
 }
 
 void
 tree_checker::visit_matrix (tree_matrix& lst)
 {
   Pix p = lst.first ();
 
   while (p)
diff --git a/src/pt-colon.h b/src/pt-colon.h
--- a/src/pt-colon.h
+++ b/src/pt-colon.h
@@ -60,18 +60,17 @@ public:
       delete op_limit;
       delete op_increment;
     }
 
   void preserve_base (void) { save_base = true; }
 
   tree_colon_expression *append (tree_expression *t);
 
-  bool rvalue_ok (void) const
-    { return true; }
+  bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   void eval_error (const std::string& s = std::string ());
 
   tree_expression *base (void) { return op_base; }
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -49,57 +49,50 @@ public:
   tree_constant (int l = -1, int c = -1)
     : tree_expression (l, c), val (), orig_text () { }
 
   tree_constant (const octave_value& v, int l = -1, int c = -1)
     : tree_expression (l, c), val (v), orig_text () { }
 
   ~tree_constant (void) { }
 
-  void *operator new (size_t size)
-    { return allocator.alloc (size); }
+  void *operator new (size_t size) { return allocator.alloc (size); }
 
-  void operator delete (void *p, size_t size)
-    { allocator.free (p, size); }
+  void operator delete (void *p, size_t size) { allocator.free (p, size); }
 
   // Type.  It would be nice to eliminate the need for this.
 
-  bool is_constant (void) const
-    { return true; }
+  bool is_constant (void) const { return true; }
 
-  void maybe_mutate (void)
-    { val.maybe_mutate (); }
+  void maybe_mutate (void) { val.maybe_mutate (); }
 
   void print (std::ostream& os, bool pr_as_read_syntax = false,
 	      bool pr_orig_txt = true);
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
 		  bool pr_orig_txt = true);
 
-  bool rvalue_ok (void) const
-    { return true; }
+  bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void)
     {
       MAYBE_DO_BREAKPOINT;
       return val;
     }
 
   octave_value_list rvalue (int nargout);
 
   void accept (tree_walker& tw);
 
   // Store the original text corresponding to this constant for later
   // pretty printing.
 
-  void stash_original_text (const std::string& s)
-    { orig_text = s; }
+  void stash_original_text (const std::string& s) { orig_text = s; }
 
-  std::string original_text (void) const
-    { return orig_text; }
+  std::string original_text (void) const { return orig_text; }
 
 private:
 
   // For custom memory management.
   static octave_allocator allocator;
 
   // The actual value that this constant refers to.
   octave_value val;
diff --git a/src/pt-exp.h b/src/pt-exp.h
--- a/src/pt-exp.h
+++ b/src/pt-exp.h
@@ -42,65 +42,49 @@ tree_expression : public tree
 public:
 
   tree_expression (int l = -1, int c = -1)
     : tree (l, c), num_parens (0), postfix_indexed (false),
       print_flag (false) { }
 
   virtual ~tree_expression (void) { }
 
-  virtual bool is_constant (void) const
-    { return false; }
+  virtual bool is_constant (void) const { return false; }
 
-  virtual bool is_matrix_constant (void) const
-    { return false; }
+  virtual bool is_matrix_constant (void) const { return false; }
 
-  virtual bool is_identifier (void) const
-    { return false; }
+  virtual bool is_identifier (void) const { return false; }
 
-  virtual bool is_index_expression (void) const
-    { return false; }
-
-  virtual bool is_indirect_ref (void) const
-    { return false; }
+  virtual bool is_index_expression (void) const { return false; }
 
-  virtual bool is_assignment_expression (void) const
-    { return false; }
+  virtual bool is_assignment_expression (void) const { return false; }
 
-  virtual bool is_prefix_expression (void) const
-    { return false; }
+  virtual bool is_prefix_expression (void) const { return false; }
 
   virtual bool is_logically_true (const char *);
 
-  virtual bool lvalue_ok (void) const
-    { return false; }
+  virtual bool lvalue_ok (void) const { return false; }
 
-  virtual bool rvalue_ok (void) const
-    { return false; }
+  virtual bool rvalue_ok (void) const { return false; }
 
   virtual octave_value rvalue (void);
 
   virtual octave_value_list rvalue (int nargout);
 
   virtual octave_lvalue lvalue (void);
 
-  int paren_count (void) const
-    { return num_parens; }
+  int paren_count (void) const { return num_parens; }
 
-  bool is_postfix_indexed (void) const
-    { return postfix_indexed; }
+  bool is_postfix_indexed (void) const { return postfix_indexed; }
 
-  bool print_result (void) const
-    { return print_flag; }
+  bool print_result (void) const { return print_flag; }
 
-  virtual std::string oper (void) const
-    { return "<unknown>"; }
+  virtual std::string oper (void) const { return "<unknown>"; }
 
-  virtual std::string name (void) const
-    { return "<unknown>"; }
+  virtual std::string name (void) const { return "<unknown>"; }
 
   virtual std::string original_text (void) const;
 
   tree_expression *mark_in_parens (void)
     {
       num_parens++;
       return this;
     }
diff --git a/src/pt-id.h b/src/pt-id.h
--- a/src/pt-id.h
+++ b/src/pt-id.h
@@ -51,18 +51,17 @@ public:
   tree_identifier (int l = -1, int c = -1)
     : tree_expression (l, c), sym (0) { }
 
   tree_identifier (symbol_record *s, int l = -1, int c = -1)
     : tree_expression (l, c), sym (s) { }
 
   ~tree_identifier (void) { }
 
-  bool is_identifier (void) const
-    { return true; }
+  bool is_identifier (void) const { return true; }
 
   std::string name (void) const;
 
   tree_identifier *define (octave_function *f, unsigned int sym_type);
 
   void document (const std::string& s);
 
   bool is_defined (void);
@@ -76,18 +75,17 @@ public:
 
   void mark_as_static (void);
 
   void mark_as_formal_parameter (void);
 
   // We really need to know whether this symbol referst to a variable
   // or a function, but we may not know that yet.
 
-  bool lvalue_ok (void) const
-    { return true; }
+  bool lvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   octave_lvalue lvalue (void);
 
   void eval_undefined_error (void);
diff --git a/src/pt-idx.cc b/src/pt-idx.cc
--- a/src/pt-idx.cc
+++ b/src/pt-idx.cc
@@ -23,133 +23,235 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
+#include "Cell.h"
 #include "error.h"
 #include "oct-map.h"
 #include "oct-obj.h"
 #include "oct-lvalue.h"
 #include "ov.h"
 #include "pager.h"
 #include "pt-arg-list.h"
 #include "pt-bp.h"
 #include "pt-idx.h"
 #include "pt-walk.h"
 #include "utils.h"
 #include "variables.h"
 
+#include "SLList.cc"
+
+template class SLNode<string_vector>;
+template class SLList<string_vector>;
+
 // Index expressions.
 
 tree_index_expression::tree_index_expression (tree_expression *e,
 					      tree_argument_list *lst,
-					      int l, int c, type t)
-  : tree_expression (l, c), expr (e), list (lst),
-    itype (t), arg_nm (lst ? lst->get_arg_names () : string_vector ()) { }
+					      int l, int c, char t)
+  : tree_expression (l, c), expr (e), args (), type (), arg_nm ()
+{
+  append (lst, t);
+}
 
 tree_index_expression::tree_index_expression (tree_expression *e,
 					      const std::string& n,
 					      int l = -1, int c = -1)
-  : tree_expression (l, c), expr (e), list (0), itype (dot),
-    arg_nm (n) { }
+  : tree_expression (l, c), expr (e), args (), type (), arg_nm ()
+{
+  append (n);
+}
+
+void
+tree_index_expression::append (tree_argument_list *lst, char t)
+{
+  args.append (lst);
+  type.append (1, t);
+  arg_nm.append (lst ? lst->get_arg_names () : string_vector ());
+}
+
+void
+tree_index_expression::append (const std::string& n)
+{
+  args.append (static_cast<tree_argument_list *> (0));
+  type.append (".");
+  arg_nm.append (n);
+}
 
 tree_index_expression::~tree_index_expression (void)
 {
   delete expr;
-  delete list;
+
+  while (! args.empty ())
+    {
+      tree_argument_list *t = args.remove_front ();
+      delete t;
+    }
 }
 
 // This is useful for printing the name of the variable in an indexed
 // assignment.
 
 std::string
 tree_index_expression::name (void) const
 {
   // ??? FIXME ???
   std::string xname = expr->name ();
 
-  return (! dot || xname == "<unknown>") ? xname : xname + "." + arg_nm(0);
+  return (type[0] != '.' || xname == "<unknown>")
+    ? xname : xname + "." + arg_nm.front ()(0);
+}
+
+static Cell
+make_subs_cell (tree_argument_list *args, const string_vector& arg_nm)
+{
+  Cell retval;
+
+  octave_value_list arg_values;
+
+  if (args)
+    arg_values = args->convert_to_const_vector ();
+
+  if (! error_state)
+    {
+      int n = arg_values.length ();
+
+      if (n > 0)
+	{
+	  arg_values.stash_name_tags (arg_nm);
+
+	  retval.resize (1, n);
+
+	  for (int i = 0; i < n; i++)
+	    retval(0,i) = arg_values(i);
+	}
+    }
+
+  return retval;
+}
+
+static inline octave_value_list
+make_value_list (tree_argument_list *args, const string_vector& arg_nm)
+{
+  octave_value_list retval;
+
+  if (args)
+    retval = args->convert_to_const_vector ();
+
+  if (! error_state)
+    {
+      int n = retval.length ();
+
+      if (n > 0)
+	retval.stash_name_tags (arg_nm);
+    }
+
+  return retval;
+}
+
+Octave_map
+tree_index_expression::make_arg_struct (void) const
+{
+  int n = args.length ();
+
+  octave_value_list subs_list (n, octave_value ());
+  octave_value_list type_list (n, octave_value ());
+
+  Pix p_args = args.first ();
+  Pix p_arg_nm = arg_nm.first ();
+
+  Octave_map m;
+
+  for (int i = 0; i < n; i++)
+    {
+      switch (type[i])
+	{
+	case '(':
+	  subs_list(i) = make_subs_cell (args(p_args), arg_nm(p_arg_nm));
+	  break;
+
+	case '{':
+	  subs_list(i) = make_subs_cell (args(p_args), arg_nm(p_arg_nm));
+	  break;
+
+	case '.':
+	  subs_list(i) = arg_nm(p_arg_nm)(0);
+	  break;
+
+	default:
+	  panic_impossible ();
+	}
+
+      if (error_state)
+	return m;
+
+      args.next (p_args);
+      arg_nm.next (p_arg_nm);
+    }
+
+  m ["subs"] = subs_list;
+  m ["type"] = type_list;
+
+  return m;
 }
 
 octave_value_list
 tree_index_expression::rvalue (int nargout)
 {
   octave_value_list retval;
 
   if (error_state)
     return retval;
 
   octave_value tmp = expr->rvalue ();
 
   if (! error_state)
     {
-      if (itype == dot)
-	{
-	  MAYBE_DO_BREAKPOINT;
+      SLList<octave_value_list> idx;
 
-	  if (nargout > 1)
-	    error ("invalid number of output arguments for structure reference");
-	  else
-	    {
-	      octave_value_list tmp = expr->rvalue (nargout);
+      int n = args.length ();
+
+      Pix p_args = args.first ();
+      Pix p_arg_nm = arg_nm.first ();
 
-	      if (tmp.empty ())
-		eval_error ();
-	      else
-		{
-		  octave_value val = tmp(0).do_struct_elt_index_op (arg_nm(0));
+      for (int i = 0; i < n; i++)
+	{
+	  switch (type[i])
+	    {
+	    case '(':
+	      idx.append (make_value_list (args(p_args), arg_nm(p_arg_nm)));
+	      break;
 
-		  if (print_result () && nargout == 0 && val.is_defined ())
-		    {
-		      // ??? FIXME ???
-
-		      std::string xname = name ();
-
-		      if (xname == "<unknown>")
-			bind_ans (val, true);
-		      else
-			val.print_with_name (octave_stdout, xname);
-		    }
+	    case '{':
+	      idx.append (make_value_list (args(p_args), arg_nm(p_arg_nm)));
+	      break;
 
-		  retval = val;
-		}
-	    }
-	}
-      else if (itype == paren || itype == brace)
-	{
-	  octave_value_list args;
+	    case '.':
+	      idx.append (arg_nm(p_arg_nm)(0));
+	      break;
 
-	  if (list)
-	    args = list->convert_to_const_vector ();
-
-	  if (! error_state)
-	    {
-	      if (! args.empty ())
-		args.stash_name_tags (arg_nm);
+	    default:
+	      panic_impossible ();
+	    }
 
-	      // XXX FIXME XXX -- is this the right thing to do?
-	      if (tmp.is_constant ())
-		retval = tmp.do_index_op (args);
-	      else
-		retval = tmp.do_multi_index_op (nargout, args);
-	    }
-	  else
-	    eval_error ();
+	  if (error_state)
+	    break;
+
+	  args.next (p_args);
+	  arg_nm.next (p_arg_nm);
 	}
-#if 0
-      else
-	panic_impossible ();
-#endif
+
+      if (! error_state)
+	retval = tmp.subsref (type, idx, nargout);
     }
-  else
-    eval_error ();
 
   return retval;
 }
 
 octave_value
 tree_index_expression::rvalue (void)
 {
   octave_value retval;
@@ -162,63 +264,74 @@ tree_index_expression::rvalue (void)
   return retval;
 }
 
 octave_lvalue
 tree_index_expression::lvalue (void)
 {
   octave_lvalue retval;
 
+  SLList<octave_value_list> idx;
+
+  int n = args.length ();
+
+  Pix p_args = args.first ();
+  Pix p_arg_nm = arg_nm.first ();
+
+  for (int i = 0; i < n; i++)
+    {
+      switch (type[i])
+	{
+	case '(':
+	  idx.append (make_value_list (args(p_args), arg_nm(p_arg_nm)));
+	  break;
+
+	case '{':
+	  idx.append (make_value_list (args(p_args), arg_nm(p_arg_nm)));
+	  break;
+
+	case '.':
+	  idx.append (arg_nm(p_arg_nm)(0));
+	  break;
+
+	default:
+	  panic_impossible ();
+	}
+
+      if (error_state)
+	break;
+
+      args.next (p_args);
+      arg_nm.next (p_arg_nm);
+    }
+
   if (! error_state)
     {
-      if (itype == dot)
-	{
-	  octave_lvalue tmp = expr->lvalue ();
-
-	  if (tmp.is_undefined () || ! tmp.is_map ())
-	    tmp.define (Octave_map ());
-
-	  retval = tmp.struct_elt_ref (arg_nm(0));
-	}
-      else if (itype == paren || itype == brace)
-	{
-	  retval = expr->lvalue ();
+      retval = expr->lvalue ();
 
-	  if (! error_state)
-	    {
-	      octave_value_list args;
-	  
-	      if (list)
-		args = list->convert_to_const_vector ();
-
-	      retval.set_index (args);
-	    }
-#if 0
-	  else
-	    panic_impossible ();
-#endif
-	}
+      if (! error_state)
+	retval.set_index (type, idx);
     }
 
   return retval;
 }
 
 void
 tree_index_expression::eval_error (void)
 {
   if (error_state > 0)
     {
       int l = line ();
       int c = column ();
 
       const char *type_str;
 
-      if (itype == dot)
+      if (type[0] == '.')
 	type_str = "structure reference operator";
-      else if (list)
+      else if (args.front ())
 	type_str = "index expression";
       else
 	type_str = "expression";
 
       if (l != -1 && c != -1)
 	::error ("evaluating %s near line %d, column %d", type_str, l, c);
       else
 	::error ("evaluating %s", type_str);
diff --git a/src/pt-idx.h b/src/pt-idx.h
--- a/src/pt-idx.h
+++ b/src/pt-idx.h
@@ -26,95 +26,86 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
 class tree_argument_list;
 
 class tree_walker;
 
+class Octave_map;
 class octave_value;
 class octave_value_list;
 class octave_lvalue;
 
+#include "SLList.h"
 #include "str-vec.h"
 
 #include "pt-exp.h"
 
 // Index expressions.
 
 class
 tree_index_expression : public tree_expression
 {
 public:
 
-  enum type
-    {
-      unknown,
-      paren,
-      brace,
-      dot
-    };
-
   tree_index_expression (tree_expression *e = 0, tree_argument_list *lst = 0,
-			 int l = -1, int c = -1, type t = paren);
+			 int l = -1, int c = -1, char t = '(');
 
   tree_index_expression (tree_expression *e, const std::string& n,
 			 int l = -1, int c = -1);
 
   ~tree_index_expression (void);
 
-  bool is_index_expression (void) const
-    { return (itype == paren || itype == brace); }
+  void append (tree_argument_list *lst = 0, char t = '(');
 
-  bool is_indirect_ref (void) const
-    { return (itype == dot); }
+  void append (const std::string& n);
+
+  bool is_index_expression (void) const { return true; }
 
   std::string name (void) const;
 
-  std::string struct_elt_name (void) const
-    { return itype == dot ? arg_nm(0) : "<unknown>"; }
+  tree_expression *expression (void) { return expr; }
 
-  type expr_type (void) { return itype; }
+  SLList<tree_argument_list *> arg_lists (void) { return args; }
 
-  tree_expression *expression (void)
-    { return expr; }
+  std::string type_tags (void) { return type; }
 
-  tree_argument_list *arg_list (void)
-    { return list; }
+  SLList<string_vector> arg_names (void) { return arg_nm; }
 
-  bool lvalue_ok (void) const
-    { return (itype == dot || expr->lvalue_ok ()); }
+  bool lvalue_ok (void) const { return expr->lvalue_ok (); }
 
-  bool rvalue_ok (void) const
-    { return true; }
+  bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   octave_lvalue lvalue (void);
 
   void eval_error (void);
 
   void accept (tree_walker& tw);
 
 private:
 
   // The LHS of this index expression.
   tree_expression *expr;
 
-  // The indices (only valid if itype == paren || itype == brace).
-  tree_argument_list *list;
+  // The indices (only valid if type == paren || type == brace).
+  SLList<tree_argument_list *> args;
 
   // The type of this index expression.
-  type itype;
+  std::string type;
 
   // The names of the arguments.
-  string_vector arg_nm;
+  SLList<string_vector> arg_nm;
+
+  Octave_map tree_index_expression::make_arg_struct (void) const;
 
   // No copying!
 
   tree_index_expression (const tree_index_expression&);
 
   tree_index_expression& operator = (const tree_index_expression&);
 };
 
diff --git a/src/pt-mat.h b/src/pt-mat.h
--- a/src/pt-mat.h
+++ b/src/pt-mat.h
@@ -53,18 +53,17 @@ public:
     if (row)
       append (row);
   }
 
   ~tree_matrix (void);
 
   bool all_elements_are_constant (void) const;
 
-  bool rvalue_ok (void) const
-    { return true; }
+  bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   void accept (tree_walker& tw);
 
 private:
diff --git a/src/pt-misc.h b/src/pt-misc.h
--- a/src/pt-misc.h
+++ b/src/pt-misc.h
@@ -52,27 +52,23 @@ public:
 
   tree_parameter_list (tree_identifier *t)
     : SLList<tree_identifier *> (), marked_for_varargs (0) { append (t); }
 
   ~tree_parameter_list (void);
 
   void mark_as_formal_parameters (void);
 
-  void mark_varargs (void)
-    { marked_for_varargs = 1; }
+  void mark_varargs (void) { marked_for_varargs = 1; }
 
-  bool takes_varargs (void) const
-    { return marked_for_varargs != 0; }
+  bool takes_varargs (void) const { return marked_for_varargs != 0; }
 
-  void mark_varargs_only (void)
-    { marked_for_varargs = -1; }
+  void mark_varargs_only (void) { marked_for_varargs = -1; }
 
-  bool varargs_only (void)
-    { return (marked_for_varargs < 0); }
+  bool varargs_only (void) { return (marked_for_varargs < 0); }
 
   void initialize_undefined_elements (octave_value& val);
 
   void define_from_arg_vector (const octave_value_list& args);
 
   void clear (void);
 
   bool is_defined (void);
diff --git a/src/pt-plot.cc b/src/pt-plot.cc
--- a/src/pt-plot.cc
+++ b/src/pt-plot.cc
@@ -661,17 +661,17 @@ subplot::extract_plot_data (int ndim, oc
     {
       ColumnVector val = sp_using_clause->values (ndim);
 
       octave_value_list args;
 
       args(1) = val;
       args(0) = octave_value::magic_colon_t;
 
-      retval = data.do_index_op (args);
+      retval = data.subsref ("(", args);
 
       if (error_state)
 	return octave_value ();
     }
   else
     {
       retval = data;
     }
diff --git a/src/pt-pr-code.cc b/src/pt-pr-code.cc
--- a/src/pt-pr-code.cc
+++ b/src/pt-pr-code.cc
@@ -479,31 +479,63 @@ tree_print_code::visit_index_expression 
 
   if (e)
     {
       e->accept (*this);
 
       expr_has_parens = e->is_postfix_indexed ();
     }
 
-  tree_argument_list *list = expr.arg_list ();
+  SLList<tree_argument_list *> arg_lists = expr.arg_lists ();
+  std::string type_tags = expr.type_tags ();
+  SLList<string_vector> arg_names = expr.arg_names ();
 
-  if (expr.expr_type () == tree_index_expression::dot)
-    {
-      os << "." << expr.struct_elt_name ();
-    }
-  else if (list)
+  int n = type_tags.length ();
+
+  Pix arg_lists_p = arg_lists.first ();
+  Pix arg_names_p = arg_names.first ();
+
+  for (int i = 0; i < n; i++)
     {
-      os << " (";
-      list->accept (*this);
-      os << ")";
-    }
-  else if (expr_has_parens)
-    {
-      os << " ()";
+      switch (type_tags[i])
+	{
+	case '(':
+	  {
+	    os << " (";
+	    tree_argument_list *l = arg_lists (arg_lists_p);
+	    if (l)
+	      l->accept (*this);
+	    os << ")";
+	  }
+	  break;
+	    
+	case '{':
+	  {
+	    os << " {";
+	    tree_argument_list *l = arg_lists (arg_lists_p);
+	    if (l)
+	      l->accept (*this);
+	    os << "}";
+	  }
+	  break;
+	    
+	case '.':
+	  {
+	    string_vector nm = arg_names (arg_names_p);
+	    assert (nm.length () == 1);
+	    os << "." << nm(0);
+	  }
+	  break;
+
+	default:
+	  panic_impossible ();
+	}
+
+      arg_lists.next (arg_lists_p);
+      arg_names.next (arg_names_p);
     }
 
   print_parens (expr, ")");
 }
 
 void
 tree_print_code::visit_matrix (tree_matrix& lst)
 {
diff --git a/src/pt-pr-code.h b/src/pt-pr-code.h
--- a/src/pt-pr-code.h
+++ b/src/pt-pr-code.h
@@ -150,24 +150,21 @@ private:
   bool print_original_text;
 
   // Current indentation.
   int curr_print_indent_level;
 
   // TRUE means we are at the beginning of a line.
   bool beginning_of_line;
 
-  void reset_indent_level (void)
-    { curr_print_indent_level = 0; }
+  void reset_indent_level (void) { curr_print_indent_level = 0; }
 
-  void increment_indent_level (void)
-    { curr_print_indent_level += 2; }
+  void increment_indent_level (void) { curr_print_indent_level += 2; }
 
-  void decrement_indent_level (void)
-    { curr_print_indent_level -= 2; }
+  void decrement_indent_level (void) { curr_print_indent_level -= 2; }
 
   void newline (void);
 
   void indent (void);
 
   void reset (void);
 
   void print_parens (const tree_expression& expr, const char *txt);
diff --git a/src/pt-select.h b/src/pt-select.h
--- a/src/pt-select.h
+++ b/src/pt-select.h
@@ -176,18 +176,17 @@ public:
     : label (0), list (l), lead_comm (lc) { }
 
   tree_switch_case (tree_expression *e, tree_statement_list *l,
 		    octave_comment_list *lc = 0)
     : label (e), list (l), lead_comm (lc) { }
 
   ~tree_switch_case (void);
 
-  bool is_default_case (void)
-    { return ! label; }
+  bool is_default_case (void) { return ! label; }
 
   bool label_matches (const octave_value& val);
 
   int eval (const octave_value& val);
 
   void eval_error (void);
 
   tree_expression *case_label (void) { return label; }
diff --git a/src/pt-stmt.cc b/src/pt-stmt.cc
--- a/src/pt-stmt.cc
+++ b/src/pt-stmt.cc
@@ -121,18 +121,17 @@ tree_statement::eval (bool silent, int n
 
 	      tree_identifier *id = static_cast<tree_identifier *> (expr);
 
 	      id->do_lookup (script_file_executed, false);
 
 	      do_bind_ans = id->is_function ();
 	    }
 	  else
-	    do_bind_ans = (! (expr->is_indirect_ref ()
-			      || expr->is_assignment_expression ()));
+	    do_bind_ans = (! expr->is_assignment_expression ());
 
 	  retval = expr->rvalue (nargout);
 
 	  if (do_bind_ans && ! (error_state || retval.empty ()))
 	    bind_ans (retval(0), pf);
 	}
 
       unwind_protect::run ();
diff --git a/src/pt-stmt.h b/src/pt-stmt.h
--- a/src/pt-stmt.h
+++ b/src/pt-stmt.h
@@ -52,24 +52,21 @@ public:
   tree_statement (tree_command *c, octave_comment_list *cl)
     : cmd (c), expr (0), comm (cl), print_flag (true) { }
 
   tree_statement (tree_expression *e, octave_comment_list *cl)
     : cmd (0), expr (e), comm (cl), print_flag (true) { }
 
   ~tree_statement (void);
 
-  void set_print_flag (bool print)
-    { print_flag = print; }
+  void set_print_flag (bool print) { print_flag = print; }
 
-  bool is_command (void)
-    { return cmd != 0; }
+  bool is_command (void) { return cmd != 0; }
 
-  bool is_expression (void)
-    { return expr != 0; }
+  bool is_expression (void) { return expr != 0; }
 
   int line (void);
   int column (void);
 
   void maybe_echo_code (bool in_function_body);
 
   bool print_result (void) { return print_flag; }
 
diff --git a/src/pt-unop.h b/src/pt-unop.h
--- a/src/pt-unop.h
+++ b/src/pt-unop.h
@@ -89,18 +89,17 @@ public:
 
   tree_prefix_expression (tree_expression *e, int l = -1, int c = -1,
 			  octave_value::unary_op t
 			    = octave_value::unknown_unary_op)
     : tree_unary_expression (e, l, c, t) { }
 
   ~tree_prefix_expression (void) { }
 
-  bool rvalue_ok (void) const
-    { return true; }
+  bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   void eval_error (void);
 
   void accept (tree_walker& tw);
@@ -126,18 +125,17 @@ public:
 
   tree_postfix_expression (tree_expression *e, int l = -1, int c = -1,
 			   octave_value::unary_op t
 			     = octave_value::unknown_unary_op)
     : tree_unary_expression (e, l, c, t) { }
 
   ~tree_postfix_expression (void) { }
 
-  bool rvalue_ok (void) const
-    { return true; }
+  bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   void eval_error (void);
 
   void accept (tree_walker& tw);
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -37,17 +37,16 @@ Software Foundation, 59 Temple Place - S
 
 #include "glob-match.h"
 #include "str-vec.h"
 
 #include "defun.h"
 #include "error.h"
 #include "oct-lvalue.h"
 #include "ov.h"
-#include "pager.h"
 #include "pt-pr-code.h"
 #include "symtab.h"
 #include "utils.h"
 #include "variables.h"
 
 // Should variables be allowed to hide functions of the same name?  A
 // positive value means yes.  A negative value means yes, but print a
 // warning message.  Zero means it should be considered an error.
@@ -174,21 +173,21 @@ SYMBOL_DEF::which (std::ostream& os, con
 	  return;
 	}
     }
 
   os << " is a " << type_as_string () << "\n";
 }
 
 void
-SYMBOL_DEF::dump_symbol_info (void)
+SYMBOL_DEF::print_info (ostream& os, const std::string& prefix) const
 {
-  octave_stdout << "symbol_def::count: " << count << "\n";
-  octave_stdout << "def.type_name():   " << definition.type_name () << "\n";
-  octave_stdout << "def.count():       " << definition.get_count () << "\n";
+  os << prefix << "symbol_def::count: " << count << "\n";
+
+  definition.print_info (os, prefix + "  ");
 }
 
 // Individual records in a symbol table.
 
 // XXX FIXME XXX -- there are lots of places below where we should
 // probably be temporarily ignoring interrupts.
 
 void
@@ -440,17 +439,17 @@ symbol_record::pop_context (void)
     {
       replace_all_defs (context.pop ());
 
       linked_to_global = global_link_context.pop ();
     }
 }
 
 void
-symbol_record::print_symbol_info_line (std::ostream& os)
+symbol_record::print_symbol_info_line (std::ostream& os) const
 {
   os << (is_read_only () ? " r-" : " rw")
      << (is_eternal () ? "-" : "d")
 #if 0
      << (hides_fcn () ? "f" : (hides_builtin () ? "F" : "-"))
 #endif
      << "  "
      << std::setiosflags (std::ios::left) << std::setw (24)
@@ -472,22 +471,22 @@ symbol_record::print_symbol_info_line (s
     os << std::setiosflags (std::ios::right) << std::setw (7) << nc;
 
   os << std::resetiosflags (std::ios::right);
 
   os << "  " << name () << "\n";
 }
 
 void
-symbol_record::dump_symbol_info (void)
+symbol_record::print_info (ostream& os, const std::string& prefix) const
 {
   if (definition)
-    definition->dump_symbol_info ();
+    definition->print_info (os, prefix);
   else
-    octave_stdout << "symbol " << name () << " is undefined\n";
+    os << prefix << "symbol " << name () << " is undefined\n";
 }
 
 bool
 symbol_record::read_only_error (const char *action)
 {
   if (is_read_only ())
     {
       if (is_variable () || is_constant ())
@@ -870,63 +869,65 @@ symbol_table::pop_context (void)
 	{
 	  ptr->pop_context ();
 	  ptr = ptr->next ();
 	}
     }
 }
 
 void
-symbol_table::print_stats (void)
+symbol_table::print_info (ostream& os) const
 {
   int count = 0;
   int empty_chains = 0;
   int max_chain_length = 0;
   int min_chain_length = INT_MAX;
 
   for (unsigned int i = 0; i < table_size; i++)
     {
       int num_this_chain = 0;
 
       symbol_record *ptr = table[i].next ();
 
       if (ptr)
-	octave_stdout << "chain number " << i << ":\n";
+	os << "chain number " << i << ":\n";
       else
 	{
 	  empty_chains++;
 	  min_chain_length = 0;
 	}
 
       while (ptr)
 	{
 	  num_this_chain++;
 
-	  octave_stdout << "  " << ptr->name () << "\n";
+	  os << "  " << ptr->name () << "\n";
+
+	  ptr->print_info (os, "    ");
 
 	  ptr = ptr->next ();
 	}
 
       count += num_this_chain;
 
       if (num_this_chain > max_chain_length)
 	max_chain_length = num_this_chain;
 
       if (num_this_chain < min_chain_length)
 	min_chain_length = num_this_chain;
 
       if (num_this_chain > 0)
-	octave_stdout << "\n";
+	os << "\n";
     }
 
-  octave_stdout << "max chain length: " << max_chain_length << "\n";
-  octave_stdout << "min chain length: " << min_chain_length << "\n";
-  octave_stdout << "empty chains:     " << empty_chains << "\n";
-  octave_stdout << "total chains:     " << table_size << "\n";
-  octave_stdout << "total symbols:    " << count << "\n";
+  os << "max chain length: " << max_chain_length << "\n";
+  os << "min chain length: " << min_chain_length << "\n";
+  os << "empty chains:     " << empty_chains << "\n";
+  os << "total chains:     " << table_size << "\n";
+  os << "total symbols:    " << count << "\n";
 }
 
 // Chris Torek's fave hash function.
 
 unsigned int
 symbol_table::hash (const std::string& str)
 {
   unsigned int h = 0;
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -196,17 +196,18 @@ private:
     // Pointer to next definition in chain.  This is used so that
     // variables can hide function definitions, and so that the function
     // definitions can reappear if the variable is cleared.
     symbol_def *next_elem;
 
     // Reference count.
     int count;
 
-    void dump_symbol_info (void);
+    void print_info (std::ostream& os,
+		     const std::string& prefix = std::string ()) const;
 
     // No copying!
 
     symbol_def (const symbol_def& sd);
 
     symbol_def& operator = (const symbol_def& sd);
   };
 
@@ -333,19 +334,20 @@ public:
   symbol_record *next (void) const { return next_elem; }
 
   void chain (symbol_record *s) { next_elem = s; }
 
   void push_context (void);
 
   void pop_context (void);
 
-  void print_symbol_info_line (std::ostream& os);
+  void print_symbol_info_line (std::ostream& os) const;
 
-  void dump_symbol_info (void);
+  void print_info (std::ostream& os,
+		   const std::string& prefix = std::string ()) const;
 
 private:
 
   unsigned int formal_param : 1;
   unsigned int linked_to_global : 1;
   unsigned int tagged_static : 1;
 
   std::string nm;
@@ -439,17 +441,17 @@ public:
   Array<symbol_record *> glob (const std::string& pat = std::string ("*"),
 			       unsigned int type = SYMTAB_ALL_TYPES,
 			       unsigned int scope = SYMTAB_ALL_SCOPES) const;
 
   void push_context (void);
 
   void pop_context (void);
 
-  void print_stats (void);
+  void print_info (ostream& os) const;
 
 private:
 
   unsigned int table_size;
 
   symbol_record *table;
 
   unsigned int hash (const std::string& s);
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -757,17 +757,17 @@ specified option.\n\
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string arg = args(0).string_value ();
 
       if (! error_state)
-	retval = octave_value (m [arg.c_str ()]);
+	retval = octave_value (m [arg.c_str ()](0));
     }
   else if (nargin == 0)
     retval = octave_value (m);
   else
     print_usage ("octave_config_info");
 
   return retval;
 }
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -40,16 +40,17 @@ Software Foundation, 59 Temple Place - S
 #include "error.h"
 #include "gripes.h"
 #include "help.h"
 #include "input.h"
 #include "lex.h"
 #include "oct-map.h"
 #include "oct-obj.h"
 #include "ov.h"
+#include "ov-usr-fcn.h"
 #include "pager.h"
 #include "parse.h"
 #include "symtab.h"
 #include "toplev.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
@@ -260,119 +261,51 @@ get_struct_elts (const std::string& text
       if (len != NPOS)
 	pos += len + 1;
     }
 
   return retval;
 }
 
 string_vector
-generate_struct_completions (const std::string& text, std::string& prefix, std::string& hint)
+generate_struct_completions (const std::string& text,
+			     std::string& prefix, std::string& hint)
 {
   string_vector names;
 
   size_t pos = text.rfind ('.');
 
-  std::string id;
-  string_vector elts;
-
-  if (pos == NPOS)
-    {
-      hint = text;
-      prefix = text;
-      elts.resize (1, text);
-    }
-  else
+  if (pos != NPOS)
     {
       if (pos == text.length ())
 	hint = "";
       else
 	hint = text.substr (pos+1);
 
       prefix = text.substr (0, pos);
-
-      elts = get_struct_elts (prefix);
     }
 
-  id = elts[0];
-
-  symbol_record *sr = curr_sym_tab->lookup (id);
-
-  if (! sr)
-    sr = global_sym_tab->lookup (id);
-
-  if (sr && sr->is_defined ())
-    {
-      octave_value tmp = sr->def ();
+  int parse_status;
 
-      // XXX FIXME XXX -- make this work for all types that can do
-      // structure reference operations.
-      if (tmp.is_map ())
-	{
-	  for (int i = 1; i < elts.length (); i++)
-	    {
-	      tmp = tmp.do_struct_elt_index_op (elts[i], true);
+  octave_value tmp = eval_string (prefix, true, parse_status);
 
-	      if (! tmp.is_map ())
-		break;
-	    }
-
-	  if (tmp.is_map ())
-	    {
-	      Octave_map m = tmp.map_value ();
-
-	      names = m.make_name_list ();
-	    }
-	}
-    }
+  if (tmp.is_defined () && tmp.is_map ())
+    names = tmp.map_keys ();
 
   return names;
 }
 
 bool
 looks_like_struct (const std::string& text)
 {
-  bool retval = true;
-
-  string_vector elts = get_struct_elts (text);
-
-  std::string id = elts[0];
-
-  symbol_record *sr = curr_sym_tab->lookup (id);
-
-  if (! sr)
-    sr = global_sym_tab->lookup (id);
-
-  if (sr && sr->is_defined ())
-    {
-      octave_value tmp = sr->def ();
-
-      // XXX FIXME XXX -- should this work for all types that can do
-      // structure reference operations?
+  int parse_status;
 
-      if (tmp.is_map ())
-	{
-	  for (int i = 1; i < elts.length (); i++)
-	    {
-	      tmp = tmp.do_struct_elt_index_op (elts[i], true);
+  octave_value tmp = eval_string (text, true, parse_status);
 
-	      if (! tmp.is_map ())
-		{
-		  retval = false;
-		  break;
-		}
-	    }
-	}
-      else
-	retval = false;
-    }
-  else
-    retval = false;
-
-  return retval;	
+  return (tmp.is_defined () && tmp.is_map ());
 }
 
 DEFUN (is_global, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_global (@var{name})\n\
 Return 1 if @var{name} is globally visible.  Otherwise, return 0.  For\n\
 example,\n\
 \n\
@@ -1298,44 +1231,61 @@ This command may not be used within a fu
 		}
 	    }
 	}
     }
 
   return retval;
 }
 
-DEFUN (__dump_symtab_info__, args, ,
+DEFUN (__print_symtab_info__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} __dump_symtab_info__ ()\n\
+@deftypefn {Built-in Function} {} __print_symtab_info__ ()\n\
 Print raw symbol table statistices.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       std::string arg = args(0).string_value ();
 
       if (arg == "global")
-	global_sym_tab->print_stats ();
+	global_sym_tab->print_info (octave_stdout);
+      else if (arg == "top-level")
+	top_level_sym_tab->print_info (octave_stdout);
       else
-	print_usage ("__dump_symtab_info__");
+	{
+	  symbol_record *gsr = global_sym_tab->lookup (arg, true);
+
+	  if (gsr && gsr->is_user_function ())
+	    {
+	      octave_value tmp = gsr->def ();
+	      const octave_value& rep = tmp.get_rep ();
+	      
+	      const octave_user_function& fcn
+		= static_cast<const octave_user_function&> (rep);
+
+	      fcn.print_symtab_info (octave_stdout);
+	    }
+	  else
+	    error ("no user-defined function named %s", arg.c_str ());
+	}
     }
   else if (nargin == 0)
-    curr_sym_tab->print_stats ();
+    curr_sym_tab->print_info (octave_stdout);
   else
-    print_usage ("__dump_symtab_info__");
+    print_usage ("__print_symtab_info__");
 
   return retval;
 }
 
-DEFUN (__dump_symbol_info__, args, ,
+DEFUN (__print_symbol_info__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __dump_symbol_info__ (@var{name})\n\
 Print symbol table information for the symbol @var{name}.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
@@ -1344,26 +1294,26 @@ Print symbol table information for the s
     {
       std::string symbol_name = args(0).string_value ();
 
       if (! error_state)
 	{
 	  symbol_record *sr = curr_sym_tab->lookup (symbol_name);
 
 	  if (sr)
-	    sr->dump_symbol_info ();
+	    sr->print_info (octave_stdout);
 	  else
-	    error ("__dymp_symbol_info__: symbol %s not found",
+	    error ("__print_symbol_info__: symbol %s not found",
 		   symbol_name.c_str ());
 	}
       else
-	print_usage ("__dump_symbol_info__");
+	print_usage ("__print_symbol_info__");
     }
   else
-    print_usage ("__dump_symbol_info__");
+    print_usage ("__print_symbol_info__");
 
   return retval;
 }
 
 // XXX FIXME XXX -- some of these should do their own checking to be
 // able to provide more meaningful warning or error messages.
 
 static int
