# HG changeset patch
# User Ben Abbott <bpabbott@mac.com>
# Date 1282905576 14400
#      Fri Aug 27 06:39:36 2010 -0400
# Node ID dd6b90f44ae5fc0ec7885009a674b2c3b3bfaa02
# Parent  9abc67b4bd4fc66fe965a96553af9005b9a2f9ce
Unify gnuplot printing with the fltk backend.

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,17 @@
+2010-08-25  Ben Abbott <bpabbott@mac.com>
+
+	* plot/__fltk_print__.m, plot/__go_draw_axes__.m,
+	plot/__go_draw_figure__.m, plot/__gnuplot_print__.m,
+	plot/gnuplot_drawnow.m, plot/print.m, plot/private/__ghostscript__.m,
+	plot/private/__tight_eps_bbox__.m: Unify gnuplot printing with the
+	the fltk backend. Turn figure background color off when printing.
+	Improve the axes font spacing for most gnuplot terminals.
+
 2010-08-26  Ben Abbott <bpabbott@mac.com>
 
 	* plot/__go_draw_axes__.m: For yaxislocation == 'right' associate text
 	position with 'second' coordinate system.
 
 2010-08-25  Ben Abbott <bpabbott@mac.com>
 
 	* plot/__go_draw_axes__.m: Revert erroneous portion of changeset
diff --git a/scripts/plot/__fltk_print__.m b/scripts/plot/__fltk_print__.m
--- a/scripts/plot/__fltk_print__.m
+++ b/scripts/plot/__fltk_print__.m
@@ -18,130 +18,143 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} __fltk_print__ (@var{@dots{}})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function __fltk_print__ (opts)
 
+  figure (opts.figure)
+  drawnow ("expose")
+
   file2unlink = "";
 
   if (! isempty (opts.fig2dev_binary))
     fig2dev_devices = {"pstex", "mf", "emf"};
   else
     ## If no fig2dev is present, support emf using pstoedit.
     fig2dev_devices = {"pstex", "mf"};
   endif
 
-  switch lower (opts.devopt)
-  case {"eps", "eps2", "epsc", "epsc2"}
-    drawnow ("eps", opts.name);
-    if (opts.tight_flag)
-      __tight_eps_bbox__ (opts, opts.name);
-    endif
-  case {"epslatex", "pslatex", "pdflatex", "epslatexstandalone", ...
-        "pslatexstandalone", "pdflatexstandalone"}
-    ## format GL2PS_TEX
-    ## FIXME - rotated text do not align properly.
-    n = find (opts.devopt == "l", 1);
-    suffix = opts.devopt(1:n-1);
-    dot = find (opts.name == ".", 1, "last");
-    if ((! isempty (dot))
-        && any (strcmpi (opts.name(dot:end), {".eps", ".ps", ".pdf", ".tex", "."})))
-      name = opts.name(1:dot-1);
-      if (dot < numel (opts.name)
-          && any (strcmpi (opts.name(dot+1:end), {"eps", "ps", "pdf"})))
-        ## If user provides eps/ps/pdf suffix, use it.
-        suffix = opts.name(dot+1:end);
+  unwind_protect
+
+    switch lower (opts.devopt)
+    case {"eps", "eps2", "epsc", "epsc2"}
+      drawnow ("eps", opts.name);
+      if (opts.tight_flag)
+        __tight_eps_bbox__ (opts, opts.name);
+      endif
+    case {"epslatex", "pslatex", "pdflatex", "epslatexstandalone", ...
+          "pslatexstandalone", "pdflatexstandalone"}
+      ## format GL2PS_TEX
+      n = find (opts.devopt == "l", 1);
+      suffix = opts.devopt(1:n-1);
+      dot = find (opts.name == ".", 1, "last");
+      if ((! isempty (dot))
+          && any (strcmpi (opts.name(dot:end), {".eps", ".ps", ".pdf", ".tex", "."})))
+        name = opts.name(1:dot-1);
+        if (dot < numel (opts.name)
+            && any (strcmpi (opts.name(dot+1:end), {"eps", "ps", "pdf"})))
+          ## If user provides eps/ps/pdf suffix, use it.
+          suffix = opts.name(dot+1:end);
+        endif
+      elseif (dot == numel (opts.name))
+        name = opts.name;
+      endif
+      drawnow (strcat (lower (suffix), "notxt"), strcat (name, ".", suffix));
+      drawnow ("tex", strcat (name, ".", suffix, ".tex"));
+      movefile (strcat (name, ".", suffix, ".tex"), strcat (name, ".tex"));
+      if (opts.tight_flag && strncmpi (opts.devopt, "eps", 3))
+        __tight_eps_bbox__ (opts, strcat (opts.name, ".eps"));
+      endif
+      if (! isempty (strfind (opts.devopt, "standalone")))
+        __latex_standalone__ (strcat (name, ".tex"));
+      endif
+    case {"tikz"}
+      ## format GL2PS_PGF
+      drawnow ("pgf", opts.name);
+    case {"ps", "ps2", "psc", "psc2", "pdf"}
+      opts.ghostscript.source = strcat (tmpnam (), ".eps");
+      file2unlink = opts.ghostscript.source;
+      if (strcmp (opts.devopt, "pdf"))
+        opts.ghostscript.device = "pdfwrite";
+      elseif (any (opts.devopt == '2'))
+        opts.ghostscript.device = "ps2write";
+      else
+        opts.ghostscript.device = "pswrite";
+      endif
+      opts.ghostscript.output = opts.name;
+      drawnow ("eps", opts.ghostscript.source);
+      if (opts.tight_flag)
+        __tight_eps_bbox__ (opts, opts.ghostscript.source);
       endif
-    elseif (dot == numel (opts.name))
-      name = opts.name;
-    endif
-    drawnow (strcat (lower (suffix), "notxt"), strcat (name, ".", suffix));
-    drawnow ("tex", strcat (name, ".", suffix, ".tex"));
-    movefile (strcat (name, ".", suffix, ".tex"), strcat (name, ".tex"));
-    if (opts.tight_flag && strncmpi (opts.devopt, "eps", 3))
-      __tight_eps_bbox__ (opts, strcat (opts.name, ".eps"));
-    endif
-    if (! isempty (strfind (opts.devopt, "standalone")))
-      __standalone__ (strcat (name, ".tex"));
-    endif
-  case {"tikz"}
-    ## format GL2PS_PGF
-    drawnow ("pgf", opts.name);
-  case {"ps", "ps2", "psc", "psc2", "pdf"}
-    opts.ghostscript.source = strcat (tmpnam (), ".eps");
-    file2unlink = opts.ghostscript.source;
-    if (strcmp (opts.devopt, "pdf"))
-      opts.ghostscript.device = "pdfwrite";
-    else
-      opts.ghostscript.device = "pswrite";
-    endif
-    opts.ghostscript.output = opts.name;
-    drawnow ("eps", opts.ghostscript.source);
-    if (opts.tight_flag)
-      __tight_eps_bbox__ (opts, opts.ghostscript.source);
+    case {"svg"}
+      ## format GL2PS_SVG
+      drawnow ("svg", opts.name);
+    case gs_based_devices ()
+      opts.ghostscript.antialiasing = true;
+      switch opts.devopt
+      case "bmp"
+        opts.ghostscript.device = "bmp32b";
+      case "png"
+        opts.ghostscript.device = "png16m";
+      case {"tiff", "tiffn"}
+        opts.ghostscript.device = "tiff24nc";
+      otherwise
+        opts.ghostscript.device = opts.devopt;
+      endswitch
+      opts.ghostscript.output = opts.name;
+      opts.ghostscript.source = strcat (tmpnam (), ".eps");
+      opts.ghostscript.epscrop = true;
+      file2unlink = opts.ghostscript.source;
+      drawnow ("eps", opts.ghostscript.source)
+      if (opts.tight_flag)
+        __tight_eps_bbox__ (opts, opts.ghostscript.source);
+      endif
+    case fig2dev_devices
+      tmp_figfile = strcat (tmpnam (), ".fig");
+      file2unlink = tmp_figfile;
+      status = __pstoedit__ (opts, "fig", tmp_figfile);
+      if (status == 0)
+        status = __fig2dev__ (opts, tmp_figfile);
+      endif
+    case {"aifm", "dxf", "emf", "fig", "hpgl"}
+      status = __pstoedit__ (opts);
+    case {"corel", "gif"}
+      error ("print:unsupporteddevice",
+             "print.m: %s output is not available for the FLTK backend.",
+             upper (opts.devopt))
+    otherwise
+      ## various ghostscript devices for printers
+      opts.ghostscript.device = opts.devopt;
+      opts.ghostscript.output = opts.name;
+      opts.ghostscript.epscrop = false;
+      opts.ghostscript.source = strcat (tmpnam (), ".eps");
+      file2unlink = opts.ghostscript.source;
+      ## Empirical observatin: "-dpxlcolor" requires a sign change.
+      opts.ghostscript.pageoffset = opts.ghostscript.pageoffset .* [1, -1];
+      drawnow ("eps", opts.ghostscript.source)
+      if (opts.tight_flag)
+        __tight_eps_bbox__ (opts, opts.ghostscript.source);
+      endif
+    endswitch
+  
+    if (! isempty (opts.ghostscript.device))
+      status = __ghostscript__ (opts.ghostscript);
     endif
-  case {"svg"}
-    ## format GL2PS_SVG
-    drawnow ("svg", opts.name);
-  case {"jpeg", "pbm", "pbmraw", "pcx24b", "pcx256", "pcx16", ...
-        "pgm", "pgmraw", "png", "ppm", "ppmraw", "pdfwrite", ...
-        "tiff", "tiffn"}
-    switch opts.devopt
-    case "png"
-      opts.ghostscript.device = "png16m";
-    case {"tiff", "tiffn"}
-      opts.ghostscript.device = "tiff24nc";
-    otherwise
-      opts.ghostscript.device = opts.devopt;
-    endswitch
-    opts.ghostscript.output = opts.name;
-    opts.ghostscript.source = strcat (tmpnam (), ".eps");
-    opts.ghostscript.epscrop = true;
-    file2unlink = opts.ghostscript.source;
-    drawnow ("eps", opts.ghostscript.source)
-    if (opts.tight_flag)
-      __tight_eps_bbox__ (opts, opts.ghostscript.source);
+
+  unwind_protect_cleanup
+    if (! isempty (file2unlink))
+      [status, output] = unlink (file2unlink);
+      if (status != 0)
+        warning ("print.m: %s, '%s'.", output, file2unlink)
+      endif
     endif
-  case fig2dev_devices
-    tmp_figfile = strcat (tmpnam (), ".fig");
-    file2unlink = tmp_figfile;
-    status = __pstoedit__ (opts, "fig", tmp_figfile);
-    if (status == 0)
-      status = __fig2dev__ (opts, tmp_figfile);
-    endif
-  case {"aifm", "dxf", "emf", "fig", "hpgl"};
-    status = __pstoedit__ (opts);
-  otherwise
-    ## various ghostscript devices for printers
-    opts.ghostscript.device = opts.devopt;
-    opts.ghostscript.output = opts.name;
-    opts.ghostscript.epscrop = false;
-    opts.ghostscript.source = strcat (tmpnam (), ".eps");
-    file2unlink = opts.ghostscript.source;
-    drawnow ("eps", opts.ghostscript.source)
-    if (opts.tight_flag)
-      __tight_eps_bbox__ (opts, opts.ghostscript.source);
-    endif
-  endswitch
-
-  ## FIXME - warning: unrecognized escape sequence `\P' -- converting to `P'
-  if (! isempty (opts.ghostscript.device))
-    status = __ghostscript__ (opts.ghostscript);
-  endif
-
-  if (! isempty (file2unlink))
-    [status, output] = unlink (file2unlink);
-    if (status != 0)
-      disp (output)
-      warning ("print.m: failed to delete temporay file, '%s'.", file2unlink)
-    endif
-  endif
+  end_unwind_protect
 
 endfunction
 
 function status = __fig2dev__ (opts, figfile, devopt, devfile)
   persistent warn_on_absence = true
   if (nargin < 4)
     devfile = opts.name;
   endif
@@ -170,42 +183,44 @@ function status = __pstoedit__ (opts, de
   if (nargin < 3)
     name = opts.name;
   endif
   if (nargin < 2)
     devopt =  opts.devopt;
   endif
   if (! isempty (opts.pstoedit_binary))
     tmp_epsfile = strcat (tmpnam (), ".eps");
-    drawnow ("eps", tmp_epsfile)
-    if (opts.tight_flag)
-      __tight_eps_bbox__ (opts, tmp_epsfile);
-    endif
-    cmd = sprintf ("%s -f %s %s %s 2>&1", opts.pstoedit_binary, devopt,
-                   tmp_epsfile, name);
-    [status, output] = system (cmd);
-    if (opts.debug || status != 0)
-      fprintf ("pstoedit command: %s", cmd)
-    endif
-    if (status != 0)
-      disp (output)
-      warning ("print:pstoeditfailed", "print.m: error running pstoedit.")
-    endif
-    [status, output] = unlink (tmp_epsfile);
-    if (status != 0)
-      disp (output)
-      warning ("print.m: failed to delete temporay file, '%s'.", tmp_epsfile)
-    endif
+    unwind_protect
+      drawnow ("eps", tmp_epsfile)
+      if (opts.tight_flag)
+        __tight_eps_bbox__ (opts, tmp_epsfile);
+      endif
+      cmd = sprintf ("%s -f %s %s %s 2>&1", opts.pstoedit_binary, devopt,
+                     tmp_epsfile, name);
+      [status, output] = system (cmd);
+      if (opts.debug || status != 0)
+        fprintf ("pstoedit command: %s", cmd)
+      endif
+      if (status != 0)
+        disp (output)
+        warning ("print:pstoeditfailed", "print.m: error running pstoedit.")
+      endif
+    unwind_protect_cleanup
+      [status, output] = unlink (tmp_epsfile);
+      if (status != 0)
+        warning ("print.m: %s, '%s'.", output, tmp_epsfile)
+      endif
+    end_unwind_protect
   elseif (isempty (opts.pstoedit_binary) && warn_on_absence)
     warning ("print:nopstoedit", "print.m: 'pstoedit' not found in EXEC_PATH.")
     warn_on_absence = false;
   endif
 endfunction
 
-function __standalone__ (latexfile)
+function __latex_standalone__ (latexfile)
   prepend = {"\\documentclass{minimal}";
              "\\usepackage{epsfig,color}";
              "\\begin{document}";
              "\\centering"};
   postpend = {"\\end{document}"};
   fid = fopen (latexfile, "r");
   if (fid >= 0)
     latex = fscanf (fid, "%c", Inf);
@@ -229,9 +244,22 @@ function __standalone__ (latexfile)
              "print.m: error closing file '%s'", latexfile)
     endif
   else
     error ("print:erroropeningfile",
            "print.m: error opening file '%s'", latexfile)
   endif
 endfunction
 
+function device_list = gs_based_devices ();
+  device_list = {"bmp16", "bmp16m", "bmp256", "bmp32b", "bmpgray", ...
+                 "jpeg", "jpegcymk", "jpeggray", "pbm", "pbmraw", ...
+                 "pcx16", "pcx24b", "pcx256", "pcx2up", "pcxcmyk", ...
+                 "pcxgray", "pcxmono", "pdfwrite", "pgm", "pgmraw", ...
+                 "pgnm", "pgnmraw", "png16", "png16m", "png256", ...
+                 "png48", "pngalpha", "pnggray", "pngmono", "pnm", ...
+                 "pnmraw", "ppm", "ppmraw", "ps2write", "pswrite", ...
+                 "tiff12nc", "tiff24nc", "tiff32nc", "tiffcrle", ...
+                 "tiffg3", "tiffg32d", "tiffg4", "tiffgray", "tifflzw", ...
+                 "tiffpack", "tiffsep", "bmp", "png", "tiff", "tiffn", ...
+                 "pdf", "ps", "psc", "ps2", "psc2"};
+endfunction
 
diff --git a/scripts/plot/__gnuplot_print__.m b/scripts/plot/__gnuplot_print__.m
--- a/scripts/plot/__gnuplot_print__.m
+++ b/scripts/plot/__gnuplot_print__.m
@@ -13,566 +13,305 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} __gnuplot_ginput__ (@var{@dots{}})
+## @deftypefn {Function File} {} __gnuplot_print__ (@var{@dots{}})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: Daniel Heiserer <Daniel.heiserer@physik.tu-muenchen.de>
 ## Adapted-By: jwe
 
 function __gnuplot_print__ (opts)
 
-  persistent warn_on_inconsistent_orientation = true
-
-  old_fig = get (0, "currentfigure");
-  unwind_protect
-    have_ghostscript = ! isempty (opts.ghostscript_binary);
+  file2unlink = "";
 
-    doprint = isempty (opts.name);
-    if (doprint)
-      if (isempty (opts.devopt))
-        if (opts.use_color < 0)
-          opts.devopt = "ps";
-          printname = cstrcat (tmpnam, ".ps");
-        else
-          opts.devopt = "psc";
-          printname = cstrcat (tmpnam, ".psc");
-        endif
-      else
-        printname = cstrcat (tmpnam, ".", devopt);
-      endif
-      opts.name = printname;
+  if (isempty (opts.fontsize))
+    ## If no fontsize, determine the nominal axes fontsize.
+    defaultfontsize = get (0, "defaultaxesfontsize");
+    axesfontsize = get (findobj (opts.figure, "type", "axes"), "fontsize");
+    if (iscell (axesfontsize))
+      axesfontsize = round (median (cell2mat (axesfontsize)));
     endif
-
-    dot = rindex (opts.name, ".");
-    if (isempty (opts.devopt))
-      if (dot == 0)
-        error ("print: no format specified");
-      else
-        dev = tolower (opts.name(dot+1:end));
-      endif
+    if (isempty (axesfontsize))
+      opts.fontsize = defaultfontsize;
     else
-      dev = opts.devopt;
+      opts.fontsize = axesfontsize;
     endif
-
-    dev_list = {"aifm", "corel", "fig", "png", "jpeg", ...
-                "gif", "pbm", "dxf", "mf", "svg", "hpgl", ...
-                "ps", "ps2", "psc", "psc2", "eps", "eps2", ...
-                "epsc", "epsc2", "emf", "pdf", "pslatex", ...
-                "epslatex", "epslatexstandalone", "pstex", "tikz"};
-    suffixes = {"ai", "cdr", "fig", "png", "jpeg", ...
-                "gif", "pbm", "dxf", "mf", "svg", "hpgl", ...
-                "ps", "ps", "ps", "ps", "eps", "eps", ...
-                "eps", "eps", "emf", "pdf", "tex", ...
-                "tex", "tex", "tex", "tikz"};
-    if (dot == 0)
-      opts.name = strcat (opts.name, ".", suffixes {strcmpi (dev_list, dev)});
-      dot = rindex (name, ".");
-    endif
-
-    if (opts.append_to_file)
-      if (any (strcmpi (dev, {"ps", "ps2", "psc", "psc2", "pdf"})))
-        if (have_ghostscript)
-          file_exists = ((numel (dir (opts.name)) == 1) && (! isdir (opts.name)));
-          if (! file_exists)
-            opts.append_to_file = 0;
-          end
-        end
-      else
-        warning ("print.m: appended output is not supported for device '%s'", dev)
-        opts.append_to_file = 0;
-      endif
-    endif
+  end
+  ## The axes-label and tick-label spacing is determined by
+  ## the font spec given in "set terminal ..."
+  gp_opts = font_spec (opts);
 
-    if (strcmp (dev, "tex"))
-      dev = "epslatex";
-    elseif (strcmp (dev, "ill"))
-      dev = "aifm";
-    elseif (strcmp (dev, "cdr"))
-      dev = "corel";
-    elseif (strcmp (dev, "meta"))
-      dev = "emf";
-    elseif (strcmp (dev, "jpg"))
-      dev = "jpeg";
-    endif
-
-    if (strcmp (dev, "epslatex"))
-      ## gnuplot 4.0 wants ".eps" in the output name    
-      if (! __gnuplot_has_feature__ ("epslatex_implies_eps_filesuffix"))
-        opts.name = cstrcat (name(1:dot), "eps");
+  unwind_protect
+    switch lower (opts.devopt)
+    case {"eps", "eps2", "epsc", "epsc2"}
+      if (any (strcmp (opts.devopt, {"eps", "epsc"})))
+        gp_opts = sprintf ("%s level1", gp_opts);
       endif
-    endif
-
-    ## Check if the specified device is one that is supported by gnuplot.
-    ## If not, assume it is a device/format supported by Ghostscript.
-    if (! any (strcmp (dev, dev_list)) && have_ghostscript)
-      ghostscript_output = opts.name;
-      ghostscript_device = dev;
-      if (doprint)
-        ## If printing, use color postscript.
-        dev = "psc";
-        opts.name = cstrcat (tmpnam, ".ps");
-      else
-        ## If saving to a file, use color encapsulated postscript.
-        dev = "epsc";
-        opts.name = cstrcat (tmpnam, ".eps");
+      eps_drawnow (opts, opts.name, gp_opts);
+    case {"epslatex", "pslatex", "pstex", "epslatexstandalone"}
+      n = find (opts.devopt == "l", 1);
+      suffix = opts.devopt(1:n-1);
+      dot = find (opts.name == ".", 1, "last");
+      if ((! isempty (dot))
+          && any (strcmpi (opts.name(dot:end),
+                  {".eps", ".ps", ".pdf", ".tex", "."})))
+        name = opts.name(1:dot-1);
+        if (dot < numel (opts.name)
+            && any (strcmpi (opts.name(dot+1:end), {"eps", "ps"})))
+          ## If user provides eps/ps suffix, use it.
+          suffix = opts.name(dot+1:end);
+        endif
+      elseif (dot == numel (opts.name))
+        name = opts.name;
       endif
-    elseif (doprint && all (! strcmpi (suffixes {strcmpi (dev_list, dev)}, 
-                                       {"ps", "eps", "hpgl"})))
-      ## When not using Ghostscript, verify the format is compatible with
-      ## hard copy output.
-      error ("print: missing file name, or invalid print format.");
-    else
-      ghostscript_output = "";
-    endif
-
-    termn = dev;
-
-    ## SVG isn't actually a bitmap, but gnuplot treats its size option as it
-    ## does the bitmap terminals.
-    bitmap_devices = {"emf", "gif", "jpeg", "pbm", "png", "svg"};
-
-    if (any (strcmp (dev, {"ps", "ps2", "psc", "psc2", "epsc", "epsc2", ...
-                           "eps", "eps2", "pstex", "pslatex", "epslatex", ...
-                           "epslatexstandalone"})))
-
-      ## Various postscript options
-      if (any (strcmp (dev, {"pstex", "pslatex", "epslatex"})))
-        options = "";
-      elseif (strcmp (dev, "epslatexstandalone"))
-        if (__gnuplot_has_feature__ ("epslatexstandalone_terminal"))
-          termn = "epslatex";
-          options = "standalone ";
-        else
-          error ("print: epslatexstandalone needs gnuplot 4.2 or higher");
-        endif
+      if (strfind (opts.devopt, "standalone"))
+        term = sprintf ("%s ",
+                        strrep (opts.devopt, "standalone", " standalone"));
       else
-        if (dev(1) == "e")
-          options = "eps ";
-        else
-          options = "";
-        endif
-        termn = "postscript";
-      endif
-
-      if (any (dev == "c") || opts.use_color > 0
-          || (! isempty (strfind (dev, "tex")) && opts.use_color == 0))
-        opts.use_color = 1;
-      else
-        opts.use_color = -1;
-      endif
-      
-      if (opts.use_color > 0)
-        if (opts.force_solid < 0)
-          options = cstrcat (options, "color dashed ");
-        else
-          options = cstrcat (options, "color solid ");
-        endif
-      else
-        if (opts.force_solid > 0)
-          options = cstrcat (options, "mono solid ");
-        else
-          options = cstrcat (options, "mono dashed ");
-        endif
-      endif
-
-      if (! isempty (opts.font))
-        options = cstrcat (options, "\"", opts.font, "\" ");
-      endif
-      if (! isempty (opts.fontsize))
-        options = cstrcat (options, " ", opts.fontsize);
-      endif
-
-    elseif (strcmp (dev, "tikz"))
-      if (! isempty (font) && ! isempty (opts.fontsize))
-        options = cstrcat (options, "\"", opts.font, ",", opts.fontsize, "\" ");
-      elseif (! isempty (font))
-        options = cstrcat (options, "\"", opts.font, "\" ");
-      else
-        options = "";
-      endif
-
-    elseif (strcmp (dev, "aifm") || strcmp (dev, "corel"))
-      ## Adobe Illustrator, CorelDraw
-      if (opts.use_color >= 0)
-        options = " color";
-      else
-        options = " mono";
-      endif
-      if (! isempty (opts.font))
-        options = cstrcat (options, " \"", opts.font, "\"");
-      endif
-      if (! isempty (opts.fontsize))
-        options = cstrcat (options, " ", opts.fontsize);
+        term = sprintf ("%s ", opts.devopt);
       endif
-
-    elseif (strcmp (dev, "fig"))
-      ## XFig
-      options = opts.orientation;
-      if (opts.use_color >= 0)
-        options = " color";
-      else
-        options = " mono";
-      endif
-      options = cstrcat (options, " ", opts.special_flag);
-      if (! isempty (opts.fontsize))
-        options = cstrcat (options, " fontsize ", opts.fontsize);
-      endif
-
-    elseif (strcmp (dev, "emf"))
-      ## Enhanced Metafile format
-      options = " ";
-      if (opts.use_color >= 0)
-        options = " color";
-      else
-        options = " mono";
-      endif
-      if (opts.force_solid >= 0)
-        options = cstrcat (options, " solid");
-      endif
-      if (! isempty (opts.font))
-        options = cstrcat (options, " \"", opts.font, "\"");
-      endif
-      if (! isempty (opts.fontsize))
-        options = cstrcat (options, " ", opts.fontsize);
+      local_drawnow (sprintf ("%s %s", term, gp_opts),
+               strcat (name, ".", suffix, ".tex"), opts)
+      movefile (strcat (name, ".", suffix, ".tex"), strcat (name, ".tex"));
+      if (opts.tight_flag && strncmpi (opts.devopt, "eps", 3))
+        __tight_eps_bbox__ (opts, strcat (opts.name, ".eps"));
       endif
-
-    elseif (any (strcmp (dev, bitmap_devices)))
-
-      if (isempty (opts.canvas_size) && isempty (opts.resolution) 
-          && any (strcmp (dev, {"pbm", "gif", "jpeg", "png"})))
-        options = "";
-      elseif (strcmp (dev, "svg"))
-        ## Referring to size, either "dynamic" or "fixed"
-        options = "fixed";
-      else
-        options = "";
-      end
-      if (! isempty (opts.canvas_size))
-        options = sprintf ("%s size %d, %d", options, opts.canvas_size);
-      endif
-
-    elseif (any (strcmp (dev, {"dxf", "mf", "hpgl"})))
-      ## AutoCad DXF, METAFONT, HPGL
-      options = "";
-
-    elseif (strcmp (dev, "pdf"))
-      ## Portable Document format
-      options = " ";
-      if (opts.use_color >= 0)
-        options = "color";
-      else
-        options = "mono";
-      endif
-      if (opts.force_solid >= 0)
-        options = cstrcat (options, " solid");
-      elseif (opts.force_solid < 0)
-        options = cstrcat (options, " dashed");
-      endif
-      if (! isempty (opts.font))
-        options = cstrcat (options, "\"", opts.font, "\" ");
+    case {"tikz"}
+      local_drawnow (sprintf ("lua tikz %s", gp_opts), opts.name, opts);
+    case {"ps", "ps2", "psc", "psc2", "pdf"}
+      if (any (strcmp (opts.devopt, {"ps", "psc"})))
+        gp_opts = sprintf ("%s level1", gp_opts);
       endif
-      if (! isempty (opts.fontsize))
-        options = cstrcat (options, " ", opts.fontsize);
-      endif
-
-    endif
- 
-    if (__gnuplot_has_feature__ ("variable_GPVAL_TERMINALS"))
-      available_terminals = __gnuplot_get_var__ (gcf, "GPVAL_TERMINALS");
-      available_terminals = regexp (available_terminals, "\\b\\w+\\b", "match");
-      ## Favor the cairo terminals.
-      if (strcmp (termn, "pdf") 
-          && any (strcmp (available_terminals, "pdfcairo")))
-        termn = "pdfcairo";
-        gnuplot_supports_term = true;
-      elseif (strcmp (termn, "png")
-              && any (strcmp (available_terminals, "pngcairo")))
-        termn = "pngcairo";
-        gnuplot_supports_term = true;
+      ## Gnuplot's BBox LLHC is located at [50,50]
+      opts.ghostscript.pageoffset = opts.ghostscript.pageoffset - 50;
+      opts.ghostscript.source = strcat (tmpnam (), ".eps");
+      file2unlink = opts.ghostscript.source;
+      if (strcmp (opts.devopt, "pdf"))
+        opts.ghostscript.device = "pdfwrite";
+      elseif (any (opts.devopt == '2'))
+        opts.ghostscript.device = "ps2write";
       else
-        gnuplot_supports_term = any (strcmp (available_terminals, termn));
-      endif
-    elseif (strcmp (termn, "pdf"))
-      ## Some Linux variants do not include a "pdf" capable gnuplot.
-      ## To be safe, use Ghostscript.
-      if (have_ghostscript)
-        gnuplot_supports_term = false;
-        ghostscript_device = "pdfwrite";
-      else
-        gnuplot_supports_term = true;
-      endif
-    else
-      gnuplot_supports_term = true;
-    endif
-
-    if (! gnuplot_supports_term)
-      if (strcmp (termn, "pdf"))
-        ## If there the installed gnuplot does not support pdf, use Ghostscript.
-        ghostscript_device = "pdfwrite";
-        if (strfind (opts.name, ".pdf") == numel (opts.name) - 3)
-          ghostscript_output = opts.name;
-        else
-          ghostscript_output = strcat (opts.name, ".pdf");
-        endif
-        name = cstrcat (tmpnam, ".ps");
-        termn = "postscript";
-        ## All "options" for pdf work for postscript as well.
-      else
-        error ("print: the device, \"%s\", is not available.", dev)
+        opts.ghostscript.device = "pswrite";
+        opts.ghostscript.level = 1;
       endif
-    endif
-
-    is_eps_file = strncmp (dev, "eps", 3);
-    p.units = get (gcf, "units");
-    p.paperunits = get (gcf, "paperunits");
-    p.papersize = get (gcf, "papersize");
-    p.paperposition = get (gcf, "paperposition");
-    p.paperpositionmode = get (gcf, "paperpositionmode");
-    p.paperorientation = get (gcf, "paperorientation");
-    p.color = get (gcf, "color");
-    if (p.papersize(1) > p.papersize(2))
-      paperorientation = "landscape";
-    else
-      paperorientation = "portrait";
-    endif
-    if (! strcmp (paperorientation, get (gcf, "paperorientation"))
-        && warn_on_inconsistent_orientation)
-       msg = {"print.m - inconsistent papersize and paperorientation properties.\n",
-               sprintf("         papersize = %.2f, %.2f\n", p.papersize),
-               sprintf("         paperorientation = \"%s\"\n", p.paperorientation),
-                       "         the paperorientation property has been ignored"};
-      warning ("%s",msg{:})
-      warn_on_inconsistent_orientation = false;
-    endif
-
-    if (strcmp (termn, "postscript") && ! strncmp (dev, "eps", 3))
-      if (isempty (opts.orientation))
-        opts.orientation = paperorientation;
-      endif
-      ## This is done here to accommodate ghostscript conversion.
-      options = cstrcat (opts.orientation, " ", options);
-    end
-
-    new_terminal = cstrcat (termn, " ", options);
-
-    mono = (opts.use_color < 0);
-
-    terminals_for_prn = {"postscript", "pdf", "pdfcairo"};
-    output_for_printer = any (strncmp (termn, terminals_for_prn, numel(termn)));
-
-    if (isempty (opts.resolution))
-      if (any (strcmp (dev, {"emf", "svg"})) || output_for_printer)
-        opts.resolution = get (0, "screenpixelsperinch");
-      else
-        opts.resolution = 150;
-      endif
-    else
-      opts.resolution = str2num (opts.resolution);
-      if (opts.resolution == 0)
-        opts.resolution = get (0, "screenpixelsperinch");
-      endif
-    endif
-    figure_properties = get (gcf);
-    if (! isfield (figure_properties, "__pixels_per_inch__"))
-      addproperty ("__pixels_per_inch__", gcf, "double", opts.resolution);
+      opts.ghostscript.output = opts.name;
+      eps_drawnow (opts, opts.ghostscript.source, gp_opts);
+    case {"svg"}
+      local_drawnow (sprintf ("svg dynamic %s", gp_opts), opts.name, opts);
+    case {"aifm", "corel", "eepic", "emf", "fig", "pdfcairo", "pngcairo"}
+      local_drawnow (sprintf ("%s %s", opts.devopt, gp_opts), opts.name, opts);
+    case gs_based_devices ()
+      opts.ghostscript.antialiasing = true;
+      switch opts.devopt
+      case "bmp"
+        opts.ghostscript.device = "bmp32b";
+      case "png"
+        opts.ghostscript.device = "png16m";
+      case {"tiff", "tiffn"}
+        opts.ghostscript.device = "tiff24nc";
+      otherwise
+        opts.ghostscript.device = opts.devopt;
+      endswitch
+      opts.ghostscript.output = opts.name;
+      opts.ghostscript.source = strcat (tmpnam (), ".eps");
+      opts.ghostscript.epscrop = true;
+      file2unlink = opts.ghostscript.source;
+      eps_drawnow (opts, opts.ghostscript.source, gp_opts);
+    case {"canvas", "dxf", "hpgl", "mf", "gif", "pstricks", "texdraw"}
+      local_drawnow (sprintf ("%s %s", opts.devopt, gp_opts), opts.name, opts)
+    case {"pdflatex", "pslatexstandalone", "pdflatexstandalone"}
+      error (sprintf ("print:no%soutput", opts.devopt),
+             "print.m: %s output is not available for the GNUPLOT backend.",
+             upper (opts.devopt))
+    otherwise
+      ## various ghostscript devices for printers
+      opts.ghostscript.device = opts.devopt;
+      opts.ghostscript.output = opts.name;
+      opts.ghostscript.epscrop = false;
+      opts.ghostscript.source = strcat (tmpnam (), ".eps");
+      file2unlink = opts.ghostscript.source;
+      ## Gnuplot's BBox LLHC is located at [50,50]
+      opts.ghostscript.pageoffset = opts.ghostscript.pageoffset - 50;
+      ## Empirical observation: "-dpxlcolor" requires a sign change.
+      opts.ghostscript.pageoffset = opts.ghostscript.pageoffset .* [1, -1];
+      ## Printers are not included in gs_devices()
+      gp_opts = font_spec (opts, "devopt", "eps");
+      eps_drawnow (opts, opts.ghostscript.source, gp_opts);
+    endswitch
+  
+    if (! isempty (opts.ghostscript.device))
+      status = __ghostscript__ (opts.ghostscript);
     endif
-    set (gcf, "__pixels_per_inch__", opts.resolution)
-
-    unwind_protect
-      set (gcf, "paperunits", "inches");
-      set (gcf, "units", "pixels");
-      set (gcf, "color", "none");
-      restore_properties = true;
-      if ((! output_for_printer || is_eps_file) && ! doprint)
-        ## If not PDF or PostScript, and the result is not being sent to a printer,
-        ## render an image the size of the paperposition box.
-        ## Trigger the listener to convert all paper props to inches.
-        if (! isempty (opts.canvas_size))
-          size_in_pixels = opts.canvas_size;
-          size_in_pixels = reshape (size_in_pixels, [1, numel(size_in_pixels)]);
-          papersize_in_inches = size_in_pixels ./ opts.resolution;
-          paperposition_in_inches = [0, 0, papersize_in_inches];
-        else
-          paperposition_in_inches = get (gcf, "paperposition");
-          paperposition_in_inches(1:2) = 0;
-          papersize_in_inches = paperposition_in_inches(3:4);
-        endif
-        set (gcf, "papersize", papersize_in_inches);
-        set (gcf, "paperposition", paperposition_in_inches);
-        set (gcf, "paperpositionmode", "manual");
-      else
-        if (strcmp (p.paperpositionmode, "auto"))
-          size_in_pixels = get (gcf, "position")(3:4);
-          paperposition_in_inches(3:4) = size_in_pixels ./ opts.resolution;
-          paperposition_in_inches(1:2) = (p.papersize - paperposition_in_inches(3:4))/2;
-        else
-          paperposition_in_inches = p.paperposition;
-        endif
-        if (! isempty (opts.orientation) && ! strcmp (opts.orientation, paperorientation))
-          ## When -landscape/portrait changes the orientation, flip both the
-          ## papersize and paperposition.
-          restore_properties = true;
-          set (gcf, "papersize", p.papersize([2, 1]));
-          set (gcf, "paperposition", paperposition_in_inches([2, 1, 4, 3]));
-        else
-          set (gcf, "paperposition", paperposition_in_inches);
-        endif
-      endif
-      if (opts.use_color < 0)
-        [objs_with_color, color_of_objs] = convert_color2mono (gcf);
-      endif
-    if (opts.append_to_file)
-         appended_file_name = opts.name;
-         if (index(termn, "pdf"))
-           opts.name = cstrcat (tmpnam, ".pdf");
-           temp_name = cstrcat (tmpnam, ".pdf");
-           ghostscript_device = "pdfwrite";
-         else
-           opts.name = cstrcat (tmpnam, ".ps");
-           temp_name = cstrcat (tmpnam, ".ps");
-           ghostscript_device = "pswrite";
-         endif
-    endif
-      if (opts.debug)
-        drawnow (new_terminal, opts.name, mono, opts.debug_file);
-      else
-        drawnow (new_terminal, opts.name, mono);
-      endif
-      if (opts.append_to_file)
-        ghostscript_options = "-q -dBATCH -dSAFER -dNOPAUSE";
-        command = sprintf ("%s %s -sDEVICE=%s -sOutputFile=%s %s %s -q", ...
-                    opts.ghostscript_binary, ghostscript_options, ghostscript_device,  ...
-                    temp_name, appended_file_name, opts.name);
-        status1 = system (command);
-        status2 = system (sprintf ("mv %s %s", temp_name, appended_file_name));
-        if (status1 != 0 || status2 != 0)
-          error ("print: output failed to append to '%s'.", appended_file_name);
-        endif
+  
+  unwind_protect_cleanup
+    if (! isempty (file2unlink))
+      [status, output] = unlink (file2unlink);
+      if (status != 0)
+        warning ("print.m: %s, '%s'.", output, file2unlink)
       endif
-    unwind_protect_cleanup
-      ## FIXME - it would be nice to delete "__pixels_per_inch__" property here.
-      if (restore_properties)
-        props = fieldnames (p);
-        for n = 1:numel(props)
-          set (gcf, props{n}, p.(props{n}))
-        endfor
-      endif
-      if (opts.use_color < 0)
-        convert_mono_to_or_from_color (objs_with_color, color_of_objs, false);
-      endif
-    end_unwind_protect
-
-    if (! isempty (ghostscript_output))
-      if (is_eps_file && opts.tight_flag)
-        ## If gnuplot's output is an eps-file then crop at the bounding box.
-        __fix_eps_bbox__ (name);
-      endif
-      ghostscript_options = "-q -dBATCH -dSAFER -dNOPAUSE -dTextAlphaBits=4";
-      if (is_eps_file)
-        ghostscript_options = sprintf ("%s -dEPSCrop", ghostscript_options);
-      endif
-      if (isempty (strfind (lower (ghostscript_device), "write")))
-        ## If output is a bitmap then include the resolution
-        ghostscript_options = sprintf ("%s -r%d", ghostscript_options, opts.resolution);
-      endif
-      ghostscript_options = sprintf ("%s -sDEVICE=%s", ghostscript_options,
-                                     ghostscript_device);
-      command = sprintf ("\"%s\" %s -sOutputFile=\"%s\" \"%s\" 2>&1", 
-                         opts.ghostscript_binary,
-                         ghostscript_options, ghostscript_output, opts.name);
-      [errcode, output] = system (command);
-      unlink (name);
-      if (errcode)
-        error ("print: Conversion failed, %s -> %s.\nError was:\n%s\n",
-               name, ghostscript_output, output);
-      endif
-    elseif (is_eps_file && opts.tight_flag && ! doprint)
-      ## If the saved output file is an eps file, use ghostscript to set a tight bbox.
-      ## This may result in a smaller or larger bbox geometry.
-      if (have_ghostscript)
-        __fix_eps_bbox__ (name);
-      endif
-    endif
-
-    if (doprint)
-      if (isunix ())
-        prn_opt = "-l";
-      elseif (ispc ())
-        prn_opt = "-o l";
-      else
-        ## FIXME - besides Unix and Windows, what other OS's might be considered.
-        prn_opt = "";
-      endif
-      if (isempty (opts.printer))
-        prn_cmd = sprintf ("lpr %s '%s' 2>&1", prn_opt, printname);
-      else
-        prn_cmd = sprintf ("lpr %s -P %s '%s' 2>&1", prn_opt, opts.printer, printname);
-      endif
-      [status, output] = system (prn_cmd);
-      if (status != 0)
-        disp (output)
-        warning ("print.m: printing failed.")
-      endif
-      [status, output] = unlink (printname);
-      if (status != 0)
-        disp (output)
-        warning ("print.m: failed to delete temporay file, '%s'.", printname)
-      endif
-    endif
-
-  unwind_protect_cleanup
-    if (isfigure (old_fig))
-      figure (old_fig)
     endif
   end_unwind_protect
 
 endfunction
 
-function [h, c] = convert_color2mono (hfig)
+function eps_drawnow (opts, epsfile, gp_opts)
+  [h, fontsize] = get_figure_text_objs (opts);
   unwind_protect
-    showhiddenhandles = get (0, "showhiddenhandles");
-    set (0, "showhiddenhandles", "on");
-    h.color = findobj (hfig, "-property", "color");
-    h.facecolor = findobj (hfig, "-property", "facecolor");
-    h.edgecolor = findobj (hfig, "-property", "edgecolor");
-    h.backgroundcolor = findobj (hfig, "-property", "backgroundcolor");
-    h.colormap = findobj (hfig, "-property", "colormap");
+    for n = 1:numel(h)
+      set (h, "fontsize", 2 * fontsize{n});
+    endfor
+    local_drawnow (sprintf ("postscript eps %s", gp_opts), epsfile, opts);
+    if (opts.tight_flag)
+      __tight_eps_bbox__ (opts, epsfile);
+    endif
   unwind_protect_cleanup
-    set (0, "showhiddenhandles", showhiddenhandles);
+    for n = 1:numel(h)
+      set (h, "fontsize", fontsize{n});
+    endfor
   end_unwind_protect
-  f = fieldnames (h);
-  for nf = 1:numel(f)
-    if (! isempty (h.(f{nf})))
-      v = get (h.(f{nf}), f{nf});
-      if (! iscell (v))
-        v = {v};
-      endif
-      c.(f{nf}) = v;
-    endif
-  endfor
-  convert_mono_to_or_from_color (h, c, true)
+endfunction
+
+function local_drawnow (term, file, opts)
+  if (opts.use_color < 0)
+    mono = true;
+  else
+    mono = false;
+  endif
+  figure (opts.figure)
+  if (isempty (opts.debug_file) || ! opts.debug)
+    drawnow (term, file, mono);
+  else
+    drawnow (term, file, mono, opts.debug_file);
+  endif
+endfunction
+
+function device_list = gs_based_devices ();
+  ## Aliases for other devices: "bmp", "png", "tiff", "tiffn", "pdf",
+  ##                            "ps", "ps2", "psc", "psc2"
+  device_list = {"bmp16", "bmp16m", "bmp256", "bmp32b", "bmpgray", ...
+                 "jpeg", "jpegcymk", "jpeggray", "pbm", "pbmraw", ...
+                 "pcx16", "pcx24b", "pcx256", "pcx2up", "pcxcmyk", ...
+                 "pcxgray", "pcxmono", "pdfwrite", "pgm", "pgmraw", ...
+                 "pgnm", "pgnmraw", "png16", "png16m", "png256", ...
+                 "png48", "pngalpha", "pnggray", "pngmono", "pnm", ...
+                 "pnmraw", "ppm", "ppmraw", "ps2write", "pswrite", ...
+                 "tiff12nc", "tiff24nc", "tiff32nc", "tiffcrle", ...
+                 "tiffg3", "tiffg32d", "tiffg4", "tiffgray", "tifflzw", ...
+                 "tiffpack", "tiffsep", "bmp", "png", "tiff", "tiffn", ...
+                 "pdf", "ps", "ps2", "psc", "psc2"};
 endfunction
 
-function convert_mono_to_or_from_color (h, c, mono)
-  f = fieldnames (h);
-  for nf = 1:numel(f)
-    for nh = 1:numel (h.(f{nf}))
-      color = c.(f{nf}){nh};
-      ## Ignore color == {"none", "flat", ...}
-      if (isfloat (color))
-        if (mono)
-          ## Same method as used by rgb2gray in the image pkg.
-          color = rgb2ntsc (color)(:,1) * ones (1, 3);
-        endif
-        set (h.(f{nf})(nh), f{nf}, color);
-      endif
-    endfor
+function f = font_spec (opts, varargin)
+  for n = 1:2:numel(varargin)
+    opts.(varargin{n}) = varargin{n+1};
   endfor
+  f = "";
+  switch opts.devopt
+  case {"cgm"}
+    if (! isempty (opts.font) && ! isempty (opts.fontsize))
+      f = sprintf ("font ""%s,%d""", opts.font, opts.fontsize);
+    elseif (! isempty (opts.font))
+      f = sprintf ("font ""%s""", opts.font);
+    elseif (! isempty (opts.fontsize))
+      f = sprintf ("%d", opts.fontsize);
+    endif
+  case {"eps", "eps2", "epsc", "epsc2", gs_based_devices(){:}}
+    ## Gnuplot renders fonts as half their specification, which 
+    ## results in a tight spacing for the axes-labels and tick-labels.
+    ## Compensate for the half scale. This will produce the proper
+    ## spacing for the requested fontsize.
+    if (! isempty (opts.font) && ! isempty (opts.fontsize))
+      f = sprintf ("font ""%s,%d""", opts.font, 2 * opts.fontsize);
+    elseif (! isempty (opts.font))
+      f = sprintf ("font ""%s""", opts.font);
+    elseif (! isempty (opts.fontsize))
+      f = sprintf ("%d", 2 * opts.fontsize);
+    endif
+  case {"svg"}
+    if (! isempty (opts.font) && ! isempty (opts.fontsize))
+      fontsize = round (opts.fontsize * 0.75);
+      f = sprintf ("fname ""%s"" fsize %d", opts.font, fontsize);
+    elseif (! isempty (opts.font))
+      f = sprintf ("fname ""%s""", opts.font);
+    elseif (! isempty (opts.fontsize))
+      fontsize = round (opts.fontsize * 0.75);
+      f = sprintf ("%s fsize %d", f, fontsize);
+    endif
+  case {"pdf"}
+    if (! isempty (opts.font) && ! isempty (opts.fontsize))
+      f = sprintf ("font ""%s,%d""", opts.font, opts.fontsize);
+    elseif (! isempty (opts.font))
+      f = sprintf ("font ""%s""", opts.font);
+    elseif (! isempty (opts.fontsize))
+      f = sprintf ("fsize %d", f, opts.fontsize);
+    endif
+  case {"pdfcairo", "pngcairo"}
+    if (! isempty (opts.font))
+      f = sprintf ("font ""%s""", opts.font);
+    endif
+  case {"epslatex", "epslatexstandalone"}
+    if (! isempty (opts.font) && ! isempty (opts.fontsize))
+      f = sprintf ("font ""%s,%d""", opts.font, opts.fontsize);
+    elseif (! isempty (opts.font))
+      f = sprintf ("font ""%s""", opts.font);
+    elseif (! isempty (opts.fontsize))
+      f = sprintf ("%d", opts.fontsize);
+    endif
+  case {"pslatex"}
+    if (! isempty (opts.fontsize))
+      f = sprintf ("%d", opts.fontsize);
+    endif
+  case {"gif", "jpeg", "png"}
+    if (! isempty (opts.font) && ! isempty (opts.fontsize))
+      f = sprintf ("font ""%s ,%d""", opts.font, opts.fontsize);
+    elseif (! isempty (opts.font))
+      f = sprintf ("font ""%s""", opts.font);
+    elseif (! isempty (opts.fontsize))
+      f = sprintf ("font ""%d""", opts.fontsize);
+    endif
+  case {"emf"}
+    if (! isempty (opts.font) && ! isempty (opts.fontsize))
+      f = sprintf ("""%s"" %d", opts.font, opts.fontsize);
+    elseif (! isempty (opts.font))
+      f = sprintf ("""%s""", opts.font);
+    elseif (! isempty (opts.fontsize))
+      f = sprintf ("%d", opts.fontsize);
+    endif
+  case {"canvas"}
+    if (! isempty (opts.fontsize))
+      f = sprintf ("fsize %d", opts.fontsize);
+    endif
+  case {"aifm", "corel"}
+    if (! isempty (opts.font) && ! isempty (opts.fontsize))
+      f = sprintf ("%s %d", opts.font, opts.fontsize);
+    elseif (! isempty (opts.font))
+      f = sprintf ("%s", opts.font);
+    elseif (! isempty (opts.fontsize))
+      f = sprintf ("%d", opts.fontsize);
+    endif
+  case {"fig"}
+    if (! isempty (opts.font) && ! isempty (opts.fontsize))
+      f = sprintf ("font %s fontsize %d", opts.font, opts.fontsize);
+    elseif (! isempty (opts.font))
+      f = sprintf ("font %s", opts.font);
+    elseif (! isempty (opts.fontsize))
+      f = sprintf ("fontsize %d", opts.fontsize);
+    endif
+  endswitch
 endfunction
 
+function [h, fontsize] = get_figure_text_objs (opts)
+  h = findall (opts.figure, "-property", "fontsize");
+  fontsize = get (h, "fontsize");
+  switch numel (fontsize)
+  case 0
+    fontsize = {};
+  case 1
+    fontsize = {fontsize};
+  endswitch
+endfunction
diff --git a/scripts/plot/__go_draw_axes__.m b/scripts/plot/__go_draw_axes__.m
--- a/scripts/plot/__go_draw_axes__.m
+++ b/scripts/plot/__go_draw_axes__.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} __go_draw_axes__ (@var{h}, @var{plot_stream}, @var{enhanced}, @var{mono})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: jwe
 
-function __go_draw_axes__ (h, plot_stream, enhanced, mono, implicit_margin, bg_is_set)
+function __go_draw_axes__ (h, plot_stream, enhanced, mono, bg_is_set)
 
   if (nargin >= 4 && nargin <= 6)
 
     showhiddenhandles = get (0, "showhiddenhandles");
     unwind_protect
       set (0, "showhiddenhandles", "on");
       axis_obj = __get__ (h);
     unwind_protect_cleanup
@@ -46,28 +46,31 @@ function __go_draw_axes__ (h, plot_strea
     endif
 
     nd = __calc_dimensions__ (axis_obj);
     if (strcmpi (axis_obj.plotboxaspectratiomode, "manual"))
       pos = __actual_axis_position__ (axis_obj);
     else
       pos = axis_obj.position;
     endif
-    pos(1:2) = pos(1:2) - implicit_margin .* [0.75, 0.5];
     if (__gnuplot_has_feature__ ("screen_coordinates_for_{lrtb}margin"))
       if (nd == 2 || all (mod (axis_obj.view, 90) == 0))
         x = [1, 1];
       else
         ## 3D plots need to be sized down to fit in the window.
         x = 1.0 ./ sqrt([2, 2.5]);
       endif
-      fprintf (plot_stream, "set tmargin screen %.15g;\n", pos(2)+pos(4)/2+x(2)*pos(4)/2);
-      fprintf (plot_stream, "set bmargin screen %.15g;\n", pos(2)+pos(4)/2-x(2)*pos(4)/2);
-      fprintf (plot_stream, "set lmargin screen %.15g;\n", pos(1)+pos(3)/2-x(1)*pos(3)/2);
-      fprintf (plot_stream, "set rmargin screen %.15g;\n", pos(1)+pos(3)/2+x(1)*pos(3)/2);
+      fprintf (plot_stream, "set tmargin screen %.15g;\n",
+               pos(2)+pos(4)/2+x(2)*pos(4)/2);
+      fprintf (plot_stream, "set bmargin screen %.15g;\n",
+               pos(2)+pos(4)/2-x(2)*pos(4)/2);
+      fprintf (plot_stream, "set lmargin screen %.15g;\n",
+               pos(1)+pos(3)/2-x(1)*pos(3)/2);
+      fprintf (plot_stream, "set rmargin screen %.15g;\n",
+               pos(1)+pos(3)/2+x(1)*pos(3)/2);
     else
       ## FIXME -- nothing should change for gnuplot 4.2.x.
       fprintf (plot_stream, "set tmargin 0;\n");
       fprintf (plot_stream, "set bmargin 0;\n");
       fprintf (plot_stream, "set lmargin 0;\n");
       fprintf (plot_stream, "set rmargin 0;\n");
 
       fprintf (plot_stream, "set origin %.15g, %.15g;\n", pos(1), pos(2));
@@ -96,17 +99,18 @@ function __go_draw_axes__ (h, plot_strea
       if (isempty (t.string))
         fputs (plot_stream, "unset title;\n");
       else
         [tt, f, s] = __maybe_munge_text__ (enhanced, t, "string");
         fontspec = create_fontspec (f, s, gnuplot_term);
         fprintf (plot_stream, "set title \"%s\" %s %s",
                  undo_string_escapes (tt), fontspec,
                  __do_enhanced_option__ (enhanced, t));
-        if (nd == 3 && __gnuplot_has_feature__ ("screen_coordinates_for_{lrtb}margin"))
+        if (nd == 3
+            && __gnuplot_has_feature__ ("screen_coordinates_for_{lrtb}margin"))
           fprintf (plot_stream, " offset screen 0, screen %.3f;\n", pos(4)/5);
         else
           fprintf (plot_stream, ";\n");
         endif
       endif
     endif
 
     if (! isempty (axis_obj.xlabel))
diff --git a/scripts/plot/__go_draw_figure__.m b/scripts/plot/__go_draw_figure__.m
--- a/scripts/plot/__go_draw_figure__.m
+++ b/scripts/plot/__go_draw_figure__.m
@@ -18,53 +18,21 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} __go_draw_figure__ (@var{h}, @var{plot_stream}, @var{enhanced}, @var{mono})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: jwe
 
-function __go_draw_figure__ (h, plot_stream, enhanced, mono, output_to_paper, implicit_margin)
+function __go_draw_figure__ (h, plot_stream, enhanced, mono)
 
-  if (nargin < 5)
-    output_to_paper = false;
-  elseif (nargin < 6)
-    ## Gnuplot has implicit margins for some output. For example, for postscript
-    ## the margin is 50pts. If not specified asssume 0.
-    implicit_margin = 0;
-  endif
-
-  if (nargin >= 4 && nargin <= 6)
+  if (nargin == 4)
     htype = get (h, "type");
     if (strcmp (htype, "figure"))
-      ## When printing, set paperunits to inches and rely on a listener to convert
-      ## the values for papersize and paperposition.
-      if (output_to_paper)
-        orig_paper_units = get (h, "paperunits");
-        gpval_term = __gnuplot_get_var__ (h, "GPVAL_TERM");
-        gpval_termoptions = __gnuplot_get_var__ (h, "GPVAL_TERMOPTIONS");
-        unwind_protect
-          set (h, "paperunits", "inches");
-          paper_size = get (h, "papersize");
-          paper_position = get (h, "paperposition");
-          paper_position = paper_position ./ paper_size([1, 2, 1, 2]);
-          implicit_margin = implicit_margin ./ paper_size;
-        unwind_protect_cleanup
-          set (h, "paperunits", orig_paper_units);
-        end_unwind_protect
-        if (strcmp (gpval_term, "postscript")
-            && ! isempty (strfind (gpval_termoptions, "landscape")))
-          ## This needed to obtain the expected result.
-          implicit_margin(2) = -implicit_margin(2);
-        endif
-      else
-        implicit_margin = implicit_margin * [1 1];
-      endif
-
       ## Get complete list of children.
       kids = allchild (h);
       nkids = length (kids);
 
       if (nkids > 0)
         fputs (plot_stream, "\nreset;\n");
         fputs (plot_stream, "set autoscale keepfix;\n");
         fputs (plot_stream, "set origin 0, 0\n");
@@ -90,26 +58,19 @@ function __go_draw_figure__ (h, plot_str
                   fprintf (plot_stream, "set obj 2 rectangle from graph 0,0 to graph 1,1 behind fc rgb \"#%02x%02x%02x\"\n", 255 * fg);
                   fg_is_set = true;
                 else
                   fg_is_set = false;
                 endif
                 if (bg_is_set)
                   fprintf (plot_stream, "set border linecolor rgb \"#%02x%02x%02x\"\n", 255 * (1 - bg));
                 endif
-                if (output_to_paper)
-                  axes_position_on_page = orig_axes_position .* paper_position([3, 4, 3 ,4]);
-                  axes_position_on_page(1:2) = axes_position_on_page(1:2) +  paper_position(1:2);
-                  set (kids(i), "position", axes_position_on_page);
-                  __go_draw_axes__ (kids(i), plot_stream, enhanced, mono, implicit_margin, bg_is_set);
-                else
-                  ## Return axes "units" and "position" back to their original values.
-                  __go_draw_axes__ (kids(i), plot_stream, enhanced, mono, implicit_margin, bg_is_set);
-                endif
-                unwind_protect_cleanup
+                ## Return axes "units" and "position" back to their original values.
+                __go_draw_axes__ (kids(i), plot_stream, enhanced, mono, bg_is_set);
+              unwind_protect_cleanup
                 set (kids(i), "units", orig_axes_units);
                 set (kids(i), "position", orig_axes_position);
                 bg_is_set = false;
                 if (fg_is_set)
                   fputs (plot_stream, "unset obj 2\n");
                 endif
               end_unwind_protect
             otherwise
diff --git a/scripts/plot/__print_parse_opts__.m b/scripts/plot/__print_parse_opts__.m
--- a/scripts/plot/__print_parse_opts__.m
+++ b/scripts/plot/__print_parse_opts__.m
@@ -53,17 +53,16 @@ function arg_st = __print_parse_opts__ (
   arg_st.use_color = 0; # 0=default, -1=mono, +1=color
   arg_st.send_to_printer = false;
   
   if (isunix ())
     arg_st.lpr_options = "-l";
   elseif (ispc ())
     arg_st.lpr_options = "-o l";
   else
-    ## FIXME - What other OS's might be considered.
     arg_st.lpr_options = "";
   endif
   arg_st.unlink = {};
   
   for i = 1:nargin
     arg = varargin{i};
     if (ischar (arg))
       if (strcmp (arg, "-color"))
@@ -77,16 +76,18 @@ function arg_st = __print_parse_opts__ (
       elseif (strcmp (arg, "-dashed"))
         arg_st.force_solid = -1;
       elseif (strncmp (arg, "-portrait", numel (arg)))
         arg_st.orientation = "portrait";
       elseif (strncmp (arg, "-landscape", numel (arg)))
         arg_st.orientation = "landscape";
       elseif (strcmp (arg, "-tight"))
         arg_st.tight_flag = true;
+      elseif (strcmp (arg, "-loose"))
+        arg_st.tight_flag = false;
       elseif (strcmp (arg, "-textspecial"))
         arg_st.special_flag = "textspecial";
       elseif (strncmp (arg, "-debug", 6))
         arg_st.debug = true;
         arg_st.ghostscript.debug = true;
         if (length (arg) > 7)
           arg_st.debug_file = arg(8:end);
         endif
@@ -149,49 +150,27 @@ function arg_st = __print_parse_opts__ (
   if (isempty (arg_st.devopt))
     if (dot == 0)
       arg_st.devopt = "psc";
     else
       arg_st.devopt = tolower (arg_st.name(dot+1:end));
     endif
   endif
 
-  if ((any (strcmp ({"ps", "ps2", "eps", "eps2"}, arg_st.devopt))
-      || (! isempty (strfind (arg_st.devopt, "tex")))) && arg_st.use_color == 0)
-    ## Mono is the default for ps, eps, and the tex/latex, devices
+  if (any (strcmp ({"ps", "ps2", "eps", "eps2"}, arg_st.devopt)))
     arg_st.use_color = -1;
-  elseif (arg_st.use_color == 0)
+  else
     arg_st.use_color = 1;
   endif
 
-  if (arg_st.append_to_file)
-    if (isempty (arg_st.name))
-      arg_st.append_to_file = false;
-    elseif (any (strcmpi (arg_st.devopt, {"eps", "eps2", "epsc", "epsc2", ...
-                                          "ps", "ps2", "psc", "psc2", "pdf"})))
-      have_ghostscript = ! isempty (__ghostscript_binary__ ());
-      if (have_ghostscript)
-        file_exists = ((numel (dir (arg_st.name)) == 1) && (! isdir (arg_st.name)));
-        if (! file_exists)
-          arg_st.append_to_file = false;
-        end
-      else
-        arg_st.append_to_file = false;
-        warning ("print.m: appended output requires ghostscript to be installed.")
-      endif
-    else
-      warning ("print.m: appended output is not supported for device '%s'", arg_st.devopt)
-      arg_st.append_to_file = false;
-    endif
-  endif
-
   if (arg_st.tight_flag)
     if (any (strcmpi (arg_st.devopt, {"ps", "ps2", "psc", "psc2", "pdf"})))
       arg_st.tight_flag = false;
-      warning ("print.m: '-tight' is not supported for device '%s'", arg_st.devopt)
+      warning ("print.m: '-tight' is not supported for device '%s'",
+               arg_st.devopt)
     endif
   endif
 
   if (strcmp (arg_st.devopt, "tex"))
     arg_st.devopt = "epslatex";
   elseif (strcmp (arg_st.devopt, "ill"))
     arg_st.devopt = "aifm";
   elseif (strcmp (arg_st.devopt, "cdr"))
@@ -217,44 +196,70 @@ function arg_st = __print_parse_opts__ (
               "svg", "hpgl", "ps", "ps", "ps", ...
               "ps", "eps", "eps", "eps", "eps", ...
               "emf", "pdf", "tex", "tex", "tex", ...
               "tex", "tex", ...
               "ps", "tiff", "tiff", "tikz", "pcx", ...
               "pcx", "pcx", "pcx", "pgm", "pgm", ...
               "ppm", "ppm", "tex"};
 
+  if (strcmp (get (arg_st.figure, "__backend__"), "gnuplot")
+      && __gnuplot_has_feature__ ("epslatex_implies_eps_filesuffix"))
+    suffixes(strncmp (dev_list, "epslatex", 8)) = {"eps"};
+  endif
+
   match = strcmpi (dev_list, arg_st.devopt);
   if (any (match))
     default_suffix = suffixes {match};
   else
     default_suffix = arg_st.devopt;
   endif
 
   if (dot == 0 && ! isempty (arg_st.name))
     arg_st.name = strcat (arg_st.name, ".", default_suffix);
   endif
 
+  if (arg_st.append_to_file)
+    if (isempty (arg_st.name))
+      arg_st.append_to_file = false;
+    elseif (any (strcmpi (arg_st.devopt, {"eps", "eps2", "epsc", "epsc2", ...
+                                          "ps", "ps2", "psc", "psc2", "pdf"})))
+      have_ghostscript = ! isempty (__ghostscript_binary__ ());
+      if (have_ghostscript)
+        file_exists = ((numel (dir (arg_st.name)) == 1) && (! isdir (arg_st.name)));
+        if (! file_exists)
+          arg_st.append_to_file = false;
+        end
+      else
+        arg_st.append_to_file = false;
+        warning ("print.m: appended output requires ghostscript to be installed.")
+      endif
+    else
+      warning ("print.m: appended output is not supported for device '%s'", arg_st.devopt)
+      arg_st.append_to_file = false;
+    endif
+  endif
+
   if (! isempty (arg_st.printer) || isempty (arg_st.name))
     arg_st.send_to_printer = true;
     if (isempty (arg_st.name))
       arg_st.name = strcat (tmpnam (), ".", default_suffix);
       arg_st.unlink{end+1} = arg_st.name;
     endif
   endif
 
   if (all (! strcmp (arg_st.devopt, dev_list)))
     arg_st.ghostscript.device = arg_st.devopt;
     arg_st.ghostscript.output = arg_st.name;
   endif
 
   if (isempty (arg_st.canvas_size))
     if (isfigure (arg_st.figure))
       [arg_st.ghostscript.papersize, paperposition] = gs_papersize (arg_st.figure,
-                                                               arg_st.orientation);
+                                                             arg_st.orientation);
     else
       ## allows tests to be run
       arg_st.ghostscript.papersize = "letter";
       paperposition = [0.25, 2.50, 8.00, 6.00] * 72;
     endif
     arg_st.canvas_size = paperposition(3:4);
     arg_st.ghostscript.pageoffset = paperposition(1:2);
   else
@@ -451,17 +456,17 @@ function [papersize, paperposition] = gs
 
   if (strcmp (paperunits, "normalized"))
     paperposition = paperposition .* papersize([1,2,1,2]);
   else
     paperposition = convert2points (paperposition, paperunits);
   endif
 
   ## FIXME - This will be obsoleted by listeners for paper properties.
-  ## Papersize is tall when portrait,and wide when landscape.
+  ##         Papersize is tall when portrait,and wide when landscape.
   if ((papersize(1) > papersize(2) && strcmpi (paperorientation, "portrait"))
       || (papersize(1) < papersize(2) && strcmpi (paperorientation, "landscape")))
     papersize = papersize ([2,1]);
     paperposition = paperposition([2,1,4,3]);
   endif
 
   if ((! strcmp (papertype, "<custom>")) && (strcmp (paperorientation, "portrait")))
     ## For portrait use the ghostscript name
diff --git a/scripts/plot/gnuplot_drawnow.m b/scripts/plot/gnuplot_drawnow.m
--- a/scripts/plot/gnuplot_drawnow.m
+++ b/scripts/plot/gnuplot_drawnow.m
@@ -33,36 +33,34 @@ function gnuplot_drawnow (h, term, file,
     mono = false;
   endif
 
   if (nargin >= 3 && nargin <= 5)
     ## Produce various output formats, or redirect gnuplot stream to a
     ## debug file.
     plot_stream = [];
     fid = [];
-    printing = ! output_to_screen (gnuplot_trim_term (term));
     default_plot_stream = get (h, "__plot_stream__");
     unwind_protect
       plot_stream = __gnuplot_open_stream__ (2, h);
       if (__gnuplot_has_feature__ ("variable_GPVAL_TERMINALS"))
         available_terminals = __gnuplot_get_var__ (plot_stream, "GPVAL_TERMINALS");
         available_terminals = regexp (available_terminals, "\\b\\w+\\b", "match");
         gnuplot_supports_term = any (strcmpi (available_terminals,
                                               gnuplot_trim_term (term)));
       else
         gnuplot_supports_term = true;
       endif
       if (gnuplot_supports_term)
-        [enhanced, implicit_margin] = gnuplot_set_term (plot_stream (1), true,
-                                                        h, term, file);
-        __go_draw_figure__ (h, plot_stream(1), enhanced, mono, printing, implicit_margin);
+        enhanced = gnuplot_set_term (plot_stream (1), true, h, term, file);
+        __go_draw_figure__ (h, plot_stream(1), enhanced, mono);
         if (nargin == 5)
           fid = fopen (debug_file, "wb");
-          [enhanced, implicit_margin] = gnuplot_set_term (fid, true, h, term, file);
-          __go_draw_figure__ (h, fid, enhanced, mono, printing, implicit_margin);
+          enhanced = gnuplot_set_term (fid, true, h, term, file);
+          __go_draw_figure__ (h, fid, enhanced, mono);
         endif
       else
         error ("gnuplot_drawnow: the gnuplot terminal, \"%s\", is not available.",
                gnuplot_trim_term (term))
       endif
     unwind_protect_cleanup
       set (h, "__plot_stream__", default_plot_stream);
       if (! isempty (plot_stream))
@@ -91,17 +89,17 @@ function gnuplot_drawnow (h, term, file,
     if (strcmp (term, "dumb"))
       ## popen2 eats stdout of gnuplot, use temporary file instead
       dumb_tmp_file = tmpnam ();
       enhanced = gnuplot_set_term (plot_stream (1), new_stream, h, ...
                                    term, dumb_tmp_file);
     else
       enhanced = gnuplot_set_term (plot_stream (1), new_stream, h, term);
     end
-    __go_draw_figure__ (h, plot_stream (1), enhanced, mono, 0);
+    __go_draw_figure__ (h, plot_stream (1), enhanced, mono);
     fflush (plot_stream (1));
     if (strcmp (term, "dumb"))
       fid = -1;
       while (fid < 0)
         pause (0.1);
         fid = fopen (dumb_tmp_file, 'r');
       endwhile
       ## reprint the plot on screen
@@ -117,51 +115,40 @@ function gnuplot_drawnow (h, term, file,
       unlink (dumb_tmp_file);
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
-function implicit_margin = gnuplot_implicit_margin (term, opts_str)
-  ## gnuplot has an implicit margin of 50pts for PS output.
-  if (strcmpi (term, "postscript"))
-    if (isempty (strfind (opts_str, " eps"))
-        && isempty (strfind (opts_str, "eps ")))
-      implicit_margin = 50/72;
-    else
-      ## When zero, the behavior of gnuplot changes.
-      implicit_margin = 1/72;
-    endif
-  else
-    implicit_margin = 0.0;
-  endif
-endfunction
-
-function [enhanced, implicit_margin] = gnuplot_set_term (plot_stream, new_stream, h, term, file)
+function enhanced = gnuplot_set_term (plot_stream, new_stream, h, term, file)
   ## Generate the gnuplot "set terminal <term> ..." command.
   ## When "term" originates from print.m, it may include other options.
   if (nargin < 4)
     ## This supports the gnuplot backend.
     term = gnuplot_default_term ();
     opts_str = "";
   else
     ## Get the one word terminal id and save the remaining as options to
     ## be passed on to gnuplot.  The terminal may respect the backend.
     [term, opts_str] = gnuplot_trim_term (term);
-    if (strcmpi (term, "pdf") && strcmpi (opts_str, "color"))
-      ## FIXME -- "color" for the pdf terminal produces a gnuplot error.
-      opts_str = "";
+    term = lower (term);
+    if (strcmpi (term, "lua"))
+      ## Replace "lau tikz" with 
+      term = "tikz";
+      opts_str = strrep (opts_str, "tikz", "");
     endif
   endif
 
-  implicit_margin = gnuplot_implicit_margin (term, opts_str);
-
-  enhanced = gnuplot_is_enhanced_term (term);
+  if (strfind (opts_str, "noenhanced"))
+    enhanced = false;
+  else
+    enhanced = gnuplot_is_enhanced_term (term);
+  endif
 
   ## Set the terminal.
   if (! isempty (term))
 
     if (enhanced)
       enh_str = "enhanced";
     else
       enh_str = "";
@@ -181,119 +168,97 @@ function [enhanced, implicit_margin] = g
         if (! isempty (fig.name) && ! isempty (title_str))
           title_str = sprintf ("%s: %s", title_str, fig.name);
         elseif (! isempty (fig.name) && isempty (title_str))
           title_str = fig.name;
         endif
         if (! isempty (title_str))
           title_str = sprintf ("title \"%s\"", title_str);
         endif
+        if (strcmp (term, "aqua"))
+          ## Adjust axes-label and tick-label spacing.
+          opts_str = sprintf ("%s font \"%s,%d\"", opts_str, 
+                              get (0, "defaultaxesfontname"),
+                              get (0, "defaultaxesfontsize") / 1.5);
+        endif
       else
         title_str = "";
       endif
+
       if (! (any (strfind (opts_str, " size ") > 0) 
           || any (strfind (opts_str, "size ") == 1)))
-        ## Convert position to units used by gnuplot.
-        if (output_to_screen (term))
-          ## Get figure size in pixels.  Rely on listener
-          ## to handle coversion of position property.
-          units = get (h, "units");
-          unwind_protect
-            set (h, "units", "pixels");
-            position_in_pixesl = get (h, "position");
-          unwind_protect_cleanup
-            set (h, "units", units);
-          end_unwind_protect
-          gnuplot_pos = position_in_pixesl(1:2);
-          gnuplot_size = position_in_pixesl(3:4);
-        else
-          ## Get size of the printed plot in inches. Rely on listener
-          ## to handle coversion of papersize property.
-          paperunits = get (h, "paperunits");
-          unwind_protect
-            set (h, "paperunits", "inches");
-            gnuplot_size = get (h, "papersize");
-          unwind_protect_cleanup
-            set (h, "paperunits", paperunits);
-          end_unwind_protect
-          if (term_units_are_pixels (term))
-            ## Convert to inches using the property set by print().
-            gnuplot_size = gnuplot_size * get (h, "__pixels_per_inch__");
-          else
-            ## Implicit margins are in units of "inches"
-            gnuplot_size = gnuplot_size - implicit_margin;
-          endif
-        endif
-        [begin_match, end_match, te, match] = regexp (opts_str, "(\\s-r\\d+)|(^-r\\d+)");
-        if (! isempty (begin_match))
-          error ("gnuplot_drawnow: specifying resultion, '%s', not supported for terminal '%s'",
-                 strtrim (match{1}), term)
+        ## Get figure size in pixels.  Rely on listener to handle coversion.
+        units = get (h, "units");
+        unwind_protect
+          set (h, "units", "pixels");
+          position_in_pixels = get (h, "position");
+        unwind_protect_cleanup
+          set (h, "units", units);
+        end_unwind_protect
+        gnuplot_pos = position_in_pixels(1:2);
+        gnuplot_size = position_in_pixels(3:4);
+        if (! (output_to_screen (term)
+               || any (strcmp (term, {"emf", "gif", "jpeg", "pbm", "png", ...
+                                      "pngcairo", "svg"}))))
+          ## Convert to inches
+          gnuplot_pos = gnuplot_pos / 72;
+          gnuplot_size = gnuplot_size / 72;
         endif
         if (all (gnuplot_size > 0))
-          ## Set terminal size.
-          terminals_with_size = {"emf", "gif", "jpeg", "latex", "pbm", ...
-                                 "pdf", "png", "postscript", "svg", ...
-                                 "epslatex", "pstex", "pslatex", "tikz"};
+          terminals_with_size = {"canvas", "emf", "epslatex", "fig", ...
+                                 "gif", "jpeg", "latex", "pbm", "pdf", ...
+                                 "pdfcairo", "postscript", "png", "pngcairo", ...
+                                 "pstex", "pslatex", "svg", "tikz"};
           if (__gnuplot_has_feature__ ("x11_figure_position"))
             terminals_with_size{end+1} = "x11";
           endif
           if (__gnuplot_has_feature__ ("wxt_figure_size"))
             terminals_with_size{end+1} = "wxt";
           endif
-          if (any (strncmpi (term, terminals_with_size, 3)))
-            if (term_units_are_pixels (term))
-              size_str = sprintf ("size %d,%d", gnuplot_size);
-            elseif (strcmp (term, "tikz"))
-              size_str = sprintf ("size %.15gin,%.15gin", gnuplot_size);
-            else
-              size_str = sprintf ("size %.15g,%.15g", gnuplot_size);
-            endif
-            if (strncmpi (term, "X11", 3) && __gnuplot_has_feature__ ("x11_figure_position"))
-              ## X11 allows the window to be positioned as well.
-              units = get (0, "units");
-              unwind_protect
-                set (0, "units", "pixels");
-                screen_size = get (0, "screensize")(3:4);
-              unwind_protect_cleanup
-                set (0, "units", units);
-              end_unwind_protect
-              if (all (screen_size > 0))
-                ## For X11, set the figure positon as well as the size
-                ## gnuplot position is UL, Octave's is LL (same for screen/window)
-                gnuplot_pos(2) = screen_size(2) - gnuplot_pos(2) - gnuplot_size(2);
-                gnuplot_pos = max (gnuplot_pos, 1);
-                size_str = sprintf ("%s position %d,%d", size_str, 
-                                    gnuplot_pos(1), gnuplot_pos(2));
-              endif
-            endif
-          elseif (strncmpi (term, "aqua", 3))
-            ## Aqua has size, but the format is different.
-            size_str = sprintf ("size %d %d", gnuplot_size);
-          elseif (strncmpi (term, "dumb", 3))
+          switch term
+          case terminals_with_size
+            size_str = sprintf ("size %g,%g", gnuplot_size);
+          case "tikz"
+            size_str = sprintf ("size %gin,%gin", gnuplot_size);
+          case "dumb"
             new_stream = 1;
             if (~isempty (getenv ("COLUMNS")) && ~isempty (getenv ("LINES")))
               ## Let dumb use full text screen size (minus prompt lines).
               n = sprintf ("%i", -2 - length (find (sprintf ("%s", PS1) == "\n")));
               ## n = the number of times \n appears in PS1
               size_str = ["size ", getenv("COLUMNS"), ",", getenv("LINES"), n];
             else
               ## Use the gnuplot default.
               size_str = "";
             end
-          elseif (strncmpi (term, "fig", 3))
-            ## Fig also has size, but the format is different.
-            size_str = sprintf ("size %.15g %.15g", gnuplot_size);
-          elseif (any (strncmpi (term, {"corel", "hpgl"}, 3)))
-            ## The size for corel and hpgl are goes at the end (implicit).
-            size_str = sprintf ("%.15g %.15g", gnuplot_size);
-          elseif (any (strncmpi (term, {"dxf"}, 3)))
-            ## DXF uses autocad units.
+          case {"aqua", "fig", "corel"}
+            size_str = sprintf ("size %g %g", gnuplot_size);
+          case "dxf"
+            size_str = "";
+          otherwise
             size_str = "";
-          else
-            size_str = "";
+          endswitch
+          if (strncmpi (term, "x11", 3)
+              && __gnuplot_has_feature__ ("x11_figure_position"))
+            ## X11 allows the window to be positioned as well.
+            units = get (0, "units");
+            unwind_protect
+              set (0, "units", "pixels");
+              screen_size = get (0, "screensize")(3:4);
+            unwind_protect_cleanup
+              set (0, "units", units);
+            end_unwind_protect
+            if (all (screen_size > 0))
+              ## For X11, set the figure positon as well as the size
+              ## gnuplot position is UL, Octave's is LL (same for screen/window)
+              gnuplot_pos(2) = screen_size(2) - gnuplot_pos(2) - gnuplot_size(2);
+              gnuplot_pos = max (gnuplot_pos, 1);
+              size_str = sprintf ("%s position %d,%d", size_str, 
+                                  gnuplot_pos(1), gnuplot_pos(2));
+            endif
           endif
         else
           size_str = "";
           warning ("gnuplot_set_term: size is zero")
         endif
       else
         ## A specified size take priority over the figure properies.
         size_str = "";
@@ -311,25 +276,38 @@ function [enhanced, implicit_margin] = g
     ## Set the gnuplot terminal (type, enhanced, title, options & size).
     term_str = sprintf ("set terminal %s", term);
     if (! isempty (enh_str))
       term_str = sprintf ("%s %s", term_str, enh_str);
     endif
     if (! isempty (title_str))
       term_str = sprintf ("%s %s", term_str, title_str);
     endif
-    if (nargin > 3 && ischar (opts_str))
-      ## Options must go last.
-      term_str = sprintf ("%s %s", term_str, opts_str);
+    if (isempty (strfind (term, "corel")))
+      if (! isempty (size_str) && new_stream)
+        ## size_str comes after other options to permit specification of
+        ## the canvas size for terminals cdr/corel.
+        term_str = sprintf ("%s %s", term_str, size_str);
+      endif
+      if (nargin > 3 && ischar (opts_str))
+        ## Options must go last.
+        term_str = sprintf ("%s %s", term_str, opts_str);
+      endif
+    else
+      if (nargin > 3 && ischar (opts_str))
+        ## Options must go last.
+        term_str = sprintf ("%s %s", term_str, opts_str);
+      endif
+      if (! isempty (size_str) && new_stream)
+        ## size_str comes after other options to permit specification of
+        ## the canvas size for terminals cdr/corel.
+        term_str = sprintf ("%s %s", term_str, size_str);
+      endif
     endif
-    if (! isempty (size_str) && new_stream)
-      ## size_str comes after other options to permit specification of
-      ## the canvas size for terminals cdr/corel.
-      term_str = sprintf ("%s %s", term_str, size_str);
-    endif
+
     ## Work around the gnuplot feature of growing the x11 window and
     ## flickering window (x11, windows, & wxt) when the mouse and
     ## multiplot are set in gnuplot.
     fputs (plot_stream, "unset multiplot;\n");
     flickering_terms = {"x11", "windows", "wxt", "dumb"};
     if (! any (strcmp (term, flickering_terms))
         || numel (findall (h, "type", "axes")) > 1
         || numel (findall (h, "type", "image")) > 0)
@@ -385,27 +363,24 @@ function [term, opts] = gnuplot_trim_ter
   endif
 endfunction
 
 function have_enhanced = gnuplot_is_enhanced_term (term)
   persistent enhanced_terminals;
   if (isempty (enhanced_terminals))
     ## Don't include pstex, pslatex or epslatex here as the TeX commands
     ## should not be interpreted in that case.
-    enhanced_terminals = {"aqua", "dumb", "png", "jpeg", "gif", "pm", ...
-                          "windows", "wxt", "svg", "postscript", "x11", ...
-                          "pdf", "emf"};
+    enhanced_terminals = {"aqua", "canvas", "dumb", "emf", "gif", "jpeg", ...
+                          "pdf", "pdfcairo", "pm", "png", "pngcairo", ...
+                          "postscript", "svg", "windows", "wxt", "x11"};
   endif
   if (nargin < 1)
     ## Determine the default gnuplot terminal.
     term = gnuplot_default_term ();
   endif
   have_enhanced = any (strncmp (enhanced_terminals, term, min (numel (term), 3)));
 endfunction
 
 function ret = output_to_screen (term)
   ret = any (strcmpi ({"aqua", "dumb", "wxt", "x11", "windows", "pm"}, term));
 endfunction
 
-function ret = term_units_are_pixels (term)
-  ret = any (strncmpi ({"emf", "gif", "jpeg", "pbm", "png", "svg"}, term, 3));
-endfunction
 
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -84,24 +84,26 @@
 ##   @itemx epslatexstandalone
 ##   @itemx pstex
 ##   @itemx pslatex
 ##   @itemx pdflatex
 ##     Generate a @LaTeX{} (or @TeX{}) file for labels, and eps/ps/pdf
 ## for graphics.  The file produced by @code{epslatexstandalone} can be
 ## processed directly by @LaTeX{}.  The other formats are intended to
 ## be included in a @LaTeX{} (or @TeX{}) document.  The @code{tex} device
-## is the same as the @code{epslatex} device.
+## is the same as the @code{epslatex} device. The @code{pdflatex} device
+## is only available for the FLTK backend.
 ##
 ##   @item tikz
-##     Generate a @LaTeX{} file using PGF/TikZ.
+##     Generate a @LaTeX{} file using PGF/TikZ. For the FLTK the result is
+##   PGF.
 ##
 ##   @item ill
 ##   @itemx aifm
-##     Adobe Illustrator
+##     Adobe Illustrator (Obsolete for Gnuplot versions > 4.2)
 ##
 ##   @item cdr
 ##   @itemx @nospell{corel}
 ##     CorelDraw
 ##
 ##   @item dxf
 ##     AutoCAD
 ##
@@ -178,17 +180,17 @@
 ## and devices are available.
 ##
 ##   When Ghostscript output is sent to a printer the size is determined
 ## by the figure's "papersize" property.  When the output 
 ## is sent to a file the size is determined by the plot box defined by
 ## the figure's "paperposition" property.
 ##
 ## @itemx -append
-##   Appends the PS, PDF, or EPS output to a pre-existing file of the 
+##   Appends the PS, or PDF output to a pre-existing file of the 
 ## same type.
 ##
 ## @itemx -r@var{NUM}
 ##   Resolution of bitmaps in pixels per inch.  For both metafiles and 
 ## SVG the default is the screen resolution, for other it is 150 dpi.
 ## To specify screen resolution, use "-r0".
 ##
 ## @item -tight
@@ -219,88 +221,73 @@ function print (varargin)
   opts = __print_parse_opts__ (varargin{:});
 
   if (! isfigure (opts.figure))
     error ("print: no figure to print.")
   endif
 
   orig_figure = get (0, "currentfigure");
   figure (opts.figure)
-  drawnow ();
-  backend = (get (opts.figure, "__backend__"));
-
-  if (strcmp (backend, "gnuplot"))
-    ## FIXME - this can be removed when __gnuplot_print__ has been modified
-    ##         to work consistently with __fltk_print__
-    opts.ghostscript_binary = opts.ghostscript.binary;
-    opts.resolution = opts.ghostscript.resolution;
-    opts.canvas_size = opts.canvas_size * opts.resolution / 72;
-    opts.resolution = sprintf ("%d", opts.resolution);
-    opts.fontsize = sprintf ("%d", opts.fontsize);
-    if (strcmp (opts.devopt, "tiff"))
-      error ("print:notiffoutput",
-             "print.m: TIFF output is not available for the Gnuplot backend.")
-    endif
-    __gnuplot_print__ (opts);
-    return
-  else
-    if (strcmp (opts.devopt, "gif"))
-      error ("print:notiffoutput",
-             "print.m: GIF output is not available for the FLTK backend.")
-    endif
-  endif
 
   if (opts.append_to_file && ! (strncmp (opts.devopt, "pdf", 3)
          || strncmp (opts.devopt(1:2), "ps", 2)))
     warning ("print:cannotappendfile", 
              "print.m: Cannot append files of type '%s'.", opts.devopt)
     opts.append_to_file = false;
   endif
 
-  if (opts.append_to_file)
-    saved_original_file = strcat (tmpnam (), ".", opts.devopt);
-    opts.unlink(end+1) = {saved_original_file};
-    movefile (opts.name, saved_original_file);
-  endif
+  unwind_protect
 
-  ## Modify properties as specified by options
-  ## FIXME - need an unwind_protect block
-  props = [];
+    if (opts.append_to_file)
+      saved_original_file = strcat (tmpnam (), ".", opts.devopt);
+      opts.unlink(end+1) = {saved_original_file};
+      movefile (opts.name, saved_original_file);
+    endif
 
-  unwind_protect
+    ## Modify properties as specified by options
+    props = [];
 
     ## backend tranlates figure position to eps bbox in points
     fpos = get (opts.figure, "position");
     props(1).h = opts.figure;
     props(1).name = "position";
     props(1).value = {fpos};
     fpos(3:4) = opts.canvas_size;
     set (opts.figure, "position", fpos)
 
+    ## Set figure background to none. This is done both for
+    ## consistency with Matlab and to elliminate the visible
+    ## box along the figure's perimeter.
+    props(2).h = opts.figure;
+    props(2).name = "color";
+    props(2).value{1} = get (props(2).h, props(2).name);
+    set (props(2).h, props(2).name, "none");
+
     if (opts.force_solid != 0)
-      h = findobj (opts.figure, "-property", "linestyle");
+      h = findall (opts.figure, "-property", "linestyle");
       m = numel (props);
       for n = 1:numel(h)
         props(m+n).h = h(n);
         props(m+n).name = "linestyle";
         props(m+n).value = {get(h(n), "linestyle")};
       endfor
       if (opts.force_solid > 0)
         linestyle = "-";
       else
         linestyle = "--";
       endif
       set (h, "linestyle", linestyle)
     endif
 
-    if (opts.use_color < 0)
+    if (opts.use_color < 0
+        && ! strcmp (get (opts.figure, "__backend__"), "gnuplot"))
       color_props = {"color", "facecolor", "edgecolor", "colormap"};
       for c = 1:numel(color_props)
-        h = findobj (opts.figure, "-property", color_props{c});
-        hnone = findobj (opts.figure, color_props{c}, "none");
+        h = findall (opts.figure, "-property", color_props{c});
+        hnone = findall (opts.figure, color_props{c}, "none");
         h = setdiff (h, hnone);
         m = numel (props);
         for n = 1:numel(h)
           rgb = get (h(n), color_props{c});
           props(m+n).h = h(n);
           props(m+n).name = color_props{c};
           props(m+n).value = {get(h(n), color_props{c})};
           xfer = repmat ([0.30, 0.59, 0.11], size (rgb, 1), 1);
@@ -309,17 +296,17 @@ function print (varargin)
             ggg = repmat (sum (xfer .* rgb, 2), 1, 3);
             set (h(n), color_props{c}, ggg)
           endif
         endfor
       endfor
     endif
 
     if (! isempty (opts.font) || ! isempty (opts.fontsize))
-      h = findobj (opts.figure, "-property", "fontname");
+      h = findall (opts.figure, "-property", "fontname");
       m = numel (props);
       for n = 1:numel(h)
         if (! isempty (opts.font))
           props(end+1).h = h(n);
           props(end).name = "fontname";
           props(end).value = {get(h(n), "fontname")};
         endif
         if (! isempty (opts.fontsize))
@@ -337,92 +324,88 @@ function print (varargin)
         else
           fontsize = opts.fontsize;
         endif
         set (h, "fontsize", fontsize)
       endif
     endif
 
     ## call the backend print script
-    drawnow ("expose")
-    feval (strcat ("__", backend, "_print__"), opts);
+    feval (strcat ("__", get (opts.figure, "__backend__") , "_print__"), opts);
+
+    ## Send to the printer
+    if (opts.send_to_printer)
+      if (isempty (opts.ghostscript.output))
+        prn_datafile = opts.name;
+      else
+        prn_datafile = opts.ghostscript.output;
+      endif
+      if (isempty (opts.printer))
+        prn_cmd = sprintf ("lpr %s '%s' 2>&1", opts.lpr_options, prn_datafile);
+      else
+        prn_cmd = sprintf ("lpr %s -P %s '%s' 2>&1", opts.lpr_options,
+                           opts.printer, prn_datafile);
+      endif
+      if (opts.debug)
+        fprintf ("lpr command: %s\n", prn_cmd)
+        [status, output] = system ("lpq");
+        disp (output)
+      endif
+      [status, output] = system (prn_cmd);
+      if (status != 0)
+        disp (output)
+        warning ("print.m: printing failed.")
+      endif
+    endif
+
+    ## Append to file using GS
+    if (opts.append_to_file)
+      if (strncmp (opts.devopt, "pdf", 3))
+        suffix = "pdf";
+        device = suffix;
+      elseif (strncmp (opts.devopt(1:2), "ps", 2))
+        ## FIXME - For FLTK & Gnuplot the fonts get mangled
+        ##         See "How to concatenate several PS files" at the link,
+        ##         http://en.wikibooks.org/wiki/PostScript_FAQ
+        suffix = "ps";
+        device = suffix;
+      endif
+      tmp_combined_file = strcat (tmpnam (), ".", suffix);
+      opts.unlink{end+1} = tmp_combined_file;
+      gs_opts = "-dQUIET -dNOPAUSE -dBATCH -dSAFER -dFIXEDMEDIA";
+      gs_cmd = sprintf ("%s %s -sDEVICE=%swrite -sOutputFile=%s %s %s", 
+               opts.ghostscript.binary, gs_opts, device, tmp_combined_file,
+               saved_original_file, opts.name);
+      [status, output] = system (gs_cmd);
+      if (opts.debug)
+        fprintf ("Append files: %s\n", gs_cmd);
+      endif
+      if (status != 0)
+        warning ("print:failedtoappendfile", 
+                 "print.m: failed to append output to file '%s'.", opts.name)
+        copyfile (saved_original_file, opts.name);
+      else
+        copyfile (tmp_combined_file, opts.name);
+      endif
+    endif
 
   unwind_protect_cleanup
-
     ## restore modified properties
     if (isstruct (props))
       for n = 1:numel(props)
         set (props(n).h, props(n).name, props(n).value{1})
       endfor
     endif
 
+    ## Unlink temporary files
+    for n = 1:numel(opts.unlink)
+      [status, output] = unlink (opts.unlink{n});
+      if (status != 0)
+        warning ("print.m: %s, '%s'.", output, opts.unlink{n})
+      endif
+    endfor
   end_unwind_protect
 
-  ## Send to the printer
-  if (opts.send_to_printer)
-    if (isempty (opts.ghostscript.output))
-      prn_datafile = opts.name;
-    else
-      prn_datafile = opts.ghostscript.output;
-    endif
-    if (isempty (opts.printer))
-      prn_cmd = sprintf ("lpr %s '%s' 2>&1", opts.lpr_options, prn_datafile);
-    else
-      prn_cmd = sprintf ("lpr %s -P %s '%s' 2>&1", opts.lpr_options,
-                         opts.printer, prn_datafile);
-    endif
-    if (opts.debug)
-      fprintf ("lpr command: %s\n", prn_cmd)
-      [status, output] = system ("lpq");
-      disp (output)
-    endif
-    [status, output] = system (prn_cmd);
-    if (status != 0)
-      disp (output)
-      warning ("print.m: printing failed.")
-    endif
-  endif
-
-  ## Append to file using GS
-  if (opts.append_to_file)
-    if (strncmp (opts.devopt, "pdf", 3))
-      suffix = "pdf";
-      device = suffix;
-    elseif (strncmp (opts.devopt(1:2), "ps", 2))
-      ## FIXME - For FLTK the fonts get mangled
-      ##         See the seciton "How to concatenate several PS files" at the link,
-      ##         http://en.wikibooks.org/wiki/PostScript_FAQ
-      suffix = "ps";
-      device = suffix;
-    endif
-    tmp_combined_file = strcat (tmpnam (), ".", suffix);
-    opts.unlink{end+1} = tmp_combined_file;
-    gs_opts = "-dQUIET -dNOPAUSE -dBATCH -dSAFER -dFIXEDMEDIA";
-    gs_cmd = sprintf ("%s %s -sDEVICE=%swrite -sOutputFile=%s %s %s", 
-             opts.ghostscript.binary, gs_opts, device, tmp_combined_file,
-             saved_original_file, opts.name);
-    [status, output] = system (gs_cmd);
-    if (opts.debug)
-      fprintf ("Append files: %s\n", gs_cmd);
-    endif
-    if (status != 0)
-      warning ("print:failedtoappendfile", 
-               "print.m: failed to append output to file '%s'.", opts.name)
-      copyfile (saved_original_file, opts.name);
-    else
-      copyfile (tmp_combined_file, opts.name);
-    endif
-  endif
-
-  ## Unlink temporary files
-  for n = 1:numel(opts.unlink)
-    [status, output] = unlink (opts.unlink{n});
-    if (status != 0)
-      disp (output)
-      warning ("print.m: failed to delete temporay file, '%s'.", opts.unlink{n})
-    endif
-  endfor
-
   if (isfigure (orig_figure))
     figure (orig_figure);
   endif
 
 endfunction
diff --git a/scripts/plot/private/__ghostscript__.m b/scripts/plot/private/__ghostscript__.m
--- a/scripts/plot/private/__ghostscript__.m
+++ b/scripts/plot/private/__ghostscript__.m
@@ -29,16 +29,17 @@ function status = __ghostscript__ (varar
   opts.output = "";
   opts.device = "";
   opts.epscrop = false;
   opts.antialiasing  = false;
   opts.resolution = 150;
   opts.papersize = "";
   opts.pageoffset = [0 0];
   opts.debug = false;
+  opts.level = [];
 
   offsetfile = "";
 
   args = varargin;
   n = find (cellfun (@isstruct, args));
   if (! isempty (n))
     f = fieldnames (args{n});
     for m = 1:numel(f)
@@ -46,16 +47,21 @@ function status = __ghostscript__ (varar
     endfor
     args(n) = [];
   endif
   for n = 1:2:numel(args)
     opts.(args{n}) = args{n+1};
   endfor
 
   gs_opts = sprintf ("-dQUIET -dNOPAUSE -dBATCH -dSAFER -sDEVICE=%s", opts.device);
+
+  if (! isempty (opts.level) && ismember (opts.level, [1, 2, 3]))
+    gs_opts = sprintf ("%s -dLanguageLevel=%d", gs_opts, round (opts.level));
+  endif
+
   if (opts.antialiasing)
     gs_opts = sprintf ("%s -dTextAlphaBits=4 -dGraphicsAlphaBits=4", gs_opts);
     gs_opts = sprintf ("%s -r%dx%d", gs_opts, [1, 1] * opts.resolution);
   elseif (any (strcmp (opts.device, {"pswrite", "ps2write", "pdfwrite"})))
     gs_opts = sprintf ("%s -dEmbedAllFonts=true", gs_opts);
     if (strcmp (opts.device, "pdfwrite"))
       ## Optimize for loading
       gs_opts = sprintf ("%s -dOptimize=true", gs_opts);
@@ -75,28 +81,33 @@ function status = __ghostscript__ (varar
         ##                requested page size matches one of the default page sizes
         gs_opts = sprintf ("%s -dNORANGEPAGESIZE", gs_opts);
       endif
     else
       error ("print:badpapersize", "__ghostscript__.m: invalid 'papersize'")
     endif
     gs_opts = sprintf ("%s -dFIXEDMEDIA", gs_opts);
     offsetfile = strcat (tmpnam (), ".ps");
-    fid = fopen (offsetfile, "w");
-    if (fid == -1)
-      error ("print:fopenfailed", "__ghostscript__.m: fopen() failed.");
-    endif
-    fprintf (fid, "%s\n", "%!PS-Adobe-3.0")
-    fprintf (fid, "%s [%d %d] %s\n", "<< /Margins [0 0] /.HWMargins [0 0 0 0] /PageOffset",
-             opts.pageoffset, ">> setpagedevice");
-    fprintf (fid, "%%EOF");
-    status = fclose (fid);
-    if (status == -1)
-      error ("print:fclosefailed", "__ghostscript__.m: fclose() failed.");
-    endif
+    unwind_protect
+      fid = fopen (offsetfile, "w");
+      onCleanup (@() unlink (offsetfile));
+      if (fid == -1)
+        error ("print:fopenfailed", "__ghostscript__.m: fopen() failed.");
+      endif
+      fprintf (fid, "%s\n", "%!PS-Adobe-3.0")
+      ## "pageoffset" is relative to the coordinates, not the BBox LLHC.
+      fprintf (fid, "%s [%d %d] %s\n", "<< /Margins [0 0] /.HWMargins [0 0 0 0] /PageOffset",
+               opts.pageoffset, ">> setpagedevice");
+      fprintf (fid, "%%EOF");
+    unwind_protect_cleanup
+      status = fclose (fid);
+      if (status == -1)
+        error ("print:fclosefailed", "__ghostscript__.m: fclose() failed.");
+      endif
+    end_unwind_protect
     if (opts.debug)
       [~,output] = system (sprintf ("cat %s", offsetfile));
       fprintf ("---- begin %s ----\n", offsetfile)
       disp (output)
       fprintf ("----- end %s -----\n", offsetfile)
     endif
   endif
 
@@ -107,14 +118,14 @@ function status = __ghostscript__ (varar
   if (opts.debug)
     fprintf ("Ghostscript command: %s\n", cmd);
   endif
 
   [status, output] = system (cmd);
 
   if (status != 0)
     warning ("print:ghostscripterror", 
-             "print.m: ghostscript failed to convert output to file '%s'.", opts.output)
+             "print.m: %s, '%s'.", output, opts.output)
   endif
 
 endfunction
 
 
diff --git a/scripts/plot/private/__tight_eps_bbox__.m b/scripts/plot/private/__tight_eps_bbox__.m
--- a/scripts/plot/private/__tight_eps_bbox__.m
+++ b/scripts/plot/private/__tight_eps_bbox__.m
@@ -32,17 +32,17 @@ function bb = __tight_eps_bbox__ (opts, 
   if (status == 0)
     orig_bbox_line = get_bbox (output);
   else
     error ("print:noboundingbox",
            "print.m: no bounding box found in '%s'", eps_file_name)
   endif
 
   ghostscript_options = "-q -dBATCH -dSAFER -dNOPAUSE -dTextAlphaBits=4 -sDEVICE=bbox";
-  cmd = sprintf ("\"%s\" %s \"%s\" 2>&1", opts.ghostscript_binary,
+  cmd = sprintf ("\"%s\" %s \"%s\" 2>&1", opts.ghostscript.binary,
                  ghostscript_options, eps_file_name);
   [status, output] = system (cmd);
 
   if (status == 0)
     tight_bbox_line = get_bbox (output);
   else
     warning ("print:nogsboundingbox",
              "print.m: ghostscript failed to determine the bounding for '%s'",
@@ -83,17 +83,16 @@ function bb = __tight_eps_bbox__ (opts, 
   ## If necessary load the eps-file and replace the bbox (can be slow).
   if (! bbox_replaced)
     fid = fopen (eps_file_name, "r");
     unwind_protect
       data = char (fread (fid, Inf)).';
     unwind_protect_cleanup
       fclose (fid);
     end_unwind_protect
-    ## FIXME - should strfind() limit the instances as find() does?
     n = strfind (data, box_string);
     if (numel (n) > 1)
       ## Only replace one instance.
       n = n(1);
     elseif (isempty (n))
       error ("print:noboundingbox", ...
              "print.m: no bounding box found in '%s'.", eps_file_name)
     endif
