# HG changeset patch
# User David Grundberg <individ@acc.umu.se>
# Date 1248969178 14400
#      Thu Jul 30 11:52:58 2009 -0400
# Node ID 25ed2d6aacf68214d44904edc2c6592c81c4867e
# Parent  833109a9f37f88ad6564821880ebaa2c2d6f8384
Parse nested functions more accurately.

diff --git a/doc/interpreter/contributors.in b/doc/interpreter/contributors.in
--- a/doc/interpreter/contributors.in
+++ b/doc/interpreter/contributors.in
@@ -57,16 +57,17 @@ Driss Ghaddab
 Nicolo Giorgetti
 Michael Goffioul
 Glenn Golden
 Tomislav Goles
 Keith Goodman
 Brian Gough
 Steffen Groot
 Etienne Grossmann
+David Grundberg
 Peter Gustafson
 Kai Habel
 William P. Y. Hadisoeseno
 Jaroslav Hajek
 Benjamin Hall
 Kim Hansen
 Soren Hauberg
 Dave Hawthorne
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,53 @@
+2009-07-30  David Grundberg  <individ@acc.umu.se>
+
+	* symtab.h (symbol_table::parent_scope): Remove.
+	(symbol_table::set_parent_scope): Remove.
+	(symbol_table::reset_parent_scope): Remove.
+	(symbol_table::install_subfunction): Require scope parameter
+	instead of xparent_scope default.
+	* symtab.cc: Remove symbol_table::xparent_scope
+	* lex.h (lexical_feedback::parsing_nested_function): Remove.
+	* lex.l	(is_keyword_token): Don't ignore endfunctions.
+	(prep_lexer_for_script_file): Renamed from prep_lexer_for_script.
+	(prep_lexer_for_function_file): New function.
+	(display_token): Display SCRIPT_FILE and FUNCTION_FILE.
+	(display_state): Display FUNCTION_FILE_BEGIN
+	(FUNCTION_FILE_BEGIN): New state.
+	(NESTED_FUNCTION_END, NESTED_FUNCTION_BEGIN): Remove states.
+	(prep_for_function, prep_for_nested_function): Remove functions.
+	* parse.h: Remove extern declaration parent_function_name,
+	end_tokens_expected.
+	* parse.y: Add variables current_function_depth,
+	max_function_depth, parsing_subfunctions, seen_endfunction. Remove
+	parent_function_name. Rename curr_fcn_ptr to primary_fcn_ptr. Add
+	token FUNCTION_FILE. Rename token SCRIPT to SCRIPT_FILE.
+	(function_file): New rule.
+	(input): Accept function_file.
+	(script_file): Rule renamed from script.
+	(function_file): New rule.
+	(function_list): New rule.
+	(push_fcn_symtab): Parse nested functions.
+	(fcn_name): Remove parent_function_name.
+	(function_end): Use seen_endfunction. New error messages.
+	(make_script): Use primary_fcn_ptr.
+	(frob_function): Simplify control structures. Don't use
+	symbol_table::parent_scope.
+	(push_fcn_symtab, function_end, frob_function, finish_function):
+	Use current_function_depth instead of
+	lexical_feedback::parsing_nested_function.
+	(make_return_command): Use current_function_depth instead of
+	lexical_feedback::defining_func.
+	(make_break_command, make_decl_command, maybe_warn_missing_semi):
+	Ditto
+	(parse_fcn_file): Warn when nested functions have been
+	declared. Remove superfluous local variables. Parse function files
+	using function_file rule.
+
 2009-07-30  Jaroslav Hajek  <highegg@gmail.com>
 
 	* data.cc (Fmerge): New DEFUN.
 	(do_merge): New helper function.
 
 2009-07-29  John W. Eaton  <jwe@octave.org>
 
 	* parse.y (param_list_end): Also set
diff --git a/src/lex.h b/src/lex.h
--- a/src/lex.h
+++ b/src/lex.h
@@ -41,17 +41,18 @@ extern OCTINTERP_API YY_BUFFER_STATE cur
 extern OCTINTERP_API void switch_to_buffer (YY_BUFFER_STATE buf);
 
 // Delete a buffer.
 extern OCTINTERP_API void delete_buffer (YY_BUFFER_STATE buf);
 
 // Is the given string a keyword?
 extern bool is_keyword (const std::string& s);
 
-extern void prep_lexer_for_script (void);
+extern void prep_lexer_for_script_file (void);
+extern void prep_lexer_for_function_file (void);
 
 // For communication between the lexer and parser.
 
 class
 lexical_feedback
 {
 public:
 
@@ -112,25 +113,19 @@ public:
   // GAG.  Stupid kludge so that [[1,2][3,4]] will work.
   bool do_comma_insert;
 
   // TRUE means we're looking at an indirect reference to a
   // structure element.
   bool looking_at_indirect_ref;
 
   // TRUE means that we've already seen the name of this function.
-  // Should only matter if defining_func is also TRUE.
+  // Should only matter if current_function_level > 0
   bool parsed_function_name;
 
-  // Are we parsing a nested function?
-  //   1 ==> Yes.
-  //   0 ==> No.
-  //  -1 ==> Yes, but it is the last one because we have seen EOF.
-  int parsing_nested_function;
-
   // TRUE means we are parsing a class method.
   bool parsing_class_method;
 
   // Return transpose or start a string?
   bool quote_is_transpose;
 
   // Set of identifiers that might be local variable names.
   std::set<std::string> pending_local_variables;
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -23,19 +23,17 @@ along with Octave; see the file COPYING.
 */
 
 %option prefix = "octave_"
 
 %s COMMAND_START
 %s MATRIX_START
 
 %x SCRIPT_FILE_BEGIN
-
-%x NESTED_FUNCTION_END
-%x NESTED_FUNCTION_BEGIN
+%x FUNCTION_FILE_BEGIN
 
 %{
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cctype>
 #include <cstring>
@@ -277,18 +275,16 @@ static bool lexer_debug_flag = false;
 // Forward declarations for functions defined at the bottom of this
 // file.
 
 static int text_yyinput (void);
 static void xunput (char c, char *buf);
 static void fixup_column_count (char *s);
 static void do_comma_insert_check (void);
 static int is_keyword_token (const std::string& s);
-static void prep_for_function (void);
-static void prep_for_nested_function (void);
 static int process_comment (bool start_in_block, bool& eof);
 static bool match_any (char c, const char *s);
 static bool next_token_is_sep_op (void);
 static bool next_token_is_bin_op (bool spc_prev);
 static bool next_token_is_postfix_unary_op (bool spc_prev);
 static std::string strip_trailing_whitespace (char *s);
 static void handle_number (void);
 static int handle_string (char delim);
@@ -324,44 +320,35 @@ SNLCMT	({SNL}|{COMMENT})
 NOT	((\~)|(\!))
 POW     ((\*\*)|(\^))
 EPOW    (\.{POW})
 IDENT	([_$a-zA-Z][_$a-zA-Z0-9]*)
 EXPON	([DdEe][+-]?{D}+)
 NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EXPON}?)|(0[xX][0-9a-fA-F]+))
 %%
 
+%{
+// Make script and function files start with a bogus token. This makes
+// the parser go down a special path.
+%}
+
 <SCRIPT_FILE_BEGIN>. {
     LEXER_DEBUG ("<SCRIPT_FILE_BEGIN>.");
 
     BEGIN (INITIAL);
     xunput (yytext[0], yytext);
-    COUNT_TOK_AND_RETURN (SCRIPT);
+    COUNT_TOK_AND_RETURN (SCRIPT_FILE);
   }
 
-<NESTED_FUNCTION_END>. {
-    LEXER_DEBUG ("<NESTED_FUNCTION_END>.");
-
-    BEGIN (NESTED_FUNCTION_BEGIN);
-    xunput (yytext[0], yytext);
-
-    lexer_flags.at_beginning_of_statement = true;
-
-    COUNT_TOK_AND_RETURN (';');
-  }
-
-<NESTED_FUNCTION_BEGIN>. {
-    LEXER_DEBUG ("<NESTED_FUNCTION_BEGIN>.");
+<FUNCTION_FILE_BEGIN>. {
+    LEXER_DEBUG ("<FUNCTION_FILE_BEGIN>.");
 
     BEGIN (INITIAL);
     xunput (yytext[0], yytext);
-
-    prep_for_nested_function ();
-
-    COUNT_TOK_AND_RETURN (FCN);
+    COUNT_TOK_AND_RETURN (FUNCTION_FILE);
   }
 
 %{
 // Help and other command-style functions.
 %}
 
 <COMMAND_START>{NL} {
     LEXER_DEBUG ("<COMMAND_START>{NL}");
@@ -999,18 +986,16 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 
 %{
 // Unrecognized input is a lexical error.
 %}
 
 . {
     LEXER_DEBUG (".");
 
-    // EOF happens here if we are parsing nested functions.
-
     xunput (yytext[0], yytext);
 
     int c = text_yyinput ();
 
     if (c != EOF)
       {
 	current_input_column++;
 
@@ -1053,23 +1038,20 @@ do_comma_insert_check (void)
 
 void
 reset_parser (void)
 {
   // Start off on the right foot.
   BEGIN (INITIAL);
 
   parser_end_of_input = false;
-  end_tokens_expected = 0;
 
   while (! symtab_context.empty ())
     symtab_context.pop ();
 
-  symbol_table::reset_parent_scope ();
-
   // We do want a prompt by default.
   promptflag = 1;
 
   // We are not in a block comment.
   block_comment_nesting_level = 0;
 
   // Error may have occurred inside some brackets, braces, or parentheses.
   nesting_level.clear ();
@@ -1376,42 +1358,16 @@ restore_input_buffer (void *buf)
 // Delete a buffer (for unwind-prot).
 
 void
 delete_input_buffer (void *buf)
 {
   delete_buffer (static_cast<YY_BUFFER_STATE> (buf));
 }
 
-static void
-prep_for_function (void)
-{
-  end_tokens_expected++;
-
-  promptflag--;
-
-  lexer_flags.defining_func = true;
-  lexer_flags.parsed_function_name = false;
-
-  if (! (reading_fcn_file || reading_script_file))
-    input_line_number = 1;
-}
-
-static void
-prep_for_nested_function (void)
-{
-  lexer_flags.parsing_nested_function = 1;
-  help_buf.push (std::string ());
-  prep_for_function ();
-  // We're still only expecting one end token for this set of functions.
-  end_tokens_expected--;
-  yylval.tok_val = new token (input_line_number, current_input_column);
-  token_stack.push (yylval.tok_val);
-}
-
 static bool
 inside_any_object_index (void)
 {
   bool retval = false;
 
   for (std::list<bool>::const_iterator i = lexer_flags.looking_at_object_index.begin ();
        i != lexer_flags.looking_at_object_index.end (); i++)
     {
@@ -1461,145 +1417,87 @@ is_keyword_token (const std::string& s)
 	  break;
 
 	case end_kw:
 	  if (inside_any_object_index ()
 	      || (lexer_flags.defining_func
 		  && ! (lexer_flags.looking_at_return_list
 			|| lexer_flags.parsed_function_name)))
 	    return 0;
-	  else
-	    {
-	      if (reading_fcn_file && end_tokens_expected == 1)
-		return -1;
-	      else
-		{
-		  yylval.tok_val = new token (token::simple_end, l, c);
-		  lexer_flags.at_beginning_of_statement = true;
-		  end_tokens_expected--;
-		}
-	    }
+
+	  yylval.tok_val = new token (token::simple_end, l, c);
+	  lexer_flags.at_beginning_of_statement = true;
 	  break;
 
 	case end_try_catch_kw:
 	  yylval.tok_val = new token (token::try_catch_end, l, c);
 	  lexer_flags.at_beginning_of_statement = true;
-	  end_tokens_expected--;
 	  break;
 
 	case end_unwind_protect_kw:
 	  yylval.tok_val = new token (token::unwind_protect_end, l, c);
 	  lexer_flags.at_beginning_of_statement = true;
-	  end_tokens_expected--;
 	  break;
 
 	case endfor_kw:
 	  yylval.tok_val = new token (token::for_end, l, c);
 	  lexer_flags.at_beginning_of_statement = true;
-	  end_tokens_expected--;
 	  break;
 
 	case endfunction_kw:
-	  {
-	    if (reading_fcn_file && end_tokens_expected == 1)
-	      return -1;
-	    else
-	      {
-		yylval.tok_val = new token (token::function_end, l, c);
-		lexer_flags.at_beginning_of_statement = true;
-		end_tokens_expected--;
-	      }
-	  }
+	  yylval.tok_val = new token (token::function_end, l, c);
+	  lexer_flags.at_beginning_of_statement = true;
 	  break;
 
 	case endif_kw:
 	  yylval.tok_val = new token (token::if_end, l, c);
 	  lexer_flags.at_beginning_of_statement = true;
-	  end_tokens_expected--;
 	  break;
 
 	case endswitch_kw:
 	  yylval.tok_val = new token (token::switch_end, l, c);
 	  lexer_flags.at_beginning_of_statement = true;
-	  end_tokens_expected--;
 	  break;
 
 	case endwhile_kw:
 	  yylval.tok_val = new token (token::while_end, l, c);
 	  lexer_flags.at_beginning_of_statement = true;
-	  end_tokens_expected--;
 	  break;
 
 	case for_kw:
 	case while_kw:
-	  end_tokens_expected++;
 	  promptflag--;
 	  lexer_flags.looping++;
 	  break;
 
 	case do_kw:
 	  lexer_flags.at_beginning_of_statement = true;
 	  promptflag--;
 	  lexer_flags.looping++;
 	  break;
 
 	case try_kw:
 	case unwind_protect_kw:
 	  lexer_flags.at_beginning_of_statement = true;
-	  end_tokens_expected++;
 	  promptflag--;
 	  break;
 
 	case if_kw:
 	case switch_kw:
-	  end_tokens_expected++;
 	  promptflag--;
 	  break;
 
 	case function_kw:
-	  {
-	    if (lexer_flags.defining_func)
-	      {
-		if (reading_fcn_file)
-		  {
-		    if (lexer_flags.parsing_nested_function)
-		      {
-			BEGIN (NESTED_FUNCTION_END);
-
-			yylval.tok_val = new token (token::function_end, l, c);
-			token_stack.push (yylval.tok_val);
-
-			lexer_flags.at_beginning_of_statement = true;
-
-			return END;
-		      }
-		    else
-		      {
-			prep_for_nested_function ();
-
-			return FCN;
-		      }
-		  }
-		else
-		  {
-		    error ("nested functions not implemented in this context");
-
-		    if ((reading_fcn_file || reading_script_file)
-			&& ! curr_fcn_file_name.empty ())
-		      error ("near line %d of file `%s.m'",
-			     input_line_number, curr_fcn_file_name.c_str ());
-		    else
-		      error ("near line %d", input_line_number);
-
-		    return LEXICAL_ERROR;
-		  }
-	      }
-	    else
-	      prep_for_function ();
-	  }
+	  promptflag--;
+
+	  lexer_flags.defining_func = true;
+	  lexer_flags.parsed_function_name = false;
+
+	  if (! (reading_fcn_file || reading_script_file))
+	    input_line_number = 1;
 	  break;
 
         case magic_file_kw:
 	  {
 	    if ((reading_fcn_file || reading_script_file)
 		&& ! curr_fcn_file_full_name.empty ())
 	      yylval.tok_val = new token (curr_fcn_file_full_name, l, c);
 	    else
@@ -3249,17 +3147,16 @@ lexical_feedback::init (void)
   braceflag = 0;
 
   // Not initially inside a loop or if statement.
   looping = 0;
 
   // Not initially defining a function.
   defining_func = false;
   parsed_function_name = false;
-  parsing_nested_function = 0;
   parsing_class_method = false;
 
   // Not initiallly looking at a function handle.
   looking_at_function_handle = 0;
 
   // Not parsing a function return, parameter, or declaration list.
   looking_at_return_list = false;
   looking_at_parameter_list = false;
@@ -3336,21 +3233,27 @@ is omitted, return a list of keywords.\n
     }
   else
     print_usage ();
 
   return retval;
 }
 
 void
-prep_lexer_for_script (void)
+prep_lexer_for_script_file (void)
 {
   BEGIN (SCRIPT_FILE_BEGIN);
 }
 
+void
+prep_lexer_for_function_file (void)
+{
+  BEGIN (FUNCTION_FILE_BEGIN);
+}
+
 static void
 maybe_warn_separator_insert (char sep)
 {
   std::string nm = curr_fcn_file_full_name;
 
   if (nm.empty ())
     warning_with_id ("Octave:separator-insert",
 		     "potential auto-insertion of `%c' near line %d",
@@ -3490,16 +3393,18 @@ display_token (int tok)
     case CATCH: std::cerr << "CATCH\n"; break;
     case GLOBAL: std::cerr << "GLOBAL\n"; break;
     case STATIC: std::cerr << "STATIC\n"; break;
     case FCN_HANDLE: std::cerr << "FCN_HANDLE\n"; break;
     case END_OF_INPUT: std::cerr << "END_OF_INPUT\n\n"; break;
     case LEXICAL_ERROR: std::cerr << "LEXICAL_ERROR\n\n"; break;
     case FCN: std::cerr << "FCN\n"; break;
     case CLOSE_BRACE: std::cerr << "CLOSE_BRACE\n"; break;
+    case SCRIPT_FILE: std::cerr << "SCRIPT_FILE\n"; break;
+    case FUNCTION_FILE: std::cerr << "FUNCTION_FILE\n"; break;
     case '\n': std::cerr << "\\n\n"; break;
     case '\r': std::cerr << "\\r\n"; break;
     case '\t': std::cerr << "TAB\n"; break;
     default:
       {
         if (tok < 256)
 	  std::cerr << static_cast<char> (tok) << "\n";
 	else
@@ -3527,22 +3432,18 @@ display_state (void)
     case MATRIX_START:
       std::cerr << "MATRIX_START" << std::endl;
       break;
 
     case SCRIPT_FILE_BEGIN:
       std::cerr << "SCRIPT_FILE_BEGIN" << std::endl;
       break;
 
-    case NESTED_FUNCTION_END:
-      std::cerr << "NESTED_FUNCTION_END" << std::endl;
-      break;
-
-    case NESTED_FUNCTION_BEGIN:
-      std::cerr << "NESTED_FUNCTION_BEGIN" << std::endl;
+    case FUNCTION_FILE_BEGIN:
+      std::cerr << "FUNCTION_FILE_BEGIN" << std::endl;
       break;
 
     default:
       std::cerr << "UNKNOWN START STATE!" << std::endl;
       break;
     }
 }
 
diff --git a/src/parse.h b/src/parse.h
--- a/src/parse.h
+++ b/src/parse.h
@@ -60,27 +60,20 @@ extern bool line_editing;
 extern bool reading_startup_message_printed;
 
 // TRUE means input is coming from startup file.
 extern bool input_from_startup_file;
 
 // Keep track of symbol table information when parsing functions.
 extern std::stack<symbol_table::scope_id> symtab_context;
 
-// Name of parent function when parsing function files that might
-// contain nested functions.
-extern std::string parent_function_name;
-
 // Name of the current class when we are parsing class methods or
 // constructors.
 extern std::string current_class_name;
 
-// Keep a count of how many END tokens we expect.
-extern int end_tokens_expected;
-
 extern OCTINTERP_API std::string
 get_help_from_file (const std::string& nm, bool& symbol_found,
 		    std::string& file);
 
 extern OCTINTERP_API std::string
 get_help_from_file (const std::string& nm, bool& symbol_found);
 
 extern OCTINTERP_API std::string lookup_autoload (const std::string& nm);
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -1,12 +1,13 @@
 /*
 
 Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
               2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009  John W. Eaton
+Copyright (C) 2009 David Grundberg
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -95,40 +96,54 @@ static std::string fcn_comment_header;
 bool line_editing = true;
 
 // TRUE means we printed messages about reading startup files.
 bool reading_startup_message_printed = false;
 
 // TRUE means input is coming from startup file.
 bool input_from_startup_file = false;
 
-// Keep a count of how many END tokens we expect.
-int end_tokens_expected = 0;
+// = 0 currently outside any function.
+// = 1 inside the primary function or a subfunction.
+// > 1 means we are looking at a function definition that seems to be
+//     inside a function. Note that the function still might not be a
+//     nested function.
+static int current_function_depth = 0;
+
+// Maximum function depth detected. Just here to determine whether
+// we have nested functions or just implicitly ended subfunctions.
+static int max_function_depth = 0;
+
+// FALSE if we are still at the primary function. Subfunctions can
+// only be declared inside function files.
+static int parsing_subfunctions = false;
+
+// Have we found an explicit end to a function?
+static bool endfunction_found = false;
 
 // Keep track of symbol table information when parsing functions.
 std::stack<symbol_table::scope_id> symtab_context;
 
-// Name of parent function when parsing function files that might
-// contain nested functions.
-std::string parent_function_name;
-
 // Name of the current class when we are parsing class methods or
 // constructors.
 std::string current_class_name;
 
 // TRUE means we are in the process of autoloading a function.
 static bool autoloading = false;
 
 // TRUE means the current function file was found in a relative path
 // element.
 static bool fcn_file_from_relative_lookup = false;
 
-// If nonzero, this is a pointer to the function we just finished
-// parsing.
-static octave_function *curr_fcn_ptr = 0;
+// Pointer to the primary user function or user script function.
+static octave_function *primary_fcn_ptr = 0;
+
+// Scope where we install all subfunctions and nested functions. Only
+// used while reading function files.
+static symbol_table::scope_id primary_fcn_scope;
 
 // List of autoloads (function -> file mapping).
 static std::map<std::string, std::string> autoload_map;
 
 // Forward declarations for some functions defined at the bottom of
 // the file.
 
 // Generic error messages.
@@ -419,17 +434,17 @@ make_statement (T *arg)
 %token <tok_val> BREAK CONTINUE FUNC_RET
 %token <tok_val> UNWIND CLEANUP
 %token <tok_val> TRY CATCH
 %token <tok_val> GLOBAL STATIC
 %token <tok_val> FCN_HANDLE
 
 // Other tokens.
 %token END_OF_INPUT LEXICAL_ERROR
-%token FCN SCRIPT
+%token FCN SCRIPT_FILE FUNCTION_FILE
 // %token VARARGIN VARARGOUT
 %token CLOSE_BRACE
 
 // Nonterminals we construct.
 %type <comment_type> stash_comment function_beg
 %type <sep_type> sep_no_nl opt_sep_no_nl sep opt_sep
 %type <tree_type> input
 %type <tree_constant_type> string constant magic_colon
@@ -444,17 +459,18 @@ make_statement (T *arg)
 %type <octave_user_function_type> function1 function2
 %type <tree_index_expression_type> word_list_cmd
 %type <tree_colon_expression_type> colon_expr1
 %type <tree_argument_list_type> arg_list word_list assign_lhs
 %type <tree_argument_list_type> cell_or_matrix_row
 %type <tree_parameter_list_type> param_list param_list1 param_list2
 %type <tree_parameter_list_type> return_list return_list1
 %type <tree_command_type> command select_command loop_command
-%type <tree_command_type> jump_command except_command function script
+%type <tree_command_type> jump_command except_command function script_file
+%type <tree_command_type> function_file function_list
 %type <tree_if_command_type> if_command
 %type <tree_if_clause_type> elseif_clause else_clause
 %type <tree_if_command_list_type> if_cmd_list1 if_cmd_list
 %type <tree_switch_command_type> switch_command
 %type <tree_switch_case_type> switch_case default_case
 %type <tree_switch_case_list_type> case_list1 case_list
 %type <tree_decl_elt_type> decl2
 %type <tree_decl_init_list_type> decl1
@@ -489,16 +505,20 @@ make_statement (T *arg)
 // ==============================
 
 input		: input1
 		  {
 		    global_command = $1;
 		    promptflag = 1;
 		    YYACCEPT;
 		  }
+		| function_file
+		  {
+		    YYACCEPT;
+		  }
 		| simple_list parse_error
 		  { ABORT_PARSE; }
 		| parse_error
 		  { ABORT_PARSE; }
 		;
 
 input1		: '\n'
 		  { $$ = 0; }
@@ -898,17 +918,17 @@ command		: declaration
 		| loop_command
 		  { $$ = $1; }
 		| jump_command
 		  { $$ = $1; }
 		| except_command
 		  { $$ = $1; }
 		| function
 		  { $$ = $1; }
-		| script
+		| script_file
 		  { $$ = $1; }
 		;
 
 // =====================
 // Declaration statemnts
 // =====================
 
 parsing_decl_list
@@ -1107,21 +1127,30 @@ except_command	: UNWIND stash_comment op
 		;
 
 // ===========================================
 // Some `subroutines' for function definitions
 // ===========================================
 
 push_fcn_symtab	: // empty
 		  {
+		    current_function_depth++;
+
+		    if (max_function_depth < current_function_depth)
+		      max_function_depth = current_function_depth;
+
 		    symtab_context.push (symbol_table::current_scope ());
 		    symbol_table::set_scope (symbol_table::alloc_scope ());
 
-		    if (! lexer_flags.parsing_nested_function)
-		      symbol_table::set_parent_scope (symbol_table::current_scope ());
+		    if (! reading_script_file && current_function_depth == 1
+			&& ! parsing_subfunctions)
+		      primary_fcn_scope = symbol_table::current_scope ();
+
+		    if (reading_script_file && current_function_depth > 1)
+		      yyerror ("nested functions not implemented in this context");
 		  }
 		;
 
 // ===========================
 // List of function parameters
 // ===========================
 
 param_list_beg	: '('
@@ -1213,28 +1242,39 @@ return_list1	: identifier
 		    $$ = $1;
 		  }
 		;
 
 // ===========
 // Script file
 // ===========
 
-script		: SCRIPT opt_list END_OF_INPUT
+script_file	: SCRIPT_FILE opt_list END_OF_INPUT
 		  {
 		    tree_statement *end_of_script
 		      = make_end ("endscript", input_line_number,
 				  current_input_column);
 
 		    make_script ($2, end_of_script);
 
 		    $$ = 0;
 		  }
 		;
 
+// =============
+// Function file
+// =============
+
+function_file   : FUNCTION_FILE function_list opt_sep END_OF_INPUT
+		;
+
+function_list   : function
+		| function_list sep function
+		;
+
 // ===================
 // Function definition
 // ===================
 
 function_beg	: push_fcn_symtab FCN stash_comment
 		  { $$ = $3; }
 		;
 
@@ -1249,22 +1289,18 @@ function	: function_beg function1
 		    recover_from_parsing_function ();
 		  }
 		;
 
 fcn_name	: identifier
 		  {
 		    std::string id_name = $1->name ();
 
-		    if (reading_fcn_file
-		        && ! lexer_flags.parsing_nested_function)
-		      parent_function_name = (curr_fcn_file_name == id_name)
-			? id_name : curr_fcn_file_name;
-
 		    lexer_flags.parsed_function_name = true;
+		    lexer_flags.defining_func = false;
 
 		    $$ = $1;
 		  }
 		;
 
 function1	: fcn_name function2
 		  {
 		    std::string fname = $1->name ();
@@ -1279,32 +1315,47 @@ function1	: fcn_name function2
 function2	: param_list opt_sep opt_list function_end
 		  { $$ = start_function ($1, $3, $4); }
 		| opt_sep opt_list function_end
 		  { $$ = start_function (0, $2, $3); }
 		;
 
 function_end	: END
 		  {
+		    endfunction_found = true;
 		    if (end_token_ok ($1, token::function_end))
 		      $$ = make_end ("endfunction", $1->line (), $1->column ());
 		    else
 		      ABORT_PARSE;
 		  }
 		| END_OF_INPUT
 		  {
-		    if (lexer_flags.parsing_nested_function)
-		      lexer_flags.parsing_nested_function = -1;
-
-		    if (reading_fcn_file || reading_script_file
-			|| get_input_from_eval_string)
-		      $$ = make_end ("endfunction", input_line_number,
-				     current_input_column);
-		    else
-		      YYABORT;
+// A lot of tests are based on the assumption that this is OK
+// 		    if (reading_script_file)
+// 		      {
+// 			yyerror ("function body open at end of script");
+// 			YYABORT;
+// 		      }
+
+		    if (endfunction_found)
+		      {
+			yyerror ("inconsistent function endings -- "
+				 "if one function is explicitly ended, "
+				 "so must all the others");
+			YYABORT;
+		      }
+
+		    if (! reading_fcn_file && ! reading_script_file)
+		      {
+			yyerror ("function body open at end of input");
+			YYABORT;
+		      }
+
+		    $$ = make_end ("endfunction", input_line_number,
+				   current_input_column);
 		  }
 		;
 
 // =============
 // Miscellaneous
 // =============
 
 stash_comment	: // empty
@@ -2236,17 +2287,17 @@ make_break_command (token *break_tok)
 
   int l = break_tok->line ();
   int c = break_tok->column ();
 
   // We check to see if we are evaluating a function, script, or loop
   // so that we don't turn eval ("break;") inside a function, script,
   // or loop into a no-op command.
 
-  if (lexer_flags.looping || lexer_flags.defining_func
+  if (lexer_flags.looping || current_function_depth > 0
       || reading_script_file || tree_evaluator::in_fcn_or_script_body
       || tree_evaluator::in_loop_command)
     retval = new tree_break_command (l, c);
   else
     retval = new tree_no_op_command ("break", l, c);
 
   return retval;
 }
@@ -2289,17 +2340,17 @@ make_return_command (token *return_tok)
       retval = new tree_no_op_command ("return", l, c);
     }
   else
     {
       // We check to see if we are evaluating a function or script so
       // that we don't turn eval ("return;") inside a function, script,
       // or loop into a no-op command.
 
-      if (lexer_flags.defining_func || reading_script_file
+      if (current_function_depth > 0 || reading_script_file
           || tree_evaluator::in_fcn_or_script_body)
         retval = new tree_return_command (l, c);
       else
         retval = new tree_no_op_command ("return", l, c);
     }
 
   return retval;
 }
@@ -2498,17 +2549,17 @@ make_assign_op (int op, tree_argument_li
       delete lhs;
     }
   else
     return new tree_multi_assignment (lhs, rhs, false, l, c, t);
 
   return retval;
 }
 
-// Define a function.
+// Define a script.
 
 static void
 make_script (tree_statement_list *cmds, tree_statement *end_script)
 {
   std::string doc_string;
 
   if (! help_buf.empty ())
     {
@@ -2524,17 +2575,17 @@ make_script (tree_statement_list *cmds, 
   octave_user_script *script
     = new octave_user_script (curr_fcn_file_full_name, curr_fcn_file_name,
 			      cmds, doc_string);
 
   octave_time now;
 
   script->stash_fcn_file_time (now);
 
-  curr_fcn_ptr = script;
+  primary_fcn_ptr = script;
 
   // Unmark any symbols that may have been tagged as local variables
   // while parsing (for example, by force_local_variable in lex.l).
 
   symbol_table::unmark_forced_variables ();
 }
 
 // Begin defining a function.
@@ -2576,59 +2627,58 @@ static octave_user_function *
 frob_function (const std::string& fname, octave_user_function *fcn)
 {
   std::string id_name = fname;
 
   // If input is coming from a file, issue a warning if the name of
   // the file does not match the name of the function stated in the
   // file.  Matlab doesn't provide a diagnostic (it ignores the stated
   // name).
+  if (! autoloading && reading_fcn_file
+      && (current_function_depth == 1
+	  && ! (parsing_subfunctions || lexer_flags.parsing_class_method)))
+  {
+    // FIXME -- should curr_fcn_file_name already be
+    // preprocessed when we get here?  It seems to only be a
+    // problem with relative file names.
+
+    std::string nm = curr_fcn_file_name;
+
+    size_t pos = nm.find_last_of (file_ops::dir_sep_chars ());
+
+    if (pos != std::string::npos)
+      nm = curr_fcn_file_name.substr (pos+1);
+
+    if (nm != id_name)
+      {
+	warning_with_id
+	  ("Octave:function-name-clash",
+	   "function name `%s' does not agree with function file name `%s'",
+	   id_name.c_str (), curr_fcn_file_full_name.c_str ());
+
+	id_name = nm;
+      }
+  }
 
   if (reading_fcn_file || autoloading)
     {
-      if (! (autoloading
-	     || lexer_flags.parsing_nested_function
-	     || lexer_flags.parsing_class_method))
-	{
-	  // FIXME -- should curr_fcn_file_name already be
-	  // preprocessed when we get here?  It seems to only be a
-	  // problem with relative file names.
-
-	  std::string nm = curr_fcn_file_name;
-
-	  size_t pos = nm.find_last_of (file_ops::dir_sep_chars ());
-
-	  if (pos != std::string::npos)
-	    nm = curr_fcn_file_name.substr (pos+1);
-
-	  if (nm != id_name)
-	    {
-	      warning_with_id
-		("Octave:function-name-clash",
-		 "function name `%s' does not agree with function file name `%s'",
-		 id_name.c_str (), curr_fcn_file_full_name.c_str ());
-
-	      id_name = nm;
-	    }
-	}
-
       octave_time now;
 
       fcn->stash_fcn_file_name (curr_fcn_file_full_name);
       fcn->stash_fcn_file_time (now);
       fcn->mark_as_system_fcn_file ();
 
       if (fcn_file_from_relative_lookup)
 	fcn->mark_relative ();
 
-      if (lexer_flags.parsing_nested_function)
+      if (current_function_depth > 1 || parsing_subfunctions)
         {
-          fcn->stash_parent_fcn_name (parent_function_name);
-          fcn->stash_parent_fcn_scope (symbol_table::parent_scope ());
-	}
+	  fcn->stash_parent_fcn_name (curr_fcn_file_name);
+	  fcn->stash_parent_fcn_scope (primary_fcn_scope);
+        }
 
       if (lexer_flags.parsing_class_method)
 	{
 	  if (current_class_name == id_name)
 	    fcn->mark_as_class_constructor ();
 	  else
 	    fcn->mark_as_class_method ();
 
@@ -2648,28 +2698,28 @@ frob_function (const std::string& fname,
 	   && curr_fcn_file_name == id_name)
     {
       warning ("function `%s' defined within script file `%s'",
 	       id_name.c_str (), curr_fcn_file_full_name.c_str ());
     }
 
   fcn->stash_function_name (id_name);
 
-  if (! help_buf.empty ())
+  if (! help_buf.empty () && current_function_depth == 1
+      && ! parsing_subfunctions)
     {
       fcn->document (help_buf.top ());
 
       help_buf.pop ();
     }
 
-  if (reading_fcn_file && ! lexer_flags.parsing_nested_function)
-    curr_fcn_ptr = fcn;
-  else
-    curr_fcn_ptr = 0;
-
+  if (reading_fcn_file && current_function_depth == 1
+      && ! parsing_subfunctions)
+    primary_fcn_ptr = fcn;
+  
   return fcn;
 }
 
 static tree_function_def *
 finish_function (tree_parameter_list *ret_list,
 		 octave_user_function *fcn, octave_comment_list *lc)
 {
   tree_function_def *retval = 0;
@@ -2688,33 +2738,31 @@ finish_function (tree_parameter_list *re
 
       symbol_table::cache_name (fcn->scope (), tmp);
 
       if (lc)
 	fcn->stash_leading_comment (lc);
 
       fcn->define_ret_list (ret_list);
 
-      if (lexer_flags.parsing_nested_function)
-	{
+      if (current_function_depth > 1 || parsing_subfunctions)
+        {
+          // FIXME -- is this flag used to determine if the function is a
+          // _subfunction_ somewhere?
 	  fcn->mark_as_nested_function ();
 
-	  symbol_table::install_subfunction (nm, octave_value (fcn));
-
-	  if (lexer_flags.parsing_nested_function < 0)
-	    {
-	      lexer_flags.parsing_nested_function = 0;
-	      symbol_table::reset_parent_scope ();
-	    }
+	  symbol_table::install_subfunction (nm, octave_value (fcn),
+					     primary_fcn_scope);
 	}
-      else if (! curr_fcn_ptr)
+
+      if (! primary_fcn_ptr)
 	{
 	  // FIXME -- there should be a better way to indicate that we
 	  // should create a tree_function_def object other than
-	  // looking at curr_fcn_ptr...
+	  // looking at primary_fcn_ptr...
 
 	  retval = new tree_function_def (fcn);
 	}
 
       // Unmark any symbols that may have been tagged as local
       // variables while parsing (for example, by force_local_variable
       // in lex.l).
 
@@ -2728,17 +2776,22 @@ static void
 recover_from_parsing_function (void)
 {
   if (symtab_context.empty ())
     panic_impossible ();
 
   symbol_table::set_scope (symtab_context.top ());
   symtab_context.pop ();
 
-  lexer_flags.defining_func = false;
+  if (reading_fcn_file && current_function_depth == 1
+      && ! parsing_subfunctions)
+    parsing_subfunctions = true;
+
+  current_function_depth--;
+
   lexer_flags.parsed_function_name = false;
   lexer_flags.looking_at_return_list = false;
   lexer_flags.looking_at_parameter_list = false;
 }
 
 // Make an index expression.
 
 static tree_index_expression *
@@ -2830,17 +2883,17 @@ make_decl_command (int tok, token *tok_v
 
   switch (tok)
     {
     case GLOBAL:
       retval = new tree_global_command (lst, l, c);
       break;
 
     case STATIC:
-      if (lexer_flags.defining_func)
+      if (current_function_depth > 0)
 	retval = new tree_static_command (lst, l, c);
       else
 	{
 	  if (reading_script_file)
 	    warning ("ignoring persistent declaration near line %d of file `%s'",
 		     l, curr_fcn_file_full_name.c_str ());
 	  else
 	    warning ("ignoring persistent declaration near line %d", l);
@@ -2907,17 +2960,17 @@ static tree_expression *
 finish_cell (tree_cell *c)
 {
   return finish_matrix (c);
 }
 
 static void
 maybe_warn_missing_semi (tree_statement_list *t)
 {
-  if (lexer_flags.defining_func)
+  if (current_function_depth > 0)
     {
       tree_statement *tmp = t->back();
 
       if (tmp->is_expression ())
 	warning_with_id
 	  ("Octave:missing-semicolon",
 	   "missing semicolon near line %d, column %d in file `%s'",
 	    tmp->line (), tmp->column (), curr_fcn_file_full_name.c_str ());
@@ -3148,40 +3201,42 @@ parse_fcn_file (const std::string& ff, c
 		const std::string& warn_for = std::string ())
 {
   unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
   octave_function *fcn_ptr = 0;
 
   // Open function file and parse.
 
-  bool old_reading_fcn_file_state = reading_fcn_file;
-
   FILE *in_stream = command_editor::get_input_stream ();
 
   unwind_protect::add_fcn (command_editor::set_input_stream,
                            in_stream);
 
   unwind_protect::protect_var (ff_instream);
 
   unwind_protect::protect_var (input_line_number);
   unwind_protect::protect_var (current_input_column);
-  unwind_protect::protect_var (end_tokens_expected);
   unwind_protect::protect_var (reading_fcn_file);
   unwind_protect::protect_var (line_editing);
-  unwind_protect::protect_var (parent_function_name);
   unwind_protect::protect_var (current_class_name);
+  unwind_protect::protect_var (current_function_depth);
+  unwind_protect::protect_var (max_function_depth);
+  unwind_protect::protect_var (parsing_subfunctions);
+  unwind_protect::protect_var (endfunction_found);
 
   input_line_number = 1;
   current_input_column = 1;
-  end_tokens_expected = 0;
   reading_fcn_file = true;
   line_editing = false;
-  parent_function_name = "";
   current_class_name = dispatch_type;
+  current_function_depth = 0;
+  max_function_depth = 0;
+  parsing_subfunctions = false;
+  endfunction_found = false;
 
   // The next four lines must be in this order.
   unwind_protect::add_fcn (command_history::ignore_entries, ! Vsaving_history);
 
   // FIXME -- we shouldn't need both the
   // command_history object and the
   // Vsaving_history variable...
   command_history::ignore_entries ();
@@ -3199,79 +3254,79 @@ parse_fcn_file (const std::string& ff, c
       bool eof;
 
       std::string help_txt = gobble_leading_white_space (ffile, eof);
 
       if (! eof)
 	{
 	  std::string file_type;
 
-	  bool parsing_script = false;
-
 	  unwind_protect::protect_var (get_input_from_eval_string);
 	  unwind_protect::protect_var (parser_end_of_input);
+	  unwind_protect::protect_var (reading_fcn_file);
+	  unwind_protect::protect_var (reading_script_file);
 
 	  get_input_from_eval_string = false;
 	  parser_end_of_input = false;
 
 	  if (! force_script && looking_at_function_keyword (ffile))
 	    {
 	      file_type = "function";
 
 	      unwind_protect::protect_var (Vecho_executing_commands);
-	      unwind_protect::protect_var (reading_fcn_file);
 
 	      Vecho_executing_commands = ECHO_OFF;
 	      reading_fcn_file = true;
 	    }
 	  else
 	    {
 	      file_type = "script";
 
-	      // The value of `reading_fcn_file' will be restored to the
-	      // proper value when we unwind from this frame.
-	      reading_fcn_file = old_reading_fcn_file_state;
-
-	      unwind_protect::protect_var (reading_script_file);
-
-	      reading_script_file = true;
-
-	      parsing_script = true;
+	      reading_fcn_file = false;
 	    }
 
+	  reading_script_file = ! reading_fcn_file;
+	  
 	  YY_BUFFER_STATE old_buf = current_buffer ();
 	  YY_BUFFER_STATE new_buf = create_buffer (ffile);
 
 	  unwind_protect::add_fcn (switch_to_buffer, old_buf);
 	  unwind_protect::add_fcn (delete_buffer, new_buf);
 
 	  switch_to_buffer (new_buf);
 
-	  unwind_protect::protect_var (curr_fcn_ptr);
-	  curr_fcn_ptr = 0;
+	  unwind_protect::protect_var (primary_fcn_ptr);
+	  primary_fcn_ptr = 0;
 
 	  reset_parser ();
 
 	  // Do this with an unwind-protect cleanup function so that
 	  // the forced variables will be unmarked in the event of an
 	  // interrupt. 
 	  symbol_table::scope_id scope = symbol_table::top_scope ();
 	  unwind_protect::add_fcn (symbol_table::unmark_forced_variables, scope);
 
 	  if (! help_txt.empty ())
 	    help_buf.push (help_txt);
 
-	  if (parsing_script)
-	    prep_lexer_for_script ();
+	  if (reading_script_file)
+	    prep_lexer_for_script_file ();
+	  else
+	    prep_lexer_for_function_file ();
 
 	  lexer_flags.parsing_class_method = ! dispatch_type.empty ();
 
 	  int status = yyparse ();
 
-	  fcn_ptr = curr_fcn_ptr;
+	  fcn_ptr = primary_fcn_ptr;
+
+	  if (reading_fcn_file && endfunction_found && max_function_depth > 1)
+	    warning_with_id ("Octave:nested-functions-coerced",
+			     "nested functions are coerced into subfunctions "
+			     "in file %s", ff.c_str ());
 
 	  if (status != 0)
 	    error ("parse error while reading %s file %s",
 		   file_type.c_str(), ff.c_str ());
 	}
     }
   else if (require_file)
     error ("no such file, `%s'", ff.c_str ());
@@ -3874,23 +3929,31 @@ eval_string (const std::string& s, bool 
 
   unwind_protect::protect_var (input_line_number);
   unwind_protect::protect_var (current_input_column);
   unwind_protect::protect_var (get_input_from_eval_string);
   unwind_protect::protect_var (input_from_eval_string_pending);
   unwind_protect::protect_var (parser_end_of_input);
   unwind_protect::protect_var (line_editing);
   unwind_protect::protect_var (current_eval_string);
+  unwind_protect::protect_var (current_function_depth);
+  unwind_protect::protect_var (max_function_depth);
+  unwind_protect::protect_var (parsing_subfunctions);
+  unwind_protect::protect_var (endfunction_found);
 
   input_line_number = 1;
   current_input_column = 1;
   get_input_from_eval_string = true;
   input_from_eval_string_pending = true;
   parser_end_of_input = false;
   line_editing = false;
+  current_function_depth = 0;
+  max_function_depth = 0;
+  parsing_subfunctions = false;
+  endfunction_found = false;
 
   current_eval_string = s;
 
   YY_BUFFER_STATE old_buf = current_buffer ();
   YY_BUFFER_STATE new_buf = create_buffer (0);
 
   unwind_protect::add_fcn (switch_to_buffer, old_buf);
   unwind_protect::add_fcn (delete_buffer, new_buf);
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -57,18 +57,16 @@ std::map<std::string, symbol_table::fcn_
 
 std::map<std::string, std::set<std::string> > symbol_table::class_precedence_table;
 
 const symbol_table::scope_id symbol_table::xglobal_scope = 0;
 const symbol_table::scope_id symbol_table::xtop_scope = 1;
 
 symbol_table::scope_id symbol_table::xcurrent_scope = 1;
 
-symbol_table::scope_id symbol_table::xparent_scope = -1;
-
 symbol_table::context_id symbol_table::xcurrent_context = 0;
 
 // Should Octave always check to see if function files have changed
 // since they were last compiled?
 static int Vignore_function_time_stamp = 1;
 
 void
 symbol_table::symbol_record::symbol_record_rep::dump
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -883,19 +883,16 @@ public:
 
   static scope_id global_scope (void) { return xglobal_scope; }
   static scope_id top_scope (void) { return xtop_scope; }
 
   static scope_id current_scope (void) { return xcurrent_scope; }
 
   static context_id current_context (void) { return xcurrent_context; }
 
-  // We use parent_scope to handle parsing subfunctions.
-  static scope_id parent_scope (void) { return xparent_scope; }
-
   static scope_id alloc_scope (void) { return scope_id_cache::alloc (); }
 
   static void set_scope (scope_id scope)
   {
     if (scope == xglobal_scope)
       error ("can't set scope to global");
     else if (scope != xcurrent_scope)
       {
@@ -937,26 +934,16 @@ public:
                 xcurrent_context = context;
 	      }
 	  }
         else
           xcurrent_context = context;
       }
   }
 
-  static void set_parent_scope (scope_id scope)
-  {
-    xparent_scope = scope;
-  }
-
-  static void reset_parent_scope (void)
-  {
-    set_parent_scope (-1);
-  }
-
   static void erase_scope (scope_id scope)
   {
     assert (scope != xglobal_scope);
 
     all_instances_iterator p = all_instances.find (scope);
 
     if (p != all_instances.end ())
       {
@@ -1202,17 +1189,17 @@ public:
 	finfo.install_cmdline_function (fcn);
 
 	fcn_table[name] = finfo;
       }
   }
 
   static void install_subfunction (const std::string& name,
 				   const octave_value& fcn,
-				   scope_id scope = xparent_scope)
+				   scope_id scope)
   {
     fcn_table_iterator p = fcn_table.find (name);
 
     if (p != fcn_table.end ())
       {
 	fcn_info& finfo = p->second;
 
 	finfo.install_subfunction (fcn, scope);
@@ -1847,19 +1834,16 @@ private:
   typedef std::map<std::string, std::set<std::string> >::const_iterator class_precedence_table_const_iterator;
   typedef std::map<std::string, std::set<std::string> >::iterator class_precedence_table_iterator;
 
   static const scope_id xglobal_scope;
   static const scope_id xtop_scope;
 
   static scope_id xcurrent_scope;
 
-  // We use parent_scope to handle parsing subfunctions.
-  static scope_id xparent_scope;
-
   static context_id xcurrent_context;
 
   symbol_table (void)
     : table_name (), table () { }
 
   ~symbol_table (void) { }
 
   static symbol_table *get_instance (scope_id scope, bool create = true)
