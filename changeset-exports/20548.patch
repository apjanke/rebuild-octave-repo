# HG changeset patch
# User Rik <rik@octave.org>
# Date 1443931396 25200
#      Sat Oct 03 21:03:16 2015 -0700
# Node ID 25623ef2ff4f86f2533c4b62215baf7137b983e0
# Parent  52ce821a52fdf2d5bebf865481bcb475ac4c3c95
doc: Rewrite docstrings for ode* family of functions.

* scripts/ode/module.mk: Remove extra newline.

* ode45.m, odeget.m, odeset.m: Rewrite docstrings.

* AbsRel_Norm.m, fuzzy_compare.m, hermite_quartic_interpolation.m,
integrate_adaptive.m, integrate_const.m, integrate_n_steps.m, kahan.m,
ode_struct_value_check.m, odepkg_event_handle.m, odepkg_structure_check.m,
runge_kutta_45_dorpri.m, starting_stepsize.m:
Don't break @deftypefn lines.  Wrap lines at 80 columns rather than 72.

diff --git a/scripts/ode/module.mk b/scripts/ode/module.mk
--- a/scripts/ode/module.mk
+++ b/scripts/ode/module.mk
@@ -11,17 +11,16 @@ scripts_ode_PRIVATE_FCN_FILES = \
   scripts/ode/private/integrate_n_steps.m \
   scripts/ode/private/kahan.m \
   scripts/ode/private/odepkg_event_handle.m \
   scripts/ode/private/odepkg_structure_check.m \
   scripts/ode/private/ode_struct_value_check.m \
   scripts/ode/private/runge_kutta_45_dorpri.m \
   scripts/ode/private/starting_stepsize.m
 
-
 scripts_ode_FCN_FILES = \
   scripts/ode/ode45.m \
   scripts/ode/odeset.m \
   scripts/ode/odeget.m
 
 scripts_odedir = $(fcnfiledir)/ode
 
 scripts_ode_DATA = $(scripts_ode_FCN_FILES)
diff --git a/scripts/ode/ode45.m b/scripts/ode/ode45.m
--- a/scripts/ode/ode45.m
+++ b/scripts/ode/ode45.m
@@ -14,63 +14,68 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{sol}] =} ode45 (@var{fun}, @var{slot}, @var{init}, [@var{opt}], [@var{par1}, @var{par2}, @dots{}])
-## @deftypefnx {Function File} {[@var{t}, @var{y}, [@var{xe}, @var{ye}, @var{ie}]] =} ode45 (@var{fun}, @var{slot}, @var{init}, [@var{opt}], [@var{par1}, @var{par2}, @dots{}])
-##
-## This function file can be used to solve a set of non--stiff ordinary
-## differential equations (non--stiff ODEs) with the well known explicit
-## Dormand-Prince method of order 4.
+## @deftypefn  {Function File} {[@var{t}, @var{y}] =} ode45 (@var{fun}, @var{trange}, @var{init})
+## @deftypefnx {Function File} {[@var{t}, @var{y}] =} ode45 (@var{fun}, @var{trange}, @var{init}, @var{opt})
+## @deftypefnx {Function File} {[@var{t}, @var{y}] =} ode45 (@dots{}, @var{par1}, @var{par2}, @dots{})
+## @deftypefnx {Function File} {[@var{t}, @var{y}, @var{xe}, @var{ye}, @var{ie}] =} ode45 (@dots{})
+## @deftypefnx {Function File} {@var{sol} =} ode45 (@var{fun}, @var{trange}, @var{init}, @dots{})
 ##
-## This function can be called with two output arguments: @var{t} and @var{y}.
-## Variable @var{t} is a column vector and contains the time stamps, instead
-## @var{y} is a matrix in which each column refers to a different unknown of
-## the problem and the rows number is the same of @var{t} rows number so that each
-## row of @var{y} contains the values of all unknowns at the time value contained
-## in the corresponding row in @var{t}.
+## Solve a set of non-stiff Ordinary Differential Equations (non-stiff ODEs)
+## with the well known explicit Dormand-Prince method of order 4.
 ##
-## The first input argument must be a function_handle or an inline function that
-## defines the set of ODE: @code{y' = f(t,y)}. As described above, this function
-## must take two input arguments, where the first is the time and the second
-## the unknowns, and must have just one output argument.
+## The first input argument must be a function handle or inline function that
+## defines the ODE: @code{y' = f(t,y)}.  The function must accept two inputs
+## where the first is time @var{t} and the second is a column vector of
+## unknowns @var{y}.
 ##
-## The second input argument must contain time informations. Usually it should
-## be a vector with at least two elements which define the initial and the final
-## time instants; if the elements are more than two, then the solution will be
-## evaluated also at these intermediate time instants unless the integrate function
-## called is the @command{integrate_n_steps}. If there is only one time value,
-## then it will give an error unless the options structure has no empty fields
-## named @var{"TimeStepNumber"} and @var{"TimeStepSize"}. If the option
-## @var{"TimeStepSize"} is not empty, then the stepper called will be
-## @command{integrate_const}, if also @var{"TimeStepNumber"} is not empty it will
-## be called the integrate function @command{integrate_n_steps}, otherwise it will
-## be called @command{integrate_adaptive}. For this last possibility the user can
-## set the tolerance for the timestep computation by setting a value to the option
-## @var{"Tau"}, that as default value has @math{1.e-6}.
+## @var{trange} specifies the time interval over which the ODE will be
+## evaluated.  Usually, it is a two-element vector specifying the initial and
+## final times (@code{[tinit, tfinal]}).  If there are more than two elements
+## then the solution will also be evaluated at these intermediate time
+## instances unless the integrate function called is
+## @command{integrate_n_steps}.  If there is only one time value, then
+## @code{ode45} will raise an error unless the options structure has
+## non-empty fields named @var{"TimeStepNumber"} and @var{"TimeStepSize"}. 
+## If the option @var{"TimeStepSize"} is not empty, then the stepper called
+## will be @command{integrate_const}.  If @var{"TimeStepNumber"} is also
+## specified then the integrate function @command{integrate_n_steps} will be
+## used; otherwise, @command{integrate_adaptive} is used.  For this last
+## possibility the user can set the tolerance for the timestep computation by
+## changing the option @var{"Tau"}, that has a default value of @math{1e-6}.
 ##
-## The third input argument must contain the initial value for the unknown.
-## If this is a vector then the solution @var{y} will be a matrix in which each
-## column is the solution for the corresponding initial value in @var{init}.
+## The third input argument @var{init} contains the initial value for the
+## unknowns.  If this is a row vector then the solution @var{y} will be a matrix
+## in which each column is the solution for the corresponding initial value
+## in @var{init}.
 ##
-## The fourth input argument is not mandatory and it should contain a structure
-## with valid ODE fields.
+## If present, the fourth input argument specifies options to the ODE solver.
+## It is a structure typically generated by @code{odeset}.
+##
+## The function usually produces just two outputs.  Variable @var{t} is a
+## column vector and contains the times where the solution was found.  The
+## output @var{y} is a matrix in which each column refers to a different
+## unknown of the problem and each row corresponds to a time in @var{t}.
 ##
 ## For example, solve an anonymous implementation of the Van der Pol equation
+##
 ## @example
+## @group
 ## fvdp = @@(t,y) [y(2); (1 - y(1)^2) * y(2) - y(1)];
 ## [T,Y] = ode45 (fvdp, [0 20], [2 0]);
+## @end group
 ## @end example
+## @seealso{odeset, odeget}
 ## @end deftypefn
-##
 
 function [varargout] = ode45 (vfun, vslot, vinit, varargin)
 
   vorder = 5; % runge_kutta_45_dorpri uses local extrapolation
   vsolver = "ode45";
 
   if (nargin == 0) ## Check number and types of all input arguments
     help (vsolver);
diff --git a/scripts/ode/odeget.m b/scripts/ode/odeget.m
--- a/scripts/ode/odeget.m
+++ b/scripts/ode/odeget.m
@@ -13,30 +13,33 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {[@var{}] =} odeget (@var{ode_opt}, @var{field}, [@var{default}], [@var{opt}])
-## @deftypefnx  {Function File} {[@var{res}] =} odeget (@var{ode_opt}, @var{field}, [@var{default}], [@var{opt}])
+## @deftypefn  {Function File} {@var{option} =} odeget (@var{ode_opt}, @var{field})
+## @deftypefnx {Function File} {@var{option} =} odeget (@var{ode_opt}, @var{field}, @var{default})
+##
+## Query the value of the property @var{field} in the ODE options structure
+## @var{ode_opt}.
 ##
 ## If this function is called with two input arguments and the first input
 ## argument @var{ode_opt} is of type structure array and the second input
-## argument @var{field} is of type string then return the option
-## value @var{res} that is specified by the option name @var{field} in
-## the ODE option structure @var{ode_opt}. Optionally if this function
-## is called with a third input argument then return the default value
-## @var{default} if @var{field} is not set in the structure @var{ode_opt}.
+## argument @var{field} is of type string then return the option value
+## @var{res} that is specified by the option name @var{field} in the ODE
+## option structure @var{ode_opt}.  Optionally if this function is called
+## with a third input argument then return the default value @var{default} if
+## @var{field} is not set in the structure @var{ode_opt}.
+## @seealso{odeset}
 ## @end deftypefn
-##
 
-## Note: 20061022, Thomas Treichl
+## Note: 2006-10-22, Thomas Treichl
 ##   We cannot create a function of the form odeget (@var{odestruct},
 ##   @var{name1}, @var{name2}) because we would get a mismatch with
 ##   the function form 1 like described above.
 
 function res = odeget (ode_opt, field, default, opt)
 
   ## Check number and types of input arguments
   if (nargin == 1)
diff --git a/scripts/ode/odeset.m b/scripts/ode/odeset.m
--- a/scripts/ode/odeset.m
+++ b/scripts/ode/odeset.m
@@ -14,45 +14,46 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {[@var{}] =} odeset ()
-## @deftypefnx {Function File}  {[@var{odestruct}] =} odeset (@var{"field1"}, @var{value1}, @var{"field2"}, @var{value2}, @dots{})
-## @deftypefnx {Function File}  {[@var{odestruct}] =} odeset (@var{oldstruct}, @var{"field1"}, @var{value1}, @var{"field2"}, @var{value2}, @dots{})
-## @deftypefnx {Function File}  {[@var{odestruct}] =} odeset (@var{oldstruct},
-## @var{newstruct})
+## @deftypefn  {Function File} {} odeset ()
+## @deftypefnx {Function File} {@var{odestruct} =} odeset (@var{"field1"}, @var{value1}, @var{"field2"}, @var{value2}, @dots{})
+## @deftypefnx {Function File} {@var{odestruct} =} odeset (@var{oldstruct}, @var{"field1"}, @var{value1}, @var{"field2"}, @var{value2}, @dots{})
+## @deftypefnx {Function File} {@var{odestruct} =} odeset (@var{oldstruct}, @var{newstruct})
 ##
-## If this function is called without an input argument then return a new
-## ODE options structure array that contains all the necessary fields and
-## sets the values of all fields to default values.
+## Create or modify an ODE options structure.
+##
+## If this function is called without an input argument then return a new ODE
+## options structure array that contains all the necessary fields and sets
+## the values of all fields to default values.
 ##
 ## If this function is called with string input arguments @var{"field1"},
-## @var{"field2"}, @dots{} identifying valid ODE options then return a
-## new ODE options structure with all necessary fields and set the values
-## of the fields @var{"field1"}, @var{"field2"}, @dots{} to the values
-## @var{value1}, @var{value2}, @dots{}
+## @var{"field2"}, @dots{} identifying valid ODE options then return a new
+## ODE options structure with all necessary fields and set the values of the
+## fields @var{"field1"}, @var{"field2"}, @dots{} to the values @var{value1},
+## @var{value2}, @dots{}
 ##
-## If this function is called with a first input argument @var{oldstruct}
-## of type structure array then overwrite all values of the options
+## If this function is called with a first input argument @var{oldstruct} of
+## type structure array then overwrite all values of the options
 ## @var{"field1"}, @var{"field2"}, @dots{} of the structure @var{oldstruct}
 ## with new values @var{value1}, @var{value2}, @dots{} and return the
 ## modified structure array.
 ##
-## If this function is called with two input arguments @var{oldstruct}
-## and @var{newstruct} of type structure array then overwrite all values
-## in the fields from the structure @var{oldstruct} with new values of the
-## fields from the structure @var{newstruct}. Empty values of @var{newstruct}
-## will not overwrite values in @var{oldstruct}.
+## If this function is called with two input arguments @var{oldstruct} and
+## @var{newstruct} of type structure array then overwrite all values in the
+## fields from the structure @var{oldstruct} with new values of the fields
+## from the structure @var{newstruct}.  Empty values of @var{newstruct} will
+## not overwrite values in @var{oldstruct}.
+## @seealso{odeget}
 ## @end deftypefn
-##
 
 function opt = odeset (varargin)
 
   ## Check number and types of all input arguments
   if ((nargin == 0)
       && (nargout == 0))
     print_options;
     return
diff --git a/scripts/ode/private/AbsRel_Norm.m b/scripts/ode/private/AbsRel_Norm.m
--- a/scripts/ode/private/AbsRel_Norm.m
+++ b/scripts/ode/private/AbsRel_Norm.m
@@ -12,17 +12,16 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-
 function res = AbsRel_Norm (x, x_old, AbsTol, RelTol, normcontrol, y)
 
   n = length (x);
 
   if (nargin == 5)
     y = zeros (size (x));
   elseif (nargin != 6)
     error ("OdePkg:InvalidArgument",
diff --git a/scripts/ode/private/fuzzy_compare.m b/scripts/ode/private/fuzzy_compare.m
--- a/scripts/ode/private/fuzzy_compare.m
+++ b/scripts/ode/private/fuzzy_compare.m
@@ -11,61 +11,56 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-
 ## -*- texinfo -*-
-## @deftypefn {Command} {[@var{res}] =} fuzzy_compare @
-## (@var{"string1"}, @var{string_set}, [@var{correctness}])
+## @deftypefn {Function File} {[@var{res}] =} fuzzy_compare (@var{"string1"}, @var{string_set}, [@var{correctness}])
 ##
-## Compare a string with a set of strings and returns the positions
-## in the set of strings at which there are the fields that best fit
-## the one we are comparing.
+## Compare a string with a set of strings and returns the positions in the
+## set of strings at which there are the fields that best fit the one we are
+## comparing.
 ##
 ## The distance used to compare the words is the Levenshtein distance
 ## and for more details see
 ## @url{http://en.wikipedia.org/wiki/Levenshtein_distance}.
 ##
-## This function must be called with one output argument @var{res}
-## which contains the positions of the elements in @var{string_set}
-## which best fit the given word. The tolerance that is used to
-## determine if a field of the list fits or not the given word is a
-## function of the length of the word and of the minimum distance of
-## the word from all the elements of the list. The more the length,
-## the more the tolerance. The less the minimum, the less the
-## tolerance but if the minimum is close to the length of the word,
-## the tolerance must be small because it means that no field in the
-## list is really fitting the given word. So that the function is:
+## This function must be called with one output argument @var{res} which
+## contains the positions of the elements in @var{string_set} which best fit
+## the given word.  The tolerance that is used to determine if a field of the
+## list fits or not the given word is a function of the length of the word
+## and of the minimum distance of the word from all the elements of the list.
+##  The more the length, the more the tolerance.  The less the minimum, the
+## less the tolerance but if the minimum is close to the length of the word,
+## the tolerance must be small because it means that no field in the list is
+## really fitting the given word.  So that the function is:
 ##
 ## @ifhtml
 ## @example
 ## @math{tolerance = 2 * (length-minimum) * minimum / length}
 ## @end example
 ## @end ifhtml
 ## @ifnothtml
 ## @math{tolerance = 2 * (length-minimum) * minimum / length}.
 ## @end ifnothtml
 ##
-## The first input argument must be a string containing the word to
-## compare.
+## The first input argument must be a string containing the word to compare.
 ##
-## The second input argument must be a vector of strings or a
-## cell_array of strings and should contain the fields to use for the
-## comparison.
+## The second input argument must be a vector of strings or a cell_array of
+## strings and should contain the fields to use for the comparison.
 ##
-## The third input argument is optional and represents a fixed
-## tolerance that will replace the implemented one.
+## The third input argument is optional and represents a fixed tolerance that
+## will replace the implemented one.
 ## @end deftypefn
 ##
-## @seealso{odeset,odeget,levenshtein}
+## @seealso{odeset, odeget, levenshtein}
 
 function res = fuzzy_compare (string1, string_set, correctness)
 
   ## check on output arguments
   if (nargout > 1)
     error ("OdePkg:InvalidArgument", "too many output arguments");
   endif
 
diff --git a/scripts/ode/private/hermite_quartic_interpolation.m b/scripts/ode/private/hermite_quartic_interpolation.m
--- a/scripts/ode/private/hermite_quartic_interpolation.m
+++ b/scripts/ode/private/hermite_quartic_interpolation.m
@@ -11,27 +11,25 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-
 ## -*- texinfo -*-
-## @deftypefn {Command} {[@var{x_out}] =}
-## hermite_quartic_interpolation (@var{t}, @var{x}, @var{der}, @var{t_out})
+## @deftypefn {Function File} {[@var{x_out}] =} hermite_quartic_interpolation (@var{t}, @var{x}, @var{der}, @var{t_out})
 ##
-## This function file can be called by a ODE solver function in order to
+## This function file can be called by an ODE solver function in order to
 ## interpolate the solution at the time @var{t_out} using 4th order
-## hermite interpolation.
+## Hermite interpolation.
 ##
 ## This function must be called with one output arguments: @var{x_out}
-## which contains the evaluation at @var{t_out} of the hermite interpolant.
+## which contains the evaluation at @var{t_out} of the Hermite interpolant.
 ##
 ## The first input argument is the vector with two given times.
 ##
 ## The second input argument is the vector with the values of the function
 ## to interpolate at the times specified in @var{t} and at the middle point.
 ##
 ## The third input argument is the value of the derivatives of the function
 ## evaluated at the two extreme points.
diff --git a/scripts/ode/private/integrate_adaptive.m b/scripts/ode/private/integrate_adaptive.m
--- a/scripts/ode/private/integrate_adaptive.m
+++ b/scripts/ode/private/integrate_adaptive.m
@@ -11,38 +11,35 @@
 ## WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
-
 ## -*- texinfo -*-
-## @deftypefn {Command} {[@var{t}, @var{y}] =}
-## integrate_adaptive (@var{@@stepper}, @var{order}, @var{@@fun}, @var{tspan},
-## @var{x0}, @var{options})
+## @deftypefn {Function File} {[@var{t}, @var{y}] =} integrate_adaptive (@var{@@stepper}, @var{order}, @var{@@fun}, @var{tspan}, @var{x0}, @var{options})
 ##
-## This function file can be called by a ODE solver function in order to
+## This function file can be called by an ODE solver function in order to
 ## integrate the set of ODEs on the interval @var{[t0,t1]} with an
 ## adaptive timestep.
 ##
 ## This function must be called with two output arguments: @var{t} and @var{y}.
 ## Variable @var{t} is a column vector and contains the time stamps, instead
 ## @var{y} is a matrix in which each column refers to a different unknown
 ## of the problem and the rows number is the same of @var{t} rows number so
 ## that each row of @var{y} contains the values of all unknowns at the time
 ## value contained in the corresponding row in @var{t}.
 ##
 ## The first input argument must be a function_handle or an inline function
 ## representing the stepper, that is the function responsible for step-by-step
-## integration. This function discriminates one method from the others.
+## integration.  This function discriminates one method from the others.
 ##
-## The second input argument is the order of the stepper. It is needed
+## The second input argument is the order of the stepper.  It is needed
 ## to compute the adaptive timesteps.
 ##
 ## The third input argument is a function_handle or an inline function that
 ## defines the set of ODE:
 ## @ifhtml
 ## @example
 ## @math{y' = f(t,y)}
 ## @end example
diff --git a/scripts/ode/private/integrate_const.m b/scripts/ode/private/integrate_const.m
--- a/scripts/ode/private/integrate_const.m
+++ b/scripts/ode/private/integrate_const.m
@@ -12,39 +12,38 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Command} {[@var{t}, @var{y}] =} integrate_const (@var{@@stepper},
-## @var{@@fun}, @var{tspan}, @var{x0}, @var{dt}, @var{options})
+## @deftypefn {Function File} {[@var{t}, @var{y}] =} integrate_const (@var{@@stepper}, @var{@@fun}, @var{tspan}, @var{x0}, @var{dt}, @var{options})
 ##
 ## This function file can be called by an ODE solver function in order to
-## integrate the set of ODEs on the interval @var{[t0,t1]} with a
-## constant timestep @var{dt}.
+## integrate the set of ODEs on the interval @var{[t0,t1]} with a constant
+## timestep @var{dt}.
 ##
 ## This function must be called with two output arguments: @var{t} and @var{y}.
-## Variable @var{t} is a column vector and contains the time stamps,
-## instead @var{y} is a matrix in which each column refers to a different
-## unknown of the problem and the rows number is the same of @var{t} rows
-## number so that each row of @var{y} contains the values of all unknowns at
-## the time value contained in the corresponding row in @var{t}.
+## Variable @var{t} is a column vector and contains the time stamps, instead
+## @var{y} is a matrix in which each column refers to a different unknown of
+## the problem and the rows number is the same of @var{t} rows number so that
+## each row of @var{y} contains the values of all unknowns at the time value
+## contained in the corresponding row in @var{t}.
 ##
 ## The first input argument must be a function_handle or an inline function
 ## representing the stepper, that is the function responsible for step-by-step
-## integration. This function discriminates one method from the others.
+## integration.  This function discriminates one method from the others.
 ##
-## The second input argument is the order of the stepper. It is needed to
+## The second input argument is the order of the stepper.  It is needed to
 ## compute the adaptive timesteps.
 ##
-## The third input argument is a function_handle or an inline function
-## that defines the set of ODE:
+## The third input argument is a function_handle or an inline function that
+## defines the set of ODE:
 ##
 ## @ifhtml
 ## @example
 ## @math{y' = f(t,y)}
 ## @end example
 ## @end ifhtml
 ## @ifnothtml
 ## @math{y' = f(t,y)}.
diff --git a/scripts/ode/private/integrate_n_steps.m b/scripts/ode/private/integrate_n_steps.m
--- a/scripts/ode/private/integrate_n_steps.m
+++ b/scripts/ode/private/integrate_n_steps.m
@@ -12,40 +12,38 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Command} {[@var{t}, @var{y}] =} integrate_n_steps
-## (@var{@@stepper}, @var{@@fun}, @var{t0}, @var{x0}, @var{dt}, @var{n},
-## @var{options})
+## @deftypefn {Function File} {[@var{t}, @var{y}] =} integrate_n_steps (@var{@@stepper}, @var{@@fun}, @var{t0}, @var{x0}, @var{dt}, @var{n}, @var{options})
 ##
 ## This function file can be called by an ODE solver function in order to
 ## integrate the set of ODEs on the interval @var{[t0,t0 + n*dt]} with a
 ## constant timestep dt and on a fixed number of steps.
 ##
 ## This function must be called with two output arguments: @var{t} and @var{y}.
 ## Variable @var{t} is a column vector and contains the time stamps, instead
 ## @var{y} is a matrix in which each column refers to a different unknown of
 ## the problem and the rows number is the same of @var{t} rows number so that
 ## each row of @var{y} contains the values of all unknowns at the time
 ## value contained in the corresponding row in @var{t}.
 ##
 ## The first input argument must be a function_handle or an inline function
 ## representing the stepper, that is the function responsible for step-by-step
-## integration. This function discriminates one method from the others.
+## integration.  This function discriminates one method from the others.
 ##
-## The second input argument is the order of the stepper. It is needed
-## to compute the adaptive timesteps.
+## The second input argument is the order of the stepper.  It is needed to
+## compute the adaptive timesteps.
 ##
-## The third input argument is a function_handle or an inline function
-## that defines the set of ODE:
+## The third input argument is a function_handle or an inline function that
+## defines the set of ODE:
 ##
 ## @ifhtml
 ## @example
 ## @math{y' = f(t,y)}
 ## @end example
 ## @end ifhtml
 ## @ifnothtml
 ## @math{y' = f(t,y)}.
diff --git a/scripts/ode/private/kahan.m b/scripts/ode/private/kahan.m
--- a/scripts/ode/private/kahan.m
+++ b/scripts/ode/private/kahan.m
@@ -12,39 +12,39 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Command} {[@var{sum}] =} kahan (@var{sum},
-## @var{comp}, @var{temp})
-## @deftypefnx {Command} {[@var{sum}, @var{comp}] =} kahan (@var{sum},
-## @var{comp}, @var{temp})
+## @deftypefn  {Function File} {[@var{sum}] =} kahan (@var{sum}, @var{comp}, @var{temp})
+## @deftypefnx {Function File} {[@var{sum}, @var{comp}] =} kahan (@var{sum}, @var{comp}, @var{temp})
 ##
 ## This function is the implementation of the Kahan summation algorithm,
-## also known as compensated summation. It significantly reduces the numerical
-## error in the total obtained by adding a sequence of finite precision
-## floating point numbers, compared to the obvious approach. For more details
+## also known as compensated summation.
+##
+## It significantly reduces the numerical error in the total obtained by adding
+## a sequence of finite precision floating point numbers, compared to the
+## obvious approach.  For more details
 ## see @url{http://en.wikipedia.org/wiki/Kahan_summation_algorithm}.
 ## This function is called in @command{integrate_adaptive} and in
 ## @command{integrate_const} to better catch equality comparisons.
 ##
 ## The first input argument is the variable that will contain the summation,
 ## so that is also returned as first output argument in order to reuse it in
 ## next calls to kahan function.
 ##
 ## The second input argument contains the compensation term and it is returned
-## as second output argument so that it can be reused in the next calls
-## of the same computation.
+## as second output argument so that it can be reused in the next calls of the
+## same computation.
 ##
-## The third input argument is the variable that contains the term to
-## be added to @var{Sum}.
+## The third input argument is the variable that contains the term to be added
+## to @var{Sum}.
 ## @end deftypefn
 
 function [Sum, comp] = kahan (Sum, comp, term)
 
     y = term - comp;
     t = Sum + y;
     comp = (t - Sum) - y;
     Sum = t;
diff --git a/scripts/ode/private/ode_struct_value_check.m b/scripts/ode/private/ode_struct_value_check.m
--- a/scripts/ode/private/ode_struct_value_check.m
+++ b/scripts/ode/private/ode_struct_value_check.m
@@ -13,24 +13,23 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{}] =}
-## ode_struct_value_check (@var{arg}, [@var{"solver"}])
+## @deftypefn {Function File} {[@var{}] =} ode_struct_value_check (@var{arg}, [@var{"solver"}])
 ##
 ## If this function is called with one input argument of type structure array
 ## then check the field names and the field values of the OdePkg structure
-## @var{arg}. Optionally if this function is called with a second input
+## @var{arg}.  Optionally if this function is called with a second input
 ## argument @var{"solver"} of type string that specifies the name of a valid
-## OdePkg solver then a higher level error detection is performed. The function
+## OdePkg solver then a higher level error detection is performed.  The function
 ## does not modify any of the field names or field values but terminates with
 ## an error if an invalid option or value is found.
 ##
 ## This function is an OdePkg internal helper function therefore it should
 ## never be necessary that this function is called directly by a user.
 ## @end deftypefn
 ##
 ## @seealso{odeset, odeget}
diff --git a/scripts/ode/private/odepkg_event_handle.m b/scripts/ode/private/odepkg_event_handle.m
--- a/scripts/ode/private/odepkg_event_handle.m
+++ b/scripts/ode/private/odepkg_event_handle.m
@@ -12,30 +12,50 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{sol}] =} odepkg_event_handle (@var{@@fun}, @var{time}, @var{y}, @var{flag}, [@var{par1}, @var{par2}, @dots{}])
+## @deftypefn {Function File} {[@var{sol}] =} odepkg_event_handle (@var{@@fun}, @var{time}, @var{y}, @var{flag}, @var{par1}, @var{par2}, @dots{})
+##
+## Return the solution of the event function that is specified as the first
+## input argument @var{@@fun} in form of a function handle.
 ##
-## Return the solution of the event function that is specified as the first input argument @var{@@fun} in form of a function handle. The second input argument @var{time} is of type double scalar and specifies the time of the event evaluation, the third input argument @var{y} either is of type double column vector (for ODEs and DAEs) and specifies the solutions or is of type cell array (for IDEs and DDEs) and specifies the derivatives or the history values, the third input argument @var{flag} is of type string and can be of the form 
+## The second input argument @var{time} is of type double scalar and
+## specifies the time of the event evaluation, the third input argument
+## @var{y} either is of type double column vector (for ODEs and DAEs) and
+## specifies the solutions or is of type cell array (for IDEs and DDEs) and
+## specifies the derivatives or the history values, the third input argument
+## @var{flag} is of type string and can be of the form 
+##
 ## @table @option
-## @item  @code{"init"}
-## then initialize internal persistent variables of the function @command{odepkg_event_handle} and return an empty cell array of size 4,
-## @item  @code{"calc"}
-## then do the evaluation of the event function and return the solution @var{sol} as type cell array of size 4,
-## @item  @code{"done"}
-## then cleanup internal variables of the function @command{odepkg_event_handle} and return an empty cell array of size 4.
+## @item  @qcode{"init"}
+## then initialize internal persistent variables of the function
+## @command{odepkg_event_handle} and return an empty cell array of size 4,
+##
+## @item  @qcode{"calc"}
+## then do the evaluation of the event function and return the solution
+## @var{sol} as type cell array of size 4,
+##
+## @item  @qcode{"done"}
+## then cleanup internal variables of the function
+## @command{odepkg_event_handle} and return an empty cell array of size 4.
 ## @end table
-## Optionally if further input arguments @var{par1}, @var{par2}, @dots{} of any type are given then pass these parameters through @command{odepkg_event_handle} to the event function.
+##
+## Optionally if further input arguments @var{par1}, @var{par2}, @dots{} of
+## any type are given then pass these parameters through
+## @command{odepkg_event_handle} to the event function.
 ##
-## This function is an OdePkg internal helper function therefore it should never be necessary that this function is called directly by a user. There is only little error detection implemented in this function file to achieve the highest performance.
+## This function is an OdePkg internal helper function therefore it should
+## never be necessary that this function is called directly by a user.  There
+## is only little error detection implemented in this function file to
+## achieve the highest performance.
 ## @end deftypefn
 ##
 ## @seealso{odepkg}
 
 function [vretval] = odepkg_event_handle (vevefun, vt, vy, vflag, varargin)
 
   ## No error handling has been implemented in this function to achieve
   ## the highest performance available.
diff --git a/scripts/ode/private/odepkg_structure_check.m b/scripts/ode/private/odepkg_structure_check.m
--- a/scripts/ode/private/odepkg_structure_check.m
+++ b/scripts/ode/private/odepkg_structure_check.m
@@ -10,30 +10,43 @@
 %# This program is distributed in the hope that it will be useful,
 %# but WITHOUT ANY WARRANTY; without even the implied warranty of
 %# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 %# GNU General Public License for more details.
 %#
 %# You should have received a copy of the GNU General Public License
 %# along with this program; If not, see <http://www.gnu.org/licenses/>.
 
-%# -*- texinfo -*-
-%# @deftypefn {Function File} {[@var{newstruct}] =} odepkg_structure_check (@var{oldstruct}, [@var{"solver"}])
-%#
-%# If this function is called with one input argument of type structure array then check the field names and the field values of the OdePkg structure @var{oldstruct} and return the structure as @var{newstruct} if no error is found. Optionally if this function is called with a second input argument @var{"solver"} of type string taht specifies the name of a valid OdePkg solver then a higher level error detection is performed. The function does not modify any of the field names or field values but terminates with an error if an invalid option or value is found.
-%#
-%# This function is an OdePkg internal helper function therefore it should never be necessary that this function is called directly by a user. There is only little error detection implemented in this function file to achieve the highest performance.
-%#
-%# Run examples with the command
-%# @example
-%# demo odepkg_structure_check
-%# @end example
-%# @end deftypefn
-%#
-%# @seealso{odepkg}
+## -*- texinfo -*-
+## @deftypefn {Function File} {[@var{newstruct}] =} odepkg_structure_check (@var{oldstruct}, [@var{"solver"}])
+##
+## If this function is called with one input argument of type structure array
+## then check the field names and the field values of the OdePkg structure
+## @var{oldstruct} and return the structure as @var{newstruct} if no error is
+## found.
+##
+## Optionally if this function is called with a second input argument
+## @var{"solver"} of type string taht specifies the name of a valid OdePkg
+## solver then a higher level error detection is performed.  The function
+## does not modify any of the field names or field values but terminates with
+## an error if an invalid option or value is found.
+##
+## This function is an OdePkg internal helper function therefore it should
+## never be necessary that this function is called directly by a user.  There
+## is only little error detection implemented in this function file to
+## achieve the highest performance.
+##
+## Run examples with the command
+##
+## @example
+## demo odepkg_structure_check
+## @end example
+## @end deftypefn
+##
+## @seealso{odepkg}
 
 function [vret] = odepkg_structure_check (varargin)
 
   %# Check the number of input arguments
   if (nargin == 0)
     help ('odepkg_structure_check');
     error ('OdePkg:InvalidArgument', ...
       'Number of input arguments must be greater than zero');
diff --git a/scripts/ode/private/runge_kutta_45_dorpri.m b/scripts/ode/private/runge_kutta_45_dorpri.m
--- a/scripts/ode/private/runge_kutta_45_dorpri.m
+++ b/scripts/ode/private/runge_kutta_45_dorpri.m
@@ -13,54 +13,48 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Command} {[@var{t_next}, @var{x_next}] =}
-## runge_kutta_45_dorpri (@var{@@fun}, @var{t}, @var{x}, @var{dt},
-## [@var{options}, @var{k_vals_in}])
-## @deftypefnx {Command} {[@var{t_next}, @var{x_next}, @var{x_est}] =}
-## runge_kutta_45_dorpri (@var{@@fun}, @var{t}, @var{x}, @var{dt},
-## [@var{options}, @var{k_vals_in}])
-## @deftypefnx {Command} {[@var{t_next}, @var{x_next}, @var{x_est},
-## @var{k_vals_out}] =} runge_kutta_45_dorpri (@var{@@fun}, @var{t}, @var{x},
-## @var{dt}, [@var{options}, @var{k_vals_in}])
+## @deftypefn  {Function File} {[@var{t_next}, @var{x_next}] =} runge_kutta_45_dorpri (@var{@@fun}, @var{t}, @var{x}, @var{dt}, @var{options}, @var{k_vals_in})
+## @deftypefnx {Function File} {[@var{t_next}, @var{x_next}, @var{x_est}] =} runge_kutta_45_dorpri (@var{@@fun}, @var{t}, @var{x}, @var{dt}, @var{options}, @var{k_vals_in})
+## @deftypefnx {Function File} {[@var{t_next}, @var{x_next}, @var{x_est}, @var{k_vals_out}] =} runge_kutta_45_dorpri (@var{@@fun}, @var{t}, @var{x}, @var{dt}, @var{options}, @var{k_vals_in})
 ##
 ## This function can be used to integrate a system of ODEs with a given initial
 ## condition @var{x} from @var{t} to @var{t+dt}, with the Dormand-Prince method.
 ## For the definition of this method see
 ## @url{http://en.wikipedia.org/wiki/Dormand%E2%80%93Prince_method}.
 ##
 ## First output argument is the final integration time value.
 ##
 ## Second output parameter is the higher order computed solution at time
 ## @var{t_next} (local extrapolation).
 ##
-## Third output parameter is a lower order solution for the estimation
-## of the error.
+## Third output parameter is a lower order solution for the estimation of the
+## error.
 ##
 ## Fourth output parameter is matrix containing the Runge-Kutta evaluations
 ## to use in a FSAL scheme or for dense output.
 ##
-## First input argument is the function describing the system of ODEs
-## to be integrated.
+## First input argument is the function describing the system of ODEs to be
+## integrated.
 ##
 ## Second input parameter is the first extreme of integration interval.
 ##
 ## Third input argument is the initial condition of the system.
 ##
 ## Fourth input argument is the timestep, that is the length of the
 ## integration interval.
 ##
-## Fifth input parameter is optional and describes a set of options useful
-## to adapt the computation to what is needed.
+## Fifth input parameter is optional and describes a set of options useful to
+## adapt the computation to what is needed.
 ##
 ## Sixth input parameter is optional and describes the Runge-Kutta evaluations
 ## of the previous step to use in a FSAL scheme.
 ## @end deftypefn
 ##
 ## @seealso{odepkg}
 
 function [t_out, x_out, x_est, k] = ...
diff --git a/scripts/ode/private/starting_stepsize.m b/scripts/ode/private/starting_stepsize.m
--- a/scripts/ode/private/starting_stepsize.m
+++ b/scripts/ode/private/starting_stepsize.m
@@ -12,25 +12,24 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Command} {[@var{h}] =} starting_stepsize (@var{order},
-## @var{@@fun}, @var{t0}, @var{x0})
+## @deftypefn {Function File} {[@var{h}] =} starting_stepsize (@var{order}, @var{@@fun}, @var{t0}, @var{x0})
 ##
 ## This function file can be used to determine a good initial step for an ODE
-## solver of order @var{order}. The algorithm is that one described in [1].
+## solver of order @var{order}.  The algorithm is that one described in [1].
 ##
 ## Second input argument, which is @var{@@fun}, is the function describing
-## the differential equations, @var{t0} is the initial time and @var{x0}
-## is the initial condition.
+## the differential equations, @var{t0} is the initial time and @var{x0} is
+## the initial condition.
 ## 
 ## This function returns a good guess for the initial timestep @var{h}.
 ##
 ## References:
 ## [1] E. Hairer, S.P. Norsett and G. Wanner,
 ## "Solving Ordinary Differential Equations I: Nonstiff Problems", Springer.
 ## @end deftypefn
 ##
