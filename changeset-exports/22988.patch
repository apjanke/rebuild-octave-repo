# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1483124581 18000
#      Fri Dec 30 14:03:01 2016 -0500
# Node ID cd33c785e80eff1791548685fd4cd5e6d1ca8900
# Parent  4643c8bce4e764ee4035dac9555738f10525f396
put to_f77_int inside octave namespace

* f77-fcn.h (to_f77_int): Move inside octave namespace.
Change all uses.

diff --git a/libinterp/corefcn/__pchip_deriv__.cc b/libinterp/corefcn/__pchip_deriv__.cc
--- a/libinterp/corefcn/__pchip_deriv__.cc
+++ b/libinterp/corefcn/__pchip_deriv__.cc
@@ -50,31 +50,31 @@ Undocumented internal function.
 
   if (nargin >= 2)
     {
       if (args(0).is_single_type () || args(1).is_single_type ())
         {
           FloatColumnVector xvec (args(0).float_vector_value ());
           FloatMatrix ymat (args(1).float_matrix_value ());
 
-          F77_INT nx = to_f77_int (xvec.numel ());
+          F77_INT nx = octave::to_f77_int (xvec.numel ());
 
           if (nx < 2)
             error ("__pchip_deriv__: X must be at least of length 2");
 
           octave_idx_type nyr = ymat.rows ();
           octave_idx_type nyc = ymat.columns ();
 
           if (nx != (rows ? nyc : nyr))
             error ("__pchip_deriv__: X and Y dimension mismatch");
 
           FloatMatrix dmat (nyr, nyc);
 
           F77_INT ierr;
-          const F77_INT incfd = rows ? to_f77_int (nyr) : 1;
+          const F77_INT incfd = rows ? octave::to_f77_int (nyr) : 1;
           volatile const octave_idx_type inc = rows ? 1 : nyr;
           volatile octave_idx_type k = 0;
 
           for (volatile octave_idx_type i = (rows ? nyr : nyc); i > 0; i--)
             {
               F77_XFCN (pchim, PCHIM, (nx, xvec.data (),
                                        ymat.data () + k * inc,
                                        dmat.fortran_vec () + k * inc,
@@ -88,31 +88,31 @@ Undocumented internal function.
 
           retval = dmat;
         }
       else
         {
           ColumnVector xvec (args(0).vector_value ());
           Matrix ymat (args(1).matrix_value ());
 
-          F77_INT nx = to_f77_int (xvec.numel ());
+          F77_INT nx = octave::to_f77_int (xvec.numel ());
 
           if (nx < 2)
             error ("__pchip_deriv__: X must be at least of length 2");
 
           octave_idx_type nyr = ymat.rows ();
           octave_idx_type nyc = ymat.columns ();
 
           if (nx != (rows ? nyc : nyr))
             error ("__pchip_deriv__: X and Y dimension mismatch");
 
           Matrix dmat (nyr, nyc);
 
           F77_INT ierr;
-          const F77_INT incfd = rows ? to_f77_int (nyr) : 1;
+          const F77_INT incfd = rows ? octave::to_f77_int (nyr) : 1;
           volatile const octave_idx_type inc = rows ? 1 : nyr;
           volatile octave_idx_type k = 0;
 
           for (volatile octave_idx_type i = (rows ? nyr : nyc); i > 0; i--)
             {
               F77_XFCN (dpchim, DPCHIM, (nx, xvec.data (),
                                          ymat.data () + k * inc,
                                          dmat.fortran_vec () + k * inc,
diff --git a/libinterp/corefcn/dot.cc b/libinterp/corefcn/dot.cc
--- a/libinterp/corefcn/dot.cc
+++ b/libinterp/corefcn/dot.cc
@@ -54,19 +54,19 @@ get_red_dims (const dim_vector& x, const
         }
       else
         {
           tmp_k = x(i);
           z(i) = 1;
         }
     }
 
-  m = to_f77_int (tmp_m);
-  n = to_f77_int (tmp_n);
-  k = to_f77_int (tmp_k);
+  m = octave::to_f77_int (tmp_m);
+  n = octave::to_f77_int (tmp_n);
+  k = octave::to_f77_int (tmp_k);
 }
 
 DEFUN (dot, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} dot (@var{x}, @var{y}, @var{dim})
 Compute the dot product of two vectors.
 
 If @var{x} and @var{y} are matrices, calculate the dot products along the
@@ -255,31 +255,31 @@ endfor
   octave_value argy = args(1);
 
   if (! argx.is_numeric_type () || ! argy.is_numeric_type ())
     error ("blkmm: A and B must be numeric");
 
   const dim_vector dimx = argx.dims ();
   const dim_vector dimy = argy.dims ();
   int nd = dimx.ndims ();
-  F77_INT m = to_f77_int (dimx(0));
-  F77_INT k = to_f77_int (dimx(1));
-  F77_INT n = to_f77_int (dimy(1));
+  F77_INT m = octave::to_f77_int (dimx(0));
+  F77_INT k = octave::to_f77_int (dimx(1));
+  F77_INT n = octave::to_f77_int (dimy(1));
   octave_idx_type tmp_np = 1;
   bool match = dimy(0) == k && nd == dimy.ndims ();
   dim_vector dimz = dim_vector::alloc (nd);
   dimz(0) = m;
   dimz(1) = n;
   for (int i = 2; match && i < nd; i++)
     {
       match = match && dimx(i) == dimy(i);
       dimz(i) = dimx(i);
       tmp_np *= dimz(i);
     }
-  F77_INT np = to_f77_int (tmp_np);
+  F77_INT np = octave::to_f77_int (tmp_np);
 
   if (! match)
     error ("blkmm: A and B dimensions don't match: (%s) and (%s)",
            dimx.str ().c_str (), dimy.str ().c_str ());
 
   if (argx.is_complex_type () || argy.is_complex_type ())
     {
       if (argx.is_single_type () || argy.is_single_type ())
diff --git a/libinterp/corefcn/ordschur.cc b/libinterp/corefcn/ordschur.cc
--- a/libinterp/corefcn/ordschur.cc
+++ b/libinterp/corefcn/ordschur.cc
@@ -109,20 +109,20 @@ is in the upper left corner, by doing:
   TYPE_COND cond1, cond2;
 
 #define PREPARE_OUTPUT()                        \
   if (info != 0)                                \
     error ("ordschur: trsen failed");           \
                                                 \
   retval = ovl (U, S);
 
-  F77_INT n = to_f77_int (sel_n);
+  F77_INT n = octave::to_f77_int (sel_n);
   Array<F77_INT> sel (dim_vector (n, 1));
   for (F77_INT i = 0; i < n; i++)
-    sel.xelem (i) = to_f77_int (sel_arg.xelem (i));
+    sel.xelem (i) = octave::to_f77_int (sel_arg.xelem (i));
 
   if (double_type)
     {
       if (complex_type)
         {
           PREPARE_ARGS (Complex, complex_matrix, double)
 
           F77_XFCN (ztrsen, ztrsen,
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -280,18 +280,18 @@ compatibility with @sc{matlab}.
         }
     }
 
 #if defined (DEBUG)
   std::cout << "qz: check argument 1" << std::endl;
 #endif
 
   // Argument 1: check if it's okay dimensioned.
-  F77_INT nn = to_f77_int (args(0).rows ());
-  F77_INT nc = to_f77_int (args(0).columns ());
+  F77_INT nn = octave::to_f77_int (args(0).rows ());
+  F77_INT nc = octave::to_f77_int (args(0).columns ());
 
 #if defined (DEBUG)
   std::cout << "argument 1 dimensions: ("
             << nn << "," << nc << ")"
             << std::endl;
 #endif
 
   octave_value_list retval;
@@ -313,18 +313,18 @@ compatibility with @sc{matlab}.
   else
     aa = args(0).matrix_value ();
 
 #if defined (DEBUG)
   std::cout << "qz: check argument 2" << std::endl;
 #endif
 
   // Extract argument 2 (bb, or cbb if complex).
-  F77_INT b_nr = to_f77_int (args(1).rows ());
-  F77_INT b_nc = to_f77_int (args(1).columns ());
+  F77_INT b_nr = octave::to_f77_int (args(1).rows ());
+  F77_INT b_nc = octave::to_f77_int (args(1).columns ());
 
   if (nn != b_nc || nn != b_nr)
     err_nonconformant ();
 
   Matrix bb;
   ComplexMatrix cbb;
 
   if (args(1).is_complex_type ())
diff --git a/liboctave/array/CColVector.cc b/liboctave/array/CColVector.cc
--- a/liboctave/array/CColVector.cc
+++ b/liboctave/array/CColVector.cc
@@ -295,20 +295,20 @@ operator * (const ComplexMatrix& m, cons
   return m * tmp;
 }
 
 ComplexColumnVector
 operator * (const ComplexMatrix& m, const ComplexColumnVector& a)
 {
   ComplexColumnVector retval;
 
-  F77_INT nr = to_f77_int (m.rows ());
-  F77_INT nc = to_f77_int (m.cols ());
+  F77_INT nr = octave::to_f77_int (m.rows ());
+  F77_INT nc = octave::to_f77_int (m.cols ());
 
-  F77_INT a_len = to_f77_int (a.numel ());
+  F77_INT a_len = octave::to_f77_int (a.numel ());
 
   if (nc != a_len)
     octave::err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   retval.clear (nr);
 
   if (nr != 0)
     {
@@ -339,20 +339,20 @@ operator * (const Matrix& m, const Compl
   return tmp * a;
 }
 
 // diagonal matrix by column vector -> column vector operations
 
 ComplexColumnVector
 operator * (const DiagMatrix& m, const ComplexColumnVector& a)
 {
-  F77_INT nr = to_f77_int (m.rows ());
-  F77_INT nc = to_f77_int (m.cols ());
+  F77_INT nr = octave::to_f77_int (m.rows ());
+  F77_INT nc = octave::to_f77_int (m.cols ());
 
-  F77_INT a_len = to_f77_int (a.numel ());
+  F77_INT a_len = octave::to_f77_int (a.numel ());
 
   if (nc != a_len)
     octave::err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
   ComplexColumnVector result (nr);
@@ -364,20 +364,20 @@ operator * (const DiagMatrix& m, const C
     result.elem (i) = 0.0;
 
   return result;
 }
 
 ComplexColumnVector
 operator * (const ComplexDiagMatrix& m, const ColumnVector& a)
 {
-  F77_INT nr = to_f77_int (m.rows ());
-  F77_INT nc = to_f77_int (m.cols ());
+  F77_INT nr = octave::to_f77_int (m.rows ());
+  F77_INT nc = octave::to_f77_int (m.cols ());
 
-  F77_INT a_len = to_f77_int (a.numel ());
+  F77_INT a_len = octave::to_f77_int (a.numel ());
 
   if (nc != a_len)
     octave::err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
   ComplexColumnVector result (nr);
@@ -389,20 +389,20 @@ operator * (const ComplexDiagMatrix& m, 
     result.elem (i) = 0.0;
 
   return result;
 }
 
 ComplexColumnVector
 operator * (const ComplexDiagMatrix& m, const ComplexColumnVector& a)
 {
-  F77_INT nr = to_f77_int (m.rows ());
-  F77_INT nc = to_f77_int (m.cols ());
+  F77_INT nr = octave::to_f77_int (m.rows ());
+  F77_INT nc = octave::to_f77_int (m.cols ());
 
-  F77_INT a_len = to_f77_int (a.numel ());
+  F77_INT a_len = octave::to_f77_int (a.numel ());
 
   if (nc != a_len)
     octave::err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
   ComplexColumnVector result (nr);
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -754,18 +754,18 @@ ComplexMatrix::inverse (MatrixType &matt
 }
 
 ComplexMatrix
 ComplexMatrix::tinverse (MatrixType &mattype, octave_idx_type& info,
                          double& rcon, bool force, bool calc_cond) const
 {
   ComplexMatrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
 
   int typ = mattype.type ();
   char uplo = (typ == MatrixType::Lower ? 'L' : 'U');
   char udiag = 'N';
   retval = *this;
@@ -813,18 +813,18 @@ ComplexMatrix::tinverse (MatrixType &mat
 }
 
 ComplexMatrix
 ComplexMatrix::finverse (MatrixType &mattype, octave_idx_type& info,
                          double& rcon, bool force, bool calc_cond) const
 {
   ComplexMatrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
 
   Array<F77_INT> ipvt (dim_vector (nr, 1));
   F77_INT *pipvt = ipvt.fortran_vec ();
 
   retval = *this;
@@ -1093,22 +1093,22 @@ ComplexMatrix::fourier (void) const
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nsamples;
 
   F77_INT npts;
 
   if (nr == 1 || nc == 1)
     {
-      npts = to_f77_int (nr > nc ? nr : nc);
+      npts = octave::to_f77_int (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
-      npts = to_f77_int (nr);
+      npts = octave::to_f77_int (nr);
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
   Array<Complex> wsave (dim_vector (nn, 1));
   Complex *pwsave = wsave.fortran_vec ();
 
@@ -1136,22 +1136,22 @@ ComplexMatrix::ifourier (void) const
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nsamples;
 
   F77_INT npts;
 
   if (nr == 1 || nc == 1)
     {
-      npts = to_f77_int (nr > nc ? nr : nc);
+      npts = octave::to_f77_int (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
-      npts = to_f77_int (nr);
+      npts = octave::to_f77_int (nr);
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
   Array<Complex> wsave (dim_vector (nn, 1));
   Complex *pwsave = wsave.fortran_vec ();
 
@@ -1174,18 +1174,18 @@ ComplexMatrix::ifourier (void) const
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::fourier2d (void) const
 {
   ComplexMatrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
 
   F77_INT npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
@@ -1242,18 +1242,18 @@ ComplexMatrix::fourier2d (void) const
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::ifourier2d (void) const
 {
   ComplexMatrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
 
   F77_INT npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
@@ -1343,18 +1343,18 @@ ComplexMatrix::determinant (MatrixType& 
                             octave_idx_type& info, double& rcon,
                             bool calc_cond) const
 {
   ComplexDET retval (1.0);
 
   info = 0;
   rcon = 0.0;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
 
   volatile int typ = mattype.type ();
 
   // Even though the matrix is marked as singular (Rectangular), we may
   // still get a useful number from the LU factorization, because it always
@@ -1496,18 +1496,18 @@ ComplexMatrix::rcond (void) const
   MatrixType mattype (*this);
   return rcond (mattype);
 }
 
 double
 ComplexMatrix::rcond (MatrixType &mattype) const
 {
   double rcon = octave::numeric_limits<double>::NaN ();
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
 
   if (nr == 0 || nc == 0)
     rcon = octave::numeric_limits<double>::Inf ();
   else
     {
@@ -1670,21 +1670,21 @@ ComplexMatrix::rcond (MatrixType &mattyp
 ComplexMatrix
 ComplexMatrix::utsolve (MatrixType &mattype, const ComplexMatrix& b,
                         octave_idx_type& info, double& rcon,
                         solve_singularity_handler sing_handler,
                         bool calc_cond, blas_trans_type transt) const
 {
   ComplexMatrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
-
-  F77_INT b_nr = to_f77_int (b.rows ());
-  F77_INT b_nc = to_f77_int (b.cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
+
+  F77_INT b_nr = octave::to_f77_int (b.rows ());
+  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
   if (nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (nr == 0 || nc == 0 || b_nc == 0)
     retval = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else
@@ -1768,21 +1768,21 @@ ComplexMatrix::utsolve (MatrixType &matt
 ComplexMatrix
 ComplexMatrix::ltsolve (MatrixType &mattype, const ComplexMatrix& b,
                         octave_idx_type& info, double& rcon,
                         solve_singularity_handler sing_handler,
                         bool calc_cond, blas_trans_type transt) const
 {
   ComplexMatrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
-
-  F77_INT b_nr = to_f77_int (b.rows ());
-  F77_INT b_nc = to_f77_int (b.cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
+
+  F77_INT b_nr = octave::to_f77_int (b.rows ());
+  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
   if (nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (nr == 0 || nc == 0 || b_nc == 0)
     retval = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else
@@ -1866,21 +1866,21 @@ ComplexMatrix::ltsolve (MatrixType &matt
 ComplexMatrix
 ComplexMatrix::fsolve (MatrixType &mattype, const ComplexMatrix& b,
                        octave_idx_type& info, double& rcon,
                        solve_singularity_handler sing_handler,
                        bool calc_cond) const
 {
   ComplexMatrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
-
-  F77_INT b_nr = to_f77_int (b.rows ());
-  F77_INT b_nc = to_f77_int (b.cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
+
+  F77_INT b_nr = octave::to_f77_int (b.rows ());
+  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
   if (nr != nc || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (nr == 0 || b_nc == 0)
     retval = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else
@@ -2418,23 +2418,23 @@ ComplexMatrix::lssolve (const ComplexMat
 }
 
 ComplexMatrix
 ComplexMatrix::lssolve (const ComplexMatrix& b, octave_idx_type& info,
                         octave_idx_type& rank, double& rcon) const
 {
   ComplexMatrix retval;
 
-  F77_INT nrhs = to_f77_int (b.cols ());
-
-  F77_INT m = to_f77_int (rows ());
-  F77_INT n = to_f77_int (cols ());
-
-  F77_INT b_nr = to_f77_int (b.rows ());
-  F77_INT b_nc = to_f77_int (b.cols ());
+  F77_INT nrhs = octave::to_f77_int (b.cols ());
+
+  F77_INT m = octave::to_f77_int (rows ());
+  F77_INT n = octave::to_f77_int (cols ());
+
+  F77_INT b_nr = octave::to_f77_int (b.rows ());
+  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
   if (m != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (m == 0 || n == 0 || b_nc == 0)
     retval = ComplexMatrix (n, b_nc, Complex (0.0, 0.0));
   else
@@ -2644,20 +2644,20 @@ ComplexMatrix::lssolve (const ComplexCol
 ComplexColumnVector
 ComplexMatrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info,
                         octave_idx_type& rank, double& rcon) const
 {
   ComplexColumnVector retval;
 
   F77_INT nrhs = 1;
 
-  F77_INT m = to_f77_int (rows ());
-  F77_INT n = to_f77_int (cols ());
-
-  F77_INT b_nel = to_f77_int (b.numel ());
+  F77_INT m = octave::to_f77_int (rows ());
+  F77_INT n = octave::to_f77_int (cols ());
+
+  F77_INT b_nel = octave::to_f77_int (b.numel ());
 
   if (m != b_nel)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (m == 0 || n == 0)
     retval = ComplexColumnVector (n, Complex (0.0, 0.0));
   else
@@ -2774,21 +2774,21 @@ operator * (const ComplexColumnVector& a
   return a * tmp;
 }
 
 ComplexMatrix
 operator * (const ComplexColumnVector& v, const ComplexRowVector& a)
 {
   ComplexMatrix retval;
 
-  F77_INT len = to_f77_int (v.numel ());
+  F77_INT len = octave::to_f77_int (v.numel ());
 
   if (len != 0)
     {
-      F77_INT a_len = to_f77_int (a.numel ());
+      F77_INT a_len = octave::to_f77_int (a.numel ());
 
       retval = ComplexMatrix (len, a_len);
       Complex *c = retval.fortran_vec ();
 
       F77_XFCN (zgemm, ZGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 ("N", 1),
                                len, a_len, 1, 1.0, F77_CONST_DBLE_CMPLX_ARG (v.data ()), len,
                                F77_CONST_DBLE_CMPLX_ARG (a.data ()), 1, 0.0, F77_DBLE_CMPLX_ARG (c), len
@@ -3405,18 +3405,18 @@ Sylvester (const ComplexMatrix& a, const
 
   ComplexMatrix ub = bs.unitary_matrix ();
   ComplexMatrix sch_b = bs.schur_matrix ();
 
   ComplexMatrix cx = ua.hermitian () * c * ub;
 
   // Solve the sylvester equation, back-transform, and return the solution.
 
-  F77_INT a_nr = to_f77_int (a.rows ());
-  F77_INT b_nr = to_f77_int (b.rows ());
+  F77_INT a_nr = octave::to_f77_int (a.rows ());
+  F77_INT b_nr = octave::to_f77_int (b.rows ());
 
   double scale;
   F77_INT info;
 
   Complex *pa = sch_a.fortran_vec ();
   Complex *pb = sch_b.fortran_vec ();
   Complex *px = cx.fortran_vec ();
 
@@ -3489,30 +3489,30 @@ xgemm (const ComplexMatrix& a, const Com
 {
   ComplexMatrix retval;
 
   bool tra = transa != blas_no_trans;
   bool trb = transb != blas_no_trans;
   bool cja = transa == blas_conj_trans;
   bool cjb = transb == blas_conj_trans;
 
-  F77_INT a_nr = to_f77_int (tra ? a.cols () : a.rows ());
-  F77_INT a_nc = to_f77_int (tra ? a.rows () : a.cols ());
-
-  F77_INT b_nr = to_f77_int (trb ? b.cols () : b.rows ());
-  F77_INT b_nc = to_f77_int (trb ? b.rows () : b.cols ());
+  F77_INT a_nr = octave::to_f77_int (tra ? a.cols () : a.rows ());
+  F77_INT a_nc = octave::to_f77_int (tra ? a.rows () : a.cols ());
+
+  F77_INT b_nr = octave::to_f77_int (trb ? b.cols () : b.rows ());
+  F77_INT b_nc = octave::to_f77_int (trb ? b.rows () : b.cols ());
 
   if (a_nc != b_nr)
     octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     retval = ComplexMatrix (a_nr, b_nc, 0.0);
   else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
     {
-      F77_INT lda = to_f77_int (a.rows ());
+      F77_INT lda = octave::to_f77_int (a.rows ());
 
       // FIXME: looking at the reference BLAS, it appears that it
       // should not be necessary to initialize the output matrix if
       // BETA is 0 in the call to ZHERK, but ATLAS appears to
       // use the result matrix before zeroing the elements.
 
       retval = ComplexMatrix (a_nr, b_nc, 0.0);
       Complex *c = retval.fortran_vec ();
@@ -3542,20 +3542,20 @@ xgemm (const ComplexMatrix& a, const Com
             for (F77_INT i = 0; i < j; i++)
               retval.xelem (j,i) = retval.xelem (i,j);
 
         }
 
     }
   else
     {
-      F77_INT lda = to_f77_int (a.rows ());
-      F77_INT tda = to_f77_int (a.cols ());
-      F77_INT ldb = to_f77_int (b.rows ());
-      F77_INT tdb = to_f77_int (b.cols ());
+      F77_INT lda = octave::to_f77_int (a.rows ());
+      F77_INT tda = octave::to_f77_int (a.cols ());
+      F77_INT ldb = octave::to_f77_int (b.rows ());
+      F77_INT tdb = octave::to_f77_int (b.cols ());
 
       retval = ComplexMatrix (a_nr, b_nc, 0.0);
       Complex *c = retval.fortran_vec ();
 
       if (b_nc == 1 && a_nr == 1)
         {
           if (cja == cjb)
             {
diff --git a/liboctave/array/CRowVector.cc b/liboctave/array/CRowVector.cc
--- a/liboctave/array/CRowVector.cc
+++ b/liboctave/array/CRowVector.cc
@@ -277,20 +277,20 @@ ComplexRowVector::operator -= (const Row
 
 // row vector by matrix -> row vector
 
 ComplexRowVector
 operator * (const ComplexRowVector& v, const ComplexMatrix& a)
 {
   ComplexRowVector retval;
 
-  F77_INT len = to_f77_int (v.numel ());
+  F77_INT len = octave::to_f77_int (v.numel ());
 
-  F77_INT a_nr = to_f77_int (a.rows ());
-  F77_INT a_nc = to_f77_int (a.cols ());
+  F77_INT a_nr = octave::to_f77_int (a.rows ());
+  F77_INT a_nc = octave::to_f77_int (a.cols ());
 
   if (a_nr != len)
     octave::err_nonconformant ("operator *", 1, len, a_nr, a_nc);
 
   if (len == 0)
     retval.resize (a_nc, 0.0);
   else
     {
@@ -401,19 +401,19 @@ operator * (const ComplexRowVector& v, c
   return v * tmp;
 }
 
 Complex
 operator * (const ComplexRowVector& v, const ComplexColumnVector& a)
 {
   Complex retval (0.0, 0.0);
 
-  F77_INT len = to_f77_int (v.numel ());
+  F77_INT len = octave::to_f77_int (v.numel ());
 
-  F77_INT a_len = to_f77_int (a.numel ());
+  F77_INT a_len = octave::to_f77_int (a.numel ());
 
   if (len != a_len)
     octave::err_nonconformant ("operator *", len, a_len);
   if (len != 0)
     F77_FUNC (xzdotu, XZDOTU) (len, F77_CONST_DBLE_CMPLX_ARG (v.data ()), 1,
                                F77_CONST_DBLE_CMPLX_ARG (a.data ()), 1, F77_DBLE_CMPLX_ARG (&retval));
 
   return retval;
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -3678,23 +3678,23 @@ SparseComplexMatrix::trisolve (MatrixTyp
                   {
                     if (ridx (i) == j)
                       D[j] = octave::math::real (data (i));
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                   }
             }
 
-          F77_INT b_nr = to_f77_int (b.rows ());
-          F77_INT b_nc = to_f77_int (b.cols ());
+          F77_INT b_nr = octave::to_f77_int (b.rows ());
+          F77_INT b_nc = octave::to_f77_int (b.cols ());
 
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
-          F77_INT tmp_nr = to_f77_int (nr);
+          F77_INT tmp_nr = octave::to_f77_int (nr);
 
           F77_INT tmp_err = 0;
 
           F77_XFCN (zptsv, ZPTSV, (tmp_nr, b_nc, D, F77_DBLE_CMPLX_ARG (DL),
                                    F77_DBLE_CMPLX_ARG (result),
                                    b_nr, tmp_err));
 
           err = tmp_err;
@@ -3744,23 +3744,23 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       D[j] = data (i);
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                     else if (ridx (i) == j - 1)
                       DU[j-1] = data (i);
                   }
             }
 
-          F77_INT b_nr = to_f77_int (b.rows ());
-          F77_INT b_nc = to_f77_int (b.cols ());
+          F77_INT b_nr = octave::to_f77_int (b.rows ());
+          F77_INT b_nc = octave::to_f77_int (b.cols ());
 
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
-          F77_INT tmp_nr = to_f77_int (nr);
+          F77_INT tmp_nr = octave::to_f77_int (nr);
 
           F77_INT tmp_err = 0;
 
           F77_XFCN (zgtsv, ZGTSV, (tmp_nr, b_nc, F77_DBLE_CMPLX_ARG (DL),
                                    F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (result),
                                    b_nr, tmp_err));
 
           err = tmp_err;
@@ -3856,17 +3856,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       D[j] = data (i);
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                     else if (ridx (i) == j - 1)
                       DU[j-1] = data (i);
                   }
             }
 
-          F77_INT tmp_nr = to_f77_int (nr);
+          F77_INT tmp_nr = octave::to_f77_int (nr);
 
           F77_INT tmp_err = 0;
 
           F77_XFCN (zgttrf, ZGTTRF, (tmp_nr, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D),
                                      F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (DU2), pipvt, tmp_err));
 
           err = tmp_err;
 
@@ -3882,17 +3882,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
                 }
               else
                 octave::warn_singular_matrix ();
             }
           else
             {
               char job = 'N';
               volatile octave_idx_type x_nz = b.nnz ();
-              F77_INT b_nr = to_f77_int (b.rows ());
+              F77_INT b_nr = octave::to_f77_int (b.rows ());
               octave_idx_type b_nc = b.cols ();
               retval = SparseComplexMatrix (nr, b_nc, x_nz);
               retval.xcidx (0) = 0;
               volatile octave_idx_type ii = 0;
               rcond = 1.0;
 
               OCTAVE_LOCAL_BUFFER (Complex, work, nr);
 
@@ -4004,25 +4004,25 @@ SparseComplexMatrix::trisolve (MatrixTyp
                   {
                     if (ridx (i) == j)
                       D[j] = octave::math::real (data (i));
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                   }
             }
 
-          F77_INT b_nr = to_f77_int (b.rows ());
-          F77_INT b_nc = to_f77_int (b.cols ());
+          F77_INT b_nr = octave::to_f77_int (b.rows ());
+          F77_INT b_nc = octave::to_f77_int (b.cols ());
 
           rcond = 1.;
 
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
-          F77_INT tmp_nr = to_f77_int (nr);
+          F77_INT tmp_nr = octave::to_f77_int (nr);
 
           F77_INT tmp_err = 0;
 
           F77_XFCN (zptsv, ZPTSV, (tmp_nr, b_nc, D, F77_DBLE_CMPLX_ARG (DL),
                                    F77_DBLE_CMPLX_ARG (result),
                                    b_nr, tmp_err));
 
           err = tmp_err;
@@ -4070,25 +4070,25 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       D[j] = data (i);
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                     else if (ridx (i) == j - 1)
                       DU[j-1] = data (i);
                   }
             }
 
-          F77_INT b_nr = to_f77_int (b.rows ());
-          F77_INT b_nc = to_f77_int (b.cols ());
+          F77_INT b_nr = octave::to_f77_int (b.rows ());
+          F77_INT b_nc = octave::to_f77_int (b.cols ());
 
           rcond = 1.;
 
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
-          F77_INT tmp_nr = to_f77_int (nr);
+          F77_INT tmp_nr = octave::to_f77_int (nr);
 
           F77_INT tmp_err = 0;
 
           F77_XFCN (zgtsv, ZGTSV, (tmp_nr, b_nc, F77_DBLE_CMPLX_ARG (DL),
                                    F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (result),
                                    b_nr, tmp_err));
 
           err = tmp_err;
@@ -4182,17 +4182,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       D[j] = data (i);
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                     else if (ridx (i) == j - 1)
                       DU[j-1] = data (i);
                   }
             }
 
-          F77_INT tmp_nr = to_f77_int (nr);
+          F77_INT tmp_nr = octave::to_f77_int (nr);
 
           F77_INT tmp_err = 0;
 
           F77_XFCN (zgttrf, ZGTTRF, (tmp_nr, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D),
                                      F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (DU2), pipvt, tmp_err));
 
           err = tmp_err;
 
@@ -4208,17 +4208,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
                 }
               else
                 octave::warn_singular_matrix ();
             }
           else
             {
               rcond = 1.;
               char job = 'N';
-              F77_INT b_nr = to_f77_int (b.rows ());
+              F77_INT b_nr = octave::to_f77_int (b.rows ());
               octave_idx_type b_nc = b.cols ();
               OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
               // Take a first guess that the number of nonzero terms
               // will be as many as in b
               volatile octave_idx_type x_nz = b.nnz ();
               volatile octave_idx_type ii = 0;
               retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
@@ -4306,17 +4306,17 @@ SparseComplexMatrix::bsolve (MatrixType 
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
         {
-          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT n_lower = octave::to_f77_int (mattype.nlower ());
           F77_INT ldm = n_lower + 1;
           ComplexMatrix m_band (ldm, nc);
           Complex *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
@@ -4333,17 +4333,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             anorm = m_band.abs ().sum ().row (0).max ();
 
-          F77_INT tmp_nr = to_f77_int (nr);
+          F77_INT tmp_nr = octave::to_f77_int (nr);
 
           F77_INT tmp_err = 0;
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      tmp_nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm, tmp_err
                                      F77_CHAR_ARG_LEN (1)));
 
@@ -4396,18 +4396,18 @@ SparseComplexMatrix::bsolve (MatrixType 
               else
                 rcond = 1.0;
 
               if (err == 0)
                 {
                   retval = ComplexMatrix (b);
                   Complex *result = retval.fortran_vec ();
 
-                  F77_INT b_nr = to_f77_int (b.rows ());
-                  F77_INT b_nc = to_f77_int (b.cols ());
+                  F77_INT b_nr = octave::to_f77_int (b.rows ());
+                  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
                   F77_XFCN (zpbtrs, ZPBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              tmp_nr, n_lower, b_nc, F77_DBLE_CMPLX_ARG (tmp_data),
                              ldm, F77_DBLE_CMPLX_ARG (result), b_nr, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
                   err = tmp_err;
@@ -4421,18 +4421,18 @@ SparseComplexMatrix::bsolve (MatrixType 
                     }
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
         {
           // Create the storage for the banded form of the sparse matrix
-          F77_INT n_upper = to_f77_int (mattype.nupper ());
-          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT n_upper = octave::to_f77_int (mattype.nupper ());
+          F77_INT n_lower = octave::to_f77_int (mattype.nlower ());
           F77_INT ldm = n_upper + 2 * n_lower + 1;
 
           ComplexMatrix m_band (ldm, nc);
           Complex *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
@@ -4458,17 +4458,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<F77_INT> ipvt (dim_vector (nr, 1));
           F77_INT *pipvt = ipvt.fortran_vec ();
 
-          F77_INT tmp_nr = to_f77_int (nr);
+          F77_INT tmp_nr = octave::to_f77_int (nr);
 
           F77_INT tmp_err = 0;
 
           F77_XFCN (zgbtrf, ZGBTRF, (tmp_nr, tmp_nr, n_lower, n_upper,
                                      F77_DBLE_CMPLX_ARG (tmp_data),
                                      ldm, pipvt, tmp_err));
 
           err = tmp_err;
@@ -4493,17 +4493,17 @@ SparseComplexMatrix::bsolve (MatrixType 
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
-                  F77_INT tmp_nc = to_f77_int (nc);
+                  F77_INT tmp_nc = octave::to_f77_int (nc);
 
                   F77_XFCN (zgbcon, ZGBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              tmp_nc, n_lower, n_upper, F77_DBLE_CMPLX_ARG (tmp_data), ldm, pipvt,
                              anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
                   err = tmp_err;
@@ -4529,18 +4529,18 @@ SparseComplexMatrix::bsolve (MatrixType 
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   retval = ComplexMatrix (b);
                   Complex *result = retval.fortran_vec ();
 
-                  F77_INT b_nr = to_f77_int (b.rows ());
-                  F77_INT b_nc = to_f77_int (b.cols ());
+                  F77_INT b_nr = octave::to_f77_int (b.rows ());
+                  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
                   char job = 'N';
                   F77_XFCN (zgbtrs, ZGBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              tmp_nr, n_lower, n_upper, b_nc, F77_DBLE_CMPLX_ARG (tmp_data),
                              ldm, pipvt, F77_DBLE_CMPLX_ARG (result), b_nr, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
@@ -4576,17 +4576,17 @@ SparseComplexMatrix::bsolve (MatrixType 
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
         {
-          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT n_lower = octave::to_f77_int (mattype.nlower ());
           F77_INT ldm = n_lower + 1;
 
           ComplexMatrix m_band (ldm, nc);
           Complex *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
@@ -4604,17 +4604,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             anorm = m_band.abs ().sum ().row (0).max ();
 
-          F77_INT tmp_nr = to_f77_int (nr);
+          F77_INT tmp_nr = octave::to_f77_int (nr);
 
           F77_INT tmp_err = 0;
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      tmp_nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm, tmp_err
                                      F77_CHAR_ARG_LEN (1)));
 
@@ -4662,17 +4662,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                         octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.0;
 
               if (err == 0)
                 {
-                  F77_INT b_nr = to_f77_int (b.rows ());
+                  F77_INT b_nr = octave::to_f77_int (b.rows ());
                   octave_idx_type b_nc = b.cols ();
                   OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
                   // Take a first guess that the number of nonzero terms
                   // will be as many as in b
                   volatile octave_idx_type x_nz = b.nnz ();
                   volatile octave_idx_type ii = 0;
                   retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
@@ -4724,18 +4724,18 @@ SparseComplexMatrix::bsolve (MatrixType 
                   retval.maybe_compress ();
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
         {
           // Create the storage for the banded form of the sparse matrix
-          F77_INT n_upper = to_f77_int (mattype.nupper ());
-          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT n_upper = octave::to_f77_int (mattype.nupper ());
+          F77_INT n_lower = octave::to_f77_int (mattype.nlower ());
           F77_INT ldm = n_upper + 2 * n_lower + 1;
 
           ComplexMatrix m_band (ldm, nc);
           Complex *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
@@ -4761,17 +4761,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<F77_INT> ipvt (dim_vector (nr, 1));
           F77_INT *pipvt = ipvt.fortran_vec ();
 
-          F77_INT tmp_nr = to_f77_int (nr);
+          F77_INT tmp_nr = octave::to_f77_int (nr);
 
           F77_INT tmp_err = 0;
 
           F77_XFCN (zgbtrf, ZGBTRF, (tmp_nr, tmp_nr, n_lower, n_upper,
                                      F77_DBLE_CMPLX_ARG (tmp_data),
                                      ldm, pipvt, tmp_err));
 
           err = tmp_err;
@@ -4794,17 +4794,17 @@ SparseComplexMatrix::bsolve (MatrixType 
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
-                  F77_INT tmp_nc = to_f77_int (nc);
+                  F77_INT tmp_nc = octave::to_f77_int (nc);
 
                   F77_XFCN (zgbcon, ZGBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              tmp_nc, n_lower, n_upper, F77_DBLE_CMPLX_ARG (tmp_data), ldm, pipvt,
                              anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
                   err = tmp_err;
@@ -4829,17 +4829,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
                   volatile octave_idx_type x_nz = b.nnz ();
-                  F77_INT b_nr = to_f77_int (b.rows ());
+                  F77_INT b_nr = octave::to_f77_int (b.rows ());
                   octave_idx_type b_nc = b.cols ();
                   retval = SparseComplexMatrix (nr, b_nc, x_nz);
                   retval.xcidx (0) = 0;
                   volatile octave_idx_type ii = 0;
 
                   OCTAVE_LOCAL_BUFFER (Complex, work, nr);
 
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
@@ -4914,17 +4914,17 @@ SparseComplexMatrix::bsolve (MatrixType 
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
         {
-          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT n_lower = octave::to_f77_int (mattype.nlower ());
           F77_INT ldm = n_lower + 1;
 
           ComplexMatrix m_band (ldm, nc);
           Complex *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
@@ -4942,17 +4942,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             anorm = m_band.abs ().sum ().row (0).max ();
 
-          F77_INT tmp_nr = to_f77_int (nr);
+          F77_INT tmp_nr = octave::to_f77_int (nr);
 
           F77_INT tmp_err = 0;
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      tmp_nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm, tmp_err
                                      F77_CHAR_ARG_LEN (1)));
 
@@ -5002,18 +5002,18 @@ SparseComplexMatrix::bsolve (MatrixType 
                         octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.0;
 
               if (err == 0)
                 {
-                  F77_INT b_nr = to_f77_int (b.rows ());
-                  F77_INT b_nc = to_f77_int (b.cols ());
+                  F77_INT b_nr = octave::to_f77_int (b.rows ());
+                  F77_INT b_nc = octave::to_f77_int (b.cols ());
                   retval = ComplexMatrix (b);
                   Complex *result = retval.fortran_vec ();
 
                   F77_XFCN (zpbtrs, ZPBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              tmp_nr, n_lower, b_nc, F77_DBLE_CMPLX_ARG (tmp_data),
                              ldm, F77_DBLE_CMPLX_ARG (result), b_nr, tmp_err
                              F77_CHAR_ARG_LEN (1)));
@@ -5029,18 +5029,18 @@ SparseComplexMatrix::bsolve (MatrixType 
                     }
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
         {
           // Create the storage for the banded form of the sparse matrix
-          F77_INT n_upper = to_f77_int (mattype.nupper ());
-          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT n_upper = octave::to_f77_int (mattype.nupper ());
+          F77_INT n_lower = octave::to_f77_int (mattype.nlower ());
           F77_INT ldm = n_upper + 2 * n_lower + 1;
 
           ComplexMatrix m_band (ldm, nc);
           Complex *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
@@ -5066,17 +5066,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<F77_INT> ipvt (dim_vector (nr, 1));
           F77_INT *pipvt = ipvt.fortran_vec ();
 
-          F77_INT tmp_nr = to_f77_int (nr);
+          F77_INT tmp_nr = octave::to_f77_int (nr);
 
           F77_INT tmp_err = 0;
 
           F77_XFCN (zgbtrf, ZGBTRF, (tmp_nr, tmp_nr, n_lower, n_upper,
                                      F77_DBLE_CMPLX_ARG (tmp_data),
                                      ldm, pipvt, tmp_err));
 
           err = tmp_err;
@@ -5099,17 +5099,17 @@ SparseComplexMatrix::bsolve (MatrixType 
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
-                  F77_INT tmp_nc = to_f77_int (nc);
+                  F77_INT tmp_nc = octave::to_f77_int (nc);
 
                   F77_XFCN (zgbcon, ZGBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              tmp_nc, n_lower, n_upper, F77_DBLE_CMPLX_ARG (tmp_data), ldm, pipvt,
                              anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
                   err = tmp_err;
@@ -5133,18 +5133,18 @@ SparseComplexMatrix::bsolve (MatrixType 
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
-                  F77_INT b_nr = to_f77_int (b.rows ());
-                  F77_INT b_nc = to_f77_int (b.cols ());
+                  F77_INT b_nr = octave::to_f77_int (b.rows ());
+                  F77_INT b_nc = octave::to_f77_int (b.cols ());
                   retval = ComplexMatrix (b);
                   Complex *result = retval.fortran_vec ();
 
                   F77_XFCN (zgbtrs, ZGBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              tmp_nr, n_lower, n_upper, b_nc, F77_DBLE_CMPLX_ARG (tmp_data),
                              ldm, pipvt, F77_DBLE_CMPLX_ARG (result), b_nr, tmp_err
                              F77_CHAR_ARG_LEN (1)));
@@ -5181,17 +5181,17 @@ SparseComplexMatrix::bsolve (MatrixType 
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
         {
-          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT n_lower = octave::to_f77_int (mattype.nlower ());
           F77_INT ldm = n_lower + 1;
 
           ComplexMatrix m_band (ldm, nc);
           Complex *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
@@ -5209,17 +5209,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             anorm = m_band.abs ().sum ().row (0).max ();
 
-          F77_INT tmp_nr = to_f77_int (nr);
+          F77_INT tmp_nr = octave::to_f77_int (nr);
 
           F77_INT tmp_err = 0;
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      tmp_nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm, tmp_err
                                      F77_CHAR_ARG_LEN (1)));
 
@@ -5270,17 +5270,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                         octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.0;
 
               if (err == 0)
                 {
-                  F77_INT b_nr = to_f77_int (b.rows ());
+                  F77_INT b_nr = octave::to_f77_int (b.rows ());
                   octave_idx_type b_nc = b.cols ();
                   OCTAVE_LOCAL_BUFFER (Complex, Bx, b_nr);
 
                   // Take a first guess that the number of nonzero terms
                   // will be as many as in b
                   volatile octave_idx_type x_nz = b.nnz ();
                   volatile octave_idx_type ii = 0;
                   retval = SparseComplexMatrix (b_nr, b_nc, x_nz);
@@ -5337,18 +5337,18 @@ SparseComplexMatrix::bsolve (MatrixType 
                   retval.maybe_compress ();
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
         {
           // Create the storage for the banded form of the sparse matrix
-          F77_INT n_upper = to_f77_int (mattype.nupper ());
-          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT n_upper = octave::to_f77_int (mattype.nupper ());
+          F77_INT n_lower = octave::to_f77_int (mattype.nlower ());
           F77_INT ldm = n_upper + 2 * n_lower + 1;
 
           ComplexMatrix m_band (ldm, nc);
           Complex *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
@@ -5374,17 +5374,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<F77_INT> ipvt (dim_vector (nr, 1));
           F77_INT *pipvt = ipvt.fortran_vec ();
 
-          F77_INT tmp_nr = to_f77_int (nr);
+          F77_INT tmp_nr = octave::to_f77_int (nr);
 
           F77_INT tmp_err = 0;
 
           F77_XFCN (zgbtrf, ZGBTRF, (tmp_nr, tmp_nr, n_lower, n_upper,
                                      F77_DBLE_CMPLX_ARG (tmp_data),
                                      ldm, pipvt, tmp_err));
 
           err = tmp_err;
@@ -5407,17 +5407,17 @@ SparseComplexMatrix::bsolve (MatrixType 
               if (calc_cond)
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
-                  F77_INT tmp_nc = to_f77_int (nc);
+                  F77_INT tmp_nc = octave::to_f77_int (nc);
 
                   F77_XFCN (zgbcon, ZGBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              tmp_nc, n_lower, n_upper, F77_DBLE_CMPLX_ARG (tmp_data), ldm, pipvt,
                              anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
                   err = tmp_err;
@@ -5442,17 +5442,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
                   volatile octave_idx_type x_nz = b.nnz ();
-                  F77_INT b_nr = to_f77_int (b.rows ());
+                  F77_INT b_nr = octave::to_f77_int (b.rows ());
                   octave_idx_type b_nc = b.cols ();
                   retval = SparseComplexMatrix (nr, b_nc, x_nz);
                   retval.xcidx (0) = 0;
                   volatile octave_idx_type ii = 0;
 
                   OCTAVE_LOCAL_BUFFER (Complex, Bx, nr);
 
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
diff --git a/liboctave/array/dColVector.cc b/liboctave/array/dColVector.cc
--- a/liboctave/array/dColVector.cc
+++ b/liboctave/array/dColVector.cc
@@ -174,20 +174,20 @@ ColumnVector::extract_n (octave_idx_type
 
 // matrix by column vector -> column vector operations
 
 ColumnVector
 operator * (const Matrix& m, const ColumnVector& a)
 {
   ColumnVector retval;
 
-  F77_INT nr = to_f77_int (m.rows ());
-  F77_INT nc = to_f77_int (m.cols ());
+  F77_INT nr = octave::to_f77_int (m.rows ());
+  F77_INT nc = octave::to_f77_int (m.cols ());
 
-  F77_INT a_len = to_f77_int (a.numel ());
+  F77_INT a_len = octave::to_f77_int (a.numel ());
 
   if (nc != a_len)
     octave::err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   retval.clear (nr);
 
   if (nr != 0)
     {
@@ -209,20 +209,20 @@ operator * (const Matrix& m, const Colum
 
 // diagonal matrix by column vector -> column vector operations
 
 ColumnVector
 operator * (const DiagMatrix& m, const ColumnVector& a)
 {
   ColumnVector retval;
 
-  F77_INT nr = to_f77_int (m.rows ());
-  F77_INT nc = to_f77_int (m.cols ());
+  F77_INT nr = octave::to_f77_int (m.rows ());
+  F77_INT nc = octave::to_f77_int (m.cols ());
 
-  F77_INT a_len = to_f77_int (a.numel ());
+  F77_INT a_len = octave::to_f77_int (a.numel ());
 
   if (nc != a_len)
     octave::err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   if (nr == 0 || nc == 0)
     retval.resize (nr, 0.0);
   else
     {
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -466,18 +466,18 @@ Matrix::inverse (MatrixType &mattype, oc
 }
 
 Matrix
 Matrix::tinverse (MatrixType &mattype, octave_idx_type& info, double& rcon,
                   bool force, bool calc_cond) const
 {
   Matrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
 
   int typ = mattype.type ();
   char uplo = (typ == MatrixType::Lower ? 'L' : 'U');
   char udiag = 'N';
   retval = *this;
@@ -525,18 +525,18 @@ Matrix::tinverse (MatrixType &mattype, o
 }
 
 Matrix
 Matrix::finverse (MatrixType &mattype, octave_idx_type& info, double& rcon,
                   bool force, bool calc_cond) const
 {
   Matrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
 
   Array<F77_INT> ipvt (dim_vector (nr, 1));
   F77_INT *pipvt = ipvt.fortran_vec ();
 
   retval = *this;
@@ -786,22 +786,22 @@ Matrix::fourier (void) const
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nsamples;
 
   F77_INT npts;
 
   if (nr == 1 || nc == 1)
     {
-      npts = to_f77_int (nr > nc ? nr : nc);
+      npts = octave::to_f77_int (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
-      npts = to_f77_int (nr);
+      npts = octave::to_f77_int (nr);
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
   Array<Complex> wsave (dim_vector (nn, 1));
   Complex *pwsave = wsave.fortran_vec ();
 
@@ -829,22 +829,22 @@ Matrix::ifourier (void) const
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nsamples;
 
   F77_INT npts;
 
   if (nr == 1 || nc == 1)
     {
-      npts = to_f77_int (nr > nc ? nr : nc);
+      npts = octave::to_f77_int (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
-      npts = to_f77_int (nr);
+      npts = octave::to_f77_int (nr);
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
   Array<Complex> wsave (dim_vector (nn, 1));
   Complex *pwsave = wsave.fortran_vec ();
 
@@ -867,18 +867,18 @@ Matrix::ifourier (void) const
   return retval;
 }
 
 ComplexMatrix
 Matrix::fourier2d (void) const
 {
   ComplexMatrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
 
   F77_INT npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
@@ -935,18 +935,18 @@ Matrix::fourier2d (void) const
   return retval;
 }
 
 ComplexMatrix
 Matrix::ifourier2d (void) const
 {
   ComplexMatrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
 
   F77_INT npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
@@ -1034,18 +1034,18 @@ DET
 Matrix::determinant (MatrixType& mattype,
                      octave_idx_type& info, double& rcon, bool calc_cond) const
 {
   DET retval (1.0);
 
   info = 0;
   rcon = 0.0;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
 
   volatile int typ = mattype.type ();
 
   // Even though the matrix is marked as singular (Rectangular), we may
   // still get a useful number from the LU factorization, because it always
@@ -1180,18 +1180,18 @@ Matrix::rcond (void) const
   MatrixType mattype (*this);
   return rcond (mattype);
 }
 
 double
 Matrix::rcond (MatrixType &mattype) const
 {
   double rcon = octave::numeric_limits<double>::NaN ();
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
 
   if (nr == 0 || nc == 0)
     rcon = octave::numeric_limits<double>::Inf ();
   else
     {
@@ -1347,21 +1347,21 @@ Matrix::rcond (MatrixType &mattype) cons
 
 Matrix
 Matrix::utsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
                  double& rcon, solve_singularity_handler sing_handler,
                  bool calc_cond, blas_trans_type transt) const
 {
   Matrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
-
-  F77_INT b_nr = to_f77_int (b.rows ());
-  F77_INT b_nc = to_f77_int (b.cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
+
+  F77_INT b_nr = octave::to_f77_int (b.rows ());
+  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
   if (nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (nr == 0 || nc == 0 || b_nc == 0)
     retval = Matrix (nc, b_nc, 0.0);
   else
@@ -1444,21 +1444,21 @@ Matrix::utsolve (MatrixType &mattype, co
 
 Matrix
 Matrix::ltsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
                  double& rcon, solve_singularity_handler sing_handler,
                  bool calc_cond, blas_trans_type transt) const
 {
   Matrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
-
-  F77_INT b_nr = to_f77_int (b.rows ());
-  F77_INT b_nc = to_f77_int (b.cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
+
+  F77_INT b_nr = octave::to_f77_int (b.rows ());
+  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
   if (nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (nr == 0 || nc == 0 || b_nc == 0)
     retval = Matrix (nc, b_nc, 0.0);
   else
@@ -1541,18 +1541,18 @@ Matrix::ltsolve (MatrixType &mattype, co
 
 Matrix
 Matrix::fsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
                 double& rcon, solve_singularity_handler sing_handler,
                 bool calc_cond) const
 {
   Matrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (nr == 0 || b.cols () == 0)
     retval = Matrix (nc, b.cols (), 0.0);
   else
@@ -1621,18 +1621,18 @@ Matrix::fsolve (MatrixType &mattype, con
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   double *result = retval.fortran_vec ();
 
-                  F77_INT b_nr = to_f77_int (b.rows ());
-                  F77_INT b_nc = to_f77_int (b.cols ());
+                  F77_INT b_nr = octave::to_f77_int (b.rows ());
+                  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
                   F77_XFCN (dpotrs, DPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, tmp_data, nr,
                                              result, b_nr, tmp_info
                                              F77_CHAR_ARG_LEN (1)));
 
                   info = tmp_info;
                 }
@@ -1711,18 +1711,18 @@ Matrix::fsolve (MatrixType &mattype, con
                     }
                 }
 
               if (info == 0)
                 {
                   retval = b;
                   double *result = retval.fortran_vec ();
 
-                  F77_INT b_nr = to_f77_int (b.rows ());
-                  F77_INT b_nc = to_f77_int (b.cols ());
+                  F77_INT b_nr = octave::to_f77_int (b.rows ());
+                  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
                   char job = 'N';
                   F77_XFCN (dgetrs, DGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
                                              nr, b_nc, tmp_data, nr,
                                              pipvt, result, b_nr, tmp_info
                                              F77_CHAR_ARG_LEN (1)));
 
                   info = tmp_info;
@@ -2071,23 +2071,23 @@ Matrix::lssolve (const Matrix& b, octave
 }
 
 Matrix
 Matrix::lssolve (const Matrix& b, octave_idx_type& info,
                  octave_idx_type& rank, double &rcon) const
 {
   Matrix retval;
 
-  F77_INT nrhs = to_f77_int (b.cols ());
-
-  F77_INT m = to_f77_int (rows ());
-  F77_INT n = to_f77_int (cols ());
-
-  F77_INT b_nr = to_f77_int (b.rows ());
-  F77_INT b_nc = to_f77_int (b.cols ());
+  F77_INT nrhs = octave::to_f77_int (b.cols ());
+
+  F77_INT m = octave::to_f77_int (rows ());
+  F77_INT n = octave::to_f77_int (cols ());
+
+  F77_INT b_nr = octave::to_f77_int (b.rows ());
+  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
   if (m != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (m == 0 || n == 0 || b_nc == 0)
     retval = Matrix (n, b_nc, 0.0);
   else
@@ -2293,20 +2293,20 @@ Matrix::lssolve (const ColumnVector& b, 
 ColumnVector
 Matrix::lssolve (const ColumnVector& b, octave_idx_type& info,
                  octave_idx_type& rank, double &rcon) const
 {
   ColumnVector retval;
 
   F77_INT nrhs = 1;
 
-  F77_INT m = to_f77_int (rows ());
-  F77_INT n = to_f77_int (cols ());
-
-  F77_INT b_nel = to_f77_int (b.numel ());
+  F77_INT m = octave::to_f77_int (rows ());
+  F77_INT n = octave::to_f77_int (cols ());
+
+  F77_INT b_nel = octave::to_f77_int (b.numel ());
 
   if (m != b_nel)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (m == 0 || n == 0)
     retval = ColumnVector (n, 0.0);
   else
@@ -2471,21 +2471,21 @@ Matrix::operator -= (const DiagMatrix& a
 
 // column vector by row vector -> matrix operations
 
 Matrix
 operator * (const ColumnVector& v, const RowVector& a)
 {
   Matrix retval;
 
-  F77_INT len = to_f77_int (v.numel ());
+  F77_INT len = octave::to_f77_int (v.numel ());
 
   if (len != 0)
     {
-      F77_INT a_len = to_f77_int (a.numel ());
+      F77_INT a_len = octave::to_f77_int (a.numel ());
 
       retval = Matrix (len, a_len);
       double *c = retval.fortran_vec ();
 
       F77_XFCN (dgemm, DGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 ("N", 1),
                                len, a_len, 1, 1.0, v.data (), len,
                                a.data (), 1, 0.0, c, len
@@ -2864,18 +2864,18 @@ Sylvester (const Matrix& a, const Matrix
 
   Matrix ub = bs.unitary_matrix ();
   Matrix sch_b = bs.schur_matrix ();
 
   Matrix cx = ua.transpose () * c * ub;
 
   // Solve the sylvester equation, back-transform, and return the solution.
 
-  F77_INT a_nr = to_f77_int (a.rows ());
-  F77_INT b_nr = to_f77_int (b.rows ());
+  F77_INT a_nr = octave::to_f77_int (a.rows ());
+  F77_INT b_nr = octave::to_f77_int (b.rows ());
 
   double scale;
   F77_INT info;
 
   double *pa = sch_a.fortran_vec ();
   double *pb = sch_b.fortran_vec ();
   double *px = cx.fortran_vec ();
 
@@ -2931,30 +2931,30 @@ Matrix
 xgemm (const Matrix& a, const Matrix& b,
        blas_trans_type transa, blas_trans_type transb)
 {
   Matrix retval;
 
   bool tra = transa != blas_no_trans;
   bool trb = transb != blas_no_trans;
 
-  F77_INT a_nr = to_f77_int (tra ? a.cols () : a.rows ());
-  F77_INT a_nc = to_f77_int (tra ? a.rows () : a.cols ());
-
-  F77_INT b_nr = to_f77_int (trb ? b.cols () : b.rows ());
-  F77_INT b_nc = to_f77_int (trb ? b.rows () : b.cols ());
+  F77_INT a_nr = octave::to_f77_int (tra ? a.cols () : a.rows ());
+  F77_INT a_nc = octave::to_f77_int (tra ? a.rows () : a.cols ());
+
+  F77_INT b_nr = octave::to_f77_int (trb ? b.cols () : b.rows ());
+  F77_INT b_nc = octave::to_f77_int (trb ? b.rows () : b.cols ());
 
   if (a_nc != b_nr)
     octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     retval = Matrix (a_nr, b_nc, 0.0);
   else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
     {
-      F77_INT lda = to_f77_int (a.rows ());
+      F77_INT lda = octave::to_f77_int (a.rows ());
 
       retval = Matrix (a_nr, b_nc);
       double *c = retval.fortran_vec ();
 
       const char ctra = get_blas_trans_arg (tra);
       F77_XFCN (dsyrk, DSYRK, (F77_CONST_CHAR_ARG2 ("U", 1),
                                F77_CONST_CHAR_ARG2 (&ctra, 1),
                                a_nr, a_nc, 1.0,
@@ -2963,20 +2963,20 @@ xgemm (const Matrix& a, const Matrix& b,
                                F77_CHAR_ARG_LEN (1)));
       for (int j = 0; j < a_nr; j++)
         for (int i = 0; i < j; i++)
           retval.xelem (j,i) = retval.xelem (i,j);
 
     }
   else
     {
-      F77_INT lda = to_f77_int (a.rows ());
-      F77_INT tda = to_f77_int (a.cols ());
-      F77_INT ldb = to_f77_int (b.rows ());
-      F77_INT tdb = to_f77_int (b.cols ());
+      F77_INT lda = octave::to_f77_int (a.rows ());
+      F77_INT tda = octave::to_f77_int (a.cols ());
+      F77_INT ldb = octave::to_f77_int (b.rows ());
+      F77_INT tdb = octave::to_f77_int (b.cols ());
 
       retval = Matrix (a_nr, b_nc);
       double *c = retval.fortran_vec ();
 
       if (b_nc == 1)
         {
           if (a_nr == 1)
             F77_FUNC (xddot, XDDOT) (a_nc, a.data (), 1, b.data (), 1, *c);
diff --git a/liboctave/array/dRowVector.cc b/liboctave/array/dRowVector.cc
--- a/liboctave/array/dRowVector.cc
+++ b/liboctave/array/dRowVector.cc
@@ -165,20 +165,20 @@ RowVector::extract_n (octave_idx_type r1
 
 // row vector by matrix -> row vector
 
 RowVector
 operator * (const RowVector& v, const Matrix& a)
 {
   RowVector retval;
 
-  F77_INT len = to_f77_int (v.numel ());
+  F77_INT len = octave::to_f77_int (v.numel ());
 
-  F77_INT a_nr = to_f77_int (a.rows ());
-  F77_INT a_nc = to_f77_int (a.cols ());
+  F77_INT a_nr = octave::to_f77_int (a.rows ());
+  F77_INT a_nc = octave::to_f77_int (a.cols ());
 
   if (a_nr != len)
     octave::err_nonconformant ("operator *", 1, len, a_nr, a_nc);
 
   if (len == 0)
     retval.resize (a_nc, 0.0);
   else
     {
@@ -287,19 +287,19 @@ linspace (double x1, double x2, octave_i
 
 // row vector by column vector -> scalar
 
 double
 operator * (const RowVector& v, const ColumnVector& a)
 {
   double retval = 0.0;
 
-  F77_INT len = to_f77_int (v.numel ());
+  F77_INT len = octave::to_f77_int (v.numel ());
 
-  F77_INT a_len = to_f77_int (a.numel ());
+  F77_INT a_len = octave::to_f77_int (a.numel ());
 
   if (len != a_len)
     octave::err_nonconformant ("operator *", len, a_len);
 
   if (len != 0)
     F77_FUNC (xddot, XDDOT) (len, v.data (), 1, a.data (), 1, retval);
 
   return retval;
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -3757,20 +3757,20 @@ SparseMatrix::trisolve (MatrixType &matt
                   {
                     if (ridx (i) == j)
                       D[j] = data (i);
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                   }
             }
 
-          F77_INT tmp_nr = to_f77_int (nr);
-
-          F77_INT b_nr = to_f77_int (b.rows ());
-          F77_INT b_nc = to_f77_int (b.cols ());
+          F77_INT tmp_nr = octave::to_f77_int (nr);
+
+          F77_INT b_nr = octave::to_f77_int (b.rows ());
+          F77_INT b_nc = octave::to_f77_int (b.cols ());
 
           retval = b;
           double *result = retval.fortran_vec ();
 
           F77_INT tmp_err = 0;
 
           F77_XFCN (dptsv, DPTSV, (tmp_nr, b_nc, D, DL, result,
                                    b_nr, tmp_err));
@@ -3822,20 +3822,20 @@ SparseMatrix::trisolve (MatrixType &matt
                       D[j] = data (i);
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                     else if (ridx (i) == j - 1)
                       DU[j-1] = data (i);
                   }
             }
 
-          F77_INT tmp_nr = to_f77_int (nr);
-
-          F77_INT b_nr = to_f77_int (b.rows ());
-          F77_INT b_nc = to_f77_int (b.cols ());
+          F77_INT tmp_nr = octave::to_f77_int (nr);
+
+          F77_INT b_nr = octave::to_f77_int (b.rows ());
+          F77_INT b_nc = octave::to_f77_int (b.cols ());
 
           retval = b;
           double *result = retval.fortran_vec ();
 
           F77_INT tmp_err = 0;
 
           F77_XFCN (dgtsv, DGTSV, (tmp_nr, b_nc, DL, D, DU, result,
                                    b_nr, tmp_err));
@@ -3932,17 +3932,17 @@ SparseMatrix::trisolve (MatrixType &matt
                       D[j] = data (i);
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                     else if (ridx (i) == j - 1)
                       DU[j-1] = data (i);
                   }
             }
 
-          F77_INT tmp_nr = to_f77_int (nr);
+          F77_INT tmp_nr = octave::to_f77_int (nr);
 
           F77_INT tmp_err = 0;
 
           F77_XFCN (dgttrf, DGTTRF, (tmp_nr, DL, D, DU, DU2, pipvt, tmp_err));
 
           if (err != 0)
             {
               rcond = 0.0;
@@ -3970,17 +3970,17 @@ SparseMatrix::trisolve (MatrixType &matt
 
               for (volatile octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < nr; i++)
                     work[i] = 0.;
                   for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
                     work[b.ridx (i)] = b.data (i);
 
-                  F77_INT b_nr = to_f77_int (b.rows ());
+                  F77_INT b_nr = octave::to_f77_int (b.rows ());
 
                   F77_XFCN (dgttrs, DGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              tmp_nr, 1, DL, D, DU, DU2, pipvt,
                              work, b_nr, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
                   err = tmp_err;
@@ -4077,20 +4077,20 @@ SparseMatrix::trisolve (MatrixType &matt
                   {
                     if (ridx (i) == j)
                       D[j] = data (i);
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                   }
             }
 
-          F77_INT tmp_nr = to_f77_int (nr);
-
-          F77_INT b_nr = to_f77_int (b.rows ());
-          F77_INT b_nc = to_f77_int (b.cols ());
+          F77_INT tmp_nr = octave::to_f77_int (nr);
+
+          F77_INT b_nr = octave::to_f77_int (b.rows ());
+          F77_INT b_nc = octave::to_f77_int (b.cols ());
 
           rcond = 1.;
 
           retval = b;
           Complex *result = retval.fortran_vec ();
 
           F77_INT tmp_err = 0;
 
@@ -4143,20 +4143,20 @@ SparseMatrix::trisolve (MatrixType &matt
                       D[j] = data (i);
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                     else if (ridx (i) == j - 1)
                       DU[j-1] = data (i);
                   }
             }
 
-          F77_INT tmp_nr = to_f77_int (nr);
-
-          F77_INT b_nr = to_f77_int (b.rows ());
-          F77_INT b_nc = to_f77_int (b.cols ());
+          F77_INT tmp_nr = octave::to_f77_int (nr);
+
+          F77_INT b_nr = octave::to_f77_int (b.rows ());
+          F77_INT b_nc = octave::to_f77_int (b.cols ());
 
           rcond = 1.;
 
           retval = b;
           Complex *result = retval.fortran_vec ();
 
           F77_INT tmp_err = 0;
 
@@ -4256,17 +4256,17 @@ SparseMatrix::trisolve (MatrixType &matt
                       D[j] = data (i);
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                     else if (ridx (i) == j - 1)
                       DU[j-1] = data (i);
                   }
             }
 
-          F77_INT tmp_nr = to_f77_int (nr);
+          F77_INT tmp_nr = octave::to_f77_int (nr);
 
           F77_INT tmp_err = 0;
 
           F77_XFCN (dgttrf, DGTTRF, (tmp_nr, DL, D, DU, DU2, pipvt, tmp_err));
 
           err = tmp_err;
 
           if (err != 0)
@@ -4281,17 +4281,17 @@ SparseMatrix::trisolve (MatrixType &matt
                 }
               else
                 octave::warn_singular_matrix ();
             }
           else
             {
               rcond = 1.;
               char job = 'N';
-              F77_INT b_nr = to_f77_int (b.rows ());
+              F77_INT b_nr = octave::to_f77_int (b.rows ());
               octave_idx_type b_nc = b.cols ();
               OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
               OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
 
               // Take a first guess that the number of nonzero terms
               // will be as many as in b
               volatile octave_idx_type x_nz = b.nnz ();
               volatile octave_idx_type ii = 0;
@@ -4401,17 +4401,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
         {
-          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT n_lower = octave::to_f77_int (mattype.nlower ());
           F77_INT ldm = n_lower + 1;
           Matrix m_band (ldm, nc);
           double *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
@@ -4428,17 +4428,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             anorm = m_band.abs ().sum ().row (0).max ();
 
-          F77_INT tmp_nr = to_f77_int (nr);
+          F77_INT tmp_nr = octave::to_f77_int (nr);
 
           F77_INT tmp_err = 0;
 
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      tmp_nr, n_lower, tmp_data, ldm, tmp_err
                                      F77_CHAR_ARG_LEN (1)));
 
@@ -4491,18 +4491,18 @@ SparseMatrix::bsolve (MatrixType &mattyp
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   retval = b;
                   double *result = retval.fortran_vec ();
 
-                  F77_INT b_nr = to_f77_int (b.rows ());
-                  F77_INT b_nc = to_f77_int (b.cols ());
+                  F77_INT b_nr = octave::to_f77_int (b.rows ());
+                  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
                   F77_XFCN (dpbtrs, DPBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              tmp_nr, n_lower, b_nc, tmp_data,
                              ldm, result, b_nr, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
                   err = tmp_err;
@@ -4516,18 +4516,18 @@ SparseMatrix::bsolve (MatrixType &mattyp
                     }
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
         {
           // Create the storage for the banded form of the sparse matrix
-          F77_INT n_upper = to_f77_int (mattype.nupper ());
-          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT n_upper = octave::to_f77_int (mattype.nupper ());
+          F77_INT n_lower = octave::to_f77_int (mattype.nlower ());
           F77_INT ldm = n_upper + 2 * n_lower + 1;
 
           Matrix m_band (ldm, nc);
           double *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
@@ -4550,17 +4550,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   double atmp = 0.;
                   for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                     atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          F77_INT tmp_nr = to_f77_int (nr);
+          F77_INT tmp_nr = octave::to_f77_int (nr);
 
           Array<F77_INT> ipvt (dim_vector (nr, 1));
           F77_INT *pipvt = ipvt.fortran_vec ();
 
           F77_INT tmp_err = 0;
 
           F77_XFCN (dgbtrf, DGBTRF, (tmp_nr, tmp_nr, n_lower, n_upper,
                                      tmp_data, ldm, pipvt, tmp_err));
@@ -4587,17 +4587,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
                   Array<F77_INT> iz (dim_vector (nr, 1));
                   F77_INT *piz = iz.fortran_vec ();
 
-                  F77_INT tmp_nc = to_f77_int (nc);
+                  F77_INT tmp_nc = octave::to_f77_int (nc);
 
                   F77_XFCN (dgbcon, DGBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              tmp_nc, n_lower, n_upper, tmp_data, ldm, pipvt,
                              anorm, rcond, pz, piz, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
                   err = tmp_err;
@@ -4623,18 +4623,18 @@ SparseMatrix::bsolve (MatrixType &mattyp
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   retval = b;
                   double *result = retval.fortran_vec ();
 
-                  F77_INT b_nr = to_f77_int (b.rows ());
-                  F77_INT b_nc = to_f77_int (b.cols ());
+                  F77_INT b_nr = octave::to_f77_int (b.rows ());
+                  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
                   char job = 'N';
                   F77_XFCN (dgbtrs, DGBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              tmp_nr, n_lower, n_upper, b_nc, tmp_data,
                              ldm, pipvt, result, b_nr, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
@@ -4670,18 +4670,18 @@ SparseMatrix::bsolve (MatrixType &mattyp
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
         {
-          F77_INT n_lower = to_f77_int (mattype.nlower ());
-          F77_INT ldm = to_f77_int (n_lower + 1);
+          F77_INT n_lower = octave::to_f77_int (mattype.nlower ());
+          F77_INT ldm = octave::to_f77_int (n_lower + 1);
 
           Matrix m_band (ldm, nc);
           double *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
@@ -4698,17 +4698,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             anorm = m_band.abs ().sum ().row (0).max ();
 
-          F77_INT tmp_nr = to_f77_int (nr);
+          F77_INT tmp_nr = octave::to_f77_int (nr);
 
           F77_INT tmp_err = 0;
 
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      tmp_nr, n_lower, tmp_data, ldm, tmp_err
                                      F77_CHAR_ARG_LEN (1)));
 
@@ -4756,17 +4756,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                         octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
-                  F77_INT b_nr = to_f77_int (b.rows ());
+                  F77_INT b_nr = octave::to_f77_int (b.rows ());
                   octave_idx_type b_nc = b.cols ();
                   OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
 
                   // Take a first guess that the number of nonzero terms
                   // will be as many as in b
                   volatile octave_idx_type x_nz = b.nnz ();
                   volatile octave_idx_type ii = 0;
                   retval = SparseMatrix (b_nr, b_nc, x_nz);
@@ -4818,19 +4818,19 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   retval.maybe_compress ();
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
         {
           // Create the storage for the banded form of the sparse matrix
-          F77_INT n_upper = to_f77_int (mattype.nupper ());
-          F77_INT n_lower = to_f77_int (mattype.nlower ());
-          F77_INT ldm = to_f77_int (n_upper + 2 * n_lower + 1);
+          F77_INT n_upper = octave::to_f77_int (mattype.nupper ());
+          F77_INT n_lower = octave::to_f77_int (mattype.nlower ());
+          F77_INT ldm = octave::to_f77_int (n_upper + 2 * n_lower + 1);
 
           Matrix m_band (ldm, nc);
           double *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
 
@@ -4852,17 +4852,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   double atmp = 0.;
                   for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                     atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          F77_INT tmp_nr = to_f77_int (nr);
+          F77_INT tmp_nr = octave::to_f77_int (nr);
 
           Array<F77_INT> ipvt (dim_vector (nr, 1));
           F77_INT *pipvt = ipvt.fortran_vec ();
 
           F77_INT tmp_err = 0;
 
           F77_XFCN (dgbtrf, DGBTRF, (tmp_nr, tmp_nr, n_lower, n_upper,
                                      tmp_data, ldm, pipvt, tmp_err));
@@ -4887,17 +4887,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
                   Array<F77_INT> iz (dim_vector (nr, 1));
                   F77_INT *piz = iz.fortran_vec ();
 
-                  F77_INT tmp_nc = to_f77_int (nc);
+                  F77_INT tmp_nc = octave::to_f77_int (nc);
 
                   F77_XFCN (dgbcon, DGBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              tmp_nc, n_lower, n_upper, tmp_data, ldm, pipvt,
                              anorm, rcond, pz, piz, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
                   err = tmp_err;
@@ -4937,17 +4937,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
                       for (octave_idx_type i = 0; i < nr; i++)
                         work[i] = 0.;
                       for (octave_idx_type i = b.cidx (j);
                            i < b.cidx (j+1); i++)
                         work[b.ridx (i)] = b.data (i);
 
-                      F77_INT b_nr = to_f77_int (b.rows ());
+                      F77_INT b_nr = octave::to_f77_int (b.rows ());
 
                       F77_XFCN (dgbtrs, DGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  tmp_nr, n_lower, n_upper, 1, tmp_data,
                                  ldm, pipvt, work, b_nr, tmp_err
                                  F77_CHAR_ARG_LEN (1)));
 
                       err = tmp_err;
@@ -5008,17 +5008,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
         {
-          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT n_lower = octave::to_f77_int (mattype.nlower ());
           F77_INT ldm = n_lower + 1;
 
           Matrix m_band (ldm, nc);
           double *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
@@ -5036,17 +5036,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             anorm = m_band.abs ().sum ().row (0).max ();
 
-          F77_INT tmp_nr = to_f77_int (nr);
+          F77_INT tmp_nr = octave::to_f77_int (nr);
 
           F77_INT tmp_err = 0;
 
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      tmp_nr, n_lower, tmp_data, ldm, tmp_err
                                      F77_CHAR_ARG_LEN (1)));
 
@@ -5096,17 +5096,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                         octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
-                  F77_INT b_nr = to_f77_int (b.rows ());
+                  F77_INT b_nr = octave::to_f77_int (b.rows ());
                   octave_idx_type b_nc = b.cols ();
 
                   OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
                   OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
 
                   retval.resize (b_nr, b_nc);
 
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
@@ -5157,18 +5157,18 @@ SparseMatrix::bsolve (MatrixType &mattyp
                     }
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
         {
           // Create the storage for the banded form of the sparse matrix
-          F77_INT n_upper = to_f77_int (mattype.nupper ());
-          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT n_upper = octave::to_f77_int (mattype.nupper ());
+          F77_INT n_lower = octave::to_f77_int (mattype.nlower ());
           F77_INT ldm = n_upper + 2 * n_lower + 1;
 
           Matrix m_band (ldm, nc);
           double *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
@@ -5191,17 +5191,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   double atmp = 0.;
                   for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                     atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          F77_INT tmp_nr = to_f77_int (nr);
+          F77_INT tmp_nr = octave::to_f77_int (nr);
 
           Array<F77_INT> ipvt (dim_vector (nr, 1));
           F77_INT *pipvt = ipvt.fortran_vec ();
 
           F77_INT tmp_err = 0;
 
           F77_XFCN (dgbtrf, DGBTRF, (tmp_nr, tmp_nr, n_lower, n_upper,
                                      tmp_data, ldm, pipvt, tmp_err));
@@ -5226,17 +5226,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
                   Array<F77_INT> iz (dim_vector (nr, 1));
                   F77_INT *piz = iz.fortran_vec ();
 
-                  F77_INT tmp_nc = to_f77_int (nc);
+                  F77_INT tmp_nc = octave::to_f77_int (nc);
 
                   F77_XFCN (dgbcon, DGBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              tmp_nc, n_lower, n_upper, tmp_data, ldm, pipvt,
                              anorm, rcond, pz, piz, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
                   err = tmp_err;
@@ -5260,17 +5260,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
-                  F77_INT b_nr = to_f77_int (b.rows ());
+                  F77_INT b_nr = octave::to_f77_int (b.rows ());
                   octave_idx_type b_nc = b.cols ();
                   retval.resize (nr,b_nc);
 
                   OCTAVE_LOCAL_BUFFER (double, Bz, nr);
                   OCTAVE_LOCAL_BUFFER (double, Bx, nr);
 
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
@@ -5331,17 +5331,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
   else
     {
       // Print spparms("spumoni") info if requested
       volatile int typ = mattype.type ();
       mattype.info ();
 
       if (typ == MatrixType::Banded_Hermitian)
         {
-          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT n_lower = octave::to_f77_int (mattype.nlower ());
           F77_INT ldm = n_lower + 1;
 
           Matrix m_band (ldm, nc);
           double *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
@@ -5359,17 +5359,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   m_band(ri - j, j) = data (i);
               }
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             anorm = m_band.abs ().sum ().row (0).max ();
 
-          F77_INT tmp_nr = to_f77_int (nr);
+          F77_INT tmp_nr = octave::to_f77_int (nr);
 
           F77_INT tmp_err = 0;
 
           char job = 'L';
           F77_XFCN (dpbtrf, DPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
                                      tmp_nr, n_lower, tmp_data, ldm, tmp_err
                                      F77_CHAR_ARG_LEN (1)));
 
@@ -5420,17 +5420,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                         octave::warn_singular_matrix (rcond);
                     }
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
-                  F77_INT b_nr = to_f77_int (b.rows ());
+                  F77_INT b_nr = octave::to_f77_int (b.rows ());
                   octave_idx_type b_nc = b.cols ();
                   OCTAVE_LOCAL_BUFFER (double, Bx, b_nr);
                   OCTAVE_LOCAL_BUFFER (double, Bz, b_nr);
 
                   // Take a first guess that the number of nonzero terms
                   // will be as many as in b
                   volatile octave_idx_type x_nz = b.nnz ();
                   volatile octave_idx_type ii = 0;
@@ -5511,18 +5511,18 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   retval.maybe_compress ();
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
         {
           // Create the storage for the banded form of the sparse matrix
-          F77_INT n_upper = to_f77_int (mattype.nupper ());
-          F77_INT n_lower = to_f77_int (mattype.nlower ());
+          F77_INT n_upper = octave::to_f77_int (mattype.nupper ());
+          F77_INT n_lower = octave::to_f77_int (mattype.nlower ());
           F77_INT ldm = n_upper + 2 * n_lower + 1;
 
           Matrix m_band (ldm, nc);
           double *tmp_data = m_band.fortran_vec ();
 
           if (! mattype.is_dense ())
             {
               octave_idx_type ii = 0;
@@ -5545,17 +5545,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                   double atmp = 0.;
                   for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
                     atmp += fabs (data (i));
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
-          F77_INT tmp_nr = to_f77_int (nr);
+          F77_INT tmp_nr = octave::to_f77_int (nr);
 
           Array<F77_INT> ipvt (dim_vector (nr, 1));
           F77_INT *pipvt = ipvt.fortran_vec ();
 
           F77_INT tmp_err = 0;
 
           F77_XFCN (dgbtrf, DGBTRF, (tmp_nr, tmp_nr, n_lower, n_upper,
                                      tmp_data, ldm, pipvt, tmp_err));
@@ -5580,17 +5580,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
               if (calc_cond)
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
                   Array<F77_INT> iz (dim_vector (nr, 1));
                   F77_INT *piz = iz.fortran_vec ();
 
-                  F77_INT tmp_nc = to_f77_int (nc);
+                  F77_INT tmp_nc = octave::to_f77_int (nc);
 
                   F77_XFCN (dgbcon, DGBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
                              tmp_nc, n_lower, n_upper, tmp_data, ldm, pipvt,
                              anorm, rcond, pz, piz, tmp_err
                              F77_CHAR_ARG_LEN (1)));
 
                   err = tmp_err;
@@ -5615,17 +5615,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                 }
               else
                 rcond = 1.;
 
               if (err == 0)
                 {
                   char job = 'N';
                   volatile octave_idx_type x_nz = b.nnz ();
-                  F77_INT b_nr = to_f77_int (b.rows ());
+                  F77_INT b_nr = octave::to_f77_int (b.rows ());
                   octave_idx_type b_nc = b.cols ();
                   retval = SparseComplexMatrix (nr, b_nc, x_nz);
                   retval.xcidx (0) = 0;
                   volatile octave_idx_type ii = 0;
 
                   OCTAVE_LOCAL_BUFFER (double, Bx, nr);
                   OCTAVE_LOCAL_BUFFER (double, Bz, nr);
 
diff --git a/liboctave/array/fCColVector.cc b/liboctave/array/fCColVector.cc
--- a/liboctave/array/fCColVector.cc
+++ b/liboctave/array/fCColVector.cc
@@ -298,20 +298,20 @@ operator * (const FloatComplexMatrix& m,
   return m * tmp;
 }
 
 FloatComplexColumnVector
 operator * (const FloatComplexMatrix& m, const FloatComplexColumnVector& a)
 {
   FloatComplexColumnVector retval;
 
-  F77_INT nr = to_f77_int (m.rows ());
-  F77_INT nc = to_f77_int (m.cols ());
+  F77_INT nr = octave::to_f77_int (m.rows ());
+  F77_INT nc = octave::to_f77_int (m.cols ());
 
-  F77_INT a_len = to_f77_int (a.numel ());
+  F77_INT a_len = octave::to_f77_int (a.numel ());
 
   if (nc != a_len)
     octave::err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   retval.clear (nr);
 
   if (nr != 0)
     {
@@ -340,20 +340,20 @@ operator * (const FloatMatrix& m, const 
   return tmp * a;
 }
 
 // diagonal matrix by column vector -> column vector operations
 
 FloatComplexColumnVector
 operator * (const FloatDiagMatrix& m, const FloatComplexColumnVector& a)
 {
-  F77_INT nr = to_f77_int (m.rows ());
-  F77_INT nc = to_f77_int (m.cols ());
+  F77_INT nr = octave::to_f77_int (m.rows ());
+  F77_INT nc = octave::to_f77_int (m.cols ());
 
-  F77_INT a_len = to_f77_int (a.numel ());
+  F77_INT a_len = octave::to_f77_int (a.numel ());
 
   if (nc != a_len)
     octave::err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   if (nc == 0 || nr == 0)
     return FloatComplexColumnVector (0);
 
   FloatComplexColumnVector result (nr);
@@ -365,20 +365,20 @@ operator * (const FloatDiagMatrix& m, co
     result.elem (i) = 0.0;
 
   return result;
 }
 
 FloatComplexColumnVector
 operator * (const FloatComplexDiagMatrix& m, const FloatColumnVector& a)
 {
-  F77_INT nr = to_f77_int (m.rows ());
-  F77_INT nc = to_f77_int (m.cols ());
+  F77_INT nr = octave::to_f77_int (m.rows ());
+  F77_INT nc = octave::to_f77_int (m.cols ());
 
-  F77_INT a_len = to_f77_int (a.numel ());
+  F77_INT a_len = octave::to_f77_int (a.numel ());
 
   if (nc != a_len)
     octave::err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   if (nc == 0 || nr == 0)
     return FloatComplexColumnVector (0);
 
   FloatComplexColumnVector result (nr);
@@ -390,20 +390,20 @@ operator * (const FloatComplexDiagMatrix
     result.elem (i) = 0.0;
 
   return result;
 }
 
 FloatComplexColumnVector
 operator * (const FloatComplexDiagMatrix& m, const FloatComplexColumnVector& a)
 {
-  F77_INT nr = to_f77_int (m.rows ());
-  F77_INT nc = to_f77_int (m.cols ());
+  F77_INT nr = octave::to_f77_int (m.rows ());
+  F77_INT nc = octave::to_f77_int (m.cols ());
 
-  F77_INT a_len = to_f77_int (a.numel ());
+  F77_INT a_len = octave::to_f77_int (a.numel ());
 
   if (nc != a_len)
     octave::err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   if (nc == 0 || nr == 0)
     return FloatComplexColumnVector (0);
 
   FloatComplexColumnVector result (nr);
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -757,18 +757,18 @@ FloatComplexMatrix::inverse (MatrixType 
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::tinverse (MatrixType &mattype, octave_idx_type& info,
                               float& rcon, bool force, bool calc_cond) const
 {
   FloatComplexMatrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
 
   int typ = mattype.type ();
   char uplo = (typ == MatrixType::Lower ? 'L' : 'U');
   char udiag = 'N';
   retval = *this;
@@ -816,18 +816,18 @@ FloatComplexMatrix::tinverse (MatrixType
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::finverse (MatrixType &mattype, octave_idx_type& info,
                               float& rcon, bool force, bool calc_cond) const
 {
   FloatComplexMatrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
 
   Array<F77_INT> ipvt (dim_vector (nr, 1));
   F77_INT *pipvt = ipvt.fortran_vec ();
 
   retval = *this;
@@ -1095,22 +1095,22 @@ FloatComplexMatrix::fourier (void) const
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nsamples;
 
   F77_INT npts;
 
   if (nr == 1 || nc == 1)
     {
-      npts = to_f77_int (nr > nc ? nr : nc);
+      npts = octave::to_f77_int (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
-      npts = to_f77_int (nr);
+      npts = octave::to_f77_int (nr);
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
   Array<FloatComplex> wsave (dim_vector (nn, 1));
   FloatComplex *pwsave = wsave.fortran_vec ();
 
@@ -1138,22 +1138,22 @@ FloatComplexMatrix::ifourier (void) cons
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nsamples;
 
   F77_INT npts;
 
   if (nr == 1 || nc == 1)
     {
-      npts = to_f77_int (nr > nc ? nr : nc);
+      npts = octave::to_f77_int (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
-      npts = to_f77_int (nr);
+      npts = octave::to_f77_int (nr);
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
   Array<FloatComplex> wsave (dim_vector (nn, 1));
   FloatComplex *pwsave = wsave.fortran_vec ();
 
@@ -1176,18 +1176,18 @@ FloatComplexMatrix::ifourier (void) cons
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::fourier2d (void) const
 {
   FloatComplexMatrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
 
   F77_INT npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
@@ -1243,18 +1243,18 @@ FloatComplexMatrix::fourier2d (void) con
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::ifourier2d (void) const
 {
   FloatComplexMatrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
 
   F77_INT npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
@@ -1343,18 +1343,18 @@ FloatComplexMatrix::determinant (MatrixT
                                  octave_idx_type& info, float& rcon,
                                  bool calc_cond) const
 {
   FloatComplexDET retval (1.0);
 
   info = 0;
   rcon = 0.0;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
 
   volatile int typ = mattype.type ();
 
   // Even though the matrix is marked as singular (Rectangular), we may
   // still get a useful number from the LU factorization, because it always
@@ -1495,18 +1495,18 @@ FloatComplexMatrix::rcond (void) const
   MatrixType mattype (*this);
   return rcond (mattype);
 }
 
 float
 FloatComplexMatrix::rcond (MatrixType &mattype) const
 {
   float rcon = octave::numeric_limits<float>::NaN ();
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
 
   if (nr == 0 || nc == 0)
     rcon = octave::numeric_limits<float>::Inf ();
   else
     {
@@ -1668,21 +1668,21 @@ FloatComplexMatrix::rcond (MatrixType &m
 FloatComplexMatrix
 FloatComplexMatrix::utsolve (MatrixType &mattype, const FloatComplexMatrix& b,
                              octave_idx_type& info, float& rcon,
                              solve_singularity_handler sing_handler,
                              bool calc_cond, blas_trans_type transt) const
 {
   FloatComplexMatrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
-
-  F77_INT b_nr = to_f77_int (b.rows ());
-  F77_INT b_nc = to_f77_int (b.cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
+
+  F77_INT b_nr = octave::to_f77_int (b.rows ());
+  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
   if (nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (nr == 0 || nc == 0 || b_nc == 0)
     retval = FloatComplexMatrix (nc, b_nc, FloatComplex (0.0, 0.0));
   else
@@ -1770,21 +1770,21 @@ FloatComplexMatrix::utsolve (MatrixType 
 FloatComplexMatrix
 FloatComplexMatrix::ltsolve (MatrixType &mattype, const FloatComplexMatrix& b,
                              octave_idx_type& info, float& rcon,
                              solve_singularity_handler sing_handler,
                              bool calc_cond, blas_trans_type transt) const
 {
   FloatComplexMatrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
-
-  F77_INT b_nr = to_f77_int (b.rows ());
-  F77_INT b_nc = to_f77_int (b.cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
+
+  F77_INT b_nr = octave::to_f77_int (b.rows ());
+  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
   if (nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (nr == 0 || nc == 0 || b_nc == 0)
     retval = FloatComplexMatrix (nc, b_nc, FloatComplex (0.0, 0.0));
   else
@@ -1872,21 +1872,21 @@ FloatComplexMatrix::ltsolve (MatrixType 
 FloatComplexMatrix
 FloatComplexMatrix::fsolve (MatrixType &mattype, const FloatComplexMatrix& b,
                             octave_idx_type& info, float& rcon,
                             solve_singularity_handler sing_handler,
                             bool calc_cond) const
 {
   FloatComplexMatrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
-
-  F77_INT b_nr = to_f77_int (b.rows ());
-  F77_INT b_nc = to_f77_int (b.cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
+
+  F77_INT b_nr = octave::to_f77_int (b.rows ());
+  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
   if (nr != nc || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (nr == 0 || b_nc == 0)
     retval = FloatComplexMatrix (nc, b_nc, FloatComplex (0.0, 0.0));
   else
@@ -2435,23 +2435,23 @@ FloatComplexMatrix::lssolve (const Float
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
                              octave_idx_type& rank, float& rcon) const
 {
   FloatComplexMatrix retval;
 
-  F77_INT nrhs = to_f77_int (b.cols ());
-
-  F77_INT m = to_f77_int (rows ());
-  F77_INT n = to_f77_int (cols ());
-
-  F77_INT b_nr = to_f77_int (b.rows ());
-  F77_INT b_nc = to_f77_int (b.cols ());
+  F77_INT nrhs = octave::to_f77_int (b.cols ());
+
+  F77_INT m = octave::to_f77_int (rows ());
+  F77_INT n = octave::to_f77_int (cols ());
+
+  F77_INT b_nr = octave::to_f77_int (b.rows ());
+  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
   if (m != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (m == 0 || n == 0 || b_nc == 0)
     retval = FloatComplexMatrix (n, b_nc, FloatComplex (0.0, 0.0));
   else
@@ -2664,20 +2664,20 @@ FloatComplexColumnVector
 FloatComplexMatrix::lssolve (const FloatComplexColumnVector& b,
                              octave_idx_type& info,
                              octave_idx_type& rank, float& rcon) const
 {
   FloatComplexColumnVector retval;
 
   F77_INT nrhs = 1;
 
-  F77_INT m = to_f77_int (rows ());
-  F77_INT n = to_f77_int (cols ());
-
-  F77_INT b_nel = to_f77_int (b.numel ());
+  F77_INT m = octave::to_f77_int (rows ());
+  F77_INT n = octave::to_f77_int (cols ());
+
+  F77_INT b_nel = octave::to_f77_int (b.numel ());
 
   if (m != b_nel)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (m == 0 || n == 0)
     retval = FloatComplexColumnVector (n, FloatComplex (0.0, 0.0));
   else
@@ -2794,21 +2794,21 @@ operator * (const FloatComplexColumnVect
   return a * tmp;
 }
 
 FloatComplexMatrix
 operator * (const FloatComplexColumnVector& v, const FloatComplexRowVector& a)
 {
   FloatComplexMatrix retval;
 
-  F77_INT len = to_f77_int (v.numel ());
+  F77_INT len = octave::to_f77_int (v.numel ());
 
   if (len != 0)
     {
-      F77_INT a_len = to_f77_int (a.numel ());
+      F77_INT a_len = octave::to_f77_int (a.numel ());
 
       retval = FloatComplexMatrix (len, a_len);
       FloatComplex *c = retval.fortran_vec ();
 
       F77_XFCN (cgemm, CGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 ("N", 1),
                                len, a_len, 1, 1.0, F77_CONST_CMPLX_ARG (v.data ()), len,
                                F77_CONST_CMPLX_ARG (a.data ()), 1, 0.0, F77_CMPLX_ARG (c), len
@@ -3427,18 +3427,18 @@ Sylvester (const FloatComplexMatrix& a, 
   FloatComplexMatrix ub = bs.unitary_matrix ();
   FloatComplexMatrix sch_b = bs.schur_matrix ();
 
   FloatComplexMatrix cx = ua.hermitian () * c * ub;
 
   // Solve the sylvester equation, back-transform, and return the
   // solution.
 
-  F77_INT a_nr = to_f77_int (a.rows ());
-  F77_INT b_nr = to_f77_int (b.rows ());
+  F77_INT a_nr = octave::to_f77_int (a.rows ());
+  F77_INT b_nr = octave::to_f77_int (b.rows ());
 
   float scale;
   F77_INT info;
 
   FloatComplex *pa = sch_a.fortran_vec ();
   FloatComplex *pb = sch_b.fortran_vec ();
   FloatComplex *px = cx.fortran_vec ();
 
@@ -3511,30 +3511,30 @@ xgemm (const FloatComplexMatrix& a, cons
 {
   FloatComplexMatrix retval;
 
   bool tra = transa != blas_no_trans;
   bool trb = transb != blas_no_trans;
   bool cja = transa == blas_conj_trans;
   bool cjb = transb == blas_conj_trans;
 
-  F77_INT a_nr = to_f77_int (tra ? a.cols () : a.rows ());
-  F77_INT a_nc = to_f77_int (tra ? a.rows () : a.cols ());
-
-  F77_INT b_nr = to_f77_int (trb ? b.cols () : b.rows ());
-  F77_INT b_nc = to_f77_int (trb ? b.rows () : b.cols ());
+  F77_INT a_nr = octave::to_f77_int (tra ? a.cols () : a.rows ());
+  F77_INT a_nc = octave::to_f77_int (tra ? a.rows () : a.cols ());
+
+  F77_INT b_nr = octave::to_f77_int (trb ? b.cols () : b.rows ());
+  F77_INT b_nc = octave::to_f77_int (trb ? b.rows () : b.cols ());
 
   if (a_nc != b_nr)
     octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     retval = FloatComplexMatrix (a_nr, b_nc, 0.0);
   else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
     {
-      F77_INT lda = to_f77_int (a.rows ());
+      F77_INT lda = octave::to_f77_int (a.rows ());
 
       // FIXME: looking at the reference BLAS, it appears that it
       // should not be necessary to initialize the output matrix if
       // BETA is 0 in the call to CHERK, but ATLAS appears to
       // use the result matrix before zeroing the elements.
 
       retval = FloatComplexMatrix (a_nr, b_nc, 0.0);
       FloatComplex *c = retval.fortran_vec ();
@@ -3564,20 +3564,20 @@ xgemm (const FloatComplexMatrix& a, cons
             for (F77_INT i = 0; i < j; i++)
               retval.xelem (j,i) = retval.xelem (i,j);
 
         }
 
     }
   else
     {
-      F77_INT lda = to_f77_int (a.rows ());
-      F77_INT tda = to_f77_int (a.cols ());
-      F77_INT ldb = to_f77_int (b.rows ());
-      F77_INT tdb = to_f77_int (b.cols ());
+      F77_INT lda = octave::to_f77_int (a.rows ());
+      F77_INT tda = octave::to_f77_int (a.cols ());
+      F77_INT ldb = octave::to_f77_int (b.rows ());
+      F77_INT tdb = octave::to_f77_int (b.cols ());
 
       retval = FloatComplexMatrix (a_nr, b_nc, 0.0);
       FloatComplex *c = retval.fortran_vec ();
 
       if (b_nc == 1 && a_nr == 1)
         {
           if (cja == cjb)
             {
diff --git a/liboctave/array/fCRowVector.cc b/liboctave/array/fCRowVector.cc
--- a/liboctave/array/fCRowVector.cc
+++ b/liboctave/array/fCRowVector.cc
@@ -278,20 +278,20 @@ FloatComplexRowVector::operator -= (cons
 
 // row vector by matrix -> row vector
 
 FloatComplexRowVector
 operator * (const FloatComplexRowVector& v, const FloatComplexMatrix& a)
 {
   FloatComplexRowVector retval;
 
-  F77_INT len = to_f77_int (v.numel ());
+  F77_INT len = octave::to_f77_int (v.numel ());
 
-  F77_INT a_nr = to_f77_int (a.rows ());
-  F77_INT a_nc = to_f77_int (a.cols ());
+  F77_INT a_nr = octave::to_f77_int (a.rows ());
+  F77_INT a_nc = octave::to_f77_int (a.cols ());
 
   if (a_nr != len)
     octave::err_nonconformant ("operator *", 1, len, a_nr, a_nc);
 
   if (len == 0)
     retval.resize (a_nc, 0.0);
   else
     {
@@ -402,19 +402,19 @@ operator * (const FloatComplexRowVector&
   return v * tmp;
 }
 
 FloatComplex
 operator * (const FloatComplexRowVector& v, const FloatComplexColumnVector& a)
 {
   FloatComplex retval (0.0, 0.0);
 
-  F77_INT len = to_f77_int (v.numel ());
+  F77_INT len = octave::to_f77_int (v.numel ());
 
-  F77_INT a_len = to_f77_int (a.numel ());
+  F77_INT a_len = octave::to_f77_int (a.numel ());
 
   if (len != a_len)
     octave::err_nonconformant ("operator *", len, a_len);
 
   if (len != 0)
     F77_FUNC (xcdotu, XCDOTU) (len, F77_CONST_CMPLX_ARG (v.data ()), 1,
                                F77_CONST_CMPLX_ARG (a.data ()), 1, F77_CMPLX_ARG (&retval));
 
diff --git a/liboctave/array/fColVector.cc b/liboctave/array/fColVector.cc
--- a/liboctave/array/fColVector.cc
+++ b/liboctave/array/fColVector.cc
@@ -174,20 +174,20 @@ FloatColumnVector::extract_n (octave_idx
 
 // matrix by column vector -> column vector operations
 
 FloatColumnVector
 operator * (const FloatMatrix& m, const FloatColumnVector& a)
 {
   FloatColumnVector retval;
 
-  F77_INT nr = to_f77_int (m.rows ());
-  F77_INT nc = to_f77_int (m.cols ());
+  F77_INT nr = octave::to_f77_int (m.rows ());
+  F77_INT nc = octave::to_f77_int (m.cols ());
 
-  F77_INT a_len = to_f77_int (a.numel ());
+  F77_INT a_len = octave::to_f77_int (a.numel ());
 
   if (nc != a_len)
     octave::err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   retval.clear (nr);
 
   if (nr != 0)
     {
@@ -209,20 +209,20 @@ operator * (const FloatMatrix& m, const 
 
 // diagonal matrix by column vector -> column vector operations
 
 FloatColumnVector
 operator * (const FloatDiagMatrix& m, const FloatColumnVector& a)
 {
   FloatColumnVector retval;
 
-  F77_INT nr = to_f77_int (m.rows ());
-  F77_INT nc = to_f77_int (m.cols ());
+  F77_INT nr = octave::to_f77_int (m.rows ());
+  F77_INT nc = octave::to_f77_int (m.cols ());
 
-  F77_INT a_len = to_f77_int (a.numel ());
+  F77_INT a_len = octave::to_f77_int (a.numel ());
 
   if (nc != a_len)
     octave::err_nonconformant ("operator *", nr, nc, a_len, 1);
 
   if (nr == 0 || nc == 0)
     retval.resize (nr, 0.0);
   else
     {
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -472,18 +472,18 @@ FloatMatrix::inverse (MatrixType &mattyp
 }
 
 FloatMatrix
 FloatMatrix::tinverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
                        bool force, bool calc_cond) const
 {
   FloatMatrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
 
   int typ = mattype.type ();
   char uplo = (typ == MatrixType::Lower ? 'L' : 'U');
   char udiag = 'N';
   retval = *this;
@@ -531,18 +531,18 @@ FloatMatrix::tinverse (MatrixType &matty
 }
 
 FloatMatrix
 FloatMatrix::finverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
                        bool force, bool calc_cond) const
 {
   FloatMatrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
 
   Array<F77_INT> ipvt (dim_vector (nr, 1));
   F77_INT *pipvt = ipvt.fortran_vec ();
 
   retval = *this;
@@ -793,22 +793,22 @@ FloatMatrix::fourier (void) const
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nsamples;
 
   F77_INT npts;
 
   if (nr == 1 || nc == 1)
     {
-      npts = to_f77_int (nr > nc ? nr : nc);
+      npts = octave::to_f77_int (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
-      npts = to_f77_int (nr);
+      npts = octave::to_f77_int (nr);
       nsamples = nc;
     }
 
   octave_idx_type nn = 4*npts+15;
 
   Array<FloatComplex> wsave (dim_vector (nn, 1));
   FloatComplex *pwsave = wsave.fortran_vec ();
 
@@ -836,17 +836,17 @@ FloatMatrix::ifourier (void) const
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nsamples;
 
   F77_INT npts;
 
   if (nr == 1 || nc == 1)
     {
-      npts = to_f77_int (nr > nc ? nr : nc);
+      npts = octave::to_f77_int (nr > nc ? nr : nc);
       nsamples = 1;
     }
   else
     {
       npts = F77_INT (nr);
       nsamples = nc;
     }
 
@@ -874,18 +874,18 @@ FloatMatrix::ifourier (void) const
   return retval;
 }
 
 FloatComplexMatrix
 FloatMatrix::fourier2d (void) const
 {
   FloatComplexMatrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
 
   F77_INT npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
@@ -941,18 +941,18 @@ FloatMatrix::fourier2d (void) const
   return retval;
 }
 
 FloatComplexMatrix
 FloatMatrix::ifourier2d (void) const
 {
   FloatComplexMatrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
 
   F77_INT npts, nsamples;
 
   if (nr == 1 || nc == 1)
     {
       npts = nr > nc ? nr : nc;
       nsamples = 1;
     }
@@ -1041,18 +1041,18 @@ FloatMatrix::determinant (MatrixType& ma
                           octave_idx_type& info, float& rcon,
                           bool calc_cond) const
 {
   FloatDET retval (1.0);
 
   info = 0;
   rcon = 0.0;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
 
   volatile int typ = mattype.type ();
 
   // Even though the matrix is marked as singular (Rectangular), we may
   // still get a useful number from the LU factorization, because it always
@@ -1187,18 +1187,18 @@ FloatMatrix::rcond (void) const
   MatrixType mattype (*this);
   return rcond (mattype);
 }
 
 float
 FloatMatrix::rcond (MatrixType &mattype) const
 {
   float rcon = octave::numeric_limits<float>::NaN ();
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("matrix must be square");
 
   if (nr == 0 || nc == 0)
     rcon = octave::numeric_limits<float>::Inf ();
   else
     {
@@ -1355,21 +1355,21 @@ FloatMatrix::rcond (MatrixType &mattype)
 FloatMatrix
 FloatMatrix::utsolve (MatrixType &mattype, const FloatMatrix& b,
                       octave_idx_type& info,
                       float& rcon, solve_singularity_handler sing_handler,
                       bool calc_cond, blas_trans_type transt) const
 {
   FloatMatrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
-
-  F77_INT b_nr = to_f77_int (b.rows ());
-  F77_INT b_nc = to_f77_int (b.cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
+
+  F77_INT b_nr = octave::to_f77_int (b.rows ());
+  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
   if (nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (nr == 0 || nc == 0 || b_nc == 0)
     retval = FloatMatrix (nc, b_nc, 0.0);
   else
@@ -1458,21 +1458,21 @@ FloatMatrix::utsolve (MatrixType &mattyp
 FloatMatrix
 FloatMatrix::ltsolve (MatrixType &mattype, const FloatMatrix& b,
                       octave_idx_type& info,
                       float& rcon, solve_singularity_handler sing_handler,
                       bool calc_cond, blas_trans_type transt) const
 {
   FloatMatrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
-
-  F77_INT b_nr = to_f77_int (b.rows ());
-  F77_INT b_nc = to_f77_int (b.cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
+
+  F77_INT b_nr = octave::to_f77_int (b.rows ());
+  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
   if (nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (nr == 0 || nc == 0 || b_nc == 0)
     retval = FloatMatrix (nc, b_nc, 0.0);
   else
@@ -1560,21 +1560,21 @@ FloatMatrix::ltsolve (MatrixType &mattyp
 FloatMatrix
 FloatMatrix::fsolve (MatrixType &mattype, const FloatMatrix& b,
                      octave_idx_type& info,
                      float& rcon, solve_singularity_handler sing_handler,
                      bool calc_cond) const
 {
   FloatMatrix retval;
 
-  F77_INT nr = to_f77_int (rows ());
-  F77_INT nc = to_f77_int (cols ());
-
-  F77_INT b_nr = to_f77_int (b.rows ());
-  F77_INT b_nc = to_f77_int (b.cols ());
+  F77_INT nr = octave::to_f77_int (rows ());
+  F77_INT nc = octave::to_f77_int (cols ());
+
+  F77_INT b_nr = octave::to_f77_int (b.rows ());
+  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
   if (nr != nc || nr != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (nr == 0 || b_nc == 0)
     retval = FloatMatrix (nc, b_nc, 0.0);
   else
@@ -2096,23 +2096,23 @@ FloatMatrix::lssolve (const FloatMatrix&
 }
 
 FloatMatrix
 FloatMatrix::lssolve (const FloatMatrix& b, octave_idx_type& info,
                       octave_idx_type& rank, float &rcon) const
 {
   FloatMatrix retval;
 
-  F77_INT nrhs = to_f77_int (b.cols ());
-
-  F77_INT m = to_f77_int (rows ());
-  F77_INT n = to_f77_int (cols ());
-
-  F77_INT b_nr = to_f77_int (b.rows ());
-  F77_INT b_nc = to_f77_int (b.cols ());
+  F77_INT nrhs = octave::to_f77_int (b.cols ());
+
+  F77_INT m = octave::to_f77_int (rows ());
+  F77_INT n = octave::to_f77_int (cols ());
+
+  F77_INT b_nr = octave::to_f77_int (b.rows ());
+  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
   if (m != b_nr)
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (m == 0 || n == 0 || b_nc == 0)
     retval = FloatMatrix (n, b_nc, 0.0);
   else
@@ -2318,18 +2318,18 @@ FloatMatrix::lssolve (const FloatColumnV
 FloatColumnVector
 FloatMatrix::lssolve (const FloatColumnVector& b, octave_idx_type& info,
                       octave_idx_type& rank, float &rcon) const
 {
   FloatColumnVector retval;
 
   F77_INT nrhs = 1;
 
-  F77_INT m = to_f77_int (rows ());
-  F77_INT n = to_f77_int (cols ());
+  F77_INT m = octave::to_f77_int (rows ());
+  F77_INT n = octave::to_f77_int (cols ());
 
   if (m != b.numel ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
 
   if (m == 0 || n == 0)
     retval = FloatColumnVector (n, 0.0);
   else
@@ -2493,21 +2493,21 @@ FloatMatrix::operator -= (const FloatDia
 
 // column vector by row vector -> matrix operations
 
 FloatMatrix
 operator * (const FloatColumnVector& v, const FloatRowVector& a)
 {
   FloatMatrix retval;
 
-  F77_INT len = to_f77_int (v.numel ());
+  F77_INT len = octave::to_f77_int (v.numel ());
 
   if (len != 0)
     {
-      F77_INT a_len = to_f77_int (a.numel ());
+      F77_INT a_len = octave::to_f77_int (a.numel ());
 
       retval = FloatMatrix (len, a_len);
       float *c = retval.fortran_vec ();
 
       F77_XFCN (sgemm, SGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 ("N", 1),
                                len, a_len, 1, 1.0, v.data (), len,
                                a.data (), 1, 0.0, c, len
@@ -2873,18 +2873,18 @@ Sylvester (const FloatMatrix& a, const F
   FloatMatrix ub = bs.unitary_matrix ();
   FloatMatrix sch_b = bs.schur_matrix ();
 
   FloatMatrix cx = ua.transpose () * c * ub;
 
   // Solve the sylvester equation, back-transform, and return the
   // solution.
 
-  F77_INT a_nr = to_f77_int (a.rows ());
-  F77_INT b_nr = to_f77_int (b.rows ());
+  F77_INT a_nr = octave::to_f77_int (a.rows ());
+  F77_INT b_nr = octave::to_f77_int (b.rows ());
 
   float scale;
   F77_INT info;
 
   float *pa = sch_a.fortran_vec ();
   float *pb = sch_b.fortran_vec ();
   float *px = cx.fortran_vec ();
 
@@ -2935,30 +2935,30 @@ FloatMatrix
 xgemm (const FloatMatrix& a, const FloatMatrix& b,
        blas_trans_type transa, blas_trans_type transb)
 {
   FloatMatrix retval;
 
   bool tra = transa != blas_no_trans;
   bool trb = transb != blas_no_trans;
 
-  F77_INT a_nr = to_f77_int (tra ? a.cols () : a.rows ());
-  F77_INT a_nc = to_f77_int (tra ? a.rows () : a.cols ());
-
-  F77_INT b_nr = to_f77_int (trb ? b.cols () : b.rows ());
-  F77_INT b_nc = to_f77_int (trb ? b.rows () : b.cols ());
+  F77_INT a_nr = octave::to_f77_int (tra ? a.cols () : a.rows ());
+  F77_INT a_nc = octave::to_f77_int (tra ? a.rows () : a.cols ());
+
+  F77_INT b_nr = octave::to_f77_int (trb ? b.cols () : b.rows ());
+  F77_INT b_nc = octave::to_f77_int (trb ? b.rows () : b.cols ());
 
   if (a_nc != b_nr)
     octave::err_nonconformant ("operator *", a_nr, a_nc, b_nr, b_nc);
 
   if (a_nr == 0 || a_nc == 0 || b_nc == 0)
     retval = FloatMatrix (a_nr, b_nc, 0.0);
   else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
     {
-      F77_INT lda = to_f77_int (a.rows ());
+      F77_INT lda = octave::to_f77_int (a.rows ());
 
       retval = FloatMatrix (a_nr, b_nc);
       float *c = retval.fortran_vec ();
 
       const char ctra = get_blas_trans_arg (tra);
       F77_XFCN (ssyrk, SSYRK, (F77_CONST_CHAR_ARG2 ("U", 1),
                                F77_CONST_CHAR_ARG2 (&ctra, 1),
                                a_nr, a_nc, 1.0,
@@ -2967,20 +2967,20 @@ xgemm (const FloatMatrix& a, const Float
                                F77_CHAR_ARG_LEN (1)));
       for (int j = 0; j < a_nr; j++)
         for (int i = 0; i < j; i++)
           retval.xelem (j,i) = retval.xelem (i,j);
 
     }
   else
     {
-      F77_INT lda = to_f77_int (a.rows ());
-      F77_INT tda = to_f77_int (a.cols ());
-      F77_INT ldb = to_f77_int (b.rows ());
-      F77_INT tdb = to_f77_int (b.cols ());
+      F77_INT lda = octave::to_f77_int (a.rows ());
+      F77_INT tda = octave::to_f77_int (a.cols ());
+      F77_INT ldb = octave::to_f77_int (b.rows ());
+      F77_INT tdb = octave::to_f77_int (b.cols ());
 
       retval = FloatMatrix (a_nr, b_nc);
       float *c = retval.fortran_vec ();
 
       if (b_nc == 1)
         {
           if (a_nr == 1)
             F77_FUNC (xsdot, XSDOT) (a_nc, a.data (), 1, b.data (), 1, *c);
diff --git a/liboctave/array/fRowVector.cc b/liboctave/array/fRowVector.cc
--- a/liboctave/array/fRowVector.cc
+++ b/liboctave/array/fRowVector.cc
@@ -165,20 +165,20 @@ FloatRowVector::extract_n (octave_idx_ty
 
 // row vector by matrix -> row vector
 
 FloatRowVector
 operator * (const FloatRowVector& v, const FloatMatrix& a)
 {
   FloatRowVector retval;
 
-  F77_INT len = to_f77_int (v.numel ());
+  F77_INT len = octave::to_f77_int (v.numel ());
 
-  F77_INT a_nr = to_f77_int (a.rows ());
-  F77_INT a_nc = to_f77_int (a.cols ());
+  F77_INT a_nr = octave::to_f77_int (a.rows ());
+  F77_INT a_nc = octave::to_f77_int (a.cols ());
 
   if (a_nr != len)
     octave::err_nonconformant ("operator *", 1, len, a_nr, a_nc);
 
   if (len == 0)
     retval.resize (a_nc, 0.0);
   else
     {
@@ -287,19 +287,19 @@ linspace (float x1, float x2, octave_idx
 
 // row vector by column vector -> scalar
 
 float
 operator * (const FloatRowVector& v, const FloatColumnVector& a)
 {
   float retval = 0.0;
 
-  F77_INT len = to_f77_int (v.numel ());
+  F77_INT len = octave::to_f77_int (v.numel ());
 
-  F77_INT a_len = to_f77_int (a.numel ());
+  F77_INT a_len = octave::to_f77_int (a.numel ());
 
   if (len != a_len)
     octave::err_nonconformant ("operator *", len, a_len);
 
   if (len != 0)
     F77_FUNC (xsdot, XSDOT) (len, v.data (), 1, a.data (), 1, retval);
 
   return retval;
diff --git a/liboctave/cruft/misc/f77-fcn.h b/liboctave/cruft/misc/f77-fcn.h
--- a/liboctave/cruft/misc/f77-fcn.h
+++ b/liboctave/cruft/misc/f77-fcn.h
@@ -365,29 +365,30 @@ typedef octave_f77_int_type F77_LOGICAL;
 
 OCTAVE_NORETURN OCTAVE_API extern
 F77_RET_T
 F77_FUNC (xstopx, XSTOPX) (F77_CONST_CHAR_ARG_DECL
                            F77_CHAR_ARG_LEN_DECL);
 
 #if defined (__cplusplus)
 
-inline F77_INT
-to_f77_int (octave_idx_type x)
+namespace octave
 {
-  // FIXME: How to do this job in C, not knowing in advance the actual
-  // type of F77_INT?
+  inline F77_INT
+  to_f77_int (octave_idx_type x)
+  {
+    if (x < std::numeric_limits<F77_INT>::min ()
+        || x > std::numeric_limits<F77_INT>::max ())
+      (*current_liboctave_error_handler)
+        ("integer dimension or index out of range for Fortran INTEGER type");
 
-  if (x < std::numeric_limits<F77_INT>::min ()
-      || x > std::numeric_limits<F77_INT>::max ())
-    (*current_liboctave_error_handler)
-      ("integer dimension or index out of range for Fortran INTEGER type");
+    return static_cast<F77_INT> (x);
+  }
+}
 
-  return static_cast<F77_INT> (x);
-}
 #endif
 
 #if defined (__cplusplus)
 }
 #endif
 
 #endif
 
diff --git a/liboctave/numeric/DASPK.cc b/liboctave/numeric/DASPK.cc
--- a/liboctave/numeric/DASPK.cc
+++ b/liboctave/numeric/DASPK.cc
@@ -78,17 +78,17 @@ ddaspk_f (const double& time, const doub
       tmp_deriv.elem (i) = deriv[i];
       tmp_state.elem (i) = state[i];
     }
 
   octave_idx_type tmp_ires = ires;
 
   tmp_delta = user_fun (tmp_state, tmp_deriv, time, tmp_ires);
 
-  ires = to_f77_int (tmp_ires);
+  ires = octave::to_f77_int (tmp_ires);
 
   if (ires >= 0)
     {
       if (tmp_delta.is_empty ())
         ires = -2;
       else
         {
           for (F77_INT i = 0; i < nn; i++)
@@ -161,17 +161,17 @@ DASPK::do_integrate (double tout)
 
       initialized = true;
 
       info.resize (dim_vector (20, 1));
 
       for (F77_INT i = 0; i < 20; i++)
         info(i) = 0;
 
-      F77_INT n = to_f77_int (size ());
+      F77_INT n = octave::to_f77_int (size ());
 
       nn = n;
 
       info(0) = 0;
 
       if (stop_time_set)
         {
           rwork(0) = stop_time;
@@ -232,18 +232,18 @@ DASPK::do_integrate (double tout)
       iwork.resize (dim_vector (liw, 1));
       rwork.resize (dim_vector (lrw, 1));
 
       // DASPK_options
 
       abs_tol = absolute_tolerance ();
       rel_tol = relative_tolerance ();
 
-      F77_INT abs_tol_len = to_f77_int (abs_tol.numel ());
-      F77_INT rel_tol_len = to_f77_int (rel_tol.numel ());
+      F77_INT abs_tol_len = octave::to_f77_int (abs_tol.numel ());
+      F77_INT rel_tol_len = octave::to_f77_int (rel_tol.numel ());
 
       if (abs_tol_len == 1 && rel_tol_len == 1)
         {
           info(1) = 0;
         }
       else if (abs_tol_len == n && rel_tol_len == n)
         {
           info(1) = 1;
@@ -278,17 +278,17 @@ DASPK::do_integrate (double tout)
         info(7) = 0;
 
       octave_idx_type maxord = maximum_order ();
       if (maxord >= 0)
         {
           if (maxord > 0 && maxord < 6)
             {
               info(8) = 1;
-              iwork(2) = to_f77_int (maxord);
+              iwork(2) = octave::to_f77_int (maxord);
             }
           else
             {
               // FIXME: Should this be a warning?
               (*current_liboctave_error_handler)
                 ("daspk: invalid value for maximum order");
               integration_error = true;
               return retval;
@@ -297,23 +297,23 @@ DASPK::do_integrate (double tout)
 
       switch (eiq)
         {
         case 1:
         case 3:
           {
             Array<octave_idx_type> ict = inequality_constraint_types ();
 
-            F77_INT ict_nel = to_f77_int (ict.numel ());
+            F77_INT ict_nel = octave::to_f77_int (ict.numel ());
 
             if (ict_nel == n)
               {
                 for (F77_INT i = 0; i < n; i++)
                   {
-                    F77_INT val = to_f77_int (ict(i));
+                    F77_INT val = octave::to_f77_int (ict(i));
                     if (val < -2 || val > 2)
                       {
                         // FIXME: Should this be a warning?
                         (*current_liboctave_error_handler)
                           ("daspk: invalid value for inequality constraint type");
                         integration_error = true;
                         return retval;
                       }
@@ -328,17 +328,17 @@ DASPK::do_integrate (double tout)
                 integration_error = true;
                 return retval;
               }
           }
         // Fall through...
 
         case 0:
         case 2:
-          info(9) = to_f77_int (eiq);
+          info(9) = octave::to_f77_int (eiq);
           break;
 
         default:
           // FIXME: Should this be a warning?
           (*current_liboctave_error_handler)
             ("daspk: invalid value for enforce inequality constraints option");
           integration_error = true;
           return retval;
@@ -347,17 +347,17 @@ DASPK::do_integrate (double tout)
       if (ccic)
         {
           if (ccic == 1)
             {
               // FIXME: this code is duplicated below.
 
               Array<octave_idx_type> av = algebraic_variables ();
 
-              F77_INT av_nel = to_f77_int (av.numel ());
+              F77_INT av_nel = octave::to_f77_int (av.numel ());
 
               if (av_nel == n)
                 {
                   F77_INT lid;
                   if (eiq == 0 || eiq == 2)
                     lid = 40;
                   else if (eiq == 1 || eiq == 3)
                     lid = 40 + n;
@@ -380,28 +380,28 @@ DASPK::do_integrate (double tout)
             {
               // FIXME: Should this be a warning?
               (*current_liboctave_error_handler)
                 ("daspk: invalid value for compute consistent initial condition option");
               integration_error = true;
               return retval;
             }
 
-          info(10) = to_f77_int (ccic);
+          info(10) = octave::to_f77_int (ccic);
         }
 
       if (eavfet)
         {
           info(15) = 1;
 
           // FIXME: this code is duplicated above.
 
           Array<octave_idx_type> av = algebraic_variables ();
 
-          F77_INT av_nel = to_f77_int (av.numel ());
+          F77_INT av_nel = octave::to_f77_int (av.numel ());
 
           if (av_nel == n)
             {
               F77_INT lid;
               if (eiq == 0 || eiq == 2)
                 lid = 40;
               else if (eiq == 1 || eiq == 3)
                 lid = 40 + n;
@@ -414,20 +414,20 @@ DASPK::do_integrate (double tout)
         }
 
       if (use_initial_condition_heuristics ())
         {
           Array<double> ich = initial_condition_heuristics ();
 
           if (ich.numel () == 6)
             {
-              iwork(31) = to_f77_int (octave::math::nint_big (ich(0)));
-              iwork(32) = to_f77_int (octave::math::nint_big (ich(1)));
-              iwork(33) = to_f77_int (octave::math::nint_big (ich(2)));
-              iwork(34) = to_f77_int (octave::math::nint_big (ich(3)));
+              iwork(31) = octave::to_f77_int (octave::math::nint_big (ich(0)));
+              iwork(32) = octave::to_f77_int (octave::math::nint_big (ich(1)));
+              iwork(33) = octave::to_f77_int (octave::math::nint_big (ich(2)));
+              iwork(34) = octave::to_f77_int (octave::math::nint_big (ich(3)));
 
               rwork(13) = ich(4);
               rwork(14) = ich(5);
             }
           else
             {
               // FIXME: Should this be a warning?
               (*current_liboctave_error_handler)
@@ -440,17 +440,17 @@ DASPK::do_integrate (double tout)
         }
 
       octave_idx_type pici = print_initial_condition_info ();
       switch (pici)
         {
         case 0:
         case 1:
         case 2:
-          info(17) = to_f77_int (pici);
+          info(17) = octave::to_f77_int (pici);
           break;
 
         default:
           // FIXME: Should this be a warning?
           (*current_liboctave_error_handler)
             ("daspk: invalid value for print initial condition info option");
           integration_error = true;
           return retval;
@@ -471,17 +471,17 @@ DASPK::do_integrate (double tout)
   double *pabs_tol = abs_tol.fortran_vec ();
 
   double *prwork = rwork.fortran_vec ();
   F77_INT *piwork = iwork.fortran_vec ();
 
   double *dummy = 0;
   F77_INT *idummy = 0;
 
-  F77_INT tmp_istate = to_f77_int (istate);
+  F77_INT tmp_istate = octave::to_f77_int (istate);
 
   F77_XFCN (ddaspk, DDASPK, (ddaspk_f, nn, t, px, pxdot, tout, pinfo,
                              prel_tol, pabs_tol, tmp_istate, prwork, lrw,
                              piwork, liw, dummy, idummy, ddaspk_j,
                              ddaspk_psol));
 
   istate = tmp_istate;
 
@@ -550,17 +550,17 @@ DASPK::do_integrate (const ColumnVector&
 }
 
 Matrix
 DASPK::integrate (const ColumnVector& tout, Matrix& xdot_out)
 {
   Matrix retval;
 
   octave_idx_type n_out = tout.numel ();
-  F77_INT n = to_f77_int (size ());
+  F77_INT n = octave::to_f77_int (size ());
 
   if (n_out > 0 && n > 0)
     {
       retval.resize (n_out, n);
       xdot_out.resize (n_out, n);
 
       for (F77_INT i = 0; i < n; i++)
         {
@@ -595,17 +595,17 @@ DASPK::do_integrate (const ColumnVector&
 
 Matrix
 DASPK::integrate (const ColumnVector& tout, Matrix& xdot_out,
                   const ColumnVector& tcrit)
 {
   Matrix retval;
 
   octave_idx_type n_out = tout.numel ();
-  F77_INT n = to_f77_int (size ());
+  F77_INT n = octave::to_f77_int (size ());
 
   if (n_out > 0 && n > 0)
     {
       retval.resize (n_out, n);
       xdot_out.resize (n_out, n);
 
       for (F77_INT i = 0; i < n; i++)
         {
diff --git a/liboctave/numeric/DASRT.cc b/liboctave/numeric/DASRT.cc
--- a/liboctave/numeric/DASRT.cc
+++ b/liboctave/numeric/DASRT.cc
@@ -76,17 +76,17 @@ ddasrt_f (const double& t, const double 
       tmp_state(i) = state[i];
       tmp_deriv(i) = deriv[i];
     }
 
   octave_idx_type tmp_ires = ires;
 
   ColumnVector tmp_fval = (*user_fsub) (tmp_state, tmp_deriv, t, tmp_ires);
 
-  ires = to_f77_int (tmp_ires);
+  ires = octave::to_f77_int (tmp_ires);
 
   if (tmp_fval.is_empty ())
     ires = -2;
   else
     {
       for (F77_INT i = 0; i < nn; i++)
         delta[i] = tmp_fval(i);
     }
@@ -160,33 +160,33 @@ DASRT::integrate (double tout)
 
       initialized = true;
 
       info.resize (dim_vector (15, 1));
 
       for (F77_INT i = 0; i < 15; i++)
         info(i) = 0;
 
-      F77_INT n = to_f77_int (size ());
+      F77_INT n = octave::to_f77_int (size ());
 
       nn = n;
 
       // DAERTFunc
 
       user_csub = DAERTFunc::constraint_function ();
 
       if (user_csub)
         {
           ColumnVector tmp = (*user_csub) (x, t);
-          ng = to_f77_int (tmp.numel ());
+          ng = octave::to_f77_int (tmp.numel ());
         }
       else
         ng = 0;
 
-      F77_INT maxord = to_f77_int (maximum_order ());
+      F77_INT maxord = octave::to_f77_int (maximum_order ());
       if (maxord >= 0)
         {
           if (maxord > 0 && maxord < 6)
             {
               info(8) = 1;
               iwork(2) = maxord;
             }
           else
@@ -268,30 +268,30 @@ DASRT::integrate (double tout)
       if (iss >= 0.0)
         {
           rwork(2) = iss;
           info(7) = 1;
         }
       else
         info(7) = 0;
 
-      F77_INT sl = to_f77_int (step_limit ());
+      F77_INT sl = octave::to_f77_int (step_limit ());
       if (sl >= 0)
         {
           info(11) = 1;
           iwork(20) = sl;
         }
       else
         info(11) = 0;
 
       abs_tol = absolute_tolerance ();
       rel_tol = relative_tolerance ();
 
-      F77_INT abs_tol_len = to_f77_int (abs_tol.numel ());
-      F77_INT rel_tol_len = to_f77_int (rel_tol.numel ());
+      F77_INT abs_tol_len = octave::to_f77_int (abs_tol.numel ());
+      F77_INT rel_tol_len = octave::to_f77_int (rel_tol.numel ());
 
       if (abs_tol_len == 1 && rel_tol_len == 1)
         {
           info.elem (1) = 0;
         }
       else if (abs_tol_len == n && rel_tol_len == n)
         {
           info.elem (1) = 1;
@@ -319,17 +319,17 @@ DASRT::integrate (double tout)
   double *prwork = rwork.fortran_vec ();
   F77_INT *piwork = iwork.fortran_vec ();
 
   F77_INT *pjroot = jroot.fortran_vec ();
 
   double *dummy = 0;
   F77_INT *idummy = 0;
 
-  F77_INT tmp_istate = to_f77_int (istate);
+  F77_INT tmp_istate = octave::to_f77_int (istate);
 
   F77_XFCN (ddasrt, DDASRT, (ddasrt_f, nn, t, px, pxdot, tout, pinfo,
                              prel_tol, pabs_tol, tmp_istate, prwork, lrw,
                              piwork, liw, dummy, idummy, ddasrt_j,
                              ddasrt_g, ng, pjroot));
 
   istate = tmp_istate;
 
@@ -388,17 +388,17 @@ DASRT::integrate (const ColumnVector& to
 {
   DASRT_result retval;
 
   Matrix x_out;
   Matrix xdot_out;
   ColumnVector t_out = tout;
 
   octave_idx_type n_out = tout.numel ();
-  F77_INT n = to_f77_int (size ());
+  F77_INT n = octave::to_f77_int (size ());
 
   if (n_out > 0 && n > 0)
     {
       x_out.resize (n_out, n);
       xdot_out.resize (n_out, n);
 
       for (F77_INT i = 0; i < n; i++)
         {
@@ -447,17 +447,17 @@ DASRT::integrate (const ColumnVector& to
 {
   DASRT_result retval;
 
   Matrix x_out;
   Matrix xdot_out;
   ColumnVector t_outs = tout;
 
   octave_idx_type n_out = tout.numel ();
-  F77_INT n = to_f77_int (size ());
+  F77_INT n = octave::to_f77_int (size ());
 
   if (n_out > 0 && n > 0)
     {
       x_out.resize (n_out, n);
       xdot_out.resize (n_out, n);
 
       octave_idx_type n_crit = tcrit.numel ();
 
diff --git a/liboctave/numeric/DASSL.cc b/liboctave/numeric/DASSL.cc
--- a/liboctave/numeric/DASSL.cc
+++ b/liboctave/numeric/DASSL.cc
@@ -75,17 +75,17 @@ ddassl_f (const double& time, const doub
       tmp_deriv.elem (i) = deriv[i];
       tmp_state.elem (i) = state[i];
     }
 
   octave_idx_type tmp_ires = ires;
 
   tmp_delta = user_fun (tmp_state, tmp_deriv, time, tmp_ires);
 
-  ires = to_f77_int (tmp_ires);
+  ires = octave::to_f77_int (tmp_ires);
 
   if (ires >= 0)
     {
       if (tmp_delta.is_empty ())
         ires = -2;
       else
         {
           for (F77_INT i = 0; i < nn; i++)
@@ -137,17 +137,17 @@ DASSL::do_integrate (double tout)
 
       initialized = true;
 
       info.resize (dim_vector (15, 1));
 
       for (F77_INT i = 0; i < 15; i++)
         info(i) = 0;
 
-      F77_INT n = to_f77_int (size ());
+      F77_INT n = octave::to_f77_int (size ());
 
       liw = 21 + n;
       lrw = 40 + 9*n + n*n;
 
       nn = n;
 
       iwork.resize (dim_vector (liw, 1));
       rwork.resize (dim_vector (lrw, 1));
@@ -212,54 +212,54 @@ DASSL::do_integrate (double tout)
       if (h0 >= 0.0)
         {
           rwork(2) = h0;
           info(7) = 1;
         }
       else
         info(7) = 0;
 
-      F77_INT sl = to_f77_int (step_limit ());
+      F77_INT sl = octave::to_f77_int (step_limit ());
 
       if (sl >= 0)
         {
           info(11) = 1;
           iwork(20) = sl;
         }
       else
         info(11) = 0;
 
-      F77_INT maxord = to_f77_int (maximum_order ());
+      F77_INT maxord = octave::to_f77_int (maximum_order ());
       if (maxord >= 0)
         {
           if (maxord > 0 && maxord < 6)
             {
               info(8) = 1;
               iwork(2) = maxord;
             }
           else
             {
               (*current_liboctave_error_handler)
                 ("dassl: invalid value for maximum order: %d", maxord);
               integration_error = true;
               return retval;
             }
         }
 
-      F77_INT enc = to_f77_int (enforce_nonnegativity_constraints ());
+      F77_INT enc = octave::to_f77_int (enforce_nonnegativity_constraints ());
       info(9) = enc ? 1 : 0;
 
-      F77_INT ccic = to_f77_int (compute_consistent_initial_condition ());
+      F77_INT ccic = octave::to_f77_int (compute_consistent_initial_condition ());
       info(10) = ccic ? 1 : 0;
 
       abs_tol = absolute_tolerance ();
       rel_tol = relative_tolerance ();
 
-      F77_INT abs_tol_len = to_f77_int (abs_tol.numel ());
-      F77_INT rel_tol_len = to_f77_int (rel_tol.numel ());
+      F77_INT abs_tol_len = octave::to_f77_int (abs_tol.numel ());
+      F77_INT rel_tol_len = octave::to_f77_int (rel_tol.numel ());
 
       if (abs_tol_len == 1 && rel_tol_len == 1)
         {
           info(1) = 0;
         }
       else if (abs_tol_len == n && rel_tol_len == n)
         {
           info(1) = 1;
@@ -285,17 +285,17 @@ DASSL::do_integrate (double tout)
   double *pabs_tol = abs_tol.fortran_vec ();
 
   double *prwork = rwork.fortran_vec ();
   F77_INT *piwork = iwork.fortran_vec ();
 
   double *dummy = 0;
   F77_INT *idummy = 0;
 
-  F77_INT tmp_istate = to_f77_int (istate);
+  F77_INT tmp_istate = octave::to_f77_int (istate);
 
   F77_XFCN (ddassl, DDASSL, (ddassl_f, nn, t, px, pxdot, tout, pinfo,
                              prel_tol, pabs_tol, tmp_istate, prwork, lrw,
                              piwork, liw, dummy, idummy, ddassl_j));
 
   istate = tmp_istate;
 
   switch (istate)
@@ -355,17 +355,17 @@ DASSL::do_integrate (const ColumnVector&
 }
 
 Matrix
 DASSL::integrate (const ColumnVector& tout, Matrix& xdot_out)
 {
   Matrix retval;
 
   octave_idx_type n_out = tout.numel ();
-  F77_INT n = to_f77_int (size ());
+  F77_INT n = octave::to_f77_int (size ());
 
   if (n_out > 0 && n > 0)
     {
       retval.resize (n_out, n);
       xdot_out.resize (n_out, n);
 
       for (F77_INT i = 0; i < n; i++)
         {
@@ -400,17 +400,17 @@ DASSL::do_integrate (const ColumnVector&
 
 Matrix
 DASSL::integrate (const ColumnVector& tout, Matrix& xdot_out,
                   const ColumnVector& tcrit)
 {
   Matrix retval;
 
   octave_idx_type n_out = tout.numel ();
-  F77_INT n = to_f77_int (size ());
+  F77_INT n = octave::to_f77_int (size ());
 
   if (n_out > 0 && n > 0)
     {
       retval.resize (n_out, n);
       xdot_out.resize (n_out, n);
 
       for (F77_INT i = 0; i < n; i++)
         {
diff --git a/liboctave/numeric/EIG.cc b/liboctave/numeric/EIG.cc
--- a/liboctave/numeric/EIG.cc
+++ b/liboctave/numeric/EIG.cc
@@ -35,18 +35,18 @@ EIG::init (const Matrix& a, bool calc_re
 {
   if (a.any_element_is_inf_or_nan ())
     (*current_liboctave_error_handler)
       ("EIG: matrix contains Inf or NaN values");
 
   if (a.is_symmetric ())
     return symmetric_init (a, calc_rev, calc_lev);
 
-  F77_INT n = to_f77_int (a.rows ());
-  F77_INT a_nc = to_f77_int (a.cols ());
+  F77_INT n = octave::to_f77_int (a.rows ());
+  F77_INT a_nc = octave::to_f77_int (a.cols ());
 
   if (n != a_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   F77_INT info = 0;
 
   Matrix atmp = a;
   double *tmp_data = atmp.fortran_vec ();
@@ -168,18 +168,18 @@ EIG::init (const Matrix& a, bool calc_re
     }
 
   return info;
 }
 
 octave_idx_type
 EIG::symmetric_init (const Matrix& a, bool calc_rev, bool calc_lev)
 {
-  F77_INT n = to_f77_int (a.rows ());
-  F77_INT a_nc = to_f77_int (a.cols ());
+  F77_INT n = octave::to_f77_int (a.rows ());
+  F77_INT a_nc = octave::to_f77_int (a.cols ());
 
   if (n != a_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   F77_INT info = 0;
 
   Matrix atmp = a;
   double *tmp_data = atmp.fortran_vec ();
@@ -227,18 +227,18 @@ EIG::init (const ComplexMatrix& a, bool 
 {
   if (a.any_element_is_inf_or_nan ())
     (*current_liboctave_error_handler)
       ("EIG: matrix contains Inf or NaN values");
 
   if (a.is_hermitian ())
     return hermitian_init (a, calc_rev, calc_lev);
 
-  F77_INT n = to_f77_int (a.rows ());
-  F77_INT a_nc = to_f77_int (a.cols ());
+  F77_INT n = octave::to_f77_int (a.rows ());
+  F77_INT a_nc = octave::to_f77_int (a.cols ());
 
   if (n != a_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   F77_INT info = 0;
 
   ComplexMatrix atmp = a;
   Complex *tmp_data = atmp.fortran_vec ();
@@ -321,18 +321,18 @@ EIG::init (const ComplexMatrix& a, bool 
   w = vltmp;
 
   return info;
 }
 
 octave_idx_type
 EIG::hermitian_init (const ComplexMatrix& a, bool calc_rev, bool calc_lev)
 {
-  F77_INT n = to_f77_int (a.rows ());
-  F77_INT a_nc = to_f77_int (a.cols ());
+  F77_INT n = octave::to_f77_int (a.rows ());
+  F77_INT a_nc = octave::to_f77_int (a.cols ());
 
   if (n != a_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   F77_INT info = 0;
 
   ComplexMatrix atmp = a;
   Complex *tmp_data = atmp.fortran_vec ();
@@ -385,21 +385,21 @@ EIG::hermitian_init (const ComplexMatrix
 octave_idx_type
 EIG::init (const Matrix& a, const Matrix& b, bool calc_rev, bool calc_lev,
            bool force_qz)
 {
   if (a.any_element_is_inf_or_nan () || b.any_element_is_inf_or_nan ())
     (*current_liboctave_error_handler)
       ("EIG: matrix contains Inf or NaN values");
 
-  F77_INT n = to_f77_int (a.rows ());
-  F77_INT nb = to_f77_int (b.rows ());
+  F77_INT n = octave::to_f77_int (a.rows ());
+  F77_INT nb = octave::to_f77_int (b.rows ());
 
-  F77_INT a_nc = to_f77_int (a.cols ());
-  F77_INT b_nc = to_f77_int (b.cols ());
+  F77_INT a_nc = octave::to_f77_int (a.cols ());
+  F77_INT b_nc = octave::to_f77_int (b.cols ());
     
   if (n != a_nc || nb != b_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
     (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
   F77_INT info = 0;
@@ -522,21 +522,21 @@ EIG::init (const Matrix& a, const Matrix
 
   return info;
 }
 
 octave_idx_type
 EIG::symmetric_init (const Matrix& a, const Matrix& b, bool calc_rev,
                      bool calc_lev)
 {
-  F77_INT n = to_f77_int (a.rows ());
-  F77_INT nb = to_f77_int (b.rows ());
+  F77_INT n = octave::to_f77_int (a.rows ());
+  F77_INT nb = octave::to_f77_int (b.rows ());
 
-  F77_INT a_nc = to_f77_int (a.cols ());
-  F77_INT b_nc = to_f77_int (b.cols ());
+  F77_INT a_nc = octave::to_f77_int (a.cols ());
+  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
   if (n != a_nc || nb != b_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
     (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
   F77_INT info = 0;
@@ -592,21 +592,21 @@ EIG::symmetric_init (const Matrix& a, co
 octave_idx_type
 EIG::init (const ComplexMatrix& a, const ComplexMatrix& b, bool calc_rev,
            bool calc_lev, bool force_qz)
 {
   if (a.any_element_is_inf_or_nan () || b.any_element_is_inf_or_nan ())
     (*current_liboctave_error_handler)
       ("EIG: matrix contains Inf or NaN values");
 
-  F77_INT n = to_f77_int (a.rows ());
-  F77_INT nb = to_f77_int (b.rows ());
+  F77_INT n = octave::to_f77_int (a.rows ());
+  F77_INT nb = octave::to_f77_int (b.rows ());
 
-  F77_INT a_nc = to_f77_int (a.cols ());
-  F77_INT b_nc = to_f77_int (b.cols ());
+  F77_INT a_nc = octave::to_f77_int (a.cols ());
+  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
   if (n != a_nc || nb != b_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
     (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
   F77_INT info = 0;
@@ -699,21 +699,21 @@ EIG::init (const ComplexMatrix& a, const
 
   return info;
 }
 
 octave_idx_type
 EIG::hermitian_init (const ComplexMatrix& a, const ComplexMatrix& b,
                      bool calc_rev, bool calc_lev)
 {
-  F77_INT n = to_f77_int (a.rows ());
-  F77_INT nb = to_f77_int (b.rows ());
+  F77_INT n = octave::to_f77_int (a.rows ());
+  F77_INT nb = octave::to_f77_int (b.rows ());
 
-  F77_INT a_nc = to_f77_int (a.cols ());
-  F77_INT b_nc = to_f77_int (b.cols ());
+  F77_INT a_nc = octave::to_f77_int (a.cols ());
+  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
   if (n != a_nc || nb != b_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
     (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
   F77_INT info = 0;
diff --git a/liboctave/numeric/LSODE.cc b/liboctave/numeric/LSODE.cc
--- a/liboctave/numeric/LSODE.cc
+++ b/liboctave/numeric/LSODE.cc
@@ -115,17 +115,17 @@ LSODE::do_integrate (double tout)
   if (! initialized || restart || ODEFunc::reset || LSODE_options::reset)
     {
       integration_error = false;
 
       initialized = true;
 
       istate = 1;
 
-      F77_INT n = to_f77_int (size ());
+      F77_INT n = octave::to_f77_int (size ());
 
       nn = n;
 
       octave_idx_type max_maxord = 0;
 
       if (integration_method () == "stiff")
         {
           max_maxord = 5;
@@ -159,17 +159,17 @@ LSODE::do_integrate (double tout)
         rwork(i) = 0;
 
       octave_idx_type maxord = maximum_order ();
 
       if (maxord >= 0)
         {
           if (maxord > 0 && maxord <= max_maxord)
             {
-              iwork(4) = to_f77_int (maxord);
+              iwork(4) = octave::to_f77_int (maxord);
               iopt = 1;
             }
           else
             {
               // FIXME: Should this be a warning?
               (*current_liboctave_error_handler)
                 ("lsode: invalid value for maximum order");
               integration_error = true;
@@ -215,17 +215,17 @@ LSODE::do_integrate (double tout)
 
       ODEFunc::reset = false;
 
       // LSODE_options
 
       rel_tol = relative_tolerance ();
       abs_tol = absolute_tolerance ();
 
-      F77_INT abs_tol_len = to_f77_int (abs_tol.numel ());
+      F77_INT abs_tol_len = octave::to_f77_int (abs_tol.numel ());
 
       if (abs_tol_len == 1)
         itol = 1;
       else if (abs_tol_len == n)
         itol = 2;
       else
         {
           // FIXME: Should this be a warning?
@@ -252,34 +252,34 @@ LSODE::do_integrate (double tout)
 
       double minss = minimum_step_size ();
       if (minss >= 0.0)
         {
           rwork(6) = minss;
           iopt = 1;
         }
 
-      F77_INT sl = to_f77_int (step_limit ());
+      F77_INT sl = octave::to_f77_int (step_limit ());
       if (sl > 0)
         {
           iwork(5) = sl;
           iopt = 1;
         }
 
       LSODE_options::reset = false;
     }
 
   double *px = x.fortran_vec ();
 
   double *pabs_tol = abs_tol.fortran_vec ();
 
   F77_INT *piwork = iwork.fortran_vec ();
   double *prwork = rwork.fortran_vec ();
 
-  F77_INT tmp_istate = to_f77_int (istate);
+  F77_INT tmp_istate = octave::to_f77_int (istate);
 
   F77_XFCN (dlsode, DLSODE, (lsode_f, nn, px, t, tout, itol, rel_tol,
                              pabs_tol, itask, tmp_istate, iopt, prwork, lrw,
                              piwork, liw, lsode_j, method_flag));
 
   istate = tmp_istate;
 
   switch (istate)
@@ -379,17 +379,17 @@ LSODE::error_message (void) const
 }
 
 Matrix
 LSODE::do_integrate (const ColumnVector& tout)
 {
   Matrix retval;
 
   octave_idx_type n_out = tout.numel ();
-  F77_INT n = to_f77_int (size ());
+  F77_INT n = octave::to_f77_int (size ());
 
   if (n_out > 0 && n > 0)
     {
       retval.resize (n_out, n);
 
       for (F77_INT i = 0; i < n; i++)
         retval.elem (0, i) = x.elem (i);
 
@@ -409,17 +409,17 @@ LSODE::do_integrate (const ColumnVector&
 }
 
 Matrix
 LSODE::do_integrate (const ColumnVector& tout, const ColumnVector& tcrit)
 {
   Matrix retval;
 
   octave_idx_type n_out = tout.numel ();
-  F77_INT n = to_f77_int (size ());
+  F77_INT n = octave::to_f77_int (size ());
 
   if (n_out > 0 && n > 0)
     {
       retval.resize (n_out, n);
 
       for (F77_INT i = 0; i < n; i++)
         retval.elem (0, i) = x.elem (i);
 
diff --git a/liboctave/numeric/Quad.cc b/liboctave/numeric/Quad.cc
--- a/liboctave/numeric/Quad.cc
+++ b/liboctave/numeric/Quad.cc
@@ -121,17 +121,17 @@ float_user_function (float *x, int& ierr
 
   return 0;
 }
 
 double
 DefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval,
                        double& abserr)
 {
-  F77_INT npts = to_f77_int (singularities.numel () + 2);
+  F77_INT npts = octave::to_f77_int (singularities.numel () + 2);
   double *points = singularities.fortran_vec ();
   double result = 0.0;
 
   F77_INT leniw = 183*npts - 122;
   Array<F77_INT> iwork (dim_vector (leniw, 1));
   F77_INT *piwork = iwork.fortran_vec ();
 
   F77_INT lenw = 2*leniw - npts;
@@ -238,17 +238,17 @@ FloatDefQuad::do_integrate (octave_idx_t
 {
   (*current_liboctave_error_handler) ("incorrect integration function called");
 }
 
 float
 FloatDefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval,
                             float& abserr)
 {
-  F77_INT npts = to_f77_int (singularities.numel () + 2);
+  F77_INT npts = octave::to_f77_int (singularities.numel () + 2);
   float *points = singularities.fortran_vec ();
   float result = 0.0;
 
   F77_INT leniw = 183*npts - 122;
   Array<F77_INT> iwork (dim_vector (leniw, 1));
   F77_INT *piwork = iwork.fortran_vec ();
 
   F77_INT lenw = 2*leniw - npts;
diff --git a/liboctave/numeric/aepbalance.cc b/liboctave/numeric/aepbalance.cc
--- a/liboctave/numeric/aepbalance.cc
+++ b/liboctave/numeric/aepbalance.cc
@@ -48,17 +48,17 @@ namespace octave
 {
   namespace math
   {
     template <>
     aepbalance<Matrix>::aepbalance (const Matrix& a, bool noperm, bool noscal)
       : balanced_mat (a), scale (), ilo (), ihi (),
         job (get_job (noperm, noscal))
     {
-      F77_INT n = to_f77_int (a.cols ());
+      F77_INT n = octave::to_f77_int (a.cols ());
 
       if (a.rows () != n)
         (*current_liboctave_error_handler) ("aepbalance: requires square matrix");
 
       scale = ColumnVector (n);
 
       F77_INT info, t_ilo, t_ihi;
 
@@ -70,25 +70,25 @@ namespace octave
       ilo = t_ilo;
       ihi = t_ihi;
     }
 
     template <>
     Matrix
     aepbalance<Matrix>::balancing_matrix (void) const
     {
-      F77_INT n = to_f77_int (balanced_mat.rows ());
+      F77_INT n = octave::to_f77_int (balanced_mat.rows ());
 
       Matrix balancing_mat (n, n, 0.0);
       for (F77_INT i = 0; i < n; i++)
         balancing_mat.elem (i ,i) = 1.0;
 
       F77_INT info;
-      F77_INT t_ilo = to_f77_int (ilo);
-      F77_INT t_ihi = to_f77_int (ihi);
+      F77_INT t_ilo = octave::to_f77_int (ilo);
+      F77_INT t_ihi = octave::to_f77_int (ihi);
 
       char side = 'R';
 
       F77_XFCN (dgebak, DGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
                                  F77_CONST_CHAR_ARG2 (&side, 1),
                                  n, t_ilo, t_ihi, scale.data (), n,
                                  balancing_mat.fortran_vec (), n, info
                                  F77_CHAR_ARG_LEN (1)
@@ -98,17 +98,17 @@ namespace octave
     }
 
     template <>
     aepbalance<FloatMatrix>::aepbalance (const FloatMatrix& a, bool noperm,
                                          bool noscal)
       : balanced_mat (a), scale (), ilo (), ihi (),
         job (get_job (noperm, noscal))
     {
-      F77_INT n = to_f77_int (a.cols ());
+      F77_INT n = octave::to_f77_int (a.cols ());
 
       if (a.rows () != n)
         (*current_liboctave_error_handler) ("aepbalance: requires square matrix");
 
       scale = FloatColumnVector (n);
 
       F77_INT info, t_ilo, t_ihi;
 
@@ -120,25 +120,25 @@ namespace octave
       ilo = t_ilo;
       ihi = t_ihi;
     }
 
     template <>
     FloatMatrix
     aepbalance<FloatMatrix>::balancing_matrix (void) const
     {
-      F77_INT n = to_f77_int (balanced_mat.rows ());
+      F77_INT n = octave::to_f77_int (balanced_mat.rows ());
 
       FloatMatrix balancing_mat (n, n, 0.0);
       for (F77_INT i = 0; i < n; i++)
         balancing_mat.elem (i ,i) = 1.0;
 
       F77_INT info;
-      F77_INT t_ilo = to_f77_int (ilo);
-      F77_INT t_ihi = to_f77_int (ihi);
+      F77_INT t_ilo = octave::to_f77_int (ilo);
+      F77_INT t_ihi = octave::to_f77_int (ihi);
 
       char side = 'R';
 
       F77_XFCN (sgebak, SGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
                                  F77_CONST_CHAR_ARG2 (&side, 1),
                                  n, t_ilo, t_ihi, scale.data (), n,
                                  balancing_mat.fortran_vec (), n, info
                                  F77_CHAR_ARG_LEN (1)
@@ -148,17 +148,17 @@ namespace octave
     }
 
     template <>
     aepbalance<ComplexMatrix>::aepbalance (const ComplexMatrix& a, bool noperm,
                                            bool noscal)
       : balanced_mat (a), scale (), ilo (), ihi (),
         job (get_job (noperm, noscal))
     {
-      F77_INT n = to_f77_int (a.cols ());
+      F77_INT n = octave::to_f77_int (a.cols ());
 
       if (a.rows () != n)
         (*current_liboctave_error_handler) ("aepbalance: requires square matrix");
 
       scale = ColumnVector (n);
 
       F77_INT info, t_ilo, t_ihi;
 
@@ -170,25 +170,25 @@ namespace octave
       ilo = t_ilo;
       ihi = t_ihi;
     }
 
     template <>
     ComplexMatrix
     aepbalance<ComplexMatrix>::balancing_matrix (void) const
     {
-      F77_INT n = to_f77_int (balanced_mat.rows ());
+      F77_INT n = octave::to_f77_int (balanced_mat.rows ());
 
       ComplexMatrix balancing_mat (n, n, 0.0);
       for (F77_INT i = 0; i < n; i++)
         balancing_mat.elem (i, i) = 1.0;
 
       F77_INT info;
-      F77_INT t_ilo = to_f77_int (ilo);
-      F77_INT t_ihi = to_f77_int (ihi);
+      F77_INT t_ilo = octave::to_f77_int (ilo);
+      F77_INT t_ihi = octave::to_f77_int (ihi);
 
       char side = 'R';
 
       F77_XFCN (zgebak, ZGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
                                  F77_CONST_CHAR_ARG2 (&side, 1),
                                  n, t_ilo, t_ihi, scale.data (), n,
                                  F77_DBLE_CMPLX_ARG (balancing_mat.fortran_vec ()),
                                  n, info
@@ -199,17 +199,17 @@ namespace octave
     }
 
     template <>
     aepbalance<FloatComplexMatrix>::aepbalance (const FloatComplexMatrix& a,
                                                 bool noperm, bool noscal)
       : balanced_mat (a), scale (), ilo (), ihi (),
         job (get_job (noperm, noscal))
     {
-      F77_INT n = to_f77_int (a.cols ());
+      F77_INT n = octave::to_f77_int (a.cols ());
 
       if (a.rows () != n)
         (*current_liboctave_error_handler) ("aepbalance: requires square matrix");
 
       scale = FloatColumnVector (n);
 
       F77_INT info, t_ilo, t_ihi;
 
@@ -221,25 +221,25 @@ namespace octave
       ilo = t_ilo;
       ihi = t_ihi;
     }
 
     template <>
     FloatComplexMatrix
     aepbalance<FloatComplexMatrix>::balancing_matrix (void) const
     {
-      F77_INT n = to_f77_int (balanced_mat.rows ());
+      F77_INT n = octave::to_f77_int (balanced_mat.rows ());
 
       FloatComplexMatrix balancing_mat (n, n, 0.0);
       for (F77_INT i = 0; i < n; i++)
         balancing_mat.elem (i, i) = 1.0;
 
       F77_INT info;
-      F77_INT t_ilo = to_f77_int (ilo);
-      F77_INT t_ihi = to_f77_int (ihi);
+      F77_INT t_ilo = octave::to_f77_int (ilo);
+      F77_INT t_ihi = octave::to_f77_int (ihi);
 
       char side = 'R';
 
       F77_XFCN (cgebak, CGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
                                  F77_CONST_CHAR_ARG2 (&side, 1),
                                  n, t_ilo, t_ihi, scale.data (), n,
                                  F77_CMPLX_ARG (balancing_mat.fortran_vec ()),
                                  n, info
diff --git a/liboctave/numeric/chol.cc b/liboctave/numeric/chol.cc
--- a/liboctave/numeric/chol.cc
+++ b/liboctave/numeric/chol.cc
@@ -56,17 +56,17 @@ chol2inv_internal (const Matrix& r, bool
   Matrix retval;
 
   octave_idx_type r_nr = r.rows ();
   octave_idx_type r_nc = r.cols ();
 
   if (r_nr != r_nc)
     (*current_liboctave_error_handler) ("chol2inv requires square matrix");
 
-  F77_INT n = to_f77_int (r_nc);
+  F77_INT n = octave::to_f77_int (r_nc);
   F77_INT info = 0;
 
   Matrix tmp = r;
   double *v = tmp.fortran_vec ();
 
   if (info == 0)
     {
       if (is_upper)
@@ -105,17 +105,17 @@ chol2inv_internal (const FloatMatrix& r,
   FloatMatrix retval;
 
   octave_idx_type r_nr = r.rows ();
   octave_idx_type r_nc = r.cols ();
 
   if (r_nr != r_nc)
     (*current_liboctave_error_handler) ("chol2inv requires square matrix");
 
-  F77_INT n = to_f77_int (r_nc);
+  F77_INT n = octave::to_f77_int (r_nc);
   F77_INT info = 0;
 
   FloatMatrix tmp = r;
   float *v = tmp.fortran_vec ();
 
   if (info == 0)
     {
       if (is_upper)
@@ -154,17 +154,17 @@ chol2inv_internal (const ComplexMatrix& 
   ComplexMatrix retval;
 
   octave_idx_type r_nr = r.rows ();
   octave_idx_type r_nc = r.cols ();
 
   if (r_nr != r_nc)
     (*current_liboctave_error_handler) ("chol2inv requires square matrix");
 
-  F77_INT n = to_f77_int (r_nc);
+  F77_INT n = octave::to_f77_int (r_nc);
   F77_INT info;
 
   ComplexMatrix tmp = r;
 
   if (is_upper)
     F77_XFCN (zpotri, ZPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
                                F77_DBLE_CMPLX_ARG (tmp.fortran_vec ()), n, info
                                F77_CHAR_ARG_LEN (1)));
@@ -199,17 +199,17 @@ chol2inv_internal (const FloatComplexMat
   FloatComplexMatrix retval;
 
   octave_idx_type r_nr = r.rows ();
   octave_idx_type r_nc = r.cols ();
 
   if (r_nr != r_nc)
     (*current_liboctave_error_handler) ("chol2inv requires square matrix");
 
-  F77_INT n = to_f77_int (r_nc);
+  F77_INT n = octave::to_f77_int (r_nc);
   F77_INT info;
 
   FloatComplexMatrix tmp = r;
 
   if (is_upper)
     F77_XFCN (cpotri, CPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
                                F77_CMPLX_ARG (tmp.fortran_vec ()), n, info
                                F77_CHAR_ARG_LEN (1)));
@@ -415,17 +415,17 @@ namespace octave
     chol<Matrix>::init (const Matrix& a, bool upper, bool calc_cond)
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       if (a_nr != a_nc)
         (*current_liboctave_error_handler) ("chol: requires square matrix");
 
-      F77_INT n = to_f77_int (a_nc);
+      F77_INT n = octave::to_f77_int (a_nc);
       F77_INT info;
 
       is_upper = upper;
 
       chol_mat.clear (n, n);
       if (is_upper)
         for (octave_idx_type j = 0; j < n; j++)
           {
@@ -484,17 +484,17 @@ namespace octave
     }
 
 #if defined (HAVE_QRUPDATE)
 
     template <>
     void
     chol<Matrix>::update (const ColumnVector& u)
     {
-      F77_INT n = to_f77_int (chol_mat.rows ());
+      F77_INT n = octave::to_f77_int (chol_mat.rows ());
 
       if (u.numel () != n)
         (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
       ColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (double, w, n);
 
@@ -503,17 +503,17 @@ namespace octave
     }
 
     template <>
     octave_idx_type
     chol<Matrix>::downdate (const ColumnVector& u)
     {
       F77_INT info = -1;
 
-      F77_INT n = to_f77_int (chol_mat.rows ());
+      F77_INT n = octave::to_f77_int (chol_mat.rows ());
 
       if (u.numel () != n)
         (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
       ColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (double, w, n);
 
@@ -524,61 +524,61 @@ namespace octave
     }
 
     template <>
     octave_idx_type
     chol<Matrix>::insert_sym (const ColumnVector& u, octave_idx_type j_arg)
     {
       F77_INT info = -1;
 
-      F77_INT n = to_f77_int (chol_mat.rows ());
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT n = octave::to_f77_int (chol_mat.rows ());
+      F77_INT j = octave::to_f77_int (j_arg);
 
       if (u.numel () != n + 1)
         (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
       if (j < 0 || j > n)
         (*current_liboctave_error_handler) ("cholinsert: index out of range");
 
       ColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (double, w, n);
 
       chol_mat.resize (n+1, n+1);
-      F77_INT ldcm = to_f77_int (chol_mat.rows ());
+      F77_INT ldcm = octave::to_f77_int (chol_mat.rows ());
 
       F77_XFCN (dchinx, DCHINX, (n, chol_mat.fortran_vec (), ldcm,
                                  j + 1, utmp.fortran_vec (), w, info));
 
       return info;
     }
 
     template <>
     void
     chol<Matrix>::delete_sym (octave_idx_type j_arg)
     {
-      F77_INT n = to_f77_int (chol_mat.rows ());
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT n = octave::to_f77_int (chol_mat.rows ());
+      F77_INT j = octave::to_f77_int (j_arg);
 
       if (j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("choldelete: index out of range");
 
       OCTAVE_LOCAL_BUFFER (double, w, n);
 
       F77_XFCN (dchdex, DCHDEX, (n, chol_mat.fortran_vec (), n, j + 1, w));
 
       chol_mat.resize (n-1, n-1);
     }
 
     template <>
     void
     chol<Matrix>::shift_sym (octave_idx_type i_arg, octave_idx_type j_arg)
     {
-      F77_INT n = to_f77_int (chol_mat.rows ());
-      F77_INT i = to_f77_int (i_arg);
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT n = octave::to_f77_int (chol_mat.rows ());
+      F77_INT i = octave::to_f77_int (i_arg);
+      F77_INT j = octave::to_f77_int (j_arg);
 
       if (i < 0 || i > n-1 || j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("cholshift: index out of range");
 
       OCTAVE_LOCAL_BUFFER (double, w, 2*n);
 
       F77_XFCN (dchshx, DCHSHX, (n, chol_mat.fortran_vec (), n,
                                  i + 1, j + 1, w));
@@ -591,17 +591,17 @@ namespace octave
     chol<FloatMatrix>::init (const FloatMatrix& a, bool upper, bool calc_cond)
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       if (a_nr != a_nc)
         (*current_liboctave_error_handler) ("chol: requires square matrix");
 
-      F77_INT n = to_f77_int (a_nc);
+      F77_INT n = octave::to_f77_int (a_nc);
       F77_INT info;
 
       is_upper = upper;
 
       chol_mat.clear (n, n);
       if (is_upper)
         for (octave_idx_type j = 0; j < n; j++)
           {
@@ -660,17 +660,17 @@ namespace octave
     }
 
 #if defined (HAVE_QRUPDATE)
 
     template <>
     void
     chol<FloatMatrix>::update (const FloatColumnVector& u)
     {
-      F77_INT n = to_f77_int (chol_mat.rows ());
+      F77_INT n = octave::to_f77_int (chol_mat.rows ());
 
       if (u.numel () != n)
         (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
       FloatColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (float, w, n);
 
@@ -679,17 +679,17 @@ namespace octave
     }
 
     template <>
     octave_idx_type
     chol<FloatMatrix>::downdate (const FloatColumnVector& u)
     {
       F77_INT info = -1;
 
-      F77_INT n = to_f77_int (chol_mat.rows ());
+      F77_INT n = octave::to_f77_int (chol_mat.rows ());
 
       if (u.numel () != n)
         (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
       FloatColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (float, w, n);
 
@@ -701,62 +701,62 @@ namespace octave
 
     template <>
     octave_idx_type
     chol<FloatMatrix>::insert_sym (const FloatColumnVector& u,
                                    octave_idx_type j_arg)
     {
       F77_INT info = -1;
 
-      F77_INT n = to_f77_int (chol_mat.rows ());
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT n = octave::to_f77_int (chol_mat.rows ());
+      F77_INT j = octave::to_f77_int (j_arg);
 
       if (u.numel () != n + 1)
         (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
       if (j < 0 || j > n)
         (*current_liboctave_error_handler) ("cholinsert: index out of range");
 
       FloatColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (float, w, n);
 
       chol_mat.resize (n+1, n+1);
-      F77_INT ldcm = to_f77_int (chol_mat.rows ());
+      F77_INT ldcm = octave::to_f77_int (chol_mat.rows ());
 
       F77_XFCN (schinx, SCHINX, (n, chol_mat.fortran_vec (), ldcm,
                                  j + 1, utmp.fortran_vec (), w, info));
 
       return info;
     }
 
     template <>
     void
     chol<FloatMatrix>::delete_sym (octave_idx_type j_arg)
     {
-      F77_INT n = to_f77_int (chol_mat.rows ());
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT n = octave::to_f77_int (chol_mat.rows ());
+      F77_INT j = octave::to_f77_int (j_arg);
 
       if (j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("choldelete: index out of range");
 
       OCTAVE_LOCAL_BUFFER (float, w, n);
 
       F77_XFCN (schdex, SCHDEX, (n, chol_mat.fortran_vec (), n,
                                  j + 1, w));
 
       chol_mat.resize (n-1, n-1);
     }
 
     template <>
     void
     chol<FloatMatrix>::shift_sym (octave_idx_type i_arg, octave_idx_type j_arg)
     {
-      F77_INT n = to_f77_int (chol_mat.rows ());
-      F77_INT i = to_f77_int (i_arg);
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT n = octave::to_f77_int (chol_mat.rows ());
+      F77_INT i = octave::to_f77_int (i_arg);
+      F77_INT j = octave::to_f77_int (j_arg);
 
       if (i < 0 || i > n-1 || j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("cholshift: index out of range");
 
       OCTAVE_LOCAL_BUFFER (float, w, 2*n);
 
       F77_XFCN (schshx, SCHSHX, (n, chol_mat.fortran_vec (), n,
                                  i + 1, j + 1, w));
@@ -769,17 +769,17 @@ namespace octave
     chol<ComplexMatrix>::init (const ComplexMatrix& a, bool upper, bool calc_cond)
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       if (a_nr != a_nc)
         (*current_liboctave_error_handler) ("chol: requires square matrix");
 
-      F77_INT n = to_f77_int (a_nc);
+      F77_INT n = octave::to_f77_int (a_nc);
       F77_INT info;
 
       is_upper = upper;
 
       chol_mat.clear (n, n);
       if (is_upper)
         for (octave_idx_type j = 0; j < n; j++)
           {
@@ -837,17 +837,17 @@ namespace octave
     }
 
 #if defined (HAVE_QRUPDATE)
 
     template <>
     void
     chol<ComplexMatrix>::update (const ComplexColumnVector& u)
     {
-      F77_INT n = to_f77_int (chol_mat.rows ());
+      F77_INT n = octave::to_f77_int (chol_mat.rows ());
 
       if (u.numel () != n)
         (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
       ComplexColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (double, rw, n);
 
@@ -859,17 +859,17 @@ namespace octave
     }
 
     template <>
     octave_idx_type
     chol<ComplexMatrix>::downdate (const ComplexColumnVector& u)
     {
       F77_INT info = -1;
 
-      F77_INT n = to_f77_int (chol_mat.rows ());
+      F77_INT n = octave::to_f77_int (chol_mat.rows ());
 
       if (u.numel () != n)
         (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
       ComplexColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (double, rw, n);
 
@@ -884,46 +884,46 @@ namespace octave
 
     template <>
     octave_idx_type
     chol<ComplexMatrix>::insert_sym (const ComplexColumnVector& u,
                                      octave_idx_type j_arg)
     {
       F77_INT info = -1;
 
-      F77_INT n = to_f77_int (chol_mat.rows ());
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT n = octave::to_f77_int (chol_mat.rows ());
+      F77_INT j = octave::to_f77_int (j_arg);
 
       if (u.numel () != n + 1)
         (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
       if (j < 0 || j > n)
         (*current_liboctave_error_handler) ("cholinsert: index out of range");
 
       ComplexColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (double, rw, n);
 
       chol_mat.resize (n+1, n+1);
-      F77_INT ldcm = to_f77_int (chol_mat.rows ());
+      F77_INT ldcm = octave::to_f77_int (chol_mat.rows ());
 
       F77_XFCN (zchinx, ZCHINX, (n,
                                  F77_DBLE_CMPLX_ARG (chol_mat.fortran_vec ()),
                                  ldcm, j + 1,
                                  F77_DBLE_CMPLX_ARG (utmp.fortran_vec ()),
                                  rw, info));
 
       return info;
     }
 
     template <>
     void
     chol<ComplexMatrix>::delete_sym (octave_idx_type j_arg)
     {
-      F77_INT n = to_f77_int (chol_mat.rows ());
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT n = octave::to_f77_int (chol_mat.rows ());
+      F77_INT j = octave::to_f77_int (j_arg);
 
       if (j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("choldelete: index out of range");
 
       OCTAVE_LOCAL_BUFFER (double, rw, n);
 
       F77_XFCN (zchdex, ZCHDEX, (n,
                                  F77_DBLE_CMPLX_ARG (chol_mat.fortran_vec ()),
@@ -932,19 +932,19 @@ namespace octave
       chol_mat.resize (n-1, n-1);
     }
 
     template <>
     void
     chol<ComplexMatrix>::shift_sym (octave_idx_type i_arg,
                                     octave_idx_type j_arg)
     {
-      F77_INT n = to_f77_int (chol_mat.rows ());
-      F77_INT i = to_f77_int (i_arg);
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT n = octave::to_f77_int (chol_mat.rows ());
+      F77_INT i = octave::to_f77_int (i_arg);
+      F77_INT j = octave::to_f77_int (j_arg);
 
       if (i < 0 || i > n-1 || j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("cholshift: index out of range");
 
       OCTAVE_LOCAL_BUFFER (Complex, w, n);
       OCTAVE_LOCAL_BUFFER (double, rw, n);
 
       F77_XFCN (zchshx, ZCHSHX, (n,
@@ -961,17 +961,17 @@ namespace octave
                                     bool calc_cond)
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       if (a_nr != a_nc)
         (*current_liboctave_error_handler) ("chol: requires square matrix");
 
-      F77_INT n = to_f77_int (a_nc);
+      F77_INT n = octave::to_f77_int (a_nc);
       F77_INT info;
 
       is_upper = upper;
 
       chol_mat.clear (n, n);
       if (is_upper)
         for (octave_idx_type j = 0; j < n; j++)
           {
@@ -1029,17 +1029,17 @@ namespace octave
     }
 
 #if defined (HAVE_QRUPDATE)
 
     template <>
     void
     chol<FloatComplexMatrix>::update (const FloatComplexColumnVector& u)
     {
-      F77_INT n = to_f77_int (chol_mat.rows ());
+      F77_INT n = octave::to_f77_int (chol_mat.rows ());
 
       if (u.numel () != n)
         (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
       FloatComplexColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (float, rw, n);
 
@@ -1048,17 +1048,17 @@ namespace octave
     }
 
     template <>
     octave_idx_type
     chol<FloatComplexMatrix>::downdate (const FloatComplexColumnVector& u)
     {
       F77_INT info = -1;
 
-      F77_INT n = to_f77_int (chol_mat.rows ());
+      F77_INT n = octave::to_f77_int (chol_mat.rows ());
 
       if (u.numel () != n)
         (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
       FloatComplexColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (float, rw, n);
 
@@ -1070,46 +1070,46 @@ namespace octave
     }
 
     template <>
     octave_idx_type
     chol<FloatComplexMatrix>::insert_sym (const FloatComplexColumnVector& u,
                                           octave_idx_type j_arg)
     {
       F77_INT info = -1;
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT j = octave::to_f77_int (j_arg);
 
-      F77_INT n = to_f77_int (chol_mat.rows ());
+      F77_INT n = octave::to_f77_int (chol_mat.rows ());
 
       if (u.numel () != n + 1)
         (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
       if (j < 0 || j > n)
         (*current_liboctave_error_handler) ("cholinsert: index out of range");
 
       FloatComplexColumnVector utmp = u;
 
       OCTAVE_LOCAL_BUFFER (float, rw, n);
 
       chol_mat.resize (n+1, n+1);
-      F77_INT ldcm = to_f77_int (chol_mat.rows ());
+      F77_INT ldcm = octave::to_f77_int (chol_mat.rows ());
 
       F77_XFCN (cchinx, CCHINX, (n, F77_CMPLX_ARG (chol_mat.fortran_vec ()),
                                  ldcm, j + 1,
                                  F77_CMPLX_ARG (utmp.fortran_vec ()),
                                  rw, info));
 
       return info;
     }
 
     template <>
     void
     chol<FloatComplexMatrix>::delete_sym (octave_idx_type j_arg)
     {
-      F77_INT n = to_f77_int (chol_mat.rows ());
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT n = octave::to_f77_int (chol_mat.rows ());
+      F77_INT j = octave::to_f77_int (j_arg);
 
       if (j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("choldelete: index out of range");
 
       OCTAVE_LOCAL_BUFFER (float, rw, n);
 
       F77_XFCN (cchdex, CCHDEX, (n, F77_CMPLX_ARG (chol_mat.fortran_vec ()),
                                  n, j + 1, rw));
@@ -1117,19 +1117,19 @@ namespace octave
       chol_mat.resize (n-1, n-1);
     }
 
     template <>
     void
     chol<FloatComplexMatrix>::shift_sym (octave_idx_type i_arg,
                                          octave_idx_type j_arg)
     {
-      F77_INT n = to_f77_int (chol_mat.rows ());
-      F77_INT i = to_f77_int (i_arg);
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT n = octave::to_f77_int (chol_mat.rows ());
+      F77_INT i = octave::to_f77_int (i_arg);
+      F77_INT j = octave::to_f77_int (j_arg);
 
       if (i < 0 || i > n-1 || j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("cholshift: index out of range");
 
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, n);
       OCTAVE_LOCAL_BUFFER (float, rw, n);
 
       F77_XFCN (cchshx, CCHSHX, (n, F77_CMPLX_ARG (chol_mat.fortran_vec ()),
diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -134,18 +134,18 @@ vector_product (const SparseMatrix& m, c
       y[m.ridx (i)] += m.data (i) * x[j];
 
   return true;
 }
 
 static bool
 vector_product (const Matrix& m, const double *x, double *y)
 {
-  F77_INT nr = to_f77_int (m.rows ());
-  F77_INT nc = to_f77_int (m.cols ());
+  F77_INT nr = octave::to_f77_int (m.rows ());
+  F77_INT nc = octave::to_f77_int (m.cols ());
 
   F77_XFCN (dgemv, DGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            nr, nc, 1.0,  m.data (), nr,
                            x, 1, 0.0, y, 1
                            F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("eigs: unrecoverable error in dgemv");
@@ -167,18 +167,18 @@ vector_product (const SparseComplexMatri
       y[m.ridx (i)] += m.data (i) * x[j];
 
   return true;
 }
 
 static bool
 vector_product (const ComplexMatrix& m, const Complex *x, Complex *y)
 {
-  F77_INT nr = to_f77_int (m.rows ());
-  F77_INT nc = to_f77_int (m.cols ());
+  F77_INT nr = octave::to_f77_int (m.rows ());
+  F77_INT nc = octave::to_f77_int (m.cols ());
 
   F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            nr, nc, 1.0, F77_CONST_DBLE_CMPLX_ARG (m.data ()),
                            nr,
                            F77_CONST_DBLE_CMPLX_ARG (x), 1, 0.0,
                            F77_DBLE_CMPLX_ARG (y), 1
                            F77_CHAR_ARG_LEN (1)));
 
@@ -596,20 +596,20 @@ octave_idx_type
 EigsRealSymmetricMatrix (const M& m, const std::string typ,
                          octave_idx_type k_arg, octave_idx_type p_arg,
                          octave_idx_type &info, Matrix &eig_vec,
                          ColumnVector &eig_val, const M& _b,
                          ColumnVector &permB, ColumnVector &resid,
                          std::ostream& os, double tol, bool rvec,
                          bool cholB, int disp, int maxit)
 {
-  F77_INT k = to_f77_int (k_arg);
-  F77_INT p = to_f77_int (p_arg);
+  F77_INT k = octave::to_f77_int (k_arg);
+  F77_INT p = octave::to_f77_int (p_arg);
   M b(_b);
-  F77_INT n = to_f77_int (m.cols ());
+  F77_INT n = octave::to_f77_int (m.cols ());
   F77_INT mode = 1;
   bool have_b = ! b.is_empty ();
   bool note3 = false;
   char bmat = 'I';
   double sigma = 0.;
   M bt;
 
   if (m.rows () != m.cols ())
@@ -724,17 +724,17 @@ EigsRealSymmetricMatrix (const M& m, con
 
   OCTAVE_LOCAL_BUFFER (double, v, n * p);
   OCTAVE_LOCAL_BUFFER (double, workl, lwork);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n);
   double *presid = resid.fortran_vec ();
 
   do
     {
-      F77_INT tmp_info = to_f77_int (info);
+      F77_INT tmp_info = octave::to_f77_int (info);
 
       F77_FUNC (dsaupd, DSAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, tmp_info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
@@ -874,20 +874,20 @@ octave_idx_type
 EigsRealSymmetricMatrixShift (const M& m, double sigma,
                               octave_idx_type k_arg, octave_idx_type p_arg,
                               octave_idx_type &info, Matrix &eig_vec,
                               ColumnVector &eig_val, const M& _b,
                               ColumnVector &permB, ColumnVector &resid,
                               std::ostream& os, double tol, bool rvec,
                               bool cholB, int disp, int maxit)
 {
-  F77_INT k = to_f77_int (k_arg);
-  F77_INT p = to_f77_int (p_arg);
+  F77_INT k = octave::to_f77_int (k_arg);
+  F77_INT p = octave::to_f77_int (p_arg);
   M b(_b);
-  F77_INT n = to_f77_int (m.cols ());
+  F77_INT n = octave::to_f77_int (m.cols ());
   F77_INT mode = 3;
   bool have_b = ! b.is_empty ();
   std::string typ = "LM";
 
   if (m.rows () != m.cols ())
     (*current_liboctave_error_handler) ("eigs: A must be square");
   if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
     (*current_liboctave_error_handler)
@@ -985,17 +985,17 @@ EigsRealSymmetricMatrixShift (const M& m
 
   OCTAVE_LOCAL_BUFFER (double, v, n * p);
   OCTAVE_LOCAL_BUFFER (double, workl, lwork);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n);
   double *presid = resid.fortran_vec ();
 
   do
     {
-      F77_INT tmp_info = to_f77_int (info);
+      F77_INT tmp_info = octave::to_f77_int (info);
 
       F77_FUNC (dsaupd, DSAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, tmp_info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
@@ -1169,19 +1169,19 @@ octave_idx_type
 EigsRealSymmetricFunc (EigsFunc fun, octave_idx_type n_arg,
                        const std::string &_typ, double sigma,
                        octave_idx_type k_arg, octave_idx_type p_arg,
                        octave_idx_type &info, Matrix &eig_vec,
                        ColumnVector &eig_val, ColumnVector &resid,
                        std::ostream& os, double tol, bool rvec,
                        bool /* cholB */, int disp, int maxit)
 {
-  F77_INT n = to_f77_int (n_arg);
-  F77_INT k = to_f77_int (k_arg);
-  F77_INT p = to_f77_int (p_arg);
+  F77_INT n = octave::to_f77_int (n_arg);
+  F77_INT k = octave::to_f77_int (k_arg);
+  F77_INT p = octave::to_f77_int (p_arg);
   std::string typ (_typ);
   bool have_sigma = (sigma ? true : false);
   char bmat = 'I';
   F77_INT mode = 1;
   int err = 0;
 
   if (resid.is_empty ())
     {
@@ -1266,17 +1266,17 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
 
   OCTAVE_LOCAL_BUFFER (double, v, n * p);
   OCTAVE_LOCAL_BUFFER (double, workl, lwork);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n);
   double *presid = resid.fortran_vec ();
 
   do
     {
-      F77_INT tmp_info = to_f77_int (info);
+      F77_INT tmp_info = octave::to_f77_int (info);
 
       F77_FUNC (dsaupd, DSAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, tmp_info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
@@ -1414,20 +1414,20 @@ octave_idx_type
 EigsRealNonSymmetricMatrix (const M& m, const std::string typ,
                             octave_idx_type k_arg, octave_idx_type p_arg,
                             octave_idx_type &info, ComplexMatrix &eig_vec,
                             ComplexColumnVector &eig_val, const M& _b,
                             ColumnVector &permB, ColumnVector &resid,
                             std::ostream& os, double tol, bool rvec,
                             bool cholB, int disp, int maxit)
 {
-  F77_INT k = to_f77_int (k_arg);
-  F77_INT p = to_f77_int (p_arg);
+  F77_INT k = octave::to_f77_int (k_arg);
+  F77_INT p = octave::to_f77_int (p_arg);
   M b(_b);
-  F77_INT n = to_f77_int (m.cols ());
+  F77_INT n = octave::to_f77_int (m.cols ());
   F77_INT mode = 1;
   bool have_b = ! b.is_empty ();
   bool note3 = false;
   char bmat = 'I';
   double sigmar = 0.;
   double sigmai = 0.;
   M bt;
 
@@ -1543,17 +1543,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
 
   OCTAVE_LOCAL_BUFFER (double, v, n * (p + 1));
   OCTAVE_LOCAL_BUFFER (double, workl, lwork + 1);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n + 1);
   double *presid = resid.fortran_vec ();
 
   do
     {
-      F77_INT tmp_info = to_f77_int (info);
+      F77_INT tmp_info = octave::to_f77_int (info);
 
       F77_FUNC (dnaupd, DNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, tmp_info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
@@ -1741,20 +1741,20 @@ EigsRealNonSymmetricMatrixShift (const M
                                  octave_idx_type k_arg, octave_idx_type p_arg,
                                  octave_idx_type &info,
                                  ComplexMatrix &eig_vec,
                                  ComplexColumnVector &eig_val, const M& _b,
                                  ColumnVector &permB, ColumnVector &resid,
                                  std::ostream& os, double tol, bool rvec,
                                  bool cholB, int disp, int maxit)
 {
-  F77_INT k = to_f77_int (k_arg);
-  F77_INT p = to_f77_int (p_arg);
+  F77_INT k = octave::to_f77_int (k_arg);
+  F77_INT p = octave::to_f77_int (p_arg);
   M b(_b);
-  F77_INT n = to_f77_int (m.cols ());
+  F77_INT n = octave::to_f77_int (m.cols ());
   F77_INT mode = 3;
   bool have_b = ! b.is_empty ();
   std::string typ = "LM";
   double sigmai = 0.;
 
   if (m.rows () != m.cols ())
     (*current_liboctave_error_handler) ("eigs: A must be square");
   if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
@@ -1853,17 +1853,17 @@ EigsRealNonSymmetricMatrixShift (const M
 
   OCTAVE_LOCAL_BUFFER (double, v, n * (p + 1));
   OCTAVE_LOCAL_BUFFER (double, workl, lwork + 1);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n + 1);
   double *presid = resid.fortran_vec ();
 
   do
     {
-      F77_INT tmp_info = to_f77_int (info);
+      F77_INT tmp_info = octave::to_f77_int (info);
 
       F77_FUNC (dnaupd, DNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, tmp_info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
@@ -2090,19 +2090,19 @@ octave_idx_type
 EigsRealNonSymmetricFunc (EigsFunc fun, octave_idx_type n_arg,
                           const std::string &_typ, double sigmar,
                           octave_idx_type k_arg, octave_idx_type p_arg,
                           octave_idx_type &info, ComplexMatrix &eig_vec,
                           ComplexColumnVector &eig_val, ColumnVector &resid,
                           std::ostream& os, double tol, bool rvec,
                           bool /* cholB */, int disp, int maxit)
 {
-  F77_INT n = to_f77_int (n_arg);
-  F77_INT k = to_f77_int (k_arg);
-  F77_INT p = to_f77_int (p_arg);
+  F77_INT n = octave::to_f77_int (n_arg);
+  F77_INT k = octave::to_f77_int (k_arg);
+  F77_INT p = octave::to_f77_int (p_arg);
   std::string typ (_typ);
   bool have_sigma = (sigmar ? true : false);
   char bmat = 'I';
   double sigmai = 0.;
   F77_INT mode = 1;
   int err = 0;
 
   if (resid.is_empty ())
@@ -2188,17 +2188,17 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
 
   OCTAVE_LOCAL_BUFFER (double, v, n * (p + 1));
   OCTAVE_LOCAL_BUFFER (double, workl, lwork + 1);
   OCTAVE_LOCAL_BUFFER (double, workd, 3 * n + 1);
   double *presid = resid.fortran_vec ();
 
   do
     {
-      F77_INT tmp_info = to_f77_int (info);
+      F77_INT tmp_info = octave::to_f77_int (info);
 
       F77_FUNC (dnaupd, DNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, presid, p, v, n, iparam,
          ipntr, workd, workl, lwork, tmp_info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
@@ -2383,20 +2383,20 @@ EigsComplexNonSymmetricMatrix (const M& 
                                octave_idx_type k_arg, octave_idx_type p_arg,
                                octave_idx_type &info, ComplexMatrix &eig_vec,
                                ComplexColumnVector &eig_val, const M& _b,
                                ColumnVector &permB,
                                ComplexColumnVector &cresid,
                                std::ostream& os, double tol, bool rvec,
                                bool cholB, int disp, int maxit)
 {
-  F77_INT k = to_f77_int (k_arg);
-  F77_INT p = to_f77_int (p_arg);
+  F77_INT k = octave::to_f77_int (k_arg);
+  F77_INT p = octave::to_f77_int (p_arg);
   M b(_b);
-  F77_INT n = to_f77_int (m.cols ());
+  F77_INT n = octave::to_f77_int (m.cols ());
   F77_INT mode = 1;
   bool have_b = ! b.is_empty ();
   bool note3 = false;
   char bmat = 'I';
   Complex sigma = 0.;
   M bt;
 
   if (m.rows () != m.cols ())
@@ -2516,17 +2516,17 @@ EigsComplexNonSymmetricMatrix (const M& 
   OCTAVE_LOCAL_BUFFER (Complex, v, n * p);
   OCTAVE_LOCAL_BUFFER (Complex, workl, lwork);
   OCTAVE_LOCAL_BUFFER (Complex, workd, 3 * n);
   OCTAVE_LOCAL_BUFFER (double, rwork, p);
   Complex *presid = cresid.fortran_vec ();
 
   do
     {
-      F77_INT tmp_info = to_f77_int (info);
+      F77_INT tmp_info = octave::to_f77_int (info);
 
       F77_FUNC (znaupd, ZNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 (typ.c_str (), 2),
          k, tol, F77_DBLE_CMPLX_ARG (presid), p, F77_DBLE_CMPLX_ARG (v), n,
          iparam, ipntr,
          F77_DBLE_CMPLX_ARG (workd), F77_DBLE_CMPLX_ARG (workl), lwork, rwork,
          tmp_info F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
@@ -2669,20 +2669,20 @@ EigsComplexNonSymmetricMatrixShift (cons
                                     octave_idx_type &info,
                                     ComplexMatrix &eig_vec,
                                     ComplexColumnVector &eig_val, const M& _b,
                                     ColumnVector &permB,
                                     ComplexColumnVector &cresid,
                                     std::ostream& os, double tol, bool rvec,
                                     bool cholB, int disp, int maxit)
 {
-  F77_INT k = to_f77_int (k_arg);
-  F77_INT p = to_f77_int (p_arg);
+  F77_INT k = octave::to_f77_int (k_arg);
+  F77_INT p = octave::to_f77_int (p_arg);
   M b(_b);
-  F77_INT n = to_f77_int (m.cols ());
+  F77_INT n = octave::to_f77_int (m.cols ());
   F77_INT mode = 3;
   bool have_b = ! b.is_empty ();
   std::string typ = "LM";
 
   if (m.rows () != m.cols ())
     (*current_liboctave_error_handler) ("eigs: A must be square");
   if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
     (*current_liboctave_error_handler)
@@ -2785,17 +2785,17 @@ EigsComplexNonSymmetricMatrixShift (cons
   OCTAVE_LOCAL_BUFFER (Complex, v, n * p);
   OCTAVE_LOCAL_BUFFER (Complex, workl, lwork);
   OCTAVE_LOCAL_BUFFER (Complex, workd, 3 * n);
   OCTAVE_LOCAL_BUFFER (double, rwork, p);
   Complex *presid = cresid.fortran_vec ();
 
   do
     {
-      F77_INT tmp_info = to_f77_int (info);
+      F77_INT tmp_info = octave::to_f77_int (info);
 
       F77_FUNC (znaupd, ZNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, F77_DBLE_CMPLX_ARG (presid), p, F77_DBLE_CMPLX_ARG (v), n,
          iparam, ipntr,
          F77_DBLE_CMPLX_ARG (workd), F77_DBLE_CMPLX_ARG (workl), lwork, rwork,
          tmp_info F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
@@ -2980,19 +2980,19 @@ EigsComplexNonSymmetricFunc (EigsComplex
                              const std::string &_typ, Complex sigma,
                              octave_idx_type k_arg, octave_idx_type p_arg,
                              octave_idx_type &info, ComplexMatrix &eig_vec,
                              ComplexColumnVector &eig_val,
                              ComplexColumnVector &cresid, std::ostream& os,
                              double tol, bool rvec, bool /* cholB */,
                              int disp, int maxit)
 {
-  F77_INT n = to_f77_int (n_arg);
-  F77_INT k = to_f77_int (k_arg);
-  F77_INT p = to_f77_int (p_arg);
+  F77_INT n = octave::to_f77_int (n_arg);
+  F77_INT k = octave::to_f77_int (k_arg);
+  F77_INT p = octave::to_f77_int (p_arg);
   std::string typ (_typ);
   bool have_sigma = (std::abs (sigma) ? true : false);
   char bmat = 'I';
   F77_INT mode = 1;
   int err = 0;
 
   if (cresid.is_empty ())
     {
@@ -3083,17 +3083,17 @@ EigsComplexNonSymmetricFunc (EigsComplex
   OCTAVE_LOCAL_BUFFER (Complex, v, n * p);
   OCTAVE_LOCAL_BUFFER (Complex, workl, lwork);
   OCTAVE_LOCAL_BUFFER (Complex, workd, 3 * n);
   OCTAVE_LOCAL_BUFFER (double, rwork, p);
   Complex *presid = cresid.fortran_vec ();
 
   do
     {
-      F77_INT tmp_info = to_f77_int (info);
+      F77_INT tmp_info = octave::to_f77_int (info);
 
       F77_FUNC (znaupd, ZNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
          k, tol, F77_DBLE_CMPLX_ARG (presid), p, F77_DBLE_CMPLX_ARG (v), n,
          iparam, ipntr,
          F77_DBLE_CMPLX_ARG (workd), F77_DBLE_CMPLX_ARG (workl), lwork, rwork,
          tmp_info F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
diff --git a/liboctave/numeric/fEIG.cc b/liboctave/numeric/fEIG.cc
--- a/liboctave/numeric/fEIG.cc
+++ b/liboctave/numeric/fEIG.cc
@@ -36,18 +36,18 @@ FloatEIG::init (const FloatMatrix& a, bo
 {
   if (a.any_element_is_inf_or_nan ())
     (*current_liboctave_error_handler)
       ("EIG: matrix contains Inf or NaN values");
 
   if (a.is_symmetric ())
     return symmetric_init (a, calc_rev, calc_lev);
 
-  F77_INT n = to_f77_int (a.rows ());
-  F77_INT a_nc = to_f77_int (a.cols ());
+  F77_INT n = octave::to_f77_int (a.rows ());
+  F77_INT a_nc = octave::to_f77_int (a.cols ());
 
   if (n != a_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   F77_INT info = 0;
 
   FloatMatrix atmp = a;
   float *tmp_data = atmp.fortran_vec ();
@@ -166,18 +166,18 @@ FloatEIG::init (const FloatMatrix& a, bo
     }
 
   return info;
 }
 
 octave_idx_type
 FloatEIG::symmetric_init (const FloatMatrix& a, bool calc_rev, bool calc_lev)
 {
-  F77_INT n = to_f77_int (a.rows ());
-  F77_INT a_nc = to_f77_int (a.cols ());
+  F77_INT n = octave::to_f77_int (a.rows ());
+  F77_INT a_nc = octave::to_f77_int (a.cols ());
 
   if (n != a_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   F77_INT info = 0;
 
   FloatMatrix atmp = a;
   float *tmp_data = atmp.fortran_vec ();
@@ -226,18 +226,18 @@ FloatEIG::init (const FloatComplexMatrix
 {
   if (a.any_element_is_inf_or_nan ())
     (*current_liboctave_error_handler)
       ("EIG: matrix contains Inf or NaN values");
 
   if (a.is_hermitian ())
     return hermitian_init (a, calc_rev, calc_lev);
 
-  F77_INT n = to_f77_int (a.rows ());
-  F77_INT a_nc = to_f77_int (a.cols ());
+  F77_INT n = octave::to_f77_int (a.rows ());
+  F77_INT a_nc = octave::to_f77_int (a.cols ());
 
   if (n != a_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   F77_INT info = 0;
 
   FloatComplexMatrix atmp = a;
   FloatComplex *tmp_data = atmp.fortran_vec ();
@@ -319,18 +319,18 @@ FloatEIG::init (const FloatComplexMatrix
 
   return info;
 }
 
 octave_idx_type
 FloatEIG::hermitian_init (const FloatComplexMatrix& a, bool calc_rev,
                           bool calc_lev)
 {
-  F77_INT n = to_f77_int (a.rows ());
-  F77_INT a_nc = to_f77_int (a.cols ());
+  F77_INT n = octave::to_f77_int (a.rows ());
+  F77_INT a_nc = octave::to_f77_int (a.cols ());
 
   if (n != a_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   F77_INT info = 0;
 
   FloatComplexMatrix atmp = a;
   FloatComplex *tmp_data = atmp.fortran_vec ();
@@ -383,21 +383,21 @@ FloatEIG::hermitian_init (const FloatCom
 octave_idx_type
 FloatEIG::init (const FloatMatrix& a, const FloatMatrix& b, bool calc_rev,
                 bool calc_lev, bool force_qz)
 {
   if (a.any_element_is_inf_or_nan () || b.any_element_is_inf_or_nan ())
     (*current_liboctave_error_handler)
       ("EIG: matrix contains Inf or NaN values");
 
-  F77_INT n = to_f77_int (a.rows ());
-  F77_INT nb = to_f77_int (b.rows ());
+  F77_INT n = octave::to_f77_int (a.rows ());
+  F77_INT nb = octave::to_f77_int (b.rows ());
 
-  F77_INT a_nc = to_f77_int (a.cols ());
-  F77_INT b_nc = to_f77_int (b.cols ());
+  F77_INT a_nc = octave::to_f77_int (a.cols ());
+  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
   if (n != a_nc || nb != b_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
     (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
   F77_INT info = 0;
@@ -518,21 +518,21 @@ FloatEIG::init (const FloatMatrix& a, co
 
   return info;
 }
 
 octave_idx_type
 FloatEIG::symmetric_init (const FloatMatrix& a, const FloatMatrix& b,
                           bool calc_rev, bool calc_lev)
 {
-  F77_INT n = to_f77_int (a.rows ());
-  F77_INT nb = to_f77_int (b.rows ());
+  F77_INT n = octave::to_f77_int (a.rows ());
+  F77_INT nb = octave::to_f77_int (b.rows ());
 
-  F77_INT a_nc = to_f77_int (a.cols ());
-  F77_INT b_nc = to_f77_int (b.cols ());
+  F77_INT a_nc = octave::to_f77_int (a.cols ());
+  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
   if (n != a_nc || nb != b_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
     (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
   F77_INT info = 0;
@@ -588,21 +588,21 @@ FloatEIG::symmetric_init (const FloatMat
 octave_idx_type
 FloatEIG::init (const FloatComplexMatrix& a, const FloatComplexMatrix& b,
                 bool calc_rev, bool calc_lev, bool force_qz)
 {
   if (a.any_element_is_inf_or_nan () || b.any_element_is_inf_or_nan ())
     (*current_liboctave_error_handler)
       ("EIG: matrix contains Inf or NaN values");
 
-  F77_INT n = to_f77_int (a.rows ());
-  F77_INT nb = to_f77_int (b.rows ());
+  F77_INT n = octave::to_f77_int (a.rows ());
+  F77_INT nb = octave::to_f77_int (b.rows ());
 
-  F77_INT a_nc = to_f77_int (a.cols ());
-  F77_INT b_nc = to_f77_int (b.cols ());
+  F77_INT a_nc = octave::to_f77_int (a.cols ());
+  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
   if (n != a_nc || nb != b_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
     (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
   F77_INT info = 0;
@@ -692,21 +692,21 @@ FloatEIG::init (const FloatComplexMatrix
   return info;
 }
 
 octave_idx_type
 FloatEIG::hermitian_init (const FloatComplexMatrix& a,
                           const FloatComplexMatrix& b,
                           bool calc_rev, bool calc_lev)
 {
-  F77_INT n = to_f77_int (a.rows ());
-  F77_INT nb = to_f77_int (b.rows ());
+  F77_INT n = octave::to_f77_int (a.rows ());
+  F77_INT nb = octave::to_f77_int (b.rows ());
 
-  F77_INT a_nc = to_f77_int (a.cols ());
-  F77_INT b_nc = to_f77_int (b.cols ());
+  F77_INT a_nc = octave::to_f77_int (a.cols ());
+  F77_INT b_nc = octave::to_f77_int (b.cols ());
 
   if (n != a_nc || nb != b_nc)
     (*current_liboctave_error_handler) ("EIG requires square matrix");
 
   if (n != nb)
     (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
   F77_INT info = 0;
diff --git a/liboctave/numeric/gepbalance.cc b/liboctave/numeric/gepbalance.cc
--- a/liboctave/numeric/gepbalance.cc
+++ b/liboctave/numeric/gepbalance.cc
@@ -40,17 +40,17 @@ namespace octave
 {
   namespace math
   {
     template <>
     octave_idx_type
     gepbalance<Matrix>::init (const Matrix& a, const Matrix& b,
                               const std::string& balance_job)
     {
-      F77_INT n = to_f77_int (a.cols ());
+      F77_INT n = octave::to_f77_int (a.cols ());
 
       if (a.rows () != n)
         (*current_liboctave_error_handler) ("GEPBALANCE requires square matrix");
 
       if (a.dims () != b.dims ())
         octave::err_nonconformant ("GEPBALANCE", n, n, b.rows(), b.cols());
 
       F77_INT info;
@@ -104,17 +104,17 @@ namespace octave
       return info;
     }
 
     template <>
     octave_idx_type
     gepbalance<FloatMatrix>::init (const FloatMatrix& a, const FloatMatrix& b,
                                    const std::string& balance_job)
     {
-      F77_INT n = to_f77_int (a.cols ());
+      F77_INT n = octave::to_f77_int (a.cols ());
 
       if (a.rows () != n)
         (*current_liboctave_error_handler)
           ("FloatGEPBALANCE requires square matrix");
 
       if (a.dims () != b.dims ())
         octave::err_nonconformant ("FloatGEPBALANCE", n, n, b.rows(), b.cols());
 
@@ -170,17 +170,17 @@ namespace octave
     }
 
     template <>
     octave_idx_type
     gepbalance<ComplexMatrix>::init (const ComplexMatrix& a,
                                      const ComplexMatrix& b,
                                      const std::string& balance_job)
     {
-      F77_INT n = to_f77_int (a.cols ());
+      F77_INT n = octave::to_f77_int (a.cols ());
 
       if (a.rows () != n)
         (*current_liboctave_error_handler)
           ("ComplexGEPBALANCE requires square matrix");
 
       if (a.dims () != b.dims ())
         octave::err_nonconformant ("ComplexGEPBALANCE", n, n, b.rows(), b.cols());
 
@@ -236,17 +236,17 @@ namespace octave
     }
 
     template <>
     octave_idx_type
     gepbalance<FloatComplexMatrix>::init (const FloatComplexMatrix& a,
                                           const FloatComplexMatrix& b,
                                           const std::string& balance_job)
     {
-      F77_INT n = to_f77_int (a.cols ());
+      F77_INT n = octave::to_f77_int (a.cols ());
 
       if (a.rows () != n)
         {
           (*current_liboctave_error_handler)
             ("FloatComplexGEPBALANCE requires square matrix");
           return -1;
         }
 
diff --git a/liboctave/numeric/gsvd.cc b/liboctave/numeric/gsvd.cc
--- a/liboctave/numeric/gsvd.cc
+++ b/liboctave/numeric/gsvd.cc
@@ -205,19 +205,19 @@ namespace octave
         return R;
     }
 
     template <typename T>
     gsvd<T>::gsvd (const T& a, const T& b, gsvd::Type gsvd_type)
     {
       F77_INT info;
 
-      F77_INT m = to_f77_int (a.rows ());
-      F77_INT n = to_f77_int (a.cols ());
-      F77_INT p = to_f77_int (b.rows ());
+      F77_INT m = octave::to_f77_int (a.rows ());
+      F77_INT n = octave::to_f77_int (a.cols ());
+      F77_INT p = octave::to_f77_int (b.rows ());
 
       T atmp = a;
       P *tmp_dataA = atmp.fortran_vec ();
 
       T btmp = b;
       P *tmp_dataB = btmp.fortran_vec ();
 
       char jobu = 'U';
diff --git a/liboctave/numeric/hess.cc b/liboctave/numeric/hess.cc
--- a/liboctave/numeric/hess.cc
+++ b/liboctave/numeric/hess.cc
@@ -35,18 +35,18 @@ along with Octave; see the file COPYING.
 namespace octave
 {
   namespace math
   {
     template <>
     octave_idx_type
     hess<Matrix>::init (const Matrix& a)
     {
-      F77_INT a_nr = to_f77_int (a.rows ());
-      F77_INT a_nc = to_f77_int (a.cols ());
+      F77_INT a_nr = octave::to_f77_int (a.rows ());
+      F77_INT a_nc = octave::to_f77_int (a.cols ());
 
       if (a_nr != a_nc)
         (*current_liboctave_error_handler) ("hess: requires square matrix");
 
       char job = 'N';
       char side = 'R';
 
       F77_INT n = a_nc;
@@ -98,18 +98,18 @@ namespace octave
 
       return info;
     }
 
     template <>
     octave_idx_type
     hess<FloatMatrix>::init (const FloatMatrix& a)
     {
-      F77_INT a_nr = to_f77_int (a.rows ());
-      F77_INT a_nc = to_f77_int (a.cols ());
+      F77_INT a_nr = octave::to_f77_int (a.rows ());
+      F77_INT a_nc = octave::to_f77_int (a.cols ());
 
       if (a_nr != a_nc)
         (*current_liboctave_error_handler) ("hess: requires square matrix");
 
       char job = 'N';
       char side = 'R';
 
       F77_INT n = a_nc;
@@ -161,18 +161,18 @@ namespace octave
 
       return info;
     }
 
     template <>
     octave_idx_type
     hess<ComplexMatrix>::init (const ComplexMatrix& a)
     {
-      F77_INT a_nr = to_f77_int (a.rows ());
-      F77_INT a_nc = to_f77_int (a.cols ());
+      F77_INT a_nr = octave::to_f77_int (a.rows ());
+      F77_INT a_nc = octave::to_f77_int (a.cols ());
 
       if (a_nr != a_nc)
         (*current_liboctave_error_handler) ("hess: requires square matrix");
 
       char job = 'N';
       char side = 'R';
 
       F77_INT n = a_nc;
@@ -224,18 +224,18 @@ namespace octave
 
       return info;
     }
 
     template <>
     octave_idx_type
     hess<FloatComplexMatrix>::init (const FloatComplexMatrix& a)
     {
-      F77_INT a_nr = to_f77_int (a.rows ());
-      F77_INT a_nc = to_f77_int (a.cols ());
+      F77_INT a_nr = octave::to_f77_int (a.rows ());
+      F77_INT a_nc = octave::to_f77_int (a.cols ());
 
       if (a_nr != a_nc)
         {
           (*current_liboctave_error_handler) ("hess: requires square matrix");
           return -1;
         }
 
       char job = 'N';
diff --git a/liboctave/numeric/lo-specfun.cc b/liboctave/numeric/lo-specfun.cc
--- a/liboctave/numeric/lo-specfun.cc
+++ b/liboctave/numeric/lo-specfun.cc
@@ -3810,29 +3810,29 @@ namespace octave
     static inline void
     fortran_psifn (T z, octave_idx_type n, T& ans, octave_idx_type& ierr);
 
     template <>
     inline void
     fortran_psifn<double> (double z, octave_idx_type n_arg,
                            double& ans, octave_idx_type& ierr)
     {
-      F77_INT n = to_f77_int (n_arg);
+      F77_INT n = octave::to_f77_int (n_arg);
       F77_INT flag = 0;
       F77_INT t_ierr;
       F77_XFCN (dpsifn, DPSIFN, (z, n, 1, 1, ans, flag, t_ierr));
       ierr = t_ierr;
     }
 
     template <>
     inline void
     fortran_psifn<float> (float z, octave_idx_type n_arg,
                           float& ans, octave_idx_type& ierr)
     {
-      F77_INT n = to_f77_int (n_arg);
+      F77_INT n = octave::to_f77_int (n_arg);
       F77_INT flag = 0;
       F77_INT t_ierr;
       F77_XFCN (psifn, PSIFN, (z, n, 1, 1, ans, flag, t_ierr));
       ierr = t_ierr;
     }
 
     template <typename T>
     T
diff --git a/liboctave/numeric/lu.cc b/liboctave/numeric/lu.cc
--- a/liboctave/numeric/lu.cc
+++ b/liboctave/numeric/lu.cc
@@ -247,18 +247,18 @@ namespace octave
 
 #endif
 
     // Specializations.
 
     template <>
     lu<Matrix>::lu (const Matrix& a)
     {
-      F77_INT a_nr = to_f77_int (a.rows ());
-      F77_INT a_nc = to_f77_int (a.columns ());
+      F77_INT a_nr = octave::to_f77_int (a.rows ());
+      F77_INT a_nc = octave::to_f77_int (a.columns ());
       F77_INT mn = (a_nr < a_nc ? a_nr : a_nc);
 
       ipvt.resize (dim_vector (mn, 1));
       F77_INT *pipvt = ipvt.fortran_vec ();
 
       a_fact = a;
       double *tmp_data = a_fact.fortran_vec ();
 
@@ -277,22 +277,22 @@ namespace octave
     lu<Matrix>::update (const ColumnVector& u, const ColumnVector& v)
     {
       if (packed ())
         unpack ();
 
       Matrix& l = l_fact;
       Matrix& r = a_fact;
 
-      F77_INT m = to_f77_int (l.rows ());
-      F77_INT n = to_f77_int (r.columns ());
-      F77_INT k = to_f77_int (l.columns ());
+      F77_INT m = octave::to_f77_int (l.rows ());
+      F77_INT n = octave::to_f77_int (r.columns ());
+      F77_INT k = octave::to_f77_int (l.columns ());
 
-      F77_INT u_nel = to_f77_int (u.numel ());
-      F77_INT v_nel = to_f77_int (v.numel ());
+      F77_INT u_nel = octave::to_f77_int (u.numel ());
+      F77_INT v_nel = octave::to_f77_int (v.numel ());
 
       if (u_nel != m || v_nel != n)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       ColumnVector utmp = u;
       ColumnVector vtmp = v;
       F77_XFCN (dlu1up, DLU1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (), k,
                                  utmp.fortran_vec (), vtmp.fortran_vec ()));
@@ -303,25 +303,25 @@ namespace octave
     lu<Matrix>::update (const Matrix& u, const Matrix& v)
     {
       if (packed ())
         unpack ();
 
       Matrix& l = l_fact;
       Matrix& r = a_fact;
 
-      F77_INT m = to_f77_int (l.rows ());
-      F77_INT n = to_f77_int (r.columns ());
-      F77_INT k = to_f77_int (l.columns ());
+      F77_INT m = octave::to_f77_int (l.rows ());
+      F77_INT n = octave::to_f77_int (r.columns ());
+      F77_INT k = octave::to_f77_int (l.columns ());
 
-      F77_INT u_nr = to_f77_int (u.rows ());
-      F77_INT u_nc = to_f77_int (u.columns ());
+      F77_INT u_nr = octave::to_f77_int (u.rows ());
+      F77_INT u_nc = octave::to_f77_int (u.columns ());
 
-      F77_INT v_nr = to_f77_int (v.rows ());
-      F77_INT v_nc = to_f77_int (v.columns ());
+      F77_INT v_nr = octave::to_f77_int (v.rows ());
+      F77_INT v_nc = octave::to_f77_int (v.columns ());
 
       if (u_nr != m || v_nr != n || u_nc != v_nc)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       for (volatile F77_INT i = 0; i < u_nc; i++)
         {
           ColumnVector utmp = u.column (i);
           ColumnVector vtmp = v.column (i);
@@ -336,22 +336,22 @@ namespace octave
     lu<Matrix>::update_piv (const ColumnVector& u, const ColumnVector& v)
     {
       if (packed ())
         unpack ();
 
       Matrix& l = l_fact;
       Matrix& r = a_fact;
 
-      F77_INT m = to_f77_int (l.rows ());
-      F77_INT n = to_f77_int (r.columns ());
-      F77_INT k = to_f77_int (l.columns ());
+      F77_INT m = octave::to_f77_int (l.rows ());
+      F77_INT n = octave::to_f77_int (r.columns ());
+      F77_INT k = octave::to_f77_int (l.columns ());
 
-      F77_INT u_nel = to_f77_int (u.numel ());
-      F77_INT v_nel = to_f77_int (v.numel ());
+      F77_INT u_nel = octave::to_f77_int (u.numel ());
+      F77_INT v_nel = octave::to_f77_int (v.numel ());
 
       if (u_nel != m || v_nel != n)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       ColumnVector utmp = u;
       ColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (double, w, m);
       for (F77_INT i = 0; i < m; i++) ipvt(i) += 1; // increment
@@ -367,25 +367,25 @@ namespace octave
     lu<Matrix>::update_piv (const Matrix& u, const Matrix& v)
     {
       if (packed ())
         unpack ();
 
       Matrix& l = l_fact;
       Matrix& r = a_fact;
 
-      F77_INT m = to_f77_int (l.rows ());
-      F77_INT n = to_f77_int (r.columns ());
-      F77_INT k = to_f77_int (l.columns ());
+      F77_INT m = octave::to_f77_int (l.rows ());
+      F77_INT n = octave::to_f77_int (r.columns ());
+      F77_INT k = octave::to_f77_int (l.columns ());
 
-      F77_INT u_nr = to_f77_int (u.rows ());
-      F77_INT u_nc = to_f77_int (u.columns ());
+      F77_INT u_nr = octave::to_f77_int (u.rows ());
+      F77_INT u_nc = octave::to_f77_int (u.columns ());
 
-      F77_INT v_nr = to_f77_int (v.rows ());
-      F77_INT v_nc = to_f77_int (v.columns ());
+      F77_INT v_nr = octave::to_f77_int (v.rows ());
+      F77_INT v_nc = octave::to_f77_int (v.columns ());
 
       if (u_nr != m || v_nr != n || u_nc != v_nc)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       OCTAVE_LOCAL_BUFFER (double, w, m);
       for (F77_INT i = 0; i < m; i++) ipvt(i) += 1; // increment
       for (volatile F77_INT i = 0; i < u_nc; i++)
         {
@@ -399,18 +399,18 @@ namespace octave
       for (F77_INT i = 0; i < m; i++) ipvt(i) -= 1; // decrement
     }
 
 #endif
 
     template <>
     lu<FloatMatrix>::lu (const FloatMatrix& a)
     {
-      F77_INT a_nr = to_f77_int (a.rows ());
-      F77_INT a_nc = to_f77_int (a.columns ());
+      F77_INT a_nr = octave::to_f77_int (a.rows ());
+      F77_INT a_nc = octave::to_f77_int (a.columns ());
       F77_INT mn = (a_nr < a_nc ? a_nr : a_nc);
 
       ipvt.resize (dim_vector (mn, 1));
       F77_INT *pipvt = ipvt.fortran_vec ();
 
       a_fact = a;
       float *tmp_data = a_fact.fortran_vec ();
 
@@ -429,22 +429,22 @@ namespace octave
     lu<FloatMatrix>::update (const FloatColumnVector& u, const FloatColumnVector& v)
     {
       if (packed ())
         unpack ();
 
       FloatMatrix& l = l_fact;
       FloatMatrix& r = a_fact;
 
-      F77_INT m = to_f77_int (l.rows ());
-      F77_INT n = to_f77_int (r.columns ());
-      F77_INT k = to_f77_int (l.columns ());
+      F77_INT m = octave::to_f77_int (l.rows ());
+      F77_INT n = octave::to_f77_int (r.columns ());
+      F77_INT k = octave::to_f77_int (l.columns ());
 
-      F77_INT u_nel = to_f77_int (u.numel ());
-      F77_INT v_nel = to_f77_int (v.numel ());
+      F77_INT u_nel = octave::to_f77_int (u.numel ());
+      F77_INT v_nel = octave::to_f77_int (v.numel ());
 
       if (u_nel != m || v_nel != n)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       FloatColumnVector utmp = u;
       FloatColumnVector vtmp = v;
       F77_XFCN (slu1up, SLU1UP, (m, n, l.fortran_vec (),
                                  m, r.fortran_vec (), k,
@@ -456,25 +456,25 @@ namespace octave
     lu<FloatMatrix>::update (const FloatMatrix& u, const FloatMatrix& v)
     {
       if (packed ())
         unpack ();
 
       FloatMatrix& l = l_fact;
       FloatMatrix& r = a_fact;
 
-      F77_INT m = to_f77_int (l.rows ());
-      F77_INT n = to_f77_int (r.columns ());
-      F77_INT k = to_f77_int (l.columns ());
+      F77_INT m = octave::to_f77_int (l.rows ());
+      F77_INT n = octave::to_f77_int (r.columns ());
+      F77_INT k = octave::to_f77_int (l.columns ());
 
-      F77_INT u_nr = to_f77_int (u.rows ());
-      F77_INT u_nc = to_f77_int (u.columns ());
+      F77_INT u_nr = octave::to_f77_int (u.rows ());
+      F77_INT u_nc = octave::to_f77_int (u.columns ());
 
-      F77_INT v_nr = to_f77_int (v.rows ());
-      F77_INT v_nc = to_f77_int (v.columns ());
+      F77_INT v_nr = octave::to_f77_int (v.rows ());
+      F77_INT v_nc = octave::to_f77_int (v.columns ());
 
       if (u_nr != m || v_nr != n || u_nc != v_nc)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       for (volatile F77_INT i = 0; i < u_nc; i++)
         {
           FloatColumnVector utmp = u.column (i);
           FloatColumnVector vtmp = v.column (i);
@@ -490,22 +490,22 @@ namespace octave
                                  const FloatColumnVector& v)
     {
       if (packed ())
         unpack ();
 
       FloatMatrix& l = l_fact;
       FloatMatrix& r = a_fact;
 
-      F77_INT m = to_f77_int (l.rows ());
-      F77_INT n = to_f77_int (r.columns ());
-      F77_INT k = to_f77_int (l.columns ());
+      F77_INT m = octave::to_f77_int (l.rows ());
+      F77_INT n = octave::to_f77_int (r.columns ());
+      F77_INT k = octave::to_f77_int (l.columns ());
 
-      F77_INT u_nel = to_f77_int (u.numel ());
-      F77_INT v_nel = to_f77_int (v.numel ());
+      F77_INT u_nel = octave::to_f77_int (u.numel ());
+      F77_INT v_nel = octave::to_f77_int (v.numel ());
 
       if (u_nel != m || v_nel != n)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       FloatColumnVector utmp = u;
       FloatColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (float, w, m);
       for (F77_INT i = 0; i < m; i++) ipvt(i) += 1; // increment
@@ -521,25 +521,25 @@ namespace octave
     lu<FloatMatrix>::update_piv (const FloatMatrix& u, const FloatMatrix& v)
     {
       if (packed ())
         unpack ();
 
       FloatMatrix& l = l_fact;
       FloatMatrix& r = a_fact;
 
-      F77_INT m = to_f77_int (l.rows ());
-      F77_INT n = to_f77_int (r.columns ());
-      F77_INT k = to_f77_int (l.columns ());
+      F77_INT m = octave::to_f77_int (l.rows ());
+      F77_INT n = octave::to_f77_int (r.columns ());
+      F77_INT k = octave::to_f77_int (l.columns ());
 
-      F77_INT u_nr = to_f77_int (u.rows ());
-      F77_INT u_nc = to_f77_int (u.columns ());
+      F77_INT u_nr = octave::to_f77_int (u.rows ());
+      F77_INT u_nc = octave::to_f77_int (u.columns ());
 
-      F77_INT v_nr = to_f77_int (v.rows ());
-      F77_INT v_nc = to_f77_int (v.columns ());
+      F77_INT v_nr = octave::to_f77_int (v.rows ());
+      F77_INT v_nc = octave::to_f77_int (v.columns ());
 
       if (u_nr != m || v_nr != n || u_nc != v_nc)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       OCTAVE_LOCAL_BUFFER (float, w, m);
       for (F77_INT i = 0; i < m; i++) ipvt(i) += 1; // increment
       for (volatile F77_INT i = 0; i < u_nc; i++)
         {
@@ -553,18 +553,18 @@ namespace octave
       for (F77_INT i = 0; i < m; i++) ipvt(i) -= 1; // decrement
     }
 
 #endif
 
     template <>
     lu<ComplexMatrix>::lu (const ComplexMatrix& a)
     {
-      F77_INT a_nr = to_f77_int (a.rows ());
-      F77_INT a_nc = to_f77_int (a.columns ());
+      F77_INT a_nr = octave::to_f77_int (a.rows ());
+      F77_INT a_nc = octave::to_f77_int (a.columns ());
       F77_INT mn = (a_nr < a_nc ? a_nr : a_nc);
 
       ipvt.resize (dim_vector (mn, 1));
       F77_INT *pipvt = ipvt.fortran_vec ();
 
       a_fact = a;
       Complex *tmp_data = a_fact.fortran_vec ();
 
@@ -585,22 +585,22 @@ namespace octave
                                const ComplexColumnVector& v)
     {
       if (packed ())
         unpack ();
 
       ComplexMatrix& l = l_fact;
       ComplexMatrix& r = a_fact;
 
-      F77_INT m = to_f77_int (l.rows ());
-      F77_INT n = to_f77_int (r.columns ());
-      F77_INT k = to_f77_int (l.columns ());
+      F77_INT m = octave::to_f77_int (l.rows ());
+      F77_INT n = octave::to_f77_int (r.columns ());
+      F77_INT k = octave::to_f77_int (l.columns ());
 
-      F77_INT u_nel = to_f77_int (u.numel ());
-      F77_INT v_nel = to_f77_int (v.numel ());
+      F77_INT u_nel = octave::to_f77_int (u.numel ());
+      F77_INT v_nel = octave::to_f77_int (v.numel ());
 
       if (u_nel != m || v_nel != n)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       ComplexColumnVector utmp = u;
       ComplexColumnVector vtmp = v;
       F77_XFCN (zlu1up, ZLU1UP, (m, n, F77_DBLE_CMPLX_ARG (l.fortran_vec ()), m,
                                  F77_DBLE_CMPLX_ARG (r.fortran_vec ()), k,
@@ -613,25 +613,25 @@ namespace octave
     lu<ComplexMatrix>::update (const ComplexMatrix& u, const ComplexMatrix& v)
     {
       if (packed ())
         unpack ();
 
       ComplexMatrix& l = l_fact;
       ComplexMatrix& r = a_fact;
 
-      F77_INT m = to_f77_int (l.rows ());
-      F77_INT n = to_f77_int (r.columns ());
-      F77_INT k = to_f77_int (l.columns ());
+      F77_INT m = octave::to_f77_int (l.rows ());
+      F77_INT n = octave::to_f77_int (r.columns ());
+      F77_INT k = octave::to_f77_int (l.columns ());
 
-      F77_INT u_nr = to_f77_int (u.rows ());
-      F77_INT u_nc = to_f77_int (u.columns ());
+      F77_INT u_nr = octave::to_f77_int (u.rows ());
+      F77_INT u_nc = octave::to_f77_int (u.columns ());
 
-      F77_INT v_nr = to_f77_int (v.rows ());
-      F77_INT v_nc = to_f77_int (v.columns ());
+      F77_INT v_nr = octave::to_f77_int (v.rows ());
+      F77_INT v_nc = octave::to_f77_int (v.columns ());
 
       if (u_nr != m || v_nr != n || u_nc != v_nc)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       for (volatile F77_INT i = 0; i < u_nc; i++)
         {
           ComplexColumnVector utmp = u.column (i);
           ComplexColumnVector vtmp = v.column (i);
@@ -648,22 +648,22 @@ namespace octave
                                    const ComplexColumnVector& v)
     {
       if (packed ())
         unpack ();
 
       ComplexMatrix& l = l_fact;
       ComplexMatrix& r = a_fact;
 
-      F77_INT m = to_f77_int (l.rows ());
-      F77_INT n = to_f77_int (r.columns ());
-      F77_INT k = to_f77_int (l.columns ());
+      F77_INT m = octave::to_f77_int (l.rows ());
+      F77_INT n = octave::to_f77_int (r.columns ());
+      F77_INT k = octave::to_f77_int (l.columns ());
 
-      F77_INT u_nel = to_f77_int (u.numel ());
-      F77_INT v_nel = to_f77_int (v.numel ());
+      F77_INT u_nel = octave::to_f77_int (u.numel ());
+      F77_INT v_nel = octave::to_f77_int (v.numel ());
 
       if (u_nel != m || v_nel != n)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       ComplexColumnVector utmp = u;
       ComplexColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (Complex, w, m);
       for (F77_INT i = 0; i < m; i++) ipvt(i) += 1; // increment
@@ -680,25 +680,25 @@ namespace octave
     lu<ComplexMatrix>::update_piv (const ComplexMatrix& u, const ComplexMatrix& v)
     {
       if (packed ())
         unpack ();
 
       ComplexMatrix& l = l_fact;
       ComplexMatrix& r = a_fact;
 
-      F77_INT m = to_f77_int (l.rows ());
-      F77_INT n = to_f77_int (r.columns ());
-      F77_INT k = to_f77_int (l.columns ());
+      F77_INT m = octave::to_f77_int (l.rows ());
+      F77_INT n = octave::to_f77_int (r.columns ());
+      F77_INT k = octave::to_f77_int (l.columns ());
 
-      F77_INT u_nr = to_f77_int (u.rows ());
-      F77_INT u_nc = to_f77_int (u.columns ());
+      F77_INT u_nr = octave::to_f77_int (u.rows ());
+      F77_INT u_nc = octave::to_f77_int (u.columns ());
 
-      F77_INT v_nr = to_f77_int (v.rows ());
-      F77_INT v_nc = to_f77_int (v.columns ());
+      F77_INT v_nr = octave::to_f77_int (v.rows ());
+      F77_INT v_nc = octave::to_f77_int (v.columns ());
 
       if (u_nr != m || v_nr != n || u_nc != v_nc)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       OCTAVE_LOCAL_BUFFER (Complex, w, m);
       for (F77_INT i = 0; i < m; i++) ipvt(i) += 1; // increment
       for (volatile F77_INT i = 0; i < u_nc; i++)
         {
@@ -713,18 +713,18 @@ namespace octave
       for (F77_INT i = 0; i < m; i++) ipvt(i) -= 1; // decrement
     }
 
 #endif
 
     template <>
     lu<FloatComplexMatrix>::lu (const FloatComplexMatrix& a)
     {
-      F77_INT a_nr = to_f77_int (a.rows ());
-      F77_INT a_nc = to_f77_int (a.columns ());
+      F77_INT a_nr = octave::to_f77_int (a.rows ());
+      F77_INT a_nc = octave::to_f77_int (a.columns ());
       F77_INT mn = (a_nr < a_nc ? a_nr : a_nc);
 
       ipvt.resize (dim_vector (mn, 1));
       F77_INT *pipvt = ipvt.fortran_vec ();
 
       a_fact = a;
       FloatComplex *tmp_data = a_fact.fortran_vec ();
 
@@ -745,22 +745,22 @@ namespace octave
                                     const FloatComplexColumnVector& v)
     {
       if (packed ())
         unpack ();
 
       FloatComplexMatrix& l = l_fact;
       FloatComplexMatrix& r = a_fact;
 
-      F77_INT m = to_f77_int (l.rows ());
-      F77_INT n = to_f77_int (r.columns ());
-      F77_INT k = to_f77_int (l.columns ());
+      F77_INT m = octave::to_f77_int (l.rows ());
+      F77_INT n = octave::to_f77_int (r.columns ());
+      F77_INT k = octave::to_f77_int (l.columns ());
 
-      F77_INT u_nel = to_f77_int (u.numel ());
-      F77_INT v_nel = to_f77_int (v.numel ());
+      F77_INT u_nel = octave::to_f77_int (u.numel ());
+      F77_INT v_nel = octave::to_f77_int (v.numel ());
 
       if (u_nel != m || v_nel != n)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       FloatComplexColumnVector utmp = u;
       FloatComplexColumnVector vtmp = v;
       F77_XFCN (clu1up, CLU1UP, (m, n, F77_CMPLX_ARG (l.fortran_vec ()), m,
                                  F77_CMPLX_ARG (r.fortran_vec ()), k,
@@ -773,25 +773,25 @@ namespace octave
                                     const FloatComplexMatrix& v)
     {
       if (packed ())
         unpack ();
 
       FloatComplexMatrix& l = l_fact;
       FloatComplexMatrix& r = a_fact;
 
-      F77_INT m = to_f77_int (l.rows ());
-      F77_INT n = to_f77_int (r.columns ());
-      F77_INT k = to_f77_int (l.columns ());
+      F77_INT m = octave::to_f77_int (l.rows ());
+      F77_INT n = octave::to_f77_int (r.columns ());
+      F77_INT k = octave::to_f77_int (l.columns ());
 
-      F77_INT u_nr = to_f77_int (u.rows ());
-      F77_INT u_nc = to_f77_int (u.columns ());
+      F77_INT u_nr = octave::to_f77_int (u.rows ());
+      F77_INT u_nc = octave::to_f77_int (u.columns ());
 
-      F77_INT v_nr = to_f77_int (v.rows ());
-      F77_INT v_nc = to_f77_int (v.columns ());
+      F77_INT v_nr = octave::to_f77_int (v.rows ());
+      F77_INT v_nc = octave::to_f77_int (v.columns ());
 
       if (u_nr != m || v_nr != n || u_nc != v_nc)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       for (volatile F77_INT i = 0; i < u_nc; i++)
         {
           FloatComplexColumnVector utmp = u.column (i);
           FloatComplexColumnVector vtmp = v.column (i);
@@ -807,22 +807,22 @@ namespace octave
                                         const FloatComplexColumnVector& v)
     {
       if (packed ())
         unpack ();
 
       FloatComplexMatrix& l = l_fact;
       FloatComplexMatrix& r = a_fact;
 
-      F77_INT m = to_f77_int (l.rows ());
-      F77_INT n = to_f77_int (r.columns ());
-      F77_INT k = to_f77_int (l.columns ());
+      F77_INT m = octave::to_f77_int (l.rows ());
+      F77_INT n = octave::to_f77_int (r.columns ());
+      F77_INT k = octave::to_f77_int (l.columns ());
 
-      F77_INT u_nel = to_f77_int (u.numel ());
-      F77_INT v_nel = to_f77_int (v.numel ());
+      F77_INT u_nel = octave::to_f77_int (u.numel ());
+      F77_INT v_nel = octave::to_f77_int (v.numel ());
 
       if (u_nel != m || v_nel != n)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       FloatComplexColumnVector utmp = u;
       FloatComplexColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, m);
       for (F77_INT i = 0; i < m; i++) ipvt(i) += 1; // increment
@@ -840,25 +840,25 @@ namespace octave
                                         const FloatComplexMatrix& v)
     {
       if (packed ())
         unpack ();
 
       FloatComplexMatrix& l = l_fact;
       FloatComplexMatrix& r = a_fact;
 
-      F77_INT m = to_f77_int (l.rows ());
-      F77_INT n = to_f77_int (r.columns ());
-      F77_INT k = to_f77_int (l.columns ());
+      F77_INT m = octave::to_f77_int (l.rows ());
+      F77_INT n = octave::to_f77_int (r.columns ());
+      F77_INT k = octave::to_f77_int (l.columns ());
 
-      F77_INT u_nr = to_f77_int (u.rows ());
-      F77_INT u_nc = to_f77_int (u.columns ());
+      F77_INT u_nr = octave::to_f77_int (u.rows ());
+      F77_INT u_nc = octave::to_f77_int (u.columns ());
 
-      F77_INT v_nr = to_f77_int (v.rows ());
-      F77_INT v_nc = to_f77_int (v.columns ());
+      F77_INT v_nr = octave::to_f77_int (v.rows ());
+      F77_INT v_nc = octave::to_f77_int (v.columns ());
 
       if (u_nr != m || v_nr != n || u_nc != v_nc)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, m);
       for (F77_INT i = 0; i < m; i++) ipvt(i) += 1; // increment
       for (volatile F77_INT i = 0; i < u_nc; i++)
         {
diff --git a/liboctave/numeric/oct-convn.cc b/liboctave/numeric/oct-convn.cc
--- a/liboctave/numeric/oct-convn.cc
+++ b/liboctave/numeric/oct-convn.cc
@@ -87,21 +87,21 @@ FORWARD_IMPL (std::complex<float>, float
 
 template <typename T, typename R>
 void convolve_nd (const T *a, const dim_vector& ad, const dim_vector& acd,
                   const R *b, const dim_vector& bd, const dim_vector& bcd,
                   T *c, const dim_vector& ccd, int nd, bool inner)
 {
   if (nd == 2)
     {
-      F77_INT ad0 = to_f77_int (ad(0));
-      F77_INT ad1 = to_f77_int (ad(1));
+      F77_INT ad0 = octave::to_f77_int (ad(0));
+      F77_INT ad1 = octave::to_f77_int (ad(1));
 
-      F77_INT bd0 = to_f77_int (bd(0));
-      F77_INT bd1 = to_f77_int (bd(1));
+      F77_INT bd0 = octave::to_f77_int (bd(0));
+      F77_INT bd1 = octave::to_f77_int (bd(1));
 
       convolve_2d<T, R> (a, ad0, ad1, b, bd0, bd1, c, inner);
     }
   else
     {
       octave_idx_type ma = acd(nd-2);
       octave_idx_type na = ad(nd-1);
       octave_idx_type mb = bcd(nd-2);
diff --git a/liboctave/numeric/qr.cc b/liboctave/numeric/qr.cc
--- a/liboctave/numeric/qr.cc
+++ b/liboctave/numeric/qr.cc
@@ -373,18 +373,18 @@ namespace octave
 
     // Specializations.
 
     template <>
     void
     qr<Matrix>::form (octave_idx_type n_arg, Matrix& afact, double *tau,
                       type qr_type)
     {
-      F77_INT n = to_f77_int (n_arg);
-      F77_INT m = to_f77_int (afact.rows ());
+      F77_INT n = octave::to_f77_int (n_arg);
+      F77_INT m = octave::to_f77_int (afact.rows ());
       F77_INT min_mn = std::min (m, n);
       F77_INT info;
 
       if (qr_type == qr<Matrix>::raw)
         {
           for (F77_INT j = 0; j < min_mn; j++)
             {
               F77_INT limit = j < min_mn - 1 ? j : min_mn - 1;
@@ -423,17 +423,17 @@ namespace octave
                     q.xelem (i, j) = afact.xelem (i, j);
                     afact.xelem (i, j) = 0;
                   }
               r = afact;
             }
 
           if (m > 0)
             {
-              F77_INT k = to_f77_int (q.cols ());
+              F77_INT k = octave::to_f77_int (q.cols ());
               // workspace query.
               double rlwork;
               F77_XFCN (dorgqr, DORGQR, (m, k, min_mn, q.fortran_vec (), m,
                                          tau, &rlwork, -1, info));
 
               // allocate buffer and do the job.
               F77_INT lwork = static_cast<F77_INT> (rlwork);
               lwork = std::max (lwork, static_cast<F77_INT> (1));
@@ -443,18 +443,18 @@ namespace octave
             }
         }
     }
 
     template <>
     void
     qr<Matrix>::init (const Matrix& a, type qr_type)
     {
-      F77_INT m = to_f77_int (a.rows ());
-      F77_INT n = to_f77_int (a.cols ());
+      F77_INT m = octave::to_f77_int (a.rows ());
+      F77_INT n = octave::to_f77_int (a.cols ());
 
       F77_INT min_mn = m < n ? m : n;
       OCTAVE_LOCAL_BUFFER (double, tau, min_mn);
 
       F77_INT info = 0;
 
       Matrix afact = a;
       if (m > n && qr_type == qr<Matrix>::std)
@@ -479,47 +479,47 @@ namespace octave
     }
 
 #if defined (HAVE_QRUPDATE)
 
     template <>
     void
     qr<Matrix>::update (const ColumnVector& u, const ColumnVector& v)
     {
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT n = to_f77_int (r.cols ());
-      F77_INT k = to_f77_int (q.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT k = octave::to_f77_int (q.cols ());
 
-      F77_INT u_nel = to_f77_int (u.numel ());
-      F77_INT v_nel = to_f77_int (v.numel ());
+      F77_INT u_nel = octave::to_f77_int (u.numel ());
+      F77_INT v_nel = octave::to_f77_int (v.numel ());
 
       if (u_nel != m || v_nel != n)
         (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 
       ColumnVector utmp = u;
       ColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (double, w, 2*k);
       F77_XFCN (dqr1up, DQR1UP, (m, n, k, q.fortran_vec (), m,
                                  r.fortran_vec (), k, utmp.fortran_vec (),
                                  vtmp.fortran_vec (), w));
     }
 
     template <>
     void
     qr<Matrix>::update (const Matrix& u, const Matrix& v)
     {
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT n = to_f77_int (r.cols ());
-      F77_INT k = to_f77_int (q.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT k = octave::to_f77_int (q.cols ());
 
-      F77_INT u_rows = to_f77_int (u.rows ());
-      F77_INT u_cols = to_f77_int (u.cols ());
+      F77_INT u_rows = octave::to_f77_int (u.rows ());
+      F77_INT u_cols = octave::to_f77_int (u.cols ());
 
-      F77_INT v_rows = to_f77_int (v.rows ());
-      F77_INT v_cols = to_f77_int (v.cols ());
+      F77_INT v_rows = octave::to_f77_int (v.rows ());
+      F77_INT v_cols = octave::to_f77_int (v.cols ());
 
       if (u_rows != m || v_rows != n || u_cols != v_cols)
         (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 
       OCTAVE_LOCAL_BUFFER (double, w, 2*k);
       for (volatile F77_INT i = 0; i < u_cols; i++)
         {
           ColumnVector utmp = u.column (i);
@@ -529,121 +529,121 @@ namespace octave
                                      vtmp.fortran_vec (), w));
         }
     }
 
     template <>
     void
     qr<Matrix>::insert_col (const ColumnVector& u, octave_idx_type j_arg)
     {
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT j = octave::to_f77_int (j_arg);
 
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT n = to_f77_int (r.cols ());
-      F77_INT k = to_f77_int (q.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT k = octave::to_f77_int (q.cols ());
 
-      F77_INT u_nel = to_f77_int (u.numel ());
+      F77_INT u_nel = octave::to_f77_int (u.numel ());
 
       if (u_nel != m)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
 
       if (j < 0 || j > n)
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       if (k < m)
         {
           q.resize (m, k+1);
           r.resize (k+1, n+1);
         }
       else
         r.resize (k, n+1);
 
-      F77_INT ldq = to_f77_int (q.rows ());
-      F77_INT ldr = to_f77_int (r.rows ());
+      F77_INT ldq = octave::to_f77_int (q.rows ());
+      F77_INT ldr = octave::to_f77_int (r.rows ());
 
       ColumnVector utmp = u;
       OCTAVE_LOCAL_BUFFER (double, w, k);
       F77_XFCN (dqrinc, DQRINC, (m, n, k, q.fortran_vec (), ldq,
                                  r.fortran_vec (), ldr, j + 1,
                                  utmp.data (), w));
     }
 
     template <>
     void
     qr<Matrix>::insert_col (const Matrix& u, const Array<octave_idx_type>& j)
     {
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT n = to_f77_int (r.cols ());
-      F77_INT k = to_f77_int (q.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT k = octave::to_f77_int (q.cols ());
 
       Array<octave_idx_type> jsi;
       Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
-      F77_INT nj = to_f77_int (js.numel ());
+      F77_INT nj = octave::to_f77_int (js.numel ());
       bool dups = false;
       for (F77_INT i = 0; i < nj - 1; i++)
         dups = dups && js(i) == js(i+1);
 
       if (dups)
         (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
 
-      F77_INT u_nel = to_f77_int (u.numel ());
-      F77_INT u_cols = to_f77_int (u.cols ());
+      F77_INT u_nel = octave::to_f77_int (u.numel ());
+      F77_INT u_cols = octave::to_f77_int (u.cols ());
 
       if (u_nel != m || u_cols != nj)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
 
-      F77_INT js_beg = to_f77_int (js(0));
-      F77_INT js_end = to_f77_int (js(nj-1));
+      F77_INT js_beg = octave::to_f77_int (js(0));
+      F77_INT js_end = octave::to_f77_int (js(nj-1));
 
       if (nj > 0 && (js_beg < 0 || js_end > n))
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       if (nj > 0)
         {
           F77_INT kmax = std::min (k + nj, m);
           if (k < m)
             {
               q.resize (m, kmax);
               r.resize (kmax, n + nj);
             }
           else
             r.resize (k, n + nj);
 
-          F77_INT ldq = to_f77_int (q.rows ());
-          F77_INT ldr = to_f77_int (r.rows ());
+          F77_INT ldq = octave::to_f77_int (q.rows ());
+          F77_INT ldr = octave::to_f77_int (r.rows ());
 
           OCTAVE_LOCAL_BUFFER (double, w, kmax);
           for (volatile F77_INT i = 0; i < nj; i++)
             {
               F77_INT ii = i;
               ColumnVector utmp = u.column (jsi(i));
-              F77_INT js_elt = to_f77_int (js(ii));
+              F77_INT js_elt = octave::to_f77_int (js(ii));
               F77_XFCN (dqrinc, DQRINC, (m, n + ii, std::min (kmax, k + ii),
                                          q.fortran_vec (), ldq,
                                          r.fortran_vec (), ldr, js_elt + 1,
                                          utmp.data (), w));
             }
         }
     }
 
     template <>
     void
     qr<Matrix>::delete_col (octave_idx_type j_arg)
     {
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT j = octave::to_f77_int (j_arg);
 
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT k = to_f77_int (r.rows ());
-      F77_INT n = to_f77_int (r.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT k = octave::to_f77_int (r.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
 
       if (j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("qrdelete: index out of range");
 
-      F77_INT ldq = to_f77_int (q.rows ());
-      F77_INT ldr = to_f77_int (r.rows ());
+      F77_INT ldq = octave::to_f77_int (q.rows ());
+      F77_INT ldr = octave::to_f77_int (r.rows ());
 
       OCTAVE_LOCAL_BUFFER (double, w, k);
       F77_XFCN (dqrdec, DQRDEC, (m, n, k, q.fortran_vec (), ldq,
                                  r.fortran_vec (), ldr, j + 1, w));
 
       if (k < m)
         {
           q.resize (m, k-1);
@@ -652,46 +652,46 @@ namespace octave
       else
         r.resize (k, n-1);
     }
 
     template <>
     void
     qr<Matrix>::delete_col (const Array<octave_idx_type>& j)
     {
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT n = to_f77_int (r.cols ());
-      F77_INT k = to_f77_int (q.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT k = octave::to_f77_int (q.cols ());
 
       Array<octave_idx_type> jsi;
       Array<octave_idx_type> js = j.sort (jsi, 0, DESCENDING);
-      F77_INT nj = to_f77_int (js.numel ());
+      F77_INT nj = octave::to_f77_int (js.numel ());
       bool dups = false;
       for (F77_INT i = 0; i < nj - 1; i++)
         dups = dups && js(i) == js(i+1);
 
       if (dups)
         (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
 
-      F77_INT js_beg = to_f77_int (js(0));
-      F77_INT js_end = to_f77_int (js(nj-1));
+      F77_INT js_beg = octave::to_f77_int (js(0));
+      F77_INT js_end = octave::to_f77_int (js(nj-1));
 
       if (nj > 0 && (js_beg > n-1 || js_end < 0))
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       if (nj > 0)
         {
-          F77_INT ldq = to_f77_int (q.rows ());
-          F77_INT ldr = to_f77_int (r.rows ());
+          F77_INT ldq = octave::to_f77_int (q.rows ());
+          F77_INT ldr = octave::to_f77_int (r.rows ());
 
           OCTAVE_LOCAL_BUFFER (double, w, k);
           for (volatile F77_INT i = 0; i < nj; i++)
             {
               F77_INT ii = i;
-              F77_INT js_elt = to_f77_int (js(ii));
+              F77_INT js_elt = octave::to_f77_int (js(ii));
               F77_XFCN (dqrdec, DQRDEC, (m, n - ii, k == m ? k : k - ii,
                                          q.fortran_vec (), ldq,
                                          r.fortran_vec (), ldr,
                                          js_elt + 1, w));
             }
 
           if (k < m)
             {
@@ -702,103 +702,103 @@ namespace octave
             r.resize (k, n - nj);
         }
     }
 
     template <>
     void
     qr<Matrix>::insert_row (const RowVector& u, octave_idx_type j_arg)
     {
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT j = octave::to_f77_int (j_arg);
 
-      F77_INT m = to_f77_int (r.rows ());
-      F77_INT n = to_f77_int (r.cols ());
+      F77_INT m = octave::to_f77_int (r.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
       F77_INT k = std::min (m, n);
 
-      F77_INT u_nel = to_f77_int (u.numel ());
+      F77_INT u_nel = octave::to_f77_int (u.numel ());
 
       if (! q.is_square () || u_nel != n)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
 
       if (j < 0 || j > m)
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       q.resize (m + 1, m + 1);
       r.resize (m + 1, n);
 
-      F77_INT ldq = to_f77_int (q.rows ());
-      F77_INT ldr = to_f77_int (r.rows ());
+      F77_INT ldq = octave::to_f77_int (q.rows ());
+      F77_INT ldr = octave::to_f77_int (r.rows ());
 
       RowVector utmp = u;
       OCTAVE_LOCAL_BUFFER (double, w, k);
       F77_XFCN (dqrinr, DQRINR, (m, n, q.fortran_vec (), ldq,
                                  r.fortran_vec (), ldr,
                                  j + 1, utmp.fortran_vec (), w));
 
     }
 
     template <>
     void
     qr<Matrix>::delete_row (octave_idx_type j_arg)
     {
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT j = octave::to_f77_int (j_arg);
 
-      F77_INT m = to_f77_int (r.rows ());
-      F77_INT n = to_f77_int (r.cols ());
+      F77_INT m = octave::to_f77_int (r.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
 
       if (! q.is_square ())
         (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
 
       if (j < 0 || j > m-1)
         (*current_liboctave_error_handler) ("qrdelete: index out of range");
 
-      F77_INT ldq = to_f77_int (q.rows ());
-      F77_INT ldr = to_f77_int (r.rows ());
+      F77_INT ldq = octave::to_f77_int (q.rows ());
+      F77_INT ldr = octave::to_f77_int (r.rows ());
 
       OCTAVE_LOCAL_BUFFER (double, w, 2*m);
       F77_XFCN (dqrder, DQRDER, (m, n, q.fortran_vec (), ldq,
                                  r.fortran_vec (), ldr, j + 1, w));
 
       q.resize (m - 1, m - 1);
       r.resize (m - 1, n);
     }
 
     template <>
     void
     qr<Matrix>::shift_cols (octave_idx_type i_arg, octave_idx_type j_arg)
     {
-      F77_INT i = to_f77_int (i_arg);
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT i = octave::to_f77_int (i_arg);
+      F77_INT j = octave::to_f77_int (j_arg);
 
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT k = to_f77_int (r.rows ());
-      F77_INT n = to_f77_int (r.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT k = octave::to_f77_int (r.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
 
       if (i < 0 || i > n-1 || j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("qrshift: index out of range");
 
-      F77_INT ldq = to_f77_int (q.rows ());
-      F77_INT ldr = to_f77_int (r.rows ());
+      F77_INT ldq = octave::to_f77_int (q.rows ());
+      F77_INT ldr = octave::to_f77_int (r.rows ());
 
       OCTAVE_LOCAL_BUFFER (double, w, 2*k);
       F77_XFCN (dqrshc, DQRSHC, (m, n, k,
                                  q.fortran_vec (), ldq,
                                  r.fortran_vec (), ldr,
                                  i + 1, j + 1, w));
     }
 
 #endif
 
     template <>
     void
     qr<FloatMatrix>::form (octave_idx_type n_arg, FloatMatrix& afact,
                            float *tau, type qr_type)
     {
-      F77_INT n = to_f77_int (n_arg);
-      F77_INT m = to_f77_int (afact.rows ());
+      F77_INT n = octave::to_f77_int (n_arg);
+      F77_INT m = octave::to_f77_int (afact.rows ());
       F77_INT min_mn = std::min (m, n);
       F77_INT info;
 
       if (qr_type == qr<FloatMatrix>::raw)
         {
           for (F77_INT j = 0; j < min_mn; j++)
             {
               F77_INT limit = j < min_mn - 1 ? j : min_mn - 1;
@@ -837,17 +837,17 @@ namespace octave
                     q.xelem (i, j) = afact.xelem (i, j);
                     afact.xelem (i, j) = 0;
                   }
               r = afact;
             }
 
           if (m > 0)
             {
-              F77_INT k = to_f77_int (q.cols ());
+              F77_INT k = octave::to_f77_int (q.cols ());
               // workspace query.
               float rlwork;
               F77_XFCN (sorgqr, SORGQR, (m, k, min_mn, q.fortran_vec (), m,
                                          tau, &rlwork, -1, info));
 
               // allocate buffer and do the job.
               F77_INT lwork = static_cast<F77_INT> (rlwork);
               lwork = std::max (lwork, static_cast<F77_INT> (1));
@@ -857,18 +857,18 @@ namespace octave
             }
         }
     }
 
     template <>
     void
     qr<FloatMatrix>::init (const FloatMatrix& a, type qr_type)
     {
-      F77_INT m = to_f77_int (a.rows ());
-      F77_INT n = to_f77_int (a.cols ());
+      F77_INT m = octave::to_f77_int (a.rows ());
+      F77_INT n = octave::to_f77_int (a.cols ());
 
       F77_INT min_mn = m < n ? m : n;
       OCTAVE_LOCAL_BUFFER (float, tau, min_mn);
 
       F77_INT info = 0;
 
       FloatMatrix afact = a;
       if (m > n && qr_type == qr<FloatMatrix>::std)
@@ -893,47 +893,47 @@ namespace octave
     }
 
 #if defined (HAVE_QRUPDATE)
 
     template <>
     void
     qr<FloatMatrix>::update (const FloatColumnVector& u, const FloatColumnVector& v)
     {
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT n = to_f77_int (r.cols ());
-      F77_INT k = to_f77_int (q.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT k = octave::to_f77_int (q.cols ());
 
-      F77_INT u_nel = to_f77_int (u.numel ());
-      F77_INT v_nel = to_f77_int (v.numel ());
+      F77_INT u_nel = octave::to_f77_int (u.numel ());
+      F77_INT v_nel = octave::to_f77_int (v.numel ());
 
       if (u_nel != m || v_nel != n)
         (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 
       FloatColumnVector utmp = u;
       FloatColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (float, w, 2*k);
       F77_XFCN (sqr1up, SQR1UP, (m, n, k, q.fortran_vec (), m,
                                  r.fortran_vec (), k, utmp.fortran_vec (),
                                  vtmp.fortran_vec (), w));
     }
 
     template <>
     void
     qr<FloatMatrix>::update (const FloatMatrix& u, const FloatMatrix& v)
     {
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT n = to_f77_int (r.cols ());
-      F77_INT k = to_f77_int (q.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT k = octave::to_f77_int (q.cols ());
 
-      F77_INT u_rows = to_f77_int (u.rows ());
-      F77_INT u_cols = to_f77_int (u.cols ());
+      F77_INT u_rows = octave::to_f77_int (u.rows ());
+      F77_INT u_cols = octave::to_f77_int (u.cols ());
 
-      F77_INT v_rows = to_f77_int (v.rows ());
-      F77_INT v_cols = to_f77_int (v.cols ());
+      F77_INT v_rows = octave::to_f77_int (v.rows ());
+      F77_INT v_cols = octave::to_f77_int (v.cols ());
 
       if (u_rows != m || v_rows != n || u_cols != v_cols)
         (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 
       OCTAVE_LOCAL_BUFFER (float, w, 2*k);
       for (volatile F77_INT i = 0; i < u_cols; i++)
         {
           FloatColumnVector utmp = u.column (i);
@@ -944,122 +944,122 @@ namespace octave
         }
     }
 
     template <>
     void
     qr<FloatMatrix>::insert_col (const FloatColumnVector& u,
                                  octave_idx_type j_arg)
     {
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT j = octave::to_f77_int (j_arg);
 
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT n = to_f77_int (r.cols ());
-      F77_INT k = to_f77_int (q.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT k = octave::to_f77_int (q.cols ());
 
-      F77_INT u_nel = to_f77_int (u.numel ());
+      F77_INT u_nel = octave::to_f77_int (u.numel ());
 
       if (u_nel != m)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
 
       if (j < 0 || j > n)
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       if (k < m)
         {
           q.resize (m, k+1);
           r.resize (k+1, n+1);
         }
       else
         r.resize (k, n+1);
 
-      F77_INT ldq = to_f77_int (q.rows ());
-      F77_INT ldr = to_f77_int (r.rows ());
+      F77_INT ldq = octave::to_f77_int (q.rows ());
+      F77_INT ldr = octave::to_f77_int (r.rows ());
 
       FloatColumnVector utmp = u;
       OCTAVE_LOCAL_BUFFER (float, w, k);
       F77_XFCN (sqrinc, SQRINC, (m, n, k, q.fortran_vec (), ldq,
                                  r.fortran_vec (), ldr, j + 1,
                                  utmp.data (), w));
     }
 
     template <>
     void
     qr<FloatMatrix>::insert_col (const FloatMatrix& u,
                                  const Array<octave_idx_type>& j)
     {
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT n = to_f77_int (r.cols ());
-      F77_INT k = to_f77_int (q.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT k = octave::to_f77_int (q.cols ());
 
       Array<octave_idx_type> jsi;
       Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
-      F77_INT nj = to_f77_int (js.numel ());
+      F77_INT nj = octave::to_f77_int (js.numel ());
       bool dups = false;
       for (F77_INT i = 0; i < nj - 1; i++)
         dups = dups && js(i) == js(i+1);
 
       if (dups)
         (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
 
-      F77_INT u_nel = to_f77_int (u.numel ());
-      F77_INT u_cols = to_f77_int (u.cols ());
+      F77_INT u_nel = octave::to_f77_int (u.numel ());
+      F77_INT u_cols = octave::to_f77_int (u.cols ());
 
       if (u_nel != m || u_cols != nj)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
 
-      F77_INT js_beg = to_f77_int (js(0));
-      F77_INT js_end = to_f77_int (js(nj-1));
+      F77_INT js_beg = octave::to_f77_int (js(0));
+      F77_INT js_end = octave::to_f77_int (js(nj-1));
 
       if (nj > 0 && (js_beg < 0 || js_end > n))
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       if (nj > 0)
         {
           F77_INT kmax = std::min (k + nj, m);
           if (k < m)
             {
               q.resize (m, kmax);
               r.resize (kmax, n + nj);
             }
           else
             r.resize (k, n + nj);
 
-          F77_INT ldq = to_f77_int (q.rows ());
-          F77_INT ldr = to_f77_int (r.rows ());
+          F77_INT ldq = octave::to_f77_int (q.rows ());
+          F77_INT ldr = octave::to_f77_int (r.rows ());
 
           OCTAVE_LOCAL_BUFFER (float, w, kmax);
           for (volatile F77_INT i = 0; i < nj; i++)
             {
               F77_INT ii = i;
               FloatColumnVector utmp = u.column (jsi(i));
-              F77_INT js_elt = to_f77_int (js(ii));
+              F77_INT js_elt = octave::to_f77_int (js(ii));
               F77_XFCN (sqrinc, SQRINC, (m, n + ii, std::min (kmax, k + ii),
                                          q.fortran_vec (), ldq,
                                          r.fortran_vec (), ldr, js_elt + 1,
                                          utmp.data (), w));
             }
         }
     }
 
     template <>
     void
     qr<FloatMatrix>::delete_col (octave_idx_type j_arg)
     {
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT j = octave::to_f77_int (j_arg);
 
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT k = to_f77_int (r.rows ());
-      F77_INT n = to_f77_int (r.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT k = octave::to_f77_int (r.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
 
       if (j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("qrdelete: index out of range");
 
-      F77_INT ldq = to_f77_int (q.rows ());
-      F77_INT ldr = to_f77_int (r.rows ());
+      F77_INT ldq = octave::to_f77_int (q.rows ());
+      F77_INT ldr = octave::to_f77_int (r.rows ());
 
       OCTAVE_LOCAL_BUFFER (float, w, k);
       F77_XFCN (sqrdec, SQRDEC, (m, n, k, q.fortran_vec (), ldq,
                                  r.fortran_vec (), ldr, j + 1, w));
 
       if (k < m)
         {
           q.resize (m, k-1);
@@ -1068,46 +1068,46 @@ namespace octave
       else
         r.resize (k, n-1);
     }
 
     template <>
     void
     qr<FloatMatrix>::delete_col (const Array<octave_idx_type>& j)
     {
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT n = to_f77_int (r.cols ());
-      F77_INT k = to_f77_int (q.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT k = octave::to_f77_int (q.cols ());
 
       Array<octave_idx_type> jsi;
       Array<octave_idx_type> js = j.sort (jsi, 0, DESCENDING);
-      F77_INT nj = to_f77_int (js.numel ());
+      F77_INT nj = octave::to_f77_int (js.numel ());
       bool dups = false;
       for (F77_INT i = 0; i < nj - 1; i++)
         dups = dups && js(i) == js(i+1);
 
       if (dups)
         (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
 
-      F77_INT js_beg = to_f77_int (js(0));
-      F77_INT js_end = to_f77_int (js(nj-1));
+      F77_INT js_beg = octave::to_f77_int (js(0));
+      F77_INT js_end = octave::to_f77_int (js(nj-1));
 
       if (nj > 0 && (js_beg > n-1 || js_end < 0))
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       if (nj > 0)
         {
-          F77_INT ldq = to_f77_int (q.rows ());
-          F77_INT ldr = to_f77_int (r.rows ());
+          F77_INT ldq = octave::to_f77_int (q.rows ());
+          F77_INT ldr = octave::to_f77_int (r.rows ());
 
           OCTAVE_LOCAL_BUFFER (float, w, k);
           for (volatile F77_INT i = 0; i < nj; i++)
             {
               F77_INT ii = i;
-              F77_INT js_elt = to_f77_int (js(ii));
+              F77_INT js_elt = octave::to_f77_int (js(ii));
               F77_XFCN (sqrdec, SQRDEC, (m, n - ii, k == m ? k : k - ii,
                                          q.fortran_vec (), ldq,
                                          r.fortran_vec (), ldr,
                                          js_elt + 1, w));
             }
 
           if (k < m)
             {
@@ -1119,104 +1119,104 @@ namespace octave
         }
     }
 
     template <>
     void
     qr<FloatMatrix>::insert_row (const FloatRowVector& u,
                                  octave_idx_type j_arg)
     {
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT j = octave::to_f77_int (j_arg);
 
-      F77_INT m = to_f77_int (r.rows ());
-      F77_INT n = to_f77_int (r.cols ());
+      F77_INT m = octave::to_f77_int (r.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
       F77_INT k = std::min (m, n);
 
-      F77_INT u_nel = to_f77_int (u.numel ());
+      F77_INT u_nel = octave::to_f77_int (u.numel ());
 
       if (! q.is_square () || u_nel != n)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
 
       if (j < 0 || j > m)
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       q.resize (m + 1, m + 1);
       r.resize (m + 1, n);
 
-      F77_INT ldq = to_f77_int (q.rows ());
-      F77_INT ldr = to_f77_int (r.rows ());
+      F77_INT ldq = octave::to_f77_int (q.rows ());
+      F77_INT ldr = octave::to_f77_int (r.rows ());
 
       FloatRowVector utmp = u;
       OCTAVE_LOCAL_BUFFER (float, w, k);
       F77_XFCN (sqrinr, SQRINR, (m, n, q.fortran_vec (), ldq,
                                  r.fortran_vec (), ldr,
                                  j + 1, utmp.fortran_vec (), w));
 
     }
 
     template <>
     void
     qr<FloatMatrix>::delete_row (octave_idx_type j_arg)
     {
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT j = octave::to_f77_int (j_arg);
 
-      F77_INT m = to_f77_int (r.rows ());
-      F77_INT n = to_f77_int (r.cols ());
+      F77_INT m = octave::to_f77_int (r.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
 
       if (! q.is_square ())
         (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
 
       if (j < 0 || j > m-1)
         (*current_liboctave_error_handler) ("qrdelete: index out of range");
 
-      F77_INT ldq = to_f77_int (q.rows ());
-      F77_INT ldr = to_f77_int (r.rows ());
+      F77_INT ldq = octave::to_f77_int (q.rows ());
+      F77_INT ldr = octave::to_f77_int (r.rows ());
 
       OCTAVE_LOCAL_BUFFER (float, w, 2*m);
       F77_XFCN (sqrder, SQRDER, (m, n, q.fortran_vec (), ldq,
                                  r.fortran_vec (), ldr, j + 1,
                                  w));
 
       q.resize (m - 1, m - 1);
       r.resize (m - 1, n);
     }
 
     template <>
     void
     qr<FloatMatrix>::shift_cols (octave_idx_type i_arg, octave_idx_type j_arg)
     {
-      F77_INT i = to_f77_int (i_arg);
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT i = octave::to_f77_int (i_arg);
+      F77_INT j = octave::to_f77_int (j_arg);
 
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT k = to_f77_int (r.rows ());
-      F77_INT n = to_f77_int (r.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT k = octave::to_f77_int (r.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
 
       if (i < 0 || i > n-1 || j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("qrshift: index out of range");
 
-      F77_INT ldq = to_f77_int (q.rows ());
-      F77_INT ldr = to_f77_int (r.rows ());
+      F77_INT ldq = octave::to_f77_int (q.rows ());
+      F77_INT ldr = octave::to_f77_int (r.rows ());
 
       OCTAVE_LOCAL_BUFFER (float, w, 2*k);
       F77_XFCN (sqrshc, SQRSHC, (m, n, k,
                                  q.fortran_vec (), ldq,
                                  r.fortran_vec (), ldr,
                                  i + 1, j + 1, w));
     }
 
 #endif
 
     template <>
     void
     qr<ComplexMatrix>::form (octave_idx_type n_arg, ComplexMatrix& afact,
                              Complex *tau, type qr_type)
     {
-      F77_INT n = to_f77_int (n_arg);
-      F77_INT m = to_f77_int (afact.rows ());
+      F77_INT n = octave::to_f77_int (n_arg);
+      F77_INT m = octave::to_f77_int (afact.rows ());
       F77_INT min_mn = std::min (m, n);
       F77_INT info;
 
       if (qr_type == qr<ComplexMatrix>::raw)
         {
           for (F77_INT j = 0; j < min_mn; j++)
             {
               F77_INT limit = j < min_mn - 1 ? j : min_mn - 1;
@@ -1255,17 +1255,17 @@ namespace octave
                     q.xelem (i, j) = afact.xelem (i, j);
                     afact.xelem (i, j) = 0;
                   }
               r = afact;
             }
 
           if (m > 0)
             {
-              F77_INT k = to_f77_int (q.cols ());
+              F77_INT k = octave::to_f77_int (q.cols ());
               // workspace query.
               Complex clwork;
               F77_XFCN (zungqr, ZUNGQR, (m, k, min_mn,
                                          F77_DBLE_CMPLX_ARG (q.fortran_vec ()),
                                          m, F77_DBLE_CMPLX_ARG (tau),
                                          F77_DBLE_CMPLX_ARG (&clwork), -1,
                                          info));
 
@@ -1281,18 +1281,18 @@ namespace octave
             }
         }
     }
 
     template <>
     void
     qr<ComplexMatrix>::init (const ComplexMatrix& a, type qr_type)
     {
-      F77_INT m = to_f77_int (a.rows ());
-      F77_INT n = to_f77_int (a.cols ());
+      F77_INT m = octave::to_f77_int (a.rows ());
+      F77_INT n = octave::to_f77_int (a.cols ());
 
       F77_INT min_mn = m < n ? m : n;
       OCTAVE_LOCAL_BUFFER (Complex, tau, min_mn);
 
       F77_INT info = 0;
 
       ComplexMatrix afact = a;
       if (m > n && qr_type == qr<ComplexMatrix>::std)
@@ -1322,22 +1322,22 @@ namespace octave
 
 #if defined (HAVE_QRUPDATE)
 
     template <>
     void
     qr<ComplexMatrix>::update (const ComplexColumnVector& u,
                                const ComplexColumnVector& v)
     {
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT n = to_f77_int (r.cols ());
-      F77_INT k = to_f77_int (q.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT k = octave::to_f77_int (q.cols ());
 
-      F77_INT u_nel = to_f77_int (u.numel ());
-      F77_INT v_nel = to_f77_int (v.numel ());
+      F77_INT u_nel = octave::to_f77_int (u.numel ());
+      F77_INT v_nel = octave::to_f77_int (v.numel ());
 
       if (u_nel != m || v_nel != n)
         (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 
       ComplexColumnVector utmp = u;
       ComplexColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (Complex, w, k);
       OCTAVE_LOCAL_BUFFER (double, rw, k);
@@ -1347,25 +1347,25 @@ namespace octave
                                  F77_DBLE_CMPLX_ARG (vtmp.fortran_vec ()),
                                  F77_DBLE_CMPLX_ARG (w), rw));
     }
 
     template <>
     void
     qr<ComplexMatrix>::update (const ComplexMatrix& u, const ComplexMatrix& v)
     {
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT n = to_f77_int (r.cols ());
-      F77_INT k = to_f77_int (q.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT k = octave::to_f77_int (q.cols ());
 
-      F77_INT u_rows = to_f77_int (u.rows ());
-      F77_INT u_cols = to_f77_int (u.cols ());
+      F77_INT u_rows = octave::to_f77_int (u.rows ());
+      F77_INT u_cols = octave::to_f77_int (u.cols ());
 
-      F77_INT v_rows = to_f77_int (v.rows ());
-      F77_INT v_cols = to_f77_int (v.cols ());
+      F77_INT v_rows = octave::to_f77_int (v.rows ());
+      F77_INT v_cols = octave::to_f77_int (v.cols ());
 
       if (u_rows != m || v_rows != n || u_cols != v_cols)
         (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 
       OCTAVE_LOCAL_BUFFER (Complex, w, k);
       OCTAVE_LOCAL_BUFFER (double, rw, k);
       for (volatile F77_INT i = 0; i < u_cols; i++)
         {
@@ -1380,126 +1380,126 @@ namespace octave
         }
     }
 
     template <>
     void
     qr<ComplexMatrix>::insert_col (const ComplexColumnVector& u,
                                    octave_idx_type j_arg)
     {
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT j = octave::to_f77_int (j_arg);
 
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT n = to_f77_int (r.cols ());
-      F77_INT k = to_f77_int (q.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT k = octave::to_f77_int (q.cols ());
 
-      F77_INT u_nel = to_f77_int (u.numel ());
+      F77_INT u_nel = octave::to_f77_int (u.numel ());
 
       if (u_nel != m)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
 
       if (j < 0 || j > n)
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       if (k < m)
         {
           q.resize (m, k+1);
           r.resize (k+1, n+1);
         }
       else
         r.resize (k, n+1);
 
-      F77_INT ldq = to_f77_int (q.rows ());
-      F77_INT ldr = to_f77_int (r.rows ());
+      F77_INT ldq = octave::to_f77_int (q.rows ());
+      F77_INT ldr = octave::to_f77_int (r.rows ());
 
       ComplexColumnVector utmp = u;
       OCTAVE_LOCAL_BUFFER (double, rw, k);
       F77_XFCN (zqrinc, ZQRINC, (m, n, k, F77_DBLE_CMPLX_ARG (q.fortran_vec ()),
                                  ldq, F77_DBLE_CMPLX_ARG (r.fortran_vec ()),
                                  ldr, j + 1,
                                  F77_CONST_DBLE_CMPLX_ARG (utmp.data ()), rw));
     }
 
     template <>
     void
     qr<ComplexMatrix>::insert_col (const ComplexMatrix& u,
                                    const Array<octave_idx_type>& j)
     {
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT n = to_f77_int (r.cols ());
-      F77_INT k = to_f77_int (q.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT k = octave::to_f77_int (q.cols ());
 
       Array<octave_idx_type> jsi;
       Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
-      F77_INT nj = to_f77_int (js.numel ());
+      F77_INT nj = octave::to_f77_int (js.numel ());
       bool dups = false;
       for (F77_INT i = 0; i < nj - 1; i++)
         dups = dups && js(i) == js(i+1);
 
       if (dups)
         (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
 
-      F77_INT u_nel = to_f77_int (u.numel ());
-      F77_INT u_cols = to_f77_int (u.cols ());
+      F77_INT u_nel = octave::to_f77_int (u.numel ());
+      F77_INT u_cols = octave::to_f77_int (u.cols ());
 
       if (u_nel != m || u_cols != nj)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
 
-      F77_INT js_beg = to_f77_int (js(0));
-      F77_INT js_end = to_f77_int (js(nj-1));
+      F77_INT js_beg = octave::to_f77_int (js(0));
+      F77_INT js_end = octave::to_f77_int (js(nj-1));
 
       if (nj > 0 && (js_beg < 0 || js_end > n))
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       if (nj > 0)
         {
           F77_INT kmax = std::min (k + nj, m);
           if (k < m)
             {
               q.resize (m, kmax);
               r.resize (kmax, n + nj);
             }
           else
             r.resize (k, n + nj);
 
-          F77_INT ldq = to_f77_int (q.rows ());
-          F77_INT ldr = to_f77_int (r.rows ());
+          F77_INT ldq = octave::to_f77_int (q.rows ());
+          F77_INT ldr = octave::to_f77_int (r.rows ());
 
           OCTAVE_LOCAL_BUFFER (double, rw, kmax);
           for (volatile F77_INT i = 0; i < nj; i++)
             {
               F77_INT ii = i;
               ComplexColumnVector utmp = u.column (jsi(i));
-              F77_INT js_elt = to_f77_int (js(ii));
+              F77_INT js_elt = octave::to_f77_int (js(ii));
               F77_XFCN (zqrinc, ZQRINC, (m, n + ii, std::min (kmax, k + ii),
                                          F77_DBLE_CMPLX_ARG (q.fortran_vec ()),
                                          ldq,
                                          F77_DBLE_CMPLX_ARG (r.fortran_vec ()),
                                          ldr, js_elt + 1,
                                          F77_CONST_DBLE_CMPLX_ARG (utmp.data ()),
                                          rw));
             }
         }
     }
 
     template <>
     void
     qr<ComplexMatrix>::delete_col (octave_idx_type j_arg)
     {
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT j = octave::to_f77_int (j_arg);
 
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT k = to_f77_int (r.rows ());
-      F77_INT n = to_f77_int (r.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT k = octave::to_f77_int (r.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
 
       if (j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("qrdelete: index out of range");
 
-      F77_INT ldq = to_f77_int (q.rows ());
-      F77_INT ldr = to_f77_int (r.rows ());
+      F77_INT ldq = octave::to_f77_int (q.rows ());
+      F77_INT ldr = octave::to_f77_int (r.rows ());
 
       OCTAVE_LOCAL_BUFFER (double, rw, k);
       F77_XFCN (zqrdec, ZQRDEC, (m, n, k, F77_DBLE_CMPLX_ARG (q.fortran_vec ()),
                                  ldq, F77_DBLE_CMPLX_ARG (r.fortran_vec ()),
                                  ldr, j + 1, rw));
 
       if (k < m)
         {
@@ -1509,46 +1509,46 @@ namespace octave
       else
         r.resize (k, n-1);
     }
 
     template <>
     void
     qr<ComplexMatrix>::delete_col (const Array<octave_idx_type>& j)
     {
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT n = to_f77_int (r.cols ());
-      F77_INT k = to_f77_int (q.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT k = octave::to_f77_int (q.cols ());
 
       Array<octave_idx_type> jsi;
       Array<octave_idx_type> js = j.sort (jsi, 0, DESCENDING);
-      F77_INT nj = to_f77_int (js.numel ());
+      F77_INT nj = octave::to_f77_int (js.numel ());
       bool dups = false;
       for (F77_INT i = 0; i < nj - 1; i++)
         dups = dups && js(i) == js(i+1);
 
       if (dups)
         (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
 
-      F77_INT js_beg = to_f77_int (js(0));
-      F77_INT js_end = to_f77_int (js(nj-1));
+      F77_INT js_beg = octave::to_f77_int (js(0));
+      F77_INT js_end = octave::to_f77_int (js(nj-1));
 
       if (nj > 0 && (js_beg > n-1 || js_end < 0))
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       if (nj > 0)
         {
-          F77_INT ldq = to_f77_int (q.rows ());
-          F77_INT ldr = to_f77_int (r.rows ());
+          F77_INT ldq = octave::to_f77_int (q.rows ());
+          F77_INT ldr = octave::to_f77_int (r.rows ());
 
           OCTAVE_LOCAL_BUFFER (double, rw, k);
           for (volatile F77_INT i = 0; i < nj; i++)
             {
               F77_INT ii = i;
-              F77_INT js_elt = to_f77_int (js(ii));
+              F77_INT js_elt = octave::to_f77_int (js(ii));
               F77_XFCN (zqrdec, ZQRDEC, (m, n - ii, k == m ? k : k - ii,
                                          F77_DBLE_CMPLX_ARG (q.fortran_vec ()),
                                          ldq,
                                          F77_DBLE_CMPLX_ARG (r.fortran_vec ()),
                                          ldr, js_elt + 1, rw));
             }
 
           if (k < m)
@@ -1561,108 +1561,108 @@ namespace octave
         }
     }
 
     template <>
     void
     qr<ComplexMatrix>::insert_row (const ComplexRowVector& u,
                                    octave_idx_type j_arg)
     {
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT j = octave::to_f77_int (j_arg);
 
-      F77_INT m = to_f77_int (r.rows ());
-      F77_INT n = to_f77_int (r.cols ());
+      F77_INT m = octave::to_f77_int (r.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
       F77_INT k = std::min (m, n);
 
-      F77_INT u_nel = to_f77_int (u.numel ());
+      F77_INT u_nel = octave::to_f77_int (u.numel ());
 
       if (! q.is_square () || u_nel != n)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
 
       if (j < 0 || j > m)
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       q.resize (m + 1, m + 1);
       r.resize (m + 1, n);
 
-      F77_INT ldq = to_f77_int (q.rows ());
-      F77_INT ldr = to_f77_int (r.rows ());
+      F77_INT ldq = octave::to_f77_int (q.rows ());
+      F77_INT ldr = octave::to_f77_int (r.rows ());
 
       ComplexRowVector utmp = u;
       OCTAVE_LOCAL_BUFFER (double, rw, k);
       F77_XFCN (zqrinr, ZQRINR, (m, n, F77_DBLE_CMPLX_ARG (q.fortran_vec ()),
                                  ldq, F77_DBLE_CMPLX_ARG (r.fortran_vec ()),
                                  ldr, j + 1,
                                  F77_DBLE_CMPLX_ARG (utmp.fortran_vec ()), rw));
 
     }
 
     template <>
     void
     qr<ComplexMatrix>::delete_row (octave_idx_type j_arg)
     {
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT j = octave::to_f77_int (j_arg);
 
-      F77_INT m = to_f77_int (r.rows ());
-      F77_INT n = to_f77_int (r.cols ());
+      F77_INT m = octave::to_f77_int (r.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
 
       if (! q.is_square ())
         (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
 
       if (j < 0 || j > m-1)
         (*current_liboctave_error_handler) ("qrdelete: index out of range");
 
-      F77_INT ldq = to_f77_int (q.rows ());
-      F77_INT ldr = to_f77_int (r.rows ());
+      F77_INT ldq = octave::to_f77_int (q.rows ());
+      F77_INT ldr = octave::to_f77_int (r.rows ());
 
       OCTAVE_LOCAL_BUFFER (Complex, w, m);
       OCTAVE_LOCAL_BUFFER (double, rw, m);
       F77_XFCN (zqrder, ZQRDER, (m, n, F77_DBLE_CMPLX_ARG (q.fortran_vec ()),
                                  ldq, F77_DBLE_CMPLX_ARG (r.fortran_vec ()),
                                  ldr, j + 1, F77_DBLE_CMPLX_ARG (w), rw));
 
       q.resize (m - 1, m - 1);
       r.resize (m - 1, n);
     }
 
     template <>
     void
     qr<ComplexMatrix>::shift_cols (octave_idx_type i_arg,
                                    octave_idx_type j_arg)
     {
-      F77_INT i = to_f77_int (i_arg);
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT i = octave::to_f77_int (i_arg);
+      F77_INT j = octave::to_f77_int (j_arg);
 
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT k = to_f77_int (r.rows ());
-      F77_INT n = to_f77_int (r.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT k = octave::to_f77_int (r.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
 
       if (i < 0 || i > n-1 || j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("qrshift: index out of range");
 
-      F77_INT ldq = to_f77_int (q.rows ());
-      F77_INT ldr = to_f77_int (r.rows ());
+      F77_INT ldq = octave::to_f77_int (q.rows ());
+      F77_INT ldr = octave::to_f77_int (r.rows ());
 
       OCTAVE_LOCAL_BUFFER (Complex, w, k);
       OCTAVE_LOCAL_BUFFER (double, rw, k);
       F77_XFCN (zqrshc, ZQRSHC, (m, n, k,
                                  F77_DBLE_CMPLX_ARG (q.fortran_vec ()), ldq,
                                  F77_DBLE_CMPLX_ARG (r.fortran_vec ()), ldr,
                                  i + 1, j + 1, F77_DBLE_CMPLX_ARG (w), rw));
     }
 
 #endif
 
     template <>
     void
     qr<FloatComplexMatrix>::form (octave_idx_type n_arg, FloatComplexMatrix& afact,
                                   FloatComplex *tau, type qr_type)
     {
-      F77_INT n = to_f77_int (n_arg);
-      F77_INT m = to_f77_int (afact.rows ());
+      F77_INT n = octave::to_f77_int (n_arg);
+      F77_INT m = octave::to_f77_int (afact.rows ());
       F77_INT min_mn = std::min (m, n);
       F77_INT info;
 
       if (qr_type == qr<FloatComplexMatrix>::raw)
         {
           for (F77_INT j = 0; j < min_mn; j++)
             {
               F77_INT limit = j < min_mn - 1 ? j : min_mn - 1;
@@ -1701,17 +1701,17 @@ namespace octave
                     q.xelem (i, j) = afact.xelem (i, j);
                     afact.xelem (i, j) = 0;
                   }
               r = afact;
             }
 
           if (m > 0)
             {
-              F77_INT k = to_f77_int (q.cols ());
+              F77_INT k = octave::to_f77_int (q.cols ());
               // workspace query.
               FloatComplex clwork;
               F77_XFCN (cungqr, CUNGQR, (m, k, min_mn,
                                          F77_CMPLX_ARG (q.fortran_vec ()), m,
                                          F77_CMPLX_ARG (tau),
                                          F77_CMPLX_ARG (&clwork), -1, info));
 
               // allocate buffer and do the job.
@@ -1725,18 +1725,18 @@ namespace octave
             }
         }
     }
 
     template <>
     void
     qr<FloatComplexMatrix>::init (const FloatComplexMatrix& a, type qr_type)
     {
-      F77_INT m = to_f77_int (a.rows ());
-      F77_INT n = to_f77_int (a.cols ());
+      F77_INT m = octave::to_f77_int (a.rows ());
+      F77_INT n = octave::to_f77_int (a.cols ());
 
       F77_INT min_mn = m < n ? m : n;
       OCTAVE_LOCAL_BUFFER (FloatComplex, tau, min_mn);
 
       F77_INT info = 0;
 
       FloatComplexMatrix afact = a;
       if (m > n && qr_type == qr<FloatComplexMatrix>::std)
@@ -1764,22 +1764,22 @@ namespace octave
 
 #if defined (HAVE_QRUPDATE)
 
     template <>
     void
     qr<FloatComplexMatrix>::update (const FloatComplexColumnVector& u,
                                     const FloatComplexColumnVector& v)
     {
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT n = to_f77_int (r.cols ());
-      F77_INT k = to_f77_int (q.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT k = octave::to_f77_int (q.cols ());
 
-      F77_INT u_nel = to_f77_int (u.numel ());
-      F77_INT v_nel = to_f77_int (v.numel ());
+      F77_INT u_nel = octave::to_f77_int (u.numel ());
+      F77_INT v_nel = octave::to_f77_int (v.numel ());
 
       if (u_nel != m || v_nel != n)
         (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 
       FloatComplexColumnVector utmp = u;
       FloatComplexColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, k);
       OCTAVE_LOCAL_BUFFER (float, rw, k);
@@ -1790,25 +1790,25 @@ namespace octave
                                  F77_CMPLX_ARG (w), rw));
     }
 
     template <>
     void
     qr<FloatComplexMatrix>::update (const FloatComplexMatrix& u,
                                     const FloatComplexMatrix& v)
     {
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT n = to_f77_int (r.cols ());
-      F77_INT k = to_f77_int (q.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT k = octave::to_f77_int (q.cols ());
 
-      F77_INT u_rows = to_f77_int (u.rows ());
-      F77_INT u_cols = to_f77_int (u.cols ());
+      F77_INT u_rows = octave::to_f77_int (u.rows ());
+      F77_INT u_cols = octave::to_f77_int (u.cols ());
 
-      F77_INT v_rows = to_f77_int (v.rows ());
-      F77_INT v_cols = to_f77_int (v.cols ());
+      F77_INT v_rows = octave::to_f77_int (v.rows ());
+      F77_INT v_cols = octave::to_f77_int (v.cols ());
 
       if (u_rows != m || v_rows != n || u_cols != v_cols)
         (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, k);
       OCTAVE_LOCAL_BUFFER (float, rw, k);
       for (volatile F77_INT i = 0; i < u_cols; i++)
         {
@@ -1822,123 +1822,123 @@ namespace octave
         }
     }
 
     template <>
     void
     qr<FloatComplexMatrix>::insert_col (const FloatComplexColumnVector& u,
                                         octave_idx_type j_arg)
     {
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT j = octave::to_f77_int (j_arg);
 
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT n = to_f77_int (r.cols ());
-      F77_INT k = to_f77_int (q.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT k = octave::to_f77_int (q.cols ());
 
-      F77_INT u_nel = to_f77_int (u.numel ());
+      F77_INT u_nel = octave::to_f77_int (u.numel ());
 
       if (u_nel != m)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
 
       if (j < 0 || j > n)
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       if (k < m)
         {
           q.resize (m, k+1);
           r.resize (k+1, n+1);
         }
       else
         r.resize (k, n+1);
 
-      F77_INT ldq = to_f77_int (q.rows ());
-      F77_INT ldr = to_f77_int (r.rows ());
+      F77_INT ldq = octave::to_f77_int (q.rows ());
+      F77_INT ldr = octave::to_f77_int (r.rows ());
 
       FloatComplexColumnVector utmp = u;
       OCTAVE_LOCAL_BUFFER (float, rw, k);
       F77_XFCN (cqrinc, CQRINC, (m, n, k, F77_CMPLX_ARG (q.fortran_vec ()), ldq,
                                  F77_CMPLX_ARG (r.fortran_vec ()), ldr, j + 1,
                                  F77_CONST_CMPLX_ARG (utmp.data ()), rw));
     }
 
     template <>
     void
     qr<FloatComplexMatrix>::insert_col (const FloatComplexMatrix& u,
                                         const Array<octave_idx_type>& j)
     {
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT n = to_f77_int (r.cols ());
-      F77_INT k = to_f77_int (q.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT k = octave::to_f77_int (q.cols ());
 
       Array<octave_idx_type> jsi;
       Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
-      F77_INT nj = to_f77_int (js.numel ());
+      F77_INT nj = octave::to_f77_int (js.numel ());
       bool dups = false;
       for (F77_INT i = 0; i < nj - 1; i++)
         dups = dups && js(i) == js(i+1);
 
       if (dups)
         (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
 
-      F77_INT u_nel = to_f77_int (u.numel ());
-      F77_INT u_cols = to_f77_int (u.cols ());
+      F77_INT u_nel = octave::to_f77_int (u.numel ());
+      F77_INT u_cols = octave::to_f77_int (u.cols ());
 
       if (u_nel != m || u_cols != nj)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
 
-      F77_INT js_beg = to_f77_int (js(0));
-      F77_INT js_end = to_f77_int (js(nj-1));
+      F77_INT js_beg = octave::to_f77_int (js(0));
+      F77_INT js_end = octave::to_f77_int (js(nj-1));
 
       if (nj > 0 && (js_beg < 0 || js_end > n))
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       if (nj > 0)
         {
           F77_INT kmax = std::min (k + nj, m);
           if (k < m)
             {
               q.resize (m, kmax);
               r.resize (kmax, n + nj);
             }
           else
             r.resize (k, n + nj);
 
-          F77_INT ldq = to_f77_int (q.rows ());
-          F77_INT ldr = to_f77_int (r.rows ());
+          F77_INT ldq = octave::to_f77_int (q.rows ());
+          F77_INT ldr = octave::to_f77_int (r.rows ());
 
           OCTAVE_LOCAL_BUFFER (float, rw, kmax);
           for (volatile F77_INT i = 0; i < nj; i++)
             {
               F77_INT ii = i;
-              F77_INT js_elt = to_f77_int (js(ii));
+              F77_INT js_elt = octave::to_f77_int (js(ii));
               F77_XFCN (cqrinc, CQRINC, (m, n + ii, std::min (kmax, k + ii),
                                          F77_CMPLX_ARG (q.fortran_vec ()), ldq,
                                          F77_CMPLX_ARG (r.fortran_vec ()), ldr,
                                          js_elt + 1,
                                          F77_CONST_CMPLX_ARG (u.column (jsi(i)).data ()),
                                          rw));
             }
         }
     }
 
     template <>
     void
     qr<FloatComplexMatrix>::delete_col (octave_idx_type j_arg)
     {
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT j = octave::to_f77_int (j_arg);
 
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT k = to_f77_int (r.rows ());
-      F77_INT n = to_f77_int (r.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT k = octave::to_f77_int (r.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
 
       if (j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("qrdelete: index out of range");
 
-      F77_INT ldq = to_f77_int (q.rows ());
-      F77_INT ldr = to_f77_int (r.rows ());
+      F77_INT ldq = octave::to_f77_int (q.rows ());
+      F77_INT ldr = octave::to_f77_int (r.rows ());
 
       OCTAVE_LOCAL_BUFFER (float, rw, k);
       F77_XFCN (cqrdec, CQRDEC, (m, n, k, F77_CMPLX_ARG (q.fortran_vec ()), ldq,
                                  F77_CMPLX_ARG (r.fortran_vec ()), ldr, j + 1,
                                  rw));
 
       if (k < m)
         {
@@ -1948,46 +1948,46 @@ namespace octave
       else
         r.resize (k, n-1);
     }
 
     template <>
     void
     qr<FloatComplexMatrix>::delete_col (const Array<octave_idx_type>& j)
     {
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT n = to_f77_int (r.cols ());
-      F77_INT k = to_f77_int (q.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
+      F77_INT k = octave::to_f77_int (q.cols ());
 
       Array<octave_idx_type> jsi;
       Array<octave_idx_type> js = j.sort (jsi, 0, DESCENDING);
-      F77_INT nj = to_f77_int (js.numel ());
+      F77_INT nj = octave::to_f77_int (js.numel ());
       bool dups = false;
       for (F77_INT i = 0; i < nj - 1; i++)
         dups = dups && js(i) == js(i+1);
 
       if (dups)
         (*current_liboctave_error_handler) ("qrinsert: duplicate index detected");
 
-      F77_INT js_beg = to_f77_int (js(0));
-      F77_INT js_end = to_f77_int (js(nj-1));
+      F77_INT js_beg = octave::to_f77_int (js(0));
+      F77_INT js_end = octave::to_f77_int (js(nj-1));
 
       if (nj > 0 && (js_beg > n-1 || js_end < 0))
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       if (nj > 0)
         {
-          F77_INT ldq = to_f77_int (q.rows ());
-          F77_INT ldr = to_f77_int (r.rows ());
+          F77_INT ldq = octave::to_f77_int (q.rows ());
+          F77_INT ldr = octave::to_f77_int (r.rows ());
 
           OCTAVE_LOCAL_BUFFER (float, rw, k);
           for (volatile F77_INT i = 0; i < nj; i++)
             {
               F77_INT ii = i;
-              F77_INT js_elt = to_f77_int (js(ii));
+              F77_INT js_elt = octave::to_f77_int (js(ii));
               F77_XFCN (cqrdec, CQRDEC, (m, n - ii, k == m ? k : k - ii,
                                          F77_CMPLX_ARG (q.fortran_vec ()), ldq,
                                          F77_CMPLX_ARG (r.fortran_vec ()), ldr,
                                          js_elt + 1, rw));
             }
 
           if (k < m)
             {
@@ -1999,90 +1999,90 @@ namespace octave
         }
     }
 
     template <>
     void
     qr<FloatComplexMatrix>::insert_row (const FloatComplexRowVector& u,
                                         octave_idx_type j_arg)
     {
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT j = octave::to_f77_int (j_arg);
 
-      F77_INT m = to_f77_int (r.rows ());
-      F77_INT n = to_f77_int (r.cols ());
+      F77_INT m = octave::to_f77_int (r.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
       F77_INT k = std::min (m, n);
 
-      F77_INT u_nel = to_f77_int (u.numel ());
+      F77_INT u_nel = octave::to_f77_int (u.numel ());
 
       if (! q.is_square () || u_nel != n)
         (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
 
       if (j < 0 || j > m)
         (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
       q.resize (m + 1, m + 1);
       r.resize (m + 1, n);
 
-      F77_INT ldq = to_f77_int (q.rows ());
-      F77_INT ldr = to_f77_int (r.rows ());
+      F77_INT ldq = octave::to_f77_int (q.rows ());
+      F77_INT ldr = octave::to_f77_int (r.rows ());
 
       FloatComplexRowVector utmp = u;
       OCTAVE_LOCAL_BUFFER (float, rw, k);
       F77_XFCN (cqrinr, CQRINR, (m, n, F77_CMPLX_ARG (q.fortran_vec ()), ldq,
                                  F77_CMPLX_ARG (r.fortran_vec ()), ldr,
                                  j + 1, F77_CMPLX_ARG (utmp.fortran_vec ()),
                                  rw));
 
     }
 
     template <>
     void
     qr<FloatComplexMatrix>::delete_row (octave_idx_type j_arg)
     {
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT j = octave::to_f77_int (j_arg);
 
-      F77_INT m = to_f77_int (r.rows ());
-      F77_INT n = to_f77_int (r.cols ());
+      F77_INT m = octave::to_f77_int (r.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
 
       if (! q.is_square ())
         (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
 
       if (j < 0 || j > m-1)
         (*current_liboctave_error_handler) ("qrdelete: index out of range");
 
-      F77_INT ldq = to_f77_int (q.rows ());
-      F77_INT ldr = to_f77_int (r.rows ());
+      F77_INT ldq = octave::to_f77_int (q.rows ());
+      F77_INT ldr = octave::to_f77_int (r.rows ());
 
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, m);
       OCTAVE_LOCAL_BUFFER (float, rw, m);
       F77_XFCN (cqrder, CQRDER, (m, n, F77_CMPLX_ARG (q.fortran_vec ()), ldq,
                                  F77_CMPLX_ARG (r.fortran_vec ()), ldr, j + 1,
                                  F77_CMPLX_ARG (w), rw));
 
       q.resize (m - 1, m - 1);
       r.resize (m - 1, n);
     }
 
     template <>
     void
     qr<FloatComplexMatrix>::shift_cols (octave_idx_type i_arg,
                                         octave_idx_type j_arg)
     {
-      F77_INT i = to_f77_int (i_arg);
-      F77_INT j = to_f77_int (j_arg);
+      F77_INT i = octave::to_f77_int (i_arg);
+      F77_INT j = octave::to_f77_int (j_arg);
 
-      F77_INT m = to_f77_int (q.rows ());
-      F77_INT k = to_f77_int (r.rows ());
-      F77_INT n = to_f77_int (r.cols ());
+      F77_INT m = octave::to_f77_int (q.rows ());
+      F77_INT k = octave::to_f77_int (r.rows ());
+      F77_INT n = octave::to_f77_int (r.cols ());
 
       if (i < 0 || i > n-1 || j < 0 || j > n-1)
         (*current_liboctave_error_handler) ("qrshift: index out of range");
 
-      F77_INT ldq = to_f77_int (q.rows ());
-      F77_INT ldr = to_f77_int (r.rows ());
+      F77_INT ldq = octave::to_f77_int (q.rows ());
+      F77_INT ldr = octave::to_f77_int (r.rows ());
 
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, k);
       OCTAVE_LOCAL_BUFFER (float, rw, k);
       F77_XFCN (cqrshc, CQRSHC, (m, n, k,
                                  F77_CMPLX_ARG (q.fortran_vec ()), ldq,
                                  F77_CMPLX_ARG (r.fortran_vec ()), ldr,
                                  i + 1, j + 1, F77_CMPLX_ARG (w), rw));
     }
diff --git a/liboctave/numeric/qrp.cc b/liboctave/numeric/qrp.cc
--- a/liboctave/numeric/qrp.cc
+++ b/liboctave/numeric/qrp.cc
@@ -45,18 +45,18 @@ namespace octave
     // Specialization.
 
     template <>
     void
     qrp<Matrix>::init (const Matrix& a, type qr_type)
     {
       assert (qr_type != qr<Matrix>::raw);
 
-      F77_INT m = to_f77_int (a.rows ());
-      F77_INT n = to_f77_int (a.cols ());
+      F77_INT m = octave::to_f77_int (a.rows ());
+      F77_INT n = octave::to_f77_int (a.cols ());
 
       F77_INT min_mn = m < n ? m : n;
       OCTAVE_LOCAL_BUFFER (double, tau, min_mn);
 
       F77_INT info = 0;
 
       Matrix afact = a;
       if (m > n && qr_type == qr<Matrix>::std)
@@ -113,18 +113,18 @@ namespace octave
     }
 
     template <>
     void
     qrp<FloatMatrix>::init (const FloatMatrix& a, type qr_type)
     {
       assert (qr_type != qr<FloatMatrix>::raw);
 
-      F77_INT m = to_f77_int (a.rows ());
-      F77_INT n = to_f77_int (a.cols ());
+      F77_INT m = octave::to_f77_int (a.rows ());
+      F77_INT n = octave::to_f77_int (a.cols ());
 
       F77_INT min_mn = m < n ? m : n;
       OCTAVE_LOCAL_BUFFER (float, tau, min_mn);
 
       F77_INT info = 0;
 
       FloatMatrix afact = a;
       if (m > n && qr_type == qr<FloatMatrix>::std)
@@ -181,18 +181,18 @@ namespace octave
     }
 
     template <>
     void
     qrp<ComplexMatrix>::init (const ComplexMatrix& a, type qr_type)
     {
       assert (qr_type != qr<ComplexMatrix>::raw);
 
-      F77_INT m = to_f77_int (a.rows ());
-      F77_INT n = to_f77_int (a.cols ());
+      F77_INT m = octave::to_f77_int (a.rows ());
+      F77_INT n = octave::to_f77_int (a.cols ());
 
       F77_INT min_mn = m < n ? m : n;
       OCTAVE_LOCAL_BUFFER (Complex, tau, min_mn);
 
       F77_INT info = 0;
 
       ComplexMatrix afact = a;
       if (m > n && qr_type == qr<ComplexMatrix>::std)
@@ -257,18 +257,18 @@ namespace octave
     }
 
     template <>
     void
     qrp<FloatComplexMatrix>::init (const FloatComplexMatrix& a, type qr_type)
     {
       assert (qr_type != qr<FloatComplexMatrix>::raw);
 
-      F77_INT m = to_f77_int (a.rows ());
-      F77_INT n = to_f77_int (a.cols ());
+      F77_INT m = octave::to_f77_int (a.rows ());
+      F77_INT n = octave::to_f77_int (a.cols ());
 
       F77_INT min_mn = m < n ? m : n;
       OCTAVE_LOCAL_BUFFER (FloatComplex, tau, min_mn);
 
       F77_INT info = 0;
 
       FloatComplexMatrix afact = a;
       if (m > n && qr_type == qr<FloatComplexMatrix>::std)
diff --git a/liboctave/numeric/schur.cc b/liboctave/numeric/schur.cc
--- a/liboctave/numeric/schur.cc
+++ b/liboctave/numeric/schur.cc
@@ -91,18 +91,18 @@ namespace octave
       const FloatComplex& a = reinterpret_cast<const FloatComplex&> (a_arg);
       return (abs (a) < 1.0);
     }
 
     template <>
     F77_INT
     schur<Matrix>::init (const Matrix& a, const std::string& ord, bool calc_unitary)
     {
-      F77_INT a_nr = to_f77_int (a.rows ());
-      F77_INT a_nc = to_f77_int (a.cols ());
+      F77_INT a_nr = octave::to_f77_int (a.rows ());
+      F77_INT a_nc = octave::to_f77_int (a.cols ());
 
       if (a_nr != a_nc)
         (*current_liboctave_error_handler) ("schur: requires square matrix");
 
       if (a_nr == 0)
         {
           schur_mat.clear ();
           unitary_mat.clear ();
@@ -178,18 +178,18 @@ namespace octave
       return info;
     }
 
     template <>
     F77_INT
     schur<FloatMatrix>::init (const FloatMatrix& a, const std::string& ord,
                               bool calc_unitary)
     {
-      F77_INT a_nr = to_f77_int (a.rows ());
-      F77_INT a_nc = to_f77_int (a.cols ());
+      F77_INT a_nr = octave::to_f77_int (a.rows ());
+      F77_INT a_nc = octave::to_f77_int (a.cols ());
 
       if (a_nr != a_nc)
         (*current_liboctave_error_handler) ("SCHUR requires square matrix");
 
       if (a_nr == 0)
         {
           schur_mat.clear ();
           unitary_mat.clear ();
@@ -265,18 +265,18 @@ namespace octave
       return info;
     }
 
     template <>
     F77_INT
     schur<ComplexMatrix>::init (const ComplexMatrix& a, const std::string& ord,
                                 bool calc_unitary)
     {
-      F77_INT a_nr = to_f77_int (a.rows ());
-      F77_INT a_nc = to_f77_int (a.cols ());
+      F77_INT a_nr = octave::to_f77_int (a.rows ());
+      F77_INT a_nc = octave::to_f77_int (a.cols ());
 
       if (a_nr != a_nc)
         (*current_liboctave_error_handler) ("SCHUR requires square matrix");
 
       if (a_nr == 0)
         {
           schur_mat.clear ();
           unitary_mat.clear ();
@@ -350,17 +350,17 @@ namespace octave
 
     template <>
     schur<ComplexMatrix>
     rsf2csf<ComplexMatrix, Matrix> (const Matrix& s_arg, const Matrix& u_arg)
     {
       ComplexMatrix s (s_arg);
       ComplexMatrix u (u_arg);
 
-      F77_INT n = to_f77_int (s.rows ());
+      F77_INT n = octave::to_f77_int (s.rows ());
 
       if (s.columns () != n || u.rows () != n || u.columns () != n)
         (*current_liboctave_error_handler)
           ("rsf2csf: inconsistent matrix dimensions");
 
       if (n > 0)
         {
           OCTAVE_LOCAL_BUFFER (double, c, n-1);
@@ -373,18 +373,18 @@ namespace octave
       return schur<ComplexMatrix> (s, u);
     }
 
     template <>
     F77_INT
     schur<FloatComplexMatrix>::init (const FloatComplexMatrix& a,
                                      const std::string& ord, bool calc_unitary)
     {
-      F77_INT a_nr = to_f77_int (a.rows ());
-      F77_INT a_nc = to_f77_int (a.cols ());
+      F77_INT a_nr = octave::to_f77_int (a.rows ());
+      F77_INT a_nc = octave::to_f77_int (a.cols ());
 
       if (a_nr != a_nc)
         (*current_liboctave_error_handler) ("SCHUR requires square matrix");
 
       if (a_nr == 0)
         {
           schur_mat.clear ();
           unitary_mat.clear ();
@@ -459,17 +459,17 @@ namespace octave
     template <>
     schur<FloatComplexMatrix>
     rsf2csf<FloatComplexMatrix, FloatMatrix> (const FloatMatrix& s_arg,
                                               const FloatMatrix& u_arg)
     {
       FloatComplexMatrix s (s_arg);
       FloatComplexMatrix u (u_arg);
 
-      F77_INT n = to_f77_int (s.rows ());
+      F77_INT n = octave::to_f77_int (s.rows ());
 
       if (s.columns () != n || u.rows () != n || u.columns () != n)
         (*current_liboctave_error_handler)
           ("rsf2csf: inconsistent matrix dimensions");
 
       if (n > 0)
         {
           OCTAVE_LOCAL_BUFFER (float, c, n-1);
diff --git a/liboctave/numeric/svd.cc b/liboctave/numeric/svd.cc
--- a/liboctave/numeric/svd.cc
+++ b/liboctave/numeric/svd.cc
@@ -277,18 +277,18 @@ namespace octave
 
     template<typename T>
     svd<T>::svd (const T& a, svd::Type type,
                  svd::Driver driver)
       : m_type (type), m_driver (driver), left_sm (), sigma (), right_sm ()
     {
       F77_INT info;
 
-      F77_INT m = to_f77_int (a.rows ());
-      F77_INT n = to_f77_int (a.cols ());
+      F77_INT m = octave::to_f77_int (a.rows ());
+      F77_INT n = octave::to_f77_int (a.cols ());
 
       if (m == 0 || n == 0)
         {
           switch (m_type)
             {
             case svd::Type::std:
               left_sm = T (m, m, 0);
               for (F77_INT i = 0; i < m; i++)
