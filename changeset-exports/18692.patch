# HG changeset patch
# User Rik <rik@octave.org>
# Date 1398646967 25200
#      Sun Apr 27 18:02:47 2014 -0700
# Node ID fe0e34be55769b965df4d268d7fcb1e8119f0dd9
# Parent  9a6646cc7c3e7f99f04470b9aff1f482ff6c9edb
maint: untabify recently added code files.

* Backend.cc, BaseControl.cc, ButtonControl.cc, Canvas.cc, Canvas.h,
CheckBoxControl.cc, Container.cc, ContextMenu.cc, EditControl.cc, Figure.cc,
Figure.h, GLCanvas.h, ListBoxControl.cc, Menu.cc, MouseModeActionGroup.cc,
Object.cc, Object.h, ObjectFactory.cc, ObjectProxy.cc, Panel.cc,
PopupMenuControl.cc, PushButtonControl.cc, PushTool.cc, QtHandlesUtils.cc,
QtHandlesUtils.h, RadioButtonControl.cc, SliderControl.cc, TextControl.cc,
ToggleButtonControl.cc, ToggleTool.cc, ToolBar.cc, ToolBarButton.cc,
__init_qt__.cc, pt-jit.cc, ov-classdef.cc, ov-classdef.h: Untabify code.

diff --git a/libgui/graphics/Backend.cc b/libgui/graphics/Backend.cc
--- a/libgui/graphics/Backend.cc
+++ b/libgui/graphics/Backend.cc
@@ -48,37 +48,37 @@ along with Octave; see the file COPYING.
 namespace QtHandles
 {
 
 static std::string toolkitObjectProperty (const graphics_object& go)
 {
   if (go.isa ("figure"))
     return std::string ("__plot_stream__");
   else if (go.isa ("uicontrol")
-	   || go.isa ("uipanel")
-	   || go.isa ("uimenu")
-	   || go.isa ("uicontextmenu")
-	   || go.isa ("uitoolbar")
-	   || go.isa ("uipushtool")
-	   || go.isa ("uitoggletool"))
+           || go.isa ("uipanel")
+           || go.isa ("uimenu")
+           || go.isa ("uicontextmenu")
+           || go.isa ("uitoolbar")
+           || go.isa ("uipushtool")
+           || go.isa ("uitoggletool"))
     return std::string ("__object__");
   else
     qCritical ("QtHandles::Backend: no __object__ property known for object "
-	       "of type %s", go.type ().c_str ());
+               "of type %s", go.type ().c_str ());
 
   return std::string ();
 }
 
 Backend::Backend (void)
   : QObject (), base_graphics_toolkit ("qt")
 {
   ObjectFactory* factory = ObjectFactory::instance ();
 
   connect (this, SIGNAL (createObject (double)),
-	   factory, SLOT (createObject (double)));
+           factory, SLOT (createObject (double)));
 }
 
 Backend::~Backend (void)
 {
 }
 
 bool Backend::initialize (const graphics_object& go)
 {
@@ -87,23 +87,23 @@ bool Backend::initialize (const graphics
       || go.isa ("uipanel")
       || go.isa ("uimenu")
       || go.isa ("uicontextmenu")
       || go.isa ("uitoolbar")
       || go.isa ("uipushtool")
       || go.isa ("uitoggletool"))
     {
       Logger::debug ("Backend::initialize %s from thread %08x",
-		     go.type ().c_str (), QThread::currentThreadId ());
+                     go.type ().c_str (), QThread::currentThreadId ());
 
       ObjectProxy* proxy = new ObjectProxy ();
       graphics_object gObj (go);
 
       gObj.get_properties ().set(toolkitObjectProperty (go),
-				 OCTAVE_PTR_TYPE ((OCTAVE_INTPTR_TYPE) proxy));
+                                 OCTAVE_PTR_TYPE ((OCTAVE_INTPTR_TYPE) proxy));
 
       emit createObject (go.get_handle ().value ());
 
       return true;
     }
 
   return false;
 }
@@ -118,40 +118,40 @@ void Backend::update (const graphics_obj
       || pId == uicontextmenu::properties::ID___OBJECT__
       || pId == uitoolbar::properties::ID___OBJECT__
       || pId == uipushtool::properties::ID___OBJECT__
       || pId == uitoggletool::properties::ID___OBJECT__
       || pId == base_properties::ID___MODIFIED__)
     return;
 
   Logger::debug ("Backend::update %s(%d) from thread %08x",
-		 go.type ().c_str (), pId, QThread::currentThreadId ());
+                 go.type ().c_str (), pId, QThread::currentThreadId ());
 
   ObjectProxy* proxy = toolkitObjectProxy (go);
 
   if (proxy)
     {
       if (go.isa ("uicontrol")
-	  && pId == uicontrol::properties::ID_STYLE)
-	{
-	  // Special case: we need to recreate the control widget
-	  // associated with the octave graphics_object
+          && pId == uicontrol::properties::ID_STYLE)
+        {
+          // Special case: we need to recreate the control widget
+          // associated with the octave graphics_object
 
-	  finalize (go);
-	  initialize (go);
-	}
+          finalize (go);
+          initialize (go);
+        }
       else
-	proxy->update (pId);
+        proxy->update (pId);
     }
 }
 
 void Backend::finalize (const graphics_object& go)
 {
   Logger::debug ("Backend::finalize %s from thread %08x",
-		 go.type ().c_str (), QThread::currentThreadId ());
+                 go.type ().c_str (), QThread::currentThreadId ());
 
   ObjectProxy* proxy = toolkitObjectProxy (go);
 
   if (proxy)
     {
       proxy->finalize ();
       delete proxy;
 
@@ -163,17 +163,17 @@ void Backend::finalize (const graphics_o
 
 void Backend::redraw_figure (const graphics_object& go) const
 {
   if (go.get_properties ().is_visible ())
     {
       ObjectProxy* proxy = toolkitObjectProxy (go);
 
       if (proxy)
-	proxy->redraw ();
+        proxy->redraw ();
     }
 }
 
 Object* Backend::toolkitObject (const graphics_object& go)
 {
   ObjectProxy* proxy = toolkitObjectProxy (go);
 
   if (proxy)
@@ -184,20 +184,20 @@ Object* Backend::toolkitObject (const gr
 
 ObjectProxy* Backend::toolkitObjectProxy (const graphics_object& go)
 {
   if (go)
     {
       octave_value ov = go.get (toolkitObjectProperty (go));
 
       if (ov.is_defined () && ! ov.is_empty ())
-	{
-	  OCTAVE_INTPTR_TYPE ptr = ov.OCTAVE_PTR_SCALAR ().value ();
+        {
+          OCTAVE_INTPTR_TYPE ptr = ov.OCTAVE_PTR_SCALAR ().value ();
 
-	  if (! error_state)
-	    return reinterpret_cast<ObjectProxy*> (ptr);
-	}
+          if (! error_state)
+            return reinterpret_cast<ObjectProxy*> (ptr);
+        }
     }
 
   return 0;
 }
 
 };
diff --git a/libgui/graphics/BaseControl.cc b/libgui/graphics/BaseControl.cc
--- a/libgui/graphics/BaseControl.cc
+++ b/libgui/graphics/BaseControl.cc
@@ -40,34 +40,34 @@ static void updatePalette (const uicontr
 {
   QPalette p = w->palette ();
 
   if (props.style_is ("edit")
       || props.style_is ("listbox")
       || props.style_is ("popupmenu"))
     {
       p.setColor (QPalette::Base,
-		  Utils::fromRgb (props.get_backgroundcolor_rgb ()));
+                  Utils::fromRgb (props.get_backgroundcolor_rgb ()));
       p.setColor (QPalette::Text,
-		  Utils::fromRgb (props.get_foregroundcolor_rgb ()));
+                  Utils::fromRgb (props.get_foregroundcolor_rgb ()));
     }
   else if (props.style_is ("pushbutton")
-	   || props.style_is ("togglebutton"))
+           || props.style_is ("togglebutton"))
     {
       p.setColor (QPalette::Button,
-		  Utils::fromRgb (props.get_backgroundcolor_rgb ()));
+                  Utils::fromRgb (props.get_backgroundcolor_rgb ()));
       p.setColor (QPalette::ButtonText,
-		  Utils::fromRgb (props.get_foregroundcolor_rgb ()));
+                  Utils::fromRgb (props.get_foregroundcolor_rgb ()));
     }
   else
     {
       p.setColor (QPalette::Window,
-		  Utils::fromRgb (props.get_backgroundcolor_rgb ()));
+                  Utils::fromRgb (props.get_backgroundcolor_rgb ()));
       p.setColor (QPalette::WindowText,
-		  Utils::fromRgb (props.get_foregroundcolor_rgb ()));
+                  Utils::fromRgb (props.get_foregroundcolor_rgb ()));
     }
 
   w->setPalette (p);
 }
 
 BaseControl::BaseControl (const graphics_object& go, QWidget* w)
   : Object (go, w), m_normalizedFont (false), m_keyPressHandlerDefined (false)
 {
@@ -78,17 +78,17 @@ void BaseControl::init (QWidget* w, bool
 {
   if (callBase)
     Object::init (w, callBase);
 
   uicontrol::properties& up = properties<uicontrol> ();
 
   Matrix bb = up.get_boundingbox (false);
   w->setGeometry (xround (bb(0)), xround (bb(1)),
-		  xround (bb(2)), xround (bb(3)));
+                  xround (bb(2)), xround (bb(3)));
   w->setFont (Utils::computeFont<uicontrol> (up, bb(3)));
   updatePalette (up, w);
   w->setEnabled (up.enable_is ("on"));
   w->setToolTip (Utils::fromStdString (up.get_tooltipstring ()));
   w->setVisible (up.is_visible ());
   m_keyPressHandlerDefined = ! up.get_keypressfcn ().is_empty ();
 
   w->installEventFilter (this);
@@ -103,21 +103,21 @@ BaseControl::~BaseControl (void)
 void BaseControl::update (int pId)
 {
   uicontrol::properties& up = properties<uicontrol> ();
   QWidget* w = qWidget<QWidget> ();
 
    switch (pId)
     {
     case uicontrol::properties::ID_POSITION:
-	{
-	  Matrix bb = up.get_boundingbox (false);
-	  w->setGeometry (xround (bb(0)), xround (bb(1)),
-			  xround (bb(2)), xround (bb(3)));
-	}
+        {
+          Matrix bb = up.get_boundingbox (false);
+          w->setGeometry (xround (bb(0)), xround (bb(1)),
+                          xround (bb(2)), xround (bb(3)));
+        }
       break;
     case uicontrol::properties::ID_FONTNAME:
     case uicontrol::properties::ID_FONTSIZE:
     case uicontrol::properties::ID_FONTWEIGHT:
     case uicontrol::properties::ID_FONTANGLE:
       w->setFont (Utils::computeFont<uicontrol> (up));
       break;
     case uicontrol::properties::ID_FONTUNITS:
@@ -148,66 +148,66 @@ void BaseControl::update (int pId)
 }
 
 bool BaseControl::eventFilter (QObject* watched, QEvent* event)
 {
   switch (event->type ())
     {
     case QEvent::Resize:
       if (m_normalizedFont)
-	{
-	  gh_manager::auto_lock lock;
+        {
+          gh_manager::auto_lock lock;
 
-	  qWidget<QWidget> ()->setFont (Utils::computeFont<uicontrol>
-					(properties<uicontrol> ()));
-	}
+          qWidget<QWidget> ()->setFont (Utils::computeFont<uicontrol>
+                                        (properties<uicontrol> ()));
+        }
       break;
     case QEvent::MouseButtonPress:
-	{
-	  gh_manager::auto_lock lock;
+        {
+          gh_manager::auto_lock lock;
 
-	  QMouseEvent* m = dynamic_cast<QMouseEvent*> (event);
-	  graphics_object go = object ();
-	  uicontrol::properties& up = Utils::properties<uicontrol> (go);
-	  graphics_object fig = go.get_ancestor ("figure");
+          QMouseEvent* m = dynamic_cast<QMouseEvent*> (event);
+          graphics_object go = object ();
+          uicontrol::properties& up = Utils::properties<uicontrol> (go);
+          graphics_object fig = go.get_ancestor ("figure");
 
-	  if (m->button () != Qt::LeftButton
-	      || ! up.enable_is ("on"))
-	    {
-	      gh_manager::post_set (fig.get_handle (), "selectiontype",
-				    Utils::figureSelectionType (m), false);
-	      gh_manager::post_set (fig.get_handle (), "currentpoint",
-				    Utils::figureCurrentPoint (fig, m),
-				    false);
-	      gh_manager::post_callback (fig.get_handle (),
-					 "windowbuttondownfcn");
-	      gh_manager::post_callback (m_handle, "buttondownfcn");
+          if (m->button () != Qt::LeftButton
+              || ! up.enable_is ("on"))
+            {
+              gh_manager::post_set (fig.get_handle (), "selectiontype",
+                                    Utils::figureSelectionType (m), false);
+              gh_manager::post_set (fig.get_handle (), "currentpoint",
+                                    Utils::figureCurrentPoint (fig, m),
+                                    false);
+              gh_manager::post_callback (fig.get_handle (),
+                                         "windowbuttondownfcn");
+              gh_manager::post_callback (m_handle, "buttondownfcn");
 
-	      if (m->button () == Qt::RightButton)
-		ContextMenu::executeAt (up, m->globalPos ());
-	    }
-	  else
-	    {
-	      if (up.style_is ("listbox"))
-		gh_manager::post_set (fig.get_handle (), "selectiontype",
-				      Utils::figureSelectionType (m), false);
-	      else
-		gh_manager::post_set (fig.get_handle (), "selectiontype",
-				      octave_value ("normal"), false);
-	    }
-	}
+              if (m->button () == Qt::RightButton)
+                ContextMenu::executeAt (up, m->globalPos ());
+            }
+          else
+            {
+              if (up.style_is ("listbox"))
+                gh_manager::post_set (fig.get_handle (), "selectiontype",
+                                      Utils::figureSelectionType (m), false);
+              else
+                gh_manager::post_set (fig.get_handle (), "selectiontype",
+                                      octave_value ("normal"), false);
+            }
+        }
       break;
     case QEvent::MouseMove:
       if (qWidget<QWidget> ()->hasMouseTracking ())
         {
-	  gh_manager::auto_lock lock;
+          gh_manager::auto_lock lock;
 
-	  QMouseEvent* m = dynamic_cast<QMouseEvent*> (event);
-	  graphics_object go = object ();
-	  graphics_object fig = go.get_ancestor ("figure");
+          QMouseEvent* m = dynamic_cast<QMouseEvent*> (event);
+          graphics_object go = object ();
+          graphics_object fig = go.get_ancestor ("figure");
 
           gh_manager::post_set (fig.get_handle (), "currentpoint",
                                 Utils::figureCurrentPoint (fig, m), false);
           gh_manager::post_callback (fig.get_handle (), "windowbuttonmotionfcn");
         }
       break;
     case QEvent::KeyPress:
       if (m_keyPressHandlerDefined)
diff --git a/libgui/graphics/ButtonControl.cc b/libgui/graphics/ButtonControl.cc
--- a/libgui/graphics/ButtonControl.cc
+++ b/libgui/graphics/ButtonControl.cc
@@ -41,17 +41,17 @@ ButtonControl::ButtonControl (const grap
   btn->setText (Utils::fromStdString (up.get_string_string ()));
   if (btn->isCheckable () || up.style_is ("togglebutton"))
     {
       btn->setCheckable (true);
 
       Matrix value = up.get_value ().matrix_value ();
 
       if (value.numel () > 0 && value(0) == up.get_max ())
-	btn->setChecked (true);
+        btn->setChecked (true);
     }
 
   connect (btn, SIGNAL (clicked (void)), SLOT (clicked (void)));
   connect (btn, SIGNAL (toggled (bool)), SLOT (toggled (bool)));
 }
 
 ButtonControl::~ButtonControl (void)
 {
@@ -65,29 +65,29 @@ void ButtonControl::update (int pId)
   switch (pId)
     {
     case uicontrol::properties::ID_STRING:
       btn->setText (Utils::fromStdString (up.get_string_string ()));
       break;
     case uicontrol::properties::ID_VALUE:
       m_blockCallback = true;
       if (btn->isCheckable ())
-	{
-	  Matrix value = up.get_value ().matrix_value ();
+        {
+          Matrix value = up.get_value ().matrix_value ();
 
-	  if (value.numel () > 0)
-	    {
-	      double dValue = value(0);
+          if (value.numel () > 0)
+            {
+              double dValue = value(0);
 
-	      if (dValue == up.get_min () && btn->isChecked ())
-		btn->setChecked (false);
-	      else if (dValue == up.get_max () && ! btn->isChecked ())
-		btn->setChecked (true);
-	    }
-	}
+              if (dValue == up.get_min () && btn->isChecked ())
+                btn->setChecked (false);
+              else if (dValue == up.get_max () && ! btn->isChecked ())
+                btn->setChecked (true);
+            }
+        }
       m_blockCallback = false;
       break;
     default:
       BaseControl::update (pId);
       break;
     }
 }
 
@@ -100,18 +100,18 @@ void ButtonControl::toggled (bool checke
       gh_manager::auto_lock lock;
 
       uicontrol::properties& up = properties<uicontrol> ();
 
       Matrix oldValue = up.get_value ().matrix_value ();
       double newValue = (checked ? up.get_max () : up.get_min ());
 
       if (oldValue.numel() != 1
-	  || (newValue != oldValue(0)))
-	gh_manager::post_set (m_handle, "value", newValue, false);
+          || (newValue != oldValue(0)))
+        gh_manager::post_set (m_handle, "value", newValue, false);
       gh_manager::post_callback (m_handle, "callback");
     }
 }
 
 void ButtonControl::clicked (void)
 {
   QAbstractButton* btn = qWidget<QAbstractButton> ();
 
diff --git a/libgui/graphics/Canvas.cc b/libgui/graphics/Canvas.cc
--- a/libgui/graphics/Canvas.cc
+++ b/libgui/graphics/Canvas.cc
@@ -90,101 +90,101 @@ void Canvas::canvasPaintEvent (void)
 {
   if (! m_redrawBlocked)
     {
       gh_manager::auto_lock lock;
 
       draw (m_handle);
 
       if (m_mouseMode == ZoomMode && m_mouseAxes.ok ())
-	drawZoomBox (m_mouseAnchor, m_mouseCurrent);
+        drawZoomBox (m_mouseAnchor, m_mouseCurrent);
     }
 }
 
 void Canvas::canvasMouseMoveEvent (QMouseEvent* event)
 {
   gh_manager::auto_lock lock;
   graphics_object ax = gh_manager::get_object (m_mouseAxes);
 
   if (m_mouseMode != NoMode && ax.valid_object ())
     {
       axes::properties& ap = Utils::properties<axes> (ax);
 
       switch (m_mouseMode)
-	{
-	case RotateMode:
-	    {
-	      Matrix bb = ap.get_boundingbox (true);
-	      Matrix view = ap.get_view ().matrix_value ();
+        {
+        case RotateMode:
+            {
+              Matrix bb = ap.get_boundingbox (true);
+              Matrix view = ap.get_view ().matrix_value ();
 
-	      // Compute new view angles
-	      view(0) += ((m_mouseCurrent.x () - event->x ())
-			  * (180.0 / bb(2)));
-	      view(1) += ((event->y () - m_mouseCurrent.y ())
-			  * (180.0 / bb(3)));
+              // Compute new view angles
+              view(0) += ((m_mouseCurrent.x () - event->x ())
+                          * (180.0 / bb(2)));
+              view(1) += ((event->y () - m_mouseCurrent.y ())
+                          * (180.0 / bb(3)));
 
-	      // Clipping
-	      view(1) = std::min (view(1), 90.0);
-	      view(1) = std::max (view(1), -90.0);
-	      if (view(0) > 180.0)
-		view(0) -= 360.0;
-	      else if (view(0) < -180.0)
-		view(0) += 360.0;
+              // Clipping
+              view(1) = std::min (view(1), 90.0);
+              view(1) = std::max (view(1), -90.0);
+              if (view(0) > 180.0)
+                view(0) -= 360.0;
+              else if (view(0) < -180.0)
+                view(0) += 360.0;
 
-	      // Snapping
-	      double snapMargin = 1.0;
-	      for (int a = -90; a <= 90; a += 90)
-		if ((a - snapMargin) < view(1)
-		    && view(1) < (a + snapMargin))
-		  {
-		    view(1) = a;
-		    break;
-		  }
-	      for (int a = -180; a <= 180; a += 180)
-		if ((a - snapMargin) < view(0)
-		    && view(0) < (a + snapMargin))
-		  {
-		    if (a == 180)
-		      view(0) = -180;
-		    else
-		      view(0) = a;
-		    break;
-		  }
+              // Snapping
+              double snapMargin = 1.0;
+              for (int a = -90; a <= 90; a += 90)
+                if ((a - snapMargin) < view(1)
+                    && view(1) < (a + snapMargin))
+                  {
+                    view(1) = a;
+                    break;
+                  }
+              for (int a = -180; a <= 180; a += 180)
+                if ((a - snapMargin) < view(0)
+                    && view(0) < (a + snapMargin))
+                  {
+                    if (a == 180)
+                      view(0) = -180;
+                    else
+                      view(0) = a;
+                    break;
+                  }
 
-	      // Update axes properties
-	      ap.set_view (view);
+              // Update axes properties
+              ap.set_view (view);
 
-	      // Update current mouse position
-	      m_mouseCurrent = event->pos ();
+              // Update current mouse position
+              m_mouseCurrent = event->pos ();
 
-	      // Force immediate redraw
-	      redraw (true);
-	    }
-	  break;
-	case ZoomMode:
-	  m_mouseCurrent = event->pos();
-	  redraw (true);
-	  break;
-	case PanMode:
-	  break;
-	default:
-	  break;
-	}
+              // Force immediate redraw
+              redraw (true);
+            }
+          break;
+        case ZoomMode:
+          m_mouseCurrent = event->pos();
+          redraw (true);
+          break;
+        case PanMode:
+          break;
+        default:
+          break;
+        }
     }
   else if (m_mouseMode == NoMode)
     {
       graphics_object obj = gh_manager::get_object (m_handle);
 
       if (obj.valid_object ())
         {
           graphics_object figObj (obj.get_ancestor ("figure"));
 
           updateCurrentPoint (figObj, obj, event);
-	  gh_manager::post_callback (figObj.get_handle (),
-				     "windowbuttonmotionfcn");
+          gh_manager::post_callback (figObj.get_handle (),
+                                     "windowbuttonmotionfcn");
         }
     }
 }
 
 void Canvas::canvasMousePressEvent (QMouseEvent* event)
 {
   gh_manager::auto_lock lock;
   graphics_object obj = gh_manager::get_object (m_handle);
@@ -194,34 +194,34 @@ void Canvas::canvasMousePressEvent (QMou
       graphics_object figObj (obj.get_ancestor ("figure"));
       graphics_object currentObj, axesObj;
       QList<graphics_object> axesList;
 
       Matrix children = obj.get_properties ().get_children ();
       octave_idx_type num_children = children.numel ();
 
       for (int i = 0; i < num_children; i++)
-	{
-	  graphics_object childObj (gh_manager::get_object (children(i)));
+        {
+          graphics_object childObj (gh_manager::get_object (children(i)));
 
           if (childObj.isa ("axes"))
             axesList.append (childObj);
-	  else if (childObj.isa ("uicontrol") || childObj.isa ("uipanel"))
-	    {
-	      Matrix bb = childObj.get_properties ().get_boundingbox (false);
-	      QRectF r (bb(0), bb(1), bb(2), bb(3));
+          else if (childObj.isa ("uicontrol") || childObj.isa ("uipanel"))
+            {
+              Matrix bb = childObj.get_properties ().get_boundingbox (false);
+              QRectF r (bb(0), bb(1), bb(2), bb(3));
 
-	      r.adjust (-5, -5, 5, 5);
-	      if (r.contains (event->posF ()))
-		{
-		  currentObj = childObj;
-		  break;
-		}
-	    }
-	}
+              r.adjust (-5, -5, 5, 5);
+              if (r.contains (event->posF ()))
+                {
+                  currentObj = childObj;
+                  break;
+                }
+            }
+        }
 
       if (! currentObj)
         {
           for (QList<graphics_object>::ConstIterator it = axesList.begin ();
                it != axesList.end (); ++it)
             {
               graphics_object go = selectFromAxes (*it, event->pos ());
 
@@ -264,104 +264,104 @@ void Canvas::canvasMousePressEvent (QMou
       else
         Utils::properties<figure> (figObj).set_currentobject (octave_NaN);
 
       Figure* fig = dynamic_cast<Figure*> (Backend::toolkitObject (figObj));
 
       MouseMode newMouseMode = NoMode;
 
       if (fig)
-	newMouseMode = fig->mouseMode ();
+        newMouseMode = fig->mouseMode ();
 
       switch (newMouseMode)
-	{
-	case NoMode:
-	  gh_manager::post_set (figObj.get_handle (), "selectiontype",
-				Utils::figureSelectionType (event), false);
+        {
+        case NoMode:
+          gh_manager::post_set (figObj.get_handle (), "selectiontype",
+                                Utils::figureSelectionType (event), false);
           updateCurrentPoint (figObj, obj, event);
-	  gh_manager::post_callback (figObj.get_handle (),
-				     "windowbuttondownfcn");
+          gh_manager::post_callback (figObj.get_handle (),
+                                     "windowbuttondownfcn");
           gh_manager::post_callback (currentObj.get_handle (),
                                      "buttondownfcn");
-	  if (event->button () == Qt::RightButton)
-	    ContextMenu::executeAt (currentObj.get_properties (),
-				    event->globalPos ());
-	  break;
-	case RotateMode:
-	case ZoomMode:
-	case PanMode:
-	  if (axesObj)
-	    {
-	      if (event->buttons () == Qt::LeftButton
-		  && event->modifiers () == Qt::NoModifier)
-		{
-		  m_mouseAnchor = m_mouseCurrent = event->pos ();
-		  m_mouseAxes = axesObj.get_handle ();
-		  m_mouseMode = newMouseMode;
-		}
-	      else if (newMouseMode == ZoomMode
-		       && event->modifiers () == Qt::NoModifier)
-		{
-		  switch (event->buttons ())
-		    {
-		    case Qt::RightButton:
-		      Utils::properties<axes> (axesObj).unzoom ();
-		      break;
-		    case Qt::MidButton:
-			{
-			  axes::properties& ap =
-			    Utils::properties<axes> (axesObj);
+          if (event->button () == Qt::RightButton)
+            ContextMenu::executeAt (currentObj.get_properties (),
+                                    event->globalPos ());
+          break;
+        case RotateMode:
+        case ZoomMode:
+        case PanMode:
+          if (axesObj)
+            {
+              if (event->buttons () == Qt::LeftButton
+                  && event->modifiers () == Qt::NoModifier)
+                {
+                  m_mouseAnchor = m_mouseCurrent = event->pos ();
+                  m_mouseAxes = axesObj.get_handle ();
+                  m_mouseMode = newMouseMode;
+                }
+              else if (newMouseMode == ZoomMode
+                       && event->modifiers () == Qt::NoModifier)
+                {
+                  switch (event->buttons ())
+                    {
+                    case Qt::RightButton:
+                      Utils::properties<axes> (axesObj).unzoom ();
+                      break;
+                    case Qt::MidButton:
+                        {
+                          axes::properties& ap =
+                            Utils::properties<axes> (axesObj);
 
-			  ap.clear_zoom_stack ();
-			  ap.set_xlimmode ("auto");
-			  ap.set_ylimmode ("auto");
-			  ap.set_zlimmode ("auto");
-			}
-		      break;
-		    }
-		  redraw (false);
-		}
-	    }
-	  break;
-	default:
-	  break;
-	}
+                          ap.clear_zoom_stack ();
+                          ap.set_xlimmode ("auto");
+                          ap.set_ylimmode ("auto");
+                          ap.set_zlimmode ("auto");
+                        }
+                      break;
+                    }
+                  redraw (false);
+                }
+            }
+          break;
+        default:
+          break;
+        }
     }
 }
 
 void Canvas::canvasMouseReleaseEvent (QMouseEvent* event)
 {
   if (m_mouseMode == ZoomMode
       && m_mouseAxes.ok ()
       && m_mouseAnchor != event->pos ())
     {
       gh_manager::auto_lock lock;
       graphics_object ax = gh_manager::get_object (m_mouseAxes);
 
       if (ax.valid_object ())
-	{
-	  axes::properties& ap = Utils::properties<axes> (ax);
+        {
+          axes::properties& ap = Utils::properties<axes> (ax);
 
-	  ColumnVector p0 = ap.pixel2coord (m_mouseAnchor.x (),
-					    m_mouseAnchor.y ());
-	  ColumnVector p1 = ap.pixel2coord (event->x (),
-					    event->y ());
+          ColumnVector p0 = ap.pixel2coord (m_mouseAnchor.x (),
+                                            m_mouseAnchor.y ());
+          ColumnVector p1 = ap.pixel2coord (event->x (),
+                                            event->y ());
 
-	  Matrix xl (1, 2, 0.0);
-	  Matrix yl (1, 2, 0.0);
+          Matrix xl (1, 2, 0.0);
+          Matrix yl (1, 2, 0.0);
 
-	  xl(0) = std::min (p0(0), p1(0));
-	  xl(1) = std::max (p0(0), p1(0));
-	  yl(0) = std::min (p0(1), p1(1));
-	  yl(1) = std::max (p0(1), p1(1));
+          xl(0) = std::min (p0(0), p1(0));
+          xl(1) = std::max (p0(0), p1(0));
+          yl(0) = std::min (p0(1), p1(1));
+          yl(1) = std::max (p0(1), p1(1));
 
-	  ap.zoom (xl, yl);
+          ap.zoom (xl, yl);
 
-	  redraw (false);
-	}
+          redraw (false);
+        }
     }
   else if (m_mouseMode == NoMode)
     {
       gh_manager::auto_lock lock;
       graphics_object obj = gh_manager::get_object (m_handle);
 
       if (obj.valid_object ())
         {
@@ -402,15 +402,15 @@ bool Canvas::canvasKeyReleaseEvent (QKey
 
       return true;
     }
 
   return false;
 }
 
 Canvas* Canvas::create (const std::string& /* name */, QWidget* parent,
-			const graphics_handle& handle)
+                        const graphics_handle& handle)
 {
   // Only OpenGL
   return new GLCanvas (parent, handle);
 }
 
 }; // namespace QtHandles
diff --git a/libgui/graphics/Canvas.h b/libgui/graphics/Canvas.h
--- a/libgui/graphics/Canvas.h
+++ b/libgui/graphics/Canvas.h
@@ -53,17 +53,17 @@ public:
 
   void addEventMask (int m) { m_eventMask |= m; }
   void clearEventMask (int m) { m_eventMask &= (~m); }
   void setEventMask (int m) { m_eventMask = m; }
 
   virtual QWidget* qWidget (void) = 0;
 
   static Canvas* create (const std::string& name, QWidget* parent,
-			 const graphics_handle& handle);
+                         const graphics_handle& handle);
 
 protected:
   virtual void draw (const graphics_handle& handle) = 0;
   virtual void drawZoomBox (const QPoint& p1, const QPoint& p2) = 0;
   virtual void resize (int x, int y, int width, int height) = 0;
   virtual graphics_object selectFromAxes (const graphics_object& ax,
                                           const QPoint& pt) = 0;
 
diff --git a/libgui/graphics/CheckBoxControl.cc b/libgui/graphics/CheckBoxControl.cc
--- a/libgui/graphics/CheckBoxControl.cc
+++ b/libgui/graphics/CheckBoxControl.cc
@@ -36,17 +36,17 @@ CheckBoxControl* CheckBoxControl::create
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
-	return new CheckBoxControl (go, new QCheckBox (container));
+        return new CheckBoxControl (go, new QCheckBox (container));
     }
 
   return 0;
 }
 
 CheckBoxControl::CheckBoxControl (const graphics_object& go, QCheckBox* box)
     : ButtonControl (go, box)
 {
diff --git a/libgui/graphics/Container.cc b/libgui/graphics/Container.cc
--- a/libgui/graphics/Container.cc
+++ b/libgui/graphics/Container.cc
@@ -49,55 +49,55 @@ Container::~Container (void)
 
 Canvas* Container::canvas (const graphics_handle& handle, bool create)
 {
   if (! m_canvas && create)
     {
       graphics_object go = gh_manager::get_object (handle);
 
       if (go)
-	{
-	  graphics_object fig = go.get_ancestor ("figure");
+        {
+          graphics_object fig = go.get_ancestor ("figure");
 
-	  m_canvas = Canvas::create (fig.get("renderer").string_value (),
-				     this, handle);
+          m_canvas = Canvas::create (fig.get("renderer").string_value (),
+                                     this, handle);
 
-	  QWidget* canvasWidget = m_canvas->qWidget ();
+          QWidget* canvasWidget = m_canvas->qWidget ();
 
-	  canvasWidget->lower ();
-	  canvasWidget->show ();
-	  canvasWidget->setGeometry (0, 0, width (), height ());
-	}
+          canvasWidget->lower ();
+          canvasWidget->show ();
+          canvasWidget->setGeometry (0, 0, width (), height ());
+        }
     }
 
   return m_canvas;
 }
 
 void Container::resizeEvent (QResizeEvent* /* event */)
 {
   if (m_canvas)
     m_canvas->qWidget ()->setGeometry (0, 0, width (), height ());
 
   gh_manager::auto_lock lock;
 
   foreach (QObject* qObj, children ())
     {
       if (qObj->isWidgetType ())
-	{
-	  Object* obj = Object::fromQObject (qObj);
+        {
+          Object* obj = Object::fromQObject (qObj);
 
-	  if (obj)
-	    {
-	      Matrix bb = obj->properties ().get_boundingbox (false);
+          if (obj)
+            {
+              Matrix bb = obj->properties ().get_boundingbox (false);
 
-	      obj->qWidget<QWidget> ()
-		->setGeometry (xround (bb(0)), xround (bb(1)),
-			       xround (bb(2)), xround (bb(3)));
-	    }
-	}
+              obj->qWidget<QWidget> ()
+                ->setGeometry (xround (bb(0)), xround (bb(1)),
+                               xround (bb(2)), xround (bb(3)));
+            }
+        }
     }
 }
 
 void Container::childEvent (QChildEvent* event)
 {
   if (event->child ()->isWidgetType ())
     {
       qobject_cast<QWidget*> (event->child ())->setMouseTracking (hasMouseTracking ());
diff --git a/libgui/graphics/ContextMenu.cc b/libgui/graphics/ContextMenu.cc
--- a/libgui/graphics/ContextMenu.cc
+++ b/libgui/graphics/ContextMenu.cc
@@ -66,29 +66,29 @@ void ContextMenu::update (int pId)
 {
   uicontextmenu::properties& up = properties<uicontextmenu> ();
   QMenu* menu = qWidget<QMenu> ();
 
   switch (pId)
     {
     case base_properties::ID_VISIBLE:
       if (up.is_visible ())
-	{
-	  Matrix pos = up.get_position ().matrix_value ();
-	  QWidget* parentW = menu->parentWidget ();
-	  QPoint pt;
+        {
+          Matrix pos = up.get_position ().matrix_value ();
+          QWidget* parentW = menu->parentWidget ();
+          QPoint pt;
 
-	  pt.rx () = xround (pos(0));
-	  pt.ry () = parentW->height () - xround (pos(1));
-	  pt = parentW->mapToGlobal (pt);
+          pt.rx () = xround (pos(0));
+          pt.ry () = parentW->height () - xround (pos(1));
+          pt = parentW->mapToGlobal (pt);
 
-	  menu->popup (pt);
-	}
+          menu->popup (pt);
+        }
       else
-	menu->hide ();
+        menu->hide ();
       break;
     default:
       Object::update (pId);
       break;
     }
 }
 
 void ContextMenu::aboutToShow (void)
@@ -111,24 +111,24 @@ void ContextMenu::executeAt (const base_
 {
   graphics_handle h = props.get_uicontextmenu ();
 
   if (h.ok ())
     {
       graphics_object go = gh_manager::get_object (h);
 
       if (go.valid_object ())
-	{
-	  ContextMenu* cMenu =
-	    dynamic_cast<ContextMenu*> (Backend::toolkitObject (go));
+        {
+          ContextMenu* cMenu =
+            dynamic_cast<ContextMenu*> (Backend::toolkitObject (go));
 
-	  if (cMenu)
-	    {
-	      QMenu* menu = cMenu->qWidget<QMenu> ();
+          if (cMenu)
+            {
+              QMenu* menu = cMenu->qWidget<QMenu> ();
 
-	      if (menu)
-		menu->popup (pt);
-	    }
-	}
+              if (menu)
+                menu->popup (pt);
+            }
+        }
     }
 }
 
 }; // namespace QtHandles
diff --git a/libgui/graphics/EditControl.cc b/libgui/graphics/EditControl.cc
--- a/libgui/graphics/EditControl.cc
+++ b/libgui/graphics/EditControl.cc
@@ -38,24 +38,24 @@ EditControl* EditControl::create (const 
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
-	{
-	  uicontrol::properties& up = Utils::properties<uicontrol> (go);
+        {
+          uicontrol::properties& up = Utils::properties<uicontrol> (go);
 
-	  if ((up.get_max () - up.get_min ()) > 1)
-	    return new EditControl (go, new TextEdit (container));
-	  else
-	    return new EditControl (go, new QLineEdit (container));
-	}
+          if ((up.get_max () - up.get_min ()) > 1)
+            return new EditControl (go, new TextEdit (container));
+          else
+            return new EditControl (go, new QLineEdit (container));
+        }
     }
 
   return 0;
 }
 
 EditControl::EditControl (const graphics_object& go, QLineEdit* edit)
      : BaseControl (go, edit), m_multiLine (false), m_textChanged (false)
 {
@@ -69,22 +69,22 @@ void EditControl::init (QLineEdit* edit,
 
   m_multiLine = false;
   initCommon (edit);
 
   uicontrol::properties& up = properties<uicontrol> ();
 
   edit->setText (Utils::fromStdString (up.get_string_string ()));
   edit->setAlignment (Utils::fromHVAlign (up.get_horizontalalignment (),
-					  up.get_verticalalignment ()));
+                                          up.get_verticalalignment ()));
 
   connect (edit, SIGNAL (textEdited (const QString&)),
-	   SLOT (textChanged (void)));
+           SLOT (textChanged (void)));
   connect (edit, SIGNAL (editingFinished (void)),
-	   SLOT (editingFinished (void)));
+           SLOT (editingFinished (void)));
 }
 
 EditControl::EditControl (const graphics_object& go, TextEdit* edit)
      : BaseControl (go, edit), m_multiLine (true), m_textChanged (false)
 {
   init (edit);
 }
 
@@ -98,19 +98,19 @@ void EditControl::init (TextEdit* edit, 
 
   uicontrol::properties& up = properties<uicontrol> ();
 
   edit->setAcceptRichText (false);
   // FIXME: support string_vector
   edit->setPlainText (Utils::fromStdString (up.get_string_string ()));
   
   connect (edit, SIGNAL (textChanged (void)),
-	   SLOT (textChanged (void)));
+           SLOT (textChanged (void)));
   connect (edit, SIGNAL (editingFinished (void)),
-	   SLOT (editingFinished (void)));
+           SLOT (editingFinished (void)));
 }
 
 EditControl::~EditControl (void)
 {
 }
 
 void EditControl::initCommon (QWidget*)
 {
@@ -124,48 +124,48 @@ void EditControl::update (int pId)
   if (m_multiLine)
     handled = updateMultiLine (pId);
   else
     handled = updateSingleLine (pId);
 
   if (! handled)
     {
       switch (pId)
-	{
-	default:
-	  BaseControl::update (pId);
-	  break;
-	}
+        {
+        default:
+          BaseControl::update (pId);
+          break;
+        }
     }
 }
 
 bool EditControl::updateSingleLine (int pId)
 {
   uicontrol::properties& up = properties<uicontrol> ();
   QLineEdit* edit = qWidget<QLineEdit> ();
 
   switch (pId)
     {
     case uicontrol::properties::ID_STRING:
       edit->setText (Utils::fromStdString (up.get_string_string ()));
       return true;
     case uicontrol::properties::ID_HORIZONTALALIGNMENT:
     case uicontrol::properties::ID_VERTICALALIGNMENT:
       edit->setAlignment (Utils::fromHVAlign (up.get_horizontalalignment (),
-					      up.get_verticalalignment ()));
+                                              up.get_verticalalignment ()));
       return true;
     case uicontrol::properties::ID_MIN:
     case uicontrol::properties::ID_MAX:
       if ((up.get_max () - up.get_min ()) > 1)
-	{
-	  QWidget* container = edit->parentWidget ();
+        {
+          QWidget* container = edit->parentWidget ();
 
-	  delete edit;
-	  init (new TextEdit (container), true);
-	}
+          delete edit;
+          init (new TextEdit (container), true);
+        }
       return true;
     default:
       break;
     }
 
   return false;
 }
 
@@ -177,22 +177,22 @@ bool EditControl::updateMultiLine (int p
   switch (pId)
     {
     case uicontrol::properties::ID_STRING:
       edit->setPlainText (Utils::fromStdString (up.get_string_string ()));
       return true;
     case uicontrol::properties::ID_MIN:
     case uicontrol::properties::ID_MAX:
       if ((up.get_max () - up.get_min ()) <= 1)
-	{
-	  QWidget* container = edit->parentWidget ();
+        {
+          QWidget* container = edit->parentWidget ();
 
-	  delete edit;
-	  init (new QLineEdit (container), true);
-	}
+          delete edit;
+          init (new QLineEdit (container), true);
+        }
       return true;
     default:
       break;
     }
 
   return false;
 }
 
@@ -201,18 +201,18 @@ void EditControl::textChanged (void)
   m_textChanged = true;
 }
 
 void EditControl::editingFinished (void)
 {
   if (m_textChanged)
     {
       QString txt = (m_multiLine
-		     ? qWidget<TextEdit> ()->toPlainText ()
-		     : qWidget<QLineEdit> ()->text ());
+                     ? qWidget<TextEdit> ()->toPlainText ()
+                     : qWidget<QLineEdit> ()->text ());
 
       gh_manager::post_set (m_handle, "string", Utils::toStdString (txt), false);
       gh_manager::post_callback (m_handle, "callback");
 
       m_textChanged = false;
     }
 }
 
diff --git a/libgui/graphics/Figure.cc b/libgui/graphics/Figure.cc
--- a/libgui/graphics/Figure.cc
+++ b/libgui/graphics/Figure.cc
@@ -56,33 +56,33 @@ static bool hasUiControlChildren (const 
 {
   Matrix kids = fp.get_all_children ();
 
   for (int i = 0; i < kids.numel (); i++)
     {
       graphics_object go (gh_manager::get_object (kids(i)));
 
       if (go && (go.isa ("uicontrol") || go.isa ("uipanel")
-		 || go.isa ("uibuttongroup")))
-	return true;
+                 || go.isa ("uibuttongroup")))
+        return true;
     }
 
   return false;
 }
 
 static bool hasUiMenuChildren (const figure::properties& fp)
 {
   Matrix kids = fp.get_all_children ();
 
   for (int i = 0; i < kids.numel (); i++)
     {
       graphics_object go (gh_manager::get_object (kids(i)));
 
       if (go && go.isa ("uimenu"))
-	return true;
+        return true;
     }
 
   return false;
 }
 
 static QRect boundingBoxToRect (const Matrix& bb)
 {
   QRect r;
@@ -168,48 +168,48 @@ void Figure::createFigureToolBarAndMenuB
   QMainWindow* win = qWidget<QMainWindow> ();
 
   m_figureToolBar = win->addToolBar (tr ("Figure ToolBar"));
   m_figureToolBar->setMovable (false);
   m_figureToolBar->setFloatable (false);
 
   MouseModeActionGroup* mouseModeGroup = new MouseModeActionGroup (win);
   connect (mouseModeGroup, SIGNAL (modeChanged (MouseMode)),
-	   SLOT (setMouseMode (MouseMode)));
+           SLOT (setMouseMode (MouseMode)));
   m_figureToolBar->addActions (mouseModeGroup->actions ());
 
   m_menuBar = new MenuBar (win);
   win->setMenuBar (m_menuBar);
 
   QMenu* fileMenu = m_menuBar->addMenu (tr ("&File"));
   fileMenu->menuAction ()->setObjectName ("builtinMenu");
   fileMenu->addAction (tr ("&New Figure"), this, SLOT (fileNewFigure (void)));
   fileMenu->addAction (tr ("&Open..."))->setEnabled (false);
   fileMenu->addSeparator ();
   fileMenu->addAction (tr ("&Save"))->setEnabled (false);
   fileMenu->addAction (tr ("Save &As"))->setEnabled (false);
   fileMenu->addSeparator ();
   fileMenu->addAction (tr ("&Close Figure"), this,
-		       SLOT (fileCloseFigure (void)), Qt::CTRL|Qt::Key_W);
+                       SLOT (fileCloseFigure (void)), Qt::CTRL|Qt::Key_W);
 
   QMenu* editMenu = m_menuBar->addMenu (tr ("&Edit"));
   editMenu->menuAction ()->setObjectName ("builtinMenu");
   editMenu->addAction (tr ("Cop&y"), this, SLOT (editCopy (void)),
-		       Qt::CTRL|Qt::Key_C)->setEnabled (false);
+                       Qt::CTRL|Qt::Key_C)->setEnabled (false);
   editMenu->addAction (tr ("Cu&t"), this, SLOT (editCut (void)),
-		       Qt::CTRL|Qt::Key_X)->setEnabled (false);
+                       Qt::CTRL|Qt::Key_X)->setEnabled (false);
   editMenu->addAction (tr ("&Paste"), this, SLOT (editPaste(void)),
-		       Qt::CTRL|Qt::Key_V)->setEnabled (false);
+                       Qt::CTRL|Qt::Key_V)->setEnabled (false);
   editMenu->addSeparator ();
   editMenu->addActions (mouseModeGroup->actions ());
 
   QMenu* helpMenu = m_menuBar->addMenu (tr ("&Help"));
   helpMenu->menuAction ()->setObjectName ("builtinMenu");
   helpMenu->addAction (tr ("&About QtHandles"), this,
-		       SLOT (helpAboutQtHandles (void)));
+                       SLOT (helpAboutQtHandles (void)));
   helpMenu->addAction (tr ("About &Qt"), qApp, SLOT (aboutQt (void)));
 
   m_menuBar->addReceiver (this);
 }
 
 Container* Figure::innerContainer (void)
 {
   return m_container;
@@ -221,22 +221,22 @@ void Figure::redraw (void)
 
   if (canvas)
     {
     canvas->redraw ();
     //canvas->setMouseMode (RotateMode);
     }
 
   foreach (QFrame* frame,
-	   qWidget<QWidget> ()->findChildren<QFrame*> ("UIPanel"))
+           qWidget<QWidget> ()->findChildren<QFrame*> ("UIPanel"))
     {
       Object* obj = Object::fromQObject (frame);
 
       if (obj)
-	obj->slotRedraw ();
+        obj->slotRedraw ();
     }
 }
 
 void Figure::beingDeleted (void)
 {
   Canvas* canvas = m_container->canvas (m_handle.value (), false);
 
   if (canvas)
@@ -255,48 +255,48 @@ void Figure::update (int pId)
   figure::properties& fp = properties<figure> ();
   QMainWindow* win = qWidget<QMainWindow> ();
 
   m_blockUpdates = true;
 
   switch (pId)
     {
     case figure::properties::ID_POSITION:
-	{
+        {
           m_innerRect = boundingBoxToRect (fp.get_boundingbox (true));
           //qDebug () << "Figure::update(position):" << m_innerRect;
-	  int offset = 0;
+          int offset = 0;
 
           foreach (QToolBar* tb, win->findChildren<QToolBar*> ())
             if (! tb->isHidden ())
               offset += tb->sizeHint ().height ();
-	  if (! m_menuBar->isHidden ())
-	    offset += m_menuBar->sizeHint ().height () + 1;
+          if (! m_menuBar->isHidden ())
+            offset += m_menuBar->sizeHint ().height () + 1;
           //qDebug () << "Figure::update(position)(adjusted):" << m_innerRect.adjusted (0, -offset, 0, 0);
-	  win->setGeometry (m_innerRect.adjusted (0, -offset, 0, 0));
+          win->setGeometry (m_innerRect.adjusted (0, -offset, 0, 0));
           //qDebug () << "Figure::update(position): done";
-	}
+        }
       break;
     case figure::properties::ID_NAME:
     case figure::properties::ID_NUMBERTITLE:
       win->setWindowTitle (Utils::fromStdString (fp.get_title ()));
       break;
     case figure::properties::ID_VISIBLE:
       if (fp.is_visible ())
-	QTimer::singleShot (0, win, SLOT (show ()));
+        QTimer::singleShot (0, win, SLOT (show ()));
       else
-	win->hide ();
+        win->hide ();
       break;
     case figure::properties::ID_TOOLBAR:
       if (fp.toolbar_is ("none"))
-	showFigureToolBar (false);
+        showFigureToolBar (false);
       else if (fp.toolbar_is ("figure"))
-	showFigureToolBar (true);
+        showFigureToolBar (true);
       else // "auto"
-	showFigureToolBar (! hasUiControlChildren (fp));
+        showFigureToolBar (! hasUiControlChildren (fp));
       break;
     case figure::properties::ID_MENUBAR:
       showMenuBar (fp.menubar_is ("figure"));
       break;
     case figure::properties::ID_KEYPRESSFCN:
       if (fp.get_keypressfcn ().is_empty ())
         m_container->canvas (m_handle)->clearEventMask (Canvas::KeyPress);
       else
@@ -327,34 +327,34 @@ void Figure::update (int pId)
 void Figure::showFigureToolBar (bool visible)
 {
   if ((! m_figureToolBar->isHidden ()) != visible)
     {
       int dy = m_figureToolBar->sizeHint ().height ();
       QRect r = qWidget<QWidget> ()->geometry ();
 
       if (! visible)
-	r.adjust (0, dy, 0, 0);
+        r.adjust (0, dy, 0, 0);
       else
-	r.adjust (0, -dy, 0, 0);
+        r.adjust (0, -dy, 0, 0);
 
       m_blockUpdates = true;
       qWidget<QWidget> ()->setGeometry (r);
       m_figureToolBar->setVisible (visible);
       m_blockUpdates = false;
 
       updateBoundingBox (false);
 
       if (visible)
-	m_mouseMode = m_lastMouseMode;
+        m_mouseMode = m_lastMouseMode;
       else
-	{
-	  m_lastMouseMode = m_mouseMode;
-	  m_mouseMode = NoMode;
-	}
+        {
+          m_lastMouseMode = m_mouseMode;
+          m_mouseMode = NoMode;
+        }
     }
 }
 
 void Figure::showMenuBar (bool visible)
 {
   int h1 = m_menuBar->sizeHint ().height ();
 
   foreach (QAction* a, m_menuBar->actions ())
@@ -368,19 +368,19 @@ void Figure::showMenuBar (bool visible)
 
   if ((! m_menuBar->isHidden ()) != visible)
     {
       int dy = qMax (h1, h2) + 1;
       QRect r = qWidget<QWidget> ()->geometry ();
 
       //qDebug () << "Figure::showMenuBar:" << r;
       if (! visible)
-	r.adjust (0, dy, 0, 0);
+        r.adjust (0, dy, 0, 0);
       else
-	r.adjust (0, -dy, 0, 0);
+        r.adjust (0, -dy, 0, 0);
       //qDebug () << "Figure::showMenuBar(adjusted):" << r;
 
       m_blockUpdates = true;
       qWidget<QWidget> ()->setGeometry (r);
       m_menuBar->setVisible (visible);
       m_blockUpdates = false;
 
       updateBoundingBox (false);
@@ -493,116 +493,116 @@ void Figure::updateBoundingBox (bool int
   gh_manager::post_function (Figure::updateBoundingBoxHelper, d);
 }
 
 bool Figure::eventNotifyBefore (QObject* obj, QEvent* event)
 {
   if (! m_blockUpdates)
     {
       if (obj == m_container)
-	{
+        {
           // Do nothing...
-	}
+        }
       else if (obj == m_menuBar)
-	{
-	  switch (event->type ())
-	    {
-	    case QEvent::ActionRemoved:
-		{
-		  QAction* a = dynamic_cast<QActionEvent*> (event)->action ();
+        {
+          switch (event->type ())
+            {
+            case QEvent::ActionRemoved:
+                {
+                  QAction* a = dynamic_cast<QActionEvent*> (event)->action ();
 
-		  if (! a->isSeparator ()
-		      && a->objectName () != "builtinMenu")
+                  if (! a->isSeparator ()
+                      && a->objectName () != "builtinMenu")
                     updateMenuBar ();
-		}
-	      break;
-	    default:
-	      break;
-	    }
-	}
+                }
+              break;
+            default:
+              break;
+            }
+        }
       else
-	{
-	  switch (event->type ())
-	    {
-	    case QEvent::Close:
-	      event->ignore ();
-	      gh_manager::post_callback (m_handle, "closerequestfcn");
-	      return true;
-	    default:
-	      break;
-	    }
-	}
+        {
+          switch (event->type ())
+            {
+            case QEvent::Close:
+              event->ignore ();
+              gh_manager::post_callback (m_handle, "closerequestfcn");
+              return true;
+            default:
+              break;
+            }
+        }
     }
 
   return false;
 }
 
 void Figure::eventNotifyAfter (QObject* watched, QEvent* event)
 {
   if (! m_blockUpdates)
     {
       if (watched == m_container)
         {
-	  switch (event->type ())
-	    {
-	    case QEvent::Resize:
-	      updateBoundingBox (true, UpdateBoundingBoxSize);
-	      break;
-	    case QEvent::ChildAdded:
-	      if (dynamic_cast<QChildEvent*> (event)->child
-		  ()->isWidgetType())
-		{
-		  gh_manager::auto_lock lock;
-		  const figure::properties& fp = properties<figure> ();
+          switch (event->type ())
+            {
+            case QEvent::Resize:
+              updateBoundingBox (true, UpdateBoundingBoxSize);
+              break;
+            case QEvent::ChildAdded:
+              if (dynamic_cast<QChildEvent*> (event)->child
+                  ()->isWidgetType())
+                {
+                  gh_manager::auto_lock lock;
+                  const figure::properties& fp = properties<figure> ();
 
-		  showFigureToolBar (! hasUiControlChildren (fp));
-		}
-	    default:
-	      break;
-	    }
+                  showFigureToolBar (! hasUiControlChildren (fp));
+                }
+            default:
+              break;
+            }
         }
       else if (watched == m_menuBar)
         {
-	  switch (event->type ())
-	    {
-	    case QEvent::ActionAdded:
-		{
-		  QAction* a = dynamic_cast<QActionEvent*> (event)->action ();
+          switch (event->type ())
+            {
+            case QEvent::ActionAdded:
+                {
+                  QAction* a = dynamic_cast<QActionEvent*> (event)->action ();
 
-		  if (! a->isSeparator ()
+                  if (! a->isSeparator ()
                       && a->objectName () != "builtinMenu")
                     updateMenuBar ();
-		}
-	      break;
-	    default:
-	      break;
-	    }
+                }
+              break;
+            default:
+              break;
+            }
         }
       else
         {
-	  switch (event->type ())
-	    {
-	    case QEvent::Move:
-	      updateBoundingBox (false, UpdateBoundingBoxPosition);
-	      updateBoundingBox (true, UpdateBoundingBoxPosition);
-	      break;
-	    case QEvent::Resize:
-	      updateBoundingBox (false, UpdateBoundingBoxSize);
-	      break;
-	    default:
-	      break;
-	    }
+          switch (event->type ())
+            {
+            case QEvent::Move:
+              updateBoundingBox (false, UpdateBoundingBoxPosition);
+              updateBoundingBox (true, UpdateBoundingBoxPosition);
+              break;
+            case QEvent::Resize:
+              updateBoundingBox (false, UpdateBoundingBoxSize);
+              break;
+            default:
+              break;
+            }
         }
     }
 }
 
 void Figure::helpAboutQtHandles (void)
 {
   QMessageBox::about (qWidget<QMainWindow> (), tr ("About QtHandles"),
-		      ABOUT_TEXT);
+                      ABOUT_TEXT);
 }
 
 void Figure::fileNewFigure (void)
 {
 }
 
 void Figure::fileCloseFigure (void)
 {
@@ -651,19 +651,19 @@ void Figure::showCustomToolBar (QToolBar
   QMainWindow* win = qWidget<QMainWindow> ();
 
   if ((! bar->isHidden ()) != visible)
     {
       QSize sz = bar->sizeHint ();
       QRect r = win->geometry ();
 
       if (visible)
-	r.adjust (0, -sz.height (), 0, 0);
+        r.adjust (0, -sz.height (), 0, 0);
       else
-	r.adjust (0, sz.height (), 0, 0);
+        r.adjust (0, sz.height (), 0, 0);
 
       m_blockUpdates = true;
       win->setGeometry (r);
       bar->setVisible (visible);
       m_blockUpdates = false;
 
       updateBoundingBox (false);
     }
diff --git a/libgui/graphics/Figure.h b/libgui/graphics/Figure.h
--- a/libgui/graphics/Figure.h
+++ b/libgui/graphics/Figure.h
@@ -32,21 +32,21 @@ along with Octave; see the file COPYING.
 class QMainWindow;
 class QToolBar;
 
 namespace QtHandles
 {
 
 enum MouseMode
 {
-  NoMode	= 0,
-  RotateMode	= 1,
-  ZoomMode	= 2,
-  PanMode	= 3,
-  SelectMode	= 4
+  NoMode        = 0,
+  RotateMode    = 1,
+  ZoomMode      = 2,
+  PanMode       = 3,
+  SelectMode    = 4
 };
 
 class Container;
 class FigureWindow;
 class MenuBar;
 class ToolBar;
 
 class Figure :
diff --git a/libgui/graphics/GLCanvas.h b/libgui/graphics/GLCanvas.h
--- a/libgui/graphics/GLCanvas.h
+++ b/libgui/graphics/GLCanvas.h
@@ -34,17 +34,17 @@ class GLCanvas : public QGLWidget, publi
 {
 public:
   GLCanvas (QWidget* parent, const graphics_handle& handle);
   ~GLCanvas (void);
 
   void draw (const graphics_handle& handle);
   void drawZoomBox (const QPoint& p1, const QPoint& p2);
   void resize (int /* x */, int /* y */,
-	       int /* width */, int /* height */) { }
+               int /* width */, int /* height */) { }
   graphics_object selectFromAxes (const graphics_object& ax,
                                   const QPoint& pt);
   QWidget* qWidget (void) { return this; }
 
 protected:
   void paintGL (void);
   void mouseMoveEvent (QMouseEvent* event);
   void mousePressEvent (QMouseEvent* event);
diff --git a/libgui/graphics/ListBoxControl.cc b/libgui/graphics/ListBoxControl.cc
--- a/libgui/graphics/ListBoxControl.cc
+++ b/libgui/graphics/ListBoxControl.cc
@@ -64,17 +64,17 @@ ListBoxControl* ListBoxControl::create (
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
-	return new ListBoxControl (go, new QListWidget (container));
+        return new ListBoxControl (go, new QListWidget (container));
     }
 
   return 0;
 }
 
 ListBoxControl::ListBoxControl (const graphics_object& go, QListWidget* list)
      : BaseControl (go, list), m_blockCallback (false)
 {
@@ -87,35 +87,35 @@ ListBoxControl::ListBoxControl (const gr
     list->setSelectionMode (QAbstractItemView::SingleSelection);
   Matrix value = up.get_value ().matrix_value ();
   if (value.numel () > 0)
     {
       octave_idx_type n = value.numel ();
       int lc = list->count ();
 
       for (octave_idx_type i = 0; i < n; i++)
-	{
-	  int idx = xround (value(i));
+        {
+          int idx = xround (value(i));
 
-	  if (1 <= idx && idx <= lc)
-	    {
-	      list->item (idx-1)->setSelected (true);
-	      if (i == 0
-		  && list->selectionMode () ==
-		  	QAbstractItemView::SingleSelection)
-		break;
-	    }
-	}
+          if (1 <= idx && idx <= lc)
+            {
+              list->item (idx-1)->setSelected (true);
+              if (i == 0
+                  && list->selectionMode () ==
+                        QAbstractItemView::SingleSelection)
+                break;
+            }
+        }
     }
 
   list->removeEventFilter (this);
   list->viewport ()->installEventFilter (this);
 
   connect (list, SIGNAL (itemSelectionChanged (void)),
-	   SLOT (itemSelectionChanged (void)));
+           SLOT (itemSelectionChanged (void)));
 }
 
 ListBoxControl::~ListBoxControl (void)
 {
 }
 
 void ListBoxControl::update (int pId)
 {
@@ -129,19 +129,19 @@ void ListBoxControl::update (int pId)
       list->clear ();
       list->addItems (Utils::fromStringVector (up.get_string_vector ()));
       updateSelection (list, up.get_value ().matrix_value ());
       m_blockCallback = false;
       break;
     case uicontrol::properties::ID_MIN:
     case uicontrol::properties::ID_MAX:
       if ((up.get_max () - up.get_min ()) > 1)
-	list->setSelectionMode (QAbstractItemView::ExtendedSelection);
+        list->setSelectionMode (QAbstractItemView::ExtendedSelection);
       else
-	list->setSelectionMode (QAbstractItemView::SingleSelection);
+        list->setSelectionMode (QAbstractItemView::SingleSelection);
       break;
     case uicontrol::properties::ID_VALUE:
       m_blockCallback = true;
       updateSelection (list, up.get_value ().matrix_value ());
       m_blockCallback = false;
       break;
     default:
       BaseControl::update (pId);
diff --git a/libgui/graphics/Menu.cc b/libgui/graphics/Menu.cc
--- a/libgui/graphics/Menu.cc
+++ b/libgui/graphics/Menu.cc
@@ -41,36 +41,36 @@ static QKeySequence accelSequence (const
   std::string s (up.get_accelerator ());
 
   if (! s.empty ())
     {
       char c = s[0];
       int keyMod = Qt::CTRL;
 
       if (c >= 'A' && c <= 'Z')
-	keyMod |= Qt::SHIFT;
+        keyMod |= Qt::SHIFT;
       if (c >= 'a' && c <= 'z')
-	c -= ('a' - 'A');
+        c -= ('a' - 'A');
       if (c >= 'A' && c <= 'Z')
-	return QKeySequence (keyMod | static_cast<int> (c));
+        return QKeySequence (keyMod | static_cast<int> (c));
     }
 
   return QKeySequence ();
 }
 
 Menu* Menu::create (const graphics_object& go)
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       QObject* qObj = parent->qObject ();
 
       if (qObj)
-	return new Menu (go, new QAction (qObj), parent);
+        return new Menu (go, new QAction (qObj), parent);
     }
 
   return 0;
 }
 
 Menu::Menu (const graphics_object& go, QAction* action, Object* parent)
     : Object (go, action), m_parent (0), m_separator (0)
 {
@@ -97,56 +97,56 @@ Menu::Menu (const graphics_object& go, Q
   if (menuContainer)
     m_parent = menuContainer->menu ();
 
   if (m_parent)
     {
       int pos = static_cast<int> (up.get_position ());
 
       if (pos <= 0)
-	{
-	  if (m_separator)
-	    m_parent->insertAction (0, m_separator);
-	  m_parent->insertAction (0, action);
+        {
+          if (m_separator)
+            m_parent->insertAction (0, m_separator);
+          m_parent->insertAction (0, action);
 
-	  int count = 0;
+          int count = 0;
 
-	  foreach (QAction* a, m_parent->actions ())
-	    if (! a->isSeparator () && a->objectName () != "builtinMenu")
-	      count++;
-	  up.get_property ("position").set
-	    (octave_value (static_cast<double> (count)), true, false);
-	}
+          foreach (QAction* a, m_parent->actions ())
+            if (! a->isSeparator () && a->objectName () != "builtinMenu")
+              count++;
+          up.get_property ("position").set
+            (octave_value (static_cast<double> (count)), true, false);
+        }
       else
-	{
+        {
 
-	  int count = 0;
-	  QAction* before = 0;
+          int count = 0;
+          QAction* before = 0;
 
-	  foreach (QAction* a, m_parent->actions ())
-	    if (! a->isSeparator () && a->objectName () != "builtinMenu")
-	      {
-		count++;
-		if (pos <= count)
-		  {
-		    before = a;
-		    break;
-		  }
-	      }
+          foreach (QAction* a, m_parent->actions ())
+            if (! a->isSeparator () && a->objectName () != "builtinMenu")
+              {
+                count++;
+                if (pos <= count)
+                  {
+                    before = a;
+                    break;
+                  }
+              }
 
-	  if (m_separator)
-	    m_parent->insertAction (before, m_separator);
-	  m_parent->insertAction (before, action);
+          if (m_separator)
+            m_parent->insertAction (before, m_separator);
+          m_parent->insertAction (before, action);
 
-	  if (before)
-	    updateSiblingPositions ();
-	  else
-	    up.get_property ("position").set
-	      (octave_value (static_cast<double> (count+1)), true, false);
-	}
+          if (before)
+            updateSiblingPositions ();
+          else
+            up.get_property ("position").set
+              (octave_value (static_cast<double> (count+1)), true, false);
+        }
     }
 
   connect (action, SIGNAL (triggered (bool)), SLOT (actionTriggered (void)));
 }
 
 Menu::~Menu (void)
 {
 }
@@ -158,86 +158,86 @@ void Menu::update (int pId)
 
   switch (pId)
     {
     case uimenu::properties::ID_LABEL:
       action->setText (Utils::fromStdString (up.get_label ()));
       break;
     case uimenu::properties::ID_CHECKED:
       if (up.is_checked ())
-	{
-	  action->setCheckable (true);
-	  action->setChecked (up.is_checked ());
-	}
+        {
+          action->setCheckable (true);
+          action->setChecked (up.is_checked ());
+        }
       else
-	{
-	  action->setChecked (false);
-	  action->setCheckable (false);
-	}
+        {
+          action->setChecked (false);
+          action->setCheckable (false);
+        }
       break;
     case uimenu::properties::ID_ENABLE:
       action->setEnabled (up.is_enable ());
       break;
     case uimenu::properties::ID_ACCELERATOR:
       if (! action->menu ())
-	action->setShortcut (accelSequence (up));
+        action->setShortcut (accelSequence (up));
       break;
     case uimenu::properties::ID_SEPARATOR:
       if (up.is_separator ())
-	{
-	  if (! m_separator)
-	    {
-	      m_separator = new QAction (action);
-	      m_separator->setSeparator (true);
-	      m_separator->setVisible (up.is_visible ());
-	      if (m_parent)
-		m_parent->insertAction (action, m_separator);
-	    }
-	}
+        {
+          if (! m_separator)
+            {
+              m_separator = new QAction (action);
+              m_separator->setSeparator (true);
+              m_separator->setVisible (up.is_visible ());
+              if (m_parent)
+                m_parent->insertAction (action, m_separator);
+            }
+        }
       else
-	{
-	  if (m_separator)
-	    delete m_separator;
-	  m_separator = 0;
-	}
+        {
+          if (m_separator)
+            delete m_separator;
+          m_separator = 0;
+        }
       break;
     case uimenu::properties::ID_VISIBLE:
       action->setVisible (up.is_visible ());
       if (m_separator)
-	m_separator->setVisible (up.is_visible ());
+        m_separator->setVisible (up.is_visible ());
       break;
     case uimenu::properties::ID_POSITION:
       if (m_separator)
-	m_parent->removeAction (m_separator);
+        m_parent->removeAction (m_separator);
       m_parent->removeAction (action);
-	{
-	  int pos = static_cast<int> (up.get_position ());
-	  QAction* before = 0;
+        {
+          int pos = static_cast<int> (up.get_position ());
+          QAction* before = 0;
 
-	  if (pos > 0)
-	    {
-	      int count = 0;
+          if (pos > 0)
+            {
+              int count = 0;
 
-	      foreach (QAction* a, m_parent->actions ())
-		if (! a->isSeparator () && a->objectName () != "builtinMenu")
-		  {
-		    count++;
-		    if (pos <= count)
-		      {
-			before = a;
-			break;
-		      }
-		  }
-	    }
+              foreach (QAction* a, m_parent->actions ())
+                if (! a->isSeparator () && a->objectName () != "builtinMenu")
+                  {
+                    count++;
+                    if (pos <= count)
+                      {
+                        before = a;
+                        break;
+                      }
+                  }
+            }
 
-	  if (m_separator)
-	    m_parent->insertAction (before, m_separator);
-	  m_parent->insertAction (before, action);
-	  updateSiblingPositions ();
-	}
+          if (m_separator)
+            m_parent->insertAction (before, m_separator);
+          m_parent->insertAction (before, action);
+          updateSiblingPositions ();
+        }
       break;
     default:
       Object::update (pId);
       break;
     }
 }
 
 QWidget* Menu::menu (void)
@@ -246,17 +246,17 @@ QWidget* Menu::menu (void)
   QMenu* _menu = action->menu ();
 
   if (! _menu)
     {
       _menu = new QMenu (action->parentWidget ());
       action->setMenu (_menu);
       action->setShortcut (QKeySequence ());
       connect (_menu, SIGNAL (aboutToShow (void)),
-	       this, SLOT (actionHovered (void)));
+               this, SLOT (actionHovered (void)));
     }
 
   return _menu;
 }
 
 void Menu::actionTriggered (void)
 {
   QAction* action = qWidget<QAction> ();
@@ -273,35 +273,35 @@ void Menu::actionHovered (void)
 
 void Menu::updateSiblingPositions (void)
 {
   if (m_parent)
     {
       double count = 1.0;
 
       foreach (QAction* a, m_parent->actions ())
-	{
-	  if (! a->isSeparator () && a->objectName () != "builtinMenu")
-	    {
-	      Object* aObj = Object::fromQObject (a);
+        {
+          if (! a->isSeparator () && a->objectName () != "builtinMenu")
+            {
+              Object* aObj = Object::fromQObject (a);
 
-	      if (aObj)
-		{
-		  graphics_object go = aObj->object ();
+              if (aObj)
+                {
+                  graphics_object go = aObj->object ();
 
-		  // Probably overkill as a uimenu child can only be another
-		  // uimenu object.
-		  if (go.isa ("uimenu"))
-		    {
-		      uimenu::properties& up = Utils::properties<uimenu> (go);
+                  // Probably overkill as a uimenu child can only be another
+                  // uimenu object.
+                  if (go.isa ("uimenu"))
+                    {
+                      uimenu::properties& up = Utils::properties<uimenu> (go);
 
-		      up.get_property ("position").set
-			(octave_value (count), true, false);
-		    }
-		}
+                      up.get_property ("position").set
+                        (octave_value (count), true, false);
+                    }
+                }
 
-	      count++;
-	    }
-	}
+              count++;
+            }
+        }
     }
 }
 
 }; // namespace QtHandles
diff --git a/libgui/graphics/MouseModeActionGroup.cc b/libgui/graphics/MouseModeActionGroup.cc
--- a/libgui/graphics/MouseModeActionGroup.cc
+++ b/libgui/graphics/MouseModeActionGroup.cc
@@ -32,23 +32,23 @@ along with Octave; see the file COPYING.
 
 namespace QtHandles
 {
 
 MouseModeActionGroup::MouseModeActionGroup (QObject* parent)
   : QObject (parent), m_current (0)
 {
   m_actions.append (new QAction (QIcon (":/images/rotate.png"),
-				 tr ("Rotate"), this));
+                                 tr ("Rotate"), this));
   m_actions.append (new QAction (QIcon (":/images/zoom.png"),
-				 tr ("Zoom"), this));
+                                 tr ("Zoom"), this));
   m_actions.append (new QAction (QIcon (":/images/pan.png"),
-				 tr ("Pan"), this));
+                                 tr ("Pan"), this));
   m_actions.append (new QAction (QIcon (":/images/select.png"),
-				 tr ("Select"), this));
+                                 tr ("Select"), this));
   m_actions[2]->setEnabled (false);
   m_actions[3]->setEnabled (false);
 
   foreach (QAction* a, m_actions)
     {
       a->setCheckable (true);
       connect (a, SIGNAL (toggled (bool)), this, SLOT (actionToggled (bool)));
     }
@@ -58,33 +58,33 @@ MouseModeActionGroup::~MouseModeActionGr
 {
 }
 
 void MouseModeActionGroup::actionToggled (bool checked)
 {
   if (! checked)
     {
       if (sender () == m_current)
-	{
-	  m_current = 0;
-	  emit modeChanged (NoMode);
-	}
+        {
+          m_current = 0;
+          emit modeChanged (NoMode);
+        }
     }
   else
     {
       int i = m_actions.indexOf (qobject_cast<QAction*> (sender ()));
 
       if (i >= 0)
-	{
-	  m_current = m_actions[i];
-	  for (int j = 0; j < m_actions.size (); j++)
-	    if (j != i)
-	      m_actions[j]->setChecked (false);
-	  emit modeChanged (static_cast<MouseMode> (i+1));
-	}
+        {
+          m_current = m_actions[i];
+          for (int j = 0; j < m_actions.size (); j++)
+            if (j != i)
+              m_actions[j]->setChecked (false);
+          emit modeChanged (static_cast<MouseMode> (i+1));
+        }
     }
 }
 
 MouseMode MouseModeActionGroup::mouseMode (void) const
 {
   int i = (m_current ? -1 : m_actions.indexOf (m_current));
 
   return static_cast<MouseMode> (i+1);
diff --git a/libgui/graphics/Object.cc b/libgui/graphics/Object.cc
--- a/libgui/graphics/Object.cc
+++ b/libgui/graphics/Object.cc
@@ -35,51 +35,51 @@ namespace QtHandles
 
 Object::Object (const graphics_object& go, QObject* obj)
   : QObject (), m_handle (go.get_handle ()), m_qobject (0)
 {
   gh_manager::auto_lock lock (false);
 
   if (! lock)
     qCritical ("QtHandles::Object::Object: "
-	       "creating Object (h=%g) without a valid lock!!!",
-	       m_handle.value ());
+               "creating Object (h=%g) without a valid lock!!!",
+               m_handle.value ());
 
   init (obj);
 }
 
 void Object::init (QObject* obj, bool)
 {
   if (m_qobject)
     qCritical ("QtHandles::Object::init: "
-	       "resetting QObject while in invalid state");
+               "resetting QObject while in invalid state");
 
   m_qobject = obj;
 
   if (m_qobject)
     {
       m_qobject->setProperty ("QtHandles::Object",
-			      qVariantFromValue<void*> (this));
+                              qVariantFromValue<void*> (this));
       connect (m_qobject, SIGNAL (destroyed (QObject*)),
-	       SLOT (objectDestroyed (QObject*)));
+               SLOT (objectDestroyed (QObject*)));
     }
 }
 
 Object::~Object (void)
 {
 }
 
 graphics_object Object::object (void) const
 {
   gh_manager::auto_lock lock (false);
 
   if (! lock)
     qCritical ("QtHandles::Object::object: "
-	       "accessing graphics object (h=%g) without a valid lock!!!",
-	       m_handle.value ());
+               "accessing graphics object (h=%g) without a valid lock!!!",
+               m_handle.value ());
 
   return gh_manager::get_object (m_handle);
 }
 
 void Object::slotUpdate (int pId)
 {
   gh_manager::auto_lock lock;
 
@@ -88,17 +88,17 @@ void Object::slotUpdate (int pId)
     // Special case for objects being deleted, as it's very likely
     // that the graphics_object already has been destroyed when this
     // is executed (because of the async behavior).
     case base_properties::ID_BEINGDELETED:
       beingDeleted ();
       break;
     default:
       if (object ().valid_object ())
-	update (pId);
+        update (pId);
       break;
     }
 }
 
 void Object::slotFinalize (void)
 {
   gh_manager::auto_lock lock;
 
diff --git a/libgui/graphics/Object.h b/libgui/graphics/Object.h
--- a/libgui/graphics/Object.h
+++ b/libgui/graphics/Object.h
@@ -50,24 +50,24 @@ public:
   
   const base_properties& properties (void) const
     { return object ().get_properties (); }
 
   template <class T>
   typename T::properties& properties (void)
     {
       return dynamic_cast<typename T::properties&>
-	(object ().get_properties ());
+        (object ().get_properties ());
     }
   
   template <class T>
   const typename T::properties& properties (void) const
     {
       return dynamic_cast<const typename T::properties&>
-	(object ().get_properties ());
+        (object ().get_properties ());
     }
 
   graphics_object object (void) const;
 
   virtual QObject* qObject (void) { return m_qobject; }
 
   template <class T>
   T* qWidget (void) { return qobject_cast<T*>(qObject ()); }
diff --git a/libgui/graphics/ObjectFactory.cc b/libgui/graphics/ObjectFactory.cc
--- a/libgui/graphics/ObjectFactory.cc
+++ b/libgui/graphics/ObjectFactory.cc
@@ -57,93 +57,93 @@ namespace QtHandles
 ObjectFactory* ObjectFactory::instance (void)
 {
   static ObjectFactory s_instance;
   static bool s_instanceCreated = false;
 
   if (! s_instanceCreated)
     {
       if (QThread::currentThread () != QApplication::instance ()->thread ())
-	s_instance.moveToThread (QApplication::instance ()->thread ());
+        s_instance.moveToThread (QApplication::instance ()->thread ());
       s_instanceCreated = true;
     }
 
   return &s_instance;
 }
 
 void ObjectFactory::createObject (double handle)
 {
   gh_manager::auto_lock lock;
 
   graphics_object go (gh_manager::get_object (graphics_handle (handle)));
 
   if (go.valid_object ())
     {
       if (go.get_properties ().is_beingdeleted ())
-	qWarning ("ObjectFactory::createObject: object is being deleted");
+        qWarning ("ObjectFactory::createObject: object is being deleted");
       else
-	{
-	  ObjectProxy* proxy = Backend::toolkitObjectProxy (go);
+        {
+          ObjectProxy* proxy = Backend::toolkitObjectProxy (go);
 
-	  if (proxy)
-	    {
-	      Logger::debug ("ObjectFactory::createObject: "
-			     "create %s from thread %08x",
-			     go.type ().c_str (), QThread::currentThreadId ());
+          if (proxy)
+            {
+              Logger::debug ("ObjectFactory::createObject: "
+                             "create %s from thread %08x",
+                             go.type ().c_str (), QThread::currentThreadId ());
 
-	      Object* obj = 0;
+              Object* obj = 0;
 
-	      if (go.isa ("figure"))
-		obj = Figure::create (go);
-	      else if (go.isa ("uicontrol"))
-		{
-		  uicontrol::properties& up =
-		   Utils::properties<uicontrol> (go);
+              if (go.isa ("figure"))
+                obj = Figure::create (go);
+              else if (go.isa ("uicontrol"))
+                {
+                  uicontrol::properties& up =
+                   Utils::properties<uicontrol> (go);
 
-		  if (up.style_is ("pushbutton"))
-		    obj = PushButtonControl::create (go);
-		  else if (up.style_is ("edit"))
-		    obj = EditControl::create (go);
-		  else if (up.style_is ("checkbox"))
-		    obj = CheckBoxControl::create (go);
-		  else if (up.style_is ("radiobutton"))
-		    obj = RadioButtonControl::create (go);
-		  else if (up.style_is ("togglebutton"))
-		    obj = ToggleButtonControl::create (go);
-		  else if (up.style_is ("text"))
-		    obj = TextControl::create (go);
-		  else if (up.style_is ("popupmenu"))
-		    obj = PopupMenuControl::create (go);
-		  else if (up.style_is ("slider"))
-		    obj = SliderControl::create (go);
-		  else if (up.style_is ("listbox"))
-		    obj = ListBoxControl::create (go);
-		}
-	      else if (go.isa ("uipanel"))
-		obj = Panel::create (go);
-	      else if (go.isa ("uimenu"))
-		obj = Menu::create (go);
-	      else if (go.isa ("uicontextmenu"))
-		obj = ContextMenu::create (go);
-	      else if (go.isa ("uitoolbar"))
-		obj = ToolBar::create (go);
-	      else if (go.isa ("uipushtool"))
-		obj = PushTool::create (go);
-	      else if (go.isa ("uitoggletool"))
-		obj = ToggleTool::create (go);
-	      else
-		qWarning ("ObjectFactory::createObject: unsupported type `%s'",
-			  go.type ().c_str ());
+                  if (up.style_is ("pushbutton"))
+                    obj = PushButtonControl::create (go);
+                  else if (up.style_is ("edit"))
+                    obj = EditControl::create (go);
+                  else if (up.style_is ("checkbox"))
+                    obj = CheckBoxControl::create (go);
+                  else if (up.style_is ("radiobutton"))
+                    obj = RadioButtonControl::create (go);
+                  else if (up.style_is ("togglebutton"))
+                    obj = ToggleButtonControl::create (go);
+                  else if (up.style_is ("text"))
+                    obj = TextControl::create (go);
+                  else if (up.style_is ("popupmenu"))
+                    obj = PopupMenuControl::create (go);
+                  else if (up.style_is ("slider"))
+                    obj = SliderControl::create (go);
+                  else if (up.style_is ("listbox"))
+                    obj = ListBoxControl::create (go);
+                }
+              else if (go.isa ("uipanel"))
+                obj = Panel::create (go);
+              else if (go.isa ("uimenu"))
+                obj = Menu::create (go);
+              else if (go.isa ("uicontextmenu"))
+                obj = ContextMenu::create (go);
+              else if (go.isa ("uitoolbar"))
+                obj = ToolBar::create (go);
+              else if (go.isa ("uipushtool"))
+                obj = PushTool::create (go);
+              else if (go.isa ("uitoggletool"))
+                obj = ToggleTool::create (go);
+              else
+                qWarning ("ObjectFactory::createObject: unsupported type `%s'",
+                          go.type ().c_str ());
 
-	      if (obj)
-		proxy->setObject (obj);
-	    }
-	  else
-	    qWarning ("ObjectFactory::createObject: no proxy for handle %g",
-		      handle);
-	}
+              if (obj)
+                proxy->setObject (obj);
+            }
+          else
+            qWarning ("ObjectFactory::createObject: no proxy for handle %g",
+                      handle);
+        }
     }
   else
     qWarning ("ObjectFactory::createObject: invalid object for handle %g",
-	      handle);
+              handle);
 }
 
 };
diff --git a/libgui/graphics/ObjectProxy.cc b/libgui/graphics/ObjectProxy.cc
--- a/libgui/graphics/ObjectProxy.cc
+++ b/libgui/graphics/ObjectProxy.cc
@@ -38,36 +38,36 @@ ObjectProxy::ObjectProxy (Object* obj)
   init (obj);
 }
 
 void ObjectProxy::init (Object* obj)
 {
   if (obj != m_object)
     {
       if (m_object)
-	{
-	  disconnect (this, SIGNAL (sendUpdate (int)),
-		      m_object, SLOT (slotUpdate (int)));
-	  disconnect (this, SIGNAL (sendFinalize (void)),
-		      m_object, SLOT (slotFinalize (void)));
-	  disconnect (this, SIGNAL (sendRedraw (void)),
-		      m_object, SLOT (slotRedraw (void)));
-	}
+        {
+          disconnect (this, SIGNAL (sendUpdate (int)),
+                      m_object, SLOT (slotUpdate (int)));
+          disconnect (this, SIGNAL (sendFinalize (void)),
+                      m_object, SLOT (slotFinalize (void)));
+          disconnect (this, SIGNAL (sendRedraw (void)),
+                      m_object, SLOT (slotRedraw (void)));
+        }
 
       m_object = obj;
 
       if (m_object)
-	{
-	  connect (this, SIGNAL (sendUpdate (int)),
-		   m_object, SLOT (slotUpdate (int)));
-	  connect (this, SIGNAL (sendFinalize (void)),
-		   m_object, SLOT (slotFinalize (void)));
-	  connect (this, SIGNAL (sendRedraw (void)),
-		   m_object, SLOT (slotRedraw (void)));
-	}
+        {
+          connect (this, SIGNAL (sendUpdate (int)),
+                   m_object, SLOT (slotUpdate (int)));
+          connect (this, SIGNAL (sendFinalize (void)),
+                   m_object, SLOT (slotFinalize (void)));
+          connect (this, SIGNAL (sendRedraw (void)),
+                   m_object, SLOT (slotRedraw (void)));
+        }
     }
 }
 
 void ObjectProxy::setObject (Object* obj)
 {
   emit sendFinalize ();
   init (obj);
 }
diff --git a/libgui/graphics/Panel.cc b/libgui/graphics/Panel.cc
--- a/libgui/graphics/Panel.cc
+++ b/libgui/graphics/Panel.cc
@@ -53,64 +53,64 @@ static int frameStyleFromProperties (con
     return (QFrame::Panel | QFrame::Raised);
   else
     return (QFrame::Panel | QFrame::Plain);
 }
 
 static void setupPalette (const uipanel::properties& pp, QPalette& p)
 {
   p.setColor (QPalette::Window,
-	      Utils::fromRgb (pp.get_backgroundcolor_rgb ()));
+              Utils::fromRgb (pp.get_backgroundcolor_rgb ()));
   p.setColor (QPalette::WindowText,
-	      Utils::fromRgb (pp.get_foregroundcolor_rgb ()));
+              Utils::fromRgb (pp.get_foregroundcolor_rgb ()));
   p.setColor (QPalette::Light,
-	      Utils::fromRgb (pp.get_highlightcolor_rgb ()));
+              Utils::fromRgb (pp.get_highlightcolor_rgb ()));
   p.setColor (QPalette::Dark,
-	      Utils::fromRgb (pp.get_shadowcolor_rgb ()));
+              Utils::fromRgb (pp.get_shadowcolor_rgb ()));
 }
 
 static int borderWidthFromProperties (const uipanel::properties& pp)
 {
   int bw = 0;
 
   if (! pp.bordertype_is ("none"))
     {
       bw = xround (pp.get_borderwidth ());
       if (pp.bordertype_is ("etchedin") || pp.bordertype_is ("etchedout"))
-	bw *= 2;
+        bw *= 2;
     }
 
   return bw;
 }
 
 Panel* Panel::create (const graphics_object& go)
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
-	return new Panel (go, new QFrame (container));
+        return new Panel (go, new QFrame (container));
     }
 
   return 0;
 }
 
 Panel::Panel (const graphics_object& go, QFrame* frame)
     : Object (go, frame), m_container (0), m_title (0), m_blockUpdates (false)
 {
   uipanel::properties& pp = properties<uipanel> ();
 
   frame->setObjectName ("UIPanel");
   frame->setAutoFillBackground (true);
   Matrix bb = pp.get_boundingbox (false);
   frame->setGeometry (xround (bb(0)), xround (bb(1)),
-		      xround (bb(2)), xround (bb(3)));
+                      xround (bb(2)), xround (bb(3)));
   frame->setFrameStyle (frameStyleFromProperties (pp));
   frame->setLineWidth (xround (pp.get_borderwidth ()));
   QPalette pal = frame->palette ();
   setupPalette (pp, pal);
   frame->setPalette (pal);
 
   m_container = new Container (frame);
   m_container->canvas (m_handle);
@@ -144,164 +144,164 @@ Panel::~Panel (void)
 {
 }
 
 bool Panel::eventFilter (QObject* watched, QEvent* event)
 {
   if (! m_blockUpdates)
     {
       if (watched == qObject ())
-	{
-	  switch (event->type ())
-	    {
-	    case QEvent::Resize:
-		{
-		  gh_manager::auto_lock lock;
-		  graphics_object go = object ();
+        {
+          switch (event->type ())
+            {
+            case QEvent::Resize:
+                {
+                  gh_manager::auto_lock lock;
+                  graphics_object go = object ();
 
-		  if (go.valid_object ())
-		    {
-		      if (m_title)
-			{
-			  const uipanel::properties& pp =
-			    Utils::properties<uipanel> (go);
+                  if (go.valid_object ())
+                    {
+                      if (m_title)
+                        {
+                          const uipanel::properties& pp =
+                            Utils::properties<uipanel> (go);
 
-			  if (pp.fontunits_is ("normalized"))
-			    {
-			      QFrame* frame = qWidget<QFrame> ();
+                          if (pp.fontunits_is ("normalized"))
+                            {
+                              QFrame* frame = qWidget<QFrame> ();
 
-			      m_title->setFont (Utils::computeFont<uipanel>
-						(pp, frame->height ()));
-			      m_title->resize (m_title->sizeHint ());
-			    }
-			}
-		      updateLayout ();
-		    }
-		}
-	      break;
-	    case QEvent::MouseButtonPress:
-		{
-		  QMouseEvent* m = dynamic_cast<QMouseEvent*> (event);
+                              m_title->setFont (Utils::computeFont<uipanel>
+                                                (pp, frame->height ()));
+                              m_title->resize (m_title->sizeHint ());
+                            }
+                        }
+                      updateLayout ();
+                    }
+                }
+              break;
+            case QEvent::MouseButtonPress:
+                {
+                  QMouseEvent* m = dynamic_cast<QMouseEvent*> (event);
 
-		  if (m->button () == Qt::RightButton)
-		    {
-		      gh_manager::auto_lock lock;
+                  if (m->button () == Qt::RightButton)
+                    {
+                      gh_manager::auto_lock lock;
 
-		      ContextMenu::executeAt (properties (), m->globalPos ());
-		    }
-		}
-	      break;
-	    default:
-	      break;
-	    }
-	}
+                      ContextMenu::executeAt (properties (), m->globalPos ());
+                    }
+                }
+              break;
+            default:
+              break;
+            }
+        }
       else if (watched == m_container)
-	{
-	  switch (event->type ())
-	    {
-	    case QEvent::Resize:
-	      if (qWidget<QWidget> ()->isVisible ())
-		{
-		  gh_manager::auto_lock lock;
+        {
+          switch (event->type ())
+            {
+            case QEvent::Resize:
+              if (qWidget<QWidget> ()->isVisible ())
+                {
+                  gh_manager::auto_lock lock;
 
-		  properties ().update_boundingbox ();
-		}
-	      break;
-	    default:
-	      break;
-	    }
-	}
+                  properties ().update_boundingbox ();
+                }
+              break;
+            default:
+              break;
+            }
+        }
     }
 
   return false;
 }
 
 void Panel::update (int pId)
 {
   uipanel::properties& pp = properties<uipanel> ();
   QFrame* frame = qWidget<QFrame> ();
 
   m_blockUpdates = true;
 
   switch (pId)
     {
     case uipanel::properties::ID_POSITION:
-	{
-	  Matrix bb = pp.get_boundingbox (false);
+        {
+          Matrix bb = pp.get_boundingbox (false);
 
-	  frame->setGeometry (xround (bb(0)), xround (bb(1)),
-			      xround (bb(2)), xround (bb(3)));
-	  updateLayout ();
-	}
+          frame->setGeometry (xround (bb(0)), xround (bb(1)),
+                              xround (bb(2)), xround (bb(3)));
+          updateLayout ();
+        }
       break;
     case uipanel::properties::ID_BORDERWIDTH:
       frame->setLineWidth (xround (pp.get_borderwidth ()));
       updateLayout ();
       break;
     case uipanel::properties::ID_BACKGROUNDCOLOR:
     case uipanel::properties::ID_FOREGROUNDCOLOR:
     case uipanel::properties::ID_HIGHLIGHTCOLOR:
     case uipanel::properties::ID_SHADOWCOLOR:
-	{
-	  QPalette pal = frame->palette ();
+        {
+          QPalette pal = frame->palette ();
 
-	  setupPalette (pp, pal);
-	  frame->setPalette (pal);
-	  if (m_title)
-	    m_title->setPalette (pal);
-	}
+          setupPalette (pp, pal);
+          frame->setPalette (pal);
+          if (m_title)
+            m_title->setPalette (pal);
+        }
       break;
     case uipanel::properties::ID_TITLE:
-	{
-	  QString title = Utils::fromStdString (pp.get_title ());
+        {
+          QString title = Utils::fromStdString (pp.get_title ());
 
-	  if (title.isEmpty ())
-	    {
-	      if (m_title)
-		delete m_title;
-	      m_title = 0;
-	    }
-	  else
-	    {
-	      if (! m_title)
-		{
-		  QPalette pal = frame->palette ();
+          if (title.isEmpty ())
+            {
+              if (m_title)
+                delete m_title;
+              m_title = 0;
+            }
+          else
+            {
+              if (! m_title)
+                {
+                  QPalette pal = frame->palette ();
 
-		  m_title = new QLabel (title, frame);
-		  m_title->setAutoFillBackground (true);
-		  m_title->setContentsMargins (4, 0, 4, 0);
-		  m_title->setPalette (pal);
-		  m_title->setFont (Utils::computeFont<uipanel> (pp));
-		  m_title->show ();
-		}
-	      else
-		{
-		  m_title->setText (title);
-		  m_title->resize (m_title->sizeHint ());
-		}
-	    }
-	  updateLayout ();
-	}
+                  m_title = new QLabel (title, frame);
+                  m_title->setAutoFillBackground (true);
+                  m_title->setContentsMargins (4, 0, 4, 0);
+                  m_title->setPalette (pal);
+                  m_title->setFont (Utils::computeFont<uipanel> (pp));
+                  m_title->show ();
+                }
+              else
+                {
+                  m_title->setText (title);
+                  m_title->resize (m_title->sizeHint ());
+                }
+            }
+          updateLayout ();
+        }
     case uipanel::properties::ID_TITLEPOSITION:
       updateLayout ();
       break;
     case uipanel::properties::ID_BORDERTYPE:
       frame->setFrameStyle (frameStyleFromProperties (pp));
       updateLayout ();
       break;
     case uipanel::properties::ID_FONTNAME:
     case uipanel::properties::ID_FONTSIZE:
     case uipanel::properties::ID_FONTWEIGHT:
     case uipanel::properties::ID_FONTANGLE:
       if (m_title)
-	{
-	  m_title->setFont (Utils::computeFont<uipanel> (pp));
-	  m_title->resize (m_title->sizeHint ());
-	  updateLayout ();
-	}
+        {
+          m_title->setFont (Utils::computeFont<uipanel> (pp));
+          m_title->resize (m_title->sizeHint ());
+          updateLayout ();
+        }
       break;
     case uipanel::properties::ID_VISIBLE:
       frame->setVisible (pp.is_visible ());
       updateLayout ();
       break;
     default:
       break;
     }
@@ -321,38 +321,38 @@ void Panel::updateLayout (void)
 {
   uipanel::properties& pp = properties<uipanel> ();
   QFrame* frame = qWidget<QFrame> ();
 
   Matrix bb = pp.get_boundingbox (true);
   int bw = borderWidthFromProperties (pp);
 
   frame->setFrameRect (QRect (xround (bb(0)) - bw, xround (bb(1)) - bw,
-			      xround (bb(2)) + 2*bw, xround (bb(3)) + 2*bw));
+                              xround (bb(2)) + 2*bw, xround (bb(3)) + 2*bw));
   m_container->setGeometry (xround (bb(0)), xround (bb(1)),
-			    xround (bb(2)), xround (bb(3)));
+                            xround (bb(2)), xround (bb(3)));
 
   if (m_blockUpdates)
     pp.update_boundingbox ();
 
   if (m_title)
     {
       QSize sz = m_title->sizeHint ();
       int offset = 5;
 
       if (pp.titleposition_is ("lefttop"))
-	m_title->move (bw+offset, 0);
+        m_title->move (bw+offset, 0);
       else if (pp.titleposition_is ("righttop"))
-	m_title->move (frame->width () - bw - offset - sz.width (), 0);
+        m_title->move (frame->width () - bw - offset - sz.width (), 0);
       else if (pp.titleposition_is ("leftbottom"))
-	m_title->move (bw+offset, frame->height () - sz.height ());
+        m_title->move (bw+offset, frame->height () - sz.height ());
       else if (pp.titleposition_is ("rightbottom"))
-	m_title->move (frame->width () - bw - offset - sz.width (),
-		       frame->height () - sz.height ());
+        m_title->move (frame->width () - bw - offset - sz.width (),
+                       frame->height () - sz.height ());
       else if (pp.titleposition_is ("centertop"))
-	m_title->move (frame->width () / 2 - sz.width () / 2, 0);
+        m_title->move (frame->width () / 2 - sz.width () / 2, 0);
       else if (pp.titleposition_is ("centerbottom"))
-	m_title->move (frame->width () / 2 - sz.width () / 2,
-		       frame->height () - sz.height ());
+        m_title->move (frame->width () / 2 - sz.width () / 2,
+                       frame->height () - sz.height ());
     }
 }
 
 };
diff --git a/libgui/graphics/PopupMenuControl.cc b/libgui/graphics/PopupMenuControl.cc
--- a/libgui/graphics/PopupMenuControl.cc
+++ b/libgui/graphics/PopupMenuControl.cc
@@ -37,94 +37,94 @@ PopupMenuControl* PopupMenuControl::crea
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
-	return new PopupMenuControl (go, new QComboBox (container));
+        return new PopupMenuControl (go, new QComboBox (container));
     }
 
   return 0;
 }
 
 PopupMenuControl::PopupMenuControl (const graphics_object& go, QComboBox *box)
      : BaseControl (go, box), m_blockUpdate (false)
 {
   uicontrol::properties& up = properties<uicontrol> ();
 
   box->addItems (Utils::fromStdString (up.get_string_string ()).split ('|'));
 
   connect (box, SIGNAL (currentIndexChanged (int)),
-	   SLOT (currentIndexChanged (int)));
+           SLOT (currentIndexChanged (int)));
 }
 
 PopupMenuControl::~PopupMenuControl (void)
 {
 }
 
 void PopupMenuControl::update (int pId)
 {
   uicontrol::properties& up = properties<uicontrol> ();
   QComboBox* box = qWidget<QComboBox> ();
 
   switch (pId)
     {
     case uicontrol::properties::ID_STRING:
       m_blockUpdate = true;
-	{
-	  int oldCurrent = box->currentIndex ();
+        {
+          int oldCurrent = box->currentIndex ();
 
-	  box->clear ();
-	  box->addItems (Utils::fromStdString
-			 (up.get_string_string ()).split ('|'));
-	  if (box->count() > 0
-	      && oldCurrent >= 0
-	      && oldCurrent < box->count ())
-	    {
-	      box->setCurrentIndex (oldCurrent);
-	    }
-	  else
-	    {
-	      gh_manager::post_set (m_handle, "value",
-				    octave_value (box->count () > 0
-						  ? 1.0 : 0.0),
-				    false);
-	    }
-	}
+          box->clear ();
+          box->addItems (Utils::fromStdString
+                         (up.get_string_string ()).split ('|'));
+          if (box->count() > 0
+              && oldCurrent >= 0
+              && oldCurrent < box->count ())
+            {
+              box->setCurrentIndex (oldCurrent);
+            }
+          else
+            {
+              gh_manager::post_set (m_handle, "value",
+                                    octave_value (box->count () > 0
+                                                  ? 1.0 : 0.0),
+                                    false);
+            }
+        }
       m_blockUpdate = false;
       break;
     case uicontrol::properties::ID_VALUE:
-	{
-	  Matrix value = up.get_value ().matrix_value ();
+        {
+          Matrix value = up.get_value ().matrix_value ();
 
-	  if (value.numel () > 0)
-	    {
-	      int newIndex = int (value(0)) - 1;
+          if (value.numel () > 0)
+            {
+              int newIndex = int (value(0)) - 1;
 
-	      if (newIndex >= 0 && newIndex < box->count ()
-		  && newIndex != box->currentIndex ())
-		{
-		  box->setCurrentIndex (newIndex);
-		}
-	    }
-	}
+              if (newIndex >= 0 && newIndex < box->count ()
+                  && newIndex != box->currentIndex ())
+                {
+                  box->setCurrentIndex (newIndex);
+                }
+            }
+        }
       break;
     default:
       BaseControl::update (pId);
       break;
     }
 }
 
 void PopupMenuControl::currentIndexChanged (int index)
 {
   if (! m_blockUpdate)
     {
       gh_manager::post_set (m_handle, "value",
-			    octave_value (double (index + 1)),
-			    false);
+                            octave_value (double (index + 1)),
+                            false);
       gh_manager::post_callback (m_handle, "callback");
     }
 }
 
 }; // namespace QtHandles
diff --git a/libgui/graphics/PushButtonControl.cc b/libgui/graphics/PushButtonControl.cc
--- a/libgui/graphics/PushButtonControl.cc
+++ b/libgui/graphics/PushButtonControl.cc
@@ -38,17 +38,17 @@ PushButtonControl* PushButtonControl::cr
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
-	return new PushButtonControl (go, new QPushButton (container));
+        return new PushButtonControl (go, new QPushButton (container));
     }
 
   return 0;
 }
 
 PushButtonControl::PushButtonControl (const graphics_object& go, QPushButton* btn)
   : ButtonControl (go, btn)
 {
diff --git a/libgui/graphics/PushTool.cc b/libgui/graphics/PushTool.cc
--- a/libgui/graphics/PushTool.cc
+++ b/libgui/graphics/PushTool.cc
@@ -35,17 +35,17 @@ PushTool* PushTool::create (const graphi
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       QWidget* parentWidget = parent->qWidget<QWidget> ();
 
       if (parentWidget)
-	return new PushTool (go, new QAction (parentWidget));
+        return new PushTool (go, new QAction (parentWidget));
     }
 
   return 0;
 }
 
 PushTool::PushTool (const graphics_object& go, QAction* action)
     : ToolBarButton<uipushtool> (go, action)
 {
diff --git a/libgui/graphics/QtHandlesUtils.cc b/libgui/graphics/QtHandlesUtils.cc
--- a/libgui/graphics/QtHandlesUtils.cc
+++ b/libgui/graphics/QtHandlesUtils.cc
@@ -103,19 +103,19 @@ QFont computeFont (const typename T::pro
   f.setPointSizeF (props.get_fontsize_points (height));
   f.setWeight (weightMap[props.get_fontweight ()]);
   f.setStyle (angleMap[props.get_fontangle ()]);
 
   return f;
 }
 
 template QFont computeFont<uicontrol> (const uicontrol::properties& props,
-				       int height);
+                                       int height);
 template QFont computeFont<uipanel> (const uipanel::properties& props,
-				     int height);
+                                     int height);
 
 QColor fromRgb (const Matrix& rgb)
 {
   QColor c;
 
   if (rgb.numel () == 3)
     c.setRgbF (rgb(0), rgb(1), rgb(2));
   
@@ -137,64 +137,64 @@ std::string figureSelectionType (QMouseE
   if (isDoubleClick)
     return std::string ("open");
   else
     {
       Qt::MouseButtons buttons = event->buttons ();
       Qt::KeyboardModifiers mods = event->modifiers ();
 
       if (mods == Qt::NoModifier)
-	{
-	  if (buttons == Qt::LeftButton)
-	    return std::string ("normal");
-	  else if (buttons == Qt::RightButton)
-	    return std::string ("alt");
+        {
+          if (buttons == Qt::LeftButton)
+            return std::string ("normal");
+          else if (buttons == Qt::RightButton)
+            return std::string ("alt");
 #if defined (Q_WS_WIN)
-	  else if (buttons == (Qt::LeftButton|Qt::RightButton))
-	    return std::string ("extend");
+          else if (buttons == (Qt::LeftButton|Qt::RightButton))
+            return std::string ("extend");
 #elif defined (Q_WS_X11)
-	  else if (buttons == Qt::MidButton)
-	    return std::string ("extend");
+          else if (buttons == Qt::MidButton)
+            return std::string ("extend");
 #endif
-	}
+        }
       else if (buttons == Qt::LeftButton)
-	{
-	  if (mods == Qt::ShiftModifier)
-	    return std::string ("extend");
-	  else if (mods == Qt::ControlModifier)
-	    return std::string ("alt");
-	}
+        {
+          if (mods == Qt::ShiftModifier)
+            return std::string ("extend");
+          else if (mods == Qt::ControlModifier)
+            return std::string ("alt");
+        }
     }
 
   return std::string ("normal");
 }
 
 Matrix figureCurrentPoint (const graphics_object& fig, QMouseEvent* event)
 {
   Object* tkFig = Backend::toolkitObject (fig);
 
   if (tkFig)
     {
       Container* c = tkFig->innerContainer ();
 
       if (c)
-	{
-	  QPoint qp = c->mapFromGlobal (event->globalPos ());
+        {
+          QPoint qp = c->mapFromGlobal (event->globalPos ());
 
-	  return
-	    tkFig->properties<figure> ().map_from_boundingbox (qp.x (),
-							       qp.y ());
-	}
+          return
+            tkFig->properties<figure> ().map_from_boundingbox (qp.x (),
+                                                               qp.y ());
+        }
     }
 
   return Matrix (1, 2, 0.0);
 }
 
 Qt::Alignment fromHVAlign (const caseless_str& halign,
-			   const caseless_str& valign)
+                           const caseless_str& valign)
 {
   Qt::Alignment flags;
 
   if (halign.compare ("left"))
     flags |= Qt::AlignLeft;
   else if (halign.compare ("center"))
     flags |= Qt::AlignHCenter;
   else if (halign.compare ("right"))
@@ -225,68 +225,68 @@ QImage makeImageFromCData (const octave_
 
       int x_off = (w < width ? (width - w) / 2 : 0);
       int y_off = (h < height ? (height - h) / 2 : 0);
 
       QImage img (width, height, QImage::Format_ARGB32);
       img.fill (qRgba (0, 0, 0, 0));
 
       if (v.is_uint8_type ())
-	{
-	  uint8NDArray d = v.uint8_array_value ();
+        {
+          uint8NDArray d = v.uint8_array_value ();
 
-	  for (int i = 0; i < w; i++)
-	    for (int j = 0; j < h; j++)
-	      {
-		int r = d(j, i, 0);
-		int g = d(j, i, 1);
-		int b = d(j, i, 2);
-		int a = 255;
+          for (int i = 0; i < w; i++)
+            for (int j = 0; j < h; j++)
+              {
+                int r = d(j, i, 0);
+                int g = d(j, i, 1);
+                int b = d(j, i, 2);
+                int a = 255;
 
-		img.setPixel (x_off + i, y_off + j, qRgba (r, g, b, a));
-	      }
-	}
+                img.setPixel (x_off + i, y_off + j, qRgba (r, g, b, a));
+              }
+        }
       else if (v.is_single_type ())
-	{
-	  FloatNDArray f = v.float_array_value ();
+        {
+          FloatNDArray f = v.float_array_value ();
 
-	  for (int i = 0; i < w; i++)
-	    for (int j = 0; j < h; j++)
-	      {
-		float r = f(j, i, 0);
-		float g = f(j, i, 1);
-		float b = f(j, i, 2);
-		int a = (xisnan (r) || xisnan (g) || xisnan (b) ? 0 : 255);
+          for (int i = 0; i < w; i++)
+            for (int j = 0; j < h; j++)
+              {
+                float r = f(j, i, 0);
+                float g = f(j, i, 1);
+                float b = f(j, i, 2);
+                int a = (xisnan (r) || xisnan (g) || xisnan (b) ? 0 : 255);
 
-		img.setPixel (x_off + i, y_off + j,
-			      qRgba (xround (r * 255),
-				     xround (g * 255),
-				     xround (b * 255),
-				     a));
-	      }
-	}
+                img.setPixel (x_off + i, y_off + j,
+                              qRgba (xround (r * 255),
+                                     xround (g * 255),
+                                     xround (b * 255),
+                                     a));
+              }
+        }
       else if (v.is_real_type ())
-	{
-	  NDArray d = v.array_value ();
+        {
+          NDArray d = v.array_value ();
 
-	  for (int i = 0; i < w; i++)
-	    for (int j = 0; j < h; j++)
-	      {
-		double r = d(j, i, 0);
-		double g = d(j, i, 1);
-		double b = d(j, i, 2);
-		int a = (xisnan (r) || xisnan (g) || xisnan (b) ? 0 : 255);
+          for (int i = 0; i < w; i++)
+            for (int j = 0; j < h; j++)
+              {
+                double r = d(j, i, 0);
+                double g = d(j, i, 1);
+                double b = d(j, i, 2);
+                int a = (xisnan (r) || xisnan (g) || xisnan (b) ? 0 : 255);
 
-		img.setPixel (x_off + i, y_off + j,
-			      qRgba (xround (r * 255),
-				     xround (g * 255),
-				     xround (b * 255),
-				     a));
-	      }
-	}
+                img.setPixel (x_off + i, y_off + j,
+                              qRgba (xround (r * 255),
+                                     xround (g * 255),
+                                     xround (b * 255),
+                                     a));
+              }
+        }
 
       return img;
     }
 
   return QImage ();
 }
 
 octave_scalar_map makeKeyEventStruct (QKeyEvent* event)
diff --git a/libgui/graphics/QtHandlesUtils.h b/libgui/graphics/QtHandlesUtils.h
--- a/libgui/graphics/QtHandlesUtils.h
+++ b/libgui/graphics/QtHandlesUtils.h
@@ -49,34 +49,34 @@ namespace Utils
 
   template <class T>
   QFont computeFont (const typename T::properties& props, int height = -1);
 
   QColor fromRgb (const Matrix& rgb);
   Matrix toRgb (const QColor& c);
 
   Qt::Alignment fromHVAlign (const caseless_str& halign,
-			     const caseless_str& valign);
+                             const caseless_str& valign);
 
   std::string figureSelectionType (QMouseEvent* event,
-				   bool isDoubleClick = false);
+                                   bool isDoubleClick = false);
 
   Matrix figureCurrentPoint (const graphics_object& fig, QMouseEvent* event);
 
   template <class T>
   inline typename T::properties&
   properties (graphics_object obj)
     { return dynamic_cast<typename T::properties&> (obj.get_properties ()); }
 
   template <class T>
   inline typename T::properties&
   properties (const graphics_handle& h)
     { return Utils::properties<T> (gh_manager::get_object (h)); }
 
   QImage makeImageFromCData (const octave_value& v, int width = -1,
-			     int height = -1);
+                             int height = -1);
 
   octave_scalar_map makeKeyEventStruct (QKeyEvent* event);
 };
 
 }; // namespace QtHandles
 
 #endif
diff --git a/libgui/graphics/RadioButtonControl.cc b/libgui/graphics/RadioButtonControl.cc
--- a/libgui/graphics/RadioButtonControl.cc
+++ b/libgui/graphics/RadioButtonControl.cc
@@ -37,24 +37,24 @@ RadioButtonControl* RadioButtonControl::
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
-	return new RadioButtonControl (go, new QRadioButton (container));
+        return new RadioButtonControl (go, new QRadioButton (container));
     }
 
   return 0;
 }
 
 RadioButtonControl::RadioButtonControl (const graphics_object& go,
-					QRadioButton* radio)
+                                        QRadioButton* radio)
     : ButtonControl (go, radio)
 {
   radio->setAutoFillBackground (true);
   radio->setAutoExclusive (false);
 }
 
 RadioButtonControl::~RadioButtonControl (void)
 {
diff --git a/libgui/graphics/SliderControl.cc b/libgui/graphics/SliderControl.cc
--- a/libgui/graphics/SliderControl.cc
+++ b/libgui/graphics/SliderControl.cc
@@ -39,24 +39,24 @@ SliderControl* SliderControl::create (co
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
-	return new SliderControl (go, new QScrollBar (container));
+        return new SliderControl (go, new QScrollBar (container));
     }
 
   return 0;
 }
 
 SliderControl::SliderControl (const graphics_object& go,
-			      QAbstractSlider* slider)
+                              QAbstractSlider* slider)
     : BaseControl (go, slider), m_blockUpdates (false)
 {
   uicontrol::properties& up = properties<uicontrol> ();
 
   slider->setTracking (false);
   Matrix bb = up.get_boundingbox ();
   slider->setOrientation (bb(2) > bb(3) ? Qt::Horizontal : Qt::Vertical);
   Matrix steps = up.get_sliderstep ().matrix_value ();
@@ -65,17 +65,17 @@ SliderControl::SliderControl (const grap
   slider->setSingleStep (xround (steps(0) * RANGE_INT_MAX));
   slider->setPageStep (xround (steps(1) * RANGE_INT_MAX));
   Matrix value = up.get_value ().matrix_value ();
   if (value.numel () > 0)
     {
       double dmin = up.get_min (), dmax = up.get_max ();
 
       slider->setValue (xround (((value(0) - dmin) / (dmax - dmin))
-				* RANGE_INT_MAX));
+                                * RANGE_INT_MAX));
     }
 
   connect (slider, SIGNAL (valueChanged (int)), SLOT (valueChanged (int)));
 }
 
 SliderControl::~SliderControl (void)
 {
 }
@@ -83,68 +83,68 @@ SliderControl::~SliderControl (void)
 void SliderControl::update (int pId)
 {
   uicontrol::properties& up = properties<uicontrol> ();
   QScrollBar* slider = qWidget<QScrollBar> ();
 
   switch (pId)
     {
     case uicontrol::properties::ID_SLIDERSTEP:
-	{
-	  Matrix steps = up.get_sliderstep ().matrix_value ();
+        {
+          Matrix steps = up.get_sliderstep ().matrix_value ();
 
-	  slider->setSingleStep (xround (steps(0) * RANGE_INT_MAX));
-	  slider->setPageStep (xround (steps(1) * RANGE_INT_MAX));
-	}
+          slider->setSingleStep (xround (steps(0) * RANGE_INT_MAX));
+          slider->setPageStep (xround (steps(1) * RANGE_INT_MAX));
+        }
       break;
     case uicontrol::properties::ID_VALUE:
-	{
-	  Matrix value = up.get_value ().matrix_value ();
-	  double dmax = up.get_max (), dmin = up.get_min ();
+        {
+          Matrix value = up.get_value ().matrix_value ();
+          double dmax = up.get_max (), dmin = up.get_min ();
 
-	  if (value.numel () > 0)
-	    {
-	      int ival = xround (((value(0) - dmin) / (dmax - dmin))
-				 * RANGE_INT_MAX);
+          if (value.numel () > 0)
+            {
+              int ival = xround (((value(0) - dmin) / (dmax - dmin))
+                                 * RANGE_INT_MAX);
 
-	      m_blockUpdates = true;
-	      slider->setValue (ival);
-	      m_blockUpdates = false;
-	    }
-	}
+              m_blockUpdates = true;
+              slider->setValue (ival);
+              m_blockUpdates = false;
+            }
+        }
       break;
     default:
       BaseControl::update (pId);
       break;
     }
 }
 
 void SliderControl::valueChanged (int ival)
 {
   if (! m_blockUpdates)
     {
       gh_manager::auto_lock lock;
       graphics_object go = object ();
 
       if (go.valid_object ())
-	{
-	  uicontrol::properties& up = Utils::properties<uicontrol> (go);
+        {
+          uicontrol::properties& up = Utils::properties<uicontrol> (go);
 
-	  Matrix value = up.get_value ().matrix_value ();
-	  double dmin = up.get_min (), dmax = up.get_max ();
+          Matrix value = up.get_value ().matrix_value ();
+          double dmin = up.get_min (), dmax = up.get_max ();
 
-	  int ival_tmp = (value.numel () > 0 ?
-			  xround (((value(0) - dmin) / (dmax - dmin))
-				  * RANGE_INT_MAX) :
-			  0);
+          int ival_tmp = (value.numel () > 0 ?
+                          xround (((value(0) - dmin) / (dmax - dmin))
+                                  * RANGE_INT_MAX) :
+                          0);
 
-	  if (ival != ival_tmp || value.numel () > 0)
-	    {
-	      double dval = dmin + (ival * (dmax - dmin) / RANGE_INT_MAX);
+          if (ival != ival_tmp || value.numel () > 0)
+            {
+              double dval = dmin + (ival * (dmax - dmin) / RANGE_INT_MAX);
 
-	      gh_manager::post_set (m_handle, "value", octave_value (dval));
-	      gh_manager::post_callback (m_handle, "callback");
-	    }
-	}
+              gh_manager::post_set (m_handle, "value", octave_value (dval));
+              gh_manager::post_callback (m_handle, "callback");
+            }
+        }
     }
 }
 
 }; // namespace QtHandles
diff --git a/libgui/graphics/TextControl.cc b/libgui/graphics/TextControl.cc
--- a/libgui/graphics/TextControl.cc
+++ b/libgui/graphics/TextControl.cc
@@ -37,32 +37,32 @@ TextControl* TextControl::create (const 
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
-	return new TextControl (go, new QLabel (container));
+        return new TextControl (go, new QLabel (container));
     }
 
   return 0;
 }
 
 TextControl::TextControl (const graphics_object& go, QLabel* label)
      : BaseControl (go, label)
 {
   uicontrol::properties& up = properties<uicontrol> ();
 
   label->setAutoFillBackground (true);
   label->setTextFormat (Qt::PlainText);
   label->setWordWrap (false);
   label->setAlignment (Utils::fromHVAlign (up.get_horizontalalignment (),
-					   up.get_verticalalignment ()));
+                                           up.get_verticalalignment ()));
   // FIXME: support string_vector
   label->setText (Utils::fromStdString (up.get_string_string ()));
 }
 
 TextControl::~TextControl (void)
 {
 }
 
@@ -75,17 +75,17 @@ void TextControl::update (int pId)
     {
     case uicontrol::properties::ID_STRING:
       // FIXME: support string_vector
       label->setText (Utils::fromStdString (up.get_string_string ()));
       break;
     case uicontrol::properties::ID_HORIZONTALALIGNMENT:
     case uicontrol::properties::ID_VERTICALALIGNMENT:
       label->setAlignment (Utils::fromHVAlign (up.get_horizontalalignment (),
-					       up.get_verticalalignment ()));
+                                               up.get_verticalalignment ()));
       break;
     default:
       BaseControl::update (pId);
       break;
     }
 }
 
 }; // namespace QtHandles
diff --git a/libgui/graphics/ToggleButtonControl.cc b/libgui/graphics/ToggleButtonControl.cc
--- a/libgui/graphics/ToggleButtonControl.cc
+++ b/libgui/graphics/ToggleButtonControl.cc
@@ -37,24 +37,24 @@ ToggleButtonControl* ToggleButtonControl
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
-	return new ToggleButtonControl (go, new QPushButton (container));
+        return new ToggleButtonControl (go, new QPushButton (container));
     }
 
   return 0;
 }
 
 ToggleButtonControl::ToggleButtonControl (const graphics_object& go,
-					  QPushButton* btn)
+                                          QPushButton* btn)
     : ButtonControl (go, btn)
 {
   btn->setCheckable (true);
   btn->setAutoFillBackground (true);
 }
 
 ToggleButtonControl::~ToggleButtonControl (void)
 {
diff --git a/libgui/graphics/ToggleTool.cc b/libgui/graphics/ToggleTool.cc
--- a/libgui/graphics/ToggleTool.cc
+++ b/libgui/graphics/ToggleTool.cc
@@ -35,32 +35,32 @@ ToggleTool* ToggleTool::create (const gr
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       QWidget* parentWidget = parent->qWidget<QWidget> ();
 
       if (parentWidget)
-	return new ToggleTool (go, new QAction (parentWidget));
+        return new ToggleTool (go, new QAction (parentWidget));
     }
 
   return 0;
 }
 
 ToggleTool::ToggleTool (const graphics_object& go, QAction* action)
     : ToolBarButton<uitoggletool> (go, action)
 {
   uitoggletool::properties& tp = properties<uitoggletool> ();
 
   action->setCheckable (true);
   action->setChecked (tp.is_state ());
 
   connect (action, SIGNAL (toggled (bool)),
-	   this, SLOT (triggered (bool)));
+           this, SLOT (triggered (bool)));
 }
 
 ToggleTool::~ToggleTool (void)
 {
 }
 
 void ToggleTool::update (int pId)
 {
@@ -77,15 +77,15 @@ void ToggleTool::update (int pId)
       break;
     }
 }
 
 void ToggleTool::triggered (bool checked)
 {
   gh_manager::post_set (m_handle, "state", checked, false);
   gh_manager::post_callback (m_handle,
-			     checked
-			     ? "oncallback"
-			     : "offcallback");
+                             checked
+                             ? "oncallback"
+                             : "offcallback");
   gh_manager::post_callback (m_handle, "clickedcallback");
 }
 
 };
diff --git a/libgui/graphics/ToolBar.cc b/libgui/graphics/ToolBar.cc
--- a/libgui/graphics/ToolBar.cc
+++ b/libgui/graphics/ToolBar.cc
@@ -66,17 +66,17 @@ ToolBar* ToolBar::create (const graphics
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       QWidget* parentWidget = parent->qWidget<QWidget> ();
 
       if (parentWidget)
-	return new ToolBar (go, new QToolBar (parentWidget));
+        return new ToolBar (go, new QToolBar (parentWidget));
     }
 
   return 0;
 }
 
 ToolBar::ToolBar (const graphics_object& go, QToolBar* bar)
      : Object (go, bar), m_empty (0), m_figure (0)
 {
@@ -105,54 +105,54 @@ void ToolBar::update (int pId)
 {
   uitoolbar::properties& tp = properties<uitoolbar> ();
   QToolBar* bar = qWidget<QToolBar> ();
 
   switch (pId)
     {
     case base_properties::ID_VISIBLE:
       if (m_figure)
-	m_figure->showCustomToolBar (bar, tp.is_visible ());
+        m_figure->showCustomToolBar (bar, tp.is_visible ());
       break;
     default:
       Object::update (pId);
       break;
     }
 }
 
 bool ToolBar::eventFilter (QObject* watched, QEvent* event)
 {
   if (watched == qObject ())
     {
       switch (event->type ())
-	{
-	case QEvent::ActionAdded:
-	case QEvent::ActionRemoved:
-	    {
-	      QActionEvent* ae = dynamic_cast<QActionEvent*> (event);
-	      QToolBar* bar = qWidget<QToolBar> ();
+        {
+        case QEvent::ActionAdded:
+        case QEvent::ActionRemoved:
+            {
+              QActionEvent* ae = dynamic_cast<QActionEvent*> (event);
+              QToolBar* bar = qWidget<QToolBar> ();
 
-	      if (ae->action () != m_empty)
-		{
-		  if (event->type () == QEvent::ActionAdded)
-		    {
-		      if (bar->actions ().size () == 2)
-			QTimer::singleShot (0, this, SLOT (hideEmpty (void)));
-		    }
-		  else
-		    {
-		      if (bar->actions ().size () == 1)
-			m_empty->setVisible (true);
-		    }
-		}
-	    }
-	  break;
-	default:
-	  break;
-	}
+              if (ae->action () != m_empty)
+                {
+                  if (event->type () == QEvent::ActionAdded)
+                    {
+                      if (bar->actions ().size () == 2)
+                        QTimer::singleShot (0, this, SLOT (hideEmpty (void)));
+                    }
+                  else
+                    {
+                      if (bar->actions ().size () == 1)
+                        m_empty->setVisible (true);
+                    }
+                }
+            }
+          break;
+        default:
+          break;
+        }
     }
 
   return false;
 }
 
 void ToolBar::hideEmpty (void)
 {
   m_empty->setVisible (false);
@@ -160,13 +160,13 @@ void ToolBar::hideEmpty (void)
 
 void ToolBar::beingDeleted (void)
 {
   if (m_figure)
     {
       QToolBar* bar = qWidget<QToolBar> ();
 
       if (bar)
-	m_figure->showCustomToolBar (bar, false);
+        m_figure->showCustomToolBar (bar, false);
     }
 }
 
 }; // namespace QtHandles
diff --git a/libgui/graphics/ToolBarButton.cc b/libgui/graphics/ToolBarButton.cc
--- a/libgui/graphics/ToolBarButton.cc
+++ b/libgui/graphics/ToolBarButton.cc
@@ -69,48 +69,48 @@ void ToolBarButton<T>::update (int pId)
   typename T::properties& tp = properties<T> ();
   QAction* action = qWidget<QAction> ();
 
   switch (pId)
     {
     case base_properties::ID_VISIBLE:
       action->setVisible (tp.is_visible ());
       if (m_separator)
-	m_separator->setVisible (tp.is_visible ());
+        m_separator->setVisible (tp.is_visible ());
       break;
     case T::properties::ID_TOOLTIPSTRING:
       action->setToolTip (Utils::fromStdString (tp.get_tooltipstring ()));
       break;
     case T::properties::ID_CDATA:
-	{
-	  QImage img = Utils::makeImageFromCData (tp.get_cdata (), 16, 16);
+        {
+          QImage img = Utils::makeImageFromCData (tp.get_cdata (), 16, 16);
 
-	  action->setIcon (QIcon (QPixmap::fromImage (img)));
-	}
+          action->setIcon (QIcon (QPixmap::fromImage (img)));
+        }
       break;
     case T::properties::ID_SEPARATOR:
       if (tp.is_separator ())
-	{
-	  if (! m_separator)
-	    {
-	      m_separator = new QAction (action);
-	      m_separator->setSeparator (true);
-	      m_separator->setVisible (tp.is_visible ());
+        {
+          if (! m_separator)
+            {
+              m_separator = new QAction (action);
+              m_separator->setSeparator (true);
+              m_separator->setVisible (tp.is_visible ());
 
-	      QWidget* w = qobject_cast<QWidget*> (action->parent ());
+              QWidget* w = qobject_cast<QWidget*> (action->parent ());
 
-	      w->insertAction (action, m_separator);
-	    }
-	}
+              w->insertAction (action, m_separator);
+            }
+        }
       else
-	{
-	  if (m_separator)
-	    delete m_separator;
-	  m_separator = 0;
-	}
+        {
+          if (m_separator)
+            delete m_separator;
+          m_separator = 0;
+        }
       break;
     case T::properties::ID_ENABLE:
       action->setEnabled (tp.is_enable ());
       break;
     default:
       Object::update (pId);
       break;
     }
diff --git a/libgui/graphics/__init_qt__.cc b/libgui/graphics/__init_qt__.cc
--- a/libgui/graphics/__init_qt__.cc
+++ b/libgui/graphics/__init_qt__.cc
@@ -43,55 +43,55 @@ namespace QtHandles
 
 static bool qtHandlesInitialized = false;
 
 bool __init__ (void)
 {
   if (! qtHandlesInitialized)
     {
       if (qApp)
-	{
-	  qRegisterMetaType<graphics_object> ("graphics_object");
+        {
+          qRegisterMetaType<graphics_object> ("graphics_object");
 
-	  gh_manager::enable_event_processing (true);
+          gh_manager::enable_event_processing (true);
 
-	  graphics_toolkit tk (new Backend ());
+          graphics_toolkit tk (new Backend ());
           gtk_manager::load_toolkit (tk);
 
-	  octave_add_atexit_function ("__shutdown_qt__");
+          octave_add_atexit_function ("__shutdown_qt__");
 
-	  // Change some default settings to use Qt default colors
-	  QPalette p;
-	  graphics_object root = gh_manager::get_object (0);
+          // Change some default settings to use Qt default colors
+          QPalette p;
+          graphics_object root = gh_manager::get_object (0);
 
-	  /*
-	  root.set ("defaultfigurecolor",
-		    octave_value (Utils::toRgb (p.color (QPalette::Window))));
-	  */
-	  root.set ("defaultuicontrolbackgroundcolor",
-		    octave_value (Utils::toRgb (p.color (QPalette::Window))));
-	  root.set ("defaultuicontrolforegroundcolor",
-		    octave_value (Utils::toRgb
-				  (p.color (QPalette::WindowText))));
-	  root.set ("defaultuipanelbackgroundcolor",
-		    octave_value (Utils::toRgb (p.color (QPalette::Window))));
-	  root.set ("defaultuipanelforegroundcolor",
-		    octave_value (Utils::toRgb
-				  (p.color (QPalette::WindowText))));
-	  root.set ("defaultuipanelhighlightcolor",
-		    octave_value (Utils::toRgb (p.color (QPalette::Light))));
-	  root.set ("defaultuipanelshadowcolor",
-		    octave_value (Utils::toRgb (p.color (QPalette::Dark))));
+          /*
+          root.set ("defaultfigurecolor",
+                    octave_value (Utils::toRgb (p.color (QPalette::Window))));
+          */
+          root.set ("defaultuicontrolbackgroundcolor",
+                    octave_value (Utils::toRgb (p.color (QPalette::Window))));
+          root.set ("defaultuicontrolforegroundcolor",
+                    octave_value (Utils::toRgb
+                                  (p.color (QPalette::WindowText))));
+          root.set ("defaultuipanelbackgroundcolor",
+                    octave_value (Utils::toRgb (p.color (QPalette::Window))));
+          root.set ("defaultuipanelforegroundcolor",
+                    octave_value (Utils::toRgb
+                                  (p.color (QPalette::WindowText))));
+          root.set ("defaultuipanelhighlightcolor",
+                    octave_value (Utils::toRgb (p.color (QPalette::Light))));
+          root.set ("defaultuipanelshadowcolor",
+                    octave_value (Utils::toRgb (p.color (QPalette::Dark))));
 
-	  qtHandlesInitialized = true;
+          qtHandlesInitialized = true;
 
-	  return true;
-	}
+          return true;
+        }
       else
-	error ("__init_qt__: QApplication object must exist.");
+        error ("__init_qt__: QApplication object must exist.");
     }
 
   return false;
 }
 
 bool __shutdown__ (void)
 {
   if (qtHandlesInitialized)
@@ -208,55 +208,55 @@ DEFUN (__uigetfile_qt__, args, , "")
   
   QStringList filterSpecs = makeFilterSpecs (args(0).cell_value ());
 
   if (isMultiSelect)
     {
       QString filter;
       QStringList files =
         QFileDialog::getOpenFileNames (0, caption, defaultFileName,
-				       filterSpecs.join (";;"), &filter, 0);
+                                       filterSpecs.join (";;"), &filter, 0);
 
       if (! files.isEmpty ())
-	{
-	  Cell cFiles (1, files.length ());
-	  QString dirName;
-	  int i = 0;
+        {
+          Cell cFiles (1, files.length ());
+          QString dirName;
+          int i = 0;
 
-	  foreach (const QString& s, files)
-	    {
-	      QFileInfo fi (s);
+          foreach (const QString& s, files)
+            {
+              QFileInfo fi (s);
 
-	      if (dirName.isEmpty ())
-		dirName = appendDirSep (fi.canonicalPath ());
-	      cFiles(i++) = toStdString (fi.fileName ());
-	    }
+              if (dirName.isEmpty ())
+                dirName = appendDirSep (fi.canonicalPath ());
+              cFiles(i++) = toStdString (fi.fileName ());
+            }
 
-	  retval(0) = cFiles;
-	  retval(1) = toStdString (dirName);
-	  if (! filter.isEmpty ())
-	    retval(2) = static_cast<double> (filterSpecs.indexOf (filter) + 1);
-	}
+          retval(0) = cFiles;
+          retval(1) = toStdString (dirName);
+          if (! filter.isEmpty ())
+            retval(2) = static_cast<double> (filterSpecs.indexOf (filter) + 1);
+        }
     }
   else
     {
       QString filter;
       QString fileName =
         QFileDialog::getOpenFileName (0, caption, defaultFileName,
-				      filterSpecs.join (";;"), &filter, 0);
+                                      filterSpecs.join (";;"), &filter, 0);
 
       if (! fileName.isNull ())
-	{
-	  QFileInfo fi (fileName);
+        {
+          QFileInfo fi (fileName);
 
-	  retval(0) = toStdString (fi.fileName ());
-	  retval(1) = toStdString (appendDirSep (fi.canonicalPath ()));
-	  if (! filter.isEmpty ())
-	    retval(2) = static_cast<double> (filterSpecs.indexOf (filter) + 1);
-	}
+          retval(0) = toStdString (fi.fileName ());
+          retval(1) = toStdString (appendDirSep (fi.canonicalPath ()));
+          if (! filter.isEmpty ())
+            retval(2) = static_cast<double> (filterSpecs.indexOf (filter) + 1);
+        }
     }
 
   return retval;
 }
 
 DEFUN (__uiputfile_qt__, args, , "")
 {
   using namespace QtHandles::Utils;
@@ -284,29 +284,29 @@ DEFUN (__uiputfile_qt__, args, , "")
   else
     defaultFileName = defaultDirectory + "/" + defaultFileName;
   
   QStringList filterSpecs = makeFilterSpecs (args(0).cell_value ());
 
   QString filter;
   QString fileName =
     QFileDialog::getSaveFileName (0, caption, defaultFileName,
-				  filterSpecs.join (";;"), &filter, 0);
+                                  filterSpecs.join (";;"), &filter, 0);
 
   if (! fileName.isNull ())
     {
       QFileInfo fi (fileName);
 
       retval(0) = toStdString (fi.fileName ());
       if (fi.exists ())
-	retval(1) = toStdString (appendDirSep (fi.canonicalPath ()));
+        retval(1) = toStdString (appendDirSep (fi.canonicalPath ()));
       else
-	retval(1) = toStdString (appendDirSep (fi.absolutePath ()));
+        retval(1) = toStdString (appendDirSep (fi.absolutePath ()));
       if (! filter.isEmpty ())
-	retval(2) = static_cast<double> (filterSpecs.indexOf (filter) + 1);
+        retval(2) = static_cast<double> (filterSpecs.indexOf (filter) + 1);
     }
 
   return retval;
 }
 
 DEFUN (__uigetdir_qt__, args, , "")
 {
   using namespace QtHandles::Utils;
@@ -316,17 +316,17 @@ DEFUN (__uigetdir_qt__, args, , "")
   //   args(1) : Dialog title
 
   octave_value retval ("");
 
   QString caption = fromStdString (args(1).string_value ());
   QString defaultDirectory = fromStdString (args(0).string_value ());
 
   QString dirName = QFileDialog::getExistingDirectory (0, caption,
-						       defaultDirectory);
+                                                       defaultDirectory);
 
   if (! dirName.isNull ())
     retval = toStdString (dirName);
 
   return retval;
 }
 
 #endif
diff --git a/libinterp/corefcn/pt-jit.cc b/libinterp/corefcn/pt-jit.cc
--- a/libinterp/corefcn/pt-jit.cc
+++ b/libinterp/corefcn/pt-jit.cc
@@ -873,17 +873,17 @@ jit_convert::visit_switch_command (tree_
       block = entry_blocks[i]; // case_cond
       assert (block);
 
       if (i)
         blocks.push_back (entry_blocks[i]);  // first block already pushed
 
       if (! twc->is_default_case ())
         {
-		  // compare result of switch expression with actual case label
+          // compare result of switch expression with actual case label
           tree_expression *te = twc->case_label ();
           jit_value *label = visit (te);
           assert(label);
 
           const jit_operation& fn = jit_typeinfo::binary_op (octave_value::op_eq);
           jit_value *cond = create_checked (fn, value, label);
           assert(cond);
 
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -52,37 +52,37 @@ gripe_method_access (const std::string& 
   std::string acc_s;
 
   if (acc.is_string ())
     acc_s = acc.string_value ();
   else
     acc_s = "class-restricted";
 
   error ("%s: method `%s' has %s access and cannot be run in this context",
-	 from.c_str (), meth.get_name ().c_str (), acc_s.c_str ());
+         from.c_str (), meth.get_name ().c_str (), acc_s.c_str ());
 }
 
 static void
 gripe_property_access (const std::string& from, const cdef_property& prop,
-		       bool is_set = false)
+                       bool is_set = false)
 {
   octave_value acc = prop.get (is_set ? "SetAccess" : "GetAccess");
   std::string acc_s;
 
   if (acc.is_string ())
     acc_s = acc.string_value ();
   else
     acc_s = "class-restricted";
 
   if (is_set)
     error ("%s: property `%s' has %s access and cannot be set in this context",
-	   from.c_str (), prop.get_name ().c_str (), acc_s.c_str ());
+           from.c_str (), prop.get_name ().c_str (), acc_s.c_str ());
   else
     error ("%s: property `%s' has %s access and cannot be obtained in this context",
-	   from.c_str (), prop.get_name ().c_str (), acc_s.c_str ());
+           from.c_str (), prop.get_name ().c_str (), acc_s.c_str ());
 }
 
 static std::string
 get_base_name (const std::string& nm)
 {
   std::string::size_type pos = nm.find_last_of ('.');
 
   if (pos != std::string::npos)
@@ -217,34 +217,34 @@ to_ov (const std::list<cdef_class>& clas
        it != class_list.end (); ++it, ++i)
     cls(i) = to_ov (*it);
 
   return octave_value (cls);
 }
 
 static bool
 is_superclass (const cdef_class& clsa, const cdef_class& clsb,
-	       bool allow_equal = true, int max_depth = -1)
+               bool allow_equal = true, int max_depth = -1)
 {
   bool retval = false;
 
   if (allow_equal && clsa == clsb)
     retval = true;
   else if (max_depth != 0)
     {
       Cell c = clsb.get ("SuperClasses").cell_value ();
 
       for (int i = 0; ! error_state && ! retval && i < c.numel (); i++)
-	{
-	  cdef_class cls = lookup_class (c(i));
-
-	  if (! error_state)
-	    retval = is_superclass (clsa, cls, true,
+        {
+          cdef_class cls = lookup_class (c(i));
+
+          if (! error_state)
+            retval = is_superclass (clsa, cls, true,
                                     max_depth < 0 ? max_depth : max_depth-1);
-	}
+        }
     }
 
   return retval;
 }
 
 inline bool
 is_strict_superclass (const cdef_class& clsa, const cdef_class& clsb)
 { return is_superclass (clsa, clsb, false); }
@@ -534,19 +534,19 @@ class_fromName (const octave_value_list&
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
-	retval(0) = to_ov (lookup_class (name));
+        retval(0) = to_ov (lookup_class (name));
       else
-	error ("fromName: invalid class name, expected a string value");
+        error ("fromName: invalid class name, expected a string value");
     }
   else
     error ("fromName: invalid number of parameters");
 
   return retval;
 }
 
 static octave_value_list
@@ -554,39 +554,39 @@ class_fevalStatic (const octave_value_li
 {
   octave_value_list retval;
 
   if (args.length () > 1 && args(0).type_name () == "object")
     {
       cdef_class cls (to_cdef (args(0)));
 
       if (! error_state)
-	{
-	  std::string meth_name = args(1).string_value ();
-
-	  if (! error_state)
-	    {
-	      cdef_method meth = cls.find_method (meth_name);
-
-	      if (meth.ok ())
-		{
+        {
+          std::string meth_name = args(1).string_value ();
+
+          if (! error_state)
+            {
+              cdef_method meth = cls.find_method (meth_name);
+
+              if (meth.ok ())
+                {
                     if (meth.is_static ())
                       retval = meth.execute (args.splice (0, 2), nargout,
                                              true, "fevalStatic");
                     else
                       error ("fevalStatic: method `%s' is not static",
                              meth_name.c_str ());
-		}
-	      else
-		error ("fevalStatic: method not found: %s",
-		       meth_name.c_str ());
-	    }
-	  else
-	    error ("fevalStatic: invalid method name, expected a string value");
-	}
+                }
+              else
+                error ("fevalStatic: method not found: %s",
+                       meth_name.c_str ());
+            }
+          else
+            error ("fevalStatic: invalid method name, expected a string value");
+        }
       error ("fevalStatic: invalid object, expected a meta.class object");
     }
   else
     error ("fevalStatic: invalid arguments");
 
   return retval;
 }
 
@@ -596,40 +596,40 @@ class_getConstant (const octave_value_li
   octave_value_list retval;
 
   if (args.length () == 2 && args(0).type_name () == "object"
       && args(0).class_name () == "meta.class")
     {
       cdef_class cls = to_cdef (args(0));
 
       if (! error_state)
-	{
-	  std::string prop_name = args(1).string_value ();
-
-	  if (! error_state)
-	    {
-	      cdef_property prop = cls.find_property (prop_name);
-
-	      if (prop.ok ())
-		{
+        {
+          std::string prop_name = args(1).string_value ();
+
+          if (! error_state)
+            {
+              cdef_property prop = cls.find_property (prop_name);
+
+              if (prop.ok ())
+                {
                   if (prop.is_constant ())
                     retval(0) = prop.get_value (true, "getConstant");
                   else
                     error ("getConstant: property `%s' is not constant",
                            prop_name.c_str ());
-		}
-	      else
-		error ("getConstant: property not found: %s",
-		       prop_name.c_str ());
-	    }
-	  else
-	    error ("getConstant: invalid property name, expected a string value");
-	}
+                }
+              else
+                error ("getConstant: property not found: %s",
+                       prop_name.c_str ());
+            }
+          else
+            error ("getConstant: invalid property name, expected a string value");
+        }
       else
-	error ("getConstant: invalid object, expected a meta.class object");
+        error ("getConstant: invalid object, expected a meta.class object");
     }
   else
     error ("getConstant: invalid arguments");
 
   return retval;
 }
 
 #define META_CLASS_CMP(OP, CLSA, CLSB, FUN) \
@@ -642,19 +642,19 @@ class_ ## OP (const octave_value_list& a
       && args(0).type_name () == "object" && args(1).type_name () == "object" \
       && args(0).class_name () == "meta.class" && args(1).class_name () == "meta.class") \
     { \
       cdef_class clsa = to_cdef (args(0)); \
 \
       cdef_class clsb = to_cdef (args(1)); \
 \
       if (! error_state) \
-	retval(0) = FUN (CLSA, CLSB); \
+        retval(0) = FUN (CLSA, CLSB); \
       else \
-	error (#OP ": invalid objects, expected meta.class objects"); \
+        error (#OP ": invalid objects, expected meta.class objects"); \
     } \
   else \
     error (#OP ": invalid arguments"); \
 \
   return retval; \
 }
 
 META_CLASS_CMP (lt, clsb, clsa, is_strict_superclass)
@@ -768,20 +768,20 @@ make_meta_class (const std::string& name
   cls.put ("Sealed", true);
   cls.mark_as_meta_class ();
 
   return cls;
 }
 
 static cdef_property
 make_property (const cdef_class& cls, const std::string& name,
-	       const octave_value& get_method = Matrix (),
-	       const std::string& get_access = "public",
-	       const octave_value& set_method = Matrix (),
-	       const std::string& set_access = "public")
+               const octave_value& get_method = Matrix (),
+               const std::string& get_access = "public",
+               const octave_value& set_method = Matrix (),
+               const std::string& set_access = "public")
 {
   cdef_property prop (name);
 
   prop.set_class (cdef_class::meta_property ());
   prop.put ("Description", std::string ());
   prop.put ("DetailedDescription", std::string ());
   prop.put ("Abstract", false);
   prop.put ("Constant", false);
@@ -943,17 +943,17 @@ octave_classdef::subsref (const std::str
   // purpose (not sure we should even implement this) and any overload subsref
   // should not be called.
 
   retval = object.subsref (type, idx, 1, skip, cdef_class (), auto_add);
 
   if (! error_state)
     {
       if (type.length () > skip && idx.size () > skip)
-	retval = retval(0).next_subsref (1, type, idx, skip);
+        retval = retval(0).next_subsref (1, type, idx, skip);
     }
 
   return retval.length () > 0 ? retval(0) : octave_value ();
 }
 
 octave_value
 octave_classdef::subsasgn (const std::string& type,
                            const std::list<octave_value_list>& idx,
@@ -1340,23 +1340,23 @@ cdef_object_scalar::subsref (const std::
   octave_value_list retval;
 
   if (! cls.ok ())
     return retval;
 
   switch (type[0])
     {
     case '.':
-	{
-	  std::string name = (idx.front ())(0).string_value ();
-
-	  cdef_method meth = cls.find_method (name);
-
-	  if (meth.ok ())
-	    {
+        {
+          std::string name = (idx.front ())(0).string_value ();
+
+          cdef_method meth = cls.find_method (name);
+
+          if (meth.ok ())
+            {
               int _nargout = (type.length () > 2 ? 1 : nargout);
 
               octave_value_list args;
 
               skip = 1;
 
               if (type.length () > 1 && type[1] == '(')
                 {
@@ -1370,40 +1370,40 @@ cdef_object_scalar::subsref (const std::
               if (meth.is_static ())
                 retval = meth.execute (args, _nargout, true, "subsref");
               else
                 {
                   refcount++;
                   retval = meth.execute (cdef_object (this), args, _nargout,
                                          true, "subsref");
                 }
-	    }
-
-	  if (skip == 0 && ! error_state)
-	    {
-	      cdef_property prop = cls.find_property (name);
-
-	      if (prop.ok ())
-		{
+            }
+
+          if (skip == 0 && ! error_state)
+            {
+              cdef_property prop = cls.find_property (name);
+
+              if (prop.ok ())
+                {
                   if (prop.is_constant ())
                     retval(0) = prop.get_value (true, "subsref");
                   else
                     {
                       refcount++;
                       retval(0) = prop.get_value (cdef_object (this),
                                                   true, "subsref");
                     }
 
                   skip = 1;
-		}
-	      else
-		error ("subsref: unknown method or property: %s", name.c_str ());
-	    }
-	  break;
-	}
+                }
+              else
+                error ("subsref: unknown method or property: %s", name.c_str ());
+            }
+          break;
+        }
 
     case '(':
         {
           refcount++;
 
           cdef_object this_obj (this);
 
           Array<cdef_object> arr (dim_vector (1, 1), this_obj);
@@ -1885,17 +1885,17 @@ cdef_class::cdef_class_rep::find_method 
     }
   else
     {
       cdef_method& meth = it->second;
 
       // FIXME: check if method reload needed
 
       if (meth.ok ())
-	return meth;
+        return meth;
     }
 
   if (! local)
     {
       // Look into superclasses
 
       Cell super_classes = get ("SuperClasses").cell_value ();
 
@@ -2096,17 +2096,17 @@ cdef_class::cdef_class_rep::get_methods 
 
   if (! error_state)
     {
       Cell c (meths.size (), 1);
 
       int idx = 0;
 
       for (std::map<std::string,cdef_method>::const_iterator it = meths.begin ();
-	   it != meths.end (); ++it, ++idx)
+           it != meths.end (); ++it, ++idx)
         c (idx, 0) = to_ov (it->second);
 
       return c;
     }
 
   return Cell ();
 }
 
@@ -2144,50 +2144,50 @@ cdef_class::cdef_class_rep::find_methods
 
   Cell super_classes = get ("SuperClasses").cell_value ();
 
   for (int i = 0; i < super_classes.numel (); i++)
     {
       cdef_class cls = lookup_class (super_classes(i));
 
       if (! error_state)
-	cls.get_rep ()->find_methods (meths, true);
+        cls.get_rep ()->find_methods (meths, true);
       else
-	break;
+        break;
     }
 }
 
 cdef_property
 cdef_class::cdef_class_rep::find_property (const std::string& nm)
 {
   property_iterator it = property_map.find (nm);
 
   if (it != property_map.end ())
     {
       cdef_property& prop = it->second;
 
       if (prop.ok ())
-	return prop;
+        return prop;
     }
 
   // Look into superclasses
 
   Cell super_classes = get ("SuperClasses").cell_value ();
 
   for (int i = 0; i < super_classes.numel (); i++)
     {
       cdef_class cls = lookup_class (super_classes(i));
 
       if (! error_state)
-	{
-	  cdef_property prop = cls.find_property (nm);
-
-	  if (prop.ok ())
-	    return prop;
-	}
+        {
+          cdef_property prop = cls.find_property (nm);
+
+          if (prop.ok ())
+            return prop;
+        }
     }
 
   return cdef_property ();
 }
 
 void
 cdef_class::cdef_class_rep::install_property (const cdef_property& prop)
 {
@@ -2205,17 +2205,17 @@ cdef_class::cdef_class_rep::get_properti
 
   if (! error_state)
     {
       Cell c (props.size (), 1);
 
       int idx = 0;
 
       for (std::map<std::string,cdef_property>::const_iterator it = props.begin ();
-	   it != props.end (); ++it, ++idx)
+           it != props.end (); ++it, ++idx)
         c (idx, 0) = to_ov (it->second);
 
       return c;
     }
 
   return Cell ();
 }
 
@@ -2226,42 +2226,42 @@ cdef_class::cdef_class_rep::find_propert
   property_const_iterator it;
 
   for (it = property_map.begin (); ! error_state && it != property_map.end ();
        ++it)
     {
       std::string nm = it->second.get_name ();
 
       if (props.find (nm) == props.end ())
-	{
+        {
           if (only_inherited)
             {
               octave_value acc = it->second.get ("GetAccess");
 
               if (! acc.is_string ()
                   || acc.string_value () == "private")
                 continue;
             }
 
-	  props[nm] = it->second;
-	}
+          props[nm] = it->second;
+        }
     }
 
   // Look into superclasses
 
   Cell super_classes = get ("SuperClasses").cell_value ();
 
   for (int i = 0; ! error_state && i < super_classes.numel (); i++)
     {
       cdef_class cls = lookup_class (super_classes(i));
 
       if (! error_state)
-	cls.get_rep ()->find_properties (props, true);
+        cls.get_rep ()->find_properties (props, true);
       else
-	break;
+        break;
     }
 }
 
 void
 cdef_class::cdef_class_rep::find_names (std::set<std::string>& names,
                                         bool all)
 {
   load_all_methods ();
@@ -2307,36 +2307,36 @@ cdef_class::cdef_class_rep::find_names (
 
   Cell super_classes = get ("SuperClasses").cell_value ();
 
   for (int i = 0; ! error_state && i < super_classes.numel (); i++)
     {
       cdef_class cls = lookup_class (super_classes(i));
 
       if (! error_state)
-	cls.get_rep ()->find_names (names, all);
+        cls.get_rep ()->find_names (names, all);
       else
-	break;
+        break;
     }
 }
 
 string_vector
 cdef_class::cdef_class_rep::get_names (void)
 {
   std::set<std::string> names;
 
   find_names (names, false);
 
   if (! error_state)
     {
       string_vector v (names.size ());
 
       int idx = 0;
       for (std::set<std::string>::const_iterator it = names.begin ();
-	   it != names.end (); ++it, ++idx)
+           it != names.end (); ++it, ++idx)
         v[idx] = *it;
 
       return v.sort (true);
     }
 
   return string_vector ();
 }
 
@@ -2362,17 +2362,17 @@ cdef_class::cdef_class_rep::delete_objec
 
   Cell super_classes = get ("SuperClasses").cell_value ();
 
   for (int i = 0; i < super_classes.numel (); i++)
     {
       cdef_class cls = lookup_class (super_classes(i));
 
       if (!error_state)
-	cls.delete_object (obj);
+        cls.delete_object (obj);
     }
 }
 
 octave_value_list
 cdef_class::cdef_class_rep::meta_subsref (const std::string& type,
                                           const std::list<octave_value_list>& idx,
                                           int nargout)
 {
@@ -2445,17 +2445,17 @@ cdef_class::cdef_class_rep::meta_subsref
     default:
       ::error ("invalid meta.class indexing");
       break;
     }
 
   if (! error_state)
     {
       if (type.length () > skip && idx.size () > skip && ! retval.empty ())
-	retval = retval(0).next_subsref (nargout, type, idx, skip);
+        retval = retval(0).next_subsref (nargout, type, idx, skip);
     }
 
   return retval;
 }
 
 void
 cdef_class::cdef_class_rep::meta_release (void)
 {
@@ -2996,17 +2996,17 @@ cdef_property::cdef_property_rep::get_va
     {
       octave_value_list args;
 
       args(0) = to_ov (obj);
       
       args = execute_ov (get_fcn, args, 1);
 
       if (! error_state)
-	retval = args(0);
+        retval = args(0);
     }
 
   return retval;
 }
 
 octave_value
 cdef_property::cdef_property_rep::get_value (bool do_check_access,
                                              const std::string& who)
@@ -3148,79 +3148,79 @@ cdef_method::cdef_method_rep::check_meth
       if (is_dummy_method (function))
         ::error ("no definition found for method `%s' of class `%s'",
                  get_name ().c_str (), dispatch_type.c_str ());
     }
 }
 
 octave_value_list
 cdef_method::cdef_method_rep::execute (const octave_value_list& args,
-				       int nargout, bool do_check_access,
+                                       int nargout, bool do_check_access,
                                        const std::string& who)
 {
   octave_value_list retval;
 
   if (do_check_access && ! check_access ())
     {
       gripe_method_access (who, wrap ());
 
       return retval;
     }
 
   if (! get ("Abstract").bool_value ())
     {
       check_method ();
 
       if (! error_state && function.is_defined ())
-	{
-	  retval = execute_ov (function, args, nargout);
-	}
+        {
+          retval = execute_ov (function, args, nargout);
+        }
     }
   else
     error ("%s: cannot execute abstract method",
-	   get ("Name").string_value ().c_str ());
+           get ("Name").string_value ().c_str ());
 
   return retval;
 }
 
 octave_value_list
 cdef_method::cdef_method_rep::execute (const cdef_object& obj,
-				       const octave_value_list& args,
-				       int nargout, bool do_check_access,
+                                       const octave_value_list& args,
+                                       int nargout, bool do_check_access,
                                        const std::string& who)
 {
   octave_value_list retval;
 
   if (do_check_access && ! check_access ())
     {
       gripe_method_access (who, wrap ());
 
       return retval;
     }
 
   if (! get ("Abstract").bool_value ())
     {
       check_method ();
 
       if (! error_state && function.is_defined ())
-	{
+        {
           octave_value_list new_args;
 
-	  new_args.resize (args.length () + 1);
-
-	  new_args(0) = to_ov (obj);
-	  for (int i = 0; i < args.length (); i++)
-	    new_args(i+1) = args(i);
-
-	  retval = execute_ov (function, new_args, nargout);
-	}
+          new_args.resize (args.length () + 1);
+
+          new_args(0) = to_ov (obj);
+          for (int i = 0; i < args.length (); i++)
+            new_args(i+1) = args(i);
+
+          retval = execute_ov (function, new_args, nargout);
+        }
     }
   else
     error ("%s: cannot execute abstract method",
-	   get ("Name").string_value ().c_str ());
+           get ("Name").string_value ().c_str ());
 
   return retval;
 }
 
 bool
 cdef_method::cdef_method_rep::is_constructor (void) const
 {
   if (function.is_function())
@@ -3256,17 +3256,17 @@ cdef_method::cdef_method_rep::meta_subsr
     default:
       error ("invalid meta.method indexing");
       break;
     }
 
   if (! error_state)
     {
       if (type.length () > 1 && idx.size () > 1 && ! retval.empty ())
-	retval = retval(0).next_subsref (nargout, type, idx, 1);
+        retval = retval(0).next_subsref (nargout, type, idx, 1);
     }
 
   return retval;
 }
 
 static cdef_package
 lookup_package (const std::string& name)
 {
@@ -3278,19 +3278,19 @@ package_fromName (const octave_value_lis
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
-	retval(0) = to_ov (lookup_package (name));
+        retval(0) = to_ov (lookup_package (name));
       else
-	error ("fromName: invalid package name, expected a string value");
+        error ("fromName: invalid package name, expected a string value");
     }
   else
     error ("fromName: invalid number of parameters");
 
   return retval;
 }
 
 static octave_value_list
@@ -3546,51 +3546,51 @@ install_classdef (void)
   meta_class.install_property (make_property  (meta_class, "ContainingPackage"));
   meta_class.install_property (make_property  (meta_class, "Description"));
   meta_class.install_property (make_property  (meta_class, "DetailedDescription"));
   meta_class.install_property (make_property  (meta_class, "Events"));
   meta_class.install_property (make_attribute (meta_class, "HandleCompatible"));
   meta_class.install_property (make_attribute (meta_class, "Hidden"));
   meta_class.install_property
       (make_property (meta_class, "InferiorClasses",
-		      make_fcn_handle (class_get_inferiorclasses, "meta.class>get.InferiorClasses"),
-		      "public", Matrix (), "private"));
+                      make_fcn_handle (class_get_inferiorclasses, "meta.class>get.InferiorClasses"),
+                      "public", Matrix (), "private"));
   meta_class.install_property
       (make_property  (meta_class, "Methods",
-		       make_fcn_handle (class_get_methods, "meta.class>get.Methods"),
-		       "public", Matrix (), "private"));
+                       make_fcn_handle (class_get_methods, "meta.class>get.Methods"),
+                       "public", Matrix (), "private"));
   meta_class.install_property
       (make_property  (meta_class, "MethodList",
-		       make_fcn_handle (class_get_methods, "meta.class>get.MethodList"),
-		       "public", Matrix (), "private"));
+                       make_fcn_handle (class_get_methods, "meta.class>get.MethodList"),
+                       "public", Matrix (), "private"));
   meta_class.install_property (make_attribute (meta_class, "Name"));
   meta_class.install_property
       (make_property  (meta_class, "Properties",
-		       make_fcn_handle (class_get_properties, "meta.class>get.Properties"),
-		       "public", Matrix (), "private"));
+                       make_fcn_handle (class_get_properties, "meta.class>get.Properties"),
+                       "public", Matrix (), "private"));
   meta_class.install_property
       (make_property  (meta_class, "PropertyList",
-		       make_fcn_handle (class_get_properties, "meta.class>get.PropertyList"),
-		       "public", Matrix (), "private"));
+                       make_fcn_handle (class_get_properties, "meta.class>get.PropertyList"),
+                       "public", Matrix (), "private"));
   meta_class.install_property (make_attribute (meta_class, "Sealed"));
   meta_class.install_property
       (make_property (meta_class, "SuperClasses",
-		      make_fcn_handle (class_get_superclasses, "meta.class>get.SuperClasses"),
-		      "public", Matrix (), "private"));
+                      make_fcn_handle (class_get_superclasses, "meta.class>get.SuperClasses"),
+                      "public", Matrix (), "private"));
   meta_class.install_property
       (make_property (meta_class, "SuperClassList",
-		      make_fcn_handle (class_get_superclasses, "meta.class>get.SuperClassList"),
-		      "public", Matrix (), "private"));
+                      make_fcn_handle (class_get_superclasses, "meta.class>get.SuperClassList"),
+                      "public", Matrix (), "private"));
   /* meta.class methods */
   meta_class.install_method (make_method (meta_class, "fromName", class_fromName,
-					  "public", true));
+                                          "public", true));
   meta_class.install_method (make_method (meta_class, "fevalStatic", class_fevalStatic,
-					  "public", false));
+                                          "public", false));
   meta_class.install_method (make_method (meta_class, "getConstant", class_getConstant,
-					  "public", false));
+                                          "public", false));
   meta_class.install_method (make_method (meta_class, "eq", class_eq));
   meta_class.install_method (make_method (meta_class, "ne", class_ne));
   meta_class.install_method (make_method (meta_class, "lt", class_lt));
   meta_class.install_method (make_method (meta_class, "le", class_le));
   meta_class.install_method (make_method (meta_class, "gt", class_gt));
   meta_class.install_method (make_method (meta_class, "ge", class_ge));
 
   /* meta.method properties */
@@ -3617,52 +3617,52 @@ install_classdef (void)
   meta_property.install_property (make_attribute (meta_property, "Hidden"));
   meta_property.install_property (make_attribute (meta_property, "GetObservable"));
   meta_property.install_property (make_attribute (meta_property, "SetObservable"));
   meta_property.install_property (make_attribute (meta_property, "GetMethod"));
   meta_property.install_property (make_attribute (meta_property, "SetMethod"));
   meta_property.install_property (make_attribute (meta_property, "DefiningClass"));
   meta_property.install_property
       (make_property (meta_property, "DefaultValue",
-		      make_fcn_handle (property_get_defaultvalue, "meta.property>get.DefaultValue"),
-		      "public", Matrix (), "private"));
+                      make_fcn_handle (property_get_defaultvalue, "meta.property>get.DefaultValue"),
+                      "public", Matrix (), "private"));
   meta_property.install_property (make_attribute (meta_property, "HasDefault"));
   /* meta.property events */
   // FIXME: add events
 
   /* handle methods */
   handle.install_method (make_method (handle, "delete", handle_delete));
 
   /* meta.package properties */
   meta_package.install_property (make_attribute (meta_package, "Name"));
   meta_package.install_property (make_property  (meta_package, "ContainingPackage"));
   meta_package.install_property
       (make_property (meta_package, "ClassList",
-		      make_fcn_handle (package_get_classes, "meta.package>get.ClassList"),
-		      "public", Matrix (), "private"));
+                      make_fcn_handle (package_get_classes, "meta.package>get.ClassList"),
+                      "public", Matrix (), "private"));
   meta_package.install_property
       (make_property (meta_package, "Classes",
-		      make_fcn_handle (package_get_classes, "meta.package>get.Classes"),
-		      "public", Matrix (), "private"));
+                      make_fcn_handle (package_get_classes, "meta.package>get.Classes"),
+                      "public", Matrix (), "private"));
   meta_package.install_property
       (make_property (meta_package, "FunctionList",
-		      make_fcn_handle (package_get_functions, "meta.package>get.FunctionList"),
-		      "public", Matrix (), "private"));
+                      make_fcn_handle (package_get_functions, "meta.package>get.FunctionList"),
+                      "public", Matrix (), "private"));
   meta_package.install_property
       (make_property (meta_package, "Functions",
-		      make_fcn_handle (package_get_functions, "meta.package>get.Functions"),
-		      "public", Matrix (), "private"));
+                      make_fcn_handle (package_get_functions, "meta.package>get.Functions"),
+                      "public", Matrix (), "private"));
   meta_package.install_property
       (make_property (meta_package, "PackageList",
-		      make_fcn_handle (package_get_packages, "meta.package>get.PackageList"),
-		      "public", Matrix (), "private"));
+                      make_fcn_handle (package_get_packages, "meta.package>get.PackageList"),
+                      "public", Matrix (), "private"));
   meta_package.install_property
       (make_property (meta_package, "Packages",
-		      make_fcn_handle (package_get_packages, "meta.package>get.Packages"),
-		      "public", Matrix (), "private"));
+                      make_fcn_handle (package_get_packages, "meta.package>get.Packages"),
+                      "public", Matrix (), "private"));
   meta_package.install_method (make_method (meta_package, "fromName", package_fromName,
                                             "public", true));
   meta_package.install_method (make_method (meta_package, "getAllPackages", package_getAllPackages,
                                             "public", true));
 
   /* create "meta" package */
   cdef_package package_meta = cdef_package::_meta = make_package ("meta");
   package_meta.install_class (meta_class,       "class");
@@ -3729,29 +3729,29 @@ cdef_manager::do_find_class (const std::
           if (ov_cls.is_defined ())
             it = all_classes.find (name);
         }
     }
 
   if (it == all_classes.end ())
     {
       if (error_if_not_found)
-	error ("class not found: %s", name.c_str ());
+        error ("class not found: %s", name.c_str ());
     }
   else
     {
       cdef_class cls = it->second;
 
       if (! cls.is_builtin ())
         cls = lookup_class (cls);
 
       if (cls.ok ())
-	return cls;
+        return cls;
       else
-	all_classes.erase (it);
+        all_classes.erase (it);
     }
 
   return cdef_class ();
 }
 
 octave_function*
 cdef_manager::do_find_method_symbol (const std::string& method_name,
                                      const std::string& class_name)
@@ -3829,19 +3829,19 @@ DEFUN (__meta_get_package__, args, , "")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       std::string cname = args(0).string_value ();
 
       if (! error_state)
-	retval = to_ov (lookup_package (cname));
+        retval = to_ov (lookup_package (cname));
       else
-	error ("invalid package name, expected a string value");
+        error ("invalid package name, expected a string value");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (__superclass_reference__, args, /* nargout */,
@@ -3865,19 +3865,19 @@ Undocumented internal function.\n\
             << args(0).string_value () << ")"
             << std::endl;
 
   if (args.length () == 1)
     {
       std::string cls = args(0).string_value ();
 
       if (! error_state)
-	retval = to_ov (lookup_class (cls));
+        retval = to_ov (lookup_class (cls));
       else
-	error ("invalid class name, expected a string value");
+        error ("invalid class name, expected a string value");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (metaclass, args, /* nargout */,
diff --git a/libinterp/octave-value/ov-classdef.h b/libinterp/octave-value/ov-classdef.h
--- a/libinterp/octave-value/ov-classdef.h
+++ b/libinterp/octave-value/ov-classdef.h
@@ -202,22 +202,22 @@ public:
       : rep (r) { }
 
   virtual ~cdef_object (void)
     { rep->release (); }
 
   cdef_object& operator = (const cdef_object& obj)
     {
       if (rep != obj.rep)
-	{
+        {
           rep->release ();
 
-	  rep = obj.rep;
-	  rep->refcount++;
-	}
+          rep = obj.rep;
+          rep->refcount++;
+        }
 
       return *this;
     }
 
   cdef_class get_class (void) const;
 
   void set_class (const cdef_class& cls) { rep->set_class (cls); }
 
@@ -406,22 +406,22 @@ public:
   void put (const std::string& pname, const octave_value& val)
     { map.assign (pname, val); }
 
   octave_value get (const std::string& pname) const
     {
       Cell val = map.contents (pname);
 
       if (val.numel () > 0)
-	return val(0, 0);
+        return val(0, 0);
       else
-	{
-	  error ("get: unknown slot: %s", pname.c_str ());
-	  return octave_value ();
-	}
+        {
+          error ("get: unknown slot: %s", pname.c_str ());
+          return octave_value ();
+        }
     }
 
   octave_value_list
   subsref (const std::string& type, const std::list<octave_value_list>& idx,
            int nargout, size_t& skip, const cdef_class& context,
            bool auto_add);
 
   octave_value
@@ -613,17 +613,17 @@ cdef_class : public cdef_meta_object
 {
 private:
 
   class
   cdef_class_rep : public cdef_meta_object_rep
   {
   public:
     cdef_class_rep (void)
-	: cdef_meta_object_rep (), member_count (0), handle_class (false),
+        : cdef_meta_object_rep (), member_count (0), handle_class (false),
           object_count (0), meta (false) { }
 
     cdef_class_rep (const std::list<cdef_class>& superclasses);
 
     cdef_object_rep* copy (void) const { return new cdef_class_rep (*this); }
 
     bool is_class (void) const { return true; }
 
@@ -776,18 +776,18 @@ public:
   cdef_class (const cdef_class& cls)
       : cdef_meta_object (cls) { }
 
   cdef_class (const cdef_object& obj)
       : cdef_meta_object (obj)
     {
       // This should never happen...
       if (! is_class ())
-	error ("internal error: invalid assignment from %s to meta.class object",
-	       class_name ().c_str ());
+        error ("internal error: invalid assignment from %s to meta.class object",
+               class_name ().c_str ());
     }
 
   cdef_class& operator = (const cdef_class& cls)
     {
       cdef_object::operator= (cls);
 
       return *this;
     }
@@ -907,17 +907,17 @@ cdef_property : public cdef_meta_object
 
 private:
 
   class
   cdef_property_rep : public cdef_meta_object_rep
   {
   public:
     cdef_property_rep (void)
-	: cdef_meta_object_rep () { }
+        : cdef_meta_object_rep () { }
 
     cdef_object_rep* copy (void) const { return new cdef_property_rep (*this); }
 
     bool is_property (void) const { return true; }
 
     std::string get_name (void) const { return get("Name").string_value (); }
 
     void set_name (const std::string& nm) { put ("Name", nm); }
@@ -962,18 +962,18 @@ public:
   cdef_property (const cdef_property& prop)
       : cdef_meta_object (prop) { }
 
   cdef_property (const cdef_object& obj)
       : cdef_meta_object (obj)
     {
       // This should never happen...
       if (! is_property ())
-	error ("internal error: invalid assignment from %s to meta.property object",
-	       class_name ().c_str ());
+        error ("internal error: invalid assignment from %s to meta.property object",
+               class_name ().c_str ());
     }
 
   cdef_property& operator = (const cdef_property& prop)
     {
       cdef_object::operator= (prop);
 
       return *this;
     }
@@ -1045,17 +1045,17 @@ private:
     void mark_as_external (const std::string& dtype)
       { dispatch_type = dtype; }
 
     octave_value_list execute (const octave_value_list& args, int nargout,
                                bool do_check_access = true,
                                const std::string& who = std::string ());
 
     octave_value_list execute (const cdef_object& obj,
-			       const octave_value_list& args, int nargout,
+                               const octave_value_list& args, int nargout,
                                bool do_check_access = true,
                                const std::string& who = std::string ());
 
     bool is_constructor (void) const;
 
     octave_value_list
     meta_subsref (const std::string& type,
                   const std::list<octave_value_list>& idx, int nargout);
@@ -1095,18 +1095,18 @@ public:
   cdef_method (const cdef_method& meth)
       : cdef_meta_object (meth) { }
 
   cdef_method (const cdef_object& obj)
       : cdef_meta_object (obj)
     {
       // This should never happen...
       if (! is_method ())
-	error ("internal error: invalid assignment from %s to meta.method object",
-	       class_name ().c_str ());
+        error ("internal error: invalid assignment from %s to meta.method object",
+               class_name ().c_str ());
     }
 
   cdef_method& operator = (const cdef_method& meth)
     {
       cdef_object::operator= (meth);
 
       return *this;
     }
@@ -1114,17 +1114,17 @@ public:
   /* normal invokation */
   octave_value_list execute (const octave_value_list& args, int nargout,
                              bool do_check_access = true,
                              const std::string& who = std::string ())
     { return get_rep ()->execute (args, nargout, do_check_access, who); }
 
   /* dot-invokation: object is pushed as 1st argument */
   octave_value_list execute (const cdef_object& obj,
-			     const octave_value_list& args, int nargout,
+                             const octave_value_list& args, int nargout,
                              bool do_check_access = true,
                              const std::string& who = std::string ())
     { return get_rep ()->execute (obj, args, nargout, do_check_access, who); }
 
   bool check_access (void) const { return get_rep ()->check_access (); }
   
   std::string get_name (void) const { return get_rep ()->get_name (); }
 
@@ -1331,18 +1331,18 @@ public:
   cdef_package (const cdef_package& pack)
     : cdef_meta_object (pack) { }
 
   cdef_package (const cdef_object& obj)
       : cdef_meta_object (obj)
     {
       // This should never happen...
       if (! is_package ())
-	error ("internal error: invalid assignment from %s to meta.package object",
-	       class_name ().c_str ());
+        error ("internal error: invalid assignment from %s to meta.package object",
+               class_name ().c_str ());
     }
 
   cdef_package& operator = (const cdef_package& pack)
     {
       cdef_object::operator= (pack);
 
       return *this;
     }
@@ -1418,28 +1418,28 @@ public:
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool print_name_tag (std::ostream& os, const std::string& name) const;
 
   void print_with_name (std::ostream& os, const std::string& name,
                         bool print_padding = true);
 
   octave_value_list subsref (const std::string& type,
-			     const std::list<octave_value_list>& idx,
+                             const std::list<octave_value_list>& idx,
                              int nargout);
 
   octave_value subsref (const std::string& type,
-			const std::list<octave_value_list>& idx)
+                        const std::list<octave_value_list>& idx)
     {
       octave_value_list retval = subsref (type, idx, 1);
       return (retval.length () > 0 ? retval(0) : octave_value ());
     }
 
   octave_value subsref (const std::string& type,
-			const std::list<octave_value_list>& idx,
+                        const std::list<octave_value_list>& idx,
                         bool auto_add);
 
   octave_value subsasgn (const std::string& type,
                          const std::list<octave_value_list>& idx,
                          const octave_value& rhs);
 
   octave_value
   undef_subsasgn (const std::string& type,
