# HG changeset patch
# User Rik <rik@octave.org>
# Date 1432699662 25200
#      Tue May 26 21:07:42 2015 -0700
# Node ID 83792dd9bcc18bc4559e77998f5d6fe32430078a
# Parent  e914b5399c675b4b5a646b46c8efb3312daeb42c
Use in-place operators in m-files where possible.

* scripts/audio/@audioplayer/set.m, scripts/audio/@audiorecorder/set.m,
scripts/audio/mu2lin.m, scripts/elfun/cosd.m, scripts/general/del2.m,
scripts/general/profexplore.m, scripts/general/quadl.m, scripts/general/rat.m,
scripts/general/rotdim.m, scripts/help/get_first_help_sentence.m,
scripts/help/private/__strip_html_tags__.m, scripts/image/cubehelix.m,
scripts/io/textread.m, scripts/linear-algebra/duplication_matrix.m,
scripts/linear-algebra/housh.m, scripts/linear-algebra/krylov.m,
scripts/linear-algebra/logm.m, scripts/linear-algebra/normest.m,
scripts/linear-algebra/onenormest.m, scripts/optimization/fminsearch.m,
scripts/optimization/lsqnonneg.m, scripts/optimization/qp.m,
scripts/plot/appearance/annotation.m, scripts/plot/appearance/axis.m,
scripts/plot/appearance/legend.m, scripts/plot/appearance/specular.m,
scripts/plot/draw/colorbar.m, scripts/plot/draw/hist.m,
scripts/plot/draw/plotmatrix.m, scripts/plot/draw/private/__stem__.m,
scripts/plot/util/__actual_axis_position__.m,
scripts/plot/util/__gnuplot_drawnow__.m, scripts/plot/util/findobj.m,
scripts/plot/util/print.m, scripts/plot/util/private/__go_draw_axes__.m,
scripts/plot/util/private/__print_parse_opts__.m, scripts/plot/util/rotate.m,
scripts/polynomial/pchip.m, scripts/polynomial/polyaffine.m,
scripts/polynomial/polyder.m, scripts/polynomial/private/__splinefit__.m,
scripts/polynomial/residue.m, scripts/signal/arch_fit.m,
scripts/signal/arch_rnd.m, scripts/signal/bartlett.m,
scripts/signal/blackman.m, scripts/signal/freqz.m, scripts/signal/hamming.m,
scripts/signal/hanning.m, scripts/signal/spectral_adf.m,
scripts/signal/spectral_xdf.m, scripts/signal/stft.m,
scripts/sparse/bicgstab.m, scripts/sparse/cgs.m,
scripts/sparse/private/__sprand_impl__.m, scripts/sparse/qmr.m,
scripts/sparse/sprandsym.m, scripts/sparse/svds.m, scripts/specfun/legendre.m,
scripts/special-matrix/gallery.m, scripts/statistics/base/gls.m,
scripts/statistics/models/logistic_regression.m,
scripts/statistics/tests/kruskal_wallis_test.m,
scripts/statistics/tests/manova.m, scripts/statistics/tests/wilcoxon_test.m,
scripts/time/datevec.m:
Use in-place operators in m-files where possible.

diff --git a/scripts/audio/@audioplayer/set.m b/scripts/audio/@audioplayer/set.m
--- a/scripts/audio/@audioplayer/set.m
+++ b/scripts/audio/@audioplayer/set.m
@@ -45,17 +45,17 @@ function settable = set (varargin)
     for [value, property] = varargin{2}
       setproperty (player, property, value);
     endfor
   elseif (nargin == 3)
     if (iscell (varargin{2}))
       index = 1;
       for property = varargin{2}
         setproperty (player, char (property), varargin{3}{index});
-        index = index + 1;
+        index += 1;
       endfor
     else
       setproperty (player, varargin{2}, varargin{3});
     endif
   else
     error ("@audioplayer/set: wrong number of arguments to the set method");
   endif
 
diff --git a/scripts/audio/@audiorecorder/set.m b/scripts/audio/@audiorecorder/set.m
--- a/scripts/audio/@audiorecorder/set.m
+++ b/scripts/audio/@audiorecorder/set.m
@@ -45,17 +45,17 @@ function settable = set (varargin)
     for [value, property] = varargin{2}
       setproperty (recorder, property, value);
     endfor
   elseif (nargin == 3)
     if (iscell (varargin{2}))
       index = 1;
       for property = varargin{2}
         setproperty (recorder, char (property), varargin{3}{index});
-        index = index + 1;
+        index += 1;
       endfor
     else
       setproperty (recorder, varargin{2}, varargin{3});
     endif
   endif
 
 endfunction
 
diff --git a/scripts/audio/mu2lin.m b/scripts/audio/mu2lin.m
--- a/scripts/audio/mu2lin.m
+++ b/scripts/audio/mu2lin.m
@@ -64,17 +64,17 @@ function y = mu2lin (x, n = 0)
   ## Set the shape of y to that of x overwrites the contents of y with
   ## ulaw of x.
   y = x;
   y(:) = ulaw(x + 1);
 
   ## Convert to real or 8-bit.
   if (n == 0)
     ## [ -32768, 32767 ] -> [ -1, 1)
-    y = y/32768;
+    y /= 32768;
   elseif (n == 8)
     ld = max (abs (y (:)));
     if (ld < 16384 && ld > 0)
       sc = 64 / ld;
     else
       sc = 1 / 256;
     endif
     y = fix (y * sc);
diff --git a/scripts/elfun/cosd.m b/scripts/elfun/cosd.m
--- a/scripts/elfun/cosd.m
+++ b/scripts/elfun/cosd.m
@@ -29,17 +29,17 @@
 function y = cosd (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   I = x / 180;
   y = cos (I .* pi);
-  I = I + 0.5;
+  I += 0.5;
   y(I == fix (I) & isfinite (I)) = 0;
 
 endfunction
 
 
 %!assert (cosd (0:10:80), cos (pi*[0:10:80]/180), -10*eps)
 %!assert (cosd ([0, 180, 360]) != 0)
 %!assert (cosd ([90, 270]) == 0)
diff --git a/scripts/general/del2.m b/scripts/general/del2.m
--- a/scripts/general/del2.m
+++ b/scripts/general/del2.m
@@ -151,17 +151,17 @@ function D = del2 (M, varargin)
             dx{i}(sz(i) - 2) * DD(idx2{:}) - ...
             dx{i}(sz(i) - 1) / dx{i}(sz(i) - 2) * DD(idx3{:});
       endif
 
       D += DD;
     endif
   endfor
 
-  D = D ./ nd;
+  D ./= nd;
 endfunction
 
 
 ## 3x3 constant test
 %!test
 %! a = ones (3,3);
 %! b = del2 (a);
 %! assert (b(:,1), [0.00;0.00;0.00]);
diff --git a/scripts/general/profexplore.m b/scripts/general/profexplore.m
--- a/scripts/general/profexplore.m
+++ b/scripts/general/profexplore.m
@@ -100,17 +100,17 @@ function rv = __profexplore_worker (fcn_
         newPrefix = sprintf ("%s  ", prefix);
 
         rv = __profexplore_worker (fcn_table, tree(option).Children, ...
                                    newParents, newPrefix);
 
         if (rv == 0)
           return;
         elseif (rv > 1)
-          rv = rv - 1;
+          rv -= 1;
           return;
         else
           assert (rv == 1);
           ## It was requested to return to this level, so just stay.
         endif
       endif
     elseif (length (cmd) >= 2 && strcmp (substr (cmd, 1, 2), "up"))
       if (length (cmd) == 2)
diff --git a/scripts/general/quadl.m b/scripts/general/quadl.m
--- a/scripts/general/quadl.m
+++ b/scripts/general/quadl.m
@@ -128,17 +128,17 @@ function q = quadl (f, a, b, tol = [], t
   erri1 = abs (i1-is);
   erri2 = abs (i2-is);
   if (erri2 != 0)
     R = erri1/erri2;
   else
     R = 1;
   endif
   if (R > 0 && R < 1)
-    tol = tol/R;
+    tol /= R;
   endif
   is = s * abs (is) * tol/myeps;
   if (is == 0)
     is = b-a;
   endif
 
   q = adaptlobstp (f, a, b, fa, fb, is, trace, varargin{:});
 
diff --git a/scripts/general/rat.m b/scripts/general/rat.m
--- a/scripts/general/rat.m
+++ b/scripts/general/rat.m
@@ -97,17 +97,17 @@ function [n,d] = rat (x,tol)
     n(idx) = n(idx).*step + lastn(idx);
     d(idx) = d(idx).*step + lastd(idx);
     lastn = nextn;
     lastd = nextd;
   endwhile
 
   if (nargout == 2)
     ## Move the minus sign to the top.
-    n = n .* sign (d);
+    n .*= sign (d);
     d = abs (d);
 
     ## Return the same shape as you receive.
     n = reshape (n, size (x));
     d = reshape (d, size (x));
 
     ## Use 1/0 for Inf.
     n(isinf (x)) = sign (x(isinf (x)));
diff --git a/scripts/general/rotdim.m b/scripts/general/rotdim.m
--- a/scripts/general/rotdim.m
+++ b/scripts/general/rotdim.m
@@ -73,17 +73,17 @@ function y = rotdim (x, n, plane)
   nd = ndims (x);
   sz = size (x);
   if (nargin < 3)
     if (nd > 2)
       ## Find the first two non-singleton dimension.
       plane = [];
       dim = 0;
       while (dim < nd)
-        dim = dim + 1;
+        dim += 1;
         if (sz (dim) != 1)
           plane = [plane, dim];
           if (length (plane) == 2)
             break;
           endif
         endif
       endwhile
       if (length (plane) < 1)
@@ -99,17 +99,17 @@ function y = rotdim (x, n, plane)
            && all (plane == fix (plane)) && all (plane > 0)
            && all (plane < (nd + 1)) && plane(1) != plane(2)))
       error ("rotdim: PLANE must be a 2 element integer vector defining a valid PLANE");
     endif
   endif
 
   n = rem (n, 4);
   if (n < 0)
-    n = n + 4;
+    n += 4;
   endif
   if (n == 0)
     y = x;
   elseif (n == 2)
     y = flip (flip (x, plane(1)), plane(2));
   elseif (n == 1 || n == 3)
     perm = 1:nd;
     perm(plane(1)) = plane(2);
diff --git a/scripts/help/get_first_help_sentence.m b/scripts/help/get_first_help_sentence.m
--- a/scripts/help/get_first_help_sentence.m
+++ b/scripts/help/get_first_help_sentence.m
@@ -112,19 +112,19 @@ function [text, status] = first_sentence
         endl = numel (keep);
       endif
       keep(def_idx(k):endl) = false;
     endfor
 
     ## Remove the @end ... that corresponds to the @def we removed above
     def1 = def_idx(1);
     space_idx = find (help_text == " ");
-    space_idx = space_idx (find (space_idx > def1, 1));
+    space_idx = space_idx(find (space_idx > def1, 1));
     bracket_idx = find (help_text == "{" | help_text == "}");
-    bracket_idx = bracket_idx (find (bracket_idx > def1, 1));
+    bracket_idx = bracket_idx(find (bracket_idx > def1, 1));
     if (isempty (space_idx) && isempty (bracket_idx))
       error ("get_first_help_sentence: couldn't parse texinfo");
     endif
     sep_idx = min (space_idx, bracket_idx);
     def_type = help_text(def1+1:sep_idx-1);
 
     end_idx = strfind (help_text, sprintf ("@end %s", def_type));
     if (isempty (end_idx))
diff --git a/scripts/help/private/__strip_html_tags__.m b/scripts/help/private/__strip_html_tags__.m
--- a/scripts/help/private/__strip_html_tags__.m
+++ b/scripts/help/private/__strip_html_tags__.m
@@ -72,11 +72,11 @@ function text = strip_superfluous_endlin
   idx = find (groups (:, 2) >= 3);
   for k = 1:length (idx)
     start = groups(idx(k), 1);
     stop = start + groups(idx(k), 2) - 1;
     keep(start+2:stop) = false;
   endfor
 
   ## Actually remove the elements
-  text = text (keep);
+  text = text(keep);
 endfunction
 
diff --git a/scripts/image/cubehelix.m b/scripts/image/cubehelix.m
--- a/scripts/image/cubehelix.m
+++ b/scripts/image/cubehelix.m
@@ -57,17 +57,17 @@ function map = cubehelix (n = rows (colo
   n = double (n);
 
   if (n > 1)
     coeff = [ -0.14861  -0.29227   1.97294
                1.78277  -0.90649   0.00000];
 
     fract = ((0:n-1) / (n-1))';
     angle = 2 * pi * (start/3 + 1 + rots*fract);
-    fract = fract .^ gamma;
+    fract .^= gamma;
     amp   = hue * fract .* (1-fract) /2;
     map   = fract + amp .* ([cos(angle) sin(angle)] * coeff);
 
     ## Clip values (only in case users have changed values of hue or gamma)
     map(map < 0) = 0;
     map(map > 1) = 1;
 
   elseif (n > 0)
diff --git a/scripts/io/textread.m b/scripts/io/textread.m
--- a/scripts/io/textread.m
+++ b/scripts/io/textread.m
@@ -92,17 +92,16 @@ function varargout = textread (filename,
       error ("missing or illegal value for 'headerlines'" );
     endif
     ## Avoid conveying floats to fskipl
     varargin{headerlines + 1} = round (varargin{headerlines + 1});
     ## Beware of zero valued headerline, fskipl would skip to EOF
     if (varargin{headerlines + 1} > 0)
       fskipl (fid, varargin{headerlines + 1});
       varargin(headerlines:headerlines+1) = [];
-      nargin = nargin - 2;
     elseif (varargin{headerlines + 1} < 0)
       warning ("textread: negative headerline value ignored");
     endif
   endif
   st_pos = ftell (fid);
 
   ## Read a first file chunk. Rest follows after endofline processing
   [str, count] = fscanf (fid, "%c", BUFLENGTH);
diff --git a/scripts/linear-algebra/duplication_matrix.m b/scripts/linear-algebra/duplication_matrix.m
--- a/scripts/linear-algebra/duplication_matrix.m
+++ b/scripts/linear-algebra/duplication_matrix.m
@@ -77,17 +77,17 @@ function d = duplication_matrix (n)
   ## It is clearly possible to make this a LOT faster!
   count = 0;
   for j = 1 : n
     d((j - 1) * n + j, count + j) = 1;
     for i = (j + 1) : n
       d((j - 1) * n + i, count + i) = 1;
       d((i - 1) * n + j, count + i) = 1;
     endfor
-    count = count + n - j;
+    count += n - j;
   endfor
 
 endfunction
 
 
 %!test
 %! N = 2;
 %! A = rand (N);
diff --git a/scripts/linear-algebra/housh.m b/scripts/linear-algebra/housh.m
--- a/scripts/linear-algebra/housh.m
+++ b/scripts/linear-algebra/housh.m
@@ -67,17 +67,17 @@ function [housv, beta, zer] = housh (x, 
   if (! isvector (x) && ! isscalar (x))
     error ("housh: first input must be a vector");
   elseif (! isscalar (j))
     error ("housh: second argment must be an integer scalar");
   else
     housv = x;
     m = max (abs (housv));
     if (m != 0.0)
-      housv = housv / m;
+      housv /= m;
       alpha = norm (housv);
       if (alpha > z)
         beta = 1.0 / (alpha * (alpha + abs (housv(j))));
         sg = sign (housv(j));
         if (sg == 0)
           sg = 1;
         endif
         housv(j) = housv(j) + alpha*sg;
diff --git a/scripts/linear-algebra/krylov.m b/scripts/linear-algebra/krylov.m
--- a/scripts/linear-algebra/krylov.m
+++ b/scripts/linear-algebra/krylov.m
@@ -204,17 +204,17 @@ function [Uret, H, nu] = krylov (A, V, k
 
     ## Multiply to get new vector.
     V = A*Q;
     ## Project off of previous vectors.
     nu = length (alpha);
     for i = 1:nu
       hv = U(:,i);
       av = alpha(i);
-      V = V - av*hv*(hv'*V);
+      V -= av*hv*(hv'*V);
       H(i,nu-columns(V)+(1:columns(V))) = V(pivot_vec(i),:);
     endfor
 
   endwhile
 
   ## Back out complete U matrix.
   ## back out U matrix.
   j1 = columns (U);
diff --git a/scripts/linear-algebra/logm.m b/scripts/linear-algebra/logm.m
--- a/scripts/linear-algebra/logm.m
+++ b/scripts/linear-algebra/logm.m
@@ -81,33 +81,33 @@ function [s, iters] = logm (A, opt_iters
   k = 0;
   ## Algorithm 11.9 in "Function of matrices", by N. Higham
   theta = [0, 0, 1.61e-2, 5.38e-2, 1.13e-1, 1.86e-1, 2.6429608311114350e-1];
   p = 0;
   m = 7;
   while (k < opt_iters)
     tau = norm (s - eye (size (s)),1);
     if (tau <= theta (7))
-      p = p + 1;
+      p += 1;
       j(1) = find (tau <= theta, 1);
       j(2) = find (tau / 2 <= theta, 1);
       if (j(1) - j(2) <= 1 || p == 2)
         m = j(1);
         break
       endif
     endif
-    k = k + 1;
+    k += 1;
     s = sqrtm (s);
   endwhile
 
   if (k >= opt_iters)
     warning ("logm: maximum number of square roots exceeded; results may still be accurate");
   endif
 
-  s = s - eye (size (s));
+  s -= eye (size (s));
 
   if (m > 1)
     s = logm_pade_pf (s, m);
   endif
 
   s = 2^k * u * s * u';
 
   ## Remove small complex values (O(eps)) which may have entered calculation
@@ -131,17 +131,17 @@ endfunction
 ##LOGM_PADE_PF   Evaluate Pade approximant to matrix log by partial fractions.
 ##   Y = LOGM_PADE_PF(A,M) evaluates the [M/M] Pade approximation to
 ##   LOG(EYE(SIZE(A))+A) using a partial fraction expansion.
 
 function s = logm_pade_pf (A, m)
   [nodes, wts] = gauss_legendre (m);
   ## Convert from [-1,1] to [0,1].
   nodes = (nodes+1)/2;
-  wts = wts/2;
+  wts /= 2;
 
   n = length (A);
   s = zeros (n);
   for j = 1:m
     s += wts(j)*(A/(eye (n) + nodes(j)*A));
   endfor
 endfunction
 
diff --git a/scripts/linear-algebra/normest.m b/scripts/linear-algebra/normest.m
--- a/scripts/linear-algebra/normest.m
+++ b/scripts/linear-algebra/normest.m
@@ -63,17 +63,17 @@ function [n, c] = normest (A, tol = 1e-6
   n = 0;
   do
     n0 = n;
     x = A * y;
     normx = norm (x);
     if (normx == 0)
       x = rand (ncols, 1);
     else
-      x = x / normx;
+      x /= normx;
     endif
     y = A' * x;
     n = norm (y);
     c += 1;
   until (abs (n - n0) <= tol * n)
 
   rand ("state", v);    # restore state of random number generator
 endfunction
diff --git a/scripts/linear-algebra/onenormest.m b/scripts/linear-algebra/onenormest.m
--- a/scripts/linear-algebra/onenormest.m
+++ b/scripts/linear-algebra/onenormest.m
@@ -128,17 +128,17 @@ function [est, v, w, iter] = onenormest 
     else
       t = default_t;
     endif
     issing = isa (n, "single");
   endif
 
   ## Initial test vectors X.
   X = rand (n, t);
-  X = X ./ (ones (n,1) * sum (abs (X), 1));
+  X ./= ones (n,1) * sum (abs (X), 1);
 
   ## Track if a vertex has been visited.
   been_there = zeros (n, 1);
 
   ## To check if the estimate has increased.
   est_old = 0;
 
   ## Normalized vector of signs.
diff --git a/scripts/optimization/fminsearch.m b/scripts/optimization/fminsearch.m
--- a/scripts/optimization/fminsearch.m
+++ b/scripts/optimization/fminsearch.m
@@ -260,55 +260,55 @@ function [x, fmax, nf] = nmsmax (fun, x,
     ##  NJH: Altered function calls and changed CNT to NF.
     ##       Changed each 'fr < f(1)' type test to '>' for maximization
     ##       and re-ordered function values after sort.
 
     vbar = (sum (V(:,1:n)')/n)';  # Mean value
     vr = (1 + alpha)*vbar - alpha*V(:,n+1);
     x(:) = vr;
     fr = dirn * feval (fun,x,varargin{:});
-    nf = nf + 1;
+    nf += 1;
     vk = vr;  fk = fr; how = "reflect, ";
     if (fr > f(n))
       if (fr > f(1))
         ve = gamma*vr + (1-gamma)*vbar;
         x(:) = ve;
         fe = dirn * feval (fun,x,varargin{:});
-        nf = nf + 1;
+        nf += 1;
         if (fe > f(1))
           vk = ve;
           fk = fe;
           how = "expand,  ";
         endif
       endif
     else
       vt = V(:,n+1);
       ft = f(n+1);
       if (fr > ft)
         vt = vr;
         ft = fr;
       endif
       vc = beta*vt + (1-beta)*vbar;
       x(:) = vc;
       fc = dirn * feval (fun,x,varargin{:});
-      nf = nf + 1;
+      nf += 1;
       if (fc > f(n))
         vk = vc; fk = fc;
         how = "contract,";
       else
         for j = 2:n
           V(:,j) = (V(:,1) + V(:,j))/2;
           x(:) = V(:,j);
           f(j) = dirn * feval (fun,x,varargin{:});
         endfor
-        nf = nf + n-1;
+        nf += n-1;
         vk = (V(:,1) + V(:,n+1))/2;
         x(:) = vk;
         fk = dirn * feval (fun,x,varargin{:});
-        nf = nf + 1;
+        nf += 1;
         how = "shrink,  ";
       endif
     endif
     V(:,n+1) = vk;
     f(n+1) = fk;
     [~,j] = sort(f);
     j = j(n+1:-1:1);
     f = f(j);
diff --git a/scripts/optimization/lsqnonneg.m b/scripts/optimization/lsqnonneg.m
--- a/scripts/optimization/lsqnonneg.m
+++ b/scripts/optimization/lsqnonneg.m
@@ -139,17 +139,17 @@ function [x, resnorm, residual, exitflag
         sf = x(pidx)./(x(pidx) - xtmp(idx));
         alpha = min (sf);
         ## LH10: adjust X.
         xx = zeros (n, 1);
         xx(p) = xtmp;
         x += alpha*(xx - x);
         ## LH11: move from P to Z all X == 0.
         ## This corresponds to those indices where minimum of sf is attained.
-        idx = idx (sf == alpha);
+        idx = idx(sf == alpha);
         p(idx) = [];
         if (useqr)
           ## update the QR factorization.
           [q, r] = qrdelete (q, r, idx);
         endif
       endif
     endwhile
 
diff --git a/scripts/optimization/qp.m b/scripts/optimization/qp.m
--- a/scripts/optimization/qp.m
+++ b/scripts/optimization/qp.m
@@ -232,23 +232,23 @@ function [x, obj, INFO, lambda] = qp (x0
         rtol = sqrt (eps);
         for i = 1:n
           if (abs (lb (i) - ub(i)) < rtol*(1 + max (abs (lb(i) + ub(i)))))
             ## These are actually an equality constraint
             tmprow = zeros (1,n);
             tmprow(i) = 1;
             A = [A;tmprow];
             b = [b; 0.5*(lb(i) + ub(i))];
-            n_eq = n_eq + 1;
+            n_eq += 1;
           else
             tmprow = zeros (1,n);
             tmprow(i) = 1;
             Ain = [Ain; tmprow; -tmprow];
             bin = [bin; lb(i); -ub(i)];
-            n_in = n_in + 2;
+            n_in += 2;
           endif
         endfor
       endif
     endif
 
     ## Inequality constraints
     if (nargs > 7)
       [dimA_in, n1] = size (A_in);
@@ -276,22 +276,22 @@ function [x, obj, INFO, lambda] = qp (x0
           rtol = sqrt (eps);
           for i = 1:dimA_in
             if (abs (A_lb(i) - A_ub(i))
                 < rtol*(1 + max (abs (A_lb(i) + A_ub(i)))))
               ## These are actually an equality constraint
               tmprow = A_in(i,:);
               A = [A;tmprow];
               b = [b; 0.5*(A_lb(i) + A_ub(i))];
-              n_eq = n_eq + 1;
+              n_eq += 1;
             else
               tmprow = A_in(i,:);
               Ain = [Ain; tmprow; -tmprow];
               bin = [bin; A_lb(i); -A_ub(i)];
-              n_in = n_in + 2;
+              n_in += 2;
             endif
           endfor
         endif
       endif
     endif
 
     ## Now we should have the following QP:
     ##
diff --git a/scripts/plot/appearance/annotation.m b/scripts/plot/appearance/annotation.m
--- a/scripts/plot/appearance/annotation.m
+++ b/scripts/plot/appearance/annotation.m
@@ -1091,17 +1091,17 @@ function XY = textcoordinates (hte, pos)
   ##  2-----3-----4
 
   ## FIXME: Matlab's horizontal/verticalalignment properties are
   ## interpreted differently: horizontalalignment is passed to the
   ## underlying text object whereas the verticalalignement controls
   ## the vertical alignment of the arrow.
 
   ang = angle (complex (pos(3), pos(4)));
-  rot = rot / 180 * pi;
+  rot *= pi / 180;
 
   [~, pt] = min (abs ((-pi:pi/4:pi) - ang));
   pt -= floor (rot / (pi/4));
   if (pt <= 0)
     pt = rem (pt, 8) + 8;
   elseif (pt > 8)
     pt = rem (pt, 8);
   endif
diff --git a/scripts/plot/appearance/axis.m b/scripts/plot/appearance/axis.m
--- a/scripts/plot/appearance/axis.m
+++ b/scripts/plot/appearance/axis.m
@@ -370,33 +370,33 @@ function lims = __get_tight_lims__ (ca, 
 endfunction
 
 function __do_tight_option__ (ca)
 
   xlim = __get_tight_lims__ (ca, "x");
   if (all (xlim == 0))
     xlim = eps () * [-1 1];
   elseif (diff (xlim == 0))
-    xlim = xlim .* (1 + eps () * [-1, 1]);
+    xlim .*= (1 + eps () * [-1, 1]);
   endif
   ylim = __get_tight_lims__ (ca, "y");
   if (all (ylim == 0))
     ylim = eps () * [-1 1];
   elseif (diff (ylim == 0))
-    ylim = ylim .* (1 + eps () * [-1, 1]);
+    ylim .*= (1 + eps () * [-1, 1]);
   endif
   set (ca, "xlim", xlim, "ylim", ylim)
   nd = __calc_dimensions__ (ca);
   is3dview = (get (ca, "view")(2) != 90);
   if (nd > 2 && is3dview)
     zlim = __get_tight_lims__ (ca, "z");
     if (all (zlim == 0))
       zlim = eps () * [-1 1];
     elseif (diff (zlim == 0))
-      zlim = zlim .* (1 + eps () * [-1, 1]);
+      zlim .*= (1 + eps () * [-1, 1]);
     endif
     set (ca, "zlim", zlim);
   endif
 
 endfunction
 
 
 %!demo
diff --git a/scripts/plot/appearance/legend.m b/scripts/plot/appearance/legend.m
--- a/scripts/plot/appearance/legend.m
+++ b/scripts/plot/appearance/legend.m
@@ -710,17 +710,17 @@ function [hleg, hleg_obj, hplot, labels]
           else
             gnuplot_offset = unmodified_axes_position(1) ...
                            - unmodified_axes_outerposition(1);
           endif
           ## FIXME: The "fontsize" is added to match the behavior of OpenGL.
           ## This implies that a change in fontsize should trigger a listener
           ## to update the legend.  The "2" was determined using a long legend
           ## key in the absence of any subplots.
-          gnuplot_offset = gnuplot_offset - 2 * fontsize;
+          gnuplot_offset -= 2 * fontsize;
         else
           gnuplot_offset = 0;
         endif
 
         ## For legend's outside the associated axes postion,
         ## align their edge to the unmodified_axes_outerpostion,
         ## and adjust the axes postion accordingly.
         switch (location)
diff --git a/scripts/plot/appearance/specular.m b/scripts/plot/appearance/specular.m
--- a/scripts/plot/appearance/specular.m
+++ b/scripts/plot/appearance/specular.m
@@ -83,12 +83,12 @@ function retval = specular (sx, sy, sz, 
   ## Calculate specular reflection using Phong's approximation
   retval = 2 * l_dot_n .* v_dot_n - dot (lv, vv);
 
   ## Set reflectance to zero if light is on the other side
   retval(l_dot_n < 0) = 0;
 
   ## Allow postive values only
   retval(retval < 0) = 0;
-  retval = retval .^ se;
+  retval .^= se;
 
 endfunction
 
diff --git a/scripts/plot/draw/colorbar.m b/scripts/plot/draw/colorbar.m
--- a/scripts/plot/draw/colorbar.m
+++ b/scripts/plot/draw/colorbar.m
@@ -393,58 +393,58 @@ function [pos, cpos, vertical, mirr] = _
     endif
   else
     off = 0.0;
   endif
 
   switch (cbox)
     case "northoutside"
       origin = pos(1:2) + [0., 0.9] .* sz + [1, -1] .* off;
-      sz = sz .* [1.0, 0.06];
+      sz .*= [1.0, 0.06];
       pos(4) = 0.8 * pos(4);
       mirr = true;
       vertical = false;
     case "north"
       origin = pos(1:2) + [0.05, 0.9] .* sz + [1, -1] .* off;
-      sz = sz .* [1.0, 0.06] * 0.9;
+      sz .*= [1.0, 0.06] * 0.9;
       mirr = false;
       vertical = false;
     case "southoutside"
       origin = pos(1:2) + off;
-      sz = sz .* [1.0, 0.06];
+      sz .*= [1.0, 0.06];
       pos(2) = pos(2) + pos(4) * 0.2;
       pos(4) = 0.8 * pos(4);
       mirr = false;
       vertical = false;
     case "south"
       origin = pos(1:2) + [0.05, 0.05] .* sz + off;
-      sz = sz .* [1.0, 0.06] * 0.9;
+      sz .*= [1.0, 0.06] * 0.9;
       mirr = true;
       vertical = false;
     case "eastoutside"
       origin = pos(1:2) + [0.9, 0] .* sz + [-1, 1] .* off;
-      sz = sz .* [0.06, 1.0];
+      sz .*= [0.06, 1.0];
       pos(3) = 0.8 * pos(3);
       mirr = true;
       vertical = true;
     case "east"
       origin = pos(1:2) + [0.9, 0.05] .* sz + [-1, 1] .* off;
-      sz = sz .* [0.06, 1.0] * 0.9;
+      sz .*= [0.06, 1.0] * 0.9;
       mirr = false;
       vertical = true;
     case "westoutside"
       origin = pos(1:2) + off;
-      sz = sz .* [0.06, 1.0];
+      sz .*= [0.06, 1.0];
       pos(1) = pos(1) + pos(3) * 0.2;
       pos(3) = 0.8 * pos(3);
       mirr = false;
       vertical = true;
     case "west"
       origin = pos(1:2) + [0.05, 0.05] .* sz + off;
-      sz = sz .* [0.06, 1.0] .* 0.9;
+      sz .*= [0.06, 1.0] .* 0.9;
       mirr = true;
       vertical = true;
   endswitch
 
   cpos = [origin, sz];
 
   if (strcmp (obj.plotboxaspectratiomode, "manual")
       || strcmp (obj.dataaspectratiomode, "manual"))
diff --git a/scripts/plot/draw/hist.m b/scripts/plot/draw/hist.m
--- a/scripts/plot/draw/hist.m
+++ b/scripts/plot/draw/hist.m
@@ -96,27 +96,27 @@ function [nn, xx] = hist (varargin)
 
   max_val = max (y(:));
   min_val = min (y(:));
 
   iarg = 1;
   if (nargin == 1 || ischar (varargin{iarg}))
     n = 10;
     x = [0.5:n]'/n;
-    x = x * (max_val - min_val) + ones (size (x)) * min_val;
+    x = (max_val - min_val) * x + min_val * ones (size (x));
   else
     ## nargin is either 2 or 3
     x = varargin{iarg++};
     if (isscalar (x))
       n = x;
       if (n <= 0)
         error ("hist: number of bins NBINS must be positive");
       endif
       x = [0.5:n]'/n;
-      x = x * (max_val - min_val) + ones (size (x)) * min_val;
+      x = (max_val - min_val) * x  + min_val * ones (size (x));
     elseif (isreal (x))
       if (isvector (x))
         x = x(:);
       endif
       xsort = sort (x);
       if (any (xsort != x))
         warning ("hist: bin values not sorted on input");
         x = xsort;
diff --git a/scripts/plot/draw/plotmatrix.m b/scripts/plot/draw/plotmatrix.m
--- a/scripts/plot/draw/plotmatrix.m
+++ b/scripts/plot/draw/plotmatrix.m
@@ -133,17 +133,17 @@ function [h, ax, p, pax] = __plotmatrix_
   for i = 1 : nargin - 1
     arg = varargin{i};
     if (ischar (arg) || iscellstr (arg))
       [linespec, valid] = __pltopt__ ("plotmatrix", varargin{i}, false);
       if (valid)
         have_line_spec = true;
         linespec = varargin(i);
         varargin(i) = [];
-        nargin = nargin - 1;
+        nargin -= 1;
         break;
       else
         print_usage ("plotmatrix");
       endif
     endif
   endfor
 
   if (nargin == 2)
diff --git a/scripts/plot/draw/private/__stem__.m b/scripts/plot/draw/private/__stem__.m
--- a/scripts/plot/draw/private/__stem__.m
+++ b/scripts/plot/draw/private/__stem__.m
@@ -187,17 +187,17 @@ endfunction
 
 function [x, y, z, dofill, lc, ls, mc, ms, args] = check_stem_arg (have_z, varargin)
 
   if (have_z)
     caller = "stem3";
   else
     caller = "stem";
   endif
-  nargin = nargin - 1;  # account for have_z argument
+  nargin = nargin () - 1;  # account for have_z argument
 
   num_numeric = find (cellfun ("isclass", varargin, "char"), 1) - 1;
   if (isempty (num_numeric))
     num_numeric = nargin;
   endif
 
   if (num_numeric < 1 || num_numeric > 3)
     print_usage (caller);
diff --git a/scripts/plot/util/__actual_axis_position__.m b/scripts/plot/util/__actual_axis_position__.m
--- a/scripts/plot/util/__actual_axis_position__.m
+++ b/scripts/plot/util/__actual_axis_position__.m
@@ -62,23 +62,23 @@ function pos = __actual_axis_position__ 
     else
       ## FIXME: This works for "axis square", but has not been
       ##        thoroughly tested for other aspect ratios.
       aspect_ratio_2d = [max(axis_obj.plotboxaspectratio(1:2)), ...
                              axis_obj.plotboxaspectratio(3)/sqrt(2)];
     endif
     orig_aspect_ratio_2d = pos_in_pixels(3:4);
     rel_aspect_ratio_2d = aspect_ratio_2d ./ orig_aspect_ratio_2d;
-    rel_aspect_ratio_2d = rel_aspect_ratio_2d ./ max (rel_aspect_ratio_2d);
+    rel_aspect_ratio_2d ./= max (rel_aspect_ratio_2d);
     if (rel_aspect_ratio_2d(1) < rel_aspect_ratio_2d(2));
       dx = (1.0 - rel_aspect_ratio_2d(1)) * pos_in_pixels(3);
-      pos_in_pixels = pos_in_pixels + dx*[0.5, 0.0, -1.0, 0.0];
+      pos_in_pixels += dx*[0.5, 0.0, -1.0, 0.0];
     elseif (rel_aspect_ratio_2d(1) > rel_aspect_ratio_2d(2))
       dy = (1.0 - rel_aspect_ratio_2d(2)) * pos_in_pixels(4);
-      pos_in_pixels = pos_in_pixels + dy*[0.0, 0.5, 0.0, -1.0];
+      pos_in_pixels += dy*[0.0, 0.5, 0.0, -1.0];
     endif
     pos = pos_in_pixels ./ fig_position([3, 4, 3, 4]);
   elseif (strcmp (get (axis_obj.parent, "__graphics_toolkit__"), "gnuplot")
           && strcmp (axis_obj.activepositionproperty, "outerposition"))
     pos = axis_obj.outerposition;
   else
     pos = axis_obj.position;
   endif
diff --git a/scripts/plot/util/__gnuplot_drawnow__.m b/scripts/plot/util/__gnuplot_drawnow__.m
--- a/scripts/plot/util/__gnuplot_drawnow__.m
+++ b/scripts/plot/util/__gnuplot_drawnow__.m
@@ -180,18 +180,18 @@ function enhanced = gnuplot_set_term (pl
           set (h, "units", units);
         end_unwind_protect
         gnuplot_pos = position_in_pixels(1:2);
         gnuplot_size = position_in_pixels(3:4);
         if (! (output_to_screen (term)
                || any (strcmp (term, {"canvas", "emf", "gif", "jpeg", ...
                                       "pbm", "png", "pngcairo", "svg"}))))
           ## Convert to inches
-          gnuplot_pos = gnuplot_pos / 72;
-          gnuplot_size = gnuplot_size / 72;
+          gnuplot_pos /= 72;
+          gnuplot_size /= 72;
         endif
         if (all (gnuplot_size > 0))
           terminals_with_size = {"canvas", "emf", "epslatex", "fig", ...
                                  "gif", "jpeg", "latex", "pbm", "pdf", ...
                                  "pdfcairo", "postscript", "png", ...
                                  "pngcairo", "pstex", "pslatex", "svg", "tikz"};
           if (__gnuplot_has_feature__ ("windows_figure_position"))
             terminals_with_size{end+1} = "windows";
diff --git a/scripts/plot/util/findobj.m b/scripts/plot/util/findobj.m
--- a/scripts/plot/util/findobj.m
+++ b/scripts/plot/util/findobj.m
@@ -94,17 +94,17 @@ function h = findobj (varargin)
       ## Return [](0x1) for compatibility.
       h = zeros (0, 1);
       return;
     endif
     if (n1 <= nargin)
       if (ischar (varargin{n1}))
         if (strcmpi (varargin{n1}, "flat"))
           depth = 0;
-          n1 = n1 + 1;
+          n1 += 1;
         endif
       else
         error ("findobj: properties and options must be strings");
       endif
     endif
   endif
 
   if (n1 <= nargin && nargin > 0)
@@ -128,73 +128,73 @@ function h = findobj (varargin)
     property(np) = 0;
     if (numel (extranegation) < np)
       extranegation(np) = false;
     endif
     logicaloperator{np} = "and";
     if (ischar (args{na}))
       if (strcmpi (args{na}, "-property"))
         if (na + 1 <= numel (args))
-          na = na + 1;
+          na += 1;
           property(np) = 1;
           pname{np} = args{na};
-          na = na + 1;
+          na += 1;
           pvalue{np} = [];
-          np = np + 1;
+          np += 1;
         else
           error ("findobj: inconsistent number of arguments");
         endif
       elseif (strcmpi (args{na}, "-regexp"))
         if (na + 2 <= numel (args))
           regularexpression(np) = 1;
-          na = na + 1;
+          na += 1;
           pname{np} = args{na};
-          na = na + 1;
+          na += 1;
           pvalue{np} = args{na};
-          na = na + 1;
-          np = np + 1;
+          na += 1;
+          np += 1;
         else
           error ("findobj: inconsistent number of arguments");
         endif
       elseif (strcmpi (args{na}, "-depth"))
         if (na + 1 <= numel (args))
-          na = na + 1;
+          na += 1;
           depth = args{na};
-          na = na + 1;
+          na += 1;
         else
           error ("findobj: inconsistent number of arguments");
         endif
       elseif (! strcmp (args{na}(1), "-"))
         ## Parameter/value pairs.
         if (na + 1 <= numel (args))
           pname{np} = args{na};
-          na = na + 1;
+          na += 1;
           pvalue{np} = args{na};
-          na = na + 1;
+          na += 1;
           if (na <= numel (args))
             if (ischar (args{na}))
               if (any (strcmpi (args{na}, operatorprecedence)))
                 logicaloperator{np} = args{na}(2:end);
-                na = na+1;
+                na += 1;
               endif
             else
               error ("findobj: properties and options must be strings");
             endif
           else
             logicaloperator{np} = "and";
           endif
-          np = np + 1;
+          np += 1;
         else
           error ("findobj: inconsistent number of arguments");
         endif
       else
         if (strcmpi (args{na}, "-not"))
           extranegation(np) = true;
         endif
-        na = na + 1;
+        na += 1;
       endif
     else
       error ("findobj: properties and options must be strings");
     endif
   endwhile
 
   numpairs = np - 1;
   if (! isempty (logicaloperator))
@@ -206,17 +206,17 @@ function h = findobj (varargin)
   h = handles;
   while (numel (handles) && ! (idepth >= depth))
     children = [];
     for n = 1 : numel (handles)
       children = [children; get(handles(n), "children")];
     endfor
     handles = children;
     h = [h; children];
-    idepth = idepth + 1;
+    idepth += 1;
   endwhile
 
   if (numpairs > 0)
     match = true (numel (h), numpairs);
     for nh = 1 : numel (h)
       p = get (h(nh));
       for np = 1 : numpairs
         fields = fieldnames (p);
@@ -262,17 +262,17 @@ function h = findobj (varargin)
           if (no == 1)
             match(:,np+1) = ! match(:,np+1);
             logicaloperator(np+1) = {"and"};
           else
             match(:,np) = feval (logicaloperator{np+1}, match(:,np), ...
                                  match(:,np+1));
             logicaloperator(np+1) = [];
             match(:,np+1) = [];
-            numpairs = numpairs - 1;
+            numpairs -= 1;
           endif
           if (numpairs < 2)
             break;
           endif
         endfor
         if (numpairs < 2)
           break;
         endif
diff --git a/scripts/plot/util/print.m b/scripts/plot/util/print.m
--- a/scripts/plot/util/print.m
+++ b/scripts/plot/util/print.m
@@ -407,17 +407,17 @@ function print (varargin)
       if (! isempty (opts.fontsize))
         if (ischar (opts.fontsize))
           fontsize = str2double (opts.fontsize);
         else
           fontsize = opts.fontsize;
         endif
         if (! isempty (opts.scalefontsize) && ! opts.scalefontsize != 1)
           ## This is done to work around the bbox being whole numbers.
-          fontsize = fontsize * opts.scalefontsize;
+          fontsize *= opts.scalefontsize;
         endif
         ## FIXME: legend child objects need to be acted on first.
         ##        or legend fontsize callback will destroy them.
         hlist = h(ishandle (h));
         haxes = strcmp (get (hlist, "type"), "axes");
         set (hlist(! haxes), "fontsize", fontsize);
         set (hlist(haxes), "fontsize", fontsize);
       endif
diff --git a/scripts/plot/util/private/__go_draw_axes__.m b/scripts/plot/util/private/__go_draw_axes__.m
--- a/scripts/plot/util/private/__go_draw_axes__.m
+++ b/scripts/plot/util/private/__go_draw_axes__.m
@@ -409,17 +409,17 @@ function __go_draw_axes__ (h, plot_strea
 
   fputs (plot_stream, "set clip two;\n");
 
   kids = axis_obj.children;
   ## Remove the axis labels and title from the children, and
   ## preserved the original order.
   [jnk, k] = setdiff (kids, [axis_obj.xlabel; axis_obj.ylabel; ...
                              axis_obj.zlabel; axis_obj.title]);
-  kids = kids (sort (k));
+  kids = kids(sort (k));
 
   if (nd == 3)
     fputs (plot_stream, "set parametric;\n");
     fputs (plot_stream, "set style data lines;\n");
     fputs (plot_stream, "set surface;\n");
     fputs (plot_stream, "unset contour;\n");
   endif
 
@@ -1626,17 +1626,17 @@ function __go_draw_axes__ (h, plot_strea
              inout, pos, box, reverse, horzvert, fontspacespec, colorspec,
              __do_enhanced_option__ (enhanced, hlgnd));
   else
     fputs (plot_stream, "unset key;\n");
   endif
   fputs (plot_stream, "set style data lines;\n");
 
   cmap = [cmap; addedcmap];
-  cmap_sz = cmap_sz + rows (addedcmap);
+  cmap_sz += rows (addedcmap);
   if (mono == false && length (cmap) > 0)
     fprintf (plot_stream,
              "set palette positive color model RGB maxcolors %i;\n",
              cmap_sz);
     fprintf (plot_stream,
              "set palette file \"-\" binary record=%d using 1:2:3:4;\n",
              cmap_sz);
     fwrite (plot_stream, [1:cmap_sz; cmap.'], "float32");
@@ -2444,34 +2444,34 @@ function str = __tex2enhanced__ (str, fn
             if (li == si)
               break;
             endif
             li++;
           else
             si++;
           endif
         endwhile
-        l1 = l1 (min (length (l1), si));
+        l1 = l1(min (length (l1), si));
         if (s(i) + l1 + 1 == s(i+1))
           if (str(s(i + 1) + p + 1) == "{")
             s2 = strfind (str(s(i + 1) + p + 2:end),'{');
             si = 1;
             l2 = strfind (str(s(i + 1) + p + 1:end),'}');
             li = 1;
             while (li <= length (l2) && si <= length (s2))
               if (l2(li) < s2(si))
                 if (li == si)
                   break;
                 endif
                 li++;
               else
                 si++;
               endif
             endwhile
-            l2 = l2 (min (length (l2), si));
+            l2 = l2(min (length (l2), si));
             if (length_string (str(s(i)+p+2:s(i)+p+l1-1)) <=
                 length_string (str(s(i+1)+p+2:s(i+1)+p+l2-1)))
               ## Shortest already first!
               str = [str(1:s(i)+p-1) "@" str(s(i)+p:end)];
             else
               ## Have to swap sub/super-script to get shortest first.
               str = [str(1:s(i)+p-1), "@", str(s(i+1)+p:s(i+1)+p+l2), ...
                      str(s(i)+p:s(i)+p+l1), str(s(i+1)+p+l2+1:end)];
@@ -2502,17 +2502,17 @@ function str = __tex2enhanced__ (str, fn
   endwhile
 
 endfunction
 
 function l = length_string (s)
   l = length (s) - length (strfind (s,'{')) - length (strfind (s,'}'));
   m = regexp (s, '/([\w-]+|[\w-]+=\d+)', 'matches');
   if (! isempty (m))
-    l = l - sum (cellfun ("length", m));
+    l -= sum (cellfun ("length", m));
   endif
 endfunction
 
 function sym = __setup_sym_table__ ()
   ## Setup the translation table for TeX to gnuplot enhanced mode.
   sym.forall = '{/Symbol \042}';
   sym.exists = '{/Symbol \044}';
   sym.ni = '{/Symbol \047}';
diff --git a/scripts/plot/util/private/__print_parse_opts__.m b/scripts/plot/util/private/__print_parse_opts__.m
--- a/scripts/plot/util/private/__print_parse_opts__.m
+++ b/scripts/plot/util/private/__print_parse_opts__.m
@@ -490,17 +490,17 @@ function gs = __ghostscript_binary__ ()
       gs_binaries = [gs_binaries, {"gs", "gs.exe"}];
     else
       ## pc - Includes Win32 and mingw.
       gs_binaries = [gs_binaries, ...
                      {"gs.exe", "gswin32c.exe", "gswin64c.exe", "mgs.exe"}];
     endif
     n = 0;
     while (n < numel (gs_binaries) && isempty (ghostscript_binary))
-      n = n + 1;
+      n += 1;
       ghostscript_binary = file_in_path (getenv ("PATH"), gs_binaries{n});
     endwhile
     if (warn_on_no_ghostscript && isempty (ghostscript_binary))
       warning ("print:noghostscript",
                "print.m: ghostscript not found in PATH");
       warn_on_no_ghostscript = false;
     endif
   endif
@@ -524,17 +524,17 @@ function bin = __find_binary__ (binary)
       ## Unix - Includes Mac OSX and Cygwin.
       binaries = strcat (binary, {"", ".exe"});
     else
       ## pc - Includes Win32 and mingw.
       binaries = strcat (binary, {".exe"});
     endif
     n = 0;
     while (n < numel (binaries) && isempty (data.(binary).bin))
-      n = n + 1;
+      n += 1;
       data.(binary).bin = file_in_path (getenv ("PATH"), binaries{n});
     endwhile
     if (isempty (data.(binary).bin) && data.(binary).warn_on_absence)
       warning (sprintf ("print:no%s", binary),
                "print.m: '%s' not found in PATH", binary);
       data.(binary).warn_on_absence = false;
     endif
   endif
@@ -569,17 +569,17 @@ function [papersize, paperposition] = gs
   if (strcmp (papertype, "<custom>"))
     papersize = get (hfig, "papersize");
     papersize = convert2points (papersize , paperunits);
   else
     papersize = papersizes (strcmp (papertypes, papertype), :);
   endif
 
   if (strcmp (paperunits, "normalized"))
-    paperposition = paperposition .* papersize([1,2,1,2]);
+    paperposition .*= papersize([1,2,1,2]);
   else
     paperposition = convert2points (paperposition, paperunits);
   endif
 
   ## FIXME: This will be obsoleted by listeners for paper properties.
   ##        Papersize is tall when portrait,and wide when landscape.
   if ((papersize(1) > papersize(2) && strcmpi (paperorientation, "portrait"))
       || (papersize(1) < papersize(2) && strcmpi (paperorientation, "landscape")))
@@ -606,19 +606,19 @@ function [papersize, paperposition] = gs
     endif
   endif
 
 endfunction
 
 function value = convert2points (value, units)
   switch (units)
     case "inches"
-      value = value * 72;
+      value *= 72;
     case "centimeters"
-      value = value * 72 / 2.54;
+      value *= 72 / 2.54;
     case "normalized"
       error ("print:customnormalized",
              "print.m: papersize=='<custom>' and paperunits='normalized' may not be combined");
   endswitch
 endfunction
 
 function device_list = gs_device_list ();
   ## Graphics formats/languages, not printers.
diff --git a/scripts/plot/util/rotate.m b/scripts/plot/util/rotate.m
--- a/scripts/plot/util/rotate.m
+++ b/scripts/plot/util/rotate.m
@@ -106,17 +106,17 @@ function rotate (h, direction, alpha, or
       c = (zlim(1) + zlim(2)) / 2;
     else
       c = 0;
     endif
 
     origin = [a, b, c];
   endif
 
-  direction = direction / norm (direction);
+  direction /= norm (direction);
 
   u = direction(1);
   v = direction(2);
   w = direction(3);
 
   a = origin(1);
   b = origin(2);
   c = origin(3);
diff --git a/scripts/polynomial/pchip.m b/scripts/polynomial/pchip.m
--- a/scripts/polynomial/pchip.m
+++ b/scripts/polynomial/pchip.m
@@ -111,17 +111,17 @@ function ret = pchip (x, y, xi)
   ## This is taken from SLATEC.
   h = diag (h);
 
   delta = diff (y, 1, 2) / h;
   del1 = (d1 - delta) / h;
   del2 = (d2 - delta) / h;
   c3 = del1 + del2;
   c2 = -c3 - del1;
-  c3 = c3 / h;
+  c3 /= h;
   coeffs = cat (3, c3, c2, d1, f1);
 
   ret = mkpp (x, coeffs, szy(1:end-1));
 
   if (nargin == 3)
     ret = ppval (ret, xi);
   endif
 
diff --git a/scripts/polynomial/polyaffine.m b/scripts/polynomial/polyaffine.m
--- a/scripts/polynomial/polyaffine.m
+++ b/scripts/polynomial/polyaffine.m
@@ -51,17 +51,17 @@ function g = polyaffine (f, mu)
    if (rows (f) > 1)
       f = f.';
    endif
 
    g = f;
 
    ## Scale.
    if (mu(2) != 1)
-     g = g ./ (mu(2) .^ (lf-1:-1:0));
+     g ./= mu(2) .^ (lf-1:-1:0);
    endif
 
    ## Translate.
    if (mu(1) != 0)
      w = (-mu(1)) .^ (0:lf-1);
      ii = lf:-1:1;
      g = g(ii) * (toeplitz (w) .* pascal (lf, -1));
      g = g(ii);
diff --git a/scripts/polynomial/polyder.m b/scripts/polynomial/polyder.m
--- a/scripts/polynomial/polyder.m
+++ b/scripts/polynomial/polyder.m
@@ -64,18 +64,18 @@ function [q, d] = polyder (p, a)
         ## remove common factors from numerator and denominator
         x = polygcd (q, d);
         if (length (x) != 1)
           q = deconv (q, x);
           d = deconv (d, x);
         endif
 
         ## move all the gain into the numerator
-        q = q/d(1);
-        d = d/d(1);
+        q /= d(1);
+        d /= d(1);
       endif
     else
       lp = numel (p);
       if (lp == 1)
         q = 0;
         return;
       elseif (lp == 0)
         q = [];
diff --git a/scripts/polynomial/private/__splinefit__.m b/scripts/polynomial/private/__splinefit__.m
--- a/scripts/polynomial/private/__splinefit__.m
+++ b/scripts/polynomial/private/__splinefit__.m
@@ -146,17 +146,17 @@ if isempty(constr)
     % Solve Min norm(u*A-y)
     u = lsqsolve(A,y,beta);
 else
     % Evaluate constraints
     B = evalcon(base,constr,periodic);
     % Solve constraints
     [Z,u0] = solvecon(B,constr);
     % Solve Min norm(u*A-y), subject to u*B = yc
-    y = y - u0*A;
+    y -= u0*A;
     A = Z*A;
     v = lsqsolve(A,y,beta);
     u = u0 + v*Z;
 end
 
 % Periodic expansion of solution
 if periodic
     jj = mod(0:pieces+n-2,pieces) + 1;
@@ -482,17 +482,17 @@ end
 % Scale coefficients
 scale = ones(size(H));
 for k = 1:n-1
     scale = scale./H;
     coefs(:,n-k) = scale.*coefs(:,n-k);
 end
 
 % Reduce number of pieces
-pieces = pieces - 2*deg;
+pieces -= 2*deg;
 
 % Sort coefficients by interval number
 ii = [n*(1:pieces); deg*ones(deg,pieces)];
 ii = cumsum(ii,1);
 coefs = coefs(ii(:),:);
 
 % Make piecewise polynomial
 pp = mkpp(breaks0,coefs,n);
@@ -512,17 +512,17 @@ cc = constr.cc;
 % Bin data
 [junk,ibin] = histc(xc,[-inf,breaks(2:end-1),inf]); %#ok
 
 % Evaluate constraints
 nx = numel(xc);
 B0 = zeros(n,nx);
 for k = 1:size(cc,1)
     if any(cc(k,:))
-        B0 = B0 + repmat(cc(k,:),n,1).*ppval(base,xc);
+        B0 += repmat(cc(k,:),n,1).*ppval(base,xc);
     end
     % Differentiate base
     coefs = base.coefs(:,1:n-k);
     for j = 1:n-k-1
         coefs(:,j) = (n-k-j+1)*coefs(:,j);
     end
     base.coefs = coefs;
     base.order = n-k;
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -165,18 +165,18 @@ function [r, p, k, e] = residue (b, a, v
     return;
   endif
 
   ## Make sure both polynomials are in reduced form.
 
   a = polyreduce (a);
   b = polyreduce (b);
 
-  b = b / a(1);
-  a = a / a(1);
+  b /= a(1);
+  a /= a(1);
 
   la = length (a);
   lb = length (b);
 
   ## Handle special cases here.
 
   if (la == 0 || lb == 0)
     k = r = p = e = [];
@@ -324,23 +324,23 @@ function [pnum, pden, e] = rresidue (r, 
       if (m == 1)
         pm = p1;
       else
         pm = conv (pm, p1);
       endif
     endfor
     pn = deconv (pden, pm);
     pn = r(n) * pn;
-    pnum = pnum + prepad (pn, N+1, 0, 2);
+    pnum += prepad (pn, N+1, 0, 2);
   endfor
 
   ## Add the direct term.
 
   if (numel (k))
-    pnum = pnum + conv (pden, k);
+    pnum += conv (pden, k);
   endif
 
   ## Check for leading zeros and trim the polynomial coefficients.
   if (isa (r, "single") || isa (p, "single") || isa (k, "single"))
     small = max ([max(abs(pden)), max(abs(pnum)), 1]) * eps ("single");
   else
     small = max ([max(abs(pden)), max(abs(pnum)), 1]) * eps;
   endif
diff --git a/scripts/signal/arch_fit.m b/scripts/signal/arch_fit.m
--- a/scripts/signal/arch_fit.m
+++ b/scripts/signal/arch_fit.m
@@ -91,31 +91,31 @@ function [a, b] = arch_fit (y, x, p, ite
   esq = e.^2;
   Z = autoreg_matrix (esq, p);
 
   for i = 1 : iter;
     h   = Z * a;
     tmp = esq ./ h.^2 - 1 ./ h;
     s   = 1 ./ h(1:T-p);
     for j = 1 : p;
-      s = s - a(j+1) * tmp(j+1:T-p+j);
+      s -= a(j+1) * tmp(j+1:T-p+j);
     endfor
     r = 1 ./ h(1:T-p);
     for j = 1:p;
-      r = r + 2 * h(j+1:T-p+j).^2 .* esq(1:T-p);
+      r += 2 * h(j+1:T-p+j).^2 .* esq(1:T-p);
     endfor
     r = sqrt (r);
     X_tilde = x(1:T-p, :) .* (r * ones (1,k));
     e_tilde = e(1:T-p) .*s ./ r;
     delta_b = inv (X_tilde' * X_tilde) * X_tilde' * e_tilde;
-    b   = b + gamma * delta_b;
+    b  += gamma * delta_b;
     e   = y - x * b;
     esq = e .^ 2;
     Z   = autoreg_matrix (esq, p);
     h   = Z * a;
     f   = esq ./ h - ones (T,1);
     Z_tilde = Z ./ (h * ones (1, p+1));
     delta_a = inv (Z_tilde' * Z_tilde) * Z_tilde' * f;
-    a = a + gamma * delta_a;
+    a += gamma * delta_a;
   endfor
 
 endfunction
 
diff --git a/scripts/signal/arch_rnd.m b/scripts/signal/arch_rnd.m
--- a/scripts/signal/arch_rnd.m
+++ b/scripts/signal/arch_rnd.m
@@ -58,24 +58,24 @@ function y = arch_rnd (a, b, t)
     error ("arch_rnd: A(1) must be positive");
   endif
   ## perhaps add a test for the roots of a(z) here ...
 
   la = length (a);
   a  = reshape (a, 1, la);
   if (la == 1)
     a  = [a, 0];
-    la = la + 1;
+    la += 1;
   endif
 
   lb = length (b);
   b  = reshape (b, 1, lb);
   if (lb == 1)
     b  = [b, 0];
-    lb = lb + 1;
+    lb += 1;
   endif
   m = max ([la, lb]);
 
   e = zeros (t, 1);
   h = zeros (t, 1);
   y = zeros (t, 1);
 
   h(1) = a(1);
diff --git a/scripts/signal/bartlett.m b/scripts/signal/bartlett.m
--- a/scripts/signal/bartlett.m
+++ b/scripts/signal/bartlett.m
@@ -37,17 +37,17 @@ function c = bartlett (m)
 
   if (! (isscalar (m) && (m == fix (m)) && (m > 0)))
     error ("bartlett: M must be a positive integer");
   endif
 
   if (m == 1)
     c = 1;
   else
-    m = m - 1;
+    m -= 1;
     n = fix (m / 2);
     c = [2*(0:n)/m, 2-2*(n+1:m)/m]';
   endif
 
 endfunction
 
 
 %!assert (bartlett (1), 1)
diff --git a/scripts/signal/blackman.m b/scripts/signal/blackman.m
--- a/scripts/signal/blackman.m
+++ b/scripts/signal/blackman.m
@@ -55,17 +55,17 @@ function c = blackman (m, opt)
       otherwise
         error ('blackman: window type must be either "periodic" or "symmetric"');
     endswitch
   endif
 
   if (m == 1)
     c = 1;
   else
-    m = m - 1;
+    m -= 1;
     k = (0 : m)' / N;
     c = 0.42 - 0.5 * cos (2 * pi * k) + 0.08 * cos (4 * pi * k);
   endif
 
 endfunction
 
 
 %!assert (blackman (1), 1)
diff --git a/scripts/signal/freqz.m b/scripts/signal/freqz.m
--- a/scripts/signal/freqz.m
+++ b/scripts/signal/freqz.m
@@ -147,17 +147,17 @@ function [h_r, f_r] = freqz (b, a, n, re
     ## polyval(fliplr(P),exp(jw)) is O(p n) and fft(x) is O(n log(n)),
     ## where p is the order of the polynomial P.  For small p it
     ## would be faster to use polyval but in practice the overhead for
     ## polyval is much higher and the little bit of time saved isn't
     ## worth the extra code.
     k = max (length (b), length (a));
     if (k > n/2 && nargout == 0)
       ## Ensure a causal phase response.
-      n = n * 2 .^ ceil (log2 (2*k/n));
+      n *= 2 .^ ceil (log2 (2*k/n));
     endif
 
     if (whole_region)
       N = n;
       if (plot_output)
         f = Fs * (0:n).' / N;    # do 1 more for the plot
       else
         f = Fs * (0:n-1).' / N;
@@ -173,18 +173,18 @@ function [h_r, f_r] = freqz (b, a, n, re
     pad_sz = N*ceil (k/N);
     b = postpad (b, pad_sz);
     a = postpad (a, pad_sz);
 
     hb = zeros (n, 1);
     ha = zeros (n, 1);
 
     for i = 1:N:pad_sz
-      hb = hb + fft (postpad (b(i:i+N-1), N))(1:n);
-      ha = ha + fft (postpad (a(i:i+N-1), N))(1:n);
+      hb += fft (postpad (b(i:i+N-1), N))(1:n);
+      ha += fft (postpad (a(i:i+N-1), N))(1:n);
     endfor
 
   endif
 
   h = hb ./ ha;
 
   if (plot_output)
     ## Plot and don't return values.
diff --git a/scripts/signal/hamming.m b/scripts/signal/hamming.m
--- a/scripts/signal/hamming.m
+++ b/scripts/signal/hamming.m
@@ -55,17 +55,17 @@ function c = hamming (m, opt)
       otherwise
         error ('hamming: window type must be either "periodic" or "symmetric"');
     endswitch
   endif
 
   if (m == 1)
     c = 1;
   else
-    m = m - 1;
+    m -= 1;
     c = 0.54 - 0.46 * cos (2 * pi * (0 : m)' / N);
   endif
 
 endfunction
 
 
 %!assert (hamming (1), 1)
 %!assert (hamming (2), (0.54 - 0.46)*ones (2,1))
diff --git a/scripts/signal/hanning.m b/scripts/signal/hanning.m
--- a/scripts/signal/hanning.m
+++ b/scripts/signal/hanning.m
@@ -55,17 +55,17 @@ function c = hanning (m, opt)
       otherwise
         error ('hanning: window type must be either "periodic" or "symmetric"');
     endswitch
   endif
 
   if (m == 1)
     c = 1;
   else
-    m = m - 1;
+    m -= 1;
     c = 0.5 - 0.5 * cos (2 * pi * (0 : m)' / N);
   endif
 
 endfunction
 
 
 %!assert (hanning (1), 1);
 %!assert (hanning (2), zeros (2,1));
diff --git a/scripts/signal/spectral_adf.m b/scripts/signal/spectral_adf.m
--- a/scripts/signal/spectral_adf.m
+++ b/scripts/signal/spectral_adf.m
@@ -55,17 +55,17 @@ function retval = spectral_adf (c, win, 
     w = triangle_lw (cr, b);
   elseif (! ischar (win))
     error ("spectral_adf: WIN must be a string");
   else
     win = str2func ([win "_lw"]);
     w = feval (win, cr, b);
   endif
 
-  c = c .* w;
+  c .*= w;
 
   retval = 2 * real (fft (c)) - c(1);
   retval = [(zeros (cr, 1)), retval];
   retval(:, 1) = (0 : cr-1)' / cr;
 
 endfunction
 
 
diff --git a/scripts/signal/spectral_xdf.m b/scripts/signal/spectral_xdf.m
--- a/scripts/signal/spectral_xdf.m
+++ b/scripts/signal/spectral_xdf.m
@@ -55,17 +55,17 @@ function retval = spectral_xdf (x, win, 
     w = triangle_sw (xr, b);
   elseif (! ischar (win))
     error ("spectral_xdf: WIN must be a string");
   else
     win = str2func ([win "_sw"]);
     w = feval (win, xr, b);
   endif
 
-  x = x - sum (x) / xr;
+  x -= sum (x) / xr;
 
   retval = (abs (fft (x)) / xr).^2;
   retval = real (ifft (fft (retval) .* fft (w)));
 
   retval = [(zeros (xr, 1)), retval];
   retval(:, 1) = (0 : xr-1)' / xr;
 
 endfunction
diff --git a/scripts/signal/stft.m b/scripts/signal/stft.m
--- a/scripts/signal/stft.m
+++ b/scripts/signal/stft.m
@@ -96,17 +96,17 @@ function [y, c] = stft (x, win_size = 80
     case 3  win_coef = ones (win_size, 1);
   endswitch
 
   ## Create a matrix Z whose columns contain the windowed time-slices.
   z = zeros (ncoef, num_win + 1);
   start = 1;
   for i = 0:num_win
     z(1:win_size, i+1) = x(start:start+win_size-1) .* win_coef;
-    start = start + inc;
+    start += inc;
   endfor
 
   y = fft (z);
 
   if (nargout == 1)
     y = abs (y(1:num_coef, :));
   else
     c = [win_size, inc, win_type];
diff --git a/scripts/sparse/bicgstab.m b/scripts/sparse/bicgstab.m
--- a/scripts/sparse/bicgstab.m
+++ b/scripts/sparse/bicgstab.m
@@ -158,17 +158,17 @@ function [x, flag, relres, iter, resvec]
       v = Ax (phat);
       alpha = rho_1 / (rr' * v);
       s = res - alpha * v;
 
       shat = precon (s);
 
       t = Ax (shat);
       omega = (s' * t) / (t' * t);
-      x = x + alpha * phat + omega * shat;
+      x += alpha * phat + omega * shat;
       res = s - omega * t;
       rho_2 = rho_1;
 
       relres = norm (res) / norm_b;
       resvec = [resvec; relres];
 
       if (relres <= tol)
         ## We reach tolerance tol within maxit iterations.
diff --git a/scripts/sparse/cgs.m b/scripts/sparse/cgs.m
--- a/scripts/sparse/cgs.m
+++ b/scripts/sparse/cgs.m
@@ -142,19 +142,19 @@ function [x, flag, relres, iter, resvec]
         p = z;
       else
         beta = ro / ro_old;
         p = z + beta * p;
       endif
       ## Cache.
       q = Ax (p);
       alpha = ro / (p' * q);
-      x = x + alpha * p;
+      x += alpha * p;
 
-      res = res - alpha * q;
+      res -= alpha * q;
       relres = norm (res) / norm_b;
       resvec = [resvec; relres];
 
       if (relres <= tol)
         ## We reach tolerance tol within maxit iterations.
         flag = 0;
         break
       elseif (resvec(end) == resvec(end - 1))
diff --git a/scripts/sparse/private/__sprand_impl__.m b/scripts/sparse/private/__sprand_impl__.m
--- a/scripts/sparse/private/__sprand_impl__.m
+++ b/scripts/sparse/private/__sprand_impl__.m
@@ -130,16 +130,16 @@ function S = __sprand_impl__ (varargin)
           ## Construct V' randomized rotation matrix
           rot_anglev = 2 * pi * rand ();
           cv = cos (rot_anglev); sv = sin (rot_anglev);
           rndtmp = randperm (n, 2);
           i = rndtmp(1); j = rndtmp(2);
           V = Vinit;
           V(i, i) = cv;  V(i, j) = sv;
           V(j, i) = -sv; V(j, j) = cv;
-          S = S * V;
+          S *= V;
         endif
       endwhile
     endif
   endif
 
 endfunction
 
diff --git a/scripts/sparse/qmr.m b/scripts/sparse/qmr.m
--- a/scripts/sparse/qmr.m
+++ b/scripts/sparse/qmr.m
@@ -176,19 +176,19 @@ function [x, flag, relres, iter, resvec]
 
     xi1 = norm (z);
     gamma0 = 1;
     eta0 = -1;
     flag = 1;
     for iter=1:1:maxit
       ## If rho0 == 0 or xi1 == 0, method fails.
       v = vt / rho0;
-      y = y / rho0;
+      y /= rho0;
       w = wt / xi1;
-      z = z / xi1;
+      z /= xi1;
 
       delta1 = z' * y;   # If delta1 == 0, method fails.
 
       yt = M2m1x (y);
       zt = M1tm1x (z);
 
       if (iter == 1)
         p = yt;
diff --git a/scripts/sparse/sprandsym.m b/scripts/sparse/sprandsym.m
--- a/scripts/sparse/sprandsym.m
+++ b/scripts/sparse/sprandsym.m
@@ -36,17 +36,17 @@ function S = sprandsym (n, d)
   if (nargin != 1 && nargin != 2)
     print_usage ();
   endif
 
   if (nargin == 1)
     [i, j] = find (tril (n));
     [nr, nc] = size (n);
     S = sparse (i, j, randn (size (i)), nr, nc);
-    S = S + tril (S, -1)';
+    S += tril (S, -1)';
     return;
   endif
 
   if (!(isscalar (n) && n == fix (n) && n > 0))
     error ("sprandsym: N must be an integer greater than 0");
   endif
 
   if (d < 0 || d > 1)
diff --git a/scripts/sparse/svds.m b/scripts/sparse/svds.m
--- a/scripts/sparse/svds.m
+++ b/scripts/sparse/svds.m
@@ -157,17 +157,17 @@ function [u, s, v, flag] = svds (A, k, s
 
     ## Scale everything by the 1-norm to make things more stable.
     b = A / max_a;
     b_opts = opts;
     ## Call to eigs is always a symmetric matrix by construction
     b_opts.issym = true;
     b_sigma = sigma;
     if (! ischar (b_sigma))
-      b_sigma = b_sigma / max_a;
+      b_sigma /= max_a;
     endif
 
     if (b_sigma == 0)
       ## Find the smallest eigenvalues
       ## The eigenvalues returns by eigs for sigma=0 are symmetric about 0.
       ## As we are only interested in the positive eigenvalues, we have to
       ## double k and then throw out the k negative eigenvalues.
       ## Separately, if sigma is nonzero, but smaller than the smallest
@@ -220,17 +220,17 @@ function [u, s, v, flag] = svds (A, k, s
 
     if (length (s) < k)
       warning ("returning fewer singular values than requested");
       if (! ischar (sigma))
         warning ("try increasing the value of sigma");
       endif
     endif
 
-    s = s * max_a;
+    s *= max_a;
   endif
 
   if (nargout < 2)
     u = s;
   else
     if (max_a == 0)
       u = eye (m, k);
       s = diag (s);
diff --git a/scripts/specfun/legendre.m b/scripts/specfun/legendre.m
--- a/scripts/specfun/legendre.m
+++ b/scripts/specfun/legendre.m
@@ -187,17 +187,17 @@ function retval = legendre (n, x, normal
     case "norm"
       scale = sqrt (n+0.5);
     case "sch"
       scale = sqrt (2);
     otherwise
       error ('legendre: NORMALIZATION option must be "unnorm", "norm", or "sch"');
   endswitch
 
-  scale = scale * ones (size (x));
+  scale *= ones (size (x));
 
   ## Based on the recurrence relation below
   ##            m                 m              m
   ## (n-m+1) * P (x) = (2*n+1)*x*P (x)  - (n+1)*P (x)
   ##            n+1               n              n-1
   ## http://en.wikipedia.org/wiki/Associated_Legendre_function
 
   overflow = false;
diff --git a/scripts/special-matrix/gallery.m b/scripts/special-matrix/gallery.m
--- a/scripts/special-matrix/gallery.m
+++ b/scripts/special-matrix/gallery.m
@@ -590,17 +590,17 @@ function C = chebspec (n, k = 0)
   ## k = 1 case obtained from k = 0 case with one bigger n.
   switch (k)
     case (0), # do nothing
     case (1), n = n + 1;
     otherwise
       error ("gallery: unknown K '%d' for chebspec matrix.", k);
   endswitch
 
-  n = n-1;
+  n -= 1;
   C = zeros (n+1);
 
   one    = ones (n+1, 1);
   x      = cos ((0:n)' * (pi/n));
   d      = ones (n+1, 1);
   d(1)   = 2;
   d(n+1) = 2;
 
@@ -768,17 +768,17 @@ function A = clement (n, k = 0)
   if (nargin < 1 || nargin > 2)
     error ("gallery: 1 or 2 arguments are required for clement matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for clement matrix.");
   elseif (! isnumeric (k) || ! isscalar (k))
     error ("gallery: K must be a numeric scalar for clement matrix.");
   endif
 
-  n = n-1;
+  n -= 1;
   x = n:-1:1;
   z = 1:n;
 
   if (k == 0)
     A = diag (x, -1) + diag (z, 1);
   elseif (k == 1)
     y = sqrt (x.*z);
     A = diag (y, -1) + diag (y, 1);
@@ -1488,23 +1488,23 @@ function [A, detA] = ipjfact (n, k = 0)
       error ("gallery: K must have a value of 0 or 1 for ipjfact matrix.");
   endswitch
 
   if (nargout == 2)
     d = 1;
 
     if (k == 0)
       for i = 1:n-1
-        d = d * prod (1:i+1) * prod (1:n-i);
+        d *= prod (1:i+1) * prod (1:n-i);
       endfor
-      d = d * prod (1:n+1);
+      d *= prod (1:n+1);
 
     elseif (k == 1)
       for i = 0:n-1
-        d = d * prod (1:i) / prod (1:n+1+i);
+        d *= prod (1:i) / prod (1:n+1+i);
       endfor
       if (rem (n*(n-1)/2, 2))
         d = -d;
       endif
 
     else
       error ("gallery: K must have a value of 0 or 1 for ipjfact matrix.");
     endif
@@ -2213,17 +2213,17 @@ function A = randsvd (n, kappa = sqrt (1
   ## Parameter n specifies dimension: m-by-n.
   m = n(1);
   n = n(end);
   p = min ([m n]);
 
   ## If A will be a vector
   if (p == 1)
     A = randn (m, n);
-    A = A / norm (A);
+    A /= norm (A);
     return;
   endif
 
   ##  Set up vector sigma of singular values.
   switch (abs (mode))
     case (1)
       sigma = ones (p, 1) ./ kappa;
       sigma(1) = 1;
@@ -2334,17 +2334,17 @@ function A = riemann (n)
   ##   Linear Algebra and Appl., 81 (1986), pp. 153-198.
 
   if (nargin != 1)
     error ("gallery: 1 argument is required for riemann matrix.");
   elseif (! isnumeric (n) || ! isscalar (n) || fix (n) != n)
     error ("gallery: N must be an integer for riemann matrix.");
   endif
 
-  n = n+1;
+  n += 1;
   i = (2:n)' * ones (1, n-1);
   j = i';
   A = i .* (! rem (j, i)) - ones (n-1);
 endfunction
 
 function A = ris (n)
   ## NOTE: this function was named dingdong in the original Test Matrix Toolbox
   ## RIS       Dingdong matrix - a symmetric Hankel matrix.
@@ -2430,17 +2430,17 @@ function T = toeppd (n, m = n, w = rand 
   elseif (numel (w) != m || numel (theta) != m)
     error ("gallery: W and THETA must be vectors of length M for toeppd matrix.");
   endif
 
   T = zeros (n);
   E = 2*pi * ((1:n)' * ones (1, n) - ones (n, 1) * (1:n));
 
   for i = 1:m
-    T = T + w(i) * cos (theta(i)*E);
+    T += w(i) * cos (theta(i)*E);
   endfor
 endfunction
 
 function P = toeppen (n, a = 1, b = -10, c = 0, d = 10, e = 1)
   ## NOTE: this function was named pentoep in the original Test Matrix Toolbox
   ## TOEPPEN   Pentadiagonal Toeplitz matrix (sparse).
   ##   P = TOEPPEN(N, A, B, C, D, E) is the N-by-N pentadiagonal
   ##   Toeplitz matrix with diagonals composed of the numbers
diff --git a/scripts/statistics/base/gls.m b/scripts/statistics/base/gls.m
--- a/scripts/statistics/base/gls.m
+++ b/scripts/statistics/base/gls.m
@@ -94,17 +94,17 @@ function [beta, v, r] = gls (y, x, o)
   if (isinteger (y))
     y = double (y);
   endif
   if (isinteger (o))
     o = double (o);
   endif
 
   ## Start of algorithm
-  o = o^(-1/2);
+  o ^= -1/2;
   z = kron (eye (cy), x);
   z = o * z;
   y1 = o * reshape (y, ry*cy, 1);
   u = z' * z;
   r = rank (u);
 
   if (r == cx*cy)
     b = inv (u) * z' * y1;
diff --git a/scripts/statistics/models/logistic_regression.m b/scripts/statistics/models/logistic_regression.m
--- a/scripts/statistics/models/logistic_regression.m
+++ b/scripts/statistics/models/logistic_regression.m
@@ -123,26 +123,26 @@ function [theta, beta, dev, dl, d2l, p] 
   ## likelihood and derivatives at starting values
   [g, g1, p, dev] = logistic_regression_likelihood (y, x, tb, z, z1);
   [dl, d2l] = logistic_regression_derivatives (x, z, z1, g, g1, p);
   epsilon = std (vec (d2l)) / 1000;
 
   ## maximize likelihood using Levenberg modified Newton's method
   iter = 0;
   while (abs (dl' * (d2l \ dl) / length (dl)) > tol)
-    iter = iter + 1;
+    iter += 1;
     tbold = tb;
     devold = dev;
     tb = tbold - d2l \ dl;
     [g, g1, p, dev] = logistic_regression_likelihood (y, x, tb, z, z1);
     if ((dev - devold) / (dl' * (tb - tbold)) < 0)
-      epsilon = epsilon / decr;
+      epsilon /= decr;
     else
       while ((dev - devold) / (dl' * (tb - tbold)) > 0)
-        epsilon = epsilon * incr;
+        epsilon *= incr;
          if (epsilon > 1e+15)
            error ("logistic_regression: epsilon too large");
          endif
          tb = tbold - (d2l - epsilon * eye (size (d2l))) \ dl;
          [g, g1, p, dev] = logistic_regression_likelihood (y, x, tb, z, z1);
          disp ("epsilon"); disp (epsilon);
       endwhile
     endif
diff --git a/scripts/statistics/tests/kruskal_wallis_test.m b/scripts/statistics/tests/kruskal_wallis_test.m
--- a/scripts/statistics/tests/kruskal_wallis_test.m
+++ b/scripts/statistics/tests/kruskal_wallis_test.m
@@ -68,26 +68,26 @@ function [pval, k, df] = kruskal_wallis_
     p = [p, (reshape (x, 1, l))];
   endfor
 
   r = ranks (p);
 
   k = 0;
   j = 0;
   for i = 1 : m;
-    k = k + (sum (r ((j + 1) : (j + n(i))))) ^ 2 / n(i);
+    k += (sum (r ((j + 1) : (j + n(i))))) ^ 2 / n(i);
     j = j + n(i);
   endfor
 
   n = length (p);
   k = 12 * k / (n * (n + 1)) - 3 * (n + 1);
 
   ## Adjust the result to takes ties into account.
   sum_ties = sum (polyval ([1, 0, -1, 0], runlength (sort (p))));
-  k = k / (1 - sum_ties / (n^3 - n));
+  k /= (1 - sum_ties / (n^3 - n));
 
   df = m - 1;
   pval = 1 - chi2cdf (k, df);
 
   if (nargout == 0)
     printf ("pval: %g\n", pval);
   endif
 
diff --git a/scripts/statistics/tests/manova.m b/scripts/statistics/tests/manova.m
--- a/scripts/statistics/tests/manova.m
+++ b/scripts/statistics/tests/manova.m
@@ -64,25 +64,25 @@ function manova (x, g)
   k = length (i) + 1;
 
   if (k == 1)
     error ("manova: there should be at least 2 groups");
   else
     group_label = s ([1, (reshape (i, 1, k - 1) + 1)]);
   endif
 
-  x = x - ones (n, 1) * mean (x);
+  x -= ones (n, 1) * mean (x);
   SST = x' * x;
 
   s = zeros (1, p);
   SSB = zeros (p, p);
   for i = 1 : k;
     v = x (find (g == group_label (i)), :);
     s = sum (v);
-    SSB = SSB + s' * s / rows (v);
+    SSB += s' * s / rows (v);
   endfor
   n_b = k - 1;
 
   SSW = SST - SSB;
   n_w = n - k;
 
   l = real (eig (SSB / SSW));
 
diff --git a/scripts/statistics/tests/wilcoxon_test.m b/scripts/statistics/tests/wilcoxon_test.m
--- a/scripts/statistics/tests/wilcoxon_test.m
+++ b/scripts/statistics/tests/wilcoxon_test.m
@@ -53,21 +53,21 @@ function [pval, z] = wilcoxon_test (x, y
   if (! (isvector (x) && isvector (y) && (length (x) == length (y))))
     error ("wilcoxon_test: X and Y must be vectors of the same length");
   endif
 
   n = length (x);
   x = reshape (x, 1, n);
   y = reshape (y, 1, n);
   d = x - y;
-  d = d (find (d != 0));
+  d = d(find (d != 0));
   n = length (d);
   if (n > 25)
     r = ranks (abs (d));
-    z = sum (r (find (d > 0)));
+    z = sum (r(find (d > 0)));
     z = ((z - n * (n + 1) / 4) / sqrt (n * (n + 1) * (2 * n + 1) / 24));
   else
     error ("wilcoxon_test: implementation requires more than 25 different pairs");
   endif
 
   cdf = stdnormal_cdf (z);
 
   if (nargin == 2)
diff --git a/scripts/time/datevec.m b/scripts/time/datevec.m
--- a/scripts/time/datevec.m
+++ b/scripts/time/datevec.m
@@ -178,19 +178,19 @@ function [y, m, d, h, mi, s] = datevec (
     ## datenum format.
 
     fracd = date - floor (date);
     tmps = abs (eps*86400*date);
     tmps(tmps == 0) = 1;
     srnd = 2 .^ floor (- log2 (tmps));
     s = round (86400 * fracd .* srnd) ./ srnd;
     h = floor (s / 3600);
-    s = s - 3600 * h;
+    s -= 3600 * h;
     mi = floor (s / 60);
-    s = s - 60 * mi;
+    s -= 60 * mi;
 
   endif
 
   if (nargout <= 1)
     y = [y, m, d, h, mi, s];
   elseif (do_resize)
     y = reshape (y, date_sz);
     m = reshape (m, date_sz);
