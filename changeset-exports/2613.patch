# HG changeset patch
# User jwe
# Date 853818798 0
#      Tue Jan 21 03:53:18 1997 +0000
# Node ID 5bcee07be597189eb74e4faa5371aad3c9dfe3a9
# Parent  e2d1b073b78a0d17c3afc5712d419d1c42541098
[project @ 1997-01-21 03:52:08 by jwe]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,12 +1,15 @@
 Mon Jan 20 11:16:21 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* mkoctfile.in (ALL_CXXFLAGS): Delete reference to -lg++.
+
 	* configure.in (RLD_FLAG): For sparc-sun-sunos4*, remove space
 	between -L and $(libdir).
+	(FPICFLAG): If using g77, set it to -fPIC.
 
 Sun Jan 19 15:57:20 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Makeconf.in, configure.in: Delete FUGLY.
 
 Wed Jan  8 23:12:02 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* configure.in (DEFAULT_PAGER): On cygwin32 systems, also look for
diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -1,8 +1,13 @@
+Summary of changes for version 2.0.3:
+------------------------------------
+
+  * size ("") is now [0, 0].
+
 Summary of changes for version 2.0:
 ----------------------------------
 
   * The set and show commands for setting and displaying gnuplot
     parameters have been replaced by gset and gshow.  This change will
     probably break lots of things, but it is necessary to allow for
     compatibility with the Matlab graphics and GUI commands in a
     future version of Octave.  (For now, the old set and show commands
diff --git a/PROJECTS b/PROJECTS
--- a/PROJECTS
+++ b/PROJECTS
@@ -139,22 +139,16 @@ Strings:
 
   * Consider making octave_print_internal() print some sort of text
     representation for unprintable characters instead of sending them
     directly to the terminal.  (But don't do this for fprintf!)
 
   * Consider changing the default value of `string_fill_char' from SPC
     to NUL.
 
-  * Consider making size ("") ==> [0, 0] for compatibility with
-    Matlab, at least when some preference variable is set.
-
-  * Consider making [] equivalent to "" for compatibility with
-    Matlab, at least when some preference variable is set.
-
   * Consider making ["test", []] ==> "test", for compatibility with
     Matlab, at least when some set of preferences are set.
 
 ----------------
 Other Data Types:
 ----------------
 
   * New types (char, short, etc.).
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,14 @@
+Mon Jan 20 18:44:11 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* chMatrix.cc (charMatrix::charMatrix (const string&)):
+	If the number of columns is zero, also set the number of rows to zero.
+	(charMatrix::charMatrix (const char *)): Likewise.
+
 Tue Jan  7 00:16:57 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Version 2.0.1 released.
 
 Sun Jan  5 12:07:45 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* dMatrix.cc (Matrix::read): Correctly compute the number of
 	columns for resizing when the number of rows is specified but the
diff --git a/liboctave/chMatrix.cc b/liboctave/chMatrix.cc
--- a/liboctave/chMatrix.cc
+++ b/liboctave/chMatrix.cc
@@ -41,35 +41,44 @@ Software Foundation, 59 Temple Place - S
 #include "lo-error.h"
 #include "str-vec.h"
 #include "mx-base.h"
 #include "mx-inlines.cc"
 
 // charMatrix class.
 
 charMatrix::charMatrix (const char *s)
-  : MArray2<char> ((s ? 1 : 0), (s ? strlen (s) : 0))
+  : MArray2<char> ()
 {
-  int nc = cols ();
+  int nc = s ? strlen (s) : 0;
+  int nr = s && nc > 0 ? 1 : 0;
+
+  resize (nr, nc);
+
   for (int i = 0; i < nc; i++)
     elem (0, i) = s[i];
 }
 
 charMatrix::charMatrix (const string& s)
-  : MArray2<char> (1, s.length ())
+  : MArray2<char> ()
 {
-  int nc = cols ();
+  int nc = s.length ();
+  int nr = nc > 0 ? 1 : 0;
+
+  resize (nr, nc);
+
   for (int i = 0; i < nc; i++)
     elem (0, i) = s[i];
 }
 
 charMatrix::charMatrix (const string_vector& s)
   : MArray2<char> (s.length (), s.max_length (), 0)
 {
   int nr = rows ();
+
   for (int i = 0; i < nr; i++)
     {
       int nc = s[i].length ();
       for (int j = 0; j < nc; j++)
 	elem (i, j) = s[i][j];
     }
 }
 
@@ -112,25 +121,31 @@ charMatrix::insert (const charMatrix& a,
 {
   Array2<char>::insert (a, r, c);
   return *this;
 }
 
 string
 charMatrix::row_as_string (int r, bool strip_ws = false) const 
 {
-  if (r < 0 || r >= rows ())
+  string retval;
+
+  int nr = rows ();
+  int nc = cols ();
+
+  if (r == 0 && nr == 0 && nc == 0)
+    return retval;
+
+  if (r < 0 || r >= nr)
     {
       (*current_liboctave_error_handler) ("range error for row_as_string");
-      return 0;
+      return retval;
     }
 
-  int nc = cols ();
-
-  string retval (nc, '\0');
+  retval.resize (nc, '\0');
 
   for (int i = 0; i < nc; i++)
     retval[i] = elem (r, i);
 
   if (strip_ws)
     {
       while (--nc >= 0)
 	{
diff --git a/mkoctfile.in b/mkoctfile.in
--- a/mkoctfile.in
+++ b/mkoctfile.in
@@ -48,9 +48,9 @@ ALL_CXXFLAGS="$INCFLAGS $HOST_CXXFLAGS $
   $GCC_IEEE_FP_FLAG $CXXFLAGS"
 
 echo "making $objfile from $srcfile"
 
 $CXX -c $CPPFLAGS $CXXPICFLAG $ALL_CXXFLAGS $srcfile -o $objfile
 
 echo "making $octfile from $objfile"
 
-$CXX -shared -o $octfile $objfile $LIBFLAGS $RLD_FLAG $OCTAVE_LIBS $FLIBS $LEXLIB $TERMLIBS $LIBS -lg++
+$CXX -shared -o $octfile $objfile $LIBFLAGS $RLD_FLAG $OCTAVE_LIBS $FLIBS $LEXLIB $TERMLIBS $LIBS
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,12 @@
+Mon Jan 20 12:28:34 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* plot/sombrero.m: Doc fix.
+
 Tue Jan  7 00:16:52 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Version 2.0.1 released.
 
 Thu Dec 19 22:16:46 1996  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* elfun/lcm.m: Replace missing if statement.
 
diff --git a/scripts/plot/sombrero.m b/scripts/plot/sombrero.m
--- a/scripts/plot/sombrero.m
+++ b/scripts/plot/sombrero.m
@@ -17,17 +17,17 @@
 ## Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ## 02111-1307, USA.
 
 ## usage: sombrero (n)
 ##
 ## Draw a `sombrero' in three dimensions using n grid lines.  The
 ## function plotted is
 ##
-##   z = sin (x^2 + y^2) / (x^2 + y^2);
+##   z = sin (sqrt (x^2 + y^2)) / (sqrt (x^2 + y^2))
 
 ## Author: jwe
 
 function sombrero (n)
 
   if (nargin != 1)
     usage ("sombrero (n)");
   endif
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,10 +1,16 @@
 Mon Jan 20 11:11:12 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* ops.h (MX_MX_BOOL_OP): Correctly handle case of one or both
+	arguments being empty.  Change all callers.
+
+	* oct-stream.cc (printf_value_cache::looking_at_string):
+	Handle empty strings correctly now that they are 0x0.
+
 	* file-io.cc: Don't include "syswait.h" here.
 
 Sun Jan 19 22:38:45 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* oct-stream.h (octave_base_stream::seek): Declare offset arg as
 	streamoff, not streampos.
 	(octave_stream::seek): Likewise.
 	* oct-strstrm.h (octave_base_strstream::seek): Likewise.
diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -30,23 +30,23 @@ XALL_CXXFLAGS = $(subst -fno-implicit-te
 # How to make a .oct file from a .o file:
 
 ifeq ($(OCTAVE_LITE), true)
   ifdef CXXPICFLAG
     %.oct : pic/%.o
 	  $(CXX) -shared -o $@ $< \
 	    $(OCTAVE_LFLAGS) \
 	    $(OCTAVE_LIBS) \
-	    $(FLIBS) $(LEXLIB) $(TERMLIBS) $(LIBS) -lg++
+	    $(FLIBS) $(LEXLIB) $(TERMLIBS) $(LIBS)
   else
     %.oct : %.o
 	  $(CXX) -shared -o $@ $< \
 	    $(OCTAVE_LFLAGS) \
 	    $(OCTAVE_LIBS) \
-	    $(FLIBS) $(LEXLIB) $(TERMLIBS) $(LIBS) -lg++
+	    $(FLIBS) $(LEXLIB) $(TERMLIBS) $(LIBS)
   endif
 endif
 
 DLD_SRC := balance.cc chol.cc colloc.cc dassl.cc det.cc eig.cc \
 	   expm.cc fft.cc fft2.cc filter.cc find.cc fsolve.cc \
 	   fsqp.cc getgrent.cc getpwent.cc getrusage.cc givens.cc \
 	   hess.cc ifft.cc ifft2.cc inv.cc log.cc lpsolve.cc lsode.cc \
 	   lu.cc minmax.cc npsol.cc pinv.cc qpsol.cc qr.cc quad.cc \
@@ -177,17 +177,17 @@ all: stamp-prereq stamp-picdir libraries
 stamp-prereq: defaults.h oct-conf.h
 	touch stamp-prereq
 
 octave: octave.o builtins.o $(DLD_STATIC_OBJ) libraries
 	$(CXX) $(CPPFLAGS) $(ALL_CXXFLAGS) $(ALL_LDFLAGS) -o octave \
 	octave.o builtins.o $(DLD_STATIC_OBJ) \
 	$(OCTAVE_LFLAGS) \
 	$(OCTAVE_LIBS) \
-	$(FLIBS) $(LEXLIB) $(TERMLIBS) $(LIBS) -lg++
+	$(FLIBS) $(LEXLIB) $(TERMLIBS) $(LIBS)
 
 stamp-picdir:
 	if [ "$(SHARED_LIBS)" = true ] || [ "$(OCTAVE_LITE)" = true ]; then \
 	  if [ -n "$(CPICFLAG)" ] || [ -n "$(CXXPICFLAG)" ]; then \
 	    if [ -d pic ]; then \
 	      true ; \
 	    else \
 	      mkdir pic ; \
@@ -208,28 +208,28 @@ libtinst.a: $(TI_OBJ)
 	$(AR) $(ARFLAGS) libtinst.a $(TI_OBJ)
 	$(RANLIB) libtinst.a
 
 stamp-interp: $(PICOBJ)
 	if $(SHARED_LIBS); then \
 	  $(CXX) -shared -o liboctinterp.$(SHLEXT) $(PICOBJ) \
 	    $(OCTAVE_LFLAGS) \
 	    -loctave -lcruft -ltinst -lreadline -lkpathsea \
-	    $(SH_TERMLIBS) $(SH_LIBS) -lg++ ; \
+	    $(SH_TERMLIBS) $(SH_LIBS) ; \
 	else \
 	  true ; \
 	fi
 	touch stamp-interp
 
 stamp-tinst: $(TI_PICOBJ)
 	if $(SHARED_LIBS); then \
 	  $(CXX) -shared -o libtinst.$(SHLEXT) $(TI_PICOBJ) \
 	    $(OCTAVE_LFLAGS) \
 	    -loctinterp -loctave -lcruft -lreadline -lkpathsea \
-	    $(SH_TERMLIBS) $(SH_LIBS) -lg++ ; \
+	    $(SH_TERMLIBS) $(SH_LIBS) ; \
 	else \
 	  true ; \
 	fi
 	touch stamp-tinst
 
 builtins.cc: $(DEF_FILES) mkbuiltins
 	@echo making $@ from $(DEF_FILES)
 	@$(srcdir)/mkbuiltins $(DEF_FILES) > $@.t
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -1579,17 +1579,24 @@ printf_value_cache::looking_at_string (v
     idx = val_idx;
   else if (elt_idx >= n_elts)
     idx = val_idx + 1;
 
   if (idx >= 0 && idx < n_vals)
     {
       octave_value tmp_val = values (idx);
 
-      retval = tmp_val.is_string () && tmp_val.rows () == 1;
+      // An empty string has zero rows and zero columns.
+
+      if (tmp_val.is_string ())
+	{
+	  int nr = tmp_val.rows ();
+
+	  retval = (nr == 1 || (nr == 0 && tmp_val.columns () == 0));
+	}
     }
 
   return retval;
 }
 
 double
 printf_value_cache::double_value (void)
 {
diff --git a/src/op-cm-cm.cc b/src/op-cm-cm.cc
--- a/src/op-cm-cm.cc
+++ b/src/op-cm-cm.cc
@@ -84,71 +84,74 @@ pow (const octave_value&, const octave_v
 static octave_value
 ldiv (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
   return xleftdiv (v1.complex_matrix_value (), v2.complex_matrix_value ());
 }
 
-#define BOOL_OP(OP, EMPTY_RESULT) \
+#define BOOL_OP(OP, ONE_EMPTY_RESULT, TWO_EMPTY_RESULT) \
   MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (), \
 		 ComplexMatrix, m2, v2.complex_matrix_value (), \
-		 real (m1 (i, j)) OP real (m2 (i, j)), #OP, EMPTY_RESULT)
+		 real (m1 (i, j)) OP real (m2 (i, j)), #OP, \
+		 ONE_EMPTY_RESULT, TWO_EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (<, Matrix ());
+  BOOL_OP (<, Matrix (), Matrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (<=, Matrix ());
+  BOOL_OP (<=, Matrix (), Matrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
-  MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (), \
-		 ComplexMatrix, m2, v2.complex_matrix_value (), \
-		 m1 (i, j) == m2 (i, j), "==", 0.0);
+  MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (),
+		 ComplexMatrix, m2, v2.complex_matrix_value (),
+		 m1 (i, j) == m2 (i, j), "==",
+		 0.0, 1.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (>=, Matrix ());
+  BOOL_OP (>=, Matrix (), Matrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (>, Matrix ());
+  BOOL_OP (>, Matrix (), Matrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
-  MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (), \
-		 ComplexMatrix, m2, v2.complex_matrix_value (), \
-		 m1 (i, j) != m2 (i, j), "!=", 1.0);
+  MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (),
+		 ComplexMatrix, m2, v2.complex_matrix_value (),
+		 m1 (i, j) != m2 (i, j), "!=",
+		 1.0, 0.0);
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
   return octave_value (product (v1.complex_matrix_value (),
@@ -181,29 +184,31 @@ el_ldiv (const octave_value& a1, const o
 				 v1.complex_matrix_value ()));
 }
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
-  MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (), \
-		 ComplexMatrix, m2, v2.complex_matrix_value (), \
-		 m1 (i, j) != 0.0 && m2 (i, j) != 0.0, "&", Matrix ());
+  MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (),
+		 ComplexMatrix, m2, v2.complex_matrix_value (),
+		 m1 (i, j) != 0.0 && m2 (i, j) != 0.0, "&",
+		 Matrix (), Matrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
 
-  MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (), \
-		 ComplexMatrix, m2, v2.complex_matrix_value (), \
-		 m1 (i, j) != 0.0 || m2 (i, j) != 0.0, "|", Matrix ());
+  MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (),
+		 ComplexMatrix, m2, v2.complex_matrix_value (),
+		 m1 (i, j) != 0.0 || m2 (i, j) != 0.0, "|",
+		 Matrix (), Matrix ());
 }
 
 static octave_value
 assign (octave_value& a1, const octave_value_list& idx,
 	const octave_value& a2)
 {
   CAST_BINOP_ARGS (octave_complex_matrix&, const octave_complex_matrix&);
 
diff --git a/src/op-cm-cs.cc b/src/op-cm-cs.cc
--- a/src/op-cm-cs.cc
+++ b/src/op-cm-cs.cc
@@ -113,18 +113,18 @@ le (const octave_value& a1, const octave
   BOOL_OP (<=, Matrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
-  MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (), \
-		 Complex, s, v2.complex_value (), \
+  MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (),
+		 Complex, s, v2.complex_value (),
 		 m (i, j) == s, 0.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
@@ -139,18 +139,18 @@ gt (const octave_value& a1, const octave
   BOOL_OP (>, Matrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
-  MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (), \
-		 Complex, s, v2.complex_value (), \
+  MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (),
+		 Complex, s, v2.complex_value (),
 		 m (i, j) != s, 1.0);
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
@@ -186,28 +186,28 @@ el_ldiv (const octave_value& a1, const o
   return x_el_div (v2.complex_value (), v1.complex_matrix_value ());
 }
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
-  MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (), \
-		 Complex, s, v2.complex_value (), \
+  MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (),
+		 Complex, s, v2.complex_value (),
 		 m (i, j) != 0.0 && s != 0.0, Matrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex&);
 
-  MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (), \
-		 Complex, s, v2.complex_value (), \
+  MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (),
+		 Complex, s, v2.complex_value (),
 		 m (i, j) != 0.0 || s != 0.0, Matrix ());
 }
 
 static octave_value
 assign (octave_value& a1, const octave_value_list& idx,
 	const octave_value& a2)
 {
   CAST_BINOP_ARGS (octave_complex_matrix&, const octave_complex&);
diff --git a/src/op-cm-m.cc b/src/op-cm-m.cc
--- a/src/op-cm-m.cc
+++ b/src/op-cm-m.cc
@@ -82,71 +82,74 @@ pow (const octave_value&, const octave_v
 static octave_value
 ldiv (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
   return xleftdiv (v1.complex_matrix_value (), v2.matrix_value ());
 }
 
-#define BOOL_OP(OP, EMPTY_RESULT) \
+#define BOOL_OP(OP, ONE_EMPTY_RESULT, TWO_EMPTY_RESULT) \
   MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (), \
 		 Matrix, m2, v2.matrix_value (), \
-		 real (m1 (i, j)) OP m2 (i, j), #OP, EMPTY_RESULT)
+		 real (m1 (i, j)) OP m2 (i, j), #OP, \
+		 ONE_EMPTY_RESULT, TWO_EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
-  BOOL_OP (<, Matrix ());
+  BOOL_OP (<, Matrix (), Matrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
-  BOOL_OP (<=, Matrix ());
+  BOOL_OP (<=, Matrix (), Matrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
-  MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (), \
-		 Matrix, m2, v2.matrix_value (), \
-		 m1 (i, j) == m2 (i, j), "==", 0.0);
+  MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (),
+		 Matrix, m2, v2.matrix_value (),
+		 m1 (i, j) == m2 (i, j), "==",
+		 0.0, 1.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
-  BOOL_OP (>=, Matrix ());
+  BOOL_OP (>=, Matrix (), Matrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
-  BOOL_OP (>, Matrix ());
+  BOOL_OP (>, Matrix (), Matrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
-  MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (), \
-		 Matrix, m2, v2.matrix_value (), \
-		 m1 (i, j) != m2 (i, j), "!=", 0.0);
+  MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (),
+		 Matrix, m2, v2.matrix_value (),
+		 m1 (i, j) != m2 (i, j), "!=",
+		 1.0, 0.0);
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
   return product (v1.complex_matrix_value (), v2.matrix_value ());
@@ -176,29 +179,31 @@ el_ldiv (const octave_value& a1, const o
   return quotient (v2.matrix_value (), v1.complex_matrix_value ());
 }
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
-  MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (), \
-		 Matrix, m2, v2.matrix_value (), \
-		 m1 (i, j) != 0.0 && m2 (i, j), "&", Matrix ());
+  MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (),
+		 Matrix, m2, v2.matrix_value (),
+		 m1 (i, j) != 0.0 && m2 (i, j), "&",
+		 Matrix (), Matrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
 
-  MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (), \
-		 Matrix, m2, v2.matrix_value (), \
-		 m1 (i, j) != 0.0 || m2 (i, j), "|", Matrix ());
+  MX_MX_BOOL_OP (ComplexMatrix, m1, v1.complex_matrix_value (),
+		 Matrix, m2, v2.matrix_value (),
+		 m1 (i, j) != 0.0 || m2 (i, j), "|",
+		 Matrix (), Matrix ());
 }
 
 static octave_value
 assign (octave_value& a1, const octave_value_list& idx,
 	const octave_value& a2)
 {
   CAST_BINOP_ARGS (octave_complex_matrix&, const octave_matrix&);
 
diff --git a/src/op-cm-s.cc b/src/op-cm-s.cc
--- a/src/op-cm-s.cc
+++ b/src/op-cm-s.cc
@@ -113,18 +113,18 @@ le (const octave_value& a1, const octave
   BOOL_OP (<=, Matrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
-  MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (), \
-		 double, s, v2.double_value (), \
+  MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (),
+		 double, s, v2.double_value (),
 		 m (i, j) == s, 0.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
@@ -139,18 +139,18 @@ gt (const octave_value& a1, const octave
   BOOL_OP (>, Matrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
-  MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (), \
-		 double, s, v2.double_value (), \
+  MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (),
+		 double, s, v2.double_value (),
 		 m (i, j) != s, 1.0);
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
@@ -186,28 +186,28 @@ el_ldiv (const octave_value& a1, const o
   return x_el_div (v2.double_value (), v1.complex_matrix_value ());
 }
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
-  MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (), \
-		 double, s, v2.double_value (), \
+  MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (),
+		 double, s, v2.double_value (),
 		 m (i, j) != 0.0 && s, Matrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_scalar&);
 
-  MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (), \
-		 double, s, v2.double_value (), \
+  MX_SC_BOOL_OP (ComplexMatrix, m, v1.complex_matrix_value (),
+		 double, s, v2.double_value (),
 		 m (i, j) != 0.0 || s, Matrix ());
 }
 
 static octave_value
 assign (octave_value& a1, const octave_value_list& idx,
 	const octave_value& a2)
 {
   CAST_BINOP_ARGS (octave_complex_matrix&, const octave_scalar&);
diff --git a/src/op-cs-cm.cc b/src/op-cs-cm.cc
--- a/src/op-cs-cm.cc
+++ b/src/op-cs-cm.cc
@@ -113,18 +113,18 @@ le (const octave_value& a1, const octave
   BOOL_OP (<=, Matrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
-  SC_MX_BOOL_OP (Complex, s, v1.complex_value (), \
-		 ComplexMatrix, m, v2.complex_matrix_value (), \
+  SC_MX_BOOL_OP (Complex, s, v1.complex_value (),
+		 ComplexMatrix, m, v2.complex_matrix_value (),
 		 s == m (i, j), 0.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
@@ -139,18 +139,18 @@ gt (const octave_value& a1, const octave
   BOOL_OP (>, Matrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
-  SC_MX_BOOL_OP (Complex, s, v1.complex_value (), \
-		 ComplexMatrix, m, v2.complex_matrix_value (), \
+  SC_MX_BOOL_OP (Complex, s, v1.complex_value (),
+		 ComplexMatrix, m, v2.complex_matrix_value (),
 		 s != m (i, j), 1.0);
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
@@ -186,28 +186,28 @@ el_ldiv (const octave_value& a1, const o
   return octave_value (v2.complex_matrix_value () / d);
 }
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
-  SC_MX_BOOL_OP (Complex, s, v1.complex_value (), \
-		 ComplexMatrix, m, v2.complex_matrix_value (), \
+  SC_MX_BOOL_OP (Complex, s, v1.complex_value (),
+		 ComplexMatrix, m, v2.complex_matrix_value (),
 		 s != 0.0 && m (i, j) != 0.0, Matrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_complex_matrix&);
 
-  SC_MX_BOOL_OP (Complex, s, v1.complex_value (), \
-		 ComplexMatrix, m, v2.complex_matrix_value (), \
+  SC_MX_BOOL_OP (Complex, s, v1.complex_value (),
+		 ComplexMatrix, m, v2.complex_matrix_value (),
 		 s != 0.0 || m (i, j) != 0.0, Matrix ());
 }
 
 static octave_value *
 complex_matrix_conv (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_complex&);
 
diff --git a/src/op-cs-m.cc b/src/op-cs-m.cc
--- a/src/op-cs-m.cc
+++ b/src/op-cs-m.cc
@@ -114,18 +114,18 @@ le (const octave_value& a1, const octave
   BOOL_OP (<=, Matrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
-  SC_MX_BOOL_OP (Complex, s, v1.complex_value (), \
-		 Matrix, m, v2.matrix_value (), \
+  SC_MX_BOOL_OP (Complex, s, v1.complex_value (),
+		 Matrix, m, v2.matrix_value (),
 		 s == m (i, j), 0.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
@@ -140,18 +140,18 @@ gt (const octave_value& a1, const octave
   BOOL_OP (>, Matrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
-  SC_MX_BOOL_OP (Complex, s, v1.complex_value (), \
-		 Matrix, m, v2.matrix_value (), \
+  SC_MX_BOOL_OP (Complex, s, v1.complex_value (),
+		 Matrix, m, v2.matrix_value (),
 		 s != m (i, j), 1.0);
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_matrix&);
 
diff --git a/src/op-m-cm.cc b/src/op-m-cm.cc
--- a/src/op-m-cm.cc
+++ b/src/op-m-cm.cc
@@ -82,71 +82,74 @@ pow (const octave_value&, const octave_v
 static octave_value
 ldiv (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
   return xleftdiv (v1.matrix_value (), v2.complex_matrix_value ());
 }
 
-#define BOOL_OP(OP, EMPTY_RESULT) \
+#define BOOL_OP(OP, ONE_EMPTY_RESULT, TWO_EMPTY_RESULT) \
   MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (), \
 		 ComplexMatrix, m2, v2.complex_matrix_value (), \
-		 m1 (i, j) OP real (m2 (i, j)), #OP, EMPTY_RESULT)
+		 m1 (i, j) OP real (m2 (i, j)), #OP, \
+		 ONE_EMPTY_RESULT, TWO_EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (<, Matrix ());
+  BOOL_OP (<, Matrix (), Matrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (<=, Matrix ());
+  BOOL_OP (<=, Matrix (), Matrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
-  MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (), \
-		 ComplexMatrix, m2, v2.complex_matrix_value (), \
-		 m1 (i, j) == m2 (i, j), "==", 0.0);
+  MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (),
+		 ComplexMatrix, m2, v2.complex_matrix_value (),
+		 m1 (i, j) == m2 (i, j), "==",
+		 0.0, 1.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (>=, Matrix ());
+  BOOL_OP (>=, Matrix (), Matrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
-  BOOL_OP (>, Matrix ());
+  BOOL_OP (>, Matrix (), Matrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
-  MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (), \
-		 ComplexMatrix, m2, v2.complex_matrix_value (), \
-		 m1 (i, j) != m2 (i, j), "!=", 1.0);
+  MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (),
+		 ComplexMatrix, m2, v2.complex_matrix_value (),
+		 m1 (i, j) != m2 (i, j), "!=",
+		 1.0, 0.0);
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
   return product (v1.matrix_value (), v2.complex_matrix_value ());
@@ -176,29 +179,31 @@ el_ldiv (const octave_value& a1, const o
   return quotient (v2.complex_matrix_value (), v1.matrix_value ());
 }
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
-  MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (), \
-		 ComplexMatrix, m2, v2.complex_matrix_value (), \
-		 m1 (i, j) && m2 (i, j) != 0.0, "&", Matrix ());
+  MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (),
+		 ComplexMatrix, m2, v2.complex_matrix_value (),
+		 m1 (i, j) && m2 (i, j) != 0.0, "&",
+		 Matrix (), Matrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
 
-  MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (), \
-		 ComplexMatrix, m2, v2.complex_matrix_value (), \
-		 m1 (i, j) || m2 (i, j) != 0.0, "|", Matrix ());
+  MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (),
+		 ComplexMatrix, m2, v2.complex_matrix_value (),
+		 m1 (i, j) || m2 (i, j) != 0.0, "|",
+		 Matrix (), Matrix ());
 }
 
 static octave_value *
 complex_matrix_conv (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_matrix&);
 
   return new octave_complex_matrix (ComplexMatrix (v.matrix_value ()));
diff --git a/src/op-m-cs.cc b/src/op-m-cs.cc
--- a/src/op-m-cs.cc
+++ b/src/op-m-cs.cc
@@ -114,18 +114,18 @@ le (const octave_value& a1, const octave
   BOOL_OP (<=, Matrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
-  MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (), \
-		 Complex, s, v2.complex_value (), \
+  MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (),
+		 Complex, s, v2.complex_value (),
 		 m (i, j) == s, 0.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
@@ -140,18 +140,18 @@ gt (const octave_value& a1, const octave
   BOOL_OP (>, Matrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
-  MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (), \
-		 Complex, s, v2.complex_value (), \
+  MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (),
+		 Complex, s, v2.complex_value (),
 		 m (i, j) != s, 1.0);
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
@@ -187,28 +187,28 @@ el_ldiv (const octave_value& a1, const o
   return x_el_div (v2.complex_value (), v1.matrix_value ());
 }
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
-  MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (), \
-		 Complex, s, v2.complex_value (), \
+  MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (),
+		 Complex, s, v2.complex_value (),
 		 m (i, j) && s != 0.0, Matrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex&);
 
-  MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (), \
-		 Complex, s, v2.complex_value (), \
+  MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (),
+		 Complex, s, v2.complex_value (),
 		 m (i, j) || s != 0.0, Matrix ());
 }
 
 static octave_value *
 complex_matrix_conv (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_matrix&);
 
diff --git a/src/op-m-m.cc b/src/op-m-m.cc
--- a/src/op-m-m.cc
+++ b/src/op-m-m.cc
@@ -81,67 +81,68 @@ pow (const octave_value&, const octave_v
 static octave_value
 ldiv (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
   return xleftdiv (v1.matrix_value (), v2.matrix_value ());
 }
 
-#define BOOL_OP(OP, EMPTY_RESULT) \
+#define BOOL_OP(OP, ONE_EMPTY_RESULT, TWO_EMPTY_RESULT) \
   MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (), \
 		 Matrix, m2, v2.matrix_value (), \
-		 m1 (i, j) OP m2 (i, j), #OP, EMPTY_RESULT)
+		 m1 (i, j) OP m2 (i, j), #OP, \
+		 ONE_EMPTY_RESULT, TWO_EMPTY_RESULT)
 
 static octave_value
 lt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
-  BOOL_OP (<, Matrix ());
+  BOOL_OP (<, Matrix (), Matrix ());
 }
 
 static octave_value
 le (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
-  BOOL_OP (<=, Matrix ());
+  BOOL_OP (<=, Matrix (), Matrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
-  BOOL_OP (==, 1.0);
+  BOOL_OP (==, 0.0, 1.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
-  BOOL_OP (>=, Matrix ());
+  BOOL_OP (>=, Matrix (), Matrix ());
 }
 
 static octave_value
 gt (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
-  BOOL_OP (>, Matrix ());
+  BOOL_OP (>, Matrix (), Matrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
-  BOOL_OP (!=, 0.0);
+  BOOL_OP (!=, 1.0, 0.0);
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
   return octave_value (product (v1.matrix_value (), v2.matrix_value ()));
@@ -171,29 +172,31 @@ el_ldiv (const octave_value& a1, const o
   return octave_value (quotient (v2.matrix_value (), v1.matrix_value ()));
 }
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
-  MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (), \
-		 Matrix, m2, v2.matrix_value (), \
-		 m1 (i, j) && m2 (i, j), "&", Matrix ());
+  MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (),
+		 Matrix, m2, v2.matrix_value (),
+		 m1 (i, j) && m2 (i, j), "&",
+		 Matrix (), Matrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
 
-  MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (), \
-		 Matrix, m2, v2.matrix_value (), \
-		 m1 (i, j) || m2 (i, j), "|", Matrix ());
+  MX_MX_BOOL_OP (Matrix, m1, v1.matrix_value (),
+		 Matrix, m2, v2.matrix_value (),
+		 m1 (i, j) || m2 (i, j), "|",
+		 Matrix (), Matrix ());
 }
 
 static octave_value
 assign (octave_value& a1, const octave_value_list& idx,
 	const octave_value& a2)
 {
   CAST_BINOP_ARGS (octave_matrix&, const octave_matrix&);
 
diff --git a/src/op-m-s.cc b/src/op-m-s.cc
--- a/src/op-m-s.cc
+++ b/src/op-m-s.cc
@@ -182,28 +182,28 @@ el_ldiv (const octave_value& a1, const o
   return x_el_div (v2.double_value (), v1.matrix_value ());
 }
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
-  MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (), \
-                 double, s, v2.double_value (), \
+  MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (),
+                 double, s, v2.double_value (),
 		 m (i, j) && s, Matrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_scalar&);
 
-  MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (), \
-                 double, s, v2.double_value (), \
+  MX_SC_BOOL_OP (Matrix, m, v1.matrix_value (),
+                 double, s, v2.double_value (),
 		 m (i, j) || s, Matrix ());
 }
 
 static octave_value
 assign (octave_value& a1, const octave_value_list& idx,
 	const octave_value& a2)
 {
   CAST_BINOP_ARGS (octave_matrix&, const octave_scalar&);
diff --git a/src/op-s-cm.cc b/src/op-s-cm.cc
--- a/src/op-s-cm.cc
+++ b/src/op-s-cm.cc
@@ -113,18 +113,18 @@ le (const octave_value& a1, const octave
   BOOL_OP (<=, Matrix ());
 }
 
 static octave_value
 eq (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
-  SC_MX_BOOL_OP (double, s, v1.double_value (), \
-		 ComplexMatrix, m, v2.complex_matrix_value (), \
+  SC_MX_BOOL_OP (double, s, v1.double_value (),
+		 ComplexMatrix, m, v2.complex_matrix_value (),
 		 s == m (i, j), 0.0);
 }
 
 static octave_value
 ge (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
@@ -139,18 +139,18 @@ gt (const octave_value& a1, const octave
   BOOL_OP (>, Matrix ());
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
-  SC_MX_BOOL_OP (double, s, v1.double_value (), \
-		 ComplexMatrix, m, v2.complex_matrix_value (), \
+  SC_MX_BOOL_OP (double, s, v1.double_value (),
+		 ComplexMatrix, m, v2.complex_matrix_value (),
 		 s != m (i, j), 1.0);
 }
 
 static octave_value
 el_mul (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
@@ -186,28 +186,28 @@ el_ldiv (const octave_value& a1, const o
   return octave_value (v2.complex_matrix_value () / d);
 }
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
-  SC_MX_BOOL_OP (double, s, v1.double_value (), \
-		 ComplexMatrix, m, v2.complex_matrix_value (), \
+  SC_MX_BOOL_OP (double, s, v1.double_value (),
+		 ComplexMatrix, m, v2.complex_matrix_value (),
 		 s && m (i, j) != 0.0, Matrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_complex_matrix&);
 
-  SC_MX_BOOL_OP (double, s, v1.double_value (), \
-		 ComplexMatrix, m, v2.complex_matrix_value (), \
+  SC_MX_BOOL_OP (double, s, v1.double_value (),
+		 ComplexMatrix, m, v2.complex_matrix_value (),
 		 s || m (i, j) != 0.0, Matrix ());
 }
 
 static octave_value *
 complex_matrix_conv (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_scalar&);
 
diff --git a/src/op-s-m.cc b/src/op-s-m.cc
--- a/src/op-s-m.cc
+++ b/src/op-s-m.cc
@@ -182,28 +182,28 @@ el_ldiv (const octave_value& a1, const o
   return octave_value (v2.matrix_value () / d);
 }
 
 static octave_value
 el_and (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
-  SC_MX_BOOL_OP (double, s, v1.double_value (), \
-                 Matrix, m, v2.matrix_value (), \
+  SC_MX_BOOL_OP (double, s, v1.double_value (),
+                 Matrix, m, v2.matrix_value (),
 		 s && m (i, j), Matrix ());
 }
 
 static octave_value
 el_or (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_matrix&);
 
-  SC_MX_BOOL_OP (double, s, v1.double_value (), \
-                 Matrix, m, v2.matrix_value (), \
+  SC_MX_BOOL_OP (double, s, v1.double_value (),
+                 Matrix, m, v2.matrix_value (),
 		 s || m (i, j), Matrix ());
 }
 
 static octave_value *
 matrix_conv (const octave_value& a)
 {
   CAST_CONV_ARG (const octave_scalar&);
 
diff --git a/src/op-str-str.cc b/src/op-str-str.cc
--- a/src/op-str-str.cc
+++ b/src/op-str-str.cc
@@ -58,17 +58,17 @@ eq (const octave_value& a1, const octave
       int cm2_nr = cm2.rows ();
       int cm2_nc = cm2.cols ();
 
       if (cm2_nr == 1 && cm2_nc == 1)
 	MX_SC_BOOL_OP (charMatrix, m, cm1, char, c, cm2 (0, 0),
 		       c == m (i, j), 0.0);
       else
 	MX_MX_BOOL_OP (charMatrix, m1, cm1, charMatrix, m2, cm2,
-		       m1 (i, j) == m2 (i, j), "==", 0.0);
+		       m1 (i, j) == m2 (i, j), "==", 0.0, 1.0);
     }
 }
 
 static octave_value
 ne (const octave_value& a1, const octave_value& a2)
 {
   CAST_BINOP_ARGS (const octave_char_matrix_str&,
 		   const octave_char_matrix_str&);
@@ -76,31 +76,27 @@ ne (const octave_value& a1, const octave
   charMatrix cm1 = v1.char_matrix_value ();
   charMatrix cm2 = v2.char_matrix_value ();
 
   if (cm1.rows () == 1 && cm1.columns () == 1)
     {
       if (cm2.rows () == 1 && cm2.columns () == 1)
 	return octave_value (cm1 (0, 0) != cm2 (0, 0));
       else
-	SC_MX_BOOL_OP (char, c, cm1 (0, 0), \
-		       charMatrix, m, cm2, \
+	SC_MX_BOOL_OP (char, c, cm1 (0, 0), charMatrix, m, cm2,
 		       c != m (i, j), 1.0);
     }
   else
     {
       if (cm2.rows () == 1 && cm2.columns () == 1)
-	MX_SC_BOOL_OP (charMatrix, m, cm1, \
-		       char, c, cm2 (0, 0), \
+	MX_SC_BOOL_OP (charMatrix, m, cm1, char, c, cm2 (0, 0),
 		       c != m (i, j), 1.0);
       else
-	MX_MX_BOOL_OP (charMatrix, m1, cm1, \
-		       charMatrix, m2, cm2, \
-		       m1 (i, j) != m2 (i, j), \
-		       "!=", 1.0);
+	MX_MX_BOOL_OP (charMatrix, m1, cm1, charMatrix, m2, cm2,
+		       m1 (i, j) != m2 (i, j), "!=", 1.0, 0.0);
     }
 }
 
 static octave_value
 assign (octave_value& a1, const octave_value_list& idx,
 	const octave_value& a2)
 {
   CAST_BINOP_ARGS (octave_char_matrix_str&, const octave_char_matrix_str&);
diff --git a/src/ops.h b/src/ops.h
--- a/src/ops.h
+++ b/src/ops.h
@@ -78,33 +78,45 @@ extern void install_ops (void);
       BOOL_OP2 (mn) \
       if (nr == 0 || nc == 0) \
         return empty_result; \
       BOOL_OP3 (test) \
     } \
   while (0)
 
 #define MX_MX_BOOL_OP(m1t, m1n, get_m1, m2t, m2n, get_m2, test, op, \
-		      empty_result) \
+		      one_empty_result, two_empty_result) \
   do \
     { \
       BOOL_OP1 (m1t, m1n, get_m1, m2t, m2n, get_m2) \
       int m1_nr = m1n.rows (); \
       int m1_nc = m1n.cols (); \
       int m2_nr = m2n.rows (); \
       int m2_nc = m2n.cols (); \
-      if (m1_nr != m2_nr || m1_nc != m2_nc) \
+      if (m1_nr == m2_nr && m1_nc == m2_nc) \
 	{ \
-	  gripe_nonconformant ("operator " op, m1_nr, m1_nc, m2_nr, m2_nc); \
-	  return Matrix (); \
+	  if (m1_nr == 0 && m1_nc == 0) \
+	    return two_empty_result; \
+	  else \
+	    { \
+	      BOOL_OP2 (m1n) \
+	      BOOL_OP3 (test) \
+	    } \
 	} \
-      if (m1_nr == 0 || m1_nc == 0) \
-	return empty_result; \
-      BOOL_OP2 (m1n) \
-      BOOL_OP3 (test) \
+      else \
+	{ \
+	  if ((m1_nr == 0 && m1_nc == 0) || (m2_nr == 0 && m2_nc == 0)) \
+	    return one_empty_result; \
+	  else \
+	    { \
+	      gripe_nonconformant ("operator " op, m1_nr, m1_nc, \
+				   m2_nr, m2_nc); \
+	      return Matrix (); \
+	    } \
+	} \
     } \
   while (0)
 
 #define CAST_BINOP_ARGS(t1, t2) \
   t1 v1 = DYNAMIC_CAST (t1, a1); \
   t2 v2 = DYNAMIC_CAST (t2, a2);
 
 #define CAST_CONV_ARG(t) \
