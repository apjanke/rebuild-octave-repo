# HG changeset patch
# User Rik <rik@octave.org>
# Date 1481237452 28800
#      Thu Dec 08 14:50:52 2016 -0800
# Node ID 551ac93c984c19d89c0601d22871d1d075ac75e5
# Parent  50495eeb5df10304169e663ed7e803744ddd5240
maint: Use C++ range feature to simplify some for loops in libinterp/parse-tree

* lex.ll, oct-parse.in.yy, pt-arg-list.cc, pt-array-list.cc, pt-assign.cc,
pt-bp.cc, pt-cell.cc, pt-check.cc, pt-decl.cc, pt-eval.cc, pt-idx.cc,
pt-mat.cc, pt-misc.cc, pt-pr-code.cc, pt-select.cc, pt-stmt.cc:
Use C++ range feature to simplify some for loops.

diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -2212,21 +2212,18 @@ namespace octave
 
     if (tok && tok->is_symbol ())
       pending_local_variables.insert (tok->symbol_name ());
   }
 
   void
   lexical_feedback::mark_as_variables (const std::list<std::string>& lst)
   {
-    for (std::list<std::string>::const_iterator p = lst.begin ();
-         p != lst.end (); p++)
-      {
-        pending_local_variables.insert (*p);
-      }
+    for (const auto& var : lst)
+      pending_local_variables.insert (var);
   }
 }
 
 static bool
 looks_like_copyright (const std::string& s)
 {
   bool retval = false;
 
@@ -2452,20 +2449,19 @@ namespace octave
     return (c == ' ' || c == '\t');
   }
 
   bool
   base_lexer::inside_any_object_index (void)
   {
     bool retval = false;
 
-    for (std::list<bool>::const_iterator i = looking_at_object_index.begin ();
-         i != looking_at_object_index.end (); i++)
+    for (const bool is_obj_idx : looking_at_object_index)
       {
-        if (*i)
+        if (is_obj_idx)
           {
             retval = true;
             break;
           }
       }
 
     return retval;
   }
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -3054,21 +3054,18 @@ namespace octave
         delete lhs;
 
         return new tree_simple_assignment (tmp, rhs, false, l, c, t);
       }
     else
       {
         std::list<std::string> names = lhs->variable_names ();
 
-        for (std::list<std::string>::const_iterator it = names.begin ();
-             it != names.end (); it++)
+        for (const auto& kw : names)
           {
-            std::string kw = *it;
-
             if (is_keyword (kw))
               {
                 delete lhs;
                 delete rhs;
 
                 bison_error ("invalid assignment to keyword \"" + kw + "\"",
                              l, c);
 
@@ -3756,20 +3753,18 @@ namespace octave
 
   bool
   base_parser::validate_array_list (tree_expression *e)
   {
     bool retval = true;
 
     tree_array_list *al = dynamic_cast<tree_array_list *> (e);
 
-    for (tree_array_list::iterator i = al->begin (); i != al->end (); i++)
+    for (tree_argument_list* row : *al)
       {
-        tree_argument_list *row = *i;
-
         if (row && row->has_magic_tilde ())
           {
             retval = false;
 
             if (e->is_matrix ())
               bison_error ("invalid use of tilde (~) in matrix expression");
             else
               bison_error ("invalid use of tilde (~) in cell expression");
@@ -4304,32 +4299,30 @@ lookup_autoload (const std::string& nm)
 }
 
 string_vector
 autoloaded_functions (void)
 {
   string_vector names (autoload_map.size ());
 
   octave_idx_type i = 0;
-  typedef std::map<std::string, std::string>::const_iterator am_iter;
-  for (am_iter p = autoload_map.begin (); p != autoload_map.end (); p++)
-    names[i++] = p->first;
+  for (const auto& fcn_fname : autoload_map)
+    names[i++] = fcn_fname.first;
 
   return names;
 }
 
 string_vector
 reverse_lookup_autoload (const std::string& nm)
 {
   string_vector names;
 
-  typedef std::map<std::string, std::string>::const_iterator am_iter;
-  for (am_iter p = autoload_map.begin (); p != autoload_map.end (); p++)
-    if (nm == p->second)
-      names.append (p->first);
+  for (const auto& fcn_fname : autoload_map)
+    if (nm == fcn_fname.second)
+      names.append (fcn_fname.first);
 
   return names;
 }
 
 octave_function *
 load_fcn_from_file (const std::string& file_name, const std::string& dir_name,
                     const std::string& dispatch_type,
                     const std::string& package_name,
@@ -4461,21 +4454,20 @@ not loaded anymore during the current Oc
     print_usage ();
 
   if (nargin == 0)
     {
       Cell func_names (dim_vector (autoload_map.size (), 1));
       Cell file_names (dim_vector (autoload_map.size (), 1));
 
       octave_idx_type i = 0;
-      typedef std::map<std::string, std::string>::const_iterator am_iter;
-      for (am_iter p = autoload_map.begin (); p != autoload_map.end (); p++)
+      for (const auto& fcn_fname : autoload_map)
         {
-          func_names(i) = p->first;
-          file_names(i) = p->second;
+          func_names(i) = fcn_fname.first;
+          file_names(i) = fcn_fname.second;
 
           i++;
         }
 
       octave_map m;
 
       m.assign ("function", func_names);
       m.assign ("file", file_names);
diff --git a/libinterp/parse-tree/pt-arg-list.cc b/libinterp/parse-tree/pt-arg-list.cc
--- a/libinterp/parse-tree/pt-arg-list.cc
+++ b/libinterp/parse-tree/pt-arg-list.cc
@@ -54,20 +54,18 @@ tree_argument_list::~tree_argument_list 
       delete *p;
       erase (p);
     }
 }
 
 bool
 tree_argument_list::has_magic_end (void) const
 {
-  for (const_iterator p = begin (); p != end (); p++)
+  for (const tree_expression* elt : *this)
     {
-      tree_expression *elt = *p;
-
       if (elt && elt->has_magic_end ())
         return true;
     }
 
   return false;
 }
 
 void
@@ -83,40 +81,35 @@ tree_argument_list::append (const elemen
       tree_identifier *id = dynamic_cast<tree_identifier *> (s);
       list_includes_magic_tilde = id && id->is_black_hole ();
     }
 }
 
 bool
 tree_argument_list::all_elements_are_constant (void) const
 {
-  for (const_iterator p = begin (); p != end (); p++)
+  for (const tree_expression* elt : *this)
     {
-      tree_expression *elt = *p;
-
       if (! elt->is_constant ())
         return false;
     }
 
   return true;
 }
 
 bool
 tree_argument_list::is_valid_lvalue_list (void) const
 {
   bool retval = true;
 
-  for (const_iterator p = begin (); p != end (); p++)
+  for (const tree_expression* elt : *this)
     {
-      tree_expression *elt = *p;
-
-      // There is no need for a separate check for the magic "~" because
-      // it represented by tree_black_hole, and that is derived from
+      // There is no need for a separate check for the magic "~" because it
+      // is represented by tree_black_hole, and that is derived from
       // tree_identifier.
-
       if (! (elt->is_identifier () || elt->is_index_expression ()))
         {
           retval = false;
           break;
         }
     }
 
   return retval;
@@ -261,56 +254,44 @@ tree_argument_list::convert_to_const_vec
   return args;
 }
 
 std::list<octave_lvalue>
 tree_argument_list::lvalue_list (void)
 {
   std::list<octave_lvalue> retval;
 
-  for (tree_argument_list::iterator p = begin ();
-       p != end ();
-       p++)
-    {
-      tree_expression *elt = *p;
-
-      retval.push_back (elt->lvalue ());
-    }
+  for (tree_expression* elt : *this)
+    retval.push_back (elt->lvalue ());
 
   return retval;
 }
 
 string_vector
 tree_argument_list::get_arg_names (void) const
 {
   int len = length ();
 
   string_vector retval (len);
 
   int k = 0;
 
-  for (const_iterator p = begin (); p != end (); p++)
-    {
-      tree_expression *elt = *p;
-
-      retval(k++) = elt->str_print_code ();
-    }
+  for (tree_expression* elt : *this)
+    retval(k++) = elt->str_print_code ();
 
   return retval;
 }
 
 std::list<std::string>
 tree_argument_list::variable_names (void) const
 {
   std::list<std::string> retval;
 
-  for (const_iterator p = begin (); p != end (); p++)
+  for (tree_expression* elt : *this)
     {
-      tree_expression *elt = *p;
-
       if (elt->is_identifier ())
         {
           tree_identifier *id = dynamic_cast<tree_identifier *> (elt);
 
           retval.push_back (id->name ());
         }
       else if (elt->is_index_expression ())
         {
@@ -328,22 +309,18 @@ tree_argument_list *
 tree_argument_list::dup (symbol_table::scope_id scope,
                          symbol_table::context_id context) const
 {
   tree_argument_list *new_list = new tree_argument_list ();
 
   new_list->list_includes_magic_end = list_includes_magic_end;
   new_list->simple_assign_lhs = simple_assign_lhs;
 
-  for (const_iterator p = begin (); p != end (); p++)
-    {
-      const tree_expression *elt = *p;
-
-      new_list->append (elt ? elt->dup (scope, context) : 0);
-    }
+  for (const tree_expression* elt : *this)
+    new_list->append (elt ? elt->dup (scope, context) : 0);
 
   return new_list;
 }
 
 void
 tree_argument_list::accept (tree_walker& tw)
 {
   tw.visit_argument_list (*this);
diff --git a/libinterp/parse-tree/pt-array-list.cc b/libinterp/parse-tree/pt-array-list.cc
--- a/libinterp/parse-tree/pt-array-list.cc
+++ b/libinterp/parse-tree/pt-array-list.cc
@@ -37,38 +37,34 @@ tree_array_list::~tree_array_list (void)
       delete *p;
       erase (p);
     }
 }
 
 bool
 tree_array_list::all_elements_are_constant (void) const
 {
-  for (const_iterator p = begin (); p != end (); p++)
+  for (const tree_argument_list* elt : *this)
     {
       octave_quit ();
 
-      tree_argument_list *elt = *p;
-
       if (! elt->all_elements_are_constant ())
         return false;
     }
 
   return true;
 }
 
 bool
 tree_array_list::has_magic_end (void) const
 {
-  for (const_iterator p = begin (); p != end (); p++)
+  for (const tree_argument_list* elt : *this)
     {
       octave_quit ();
 
-      tree_argument_list *elt = *p;
-
       if (elt && elt->has_magic_end ())
         return true;
     }
 
   return false;
 }
 
 void
@@ -77,22 +73,18 @@ tree_array_list::copy_base (const tree_a
   tree_expression::copy_base (array_list);
 }
 
 void
 tree_array_list::copy_base (const tree_array_list& array_list,
                             symbol_table::scope_id scope,
                             symbol_table::context_id context)
 {
-  for (const_iterator p = array_list.begin (); p != array_list.end (); p++)
-    {
-      const tree_argument_list *elt = *p;
-
-      append (elt ? elt->dup (scope, context) : 0);
-    }
+  for (const tree_argument_list* elt : array_list)
+    append (elt ? elt->dup (scope, context) : 0);
 
   copy_base (*this);
 }
 
 tree_expression *
 tree_array_list::dup (symbol_table::scope_id,
                       symbol_table::context_id) const
 {
diff --git a/libinterp/parse-tree/pt-assign.cc b/libinterp/parse-tree/pt-assign.cc
--- a/libinterp/parse-tree/pt-assign.cc
+++ b/libinterp/parse-tree/pt-assign.cc
@@ -196,20 +196,18 @@ tree_multi_assignment::rvalue (int)
   octave_value_list retval;
 
   if (rhs)
     {
       std::list<octave_lvalue> lvalue_list = lhs->lvalue_list ();
 
       octave_idx_type n_out = 0;
 
-      for (std::list<octave_lvalue>::const_iterator p = lvalue_list.begin ();
-           p != lvalue_list.end ();
-           p++)
-        n_out += p->numel ();
+      for (const auto& lval : lvalue_list)
+        n_out += lval.numel ();
 
       // The following trick is used to keep rhs_val constant.
       const octave_value_list rhs_val1 = rhs->rvalue (n_out, &lvalue_list);
       const octave_value_list rhs_val = (rhs_val1.length () == 1
                                          && rhs_val1(0).is_cs_list ()
                                          ? rhs_val1(0).list_value ()
                                          : rhs_val1);
 
@@ -218,24 +216,20 @@ tree_multi_assignment::rvalue (int)
       octave_idx_type n = rhs_val.length ();
 
       // To avoid copying per elements and possible optimizations, we
       // postpone joining the final values.
       std::list<octave_value_list> retval_list;
 
       tree_argument_list::iterator q = lhs->begin ();
 
-      for (std::list<octave_lvalue>::iterator p = lvalue_list.begin ();
-           p != lvalue_list.end ();
-           p++)
+      for (octave_lvalue ult : lvalue_list)
         {
           tree_expression *lhs_elt = *q++;
 
-          octave_lvalue ult = *p;
-
           octave_idx_type nel = ult.numel ();
 
           if (nel != 1)
             {
               // Huge kluge so that wrapper scripts with lines like
               //
               //   [varargout{1:nargout}] = fcn (args);
               //
diff --git a/libinterp/parse-tree/pt-bp.cc b/libinterp/parse-tree/pt-bp.cc
--- a/libinterp/parse-tree/pt-bp.cc
+++ b/libinterp/parse-tree/pt-bp.cc
@@ -218,20 +218,18 @@ tree_breakpoint::visit_if_command (tree_
 
   if (lst)
     lst->accept (*this);
 }
 
 void
 tree_breakpoint::visit_if_command_list (tree_if_command_list& lst)
 {
-  for (tree_if_command_list::iterator p = lst.begin (); p != lst.end (); p++)
+  for (tree_if_clause* t : lst)
     {
-      tree_if_clause *t = *p;
-
       if (t->line () >= line)
         take_action (*t);
 
       if (! found)
         {
           tree_statement_list *stmt_lst = t->commands ();
 
           if (stmt_lst)
@@ -347,25 +345,23 @@ tree_breakpoint::visit_statement (tree_s
   else
     {
       if (stmt.line () >= line)
         take_action (stmt);
     }
 }
 
 // Called by
-//      tree_statement_list::set_breakpoint (int line, std::string& condition)
-// with  lst  consisting of a user function in which to set a breakpoint.
+//   tree_statement_list::set_breakpoint (int line, std::string& condition)
+// with <lst> consisting of a user function in which to set a breakpoint.
 void
 tree_breakpoint::visit_statement_list (tree_statement_list& lst)
 {
-  for (tree_statement_list::iterator p = lst.begin (); p != lst.end (); p++)
+  for (tree_statement* elt : lst)
     {
-      tree_statement *elt = *p;
-
       if (elt)
         {
           elt->accept (*this);
 
           if (found)
             break;
         }
     }
@@ -375,20 +371,18 @@ void
 tree_breakpoint::visit_switch_case (tree_switch_case&)
 {
   panic_impossible ();
 }
 
 void
 tree_breakpoint::visit_switch_case_list (tree_switch_case_list& lst)
 {
-  for (tree_switch_case_list::iterator p = lst.begin (); p != lst.end (); p++)
+  for (tree_switch_case* t : lst)
     {
-      tree_switch_case *t = *p;
-
       if (t->line () >= line)
         take_action (*t);
 
       if (! found)
         {
           tree_statement_list *stmt_lst = t->commands ();
 
           if (stmt_lst)
diff --git a/libinterp/parse-tree/pt-cell.cc b/libinterp/parse-tree/pt-cell.cc
--- a/libinterp/parse-tree/pt-cell.cc
+++ b/libinterp/parse-tree/pt-cell.cc
@@ -41,20 +41,18 @@ tree_cell::rvalue1 (int)
 
   octave_idx_type nr = length ();
   octave_idx_type nc = -1;
 
   Cell val;
 
   octave_idx_type i = 0;
 
-  for (iterator p = begin (); p != end (); p++)
+  for (tree_argument_list* elt : *this)
     {
-      tree_argument_list *elt = *p;
-
       octave_value_list row = elt->convert_to_const_vector ();
 
       if (nr == 1)
         // Optimize the single row case.
         val = row.cell_value ();
       else if (nc < 0)
         {
           nc = row.length ();
diff --git a/libinterp/parse-tree/pt-check.cc b/libinterp/parse-tree/pt-check.cc
--- a/libinterp/parse-tree/pt-check.cc
+++ b/libinterp/parse-tree/pt-check.cc
@@ -434,20 +434,18 @@ tree_checker::visit_statement (tree_stat
       if (expr)
         expr->accept (*this);
     }
 }
 
 void
 tree_checker::visit_statement_list (tree_statement_list& lst)
 {
-  for (tree_statement_list::iterator p = lst.begin (); p != lst.end (); p++)
+  for (tree_statement* elt : lst)
     {
-      tree_statement *elt = *p;
-
       if (elt)
         elt->accept (*this);
     }
 }
 
 void
 tree_checker::visit_switch_case (tree_switch_case& cs)
 {
diff --git a/libinterp/parse-tree/pt-decl.cc b/libinterp/parse-tree/pt-decl.cc
--- a/libinterp/parse-tree/pt-decl.cc
+++ b/libinterp/parse-tree/pt-decl.cc
@@ -81,22 +81,18 @@ tree_decl_elt::accept (tree_walker& tw)
 // Initializer lists for declaration statements.
 
 tree_decl_init_list *
 tree_decl_init_list::dup (symbol_table::scope_id scope,
                           symbol_table::context_id context) const
 {
   tree_decl_init_list *new_dil = new tree_decl_init_list ();
 
-  for (const_iterator p = begin (); p != end (); p++)
-    {
-      const tree_decl_elt *elt = *p;
-
-      new_dil->append (elt ? elt->dup (scope, context) : 0);
-    }
+  for (const tree_decl_elt* elt : *this)
+    new_dil->append (elt ? elt->dup (scope, context) : 0);
 
   return new_dil;
 }
 
 void
 tree_decl_init_list::accept (tree_walker& tw)
 {
   tw.visit_decl_init_list (*this);
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -193,23 +193,18 @@ do_static_init (tree_decl_elt& elt)
 namespace octave
 {
   void
   tree_evaluator::do_decl_init_list (decl_elt_init_fcn fcn,
                                      tree_decl_init_list *init_list)
   {
     if (init_list)
       {
-        for (tree_decl_init_list::iterator p = init_list->begin ();
-             p != init_list->end (); p++)
-          {
-            tree_decl_elt *elt = *p;
-
-            fcn (*elt);
-          }
+        for (tree_decl_elt* elt : *init_list)
+          fcn (*elt);
       }
   }
 
   void
   tree_evaluator::visit_global_command (tree_global_command& cmd)
   {
     if (debug_mode)
       do_breakpoint (cmd.is_breakpoint (true));
@@ -507,20 +502,18 @@ namespace octave
 
     if (lst)
       lst->accept (*this);
   }
 
   void
   tree_evaluator::visit_if_command_list (tree_if_command_list& lst)
   {
-    for (tree_if_command_list::iterator p = lst.begin (); p != lst.end (); p++)
+    for (tree_if_clause* tic : lst)
       {
-        tree_if_clause *tic = *p;
-
         tree_expression *expr = tic->condition ();
 
         if (statement_context == function || statement_context == script)
           octave_call_stack::set_location (tic->line (), tic->column ());
 
         if (debug_mode && ! tic->is_else_clause ())
           do_breakpoint (tic->is_breakpoint (true));
 
@@ -788,21 +781,18 @@ namespace octave
              cmd.line (), cmd.column ());
 
     octave_value val = expr->rvalue1 ();
 
     tree_switch_case_list *lst = cmd.case_list ();
 
     if (lst)
       {
-        for (tree_switch_case_list::iterator p = lst->begin ();
-             p != lst->end (); p++)
+        for (tree_switch_case* t : *lst)
           {
-            tree_switch_case *t = *p;
-
             if (t->is_default_case () || t->label_matches (val))
               {
                 tree_statement_list *stmt_lst = t->commands ();
 
                 if (stmt_lst)
                   stmt_lst->accept (*this);
 
                 break;
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -120,22 +120,18 @@ tree_index_expression::~tree_index_expre
       delete *p;
       dyn_field.erase (p);
     }
 }
 
 bool
 tree_index_expression::has_magic_end (void) const
 {
-  for (std::list<tree_argument_list *>::const_iterator p = args.begin ();
-       p != args.end ();
-       p++)
+  for (const tree_argument_list* elt : args)
     {
-      tree_argument_list *elt = *p;
-
       if (elt && elt->has_magic_end ())
         return true;
     }
 
   return false;
 }
 
 // This is useful for printing the name of the variable in an indexed
@@ -661,41 +657,29 @@ tree_index_expression::dup (symbol_table
 {
   tree_index_expression *new_idx_expr
     = new tree_index_expression (line (), column ());
 
   new_idx_expr->expr = expr ? expr->dup (scope, context) : 0;
 
   std::list<tree_argument_list *> new_args;
 
-  for (std::list<tree_argument_list *>::const_iterator p = args.begin ();
-       p != args.end ();
-       p++)
-    {
-      const tree_argument_list *elt = *p;
-
-      new_args.push_back (elt ? elt->dup (scope, context) : 0);
-    }
+  for (const tree_argument_list* elt : args)
+    new_args.push_back (elt ? elt->dup (scope, context) : 0);
 
   new_idx_expr->args = new_args;
 
   new_idx_expr->type = type;
 
   new_idx_expr->arg_nm = arg_nm;
 
   std::list<tree_expression *> new_dyn_field;
 
-  for (std::list<tree_expression *>::const_iterator p = dyn_field.begin ();
-       p != dyn_field.end ();
-       p++)
-    {
-      const tree_expression *elt = *p;
-
-      new_dyn_field.push_back (elt ? elt->dup (scope, context) : 0);
-    }
+  for (const tree_expression* elt : dyn_field)
+    new_dyn_field.push_back (elt ? elt->dup (scope, context) : 0);
 
   new_idx_expr->dyn_field = new_dyn_field;
 
   new_idx_expr->copy_base (*this);
 
   return new_idx_expr;
 }
 
diff --git a/libinterp/parse-tree/pt-mat.cc b/libinterp/parse-tree/pt-mat.cc
--- a/libinterp/parse-tree/pt-mat.cc
+++ b/libinterp/parse-tree/pt-mat.cc
@@ -347,24 +347,20 @@ tm_row_const::tm_row_const_rep::init (co
   all_real = true;
   all_cmplx = true;
   any_cell = false;
   any_sparse = false;
   any_class = false;
 
   bool first_elem = true;
 
-  for (tree_argument_list::const_iterator p = row.begin ();
-       p != row.end ();
-       p++)
+  for (tree_expression* elt : row)
     {
       octave_quit ();
 
-      tree_expression *elt = *p;
-
       octave_value tmp = elt->rvalue1 ();
 
       if (tmp.is_undefined ())
         {
           ok = true;
           return;
         }
       else
@@ -385,22 +381,20 @@ tm_row_const::tm_row_const_rep::init (co
         }
     }
 
   if (any_cell && ! any_class && ! first_elem_is_struct)
     cellify ();
 
   first_elem = true;
 
-  for (iterator p = begin (); p != end (); p++)
+  for (const octave_value& val : *this)
     {
       octave_quit ();
 
-      octave_value val = *p;
-
       dim_vector this_elt_dv = val.dims ();
 
       if (! this_elt_dv.zero_by_zero ())
         {
           all_mt = false;
 
           if (first_elem)
             {
@@ -415,41 +409,39 @@ tm_row_const::tm_row_const_rep::init (co
   ok = true;
 }
 
 void
 tm_row_const::tm_row_const_rep::cellify (void)
 {
   bool elt_changed = false;
 
-  for (iterator p = begin (); p != end (); p++)
+  for (auto& elt : *this)
     {
       octave_quit ();
 
-      if (! p->is_cell ())
+      if (! elt.is_cell ())
         {
           elt_changed = true;
 
-          if (p->is_empty ())
-            *p = Cell ();
+          if (elt.is_empty ())
+            elt = Cell ();
           else
-            *p = Cell (*p);
+            elt = Cell (elt);
         }
     }
 
   if (elt_changed)
     {
       bool first_elem = true;
 
-      for (iterator p = begin (); p != end (); p++)
+      for (const octave_value& val : *this)
         {
           octave_quit ();
 
-          octave_value val = *p;
-
           dim_vector this_elt_dv = val.dims ();
 
           if (! this_elt_dv.zero_by_zero ())
             {
               if (first_elem)
                 {
                   first_elem = false;
                   dv = this_elt_dv;
@@ -536,27 +528,23 @@ tm_const::init (const tree_matrix& tm)
   any_cell = false;
   any_sparse = false;
   any_class = false;
   all_1x1 = ! tm.empty ();
 
   bool first_elem = true;
   bool first_elem_is_struct = false;
 
-  // Just eval and figure out if what we have is complex or all
-  // strings.  We can't check columns until we know that this is a
-  // numeric matrix -- collections of strings can have elements of
-  // different lengths.
-
-  for (tree_matrix::const_iterator p = tm.begin (); p != tm.end (); p++)
+  // Just eval and figure out if what we have is complex or all strings.
+  // We can't check columns until we know that this is a numeric matrix --
+  // collections of strings can have elements of different lengths.
+  for (const tree_argument_list* elt : tm)
     {
       octave_quit ();
 
-      tree_argument_list *elt = *p;
-
       tm_row_const tmp (*elt);
 
       if (first_elem)
         {
           first_elem_is_struct = tmp.first_elem_struct_p ();
 
           first_elem = false;
         }
@@ -598,32 +586,30 @@ tm_const::init (const tree_matrix& tm)
           append (tmp);
         }
       else
         break;
     }
 
   if (any_cell && ! any_class && ! first_elem_is_struct)
     {
-      for (iterator q = begin (); q != end (); q++)
+      for (auto& elt : *this)
         {
           octave_quit ();
 
-          q->cellify ();
+          elt.cellify ();
         }
     }
 
   first_elem = true;
 
-  for (iterator q = begin (); q != end (); q++)
+  for (tm_row_const& elt : *this)
     {
       octave_quit ();
 
-      tm_row_const elt = *q;
-
       octave_idx_type this_elt_nr = elt.rows ();
       octave_idx_type this_elt_nc = elt.cols ();
 
       std::string this_elt_class_nm = elt.class_name ();
       class_nm = get_concat_class (class_nm, this_elt_class_nm);
 
       dim_vector this_elt_dv = elt.dims ();
 
@@ -671,30 +657,27 @@ maybe_warn_string_concat (bool all_dq_st
 template <typename TYPE, typename T>
 static void
 single_type_concat (Array<T>& result,
                     tm_const& tmp)
 {
   octave_idx_type r = 0;
   octave_idx_type c = 0;
 
-  for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
+  for (tm_row_const& row : tmp)
     {
-      tm_row_const row = *p;
       // Skip empty arrays to allow looser rules.
       if (row.dims ().any_zero ())
         continue;
 
-      for (tm_row_const::iterator q = row.begin ();
-           q != row.end ();
-           q++)
+      for (auto& elt : row)
         {
           octave_quit ();
 
-          TYPE ra = octave_value_extract<TYPE> (*q);
+          TYPE ra = octave_value_extract<TYPE> (elt);
 
           // Skip empty arrays to allow looser rules.
 
           if (! ra.is_empty ())
             {
               result.insert (ra, r, c);
 
               c += ra.columns ();
@@ -725,32 +708,31 @@ single_type_concat (Array<T>& result,
       tm_row_const& row = tmp.front ();
       if (! (equal_types<T, char>::value || equal_types<T, octave_value>::value)
           && row.all_1x1_p ())
         {
           // Optimize all scalars case.
           result.clear (dv);
           assert (static_cast<size_t> (result.numel ()) == row.length ());
           octave_idx_type i = 0;
-          for (tm_row_const::iterator q = row.begin (); q != row.end (); q++)
-            result(i++) = octave_value_extract<T> (*q);
+          for (const auto& elt : row)
+            result(i++) = octave_value_extract<T> (elt);
 
           return;
         }
 
       octave_idx_type ncols = row.length ();
       octave_idx_type i = 0;
       OCTAVE_LOCAL_BUFFER (Array<T>, array_list, ncols);
 
-      for (tm_row_const::iterator q = row.begin (); q != row.end (); q++)
+      for (const auto& elt : row)
         {
           octave_quit ();
 
-          array_list[i] = octave_value_extract<TYPE> (*q);
-          i++;
+          array_list[i++] = octave_value_extract<TYPE> (elt);
         }
 
       result = Array<T>::cat (-2, ncols, array_list);
     }
   else
     {
       result = Array<T> (dv);
       single_type_concat<TYPE> (result, tmp);
@@ -770,28 +752,27 @@ single_type_concat (Sparse<T>& result,
     }
 
   // Sparse matrices require preallocation for efficient indexing; besides,
   // only horizontal concatenation can be efficiently handled by indexing.
   // So we just cat all rows through liboctave, then cat the final column.
   octave_idx_type nrows = tmp.length ();
   octave_idx_type j = 0;
   OCTAVE_LOCAL_BUFFER (Sparse<T>, sparse_row_list, nrows);
-  for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
+  for (tm_row_const& row : tmp)
     {
-      tm_row_const row = *p;
       octave_idx_type ncols = row.length ();
       octave_idx_type i = 0;
       OCTAVE_LOCAL_BUFFER (Sparse<T>, sparse_list, ncols);
 
-      for (tm_row_const::iterator q = row.begin (); q != row.end (); q++)
+      for (auto& elt : row)
         {
           octave_quit ();
 
-          sparse_list[i] = octave_value_extract<TYPE> (*q);
+          sparse_list[i] = octave_value_extract<TYPE> (elt);
           i++;
         }
 
       Sparse<T> stmp = Sparse<T>::cat (-2, ncols, sparse_list);
       sparse_row_list[j] = stmp;
       j++;
     }
 
@@ -808,28 +789,27 @@ single_type_concat (octave_map& result,
     {
       result = octave_map (dv);
       return;
     }
 
   octave_idx_type nrows = tmp.length ();
   octave_idx_type j = 0;
   OCTAVE_LOCAL_BUFFER (octave_map, map_row_list, nrows);
-  for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
+  for (tm_row_const& row : tmp)
     {
-      tm_row_const row = *p;
       octave_idx_type ncols = row.length ();
       octave_idx_type i = 0;
       OCTAVE_LOCAL_BUFFER (MAP, map_list, ncols);
 
-      for (tm_row_const::iterator q = row.begin (); q != row.end (); q++)
+      for (auto& elt : row)
         {
           octave_quit ();
 
-          map_list[i] = octave_value_extract<MAP> (*q);
+          map_list[i] = octave_value_extract<MAP> (elt);
           i++;
         }
 
       octave_map mtmp = octave_map::cat (-2, ncols, map_list);
       map_row_list[j] = mtmp;
       j++;
     }
 
@@ -866,31 +846,29 @@ do_single_type_concat<octave_map> (const
 static octave_value
 do_class_concat (tm_const& tmc)
 {
   octave_value retval;
 
   octave_value_list rows (tmc.length (), octave_value ());
 
   octave_idx_type j = 0;
-  for (tm_const::iterator p = tmc.begin (); p != tmc.end (); p++)
+  for (tm_row_const& tmrc : tmc)
     {
       octave_quit ();
 
-      tm_row_const tmrc = *p;
-
       if (tmrc.length () == 1)
         rows(j++) = *(tmrc.begin ());
       else
         {
           octave_value_list row (tmrc.length (), octave_value ());
 
           octave_idx_type i = 0;
-          for (tm_row_const::iterator q = tmrc.begin (); q != tmrc.end (); q++)
-            row(i++) = *q;
+          for (auto& elt : tmrc)
+            row(i++) = elt;
 
           rows(j++) = do_class_concat (row, "horzcat", 1);
         }
     }
 
   if (rows.length () == 1)
     retval = rows(0);
   else
@@ -1031,28 +1009,25 @@ tree_matrix::rvalue1 (int)
               // with things like [ones(1,4),sprandn(1e8,4,1e-4)]
               if (all_real_p)
                 ctmp = octave_sparse_matrix ().resize (dv);
               else
                 ctmp = octave_sparse_complex_matrix ().resize (dv);
             }
           else
             {
-              for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
+              for (tm_row_const& row : tmp)
                 {
                   octave_quit ();
 
-                  tm_row_const row = *p;
-
-                  for (tm_row_const::iterator q = row.begin ();
-                       q != row.end (); q++)
+                  for (auto& elt : row)
                     {
                       octave_quit ();
 
-                      ctmp = *q;
+                      ctmp = elt;
 
                       if (! ctmp.all_zero_dims ())
                         goto found_non_empty;
                     }
                 }
 
               ctmp = (*(tmp.begin () -> begin ()));
 
@@ -1064,30 +1039,24 @@ tree_matrix::rvalue1 (int)
 
           // Now, extract the values from the individual elements and
           // insert them in the result matrix.
 
           int dv_len = dv.ndims ();
           octave_idx_type ntmp = dv_len > 1 ? dv_len : 2;
           Array<octave_idx_type> ra_idx (dim_vector (ntmp, 1), 0);
 
-          for (tm_const::iterator p = tmp.begin (); p != tmp.end (); p++)
+          for (tm_row_const& row : tmp)
             {
               octave_quit ();
 
-              tm_row_const row = *p;
-
-              for (tm_row_const::iterator q = row.begin ();
-                   q != row.end ();
-                   q++)
+              for (auto& elt : row)
                 {
                   octave_quit ();
 
-                  octave_value elt = *q;
-
                   if (elt.is_empty ())
                     continue;
 
                   ctmp = do_cat_op (ctmp, elt, ra_idx);
 
                   ra_idx (1) += elt.columns ();
                 }
 
diff --git a/libinterp/parse-tree/pt-misc.cc b/libinterp/parse-tree/pt-misc.cc
--- a/libinterp/parse-tree/pt-misc.cc
+++ b/libinterp/parse-tree/pt-misc.cc
@@ -46,34 +46,29 @@ tree_parameter_list::~tree_parameter_lis
       delete *p;
       erase (p);
     }
 }
 
 void
 tree_parameter_list::mark_as_formal_parameters (void)
 {
-  for (iterator p = begin (); p != end (); p++)
-    {
-      tree_decl_elt *elt = *p;
-      elt->mark_as_formal_parameter ();
-    }
+  for (tree_decl_elt* elt : *this)
+    elt->mark_as_formal_parameter ();
 }
 
 bool
 tree_parameter_list::validate (in_or_out type)
 {
   bool retval = true;
 
   std::set<std::string> dict;
 
-  for (iterator p = begin (); p != end (); p++)
+  for (tree_decl_elt* elt : *this)
     {
-      tree_decl_elt *elt = *p;
-
       tree_identifier *id = elt->ident ();
 
       if (id)
         {
           std::string name = id->name ();
 
           if (id->is_black_hole ())
             {
@@ -124,23 +119,21 @@ tree_parameter_list::initialize_undefine
 
   int count = 0;
 
   octave_value tmp = symbol_table::varval (".ignored.");
   const Matrix ignored = tmp.is_defined () ? tmp.matrix_value () : Matrix ();
 
   octave_idx_type k = 0;
 
-  for (iterator p = begin (); p != end (); p++)
+  for (tree_decl_elt* elt : *this)
     {
       if (++count > nargout)
         break;
 
-      tree_decl_elt *elt = *p;
-
       if (! elt->is_variable ())
         {
           if (! warned)
             {
               warned = true;
 
               while (k < ignored.numel ())
                 {
@@ -217,22 +210,18 @@ tree_parameter_list::undefine (void)
     }
 }
 
 std::list<std::string>
 tree_parameter_list::variable_names (void) const
 {
   std::list<std::string> retval;
 
-  for (const_iterator p = begin (); p != end (); p++)
-    {
-      tree_decl_elt *elt = *p;
-
-      retval.push_back (elt->name ());
-    }
+  for (tree_decl_elt* elt : *this)
+    retval.push_back (elt->name ());
 
   return retval;
 }
 
 octave_value_list
 tree_parameter_list::convert_to_const_vector (int nargout,
                                               const Cell& varargout)
 {
@@ -243,55 +232,49 @@ tree_parameter_list::convert_to_const_ve
   if (len == 0)
     return varargout;
   else if (nargout <= len)
     {
       octave_value_list retval (nargout);
 
       int i = 0;
 
-      for (iterator p = begin (); p != end (); p++)
+      for (tree_decl_elt* elt : *this)
         {
-          tree_decl_elt *elt = *p;
           if (elt->is_defined ())
             retval(i++) = elt->rvalue1 ();
           else
             break;
         }
 
       return retval;
     }
   else
     {
       octave_value_list retval (len + vlen);
 
       int i = 0;
 
-      for (iterator p = begin (); p != end (); p++)
-        {
-          tree_decl_elt *elt = *p;
-          retval(i++) = elt->rvalue1 ();
-        }
+      for (tree_decl_elt* elt : *this)
+        retval(i++) = elt->rvalue1 ();
 
       for (octave_idx_type j = 0; j < vlen; j++)
         retval(i++) = varargout(j);
 
       return retval;
     }
 }
 
 bool
 tree_parameter_list::is_defined (void)
 {
   bool status = true;
 
-  for (iterator p = begin (); p != end (); p++)
+  for (tree_decl_elt* elt : *this)
     {
-      tree_decl_elt *elt = *p;
-
       if (! elt->is_variable ())
         {
           status = false;
           break;
         }
     }
 
   return status;
@@ -301,22 +284,18 @@ tree_parameter_list *
 tree_parameter_list::dup (symbol_table::scope_id scope,
                           symbol_table::context_id context) const
 {
   tree_parameter_list *new_list = new tree_parameter_list ();
 
   if (takes_varargs ())
     new_list->mark_varargs ();
 
-  for (const_iterator p = begin (); p != end (); p++)
-    {
-      const tree_decl_elt *elt = *p;
-
-      new_list->append (elt->dup (scope, context));
-    }
+  for (const tree_decl_elt* elt : *this)
+    new_list->append (elt->dup (scope, context));
 
   return new_list;
 }
 
 void
 tree_parameter_list::accept (tree_walker& tw)
 {
   tw.visit_parameter_list (*this);
@@ -335,22 +314,18 @@ tree_return_list::~tree_return_list (voi
 }
 
 tree_return_list *
 tree_return_list::dup (symbol_table::scope_id scope,
                        symbol_table::context_id context) const
 {
   tree_return_list *new_list = new tree_return_list ();
 
-  for (const_iterator p = begin (); p != end (); p++)
-    {
-      const tree_index_expression *elt = *p;
-
-      new_list->append (elt->dup (scope, context));
-    }
+  for (const tree_index_expression* elt : *this)
+    new_list->append (elt->dup (scope, context));
 
   return new_list;
 }
 
 void
 tree_return_list::accept (tree_walker& tw)
 {
   tw.visit_return_list (*this);
diff --git a/libinterp/parse-tree/pt-pr-code.cc b/libinterp/parse-tree/pt-pr-code.cc
--- a/libinterp/parse-tree/pt-pr-code.cc
+++ b/libinterp/parse-tree/pt-pr-code.cc
@@ -895,20 +895,18 @@ tree_print_code::visit_statement (tree_s
             newline ();
         }
     }
 }
 
 void
 tree_print_code::visit_statement_list (tree_statement_list& lst)
 {
-  for (tree_statement_list::iterator p = lst.begin (); p != lst.end (); p++)
+  for (tree_statement* elt : lst)
     {
-      tree_statement *elt = *p;
-
       if (elt)
         elt->accept (*this);
     }
 }
 
 void
 tree_print_code::visit_switch_case (tree_switch_case& cs)
 {
diff --git a/libinterp/parse-tree/pt-select.cc b/libinterp/parse-tree/pt-select.cc
--- a/libinterp/parse-tree/pt-select.cc
+++ b/libinterp/parse-tree/pt-select.cc
@@ -62,22 +62,18 @@ tree_if_clause::accept (tree_walker& tw)
 // List of if commands.
 
 tree_if_command_list *
 tree_if_command_list::dup (symbol_table::scope_id scope,
                            symbol_table::context_id context) const
 {
   tree_if_command_list *new_icl = new tree_if_command_list ();
 
-  for (const_iterator p = begin (); p != end (); p++)
-    {
-      const tree_if_clause *elt = *p;
-
-      new_icl->append (elt ? elt->dup (scope, context) : 0);
-    }
+  for (const tree_if_clause* elt : *this)
+    new_icl->append (elt ? elt->dup (scope, context) : 0);
 
   return new_icl;
 }
 
 void
 tree_if_command_list::accept (tree_walker& tw)
 {
   tw.visit_if_command_list (*this);
@@ -164,22 +160,18 @@ tree_switch_case::accept (tree_walker& t
 // List of switch cases.
 
 tree_switch_case_list *
 tree_switch_case_list::dup (symbol_table::scope_id scope,
                             symbol_table::context_id context) const
 {
   tree_switch_case_list *new_scl = new tree_switch_case_list ();
 
-  for (const_iterator p = begin (); p != end (); p++)
-    {
-      const tree_switch_case *elt = *p;
-
-      new_scl->append (elt ? elt->dup (scope, context) : 0);
-    }
+  for (const tree_switch_case* elt : *this)
+    new_scl->append (elt ? elt->dup (scope, context) : 0);
 
   return new_scl;
 }
 
 void
 tree_switch_case_list::accept (tree_walker& tw)
 {
   tw.visit_switch_case_list (*this);
diff --git a/libinterp/parse-tree/pt-stmt.cc b/libinterp/parse-tree/pt-stmt.cc
--- a/libinterp/parse-tree/pt-stmt.cc
+++ b/libinterp/parse-tree/pt-stmt.cc
@@ -305,22 +305,18 @@ tree_statement_list::remove_all_breakpoi
 tree_statement_list *
 tree_statement_list::dup (symbol_table::scope_id scope,
                           symbol_table::context_id context) const
 {
   tree_statement_list *new_list = new tree_statement_list ();
 
   new_list->function_body = function_body;
 
-  for (const_iterator p = begin (); p != end (); p++)
-    {
-      const tree_statement *elt = *p;
-
-      new_list->append (elt ? elt->dup (scope, context) : 0);
-    }
+  for (const tree_statement* elt : *this)
+    new_list->append (elt ? elt->dup (scope, context) : 0);
 
   return new_list;
 }
 
 void
 tree_statement_list::accept (tree_walker& tw)
 {
   tw.visit_statement_list (*this);
