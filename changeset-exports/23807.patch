# HG changeset patch
# User Rik <rik@octave.org>
# Date 1501281600 25200
#      Fri Jul 28 15:40:00 2017 -0700
# Node ID 336f89b6208b7d6c9522026a06e113a1061afa06
# Parent  6925c8d2cd87c26a380011875174962632f2fa67
Use character literals 'c' rather than string literals "c" when possible.
Better performance when string constructor isn't required.

* Figure.cc, __init_qt__.cc, files-dock-widget.cc, file-editor-tab.cc,
file-editor.cc, octave-qscintilla.cc, main-window.cc, octave-dock-widget.cc,
octave-qt-link.cc, parser.cc, webinfo.cc, resource-manager.cc,
settings-dialog.cc, workspace-view.cc, __magick_read__.cc, balance.cc,
debug.cc, dynamic-ld.cc, ft-text-renderer.cc, gl-render.cc, gl2ps-print.cc,
graphics.cc, hook-fcn.h, input.cc, load-path.cc, load-save.cc, ls-hdf5.cc,
oct-hist.cc, oct-stream.cc, pager.cc, pr-output.cc, qz.cc, symtab.cc, symtab.h,
tril.cc, __delaunayn__.cc, __init_fltk__.cc, __voronoi__.cc, audioread.cc,
ccolamd.cc, colamd.cc, convhulln.cc, ov-base-int.cc, ov-base-mat.cc,
ov-base-scalar.cc, ov-base.cc, ov-bool-mat.cc, ov-cell.cc, ov-class.cc,
ov-classdef.cc, ov-colon.cc, ov-complex.cc, ov-cx-mat.cc, ov-fcn-handle.cc,
ov-fcn-inline.cc, ov-fcn.h, ov-flt-cx-mat.cc, ov-flt-re-mat.cc, ov-java.cc,
ov-oncleanup.cc, ov-range.cc, ov-re-mat.cc, ov-re-sparse.cc, ov-str-mat.cc,
ov-struct.cc, ov-usr-fcn.cc, ov.cc, octave.cc, bp-table.cc, jit-ir.cc,
jit-ir.h, jit-typeinfo.cc, pt-funcall.cc, pt-idx.cc, pt-pr-code.cc, pt.h,
Array.cc, CDiagMatrix.cc, CMatrix.cc, CNDArray.cc, CRowVector.cc, CSparse.cc,
Range.cc, boolSparse.cc, dDiagMatrix.cc, dMatrix.cc, dNDArray.cc,
dRowVector.cc, dSparse.cc, fCDiagMatrix.cc, fCMatrix.cc, fCNDArray.cc,
fCRowVector.cc, fDiagMatrix.cc, fMatrix.cc, fNDArray.cc, fRowVector.cc,
idx-vector.cc, intNDArray.cc, CollocWt.cc, DASPK.cc, DASRT.cc, DASSL.cc,
LSODE.cc, oct-time.cc, cmd-hist.cc, kpse.cc, lo-array-errwarn.cc, lo-regexp.cc,
lo-utils.cc, str-vec.cc, url-transfer.cc, main-cli.cc, main-gui.cc,
mkoctfile.in.cc:
Replace 1-character string literals "c" with the character literal 'c'.

diff --git a/libgui/graphics/Figure.cc b/libgui/graphics/Figure.cc
--- a/libgui/graphics/Figure.cc
+++ b/libgui/graphics/Figure.cc
@@ -280,17 +280,17 @@ namespace QtHandles
     std::string mode = fp.get___mouse_mode__ ();
 
     if (mode == "zoom")
       {
         octave_scalar_map zm = fp.get___zoom_mode__ ().scalar_map_value ();
 
         std::string direction = zm.getfield ("Direction").string_value ();
 
-        mode += " " + direction;
+        mode += ' ' + direction;
       }
 
     return mouse_mode_from_string (mode);
   }
 
   void
   Figure::createFigureToolBarAndMenuBar (void)
   {
@@ -901,17 +901,17 @@ namespace QtHandles
     Ffeval (ovl ("print", fnum, file));
   }
 
   void
   Figure::copy_figure_callback (const std::string& format)
   {
     std::string msg;
 
-    std::string file = octave::sys::tempnam ("", "oct-", msg) + "." + format;
+    std::string file = octave::sys::tempnam ("", "oct-", msg) + '.' + format;
 
     if (file.empty ())
       {
         // Report error?
         return;
       }
 
     save_figure_callback (file);
diff --git a/libgui/graphics/__init_qt__.cc b/libgui/graphics/__init_qt__.cc
--- a/libgui/graphics/__init_qt__.cc
+++ b/libgui/graphics/__init_qt__.cc
@@ -182,17 +182,17 @@ makeFilterSpecs (const Cell& filters)
 
   return filterSpecs;
 }
 
 static QString
 appendDirSep (const QString& d)
 {
   if (! d.endsWith ("/") && ! d.endsWith (QDir::separator ()))
-    return (d + "/");
+    return (d + '/');
   return d;
 }
 
 DEFUN (__uigetfile_qt__, args, , "")
 {
   using namespace QtHandles::Utils;
 
   // Expected arguments:
@@ -215,17 +215,17 @@ DEFUN (__uigetfile_qt__, args, , "")
   else
     retval(0) = "";
   retval(1) = "";
   retval(2) = 0.0;
 
   if (defaultFileName.isEmpty ())
     defaultFileName = defaultDirectory;
   else
-    defaultFileName = defaultDirectory + "/" + defaultFileName;
+    defaultFileName = defaultDirectory + '/' + defaultFileName;
 
   QStringList filterSpecs = makeFilterSpecs (args(0).cell_value ());
 
   if (isMultiSelect)
     {
       QString filter;
       QStringList files =
         QFileDialog::getOpenFileNames (0, caption, defaultFileName,
@@ -293,17 +293,17 @@ DEFUN (__uiputfile_qt__, args, , "")
 
   retval(0) = "";
   retval(1) = "";
   retval(2) = 0.0;
 
   if (defaultFileName.isEmpty ())
     defaultFileName = defaultDirectory;
   else
-    defaultFileName = defaultDirectory + "/" + defaultFileName;
+    defaultFileName = defaultDirectory + '/' + defaultFileName;
 
   QStringList filterSpecs = makeFilterSpecs (args(0).cell_value ());
 
   QString filter;
   QString fileName =
     QFileDialog::getSaveFileName (0, caption, defaultFileName,
                                   filterSpecs.join (";;"), &filter, 0);
 
diff --git a/libgui/src/files-dock-widget.cc b/libgui/src/files-dock-widget.cc
--- a/libgui/src/files-dock-widget.cc
+++ b/libgui/src/files-dock-widget.cc
@@ -658,18 +658,18 @@ files_dock_widget::contextmenu_rename (b
 
       QString new_name
         = QInputDialog::getText (this, tr ("Rename file/directory"),
                                  tr ("Rename file/directory:\n")
                                  + old_name + tr ("\n to: "),
                                  QLineEdit::Normal, old_name, &ok);
       if (ok && new_name.length () > 0)
         {
-          new_name = path.absolutePath () + "/" + new_name;
-          old_name = path.absolutePath () + "/" + old_name;
+          new_name = path.absolutePath () + '/' + new_name;
+          old_name = path.absolutePath () + '/' + old_name;
           path.rename (old_name, new_name);
           _file_system_model->revert ();
         }
     }
 
 }
 
 void
@@ -875,17 +875,17 @@ files_dock_widget::process_new_file (con
 {
   bool ok;
 
   QString name = QInputDialog::getText (this, tr ("Create File"),
        tr ("Create file in\n","String ends with \\n!") + parent_dir,
        QLineEdit::Normal, tr ("New File.txt"), &ok);
   if (ok && name.length () > 0)
     {
-      name = parent_dir + "/" + name;
+      name = parent_dir + '/' + name;
 
       QFile file (name);
       file.open (QIODevice::WriteOnly);
       _file_system_model->revert ();
     }
 }
 
 void
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -222,20 +222,20 @@ file_editor_tab::file_editor_tab (const 
   QSettings *settings = resource_manager::get_settings ();
   if (settings)
     notice_settings (settings, true);
 
   setFocusProxy (_edit_area);
 
   // encoding, not updated with the settings
 #if defined (Q_OS_WIN32)
-  _encoding = settings->value ("editor/default_encoding","SYSTEM")
+  _encoding = settings->value ("editor/default_encoding", "SYSTEM")
                                .toString ();
 #else
-  _encoding = settings->value ("editor/default_encoding","UTF-8")
+  _encoding = settings->value ("editor/default_encoding", "UTF-8")
                                .toString ();
 #endif
   _enc_indicator->setText (_encoding);
   // no changes in encoding yet
   _new_encoding = _encoding;
 
   // indicators
   _indicator_highlight_all
@@ -382,17 +382,17 @@ file_editor_tab::handle_context_menu_bre
   // If both present, use the OR of them, to avoid accidental overwriting
   // FIXME: If both are present, show old condition unselected and
   //        the selection (in edit area) selected (in the dialog).
   if (_edit_area->hasSelectedText ())
     {
       if (cond == "")
         cond = _edit_area->selectedText ();
       else
-        cond = "(" + cond + ") || (" + _edit_area->selectedText () + ")";
+        cond = '(' + cond + ") || (" + _edit_area->selectedText () + ')';
     }
 
   bool valid = false;
   std::string prompt = "dbstop if";
   bool ok;
   while (! valid)
     {
       QString new_condition
@@ -2440,17 +2440,17 @@ file_editor_tab::notice_settings (const 
   // reload changed files
   _always_reload_changed_files =
         settings->value ("editor/always_reload_changed_files",false).toBool ();
 }
 
 void
 file_editor_tab::auto_margin_width ()
 {
-  _edit_area->setMarginWidth (2, "1"+QString::number (_edit_area->lines ()));
+  _edit_area->setMarginWidth (2, "1" + QString::number (_edit_area->lines ()));
 }
 
 // the following close request was changed from a signal slot into a
 // normal function because we need the return value from close whether
 // the tab really was closed (for canceling exiting octave).
 // When emitting a signal, only the return value from the last slot
 // goes back to the sender
 bool
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -1307,21 +1307,21 @@ file_editor::enable_menu_shortcuts (bool
 
 QMenu*
 file_editor::m_add_menu (QMenuBar *p, QString name)
 {
   QMenu *menu = p->addMenu (name);
 
   QString base_name = name;  // get a copy
   // replace intended '&' ("&&") by a temp. string
-  base_name.replace ("&&","___octave_amp_replacement___");
+  base_name.replace ("&&", "___octave_amp_replacement___");
   // remove single '&' (shortcut)
   base_name.remove ("&");
   // restore intended '&'
-  base_name.replace ("___octave_amp_replacement___","&&");
+  base_name.replace ("___octave_amp_replacement___", "&&");
 
   // remember names with and without shortcut
   _hash_menu_text[menu] = QStringList () << name << base_name;
 
   return menu;
 }
 
 void
diff --git a/libgui/src/m-editor/octave-qscintilla.cc b/libgui/src/m-editor/octave-qscintilla.cc
--- a/libgui/src/m-editor/octave-qscintilla.cc
+++ b/libgui/src/m-editor/octave-qscintilla.cc
@@ -244,22 +244,22 @@ octave_qscintilla::contextMenuEvent (QCo
       // help menu: get the position of the mouse or the text cursor
       // (only for octave files)
       QString lexer_name = lexer ()->lexer ();
       if (lexer_name == "octave" || lexer_name == "matlab")
         {
           _word_at_cursor = wordAtPoint (local_pos);
           if (! _word_at_cursor.isEmpty ())
             {
-              context_menu->addAction (tr ("Help on") + " " + _word_at_cursor,
+              context_menu->addAction (tr ("Help on") + ' ' + _word_at_cursor,
                                        this, SLOT (contextmenu_help (bool)));
               context_menu->addAction (tr ("Documentation on")
-                                       + " " + _word_at_cursor,
+                                       + ' ' + _word_at_cursor,
                                        this, SLOT (contextmenu_doc (bool)));
-              context_menu->addAction (tr ("Edit") + " " + _word_at_cursor,
+              context_menu->addAction (tr ("Edit") + ' ' + _word_at_cursor,
                                        this, SLOT (contextmenu_edit (bool)));
             }
         }
     }
 #if defined (HAVE_QSCI_VERSION_2_6_0)
   else
     {
       // remove all standard actions from scintilla
@@ -529,17 +529,17 @@ octave_qscintilla::auto_close (int auto_
       next_line = "catch\n";
     else if (first_word == "unwind_protect")
       next_line = "unwind_protect_cleanup\n";
     else if (autofill_simple_end)
       next_line = "end\n";
     else
       {
         if (first_word == "unwind_protect")
-          first_word = "_" + first_word;
+          first_word = '_' + first_word;
         next_line = "end" + first_word + "\n";
       }
 
     insertAt (QString (start, ' ') + next_line, linenr + 2, 0);
 }
 
 
 // Do smart indendation after if, for, ...
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -526,17 +526,17 @@ news_reader::process (void)
   QString html_text;
 
   if (connect_to_web)
     {
       // Run this part in a separate thread so Octave can continue to
       // run while we wait for the page to load.  Then emit the signal
       // to display it when we have the page contents.
 
-      QString url = base_url + "/" + page;
+      QString url = base_url + '/' + page;
       std::ostringstream buf;
       octave::url_transfer octave_dot_org (url.toStdString (), buf);
 
       if (octave_dot_org.is_valid ())
         {
           Array<std::string> param;
           octave_dot_org.http_get (param);
 
@@ -2015,21 +2015,21 @@ main_window::disable_menu_shortcuts (boo
 
 QMenu*
 main_window::m_add_menu (QMenuBar *p, QString name)
 {
   QMenu *menu = p->addMenu (name);
 
   QString base_name = name;  // get a copy
   // replace intended '&' ("&&") by a temp. string
-  base_name.replace ("&&","___octave_amp_replacement___");
+  base_name.replace ("&&", "___octave_amp_replacement___");
   // remove single '&' (shortcut)
   base_name.remove ("&");
   // restore intended '&'
-  base_name.replace ("___octave_amp_replacement___","&&");
+  base_name.replace ("___octave_amp_replacement___", "&&");
 
   // remember names with and without shortcut
   _hash_menu_text[menu] = QStringList () << name << base_name;
 
   return menu;
 }
 
 void
diff --git a/libgui/src/octave-dock-widget.cc b/libgui/src/octave-dock-widget.cc
--- a/libgui/src/octave-dock-widget.cc
+++ b/libgui/src/octave-dock-widget.cc
@@ -221,17 +221,17 @@ octave_dock_widget::make_window ()
                                 QRect (50,100,480,480)).toRect ());
 
 #else
 
   // non windows: Just set the appripriate window flag
   setWindowFlags (Qt::Window);
 
   QString css = styleSheet ();
-  css.replace ("widget-undock","widget-dock");
+  css.replace ("widget-undock", "widget-dock");
   setStyleSheet (css);
 
 #endif
 
   _floating = true;
 
   set_focus_predecessor ();  // set focus previously active widget if tabbed
 }
@@ -277,17 +277,17 @@ octave_dock_widget::make_widget (bool do
 
   // non windows: just say we are a docked widget again
 
   Q_UNUSED (dock);
 
   setWindowFlags (Qt::Widget);
 
   QString css = styleSheet ();
-  css.replace ("widget-dock","widget-undock");
+  css.replace ("widget-dock", "widget-undock");
   setStyleSheet (css);
 
 #endif
 
   _floating = false;
 }
 
 // slot for (un)dock action
diff --git a/libgui/src/octave-qt-link.cc b/libgui/src/octave-qt-link.cc
--- a/libgui/src/octave-qt-link.cc
+++ b/libgui/src/octave-qt-link.cc
@@ -227,17 +227,17 @@ make_filter_list (const octave_link::fil
       ext.replace (";", " ");
 
       if (name.isEmpty ())
         {
           // No name field.  Build one from the extensions.
           name = ext.toUpper () + " Files";
         }
 
-      retval.append (name + " (" + ext + ")");
+      retval.append (name + " (" + ext + ')');
     }
 
   return retval;
 }
 
 std::pair<std::list<int>, int>
 octave_qt_link::do_list_dialog (const std::list<std::string>& list,
                                 const std::string& mode,
diff --git a/libgui/src/qtinfo/parser.cc b/libgui/src/qtinfo/parser.cc
--- a/libgui/src/qtinfo/parser.cc
+++ b/libgui/src/qtinfo/parser.cc
@@ -57,28 +57,28 @@ parser::set_info_path (const QString& in
   QFileInfo info (infoPath);
 
   bool info_file_exists = info.exists ();
   QHash<QString, QString>::iterator it;
   for (it = _compressors_map.begin (); it != _compressors_map.end (); it++)
     {
       if (info_file_exists)
         break;
-      info_file_exists = QFileInfo (info.absoluteFilePath () + "." +
+      info_file_exists = QFileInfo (info.absoluteFilePath () + '.' +
                                     it.key ()).exists ();
     }
 
   if (info_file_exists)
     {
       QString path = info.absolutePath ();
       QString fileName = info.fileName ();
 
       QDir infoDir (path);
       QStringList filter;
-      filter.append (fileName + "*");
+      filter.append (fileName + '*');
 
       _info_files = infoDir.entryInfoList (filter, QDir::Files);
 
       parse_info_map ();
 
       return true;
     }
   else
@@ -235,17 +235,17 @@ parser::get_next_node (QIODevice *io)
           line_buffer = line;             // and store it
           append_line (&text, line);
           line = io->readLine ();         // get next line of text
           append_line (&text, line);
           line = io->readLine ();         // drop last line (unneeded chars)
           line = line_buffer;             // and take the first instead
           // now correct the size of the dropped line and 5 additional chars
           for (i = 1; i < len + 6; i++)
-            line.insert (line.size ()-1,QByteArray (" "));  // adding blanks
+            line.insert (line.size ()-1, QByteArray (" "));  // adding blanks
         }
 
       if (line.at(0) == 31)
         break;
       else
         append_line (&text, line);
     }
   return text;
@@ -313,42 +313,42 @@ replace_links (QString& text)
       QString type     = re.cap (1);
       QString note     = re.cap (3);
       QString url_link = re.cap (4);
       QString term     = re.cap (5);
 
       if (url_link.isEmpty ())
         url_link = note;
 
-      term.replace (":","");
-      note.replace (":","");
+      term.replace (":", "");
+      note.replace (":", "");
       note.replace (QRegExp ("`([^']+)'"),"\\1");  // no extra format in links
 
       QRegExp re_break ("(\n[ ]*)");
 
       if (note == "fig" || note == "tab")
         url_link.prepend ("#");
 
       QString href;
       if (type == "\n*")
         href = "\n";
 
       if (re_break.indexIn (url_link) != -1)
         term += re_break.cap (1);
       else if (re_break.indexIn (re.cap (2)) != -1)
-        href = re_break.cap (1) + " ";
+        href = re_break.cap (1) + ' ';
       else if (re_break.indexIn (note) != -1)
         term += re_break.cap (1);
       note.replace (re_break,"&nbsp;");
 
       url_link = url_link.trimmed ();
-      url_link.replace ("\n"," ");
-      url_link.replace (QRegExp ("  +")," ");
-      url_link.replace ("<b>","");
-      url_link.replace ("</b>","");
+      url_link.replace ("\n", " ");
+      url_link.replace (QRegExp ("  +"), " ");
+      url_link.replace ("<b>", "");
+      url_link.replace ("</b>", "");
 
       href += R"(<font style="color:DarkGray; font-weight:bold;">&raquo;</font>)";
       href += "&nbsp;<a href='" + url_link + "'>" + note + "</a>" + term;
       f = re.matchedLength ();
       text.replace (i, f, href);
       i += href.size ();
     }
 }
@@ -554,19 +554,19 @@ parser::seek (QIODevice *io, int pos)
 }
 
 QString
 parser::global_search (const QString& text, int max_founds)
 {
   QString results;
   QStringList words = text.split (" ", QString::SkipEmptyParts);
 
-  QString re_program ("(" + QRegExp::escape (words.at (0)));
+  QString re_program ('(' + QRegExp::escape (words.at (0)));
   for (int i = 1; i < words.size (); i++)
-    re_program += "|" + QRegExp::escape (words.at (i));
+    re_program += '|' + QRegExp::escape (words.at (i));
   re_program += ')';
 
   QRegExp re (re_program, Qt::CaseInsensitive);
 
   results.append ("<html><body>\n<h1>Search results</h1>\n<b>Results for:</b> ");
   results.append (text);
   results.append ("<br>\n");
 
diff --git a/libgui/src/qtinfo/webinfo.cc b/libgui/src/qtinfo/webinfo.cc
--- a/libgui/src/qtinfo/webinfo.cc
+++ b/libgui/src/qtinfo/webinfo.cc
@@ -179,17 +179,17 @@ webinfo::set_info_path (const QString& i
     return false;
 }
 
 void
 webinfo::load_node (const QString& node_name)
 {
   // no XREF in the tabs
   QString tab_text = node_name;
-  tab_text.replace ("XREF","");
+  tab_text.replace ("XREF", "");
 
   //Check if node has been already opened.
   for (int i = 0; i < _tab_bar->count (); i++)
     {
       if (tab_text == _tab_bar->tabText (i))
         {
           _tab_bar->setCurrentIndex (i);
           return;
diff --git a/libgui/src/resource-manager.cc b/libgui/src/resource-manager.cc
--- a/libgui/src/resource-manager.cc
+++ b/libgui/src/resource-manager.cc
@@ -110,17 +110,17 @@ resource_manager::config_translators (QT
 
   QString language = "SYSTEM";  // take system language per default
 
   QSettings *settings = resource_manager::get_settings ();
 
   if (settings)
     {
       // get the locale from the settings if already available
-      language = settings->value ("language","SYSTEM").toString ();
+      language = settings->value ("language", "SYSTEM").toString ();
     }
 
   if (language == "SYSTEM")
     language = QLocale::system ().name ();    // get system wide locale
 
   // load the translator file for qt strings
   loaded = qt_tr->load ("qt_" + language, qt_trans_dir);
 
diff --git a/libgui/src/settings-dialog.cc b/libgui/src/settings-dialog.cc
--- a/libgui/src/settings-dialog.cc
+++ b/libgui/src/settings-dialog.cc
@@ -282,17 +282,17 @@ settings_dialog::settings_dialog (QWidge
   QFileInfoList qm_files = qm_dir.entryInfoList (QStringList ("*.qm"),
                                                  QDir::Files | QDir::Readable,
                                                  QDir::Name);
   for (int i = 0; i < qm_files.length (); i++)   // insert available languages
     ui->comboBox_language->addItem (qm_files.at (i).baseName ());
   // System at beginning
   ui->comboBox_language->insertItem (0,tr ("System setting"));
   ui->comboBox_language->insertSeparator (1);    // separator after System
-  QString language = settings->value ("language","SYSTEM").toString ();
+  QString language = settings->value ("language", "SYSTEM").toString ();
   if (language == "SYSTEM")
     language = tr ("System setting");
   int selected = ui->comboBox_language->findText (language);
   if (selected >= 0)
     ui->comboBox_language->setCurrentIndex (selected);
   else
     ui->comboBox_language->setCurrentIndex (0);  // System is default
 
@@ -307,17 +307,17 @@ settings_dialog::settings_dialog (QWidge
   ui->icon_size_large->setChecked (icon_size == 1);
 
   // which icon has to be selected
   QButtonGroup *icon_group = new QButtonGroup (this);
   icon_group->addButton (ui->general_icon_octave);
   icon_group->addButton (ui->general_icon_graphic);
   icon_group->addButton (ui->general_icon_letter);
   QString widget_icon_set =
-    settings->value ("DockWidgets/widget_icon_set","NONE").toString ();
+    settings->value ("DockWidgets/widget_icon_set", "NONE").toString ();
   ui->general_icon_octave-> setChecked (true);  // the default (if invalid set)
   ui->general_icon_octave-> setChecked (widget_icon_set == "NONE");
   ui->general_icon_graphic-> setChecked (widget_icon_set == "GRAPHIC");
   ui->general_icon_letter-> setChecked (widget_icon_set == "LETTER");
 
   // custom title bar of dock widget
   QVariant default_var = QColor (255,255,255);
   QColor bg_color = settings->value ("Dockwidgets/title_bg_color",
@@ -496,17 +496,17 @@ settings_dialog::settings_dialog (QWidge
     settings->value ("editor/create_new_file",false).toBool ());
   ui->editor_reload_changed_files->setChecked (
     settings->value ("editor/always_reload_changed_files",false).toBool ());
   ui->editor_hiding_closes_files->setChecked (
     settings->value ("editor/hiding_closes_files",false).toBool ());
 
   // terminal
   ui->terminal_fontName->setCurrentFont (QFont (
-      settings->value ("terminal/fontName","Courier New").toString ()));
+      settings->value ("terminal/fontName", "Courier New").toString ()));
   ui->terminal_fontSize->setValue (
     settings->value ("terminal/fontSize", 10).toInt ());
   ui->terminal_history_buffer->setValue (
     settings->value ("terminal/history_buffer",1000).toInt ());
   ui->terminal_cursorBlinking->setChecked (
     settings->value ("terminal/cursorBlinking",true).toBool ());
   ui->terminal_cursorUseForegroundColor->setChecked (
     settings->value ("terminal/cursorUseForegroundColor",true).toBool ());
diff --git a/libgui/src/workspace-view.cc b/libgui/src/workspace-view.cc
--- a/libgui/src/workspace-view.cc
+++ b/libgui/src/workspace-view.cc
@@ -321,23 +321,23 @@ workspace_view::contextmenu_requested (c
       if (! wm->is_top_level ())
         {
           rename->setDisabled (true);
           rename->setToolTip (tr ("Only top-level symbols may be renamed"));
         }
 
       menu.addSeparator ();
 
-      menu.addAction ("disp (" + var_name + ")", this,
+      menu.addAction ("disp (" + var_name + ')', this,
                       SLOT (handle_contextmenu_disp ()));
 
-      menu.addAction ("plot (" + var_name + ")", this,
+      menu.addAction ("plot (" + var_name + ')', this,
                       SLOT (handle_contextmenu_plot ()));
 
-      menu.addAction ("stem (" + var_name + ")", this,
+      menu.addAction ("stem (" + var_name + ')', this,
                       SLOT (handle_contextmenu_stem ()));
 
       menu.addSeparator ();
 
     }
 
   if (_filter_shown)
     menu.addAction (tr ("Hide filter"), this,
diff --git a/libinterp/corefcn/__magick_read__.cc b/libinterp/corefcn/__magick_read__.cc
--- a/libinterp/corefcn/__magick_read__.cc
+++ b/libinterp/corefcn/__magick_read__.cc
@@ -90,17 +90,17 @@ is_indexed (const Magick::Image& img)
           // store values from the underlying library as image attributes.  In
           // the case of PNG files, this is libpng where an indexed image will
           // always have a value of 3 for "color-type-orig".  This property
           // always has a value in libpng so if we get nothing, we assume this
           // GM version does not store them and we have to go with whatever
           // GM PseudoClass says.
           const std::string color_type =
             const_cast<Magick::Image&> (img).attribute ("PNG:IHDR.color-type-orig");
-          if (! color_type.empty() && color_type != "3")
+          if (! color_type.empty () && color_type != "3")
             indexed = false;
         }
     }
   return indexed;
 }
 
 //  The depth from depth() is not always correct for us but seems to be the
 //  best value we can get.  For example, a grayscale png image with 1 bit
@@ -1437,17 +1437,17 @@ init_reverse_disposal_methods ()
 
 void static
 write_file (const std::string& filename,
             const std::string& ext,
             std::vector<Magick::Image>& imvec)
 {
   try
     {
-      Magick::writeImages (imvec.begin (), imvec.end (), ext + ":" + filename);
+      Magick::writeImages (imvec.begin (), imvec.end (), ext + ':' + filename);
     }
   catch (Magick::Warning& w)
     {
       warning ("Magick++ warning: %s", w.what ());
     }
   catch (Magick::ErrorCoder& e)
     {
       warning ("Magick++ coder error: %s", e.what ());
diff --git a/libinterp/corefcn/balance.cc b/libinterp/corefcn/balance.cc
--- a/libinterp/corefcn/balance.cc
+++ b/libinterp/corefcn/balance.cc
@@ -212,17 +212,17 @@ Generalized eigenvalue problem balancing
   else
     {
       std::string bal_job;
       if (nargout == 1)
         warning ("balance: used GEP, should have two output arguments");
 
       // Generalized eigenvalue problem.
       if (nargin == 2)
-        bal_job = "B";
+        bal_job = 'B';
       else
         bal_job = args(2).xstring_value ("balance: OPT argument must be a string");
 
       if ((nn != args(1).columns ()) || (nn != args(1).rows ()))
         err_nonconformant ();
 
       Matrix bb;
       ComplexMatrix cbb;
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -415,23 +415,23 @@ The @qcode{"warn"} field is set similarl
                   if (have_unconditional++)
                     break;                   // stop once we know its plural
                 }
             }
           // If we actually have some, print line numbers only
           if (have_unconditional)
             {
               const char *_s_ = (have_unconditional > 1) ? "s" : "";
-              octave_stdout << "breakpoint" << _s_ <<" in " << fnm_bp_p.first
-                            << " at line" << _s_ << " ";
+              octave_stdout << "breakpoint" << _s_ << " in " << fnm_bp_p.first
+                            << " at line" << _s_ << ' ';
 
               for (const auto& bp : m)
                 {
                   if (bp.cond == "")
-                    octave_stdout << bp.line << " ";
+                    octave_stdout << bp.line << ' ';
                 }
               octave_stdout << std::endl;
             }
 
           // print conditional breakpoints, one per line, with conditions
           for (const auto& bp : m)
             {
               if (bp.cond != "")
@@ -549,17 +549,17 @@ is stopped.
   if (l > 0)
     {
       octave_stdout << "line " << l;
 
       std::string file_name = dbg_fcn->fcn_file_name ();
 
       if (! file_name.empty ())
         {
-          octave_stdout << " [" << file_name << "]" << std::endl;
+          octave_stdout << " [" << file_name << ']' << std::endl;
 
           std::string line = dbg_fcn->get_code_line (l);
 
           if (! line.empty ())
             octave_stdout << l << ": " << line << std::endl;
         }
       else
         octave_stdout << std::endl;
@@ -903,17 +903,17 @@ do_dbstack (octave::interpreter& interp,
               int line = lines(i).int_value ();
 
               if (show_top_level && i == curr_frame)
                 show_top_level = false;
 
               os << (i == curr_frame ? "  --> " : "      ")
                  << std::setw (max_name_len) << name
                  << " at line " << line
-                 << " [" << file << "]"
+                 << " [" << file << ']'
                  << std::endl;
             }
 
           if (show_top_level)
             os << "  --> top level" << std::endl;
         }
     }
   else
diff --git a/libinterp/corefcn/dynamic-ld.cc b/libinterp/corefcn/dynamic-ld.cc
--- a/libinterp/corefcn/dynamic-ld.cc
+++ b/libinterp/corefcn/dynamic-ld.cc
@@ -294,17 +294,17 @@ namespace octave
       }
 
     return retval;
   }
 
   std::string
   dynamic_loader::name_mangler (const std::string& name)
   {
-    return "G" + name;
+    return 'G' + name;
   }
 
   std::string
   dynamic_loader::name_uscore_mangler (const std::string& name)
   {
     return "_G" + name;
   }
 
diff --git a/libinterp/corefcn/ft-text-renderer.cc b/libinterp/corefcn/ft-text-renderer.cc
--- a/libinterp/corefcn/ft-text-renderer.cc
+++ b/libinterp/corefcn/ft-text-renderer.cc
@@ -188,17 +188,17 @@ namespace octave
                          const std::string& angle, double size)
     {
       FT_Face retval = nullptr;
 
 #if defined (HAVE_FT_REFERENCE_FACE)
       // Look first into the font cache, then use fontconfig.  If the font
       // is present in the cache, simply add a reference and return it.
 
-      ft_key key (name + ":" + weight + ":" + angle, size);
+      ft_key key (name + ':' + weight + ':' + angle, size);
       ft_cache::const_iterator it = cache.find (key);
 
       if (it != cache.end ())
         {
           FT_Reference_Face (it->second);
           return it->second;
         }
 #endif
@@ -1051,17 +1051,17 @@ namespace octave
       update_line_bbox ();
   }
 
   void
   ft_text_renderer::visit (text_element_symbol& e)
   {
     uint32_t code = e.get_symbol_code ();
 
-    text_renderer::string fs (std::string ("-"), font, xoffset, yoffset);
+    text_renderer::string fs ("-", font, xoffset, yoffset);
 
     if (code != text_element_symbol::invalid_code && font.is_valid ())
       {
         process_character (code);
         fs.set_code (code);
       }
     else if (font.is_valid ())
       ::warning ("ignoring unknown symbol: %d", e.get_symbol ());
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -1023,18 +1023,18 @@ namespace octave
       {
         double val = ticks(i);
 
         if (lim1 <= val && val <= lim2)
           {
             Matrix b;
 
             std::string label (ticklabels(i % nlabels));
-            label.erase (0, label.find_first_not_of (" "));
-            label = label.substr (0, label.find_last_not_of (" ")+1);
+            label.erase (0, label.find_first_not_of (' '));
+            label = label.substr (0, label.find_last_not_of (' ')+1);
 
             // FIXME: As tick text is transparent, shouldn't it be
             //        drawn after axes object, for correct rendering?
             if (xyz == X_AXIS)
               {
                 b = render_text (label, val, p1, p2, ha, va);
               }
             else if (xyz == Y_AXIS)
diff --git a/libinterp/corefcn/gl2ps-print.cc b/libinterp/corefcn/gl2ps-print.cc
--- a/libinterp/corefcn/gl2ps-print.cc
+++ b/libinterp/corefcn/gl2ps-print.cc
@@ -273,28 +273,28 @@ namespace octave
             // For LaTeX output the print process uses 2 drawnow() commands.
             // The first one is for the pdf/ps/eps graph to be included.  The
             // print_cmd is saved as old_print_cmd.  Then the second drawnow()
             // outputs the tex-file and the graphic filename to be included is
             // extracted from old_print_cmd.
 
             std::string include_graph;
 
-            size_t found_redirect = old_print_cmd.find (">");
+            size_t found_redirect = old_print_cmd.find ('>');
 
             if (found_redirect != std::string::npos)
               include_graph = old_print_cmd.substr (found_redirect + 1);
             else
               include_graph = old_print_cmd;
 
-            size_t n_begin = include_graph.find_first_not_of (" ");
+            size_t n_begin = include_graph.find_first_not_of (' ');
 
             if (n_begin != std::string::npos)
               {
-                size_t n_end = include_graph.find_last_not_of (" ");
+                size_t n_end = include_graph.find_last_not_of (' ');
                 include_graph = include_graph.substr (n_begin,
                                                       n_end - n_begin + 1);
               }
             else
               include_graph = "foobar-inc";
 
             // GL2PS_SILENT was removed to allow gl2ps to print errors on stderr
             GLint ret = gl2psBeginPage ("gl2ps_renderer figure", "Octave", nullptr,
@@ -419,155 +419,155 @@ namespace octave
 static std::string
 code_to_symbol (uint32_t code)
 {
   std::string retval;
 
   uint32_t idx = code - 945;
   if (idx < 25)
     {
-      std::string characters("abgdezhqiklmnxoprVstufcyw");
+      std::string characters ("abgdezhqiklmnxoprVstufcyw");
       retval = characters[idx];
       return retval;
     }
 
   idx = code - 913;
   if (idx < 25)
     {
-      std::string characters("ABGDEZHQIKLMNXOPRVSTUFCYW");
+      std::string characters ("ABGDEZHQIKLMNXOPRVSTUFCYW");
       retval = characters[idx];
     }
   else if (code == 978)
-    retval = std::string ("U");
+    retval = "U";
   else if (code == 215)
-    retval = std::string ("\xb4");
+    retval = "\xb4";
   else if (code == 177)
-    retval = std::string ("\xb1");
+    retval = "\xb1";
   else if (code == 8501)
-    retval = std::string ("\xc0");
+    retval = "\xc0";
   else if (code == 8465)
-    retval = std::string ("\xc1");
+    retval = "\xc1";
   else if (code == 8242)
-    retval = std::string ("\xa2");
+    retval = "\xa2";
   else if (code == 8736)
-    retval = std::string ("\xd0");
+    retval = "\xd0";
   else if (code == 172)
-    retval = std::string ("\xd8");
+    retval = "\xd8";
   else if (code == 9829)
-    retval = std::string ("\xa9");
+    retval = "\xa9";
   else if (code == 8472)
-    retval = std::string ("\xc3");
+    retval = "\xc3";
   else if (code == 8706)
-    retval = std::string ("\xb6");
+    retval = "\xb6";
   else if (code == 8704)
-    retval = std::string ("\x22");
+    retval = "\x22";
   else if (code == 9827)
-    retval = std::string ("\xa7");
+    retval = "\xa7";
   else if (code == 9824)
-    retval = std::string ("\xaa");
+    retval = "\xaa";
   else if (code == 8476)
-    retval = std::string ("\xc2");
+    retval = "\xc2";
   else if (code == 8734)
-    retval = std::string ("\xa5");
+    retval = "\xa5";
   else if (code == 8730)
-    retval = std::string ("\xd6");
+    retval = "\xd6";
   else if (code == 8707)
-    retval = std::string ("\x24");
+    retval = "\x24";
   else if (code == 9830)
-    retval = std::string ("\xa8");
+    retval = "\xa8";
   else if (code == 8747)
-    retval = std::string ("\xf2");
+    retval = "\xf2";
   else if (code == 8727)
-    retval = std::string ("\x2a");
+    retval = "\x2a";
   else if (code == 8744)
-    retval = std::string ("\xda");
+    retval = "\xda";
   else if (code == 8855)
-    retval = std::string ("\xc4");
+    retval = "\xc4";
   else if (code == 8901)
-    retval = std::string ("\xd7");
+    retval = "\xd7";
   else if (code == 8728)
-    retval = std::string ("\xb0");
+    retval = "\xb0";
   else if (code == 8745)
-    retval = std::string ("\xc7");
+    retval = "\xc7";
   else if (code == 8743)
-    retval = std::string ("\xd9");
+    retval = "\xd9";
   else if (code == 8856)
-    retval = std::string ("\xc6");
+    retval = "\xc6";
   else if (code == 8729)
-    retval = std::string ("\xb7");
+    retval = "\xb7";
   else if (code == 8746)
-    retval = std::string ("\xc8");
+    retval = "\xc8";
   else if (code == 8853)
-    retval = std::string ("\xc5");
+    retval = "\xc5";
   else if (code == 8804)
-    retval = std::string ("\xa3");
+    retval = "\xa3";
   else if (code == 8712)
-    retval = std::string ("\xce");
+    retval = "\xce";
   else if (code == 8839)
-    retval = std::string ("\xca");
+    retval = "\xca";
   else if (code == 8801)
-    retval = std::string ("\xba");
+    retval = "\xba";
   else if (code == 8773)
-    retval = std::string ("\x40");
+    retval = "\x40";
   else if (code == 8834)
-    retval = std::string ("\xcc");
+    retval = "\xcc";
   else if (code == 8805)
-    retval = std::string ("\xb3");
+    retval = "\xb3";
   else if (code == 8715)
-    retval = std::string ("\x27");
+    retval = "\x27";
   else if (code == 8764)
-    retval = std::string ("\x7e");
+    retval = "\x7e";
   else if (code == 8733)
-    retval = std::string ("\xb5");
+    retval = "\xb5";
   else if (code == 8838)
-    retval = std::string ("\xcd");
+    retval = "\xcd";
   else if (code == 8835)
-    retval = std::string ("\xc9");
+    retval = "\xc9";
   else if (code == 8739)
-    retval = std::string ("\xbd");
+    retval = "\xbd";
   else if (code == 8776)
-    retval = std::string ("\xbb");
+    retval = "\xbb";
   else if (code == 8869)
-    retval = std::string ("\x5e");
+    retval = "\x5e";
   else if (code == 8656)
-    retval = std::string ("\xdc");
+    retval = "\xdc";
   else if (code == 8592)
-    retval = std::string ("\xac");
+    retval = "\xac";
   else if (code == 8658)
-    retval = std::string ("\xde");
+    retval = "\xde";
   else if (code == 8594)
-    retval = std::string ("\xae");
+    retval = "\xae";
   else if (code == 8596)
-    retval = std::string ("\xab");
+    retval = "\xab";
   else if (code == 8593)
-    retval = std::string ("\xad");
+    retval = "\xad";
   else if (code == 8595)
-    retval = std::string ("\xaf");
+    retval = "\xaf";
   else if (code == 8970)
-    retval = std::string ("\xeb");
+    retval = "\xeb";
   else if (code == 8971)
-    retval = std::string ("\xfb");
+    retval = "\xfb";
   else if (code == 10216)
-    retval = std::string ("\xe1");
+    retval = "\xe1";
   else if (code == 10217)
-    retval = std::string ("\xf1");
+    retval = "\xf1";
   else if (code == 8968)
-    retval = std::string ("\xe9");
+    retval = "\xe9";
   else if (code == 8969)
-    retval = std::string ("\xf9");
+    retval = "\xf9";
   else if (code == 8800)
-    retval = std::string ("\xb9");
+    retval = "\xb9";
   else if (code == 8230)
-    retval = std::string ("\xbc");
+    retval = "\xbc";
   else if (code == 176)
-    retval = std::string ("\xb0");
+    retval = "\xb0";
   else if (code == 8709)
-    retval = std::string ("\xc6");
+    retval = "\xc6";
   else if (code == 169)
-    retval = std::string ("\xd3");
+    retval = "\xd3";
 
   if (retval.empty ())
     warning ("print: unhandled symbol %d", code);
 
   return retval;
 }
 
 static std::string
@@ -695,17 +695,17 @@ namespace octave
               {
                 fontname = "Symbol";
                 str = code_to_symbol (txtobj.get_code ());
               }
             else
               {
                 std::stringstream ss;
                 ss << txtobj.get_code ();
-                str = "&#" + ss.str () + ";";
+                str = "&#" + ss.str () + ';';
               }
           }
         else
           {
             str = txtobj.get_string ();
             // Escape parenthesis until gl2ps does it (see bug ##45301).
             if (term.find ("svg") == std::string::npos)
               {
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1223,24 +1223,24 @@ radio_values::values_as_string (void) co
 {
   std::string retval;
 
   for (const auto& val : possible_vals)
     {
       if (retval.empty ())
         {
           if (val == default_value ())
-            retval = "{" + val + "}";
+            retval = '{' + val + '}';
           else
             retval = val;
         }
       else
         {
           if (val == default_value ())
-            retval += " | {" + val + "}";
+            retval += " | {" + val + '}';
           else
             retval += " | " + val;
         }
     }
 
   if (! retval.empty ())
     retval = "[ " + retval + " ]";
 
@@ -7292,30 +7292,30 @@ axes::properties::calc_ticklabels (const
             exponent = std::floor (std::log10 (-values(i)));
           else
             exponent = std::floor (std::log10 (values(i)));
           significand = values(i) * std::pow (10., -exponent);
 
           os.str ("");
           if ((std::abs (significand) - 1) >
               10*std::numeric_limits<double>::epsilon())
-            os << significand << "x";
+            os << significand << 'x';
           else if (significand < 0)
-            os << "-";
+            os << '-';
 
           os << "10^{";
 
           if (exponent < 0.0)
             {
-              os << "-";
+              os << '-';
               exponent = -exponent;
             }
           if (exponent < 10. && (exp_max > 9 || exp_min < -9))
-            os << "0";
-          os << exponent << "}";
+            os << '0';
+          os << exponent << '}';
           c(i) = os.str ();
         }
     }
   else
     {
       for (int i = 0; i < values.numel (); i++)
         {
           bool omit_tick = false;
@@ -7346,18 +7346,18 @@ axes::properties::get_ticklabel_extents 
   wmax = hmax = 0.0;
   int n = std::min (ticklabels.numel (), ticks.numel ());
   for (int i = 0; i < n; i++)
     {
       double val = ticks(i);
       if (limits(0) <= val && val <= limits(1))
         {
           std::string label (ticklabels(i));
-          label.erase (0, label.find_first_not_of (" "));
-          label = label.substr (0, label.find_last_not_of (" ")+1);
+          label.erase (0, label.find_first_not_of (' '));
+          label = label.substr (0, label.find_last_not_of (' ')+1);
 
           if (txt_renderer.ok ())
             {
               gh_manager::auto_lock guard;
               ext = txt_renderer.get_extent (label, 0.0,
                                              get_ticklabelinterpreter ());
 
               wmax = std::max (wmax, ext(0));
diff --git a/libinterp/corefcn/hook-fcn.h b/libinterp/corefcn/hook-fcn.h
--- a/libinterp/corefcn/hook-fcn.h
+++ b/libinterp/corefcn/hook-fcn.h
@@ -153,17 +153,17 @@ public:
     octave_fcn_handle *fh = fcn_handle.fcn_handle_value (true);
 
     if (fh)
       {
         valid = true;
 
         std::ostringstream buf;
         buf << fh;
-        ident = fh->fcn_name () + ":" + buf.str ();
+        ident = fh->fcn_name () + ':' + buf.str ();
       }
   }
 
   void eval (const octave_value_list& initial_args)
   {
     octave_value_list args = initial_args;
 
     if (data.is_defined ())
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -337,17 +337,17 @@ is_completing_dirfns (void)
   static const size_t dirfns_commands_length = 2;
 
   bool retval = false;
 
   std::string line = octave::command_editor::get_line_buffer ();
 
   for (size_t i = 0; i < dirfns_commands_length; i++)
     {
-      int index = line.find (dirfns_commands[i] + " ");
+      int index = line.find (dirfns_commands[i] + ' ');
 
       if (index == 0)
         {
           retval = true;
           break;
         }
     }
 
@@ -423,17 +423,17 @@ generate_completion (const std::string& 
 
           list_index++;
 
           if (hint == name.substr (0, hint_len))
             {
               // Special case: array reference forces prefix="."
               //               in generate_struct_completions ()
               if (list_index <= name_list_len && ! prefix.empty ())
-                retval = (prefix == "." ? "" : prefix) + "." + name;
+                retval = (prefix == "." ? "" : prefix) + '.' + name;
               else
                 retval = name;
 
               char prev_char = octave::command_editor::get_prev_char
                                                        (text.length ());
               if (matches == 1 && looks_like_struct (retval, prev_char))
                 {
                   // Don't append anything, since we don't know
@@ -454,17 +454,17 @@ generate_completion (const std::string& 
 }
 
 static std::string
 quoting_filename (const std::string& text, int, char quote)
 {
   if (quote)
     return text;
   else
-    return (std::string ("'") + text);
+    return ("'" + text);
 }
 
 // Try to parse a partial command line in reverse, excluding trailing TEXT.
 // If it appears a variable has been indexed by () or {},
 // return that expression,
 // to allow autocomplete of field names of arrays of structures.
 std::string
 find_indexed_expression (const std::string& text)
@@ -575,17 +575,17 @@ get_debug_input (octave::interpreter& in
   std::ostringstream buf;
 
   if (! nm.empty ())
     {
       if (Vgud_mode)
         {
           static char ctrl_z = 'Z' & 0x1f;
 
-          buf << ctrl_z << ctrl_z << nm << ":" << curr_debug_line;
+          buf << ctrl_z << ctrl_z << nm << ':' << curr_debug_line;
         }
       else
         {
           // FIXME: we should come up with a clean way to detect
           // that we are stopped on the no-op command that marks the
           // end of a function or script.
 
           if (! silent)
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -916,17 +916,17 @@ namespace octave
 
     dir_info::package_dir_map_type package_dir_map = di.package_dir_map;
 
     for (const auto& pkg_di : package_dir_map)
       {
         std::string full_name = pkg_di.first;
 
         if (! pname.empty ())
-          full_name = pname + "." + full_name;
+          full_name = pname + '.' + full_name;
 
         move (pkg_di.second, at_end, full_name);
       }
   }
 
   void
   load_path::add (const std::string& dir_arg, bool at_end, bool warn)
   {
@@ -991,17 +991,17 @@ namespace octave
 
     dir_info::package_dir_map_type package_dir_map = di.package_dir_map;
 
     for (const auto& pkg_di : package_dir_map)
       {
         std::string full_name = pkg_di.first;
 
         if (! pname.empty ())
-          full_name = pname + "." + full_name;
+          full_name = pname + '.' + full_name;
 
         remove (pkg_di.second, full_name);
       }
   }
 
   bool
   load_path::is_package (const std::string& name) const
   {
@@ -1024,17 +1024,17 @@ namespace octave
 
     dir_info::package_dir_map_type package_dir_map = di.package_dir_map;
 
     for (const auto& pkg_di : package_dir_map)
       {
         std::string full_name = pkg_di.first;
 
         if (! pname.empty ())
-          full_name = pname + "." + full_name;
+          full_name = pname + '.' + full_name;
 
         add (pkg_di.second, at_end, full_name);
       }
   }
 
   string_vector
   load_path::get_file_list (const load_path::dir_info::fcn_file_map_type& lst) const
   {
@@ -1602,17 +1602,17 @@ namespace octave
       {
         const fcn_map_type& m = cls_fnmap.second;
 
         if (m.find (meth) != m.end ())
           {
             std::string class_name = cls_fnmap.first;
 
             if (! m_package_name.empty ())
-              class_name = m_package_name + "." + class_name;
+              class_name = m_package_name + '.' + class_name;
 
             l.push_back (class_name);
           }
       }
   }
 
   string_vector
   load_path::package_info::fcn_names (void) const
@@ -1754,17 +1754,17 @@ namespace octave
 
     for (const auto& cls_ci : method_file_map)
       {
         std::string class_name = cls_ci.first;
 
         fcn_map_type& fm = method_map[class_name];
 
         std::string full_dir_name
-          = sys::file_ops::concat (dir_name, "@" + class_name);
+          = sys::file_ops::concat (dir_name, '@' + class_name);
 
         const dir_info::class_info& ci = cls_ci.second;
 
         // <FCN_NAME, TYPES>
         const dir_info::fcn_file_map_type& m = ci.method_file_map;
 
         for (const auto& nm_typ : m)
           {
@@ -1862,17 +1862,17 @@ namespace octave
   {
     for (auto& cls_fnmap : method_map)
       {
         std::string class_name = cls_fnmap.first;
 
         fcn_map_type& fn_map = cls_fnmap.second;
 
         std::string full_dir_name
-          = sys::file_ops::concat (dir_name, "@" + class_name);
+          = sys::file_ops::concat (dir_name, '@' + class_name);
 
         for (auto& nm_filst : fn_map)
           {
             file_info_list_type& file_info_list = nm_filst.second;
 
             if (file_info_list.size () == 1)
               continue;
             else
@@ -1953,17 +1953,17 @@ namespace octave
   {
     for (auto& cls_fnmap : method_map)
       {
         std::string class_name = cls_fnmap.first;
 
         fcn_map_type& fn_map = cls_fnmap.second;
 
         std::string full_dir_name
-          = sys::file_ops::concat (dir, "@" + class_name);
+          = sys::file_ops::concat (dir, '@' + class_name);
 
         for (auto& nm_filst : fn_map)
           {
             file_info_list_type& file_info_list = nm_filst.second;
 
             if (file_info_list.size () == 1)
               continue;
             else
@@ -2091,26 +2091,26 @@ namespace octave
       {
         os << "oct";
         printed_type = true;
       }
 
     if (types & load_path::MEX_FILE)
       {
         if (printed_type)
-          os << "|";
+          os << '|';
         os << "mex";
         printed_type = true;
       }
 
     if (types & load_path::M_FILE)
       {
         if (printed_type)
-          os << "|";
-        os << "m";
+          os << '|';
+        os << 'm';
         printed_type = true;
       }
   }
 
   void
   load_path::package_info::print_fcn_list (std::ostream& os,
                                            const load_path::dir_info::fcn_file_map_type& lst) const
   {
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -110,19 +110,19 @@ static std::string Voctave_core_file_opt
 
 static std::string
 default_save_header_format (void)
 {
   return
     std::string ("# Created by Octave " OCTAVE_VERSION
                  ", %a %b %d %H:%M:%S %Y %Z <")
     + octave::sys::env::get_user_name ()
-    + std::string ("@")
+    + '@'
     + octave::sys::env::get_host_name ()
-    + std::string (">");
+    + '>';
 }
 
 // The format string for the comment line at the top of text-format
 // save files.  Passed to strftime.  Should begin with '#' and contain
 // no newline characters.
 static std::string Vsave_header_format_string = default_save_header_format ();
 
 OCTAVE_NORETURN static
@@ -495,17 +495,17 @@ do_load (std::istream& stream, const std
   return retval;
 }
 
 static std::string
 find_file_to_load (const std::string& name, const std::string& orig_name)
 {
   std::string fname = find_data_file_in_load_path ("load", name, true);
 
-  size_t dot_pos = fname.rfind (".");
+  size_t dot_pos = fname.rfind ('.');
   size_t sep_pos = fname.find_last_of (octave::sys::file_ops::dir_sep_chars ());
 
   if (dot_pos == std::string::npos
       || (sep_pos != std::string::npos && dot_pos < sep_pos))
     {
       // Either no '.' in name or no '.' appears after last directory
       // separator.
 
diff --git a/libinterp/corefcn/ls-hdf5.cc b/libinterp/corefcn/ls-hdf5.cc
--- a/libinterp/corefcn/ls-hdf5.cc
+++ b/libinterp/corefcn/ls-hdf5.cc
@@ -546,17 +546,17 @@ hdf5_read_next_data_internal (hid_t grou
 #else
           hid_t int_sign = H5Tget_sign (type_id);
 
           if (int_sign == H5T_SGN_ERROR)
             warning ("load: can't read '%s' (unknown datatype)", name);
           else
             {
               if (int_sign == H5T_SGN_NONE)
-                int_typ.append ("u");
+                int_typ.push_back ('u');
               int_typ.append ("int");
 
               int slen = H5Tget_size (type_id);
               if (slen < 0)
                 warning ("load: can't read '%s' (unknown datatype)", name);
               else
                 {
                   switch (slen)
diff --git a/libinterp/corefcn/oct-hist.cc b/libinterp/corefcn/oct-hist.cc
--- a/libinterp/corefcn/oct-hist.cc
+++ b/libinterp/corefcn/oct-hist.cc
@@ -105,19 +105,19 @@ default_history_size (void)
 }
 
 static std::string
 default_history_timestamp_format (void)
 {
   return
     std::string ("# Octave " OCTAVE_VERSION ", %a %b %d %H:%M:%S %Y %Z <")
     + octave::sys::env::get_user_name ()
-    + std::string ("@")
+    + '@'
     + octave::sys::env::get_host_name ()
-    + std::string (">");
+    + '>';
 }
 
 // The format of the timestamp marker written to the history file when
 // Octave exits.
 static std::string Vhistory_timestamp_format_string
   = default_history_timestamp_format ();
 
 // Display, save, or load history.  Stolen and modified from bash.
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -398,17 +398,17 @@ namespace octave
           }
         else if (isspace (s[i]))
           {
             type = scanf_format_elt::whitespace_conversion;
 
             width = 0;
             discard = false;
             modifier = '\0';
-            buf << " ";
+            buf << ' ';
 
             while (++i < n && isspace (s[i]))
               ; // skip whitespace
 
             add_elt_to_list (width, discard, type, modifier);
 
             have_more = false;
           }
@@ -5776,17 +5776,17 @@ namespace octave
                         if (! val_cache)
                           break;
                       }
                   }
               }
 
             if (elt->type == '%')
               {
-                os << "%";
+                os << '%';
                 retval++;
               }
             else if (elt->args == 0 && elt->text)
               {
                 os << elt->text;
                 retval += strlen (elt->text);
               }
             else if (elt->type == 's' || elt->type == 'c')
diff --git a/libinterp/corefcn/pager.cc b/libinterp/corefcn/pager.cc
--- a/libinterp/corefcn/pager.cc
+++ b/libinterp/corefcn/pager.cc
@@ -111,17 +111,17 @@ pager_event_handler (pid_t pid, int stat
   if (pid > 0)
     {
       if (octave::sys::wifexited (status) || octave::sys::wifsignaled (status))
         {
           // Avoid warning() since that will put us back in the pager,
           // which would be bad news.
 
           std::cerr << "warning: connection to external pager lost (pid = "
-                    << pid << ")" << std::endl;
+                    << pid << ')' << std::endl;
           std::cerr << "warning: flushing pending output (please wait)"
                     << std::endl;
 
           // Request removal of this PID from the list of child
           // processes.
 
           retval = true;
         }
@@ -131,17 +131,17 @@ pager_event_handler (pid_t pid, int stat
 }
 
 static std::string
 pager_command (void)
 {
   std::string cmd = VPAGER;
 
   if (! (cmd.empty () || VPAGER_FLAGS.empty ()))
-    cmd += " " + VPAGER_FLAGS;
+    cmd += ' ' + VPAGER_FLAGS;
 
   return cmd;
 }
 
 static void
 do_sync (const char *msg, int len, bool bypass_pager)
 {
   if (msg && len > 0)
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -399,17 +399,17 @@ rational_approx (double val, int len)
           n = step * n + lastn;
           d = step * d + lastd;
           lastn = nextn;
           lastd = nextd;
 
           std::ostringstream buf;
           buf.flags (std::ios::fixed);
           buf << std::setprecision (0) << static_cast<int>(n)
-              << "/" << static_cast<int>(d);
+              << '/' << static_cast<int>(d);
           m++;
 
           if (n < 0 && d < 0)
             {
               // Double negative, string can be two characters longer..
               if (buf.str ().length () > static_cast<unsigned int>(len + 2))
                 break;
             }
@@ -426,17 +426,17 @@ rational_approx (double val, int len)
       if (lastd < 0.)
         {
           // Move sign to the top
           lastd = - lastd;
           lastn = - lastn;
           std::ostringstream buf;
           buf.flags (std::ios::fixed);
           buf << std::setprecision (0) << static_cast<int>(lastn)
-              << "/" << static_cast<int>(lastd);
+              << '/' << static_cast<int>(lastd);
           s = buf.str ();
         }
     }
 
   return s;
 }
 
 /*
@@ -476,17 +476,17 @@ operator << (std::ostream& os, const pr_
 
   if (fw >= 0)
     os << std::setw (fw);
 
   os.flags (static_cast<std::ios::fmtflags>
             (prf.f.fmt | prf.f.up | prf.f.sp));
 
   if (fw > 0 && s.length () > static_cast<unsigned int>(fw))
-    os << "*";
+    os << '*';
   else
     os << s;
 
   return os;
 }
 
 // Current format for real numbers and the real part of complex
 // numbers.
@@ -1583,56 +1583,56 @@ pr_complex (std::ostream& os, const Comp
         {
           if (hex_format || bit_format)
             os << "  ";
           else
             os << " + ";
 
           pr_imag_float (os, i, i_fw);
         }
-      os << "i";
+      os << 'i';
     }
 }
 
 static void
 print_empty_matrix (std::ostream& os, octave_idx_type nr, octave_idx_type nc,
                     bool pr_as_read_syntax)
 {
   assert (nr == 0 || nc == 0);
 
   if (pr_as_read_syntax)
     {
       if (nr == 0 && nc == 0)
         os << "[]";
       else
-        os << "zeros (" << nr << ", " << nc << ")";
+        os << "zeros (" << nr << ", " << nc << ')';
     }
   else
     {
       os << "[]";
 
       if (Vprint_empty_dimensions)
-        os << "(" << nr << "x" << nc << ")";
+        os << '(' << nr << 'x' << nc << ')';
     }
 }
 
 static void
 print_empty_nd_array (std::ostream& os, const dim_vector& dims,
                       bool pr_as_read_syntax)
 {
   assert (dims.any_zero ());
 
   if (pr_as_read_syntax)
-    os << "zeros (" << dims.str (',') << ")";
+    os << "zeros (" << dims.str (',') << ')';
   else
     {
       os << "[]";
 
       if (Vprint_empty_dimensions)
-        os << "(" << dims.str () << ")";
+        os << '(' << dims.str () << ')';
     }
 }
 
 static void
 pr_scale_header (std::ostream& os, double scale)
 {
   if (Vfixed_point_format && ! print_g && scale != 1.0)
     {
@@ -1761,17 +1761,17 @@ octave_print_internal (std::ostream& os,
       if (free_format)
         {
           if (pr_as_read_syntax)
             os << "[\n";
 
           os << m;
 
           if (pr_as_read_syntax)
-            os << "]";
+            os << ']';
 
           return;
         }
 
       octave_idx_type inc = nc;
       if (total_width > max_width && Vsplit_long_rows)
         {
           inc = max_width / column_width;
@@ -1897,17 +1897,17 @@ octave_print_internal (std::ostream& os,
       if (free_format)
         {
           if (pr_as_read_syntax)
             os << "[\n";
 
           os << Matrix (m);
 
           if (pr_as_read_syntax)
-            os << "]";
+            os << ']';
 
           return;
         }
 
       octave_idx_type inc = nc;
       if (total_width > max_width && Vsplit_long_rows)
         {
           inc = max_width / column_width;
@@ -1943,17 +1943,17 @@ octave_print_internal (std::ostream& os,
 
               col += inc;
 
               if (col >= nc)
                 os << " ]";
               else
                 os << " ...\n";
             }
-          os << ")";
+          os << ')';
         }
       else
         {
           octave::preserve_stream_state stream_state (os);
 
           os << "Diagonal Matrix\n";
           if (! Vcompact_format)
             os << "\n";
@@ -2037,19 +2037,19 @@ void print_nd_array (std::ostream& os, c
 
               std::ostringstream buf;
 
               for (int k = 2; k < ndims; k++)
                 {
                   buf << ra_idx(k) + 1;
 
                   if (k < ndims - 1)
-                    buf << ",";
+                    buf << ',';
                   else
-                    buf << ")";
+                    buf << ')';
                 }
 
               nm += buf.str ();
             }
 
           Array<idx_vector> idx (dim_vector (ndims, 1));
 
           idx(0) = idx_vector (':');
@@ -2100,24 +2100,24 @@ template <>
 pr_plus_format<> (std::ostream& os, const Complex& c)
 {
   double rp = c.real ();
   double ip = c.imag ();
 
   if (rp == 0.0)
     {
       if (ip == 0.0)
-        os << " ";
+        os << ' ';
       else
-        os << "i";
+        os << 'i';
     }
   else if (ip == 0.0)
     pr_plus_format (os, rp);
   else
-    os << "c";
+    os << 'c';
 }
 
 void
 octave_print_internal (std::ostream& os, const Complex& c,
                        bool pr_as_read_syntax)
 {
   if (pr_as_read_syntax)
     os << c;
@@ -2179,17 +2179,17 @@ octave_print_internal (std::ostream& os,
       if (free_format)
         {
           if (pr_as_read_syntax)
             os << "[\n";
 
           os << cm;
 
           if (pr_as_read_syntax)
-            os << "]";
+            os << ']';
 
           return;
         }
 
       octave_idx_type inc = nc;
       if (total_width > max_width && Vsplit_long_rows)
         {
           inc = max_width / column_width;
@@ -2317,17 +2317,17 @@ octave_print_internal (std::ostream& os,
       if (free_format)
         {
           if (pr_as_read_syntax)
             os << "[\n";
 
           os << ComplexMatrix (cm);
 
           if (pr_as_read_syntax)
-            os << "]";
+            os << ']';
 
           return;
         }
 
       octave_idx_type inc = nc;
       if (total_width > max_width && Vsplit_long_rows)
         {
           inc = max_width / column_width;
@@ -2363,17 +2363,17 @@ octave_print_internal (std::ostream& os,
 
               col += inc;
 
               if (col >= nc)
                 os << " ]";
               else
                 os << " ...\n";
             }
-          os << ")";
+          os << ')';
         }
       else
         {
           octave::preserve_stream_state stream_state (os);
 
           os << "Diagonal Matrix\n";
           if (! Vcompact_format)
             os << "\n";
@@ -2462,17 +2462,17 @@ octave_print_internal (std::ostream& os,
       if (free_format)
         {
           if (pr_as_read_syntax)
             os << "[\n";
 
           os << Matrix (m);
 
           if (pr_as_read_syntax)
-            os << "]";
+            os << ']';
 
           return;
         }
 
       octave_idx_type inc = nc;
       if (total_width > max_width && Vsplit_long_rows)
         {
           inc = max_width / column_width;
@@ -2511,17 +2511,17 @@ octave_print_internal (std::ostream& os,
 
               col += inc;
 
               if (col >= nc)
                 os << " ]";
               else
                 os << " ...\n";
             }
-          os << ")";
+          os << ')';
         }
       else
         {
           octave::preserve_stream_state stream_state (os);
 
           os << "Permutation Matrix\n";
           if (! Vcompact_format)
             os << "\n";
@@ -2898,19 +2898,19 @@ octave_print_internal (std::ostream& os,
 
               std::ostringstream buf;
 
               for (int k = 2; k < ndims; k++)
                 {
                   buf << ra_idx(k) + 1;
 
                   if (k < ndims - 1)
-                    buf << ",";
+                    buf << ',';
                   else
-                    buf << ")";
+                    buf << ')';
                 }
 
               nm += buf.str ();
             }
 
           Array<idx_vector> idx (dim_vector (ndims, 1));
 
           idx(0) = idx_vector (':');
@@ -3163,19 +3163,19 @@ octave_print_internal_template (std::ost
 
               std::ostringstream buf;
 
               for (int k = 2; k < ndims; k++)
                 {
                   buf << ra_idx(k) + 1;
 
                   if (k < ndims - 1)
-                    buf << ",";
+                    buf << ',';
                   else
-                    buf << ")";
+                    buf << ')';
                 }
 
               nm += buf.str ();
 
               os << nm << " =\n";
               if (! Vcompact_format)
                 os << "\n";
             }
@@ -3271,19 +3271,19 @@ octave_print_internal_template (std::ost
 
               std::ostringstream buf;
 
               for (int k = 2; k < ndims; k++)
                 {
                   buf << ra_idx(k) + 1;
 
                   if (k < ndims - 1)
-                    buf << ",";
+                    buf << ',';
                   else
-                    buf << ")";
+                    buf << ')';
                 }
 
               nm += buf.str ();
 
               os << nm << " =\n";
               if (! Vcompact_format)
                 os << "\n";
             }
@@ -3310,17 +3310,17 @@ octave_print_internal_template (std::ost
                       octave_quit ();
                       os << "  ";
                       os << typename octave_print_conv<T>::print_conv_type (page(ii,jj));
                     }
                   os << "\n";
                 }
 
               if (pr_as_read_syntax)
-                os << "]";
+                os << ']';
             }
           else
             {
               octave::preserve_stream_state stream_state (os);
 
               octave_idx_type n_rows = page.rows ();
               octave_idx_type n_cols = page.cols ();
 
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -304,17 +304,17 @@ Note: @code{qz} performs permutation bal
   std::cout << "qz: check matrix A" << std::endl;
 #endif
 
   // Matrix A: check dimensions.
   F77_INT nn = octave::to_f77_int (args(0).rows ());
   F77_INT nc = octave::to_f77_int (args(0).columns ());
 
 #if defined (DEBUG)
-  std::cout << "Matrix A dimensions: (" << nn << "," << nc << ")" << std::endl;
+  std::cout << "Matrix A dimensions: (" << nn << ',' << nc << ')' << std::endl;
 #endif
 
   if (args(0).isempty ())
     {
       warn_empty_arg ("qz: A");
       return octave_value_list (2, Matrix ());
     }
   else if (nc != nn)
@@ -777,19 +777,19 @@ Note: @code{qz} performs permutation bal
               std::cout << "safmin="
                         << setiosflags (std::ios::scientific)
                         << safmin << std::endl;
 
               for (F77_INT idr = j; idr <= j+1; idr++)
                 {
                   for (F77_INT idc = j; idc <= j+1; idc++)
                     {
-                      std::cout << "aa(" << idr << "," << idc << ")="
+                      std::cout << "aa(" << idr << ',' << idc << ")="
                                 << aa(idr,idc) << std::endl;
-                      std::cout << "bb(" << idr << "," << idc << ")="
+                      std::cout << "bb(" << idr << ',' << idc << ")="
                                 << bb(idr,idc) << std::endl;
                     }
                 }
 #endif
 
               // FIXME: probably should be using
               // fortran_vec instead of &aa(j,j) here.
 
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -1394,17 +1394,17 @@ namespace octave
 
   // look for @class/method>subfunction
   octave_value
   symbol_table::find_submethod (const std::string& name,
                                 const std::string& dispatch_type)
   {
     octave_value fcn;
 
-    std::string full_name = "@" + dispatch_type +
+    std::string full_name = '@' + dispatch_type +
       sys::file_ops::dir_sep_str () + name;
     size_t pos = full_name.find_first_of (Vfilemarker);
 
     if (pos != std::string::npos)
       {
         std::string fcn_scope = full_name.substr (0, pos);
         scope *stored_scope = m_current_scope;
         m_current_scope = m_top_scope;
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -703,17 +703,17 @@ namespace octave
 
         octave_value dump (void) const;
 
         std::string full_name (void) const
         {
           if (package_name.empty ())
             return name;
           else
-            return package_name + "." + name;
+            return package_name + '.' + name;
         }
 
         std::string name;
 
         std::string package_name;
 
         // File name to function object.
         std::map<std::string, octave_value> local_functions;
diff --git a/libinterp/corefcn/tril.cc b/libinterp/corefcn/tril.cc
--- a/libinterp/corefcn/tril.cc
+++ b/libinterp/corefcn/tril.cc
@@ -281,17 +281,17 @@ do_trilu (const std::string& name,
 
         octave_value_list ov_idx;
         std::list<octave_value_list> idx_tmp;
         ov_idx(1) = static_cast<double> (nc+1);
         ov_idx(0) = Range (1, nr);
         idx_tmp.push_back (ov_idx);
         ov_idx(1) = static_cast<double> (nc);
         tmp = tmp.resize (dim_vector (0,0));
-        tmp = tmp.subsasgn ("(",idx_tmp, arg.do_index_op (ov_idx));
+        tmp = tmp.subsasgn ("(", idx_tmp, arg.do_index_op (ov_idx));
         tmp = tmp.resize (dims);
 
         if (lower)
           {
             octave_idx_type st = (nc < nr + k ? nc : nr + k);
 
             for (octave_idx_type j = 1; j <= st; j++)
               {
diff --git a/libinterp/dldfcn/__delaunayn__.cc b/libinterp/dldfcn/__delaunayn__.cc
--- a/libinterp/dldfcn/__delaunayn__.cc
+++ b/libinterp/dldfcn/__delaunayn__.cc
@@ -128,17 +128,17 @@ Undocumented internal function.
       else if (args(1).isempty ())
         ;  // Use default options
       else if (args(1).iscellstr ())
         {
           options = "";
           Array<std::string> tmp = args(1).cellstr_value ();
 
           for (octave_idx_type i = 0; i < tmp.numel (); i++)
-            options += tmp(i) + " ";
+            options += tmp(i) + ' ';
         }
       else
         error ("__delaunayn__: OPTIONS argument must be a string, cell array of strings, or empty");
     }
 
   if (n > dim + 1)
     {
       p = p.transpose ();
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -143,17 +143,17 @@ public:
       hide_overlay ();
   }
 
   bool zoom (void) { return m_in_zoom; }
   void set_zoom_box (const Matrix& zb) { m_zoom_box = zb; }
 
   void print (const std::string& cmd, const std::string& term)
   {
-    //std::cout << "OpenGL_fltk::print(cmd=" << cmd << ", term=" << term << ") canvas size = " << w () << "x" << h () << std::endl;
+    //std::cout << "OpenGL_fltk::print(cmd=" << cmd << ", term=" << term << ") canvas size = " << w () << 'x' << h () << std::endl;
 
     octave::gl2ps_print (gh_manager::get_object (m_number), cmd, term);
   }
 
   uint8NDArray get_pixels (void)
   {
     m_renderer.draw (gh_manager::get_object (m_number));
     return m_renderer.get_pixels (w (), h ());
@@ -375,17 +375,17 @@ public:
             if (menupath == findname)
               return (t);
           }
         else
           {
             // End of submenu? Pop back one level.
             if (! m->label ())
               {
-                size_t idx = menupath.find_last_of ("/");
+                size_t idx = menupath.find_last_of ('/');
                 if (idx != std::string::npos)
                   menupath.erase (idx);
                 else
                   menupath.clear ();
                 continue;
               }
             // Menu item?
             std::string itempath = menupath;
@@ -595,31 +595,31 @@ public:
         do
           {
             const Fl_Menu_Item *item
               = m_menubar->find_item (fltk_label.c_str ());
 
             if (item)
               {
                 //avoid duplicate menulabels
-                size_t idx1 = fltk_label.find_last_of ("(");
-                size_t idx2 = fltk_label.find_last_of (")");
+                size_t idx1 = fltk_label.find_last_of ('(');
+                size_t idx2 = fltk_label.find_last_of (')');
                 int len = idx2 - idx1;
                 int val = 1;
                 if (len > 0)
                   {
                     std::string valstr = fltk_label.substr (idx1 + 1, len - 1);
                     fltk_label.erase (idx1, len + 1);
                     val = atoi (valstr.c_str ());
                     if (val > 0 && val < 99)
                       val++;
                   }
                 std::ostringstream valstream;
                 valstream << val;
-                fltk_label += "(" + valstream.str () + ")";
+                fltk_label += '(' + valstream.str () + ')';
               }
             else
               {
                 Matrix uimenu_ch = find_uimenu_children (uimenup);
                 int len = uimenu_ch.numel ();
                 int flags = 0;
                 if (len > 0)
                   flags = FL_SUBMENU;
@@ -1237,38 +1237,38 @@ private:
                      int px1 = -1, int py1 = -1)
   {
     double x0, y0, x1, y1;
     x0 = y0 = x1 = y1 = octave::numeric_limits<double>::NaN ();
     std::stringstream cbuf;
     cbuf.precision (4);
     cbuf.width (6);
     pixel2pos (ax, px0, py0, x0, y0);
-    cbuf << "[" << x0 << ", " << y0 << "]";
+    cbuf << '[' << x0 << ", " << y0 << ']';
     if (px1 >= 0)
       {
         pixel2pos (ax, px1, py1, x1, y1);
-        cbuf << " -> ["<< x1 << ", " << y1 << "]";
+        cbuf << " -> ["<< x1 << ", " << y1 << ']';
       }
 
     m_status->value (cbuf.str ().c_str ());
   }
 
   void view2status (graphics_object ax)
   {
     if (ax && ax.isa ("axes"))
       {
         axes::properties& ap =
           dynamic_cast<axes::properties&> (ax.get_properties ());
         std::stringstream cbuf;
         cbuf.precision (4);
         cbuf.width (6);
         Matrix v (1,2,0);
         v = ap.get ("view").matrix_value ();
-        cbuf << "[azimuth: " << v(0) << ", elevation: " << v(1) << "]";
+        cbuf << "[azimuth: " << v(0) << ", elevation: " << v(1) << ']';
 
         m_status->value (cbuf.str ().c_str ());
       }
   }
 
   void set_currentpoint (int px, int py)
   {
     if (! m_fp.is_beingdeleted ())
@@ -1388,17 +1388,17 @@ private:
       key_str = "separator";
     else if (e_key >= 0xffb0 && e_key <= 0xffb9)
       {
         tmp_str << "numpad" << (e_key - 0xffb0);
         key_str = tmp_str.str ();
       }
     else if (e_key >= (FL_F + 1) && e_key <= (FL_F + 12))
       {
-        tmp_str << "f" << (e_key - FL_F);
+        tmp_str << 'f' << (e_key - FL_F);
         key_str = tmp_str.str ();
       }
     else if (e_key == ',')
       key_str = "comma";
     else if (e_key == '.')
       key_str = "period";
     else if (e_key == '-')
       key_str = "hyphen";
@@ -2294,17 +2294,17 @@ public:
       {
         uimenu::properties& uimenup =
           dynamic_cast<uimenu::properties&> (uimenu_obj.get_properties ());
         std::string fltk_label = uimenup.get_label ();
         graphics_object go = gh_manager::get_object (uimenu_obj.get_parent ());
         if (go.isa ("uimenu"))
           fltk_label = dynamic_cast<const uimenu::properties&>
                        (go.get_properties ()).get___fltk_label__ ()
-                       + "/"
+                       + '/'
                        + fltk_label;
         else if (go.isa ("figure") || go.isa ("uicontextmenu"))
           ;
         else
           error ("invalid parent object\n");
 
         uimenup.set___fltk_label__ (fltk_label);
       }
diff --git a/libinterp/dldfcn/__voronoi__.cc b/libinterp/dldfcn/__voronoi__.cc
--- a/libinterp/dldfcn/__voronoi__.cc
+++ b/libinterp/dldfcn/__voronoi__.cc
@@ -118,27 +118,27 @@ Undocumented internal function.
   else
     options = " Qbb Qx";
 
   if (nargin == 3)
     {
       octave_value opt_arg = args(2);
 
       if (opt_arg.is_string ())
-        options = " " + opt_arg.string_value ();
+        options = ' ' + opt_arg.string_value ();
       else if (opt_arg.isempty ())
         ; // Use default options.
       else if (opt_arg.iscellstr ())
         {
           options = "";
 
           Array<std::string> tmp = opt_arg.cellstr_value ();
 
           for (octave_idx_type i = 0; i < tmp.numel (); i++)
-            options += " " + tmp(i);
+            options += ' ' + tmp(i);
         }
       else
         error ("%s: OPTIONS must be a string, cell array of strings, or empty",
                caller.c_str ());
     }
 
   boolT ismalloc = false;
 
diff --git a/libinterp/dldfcn/audioread.cc b/libinterp/dldfcn/audioread.cc
--- a/libinterp/dldfcn/audioread.cc
+++ b/libinterp/dldfcn/audioread.cc
@@ -288,17 +288,17 @@ Comment.
   else if (args(1).isinteger ())
     err_wrong_type_arg ("audiowrite", args(1));
 
   Matrix audio = args(1).matrix_value ();
 
   int samplerate = args(2).int_value ();
 
   std::string ext;
-  size_t dotpos = filename.find_last_of (".");
+  size_t dotpos = filename.find_last_of ('.');
   if (dotpos != std::string::npos)
     ext = filename.substr (dotpos + 1);
   std::transform (ext.begin (), ext.end (), ext.begin (), ::tolower);
 
   sf_count_t items_to_write = audio.rows () * audio.columns ();
 
   if (audio.rows () == 1)
     audio = audio.transpose ();
diff --git a/libinterp/dldfcn/ccolamd.cc b/libinterp/dldfcn/ccolamd.cc
--- a/libinterp/dldfcn/ccolamd.cc
+++ b/libinterp/dldfcn/ccolamd.cc
@@ -164,17 +164,17 @@ ccolamd, csymamd, amd, colamd, symamd, a
       if (nel_User_knobs > 3)
         knobs[CCOLAMD_AGGRESSIVE] = (User_knobs(3) != 0);
       if (nel_User_knobs > 4)
         spumoni = (User_knobs(4) != 0);
 
       // print knob settings if spumoni is set
       if (spumoni)
         {
-          octave_stdout << "\nccolamd version " << CCOLAMD_MAIN_VERSION << "."
+          octave_stdout << "\nccolamd version " << CCOLAMD_MAIN_VERSION << '.'
                         <<  CCOLAMD_SUB_VERSION << ", " << CCOLAMD_DATE
                         << ":\nknobs(1): " << User_knobs(0) << ", order for ";
           if (knobs[CCOLAMD_LU] != 0)
             octave_stdout << "lu (A)\n";
           else
             octave_stdout << "chol (A'*A)\n";
 
           if (knobs[CCOLAMD_DENSE_ROW] >= 0)
@@ -426,17 +426,17 @@ ccolamd, csymamd, amd, colamd, symamd, a
         knobs[CCOLAMD_AGGRESSIVE] = User_knobs(1);
       if (nel_User_knobs > 1)
         spumoni = static_cast<int> (User_knobs(2));
 
       // print knob settings if spumoni is set
       if (spumoni)
         {
           octave_stdout << "\ncsymamd version " << CCOLAMD_MAIN_VERSION
-                        << "." << CCOLAMD_SUB_VERSION
+                        << '.' << CCOLAMD_SUB_VERSION
                         << ", " << CCOLAMD_DATE << "\n";
 
           if (knobs[CCOLAMD_DENSE_ROW] >= 0)
             octave_stdout << "knobs(1): " << User_knobs(0)
                           << ", rows/cols with > max (16,"
                           << knobs[CCOLAMD_DENSE_ROW]
                           << "*sqrt (size(A,2)))"
                           << " entries removed\n";
diff --git a/libinterp/dldfcn/colamd.cc b/libinterp/dldfcn/colamd.cc
--- a/libinterp/dldfcn/colamd.cc
+++ b/libinterp/dldfcn/colamd.cc
@@ -298,17 +298,17 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
       if (nel_User_knobs > 2)
         spumoni = static_cast<int> (User_knobs(2));
 
       // print knob settings if spumoni is set
       if (spumoni)
         {
 
           octave_stdout << "\ncolamd version " << COLAMD_MAIN_VERSION
-                        << "." <<  COLAMD_SUB_VERSION
+                        << '.' <<  COLAMD_SUB_VERSION
                         << ", " << COLAMD_DATE << ":\n";
 
           if (knobs[COLAMD_DENSE_ROW] >= 0)
             octave_stdout << "knobs(1): " << User_knobs (0)
                           << ", rows with > max (16,"
                           << knobs[COLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
                           << " entries removed\n";
           else
@@ -697,17 +697,17 @@ permutations on the tree.
       cidx = sm.xcidx ();
     }
 
   bool is_sym = true;
 
   if (nargin == 2)
     {
       std::string str = args(1).xstring_value ("etree: TYP must be a string");
-      if (str.find ("C") == 0 || str.find ("c") == 0)
+      if (str.find ('C') == 0 || str.find ('c') == 0)
         is_sym = false;
     }
 
   // column elimination tree post-ordering (reuse variables)
   OCTAVE_LOCAL_BUFFER (octave_idx_type, etree, n_col + 1);
 
   if (is_sym)
     {
diff --git a/libinterp/dldfcn/convhulln.cc b/libinterp/dldfcn/convhulln.cc
--- a/libinterp/dldfcn/convhulln.cc
+++ b/libinterp/dldfcn/convhulln.cc
@@ -135,27 +135,27 @@ convex hull is calculated.
   if (dim <= 4)
     options = " Qt";
   else
     options = " Qt Qx";
 
   if (nargin == 2)
     {
       if (args(1).is_string ())
-        options = " " + args(1).string_value ();
+        options = ' ' + args(1).string_value ();
       else if (args(1).isempty ())
         ; // Use default options.
       else if (args(1).iscellstr ())
         {
           options = "";
 
           Array<std::string> tmp = args(1).cellstr_value ();
 
           for (octave_idx_type i = 0; i < tmp.numel (); i++)
-            options += " " + tmp(i);
+            options += ' ' + tmp(i);
         }
       else
         error ("convhulln: OPTIONS must be a string, cell array of strings, or empty");
     }
 
   boolT ismalloc = false;
 
   octave::unwind_protect frame;
diff --git a/libinterp/octave-value/ov-base-int.cc b/libinterp/octave-value/ov-base-int.cc
--- a/libinterp/octave-value/ov-base-int.cc
+++ b/libinterp/octave-value/ov-base-int.cc
@@ -268,17 +268,17 @@ template <typename T>
 bool
 octave_base_int_matrix<T>::save_ascii (std::ostream& os)
 {
   dim_vector dv = this->dims ();
 
   os << "# ndims: " << dv.ndims () << "\n";
 
   for (int i = 0; i < dv.ndims (); i++)
-    os << " " << dv(i);
+    os << ' ' << dv(i);
 
   os << "\n" << this->matrix;
 
   return true;
 }
 
 template <typename T>
 bool
diff --git a/libinterp/octave-value/ov-base-mat.cc b/libinterp/octave-value/ov-base-mat.cc
--- a/libinterp/octave-value/ov-base-mat.cc
+++ b/libinterp/octave-value/ov-base-mat.cc
@@ -466,26 +466,26 @@ octave_base_matrix<MT>::short_disp (std:
       octave_idx_type max_elts = 10;
       octave_idx_type elts = 0;
 
       octave_idx_type nel = matrix.numel ();
 
       octave_idx_type nr = matrix.rows ();
       octave_idx_type nc = matrix.columns ();
 
-      os << "[";
+      os << '[';
 
       for (octave_idx_type i = 0; i < nr; i++)
         {
           for (octave_idx_type j = 0; j < nc; j++)
             {
               std::ostringstream buf;
               octave_print_internal (buf, matrix(j*nr+i));
               std::string tmp = buf.str ();
-              size_t pos = tmp.find_first_not_of (" ");
+              size_t pos = tmp.find_first_not_of (' ');
               if (pos != std::string::npos)
                 os << tmp.substr (pos);
               else if (! tmp.empty ())
                 os << tmp[0];
 
               if (++elts >= max_elts)
                 goto done;
 
@@ -495,17 +495,17 @@ octave_base_matrix<MT>::short_disp (std:
 
           if (i < nr - 1 && elts < max_elts)
             os << "; ";
         }
 
     done:
 
       if (nel <= max_elts)
-        os << "]";
+        os << ']';
     }
   else
     os << "...";
 }
 
 template <typename MT>
 octave_value
 octave_base_matrix<MT>::fast_elem_extract (octave_idx_type n) const
diff --git a/libinterp/octave-value/ov-base-scalar.cc b/libinterp/octave-value/ov-base-scalar.cc
--- a/libinterp/octave-value/ov-base-scalar.cc
+++ b/libinterp/octave-value/ov-base-scalar.cc
@@ -176,17 +176,17 @@ octave_base_scalar<ST>::print_name_tag (
 
 template <typename ST>
 void
 octave_base_scalar<ST>::short_disp (std::ostream& os) const
 {
   std::ostringstream buf;
   octave_print_internal (buf, scalar);
   std::string tmp = buf.str ();
-  size_t pos = tmp.find_first_not_of (" ");
+  size_t pos = tmp.find_first_not_of (' ');
   if (pos != std::string::npos)
     os << tmp.substr (pos);
   else if (! tmp.empty ())
     os << tmp[0];
 }
 
 template <typename ST>
 octave_value
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -244,17 +244,17 @@ octave_base_value::do_index_op (const oc
 {
   std::string nm = type_name ();
   error ("can't perform indexing operations for %s type", nm.c_str ());
 }
 
 idx_vector
 octave_base_value::index_vector (bool /* require_integers */) const
 {
-  std::string nm = "<" + type_name () + ">";
+  std::string nm = '<' + type_name () + '>';
   octave::err_invalid_index (nm.c_str ());
 }
 
 octave_value
 octave_base_value::subsasgn (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              const octave_value& rhs)
 {
@@ -1341,17 +1341,17 @@ octave_base_value::indent (std::ostream&
   assert (curr_print_indent_level >= 0);
 
   if (beginning_of_line)
     {
       // FIXME: do we need this?
       // os << prefix;
 
       for (int i = 0; i < curr_print_indent_level; i++)
-        os << " ";
+        os << ' ';
 
       beginning_of_line = false;
     }
 }
 
 // All print() functions should use this to print new lines.
 
 void
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -236,17 +236,17 @@ octave_bool_matrix::save_ascii (std::ost
 {
   dim_vector dv = dims ();
   if (dv.ndims () > 2)
     {
       NDArray tmp = array_value ();
       os << "# ndims: " << dv.ndims () << "\n";
 
       for (int i = 0; i < dv.ndims (); i++)
-        os << " " << dv(i);
+        os << ' ' << dv(i);
 
       os << "\n" << tmp;
     }
   else
     {
       // Keep this case, rather than use generic code above for backward
       // compatibility.  Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -643,56 +643,56 @@ octave_cell::print_raw (std::ostream& os
   if (nd == 2)
     {
       octave_idx_type nr = rows ();
       octave_idx_type nc = columns ();
 
       if (nr > 0 && nc > 0)
         {
           indent (os);
-          os << "{";
+          os << '{';
           newline (os);
 
           increment_indent_level ();
 
           for (octave_idx_type j = 0; j < nc; j++)
             {
               for (octave_idx_type i = 0; i < nr; i++)
                 {
                   octave_quit ();
 
                   std::ostringstream buf;
-                  buf << "[" << i+1 << "," << j+1 << "]";
+                  buf << '[' << i+1 << ',' << j+1 << ']';
 
                   octave_value val = matrix(i,j);
 
                   val.print_with_name (os, buf.str ());
                 }
             }
 
           decrement_indent_level ();
 
           indent (os);
-          os << "}";
+          os << '}';
           newline (os);
         }
       else
         {
           indent (os);
           os << "{}";
           if (Vprint_empty_dimensions)
-            os << "(" << nr << "x" << nc << ")";
+            os << '(' << nr << 'x' << nc << ')';
           newline (os);
         }
     }
   else
     {
       indent (os);
       dim_vector dv = matrix.dims ();
-      os << "{" << dv.str () << " Cell Array}";
+      os << '{' << dv.str () << " Cell Array}";
       newline (os);
     }
 }
 
 bool
 octave_cell::print_name_tag (std::ostream& os, const std::string& name) const
 {
   bool retval = false;
@@ -723,17 +723,17 @@ bool
 octave_cell::save_ascii (std::ostream& os)
 {
   dim_vector dv = dims ();
   if (dv.ndims () > 2)
     {
       os << "# ndims: " << dv.ndims () << "\n";
 
       for (int i = 0; i < dv.ndims (); i++)
-        os << " " << dv(i);
+        os << ' ' << dv(i);
       os << "\n";
 
       Cell tmp = cell_value ();
 
       for (octave_idx_type i = 0; i < dv.numel (); i++)
         {
           octave_value o_val = tmp.elem (i);
 
@@ -1054,17 +1054,17 @@ octave_cell::save_hdf5 (octave_hdf5_id l
 
   octave_idx_type nel = dv.numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       std::ostringstream buf;
       int digits = static_cast<int> (std::floor (::log10 (static_cast<double>
                                      (nel)) + 1.0));
-      buf << "_" << std::setw (digits) << std::setfill ('0') << i;
+      buf << '_' << std::setw (digits) << std::setfill ('0') << i;
       std::string s = buf.str ();
 
       if (! add_hdf5_data (data_hid, tmp.elem (i), s.c_str (), "", false,
                            save_as_floats))
         {
           H5Gclose (data_hid);
           return false;
         }
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -1008,17 +1008,17 @@ octave_class::print (std::ostream& os, b
 }
 
 void
 octave_class::print_raw (std::ostream& os, bool) const
 {
   octave::unwind_protect frame;
 
   indent (os);
-  os << "  <class " << class_name () << ">";
+  os << "  <class " << class_name () << '>';
   newline (os);
 }
 
 bool
 octave_class::print_name_tag (std::ostream& os, const std::string& name) const
 {
   return octave_base_value::print_name_tag (os, name);
 }
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -972,17 +972,17 @@ octave_classdef::print (std::ostream& os
 
 void
 octave_classdef::print_raw (std::ostream& os, bool) const
 {
   indent (os);
   os << "<object ";
   if (object.is_array ())
     os << "array ";
-  os << class_name () << ">";
+  os << class_name () << '>';
   newline (os);
 }
 
 bool
 octave_classdef::print_name_tag (std::ostream& os,
                                  const std::string& name) const
 {
   return octave_base_value::print_name_tag (os, name);
@@ -2531,17 +2531,17 @@ cdef_class::make_meta_class (octave::int
 {
   cdef_class retval;
   std::string class_name, full_class_name;
 
   // Class creation
 
   class_name = full_class_name = t->ident ()->name ();
   if (! t->package_name ().empty ())
-    full_class_name = t->package_name () + "." + full_class_name;
+    full_class_name = t->package_name () + '.' + full_class_name;
 
 #if DEBUG_TRACE
   std::cerr << "class: " << full_class_name << std::endl;
 #endif
 
   std::list<cdef_class> slist;
 
   if (t->superclass_list ())
@@ -2648,20 +2648,20 @@ cdef_class::make_meta_class (octave::int
             {
               for (auto& mtd : *mb_p->element_list ())
                 {
                   std::string mname = mtd.function_value ()->name ();
                   std::string mprefix = mname.substr (0, 4);
 
                   if (mprefix == "get.")
                     get_methods[mname.substr (4)] =
-                      make_fcn_handle (mtd, full_class_name + ">" + mname);
+                      make_fcn_handle (mtd, full_class_name + '>' + mname);
                   else if (mprefix == "set.")
                     set_methods[mname.substr (4)] =
-                      make_fcn_handle (mtd, full_class_name + ">" + mname);
+                      make_fcn_handle (mtd, full_class_name + '>' + mname);
                   else
                     {
                       cdef_method meth = make_method (retval, mname, mtd);
 
 #if DEBUG_TRACE
                       std::cerr << (mname == class_name ? "constructor"
                                                         : "method")
                                 << ": " << mname << std::endl;
@@ -3251,17 +3251,17 @@ cdef_package::cdef_package_rep::get_func
 
 Cell
 cdef_package::cdef_package_rep::get_packages (void) const
 { return map2Cell (package_map); }
 
 octave_value
 cdef_package::cdef_package_rep::find (const std::string& nm)
 {
-  std::string symbol_name = get_name () + "." + nm;
+  std::string symbol_name = get_name () + '.' + nm;
 
   octave::symbol_table& symtab
     = octave::__get_symbol_table__ ("cdef_package::cdef_package_rep::find");
 
   return symtab.find (symbol_name, octave_value_list (), true, false);
 }
 
 octave_value_list
@@ -3811,17 +3811,17 @@ Undocumented internal function.
 DEFUN (__meta_class_query__, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} __meta_class_query__ ()
 Undocumented internal function.
 @end deftypefn */)
 {
 #if DEBUG_TRACE
   std::cerr << "__meta_class_query__ ("
-            << args(0).string_value () << ")"
+            << args(0).string_value () << ')'
             << std::endl;
 #endif
 
   if (args.length () != 1)
     print_usage ();
 
   std::string cls = args(0).xstring_value ("CLASS_NAME must be a string");
 
diff --git a/libinterp/octave-value/ov-colon.cc b/libinterp/octave-value/ov-colon.cc
--- a/libinterp/octave-value/ov-colon.cc
+++ b/libinterp/octave-value/ov-colon.cc
@@ -39,10 +39,10 @@ octave_magic_colon::print (std::ostream&
 {
   indent (os);
   print_raw (os);
 }
 
 void
 octave_magic_colon::print_raw (std::ostream& os, bool) const
 {
-  os << ":";
+  os << ':';
 }
diff --git a/libinterp/octave-value/ov-complex.cc b/libinterp/octave-value/ov-complex.cc
--- a/libinterp/octave-value/ov-complex.cc
+++ b/libinterp/octave-value/ov-complex.cc
@@ -134,17 +134,17 @@ octave_complex::do_index_op (const octav
   return tmp.do_index_op (idx, resize_ok);
 }
 
 // Can't make an index_vector from a complex number.  Throw an error.
 idx_vector
 octave_complex::index_vector (bool) const
 {
   std::ostringstream buf;
-  buf << scalar.real () << std::showpos << scalar.imag () << "i";
+  buf << scalar.real () << std::showpos << scalar.imag () << 'i';
   octave::complex_index_exception e (buf.str ());
 
   throw e;
 }
 
 double
 octave_complex::double_value (bool force_conversion) const
 {
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -319,17 +319,17 @@ octave_complex_matrix::save_ascii (std::
   dim_vector dv = dims ();
   if (dv.ndims () > 2)
     {
       ComplexNDArray tmp = complex_array_value ();
 
       os << "# ndims: " << dv.ndims () << "\n";
 
       for (int i = 0; i < dv.ndims (); i++)
-        os << " " << dv(i);
+        os << ' ' << dv(i);
 
       os << "\n" << tmp;
     }
   else
     {
       // Keep this case, rather than use generic code above for backward
       // compatibility.  Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -523,17 +523,17 @@ octave_fcn_handle::save_binary (std::ost
       octave_user_function *f = fcn.user_function_value ();
       octave::symbol_table::scope *f_scope = f->scope ();
       if (f_scope)
         vars = f_scope->all_variables ();
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
-        nmbuf << nm << " " << varlen;
+        nmbuf << nm << ' ' << varlen;
       else
         nmbuf << nm;
 
       std::string buf_str = nmbuf.str ();
       int32_t tmp = buf_str.length ();
       os.write (reinterpret_cast<char *> (&tmp), 4);
       os.write (buf_str.c_str (), buf_str.length ());
 
@@ -1467,17 +1467,17 @@ octave_fcn_handle::print_raw (std::ostre
                 tpc.print_fcn_handle_body (e);
             }
 
           printed = true;
         }
     }
 
   if (! printed)
-    octave_print_internal (os, "@" + nm, pr_as_read_syntax,
+    octave_print_internal (os, '@' + nm, pr_as_read_syntax,
                            current_print_indent_level ());
 }
 
 octave_value
 make_fcn_handle (const std::string& nm, bool local_funcs)
 {
   octave_value retval;
 
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -638,17 +638,17 @@ octave_fcn_inline::print (std::ostream& 
 void
 octave_fcn_inline::print_raw (std::ostream& os, bool pr_as_read_syntax) const
 {
   std::ostringstream buf;
 
   if (nm.empty ())
     buf << "f(";
   else
-    buf << nm << "(";
+    buf << nm << '(';
 
   for (int i = 0; i < ifargs.numel (); i++)
     {
       if (i)
         buf << ", ";
 
       buf << ifargs(i);
     }
@@ -780,17 +780,17 @@ functions from strings is through the us
                   && tmp_arg != "e" && tmp_arg != "eps")
                 fargs.append (tmp_arg);
 
               tmp_arg = "";
               is_arg = false;
             }
         }
 
-      // Sort the arguments into ascii order.
+      // Sort the arguments into ASCII order.
       fargs.sort ();
 
       if (fargs.isempty ())
         fargs.append (std::string ("x"));
 
     }
   else if (nargin == 2 && args(1).isnumeric ())
     {
@@ -804,17 +804,17 @@ functions from strings is through the us
 
       fargs.resize (n+1);
 
       fargs(0) = "x";
 
       for (int i = 1; i < n+1; i++)
         {
           std::ostringstream buf;
-          buf << "P" << i;
+          buf << 'P' << i;
           fargs(i) = buf.str ();
         }
     }
   else
     {
       fargs.resize (nargin - 1);
 
       for (int i = 1; i < nargin; i++)
@@ -957,23 +957,23 @@ quadv (fcn, 0, 3)
 
   while (i < old_func.length ())
     {
       std::string t1 = old_func.substr (i, 1);
 
       if (t1 == "*" || t1 == "/" || t1 == "\\" || t1 == "^")
         {
           if (i && old_func.substr (i-1, 1) != ".")
-            new_func.append (".");
+            new_func += '.';
 
           // Special case for ** operator.
           if (t1 == "*" && i < (old_func.length () - 1)
               && old_func.substr (i+1, 1) == "*")
             {
-              new_func.append ("*");
+              new_func += '*';
               i++;
             }
         }
       new_func.append (t1);
       i++;
     }
 
   if (func_is_string)
diff --git a/libinterp/octave-value/ov-fcn.h b/libinterp/octave-value/ov-fcn.h
--- a/libinterp/octave-value/ov-fcn.h
+++ b/libinterp/octave-value/ov-fcn.h
@@ -181,17 +181,17 @@ public:
 
   std::string name (void) const { return my_name; }
 
   std::string canonical_name (void) const
   {
     if (xpackage_name.empty ())
       return my_name;
     else
-      return xpackage_name + "." + my_name;
+      return xpackage_name + '.' + my_name;
   }
 
   void document (const std::string& ds) { doc = ds; }
 
   std::string doc_string (void) const { return doc; }
 
   virtual void unload (void) { }
 
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -293,17 +293,17 @@ octave_float_complex_matrix::save_ascii 
   dim_vector dv = dims ();
   if (dv.ndims () > 2)
     {
       FloatComplexNDArray tmp = complex_array_value ();
 
       os << "# ndims: " << dv.ndims () << "\n";
 
       for (int i = 0; i < dv.ndims (); i++)
-        os << " " << dv(i);
+        os << ' ' << dv(i);
 
       os << "\n" << tmp;
     }
   else
     {
       // Keep this case, rather than use generic code above for backward
       // compatibility.  Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -370,17 +370,17 @@ octave_float_matrix::save_ascii (std::os
 
   if (dv.ndims () > 2)
     {
       FloatNDArray tmp = float_array_value ();
 
       os << "# ndims: " << dv.ndims () << "\n";
 
       for (int i=0; i < dv.ndims (); i++)
-        os << " " << dv(i);
+        os << ' ' << dv(i);
 
       os << "\n" << tmp;
     }
   else
     {
       // Keep this case, rather than use generic code above for backward
       // compatibility.  Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -220,17 +220,17 @@ namespace octave
       if (! js.bad () && ! js.fail ())
         {
           std::string line;
 
           while (! js.eof () && ! js.fail ())
             {
               std::getline (js, line);
 
-              if (line.find ("-") == 0)
+              if (line.find ('-') == 0)
                 java_opts.push_back (line);
               else if (line.length () > 0 && Vdebug_java)
                 std::cerr << "invalid JVM option, skipping: " << line << std::endl;
             }
         }
     }
 
   private:
@@ -432,33 +432,33 @@ initial_class_path (void)
           // The filename is "javaclasspath.txt", but historically
           // has been "classpath.txt" so both are supported.
           std::string cp_list[] = {"javaclasspath.txt", "classpath.txt"};
 
           for (int i=0; i<2; i++)
             {
               std::string filename = cp_list[i];
               std::string cp_file = filename;
-              octave::sys::file_stat   cp_exists;
+              octave::sys::file_stat cp_exists;
 
               // Try to find classpath file in the current directory.
 
               cp_exists = octave::sys::file_stat (cp_file);
               if (cp_exists)
                 {
                   // File found.  Add its contents to the static classpath.
                   std::string classpath = read_classpath_txt (cp_file);
                   retval.append (classpath);
                 }
 
               // Try to find classpath file in the user's home directory.
 
               if (cwd != home_dir)
                 {
-                  cp_file = "~" + sep + filename;
+                  cp_file = '~' + sep + filename;
                   cp_file = octave::sys::file_ops::tilde_expand (cp_file);
                   cp_exists = octave::sys::file_stat (cp_file);
                   if (cp_exists)
                     {
                       // File found.  Add its contents to the static classpath.
                       std::string classpath = read_classpath_txt (cp_file);
                       retval.append (classpath);
                     }
@@ -2167,17 +2167,17 @@ octave_java::print (std::ostream& os, bo
 {
   print_raw (os);
   newline (os);
 }
 
 void
 octave_java::print_raw (std::ostream& os, bool) const
 {
-  os << "<Java object: " << java_classname << ">";
+  os << "<Java object: " << java_classname << '>';
 }
 
 // FIXME: Need routines to actually save/load java objects through Serialize.
 //        See bug #42112.
 
 bool
 octave_java::save_ascii (std::ostream& /* os */)
 {
diff --git a/libinterp/octave-value/ov-oncleanup.cc b/libinterp/octave-value/ov-oncleanup.cc
--- a/libinterp/octave-value/ov-oncleanup.cc
+++ b/libinterp/octave-value/ov-oncleanup.cc
@@ -175,17 +175,17 @@ octave_oncleanup::print (std::ostream& o
 }
 
 void
 octave_oncleanup::print_raw (std::ostream& os, bool pr_as_read_syntax) const
 {
   os << "onCleanup (";
   if (fcn.is_defined ())
     fcn.print_raw (os, pr_as_read_syntax);
-  os << ")";
+  os << ')';
 }
 
 DEFUN (onCleanup, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {@var{obj} =} onCleanup (@var{function})
 Create a special object that executes a given function upon destruction.
 
 If the object is copied to multiple variables (or cell or struct array
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -467,22 +467,22 @@ void
 octave_range::short_disp (std::ostream& os) const
 {
   octave_idx_type len = range.numel ();
 
   if (len == 0)
     os << "[]";
   else
     {
-      os << range.base () << ":";
+      os << range.base () << ':';
 
       if (len > 1)
         {
           if (range.inc () != 1)
-            os << range.inc () << ":";
+            os << range.inc () << ':';
 
           os << range.limit ();
         }
     }
 }
 
 // Skip white space and comments on stream IS.
 
@@ -511,22 +511,22 @@ octave_range::save_ascii (std::ostream& 
   octave_idx_type len = r.numel ();
 
   if (inc != 0)
     os << "# base, limit, increment\n";
   else
     os << "# base, length, increment\n";
 
   octave_write_double (os, base);
-  os << " ";
+  os << ' ';
   if (inc != 0)
     octave_write_double (os, limit);
   else
     os << len;
-  os << " ";
+  os << ' ';
   octave_write_double (os, inc);
   os << "\n";
 
   return true;
 }
 
 bool
 octave_range::load_ascii (std::istream& is)
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -472,17 +472,17 @@ octave_matrix::save_ascii (std::ostream&
 
   if (dv.ndims () > 2)
     {
       NDArray tmp = array_value ();
 
       os << "# ndims: " << dv.ndims () << "\n";
 
       for (int i=0; i < dv.ndims (); i++)
-        os << " " << dv(i);
+        os << ' ' << dv(i);
 
       os << "\n" << tmp;
     }
   else
     {
       // Keep this case, rather than use generic code above for backward
       // compatibility.  Makes load_ascii much more complex!!
       os << "# rows: " << rows () << "\n"
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -56,17 +56,17 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
 
 idx_vector
 octave_sparse_matrix::index_vector (bool /* require_integers */) const
 {
   if (matrix.numel () == matrix.nnz ())
     return idx_vector (array_value ());
   else
     {
-      std::string nm = "<" + type_name () + ">";
+      std::string nm = '<' + type_name () + '>';
       octave::err_invalid_index (nm.c_str ());
     }
 }
 
 octave_base_value *
 octave_sparse_matrix::try_narrowing_conversion (void)
 {
   octave_base_value *retval = nullptr;
diff --git a/libinterp/octave-value/ov-str-mat.cc b/libinterp/octave-value/ov-str-mat.cc
--- a/libinterp/octave-value/ov-str-mat.cc
+++ b/libinterp/octave-value/ov-str-mat.cc
@@ -281,17 +281,17 @@ bool
 octave_char_matrix_str::save_ascii (std::ostream& os)
 {
   dim_vector dv = dims ();
   if (dv.ndims () > 2)
     {
       charNDArray tmp = char_array_value ();
       os << "# ndims: " << dv.ndims () << "\n";
       for (int i=0; i < dv.ndims (); i++)
-        os << " " << dv(i);
+        os << ' ' << dv(i);
       os << "\n";
       os.write (tmp.fortran_vec (), dv.numel ());
       os << "\n";
     }
   else
     {
       // Keep this case, rather than use generic code above for
       // backward compatibility.  Makes load_ascii much more complex!!
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -661,17 +661,17 @@ octave_struct::save_ascii (std::ostream&
 
   octave_idx_type nf = m.nfields ();
 
   const dim_vector dv = dims ();
 
   os << "# ndims: " << dv.ndims () << "\n";
 
   for (int i = 0; i < dv.ndims (); i++)
-    os << " " << dv(i);
+    os << ' ' << dv(i);
   os << "\n";
 
   os << "# length: " << nf << "\n";
 
   // Iterating over the list of keys will preserve the order of the
   // fields.
   string_vector keys = m.fieldnames ();
 
@@ -1283,17 +1283,17 @@ octave_scalar_struct::print_raw (std::os
 
           octave_value val = map.contents (key);
 
           if (print_fieldnames_only)
             {
               indent (os);
               os << key;
               dim_vector dv = val.dims ();
-              os << ": " << dv.str () << " " << val.type_name ();
+              os << ": " << dv.str () << ' ' << val.type_name ();
               newline (os);
             }
           else
             val.print_with_name (os, key);
         }
 
       decrement_indent_level ();
       decrement_indent_level ();
@@ -1336,17 +1336,17 @@ octave_scalar_struct::save_ascii (std::o
 
   octave_idx_type nf = m.nfields ();
 
   const dim_vector dv = dims ();
 
   os << "# ndims: " << dv.ndims () << "\n";
 
   for (int i = 0; i < dv.ndims (); i++)
-    os << " " << dv(i);
+    os << ' ' << dv(i);
   os << "\n";
 
   os << "# length: " << nf << "\n";
 
   // Iterating over the list of keys will preserve the order of the
   // fields.
   string_vector keys = m.fieldnames ();
 
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -365,26 +365,26 @@ octave_user_function::stash_parent_fcn_s
 
 std::string
 octave_user_function::profiler_name (void) const
 {
   std::ostringstream result;
 
   if (is_anonymous_function ())
     result << "anonymous@" << fcn_file_name ()
-           << ":" << location_line << ":" << location_column;
+           << ':' << location_line << ':' << location_column;
   else if (is_subfunction ())
-    result << parent_fcn_name () << ">" << name ();
+    result << parent_fcn_name () << '>' << name ();
   else if (is_class_method ())
-    result << "@" << dispatch_class () << "/" << name ();
+    result << '@' << dispatch_class () << '/' << name ();
   else if (is_class_constructor () || is_classdef_constructor ())
-    result << "@" << name ();
+    result << '@' << name ();
   else if (is_inline_function ())
     result << "inline@" << fcn_file_name ()
-           << ":" << location_line << ":" << location_column;
+           << ':' << location_line << ':' << location_column;
   else
     result << name ();
 
   return result.str ();
 }
 
 void
 octave_user_function::mark_as_system_fcn_file (void)
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -2557,17 +2557,17 @@ do_colon_op (const octave_value& base, c
 
 void
 octave_value::print_info (std::ostream& os, const std::string& prefix) const
 {
   os << prefix << "type_name: " << type_name () << "\n"
      << prefix << "count:     " << get_count () << "\n"
      << prefix << "rep info:  ";
 
-  rep->print_info (os, prefix + " ");
+  rep->print_info (os, prefix + ' ');
 }
 
 OCTAVE_NORETURN static void
 err_unary_op (const std::string& on, const std::string& tn)
 {
   error ("unary operator '%s' not implemented for '%s' operands",
          on.c_str (), tn.c_str ());
 }
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -139,17 +139,17 @@ namespace octave
             break;
 
           case EVAL_OPTION:
             if (octave_optarg_wrapper ())
               {
                 if (m_code_to_eval.empty ())
                   m_code_to_eval = octave_optarg_wrapper ();
                 else
-                  m_code_to_eval += std::string (" ") + octave_optarg_wrapper ();
+                  m_code_to_eval += ' ' + octave_optarg_wrapper ();
               }
             break;
 
           case EXEC_PATH_OPTION:
             if (octave_optarg_wrapper ())
               m_exec_path = octave_optarg_wrapper ();
             break;
 
diff --git a/libinterp/parse-tree/bp-table.cc b/libinterp/parse-tree/bp-table.cc
--- a/libinterp/parse-tree/bp-table.cc
+++ b/libinterp/parse-tree/bp-table.cc
@@ -434,17 +434,17 @@ bp_table::parse_dbfunction_params (const
 
         case dbstop_if:
           if (seen_in)    // conditional breakpoint
             {
               cond = "";  // remaining arguments form condition
               for (; pos < nargin; pos++)
                 {
                   if (args(pos).is_string ())
-                    cond = cond + " " + args(pos).string_value ();
+                    cond = cond + ' ' + args(pos).string_value ();
                   else
                     error ("%s: arguments to 'if' must all be strings", who);
                 }
 
               cond = cond.substr (1);   // omit initial space
             }
           else    // stop on event (error, warning, interrupt, NaN/inf)
             {
diff --git a/libinterp/parse-tree/jit-ir.cc b/libinterp/parse-tree/jit-ir.cc
--- a/libinterp/parse-tree/jit-ir.cc
+++ b/libinterp/parse-tree/jit-ir.cc
@@ -214,17 +214,17 @@ jit_instruction::parent_llvm (void) cons
   return mparent->to_llvm ();
 }
 
 std::ostream&
 jit_instruction::short_print (std::ostream& os) const
 {
   if (type ())
     jit_print (os, type ()) << ": ";
-  return os << "#" << mid;
+  return os << '#' << mid;
 }
 
 void
 jit_instruction::do_construct_ssa (size_t start, size_t end)
 {
   for (size_t i = start; i < end; ++i)
     {
       jit_value *arg = argument (i);
@@ -397,38 +397,38 @@ jit_block::to_llvm (void) const
 std::ostream&
 jit_block::print_dom (std::ostream& os) const
 {
   short_print (os);
   os << ":\n";
   os << "  mid: " << mid << std::endl;
   os << "  predecessors: ";
   for (jit_use *use = first_use (); use; use = use->next ())
-    os << *use->user_parent () << " ";
+    os << *use->user_parent () << ' ';
   os << std::endl;
 
   os << "  successors: ";
   for (size_t i = 0; i < successor_count (); ++i)
-    os << *successor (i) << " ";
+    os << *successor (i) << ' ';
   os << std::endl;
 
   os << "  idom: ";
   if (idom)
     os << *idom;
   else
     os << "NULL";
   os << std::endl;
   os << "  df: ";
   for (df_iterator iter = df_begin (); iter != df_end (); ++iter)
-    os << **iter << " ";
+    os << **iter << ' ';
   os << std::endl;
 
   os << "  dom_succ: ";
   for (size_t i = 0; i < dom_succ.size (); ++i)
-    os << *dom_succ[i] << " ";
+    os << *dom_succ[i] << ' ';
 
   return os << std::endl;
 }
 
 void
 jit_block::compute_df (size_t avisit_count)
 {
   if (visited (avisit_count))
@@ -827,17 +827,17 @@ jit_magic_end::infer (void)
   return false;
 }
 
 std::ostream&
 jit_magic_end::print (std::ostream& os, size_t indent) const
 {
   context ctx = resolve_context ();
   short_print (print_indent (os, indent)) << " (" << *ctx.value << ", ";
-  return os << *ctx.index << ", " << *ctx.count << ")";
+  return os << *ctx.index << ", " << *ctx.count << ')';
 }
 
 const jit_function&
 jit_magic_end::overload () const
 {
   const context& ctx = resolve_context ();
   return jit_typeinfo::end (ctx.value, ctx.index, ctx.count);
 }
diff --git a/libinterp/parse-tree/jit-ir.h b/libinterp/parse-tree/jit-ir.h
--- a/libinterp/parse-tree/jit-ir.h
+++ b/libinterp/parse-tree/jit-ir.h
@@ -269,17 +269,17 @@ public:
   {
     llvm_value = compiled;
   }
 
 protected:
   std::ostream& print_indent (std::ostream& os, size_t indent = 0) const
   {
     for (size_t i = 0; i < indent * 8; ++i)
-      os << " ";
+      os << ' ';
     return os;
   }
 
   llvm::Value *llvm_value;
 private:
   jit_type *ty;
   jit_instruction *mlast_use;
   bool min_worklist;
@@ -531,20 +531,20 @@ public:
 
   PASS_T value (void) const { return mvalue; }
 
   virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
   {
     print_indent (os, indent);
     jit_print (os, type ()) << ": ";
     if (QUOTE)
-      os << R"(")";
+      os << '"';
     os << mvalue;
     if (QUOTE)
-      os << R"(")";
+      os << '"';
     return os;
   }
 
   JIT_VALUE_ACCEPT;
 private:
   T mvalue;
 };
 
@@ -718,17 +718,17 @@ public:
   std::ostream& print_dom (std::ostream& os) const;
 
   virtual std::ostream& short_print (std::ostream& os) const
   {
     os << mname;
     if (mid != NO_ID)
       os << mid;
     else
-      os << "!";
+      os << '!';
     return os;
   }
 
   llvm::BasicBlock * to_llvm (void) const;
 
   std::list<jit_block *>::iterator location (void) const
   { return mlocation; }
 
@@ -896,17 +896,17 @@ public:
   }
 
   virtual std::ostream& short_print (std::ostream& os) const
   {
     if (type ())
       jit_print (os, type ()) << ": ";
 
     dest ()->short_print (os);
-    return os << "#" << id ();
+    return os << '#' << id ();
   }
 private:
   jit_variable *mdest;
 };
 
 class
 jit_assign : public jit_assign_base
 {
@@ -1197,17 +1197,17 @@ public:
     os << "call " << moperation.name () << " (";
 
     for (size_t i = 0; i < argument_count (); ++i)
       {
         print_argument (os, i);
         if (i + 1 < argument_count ())
           os << ", ";
       }
-    return os << ")";
+    return os << ')';
   }
 
   virtual bool infer (void);
 
   JIT_VALUE_ACCEPT;
 private:
   const jit_operation& moperation;
 };
@@ -1289,17 +1289,17 @@ public:
   const jit_function& overload () const;
 
   virtual std::ostream& print (std::ostream& os, size_t indent = 0) const;
 
   context resolve_context (void) const;
 
   virtual std::ostream& short_print (std::ostream& os) const
   {
-    return os << "magic_end" << "#" << id ();
+    return os << "magic_end" << '#' << id ();
   }
 
   JIT_VALUE_ACCEPT;
 private:
   std::vector<context> contexts;
 };
 
 class
@@ -1404,17 +1404,17 @@ public:
     return res ? res->type () : nullptr;
   }
 
   virtual std::ostream& print (std::ostream& os, size_t indent = 0) const
   {
     print_indent (os, indent) << "return";
 
     if (result ())
-      os << " " << *result ();
+      os << ' ' << *result ();
 
     return os;
   }
 
   JIT_VALUE_ACCEPT;
 };
 
 class
diff --git a/libinterp/parse-tree/jit-typeinfo.cc b/libinterp/parse-tree/jit-typeinfo.cc
--- a/libinterp/parse-tree/jit-typeinfo.cc
+++ b/libinterp/parse-tree/jit-typeinfo.cc
@@ -483,27 +483,27 @@ jit_range::all_elements_are_ints () cons
   Range r (*this);
   return r.all_elements_are_ints ();
 }
 
 std::ostream&
 operator<< (std::ostream& os, const jit_range& rng)
 {
   return os << "Range[" << rng.base << ", " << rng.limit << ", " << rng.inc
-         << ", " << rng.nelem << "]";
+         << ", " << rng.nelem << ']';
 }
 
 // -------------------- jit_matrix --------------------
 
 std::ostream&
 operator<< (std::ostream& os, const jit_matrix& mat)
 {
   return os << "Matrix[" << mat.ref_count << ", " << mat.slice_data << ", "
          << mat.slice_len << ", " << mat.dimensions << ", "
-         << mat.array << "]";
+         << mat.array << ']';
 }
 
 // -------------------- jit_type --------------------
 jit_type::jit_type (const std::string& aname, jit_type *aparent,
                     llvm::Type *allvm_type, bool askip_paren, int aid) :
   mname (aname), mparent (aparent), llvm_type (allvm_type), mid (aid),
   mdepth (aparent ? aparent->mdepth + 1 : 0), mskip_paren (askip_paren)
 {
@@ -1896,17 +1896,17 @@ jit_typeinfo::add_print (jit_type *ty, v
 
 // FIXME: cp between add_binary_op, add_binary_icmp, and add_binary_fcmp
 void
 jit_typeinfo::add_binary_op (jit_type *ty, int op, int llvm_op)
 {
   std::stringstream fname;
   octave_value::binary_op ov_op = static_cast<octave_value::binary_op>(op);
   fname << "octave_jit_" << octave_value::binary_op_as_string (ov_op)
-        << "_" << ty->name ();
+        << '_' << ty->name ();
 
   jit_function fn = create_internal (fname.str (), ty, ty, ty);
   llvm::BasicBlock *block = fn.new_block ();
   builder.SetInsertPoint (block);
   llvm::Instruction::BinaryOps temp
     = static_cast<llvm::Instruction::BinaryOps>(llvm_op);
 
   llvm::Value *ret = builder.CreateBinOp (temp, fn.argument (builder, 0),
@@ -1916,17 +1916,17 @@ jit_typeinfo::add_binary_op (jit_type *t
 }
 
 void
 jit_typeinfo::add_binary_icmp (jit_type *ty, int op, int llvm_op)
 {
   std::stringstream fname;
   octave_value::binary_op ov_op = static_cast<octave_value::binary_op>(op);
   fname << "octave_jit" << octave_value::binary_op_as_string (ov_op)
-        << "_" << ty->name ();
+        << '_' << ty->name ();
 
   jit_function fn = create_internal (fname.str (), boolean, ty, ty);
   llvm::BasicBlock *block = fn.new_block ();
   builder.SetInsertPoint (block);
   llvm::CmpInst::Predicate temp
     = static_cast<llvm::CmpInst::Predicate>(llvm_op);
   llvm::Value *ret = builder.CreateICmp (temp, fn.argument (builder, 0),
                                          fn.argument (builder, 1));
@@ -1935,17 +1935,17 @@ jit_typeinfo::add_binary_icmp (jit_type 
 }
 
 void
 jit_typeinfo::add_binary_fcmp (jit_type *ty, int op, int llvm_op)
 {
   std::stringstream fname;
   octave_value::binary_op ov_op = static_cast<octave_value::binary_op>(op);
   fname << "octave_jit" << octave_value::binary_op_as_string (ov_op)
-        << "_" << ty->name ();
+        << '_' << ty->name ();
 
   jit_function fn = create_internal (fname.str (), boolean, ty, ty);
   llvm::BasicBlock *block = fn.new_block ();
   builder.SetInsertPoint (block);
   llvm::CmpInst::Predicate temp
     = static_cast<llvm::CmpInst::Predicate>(llvm_op);
   llvm::Value *ret = builder.CreateFCmp (temp, fn.argument (builder, 0),
                                          fn.argument (builder, 1));
diff --git a/libinterp/parse-tree/pt-funcall.cc b/libinterp/parse-tree/pt-funcall.cc
--- a/libinterp/parse-tree/pt-funcall.cc
+++ b/libinterp/parse-tree/pt-funcall.cc
@@ -58,17 +58,17 @@ namespace octave
         for (octave_idx_type i = 0; i < n; i++)
           {
             args(i).print_raw (os, pr_as_read_syntax);
 
             if (i < n - 1)
               os << ", ";
           }
 
-        os << ")";
+        os << ')';
       }
   }
 
   tree_funcall *
   tree_funcall::dup (symbol_table::scope&) const
   {
     tree_funcall *new_fc = new tree_funcall (fcn, args, line (), column ());
 
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -85,26 +85,26 @@ namespace octave
     if (lst && lst->has_magic_tilde ())
       error ("invalid use of empty argument (~) in index expression");
   }
 
   void
   tree_index_expression::append (const std::string& n)
   {
     args.push_back (static_cast<tree_argument_list *> (nullptr));
-    type.append (".");
+    type += '.';
     arg_nm.push_back (n);
     dyn_field.push_back (static_cast<tree_expression *> (nullptr));
   }
 
   void
   tree_index_expression::append (tree_expression *df)
   {
     args.push_back (static_cast<tree_argument_list *> (nullptr));
-    type.append (".");
+    type += '.';
     arg_nm.push_back ("");
     dyn_field.push_back (df);
   }
 
   tree_index_expression::~tree_index_expression (void)
   {
     delete expr;
 
diff --git a/libinterp/parse-tree/pt-pr-code.cc b/libinterp/parse-tree/pt-pr-code.cc
--- a/libinterp/parse-tree/pt-pr-code.cc
+++ b/libinterp/parse-tree/pt-pr-code.cc
@@ -83,17 +83,17 @@ namespace octave
 
     print_parens (expr, "(");
 
     tree_expression *op1 = expr.lhs ();
 
     if (op1)
       op1->accept (*this);
 
-    os << " " << expr.oper () << " ";
+    os << ' ' << expr.oper () << ' ';
 
     tree_expression *op2 = expr.rhs ();
 
     if (op2)
       op2->accept (*this);
 
     print_parens (expr, ")");
   }
@@ -119,25 +119,25 @@ namespace octave
       op1->accept (*this);
 
     // Stupid syntax.
 
     tree_expression *op3 = expr.increment ();
 
     if (op3)
       {
-        os << ":";
+        os << ':';
         op3->accept (*this);
       }
 
     tree_expression *op2 = expr.limit ();
 
     if (op2)
       {
-        os << ":";
+        os << ':';
         op2->accept (*this);
       }
 
     print_parens (expr, ")");
   }
 
   void
   tree_print_code::visit_continue_command (tree_continue_command&)
@@ -147,17 +147,17 @@ namespace octave
     os << "continue";
   }
 
   void
   tree_print_code::visit_decl_command (tree_decl_command& cmd)
   {
     indent ();
 
-    os << cmd.name () << " ";
+    os << cmd.name () << ' ';
 
     tree_decl_init_list *init_list = cmd.initializer_list ();
 
     if (init_list)
       init_list->accept (*this);
   }
 
   void
@@ -206,33 +206,33 @@ namespace octave
 
     os << (cmd.in_parallel () ? "parfor " : "for ");
 
     tree_expression *lhs = cmd.left_hand_side ();
 
     tree_expression *maxproc = cmd.maxproc_expr ();
 
     if (maxproc)
-      os << "(";
+      os << '(';
 
     if (lhs)
       lhs->accept (*this);
 
     os << " = ";
 
     tree_expression *expr = cmd.control_expr ();
 
     if (expr)
       expr->accept (*this);
 
     if (maxproc)
       {
         os << ", ";
         maxproc->accept (*this);
-        os << ")";
+        os << ')';
       }
 
     newline ();
 
     tree_statement_list *list = cmd.body ();
 
     if (list)
       {
@@ -345,71 +345,71 @@ namespace octave
     if (ret_list)
       {
         bool takes_var_return = fcn.takes_var_return ();
 
         int len = ret_list->length ();
 
         if (len > 1 || takes_var_return)
           {
-            os << "[";
+            os << '[';
             nesting.push ('[');
           }
 
         ret_list->accept (*this);
 
         if (takes_var_return)
           {
             if (len > 0)
               os << ", ";
 
             os << "varargout";
           }
 
         if (len > 1 || takes_var_return)
           {
             nesting.pop ();
-            os << "]";
+            os << ']';
           }
 
         os << " = ";
       }
 
     std::string fcn_name = fcn.name ();
 
-    os << (fcn_name.empty () ? std::string ("(empty)") : fcn_name) << " ";
+    os << (fcn_name.empty () ? std::string ("(empty)") : fcn_name) << ' ';
 
     tree_parameter_list *param_list = fcn.parameter_list ();
 
     if (param_list)
       {
         bool takes_varargs = fcn.takes_varargs ();
 
         int len = param_list->length ();
 
         if (len > 0 || takes_varargs)
           {
-            os << "(";
+            os << '(';
             nesting.push ('(');
           }
 
         param_list->accept (*this);
 
         if (takes_varargs)
           {
             if (len > 0)
               os << ", ";
 
             os << "varargin";
           }
 
         if (len > 0 || takes_varargs)
           {
             nesting.pop ();
-            os << ")";
+            os << ')';
             newline ();
           }
       }
     else
       {
         os << "()";
         newline ();
       }
@@ -548,55 +548,55 @@ namespace octave
     for (int i = 0; i < n; i++)
       {
         switch (type_tags[i])
           {
           case '(':
             {
               char nc = nesting.top ();
               if ((nc == '[' || nc == '{') && expr.paren_count () == 0)
-                os << "(";
+                os << '(';
               else
                 os << " (";
               nesting.push ('(');
 
               tree_argument_list *l = *p_arg_lists;
               if (l)
                 l->accept (*this);
 
               nesting.pop ();
-              os << ")";
+              os << ')';
             }
             break;
 
           case '{':
             {
               char nc = nesting.top ();
               if ((nc == '[' || nc == '{') && expr.paren_count () == 0)
-                os << "{";
+                os << '{';
               else
                 os << " {";
               // We only care about whitespace inside [] and {} when we
               // are defining matrix and cell objects, not when indexing.
               nesting.push ('(');
 
               tree_argument_list *l = *p_arg_lists;
               if (l)
                 l->accept (*this);
 
               nesting.pop ();
-              os << "}";
+              os << '}';
             }
             break;
 
           case '.':
             {
               string_vector nm = *p_arg_names;
               assert (nm.numel () == 1);
-              os << "." << nm(0);
+              os << '.' << nm(0);
             }
             break;
 
           default:
             panic_impossible ();
           }
 
         p_arg_lists++;
@@ -608,17 +608,17 @@ namespace octave
 
   void
   tree_print_code::visit_matrix (tree_matrix& lst)
   {
     indent ();
 
     print_parens (lst, "(");
 
-    os << "[";
+    os << '[';
     nesting.push ('[');
 
     tree_matrix::iterator p = lst.begin ();
 
     while (p != lst.end ())
       {
         tree_argument_list *elt = *p++;
 
@@ -627,29 +627,29 @@ namespace octave
             elt->accept (*this);
 
             if (p != lst.end ())
               os << "; ";
           }
       }
 
     nesting.pop ();
-    os << "]";
+    os << ']';
 
     print_parens (lst, ")");
   }
 
   void
   tree_print_code::visit_cell (tree_cell& lst)
   {
     indent ();
 
     print_parens (lst, "(");
 
-    os << "{";
+    os << '{';
     nesting.push ('{');
 
     tree_cell::iterator p = lst.begin ();
 
     while (p != lst.end ())
       {
         tree_argument_list *elt = *p++;
 
@@ -658,17 +658,17 @@ namespace octave
             elt->accept (*this);
 
             if (p != lst.end ())
               os << "; ";
           }
       }
 
     nesting.pop ();
-    os << "}";
+    os << '}';
 
     print_parens (lst, ")");
   }
 
   void
   tree_print_code::visit_multi_assignment (tree_multi_assignment& expr)
   {
     indent ();
@@ -678,30 +678,30 @@ namespace octave
     tree_argument_list *lhs = expr.left_hand_side ();
 
     if (lhs)
       {
         int len = lhs->length ();
 
         if (len > 1)
           {
-            os << "[";
+            os << '[';
             nesting.push ('[');
           }
 
         lhs->accept (*this);
 
         if (len > 1)
           {
             nesting.pop ();
-            os << "]";
+            os << ']';
           }
       }
 
-    os << " " << expr.oper () << " ";
+    os << ' ' << expr.oper () << ' ';
 
     tree_expression *rhs = expr.right_hand_side ();
 
     if (rhs)
       rhs->accept (*this);
 
     print_parens (expr, ")");
   }
@@ -840,17 +840,17 @@ namespace octave
 
     print_parens (expr, "(");
 
     tree_expression *lhs = expr.left_hand_side ();
 
     if (lhs)
       lhs->accept (*this);
 
-    os << " " << expr.oper () << " ";
+    os << ' ' << expr.oper () << ' ';
 
     tree_expression *rhs = expr.right_hand_side ();
 
     if (rhs)
       rhs->accept (*this);
 
     print_parens (expr, ")");
   }
@@ -873,17 +873,17 @@ namespace octave
         tree_expression *expr = stmt.expression ();
 
         if (expr)
           {
             expr->accept (*this);
 
             if (! stmt.print_result ())
               {
-                os << ";";
+                os << ';';
                 newline (" ");
               }
             else
               newline ();
           }
       }
   }
 
@@ -1004,17 +1004,17 @@ namespace octave
     print_indented_comment (cmd.middle_comment ());
 
     indent ();
 
     os << "catch";
 
     if (expr_id)
       {
-        os << " ";
+        os << ' ';
         expr_id->accept (*this);
       }
 
     newline ();
 
     tree_statement_list *catch_code = cmd.cleanup ();
 
     if (catch_code)
@@ -1259,17 +1259,17 @@ namespace octave
               {
                 printed_something = true;
 
                 indent ();
 
                 os << "##";
 
                 if (! (isspace (c) || c == '!'))
-                  os << " ";
+                  os << ' ';
               }
 
             os << static_cast<char> (c);
 
             prev_char_was_newline = false;
           }
       }
 
diff --git a/libinterp/parse-tree/pt.h b/libinterp/parse-tree/pt.h
--- a/libinterp/parse-tree/pt.h
+++ b/libinterp/parse-tree/pt.h
@@ -79,17 +79,17 @@ namespace octave
     bool meets_bp_condition (void) const;
 
     bool is_breakpoint (bool check_active = false) const
     { return bp && (! check_active || meets_bp_condition ()); }
 
     // breakpoint condition, or "0" (i.e., "false") if no breakpoint.
     // To distinguish "0" from a disabled breakpoint, test "is_breakpoint" too.
     const std::string bp_cond (void) const
-    { return bp ? *bp : std::string("0"); }
+    { return bp ? *bp : "0"; }
 
     std::string str_print_code (void);
 
     virtual void accept (tree_walker& tw) = 0;
 
   private:
 
     // The input line and column where we found the text that was
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -2777,17 +2777,17 @@ operator << (std::ostream& os, const Arr
 {
   dim_vector a_dims = a.dims ();
 
   int n_dims = a_dims.ndims ();
 
   os << n_dims << "-dimensional array";
 
   if (n_dims)
-    os << " (" << a_dims.str () << ")";
+    os << " (" << a_dims.str () << ')';
 
   os <<"\n\n";
 
   if (n_dims)
     {
       os << "data:";
 
       Array<octave_idx_type> ra_idx (dim_vector (n_dims, 1), 0);
@@ -2810,57 +2810,57 @@ operator << (std::ostream& os, const Arr
               cols = a_dims(1);
 
               for (octave_idx_type j = 0; j < rows; j++)
                 {
                   ra_idx(0) = j;
                   for (octave_idx_type k = 0; k < cols; k++)
                     {
                       ra_idx(1) = k;
-                      os << " " << a.elem (ra_idx);
+                      os << ' ' << a.elem (ra_idx);
                     }
                   os << "\n";
                 }
               break;
 
             default:
               rows = a_dims(0);
 
               for (octave_idx_type k = 0; k < rows; k++)
                 {
                   ra_idx(0) = k;
-                  os << " " << a.elem (ra_idx);
+                  os << ' ' << a.elem (ra_idx);
                 }
               break;
             }
 
           os << "\n";
         }
       else
         {
           octave_idx_type rows = a_dims(0);
           octave_idx_type cols = a_dims(1);
 
           for (int i = 0; i < m; i++)
             {
               os << "\n(:,:,";
 
               for (int j = 2; j < n_dims - 1; j++)
-                os << ra_idx(j) + 1 << ",";
+                os << ra_idx(j) + 1 << ',';
 
               os << ra_idx(n_dims - 1) + 1 << ") = \n";
 
               for (octave_idx_type j = 0; j < rows; j++)
                 {
                   ra_idx(0) = j;
 
                   for (octave_idx_type k = 0; k < cols; k++)
                     {
                       ra_idx(1) = k;
-                      os << " " << a.elem (ra_idx);
+                      os << ' ' << a.elem (ra_idx);
                     }
 
                   os << "\n";
                 }
 
               os << "\n";
 
               if (i != m - 1)
diff --git a/liboctave/array/CDiagMatrix.cc b/liboctave/array/CDiagMatrix.cc
--- a/liboctave/array/CDiagMatrix.cc
+++ b/liboctave/array/CDiagMatrix.cc
@@ -497,16 +497,16 @@ operator << (std::ostream& os, const Com
 {
   Complex ZERO (0.0);
 //  int field_width = os.precision () + 7;
   for (octave_idx_type i = 0; i < a.rows (); i++)
     {
       for (octave_idx_type j = 0; j < a.cols (); j++)
         {
           if (i == j)
-            os << " " /* setw (field_width) */ << a.elem (i, i);
+            os << ' ' /* setw (field_width) */ << a.elem (i, i);
           else
-            os << " " /* setw (field_width) */ << ZERO;
+            os << ' ' /* setw (field_width) */ << ZERO;
         }
       os << "\n";
     }
   return os;
 }
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -3327,17 +3327,17 @@ ComplexMatrix::column_max (Array<octave_
 
 std::ostream&
 operator << (std::ostream& os, const ComplexMatrix& a)
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     {
       for (octave_idx_type j = 0; j < a.cols (); j++)
         {
-          os << " ";
+          os << ' ';
           octave_write_complex (os, a.elem (i, j));
         }
       os << "\n";
     }
   return os;
 }
 
 std::istream&
diff --git a/liboctave/array/CNDArray.cc b/liboctave/array/CNDArray.cc
--- a/liboctave/array/CNDArray.cc
+++ b/liboctave/array/CNDArray.cc
@@ -830,17 +830,17 @@ ComplexNDArray::diag (octave_idx_type m,
 // This contains no information on the array structure !!!
 std::ostream&
 operator << (std::ostream& os, const ComplexNDArray& a)
 {
   octave_idx_type nel = a.numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      os << " ";
+      os << ' ';
       octave_write_complex (os, a.elem (i));
       os << "\n";
     }
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, ComplexNDArray& a)
diff --git a/liboctave/array/CRowVector.cc b/liboctave/array/CRowVector.cc
--- a/liboctave/array/CRowVector.cc
+++ b/liboctave/array/CRowVector.cc
@@ -360,17 +360,17 @@ ComplexRowVector::max (void) const
 
 // i/o
 
 std::ostream&
 operator << (std::ostream& os, const ComplexRowVector& a)
 {
 //  int field_width = os.precision () + 7;
   for (octave_idx_type i = 0; i < a.numel (); i++)
-    os << " " /* setw (field_width) */ << a.elem (i);
+    os << ' ' /* setw (field_width) */ << a.elem (i);
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, ComplexRowVector& a)
 {
   octave_idx_type len = a.numel ();
 
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -5780,18 +5780,18 @@ SparseComplexMatrix::fsolve (MatrixType&
                   for (octave_idx_type i = 0; i < b.rows (); i++)
                     retval.xelem (i,j) = static_cast<Complex *>(X->x)[jr + i];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_dense) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
-              static char tmp[] = " ";
-              CHOLMOD_NAME(print_common) (tmp, cm);
+              static char blank_name[] = " ";
+              CHOLMOD_NAME(print_common) (blank_name, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
 #else
           (*current_liboctave_warning_with_id_handler)
             ("Octave:missing-dependency",
              "support for CHOLMOD was unavailable or disabled "
              "when liboctave was built");
 
@@ -6048,18 +6048,18 @@ SparseComplexMatrix::fsolve (MatrixType&
                   retval.xridx (j) = static_cast<octave_idx_type *>(X->i)[j];
                   retval.xdata (j) = static_cast<Complex *>(X->x)[j];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_sparse) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
-              static char tmp[] = " ";
-              CHOLMOD_NAME(print_common) (tmp, cm);
+              static char blank_name[] = " ";
+              CHOLMOD_NAME(print_common) (blank_name, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
 #else
           (*current_liboctave_warning_with_id_handler)
             ("Octave:missing-dependency",
              "support for CHOLMOD was unavailable or disabled "
              "when liboctave was built");
 
@@ -6333,18 +6333,18 @@ SparseComplexMatrix::fsolve (MatrixType&
                   for (octave_idx_type i = 0; i < b.rows (); i++)
                     retval.xelem (i,j) = static_cast<Complex *>(X->x)[jr + i];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_dense) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
-              static char tmp[] = " ";
-              CHOLMOD_NAME(print_common) (tmp, cm);
+              static char blank_name[] = " ";
+              CHOLMOD_NAME(print_common) (blank_name, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
 #else
           (*current_liboctave_warning_with_id_handler)
             ("Octave:missing-dependency",
              "support for CHOLMOD was unavailable or disabled "
              "when liboctave was built");
 
@@ -6580,18 +6580,18 @@ SparseComplexMatrix::fsolve (MatrixType&
                   retval.xridx (j) = static_cast<octave_idx_type *>(X->i)[j];
                   retval.xdata (j) = static_cast<Complex *>(X->x)[j];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_sparse) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
-              static char tmp[] = " ";
-              CHOLMOD_NAME(print_common) (tmp, cm);
+              static char blank_name[] = " ";
+              CHOLMOD_NAME(print_common) (blank_name, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
 #else
           (*current_liboctave_warning_with_id_handler)
             ("Octave:missing-dependency",
              "support for CHOLMOD was unavailable or disabled "
              "when liboctave was built");
 
@@ -7467,17 +7467,17 @@ operator << (std::ostream& os, const Spa
 
   // add one to the printed indices to go from
   //  zero-based to one-based arrays
   for (octave_idx_type j = 0; j < nc; j++)
     {
       octave_quit ();
       for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
         {
-          os << a.ridx (i) + 1 << " "  << j + 1 << " ";
+          os << a.ridx (i) + 1 << ' '  << j + 1 << ' ';
           octave_write_complex (os, a.data (i));
           os << "\n";
         }
     }
 
   return os;
 }
 
diff --git a/liboctave/array/Range.cc b/liboctave/array/Range.cc
--- a/liboctave/array/Range.cc
+++ b/liboctave/array/Range.cc
@@ -336,19 +336,19 @@ operator << (std::ostream& os, const Ran
 {
   double b = a.base ();
   double increment = a.inc ();
   octave_idx_type num_elem = a.numel ();
 
   if (num_elem > 1)
     {
       // First element must be the base *exactly* (-0).
-      os << b << " ";
+      os << b << ' ';
       for (octave_idx_type i = 1; i < num_elem-1; i++)
-        os << b + i * increment << " ";
+        os << b + i * increment << ' ';
     }
 
   // Print out exactly the last element, rather than a calculated last element.
   os << a.rng_limit << "\n";
 
   return os;
 }
 
diff --git a/liboctave/array/boolSparse.cc b/liboctave/array/boolSparse.cc
--- a/liboctave/array/boolSparse.cc
+++ b/liboctave/array/boolSparse.cc
@@ -264,17 +264,17 @@ operator << (std::ostream& os, const Spa
   octave_idx_type nc = a.cols ();
 
   // add one to the printed indices to go from
   //  zero-based to one-based arrays
   for (octave_idx_type j = 0; j < nc; j++)
     {
       octave_quit ();
       for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
-        os << a.ridx (i) + 1 << " "  << j + 1 << " " << a.data (i) << "\n";
+        os << a.ridx (i) + 1 << ' '  << j + 1 << ' ' << a.data (i) << "\n";
     }
 
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, SparseBoolMatrix& a)
 {
diff --git a/liboctave/array/dDiagMatrix.cc b/liboctave/array/dDiagMatrix.cc
--- a/liboctave/array/dDiagMatrix.cc
+++ b/liboctave/array/dDiagMatrix.cc
@@ -331,16 +331,16 @@ operator << (std::ostream& os, const Dia
 {
 //  int field_width = os.precision () + 7;
 
   for (octave_idx_type i = 0; i < a.rows (); i++)
     {
       for (octave_idx_type j = 0; j < a.cols (); j++)
         {
           if (i == j)
-            os << " " /* setw (field_width) */ << a.elem (i, i);
+            os << ' ' /* setw (field_width) */ << a.elem (i, i);
           else
-            os << " " /* setw (field_width) */ << 0.0;
+            os << ' ' /* setw (field_width) */ << 0.0;
         }
       os << "\n";
     }
   return os;
 }
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -2794,17 +2794,17 @@ Matrix::column_max (Array<octave_idx_typ
 
 std::ostream&
 operator << (std::ostream& os, const Matrix& a)
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     {
       for (octave_idx_type j = 0; j < a.cols (); j++)
         {
-          os << " ";
+          os << ' ';
           octave_write_double (os, a.elem (i, j));
         }
       os << "\n";
     }
   return os;
 }
 
 std::istream&
diff --git a/liboctave/array/dNDArray.cc b/liboctave/array/dNDArray.cc
--- a/liboctave/array/dNDArray.cc
+++ b/liboctave/array/dNDArray.cc
@@ -855,17 +855,17 @@ NDArray::diag (octave_idx_type m, octave
 // This contains no information on the array structure !!!
 std::ostream&
 operator << (std::ostream& os, const NDArray& a)
 {
   octave_idx_type nel = a.numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      os << " ";
+      os << ' ';
       octave_write_double (os, a.elem (i));
       os << "\n";
     }
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, NDArray& a)
diff --git a/liboctave/array/dRowVector.cc b/liboctave/array/dRowVector.cc
--- a/liboctave/array/dRowVector.cc
+++ b/liboctave/array/dRowVector.cc
@@ -232,17 +232,17 @@ RowVector::max (void) const
 }
 
 std::ostream&
 operator << (std::ostream& os, const RowVector& a)
 {
 //  int field_width = os.precision () + 7;
 
   for (octave_idx_type i = 0; i < a.numel (); i++)
-    os << " " /* setw (field_width) */ << a.elem (i);
+    os << ' ' /* setw (field_width) */ << a.elem (i);
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, RowVector& a)
 {
   octave_idx_type len = a.numel ();
 
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -5832,18 +5832,18 @@ SparseMatrix::fsolve (MatrixType& mattyp
                   for (octave_idx_type i = 0; i < b.rows (); i++)
                     retval.xelem (i,j) = static_cast<double *>(X->x)[jr + i];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_dense) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
-              static char tmp[] = " ";
-              CHOLMOD_NAME(print_common) (tmp, cm);
+              static char blank_name[] = " ";
+              CHOLMOD_NAME(print_common) (blank_name, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
 #else
           (*current_liboctave_warning_with_id_handler)
             ("Octave:missing-dependency",
              "support for CHOLMOD was unavailable or disabled "
              "when liboctave was built");
 
@@ -6071,18 +6071,18 @@ SparseMatrix::fsolve (MatrixType& mattyp
                   retval.xridx (j) = static_cast<octave_idx_type *>(X->i)[j];
                   retval.xdata (j) = static_cast<double *>(X->x)[j];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_sparse) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
-              static char tmp[] = " ";
-              CHOLMOD_NAME(print_common) (tmp, cm);
+              static char blank_name[] = " ";
+              CHOLMOD_NAME(print_common) (blank_name, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
 #else
           (*current_liboctave_warning_with_id_handler)
             ("Octave:missing-dependency",
              "support for CHOLMOD was unavailable or disabled "
              "when liboctave was built");
 
@@ -6327,18 +6327,18 @@ SparseMatrix::fsolve (MatrixType& mattyp
                   for (octave_idx_type i = 0; i < b.rows (); i++)
                     retval.xelem (i,j) = static_cast<Complex *>(X->x)[jr + i];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_dense) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
-              static char tmp[] = " ";
-              CHOLMOD_NAME(print_common) (tmp, cm);
+              static char blank_name[] = " ";
+              CHOLMOD_NAME(print_common) (blank_name, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
 #else
           (*current_liboctave_warning_with_id_handler)
             ("Octave:missing-dependency",
              "support for CHOLMOD was unavailable or disabled "
              "when liboctave was built");
 
@@ -6588,18 +6588,18 @@ SparseMatrix::fsolve (MatrixType& mattyp
                   retval.xridx (j) = static_cast<octave_idx_type *>(X->i)[j];
                   retval.xdata (j) = static_cast<Complex *>(X->x)[j];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_sparse) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
               CHOLMOD_NAME(finish) (cm);
-              static char tmp[] = " ";
-              CHOLMOD_NAME(print_common) (tmp, cm);
+              static char blank_name[] = " ";
+              CHOLMOD_NAME(print_common) (blank_name, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
             }
 #else
           (*current_liboctave_warning_with_id_handler)
             ("Octave:missing-dependency",
              "support for CHOLMOD was unavailable or disabled "
              "when liboctave was built");
 
@@ -7482,17 +7482,17 @@ operator << (std::ostream& os, const Spa
 
   // add one to the printed indices to go from
   //  zero-based to one-based arrays
   for (octave_idx_type j = 0; j < nc; j++)
     {
       octave_quit ();
       for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
         {
-          os << a.ridx (i) + 1 << " "  << j + 1 << " ";
+          os << a.ridx (i) + 1 << ' '  << j + 1 << ' ';
           octave_write_double (os, a.data (i));
           os << "\n";
         }
     }
 
   return os;
 }
 
diff --git a/liboctave/array/fCDiagMatrix.cc b/liboctave/array/fCDiagMatrix.cc
--- a/liboctave/array/fCDiagMatrix.cc
+++ b/liboctave/array/fCDiagMatrix.cc
@@ -501,16 +501,16 @@ operator << (std::ostream& os, const Flo
 {
   FloatComplex ZERO (0.0);
 //  int field_width = os.precision () + 7;
   for (octave_idx_type i = 0; i < a.rows (); i++)
     {
       for (octave_idx_type j = 0; j < a.cols (); j++)
         {
           if (i == j)
-            os << " " /* setw (field_width) */ << a.elem (i, i);
+            os << ' ' /* setw (field_width) */ << a.elem (i, i);
           else
-            os << " " /* setw (field_width) */ << ZERO;
+            os << ' ' /* setw (field_width) */ << ZERO;
         }
       os << "\n";
     }
   return os;
 }
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -3354,17 +3354,17 @@ FloatComplexMatrix::column_max (Array<oc
 
 std::ostream&
 operator << (std::ostream& os, const FloatComplexMatrix& a)
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     {
       for (octave_idx_type j = 0; j < a.cols (); j++)
         {
-          os << " ";
+          os << ' ';
           octave_write_complex (os, a.elem (i, j));
         }
       os << "\n";
     }
   return os;
 }
 
 std::istream&
diff --git a/liboctave/array/fCNDArray.cc b/liboctave/array/fCNDArray.cc
--- a/liboctave/array/fCNDArray.cc
+++ b/liboctave/array/fCNDArray.cc
@@ -839,17 +839,17 @@ FloatComplexNDArray::diag (octave_idx_ty
 // This contains no information on the array structure !!!
 std::ostream&
 operator << (std::ostream& os, const FloatComplexNDArray& a)
 {
   octave_idx_type nel = a.numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      os << " ";
+      os << ' ';
       octave_write_complex (os, a.elem (i));
       os << "\n";
     }
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, FloatComplexNDArray& a)
diff --git a/liboctave/array/fCRowVector.cc b/liboctave/array/fCRowVector.cc
--- a/liboctave/array/fCRowVector.cc
+++ b/liboctave/array/fCRowVector.cc
@@ -361,17 +361,17 @@ FloatComplexRowVector::max (void) const
 
 // i/o
 
 std::ostream&
 operator << (std::ostream& os, const FloatComplexRowVector& a)
 {
 //  int field_width = os.precision () + 7;
   for (octave_idx_type i = 0; i < a.numel (); i++)
-    os << " " /* setw (field_width) */ << a.elem (i);
+    os << ' ' /* setw (field_width) */ << a.elem (i);
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, FloatComplexRowVector& a)
 {
   octave_idx_type len = a.numel ();
 
diff --git a/liboctave/array/fDiagMatrix.cc b/liboctave/array/fDiagMatrix.cc
--- a/liboctave/array/fDiagMatrix.cc
+++ b/liboctave/array/fDiagMatrix.cc
@@ -331,16 +331,16 @@ operator << (std::ostream& os, const Flo
 {
 //  int field_width = os.precision () + 7;
 
   for (octave_idx_type i = 0; i < a.rows (); i++)
     {
       for (octave_idx_type j = 0; j < a.cols (); j++)
         {
           if (i == j)
-            os << " " /* setw (field_width) */ << a.elem (i, i);
+            os << ' ' /* setw (field_width) */ << a.elem (i, i);
           else
-            os << " " /* setw (field_width) */ << 0.0;
+            os << ' ' /* setw (field_width) */ << 0.0;
         }
       os << "\n";
     }
   return os;
 }
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -2801,17 +2801,17 @@ FloatMatrix::column_max (Array<octave_id
 
 std::ostream&
 operator << (std::ostream& os, const FloatMatrix& a)
 {
   for (octave_idx_type i = 0; i < a.rows (); i++)
     {
       for (octave_idx_type j = 0; j < a.cols (); j++)
         {
-          os << " ";
+          os << ' ';
           octave_write_float (os, a.elem (i, j));
         }
       os << "\n";
     }
   return os;
 }
 
 std::istream&
diff --git a/liboctave/array/fNDArray.cc b/liboctave/array/fNDArray.cc
--- a/liboctave/array/fNDArray.cc
+++ b/liboctave/array/fNDArray.cc
@@ -818,17 +818,17 @@ FloatNDArray::diag (octave_idx_type m, o
 // This contains no information on the array structure !!!
 std::ostream&
 operator << (std::ostream& os, const FloatNDArray& a)
 {
   octave_idx_type nel = a.numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-      os << " ";
+      os << ' ';
       octave_write_float (os, a.elem (i));
       os << "\n";
     }
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, FloatNDArray& a)
diff --git a/liboctave/array/fRowVector.cc b/liboctave/array/fRowVector.cc
--- a/liboctave/array/fRowVector.cc
+++ b/liboctave/array/fRowVector.cc
@@ -232,17 +232,17 @@ FloatRowVector::max (void) const
 }
 
 std::ostream&
 operator << (std::ostream& os, const FloatRowVector& a)
 {
 //  int field_width = os.precision () + 7;
 
   for (octave_idx_type i = 0; i < a.numel (); i++)
-    os << " " /* setw (field_width) */ << a.elem (i);
+    os << ' ' /* setw (field_width) */ << a.elem (i);
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, FloatRowVector& a)
 {
   octave_idx_type len = a.numel ();
 
diff --git a/liboctave/array/idx-vector.cc b/liboctave/array/idx-vector.cc
--- a/liboctave/array/idx-vector.cc
+++ b/liboctave/array/idx-vector.cc
@@ -105,17 +105,17 @@ idx_vector::idx_colon_rep::sort_idx (Arr
 {
   (*current_liboctave_error_handler)
     ("internal error: idx_colon_rep::sort_idx");
 }
 
 std::ostream&
 idx_vector::idx_colon_rep::print (std::ostream& os) const
 {
-  return os << ":";
+  return os << ':';
 }
 
 idx_vector::idx_range_rep::idx_range_rep (octave_idx_type _start,
                                           octave_idx_type _limit,
                                           octave_idx_type _step)
   : idx_base_rep (), start(_start),
     len (_step ? std::max ((_limit - _start) / _step,
                            static_cast<octave_idx_type> (0))
diff --git a/liboctave/array/intNDArray.cc b/liboctave/array/intNDArray.cc
--- a/liboctave/array/intNDArray.cc
+++ b/liboctave/array/intNDArray.cc
@@ -140,17 +140,17 @@ intNDArray<T>::insert (const intNDArray<
 
 template <typename T>
 std::ostream&
 operator << (std::ostream& os, const intNDArray<T>& a)
 {
   octave_idx_type nel = a.numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
-    os << " " << a.elem (i) << "\n";
+    os << ' ' << a.elem (i) << "\n";
 
   return os;
 }
 
 template <typename T>
 std::istream&
 operator >> (std::istream& is, intNDArray<T>& a)
 {
diff --git a/liboctave/numeric/CollocWt.cc b/liboctave/numeric/CollocWt.cc
--- a/liboctave/numeric/CollocWt.cc
+++ b/liboctave/numeric/CollocWt.cc
@@ -489,16 +489,16 @@ operator << (std::ostream& os, const Col
 
   if (a.right_included ())
     os << "right boundary is included\n";
   else
     os << "right boundary is not included\n";
 
   os << "\n";
 
-  os << a.Alpha << " " << a.Beta << "\n\n"
+  os << a.Alpha << ' ' << a.Beta << "\n\n"
      << a.r << "\n\n"
      << a.q << "\n\n"
      << a.A << "\n"
      << a.B << "\n";
 
   return os;
 }
diff --git a/liboctave/numeric/DASPK.cc b/liboctave/numeric/DASPK.cc
--- a/liboctave/numeric/DASPK.cc
+++ b/liboctave/numeric/DASPK.cc
@@ -719,71 +719,71 @@ DASPK::error_message (void) const
       break;
 
     case 4:
       retval = "initial condition calculation completed successfully";
       break;
 
     case -1:
       retval = std::string ("a large amount of work has been expended (t =")
-               + t_curr + ")";
+               + t_curr + ')';
       break;
 
     case -2:
       retval = "the error tolerances are too stringent";
       break;
 
     case -3:
       retval = std::string ("error weight became zero during problem. (t = ")
                + t_curr
                + "; solution component i vanished, and atol or atol(i) == 0)";
       break;
 
     case -6:
       retval = std::string ("repeated error test failures on the last attempted step (t = ")
-               + t_curr + ")";
+               + t_curr + ')';
       break;
 
     case -7:
       retval = std::string ("the corrector could not converge (t = ")
-               + t_curr + ")";
+               + t_curr + ')';
       break;
 
     case -8:
       retval = std::string ("the matrix of partial derivatives is singular (t = ")
-               + t_curr + ")";
+               + t_curr + ')';
       break;
 
     case -9:
       retval = std::string ("the corrector could not converge (t = ")
                + t_curr + "; repeated test failures)";
       break;
 
     case -10:
       retval = std::string ("corrector could not converge because IRES was -1 (t = ")
-               + t_curr + ")";
+               + t_curr + ')';
       break;
 
     case -11:
       retval = std::string ("return requested in user-supplied function (t = ")
-               + t_curr + ")";
+               + t_curr + ')';
       break;
 
     case -12:
       retval = "failed to compute consistent initial conditions";
       break;
 
     case -13:
       retval = std::string ("unrecoverable error encountered inside user's PSOL function (t = ")
-               + t_curr + ")";
+               + t_curr + ')';
       break;
 
     case -14:
       retval = std::string ("the Krylov linear system solver failed to converge (t = ")
-               + t_curr + ")";
+               + t_curr + ')';
       break;
 
     case -33:
       retval = "unrecoverable error (see printed message)";
       break;
 
     default:
       retval = "unknown error state";
diff --git a/liboctave/numeric/DASRT.cc b/liboctave/numeric/DASRT.cc
--- a/liboctave/numeric/DASRT.cc
+++ b/liboctave/numeric/DASRT.cc
@@ -582,57 +582,57 @@ DASRT::error_message (void) const
       break;
 
     case 4:
       retval = "integration completed by finding one or more roots of G at T";
       break;
 
     case -1:
       retval = std::string ("a large amount of work has been expended (t =")
-               + t_curr + ")";
+               + t_curr + ')';
       break;
 
     case -2:
       retval = "the error tolerances are too stringent";
       break;
 
     case -3:
       retval = std::string ("error weight became zero during problem. (t = ")
                + t_curr
                + "; solution component i vanished, and atol or atol(i) == 0)";
       break;
 
     case -6:
       retval = std::string ("repeated error test failures on the last attempted step (t = ")
-               + t_curr + ")";
+               + t_curr + ')';
       break;
 
     case -7:
       retval = std::string ("the corrector could not converge (t = ")
-               + t_curr + ")";
+               + t_curr + ')';
       break;
 
     case -8:
       retval = std::string ("the matrix of partial derivatives is singular (t = ")
-               + t_curr + ")";
+               + t_curr + ')';
       break;
 
     case -9:
       retval = std::string ("the corrector could not converge (t = ")
                + t_curr + "; repeated test failures)";
       break;
 
     case -10:
       retval = std::string ("corrector could not converge because IRES was -1 (t = ")
-               + t_curr + ")";
+               + t_curr + ')';
       break;
 
     case -11:
       retval = std::string ("return requested in user-supplied function (t = ")
-               + t_curr + ")";
+               + t_curr + ')';
       break;
 
     case -12:
       retval = "failed to compute consistent initial conditions";
       break;
 
     case -33:
       retval = "unrecoverable error (see printed message)";
diff --git a/liboctave/numeric/DASSL.cc b/liboctave/numeric/DASSL.cc
--- a/liboctave/numeric/DASSL.cc
+++ b/liboctave/numeric/DASSL.cc
@@ -520,57 +520,57 @@ DASSL::error_message (void) const
       break;
 
     case 3:
       retval = "integration to tout completed by stepping past TOUT";
       break;
 
     case -1:
       retval = std::string ("a large amount of work has been expended (t =")
-               + t_curr + ")";
+               + t_curr + ')';
       break;
 
     case -2:
       retval = "the error tolerances are too stringent";
       break;
 
     case -3:
       retval = std::string ("error weight became zero during problem. (t = ")
                + t_curr
                + "; solution component i vanished, and atol or atol(i) == 0)";
       break;
 
     case -6:
       retval = std::string ("repeated error test failures on the last attempted step (t = ")
-               + t_curr + ")";
+               + t_curr + ')';
       break;
 
     case -7:
       retval = std::string ("the corrector could not converge (t = ")
-               + t_curr + ")";
+               + t_curr + ')';
       break;
 
     case -8:
       retval = std::string ("the matrix of partial derivatives is singular (t = ")
-               + t_curr + ")";
+               + t_curr + ')';
       break;
 
     case -9:
       retval = std::string ("the corrector could not converge (t = ")
                + t_curr + "; repeated test failures)";
       break;
 
     case -10:
       retval = std::string ("corrector could not converge because IRES was -1 (t = ")
-               + t_curr + ")";
+               + t_curr + ')';
       break;
 
     case -11:
       retval = std::string ("return requested in user-supplied function (t = ")
-               + t_curr + ")";
+               + t_curr + ')';
       break;
 
     case -12:
       retval = "failed to compute consistent initial conditions";
       break;
 
     case -33:
       retval = "unrecoverable error (see printed message)";
diff --git a/liboctave/numeric/LSODE.cc b/liboctave/numeric/LSODE.cc
--- a/liboctave/numeric/LSODE.cc
+++ b/liboctave/numeric/LSODE.cc
@@ -359,17 +359,17 @@ LSODE::error_message (void) const
     case -6:
       retval = std::string ("error weight became zero during problem. (t = ")
                + t_curr
                + "; solution component i vanished, and atol or atol(i) == 0)";
       break;
 
     case -13:
       retval = "return requested in user-supplied function (t = "
-               + t_curr + ")";
+               + t_curr + ')';
       break;
 
     default:
       retval = "unknown error state";
       break;
     }
 
   return retval;
diff --git a/liboctave/system/oct-time.cc b/liboctave/system/oct-time.cc
--- a/liboctave/system/oct-time.cc
+++ b/liboctave/system/oct-time.cc
@@ -91,17 +91,17 @@ namespace octave
       return localtime (*this).asctime ();
     }
 
     std::ostream&
     operator << (std::ostream& os, const time& ot)
     {
       preserve_stream_state stream_state (os);
 
-      os << ot.ot_unix_time << "."
+      os << ot.ot_unix_time << '.'
          << std::setw (6) << std::setfill ('0') << ot.ot_usec;
 
       return os;
     }
 
     void
     time::stamp (void)
     {
diff --git a/liboctave/util/cmd-hist.cc b/liboctave/util/cmd-hist.cc
--- a/liboctave/util/cmd-hist.cc
+++ b/liboctave/util/cmd-hist.cc
@@ -124,17 +124,17 @@ namespace octave
     size_t beg = 0;
 
     while (beg < len)
       {
         if (control_arg[beg] == ':')
           beg++;
         else
           {
-            size_t end = control_arg.find (":", beg);
+            size_t end = control_arg.find (':', beg);
 
             if (end == std::string::npos)
               end = len;
 
             std::string tmp = control_arg.substr (beg, end-beg);
 
             if (tmp == "erasedups")
               history_control |= HC_ERASEDUPS;
@@ -164,25 +164,25 @@ namespace octave
     std::string retval;
 
     if (history_control & HC_IGNSPACE)
       retval.append ("ignorespace");
 
     if (history_control & HC_IGNDUPS)
       {
         if (retval.length () > 0)
-          retval.append (":");
+          retval += ':';
 
         retval.append ("ignoredups");
       }
 
     if (history_control & HC_ERASEDUPS)
       {
         if (retval.length () > 0)
-          retval.append (":");
+          retval += ':';
 
         retval.append ("erasedups");
       }
 
     return retval;
   }
 
   bool
diff --git a/liboctave/util/kpse.cc b/liboctave/util/kpse.cc
--- a/liboctave/util/kpse.cc
+++ b/liboctave/util/kpse.cc
@@ -261,17 +261,17 @@ static bool first_search = true;
 static void
 log_search (const std::list<std::string>& filenames)
 {
   if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
     {
       for (const auto& filename : filenames)
         {
           octave::sys::time now;
-          std::cerr << now.unix_time () << " " << filename << std::endl;
+          std::cerr << now.unix_time () << ' ' << filename << std::endl;
         }
     }
 }
 
 /* Concatenate each element in DIRS with NAME (assume each ends with a
    /, to save time).  If SEARCH_ALL is false, return the first readable
    regular file.  Else continue to search for more.  In any case, if
    none, return a list containing just NULL.
@@ -557,17 +557,17 @@ find_first_of (const std::string& path, 
       for (auto p = names.cbegin (); p != names.cend (); p++)
         {
           if (p == names.cbegin ())
             std::cerr << *p;
           else
             std::cerr << ", " << *p;
         }
 
-      std::cerr << "), path=" << path << "." << std::endl;
+      std::cerr << "), path=" << path << '.' << std::endl;
     }
 
   for (const auto& name : names)
     {
       if (kpse_absolute_p (name, true))
         {
           /* If the name is absolute or explicitly relative, no need
              to consider PATH at all.  If we find something, then we
diff --git a/liboctave/util/lo-array-errwarn.cc b/liboctave/util/lo-array-errwarn.cc
--- a/liboctave/util/lo-array-errwarn.cc
+++ b/liboctave/util/lo-array-errwarn.cc
@@ -131,17 +131,17 @@ namespace octave
       buf << var;
 
     bool show_parens = dim > 0;
 
     if (show_parens)
       {
         if (dim < 5)
           {
-            buf << "(";
+            buf << '(';
 
             for (octave_idx_type i = 1; i < dim; i++)
               buf << "_,";
           }
         else
           buf << "(...[x" << dim - 1 << "]...";
       }
 
@@ -150,17 +150,17 @@ namespace octave
     if (show_parens)
       {
         if (nd - dim < 5)
           {
             for (octave_idx_type i = 0; i < nd - dim; i++)
               buf << ",_";
 
             if (nd >= dim)
-              buf << ")";
+              buf << ')';
           }
         else
           buf << "...[x" << nd - dim << "]...)";
       }
 
     return buf.str ();
   }
 
diff --git a/liboctave/util/lo-regexp.cc b/liboctave/util/lo-regexp.cc
--- a/liboctave/util/lo-regexp.cc
+++ b/liboctave/util/lo-regexp.cc
@@ -179,35 +179,35 @@ namespace octave
                       {
                         lookbehind_warned = true;
                         (*current_liboctave_warning_with_id_handler)
                           ("Octave:regexp-lookbehind-limit",
                            "%s: arbitrary length lookbehind patterns are only supported up to length %d",
                            who.c_str (), MAXLOOKBEHIND);
                       }
 
-                    buf << pattern.substr (pos, new_pos - pos) << "(";
+                    buf << pattern.substr (pos, new_pos - pos) << '(';
 
                     size_t i;
 
                     if (pattern.at (tmp_pos3) == '*')
                       i = 0;
                     else
                       i = 1;
 
                     for (; i < max_length + 1; i++)
                       {
                         buf << pattern.substr (new_pos, tmp_pos3 - new_pos)
-                            << "{" << i << "}";
+                            << '{' << i << '}';
                         buf << pattern.substr (tmp_pos3 + 1,
                                                tmp_pos1 - tmp_pos3 - 1);
                         if (i != max_length)
-                          buf << "|";
+                          buf << '|';
                       }
-                    buf << ")";
+                    buf << ')';
                   }
                 else
                   buf << pattern.substr (pos, tmp_pos1 - pos);
 
                 pos = tmp_pos1;
               }
           }
         else
diff --git a/liboctave/util/lo-utils.cc b/liboctave/util/lo-utils.cc
--- a/liboctave/util/lo-utils.cc
+++ b/liboctave/util/lo-utils.cc
@@ -392,21 +392,21 @@ octave_write_double (std::ostream& os, d
     os << (d < 0 ? "-Inf" : "Inf");
   else
     os << d;
 }
 
 void
 octave_write_complex (std::ostream& os, const Complex& c)
 {
-  os << "(";
+  os << '(';
   octave_write_double (os, real (c));
-  os << ",";
+  os << ',';
   octave_write_double (os, imag (c));
-  os << ")";
+  os << ')';
 }
 
 void
 octave_write_float (std::ostream& os, float d)
 {
   if (lo_ieee_is_NA (d))
     os << "NA";
   else if (lo_ieee_isnan (d))
@@ -415,14 +415,14 @@ octave_write_float (std::ostream& os, fl
     os << (d < 0 ? "-Inf" : "Inf");
   else
     os << d;
 }
 
 void
 octave_write_float_complex (std::ostream& os, const FloatComplex& c)
 {
-  os << "(";
+  os << '(';
   octave_write_float (os, real (c));
-  os << ",";
+  os << ',';
   octave_write_float (os, imag (c));
-  os << ")";
+  os << ')';
 }
diff --git a/liboctave/util/str-vec.cc b/liboctave/util/str-vec.cc
--- a/liboctave/util/str-vec.cc
+++ b/liboctave/util/str-vec.cc
@@ -252,16 +252,16 @@ string_vector::list_in_columns (std::ost
           octave_idx_type name_length = nm.length ();
 
           count += nr;
           if (count >= total_names)
             break;
 
           octave_idx_type spaces_to_pad = max_name_length - name_length;
           for (octave_idx_type i = 0; i < spaces_to_pad; i++)
-            os << " ";
+            os << ' ';
           pos += max_name_length;
         }
       os << "\n";
     }
 
   return os;
 }
diff --git a/liboctave/util/url-transfer.cc b/liboctave/util/url-transfer.cc
--- a/liboctave/util/url-transfer.cc
+++ b/liboctave/util/url-transfer.cc
@@ -429,17 +429,17 @@ namespace octave
       if (! good ())
         return;
 
       SETOPT (CURLOPT_POSTQUOTE, 0);
     }
 
     void put (const std::string& file, std::istream& is)
     {
-      url = "ftp://" + host_or_url + "/" + file;
+      url = "ftp://" + host_or_url + '/' + file;
       SETOPT (CURLOPT_URL, url.c_str ());
       SETOPT (CURLOPT_UPLOAD, 1);
       SETOPT (CURLOPT_NOBODY, 0);
       std::istream& old_is = set_istream (is);
 
       perform ();
       if (! good ())
         return;
@@ -448,34 +448,34 @@ namespace octave
       SETOPT (CURLOPT_NOBODY, 1);
       SETOPT (CURLOPT_UPLOAD, 0);
       url = "ftp://" + host_or_url;
       SETOPT (CURLOPT_URL, url.c_str ());
     }
 
     void get (const std::string& file, std::ostream& os)
     {
-      url = "ftp://" + host_or_url + "/" + file;
+      url = "ftp://" + host_or_url + '/' + file;
       SETOPT (CURLOPT_URL, url.c_str ());
       SETOPT (CURLOPT_NOBODY, 0);
       std::ostream& old_os = set_ostream (os);
 
       perform ();
       if (! good ())
         return;
 
       set_ostream (old_os);
       SETOPT (CURLOPT_NOBODY, 1);
       url = "ftp://" + host_or_url;
       SETOPT (CURLOPT_URL, url.c_str ());
     }
 
     void dir (void)
     {
-      url = "ftp://" + host_or_url + "/";
+      url = "ftp://" + host_or_url + '/';
       SETOPT (CURLOPT_URL, url.c_str ());
       SETOPT (CURLOPT_NOBODY, 0);
 
       perform ();
       if (! good ())
         return;
 
       SETOPT (CURLOPT_NOBODY, 1);
@@ -483,17 +483,17 @@ namespace octave
       SETOPT (CURLOPT_URL, url.c_str ());
     }
 
     string_vector list (void)
     {
       string_vector retval;
 
       std::ostringstream buf;
-      url = "ftp://" + host_or_url + "/";
+      url = "ftp://" + host_or_url + '/';
       SETOPTR (CURLOPT_WRITEDATA, static_cast<void *> (&buf));
       SETOPTR (CURLOPT_URL, url.c_str ());
       SETOPTR (CURLOPT_DIRLISTONLY, 1);
       SETOPTR (CURLOPT_NOBODY, 0);
 
       perform ();
       if (! good ())
         return retval;
@@ -531,17 +531,17 @@ namespace octave
       return retval;
     }
 
     void get_fileinfo (const std::string& filename, double& filesize,
                        time_t& filetime, bool& fileisdir)
     {
       std::string path = pwd ();
 
-      url = "ftp://" + host_or_url + "/" + path + "/" + filename;
+      url = "ftp://" + host_or_url + '/' + path + '/' + filename;
       SETOPT (CURLOPT_URL, url.c_str ());
       SETOPT (CURLOPT_FILETIME, 1);
       SETOPT (CURLOPT_HEADERFUNCTION, throw_away);
       SETOPT (CURLOPT_WRITEFUNCTION, throw_away);
 
       // FIXME
       // The MDTM command fails for a directory on the servers I tested
       // so this is a means of testing for directories.  It also means
@@ -570,17 +570,17 @@ namespace octave
       SETOPT (CURLOPT_FILETIME, 0);
       url = "ftp://" + host_or_url;
       SETOPT (CURLOPT_URL, url.c_str ());
 
       // The MDTM command seems to reset the path to the root with the
       // servers I tested with, so cd again into the correct path.  Make
       // the path absolute so that this will work even with servers that
       // don't end up in the root after an MDTM command.
-      cwd ("/" + path);
+      cwd ('/' + path);
     }
 
     std::string pwd (void)
     {
       std::string retval;
 
       struct curl_slist *slist = nullptr;
 
@@ -614,17 +614,17 @@ namespace octave
 
     void http_get (const Array<std::string>& param)
     {
       url = host_or_url;
 
       std::string query_string = form_query_string (param);
 
       if (! query_string.empty ())
-        url += "?" + query_string;
+        url += '?' + query_string;
 
       SETOPT (CURLOPT_URL, url.c_str ());
 
       perform ();
     }
 
     void http_post (const Array<std::string>& param)
     {
@@ -678,17 +678,17 @@ namespace octave
                std::istream& is, std::ostream& os)
     {
       // No data transfer by default
       SETOPT (CURLOPT_NOBODY, 1);
 
       // Set the username and password
       userpwd = user;
       if (! passwd.empty ())
-        userpwd += ":" + passwd;
+        userpwd += ':' + passwd;
       if (! userpwd.empty ())
         SETOPT (CURLOPT_USERPWD, userpwd.c_str ());
 
       // Define our callback to get called when there's data to be written.
       SETOPT (CURLOPT_WRITEFUNCTION, write_data);
 
       // Set a pointer to our struct to pass to the callback.
       SETOPT (CURLOPT_WRITEDATA, static_cast<void *> (&os));
@@ -724,40 +724,40 @@ namespace octave
           std::string text = param(i+1);
 
           // Encode strings.
           char *enc_name = curl_easy_escape (curl, name.c_str (),
                                              name.length ());
           char *enc_text = curl_easy_escape (curl, text.c_str (),
                                              text.length ());
 
-          query << enc_name << "=" << enc_text;
+          query << enc_name << '=' << enc_text;
 
           curl_free (enc_name);
           curl_free (enc_text);
 
           if (i < param.numel ()-1)
-            query << "&";
+            query << '&';
         }
 
       query.flush ();
 
       return query.str ();
     }
 
     void ftp_file_or_dir_action (const std::string& file_or_dir,
                                  const std::string& action)
     {
       struct curl_slist *slist = nullptr;
 
       unwind_protect frame;
 
       frame.add_fcn (curl_slist_free_all, slist);
 
-      std::string cmd = action + " " + file_or_dir;
+      std::string cmd = action + ' ' + file_or_dir;
 
       slist = curl_slist_append (slist, cmd.c_str ());
 
       SETOPT (CURLOPT_POSTQUOTE, slist);
 
       perform ();
 
       if (! good ())
diff --git a/src/main-cli.cc b/src/main-cli.cc
--- a/src/main-cli.cc
+++ b/src/main-cli.cc
@@ -55,27 +55,27 @@ check_hg_versions (void)
   std::string liboctinterp_id = liboctinterp_hg_id ();
 
   if (octave_id != liboctave_id)
     {
       std::cerr << "octave hg id ("
                 << octave_id
                 << ") does not match liboctave hg id ("
                 << liboctave_id
-                << ")" << std::endl;
+                << ')' << std::endl;
       ok = false;
     }
 
   if (octave_id != liboctinterp_id)
     {
       std::cerr << "octave hg id ("
                 << octave_id
                 << ") does not match liboctinterp hg id ("
                 << liboctinterp_id
-                << ")" << std::endl;
+                << ')' << std::endl;
       ok = false;
     }
 
   if (! ok)
     exit (1);
 }
 
 int
diff --git a/src/main-gui.cc b/src/main-gui.cc
--- a/src/main-gui.cc
+++ b/src/main-gui.cc
@@ -59,37 +59,37 @@ check_hg_versions (void)
   std::string liboctgui_id = liboctgui_hg_id ();
 
   if (octave_id != liboctave_id)
     {
       std::cerr << "octave hg id ("
                 << octave_id
                 << ") does not match liboctave hg id ("
                 << liboctave_id
-                << ")" << std::endl;
+                << ')' << std::endl;
       ok = false;
     }
 
   if (octave_id != liboctinterp_id)
     {
       std::cerr << "octave hg id ("
                 << octave_id
                 << ") does not match liboctinterp hg id ("
                 << liboctinterp_id
-                << ")" << std::endl;
+                << ')' << std::endl;
       ok = false;
     }
 
   if (octave_id != liboctgui_id)
     {
       std::cerr << "octave hg id ("
                 << octave_id
                 << ") does not match liboctgui hg id ("
                 << liboctgui_id
-                << ")" << std::endl;
+                << ')' << std::endl;
       ok = false;
     }
 
   if (! ok)
     exit (1);
 }
 
 int
diff --git a/src/mkoctfile.in.cc b/src/mkoctfile.in.cc
--- a/src/mkoctfile.in.cc
+++ b/src/mkoctfile.in.cc
@@ -255,33 +255,33 @@ initialize (void)
 
   vars["LD_STATIC_FLAG"] = get_variable ("LD_STATIC_FLAG",
                                          %OCTAVE_CONF_LD_STATIC_FLAG%);
 
   vars["LFLAGS"] = get_variable ("LFLAGS", DEFAULT_LFLAGS);
 
   vars["F77_INTEGER8_FLAG"] = get_variable ("F77_INTEGER8_FLAG",
                                             %OCTAVE_CONF_F77_INTEGER_8_FLAG%);
-  vars["ALL_FFLAGS"] = vars["FFLAGS"] + " " + vars["F77_INTEGER8_FLAG"];
+  vars["ALL_FFLAGS"] = vars["FFLAGS"] + ' ' + vars["F77_INTEGER8_FLAG"];
 
   vars["ALL_CFLAGS"]
-    = vars["INCFLAGS"] + " " + vars["XTRA_CFLAGS"] + " " + vars["CFLAGS"];
+    = vars["INCFLAGS"] + ' ' + vars["XTRA_CFLAGS"] + ' ' + vars["CFLAGS"];
 
   vars["ALL_CXXFLAGS"]
-    = vars["INCFLAGS"] + " " + vars["XTRA_CXXFLAGS"] + " " + vars["CXXFLAGS"];
+    = vars["INCFLAGS"] + ' ' + vars["XTRA_CXXFLAGS"] + ' ' + vars["CXXFLAGS"];
 
   vars["ALL_LDFLAGS"]
-    = vars["LD_STATIC_FLAG"] + " " + vars["CPICFLAG"] + " " + vars["LDFLAGS"];
+    = vars["LD_STATIC_FLAG"] + ' ' + vars["CPICFLAG"] + ' ' + vars["LDFLAGS"];
 
   vars["OCTAVE_LIBS"]
-    = (vars["LIBOCTINTERP"] + " " + vars["LIBOCTAVE"] + " "
+    = (vars["LIBOCTINTERP"] + ' ' + vars["LIBOCTAVE"] + ' '
        + vars["SPECIAL_MATH_LIB"]);
 
-  vars["FFTW_LIBS"] = vars["FFTW3_LDFLAGS"] + " " + vars["FFTW3_LIBS"] + " "
-                      + vars["FFTW3F_LDFLAGS"] + " " + vars["FFTW3F_LIBS"];
+  vars["FFTW_LIBS"] = vars["FFTW3_LDFLAGS"] + ' ' + vars["FFTW3_LIBS"] + ' '
+                      + vars["FFTW3F_LDFLAGS"] + ' ' + vars["FFTW3F_LIBS"];
 }
 
 static std::string usage_msg = "usage: mkoctfile [options] file ...";
 
 static std::string version_msg = "mkoctfile, version " OCTAVE_VERSION;
 
 static bool debug = false;
 
@@ -504,22 +504,22 @@ main (int argc, char **argv)
                || ends_with (arg, "f90") || ends_with (arg, ".F90"))
         {
           file = arg;
           f77files.push_back (file);
         }
       else if (ends_with (arg, ".o") || ends_with (arg, ".obj"))
         {
           file = arg;
-          objfiles += (" " + quote_path (arg));
+          objfiles += (' ' + quote_path (arg));
         }
       else if (ends_with (arg, ".lib") || ends_with (arg, ".a"))
         {
           file = arg;
-          libfiles += (" " + quote_path (arg));
+          libfiles += (' ' + quote_path (arg));
         }
       else if (arg == "-d" || arg == "-debug" || arg == "--debug"
                || arg == "-v" || arg == "-verbose" ||  arg == "--verbose")
         {
           debug = true;
           if (vars["CC"] == "cc-msvc")
             vars["CC"] += " -d";
           if (vars["CXX"] == "cc-msvc")
@@ -530,46 +530,46 @@ main (int argc, char **argv)
       else if (arg == "-h" || arg == "-?" || arg == "-help" || arg == "--help")
         {
           std::cout << usage_msg << std::endl;
           std::cout << help_msg << std::endl;
           return 0;
         }
       else if (starts_with (arg, "-I"))
         {
-          incflags += (" " + quote_path (arg));
+          incflags += (' ' + quote_path (arg));
         }
       else if (arg == "-idirafter")
         {
           if (i < argc-1)
             {
               arg = argv[++i];
               incflags += (" -idirafter " + arg);
             }
           else
             std::cerr << "mkoctfile: include directory name missing"
                       << std::endl;
         }
       else if (starts_with (arg, "-D"))
         {
-          defs += (" " + arg);
+          defs += (' ' + arg);
         }
       else if (arg == "-largeArrayDims" || arg == "-compatibleArrayDims")
         {
           std::cout << "warning: -largeArrayDims and -compatibleArrayDims are accepted for compatibility, but ignored" << std::endl;
         }
       else if (starts_with (arg, "-Wl,") || starts_with (arg, "-l")
                || starts_with (arg, "-L") || starts_with (arg, "-R"))
         {
-          ldflags += (" " + arg);
+          ldflags += (' ' + arg);
         }
 #if ! defined (OCTAVE_USE_WINDOWS_API)
       else if (arg == "-pthread")
         {
-          ldflags += (" " + arg);
+          ldflags += (' ' + arg);
         }
 #endif
       else if (arg == "-M" || arg == "-depend" || arg == "--depend")
         {
           depend = true;
         }
       else if (arg == "-o" || arg == "-output" || arg == "--output")
         {
@@ -623,22 +623,22 @@ main (int argc, char **argv)
           incflags += " -I.";
 #if defined (_MSC_VER)
           ldflags += " -Wl,-export:mexFunction";
 #endif
           output_ext = ".mex";
         }
       else if (starts_with (arg, "-W"))
         {
-          pass_on_options += (" " + arg);
+          pass_on_options += (' ' + arg);
         }
       else if (starts_with (arg, "-"))
         {
           // Pass through any unrecognized options
-          pass_on_options += (" " + arg);
+          pass_on_options += (' ' + arg);
         }
       else
         {
           std::cerr << "mkoctfile: unrecognized argument " << arg << std::endl;
           return 1;
         }
 
       if (! file.empty () && octfile.empty ())
@@ -676,68 +676,68 @@ main (int argc, char **argv)
     {
       for (const auto& f : cfiles)
         {
           std::string dfile = basename (f, true) + ".d", line;
 
           octave_unlink_wrapper (dfile.c_str ());
 
           std::string cmd
-            = (vars["CC"] + " " + vars["DEPEND_FLAGS"] + " "
-               + vars["CPPFLAGS"] + " " + vars["ALL_CFLAGS"] + " "
-               + incflags  + " " + defs + " " + quote_path (f));
+            = (vars["CC"] + ' ' + vars["DEPEND_FLAGS"] + ' '
+               + vars["CPPFLAGS"] + ' ' + vars["ALL_CFLAGS"] + ' '
+               + incflags  + ' ' + defs + ' ' + quote_path (f));
 
           FILE *fd = popen (cmd.c_str (), "r");
           std::ofstream fo (dfile.c_str ());
           size_t pos;
           while (! feof (fd))
             {
               line = get_line (fd);
               if ((pos = line.rfind (".o:")) != std::string::npos)
                 {
                   size_t spos = line.rfind ('/', pos);
                   std::string ofile =
                     (spos == std::string::npos
                      ? line.substr (0, pos+2)
                      : line.substr (spos+1, pos-spos+1));
-                  fo << "pic/" << ofile << " " << ofile << " "
+                  fo << "pic/" << ofile << ' ' << ofile << ' '
                      << dfile << line.substr (pos) << std::endl;
                 }
               else
                 fo << line << std::endl;
             }
           pclose (fd);
           fo.close ();
         }
 
       for (const auto& f : ccfiles)
         {
           std::string dfile = basename (f, true) + ".d", line;
 
           octave_unlink_wrapper (dfile.c_str ());
 
           std::string cmd
-            = (vars["CXX"] + " " + vars["DEPEND_FLAGS"] + " "
-               + vars["CPPFLAGS"] + " " + vars["ALL_CXXFLAGS"] + " "
-               + incflags  + " " + defs + " " + quote_path (f));
+            = (vars["CXX"] + ' ' + vars["DEPEND_FLAGS"] + ' '
+               + vars["CPPFLAGS"] + ' ' + vars["ALL_CXXFLAGS"] + ' '
+               + incflags  + ' ' + defs + ' ' + quote_path (f));
 
           FILE *fd = popen (cmd.c_str (), "r");
           std::ofstream fo (dfile.c_str ());
           size_t pos;
           while (! feof (fd))
             {
               line = get_line (fd);
               if ((pos = line.rfind (".o:")) != std::string::npos)
                 {
                   size_t spos = line.rfind ('/', pos);
                   std::string ofile =
                     (spos == std::string::npos
                      ? line.substr (0, pos+2)
                      : line.substr (spos+1, pos-spos+1));
-                  fo << "pic/" << ofile << " " << ofile << " "
+                  fo << "pic/" << ofile << ' ' << ofile << ' '
                      << dfile << line.substr (pos+2) << std::endl;
                 }
               else
                 fo << line << std::endl;
             }
           pclose (fd);
           fo.close ();
         }
@@ -756,22 +756,22 @@ main (int argc, char **argv)
             {
               if (link)
                 o = b + ".o";
               else
                 o = outputfile;
             }
           else
             o = b + ".o";
-          objfiles += (" " + o);
+          objfiles += (' ' + o);
 
           std::string cmd
-            = (vars["F77"] + " -c " + vars["FPICFLAG"] + " "
-               + vars["ALL_FFLAGS"] + " " + incflags + " " + defs + " "
-               + pass_on_options + " " + f + " -o " + o);
+            = (vars["F77"] + " -c " + vars["FPICFLAG"] + ' '
+               + vars["ALL_FFLAGS"] + ' ' + incflags + ' ' + defs + ' '
+               + pass_on_options + ' ' + f + " -o " + o);
 
           int status = run_command (cmd, printonly);
 
           if (status)
             return status;
         }
       else
         {
@@ -790,22 +790,22 @@ main (int argc, char **argv)
             {
               if (link)
                 o = b + ".o";
               else
                 o = outputfile;
             }
           else
             o = b + ".o";
-          objfiles += (" " + o);
+          objfiles += (' ' + o);
 
           std::string cmd
-            = (vars["CC"] + " -c " + vars["CPPFLAGS"] + " "
-               + vars["CPICFLAG"] + " " + vars["ALL_CFLAGS"] + " "
-               + pass_on_options + " " + incflags + " " + defs + " "
+            = (vars["CC"] + " -c " + vars["CPPFLAGS"] + ' '
+               + vars["CPICFLAG"] + ' ' + vars["ALL_CFLAGS"] + ' '
+               + pass_on_options + ' ' + incflags + ' ' + defs + ' '
                + quote_path (f) + " -o " + quote_path (o));
 
           int status = run_command (cmd, printonly);
 
           if (status)
             return status;
         }
       else
@@ -825,22 +825,22 @@ main (int argc, char **argv)
             {
               if (link)
                 o = b + ".o";
               else
                 o = outputfile;
             }
           else
             o = b + ".o";
-          objfiles += (" " + o);
+          objfiles += (' ' + o);
 
           std::string cmd
-            = (vars["CXX"] + " -c " + vars["CPPFLAGS"] + " "
-               + vars["CXXPICFLAG"] + " " + vars["ALL_CXXFLAGS"] + " "
-               + pass_on_options + " " + incflags + " " + defs + " "
+            = (vars["CXX"] + " -c " + vars["CPPFLAGS"] + ' '
+               + vars["CXXPICFLAG"] + ' ' + vars["ALL_CXXFLAGS"] + ' '
+               + pass_on_options + ' ' + incflags + ' ' + defs + ' '
                + quote_path (f) + " -o " + quote_path (o));
 
           int status = run_command (cmd, printonly);
 
           if (status)
             return status;
         }
       else
@@ -853,22 +853,22 @@ main (int argc, char **argv)
 
   if (link && ! objfiles.empty ())
     {
       if (link_stand_alone)
         {
           if (! vars["LD_CXX"].empty ())
             {
               std::string cmd
-                = (vars["LD_CXX"] + " " + vars["CPPFLAGS"] + " "
-                   + vars["ALL_CXXFLAGS"] + " " + vars["RDYNAMIC_FLAG"] + " "
-                   + vars["ALL_LDFLAGS"] + " " + pass_on_options + " "
-                   + output_option + " " + objfiles + " " + libfiles + " "
-                   + ldflags + " " + vars["LFLAGS"] + " -loctinterp -loctave "
-                   + vars["OCTAVE_LINK_OPTS"] + " " + vars["OCTAVE_LINK_DEPS"]);
+                = (vars["LD_CXX"] + ' ' + vars["CPPFLAGS"] + ' '
+                   + vars["ALL_CXXFLAGS"] + ' ' + vars["RDYNAMIC_FLAG"] + ' '
+                   + vars["ALL_LDFLAGS"] + ' ' + pass_on_options + ' '
+                   + output_option + ' ' + objfiles + ' ' + libfiles + ' '
+                   + ldflags + ' ' + vars["LFLAGS"] + " -loctinterp -loctave "
+                   + vars["OCTAVE_LINK_OPTS"] + ' ' + vars["OCTAVE_LINK_DEPS"]);
 
               int status = run_command (cmd, printonly);
 
               if (status)
                 return status;
             }
           else
             {
@@ -876,21 +876,21 @@ main (int argc, char **argv)
                 << "mkoctfile: no way to link stand-alone executable file"
                 << std::endl;
               return 1;
             }
         }
       else
         {
           std::string cmd
-            = (vars["DL_LD"] + " " + vars["ALL_CXXFLAGS"] + " "
-               + vars["DL_LDFLAGS"] + " " + pass_on_options
-               + " -o " + octfile + " " + objfiles + " " + libfiles + " "
-               + ldflags + " " + vars["LFLAGS"] + " -loctinterp -loctave "
-               + vars["OCT_LINK_OPTS"] + " " + vars["OCT_LINK_DEPS"]);
+            = (vars["DL_LD"] + ' ' + vars["ALL_CXXFLAGS"] + ' '
+               + vars["DL_LDFLAGS"] + ' ' + pass_on_options
+               + " -o " + octfile + ' ' + objfiles + ' ' + libfiles + ' '
+               + ldflags + ' ' + vars["LFLAGS"] + " -loctinterp -loctave "
+               + vars["OCT_LINK_OPTS"] + ' ' + vars["OCT_LINK_DEPS"]);
 
           int status = run_command (cmd, printonly);
 
           if (status)
             return status;
         }
 
       if (strip)
