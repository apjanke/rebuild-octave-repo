# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1449687643 18000
#      Wed Dec 09 14:00:43 2015 -0500
# Node ID 35241c4b696c3dc61409a2cc37190b3ba806ed38
# Parent  ae0bd73671f35e31e1c00e78ac605fc88606fcb7
eliminate return statements after calls to error

* Cell.cc, __ichol__.cc, __lin_interpn__.cc, __pchip_deriv__.cc,
besselj.cc, cellfun.cc, colloc.cc, debug.cc, dlmread.cc,
dynamic-ld.cc, filter.cc, find.cc, gl2ps-renderer.cc, load-path.cc,
load-save.cc, ls-mat4.cc, ls-mat5.cc, ls-oct-text.cc, luinc.cc,
max.cc, nproc.cc, oct-hist.cc, oct-map.cc, oct-obj.cc, oct-stream.cc,
ordschur.cc, pinv.cc, pr-output.cc, profiler.cc, psi.cc, quadcc.cc,
qz.cc, rand.cc, strfind.cc, strfns.cc, sysdep.cc, toplev.cc, tril.cc,
typecast.cc, urlwrite.cc, utils.cc, variables.cc: Eliminate return
statements after calls to error.

diff --git a/libinterp/corefcn/Cell.cc b/libinterp/corefcn/Cell.cc
--- a/libinterp/corefcn/Cell.cc
+++ b/libinterp/corefcn/Cell.cc
@@ -289,25 +289,23 @@ Cell
 Cell::column (octave_idx_type i) const
 {
   Cell retval;
 
   if (ndims () < 3)
     {
       if (i < 0 || i >= cols ())
         error ("invalid column selection");
-      else
-        {
-          octave_idx_type nr = rows ();
+
+      octave_idx_type nr = rows ();
 
-          retval.resize (dim_vector (nr, 1));
+      retval.resize (dim_vector (nr, 1));
 
-          for (octave_idx_type j = 0; j < nr; j++)
-            retval.xelem (j) = elem (j, i);
-        }
+      for (octave_idx_type j = 0; j < nr; j++)
+        retval.xelem (j) = elem (j, i);
     }
   else
     error ("Cell::column: requires 2-D cell array");
 
   return retval;
 }
 
 Cell
diff --git a/libinterp/corefcn/__ichol__.cc b/libinterp/corefcn/__ichol__.cc
--- a/libinterp/corefcn/__ichol__.cc
+++ b/libinterp/corefcn/__ichol__.cc
@@ -47,35 +47,28 @@ Complex ichol_mult_complex (Complex a, C
 double ichol_mult_real (double a, double b)
 {
   return a * b;
 }
 
 bool ichol_checkpivot_complex (Complex pivot)
 {
   if (pivot.imag () != 0)
-    {
-      error ("ichol: non-real pivot encountered.  The matrix must be hermitian.");
-      return false;
-    }
+    error ("ichol: non-real pivot encountered.  The matrix must be hermitian.");
   else if (pivot.real () < 0)
-    {
-      error ("ichol: negative pivot encountered");
-      return false;
-    }
+    error ("ichol: negative pivot encountered");
+
   return true;
 }
 
 bool ichol_checkpivot_real (double pivot)
 {
   if (pivot < 0)
-    {
-      error ("ichol: negative pivot encountered");
-      return false;
-    }
+    error ("ichol: negative pivot encountered");
+
   return true;
 }
 
 template <typename octave_matrix_t, typename T, T (*ichol_mult) (T, T),
           bool (*ichol_checkpivot) (T)>
 void ichol_0 (octave_matrix_t& sm, const std::string michol = "off")
 {
 
@@ -151,20 +144,17 @@ void ichol_0 (octave_matrix_t& sm, const
           else
             jrow = Llist[jrow];
         }
 
       if (opt == ON)
         data[j1] += dropsums[k];
 
       if (ridx[j1] != k)
-        {
-          error ("ichol: encountered a pivot equal to 0");
-          break;
-        }
+        error ("ichol: encountered a pivot equal to 0");
 
       if (! ichol_checkpivot (data[j1]))
         break;
 
       data[cidx[k]] = std::sqrt (data[j1]);
 
       // Update Llist and Lfirst with the k-column information.  Also,
       // scale the column elements by the pivot and reset the working array iw.
@@ -384,36 +374,32 @@ void ichol_t (const octave_matrix_t& sm,
           w_data[jrow] = zero;
         }
 
       // Compensate column sums --> michol option
       if (opt == ON)
         data_l[total_len] += col_drops[k];
 
       if (data_l[total_len] == zero)
-        {
-          error ("ichol: encountered a pivot equal to 0");
-          break;
-        }
-      else if (! ichol_checkpivot (data_l[total_len]))
+        error ("ichol: encountered a pivot equal to 0");
+
+      if (! ichol_checkpivot (data_l[total_len]))
         break;
 
       // Once elements are dropped and compensation of column sums are done,
       // scale the elements by the pivot.
       data_l[total_len] = std::sqrt (data_l[total_len]);
       for (jj = total_len + 1; jj < (total_len + w_len); jj++)
         data_l[jj] /=  data_l[total_len];
       total_len += w_len;
       // Check if there are too many elements to be indexed with
       // octave_idx_type type due to fill-in during the process.
       if (total_len < 0)
-        {
-          error ("ichol: integer overflow.  Too many fill-in elements in L");
-          break;
-        }
+        error ("ichol: integer overflow.  Too many fill-in elements in L");
+
       cidx_l[k+1] = cidx_l[k] - cidx_l[0] + w_len;
 
       // Update Llist and Lfirst with the k-column information.
       if (k < (n - 1))
         {
           Lfirst[k] = cidx_l[k];
           if ((Lfirst[k] + 1) < cidx_l[k+1])
             {
diff --git a/libinterp/corefcn/__lin_interpn__.cc b/libinterp/corefcn/__lin_interpn__.cc
--- a/libinterp/corefcn/__lin_interpn__.cc
+++ b/libinterp/corefcn/__lin_interpn__.cc
@@ -217,41 +217,33 @@ lin_interpn (int n, M *X, const M V, M *
   // tests if X[0] is a vector, if yes, assume that all elements of X are
   // in the ndgrid format.
 
   if (! isvector (X[0]))
     {
       for (int i = 0; i < n; i++)
         {
           if (X[i].dims () != V.dims ())
-            {
-              error ("interpn: incompatible size of argument number %d", i+1);
-              return retval;
-            }
-          else
-            {
-              M tmp = M (dim_vector (size[i], 1));
+            error ("interpn: incompatible size of argument number %d", i+1);
+
+          M tmp = M (dim_vector (size[i], 1));
 
-              for (octave_idx_type j = 0; j < size[i]; j++)
-                tmp(j) =  X[i](scale[i]*j);
+          for (octave_idx_type j = 0; j < size[i]; j++)
+            tmp(j) =  X[i](scale[i]*j);
 
-              X[i] = tmp;
-            }
+          X[i] = tmp;
         }
     }
 
   for (int i = 0; i < n; i++)
     {
       if (! isvector (X[i]) && X[i].numel () != size[i])
-        {
-          error ("interpn: incompatible size of argument number %d", i+1);
-          return retval;
-        }
-      else
-        x[i] = X[i].data ();
+        error ("interpn: incompatible size of argument number %d", i+1);
+
+      x[i] = X[i].data ();
     }
 
   lin_interpn (n, size, scale, Ni, extrapval, x, v, y, vi);
 
   retval = Vi;
 
   return retval;
 }
@@ -291,20 +283,17 @@ Undocumented internal function.\n\
       const FloatNDArray V = args(n).float_array_value ();
 
       for (int i = 0; i < n; i++)
         {
           X[i] = args(i).float_array_value ();
           Y[i] = args(n+i+1).float_array_value ();
 
           if (Y[0].dims () != Y[i].dims ())
-            {
-              error ("interpn: incompatible size of argument number %d", n+i+2);
-              return retval;
-            }
+            error ("interpn: incompatible size of argument number %d", n+i+2);
         }
 
       retval = lin_interpn<float, FloatNDArray> (n, X, V, Y);
     }
   else
     {
       OCTAVE_LOCAL_BUFFER (NDArray, X, n);
       OCTAVE_LOCAL_BUFFER (NDArray, Y, n);
@@ -312,20 +301,17 @@ Undocumented internal function.\n\
       const NDArray V = args(n).array_value ();
 
       for (int i = 0; i < n; i++)
         {
           X[i] = args(i).array_value ();
           Y[i] = args(n+i+1).array_value ();
 
           if (Y[0].dims () != Y[i].dims ())
-            {
-              error ("interpn: incompatible size of argument number %d", n+i+2);
-              return retval;
-            }
+            error ("interpn: incompatible size of argument number %d", n+i+2);
         }
 
       retval = lin_interpn<double, NDArray> (n, X, V, Y);
     }
 
   return retval;
 }
 
diff --git a/libinterp/corefcn/__pchip_deriv__.cc b/libinterp/corefcn/__pchip_deriv__.cc
--- a/libinterp/corefcn/__pchip_deriv__.cc
+++ b/libinterp/corefcn/__pchip_deriv__.cc
@@ -66,29 +66,23 @@ Undocumented internal function.\n\
       if (args(0).is_single_type () || args(1).is_single_type ())
         {
           FloatColumnVector xvec (args(0).float_vector_value ());
           FloatMatrix ymat (args(1).float_matrix_value ());
 
           octave_idx_type nx = xvec.numel ();
 
           if (nx < 2)
-            {
-              error ("__pchip_deriv__: X must be at least of length 2");
-              return retval;
-            }
+            error ("__pchip_deriv__: X must be at least of length 2");
 
           octave_idx_type nyr = ymat.rows ();
           octave_idx_type nyc = ymat.columns ();
 
           if (nx != (rows ? nyc : nyr))
-            {
-              error ("__pchip_deriv__: X and Y dimension mismatch");
-              return retval;
-            }
+            error ("__pchip_deriv__: X and Y dimension mismatch");
 
           FloatMatrix dmat (nyr, nyc);
 
           octave_idx_type ierr;
           const octave_idx_type incfd = rows ? nyr : 1;
           volatile const octave_idx_type inc = rows ? 1 : nyr;
           volatile octave_idx_type k = 0;
 
@@ -97,45 +91,36 @@ Undocumented internal function.\n\
               F77_XFCN (pchim, PCHIM, (nx, xvec.data (),
                                        ymat.data () + k * inc,
                                        dmat.fortran_vec () + k * inc,
                                        incfd, &ierr));
 
               k++;
 
               if (ierr < 0)
-                {
-                  error ("__pchip_deriv__: PCHIM failed with ierr = %i", ierr);
-                  return retval;
-                }
+                error ("__pchip_deriv__: PCHIM failed with ierr = %i", ierr);
             }
 
           retval = dmat;
         }
       else
         {
           ColumnVector xvec (args(0).vector_value ());
           Matrix ymat (args(1).matrix_value ());
 
           octave_idx_type nx = xvec.numel ();
 
           if (nx < 2)
-            {
-              error ("__pchip_deriv__: X must be at least of length 2");
-              return retval;
-            }
+            error ("__pchip_deriv__: X must be at least of length 2");
 
           octave_idx_type nyr = ymat.rows ();
           octave_idx_type nyc = ymat.columns ();
 
           if (nx != (rows ? nyc : nyr))
-            {
-              error ("__pchip_deriv__: X and Y dimension mismatch");
-              return retval;
-            }
+            error ("__pchip_deriv__: X and Y dimension mismatch");
 
           Matrix dmat (nyr, nyc);
 
           octave_idx_type ierr;
           const octave_idx_type incfd = rows ? nyr : 1;
           volatile const octave_idx_type inc = rows ? 1 : nyr;
           volatile octave_idx_type k = 0;
 
@@ -143,20 +128,17 @@ Undocumented internal function.\n\
             {
               F77_XFCN (dpchim, DPCHIM, (nx, xvec.data (),
                                          ymat.data () + k * inc,
                                          dmat.fortran_vec () + k * inc,
                                          incfd, &ierr));
               k++;
 
               if (ierr < 0)
-                {
-                  error ("__pchip_deriv__: DPCHIM failed with ierr = %i", ierr);
-                  return retval;
-                }
+                error ("__pchip_deriv__: DPCHIM failed with ierr = %i", ierr);
             }
 
           retval = dmat;
         }
     }
 
   return retval;
 }
diff --git a/libinterp/corefcn/besselj.cc b/libinterp/corefcn/besselj.cc
--- a/libinterp/corefcn/besselj.cc
+++ b/libinterp/corefcn/besselj.cc
@@ -102,20 +102,17 @@ do_bessel (enum bessel_type type, const 
           if (opt_val != 0.0 && opt_val != 1.0)
             rpt_error = true;
           scaled = (opt_val == 1.0);
         }
       else if (opt_arg.is_bool_type ())
         scaled = opt_arg.bool_value ();
 
       if (rpt_error)
-        {
-          error ("%s: OPT must be 0 (or false) or 1 (or true)", fn);
-          return retval;
-        }
+        error ("%s: OPT must be 0 (or false) or 1 (or true)", fn);
     }
 
   octave_value alpha_arg = args(0);
   octave_value x_arg = args(1);
 
   if (alpha_arg.is_single_type () || x_arg.is_single_type ())
     {
       if (alpha_arg.is_scalar_type ())
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -243,34 +243,24 @@ get_mapper_fun_options (const octave_val
             }
           else if (args(nargin-1).is_string ())
             {
               std::string err_name = args(nargin-1).string_value ();
 
               error_handler = symbol_table::find_function (err_name);
 
               if (error_handler.is_undefined ())
-                {
-                  error ("cellfun: invalid function NAME: %s",
-                         err_name.c_str ());
-                  break;
-                }
+                error ("cellfun: invalid function NAME: %s",
+                       err_name.c_str ());
             }
           else
-            {
-              error ("cellfun: invalid value for 'ErrorHandler' function");
-              break;
-            }
+            error ("cellfun: invalid value for 'ErrorHandler' function");
         }
       else
-        {
-          error ("cellfun: unrecognized parameter %s",
-                 arg.c_str ());
-          break;
-        }
+        error ("cellfun: unrecognized parameter %s", arg.c_str ());
 
       nargin -= 2;
     }
 
   nargin -= 1;
 }
 
 DEFUN (cellfun, args, nargout,
@@ -531,40 +521,34 @@ v = cellfun (@@det, a); # faster\n\
       dim_vector fdims (1, 1);
 
       // Collect arguments.  Pre-fill scalar elements of inputlist
       // array.
 
       for (int j = 0; j < nargin; j++)
         {
           if (! args(j+1).is_cell ())
-            {
-              error ("cellfun: arguments must be cells");
-              return octave_value_list ();
-            }
+            error ("cellfun: arguments must be cells");
 
           inputs[j] = args(j+1).cell_value ();
           mask[j] = inputs[j].numel () != 1;
           if (! mask[j])
             inputlist(j) = cinputs[j](0);
         }
 
       for (int j = 0; j < nargin; j++)
         {
           if (mask[j])
             {
               fdims = inputs[j].dims ();
               k = inputs[j].numel ();
               for (int i = j+1; i < nargin; i++)
                 {
                   if (mask[i] && inputs[i].dims () != fdims)
-                    {
-                      error ("cellfun: dimensions mismatch");
-                      return octave_value_list ();
-                    }
+                    error ("cellfun: dimensions mismatch");
                 }
               break;
             }
         }
 
       unwind_protect frame;
       frame.protect_var (buffer_error_messages);
 
@@ -589,20 +573,17 @@ v = cellfun (@@det, a); # faster\n\
                     inputlist.xelem (j) = cinputs[j](count);
                 }
 
               const octave_value_list tmp
                 = get_output_list (count, nargout, inputlist, func,
                                    error_handler);
 
               if (nargout > 0 && tmp.length () < nargout)
-                {
-                  error ("cellfun: function returned fewer than nargout values");
-                  return retval;
-                }
+                error ("cellfun: function returned fewer than nargout values");
 
               if  (nargout > 0
                    || (nargout == 0
                        && tmp.length () > 0 && tmp(0).is_defined ()))
                 {
                   int num_to_copy = tmp.length ();
 
                   if (num_to_copy > nargout1)
@@ -614,20 +595,17 @@ v = cellfun (@@det, a); # faster\n\
                         {
                           if (tmp(j).is_defined ())
                             {
                               octave_value val = tmp(j);
 
                               if (val.numel () == 1)
                                 retv[j] = val.resize (fdims);
                               else
-                                {
-                                  error ("cellfun: all values must be scalars when UniformOutput = true");
-                                  break;
-                                }
+                                error ("cellfun: all values must be scalars when UniformOutput = true");
                             }
                         }
                     }
                   else
                     {
                       for (int j = 0; j < num_to_copy; j++)
                         {
                           if (tmp(j).is_defined ())
@@ -638,20 +616,17 @@ v = cellfun (@@det, a); # faster\n\
                                 {
                                   if (val.numel () == 1)
                                     {
                                       idx_list.front ()(0) = count + 1.0;
                                       retv[j].assign (octave_value::op_asn_eq,
                                                       idx_type, idx_list, val);
                                     }
                                   else
-                                    {
-                                      error ("cellfun: all values must be scalars when UniformOutput = true");
-                                      break;
-                                    }
+                                    error ("cellfun: all values must be scalars when UniformOutput = true");
                                 }
                             }
                         }
                     }
                 }
             }
 
           retval.resize (nargout1);
@@ -681,20 +656,17 @@ v = cellfun (@@det, a); # faster\n\
                     inputlist.xelem (j) = cinputs[j](count);
                 }
 
               const octave_value_list tmp
                 = get_output_list (count, nargout, inputlist, func,
                                    error_handler);
 
               if (nargout > 0 && tmp.length () < nargout)
-                {
-                  error ("cellfun: function returned fewer than nargout values");
-                  return retval;
-                }
+                error ("cellfun: function returned fewer than nargout values");
 
               if  (nargout > 0
                    || (nargout == 0
                        && tmp.length () > 0 && tmp(0).is_defined ()))
                 {
                   int num_to_copy = tmp.length ();
 
                   if (num_to_copy > nargout1)
@@ -1676,25 +1648,20 @@ do_num2cell_helper (const dim_vector& dv
 
   OCTAVE_LOCAL_BUFFER_INIT (bool, sing, maxd, false);
 
   perm.clear (maxd, 1);
   for (int i = 0; i < dvl; i++)
     {
       int k = dimv(i) - 1;
       if (k < 0)
-        {
-          error ("num2cell: dimension indices must be positive");
-          return;
-        }
-      else if (i > 0 && k < dimv(i-1) - 1)
-        {
-          error ("num2cell: dimension indices must be strictly increasing");
-          return;
-        }
+        error ("num2cell: dimension indices must be positive");
+
+      if (i > 0 && k < dimv(i-1) - 1)
+        error ("num2cell: dimension indices must be strictly increasing");
 
       sing[k] = true;
       perm(i) = k;
     }
 
   for (int k = 0, i = dvl; k < maxd; k++)
     if (! sing[k])
       perm(i++) = k;
@@ -1794,19 +1761,17 @@ do_object2cell (const octave_value& obj,
           octave_quit ();
 
           idx(0) = double (i+1);
 
           retval.xelem (i) = array.single_subsref ("(", idx);
         }
     }
   else
-    {
-      error ("num2cell (A, dim) not implemented for class objects");
-    }
+    error ("num2cell (A, dim) not implemented for class objects");
 
   return retval;
 }
 
 DEFUN (num2cell, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{C} =} num2cell (@var{A})\n\
 @deftypefnx {Built-in Function} {@var{C} =} num2cell (@var{A}, @var{dim})\n\
@@ -1922,21 +1887,17 @@ mat2cell_mismatch (const dim_vector& dv,
     {
       octave_idx_type s = 0;
       for (octave_idx_type j = 0; j < d[i].numel (); j++)
         s += d[i](j);
 
       octave_idx_type r = i < dv.length () ? dv(i) : 1;
 
       if (s != r)
-        {
-          error ("mat2cell: mismatch on %d-th dimension (%d != %d)",
-                 i+1, r, s);
-          return true;
-        }
+        error ("mat2cell: mismatch on %d-th dimension (%d != %d)", i+1, r, s);
     }
 
   return false;
 }
 
 template<class container>
 static void
 prepare_idx (container *idx, int idim, int nd,
@@ -2188,20 +2149,17 @@ mat2cell (reshape (1:16,4,4), [3,1], [3,
   OCTAVE_LOCAL_BUFFER (Array<octave_idx_type>, d, nargin-1);
 
   for (int i = 1; i < nargin; i++)
     d[i-1] = args(i).octave_idx_type_vector_value (true);
 
   octave_value a = args(0);
   bool sparse = a.is_sparse_type ();
   if (sparse && nargin > 3)
-    {
-      error ("mat2cell: sparse arguments only support 2-D indexing");
-      return retval;
-    }
+    error ("mat2cell: sparse arguments only support 2-D indexing");
 
   switch (a.builtin_type ())
     {
     case btyp_double:
       {
         if (sparse)
           retval = do_mat2cell_2d (a.sparse_matrix_value (), d, nargin-1);
         else
@@ -2324,18 +2282,16 @@ endfor\n\
 @end group\n\
 @end example\n\
 \n\
 The position of the index is determined by @var{dim}.  If not specified,\n\
 slicing is done along the first non-singleton dimension.\n\
 @seealso{cell2mat, cellindexmat, cellfun}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   if (nargin < 3 || nargin > 4)
     print_usage ();
 
   octave_value x = args(0);
   Array<octave_idx_type> lb = args(1).octave_idx_type_vector_value ();
   Array<octave_idx_type> ub = args(2).octave_idx_type_vector_value ();
@@ -2344,96 +2300,92 @@ slicing is done along the first non-sing
     {
       dim = args(3).int_value () - 1;
       if (dim < 0)
         error ("cellslices: DIM must be a valid dimension");
     }
 
   if (lb.numel () != ub.numel ())
     error ("cellslices: the lengths of LB and UB must match");
-  else
+
+  Cell retcell;
+  if (! x.is_sparse_type () && x.is_matrix_type ())
     {
-      Cell retcell;
-      if (! x.is_sparse_type () && x.is_matrix_type ())
+      // specialize for some dense arrays.
+      if (x.is_bool_type ())
+        retcell = do_cellslices_nda (x.bool_array_value (),
+                                     lb, ub, dim);
+      else if (x.is_char_matrix ())
+        retcell = do_cellslices_nda (x.char_array_value (),
+                                     lb, ub, dim);
+      else if (x.is_integer_type ())
         {
-          // specialize for some dense arrays.
-          if (x.is_bool_type ())
-            retcell = do_cellslices_nda (x.bool_array_value (),
+          if (x.is_int8_type ())
+            retcell = do_cellslices_nda (x.int8_array_value (),
                                          lb, ub, dim);
-          else if (x.is_char_matrix ())
-            retcell = do_cellslices_nda (x.char_array_value (),
+          else if (x.is_int16_type ())
+            retcell = do_cellslices_nda (x.int16_array_value (),
+                                         lb, ub, dim);
+          else if (x.is_int32_type ())
+            retcell = do_cellslices_nda (x.int32_array_value (),
                                          lb, ub, dim);
-          else if (x.is_integer_type ())
-            {
-              if (x.is_int8_type ())
-                retcell = do_cellslices_nda (x.int8_array_value (),
-                                             lb, ub, dim);
-              else if (x.is_int16_type ())
-                retcell = do_cellslices_nda (x.int16_array_value (),
-                                             lb, ub, dim);
-              else if (x.is_int32_type ())
-                retcell = do_cellslices_nda (x.int32_array_value (),
-                                             lb, ub, dim);
-              else if (x.is_int64_type ())
-                retcell = do_cellslices_nda (x.int64_array_value (),
-                                             lb, ub, dim);
-              else if (x.is_uint8_type ())
-                retcell = do_cellslices_nda (x.uint8_array_value (),
-                                             lb, ub, dim);
-              else if (x.is_uint16_type ())
-                retcell = do_cellslices_nda (x.uint16_array_value (),
-                                             lb, ub, dim);
-              else if (x.is_uint32_type ())
-                retcell = do_cellslices_nda (x.uint32_array_value (),
-                                             lb, ub, dim);
-              else if (x.is_uint64_type ())
-                retcell = do_cellslices_nda (x.uint64_array_value (),
-                                             lb, ub, dim);
-            }
-          else if (x.is_complex_type ())
-            {
-              if (x.is_single_type ())
-                retcell = do_cellslices_nda (x.float_complex_array_value (),
-                                             lb, ub, dim);
-              else
-                retcell = do_cellslices_nda (x.complex_array_value (),
-                                             lb, ub, dim);
-            }
+          else if (x.is_int64_type ())
+            retcell = do_cellslices_nda (x.int64_array_value (),
+                                         lb, ub, dim);
+          else if (x.is_uint8_type ())
+            retcell = do_cellslices_nda (x.uint8_array_value (),
+                                         lb, ub, dim);
+          else if (x.is_uint16_type ())
+            retcell = do_cellslices_nda (x.uint16_array_value (),
+                                         lb, ub, dim);
+          else if (x.is_uint32_type ())
+            retcell = do_cellslices_nda (x.uint32_array_value (),
+                                         lb, ub, dim);
+          else if (x.is_uint64_type ())
+            retcell = do_cellslices_nda (x.uint64_array_value (),
+                                         lb, ub, dim);
+        }
+      else if (x.is_complex_type ())
+        {
+          if (x.is_single_type ())
+            retcell = do_cellslices_nda (x.float_complex_array_value (),
+                                         lb, ub, dim);
           else
-            {
-              if (x.is_single_type ())
-                retcell = do_cellslices_nda (x.float_array_value (),
-                                             lb, ub, dim);
-              else
-                retcell = do_cellslices_nda (x.array_value (),
-                                             lb, ub, dim);
-            }
+            retcell = do_cellslices_nda (x.complex_array_value (),
+                                         lb, ub, dim);
         }
       else
         {
-          // generic code.
-          octave_idx_type n = lb.numel ();
-          retcell = Cell (1, n);
-          const dim_vector dv = x.dims ();
-          int ndims = dv.length ();
-          if (dim < 0)
-            dim = dv.first_non_singleton ();
-          ndims = std::max (ndims, dim + 1);
-          octave_value_list idx (ndims, octave_value::magic_colon_t);
-          for (octave_idx_type i = 0; i < n; i++)
-            {
-              idx(dim) = Range (lb(i), ub(i));
-              retcell(i) = x.do_index_op (idx);
-            }
+          if (x.is_single_type ())
+            retcell = do_cellslices_nda (x.float_array_value (),
+                                         lb, ub, dim);
+          else
+            retcell = do_cellslices_nda (x.array_value (),
+                                         lb, ub, dim);
         }
-
-      retval = retcell;
+    }
+  else
+    {
+      // generic code.
+      octave_idx_type n = lb.numel ();
+      retcell = Cell (1, n);
+      const dim_vector dv = x.dims ();
+      int ndims = dv.length ();
+      if (dim < 0)
+        dim = dv.first_non_singleton ();
+      ndims = std::max (ndims, dim + 1);
+      octave_value_list idx (ndims, octave_value::magic_colon_t);
+      for (octave_idx_type i = 0; i < n; i++)
+        {
+          idx(dim) = Range (lb(i), ub(i));
+          retcell(i) = x.do_index_op (idx);
+        }
     }
 
-  return retval;
+  return octave_value (retcell);
 }
 
 /*
 %!test
 %! m = [1, 2, 3, 4; 5, 6, 7, 8; 9, 10, 11, 12];
 %! c = cellslices (m, [1, 2], [2, 3], 2);
 %! assert (c, {[1, 2; 5, 6; 9, 10], [2, 3; 6, 7; 10, 11]});
 */
diff --git a/libinterp/corefcn/colloc.cc b/libinterp/corefcn/colloc.cc
--- a/libinterp/corefcn/colloc.cc
+++ b/libinterp/corefcn/colloc.cc
@@ -76,28 +76,22 @@ Reference: @nospell{J. Villadsen}, @nosp
           right = 1;
         }
       else if ((s.length () == 1 && (s[0] == 'L' || s[0] == 'l'))
                || s == "left")
         {
           left = 1;
         }
       else
-        {
-          error ("colloc: string argument must be \"left\" or \"right\"");
-          return retval;
-        }
+        error ("colloc: string argument must be \"left\" or \"right\"");
     }
 
   ntot += left + right;
   if (ntot < 1)
-    {
-      error ("colloc: the total number of roots must be positive");
-      return retval;
-    }
+    error ("colloc: the total number of roots must be positive");
 
   CollocWt wts (ncol, left, right);
 
   ColumnVector r = wts.roots ();
   Matrix A = wts.first ();
   Matrix B = wts.second ();
   ColumnVector q = wts.quad_weights ();
 
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -220,27 +220,24 @@ parse_dbfunction_params (const char *who
         {
           // It was a line number.  Need to get function name from debugger.
           if (Vdebugging)
             {
               symbol_name = get_user_code ()->name ();
               idx = 0;
             }
           else
-            {
-              error ("%s: no function specified", who);
-            }
+            error ("%s: no function specified", who);
         }
     }
   else if (args(0).is_map ())
     {
       // This is a problem because parse_dbfunction_params()
       // can only pass out a single function.
       error ("%s: struct input not implemented", who);
-      return;
     }
   else
     error ("%s: invalid parameter specified", who);
 
   for (int i = idx; i < args.length (); i++)
     {
       if (args(i).is_string ())
         {
@@ -273,20 +270,17 @@ bp_table::instance_ok (void)
     {
       instance = new bp_table ();
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
-    {
-      error ("unable to create breakpoint table!");
-      retval = false;
-    }
+    error ("unable to create breakpoint table!");
 
   return retval;
 }
 
 bool
 bp_table::do_add_breakpoint_1 (octave_user_code *fcn,
                                const std::string& fname,
                                const bp_table::intmap& line,
@@ -728,20 +722,17 @@ current function.\n\
 {
   octave_map retval;
   int nargin = args.length ();
   octave_value_list fcn_list;
   bp_table::fname_line_map bp_list;
   std::string symbol_name;
 
   if (nargin != 0 && nargin != 1)
-    {
-      error ("dbstatus: only zero or one arguments accepted\n");
-      return octave_value ();
-    }
+    error ("dbstatus: only zero or one arguments accepted\n");
 
   if (nargin == 1)
     {
       if (args(0).is_string ())
         {
           symbol_name = args(0).string_value ();
           fcn_list(0) = symbol_name;
           bp_list = bp_table::get_breakpoint_list (fcn_list);
@@ -956,20 +947,17 @@ numbers.\n\
                 int start, end;
                 start = atoi (start_str.c_str ());
                 if (end_str == "end")
                   end = std::numeric_limits<int>::max ();
                 else
                   end = atoi (end_str.c_str ());
 
                 if (std::min (start, end) <= 0)
-                  {
-                    error ("dbtype: start and end lines must be >= 1\n");
-                    break;
-                  }
+                  error ("dbtype: start and end lines must be >= 1\n");
 
                 if (start <= end)
                   do_dbtype (octave_stdout, dbg_fcn->fcn_file_name (),
                              start, end);
                 else
                   error ("dbtype: start line must be less than end line\n");
               }
           }
@@ -985,20 +973,17 @@ numbers.\n\
                   do_dbtype (octave_stdout, dbg_fcn->fcn_file_name (),
                              0, std::numeric_limits<int>::max ());
                 else
                   error ("dbtype: function <%s> not found\n", arg.c_str ());
               }
             else  // (dbtype lineno)
               {
                 if (line <= 0)
-                  {
-                    error ("dbtype: start and end lines must be >= 1\n");
-                    break;
-                  }
+                  error ("dbtype: start and end lines must be >= 1\n");
 
                 dbg_fcn = get_user_code ();
 
                 if (dbg_fcn)
                   do_dbtype (octave_stdout, dbg_fcn->fcn_file_name (),
                              line, line);
               }
           }
@@ -1027,20 +1012,17 @@ numbers.\n\
             }
           else
             {
               start = atoi (arg.c_str ());
               end = start;
             }
 
           if (std::min (start, end) <= 0)
-            {
-              error ("dbtype: start and end lines must be >= 1\n");
-              break;
-            }
+            error ("dbtype: start and end lines must be >= 1\n");
 
           if (start <= end)
             do_dbtype (octave_stdout, dbg_fcn->fcn_file_name (),
                        start, end);
           else
             error ("dbtype: start line must be less than end line\n");
         }
       else
diff --git a/libinterp/corefcn/dlmread.cc b/libinterp/corefcn/dlmread.cc
--- a/libinterp/corefcn/dlmread.cc
+++ b/libinterp/corefcn/dlmread.cc
@@ -213,40 +213,31 @@ fill empty fields.  The default is zero.
       // Filename.
       std::string fname (args(0).string_value ());
 
       std::string tname = file_ops::tilde_expand (fname);
 
       input_file.open (tname.c_str (), std::ios::in);
 
       if (! input_file)
-        {
-          error ("dlmread: unable to open file '%s'", fname.c_str ());
-          return retval;
-        }
-      else
-        input = &input_file;
+        error ("dlmread: unable to open file '%s'", fname.c_str ());
+
+      input = &input_file;
     }
   else if (args(0).is_scalar_type ())
     {
       octave_stream is = octave_stream_list::lookup (args(0), "dlmread");
 
       input = is.input_stream ();
 
       if (! input)
-        {
-          error ("dlmread: stream FILE not open for input");
-          return retval;
-        }
+        error ("dlmread: stream FILE not open for input");
     }
   else
-    {
-      error ("dlmread: FILE argument must be a string or file id");
-      return retval;
-    }
+    error ("dlmread: FILE argument must be a string or file id");
 
   // Set default separator.
   std::string sep;
   if (nargin > 1)
     {
       if (args(1).is_sq_string ())
         sep = do_string_escapes (args(1).string_value ());
       else
diff --git a/libinterp/corefcn/dynamic-ld.cc b/libinterp/corefcn/dynamic-ld.cc
--- a/libinterp/corefcn/dynamic-ld.cc
+++ b/libinterp/corefcn/dynamic-ld.cc
@@ -154,21 +154,17 @@ octave_shlib_list::instance_ok (void)
     {
       instance = new octave_shlib_list ();
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
-    {
-      error ("unable to create shared library list object!");
-
-      retval = false;
-    }
+    error ("unable to create shared library list object!");
 
   return retval;
 }
 
 void
 octave_shlib_list::append (const octave_shlib& shl)
 {
   if (instance_ok ())
@@ -210,21 +206,18 @@ octave_dynamic_loader::instance_ok (void
     {
       instance = new octave_dynamic_loader ();
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
-    {
-      error ("unable to create dynamic loader object!");
+    error ("unable to create dynamic loader object!");
 
-      retval = false;
-    }
 
   return retval;
 }
 
 static void
 do_clear_function (const std::string& fcn_name)
 {
   warning_with_id ("Octave:reload-forces-clear", "  %s", fcn_name.c_str ());
diff --git a/libinterp/corefcn/filter.cc b/libinterp/corefcn/filter.cc
--- a/libinterp/corefcn/filter.cc
+++ b/libinterp/corefcn/filter.cc
@@ -71,60 +71,42 @@ filter (MArray<T>& b, MArray<T>& a, MArr
   //        necessary to stop bug #33164.
   b.resize (dim_vector (ab_len, 1), 0.0);
   if (a_len > 1)
     a.resize (dim_vector (ab_len, 1), 0.0);
 
   T norm = a (0);
 
   if (norm == static_cast<T> (0.0))
-    {
-      error ("filter: the first element of A must be nonzero");
-      return y;
-    }
+    error ("filter: the first element of A must be nonzero");
 
   dim_vector x_dims = x.dims ();
   if (dim < 0 || dim > x_dims.length ())
-    {
-      error ("filter: DIM must be a valid dimension");
-      return y;
-    }
+    error ("filter: DIM must be a valid dimension");
 
   octave_idx_type x_len = x_dims(dim);
 
   dim_vector si_dims = si.dims ();
   octave_idx_type si_len = si_dims(0);
 
   if (si_len != ab_len - 1)
-    {
-      error ("filter: first dimension of SI must be of length max (length (a), length (b)) - 1");
-      return y;
-    }
+    error ("filter: first dimension of SI must be of length max (length (a), length (b)) - 1");
 
   if (si_dims.length () != x_dims.length ())
-    {
-      error ("filter: dimensionality of SI and X must agree");
-      return y;
-    }
+    error ("filter: dimensionality of SI and X must agree");
 
   for (octave_idx_type i = 1; i < dim; i++)
     {
       if (si_dims(i) != x_dims(i-1))
-        {
-          error ("filter: dimensionality of SI and X must agree");
-          return y;
-        }
+        error ("filter: dimensionality of SI and X must agree");
     }
   for (octave_idx_type i = dim+1; i < x_dims.length (); i++)
     {
       if (si_dims(i) != x_dims(i))
-        {
-          error ("filter: dimensionality of SI and X must agree");
-          return y;
-        }
+        error ("filter: dimensionality of SI and X must agree");
     }
 
   if (x_len == 0)
     return x;
 
   if (norm != static_cast<T> (1.0))
     {
       a /= norm;
@@ -265,20 +247,17 @@ filter (MArray<T>& b, MArray<T>& a, MArr
       while (dim < x_dims.length () && x_dims(dim) <= 1)
         dim++;
 
       // All dimensions singleton, pick first dimension
       if (dim == x_dims.length ())
         dim = 0;
     }
   else if (dim < 0 || dim > x_dims.length ())
-    {
-      error ("filter: DIM must be a valid dimension");
-      return MArray<T> ();
-    }
+    error ("filter: DIM must be a valid dimension");
 
   octave_idx_type a_len = a.numel ();
   octave_idx_type b_len = b.numel ();
 
   octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
   dim_vector si_dims = x.dims ();
   for (int i = dim; i > 0; i--)
     si_dims(i) = si_dims(i-1);
@@ -404,20 +383,17 @@ H(z) = ---------------------\n\
 
   int dim;
   dim_vector x_dims = args(2).dims ();
 
   if (nargin == 5)
     {
       dim = args(4).nint_value () - 1;
       if (dim < 0 || dim >= x_dims.length ())
-        {
-          error ("filter: DIM must be a valid dimension");
-          return retval;
-        }
+        error ("filter: DIM must be a valid dimension");
     }
   else
     {
       // Find first non-singleton dimension
       dim = 0;
       while (dim < x_dims.length () && x_dims(dim) <= 1)
         dim++;
 
diff --git a/libinterp/corefcn/find.cc b/libinterp/corefcn/find.cc
--- a/libinterp/corefcn/find.cc
+++ b/libinterp/corefcn/find.cc
@@ -411,20 +411,17 @@ b = sparse (i, j, v, sz(1), sz(2));\n\
       std::string s_arg = args(2).string_value ();
 
       if (s_arg == "first")
         direction = 1;
       else if (s_arg == "last")
         direction = -1;
 
       if (direction == 0)
-        {
-          error ("find: DIRECTION must be \"first\" or \"last\"");
-          return retval;
-        }
+        error ("find: DIRECTION must be \"first\" or \"last\"");
     }
 
   octave_value arg = args(0);
 
   if (arg.is_bool_type ())
     {
       if (arg.is_sparse_type ())
         {
diff --git a/libinterp/corefcn/gl2ps-renderer.cc b/libinterp/corefcn/gl2ps-renderer.cc
--- a/libinterp/corefcn/gl2ps-renderer.cc
+++ b/libinterp/corefcn/gl2ps-renderer.cc
@@ -62,20 +62,17 @@ glps_renderer::draw (const graphics_obje
         gl2ps_term = GL2PS_PS;
       else if (term.find ("svg") != std::string::npos)
         gl2ps_term = GL2PS_SVG;
       else if (term.find ("pgf") != std::string::npos)
         gl2ps_term = GL2PS_PGF;
       else if (term.find ("tex") != std::string::npos)
         gl2ps_term = GL2PS_TEX;
       else
-        {
-          error ("gl2ps-renderer::draw: Unknown terminal %s", term.c_str ());
-          return;
-        }
+        error ("gl2ps-renderer::draw: Unknown terminal %s", term.c_str ());
 
       GLint gl2ps_text = 0;
       if (term.find ("notxt") != std::string::npos)
         gl2ps_text = GL2PS_NO_TEXT;
 
       // Default sort order optimizes for 3D plots
       GLint gl2ps_sort = GL2PS_BSP_SORT;
 
@@ -126,34 +123,32 @@ glps_renderer::draw (const graphics_obje
                                        | GL2PS_NO_PS3_SHADING
                                        | GL2PS_USE_CURRENT_VIEWPORT),
                                       GL_RGBA, 0, 0, 0, 0, 0,
                                       buffsize, fp, include_graph.c_str ());
           if (ret == GL2PS_ERROR)
             {
               old_print_cmd.clear ();
               error ("gl2ps-renderer::draw: gl2psBeginPage returned GL2PS_ERROR");
-              return;
             }
 
           old_print_cmd = print_cmd;
 
           opengl_renderer::draw (go);
 
           // Without glFinish () there may be primitives missing in the
           // gl2ps output.
           glFinish ();
 
           state = gl2psEndPage ();
 
           if (state == GL2PS_ERROR)
             {
               old_print_cmd.clear ();
               error ("gl2ps-renderer::draw: gl2psEndPage returned GL2PS_ERROR");
-              return;
             }
 
           // Don't check state for GL2PS_UNINITIALIZED (should never happen)
           // GL2PS_OVERFLOW (see while loop) or GL2PS_SUCCESS
         }
     }
   else
     opengl_renderer::draw (go);
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -330,21 +330,17 @@ load_path::instance_ok (void)
     {
       instance = new load_path ();
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
-    {
-      error ("unable to create load path object!");
-
-      retval = false;
-    }
+    error ("unable to create load path object!");
 
   return retval;
 }
 
 // FIXME: maybe we should also maintain a map to speed up this method of access.
 
 load_path::const_dir_info_list_iterator
 load_path::find_dir_info (const std::string& dir_arg) const
@@ -2446,20 +2442,17 @@ addpath (\"dir1:/dir2:~/dir3\")\n\
       if (val == 0)
         nargin--;
       else if (val == 1)
         {
           append = true;
           nargin--;
         }
       else
-        {
-          error ("addpath: OPTION must be '-begin'/0 or '-end'/1");
-          return retval;
-        }
+        error ("addpath: OPTION must be '-begin'/0 or '-end'/1");
     }
 
   bool need_to_update = false;
 
   for (int i = 0; i < nargin; i++)
     {
       std::string arg = args(i).xstring_value ("addpath: all arguments must be strings");
 
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -184,16 +184,17 @@ read_binary_file_header (std::istream& i
   if (strncmp (magic, "Octave-1-L", magic_len) == 0)
     swap = oct_mach_info::words_big_endian ();
   else if (strncmp (magic, "Octave-1-B", magic_len) == 0)
     swap = ! oct_mach_info::words_big_endian ();
   else
     {
       if (! quiet)
         error ("load: unable to read read binary file");
+
       return -1;
     }
 
   char tmp = 0;
   is.read (&tmp, 1);
 
   flt_fmt = mopt_digit_to_float_format (tmp);
 
@@ -692,17 +693,16 @@ Force Octave to assume the file is in Oc
           format = LS_MAT_BINARY;
         }
       else if (argv[i] == "-hdf5" || argv[i] == "-h")
         {
 #ifdef HAVE_HDF5
           format = LS_HDF5;
 #else /* ! HAVE_HDF5 */
           error ("load: octave executable was not linked with HDF5 library");
-          return retval;
 #endif /* ! HAVE_HDF5 */
         }
       else if (argv[i] == "-import" || argv[i] == "-i")
         {
           warning ("load: -import ignored");
         }
       else if (argv[i] == "-text" || argv[i] == "-t")
         {
@@ -1269,37 +1269,28 @@ save_vars (const string_vector& argv, in
 
   if (argv_idx == argc)
     {
       save_vars (os, "*", fmt, save_as_floats);
     }
   else if (argv[argv_idx] == "-struct")
     {
       if (++argv_idx >= argc)
-        {
-          error ("save: missing struct name");
-          return;
-        }
+        error ("save: missing struct name");
 
       std::string struct_name = argv[argv_idx];
 
       if (! symbol_table::is_variable (struct_name))
-        {
-          error ("save: no such variable: '%s'", struct_name.c_str ());
-          return;
-        }
+        error ("save: no such variable: '%s'", struct_name.c_str ());
 
       octave_value struct_var = symbol_table::varval (struct_name);
 
       if (! struct_var.is_map () || struct_var.numel () != 1)
-        {
-          error ("save: '%s' is not a scalar structure",
-                 struct_name.c_str ());
-          return;
-        }
+        error ("save: '%s' is not a scalar structure", struct_name.c_str ());
+
       octave_scalar_map struct_var_map = struct_var.scalar_map_value ();
 
       ++argv_idx;
 
       if (argv_idx < argc)
         {
           for (int i = argv_idx; i < argc; i++)
             {
@@ -1615,20 +1606,17 @@ the file @file{data} in Octave's binary 
                              use_zlib);
   int argc = argv.numel ();
   int i = 0;
 
   if (i == argc)
     print_usage ();
 
   if (save_as_floats && format == LS_TEXT)
-    {
-      error ("save: cannot specify both -text and -float-binary");
-      return retval;
-    }
+    error ("save: cannot specify both -text and -float-binary");
 
   if (argv[i] == "-")
     {
       i++;
 
 #ifdef HAVE_HDF5
       if (format == LS_HDF5)
         error ("save: cannot write HDF5 format to stdout");
@@ -1677,20 +1665,17 @@ the file @file{data} in Octave's binary 
           || format == LS_MAT7_BINARY)
         mode |= std::ios::binary;
 
 #ifdef HAVE_HDF5
       if (format == LS_HDF5)
         {
           // FIXME: It should be possible to append to HDF5 files.
           if (append)
-            {
-              error ("save: appending to HDF5 files is not implemented");
-              return retval;
-            }
+            error ("save: appending to HDF5 files is not implemented");
 
           bool write_header_info
             = ! (append && H5Fis_hdf5 (fname.c_str ()) > 0);
 
           hdf5_ofstream hdf5_file (fname.c_str (), mode);
 
           if (hdf5_file.file_id != -1)
             {
diff --git a/libinterp/corefcn/ls-mat4.cc b/libinterp/corefcn/ls-mat4.cc
--- a/libinterp/corefcn/ls-mat4.cc
+++ b/libinterp/corefcn/ls-mat4.cc
@@ -161,16 +161,17 @@ read_mat_file_header (std::istream& is, 
       swap_bytes<4> (&imag);
       swap_bytes<4> (&len);
     }
 
   if (mopt > 9999 || mopt < 0 || imag > 1 || imag < 0)
     {
       if (! quiet)
         error ("load: can't read binary file");
+
       return -1;
     }
 
   return 0;
 
 data_read_error:
   return -1;
 }
@@ -272,26 +273,20 @@ read_mat_binary_data (std::istream& is, 
   mopt /= 10;        // Eliminate second digit.
   order = mopt % 10; // Row or column major ordering.
   mopt /= 10;        // Eliminate third digit.
   mach = mopt % 10;  // IEEE, VAX, etc.
 
   flt_fmt = mopt_digit_to_float_format (mach);
 
   if (flt_fmt == oct_mach_info::flt_fmt_unknown)
-    {
-      error ("load: unrecognized binary format!");
-      return retval;
-    }
+    error ("load: unrecognized binary format!");
 
   if (imag && type == 1)
-    {
-      error ("load: encountered complex matrix with string flag set!");
-      return retval;
-    }
+    error ("load: encountered complex matrix with string flag set!");
 
   // LEN includes the terminating character, and the file is also
   // supposed to include it, but apparently not all files do.  Either
   // way, I think this should work.
 
   {
     OCTAVE_LOCAL_BUFFER (char, name, len+1);
     name[len] = '\0';
@@ -369,33 +364,27 @@ read_mat_binary_data (std::istream& is, 
       }
     else
       {
         re.resize (nr, nc);
 
         read_mat_binary_data (is, re.fortran_vec (), prec, dlen, swap, flt_fmt);
 
         if (! is)
-          {
-            error ("load: reading matrix data for '%s'", name);
-            goto data_read_error;
-          }
+          error ("load: reading matrix data for '%s'", name);
 
         if (imag)
           {
             Matrix im (nr, nc);
 
             read_mat_binary_data (is, im.fortran_vec (), prec, dlen, swap,
                                   flt_fmt);
 
             if (! is)
-              {
-                error ("load: reading imaginary matrix data for '%s'", name);
-                goto data_read_error;
-              }
+              error ("load: reading imaginary matrix data for '%s'", name);
 
             ComplexMatrix ctmp (nr, nc);
 
             for (octave_idx_type j = 0; j < nc; j++)
               for (octave_idx_type i = 0; i < nr; i++)
                 ctmp (i, j) = Complex (re (i, j), im (i, j));
 
             tc = order ? ctmp.transpose () : ctmp;
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -371,57 +371,45 @@ read_mat5_integer_data (std::istream& is
 
 #define OCTAVE_MAT5_INTEGER_READ(TYP) \
   { \
         TYP re (dims); \
   \
         std::streampos tmp_pos; \
   \
         if (read_mat5_tag (is, swap, type, len, is_small_data_element)) \
-          { \
-            error ("load: reading matrix data for '%s'", retval.c_str ()); \
-            goto data_read_error; \
-          } \
+          error ("load: reading matrix data for '%s'", retval.c_str ()); \
   \
         octave_idx_type n = re.numel (); \
         tmp_pos = is.tellg (); \
         read_mat5_integer_data (is, re.fortran_vec (), n, swap, \
                                 static_cast<enum mat5_data_type> (type)); \
   \
         if (! is) \
-          { \
-            error ("load: reading matrix data for '%s'", retval.c_str ()); \
-            goto data_read_error; \
-          } \
+          error ("load: reading matrix data for '%s'", retval.c_str ()); \
   \
         is.seekg (tmp_pos + static_cast<std::streamoff>\
                   (READ_PAD (is_small_data_element, len))); \
   \
         if (imag) \
           { \
             /* We don't handle imag integer types, convert to an array */ \
             NDArray im (dims); \
   \
             if (read_mat5_tag (is, swap, type, len, is_small_data_element)) \
-              { \
-                error ("load: reading matrix data for '%s'", \
-                       retval.c_str ()); \
-                goto data_read_error; \
-              } \
+              error ("load: reading matrix data for '%s'", \
+                     retval.c_str ()); \
   \
             n = im.numel (); \
             read_mat5_binary_data (is, im.fortran_vec (), n, swap, \
                                    static_cast<enum mat5_data_type> (type), flt_fmt); \
   \
             if (! is) \
-              { \
-                error ("load: reading imaginary matrix data for '%s'", \
-                       retval.c_str ()); \
-                goto data_read_error; \
-              } \
+              error ("load: reading imaginary matrix data for '%s'", \
+                     retval.c_str ()); \
   \
             ComplexNDArray ctmp (dims); \
   \
             for (octave_idx_type i = 0; i < n; i++) \
               ctmp(i) = Complex (re(i).double_value (), im(i)); \
   \
             tc = ctmp;  \
           } \
@@ -614,35 +602,31 @@ read_mat5_binary_element (std::istream& 
     }
 
   std::streampos pos;
 
   if (type != miMATRIX)
     {
       pos = is.tellg ();
       error ("load: invalid element type = %d", type);
-      goto early_read_error;
     }
 
   if (element_length == 0)
     {
       tc = Matrix ();
       return retval;
     }
 
   pos = is.tellg ();
 
   // array flags subelement
   int32_t len;
   if (read_mat5_tag (is, swap, type, len, is_small_data_element)
       || type != miUINT32 || len != 8 || is_small_data_element)
-    {
-      error ("load: invalid array flags subelement");
-      goto early_read_error;
-    }
+    error ("load: invalid array flags subelement");
 
   int32_t flags;
   read_int (is, swap, flags);
 
   imag = (flags & 0x0800) != 0; // has an imaginary part?
 
   global = (flags & 0x0400) != 0; // global variable?
 
@@ -656,20 +640,17 @@ read_mat5_binary_element (std::istream& 
 
   // dimensions array subelement
   if (arrayclass != MAT_FILE_WORKSPACE_CLASS)
     {
       int32_t dim_len;
 
       if (read_mat5_tag (is, swap, type, dim_len, is_small_data_element)
           || type != miINT32)
-        {
-          error ("load: invalid dimensions array subelement");
-          goto early_read_error;
-        }
+        error ("load: invalid dimensions array subelement");
 
       int ndims = dim_len / 4;
       if (ndims == 1)
         {
           // R and Python can create a 1-D object which is really an Nx1 object
           dims.resize (2);
           dims(1) = 1;
         }
@@ -692,20 +673,17 @@ read_mat5_binary_element (std::istream& 
       // Why did mathworks decide to not have dims for a workspace!!!
       dims.resize (2);
       dims(0) = 1;
       dims(1) = 1;
     }
 
   if (read_mat5_tag (is, swap, type, len, is_small_data_element)
       || ! INT8(type))
-    {
-      error ("load: invalid array name subelement");
-      goto early_read_error;
-    }
+    error ("load: invalid array name subelement");
 
   {
     OCTAVE_LOCAL_BUFFER (char, name, len+1);
 
     // Structure field subelements have zero-length array name subelements.
 
     std::streampos tmp_pos = is.tellg ();
 
@@ -733,20 +711,17 @@ read_mat5_binary_element (std::istream& 
         for (octave_idx_type i = 0; i < n; i++)
           {
             octave_value tc2;
 
             std::string nm
               = read_mat5_binary_element (is, filename, swap, global, tc2);
 
             if (! is)
-              {
-                error ("load: reading cell data for '%s'", nm.c_str ());
-                goto data_read_error;
-              }
+              error ("load: reading cell data for '%s'", nm.c_str ());
 
             cell_array(i) = tc2;
           }
 
         tc = cell_array;
       }
       break;
 
@@ -775,111 +750,87 @@ read_mat5_binary_element (std::istream& 
             cidx = sm.cidx ();
             data = sm.data ();
           }
 
         // row indices
         std::streampos tmp_pos;
 
         if (read_mat5_tag (is, swap, type, len, is_small_data_element))
-          {
-            error ("load: reading sparse row data for '%s'", retval.c_str ());
-            goto data_read_error;
-          }
+          error ("load: reading sparse row data for '%s'", retval.c_str ());
 
         tmp_pos = is.tellg ();
 
         read_mat5_integer_data (is, ridx, nzmax, swap,
                                 static_cast<enum mat5_data_type> (type));
 
         if (! is)
-          {
-            error ("load: reading sparse row data for '%s'", retval.c_str ());
-            goto data_read_error;
-          }
+          error ("load: reading sparse row data for '%s'", retval.c_str ());
 
         is.seekg (tmp_pos + static_cast<std::streamoff>
                   (READ_PAD (is_small_data_element, len)));
 
         // col indices
         if (read_mat5_tag (is, swap, type, len, is_small_data_element))
-          {
-            error ("load: reading sparse column data for '%s'",
-                   retval.c_str ());
-            goto data_read_error;
-          }
+          error ("load: reading sparse column data for '%s'",
+                 retval.c_str ());
 
         tmp_pos = is.tellg ();
 
         read_mat5_integer_data (is, cidx, nc + 1, swap,
                                 static_cast<enum mat5_data_type> (type));
 
         if (! is)
-          {
-            error ("load: reading sparse column data for '%s'",
-                   retval.c_str ());
-            goto data_read_error;
-          }
+          error ("load: reading sparse column data for '%s'",
+                 retval.c_str ());
 
         is.seekg (tmp_pos + static_cast<std::streamoff>
                   (READ_PAD (is_small_data_element, len)));
 
         // real data subelement
         if (read_mat5_tag (is, swap, type, len, is_small_data_element))
-          {
-            error ("load: reading sparse matrix data for '%s'",
-                   retval.c_str ());
-            goto data_read_error;
-          }
+          error ("load: reading sparse matrix data for '%s'",
+                 retval.c_str ());
 
         octave_idx_type nnz = cidx[nc];
         NDArray re;
         if (imag)
           {
             re = NDArray (dim_vector (nnz, 1));
             data = re.fortran_vec ();
           }
 
         tmp_pos = is.tellg ();
         read_mat5_binary_data (is, data, nnz, swap,
                                static_cast<enum mat5_data_type> (type),
                                flt_fmt);
 
         if (! is)
-          {
-            error ("load: reading sparse matrix data for '%s'",
-                   retval.c_str ());
-            goto data_read_error;
-          }
+          error ("load: reading sparse matrix data for '%s'",
+                 retval.c_str ());
 
         is.seekg (tmp_pos + static_cast<std::streamoff>
                   (READ_PAD (is_small_data_element, len)));
 
         // imaginary data subelement
         if (imag)
           {
             NDArray im (dim_vector (static_cast<int> (nnz), 1));
 
             if (read_mat5_tag (is, swap, type, len, is_small_data_element))
-              {
-                error ("load: reading sparse matrix data for '%s'",
-                       retval.c_str ());
-                goto data_read_error;
-              }
+              error ("load: reading sparse matrix data for '%s'",
+                     retval.c_str ());
 
             read_mat5_binary_data (is, im.fortran_vec (), nnz, swap,
                                    static_cast<enum mat5_data_type> (type),
                                    flt_fmt);
 
             if (! is)
-              {
-                error ("load: reading imaginary sparse matrix data for '%s'",
-                       retval.c_str ());
-                goto data_read_error;
-              }
+              error ("load: reading imaginary sparse matrix data for '%s'",
+                     retval.c_str ());
 
             for (octave_idx_type i = 0; i < nnz; i++)
               scm.xdata (i) = Complex (re (i), im (i));
 
             tc = scm;
           }
         else
           tc = sm;
@@ -1061,53 +1012,41 @@ read_mat5_binary_element (std::istream& 
             if (parse_status == 0)
               {
                 octave_fcn_handle *fh =
                   anon_fcn_handle.fcn_handle_value ();
 
                 if (fh)
                   tc = new octave_fcn_handle (fh->fcn_val (), "@<anonymous>");
                 else
-                  {
-                    error ("load: failed to load anonymous function handle");
-                    goto skip_ahead;
-                  }
+                  error ("load: failed to load anonymous function handle");
               }
             else
-              {
-                error ("load: failed to load anonymous function handle");
-                goto skip_ahead;
-              }
+              error ("load: failed to load anonymous function handle");
 
             frame.run ();
           }
         else
-          {
-            error ("load: invalid function handle type");
-            goto skip_ahead;
-          }
+          error ("load: invalid function handle type");
       }
       break;
 
     case MAT_FILE_WORKSPACE_CLASS:
       {
         octave_map m (dim_vector (1, 1));
         int n_fields = 2;
         string_vector field (n_fields);
 
         for (int i = 0; i < n_fields; i++)
           {
             int32_t fn_type;
             int32_t fn_len;
             if (read_mat5_tag (is, swap, fn_type, fn_len, is_small_data_element)
                 || ! INT8(fn_type))
-              {
-                error ("load: invalid field name subelement");
-                goto data_read_error;
-              }
+              error ("load: invalid field name subelement");
 
             OCTAVE_LOCAL_BUFFER (char, elname, fn_len + 1);
 
             std::streampos tmp_pos = is.tellg ();
 
             if (fn_len)
               {
                 if (! is.read (elname, fn_len))
@@ -1156,20 +1095,17 @@ read_mat5_binary_element (std::istream& 
       break;
 
     case MAT_FILE_OBJECT_CLASS:
       {
         isclass = true;
 
         if (read_mat5_tag (is, swap, type, len, is_small_data_element)
             || ! INT8(type))
-          {
-            error ("load: invalid class name");
-            goto skip_ahead;
-          }
+          error ("load: invalid class name");
 
         {
           OCTAVE_LOCAL_BUFFER (char, name, len+1);
 
           std::streampos tmp_pos = is.tellg ();
 
           if (len)
             {
@@ -1193,35 +1129,29 @@ read_mat5_binary_element (std::istream& 
         int32_t field_name_length;
 
         // field name length subelement -- actually the maximum length
         // of a field name.  The Matlab docs promise this will always
         // be 32.  We read and use the actual value, on the theory
         // that eventually someone will recognize that's a waste of space.
         if (read_mat5_tag (is, swap, fn_type, fn_len, is_small_data_element)
             || fn_type != miINT32)
-          {
-            error ("load: invalid field name length subelement");
-            goto data_read_error;
-          }
+          error ("load: invalid field name length subelement");
 
         if (! is.read (reinterpret_cast<char *> (&field_name_length), fn_len))
           goto data_read_error;
 
         if (swap)
           swap_bytes<4> (&field_name_length);
 
         // field name subelement.  The length of this subelement tells
         // us how many fields there are.
         if (read_mat5_tag (is, swap, fn_type, fn_len, is_small_data_element)
             || ! INT8(fn_type))
-          {
-            error ("load: invalid field name subelement");
-            goto data_read_error;
-          }
+          error ("load: invalid field name subelement");
 
         octave_idx_type n_fields = fn_len/field_name_length;
 
         if (n_fields > 0)
           {
             fn_len = READ_PAD (is_small_data_element, fn_len);
 
             OCTAVE_LOCAL_BUFFER (char, elname, fn_len);
@@ -1361,59 +1291,47 @@ read_mat5_binary_element (std::istream& 
       {
         FloatNDArray re (dims);
 
         // real data subelement
 
         std::streampos tmp_pos;
 
         if (read_mat5_tag (is, swap, type, len, is_small_data_element))
-          {
-            error ("load: reading matrix data for '%s'", retval.c_str ());
-            goto data_read_error;
-          }
+          error ("load: reading matrix data for '%s'", retval.c_str ());
 
         octave_idx_type n = re.numel ();
         tmp_pos = is.tellg ();
         read_mat5_binary_data (is, re.fortran_vec (), n, swap,
                                static_cast<enum mat5_data_type> (type),
                                flt_fmt);
 
         if (! is)
-          {
-            error ("load: reading matrix data for '%s'", retval.c_str ());
-            goto data_read_error;
-          }
+          error ("load: reading matrix data for '%s'", retval.c_str ());
 
         is.seekg (tmp_pos + static_cast<std::streamoff>
                   (READ_PAD (is_small_data_element, len)));
 
         if (imag)
           {
             // imaginary data subelement
 
             FloatNDArray im (dims);
 
             if (read_mat5_tag (is, swap, type, len, is_small_data_element))
-              {
-                error ("load: reading matrix data for '%s'", retval.c_str ());
-                goto data_read_error;
-              }
+              error ("load: reading matrix data for '%s'", retval.c_str ());
 
             n = im.numel ();
             read_mat5_binary_data (is, im.fortran_vec (), n, swap,
                                    static_cast<enum mat5_data_type> (type),
                                    flt_fmt);
 
             if (! is)
-              {
-                error ("load: reading imaginary matrix data for '%s'",
-                       retval.c_str ());
-                goto data_read_error;
-              }
+              error ("load: reading imaginary matrix data for '%s'",
+                     retval.c_str ());
 
             FloatComplexNDArray ctmp (dims);
 
             for (octave_idx_type i = 0; i < n; i++)
               ctmp(i) = FloatComplex (re(i), im(i));
 
             tc = ctmp;
           }
@@ -1430,32 +1348,26 @@ read_mat5_binary_element (std::istream& 
       {
         NDArray re (dims);
 
         // real data subelement
 
         std::streampos tmp_pos;
 
         if (read_mat5_tag (is, swap, type, len, is_small_data_element))
-          {
-            error ("load: reading matrix data for '%s'", retval.c_str ());
-            goto data_read_error;
-          }
+          error ("load: reading matrix data for '%s'", retval.c_str ());
 
         octave_idx_type n = re.numel ();
         tmp_pos = is.tellg ();
         read_mat5_binary_data (is, re.fortran_vec (), n, swap,
                                static_cast<enum mat5_data_type> (type),
                                flt_fmt);
 
         if (! is)
-          {
-            error ("load: reading matrix data for '%s'", retval.c_str ());
-            goto data_read_error;
-          }
+          error ("load: reading matrix data for '%s'", retval.c_str ());
 
         is.seekg (tmp_pos + static_cast<std::streamoff>
                   (READ_PAD (is_small_data_element, len)));
 
         if (logicalvar)
           {
             // Logical variables can either be MAT_FILE_UINT8_CLASS or
             // MAT_FILE_DOUBLE_CLASS, so check if we have a logical
@@ -1470,32 +1382,26 @@ read_mat5_binary_element (std::istream& 
           }
         else if (imag)
           {
             // imaginary data subelement
 
             NDArray im (dims);
 
             if (read_mat5_tag (is, swap, type, len, is_small_data_element))
-              {
-                error ("load: reading matrix data for '%s'", retval.c_str ());
-                goto data_read_error;
-              }
+              error ("load: reading matrix data for '%s'", retval.c_str ());
 
             n = im.numel ();
             read_mat5_binary_data (is, im.fortran_vec (), n, swap,
                                    static_cast<enum mat5_data_type> (type),
                                    flt_fmt);
 
             if (! is)
-              {
-                error ("load: reading imaginary matrix data for '%s'",
-                       retval.c_str ());
-                goto data_read_error;
-              }
+              error ("load: reading imaginary matrix data for '%s'",
+                     retval.c_str ());
 
             ComplexNDArray ctmp (dims);
 
             for (octave_idx_type i = 0; i < n; i++)
               ctmp(i) = Complex (re(i), im(i));
 
             tc = ctmp;
           }
@@ -1555,17 +1461,16 @@ read_mat5_binary_element (std::istream& 
   is.seekg (pos + static_cast<std::streamoff> (element_length));
 
   if (is.eof ())
     is.clear ();
 
   return retval;
 
 data_read_error:
-early_read_error:
   error ("load: trouble reading binary file '%s'", filename.c_str ());
   return std::string ();
 
 skip_ahead:
   warning ("load: skipping over '%s'", retval.c_str ());
   is.seekg (pos + static_cast<std::streamoff> (element_length));
   return read_mat5_binary_element (is, filename, swap, global, tc);
 }
@@ -2416,20 +2321,17 @@ save_mat5_binary_element (std::ostream& 
               == Z_OK)
             {
               write_mat5_tag (os, miCOMPRESSED,
                               static_cast<octave_idx_type> (destLen));
 
               os.write (out_buf, destLen);
             }
           else
-            {
-              error ("save: error compressing data element");
-              ret = false;
-            }
+            error ("save: error compressing data element");
         }
 
       return ret;
     }
 #endif
 
   write_mat5_tag (os, miMATRIX, save_mat5_element_length
                   (tc, name, save_as_floats, mat7_format));
diff --git a/libinterp/corefcn/ls-oct-text.cc b/libinterp/corefcn/ls-oct-text.cc
--- a/libinterp/corefcn/ls-oct-text.cc
+++ b/libinterp/corefcn/ls-oct-text.cc
@@ -392,20 +392,17 @@ save_three_d (std::ostream& os, const oc
               if (i+1 < nc)
                 os << "\n";
             }
         }
 
       os.precision (old_precision);
     }
   else
-    {
-      error ("for now, I can only save real matrices in 3-D format");
-      fail = true;
-    }
+    error ("for now, I can only save real matrices in 3-D format");
 
   return (os && ! fail);
 }
 
 DEFUN (save_precision, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} save_precision ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} save_precision (@var{new_val})\n\
diff --git a/libinterp/corefcn/luinc.cc b/libinterp/corefcn/luinc.cc
--- a/libinterp/corefcn/luinc.cc
+++ b/libinterp/corefcn/luinc.cc
@@ -150,20 +150,17 @@ values of @var{p} @var{q} as vector valu
           thresh = tmp.matrix_value ();
 
           if (thresh.numel () == 1)
             {
               thresh.resize (1,2);
               thresh(1) = thresh(0);
             }
           else if (thresh.numel () != 2)
-            {
-              error ("luinc: THRESH must be a 1 or 2-element vector");
-              return retval;
-            }
+            error ("luinc: THRESH must be a 1 or 2-element vector");
         }
     }
   else
     droptol = args(1).double_value ();
 
   if (nargin == 3)
     {
       std::string tmp = args(2).string_value ();
diff --git a/libinterp/corefcn/max.cc b/libinterp/corefcn/max.cc
--- a/libinterp/corefcn/max.cc
+++ b/libinterp/corefcn/max.cc
@@ -240,20 +240,17 @@ do_minmax_body (const octave_value_list&
     {
       octave_value arg = args(0);
       int dim = -1;
       if (nargin == 3)
         {
           dim = args(2).int_value (true) - 1;
 
           if (dim < 0)
-            {
-              error ("%s: DIM must be a valid dimension", func);
-              return retval;
-            }
+            error ("%s: DIM must be a valid dimension", func);
 
           if (! args(1).is_empty ())
             warning ("%s: second argument is ignored", func);
         }
 
       switch (arg.builtin_type ())
         {
         case btyp_double:
@@ -919,20 +916,17 @@ do_cumminmax_body (const octave_value_li
 
   octave_value arg = args(0);
   int dim = -1;
   if (nargin == 2)
     {
       dim = args(1).int_value (true) - 1;
 
       if (dim < 0)
-        {
-          error ("%s: DIM must be a valid dimension", func);
-          return retval;
-        }
+        error ("%s: DIM must be a valid dimension", func);
     }
 
   switch (arg.builtin_type ())
     {
     case btyp_double:
       retval = do_cumminmax_red_op<NDArray> (arg, nargout, dim, ismin);
       break;
 
diff --git a/libinterp/corefcn/nproc.cc b/libinterp/corefcn/nproc.cc
--- a/libinterp/corefcn/nproc.cc
+++ b/libinterp/corefcn/nproc.cc
@@ -65,20 +65,17 @@ environment variable.\n\
 
       if (arg == "all")
         query = NPROC_ALL;
       else if (arg == "current")
         query = NPROC_CURRENT;
       else if (arg == "overridable")
         query = NPROC_CURRENT_OVERRIDABLE;
       else
-        {
-          error ("nproc: invalid value for QUERY");
-          return retval;
-        }
+        error ("nproc: invalid value for QUERY");
     }
 
   retval = num_processors (query);
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/oct-hist.cc b/libinterp/corefcn/oct-hist.cc
--- a/libinterp/corefcn/oct-hist.cc
+++ b/libinterp/corefcn/oct-hist.cc
@@ -415,37 +415,31 @@ mk_tmp_hist_file (const octave_value_lis
 
   if (usage_error)
     {
       usage ("%s [first] [last]", warn_for);
       return retval;
     }
 
   if (hist_beg > hist_count || hist_end > hist_count)
-    {
-      error ("%s: history specification out of range", warn_for);
-      return retval;
-    }
+    error ("%s: history specification out of range", warn_for);
 
   if (hist_end < hist_beg)
     {
       std::swap (hist_end, hist_beg);
       reverse = true;
     }
 
   std::string name = octave_tempnam ("", "oct-");
 
   std::fstream file (name.c_str (), std::ios::out);
 
   if (! file)
-    {
-      error ("%s: couldn't open temporary file '%s'", warn_for,
-             name.c_str ());
-      return retval;
-    }
+    error ("%s: couldn't open temporary file '%s'", warn_for,
+           name.c_str ());
 
   if (reverse)
     {
       for (int i = hist_end; i >= hist_beg; i--)
         file << hlist[i] << "\n";
     }
   else
     {
@@ -485,20 +479,17 @@ do_edit_history (const octave_value_list
 
   int status = system (cmd.c_str ());
 
   octave_set_interrupt_handler (old_interrupt_handler);
 
   // Check if text edition was successfull.  Abort the operation
   // in case of failure.
   if (status != EXIT_SUCCESS)
-    {
-      error ("edit_history: text editor command failed");
-      return;
-    }
+    error ("edit_history: text editor command failed");
 
   // Write the commands to the history file since source_file
   // disables command line history while it executes.
 
   std::fstream file (name.c_str (), std::ios::in);
 
   char *line;
   //int first = 1;
diff --git a/libinterp/corefcn/oct-map.cc b/libinterp/corefcn/oct-map.cc
--- a/libinterp/corefcn/oct-map.cc
+++ b/libinterp/corefcn/oct-map.cc
@@ -777,20 +777,17 @@ octave_map::cat (int dim, octave_idx_typ
             }
           else
             {
               dim_vector dv = map_list[0].dimensions;
 
               for (octave_idx_type i = 1; i < n; i++)
                 {
                   if (! dv.concat (map_list[i].dimensions, dim))
-                    {
-                      error ("dimension mismatch in struct concatenation");
-                      return retval;
-                    }
+                    error ("dimension mismatch in struct concatenation");
                 }
 
               retval.dimensions = dv;
             }
         }
 
       retval.optimize_dimensions ();
     }
@@ -1295,20 +1292,17 @@ octave_map::concat (const octave_map& rb
 {
   if (nfields () == rb.nfields ())
     {
       for (const_iterator pa = begin (); pa != end (); pa++)
         {
           const_iterator pb = rb.seek (key(pa));
 
           if (pb == rb.end ())
-            {
-              error ("field name mismatch in structure concatenation");
-              break;
-            }
+            error ("field name mismatch in structure concatenation");
 
           contents(pa).insert (rb.contents (pb), ra_idx);
         }
     }
   else
     {
       dim_vector dv = dims ();
 
@@ -1324,16 +1318,13 @@ octave_map::concat (const octave_map& rb
 void
 octave_map::optimize_dimensions (void)
 {
   octave_idx_type nf = nfields ();
 
   for (octave_idx_type i = 0; i < nf; i++)
     {
       if (! xvals[i].optimize_dimensions (dimensions))
-        {
-          error ("internal error: dimension mismatch across fields in struct");
-          break;
-        }
+        error ("internal error: dimension mismatch across fields in struct");
     }
 
 }
 
diff --git a/libinterp/corefcn/oct-obj.cc b/libinterp/corefcn/oct-obj.cc
--- a/libinterp/corefcn/oct-obj.cc
+++ b/libinterp/corefcn/oct-obj.cc
@@ -128,27 +128,21 @@ octave_value_list::splice (octave_idx_ty
 {
   octave_value_list retval;
 
   octave_idx_type len = length ();
 
   if (offset < 0 || offset >= len)
     {
       if (! (rep_length == 0 && offset == len))
-        {
-          error ("octave_value_list::splice: invalid OFFSET");
-          return retval;
-        }
+        error ("octave_value_list::splice: invalid OFFSET");
     }
 
   if (rep_length < 0 || rep_length + offset > len)
-    {
-      error ("octave_value_list::splice: invalid LENGTH");
-      return retval;
-    }
+    error ("octave_value_list::splice: invalid LENGTH");
 
   octave_idx_type lst_len = lst.length ();
 
   octave_idx_type new_len = len - rep_length + lst_len;
 
   retval.resize (new_len);
 
   octave_idx_type k = 0;
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -934,22 +934,18 @@ octave_base_stream::clearerr (void)
 
 std::string
 octave_base_stream::do_gets (octave_idx_type max_len, bool& err,
                              bool strip_newline, const std::string& who)
 {
   std::string retval;
 
   if (interactive && file_number () == 0)
-    {
-      ::error ("%s: unable to read from stdin while running interactively",
-               who.c_str ());
-
-      return retval;
-    }
+    ::error ("%s: unable to read from stdin while running interactively",
+             who.c_str ());
 
   err = false;
 
   std::istream *isp = input_stream ();
 
   if (isp)
     {
       std::istream& is = *isp;
@@ -2401,20 +2397,17 @@ do_printf_conv (std::ostream& os, const 
 static size_t
 do_printf_string (std::ostream& os, const printf_format_elt *elt,
                   int nsa, int sa_1, int sa_2, const std::string& arg,
                   const std::string& who)
 {
   size_t retval = 0;
 
   if (nsa > 2)
-    {
-      ::error ("%s: internal error handling format", who.c_str ());
-      return retval;
-    }
+    ::error ("%s: internal error handling format", who.c_str ());
 
   std::string flags = elt->flags;
 
   bool left = flags.find ('-') != std::string::npos;
 
   size_t len = arg.length ();
 
   size_t fw = nsa > 0 ? sa_1 : (elt->fw == -1 ? len : elt->fw);
@@ -2610,18 +2603,17 @@ octave_base_stream::do_numeric_printf_co
           {
             double dval = val.double_value (true);
 
             retval += do_printf_conv (os, fmt, nsa, sa_1, sa_2, dval, who);
           }
           break;
 
         default:
-          error ("%s: invalid format specifier",
-                 who.c_str ());
+          error ("%s: invalid format specifier", who.c_str ());
           return -1;
           break;
         }
     }
 
   return retval;
 }
 
@@ -4123,21 +4115,17 @@ octave_stream_list::instance_ok (void)
     {
       instance = new octave_stream_list ();
 
       if (instance)
         singleton_cleanup_list::add (cleanup_instance);
     }
 
   if (! instance)
-    {
-      ::error ("unable to create stream list object!");
-
-      retval = false;
-    }
+    ::error ("unable to create stream list object!");
 
   return retval;
 }
 
 int
 octave_stream_list::insert (octave_stream& os)
 {
   return (instance_ok ()) ? instance->do_insert (os) : -1;
diff --git a/libinterp/corefcn/ordschur.cc b/libinterp/corefcn/ordschur.cc
--- a/libinterp/corefcn/ordschur.cc
+++ b/libinterp/corefcn/ordschur.cc
@@ -114,25 +114,19 @@ is in the upper left corner, by doing:\n
 
   const Array<octave_idx_type> sel = args(2).octave_idx_type_vector_value ("ordschur: SELECT must be an array of integers");
 
   const octave_idx_type n = sel.numel ();
 
   const dim_vector dimU = args(0).dims ();
   const dim_vector dimS = args(1).dims ();
   if (n != dimU(0))
-    {
-      error ("ordschur: SELECT must have same length as the sides of U and S");
-      return retval;
-    }
+    error ("ordschur: SELECT must have same length as the sides of U and S");
   else if (n != dimU(0) || n != dimS(0) || n != dimU(1) || n != dimS(1))
-    {
-      error ("ordschur: U and S must be square and of equal sizes");
-      return retval;
-    }
+    error ("ordschur: U and S must be square and of equal sizes");
 
   const bool double_type  = args(0).is_double_type ()
                             || args(1).is_double_type ();
   const bool complex_type = args(0).is_complex_type ()
                             || args(1).is_complex_type ();
 
 #define PREPARE_ARGS(TYPE, TYPE_M, TYPE_COND) \
           TYPE ## Matrix U = args(0).x ## TYPE_M ## _value ("ordschur: U and S must be real or complex floating point matrices"); \
@@ -140,20 +134,18 @@ is in the upper left corner, by doing:\n
           TYPE ## Matrix w (dim_vector (n, 1)); \
           TYPE ## Matrix work (dim_vector (n, 1)); \
           octave_idx_type m; \
           octave_idx_type info; \
           TYPE_COND cond1, cond2;
 
 #define PREPARE_OUTPUT()\
           if (info != 0) \
-            { \
-              error ("ordschur: trsen failed"); \
-              return retval; \
-            } \
+            error ("ordschur: trsen failed"); \
+ \
           retval(0) = U; \
           retval(1) = S;
 
   if (double_type)
     {
       if (complex_type)
         {
           PREPARE_ARGS (Complex, complex_matrix, double)
diff --git a/libinterp/corefcn/pinv.cc b/libinterp/corefcn/pinv.cc
--- a/libinterp/corefcn/pinv.cc
+++ b/libinterp/corefcn/pinv.cc
@@ -76,37 +76,31 @@ where @code{sigma_max (@var{x})} is the 
     {
       if (isfloat)
         {
           float tol = 0.0;
           if (nargin == 2)
             tol = args(1).float_value ();
 
           if (tol < 0.0)
-            {
-              error ("pinv: TOL must be greater than zero");
-              return retval;
-            }
+            error ("pinv: TOL must be greater than zero");
 
           if (arg.is_real_type ())
             retval = arg.float_diag_matrix_value ().pseudo_inverse (tol);
           else
             retval = arg.float_complex_diag_matrix_value ().pseudo_inverse (tol);
         }
       else
         {
           double tol = 0.0;
           if (nargin == 2)
             tol = args(1).double_value ();
 
           if (tol < 0.0)
-            {
-              error ("pinv: TOL must be greater than zero");
-              return retval;
-            }
+            error ("pinv: TOL must be greater than zero");
 
           if (arg.is_real_type ())
             retval = arg.diag_matrix_value ().pseudo_inverse (tol);
           else
             retval = arg.complex_diag_matrix_value ().pseudo_inverse (tol);
         }
     }
   else if (arg.is_perm_matrix ())
@@ -115,20 +109,17 @@ where @code{sigma_max (@var{x})} is the 
     }
   else if (isfloat)
     {
       float tol = 0.0;
       if (nargin == 2)
         tol = args(1).float_value ();
 
       if (tol < 0.0)
-        {
-          error ("pinv: TOL must be greater than zero");
-          return retval;
-        }
+        error ("pinv: TOL must be greater than zero");
 
       if (arg.is_real_type ())
         {
           FloatMatrix m = arg.float_matrix_value ();
 
           retval = m.pseudo_inverse (tol);
         }
       else if (arg.is_complex_type ())
@@ -142,20 +133,17 @@ where @code{sigma_max (@var{x})} is the 
     }
   else
     {
       double tol = 0.0;
       if (nargin == 2)
         tol = args(1).double_value ();
 
       if (tol < 0.0)
-        {
-          error ("pinv: TOL must be greater than zero");
-          return retval;
-        }
+        error ("pinv: TOL must be greater than zero");
 
       if (arg.is_real_type ())
         {
           Matrix m = arg.matrix_value ();
 
           retval = m.pseudo_inverse (tol);
         }
       else if (arg.is_complex_type ())
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -3660,21 +3660,17 @@ set_format_style (int argc, const string
                   print_big_e = true;
                 }
               else if (arg == "eng")
                 {
                   init_format_state ();
                   print_eng = true;
                 }
               else
-                {
-                  error ("format: unrecognized option 'short %s'",
-                         arg.c_str ());
-                  return;
-                }
+                error ("format: unrecognized option 'short %s'", arg.c_str ());
             }
           else
             init_format_state ();
 
           set_output_prec_and_fw (5, 10);
         }
       else if (arg == "shorte")
         {
@@ -3738,21 +3734,17 @@ set_format_style (int argc, const string
                   print_big_e = true;
                 }
               else if (arg == "eng")
                 {
                   init_format_state ();
                   print_eng = true;
                 }
               else
-                {
-                  error ("format: unrecognized option 'long %s'",
-                         arg.c_str ());
-                  return;
-                }
+                error ("format: unrecognized option 'long %s'", arg.c_str ());
             }
           else
             init_format_state ();
 
           set_output_prec_and_fw (15, 20);
         }
       else if (arg == "longe")
         {
@@ -3811,20 +3803,17 @@ set_format_style (int argc, const string
           if (--argc > 0)
             {
               arg = argv[idx++];
               format.append (arg);
 
               if (arg.length () == 3)
                 plus_format_chars = arg;
               else
-                {
-                  error ("format: invalid option for plus format");
-                  return;
-                }
+                error ("format: invalid option for plus format");
             }
           else
             plus_format_chars = "+- ";
 
           init_format_state ();
           plus_format = true;
         }
       else if (arg == "rat")
@@ -3853,20 +3842,17 @@ set_format_style (int argc, const string
           return;
         }
       else if (arg == "loose")
         {
           Vcompact_format = false;
           return;
         }
       else
-        {
-          error ("format: unrecognized format state '%s'", arg.c_str ());
-          return;
-        }
+        error ("format: unrecognized format state '%s'", arg.c_str ());
     }
   else
     {
       init_format_state ();
       set_output_prec_and_fw (5, 10);
       format = std::string ("short");
     }
 
diff --git a/libinterp/corefcn/profiler.cc b/libinterp/corefcn/profiler.cc
--- a/libinterp/corefcn/profiler.cc
+++ b/libinterp/corefcn/profiler.cc
@@ -260,20 +260,17 @@ profile_data_accumulator::exit_function 
   // up the stack.  So note the start-time for this!
   last_time = query_time ();
 }
 
 void
 profile_data_accumulator::reset (void)
 {
   if (is_active ())
-    {
-      error ("Can't reset active profiler.");
-      return;
-    }
+    error ("Can't reset active profiler.");
 
   known_functions.clear ();
   fcn_index.clear ();
 
   if (call_tree)
     {
       delete call_tree;
       call_tree = 0;
diff --git a/libinterp/corefcn/psi.cc b/libinterp/corefcn/psi.cc
--- a/libinterp/corefcn/psi.cc
+++ b/libinterp/corefcn/psi.cc
@@ -69,93 +69,79 @@ can have any value real or complex value
 
   const octave_idx_type nargin = args.length ();
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   const octave_value oct_z = (nargin == 1) ? args(0) : args(1);
   const octave_idx_type k = (nargin == 1) ? 0 : args(0).idx_type_value ("psi: K must be an integer");
   if (k < 0)
-    {
-      error ("psi: K must be non-negative");
-      return retval;
-    }
+    error ("psi: K must be non-negative");
   else if (k == 0)
     {
 #define FLOAT_BRANCH(T, A, M, E) \
       if (oct_z.is_ ## T ##_type ()) \
         { \
           const A ## NDArray z = oct_z.M ## array_value (); \
           A ## NDArray psi_z (z.dims ()); \
-\
+ \
           const E* zv = z.data (); \
           E* psi_zv = psi_z.fortran_vec (); \
           const octave_idx_type n = z.numel (); \
           for (octave_idx_type i = 0; i < n; i++) \
             *psi_zv++ = psi (*zv++); \
-\
+ \
           retval = psi_z; \
         }
 
       if (oct_z.is_complex_type ())
         {
           FLOAT_BRANCH(double, Complex, complex_, Complex)
           else FLOAT_BRANCH(single, FloatComplex, float_complex_, FloatComplex)
           else
-            {
-              error ("psi: Z must be a floating point");
-            }
+            error ("psi: Z must be a floating point");
         }
       else
         {
           FLOAT_BRANCH(double, , , double)
           else FLOAT_BRANCH(single, Float, float_, float)
           else
-            {
-              error ("psi: Z must be a floating point");
-            }
+            error ("psi: Z must be a floating point");
         }
 
 #undef FLOAT_BRANCH
     }
   else
     {
       if (! oct_z.is_real_type ())
-        {
-          error ("psi: Z must be real value for polygamma (K > 0)");
-          return retval;
-        }
+        error ("psi: Z must be real value for polygamma (K > 0)");
 
 #define FLOAT_BRANCH(T, A, M, E) \
       if (oct_z.is_ ## T ##_type ()) \
         { \
           const A ## NDArray z = oct_z.M ## array_value (); \
           A ## NDArray psi_z (z.dims ()); \
-\
+ \
           const E* zv = z.data (); \
           E* psi_zv = psi_z.fortran_vec (); \
           const octave_idx_type n = z.numel (); \
           for (octave_idx_type i = 0; i < n; i++) \
             { \
               if (*zv < 0) \
-                { \
-                  error ("psi: Z must be non-negative for polygamma (K > 0)"); \
-                  return retval; \
-                } \
+                error ("psi: Z must be non-negative for polygamma (K > 0)"); \
+ \
               *psi_zv++ = psi (k, *zv++); \
             } \
           retval = psi_z; \
         }
 
       FLOAT_BRANCH(double, , , double)
       else FLOAT_BRANCH(single, Float, float_, float)
       else
-        {
-          error ("psi: Z must be a floating point for polygamma (K > 0)");
-        }
+        error ("psi: Z must be a floating point for polygamma (K > 0)");
 
 #undef FLOAT_BRANCH
     }
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/quadcc.cc b/libinterp/corefcn/quadcc.cc
--- a/libinterp/corefcn/quadcc.cc
+++ b/libinterp/corefcn/quadcc.cc
@@ -1598,50 +1598,38 @@ Mathematical Software, Vol. 37, Issue 3,
       std::string fname = "function y = ";
       fname.append (fcn_name);
       fname.append ("(x) y = ");
       fcn = extract_function (args(0), "quadcc", fcn_name, fname,
                               "; endfunction");
     }
 
   if (! args(1).is_real_scalar ())
-    {
-      error ("quadcc: lower limit of integration (A) must be a single real scalar");
-      return retval;
-    }
+    error ("quadcc: lower limit of integration (A) must be a single real scalar");
   else
     a = args(1).double_value ();
 
   if (! args(2).is_real_scalar ())
-    {
-      error ("quadcc: upper limit of integration (B) must be a single real scalar");
-      return retval;
-    }
+    error ("quadcc: upper limit of integration (B) must be a single real scalar");
   else
     b = args(2).double_value ();
 
   if (nargin < 4 || args(3).is_empty ())
     tol = 1.0e-6;
   else if (! args(3).is_real_scalar () || args(3).double_value () <= 0)
-    {
-      error ("quadcc: tolerance (TOL) must be a single real scalar > 0");
-      return retval;
-    }
+    error ("quadcc: tolerance (TOL) must be a single real scalar > 0");
   else
     tol = args(3).double_value ();
 
   if (nargin < 5)
     {
       nivals = 1;
     }
   else if (!(args(4).is_real_scalar () || args(4).is_real_matrix ()))
-    {
-      error ("quadcc: list of singularities (SING) must be a vector of real values");
-      return retval;
-    }
+    error ("quadcc: list of singularities (SING) must be a vector of real values");
   else
     {
       nivals = 1 + args(4).numel ();
     }
 
   int cquad_heapsize = (nivals >= min_cquad_heapsize ? nivals + 1
                                                      : min_cquad_heapsize);
   /* The interval heap. */
@@ -1700,26 +1688,22 @@ Mathematical Software, Vol. 37, Issue 3,
       else
         {
           for (i = 0; i <= n[3]; i++)
             ex(i) = m + xi[i] * h;
         }
       fargs(0) = ex;
       fvals = feval (fcn, fargs, 1);
       if (fvals.length () != 1 || ! fvals(0).is_real_matrix ())
-        {
-          error ("quadcc: integrand F must return a single, real-valued vector");
-          return retval;
-        }
+        error ("quadcc: integrand F must return a single, real-valued vector");
+
       Matrix effex = fvals(0).matrix_value ();
       if (effex.numel () != ex.numel ())
-        {
-          error ("quadcc: integrand F must return a single, real-valued vector of the same size as the input");
-          return retval;
-        }
+        error ("quadcc: integrand F must return a single, real-valued vector of the same size as the input");
+
       for (i = 0; i <= n[3]; i++)
         {
           iv->fx[i] = effex(i);
           if (wrap)
             {
               xw = ex(i);
               iv->fx[i] *= (1.0 + xw * xw) * M_PI / 2;
             }
@@ -1819,26 +1803,22 @@ Mathematical Software, Vol. 37, Issue 3,
             else
               {
                 for (i = 0; i < n[d] / 2; i++)
                   ex(i) = m + xi[(2 * i + 1) * skip[d]] * h;
               }
             fargs(0) = ex;
             fvals = feval (fcn, fargs, 1);
             if (fvals.length () != 1 || ! fvals(0).is_real_matrix ())
-              {
-                error ("quadcc: integrand F must return a single, real-valued vector");
-                return retval;
-              }
+              error ("quadcc: integrand F must return a single, real-valued vector");
+
             Matrix effex = fvals(0).matrix_value ();
             if (effex.numel () != ex.numel ())
-              {
-                error ("quadcc: integrand F must return a single, real-valued vector of the same size as the input");
-                return retval;
-              }
+              error ("quadcc: integrand F must return a single, real-valued vector of the same size as the input");
+
             neval += effex.numel ();
             for (i = 0; i < n[d] / 2; i++)
               {
                 j = (2 * i + 1) * skip[d];
                 iv->fx[j] = effex(i);
                 if (wrap)
                   {
                     xw = ex(i);
@@ -1967,26 +1947,22 @@ Mathematical Software, Vol. 37, Issue 3,
             else
               {
                 for (i = 0; i < n[0] - 1; i++)
                   ex(i) = ml + xi[(i + 1) * skip[0]] * hl;
               }
             fargs(0) = ex;
             fvals = feval (fcn, fargs, 1);
             if (fvals.length () != 1 || ! fvals(0).is_real_matrix ())
-              {
-                error ("quadcc: integrand F must return a single, real-valued vector");
-                return retval;
-              }
+              error ("quadcc: integrand F must return a single, real-valued vector");
+
             Matrix effex = fvals(0).matrix_value ();
             if (effex.numel () != ex.numel ())
-              {
-                error ("quadcc: integrand F must return a single, real-valued vector of the same size as the input");
-                return retval;
-              }
+              error ("quadcc: integrand F must return a single, real-valued vector of the same size as the input");
+
             neval += effex.numel ();
             for (i = 0; i < n[0] - 1; i++)
               {
                 j = (i + 1) * skip[0];
                 ivl->fx[j] = effex(i);
                 if (wrap)
                   {
                     xw = ex(i);
@@ -2063,26 +2039,22 @@ Mathematical Software, Vol. 37, Issue 3,
             else
               {
                 for (i = 0; i < n[0] - 1; i++)
                   ex(i) = mr + xi[(i + 1) * skip[0]] * hr;
               }
             fargs(0) = ex;
             fvals = feval (fcn, fargs, 1);
             if (fvals.length () != 1 || ! fvals(0).is_real_matrix ())
-              {
-                error ("quadcc: integrand F must return a single, real-valued vector");
-                return retval;
-              }
+              error ("quadcc: integrand F must return a single, real-valued vector");
+
             Matrix effex = fvals(0).matrix_value ();
             if (effex.numel () != ex.numel ())
-              {
-                error ("quadcc: integrand F must return a single, real-valued vector of the same size as the input");
-                return retval;
-              }
+              error ("quadcc: integrand F must return a single, real-valued vector of the same size as the input");
+
             neval += effex.numel ();
             for (i = 0; i < n[0] - 1; i++)
               {
                 j = (i + 1) * skip[0];
                 ivr->fx[j] = effex(i);
                 if (wrap)
                   {
                     xw = ex(i);
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -404,20 +404,17 @@ compatibility with @sc{matlab}.\n\
 
       if (! tmp.empty ())
         ord_job = tmp[0];
 
       if (! (ord_job == 'N' || ord_job == 'n'
              || ord_job == 'S' || ord_job == 's'
              || ord_job == 'B' || ord_job == 'b'
              || ord_job == '+' || ord_job == '-'))
-        {
-          error ("qz: invalid order option");
-          return retval;
-        }
+        error ("qz: invalid order option");
 
       // overflow constant required by dlag2
       F77_FUNC (xdlamch, XDLAMCH) (F77_CONST_CHAR_ARG2 ("S", 1),
                                    safmin
                                    F77_CHAR_ARG_LEN (1));
 
 #ifdef DEBUG_EIG
       std::cout << "qz: initial value of safmin="
@@ -507,20 +504,17 @@ compatibility with @sc{matlab}.\n\
   // Both matrices loaded, now let's check what kind of arithmetic:
   // declared volatile to avoid compiler warnings about long jumps,
   // vforks.
 
   volatile int complex_case
     = (args(0).is_complex_type () || args(1).is_complex_type ());
 
   if (nargin == 3 && complex_case)
-    {
-      error ("qz: cannot re-order complex qz decomposition");
-      return retval;
-    }
+    error ("qz: cannot re-order complex qz decomposition");
 
   // First, declare variables used in both the real and complex case.
   Matrix QQ(nn,nn), ZZ(nn,nn), VR(nn,nn), VL(nn,nn);
   RowVector alphar(nn), alphai(nn), betar(nn);
   ComplexRowVector xalpha(nn), xbeta(nn);
   ComplexMatrix CQ(nn,nn), CZ(nn,nn), CVR(nn,nn), CVL(nn,nn);
   octave_idx_type ilo, ihi, info;
   char compq = (nargout >= 3 ? 'V' : 'N');
@@ -789,226 +783,221 @@ compatibility with @sc{matlab}.\n\
         }
 
     }
 
   // Order the QZ decomposition?
   if (! (ord_job == 'N' || ord_job == 'n'))
     {
       if (complex_case)
-        {
-          // Probably not needed, but better be safe.
-          error ("qz: cannot re-order complex qz decomposition");
-          return retval;
-        }
-      else
-        {
+        // Probably not needed, but better be safe.
+        error ("qz: cannot re-order complex qz decomposition");
+
 #ifdef DEBUG_SORT
-          std::cout << "qz: ordering eigenvalues: ord_job = "
-                    << ord_job << std::endl;
+      std::cout << "qz: ordering eigenvalues: ord_job = "
+                << ord_job << std::endl;
 #endif
 
-          // Declared static to avoid vfork/long jump compiler complaints.
-          static sort_function sort_test;
-          sort_test = 0;
+      // Declared static to avoid vfork/long jump compiler complaints.
+      static sort_function sort_test;
+      sort_test = 0;
 
-          switch (ord_job)
-            {
-            case 'S':
-            case 's':
-              sort_test = &fin;
-              break;
+      switch (ord_job)
+        {
+        case 'S':
+        case 's':
+          sort_test = &fin;
+          break;
 
-            case 'B':
-            case 'b':
-              sort_test = &fout;
-              break;
+        case 'B':
+        case 'b':
+          sort_test = &fout;
+          break;
 
-            case '+':
-              sort_test = &fcrhp;
-              break;
+        case '+':
+          sort_test = &fcrhp;
+          break;
 
-            case '-':
-              sort_test = &folhp;
-              break;
+        case '-':
+          sort_test = &folhp;
+          break;
 
-            default:
-              // Invalid order option (should never happen, since we
-              // checked the options at the top).
-              panic_impossible ();
-              break;
-            }
+        default:
+          // Invalid order option (should never happen, since we
+          // checked the options at the top).
+          panic_impossible ();
+          break;
+        }
 
-          octave_idx_type ndim, fail;
-          double inf_norm;
+      octave_idx_type ndim, fail;
+      double inf_norm;
 
-          F77_XFCN (xdlange, XDLANGE,
-                    (F77_CONST_CHAR_ARG2 ("I", 1),
-                     nn, nn, aa.data (), nn, work.fortran_vec (), inf_norm
-                     F77_CHAR_ARG_LEN (1)));
+      F77_XFCN (xdlange, XDLANGE,
+                (F77_CONST_CHAR_ARG2 ("I", 1),
+                 nn, nn, aa.data (), nn, work.fortran_vec (), inf_norm
+                 F77_CHAR_ARG_LEN (1)));
 
-          double eps = std::numeric_limits<double>::epsilon () * inf_norm * nn;
+      double eps = std::numeric_limits<double>::epsilon () * inf_norm * nn;
 
 #ifdef DEBUG_SORT
-          std::cout << "qz: calling dsubsp: aa=" << std::endl;
-          octave_print_internal (std::cout, aa, 0);
-          std::cout << std::endl << "bb="  << std::endl;
-          octave_print_internal (std::cout, bb, 0);
-          if (compz == 'V')
-            {
-              std::cout << std::endl << "ZZ="  << std::endl;
-              octave_print_internal (std::cout, ZZ, 0);
-            }
-          std::cout << std::endl;
-          std::cout << "alphar = " << std::endl;
-          octave_print_internal (std::cout, (Matrix) alphar, 0);
-          std::cout << std::endl << "alphai = " << std::endl;
-          octave_print_internal (std::cout, (Matrix) alphai, 0);
-          std::cout << std::endl << "beta = " << std::endl;
-          octave_print_internal (std::cout, (Matrix) betar, 0);
-          std::cout << std::endl;
+      std::cout << "qz: calling dsubsp: aa=" << std::endl;
+      octave_print_internal (std::cout, aa, 0);
+      std::cout << std::endl << "bb="  << std::endl;
+      octave_print_internal (std::cout, bb, 0);
+      if (compz == 'V')
+        {
+          std::cout << std::endl << "ZZ="  << std::endl;
+          octave_print_internal (std::cout, ZZ, 0);
+        }
+      std::cout << std::endl;
+      std::cout << "alphar = " << std::endl;
+      octave_print_internal (std::cout, (Matrix) alphar, 0);
+      std::cout << std::endl << "alphai = " << std::endl;
+      octave_print_internal (std::cout, (Matrix) alphai, 0);
+      std::cout << std::endl << "beta = " << std::endl;
+      octave_print_internal (std::cout, (Matrix) betar, 0);
+      std::cout << std::endl;
 #endif
 
-          Array<octave_idx_type> ind (dim_vector (nn, 1));
+      Array<octave_idx_type> ind (dim_vector (nn, 1));
 
-          F77_XFCN (dsubsp, DSUBSP,
-                    (nn, nn, aa.fortran_vec (), bb.fortran_vec (),
-                     ZZ.fortran_vec (), sort_test, eps, ndim, fail,
-                     ind.fortran_vec ()));
+      F77_XFCN (dsubsp, DSUBSP,
+                (nn, nn, aa.fortran_vec (), bb.fortran_vec (),
+                 ZZ.fortran_vec (), sort_test, eps, ndim, fail,
+                 ind.fortran_vec ()));
 
 #ifdef DEBUG
-          std::cout << "qz: back from dsubsp: aa=" << std::endl;
-          octave_print_internal (std::cout, aa, 0);
-          std::cout << std::endl << "bb="  << std::endl;
-          octave_print_internal (std::cout, bb, 0);
-          if (compz == 'V')
-            {
-              std::cout << std::endl << "ZZ="  << std::endl;
-              octave_print_internal (std::cout, ZZ, 0);
-            }
-          std::cout << std::endl;
+      std::cout << "qz: back from dsubsp: aa=" << std::endl;
+      octave_print_internal (std::cout, aa, 0);
+      std::cout << std::endl << "bb="  << std::endl;
+      octave_print_internal (std::cout, bb, 0);
+      if (compz == 'V')
+        {
+          std::cout << std::endl << "ZZ="  << std::endl;
+          octave_print_internal (std::cout, ZZ, 0);
+        }
+      std::cout << std::endl;
 #endif
 
-          // Manually update alphar, alphai, betar.
-          static int jj;
+      // Manually update alphar, alphai, betar.
+      static int jj;
+
+      jj = 0;
+      while (jj < nn)
+        {
+#ifdef DEBUG_EIG
+          std::cout << "computing gen eig #" << jj << std::endl;
+#endif
+
+          // Number of zeros in this block.
+          static int zcnt;
 
-          jj = 0;
-          while (jj < nn)
+          if (jj == (nn-1))
+            zcnt = 1;
+          else if (aa(jj+1,jj) == 0)
+            zcnt = 1;
+          else zcnt = 2;
+
+          if (zcnt == 1)
             {
+              // Real zero.
 #ifdef DEBUG_EIG
-              std::cout << "computing gen eig #" << jj << std::endl;
+              std::cout << "  single gen eig:" << std::endl;
+              std::cout << "  alphar(" << jj << ") = " << aa(jj,jj)
+                        << std::endl;
+              std::cout << "  betar(" << jj << ") = " << bb(jj,jj)
+                        << std::endl;
+              std::cout << "  alphai(" << jj << ") = 0" << std::endl;
 #endif
 
-              // Number of zeros in this block.
-              static int zcnt;
-
-              if (jj == (nn-1))
-                zcnt = 1;
-              else if (aa(jj+1,jj) == 0)
-                zcnt = 1;
-              else zcnt = 2;
+              alphar(jj) = aa(jj,jj);
+              alphai(jj) = 0;
+              betar(jj) = bb(jj,jj);
+            }
+          else
+            {
+              // Complex conjugate pair.
+#ifdef DEBUG_EIG
+              std::cout << "qz: calling dlag2:" << std::endl;
+              std::cout << "safmin="
+                        << setiosflags (std::ios::scientific)
+                        << safmin << std::endl;
 
-              if (zcnt == 1)
+              for (int idr = jj; idr <= jj+1; idr++)
                 {
-                  // Real zero.
-#ifdef DEBUG_EIG
-                  std::cout << "  single gen eig:" << std::endl;
-                  std::cout << "  alphar(" << jj << ") = " << aa(jj,jj)
-                            << std::endl;
-                  std::cout << "  betar(" << jj << ") = " << bb(jj,jj)
-                            << std::endl;
-                  std::cout << "  alphai(" << jj << ") = 0" << std::endl;
+                  for (int idc = jj; idc <= jj+1; idc++)
+                    {
+                      std::cout << "aa(" << idr << "," << idc << ")="
+                                << aa(idr,idc) << std::endl;
+                      std::cout << "bb(" << idr << "," << idc << ")="
+                                << bb(idr,idc) << std::endl;
+                    }
+                }
 #endif
 
-                  alphar(jj) = aa(jj,jj);
+              // FIXME: probably should be using
+              // fortran_vec instead of &aa(jj,jj) here.
+
+              double scale1, scale2, wr1, wr2, wi;
+              const double *aa_ptr = aa.data () + jj * nn + jj;
+              const double *bb_ptr = bb.data () + jj * nn + jj;
+              F77_XFCN (dlag2, DLAG2,
+                        (aa_ptr, nn, bb_ptr, nn, safmin,
+                         scale1, scale2, wr1, wr2, wi));
+
+#ifdef DEBUG_EIG
+              std::cout << "dlag2 returns: scale1=" << scale1
+                        << "\tscale2=" << scale2 << std::endl
+                        << "\twr1=" << wr1 << "\twr2=" << wr2
+                        << "\twi=" << wi << std::endl;
+#endif
+
+              // Just to be safe, check if it's a real pair.
+              if (wi == 0)
+                {
+                  alphar(jj) = wr1;
                   alphai(jj) = 0;
-                  betar(jj) = bb(jj,jj);
+                  betar(jj) = scale1;
+                  alphar(jj+1) = wr2;
+                  alphai(jj+1) = 0;
+                  betar(jj+1) = scale2;
                 }
               else
                 {
-                  // Complex conjugate pair.
-#ifdef DEBUG_EIG
-                  std::cout << "qz: calling dlag2:" << std::endl;
-                  std::cout << "safmin="
-                            << setiosflags (std::ios::scientific)
-                            << safmin << std::endl;
-
-                  for (int idr = jj; idr <= jj+1; idr++)
-                    {
-                      for (int idc = jj; idc <= jj+1; idc++)
-                        {
-                          std::cout << "aa(" << idr << "," << idc << ")="
-                                    << aa(idr,idc) << std::endl;
-                          std::cout << "bb(" << idr << "," << idc << ")="
-                                    << bb(idr,idc) << std::endl;
-                        }
-                    }
-#endif
-
-                  // FIXME: probably should be using
-                  // fortran_vec instead of &aa(jj,jj) here.
-
-                  double scale1, scale2, wr1, wr2, wi;
-                  const double *aa_ptr = aa.data () + jj * nn + jj;
-                  const double *bb_ptr = bb.data () + jj * nn + jj;
-                  F77_XFCN (dlag2, DLAG2,
-                            (aa_ptr, nn, bb_ptr, nn, safmin,
-                             scale1, scale2, wr1, wr2, wi));
-
-#ifdef DEBUG_EIG
-                  std::cout << "dlag2 returns: scale1=" << scale1
-                            << "\tscale2=" << scale2 << std::endl
-                            << "\twr1=" << wr1 << "\twr2=" << wr2
-                            << "\twi=" << wi << std::endl;
-#endif
-
-                  // Just to be safe, check if it's a real pair.
-                  if (wi == 0)
-                    {
-                      alphar(jj) = wr1;
-                      alphai(jj) = 0;
-                      betar(jj) = scale1;
-                      alphar(jj+1) = wr2;
-                      alphai(jj+1) = 0;
-                      betar(jj+1) = scale2;
-                    }
-                  else
-                    {
-                      alphar(jj) = alphar(jj+1) = wr1;
-                      alphai(jj) = -(alphai(jj+1) = wi);
-                      betar(jj)  = betar(jj+1) = scale1;
-                    }
+                  alphar(jj) = alphar(jj+1) = wr1;
+                  alphai(jj) = -(alphai(jj+1) = wi);
+                  betar(jj)  = betar(jj+1) = scale1;
                 }
-
-              // Advance past this block.
-              jj += zcnt;
             }
 
+          // Advance past this block.
+          jj += zcnt;
+        }
+
 #ifdef DEBUG_SORT
-          std::cout << "qz: back from dsubsp: aa=" << std::endl;
-          octave_print_internal (std::cout, aa, 0);
-          std::cout << std::endl << "bb="  << std::endl;
-          octave_print_internal (std::cout, bb, 0);
+      std::cout << "qz: back from dsubsp: aa=" << std::endl;
+      octave_print_internal (std::cout, aa, 0);
+      std::cout << std::endl << "bb="  << std::endl;
+      octave_print_internal (std::cout, bb, 0);
 
-          if (compz == 'V')
-            {
-              std::cout << std::endl << "ZZ="  << std::endl;
-              octave_print_internal (std::cout, ZZ, 0);
-            }
-          std::cout << std::endl << "qz: ndim=" << ndim << std::endl
-                    << "fail=" << fail << std::endl;
-          std::cout << "alphar = " << std::endl;
-          octave_print_internal (std::cout, (Matrix) alphar, 0);
-          std::cout << std::endl << "alphai = " << std::endl;
-          octave_print_internal (std::cout, (Matrix) alphai, 0);
-          std::cout << std::endl << "beta = " << std::endl;
-          octave_print_internal (std::cout, (Matrix) betar, 0);
-          std::cout << std::endl;
+      if (compz == 'V')
+        {
+          std::cout << std::endl << "ZZ="  << std::endl;
+          octave_print_internal (std::cout, ZZ, 0);
+        }
+      std::cout << std::endl << "qz: ndim=" << ndim << std::endl
+                << "fail=" << fail << std::endl;
+      std::cout << "alphar = " << std::endl;
+      octave_print_internal (std::cout, (Matrix) alphar, 0);
+      std::cout << std::endl << "alphai = " << std::endl;
+      octave_print_internal (std::cout, (Matrix) alphai, 0);
+      std::cout << std::endl << "beta = " << std::endl;
+      octave_print_internal (std::cout, (Matrix) betar, 0);
+      std::cout << std::endl;
 #endif
-        }
     }
 
   // Compute generalized eigenvalues?
   ComplexColumnVector gev;
 
   if (nargout < 2 || nargout == 7 || (nargin == 3 && nargout == 4))
     {
       if (complex_case)
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -81,20 +81,17 @@ do_rand (const octave_value_list& args, 
         }
       else if (s_arg == "double")
         nargin--;
     }
 
   if (additional_arg)
     {
       if (nargin == 0)
-        {
-          error ("%s: at least one argument is required", fcn);
-          goto done;
-        }
+        error ("%s: at least one argument is required", fcn);
       else if (args(0).is_string ())
         additional_arg = false;
       else
         {
           a = args(0).xarray_value ("%s: dimension must be a scalar integer", fcn);
 
           idx++;
           nargin--;
@@ -161,19 +158,17 @@ do_rand (const octave_value_list& args, 
             else
               error ("%s: unrecognized string argument", fcn);
           }
         else if (tmp.is_scalar_type ())
           {
             double dval = tmp.double_value ();
 
             if (xisnan (dval))
-              {
-                error ("%s: NaN is invalid matrix dimension", fcn);
-              }
+              error ("%s: NaN is invalid matrix dimension", fcn);
             else
               {
                 dims.resize (2);
 
                 dims(0) = NINTbig (tmp.double_value ());
                 dims(1) = NINTbig (tmp.double_value ());
 
                 goto gen_matrix;
@@ -309,20 +304,18 @@ gen_matrix:
     {
       if (additional_arg)
         {
           if (a.numel () == 1)
             return octave_rand::float_nd_array (dims, a(0));
           else
             {
               if (a.dims () != dims)
-                {
-                  error ("%s: mismatch in argument size", fcn);
-                  return retval;
-                }
+                error ("%s: mismatch in argument size", fcn);
+
               octave_idx_type len = a.numel ();
               FloatNDArray m (dims);
               float *v = m.fortran_vec ();
               for (octave_idx_type i = 0; i < len; i++)
                 v[i] = octave_rand::float_scalar (a(i));
               return m;
             }
         }
@@ -333,20 +326,18 @@ gen_matrix:
     {
       if (additional_arg)
         {
           if (a.numel () == 1)
             return octave_rand::nd_array (dims, a(0));
           else
             {
               if (a.dims () != dims)
-                {
-                  error ("%s: mismatch in argument size", fcn);
-                  return retval;
-                }
+                error ("%s: mismatch in argument size", fcn);
+
               octave_idx_type len = a.numel ();
               NDArray m (dims);
               double *v = m.fortran_vec ();
               for (octave_idx_type i = 0; i < len; i++)
                 v[i] = octave_rand::scalar (a(i));
               return m;
             }
         }
diff --git a/libinterp/corefcn/strfind.cc b/libinterp/corefcn/strfind.cc
--- a/libinterp/corefcn/strfind.cc
+++ b/libinterp/corefcn/strfind.cc
@@ -249,20 +249,17 @@ strfind (@{\"abababa\", \"bebebe\", \"ab
                     retc(i) = Matrix ();
                   else
                     retc(i) = octave_value (qs_search (needle,
                                                        argse.char_array_value (),
                                                        table, overlaps),
                                             true, true);
                 }
               else
-                {
-                  error ("strfind: each element of CELLSTR must be a string");
-                  break;
-                }
+                error ("strfind: each element of CELLSTR must be a string");
             }
 
           retval = retc;
         }
       else
         error ("strfind: first argument must be a string or cell array of strings");
     }
   else if (argpat.is_cell ())
@@ -432,20 +429,17 @@ strrep (\"This is a test string\", \"is\
 
           for (octave_idx_type i = 0; i < ns; i++)
             {
               octave_value argse = argsc(i);
               if (argse.is_string ())
                 retc(i) = qs_replace (argse.char_array_value (), pat, rep,
                                       table, overlaps);
               else
-                {
-                  error ("strrep: each element of S must be a string");
-                  break;
-                }
+                error ("strrep: each element of S must be a string");
             }
 
           retval = retc;
         }
       else
         error ("strrep: S must be a string or cell array of strings");
     }
   else if (argpat.is_cell () || argrep.is_cell ())
diff --git a/libinterp/corefcn/strfns.cc b/libinterp/corefcn/strfns.cc
--- a/libinterp/corefcn/strfns.cc
+++ b/libinterp/corefcn/strfns.cc
@@ -481,20 +481,17 @@ do_strcmp_fun (const octave_value& arg0,
                         }
                     }
                 }
             }
         }
       else
         {
           if (size1 != size2)
-            {
-              error ("%s: nonconformant cell arrays", fcn_name);
-              return retval;
-            }
+            error ("%s: nonconformant cell arrays", fcn_name);
 
           if (cell1.is_cellstr () && cell2.is_cellstr ())
             {
               const Array<std::string> cellstr1 = cell1_val.cellstr_value ();
               const Array<std::string> cellstr2 = cell2_val.cellstr_value ();
               for (octave_idx_type i = 0; i < r1; i++)
                 output (i) = str_op (cellstr1(i), cellstr2(i), n);
             }
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -333,17 +333,16 @@ raw_mode (bool on, bool wait)
 {
   static bool curr_on = false;
 
   int tty_fd = STDIN_FILENO;
   if (! gnulib::isatty (tty_fd))
     {
       if (interactive && ! forced_interactive)
         error ("stdin is not a tty!");
-      return;
     }
 
   if (on == curr_on)
     return;
 
 #if defined (HAVE_TERMIOS_H)
   {
     struct termios s;
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -1040,39 +1040,33 @@ command shell that is started to run the
     {
       std::string type_str = args(2).xstring_value ("system: TYPE must be a string");
 
       if (type_str == "sync")
         type = et_sync;
       else if (type_str == "async")
         type = et_async;
       else
-        {
-          error ("system: TYPE must be \"sync\" or \"async\"");
-          return retval;
-        }
+        error ("system: TYPE must be \"sync\" or \"async\"");
     }
 
   if (nargin > 1)
     {
       try
         {
           return_output = args(1).is_true ();
         }
       catch (octave_execution_exception& e)
         {
           error (e, "system: RETURN_OUTPUT must be boolean value true or false");
         }
     }
 
   if (return_output && type == et_async)
-    {
-      error ("system: can't return output from commands run asynchronously");
-      return retval;
-    }
+    error ("system: can't return output from commands run asynchronously");
 
   std::string cmd_str = args(0).xstring_value ("system: first argument must be a string");
 
 #if defined (__WIN32__) && ! defined (__CYGWIN__)
   // Work around weird double-quote handling on Windows systems.
   if (type == et_sync)
     cmd_str = "\"" + cmd_str + "\"";
 #endif
diff --git a/libinterp/corefcn/tril.cc b/libinterp/corefcn/tril.cc
--- a/libinterp/corefcn/tril.cc
+++ b/libinterp/corefcn/tril.cc
@@ -126,42 +126,37 @@ do_triu (const Array<T>& a, octave_idx_t
 // These two are by David Bateman.
 // FIXME: optimizations possible. "pack" support missing.
 
 template <class T>
 static Sparse<T>
 do_tril (const Sparse<T>& a, octave_idx_type k, bool pack)
 {
   if (pack) // FIXME
-    {
-      error ("tril: \"pack\" not implemented for sparse matrices");
-      return Sparse<T> ();
-    }
+    error ("tril: \"pack\" not implemented for sparse matrices");
 
   Sparse<T> m = a;
   octave_idx_type nc = m.cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
       if (m.ridx (i) < j-k)
         m.data(i) = 0.;
 
   m.maybe_compress (true);
+
   return m;
 }
 
 template <class T>
 static Sparse<T>
 do_triu (const Sparse<T>& a, octave_idx_type k, bool pack)
 {
   if (pack) // FIXME
-    {
-      error ("triu: \"pack\" not implemented for sparse matrices");
-      return Sparse<T> ();
-    }
+    error ("triu: \"pack\" not implemented for sparse matrices");
 
   Sparse<T> m = a;
   octave_idx_type nc = m.cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
       if (m.ridx (i) > j-k)
         m.data(i) = 0.;
@@ -262,21 +257,18 @@ do_trilu (const std::string& name,
 #undef ARRAYCASE
 
         default:
           {
             // Generic code that works on octave-values, that is slow
             // but will also work on arbitrary user types
 
             if (pack) // FIXME
-              {
-                error ("%s: \"pack\" not implemented for class %s",
-                       name.c_str (), arg.class_name ().c_str ());
-                return octave_value ();
-              }
+              error ("%s: \"pack\" not implemented for class %s",
+                     name.c_str (), arg.class_name ().c_str ());
 
             octave_value tmp = arg;
             if (arg.numel () == 0)
               return arg;
 
             octave_idx_type nr = dims(0);
             octave_idx_type nc = dims(1);
 
diff --git a/libinterp/corefcn/typecast.cc b/libinterp/corefcn/typecast.cc
--- a/libinterp/corefcn/typecast.cc
+++ b/libinterp/corefcn/typecast.cc
@@ -76,20 +76,19 @@ reinterpret_copy (const void *data, octa
     {
       ArrayType retval (get_vec_dims (old_dims, n));
       T *dest = retval.fortran_vec ();
       std::memcpy (dest, data, n * sizeof (T));
 
       return retval;
     }
   else
-    {
-      error ("typecast: incorrect number of input values to make output value");
-      return ArrayType ();
-    }
+    error ("typecast: incorrect number of input values to make output value");
+
+  return ArrayType ();
 }
 
 
 DEFUN (typecast, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{y} =} typecast (@var{x}, \"@var{class}\")\n\
 Return a new array @var{y} resulting from interpreting the data of @var{x}\n\
 in memory as data of the numeric class @var{class}.\n\
@@ -286,20 +285,19 @@ do_bitpack (const boolNDArray& bitp)
 
           packed[i] = c;
           bits += std::numeric_limits<unsigned char>::digits;
         }
 
       return retval;
     }
   else
-    {
-      error ("bitpack: incorrect number of bits to make up output value");
-      return ArrayType ();
-    }
+    error ("bitpack: incorrect number of bits to make up output value");
+
+  return ArrayType ();
 }
 
 DEFUN (bitpack, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{y} =} bitpack (@var{x}, @var{class})\n\
 Return a new array @var{y} resulting from interpreting the logical array\n\
 @var{x} as raw bit patterns for data of the numeric class @var{class}.\n\
 \n\
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -75,21 +75,17 @@ public:
   static bool instance_ok (void)
   {
     bool retval = true;
 
     if (! instance)
       create_instance ();
 
     if (! instance)
-      {
-        error ("unable to create ch_manager!");
-
-        retval = false;
-      }
+      error ("unable to create ch_manager!");
 
     return retval;
   }
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
 
   static curl_handle get_handle (void)
   {
@@ -350,43 +346,34 @@ urlwrite (\"http://www.google.com/search
   std::string method;
   Array<std::string> param;
 
   if (nargin == 4)
     {
       method = args(2).xstring_value ("urlwrite: METHOD must be a string");
 
       if (method != "get" && method != "post")
-        {
-          error ("urlwrite: METHOD must be \"get\" or \"post\"");
-          return retval;
-        }
+        error ("urlwrite: METHOD must be \"get\" or \"post\"");
 
       param = args(3).xcellstr_value ("urlwrite: parameters (PARAM) for get and post requests must be given as a cell array of strings");
 
       if (param.numel () % 2 == 1)
-        {
-          error ("urlwrite: number of elements in PARAM must be even");
-          return retval;
-        }
+        error ("urlwrite: number of elements in PARAM must be even");
     }
 
   // The file should only be deleted if it doesn't initially exist, we
   // create it, and the download fails.  We use unwind_protect to do
   // it so that the deletion happens no matter how we exit the function.
 
   file_stat fs (filename);
 
   std::ofstream ofile (filename.c_str (), std::ios::out | std::ios::binary);
 
   if (! ofile.is_open ())
-    {
-      error ("urlwrite: unable to open file");
-      return retval;
-    }
+    error ("urlwrite: unable to open file");
 
   unwind_protect_safe frame;
 
   frame.add_fcn (delete_file, filename);
 
   url_transfer curl = url_transfer (url, ofile);
 
   if (curl.is_valid ())
@@ -481,28 +468,22 @@ s = urlread (\"http://www.google.com/sea
   std::string method;
   Array<std::string> param;
 
   if (nargin == 3)
     {
       method = args(1).xstring_value ("urlread: METHOD must be a string");
 
       if (method != "get" && method != "post")
-        {
-          error ("urlread: METHOD must be \"get\" or \"post\"");
-          return retval;
-        }
+        error ("urlread: METHOD must be \"get\" or \"post\"");
 
       param = args(2).xcellstr_value ("urlread: parameters (PARAM) for get and post requests must be given as a cell array of strings");
 
       if (param.numel () % 2 == 1)
-        {
-          error ("urlread: number of elements in PARAM must be even");
-          return retval;
-        }
+        error ("urlread: number of elements in PARAM must be even");
     }
 
   std::ostringstream buf;
 
   url_transfer curl = url_transfer (url, buf);
 
   if (curl.is_valid ())
     {
@@ -910,52 +891,40 @@ Undocumented internal function\n\
 
           for (octave_idx_type i = 0; i < files.numel (); i++)
             {
               std::string file = files (i);
 
               file_stat fs (file);
 
               if (! fs.exists ())
-                {
-                  error ("__ftp__mput: file does not exist");
-                  break;
-                }
+                error ("__ftp__mput: file does not exist");
 
               if (fs.is_dir ())
                 {
                   file_list.append (curl.mput_directory ("", file));
 
                   if (! curl.good ())
-                    {
-                      error ("__ftp_mput__: %s", curl.lasterror().c_str());
-                      break;
-                    }
+                    error ("__ftp_mput__: %s", curl.lasterror().c_str());
                 }
               else
                 {
                   // FIXME: Does ascii mode need to be flagged here?
                   std::ifstream ifile (file.c_str (), std::ios::in |
                                        std::ios::binary);
 
                   if (! ifile.is_open ())
-                    {
-                      error ("__ftp_mput__: unable to open file");
-                      break;
-                    }
+                    error ("__ftp_mput__: unable to open file");
 
                   curl.put (file, ifile);
 
                   ifile.close ();
 
                   if (! curl.good ())
-                    {
-                      error ("__ftp_mput__: %s", curl.lasterror().c_str());
-                      break;
-                    }
+                    error ("__ftp_mput__: %s", curl.lasterror().c_str());
 
                   file_list.append (file);
                 }
             }
 
           if (nargout > 0)
             retval = file_list;
         }
@@ -1012,38 +981,32 @@ Undocumented internal function\n\
                     curl.mget_directory (sv(i), target);
                   else
                     {
                       std::ofstream ofile ((target + sv(i)).c_str (),
                                            std::ios::out |
                                            std::ios::binary);
 
                       if (! ofile.is_open ())
-                        {
-                          error ("__ftp_mget__: unable to open file");
-                          break;
-                        }
+                        error ("__ftp_mget__: unable to open file");
 
                       unwind_protect_safe frame;
 
                       frame.add_fcn (delete_file, target + sv(i));
 
                       curl.get (sv(i), ofile);
 
                       ofile.close ();
 
                       if (curl.good ())
                         frame.discard ();
                     }
 
                   if (! curl.good ())
-                    {
-                      error ("__ftp_mget__: %s", curl.lasterror().c_str());
-                      break;
-                    }
+                    error ("__ftp_mget__: %s", curl.lasterror().c_str());
                 }
             }
 
           if (n == 0)
             error ("__ftp_mget__: file not found");
         }
       else
         error ("__ftp_mget__: invalid ftp handle");
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -1470,20 +1470,17 @@ do_simple_cellfun (octave_value_list (*f
               new_args(i) = ccells[i](0);
             }
           else if (numel == 1)
             {
               numel = n;
               dims = ccells[i].dims ();
             }
           else if (dims != ccells[i].dims ())
-            {
-              error ("%s: cell arguments must have matching sizes", fun_name);
-              break;
-            }
+            error ("%s: cell arguments must have matching sizes", fun_name);
         }
     }
 
   for (int i = 0; i < nargout; i++)
     rcells[i].clear (dims);
 
   for (octave_idx_type j = 0; j < numel; j++)
     {
@@ -1491,25 +1488,20 @@ do_simple_cellfun (octave_value_list (*f
         if (iscell[i])
           new_args(i) = ccells[i](j);
 
       octave_quit ();
 
       const octave_value_list tmp = fun (new_args, nargout);
 
       if (tmp.length () < nargout)
-        {
-          error ("%s: do_simple_cellfun: internal error", fun_name);
-          break;
-        }
-      else
-        {
-          for (int i = 0; i < nargout; i++)
-            rcells[i](j) = tmp(i);
-        }
+        error ("%s: do_simple_cellfun: internal error", fun_name);
+
+      for (int i = 0; i < nargout; i++)
+        rcells[i](j) = tmp(i);
     }
 
   retval.resize (nargout);
 
   for (int i = 0; i < nargout; i++)
     retval(i) = rcells[i];
 
   return retval;
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -158,21 +158,18 @@ extract_function (const octave_value& ar
 
       eval_string (cmd, true, parse_status, 0);
 
       if (parse_status == 0)
         {
           retval = is_valid_function (fname, warn_for, 0);
 
           if (! retval)
-            {
-              error ("%s: '%s' is not valid as a function",
-                     warn_for.c_str (), fname.c_str ());
-              return retval;
-            }
+            error ("%s: '%s' is not valid as a function",
+                   warn_for.c_str (), fname.c_str ());
 
           warning ("%s: passing function body as a string is obsolete; please use anonymous functions",
                    warn_for.c_str ());
         }
       else
         error ("%s: '%s' is not valid as a function",
                warn_for.c_str (), fname.c_str ());
     }
@@ -327,20 +324,17 @@ static octave_value
 do_isglobal (const octave_value_list& args)
 {
   octave_value retval = false;
 
   if (args.length () != 1)
     print_usage ();
 
   if (! args(0).is_string ())
-    {
-      error ("isglobal: NAME must be a string");
-      return retval;
-    }
+    error ("isglobal: NAME must be a string");
 
   std::string name = args(0).string_value ();
 
   return symbol_table::is_global (name);
 }
 
 DEFUN (isglobal, args, ,
        "-*- texinfo -*-\n\
@@ -392,20 +386,17 @@ symbol_exist (const std::string& name, c
   bool search_var = type == "var";
   bool search_dir = type == "dir";
   bool search_file = type == "file";
   bool search_builtin = type == "builtin";
   bool search_class = type == "class";
 
   if (! (search_any || search_var || search_dir || search_file ||
          search_builtin || search_class))
-    {
-      error ("exist: unrecognized type argument \"%s\"", type.c_str ());
-      return 0;
-    }
+    error ("exist: unrecognized type argument \"%s\"", type.c_str ());
 
   if (search_any || search_var)
     {
       octave_value val = symbol_table::varval (name);
 
       if (val.is_constant () || val.is_object ()
           || val.is_function_handle ()
           || val.is_anonymous_function ()
@@ -1485,41 +1476,35 @@ public:
               items = sscanf (cmd.c_str (), "%c%c:%d:%d:%d;",
                               &garbage, &param.command, &a, &b, &balance);
             else
               items = sscanf (cmd.c_str (), "%c%c%c:%d:%d:%d;",
                               &garbage, &param.modifier, &param.command,
                               &a, &b, &balance) - 1;
 
             if (items < 2)
-              {
-                error ("whos_line_format: parameter structure without command in whos_line_format");
-                error_encountered = true;
-              }
+              error ("whos_line_format: parameter structure without command in whos_line_format");
 
             // Insert data into parameter
             param.first_parameter_length = 0;
             pos = param_string.find (param.command);
             if (pos != std::string::npos)
               {
                 param.parameter_length = param_length(pos);
                 param.text = param_names(pos);
                 param.line.assign (param_names(pos).length (), '=');
 
                 param.parameter_length = (a > param.parameter_length
                                           ? a : param.parameter_length);
                 if (param.command == 's' && param.modifier == 'c' && b > 0)
                   param.first_parameter_length = b;
               }
             else
-              {
-                error ("whos_line_format: '%c' is not a command",
-                       param.command);
-                error_encountered = true;
-              }
+              error ("whos_line_format: '%c' is not a command",
+                     param.command);
 
             if (param.command == 's')
               {
                 // Have to calculate space needed for printing
                 // matrix dimensions Space needed for Size column is
                 // hard to determine in prior, because it depends on
                 // dimensions to be shown. That is why it is
                 // recalculated for each Size-command int first,
@@ -1554,21 +1539,18 @@ public:
                   }
                 else
                   {
                     param.parameter_length = total;
                     param.first_parameter_length = 0;
                   }
               }
             else if (param.modifier == 'c')
-              {
-                error ("whos_line_format: modifier 'c' not available for command '%c'",
-                       param.command);
-                error_encountered = true;
-              }
+              error ("whos_line_format: modifier 'c' not available for command '%c'",
+                     param.command);
 
             // What happens if whos_line_format contains negative numbers
             // at param_length positions?
             param.balance = (b < 0 ? 0 : param.balance);
             param.first_parameter_length = (b < 0 ? 0 :
                                             param.first_parameter_length);
             param.parameter_length = (a < 0
                                       ? 0
