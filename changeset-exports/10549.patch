# HG changeset patch
# User Rik <code@nomad.inbox5.com>
# Date 1272047330 25200
#      Fri Apr 23 11:28:50 2010 -0700
# Node ID 95c3e38098bfbe3752a7477f303b4db338a8d4cc
# Parent  479536c5bb105b1548ad477aa56b968b957bfd95
Untabify .m scripts

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,12 @@
+2010-04-23  Rik <octave@nomad.inbox5.com>
+
+   * scripts/*.m: Untabify scripts
+
 2010-04-23  Rik <octave@nomad.inbox5.com>
 
    * scripts/geometry/griddata.m, scripts/geometry/griddatan.m, 
      scripts/geometry/tsearchn.m: Replace nan with NaN for nice visual cue
 
 2010-04-23  Rik <octave@nomad.inbox5.com>
 
 	* optimization/gplot.m: Eliminate parsing error for NaN inside of matrix 
diff --git a/scripts/audio/loadaudio.m b/scripts/audio/loadaudio.m
--- a/scripts/audio/loadaudio.m
+++ b/scripts/audio/loadaudio.m
@@ -59,17 +59,17 @@ function X = loadaudio (name, ext, bit)
   if (strcmp (ext, "lin") || strcmp (ext, "raw") || strcmp (ext, "pcm"))
     if (bit == 8)
       [Y, c] = fread (num, inf, "uchar");
       X = Y - 127;
     else
       [X, c] = fread (num, inf, "short");
     endif
   elseif (strcmp (ext, "mu") || strcmp (ext, "au")
-	  || strcmp (ext, "snd") || strcmp(ext, "ul"))
+          || strcmp (ext, "snd") || strcmp(ext, "ul"))
     [Y, c] = fread (num, inf, "uchar");
     ## remove file header
     m = find (Y(1:64) == 0, 1, "last");
     if (! isempty (m))
       Y(1:m) = [];
     endif
     X = mu2lin (Y, bit);
   else
diff --git a/scripts/audio/mu2lin.m b/scripts/audio/mu2lin.m
--- a/scripts/audio/mu2lin.m
+++ b/scripts/audio/mu2lin.m
@@ -39,31 +39,31 @@ function y = mu2lin (x, bit)
     if (bit != 0 && bit != 8 && bit != 16)
       error ("mu2lin: bit must be either 0, 8 or 16");
     endif
   else
     print_usage ();
   endif
 
   ulaw = [32124, 31100, 30076, 29052, 28028, 27004, 25980, 24956, \
-	  23932, 22908, 21884, 20860, 19836, 18812, 17788, 16764, \
-	  15996, 15484, 14972, 14460, 13948, 13436, 12924, 12412, \
-	  11900, 11388, 10876, 10364,  9852,  9340,  8828,  8316, \
-	   7932,  7676,  7420,  7164,  6908,  6652,  6396,  6140, \
-	   5884,  5628,  5372,  5116,  4860,  4604,  4348,  4092, \
-	   3900,  3772,  3644,  3516,  3388,  3260,  3132,  3004, \
-	   2876,  2748,  2620,  2492,  2364,  2236,  2108,  1980, \
-	   1884,  1820,  1756,  1692,  1628,  1564,  1500,  1436, \
-	   1372,  1308,  1244,  1180,  1116,  1052,   988,   924, \
-	    876,   844,   812,   780,   748,   716,   684,   652, \
-	    620,   588,   556,   524,   492,   460,   428,   396, \
-	    372,   356,   340,   324,   308,   292,   276,   260, \
-	    244,   228,   212,   196,   180,   164,   148,   132, \
-	    120,   112,   104,    96,    88,    80,    72,    64, \
-	     56,    48,    40,    32,    24,    16,     8,     0 ];
+          23932, 22908, 21884, 20860, 19836, 18812, 17788, 16764, \
+          15996, 15484, 14972, 14460, 13948, 13436, 12924, 12412, \
+          11900, 11388, 10876, 10364,  9852,  9340,  8828,  8316, \
+           7932,  7676,  7420,  7164,  6908,  6652,  6396,  6140, \
+           5884,  5628,  5372,  5116,  4860,  4604,  4348,  4092, \
+           3900,  3772,  3644,  3516,  3388,  3260,  3132,  3004, \
+           2876,  2748,  2620,  2492,  2364,  2236,  2108,  1980, \
+           1884,  1820,  1756,  1692,  1628,  1564,  1500,  1436, \
+           1372,  1308,  1244,  1180,  1116,  1052,   988,   924, \
+            876,   844,   812,   780,   748,   716,   684,   652, \
+            620,   588,   556,   524,   492,   460,   428,   396, \
+            372,   356,   340,   324,   308,   292,   276,   260, \
+            244,   228,   212,   196,   180,   164,   148,   132, \
+            120,   112,   104,    96,    88,    80,    72,    64, \
+             56,    48,    40,    32,    24,    16,     8,     0 ];
 
   ulaw = [ -ulaw, ulaw ];
 
   ## Set the shape of y to that of x overwrites the contents of y with
   ## ulaw of x.
   y = x;
   y(:) = ulaw (x + 1);
 
diff --git a/scripts/audio/playaudio.m b/scripts/audio/playaudio.m
--- a/scripts/audio/playaudio.m
+++ b/scripts/audio/playaudio.m
@@ -59,17 +59,17 @@ function playaudio (name, ext)
     elseif (nargin == 2)
       name = [name, ".", ext];
     else
       print_usage ();
     endif
     if (strcmp (ext, "lin") || strcmp (ext, "raw"))
       system (sprintf ("cat \"%s\" > /dev/dsp", name));
     elseif (strcmp (ext, "mu") || strcmp (ext, "au")
-	    || strcmp (ext, "snd") || strcmp (ext, "ul"))
+            || strcmp (ext, "snd") || strcmp (ext, "ul"))
       system (sprintf ("cat \"%s\" > /dev/audio", name));
     else
       error ("playaudio does not support given extension");
     endif
   else
     print_usage ();
   endif
 
diff --git a/scripts/audio/saveaudio.m b/scripts/audio/saveaudio.m
--- a/scripts/audio/saveaudio.m
+++ b/scripts/audio/saveaudio.m
@@ -71,17 +71,17 @@ function saveaudio (name, X, ext, bit)
         X = fix (X * sc);
       endif
       X = X + 127;
       c = fwrite (num, X, "uchar");
     else
       c = fwrite (num, X, "short");
     endif
   elseif (strcmp (ext, "mu") || strcmp (ext, "au")
-	  || strcmp (ext, "snd") || strcmp (ext, "ul"))
+          || strcmp (ext, "snd") || strcmp (ext, "ul"))
     Y = lin2mu (X);
     c = fwrite (num, Y, "uchar");
   else
     fclose (num);
     error ("saveaudio does not support given extension");
   endif
 
   fclose (num);
diff --git a/scripts/audio/wavread.m b/scripts/audio/wavread.m
--- a/scripts/audio/wavread.m
+++ b/scripts/audio/wavread.m
@@ -127,34 +127,34 @@ function [y, samples_per_sec, bits_per_s
   ## Determine sample data type.
   if (format_tag == FORMAT_PCM)
     switch (bits_per_sample)
       case 8
         format = "uint8";
       case 16 
         format = "int16";
       case 24
-	format = "uint8";
+        format = "uint8";
       case 32 
         format = "int32";
       otherwise
         fclose (fid);
         error ("wavread: %d bits sample resolution is not supported with PCM",
-	       bits_per_sample);
+               bits_per_sample);
     endswitch
   else
     switch (bits_per_sample)
       case 32 
         format = "float32";
       case 64 
         format = "float64";
       otherwise
         fclose (fid);
         error ("wavread: %d bits sample resolution is not supported with IEEE float",
-	       bits_per_sample);
+               bits_per_sample);
     endswitch
   endif
   
   ## Parse arguments.
   if (nargin == 1)
     length = 8 * data_size / bits_per_sample;
   else
     if (size (param, 2) == 1)
@@ -182,34 +182,34 @@ function [y, samples_per_sec, bits_per_s
     length *= 3;
   endif
   [yi, n] = fread (fid, length, format, 0, BYTEORDER);
   fclose (fid);
 
   ## Check data.
   if (mod (numel (yi), channels) != 0)
     error ("wavread: data in %s doesn't match the number of channels",
-	   filename);
+           filename);
   endif
 
   if (bits_per_sample == 24)
     yi = reshape (yi, 3, rows(yi)/3)';
     yi(yi(:,3) >= 128, 3) -= 256;
     yi = yi * [1; 256; 65536];
   endif
 
   if (format_tag == FORMAT_PCM)
     ## Normalize samples.
     switch (bits_per_sample)
       case 8
         yi = (yi - 128)/127;
       case 16
         yi /= 32767;
       case 24
-		yi /= 8388607;
+                yi /= 8388607;
       case 32
         yi /= 2147483647;
     endswitch
   endif
   
   ## Deinterleave.
   nr = numel (yi) / channels;
   y = reshape (yi, channels, nr)';
diff --git a/scripts/audio/wavwrite.m b/scripts/audio/wavwrite.m
--- a/scripts/audio/wavwrite.m
+++ b/scripts/audio/wavwrite.m
@@ -50,25 +50,25 @@ function wavwrite (y, varargin)
   bits_per_sample = 16;
 
   if (ischar (y))
     filename = y;
     y = varargin{1};
     if (nargin > 2)
       samples_per_sec = varargin{2};
       if (nargin > 3)
-	bits_per_sample = varargin{3};
+        bits_per_sample = varargin{3};
       endif
     endif
   else
     filename = varargin{end};
     if (nargin > 2)
       samples_per_sec = varargin{1};
       if (nargin > 3)
-	bits_per_sample = varargin{2};
+        bits_per_sample = varargin{2};
       endif
     endif
   endif
 
   ## test arguments
   if (columns (y) < 1)
     error ("wavwrite: Y must have at least one column");
   endif
diff --git a/scripts/deprecated/cellidx.m b/scripts/deprecated/cellidx.m
--- a/scripts/deprecated/cellidx.m
+++ b/scripts/deprecated/cellidx.m
@@ -83,27 +83,27 @@ function [idxvec,errmsg]  = cellidx (lis
     endif
   endif
 
   nsigs = length(listvar);
   for idx = 1:length(strlist)
     signame = strlist{idx};
     for jdx = 1:nsigs
       if (strcmp (signame, listvar{jdx}))
-	if (idxvec(idx) != 0)
-	  warning ("Duplicate signal name %s (%d,%d)\n",
-		   listvar{jdx}, jdx, idxvec(idx));
-	else
-	  idxvec(idx) = jdx;
-	endif
+        if (idxvec(idx) != 0)
+          warning ("Duplicate signal name %s (%d,%d)\n",
+                   listvar{jdx}, jdx, idxvec(idx));
+        else
+          idxvec(idx) = jdx;
+        endif
       endif
     endfor
     if (idxvec(idx) == 0)
       errmsg = sprintf ("Did not find %s", signame);
       if (nargout == 1)
-	error (errmsg);
+        error (errmsg);
       else
-	break;
+        break;
       endif
     endif
   endfor
 
 endfunction
diff --git a/scripts/deprecated/intwarning.m b/scripts/deprecated/intwarning.m
--- a/scripts/deprecated/intwarning.m
+++ b/scripts/deprecated/intwarning.m
@@ -81,53 +81,53 @@ function y = intwarning (x)
     if (nargout > 0)
       y = warning("query", "Octave:int-convert-nan");
       y = [y; warning("query", "Octave:int-convert-non-int-val")];
       y = [y; warning("query", "Octave:int-convert-overflow")];
       y = [y; warning("query", "Octave:int-math-overflow")];
     endif
     if (ischar (x))
       if (strcmpi (x, "query"))
-	if (nargout == 0)
-	  __print_int_warn_state__ ("Octave:int-convert-nan");
-	  __print_int_warn_state__ ("Octave:int-convert-non-int-val");
-	  __print_int_warn_state__ ("Octave:int-convert-overflow");
-	  __print_int_warn_state__ ("Octave:int-math-overflow");
-	  printf("\n");
-	endif
+        if (nargout == 0)
+          __print_int_warn_state__ ("Octave:int-convert-nan");
+          __print_int_warn_state__ ("Octave:int-convert-non-int-val");
+          __print_int_warn_state__ ("Octave:int-convert-overflow");
+          __print_int_warn_state__ ("Octave:int-math-overflow");
+          printf("\n");
+        endif
       elseif (strcmpi (x, "on"))
-	warning ("on", "Octave:int-convert-nan");
-	warning ("on", "Octave:int-convert-non-int-val");
-	warning ("on", "Octave:int-convert-overflow");
-	warning ("on", "Octave:int-math-overflow");
+        warning ("on", "Octave:int-convert-nan");
+        warning ("on", "Octave:int-convert-non-int-val");
+        warning ("on", "Octave:int-convert-overflow");
+        warning ("on", "Octave:int-math-overflow");
       elseif (strcmpi (x, "off"))
-	warning ("off", "Octave:int-convert-nan");
-	warning ("off", "Octave:int-convert-non-int-val");
-	warning ("off", "Octave:int-convert-overflow");    
-	warning ("off", "Octave:int-math-overflow");    
+        warning ("off", "Octave:int-convert-nan");
+        warning ("off", "Octave:int-convert-non-int-val");
+        warning ("off", "Octave:int-convert-overflow");    
+        warning ("off", "Octave:int-math-overflow");    
       else
-	error ("intwarning: unrecognized argument");
+        error ("intwarning: unrecognized argument");
       endif
     elseif (isstruct(x))
       for fld = fieldnames (x)
-	if (strcmp ("Octave:int-convert-nan") || 
-	    strcmp ("Octave:int-convert-non-int-val") || 
-	    strcmp ("Octave:int-convert-overflow") ||
-	    strcmp ("Octave:int-cmath-overflow"))
-	  s = getfield (x, fld);
-	  if (! ischar (s) || !(strcmpi("s","on") || strcmpi("s","off")))
-	    error ("intwarning: unexpected warning state");
-	  endif
-	  warning (s, fld);
-	else
-	  error ("intwarning: unrecognized integer warning %s", fld);
-	endif
+        if (strcmp ("Octave:int-convert-nan") || 
+            strcmp ("Octave:int-convert-non-int-val") || 
+            strcmp ("Octave:int-convert-overflow") ||
+            strcmp ("Octave:int-cmath-overflow"))
+          s = getfield (x, fld);
+          if (! ischar (s) || !(strcmpi("s","on") || strcmpi("s","off")))
+            error ("intwarning: unexpected warning state");
+          endif
+          warning (s, fld);
+        else
+          error ("intwarning: unrecognized integer warning %s", fld);
+        endif
       endfor
     else
       error ("intwarning: unexpected input");
     endif
   endif
 endfunction
 
 function __print_int_warn_state__ (s)
   fprintf ("The state of warning \"%s\" is \"%s\"\n", 
-	   s, warning ("query", s).state);
+           s, warning ("query", s).state);
 endfunction
diff --git a/scripts/deprecated/lchol.m b/scripts/deprecated/lchol.m
--- a/scripts/deprecated/lchol.m
+++ b/scripts/deprecated/lchol.m
@@ -25,15 +25,15 @@
 
 ## Deprecated in version 3.2
 
 function varargout = lchol (varargin)
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
-	     "spfind is obsolete and will be removed from a future version of Octave; please use find instead");
+             "spfind is obsolete and will be removed from a future version of Octave; please use find instead");
   endif
 
   varargout = cell (nargout, 1);
   [ varargout{:} ] = chol (varargin{:}, "lower");
 
 endfunction
diff --git a/scripts/deprecated/spatan2.m b/scripts/deprecated/spatan2.m
--- a/scripts/deprecated/spatan2.m
+++ b/scripts/deprecated/spatan2.m
@@ -23,14 +23,14 @@
 
 ## Deprecated in version 3.2
 
 function retval = spatan2 (varargin)
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
-	     "spatan2 is obsolete and will be removed from a future version of Octave; please use atan2 instead");
+             "spatan2 is obsolete and will be removed from a future version of Octave; please use atan2 instead");
   endif
 
   retval = atan2 (varargin{:});
 
 endfunction
diff --git a/scripts/deprecated/spchol.m b/scripts/deprecated/spchol.m
--- a/scripts/deprecated/spchol.m
+++ b/scripts/deprecated/spchol.m
@@ -25,15 +25,15 @@
 
 ## Deprecated in version 3.2
 
 function varargout = spchol (varargin)
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
-	     "spchol is obsolete and will be removed from a future version of Octave; please use chol instead");
+             "spchol is obsolete and will be removed from a future version of Octave; please use chol instead");
   endif
 
   varargout = cell (nargout, 1);
   [ varargout{:} ] = chol (varargin{:});
 
 endfunction
diff --git a/scripts/deprecated/spchol2inv.m b/scripts/deprecated/spchol2inv.m
--- a/scripts/deprecated/spchol2inv.m
+++ b/scripts/deprecated/spchol2inv.m
@@ -23,14 +23,14 @@
 
 ## Deprecated in version 3.2
 
 function retval = spchol2inv (varargin)
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
-	     "spchol2inv is obsolete and will be removed from a future version of Octave; please use chol2inv instead");
+             "spchol2inv is obsolete and will be removed from a future version of Octave; please use chol2inv instead");
   endif
 
   retval = chol2inv (varargin{:});
 
 endfunction
diff --git a/scripts/deprecated/spcholinv.m b/scripts/deprecated/spcholinv.m
--- a/scripts/deprecated/spcholinv.m
+++ b/scripts/deprecated/spcholinv.m
@@ -23,13 +23,13 @@
 
 ## Deprecated in version 3.2
 
 function retval = spcholinv (varargin)
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
-	     "spcholinv is obsolete and will be removed from a future version of Octave; please use cholinv instead");
+             "spcholinv is obsolete and will be removed from a future version of Octave; please use cholinv instead");
   endif
   retval = cholinv (varargin{:});
 
 endfunction
diff --git a/scripts/deprecated/spcumprod.m b/scripts/deprecated/spcumprod.m
--- a/scripts/deprecated/spcumprod.m
+++ b/scripts/deprecated/spcumprod.m
@@ -23,14 +23,14 @@
 
 ## Deprecated in version 3.2
 
 function retval = spcumprod (varargin)
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
-	     "spcumprod is obsolete and will be removed from a future version of Octave; please use cumprod instead");
+             "spcumprod is obsolete and will be removed from a future version of Octave; please use cumprod instead");
   endif
 
   retval = cumprod (varargin{:});
 
 endfunction
diff --git a/scripts/deprecated/spcumsum.m b/scripts/deprecated/spcumsum.m
--- a/scripts/deprecated/spcumsum.m
+++ b/scripts/deprecated/spcumsum.m
@@ -23,14 +23,14 @@
 
 ## Deprecated in version 3.2
 
 function retval = spcumsum (varargin)
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
-	     "spcumsum is obsolete and will be removed from a future version of Octave; please use cumsum instead");
+             "spcumsum is obsolete and will be removed from a future version of Octave; please use cumsum instead");
   endif
 
   retval = cumsum (varargin{:});
 
 endfunction
diff --git a/scripts/deprecated/spdet.m b/scripts/deprecated/spdet.m
--- a/scripts/deprecated/spdet.m
+++ b/scripts/deprecated/spdet.m
@@ -23,15 +23,15 @@
 
 ## Deprecated in version 3.2
 
 function varargout = spdet (varargin)
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
-	     "spdet is obsolete and will be removed from a future version of Octave; please use det instead");
+             "spdet is obsolete and will be removed from a future version of Octave; please use det instead");
   endif
 
   varargout = cell (nargout, 1);
   [ varargout{:} ] = det (varargin{:});
 
 endfunction
diff --git a/scripts/deprecated/spdiag.m b/scripts/deprecated/spdiag.m
--- a/scripts/deprecated/spdiag.m
+++ b/scripts/deprecated/spdiag.m
@@ -23,14 +23,14 @@
 
 ## Deprecated in version 3.2
 
 function retval = spdiag (varargin)
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
-	     "spdiag is obsolete and will be removed from a future version of Octave; please use sparse (diag (...)) instead");
+             "spdiag is obsolete and will be removed from a future version of Octave; please use sparse (diag (...)) instead");
   endif
 
   retval = sparse (diag (varargin{:}));
 
 endfunction
diff --git a/scripts/deprecated/spfind.m b/scripts/deprecated/spfind.m
--- a/scripts/deprecated/spfind.m
+++ b/scripts/deprecated/spfind.m
@@ -26,15 +26,15 @@
 
 ## Deprecated in version 3.2
 
 function varargout = spfind (varargin)
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
-	     "spfind is obsolete and will be removed from a future version of Octave; please use find instead");
+             "spfind is obsolete and will be removed from a future version of Octave; please use find instead");
   endif
 
   varargout = cell (nargout, 1);
   [ varargout{:} ] = find (varargin{:});
 
 endfunction
diff --git a/scripts/deprecated/spinv.m b/scripts/deprecated/spinv.m
--- a/scripts/deprecated/spinv.m
+++ b/scripts/deprecated/spinv.m
@@ -23,15 +23,15 @@
 
 ## Deprecated in version 3.2
 
 function varargout = spinv (varargin)
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
-	     "spinv is obsolete and will be removed from a future version of Octave; please use inv instead");
+             "spinv is obsolete and will be removed from a future version of Octave; please use inv instead");
   endif
 
   varargout = cell (nargout, 1);
   [ varargout{:} ] = inv (varargin{:});
 
 endfunction
diff --git a/scripts/deprecated/spkron.m b/scripts/deprecated/spkron.m
--- a/scripts/deprecated/spkron.m
+++ b/scripts/deprecated/spkron.m
@@ -25,14 +25,14 @@
 
 ## Deprecated in version 3.2
 
 function retval = spkron (varargin)
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
-	     "spkron is obsolete and will be removed from a future version of Octave; please use kron instead");
+             "spkron is obsolete and will be removed from a future version of Octave; please use kron instead");
   endif
 
   retval = kron (varargin{:});
 
 endfunction
diff --git a/scripts/deprecated/splchol.m b/scripts/deprecated/splchol.m
--- a/scripts/deprecated/splchol.m
+++ b/scripts/deprecated/splchol.m
@@ -26,15 +26,15 @@
 
 ## Deprecated in version 3.2
 
 function varargout = splchol (varargin)
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
-	     "splchol is obsolete and will be removed from a future version of Octave; please use chol instead");
+             "splchol is obsolete and will be removed from a future version of Octave; please use chol instead");
   endif
 
   varargout = cell (nargout, 1);
   [ varargout{:} ] = chol (varargin{:}, "lower");
 
 endfunction
diff --git a/scripts/deprecated/split.m b/scripts/deprecated/split.m
--- a/scripts/deprecated/split.m
+++ b/scripts/deprecated/split.m
@@ -66,50 +66,50 @@ function m = split (s, t, n)
     endif
 
     if (ischar (s) && ischar (t))
 
       l_s = length (s);
       l_t = length (t);
 
       if (l_s == 0)
-	m = "";
-	return;
+        m = "";
+        return;
       elseif (l_t == 0)
-	m = s';
-	return;
+        m = s';
+        return;
       elseif (l_s < l_t)
-	error ("split: s must not be shorter than t");
+        error ("split: s must not be shorter than t");
       endif
 
       if (min (size (s)) != 1 || min (size (t)) != 1)
-	error("split: multi-line strings are not supported");
+        error("split: multi-line strings are not supported");
       endif
 
       ind = findstr (s, t, 0);
       if (length (ind) == 0)
-	m = s;
-	return;
+        m = s;
+        return;
       elseif (n - 1 < length(ind))
-	ind = ind(1:n-1);
+        ind = ind(1:n-1);
       endif
       ind2 = [1, ind+l_t];
       ind  = [ind, l_s+1];
 
       ind_diff = ind-ind2;
 
       ## Create a matrix of the correct size that's filled with spaces.
       m_rows = length (ind);
       m_cols = max (ind_diff);
       m = repmat (" ", m_rows, m_cols);
 
       ## Copy the strings to the matrix.
       for i = 1:length (ind)
-	tmp = ind2(i):(ind(i)-1);
-	m(i,1:length(tmp)) = s(tmp);
+        tmp = ind2(i):(ind(i)-1);
+        m(i,1:length(tmp)) = s(tmp);
       endfor
     else
       error ("split: both s and t must be strings");
     endif
   else
     print_usage ();
   endif
 
diff --git a/scripts/deprecated/splu.m b/scripts/deprecated/splu.m
--- a/scripts/deprecated/splu.m
+++ b/scripts/deprecated/splu.m
@@ -27,17 +27,17 @@
 
 ## Deprecated in version 3.2
 
 function varargout = splu (varargin)
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
-	     "splu is obsolete and will be removed from a future version of Octave; please use lu instead");
+             "splu is obsolete and will be removed from a future version of Octave; please use lu instead");
   endif
 
   for i = 2 : nargin
     arg = varargin {i};
     if (! isscalar (arg))
       error ("splu: Can no longer treat input column permutations");
     endif
   endfor
diff --git a/scripts/deprecated/spmax.m b/scripts/deprecated/spmax.m
--- a/scripts/deprecated/spmax.m
+++ b/scripts/deprecated/spmax.m
@@ -24,15 +24,15 @@
 
 ## Deprecated in version 3.2
 
 function varargout = spmax (varargin)
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
-	     "spmax is obsolete and will be removed from a future version of Octave; please use max instead");
+             "spmax is obsolete and will be removed from a future version of Octave; please use max instead");
   endif
 
   varargout = cell (nargout, 1);
   [ varargout{:} ] = max (varargin{:});
 
 endfunction
diff --git a/scripts/deprecated/spmin.m b/scripts/deprecated/spmin.m
--- a/scripts/deprecated/spmin.m
+++ b/scripts/deprecated/spmin.m
@@ -24,15 +24,15 @@
 
 ## Deprecated in version 3.2
 
 function varargout = spmin (varargin)
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
-	     "spmin is obsolete and will be removed from a future version of Octave; please use min instead");
+             "spmin is obsolete and will be removed from a future version of Octave; please use min instead");
   endif
 
   varargout = cell (nargout, 1);
   [ varargout{:} ] = min (varargin{:});
 
 endfunction
diff --git a/scripts/deprecated/spprod.m b/scripts/deprecated/spprod.m
--- a/scripts/deprecated/spprod.m
+++ b/scripts/deprecated/spprod.m
@@ -23,14 +23,14 @@
 
 ## Deprecated in version 3.2
 
 function retval = spprod (varargin)
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
-	     "spprod is obsolete and will be removed from a future version of Octave; please use prod instead");
+             "spprod is obsolete and will be removed from a future version of Octave; please use prod instead");
   endif
 
   retval = prod (varargin{:});
 
 endfunction
diff --git a/scripts/deprecated/spqr.m b/scripts/deprecated/spqr.m
--- a/scripts/deprecated/spqr.m
+++ b/scripts/deprecated/spqr.m
@@ -26,15 +26,15 @@
 
 ## Deprecated in version 3.2
 
 function varargout = spqr (varargin)
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
-	     "spqr is obsolete and will be removed from a future version of Octave; please use qr instead");
+             "spqr is obsolete and will be removed from a future version of Octave; please use qr instead");
   endif
 
   varargout = cell (nargout, 1);
   [ varargout{:} ] = qr (varargin{:});
 
 endfunction
diff --git a/scripts/deprecated/spsum.m b/scripts/deprecated/spsum.m
--- a/scripts/deprecated/spsum.m
+++ b/scripts/deprecated/spsum.m
@@ -23,14 +23,14 @@
 
 ## Deprecated in version 3.2
 
 function retval = spsum (varargin)
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
-	     "spsum is obsolete and will be removed from a future version of Octave; please use sum instead");
+             "spsum is obsolete and will be removed from a future version of Octave; please use sum instead");
   endif
 
   retval = sum (varargin{:});
 
 endfunction
diff --git a/scripts/deprecated/spsumsq.m b/scripts/deprecated/spsumsq.m
--- a/scripts/deprecated/spsumsq.m
+++ b/scripts/deprecated/spsumsq.m
@@ -23,13 +23,13 @@
 
 ## Deprecated in version 3.2
 
 function retval = spsumsq (varargin)
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
-	     "spsumsq is obsolete and will be removed from a future version of Octave; please use sumsq instead");
+             "spsumsq is obsolete and will be removed from a future version of Octave; please use sumsq instead");
   endif
   retval = sumsq (varargin{:});
 
 endfunction
diff --git a/scripts/elfun/lcm.m b/scripts/elfun/lcm.m
--- a/scripts/elfun/lcm.m
+++ b/scripts/elfun/lcm.m
@@ -56,39 +56,39 @@ function l = lcm (varargin)
     endif
 
     if (any (a) == 0)
       l = 0;
     else
       a = abs (a);
       l = a (1);
       for k = 1:(length (a) - 1)
-	l = l * a(k+1) / gcd (l, a(k+1));
+        l = l * a(k+1) / gcd (l, a(k+1));
       endfor
     endif
   else
     
     l = varargin{1};
     sz = size (l);
     nel = numel (l);
 
     for i = 2:nargin
       a = varargin{i};
 
       if (size (a) != sz)
-	if (nel == 1)
-	  sz = size (a);
-	  nel = numel (a);
-	elseif (numel (a) != 1)
-	  error ("lcm: all arguments must be the same size or scalar");
-	endif
+        if (nel == 1)
+          sz = size (a);
+          nel = numel (a);
+        elseif (numel (a) != 1)
+          error ("lcm: all arguments must be the same size or scalar");
+        endif
       endif
 
       if (round (a) != a)
-	error ("lcm: all arguments must be integer");
+        error ("lcm: all arguments must be integer");
       endif
 
       idx = find (l == 0 || a == 0);
       a = abs (a);
       l = l .* a ./ gcd (l, a);
       l(idx) = 0;
     endfor
   endif
diff --git a/scripts/general/bicubic.m b/scripts/general/bicubic.m
--- a/scripts/general/bicubic.m
+++ b/scripts/general/bicubic.m
@@ -74,17 +74,17 @@ function F = bicubic (X, Y, Z, XI, YI, e
     s = Y;
     t = Z;
     Z = X;
     [rz, cz] = size (Z);
   elseif (nargin == 5 || nargin == 6)
     [rz, cz] = size (Z) ; 
     if (isvector (X) && isvector (Y))
       if (rz != length (Y) || cz != length (X))
-	error ("length of X and Y must match the size of Z");
+        error ("length of X and Y must match the size of Z");
       endif
     elseif (size_equal (X, Y) && size_equal (X, Z))
       X = X(1,:);
       Y = Y(:,1);
     else
       error ("X, Y and Z must be martrices of same size");
     endif
     
@@ -179,18 +179,18 @@ function F = bicubic (X, Y, Z, XI, YI, e
   lent = length (ct0);
   lens = length (cs0);
   F = zeros (lent, lens);
   
   for i = 1:lent
     it = indt(i);
     int = [it, it+1, it+2, it+3];
     F(i,:) = ([ct0(i),ct1(i),ct2(i),ct3(i)]
-	      * (p(int,inds) .* cs0 + p(int,inds+1) .* cs1
-		 + p(int,inds+2) .* cs2 + p(int,inds+3) .* cs3));
+              * (p(int,inds) .* cs0 + p(int,inds+1) .* cs1
+                 + p(int,inds+2) .* cs2 + p(int,inds+3) .* cs3));
   endfor
 
   ## Set points outside the table to extrapval.
   if (! (isempty (xfirst_ind) && isempty (xlast_ind)))
     F(:, [xfirst_ind, xlast_ind]) = extrapval;
   endif
   if (! (isempty (yfirst_ind) && isempty (ylast_ind)))
     F([yfirst_ind; ylast_ind], :) = extrapval;
diff --git a/scripts/general/cell2mat.m b/scripts/general/cell2mat.m
--- a/scripts/general/cell2mat.m
+++ b/scripts/general/cell2mat.m
@@ -50,23 +50,23 @@ function m = cell2mat (c)
   if (nb == 0)
     m = [];
   elseif (ndims (c) == 2)
     ## 2d case optimized
     [nr, nc] = size (c);
     if (nc > nr)
       c1 = cell (nr, 1);
       for i = 1 : nr
-	c1{i} = [c{i,:}];
+        c1{i} = [c{i,:}];
       endfor
       m = vertcat (c1 {:});
     else
       c1 = cell (nc, 1);
       for i = 1 : nc
-	c1{i} = vertcat (c{:,i});
+        c1{i} = vertcat (c{:,i});
       endfor
       m = [c1{:}];
     endif
   else
     ## n dimensions case
     for k = ndims (c):-1:2,
       sz = size (c);
       sz(k) = 1;
diff --git a/scripts/general/circshift.m b/scripts/general/circshift.m
--- a/scripts/general/circshift.m
+++ b/scripts/general/circshift.m
@@ -50,40 +50,40 @@ function y = circshift (x, n)
   if (nargin == 2)
     if (isempty (x))
       y = x;
     else
       nd = ndims (x);
       sz = size (x);
 
       if (! isvector (n) && length (n) > nd)
-	error ("circshift: n must be a vector, no longer than the number of dimension in x");
+        error ("circshift: n must be a vector, no longer than the number of dimension in x");
       endif
     
       if (any (n != floor (n)))
-	error ("circshift: all values of n must be integers");
+        error ("circshift: all values of n must be integers");
       endif
 
       idx = cell ();
       for i = 1:length (n);
-	nn = n(i);
-	if (nn < 0)
-	  while (sz(i) <= -nn)
-	    nn = nn + sz(i);
-	  endwhile
-	  idx{i} = [(1-nn):sz(i), 1:-nn];
-	else
-	  while (sz(i) <= nn)
-	    nn = nn - sz(i);
-	  endwhile
-	  idx{i} = [(sz(i)-nn+1):sz(i), 1:(sz(i)-nn)];
-	endif
+        nn = n(i);
+        if (nn < 0)
+          while (sz(i) <= -nn)
+            nn = nn + sz(i);
+          endwhile
+          idx{i} = [(1-nn):sz(i), 1:-nn];
+        else
+          while (sz(i) <= nn)
+            nn = nn - sz(i);
+          endwhile
+          idx{i} = [(sz(i)-nn+1):sz(i), 1:(sz(i)-nn)];
+        endif
       endfor
       for i = (length(n) + 1) : nd
-	idx{i} = 1:sz(i);
+        idx{i} = 1:sz(i);
       endfor
       y = x(idx{:});
     endif
   else
     print_usage ();
   endif
 endfunction
 
diff --git a/scripts/general/cplxpair.m b/scripts/general/cplxpair.m
--- a/scripts/general/cplxpair.m
+++ b/scripts/general/cplxpair.m
@@ -114,26 +114,26 @@ function y = cplxpair (z, tol, dim)
 
   ## For each remaining z, place the value and its conjugate at the
   ## start of the returned list, and remove them from further
   ## consideration.
   for j = 1:m
     p = n - nr(j);
     for i = 1:2:p
       if (i+1 > p)
-	error ("cplxpair could not pair all complex numbers");
+        error ("cplxpair could not pair all complex numbers");
       endif
       [v, idx] = min (abs (z(i+1:p) - conj (z(i))));
       if (v > tol)
-	error ("cplxpair could not pair all complex numbers");
+        error ("cplxpair could not pair all complex numbers");
       endif
       if (imag (z(i)) < 0)
-	y([i, i+1]) = z([i, idx+i]);
+        y([i, i+1]) = z([i, idx+i]);
       else
-	y([i, i+1]) = z([idx+i, i]);
+        y([i, i+1]) = z([idx+i, i]);
       endif
       z(idx+i) = z(i+1);
     endfor
   endfor
 
   ## Reshape the output matrix.
   y = ipermute (reshape (y, sz), perm);
 
@@ -141,19 +141,19 @@ endfunction
 
 %!demo
 %! [ cplxpair(exp(2i*pi*[0:4]'/5)), exp(2i*pi*[3; 2; 4; 1; 0]/5) ]
 
 %!assert (isempty(cplxpair([])));
 %!assert (cplxpair(1), 1)
 %!assert (cplxpair([1+1i, 1-1i]), [1-1i, 1+1i])
 %!assert (cplxpair([1+1i, 1+1i, 1, 1-1i, 1-1i, 2]), \
-%!	  [1-1i, 1+1i, 1-1i, 1+1i, 1, 2])
+%!        [1-1i, 1+1i, 1-1i, 1+1i, 1, 2])
 %!assert (cplxpair([1+1i; 1+1i; 1; 1-1i; 1-1i; 2]), \
-%!	  [1-1i; 1+1i; 1-1i; 1+1i; 1; 2]) 
+%!        [1-1i; 1+1i; 1-1i; 1+1i; 1; 2]) 
 %!assert (cplxpair([0, 1, 2]), [0, 1, 2]);
 
 %!shared z
 %! z=exp(2i*pi*[4; 3; 5; 2; 6; 1; 0]/7);
 %!assert (cplxpair(z(randperm(7))), z);
 %!assert (cplxpair(z(randperm(7))), z);
 %!assert (cplxpair(z(randperm(7))), z);
 %!assert (cplxpair([z(randperm(7)),z(randperm(7))]),[z,z])
diff --git a/scripts/general/cumtrapz.m b/scripts/general/cumtrapz.m
--- a/scripts/general/cumtrapz.m
+++ b/scripts/general/cumtrapz.m
@@ -26,22 +26,22 @@
 ## @var{y} along the first non-singleton dimension.  If the argument 
 ## @var{x} is omitted a equally spaced vector is assumed.  @code{cumtrapz 
 ## (@var{x}, @var{y})} evaluates the cumulative integral with respect 
 ## to @var{x}.
 ##  
 ## @seealso{trapz,cumsum}
 ## @end deftypefn
 
-## Author:	Kai Habel <kai.habel@gmx.de>
+## Author:      Kai Habel <kai.habel@gmx.de>
 ##
 ## also: June 2000 Paul Kienzle (fixes,suggestions) 
 ## 2006-05-12 David Bateman - Modified for NDArrays
 
-function z = cumtrapz (x, y, dim)	
+function z = cumtrapz (x, y, dim)       
 
   if (nargin < 1) || (nargin > 3)
     print_usage ();
   endif
 
   nd = ndims (x);
   sz = size (x);
 
@@ -78,27 +78,27 @@ function z = cumtrapz (x, y, dim)
   endif
 
   n = sz(dim);
   idx1 = cell ();
   for i = 1:nd
     idx1{i} = 1:sz(i);
   endfor
   idx2 = idx1;
-  idx1{dim} = 2 : n;	
+  idx1{dim} = 2 : n;    
   idx2{dim} = 1 : (n - 1);
 
   if (! have_x)
     z = 0.5 * cumsum (x(idx1{:}) + x(idx2{:}), dim);
   else
     if (! size_equal (x, y))
       error ("cumtrapz: x and y must have same shape");
     endif
     z = 0.5 * cumsum ((x(idx1{:}) - x(idx2{:})) .* 
-		      (y(idx1{:}) + y(idx2{:})), dim);
+                      (y(idx1{:}) + y(idx2{:})), dim);
   endif
 
   sz(dim) = 1;
   z = cat (dim, zeros (sz), z);
 
 endfunction
 
 %!shared x1,x2,y
diff --git a/scripts/general/dblquad.m b/scripts/general/dblquad.m
--- a/scripts/general/dblquad.m
+++ b/scripts/general/dblquad.m
@@ -45,17 +45,17 @@ function q = dblquad(f, xa, xb, ya, yb, 
 
   inner = @__dblquad_inner__;
   if (ischar (f))
     f = @(x,y) feval (f, x, y, varargin{:});
     varargin = {};
   endif
 
   q = feval (quadf, @(y) inner (y, f, xa, xb, tol, quadf,
-				varargin{:}), ya, yb, tol);
+                                varargin{:}), ya, yb, tol);
 endfunction
 
 function q = __dblquad_inner__ (y, f, xa, xb, tol, quadf, varargin)
   q = zeros (size(y));
   for i = 1 : length (y)
     q(i) = feval (quadf, @(x) f(x, y(i), varargin{:}), xa, xb, tol);
   endfor
 endfunction
diff --git a/scripts/general/del2.m b/scripts/general/del2.m
--- a/scripts/general/del2.m
+++ b/scripts/general/del2.m
@@ -75,40 +75,40 @@ function D = del2 (M, varargin)
   if (nargin == 2 || nargin == 1)
     if (nargin == 1)
       h = 1;
     else
       h = varargin{1};
     endif
     for i = 1 : nd
       if (isscalar (h))
-	dx{i} = h * ones (sz (i), 1);
+        dx{i} = h * ones (sz (i), 1);
       else
-	if (length (h) == sz (i))
-	  dx{i} = diff (h)(:);
-	else
-	  error ("dimensionality mismatch in %d-th spacing vector", i);
-	endif
+        if (length (h) == sz (i))
+          dx{i} = diff (h)(:);
+        else
+          error ("dimensionality mismatch in %d-th spacing vector", i);
+        endif
       endif
     endfor
   elseif (nargin - 1 == nd)
     ## Reverse dx{1} and dx{2} as the X-dim is the 2nd dim of the ND array
     tmp = varargin{1};
     varargin{1} = varargin{2};
     varargin{2} = tmp;
 
     for i = 1 : nd
       if (isscalar (varargin{i}))
-	dx{i} = varargin{i} * ones (sz (i), 1);
+        dx{i} = varargin{i} * ones (sz (i), 1);
       else
-	if (length (varargin{i}) == sz (i))
-	  dx{i} = diff (varargin{i})(:);
-	else
-	  error ("dimensionality mismatch in %d-th spacing vector", i);
-	endif
+        if (length (varargin{i}) == sz (i))
+          dx{i} = diff (varargin{i})(:);
+        else
+          error ("dimensionality mismatch in %d-th spacing vector", i);
+        endif
       endif
     endfor
   else
     print_usage ();
   endif
 
   idx = cell (1, nd);
   for i = 1: nd
@@ -126,34 +126,34 @@ function D = del2 (M, varargin)
       idx2{i} = 2 : sz(i) - 1;
       idx3{i} = 3 : sz(i);
       szi = sz;
       szi (i) = 1;
 
       h1 = repmat (shiftdim (dx{i}(1 : sz(i) - 2), 1 - i), szi);
       h2 = repmat (shiftdim (dx{i}(2 : sz(i) - 1), 1 - i), szi);
       DD(idx2{:}) = ((M(idx1{:}) - M(idx2{:})) ./ h1 + ...
-		     (M(idx3{:}) - M(idx2{:})) ./ h2) ./ (h1 + h2);
+                     (M(idx3{:}) - M(idx2{:})) ./ h2) ./ (h1 + h2);
 
       ## left and right boundary
       if (sz(i) == 3)
-	DD(idx1{:}) = DD(idx3{:}) = DD(idx2{:});
+        DD(idx1{:}) = DD(idx3{:}) = DD(idx2{:});
       else
-	idx1{i} = 1;
-	idx2{i} = 2;
-	idx3{i} = 3;
-	DD(idx1{:}) = (dx{i}(1) + dx{i}(2)) / dx{i}(2) * DD (idx2{:}) - ...
-	    dx{i}(1) / dx{i}(2) * DD (idx3{:});
+        idx1{i} = 1;
+        idx2{i} = 2;
+        idx3{i} = 3;
+        DD(idx1{:}) = (dx{i}(1) + dx{i}(2)) / dx{i}(2) * DD (idx2{:}) - ...
+            dx{i}(1) / dx{i}(2) * DD (idx3{:});
 
-	idx1{i} = sz(i);
-	idx2{i} = sz(i) - 1;
-	idx3{i} = sz(i) - 2;
-	DD(idx1{:}) =  (dx{i}(sz(i) - 1) + dx{i}(sz(i) - 2)) / ...
-	    dx{i}(sz(i) - 2) * DD (idx2{:}) - ...
-	    dx{i}(sz(i) - 1) / dx{i}(sz(i) - 2) * DD (idx3{:});
+        idx1{i} = sz(i);
+        idx2{i} = sz(i) - 1;
+        idx3{i} = sz(i) - 2;
+        DD(idx1{:}) =  (dx{i}(sz(i) - 1) + dx{i}(sz(i) - 2)) / ...
+            dx{i}(sz(i) - 2) * DD (idx2{:}) - ...
+            dx{i}(sz(i) - 1) / dx{i}(sz(i) - 2) * DD (idx3{:});
       endif
 
       D += DD;
     endif
   endfor
 
   D = D ./ nd;
 endfunction
diff --git a/scripts/general/gradient.m b/scripts/general/gradient.m
--- a/scripts/general/gradient.m
+++ b/scripts/general/gradient.m
@@ -130,17 +130,17 @@ function varargout = matrix_gradient (m,
     endfor
   endif
 
   m = shiftdim (m, 1);
   for i = 1:min (nd, nargout)
     mr = rows (m);
     mc = numel (m) / mr;
     Y = zeros (size (m), class (m));
-	
+        
     if (mr > 1)
       ## Top and bottom boundary.
       Y(1,:) = diff (m(1:2, :)) / d{i}(1);
       Y(mr,:) = diff (m(mr-1:mr, :) / d{i}(mr - 1));
     endif
 
     if (mr > 2)
       ## Interior points.
diff --git a/scripts/general/idivide.m b/scripts/general/idivide.m
--- a/scripts/general/idivide.m
+++ b/scripts/general/idivide.m
@@ -75,17 +75,17 @@ function z = idivide (x, y, op)
   else
     if (isfloat (x))
       typ = class (y);
     elseif (isfloat (y))
       typ = class (x);
     else
       typ = class (x);
       if (!strcmp (class (x), class (y)))
-	error ("idivide: incompatible types");
+        error ("idivide: incompatible types");
       endif
     endif
 
     if (strcmp (op, "fix"))
       z = cast (fix (double (x) ./ double (y)), typ);
     elseif (strcmp (op, "floor"))
       z = cast (floor (double (x) ./ double (y)), typ);
     elseif (strcmp (op, "ceil"))
diff --git a/scripts/general/int2str.m b/scripts/general/int2str.m
--- a/scripts/general/int2str.m
+++ b/scripts/general/int2str.m
@@ -53,17 +53,17 @@ function retval = int2str (x)
   if (nargin == 1)
     x = round (real(x));
     sz = size(x);
     nd = ndims (x);
     nc = columns (x);
     if (nc > 1)
       idx = cell ();
       for i = 1:nd
-	idx{i} = 1:sz(i);
+        idx{i} = 1:sz(i);
       endfor
       idx(2) = 1;
       ifmt = get_fmt (x(idx{:}), 0);
       idx(2) = 2:sz(2);
       rfmt = get_fmt (x(idx{:}), 2);
       fmt = cstrcat (ifmt, repmat (rfmt, 1, nc-1), "\n");
     else
       fmt = cstrcat (get_fmt (x, 0), "\n");
@@ -84,33 +84,33 @@ function fmt = get_fmt (x, sep)
   if (isempty (t))
     ## All zeros.
     fmt = sprintf ("%%%dd", 1 + sep);
   else
     ## Maybe have some zeros.
     nan_inf = isinf (t) | isnan (t);
     if (any (nan_inf))
       if (any (t(nan_inf) < 0))
-	min_fw = 4 + sep;
+        min_fw = 4 + sep;
       else
-	min_fw = 3 + sep;
+        min_fw = 3 + sep;
       endif
     else
       min_fw = 1 + sep;
     endif
     t = t(! nan_inf);
     if (isempty (t))
       ## Only zeros, Inf, and NaN.
       fmt = sprintf ("%%%dd", min_fw);
     else
       ## Could have anything.
       tfw = floor (log10 (double (abs (t)))) + 1 + sep;
       fw = max (tfw);
       if (any (t(tfw == fw) < 0))
-	fw++;
+        fw++;
       endif
       fmt = sprintf ("%%%dd", max (fw, min_fw));
     endif
   endif
 
 endfunction
 
 %!assert(strcmp (int2str (-123), "-123") && strcmp (int2str (1.2), "1"));
diff --git a/scripts/general/interp1.m b/scripts/general/interp1.m
--- a/scripts/general/interp1.m
+++ b/scripts/general/interp1.m
@@ -108,31 +108,31 @@ function yi = interp1 (x, y, varargin)
   xi = [];
   pp = false;
   firstnumeric = true;
 
   if (nargin > 2)
     for i = 1:length (varargin)
       arg = varargin{i};
       if (ischar (arg))
-	arg = tolower (arg);
-	if (strcmp ("extrap", arg))
-	  extrap = "extrap";
-	elseif (strcmp ("pp", arg))
-	  pp = true;
-	else
-	  method = arg;
-	endif
+        arg = tolower (arg);
+        if (strcmp ("extrap", arg))
+          extrap = "extrap";
+        elseif (strcmp ("pp", arg))
+          pp = true;
+        else
+          method = arg;
+        endif
       else
-	if (firstnumeric)
-	  xi = arg;
-	  firstnumeric = false;
-	else
-	  extrap = arg;
-	endif
+        if (firstnumeric)
+          xi = arg;
+          firstnumeric = false;
+        else
+          extrap = arg;
+        endif
       endif
     endfor
   endif
 
   ## reshape matrices for convenience
   x = x(:);
   nx = rows (x);
   szx = size (xi);
@@ -406,174 +406,174 @@ endfunction
 %!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
 %!assert (interp1(xp,yp,xp,style), yp, 100*eps);
 %!assert (interp1(xp,yp,xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp,style), yp, 100*eps);
 %!assert (isempty(interp1(xp',yp',[],style)));
 %!assert (isempty(interp1(xp,yp,[],style)));
 %!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!	  [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
 %!assert (interp1(xp,yp,xi,style),...
-%!	  interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
+%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
 %!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!	  interp1(xp,yp,xi,style,"extrap"),10*eps);
+%!        interp1(xp,yp,xi,style,"extrap"),10*eps);
 %!error interp1(1,1,1, style);
 %!assert (interp1(xp,[yp',yp'],xi,style),
-%!	  interp1(xp,[yp',yp'],xi,["*",style]),100*eps);
+%!        interp1(xp,[yp',yp'],xi,["*",style]),100*eps);
 %!test style=['*',style];
 %!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
 %!assert (interp1(xp,yp,xp,style), yp, 100*eps);
 %!assert (interp1(xp,yp,xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp,style), yp, 100*eps);
 %!assert (isempty(interp1(xp',yp',[],style)));
 %!assert (isempty(interp1(xp,yp,[],style)));
 %!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!	  [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
 %!assert (interp1(xp,yp,xi,style),...
-%!	  interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
+%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
 %!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!	  interp1(xp,yp,xi,style,"extrap"),10*eps);
+%!        interp1(xp,yp,xi,style,"extrap"),10*eps);
 %!error interp1(1,1,1, style);
 ## ENDBLOCK
 %!test style='linear';
 ## BLOCK
 %!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
 %!assert (interp1(xp,yp,xp,style), yp, 100*eps);
 %!assert (interp1(xp,yp,xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp,style), yp, 100*eps);
 %!assert (isempty(interp1(xp',yp',[],style)));
 %!assert (isempty(interp1(xp,yp,[],style)));
 %!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!	  [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
 %!assert (interp1(xp,yp,xi,style),...
-%!	  interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
+%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
 %!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!	  interp1(xp,yp,xi,style,"extrap"),10*eps);
+%!        interp1(xp,yp,xi,style,"extrap"),10*eps);
 %!error interp1(1,1,1, style);
 %!assert (interp1(xp,[yp',yp'],xi,style),
-%!	  interp1(xp,[yp',yp'],xi,["*",style]),100*eps);
+%!        interp1(xp,[yp',yp'],xi,["*",style]),100*eps);
 %!test style=['*',style];
 %!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
 %!assert (interp1(xp,yp,xp,style), yp, 100*eps);
 %!assert (interp1(xp,yp,xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp,style), yp, 100*eps);
 %!assert (isempty(interp1(xp',yp',[],style)));
 %!assert (isempty(interp1(xp,yp,[],style)));
 %!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!	  [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
 %!assert (interp1(xp,yp,xi,style),...
-%!	  interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
+%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
 %!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!	  interp1(xp,yp,xi,style,"extrap"),10*eps);
+%!        interp1(xp,yp,xi,style,"extrap"),10*eps);
 %!error interp1(1,1,1, style);
 ## ENDBLOCK
 %!test style='cubic';
 ## BLOCK
 %!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
 %!assert (interp1(xp,yp,xp,style), yp, 100*eps);
 %!assert (interp1(xp,yp,xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp,style), yp, 100*eps);
 %!assert (isempty(interp1(xp',yp',[],style)));
 %!assert (isempty(interp1(xp,yp,[],style)));
 %!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!	  [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
 %!assert (interp1(xp,yp,xi,style),...
-%!	  interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
+%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
 %!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!	  interp1(xp,yp,xi,style,"extrap"),100*eps);
+%!        interp1(xp,yp,xi,style,"extrap"),100*eps);
 %!error interp1(1,1,1, style);
 %!assert (interp1(xp,[yp',yp'],xi,style),
-%!	  interp1(xp,[yp',yp'],xi,["*",style]),100*eps);
+%!        interp1(xp,[yp',yp'],xi,["*",style]),100*eps);
 %!test style=['*',style];
 %!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
 %!assert (interp1(xp,yp,xp,style), yp, 100*eps);
 %!assert (interp1(xp,yp,xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp,style), yp, 100*eps);
 %!assert (isempty(interp1(xp',yp',[],style)));
 %!assert (isempty(interp1(xp,yp,[],style)));
 %!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!	  [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
 %!assert (interp1(xp,yp,xi,style),...
-%!	  interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
+%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
 %!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!	  interp1(xp,yp,xi,style,"extrap"),100*eps);
+%!        interp1(xp,yp,xi,style,"extrap"),100*eps);
 %!error interp1(1,1,1, style);
 ## ENDBLOCK
 %!test style='pchip';
 ## BLOCK
 %!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
 %!assert (interp1(xp,yp,xp,style), yp, 100*eps);
 %!assert (interp1(xp,yp,xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp,style), yp, 100*eps);
 %!assert (isempty(interp1(xp',yp',[],style)));
 %!assert (isempty(interp1(xp,yp,[],style)));
 %!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!	  [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
 %!assert (interp1(xp,yp,xi,style),...
-%!	  interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
+%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
 %!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!	  interp1(xp,yp,xi,style,"extrap"),10*eps);
+%!        interp1(xp,yp,xi,style,"extrap"),10*eps);
 %!error interp1(1,1,1, style);
 %!assert (interp1(xp,[yp',yp'],xi,style),
-%!	  interp1(xp,[yp',yp'],xi,["*",style]),100*eps);
+%!        interp1(xp,[yp',yp'],xi,["*",style]),100*eps);
 %!test style=['*',style];
 %!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
 %!assert (interp1(xp,yp,xp,style), yp, 100*eps);
 %!assert (interp1(xp,yp,xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp,style), yp, 100*eps);
 %!assert (isempty(interp1(xp',yp',[],style)));
 %!assert (isempty(interp1(xp,yp,[],style)));
 %!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!	  [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
 %!assert (interp1(xp,yp,xi,style),...
-%!	  interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
+%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
 %!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!	  interp1(xp,yp,xi,style,"extrap"),10*eps);
+%!        interp1(xp,yp,xi,style,"extrap"),10*eps);
 %!error interp1(1,1,1, style);
 ## ENDBLOCK
 %!test style='spline';
 ## BLOCK
 %!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
 %!assert (interp1(xp,yp,xp,style), yp, 100*eps);
 %!assert (interp1(xp,yp,xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp,style), yp, 100*eps);
 %!assert (isempty(interp1(xp',yp',[],style)));
 %!assert (isempty(interp1(xp,yp,[],style)));
 %!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!	  [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
 %!assert (interp1(xp,yp,xi,style),...
-%!	  interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
+%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
 %!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!	  interp1(xp,yp,xi,style,"extrap"),10*eps);
+%!        interp1(xp,yp,xi,style,"extrap"),10*eps);
 %!error interp1(1,1,1, style);
 %!assert (interp1(xp,[yp',yp'],xi,style),
-%!	  interp1(xp,[yp',yp'],xi,["*",style]),100*eps);
+%!        interp1(xp,[yp',yp'],xi,["*",style]),100*eps);
 %!test style=['*',style];
 %!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
 %!assert (interp1(xp,yp,xp,style), yp, 100*eps);
 %!assert (interp1(xp,yp,xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp,style), yp, 100*eps);
 %!assert (isempty(interp1(xp',yp',[],style)));
 %!assert (isempty(interp1(xp,yp,[],style)));
 %!assert (interp1(xp,[yp',yp'],xi(:),style),...
-%!	  [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
+%!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
 %!assert (interp1(xp,yp,xi,style),...
-%!	  interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
+%!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
 %!assert (ppval(interp1(xp,yp,style,"pp"),xi),
-%!	  interp1(xp,yp,xi,style,"extrap"),10*eps);
+%!        interp1(xp,yp,xi,style,"extrap"),10*eps);
 %!error interp1(1,1,1, style);
 ## ENDBLOCK
 ## ENDBLOCKTEST
 
 %!# test linear extrapolation
 %!assert (interp1([1:5],[3:2:11],[0,6],"linear","extrap"), [1, 13], eps);
 %!assert (interp1(xp, yp, [-1, max(xp)+1],"linear",5), [5, 5]);
 
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -68,17 +68,17 @@
 ## If a scalar value @var{extrapval} is defined as the final value, then
 ## values outside the mesh as set to this value.  Note that in this case 
 ## @var{method} must be defined as well.  If @var{extrapval} is not
 ## defined then NA is assumed. 
 ##
 ## @seealso{interp1}
 ## @end deftypefn
 
-## Author:	Kai Habel <kai.habel@gmx.de>
+## Author:      Kai Habel <kai.habel@gmx.de>
 ## 2005-03-02 Thomas Weber <weber@num.uni-sb.de> 
 ##     * Add test cases
 ## 2005-03-02 Paul Kienzle <pkienzle@users.sf.net>
 ##     * Simplify
 ## 2005-04-23 Dmitri A. Sergatskov <dasergatskov@gmail.com>
 ##     * Modified demo and test for new gnuplot interface
 ## 2005-09-07 Hoxide <hoxide_dirac@yahoo.com.cn>
 ##     * Add bicubic interpolation method
@@ -94,42 +94,42 @@ function ZI = interp2 (varargin)
   method = "linear";
   extrapval = NA;
 
   switch (nargin)
     case 1
       Z = varargin{1};
     case 2
       if (ischar (varargin{2}))
-	[Z, method] = deal (varargin{:});
+        [Z, method] = deal (varargin{:});
       else
-	[Z, n] = deal (varargin{:});
+        [Z, n] = deal (varargin{:});
       endif
     case 3
       if (ischar (varargin{3}))
-	[Z, n, method] = deal (varargin{:});
+        [Z, n, method] = deal (varargin{:});
       else
-	[Z, XI, YI] = deal (varargin{:});
+        [Z, XI, YI] = deal (varargin{:});
       endif
     case 4
       if (ischar (varargin{4}))
-	[Z, XI, YI, method] = deal (varargin{:});
+        [Z, XI, YI, method] = deal (varargin{:});
       else
-	[Z, n, method, extrapval] = deal (varargin{:});
+        [Z, n, method, extrapval] = deal (varargin{:});
       endif
     case 5
       if (ischar (varargin{4}))
-	[Z, XI, YI, method, extrapval] = deal (varargin{:});
+        [Z, XI, YI, method, extrapval] = deal (varargin{:});
       else
-	[X, Y, Z, XI, YI] = deal (varargin{:});
+        [X, Y, Z, XI, YI] = deal (varargin{:});
       endif
     case 6 
-	[X, Y, Z, XI, YI, method] = deal (varargin{:});
+        [X, Y, Z, XI, YI, method] = deal (varargin{:});
     case 7
-	[X, Y, Z, XI, YI, method, extrapval] = deal (varargin{:});
+        [X, Y, Z, XI, YI, method, extrapval] = deal (varargin{:});
     otherwise
       print_usage ();
   endswitch
 
   ## Type checking.
   if (!ismatrix (Z))
     error ("interp2 expected matrix Z"); 
   endif
@@ -176,17 +176,17 @@ function ZI = interp2 (varargin)
       error ("X and Y must be matrices of same size");
     endif
     if (columns (Z) != length (X) || rows (Z) != length (Y))
       error ("X and Y size must match Z dimensions");
     endif
 
     ## If Xi and Yi are vectors of different orientation build a grid
     if ((rows (XI) == 1 && columns (YI) == 1)
-	|| (columns (XI) == 1 && rows (YI) == 1))
+        || (columns (XI) == 1 && rows (YI) == 1))
       [XI, YI] = meshgrid (XI, YI);
     elseif (! size_equal (XI, YI))
       error ("XI and YI must be matrices of same size");
     endif
 
     ## if XI, YI are vectors, X and Y should share their orientation.
     if (rows (XI) == 1)
       if (rows (X) != 1)
@@ -234,17 +234,17 @@ function ZI = interp2 (varargin)
       ii = (XI - X(xidx) >= X(xidx + 1) - XI);
       jj = (YI - Y(yidx) >= Y(yidx + 1) - YI);
       idx = sub2ind (size (Z), yidx+jj, xidx+ii);
       ZI = Z(idx);
 
     elseif (strcmp (method, "pchip"))
 
       if (length (X) < 2 || length (Y) < 2)
-	error ("interp2: pchip2 requires at least 2 points in each dimension")
+        error ("interp2: pchip2 requires at least 2 points in each dimension")
       endif
 
       ## first order derivatives
       DX = __pchip_deriv__ (X, Z, 2);
       DY = __pchip_deriv__ (Y, Z, 1);
       ## Compute mixed derivatives row-wise and column-wise, use the average.
       DXY = (__pchip_deriv__ (X, DY, 2) + __pchip_deriv__ (Y, DX, 1))/2;
       
@@ -279,67 +279,67 @@ function ZI = interp2 (varargin)
       t1 = t2 - t1;
       yb{2,1} = hy.*(t1 + ty);
       t2 += t1;
       yb{1,2} = -t2;
       yb{1,1} = t2 + 1;
 
       ZI = zeros (size (XI));
       for i = 1:2
-	for j = 1:2
-	  zidx = sub2ind (size (Z), yidx+(j-1), xidx+(i-1));
-	  ZI += xb{1,i} .* yb{1,j} .*   Z(zidx);
-	  ZI += xb{2,i} .* yb{1,j} .*  DX(zidx);
-	  ZI += xb{1,i} .* yb{2,j} .*  DY(zidx);
-	  ZI += xb{2,i} .* yb{2,j} .* DXY(zidx);
-	endfor
+        for j = 1:2
+          zidx = sub2ind (size (Z), yidx+(j-1), xidx+(i-1));
+          ZI += xb{1,i} .* yb{1,j} .*   Z(zidx);
+          ZI += xb{2,i} .* yb{1,j} .*  DX(zidx);
+          ZI += xb{1,i} .* yb{2,j} .*  DY(zidx);
+          ZI += xb{2,i} .* yb{2,j} .* DXY(zidx);
+        endfor
       endfor
 
     endif
 
     if (! isempty (extrapval))
       ## set points outside the table to 'extrapval'
       if (X (1) < X (end))
-	if (Y (1) < Y (end))
-	  ZI (XI < X(1,1) | XI > X(end) | YI < Y(1,1) | YI > Y(end)) = ...
-		  extrapval;
-	else
-	  ZI (XI < X(1) | XI > X(end) | YI < Y(end) | YI > Y(1)) = ...
-		  extrapval;
-	endif
+        if (Y (1) < Y (end))
+          ZI (XI < X(1,1) | XI > X(end) | YI < Y(1,1) | YI > Y(end)) = ...
+                  extrapval;
+        else
+          ZI (XI < X(1) | XI > X(end) | YI < Y(end) | YI > Y(1)) = ...
+                  extrapval;
+        endif
       else
-	if (Y (1) < Y (end))
-	  ZI (XI < X(end) | XI > X(1) | YI < Y(1) | YI > Y(end)) = ...
-		  extrapval;
-	else
-	  ZI (XI < X(1,end) | XI > X(1) | YI < Y(end) | YI > Y(1)) = ...
-		  extrapval;
-	endif
+        if (Y (1) < Y (end))
+          ZI (XI < X(end) | XI > X(1) | YI < Y(1) | YI > Y(end)) = ...
+                  extrapval;
+        else
+          ZI (XI < X(1,end) | XI > X(1) | YI < Y(end) | YI > Y(1)) = ...
+                  extrapval;
+        endif
       endif
     endif
 
   else
 
     ## If X and Y vectors produce a grid from them
     if (isvector (X) && isvector (Y))
       X = X(:).';
       Y = Y(:);
       if (!isequal ([length(X), length(Y)], size(Z)))
-	error ("X and Y size must match Z dimensions");
+        error ("X and Y size must match Z dimensions");
       endif
     elseif (!size_equal (X, Y))
       error ("X and Y must be matrices of same size");
       if (! size_equal (X, Z))
-	error ("X and Y size must match Z dimensions");
+        error ("X and Y size must match Z dimensions");
       endif
     endif
 
     ## If Xi and Yi are vectors of different orientation build a grid
     if ((rows (XI) == 1 && columns (YI) == 1)
-	|| (columns (XI) == 1 && rows (YI) == 1))
+        || (columns (XI) == 1 && rows (YI) == 1))
       ## Do nothing
     elseif (! size_equal (XI, YI))
       error ("XI and YI must be matrices of same size");
     endif
 
     ## FIXME bicubic/__splinen__ don't handle arbitrary XI, YI
     if (strcmp (method, "cubic"))
       if (isgriddata (XI) && isgriddata (YI'))
@@ -391,17 +391,17 @@ function ZI = interp2 (varargin)
       
       else
         error ("interp2: input data must have `meshgrid' format");
       endif
 
     elseif (strcmp (method, "spline"))
       if (isgriddata (XI) && isgriddata (YI'))
         ZI = __splinen__ ({Y(:,1).', X(1,:)}, Z, {YI(:,1), XI(1,:)}, extrapval, 
-			"spline");
+                        "spline");
       else
         error ("interp2: input data must have `meshgrid' format");
       endif
     else
       error ("interpolation method not recognized");
     endif
 
   endif
diff --git a/scripts/general/interp3.m b/scripts/general/interp3.m
--- a/scripts/general/interp3.m
+++ b/scripts/general/interp3.m
@@ -78,55 +78,55 @@ function vi = interp3 (varargin)
       error ("extrapal is expected to be a numeric scalar");
     endif
     extrapval = varargin{end};
     method = varargin{end-1};
     nargs = nargs - 2;
   endif
 
   if (nargs < 3 || (nargs == 4 && ! isvector (varargin{1})
-		    && nargs == (ndims (varargin{1}) + 1)))
+                    && nargs == (ndims (varargin{1}) + 1)))
     v = varargin{1};
     if (ndims (v) != 3)
       error ("expect 3-dimensional array of values");
     endif
     x = varargin (2:4);
     if (any (! cellfun (@isvector, x)))
       for i = 2 : 3
-	if (! size_equal (x{1}, x{i}))
-	  error ("dimensional mismatch");
-	endif
-	x{i} = permute (x{i}, [2, 1, 3]);
+        if (! size_equal (x{1}, x{i}))
+          error ("dimensional mismatch");
+        endif
+        x{i} = permute (x{i}, [2, 1, 3]);
       endfor
       x{1} = permute (x{1}, [2, 1, 3]);
     endif
     v = permute (v, [2, 1, 3]);
     vi = ipermute (interpn (v, x{:}, method, extrapval), [2, 1, 3]);
   elseif (nargs == 7 && nargs == (2 * ndims (varargin{ceil (nargs / 2)})) + 1)
     v = varargin{4};
     if (ndims (v) != 3)
       error ("expect 3-dimensional array of values");
     endif
     x = varargin (1:3);
     if (any (! cellfun (@isvector, x)))
       for i = 2 : 3
-	if (! size_equal (x{1}, x{i}) || ! size_equal (x{i}, v))
-	  error ("dimensional mismatch");
-	endif
-	x{i} = permute (x{i}, [2, 1, 3]);
+        if (! size_equal (x{1}, x{i}) || ! size_equal (x{i}, v))
+          error ("dimensional mismatch");
+        endif
+        x{i} = permute (x{i}, [2, 1, 3]);
       endfor
       x{1} = permute (x{1}, [2, 1, 3]);
     endif
     y = varargin (5:7);
     if (any (! cellfun (@isvector, y)))
       for i = 2 : 3
-	if (! size_equal (y{1}, y{i}))
-	  error ("dimensional mismatch");
-	endif
-	y{i} = permute (y{i}, [2, 1, 3]);
+        if (! size_equal (y{1}, y{i}))
+          error ("dimensional mismatch");
+        endif
+        y{i} = permute (y{i}, [2, 1, 3]);
       endfor
       y{1} = permute (y{1}, [2, 1, 3]);
     endif
     v = permute (v, [2, 1, 3]);
     vi = ipermute (interpn (x{:}, v, y{:}, method, extrapval), [2, 1, 3]);
   else
     error ("wrong number or incorrectly formatted input arguments");
   endif
diff --git a/scripts/general/interpn.m b/scripts/general/interpn.m
--- a/scripts/general/interpn.m
+++ b/scripts/general/interpn.m
@@ -84,17 +84,17 @@ function vi = interpn (varargin)
   endif
 
   if (nargs < 3)
     v = varargin{1};
     m = 1;
     if (nargs == 2)
       m = varargin{2};
       if (! isnumeric (m) || ! isscalar (m) || floor (m) != m)
-	error ("m is expected to be a integer scalar");
+        error ("m is expected to be a integer scalar");
       endif
     endif
     sz = size (v);
     nd = ndims (v);
     x = cell (1, nd);
     y = cell (1, nd);
     for i = 1 : nd;
       x{i} = 1 : sz(i);
@@ -105,31 +105,31 @@ function vi = interpn (varargin)
     sz = size (v);
     nd = ndims (v);
     x = cell (1, nd);
     y = varargin (2 : nargs);
     for i = 1 : nd;
       x{i} = 1 : sz(i);
     endfor
   elseif (rem (nargs, 2) == 1 && nargs ==  
-	  (2 * ndims (varargin{ceil (nargs / 2)})) + 1)
+          (2 * ndims (varargin{ceil (nargs / 2)})) + 1)
     nv = ceil (nargs / 2);
     v = varargin{nv};
     sz = size (v);
     nd = ndims (v);
     x = varargin (1 : (nv - 1));
     y = varargin ((nv + 1) : nargs);
   else
     error ("wrong number or incorrectly formatted input arguments");
   endif
 
   if (any (! cellfun (@isvector, x)))
     for i = 2 : nd
       if (! size_equal (x{1}, x{i}) || ! size_equal (x{i}, v))
-	error ("dimensional mismatch");
+        error ("dimensional mismatch");
       endif
       idx (1 : nd) = {1};
       idx (i) = ":";
       x{i} = x{i}(idx{:})(:);
     endfor
     idx (1 : nd) = {1};
     idx (1) = ":";
     x{1} = x{1}(idx{:})(:);
@@ -156,37 +156,37 @@ function vi = interpn (varargin)
     for i = 1 : nd
       idx |= y{i} < min (x{i}(:)) | y{i} > max (x{i}(:));
     endfor
     vi(idx) = extrapval;
     vi = reshape (vi, yshape); 
   elseif (strcmp (method, "spline"))
     if (any (! cellfun (@isvector, y)))
       for i = 2 : nd
-	if (! size_equal (y{1}, y{i}))
-	  error ("dimensional mismatch");
-	endif
-	idx (1 : nd) = {1};
-	idx (i) = ":";
-	y{i} = y{i}(idx{:});
+        if (! size_equal (y{1}, y{i}))
+          error ("dimensional mismatch");
+        endif
+        idx (1 : nd) = {1};
+        idx (i) = ":";
+        y{i} = y{i}(idx{:});
       endfor
       idx (1 : nd) = {1};
       idx (1) = ":";
       y{1} = y{1}(idx{:});
     endif
 
     vi = __splinen__ (x, v, y, extrapval, "interpn");
 
     if (size_equal (y{:}))
       ly = length (y{1});
       idx = cell (1, ly);
       q = cell (1, nd);
       for i = 1 : ly
- 	q(:) = i;
- 	idx {i} = q;
+        q(:) = i;
+        idx {i} = q;
       endfor
       vi = vi (cellfun (@(x) sub2ind (size(vi), x{:}), idx));
       vi = reshape (vi, size(y{1}));
     endif
   elseif (strcmp (method, "cubic")) 
     error ("cubic interpolation not yet implemented");
   else
     error ("unrecognized interpolation method");
diff --git a/scripts/general/isa.m b/scripts/general/isa.m
--- a/scripts/general/isa.m
+++ b/scripts/general/isa.m
@@ -28,18 +28,18 @@ function retval = isa (x, cname)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   persistent float_classes = {"double", "single"};
 
   persistent fnum_classes = {"double", "single", ...
-			     "uint8", "uint16", "uint32", "uint64", ...
-			     "int8", "int16", "int32", "int64"};
+                             "uint8", "uint16", "uint32", "uint64", ...
+                             "int8", "int16", "int32", "int64"};
 
   if (strcmp (cname, "float"))
     retval = any (strcmp (class (x), float_classes));
   elseif (strcmp (cname, "numeric"))
     retval = any (strcmp (class (x), fnum_classes));
   else
     class_of_x = class (x);
     retval = strcmp (class_of_x, cname);
diff --git a/scripts/general/num2str.m b/scripts/general/num2str.m
--- a/scripts/general/num2str.m
+++ b/scripts/general/num2str.m
@@ -69,44 +69,44 @@ function retval = num2str (x, arg)
 
   if (ischar (x))
     retval = x;
   elseif (isempty (x))
     retval = "";
   elseif (iscomplex (x))
     if (nargin == 2)
       if (ischar (arg))
-	fmt = cstrcat (arg, "%-+", arg(2:end), "i");
+        fmt = cstrcat (arg, "%-+", arg(2:end), "i");
       else
-	if (isnumeric (x) && round (x) == x && abs (x) < (10 .^ arg))
-	  fmt = sprintf ("%%%dd%%-+%ddi  ", arg, arg);
-	else
-	  fmt = sprintf ("%%%d.%dg%%-+%d.%dgi", arg+7, arg, arg+7, arg);
-	endif
+        if (isnumeric (x) && round (x) == x && abs (x) < (10 .^ arg))
+          fmt = sprintf ("%%%dd%%-+%ddi  ", arg, arg);
+        else
+          fmt = sprintf ("%%%d.%dg%%-+%d.%dgi", arg+7, arg, arg+7, arg);
+        endif
       endif
     else
       ## Setup a suitable format string
       if (isnumeric (x) && round (x) == x && abs (x) < 1e10)
-	if (max (abs (real (x(:)))) == 0)
-	  dgt1 = 2;
-	else
-	  dgt1 = ceil (log10 (max (max (abs (real (x(:)))),
-				   max (abs (imag (x(:))))))) + 2;
-	endif
-	dgt2 = dgt1 - (min (real (x(:))) >= 0);
-	
-	if (length (abs (x) == x) > 0)
-	  fmt = sprintf("%%%dg%%+-%dgi  ", dgt2, dgt1);
-	else
-	  fmt = sprintf("%%%dd%%+-%ddi  ", dgt2, dgt1);
-	endif
+        if (max (abs (real (x(:)))) == 0)
+          dgt1 = 2;
+        else
+          dgt1 = ceil (log10 (max (max (abs (real (x(:)))),
+                                   max (abs (imag (x(:))))))) + 2;
+        endif
+        dgt2 = dgt1 - (min (real (x(:))) >= 0);
+        
+        if (length (abs (x) == x) > 0)
+          fmt = sprintf("%%%dg%%+-%dgi  ", dgt2, dgt1);
+        else
+          fmt = sprintf("%%%dd%%+-%ddi  ", dgt2, dgt1);
+        endif
       elseif (isscalar (x))
-	fmt = "%.6g%-+.6gi";
+        fmt = "%.6g%-+.6gi";
       else
-	fmt = "%11.6g%-+11.6gi";
+        fmt = "%11.6g%-+11.6gi";
       endif
     endif
 
     ## Manipulate the complex value to have real values in the odd
     ## columns and imaginary values in the even columns.
     sz = size (x);
     nc = sz(2);
     nd = ndims (x);
@@ -122,59 +122,59 @@ function retval = num2str (x, arg)
 
     fmt = cstrcat (deblank (repmat (fmt, 1, nc)), "\n");
     tmp = sprintf (fmt, permute (x, [2, 1, 3:nd]));
 
     ## Put the "i"'s where they are supposed to be.
     while (true)
       tmp2 = strrep (tmp, " i\n", "i\n");
       if (length (tmp) == length (tmp2))
-	break;
+        break;
       else
-	tmp = tmp2;
+        tmp = tmp2;
       endif
     endwhile
     while (true)
       tmp2 = strrep (tmp, " i", "i ");
       if (tmp == tmp2)
-	break;
+        break;
       else
-	tmp = tmp2;
+        tmp = tmp2;
       endif
     endwhile
 
     tmp(length (tmp)) = "";
     retval = char (strtrim (strsplit (tmp, "\n")));
   else
     if (nargin == 2)
       if (ischar (arg))
-	fmt = arg;
+        fmt = arg;
       else
-	if (isnumeric (x) && round (x) == x && abs (x) < (10 .^ arg))
-	  fmt = sprintf ("%%%dd  ", arg);
-	else
-	  fmt = sprintf ("%%%d.%dg", arg+7, arg);
-	endif
+        if (isnumeric (x) && round (x) == x && abs (x) < (10 .^ arg))
+          fmt = sprintf ("%%%dd  ", arg);
+        else
+          fmt = sprintf ("%%%d.%dg", arg+7, arg);
+        endif
       endif
     else
       if (isnumeric (x) && round (x) == x && abs (x) < 1e10)
-	if (max (abs (x(:))) == 0)
-	  dgt = 2;
-	else
-	  dgt = floor (log10 (max (abs(x(:))))) + (min (real (x(:))) < 0) + 2;
-	endif
-	if (length (abs (x) == x) > 0)
-	  fmt = sprintf ("%%%dg  ", dgt);
-	else
-	  fmt = sprintf ("%%%dd  ", dgt);
-	endif
+        if (max (abs (x(:))) == 0)
+          dgt = 2;
+        else
+          dgt = floor (log10 (max (abs(x(:))))) + (min (real (x(:))) < 0) + 2;
+        endif
+        if (length (abs (x) == x) > 0)
+          fmt = sprintf ("%%%dg  ", dgt);
+        else
+          fmt = sprintf ("%%%dd  ", dgt);
+        endif
       elseif (isscalar (x))
-	fmt = "%11.5g";
+        fmt = "%11.5g";
       else
-	fmt = "%11.5g";
+        fmt = "%11.5g";
       endif
     endif
     fmt = cstrcat (deblank (repmat (fmt, 1, columns (x))), "\n");
     nd = ndims (x);
     tmp = sprintf (fmt, permute (x, [2, 1, 3:nd]));
     tmp(length (tmp)) = "";
     retval = strtrim (char (strsplit (tmp, "\n")));
   endif
diff --git a/scripts/general/postpad.m b/scripts/general/postpad.m
--- a/scripts/general/postpad.m
+++ b/scripts/general/postpad.m
@@ -48,17 +48,17 @@ function y = postpad (x, l, c, dim)
     while (dim < nd + 1 && sz (dim) == 1)
       dim = dim + 1;
     endwhile
     if (dim > nd)
       dim = 1;
     endif
   else
     if (! (isscalar (dim) && dim == round (dim)) && dim > 0 && 
-	dim < (nd + 1))
+        dim < (nd + 1))
       error ("postpad: dim must be an integer and valid dimension");
     endif
   endif
 
   if (! isscalar (l) || l < 0)
     error ("second argument must be a positive scaler");
   endif
 
diff --git a/scripts/general/prepad.m b/scripts/general/prepad.m
--- a/scripts/general/prepad.m
+++ b/scripts/general/prepad.m
@@ -59,17 +59,17 @@ function y = prepad (x, l, c, dim)
     while (dim < nd + 1 && sz (dim) == 1)
       dim = dim + 1;
     endwhile
     if (dim > nd)
       dim = 1;
     endif
   else
     if (! (isscalar (dim) && dim == round (dim)) && dim > 0 && 
-	dim < (nd + 1))
+        dim < (nd + 1))
       error ("prepad: dim must be an integer and valid dimension");
     endif
   endif
 
   if (! isscalar (l) || l < 0)
     error ("second argument must be a positive scaler");
   endif
 
diff --git a/scripts/general/private/__isequal__.m b/scripts/general/private/__isequal__.m
--- a/scripts/general/private/__isequal__.m
+++ b/scripts/general/private/__isequal__.m
@@ -54,19 +54,19 @@ function t = __isequal__ (nans_compare_e
 
   l_v = nargin - 2;
 
   ## Generic tests.
 
   ## All arguments must either be of the same class or they must be
   ## numeric values.
   t = (all (strcmp (class(x),
-		   cellfun (@class, varargin, "UniformOutput", false)))
+                   cellfun (@class, varargin, "UniformOutput", false)))
        || ((isnumeric (x) || islogical (x))
-	   && all ((cellfun (@isnumeric, varargin) | cellfun (@islogical, varargin)))));
+           && all ((cellfun (@isnumeric, varargin) | cellfun (@islogical, varargin)))));
 
   if (t)
     ## Test that everything has the same number of dimensions.
     s_x = size (x);
     s_v = cellfun (@size, varargin, "UniformOutput", false);
     t = all (length (s_x) == cellfun (@length, s_v));
   endif
 
@@ -90,93 +90,93 @@ function t = __isequal__ (nans_compare_e
       l_fn_x = length (fn_x);
       fn_v = cellfun (@fieldnames, varargin, "UniformOutput", false);
       t = all (l_fn_x == cellfun (@length, fn_v));
 
       ## Test that all the names are equal.
       idx = 0;
       s_fn_x = sort (fn_x);
       while (t && idx < l_v)
-	idx++;
-	## We'll allow the fieldnames to be in a different order.
-	t = all (strcmp (s_fn_x, sort (fn_v{idx})));
+        idx++;
+        ## We'll allow the fieldnames to be in a different order.
+        t = all (strcmp (s_fn_x, sort (fn_v{idx})));
       endwhile
 
       idx = 0;
       while (t && idx < l_fn_x)
-	## Test that all field values are equal.
-	idx++;
-	args = {nans_compare_equal, {x.(fn_x{idx})}};
-	for argn = 1:l_v
-	  args{argn+2} = {varargin{argn}.(fn_x{idx})};
-	endfor
-	## Minimize function calls by calling for all the arguments at
-	## once.
+        ## Test that all field values are equal.
+        idx++;
+        args = {nans_compare_equal, {x.(fn_x{idx})}};
+        for argn = 1:l_v
+          args{argn+2} = {varargin{argn}.(fn_x{idx})};
+        endfor
+        ## Minimize function calls by calling for all the arguments at
+        ## once.
         t = __isequal__ (args{:});
       endwhile
 
     elseif (iscell (x))
       ## Check that each element of a cell is equal.
       l_x = numel (x);
       idx = 0;
       while (t && idx < l_x)
-	idx++;
-	args = {nans_compare_equal, x{idx}};
-	for p = 1:l_v
-	  args{p+2} = varargin{p}{idx};
-	endfor
+        idx++;
+        args = {nans_compare_equal, x{idx}};
+        for p = 1:l_v
+          args{p+2} = varargin{p}{idx};
+        endfor
         t = __isequal__ (args{:});
       endwhile
 
     elseif (ischar (x))
 
       ## Sizes are equal already, so we can just make everything into a
       ## row and test the rows.
       for i = 1:l_v
-	strings{i} = reshape (varargin{i}, 1, []);
+        strings{i} = reshape (varargin{i}, 1, []);
       endfor
       t = all (strcmp (reshape (x, 1, []), strings));
 
     elseif (isa (x, "function_handle"))
 
       ## The == operator is overloaded for handles.
       t = all (cellfun (@eq, {x}, varargin));
 
     else
       ## Check the numeric types.
 
       if (issparse (x))
-	f_x = spfind (x);
+        f_x = spfind (x);
       else
-	f_x = find (x);
+        f_x = find (x);
       endif
       l_f_x = length (f_x);
       x = x(f_x);
       for argn = 1:l_v
-	y = varargin{argn};
-	if (issparse (y))
+        y = varargin{argn};
+        if (issparse (y))
           f_y = spfind (y);
-	else
+        else
           f_y = find (y);
-	endif
+        endif
 
-	t = (l_f_x == length (f_y)) && all (f_x == f_y);
-	if (!t)
+        t = (l_f_x == length (f_y)) && all (f_x == f_y);
+        if (!t)
           return;
-	endif
+        endif
 
-	y = y(f_y);
-	m = (x == y);
-	t = all (m);
+        y = y(f_y);
+        m = (x == y);
+        t = all (m);
 
-	if (!t)
+        if (!t)
           if (nans_compare_equal)
             t = isnan (x(!m)) && isnan (y(!m));
           else
             return;
           endif
-	endif
+        endif
       endfor
 
     endif
   endif
 
 endfunction
diff --git a/scripts/general/quadgk.m b/scripts/general/quadgk.m
--- a/scripts/general/quadgk.m
+++ b/scripts/general/quadgk.m
@@ -127,54 +127,54 @@ function [q, err] = quadgk (f, a, b, var
     abstol = 1e-10;
     reltol = 1e-5;
     waypoints = [];
     maxint = 650;
     trace = false;
 
     if (nargin > 3)
       if (! ischar (varargin{1}))
-	if (!isempty (varargin{1}))
-	  abstol = varargin{1};
-	  reltol = 0;
-	endif
-	if (nargin > 4)
-	  trace = varargin{2};
-	endif
-	if (nargin > 5)
-	  error ("quadgk: can not pass additional arguments to user function");
+        if (!isempty (varargin{1}))
+          abstol = varargin{1};
+          reltol = 0;
+        endif
+        if (nargin > 4)
+          trace = varargin{2};
+        endif
+        if (nargin > 5)
+          error ("quadgk: can not pass additional arguments to user function");
         endif
       else
-	idx = 1;
-	while (idx < nargin - 3)
-	  if (ischar (varargin{idx}))
-	    str = varargin{idx++};
-	    if (strcmpi (str, "reltol"))
-	      reltol = varargin{idx++};
-	    elseif (strcmpi (str, "abstol"))
-	      abstol = varargin{idx++};
-	    elseif (strcmpi (str, "waypoints"))
-	      waypoints = varargin{idx++} (:);
-	      if (isreal(waypoints))
-		waypoints (waypoints < a | waypoints > b) = [];
-	      endif
-	    elseif (strcmpi (str, "maxintervalcount"))
-	      maxint = varargin{idx++};
-	    elseif (strcmpi (str, "trace"))
-	      trace = varargin{idx++};
-	    else
-	      error ("quadgk: unknown property %s", str);
-	    endif
-	  else
-	    error ("quadgk: expecting property to be a string");
-	  endif
-	endwhile
-	if (idx != nargin - 2)
-	  error ("quadgk: expecting properties in pairs");
-	endif
+        idx = 1;
+        while (idx < nargin - 3)
+          if (ischar (varargin{idx}))
+            str = varargin{idx++};
+            if (strcmpi (str, "reltol"))
+              reltol = varargin{idx++};
+            elseif (strcmpi (str, "abstol"))
+              abstol = varargin{idx++};
+            elseif (strcmpi (str, "waypoints"))
+              waypoints = varargin{idx++} (:);
+              if (isreal(waypoints))
+                waypoints (waypoints < a | waypoints > b) = [];
+              endif
+            elseif (strcmpi (str, "maxintervalcount"))
+              maxint = varargin{idx++};
+            elseif (strcmpi (str, "trace"))
+              trace = varargin{idx++};
+            else
+              error ("quadgk: unknown property %s", str);
+            endif
+          else
+            error ("quadgk: expecting property to be a string");
+          endif
+        endwhile
+        if (idx != nargin - 2)
+          error ("quadgk: expecting properties in pairs");
+        endif
       endif
     endif
 
     ## Convert function given as a string to a function handle
     if (ischar (f))
       f = @(x) feval (f, x);
     endif
 
@@ -191,20 +191,20 @@ function [q, err] = quadgk (f, a, b, var
       ## Standard Infinite to finite integral transformation.
       ##   \int_{-\infinity_^\infinity f(x) dx = \int_-1^1 f (g(t)) g'(t) dt
       ## where 
       ##   g(t)  = t / (1 - t^2)
       ##   g'(t) =  (1 + t^2) / (1 - t^2) ^ 2
       ## waypoint transform is then
       ##   t =  (2 * g(t)) ./ (1 + sqrt(1 + 4 * g(t) .^ 2))
       if (!isempty (waypoints))
-	trans = @(x) (2 * x) ./ (1 + sqrt(1 + 4 * x .^ 2));
-	subs = [-1; trans(waypoints); 1];
+        trans = @(x) (2 * x) ./ (1 + sqrt(1 + 4 * x .^ 2));
+        subs = [-1; trans(waypoints); 1];
       else
-	subs = linspace (-1, 1, 11)'; 
+        subs = linspace (-1, 1, 11)'; 
       endif
       h = 2;
       h0 = b - a;
       trans = @(t) t ./ (1 - t.^2);
       f = @(t) f (t ./ (1 - t .^ 2)) .* (1 + t .^ 2) ./ ((1 - t .^ 2) .^ 2);
     elseif (isinf(a))
       ## Formula defined in Shampine paper as two separate steps. One to
       ## weaken singularity at finite end, then a second to transform to
@@ -216,21 +216,21 @@ function [q, err] = quadgk (f, a, b, var
       ##                  \int_{-1}^0 f (b - g(s) ^ 2) 2 g(s) g'(s) ds
       ## where 
       ##   g(s)  = s / (1 + s)
       ##   g'(s) = 1 / (1 + s) ^ 2
       ## waypoint transform is then
       ##   t = sqrt (b - x)
       ##   s =  - t / (t + 1)
       if (!isempty (waypoints))
-	tmp = sqrt (b - waypoints);
-	trans = @(x)  - x ./ (x + 1);
-	subs = [0; trans(tmp); 1];
+        tmp = sqrt (b - waypoints);
+        trans = @(x)  - x ./ (x + 1);
+        subs = [0; trans(tmp); 1];
       else
-	subs = linspace (0, 1, 11)'; 
+        subs = linspace (0, 1, 11)'; 
       endif
       h = 1;
       h0 = b - a;
       trans = @(t) b - (t ./ (1 + t)).^2;
       f = @(s) - 2 * s .* f (b -  (s ./ (1 + s)) .^ 2) ./ ((1 + s) .^ 3);
     elseif (isinf(b))
       ## Formula defined in Shampine paper as two separate steps. One to
       ## weaken singularity at finite end, then a second to transform to
@@ -241,21 +241,21 @@ function [q, err] = quadgk (f, a, b, var
       ##           \int_0^1 f (a + g(s) ^ 2) 2 g(s) g'(s) ds
       ## where 
       ##   g(s)  = s / (1 - s)
       ##   g'(s) = 1 / (1 - s) ^ 2
       ## waypoint transform is then
       ##   t = sqrt (x - a)
       ##   s = t / (t + 1)
       if (!isempty (waypoints))
-	tmp = sqrt (waypoints - a);
-	trans = @(x) x ./ (x + 1);
-	subs = [0; trans(tmp); 1];
+        tmp = sqrt (waypoints - a);
+        trans = @(x) x ./ (x + 1);
+        subs = [0; trans(tmp); 1];
       else
-	subs = linspace (0, 1, 11)'; 
+        subs = linspace (0, 1, 11)'; 
       endif
       h = 1;
       h0 = b - a;
       trans = @(t) a + (t ./ (1 - t)).^2;
       f = @(s) 2 * s .* f (a +  (s ./ (1 - s)) .^ 2) ./ ((1 - s) .^ 3);
     else
       ## Davis, Rabinowitz, "Methods of Numerical Integration" p441 2ed.
       ## Presented in section 5 of the Shampine paper as
@@ -264,20 +264,20 @@ function [q, err] = quadgk (f, a, b, var
       ## waypoint transform can then be found by solving for t with
       ## Maxima (solve (c + 3*t -  3^3, t);). This gives 3 roots, two of
       ## which are complex for values between a and b and so can be
       ## ignored. The third is
       ##  c = (-4*x + 2*(b+a)) / (b-a);
       ##  k = ((sqrt(c^2 - 4) + c)/2)^(1/3);
       ##  t = (sqrt(3)* 1i * (1 - k^2) - (1 + k^2)) / 2 / k;
       if (! isempty (waypoints))
-	trans = @__quadgk_finite_waypoint__;
-	subs = [-1; trans(waypoints, a, b); 1];
+        trans = @__quadgk_finite_waypoint__;
+        subs = [-1; trans(waypoints, a, b); 1];
       else
-	subs = linspace(-1, 1, 11)'; 
+        subs = linspace(-1, 1, 11)'; 
       endif
       h = 2;
       h0 = b - a;
       trans = @(t) ((b - a) ./ 4) * t .* (3 - t.^2) + (b + a) ./ 2;
       f = @(t) f((b - a) ./ 4 .* t .* (3 - t.^2) + (b + a) ./ 2) .* ...
            3 .* (b - a) ./ 4 .* (1 - t.^2);
     endif
 
@@ -295,128 +295,128 @@ function [q, err] = quadgk (f, a, b, var
       warning ("off", "Octave:divide-by-zero");
 
       ## Initial evaluation of the integrand on the sub-intervals
       [q_subs, q_errs] = __quadgk_eval__ (f, subs);
       q0 = sum (q_subs);
       err0 = sum (q_errs);
     
       if (isa (a, "single") || isa (b, "single") || isa (waypoints, "single"))
-	myeps = eps ("single");
+        myeps = eps ("single");
       else
-	myeps = eps;
+        myeps = eps;
       endif
 
       first = true;
       while (true)
-	## Check for sub-intervals that are too small. Test must be
-	## performed in untransformed sub-intervals. What is a good
-	## value for this test. Shampine suggests 100*eps
-	if (any (abs (diff (trans (subs), [], 2) / h0) < 100 * myeps))
-	  q = q0;
-	  err = err0;
-	  break;
-	endif
+        ## Check for sub-intervals that are too small. Test must be
+        ## performed in untransformed sub-intervals. What is a good
+        ## value for this test. Shampine suggests 100*eps
+        if (any (abs (diff (trans (subs), [], 2) / h0) < 100 * myeps))
+          q = q0;
+          err = err0;
+          break;
+        endif
 
-	## Quit if any evaluations are not finite (Inf or NaN)
-	if (any (! isfinite (q_subs)))
-	  warning ("quadgk: non finite integrand encountered"); 
-	  q = q0;
-	  err = err0;
-	  break;
-	endif
+        ## Quit if any evaluations are not finite (Inf or NaN)
+        if (any (! isfinite (q_subs)))
+          warning ("quadgk: non finite integrand encountered"); 
+          q = q0;
+          err = err0;
+          break;
+        endif
 
-	tol = max (abstol, reltol .* abs (q0));
+        tol = max (abstol, reltol .* abs (q0));
 
-	## If the global error estimate is meet exit
-	if (err0 < tol)
-	  q = q0;
-	  err = err0;
-	  break;
-	endif
+        ## If the global error estimate is meet exit
+        if (err0 < tol)
+          q = q0;
+          err = err0;
+          break;
+        endif
 
-	## Accept the sub-intervals that meet the convergence criteria
-	idx = find (abs (q_errs) < tol .* abs(diff (subs, [], 2)) ./ h);
-	if (first)
-	  q = sum (q_subs (idx));
-	  err = sum (q_errs(idx));
-	  first = false;
-	else
-	  q0 = q + sum (q_subs);
-	  err0 = err + sum (q_errs);
-	  q += sum (q_subs (idx));
-	  err += sum (q_errs(idx));
-	endif
-	subs(idx,:) = [];
+        ## Accept the sub-intervals that meet the convergence criteria
+        idx = find (abs (q_errs) < tol .* abs(diff (subs, [], 2)) ./ h);
+        if (first)
+          q = sum (q_subs (idx));
+          err = sum (q_errs(idx));
+          first = false;
+        else
+          q0 = q + sum (q_subs);
+          err0 = err + sum (q_errs);
+          q += sum (q_subs (idx));
+          err += sum (q_errs(idx));
+        endif
+        subs(idx,:) = [];
 
-	## If no remaining sub-intervals exit
-	if (rows (subs) == 0)
-	  break;
-	endif
+        ## If no remaining sub-intervals exit
+        if (rows (subs) == 0)
+          break;
+        endif
 
-	if (trace)
-	  disp([rows(subs), err, q0]);
-	endif
+        if (trace)
+          disp([rows(subs), err, q0]);
+        endif
 
-	## Split remaining sub-intervals in two
-	mid = (subs(:,2) + subs(:,1)) ./ 2;
-	subs = [subs(:,1), mid; mid, subs(:,2)];
+        ## Split remaining sub-intervals in two
+        mid = (subs(:,2) + subs(:,1)) ./ 2;
+        subs = [subs(:,1), mid; mid, subs(:,2)];
 
-	## If the maximum sub-interval count is met accept remaining
-	## sub-interval and exit
-	if (rows (subs) > maxint)
-	  warning ("quadgk: maximum interval count (%d) met", maxint);
-	  q += sum (q_subs);
-	  err += sum (q_errs);
-	  break;
-	endif
+        ## If the maximum sub-interval count is met accept remaining
+        ## sub-interval and exit
+        if (rows (subs) > maxint)
+          warning ("quadgk: maximum interval count (%d) met", maxint);
+          q += sum (q_subs);
+          err += sum (q_errs);
+          break;
+        endif
 
-	## Evaluation of the integrand on the remaining sub-intervals
-	[q_subs, q_errs] = __quadgk_eval__ (f, subs);
+        ## Evaluation of the integrand on the remaining sub-intervals
+        [q_subs, q_errs] = __quadgk_eval__ (f, subs);
       endwhile
 
       if (err > max (abstol, reltol * abs(q)))
-	warning ("quadgk: Error tolerance not met. Estimated error %g", err);
+        warning ("quadgk: Error tolerance not met. Estimated error %g", err);
       endif
     unwind_protect_cleanup
       if (strcmp (warn_state.state, "on")) 
-	warning ("on", "Octave:divide-by-zero");
+        warning ("on", "Octave:divide-by-zero");
       endif
     end_unwind_protect
   endif
 endfunction
 
 function [q, err] = __quadgk_eval__ (f, subs)
   ## A (15,7) point pair of Gauss-Konrod quadrature rules. The abscissa
   ## and weights are copied directly from dqk15w.f from quadpack
 
   persistent abscissa = [-0.9914553711208126e+00, -0.9491079123427585e+00, ...
-			 -0.8648644233597691e+00, -0.7415311855993944e+00, ...
-			 -0.5860872354676911e+00, -0.4058451513773972e+00, ...
-			 -0.2077849550078985e+00,  0.0000000000000000e+00, ...
-			  0.2077849550078985e+00,  0.4058451513773972e+00, ...
-			  0.5860872354676911e+00,  0.7415311855993944e+00, ...
-			  0.8648644233597691e+00,  0.9491079123427585e+00, ...
-			  0.9914553711208126e+00];
+                         -0.8648644233597691e+00, -0.7415311855993944e+00, ...
+                         -0.5860872354676911e+00, -0.4058451513773972e+00, ...
+                         -0.2077849550078985e+00,  0.0000000000000000e+00, ...
+                          0.2077849550078985e+00,  0.4058451513773972e+00, ...
+                          0.5860872354676911e+00,  0.7415311855993944e+00, ...
+                          0.8648644233597691e+00,  0.9491079123427585e+00, ...
+                          0.9914553711208126e+00];
 
   persistent weights15 = ...
       diag ([0.2293532201052922e-01,  0.6309209262997855e-01, ...
-	     0.1047900103222502e+00,  0.1406532597155259e+00, ...
-	     0.1690047266392679e+00,  0.1903505780647854e+00, ...
-	     0.2044329400752989e+00,  0.2094821410847278e+00, ...
-	     0.2044329400752989e+00,  0.1903505780647854e+00, ...
-	     0.1690047266392679e+00,  0.1406532597155259e+00, ...
-	     0.1047900103222502e+00,  0.6309209262997855e-01, ...
-	     0.2293532201052922e-01]);
+             0.1047900103222502e+00,  0.1406532597155259e+00, ...
+             0.1690047266392679e+00,  0.1903505780647854e+00, ...
+             0.2044329400752989e+00,  0.2094821410847278e+00, ...
+             0.2044329400752989e+00,  0.1903505780647854e+00, ...
+             0.1690047266392679e+00,  0.1406532597155259e+00, ...
+             0.1047900103222502e+00,  0.6309209262997855e-01, ...
+             0.2293532201052922e-01]);
 
   persistent weights7  = ...
       diag ([0.1294849661688697e+00,  0.2797053914892767e+00, ...
-	     0.3818300505051889e+00,  0.4179591836734694e+00, ...
-	     0.3818300505051889e+00,  0.2797053914892767e+00, ...
-	     0.1294849661688697e+00]);
+             0.3818300505051889e+00,  0.4179591836734694e+00, ...
+             0.3818300505051889e+00,  0.2797053914892767e+00, ...
+             0.1294849661688697e+00]);
 
   halfwidth = diff (subs, [], 2) ./ 2;
   center = sum (subs, 2) ./ 2;;
   x = bsxfun (@plus, halfwidth * abscissa, center);
   y = reshape (f (x(:)), size(x));
 
   ## This is faster than using bsxfun as the * operator can use a
   ## single BLAS call, rather than rows(sub) calls to the @times
diff --git a/scripts/general/quadl.m b/scripts/general/quadl.m
--- a/scripts/general/quadl.m
+++ b/scripts/general/quadl.m
@@ -93,27 +93,27 @@ function Q = quadl (f, a, b, tol, trace,
   y = feval (f, x, varargin{:});
 
   fa = y(1); 
   fb = y(13);
 
   i2 = (h/6)*(y(1) + y(13) + 5*(y(5)+y(9)));
 
   i1 = (h/1470)*(77*(y(1)+y(13))
-		 + 432*(y(3)+y(11))
-		 + 625*(y(5)+y(9))
-		 + 672*y(7));
+                 + 432*(y(3)+y(11))
+                 + 625*(y(5)+y(9))
+                 + 672*y(7));
 
   is = h*(.0158271919734802*(y(1)+y(13))
-	  +.0942738402188500*(y(2)+y(12))
-	  + .155071987336585*(y(3)+y(11))
-	  + .188821573960182*(y(4)+y(10))
-	  + .199773405226859*(y(5)+y(9))
-	  + .224926465333340*(y(6)+y(8))
-	  + .242611071901408*y(7));
+          +.0942738402188500*(y(2)+y(12))
+          + .155071987336585*(y(3)+y(11))
+          + .188821573960182*(y(4)+y(10))
+          + .199773405226859*(y(5)+y(9))
+          + .224926465333340*(y(6)+y(8))
+          + .242611071901408*y(7));
 
   s = sign(is); 
 
   if (s == 0)
     s = 1;
   endif
   erri1 = abs(i1-is);
   erri2 = abs(i2-is);
@@ -166,21 +166,21 @@ function Q = adaptlobstp (f, a, b, fa, f
       need_warning (0);
     endif
     Q = i1;
     if (trace)
       disp ([a, b-a, Q]);
     endif
   else
     Q = (adaptlobstp (f, a, mll, fa, fmll, is, trace, varargin{:})
-	 + adaptlobstp (f, mll, ml, fmll, fml, is, trace, varargin{:})
-	 + adaptlobstp (f, ml, m, fml, fm, is, trace, varargin{:})
-	 + adaptlobstp (f, m, mr, fm, fmr, is, trace, varargin{:})
-	 + adaptlobstp (f, mr, mrr, fmr, fmrr, is, trace, varargin{:})
-	 + adaptlobstp (f, mrr, b, fmrr, fb, is, trace, varargin{:}));
+         + adaptlobstp (f, mll, ml, fmll, fml, is, trace, varargin{:})
+         + adaptlobstp (f, ml, m, fml, fm, is, trace, varargin{:})
+         + adaptlobstp (f, m, mr, fm, fmr, is, trace, varargin{:})
+         + adaptlobstp (f, mr, mrr, fmr, fmrr, is, trace, varargin{:})
+         + adaptlobstp (f, mrr, b, fmrr, fb, is, trace, varargin{:}));
   endif
 endfunction
 
 function r = need_warning (v)
   persistent w = [];
   if (nargin == 0)
     r = w;
   else 
diff --git a/scripts/general/quadv.m b/scripts/general/quadv.m
--- a/scripts/general/quadv.m
+++ b/scripts/general/quadv.m
@@ -79,29 +79,29 @@ function [q, fcnt] = quadv (f, a, b, tol
   if (isinf (fb))
     fb = feval (f, b - myeps * (b-a), varargin{:});
   endif
 
   h = (b - a) / 2;
   q = (b - a) / 6 * (fa + 4 * fc + fb);
  
   [q, fcnt, hmin] = simpsonstp (f, a, b, c, fa, fb, fc, q, fcnt, abs (b - a), 
-				tol, trace, varargin{:});
+                                tol, trace, varargin{:});
 
   if (fcnt > 10000)
     warning ("maximum iteration count reached");
   elseif (isnan (q) || isinf (q))
     warning ("infinite or NaN function evaluations were returned");
   elseif (hmin < (b - a) * myeps)
     warning ("minimum step size reached -- possibly singular integral");
   endif
 endfunction
 
 function [q, fcnt, hmin] = simpsonstp (f, a, b, c, fa, fb, fc, q0, 
-				       fcnt, hmin, tol, trace, varargin)
+                                       fcnt, hmin, tol, trace, varargin)
   if (fcnt > 10000)
     q = q0;
   else
     d = (a + c) / 2;
     e = (c + b) / 2;
     fd = feval (f, d, varargin{:});
     fe = feval (f, e, varargin{:});
     fcnt += 2;
@@ -115,19 +115,19 @@ function [q, fcnt, hmin] = simpsonstp (f
 
     if (trace)
       disp ([fcnt, a, b-a, q]);
     endif
 
     ## Force at least one adpative step.
     if (fcnt == 5 || abs (q - q0) > tol)
       [q1, fcnt, hmin] = simpsonstp (f, a, c, d, fa, fc, fd, q1, fcnt, hmin,
-				    tol, trace, varargin{:});
+                                    tol, trace, varargin{:});
       [q2, fcnt, hmin] = simpsonstp (f, c, b, e, fc, fb, fe, q2, fcnt, hmin,
-				     tol, trace, varargin{:});
+                                     tol, trace, varargin{:});
       q = q1 + q2;
     endif
   endif
 endfunction
 
 %!assert (quadv (@sin, 0, 2 * pi), 0, 1e-5)
 %!assert (quadv (@sin, 0, pi), 2, 1e-5)
 
diff --git a/scripts/general/rat.m b/scripts/general/rat.m
--- a/scripts/general/rat.m
+++ b/scripts/general/rat.m
@@ -66,17 +66,17 @@ function [n,d] = rat(x,tol)
   steps = zeros([nsz, 0]);
 
   ## Grab new factors until all continued fractions converge.
   while (1)
     ## Determine which fractions have not yet converged.
     idx = find(abs (y-n./d) >= tol);
     if (isempty(idx))
       if (isempty (steps))
-	steps = NaN (nsz, 1);
+        steps = NaN (nsz, 1);
       endif
       break;
     endif
 
     ## Grab the next step in the continued fraction.
     flip = 1./frac(idx);
     ## Next element in the continued fraction.
     step = round(flip);
@@ -117,36 +117,36 @@ function [n,d] = rat(x,tol)
   else
     n = "";
     nsteps = size(steps, 2);
     for i = 1: nsz
       s = [int2str(y(i))," "];
       j = 1;
 
       while (true)
-	step = steps(i, j++);
-	if (isnan (step))
-	  break;
-	endif
-	if (j > nsteps || isnan (steps(i, j)))
-	  if (step < 0)
-	    s = [s(1:end-1), " + 1/(", int2str(step), ")"];
-	  else
-	    s = [s(1:end-1), " + 1/", int2str(step)];
-	  endif
-	  break;
-	else
-	  s = [s(1:end-1), " + 1/(", int2str(step), ")"];
+        step = steps(i, j++);
+        if (isnan (step))
+          break;
+        endif
+        if (j > nsteps || isnan (steps(i, j)))
+          if (step < 0)
+            s = [s(1:end-1), " + 1/(", int2str(step), ")"];
+          else
+            s = [s(1:end-1), " + 1/", int2str(step)];
+          endif
+          break;
+        else
+          s = [s(1:end-1), " + 1/(", int2str(step), ")"];
         endif
       endwhile
       s = [s, repmat(")", 1, j-2)];
       n_nc = columns (n);
       s_nc = columns (s);
       if (n_nc > s_nc)
-	s(:,s_nc+1:n_nc) = " "
+        s(:,s_nc+1:n_nc) = " "
       elseif (s_nc > n_nc)
-	n(:,n_nc+1:s_nc) = " ";
+        n(:,n_nc+1:s_nc) = " ";
       endif
       n = cat (1, n, s);
     endfor
   endif
 
 endfunction
diff --git a/scripts/general/rotdim.m b/scripts/general/rotdim.m
--- a/scripts/general/rotdim.m
+++ b/scripts/general/rotdim.m
@@ -69,31 +69,31 @@ function y = rotdim (x, k, plane)
   sz = size (x);
   if (nargin < 3)
     ## Find the first two non-singleton dimension.
     plane = [];
     dim = 0;
     while (dim < nd)
       dim = dim + 1;
       if (sz (dim) != 1)
-	plane = [plane, dim];
-	if (length (plane) == 2)
-	  break;
-	endif
+        plane = [plane, dim];
+        if (length (plane) == 2)
+          break;
+        endif
       endif
     endwhile
     if (length (plane) < 1)
       plane = [1, 2];
     elseif (length (plane) < 2)
       plane = [1, plane];
     endif
   else
     if (! (isvector (plane) && length (plane) == 2
-	   && all (plane == round (plane)) && all (plane > 0)
-	   && all (plane < (nd + 1)) && plane(1) != plane(2)))
+           && all (plane == round (plane)) && all (plane > 0)
+           && all (plane < (nd + 1)) && plane(1) != plane(2)))
       error ("rotdim: plane must be a 2 element integer vector defining a valid plane");
     endif
   endif
 
   k = rem (k, 4);
   if (k < 0)
     k = k + 4;
   endif
diff --git a/scripts/general/shift.m b/scripts/general/shift.m
--- a/scripts/general/shift.m
+++ b/scripts/general/shift.m
@@ -42,17 +42,17 @@ function y = shift (x, b, dim)
     error ("shift: b must be an integer");
   endif
 
   nd = ndims (x);
   sz = size (x);
 
   if (nargin == 3)
     if (! (isscalar (dim) && dim == round (dim)) && dim > 0 && 
-	dim < (nd + 1))
+        dim < (nd + 1))
       error ("shift: dim must be an integer and valid dimension");
     endif
   else
     ## Find the first non-singleton dimension
     dim  = 1;
     while (dim < nd + 1 && sz (dim) == 1)
       dim = dim + 1;
     endwhile
diff --git a/scripts/general/sortrows.m b/scripts/general/sortrows.m
--- a/scripts/general/sortrows.m
+++ b/scripts/general/sortrows.m
@@ -60,19 +60,19 @@ endfunction
 function i = sort_rows_idx_generic (default_mode, other_mode, m, c)
 
   if (nargin == 3)
     indices = [1:size(m,2)]';
     mode(1:size(m,2)) = {default_mode};
   else
     for ii = 1:length (c);
       if (c(ii) < 0)
-	mode{ii} = other_mode;
+        mode{ii} = other_mode;
       else
-	mode{ii} = default_mode;
+        mode{ii} = default_mode;
       endif
     endfor
     indices = abs(c(:));
   endif
 
   ## Since sort is 'stable' the order of identical elements will be
   ## preserved, so by traversing the sort indices in reverse order we
   ## will make sure that identical elements in index i are subsorted by
diff --git a/scripts/general/structfun.m b/scripts/general/structfun.m
--- a/scripts/general/structfun.m
+++ b/scripts/general/structfun.m
@@ -109,17 +109,17 @@ endfunction
 
 
 %!test
 %! s.name1 = "John Smith"; 
 %! s.name2 = "Jill Jones"; 
 %! l.name1 = "Smith";
 %! l.name2 = "Jones";
 %! o = structfun (@(x) regexp (x, '(\w+)$', "matches"){1}, s, 
-%!		  "UniformOutput", false);
+%!                "UniformOutput", false);
 %! assert (o, l);
 
 %!function [a, b] = twoouts (x)
 %! a = x + x;
 %! b = x * x;
 
 %!test
 %! s = struct ("a", {1, 2, 3}, "b", {4, 5, 6});
diff --git a/scripts/general/trapz.m b/scripts/general/trapz.m
--- a/scripts/general/trapz.m
+++ b/scripts/general/trapz.m
@@ -25,23 +25,23 @@
 ## (@var{y})} computes the integral of the @var{y} along the first
 ## non-singleton dimension.  If the argument @var{x} is omitted a 
 ## equally spaced vector is assumed.  @code{trapz (@var{x}, @var{y})} 
 ## evaluates the integral with respect to @var{x}.
 ##  
 ## @seealso{cumtrapz}
 ## @end deftypefn
 
-## Author:	Kai Habel <kai.habel@gmx.de>
+## Author:      Kai Habel <kai.habel@gmx.de>
 ##
 ## also: June 2000 - Paul Kienzle (fixes,suggestions) 
 ## 2006-05-12 David Bateman - Modified for NDArrays
 
 function z = trapz (x, y, dim)
-	
+        
 
   if (nargin < 1) || (nargin > 3)
     print_usage ();
   endif
 
   nd = ndims (x);
   sz = size (x);
 
@@ -78,27 +78,27 @@ function z = trapz (x, y, dim)
   endif
  
   n = sz(dim);
   idx1 = cell ();
   for i = 1:nd
     idx1{i} = 1:sz(i);
   endfor
   idx2 = idx1;
-  idx1{dim} = 2 : n;	
+  idx1{dim} = 2 : n;    
   idx2{dim} = 1 : (n - 1);
 
   if (! have_x)
     z = 0.5 * sum (x(idx1{:}) + x(idx2{:}), dim);
   else
     if (! size_equal (x, y))
       error ("trapz: x and y must have same shape");
     endif
     z = 0.5 * sum ((x(idx1{:}) - x(idx2{:})) .* 
-		   (y(idx1{:}) + y(idx2{:})), dim);
+                   (y(idx1{:}) + y(idx2{:})), dim);
   endif
 endfunction
 
 %!assert (trapz(1:5), 12)
 %!assert (trapz(0:0.5:2,1:5), 6)
 %!assert (trapz([1:5;1:5],2),[12;12])
 %!assert (trapz([1:5;1:5].',1),[12,12])
 %!assert (trapz([0:0.5:2;0:0.5:2],[1:5;1:5],2),[6;6])
diff --git a/scripts/geometry/griddata.m b/scripts/geometry/griddata.m
--- a/scripts/geometry/griddata.m
+++ b/scripts/geometry/griddata.m
@@ -25,23 +25,23 @@
 ## The interpolation points are all @code{(@var{xi}, @var{yi})}.  If
 ## @var{xi}, @var{yi} are vectors then they are made into a 2D mesh.
 ##
 ## The interpolation method can be @code{"nearest"}, @code{"cubic"} or
 ## @code{"linear"}.  If method is omitted it defaults to @code{"linear"}.
 ## @seealso{delaunay}
 ## @end deftypefn
 
-## Author:	Kai Habel <kai.habel@gmx.de>
+## Author:      Kai Habel <kai.habel@gmx.de>
 ## Adapted-by:  Alexander Barth <barth.alexander@gmail.com>
 ##              xi and yi are not "meshgridded" if both are vectors 
 ##              of the same size (for compatibility)
 
 function [rx, ry, rz] = griddata (x, y, z, xi, yi, method)
-	
+        
   if (nargin == 5)
     method = "linear";
   endif
   if (nargin < 5 || nargin > 7) 
     print_usage ();
   endif
 
   if (ischar (method))
diff --git a/scripts/geometry/griddata3.m b/scripts/geometry/griddata3.m
--- a/scripts/geometry/griddata3.m
+++ b/scripts/geometry/griddata3.m
@@ -26,17 +26,17 @@
 ## The interpolation method can be @code{"nearest"} or @code{"linear"}.
 ## If method is omitted it defaults to @code{"linear"}.
 ## @seealso{griddata, delaunayn}
 ## @end deftypefn
 
 ## Author: David Bateman <dbateman@free.fr>
 
 function vi = griddata3 (x, y, z, v, xi, yi, zi, method, varargin)
-	
+        
   if (nargin < 7)
     print_usage ();
   endif
 
   if (!all (size (x) == size (y) & size (x) == size(z) & size(x) == size (v)))
     error ("griddata3: x, y, z, and v must be vectors of same length");
   endif
 
diff --git a/scripts/geometry/inpolygon.m b/scripts/geometry/inpolygon.m
--- a/scripts/geometry/inpolygon.m
+++ b/scripts/geometry/inpolygon.m
@@ -39,20 +39,20 @@
 
 function [IN, ON] = inpolygon (X, Y, xv, yv)
 
   if (nargin != 4)
     print_usage ();
   endif
 
   if (! (isreal (X) && isreal (Y) && ismatrix (Y) && ismatrix (Y)
-	 && size_equal (X, Y)))
+         && size_equal (X, Y)))
     error ("inpolygon: first two arguments must be real matrices of same size");
   elseif (! (isreal (xv) && isreal (yv) && isvector (xv) && isvector (yv)
-	     && size_equal (xv, yv)))
+             && size_equal (xv, yv)))
     error ("inpolygon: last two arguments must be real vectors of same size");
   endif
 
   npol = length (xv);
   do_boundary = (nargout >= 2);
   
   IN = zeros (size(X), "logical");
   if (do_boundary) 
@@ -64,24 +64,24 @@ function [IN, ON] = inpolygon (X, Y, xv,
     delta_xv = xv(j) - xv(i);
     delta_yv = yv(j) - yv(i);
     ## distance = [distance from (X,Y) to edge] * length(edge)
     distance = delta_xv .* (Y - yv(i)) - (X - xv(i)) .* delta_yv;
     ##
     ## is Y between the y-values of edge i,j
     ##        AND (X,Y) on the left of the edge ?
     idx1 = (((yv(i) <= Y & Y < yv(j)) | (yv(j) <= Y & Y < yv(i)))
-	    & 0 < distance.*delta_yv);
+            & 0 < distance.*delta_yv);
     IN (idx1) = !IN (idx1);
 
     ## Check if (X,Y) are actually ON the boundary of the polygon.
     if (do_boundary)
        idx2 = (((yv(i) <= Y & Y <= yv(j)) | (yv(j) <= Y & Y <= yv(i)))
-	       & ((xv(i) <= X & X <= xv(j)) | (xv(j) <= X & X <= xv(i)))
-	       & (0 == distance | !delta_xv));
+               & ((xv(i) <= X & X <= xv(j)) | (xv(j) <= X & X <= xv(i)))
+               & (0 == distance | !delta_xv));
        ON (idx2) = true;
     endif
     j = i;
   endfor
 
 endfunction
 
 %!demo
diff --git a/scripts/geometry/rectint.m b/scripts/geometry/rectint.m
--- a/scripts/geometry/rectint.m
+++ b/scripts/geometry/rectint.m
@@ -29,17 +29,17 @@
 ## column corresponds to the j-th row of b.
 ##
 ## @seealso{polyarea}
 ## @end deftypefn
 
 ## Author: Bill Denney <bill@denney.ws>
 
 function area = rectint (a, b)
-	
+        
   if (nargin != 2)
     print_usage ();
   elseif (ndims (a) != 2 || ndims (b) != 2)
     error ("rectint: expecting arguments to be 2-d arrays");
   elseif (columns (a) != 4)
     error ("rectint: a must have 4 columns");
   elseif (columns (b) != 4)
     error ("rectint: b must have 4 columns");
diff --git a/scripts/geometry/trimesh.m b/scripts/geometry/trimesh.m
--- a/scripts/geometry/trimesh.m
+++ b/scripts/geometry/trimesh.m
@@ -36,27 +36,27 @@ function h = trimesh (tri, x, y, z, vara
   if (nargin == 3)
     triplot (tri, x, y);
   elseif (ischar (z))
     triplot (tri, x, y, z, varargin{:});
   else
     newplot ();
     if (nargout > 0)
       h = patch ("Vertices", [x(:), y(:), z(:)], "Faces", tri, 
-		 "FaceColor", "none", "EdgeColor", __next_line_color__(), 
-		 varargin{:});
+                 "FaceColor", "none", "EdgeColor", __next_line_color__(), 
+                 varargin{:});
     else
       patch ("Vertices", [x(:), y(:), z(:)], "Faces", tri, 
-	     "FaceColor", "none", "EdgeColor", __next_line_color__(), 
-	     varargin{:});
+             "FaceColor", "none", "EdgeColor", __next_line_color__(), 
+             varargin{:});
     endif
 
     if (! ishold ())
       set (gca(), "view", [-37.5, 30],
-	   "xgrid", "on", "ygrid", "on", "zgrid", "on");
+           "xgrid", "on", "ygrid", "on", "zgrid", "on");
     endif
   endif
 endfunction
 
 %!demo
 %! N = 10;
 %! rand ('state', 10)
 %! x = 3 - 6 * rand (N, N);
diff --git a/scripts/geometry/triplot.m b/scripts/geometry/triplot.m
--- a/scripts/geometry/triplot.m
+++ b/scripts/geometry/triplot.m
@@ -33,20 +33,20 @@ function h = triplot (tri, x, y, varargi
   if (nargin < 3)
     print_usage ();
   endif
 
   idx = tri(:, [1, 2, 3, 1]).';
   nt = size (tri, 1);
   if (nargout > 0)
     h = plot ([x(idx); NaN(1, nt)](:),
-	      [y(idx); NaN(1, nt)](:), varargin{:});
+              [y(idx); NaN(1, nt)](:), varargin{:});
   else
     plot ([x(idx); NaN(1, nt)](:),
-	  [y(idx); NaN(1, nt)](:), varargin{:});
+          [y(idx); NaN(1, nt)](:), varargin{:});
   endif
 endfunction
 
 %!demo
 %! rand ('state', 2)
 %! x = rand (20, 1);
 %! y = rand (20, 1);
 %! tri = delaunay (x, y);
diff --git a/scripts/geometry/trisurf.m b/scripts/geometry/trisurf.m
--- a/scripts/geometry/trisurf.m
+++ b/scripts/geometry/trisurf.m
@@ -43,29 +43,29 @@ function h = trisurf (tri, x, y, z, vara
       varargin(1) = [];
     else
       c = z;
     endif
 
     newplot ();
     if (nargout > 0)
       h = patch ("Faces", tri, "Vertices", [x(:), y(:), z(:)],  
-	     "FaceVertexCData", reshape (c, numel (c), 1), 
-	     "FaceColor", "flat", "EdgeColor", "none",
-	     varargin{:});
+             "FaceVertexCData", reshape (c, numel (c), 1), 
+             "FaceColor", "flat", "EdgeColor", "none",
+             varargin{:});
     else
       patch ("Faces", tri, "Vertices", [x(:), y(:), z(:)],  
-	     "FaceVertexCData", reshape (c, numel (c), 1), 
-	     "FaceColor", "flat", "EdgeColor", "none",
-	     varargin{:});
+             "FaceVertexCData", reshape (c, numel (c), 1), 
+             "FaceColor", "flat", "EdgeColor", "none",
+             varargin{:});
     endif
 
     if (! ishold ())
       set (gca(), "view", [-37.5, 30],
-	   "xgrid", "on", "ygrid", "on", "zgrid", "on");
+           "xgrid", "on", "ygrid", "on", "zgrid", "on");
     endif
   endif
 endfunction
 
 %!demo
 %! N = 10;
 %! rand ('state', 10)
 %! x = 3 - 6 * rand (N, N);
diff --git a/scripts/geometry/voronoi.m b/scripts/geometry/voronoi.m
--- a/scripts/geometry/voronoi.m
+++ b/scripts/geometry/voronoi.m
@@ -114,33 +114,33 @@ function [vvx, vvy] = voronoi (varargin)
   xmin = min (x(:));
   ymax = max (y(:));
   ymin = min (y(:));
   xdelta = xmax - xmin;
   ydelta = ymax - ymin;
   scale = 2;
 
   xbox = [xmin - scale * xdelta; xmin - scale * xdelta; ...
-	  xmax + scale * xdelta; xmax + scale * xdelta];
+          xmax + scale * xdelta; xmax + scale * xdelta];
   ybox = [xmin - scale * xdelta; xmax + scale * xdelta; ...
-	  xmax + scale * xdelta; xmin - scale * xdelta];
+          xmax + scale * xdelta; xmin - scale * xdelta];
 
   [p, c, infi] = __voronoi__ ([[x(:) ; xbox(:)], [y(:); ybox(:)]], opts{:});
 
   idx = find (!infi);
   ll = length (idx);
   c = c(idx).';
   k = sum (cellfun ('length', c));
   edges = cell2mat(cellfun (@(x) [x ; [x(end), x(1:end-1)]], c, 
-			    "UniformOutput", false));
+                            "UniformOutput", false));
 
   ## Identify the unique edges of the Voronoi diagram
   edges = sortrows (sort (edges).').';
   edges = edges (:, [(edges(1, 1: end - 1) != edges(1, 2 : end) | ...
-		      edges(2, 1 :end - 1) != edges(2, 2 : end)), true]);
+                      edges(2, 1 :end - 1) != edges(2, 2 : end)), true]);
 
   ## Eliminate the edges of the diagram representing the box
   poutside = (1 : rows(p)) ...
       (p (:, 1) < xmin - xdelta | p (:, 1) > xmax + xdelta | ...
        p (:, 2) < ymin - ydelta | p (:, 2) > ymax + ydelta);
   edgeoutside = ismember (edges (1, :), poutside) & ...
       ismember (edges (2, :), poutside);
   edges (:, edgeoutside) = [];
@@ -148,17 +148,17 @@ function [vvx, vvy] = voronoi (varargin)
   ## Get points of the diagram
   vx = reshape (p (edges, 1), size(edges));
   vy = reshape (p (edges, 2), size(edges));
 
   if (nargout < 2)    
     lim = [xmin, xmax, ymin, ymax];
     h = plot (handl, vx, vy, linespec{:}, x, y, '+');
     axis (lim + 0.1 * [[-1, 1] * (lim (2) - lim (1)), ...
-		       [-1, 1] * (lim (4) - lim (3))]);
+                       [-1, 1] * (lim (4) - lim (3))]);
     if (nargout == 1)
       vxx = h;
     endif
   elseif (nargout == 2)
     vvx = vx;
     vvy = vy;
   else
     error ("voronoi: only two or zero output arguments supported");
diff --git a/scripts/help/doc.m b/scripts/help/doc.m
--- a/scripts/help/doc.m
+++ b/scripts/help/doc.m
@@ -40,19 +40,19 @@ function retval = doc (fname)
 
     ftype = 0;
 
     if (nargin == 1)
       ## Get the directory where the function lives.
       ## FIXME -- maybe we should have a better way of doing this.
 
       if (ischar (fname))
-	ftype = exist (fname);
+        ftype = exist (fname);
       else
-	error ("doc: expecting argument to be a character string");
+        error ("doc: expecting argument to be a character string");
       endif
     else
       fname = "";
     endif
 
     if (ftype == 2 || ftype == 3)
       ffile = which (fname);
     else
@@ -76,28 +76,28 @@ function retval = doc (fname)
       info_file_name = info_file ();
     endif
 
     ## FIXME -- don't change the order of the arguments below because
     ## the info-emacs-info script currently expects --directory DIR as
     ## the third and fourth arguments.  Someone should fix that.
 
     cmd = sprintf ("\"%s\" --file \"%s\" --directory \"%s\"",
-		   info_program (), info_file_name, info_dir);
+                   info_program (), info_file_name, info_dir);
 
     have_fname = ! isempty (fname);
 
     if (have_fname)
       status = system (sprintf ("%s --index-search %s", cmd, fname));
     endif
 
     if (! (have_fname && status == 0))
       status = system (cmd);
       if (status == 127)
-	warning ("unable to find info program `%s'", info_program ());
+        warning ("unable to find info program `%s'", info_program ());
       endif
     endif
 
     if (nargout > 0)
       retval = status;
     endif
 
   else
diff --git a/scripts/help/help.m b/scripts/help/help.m
--- a/scripts/help/help.m
+++ b/scripts/help/help.m
@@ -61,17 +61,17 @@ function help (name)
       case "texinfo"
         [text, status] = __makeinfo__ (text, "plain text");
       case "html"
         [text, status] = strip_html_tags (text);
       case "not documented"
         error ("help: `%s' is not documented\n", name);
       case "not found"
         do_contents (name);
-	return;
+        return;
       otherwise
         error ("help: internal error: unsupported help text format: '%s'\n", format);
     endswitch
     
     ## Print text
     if (status != 0)
       warning ("help: Texinfo formatting filter exited abnormally; raw Texinfo source of help text follows...\n");
     endif
@@ -94,28 +94,28 @@ function do_contents (name)
   for i = 1:numel (dlist)
     fname = make_absolute_filename (fullfile (dlist{i}, "Contents.m"));
 
     [text, format] = get_help_text_from_file (fname);
 
     ## Take action depending on help text format
     switch (lower (format))
       case "plain text"
-	status = 0;
+        status = 0;
       case "texinfo"
-	[text, status] = __makeinfo__ (text, "plain text");
+        [text, status] = __makeinfo__ (text, "plain text");
       case "html"
-	[text, status] = strip_html_tags (text);
+        [text, status] = strip_html_tags (text);
     endswitch
 
     if (! isempty (text))
       found = true;
       ## Print text.
       if (status != 0)
-	warning ("help: Texinfo formatting filter exited abnormally; raw Texinfo source of help text follows...\n");
+        warning ("help: Texinfo formatting filter exited abnormally; raw Texinfo source of help text follows...\n");
       endif
       printf ("%s:\n\n%s\n", fname, text);
     endif
 
   endfor
 
   if (found)
     puts (__additional_help_message__ ());
diff --git a/scripts/help/which.m b/scripts/help/which.m
--- a/scripts/help/which.m
+++ b/scripts/help/which.m
@@ -23,30 +23,30 @@
 
 function varargout = which (varargin)
 
   if (nargin > 0 && iscellstr (varargin))
     m = __which__ (varargin{:});
 
     if (nargout == 0)
       for i = 1:nargin
-	if (isempty (m(i).file))
-	  if (! isempty (m(i).type))
-	    printf ("`%s' is a %s\n",
-		    m(i).name, m(i).type);
-	  endif
-	else
-	  if (isempty (m(i).type))
-	    printf ("`%s' is the file %s\n",
-		    m(i).name, m(i).file);
-	  else
-	    printf ("`%s' is a %s from the file %s\n",
-		    m(i).name, m(i).type, m(i).file);
-	  endif
-	endif
+        if (isempty (m(i).file))
+          if (! isempty (m(i).type))
+            printf ("`%s' is a %s\n",
+                    m(i).name, m(i).type);
+          endif
+        else
+          if (isempty (m(i).type))
+            printf ("`%s' is the file %s\n",
+                    m(i).name, m(i).file);
+          else
+            printf ("`%s' is a %s from the file %s\n",
+                    m(i).name, m(i).type, m(i).file);
+          endif
+        endif
       endfor
     else
       varargout = {m.file};
     endif
   else
     print_usage ();
   endif
 
diff --git a/scripts/io/dlmwrite.m b/scripts/io/dlmwrite.m
--- a/scripts/io/dlmwrite.m
+++ b/scripts/io/dlmwrite.m
@@ -106,74 +106,74 @@ function dlmwrite (file, a, varargin)
     i = i + 1;
     if (strcmpi (varargin{i}, "delimiter"))
       i = i + 1;
       delim = varargin{i};
     elseif (strcmpi (varargin{i}, "newline"))
       i = i + 1;
       newline = varargin{i};
       if (strcmpi (newline, "unix"))
-	newline = "\n";
+        newline = "\n";
       elseif (strcmpi (newline, "pc"))
-	newline = "\r\n";
+        newline = "\r\n";
       elseif (strcmpi (newline, "mac"))
-	newline = "\r";
+        newline = "\r";
       endif
     elseif (strcmpi (varargin{i}, "roffset"))
       i = i + 1;
       r = varargin{i};
     elseif (strcmpi (varargin{i}, "coffset"))
       i = i + 1;
       c = varargin{i};
     elseif (strcmpi (varargin{i}, "precision"))
       i = i + 1;
       precision = varargin{i};
       if (! strcmpi (class (precision), "char"))
-	precision = sprintf ("%.%gg", precision);
+        precision = sprintf ("%.%gg", precision);
       endif
     elseif (strcmpi (varargin{i}, "-append"))
       opentype = "at";
     elseif (strcmpi (varargin{i}, "append"))
       i = i + 1;
       if (strcmpi (varargin{i}, "on"))
-	opentype = "at";
+        opentype = "at";
       elseif (strcmpi (varargin{i}, "off"))
-	opentype = "wt";
+        opentype = "wt";
       else
-	error ("dlmwrite: append must be \"on\" or \"off\".");
+        error ("dlmwrite: append must be \"on\" or \"off\".");
       endif
     else
       if (i == 1)
-	delim = varargin{i};
+        delim = varargin{i};
       elseif (i == 2)
-	r = varargin{i};
+        r = varargin{i};
       elseif (i == 3)
-	c = varargin{i};
+        c = varargin{i};
       else
-	print_usage();
+        print_usage();
       endif
     endif
   endwhile
 
   [fid, msg] = fopen (file, opentype);
   if (fid < 0)
     error (msg);
   else
     if (r > 0)
       fprintf (fid, "%s",
-	       repmat ([repmat(delim, 1, c + columns(a)-1), newline], 1, r));
+               repmat ([repmat(delim, 1, c + columns(a)-1), newline], 1, r));
     endif
     if (iscomplex (a))
       cprecision = regexprep (precision, '^%([-\d.])','%+$1');
       template = [precision, cprecision, "i", ...
-		  repmat([delim, precision, cprecision, "i"], 1, ...
-		  columns(a) - 1), newline ];
+                  repmat([delim, precision, cprecision, "i"], 1, ...
+                  columns(a) - 1), newline ];
     else
       template = [precision, repmat([delim, precision], 1, columns(a)-1),...
-		  newline];
+                  newline];
     endif
     if (c > 0)
       template = [repmat(delim, 1, c), template];
     endif
     if (iscomplex (a))
       a = a.';
       b = zeros (2*rows(a), columns (a));
       b(1: 2 : end, :) = real (a);
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -110,26 +110,26 @@ function varargout = strread (str, forma
           case "shell"
             comment_specif = {"#", "\n"};
           case "matlab"
             comment_specif = {"%", "\n"};
           otherwise
             warning ("strread: unknown comment style '%s'", val);
         endswitch
       case "delimiter"
-	delimiter_str = varargin {n+1};
+        delimiter_str = varargin {n+1};
       case "emptyvalue"
-	numeric_fill_value = varargin {n+1};
+        numeric_fill_value = varargin {n+1};
       case "bufsize"
         ## XXX: We could synthesize this, but that just seems weird...
-	warning ("strread: property \"bufsize\"  is not implemented");
+        warning ("strread: property \"bufsize\"  is not implemented");
       case "whitespace"
-	white_spaces = varargin {n+1}; 
+        white_spaces = varargin {n+1}; 
       case "expchars"
-	warning ("strread: property \"expchars\"  is not implemented");
+        warning ("strread: property \"expchars\"  is not implemented");
       otherwise
         warning ("strread: unknown property \"%s\"", varargin {n});
     endswitch
   endfor
 
   ## Parse format string
   idx = strfind (formatstr, "%")';
   specif = formatstr ([idx, idx+1]);
diff --git a/scripts/linear-algebra/condest.m b/scripts/linear-algebra/condest.m
--- a/scripts/linear-algebra/condest.m
+++ b/scripts/linear-algebra/condest.m
@@ -120,28 +120,28 @@ function [est, v] = condest (varargin)
     if (! issquare (A))
       error ("condest: matrix must be square");
     endif
     n = rows (A);
     have_A = true;
 
     if (nargin > 1)
       if (isscalar (varargin{2}))
-	t = varargin{2};
-	have_t = true;
+        t = varargin{2};
+        have_t = true;
       elseif (nargin > 2)
-	solve = varargin{2};
-	solve_t = varargin{3};
-	have_solve = true;
-	if (nargin > 3)
-	  t = varargin{4};
-	  have_t = true;
-	endif
+        solve = varargin{2};
+        solve_t = varargin{3};
+        have_solve = true;
+        if (nargin > 3)
+          t = varargin{4};
+          have_t = true;
+        endif
       else
-	error ("condest: must supply both solve and solve_t");
+        error ("condest: must supply both solve and solve_t");
       endif
     endif
   elseif (nargin > 4)
     apply = varargin{1};
     apply_t = varargin{2};
     solve = varargin{3};
     solve_t = varargin{4};
     have_solve = true;
diff --git a/scripts/linear-algebra/cross.m b/scripts/linear-algebra/cross.m
--- a/scripts/linear-algebra/cross.m
+++ b/scripts/linear-algebra/cross.m
@@ -37,17 +37,17 @@
 ## @seealso{dot}
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 15 October 1994
 ## Adapted-By: jwe
 
 function z = cross (x, y, dim)
-	
+        
   if (nargin != 2 && nargin != 3)
     print_usage ();
   endif
 
   if (ndims (x) < 3 && ndims (y) < 3 && nargin < 3)
     ## COMPATIBILITY -- opposite behaviour for cross(row,col)
     ## Swap x and y in the assignments below to get the matlab behaviour.
     ## Better yet, fix the calling code so that it uses conformant vectors.
diff --git a/scripts/linear-algebra/krylov.m b/scripts/linear-algebra/krylov.m
--- a/scripts/linear-algebra/krylov.m
+++ b/scripts/linear-algebra/krylov.m
@@ -84,17 +84,17 @@ function [Uret, H, nu] = krylov (A, V, k
   if (! issquare (A) || isempty (A))
     error ("A(%d x %d) must be non-empty square matrix", rows (A), columns (A));
   endif
   na = rows (A);
 
   [m, kb] = size (V);
   if (m != na)
     error("A(%d x %d), V(%d x %d): argument dimensions do not match",
-	  na, na, m, kb)
+          na, na, m, kb)
   endif
 
   if (! isscalar (k))
     error ("krylov: third argument must be a scalar integer");
   endif
 
   Vnrm = norm (V, Inf);
 
@@ -125,55 +125,55 @@ function [Uret, H, nu] = krylov (A, V, k
       ## Index of next Householder reflection.
       nu = length(alpha)+1;
 
       short_pv = pivot_vec(nu:na);
       q = V(:,jj);
       short_q = q(short_pv);
 
       if (norm (short_q) < eps1)
-	## Insignificant column; delete.
+        ## Insignificant column; delete.
         nv = columns (V);
         if (jj != nv)
           [V(:,jj), V(:,nv)] = swap (V(:,jj), V(:,nv));
-	  ## FIXME -- H columns should be swapped too.  Not done
-	  ## since Block Hessenberg structure is lost anyway.
+          ## FIXME -- H columns should be swapped too.  Not done
+          ## since Block Hessenberg structure is lost anyway.
         endif
         V = V(:,1:(nv-1));
-	## One less reflection.
+        ## One less reflection.
         nu--;
       else
-	## New householder reflection.
+        ## New householder reflection.
         if (pflg)
           ## Locate max magnitude element in short_q.
           asq = abs (short_q);
           maxv = max (asq);
           maxidx = find (asq == maxv, 1);
           pivot_idx = short_pv(maxidx);
 
-	  ## See if need to change the pivot list.
+          ## See if need to change the pivot list.
           if (pivot_idx != pivot_vec(nu))
             swapidx = maxidx + (nu-1);
             [pivot_vec(nu), pivot_vec(swapidx)] = ...
-		swap (pivot_vec(nu), pivot_vec(swapidx));
+                swap (pivot_vec(nu), pivot_vec(swapidx));
           endif
         endif
 
-	## Isolate portion of vector for reflection.
+        ## Isolate portion of vector for reflection.
         idx = pivot_vec(nu:na);
         jdx = pivot_vec(1:nu);
 
         [hv, av, z] = housh (q(idx), 1, 0);
         alpha(nu) = av;
         U(idx,nu) = hv;
 
         ## Reduce V per the reflection.
         V(idx,:) = V(idx,:) - av*hv*(hv' * V(idx,:));
         if(iter > 1)
-	  ## FIXME -- not done correctly for block case.
+          ## FIXME -- not done correctly for block case.
           H(nu,nu-1) = V(pivot_vec(nu),jj);
         endif
 
         ## Advance to next column of V.
         jj++;
       endif
     endwhile
 
@@ -228,17 +228,17 @@ function [Uret, H, nu] = krylov (A, V, k
     U(idx(1),i) = 1;
     U(idx,i:j1) = U(idx,i:j1)-av*hv*(hv'*U(idx,i:j1));
   endfor
 
   nu = length (alpha);
   Uret = U;
   if (max (max (abs (Uret(zidx,:)))) > 0)
     warning ("krylov: trivial null space corrupted; set pflg = 1 or eps1 > %e",
-	     eps1);
+             eps1);
   endif
 
 endfunction
 
 
 function [a1, b1] = swap (a, b)
 
   a1 = b;
diff --git a/scripts/linear-algebra/null.m b/scripts/linear-algebra/null.m
--- a/scripts/linear-algebra/null.m
+++ b/scripts/linear-algebra/null.m
@@ -48,31 +48,31 @@ function retval = null (A, tol)
     if (S_nr == 1 || S_nc == 1)
       s = S(1);
     else
       s = diag (S);
     endif
 
     if (nargin == 1)
       if (isa (A, "single"))
-	tol = max (size (A)) * s (1) * eps ("single");
+        tol = max (size (A)) * s (1) * eps ("single");
       else
-	tol = max (size (A)) * s (1) * eps;
+        tol = max (size (A)) * s (1) * eps;
       endif
     elseif (nargin != 2)
       print_usage ();
     endif
 
     rank = sum (s > tol);
 
     if (rank < cols)
       retval = V (:, rank+1:cols);
       if (isa (A, "single"))
-	retval(abs (retval) < eps ("single")) = 0;
+        retval(abs (retval) < eps ("single")) = 0;
       else
-	retval(abs (retval) < eps) = 0;
+        retval(abs (retval) < eps) = 0;
       endif
     else
       retval = zeros (cols, 0);
     endif
   endif
 
 endfunction
diff --git a/scripts/linear-algebra/onenormest.m b/scripts/linear-algebra/onenormest.m
--- a/scripts/linear-algebra/onenormest.m
+++ b/scripts/linear-algebra/onenormest.m
@@ -205,24 +205,24 @@ function [est, v, w, iter] = onenormest 
     if (iter >= 2 && mhi == ind_best)
       ## Hit a cycle, stop.
       break;
     endif
     [h, ind] = sort (h, 'descend');
     if (t > 1)
       firstind = ind(1:t);
       if (all (been_there(firstind)))
-	## Visited all these before, so stop.
-	break;
+        ## Visited all these before, so stop.
+        break;
       endif
       ind = ind (!been_there (ind));
       if (length (ind) < t)
-	## There aren't enough new vectors, so we're practically
-	## in a cycle. Stop.
-	break;
+        ## There aren't enough new vectors, so we're practically
+        ## in a cycle. Stop.
+        break;
       endif
     endif
 
     ## Visit the new indices.
     X = zeros (n, t);
     for zz = 1 : t
       X(ind(zz),zz) = 1;
     endfor
diff --git a/scripts/linear-algebra/orth.m b/scripts/linear-algebra/orth.m
--- a/scripts/linear-algebra/orth.m
+++ b/scripts/linear-algebra/orth.m
@@ -47,19 +47,19 @@ function retval = orth (A, tol)
     if (S_nr == 1 || S_nc == 1)
       s = S(1);
     else
       s = diag (S);
     endif
 
     if (nargin == 1)
       if (isa (A, "single"))
-	tol = max (size (A)) * s (1) * eps ("single");
+        tol = max (size (A)) * s (1) * eps ("single");
       else
-	tol = max (size (A)) * s (1) * eps;
+        tol = max (size (A)) * s (1) * eps;
       endif
     endif
 
     rank = sum (s > tol);
 
     if (rank > 0)
       retval = -U (:, 1:rank);
     else
diff --git a/scripts/linear-algebra/rank.m b/scripts/linear-algebra/rank.m
--- a/scripts/linear-algebra/rank.m
+++ b/scripts/linear-algebra/rank.m
@@ -38,19 +38,19 @@
 function retval = rank (A, tol)
 
   if (nargin == 1)
     sigma = svd (A);
     if (isempty (sigma))
       tolerance = 0;
     else
       if (isa (A, "single"))
-	tolerance = max (size (A)) * sigma (1) * eps ("single");
+        tolerance = max (size (A)) * sigma (1) * eps ("single");
       else
-	tolerance = max (size (A)) * sigma (1) * eps;
+        tolerance = max (size (A)) * sigma (1) * eps;
       endif
     endif
   elseif (nargin == 2)
     sigma = svd (A);
     tolerance = tol;
   else
     print_usage ();
   endif
diff --git a/scripts/linear-algebra/rref.m b/scripts/linear-algebra/rref.m
--- a/scripts/linear-algebra/rref.m
+++ b/scripts/linear-algebra/rref.m
@@ -73,15 +73,15 @@ function [A, k] = rref (A, tolerance)
       A (r, c:cols) = A (r, c:cols) / A (r, c);
 
       ## Eliminate the current column
       ridx = [1:r-1, r+1:rows];
       A (ridx, c:cols) = A (ridx, c:cols) - A (ridx, c) * A(r, c:cols);
 
       ## Check if done
       if (r++ == rows)
-	break;
+        break;
       endif
     endif
   endfor
   k = find (used);
 
 endfunction
diff --git a/scripts/miscellaneous/bincoeff.m b/scripts/miscellaneous/bincoeff.m
--- a/scripts/miscellaneous/bincoeff.m
+++ b/scripts/miscellaneous/bincoeff.m
@@ -75,29 +75,29 @@ function b = bincoeff (n, k)
   ind = (! (k >= 0) | (k != real (round (k))) | isnan (n));
   b(ind) = NaN;
   
   ind = (k == 0);
   b(ind) = 1;
 
   ind = ((k > 0) & ((n == real (round (n))) & (n < 0)));
   b(ind) = (-1) .^ k(ind) .* exp (gammaln (abs (n(ind)) + k(ind))
-				  - gammaln (k(ind) + 1)
-				  - gammaln (abs (n(ind))));
+                                  - gammaln (k(ind) + 1)
+                                  - gammaln (abs (n(ind))));
 
   ind = ((k > 0) & (n >= k));
   b(ind) = exp (gammaln (n(ind) + 1)
-		- gammaln (k(ind) + 1)
-		- gammaln (n(ind) - k(ind) + 1));
+                - gammaln (k(ind) + 1)
+                - gammaln (n(ind) - k(ind) + 1));
 
   ind = ((k > 0) & ((n != real (round (n))) & (n < k)));
   b(ind) = (1/pi) * exp (gammaln (n(ind) + 1)
-			 - gammaln (k(ind) + 1)
-			 + gammaln (k(ind) - n(ind))
-			 + log (sin (pi * (n(ind) - k(ind) + 1))));
+                         - gammaln (k(ind) + 1)
+                         + gammaln (k(ind) - n(ind))
+                         + log (sin (pi * (n(ind) - k(ind) + 1))));
 
   ## Clean up rounding errors.
   ind = (n == round (n));
   b(ind) = round (b(ind));
 
   ind = (n != round (n));
   b(ind) = real (b(ind));
 
diff --git a/scripts/miscellaneous/cast.m b/scripts/miscellaneous/cast.m
--- a/scripts/miscellaneous/cast.m
+++ b/scripts/miscellaneous/cast.m
@@ -24,21 +24,21 @@
 
 ## Author: jwe
 
 function retval = cast (val, typ)
 
   if (nargin == 2)
     if (ischar (typ))
       if (any (strcmp (typ, {"int8"; "uint8"; "int16"; "uint16";
-			     "int32"; "uint32"; "int64"; "uint64";
-			     "double"; "single"; "logical"; "char"})))
-	retval = feval (typ, val);
+                             "int32"; "uint32"; "int64"; "uint64";
+                             "double"; "single"; "logical"; "char"})))
+        retval = feval (typ, val);
       else
-	error ("cast: type name `%s' is not a built-in type", typ);
+        error ("cast: type name `%s' is not a built-in type", typ);
       endif
     else
       error ("cast: expecting type name as second argument");
     endif
   else
     print_usage ();
   endif
 
diff --git a/scripts/miscellaneous/compare_versions.m b/scripts/miscellaneous/compare_versions.m
--- a/scripts/miscellaneous/compare_versions.m
+++ b/scripts/miscellaneous/compare_versions.m
@@ -108,17 +108,17 @@ function out = compare_versions (v1, v2,
     v2c = "";
     v2nochar = v2;
   endif
 
   v1n = str2num (char (strsplit (v1nochar, ".")));
   v2n = str2num (char (strsplit (v2nochar, ".")));
   if ((isempty (v1n) && isempty (v1c)) || (isempty (v2n) && isempty(v2c)))
     error ("compare_versions: given version strings are not valid: %s %s",
-	   v1, v2);
+           v1, v2);
   endif
 
   ## Assume that any additional elements would be 0 if one is longer
   ## than the other.
   maxnumlen = max ([length(v1n) length(v2n)]);
   if (length (v1n) < maxnumlen)
     v1n(length(v1n)+1:maxnumlen) = 0;
   endif
diff --git a/scripts/miscellaneous/copyfile.m b/scripts/miscellaneous/copyfile.m
--- a/scripts/miscellaneous/copyfile.m
+++ b/scripts/miscellaneous/copyfile.m
@@ -80,47 +80,47 @@ function [status, msg, msgid] = copyfile
       error ("copyfile: no files to move");
     endif
     p1 = sprintf ("\"%s\" ", f1{:});
     p2 = tilde_expand (f2);
 
     if (isdir && length(p1) > max_cmd_line)
       l2 = length(p2) + length (cmd) + 6;
       while (! isempty(f1))
-	p1 = sprintf ("\"%s\" ", f1{1});
-	f1(1) = [];
-	while (!isempty (f1) && (length(p1) + length(f1{1}) + l2 < 
-				 max_cmd_line))
-	  p1 = sprintf ("%s\"%s\" ", p1, f1{1});
-	  f1(1) = [];
-	endwhile 
+        p1 = sprintf ("\"%s\" ", f1{1});
+        f1(1) = [];
+        while (!isempty (f1) && (length(p1) + length(f1{1}) + l2 < 
+                                 max_cmd_line))
+          p1 = sprintf ("%s\"%s\" ", p1, f1{1});
+          f1(1) = [];
+        endwhile 
 
-	if (ispc () && ! isunix () && ! isempty (file_in_path (EXEC_PATH, "cp.exe")))
-	  p1 = strrep (p1, "\\", "/");
-	  p2 = strrep (p2, "\\", "/");
-	endif
+        if (ispc () && ! isunix () && ! isempty (file_in_path (EXEC_PATH, "cp.exe")))
+          p1 = strrep (p1, "\\", "/");
+          p2 = strrep (p2, "\\", "/");
+        endif
 
-	## Copy the files.
-	[err, msg] = system (sprintf ("%s %s\"%s\"", cmd, p1, p2));
-	if (err < 0)
-	  status = false;
-	  msgid = "copyfile";
-	  break;
-	endif
+        ## Copy the files.
+        [err, msg] = system (sprintf ("%s %s\"%s\"", cmd, p1, p2));
+        if (err < 0)
+          status = false;
+          msgid = "copyfile";
+          break;
+        endif
       endwhile
     else
       if (ispc () && ! isunix () && ! isempty (file_in_path (EXEC_PATH, "cp.exe")))
-	p1 = strrep (p1, "\\", "/");
-	p2 = strrep (p2, "\\", "/");
+        p1 = strrep (p1, "\\", "/");
+        p2 = strrep (p2, "\\", "/");
       endif
 
       ## Copy the files.
       [err, msg] = system (sprintf ("%s %s\"%s\"", cmd, p1, p2));
       if (err < 0)
-	status = false;
-	msgid = "copyfile";
+        status = false;
+        msgid = "copyfile";
       endif
     endif
   else
     print_usage ();
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/dir.m b/scripts/miscellaneous/dir.m
--- a/scripts/miscellaneous/dir.m
+++ b/scripts/miscellaneous/dir.m
@@ -57,17 +57,17 @@ function retval = dir (file)
   if (nargin == 0)
     file = ".";
   elseif (nargin > 1)
     print_usage ();
   endif
 
   ## Prep the retval.
   info = struct (zeros (0, 1),
-		 {"name", "date", "bytes", "isdir", "datenum", "statinfo"});
+                 {"name", "date", "bytes", "isdir", "datenum", "statinfo"});
 
   if (ischar (file))
     if (strcmp (file, "*"))
       file = ".";
     endif
     if (strcmp (file, "."))
       flst = {"."};
       nf = 1;
@@ -77,55 +77,55 @@ function retval = dir (file)
     endif
 
     ## Determine the file list for the case where a single directory is
     ## specified.
     if (nf == 1)
       fn = flst{1};
       [st, err, msg] = stat (fn);
       if (err < 0)
-	warning ("dir: `stat (%s)' failed: %s", fn, msg);
-	nf = 0;
+        warning ("dir: `stat (%s)' failed: %s", fn, msg);
+        nf = 0;
       elseif (S_ISDIR (st.mode))
-	flst = readdir (flst{1});
-	nf = length (flst);
-	for i = 1:nf
-	  flst{i} = fullfile (fn, flst{i});
-	endfor
+        flst = readdir (flst{1});
+        nf = length (flst);
+        for i = 1:nf
+          flst{i} = fullfile (fn, flst{i});
+        endfor
       endif
     endif
 
     if (length (flst) > 0)
       ## Collect results.
       for i = nf:-1:1
-	fn = flst{i};
-	[st, err, msg] = lstat (fn);
-	if (err < 0)
-	  warning ("dir: `lstat (%s)' failed: %s", fn, msg);
-	else
-	  ## If we are looking at a link that points to something,
-	  ## return info about the target of the link, otherwise, return
-	  ## info about the link itself.
-	  if (S_ISLNK (st.mode))
-	    [xst, err, msg] = stat (fn);
-	    if (! err)
-	      st = xst;
-	    endif
-	  endif
-	  [dummy, fn, ext] = fileparts (fn);
-	  fn = cstrcat (fn, ext);
-	  info(i,1).name = fn;
-	  lt = localtime (st.mtime);
-	  info(i,1).date = strftime ("%d-%b-%Y %T", lt);
-	  info(i,1).bytes = st.size;
-	  info(i,1).isdir = S_ISDIR (st.mode);
-	  info(i,1).datenum = datenum (lt.year + 1900, lt.mon + 1, lt.mday,
-				       lt.hour, lt.min, lt.sec);
-	  info(i,1).statinfo = st;
-	endif
+        fn = flst{i};
+        [st, err, msg] = lstat (fn);
+        if (err < 0)
+          warning ("dir: `lstat (%s)' failed: %s", fn, msg);
+        else
+          ## If we are looking at a link that points to something,
+          ## return info about the target of the link, otherwise, return
+          ## info about the link itself.
+          if (S_ISLNK (st.mode))
+            [xst, err, msg] = stat (fn);
+            if (! err)
+              st = xst;
+            endif
+          endif
+          [dummy, fn, ext] = fileparts (fn);
+          fn = cstrcat (fn, ext);
+          info(i,1).name = fn;
+          lt = localtime (st.mtime);
+          info(i,1).date = strftime ("%d-%b-%Y %T", lt);
+          info(i,1).bytes = st.size;
+          info(i,1).isdir = S_ISDIR (st.mode);
+          info(i,1).datenum = datenum (lt.year + 1900, lt.mon + 1, lt.mday,
+                                       lt.hour, lt.min, lt.sec);
+          info(i,1).statinfo = st;
+        endif
       endfor
     endif
 
   else
     error ("dir: expecting directory or filename to be a char array");
   endif
 
   ## Return the output arguments.
diff --git a/scripts/miscellaneous/dump_prefs.m b/scripts/miscellaneous/dump_prefs.m
--- a/scripts/miscellaneous/dump_prefs.m
+++ b/scripts/miscellaneous/dump_prefs.m
@@ -82,17 +82,17 @@ function dump_prefs (file)
               "struct_levels_to_print";
               "suppress_verbose_help_message"];
 
   for i = 1:rows(sym_list)
     sym = deblank (sym_list(i,:));
     try
       val = feval (sym);
       if (isnumeric (val))
-	val = sprintf ("%g", val);
+        val = sprintf ("%g", val);
       endif
       fprintf (file, "  %s = %s\n", sym, val);
     catch
       fprintf (file, "# %s = <no value or error in displaying it>\n", sym);
     end_try_catch
   endfor
 
 endfunction
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -138,46 +138,46 @@
 ## Original version by Paul Kienzle distributed as free software in the
 ## public domain.
 
 function ret = edit (file, state)
 
   ## Pick up globals or default them.
 
   persistent FUNCTION = struct ("EDITOR", cstrcat (EDITOR (), " %s"),
-  				"HOME", fullfile (default_home, "octave"),
-  				"AUTHOR", default_user(1),
-  				"EMAIL",  [],
-  				"LICENSE",  "GPL",
-  				"MODE", "sync",
-  				"EDITINPLACE", false);
+                                "HOME", fullfile (default_home, "octave"),
+                                "AUTHOR", default_user(1),
+                                "EMAIL",  [],
+                                "LICENSE",  "GPL",
+                                "MODE", "sync",
+                                "EDITINPLACE", false);
 
   ## Make sure the state variables survive "clear functions".
   mlock;
 
   if (nargin == 2)
     switch (toupper (file))
     case "EDITOR"
       FUNCTION.EDITOR = state;
     case "HOME"
       if (! isempty (state) && state(1) == "~")
-	state = [ default_home, state(2:end) ];
+        state = [ default_home, state(2:end) ];
       endif
       FUNCTION.HOME = state;
     case "AUTHOR"
       FUNCTION.AUTHOR = state;
     case "EMAIL"
       FUNCTION.EMAIL = state;
     case "LICENSE"
       FUNCTION.LICENSE = state;
     case "MODE"
       if (strcmp (state, "sync") || strcmp (state, "async"))
         FUNCTION.MODE = state;
       else
-    	error('expected "edit MODE sync|async"');
+        error('expected "edit MODE sync|async"');
       endif
     case "EDITINPLACE"
       if (ischar (state))
         if (strcmpi (state, "true"))
           state = true;
         elseif (strcmpi (state, "false"))
           state = false;
         else
@@ -196,18 +196,18 @@ function ret = edit (file, state)
     endswitch
     return
   endif
 
   ## Start the editor without a file if no file is given.
   if (nargin < 1)
     if (exist (FUNCTION.HOME, "dir") == 7 && (isunix () || ! ispc ()))
       system (cstrcat ("cd \"", FUNCTION.HOME, "\" ; ",
-		      sprintf (FUNCTION.EDITOR, "")),
-	      [], FUNCTION.MODE);
+                      sprintf (FUNCTION.EDITOR, "")),
+              [], FUNCTION.MODE);
     else
       system (sprintf (FUNCTION.EDITOR,""), [], FUNCTION.MODE);
     endif
     return;
   endif
 
   ## Check whether the user is trying to edit a builtin of compiled function.
   switch (exist (file))
@@ -303,34 +303,34 @@ function ret = edit (file, state)
   idx = rindex (file, ".");
   name = file(1:idx-1);
   ext = file(idx+1:end);
   switch (ext)
     case {"cc", "m"}
       0;
     otherwise
       system (sprintf (FUNCTION.EDITOR, cstrcat ("\"", fileandpath, "\"")),
-	      [], FUNCTION.MODE);
+              [], FUNCTION.MODE);
       return;
   endswitch
 
   ## The file doesn't exist in path so create it, put in the function
   ## template and edit it.
 
   ## Guess the email name if it was not given.
   if (isempty (FUNCTION.EMAIL))
     host = getenv("HOSTNAME");
     if (isempty (host) && ispc ())
       host = getenv ("COMPUTERNAME");
     endif
     if (isempty (host))
       [status, host] = system ("uname -n");
       ## trim newline from end of hostname
       if (! isempty (host))
-	host = host(1:end-1);
+        host = host(1:end-1);
       endif
     endif
     if (isempty (host))
       FUNCTION.EMAIL = " ";
     else
       FUNCTION.EMAIL = cstrcat ("<", default_user(0), "@", host, ">");
     endif
   endif
@@ -390,77 +390,77 @@ LIABILITY, OR TORT (INCLUDING NEGLIGENCE
 OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n\
 SUCH DAMAGE.\
 ");
       tail = cstrcat (author, "\n", revs);
 
     case "PD"
       head = "";
       tail = cstrcat (author, "\n", revs, "\n\n",
-		     "This program is granted to the public domain.");
+                     "This program is granted to the public domain.");
 
     otherwise
       head = "";
       tail = cstrcat (copyright, "\n\n", FUNCTION.LICENSE, "\n",
-		     author, "\n", revs);
+                     author, "\n", revs);
   endswitch
 
   ## Generate the function template.
   exists = exist (name);
   switch (ext)
     case {"cc", "C", "cpp"}
       if (isempty (head))
-	comment = cstrcat ("/*\n", tail, "\n\n*/\n\n");
+        comment = cstrcat ("/*\n", tail, "\n\n*/\n\n");
       else
-	comment = cstrcat ("/*\n", head, "\n\n", tail, "\n\n*/\n\n");
+        comment = cstrcat ("/*\n", head, "\n\n", tail, "\n\n*/\n\n");
       endif
       ## If we are shadowing an m-file, paste the code for the m-file.
       if (any (exists == [2, 103]))
-	code = cstrcat ("\\ ", strrep (type (name), "\n", "\n// "));
+        code = cstrcat ("\\ ", strrep (type (name), "\n", "\n// "));
       else
-	code = " ";
+        code = " ";
       endif
       body = cstrcat ("#include <octave/oct.h>\n\n",
                      "DEFUN_DLD(", name, ",args,nargout,\"\\\n",
-		     name, "\\n\\\n\")\n{\n",
-		     "  octave_value_list retval;\n",
-		     "  int nargin = args.length();\n\n",
-		     code, "\n  return retval;\n}\n");
+                     name, "\\n\\\n\")\n{\n",
+                     "  octave_value_list retval;\n",
+                     "  int nargin = args.length();\n\n",
+                     code, "\n  return retval;\n}\n");
 
       text = cstrcat (comment, body);
     case "m"
       ## If we are editing a function defined on the fly, paste the
       ## code.
       if (any (exists == [2, 103]))
-	body = type (name);
+        body = type (name);
       else
-	body = cstrcat ("function [ ret ] = ", name, " ()\n\nendfunction\n");
+        body = cstrcat ("function [ ret ] = ", name, " ()\n\nendfunction\n");
       endif
       if (isempty (head))
-	comment = cstrcat ("## ", name, "\n\n",
-			  "## ", strrep (tail, "\n", "\n## "), "\n\n");
+        comment = cstrcat ("## ", name, "\n\n",
+                          "## ", strrep (tail, "\n", "\n## "), "\n\n");
       else
-	comment = cstrcat ("## ", strrep(head,"\n","\n## "), "\n\n", ...
-			  "## ", name, "\n\n", ...
-			  "## ", strrep (tail, "\n", "\n## "), "\n\n");
+        comment = cstrcat ("## ", strrep(head,"\n","\n## "), "\n\n", ...
+                          "## ", name, "\n\n", ...
+                          "## ", strrep (tail, "\n", "\n## "), "\n\n");
       endif
       text = cstrcat (comment, body);
   endswitch
 
   ## Write the initial file (if there is anything to write)
   fid = fopen (fileandpath, "wt");
   if (fid < 0)
     error ("edit: could not create %s", fileandpath);
   endif
   fputs (fid, text);
   fclose (fid);
 
   ## Finally we are ready to edit it!
   system (sprintf (FUNCTION.EDITOR, cstrcat ("\"", fileandpath, "\"")),
-	  [], FUNCTION.MODE);
+          [], FUNCTION.MODE);
 
 endfunction
 
 function ret = default_home ()
 
   ret = getenv ("HOME");
   if (isempty (ret))
     ret = glob ("~");
diff --git a/scripts/miscellaneous/fileattrib.m b/scripts/miscellaneous/fileattrib.m
--- a/scripts/miscellaneous/fileattrib.m
+++ b/scripts/miscellaneous/fileattrib.m
@@ -81,57 +81,57 @@ function [status, msg, msgid] = fileattr
     endif
   else
     error ("fileattrib: expecting first argument to be a character string");
   endif
 
   if (nargin == 0 || nargin == 1)
 
     r_n = r_a = r_s = r_h = r_d ...
-	= r_u_r = r_u_w = r_u_x ...
-	= r_g_r = r_g_w = r_g_x ...
-	= r_o_r = r_o_w = r_o_x = cell (nfiles, 1);
+        = r_u_r = r_u_w = r_u_x ...
+        = r_g_r = r_g_w = r_g_x ...
+        = r_o_r = r_o_w = r_o_x = cell (nfiles, 1);
 
     curr_dir = pwd ();
 
     for i = 1:nfiles
       [info, err, msg] = stat (files{i});
       if (! err)
-	r_n{i} = canonicalize_file_name (files{i});
-	r_a{i} = NaN;
-	r_s{i} = NaN;
-	r_h{i} = NaN;
-	r_d{i} = S_ISDIR (info.mode);
-	## FIXME -- maybe we should have S_IRUSR etc. masks?
-	modestr = info.modestr;
-	r_u_r{i} = modestr(2) == "r";
-	r_u_w{i} = modestr(3) == "w";
-	r_u_x{i} = modestr(4) == "x";
-	r_g_r{i} = modestr(5) == "r";
-	r_g_w{i} = modestr(6) == "w";
-	r_g_x{i} = modestr(7) == "x";
-	r_o_r{i} = modestr(8) == "r";
-	r_o_w{i} = modestr(9) == "w";
-	r_o_x{i} = modestr(10) == "x";
+        r_n{i} = canonicalize_file_name (files{i});
+        r_a{i} = NaN;
+        r_s{i} = NaN;
+        r_h{i} = NaN;
+        r_d{i} = S_ISDIR (info.mode);
+        ## FIXME -- maybe we should have S_IRUSR etc. masks?
+        modestr = info.modestr;
+        r_u_r{i} = modestr(2) == "r";
+        r_u_w{i} = modestr(3) == "w";
+        r_u_x{i} = modestr(4) == "x";
+        r_g_r{i} = modestr(5) == "r";
+        r_g_w{i} = modestr(6) == "w";
+        r_g_x{i} = modestr(7) == "x";
+        r_o_r{i} = modestr(8) == "r";
+        r_o_w{i} = modestr(9) == "w";
+        r_o_x{i} = modestr(10) == "x";
       else
-	status = false;
-	msgid = "fileattrib";
-	break;
+        status = false;
+        msgid = "fileattrib";
+        break;
       endif
     endfor
     if (status)
       r = struct ("Name", r_n, "archive", r_a, "system", r_s,
-		  "hidden", r_s, "directory", r_d, "UserRead", r_u_r,
-		  "UserWrite", r_u_w, "UserExecute", r_u_x,
-		  "GroupRead", r_g_r, "GroupWrite", r_g_w,
-		  "GroupExecute", r_g_x, "OtherRead", r_o_r,
-		  "OtherWrite", r_o_w, "OtherExecute", r_o_x);
+                  "hidden", r_s, "directory", r_d, "UserRead", r_u_r,
+                  "UserWrite", r_u_w, "UserExecute", r_u_x,
+                  "GroupRead", r_g_r, "GroupWrite", r_g_w,
+                  "GroupExecute", r_g_x, "OtherRead", r_o_r,
+                  "OtherWrite", r_o_w, "OtherExecute", r_o_x);
       if (nargout == 0)
-	status = r;
+        status = r;
       else
-	msg = r;
+        msg = r;
       endif
     endif
   else
     print_usage ();
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/fileparts.m b/scripts/miscellaneous/fileparts.m
--- a/scripts/miscellaneous/fileparts.m
+++ b/scripts/miscellaneous/fileparts.m
@@ -24,35 +24,35 @@
 ## @end deftypefn
 
 function [directory, name, extension, version] = fileparts (filename)
 
   if (nargin == 1)
     if (ischar (filename))
       ds = strchr (filename, filesep ("all"), 1, "last");
       if (isempty (ds))
-	ds = 0;
+        ds = 0;
       endif
       es = rindex (filename, ".");
       ## These can be the same if they are both 0 (no dir or ext).
       if (es <= ds)
-	es = length(filename)+1;
+        es = length(filename)+1;
       endif
       if (ds == 0)
-	directory = "";
+        directory = "";
       elseif (ds == 1)
-	directory = filename(1);
+        directory = filename(1);
       else
-	directory = filename(1:ds-1);
+        directory = filename(1:ds-1);
       endif
       name = filename(ds+1:es-1);
       if (es > 0 && es <= length (filename))
-	extension = filename(es:end);
+        extension = filename(es:end);
       else
-	extension = "";
+        extension = "";
       endif
       version = "";
     else
       error ("fileparts: expecting filename argument to be a string");
     endif
   else
     print_usage ();
   endif
diff --git a/scripts/miscellaneous/fullfile.m b/scripts/miscellaneous/fullfile.m
--- a/scripts/miscellaneous/fullfile.m
+++ b/scripts/miscellaneous/fullfile.m
@@ -26,26 +26,26 @@ function filename = fullfile (varargin)
 
   if (nargin > 0)
     ## Discard all empty arguments
     varargin(cellfun (@isempty, varargin)) = [];
     nargs = numel (varargin);
     if (nargs > 1)
       filename = varargin{1};
       if (strcmp (filename(end), filesep))
-	filename(end) = "";
+        filename(end) = "";
       endif
       for i = 2:nargs
-	tmp = varargin{i};
-	if (i < nargs && strcmp (tmp(end), filesep))
-	  tmp(end) = "";
-	elseif (i == nargs && strcmp (tmp, filesep))
-	  tmp = "";
-	endif
-	filename = cstrcat (filename, filesep, tmp);
+        tmp = varargin{i};
+        if (i < nargs && strcmp (tmp(end), filesep))
+          tmp(end) = "";
+        elseif (i == nargs && strcmp (tmp, filesep))
+          tmp = "";
+        endif
+        filename = cstrcat (filename, filesep, tmp);
       endfor
     elseif (nargs == 1)
       filename = varargin{1};
     else
       filename = "";
     endif
   else
     print_usage ();
diff --git a/scripts/miscellaneous/license.m b/scripts/miscellaneous/license.m
--- a/scripts/miscellaneous/license.m
+++ b/scripts/miscellaneous/license.m
@@ -114,19 +114,19 @@ function retval = license (varargin)
     else
 
       if (! strcmp (varargin{1}, "inuse"))
         usage ("retval = license (\"inuse\")");
       endif
 
       pw = getpwuid (getuid ());
       if (isstruct (pw))
-	username = pw.name;
+        username = pw.name;
       else
-	username = "octave_user";
+        username = "octave_user";
       endif
 
       retval(1:nr_licenses) = struct ("feature", "", "user", "");
       for p = 1:nr_licenses
         retval(p).feature = __octave_licenses__{p,1};
         retval(p).user = username;
       endfor
 
diff --git a/scripts/miscellaneous/ls.m b/scripts/miscellaneous/ls.m
--- a/scripts/miscellaneous/ls.m
+++ b/scripts/miscellaneous/ls.m
@@ -52,23 +52,23 @@ function retval = ls (varargin)
 
     cmd = sprintf ("%s ", __ls_command__, args{:});
 
     if (page_screen_output () || nargout > 0)
 
       [status, output] = system (cmd);
 
       if (status == 0)
-	if (nargout == 0)
-	  puts (output);
-	else
-	  retval = strvcat (regexp (output, '[^\s]+', 'match'){:});
-	endif
+        if (nargout == 0)
+          puts (output);
+        else
+          retval = strvcat (regexp (output, '[^\s]+', 'match'){:});
+        endif
       else
-	error ("ls: command exited abnormally with status %d", status);
+        error ("ls: command exited abnormally with status %d", status);
       endif
 
     else
       ## Just let the output flow if the pager is off.  That way the
       ## output from things like "ls -R /" will show up immediately and
       ## we won't have to buffer all the output.
       system (cmd);
     endif
diff --git a/scripts/miscellaneous/ls_command.m b/scripts/miscellaneous/ls_command.m
--- a/scripts/miscellaneous/ls_command.m
+++ b/scripts/miscellaneous/ls_command.m
@@ -40,17 +40,17 @@ function old_cmd = ls_command (cmd)
   endif
 
   if (nargin == 0 || nargin == 1)
 
     old_cmd = __ls_command__;
 
     if (nargin == 1)
       if (ischar (cmd))
-	__ls_command__ = cmd;
+        __ls_command__ = cmd;
       else
-	error ("ls_command: expecting argument to be a character string");
+        error ("ls_command: expecting argument to be a character string");
       endif
     endif
 
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/mkoctfile.m b/scripts/miscellaneous/mkoctfile.m
--- a/scripts/miscellaneous/mkoctfile.m
+++ b/scripts/miscellaneous/mkoctfile.m
@@ -129,14 +129,14 @@ function mkoctfile (varargin)
   for i = 1:nargin
     cmd = cstrcat (cmd, " \"", varargin{i}, "\"");
   endfor
   
   status = system (cmd);
 
   if (status == 127)
     warning ("unable to find mkoctfile in expected location: `%s'",
-	     shell_script);
+             shell_script);
 
     warning ("mkoctfile exited with failure status");
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/movefile.m b/scripts/miscellaneous/movefile.m
--- a/scripts/miscellaneous/movefile.m
+++ b/scripts/miscellaneous/movefile.m
@@ -79,45 +79,45 @@ function [status, msg, msgid] = movefile
       error ("movefile: no files to move");
     endif
     p1 = sprintf ("\"%s\" ", f1{:});
     p2 = tilde_expand (f2);
 
     if (isdir && length(p1) > max_cmd_line)
       l2 = length(p2) + length (cmd) + 6;
       while (! isempty(f1))
-	p1 = sprintf ("\"%s\" ", f1{1});
-	f1(1) = [];
-	while (!isempty (f1) && (length(p1) + length(f1{1}) + l2 < 
-				 max_cmd_line))
-	  p1 = sprintf ("%s\"%s\" ", p1, f1{1});
-	  f1(1) = [];
-	endwhile 
+        p1 = sprintf ("\"%s\" ", f1{1});
+        f1(1) = [];
+        while (!isempty (f1) && (length(p1) + length(f1{1}) + l2 < 
+                                 max_cmd_line))
+          p1 = sprintf ("%s\"%s\" ", p1, f1{1});
+          f1(1) = [];
+        endwhile 
 
-	if (ispc () && ! isunix () && ! isempty (file_in_path (EXEC_PATH, "cp.exe")))
-	  p1 = strrep (p1, "\\", "/");
-	  p2 = strrep (p2, "\\", "/");
-	endif
+        if (ispc () && ! isunix () && ! isempty (file_in_path (EXEC_PATH, "cp.exe")))
+          p1 = strrep (p1, "\\", "/");
+          p2 = strrep (p2, "\\", "/");
+        endif
 
-	## Move the file(s).
-	[err, msg] = system (sprintf ("%s %s \"%s\"", cmd, p1, p2));
-	if (err < 0)
-	  status = false;
-	  msgid = "movefile";
-	endif
+        ## Move the file(s).
+        [err, msg] = system (sprintf ("%s %s \"%s\"", cmd, p1, p2));
+        if (err < 0)
+          status = false;
+          msgid = "movefile";
+        endif
       endwhile
     else
       if (ispc () && ! isunix () && ! isempty (file_in_path (EXEC_PATH, "cp.exe")))
-	p1 = strrep (p1, "\\", "/");
-	p2 = strrep (p2, "\\", "/");
+        p1 = strrep (p1, "\\", "/");
+        p2 = strrep (p2, "\\", "/");
       endif
 
       ## Move the file(s).
       [err, msg] = system (sprintf ("%s %s \"%s\"", cmd, p1, p2));
       if (err < 0)
-	status = false;
-	msgid = "movefile";
+        status = false;
+        msgid = "movefile";
       endif
     endif
   else
     print_usage ();
   endif
 endfunction
diff --git a/scripts/miscellaneous/orderfields.m b/scripts/miscellaneous/orderfields.m
--- a/scripts/miscellaneous/orderfields.m
+++ b/scripts/miscellaneous/orderfields.m
@@ -103,34 +103,34 @@ function [t, p] = orderfields (s1, s2)
     if (isstruct (s1))
       names = sort (fieldnames (s1));
     endif
   elseif (nargin == 2)
     if (isstruct (s2))
       ## Two structures: return the fields in the order of s2.
       names = fieldnames (s2);
       if (! isequal (sort (fieldnames (s1)), sort (names)))
-	error ("orderfields: structures do not have same fields");
+        error ("orderfields: structures do not have same fields");
       endif
     elseif (iscellstr (s2))
       ## A structure and a list of fields: order by the list of fields.
       t1 = sort (fieldnames (s1));
       t2 = sort (s2(:));
       if (! isequal (t1, t2))
-	error ("orderfields: name list does not match structure fields");
+        error ("orderfields: name list does not match structure fields");
       endif
       names = s2;
     elseif (isvector (s2))
       ## A structure and a permutation vector: permute the order of s1.
       names = fieldnames (s1);
       t1 = sort (s2);
       t1 = t1(:)';
       t2 = 1:numel (names);
       if (! isequal (t1, t2))
-	error ("orderfields: invalid permutation vector");
+        error ("orderfields: invalid permutation vector");
       endif
       names = names (s2);
     endif
   endif
 
   ## Find permutation vector which converts the original name order
   ## into the new name order.  Note: could save a couple of sorts
   ## in some cases, but performance isn't critical.
diff --git a/scripts/miscellaneous/perl.m b/scripts/miscellaneous/perl.m
--- a/scripts/miscellaneous/perl.m
+++ b/scripts/miscellaneous/perl.m
@@ -29,16 +29,16 @@
 function [output, status] = perl (script = "-e ''", varargin)
 
   ## VARARGIN is intialized to {}(1x0) if no additional arguments are
   ## supplied, so there is no need to check for it, or provide an
   ## initial value in the argument list of the function definition.
 
   if (ischar (script)
       && ((nargin != 1 && iscellstr (varargin))
-	  || (nargin == 1 && ! isempty (script))))
+          || (nargin == 1 && ! isempty (script))))
     [status, output] = system (cstrcat ("perl ", script,
-					sprintf (" %s", varargin{:})));
+                                        sprintf (" %s", varargin{:})));
   else
     error ("perl: invalid arguments");
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/run.m b/scripts/miscellaneous/run.m
--- a/scripts/miscellaneous/run.m
+++ b/scripts/miscellaneous/run.m
@@ -32,23 +32,23 @@ function run (s)
     print_usage ();
   endif
 
   [d, f, ext] = fileparts (s);
   if (! isempty (d))
     if (exist (d, "dir"))
       wd = pwd ();
       unwind_protect
-	cd (d);
-	if (! exist (f, "file") || ! strcmp (ext, ".m"))
-	  error ("run: file must exist and be a valid Octave script file");
-	endif
-	evalin ("caller", [f, ";"], "rethrow (lasterror ())");
+        cd (d);
+        if (! exist (f, "file") || ! strcmp (ext, ".m"))
+          error ("run: file must exist and be a valid Octave script file");
+        endif
+        evalin ("caller", [f, ";"], "rethrow (lasterror ())");
       unwind_protect_cleanup
-	cd (wd);
+        cd (wd);
       end_unwind_protect
     else
       error ("run: the path %s doesn't exist", d);
     endif
   else
     if (exist (f, "file"))
       evalin ("caller", [f, ";"], "rethrow (lasterror ())");
     else
diff --git a/scripts/miscellaneous/substruct.m b/scripts/miscellaneous/substruct.m
--- a/scripts/miscellaneous/substruct.m
+++ b/scripts/miscellaneous/substruct.m
@@ -54,17 +54,17 @@ function retval = substruct (varargin)
     typ = varargin(1:2:nargs);
     sub = varargin(2:2:nargs);
     braces = strcmp (typ, "()") | strcmp (typ, "{}");
     dots = strcmp (typ, ".");
     if (all (braces | dots))
       cells = cellfun ("isclass", sub, "cell");
       chars = cellfun ("isclass", sub, "char");
       if (any (braces &! cells))
-	error ("substruct: for type == () or {}, subs must be a cell array");
+        error ("substruct: for type == () or {}, subs must be a cell array");
       elseif (any (dots &! chars))
         error ("substruct: for type == ., subs must be a character string");
       endif
     else
       error ("substruct: expecting type to be one of \"()\", \"{}\", or \".\"");
     endif
 
     retval = struct ("type", typ, "subs", sub);
diff --git a/scripts/miscellaneous/swapbytes.m b/scripts/miscellaneous/swapbytes.m
--- a/scripts/miscellaneous/swapbytes.m
+++ b/scripts/miscellaneous/swapbytes.m
@@ -40,17 +40,17 @@ function y = swapbytes (x)
   if (strcmp (clx, "int8") || strcmp (clx, "uint8") || isempty (x))
     y = x;
   else
     if (strcmp (clx, "int16") || strcmp (clx, "uint16"))
       nb = 2;
     elseif (strcmp (clx, "int32") || strcmp (clx, "uint32"))
       nb = 4;
     elseif (strcmp (clx, "int64") || strcmp (clx, "uint64") ||
-	    strcmp (clx, "double"))
+            strcmp (clx, "double"))
       nb = 8;
     else
       error ("swapbytes: invalid class of object");
     endif
     y = reshape (typecast (reshape (typecast (x(:), "uint8"), nb, numel (x))
-			   ([nb : -1 : 1], :) (:), clx), size(x));
+                           ([nb : -1 : 1], :) (:), clx), size(x));
   endif
 endfunction
diff --git a/scripts/miscellaneous/tar.m b/scripts/miscellaneous/tar.m
--- a/scripts/miscellaneous/tar.m
+++ b/scripts/miscellaneous/tar.m
@@ -42,30 +42,30 @@ function entries = tar (tarfile, files, 
     ## Test type of input
     if (ischar (files))
       files = cellstr (files);
     endif
 
     if (ischar (tarfile) && iscellstr (files) && ischar (root))
 
       cmd = sprintf ("tar cvf %s -C %s %s", tarfile, root,
-		     sprintf (" %s", files{:}));
+                     sprintf (" %s", files{:}));
 
       [status, output] = system (cmd);
 
       if (status == 0)
-	if (nargout > 0)
-	  if (output(end) == "\n")
-	    output(end) = [];
-	  endif
+        if (nargout > 0)
+          if (output(end) == "\n")
+            output(end) = [];
+          endif
           entries = strsplit (output, "\n");
-	  entries = entries';
-	endif
+          entries = entries';
+        endif
       else
-	error ("tar: tar exited with status = %d", status);
+        error ("tar: tar exited with status = %d", status);
       endif
     
     else
       error ("tar: expecting all arguments to be character strings");
     endif
 
   else
     print_usage("tar");
diff --git a/scripts/miscellaneous/unpack.m b/scripts/miscellaneous/unpack.m
--- a/scripts/miscellaneous/unpack.m
+++ b/scripts/miscellaneous/unpack.m
@@ -43,44 +43,44 @@ function filelist = unpack (file, direct
   endif
   if (nargin < 3)
     filetype = "";
   endif
 
   if (ischar (file))
     if (isdir (file))
       if (isempty (filetype))
-	error ("unpack: filetype must be given for a directory");
+        error ("unpack: filetype must be given for a directory");
       elseif (! any (strcmpi (filetype, "gunzip")))
-	error ("unpack: filetype must be gunzip for a directory");
+        error ("unpack: filetype must be gunzip for a directory");
       endif
     else
       [pathstr, name, ext] = fileparts (file);
 
       ## Check to see if it's .tar.gz, .tar.Z, etc.
       if (any (strcmpi ({".gz" ".Z" ".bz2" ".bz"}, ext)))
-	[tmppathstr, tmpname, tmpext] = fileparts (name);
-	if (strcmpi (tmpext, ".tar"))
-	  name = tmpname;
-	  ext = cstrcat (tmpext, ext);
-	endif
+        [tmppathstr, tmpname, tmpext] = fileparts (name);
+        if (strcmpi (tmpext, ".tar"))
+          name = tmpname;
+          ext = cstrcat (tmpext, ext);
+        endif
       endif
 
       ## If the file is a url, download it and then work with that
       ## file.
       if (! isempty (strfind (file, "://")))
-	## FIXME -- the above is not a perfect test for a url
-	urlfile = file;
-	## FIXME -- should we name the file that we download with the
-	## same file name as the url requests?
-	tmpfile = cstrcat (tmpnam (), ext);
-	[file, success, msg] = urlwrite (urlfile, tmpfile);
-	if (! success)
-	  error ("unpack: could not get \"%s\": %s", urlfile, msg);
-	endif
+        ## FIXME -- the above is not a perfect test for a url
+        urlfile = file;
+        ## FIXME -- should we name the file that we download with the
+        ## same file name as the url requests?
+        tmpfile = cstrcat (tmpnam (), ext);
+        [file, success, msg] = urlwrite (urlfile, tmpfile);
+        if (! success)
+          error ("unpack: could not get \"%s\": %s", urlfile, msg);
+        endif
       endif
 
     endif
 
     ## canonicalize_file_name returns empty if the file isn't found, so
     ## use that to check for existence
     cfile = canonicalize_file_name (file);
 
@@ -115,39 +115,39 @@ function filelist = unpack (file, direct
   ## The third cell is the function to execute on output to get the
   ##   files list.
   ## The fourth cell indicates if the files may need to be manually moved
   ##   (i.e. tar and unzip decompress into the current directory while
   ##   bzip2 and gzip decompress the file at its location).
   persistent commandlist;
   if (isempty (commandlist))
     commandlist.gz = {"gzip -d -v -r \"%s\"", ...
-		      "gzip -d -r \"%s\"", ...
-		      @__parse_gzip__, true};
+                      "gzip -d -r \"%s\"", ...
+                      @__parse_gzip__, true};
     commandlist.z = commandlist.gz;
     commandlist.bz2 = {"bzip2 -d -v \"%s\"", ...
-		       "bzip2 -d \"%s\"", ...
-		       @__parse_bzip2__, true};
+                       "bzip2 -d \"%s\"", ...
+                       @__parse_bzip2__, true};
     commandlist.bz = commandlist.bz2;
     commandlist.tar = {"tar xvf \"%s\"", ...
-		       "tar xf \"%s\"", ...
-		       @__parse_tar__, false};
+                       "tar xf \"%s\"", ...
+                       @__parse_tar__, false};
     commandlist.targz = {"gzip -d -c \"%s\" | tar xvf -", ...
-			 "gzip -d -c \"%s\" | tar xf -", ...
-			 @__parse_tar__, false};
+                         "gzip -d -c \"%s\" | tar xf -", ...
+                         @__parse_tar__, false};
     commandlist.tgz = commandlist.targz;
     commandlist.tarbz2 = {"bzip2 -d -c \"%s\" | tar xvf -", ...
-			  "bzip2 -d -c \"%s\" | tar xf -", ...
-			  @__parse_tar__, false};
+                          "bzip2 -d -c \"%s\" | tar xf -", ...
+                          @__parse_tar__, false};
     commandlist.tarbz = commandlist.tarbz2;
     commandlist.tbz2 = commandlist.tarbz2;
     commandlist.tbz = commandlist.tarbz2;
     commandlist.zip = {"unzip \"%s\"", ...
-		       "unzip -q \"%s\"", ...
-		       @__parse_zip__, false};
+                       "unzip -q \"%s\"", ...
+                       @__parse_zip__, false};
   endif
 
   nodotext = ext(! ismember (ext, "."));
   
   origdir = pwd ();
 
   if (isfield (commandlist, nodotext))
     [commandv, commandq, parser, move] = deal (commandlist.(nodotext){:});
@@ -180,38 +180,38 @@ function filelist = unpack (file, direct
     cd (directory);
     [status, output] = system (sprintf (cstrcat (command, " 2>&1"), file));
   unwind_protect_cleanup
     cd (origdir);
   end_unwind_protect
 
   if (status)
     error ("unpack: unarchiving program exited with status: %d\n%s",
-	   status, output);
+           status, output);
   endif
 
   if (nargout > 0 || needmove)
     ## Trim the last cr if needed.
     ## FIXME -- will this need to change to a check for "\r\n" for windows?
     if (output(length (output)) == "\n")
       output(length (output)) = [];
     endif
     files = parser (strsplit (output, "\n"))';
 
     ## Move files if necessary
     if (needmove)
       [st, msg, msgid] = movefile (files, directory);
       if (! st)
-	error ("unpack: unable to move files to \"%s\": %s",
-	       directory, msg);
+        error ("unpack: unable to move files to \"%s\": %s",
+               directory, msg);
       endif
 
       ## Fix the names for the files since they were moved.
       for i = 1:numel (files)
-	files{i} = strrep (files{i}, cstartdir, cenddir);
+        files{i} = strrep (files{i}, cstartdir, cenddir);
       endfor
     endif
 
     ## Return output if requested.
     if (nargout > 0)
       filelist = files;
     endif
   endif
@@ -236,26 +236,26 @@ function files = __parse_gzip__ (output)
 
   files = {};
   ## The middle ": " should indicate a good place to start looking for
   ## the filename.
   for i = 1:length (output)
     colons = strfind (output{i}, ":");
     if (isempty (colons))
       warning ("unpack:parsing",
-	       "Unable to parse line (gzip missing colon):\n%s", output{i});
+               "Unable to parse line (gzip missing colon):\n%s", output{i});
     else
       midcolon = colons(ceil (length (colons)/2));
       thisstr = output{i}(midcolon+2:length(output{i}));
       idx = index (thisstr, "with") + 5;
       if (isempty (idx))
-	warning ("unpack:parsing",
-		 "Unable to parse line (gzip missing with):\n%s", output{i});
+        warning ("unpack:parsing",
+                 "Unable to parse line (gzip missing with):\n%s", output{i});
       else
-	files{i} = thisstr(idx:length (thisstr));
+        files{i} = thisstr(idx:length (thisstr));
       endif
     endif
   endfor
 endfunction
 
 function files = __parse_bzip2__ (output)
   ## Parse the output from bzip2 and bunzip2 returning the files
   ## commpressed (or decompressed).
diff --git a/scripts/miscellaneous/what.m b/scripts/miscellaneous/what.m
--- a/scripts/miscellaneous/what.m
+++ b/scripts/miscellaneous/what.m
@@ -58,25 +58,25 @@ function ret = what (d)
     n = files(i).name;
     ## Ignore . and ..
     if (strcmp (n, ".") || strcmp (n, ".."))
       continue;
     else
       ## Ignore mdl and p files
       [dummy, f, e] = fileparts (n);
       if (strcmp (e, ".m"))
-	w.m{end+1} = n; 
+        w.m{end+1} = n; 
       elseif (strcmp (e, mexext ()))
-	w.mex{end+1} = n; 
+        w.mex{end+1} = n; 
       elseif (strcmp (e, ".oct"))
-	w.oct{end+1} = n;
+        w.oct{end+1} = n;
       elseif (strcmp (e, ".mat"))
-	w.mat{end+1} = n; 
+        w.mat{end+1} = n; 
       elseif(strcmp (n(1), "@"))
-	w.classes{end+1} = n;
+        w.classes{end+1} = n;
       endif
     endif
   endfor
 
   if (nargout == 0)
     __display_filenames__ ("M-files in directory", w.path, w.m);
     __display_filenames__ ("\nMEX-files in directory", w.path, w.mex);
     __display_filenames__ ("\nOCT-files in directory", w.path, w.oct);
diff --git a/scripts/miscellaneous/zip.m b/scripts/miscellaneous/zip.m
--- a/scripts/miscellaneous/zip.m
+++ b/scripts/miscellaneous/zip.m
@@ -39,35 +39,35 @@ function entries = zip (zipfile, files, 
 
     if (ischar (files))
       files = cellstr (files);
     endif
 
     if (ischar (zipfile) && iscellstr (files))
 
       cmd = sprintf ("cd %s; zip -r %s/%s %s", rootdir, pwd (), zipfile,
-		     sprintf (" %s", files{:}));
+                     sprintf (" %s", files{:}));
 
       [status, output] = system (cmd);
 
       if (status == 0)
-	if (nargout > 0)
-	  cmd = sprintf ("unzip -Z -1 %s", zipfile);
-	  [status, entries] = system (cmd);
-	  if (status == 0)
-	    if (entries(end) == "\n")
-	      entries(end) = [];
-	    endif
+        if (nargout > 0)
+          cmd = sprintf ("unzip -Z -1 %s", zipfile);
+          [status, entries] = system (cmd);
+          if (status == 0)
+            if (entries(end) == "\n")
+              entries(end) = [];
+            endif
             entries = strsplit (entries, "\n");
-	  else
-	    error ("zip: zipinfo failed with exit status = %d", status);
-	  endif
-	endif
+          else
+            error ("zip: zipinfo failed with exit status = %d", status);
+          endif
+        endif
       else
-	error ("zip: zip failed with exit status = %d", status);
+        error ("zip: zip failed with exit status = %d", status);
       endif
     
     else
       error ("zip: expecting all arguments to be character strings");
     endif
 
   else
     print_usage ();
diff --git a/scripts/optimization/fminunc.m b/scripts/optimization/fminunc.m
--- a/scripts/optimization/fminunc.m
+++ b/scripts/optimization/fminunc.m
@@ -385,17 +385,17 @@ function x = __doglegm__ (r, g, d, delta
     sn = norm (s);
     if (sn > 0)
       ## Normalize and rescale.
       s = (s / sn) ./ d;
       ## Get the line minimizer in s direction.
       tn = norm (r*s);
       snm = (sn / tn) / tn;
       if (snm < delta)
-	## Get the dogleg path minimizer.
+        ## Get the dogleg path minimizer.
         bn = norm (b);
         dxn = delta/xn; snmd = snm/delta;
         t = (bn/sn) * (bn/xn) * snmd;
         t -= dxn * snmd^2 - sqrt ((t-dxn)^2 + (1-dxn^2)*(1-snmd^2));
         alpha = dxn*(1-snmd^2) / t;
       else
         alpha = 0;
       endif
diff --git a/scripts/optimization/fsolve.m b/scripts/optimization/fsolve.m
--- a/scripts/optimization/fsolve.m
+++ b/scripts/optimization/fsolve.m
@@ -379,25 +379,25 @@ function [x, fvec, info, output, fjac] =
       ## iterations, so we need scaling-independent tolerances wherever
       ## possible.
 
       ## FIXME -- why tolf*n*xn? If abs (e) ~ abs(x) * eps is a vector
       ## of perturbations of x, then norm (fjac*e) <= eps*n*xn, i.e. by
       ## tolf ~ eps we demand as much accuracy as we can expect.
       if (fn <= tolf*n*xn)
         info = 1;
-	## The following tests done only after successful step.
+        ## The following tests done only after successful step.
       elseif (ratio >= 1e-4)
         ## This one is classic. Note that we use scaled variables again,
-	## but compare to scaled step, so nothing bad.
+        ## but compare to scaled step, so nothing bad.
         if (sn <= tolx*xn)
           info = 2;
           ## Again a classic one. It seems weird to use the same tolf
-	  ## for two different tests, but that's what M*b manual appears
-	  ## to say.
+          ## for two different tests, but that's what M*b manual appears
+          ## to say.
         elseif (actred < tolf)
           info = 3;
         endif
       endif
 
       ## Criterion for recalculating jacobian.
       if (! updating || nfail == 2 || nsuciter < 2)
         break;
@@ -576,17 +576,17 @@ function x = __dogleg__ (r, b, d, delta)
     sn = norm (s);
     if (sn > 0)
       ## Normalize and rescale.
       s = (s / sn) ./ d;
       ## Get the line minimizer in s direction.
       tn = norm (r*s);
       snm = (sn / tn) / tn;
       if (snm < delta)
-	## Get the dogleg path minimizer.
+        ## Get the dogleg path minimizer.
         bn = norm (b);
         dxn = delta/xn; snmd = snm/delta;
         t = (bn/sn) * (bn/xn) * snmd;
         t -= dxn * snmd^2 - sqrt ((t-dxn)^2 + (1-dxn^2)*(1-snmd^2));
         alpha = dxn*(1-snmd^2) / t;
       else
         alpha = 0;
       endif
diff --git a/scripts/optimization/glpk.m b/scripts/optimization/glpk.m
--- a/scripts/optimization/glpk.m
+++ b/scripts/optimization/glpk.m
@@ -160,44 +160,44 @@
 ## @item 0
 ## No scaling.
 ## @item 1
 ## Equilibration scaling.
 ## @item 2
 ## Geometric mean scaling, then equilibration scaling.
 ## @end table
 ## 
-## @item dual	 (@w{@code{LPX_K_DUAL}}, default: 0)
+## @item dual    (@w{@code{LPX_K_DUAL}}, default: 0)
 ## Dual simplex option:
 ## @table @asis
 ## @item 0
 ## Do not use the dual simplex.
 ## @item 1
 ## If initial basic solution is dual feasible, use the dual simplex.
 ## @end table
 ## 
-## @item price	 (@w{@code{LPX_K_PRICE}}, default: 1)
+## @item price   (@w{@code{LPX_K_PRICE}}, default: 1)
 ## Pricing option (for both primal and dual simplex):
 ## @table @asis
 ## @item 0
 ## Textbook pricing.
 ## @item 1
 ## Steepest edge pricing.
 ## @end table
 ##   
-## @item round	 (@w{@code{LPX_K_ROUND}}, default: 0)
+## @item round   (@w{@code{LPX_K_ROUND}}, default: 0)
 ## Solution rounding option:
 ## @table @asis
 ## @item 0
 ## Report all primal and dual values "as is".
 ## @item 1
 ## Replace tiny primal and dual values by exact zero.
 ## @end table
 ## 
-## @item itlim	 (@w{@code{LPX_K_ITLIM}}, default: -1)
+## @item itlim   (@w{@code{LPX_K_ITLIM}}, default: -1)
 ## Simplex iterations limit.  If this value is positive, it is decreased by
 ## one each time when one simplex iteration has been performed, and
 ## reaching zero value signals the solver to stop the search.  Negative
 ## value means no iterations limit.
 ## 
 ## @item itcnt (@w{@code{LPX_K_OUTFRQ}}, default: 200)
 ## Output frequency, in iterations.  This parameter specifies how
 ## frequently the solver sends information about the solution to the
@@ -488,31 +488,31 @@ function [xopt, fmin, status, extra] = g
 
   if (nargin > 5)
     if (isempty (ctype))
       ctype = repmat ("S", nc, 1);
     elseif (! ischar (ctype) || all (size (ctype) > 1) || length (ctype) != nc)
       error ("CTYPE must be a char valued vector of length %d", nc);
       return;
     elseif (! all (ctype == "F" | ctype == "U" | ctype == "S"
-		   | ctype == "L" | ctype == "D"))
+                   | ctype == "L" | ctype == "D"))
       error ("CTYPE must contain only F, U, S, L, or D");
       return;
     endif
   else
     ctype = repmat ("S", nc, 1);
   endif
 
   ## 7) Vector with the type of variables
 
   if (nargin > 6)
     if (isempty (vartype))
       vartype = repmat ("C", nx, 1);
     elseif (! ischar (vartype) || all (size (vartype) > 1)
-	    || length (vartype) != nx)
+            || length (vartype) != nx)
       error ("VARTYPE must be a char valued vector of length %d", nx);
       return;
     elseif (! all (vartype == "C" | vartype == "I"))
       error ("VARTYPE must contain only C or I");
       return;
     endif
   else
     ## As default we consider continuous vars
diff --git a/scripts/optimization/qp.m b/scripts/optimization/qp.m
--- a/scripts/optimization/qp.m
+++ b/scripts/optimization/qp.m
@@ -179,107 +179,107 @@ function [x, obj, INFO, lambda] = qp (x0
     ## Equality constraint matrices
     if (isempty (A) || isempty (b))
       A = zeros (0, n);
       b = zeros (0, 1);
       n_eq = 0;
     else
       [n_eq, n1] = size (A);
       if (n1 != n)
-	error ("qp: equality constraint matrix has incorrect column dimension");
+        error ("qp: equality constraint matrix has incorrect column dimension");
       endif
       if (numel (b) != n_eq)
-	error ("qp: equality constraint matrix and vector have inconsistent dimension");
+        error ("qp: equality constraint matrix and vector have inconsistent dimension");
       endif
     endif
 
     ## Bound constraints
     Ain = zeros (0, n);
     bin = zeros (0, 1);
     n_in = 0;
     if (nargs > 5)
       if (! isempty (lb))
-	if (numel (lb) != n)
-	  error ("qp: lower bound has incorrect length");
-	elseif (isempty (ub))
-	  Ain = [Ain; eye(n)];
-	  bin = [bin; lb];
-	endif
+        if (numel (lb) != n)
+          error ("qp: lower bound has incorrect length");
+        elseif (isempty (ub))
+          Ain = [Ain; eye(n)];
+          bin = [bin; lb];
+        endif
       endif
 
       if (! isempty (ub))
-	if (numel (ub) != n)
-	  error ("qp: upper bound has incorrect length");
-	elseif (isempty (lb))
-	  Ain = [Ain; -eye(n)];
-	  bin = [bin; -ub];
-	endif
+        if (numel (ub) != n)
+          error ("qp: upper bound has incorrect length");
+        elseif (isempty (lb))
+          Ain = [Ain; -eye(n)];
+          bin = [bin; -ub];
+        endif
       endif
       
       if (! isempty (lb) && ! isempty (ub))
-	rtol = sqrt (eps);
-	for i = 1:n
-	  if (abs(lb (i) - ub(i)) < rtol*(1 + max (abs (lb(i) + ub(i)))))
+        rtol = sqrt (eps);
+        for i = 1:n
+          if (abs(lb (i) - ub(i)) < rtol*(1 + max (abs (lb(i) + ub(i)))))
             ## These are actually an equality constraint
-	    tmprow = zeros(1,n);
-	    tmprow(i) = 1;
+            tmprow = zeros(1,n);
+            tmprow(i) = 1;
             A = [A;tmprow];
             b = [b; 0.5*(lb(i) + ub(i))];
-	    n_eq = n_eq + 1;
-	  else
-	    tmprow = zeros(1,n);
-	    tmprow(i) = 1;
-	    Ain = [Ain; tmprow; -tmprow];
-	    bin = [bin; lb(i); -ub(i)];
-	    n_in = n_in + 2;
-	  endif
-	endfor
+            n_eq = n_eq + 1;
+          else
+            tmprow = zeros(1,n);
+            tmprow(i) = 1;
+            Ain = [Ain; tmprow; -tmprow];
+            bin = [bin; lb(i); -ub(i)];
+            n_in = n_in + 2;
+          endif
+        endfor
       endif
     endif
 
     ## Inequality constraints
     if (nargs > 7)
       [dimA_in, n1] = size (A_in);
       if (n1 != n)
-	error ("qp: inequality constraint matrix has incorrect column dimension");
+        error ("qp: inequality constraint matrix has incorrect column dimension");
       else
-	if (! isempty (A_lb))
-	  if (numel (A_lb) != dimA_in)
-	    error ("qp: inequality constraint matrix and lower bound vector inconsistent");
-	  elseif (isempty (A_ub))
-	    Ain = [Ain; A_in];
-	    bin = [bin; A_lb];
-	  endif
-	endif
-	if (! isempty (A_ub))
-	  if (numel (A_ub) != dimA_in)
-	    error ("qp: inequality constraint matrix and upper bound vector inconsistent");
-	  elseif (isempty (A_lb))
-	    Ain = [Ain; -A_in];
-	    bin = [bin; -A_ub];
-	  endif
-	endif
-	
-	if (! isempty (A_lb) && ! isempty (A_ub))
-	  rtol = sqrt (eps);
-	  for i = 1:dimA_in
-	    if (abs (A_lb(i) - A_ub(i)) < rtol*(1 + max (abs (A_lb(i) + A_ub(i)))))
+        if (! isempty (A_lb))
+          if (numel (A_lb) != dimA_in)
+            error ("qp: inequality constraint matrix and lower bound vector inconsistent");
+          elseif (isempty (A_ub))
+            Ain = [Ain; A_in];
+            bin = [bin; A_lb];
+          endif
+        endif
+        if (! isempty (A_ub))
+          if (numel (A_ub) != dimA_in)
+            error ("qp: inequality constraint matrix and upper bound vector inconsistent");
+          elseif (isempty (A_lb))
+            Ain = [Ain; -A_in];
+            bin = [bin; -A_ub];
+          endif
+        endif
+        
+        if (! isempty (A_lb) && ! isempty (A_ub))
+          rtol = sqrt (eps);
+          for i = 1:dimA_in
+            if (abs (A_lb(i) - A_ub(i)) < rtol*(1 + max (abs (A_lb(i) + A_ub(i)))))
               ## These are actually an equality constraint
-	      tmprow = A_in(i,:);
+              tmprow = A_in(i,:);
               A = [A;tmprow];
               b = [b; 0.5*(A_lb(i) + A_ub(i))];
-	      n_eq = n_eq + 1;
-	    else
-	      tmprow = A_in(i,:);
-	      Ain = [Ain; tmprow; -tmprow];
-	      bin = [bin; A_lb(i); -A_ub(i)];
-	      n_in = n_in + 2;
-	    endif
-	  endfor
-	endif
+              n_eq = n_eq + 1;
+            else
+              tmprow = A_in(i,:);
+              Ain = [Ain; tmprow; -tmprow];
+              bin = [bin; A_lb(i); -A_ub(i)];
+              n_in = n_in + 2;
+            endif
+          endfor
+        endif
       endif
     endif
 
     ## Now we should have the following QP:
     ##
     ##   min_x  0.5*x'*H*x + x'*q
     ##   s.t.   A*x = b
     ##          Ain*x >= bin
@@ -290,94 +290,94 @@ function [x, obj, INFO, lambda] = qp (x0
 
     bin(idx) = [];
     Ain(idx,:) = [];
 
     n_in = numel (bin);
 
     ## Check if the initial guess is feasible.
     if (isa (x0, "single") || isa (H, "single") || isa (q, "single") || isa (A, "single")
-	|| isa (b, "single"))
+        || isa (b, "single"))
       rtol = sqrt (eps ("single"));
     else
       rtol = sqrt (eps);
     endif
 
     eq_infeasible = (n_eq > 0 && norm (A*x0-b) > rtol*(1+abs (b)));
     in_infeasible = (n_in > 0 && any (Ain*x0-bin < -rtol*(1+abs (bin))));
 
     info = 0;
     if (eq_infeasible || in_infeasible)
       ## The initial guess is not feasible.
       ## First define xbar that is feasible with respect to the equality
       ## constraints.
       if (eq_infeasible)
-	if (rank (A) < n_eq)
-	  error ("qp: equality constraint matrix must be full row rank")
-	endif
-	xbar = pinv (A) * b;
+        if (rank (A) < n_eq)
+          error ("qp: equality constraint matrix must be full row rank")
+        endif
+        xbar = pinv (A) * b;
       else
-	xbar = x0;
+        xbar = x0;
       endif
 
       ## Check if xbar is feasible with respect to the inequality
       ## constraints also.
       if (n_in > 0)
-	res = Ain * xbar - bin;
-	if (any (res < -rtol * (1 + abs (bin))))
-	  ## xbar is not feasible with respect to the inequality
-	  ## constraints.  Compute a step in the null space of the
-	  ## equality constraints, by solving a QP.  If the slack is
-	  ## small, we have a feasible initial guess.  Otherwise, the
-	  ## problem is infeasible.
-	  if (n_eq > 0)
-	    Z = null (A);
-	    if (isempty (Z))
-	      ## The problem is infeasible because A is square and full
-	      ## rank, but xbar is not feasible.
-	      info = 6;
-	    endif
-	  endif
+        res = Ain * xbar - bin;
+        if (any (res < -rtol * (1 + abs (bin))))
+          ## xbar is not feasible with respect to the inequality
+          ## constraints.  Compute a step in the null space of the
+          ## equality constraints, by solving a QP.  If the slack is
+          ## small, we have a feasible initial guess.  Otherwise, the
+          ## problem is infeasible.
+          if (n_eq > 0)
+            Z = null (A);
+            if (isempty (Z))
+              ## The problem is infeasible because A is square and full
+              ## rank, but xbar is not feasible.
+              info = 6;
+            endif
+          endif
 
-	  if (info != 6)
+          if (info != 6)
             ## Solve an LP with additional slack variables to find
-	    ## a feasible starting point.
-	    gamma = eye (n_in);
-	    if (n_eq > 0)
-	      Atmp = [Ain*Z, gamma];
-	      btmp = -res;
-	    else
-	      Atmp = [Ain, gamma];
-	      btmp = bin;
-	    endif
-	    ctmp = [zeros(n-n_eq, 1); ones(n_in, 1)];
-	    lb = [-Inf(n-n_eq,1); zeros(n_in,1)];
-	    ub = [];
-	    ctype = repmat ("L", n_in, 1);
-	    [P, dummy, status] = glpk (ctmp, Atmp, btmp, lb, ub, ctype);
-	    if ((status == 180 || status == 181 || status == 151)
-		&& all (abs (P(n-n_eq+1:end)) < rtol * (1 + norm (btmp))))
-	      ## We found a feasible starting point
-	      if (n_eq > 0)
-		x0 = xbar + Z*P(1:n-n_eq);
-	      else
-		x0 = P(1:n);
+            ## a feasible starting point.
+            gamma = eye (n_in);
+            if (n_eq > 0)
+              Atmp = [Ain*Z, gamma];
+              btmp = -res;
+            else
+              Atmp = [Ain, gamma];
+              btmp = bin;
+            endif
+            ctmp = [zeros(n-n_eq, 1); ones(n_in, 1)];
+            lb = [-Inf(n-n_eq,1); zeros(n_in,1)];
+            ub = [];
+            ctype = repmat ("L", n_in, 1);
+            [P, dummy, status] = glpk (ctmp, Atmp, btmp, lb, ub, ctype);
+            if ((status == 180 || status == 181 || status == 151)
+                && all (abs (P(n-n_eq+1:end)) < rtol * (1 + norm (btmp))))
+              ## We found a feasible starting point
+              if (n_eq > 0)
+                x0 = xbar + Z*P(1:n-n_eq);
+              else
+                x0 = P(1:n);
               endif
-	    else
-	      ## The problem is infeasible
-	      info = 6;
-	    endif
-	  endif
-	else
-	  ## xbar is feasible.  We use it a starting point.
-	  x0 = xbar;
-	endif
+            else
+              ## The problem is infeasible
+              info = 6;
+            endif
+          endif
+        else
+          ## xbar is feasible.  We use it a starting point.
+          x0 = xbar;
+        endif
       else
-	## xbar is feasible.  We use it a starting point.
-	x0 = xbar;
+        ## xbar is feasible.  We use it a starting point.
+        x0 = xbar;
       endif
     endif
 
     if (info == 0)
       ## The initial (or computed) guess is feasible.
       ## We call the solver.
       [x, lambda, info, iter] = __qp__ (x0, H, q, A, b, Ain, bin, maxit);
     else
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -219,131 +219,131 @@ function [x, obj, info, iter, nf, lambda
     ## ce_fun  -- equality constraint functions
     ## ci_fun  -- inequality constraint functions
     ## A == [grad_{x_1} cx_fun, grad_{x_2} cx_fun, ..., grad_{x_n} cx_fun]^T
 
     obj_grd = @fd_obj_grd;
     have_hess = 0;
     if (iscell (objf))
       if (length (objf) > 0)
-	__sqp_obj_fun__ = obj_fun = objf{1};
-	if (length (objf) > 1)
-	  obj_grd = objf{2};
-	  if (length (objf) > 2)
-	    obj_hess = objf{3};
-	    have_hess = 1;
-	  endif
-	endif
+        __sqp_obj_fun__ = obj_fun = objf{1};
+        if (length (objf) > 1)
+          obj_grd = objf{2};
+          if (length (objf) > 2)
+            obj_hess = objf{3};
+            have_hess = 1;
+          endif
+        endif
       else
-	error ("sqp: invalid objective function");
+        error ("sqp: invalid objective function");
       endif
     else
       __sqp_obj_fun__ = obj_fun = objf;
     endif
 
     ce_fun = @empty_cf;
     ce_grd = @empty_jac;
     if (nargin > 2)
       ce_grd = @fd_ce_jac;
       if (iscell (cef))
-	if (length (cef) > 0)
-	  __sqp_ce_fun__ = ce_fun = cef{1};
-	  if (length (cef) > 1)
-	    ce_grd = cef{2};
-	  endif
-	else
-	  error ("sqp: invalid equality constraint function");
-	endif
+        if (length (cef) > 0)
+          __sqp_ce_fun__ = ce_fun = cef{1};
+          if (length (cef) > 1)
+            ce_grd = cef{2};
+          endif
+        else
+          error ("sqp: invalid equality constraint function");
+        endif
       elseif (! isempty (cef))
-	ce_fun = cef;
+        ce_fun = cef;
       endif
     endif
     __sqp_ce_fun__ = ce_fun;
 
     ci_fun = @empty_cf;
     ci_grd = @empty_jac;
-	
+        
     if (nargin > 3)
       ## constraint function given by user with possibly gradient
       __sqp_cif__ = cif;
       ## constraint function given by user without gradient
       __sqp_cifcn__ = @empty_cf;
       if (iscell (__sqp_cif__))
-	if (length (__sqp_cif__) > 0)
-	  __sqp_cifcn__ = __sqp_cif__{1};
-	endif
+        if (length (__sqp_cif__) > 0)
+          __sqp_cifcn__ = __sqp_cif__{1};
+        endif
       elseif (! isempty (__sqp_cif__))
-	__sqp_cifcn__ = __sqp_cif__;
+        __sqp_cifcn__ = __sqp_cif__;
       endif
 
       if (nargin < 5)
-      	ci_grd = @fd_ci_jac;
-      	if (iscell (cif))
-	  if (length (cif) > 0)
-	    __sqp_ci_fun__ = ci_fun = cif{1};
-	    if (length (cif) > 1)
-	      ci_grd = cif{2};
-	    endif
-	  else
-	    error ("sqp: invalid equality constraint function");
-	  endif
-      	elseif (! isempty (cif))
-	  ci_fun = cif;
-      	endif
+        ci_grd = @fd_ci_jac;
+        if (iscell (cif))
+          if (length (cif) > 0)
+            __sqp_ci_fun__ = ci_fun = cif{1};
+            if (length (cif) > 1)
+              ci_grd = cif{2};
+            endif
+          else
+            error ("sqp: invalid equality constraint function");
+          endif
+        elseif (! isempty (cif))
+          ci_fun = cif;
+        endif
       else
-	global __sqp_lb__;
-	if (isvector (lb))
-	  __sqp_lb__ = lb;
-	elseif (isempty (lb))
-	  if (isa (x, "single"))
-	    __sqp_lb__ = -realmax ("single");
-	  else
-	    __sqp_lb__ = -realmax;
-	  endif
-	else
-	  error ("sqp: invalid lower bound");
-	endif
+        global __sqp_lb__;
+        if (isvector (lb))
+          __sqp_lb__ = lb;
+        elseif (isempty (lb))
+          if (isa (x, "single"))
+            __sqp_lb__ = -realmax ("single");
+          else
+            __sqp_lb__ = -realmax;
+          endif
+        else
+          error ("sqp: invalid lower bound");
+        endif
 
-	global __sqp_ub__;
-	if (isvector (ub))
-	  __sqp_ub__ = ub;
-	elseif (isempty (lb))
-	  if (isa (x, "single"))
-	    __sqp_ub__ = realmax ("single");
-	  else
-	    __sqp_ub__ = realmax;
-	  endif
-	else
-	  error ("sqp: invalid upper bound");
-	endif
+        global __sqp_ub__;
+        if (isvector (ub))
+          __sqp_ub__ = ub;
+        elseif (isempty (lb))
+          if (isa (x, "single"))
+            __sqp_ub__ = realmax ("single");
+          else
+            __sqp_ub__ = realmax;
+          endif
+        else
+          error ("sqp: invalid upper bound");
+        endif
 
-	if (lb > ub)
-	  error ("sqp: upper bound smaller than lower bound");
-	endif
-       	__sqp_ci_fun__ = ci_fun = @cf_ub_lb;
-       	ci_grd = @cigrad_ub_lb;
+        if (lb > ub)
+          error ("sqp: upper bound smaller than lower bound");
+        endif
+        __sqp_ci_fun__ = ci_fun = @cf_ub_lb;
+        ci_grd = @cigrad_ub_lb;
       endif
       __sqp_ci_fun__ = ci_fun;
     endif
 
     iter_max = 100;
     if (nargin > 6 && ! isempty (maxiter))
       if (isscalar (maxiter) && maxiter > 0 && round (maxiter) == maxiter)
-	iter_max = maxiter;
+        iter_max = maxiter;
       else
-	error ("sqp: invalid number of maximum iterations");
+        error ("sqp: invalid number of maximum iterations");
       endif
     endif
 
     tol = sqrt (eps);
     if (nargin > 7 && ! isempty (tolerance))
       if (isscalar (tolerance) && tolerance > 0)
-	tol = tolerance;
+        tol = tolerance;
       else
-	error ("sqp: invalid value for tolerance");
+        error ("sqp: invalid value for tolerance");
       endif
     endif
 
     iter = 0;
 
     obj = feval (obj_fun, x);
     __sqp_nfun__ = 1;
 
@@ -393,42 +393,42 @@ function [x, obj, info, iter, nf, lambda
       t0 = norm (c - A' * lambda);
       t1 = norm (ce);
       t2 = all (ci >= 0);
       t3 = all (lambda_i >= 0);
       t4 = norm (lambda .* con);
 
       if (t2 && t3 && max ([t0; t1; t4]) < tol)
         info = 101;
-	break;
+        break;
       endif
 
       ## Compute search direction p by solving QP.
 
       g = -ce;
       d = -ci;
 
       ## Discard inequality constraints that have -Inf bounds since those
       ## will never be active.
       idx = isinf (d) & d < 0;
       d(idx) = [];
       C(idx,:) = [];
 
       [p, obj_qp, INFO, lambda] = qp (x, B, c, F, g, [], [], d, C,
-				      Inf (size (d)));
+                                      Inf (size (d)));
 
       info = INFO.info;
 
       ## Check QP solution and attempt to recover if it has failed.
 
       ## Choose mu such that p is a descent direction for the chosen
       ## merit function phi.
 
       [x_new, alpha, obj_new] = linesearch_L1 (x, p, obj_fun, obj_grd,
-					       ce_fun, ci_fun, lambda, obj);
+                                               ce_fun, ci_fun, lambda, obj);
 
       ## Evaluate objective function, constraints, and gradients at
       ## x_new.
 
       c_new = feval (obj_grd, x_new);
 
       ce_new = feval (ce_fun, x_new);
       F_new = feval (ce_grd, x_new);
@@ -441,61 +441,61 @@ function [x, obj, info, iter, nf, lambda
       ## Set
       ##
       ## s = alpha * p
       ## y = grad_x L (x_new, lambda) - grad_x L (x, lambda})
 
       y = c_new - c;
 
       if (! isempty (A))
-	t = ((A_new - A)'*lambda);
-	y -= t;
+        t = ((A_new - A)'*lambda);
+        y -= t;
       endif
 
       delx = x_new - x;
 
       if (norm (delx) < tol * norm (x))
-	info = 101;
-	break;
+        info = 101;
+        break;
       endif
 
       if (have_hess)
 
-	B = feval (obj_hess, x);
+        B = feval (obj_hess, x);
 
       else
 
-	## Update B using a quasi-Newton formula.
+        ## Update B using a quasi-Newton formula.
 
-	delxt = delx';
+        delxt = delx';
 
-	## Damped BFGS.  Or maybe we would actually want to use the Hessian
-	## of the Lagrangian, computed directly.
+        ## Damped BFGS.  Or maybe we would actually want to use the Hessian
+        ## of the Lagrangian, computed directly.
 
-	d1 = delxt*B*delx;
+        d1 = delxt*B*delx;
 
-	t1 = 0.2 * d1;
-	t2 = delxt*y;
+        t1 = 0.2 * d1;
+        t2 = delxt*y;
 
-	if (t2 < t1)
-	  theta = 0.8*d1/(d1 - t2);
-	else
-	  theta = 1;
-	endif
+        if (t2 < t1)
+          theta = 0.8*d1/(d1 - t2);
+        else
+          theta = 1;
+        endif
 
-	r = theta*y + (1-theta)*B*delx;
+        r = theta*y + (1-theta)*B*delx;
 
-	d2 = delxt*r;
+        d2 = delxt*r;
 
-	if (d1 == 0 || d2 == 0)
-	  info = 102;
-	  break;
-	endif
+        if (d1 == 0 || d2 == 0)
+          info = 102;
+          break;
+        endif
 
-	B = B - B*delx*delxt*B/d1 + r*r'/d2;
+        B = B - B*delx*delxt*B/d1 + r*r'/d2;
 
       endif
 
       x = x_new;
 
       obj = obj_new;
 
       c = c_new;
@@ -549,17 +549,17 @@ function [merit, obj] = phi_L1 (obj, obj
   if (! isempty (t))
     merit += t;
   endif
 
 endfunction
 
 
 function [x_new, alpha, obj] = linesearch_L1 (x, p, obj_fun, obj_grd,
-					      ce_fun, ci_fun, lambda, obj)
+                                              ce_fun, ci_fun, lambda, obj)
 
   ## Choose parameters
   ##
   ## eta in the range (0, 0.5)
   ## tau in the range (0, 1)
 
   eta = 0.25;
   tau = 0.5;
@@ -722,17 +722,17 @@ function res = cigrad_ub_lb (x)
 
   res = [eye(numel(x)); -eye(numel(x))];
 
   cigradfcn = @fd_ci_jac;
 
   if (iscell (__sqp_cif__) && length (__sqp_cif__) > 1)
     cigradfcn = __sqp_cif__{2};
   endif
-	
+        
   if (! isempty (cigradfcn))
     res = [feval(cigradfcn,x); eye(numel(x)); -eye(numel(x))];
   endif
 
 endfunction
 
 %!function r = g (x)
 %!  r = [sumsq(x)-10;
diff --git a/scripts/path/pathdef.m b/scripts/path/pathdef.m
--- a/scripts/path/pathdef.m
+++ b/scripts/path/pathdef.m
@@ -90,45 +90,45 @@ function specifiedpath = __extractpath__
     ## read in all lines of the file
     [fid, msg] = fopen (savefile, "rt");
     if (fid < 0)
       error ("__extractpath__: could not open savefile, %s: %s", savefile, msg);
     endif
     unwind_protect
       linenum = 0;
       while (linenum >= 0)
-	result = fgetl (fid);
-	if (isnumeric (result))
-	  ## End at the end of file.
-	  linenum = -1;
-	else
-	  linenum++;
-	  filelines{linenum} = result;
-	  ## Find the first and last lines if they exist in the file.
-	  if (strcmp (result, beginstring))
-	    startline = linenum + 1;
-	  elseif (strcmp (result, endstring))
-	    endline = linenum - 1;
-	  endif
-	endif
+        result = fgetl (fid);
+        if (isnumeric (result))
+          ## End at the end of file.
+          linenum = -1;
+        else
+          linenum++;
+          filelines{linenum} = result;
+          ## Find the first and last lines if they exist in the file.
+          if (strcmp (result, beginstring))
+            startline = linenum + 1;
+          elseif (strcmp (result, endstring))
+            endline = linenum - 1;
+          endif
+        endif
       endwhile
     unwind_protect_cleanup
       closeread = fclose (fid);
       if (closeread < 0)
-	error ("savepath: could not close savefile after reading, %s",
-	       savefile);
+        error ("savepath: could not close savefile after reading, %s",
+               savefile);
       endif
     end_unwind_protect
   endif
 
   ## Extract the path specifiation.
   if (startline > endline || (startline > 0 && endline == 0))
     error ("savepath: unable to parse file, %s", savefile);
   elseif (startline > 0)
     ## Undo doubling of single quote characters performed by savepath.
     specifiedpath = strrep (regexprep (cstrcat (filelines(startline:endline){:}),
-				       " *path *\\('(.*)'\\); *", "$1"),
-			    "''", "'");
+                                       " *path *\\('(.*)'\\); *", "$1"),
+                            "''", "'");
   else
     specifiedpath = "";
   endif
 
 endfunction  
diff --git a/scripts/path/savepath.m b/scripts/path/savepath.m
--- a/scripts/path/savepath.m
+++ b/scripts/path/savepath.m
@@ -47,36 +47,36 @@ function varargout = savepath (savefile)
     ## read in all lines of the file
     [fid, msg] = fopen (savefile, "rt");
     if (fid < 0)
       error ("savepath: could not open savefile, %s: %s", savefile, msg);
     endif
     unwind_protect
       linenum = 0;
       while (linenum >= 0)
-	result = fgetl (fid);
-	if (isnumeric (result))
-	  ## end at the end of file
-	  linenum = -1;
-	else
-	  linenum = linenum + 1;
-	  filelines{linenum} = result;
-	  ## find the first and last lines if they exist in the file
-	  if (strcmp (result, beginstring))
-	    startline = linenum;
-	  elseif (strcmp (result, endstring))
-	    endline = linenum;
-	  endif
-	endif
+        result = fgetl (fid);
+        if (isnumeric (result))
+          ## end at the end of file
+          linenum = -1;
+        else
+          linenum = linenum + 1;
+          filelines{linenum} = result;
+          ## find the first and last lines if they exist in the file
+          if (strcmp (result, beginstring))
+            startline = linenum;
+          elseif (strcmp (result, endstring))
+            endline = linenum;
+          endif
+        endif
       endwhile
     unwind_protect_cleanup
       closeread = fclose (fid);
       if (closeread < 0)
-	error ("savepath: could not close savefile after reading, %s",
-	       savefile);
+        error ("savepath: could not close savefile after reading, %s",
+               savefile);
       endif
     end_unwind_protect
   endif
 
   if (startline > endline || (startline > 0 && endline == 0))
     error ("savepath: unable to parse file, %s", savefile);
   endif
 
@@ -152,17 +152,17 @@ function varargout = savepath (savefile)
     if (! isempty (default_path))
       n1 = strmatch (default_path{1}, path_to_preserve, "exact");
       n2 = strmatch (default_path{end}, path_to_preserve, "exact");
       n_middle = round (0.5*(n1+n2));
       [tmp, n] = setdiff (path_to_preserve, default_path);
       path_to_save = path_to_preserve (sort (n));
       ## Remove pwd
       path_to_save = path_to_save (! strcmpi (path_to_save,
-					      strcat (".", pathsep)));
+                                              strcat (".", pathsep)));
       n = ones (size (path_to_save));
       for m = 1:numel(path_to_save)
         n(m) = strmatch (path_to_save{m}, path_to_preserve);
       endfor
       path_to_save_begin = path_to_save(n <= n_middle);
       path_to_save_end   = path_to_save(n > n_middle);
     else
       path_to_save_begin = path_to_preserve;
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -197,228 +197,228 @@
 
 function [local_packages, global_packages] = pkg (varargin)
   ## Installation prefix (FIXME: what should these be on windows?)
   persistent user_prefix = false;
   persistent prefix = -1;
   persistent archprefix = -1;
   persistent local_list = tilde_expand (fullfile ("~", ".octave_packages"));
   persistent global_list = fullfile (OCTAVE_HOME (), "share", "octave",
-				     "octave_packages");
+                                     "octave_packages");
   mlock ();
 
   global_install = issuperuser ();
 
   if (prefix == -1)
     if (global_install)
       prefix = fullfile (OCTAVE_HOME (), "share", "octave", "packages");
       archprefix = fullfile (octave_config_info ("libexecdir"),
-			     "octave", "packages");
+                             "octave", "packages");
     else
       prefix = fullfile ("~", "octave");
       archprefix = prefix;
     endif
     prefix = tilde_expand (prefix);
     archprefix = tilde_expand (archprefix);
   endif
 
   available_actions = {"list", "install", "uninstall", "load", ...
-		       "unload", "prefix", "local_list", ...
-		       "global_list", "rebuild", "build","describe"}; 
+                       "unload", "prefix", "local_list", ...
+                       "global_list", "rebuild", "build","describe"}; 
   ## Handle input
   if (length (varargin) == 0 || ! iscellstr (varargin))
     print_usage ();
   endif
   files = {};
   deps = true;
   auto = 0;
   action = "none";
   verbose = false;
   for i = 1:length (varargin)
     switch (varargin{i})
       case "-nodeps"
-	deps = false;
+        deps = false;
       case "-noauto"
-	auto = -1;
+        auto = -1;
       case "-auto"
-	auto = 1;
+        auto = 1;
       case "-verbose"
-	verbose = true;
+        verbose = true;
       case "-local"
-	global_install = false;
-	if (! user_prefix)
-	  prefix = tilde_expand (fullfile ("~", "octave"));
-	  archprefix = prefix;
-	endif
+        global_install = false;
+        if (! user_prefix)
+          prefix = tilde_expand (fullfile ("~", "octave"));
+          archprefix = prefix;
+        endif
       case "-global"
-	global_install = true;
-	if (! user_prefix)
-	  prefix = fullfile (OCTAVE_HOME (), "share", "octave", "packages");
-	  archprefix = fullfile (octave_config_info ("libexecdir"),
-				 "octave", "packages");
-	endif
+        global_install = true;
+        if (! user_prefix)
+          prefix = fullfile (OCTAVE_HOME (), "share", "octave", "packages");
+          archprefix = fullfile (octave_config_info ("libexecdir"),
+                                 "octave", "packages");
+        endif
       case available_actions
-	if (strcmp (action, "none"))
-	  action = varargin{i};
-	else
-	  error ("more than one action specified");
-	endif
+        if (strcmp (action, "none"))
+          action = varargin{i};
+        else
+          error ("more than one action specified");
+        endif
       otherwise
-	files{end+1} = varargin{i};
+        files{end+1} = varargin{i};
     endswitch
   endfor
 
   ## Take action
   switch (action)
     case "list"
       if (nargout == 0)
-	installed_packages (local_list, global_list);
+        installed_packages (local_list, global_list);
       elseif (nargout == 1)
-	local_packages = installed_packages (local_list, global_list);
+        local_packages = installed_packages (local_list, global_list);
       elseif (nargout == 2)
-	[local_packages, global_packages] = installed_packages (local_list,
-								global_list);
+        [local_packages, global_packages] = installed_packages (local_list,
+                                                                global_list);
       else
-	error ("too many output arguments requested");
+        error ("too many output arguments requested");
       endif
 
     case "install"
       if (length (files) == 0)
-	error ("you must specify at least one filename when calling 'pkg install'");
+        error ("you must specify at least one filename when calling 'pkg install'");
       endif
       install (files, deps, auto, prefix, archprefix, verbose, local_list, 
-	       global_list, global_install);
+               global_list, global_install);
 
     case "uninstall"
       if (length (files) == 0)
-	error ("you must specify at least one package when calling 'pkg uninstall'");
+        error ("you must specify at least one package when calling 'pkg uninstall'");
       endif
       uninstall (files, deps, verbose, local_list, 
-		 global_list, global_install);
+                 global_list, global_install);
 
     case "load"
       if (length (files) == 0)
-	error ("you must specify at least one package, 'all' or 'auto' when calling 'pkg load'");
+        error ("you must specify at least one package, 'all' or 'auto' when calling 'pkg load'");
       endif
       load_packages (files, deps, local_list, global_list);
 
     case "unload"
       if (length (files) == 0)
-	error ("you must specify at least one package or 'all' when calling 'pkg unload'");
+        error ("you must specify at least one package or 'all' when calling 'pkg unload'");
       endif
       unload_packages (files, deps, local_list, global_list);
 
     case "prefix"
       if (length (files) == 0 && nargout == 0)
-	printf ("Installation prefix:             %s\n", prefix);
-	printf ("Architecture dependent prefix:   %s\n", archprefix);
+        printf ("Installation prefix:             %s\n", prefix);
+        printf ("Architecture dependent prefix:   %s\n", archprefix);
       elseif (length (files) == 0 && nargout >= 1)
-	local_packages = prefix;
-	global_packages = archprefix;
+        local_packages = prefix;
+        global_packages = archprefix;
       elseif (length (files) >= 1 && nargout <= 2 && ischar (files{1}))
-	prefix = files{1};
-	prefix = absolute_pathname (prefix);
-	local_packages = prefix;
-	user_prefix = true;
-	if (length (files) >= 2 && ischar (files{2}))
-	  archprefix = files{2};
-	  try
-	    archprefix = absolute_pathname (archprefix);
+        prefix = files{1};
+        prefix = absolute_pathname (prefix);
+        local_packages = prefix;
+        user_prefix = true;
+        if (length (files) >= 2 && ischar (files{2}))
+          archprefix = files{2};
+          try
+            archprefix = absolute_pathname (archprefix);
           catch
-	    mkdir (archprefix);
-	    warning ("creating the directory %s\n", archprefix);
-	    archprefix = absolute_pathname (archprefix);
-	  end_try_catch
-	  global_packages = archprefix;
-	endif
+            mkdir (archprefix);
+            warning ("creating the directory %s\n", archprefix);
+            archprefix = absolute_pathname (archprefix);
+          end_try_catch
+          global_packages = archprefix;
+        endif
       else
-	error ("you must specify a prefix directory, or request an output argument");
+        error ("you must specify a prefix directory, or request an output argument");
       endif
 
     case "local_list"
       if (length (files) == 0 && nargout == 0)
-	disp (local_list);
+        disp (local_list);
       elseif (length (files) == 0 && nargout == 1)
-	local_packages = local_list;
+        local_packages = local_list;
       elseif (length (files) == 1 && nargout == 0 && ischar (files{1}))
-	try
-	  local_list = absolute_pathname (files{1});
-	catch
-	  ## Force file to be created
-	  fclose (fopen (files{1}, "wt"));
-	  local_list = absolute_pathname (files{1});
-	end_try_catch
+        try
+          local_list = absolute_pathname (files{1});
+        catch
+          ## Force file to be created
+          fclose (fopen (files{1}, "wt"));
+          local_list = absolute_pathname (files{1});
+        end_try_catch
       else
-	error ("you must specify a local_list file, or request an output argument");
+        error ("you must specify a local_list file, or request an output argument");
       endif
 
     case "global_list"
       if (length (files) == 0 && nargout == 0)
-	disp(global_list);
+        disp(global_list);
       elseif (length (files) == 0 && nargout == 1)
-	local_packages = global_list;
+        local_packages = global_list;
       elseif (length (files) == 1 && nargout == 0 && ischar (files{1}))
-	try
-	  global_list = absolute_pathname (files{1});
-	catch
-	  ## Force file to be created
-	  fclose (fopen (files{1}, "wt"));
-	  global_list = absolute_pathname (files{1});
-	end_try_catch
+        try
+          global_list = absolute_pathname (files{1});
+        catch
+          ## Force file to be created
+          fclose (fopen (files{1}, "wt"));
+          global_list = absolute_pathname (files{1});
+        end_try_catch
       else
-	error ("you must specify a global_list file, or request an output argument");
+        error ("you must specify a global_list file, or request an output argument");
       endif
 
     case "rebuild"
       if (global_install)
-	global_packages = rebuild (prefix, archprefix, global_list, files, 
-				   auto, verbose);
-	global_packages = save_order (global_packages);
-	save (global_list, "global_packages");
-	if (nargout > 0)
-	  local_packages = global_packages;
-	endif
+        global_packages = rebuild (prefix, archprefix, global_list, files, 
+                                   auto, verbose);
+        global_packages = save_order (global_packages);
+        save (global_list, "global_packages");
+        if (nargout > 0)
+          local_packages = global_packages;
+        endif
       else
-	local_packages = rebuild (prefix, archprefix, local_list, files, auto, 
-				  verbose);
-	local_packages = save_order (local_packages);
-	save (local_list, "local_packages");
-	if (nargout == 0)
-	  clear ("local_packages");
-	endif
+        local_packages = rebuild (prefix, archprefix, local_list, files, auto, 
+                                  verbose);
+        local_packages = save_order (local_packages);
+        save (local_list, "local_packages");
+        if (nargout == 0)
+          clear ("local_packages");
+        endif
       endif
 
     case "build"
       if (length (files) < 2)
-	error ("you must specify at least the build directory and one filename\nwhen calling 'pkg build'");
+        error ("you must specify at least the build directory and one filename\nwhen calling 'pkg build'");
       endif
       build (files, deps, auto, verbose);
 
     case "describe"
       if (length (files) == 0)
-	error ("you must specify at least one package or 'all' when calling 'pkg describe'");
+        error ("you must specify at least one package or 'all' when calling 'pkg describe'");
       endif
       ## FIXME: the name of the output variables is inconsistent
       ##            with their content
       switch (nargout)
-	case 0
-	  describe (files, verbose, local_list, global_list);
-	case 1
-	  pkg_desc_list = describe (files, verbose, local_list, ...
-				    global_list);
-	  local_packages = pkg_desc_list;
-	case 2
-	  [pkg_desc_list, flag] = describe (files, verbose, local_list, ...
-					    global_list);
-	  local_packages  = pkg_desc_list;
-	  global_packages = flag;
-	otherwise
-	  error ("you can request at most two outputs when calling 'pkg describe'");
+        case 0
+          describe (files, verbose, local_list, global_list);
+        case 1
+          pkg_desc_list = describe (files, verbose, local_list, ...
+                                    global_list);
+          local_packages = pkg_desc_list;
+        case 2
+          [pkg_desc_list, flag] = describe (files, verbose, local_list, ...
+                                            global_list);
+          local_packages  = pkg_desc_list;
+          global_packages = flag;
+        otherwise
+          error ("you can request at most two outputs when calling 'pkg describe'");
       endswitch
-		
+                
     otherwise
       error ("you must specify a valid action for 'pkg'. See 'help pkg' for details");
   endswitch
 endfunction
 
 function descriptions = rebuild (prefix, archprefix, list, files, auto, verbose)
   if (isempty (files))
     [dirlist, err, msg] = readdir (prefix);
@@ -442,57 +442,57 @@ function descriptions = rebuild (prefix,
     descfile = fullfile (prefix, dirlist{k}, "packinfo", "DESCRIPTION");
     if (verbose)
       printf ("recreating package description from %s\n", dirlist{k});
     endif
     if (exist (descfile, "file"))
       desc = get_description (descfile);
       desc.dir = fullfile (prefix, dirlist{k});
       desc.archprefix = fullfile (archprefix, cstrcat (desc.name, "-",
-				  desc.version));
+                                  desc.version));
       if (auto != 0)
-	if (exist (fullfile (desc.dir, "packinfo", ".autoload"), "file"))
-	  unlink (fullfile (desc.dir, "packinfo", ".autoload"));
-	endif
+        if (exist (fullfile (desc.dir, "packinfo", ".autoload"), "file"))
+          unlink (fullfile (desc.dir, "packinfo", ".autoload"));
+        endif
         if (auto < 0)
-	  desc.autoload = 0;
-	elseif (auto > 0)
-	  desc.autoload = 1;
-	  fclose (fopen (fullfile (desc.dir, "packinfo", ".autoload"), "wt"));
-	endif
+          desc.autoload = 0;
+        elseif (auto > 0)
+          desc.autoload = 1;
+          fclose (fopen (fullfile (desc.dir, "packinfo", ".autoload"), "wt"));
+        endif
       else
-	if (exist (fullfile (desc.dir, "packinfo", ".autoload"), "file"))
-	  desc.autoload = 1;
-	else
-	  desc.autoload = 0;
-	endif
+        if (exist (fullfile (desc.dir, "packinfo", ".autoload"), "file"))
+          desc.autoload = 1;
+        else
+          desc.autoload = 0;
+        endif
       endif
       descriptions{end + 1} = desc;
     elseif (verbose)
       warning ("directory %s is not a valid package", dirlist{k});
     endif
   endfor
 
   if (! isempty (files))
     ## We are rebuilding for a particular package(s) so we should take
     ## care to keep the other untouched packages in the descriptions
     descriptions = {descriptions{:}, old_descriptions{:}};
 
     dup = [];
     for i = 1:length (descriptions)
       if (find (dup, i))
-	continue;
+        continue;
       endif
       for j = (i+1):length (descriptions)
-	if (find (dup, j))
-	  continue;
-	endif
-	if (strcmp (descriptions{i}.name, descriptions{j}.name))
-	  dup = [dup, j];
-	endif
+        if (find (dup, j))
+          continue;
+        endif
+        if (strcmp (descriptions{i}.name, descriptions{j}.name))
+          dup = [dup, j];
+        endif
       endfor
     endfor
     if (! isempty (dup))
       descriptions (dup) = [];
     endif  
   endif
 endfunction
 
@@ -514,145 +514,145 @@ function build (files, handle_deps, auto
     [status, msg] = mkdir (installdir);
     if (status != 1)
       error ("could not create installation directory: %s", msg);
     endif
   endif
   files(1) = [];
   buildlist = fullfile (builddir, "octave_packages");
   install (files, handle_deps, autoload, installdir, installdir, verbose, 
-	   buildlist, "", false);
+           buildlist, "", false);
   unwind_protect
     repackage (builddir, buildlist);
   unwind_protect_cleanup
     unload_packages ({"all"}, handle_deps, buildlist, "");
     if (exist (installdir, "dir"))
       rm_rf (installdir);
     endif
     if (exist (buildlist, "file"))
       unlink (buildlist);
     endif
   end_unwind_protect
 endfunction
 
 function install (files, handle_deps, autoload, prefix, archprefix, verbose, 
-		  local_list, global_list, global_install)
+                  local_list, global_list, global_install)
 
   ## Check that the directory in prefix exist. If it doesn't: create it!
   if (! exist (prefix, "dir"))
     warning ("creating installation directory %s", prefix);
     [status, msg] = mkdir (prefix);
     if (status != 1)
       error ("could not create installation directory: %s", msg);
     endif
   endif
 
   ## Get the list of installed packages.
   [local_packages, global_packages] = installed_packages (local_list, 
-							  global_list);
+                                                          global_list);
 
   installed_pkgs_lst = {local_packages{:}, global_packages{:}};        
 
   if (global_install)
     packages = global_packages;
   else
     packages = local_packages;
   endif
 
   ## Uncompress the packages and read the DESCRIPTION files.
   tmpdirs = packdirs = descriptions = {};
   try
     ## Warn about non existent files.
     for i = 1:length (files)
       if (isempty (glob(files{i}))) 
-	warning ("file %s does not exist", files{i});
+        warning ("file %s does not exist", files{i});
       endif
     endfor
 
     ## Unpack the package files and read the DESCRIPTION files.
     files = glob (files);
     packages_to_uninstall = [];
     for i = 1:length (files)
       tgz = files{i};
 
       if (exist (tgz, "file"))
-	## Create a temporary directory.
-	tmpdir = tmpnam ();
-	tmpdirs{end+1} = tmpdir;
+        ## Create a temporary directory.
+        tmpdir = tmpnam ();
+        tmpdirs{end+1} = tmpdir;
         if (verbose)
-	  printf ("mkdir (%s)\n", tmpdir);
-	endif
-	[status, msg] = mkdir (tmpdir);
-	if (status != 1)
-	  error ("couldn't create temporary directory: %s", msg);
-	endif
+          printf ("mkdir (%s)\n", tmpdir);
+        endif
+        [status, msg] = mkdir (tmpdir);
+        if (status != 1)
+          error ("couldn't create temporary directory: %s", msg);
+        endif
 
-	## Uncompress the package.
-	if (verbose)
-	  printf ("untar (%s, %s)\n", tgz, tmpdir);
-	endif
-	untar (tgz, tmpdir);
+        ## Uncompress the package.
+        if (verbose)
+          printf ("untar (%s, %s)\n", tgz, tmpdir);
+        endif
+        untar (tgz, tmpdir);
 
-	## Get the name of the directories produced by tar.
-	[dirlist, err, msg] = readdir (tmpdir);
-	if (err)
-	  error ("couldn't read directory produced by tar: %s", msg);
-	endif
+        ## Get the name of the directories produced by tar.
+        [dirlist, err, msg] = readdir (tmpdir);
+        if (err)
+          error ("couldn't read directory produced by tar: %s", msg);
+        endif
 
-	if (length (dirlist) > 3)
-	  error ("bundles of packages are not allowed")
-	endif
+        if (length (dirlist) > 3)
+          error ("bundles of packages are not allowed")
+        endif
       endif
 
       ## The filename pointed to an uncompressed package to begin with.
       if (exist (tgz, "dir"))
-	dirlist = {".", "..", tgz};
+        dirlist = {".", "..", tgz};
       endif
 
       if (exist (tgz, "file") || exist (tgz, "dir"))
-	## The two first entries of dirlist are "." and "..".
-	if (exist (tgz, "file"))
-	  packdir = fullfile (tmpdir, dirlist{3});
-	else
-	  packdir = fullfile (pwd(), dirlist{3});
-	endif
-	packdirs{end+1} = packdir;
-	
-	## Make sure the package contains necessary files.
-	verify_directory (packdir);
-	
-	## Read the DESCRIPTION file.
-	filename = fullfile (packdir, "DESCRIPTION");
-	desc = get_description (filename);
-	
-	## Verify that package name corresponds with filename.
-	[dummy, nm] = fileparts (tgz); 
-	if ((length (nm) >= length (desc.name))
-	    && ! strcmp (desc.name, nm(1:length(desc.name))))
-	  error ("package name '%s' doesn't correspond to its filename '%s'", 
-		 desc.name, nm);
-	endif
-	
-	## Set default installation directory.
-	desc.dir = fullfile (prefix, cstrcat (desc.name, "-", desc.version));
-	
-	## Set default architectire dependent installation directory.
-	desc.archprefix = fullfile (archprefix, cstrcat (desc.name, "-",
-							 desc.version));
-	
-	## Save desc.
-	descriptions{end+1} = desc;
-	
-	## Are any of the new packages already installed?
-	## If so we'll remove the old version.
-	for j = 1:length (packages)
-	  if (strcmp (packages{j}.name, desc.name))
-	    packages_to_uninstall(end+1) = j;
-	  endif
-	endfor
+        ## The two first entries of dirlist are "." and "..".
+        if (exist (tgz, "file"))
+          packdir = fullfile (tmpdir, dirlist{3});
+        else
+          packdir = fullfile (pwd(), dirlist{3});
+        endif
+        packdirs{end+1} = packdir;
+        
+        ## Make sure the package contains necessary files.
+        verify_directory (packdir);
+        
+        ## Read the DESCRIPTION file.
+        filename = fullfile (packdir, "DESCRIPTION");
+        desc = get_description (filename);
+        
+        ## Verify that package name corresponds with filename.
+        [dummy, nm] = fileparts (tgz); 
+        if ((length (nm) >= length (desc.name))
+            && ! strcmp (desc.name, nm(1:length(desc.name))))
+          error ("package name '%s' doesn't correspond to its filename '%s'", 
+                 desc.name, nm);
+        endif
+        
+        ## Set default installation directory.
+        desc.dir = fullfile (prefix, cstrcat (desc.name, "-", desc.version));
+        
+        ## Set default architectire dependent installation directory.
+        desc.archprefix = fullfile (archprefix, cstrcat (desc.name, "-",
+                                                         desc.version));
+        
+        ## Save desc.
+        descriptions{end+1} = desc;
+        
+        ## Are any of the new packages already installed?
+        ## If so we'll remove the old version.
+        for j = 1:length (packages)
+          if (strcmp (packages{j}.name, desc.name))
+            packages_to_uninstall(end+1) = j;
+          endif
+        endfor
       endif
     endfor
   catch
     ## Something went wrong, delete tmpdirs.
     for i = 1:length (tmpdirs)
       rm_rf (tmpdirs{i});
     endfor
     rethrow (lasterror ());
@@ -661,37 +661,37 @@ function install (files, handle_deps, au
   ## Check dependencies.
   if (handle_deps)
     ok = true;
     error_text = "";
     for i = 1:length (descriptions)
       desc = descriptions{i};
       idx2 = setdiff (1:length(descriptions), i);
       if (global_install)
-	## Global installation is not allowed to have dependencies on locally
-	## installed packages.
-	idx1 = setdiff (1:length(global_packages), packages_to_uninstall);
-	pseudo_installed_packages = {global_packages{idx1}, ...
-				     descriptions{idx2}};
+        ## Global installation is not allowed to have dependencies on locally
+        ## installed packages.
+        idx1 = setdiff (1:length(global_packages), packages_to_uninstall);
+        pseudo_installed_packages = {global_packages{idx1}, ...
+                                     descriptions{idx2}};
       else
-	idx1 = setdiff (1:length(local_packages), packages_to_uninstall);
-	pseudo_installed_packages = {local_packages{idx1}, ... 
-				     global_packages{:}, ...
-				     descriptions{idx2}};
+        idx1 = setdiff (1:length(local_packages), packages_to_uninstall);
+        pseudo_installed_packages = {local_packages{idx1}, ... 
+                                     global_packages{:}, ...
+                                     descriptions{idx2}};
       endif
       bad_deps = get_unsatisfied_deps (desc, pseudo_installed_packages);
       ## Are there any unsatisfied dependencies?
       if (! isempty (bad_deps))
-	ok = false;
-	for i = 1:length (bad_deps)
-	  dep = bad_deps{i};
-	  error_text = cstrcat (error_text, " ", desc.name, " needs ",
-			       dep.package, " ", dep.operator, " ",
-			       dep.version, "\n");
-	endfor
+        ok = false;
+        for i = 1:length (bad_deps)
+          dep = bad_deps{i};
+          error_text = cstrcat (error_text, " ", desc.name, " needs ",
+                               dep.package, " ", dep.operator, " ",
+                               dep.version, "\n");
+        endfor
       endif
     endfor
 
     ## Did we find any unsatisfied dependencies?
     if (! ok)
       error ("the following dependencies where unsatisfied:\n  %s", error_text);
     endif
   endif
@@ -711,21 +711,21 @@ function install (files, handle_deps, au
     endfor
     rethrow (lasterror ());
   end_try_catch
 
   ## Uninstall the packages that will be replaced.
   try
     for i = packages_to_uninstall
       if (global_install)
-	uninstall ({global_packages{i}.name}, false, verbose, local_list, 
-		   global_list, global_install);
+        uninstall ({global_packages{i}.name}, false, verbose, local_list, 
+                   global_list, global_install);
       else
-	uninstall ({local_packages{i}.name}, false, verbose, local_list, 
-		   global_list, global_install);
+        uninstall ({local_packages{i}.name}, false, verbose, local_list, 
+                   global_list, global_install);
       endif
     endfor
   catch
     ## Something went wrong, delete tmpdirs.
     for i = 1:length (tmpdirs)
       rm_rf (tmpdirs{i});
     endfor
     rethrow (lasterror ());
@@ -753,30 +753,30 @@ function install (files, handle_deps, au
     endfor
     rethrow (lasterror ());
   end_try_catch
 
   ## Check if the installed directory is empty. If it is remove it
   ## from the list.
   for i = length (descriptions):-1:1
     if (dirempty (descriptions{i}.dir, {"packinfo", "doc"}) &&
-	dirempty (getarchdir (descriptions{i})))
+        dirempty (getarchdir (descriptions{i})))
       warning ("package %s is empty\n", descriptions{i}.name);
       rm_rf (descriptions{i}.dir);
       rm_rf (getarchdir (descriptions{i}));
       descriptions(i) = [];
     endif
   endfor
 
   ## If the package requested that it is autoloaded, or the installer
   ## requested that it is, then mark the package as autoloaded.
   for i = length (descriptions):-1:1
     if (autoload > 0 || (autoload == 0 && isautoload (descriptions(i))))
       fclose (fopen (fullfile (descriptions{i}.dir, "packinfo", 
-			       ".autoload"), "wt"));
+                               ".autoload"), "wt"));
       descriptions{i}.autoload = 1;
     endif
   endfor
 
   ## Add the packages to the package list.
   try
     if (global_install)
       idx = setdiff (1:length(global_packages), packages_to_uninstall);
@@ -814,35 +814,35 @@ function install (files, handle_deps, au
   endfor
 
   ## Add the newly installed packages to the path, so the user
   ## can begin using them. Only load them if they are marked autoload.
   if (length (descriptions) > 0)
     idx = [];
     for i = 1:length (descriptions)
       if (isautoload (descriptions(i)))
-	nm = descriptions{i}.name;
-	for j = 1:length (installed_pkgs_lst)
-	  if (strcmp (nm, installed_pkgs_lst{j}.name))
-	    idx (end + 1) = j;
-	    break;
-	  endif
-	endfor
+        nm = descriptions{i}.name;
+        for j = 1:length (installed_pkgs_lst)
+          if (strcmp (nm, installed_pkgs_lst{j}.name))
+            idx (end + 1) = j;
+            break;
+          endif
+        endfor
       endif
     endfor
     load_packages_and_dependencies (idx, handle_deps, installed_pkgs_lst,
-				    global_install);
+                                    global_install);
   endif
 endfunction
 
 function uninstall (pkgnames, handle_deps, verbose, local_list, 
-		    global_list, global_install)
+                    global_list, global_install)
   ## Get the list of installed packages.
   [local_packages, global_packages] = installed_packages(local_list, 
-							 global_list);
+                                                         global_list);
   if (global_install)
     installed_pkgs_lst = {local_packages{:}, global_packages{:}};
   else
     installed_pkgs_lst = local_packages;
   endif
 
   num_packages = length (installed_pkgs_lst);
   delete_idx = [];
@@ -857,24 +857,24 @@ function uninstall (pkgnames, handle_dep
   if (length (delete_idx) != length (pkgnames))
     if (global_install)
       ## Try again for a locally installed package.
       installed_pkgs_lst = local_packages;
 
       num_packages = length (installed_pkgs_lst);
       delete_idx = [];
       for i = 1:num_packages
-	cur_name = installed_pkgs_lst{i}.name;
-	if (any (strcmp (cur_name, pkgnames)))
-	  delete_idx(end+1) = i;
-	endif
+        cur_name = installed_pkgs_lst{i}.name;
+        if (any (strcmp (cur_name, pkgnames)))
+          delete_idx(end+1) = i;
+        endif
       endfor
       if (length (delete_idx) != length (pkgnames))
-	## FIXME: We should have a better error message.
-	warning ("some of the packages you want to uninstall are not installed");
+        ## FIXME: We should have a better error message.
+        warning ("some of the packages you want to uninstall are not installed");
       endif
     else
       ## FIXME: We should have a better error message.
       warning ("some of the packages you want to uninstall are not installed");
     endif
   endif
 
   ## Compute the packages that will remain installed.
@@ -885,22 +885,22 @@ function uninstall (pkgnames, handle_dep
   if (handle_deps)
     error_text = "";
     for i = 1:length (remaining_packages)
       desc = remaining_packages{i};
       bad_deps = get_unsatisfied_deps (desc, remaining_packages);
 
       ## Will the uninstallation break any dependencies?
       if (! isempty (bad_deps))
-	for i = 1:length (bad_deps)
-	  dep = bad_deps{i};
-	  error_text = cstrcat (error_text, " ", desc.name, " needs ",
-			       dep.package, " ", dep.operator, " ",
-			       dep.version, "\n");
-	endfor
+        for i = 1:length (bad_deps)
+          dep = bad_deps{i};
+          error_text = cstrcat (error_text, " ", desc.name, " needs ",
+                               dep.package, " ", dep.operator, " ",
+                               dep.version, "\n");
+        endfor
       endif
     endfor
 
     if (! isempty (error_text))
       error ("the following dependencies where unsatisfied:\n  %s", error_text);
     endif
   endif
 
@@ -913,30 +913,30 @@ function uninstall (pkgnames, handle_dep
       cd (fullfile (desc.dir, "packinfo"));
       on_uninstall (desc);
       cd (wd);
     endif
     ## Do the actual deletion.
     if (desc.loaded)
       rmpath (desc.dir);
       if (exist (getarchdir (desc)))
-	rmpath (getarchdir (desc));
+        rmpath (getarchdir (desc));
       endif
     endif
     if (exist (desc.dir, "dir"))
       [status, msg] = rm_rf (desc.dir);
       if (status != 1)
-	error ("couldn't delete directory %s: %s", desc.dir, msg);
+        error ("couldn't delete directory %s: %s", desc.dir, msg);
       endif
       [status, msg] = rm_rf (getarchdir (desc));
       if (status != 1)
-	error ("couldn't delete directory %s: %s", getarchdir (desc), msg);
+        error ("couldn't delete directory %s: %s", getarchdir (desc), msg);
       endif
       if (dirempty (desc.archprefix))
-	rm_rf (desc.archprefix);
+        rm_rf (desc.archprefix);
       endif
     else
       warning ("directory %s previously lost", desc.dir);
     endif
   endfor
 
   ## Write a new ~/.octave_packages.
   if (global_install)
@@ -953,17 +953,17 @@ function uninstall (pkgnames, handle_dep
       local_packages = save_order (remaining_packages);
       save (local_list, "local_packages");
     endif
   endif
 
 endfunction
 
 function [pkg_desc_list, flag] = describe (pkgnames, verbose, 
-					   local_list, global_list)
+                                           local_list, global_list)
 
   ## Get the list of installed packages.
   installed_pkgs_lst = installed_packages(local_list, global_list);
   num_packages = length (installed_pkgs_lst);
   
 
   describe_all = false;
   if (any (strcmp ("all", pkgnames)))
@@ -980,19 +980,19 @@ function [pkg_desc_list, flag] = describ
     if (describe_all)
       name_pos = i;
     else
       name_pos = find(strcmp (curr_name, pkgnames));
     endif
 
     if (! isempty (name_pos))
       if (installed_pkgs_lst{i}.loaded)
-	flag{name_pos} = "Loaded";
+        flag{name_pos} = "Loaded";
       else
-	flag{name_pos} = "Not loaded";
+        flag{name_pos} = "Not loaded";
       endif
 
       pkg_desc_list{name_pos}.name = installed_pkgs_lst{i}.name;
       pkg_desc_list{name_pos}.version = installed_pkgs_lst{i}.version;
       pkg_desc_list{name_pos}.description = installed_pkgs_lst{i}.description;
       pkg_desc_list{name_pos}.provides = parse_pkg_idx (installed_pkgs_lst{i}.dir);
 
     endif
@@ -1000,27 +1000,27 @@ function [pkg_desc_list, flag] = describ
 
   non_inst = find (strcmp (flag, "Not installed"));
   if (! isempty (non_inst))
     if (nargout < 2)
       non_inst_str = sprintf (" %s ", pkgnames{non_inst});
       error ("some packages are not installed: %s", non_inst_str);
     else
       pkg_desc_list{non_inst} = struct ("name", {}, "description",  
-					{}, "provides", {});
+                                        {}, "provides", {});
     endif
   endif
 
   if (nargout == 0)
     for i = 1:num_pkgnames
       print_package_description (pkg_desc_list{i}.name,
-				 pkg_desc_list{i}.version,
-				 pkg_desc_list{i}.provides,  
-				 pkg_desc_list{i}.description,
-				 flag{i}, verbose);
+                                 pkg_desc_list{i}.version,
+                                 pkg_desc_list{i}.provides,  
+                                 pkg_desc_list{i}.description,
+                                 flag{i}, verbose);
     endfor
   endif
 
 endfunction
 
 ## AUXILIARY FUNCTIONS
 
 ## Read an INDEX file.
@@ -1031,17 +1031,17 @@ function [pkg_idx_struct] = parse_pkg_id
   if (! exist (index_file, "file"))
     error ("could not find any INDEX file in directory %s, try 'pkg rebuild all' to generate missing INDEX files", packdir);
   endif    
 
     
   [fid, msg] = fopen (index_file, "r");
   if (fid == -1)
     error ("the INDEX file %s could not be read: %s", 
-	   index_file, msg);
+           index_file, msg);
   endif
 
   cat_num = 1;
   pkg_idx_struct{1}.category = "Uncategorized";
   pkg_idx_struct{1}.functions = {};
 
   line = fgetl (fid);
   while (isempty (strfind (line, ">>")) && ! feof (fid))
@@ -1055,46 +1055,46 @@ function [pkg_idx_struct] = parse_pkg_id
       ## FIXME: probably comments and pointers to external functions
       ## could be treated better when printing to screen?
     elseif (! isempty (strfind (line, ">>")))
       ## Skip package name and description as they are in DESCRIPTION
       ## already.
     elseif (! isspace (line(1)))
       ## Category.
       if (! isempty (pkg_idx_struct{cat_num}.functions))
-	pkg_idx_struct{++cat_num}.functions = {};
+        pkg_idx_struct{++cat_num}.functions = {};
       endif
       pkg_idx_struct{cat_num}.category = deblank (line);
     else
       ## Function names.
       while (any (! isspace (line)))
-	[fun_name, line] = strtok (line);
-	pkg_idx_struct{cat_num}.functions{end+1} = deblank (fun_name);
+        [fun_name, line] = strtok (line);
+        pkg_idx_struct{cat_num}.functions{end+1} = deblank (fun_name);
       endwhile
     endif
     line = fgetl (fid);
   endwhile
   fclose (fid);
 endfunction
 
 function print_package_description (pkg_name, pkg_ver, pkg_idx_struct, 
-				    pkg_desc, status, verbose)
+                                    pkg_desc, status, verbose)
 
   printf ("---\nPackage name:\n\t%s\n", pkg_name);
   printf ("Version:\n\t%s\n", pkg_ver);
   printf ("Short description:\n\t%s\n", pkg_desc);
   printf ("Status:\n\t%s\n", status);
   if (verbose)
     printf ("---\nProvides:\n");    
     for i = 1:length(pkg_idx_struct)
       if (! isempty (pkg_idx_struct{i}.functions))
-	printf ("%s\n", pkg_idx_struct{i}.category);
-	for j = 1:length(pkg_idx_struct{i}.functions)
-	  printf ("\t%s\n", pkg_idx_struct{i}.functions{j});
-	endfor
+        printf ("%s\n", pkg_idx_struct{i}.category);
+        for j = 1:length(pkg_idx_struct{i}.functions)
+          printf ("\t%s\n", pkg_idx_struct{i}.functions{j});
+        endfor
       endif
     endfor
   endif
 
 endfunction
 
 
 function pth = absolute_pathname (pth)
@@ -1114,78 +1114,78 @@ function repackage (builddir, buildlist)
     pack = packages{i};
     unwind_protect
       cd (builddir);
       mkdir (pack.name);
       mkdir (fullfile (pack.name, "inst"));
       copyfile (fullfile (pack.dir, "*"), fullfile (pack.name, "inst"));
       movefile (fullfile (pack.name, "inst","packinfo", "*"), pack.name);
       if (exist (fullfile (pack.name, "inst","packinfo", ".autoload"), "file"))
-	unlink (fullfile (pack.name, "inst","packinfo", ".autoload"));
+        unlink (fullfile (pack.name, "inst","packinfo", ".autoload"));
       endif
       rmdir (fullfile (pack.name, "inst", "packinfo"));
       if (exist (fullfile (pack.name, "inst", "doc"), "dir"))
-	movefile (fullfile (pack.name, "inst", "doc"), pack.name);
+        movefile (fullfile (pack.name, "inst", "doc"), pack.name);
       endif
       if (exist (fullfile (pack.name, "inst", "bin"), "dir"))
-	movefile (fullfile (pack.name, "inst", "bin"), pack.name);
+        movefile (fullfile (pack.name, "inst", "bin"), pack.name);
       endif
       archdir = fullfile (pack.archprefix, cstrcat (pack.name, "-",
-			  pack.version), getarch ());
+                          pack.version), getarch ());
       if (exist (archdir, "dir"))
-	if (exist (fullfile (pack.name, "inst", "PKG_ADD"), "file"))
-	  unlink (fullfile (pack.name, "inst", "PKG_ADD"));
-	endif
-	if (exist (fullfile (pack.name, "inst", "PKG_DEL"), "file"))
-	  unlink (fullfile (pack.name, "inst", "PKG_DEL"));
-	endif
-	if (exist (fullfile (archdir, "PKG_ADD"), "file"))
-	  movefile (fullfile (archdir, "PKG_ADD"), 
-		    fullfile (pack.name, "PKG_ADD"));
-	endif
-	if (exist (fullfile (archdir, "PKG_DEL"), "file"))
-	  movefile (fullfile (archdir, "PKG_DEL"), 
-		    fullfile (pack.name, "PKG_DEL")); 
-	endif
+        if (exist (fullfile (pack.name, "inst", "PKG_ADD"), "file"))
+          unlink (fullfile (pack.name, "inst", "PKG_ADD"));
+        endif
+        if (exist (fullfile (pack.name, "inst", "PKG_DEL"), "file"))
+          unlink (fullfile (pack.name, "inst", "PKG_DEL"));
+        endif
+        if (exist (fullfile (archdir, "PKG_ADD"), "file"))
+          movefile (fullfile (archdir, "PKG_ADD"), 
+                    fullfile (pack.name, "PKG_ADD"));
+        endif
+        if (exist (fullfile (archdir, "PKG_DEL"), "file"))
+          movefile (fullfile (archdir, "PKG_DEL"), 
+                    fullfile (pack.name, "PKG_DEL")); 
+        endif
       else
-	if (exist (fullfile (pack.name, "inst", "PKG_ADD"), "file"))
-	  movefile (fullfile (pack.name, "inst", "PKG_ADD"), 
-		    fullfile (pack.name, "PKG_ADD"));
-	endif 
-	if (exist (fullfile (pack.name, "inst", "PKG_DEL"), "file"))
-	  movefile (fullfile (pack.name, "inst", "PKG_DEL"), 
-		    fullfile (pack.name, "PKG_DEL")); 
-	endif	
-      endif	
+        if (exist (fullfile (pack.name, "inst", "PKG_ADD"), "file"))
+          movefile (fullfile (pack.name, "inst", "PKG_ADD"), 
+                    fullfile (pack.name, "PKG_ADD"));
+        endif 
+        if (exist (fullfile (pack.name, "inst", "PKG_DEL"), "file"))
+          movefile (fullfile (pack.name, "inst", "PKG_DEL"), 
+                    fullfile (pack.name, "PKG_DEL")); 
+        endif   
+      endif     
       tfile = cstrcat (pack.name, "-", pack.version, ".tar");
       tar (tfile, pack.name);
       try 
-	gzip (tfile);
-	unlink (tfile);
+        gzip (tfile);
+        unlink (tfile);
       catch
-	warning ("failed to compress %s", tfile);
+        warning ("failed to compress %s", tfile);
       end_try_catch
     unwind_protect_cleanup
       if (exist (pack.name, "dir"))
-	rm_rf (pack.name);
+        rm_rf (pack.name);
       endif
       cd (wd);
     end_unwind_protect
   endfor
 endfunction
 
 function auto = isautoload (desc)
   auto = false;
   if (isfield (desc{1}, "autoload"))
     a = desc{1}.autoload;
     if ((isnumeric (a) && a > 0)
         || (ischar (a) && (strcmpi (a, "true")
-			 || strcmpi (a, "on")
-			 || strcmpi (a, "yes")
-			 || strcmpi (a, "1"))))
+                         || strcmpi (a, "on")
+                         || strcmpi (a, "yes")
+                         || strcmpi (a, "1"))))
       auto = true;
     endif
   endif
 endfunction
 
 function prepare_installation (desc, packdir)
   ## Is there a pre_install to call?
   if (exist (fullfile (packdir, "pre_install.m"), "file"))
@@ -1202,17 +1202,17 @@ function prepare_installation (desc, pac
 
   ## If the directory "inst" doesn't exist, we create it.
   inst_dir = fullfile (packdir, "inst");
   if (! exist (inst_dir, "dir"))
     [status, msg] = mkdir (inst_dir);
     if (status != 1)
       rm_rf (desc.dir);
       error ("the 'inst' directory did not exist and could not be created: %s", 
-	     msg);
+             msg);
     endif
   endif
 endfunction
 
 function configure_make (desc, packdir, verbose)   
   ## Perform ./configure, make, make install in "src".
   if (exist (fullfile (packdir, "src"), "dir"))
     src = fullfile (packdir, "src");
@@ -1229,129 +1229,129 @@ function configure_make (desc, packdir, 
         flags = cstrcat (flags, " AR=\"", octave_config_info ("AR"), "\"");
       endif
       if (isempty (getenv ("RANLIB")))
         flags = cstrcat (flags, " RANLIB=\"", octave_config_info ("RANLIB"), "\"");
       endif
       [status, output] = shell (strcat ("cd '", src, "'; ./configure --prefix=\"",
                                         desc.dir, "\"", flags));
       if (status != 0)
-	rm_rf (desc.dir);
-	error ("the configure script returned the following error: %s", output);
+        rm_rf (desc.dir);
+        error ("the configure script returned the following error: %s", output);
       elseif (verbose)
-	printf("%s", output);
+        printf("%s", output);
       endif
 
     endif
 
     ## Make.
     if (exist (fullfile (src, "Makefile"), "file"))
       [status, output] = shell (cstrcat ("export INSTALLDIR=\"", desc.dir,
-					 "\"; make -C '", src, "'"));
+                                         "\"; make -C '", src, "'"));
       if (status != 0)
-	rm_rf (desc.dir);
-	error ("'make' returned the following error: %s", output);
+        rm_rf (desc.dir);
+        error ("'make' returned the following error: %s", output);
       elseif (verbose)
-	printf("%s", output);
+        printf("%s", output);
       endif
     endif
 
     ## Copy files to "inst" and "inst/arch" (this is instead of 'make
     ## install').
     files = fullfile (src, "FILES");
     instdir = fullfile (packdir, "inst");
     archdir = fullfile (packdir, "inst", getarch ());
 
     ## Get file names.
     if (exist (files, "file"))
       [fid, msg] = fopen (files, "r");
       if (fid < 0)
-	error ("couldn't open %s: %s", files, msg);
+        error ("couldn't open %s: %s", files, msg);
       endif
       filenames = char (fread (fid))';
       fclose (fid);
       if (filenames(end) == "\n")
-	filenames(end) = [];
+        filenames(end) = [];
       endif
       filenames = split_by (filenames, "\n");
       delete_idx =  [];
       for i = 1:length (filenames)
-	if (! all (isspace (filenames{i})))
-	  filenames{i} = fullfile (src, filenames{i});
-	else
-	  delete_idx(end+1) = i;
-	endif
+        if (! all (isspace (filenames{i})))
+          filenames{i} = fullfile (src, filenames{i});
+        else
+          delete_idx(end+1) = i;
+        endif
       endfor
       filenames(delete_idx) = [];
     else
       m = dir (fullfile (src, "*.m"));
       oct = dir (fullfile (src, "*.oct"));
       mex = dir (fullfile (src, "*.mex"));
 
       filenames = cellfun (@(x) fullfile (src, x),
-			   {m.name, oct.name, mex.name},
-			   "UniformOutput", false);
+                           {m.name, oct.name, mex.name},
+                           "UniformOutput", false);
     endif
 
     ## Split into architecture dependent and independent files.
     if (isempty (filenames))
       idx = [];
     else
       idx = cellfun (@is_architecture_dependent, filenames);
     endif
     archdependent = filenames (idx);
     archindependent = filenames (!idx);
 
     ## Copy the files.
     if (! all (isspace ([filenames{:}])))
-	if (! exist (instdir, "dir")) 
-	  mkdir (instdir);
-	endif
-	if (! all (isspace ([archindependent{:}])))
-	  if (verbose)
-	    printf ("copyfile");
-	    printf (" %s", archindependent{:});
-	    printf ("%s\n", instdir);
-	  endif
-	  [status, output] = copyfile (archindependent, instdir);
-	  if (status != 1)
-	    rm_rf (desc.dir);
-	    error ("Couldn't copy files from 'src' to 'inst': %s", output);
-	  endif
+        if (! exist (instdir, "dir")) 
+          mkdir (instdir);
+        endif
+        if (! all (isspace ([archindependent{:}])))
+          if (verbose)
+            printf ("copyfile");
+            printf (" %s", archindependent{:});
+            printf ("%s\n", instdir);
+          endif
+          [status, output] = copyfile (archindependent, instdir);
+          if (status != 1)
+            rm_rf (desc.dir);
+            error ("Couldn't copy files from 'src' to 'inst': %s", output);
+          endif
         endif
-	if (! all (isspace ([archdependent{:}])))
-	  if (verbose)
-	    printf ("copyfile");
-	    printf (" %s", archdependent{:});
-	    printf (" %s\n", archdir);
-	  endif
-	  if (! exist (archdir, "dir")) 
-	    mkdir (archdir);
-	  endif
-	  [status, output] = copyfile (archdependent, archdir);
-	  if (status != 1)
-	    rm_rf (desc.dir);
-	    error ("Couldn't copy files from 'src' to 'inst': %s", output);
-	  endif
+        if (! all (isspace ([archdependent{:}])))
+          if (verbose)
+            printf ("copyfile");
+            printf (" %s", archdependent{:});
+            printf (" %s\n", archdir);
+          endif
+          if (! exist (archdir, "dir")) 
+            mkdir (archdir);
+          endif
+          [status, output] = copyfile (archdependent, archdir);
+          if (status != 1)
+            rm_rf (desc.dir);
+            error ("Couldn't copy files from 'src' to 'inst': %s", output);
+          endif
         endif
     endif
   endif
 endfunction
 
 function pkg = extract_pkg (nm, pat)
   fid = fopen (nm, "rt");
   pkg = "";
   if (fid >= 0)
     while (! feof (fid))
       ln = fgetl (fid);
       if (ln > 0)
-	t = regexp (ln, pat, "tokens");
-	if (! isempty (t))
+        t = regexp (ln, pat, "tokens");
+        if (! isempty (t))
           pkg = cstrcat (pkg, "\n", t{1}{1});
-	endif
+        endif
       endif
     endwhile
     if (! isempty (pkg))
       pkg = cstrcat (pkg, "\n");
     endif
     fclose (fid);
   endif
 endfunction
@@ -1359,17 +1359,17 @@ endfunction
 function create_pkgadddel (desc, packdir, nm, global_install)
   instpkg = fullfile (desc.dir, nm);
   instfid = fopen (instpkg, "wt");
   ## If it is exists, most of the  PKG_* file should go into the 
   ## architecture dependent directory so that the autoload/mfilename 
   ## commands work as expected. The only part that doesn't is the
   ## part in the main directory.
   archdir = fullfile (getarchprefix (desc), cstrcat (desc.name, "-",
-		      desc.version), getarch ());
+                      desc.version), getarch ());
   if (exist (getarchdir (desc, global_install), "dir"))
     archpkg = fullfile (getarchdir (desc, global_install), nm);
     archfid = fopen (archpkg, "at");
   else
     archpkg = instpkg;
     archfid = instfid;
   endif
 
@@ -1437,17 +1437,17 @@ function copy_files (desc, packdir, glob
   instdir = fullfile (packdir, "inst");
   if (! dirempty (instdir))
     [status, output] = copyfile (fullfile (instdir, "*"), desc.dir);
     if (status != 1)
       rm_rf (desc.dir);
       error ("couldn't copy files to the installation directory");
     endif
     if (exist (fullfile (desc.dir, getarch ()), "dir") &&
-	! strcmp (fullfile (desc.dir, getarch ()), octfiledir))
+        ! strcmp (fullfile (desc.dir, getarch ()), octfiledir))
       if (! exist (octfiledir, "dir"))
         ## Can be required to create upto three levels of dirs.
         octm1 = fileparts (octfiledir);
         if (! exist (octm1, "dir"))
           octm2 = fileparts (octm1);
           if (! exist (octm2, "dir"))
             octm3 = fileparts (octm2);
             if (! exist (octm3, "dir"))
@@ -1475,17 +1475,17 @@ function copy_files (desc, packdir, glob
         [status, output] = mkdir (octfiledir);
         if (status != 1)
           rm_rf (desc.dir);
           error ("couldn't create installation directory %s : %s", 
           octfiledir, output);
         endif
       endif
       [status, output] = movefile (fullfile (desc.dir, getarch (), "*"), 
-				   octfiledir);
+                                   octfiledir);
       rm_rf (fullfile (desc.dir, getarch ()));
 
       if (status != 1)
         rm_rf (desc.dir);
         rm_rf (octfiledir);
         error ("couldn't copy files to the installation directory");
       endif
     endif
@@ -1535,17 +1535,17 @@ function copy_files (desc, packdir, glob
     if (status != 1)
       rm_rf (desc.dir);
       rm_rf (octfiledir);
       error ("couldn't copy INDEX file: %s", output);
     endif
   else
     try
       write_index (desc, fullfile (packdir, "inst"),
-		   fullfile (packinfo, "INDEX"), global_install);
+                   fullfile (packinfo, "INDEX"), global_install);
     catch
       rm_rf (desc.dir);
       rm_rf (octfiledir);
       rethrow (lasterror ());
     end_try_catch
   endif
 
   ## Is there an 'on_uninstall.m' to install?
@@ -1618,41 +1618,41 @@ function desc = get_description (filenam
 
   line = fgetl (fid);
   while (line != -1)
     if (line(1) == "#")
       ## Comments, do nothing.
     elseif (isspace(line(1)))
       ## Continuation lines
       if (exist ("keyword", "var") && isfield (desc, keyword))
-	desc.(keyword) = cstrcat (desc.(keyword), " ", rstrip(line));
+        desc.(keyword) = cstrcat (desc.(keyword), " ", rstrip(line));
       endif
     else
       ## Keyword/value pair
       colon = find (line == ":");
       if (length (colon) == 0)
-	disp ("skipping line");
+        disp ("skipping line");
       else
-	colon = colon(1);
-	keyword = tolower (strip (line(1:colon-1)));
-	value = strip (line (colon+1:end));
-	if (length (value) == 0)
-	    fclose (fid);
-	    error ("the keyword %s has an empty value", desc.keywords{end});
-	endif
-	desc.(keyword) = value;
+        colon = colon(1);
+        keyword = tolower (strip (line(1:colon-1)));
+        value = strip (line (colon+1:end));
+        if (length (value) == 0)
+            fclose (fid);
+            error ("the keyword %s has an empty value", desc.keywords{end});
+        endif
+        desc.(keyword) = value;
       endif
     endif
     line = fgetl (fid);
   endwhile
   fclose (fid);
 
   ## Make sure all is okay.
   needed_fields = {"name", "version", "date", "title", ...
-		   "author", "maintainer", "description"};
+                   "author", "maintainer", "description"};
   for f = needed_fields
     if (! isfield (desc, f{1}))
       error ("description is missing needed field %s", f{1});
     endif
   endfor
   desc.version = fix_version (desc.version);
   if (isfield (desc, "depends"))
     desc.depends = fix_depends (desc.depends);
@@ -1699,35 +1699,35 @@ function deps_cell = fix_depends (depend
     rpar = find (dep == ")");
     ## Does the dependency specify a version
     ## Example: package(>= version).
     if (length (lpar) == 1 && length (rpar) == 1)
       package = tolower (strip (dep(1:lpar-1)));
       sub = dep(lpar(1)+1:rpar(1)-1);
       parts = strsplit (sub, " ", true);
       if (length (parts) != 2)
-	error ("incorrect syntax for dependency `%s' in the DESCRIPTION file\n",
-	       dep);
+        error ("incorrect syntax for dependency `%s' in the DESCRIPTION file\n",
+               dep);
       endif
       operator = parts{1};
       if (! any (strcmp (operator, {">", ">=", "<=", "<", "=="})))
-	error ("unsupported operator: %s", operator);
+        error ("unsupported operator: %s", operator);
       endif
       version  = fix_version (parts{2});
 
   ## If no version is specified for the dependency
   ## we say that the version should be greater than 
   ## or equal to "0.0.0".
   else
     package = tolower (strip (dep));
     operator = ">=";
     version  = "0.0.0";
   endif
   deps_cell{i} = struct ("package", package, "operator", operator,
-			 "version", version);
+                         "version", version);
   endfor
 endfunction
 
 ## Strip the text of spaces from the right
 ## Example: "  hello world  " => "  hello world"
 ## FIXME -- is this the same as deblank?
 function text = rstrip (text)
   chars = find (! isspace (text));
@@ -1834,23 +1834,23 @@ function bad_deps = get_unsatisfied_deps
     if (strcmp (dep.package, "octave"))
       if (! compare_versions (OCTAVE_VERSION, dep.version, dep.operator))
         bad_deps{end+1} = dep;
       endif
       ## Is the current dependency not Octave?
     else
       ok = false;
       for i = 1:length (installed_pkgs_lst)
-	cur_name = installed_pkgs_lst{i}.name;
-	cur_version = installed_pkgs_lst{i}.version;
-	if (strcmp (dep.package, cur_name)
-	    && compare_versions (cur_version, dep.version, dep.operator))
-	  ok = true;
-	  break;
-	endif
+        cur_name = installed_pkgs_lst{i}.name;
+        cur_version = installed_pkgs_lst{i}.version;
+        if (strcmp (dep.package, cur_name)
+            && compare_versions (cur_version, dep.version, dep.operator))
+          ok = true;
+          break;
+        endif
       endfor
       if (! ok)
         bad_deps{end+1} = dep;
       endif
     endif
   endfor
 endfunction
 
@@ -1872,20 +1872,20 @@ function [out1, out2] = installed_packag
   ## Locally installed packages take precedence.
   dup = [];
   for i = 1:length (installed_pkgs_lst)
     if (find (dup, i))
       continue;
     endif
     for j = (i+1):length (installed_pkgs_lst)
       if (find (dup, j))
-	continue;
+        continue;
       endif
       if (strcmp (installed_pkgs_lst{i}.name, installed_pkgs_lst{j}.name))
-	dup = [dup, j];
+        dup = [dup, j];
       endif
     endfor
   endfor
   if (! isempty(dup))
     installed_pkgs_lst(dup) = [];
   endif  
 
   ## Now check if the package is loaded.
@@ -1933,23 +1933,23 @@ function [out1, out2] = installed_packag
   h1 = "Package Name";
   h2 = "Version";
   h3 = "Installation directory";
   max_name_length = length (h1); 
   max_version_length = length (h2);
   names = cell (num_packages, 1); 
   for i = 1:num_packages
     max_name_length = max (max_name_length,
-			   length (installed_pkgs_lst{i}.name));
+                           length (installed_pkgs_lst{i}.name));
     max_version_length = max (max_version_length,
-			      length (installed_pkgs_lst{i}.version));
+                              length (installed_pkgs_lst{i}.version));
     names{i} = installed_pkgs_lst{i}.name;
   endfor
   max_dir_length = terminal_size()(2) - max_name_length - ...
-					     max_version_length - 7;
+                                             max_version_length - 7;
   if (max_dir_length < 20)
      max_dir_length = Inf;
   endif
 
   h1 = postpad (h1, max_name_length + 1, " ");
   h2 = postpad (h2, max_version_length, " ");;
 
   ## Print a header.
@@ -1957,28 +1957,28 @@ function [out1, out2] = installed_packag
   printf (header);
   tmp = sprintf (repmat ("-", 1, length(header)-1));
   tmp(length(h1)+2) = "+";
   tmp(length(h1)+length(h2)+5) = "+";
   printf ("%s\n", tmp);
 
   ## Print the packages.
   format = sprintf ("%%%ds %%1s| %%%ds | %%s\n", max_name_length,
-		    max_version_length);
+                    max_version_length);
   [dummy, idx] = sort (names);
   for i = 1:num_packages
     cur_name = installed_pkgs_lst{idx(i)}.name;
     cur_version = installed_pkgs_lst{idx(i)}.version;
     cur_dir = installed_pkgs_lst{idx(i)}.dir;
     if (length (cur_dir) > max_dir_length)
       first_char = length (cur_dir) - max_dir_length + 4;
       first_filesep = strfind (cur_dir(first_char:end), filesep());
       if (! isempty (first_filesep))
         cur_dir = cstrcat ("...", 
-			  cur_dir((first_char + first_filesep(1) - 1):end));
+                          cur_dir((first_char + first_filesep(1) - 1):end));
       else
         cur_dir = cstrcat ("...", cur_dir(first_char:end));
       endif
     endif
     if (installed_pkgs_lst{idx(i)}.loaded)
       cur_loaded = "*";
     else
       cur_loaded = " ";
@@ -2001,26 +2001,26 @@ function load_packages (files, handle_de
   ## Load all.
   if (length (files) == 1 && strcmp (files{1}, "all"))
     idx = [1:length(installed_pkgs_lst)];
   ## Load auto.
   elseif (length (files) == 1 && strcmp (files{1}, "auto")) 
     idx = [];
     for i = 1:length (installed_pkgs_lst)
       if (exist (fullfile (pdirs{i}, "packinfo", ".autoload"), "file"))
-	idx (end + 1) = i;
+        idx (end + 1) = i;
       endif
     endfor
   ## Load package_name1 ...
   else
     idx = [];
     for i = 1:length (files)
       idx2 = find (strcmp (pnames, files{i}));
       if (! any (idx2))
-	  error ("package %s is not installed", files{i});
+          error ("package %s is not installed", files{i});
       endif
       idx (end + 1) = idx2;
     endfor
   endif
 
   ## Load the packages, but take care of the ordering of dependencies.
   load_packages_and_dependencies (idx, handle_deps, installed_pkgs_lst, true);
 endfunction
@@ -2046,19 +2046,19 @@ function unload_packages (files, handle_
     desc = installed_pkgs_lst;
   else
     ## Unload package_name1 ...
     dirs = {};
     desc = {};
     for i = 1:length (files)
       idx = strcmp (pnames, files{i});
       if (! any (idx))
-	error ("package %s is not installed", files{i});
+        error ("package %s is not installed", files{i});
       endif
-	dirs{end+1} = pdirs{idx};
+        dirs{end+1} = pdirs{idx};
         desc{end+1} = installed_pkgs_lst{idx};
       endfor
   endif
 
   ## Check for architecture dependent directories.
   archdirs = {};
   for i = 1:length (dirs)
     tmpdir = getarchdir (desc{i});
@@ -2127,24 +2127,24 @@ function emp = dirempty (nm, ign)
     emp = true;
   else
     emp = true;
   endif
 endfunction
 
 function arch = getarch ()
   persistent _arch = cstrcat (octave_config_info("canonical_host_type"), ...
-			     "-", octave_config_info("api_version"));
+                             "-", octave_config_info("api_version"));
   arch = _arch;
 endfunction
 
 function archprefix = getarchprefix (desc, global_install)
   if ((nargin == 2 && global_install) || (nargin < 2 && issuperuser ()))
     archprefix = fullfile (octave_config_info ("libexecdir"), "octave", 
-			   "packages", cstrcat(desc.name, "-", desc.version));
+                           "packages", cstrcat(desc.name, "-", desc.version));
   else
     archprefix = desc.dir;
   endif
 endfunction
 
 function archdir = getarchdir (desc)
   archdir = fullfile (desc.archprefix, getarch());
 endfunction
@@ -2179,29 +2179,29 @@ function [status, output] = shell (cmd)
   endif
 endfunction
 
 function newdesc = save_order (desc)
   newdesc = {};
   for i = 1 : length(desc)
     deps = desc{i}.depends;
     if (isempty (deps) || (length (deps) == 1 && 
-			  strcmp(deps{1}.package, "octave")))
+                          strcmp(deps{1}.package, "octave")))
       newdesc {end + 1} = desc{i};
     else
       tmpdesc = {};
       for k = 1 : length (deps)
         for j = 1 : length (desc)
           if (strcmp (desc{j}.name, deps{k}.package))
             tmpdesc{end+1} = desc{j};
-	    break;
+            break;
           endif
         endfor
       endfor
-      if (! isempty (tmpdesc))					     
+      if (! isempty (tmpdesc))                                       
         newdesc = {newdesc{:}, save_order(tmpdesc){:}, desc{i}};
       else
         newdesc{end+1} = desc{i};
       endif
     endif
   endfor
   ## Eliminate the duplicates.
   idx = [];
@@ -2211,17 +2211,17 @@ function newdesc = save_order (desc)
         idx (end + 1) = j;
       endif
     endfor
   endfor
   newdesc(idx) = [];
 endfunction
 
 function load_packages_and_dependencies (idx, handle_deps, installed_pkgs_lst,
-					 global_install)
+                                         global_install)
   idx = load_package_dirs (idx, [], handle_deps, installed_pkgs_lst);
   dirs = {};
   execpath = EXEC_PATH ();
   for i = idx;
     ndir = installed_pkgs_lst{i}.dir;
     dirs{end+1} = ndir;
     if (exist (fullfile (dirs{end}, "bin"), "dir"))
       execpath = cstrcat (fullfile (dirs{end}, "bin"), ":", execpath);
@@ -2244,34 +2244,34 @@ function load_packages_and_dependencies 
   if (! strcmp (EXEC_PATH, execpath))
     EXEC_PATH (execpath);
   endif
 endfunction
 
 function idx = load_package_dirs (lidx, idx, handle_deps, installed_pkgs_lst)
   for i = lidx
     if (isfield (installed_pkgs_lst{i}, "loaded") &&
-	installed_pkgs_lst{i}.loaded)
+        installed_pkgs_lst{i}.loaded)
       continue;
     else
       if (handle_deps)
         deps = installed_pkgs_lst{i}.depends;
         if ((length (deps) > 1) || (length (deps) == 1 && 
-	  		  ! strcmp(deps{1}.package, "octave")))
+                          ! strcmp(deps{1}.package, "octave")))
           tmplidx = [];
           for k = 1 : length (deps)
             for j = 1 : length (installed_pkgs_lst)
               if (strcmp (installed_pkgs_lst{j}.name, deps{k}.package))
                 tmplidx (end + 1) = j;
-	        break;
+                break;
               endif
             endfor
           endfor
           idx = load_package_dirs (tmplidx, idx, handle_deps, 
-				 installed_pkgs_lst);
+                                 installed_pkgs_lst);
         endif
       endif
       if (isempty (find(idx == i)))
         idx (end + 1) = i;
       endif
     endif
   endfor
 endfunction
@@ -2286,15 +2286,15 @@ function dep = is_architecture_dependent
       isglob = true;
       ext(end) = [];
     else
       isglob = false;
     endif
     pos = findstr (nm, ext);
     if (pos)
       if (! isglob && (length(nm) - pos(end) != length(ext) - 1))
-	continue;
+        continue;
       endif
       dep = true;
       break;
     endif
   endfor
 endfunction
diff --git a/scripts/plot/__gnuplot_get_var__.m b/scripts/plot/__gnuplot_get_var__.m
--- a/scripts/plot/__gnuplot_get_var__.m
+++ b/scripts/plot/__gnuplot_get_var__.m
@@ -123,18 +123,18 @@ function gp_var_value = __gnuplot_get_va
       ## Direct gnuplot to print to <STDERR>
       fputs (ostream, "set print;\n");
       fflush (ostream);
 
       str = {};
       while (isempty (str))
         str = char (fread (istream)');
         if (isempty (str))
-	  sleep (0.05);
-	else
+          sleep (0.05);
+        else
           str = regexp (str, "OCTAVE:.*", "match");
           str = str{end}(8:end);
         endif
         fclear (istream);
       endwhile
     endif
 
     ## Strip out EOLs and the continuation character "|"
diff --git a/scripts/plot/__gnuplot_ginput__.m b/scripts/plot/__gnuplot_ginput__.m
--- a/scripts/plot/__gnuplot_ginput__.m
+++ b/scripts/plot/__gnuplot_ginput__.m
@@ -76,76 +76,76 @@ function [x, y, button] = __gnuplot_ginp
     k = 0;
     while (true)
       k++;
 
       ## Notes: MOUSE_* can be undefined if user closes gnuplot by "q"
       ## or Alt-F4. Further, this abrupt close also requires the leading
       ## "\n" on the next line.
       if (use_mkfifo)
-	fprintf (ostream, "set print \"%s\";\n", gpin_name);
-	fflush (ostream);
-	[gpin, err] = fopen (gpin_name, "r");
-	if (err != 0)
-	  error ("ginput: Can not open fifo (%s)", msg);
-	endif
-	fputs (ostream, "pause mouse any;\n\n");
-	fputs (ostream, "\nif (exists(\"MOUSE_KEY\") && exists(\"MOUSE_X\")) print MOUSE_X, MOUSE_Y, MOUSE_KEY; else print \"0 0 -1\"\n");
+        fprintf (ostream, "set print \"%s\";\n", gpin_name);
+        fflush (ostream);
+        [gpin, err] = fopen (gpin_name, "r");
+        if (err != 0)
+          error ("ginput: Can not open fifo (%s)", msg);
+        endif
+        fputs (ostream, "pause mouse any;\n\n");
+        fputs (ostream, "\nif (exists(\"MOUSE_KEY\") && exists(\"MOUSE_X\")) print MOUSE_X, MOUSE_Y, MOUSE_KEY; else print \"0 0 -1\"\n");
 
-	## Close output file, to force it to be flushed
-	fputs (ostream, "set print;\n");
-	fflush (ostream);
+        ## Close output file, to force it to be flushed
+        fputs (ostream, "set print;\n");
+        fflush (ostream);
 
-	## Now read from fifo.
-	[x(k), y(k), button(k), count] = fscanf (gpin, "%f %f %d", "C");
-	fclose (gpin);
+        ## Now read from fifo.
+        [x(k), y(k), button(k), count] = fscanf (gpin, "%f %f %d", "C");
+        fclose (gpin);
       else
-	fprintf (ostream, "set print \"-\";\n");
-	fflush (ostream);
-	fputs (ostream, "pause mouse any;\n\n");
-	fputs (ostream, "\nif (exists(\"MOUSE_KEY\") && exists(\"MOUSE_X\")) print \"OCTAVE: \", MOUSE_X, MOUSE_Y, MOUSE_KEY; else print \"0 0 -1\"\n");
+        fprintf (ostream, "set print \"-\";\n");
+        fflush (ostream);
+        fputs (ostream, "pause mouse any;\n\n");
+        fputs (ostream, "\nif (exists(\"MOUSE_KEY\") && exists(\"MOUSE_X\")) print \"OCTAVE: \", MOUSE_X, MOUSE_Y, MOUSE_KEY; else print \"0 0 -1\"\n");
 
-	## Close output file, to force it to be flushed
-	fputs (ostream, "set print;\n");
-	fflush (ostream);
+        ## Close output file, to force it to be flushed
+        fputs (ostream, "set print;\n");
+        fflush (ostream);
 
-	str = {};
-	while (isempty (str))
-	  str = char (fread (istream)');
-	  if (isempty (str))
-	    sleep (0.05);
-	  else
-	    str = regexp (str, 'OCTAVE:\s+[\d.\+-]+\s+[\d.\+-]+\s+\d*', 'match');
-	  endif
-	  fclear (istream);
-	endwhile
+        str = {};
+        while (isempty (str))
+          str = char (fread (istream)');
+          if (isempty (str))
+            sleep (0.05);
+          else
+            str = regexp (str, 'OCTAVE:\s+[\d.\+-]+\s+[\d.\+-]+\s+\d*', 'match');
+          endif
+          fclear (istream);
+        endwhile
         [x(k), y(k), button(k), count] = sscanf (str{end}(8:end), "%f %f %d", "C");
       endif
 
       if ([x(k), y(k), button(k)] == [0, 0, -1])
-	## Mousing not active (no plot yet).
-	break;
+        ## Mousing not active (no plot yet).
+        break;
       endif
 
       if (nargin > 1)
-	## Input argument n was given => stop when k == n.
-	if (k == n) 
-	  break; 
-	endif
+        ## Input argument n was given => stop when k == n.
+        if (k == n) 
+          break; 
+        endif
       else
-	## Input argument n not given => stop when hitting a return key.
-	## if (button(k) == 0x0D || button(k) == 0x0A) 
-	##   ## hit Return or Enter
-	if (button(k) == 0x0D)
-	  ## hit Return
-	  x(k:end) = [];
-	  y(k:end) = [];
-	  button(k:end) = [];
-	  break;
-	endif
+        ## Input argument n not given => stop when hitting a return key.
+        ## if (button(k) == 0x0D || button(k) == 0x0A) 
+        ##   ## hit Return or Enter
+        if (button(k) == 0x0D)
+          ## hit Return
+          x(k:end) = [];
+          y(k:end) = [];
+          button(k:end) = [];
+          break;
+        endif
       endif
     endwhile
 
   unwind_protect_cleanup
     if (use_mkfifo)
       unlink (gpin_name);
     endif
   end_unwind_protect
diff --git a/scripts/plot/__go_draw_axes__.m b/scripts/plot/__go_draw_axes__.m
--- a/scripts/plot/__go_draw_axes__.m
+++ b/scripts/plot/__go_draw_axes__.m
@@ -49,20 +49,20 @@ function __go_draw_axes__ (h, plot_strea
     if (strcmpi (axis_obj.plotboxaspectratiomode, "manual"))
       pos = __actual_axis_position__ (axis_obj);
     else
       pos = axis_obj.position;
       pos = pos - implicit_margin([1, 2, 1, 2]).*[1, 1, -0.5, -0.5];
     endif
     if (__gnuplot_has_feature__ ("screen_coordinates_for_{lrtb}margin"))
       if (nd == 2)
-	x = [1, 1];
+        x = [1, 1];
       else
-	## 3D plots need to be sized down to fit in the window.
-	x = 1.0 ./ sqrt([2, 2.5]);
+        ## 3D plots need to be sized down to fit in the window.
+        x = 1.0 ./ sqrt([2, 2.5]);
       endif
       fprintf (plot_stream, "set tmargin screen %.15g;\n", pos(2)+pos(4)/2+x(2)*pos(4)/2);
       fprintf (plot_stream, "set bmargin screen %.15g;\n", pos(2)+pos(4)/2-x(2)*pos(4)/2);
       fprintf (plot_stream, "set lmargin screen %.15g;\n", pos(1)+pos(3)/2-x(1)*pos(3)/2);
       fprintf (plot_stream, "set rmargin screen %.15g;\n", pos(1)+pos(3)/2+x(1)*pos(3)/2);
     else
       ## FIXME -- nothing should change for gnuplot 4.2.x.
       fprintf (plot_stream, "set tmargin 0;\n");
@@ -89,121 +89,121 @@ function __go_draw_axes__ (h, plot_strea
     fputs (plot_stream, "unset ytics;\n");
     fputs (plot_stream, "unset ztics;\n");
     fputs (plot_stream, "unset x2tics;\n");
     fputs (plot_stream, "unset x2tics;\n");
 
     if (! isempty (axis_obj.title))
       t = get (axis_obj.title);
       if (isempty (t.string))
-	fputs (plot_stream, "unset title;\n");
+        fputs (plot_stream, "unset title;\n");
       else
-	[tt, f, s] = __maybe_munge_text__ (enhanced, t, "string");
-	fontspec = create_fontspec (f, s, gnuplot_term);
-	fprintf (plot_stream, "set title \"%s\" %s %s",
-		 undo_string_escapes (tt), fontspec,
-		 __do_enhanced_option__ (enhanced, t));
-	if (nd == 3 && __gnuplot_has_feature__ ("screen_coordinates_for_{lrtb}margin"))
-	  fprintf (plot_stream, " offset screen 0, screen %.3f;\n", pos(4)/5);
-	else
-	  fprintf (plot_stream, ";\n");
-	endif
+        [tt, f, s] = __maybe_munge_text__ (enhanced, t, "string");
+        fontspec = create_fontspec (f, s, gnuplot_term);
+        fprintf (plot_stream, "set title \"%s\" %s %s",
+                 undo_string_escapes (tt), fontspec,
+                 __do_enhanced_option__ (enhanced, t));
+        if (nd == 3 && __gnuplot_has_feature__ ("screen_coordinates_for_{lrtb}margin"))
+          fprintf (plot_stream, " offset screen 0, screen %.3f;\n", pos(4)/5);
+        else
+          fprintf (plot_stream, ";\n");
+        endif
       endif
     endif
 
     if (! isempty (axis_obj.xlabel))
       t = get (axis_obj.xlabel);
       angle = t.rotation;
       colorspec = get_text_colorspec (axis_obj.xcolor, mono);
       if (isempty (t.string))
-	fprintf (plot_stream, "unset xlabel;\n");
-	fprintf (plot_stream, "unset x2label;\n");
+        fprintf (plot_stream, "unset xlabel;\n");
+        fprintf (plot_stream, "unset x2label;\n");
       else
-	[tt, f, s] = __maybe_munge_text__ (enhanced, t, "string");
-	fontspec = create_fontspec (f, s, gnuplot_term);
-	if (strcmpi (axis_obj.xaxislocation, "top"))
-	  fprintf (plot_stream, "set x2label \"%s\" %s %s %s",
-		   undo_string_escapes (tt), colorspec, fontspec,
-		   __do_enhanced_option__ (enhanced, t));
-	else
-	  fprintf (plot_stream, "set xlabel \"%s\" %s %s %s",
-		   undo_string_escapes (tt), colorspec, fontspec,
-		   __do_enhanced_option__ (enhanced, t));
-	endif
-	fprintf (plot_stream, " rotate by %f;\n", angle);
-	if (strcmpi (axis_obj.xaxislocation, "top"))
-	  fprintf (plot_stream, "unset xlabel;\n");
-	else
-	  fprintf (plot_stream, "unset x2label;\n");
-	endif
+        [tt, f, s] = __maybe_munge_text__ (enhanced, t, "string");
+        fontspec = create_fontspec (f, s, gnuplot_term);
+        if (strcmpi (axis_obj.xaxislocation, "top"))
+          fprintf (plot_stream, "set x2label \"%s\" %s %s %s",
+                   undo_string_escapes (tt), colorspec, fontspec,
+                   __do_enhanced_option__ (enhanced, t));
+        else
+          fprintf (plot_stream, "set xlabel \"%s\" %s %s %s",
+                   undo_string_escapes (tt), colorspec, fontspec,
+                   __do_enhanced_option__ (enhanced, t));
+        endif
+        fprintf (plot_stream, " rotate by %f;\n", angle);
+        if (strcmpi (axis_obj.xaxislocation, "top"))
+          fprintf (plot_stream, "unset xlabel;\n");
+        else
+          fprintf (plot_stream, "unset x2label;\n");
+        endif
       endif
     endif
 
     if (! isempty (axis_obj.ylabel))
       t = get (axis_obj.ylabel);
       angle = t.rotation;
       colorspec = get_text_colorspec (axis_obj.ycolor, mono);
       if (isempty (t.string))
-	fprintf (plot_stream, "unset ylabel;\n");
-	fprintf (plot_stream, "unset y2label;\n");
+        fprintf (plot_stream, "unset ylabel;\n");
+        fprintf (plot_stream, "unset y2label;\n");
       else
-	[tt, f, s] = __maybe_munge_text__ (enhanced, t, "string");
-	fontspec = create_fontspec (f, s, gnuplot_term);
-	if (strcmpi (axis_obj.yaxislocation, "right"))
-	  fprintf (plot_stream, "set y2label \"%s\" %s %s %s",
-		   undo_string_escapes (tt), colorspec, fontspec,
-		   __do_enhanced_option__ (enhanced, t));
-	else
-	  fprintf (plot_stream, "set ylabel \"%s\" %s %s %s",
-		   undo_string_escapes (tt), colorspec, fontspec,
-		   __do_enhanced_option__ (enhanced, t));
-	endif
-	fprintf (plot_stream, " rotate by %f;\n", angle);
-	if (strcmpi (axis_obj.yaxislocation, "right"))
-	  fprintf (plot_stream, "unset ylabel;\n");
-	else
-	  fprintf (plot_stream, "unset y2label;\n");
-	endif
+        [tt, f, s] = __maybe_munge_text__ (enhanced, t, "string");
+        fontspec = create_fontspec (f, s, gnuplot_term);
+        if (strcmpi (axis_obj.yaxislocation, "right"))
+          fprintf (plot_stream, "set y2label \"%s\" %s %s %s",
+                   undo_string_escapes (tt), colorspec, fontspec,
+                   __do_enhanced_option__ (enhanced, t));
+        else
+          fprintf (plot_stream, "set ylabel \"%s\" %s %s %s",
+                   undo_string_escapes (tt), colorspec, fontspec,
+                   __do_enhanced_option__ (enhanced, t));
+        endif
+        fprintf (plot_stream, " rotate by %f;\n", angle);
+        if (strcmpi (axis_obj.yaxislocation, "right"))
+          fprintf (plot_stream, "unset ylabel;\n");
+        else
+          fprintf (plot_stream, "unset y2label;\n");
+        endif
       endif
     endif
 
     if (! isempty (axis_obj.zlabel))
       t = get (axis_obj.zlabel);
       angle = t.rotation;
       colorspec = get_text_colorspec (axis_obj.zcolor, mono);
       if (isempty (t.string))
-	fputs (plot_stream, "unset zlabel;\n");
+        fputs (plot_stream, "unset zlabel;\n");
       else
-	[tt, f, s] = __maybe_munge_text__ (enhanced, t, "string");
-	fontspec = create_fontspec (f, s, gnuplot_term);
-	fprintf (plot_stream, "set zlabel \"%s\" %s %s %s",
-		 undo_string_escapes (tt), colorspec, fontspec,
-		 __do_enhanced_option__ (enhanced, t));
-	fprintf (plot_stream, " rotate by %f;\n", angle);
+        [tt, f, s] = __maybe_munge_text__ (enhanced, t, "string");
+        fontspec = create_fontspec (f, s, gnuplot_term);
+        fprintf (plot_stream, "set zlabel \"%s\" %s %s %s",
+                 undo_string_escapes (tt), colorspec, fontspec,
+                 __do_enhanced_option__ (enhanced, t));
+        fprintf (plot_stream, " rotate by %f;\n", angle);
       endif
     endif
 
     if (strcmpi (axis_obj.xaxislocation, "top"))
       xaxisloc = "x2";
       xaxisloc_using = "x2";
     else
       xaxisloc = "x";
       xaxisloc_using = "x1";
       if (strcmpi (axis_obj.xaxislocation, "zero"))
-	fputs (plot_stream, "set xzeroaxis;\n");
+        fputs (plot_stream, "set xzeroaxis;\n");
       endif
     endif
     if (strcmpi (axis_obj.yaxislocation, "right"))
       yaxisloc = "y2";
       yaxisloc_using = "y2";
     else
       yaxisloc = "y";
       yaxisloc_using = "y1";
       if (strcmpi (axis_obj.yaxislocation, "zero"))
-	fputs (plot_stream, "set yzeroaxis;\n");
+        fputs (plot_stream, "set yzeroaxis;\n");
       endif
     endif
 
     have_grid = false;
 
     if (strcmpi (axis_obj.xgrid, "on"))
       have_grid = true;
       fprintf (plot_stream, "set grid %stics;\n", xaxisloc);
@@ -223,45 +223,45 @@ function __go_draw_axes__ (h, plot_strea
       fputs (plot_stream, "set grid ztics;\n");
     else
       fputs (plot_stream, "set grid noztics;\n");
     endif
 
     if (strcmpi (axis_obj.xminorgrid, "on"))
       have_grid = true;
       if (strcmp (axis_obj.xscale, "log"))
-	m = 10;
+        m = 10;
       else
-	m = 5;
+        m = 5;
       endif
       fprintf (plot_stream, "set m%stics %d;\n", xaxisloc, m);
       fprintf (plot_stream, "set grid m%stics;\n", xaxisloc);
     else
       fprintf (plot_stream, "set grid nom%stics;\n", xaxisloc);
     endif
 
     if (strcmpi (axis_obj.yminorgrid, "on"))
       have_grid = true;
       if (strcmp (axis_obj.yscale, "log"))
-	m = 10;
+        m = 10;
       else
-	m = 5;
+        m = 5;
       endif
       fprintf (plot_stream, "set m%stics %d;\n", yaxisloc, m);
       fprintf (plot_stream, "set grid m%stics;\n", yaxisloc);
     else
       fprintf (plot_stream, "set grid nom%stics;\n", yaxisloc);
     endif
 
     if (strcmpi (axis_obj.zminorgrid, "on"))
       have_grid = true;
       if (strcmp (axis_obj.zscale, "log"))
-	m = 10;
+        m = 10;
       else
-	m = 5;
+        m = 5;
       endif
       fprintf (plot_stream, "set mztics %d;\n", m);
       fputs (plot_stream, "set grid mztics;\n");
     else
       fputs (plot_stream, "set grid nomztics;\n");
     endif
 
     ## The grid front/back/layerdefault option also controls the
@@ -332,980 +332,980 @@ function __go_draw_axes__ (h, plot_strea
 
     if (! cautoscale && clim(1) == clim(2))
       clim(2)++;
     endif
     addedcmap = [];
 
     [view_cmd, view_fcn, view_zoom] = image_viewer ();
     use_gnuplot_for_images = (ischar (view_fcn)
-			      && strcmpi (view_fcn, "gnuplot_internal"));
+                              && strcmpi (view_fcn, "gnuplot_internal"));
 
     ximg_data = {};
     ximg_data_idx = 0;
 
     while (! isempty (kids))
 
       obj = get (kids(end));
       kids = kids(1:(end-1));
 
       if (strcmpi (obj.visible, "off"))
-	continue;
+        continue;
       endif
 
       ## Check for facecolor interpolation for surfaces.
       doing_interp_color = ...
          isfield (obj, "facecolor") && strncmp (obj.facecolor, "interp", 6);
 
       switch (obj.type)
-	case "image"
-	  img_data = obj.cdata;
-	  img_xdata = obj.xdata;
-	  img_ydata = obj.ydata;
+        case "image"
+          img_data = obj.cdata;
+          img_xdata = obj.xdata;
+          img_ydata = obj.ydata;
 
-	  if (use_gnuplot_for_images)
+          if (use_gnuplot_for_images)
 
-	    if (ndims (img_data) == 3)
-	      truecolor = true;
-	    elseif (strcmpi (obj.cdatamapping, "direct"))
-	      cdatadirect = true;
-	    endif
-	    data_idx++;
-	    is_image_data(data_idx) = true;
-	    parametric(data_idx) = false;
-	    have_cdata(data_idx) = false;
-	    have_3d_patch(data_idx) = false;
+            if (ndims (img_data) == 3)
+              truecolor = true;
+            elseif (strcmpi (obj.cdatamapping, "direct"))
+              cdatadirect = true;
+            endif
+            data_idx++;
+            is_image_data(data_idx) = true;
+            parametric(data_idx) = false;
+            have_cdata(data_idx) = false;
+            have_3d_patch(data_idx) = false;
 
-	    [y_dim, x_dim] = size (img_data(:,:,1));
-	    if (x_dim > 1)
-	      dx = abs (img_xdata(2)-img_xdata(1))/(x_dim-1);
-	    else
-	      x_dim = 2;
-	      img_data = [img_data, img_data];
-	      dx = abs (img_xdata(2)-img_xdata(1));
-	    endif
-	    if (y_dim > 1)
-	      dy = abs (img_ydata(2)-img_ydata(1))/(y_dim-1);
-	    else
-	      y_dim = 2;
-	      img_data = [img_data; img_data];
-	      dy = abs (img_ydata(2)-img_ydata(1));
-	    endif
-	    x_origin = min (img_xdata);
-	    y_origin = min (img_ydata);
+            [y_dim, x_dim] = size (img_data(:,:,1));
+            if (x_dim > 1)
+              dx = abs (img_xdata(2)-img_xdata(1))/(x_dim-1);
+            else
+              x_dim = 2;
+              img_data = [img_data, img_data];
+              dx = abs (img_xdata(2)-img_xdata(1));
+            endif
+            if (y_dim > 1)
+              dy = abs (img_ydata(2)-img_ydata(1))/(y_dim-1);
+            else
+              y_dim = 2;
+              img_data = [img_data; img_data];
+              dy = abs (img_ydata(2)-img_ydata(1));
+            endif
+            x_origin = min (img_xdata);
+            y_origin = min (img_ydata);
 
-	    if (ndims (img_data) == 3)
-	      data{data_idx} = permute (img_data, [3, 1, 2])(:);
-	      format = "1:2:3";
-	      imagetype = "rgbimage";
-	    else
-	      data{data_idx} = img_data(:);
-	      format = "1";
-	      imagetype = "image";
-	    endif
+            if (ndims (img_data) == 3)
+              data{data_idx} = permute (img_data, [3, 1, 2])(:);
+              format = "1:2:3";
+              imagetype = "rgbimage";
+            else
+              data{data_idx} = img_data(:);
+              format = "1";
+              imagetype = "image";
+            endif
 
-	    titlespec{data_idx} = "title \"\"";
-	    usingclause{data_idx} = sprintf ("binary array=%dx%d scan=yx origin=(%.15g,%.15g) dx=%.15g dy=%.15g using %s",
-		x_dim, y_dim, x_origin, y_origin, dx, dy, format);
-	    withclause{data_idx} = sprintf ("with %s;", imagetype);
+            titlespec{data_idx} = "title \"\"";
+            usingclause{data_idx} = sprintf ("binary array=%dx%d scan=yx origin=(%.15g,%.15g) dx=%.15g dy=%.15g using %s",
+                x_dim, y_dim, x_origin, y_origin, dx, dy, format);
+            withclause{data_idx} = sprintf ("with %s;", imagetype);
 
-	  else
-	    ximg_data{++ximg_data_idx} = img_data;
-	  endif
+          else
+            ximg_data{++ximg_data_idx} = img_data;
+          endif
 
-	case "line"
-	  if (strncmp (obj.linestyle, "none", 4)
-	      && (! isfield (obj, "marker")
-		  || (isfield (obj, "marker")
-		      && strncmp (obj.marker, "none", 4))))
-	    continue;
-	  endif
-	  data_idx++;
-	  is_image_data(data_idx) = false;
-	  parametric(data_idx) = true;
-	  have_cdata(data_idx) = false;
-	  have_3d_patch(data_idx) = false;
+        case "line"
+          if (strncmp (obj.linestyle, "none", 4)
+              && (! isfield (obj, "marker")
+                  || (isfield (obj, "marker")
+                      && strncmp (obj.marker, "none", 4))))
+            continue;
+          endif
+          data_idx++;
+          is_image_data(data_idx) = false;
+          parametric(data_idx) = true;
+          have_cdata(data_idx) = false;
+          have_3d_patch(data_idx) = false;
 
-	  if (isempty (obj.keylabel))
-	    titlespec{data_idx} = "title \"\"";
-	  else
-	    tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "keylabel"));
-	    titlespec{data_idx} = cstrcat ("title \"", tmp, "\"");
-	  endif
-	  usingclause{data_idx} = sprintf ("record=%d", numel (obj.xdata));
-	  errbars = "";
-	  if (nd == 3)
-	    xdat = obj.xdata(:);
-	    ydat = obj.ydata(:);
-	    if (! isempty (obj.zdata))
-	      zdat = obj.zdata(:);
-	    else
-	      zdat = zeros (size (xdat));
-	    endif
-	    data{data_idx} = [xdat, ydat, zdat]';
-	    usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3)", numel (xdat));
-	    ## fputs (plot_stream, "set parametric;\n");
-	  else
-	    xdat = obj.xdata(:);
-	    ydat = obj.ydata(:);
-	    ldat = obj.ldata;
-	    yerr = xerr = false;
-	    if (! isempty (ldat))
-	      yerr = true;
-	      ldat = ldat(:);
-	    endif
-	    udat = obj.udata;
-	    if (! isempty (udat))
-	      udat = udat(:);
-	    endif
-	    xldat = obj.xldata;
-	    if (! isempty (xldat))
-	      xerr = true;
-	      xldat = xldat(:);
-	    endif
-	    xudat = obj.xudata;
-	    if (! isempty (xudat))
-	      xudat = xudat(:);
-	    endif
-	    if (yerr)
-	      if (isempty (ldat))
-		ylo = ydat;
-	      else
-		ylo = ydat-ldat;
-	      endif
-	      if (isempty (udat))
-		yhi = ydat;
-	      else
-		yhi = ydat+udat;
-	      endif
-	      if (xerr)
-		if (isempty (xldat))
-		  xlo = xdat;
-		else
-		  xlo = xdat-xldat;
-		endif
-		if (isempty (xudat))
-		  xhi = xdat;
-		else
-		  xhi = xdat+xudat;
-		endif
-		data{data_idx} = [xdat, ydat, xlo, xhi, ylo, yhi]';
-		usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3):($4):($5):($6)", numel (xdat));
-		errbars = "xyerrorbars";
-	      else
-		data{data_idx} = [xdat, ydat, ylo, yhi]';
-		usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3):($4)", numel (xdat));
-		errbars = "yerrorbars";
-	      endif
-	    elseif (xerr)
-	      if (isempty (xldat))
-		xlo = xdat;
-	      else
-		xlo = xdat-xldat;
-	      endif
-	      if (isempty (xudat))
-		xhi = xdat;
-	      else
-		xhi = xdat+xudat;
-	      endif
-	      data{data_idx} = [xdat, ydat, xlo, xhi]';
-	      usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3):($4)", numel (xdat));
-	      errbars = "xerrorbars";
-	    else
-	      data{data_idx} = [xdat, ydat]';
-	      usingclause{data_idx} = sprintf ("record=%d using ($1):($2) axes %s%s",
-					      rows(xdat), xaxisloc_using, yaxisloc_using);
-	    endif
-	  endif
+          if (isempty (obj.keylabel))
+            titlespec{data_idx} = "title \"\"";
+          else
+            tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "keylabel"));
+            titlespec{data_idx} = cstrcat ("title \"", tmp, "\"");
+          endif
+          usingclause{data_idx} = sprintf ("record=%d", numel (obj.xdata));
+          errbars = "";
+          if (nd == 3)
+            xdat = obj.xdata(:);
+            ydat = obj.ydata(:);
+            if (! isempty (obj.zdata))
+              zdat = obj.zdata(:);
+            else
+              zdat = zeros (size (xdat));
+            endif
+            data{data_idx} = [xdat, ydat, zdat]';
+            usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3)", numel (xdat));
+            ## fputs (plot_stream, "set parametric;\n");
+          else
+            xdat = obj.xdata(:);
+            ydat = obj.ydata(:);
+            ldat = obj.ldata;
+            yerr = xerr = false;
+            if (! isempty (ldat))
+              yerr = true;
+              ldat = ldat(:);
+            endif
+            udat = obj.udata;
+            if (! isempty (udat))
+              udat = udat(:);
+            endif
+            xldat = obj.xldata;
+            if (! isempty (xldat))
+              xerr = true;
+              xldat = xldat(:);
+            endif
+            xudat = obj.xudata;
+            if (! isempty (xudat))
+              xudat = xudat(:);
+            endif
+            if (yerr)
+              if (isempty (ldat))
+                ylo = ydat;
+              else
+                ylo = ydat-ldat;
+              endif
+              if (isempty (udat))
+                yhi = ydat;
+              else
+                yhi = ydat+udat;
+              endif
+              if (xerr)
+                if (isempty (xldat))
+                  xlo = xdat;
+                else
+                  xlo = xdat-xldat;
+                endif
+                if (isempty (xudat))
+                  xhi = xdat;
+                else
+                  xhi = xdat+xudat;
+                endif
+                data{data_idx} = [xdat, ydat, xlo, xhi, ylo, yhi]';
+                usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3):($4):($5):($6)", numel (xdat));
+                errbars = "xyerrorbars";
+              else
+                data{data_idx} = [xdat, ydat, ylo, yhi]';
+                usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3):($4)", numel (xdat));
+                errbars = "yerrorbars";
+              endif
+            elseif (xerr)
+              if (isempty (xldat))
+                xlo = xdat;
+              else
+                xlo = xdat-xldat;
+              endif
+              if (isempty (xudat))
+                xhi = xdat;
+              else
+                xhi = xdat+xudat;
+              endif
+              data{data_idx} = [xdat, ydat, xlo, xhi]';
+              usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3):($4)", numel (xdat));
+              errbars = "xerrorbars";
+            else
+              data{data_idx} = [xdat, ydat]';
+              usingclause{data_idx} = sprintf ("record=%d using ($1):($2) axes %s%s",
+                                              rows(xdat), xaxisloc_using, yaxisloc_using);
+            endif
+          endif
 
-	  style = do_linestyle_command (obj, obj.color, data_idx, mono, 
-					plot_stream, errbars);
+          style = do_linestyle_command (obj, obj.color, data_idx, mono, 
+                                        plot_stream, errbars);
 
           withclause{data_idx} = sprintf ("with %s linestyle %d",
-					  style{1}, data_idx);
+                                          style{1}, data_idx);
 
-	  if (length (style) > 1)
-	    data_idx++;
-	    is_image_data(data_idx) = is_image_data(data_idx - 1); 
-	    parametric(data_idx) = parametric(data_idx - 1);
-	    have_cdata(data_idx) = have_cdata(data_idx - 1);
-	    have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
-	    titlespec{data_idx} = "title \"\"";
-	    usingclause{data_idx} = usingclause{data_idx - 1};
-	    data{data_idx} = data{data_idx - 1};
-	    withclause{data_idx} = sprintf ("with %s linestyle %d",
-					  style{2}, data_idx);
-	  endif
-	  if (length (style) > 2)
-	    data_idx++;
-	    is_image_data(data_idx) = is_image_data(data_idx - 1); 
-	    parametric(data_idx) = parametric(data_idx - 1);
-	    have_cdata(data_idx) = have_cdata(data_idx - 1);
-	    have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
-	    titlespec{data_idx} = "title \"\"";
-	    usingclause{data_idx} = usingclause{data_idx - 1};
-	    data{data_idx} = data{data_idx - 1};
-	    withclause{data_idx} = sprintf ("with %s linestyle %d",
-					  style{3}, data_idx);
-	  endif
+          if (length (style) > 1)
+            data_idx++;
+            is_image_data(data_idx) = is_image_data(data_idx - 1); 
+            parametric(data_idx) = parametric(data_idx - 1);
+            have_cdata(data_idx) = have_cdata(data_idx - 1);
+            have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
+            titlespec{data_idx} = "title \"\"";
+            usingclause{data_idx} = usingclause{data_idx - 1};
+            data{data_idx} = data{data_idx - 1};
+            withclause{data_idx} = sprintf ("with %s linestyle %d",
+                                          style{2}, data_idx);
+          endif
+          if (length (style) > 2)
+            data_idx++;
+            is_image_data(data_idx) = is_image_data(data_idx - 1); 
+            parametric(data_idx) = parametric(data_idx - 1);
+            have_cdata(data_idx) = have_cdata(data_idx - 1);
+            have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
+            titlespec{data_idx} = "title \"\"";
+            usingclause{data_idx} = usingclause{data_idx - 1};
+            data{data_idx} = data{data_idx - 1};
+            withclause{data_idx} = sprintf ("with %s linestyle %d",
+                                          style{3}, data_idx);
+          endif
 
        case "patch"
          cmap = parent_figure_obj.colormap;
-	 [nr, nc] = size (obj.xdata);
-
-	 if (! isempty (obj.cdata))
-	   cdat = obj.cdata;
-	   if (strcmpi (obj.cdatamapping, "direct"))
-	     cdatadirect = true;
-	   endif
-	 else
-	   cdat = [];
-	 endif
+         [nr, nc] = size (obj.xdata);
 
-	 data_3d_idx = NaN;
-	 for i = 1:nc
-	   xcol = obj.xdata(:,i);
-	   ycol = obj.ydata(:,i);
-	   if (nd == 3)
-	     if (! isempty (obj.zdata))
-	       zcol = obj.zdata(:,i);
-	     else
-	       zcol = zeros (size (xcol));
-	     endif
-	   endif
-
-	   if (! isnan (xcol) && ! isnan (ycol))
-	     ## Is the patch closed or not
-	     if (strncmp (obj.facecolor, "none", 4)) 
-	       hidden_removal = false;
-	     else
+         if (! isempty (obj.cdata))
+           cdat = obj.cdata;
+           if (strcmpi (obj.cdatamapping, "direct"))
+             cdatadirect = true;
+           endif
+         else
+           cdat = [];
+         endif
 
-	       if (isnan (hidden_removal))
-		 hidden_removal = true;
-	       endif
-	       if (nd == 3)
-		 if (numel (xcol) > 3)
-		   error ("gnuplot (as of v4.2) only supports 3D filled triangular patches");
-		 else
-		   if (isnan (data_3d_idx))
-		     data_idx++;
-		     data_3d_idx = data_idx; 
-		     is_image_data(data_idx) = false;
-		     parametric(data_idx) = false;
-		     have_cdata(data_idx) = true;
-		     have_3d_patch(data_idx) = true;
-		     withclause{data_3d_idx} = sprintf ("with pm3d");
-		     usingclause{data_3d_idx} =  "using 1:2:3:4";
-		     data{data_3d_idx} = [];
-		   endif
-		   local_idx = data_3d_idx;
-		   ccdat = NaN;
-		 endif
-	       else
-		 data_idx++;
-		 local_idx = data_idx;
-		 is_image_data(data_idx) = false;
-		 parametric(data_idx) = false;
-		 have_cdata(data_idx) = false;
-		 have_3d_patch(data_idx) = false;
-	       endif
+         data_3d_idx = NaN;
+         for i = 1:nc
+           xcol = obj.xdata(:,i);
+           ycol = obj.ydata(:,i);
+           if (nd == 3)
+             if (! isempty (obj.zdata))
+               zcol = obj.zdata(:,i);
+             else
+               zcol = zeros (size (xcol));
+             endif
+           endif
+
+           if (! isnan (xcol) && ! isnan (ycol))
+             ## Is the patch closed or not
+             if (strncmp (obj.facecolor, "none", 4)) 
+               hidden_removal = false;
+             else
 
-	       if (i > 1 || isempty (obj.keylabel))
-		 titlespec{local_idx} = "title \"\"";
-	       else
-		 tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "keylabel"));
-		 titlespec{local_idx} = cstrcat ("title \"", tmp, "\"");
-	       endif
-               if (isfield (obj, "facecolor"))
-		 if ((strncmp (obj.facecolor, "flat", 4)
-		     || strncmp (obj.facecolor, "interp", 6))
-		     && isfield (obj, "cdata"))
-		   if (ndims (obj.cdata) == 2
-		       && (size (obj.cdata, 2) == nc
-			   && (size (obj.cdata, 1) == 1
-			       || size (obj.cdata, 1) == 3)))
-		     ccol = cdat (:, i);
-		   elseif (ndims (obj.cdata) == 2
-		       && (size (obj.cdata, 1) == nc
-			   && (size (obj.cdata, 2) == 1
-			       || size (obj.cdata, 2) == 3)))
-		     ccol = cdat (i, :);
-		   elseif (ndims (obj.cdata) == 3)
-		     ccol = permute (cdat (:, i, :), [1, 3, 2]);
-		   else
-		     ccol = cdat;
-		   endif
-		   if (strncmp (obj.facecolor, "flat", 4))
-		     if (numel(ccol) == 3)
-		       color = ccol;
-		     elseif (nd == 3 && numel (xcol) == 3)
-		       ccdat = ccol * ones (3,1);
-		     else
-		       r = 1 + round ((size (cmap, 1) - 1)
-				      * (ccol - clim(1))/(clim(2) - clim(1)));
-		       r = max (1, min (r, size (cmap, 1)));
-		       color = cmap(r, :);
-		     endif
-		   elseif (strncmp (obj.facecolor, "interp", 6))
-		     if (nd == 3 && numel (xcol) == 3)
-		       ccdat = ccol;
-		       if (! isvector (ccdat))
-			 tmp = rows(cmap) + rows(addedcmap) + ... 
-			      [1 : rows(ccdat)];
-			 addedcmap = [addedcmap; ccdat];
-			 ccdat = tmp(:);
-		       else
-			 ccdat = ccdat(:);
-		       endif
-		     else
-		       warning ("\"interp\" not supported, using 1st entry of cdata");
-		       r = 1 + round ((size (cmap, 1) - 1) * ccol(1));
-		       r = max (1, min (r, size (cmap, 1)));
-		       color = cmap(r,:);
-		     endif
-		   endif
-		 elseif (isnumeric (obj.facecolor))
-		   color = obj.facecolor;
-		 else
-		   color = [0, 1, 0];
-		 endif
+               if (isnan (hidden_removal))
+                 hidden_removal = true;
+               endif
+               if (nd == 3)
+                 if (numel (xcol) > 3)
+                   error ("gnuplot (as of v4.2) only supports 3D filled triangular patches");
+                 else
+                   if (isnan (data_3d_idx))
+                     data_idx++;
+                     data_3d_idx = data_idx; 
+                     is_image_data(data_idx) = false;
+                     parametric(data_idx) = false;
+                     have_cdata(data_idx) = true;
+                     have_3d_patch(data_idx) = true;
+                     withclause{data_3d_idx} = sprintf ("with pm3d");
+                     usingclause{data_3d_idx} =  "using 1:2:3:4";
+                     data{data_3d_idx} = [];
+                   endif
+                   local_idx = data_3d_idx;
+                   ccdat = NaN;
+                 endif
                else
-		 color = [0, 1, 0];
+                 data_idx++;
+                 local_idx = data_idx;
+                 is_image_data(data_idx) = false;
+                 parametric(data_idx) = false;
+                 have_cdata(data_idx) = false;
+                 have_3d_patch(data_idx) = false;
                endif
 
-	       if (nd == 3 && numel (xcol) == 3)
-		 if (isnan (ccdat))
-		   ccdat = (rows (cmap) + rows(addedcmap) + 1) * ones(3, 1);
-		   addedcmap = [addedcmap; reshape(color, 1, 3)];
-		 endif
-		 data{data_3d_idx} = [data{data_3d_idx}, ...
-				      [[xcol; xcol(end)], [ycol; ycol(end)], ...
-				      [zcol; zcol(end)], [ccdat; ccdat(end)]]'];
-	       else
-		 if (mono)
-		   colorspec = "";
-		 elseif (__gnuplot_has_feature__ ("transparent_patches")
-			 && isscalar (obj.facealpha))
+               if (i > 1 || isempty (obj.keylabel))
+                 titlespec{local_idx} = "title \"\"";
+               else
+                 tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "keylabel"));
+                 titlespec{local_idx} = cstrcat ("title \"", tmp, "\"");
+               endif
+               if (isfield (obj, "facecolor"))
+                 if ((strncmp (obj.facecolor, "flat", 4)
+                     || strncmp (obj.facecolor, "interp", 6))
+                     && isfield (obj, "cdata"))
+                   if (ndims (obj.cdata) == 2
+                       && (size (obj.cdata, 2) == nc
+                           && (size (obj.cdata, 1) == 1
+                               || size (obj.cdata, 1) == 3)))
+                     ccol = cdat (:, i);
+                   elseif (ndims (obj.cdata) == 2
+                       && (size (obj.cdata, 1) == nc
+                           && (size (obj.cdata, 2) == 1
+                               || size (obj.cdata, 2) == 3)))
+                     ccol = cdat (i, :);
+                   elseif (ndims (obj.cdata) == 3)
+                     ccol = permute (cdat (:, i, :), [1, 3, 2]);
+                   else
+                     ccol = cdat;
+                   endif
+                   if (strncmp (obj.facecolor, "flat", 4))
+                     if (numel(ccol) == 3)
+                       color = ccol;
+                     elseif (nd == 3 && numel (xcol) == 3)
+                       ccdat = ccol * ones (3,1);
+                     else
+                       r = 1 + round ((size (cmap, 1) - 1)
+                                      * (ccol - clim(1))/(clim(2) - clim(1)));
+                       r = max (1, min (r, size (cmap, 1)));
+                       color = cmap(r, :);
+                     endif
+                   elseif (strncmp (obj.facecolor, "interp", 6))
+                     if (nd == 3 && numel (xcol) == 3)
+                       ccdat = ccol;
+                       if (! isvector (ccdat))
+                         tmp = rows(cmap) + rows(addedcmap) + ... 
+                              [1 : rows(ccdat)];
+                         addedcmap = [addedcmap; ccdat];
+                         ccdat = tmp(:);
+                       else
+                         ccdat = ccdat(:);
+                       endif
+                     else
+                       warning ("\"interp\" not supported, using 1st entry of cdata");
+                       r = 1 + round ((size (cmap, 1) - 1) * ccol(1));
+                       r = max (1, min (r, size (cmap, 1)));
+                       color = cmap(r,:);
+                     endif
+                   endif
+                 elseif (isnumeric (obj.facecolor))
+                   color = obj.facecolor;
+                 else
+                   color = [0, 1, 0];
+                 endif
+               else
+                 color = [0, 1, 0];
+               endif
+
+               if (nd == 3 && numel (xcol) == 3)
+                 if (isnan (ccdat))
+                   ccdat = (rows (cmap) + rows(addedcmap) + 1) * ones(3, 1);
+                   addedcmap = [addedcmap; reshape(color, 1, 3)];
+                 endif
+                 data{data_3d_idx} = [data{data_3d_idx}, ...
+                                      [[xcol; xcol(end)], [ycol; ycol(end)], ...
+                                      [zcol; zcol(end)], [ccdat; ccdat(end)]]'];
+               else
+                 if (mono)
+                   colorspec = "";
+                 elseif (__gnuplot_has_feature__ ("transparent_patches")
+                         && isscalar (obj.facealpha))
                    colorspec = sprintf ("lc rgb \"#%02x%02x%02x\" fillstyle transparent solid %f",
-				      round (255*color), obj.facealpha);
-		 else
-		   colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
-					round (255*color));
-		 endif
+                                      round (255*color), obj.facealpha);
+                 else
+                   colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
+                                        round (255*color));
+                 endif
 
-		 withclause{data_idx} = sprintf ("with filledcurve %s",
-					       colorspec);
-		 data{data_idx} = [xcol, ycol]';
-		 usingclause{data_idx} = sprintf ("record=%d using ($1):($2)",
-						  numel (xcol));
-	       endif
-	     endif
-	   endif
+                 withclause{data_idx} = sprintf ("with filledcurve %s",
+                                               colorspec);
+                 data{data_idx} = [xcol, ycol]';
+                 usingclause{data_idx} = sprintf ("record=%d using ($1):($2)",
+                                                  numel (xcol));
+               endif
+             endif
+           endif
 
            ## patch outline
-	   if (!(strncmp (obj.edgecolor, "none", 4)
+           if (!(strncmp (obj.edgecolor, "none", 4)
                   && strncmp (obj.markeredgecolor, "none", 4)
                   && strncmp (obj.markerfacecolor, "none", 4)))
 
-	     data_idx++;
+             data_idx++;
              is_image_data(data_idx) = false;
              parametric(data_idx) = false;
-	     have_cdata(data_idx) = false;
-	     have_3d_patch(data_idx) = false;
+             have_cdata(data_idx) = false;
+             have_3d_patch(data_idx) = false;
              titlespec{data_idx} = "title \"\"";
-	     usingclause{data_idx} = sprintf ("record=%d", numel (obj.xdata));
+             usingclause{data_idx} = sprintf ("record=%d", numel (obj.xdata));
 
-	     if (isfield (obj, "markersize"))
-	       mdat = obj.markersize / 3;
-	     endif
+             if (isfield (obj, "markersize"))
+               mdat = obj.markersize / 3;
+             endif
 
              if (isfield (obj, "edgecolor"))
                ## FIXME
                ## This is the wrong thing to do as edgecolor, markeredgecolor
                ## and markerfacecolor can have different values and we should
                ## treat them seperately. However, the below allow the scatter
                ## functions to work as expected, where only one of these values
                ## is set
-	       if (strncmp (obj.edgecolor, "none", 4))
+               if (strncmp (obj.edgecolor, "none", 4))
                  if (strncmp (obj.markeredgecolor, "none", 4))
                    ec = obj.markerfacecolor;
                  else
                    ec = obj.markeredgecolor;
                  endif
                else
                  ec = obj.edgecolor;
                endif
 
-	       if ((strncmp (ec, "flat", 4)
-		    || strncmp (ec, "interp", 6))
-		   && isfield (obj, "cdata"))
-		 if (ndims (obj.cdata) == 2
-		     && (size (obj.cdata, 2) == nc
-			 && (size (obj.cdata, 1) == 1
-			     || size (obj.cdata, 1) == 3)))
-		   ccol = cdat (:, i);
-		 elseif (ndims (obj.cdata) == 2
-			 && (size (obj.cdata, 1) == nc
-			     && (size (obj.cdata, 2) == 1
-				 || size (obj.cdata, 2) == 3)))
-		   ccol = cdat (i, :);
-		 elseif (ndims (obj.cdata) == 3)
-		   ccol = permute (cdat (:, i, :), [1, 3, 2]);
-		 else
-		   ccol = cdat;
-		 endif
-		 if (strncmp (ec, "flat", 4))
-		   if (numel(ccol) == 3)
-		     color = ccol;
-		   else
+               if ((strncmp (ec, "flat", 4)
+                    || strncmp (ec, "interp", 6))
+                   && isfield (obj, "cdata"))
+                 if (ndims (obj.cdata) == 2
+                     && (size (obj.cdata, 2) == nc
+                         && (size (obj.cdata, 1) == 1
+                             || size (obj.cdata, 1) == 3)))
+                   ccol = cdat (:, i);
+                 elseif (ndims (obj.cdata) == 2
+                         && (size (obj.cdata, 1) == nc
+                             && (size (obj.cdata, 2) == 1
+                                 || size (obj.cdata, 2) == 3)))
+                   ccol = cdat (i, :);
+                 elseif (ndims (obj.cdata) == 3)
+                   ccol = permute (cdat (:, i, :), [1, 3, 2]);
+                 else
+                   ccol = cdat;
+                 endif
+                 if (strncmp (ec, "flat", 4))
+                   if (numel(ccol) == 3)
+                     color = ccol;
+                   else
                      if (isscalar (ccol))
                        ccol = repmat(ccol, numel (xcol), 1);
                      endif
                      color = "flat";
-	             have_cdata(data_idx) = true;
-		   endif
-		 elseif (strncmp (ec, "interp", 6))
-		   if (numel(ccol) == 3)
-		     warning ("\"interp\" not supported, using 1st entry of cdata");
-		     color = ccol(1,:);
-		   else
+                     have_cdata(data_idx) = true;
+                   endif
+                 elseif (strncmp (ec, "interp", 6))
+                   if (numel(ccol) == 3)
+                     warning ("\"interp\" not supported, using 1st entry of cdata");
+                     color = ccol(1,:);
+                   else
                      if (isscalar (ccol))
                        ccol = repmat(ccol, numel (xcol), 1);
                      endif
                      color = "interp";
-	             have_cdata(data_idx) = true;
+                     have_cdata(data_idx) = true;
                    endif
-		 endif
-	       elseif (isnumeric (ec))
-		 color = ec;
-	       else
-		 color = [0, 0, 0];
-	       endif
+                 endif
+               elseif (isnumeric (ec))
+                 color = ec;
+               else
+                 color = [0, 0, 0];
+               endif
              else
-	       color = [0, 0, 0];
+               color = [0, 0, 0];
+             endif
+
+             if (isfield (obj, "linestyle"))
+               switch (obj.linestyle)
+                 case "-"
+                   lt = "lt 1";
+                 case "--"
+                   lt = "lt 2";
+                 case ":"
+                   lt = "lt 3";
+                 case "-."
+                   lt = "lt 6";
+                 case "none"
+                   lt = "";
+                 otherwise
+                   lt = "";
+               endswitch
+             else
+               lt = "";
+             endif
+
+             if (isfield (obj, "linewidth"))
+               lw = sprintf("linewidth %f", obj.linewidth);
+             else
+               lw  = "";
              endif
 
-	     if (isfield (obj, "linestyle"))
-	       switch (obj.linestyle)
-		 case "-"
-		   lt = "lt 1";
-		 case "--"
-		   lt = "lt 2";
-		 case ":"
-		   lt = "lt 3";
-		 case "-."
-		   lt = "lt 6";
-		 case "none"
-		   lt = "";
-		 otherwise
-		   lt = "";
-	       endswitch
-	     else
-	       lt = "";
-	     endif
-
-	     if (isfield (obj, "linewidth"))
-	       lw = sprintf("linewidth %f", obj.linewidth);
-	     else
-	       lw  = "";
-	     endif
-
-	     if (isfield (obj, "marker"))
-	       if (isfield (obj, "marker"))
-		 switch (obj.marker)
-		   case "+"
-		     pt = pt2 = "pt 1";
-		   case "o"
-		     pt = "pt 6";
+             if (isfield (obj, "marker"))
+               if (isfield (obj, "marker"))
+                 switch (obj.marker)
+                   case "+"
+                     pt = pt2 = "pt 1";
+                   case "o"
+                     pt = "pt 6";
                      pt2 = "pt 7";
-		   case "*"
-		     pt = pt2 = "pt 3";
-		   case "."
-		     pt = pt2 = "pt 0";
-		   case "x"
-		     pt = pt2 = "pt 2";
-		   case {"square", "s"}
-		     pt = "pt 4";
-		     pt2 = "pt 5";
-		   case {"diamond", "d"}
-		     pt = "pt 13";
-		     pt2 = "pt 14";
-		   case "^"
-		     pt = "pt 8";
-		     pt2 = "pt 9";
-		   case "v"
-		     pt = "pt 10";
-		     pt2 = "pt 11";
-		   case ">"
-	             ## FIXME missing point type 
-		     pt = "pt 8";
-		     pt2 = "pt 9";
-		   case "<"
-	             ## FIXME missing point type 
-		     pt = "pt 10";
-		     pt2 = "pt 11";
-		   case {"pentagram", "p"}
-	             ## FIXME missing point type 
-		     pt = pt2 = "pt 3";
-		   case {"hexagram", "h"}
-		     pt = pt2 = "pt 3";
-		   case "none"
-		     pt = pt2 = "";
-		   otherwise
-		     pt = pt2 = "";
-		 endswitch
-	       endif
-	     else
-	       pt = pt2 = "";
-	     endif
+                   case "*"
+                     pt = pt2 = "pt 3";
+                   case "."
+                     pt = pt2 = "pt 0";
+                   case "x"
+                     pt = pt2 = "pt 2";
+                   case {"square", "s"}
+                     pt = "pt 4";
+                     pt2 = "pt 5";
+                   case {"diamond", "d"}
+                     pt = "pt 13";
+                     pt2 = "pt 14";
+                   case "^"
+                     pt = "pt 8";
+                     pt2 = "pt 9";
+                   case "v"
+                     pt = "pt 10";
+                     pt2 = "pt 11";
+                   case ">"
+                     ## FIXME missing point type 
+                     pt = "pt 8";
+                     pt2 = "pt 9";
+                   case "<"
+                     ## FIXME missing point type 
+                     pt = "pt 10";
+                     pt2 = "pt 11";
+                   case {"pentagram", "p"}
+                     ## FIXME missing point type 
+                     pt = pt2 = "pt 3";
+                   case {"hexagram", "h"}
+                     pt = pt2 = "pt 3";
+                   case "none"
+                     pt = pt2 = "";
+                   otherwise
+                     pt = pt2 = "";
+                 endswitch
+               endif
+             else
+               pt = pt2 = "";
+             endif
 
-	     if (mono)
-	       colorspec = "";
-	     else
+             if (mono)
+               colorspec = "";
+             else
                if (ischar (color))
                  colorspec = "palette";
                else
-	         colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
-				      round (255*color));
+                 colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
+                                      round (255*color));
                endif
-	     endif
+             endif
 
              sidx = 1;
              if (isempty (lt))
                style = "";
              else
                style = "lines";
              endif
              tmpwith = {};
 
              facesame = true;
              if (! isequal (pt, pt2) && isfield (obj, "markerfacecolor") 
-	         && !strncmp (obj.markerfacecolor, "none", 4))
+                 && !strncmp (obj.markerfacecolor, "none", 4))
                if (strncmp (obj.markerfacecolor, "auto", 4)
-	           || ! isnumeric (obj.markerfacecolor) 
-	           || (isnumeric (obj.markerfacecolor) 
-	               && isequal (color, obj.markerfacecolor)))
-	         style = strcat (style, "points");
-	         if (isfield (obj, "markersize"))
-	           if (length (mdat) == nc)
-		     m = mdat(i);
-	           else
-		     m = mdat;
-	           endif
-		   ps = sprintf("pointsize %f", m / 3);
+                   || ! isnumeric (obj.markerfacecolor) 
+                   || (isnumeric (obj.markerfacecolor) 
+                       && isequal (color, obj.markerfacecolor)))
+                 style = strcat (style, "points");
+                 if (isfield (obj, "markersize"))
+                   if (length (mdat) == nc)
+                     m = mdat(i);
+                   else
+                     m = mdat;
+                   endif
+                   ps = sprintf("pointsize %f", m / 3);
                  else
                    ps = "";
-	         endif
+                 endif
 
-	         tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
-					  style, lw, pt2, lt, ps, 
-					  colorspec);
+                 tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
+                                          style, lw, pt2, lt, ps, 
+                                          colorspec);
                else
-	         facesame = false;
-	         if (! isempty (style))	
-	           tmpwith{sidx} = sprintf ("with %s %s %s %s",
-					    style, lw, lt, 
-					    colorspec);
-	           sidx ++;
-	         endif
-	         if (isnumeric (obj.markerfacecolor) && ! mono)
-	           colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
-				        round (255*obj.markerfacecolor));
-	         endif
-	         style = "points";
-	         if (isfield (obj, "markersize"))
-	           if (length (mdat) == nc)
-		     m = mdat(i);
-	           else
-		     m = mdat;
-	           endif
-		   ps = sprintf("pointsize %f", m / 3);
+                 facesame = false;
+                 if (! isempty (style)) 
+                   tmpwith{sidx} = sprintf ("with %s %s %s %s",
+                                            style, lw, lt, 
+                                            colorspec);
+                   sidx ++;
+                 endif
+                 if (isnumeric (obj.markerfacecolor) && ! mono)
+                   colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
+                                        round (255*obj.markerfacecolor));
+                 endif
+                 style = "points";
+                 if (isfield (obj, "markersize"))
+                   if (length (mdat) == nc)
+                     m = mdat(i);
+                   else
+                     m = mdat;
+                   endif
+                   ps = sprintf("pointsize %f", m / 3);
                  else
                    ps = "";
-	         endif
-	         tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
-					  style, lw, pt2, lt, ps, 
-					  colorspec);
+                 endif
+                 tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
+                                          style, lw, pt2, lt, ps, 
+                                          colorspec);
                endif
              endif
 
              if (isfield (obj, "markeredgecolor") 
-	         && !strncmp (obj.markeredgecolor, "none", 4))
+                 && !strncmp (obj.markeredgecolor, "none", 4))
                if (facesame && !isempty (pt) 
                    && (strncmp (obj.markeredgecolor, "auto", 4)
-		       || ! isnumeric (obj.markeredgecolor) 
-		       || (isnumeric (obj.markeredgecolor) 
-			   && isequal (color, obj.markeredgecolor))))
-	         if (sidx == 1 && ((length (style) == 5 
-	                  && strncmp (style, "lines", 5)) 
+                       || ! isnumeric (obj.markeredgecolor) 
+                       || (isnumeric (obj.markeredgecolor) 
+                           && isequal (color, obj.markeredgecolor))))
+                 if (sidx == 1 && ((length (style) == 5 
+                          && strncmp (style, "lines", 5)) 
                          || isempty (style)))
-	           style = strcat (style, "points");
-	           if (isfield (obj, "markersize"))
-	             if (length (mdat) == nc)
-		       m = mdat(i);
-	             else
-		       m = mdat;
-	             endif
-		     ps = sprintf("pointsize %f", m / 3);
+                   style = strcat (style, "points");
+                   if (isfield (obj, "markersize"))
+                     if (length (mdat) == nc)
+                       m = mdat(i);
+                     else
+                       m = mdat;
+                     endif
+                     ps = sprintf("pointsize %f", m / 3);
                    else
                      ps = "";
-	           endif
-	           tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
-					    style, lw, pt, lt, ps, 
-					    colorspec);
-	         endif
+                   endif
+                   tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
+                                            style, lw, pt, lt, ps, 
+                                            colorspec);
+                 endif
                else
-	         if (!isempty (style))	
+                 if (!isempty (style))  
                    if (length(tmpwith) < sidx || isempty (tmpwith{sidx}))
-	             tmpwith{sidx} = sprintf ("with %s %s %s %s",
-					      style, lw, lt, 
-					      colorspec);
+                     tmpwith{sidx} = sprintf ("with %s %s %s %s",
+                                              style, lw, lt, 
+                                              colorspec);
                    endif
-	           sidx ++;
-	         endif
+                   sidx ++;
+                 endif
 
                  if (!isempty (pt)) 
-	           if (! mono)
-	             if (strncmp (obj.markeredgecolor, "auto", 4))
-	               colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
-				            round (255*color));
-	             elseif (isnumeric (obj.markeredgecolor) && ! mono)
-	               colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
-				            round (255*obj.markeredgecolor));
-	             endif
-	           endif
-	           style = "points";
-	           if (isfield (obj, "markersize"))
-	             if (length (mdat) == nc)
-		       m = mdat(i);
-	             else
-		       m = mdat;
-	             endif
-		     ps = sprintf("pointsize %f", m / 3);
+                   if (! mono)
+                     if (strncmp (obj.markeredgecolor, "auto", 4))
+                       colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
+                                            round (255*color));
+                     elseif (isnumeric (obj.markeredgecolor) && ! mono)
+                       colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
+                                            round (255*obj.markeredgecolor));
+                     endif
+                   endif
+                   style = "points";
+                   if (isfield (obj, "markersize"))
+                     if (length (mdat) == nc)
+                       m = mdat(i);
+                     else
+                       m = mdat;
+                     endif
+                     ps = sprintf("pointsize %f", m / 3);
                    else
                      ps = "";
-	           endif
-	           tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
-					    style, lw, pt, lt, ps, 
-					    colorspec);
+                   endif
+                   tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
+                                            style, lw, pt, lt, ps, 
+                                            colorspec);
                  endif
                endif
              endif
 
              if (isempty (tmpwith))
                withclause{data_idx} = sprintf ("with %s %s %s %s %s",
                                                style, lw, pt, lt, 
                                                colorspec);
              else
-	       withclause{data_idx} = tmpwith{1};
+               withclause{data_idx} = tmpwith{1};
              endif
-	     if (nd == 3)
+             if (nd == 3)
                if (ischar (color))
-	         if (! isnan (xcol) && ! isnan (ycol) && ! isnan (zcol))
-		   data{data_idx} = [[xcol; xcol(1)], [ycol; ycol(1)], ...
-				     [zcol; zcol(1)], [ccol; ccol(1)]]';
-	         else
-		   data{data_idx} = [xcol, ycol, zcol, ccol]';
-	         endif
-	         usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3):($4)", columns (data{data_idx}));
+                 if (! isnan (xcol) && ! isnan (ycol) && ! isnan (zcol))
+                   data{data_idx} = [[xcol; xcol(1)], [ycol; ycol(1)], ...
+                                     [zcol; zcol(1)], [ccol; ccol(1)]]';
+                 else
+                   data{data_idx} = [xcol, ycol, zcol, ccol]';
+                 endif
+                 usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3):($4)", columns (data{data_idx}));
                else
-	         if (! isnan (xcol) && ! isnan (ycol) && ! isnan (zcol))
-		   data{data_idx} = [[xcol; xcol(1)], [ycol; ycol(1)], ...
-				     [zcol; zcol(1)]]';
-	         else
-		   data{data_idx} = [xcol, ycol, zcol]';
-	         endif
-	         usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3)", columns (data{data_idx}));
+                 if (! isnan (xcol) && ! isnan (ycol) && ! isnan (zcol))
+                   data{data_idx} = [[xcol; xcol(1)], [ycol; ycol(1)], ...
+                                     [zcol; zcol(1)]]';
+                 else
+                   data{data_idx} = [xcol, ycol, zcol]';
+                 endif
+                 usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3)", columns (data{data_idx}));
                endif
-	     else
+             else
                if (ischar (color))
-	         if (! isnan (xcol) && ! isnan (ycol))
-		   data{data_idx} = [[xcol; xcol(1)], [ycol; ycol(1)], ...
+                 if (! isnan (xcol) && ! isnan (ycol))
+                   data{data_idx} = [[xcol; xcol(1)], [ycol; ycol(1)], ...
                                      [ccol; ccol(1)]]';
-	         else
-		   data{data_idx} = [xcol, ycol, ccol]';
-	         endif
-	         usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3)", columns (data{data_idx}));
+                 else
+                   data{data_idx} = [xcol, ycol, ccol]';
+                 endif
+                 usingclause{data_idx} = sprintf ("record=%d using ($1):($2):($3)", columns (data{data_idx}));
                else
-	         if (! isnan (xcol) && ! isnan (ycol))
-		   data{data_idx} = [[xcol; xcol(1)], [ycol; ycol(1)]]';
-	         else
-		   data{data_idx} = [xcol, ycol]';
-	         endif
-	         usingclause{data_idx} = sprintf ("record=%d using ($1):($2)", columns (data{data_idx}));
+                 if (! isnan (xcol) && ! isnan (ycol))
+                   data{data_idx} = [[xcol; xcol(1)], [ycol; ycol(1)]]';
+                 else
+                   data{data_idx} = [xcol, ycol]';
+                 endif
+                 usingclause{data_idx} = sprintf ("record=%d using ($1):($2)", columns (data{data_idx}));
                endif
-	     endif
+             endif
 
-	     if (length (tmpwith) > 1)
-	       data_idx++;
-	       is_image_data(data_idx) = is_image_data(data_idx - 1); 
-	       parametric(data_idx) = parametric(data_idx - 1);
-	       have_cdata(data_idx) = have_cdata(data_idx - 1);
-	       have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
-	       titlespec{data_idx} = "title \"\"";
-	       usingclause{data_idx} = usingclause{data_idx - 1};
-	       data{data_idx} = data{data_idx - 1};
-	       withclause{data_idx} = tmpwith{2};
-	     endif
-	     if (length (tmpwith) > 2)
-	       data_idx++;
-	       is_image_data(data_idx) = is_image_data(data_idx - 1); 
-	       parametric(data_idx) = parametric(data_idx - 1);
-	       have_cdata(data_idx) = have_cdata(data_idx - 1);
-	       have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
-	       titlespec{data_idx} = "title \"\"";
-	       usingclause{data_idx} = usingclause{data_idx - 1};
-	       data{data_idx} = data{data_idx - 1};
-	       withclause{data_idx} = tmpwith{3};
-	     endif
-	   endif
-	 endfor
+             if (length (tmpwith) > 1)
+               data_idx++;
+               is_image_data(data_idx) = is_image_data(data_idx - 1); 
+               parametric(data_idx) = parametric(data_idx - 1);
+               have_cdata(data_idx) = have_cdata(data_idx - 1);
+               have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
+               titlespec{data_idx} = "title \"\"";
+               usingclause{data_idx} = usingclause{data_idx - 1};
+               data{data_idx} = data{data_idx - 1};
+               withclause{data_idx} = tmpwith{2};
+             endif
+             if (length (tmpwith) > 2)
+               data_idx++;
+               is_image_data(data_idx) = is_image_data(data_idx - 1); 
+               parametric(data_idx) = parametric(data_idx - 1);
+               have_cdata(data_idx) = have_cdata(data_idx - 1);
+               have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
+               titlespec{data_idx} = "title \"\"";
+               usingclause{data_idx} = usingclause{data_idx - 1};
+               data{data_idx} = data{data_idx - 1};
+               withclause{data_idx} = tmpwith{3};
+             endif
+           endif
+         endfor
 
-	case "surface"
-	  view_map = true;
+        case "surface"
+          view_map = true;
           if (! (strncmp (obj.edgecolor, "none", 4)
-		 && strncmp (obj.facecolor, "none", 4)))
-	    data_idx++;
-	    is_image_data(data_idx) = false;
-	    parametric(data_idx) = false;
-	    have_cdata(data_idx) = true;
-	    have_3d_patch(data_idx) = false;
-	    style = do_linestyle_command (obj, obj.edgecolor,
-					  data_idx, mono, 
-					  plot_stream);
-	    if (isempty (obj.keylabel))
-	      titlespec{data_idx} = "title \"\"";
-	    else
-	      tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "keylabel"));
-	      titlespec{data_idx} = cstrcat ("title \"", tmp, "\"");
-	    endif
-	    withclause{data_idx} = sprintf ("with pm3d linestyle %d",
-		           		    data_idx);
-	    withpm3d = true;
-	    pm3didx = data_idx;
+                 && strncmp (obj.facecolor, "none", 4)))
+            data_idx++;
+            is_image_data(data_idx) = false;
+            parametric(data_idx) = false;
+            have_cdata(data_idx) = true;
+            have_3d_patch(data_idx) = false;
+            style = do_linestyle_command (obj, obj.edgecolor,
+                                          data_idx, mono, 
+                                          plot_stream);
+            if (isempty (obj.keylabel))
+              titlespec{data_idx} = "title \"\"";
+            else
+              tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "keylabel"));
+              titlespec{data_idx} = cstrcat ("title \"", tmp, "\"");
+            endif
+            withclause{data_idx} = sprintf ("with pm3d linestyle %d",
+                                            data_idx);
+            withpm3d = true;
+            pm3didx = data_idx;
 
-	    xdat = obj.xdata;
-	    ydat = obj.ydata;
-	    zdat = obj.zdata;
-	    cdat = obj.cdata;
+            xdat = obj.xdata;
+            ydat = obj.ydata;
+            zdat = obj.zdata;
+            cdat = obj.cdata;
 
-  	    err = false;
+            err = false;
             if (! size_equal(zdat, cdat))
               err = true;
             endif
-	    if (isvector (xdat) && isvector (ydat) && ismatrix (zdat))
-	      if (rows (zdat) == length (ydat)
-		  && columns (zdat) == length (xdat))
+            if (isvector (xdat) && isvector (ydat) && ismatrix (zdat))
+              if (rows (zdat) == length (ydat)
+                  && columns (zdat) == length (xdat))
                 [xdat, ydat] = meshgrid (xdat, ydat);
-	      else
+              else
                 err = true;
-	      endif
-	    elseif (ismatrix (xdat) && ismatrix (ydat) && ismatrix (zdat))
-	      if (! size_equal (xdat, ydat, zdat))
+              endif
+            elseif (ismatrix (xdat) && ismatrix (ydat) && ismatrix (zdat))
+              if (! size_equal (xdat, ydat, zdat))
                 err = true;
-	      endif
-	    else
-	      err = true;
-	    endif
-	    if (err)
-	      error ("__go_draw_axes__: invalid grid data");
-	    endif
-	    xlen = columns (zdat);
-	    ylen = rows (zdat);
-	    if (xlen == columns (xdat) && xlen == columns (ydat)
-	        && ylen == rows (xdat) && ylen == rows (ydat))
-	      len = 4 * xlen;
-	      zz = zeros (ylen, len);
-	      k = 1;
-	      for kk = 1:4:len
-	        zz(:,kk)   = xdat(:,k);
-	        zz(:,kk+1) = ydat(:,k);
-	        zz(:,kk+2) = zdat(:,k);
-	        zz(:,kk+3) = cdat(:,k);
-	        k++;
-	      endfor
-	      data{data_idx} = zz.';
-	    endif
+              endif
+            else
+              err = true;
+            endif
+            if (err)
+              error ("__go_draw_axes__: invalid grid data");
+            endif
+            xlen = columns (zdat);
+            ylen = rows (zdat);
+            if (xlen == columns (xdat) && xlen == columns (ydat)
+                && ylen == rows (xdat) && ylen == rows (ydat))
+              len = 4 * xlen;
+              zz = zeros (ylen, len);
+              k = 1;
+              for kk = 1:4:len
+                zz(:,kk)   = xdat(:,k);
+                zz(:,kk+1) = ydat(:,k);
+                zz(:,kk+2) = zdat(:,k);
+                zz(:,kk+3) = cdat(:,k);
+                k++;
+              endfor
+              data{data_idx} = zz.';
+            endif
 
-	    if (doing_interp_color)
-	      interp_str = "interpolate 0, 0";
-	    else
-	      ## No interpolation of facecolors.
-	      interp_str = "";
-	    endif
-	    usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3):($4)", ylen, xlen);
+            if (doing_interp_color)
+              interp_str = "interpolate 0, 0";
+            else
+              ## No interpolation of facecolors.
+              interp_str = "";
+            endif
+            usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3):($4)", ylen, xlen);
 
             flat_interp_face = (strncmp (obj.facecolor, "flat", 4)
-				|| strncmp (obj.facecolor, "interp", 6));
+                                || strncmp (obj.facecolor, "interp", 6));
             flat_interp_edge = (strncmp (obj.edgecolor, "flat", 4)
-				|| strncmp (obj.edgecolor, "interp", 6));
+                                || strncmp (obj.edgecolor, "interp", 6));
 
-	    facecolor_none_or_white = (strncmp (obj.facecolor, "none", 4)
-				       || (isnumeric (obj.facecolor)
-					   && all (obj.facecolor == 1)));
-	    hidden_removal = false;
+            facecolor_none_or_white = (strncmp (obj.facecolor, "none", 4)
+                                       || (isnumeric (obj.facecolor)
+                                           && all (obj.facecolor == 1)));
+            hidden_removal = false;
             fputs (plot_stream, "set style increment default;\n");
             if (flat_interp_edge && facecolor_none_or_white)
-	      withpm3d = false;
-	      withclause{data_idx} = sprintf ("with %s palette", style {1});
-	      fputs (plot_stream, "unset pm3d\n");
-	      if (all (obj.facecolor == 1))
+              withpm3d = false;
+              withclause{data_idx} = sprintf ("with %s palette", style {1});
+              fputs (plot_stream, "unset pm3d\n");
+              if (all (obj.facecolor == 1))
                 hidden_removal = true;
               endif
-	    elseif (facecolor_none_or_white)
-	      if (all (obj.facecolor == 1))
+            elseif (facecolor_none_or_white)
+              if (all (obj.facecolor == 1))
                 hidden_removal = true;
               endif
-	      fputs(plot_stream,"unset pm3d;\n");
-	      fputs(plot_stream,"set style increment user;\n");
-	      withpm3d = false;
-	      withclause{data_idx} = sprintf("with %s linestyle %d", 
-					     style{1}, data_idx);
-	      fputs (plot_stream, "unset pm3d\n");
+              fputs(plot_stream,"unset pm3d;\n");
+              fputs(plot_stream,"set style increment user;\n");
+              withpm3d = false;
+              withclause{data_idx} = sprintf("with %s linestyle %d", 
+                                             style{1}, data_idx);
+              fputs (plot_stream, "unset pm3d\n");
             endif
 
-	    if (doing_interp_color)
-	      ## "depthorder" interferes with interpolation of colors.
-	      dord = "scansautomatic";
-	    else
-	      dord = "depthorder";
-	    endif
+            if (doing_interp_color)
+              ## "depthorder" interferes with interpolation of colors.
+              dord = "scansautomatic";
+            else
+              dord = "depthorder";
+            endif
 
-	    if (flat_interp_face && strncmp (obj.edgecolor, "flat", 4))
+            if (flat_interp_face && strncmp (obj.edgecolor, "flat", 4))
               fprintf (plot_stream, "set pm3d explicit at s %s %s corners2color c3;\n", 
-		       interp_str, dord);
+                       interp_str, dord);
             elseif (!facecolor_none_or_white)
               if (strncmp (obj.edgecolor, "none", 4))
                 if (__gnuplot_has_feature__ ("transparent_surface") 
                     && isscalar (obj.facealpha))
                   fprintf (plot_stream,
                            "set style fill transparent solid %f;\n",
                            obj.facealpha);
                 endif
                 fprintf (plot_stream, "set pm3d explicit at s %s corners2color c3;\n", 
-			 interp_str, dord);
+                         interp_str, dord);
               else
                 fprintf (plot_stream, "set pm3d explicit at s hidden3d %d %s %s corners2color c3;\n", 
-			 data_idx, interp_str, dord);
+                         data_idx, interp_str, dord);
 
                 if (__gnuplot_has_feature__ ("transparent_surface") 
                     && isscalar (obj.facealpha))
                   fprintf (plot_stream,
                            "set style fill transparent solid %f;\n",
                            obj.facealpha);
                 endif
               endif
             endif
-	    
-	    zz = [];
-	    if (length (style) > 1)
-	      len = 3 * xlen;
-	      zz = zeros (ylen, len);
-	      k = 1;
-	      for kk = 1:3:len
-	        zz(:,kk)   = xdat(:,k);
-	        zz(:,kk+1) = ydat(:,k);
-	        zz(:,kk+2) = zdat(:,k);
-	        k++;
-	      endfor
-	      zz = zz.';
+            
+            zz = [];
+            if (length (style) > 1)
+              len = 3 * xlen;
+              zz = zeros (ylen, len);
+              k = 1;
+              for kk = 1:3:len
+                zz(:,kk)   = xdat(:,k);
+                zz(:,kk+1) = ydat(:,k);
+                zz(:,kk+2) = zdat(:,k);
+                k++;
+              endfor
+              zz = zz.';
 
-	      data_idx++;
-	      is_image_data(data_idx) = is_image_data(data_idx - 1); 
-	      parametric(data_idx) = parametric(data_idx - 1);
-	      have_cdata(data_idx) = false;
-	      have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
-	      titlespec{data_idx} = "title \"\"";
-	      usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3)", ylen, xlen);
-	      data{data_idx} = zz;
-	      withclause{data_idx} = sprintf ("with %s linestyle %d",
-					      style{2}, data_idx);
+              data_idx++;
+              is_image_data(data_idx) = is_image_data(data_idx - 1); 
+              parametric(data_idx) = parametric(data_idx - 1);
+              have_cdata(data_idx) = false;
+              have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
+              titlespec{data_idx} = "title \"\"";
+              usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3)", ylen, xlen);
+              data{data_idx} = zz;
+              withclause{data_idx} = sprintf ("with %s linestyle %d",
+                                              style{2}, data_idx);
 
-	    endif
-	    if (length (style) > 2)
-	      data_idx++;
-	      is_image_data(data_idx) = is_image_data(data_idx - 1); 
-	      parametric(data_idx) = parametric(data_idx - 1);
-	      have_cdata(data_idx) = false;
-	      have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
-	      titlespec{data_idx} = "title \"\"";
-	      usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3)", ylen, xlen);
-	      data{data_idx} = zz;
-	      withclause{data_idx} = sprintf ("with %s linestyle %d",
-					      style{3}, data_idx);
-	    endif
-	    if (withpm3d && strncmp (style {1}, "linespoints", 11))
-	      if (isempty(zz))
-		len = 3 * xlen;
-		zz = zeros (ylen, len);
-		k = 1;
-		for kk = 1:3:len
-	          zz(:,kk)   = xdat(:,k);
-	          zz(:,kk+1) = ydat(:,k);
-	          zz(:,kk+2) = zdat(:,k);
-	          k++;
-		endfor
-		zz = zz.';
-	      endif
-	      data_idx++;
-	      is_image_data(data_idx) = is_image_data(data_idx - 1); 
-	      parametric(data_idx) = parametric(data_idx - 1);
-	      have_cdata(data_idx) = false;
-	      have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
-	      titlespec{data_idx} = "title \"\"";
-	      usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3)", ylen, xlen);
-	      data{data_idx} = zz;
-	      withclause{data_idx} = sprintf ("with points linestyle %d",
-					      pm3didx);
-	    endif
-	  endif
+            endif
+            if (length (style) > 2)
+              data_idx++;
+              is_image_data(data_idx) = is_image_data(data_idx - 1); 
+              parametric(data_idx) = parametric(data_idx - 1);
+              have_cdata(data_idx) = false;
+              have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
+              titlespec{data_idx} = "title \"\"";
+              usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3)", ylen, xlen);
+              data{data_idx} = zz;
+              withclause{data_idx} = sprintf ("with %s linestyle %d",
+                                              style{3}, data_idx);
+            endif
+            if (withpm3d && strncmp (style {1}, "linespoints", 11))
+              if (isempty(zz))
+                len = 3 * xlen;
+                zz = zeros (ylen, len);
+                k = 1;
+                for kk = 1:3:len
+                  zz(:,kk)   = xdat(:,k);
+                  zz(:,kk+1) = ydat(:,k);
+                  zz(:,kk+2) = zdat(:,k);
+                  k++;
+                endfor
+                zz = zz.';
+              endif
+              data_idx++;
+              is_image_data(data_idx) = is_image_data(data_idx - 1); 
+              parametric(data_idx) = parametric(data_idx - 1);
+              have_cdata(data_idx) = false;
+              have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
+              titlespec{data_idx} = "title \"\"";
+              usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3)", ylen, xlen);
+              data{data_idx} = zz;
+              withclause{data_idx} = sprintf ("with points linestyle %d",
+                                              pm3didx);
+            endif
+          endif
 
-	case "text"
-	  [label, f, s] = __maybe_munge_text__ (enhanced, obj, "string");
-	  fontspec = create_fontspec (f, s, gnuplot_term);
-	  lpos = obj.position;
-	  halign = obj.horizontalalignment;
-	  angle = obj.rotation;
+        case "text"
+          [label, f, s] = __maybe_munge_text__ (enhanced, obj, "string");
+          fontspec = create_fontspec (f, s, gnuplot_term);
+          lpos = obj.position;
+          halign = obj.horizontalalignment;
+          angle = obj.rotation;
           units = obj.units;
-	  color = obj.color;
+          color = obj.color;
           if (strcmpi (units, "normalized"))
             units = "graph";
           else
             units = "";
           endif
-	  
-	  if (isnumeric (color))
-	    colorspec = get_text_colorspec (color, mono);
-	  endif
+          
+          if (isnumeric (color))
+            colorspec = get_text_colorspec (color, mono);
+          endif
 
-	  if (nd == 3)
-	    fprintf (plot_stream,
-		     "set label \"%s\" at %s %.15g,%.15g,%.15g %s rotate by %f %s %s front %s;\n",
-		     undo_string_escapes (label), units, lpos(1),
-		     lpos(2), lpos(3), halign, angle, fontspec,
-		     __do_enhanced_option__ (enhanced, obj), colorspec);
-	  else
- 	    fprintf (plot_stream,
- 		     "set label \"%s\" at %s %.15g,%.15g %s rotate by %f %s %s front %s;\n",
- 		     undo_string_escapes (label), units,
- 		     lpos(1), lpos(2), halign, angle, fontspec,
-		     __do_enhanced_option__ (enhanced, obj), colorspec);
-	  endif
+          if (nd == 3)
+            fprintf (plot_stream,
+                     "set label \"%s\" at %s %.15g,%.15g,%.15g %s rotate by %f %s %s front %s;\n",
+                     undo_string_escapes (label), units, lpos(1),
+                     lpos(2), lpos(3), halign, angle, fontspec,
+                     __do_enhanced_option__ (enhanced, obj), colorspec);
+          else
+            fprintf (plot_stream,
+                     "set label \"%s\" at %s %.15g,%.15g %s rotate by %f %s %s front %s;\n",
+                     undo_string_escapes (label), units,
+                     lpos(1), lpos(2), halign, angle, fontspec,
+                     __do_enhanced_option__ (enhanced, obj), colorspec);
+          endif
 
         case "hggroup"
-	  ## Push group children into the kid list.
-	  if (isempty (kids))
-	    kids = obj.children;
-	  elseif (! isempty (obj.children))
-	    kids = [kids; obj.children];
-	  endif
+          ## Push group children into the kid list.
+          if (isempty (kids))
+            kids = obj.children;
+          elseif (! isempty (obj.children))
+            kids = [kids; obj.children];
+          endif
 
-	otherwise
-	  error ("__go_draw_axes__: unknown object class, %s",
-		 obj.type);
+        otherwise
+          error ("__go_draw_axes__: unknown object class, %s",
+                 obj.type);
       endswitch
 
     endwhile
 
     ## This is need to prevent warnings for rotations in 3D plots, while
     ## allowing colorbars with contours.
     if (nd == 2 || (data_idx > 1 && !view_map))
       fputs (plot_stream, "set pm3d implicit;\n");
@@ -1346,258 +1346,258 @@ function __go_draw_axes__ (h, plot_strea
     endif
     fprintf (plot_stream, "set yrange [%.15e:%.15e] %s;\n", ylim, ydir);
     if (strcmpi (axis_obj.yaxislocation, "right"))
       fprintf (plot_stream, "set y2range [%.15e:%.15e] %s;\n", ylim, ydir);
     endif
 
     if (nd == 3)
       if (isempty (zlim))
-	return;
+        return;
       endif
       if (strcmpi (axis_obj.zdir, "reverse"))
-	zdir = "reverse";
+        zdir = "reverse";
       else
-	zdir = "noreverse";
+        zdir = "noreverse";
       endif
       fprintf (plot_stream, "set zrange [%.15e:%.15e] %s;\n", zlim, zdir);
     endif
 
     cmap = parent_figure_obj.colormap;    
     cmap_sz = rows(cmap);
     if (! any (isinf (clim)))
       if (truecolor || ! cdatadirect)
-	if (rows(addedcmap) > 0)
-	  for i = 1:data_idx
-	    if (have_3d_patch(i))
-	      data{i}(end,:) = clim(2) * (data{i}(end, :) - 0.5) / cmap_sz;
-	     endif
-	  endfor
-	  fprintf (plot_stream, "set cbrange [%g:%g];\n", clim(1), clim(2) * 
-		   (cmap_sz + rows(addedcmap)) / cmap_sz);
-	else
-	  fprintf (plot_stream, "set cbrange [%g:%g];\n", clim);
-	endif
+        if (rows(addedcmap) > 0)
+          for i = 1:data_idx
+            if (have_3d_patch(i))
+              data{i}(end,:) = clim(2) * (data{i}(end, :) - 0.5) / cmap_sz;
+             endif
+          endfor
+          fprintf (plot_stream, "set cbrange [%g:%g];\n", clim(1), clim(2) * 
+                   (cmap_sz + rows(addedcmap)) / cmap_sz);
+        else
+          fprintf (plot_stream, "set cbrange [%g:%g];\n", clim);
+        endif
       else
-	fprintf (plot_stream, "set cbrange [1:%d];\n", cmap_sz + 
-		 rows (addedcmap));
+        fprintf (plot_stream, "set cbrange [1:%d];\n", cmap_sz + 
+                 rows (addedcmap));
       endif
     endif
 
     if (strcmpi (axis_obj.box, "on"))
       if (nd == 3)
-	fputs (plot_stream, "set border 4095;\n");
+        fputs (plot_stream, "set border 4095;\n");
       else
-	fputs (plot_stream, "set border 431;\n");
+        fputs (plot_stream, "set border 431;\n");
       endif
     else
       if (nd == 3)
-	fputs (plot_stream, "set border 895;\n");
+        fputs (plot_stream, "set border 895;\n");
       else
-	if (strcmpi (axis_obj.yaxislocation, "right"))
-	  fprintf (plot_stream, "unset ytics; set y2tics %s nomirror\n",
-		   axis_obj.tickdir);
-	  if (strcmpi (axis_obj.xaxislocation, "top"))
-	    fprintf (plot_stream, "unset xtics; set x2tics %s nomirror\n",
-		     axis_obj.tickdir);
-	    fputs (plot_stream, "set border 12;\n");
-	  else
-	    fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
-		     axis_obj.tickdir);
-	    fputs (plot_stream, "set border 9;\n");
-	  endif
-	else
-	  fprintf (plot_stream, "unset y2tics; set ytics %s nomirror\n",
-		   axis_obj.tickdir);
-	  if (strcmpi (axis_obj.xaxislocation, "top"))
-	    fprintf (plot_stream, "unset xtics; set x2tics %s nomirror\n",
-		     axis_obj.tickdir);
-	    fputs (plot_stream, "set border 6;\n");
-	  else
-	    fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
-		     axis_obj.tickdir);
-	    fputs (plot_stream, "set border 3;\n");
-	  endif
-	endif
+        if (strcmpi (axis_obj.yaxislocation, "right"))
+          fprintf (plot_stream, "unset ytics; set y2tics %s nomirror\n",
+                   axis_obj.tickdir);
+          if (strcmpi (axis_obj.xaxislocation, "top"))
+            fprintf (plot_stream, "unset xtics; set x2tics %s nomirror\n",
+                     axis_obj.tickdir);
+            fputs (plot_stream, "set border 12;\n");
+          else
+            fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
+                     axis_obj.tickdir);
+            fputs (plot_stream, "set border 9;\n");
+          endif
+        else
+          fprintf (plot_stream, "unset y2tics; set ytics %s nomirror\n",
+                   axis_obj.tickdir);
+          if (strcmpi (axis_obj.xaxislocation, "top"))
+            fprintf (plot_stream, "unset xtics; set x2tics %s nomirror\n",
+                     axis_obj.tickdir);
+            fputs (plot_stream, "set border 6;\n");
+          else
+            fprintf (plot_stream, "unset x2tics; set xtics %s nomirror\n",
+                     axis_obj.tickdir);
+            fputs (plot_stream, "set border 3;\n");
+          endif
+        endif
       endif
     endif
 
     if (strcmpi (axis_obj.visible, "off"))
       fputs (plot_stream, "unset border; unset tics\n");
     else
       fprintf (plot_stream, "set border lw %f;\n", axis_obj.linewidth);
     endif
 
     if (strcmpi (axis_obj.key, "on"))
       if (strcmpi (axis_obj.keybox, "on"))
-	box = "box";
+        box = "box";
       else
-	box = "nobox";
+        box = "nobox";
       endif
       if (strcmpi (axis_obj.keyreverse, "on"))
-	reverse = "reverse";
+        reverse = "reverse";
       else
-	reverse = "noreverse";
+        reverse = "noreverse";
       endif
       inout = "inside";
       keypos = axis_obj.keypos;
       if (ischar (keypos))
-	keypos = lower (keypos);
-	keyout = findstr (keypos, "outside");
-	if (! isempty (keyout))
-	  inout = "outside";
-	  keypos = keypos(1:keyout-1);
-	endif
+        keypos = lower (keypos);
+        keyout = findstr (keypos, "outside");
+        if (! isempty (keyout))
+          inout = "outside";
+          keypos = keypos(1:keyout-1);
+        endif
       endif
       switch (keypos)
-	case -1
-	  pos = "right top";
-	  inout = "outside";
-	case 1
-	  pos = "right top";
-	case 2
-	  pos = "left top";
-	case 3
-	  pos = "left bottom";
-	case {4, 0}
-	  pos = "right bottom";
-	case "north"
-	  pos = "center top";
-	case "south"
-	  pos = "center bottom";
-	case "east"
-	  pos = "right center";
-	case "west"
-	  pos = "left center";
-	case "northeast"
-	  pos = "right top";
-	case "northwest"
-	  pos = "left top";
-	case "southeast"
-	  pos = "right bottom";
-	case "southwest"
-	  pos = "left bottom";
-	case "best" 
-	  pos = "";
-	  warning ("legend: 'Best' not yet implemented for location specifier.\n");
-	  ## Least conflict with data in plot.
-	  ## Least unused space outside plot.
-	otherwise
-	  pos = "";
+        case -1
+          pos = "right top";
+          inout = "outside";
+        case 1
+          pos = "right top";
+        case 2
+          pos = "left top";
+        case 3
+          pos = "left bottom";
+        case {4, 0}
+          pos = "right bottom";
+        case "north"
+          pos = "center top";
+        case "south"
+          pos = "center bottom";
+        case "east"
+          pos = "right center";
+        case "west"
+          pos = "left center";
+        case "northeast"
+          pos = "right top";
+        case "northwest"
+          pos = "left top";
+        case "southeast"
+          pos = "right bottom";
+        case "southwest"
+          pos = "left bottom";
+        case "best" 
+          pos = "";
+          warning ("legend: 'Best' not yet implemented for location specifier.\n");
+          ## Least conflict with data in plot.
+          ## Least unused space outside plot.
+        otherwise
+          pos = "";
       endswitch
       if (__gnuplot_has_feature__ ("key_has_font_properties"))
         fontspec = create_fontspec (axis_obj.fontname, axis_obj.fontsize, gnuplot_term);
       else
-	fontspec = "";
+        fontspec = "";
       endif
       fprintf (plot_stream, "set key %s %s %s %s %s;\n", inout, pos, box,
                reverse, fontspec);
     else
       fputs (plot_stream, "unset key;\n");
     endif
 
     fputs (plot_stream, "set style data lines;\n");
 
     if (! use_gnuplot_for_images)
       for i = 1:ximg_data_idx
-	view_fcn (xlim, ylim, ximg_data{i}, view_zoom, view_cmd);
+        view_fcn (xlim, ylim, ximg_data{i}, view_zoom, view_cmd);
       endfor
     endif
 
     cmap = [cmap; addedcmap];
     cmap_sz = cmap_sz + rows(addedcmap);
     if (length(cmap) > 0)
       fprintf (plot_stream,
-	       "set palette positive color model RGB maxcolors %i;\n",
-	       cmap_sz);
+               "set palette positive color model RGB maxcolors %i;\n",
+               cmap_sz);
       fprintf (plot_stream,
-	       "set palette file \"-\" binary record=%d using 1:2:3:4;\n",
-	       cmap_sz);
+               "set palette file \"-\" binary record=%d using 1:2:3:4;\n",
+               cmap_sz);
       fwrite (plot_stream, [1:cmap_sz; cmap.'], "float32");
       fwrite (plot_stream, "\n");
     endif
 
     fputs (plot_stream, "unset colorbox;\n");
 
     if (have_data)
       if (nd == 2)
-	plot_cmd = "plot";
+        plot_cmd = "plot";
       else
-	plot_cmd = "splot";
-	rot_x = 90 - axis_obj.view(2);
-	rot_z = axis_obj.view(1);
-	while (rot_z < 0)
-	  rot_z += 360;
-	endwhile
- 	fputs (plot_stream, "set ticslevel 0;\n");
-	if (view_map && rot_x == 0 && rot_z == 0)
-	  fputs (plot_stream, "set view map;\n");
-	else
-	  fprintf (plot_stream, "set view %.15g, %.15g;\n", rot_x, rot_z);
-	endif
+        plot_cmd = "splot";
+        rot_x = 90 - axis_obj.view(2);
+        rot_z = axis_obj.view(1);
+        while (rot_z < 0)
+          rot_z += 360;
+        endwhile
+        fputs (plot_stream, "set ticslevel 0;\n");
+        if (view_map && rot_x == 0 && rot_z == 0)
+          fputs (plot_stream, "set view map;\n");
+        else
+          fprintf (plot_stream, "set view %.15g, %.15g;\n", rot_x, rot_z);
+        endif
       endif
       if (have_3d_patch (1))
-	fputs (plot_stream, "set pm3d depthorder\n");
-	fprintf (plot_stream, "%s \"-\" %s %s %s \\\n", plot_cmd,
-		 usingclause{1}, titlespec{1}, withclause{1});
+        fputs (plot_stream, "set pm3d depthorder\n");
+        fprintf (plot_stream, "%s \"-\" %s %s %s \\\n", plot_cmd,
+                 usingclause{1}, titlespec{1}, withclause{1});
       elseif (is_image_data (1))
-	fprintf (plot_stream, "%s \"-\" %s %s %s \\\n", plot_cmd,
-		 usingclause{1}, titlespec{1}, withclause{1});
+        fprintf (plot_stream, "%s \"-\" %s %s %s \\\n", plot_cmd,
+                 usingclause{1}, titlespec{1}, withclause{1});
       else
-	fprintf (plot_stream, "%s \"-\" binary format='%%float64' %s %s %s \\\n", plot_cmd,
-		 usingclause{1}, titlespec{1}, withclause{1});
+        fprintf (plot_stream, "%s \"-\" binary format='%%float64' %s %s %s \\\n", plot_cmd,
+                 usingclause{1}, titlespec{1}, withclause{1});
       endif
       for i = 2:data_idx
-	if (have_3d_patch (i))
-	  fprintf (plot_stream, ", \"-\" %s %s %s \\\n",
-		   usingclause{i}, titlespec{i}, withclause{i});
-	elseif (is_image_data (i))
-	  if (! is_image_data (i-1))
-	    fputs (plot_stream, "; ");
+        if (have_3d_patch (i))
+          fprintf (plot_stream, ", \"-\" %s %s %s \\\n",
+                   usingclause{i}, titlespec{i}, withclause{i});
+        elseif (is_image_data (i))
+          if (! is_image_data (i-1))
+            fputs (plot_stream, "; ");
             if (bg_is_set)      
               fputs (plot_stream, "unset obj 1; \\\n");
               bg_is_set = false;
             endif
-	  endif
+          endif
           fprintf (plot_stream, "%s \"-\" %s %s %s \\\n", plot_cmd,
-		   usingclause{i}, titlespec{i}, withclause{i});
-	elseif (is_image_data (i-1))
+                   usingclause{i}, titlespec{i}, withclause{i});
+        elseif (is_image_data (i-1))
           if (bg_is_set)      
             fputs (plot_stream, "unset obj 1; \\\n");
               bg_is_set = false;
             endif
-	  fprintf (plot_stream, "%s \"-\" binary format='%%float64' %s %s %s \\\n", plot_cmd,
-		   usingclause{i}, titlespec{i}, withclause{i});
-	else
-	  fprintf (plot_stream, ", \"-\" binary format='%%float64' %s %s %s \\\n",
-		   usingclause{i}, titlespec{i}, withclause{i});
-	endif
+          fprintf (plot_stream, "%s \"-\" binary format='%%float64' %s %s %s \\\n", plot_cmd,
+                   usingclause{i}, titlespec{i}, withclause{i});
+        else
+          fprintf (plot_stream, ", \"-\" binary format='%%float64' %s %s %s \\\n",
+                   usingclause{i}, titlespec{i}, withclause{i});
+        endif
       endfor
       fputs (plot_stream, ";\n");
       for i = 1:data_idx
-	if (have_3d_patch (i))
-	  ## Can't write 3d patch data as binary as can't plot more than 
-	  ## a single patch at a time and have to plot all patches together
-	  ## so that the gnuplot depth ordering is done correctly
-	  for j = 1 : 4 : columns(data{i})
-	    if (j != 1)
-	      fputs (plot_stream, "\n\n");
-	    endif
-	    fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n", data{i}(:,j).');
-	    fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n\n", data{i}(:,j+1).');
-	    fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n", data{i}(:,j+2).');
-	    fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n", data{i}(:,j+3).');
-	  endfor
-	  fputs (plot_stream, "e\n");
-	elseif (is_image_data(i))
-	  fwrite (plot_stream, data{i}, "float32");
-	else
-	  __gnuplot_write_data__ (plot_stream, data{i}, nd, parametric(i), 
-				  have_cdata(i));
-	endif
+        if (have_3d_patch (i))
+          ## Can't write 3d patch data as binary as can't plot more than 
+          ## a single patch at a time and have to plot all patches together
+          ## so that the gnuplot depth ordering is done correctly
+          for j = 1 : 4 : columns(data{i})
+            if (j != 1)
+              fputs (plot_stream, "\n\n");
+            endif
+            fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n", data{i}(:,j).');
+            fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n\n", data{i}(:,j+1).');
+            fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n", data{i}(:,j+2).');
+            fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n", data{i}(:,j+3).');
+          endfor
+          fputs (plot_stream, "e\n");
+        elseif (is_image_data(i))
+          fwrite (plot_stream, data{i}, "float32");
+        else
+          __gnuplot_write_data__ (plot_stream, data{i}, nd, parametric(i), 
+                                  have_cdata(i));
+        endif
       endfor
     else
       fputs (plot_stream, "plot \"-\";\nInf Inf\ne\n");
     endif
 
     ## Needed to allow mouse rotation with pcolor.
     if (view_map)
       fputs (plot_stream, "unset view;\n");
@@ -1620,47 +1620,47 @@ function fontspec = create_fontspec (f, 
   if (strcmp (f, "*") || strcmp (gp_term, "tikz"))
     fontspec = sprintf ("font \",%d\"", s);
   else
     fontspec = sprintf ("font \"%s,%d\"", f, s);
   endif
 endfunction
 
 function style = do_linestyle_command (obj, linecolor, idx, mono,
-				       plot_stream, errbars = "")
+                                       plot_stream, errbars = "")
   style = {};
 
   fprintf (plot_stream, "set style line %d default;\n", idx);
   fprintf (plot_stream, "set style line %d", idx);
 
   found_style = false;
   if (isnumeric (linecolor))
     color = linecolor;
     if (! mono)
       fprintf (plot_stream, " linecolor rgb \"#%02x%02x%02x\"",
-	       round (255*color));
+               round (255*color));
     endif
   else
     color = [0, 0, 0];
   endif
 
   if (isfield (obj, "linestyle"))
     switch (obj.linestyle)
       case "-"
-	lt = "1";
+        lt = "1";
       case "--"
-	lt = "2";
+        lt = "2";
       case ":"
-	lt = "3";
+        lt = "3";
       case "-."
-	lt = "6";
+        lt = "6";
       case "none"
-	lt = "";
+        lt = "";
       otherwise
-	lt = "";
+        lt = "";
     endswitch
 
     ## FIXME -- linetype is currently broken, since it disables the
     ## gnuplot default dashed and solid linestyles with the only
     ## benefit of being able to specify '--' and get a single sized
     ## dashed line of identical dash pattern for all called this way.
     ## All dash patterns are a subset of "with lines" and none of the
     ## lt specifications will correctly propagate into the x11 terminal
@@ -1681,55 +1681,55 @@ function style = do_linestyle_command (o
   if (isfield (obj, "linewidth"))
     fprintf (plot_stream, " linewidth %f", obj.linewidth);
     found_style = true;
   endif
 
   if (isfield (obj, "marker"))
     switch (obj.marker)
       case "+"
-	pt = pt2 = "1";
+        pt = pt2 = "1";
       case "o"
-	pt = "6";
-	pt2 = "7";
+        pt = "6";
+        pt2 = "7";
       case "*"
-	pt = pt2 = "3";
+        pt = pt2 = "3";
       case "."
-	pt = pt2 = "0";
+        pt = pt2 = "0";
       case "x"
-	pt = pt2 = "2";
+        pt = pt2 = "2";
       case {"square", "s"}
-	pt = "4";
-	pt2 = "5";
+        pt = "4";
+        pt2 = "5";
       case {"diamond", "d"}
-	pt = "13";
-	pt2 = "14";
+        pt = "13";
+        pt2 = "14";
       case "^"
-	pt = "8";
-	pt2 = "9";
+        pt = "8";
+        pt2 = "9";
       case "v"
-	pt = "10";
-	pt2 = "11";
+        pt = "10";
+        pt2 = "11";
       case ">"
-	## FIXME missing point type 
-	pt = "8";
-	pt2 = "9";
+        ## FIXME missing point type 
+        pt = "8";
+        pt2 = "9";
       case "<"
-	## FIXME missing point type 
-	pt = "10";
-	pt2 = "11";
+        ## FIXME missing point type 
+        pt = "10";
+        pt2 = "11";
       case {"pentagram", "p"}
-	## FIXME missing point type 
-	pt = pt2 = "3";
+        ## FIXME missing point type 
+        pt = pt2 = "3";
       case {"hexagram", "h"}
-	pt = pt2 = "3";
+        pt = pt2 = "3";
       case "none"
-	pt = pt2 = "";
+        pt = pt2 = "";
       otherwise
-	pt = pt2 = "";
+        pt = pt2 = "";
     endswitch
   else
     pt = pt2 = "";
   endif
 
   if (! isempty (pt))
     found_style = true;
   endif
@@ -1739,101 +1739,101 @@ function style = do_linestyle_command (o
     if (isempty (lt))
       style {sidx} = "";
     else
       style {sidx} = "lines";
     endif
     
     facesame = true;
     if (! isequal (pt, pt2) && isfield (obj, "markerfacecolor") 
-	&& !strncmp (obj.markerfacecolor, "none", 4))
+        && !strncmp (obj.markerfacecolor, "none", 4))
       if (strncmp (obj.markerfacecolor, "auto", 4)
-	  || ! isnumeric (obj.markerfacecolor) 
-	  || (isnumeric (obj.markerfacecolor) 
-	      && isequal (color, obj.markerfacecolor)))
-	if (! isempty (pt2))
-	  fprintf (plot_stream, " pointtype %s", pt2);
-	  style {sidx} = strcat (style{sidx}, "points");
-	endif
-	if (isfield (obj, "markersize"))
-	  fprintf (plot_stream, " pointsize %f", obj.markersize / 3);
-	endif
+          || ! isnumeric (obj.markerfacecolor) 
+          || (isnumeric (obj.markerfacecolor) 
+              && isequal (color, obj.markerfacecolor)))
+        if (! isempty (pt2))
+          fprintf (plot_stream, " pointtype %s", pt2);
+          style {sidx} = strcat (style{sidx}, "points");
+        endif
+        if (isfield (obj, "markersize"))
+          fprintf (plot_stream, " pointsize %f", obj.markersize / 3);
+        endif
       else
-	facesame = false;
-	if (! found_style)
-	  fputs (plot_stream, " default");
-	endif
-	fputs (plot_stream, ";\n");
-	if (! isempty (style {sidx}))	
-	  sidx ++;
-	  idx ++;
-	else
-	  fputs (plot_stream, ";\n");
-	endif
-	fprintf (plot_stream, "set style line %d default;\n", idx);
-	fprintf (plot_stream, "set style line %d", idx);
-	if (isnumeric (obj.markerfacecolor) && ! mono)
-	  fprintf (plot_stream, " linecolor rgb \"#%02x%02x%02x\"",
-		   round (255*obj.markerfacecolor));
-	endif
-	if (! isempty (pt2))
-	  style {sidx} = "points";
-	  fprintf (plot_stream, " pointtype %s", pt2);
-	endif
-	if (isfield (obj, "markersize"))
-	  fprintf (plot_stream, " pointsize %f", obj.markersize / 3);
-	endif
+        facesame = false;
+        if (! found_style)
+          fputs (plot_stream, " default");
+        endif
+        fputs (plot_stream, ";\n");
+        if (! isempty (style {sidx}))   
+          sidx ++;
+          idx ++;
+        else
+          fputs (plot_stream, ";\n");
+        endif
+        fprintf (plot_stream, "set style line %d default;\n", idx);
+        fprintf (plot_stream, "set style line %d", idx);
+        if (isnumeric (obj.markerfacecolor) && ! mono)
+          fprintf (plot_stream, " linecolor rgb \"#%02x%02x%02x\"",
+                   round (255*obj.markerfacecolor));
+        endif
+        if (! isempty (pt2))
+          style {sidx} = "points";
+          fprintf (plot_stream, " pointtype %s", pt2);
+        endif
+        if (isfield (obj, "markersize"))
+          fprintf (plot_stream, " pointsize %f", obj.markersize / 3);
+        endif
       endif
     endif
     if (isfield (obj, "markeredgecolor") 
-	&& !strncmp (obj.markeredgecolor, "none", 4))
+        && !strncmp (obj.markeredgecolor, "none", 4))
       if (facesame && !isempty (pt)
           && (strncmp (obj.markeredgecolor, "auto", 4)
-	      || ! isnumeric (obj.markeredgecolor) 
-	      || (isnumeric (obj.markeredgecolor) 
-		  && isequal (color, obj.markeredgecolor))))
-	if (sidx == 1 && ((length (style {sidx}) == 5 
-	    && strncmp (style {sidx}, "lines", 5)) || isempty (style {sidx})))
-	  if (! isempty (pt))
-	    style {sidx} = strcat (style{sidx}, "points");
-	    fprintf (plot_stream, " pointtype %s", pt);
-	  endif
-	  if (isfield (obj, "markersize"))
-	    fprintf (plot_stream, " pointsize %f", obj.markersize / 3);
-	  endif
-	endif
+              || ! isnumeric (obj.markeredgecolor) 
+              || (isnumeric (obj.markeredgecolor) 
+                  && isequal (color, obj.markeredgecolor))))
+        if (sidx == 1 && ((length (style {sidx}) == 5 
+            && strncmp (style {sidx}, "lines", 5)) || isempty (style {sidx})))
+          if (! isempty (pt))
+            style {sidx} = strcat (style{sidx}, "points");
+            fprintf (plot_stream, " pointtype %s", pt);
+          endif
+          if (isfield (obj, "markersize"))
+            fprintf (plot_stream, " pointsize %f", obj.markersize / 3);
+          endif
+        endif
       else
-	if (! found_style)
-	  fputs (plot_stream, " default");
-	endif
-	fputs (plot_stream, ";\n");
-	if (!isempty (style {sidx}))	
-	  sidx ++;
-	  idx ++;
-	else
-	  fputs (plot_stream, ";\n");
-	endif
-	fprintf (plot_stream, "set style line %d default;\n", idx);
-	fprintf (plot_stream, "set style line %d", idx);
-	if (! mono)
-	  if (strncmp (obj.markeredgecolor, "auto", 4))
-	    fprintf (plot_stream, " linecolor rgb \"#%02x%02x%02x\"",
-		     round (255*color));
-	  elseif (isnumeric (obj.markeredgecolor) && ! mono)
-	    fprintf (plot_stream, " linecolor rgb \"#%02x%02x%02x\"",
-		     round (255*obj.markeredgecolor));
-	  endif
-	endif
-	if (! isempty (pt))
-	  style {sidx} = "points";
-	  fprintf (plot_stream, " pointtype %s", pt);
-	endif
-	if (isfield (obj, "markersize"))
-	  fprintf (plot_stream, " pointsize %f", obj.markersize / 3);
-	endif
+        if (! found_style)
+          fputs (plot_stream, " default");
+        endif
+        fputs (plot_stream, ";\n");
+        if (!isempty (style {sidx}))    
+          sidx ++;
+          idx ++;
+        else
+          fputs (plot_stream, ";\n");
+        endif
+        fprintf (plot_stream, "set style line %d default;\n", idx);
+        fprintf (plot_stream, "set style line %d", idx);
+        if (! mono)
+          if (strncmp (obj.markeredgecolor, "auto", 4))
+            fprintf (plot_stream, " linecolor rgb \"#%02x%02x%02x\"",
+                     round (255*color));
+          elseif (isnumeric (obj.markeredgecolor) && ! mono)
+            fprintf (plot_stream, " linecolor rgb \"#%02x%02x%02x\"",
+                     round (255*obj.markeredgecolor));
+          endif
+        endif
+        if (! isempty (pt))
+          style {sidx} = "points";
+          fprintf (plot_stream, " pointtype %s", pt);
+        endif
+        if (isfield (obj, "markersize"))
+          fprintf (plot_stream, " pointsize %f", obj.markersize / 3);
+        endif
       endif
     endif
   else
     style{1} = errbars;
   endif
 
   if (! found_style && isempty (style {1}))
     fputs (plot_stream, " default");
@@ -1845,23 +1845,23 @@ endfunction
 
 function nd = __calc_dimensions__ (obj)
   kids = obj.children;
   nd = 2;
   for i = 1:length (kids)
     obj = get (kids(i));
     switch (obj.type)
       case {"image", "text"}
-	## ignore as they 
+        ## ignore as they 
       case {"line", "patch"}
-	if (! isempty (obj.zdata))
-	  nd = 3;
-	endif
+        if (! isempty (obj.zdata))
+          nd = 3;
+        endif
       case "surface"
-	nd = 3;
+        nd = 3;
       case "hggroup"
         obj_nd = __calc_dimensions__ (obj);
         if (obj_nd == 3)
           nd = 3;
         endif
     endswitch
   endfor
 endfunction
@@ -1882,23 +1882,23 @@ function __gnuplot_write_data__ (plot_st
   if (nd == 2)
     fwrite (plot_stream, data, "float64");
   elseif (nd == 3)
     if (parametric)
       fwrite (plot_stream, data, "float64");
     else
       nr = rows (data);
       if (cdata)
-	for j = 1:4:nr
-	  fwrite (plot_stream, data(j:j+3,:), "float64");
-	endfor
+        for j = 1:4:nr
+          fwrite (plot_stream, data(j:j+3,:), "float64");
+        endfor
       else
-	for j = 1:3:nr
-	  fwrite (plot_stream, data(j:j+2,:), "float64");
-	endfor
+        for j = 1:3:nr
+          fwrite (plot_stream, data(j:j+2,:), "float64");
+        endfor
       endif
     endif
   endif
 
 endfunction
 
 function do_tics (obj, plot_stream, ymirror, mono, gnuplot_term)
 
@@ -1919,73 +1919,73 @@ function do_tics (obj, plot_stream, ymir
   [fontname, fontsize] = get_fontname_and_size (obj);
   fontspec = create_fontspec (fontname, fontsize, gnuplot_term);
 
   ## A Gnuplot tic scale of 69 is equivalent to Octave's 0.5.
   ticklength = sprintf ("scale %4.1f", (69/0.5)*obj.ticklength(1));
 
   if (strcmpi (obj.xaxislocation, "top"))
     do_tics_1 (obj.xtickmode, obj.xtick, obj.xminortick, obj.xticklabelmode,
-	       obj.xticklabel, obj.xcolor, "x2", plot_stream, true, mono,
-	       "border", obj.tickdir, ticklength, fontname, fontspec,
-	       obj.interpreter, obj.xscale);
+               obj.xticklabel, obj.xcolor, "x2", plot_stream, true, mono,
+               "border", obj.tickdir, ticklength, fontname, fontspec,
+               obj.interpreter, obj.xscale);
     do_tics_1 ("manual", [], "off", obj.xticklabelmode, obj.xticklabel,
-	       obj.xcolor, "x", plot_stream, true, mono, "border",
-	       "", "", fontname, fontspec, obj.interpreter, obj.xscale);
+               obj.xcolor, "x", plot_stream, true, mono, "border",
+               "", "", fontname, fontspec, obj.interpreter, obj.xscale);
   elseif (strcmpi (obj.xaxislocation, "zero"))
     do_tics_1 (obj.xtickmode, obj.xtick, obj.xminortick, obj.xticklabelmode,
-	       obj.xticklabel, obj.xcolor, "x", plot_stream, true, mono,
-	       "axis", obj.tickdir, ticklength, fontname, fontspec,
-	       obj.interpreter, obj.xscale);
+               obj.xticklabel, obj.xcolor, "x", plot_stream, true, mono,
+               "axis", obj.tickdir, ticklength, fontname, fontspec,
+               obj.interpreter, obj.xscale);
     do_tics_1 ("manual", [], "off", obj.xticklabelmode, obj.xticklabel,
-	       obj.xcolor, "x2", plot_stream, true, mono, "axis",
-	       "", "", fontname, fontspec, obj.interpreter, obj.xscale);
+               obj.xcolor, "x2", plot_stream, true, mono, "axis",
+               "", "", fontname, fontspec, obj.interpreter, obj.xscale);
   else
     do_tics_1 (obj.xtickmode, obj.xtick, obj.xminortick, obj.xticklabelmode,
-	       obj.xticklabel, obj.xcolor, "x", plot_stream, true, mono,
-	       "border", obj.tickdir, ticklength, fontname, fontspec,
-	       obj.interpreter, obj.xscale);
+               obj.xticklabel, obj.xcolor, "x", plot_stream, true, mono,
+               "border", obj.tickdir, ticklength, fontname, fontspec,
+               obj.interpreter, obj.xscale);
     do_tics_1 ("manual", [], "off", obj.xticklabelmode, obj.xticklabel,
-	       obj.xcolor, "x2", plot_stream, true, mono, "border",
-	       "", "", fontname, fontspec, obj.interpreter, obj.xscale);
+               obj.xcolor, "x2", plot_stream, true, mono, "border",
+               "", "", fontname, fontspec, obj.interpreter, obj.xscale);
   endif
   if (strcmpi (obj.yaxislocation, "right"))
     do_tics_1 (obj.ytickmode, obj.ytick, obj.yminortick, obj.yticklabelmode,
-	       obj.yticklabel, obj.ycolor, "y2", plot_stream, ymirror, mono,
-	       "border", obj.tickdir, ticklength, fontname, fontspec,
-	       obj.interpreter, obj.yscale);
+               obj.yticklabel, obj.ycolor, "y2", plot_stream, ymirror, mono,
+               "border", obj.tickdir, ticklength, fontname, fontspec,
+               obj.interpreter, obj.yscale);
     do_tics_1 ("manual", [], "off", obj.yticklabelmode, obj.yticklabel,
-	       obj.ycolor, "y", plot_stream, ymirror, mono, "border",
-	       "", "", fontname, fontspec, obj.interpreter, obj.yscale);
+               obj.ycolor, "y", plot_stream, ymirror, mono, "border",
+               "", "", fontname, fontspec, obj.interpreter, obj.yscale);
   elseif (strcmpi (obj.yaxislocation, "zero"))
     do_tics_1 (obj.ytickmode, obj.ytick, obj.yminortick, obj.yticklabelmode,
-	       obj.yticklabel, obj.ycolor, "y", plot_stream, ymirror, mono,
-	       "axis", obj.tickdir, ticklength, fontname, fontspec,
-	       obj.interpreter, obj.yscale);
+               obj.yticklabel, obj.ycolor, "y", plot_stream, ymirror, mono,
+               "axis", obj.tickdir, ticklength, fontname, fontspec,
+               obj.interpreter, obj.yscale);
     do_tics_1 ("manual", [], "off", obj.yticklabelmode, obj.yticklabel,
-	       obj.ycolor, "y2", plot_stream, ymirror, mono, "axis",
-	       "", "", fontname, fontspec, obj.interpreter, obj.yscale);
+               obj.ycolor, "y2", plot_stream, ymirror, mono, "axis",
+               "", "", fontname, fontspec, obj.interpreter, obj.yscale);
   else
     do_tics_1 (obj.ytickmode, obj.ytick, obj.yminortick, obj.yticklabelmode,
-	       obj.yticklabel, obj.ycolor, "y", plot_stream, ymirror, mono,
-	       "border", obj.tickdir, ticklength, fontname, fontspec,
-	       obj.interpreter, obj.yscale);
+               obj.yticklabel, obj.ycolor, "y", plot_stream, ymirror, mono,
+               "border", obj.tickdir, ticklength, fontname, fontspec,
+               obj.interpreter, obj.yscale);
     do_tics_1 ("manual", [], "off", obj.yticklabelmode, obj.yticklabel,
-	       obj.ycolor, "y2", plot_stream, ymirror, mono, "border",
-	       "", "", fontname, fontspec, obj.interpreter, obj.yscale);
+               obj.ycolor, "y2", plot_stream, ymirror, mono, "border",
+               "", "", fontname, fontspec, obj.interpreter, obj.yscale);
   endif
   do_tics_1 (obj.ztickmode, obj.ztick, obj.zminortick, obj.zticklabelmode,
-	     obj.zticklabel, obj.zcolor, "z", plot_stream, true, mono,
-	     "border", obj.tickdir, ticklength, fontname, fontspec,
-	     obj.interpreter, obj.yscale);
+             obj.zticklabel, obj.zcolor, "z", plot_stream, true, mono,
+             "border", obj.tickdir, ticklength, fontname, fontspec,
+             obj.interpreter, obj.yscale);
 endfunction
 
 function do_tics_1 (ticmode, tics, mtics, labelmode, labels, color, ax,
-		    plot_stream, mirror, mono, axispos, tickdir, ticklength,
-		    fontname, fontspec, interpreter, scale)
+                    plot_stream, mirror, mono, axispos, tickdir, ticklength,
+                    fontname, fontspec, interpreter, scale)
   persistent warned_latex = false;
   if (strcmpi (interpreter, "tex"))
     for n = 1 : numel(labels)
       labels{n} = __tex2enhanced__ (labels{n}, fontname, false, false);
     endfor
   elseif (strcmpi (interpreter, "latex"))
     if (! warned_latex)
       warning ("latex markup not supported for tick marks");
@@ -2000,81 +2000,81 @@ function do_tics_1 (ticmode, tics, mtics
     num_mtics = 5;
   endif
   colorspec = get_text_colorspec (color, mono);
   if (strcmpi (ticmode, "manual") || strcmpi (labelmode, "manual"))
     if (isempty (tics))
       fprintf (plot_stream, "unset %stics;\nunset m%stics;\n", ax, ax);
     elseif (strcmpi (labelmode, "manual"))
       if (ischar (labels))
-	labels = cellstr (labels);
+        labels = cellstr (labels);
       endif
       if (isnumeric (labels))
-	labels = num2str (real (labels(:)));
+        labels = num2str (real (labels(:)));
       endif
       if (ischar (labels))
-	labels = permute (cellstr (labels), [2, 1]);
+        labels = permute (cellstr (labels), [2, 1]);
       endif
       if (iscellstr (labels))
-	k = 1;
-	ntics = numel (tics);
-	nlabels = numel (labels);
-	fprintf (plot_stream, "set format %s \"%%s\";\n", ax);
-	if (mirror)
-	  fprintf (plot_stream, "set %stics %s %s %s mirror (", ax, 
-		   tickdir, ticklength, axispos);
-	else
-	  fprintf (plot_stream, "set %stics %s %s %s nomirror (", ax,
-		   tickdir, ticklength, axispos);
-	endif
+        k = 1;
+        ntics = numel (tics);
+        nlabels = numel (labels);
+        fprintf (plot_stream, "set format %s \"%%s\";\n", ax);
+        if (mirror)
+          fprintf (plot_stream, "set %stics %s %s %s mirror (", ax, 
+                   tickdir, ticklength, axispos);
+        else
+          fprintf (plot_stream, "set %stics %s %s %s nomirror (", ax,
+                   tickdir, ticklength, axispos);
+        endif
  
-	labels = regexprep(labels, "%", "%%");
-	for i = 1:ntics
-	  fprintf (plot_stream, " \"%s\" %.15g", labels{k++}, tics(i));
-	  if (i < ntics)
-	    fputs (plot_stream, ", ");
-	  endif
-	  if (k > nlabels)
-	    k = 1;
-	  endif
-	endfor
-	fprintf (plot_stream, ") %s %s;\n", colorspec, fontspec);
- 	if (strcmp (mtics, "on"))
-	  fprintf (plot_stream, "set m%stics %d;\n", ax, num_mtics);
-	else
-	  fprintf (plot_stream, "unset m%stics;\n", ax);
-	endif
+        labels = regexprep(labels, "%", "%%");
+        for i = 1:ntics
+          fprintf (plot_stream, " \"%s\" %.15g", labels{k++}, tics(i));
+          if (i < ntics)
+            fputs (plot_stream, ", ");
+          endif
+          if (k > nlabels)
+            k = 1;
+          endif
+        endfor
+        fprintf (plot_stream, ") %s %s;\n", colorspec, fontspec);
+        if (strcmp (mtics, "on"))
+          fprintf (plot_stream, "set m%stics %d;\n", ax, num_mtics);
+        else
+          fprintf (plot_stream, "unset m%stics;\n", ax);
+        endif
      else
-	error ("unsupported type of ticklabel");
+        error ("unsupported type of ticklabel");
       endif
     else
       fprintf (plot_stream, "set format %s \"%s\";\n", ax, fmt);
       if (mirror)
-	fprintf (plot_stream, "set %stics %s %s %s mirror (", ax, tickdir,
-		 ticklength, axispos);
+        fprintf (plot_stream, "set %stics %s %s %s mirror (", ax, tickdir,
+                 ticklength, axispos);
       else
-	fprintf (plot_stream, "set %stics %s %s %s nomirror (", ax, tickdir,
-		 ticklength, axispos);
+        fprintf (plot_stream, "set %stics %s %s %s nomirror (", ax, tickdir,
+                 ticklength, axispos);
       endif
       fprintf (plot_stream, " %.15g,", tics(1:end-1));
       fprintf (plot_stream, " %.15g) %s;\n", tics(end), fontspec);
       if (strcmp (mtics, "on"))
         fprintf (plot_stream, "set m%stics %d;\n", ax, num_mtics);
       else
-	fprintf (plot_stream, "unset m%stics;\n", ax);
+        fprintf (plot_stream, "unset m%stics;\n", ax);
       endif
     endif
   else
     fprintf (plot_stream, "set format %s \"%s\";\n", ax, fmt);
     if (mirror)
       fprintf (plot_stream, "set %stics %s %s %s mirror %s %s;\n", ax, 
-	       axispos, tickdir, ticklength, colorspec, fontspec);
+               axispos, tickdir, ticklength, colorspec, fontspec);
     else
       fprintf (plot_stream, "set %stics %s %s %s nomirror %s %s;\n", ax, 
-	       tickdir, ticklength, axispos, colorspec, fontspec);
+               tickdir, ticklength, axispos, colorspec, fontspec);
     endif
     if (strcmp (mtics, "on"))
       fprintf (plot_stream, "set m%stics %d;\n", ax, num_mtics);
     else
       fprintf (plot_stream, "unset m%stics;\n", ax);
     endif
   endif
 endfunction
@@ -2098,43 +2098,43 @@ function ticklabel = ticklabel_to_cell (
   endif
 endfunction
 
 function colorspec = get_text_colorspec (color, mono)
   if (mono)
     colorspec = "";
   else
     colorspec = sprintf ("textcolor rgb \"#%02x%02x%02x\"",
-			 round (255*color));
+                         round (255*color));
   endif
 endfunction
 
 function [f, s, fnt, it, bld] = get_fontname_and_size (t)
   if (isempty (t.fontname))
     fnt = "Helvetica";
   else
     fnt = t.fontname;
   endif
   f = fnt;
   it = false;
   bld = false;
   if (! isempty (t.fontweight) && strcmpi (t.fontweight, "bold"))
     if (! isempty(t.fontangle)
-	&& (strcmpi (t.fontangle, "italic")
-	    || strcmpi (t.fontangle, "oblique")))
+        && (strcmpi (t.fontangle, "italic")
+            || strcmpi (t.fontangle, "oblique")))
       f = cstrcat (f, "-bolditalic");
       it = true;
       bld = true;
     else
       f = cstrcat (f, "-bold");
       bld = true;
     endif
   elseif (! isempty(t.fontangle)
-	  && (strcmpi (t.fontangle, "italic")
-	      || strcmpi (t.fontangle, "oblique")))
+          && (strcmpi (t.fontangle, "italic")
+              || strcmpi (t.fontangle, "oblique")))
     f = cstrcat (f, "-italic");
     it = true;
   endif
   if (isempty (t.fontsize))
     s = 10;
   else
     s = t.fontsize;
   endif
@@ -2155,18 +2155,18 @@ function [str, f, s] = __maybe_munge_tex
   endif
 
   str = getfield (obj, fld);
   if (enhanced)
     if (strcmpi (obj.interpreter, "tex"))
       str = __tex2enhanced__ (str, fnt, it, bld);
     elseif (strcmpi (obj.interpreter, "latex"))
       if (! warned_latex)
-	warning ("latex markup not supported for text objects");
-	warned_latex = true;
+        warning ("latex markup not supported for text objects");
+        warned_latex = true;
       endif
     endif
   endif
 endfunction
 
 function str = __tex2enhanced__ (str, fnt, it, bld)
   persistent sym = __setup_sym_table__ ();
   persistent flds = fieldnames (sym);
@@ -2175,99 +2175,99 @@ function str = __tex2enhanced__ (str, fn
 
   for i = length (s) : -1 : 1
     ## special case for "\0"  and replace with "{/Symbol \306}'
     if (strncmp (m{i}, '\0', 2))
       str = cstrcat (str(1:s(i) - 1), '{/Symbol \306}', str(s(i) + 2:end));
     else
       f = m{i}(2:end);
       if (isfield (sym, f))
-	g = getfield(sym, f);
-	## FIXME The symbol font doesn't seem to support bold or italic
-	##if (bld)
-	##  if (it)
-	##    g = regexprep (g, '/Symbol', '/Symbol-bolditalic');
-	##  else
-	##    g = regexprep (g, '/Symbol', '/Symbol-bold');
-	##  endif
-	##elseif (it)
-	##  g = regexprep (g, '/Symbol', '/Symbol-italic');
-	##endif
+        g = getfield(sym, f);
+        ## FIXME The symbol font doesn't seem to support bold or italic
+        ##if (bld)
+        ##  if (it)
+        ##    g = regexprep (g, '/Symbol', '/Symbol-bolditalic');
+        ##  else
+        ##    g = regexprep (g, '/Symbol', '/Symbol-bold');
+        ##  endif
+        ##elseif (it)
+        ##  g = regexprep (g, '/Symbol', '/Symbol-italic');
+        ##endif
         str = cstrcat (str(1:s(i) - 1), g, str(e(i) + 1:end));
       elseif (strncmp (f, "rm", 2))
-	bld = false;
-	it = false;
+        bld = false;
+        it = false;
         str = cstrcat (str(1:s(i) - 1), '/', fnt, ' ', str(s(i) + 3:end));
       elseif (strncmp (f, "it", 2) || strncmp (f, "sl", 2))
-	it = true;
-	if (bld)
+        it = true;
+        if (bld)
           str = cstrcat (str(1:s(i) - 1), '/', fnt, '-bolditalic ', 
-			str(s(i) + 3:end));
+                        str(s(i) + 3:end));
         else
           str = cstrcat (str(1:s(i) - 1), '/', fnt, '-italic ', 
-			str(s(i) + 3:end));
+                        str(s(i) + 3:end));
         endif
       elseif (strncmp (f, "bf", 2))
-	bld = true;
-	if (it)
+        bld = true;
+        if (it)
           str = cstrcat (str(1:s(i) - 1), '/', fnt, '-bolditalic ', 
-			str(2(i) + 3:end));
+                        str(2(i) + 3:end));
         else
           str = cstrcat (str(1:s(i) - 1), '/', fnt, '-bold ', 
-			str(s(i) + 3:end));
+                        str(s(i) + 3:end));
         endif
       elseif (strcmpi (f, "color"))
-	## FIXME Ignore \color but remove trailing {} block as well
-	d = strfind(str(e(i) + 1:end),'}');
+        ## FIXME Ignore \color but remove trailing {} block as well
+        d = strfind(str(e(i) + 1:end),'}');
         if (isempty (d))
-	  warning ('syntax error in \color argument');
-	else
-	  str = cstrcat (str(1:s(i) - 1), str(e(i) + d + 1:end));
+          warning ('syntax error in \color argument');
+        else
+          str = cstrcat (str(1:s(i) - 1), str(e(i) + d + 1:end));
         endif
       elseif(strcmpi (f, "fontname"))
-	b1 = strfind(str(e(i) + 1:end),'{');
-	b2 = strfind(str(e(i) + 1:end),'}');
+        b1 = strfind(str(e(i) + 1:end),'{');
+        b2 = strfind(str(e(i) + 1:end),'}');
         if (isempty(b1) || isempty(b2))
-	  warning ('syntax error in \fontname argument');
-	else
+          warning ('syntax error in \fontname argument');
+        else
           str = cstrcat (str(1:s(i) - 1), '/', 
-			str(e(i)+b1(1) + 1:e(i)+b2(1)-1), '{}',
-			str(e(i) + b2(1) + 1:end));
+                        str(e(i)+b1(1) + 1:e(i)+b2(1)-1), '{}',
+                        str(e(i) + b2(1) + 1:end));
         endif
       elseif(strcmpi (f, "fontsize"))
-	b1 = strfind(str(e(i) + 1:end),'{');
-	b2 = strfind(str(e(i) + 1:end),'}');
+        b1 = strfind(str(e(i) + 1:end),'{');
+        b2 = strfind(str(e(i) + 1:end),'}');
         if (isempty(b1) || isempty(b2))
-	  warning ('syntax error in \fontname argument');
-	else
+          warning ('syntax error in \fontname argument');
+        else
           str = cstrcat (str(1:s(i) - 1), '/=', 
-			str(e(i)+b1(1) + 1:e(i)+b2(1)-1), '{}',
-			str(e(i) + b2(1) + 1:end));
+                        str(e(i)+b1(1) + 1:e(i)+b2(1)-1), '{}',
+                        str(e(i) + b2(1) + 1:end));
         endif
       else
-	## Last desperate attempt to treat the symbol. Look for things
-	## like \pix, that should be translated to the symbol Pi and x
-	for j = 1 : length (flds)
-	  if (strncmp (flds{j}, f, length (flds{j})))
-	    g = getfield(sym, flds{j});
-	    ## FIXME The symbol font doesn't seem to support bold or italic
-	    ##if (bld)
-	    ##  if (it)
-	    ##    g = regexprep (g, '/Symbol', '/Symbol-bolditalic');
-	    ##  else
-	    ##    g = regexprep (g, '/Symbol', '/Symbol-bold');
-	    ##  endif
-	    ##elseif (it)
-	    ##  g = regexprep (g, '/Symbol', '/Symbol-italic');
-	    ##endif
+        ## Last desperate attempt to treat the symbol. Look for things
+        ## like \pix, that should be translated to the symbol Pi and x
+        for j = 1 : length (flds)
+          if (strncmp (flds{j}, f, length (flds{j})))
+            g = getfield(sym, flds{j});
+            ## FIXME The symbol font doesn't seem to support bold or italic
+            ##if (bld)
+            ##  if (it)
+            ##    g = regexprep (g, '/Symbol', '/Symbol-bolditalic');
+            ##  else
+            ##    g = regexprep (g, '/Symbol', '/Symbol-bold');
+            ##  endif
+            ##elseif (it)
+            ##  g = regexprep (g, '/Symbol', '/Symbol-italic');
+            ##endif
             str = cstrcat (str(1:s(i) - 1), g, 
-	    		  str(s(i) + length (flds{j}) + 1:end));
-	    break;
-	  endif
-	endfor
+                          str(s(i) + length (flds{j}) + 1:end));
+            break;
+          endif
+        endfor
       endif
     endif
   endfor
 
   ## Prepend @ to things  things like _0^x or _{-100}^{100} for
   ## alignment But need to put the shorter of the two arguments first.
   ## Carful of nested {} and unprinted characters when defining
   ## shortest.. Don't have to worry about things like ^\theta as they
@@ -2276,76 +2276,76 @@ function str = __tex2enhanced__ (str, fn
   ## FIXME -- This is a mess... Is it worth it just for a "@" character?
 
   [s, m] = regexp(str,'[_\^]','start','matches');
   i = 1;
   p = 0;
   while (i < length (s))
     if (i < length(s))
       if (str(s(i) + p + 1) == "{")
-	s1 = strfind(str(s(i) + p + 2:end),'{');
-	si = 1;
-	l1 = strfind(str(s(i) + p + 1:end),'}');
+        s1 = strfind(str(s(i) + p + 2:end),'{');
+        si = 1;
+        l1 = strfind(str(s(i) + p + 1:end),'}');
         li = 1;
-	while (li <= length (l1) && si <= length (s1))
+        while (li <= length (l1) && si <= length (s1))
           if (l1(li) < s1(si))
-	    if (li == si)
-	      break;
-	    endif
-	    li++;
-	  else
-	    si++;
-	  endif
-	endwhile
-	l1 = l1 (min (length(l1), si));
+            if (li == si)
+              break;
+            endif
+            li++;
+          else
+            si++;
+          endif
+        endwhile
+        l1 = l1 (min (length(l1), si));
         if (s(i) + l1 + 1 == s(i+1))
-	  if (str(s(i + 1) + p + 1) == "{")
-	    s2 = strfind(str(s(i + 1) + p + 2:end),'{');
-	    si = 1;
-	    l2 = strfind(str(s(i + 1) + p + 1:end),'}');
+          if (str(s(i + 1) + p + 1) == "{")
+            s2 = strfind(str(s(i + 1) + p + 2:end),'{');
+            si = 1;
+            l2 = strfind(str(s(i + 1) + p + 1:end),'}');
             li = 1;
-	    while (li <= length (l2) && si <= length (s2))
+            while (li <= length (l2) && si <= length (s2))
               if (l2(li) < s2(si))
-		if (li == si)
-		  break;
-		endif
-		li++;
-	      else
-		si++;
-	      endif
-	    endwhile
-	    l2 = l2 (min (length(l2), si));
-	    if (length_string (str(s(i)+p+2:s(i)+p+l1-1)) <=
-		length_string(str(s(i+1)+p+2:s(i+1)+p+l2-1)))
-	      ## Shortest already first!
-	      str = cstrcat (str(1:s(i)+p-1), "@", str(s(i)+p:end));
-	    else
-	      ## Have to swap sub/super-script to get shortest first.
-	      str = cstrcat (str(1:s(i)+p-1), "@", str(s(i+1)+p:s(i+1)+p+l2),
-			    str(s(i)+p:s(i)+p+l1), str(s(i+1)+p+l2+1:end));
-	    endif
-	  else
-	    ## Have to swap sub/super-script to get shortest first.
-	    str = cstrcat (str(1:s(i)+p-1), "@", str(s(i+1)+p:s(i+1)+p+1),
-			  str(s(i)+p:s(i)+p+l1), str(s(i+1)+p+2:end));
-	  endif
+                if (li == si)
+                  break;
+                endif
+                li++;
+              else
+                si++;
+              endif
+            endwhile
+            l2 = l2 (min (length(l2), si));
+            if (length_string (str(s(i)+p+2:s(i)+p+l1-1)) <=
+                length_string(str(s(i+1)+p+2:s(i+1)+p+l2-1)))
+              ## Shortest already first!
+              str = cstrcat (str(1:s(i)+p-1), "@", str(s(i)+p:end));
+            else
+              ## Have to swap sub/super-script to get shortest first.
+              str = cstrcat (str(1:s(i)+p-1), "@", str(s(i+1)+p:s(i+1)+p+l2),
+                            str(s(i)+p:s(i)+p+l1), str(s(i+1)+p+l2+1:end));
+            endif
+          else
+            ## Have to swap sub/super-script to get shortest first.
+            str = cstrcat (str(1:s(i)+p-1), "@", str(s(i+1)+p:s(i+1)+p+1),
+                          str(s(i)+p:s(i)+p+l1), str(s(i+1)+p+2:end));
+          endif
           i += 2;
-	  p ++;
-	else
-	  i++;
-	endif
+          p ++;
+        else
+          i++;
+        endif
       else
-	if (s(i+1) == s(i) + 2)
-	  ## Shortest already first!
-	  str = cstrcat (str(1:s(i)+p-1), "@", str(s(i)+p:end));
-	  p ++;
+        if (s(i+1) == s(i) + 2)
+          ## Shortest already first!
+          str = cstrcat (str(1:s(i)+p-1), "@", str(s(i)+p:end));
+          p ++;
           i += 2;
-	else
-	  i ++;
-	endif
+        else
+          i ++;
+        endif
       endif
     else
       i ++;
     endif
   endwhile
 
 endfunction
 
diff --git a/scripts/plot/__next_line_color__.m b/scripts/plot/__next_line_color__.m
--- a/scripts/plot/__next_line_color__.m
+++ b/scripts/plot/__next_line_color__.m
@@ -34,17 +34,17 @@ function rgb = __next_line_color__ (rese
   if (nargin < 2)
     if (nargin == 1 && reset)
       color_rotation = get (gca (), "colororder");
       num_colors = rows (color_rotation);
       color_index = 1;
     elseif (! isempty (color_rotation))
       rgb = color_rotation(color_index,:);
       if (++color_index > num_colors)
-	color_index = 1;
+        color_index = 1;
         __next_line_style__ ("incr");
       endif
     else
       error ("__next_line_color__: color_rotation not initialized");
     endif
   else
     print_usage ();
   endif
diff --git a/scripts/plot/__next_line_style__.m b/scripts/plot/__next_line_style__.m
--- a/scripts/plot/__next_line_style__.m
+++ b/scripts/plot/__next_line_style__.m
@@ -31,17 +31,17 @@ function [linestyle, marker] = __next_li
   persistent style_index;
 
   if (nargin < 2)
     if (nargin == 1)
       if (ischar (reset) && strncmp (reset, "incr", 4))
         if (isempty (style_rotation))
           error ("__next_line_style__: style_rotation not initialized");
         elseif (++style_index > num_styles)
-	  style_index = 1;
+          style_index = 1;
         endif
       elseif (reset)
         style_rotation = strsplit (get (gca (), "linestyleorder"), "|");
         num_styles = length (style_rotation);
         style_index = 1;
       endif
     elseif (! isempty (style_rotation))
       options = __pltopt__ ("__next_line_style__", 
diff --git a/scripts/plot/__plt_get_axis_arg__.m b/scripts/plot/__plt_get_axis_arg__.m
--- a/scripts/plot/__plt_get_axis_arg__.m
+++ b/scripts/plot/__plt_get_axis_arg__.m
@@ -39,33 +39,33 @@ function [h, varargin, narg] = __plt_get
       && numel (varargin{1}) == 1 && ishandle (varargin{1}(1)) 
       && varargin{1}(1) != 0 && ! isfigure (varargin{1}(1)))
     tmp = varargin{1};
     obj = get (tmp);
     if (strcmp (obj.type, "axes") || strcmp (obj.type, "hggroup"))
       h = ancestor (tmp, "axes");
       varargin(1) = [];
       if (isempty (varargin))
-	varargin = {};
+        varargin = {};
       endif
     else
       error ("%s: expecting first argument to be axes handle", caller);
     endif
   else
     f = get (0, "currentfigure");
     if (isempty (f))
       h = [];
     else
       h = get (f, "currentaxes");
     endif
     if (isempty (h))
       if (nogca)
-	h = NaN;
+        h = NaN;
       else
-	h = gca ();
+        h = gca ();
       endif
     endif
     if (nargin < 2)
       varargin = {};
     endif
   endif
 
   if (ishandle (h) && strcmp (get (h, "nextplot"), "new"))
diff --git a/scripts/plot/ancestor.m b/scripts/plot/ancestor.m
--- a/scripts/plot/ancestor.m
+++ b/scripts/plot/ancestor.m
@@ -53,17 +53,17 @@ function p = ancestor (h, type, toplevel
           break;
         endif
         if (any (strcmpi (get (h, "type"), type)))
           p = h;
           if (look_first)
             break;
           endif
         endif
-		h = get (h, "Parent");
+                h = get (h, "Parent");
       endwhile
     else
       error ("ancestor: second argument must be a string or cell array of strings");
     endif
   else
     print_usage ();
   endif
 
diff --git a/scripts/plot/area.m b/scripts/plot/area.m
--- a/scripts/plot/area.m
+++ b/scripts/plot/area.m
@@ -115,21 +115,21 @@ function retval = __area__ (ax, x, y, bv
     addproperty ("xdata", hg, "data", x1);
     addproperty ("ydata", hg, "data", y1);
 
     addlistener (hg, "xdata", @update_data);
     addlistener (hg, "ydata", @update_data);
 
     if (i == 1)
       h = patch (ax, [x1(1), x1, fliplr(x1)], [bv, y1, bv*ones(1, length(y1))],
-		 __next_line_color__ (), "parent", hg);
+                 __next_line_color__ (), "parent", hg);
     else
       y1 = y0 + y1;
       h = patch (ax, [x1(1), x1, fliplr(x1)], [y0(1), y1, fliplr(y0)],
-		 __next_line_color__ (), "parent", hg);
+                 __next_line_color__ (), "parent", hg);
     endif
 
     y0 = y1;
 
     addproperty ("basevalue", hg, "data", bv);
     addlistener (hg, "basevalue", @move_baseline); 
 
     addproperty ("edgecolor", hg, "patchedgecolor", get (h, "edgecolor"));
@@ -166,22 +166,22 @@ function move_baseline (h, d)
   ## Don't allow recursion
   if (! recursion)
     unwind_protect
       recursion = true;
       hlist = get (h, "areagroup");
       b0 = get (h, "basevalue");
 
       for hh = hlist(:)'
-	if (hh != h)
-	  b1 = get (hh, "basevalue");
-	  if (b1 != b0)
-	    set (hh, "basevalue", b0);
-	  endif
-	endif
+        if (hh != h)
+          b1 = get (hh, "basevalue");
+          if (b1 != b0)
+            set (hh, "basevalue", b0);
+          endif
+        endif
       endfor
       update_data (h, d);
     unwind_protect_cleanup
       recursion = false;
     end_unwind_protect
   endif
 endfunction
 
diff --git a/scripts/plot/axes.m b/scripts/plot/axes.m
--- a/scripts/plot/axes.m
+++ b/scripts/plot/axes.m
@@ -39,17 +39,17 @@ function h = axes (varargin)
     endif
     tmp = __go_axes__ (cf, varargin{:});
     set (ancestor (cf, "figure"), "currentaxes", tmp);
   else
     ## arg is axes handle, make it the current axes for the current
     ## figure.
     tmp = varargin{1};
     if (length(tmp) == 1 && ishandle (tmp)
-	&& strcmp (get (tmp, "type"), "axes"))
+        && strcmp (get (tmp, "type"), "axes"))
       parent = ancestor (tmp, "figure");
       set (0, "currentfigure", parent);
       set (parent, "currentaxes", tmp);
     else
       error ("axes: expecting argument to be a scalar axes handle");
     endif
   endif
 
diff --git a/scripts/plot/axis.m b/scripts/plot/axis.m
--- a/scripts/plot/axis.m
+++ b/scripts/plot/axis.m
@@ -138,20 +138,20 @@ function curr_axis = __axis__ (ca, ax, v
   if (nargin == 1)
     if (nargout == 0)
       set (ca, "xlimmode", "auto", "ylimmode", "auto", "zlimmode", "auto");
     else
       xlim = get (ca, "xlim");
       ylim = get (ca, "ylim");
       view = get (ca, "view");
       if (view(2) == 90)
-	curr_axis = [xlim, ylim];
+        curr_axis = [xlim, ylim];
       else
-	zlim = get (ca, "zlim");
-	curr_axis = [xlim, ylim, zlim];
+        zlim = get (ca, "zlim");
+        curr_axis = [xlim, ylim, zlim];
       endif
     endif
 
   elseif (ischar (ax))
     len = length (ax);
 
     ## 'matrix mode' to reverse the y-axis
     if (strcmpi (ax, "ij"))
@@ -170,98 +170,98 @@ function curr_axis = __axis__ (ca, ax, v
       y = ylim;
       set (ca, "plotboxaspectratio", [(x(2)-x(1)), (y(2)-y(1)), 1]);
     elseif (strcmpi (ax, "normal"))
       set (ca, "plotboxaspectratiomode", "auto");
 
       ## axis limits
     elseif (len >= 4 && strcmpi (ax(1:4), "auto"))
       if (len > 4)
-	if (any (ax == "x"))
-	  set (ca, "xlimmode", "auto");
-	endif
-	if (any (ax == "y"))
-	  set (ca, "ylimmode", "auto");
-	endif
-	if (any (ax == "z"))
-	  set (ca, "zlimmode", "auto");
-	endif
+        if (any (ax == "x"))
+          set (ca, "xlimmode", "auto");
+        endif
+        if (any (ax == "y"))
+          set (ca, "ylimmode", "auto");
+        endif
+        if (any (ax == "z"))
+          set (ca, "zlimmode", "auto");
+        endif
       else
-	set (ca, "xlimmode", "auto", "ylimmode", "auto", "zlimmode", "auto");
+        set (ca, "xlimmode", "auto", "ylimmode", "auto", "zlimmode", "auto");
       endif
     elseif (strcmpi (ax, "manual"))
       ## fixes the axis limits, like axis(axis) should;
       set (ca, "xlimmode", "manual", "ylimmode", "manual", "zlimmode", "manual");
     elseif (strcmpi (ax, "tight"))
       ## sets the axis limits to the min and max of all data.
       __do_tight_option__ (ca);
       ## tic marks
     elseif (strcmpi (ax, "on") || strcmpi (ax, "tic"))
       set (ca, "xtickmode", "auto", "ytickmode", "auto", "ztickmode", "auto");
       if (strcmpi (ax, "on"))
         set (ca, "xticklabelmode", "auto", "yticklabelmode", "auto",
-	   "zticklabelmode", "auto");
+           "zticklabelmode", "auto");
       endif
       set (ca, "visible", "on");
     elseif (strcmpi (ax, "off"))
       set (ca, "xtick", [], "ytick", [], "ztick", []);
       set (ca, "visible", "off");
     elseif (len > 3 && strcmpi (ax(1:3), "tic"))
       if (any (ax == "x"))
-	set (ca, "xtickmode", "auto");
+        set (ca, "xtickmode", "auto");
       else
-	set (ca, "xtick", []);
+        set (ca, "xtick", []);
       endif
       if (any (ax == "y"))
-	set (ca, "ytickmode", "auto");
+        set (ca, "ytickmode", "auto");
       else
-	set (ca, "ytick", []);
+        set (ca, "ytick", []);
       endif
       if (any (ax == "z"))
-	set (ca, "ztickmode", "auto");
+        set (ca, "ztickmode", "auto");
       else
-	set (ca, "ztick", []);
+        set (ca, "ztick", []);
       endif
     elseif (strcmpi (ax, "label"))
       set (ca, "xticklabelmode", "auto", "yticklabelmode", "auto",
-	   "zticklabelmode", "auto");
+           "zticklabelmode", "auto");
     elseif (strcmpi (ax, "nolabel"))
       set (ca, "xticklabel", "", "yticklabel", "", "zticklabel", "");
     elseif (len > 5 && strcmpi (ax(1:5), "label"))
       if (any (ax == "x"))
-	set (ca, "xticklabelmode", "auto");
+        set (ca, "xticklabelmode", "auto");
       else
-	set (ca, "xticklabel", "");
+        set (ca, "xticklabel", "");
       endif
       if (any (ax == "y"))
-	set (ca, "yticklabelmode", "auto");
+        set (ca, "yticklabelmode", "auto");
       else
-	set (ca, "yticklabel", "");
+        set (ca, "yticklabel", "");
       endif
       if (any (ax == "z"))
-	set (ca, "zticklabelmode", "auto");
+        set (ca, "zticklabelmode", "auto");
       else
-	set (ca, "zticklabel", "");
+        set (ca, "zticklabel", "");
       endif
 
     else
       warning ("unknown axis option '%s'", ax);
     endif
 
   elseif (isvector (ax))
 
     len = length (ax);
 
     if (len != 2 && len != 4 && len != 6)
       error ("axis: expecting vector with 2, 4, or 6 elements");
     endif
 
     for i = 1:2:len
       if (ax(i) == ax(i+1))
-	error ("axis: limits(%d) cannot equal limits(%d)", i, i+1);
+        error ("axis: limits(%d) cannot equal limits(%d)", i, i+1);
       endif
     endfor
 
     if (len > 1)
       set (ca, "xlim", [ax(1), ax(2)]);
     endif
 
     if (len > 3)
diff --git a/scripts/plot/box.m b/scripts/plot/box.m
--- a/scripts/plot/box.m
+++ b/scripts/plot/box.m
@@ -40,21 +40,21 @@ function box (varargin)
       box_state = "off";
     else
       box_state = "on";
     endif
   elseif (nargs == 1)
     state = varargin{1};
     if (ischar (state))
       if (strcmpi (state, "off"))
-	box_state = "off";
+        box_state = "off";
       elseif (strcmpi (state, "on"))
-	box_state = "on";
+        box_state = "on";
       else
-	print_usage ();
+        print_usage ();
       endif
     endif
   else
     print_usage ();
   endif
 
   set (h, "box", box_state);
 
diff --git a/scripts/plot/cla.m b/scripts/plot/cla.m
--- a/scripts/plot/cla.m
+++ b/scripts/plot/cla.m
@@ -30,27 +30,27 @@
 ## Created: 2008-10-03
 
 function cla (varargin)
 
   if (nargin > 2)
     print_usage ();
   elseif (nargin > 1)
     if (ishandle (varargin{1})
-	&& strcmp (get (varargin{1}, "type"), "axes")
-	&& ischar (varargin{2}) && strcmpi (varargin{2}, "reset"))
+        && strcmp (get (varargin{1}, "type"), "axes")
+        && ischar (varargin{2}) && strcmpi (varargin{2}, "reset"))
       oldhax = gca;
       hax = varargin{1};
       do_reset = true;
     else
       print_usage ();
     endif
   elseif (nargin == 1)
     if (ishandle (varargin{1})
-	&& strcmp (get (varargin{1}, "type"), "axes"))
+        && strcmp (get (varargin{1}, "type"), "axes"))
       oldhax = gca;
       hax = varargin{1};
       do_reset = false;
     elseif (ischar (varargin{1}) && strcmpi (varargin{1}, "reset"))
       hax = gca;
       oldhax = hax;
       do_reset = true;
     else
diff --git a/scripts/plot/clabel.m b/scripts/plot/clabel.m
--- a/scripts/plot/clabel.m
+++ b/scripts/plot/clabel.m
@@ -62,20 +62,20 @@ function retval = clabel (c, varargin)
 
   if (nargin < 1)
     print_usage()
   elseif (nargin == 1)
     hparent = gca ();
   else
     arg = varargin{1};
     if (isscalar (arg) && ishandle(arg) && 
-	strcmp (get (arg, "type"), "hggroup"))
+        strcmp (get (arg, "type"), "hggroup"))
       obj = get (arg);
       if (! isfield (obj, "contourmatrix"))
-	error ("clabel: expecting the handle to be a contour group");
+        error ("clabel: expecting the handle to be a contour group");
       endif
       hg = arg;
       have_hg = true;
       varargin(1) = [];
     else
       hparent = gca ();
     endif
   endif
@@ -102,26 +102,26 @@ function retval = clabel (c, varargin)
     if (strcmpi (arg, "manual"))
       error ("clabel: manual contouring mode not supported");
     endif
   endfor
 
   if (have_hg)
     if (! isempty (v))
       if (have_labelspacing)
-	set (hg, "textlistmode", "manual", "textlist", v, 
-	     "labelspacing", label_spacing, "showtext", "on");
+        set (hg, "textlistmode", "manual", "textlist", v, 
+             "labelspacing", label_spacing, "showtext", "on");
       else
-	set (hg, "textlistmode", "manual", "textlist", v, "showtext", "on");
+        set (hg, "textlistmode", "manual", "textlist", v, "showtext", "on");
       endif
     else
       if (have_labelspacing)
-	set (hg,"showtext", "on", "labelspacing", label_spacing);
+        set (hg,"showtext", "on", "labelspacing", label_spacing);
       else
-	set (hg,"showtext", "on");
+        set (hg,"showtext", "on");
       endif
     endif
     retval = findobj (hg, "type", "text");
     if (! isempty (varargin))
       set (retval, varargin {:});
     endif
   else
     retval =  __clabel__ (c, v, hparent, label_spacing, [], varargin{:});
diff --git a/scripts/plot/clf.m b/scripts/plot/clf.m
--- a/scripts/plot/clf.m
+++ b/scripts/plot/clf.m
@@ -32,17 +32,17 @@
 ## Author: jwe
 
 function clf (varargin)
 
   if (nargin > 2)
     print_usage ();
   elseif (nargin > 1)
     if (isfigure (varargin{1}) && ischar (varargin{2})
-	&& strcmpi (varargin{2}, "reset"))
+        && strcmpi (varargin{2}, "reset"))
       oldfig = gcf;
       hfig = varargin{1};
       do_reset = true;
     else
       print_usage ();
     endif
   elseif (nargin == 1)
     if (isfigure (varargin{1}))
diff --git a/scripts/plot/close.m b/scripts/plot/close.m
--- a/scripts/plot/close.m
+++ b/scripts/plot/close.m
@@ -44,18 +44,18 @@ function retval = close (arg1, arg2)
     if (ischar (arg1) && strcmpi (arg1, "all"))
       close_all_figures (false);
     elseif (isfigure (arg1))
       figs = arg1;
     else
       error ("close: expecting argument to be \"all\" or a figure handle");
     endif
   elseif (nargin == 2
-	  && ischar (arg1) && strcmpi (arg1, "all")
-	  && ischar (arg2) && strcmpi (arg2, "hidden"))
+          && ischar (arg1) && strcmpi (arg1, "all")
+          && ischar (arg2) && strcmpi (arg2, "hidden"))
     close_all_figures (true);
   else
     print_usage ();
   endif
 
   for h = figs
     __go_execute_callback__ (h, "closerequestfcn");
   endfor
diff --git a/scripts/plot/colorbar.m b/scripts/plot/colorbar.m
--- a/scripts/plot/colorbar.m
+++ b/scripts/plot/colorbar.m
@@ -53,34 +53,34 @@ function h = colorbar (varargin)
   deleting = false;
 
   i = 1;
   while (i <= nargin)
     arg = varargin {i++};
 
     if (ischar(arg))
       if (strcmpi (arg, "peer"))
-	if (i > nargin)
-	  error ("colorbar: missing axes handle after \"peer\"");
-	else
-	  ax = varargin{i++};
-	  if (!isscalar (ax) || ! ishandle (ax)
-	      || ! strcmp (get (ax, "type"), "axes"))
-	    error ("colorbar: expecting an axes handle following \"peer\"");
-	  endif
-	endif
+        if (i > nargin)
+          error ("colorbar: missing axes handle after \"peer\"");
+        else
+          ax = varargin{i++};
+          if (!isscalar (ax) || ! ishandle (ax)
+              || ! strcmp (get (ax, "type"), "axes"))
+            error ("colorbar: expecting an axes handle following \"peer\"");
+          endif
+        endif
       elseif (strcmpi (arg, "north") || strcmpi (arg, "south")
-	      || strcmpi (arg, "east") || strcmpi (arg, "west")
-	      || strcmpi (arg, "northoutside") || strcmpi (arg, "southoutside")
-	      || strcmpi (arg, "eastoutside") || strcmpi (arg, "westoutside"))
-	loc = tolower (arg);
+              || strcmpi (arg, "east") || strcmpi (arg, "west")
+              || strcmpi (arg, "northoutside") || strcmpi (arg, "southoutside")
+              || strcmpi (arg, "eastoutside") || strcmpi (arg, "westoutside"))
+        loc = tolower (arg);
       elseif (strcmpi (arg, "off") || strcmpi (arg, "none"))
-	deleting = true;
+        deleting = true;
       else
-	args{end+1} = arg;
+        args{end+1} = arg;
       endif
     else
       args{end+1} = arg;
     endif
   endwhile
 
   if (isempty (ax))
     ax = gca ();
@@ -104,56 +104,56 @@ function h = colorbar (varargin)
     cext = get (ax, "clim");
     cdiff = (cext(2) - cext(1)) / clen / 2;
     cmin = cext(1) + cdiff;
     cmax = cext(2) - cdiff;
 
     orig_pos = obj.position;
     orig_opos = obj.outerposition;
     [pos, cpos, vertical, mirror] =  ...
-	__position_colorbox__ (loc, obj, ancestor (ax, "figure"));
+        __position_colorbox__ (loc, obj, ancestor (ax, "figure"));
     set (ax, "activepositionproperty", "position", "position", pos);
 
     cax = __go_axes__ (get (ax, "parent"), "tag", "colorbar", 
-    		       "handlevisibility", "on", 
-		       "activepositionproperty", "position", 
-		       "position", cpos);
+                       "handlevisibility", "on", 
+                       "activepositionproperty", "position", 
+                       "position", cpos);
     addproperty ("location", cax, "radio",
-		 "eastoutside|east|westoutside|west|northoutside|north|southoutside|south",
-		 loc);
+                 "eastoutside|east|westoutside|west|northoutside|north|southoutside|south",
+                 loc);
     addproperty ("axes", cax, "handle", ax);
 
     if (vertical)
       hi = image (cax, [0,1], [cmin, cmax], [1 : clen]');
       if (mirror)
-	set (cax, "xtick", [], "xdir", "normal", "ydir", "normal",
-	     "ylim", cext, "ylimmode", "manual",
-	     "yaxislocation", "right", args{:});
+        set (cax, "xtick", [], "xdir", "normal", "ydir", "normal",
+             "ylim", cext, "ylimmode", "manual",
+             "yaxislocation", "right", args{:});
       else
-	set (cax, "xtick", [], "xdir", "normal", "ydir", "normal",
-	     "ylim", cext, "ylimmode", "manual",
-	     "yaxislocation", "left", args{:});
+        set (cax, "xtick", [], "xdir", "normal", "ydir", "normal",
+             "ylim", cext, "ylimmode", "manual",
+             "yaxislocation", "left", args{:});
       endif
     else
       hi = image (cax, [cmin, cmax], [0,1], [1 : clen]);
       if (mirror)
-	set (cax, "ytick", [], "xdir", "normal", "ydir", "normal",
-	     "xlim", cext, "xlimmode", "manual",
-	     "xaxislocation", "top", args{:});
+        set (cax, "ytick", [], "xdir", "normal", "ydir", "normal",
+             "xlim", cext, "xlimmode", "manual",
+             "xaxislocation", "top", args{:});
       else
-	set (cax, "ytick", [], "xdir", "normal", "ydir", "normal",
-	     "xlim", cext, "xlimmode", "manual",
-	     "xaxislocation", "bottom", args{:});
+        set (cax, "ytick", [], "xdir", "normal", "ydir", "normal",
+             "xlim", cext, "xlimmode", "manual",
+             "xaxislocation", "bottom", args{:});
       endif
     endif
 
     ctext = text (0, 0, "", "tag", "colorbar","visible", "off", 
-		  "handlevisibility", "off", "xliminclude", "off",  
-		  "yliminclude", "off", "zliminclude", "off",
-		  "deletefcn", {@deletecolorbar, cax, orig_pos, orig_opos});
+                  "handlevisibility", "off", "xliminclude", "off",  
+                  "yliminclude", "off", "zliminclude", "off",
+                  "deletefcn", {@deletecolorbar, cax, orig_pos, orig_opos});
 
     set (cax, "deletefcn", {@resetaxis, orig_pos, orig_opos});
 
     addlistener (ax, "clim", {@update_colorbar_clim, hi, vertical})
     addlistener (ax, "plotboxaspectratio", {@update_colorbar_axis, cax})
     addlistener (ax, "plotboxaspectratiomode", {@update_colorbar_axis, cax})
     addlistener (ax, "position", {@update_colorbar_axis, cax})
 
@@ -168,17 +168,17 @@ function deletecolorbar (h, d, hc, pos, 
   ## Don't delete the colorbar and reset the axis size if the
   ## parent figure is being deleted.
   if (ishandle (hc) && strcmp (get (hc, "type"), "axes") && 
       (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")))
     if (strcmp (get (hc, "beingdeleted"), "off"))
       delete (hc);
     endif
     if (!isempty (ancestor (h, "axes")) &&
-	strcmp (get (ancestor (h, "axes"), "beingdeleted"), "off"))
+        strcmp (get (ancestor (h, "axes"), "beingdeleted"), "off"))
       set (ancestor (h, "axes"), "position", pos, "outerposition", opos);
     endif
   endif
 endfunction
 
 function resetaxis (h, d, pos, opos)
   if (ishandle (h) && strcmp (get (h, "type"), "axes") && 
       (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")) &&
@@ -207,66 +207,66 @@ function update_colorbar_clim (h, d, hi,
 endfunction
 
 function update_colorbar_axis (h, d, cax)
   if (ishandle (cax) && strcmp (get (cax, "type"), "axes") && 
       (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")))
     loc = get (cax, "location");
     obj = get (h);
     [pos, cpos, vertical, mirror] =  ...
-	__position_colorbox__ (loc, obj, ancestor (h, "figure"));
+        __position_colorbox__ (loc, obj, ancestor (h, "figure"));
 
     if (vertical)
       if (mirror)
-	set (cax, "xtick", [], "xdir", "normal", "ydir", "normal",
-	     "yaxislocation", "right", "position", cpos);
+        set (cax, "xtick", [], "xdir", "normal", "ydir", "normal",
+             "yaxislocation", "right", "position", cpos);
       else
-	set (cax, "xtick", [], "xdir", "normal", "ydir", "normal",
-	     "yaxislocation", "left", "position", cpos);
+        set (cax, "xtick", [], "xdir", "normal", "ydir", "normal",
+             "yaxislocation", "left", "position", cpos);
       endif
     else
       if (mirror)
-	set (cax, "ytick", [], "xdir", "normal", "ydir", "normal",
-	     "xaxislocation", "top", "position", cpos);
+        set (cax, "ytick", [], "xdir", "normal", "ydir", "normal",
+             "xaxislocation", "top", "position", cpos);
       else
-	set (cax, "ytick", [], "xdir", "normal", "ydir", "normal",
-	     "xaxislocation", "bottom", "position", cpos);
+        set (cax, "ytick", [], "xdir", "normal", "ydir", "normal",
+             "xaxislocation", "bottom", "position", cpos);
       endif
     endif
 
   endif
 endfunction
 
 function [pos, cpos, vertical, mirr] = __position_colorbox__ (cbox, obj, cf)
 
   pos = obj.position;
   sz = pos(3:4);
 
   off = 0;
   if (strcmpi (obj.plotboxaspectratiomode, "manual"))
     r = obj.plotboxaspectratio;
     if (pos(3) > pos(4))
       switch (cbox)
-	case {"east", "eastoutside", "west", "westoutside"}
-	  off = [(pos(3) - pos(4)) ./ (r(2) / r(1)), 0];	  
+        case {"east", "eastoutside", "west", "westoutside"}
+          off = [(pos(3) - pos(4)) ./ (r(2) / r(1)), 0];          
       endswitch
     else
       switch (cbox)
-	case {"north", "northoutside", "south", "southoutside"}
-	  off = [0, (pos(4) - pos(3)) ./ (r(1) / r(2))];
-	  ## This shouldn't be here except that gnuplot doesn't have a
-	  ## square window and so a square aspect ratio is not square.
-	  ## The corrections are empirical.
-	  if (strcmp (get (cf, "__backend__"), "gnuplot"))
-	    if (length (cbox) > 7 && strcmp (cbox(end-6:end),"outside"))
-	      off = off / 2;
-	    else
-	      off = off / 1.7;
-	    endif
-	  endif
+        case {"north", "northoutside", "south", "southoutside"}
+          off = [0, (pos(4) - pos(3)) ./ (r(1) / r(2))];
+          ## This shouldn't be here except that gnuplot doesn't have a
+          ## square window and so a square aspect ratio is not square.
+          ## The corrections are empirical.
+          if (strcmp (get (cf, "__backend__"), "gnuplot"))
+            if (length (cbox) > 7 && strcmp (cbox(end-6:end),"outside"))
+              off = off / 2;
+            else
+              off = off / 1.7;
+            endif
+          endif
       endswitch
     endif
     off = off / 2;
   endif
 
   switch (cbox)
     case "northoutside"
       origin = pos(1:2) + [0., 0.9] .* sz + [1, -1] .* off;
diff --git a/scripts/plot/comet.m b/scripts/plot/comet.m
--- a/scripts/plot/comet.m
+++ b/scripts/plot/comet.m
@@ -34,17 +34,17 @@
 ## Author: Ben Abbott bpabbott@mac.com
 ## Created: 2008-09-21
 
 function comet (varargin)
 
   if (nargin == 0)
     print_usage ();
   elseif (numel (varargin{1}) == 1 && ishandle (varargin{1})
-	  && strcmpi (get (varargin{1}, "type"), "axes"))
+          && strcmpi (get (varargin{1}, "type"), "axes"))
     axes (varargin{1});
     varargin = varargin(2:end);
     numargin = nargin - 1;
   else
     numargin = nargin;
   endif
 
   p = 0.1;
diff --git a/scripts/plot/compass.m b/scripts/plot/compass.m
--- a/scripts/plot/compass.m
+++ b/scripts/plot/compass.m
@@ -65,21 +65,21 @@ function retval = compass (varargin)
 
   line_spec = "b-";
   have_line_spec = false;
   while (ioff <= nargin)
     arg = varargin{ioff++};
     if ((ischar (arg) || iscell (arg)) && ! have_line_spec)
       [linespec, valid] = __pltopt__ ("compass", arg, false);
       if (valid)
-	line_spec = arg;
-	have_line_spec = true;
-	break;
+        line_spec = arg;
+        have_line_spec = true;
+        break;
       else
-	error ("compass: invalid linespec");
+        error ("compass: invalid linespec");
       endif
     else
       error ("compass: unrecognized argument");
     endif
   endwhile
 
   ## Matlab draws compass plots, with the arrow head as one continous 
   ## line, and each arrow separately. This is completely different than 
diff --git a/scripts/plot/contourf.m b/scripts/plot/contourf.m
--- a/scripts/plot/contourf.m
+++ b/scripts/plot/contourf.m
@@ -63,17 +63,17 @@ function [c, h] = contourf (varargin)
 
   [xh, varargin] = __plt_get_axis_arg__ ("contour", varargin{:});
 
   oldh = gca ();
   unwind_protect
     axes (xh);
     newplot ();
     [ctmp, htmp] = __contour__ (xh, "none", "fill", "on",
-				"linecolor", "black", varargin{:});
+                                "linecolor", "black", varargin{:});
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
   if (nargout > 0)
     c = ctmp;
     h = htmp;
   endif
diff --git a/scripts/plot/cylinder.m b/scripts/plot/cylinder.m
--- a/scripts/plot/cylinder.m
+++ b/scripts/plot/cylinder.m
@@ -43,17 +43,17 @@
 ## @end group
 ## @end example
 ## @seealso{sphere}
 ## @end deftypefn
 
 function [xx, yy, zz] = cylinder (varargin)
 
   [ax, args, nargs] = __plt_get_axis_arg__ ((nargout > 0), "cylinder", 
-					    varargin{:});
+                                            varargin{:});
 
   if (nargs == 0)
     n = 20;
     r = [1, 1];
   elseif (nargs == 1)
     n = 20;
     r = args{1};
   elseif (nargs == 2)
diff --git a/scripts/plot/ellipsoid.m b/scripts/plot/ellipsoid.m
--- a/scripts/plot/ellipsoid.m
+++ b/scripts/plot/ellipsoid.m
@@ -27,17 +27,17 @@
 ## @seealso{sphere}
 ## @end deftypefn
 
 ## Author: Sylvain Pelissier <sylvain.pelissier@gmail.com>
 
 function [xx, yy, zz] = ellipsoid (varargin)
 
   [h, varargin, nargin] = __plt_get_axis_arg__ ((nargout > 0), "ellipsoid", 
-						varargin{:});
+                                                varargin{:});
 
   if (nargin != 6 && nargin != 7)
     print_usage ();
   endif
 
   xc = varargin{1};
   yc = varargin{2};
   zc = varargin{3};
diff --git a/scripts/plot/feather.m b/scripts/plot/feather.m
--- a/scripts/plot/feather.m
+++ b/scripts/plot/feather.m
@@ -65,21 +65,21 @@ function retval = feather (varargin)
 
   line_spec = "b-";
   have_line_spec = false;
   while (ioff <= nargin)
     arg = varargin{ioff++};
     if ((ischar (arg) || iscell (arg)) && ! have_line_spec)
       [linespec, valid] = __pltopt__ ("feather", arg, false);
       if (valid)
-	line_spec = arg;
-	have_line_spec = false;
-	break;
+        line_spec = arg;
+        have_line_spec = false;
+        break;
       else
-	error ("feather: invalid linespec");
+        error ("feather: invalid linespec");
       endif
     else
       error ("feather: unrecognized argument");
     endif
   endwhile
 
   ## Matlab draws feather plots, with the arrow head as one continous 
   ## line, and each arrow separately. This is completely different than 
diff --git a/scripts/plot/fill.m b/scripts/plot/fill.m
--- a/scripts/plot/fill.m
+++ b/scripts/plot/fill.m
@@ -33,24 +33,24 @@ function retval = fill (varargin)
   iargs = __find_patches__ (varargin{:});
 
   oldh = gca ();
   unwind_protect
     axes (h);
 
     for i = 1 : length (iargs)
       if (i == length (iargs))
-	args = varargin (iargs(i):end);
+        args = varargin (iargs(i):end);
       else
         args = varargin (iargs(i):iargs(i+1)-1);
       endif
       newplot ();
       [tmp, fail] = __patch__ (h, args{:});
       if (fail)
-	print_usage();
+        print_usage();
       endif
       htmp (end + 1) = tmp;
     endfor
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
   if (nargout > 0)
@@ -60,53 +60,53 @@ function retval = fill (varargin)
 endfunction
 
 function iargs = __find_patches__ (varargin)
   iargs = [];
   i = 1;
   while (i < nargin)
     iargs (end + 1) = i;
     if (ischar (varargin{i})
-	&& (strcmpi (varargin{i}, "faces")
-	    || strcmpi (varargin{i}, "vertices")))
+        && (strcmpi (varargin{i}, "faces")
+            || strcmpi (varargin{i}, "vertices")))
       i += 4;
     elseif (isnumeric (varargin{i}))
       i += 2;
     endif
 
     if (i <= nargin)
       while (true);
-	if (ischar (varargin{i}) && 
-	    (strcmpi (varargin{i}, "faces")
-	     || strcmpi (varargin{i}, "vertices")))
-	  break;
-	elseif (isnumeric (varargin{i}))
-	  ## Assume its the colorspec
-	  i++;
-	  break;
-	elseif (ischar (varargin{i}))
-	  colspec = tolower (varargin{i});
-	  collen = length (colspec);
+        if (ischar (varargin{i}) && 
+            (strcmpi (varargin{i}, "faces")
+             || strcmpi (varargin{i}, "vertices")))
+          break;
+        elseif (isnumeric (varargin{i}))
+          ## Assume its the colorspec
+          i++;
+          break;
+        elseif (ischar (varargin{i}))
+          colspec = tolower (varargin{i});
+          collen = length (colspec);
 
-	  if (strncmp (colspec, "blue", collen)
-	      || strncmp (colspec, "black", collen)
-	      || strncmp (colspec, "k", collen)
-	      || strncmp (colspec, "black", collen)
-	      || strncmp (colspec, "red", collen)
-	      || strncmp (colspec, "green", collen)
-	      || strncmp (colspec, "yellow", collen)
-	      || strncmp (colspec, "magenta", collen)
-	      || strncmp (colspec, "cyan", collen)
-	      || strncmp (colspec, "white", collen))
-	    i++;
-	    break;
-	  endif
-	else
-	  i += 2;
-	endif
+          if (strncmp (colspec, "blue", collen)
+              || strncmp (colspec, "black", collen)
+              || strncmp (colspec, "k", collen)
+              || strncmp (colspec, "black", collen)
+              || strncmp (colspec, "red", collen)
+              || strncmp (colspec, "green", collen)
+              || strncmp (colspec, "yellow", collen)
+              || strncmp (colspec, "magenta", collen)
+              || strncmp (colspec, "cyan", collen)
+              || strncmp (colspec, "white", collen))
+            i++;
+            break;
+          endif
+        else
+          i += 2;
+        endif
       endwhile
     endif
   endwhile
 endfunction
 
 %!demo
 %! clf
 %! t1 = (1/16:1/8:1)'*2*pi;
diff --git a/scripts/plot/findobj.m b/scripts/plot/findobj.m
--- a/scripts/plot/findobj.m
+++ b/scripts/plot/findobj.m
@@ -79,25 +79,25 @@ function h = findobj (varargin)
       endif
     else
       ## Return [](0x1) for compatibility.
       h = zeros (0, 1);
       return;
     endif
     if (n1 <= nargin)
       if (ischar (varargin{n1}))
-	if (strcmpi (varargin{n1}, "flat"))
-	  depth = 0;
-	  n1 = n1 + 1;
-	elseif (strcmpi (varargin{n1}, "-depth"))
-	  depth = varargin{n1+1};
-	  n1 = n1 + 2;
-	endif
+        if (strcmpi (varargin{n1}, "flat"))
+          depth = 0;
+          n1 = n1 + 1;
+        elseif (strcmpi (varargin{n1}, "-depth"))
+          depth = varargin{n1+1};
+          n1 = n1 + 2;
+        endif
       else
-	error ("findobj: properties and options must be strings");
+        error ("findobj: properties and options must be strings");
       endif
     endif
   endif
 
   if (n1 <= nargin && nargin > 0)
     args = varargin(n1 : nargin);
   else
     args = {};
@@ -112,77 +112,77 @@ function h = findobj (varargin)
   na = 1;
 
   while (na <= numel (args))
     regularexpression(np) = 0;
     property(np) = 0;
     logicaloperator{np} = "and";
     if (ischar (args{na}))
       if (strcmpi (args{na}, "-regexp"))
-	if (na + 2 <= numel (args))
-	  regularexpression(np) = 1;
-	  na = na + 1;
-	  pname{np} = args{na};
-	  na = na + 1;
-	  pvalue{np} = args{na};
-	  na = na + 1;
-	  np = np + 1;
-	else
-	  error ("findobj: inconsistent number of arguments");
-	endif
+        if (na + 2 <= numel (args))
+          regularexpression(np) = 1;
+          na = na + 1;
+          pname{np} = args{na};
+          na = na + 1;
+          pvalue{np} = args{na};
+          na = na + 1;
+          np = np + 1;
+        else
+          error ("findobj: inconsistent number of arguments");
+        endif
       elseif (strcmpi (args{na}, "-property"))
-	if (na + 1 <= numel (args))
-	  na = na + 1;
-	  property(np) = 1;
-	  pname{np} = args{na};
-	  na = na + 1;
-	  pvalue{np} = [];
-	  np = np + 1;
-	else
-	  error ("findobj: inconsistent number of arguments");
-	endif
+        if (na + 1 <= numel (args))
+          na = na + 1;
+          property(np) = 1;
+          pname{np} = args{na};
+          na = na + 1;
+          pvalue{np} = [];
+          np = np + 1;
+        else
+          error ("findobj: inconsistent number of arguments");
+        endif
       elseif (! strcmp (args{na}(1), "-"))
-	## Parameter/value pairs.
-	if (na + 1 <= numel (args))
-	  pname{np} = args{na};
-	  na = na + 1;
-	  pvalue{np} = args{na};
-	  na = na + 1;
-	  if (na <= numel(args))
-	    if (ischar (args{na}))
-	      if strcmpi(args{na}, "-and")
-		logicaloperator{np} = "and";
-		na = na+1;
-	      elseif strcmpi(args{na}, "-or")
-		logicaloperator{np} = "or";
-		na = na+1;
-	      elseif strcmpi(args{na}, "-xor")
-		logicaloperator{np} = "xor";
-		na = na+1;
-	      elseif strcmpi(args{na}, "-not")
-		logicaloperator{np} = "not";
-		na = na+1;
-	      endif
-	    else
-	      error ("findobj: properties and options must be strings");
-	    endif
-	  else
-	    logicaloperator{np} = "and";
-	  endif
-	  np = np + 1;
-	else
-	  error ("findobj: inconsistent number of arguments");
-	endif
+        ## Parameter/value pairs.
+        if (na + 1 <= numel (args))
+          pname{np} = args{na};
+          na = na + 1;
+          pvalue{np} = args{na};
+          na = na + 1;
+          if (na <= numel(args))
+            if (ischar (args{na}))
+              if strcmpi(args{na}, "-and")
+                logicaloperator{np} = "and";
+                na = na+1;
+              elseif strcmpi(args{na}, "-or")
+                logicaloperator{np} = "or";
+                na = na+1;
+              elseif strcmpi(args{na}, "-xor")
+                logicaloperator{np} = "xor";
+                na = na+1;
+              elseif strcmpi(args{na}, "-not")
+                logicaloperator{np} = "not";
+                na = na+1;
+              endif
+            else
+              error ("findobj: properties and options must be strings");
+            endif
+          else
+            logicaloperator{np} = "and";
+          endif
+          np = np + 1;
+        else
+          error ("findobj: inconsistent number of arguments");
+        endif
       else
-	## This is sloppy ... but works like Matlab.
-	if strcmpi(args{na}, "-not")
-	  h = [];
-	  return
-	endif
-	na = na + 1;
+        ## This is sloppy ... but works like Matlab.
+        if strcmpi(args{na}, "-not")
+          h = [];
+          return
+        endif
+        na = na + 1;
       endif
     else
       error ("findobj: properties and options must be strings");
     endif
   endwhile
 
   numpairs = np - 1;
   
@@ -199,46 +199,46 @@ function h = findobj (varargin)
     idepth = idepth + 1;
   endwhile
 
   keepers = ones (size (h));
   if (numpairs > 0)
     for nh = 1 : numel(h)
       p = get (h (nh));
       for np = 1 : numpairs
-	fields = fieldnames (p);
-	fieldindex = find (strcmpi (fields, pname{np}), 1);
-	if (numel (fieldindex))
+        fields = fieldnames (p);
+        fieldindex = find (strcmpi (fields, pname{np}), 1);
+        if (numel (fieldindex))
           pname{np} = fields{fieldindex};
           if (property(np))
             match = 1;
           else
             if (regularexpression(np))
-	      match = regexp (p.(pname{np}), pvalue{np});
+              match = regexp (p.(pname{np}), pvalue{np});
               if isempty (match)
                 match = 0;
               endif
             elseif (numel (p.(pname{np})) == numel (pvalue{np}))
-	      if (ischar (pvalue{np}))
-		match = strcmpi (pvalue{np}, p.(pname{np}));
-	      else
-		match = (pvalue{np} == p.(pname{np}));
-	      endif
+              if (ischar (pvalue{np}))
+                match = strcmpi (pvalue{np}, p.(pname{np}));
+              else
+                match = (pvalue{np} == p.(pname{np}));
+              endif
             else
-	      match = 0;
+              match = 0;
             endif
             match = all (match);
           endif
           if (strcmpi (logicaloperator{np}, "not"))
             keepers(nh) = ! keepers(nh) & ! match;
           else
             keepers(nh) = feval (logicaloperator{np}, keepers(nh), match);
           endif
-	else
-	  keepers(nh) = 0;
-	endif
+        else
+          keepers(nh) = 0;
+        endif
       endfor
     endfor
   endif
 
   h = h (keepers != 0);
   h = reshape (h, [numel(h), 1]);
 endfunction
diff --git a/scripts/plot/fplot.m b/scripts/plot/fplot.m
--- a/scripts/plot/fplot.m
+++ b/scripts/plot/fplot.m
@@ -87,17 +87,17 @@ function fplot (fn, limits, n, linespec)
     n = 8;
     x = linspace (limits(1), limits(2), n)';
     y = feval (fn, x);
 
     while (n < 2 .^ 20)
       y00 = interp1 (x0, y0, x, "linear");
       err = 0.5 * max (abs ((y00 - y) ./ (y00 + y))(:));
       if (err == err0 || 0.5 * max (abs ((y00 - y) ./ (y00 + y))(:)) < tol)
-	break;
+        break;
       endif
       x0 = x;
       y0 = y;
       err0 = err;
       n = 2 * (n - 1) + 1;
       x = linspace (limits(1), limits(2), n)';
       y = feval (fn, x);
     endwhile 
diff --git a/scripts/plot/gnuplot_drawnow.m b/scripts/plot/gnuplot_drawnow.m
--- a/scripts/plot/gnuplot_drawnow.m
+++ b/scripts/plot/gnuplot_drawnow.m
@@ -65,19 +65,19 @@ function gnuplot_drawnow (h, term, file,
       endif
     unwind_protect_cleanup
       set (h, "__plot_stream__", default_plot_stream);
       if (! isempty (plot_stream))
         pclose (plot_stream(1));
         if (numel (plot_stream) > 1)
           pclose (plot_stream(2));
         endif
-	if (numel (plot_stream) > 2)
-	  waitpid (plot_stream(3));
-	endif
+        if (numel (plot_stream) > 2)
+          waitpid (plot_stream(3));
+        endif
       endif
       if (! isempty (fid))
         fclose (fid);
       endif
     end_unwind_protect
   elseif (nargin == 1)
     ##  Graphics terminal for display.
     plot_stream = get (h, "__plot_stream__");
@@ -104,18 +104,18 @@ function gnuplot_drawnow (h, term, file,
         pause (0.1);
         fid = fopen (dumb_tmp_file, 'r');
       endwhile
       ## reprint the plot on screen
       [a, count] = fscanf (fid, '%c', Inf);
       fclose (fid);
       if (count>0)
         if (a(1)==12)
-       	  ## avoid ^L at the beginning
-	  a = a(2:end);
+          ## avoid ^L at the beginning
+          a = a(2:end);
         end
         puts (a);
       end
       unlink (dumb_tmp_file);
     endif
   else
     print_usage ();
   endif
@@ -185,81 +185,81 @@ function [enhanced, implicit_margin] = g
         endif
         if (! isempty (title_str))
           title_str = sprintf ("title \"%s\"", title_str);
         endif
       else
         title_str = "";
       endif
       if (! (any (strfind (opts_str, " size ") > 0) 
-	  || any (strfind (opts_str, "size ") == 1)))
+          || any (strfind (opts_str, "size ") == 1)))
         ## Convert position to units used by gnuplot.
         if (output_to_screen (term))
           ## Get figure size in pixels.  Rely on listener
-	  ## to handle coversion of position property.
-	  units = get (h, "units");
-	  unwind_protect
-	    set (h, "units", "pixels");
-	    position_in_pixesl = get (h, "position");
-	  unwind_protect_cleanup
-	    set (h, "units", units);
-	  end_unwind_protect
-	  gnuplot_pos = position_in_pixesl(1:2);
-	  gnuplot_size = position_in_pixesl(3:4);
+          ## to handle coversion of position property.
+          units = get (h, "units");
+          unwind_protect
+            set (h, "units", "pixels");
+            position_in_pixesl = get (h, "position");
+          unwind_protect_cleanup
+            set (h, "units", units);
+          end_unwind_protect
+          gnuplot_pos = position_in_pixesl(1:2);
+          gnuplot_size = position_in_pixesl(3:4);
         else
           ## Get size of the printed plot in inches. Rely on listener
-	  ## to handle coversion of papersize property.
-	  paperunits = get (h, "paperunits");
-	  unwind_protect
-	    set (h, "paperunits", "inches");
+          ## to handle coversion of papersize property.
+          paperunits = get (h, "paperunits");
+          unwind_protect
+            set (h, "paperunits", "inches");
             gnuplot_size = get (h, "papersize");
-	  unwind_protect_cleanup
-	    set (h, "paperunits", paperunits);
-	  end_unwind_protect
+          unwind_protect_cleanup
+            set (h, "paperunits", paperunits);
+          end_unwind_protect
           if (term_units_are_pixels (term))
-	    ## Convert to inches using the property set by print().
-	    gnuplot_size = gnuplot_size * get (h, "__pixels_per_inch__");
-	  else
-	    ## Implicit margins are in units of "inches"
-	    gnuplot_size = gnuplot_size - implicit_margin;
+            ## Convert to inches using the property set by print().
+            gnuplot_size = gnuplot_size * get (h, "__pixels_per_inch__");
+          else
+            ## Implicit margins are in units of "inches"
+            gnuplot_size = gnuplot_size - implicit_margin;
           endif
         endif
-	[begin_match, end_match, te, match] = regexp (opts_str, "(\\s-r\\d+)|(^-r\\d+)");
-	if (! isempty (begin_match))
-	  error ("gnuplot_drawnow.m: specifying resultion, '%s', not supported for terminal '%s'",
-	         strtrim (match{1}), term)
-	endif
+        [begin_match, end_match, te, match] = regexp (opts_str, "(\\s-r\\d+)|(^-r\\d+)");
+        if (! isempty (begin_match))
+          error ("gnuplot_drawnow.m: specifying resultion, '%s', not supported for terminal '%s'",
+                 strtrim (match{1}), term)
+        endif
         if (all (gnuplot_size > 0))
           ## Set terminal size.
           terminals_with_size = {"emf", "gif", "jpeg", "latex", "pbm", ...
                                  "pdf", "png", "postscript", "svg", ...
                                  "epslatex", "pstex", "pslatex", "tikz"};
           if (__gnuplot_has_feature__ ("x11_figure_position"))
             terminals_with_size{end+1} = "x11";
           endif
           if (__gnuplot_has_feature__ ("wxt_figure_size"))
             terminals_with_size{end+1} = "wxt";
           endif
           if (any (strncmpi (term, terminals_with_size, 3)))
-	    if (term_units_are_pixels (term))
+            if (term_units_are_pixels (term))
               size_str = sprintf ("size %d,%d", gnuplot_size);
-	    elseif (strcmp (term, "tikz"))
+            elseif (strcmp (term, "tikz"))
               size_str = sprintf ("size %.15gin,%.15gin", gnuplot_size);
-	    else
+            else
               size_str = sprintf ("size %.15g,%.15g", gnuplot_size);
-	    endif
+            endif
             if (strncmpi (term, "X11", 3) && __gnuplot_has_feature__ ("x11_figure_position"))
-	      ## X11 allows the window to be positioned as well.
-	      units = get (0, "units");
-	      unwind_protect
-	        set (0, "units", "pixels");
-	        screen_size = get (0, "screensize")(3:4);
-	      unwind_protect_cleanup
-	        set (0, "units", units);
-	      end_unwind_protect
+              ## X11 allows the window to be positioned as well.
+              units = get (0, "units");
+              unwind_protect
+                set (0, "units", "pixels");
+                screen_size = get (0, "screensize")(3:4);
+              unwind_protect_cleanup
+                set (0, "units", units);
+              end_unwind_protect
               if (all (screen_size > 0))
                 ## For X11, set the figure positon as well as the size
                 ## gnuplot position is UL, Octave's is LL (same for screen/window)
                 gnuplot_pos(2) = screen_size(2) - gnuplot_pos(2) - gnuplot_size(2);
                 gnuplot_pos = max (gnuplot_pos, 1);
                 size_str = sprintf ("%s position %d,%d", size_str, 
                                     gnuplot_pos(1), gnuplot_pos(2));
               endif
@@ -270,34 +270,34 @@ function [enhanced, implicit_margin] = g
           elseif (strncmpi (term, "dumb", 3))
             new_stream = 1;
             if (~isempty (getenv ("COLUMNS")) && ~isempty (getenv ("LINES")))
               ## Let dumb use full text screen size (minus prompt lines).
               n = sprintf ("%i", -2 - length (find (sprintf ("%s", PS1) == "\n")));
               ## n = the number of times \n appears in PS1
               size_str = ["size ", getenv("COLUMNS"), ",", getenv("LINES"), n];
             else
-	      ## Use the gnuplot default.
+              ## Use the gnuplot default.
               size_str = "";
             end
           elseif (strncmpi (term, "fig", 3))
             ## Fig also has size, but the format is different.
             size_str = sprintf ("size %.15g %.15g", gnuplot_size);
           elseif (any (strncmpi (term, {"corel", "hpgl"}, 3)))
             ## The size for corel and hpgl are goes at the end (implicit).
             size_str = sprintf ("%.15g %.15g", gnuplot_size);
           elseif (any (strncmpi (term, {"dxf"}, 3)))
             ## DXF uses autocad units.
             size_str = "";
           else
             size_str = "";
           endif
         else
           size_str = "";
-	  warning ("gnuplot_set_term: size is zero")
+          warning ("gnuplot_set_term: size is zero")
         endif
       else
         ## A specified size take priority over the figure properies.
         size_str = "";
       endif
     else
       if isempty (h)
         disp ("gnuplot_set_term: figure handle is empty")
diff --git a/scripts/plot/grid.m b/scripts/plot/grid.m
--- a/scripts/plot/grid.m
+++ b/scripts/plot/grid.m
@@ -52,38 +52,38 @@ function grid (varargin)
   if (nargs > 2)
     print_usage ();
   elseif (nargs == 0)
     grid_on = ! grid_on;
   else
     x = varargin{1};
     if (ischar (x))
       if (strcmpi (x, "off"))
-	grid_on = false;
+        grid_on = false;
       elseif (strcmpi (x, "on"))
-	grid_on = true;
+        grid_on = true;
       elseif (strcmpi (x, "minor"))
         if (nargs == 2)
-	  x2 = varargin{2};
-	  if (strcmpi (x2, "on"))
-	    minor_on = true;
-	    grid_on = true;
-	  elseif (strcmpi (x2, "off"))
-	    minor_on = false;
-	  else
-	    print_usage ();
-	  endif
-	else
-	   minor_on = ! minor_on;
-	   if (minor_on)
-	     grid_on = true;
-	   endif
-	endif
+          x2 = varargin{2};
+          if (strcmpi (x2, "on"))
+            minor_on = true;
+            grid_on = true;
+          elseif (strcmpi (x2, "off"))
+            minor_on = false;
+          else
+            print_usage ();
+          endif
+        else
+           minor_on = ! minor_on;
+           if (minor_on)
+             grid_on = true;
+           endif
+        endif
       else
-	print_usage ();
+        print_usage ();
       endif
     else
       error ("grid: argument must be a string");
     endif
   endif
 
   if (grid_on)
     set (ax, "xgrid", "on", "ygrid", "on", "zgrid", "on");
diff --git a/scripts/plot/gtext.m b/scripts/plot/gtext.m
--- a/scripts/plot/gtext.m
+++ b/scripts/plot/gtext.m
@@ -27,25 +27,25 @@
 ## @seealso{ginput, text}
 ## @end deftypefn
 
 function gtext (s, varargin)
 
   if (nargin > 0)
     if (iscellstr (s))
       if (isempty (s))
-	s = "";
+        s = "";
       else
-	s = sprintf ("%s\n", s{:});
+        s = sprintf ("%s\n", s{:});
       endif
     endif
     if (ischar (s))
       if (! isempty (s))
-	[x, y] = ginput (1);
-	text (x, y, s, varargin{:});
+        [x, y] = ginput (1);
+        text (x, y, s, varargin{:});
       endif
     else
       error ("gtext: expecting a string or cell array of strings");
     endif 
   else
     print_usage ();
   endif
 
diff --git a/scripts/plot/hidden.m b/scripts/plot/hidden.m
--- a/scripts/plot/hidden.m
+++ b/scripts/plot/hidden.m
@@ -28,43 +28,43 @@
 function retval = hidden (mode)
 
   if (nargin == 0)
     mode = "swap";
   elseif (nargin == 1);
     if (ischar (mode))
       mode = tolower (mode);
       if (! strcmp (mode, "on") && ! strcmp (mode, "off"))
-	error ("hidden: mode expected to be 'on' or 'off'");
+        error ("hidden: mode expected to be 'on' or 'off'");
       endif
     else
       error ("hidden: expecting mode to be a string");
     endif
   else
     print_usage ();
   endif
 
   for h = get (gca (), "children");
     htype = lower (get (h, "type"));
     if (strcmp (htype, "surface"))
       fc = get (h, "facecolor");
       if ((! ischar (fc) && is_white (fc))
-	  || (ischar (fc) && strcmpi (fc, "none")))
+          || (ischar (fc) && strcmpi (fc, "none")))
         switch (mode)
         case "on"
           set (h, "facecolor", "w");
         case "off"
           set (h, "facecolor", "none");
         case "swap"
           if (ischar (fc))
             set (h, "facecolor", "w");
-	    mode = "on";
+            mode = "on";
           else
             set (h, "facecolor", "none");
-	    mode = "off";
+            mode = "off";
           endif
         endswitch
       endif
     endif
   endfor
 
   if (nargout > 0)
     retval = mode;
diff --git a/scripts/plot/hist.m b/scripts/plot/hist.m
--- a/scripts/plot/hist.m
+++ b/scripts/plot/hist.m
@@ -75,17 +75,17 @@ function [nn, xx] = hist (y, varargin)
       n = x;
       if (n <= 0)
         error ("hist: number of bins must be positive");
       endif
       x = [0.5:n]'/n;
       x = x * (max_val - min_val) + ones (size (x)) * min_val;
     elseif (isreal (x))
       if (isvector (x))
-	x = x(:);
+        x = x(:);
       endif
       tmp = sort (x);
       if (any (tmp != x))
         warning ("hist: bin values not sorted on input");
         x = tmp;
       endif
     else
       error ("hist: second argument must be a scalar or a vector");
@@ -109,18 +109,18 @@ function [nn, xx] = hist (y, varargin)
   else
     ## The following algorithm works fastest for n greater than about 30.
     ## Put cutoff elements between boundaries, integrate over all
     ## elements, keep totals at boundaries.
     [s, idx] = sort ([y; repmat(cutoff, 1, y_nc)]);
     len = rows (y);
     chist = cumsum (idx <= len);
     chist = [(zeros (1, y_nc));
-	     (reshape (chist(idx > len), rows (cutoff), y_nc));
-	     (chist(end,:) - sum (isnan (y)))];
+             (reshape (chist(idx > len), rows (cutoff), y_nc));
+             (chist(end,:) - sum (isnan (y)))];
   endif
 
   freq = diff (chist);
 
   if (nargin > 2 && ! ischar (varargin{iarg}))
     ## Normalise the histogram.
     norm = varargin{iarg++};
     freq = freq / rows (y) * norm;
diff --git a/scripts/plot/hold.m b/scripts/plot/hold.m
--- a/scripts/plot/hold.m
+++ b/scripts/plot/hold.m
@@ -58,21 +58,21 @@ function hold (varargin)
   endif
 
   if (nargs == 0)
     turn_hold_off = ishold (ax);
   elseif (nargs == 1)
     state = varargin{1};
     if (ischar (state))
       if (strcmpi (state, "off"))
-	turn_hold_off = true;
+        turn_hold_off = true;
       elseif (strcmpi (state, "on"))
-	turn_hold_off = false;
+        turn_hold_off = false;
       else
-	error ("hold: invalid hold state");
+        error ("hold: invalid hold state");
       endif
     endif
   else
     print_usage ();
   endif
 
   if (turn_hold_off)
     set (ax, "nextplot", "replace");
diff --git a/scripts/plot/ishold.m b/scripts/plot/ishold.m
--- a/scripts/plot/ishold.m
+++ b/scripts/plot/ishold.m
@@ -25,31 +25,31 @@
 function retval = ishold (h)
 
   if (nargin == 0)
     ax = gca ();
     fig = gcf ();
   elseif (nargin == 1)
     if (ishandle (h))
       if (isfigure (h))
-	ax = get (h, "currentaxes");
-	if (isempty (ax))
-	  ax = __go_axes__ (h);
-	  set (h, "currentaxes", ax);
-	endif
-	fig = h;
+        ax = get (h, "currentaxes");
+        if (isempty (ax))
+          ax = __go_axes__ (h);
+          set (h, "currentaxes", ax);
+        endif
+        fig = h;
       elseif (strcmpi (get (h, "type"), "axes"))
-	ax = h;
-	fig = get (h, "parent");
+        ax = h;
+        fig = get (h, "parent");
       else
-	error ("hold: expecting argument to be axes or figure graphics handle");
+        error ("hold: expecting argument to be axes or figure graphics handle");
       endif
     else
       error ("hold: expecting argument to be axes or figure graphics handle");
     endif
   else
     print_usage ();
   endif
 
   retval = (strcmpi (get (fig, "nextplot"), "add")
-	    && strcmpi (get (ax, "nextplot"), "add"));
+            && strcmpi (get (ax, "nextplot"), "add"));
 
 endfunction
diff --git a/scripts/plot/isonormals.m b/scripts/plot/isonormals.m
--- a/scripts/plot/isonormals.m
+++ b/scripts/plot/isonormals.m
@@ -56,35 +56,35 @@
 ## lin = linspace (0, 2, N);
 ## [x, y, z] = meshgrid (lin, lin, lin);
 ## c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
 ## figure (); ## Open another figure window
 ##
 ## subplot (2, 2, 1); view (-38, 20);
 ## [f, v, cdat] = isosurface (x, y, z, c, iso, y);
 ## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, \
-## 	   "FaceColor", "interp", "EdgeColor", "none");
+##         "FaceColor", "interp", "EdgeColor", "none");
 ## isofinish (p); ## Call user function isofinish
 ##
 ## subplot (2, 2, 2); view (-38, 20);
 ## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, \
-## 	   "FaceColor", "interp", "EdgeColor", "none");
+##         "FaceColor", "interp", "EdgeColor", "none");
 ## isonormals (x, y, z, c, p); ## Directly modify patch
 ## isofinish (p);
 ##
 ## subplot (2, 2, 3); view (-38, 20);
 ## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, \
-## 	   "FaceColor", "interp", "EdgeColor", "none");
+##         "FaceColor", "interp", "EdgeColor", "none");
 ## n = isonormals (x, y, z, c, v); ## Compute normals of isosurface
 ## set (p, "VertexNormals", n);    ## Manually set vertex normals
 ## isofinish (p);
 ##
 ## subplot (2, 2, 4); view (-38, 20);
 ## p = patch ("Faces", f, "Vertices", v, "FaceVertexCData", cdat, \
-## 	   "FaceColor", "interp", "EdgeColor", "none");
+##         "FaceColor", "interp", "EdgeColor", "none");
 ## isonormals (x, y, z, c, v, "negate"); ## Use reverse directly
 ## isofinish (p);
 ## @end example
 ##
 ## @seealso {isosurface, isocolors, isocaps, marching_cube}
 ##
 ## @end deftypefn
 
diff --git a/scripts/plot/isosurface.m b/scripts/plot/isosurface.m
--- a/scripts/plot/isosurface.m
+++ b/scripts/plot/isosurface.m
@@ -154,25 +154,25 @@ function varargout = isosurface(varargin
   endif
 
   switch (nargout)
     case 0
       ## plot the calculated surface
       newplot ();
       if (calc_colors)
         pa = patch ("Faces", fvc.faces, "Vertices", fvc.vertices,
-		    "FaceVertexCData", fvc.facevertexcdata, 
-		    "FaceColor", "flat", "EdgeColor", "none");
+                    "FaceVertexCData", fvc.facevertexcdata, 
+                    "FaceColor", "flat", "EdgeColor", "none");
       else
         pa = patch ("Faces", fvc.faces, "Vertices", fvc.vertices, 
-		    "FaceColor", "g", "EdgeColor", "k");
+                    "FaceColor", "g", "EdgeColor", "k");
       endif
       if (! ishold ())
-	set (gca(), "view", [-37.5, 30],
-	     "xgrid", "on", "ygrid", "on", "zgrid", "on");
+        set (gca(), "view", [-37.5, 30],
+             "xgrid", "on", "ygrid", "on", "zgrid", "on");
       endif
     case 1
       varargout = {fvc};
     case 2
       varargout = {fvc.faces, fvc.vertices};
     case 3
       varargout = {fvc.faces, fvc.vertices, fvc.facevertexcdata};
     otherwise
diff --git a/scripts/plot/legend.m b/scripts/plot/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/legend.m
@@ -80,20 +80,20 @@ function legend (varargin)
 
   [ca, varargin, nargin] = __plt_get_axis_arg__ ("legend", varargin{:});
   nargs = nargin;
 
   if (nargs > 0)
     pos = varargin{nargs};
     if (isnumeric (pos) && isscalar (pos) && round (pos) == pos)
       if (pos >= -1 && pos <= 4)
-	set (ca, "keypos", pos);
-	nargs--;
+        set (ca, "keypos", pos);
+        nargs--;
       else
-	error ("legend: invalid position specified");
+        error ("legend: invalid position specified");
       endif
     endif
   endif
   
   if (nargs > 1)
     pos = varargin{nargs-1};
     str = varargin{nargs};
     if (strcmpi (pos, "location")  && ischar (str))
@@ -106,104 +106,104 @@ function legend (varargin)
   nkids = numel (kids);
   k = 1;
   turn_on_legend = false;
 
   if (nargs == 1)
     arg = varargin{1};
     if (ischar (arg))
       if (rows (arg) == 1)
-	str = tolower (deblank (arg));
-	switch (str)
-	  case {"off", "hide"}
-	    set (ca, "key", "off");
-	    nargs--;
-	  case "show"
-	    set (ca, "key", "on");
-	    nargs--;
-	  case "toggle"
-	    val = get (ca, "key");
-	    if (strcmpi (val, "on"))
-	      set (ca, "key", "off");
-	    else
-	      set (ca, "key", "on");
-	    endif
-	    nargs--;
-	  case "boxon"
-	    set (ca, "key", "on", "keybox", "on");
-	    nargs--;
-	  case "boxoff"
-	    set (ca, "keybox", "off");
-	    nargs--;
-	  case "left"
-	    set (ca, "keyreverse", "off")
-	    nargs--;
-	  case "right"
-	    set (ca, "keyreverse", "on")
-	    nargs--;
-	  otherwise
-	endswitch
+        str = tolower (deblank (arg));
+        switch (str)
+          case {"off", "hide"}
+            set (ca, "key", "off");
+            nargs--;
+          case "show"
+            set (ca, "key", "on");
+            nargs--;
+          case "toggle"
+            val = get (ca, "key");
+            if (strcmpi (val, "on"))
+              set (ca, "key", "off");
+            else
+              set (ca, "key", "on");
+            endif
+            nargs--;
+          case "boxon"
+            set (ca, "key", "on", "keybox", "on");
+            nargs--;
+          case "boxoff"
+            set (ca, "keybox", "off");
+            nargs--;
+          case "left"
+            set (ca, "keyreverse", "off")
+            nargs--;
+          case "right"
+            set (ca, "keyreverse", "on")
+            nargs--;
+          otherwise
+        endswitch
       else
-	varargin = cellstr (arg);
-	nargs = numel (varargin);
+        varargin = cellstr (arg);
+        nargs = numel (varargin);
       endif
     elseif (iscellstr (arg))
       varargin = arg;
       nargs = numel (varargin);
     else
       error ("legend: expecting argument to be a character string");
     endif
   endif
 
   if (nargs > 0)
     have_data = false;
     for k = 1:nkids
       typ = get (kids(k), "type");
       if (strcmp (typ, "line") || strcmp (typ, "surface")
-	  || strcmp (typ, "patch") || strcmp (typ, "hggroup"))
-	have_data = true;
-	break;
+          || strcmp (typ, "patch") || strcmp (typ, "hggroup"))
+        have_data = true;
+        break;
       endif
     endfor
     if (! have_data)
       warning ("legend: plot data is empty; setting key labels has no effect");
     endif
   endif
 
   warned = false;
   k = nkids;
   for i = 1:nargs
     arg = varargin{i};
     if (ischar (arg))
       typ = get (kids(k), "type");
       while (k > 1
-	     && ! (strcmp (typ, "line") || strcmp (typ, "surface")
-		   || strcmp (typ, "patch") || strcmp (typ, "hggroup")))
-	typ = get (kids(--k), "type");
+             && ! (strcmp (typ, "line") || strcmp (typ, "surface")
+                   || strcmp (typ, "patch") || strcmp (typ, "hggroup")))
+        typ = get (kids(--k), "type");
       endwhile
       if (k > 0)
-	if (strcmp (get (kids(k), "type"), "hggroup"))
-	  hgkids = get (kids(k), "children");
-	  for j = 1 : length (hgkids)
-	    hgobj = get (hgkids (j));
-	    if (isfield (hgobj, "keylabel"))
-	      set (hgkids(j), "keylabel", arg);
-	      break;
-	    endif
-	  endfor
-	else
-	  set (kids(k), "keylabel", arg);
-	endif
-	turn_on_legend = true;
-	if (--k == 0)
-	  break;
-	endif
+        if (strcmp (get (kids(k), "type"), "hggroup"))
+          hgkids = get (kids(k), "children");
+          for j = 1 : length (hgkids)
+            hgobj = get (hgkids (j));
+            if (isfield (hgobj, "keylabel"))
+              set (hgkids(j), "keylabel", arg);
+              break;
+            endif
+          endfor
+        else
+          set (kids(k), "keylabel", arg);
+        endif
+        turn_on_legend = true;
+        if (--k == 0)
+          break;
+        endif
       elseif (! warned)
-	warned = true;
-	warning ("legend: ignoring extra labels");
+        warned = true;
+        warning ("legend: ignoring extra labels");
       endif
     else
       error ("legend: expecting argument to be a character string");
     endif
   endfor
 
   if (turn_on_legend)
     set (ca, "key", "on");
diff --git a/scripts/plot/linkprop.m b/scripts/plot/linkprop.m
--- a/scripts/plot/linkprop.m
+++ b/scripts/plot/linkprop.m
@@ -64,22 +64,22 @@ function update_prop (h, d, hlist, prop)
   persistent recursion = false;
 
   ## Don't allow recursion
   if (! recursion)
     unwind_protect
       recursion = true;
       val = get (h, prop);
       for hh = hlist(:)'
-	if (hh != h)
-	  oldval = get (hh, prop);
-	  if (! isequal (val, oldval))
-	    set (hh, prop, val);
-	  endif
-	endif
+        if (hh != h)
+          oldval = get (hh, prop);
+          if (! isequal (val, oldval))
+            set (hh, prop, val);
+          endif
+        endif
       endfor
     unwind_protect_cleanup
       recursion = false;
     end_unwind_protect
   endif
 endfunction
 
 function delete_prop (h, d, hlist, prop)
diff --git a/scripts/plot/meshz.m b/scripts/plot/meshz.m
--- a/scripts/plot/meshz.m
+++ b/scripts/plot/meshz.m
@@ -56,21 +56,21 @@ function retval = meshz (varargin)
   endif
 
 
   if (isvector (x) && isvector (y))
     x = [x(1), x(:).', x(end)];
     y = [y(1); y(:); y(end)];
   else
     x = [x(1, 1), x(1, :), x(1, end);
-	 x(:, 1), x, x(:, end);
-	 x(end, 1), x(end, :), x(end, end)]; 
+         x(:, 1), x, x(:, end);
+         x(end, 1), x(end, :), x(end, end)]; 
     y = [y(1, 1), y(1, :), y(1, end);
-	 y(:, 1), y, y(:, end);
-	 y(end, 1), y(end, :), y(end, end)]; 
+         y(:, 1), y, y(:, end);
+         y(end, 1), y(end, :), y(end, end)]; 
   endif
 
   zref = min(z(isfinite(z)));
   z = [zref .* ones(1, size(z, 2) + 2);
        zref .* ones(size(z, 1), 1), z, zref .* ones(size(z, 1), 1); 
        zref.* ones(1, size(z, 2) + 2)];
 
   oldh = gca ();
diff --git a/scripts/plot/newplot.m b/scripts/plot/newplot.m
--- a/scripts/plot/newplot.m
+++ b/scripts/plot/newplot.m
@@ -34,28 +34,28 @@ function newplot ()
       ## FIXME -- probably we should do more than validate the nextplot
       ## property value...
       case "new"
       case "add"
       case "replacechildren"
         delete (get (cf, "children"))
       case "replace"
       otherwise
-	error ("newplot: unrecognized nextplot property for current figure");
+        error ("newplot: unrecognized nextplot property for current figure");
     endswitch
     ca = gca ();
     anp = get (ca, "nextplot");
     switch (anp)
       case "new"
       case "add"
       case "replacechildren"
         delete (get (ca, "children"))
       case "replace"
-	__go_axes_init__ (ca, "replace");
-	__request_drawnow__ ();
+        __go_axes_init__ (ca, "replace");
+        __request_drawnow__ ();
       otherwise
-	error ("newplot: unrecognized nextplot property for current axes");
+        error ("newplot: unrecognized nextplot property for current axes");
     endswitch
   else
     print_usage ();
   endif
 
 endfunction
diff --git a/scripts/plot/pareto.m b/scripts/plot/pareto.m
--- a/scripts/plot/pareto.m
+++ b/scripts/plot/pareto.m
@@ -59,37 +59,37 @@ function h = pareto (varargin)
     print_usage ();
   endif
 
   x = varargin {1}(:).';
   if (nargin == 2)
     y = varargin {2}(:).';
     if (! iscell (y))
       if (ischar (y))
-	y = cellstr (y);
+        y = cellstr (y);
       else
-	y = cellfun (@(x) num2str (x), num2cell (y), "UniformOutput", false);
+        y = cellfun (@(x) num2str (x), num2cell (y), "UniformOutput", false);
       endif
     endif
   else
     y = cellfun (@(x) int2str (x), num2cell (1 : numel(x)), 
-		 "UniformOutput", false);
+                 "UniformOutput", false);
   endif
 
   [x, idx] = sort (x, "descend");
   y = y (idx);
   cdf = cumsum (x);
   maxcdf = max(cdf);
   cdf = cdf ./ maxcdf;
   cdf95 = cdf - 0.95;
   idx95 = find(sign(cdf95(1:end-1)) != sign(cdf95(2:end)))(1);
 
   [ax, hbar, hline] = plotyy (1 : idx95, x (1 : idx95), 
-			      1 : length(cdf), 100 .* cdf, 
-			      @bar, @plot);
+                              1 : length(cdf), 100 .* cdf, 
+                              @bar, @plot);
 
   axis (ax(1), [1 - 0.6, idx95 + 0.6, 0, maxcdf]);
   axis (ax(2), [1 - 0.6, idx95 + 0.6, 0, 100]);
   set (ax(2), "ytick", [0, 20, 40, 60, 80, 100], 
        "yticklabel", {"0%", "20%", "40%", "60%", "80%", "100%"});
   set (ax(1), "xtick", 1 : idx95, "xticklabel", y (1: idx95));
   set (ax(2), "xtick", 1 : idx95, "xticklabel", y (1: idx95));
 
diff --git a/scripts/plot/pie.m b/scripts/plot/pie.m
--- a/scripts/plot/pie.m
+++ b/scripts/plot/pie.m
@@ -81,23 +81,23 @@ function hlist = __pie__ (varargin)
   have_labels = false;
 
   while (iarg <= nargin)
     arg = varargin{iarg++};
     if (iscell (arg))
       labels = arg;
       have_labels = true;
       if (numel (x) != numel (labels))
-	error ("pie: mismatch in number of labels and data");
+        error ("pie: mismatch in number of labels and data");
       endif
     elseif (isnumeric (arg))
       explode = arg;
       have_explode = true;
       if (! size_equal (x, explode))
-	error ("pie: mismatch in number of elements in explode and data");
+        error ("pie: mismatch in number of elements in explode and data");
       endif
     endif
   endwhile
 
   if (! have_explode)
     explode = zeros (size (x));
   endif
 
@@ -135,17 +135,17 @@ function hlist = __pie__ (varargin)
     yt = 1.2 * cosd (xn2);
     if (xt > 0)
       align = "left";
     else
       align = "right";
     endif
 
     hlist = [hlist; patch(xoff + [0, - sind(xn)], yoff + [0, cosd(xn)], i);
-    	     text(xt, yt, labels{i}, "horizontalalignment", align)];
+             text(xt, yt, labels{i}, "horizontalalignment", align)];
   endfor
 
   if (len == 1)
     set (h, "clim", [1, 2]);
   else
     set (h, "clim", [1, len]);
   endif
 
diff --git a/scripts/plot/plot3.m b/scripts/plot/plot3.m
--- a/scripts/plot/plot3.m
+++ b/scripts/plot/plot3.m
@@ -107,94 +107,94 @@ function retval = plot3 (varargin)
     if (property_set)
       properties = [properties, new_cell];
       property_set = 0;
       continue;
     endif
 
     if (ischar (new))
       if (! z_set)
-	if (! y_set)
-	  if (! x_set)
-	    error ("plot3: needs x, [ y, [ z ] ]");
-	  else
-	    z = imag (x);
-	    y = real (x);
-	    y_set = 1;
-	    z_set = 1;
-	    if (rows(x) > 1)
-	      x = repmat ((1:rows(x))', 1, columns(x));
-	    else
-	      x = 1:columns(x);
-	    endif
-	  endif
-	else
-	  z = imag (y);
-	  y = real (y);
-	  z_set = 1;
-	endif
+        if (! y_set)
+          if (! x_set)
+            error ("plot3: needs x, [ y, [ z ] ]");
+          else
+            z = imag (x);
+            y = real (x);
+            y_set = 1;
+            z_set = 1;
+            if (rows(x) > 1)
+              x = repmat ((1:rows(x))', 1, columns(x));
+            else
+              x = 1:columns(x);
+            endif
+          endif
+        else
+          z = imag (y);
+          y = real (y);
+          z_set = 1;
+        endif
       endif
 
       if (! fmt_set)
-	[options, valid] = __pltopt__ ("plot3", new, false);
-	if (! valid)
-	  properties = [properties, new_cell];
-	  property_set = 1;
-	  continue;
-	else
-	  fmt_set = 1;
-	  while (arg < nargin && ischar (varargin{arg+1}))
-	    if (nargin - arg < 2)
-	      error ("plot3: properties must appear followed by a value");
-	    endif
-	    properties = [properties, varargin(arg+1:arg+2)];
-	    arg += 2;
-	  endwhile
-	endif
+        [options, valid] = __pltopt__ ("plot3", new, false);
+        if (! valid)
+          properties = [properties, new_cell];
+          property_set = 1;
+          continue;
+        else
+          fmt_set = 1;
+          while (arg < nargin && ischar (varargin{arg+1}))
+            if (nargin - arg < 2)
+              error ("plot3: properties must appear followed by a value");
+            endif
+            properties = [properties, varargin(arg+1:arg+2)];
+            arg += 2;
+          endwhile
+        endif
       else
-	properties = [properties, new_cell];
-	property_set = 1;
-	continue;
+        properties = [properties, new_cell];
+        property_set = 1;
+        continue;
       endif
 
       if (isvector (x) && isvector (y))
-	if (isvector (z))
-	  x = x(:);
-	  y = y(:);
-	  z = z(:);
-	elseif (length (x) == rows (z) && length (y) == columns (z))
-	  [x, y] = meshgrid (x, y);
-	else
-	  error ("plot3: [length(x), length(y)] must match size(z)");
-	endif
+        if (isvector (z))
+          x = x(:);
+          y = y(:);
+          z = z(:);
+        elseif (length (x) == rows (z) && length (y) == columns (z))
+          [x, y] = meshgrid (x, y);
+        else
+          error ("plot3: [length(x), length(y)] must match size(z)");
+        endif
       endif
 
       if (! size_equal (x, y, z))
-	error ("plot3: x, y, and z must have the same shape");
+        error ("plot3: x, y, and z must have the same shape");
       endif
 
       key = options.key;
       if (! isempty (key))
-	set (gca (), "key", "on");
+        set (gca (), "key", "on");
       endif
 
       for i = 1 : columns (x)
         linestyle = options.linestyle;
         marker = options.marker;
-	if (isempty (marker) && isempty (linestyle))
-	   [linestyle, marker] = __next_line_style__ ();
-	endif
-	color = options.color;
-	if (isempty (options.color))
-	  color = __next_line_color__ ();
-	endif
+        if (isempty (marker) && isempty (linestyle))
+           [linestyle, marker] = __next_line_style__ ();
+        endif
+        color = options.color;
+        if (isempty (options.color))
+          color = __next_line_color__ ();
+        endif
 
-	tmp(++idx) = line (x(:, i), y(:, i), z(:, i),  "keylabel", key,
-			   "color", color, "linestyle", linestyle,
-			   "marker", marker, properties{:});
+        tmp(++idx) = line (x(:, i), y(:, i), z(:, i),  "keylabel", key,
+                           "color", color, "linestyle", linestyle,
+                           "marker", marker, properties{:});
       endfor
 
       x_set = 0;
       y_set = 0;
       z_set = 0;
       fmt_set = 0;
       properties = {};
     elseif (! x_set)
@@ -203,51 +203,51 @@ function retval = plot3 (varargin)
     elseif (! y_set)
       y = new;
       y_set = 1;
     elseif (! z_set)
       z = new;
       z_set = 1;
     else
       if (isvector (x) && isvector (y))
-	if (isvector (z))
-	  x = x(:);
-	  y = y(:);
-	  z = z(:);
-	elseif (length (x) == rows (z) && length (y) == columns (z))
-	  [x, y] = meshgrid (x, y);
-	else
-	  error ("plot3: [length(x), length(y)] must match size(z)");
-	endif
+        if (isvector (z))
+          x = x(:);
+          y = y(:);
+          z = z(:);
+        elseif (length (x) == rows (z) && length (y) == columns (z))
+          [x, y] = meshgrid (x, y);
+        else
+          error ("plot3: [length(x), length(y)] must match size(z)");
+        endif
       endif
 
       if (! size_equal (x, y, z))
-	error ("plot3: x, y, and z must have the same shape");
+        error ("plot3: x, y, and z must have the same shape");
       endif
 
       options =  __default_plot_options__ ();
       key = options.key;
       if (! isempty (key))
-	set (gca (), "key", "on");
+        set (gca (), "key", "on");
       endif
 
       for i = 1 : columns (x)
         linestyle = options.linestyle;
         marker = options.marker;
-	if (isempty (marker) && isempty (linestyle))
-	   [linestyle, marker] = __next_line_style__ ();
-	endif
-	color = options.color;
-	if (isempty (color))
-	  color = __next_line_color__ ();
-	endif
+        if (isempty (marker) && isempty (linestyle))
+           [linestyle, marker] = __next_line_style__ ();
+        endif
+        color = options.color;
+        if (isempty (color))
+          color = __next_line_color__ ();
+        endif
 
-	tmp(++idx) = line (x(:, i), y(:, i), z(:, i),  "keylabel", key,
-			   "color", color, "linestyle", linestyle,
-			   "marker", marker, properties{:});
+        tmp(++idx) = line (x(:, i), y(:, i), z(:, i),  "keylabel", key,
+                           "color", color, "linestyle", linestyle,
+                           "marker", marker, properties{:});
       endfor
 
       x = new;
       y_set = 0;
       z_set = 0;
       fmt_set = 0;
       properties = {};
     endif
@@ -258,41 +258,41 @@ function retval = plot3 (varargin)
     error ("plot3: properties must appear followed by a value");
   endif
 
   ## Handle last plot.
 
   if (x_set)
     if (y_set)
       if (! z_set)
-	z = imag (y);
-	y = real (y);
-	z_set = 1;
+        z = imag (y);
+        y = real (y);
+        z_set = 1;
       endif
     else
       z = imag (x);
       y = real (x);
       y_set = 1;
       z_set = 1;
       if (rows (x) > 1)
-	x = repmat ((1:rows (x))', 1, columns(x));
+        x = repmat ((1:rows (x))', 1, columns(x));
       else
-	x = 1:columns(x);
+        x = 1:columns(x);
       endif
     endif
 
     if (isvector (x) && isvector (y))
       if (isvector (z))
-	x = x(:);
-	y = y(:);
-	z = z(:);
+        x = x(:);
+        y = y(:);
+        z = z(:);
       elseif (length (x) == rows (z) && length (y) == columns (z))
-	[x, y] = meshgrid (x, y);
+        [x, y] = meshgrid (x, y);
       else
-	error ("plot3: [length(x), length(y)] must match size(z)");
+        error ("plot3: [length(x), length(y)] must match size(z)");
       endif
     endif
 
     if (! size_equal (x, y, z))
       error ("plot3: x, y, and z must have the same shape");
     endif
 
     options =  __default_plot_options__ ();
@@ -300,26 +300,26 @@ function retval = plot3 (varargin)
     if (! isempty (key))
       set (gca (), "key", "on");
     endif
 
     for i = 1 : columns (x)
       linestyle = options.linestyle;
       marker = options.marker;
       if (isempty (marker) && isempty (linestyle))
-	[linestyle, marker] = __next_line_style__ ();
+        [linestyle, marker] = __next_line_style__ ();
       endif
       color = options.color;
       if (isempty (color))
-	color = __next_line_color__ ();
+        color = __next_line_color__ ();
       endif
 
       tmp(++idx) = line (x(:, i), y(:, i), z(:, i),  "keylabel", key, 
-			 "color", color, "linestyle", linestyle,
-			 "marker", marker, properties{:});
+                         "color", color, "linestyle", linestyle,
+                         "marker", marker, properties{:});
     endfor
   endif
 
   set (gca (), "view", [-37.5, 30]);
 
   if (nargout > 0 && idx > 0)
     retval = tmp;
   endif
diff --git a/scripts/plot/plotmatrix.m b/scripts/plot/plotmatrix.m
--- a/scripts/plot/plotmatrix.m
+++ b/scripts/plot/plotmatrix.m
@@ -69,72 +69,72 @@ function [h, ax, bigax, p, pax] = plotma
     print_usage ();
   else
     oldh = gca ();
     unwind_protect
       axes (bigax2);
       newplot ();
       [h2, ax2, p2, pax2, need_usage] = __plotmatrix__ (bigax2, varargin{:});
       if (need_usage)
-	print_usage ();
+        print_usage ();
       endif
       if (nargout > 0)
-	h = h2;
-	ax = ax2;
-	bigax = bigax2;
-	p = p2;
-	pax = pax2;
+        h = h2;
+        ax = ax2;
+        bigax = bigax2;
+        p = p2;
+        pax = pax2;
       endif
       axes (bigax2);
       ctext = text (0, 0, "", "visible", "off", 
-		    "handlevisibility", "off", "xliminclude", "off",  
-		    "yliminclude", "off", "zliminclude", "off",
-		    "deletefcn", {@plotmatrixdelete, [ax2; pax2]});
+                    "handlevisibility", "off", "xliminclude", "off",  
+                    "yliminclude", "off", "zliminclude", "off",
+                    "deletefcn", {@plotmatrixdelete, [ax2; pax2]});
       set (bigax2, "visible", "off");
     unwind_protect_cleanup
       axes (oldh);
     end_unwind_protect
   endif
 endfunction
 
 %!demo
 %! plotmatrix (randn (100, 3), 'g+')
 
 function plotmatrixdelete (h, d, ax)
   for i = 1 : numel (ax)
     hc = ax(i);
     if (ishandle (hc) && strcmp (get (hc, "type"), "axes") && 
-	strcmpi (get (hc, "beingdeleted"), "off"))
+        strcmpi (get (hc, "beingdeleted"), "off"))
       parent = get (hc, "parent");
       ## If the parent is invalid or being deleted, then do nothing
       if (ishandle (parent) && strcmpi (get (parent, "beingdeleted"), "off"))
-	delete (hc);
+        delete (hc);
       endif
     endif
   endfor
 endfunction
 
 function [h, ax, p, pax, need_usage] = __plotmatrix__ (bigax, varargin)
   need_usage = false;
   have_line_spec = false;
   have_hist = false;
   parent = get (bigax, "parent");
   for i = 1 : nargin - 1
     arg = varargin{i};
     if (ischar (arg) || iscell (arg))
       [linespec, valid] = __pltopt__ ("plotmatrix", varargin{i}, false);
       if (valid)
-	have_line_spec = true;      
-	linespec = varargin(i);
-	varargin(i) = [];
-	nargin = nargin - 1;
-	break;
+        have_line_spec = true;      
+        linespec = varargin(i);
+        varargin(i) = [];
+        nargin = nargin - 1;
+        break;
       else
-	need_usage = true;
-	returm;
+        need_usage = true;
+        returm;
       endif
     endif
   endfor
 
   if (nargin == 2)
     X = varargin{1};
     Y = X;
     have_hist = true;
@@ -164,26 +164,26 @@ function [h, ax, p, pax, need_usage] = _
   yoff = 0.05;
   border = [0.130, 0.110, 0.225, 0.185] .* [xsize, ysize, xsize, ysize];
   border(3:4) = - border(3:4) - border(1:2);
 
   for i = 1 : n
     for j = 1 : m
       pos = [xsize * (j - 1) + xoff, ysize * (n - i) + yoff, xsize, ysize];
       tmp = axes ("outerposition", pos, "position", pos + border,
-		  "parent", parent);
+                  "parent", parent);
       if (i == j && have_hist)
-	pax = [pax ; tmp];
-	[nn, xx] = hist (X(:, i));
-	tmp = bar (xx, nn, 1.0);
-	p = [p; tmp];
+        pax = [pax ; tmp];
+        [nn, xx] = hist (X(:, i));
+        tmp = bar (xx, nn, 1.0);
+        p = [p; tmp];
       else
-	ax = [ax ; tmp];
-	if (have_line_spec)
-	  tmp = plot (X (:, i), Y (:, j), linespec);
-	else
-	  tmp = plot (X (:, i), Y (:, j), ".");
-	endif
-	h = [h ; tmp];
+        ax = [ax ; tmp];
+        if (have_line_spec)
+          tmp = plot (X (:, i), Y (:, j), linespec);
+        else
+          tmp = plot (X (:, i), Y (:, j), ".");
+        endif
+        h = [h ; tmp];
       endif
     endfor
   endfor
 endfunction
diff --git a/scripts/plot/plotyy.m b/scripts/plot/plotyy.m
--- a/scripts/plot/plotyy.m
+++ b/scripts/plot/plotyy.m
@@ -60,17 +60,17 @@ function [Ax, H1, H2] = plotyy (varargin
       &&  ishandle(varargin{1}(2)) && 
       all (floor (varargin{1}) != varargin{1}))
     obj1 = get (varargin{1}(1));
     obj2 = get (varargin{1}(2));
     if (strcmp (obj1.type, "axes") || strcmp (obj2.type, "axes"))
       ax = [obj1, obj2];
       varargin(1) = [];
       if (isempty (varargin))
-	varargin = {};
+        varargin = {};
       endif
     else
       error ("plotyy: expecting first argument to be axes handle");
     endif
   else
     f = get (0, "currentfigure");
     if (isempty (f))
       f = figure ();
@@ -165,21 +165,21 @@ function [ax, h1, h2] = __plotyy__ (ax, 
   set (ax(2), "ycolor", getcolor (h2(1)));
   set (ax(2), "position", get (ax(1), "position"));
   set (ax(2), "xlim", xlim);
   set (ax(2), "color", "none");
 
   ## Add invisible text objects that when destroyed, 
   ## also remove the other axis
   t1 = text (0, 0, "", "parent", ax(1), "tag", "plotyy", 
-	     "handlevisibility", "off", "visible", "off",
-	     "xliminclude", "off", "yliminclude", "off");
+             "handlevisibility", "off", "visible", "off",
+             "xliminclude", "off", "yliminclude", "off");
   t2 = text (0, 0, "", "parent", ax(2), "tag", "plotyy", 
-	     "handlevisibility", "off", "visible", "off",
-	     "xliminclude", "off", "yliminclude", "off");
+             "handlevisibility", "off", "visible", "off",
+             "xliminclude", "off", "yliminclude", "off");
 
   set (t1, "deletefcn", {@deleteplotyy, ax(2), t2});
   set (t2, "deletefcn", {@deleteplotyy, ax(1), t1});
 
   addlistener (ax(1), "position", {@update_position, ax(2)});
   addlistener (ax(2), "position", {@update_position, ax(1)});
   addlistener (ax(1), "view", {@update_position, ax(2)});
   addlistener (ax(2), "view", {@update_position, ax(1)});
@@ -241,22 +241,22 @@ function update_position (h, d, ax2)
       view = get (h, "view");
       plotboxaspectratio = get (h, "plotboxaspectratio");
       plotboxaspectratiomode = get (h, "plotboxaspectratiomode");
       oldposition = get (ax2, "position");
       oldview = get (ax2, "view");
       oldplotboxaspectratio = get (ax2, "plotboxaspectratio");
       oldplotboxaspectratiomode = get (ax2, "plotboxaspectratiomode");
       if (! (isequal (position, oldposition) && isequal (view, oldview)))
-	set (ax2, "position", position, "view", view)
+        set (ax2, "position", position, "view", view)
       endif
       if (! (isequal (plotboxaspectratio, oldplotboxaspectratio) 
-	     && isequal (plotboxaspectratiomode, oldplotboxaspectratiomode)))
-	set (ax2, "plotboxaspectratio", plotboxaspectratio);
-	set (ax2, "plotboxaspectratiomode", plotboxaspectratiomode);
+             && isequal (plotboxaspectratiomode, oldplotboxaspectratiomode)))
+        set (ax2, "plotboxaspectratio", plotboxaspectratio);
+        set (ax2, "plotboxaspectratiomode", plotboxaspectratiomode);
       endif
     unwind_protect_cleanup
       recursion = false;
     end_unwind_protect
   endif  
 endfunction
 
 function color = getcolor (ax)
diff --git a/scripts/plot/polar.m b/scripts/plot/polar.m
--- a/scripts/plot/polar.m
+++ b/scripts/plot/polar.m
@@ -34,48 +34,48 @@ function retval = polar (varargin)
 
   oldh = gca ();
   unwind_protect
     axes (h);
     newplot ();
 
     if (nargs == 3)
       if (! ischar (varargin{3}))
-	error ("polar: third argument must be a string");
+        error ("polar: third argument must be a string");
       endif
       tmp = __plr2__ (h, varargin{:});
       maxr = max (varargin {2} (:));
     elseif (nargs == 2)
       if (ischar (varargin{2}))
-	tmp = __plr1__ (h, varargin{:});
-	if (iscomplex(varargin{1}))
-	  maxr = max (imag(varargin{1})(:));
-	else
-	  maxr = max (varargin{1}(:));
-	endif
+        tmp = __plr1__ (h, varargin{:});
+        if (iscomplex(varargin{1}))
+          maxr = max (imag(varargin{1})(:));
+        else
+          maxr = max (varargin{1}(:));
+        endif
       else
-	fmt = "";
-	tmp = __plr2__ (h, varargin{:}, fmt);
-	maxr = max (varargin {2} (:));
+        fmt = "";
+        tmp = __plr2__ (h, varargin{:}, fmt);
+        maxr = max (varargin {2} (:));
       endif
     elseif (nargs == 1)
       fmt = "";
       tmp = __plr1__ (h, varargin{:}, fmt);
       if (iscomplex(varargin{1}))
-	maxr = max (imag(varargin{1})(:));
+        maxr = max (imag(varargin{1})(:));
       else
-	maxr = max (varargin{1}(:));
+        maxr = max (varargin{1}(:));
       endif
     else
       print_usage ();
     endif
 
     set (h, "xlim", [-maxr, maxr], "ylim", [-maxr, maxr],
-	 "xaxislocation", "zero", "yaxislocation", "zero",
-	 "plotboxaspectratio", [1, 1, 1]); 
+         "xaxislocation", "zero", "yaxislocation", "zero",
+         "plotboxaspectratio", [1, 1, 1]); 
 
     if (nargout > 0)
       retval = tmp;
     endif
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
diff --git a/scripts/plot/private/__actual_axis_position__.m b/scripts/plot/private/__actual_axis_position__.m
--- a/scripts/plot/private/__actual_axis_position__.m
+++ b/scripts/plot/private/__actual_axis_position__.m
@@ -30,17 +30,17 @@ function pos = __actual_axis_position__ 
   endif
 
   ## When using {rltb}margin, Gnuplot does not handle the specified
   ## aspect ratio properly, so handle it here.
   if (__calc_dimensions__ (axis_obj) == 3)
     ## FIXME -- this works for "axis square", but has not been
     ##          thoroughly tested for other aspect ratios.
     aspect_ratio_2d = [max(axis_obj.plotboxaspectratio(1:2)), ...
-			   axis_obj.plotboxaspectratio(3)/sqrt(2)];
+                           axis_obj.plotboxaspectratio(3)/sqrt(2)];
   else
     aspect_ratio_2d = axis_obj.plotboxaspectratio(1:2);
   endif
   orig_fig_units = get (axis_obj.parent, "units");
   orig_fig_position = get (axis_obj.parent, "position");
   unwind_protect
     set (axis_obj.parent, "units", "pixels")
     fig_position = get (axis_obj.parent, "position");
diff --git a/scripts/plot/private/__add_datasource__.m b/scripts/plot/private/__add_datasource__.m
--- a/scripts/plot/private/__add_datasource__.m
+++ b/scripts/plot/private/__add_datasource__.m
@@ -35,21 +35,21 @@ function newargs = __add_datasource__ (f
     addproperty (strcat (data{i}, "datasource"), h, "string", "");
   endfor
 
   i = 0;
   newargs = {};
   while (i < numel (varargin))
     arg = varargin{++i};
     if (i != numel(varargin) && ischar (arg)
-	&& length (arg) > 9 && strcmpi (arg(end-9:end), "datasource"))
+        && length (arg) > 9 && strcmpi (arg(end-9:end), "datasource"))
       arg = tolower (arg);
       val = varargin{++i};
       if (ischar (val))
-	set (h, arg, val);
+        set (h, arg, val);
       else
-	error ("%s: expecting data source to be a string", fcn);
+        error ("%s: expecting data source to be a string", fcn);
       endif
     else
       newargs{end + 1} = arg;
     endif
   endwhile
 endfunction
diff --git a/scripts/plot/private/__axes_limits__.m b/scripts/plot/private/__axes_limits__.m
--- a/scripts/plot/private/__axes_limits__.m
+++ b/scripts/plot/private/__axes_limits__.m
@@ -31,22 +31,22 @@ function retval = __axes_limits__ (fcn, 
 
   if (nargin == 0)
     retval = get (h, fcn);
   else
     arg = varargin{1};
 
     if (ischar (arg))
       if (strcmpi (arg, "mode"))
-	retval = get (h, fcnmode);
+        retval = get (h, fcnmode);
       elseif (strcmpi (arg, "auto") ||  strcmpi (arg, "manual"))
-	set (h, fcnmode, arg);
+        set (h, fcnmode, arg);
       endif
     else
       if (!isnumeric (arg) && any (size(arg(:)) != [2, 1]))
-	error ("%s: argument must be a 2 element vector", fcn);
+        error ("%s: argument must be a 2 element vector", fcn);
       else
-	set (h, fcn, arg(:));
+        set (h, fcn, arg(:));
       endif
     endif
   endif
 
 endfunction
diff --git a/scripts/plot/private/__axis_label__.m b/scripts/plot/private/__axis_label__.m
--- a/scripts/plot/private/__axis_label__.m
+++ b/scripts/plot/private/__axis_label__.m
@@ -32,17 +32,17 @@ function retval = __axis_label__ (caller
     h = get (gca (), caller);
 
     set (h, "fontangle", get (ca, "fontangle"),
          "fontname", get (ca, "fontname"),
          "fontsize", get (ca, "fontsize"),
          "fontunits", get (ca, "fontunits"),
          "fontweight", get (ca, "fontweight"),
          "string", txt,
-	 varargin{:});
+         varargin{:});
 
     if (nargout > 0)
       retval = h;
     endif
   else
     error ("%s: expecting first argument to be character string", caller);
   endif
 
diff --git a/scripts/plot/private/__bar__.m b/scripts/plot/private/__bar__.m
--- a/scripts/plot/private/__bar__.m
+++ b/scripts/plot/private/__bar__.m
@@ -43,23 +43,23 @@ function varargout = __bar__ (vertical, 
     endif
     y = varargin{2};
     if (isvector (y))
       y = y(:);
     endif
     if (size (x, 1) != size (y, 1))
       y = varargin{1};
       if (isvector (y))
-	y = y(:);
+        y = y(:);
       endif
       x = [1:size(y,1)]';
       idx = 2;
     else
       if (! isvector (x))
-	error ("%s: x must be a vector", func);
+        error ("%s: x must be a vector", func);
       endif
       idx = 3;
     endif
   else
     y = varargin{1};
     if (isvector (y))
       y = y(:);
     endif
@@ -73,37 +73,37 @@ function varargout = __bar__ (vertical, 
     if (ischar (varargin{idx}) && strcmpi (varargin{idx}, "grouped"))
       group = true;
       idx++;
     elseif (ischar (varargin{idx}) && strcmpi (varargin{idx}, "stacked"))
       group = false;
       idx++;
     else
       if ((ischar (varargin{idx}) || iscell (varargin{idx}))
-	  && ! have_line_spec)
-	[linespec, valid] = __pltopt__ (func, varargin{idx}, false);
-	if (valid)
-	  have_line_spec = true;
-	  newargs = [{linespec.color}, newargs];
-	  idx++;
-	  continue;
-	endif
+          && ! have_line_spec)
+        [linespec, valid] = __pltopt__ (func, varargin{idx}, false);
+        if (valid)
+          have_line_spec = true;
+          newargs = [{linespec.color}, newargs];
+          idx++;
+          continue;
+        endif
       endif
       if (isscalar(varargin{idx}))
-	width = varargin{idx++};
+        width = varargin{idx++};
       elseif (idx == nargin - 2)
-	newargs = [newargs,varargin(idx++)];
+        newargs = [newargs,varargin(idx++)];
       elseif (ischar (varargin{idx})
-	      && strcmpi (varargin{idx}, "basevalue")
-	      && isscalar (varargin{idx+1}))
+              && strcmpi (varargin{idx}, "basevalue")
+              && isscalar (varargin{idx+1}))
         bv = varargin{idx+1};
         idx += 2;
       else
-	newargs = [newargs,varargin(idx:idx+1)];
-	idx += 2;
+        newargs = [newargs,varargin(idx:idx+1)];
+        idx += 2;
       endif
     endif
   endwhile
 
   xlen = size (x, 1);
   ylen = size (y, 1);
 
   if (xlen != ylen)
@@ -148,19 +148,19 @@ function varargout = __bar__ (vertical, 
 
   if (nargout < 2)
     oldh = gca ();
     unwind_protect
       axes (h);
       newplot ();
 
       tmp = bars (h, vertical, x, y, xb, yb, width, group,
-		  have_line_spec, bv, newargs{:});
+                  have_line_spec, bv, newargs{:});
       if (nargout == 1)
-	varargout{1} = tmp;
+        varargout{1} = tmp;
       endif
     unwind_protect_cleanup
       axes (oldh);
     end_unwind_protect
   else
     if (vertical)
       varargout{1} = xb;
       varargout{2} = yb;
@@ -180,37 +180,37 @@ function tmp = bars (ax, vertical, x, y,
 
   for i = 1:ycols
     hg = hggroup ();
     tmp = [tmp; hg];
     args = __add_datasource__ ("bar", hg, {"x", "y"}, varargin{:});
     
     if (vertical)
       if (! have_color_spec)
-	if (ycols == 1)
-	  lev = clim(1);
-	else
-	  lev = (i - 1) * (clim(2) - clim(1)) / (ycols - 1) - clim(1);
-	endif
-	h = patch(xb(:,:,i), yb(:,:,i), "FaceColor", "flat", 
-		  "cdata", lev, "parent", hg);
+        if (ycols == 1)
+          lev = clim(1);
+        else
+          lev = (i - 1) * (clim(2) - clim(1)) / (ycols - 1) - clim(1);
+        endif
+        h = patch(xb(:,:,i), yb(:,:,i), "FaceColor", "flat", 
+                  "cdata", lev, "parent", hg);
       else
-	h = patch(xb(:,:,i), yb(:,:,i), "parent", hg);
+        h = patch(xb(:,:,i), yb(:,:,i), "parent", hg);
       endif
     else
       if (! have_color_spec)
-	if (ycols == 1)
-	  lev = clim(1)
-	else
-	  lev = (i - 1) * (clim(2) - clim(1)) / (ycols - 1) - clim(1);
-	endif
-	h = patch(yb(:,:,i), xb(:,:,i), "FaceColor", "flat", 
-		  "cdata", lev, "parent", hg);
+        if (ycols == 1)
+          lev = clim(1)
+        else
+          lev = (i - 1) * (clim(2) - clim(1)) / (ycols - 1) - clim(1);
+        endif
+        h = patch(yb(:,:,i), xb(:,:,i), "FaceColor", "flat", 
+                  "cdata", lev, "parent", hg);
       else
-	h = patch(yb(:,:,i), xb(:,:,i), "parent", hg);
+        h = patch(yb(:,:,i), xb(:,:,i), "parent", hg);
       endif
     endif
 
     if (i == 1)
       x_axis_range = get (ax, "xlim");
       h_baseline = line (x_axis_range, [0, 0], "color", [0, 0, 0]);
       set (h_baseline, "handlevisibility", "off");
       set (h_baseline, "xliminclude", "off");
@@ -279,55 +279,55 @@ endfunction
 function update_xlim (h, d)
   kids = get (h, "children");
   xlim = get (h, "xlim");
 
   for i = 1 : length (kids)
     obj = get (kids (i));
     if (strcmp (obj.type, "hggroup") && isfield (obj, "baseline"))
       if (any (get (obj.baseline, "xdata") != xlim))
-	set (obj.baseline, "xdata", xlim);
+        set (obj.baseline, "xdata", xlim);
       endif
     endif
   endfor
 endfunction
 
 function update_baseline (h, d)
   visible = get (h, "visible");
   ydata = get (h, "ydata")(1);
 
   kids = get (get (h, "parent"), "children");
   for i = 1 : length (kids)
     obj = get (kids (i));
     if (strcmp (obj.type, "hggroup") && isfield (obj, "baseline") 
-	&& obj.baseline == h)
+        && obj.baseline == h)
       ## Only alter if changed to avoid recursion of the listener functions
       if (! strcmpi (get (kids(i), "showbaseline"), visible))
-	set (kids (i), "showbaseline", visible);
+        set (kids (i), "showbaseline", visible);
       endif
       if (! strcmpi (get (kids(i), "basevalue"), visible))
-	set (kids (i), "basevalue", ydata);
+        set (kids (i), "basevalue", ydata);
       endif
     endif
   endfor
 endfunction
 
 function show_baseline (h, d)
   persistent recursion = false;
 
   ## Don't allow recursion
   if (! recursion)
     unwind_protect
       recursion = true;
       hlist = get (h, "bargroup");
       showbaseline = get (h, "showbaseline");
       for hh = hlist(:)'
-	if (hh != h)
-	  set (hh, "showbaseline", showbaseline);
-	endif
+        if (hh != h)
+          set (hh, "showbaseline", showbaseline);
+        endif
       endfor
       set (get (h, "baseline"), "visible", showbaseline);
     unwind_protect_cleanup
       recursion = false;
     end_unwind_protect
   endif
 endfunction
 
@@ -357,36 +357,36 @@ function update_data (h, d)
 
   ## Don't allow recursion
   if (! recursion)
     unwind_protect
       recursion = true;
       hlist = get (h, "bargroup");
       x = get (h, "xdata");
       if (!isvector (x))
-	x = x(:);
+        x = x(:);
       endif
       y = [];
       for hh = hlist(:)'
-	ytmp = get (hh, "ydata");
-	y = [y ytmp(:)];
+        ytmp = get (hh, "ydata");
+        y = [y ytmp(:)];
       endfor
 
       [xb, yb] = bar (x, y, get (h, "barwidth"), get (h, "barlayout"),
-		      "basevalue", get (h, "basevalue"));
+                      "basevalue", get (h, "basevalue"));
       ny = columns (y);
       vert = strcmpi (get (h, "horizontal"), "off");
 
       for i = 1:ny
-	hp = get (hlist(i), "children");
-	if (vert)
-	  set (hp, "xdata", xb(:,:,i), "ydata", yb(:,:,i));
-	else
-	  set (hp, "xdata", yb(:,:,i), "ydata", xb(:,:,i));
-	endif
+        hp = get (hlist(i), "children");
+        if (vert)
+          set (hp, "xdata", xb(:,:,i), "ydata", yb(:,:,i));
+        else
+          set (hp, "xdata", yb(:,:,i), "ydata", xb(:,:,i));
+        endif
       endfor
     unwind_protect_cleanup
       recursion = false;
     end_unwind_protect
   endif
 endfunction
 
 function update_group (h, d)
@@ -398,26 +398,26 @@ function update_group (h, d)
       recursion = true;
       hlist = get (h, "bargroup");
       barwidth = get(h, "barwidth");
       barlayout = get (h, "barlayout");
       horizontal = get (h, "horizontal");
 
       ## To prevent recursion, only change if modified
       for hh = hlist(:)'
-	if (hh != h)
-	  if (get (hh, "barwidth") != barwidth)
-	    set (hh, "barwidth", barwidth);
-	  endif
-	  if (! strcmpi (get (hh, "barlayout"), barlayout))
-	    set (hh, "barlayout", barlayout);
-	  endif
-	  if (! strcmpi (get (hh, "horizontal"), horizontal))
-	    set (hh, "horizontal", horizontal);
-	  endif
-	endif
+        if (hh != h)
+          if (get (hh, "barwidth") != barwidth)
+            set (hh, "barwidth", barwidth);
+          endif
+          if (! strcmpi (get (hh, "barlayout"), barlayout))
+            set (hh, "barlayout", barlayout);
+          endif
+          if (! strcmpi (get (hh, "horizontal"), horizontal))
+            set (hh, "horizontal", horizontal);
+          endif
+        endif
       endfor
       update_data (h, d);
     unwind_protect_cleanup
       recursion = false;
     end_unwind_protect
   endif
 endfunction
diff --git a/scripts/plot/private/__clabel__.m b/scripts/plot/private/__clabel__.m
--- a/scripts/plot/private/__clabel__.m
+++ b/scripts/plot/private/__clabel__.m
@@ -24,17 +24,17 @@
 function h = __clabel__ (c, v, hparent, label_spacing, z, varargin)
   ## FIXME
   ## Assume that the plot size is 4 by 3 inches.
   lims = axis ();
   xspacing = 72 * 4 / abs(lims(1) - lims(2));
   yspacing = 72 * 3 / abs(lims(3) - lims(4));
 
   if (isscalar (hparent) && ishandle(hparent) && 
-	strcmp (get (hparent, "type"), "hggroup"))
+        strcmp (get (hparent, "type"), "hggroup"))
     x = get (hparent, "xdata");
     xmin = min (x(:));
     xmax = max (x(:));
     y = get (hparent, "ydata");
     ymin = min (y(:));
     ymax = max (y(:));
   else
     i1 = 1;
@@ -80,36 +80,36 @@ function h = __clabel__ (c, v, hparent, 
     endif
 
     j1 = 2;
     tlabel = sprintf ("%g", clev);
     for i = 1 : ntag
       tagpos = pos(i);
       
       while (j1 < clen && cumd(j1) < tagpos)
-	j1++;
+        j1++;
       endwhile
       tpos = sum(c(:,i1+j1-1:i1+j1), 2) ./ 2;
 
       if (tpos(1) != xmin &&  tpos(1) != xmax && 
-	  tpos(2) != ymin &&  tpos(2) != ymax)
-	trot = 180 / pi * atan2 (diff (c(2,i1+j1-1:i1+j1)),
-				 diff (c(1,i1+j1-1:i1+j1)));
+          tpos(2) != ymin &&  tpos(2) != ymax)
+        trot = 180 / pi * atan2 (diff (c(2,i1+j1-1:i1+j1)),
+                                 diff (c(1,i1+j1-1:i1+j1)));
 
-	if (ischar (z))
-	  ht = text (tpos(1), tpos(2), clev, tlabel, "rotation", trot, 
-		     "parent", hparent, "horizontalalignment", "center",
-		     "userdata", clev, varargin{:});
-	elseif (!isempty (z))
-	  ht = text (tpos(1), tpos(2), z, tlabel, "rotation", trot, 
-		     "parent", hparent, "horizontalalignment", "center",
-		     "userdata", clev, varargin{:});
-	else
-	  ht = text (tpos(1), tpos(2), tlabel, "rotation", trot,
-		     "parent", hparent, "horizontalalignment", "center",
-		     "userdata", clev, varargin{:});
-	endif
-	h = [h; ht];
+        if (ischar (z))
+          ht = text (tpos(1), tpos(2), clev, tlabel, "rotation", trot, 
+                     "parent", hparent, "horizontalalignment", "center",
+                     "userdata", clev, varargin{:});
+        elseif (!isempty (z))
+          ht = text (tpos(1), tpos(2), z, tlabel, "rotation", trot, 
+                     "parent", hparent, "horizontalalignment", "center",
+                     "userdata", clev, varargin{:});
+        else
+          ht = text (tpos(1), tpos(2), tlabel, "rotation", trot,
+                     "parent", hparent, "horizontalalignment", "center",
+                     "userdata", clev, varargin{:});
+        endif
+        h = [h; ht];
       endif
     endfor
     i1 += clen+1;
   endwhile
 endfunction 
\ No newline at end of file
diff --git a/scripts/plot/private/__contour__.m b/scripts/plot/private/__contour__.m
--- a/scripts/plot/private/__contour__.m
+++ b/scripts/plot/private/__contour__.m
@@ -29,52 +29,52 @@ function [c, hg] = __contour__ (varargin
   linespec.linestyle = "-";
   linespec.color = "auto";
   edgecolor = "flat";
   for i = 3 : nargin
     arg = varargin {i};
     if ((ischar (arg) || iscell (arg)))
       [linespec, valid] = __pltopt__ ("__contour__", arg, false);
       if (isempty (linespec.color))
-	linespec.color = "auto";
+        linespec.color = "auto";
       endif
       if (isempty (linespec.linestyle))
-	linespec.linestyle = "-";
+        linespec.linestyle = "-";
       endif
       if (valid)
-	have_line_spec = true;
-	varargin(i) = [];
-	break;
+        have_line_spec = true;
+        varargin(i) = [];
+        break;
       endif
     endif
   endfor
 
   opts = {};
   i = 3;
   while (i < length (varargin))
     if (ischar (varargin {i}))
       if (strcmpi (varargin{i}, "fill"))
-	filled = varargin {i + 1};
-	varargin(i:i+1) = [];
+        filled = varargin {i + 1};
+        varargin(i:i+1) = [];
       elseif (strcmpi (varargin{i}, "linecolor"))
-	linespec.color = varargin {i + 1};
-	edgecolor = linespec.color;
-	if (ischar (edgecolor) && strcmpi (edgecolor, "auto"))
-	  edgecolor = "flat";
-	endif
-	varargin(i:i+1) = [];
+        linespec.color = varargin {i + 1};
+        edgecolor = linespec.color;
+        if (ischar (edgecolor) && strcmpi (edgecolor, "auto"))
+          edgecolor = "flat";
+        endif
+        varargin(i:i+1) = [];
       elseif (strcmpi (varargin{i}, "edgecolor"))
-	linespec.color = varargin {i + 1};
-	edgecolor = linespec.color;
-	if (ischar (edgecolor) && strcmpi (edgecolor, "flat"))
-	  linespec.color = "auto";
-	endif
-	varargin(i:i+1) = [];
+        linespec.color = varargin {i + 1};
+        edgecolor = linespec.color;
+        if (ischar (edgecolor) && strcmpi (edgecolor, "flat"))
+          linespec.color = "auto";
+        endif
+        varargin(i:i+1) = [];
       else
-	opts{end+1} = varargin{i};
+        opts{end+1} = varargin{i};
         varargin(i) = [];
         opts{end+1} = varargin{i};
         varargin(i) = [];
       endif
     else
       i++;
     endif
   endwhile
@@ -93,17 +93,17 @@ function [c, hg] = __contour__ (varargin
     vnauto = false;
   else
     vnauto = true;
     vn = 10; 
   endif
 
   if (isscalar (vn))
     lvl = linspace (min (z1(!isinf(z1))), max (z1(!isinf(z1))), 
-		    vn + 2)(1:end-1);
+                    vn + 2)(1:end-1);
   else
     lvl = vn;
   endif
 
   if (strcmpi (filled, "on"))
     if (isvector (x1) || isvector (y1))
       [x1, y1] = meshgrid (x1, y1);
     endif
@@ -251,50 +251,50 @@ function add_patch_children (hg)
 
     ## Handle for each level the case where we have (a) hole(s) in a patch.
     ## Those are to be filled with the color of level below or with the
     ## background colour.
     for k = 1:numel (lev)
       lvl_idx = find (abs (cont_lev - lev(k)) < lvl_eps);
       len = numel (lvl_idx);
       if (len > 1)
-	## mark = logical(zeros(size(lvl_idx)));
-	mark = false (size (lvl_idx));
-	a = 1;
-	while (a < len)
-	  ## take 1st patch
+        ## mark = logical(zeros(size(lvl_idx)));
+        mark = false (size (lvl_idx));
+        a = 1;
+        while (a < len)
+          ## take 1st patch
           b = a + 1;
           pa_idx = lvl_idx(a);
           ## get pointer to contour start, and contour length
           curr_ct_idx = cont_idx(pa_idx);
           curr_ct_len = cont_len(pa_idx);
-	  ## get contour
+          ## get contour
           curr_ct = c(:, curr_ct_idx:curr_ct_idx+curr_ct_len-1);
           b_vec = (a+1):len;
           next_ct_pt_vec = c(:, cont_idx(lvl_idx(b_vec)));
           in = inpolygon (next_ct_pt_vec(1,:), next_ct_pt_vec(2,:),
-			  curr_ct(1, :), curr_ct(2, :));
+                          curr_ct(1, :), curr_ct(2, :));
           mark(b_vec(in)) = !mark(b_vec(in));
           a++;
-	endwhile
-	if (numel (mark) > 0)
-	  ## All marked contours describe a hole in a larger contour of
-	  ## the same level and must be filled with colour of level below.
+        endwhile
+        if (numel (mark) > 0)
+          ## All marked contours describe a hole in a larger contour of
+          ## the same level and must be filled with colour of level below.
           ma_idx = lvl_idx(mark);
           if (k > 1)
-	    ## Find color of level below.
+            ## Find color of level below.
             tmp = find(abs(cont_lev - lev(k - 1)) < lvl_eps);
             lvl_bel_idx = tmp(1);
-	    ## Set color of patches found.
-	    cont_lev(ma_idx) = cont_lev(lvl_bel_idx);
+            ## Set color of patches found.
+            cont_lev(ma_idx) = cont_lev(lvl_bel_idx);
           else
-	    ## Set lowest level contour to NaN.
-	    cont_lev(ma_idx) = NaN;
+            ## Set lowest level contour to NaN.
+            cont_lev(ma_idx) = NaN;
           endif
-	endif
+        endif
       endif
     endfor
 
     ## The algorithm can create patches with the size of the plotting
     ## area, we would like to draw only the patch with the highest level.
     del_idx = [];
     max_idx = find (cont_area == max (cont_area));
     if (numel (max_idx) > 1)
@@ -310,20 +310,20 @@ function add_patch_children (hg)
     len = ncont - numel (del_idx);
     h = [];
     for n = len:(-1):1
       idx = svec(n);
       ctmp = c(:, cont_idx(idx):cont_idx(idx) + cont_len(idx) - 1);
       if (all (ctmp(:,1) == ctmp(:,end)))
         ctmp(:, end) = [];
       else
-	## Special case unclosed contours
+        ## Special case unclosed contours
       endif
       h = [h; patch(ctmp(1, :), ctmp(2, :), cont_lev(idx), "edgecolor", lc, 
-		    "linestyle", ls, "linewidth", lw, "parent", hg)];
+                    "linestyle", ls, "linewidth", lw, "parent", hg)];
     endfor
 
     if (min (lev) == max (lev))
       set (gca (), "clim", [min(lev)-1, max(lev)+1]);
     else
       set (gca(), "clim", [min(lev), max(lev)]);
     endif
 
@@ -332,36 +332,36 @@ function add_patch_children (hg)
     ## Decode contourc output format.
     i1 = 1;
     h = [];
     while (i1 < length (c))
       clev = c(1,i1);
       clen = c(2,i1);
 
       if (all (c(:,i1+1) == c(:,i1+clen)))
-	p = c(:, i1+1:i1+clen-1);
+        p = c(:, i1+1:i1+clen-1);
       else
-	p = [c(:, i1+1:i1+clen), NaN(2, 1)];
+        p = [c(:, i1+1:i1+clen), NaN(2, 1)];
       endif
 
       switch (zmode)
-	case "none"
-	  h = [h; patch(p(1,:), p(2,:), "facecolor", "none", 
-			"edgecolor", lc, "linestyle", ls, "linewidth", lw,
-			"cdata", clev, "parent", hg)]; 
-	case "auto"
-	  h = [h; patch(p(1,:), p(2,:), clev * ones (1, columns (p)),
-			"facecolor", "none", "edgecolor", lc, 
-			"linestyle", ls, "linewidth", lw, "cdata", clev, 
-			"parent", hg)];
-	otherwise
-	  h = [h; patch(p(1,:), p(2,:), z * ones (1, columns (p)),
-			"facecolor", "none", "edgecolor", lc,
-			"linestyle", ls, "linewidth", lw, "cdata", clev,
-			"parent", hg)];
+        case "none"
+          h = [h; patch(p(1,:), p(2,:), "facecolor", "none", 
+                        "edgecolor", lc, "linestyle", ls, "linewidth", lw,
+                        "cdata", clev, "parent", hg)]; 
+        case "auto"
+          h = [h; patch(p(1,:), p(2,:), clev * ones (1, columns (p)),
+                        "facecolor", "none", "edgecolor", lc, 
+                        "linestyle", ls, "linewidth", lw, "cdata", clev, 
+                        "parent", hg)];
+        otherwise
+          h = [h; patch(p(1,:), p(2,:), z * ones (1, columns (p)),
+                        "facecolor", "none", "edgecolor", lc,
+                        "linestyle", ls, "linewidth", lw, "cdata", clev,
+                        "parent", hg)];
       endswitch
       i1 += clen+1;
     endwhile
   endif
 
 endfunction
 
 function update_zlevel (h, d)
@@ -369,22 +369,22 @@ function update_zlevel (h, d)
   zmode = get (h, "zlevelmode");
   kids = get (h, "children");
 
   switch (zmode)
     case "none"
       set (kids, "zdata", []);
     case "auto"
       for i = 1 : length (kids)
-	set (kids(i), "zdata", get (kids (i), "cdata") .* 
-	     ones (size (get (kids (i), "xdata"))));
+        set (kids(i), "zdata", get (kids (i), "cdata") .* 
+             ones (size (get (kids (i), "xdata"))));
       endfor
     otherwise
       for i = 1 : length (kids)
-	set (kids(i), "zdata", z .* ones (size (get (kids (i), "xdata"))));
+        set (kids(i), "zdata", z .* ones (size (get (kids (i), "xdata"))));
       endfor
   endswitch
 endfunction
 
 function update_edgecolor (h, d)
   ec = get (h, "edgecolor");
   lc = get (h, "linecolor");
   if (ischar (ec) && strcmpi (ec, "flat"))
@@ -426,31 +426,31 @@ function update_data (h, d)
       lvl = 10;
     endif
 
     if (strcmpi (get (h, "fill"), "on"))
       X = get (h, "xdata");
       Y = get (h, "ydata");
       Z = get (h, "zdata");
       if (isvector (X) || isvector (Y))
-	[X, Y] = meshgrid (X, Y);
+        [X, Y] = meshgrid (X, Y);
       endif
       [nr, nc] = size (Z);
       X0 = prepad(X, nc+1, 2 * X(1, 1) - X(1, 2), 2);
       X0 = postpad(X0, nc+2, 2 * X(1, nc) - X(1, nc - 1), 2);
       X0 = [X0(1, :); X0; X0(1, :)];
       Y0 = prepad(Y, nr+1, 2 * Y(1, 1) - Y(2, 1), 1);
       Y0 = postpad(Y0, nr+2, 2 * Y(nr, 1) - Y(nr - 1, 1));
       Y0 = [Y0(:, 1), Y0, Y0(:, 1)];
       Z0 = -Inf(nr+2, nc+2);
       Z0(2:nr+1, 2:nc+1) = Z;
       [c, lev] = contourc (X0, Y0, Z0, lvl);
     else
       [c, lev] = contourc (get (h, "xdata"), get (h, "ydata"), 
-			   get (h, "zdata"), lvl); 
+                           get (h, "zdata"), lvl); 
     endif
     set (h, "contourmatrix", c);
 
     if (strcmpi (get (h, "levellistmode"), "manual"))
       ## Do nothing
     elseif (strcmpi (get (h, "levelstepmode"), "manual"))
       set (h, "levellist", lev);
     else
@@ -488,25 +488,25 @@ function update_text (h, d)
       set (h, "textlist", lvl);
     else
       lvl = get (h, "levellist");
       set (h, "textlist", lvl, "textstep", get (h, "levelstep"));
     endif
 
     if (strcmpi (get (h, "showtext"), "on"))
       switch (get (h, "zlevelmode"))
-	case "manual"
-	  __clabel__ (get (h, "contourmatrix"), lvl, h, 
-		      get (h, "labelspacing"), get (h, "zlevel"));
-	case "auto"
-	  __clabel__ (get (h, "contourmatrix"), lvl, h,
-		      get (h, "labelspacing"), "auto");
-	otherwise
-	  __clabel__ (get (h, "contourmatrix"), lvl, h,
-		      get (h, "labelspacing"), []);
+        case "manual"
+          __clabel__ (get (h, "contourmatrix"), lvl, h, 
+                      get (h, "labelspacing"), get (h, "zlevel"));
+        case "auto"
+          __clabel__ (get (h, "contourmatrix"), lvl, h,
+                      get (h, "labelspacing"), "auto");
+        otherwise
+          __clabel__ (get (h, "contourmatrix"), lvl, h,
+                      get (h, "labelspacing"), []);
       endswitch
     endif
   endif
 
   recursive = false;
 endfunction
 
 function lvl_eps = get_lvl_eps (lev)
diff --git a/scripts/plot/private/__errcomm__.m b/scripts/plot/private/__errcomm__.m
--- a/scripts/plot/private/__errcomm__.m
+++ b/scripts/plot/private/__errcomm__.m
@@ -46,31 +46,31 @@ function retval = __errcomm__ (caller, p
       usage ("%s (...)", caller);
     endif
     sz = size (a);
     ndata = 1;
     data{ndata} = a;
     while (k <= nargs)
       a = varargin{k++};
       if (ischar (a) || iscellstr (a))
-	retval(idx++) = __errplot__ (a, p, data{1:ndata});
-	break;
+        retval(idx++) = __errplot__ (a, p, data{1:ndata});
+        break;
       elseif (isvector (a))
-	a = a(:);
+        a = a(:);
       elseif (ismatrix (a))
-	;
+        ;
       else
-	error ("wrong argument types");
+        error ("wrong argument types");
       endif
       if (size (a) != sz)
-	error ("argument sizes do not match");
+        error ("argument sizes do not match");
       endif
       data{++ndata} = a;
       if (ndata > 6)
-	error ("too many arguments to a plot");
+        error ("too many arguments to a plot");
       endif
     endwhile
   endwhile
 
   if (! (ischar (a) || iscellstr (a)))
     retval(idx++) = __errplot__ ("~", p, data{1:ndata});
   endif
 
diff --git a/scripts/plot/private/__errplot__.m b/scripts/plot/private/__errplot__.m
--- a/scripts/plot/private/__errplot__.m
+++ b/scripts/plot/private/__errplot__.m
@@ -54,17 +54,17 @@ function h = __errplot__ (fstr, p, a1, a
       ifmt = "boxxy";
     else
       print_usage ();
     endif
 
     hg = hggroup ("parent", p);
     h = [h; hg];
     args = __add_datasource__ ("__errplot__", hg, 
-			       {"x", "y", "l", "u", "xl", "xu"});
+                               {"x", "y", "l", "u", "xl", "xu"});
 
     if (isempty (fmt.color))
       hl = __line__ (hg, "color", __next_line_color__ ());
     else
       hl = __line__ (hg, "color", fmt.color);
     endif
 
     ## FIXME -- note the code below adds the errorbar data directly as
@@ -72,64 +72,64 @@ function h = __errplot__ (fstr, p, a1, a
     ## this.  Matlab has the errorbar part of the plot as a special line
     ## object with embedded NaNs that draws the three segments of the
     ## bar separately.  Should we duplicate Matlab's behavior and stop
     ## using the ldata, etc. properties of the line objects that are
     ## Octace specific?
 
     switch (nargin - 2)
       case 1
-	error ("error plot requires 2, 3, 4 or 6 columns");
+        error ("error plot requires 2, 3, 4 or 6 columns");
       case 2
-	set (hl, "xdata", (1:len)');
-	set (hl, "ydata", a1(:,i));
-	set (hl, "ldata", a2(:,i));
-	set (hl, "udata", a2(:,i));
+        set (hl, "xdata", (1:len)');
+        set (hl, "ydata", a1(:,i));
+        set (hl, "ldata", a2(:,i));
+        set (hl, "udata", a2(:,i));
       case 3
-	set (hl, "xdata", a1(:,i));
-	set (hl, "ydata", a2(:,i));
-	set (hl, "ldata", a3(:,i));
-	set (hl, "udata", a3(:,i));
+        set (hl, "xdata", a1(:,i));
+        set (hl, "ydata", a2(:,i));
+        set (hl, "ldata", a3(:,i));
+        set (hl, "udata", a3(:,i));
       case 4
-	set (hl, "xdata", a1(:,i));
-	set (hl, "ydata", a2(:,i));
+        set (hl, "xdata", a1(:,i));
+        set (hl, "ydata", a2(:,i));
 
-	if (index (ifmt, "boxxy") || index (ifmt, "xyerr"))
-	  set (hl, "xldata", a3(:,i));
-	  set (hl, "xudata", a3(:,i));
-	  set (hl, "ldata", a4(:,i));
-	  set (hl, "udata", a4(:,i));
-	elseif (index (ifmt, "xerr"))
-	  set (hl, "xldata", a3(:,i));
-	  set (hl, "xudata", a4(:,i));
-	else
-	  set (hl, "ldata", a3(:,i));
-	  set (hl, "udata", a4(:,i));
-	endif
+        if (index (ifmt, "boxxy") || index (ifmt, "xyerr"))
+          set (hl, "xldata", a3(:,i));
+          set (hl, "xudata", a3(:,i));
+          set (hl, "ldata", a4(:,i));
+          set (hl, "udata", a4(:,i));
+        elseif (index (ifmt, "xerr"))
+          set (hl, "xldata", a3(:,i));
+          set (hl, "xudata", a4(:,i));
+        else
+          set (hl, "ldata", a3(:,i));
+          set (hl, "udata", a4(:,i));
+        endif
       case 5
-	error ("error plot requires 2, 3, 4 or 6 columns");
+        error ("error plot requires 2, 3, 4 or 6 columns");
       case 6
-	set (hl, "xdata", a1(:,i));
-	set (hl, "ydata", a2(:,i));
-	set (hl, "xldata", a3(:,i));
-	set (hl, "xudata", a4(:,i));
-	set (hl, "ldata", a5(:,i));
-	set (hl, "udata", a6(:,i));
+        set (hl, "xdata", a1(:,i));
+        set (hl, "ydata", a2(:,i));
+        set (hl, "xldata", a3(:,i));
+        set (hl, "xudata", a4(:,i));
+        set (hl, "ldata", a5(:,i));
+        set (hl, "udata", a6(:,i));
     endswitch
 
     addproperty ("color", hg, "linecolor", get (hl, "color"));
     addproperty ("linewidth", hg, "linelinewidth", get (hl, "linewidth"));
     addproperty ("linestyle", hg, "linelinestyle", get (hl, "linestyle"));
     addproperty ("marker", hg, "linemarker", get (hl, "marker"));
     addproperty ("markerfacecolor", hg, "linemarkerfacecolor", 
-		 get (hl, "markerfacecolor"));
+                 get (hl, "markerfacecolor"));
     addproperty ("markeredgecolor", hg, "linemarkerfacecolor", 
-		 get (hl, "markeredgecolor"));
+                 get (hl, "markeredgecolor"));
     addproperty ("markersize", hg, "linemarkersize", 
-		 get (hl, "markersize"));
+                 get (hl, "markersize"));
 
     addlistener (hg, "color", @update_props);
     addlistener (hg, "linewidth", @update_props); 
     addlistener (hg, "linestyle", @update_props); 
     addlistener (hg, "marker", @update_props); 
     addlistener (hg, "markerfacecolor", @update_props); 
     addlistener (hg, "markersize", @update_props);
 
@@ -143,21 +143,21 @@ function h = __errplot__ (fstr, p, a1, a
     addlistener (hg, "xdata", @update_data);
     addlistener (hg, "ydata", @update_data);
     addlistener (hg, "ldata", @update_data);
     addlistener (hg, "udata", @update_data);
     addlistener (hg, "xldata", @update_data);
     addlistener (hg, "xudata", @update_data);
 
     __line__ (hg, "xdata", get (hl, "xdata"), 
-	      "ydata", get (hl, "ydata"), 
-	      "color", get (hl, "color"),
-	      "linewidth", get (hl, "linewidth"),
-	      "linestyle", get (hl, "linestyle"), 
-	      "marker", "none", "parent", hg);
+              "ydata", get (hl, "ydata"), 
+              "color", get (hl, "color"),
+              "linewidth", get (hl, "linewidth"),
+              "linestyle", get (hl, "linestyle"), 
+              "marker", "none", "parent", hg);
   endfor
 
 endfunction
 
 function update_props (h, d)
   set (get (h, "children"), "color", get (h, "color"), 
        "linewidth", get (h, "linewidth"), "linestyle", get (h, "linestyle"), 
        "marker", get (h, "marker"), "markersize", get (h, "markersize"),
diff --git a/scripts/plot/private/__ezplot__.m b/scripts/plot/private/__ezplot__.m
--- a/scripts/plot/private/__ezplot__.m
+++ b/scripts/plot/private/__ezplot__.m
@@ -71,19 +71,19 @@ function [h, needusage] = __ezplot__ (pf
       nargs = 2;
     elseif (length (argnames (fun)) != nargs)
       error ("%s: excepting a function of %d arguments", func, nargs);
     endif
     fstr = formula (fun);
     if (isplot)
       xarg = argnames(fun){1};
       if (nargs == 2)
-	yarg = argnames(fun){2};
+        yarg = argnames(fun){2};
       else
-	yarg = "";
+        yarg = "";
       endif
     elseif (isplot3)
       xarg = "x";
       yarg = "y";
     elseif (ispolar)
       xarg = "";
       yarg = "";
     else
@@ -96,50 +96,50 @@ function [h, needusage] = __ezplot__ (pf
     elseif (length (argnames (fun)) != nargs)
       error ("%s: excepting a function of %d arguments", func, nargs);
     endif
     fun = vectorize (fun);
     fstr = formula (fun);
     if (isplot)
       xarg = argnames(fun){1};
       if (nargs == 2)
-	yarg = argnames(fun){2};
+        yarg = argnames(fun){2};
       else
-	yarg = "";
+        yarg = "";
       endif
     elseif (isplot3)
       xarg = "x";
       yarg = "y";
     elseif (isplot || ispolar)
       xarg = "";
       yarg = "";
     else
       xarg = argnames(fun)(1);
       yarg = argnames(fun)(2);
     endif
   elseif (isa (fun, "function_handle"))
     fstr = func2str (fun);
     if (length (findstr (fstr, ")")) != 0)
       args = regexp (substr (fstr, 3, findstr (fstr, ")")(1) - 3), 
-		     '(\w[\w\d]*)', 'tokens');
+                     '(\w[\w\d]*)', 'tokens');
     fstr = substr (fstr, findstr (fstr, ")")(1) + 1);
     else
       args = {{"x"}};
     endif
     if (isplot && length (args) == 2)
       nargs = 2;
     elseif (length (args) != nargs)
       error ("%s: excepting a function of %d arguments", func, nargs);
     endif
     if (isplot)
       xarg = args{1}{1};
       if (nargs == 2)
-	yarg = args{2}{1};
+        yarg = args{2}{1};
       else
-	yarg = "";
+        yarg = "";
       endif
     elseif (isplot3)
       xarg = "x";
       yarg = "y";
     elseif (ispolar)
       xarg = "";
       yarg = "";
     else
@@ -152,83 +152,83 @@ function [h, needusage] = __ezplot__ (pf
 
   if (nargin > 2 || (nargin == 2 && isplot))
     funx = fun;
     fstrx = fstr;
     funy = varargin {2};
     if (ischar (funy) && ! strcmp (funy, "circ") && ! strcmp (funy, "animate"))
       parametric = true;
       if (exist (funy, "file") || exist (funy, "builtin"))
-	funy = vectorize (inline (cstrcat (funy, "(t)")));
+        funy = vectorize (inline (cstrcat (funy, "(t)")));
       else
-	funy = vectorize (inline (funy));
+        funy = vectorize (inline (funy));
       endif
       if (length (argnames (funy)) != nargs)
-	error ("%s: excepting a function of %d arguments", func, nargs);
+        error ("%s: excepting a function of %d arguments", func, nargs);
       endif
       fstry = formula (funy);
     elseif (strcmp (typeinfo (funy), "inline function"))
       parametric = true;
       if (length (argnames (funy)) != nargs)
-	error ("%s: excepting a function of %d arguments", func, nargs);
+        error ("%s: excepting a function of %d arguments", func, nargs);
       endif
       funy = vectorize (funy);
       fstry = formula (funy);
     elseif (isa (funy, "function_handle"))
       parametric = true;
       fstry = func2str (funy);
       if (length (findstr (fstry, ")")) != 0)
-	args = regexp (substr (fstry, 3, findstr (fstry, ")")(1) - 3), 
-		       '(\w[\w\d]*)', 'tokens');
-	fstry = substr (fstry, findstr (fstry, ")")(1) + 1);
+        args = regexp (substr (fstry, 3, findstr (fstry, ")")(1) - 3), 
+                       '(\w[\w\d]*)', 'tokens');
+        fstry = substr (fstry, findstr (fstry, ")")(1) + 1);
       else
-	args = {{"y"}};
+        args = {{"y"}};
       endif
       if (length (args) != nargs)
-	error ("%s: excepting a function of %d arguments", func, nargs);
+        error ("%s: excepting a function of %d arguments", func, nargs);
       endif
     endif
 
     if (parametric && isplot)
       xarg = "x";
       yarg = "y";
       if (nargs == 2)
-	error ("%s: can not define a parametric function in this manner");
+        error ("%s: can not define a parametric function in this manner");
       endif
     endif
 
     if (!isplot && parametric)
       funz = varargin {3};
       if (ischar (funz) && ! strcmp (funz, "circ") && 
-	  ! strcmp (funz, "animate"))
-	if (exist (funz, "file") || exist (funz, "builtin"))
-	  funz = vectorize (inline (cstrcat (funz, "(t)")));
-	else
-	  funz = vectorize (inline (funz));
-	endif
-	if (length (argnames (funz)) != nargs)
-	  error ("%s: excepting a function of %d arguments", func, nargs);
-	endif
-	fstrz = formula (funz);
+          ! strcmp (funz, "animate"))
+        if (exist (funz, "file") || exist (funz, "builtin"))
+          funz = vectorize (inline (cstrcat (funz, "(t)")));
+        else
+          funz = vectorize (inline (funz));
+        endif
+        if (length (argnames (funz)) != nargs)
+          error ("%s: excepting a function of %d arguments", func, nargs);
+        endif
+        fstrz = formula (funz);
       elseif (strcmp (typeinfo (funz), "inline function"))
-	if (length (argnames (funz)) != nargs)
-	  error ("%s: excepting a function of %d arguments", func, nargs);
-	endif
-	funz = vectorize (funz);
-	fstrz = formula (funz);
+        if (length (argnames (funz)) != nargs)
+          error ("%s: excepting a function of %d arguments", func, nargs);
+        endif
+        funz = vectorize (funz);
+        fstrz = formula (funz);
       elseif (isa (funz, "function_handle"))
-	fstrz = func2str (funz);
-	args = regexp (substr (fstrz, 3, findstr (fstrz, ")")(1) - 3), 
-		       '(\w[\w\d]*)', 'tokens');
-	if (length (args) != nargs)
-	  error ("%s: excepting a function of %d arguments", func, nargs);
-	endif
-	fstrz = substr (fstrz, findstr (fstrz, ")")(1) + 1);
+        fstrz = func2str (funz);
+        args = regexp (substr (fstrz, 3, findstr (fstrz, ")")(1) - 3), 
+                       '(\w[\w\d]*)', 'tokens');
+        if (length (args) != nargs)
+          error ("%s: excepting a function of %d arguments", func, nargs);
+        endif
+        fstrz = substr (fstrz, findstr (fstrz, ")")(1) + 1);
       else
-	error ("%s: parametric plots expect 3 functions", func);
+        error ("%s: parametric plots expect 3 functions", func);
       endif
     endif
   endif
 
   if (isplot && nargs != 2)
     n = 500; 
   else
     n = 60;
@@ -272,23 +272,23 @@ function [h, needusage] = __ezplot__ (pf
 
   if (circ)
     if (iscontour || isplot3 || isplot)
       needusage = true;
       return;
     endif
     if (parametric)
       error ("%s: can not have both circular domain and parametric function", 
-	     func);
+             func);
     endif
     cent = [domain(1) + domain(2), domain(3) + domain(4)] / 2;
     funx = @(r,t) r .* cos (t) + cent (1);
     funy = @(r,t) r .* sin (t) + cent (2);
     domain = [0, sqrt((domain(2) - cent(1))^2 + (domain(4) - cent(2))^2), ...
-	      -pi, pi];
+              -pi, pi];
     funz = fun;
     parametric = true;
   endif
 
   if (animate)
     if (!isplot3)
       error ("%s: animated graphs only valid with plot3", func);
     endif
@@ -326,111 +326,111 @@ function [h, needusage] = __ezplot__ (pf
 
       ## Eliminate the singularities
       X = __eliminate_sing__ (X);
       Y = __eliminate_sing__ (Y);
       Z = __eliminate_sing__ (Z);
     endif
 
     fstrx = regexprep (regexprep (regexprep (fstrx,'\.\^\s*','^'), 
-		      '\./', '/'), '[\.]*\*', '');
+                      '\./', '/'), '[\.]*\*', '');
     fstry = regexprep (regexprep (regexprep (fstry,'\.\^\s*','^'), 
-		      '\./', '/'), '[\.]*\*', '');
+                      '\./', '/'), '[\.]*\*', '');
     if (isplot)
       fstr = cstrcat ("x = ",fstrx,", y = ",fstry);
     else
       fstrz = regexprep (regexprep (regexprep (fstrz,'\.\^\s*','^'), 
-				    '\./', '/'), '[\.]*\*', '');
+                                    '\./', '/'), '[\.]*\*', '');
       fstr = cstrcat ("x = ",fstrx,",y = ",fstry,", z = ",fstrz);
     endif
   else
     if (isplot3)
       needusage = true;
       return;
     endif
 
     fstr = regexprep (regexprep (regexprep (fstr,'\.\^\s*','^'), '\./', '/'), 
-		      '[\.]*\*', '');
+                      '[\.]*\*', '');
     if (isplot && nargs == 2)
       if (strcmp (typeinfo (fun), "inline function") && 
-	  !isempty (strfind (formula (fun) , "=")))
-	fun = inline (cstrcat (strrep (formula (fun), "=", "- ("), ")"));
+          !isempty (strfind (formula (fun) , "=")))
+        fun = inline (cstrcat (strrep (formula (fun), "=", "- ("), ")"));
       else
-	fstr = cstrcat (fstr, " = 0");
+        fstr = cstrcat (fstr, " = 0");
       endif
 
       Z = feval (fun, X, Y);
 
       ## Matlab returns line objects for this case and so can't call 
       ## contour directly as it returns patch objects to allow colormaps
       ## to work with contours. Therefore recreate the lines from the
       ## output for contourc, and store in cell arrays.
       [c, lev] = contourc (X, Y, Z, [0, 0]);
 
       i1 = 1;
       XX = {};
       YY = {};
       while (i1 < length (c))
-	clev = c(1,i1);
-	clen = c(2,i1);
-	XX = [XX, {c(1, i1+1:i1+clen)}];
-	YY = [YY, {c(2, i1+1:i1+clen)}];
-	i1 += clen+1;
+        clev = c(1,i1);
+        clen = c(2,i1);
+        XX = [XX, {c(1, i1+1:i1+clen)}];
+        YY = [YY, {c(2, i1+1:i1+clen)}];
+        i1 += clen+1;
       endwhile
     else  
       if (ispolar)
-	Z = feval (fun, X);
+        Z = feval (fun, X);
       elseif (isplot)
-	Z = real (feval (fun, X));
+        Z = real (feval (fun, X));
 
-	## Eliminate the singularities. This seems to be what matlab
-	## does, but can't be sure.
-	XX = sort (Z (isfinite (Z)));
-	if (length (X) > 4)
-	  d = XX(fix (7 * length (XX) / 8)) - XX(fix (length (XX) / 8));
-	  yrange = [max(XX(1) - d/8, XX(fix (length (XX) / 8)) - d), ...
-		    min(XX(end) + d/8, XX(fix (7 * length (XX) / 8)) + d)];
-	else
-	  yrange = [XX(1), XX(end)];
+        ## Eliminate the singularities. This seems to be what matlab
+        ## does, but can't be sure.
+        XX = sort (Z (isfinite (Z)));
+        if (length (X) > 4)
+          d = XX(fix (7 * length (XX) / 8)) - XX(fix (length (XX) / 8));
+          yrange = [max(XX(1) - d/8, XX(fix (length (XX) / 8)) - d), ...
+                    min(XX(end) + d/8, XX(fix (7 * length (XX) / 8)) + d)];
+        else
+          yrange = [XX(1), XX(end)];
         endif
 
-	idx = 2 : length(Z);
-	idx = find (((Z(idx) > yrange(2) / 2) & (Z(idx-1) < yrange(1) / 2)) |
-		 ((Z(idx) < yrange(1) / 2) & (Z(idx-1) > yrange (2) / 2)));
-	if (any(idx))
-	  Z(idx) = NaN; 
-	endif
+        idx = 2 : length(Z);
+        idx = find (((Z(idx) > yrange(2) / 2) & (Z(idx-1) < yrange(1) / 2)) |
+                 ((Z(idx) < yrange(1) / 2) & (Z(idx-1) > yrange (2) / 2)));
+        if (any(idx))
+          Z(idx) = NaN; 
+        endif
       else
-	Z = feval (fun, X, Y);
+        Z = feval (fun, X, Y);
 
-	## Eliminate the singularities
-	Z = __eliminate_sing__ (Z);
+        ## Eliminate the singularities
+        Z = __eliminate_sing__ (Z);
       endif
     endif
   endif
 
   oldax = gca (); 
   unwind_protect
     axes (ax);
     if (iscontour)
       [clev, h] = feval (pfunc, X, Y, Z);
     elseif (isplot && nargs == 2)
       h = [];
       hold_state = get (ax, "nextplot");
       for i = 1 : length (XX)
-	h = [h; plot(XX{i}, YY{i})];
-	if (i == 1)
-	  set (ax, "nextplot", "add")
-	endif
+        h = [h; plot(XX{i}, YY{i})];
+        if (i == 1)
+          set (ax, "nextplot", "add")
+        endif
       endfor
       set (ax, "nextplot", hold_state)
     elseif (ispolar || isplot)
       h = feval (pfunc, X, Z);
       if (isplot && !parametric)
-	axis ([X(1), X(end), yrange]);
+        axis ([X(1), X(end), yrange]);
       endif
     else
       h = feval (pfunc, X, Y, Z);
     endif
     xlabel (xarg);
     ylabel (yarg);
     title (fstr);
   unwind_protect_cleanup
diff --git a/scripts/plot/private/__patch__.m b/scripts/plot/private/__patch__.m
--- a/scripts/plot/private/__patch__.m
+++ b/scripts/plot/private/__patch__.m
@@ -34,104 +34,104 @@ function [h, failed] = __patch__ (p, var
   if (isstruct (varargin{1}))
     if (isfield (varargin{1}, "vertices") && isfield (varargin{1}, "faces"))
       args{1} = "faces";
       args{2} = getfield(varargin{1}, "faces");
       args{3} = "vertices";
       args{4} = getfield(varargin{1}, "vertices");
       args{5} = "facevertexcdata";
       if (isfield (varargin{1}, "facevertexcdata"))
-	args{6} = getfield(varargin{1}, "facevertexcdata");
+        args{6} = getfield(varargin{1}, "facevertexcdata");
       else
-	args{6} = [];
+        args{6} = [];
       endif
       args = [args; varargin(2:end)];
       args = setdata (args);
     else
       failed = true;
     endif
   elseif (isnumeric (varargin{1}))
     if (nargin < 3 || ! isnumeric (varargin{2}))
       failed = true;
     else
       x = varargin{1};
       y = varargin{2};
       iarg = 3;
 
       if (nargin > 3 && ndims (varargin{3}) == 2 && ndims (x) == 2
-	  && size_equal(x, varargin{3}) && !ischar(varargin{3}))
-	z = varargin{3};
-	iarg++;
+          && size_equal(x, varargin{3}) && !ischar(varargin{3}))
+        z = varargin{3};
+        iarg++;
       else
-	z = [];
+        z = [];
       endif
 
       if (isvector (x))
-	x = x(:);
-	y = y(:);
-	z = z(:);
+        x = x(:);
+        y = y(:);
+        z = z(:);
       endif
       args{1} = "xdata";
       args{2} = x;
       args{3} = "ydata";
       args{4} = y;
       args{5} = "zdata";
       args{6} = z;
 
       if (isnumeric (varargin{iarg}))
-	c = varargin{iarg};
-	iarg++;
+        c = varargin{iarg};
+        iarg++;
 
-	if (ndims (c) == 3 && size (c, 2) == 1)
-	  c = permute (c, [1, 3, 2]);
-	endif
+        if (ndims (c) == 3 && size (c, 2) == 1)
+          c = permute (c, [1, 3, 2]);
+        endif
 
-	if (isvector (c) && numel (c) == columns (x))
-	  if (isnan (c))
-	    args{7} = "facecolor";
-	    args{8} = [1, 1, 1];
-	    args{9} = "cdata";
-	    args{10} = c;
-	  elseif (isnumeric (c))
-	    args{7} = "facecolor";
-	    args{8} = "flat";
-	    args{9} = "cdata";
-	    args{10} = c;
-	  else
-	    error ("patch: color value not valid");
-	  endif
-	elseif (size (c, ndims (c)) == 3)
-	  args{7} = "facecolor";
-	  args{8} = "flat";
-	  args{9} = "cdata";
-	  args{10} = c;
-	else
-	  ## Color Vectors
-	  if (rows (c) != rows (x) || rows (c) != length (y))
-	    error ("patch: size of x, y, and c must be equal")
-	  else
-	    args{7} = "facecolor";
-	    args{8} = "interp";
-	    args{9} = "cdata";
-	    args{10} = [];
-	  endif
-	endif
+        if (isvector (c) && numel (c) == columns (x))
+          if (isnan (c))
+            args{7} = "facecolor";
+            args{8} = [1, 1, 1];
+            args{9} = "cdata";
+            args{10} = c;
+          elseif (isnumeric (c))
+            args{7} = "facecolor";
+            args{8} = "flat";
+            args{9} = "cdata";
+            args{10} = c;
+          else
+            error ("patch: color value not valid");
+          endif
+        elseif (size (c, ndims (c)) == 3)
+          args{7} = "facecolor";
+          args{8} = "flat";
+          args{9} = "cdata";
+          args{10} = c;
+        else
+          ## Color Vectors
+          if (rows (c) != rows (x) || rows (c) != length (y))
+            error ("patch: size of x, y, and c must be equal")
+          else
+            args{7} = "facecolor";
+            args{8} = "interp";
+            args{9} = "cdata";
+            args{10} = [];
+          endif
+        endif
       elseif (ischar (varargin{iarg}) && rem (nargin - iarg, 2) != 0)
-	## Assume that any additional argument over an even number is
-	## color string.
-	args{7} = "facecolor";
-	args{8} =  tolower (varargin{iarg});
-	args{9} = "cdata";
-	args{10} = [];
-	iarg++;
+        ## Assume that any additional argument over an even number is
+        ## color string.
+        args{7} = "facecolor";
+        args{8} =  tolower (varargin{iarg});
+        args{9} = "cdata";
+        args{10} = [];
+        iarg++;
       else
-	args{7} = "facecolor";
-	args{8} = [0, 1, 0];
-	args{9} = "cdata";
-	args{10} = [];
+        args{7} = "facecolor";
+        args{8} = [0, 1, 0];
+        args{9} = "cdata";
+        args{10} = [];
       endif
 
       args = [args, varargin(iarg:end)];
       args = setvertexdata (args);
     endif
   else
     args = varargin;
     if (any(cellfun (@(x) strcmpi(x,"faces") || strcmpi(x, "vertices"), args)))
@@ -197,37 +197,37 @@ function args = setdata (args)
 
   nr = size (faces, 2);
   nc = size (faces, 1);
   idx = faces .';
   t1 = isnan (idx);
   if (any (t1(:)))
     t2 = find (t1 != t1([2:end,end],:));
     idx (t1) = idx (t2 (cell2mat (cellfun (@(x) x(1)*ones(1,x(2)),
-		mat2cell ([1 : nc; sum(t1)], 2, ones(1,nc)), 
-					   "UniformOutput", false))));
+                mat2cell ([1 : nc; sum(t1)], 2, ones(1,nc)), 
+                                           "UniformOutput", false))));
   endif
   x = reshape (vert(:,1)(idx), size (idx));
   y = reshape (vert(:,2)(idx), size (idx));
   if (size(vert,2) > 2)
     z = reshape (vert(:,3)(idx), size (idx));
   else
     z = [];
   endif
 
   if (ischar (fc) && (strcmpi (fc, "flat") || strcmpi (fc, "interp")))
     if (size(fvc, 1) == nc || size (fvc, 1) == 1)
       c = reshape (fvc, [1, size(fvc)]);
     else
       if (size(fvc, 2) == 3)
-	c = cat(3, reshape (fvc(idx, 1), size(idx)),
-		reshape (fvc(idx, 2), size(idx)),
-		reshape (fvc(idx, 3), size(idx)));
+        c = cat(3, reshape (fvc(idx, 1), size(idx)),
+                reshape (fvc(idx, 2), size(idx)),
+                reshape (fvc(idx, 3), size(idx)));
       else
-	c = reshape (fvc(idx), size(idx));
+        c = reshape (fvc(idx), size(idx));
       endif
     endif
   else
     c = [];
   endif
   args = {"xdata", x, "ydata", y, "zdata", z, "cdata", c, args{:}};
 endfunction
 
diff --git a/scripts/plot/private/__plt__.m b/scripts/plot/private/__plt__.m
--- a/scripts/plot/private/__plt__.m
+++ b/scripts/plot/private/__plt__.m
@@ -39,76 +39,76 @@ function retval = __plt__ (caller, h, va
 
     ## Gather arguments, decode format, gather plot strings, and plot lines.
 
     retval = [];
 
     while (nargs > 0 || x_set)
 
       if (nargs == 0)
-	## Force the last plot when input variables run out.
-	next_cell = {};
-	next_arg = {""};
+        ## Force the last plot when input variables run out.
+        next_cell = {};
+        next_arg = {""};
       else
-	next_cell = varargin(k);
-	next_arg = varargin{k++};
+        next_cell = varargin(k);
+        next_arg = varargin{k++};
       endif
 
       nargs--;
 
       if (ischar (next_arg) || iscellstr (next_arg))
-	if (x_set)
-	  [options, valid] = __pltopt__ (caller, next_arg, false);
-	  if (! valid)
-	    if (nargs == 0)
-	      error ("%s: properties must appear followed by a value", caller);
-	    endif
-	    properties = [properties, [next_cell, varargin(k++)]];
-	    nargs--;
-	    continue;
-	  else
-	    while (nargs > 0 && ischar (varargin{k}))
-	      if (nargs < 2)
-		error ("%s: properties must appear followed by a value",
-		       caller);
-	      endif
-	      properties = [properties, varargin(k:k+1)];
-	      k += 2;
-	      nargs -= 2;
-	    endwhile
-	  endif
-	  if (y_set)
-	    tmp = __plt2__ (h, x, y, options, properties);
-	    properties = {};
-	    retval = [retval; tmp];
-	  else
-	    tmp = __plt1__ (h, x, options, properties);
-	    properties = {};
-	    retval = [retval; tmp];
-	  endif
-	  x_set = false;
-	  y_set = false;
-	else
-	  error ("plot: no data to plot");
-	endif
+        if (x_set)
+          [options, valid] = __pltopt__ (caller, next_arg, false);
+          if (! valid)
+            if (nargs == 0)
+              error ("%s: properties must appear followed by a value", caller);
+            endif
+            properties = [properties, [next_cell, varargin(k++)]];
+            nargs--;
+            continue;
+          else
+            while (nargs > 0 && ischar (varargin{k}))
+              if (nargs < 2)
+                error ("%s: properties must appear followed by a value",
+                       caller);
+              endif
+              properties = [properties, varargin(k:k+1)];
+              k += 2;
+              nargs -= 2;
+            endwhile
+          endif
+          if (y_set)
+            tmp = __plt2__ (h, x, y, options, properties);
+            properties = {};
+            retval = [retval; tmp];
+          else
+            tmp = __plt1__ (h, x, options, properties);
+            properties = {};
+            retval = [retval; tmp];
+          endif
+          x_set = false;
+          y_set = false;
+        else
+          error ("plot: no data to plot");
+        endif
       elseif (x_set)
-	if (y_set)
-	  options = __pltopt__ (caller, {""});
-	  tmp = __plt2__ (h, x, y, options, properties);
-	  retval = [retval; tmp];
-	  x = next_arg;
-	  y_set = false;
-	  properties = {};
-	else
-	  y = next_arg;
-	  y_set = true;
-	endif
+        if (y_set)
+          options = __pltopt__ (caller, {""});
+          tmp = __plt2__ (h, x, y, options, properties);
+          retval = [retval; tmp];
+          x = next_arg;
+          y_set = false;
+          properties = {};
+        else
+          y = next_arg;
+          y_set = true;
+        endif
       else
-	x = next_arg;
-	x_set = true;
+        x = next_arg;
+        x_set = true;
       endif
 
     endwhile
 
   else
     msg = sprintf ("%s (y)\n", caller);
     msg = sprintf ("%s       %s (x, y, ...)\n", msg, caller);
     msg = sprintf ("%s       %s (x, y, fmt, ...)", msg, caller);
@@ -233,37 +233,37 @@ function retval = __plt2mm__ (h, x, y, o
 
   [x_nr, x_nc] = size (x);
   [y_nr, y_nc] = size (y);
 
   k = 1;
   if (x_nr == y_nr && x_nc == y_nc)
     if (x_nc > 0)
       if (numel (options) == 1)
-	options = repmat (options(:), x_nc, 1);
+        options = repmat (options(:), x_nc, 1);
       endif
       retval = zeros (x_nc, 1);
       for i = 1:x_nc
-	tkey = options(i).key;
-	if (! isempty (tkey))
-	  set (h, "key", "on");
-	endif
+        tkey = options(i).key;
+        if (! isempty (tkey))
+          set (h, "key", "on");
+        endif
         linestyle = options(i).linestyle;
         marker = options(i).marker;
-	if (isempty (marker) && isempty (linestyle))
-	   [linestyle, marker] = __next_line_style__ ();
-	endif
-	color = options(i).color;
-	if (isempty (color))
-	  color = __next_line_color__ ();
-	endif
+        if (isempty (marker) && isempty (linestyle))
+           [linestyle, marker] = __next_line_style__ ();
+        endif
+        color = options(i).color;
+        if (isempty (color))
+          color = __next_line_color__ ();
+        endif
 
-	retval(i) = line (x(:,i), y(:,i), "keylabel", tkey, "color", color,
-			  "linestyle", linestyle,
-			  "marker", marker, properties{:});
+        retval(i) = line (x(:,i), y(:,i), "keylabel", tkey, "color", color,
+                          "linestyle", linestyle,
+                          "marker", marker, properties{:});
       endfor
     else
       error ("__plt2mm__: arguments must be a matrices");
     endif
   else
     error ("__plt2mm__: matrix dimensions must match");
   endif
 
@@ -307,31 +307,31 @@ function retval = __plt2mv__ (h, x, y, o
   if (x_nc > 0)
     if (numel (options) == 1)
       options = repmat (options(:), x_nc, 1);
     endif
     retval = zeros (x_nc, 1);
     for i = 1:x_nc
       tkey = options(i).key;
       if (! isempty (tkey))
-	set (h, "key", "on");
+        set (h, "key", "on");
       endif
       linestyle = options(i).linestyle;
       marker = options(i).marker;
       if (isempty (marker) && isempty (linestyle))
-	[linestyle, marker] = __next_line_style__ ();
+        [linestyle, marker] = __next_line_style__ ();
       endif
       color = options(i).color;
       if (isempty (color))
-	color = __next_line_color__ ();
+        color = __next_line_color__ ();
       endif
 
       retval(i) = line (x(:,i), y, "keylabel", tkey, "color", color,
-			"linestyle", linestyle,
-			"marker", marker, properties{:});
+                        "linestyle", linestyle,
+                        "marker", marker, properties{:});
     endfor
   else
     error ("__plt2mv__: arguments must be a matrices");
   endif
 
 endfunction
 
 function retval = __plt2ss__ (h, x, y, options, properties)
@@ -366,18 +366,18 @@ function retval = __plt2ss__ (h, x, y, o
       [linestyle, marker] = __next_line_style__ ();
     endif
     color = options.color;
     if (isempty (color))
       color = __next_line_color__ ();
     endif
 
     retval = line (x, y, "keylabel", key, "color", color,
-		   "linestyle", linestyle,
-		   "marker", marker, properties{:});
+                   "linestyle", linestyle,
+                   "marker", marker, properties{:});
   else
     error ("__plt2ss__: arguments must be scalars");
   endif
 
 endfunction
 
 function retval = __plt2sv__ (h, x, y, options, properties)
 
@@ -397,31 +397,31 @@ function retval = __plt2sv__ (h, x, y, o
     len = numel (y);
     if (numel (options) == 1)
       options = repmat (options(:), len, 1);
     endif
     retval = zeros (len, 1);
     for i = 1:len
       tkey = options(i).key;
       if (! isempty (tkey))
-	set (h, "key", "on");
+        set (h, "key", "on");
       endif
       linestyle = options(i).linestyle;
       marker = options(i).marker;
       if (isempty (marker) && isempty (linestyle))
         [linestyle, marker] = __next_line_style__ ();
       endif
       color = options(i).color;
       if (isempty (color))
-	color = __next_line_color__ ();
+        color = __next_line_color__ ();
       endif
 
       retval(i) = line (x, y(i), "keylabel", tkey, "color", color,
-			"linestyle", linestyle,
-			"marker", marker, properties{:});
+                        "linestyle", linestyle,
+                        "marker", marker, properties{:});
     endfor
   else
     error ("__plt2sv__: first arg must be scalar, second arg must be vector");
   endif
 
 endfunction
 
 function retval = __plt2vm__ (h, x, y, options, properties)
@@ -462,31 +462,31 @@ function retval = __plt2vm__ (h, x, y, o
   if (y_nc > 0)
     if (numel (options) == 1)
       options = repmat (options(:), y_nc, 1);
     endif
     retval = zeros (y_nc, 1);
     for i = 1:y_nc
       tkey = options(i).key;
       if (! isempty (tkey))
-	set (h, "key", "on");
+        set (h, "key", "on");
       endif
       linestyle = options(i).linestyle;
       marker = options(i).marker;
       if (isempty (marker) && isempty (linestyle))
         [linestyle, marker] = __next_line_style__ ();
       endif
       color = options(i).color;
       if (isempty (color))
-	color = __next_line_color__ ();
+        color = __next_line_color__ ();
       endif
 
       retval(i) = line (x, y(:,i), "keylabel", tkey, "color", color,
-			"linestyle", linestyle,
-			"marker", marker, properties{:});
+                        "linestyle", linestyle,
+                        "marker", marker, properties{:});
     endfor
   else
     error ("__plt2vm__: arguments must be a matrices");
   endif
 
 endfunction
 
 function retval = __plt2vs__ (h, x, y, options, properties)
@@ -507,31 +507,31 @@ function retval = __plt2vs__ (h, x, y, o
     len = numel (x);
     if (numel (options) == 1)
       options = repmat (options(:), len, 1);
     endif
     retval = zeros (len, 1);
     for i = 1:len
       tkey = options(i).key;
       if (! isempty (tkey))
-	set (h, "key", "on");
+        set (h, "key", "on");
       endif
       linestyle = options(i).linestyle;
       marker = options(i).marker;
       if (isempty (marker) && isempty (linestyle))
         [linestyle, marker] = __next_line_style__ ();
       endif
       color = options(i).color;
       if (isempty (color))
-	color = __next_line_color__ ();
+        color = __next_line_color__ ();
       endif
 
       retval(i) = line (x(i), y, "keylabel", tkey, "color", color,
-			"linestyle", linestyle,
-			"marker", marker, properties{:});
+                        "linestyle", linestyle,
+                        "marker", marker, properties{:});
     endfor
   else
     error ("__plt2vs__: first arg must be vector, second arg must be scalar");
   endif
 
 endfunction
 
 function retval = __plt2vv__ (h, x, y, options, properties)
@@ -580,15 +580,15 @@ function retval = __plt2vv__ (h, x, y, o
       [linestyle, marker] = __next_line_style__ ();
     endif
     color = options.color;
     if (isempty (color))
       color = __next_line_color__ ();
     endif
 
     retval = line (x, y, "keylabel", key, "color", color,
-	      "linestyle", linestyle,
-	      "marker", marker, properties{:});
+              "linestyle", linestyle,
+              "marker", marker, properties{:});
   else
     error ("__plt2vv__: vector lengths must match");
   endif
 
 endfunction
diff --git a/scripts/plot/private/__pltopt__.m b/scripts/plot/private/__pltopt__.m
--- a/scripts/plot/private/__pltopt__.m
+++ b/scripts/plot/private/__pltopt__.m
@@ -107,17 +107,17 @@ function [options, valid] = __pltopt__ (
       error ("__pltopt__: expecting argument to be character string or cell array of character strings");
     endif
     if (ischar (opt))
       opt = cellstr (opt);
     endif
     for i = nel:-1:1
       [options(i), valid] = __pltopt1__ (caller, opt{i}, err_on_invalid);
       if (! err_on_invalid && ! valid)
-	return;
+        return;
       endif
     endfor
   else
     print_usage ();
   endif
 
 endfunction
 
@@ -147,87 +147,87 @@ function [options, valid] = __pltopt1__ 
 
   ## If called by __errplot__, extract the linestyle before proceeding.
   if (strcmp (caller,"__errplot__"))
     if (strncmp (opt, "#~>", 3))
       n = 3;
     elseif (strncmp (opt, "#~", 2) || strncmp (opt, "~>", 2))
       n = 2;
     elseif (strncmp (opt, "~", 1) || strncmp (opt, ">", 1) 
-	    || strncmp (opt, "#", 1))
+            || strncmp (opt, "#", 1))
       n = 1;
     endif
     options.linestyle = opt(1:n);
     opt(1:n) = [];
     have_linestyle = true;
   endif
 
   while (! isempty (opt))
     if (strncmp (opt, "--", 2) || strncmp (opt, "-.", 2))
       options.linestyle = opt(1:2);
       have_linestyle = true;
       n = 2;
     else
       topt = opt(1);
       n = 1;
       if (topt == "-" || topt == ":")
-	have_linestyle = true;
-	options.linestyle = topt;
+        have_linestyle = true;
+        options.linestyle = topt;
       elseif (topt == "+" || topt == "o" || topt == "*"
-	      || topt == "." || topt == "x" || topt == "s"
-	      || topt == "d" || topt == "^" || topt == "v"
-	      || topt == ">" || topt == "<" || topt == "p"
-	      || topt == "h" || topt == "@")
-	have_marker = true;
+              || topt == "." || topt == "x" || topt == "s"
+              || topt == "d" || topt == "^" || topt == "v"
+              || topt == ">" || topt == "<" || topt == "p"
+              || topt == "h" || topt == "@")
+        have_marker = true;
         ## Backward compatibility.  Leave undocumented.
-	if (topt == "@")
-	  topt = "+";
-	endif
-	options.marker = topt;
+        if (topt == "@")
+          topt = "+";
+        endif
+        options.marker = topt;
 ### Numeric color specs for backward compatibility.  Leave undocumented.
       elseif (topt == "k" || topt == "0")
-	options.color = [0, 0, 0];
+        options.color = [0, 0, 0];
       elseif (topt == "r" || topt == "1")
-	options.color = [1, 0, 0];
+        options.color = [1, 0, 0];
       elseif (topt == "g" || topt == "2")
-	options.color = [0, 1, 0];
+        options.color = [0, 1, 0];
       elseif (topt == "b" || topt == "3")
-	options.color = [0, 0, 1];
+        options.color = [0, 0, 1];
       elseif (topt == "y")
-	options.color = [1, 1, 0];
+        options.color = [1, 1, 0];
       elseif (topt == "m" || topt == "4")
-	options.color = [1, 0, 1];
+        options.color = [1, 0, 1];
       elseif (topt == "c" || topt == "5")
-	options.color = [0, 1, 1];
+        options.color = [0, 1, 1];
       elseif (topt == "w" || topt == "6")
-	options.color = [1, 1, 1];
+        options.color = [1, 1, 1];
       elseif (isspace (topt))
-	## Do nothing.
+        ## Do nothing.
       elseif (topt == ";")
-	t = index (opt(2:end), ";");
-	if (t)
-	  options.key = undo_string_escapes (opt(2:t));
-	  n = t+1;
-	else
-	  if (err_on_invalid)
+        t = index (opt(2:end), ";");
+        if (t)
+          options.key = undo_string_escapes (opt(2:t));
+          n = t+1;
+        else
+          if (err_on_invalid)
             error ("%s: unfinished key label", caller);
-	  else
-	    valid = false;
-	    options = __default_plot_options__ ();
-	    return;
-	  endif
+          else
+            valid = false;
+            options = __default_plot_options__ ();
+            return;
+          endif
         endif
       else
-	if (err_on_invalid)
-	  error ("%s: unrecognized format character: `%s'", caller, topt);
-	else
-	  valid = false;
-	  options = __default_plot_options__ ();
-	  return;
-	endif
+        if (err_on_invalid)
+          error ("%s: unrecognized format character: `%s'", caller, topt);
+        else
+          valid = false;
+          options = __default_plot_options__ ();
+          return;
+        endif
       endif
     endif
     opt(1:n) = [];
   endwhile
 
   if (! have_linestyle && have_marker)
     options.linestyle = "none";
   endif
diff --git a/scripts/plot/private/__quiver__.m b/scripts/plot/private/__quiver__.m
--- a/scripts/plot/private/__quiver__.m
+++ b/scripts/plot/private/__quiver__.m
@@ -43,61 +43,61 @@ function hg = __quiver__ (varargin)
     v = varargin{ioff++};
     if (is3d)
       w = varargin{ioff++}
       [x, y, z] = meshgrid (1:size(u,2), 1:size(u,1), 1:max(size(w)));
     else
       [x, y] = meshgrid (1:size(u,2), 1:size(u,1));
     endif
     if (nargin >= ioff && isnumeric (varargin{ioff})
-	&& isscalar (varargin{ioff}))
+        && isscalar (varargin{ioff}))
       autoscale = varargin{ioff++};
     endif
   else
     x = varargin{ioff++};
     y = varargin{ioff++};
     if (is3d)
       z = varargin{ioff++};
     endif
     u = varargin{ioff++};
     v = varargin{ioff++}; 
     if (is3d)
       w = varargin{ioff++};
       if (isvector (x) && isvector (y) && isvector (z)
-	  && (! isvector (u) || ! isvector (v) || ! isvector(w)))
-	[x, y, z] = meshgrid (x, y, z);
+          && (! isvector (u) || ! isvector (v) || ! isvector(w)))
+        [x, y, z] = meshgrid (x, y, z);
       endif
     else
       if (isvector (x) && isvector (y) && (! isvector (u) || ! isvector (v)))
-	[x, y] = meshgrid (x, y);
+        [x, y] = meshgrid (x, y);
       endif
     endif
     if (nargin >= ioff && isnumeric (varargin{ioff})
-	&& isscalar (varargin{ioff}))
+        && isscalar (varargin{ioff}))
       autoscale = varargin{ioff++};
     endif
   endif
 
   have_filled = false;
   have_line_spec = false;
   args = {};
   while (ioff <= nargin)
     arg = varargin{ioff++};
     if (ischar (arg) && strncmpi (arg, "filled", 6))
       have_filled = true;
     elseif ((ischar (arg) || iscell (arg))
-	    && ! have_line_spec)
+            && ! have_line_spec)
       [linespec, valid] = __pltopt__ ("quiver", arg, false);
       if (valid)
-	have_line_spec = true;
-	if (strncmp (linespec.linestyle, "none", 4))
-	  linespec.linestyle = "-";
-	endif
+        have_line_spec = true;
+        if (strncmp (linespec.linestyle, "none", 4))
+          linespec.linestyle = "-";
+        endif
       else
-	args {end + 1} = arg;
+        args {end + 1} = arg;
         if (ioff <= nargin)
           args {end + 1} = varargin{ioff++};
         endif
       endif
     else
       args {end + 1} = arg;
       if (ioff <= nargin)
         args {end + 1} = varargin{ioff++};
@@ -117,36 +117,36 @@ function hg = __quiver__ (varargin)
       len = max (sqrt (u(:).^2 + dy(:).^2));
       dz = 0;
     endif
     if (len > 0)
       s = 2 * autoscale / sqrt (2) * sqrt (dx.^2 + dy.^2 + dz.^2) / len; 
       uu = s * u;
       vv = s * v;
       if (is3d)
-	ww = s*w;
+        ww = s*w;
       endif
     endif
   else
     uu = u;
     vv = v;
     if (is3d)
       ww = w;
     endif
   endif
 
   hstate = get (h, "nextplot");
   unwind_protect
     hg = hggroup ();
     if (is3d)
       args = __add_datasource__ ("quiver3", hg, 
-				 {"x", "y", "z", "u", "v", "w"}, args{:});
+                                 {"x", "y", "z", "u", "v", "w"}, args{:});
     else
       args = __add_datasource__ ("quiver", hg, 
-				 {"x", "y", "z", "u", "v", "w"}, args{:});
+                                 {"x", "y", "z", "u", "v", "w"}, args{:});
     endif
     hold on;
 
     addproperty ("xdata", hg, "data", x);
     addproperty ("ydata", hg, "data", y);
 
     addproperty ("udata", hg, "data", u);
     addproperty ("vdata", hg, "data", v);
@@ -171,105 +171,105 @@ function hg = __quiver__ (varargin)
     yend = y + vv(:);
     if (is3d)
       z = z(:);
       zend = z + ww(:);
     endif
 
     if (have_line_spec)
       if (is3d)
-	h1 = plot3 ([x.'; xend.'; NaN(1, length (x))](:),
-		    [y.'; yend.'; NaN(1, length (y))](:),
-		    [z.'; zend.'; NaN(1, length (z))](:),
-		    "linestyle", linespec.linestyle, 
-		    "color", linespec.color, "parent", hg);
+        h1 = plot3 ([x.'; xend.'; NaN(1, length (x))](:),
+                    [y.'; yend.'; NaN(1, length (y))](:),
+                    [z.'; zend.'; NaN(1, length (z))](:),
+                    "linestyle", linespec.linestyle, 
+                    "color", linespec.color, "parent", hg);
       else
-	h1 = plot ([x.'; xend.'; NaN(1, length (x))](:),
-		   [y.'; yend.'; NaN(1, length (y))](:),
-		   "linestyle", linespec.linestyle, 
-		    "color", linespec.color, "parent", hg);
+        h1 = plot ([x.'; xend.'; NaN(1, length (x))](:),
+                   [y.'; yend.'; NaN(1, length (y))](:),
+                   "linestyle", linespec.linestyle, 
+                    "color", linespec.color, "parent", hg);
       endif
     else
       if (is3d)
-	h1 = plot3 ([x.'; xend.'; NaN(1, length (x))](:),
-		    [y.'; yend.'; NaN(1, length (y))](:),
-		    [z.'; zend.'; NaN(1, length (z))](:),
-		    "parent", hg);
+        h1 = plot3 ([x.'; xend.'; NaN(1, length (x))](:),
+                    [y.'; yend.'; NaN(1, length (y))](:),
+                    [z.'; zend.'; NaN(1, length (z))](:),
+                    "parent", hg);
       else
-	h1 = plot ([x.'; xend.'; NaN(1, length (x))](:),
-		   [y.'; yend.'; NaN(1, length (y))](:),
-		   "parent", hg);
+        h1 = plot ([x.'; xend.'; NaN(1, length (x))](:),
+                   [y.'; yend.'; NaN(1, length (y))](:),
+                   "parent", hg);
       endif
     endif
 
     xtmp = x + uu(:) .* (1 - arrowsize);
     ytmp = y + vv(:) .* (1 - arrowsize);
     xarrw1 = xtmp + (y - yend) * arrowsize / 3;
     xarrw2 = xtmp - (y - yend) * arrowsize / 3;
     yarrw1 = ytmp - (x - xend) * arrowsize / 3;
     yarrw2 = ytmp + (x - xend) * arrowsize / 3;
     if (is3d)
       zarrw1 = zarrw2 = zend - ww(:) * arrowsize;
     endif
 
     if (have_line_spec)
       if (isfield (linespec, "marker") && 
-	! strncmp (linespec.marker, "none", 4))
-	if (is3d)
-	  h2 = plot3 ([xarrw1.'; xend.'; xarrw2.'; NaN(1, length (x))](:),
-		      [yarrw1.'; yend.'; yarrw2.'; NaN(1, length (y))](:),
-		      [zarrw1.'; zend.'; zarrw2.'; NaN(1, length (z))](:),
-		      "linestyle", "none", "parent", hg);
-	else
-	  h2 = plot ([xarrw1.'; xend.'; xarrw2.'; NaN(1, length (x))](:),
-		     [yarrw1.'; yend.'; yarrw2.'; NaN(1, length (y))](:),
-		     "linestyle", "none", "parent", hg);
-	endif
+        ! strncmp (linespec.marker, "none", 4))
+        if (is3d)
+          h2 = plot3 ([xarrw1.'; xend.'; xarrw2.'; NaN(1, length (x))](:),
+                      [yarrw1.'; yend.'; yarrw2.'; NaN(1, length (y))](:),
+                      [zarrw1.'; zend.'; zarrw2.'; NaN(1, length (z))](:),
+                      "linestyle", "none", "parent", hg);
+        else
+          h2 = plot ([xarrw1.'; xend.'; xarrw2.'; NaN(1, length (x))](:),
+                     [yarrw1.'; yend.'; yarrw2.'; NaN(1, length (y))](:),
+                     "linestyle", "none", "parent", hg);
+        endif
       else
-	if (is3d)
-	  h2 = plot3 ([xarrw1.'; xend.'; xarrw2.'; NaN(1, length (x))](:),
-		      [yarrw1.'; yend.'; yarrw2.'; NaN(1, length (y))](:),
-		      [zarrw1.'; zend.'; zarrw2.'; NaN(1, length (z))](:),
-		      "linestyle", linespec.linestyle,
-		      "color", linespec.color, "parent", hg);
-	else
-	  h2 = plot ([xarrw1.'; xend.'; xarrw2.'; NaN(1, length (x))](:),
-		     [yarrw1.'; yend.'; yarrw2.'; NaN(1, length (y))](:),
-		     "linestyle", linespec.linestyle,
-		      "color", linespec.color, "parent", hg);
-	endif
+        if (is3d)
+          h2 = plot3 ([xarrw1.'; xend.'; xarrw2.'; NaN(1, length (x))](:),
+                      [yarrw1.'; yend.'; yarrw2.'; NaN(1, length (y))](:),
+                      [zarrw1.'; zend.'; zarrw2.'; NaN(1, length (z))](:),
+                      "linestyle", linespec.linestyle,
+                      "color", linespec.color, "parent", hg);
+        else
+          h2 = plot ([xarrw1.'; xend.'; xarrw2.'; NaN(1, length (x))](:),
+                     [yarrw1.'; yend.'; yarrw2.'; NaN(1, length (y))](:),
+                     "linestyle", linespec.linestyle,
+                      "color", linespec.color, "parent", hg);
+        endif
       endif
     elseif (is3d)
       h2 = plot3 ([xarrw1.'; xend.'; xarrw2.'; NaN(1, length (x))](:),
-		  [yarrw1.'; yend.'; yarrw2.'; NaN(1, length (y))](:),
-		  [zarrw1.'; zend.'; zarrw2.'; NaN(1, length (z))](:),
-		  "parent", hg);
+                  [yarrw1.'; yend.'; yarrw2.'; NaN(1, length (y))](:),
+                  [zarrw1.'; zend.'; zarrw2.'; NaN(1, length (z))](:),
+                  "parent", hg);
     else
       h2 = plot ([xarrw1.'; xend.'; xarrw2.'; NaN(1, length (x))](:),
-		 [yarrw1.'; yend.'; yarrw2.'; NaN(1, length (y))](:),
-		 "parent", hg);
+                 [yarrw1.'; yend.'; yarrw2.'; NaN(1, length (y))](:),
+                 "parent", hg);
     endif
 
     if (! have_line_spec
-	|| (isfield (linespec, "marker")
-	    && strncmp (linespec.marker, "none", 4)))
+        || (isfield (linespec, "marker")
+            && strncmp (linespec.marker, "none", 4)))
       if (is3d)
-	h3 = plot3 (x, y, z, "linestyle", "none", "marker", "none", 
-		    "parent", hg);
+        h3 = plot3 (x, y, z, "linestyle", "none", "marker", "none", 
+                    "parent", hg);
       else
-	h3 = plot (x, y, "linestyle", "none", "marker", "none", "parent", hg);
+        h3 = plot (x, y, "linestyle", "none", "marker", "none", "parent", hg);
       endif
     else
       if (is3d)
-	h3 = plot3 (x, y, z, "linestyle", "none", "marker", linespec.marker,
-		    "parent", hg);
+        h3 = plot3 (x, y, z, "linestyle", "none", "marker", linespec.marker,
+                    "parent", hg);
       else
 
-	h3 = plot (x, y, "linestyle", "none", "marker", linespec.marker,
-		   "parent", hg);
+        h3 = plot (x, y, "linestyle", "none", "marker", linespec.marker,
+                   "parent", hg);
       endif
     endif
     if (have_filled)
       ## FIXME gnuplot doesn't respect the markerfacecolor field
       set (h3, "markerfacecolor", get (h1, "color")); 
     endif
 
     ## Set up the hggroup properties and listeners
@@ -289,17 +289,17 @@ function hg = __quiver__ (varargin)
     addproperty ("showarrowhead", hg, "radio", "{on}|off", "on");
     addlistener (hg, "showarrowhead", @update_props);
 
     addproperty ("color", hg, "linecolor", get (h1, "color"));
     addproperty ("linewidth", hg, "linelinewidth", get (h1, "linewidth"));
     addproperty ("linestyle", hg, "linelinestyle", get (h1, "linestyle"));
     addproperty ("marker", hg, "linemarker", get (h3, "marker"));
     addproperty ("markerfacecolor", hg, "linemarkerfacecolor",
-		 get (h3, "markerfacecolor"));
+                 get (h3, "markerfacecolor"));
     addproperty ("markersize", hg, "linemarkersize", get (h3, "markersize"));
 
     addlistener (hg, "color", @update_props);
     addlistener (hg, "linewidth", @update_props); 
     addlistener (hg, "linestyle", @update_props); 
     addlistener (hg, "marker", @update_props); 
     addlistener (hg, "markerfacecolor", @update_props); 
     addlistener (hg, "markersize", @update_props);
@@ -345,17 +345,17 @@ function update_data (h, d)
       len = max (sqrt (u(:).^2 + dy(:).^2));
       dz = 0;
     endif
     if (len > 0)
       s = 2 * s / sqrt (2) * sqrt (dx.^2 + dy.^2 + dz.^2) / len; 
       u = s * u;
       v = s * v;
       if (is3d)
-	w = s*w;
+        w = s*w;
       endif
     endif
   endif
 
   x = x(:);
   y = y(:);
   xend = x + u(:);
   yend = y + v(:);
diff --git a/scripts/plot/private/__scatter__.m b/scripts/plot/private/__scatter__.m
--- a/scripts/plot/private/__scatter__.m
+++ b/scripts/plot/private/__scatter__.m
@@ -60,17 +60,17 @@ function hg = __scatter__ (varargin)
   else
     s = 6;
   endif
 
   if (istart < nargin && firstnonnumeric > istart + 1)
     c = varargin{istart + 1};
     if (isvector (c))
       if (columns (c) != 3)
-	c = c(:);
+        c = c(:);
       endif
     endif
   elseif (firstnonnumeric == istart + 1 && ischar (varargin{istart + 1}))
     c = varargin{istart + 1};
     firstnonnumeric++;
   else
     c = [];
   endif
@@ -82,41 +82,41 @@ function hg = __scatter__ (varargin)
   iarg = firstnonnumeric;
   while (iarg <= nargin)
     arg = varargin{iarg++};
     if (ischar (arg) && strncmpi (arg, "filled", 6))
       filled = true;
     elseif ((ischar (arg) || iscell (arg)) && ! have_marker)
       [linespec, valid] = __pltopt__ (fcn, arg, false);
       if (valid)
-	have_marker = true;
-	marker = linespec.marker;
-	if (strncmp (marker, "none", 4))
-	  marker = "o";
+        have_marker = true;
+        marker = linespec.marker;
+        if (strncmp (marker, "none", 4))
+          marker = "o";
         elseif (isempty (marker))
           [dummy, marker] = __next_line_style__ ();
-	endif
+        endif
       else
-	error ("%s: invalid linespec", fcn);
+        error ("%s: invalid linespec", fcn);
       endif
     else
       newargs{end+1} = arg;
       if (iarg <= nargin)
-	newargs{end+1} = varagin{iarg++};
+        newargs{end+1} = varagin{iarg++};
       endif
     endif
   endwhile
 
   if (isempty (c))
     c = __next_line_color__();
   endif
 
   hg = hggroup ();
   newargs = __add_datasource__ (fcn, hg, {"x", "y", "z", "c", "size"}, 
-			     newargs{:});
+                             newargs{:});
 
   addproperty ("xdata", hg, "data", x);
   addproperty ("ydata", hg, "data", y);
   addproperty ("zdata", hg, "data", z);
   if (ischar (c))
     addproperty ("cdata", hg, "data", __color_str_rgb__ (c));
   else
     addproperty ("cdata", hg, "data", c);
@@ -321,17 +321,17 @@ function update_props (h, d)
   lw = get (h, "linewidth");
   m = get (h, "marker");
   fc = get (h, "markerfacecolor");
   ec = get (h, "markeredgecolor");
   kids = get (h, "children");
 
   for i = 1 : numel (kids)
     set (kids (i), "linewidth", lw, "marker", m, "markerfacecolor", fc, 
-	 "edgecolor", ec)
+         "edgecolor", ec)
   endfor
 endfunction
 
 function update_data (h, d)
   x1 = get (h, "xdata");
   y1 = get (h, "ydata");
   z1 = get (h, "zdata");
   c1 = get (h, "cdata");
@@ -341,31 +341,31 @@ function update_data (h, d)
   size1 = get (h, "sizedata");
   if (numel (size1) == 1)
     size1 = repmat (size1, numel (x1), 1);
   endif
   hlist = get (h, "children");
   if (ischar (c1))
     if (isempty (z1))
       for i = 1 : length (hlist)
-	set (hlist(i), "vertices", [x1(i), y1(i)], "cdata", c1,
-	     "markersize", size1(i));
+        set (hlist(i), "vertices", [x1(i), y1(i)], "cdata", c1,
+             "markersize", size1(i));
       endfor
     else
       for i = 1 : length (hlist)
-	set (hlist(i), "vertices", [x1(i), y1(i), z1(i)], "cdata", c1,
-	     "markersize", size1(i));
+        set (hlist(i), "vertices", [x1(i), y1(i), z1(i)], "cdata", c1,
+             "markersize", size1(i));
       endfor
     endif
   else
     if (isempty (z1))
       for i = 1 : length (hlist)
-	set (hlist(i), "vertices", [x1(i), y1(i)], "cdata", 
-	     reshape(c1(i,:),[1, size(c1)(2:end)]), "markersize", size1(i));
+        set (hlist(i), "vertices", [x1(i), y1(i)], "cdata", 
+             reshape(c1(i,:),[1, size(c1)(2:end)]), "markersize", size1(i));
       endfor
     else
       for i = 1 : length (hlist)
-	set (hlist(i), "vertices", [x1(i), y1(i), z1(i)], "cdata", 
-	     reshape(c1(i,:),[1, size(c1)(2:end)]), "markersize", size1(i));
+        set (hlist(i), "vertices", [x1(i), y1(i), z1(i)], "cdata", 
+             reshape(c1(i,:),[1, size(c1)(2:end)]), "markersize", size1(i));
       endfor
     endif
   endif
 endfunction
diff --git a/scripts/plot/private/__stem__.m b/scripts/plot/private/__stem__.m
--- a/scripts/plot/private/__stem__.m
+++ b/scripts/plot/private/__stem__.m
@@ -42,87 +42,87 @@ function h = __stem__ (have_z, varargin)
     axes (ax);
     hold_state = get (ax, "nextplot");
     newplot ();
     h = [];
 
     nx = rows (x);
     for i = 1: columns (x)
       if (have_z)
-	xt = x(:)';
-	xt = [xt; xt; NaN(1, nx)](:);
-	yt = y(:)';
-	yt = [yt; yt; NaN(1, nx)](:);
-	zt = z(:)';
-	zt = [zeros(1, nx); zt; NaN(1, nx)](:);
+        xt = x(:)';
+        xt = [xt; xt; NaN(1, nx)](:);
+        yt = y(:)';
+        yt = [yt; yt; NaN(1, nx)](:);
+        zt = z(:)';
+        zt = [zeros(1, nx); zt; NaN(1, nx)](:);
       else
-	xt = x(:, i)';
-	xt = [xt; xt; NaN(1, nx)](:);
-	yt = y(:, i)';
-	yt = [zeros(1, nx); yt; NaN(1, nx)](:);
+        xt = x(:, i)';
+        xt = [xt; xt; NaN(1, nx)](:);
+        yt = y(:, i)';
+        yt = [zeros(1, nx); yt; NaN(1, nx)](:);
       endif
 
       hg  = hggroup ();
       h = [h; hg];
       args = __add_datasource__ (caller, hg, {"x", "y", "z"}, varargin{:});
       
       if (i == 1)
-	set (ax, "nextplot", "add");
+        set (ax, "nextplot", "add");
       endif
 
       if (isempty (llc))
-	lc = __next_line_color__ ();
+        lc = __next_line_color__ ();
       else
-	lc = llc;
+        lc = llc;
       endif
 
       if (isempty (mmc))
-	mc = lc;
+        mc = lc;
       else
-	mc = mmc;
+        mc = mmc;
       endif
 
       if (dofill)
-	fc = mc;
+        fc = mc;
       else
-	fc = "none";
+        fc = "none";
       endif
 
       if (have_z)
-	h_stems = plot3 (xt, yt, zt, "color", lc, "linestyle", ls, 
-			 "parent", hg, x, y, z, "color", mc,
-			 "marker",  ms, "linestyle", "none",
-			 "markerfacecolor", fc, "parent", hg);
+        h_stems = plot3 (xt, yt, zt, "color", lc, "linestyle", ls, 
+                         "parent", hg, x, y, z, "color", mc,
+                         "marker",  ms, "linestyle", "none",
+                         "markerfacecolor", fc, "parent", hg);
 
-	h_baseline = [];
+        h_baseline = [];
       else
-	h_stems = plot (xt, yt, "color", lc, "linestyle", ls,
-			"parent", hg, x(:,i), y(:, i), "color", mc, "marker",
-			ms, "linestyle", "none", "markerfacecolor",
-			fc, "parent", hg); 
+        h_stems = plot (xt, yt, "color", lc, "linestyle", ls,
+                        "parent", hg, x(:,i), y(:, i), "color", mc, "marker",
+                        ms, "linestyle", "none", "markerfacecolor",
+                        fc, "parent", hg); 
 
-	if (i == 1)
-	  x_axis_range = get (ax, "xlim");
-	  h_baseline = line (x_axis_range, [0, 0], "color", [0, 0, 0]);
-	  set (h_baseline, "handlevisibility", "off");
-	  set (h_baseline, "xliminclude", "off");
-	  addlistener (ax, "xlim", @update_xlim);
-	  addlistener (h_baseline, "ydata", @update_baseline);
-	  addlistener (h_baseline, "visible", @update_baseline);
-	endif
+        if (i == 1)
+          x_axis_range = get (ax, "xlim");
+          h_baseline = line (x_axis_range, [0, 0], "color", [0, 0, 0]);
+          set (h_baseline, "handlevisibility", "off");
+          set (h_baseline, "xliminclude", "off");
+          addlistener (ax, "xlim", @update_xlim);
+          addlistener (h_baseline, "ydata", @update_baseline);
+          addlistener (h_baseline, "visible", @update_baseline);
+        endif
       endif
 
       ## Setup the hggroup and listeners.
       addproperty ("showbaseline", hg, "radio", "{on}|off");
       addproperty ("basevalue", hg, "data", 0);
       addproperty ("baseline", hg, "data", h_baseline);
 
       if (!have_z)
-	addlistener (hg, "showbaseline", @show_baseline);
-	addlistener (hg, "basevalue", @move_baseline); 
+        addlistener (hg, "showbaseline", @show_baseline);
+        addlistener (hg, "basevalue", @move_baseline); 
       endif
 
       addproperty ("color", hg, "linecolor", lc);
       addproperty ("linewidth", hg, "linelinewidth", 0.5);
       addproperty ("linestyle", hg, "linelinestyle", ls);
       addproperty ("marker", hg, "linemarker", ms);
       addproperty ("markerfacecolor", hg, "linemarkerfacecolor", fc);
       addproperty ("markersize", hg, "linemarkersize", 6);
@@ -132,30 +132,30 @@ function h = __stem__ (have_z, varargin)
       addlistener (hg, "linestyle", @update_props); 
       addlistener (hg, "marker", @update_props); 
       addlistener (hg, "markerfacecolor", @update_props); 
       addlistener (hg, "markersize", @update_props);
 
       addproperty ("xdata", hg, "data", x(:, i));
       addproperty ("ydata", hg, "data", y(:, i));
       if (have_z)
-	addproperty ("zdata", hg, "data", z(:, i));
+        addproperty ("zdata", hg, "data", z(:, i));
       else
-	addproperty ("zdata", hg, "data", []);
+        addproperty ("zdata", hg, "data", []);
       endif
 
       addlistener (hg, "xdata", @update_data);
       addlistener (hg, "ydata", @update_data);
       addlistener (hg, "zdata", @update_data);
 
       if (! isempty (args))
-	set (hg, args{:});
+        set (hg, args{:});
       endif
       if (i == 1 && !isempty(h_baseline))
-	set (h_baseline, "parent", get (hg, "parent"));
+        set (h_baseline, "parent", get (hg, "parent"));
       endif
     endfor
 
   unwind_protect_cleanup
     set (ax, "nextplot", hold_state);
     axes (oldax);
   end_unwind_protect
 endfunction
@@ -173,17 +173,17 @@ function [x, y, z, dofill, lc, ls, mc, m
     caller = "stem";
   endif
 
   ## Remove prop/val pairs from data to consider.
   i = 2;
   newargs = {};
   while (i < length (varargin))
     if (ischar (varargin{i}) && !(strcmpi ("fill", varargin{i})
-				  || strcmpi ("filled", varargin{i})))
+                                  || strcmpi ("filled", varargin{i})))
       newargs{end + 1} = varargin{i};
       newargs{end + 1} = varargin{i + 1};
       nargin = nargin - 2;
       varargin(i:i+1) = [];
     else
       i++;
     endif
   endwhile
@@ -199,170 +199,170 @@ function [x, y, z, dofill, lc, ls, mc, m
   if (nargin == 2)
     if (have_z)
       z = varargin{1};
       x = 1:rows (z);
       y = 1:columns (z);
     else
       y = varargin{1};
       if (isvector (y))
-	x = 1:length (y);
+        x = 1:length (y);
       elseif (ismatrix (y))
-	x = 1:rows (y);
+        x = 1:rows (y);
       else 
-	error ("stem: Y must be a matrix");
+        error ("stem: Y must be a matrix");
       endif # in each case, x & y will be defined
     endif
   elseif (nargin == 3)
     ## Several possibilities
     ##
     ## 1. the real y data
     ## 2. 'filled'
     ## 3. line spec
     if (ischar (varargin{2}))
       ## Only 2. or 3. possible.
       if (strcmpi ("fill", varargin{2}) || strcmpi ("filled", varargin{2}))
-	dofill = 1;
+        dofill = 1;
       else
-	## Parse the linespec.
-	[lc, ls, mc, ms] = stem_line_spec (caller, varargin{2});
+        ## Parse the linespec.
+        [lc, ls, mc, ms] = stem_line_spec (caller, varargin{2});
       endif
       if (have_z)
-	z = varargin{1};
-	x = 1:rows (z);
-	y = 1:columns (z);
+        z = varargin{1};
+        x = 1:rows (z);
+        y = 1:columns (z);
       else
-	y = varargin{1};
-	if (isvector (y))
-	  x = 1:length (y);
-	elseif (ismatrix (y))
-	  x = 1:rows (y);
-	else
-	  error ("stem: Y must be a matrix");
-	endif # in each case, x & y will be defined
+        y = varargin{1};
+        if (isvector (y))
+          x = 1:length (y);
+        elseif (ismatrix (y))
+          x = 1:rows (y);
+        else
+          error ("stem: Y must be a matrix");
+        endif # in each case, x & y will be defined
       endif
     else
       if (have_z)
-	error ("stem3: must define X, Y and Z");
+        error ("stem3: must define X, Y and Z");
       else
-	## Must be the real y data.
-	x = varargin{1};
-	y = varargin{2};
-	if (! (ismatrix (x) && ismatrix (y)))
-	  error ("stem: X and Y must be matrices");
-	endif
+        ## Must be the real y data.
+        x = varargin{1};
+        y = varargin{2};
+        if (! (ismatrix (x) && ismatrix (y)))
+          error ("stem: X and Y must be matrices");
+        endif
       endif
     endif
   elseif (nargin == 4)
     ## Again, several possibilities:
     ##
     ## arg2 1. real y
     ## arg2 2. 'filled' or linespec
     ## arg3 1. real z
     ## arg3 2. 'filled' or linespec
     if (ischar (varargin{2}))
       ## Only arg2 2. / arg3 1. & arg3 3. are possible.
       if (strcmpi ("fill", varargin{2}) || strcmpi ("filled", varargin{2}))
-	dofill = 1;
-	fill_2 = 1; # Be sure, no second "fill" is in the arguments.
+        dofill = 1;
+        fill_2 = 1; # Be sure, no second "fill" is in the arguments.
       else
-	## Must be a linespec.
-	[lc, ls, mc, ms] = stem_line_spec (caller, varargin{2});
-	linespec_2 = 1;
+        ## Must be a linespec.
+        [lc, ls, mc, ms] = stem_line_spec (caller, varargin{2});
+        linespec_2 = 1;
       endif
       if (have_z)
-	z = varargin{1};
-	x = 1:rows (z);
-	y = 1:columns (z);
+        z = varargin{1};
+        x = 1:rows (z);
+        y = 1:columns (z);
       else
-	y = varargin{1};
-	if (isvector (y))
-	  x = 1:length (y);
-	elseif (ismatrix (y))
-	  x = 1:rows (y);
-	else
-	  error ("stem: Y must be a matrix");
-	endif # in each case, x & y will be defined
+        y = varargin{1};
+        if (isvector (y))
+          x = 1:length (y);
+        elseif (ismatrix (y))
+          x = 1:rows (y);
+        else
+          error ("stem: Y must be a matrix");
+        endif # in each case, x & y will be defined
       endif
     else
       if (have_z)
-	x = varargin{1};
-	y = varargin{2};
-	z = varargin{3};
-	if (! (ismatrix (x) && ismatrix (y) && ismatrix (z)))
-	  error ("stem3: X, Y and Z must be matrices");
-	endif
+        x = varargin{1};
+        y = varargin{2};
+        z = varargin{3};
+        if (! (ismatrix (x) && ismatrix (y) && ismatrix (z)))
+          error ("stem3: X, Y and Z must be matrices");
+        endif
       else
-	## must be the real y data.
-	x = varargin{1};
-	y = varargin{2};
-	if (! (ismatrix (x) && ismatrix (y)))
-	  error ("stem: X and Y must be matrices");
-	endif
+        ## must be the real y data.
+        x = varargin{1};
+        y = varargin{2};
+        if (! (ismatrix (x) && ismatrix (y)))
+          error ("stem: X and Y must be matrices");
+        endif
       endif
     endif # if ischar(varargin{2})
     if (! have_z)
       ## varargin{3} must be char.
       ## Check for "fill.
       if ((strcmpi (varargin{3}, "fill") || strcmpi (varargin{3}, "filled"))
-	  && fill_2)
-	error ("stem: duplicate fill argument");
+          && fill_2)
+        error ("stem: duplicate fill argument");
       elseif (strcmpi ("fill", varargin{3}) && linespec_2)
-	## Must be "fill".
-	dofill = 1;
-	fill_2 = 1;
+        ## Must be "fill".
+        dofill = 1;
+        fill_2 = 1;
       elseif ((strcmpi (varargin{3}, "fill") || strcmpi (varargin{3}, "filled"))
-	  && !linespec_2)
-	## Must be "fill".
-	dofill = 1;
-	fill_2 = 1;
+          && !linespec_2)
+        ## Must be "fill".
+        dofill = 1;
+        fill_2 = 1;
       elseif (! linespec_2)
-	## Must be linespec.
-	[lc, ls, mc, ms] = stem_line_spec (caller, varargin{3});
-	linespec_2 = 1;
+        ## Must be linespec.
+        [lc, ls, mc, ms] = stem_line_spec (caller, varargin{3});
+        linespec_2 = 1;
       endif
     endif
   elseif (nargin == 5)
     if (have_z)
       x = varargin{1};
       y = varargin{2};
       z = varargin{3};
       if (! (ismatrix (x) && ismatrix (y) && ismatrix (z)))
-	error ("stem3: X, Y and Z must be matrices");
+        error ("stem3: X, Y and Z must be matrices");
       endif
     else
       x = varargin{1};
       y = varargin{2};
       if (! (ismatrix (x) && ismatrix (y)))
-	error ("stem: X and Y must be matrices");
+        error ("stem: X and Y must be matrices");
       endif
     endif
 
     if (! have_z)
       if (strcmpi (varargin{3}, "fill") || strcmpi (varargin{3}, "filled"))
-	dofill = 1;
-	fill_2 = 1; # Be sure, no second "fill" is in the arguments.
+        dofill = 1;
+        fill_2 = 1; # Be sure, no second "fill" is in the arguments.
       else
-	## Must be a linespec.
-	[lc, ls, mc, ms] = stem_line_spec (caller, varargin{3});
-	linespec_2 = 1;
+        ## Must be a linespec.
+        [lc, ls, mc, ms] = stem_line_spec (caller, varargin{3});
+        linespec_2 = 1;
       endif
     endif
 
     ## Check for "fill".
     if ((strcmpi (varargin{4}, "fill") || strcmpi (varargin{4}, "filled"))
-	&& fill_2)
+        && fill_2)
       error ("%s: duplicate fill argument", caller);
     elseif ((strcmpi (varargin{4}, "fill") || strcmpi (varargin{4}, "filled"))
-	&& linespec_2)
+        && linespec_2)
       ## Must be "fill".
       dofill = 1;
       fill_2 = 1;
     elseif (!strcmpi (varargin{4}, "fill") && !strcmpi (varargin{4}, "filled")
-	&& !linespec_2)
+        && !linespec_2)
       ## Must be linespec.
       [lc, ls, mc, ms] = stem_line_spec (caller, varargin{4});
       linespec_2 = 1;
     endif
   elseif (nargin == 6 && have_z)
     x = varargin{1};
     y = varargin{2};
     z = varargin{3};
@@ -376,25 +376,25 @@ function [x, y, z, dofill, lc, ls, mc, m
     else
       ## Must be a linespec.
       [lc, ls, mc, ms] = stem_line_spec (caller, varargin{4});
       linespec_2 = 1;
     endif
 
     ## check for "fill" ..
     if ((strcmpi (varargin{5}, "fill") || strcmpi (varargin{5}, "filled"))
-	&& fill_2)
+        && fill_2)
       error ("stem3: duplicate fill argument");
     elseif ((strcmpi (varargin{5}, "fill") || strcmpi (varargin{5}, "filled"))
-	&& linespec_2)
+        && linespec_2)
       ## Must be "fill".
       dofill = 1;
       fill_2 = 1;
     elseif (!strcmpi (varargin{5}, "fill") && !strcmpi (varargin{5}, "filled")
-	    && !linespec_2)
+            && !linespec_2)
       ## Must be linespec.
       [lc, ls, mc, ms] = stem_line_spec (caller, varargin{5});
       linespec_2 = 1;
     endif
   else
     error ("%s: incorrect number of arguments", caller);
   endif
 
@@ -406,39 +406,39 @@ function [x, y, z, dofill, lc, ls, mc, m
       x = x(:);
       y = y(:);
       z = z(:);
     endif
   else
     if (isvector (x))
       x = x(:);
       if (isvector (y))
-	if (length (x) != length (y))
-	  error ("stem: inconsistent size of x and y");
-	else
-	  y = y(:);
-	endif
+        if (length (x) != length (y))
+          error ("stem: inconsistent size of x and y");
+        else
+          y = y(:);
+        endif
       else
-	if (length (x) == rows (y))
-	  x = repmat (x(:), 1, columns (y));
-	else
-	  error ("stem: inconsistent size of x and y");
-	endif
+        if (length (x) == rows (y))
+          x = repmat (x(:), 1, columns (y));
+        else
+          error ("stem: inconsistent size of x and y");
+        endif
       endif
     elseif (!size_equal (x, y))
       error ("stem: inconsistent size of x and y");
     endif
   endif
 
 endfunction
 
 function [lc, ls, mc, ms] = stem_line_spec (caller, str)
   if (! ischar (str))
     error ("%s: expecting argument to be \"fill\" or a string of specifiers",
-	   caller);
+           caller);
   endif
   [lc, ls, mc, ms] = set_default_values ();
   ## Parse the line specifier string.
   cur_props = __pltopt__ ("stem", str, false);
   for i = 1:length(cur_props)
     if (isfield (cur_props(i), "color") && ! isempty (cur_props(i).color)); # means line color
       mc = lc = cur_props(i).color;
     elseif (isfield (cur_props(i), "linestyle"))
@@ -466,37 +466,37 @@ endfunction
 function update_xlim (h, d)
   kids = get (h, "children");
   xlim = get (h, "xlim");
 
   for i = 1 : length (kids)
     obj = get (kids (i));
     if (strcmp (obj.type, "hggroup") && isfield (obj, "baseline"))
       if (any (get (obj.baseline, "xdata") != xlim))
-	set (obj.baseline, "xdata", xlim);
+        set (obj.baseline, "xdata", xlim);
       endif
     endif
   endfor
 endfunction
 
 function update_baseline (h, d)
   visible = get (h, "visible");
   ydata = get (h, "ydata")(1);
 
   kids = get (get (h, "parent"), "children");
   for i = 1 : length (kids)
     obj = get (kids (i));
     if (strcmp (obj.type, "hggroup") && isfield (obj, "baseline") 
-	&& obj.baseline == h)
+        && obj.baseline == h)
       ## Only alter if changed to avoid recursion of the listener functions
       if (! strcmpi (get (kids(i), "showbaseline"), visible))
-	set (kids (i), "showbaseline", visible);
+        set (kids (i), "showbaseline", visible);
       endif
       if (! strcmpi (get (kids(i), "basevalue"), visible))
-	set (kids (i), "basevalue", ydata);
+        set (kids (i), "basevalue", ydata);
       endif
     endif
   endfor
 endfunction
 
 function show_baseline (h, d)
   set (get (h, "baseline"), "visible", get (h, "showbaseline"));
 endfunction
diff --git a/scripts/plot/refreshdata.m b/scripts/plot/refreshdata.m
--- a/scripts/plot/refreshdata.m
+++ b/scripts/plot/refreshdata.m
@@ -60,19 +60,19 @@ function refreshdata (h, ws)
     endif
     if (!all (ishandle (h)) || !all (strcmp (get (h, "type"), "figure")))
       error ("refreshdata: expecting a list of figure handles");
     endif
     if (nargin < 2)
       ws = "base";
     else
       if (!ischar (ws) || !(strcmpi (ws, "base") || strcmpi (ws, "caller")))
-	error ("refreshdata: expecting workspace to be \"base\" or ""caller\"");
+        error ("refreshdata: expecting workspace to be \"base\" or ""caller\"");
       else
-	ws = tolower (ws);
+        ws = tolower (ws);
       endif
     endif
   endif
 
   h = findall (h);
   objs = [];
   props = {};
 
@@ -87,20 +87,20 @@ function refreshdata (h, ws)
       objs  = [objs ; h(i)];
     endif
   endfor
 
   for i = 1 : length (objs)
     for j = 1 : length (props {i})
       expr = get (objs(i), props{i}{j});
       if (!isempty (expr))
-	val = evalin (ws, expr);
-	prop =  props{i}{j}(1:end-6);
+        val = evalin (ws, expr);
+        prop =  props{i}{j}(1:end-6);
         if (! isequal (get (objs(i), prop), val))
-	  set (objs(i), props{i}{j}(1:end-6), val);
+          set (objs(i), props{i}{j}(1:end-6), val);
         endif
       endif
     endfor
   endfor
 endfunction
 
 %!demo
 %! x = 0:0.1:10;
diff --git a/scripts/plot/ribbon.m b/scripts/plot/ribbon.m
--- a/scripts/plot/ribbon.m
+++ b/scripts/plot/ribbon.m
@@ -71,17 +71,17 @@ function h = ribbon (x, y, width)
     cc = ones (size (zz)) * c;
     tmp(c) = surface (xx, yy, zz, cc);
   endfor
 
   ax = get (tmp(c), "parent");
 
   if (! ishold ())
     set (ax, "view", [-37.5, 30], "box", "off", "xgrid", "on",
-	 "ygrid", "on", "zgrid", "on");
+         "ygrid", "on", "zgrid", "on");
   endif
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
diff --git a/scripts/plot/rose.m b/scripts/plot/rose.m
--- a/scripts/plot/rose.m
+++ b/scripts/plot/rose.m
@@ -46,17 +46,17 @@
 ##
 ##
 ## @seealso{plot, compass, polar, hist}
 ## @end deftypefn
 
 function [thout, rout] = rose (varargin)
 
   [h, varargin, nargin] = __plt_get_axis_arg__ ((nargout > 1), "rose", 
-						varargin{:});
+                                                varargin{:});
 
   if (nargin < 1)
     print_usage ();
   endif
 
   ## Force theta to [0,2*pi] range
   th = varargin {1};
   th = atan2  (sin (th), cos (th)) + pi;
diff --git a/scripts/plot/slice.m b/scripts/plot/slice.m
--- a/scripts/plot/slice.m
+++ b/scripts/plot/slice.m
@@ -130,48 +130,48 @@ function h = slice (varargin)
 
   if (have_sval)
     ns = length (sx) + length (sy) + length (sz);
     hs = zeros(ns,1);
     [ny, nx, nz] = size (v);
     if (length(sz) > 0)
       for i = 1:length(sz)
         [xi, yi, zi] = meshgrid (squeeze (x(1,:,1)),
-				 squeeze (y(:,1,1)), sz(i));
+                                 squeeze (y(:,1,1)), sz(i));
         vz = squeeze (interp3 (x, y, z, v, xi, yi, zi, method));
         tmp(sidx++) = surface (xi, yi, sz(i) * ones (size (yi)), vz);
       endfor
     endif
 
     if (length (sy) > 0)
       for i = length(sy):-1:1
-	[xi, yi, zi] = meshgrid (squeeze (x(1,:,1)), sy(i), squeeze (z(1,1,:)));
+        [xi, yi, zi] = meshgrid (squeeze (x(1,:,1)), sy(i), squeeze (z(1,1,:)));
         vy = squeeze (interp3 (x, y, z, v, xi, yi, zi, method));
         tmp(sidx++) = surface (squeeze (xi),
-			       squeeze (sy(i) * ones (size (zi))),
-			       squeeze (zi), vy);
+                               squeeze (sy(i) * ones (size (zi))),
+                               squeeze (zi), vy);
       endfor
     endif
 
     if (length (sx) > 0)
       for i = length(sx):-1:1
         [xi, yi, zi] = meshgrid (sx(i), squeeze (y(:,1,1)), squeeze (z(1,1,:)));
         vx = squeeze (interp3 (x, y, z, v, xi, yi, zi, method));
         tmp(sidx++) = surface (squeeze (sx(i) * ones (size (zi))),
-			       squeeze (yi), squeeze(zi), vx);
+                               squeeze (yi), squeeze(zi), vx);
       endfor
     endif
   else
     vi = interp3 (x, y, z, v, sx, sy, sz);
     tmp = surface (sx, sy, sz, vi);
   endif
 
   if (! ishold ())
     set (ax, "view", [-37.5, 30.0], "box", "off", "xgrid", "on",
-	 "ygrid", "on", "zgrid", "on");
+         "ygrid", "on", "zgrid", "on");
   endif
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
diff --git a/scripts/plot/sombrero.m b/scripts/plot/sombrero.m
--- a/scripts/plot/sombrero.m
+++ b/scripts/plot/sombrero.m
@@ -41,21 +41,21 @@ function [x, y, z] = sombrero (n)
   if (nargin < 2)
     if (n > 1)
       tx = ty = linspace (-8, 8, n)';
       [xx, yy] = meshgrid (tx, ty);
       r = sqrt (xx .^ 2 + yy .^ 2) + eps;
       tz = sin (r) ./ r;
       if (nargout == 0)
         surf (tx, ty, tz);
-	box ("off");
+        box ("off");
       else
-	x = tx;
-	y = ty;
-	z = tz;
+        x = tx;
+        y = ty;
+        z = tz;
       endif
     else
       error ("sombrero: number of grid lines must be greater than 1");
     endif
   else
     print_usage ();
   endif
 
diff --git a/scripts/plot/sphere.m b/scripts/plot/sphere.m
--- a/scripts/plot/sphere.m
+++ b/scripts/plot/sphere.m
@@ -28,17 +28,17 @@
 ## @code{surf (@var{x}, @var{y}, @var{z})}.  If an axes handle is passed
 ## as the first argument, the surface is plotted to this set of axes.
 ## @seealso{peaks}
 ## @end deftypefn
 
 function [xx, yy, zz] = sphere (varargin)
 
   [h, varargin, nargin] = __plt_get_axis_arg__ ((nargout > 0), "sphere", 
-						varargin{:});
+                                                varargin{:});
   if (nargin > 1)
     print_usage ();
   elseif (nargin == 1)
     n = varargin{1};
   else
     n = 20;
   endif
 
diff --git a/scripts/plot/stairs.m b/scripts/plot/stairs.m
--- a/scripts/plot/stairs.m
+++ b/scripts/plot/stairs.m
@@ -60,37 +60,37 @@ function [xs, ys] = stairs (varargin)
   if (nargin < 1)
     print_usage ();
   else
     if (nargout > 1)
       [h, xs, ys] = __stairs__ (false, varargin{:});
     else
       oldax = gca ();
       unwind_protect
-	axes (ax);
-	newplot ();
-	[h, xxs, yys] = __stairs__ (true, varargin{:});
+        axes (ax);
+        newplot ();
+        [h, xxs, yys] = __stairs__ (true, varargin{:});
       unwind_protect_cleanup
-	axes (oldax);
+        axes (oldax);
       end_unwind_protect
     endif
     if (nargout == 1)
       xs = h;
     endif
   endif
 endfunction
 
 function [h, xs, ys] = __stairs__ (doplot, varargin)
 
   if (nargin == 2 || ischar (varargin{2}))
     y = varargin {1};
     varargin(1) = [];
     if (ismatrix (y))
       if (isvector (y))
-	y = y(:);
+        y = y(:);
       endif
       x = 1:rows (y);
     endif
   else
     x = varargin{1};
     y = varargin{2};
     varargin(1:2) = [];
   endif
@@ -111,17 +111,17 @@ function [h, xs, ys] = __stairs__ (doplo
 
   if (ismatrix (y))
     [nr, nc] = size (y);
     if (vec_x)
       x = repmat (x, [1, nc]);
     else
       [x_nr, x_nc] = size (x);
       if (x_nr != nr || x_nc != nc)
-	error ("stairs: argument size mismatch");
+        error ("stairs: argument size mismatch");
       endif
     endif
   endif
 
   len = 2*nr - 1;
 
   xs = ys = zeros (len, nc);
 
@@ -138,69 +138,69 @@ function [h, xs, ys] = __stairs__ (doplo
   ys(ridx,:) = y(2:nr,:);
 
   have_line_spec = false;
   for i = 1 : length (varargin)
     arg = varargin {i};
     if ((ischar (arg) || iscell (arg)) && ! have_line_spec)
       [linespec, valid] = __pltopt__ ("stairs", arg, false);
       if (valid)
-	have_line_spec = true;
-	varargin(i) = [];
-	break;
+        have_line_spec = true;
+        varargin(i) = [];
+        break;
       endif
     endif
   endfor 
 
   if (doplot)
     h = [];
     unwind_protect
       hold_state = get (gca (), "nextplot");
       for i = 1 : size(y, 2)
-	hg = hggroup ();
-	h = [h; hg];
-	args = __add_datasource__ ("stairs", hg, {"x", "y"}, varargin{:});
+        hg = hggroup ();
+        h = [h; hg];
+        args = __add_datasource__ ("stairs", hg, {"x", "y"}, varargin{:});
 
-	addproperty ("xdata", hg, "data", x(:,i).');
-	addproperty ("ydata", hg, "data", y(:,i).');
+        addproperty ("xdata", hg, "data", x(:,i).');
+        addproperty ("ydata", hg, "data", y(:,i).');
 
-	addlistener (hg, "xdata", @update_data);
-	addlistener (hg, "ydata", @update_data);
+        addlistener (hg, "xdata", @update_data);
+        addlistener (hg, "ydata", @update_data);
 
-	if (have_line_spec)
-	  tmp = line (xs(:,i).', ys(:,i).', "color", linespec.color,
-		      "parent", hg);
-	else
-	  tmp = line (xs(:,i).', ys(:,i).', "color", __next_line_color__ (),
-		      "parent", hg);
-	endif
+        if (have_line_spec)
+          tmp = line (xs(:,i).', ys(:,i).', "color", linespec.color,
+                      "parent", hg);
+        else
+          tmp = line (xs(:,i).', ys(:,i).', "color", __next_line_color__ (),
+                      "parent", hg);
+        endif
 
         addproperty ("color", hg, "linecolor", get (tmp, "color"));
-	addproperty ("linewidth", hg, "linelinewidth", get (tmp, "linewidth"));
-	addproperty ("linestyle", hg, "linelinestyle", get (tmp, "linestyle"));
+        addproperty ("linewidth", hg, "linelinewidth", get (tmp, "linewidth"));
+        addproperty ("linestyle", hg, "linelinestyle", get (tmp, "linestyle"));
 
-	addproperty ("marker", hg, "linemarker", get (tmp, "marker"));
-	addproperty ("markerfacecolor", hg, "linemarkerfacecolor",
-		     get (tmp, "markerfacecolor"));
-	addproperty ("markeredgecolor", hg, "linemarkeredgecolor",
-		     get (tmp, "markeredgecolor"));
-	addproperty ("markersize", hg, "linemarkersize",
-		     get (tmp, "markersize"));
+        addproperty ("marker", hg, "linemarker", get (tmp, "marker"));
+        addproperty ("markerfacecolor", hg, "linemarkerfacecolor",
+                     get (tmp, "markerfacecolor"));
+        addproperty ("markeredgecolor", hg, "linemarkeredgecolor",
+                     get (tmp, "markeredgecolor"));
+        addproperty ("markersize", hg, "linemarkersize",
+                     get (tmp, "markersize"));
 
-	addlistener (hg, "color", @update_props);
-	addlistener (hg, "linewidth", @update_props); 
-	addlistener (hg, "linestyle", @update_props); 
-	addlistener (hg, "marker", @update_props); 
-	addlistener (hg, "markerfacecolor", @update_props); 
-	addlistener (hg, "markeredgecolor", @update_props); 
-	addlistener (hg, "markersize", @update_props); 
+        addlistener (hg, "color", @update_props);
+        addlistener (hg, "linewidth", @update_props); 
+        addlistener (hg, "linestyle", @update_props); 
+        addlistener (hg, "marker", @update_props); 
+        addlistener (hg, "markerfacecolor", @update_props); 
+        addlistener (hg, "markeredgecolor", @update_props); 
+        addlistener (hg, "markersize", @update_props); 
 
-	if (! isempty (args))
-	  set (hg, args{:});
-	endif
+        if (! isempty (args))
+          set (hg, args{:});
+        endif
       endfor
     unwind_protect_cleanup
       set (gca (), "nextplot", hold_state);
     end_unwind_protect
   else
     h = 0;
   endif
 
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -115,39 +115,39 @@ function h = subplot (rows, columns, ind
       ## "deletefcn" callback or for legends/colorbars that are deleted
       ## with their corresponding axes).
       if (! ishandle (child))
         continue;
       endif
       if (strcmp (get (child, "type"), "axes"))
         ## Skip legend and colorbar objects.
         if (strcmp (get (child, "tag"), "legend") || 
-	    strcmp (get (child, "tag"), "colorbar"))
+            strcmp (get (child, "tag"), "colorbar"))
           continue;
         endif
         objpos = get (child, "position");
         if (all (objpos == pos))
-	  ## If the new axes are in exactly the same position as an
-	  ## existing axes object, use the existing axes.
-	  found = true;
-	  tmp = child;
+          ## If the new axes are in exactly the same position as an
+          ## existing axes object, use the existing axes.
+          found = true;
+          tmp = child;
         else
-	  ## If the new axes overlap an old axes object, delete the old
-	  ## axes.
-	  x0 = pos(1);
-	  x1 = x0 + pos(3);
-	  y0 = pos(2);
-	  y1 = y0 + pos(4);	
-	  objx0 = objpos(1);
-	  objx1 = objx0 + objpos(3);
-	  objy0 = objpos(2);
-	  objy1 = objy0 + objpos(4);
-	  if (! (x0 >= objx1 || x1 <= objx0 || y0 >= objy1 || y1 <= objy0))
-	    delete (child);
-	  endif
+          ## If the new axes overlap an old axes object, delete the old
+          ## axes.
+          x0 = pos(1);
+          x1 = x0 + pos(3);
+          y0 = pos(2);
+          y1 = y0 + pos(4);     
+          objx0 = objpos(1);
+          objx1 = objx0 + objpos(3);
+          objy0 = objpos(2);
+          objy1 = objy0 + objpos(4);
+          if (! (x0 >= objx1 || x1 <= objx0 || y0 >= objy1 || y1 <= objy0))
+            delete (child);
+          endif
         endif
       endif
     endfor
 
     if (found)
       set (cf, "currentaxes", tmp);
     else
       pos = subplot_position (rows, columns, index, "outerposition", units);
diff --git a/scripts/plot/surf.m b/scripts/plot/surf.m
--- a/scripts/plot/surf.m
+++ b/scripts/plot/surf.m
@@ -36,17 +36,17 @@ function retval = surf (varargin)
   oldh = gca ();
   unwind_protect
     axes (h);
     newplot ();
     tmp = surface (varargin{:});
 
     if (! ishold ())
       set (h, "view", [-37.5, 30],
-	   "xgrid", "on", "ygrid", "on", "zgrid", "on");
+           "xgrid", "on", "ygrid", "on", "zgrid", "on");
     endif
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
   if (nargout > 0)
     retval = tmp;
   endif
diff --git a/scripts/plot/surface.m b/scripts/plot/surface.m
--- a/scripts/plot/surface.m
+++ b/scripts/plot/surface.m
@@ -143,16 +143,16 @@ function [h, bad_usage] = __surface__ (a
 
   if (! bad_usage)
     ## Make a default surface object.
     other_args = {};
     if (firststring < nargin)
       other_args = varargin(firststring:end);
     endif
     h = __go_surface__ (ax, "xdata", x, "ydata", y, "zdata", z, "cdata", c,
-			other_args{:});
+                        other_args{:});
 
     if (! ishold ())
       set (ax, "view", [0, 90], "box", "off");
     endif
   endif
 
 endfunction
diff --git a/scripts/plot/surfl.m b/scripts/plot/surfl.m
--- a/scripts/plot/surfl.m
+++ b/scripts/plot/surfl.m
@@ -71,17 +71,17 @@ function retval = surfl (varargin)
     newplot ();
 
     ## Check for lighting type.
     use_cdata = true;
     if (ischar (varargin{end}))
       lstr = varargin{end};
       if (strncmp (tolower (lstr), "light", 5))
         warning ("light method not supported (yet), using cdata method instead");
-	## This can be implemented when light objects are supported.
+        ## This can be implemented when light objects are supported.
         use_cdata = false;
       elseif (strncmp (tolower (lstr), "cdata", 5))
         use_cdata = true;
       else
         error ("surfl: unknown lighting method");
       endif
       varargin(end) = [];
     endif
@@ -114,17 +114,17 @@ function retval = surfl (varargin)
         varargin(end) = [];
         have_lv = true;
       endif
     endif
     
     tmp = surface (varargin{:});
     if (! ishold ())
       set (h, "view", [-37.5, 30],
-	   "xgrid", "on", "ygrid", "on", "zgrid", "on", "clim", [0 1]);
+           "xgrid", "on", "ygrid", "on", "zgrid", "on", "clim", [0 1]);
     endif
 
     ## Get view vector (vv).
     a = axis;
     [az, el] = view;
     [vv(1), vv(2), vv(3)] = sph2cart ((az - 90) * pi/180.0, el * pi/180.0, 1.0);
     vv /= norm (vv);
 
diff --git a/scripts/plot/surfnorm.m b/scripts/plot/surfnorm.m
--- a/scripts/plot/surfnorm.m
+++ b/scripts/plot/surfnorm.m
@@ -49,17 +49,17 @@
 ## surfnorm (peaks (25));
 ## @end example
 ## @seealso{surf, quiver3}
 ## @end deftypefn
 
 function [Nx, Ny, Nz] = surfnorm (varargin)
 
   [h, varargin, nargin] = __plt_get_axis_arg__ ((nargout != 0), "surfnorm", 
-						varargin{:});
+                                                varargin{:});
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
   endif
 
   if (nargin == 1)
     z = varargin{1};
     [x, y] = meshgrid (1:size(z,1), 1:size(z,2));
@@ -93,43 +93,43 @@ function [Nx, Ny, Nz] = surfnorm (vararg
 
   c = cross ([u.x(:), u.y(:), u.z(:)], [v.x(:), v.y(:), v.z(:)]);
   w.x = reshape (c(:,1), size(u.x));
   w.y = reshape (c(:,2), size(u.y));
   w.z = reshape (c(:,3), size(u.z));
 
   ## Create normal vectors as mesh vectices from normals at mesh centers
   nx = (w.x(1:end-1,1:end-1) + w.x(1:end-1,2:end) +
-	w.x(2:end,1:end-1) + w.x(2:end,2:end)) ./ 4; 
+        w.x(2:end,1:end-1) + w.x(2:end,2:end)) ./ 4; 
   ny = (w.y(1:end-1,1:end-1) + w.y(1:end-1,2:end) +
-	w.y(2:end,1:end-1) + w.y(2:end,2:end)) ./ 4; 
+        w.y(2:end,1:end-1) + w.y(2:end,2:end)) ./ 4; 
   nz = (w.z(1:end-1,1:end-1) + w.z(1:end-1,2:end) +
-	w.z(2:end,1:end-1) + w.z(2:end,2:end)) ./ 4; 
+        w.z(2:end,1:end-1) + w.z(2:end,2:end)) ./ 4; 
 
   ## Normalize the normal vectors
   len = sqrt (nx.^2 + ny.^2 + nz.^2);
   nx = nx ./ len;
   ny = ny ./ len;
   nz = nz ./ len;
 
   if (nargout == 0)
     oldh = gca ();
     unwind_protect
       axes (h);
       newplot ();
       surf (x, y, z, varargin{ioff:end});
       old_hold_state = get (h, "nextplot");
       unwind_protect
-	set (h, "nextplot", "add");
-	plot3 ([x(:)'; x(:).' + nx(:).' ; NaN(size(x(:).'))](:),
-	       [y(:)'; y(:).' + ny(:).' ; NaN(size(y(:).'))](:),
-	       [z(:)'; z(:).' + nz(:).' ; NaN(size(z(:).'))](:), 
-	       varargin{ioff:end});
+        set (h, "nextplot", "add");
+        plot3 ([x(:)'; x(:).' + nx(:).' ; NaN(size(x(:).'))](:),
+               [y(:)'; y(:).' + ny(:).' ; NaN(size(y(:).'))](:),
+               [z(:)'; z(:).' + nz(:).' ; NaN(size(z(:).'))](:), 
+               varargin{ioff:end});
       unwind_protect_cleanup
-	set (h, "nextplot", old_hold_state);
+        set (h, "nextplot", old_hold_state);
       end_unwind_protect
     unwind_protect_cleanup
       axes (oldh);
     end_unwind_protect
   else
     Nx = nx;
     Ny = ny;
     Nz = nz;
diff --git a/scripts/plot/text.m b/scripts/plot/text.m
--- a/scripts/plot/text.m
+++ b/scripts/plot/text.m
@@ -45,17 +45,17 @@ function h = text (varargin)
       z = zeros (size (x));
       offset = 3;
     endif
 
     label = varargin{offset};
     if (ischar (label) || iscellstr (label))
       varargin(1:offset) = [];
       if (ischar (label))
-	label = cellstr (label);
+        label = cellstr (label);
       endif
       n = numel (label);
       nx = numel (x);
       ny = numel (y);
       nz = numel (z);
     else
       error ("text: expecting label to be a character string or cell array of character strings");
     endif
@@ -68,32 +68,32 @@ function h = text (varargin)
 
   if (rem (numel (varargin), 2) == 0)
 
     if (nx == ny && nx == nz)
       pos = [x(:), y(:), z(:)];
       ca = gca ();
       tmp = zeros (n, 1);
       if (n == 1)
-	label = label{1};
-	for i = 1:nx
-	  tmp(i) = __go_text__ (ca, "string", label,
-				"position", pos(i,:),
-				varargin{:});
-	endfor
-	__request_drawnow__ ();
+        label = label{1};
+        for i = 1:nx
+          tmp(i) = __go_text__ (ca, "string", label,
+                                "position", pos(i,:),
+                                varargin{:});
+        endfor
+        __request_drawnow__ ();
       elseif (n == nx)
-	for i = 1:nx
-	  tmp(i) = __go_text__ (ca, "string", label{i},
-				"position", pos(i,:),
-				varargin{:});
-	endfor
-	__request_drawnow__ ();
+        for i = 1:nx
+          tmp(i) = __go_text__ (ca, "string", label{i},
+                                "position", pos(i,:),
+                                varargin{:});
+        endfor
+        __request_drawnow__ ();
       else
-	error ("text: dimension mismatch for coordinates and label");
+        error ("text: dimension mismatch for coordinates and label");
       endif
     else
       error ("text: dimension mismatch for coordinates");
     endif
 
     if (nargout > 0)
       h = tmp;
     endif
diff --git a/scripts/plot/view.m b/scripts/plot/view.m
--- a/scripts/plot/view.m
+++ b/scripts/plot/view.m
@@ -29,23 +29,23 @@ function [azimuth, elevation] = view (x,
 
   if (nargin < 4)
     if (nargin == 0)
       tmp = get (gca (), "view");
       az = tmp(1);
       el = tmp(2);
     elseif (nargin == 1)
       if (x == 2)
-	az = 0;
-	el = 90;
+        az = 0;
+        el = 90;
       elseif (x == 3)
-	az = -37.5;
-	el = 30;
+        az = -37.5;
+        el = 30;
       else
-	error ("view: expecting single argument to be 2 or 3");
+        error ("view: expecting single argument to be 2 or 3");
       endif
     elseif (nargin == 2)
       az = x;
       el = y;
     elseif (nargin == 3)
       error ("view: view (x, y, z) not implemented");
     endif
 
diff --git a/scripts/polynomial/polyderiv.m b/scripts/polynomial/polyderiv.m
--- a/scripts/polynomial/polyderiv.m
+++ b/scripts/polynomial/polyderiv.m
@@ -37,52 +37,52 @@
 function [q, r] = polyderiv (p, a)
 
   if (nargin == 1 || nargin == 2)
     if (! isvector (p))
       error ("polyderiv: argument must be a vector");
     endif
     if (nargin == 2)
       if (! isvector (a))
-	error ("polyderiv: argument must be a vector");
+        error ("polyderiv: argument must be a vector");
       endif
       if (nargout == 1) 
-	## derivative of p*a returns a single polynomial
-	q = polyderiv (conv (p, a));
+        ## derivative of p*a returns a single polynomial
+        q = polyderiv (conv (p, a));
       else
-	## derivative of p/a returns numerator and denominator
-	r = conv (a, a);
-	if (numel (p) == 1)
-	  q = -p * polyderiv (a);
-	elseif (numel (a) == 1)
-	  q = a * polyderiv (p);
-	else
-	  q = conv (polyderiv (p), a) - conv (p, polyderiv (a));
-	  q = polyreduce (q);
-	endif
+        ## derivative of p/a returns numerator and denominator
+        r = conv (a, a);
+        if (numel (p) == 1)
+          q = -p * polyderiv (a);
+        elseif (numel (a) == 1)
+          q = a * polyderiv (p);
+        else
+          q = conv (polyderiv (p), a) - conv (p, polyderiv (a));
+          q = polyreduce (q);
+        endif
 
-	## remove common factors from numerator and denominator
-	x = polygcd (q, r);
-	if (length(x) != 1)
-	  q = deconv (q, x);
-	  r = deconv (r, x);
-	endif
+        ## remove common factors from numerator and denominator
+        x = polygcd (q, r);
+        if (length(x) != 1)
+          q = deconv (q, x);
+          r = deconv (r, x);
+        endif
 
-	## move all the gain into the numerator
-	q = q/r(1);
-	r = r/r(1);
+        ## move all the gain into the numerator
+        q = q/r(1);
+        r = r/r(1);
       endif
     else
       lp = numel (p);
       if (lp == 1)
-	q = 0;
-	return;
+        q = 0;
+        return;
       elseif (lp == 0)
-	q = [];
-	return;
+        q = [];
+        return;
       endif
 
       ## Force P to be a row vector.
       p = p(:).';
 
       q = p(1:(lp-1)) .* [(lp-1):-1:1];
     endif
   else
diff --git a/scripts/polynomial/polygcd.m b/scripts/polynomial/polygcd.m
--- a/scripts/polynomial/polygcd.m
+++ b/scripts/polynomial/polygcd.m
@@ -43,41 +43,41 @@
 ## residue, filter, polyval, polyvalm}
 ## @end deftypefn
 
 function x = polygcd (b, a, tol)
 
   if (nargin == 2 || nargin == 3)
     if (nargin == 2)
       if (isa (a, "single") || isa (b, "single"))
-	tol = sqrt (eps ("single"));
+        tol = sqrt (eps ("single"));
       else
-	tol = sqrt (eps);
+        tol = sqrt (eps);
       endif
     endif
     if (length (a) == 1 || length (b) == 1)
       if (a == 0)
-	x = b;
+        x = b;
       elseif (b == 0)
-	x = a;
+        x = a;
       else
-	x = 1;
+        x = 1;
       endif
     else
       a /= a(1);
       while (1)
-	[d, r] = deconv (b, a);
-	nz = find (abs (r) > tol);
-	if (isempty (nz))
-	  x = a;
-	  break;
-	else
-	  r = r(nz(1):length(r));
-	endif
-	b = a;
-	a = r / r(1);
+        [d, r] = deconv (b, a);
+        nz = find (abs (r) > tol);
+        if (isempty (nz))
+          x = a;
+          break;
+        else
+          r = r(nz(1):length(r));
+        endif
+        b = a;
+        a = r / r(1);
       endwhile
     endif
   else
     print_usage ();
   endif
 
 endfunction
diff --git a/scripts/polynomial/polyout.m b/scripts/polynomial/polyout.m
--- a/scripts/polynomial/polyout.m
+++ b/scripts/polynomial/polyout.m
@@ -57,18 +57,18 @@ function y = polyout (c, x)
 
   n = length (c);
   if(n > 0)
     n1 = n+1;
 
     tmp = coeff (c(1));
     for ii = 2:n
       if (real (c(ii)) < 0)
-	ns = " - ";
-	c(ii) = -c(ii);
+        ns = " - ";
+        c(ii) = -c(ii);
       else
         ns = " + ";
       endif
 
       tmp = sprintf ("%s*%s^%d%s%s", tmp, x, n1-ii, ns, coeff (c(ii)));
 
     endfor
   else
diff --git a/scripts/polynomial/spline.m b/scripts/polynomial/spline.m
--- a/scripts/polynomial/spline.m
+++ b/scripts/polynomial/spline.m
@@ -120,69 +120,69 @@ function ret = spline (x, y, xi)
       g = 3 * diff (a(2:n,:)) ./ h(2:n-1,idx) ...
           - 3 * diff (a(1:n-1,:)) ./ h(1:n-2,idx);
       g(1,:) = 3 * (a(3,:) - a(2,:)) / h(2) ...
           - 3 / 2 * (3 * (a(2,:) - a(1,:)) / h(1) - dfs);
       g(n-2,:) = 3 / 2 * (3 * (a(n,:) - a(n-1,:)) / h(n-1) - dfe) ...
           - 3 * (a(n-1,:) - a(n-2,:)) / h(n-2);
 
       c(2:n-1,:) = spdiags ([[e(:); 0], dg, [0; e(:)]],
-			      [-1, 0, 1], n-2, n-2) \ g;
+                              [-1, 0, 1], n-2, n-2) \ g;
     endif
 
     c(1,:) = (3 / h(1) * (a(2,:) - a(1,:)) - 3 * dfs
-	      - c(2,:) * h(1)) / (2 * h(1));
+              - c(2,:) * h(1)) / (2 * h(1));
     c(n,:) = - (3 / h(n-1) * (a(n,:) - a(n-1,:)) - 3 * dfe
-		+ c(n-1,:) * h(n-1)) / (2 * h(n-1));
+                + c(n-1,:) * h(n-1)) / (2 * h(n-1));
     b(1:n-1,:) = diff (a) ./ h(1:n-1, idx) ...
-	- h(1:n-1,idx) / 3 .* (c(2:n,:) + 2 * c(1:n-1,:));
+        - h(1:n-1,idx) / 3 .* (c(2:n,:) + 2 * c(1:n-1,:));
     d = diff (c) ./ (3 * h(1:n-1, idx));
 
   else
 
     g = zeros (n-2, columns (a));
     g(1,:) = 3 / (h(1) + h(2)) ...
-	* (a(3,:) - a(2,:) - h(2) / h(1) * (a(2,:) - a(1,:)));
+        * (a(3,:) - a(2,:) - h(2) / h(1) * (a(2,:) - a(1,:)));
     g(n-2,:) = 3 / (h(n-1) + h(n-2)) ...
-	* (h(n-2) / h(n-1) * (a(n,:) - a(n-1,:)) - (a(n-1,:) - a(n-2,:)));
+        * (h(n-2) / h(n-1) * (a(n,:) - a(n-1,:)) - (a(n-1,:) - a(n-2,:)));
 
     if (n > 4)
 
       g(2:n - 3,:) = 3 * diff (a(3:n-1,:)) ./ h(3:n-2,idx) ...
           - 3 * diff (a(2:n-2,:)) ./ h(2:n - 3,idx);
 
       dg = 2 * (h(1:n-2) .+ h(2:n-1));
       dg(1) = dg(1) - h(1);
       dg(n-2) = dg(n-2) - h(n-1);
 
       ldg = udg = h(2:n-2);
       udg(1) = udg(1) - h(1);
       ldg(n - 3) = ldg(n-3) - h(n-1);
       c(2:n-1,:) = spdiags ([[ldg(:); 0], dg, [0; udg(:)]],
-			      [-1, 0, 1], n-2, n-2) \ g;
+                              [-1, 0, 1], n-2, n-2) \ g;
 
     elseif (n == 4)
 
       dg = [h(1) + 2 * h(2); 2 * h(2) + h(3)];
       ldg = h(2) - h(3);
       udg = h(2) - h(1);
       c(2:n-1,:) = spdiags ([[ldg(:);0], dg, [0; udg(:)]],
-			      [-1, 0, 1], n-2, n-2) \ g;
+                              [-1, 0, 1], n-2, n-2) \ g;
       
     else # n == 3
-	    
+            
       dg = h(1) + 2 * h(2);
       c(2:n-1,:) = g/dg(1);
 
     endif
 
     c(1,:) = c(2,:) + h(1) / h(2) * (c(2,:) - c(3,:));
     c(n,:) = c(n-1,:) + h(n-1) / h(n-2) * (c(n-1,:) - c(n-2,:));
     b = diff (a) ./ h(1:n-1, idx) ...
-	- h(1:n-1, idx) / 3 .* (c(2:n,:) + 2 * c(1:n-1,:));
+        - h(1:n-1, idx) / 3 .* (c(2:n,:) + 2 * c(1:n-1,:));
     d = diff (c) ./ (3 * h(1:n-1, idx));
 
   endif
 
   d = d(1:n-1,:);
   c = c(1:n-1,:);
   b = b(1:n-1,:);
   a = a(1:n-1,:);
diff --git a/scripts/set/intersect.m b/scripts/set/intersect.m
--- a/scripts/set/intersect.m
+++ b/scripts/set/intersect.m
@@ -56,19 +56,19 @@ function [c, ia, ib] = intersect (a, b, 
       c = [a; b];
       [c, ic] = sortrows (c);
       ii = find (all (c(1:end-1,:) == c(2:end,:), 2));
       c = c(ii,:);
     else
       c = [a(:); b(:)];
       [c, ic] = sort (c);               ## [a(:);b(:)](ic) == c
       if (iscellstr (c))
-	ii = find (strcmp (c(1:end-1), c(2:end)));
+        ii = find (strcmp (c(1:end-1), c(2:end)));
       else
-	ii = find (c(1:end-1) == c(2:end));
+        ii = find (c(1:end-1) == c(2:end));
       endif
       c = c(ii);
     endif
 
     if (nargout > 1)
       ia = ja(ic(ii));                  ## a(ia) == c
       ib = jb(ic(ii+1) - length (a));   ## b(ib) == c
     endif
diff --git a/scripts/set/setdiff.m b/scripts/set/setdiff.m
--- a/scripts/set/setdiff.m
+++ b/scripts/set/setdiff.m
@@ -53,42 +53,42 @@ function [c, i] = setdiff (a, b, varargi
     if (! isempty (c) && ! isempty (b))
       ## Form a and b into combined set.
       b = unique (b, "rows");
       [dummy, idx] = sortrows ([c; b]);
       ## Eliminate those elements of a that are the same as in b.
       dups = find (all (dummy(1:end-1,:) == dummy(2:end,:), 2));
       c(idx(dups),:) = [];
       if (nargout > 1)
-	i(idx(dups),:) = [];
+        i(idx(dups),:) = [];
       endif
     endif
   else
     if (nargout > 1)
       [c, i] = unique (a);
     else
       c = unique (a);
     endif
     if (! isempty (c) && ! isempty (b))
       ## Form a and b into combined set.
       b = unique (b);
       [dummy, idx] = sort ([c(:); b(:)]);
       ## Eliminate those elements of a that are the same as in b.
       if (iscellstr (dummy))
         dups = find (strcmp (dummy(1:end-1), dummy(2:end)));
       else
-	dups = find (dummy(1:end-1) == dummy(2:end));
+        dups = find (dummy(1:end-1) == dummy(2:end));
       endif
       c(idx(dups)) = [];
       if (nargout > 1)
-	i(idx(dups)) = [];
+        i(idx(dups)) = [];
       endif
       ## Reshape if necessary.
       if (size (c, 1) != 1 && size (b, 1) == 1)
-	c = c.';
+        c = c.';
       endif
     endif
   endif
   
 endfunction
   
 %!assert(setdiff(["bb";"zz";"bb";"zz"],["bb";"cc";"bb"],"rows"), "zz")
 %!assert(setdiff(["b";"z";"b";"z"],["b";"c";"b"],"rows"), "z")
diff --git a/scripts/set/setxor.m b/scripts/set/setxor.m
--- a/scripts/set/setxor.m
+++ b/scripts/set/setxor.m
@@ -58,34 +58,34 @@ function [c, ia, ib] = setxor (a, b, var
   else
     ## Reject duplicates.
     if (nargin > 2)
       na = rows (a); nb = rows (b);
       [c, i] = sortrows ([a; b]);
       n = rows (c);
       idx = find (all (c(1:n-1) == c(2:n), 2));
       if (! isempty (idx))
-	c([idx, idx+1],:) = [];
-	i([idx, idx+1],:) = [];
+        c([idx, idx+1],:) = [];
+        i([idx, idx+1],:) = [];
       endif
     else
       na = numel (a); nb = numel (b);
       [c, i] = sort ([a(:); b(:)]);
       n = length (c);
       if (iscell (c))
-        idx = find (strcmp (c(1:n-1), c(2:n)));	  
+        idx = find (strcmp (c(1:n-1), c(2:n)));   
       else
         idx = find (c(1:n-1) == c(2:n));
       endif
       if (! isempty (idx))
-	c([idx, idx+1]) = [];
-	i([idx, idx+1]) = [];
+        c([idx, idx+1]) = [];
+        i([idx, idx+1]) = [];
       endif
       if (size (a, 1) == 1 || size (b, 1) == 1)
-	c = c.';
+        c = c.';
       endif
     endif
   endif
   if (nargout > 1)
     ia = ia(i(i <= na));
     ib = ib(i(i > na) - na);
   endif
 
diff --git a/scripts/signal/unwrap.m b/scripts/signal/unwrap.m
--- a/scripts/signal/unwrap.m
+++ b/scripts/signal/unwrap.m
@@ -35,17 +35,17 @@ function retval = unwrap (a, tol, dim)
     print_usage ();
   endif
 
   nd = ndims (a);
   sz = size (a);
 
   if (nargin == 3)
     if (! (isscalar (dim) && dim == round (dim)) && dim > 0 && 
-	dim < (nd + 1))
+        dim < (nd + 1))
       error ("unwrap: dim must be an integer and valid dimension");
     endif
   else
     ## Find the first non-singleton dimension
     dim  = 1;
     while (dim < nd + 1 && sz(dim) == 1)
       dim = dim + 1;
     endwhile
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -117,19 +117,19 @@
 ## verifying this assumption. 
 ## @end itemize
 ## 
 ## Let us consider a trivial problem with a diagonal matrix (we exploit the
 ## sparsity of A) 
 ## 
 ## @example
 ## @group
-## 	n = 10; 
-## 	a = diag (sparse (1:n));
-## 	b = rand (n, 1);
+##      n = 10; 
+##      a = diag (sparse (1:n));
+##      b = rand (n, 1);
 ##      [l, u, p, q] = luinc (a, 1.e-3);
 ## @end group
 ## @end example
 ## 
 ## @sc{Example 1:} Simplest use of @code{pcg}
 ## 
 ## @example
 ##   x = pcg(A,b)
@@ -193,22 +193,22 @@
 ## 
 ##   [x, flag, relres, iter, resvec, eigest] = ...
 ##        pcg (A, b, [], [], "apply_m", [], [], 3)
 ## @end group
 ## @end example
 ## 
 ## @sc{References}
 ## 
-## 	[1] C.T.Kelley, 'Iterative methods for linear and nonlinear equations',
-## 	SIAM, 1995 (the base PCG algorithm) 
-## 	
-## 	[2] Y.Saad, 'Iterative methods for sparse linear systems', PWS 1996
-## 	(condition number estimate from PCG) Revised version of this book is
-## 	available online at http://www-users.cs.umn.edu/~saad/books.html
+##      [1] C.T.Kelley, 'Iterative methods for linear and nonlinear equations',
+##      SIAM, 1995 (the base PCG algorithm) 
+##      
+##      [2] Y.Saad, 'Iterative methods for sparse linear systems', PWS 1996
+##      (condition number estimate from PCG) Revised version of this book is
+##      available online at http://www-users.cs.umn.edu/~saad/books.html
 ## 
 ##
 ## @seealso{sparse, pcr}
 ## @end deftypefn
 
 ## Author: Piotr Krzyzanowski <piotr.krzyzanowski@mimuw.edu.pl>
 ## Modified by: Vittoria Rezzonico <vittoria.rezzonico@epfl.ch>
 ##    - Add the ability to provide the pre-conditioner as two separate
@@ -267,28 +267,28 @@ function [x, flag, relres, iter, resvec,
 
   resvec(1,1) = norm (r);
   alpha = 1;
   iter = 2;
 
   while (resvec (iter-1,1) > tol * resvec (1,1) && iter < maxit)
     if (exist_m1)
       if(isnumeric (m1))
-	y = m1 \ r;
+        y = m1 \ r;
       else
-	y = feval (m1, r, varargin{:});
+        y = feval (m1, r, varargin{:});
       endif
     else
       y = r;
     endif
     if (exist_m2)
       if (isnumeric (m2))
-	z = m2 \ y;
+        z = m2 \ y;
       else
-	z = feval (m2, y, varargin{:});
+        z = feval (m2, y, varargin{:});
       endif
     else
       z = y;
     endif
     tau = z' * r; 
     resvec (iter-1,2) = sqrt (tau);
     beta = tau / oldtau;
     oldtau = tau;
@@ -306,55 +306,55 @@ function [x, flag, relres, iter, resvec,
     if (alpha <= 0.0)
       ## Negative matrix.
       matrix_positive_definite = false;
     endif
     x += alpha * p;
     r -= alpha * w;
     if (nargout > 5 && iter > 2)
       T(iter-1:iter, iter-1:iter) = T(iter-1:iter, iter-1:iter) + ...
-	  [1 sqrt(beta); sqrt(beta) beta]./oldalpha;
+          [1 sqrt(beta); sqrt(beta) beta]./oldalpha;
       ## EVS = eig(T(2:iter-1,2:iter-1));
       ## fprintf(stderr,"PCG condest: %g (iteration: %d)\n", max(EVS)/min(EVS),iter);
     endif
     resvec (iter,1) = norm (r);
     iter++;
   endwhile
 
   if (nargout > 5)
     if (matrix_positive_definite)
       if (iter > 3)
-	T = T(2:iter-2,2:iter-2);
-	l = eig (T);
-	eigest = [min(l), max(l)];
-	## fprintf (stderr, "pcg condest: %g\n", eigest(2)/eigest(1));
+        T = T(2:iter-2,2:iter-2);
+        l = eig (T);
+        eigest = [min(l), max(l)];
+        ## fprintf (stderr, "pcg condest: %g\n", eigest(2)/eigest(1));
       else
-	eigest = [NaN, NaN];
-	warning ("pcg: eigenvalue estimate failed: iteration converged too fast.");
+        eigest = [NaN, NaN];
+        warning ("pcg: eigenvalue estimate failed: iteration converged too fast.");
       endif
     else
       eigest = [NaN, NaN];
     endif
 
     ## Apply the preconditioner once more and finish with the precond
     ## residual.
     if (exist_m1)
       if (isnumeric (m1))
-	y = m1 \ r;
+        y = m1 \ r;
       else
-	y = feval (m1, r, varargin{:});
+        y = feval (m1, r, varargin{:});
       endif
     else
       y = r;
     endif
     if (exist_m2)
       if (isnumeric (m2))
-	z = m2 \ y;
+        z = m2 \ y;
       else
-	z = feval (m2, y, varargin{:});
+        z = feval (m2, y, varargin{:});
       endif
     else
       z = y;
     endif
 
     resvec (iter-1,2) = sqrt (r' * z);
   else
     resvec = resvec(:,1);
@@ -363,166 +363,166 @@ function [x, flag, relres, iter, resvec,
   flag = 0;
   relres = resvec (iter-1,1) ./ resvec(1,1);
   iter -= 2;
   if (iter >= maxit - 2)
     flag = 1;
     if (nargout < 2)
       warning ("pcg: maximum number of iterations (%d) reached\n", iter);
       warning ("the initial residual norm was reduced %g times.\n", ...
-	       1.0 / relres);
+               1.0 / relres);
     endif
   elseif (nargout < 2)
     fprintf (stderr, "pcg: converged in %d iterations. ", iter);
     fprintf (stderr, "the initial residual norm was reduced %g times.\n",...
-	     1.0/relres);
+             1.0/relres);
   endif
 
   if (! matrix_positive_definite)
     flag = 3;
     if (nargout < 2)
       warning ("pcg: matrix not positive definite?\n");
     endif
   endif
 endfunction
 
 %!demo
 %!
-%!	# Simplest usage of pcg (see also 'help pcg')
+%!      # Simplest usage of pcg (see also 'help pcg')
 %!
-%!	N = 10; 
-%!	A = diag ([1:N]); b = rand (N, 1); y =  A \ b; #y is the true solution
-%!  	x = pcg (A, b);
-%!	printf('The solution relative error is %g\n', norm (x - y) / norm (y));
+%!      N = 10; 
+%!      A = diag ([1:N]); b = rand (N, 1); y =  A \ b; #y is the true solution
+%!      x = pcg (A, b);
+%!      printf('The solution relative error is %g\n', norm (x - y) / norm (y));
 %!
-%!	# You shouldn't be afraid if pcg issues some warning messages in this
-%!	# example: watch out in the second example, why it takes N iterations 
-%!	# of pcg to converge to (a very accurate, by the way) solution
+%!      # You shouldn't be afraid if pcg issues some warning messages in this
+%!      # example: watch out in the second example, why it takes N iterations 
+%!      # of pcg to converge to (a very accurate, by the way) solution
 %!demo
 %!
-%!	# Full output from pcg, except for the eigenvalue estimates
-%!	# We use this output to plot the convergence history  
+%!      # Full output from pcg, except for the eigenvalue estimates
+%!      # We use this output to plot the convergence history  
 %!
-%!	N = 10; 
-%!	A = diag ([1:N]); b = rand (N, 1); X =  A \ b; #X is the true solution
-%!  	[x, flag, relres, iter, resvec] = pcg (A, b);
-%!	printf('The solution relative error is %g\n', norm (x - X) / norm (X));
-%!	title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||/||b||)');
-%!	semilogy([0:iter], resvec / resvec(1),'o-g');
+%!      N = 10; 
+%!      A = diag ([1:N]); b = rand (N, 1); X =  A \ b; #X is the true solution
+%!      [x, flag, relres, iter, resvec] = pcg (A, b);
+%!      printf('The solution relative error is %g\n', norm (x - X) / norm (X));
+%!      title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||/||b||)');
+%!      semilogy([0:iter], resvec / resvec(1),'o-g');
 %!      legend('relative residual');
 %!demo
 %!
-%!	# Full output from pcg, including the eigenvalue estimates
-%!	# Hilbert matrix is extremely ill conditioned, so pcg WILL have problems
+%!      # Full output from pcg, including the eigenvalue estimates
+%!      # Hilbert matrix is extremely ill conditioned, so pcg WILL have problems
 %!
-%!	N = 10; 
-%!	A = hilb (N); b = rand (N, 1); X = A \ b; #X is the true solution
-%!  	[x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], 200);
-%!	printf('The solution relative error is %g\n', norm (x - X) / norm (X));
-%!	printf('Condition number estimate is %g\n', eigest(2) / eigest (1));
-%!	printf('Actual condition number is   %g\n', cond (A));
-%!	title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||)');
-%!	semilogy([0:iter], resvec,['o-g';'+-r']);
+%!      N = 10; 
+%!      A = hilb (N); b = rand (N, 1); X = A \ b; #X is the true solution
+%!      [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], 200);
+%!      printf('The solution relative error is %g\n', norm (x - X) / norm (X));
+%!      printf('Condition number estimate is %g\n', eigest(2) / eigest (1));
+%!      printf('Actual condition number is   %g\n', cond (A));
+%!      title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||)');
+%!      semilogy([0:iter], resvec,['o-g';'+-r']);
 %!      legend('absolute residual','absolute preconditioned residual');
 %!demo
 %!
-%!	# Full output from pcg, including the eigenvalue estimates
-%!	# We use the 1-D Laplacian matrix for A, and cond(A) = O(N^2)
-%!	# and that's the reasone we need some preconditioner; here we take
-%!	# a very simple and not powerful Jacobi preconditioner, 
-%!	# which is the diagonal of A
+%!      # Full output from pcg, including the eigenvalue estimates
+%!      # We use the 1-D Laplacian matrix for A, and cond(A) = O(N^2)
+%!      # and that's the reasone we need some preconditioner; here we take
+%!      # a very simple and not powerful Jacobi preconditioner, 
+%!      # which is the diagonal of A
 %!
-%!	N = 100; 
-%!	A = zeros (N, N);
-%!	for i=1 : N - 1 # form 1-D Laplacian matrix
-%!		A (i:i+1, i:i+1) = [2 -1; -1 2];
-%!	endfor
-%!	b = rand (N, 1); X = A \ b; #X is the true solution
-%!	maxit = 80;
-%!	printf('System condition number is %g\n', cond (A));
-%!	# No preconditioner: the convergence is very slow!
+%!      N = 100; 
+%!      A = zeros (N, N);
+%!      for i=1 : N - 1 # form 1-D Laplacian matrix
+%!              A (i:i+1, i:i+1) = [2 -1; -1 2];
+%!      endfor
+%!      b = rand (N, 1); X = A \ b; #X is the true solution
+%!      maxit = 80;
+%!      printf('System condition number is %g\n', cond (A));
+%!      # No preconditioner: the convergence is very slow!
 %!
-%!  	[x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit);
-%!	printf('System condition number estimate is %g\n', eigest(2) / eigest(1));
-%!	title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||)');
-%!	semilogy([0:iter], resvec(:,1), 'o-g');
+%!      [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit);
+%!      printf('System condition number estimate is %g\n', eigest(2) / eigest(1));
+%!      title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||)');
+%!      semilogy([0:iter], resvec(:,1), 'o-g');
 %!      legend('NO preconditioning: absolute residual');
 %!
-%!	pause(1);
-%!	# Test Jacobi preconditioner: it will not help much!!!
+%!      pause(1);
+%!      # Test Jacobi preconditioner: it will not help much!!!
 %!
-%!	M = diag (diag (A)); # Jacobi preconditioner
-%!  	[x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit, M);
-%!	printf('JACOBI preconditioned system condition number estimate is %g\n', eigest(2) / eigest(1));
-%!	hold on;
-%!	semilogy([0:iter], resvec(:,1), 'o-r');
+%!      M = diag (diag (A)); # Jacobi preconditioner
+%!      [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit, M);
+%!      printf('JACOBI preconditioned system condition number estimate is %g\n', eigest(2) / eigest(1));
+%!      hold on;
+%!      semilogy([0:iter], resvec(:,1), 'o-r');
 %!      legend('NO preconditioning: absolute residual', ...
 %!             'JACOBI preconditioner: absolute residual');
 %!
-%!	pause(1);
-%!	# Test nonoverlapping block Jacobi preconditioner: it will help much!
+%!      pause(1);
+%!      # Test nonoverlapping block Jacobi preconditioner: it will help much!
 %!
-%!	M = zeros (N, N); k = 4;
-%!	for i = 1 : k : N # form 1-D Laplacian matrix
-%!		M (i:i+k-1, i:i+k-1) = A (i:i+k-1, i:i+k-1);
-%!	endfor
-%!  	[x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit, M);
-%!	printf('BLOCK JACOBI preconditioned system condition number estimate is %g\n', eigest(2) / eigest(1));
-%!	semilogy ([0:iter], resvec(:,1),'o-b');
+%!      M = zeros (N, N); k = 4;
+%!      for i = 1 : k : N # form 1-D Laplacian matrix
+%!              M (i:i+k-1, i:i+k-1) = A (i:i+k-1, i:i+k-1);
+%!      endfor
+%!      [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit, M);
+%!      printf('BLOCK JACOBI preconditioned system condition number estimate is %g\n', eigest(2) / eigest(1));
+%!      semilogy ([0:iter], resvec(:,1),'o-b');
 %!      legend('NO preconditioning: absolute residual', ...
 %!             'JACOBI preconditioner: absolute residual', ...
 %!             'BLOCK JACOBI preconditioner: absolute residual');
-%!	hold off;
+%!      hold off;
 %!test
 %!
-%!	#solve small diagonal system
+%!      #solve small diagonal system
 %!
-%!	N = 10; 
-%!	A = diag ([1:N]); b = rand (N, 1); X = A \ b; #X is the true solution
-%!  	[x, flag] = pcg (A, b, [], N+1);
-%!	assert(norm (x - X) / norm (X), 0, 1e-10);
-%!	assert(flag, 0);
+%!      N = 10; 
+%!      A = diag ([1:N]); b = rand (N, 1); X = A \ b; #X is the true solution
+%!      [x, flag] = pcg (A, b, [], N+1);
+%!      assert(norm (x - X) / norm (X), 0, 1e-10);
+%!      assert(flag, 0);
 %!
 %!test
 %!
-%!	#solve small indefinite diagonal system
-%!	#despite A is indefinite, the iteration continues and converges
-%!	#indefiniteness of A is detected
+%!      #solve small indefinite diagonal system
+%!      #despite A is indefinite, the iteration continues and converges
+%!      #indefiniteness of A is detected
 %!
-%!	N = 10; 
-%!	A = diag([1:N] .* (-ones(1, N) .^ 2)); b = rand (N, 1); X = A \ b; #X is the true solution
-%!  	[x, flag] = pcg (A, b, [], N+1);
-%!	assert(norm (x - X) / norm (X), 0, 1e-10);
-%!	assert(flag, 3);
+%!      N = 10; 
+%!      A = diag([1:N] .* (-ones(1, N) .^ 2)); b = rand (N, 1); X = A \ b; #X is the true solution
+%!      [x, flag] = pcg (A, b, [], N+1);
+%!      assert(norm (x - X) / norm (X), 0, 1e-10);
+%!      assert(flag, 3);
 %!
 %!test
 %!
-%!	#solve tridiagonal system, do not converge in default 20 iterations
+%!      #solve tridiagonal system, do not converge in default 20 iterations
 %!
-%!	N = 100; 
-%!	A = zeros (N, N);
-%!	for i = 1 : N - 1 # form 1-D Laplacian matrix
-%!		A (i:i+1, i:i+1) = [2 -1; -1 2];
-%!	endfor
-%!	b = ones (N, 1); X = A \ b; #X is the true solution
-%!  	[x, flag, relres, iter, resvec, eigest] = pcg (A, b, 1e-12);
-%!	assert(flag);
-%!	assert(relres > 1.0);
-%!	assert(iter, 20); #should perform max allowable default number of iterations
+%!      N = 100; 
+%!      A = zeros (N, N);
+%!      for i = 1 : N - 1 # form 1-D Laplacian matrix
+%!              A (i:i+1, i:i+1) = [2 -1; -1 2];
+%!      endfor
+%!      b = ones (N, 1); X = A \ b; #X is the true solution
+%!      [x, flag, relres, iter, resvec, eigest] = pcg (A, b, 1e-12);
+%!      assert(flag);
+%!      assert(relres > 1.0);
+%!      assert(iter, 20); #should perform max allowable default number of iterations
 %!
 %!test
 %!
-%!	#solve tridiagonal system with 'prefect' preconditioner
-%!	#converges in one iteration, so the eigest does not work
-%!	#and issues a warning
+%!      #solve tridiagonal system with 'prefect' preconditioner
+%!      #converges in one iteration, so the eigest does not work
+%!      #and issues a warning
 %!
-%!	N = 100; 
-%!	A = zeros (N, N);
-%!	for i = 1 : N - 1 # form 1-D Laplacian matrix
-%!		A (i:i+1, i:i+1) = [2 -1; -1 2];
-%!	endfor
-%!	b = ones (N, 1); X = A \ b; #X is the true solution
-%!  	[x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], [], A, [], b);
-%!	assert(norm (x - X) / norm (X), 0, 1e-6);
-%!	assert(flag, 0);
-%!	assert(iter, 1); #should converge in one iteration
-%!	assert(isnan (eigest), isnan ([NaN, NaN]));
+%!      N = 100; 
+%!      A = zeros (N, N);
+%!      for i = 1 : N - 1 # form 1-D Laplacian matrix
+%!              A (i:i+1, i:i+1) = [2 -1; -1 2];
+%!      endfor
+%!      b = ones (N, 1); X = A \ b; #X is the true solution
+%!      [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], [], A, [], b);
+%!      assert(norm (x - X) / norm (X), 0, 1e-6);
+%!      assert(flag, 0);
+%!      assert(iter, 1); #should converge in one iteration
+%!      assert(isnan (eigest), isnan ([NaN, NaN]));
 %!
diff --git a/scripts/sparse/pcr.m b/scripts/sparse/pcr.m
--- a/scripts/sparse/pcr.m
+++ b/scripts/sparse/pcr.m
@@ -95,19 +95,19 @@
 ## 1,2, @dots{}, @var{iter}+1}.
 ## @end itemize
 ## 
 ## Let us consider a trivial problem with a diagonal matrix (we exploit the
 ## sparsity of A) 
 ## 
 ## @example
 ## @group
-## 	n = 10; 
-## 	a = sparse (diag (1:n));
-## 	b = rand (N, 1);
+##      n = 10; 
+##      a = sparse (diag (1:n));
+##      b = rand (N, 1);
 ## @end group
 ## @end example
 ## 
 ## @sc{Example 1:} Simplest use of @code{pcr}
 ## 
 ## @example
 ##   x = pcr(A, b)
 ## @end example
@@ -126,47 +126,47 @@
 ## @end example
 ## 
 ## @sc{Example 3:}  Preconditioned iteration, with full diagnostics.  The
 ## preconditioner (quite strange, because even the original matrix
 ## @var{a} is trivial) is defined as a function
 ## 
 ## @example
 ## @group
-##   function y = apply_m (x)		
+##   function y = apply_m (x)           
 ##     k = floor (length(x)-2); 
 ##     y = x; 
-##     y(1:k) = x(1:k)./[1:k]';	
+##     y(1:k) = x(1:k)./[1:k]'; 
 ##   endfunction
 ## 
 ##   [x, flag, relres, iter, resvec] = ...
 ##                      pcr (a, b, [], [], "apply_m")
 ##   semilogy([1:iter+1], resvec);
 ## @end group
 ## @end example
 ##
 ## @sc{Example 4:} Finally, a preconditioner which depends on a
 ## parameter @var{k}.
 ## 
 ## @example
 ## @group
 ##   function y = apply_m (x, varargin)
 ##     k = varargin@{1@}; 
-##     y = x; y(1:k) = x(1:k)./[1:k]';	 
+##     y = x; y(1:k) = x(1:k)./[1:k]';   
 ##   endfunction
 ## 
 ##   [x, flag, relres, iter, resvec] = ...
 ##                      pcr (a, b, [], [], "apply_m"', [], 3)
 ## @end group
 ## @end example
 ## 
 ## @sc{References}
 ## 
-## 	[1] W. Hackbusch, "Iterative Solution of Large Sparse Systems of
-##  	Equations", section 9.5.4; Springer, 1994
+##      [1] W. Hackbusch, "Iterative Solution of Large Sparse Systems of
+##      Equations", section 9.5.4; Springer, 1994
 ##
 ## @seealso{sparse, pcg}
 ## @end deftypefn
 
 ## Author: Piotr Krzyzanowski <piotr.krzyzanowski@mimuw.edu.pl>
 
 function [x, flag, relres, iter, resvec] = pcr (a, b, tol, maxit, m, x0, varargin)
 
@@ -192,239 +192,239 @@ function [x, flag, relres, iter, resvec]
     tol = 1e-6;
   endif
 
   if (nargin < 2)
     print_usage ();
   endif
 
   ##  init
-  if (isnumeric (a))		# is A a matrix?
+  if (isnumeric (a))            # is A a matrix?
     r = b - a*x;
-  else				# then A should be a function!
+  else                          # then A should be a function!
     r = b - feval (a, x, varargin{:});
   endif
 
-  if (isnumeric (m))		# is M a matrix?
-    if (isempty (m))		# if M is empty, use no precond
+  if (isnumeric (m))            # is M a matrix?
+    if (isempty (m))            # if M is empty, use no precond
       p = r;
-    else			# otherwise, apply the precond
+    else                        # otherwise, apply the precond
       p = m \ r;
     endif
-  else				# then M should be a function!
+  else                          # then M should be a function!
     p = feval (m, r, varargin{:});
   endif
 
   iter = 2;
 
   b_bot_old = 1;
   q_old = p_old = s_old = zeros (size (x));
 
-  if (isnumeric (a))		# is A a matrix?
+  if (isnumeric (a))            # is A a matrix?
     q = a * p;
-  else				# then A should be a function!
+  else                          # then A should be a function!
     q = feval (a, p, varargin{:});
   endif
-	
+        
   resvec(1) = abs (norm (r)); 
 
   ## iteration
   while (resvec(iter-1) > tol*resvec(1) && iter < maxit)
 
-    if (isnumeric (m))		# is M a matrix?
-      if (isempty (m))		# if M is empty, use no precond
-	s = q;
-      else			# otherwise, apply the precond
-	s = m \ q;
+    if (isnumeric (m))          # is M a matrix?
+      if (isempty (m))          # if M is empty, use no precond
+        s = q;
+      else                      # otherwise, apply the precond
+        s = m \ q;
       endif
-    else			# then M should be a function!
+    else                        # then M should be a function!
       s = feval (m, q, varargin{:});
     endif
     b_top = r' * s;
     b_bot = q' * s;
-	
+        
     if (b_bot == 0.0)
       breakdown = true;
       break;
     endif
     lambda = b_top / b_bot;
-	
+        
     x += lambda*p;
     r -= lambda*q;
-	
-    if (isnumeric(a))		# is A a matrix?
+        
+    if (isnumeric(a))           # is A a matrix?
       t = a*s;
-    else			# then A should be a function!
+    else                        # then A should be a function!
       t = feval (a, s, varargin{:});
     endif
-	
+        
     alpha0 = (t'*s) / b_bot;
     alpha1 = (t'*s_old) / b_bot_old;
-	
+        
     p_temp = p;
     q_temp = q;
 
     p = s - alpha0*p - alpha1*p_old;
     q = t - alpha0*q - alpha1*q_old;
-	
+        
     s_old = s;
     p_old = p_temp;
     q_old = q_temp;
     b_bot_old = b_bot;
-	
+        
     resvec(iter) = abs (norm (r));
     iter++;
   endwhile
 
   flag = 0;
   relres = resvec(iter-1) ./ resvec(1);
   iter -= 2;
   if (iter >= maxit-2)
     flag = 1;
     if (nargout < 2)
       warning ("pcr: maximum number of iterations (%d) reached\n", iter);
       warning ("the initial residual norm was reduced %g times.\n", 1.0/relres);
     endif
   elseif (nargout < 2 && ! breakdown)
     fprintf (stderr, "pcr: converged in %d iterations. \n", iter);
     fprintf (stderr, "the initial residual norm was reduced %g times.\n",
-	     1.0 / relres);
+             1.0 / relres);
   endif
 
   if (breakdown)
     flag = 3;
     if (nargout < 2)
       warning ("pcr: breakdown occurred:\n");
       warning ("system matrix singular or preconditioner indefinite?\n");
     endif
   endif
 
 endfunction
 
 %!demo
 %!
-%!	# Simplest usage of PCR (see also 'help pcr')
+%!      # Simplest usage of PCR (see also 'help pcr')
 %!
-%!	N = 20; 
-%!	A = diag(linspace(-3.1,3,N)); b = rand(N,1); y = A\b; #y is the true solution
-%!  	x = pcr(A,b);
-%!	printf('The solution relative error is %g\n', norm(x-y)/norm(y));
+%!      N = 20; 
+%!      A = diag(linspace(-3.1,3,N)); b = rand(N,1); y = A\b; #y is the true solution
+%!      x = pcr(A,b);
+%!      printf('The solution relative error is %g\n', norm(x-y)/norm(y));
 %!
-%!	# You shouldn't be afraid if PCR issues some warning messages in this
-%!	# example: watch out in the second example, why it takes N iterations 
-%!	# of PCR to converge to (a very accurate, by the way) solution
+%!      # You shouldn't be afraid if PCR issues some warning messages in this
+%!      # example: watch out in the second example, why it takes N iterations 
+%!      # of PCR to converge to (a very accurate, by the way) solution
 %!demo
 %!
-%!	# Full output from PCR
-%!	# We use this output to plot the convergence history  
+%!      # Full output from PCR
+%!      # We use this output to plot the convergence history  
 %!
-%!	N = 20; 
-%!	A = diag(linspace(-3.1,30,N)); b = rand(N,1); X = A\b; #X is the true solution
-%!  	[x, flag, relres, iter, resvec] = pcr(A,b);
-%!	printf('The solution relative error is %g\n', norm(x-X)/norm(X));
-%!	title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||/||b||)');
-%!	semilogy([0:iter],resvec/resvec(1),'o-g;relative residual;');
+%!      N = 20; 
+%!      A = diag(linspace(-3.1,30,N)); b = rand(N,1); X = A\b; #X is the true solution
+%!      [x, flag, relres, iter, resvec] = pcr(A,b);
+%!      printf('The solution relative error is %g\n', norm(x-X)/norm(X));
+%!      title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||/||b||)');
+%!      semilogy([0:iter],resvec/resvec(1),'o-g;relative residual;');
 %!demo
 %!
-%!	# Full output from PCR
-%!	# We use indefinite matrix based on the Hilbert matrix, with one
-%!	# strongly negative eigenvalue
-%!	# Hilbert matrix is extremely ill conditioned, so is ours, 
-%!	# and that's why PCR WILL have problems
+%!      # Full output from PCR
+%!      # We use indefinite matrix based on the Hilbert matrix, with one
+%!      # strongly negative eigenvalue
+%!      # Hilbert matrix is extremely ill conditioned, so is ours, 
+%!      # and that's why PCR WILL have problems
 %!
-%!	N = 10; 
-%!	A = hilb(N); A(1,1)=-A(1,1); b = rand(N,1); X = A\b; #X is the true solution
-%!	printf('Condition number of A is   %g\n', cond(A));
-%!  	[x, flag, relres, iter, resvec] = pcr(A,b,[],200);
-%!	if (flag == 3)
-%!	  printf('PCR breakdown. System matrix is [close to] singular\n');
-%!	end
-%!	title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||)');
-%!	semilogy([0:iter],resvec,'o-g;absolute residual;');
+%!      N = 10; 
+%!      A = hilb(N); A(1,1)=-A(1,1); b = rand(N,1); X = A\b; #X is the true solution
+%!      printf('Condition number of A is   %g\n', cond(A));
+%!      [x, flag, relres, iter, resvec] = pcr(A,b,[],200);
+%!      if (flag == 3)
+%!        printf('PCR breakdown. System matrix is [close to] singular\n');
+%!      end
+%!      title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||)');
+%!      semilogy([0:iter],resvec,'o-g;absolute residual;');
 %!demo
 %!
-%!	# Full output from PCR
-%!	# We use an indefinite matrix based on the 1-D Laplacian matrix for A, 
-%!	# and here we have cond(A) = O(N^2)
-%!	# That's the reason we need some preconditioner; here we take
-%!	# a very simple and not powerful Jacobi preconditioner, 
-%!	# which is the diagonal of A
+%!      # Full output from PCR
+%!      # We use an indefinite matrix based on the 1-D Laplacian matrix for A, 
+%!      # and here we have cond(A) = O(N^2)
+%!      # That's the reason we need some preconditioner; here we take
+%!      # a very simple and not powerful Jacobi preconditioner, 
+%!      # which is the diagonal of A
 %!
-%!	# Note that we use here indefinite preconditioners!
+%!      # Note that we use here indefinite preconditioners!
 %!
-%!	N = 100; 
-%!	A = zeros(N,N);
-%!	for i=1:N-1 # form 1-D Laplacian matrix
-%!		A(i:i+1,i:i+1) = [2 -1; -1 2];
-%!	endfor
-%!	A = [A, zeros(size(A)); zeros(size(A)), -A];
-%!	b = rand(2*N,1); X = A\b; #X is the true solution
-%!	maxit = 80;
-%!	printf('System condition number is %g\n',cond(A));
-%!	# No preconditioner: the convergence is very slow!
+%!      N = 100; 
+%!      A = zeros(N,N);
+%!      for i=1:N-1 # form 1-D Laplacian matrix
+%!              A(i:i+1,i:i+1) = [2 -1; -1 2];
+%!      endfor
+%!      A = [A, zeros(size(A)); zeros(size(A)), -A];
+%!      b = rand(2*N,1); X = A\b; #X is the true solution
+%!      maxit = 80;
+%!      printf('System condition number is %g\n',cond(A));
+%!      # No preconditioner: the convergence is very slow!
 %!
-%!  	[x, flag, relres, iter, resvec] = pcr(A,b,[],maxit);
-%!	title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||)');
-%!	semilogy([0:iter],resvec,'o-g;NO preconditioning: absolute residual;');
+%!      [x, flag, relres, iter, resvec] = pcr(A,b,[],maxit);
+%!      title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||)');
+%!      semilogy([0:iter],resvec,'o-g;NO preconditioning: absolute residual;');
 %!
-%!	pause(1);
-%!	# Test Jacobi preconditioner: it will not help much!!!
+%!      pause(1);
+%!      # Test Jacobi preconditioner: it will not help much!!!
 %!
-%!	M = diag(diag(A)); # Jacobi preconditioner
-%!  	[x, flag, relres, iter, resvec] = pcr(A,b,[],maxit,M);
-%!	hold on;
-%!	semilogy([0:iter],resvec,'o-r;JACOBI preconditioner: absolute residual;');
+%!      M = diag(diag(A)); # Jacobi preconditioner
+%!      [x, flag, relres, iter, resvec] = pcr(A,b,[],maxit,M);
+%!      hold on;
+%!      semilogy([0:iter],resvec,'o-r;JACOBI preconditioner: absolute residual;');
 %!
-%!	pause(1);
-%!	# Test nonoverlapping block Jacobi preconditioner: this one should give
-%!	# some convergence speedup!
+%!      pause(1);
+%!      # Test nonoverlapping block Jacobi preconditioner: this one should give
+%!      # some convergence speedup!
 %!
-%!	M = zeros(N,N);k=4;
-%!	for i=1:k:N # get k x k diagonal blocks of A
-%!		M(i:i+k-1,i:i+k-1) = A(i:i+k-1,i:i+k-1);
-%!	endfor
-%!	M = [M, zeros(size(M)); zeros(size(M)), -M];
-%!  	[x, flag, relres, iter, resvec] = pcr(A,b,[],maxit,M);
-%!	semilogy([0:iter],resvec,'o-b;BLOCK JACOBI preconditioner: absolute residual;');
-%!	hold off;
+%!      M = zeros(N,N);k=4;
+%!      for i=1:k:N # get k x k diagonal blocks of A
+%!              M(i:i+k-1,i:i+k-1) = A(i:i+k-1,i:i+k-1);
+%!      endfor
+%!      M = [M, zeros(size(M)); zeros(size(M)), -M];
+%!      [x, flag, relres, iter, resvec] = pcr(A,b,[],maxit,M);
+%!      semilogy([0:iter],resvec,'o-b;BLOCK JACOBI preconditioner: absolute residual;');
+%!      hold off;
 %!test
 %!
-%!	#solve small indefinite diagonal system
+%!      #solve small indefinite diagonal system
 %!
-%!	N = 10; 
-%!	A = diag(linspace(-10.1,10,N)); b = ones(N,1); X = A\b; #X is the true solution
-%!  	[x, flag] = pcr(A,b,[],N+1);
-%!	assert(norm(x-X)/norm(X)<1e-10);
-%!	assert(flag,0);
+%!      N = 10; 
+%!      A = diag(linspace(-10.1,10,N)); b = ones(N,1); X = A\b; #X is the true solution
+%!      [x, flag] = pcr(A,b,[],N+1);
+%!      assert(norm(x-X)/norm(X)<1e-10);
+%!      assert(flag,0);
 %!
 %!test
 %!
-%!	#solve tridiagonal system, do not converge in default 20 iterations
-%!	#should perform max allowable default number of iterations
+%!      #solve tridiagonal system, do not converge in default 20 iterations
+%!      #should perform max allowable default number of iterations
 %!
-%!	N = 100; 
-%!	A = zeros(N,N);
-%!	for i=1:N-1 # form 1-D Laplacian matrix
-%!		A(i:i+1,i:i+1) = [2 -1; -1 2];
-%!	endfor
-%!	b = ones(N,1); X = A\b; #X is the true solution
-%!  	[x, flag, relres, iter, resvec] = pcr(A,b,1e-12);
-%!	assert(flag,1);
-%!	assert(relres>0.6);
-%!	assert(iter,20);
+%!      N = 100; 
+%!      A = zeros(N,N);
+%!      for i=1:N-1 # form 1-D Laplacian matrix
+%!              A(i:i+1,i:i+1) = [2 -1; -1 2];
+%!      endfor
+%!      b = ones(N,1); X = A\b; #X is the true solution
+%!      [x, flag, relres, iter, resvec] = pcr(A,b,1e-12);
+%!      assert(flag,1);
+%!      assert(relres>0.6);
+%!      assert(iter,20);
 %!
 %!test
 %!
-%!	#solve tridiagonal system with 'prefect' preconditioner
-%!	#converges in one iteration
+%!      #solve tridiagonal system with 'prefect' preconditioner
+%!      #converges in one iteration
 %!
-%!	N = 100; 
-%!	A = zeros(N,N);
-%!	for i=1:N-1 # form 1-D Laplacian matrix
-%!		A(i:i+1,i:i+1) = [2 -1; -1 2];
-%!	endfor
-%!	b = ones(N,1); X = A\b; #X is the true solution
-%!  	[x, flag, relres, iter] = pcr(A,b,[],[],A,b);
-%!	assert(norm(x-X)/norm(X)<1e-6);
-%!	assert(relres<1e-6);
-%!	assert(flag,0);
-%!	assert(iter,1); #should converge in one iteration
+%!      N = 100; 
+%!      A = zeros(N,N);
+%!      for i=1:N-1 # form 1-D Laplacian matrix
+%!              A(i:i+1,i:i+1) = [2 -1; -1 2];
+%!      endfor
+%!      b = ones(N,1); X = A\b; #X is the true solution
+%!      [x, flag, relres, iter] = pcr(A,b,[],[],A,b);
+%!      assert(norm(x-X)/norm(X)<1e-6);
+%!      assert(relres<1e-6);
+%!      assert(flag,0);
+%!      assert(iter,1); #should converge in one iteration
 %!
diff --git a/scripts/sparse/spaugment.m b/scripts/sparse/spaugment.m
--- a/scripts/sparse/spaugment.m
+++ b/scripts/sparse/spaugment.m
@@ -73,19 +73,19 @@
 ## @end deftypefn
 
 function s = spaugment (a, c)
   if (nargin < 2)
     if (issparse (a))
       c = max (max (abs (a))) / 1000;
     else
       if (ndims (a) != 2)
-	error ("spaugment: expecting 2-dimenisional matrix")
+        error ("spaugment: expecting 2-dimenisional matrix")
       else
-	c = max (abs (a(:))) / 1000;
+        c = max (abs (a(:))) / 1000;
       endif
     endif
   elseif (!isscalar (c))
     error ("spaugment: c must be a scalar");
   endif
 
   [m, n] = size (a);
   s = [ c * speye(m, m), a; a', sparse(n, n)];
diff --git a/scripts/sparse/spconvert.m b/scripts/sparse/spconvert.m
--- a/scripts/sparse/spconvert.m
+++ b/scripts/sparse/spconvert.m
@@ -28,17 +28,17 @@
 
 function s = spconvert (m)
 
   if (issparse (m))
     s = m;
   else
     sz = size (m);
     if (nargin != 1 || ! ismatrix (m) || ! isreal (m)
-	|| length (sz) != 2 || (sz(2) != 3 && sz(2) != 4))
+        || length (sz) != 2 || (sz(2) != 3 && sz(2) != 4))
       error ("spconvert: argument must be sparse or real matrix with 3 or 4 columns");
     elseif (sz(2) == 3)
       s = sparse (m(:,1), m(:,2), m(:,3));
     else
       s = sparse (m(:,1), m(:,2), m(:,3) + 1i*m(:,4));
     endif
   endif
 
diff --git a/scripts/sparse/sprand.m b/scripts/sparse/sprand.m
--- a/scripts/sparse/sprand.m
+++ b/scripts/sparse/sprand.m
@@ -35,18 +35,18 @@
 ## @seealso{sprandn}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 ##
 ## Changelog:
 ##
 ## Piotr Krzyzanowski <przykry2004@users.sf.net>
-## 	2004-09-27	use Paul's hint to allow larger random matrices
-##			at the price of sometimes lower density than desired
+##      2004-09-27      use Paul's hint to allow larger random matrices
+##                      at the price of sometimes lower density than desired
 ## David Bateman 
 ##      2004-10-20      Texinfo help and copyright message 
 
 function S = sprand (m, n, d)
   if (nargin == 1)
     [i, j, v] = find (m);
     [nr, nc] = size (m);
     S = sparse (i, j, rand (size (v)), nr, nc);
diff --git a/scripts/sparse/sprandsym.m b/scripts/sparse/sprandsym.m
--- a/scripts/sparse/sprandsym.m
+++ b/scripts/sparse/sprandsym.m
@@ -63,15 +63,15 @@ function S = sprandsym (n, d)
     j2 = floor ((idx2(1:k2)-1)/n2);
     i2 = idx2(1:k2) - j2*n2;
 
     if (isempty (i1) && isempty (i2))
       S = sparse (n, n);
     else
       S1 = sparse (i1, j1+1, randn (k1, 1), m1, n1);
       S = [tril(S1), sparse(m1,m1); ...
-	   sparse(i2,j2+1,randn(k2,1),n2,n2), triu(S1,1)'];
+           sparse(i2,j2+1,randn(k2,1),n2,n2), triu(S1,1)'];
       S = S + tril (S, -1)';
     endif
   else
     print_usage ();
   endif
 endfunction
diff --git a/scripts/sparse/svds.m b/scripts/sparse/svds.m
--- a/scripts/sparse/svds.m
+++ b/scripts/sparse/svds.m
@@ -137,20 +137,20 @@ function [u, s, v, flag] = svds (a, k, s
 
     if (!ischar (b_sigma) && b_sigma == 0)
       ## The eigenvalues returns by eigs are symmetric about 0. As we 
       ## are only interested in the positive eigenvalues, we have to
       ## double k. If sigma is smaller than the smallest singular value
       ## this can also be an issue. However, we'd like to avoid double
       ## k for all scalar value of sigma...
       [V, s, flag] = eigs ([sparse(m,m), b; b', sparse(n,n)], 
-			   2 * k, b_sigma, b_opts);
+                           2 * k, b_sigma, b_opts);
     else
       [V, s, flag] = eigs ([sparse(m,m), b; b', sparse(n,n)],
-			   k, b_sigma, b_opts);
+                           k, b_sigma, b_opts);
     endif
     s = diag (s);
 
     if (ischar (sigma))
       norma = max (s);
     else
       norma = normest (a);
     endif
@@ -179,17 +179,17 @@ function [u, s, v, flag] = svds (a, k, s
     endif
     u = u(:,ind);
     s = s(ind);
     v = v(:,ind);
 
     if (length (s) < k)
       warning ("returning fewer singular values than requested");
       if (!ischar (sigma))
-	warning ("try increasing the value of sigma");
+        warning ("try increasing the value of sigma");
       endif
     endif
 
     s = s * max_a;
   endif
 
   if (nargout < 2)
     u = s;
diff --git a/scripts/sparse/treelayout.m b/scripts/sparse/treelayout.m
--- a/scripts/sparse/treelayout.m
+++ b/scripts/sparse/treelayout.m
@@ -39,42 +39,42 @@ function [x_coordinate, y_coordinate, he
     ## The count of nodes of the graph.
     num_nodes = length (tree);
     ## The number of children.
     num_children = zeros (1, num_nodes + 1);
 
     ## Checking vector of predecessors.
     for i = 1 : num_nodes
       if (tree(i) < i)
-	## This part of graph was checked before.
+        ## This part of graph was checked before.
         continue;
       endif
 
       ## Try to find cicle in this part of graph using modified Floyd's
       ## cycle-finding algorithm.
       tortoise = tree(i);
       hare = tree(tortoise);
 
       while (tortoise != hare)
-	## End after finding a cicle or reaching a checked part of graph.
+        ## End after finding a cicle or reaching a checked part of graph.
 
         if (hare < i)
           ## This part of graph was checked before.
           break
         endif
 
         tortoise = tree(tortoise);
-	## Hare will move faster than tortoise so in cicle hare must
-	## reach tortoise.
+        ## Hare will move faster than tortoise so in cicle hare must
+        ## reach tortoise.
         hare = tree(tree(hare));
 
       endwhile
 
       if (tortoise == hare)
-	## If hare reach tortoise we found circle.
+        ## If hare reach tortoise we found circle.
         error ("treelayout: vector of predecessors has bad format");
       endif
 
     endfor
     ## Vector of predecessors has right format.
 
     for i = 1:num_nodes
       ## vec_of_child is helping vector which is used to speed up the
@@ -146,46 +146,46 @@ function [x_coordinate, y_coordinate, he
         top_level = 0;
       endif
       ## If there is not any descendant of "parent node":
       if (stk(end,2) != par_number)
        left_most++;
        x_coordinate_r(par_number) = left_most;           
        max_ht = min (max_ht, level);
        if (length(stk) > 1 && find ((shift(stk,1)-stk) == 0) > 1
-	   && stk(end,2) != stk(end-1,2))
-	  ## Return to the nearest branching the position to return
-	  ## position is the position on the stack, where should be
+           && stk(end,2) != stk(end-1,2))
+          ## Return to the nearest branching the position to return
+          ## position is the position on the stack, where should be
           ## started further search (there are two nodes which has the
           ## same parent node).
 
           position = (find ((shift (stk(:,2), 1) - stk(:,2)) == 0))(end) + 1;
           par_number_vec = stk(position:end,2);
 
           ## The vector of removed nodes (the content of stack form
           ## position to end).
 
           level += length (par_number_vec);
 
-	  ## The level have to be decreased.
+          ## The level have to be decreased.
 
           x_coordinate_r(par_number_vec) = left_most;
           stk(position:end,:) = [];
-        endif	
+        endif   
 
         ## Remove the next node from "searched branch".
 
         stk(end,:) = [];
-	## Choose new "parent node".
+        ## Choose new "parent node".
         par_number = stk(end,1);
-	## If there is another branch start to search it.
-	if (par_number != -1)
-          y_coordinate(par_number) = level;	
+        ## If there is another branch start to search it.
+        if (par_number != -1)
+          y_coordinate(par_number) = level;     
           x_coordinate_l(par_number) = left_most + 1;
-	endif
+        endif
       else
 
         ## There were descendants of "parent nod" choose the last of
         ## them and go on through it.
         level--;
         par_number = stk(end,1);
         y_coordinate(par_number) = level;     
         x_coordinate_l(par_number) = left_most + 1;
diff --git a/scripts/sparse/treeplot.m b/scripts/sparse/treeplot.m
--- a/scripts/sparse/treeplot.m
+++ b/scripts/sparse/treeplot.m
@@ -36,23 +36,23 @@ function treeplot (tree, node_s, edge_s)
       error ("treeplot: the first input argument must be a vector of predecessors");
     else
       ## The initialization of node end edge style.
       node_style = "k*";
       edge_style = "r";      
       if (nargin > 2)
         edge_style = edge_s;
         if (nargin > 1) 
-	  if (length (findstr (node_s, "*")) == 0
-	      && length (findstr (node_s, "+")) == 0
-	      && length (findstr (node_s, "x")) == 0)
-	    node_style = [node_s, "o"];
-	  else
-	    node_style = node_s;
-	  endif
+          if (length (findstr (node_s, "*")) == 0
+              && length (findstr (node_s, "+")) == 0
+              && length (findstr (node_s, "x")) == 0)
+            node_style = [node_s, "o"];
+          else
+            node_style = node_s;
+          endif
         endif
       endif
 
       ## Make it a row vector.
       tree = tree(:)';
 
       ## The count of nodes of the graph.
       num_nodes = length (tree);
@@ -67,23 +67,23 @@ function treeplot (tree, node_s, edge_s)
         num_children(tree(i)+1) = num_children(tree(i)+1) + 1;
       endfor
       pos = 1;
       start = zeros (1, num_nodes+1);
       xhelp = zeros (1, num_nodes+1);
       stop = zeros (1, num_nodes+1);
       for i = 1:num_nodes+1
         start(i) = pos;
-	xhelp(i) = pos;
-	pos += num_children(i);
-	stop(i) = pos;
+        xhelp(i) = pos;
+        pos += num_children(i);
+        stop(i) = pos;
       endfor
       for i = 1:num_nodes        
         vec_of_child(xhelp(tree(i)+1)) = i;  
-	xhelp(tree(i)+1) = xhelp(tree(i)+1)+1;
+        xhelp(tree(i)+1) = xhelp(tree(i)+1)+1;
       endfor
 
       ## The number of "parent" (actual) node (it's descendants will be
       ## browse in the next iteration).
       par_number = 0;
 
       ## The x-coordinate of the left most descendant of "parent node"
       ## this value is increased in each leaf.
@@ -101,110 +101,110 @@ function treeplot (tree, node_s, edge_s)
       stk = [-1, 0];
 
       ## Stack which is use to draw the graph edge (it have to be
       ## uninterupted line).
       skelet = 0;
 
       ## The top of the stack.
       while (par_number != -1)
-	if (start(par_number+1) < stop(par_number+1))
-	  idx = vec_of_child(start(par_number+1):stop(par_number+1)-1);
-	else
-	  idx = zeros (1, 0);
-	endif
+        if (start(par_number+1) < stop(par_number+1))
+          idx = vec_of_child(start(par_number+1):stop(par_number+1)-1);
+        else
+          idx = zeros (1, 0);
+        endif
         ## Add to idx the vector of parent descendants.
-	stk = [stk; [idx', ones(fliplr(size(idx)))*par_number]];
-	## Add to stack the records relevant to parent descandant s.
-	if (par_number != 0)
-	  skelet = [skelet; ([ones(size(idx))*par_number; idx])(:)];
-	endif
+        stk = [stk; [idx', ones(fliplr(size(idx)))*par_number]];
+        ## Add to stack the records relevant to parent descandant s.
+        if (par_number != 0)
+          skelet = [skelet; ([ones(size(idx))*par_number; idx])(:)];
+        endif
 
-	## If there is not any descendant of "parent node":
-	if (stk(end,2) != par_number)
-	  left_most++;
+        ## If there is not any descendant of "parent node":
+        if (stk(end,2) != par_number)
+          left_most++;
           x_coordinate_r(par_number) = left_most;           
-	  max_ht = min (max_ht, level);
+          max_ht = min (max_ht, level);
           if (length(stk) > 1 && find ((shift(stk,1)-stk) == 0) > 1
-	      && stk(end,2) != stk(end-1,2))
-	    ## Return to the nearest branching the position to return
-	    ## position is the position on the stack, where should be
-	    ## started further search (there are two nodes which has the
-	    ## same parent node).
+              && stk(end,2) != stk(end-1,2))
+            ## Return to the nearest branching the position to return
+            ## position is the position on the stack, where should be
+            ## started further search (there are two nodes which has the
+            ## same parent node).
             position = (find ((shift(stk(:,2),1)-stk(:,2)) == 0))(end) + 1;
             par_number_vec = stk(position:end,2);
             ## The vector of removed nodes (the content of stack form
-	    ## position to end).
+            ## position to end).
             skelet = [skelet; flipud(par_number_vec)];
             level += length (par_number_vec);
-	    ## The level have to be decreased.
+            ## The level have to be decreased.
             x_coordinate_r(par_number_vec) = left_most;
             stk(position:end,:) = [];
-          endif	
-       	  ## Remove the next node from "searched branch".
-	  stk(end,:) = [];
-	  ## Choose new "parent node".
+          endif 
+          ## Remove the next node from "searched branch".
+          stk(end,:) = [];
+          ## Choose new "parent node".
           par_number = stk(end,1);
-	  ## If there is another branch start to search it.
-	  if (par_number != -1)
-	    skelet = [skelet; stk(end,2); par_number];
-            y_coordinate(par_number) = level;	
-	    x_coordinate_l(par_number) = left_most + 1;
-	  endif
-	else
+          ## If there is another branch start to search it.
+          if (par_number != -1)
+            skelet = [skelet; stk(end,2); par_number];
+            y_coordinate(par_number) = level;   
+            x_coordinate_l(par_number) = left_most + 1;
+          endif
+        else
           ## There were descendants of "parent nod" choose the last of
-	  ## them and go on through it.
+          ## them and go on through it.
           level--;
-	  par_number = stk(end,1);
-	  y_coordinate(par_number) = level;     
-	  x_coordinate_l(par_number) = left_most + 1;
-	endif
+          par_number = stk(end,1);
+          y_coordinate(par_number) = level;     
+          x_coordinate_l(par_number) = left_most + 1;
+        endif
       endwhile
 
       ## Calculate the x coordinates (the known values are the position
       ## of most left and most right descendants).
       x_coordinate = (x_coordinate_l + x_coordinate_r) / 2;
 
       ## FIXME -- we should probably stuff all the arguments into a cell
       ## array and make a single call to plot here so we can avoid
       ## setting the hold state...
 
       hold_is_on = ishold ();
       unwind_protect
-	hold ("on");
+        hold ("on");
 
-	## Plot grah nodes.
-	plot (x_coordinate, y_coordinate, node_style);
+        ## Plot grah nodes.
+        plot (x_coordinate, y_coordinate, node_style);
 
-	## Helping command - usable for plotting edges
-	skelet = [skelet; 0];
+        ## Helping command - usable for plotting edges
+        skelet = [skelet; 0];
 
-	## Draw graph edges.
-	idx = find (skelet == 0);
+        ## Draw graph edges.
+        idx = find (skelet == 0);
 
-	## Plot each tree component in one loop.
-	for i = 2:length(idx)
-	  ## Tree component start.
-	  istart = idx(i-1) + 1;
-	  ## Tree component end.
-	  istop = idx(i) - 1;
-	  if (istop - istart < 1)                          
-	    continue;
-	  endif
-	  plot (x_coordinate(skelet(istart:istop)),
-		y_coordinate(skelet(istart:istop)), edge_style)
-	endfor
+        ## Plot each tree component in one loop.
+        for i = 2:length(idx)
+          ## Tree component start.
+          istart = idx(i-1) + 1;
+          ## Tree component end.
+          istop = idx(i) - 1;
+          if (istop - istart < 1)                          
+            continue;
+          endif
+          plot (x_coordinate(skelet(istart:istop)),
+                y_coordinate(skelet(istart:istop)), edge_style)
+        endfor
 
-	## Set axis and graph size.
-	axis ([0.5, left_most+0.5, max_ht-0.5, num_nodes-0.5], "nolabel");
+        ## Set axis and graph size.
+        axis ([0.5, left_most+0.5, max_ht-0.5, num_nodes-0.5], "nolabel");
 
       unwind_protect_cleanup
-	if (! hold_is_on)
-	  hold ("off");
-	endif
+        if (! hold_is_on)
+          hold ("off");
+        endif
       end_unwind_protect
       
     endif
   endif
 endfunction
 
 %!demo
 %! % Plot a simple tree plot 
diff --git a/scripts/specfun/nchoosek.m b/scripts/specfun/nchoosek.m
--- a/scripts/specfun/nchoosek.m
+++ b/scripts/specfun/nchoosek.m
@@ -107,18 +107,18 @@ function A = nchoosek (v, k)
     ## alphabetical order.
     for i = 1:k
       p{i} = zeros (0, i, cl);
     endfor
     s = ones (1, 1, cl);
     p{1} = n*s;
     for j = n-1:-1:1
       for i = k:-1:2
-	q = p{i-1};
-	p{i} = [[repmat(s*j, rows (p{i-1}), 1), p{i-1}]; p{i}];
+        q = p{i-1};
+        p{i} = [[repmat(s*j, rows (p{i-1}), 1), p{i-1}]; p{i}];
       endfor
       p{1} = [j;p{1}];
     endfor
     v = v(:);
     A = v(p{k});
   endif
 endfunction
 
diff --git a/scripts/specfun/primes.m b/scripts/specfun/primes.m
--- a/scripts/specfun/primes.m
+++ b/scripts/specfun/primes.m
@@ -78,17 +78,17 @@ function x = primes (p)
     for i = 1:(sqrt(p)-1)/2       # check up to sqrt(p)
       if (sieve(i))               # if i is prime, eliminate multiples of i
         sieve(3*i+1:2*i+1:len) = 0; # do it
       endif
     endfor
     x = [2, 1+2*find(sieve)];     # primes remaining after sieve
   else
     a = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, ...
-	 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, ...
-	 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, ...
-	 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, ...
-	 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, ...
-	 293, 307, 311, 313, 317, 331, 337, 347, 349];
+         53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, ...
+         109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, ...
+         173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, ...
+         233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, ...
+         293, 307, 311, 313, 317, 331, 337, 347, 349];
     x = a(a <= p);
   endif
 
 endfunction
diff --git a/scripts/special-matrix/toeplitz.m b/scripts/special-matrix/toeplitz.m
--- a/scripts/special-matrix/toeplitz.m
+++ b/scripts/special-matrix/toeplitz.m
@@ -95,17 +95,17 @@ function retval = toeplitz (c, r)
     cidx = find(c);
     ridx = find(r);
 
     ## Ignore the first element in r.
     ridx = ridx(ridx > 1);
 
     ## Form matrix.
     retval = spdiags(repmat(c(cidx),nr,1),1-cidx,nr,nc)+...
-	spdiags(repmat(r(ridx),nr,1),ridx-1,nr,nc);
+        spdiags(repmat(r(ridx),nr,1),ridx-1,nr,nc);
   else  
     ## Concatenate data into a single column vector.
     data = [r(end:-1:2)(:); c(:)];
 
     ## Get slices.
     slices = cellslices (data, nc:-1:1, nc+nr-1:-1:nr);
 
     ## Form matrix.
diff --git a/scripts/statistics/base/iqr.m b/scripts/statistics/base/iqr.m
--- a/scripts/statistics/base/iqr.m
+++ b/scripts/statistics/base/iqr.m
@@ -45,18 +45,18 @@ function y = iqr (x, dim)
     while (dim < nd + 1 && sz(dim) == 1)
       dim = dim + 1;
     endwhile
     if (dim > nd)
       dim = 1;
     endif
   else
     if (! (isscalar (dim) && dim == round (dim))
-	&& dim > 0
-	&& dim < (nd + 1))
+        && dim > 0
+        && dim < (nd + 1))
       error ("iqr: dim must be an integer and valid dimension");
     endif
   endif
 
   ## This code is a bit heavy, but is needed until empirical_inv 
   ## takes other than vector arguments.
   c = sz(dim);
   sz(dim) = 1;
diff --git a/scripts/statistics/base/kurtosis.m b/scripts/statistics/base/kurtosis.m
--- a/scripts/statistics/base/kurtosis.m
+++ b/scripts/statistics/base/kurtosis.m
@@ -58,18 +58,18 @@ function retval = kurtosis (x, dim)
     while (dim < nd + 1 && sz(dim) == 1)
       dim = dim + 1;
     endwhile
     if (dim > nd)
       dim = 1;
     endif
   else
     if (! (isscalar (dim) && dim == round (dim))
-	&& dim > 0
-	&& dim < (nd + 1))
+        && dim > 0
+        && dim < (nd + 1))
       error ("kurtosis: dim must be an integer and valid dimension");
     endif
   endif
   
   if (! ismatrix (x))
     error ("kurtosis: x has to be a matrix or a vector");
   endif
 
diff --git a/scripts/statistics/base/qqplot.m b/scripts/statistics/base/qqplot.m
--- a/scripts/statistics/base/qqplot.m
+++ b/scripts/statistics/base/qqplot.m
@@ -73,17 +73,17 @@ function [q, s] = qqplot (x, dist, varar
   else
     q = feval (f, t, varargin{:});
     if (nargin > 3)
       tmp = sprintf (", %g", varargin{2:end});
     else 
       tmp = "";
     endif
     q_label = sprintf ("%s with parameter(s) %g%s", func2str (f),
-		       varargin{1}, tmp);
+                       varargin{1}, tmp);
   endif
 
   if (nargout == 0)
     plot (q, s);
     xlabel (q_label);
     ylabel ("sample points");
   endif
 
diff --git a/scripts/statistics/base/quantile.m b/scripts/statistics/base/quantile.m
--- a/scripts/statistics/base/quantile.m
+++ b/scripts/statistics/base/quantile.m
@@ -314,67 +314,67 @@ function inv = __quantile__ (x, p, metho
 
     ## The column-distribution indices.
     pcd = kron (ones (n, 1), mx*(0:nx-1));
     mm = kron (ones (n, 1), m);
     switch method
       case {1, 2, 3}
         switch method
           case 1
-	    p = max (ceil (kron (p, m)), 1);
-	    inv(k,:) = x(p + pcd);
+            p = max (ceil (kron (p, m)), 1);
+            inv(k,:) = x(p + pcd);
 
           case 2
-	    p = kron (p, m);
-	    p_lr = max (ceil (p), 1);
-	    p_rl = min (floor (p + 1), mm);
-	    inv(k,:) = (x(p_lr + pcd) + x(p_rl + pcd))/2;
+            p = kron (p, m);
+            p_lr = max (ceil (p), 1);
+            p_rl = min (floor (p + 1), mm);
+            inv(k,:) = (x(p_lr + pcd) + x(p_rl + pcd))/2;
 
           case 3
            ## Used by SAS, method PCTLDEF=2.
            ## http://support.sas.com/onlinedoc/913/getDoc/en/statug.hlp/stdize_sect14.htm
-	    t = max (kron (p, m), 1);
-	    t = roundb (t);
-	    inv(k,:) = x(t + pcd);
+            t = max (kron (p, m), 1);
+            t = roundb (t);
+            inv(k,:) = x(t + pcd);
         endswitch
 
       otherwise
         switch method
           case 4
-	    p = kron (p, m);
+            p = kron (p, m);
 
           case 5
             ## Used by Matlab.
-	    p = kron (p, m) + 0.5;
+            p = kron (p, m) + 0.5;
 
           case 6
             ## Used by Minitab and SPSS.
-	    p = kron (p, m+1);
+            p = kron (p, m+1);
 
           case 7
             ## Used by S and R.
-	    p = kron (p, m-1) + 1;
+            p = kron (p, m-1) + 1;
 
           case 8
             ## Median unbiased .
-	    p = kron (p, m+1/3) + 1/3;
+            p = kron (p, m+1/3) + 1/3;
 
           case 9
             ## Approximately unbiased respecting order statistics.
-	    p = kron (p, m+0.25) + 0.375;
+            p = kron (p, m+0.25) + 0.375;
 
           otherwise
             error ("quantile: Unknown method, '%d'", method);
         endswitch
 
-	## Duplicate single values.
-	imm1 = mm == 1;
-	x(2,imm1) = x(1,imm1);
+        ## Duplicate single values.
+        imm1 = mm == 1;
+        x(2,imm1) = x(1,imm1);
 
-	## Interval indices.
-	pi = max (min (floor (p), mm-1), 1);
-	pr = max (min (p - pi, 1), 0);
-	pi += pcd;
-	inv(k,:) = (1-pr) .* x(pi) + pr .* x(pi+1);
+        ## Interval indices.
+        pi = max (min (floor (p), mm-1), 1);
+        pr = max (min (p - pi, 1), 0);
+        pi += pcd;
+        inv(k,:) = (1-pr) .* x(pi) + pr .* x(pi+1);
     endswitch
   endif
 
 endfunction
diff --git a/scripts/statistics/base/ranks.m b/scripts/statistics/base/ranks.m
--- a/scripts/statistics/base/ranks.m
+++ b/scripts/statistics/base/ranks.m
@@ -45,18 +45,18 @@ function y = ranks (x, dim)
     while (dim < nd + 1 && sz(dim) == 1)
       dim = dim + 1;
     endwhile
     if (dim > nd)
       dim = 1;
     endif
   else
     if (! (isscalar (dim) && dim == round (dim))
-	&& dim > 0
-	&& dim < (nd + 1))
+        && dim > 0
+        && dim < (nd + 1))
       error ("ranks: dim must be an integer and valid dimension");
     endif
   endif
 
   if (sz(dim) == 1)
     y = ones(sz);
   else
     ## The algorithm works only on dim = 1, so permute if necesary.
@@ -72,18 +72,18 @@ function y = ranks (x, dim)
     eq_el = find (diff ([xs; infvec]) == 0);
     if (isempty (eq_el))
       [eq_el, y] = sort (xi);
     else
       runs = complement (eq_el+1, eq_el);
       len = diff (find (diff ([Inf; eq_el; -Inf]) != 1)) + 1;
       [eq_el, y] = sort (xi);
       for i = 1 : length(runs)
-	y (xi (runs (i) + [0:(len(i)-1)]) + floor (runs (i) ./ sz(1)) 
-	   * sz(1)) = eq_el(runs(i)) + (len(i) - 1) / 2;
+        y (xi (runs (i) + [0:(len(i)-1)]) + floor (runs (i) ./ sz(1)) 
+           * sz(1)) = eq_el(runs(i)) + (len(i) - 1) / 2;
       endfor
     endif  
     if (dim != 1)
       y = permute (y, perm);
     endif
   endif
 
 endfunction
diff --git a/scripts/statistics/base/run_count.m b/scripts/statistics/base/run_count.m
--- a/scripts/statistics/base/run_count.m
+++ b/scripts/statistics/base/run_count.m
@@ -42,18 +42,18 @@ function retval = run_count (x, n, dim)
     while (dim < nd + 1 && sz(dim) == 1)
       dim = dim + 1;
     endwhile
     if (dim > nd)
       dim = 1;
     endif
   else
     if (! (isscalar (dim) && dim == round (dim))
-	&& dim > 0
-	&& dim < (nd + 1))
+        && dim > 0
+        && dim < (nd + 1))
       error ("run_count: dim must be an integer and valid dimension");
     endif
   endif
 
   if (! (isscalar (n) && n == round (n)) && n > 0)
     error ("run_count: n must be a positive integer");
   endif
   
diff --git a/scripts/statistics/base/skewness.m b/scripts/statistics/base/skewness.m
--- a/scripts/statistics/base/skewness.m
+++ b/scripts/statistics/base/skewness.m
@@ -57,18 +57,18 @@ function retval = skewness (x, dim)
     while (dim < nd + 1 && sz(dim) == 1)
       dim = dim + 1;
     endwhile
     if (dim > nd)
       dim = 1;
     endif
   else
     if (! (isscalar (dim) && dim == round (dim))
-	&& dim > 0
-	&& dim < (nd + 1))
+        && dim > 0
+        && dim < (nd + 1))
       error ("skewness: dim must be an integer and valid dimension");
     endif
   endif
 
   if (! ismatrix (x))
     error ("skewness: x has to be a matrix or a vector");
   endif
 
diff --git a/scripts/statistics/base/statistics.m b/scripts/statistics/base/statistics.m
--- a/scripts/statistics/base/statistics.m
+++ b/scripts/statistics/base/statistics.m
@@ -45,30 +45,30 @@ function S = statistics (X, dim)
     while (dim < nd + 1 && sz(dim) == 1)
       dim = dim + 1;
     endwhile
     if (dim > nd)
       dim = 1;
     endif
   else
     if (! (isscalar (dim) && dim == round (dim))
-	&& dim > 0
-	&& dim < (nd + 1))
+        && dim > 0
+        && dim < (nd + 1))
       error ("statistics: dim must be an integer and valid dimension");
     endif
   endif
   
   if (! ismatrix (X) || sz(dim) < 2)
     error ("statistics: invalid argument");
   endif    
 
   emp_inv = quantile (X, [0.25; 0.5; 0.75], dim, 7);
 
   S = cat (dim, min (X, [], dim), emp_inv, max (X, [], dim), mean (X, dim),
-	   std (X, [], dim), skewness (X, dim), kurtosis (X, dim));
+           std (X, [], dim), skewness (X, dim), kurtosis (X, dim));
 
 endfunction
 
 %!test
 %! x = rand(7,5);
 %! s = statistics (x);
 %! m = median (x);
 %! assert (m, s(3,:), eps);
diff --git a/scripts/statistics/base/studentize.m b/scripts/statistics/base/studentize.m
--- a/scripts/statistics/base/studentize.m
+++ b/scripts/statistics/base/studentize.m
@@ -44,18 +44,18 @@ function t = studentize (x, dim)
     while (dim < nd + 1 && sz(dim) == 1)
       dim = dim + 1;
     endwhile
     if (dim > nd)
       dim = 1;
     endif
   else
     if (! (isscalar (dim) && dim == round (dim))
-	&& dim > 0
-	&& dim < (nd + 1))
+        && dim > 0
+        && dim < (nd + 1))
       error ("studentize: dim must be an integer and valid dimension");
     endif
   endif
 
   if (! ismatrix (x))
     error ("studentize: x must be a vector or a matrix");
   endif
 
diff --git a/scripts/statistics/base/var.m b/scripts/statistics/base/var.m
--- a/scripts/statistics/base/var.m
+++ b/scripts/statistics/base/var.m
@@ -61,23 +61,23 @@ function retval = var (x, opt, dim)
   if (isempty (x))
     ## FIXME -- is there a way to obtain these results without all the
     ## special cases?
     if (ndims (x) == 2 && sz(1) == 0 && sz(2) == 0)
       retval = NaN;
     else
       sz(dim) = 1;
       if (n == 0)
-	if (prod (sz) == 0)
-	  retval = zeros (sz);
-	else
-	  retval = NaN (sz);
-	endif
+        if (prod (sz) == 0)
+          retval = zeros (sz);
+        else
+          retval = NaN (sz);
+        endif
       else
-	retval = zeros (sz);
+        retval = zeros (sz);
       endif
     endif
   elseif (n == 1)
     retval = zeros (sz);
   else
     retval = sumsq (center (x, dim), dim) / (n + opt - 1);
   endif
 
diff --git a/scripts/statistics/distributions/betapdf.m b/scripts/statistics/distributions/betapdf.m
--- a/scripts/statistics/distributions/betapdf.m
+++ b/scripts/statistics/distributions/betapdf.m
@@ -45,16 +45,16 @@ function pdf = betapdf (x, a, b)
   if (any (k))
     pdf (k) = NaN;
   endif
 
   k = find ((x > 0) & (x < 1) & (a > 0) & (b > 0));
   if (any (k))
     if (isscalar(a) && isscalar(b))
       pdf(k) = exp ((a - 1) .* log (x(k))
-		    + (b - 1) .* log (1 - x(k))) ./ beta (a, b);
+                    + (b - 1) .* log (1 - x(k))) ./ beta (a, b);
     else
       pdf(k) = exp ((a(k) - 1) .* log (x(k))
-		    + (b(k) - 1) .* log (1 - x(k))) ./ beta (a(k), b(k));
+                    + (b(k) - 1) .* log (1 - x(k))) ./ beta (a(k), b(k));
     endif
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/betarnd.m b/scripts/statistics/distributions/betarnd.m
--- a/scripts/statistics/distributions/betarnd.m
+++ b/scripts/statistics/distributions/betarnd.m
@@ -32,45 +32,45 @@
 ## Description: Random deviates from the Beta distribution
 
 function rnd = betarnd (a, b, r, c)
 
   if (nargin > 1)
     if (!isscalar(a) || !isscalar(b)) 
       [retval, a, b] = common_size (a, b);
       if (retval > 0)
-	error ("betarnd: a and b must be of common size or scalar");
+        error ("betarnd: a and b must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("betarnd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("betarnd: c must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (a) != 1)
-	&& (length (size (a)) != length (sz) || any (size (a) != sz)))
+        && (length (size (a)) != length (sz) || any (size (a) != sz)))
       error ("betarnd: a and b must be scalar or of size [r,c]");
     endif
   elseif (nargin == 3)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("betarnd: r must be a positive integer or vector");
     endif
 
     if (any (size (a) != 1)
-	&& (length (size (a)) != length (sz) || any (size (a) != sz)))
+        && (length (size (a)) != length (sz) || any (size (a) != sz)))
       error ("betarnd: a and b must be scalar or of size sz");
     endif
   elseif (nargin == 2)
     sz = size(a);
   else
     print_usage ();
   endif
 
diff --git a/scripts/statistics/distributions/binocdf.m b/scripts/statistics/distributions/binocdf.m
--- a/scripts/statistics/distributions/binocdf.m
+++ b/scripts/statistics/distributions/binocdf.m
@@ -37,29 +37,29 @@ function cdf = binocdf (x, n, p)
       error ("binocdf: x, n and p must be of common size or scalar");
     endif
   endif
 
   sz = size (x);
   cdf = zeros (sz);
 
   k = find (isnan (x) | !(n >= 0) | (n != round (n))
-	    | !(p >= 0) | !(p <= 1));
+            | !(p >= 0) | !(p <= 1));
   if (any (k))
     cdf(k) = NaN;
   endif
 
   k = find ((x >= n) & (n >= 0) & (n == round (n))
-	    & (p >= 0) & (p <= 1));
+            & (p >= 0) & (p <= 1));
   if (any (k))
     cdf(k) = 1;
   endif
 
   k = find ((x >= 0) & (x < n) & (n == round (n))
-	    & (p >= 0) & (p <= 1));
+            & (p >= 0) & (p <= 1));
   if (any (k))
     tmp = floor (x(k));
     if (isscalar (n) && isscalar (p))
       cdf(k) = 1 - betainc (p, tmp + 1, n - tmp);
     else
       cdf(k) = 1 - betainc (p(k), tmp + 1, n(k) - tmp);
     endif
   endif
diff --git a/scripts/statistics/distributions/binoinv.m b/scripts/statistics/distributions/binoinv.m
--- a/scripts/statistics/distributions/binoinv.m
+++ b/scripts/statistics/distributions/binoinv.m
@@ -37,42 +37,42 @@ function inv = binoinv (x, n, p)
       error ("binoinv: x, n and p must be of common size or scalars");
     endif
   endif
   
   sz = size (x);
   inv = zeros (sz);
 
   k = find (!(x >= 0) | !(x <= 1) | !(n >= 0) | (n != round (n))
-	    | !(p >= 0) | !(p <= 1));
+            | !(p >= 0) | !(p <= 1));
   if (any (k))
     inv(k) = NaN;
   endif
 
   k = find ((x >= 0) & (x <= 1) & (n >= 0) & (n == round (n))
-	    & (p >= 0) & (p <= 1));
+            & (p >= 0) & (p <= 1));
   if (any (k))
     if (isscalar (n) && isscalar (p))
       cdf = binopdf (0, n, p) * ones (size(k));
       while (any (inv(k) < n))
-	m = find (cdf < x(k));
-	if (any (m))
+        m = find (cdf < x(k));
+        if (any (m))
           inv(k(m)) = inv(k(m)) + 1;
           cdf(m) = cdf(m) + binopdf (inv(k(m)), n, p);
-	else
+        else
           break;
-	endif
+        endif
       endwhile
     else 
       cdf = binopdf (0, n(k), p(k));
       while (any (inv(k) < n(k)))
-	m = find (cdf < x(k));
-	if (any (m))
+        m = find (cdf < x(k));
+        if (any (m))
           inv(k(m)) = inv(k(m)) + 1;
           cdf(m) = cdf(m) + binopdf (inv(k(m)), n(k(m)), p(k(m)));
-	else
+        else
           break;
-	endif
+        endif
       endwhile
     endif
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/binornd.m b/scripts/statistics/distributions/binornd.m
--- a/scripts/statistics/distributions/binornd.m
+++ b/scripts/statistics/distributions/binornd.m
@@ -32,45 +32,45 @@
 ## Description: Random deviates from the binomial distribution
 
 function rnd = binornd (n, p, r, c)
 
   if (nargin > 1)
     if (!isscalar(n) || !isscalar(p)) 
       [retval, n, p] = common_size (n, p);
       if (retval > 0)
-	error ("binornd: n and p must be of common size or scalar");
+        error ("binornd: n and p must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("binornd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("binornd: c must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (n) != 1)
-	&& (length (size (n)) != length (sz) ||	any (size (n) != sz)))
+        && (length (size (n)) != length (sz) || any (size (n) != sz)))
       error ("binornd: n and must be scalar or of size [r, c]");
     endif
   elseif (nargin == 3)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("binornd: r must be a positive integer or vector");
     endif
 
     if (any (size (n) != 1)
-	&& (length (size (n)) != length (sz) || any (size (n) != sz)))
+        && (length (size (n)) != length (sz) || any (size (n) != sz)))
       error ("binornd: n and must be scalar or of size sz");
     endif
   elseif (nargin == 2)
     sz = size(n);
   else
     print_usage ();
   endif
 
diff --git a/scripts/statistics/distributions/cauchy_pdf.m b/scripts/statistics/distributions/cauchy_pdf.m
--- a/scripts/statistics/distributions/cauchy_pdf.m
+++ b/scripts/statistics/distributions/cauchy_pdf.m
@@ -49,16 +49,16 @@ function pdf = cauchy_pdf (x, location, 
   sz = size (x);
   pdf = NaN (sz);
 
   k = find ((x > -Inf) & (x < Inf) & (location > -Inf) &
             (location < Inf) & (scale > 0) & (scale < Inf));
   if (any (k))
     if (isscalar (location) && isscalar (scale)) 
       pdf(k) = ((1 ./ (1 + ((x(k) - location) ./ scale) .^ 2))
-		/ pi ./ scale);
+                / pi ./ scale);
     else
       pdf(k) = ((1 ./ (1 + ((x(k) - location(k)) ./ scale(k)) .^ 2))
-		/ pi ./ scale(k));
+                / pi ./ scale(k));
     endif
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/cauchy_rnd.m b/scripts/statistics/distributions/cauchy_rnd.m
--- a/scripts/statistics/distributions/cauchy_rnd.m
+++ b/scripts/statistics/distributions/cauchy_rnd.m
@@ -32,45 +32,45 @@
 ## Description: Random deviates from the Cauchy distribution
 
 function rnd = cauchy_rnd (l, scale, r, c)
 
   if (nargin > 1)
     if (!isscalar (l) || !isscalar (scale)) 
       [retval, l, scale] = common_size (l, scale);
       if (retval > 0)
-	error ("cauchy_rnd: lambda and sigma must be of common size or scalar");
+        error ("cauchy_rnd: lambda and sigma must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("cauchy_rnd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("cauchy_rnd: c must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (l) != 1)
-	&& (length (size (l)) != length (sz) || any (size (l) != sz)))
+        && (length (size (l)) != length (sz) || any (size (l) != sz)))
       error ("cauchy_rnd: lambda and sigma must be scalar or of size [r, c]");
     endif
   elseif (nargin == 3)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("cauchy_rnd: r must be a positive integer or vector");
     endif
 
     if (any (size (l) != 1)
-	&& (length (size (l)) != length (sz) ||	any (size (l) != sz)))
+        && (length (size (l)) != length (sz) || any (size (l) != sz)))
       error ("cauchy_rnd: lambda and sigma must be scalar or of size sz");
     endif
   elseif (nargin == 2)
     sz = size(l);
   else
     print_usage ();
   endif
 
diff --git a/scripts/statistics/distributions/chi2rnd.m b/scripts/statistics/distributions/chi2rnd.m
--- a/scripts/statistics/distributions/chi2rnd.m
+++ b/scripts/statistics/distributions/chi2rnd.m
@@ -37,30 +37,30 @@ function rnd = chi2rnd (n, r, c)
       error ("chi2rnd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("chi2rnd: c must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (n) != 1)
-	&& (length (size (n)) != length (sz) ||	any (size (n) != sz)))
+        && (length (size (n)) != length (sz) || any (size (n) != sz)))
       error ("chi2rnd: n must be scalar or of size [r, c]");
     endif
   elseif (nargin == 2)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("chi2rnd: r must be a positive integer or vector");
     endif
 
     if (any (size (n) != 1)
-	&& (length (size (n)) != length (sz) || any (size (n) != sz)))
+        && (length (size (n)) != length (sz) || any (size (n) != sz)))
       error ("chi2rnd: n must be scalar or of size sz");
     endif
   elseif (nargin == 1)
     sz = size(n);
   else
     print_usage ();
   endif
 
diff --git a/scripts/statistics/distributions/discrete_rnd.m b/scripts/statistics/distributions/discrete_rnd.m
--- a/scripts/statistics/distributions/discrete_rnd.m
+++ b/scripts/statistics/distributions/discrete_rnd.m
@@ -50,21 +50,21 @@ function rnd = discrete_rnd (v, p, r, c)
     ## if the first arg is scalar
 
     if (isscalar (v))
       sz = [1, floor(v)];
       v = p;
       p = r;
     else
       if (isscalar (r) && (r > 0))
-	sz = [r, r];
+        sz = [r, r];
       elseif (isvector(r) && all (r > 0))
-	sz = r(:)';
+        sz = r(:)';
       else
-	error ("discrete_rnd: r must be a positive integer or vector");
+        error ("discrete_rnd: r must be a positive integer or vector");
       endif
     endif
   else
     print_usage ();
   endif
 
   if (! isvector (v))
     error ("discrete_rnd: v must be a vector");
diff --git a/scripts/statistics/distributions/exprnd.m b/scripts/statistics/distributions/exprnd.m
--- a/scripts/statistics/distributions/exprnd.m
+++ b/scripts/statistics/distributions/exprnd.m
@@ -38,30 +38,30 @@ function rnd = exprnd (l, r, c)
       error ("exprnd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("exprnd: c must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (l) != 1) && 
-	(length (size (l)) != length (sz) || any (size (l) != sz)))
+        (length (size (l)) != length (sz) || any (size (l) != sz)))
       error ("exprnd: lambda must be scalar or of size [r, c]");
     endif
   elseif (nargin == 2)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("exprnd: r must be a positive integer or vector");
     endif
 
     if (any (size (l) != 1) && 
-	((length (size (l)) != length (sz)) || any (size (l) != sz)))
+        ((length (size (l)) != length (sz)) || any (size (l) != sz)))
       error ("exprnd: lambda must be scalar or of size sz");
     endif
   elseif (nargin == 1)
     sz = size (l);
   else
     print_usage ();
   endif
 
diff --git a/scripts/statistics/distributions/fcdf.m b/scripts/statistics/distributions/fcdf.m
--- a/scripts/statistics/distributions/fcdf.m
+++ b/scripts/statistics/distributions/fcdf.m
@@ -53,13 +53,13 @@ function cdf = fcdf (x, m, n)
   endif
 
   k = find ((x > 0) & (x < Inf) & (m > 0) & (n > 0));
   if (any (k))
     if (isscalar (m) && isscalar (n))
       cdf(k) = 1 - betainc (1 ./ (1 + m .* x(k) ./ n), n / 2, m / 2);
     else
       cdf(k) = 1 - betainc (1 ./ (1 + m(k) .* x(k) ./ n(k)), n(k) / 2, 
-			    m(k) / 2);
+                            m(k) / 2);
     endif
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/finv.m b/scripts/statistics/distributions/finv.m
--- a/scripts/statistics/distributions/finv.m
+++ b/scripts/statistics/distributions/finv.m
@@ -53,13 +53,13 @@ function inv = finv (x, m, n)
   endif
 
   k = find ((x > 0) & (x < 1) & (m > 0) & (n > 0));
   if (any (k))
     if (isscalar (m) && isscalar (n))
       inv(k) = ((1 ./ betainv (1 - x(k), n / 2, m / 2) - 1) .* n ./ m);
     else
       inv(k) = ((1 ./ betainv (1 - x(k), n(k) / 2, m(k) / 2) - 1)
-		.* n(k) ./ m(k));
+                .* n(k) ./ m(k));
     endif
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/fpdf.m b/scripts/statistics/distributions/fpdf.m
--- a/scripts/statistics/distributions/fpdf.m
+++ b/scripts/statistics/distributions/fpdf.m
@@ -47,19 +47,19 @@ function pdf = fpdf (x, m, n)
     pdf(k) = NaN;
   endif
 
   k = find ((x > 0) & (x < Inf) & (m > 0) & (n > 0));
   if (any (k))
     if (isscalar (m) && isscalar (n))
       tmp = m / n * x(k);
       pdf(k) = (exp ((m / 2 - 1) .* log (tmp)
-		     - ((m + n) / 2) .* log (1 + tmp))
-		.* (m / n) ./ beta (m / 2, n / 2));
+                     - ((m + n) / 2) .* log (1 + tmp))
+                .* (m / n) ./ beta (m / 2, n / 2));
     else
       tmp = m(k) .* x(k) ./ n(k);
       pdf(k) = (exp ((m(k) / 2 - 1) .* log (tmp)
-		     - ((m(k) + n(k)) / 2) .* log (1 + tmp))
-		.* (m(k) ./ n(k)) ./ beta (m(k) / 2, n(k) / 2));
+                     - ((m(k) + n(k)) / 2) .* log (1 + tmp))
+                .* (m(k) ./ n(k)) ./ beta (m(k) / 2, n(k) / 2));
     endif
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/frnd.m b/scripts/statistics/distributions/frnd.m
--- a/scripts/statistics/distributions/frnd.m
+++ b/scripts/statistics/distributions/frnd.m
@@ -33,64 +33,64 @@
 ## Description: Random deviates from the F distribution
 
 function rnd = frnd (m, n, r, c)
 
   if (nargin > 1)
     if (!isscalar(m) || !isscalar(n)) 
       [retval, m, n] = common_size (m, n);
       if (retval > 0)
-	error ("frnd: m and n must be of common size or scalar");
+        error ("frnd: m and n must be of common size or scalar");
       endif
     endif
   endif
 
 
   if (nargin == 4)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("frnd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("frnd: c must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (m) != 1) && 
-	((length (size (m)) != length (sz)) || any (size (m) != sz)))
+        ((length (size (m)) != length (sz)) || any (size (m) != sz)))
       error ("frnd: m and n must be scalar or of size [r,c]");
     endif
   elseif (nargin == 3)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("frnd: r must be a positive integer or vector");
     endif
 
     if (any (size (m) != 1) && 
-	((length (size (m)) != length (sz)) || any (size (m) != sz)))
+        ((length (size (m)) != length (sz)) || any (size (m) != sz)))
       error ("frnd: m and n must be scalar or of size sz");
     endif
   elseif (nargin == 2)
     sz = size(a);
   else
     print_usage ();
   endif
 
 
   if (isscalar (m) && isscalar (n))
     if (isinf (m) || isinf (n))
       if (isinf (m))
-	rnd = ones (sz);
+        rnd = ones (sz);
       else
-	rnd = 2 ./ m .* randg(m / 2, sz);
+        rnd = 2 ./ m .* randg(m / 2, sz);
       endif
       if (! isinf (n))
-	rnd = 0.5 .* n .* rnd ./ randg (n / 2, sz); 
+        rnd = 0.5 .* n .* rnd ./ randg (n / 2, sz); 
       endif
     elseif ((m > 0) && (m < Inf) && (n > 0) && (n < Inf))
       rnd = n ./ m .* randg (m / 2, sz) ./ randg (n / 2, sz);
     else
       rnd = NaN (sz);
     endif
   else
     rnd = zeros (sz);
diff --git a/scripts/statistics/distributions/gampdf.m b/scripts/statistics/distributions/gampdf.m
--- a/scripts/statistics/distributions/gampdf.m
+++ b/scripts/statistics/distributions/gampdf.m
@@ -47,27 +47,27 @@ function pdf = gampdf (x, a, b)
   if (any (k))
     pdf (k) = NaN;
   endif
 
   k = find ((x > 0) & (a > 0) & (a <= 1) & (b > 0));
   if (any (k))
     if (isscalar(a) && isscalar(b))
       pdf(k) = (x(k) .^ (a - 1)) ...
-		.* exp(- x(k) ./ b) ./ gamma (a) ./ (b .^ a);
+                .* exp(- x(k) ./ b) ./ gamma (a) ./ (b .^ a);
     else
       pdf(k) = (x(k) .^ (a(k) - 1)) ...
-		.* exp(- x(k) ./ b(k)) ./ gamma (a(k)) ./ (b(k) .^ a(k));
+                .* exp(- x(k) ./ b(k)) ./ gamma (a(k)) ./ (b(k) .^ a(k));
     endif
   endif
 
   k = find ((x > 0) & (a > 1) & (b > 0));
   if (any (k))
     if (isscalar(a) && isscalar(b))
       pdf(k) = exp (- a .* log (b) + (a-1) .* log (x(k))
-		    - x(k) ./ b - gammaln (a));
+                    - x(k) ./ b - gammaln (a));
     else
       pdf(k) = exp (- a(k) .* log (b(k)) + (a(k)-1) .* log (x(k))
-		    - x(k) ./ b(k) - gammaln (a(k)));
+                    - x(k) ./ b(k) - gammaln (a(k)));
     endif
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/gamrnd.m b/scripts/statistics/distributions/gamrnd.m
--- a/scripts/statistics/distributions/gamrnd.m
+++ b/scripts/statistics/distributions/gamrnd.m
@@ -33,45 +33,45 @@
 ## Description: Random deviates from the Gamma distribution
 
 function rnd = gamrnd (a, b, r, c)
 
   if (nargin > 1)
     if (!isscalar(a) || !isscalar(b)) 
       [retval, a, b] = common_size (a, b);
       if (retval > 0)
-	error ("gamrnd: a and b must be of common size or scalar");
+        error ("gamrnd: a and b must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("gamrnd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("gamrnd: c must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (a) != 1)
-	&& (length (size (a)) != length (sz) || any (size (a) != sz)))
+        && (length (size (a)) != length (sz) || any (size (a) != sz)))
       error ("gamrnd: a and b must be scalar or of size [r, c]");
     endif
   elseif (nargin == 3)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("gamrnd: r must be a positive integer or vector");
     endif
 
     if (any (size (a) != 1)
-	&& (length (size (a)) != length (sz) || any (size (a) != sz)))
+        && (length (size (a)) != length (sz) || any (size (a) != sz)))
       error ("gamrnd: a and b must be scalar or of size sz");
     endif
   elseif (nargin == 2)
     sz = size(a);
   else
     print_usage ();
   endif
 
diff --git a/scripts/statistics/distributions/geornd.m b/scripts/statistics/distributions/geornd.m
--- a/scripts/statistics/distributions/geornd.m
+++ b/scripts/statistics/distributions/geornd.m
@@ -38,30 +38,30 @@ function rnd = geornd (p, r, c)
       error ("geornd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("geornd: c must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (p) != 1) && ((length (size (p)) != length (sz)) ||
-				any (size (p) != sz)))
+                                any (size (p) != sz)))
       error ("geornd: p must be scalar or of size [r, c]");
     endif
   elseif (nargin == 2)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("geornd: r must be a positive integer or vector");
     endif
 
     if (any (size (p) != 1) && ((length (size (p)) != length (sz)) ||
-				any (size (p) != sz)))
+                                any (size (p) != sz)))
       error ("geornd: n must be scalar or of size sz");
     endif
   elseif (nargin == 1)
     sz = size(n);
   elseif (nargin != 1)
     print_usage ();
   endif
 
diff --git a/scripts/statistics/distributions/hygepdf.m b/scripts/statistics/distributions/hygepdf.m
--- a/scripts/statistics/distributions/hygepdf.m
+++ b/scripts/statistics/distributions/hygepdf.m
@@ -57,16 +57,16 @@ function pdf = hygepdf (x, t, m, n)
     else
       pdf (k) = NaN;
     endif
   endif
   k = find (!i1 & !i2);
   if (any (k))
     if (isscalar (t) && isscalar (m) && isscalar (n))
       pdf (k) = (bincoeff (m, x(k)) .* bincoeff (t-m, n-x(k))
-		 / bincoeff (t, n));
+                 / bincoeff (t, n));
     else
       pdf (k) = (bincoeff (m(k), x(k)) .* bincoeff (t(k)-m(k), n(k)-x(k))
-		 ./ bincoeff (t(k), n(k)));
+                 ./ bincoeff (t(k), n(k)));
     endif
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/laplace_inv.m b/scripts/statistics/distributions/laplace_inv.m
--- a/scripts/statistics/distributions/laplace_inv.m
+++ b/scripts/statistics/distributions/laplace_inv.m
@@ -42,12 +42,12 @@ function inv = laplace_inv (x)
   k = find (x == 1);
   if (any (k))
     inv(k) = Inf;
   endif
 
   k = find ((x > 0) & (x < 1));
   if (any (k))
     inv(k) = ((x(k) < 1/2) .* log (2 * x(k))
-	      - (x(k) > 1/2) .* log (2 * (1 - x(k))));
+              - (x(k) > 1/2) .* log (2 * (1 - x(k))));
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/lognrnd.m b/scripts/statistics/distributions/lognrnd.m
--- a/scripts/statistics/distributions/lognrnd.m
+++ b/scripts/statistics/distributions/lognrnd.m
@@ -32,46 +32,46 @@
 ## Description: Random deviates from the log normal distribution
 
 function rnd = lognrnd (mu, sigma, r, c)
 
   if (nargin > 1)
     if (!isscalar(mu) || !isscalar(sigma)) 
       [retval, mu, sigma] = common_size (mu, sigma);
       if (retval > 0)
-	error ("lognrnd: mu and sigma must be of common size or scalar");
+        error ("lognrnd: mu and sigma must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("lognrnd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("lognrnd: c must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (mu) != 1) && 
-	((length (size (mu)) != length (sz)) || any (size (mu) != sz)))
+        ((length (size (mu)) != length (sz)) || any (size (mu) != sz)))
       error ("lognrnd: mu and sigma must be scalar or of size [r, c]");
     endif
 
   elseif (nargin == 3)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("lognrnd: r must be a positive integer or vector");
     endif
 
     if (any (size (mu) != 1) && 
-	((length (size (mu)) != length (sz)) || any (size (mu) != sz)))
+        ((length (size (mu)) != length (sz)) || any (size (mu) != sz)))
       error ("lognrnd: mu and sigma must be scalar or of size sz");
     endif
   elseif (nargin == 2)
     sz = size(mu);
   else
     print_usage ();
   endif
 
diff --git a/scripts/statistics/distributions/nbincdf.m b/scripts/statistics/distributions/nbincdf.m
--- a/scripts/statistics/distributions/nbincdf.m
+++ b/scripts/statistics/distributions/nbincdf.m
@@ -40,53 +40,53 @@ function cdf = nbincdf (x, n, p)
     if (retval > 0)
       error ("nbincdf: x, n and p must be of common size or scalar");
     endif
   endif
   
   cdf = zeros (size (x));
 
   k = find (isnan (x) | (n < 1) | (n == Inf) | (n != round (n))
-	    | (p < 0) | (p > 1));
+            | (p < 0) | (p > 1));
   if (any (k))
     cdf(k) = NaN;
   endif
 
   k = find ((x == Inf) & (n > 0) & (n < Inf) & (n == round (n))
-	    & (p >= 0) & (p <= 1));
+            & (p >= 0) & (p <= 1));
   if (any (k))
     cdf(k) = 1;
   endif
 
   k = find ((x >= 0) & (x < Inf) & (x == round (x)) & (n > 0)
-	    & (n < Inf) & (n == round (n)) & (p > 0) & (p <= 1));
+            & (n < Inf) & (n == round (n)) & (p > 0) & (p <= 1));
   if (any (k))
     ## Does anyone know a better way to do the summation?
     m = zeros (size (k));
     x = floor (x(k));
     y = cdf(k);
     if (isscalar (n) && isscalar (p))
       while (1)
-	l = find (m <= x);
-	if (any (l))
+        l = find (m <= x);
+        if (any (l))
           y(l) = y(l) + nbinpdf (m(l), n, p);
           m(l) = m(l) + 1;
-	else
+        else
           break;
-	endif
+        endif
       endwhile
     else
       n = n(k);
       p = p(k);
       while (1)
-	l = find (m <= x);
-	if (any (l))
+        l = find (m <= x);
+        if (any (l))
           y(l) = y(l) + nbinpdf (m(l), n(l), p(l));
           m(l) = m(l) + 1;
-	else
+        else
           break;
-	endif
+        endif
       endwhile
     endif
     cdf(k) = y;
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/nbininv.m b/scripts/statistics/distributions/nbininv.m
--- a/scripts/statistics/distributions/nbininv.m
+++ b/scripts/statistics/distributions/nbininv.m
@@ -41,53 +41,53 @@ function inv = nbininv (x, n, p)
     if (retval > 0)
       error ("nbininv: x, n and p must be of common size or scalar");
     endif
   endif
 
   inv = zeros (size (x));
 
   k = find (isnan (x) | (x < 0) | (x > 1) | (n < 1) | (n == Inf)
-	    | (n != round (n)) | (p < 0) | (p > 1));
+            | (n != round (n)) | (p < 0) | (p > 1));
   if (any (k))
     inv(k) = NaN;
   endif
 
   k = find ((x == 1) & (n > 0) & (n < Inf) & (n == round (n))
-	    & (p >= 0) & (p <= 1));
+            & (p >= 0) & (p <= 1));
   if (any (k))
     inv(k) = Inf;
   endif
 
   k = find ((x >= 0) & (x < 1) & (n > 0) & (n < Inf)
-	    & (n == round (n)) & (p > 0) & (p <= 1));
+            & (n == round (n)) & (p > 0) & (p <= 1));
   if (any (k))
     m = zeros (size (k));
     x = x(k);
     if (isscalar (n) && isscalar (p))
       s = p ^ n * ones (size(k));
       while (1)
-	l = find (s < x);
-	if (any (l))
+        l = find (s < x);
+        if (any (l))
           m(l) = m(l) + 1;
           s(l) = s(l) + nbinpdf (m(l), n, p);
-	else
+        else
           break;
-	endif
+        endif
       endwhile
     else
       n = n(k);
       p = p(k);
       s = p .^ n;
       while (1)
-	l = find (s < x);
-	if (any (l))
+        l = find (s < x);
+        if (any (l))
           m(l) = m(l) + 1;
           s(l) = s(l) + nbinpdf (m(l), n(l), p(l));
-	else
+        else
           break;
-	endif
+        endif
       endwhile
     endif
     inv(k) = m;
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/nbinpdf.m b/scripts/statistics/distributions/nbinpdf.m
--- a/scripts/statistics/distributions/nbinpdf.m
+++ b/scripts/statistics/distributions/nbinpdf.m
@@ -41,30 +41,30 @@ function pdf = nbinpdf (x, n, p)
     if (retval > 0)
       error ("nbinpdf: x, n and p must be of common size or scalar");
     endif
   endif
 
   pdf = zeros (size (x));
 
   k = find (isnan (x) | (n < 1) | (n == Inf) | (n != round (n))
-	    | (p < 0) | (p > 1));
+            | (p < 0) | (p > 1));
   if (any (k))
     pdf(k) = NaN;
   endif
 
   ## Just for the fun of it ...
   k = find ((x == Inf) & (n > 0) & (n < Inf) & (n == round (n))
-	    & (p == 0));
+            & (p == 0));
   if (any (k))
     pdf(k) = 1;
   endif
 
   k = find ((x >= 0) & (x < Inf) & (x == round (x)) & (n > 0)
-	    & (n < Inf) & (n == round (n)) & (p > 0) & (p <= 1));
+            & (n < Inf) & (n == round (n)) & (p > 0) & (p <= 1));
   if (any (k))
     if (isscalar (n) && isscalar (p))
       pdf(k) = bincoeff (-n, x(k)) .* (p ^ n) .* ((p - 1) .^ x(k));
     else
       pdf(k) = bincoeff (-n(k), x(k)) .* (p(k) .^ n(k)) .* ((p(k) - 1) .^ x(k));
     endif
   endif
 
diff --git a/scripts/statistics/distributions/nbinrnd.m b/scripts/statistics/distributions/nbinrnd.m
--- a/scripts/statistics/distributions/nbinrnd.m
+++ b/scripts/statistics/distributions/nbinrnd.m
@@ -32,68 +32,68 @@
 ## Description: Random deviates from the Pascal distribution
 
 function rnd = nbinrnd (n, p, r, c)
 
   if (nargin > 1)
     if (!isscalar(n) || !isscalar(p)) 
       [retval, n, p] = common_size (n, p);
       if (retval > 0)
-	error ("nbinrnd: n and p must be of common size or scalar");
+        error ("nbinrnd: n and p must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("nbinrnd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("nbinrnd: c must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (n) != 1) && 
-	((length (size (n)) != length (sz)) || any (size (n) != sz)))
+        ((length (size (n)) != length (sz)) || any (size (n) != sz)))
       error ("nbinrnd: n and p must be scalar or of size [r, c]");
     endif
 
   elseif (nargin == 3)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("nbinrnd: r must be a positive integer or vector");
     endif
 
     if (any (size (n) != 1) && 
-	((length (size (n)) != length (sz)) || any (size (n) != sz)))
+        ((length (size (n)) != length (sz)) || any (size (n) != sz)))
       error ("nbinrnd: n and p must be scalar or of size sz");
     endif
   elseif (nargin == 2)
     sz = size(n);
   else
     print_usage ();
   endif
 
   if (isscalar (n) && isscalar (p))
     if ((n < 1) || (n == Inf) || (n != round (n)) || (p <= 0) || (p > 1));
       rnd = NaN (sz);
     elseif ((n > 0) && (n < Inf) && (n == round (n)) && 
-	    (p > 0) && (p <= 1))
+            (p > 0) && (p <= 1))
       rnd = randp ((1 - p) ./ p .* randg (n, sz));
     else
       rnd = zeros (sz);
     endif
   else
     rnd = zeros (sz);
 
     k = find ((n < 1) || (n == Inf) || (n != round (n)) || 
-	      (p <= 0) || (p > 1));
+              (p <= 0) || (p > 1));
     if (any (k))
       rnd(k) = NaN;
     endif
 
     k = find ((n > 0) & (n < Inf) & (n == round (n)) & (p > 0) & (p <= 1));
     if (any (k))
       rnd(k) = randp ((1 - p(k)) ./ p(k) .* randg (n(k), size(k)));
     endif
diff --git a/scripts/statistics/distributions/normrnd.m b/scripts/statistics/distributions/normrnd.m
--- a/scripts/statistics/distributions/normrnd.m
+++ b/scripts/statistics/distributions/normrnd.m
@@ -32,45 +32,45 @@
 ## Description: Random deviates from the normal distribution
 
 function rnd = normrnd (m, s, r, c)
 
   if (nargin > 1)
     if (!isscalar (m) || !isscalar (s)) 
       [retval, m, s] = common_size (m, s);
       if (retval > 0)
-	error ("normrnd: m and s must be of common size or scalar");
+        error ("normrnd: m and s must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("normrnd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("normrnd: c must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (m) != 1)
-	&& (length (size (m)) != length (sz) || any (size (m) != sz)))
+        && (length (size (m)) != length (sz) || any (size (m) != sz)))
       error ("normrnd: m and s must be scalar or of size [r, c]");
     endif
   elseif (nargin == 3)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("normrnd: r must be a positive integer or vector");
     endif
 
     if (any (size (m) != 1)
-	&& (length (size (m)) != length (sz) || any (size (m) != sz)))
+        && (length (size (m)) != length (sz) || any (size (m) != sz)))
       error ("normrnd: m and s must be scalar or of size sz");
     endif
   elseif (nargin == 2)
     sz = size(m);
   else
     print_usage ();
   endif
 
diff --git a/scripts/statistics/distributions/poissinv.m b/scripts/statistics/distributions/poissinv.m
--- a/scripts/statistics/distributions/poissinv.m
+++ b/scripts/statistics/distributions/poissinv.m
@@ -57,20 +57,20 @@ function inv = poissinv (x, l)
       cdf = exp (-l) * ones (size (k));
     else
       cdf = exp (-l(k));
     endif
     while (1)
       m = find (cdf < x(k));
       if (any (m))
         inv(k(m)) = inv(k(m)) + 1;
-	if (isscalar (l))
+        if (isscalar (l))
           cdf(m) = cdf(m) + poisspdf (inv(k(m)), l);
-	else
+        else
           cdf(m) = cdf(m) + poisspdf (inv(k(m)), l(k(m)));
-	endif
+        endif
       else
         break;
       endif
     endwhile
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/poissrnd.m b/scripts/statistics/distributions/poissrnd.m
--- a/scripts/statistics/distributions/poissrnd.m
+++ b/scripts/statistics/distributions/poissrnd.m
@@ -36,30 +36,30 @@ function rnd = poissrnd (l, r, c)
       error ("poissrnd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("poissrnd: c must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (l) != 1) && 
-	((length (size (l)) != length (sz)) || any (size (l) != sz)))
+        ((length (size (l)) != length (sz)) || any (size (l) != sz)))
       error ("poissrnd: lambda must be scalar or of size [r, c]");
     endif
   elseif (nargin == 2)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("poissrnd: r must be a positive integer or vector");
     endif
 
     if (any (size (l) != 1) && 
-	((length (size (l)) != length (sz)) || any (size (l) != sz)))
+        ((length (size (l)) != length (sz)) || any (size (l) != sz)))
       error ("poissrnd: lambda must be scalar or of size sz");
     endif
   elseif (nargin == 1)
     sz = size (l);
   else
     print_usage ();
   endif
 
diff --git a/scripts/statistics/distributions/tinv.m b/scripts/statistics/distributions/tinv.m
--- a/scripts/statistics/distributions/tinv.m
+++ b/scripts/statistics/distributions/tinv.m
@@ -61,22 +61,22 @@ function inv = tinv (x, n)
   if (any (k))
     inv(k) = Inf;
   endif
 
   k = find ((x > 0) & (x < 1) & (n > 0) & (n < 10000));
   if (any (k))
     if (isscalar (n))
       inv(k) = (sign (x(k) - 1/2)
-		.* sqrt (n .* (1 ./ betainv (2*min (x(k), 1 - x(k)),
-						 n/2, 1/2) - 1)));
+                .* sqrt (n .* (1 ./ betainv (2*min (x(k), 1 - x(k)),
+                                                 n/2, 1/2) - 1)));
     else
       inv(k) = (sign (x(k) - 1/2)
-		.* sqrt (n(k) .* (1 ./ betainv (2*min (x(k), 1 - x(k)),
-						 n(k)/2, 1/2) - 1)));
+                .* sqrt (n(k) .* (1 ./ betainv (2*min (x(k), 1 - x(k)),
+                                                 n(k)/2, 1/2) - 1)));
     endif
   endif
 
   ## For large n, use the quantiles of the standard normal
   k = find ((x > 0) & (x < 1) & (n >= 10000));
   if (any (k))
     inv(k) = stdnormal_inv (x(k));
   endif
diff --git a/scripts/statistics/distributions/tpdf.m b/scripts/statistics/distributions/tpdf.m
--- a/scripts/statistics/distributions/tpdf.m
+++ b/scripts/statistics/distributions/tpdf.m
@@ -45,16 +45,16 @@ function pdf = tpdf (x, n)
   if (any (k))
     pdf(k) = NaN;
   endif
 
   k = find (!isinf (x) & !isnan (x) & (n > 0) & (n < Inf));
   if (any (k))
     if (isscalar (n))
       pdf(k) = (exp (- (n + 1) .* log (1 + x(k) .^ 2 ./ n)/2)
-		/ (sqrt (n) * beta (n/2, 1/2)));
+                / (sqrt (n) * beta (n/2, 1/2)));
     else
       pdf(k) = (exp (- (n(k) + 1) .* log (1 + x(k) .^ 2 ./ n(k))/2)
-		./ (sqrt (n(k)) .* beta (n(k)/2, 1/2)));
+                ./ (sqrt (n(k)) .* beta (n(k)/2, 1/2)));
     endif
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/trnd.m b/scripts/statistics/distributions/trnd.m
--- a/scripts/statistics/distributions/trnd.m
+++ b/scripts/statistics/distributions/trnd.m
@@ -38,30 +38,30 @@ function rnd = trnd (n, r, c)
       error ("trnd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("trnd: c must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (n) != 1) && 
-	((length (size (n)) != length (sz)) || any (size (n) != sz)))
+        ((length (size (n)) != length (sz)) || any (size (n) != sz)))
       error ("trnd: n must be scalar or of size sz");
     endif
   elseif (nargin == 2)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("trnd: r must be a positive integer or vector");
     endif
 
     if (any (size (n) != 1) && 
-	((length (size (n)) != length (sz)) || any (size (n) != sz)))
+        ((length (size (n)) != length (sz)) || any (size (n) != sz)))
       error ("trnd: n must be scalar or of size sz");
     endif
   elseif (nargin == 1)
     sz = size (n);
   else
     print_usage ();
   endif
 
diff --git a/scripts/statistics/distributions/unidrnd.m b/scripts/statistics/distributions/unidrnd.m
--- a/scripts/statistics/distributions/unidrnd.m
+++ b/scripts/statistics/distributions/unidrnd.m
@@ -39,17 +39,17 @@ function retval = unidrnd (n, varargin)
     if (rows (varargin{1}) == 1 && columns (varargin{1}) > 1)
       dims = varargin{1};
     else
       error ("unidrnd: invalid dimension vector");
     endif
   elseif (nargin > 2)
     for i = 1:nargin-1
       if (! isscalar (varargin{i}))
-	error ("unidrnd: expecting scalar dimensions");
+        error ("unidrnd: expecting scalar dimensions");
       endif
     endfor
     dims = [varargin{:}];
   else
     error ("unidrnd (n, ...)");
   endif
   if (isscalar (n)
       || (length (size (n)) == length (dims) && all (size (n) == dims)))
diff --git a/scripts/statistics/distributions/unifrnd.m b/scripts/statistics/distributions/unifrnd.m
--- a/scripts/statistics/distributions/unifrnd.m
+++ b/scripts/statistics/distributions/unifrnd.m
@@ -31,45 +31,45 @@
 ## Description: Random deviates from the uniform distribution
 
 function rnd = unifrnd (a, b, r, c)
 
   if (nargin > 1)
     if (!isscalar(a) || !isscalar(b)) 
       [retval, a, b] = common_size (a, b);
       if (retval > 0)
-	error ("unifrnd: a and b must be of common size or scalar");
+        error ("unifrnd: a and b must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("unifrnd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("unifrnd: c must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (a) != 1)
-	&& (length (size (a)) != length (sz) || any (size (a) != sz)))
+        && (length (size (a)) != length (sz) || any (size (a) != sz)))
       error ("unifrnd: a and b must be scalar or of size [r, c]");
     endif
   elseif (nargin == 3)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("unifrnd: r must be a positive integer or vector");
     endif
 
     if (any (size (a) != 1)
-	&& (length (size (a)) != length (sz) || any (size (a) != sz)))
+        && (length (size (a)) != length (sz) || any (size (a) != sz)))
       error ("unifrnd: a and b must be scalar or of size sz");
     endif
   elseif (nargin == 2)
     sz = size(a);
   else
     print_usage ();
   endif
 
diff --git a/scripts/statistics/distributions/wblpdf.m b/scripts/statistics/distributions/wblpdf.m
--- a/scripts/statistics/distributions/wblpdf.m
+++ b/scripts/statistics/distributions/wblpdf.m
@@ -66,18 +66,18 @@ function pdf = wblpdf (x, scale, shape)
   if (any (k))
     pdf(k) = 0;
   endif
 
   k = find ((x > 0) & (x < Inf) & ok);
   if (any (k))
     if (isscalar (shape) && isscalar (scale))
       pdf(k) = (shape .* (scale .^ -shape)
-		.* (x(k) .^ (shape - 1))
-		.* exp(- (x(k) / scale) .^ shape));
+                .* (x(k) .^ (shape - 1))
+                .* exp(- (x(k) / scale) .^ shape));
     else
       pdf(k) = (shape(k) .* (scale(k) .^ -shape(k))
-		.* (x(k) .^ (shape(k) - 1))
-		.* exp(- (x(k) ./ scale(k)) .^ shape(k)));
+                .* (x(k) .^ (shape(k) - 1))
+                .* exp(- (x(k) ./ scale(k)) .^ shape(k)));
     endif
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/wblrnd.m b/scripts/statistics/distributions/wblrnd.m
--- a/scripts/statistics/distributions/wblrnd.m
+++ b/scripts/statistics/distributions/wblrnd.m
@@ -32,47 +32,47 @@
 ## Description: Random deviates from the Weibull distribution
 
 function rnd = wblrnd (scale, shape, r, c)
 
   if (nargin > 1)
     if (!isscalar(shape) || !isscalar(scale)) 
       [retval, shape, scale] = common_size (shape, scale);
       if (retval > 0)
-	error ("wblrnd: shape and scale must be of common size or scalar");
+        error ("wblrnd: shape and scale must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("wblrnd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("wblrnd: c must be a positive integer");
     endif
     sz = [r, c];
 
     if (any (size (scale) != 1) && 
-	((length (size (scale)) != length (sz))
-	 || any (size (scale) != sz)))
+        ((length (size (scale)) != length (sz))
+         || any (size (scale) != sz)))
       error ("wblrnd: shape and scale must be scalar or of size [r, c]");
     endif
   elseif (nargin == 3)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("wblrnd: r must be a positive integer or vector");
     endif
 
     if (any (size (scale) != 1) && 
-	((length (size (scale)) != length (sz))
-	 || any (size (scale) != sz)))
+        ((length (size (scale)) != length (sz))
+         || any (size (scale) != sz)))
       error ("wblrnd: shape and scale must be scalar or of size sz");
     endif
   elseif (nargin == 2)
     sz = size(shape);
   else
     print_usage ();
   endif
 
diff --git a/scripts/strings/cstrcat.m b/scripts/strings/cstrcat.m
--- a/scripts/strings/cstrcat.m
+++ b/scripts/strings/cstrcat.m
@@ -45,21 +45,21 @@
 
 function st = cstrcat (varargin)
 
   if (nargin > 0)
 
     if (iscellstr (varargin))
       ## All arguments are character strings.
       unwind_protect
-	tmp = warning ("query", "Octave:empty-list-elements");
-	warning ("off", "Octave:empty-list-elements");
-	st = [varargin{:}];
+        tmp = warning ("query", "Octave:empty-list-elements");
+        warning ("off", "Octave:empty-list-elements");
+        st = [varargin{:}];
       unwind_protect_cleanup
-	warning (tmp.state, "Octave:empty-list-elements");
+        warning (tmp.state, "Octave:empty-list-elements");
       end_unwind_protect
     else
       error ("cstrcat: expecting arguments to character strings");
     endif
   else
     print_usage ();
   endif
 
diff --git a/scripts/strings/deblank.m b/scripts/strings/deblank.m
--- a/scripts/strings/deblank.m
+++ b/scripts/strings/deblank.m
@@ -35,26 +35,26 @@ function s = deblank (s)
   endif
 
   char_arg = ischar (s);
 
   if (char_arg || isnumeric (s))
 
     if (! isempty (s))
       if (char_arg)
-	k = find (! isspace (s) & s != "\0");
+        k = find (! isspace (s) & s != "\0");
       else
-	warning ("deblank: expecting character string argument")
-	k = find (s != 0);
+        warning ("deblank: expecting character string argument")
+        k = find (s != 0);
       endif
 
       if (isempty (k))
-	s = resize (s, 0, 0);
+        s = resize (s, 0, 0);
       else
-	s = s(:,1:ceil (max (k) / rows (s)));
+        s = s(:,1:ceil (max (k) / rows (s)));
       endif
     endif
 
   elseif (iscell(s))
 
     s = cellfun (@deblank, s, "UniformOutput", false);
 
   else
diff --git a/scripts/strings/findstr.m b/scripts/strings/findstr.m
--- a/scripts/strings/findstr.m
+++ b/scripts/strings/findstr.m
@@ -77,18 +77,18 @@ function v = findstr (s, t, overlap)
     ## length two target: find first at i and second at i+1
     v = find (s(1:l_s-1) == t(1) & s(2:l_s) == t(2));
     
   else
     ## length three or more: match the first three by find then go through
     ## the much smaller list to determine which of them are real matches
     limit = l_s - l_t + 1;
     v = find (s(1:limit) == t(1)
-	      & s(2:limit+1) == t(2)
-	      & s (3:limit+2) == t(3));
+              & s(2:limit+1) == t(2)
+              & s (3:limit+2) == t(3));
   endif
 
   ## Need to search the index vector if our find was too short
   ## (target length > 3), or if we don't allow overlaps.  Note though
   ## that there cannot be any overlaps if the first character in the
   ## target is different from the remaining characters in the target,
   ## so a single character, two different characters, or first character
   ## different from the second two don't need to be searched.
@@ -98,29 +98,29 @@ function v = findstr (s, t, overlap)
       t = t.';
     endif
     
     ## determine which ones to keep
     keep = zeros (size (v));
     ind = 0:l_t-1;
     if (overlap)
       for idx = 1:length (v)
-	keep(idx) = all (s(v(idx) + ind) == t);
+        keep(idx) = all (s(v(idx) + ind) == t);
       endfor
     else
       ## First possible position for next non-overlapping match.
       next = 1;
       for idx = 1:length (v)
-	if (v(idx) >= next && s(v(idx) + ind) == t)
-	  keep(idx) = 1;
-	  ## Skip to the next possible match position.
-	  next = v(idx) + l_t;
-	else
-	  keep(idx) = 0;
-	endif
+        if (v(idx) >= next && s(v(idx) + ind) == t)
+          keep(idx) = 1;
+          ## Skip to the next possible match position.
+          next = v(idx) + l_t;
+        else
+          keep(idx) = 0;
+        endif
       endfor
     endif
     if (! isempty (v))
       v = v(find (keep));
     endif
   endif
 
   if (isempty (v))
diff --git a/scripts/strings/isstrprop.m b/scripts/strings/isstrprop.m
--- a/scripts/strings/isstrprop.m
+++ b/scripts/strings/isstrprop.m
@@ -80,41 +80,41 @@
 ## islower, isprint, ispunct, isspace, isupper, isxdigit}
 ## @end deftypefn
 
 function retval = isstrprop (str, pred)
 
   if (nargin == 2)
     switch (pred)
       case "alpha"
-	retval = isalpha (str);
+        retval = isalpha (str);
       case {"alnum", "alphanum"}
-	retval = isalnum (str);
+        retval = isalnum (str);
       case "ascii"
-	retval = isascii (str);
+        retval = isascii (str);
       case "cntrl"
-	retval = iscntrl (str);
+        retval = iscntrl (str);
       case "digit"
-	retval = isdigit (str);
+        retval = isdigit (str);
       case {"graph", "graphic"}
-	retval = isgraph (str);
+        retval = isgraph (str);
       case "lower"
-	retval = islower (str);
+        retval = islower (str);
       case "print"
-	retval = isprint (str);
+        retval = isprint (str);
       case "punct"
-	retval = ispunct (str);
+        retval = ispunct (str);
       case {"space", "wspace"}
-	retval = isspace (str);
+        retval = isspace (str);
       case "upper"
-	retval = isupper (str);
+        retval = isupper (str);
       case "xdigit"
-	retval = isxdigit (str);
+        retval = isxdigit (str);
       otherwise
-	error ("isstrprop: invalid predicate");
+        error ("isstrprop: invalid predicate");
     endswitch
   else
     print_usage ();
   endif
 
 endfunction
 
 %!error <invalid predicate> isstrprop ("abc123", "foo");
diff --git a/scripts/strings/regexptranslate.m b/scripts/strings/regexptranslate.m
--- a/scripts/strings/regexptranslate.m
+++ b/scripts/strings/regexptranslate.m
@@ -53,22 +53,22 @@ function y = regexptranslate (op, x)
   if nargin != 2
     print_usage ();
   endif 
   
   if (ischar (op))
     op = tolower (op);
     if (strcmp ("wildcard", op))
       y = regexprep (regexprep (regexprep (x, "\\.", "\\."), "\\*",
-				".*"), "\\?", ".");
+                                ".*"), "\\?", ".");
     elseif (strcmp ("escape", op))
       ch = {'\$', '\.', '\?', '\[', '\]'};
       y = x;
       for i = 1 : length (ch)
-	y = regexprep (y, ch{i}, ch{i});
+        y = regexprep (y, ch{i}, ch{i});
       endfor
     else
       error ("regexptranslate: unexpected operation");
     endif
   else
     error ("regexptranslate: expecting operation to be a string");
   endif
 endfunction
diff --git a/scripts/strings/strtok.m b/scripts/strings/strtok.m
--- a/scripts/strings/strtok.m
+++ b/scripts/strings/strtok.m
@@ -53,24 +53,24 @@ function [tok, rem] = strtok (str, delim
 
   if (isempty (str))
     tok = rem = "";
   elseif (length (delim) > 3)
     start = 1;
     len = length (str);
     while (start <= len)
       if (all (str(start) != delim))
-	break; 
+        break; 
       endif
       start++;
     endwhile
     stop = start;
     while (stop <= len)
       if (any (str(stop) == delim))
-	break; 
+        break; 
       endif
       stop++;
     endwhile
     tok = str(start:stop-1);
     rem = str(stop:len);
   else
     if (length (delim) == 1)
       idx = find (str == delim);
@@ -81,21 +81,21 @@ function [tok, rem] = strtok (str, delim
     endif
     if (isempty (idx))
       tok = str;
       rem = "";
     else
       ## Find first non-leading delimiter.
       skip = find (idx(:)' != 1:length(idx));
       if (isempty (skip))
-      	tok = str(idx(length(idx))+1:length(str));
-      	rem = "";
+        tok = str(idx(length(idx))+1:length(str));
+        rem = "";
       else
-      	tok = str(skip(1):idx(skip(1))-1);
-      	rem = str(idx(skip(1)):length(str));
+        tok = str(skip(1):idx(skip(1))-1);
+        rem = str(idx(skip(1)):length(str));
       endif
     endif
   endif
 
 endfunction
 
 %!demo
 %! strtok("this is the life")
diff --git a/scripts/testfun/assert.m b/scripts/testfun/assert.m
--- a/scripts/testfun/assert.m
+++ b/scripts/testfun/assert.m
@@ -62,20 +62,20 @@ function assert (cond, varargin)
   for i = 2:rows (argn)
     in = cstrcat (in, ",", deblank (argn(i,:)));
   endfor
   in = cstrcat ("(", in, ")");
 
   if (nargin == 1 || (nargin > 1 && islogical (cond) && ischar (varargin{1})))
     if ((! isnumeric (cond) && ! islogical (cond)) || ! all (cond(:)))
       if (nargin == 1)
-	## Say which elements failed?
-	error ("assert %s failed", in);
+        ## Say which elements failed?
+        error ("assert %s failed", in);
       else
-	error (varargin{:});
+        error (varargin{:});
       endif
     endif  
   else
     if (nargin < 2 || nargin > 3)
       print_usage ();
     endif
 
     expected = varargin {1};
@@ -93,56 +93,56 @@ function assert (cond, varargin)
     iserror = 0;
 
 
     if (ischar (expected))
       iserror = (! ischar (cond) || ! strcmp (cond, expected));
 
     elseif (iscell (expected))
       if (! iscell (cond) || any (size (cond) != size (expected)))
-	iserror = 1;
+        iserror = 1;
       else
-	try
-	  for i = 1:length (expected(:))
-	    assert (cond{i}, expected{i}, tol);
-	  endfor
-	catch
-	  iserror = 1;
-	end_try_catch
+        try
+          for i = 1:length (expected(:))
+            assert (cond{i}, expected{i}, tol);
+          endfor
+        catch
+          iserror = 1;
+        end_try_catch
       endif
 
     elseif (isstruct (expected))
       if (! isstruct (cond) || any (size (cond) != size (expected))
-	  || rows (fieldnames (cond)) != rows (fieldnames (expected)))
-	iserror = 1;
+          || rows (fieldnames (cond)) != rows (fieldnames (expected)))
+        iserror = 1;
       else
-	try
-	  empty = numel (cond) == 0;
-	  normal = numel (cond) == 1;
-	  for [v, k] = cond
-	    if (! isfield (expected, k))
-	      error ();
-	    endif
-	    if (empty)
-	      v = cell (1, 0);
-	    endif
-	    if (normal)
-	      v = {v};
-	    else
-	      v = v(:)';
-	    endif
-	    assert (v, {expected.(k)}, tol);
-	  endfor
-	catch
-	  iserror = 1;
-	end_try_catch
+        try
+          empty = numel (cond) == 0;
+          normal = numel (cond) == 1;
+          for [v, k] = cond
+            if (! isfield (expected, k))
+              error ();
+            endif
+            if (empty)
+              v = cell (1, 0);
+            endif
+            if (normal)
+              v = {v};
+            else
+              v = v(:)';
+            endif
+            assert (v, {expected.(k)}, tol);
+          endfor
+        catch
+          iserror = 1;
+        end_try_catch
       endif
 
     elseif (ndims (cond) != ndims (expected)
-	    || any (size (cond) != size (expected)))
+            || any (size (cond) != size (expected)))
       iserror = 1;
       coda = "Dimensions don't match";
 
     else
       if (nargin < 3)
         ## Without explicit tolerance, be more strict.
         if (! strcmp(class (cond), class (expected)))
           iserror = 1;
diff --git a/scripts/testfun/example.m b/scripts/testfun/example.m
--- a/scripts/testfun/example.m
+++ b/scripts/testfun/example.m
@@ -40,21 +40,21 @@ function [code_r, idx_r] = example (name
   if (nargin < 2)
     n = 0;
   endif
 
   [code, idx] = test (name, "grabdemo");
   if (nargout > 0)
     if (n > 0)
       if (n <= length (idx))
-      	code_r = code(idx(n):idx(n+1)-1);
-      	idx_r = [1, length(code_r)+1];
+        code_r = code(idx(n):idx(n+1)-1);
+        idx_r = [1, length(code_r)+1];
       else
-	code_r = "";
-	idx_r = [];
+        code_r = "";
+        idx_r = [];
       endif
     else
       code_r = code;
       idx_r = idx;
     endif
   else
     if (n > 0)
       doidx = n;
@@ -82,13 +82,13 @@ endfunction
 %!demo
 %! t=0:0.01:2*pi; x=sin(t);
 %! plot(t,x)
 
 %!assert (example('example',1), "\n example('example');");
 %!test
 %! [code, idx] = example('example');
 %! assert (code, ... 
-%!	   "\n example('example');\n t=0:0.01:2*pi; x=sin(t);\n plot(t,x)")
+%!         "\n example('example');\n t=0:0.01:2*pi; x=sin(t);\n plot(t,x)")
 %! assert (idx, [1, 22, 59]);
 
 %!error example;
 %!error example('example',3,5)
diff --git a/scripts/testfun/fail.m b/scripts/testfun/fail.m
--- a/scripts/testfun/fail.m
+++ b/scripts/testfun/fail.m
@@ -86,21 +86,21 @@ function ret = fail (code, pattern, warn
       evalin ("caller", sprintf ("%s;", code));
       ## printf("lastwarn after %s: %s\n",code,lastwarn);
       ## Retrieve new warnings.
       err = lastwarn ();
       warning (state.state, "quiet");
       if (isempty (err))
         msg = sprintf ("expected warning <%s> but got none", pattern); 
       else
-	## Transform "warning: ...\n" to "...".
+        ## Transform "warning: ...\n" to "...".
         err([1:9, end]) = [];
         if (! isempty (regexp (err, pattern, "once")))
-	  return;
-	endif
+          return;
+        endif
         msg = sprintf ("expected warning <%s>\nbut got <%s>", pattern, err);
       endif
     catch
       warning (state.state, "quiet");
       err = lasterr;
       ## Transform "error: ...\n", to "...".
       err([1:7, end]) = [];
       msg = sprintf ("expected warning <%s> but got error <%s>", pattern, err);
@@ -112,17 +112,17 @@ function ret = fail (code, pattern, warn
       evalin ("caller", sprintf ("%s;", code));
       msg = sprintf ("expected error <%s> but got none", pattern);
     catch
       err = lasterr ();
       if (strcmp (err(1:7), "error:"))
          err([1:6, end]) = []; # transform "error: ...\n", to "..."
       endif
       if (! isempty (regexp (err, pattern, "once")))
-	return;
+        return;
       endif
       msg = sprintf ("expected error <%s>\nbut got <%s>", pattern, err);
     end_try_catch
   endif
 
   ## If we get here, then code didn't fail or error didn't match.
   error (msg);
 
diff --git a/scripts/testfun/rundemos.m b/scripts/testfun/rundemos.m
--- a/scripts/testfun/rundemos.m
+++ b/scripts/testfun/rundemos.m
@@ -27,19 +27,19 @@ function rundemos (directory)
   if (nargin == 0)
     dirs = strsplit (path (), pathsep ());
   elseif (nargin == 1)
     if (is_absolute_filename (directory))
       dirs = {directory};
     else
       fullname = find_dir_in_path (directory);
       if (! isempty (fullname))
-	dirs = {fullname};
+        dirs = {fullname};
       else
-	error ("rundemos: expecting argument to be a directory name");
+        error ("rundemos: expecting argument to be a directory name");
       endif
     endif
   else
     print_usage ();
   endif
 
   for i = 1:numel (dirs)
     d = dirs{i};
@@ -51,20 +51,20 @@ endfunction
 function run_all_demos (directory)
   dirinfo = dir (directory);
   flist = {dirinfo.name};
   for i = 1:numel (flist)
     f = flist{i};
     if (length (f) > 2 && strcmp (f((end-1):end), ".m"))
       f = fullfile (directory, f);
       if (has_demos (f))
-	demo (f);
-	if (i != numel (flist))
-	  input ("Press <enter> to continue: ", "s");
-	endif
+        demo (f);
+        if (i != numel (flist))
+          input ("Press <enter> to continue: ", "s");
+        endif
       endif
     endif
   endfor
 endfunction
 
 function retval = has_demos (f)
   fid = fopen (f);
   if (f < 0)
diff --git a/scripts/testfun/runtests.m b/scripts/testfun/runtests.m
--- a/scripts/testfun/runtests.m
+++ b/scripts/testfun/runtests.m
@@ -27,19 +27,19 @@ function runtests (directory)
   if (nargin == 0)
     dirs = strsplit (path (), pathsep ());
   elseif (nargin == 1)
     if (is_absolute_filename (directory))
       dirs = {directory};
     else
       fullname = find_dir_in_path (directory);
       if (! isempty (fullname))
-	dirs = {fullname};
+        dirs = {fullname};
       else
-	error ("runtests: expecting argument to be a directory name");
+        error ("runtests: expecting argument to be a directory name");
       endif
     endif
   else
     print_usage ();
   endif
 
   for i = 1:numel (dirs)
     d = dirs{i};
diff --git a/scripts/testfun/speed.m b/scripts/testfun/speed.m
--- a/scripts/testfun/speed.m
+++ b/scripts/testfun/speed.m
@@ -219,22 +219,22 @@ function [__order, __test_n, __tnew, __t
       eval (cstrcat ("__t3 = time();", __f1, "; __t3 = time()-__t3;"));
       __t = min ([__t, __t2, __t3]);
     endif
     __tnew(k) = __t;
 
     if (! isempty (__f2))
       eval (cstrcat ("__t = time();", __f2, "; __v2=ans; __t = time()-__t;"));
       if (__t < 0.25)
-      	eval (cstrcat ("__t2 = time();", __f2, "; __t2 = time()-__t2;"));
-      	eval (cstrcat ("__t3 = time();", __f2, "; __t3 = time()-__t3;"));
+        eval (cstrcat ("__t2 = time();", __f2, "; __t2 = time()-__t2;"));
+        eval (cstrcat ("__t3 = time();", __f2, "; __t3 = time()-__t3;"));
       endif
       __torig(k) = __t;
       if (! isinf(__tol))
-      	assert (__v1, __v2, __tol);
+        assert (__v1, __v2, __tol);
       endif
     endif
   endfor
   
   ## Drop times of zero.
   if (! isempty (__f2))
     zidx = (__tnew < 100*eps |  __torig < 100*eps);
     __test_n(zidx) = [];
@@ -259,30 +259,30 @@ function [__order, __test_n, __tnew, __t
   
   if (doplot)
     figure;
   endif
 
   if (doplot && ! isempty (__f2))
     subplot (1, 2, 1);
     semilogx (__test_n, __torig./__tnew, 
-	      cstrcat ("-*r;", strrep (__f1, ";", "."), "/",
-		      strrep (__f2, ";", "."), ";"),
-	       __test_n, __tnew./__torig,
-	      cstrcat ("-*g;", strrep (__f2, ";", "."), "/",
-		      strrep (__f1, ";", "."), ";"));
+              cstrcat ("-*r;", strrep (__f1, ";", "."), "/",
+                      strrep (__f2, ";", "."), ";"),
+               __test_n, __tnew./__torig,
+              cstrcat ("-*g;", strrep (__f2, ";", "."), "/",
+                      strrep (__f1, ";", "."), ";"));
     xlabel ("test length");
     title (__f1);
     ylabel ("speedup ratio");
 
     subplot (1, 2, 2);
     loglog (__test_n, __tnew*1000,
-	    cstrcat ("*-g;", strrep (__f1, ";", "."), ";"), 
-	    __test_n, __torig*1000,
-	    cstrcat ("*-r;", strrep (__f2,";","."), ";"));
+            cstrcat ("*-g;", strrep (__f1, ";", "."), ";"), 
+            __test_n, __torig*1000,
+            cstrcat ("*-r;", strrep (__f2,";","."), ";"));
   
     xlabel ("test length");
     ylabel ("best execution time (ms)");
     title (cstrcat ("init: ", __init));
 
     ratio = mean (__torig ./ __tnew);
     printf ("\n\nMean runtime ratio = %.3g for '%s' vs '%s'\n",
             ratio, __f2, __f1);
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -100,17 +100,17 @@ function [__ret1, __ret2, __ret3, __ret4
   __batch = (! isempty (__fid));
 
   ## Decide if error messages should be collected.
   __close_fid = 0;
   if (__batch)
     if (ischar (__fid))
       __fid = fopen (__fid, "wt");
       if (__fid < 0)
-	error ("could not open log file");
+        error ("could not open log file");
       endif
       __close_fid = 1;
     endif
     fprintf (__fid, "%sprocessing %s\n", __signal_file, __name);
     fflush (__fid);
   else
     __fid = stdout;
   endif
@@ -171,17 +171,17 @@ function [__ret1, __ret2, __ret3, __ret4
   if (isempty (__file))
     if (__grabdemo)
       __ret1 = "";
       __ret2 = [];
     else
       fprintf (__fid, "%s%s does not exist in path\n", __signal_empty, __name);
       fflush (__fid);
       if (nargout > 0)
-	__ret1 = __ret2 = 0;
+        __ret1 = __ret2 = 0;
       endif
     endif
     if (__close_fid)
       fclose(__fid);
     endif
     return;
   endif
 
@@ -191,17 +191,17 @@ function [__ret1, __ret2, __ret3, __ret4
   if (isempty (__body))
     if (__grabdemo)
       __ret1 = "";
       __ret2 = [];
     else
       fprintf (__fid, "%s%s has no tests available\n", __signal_empty, __file);
       fflush (__fid);
       if (nargout > 0)
-	__ret1 = __ret2 = 0;
+        __ret1 = __ret2 = 0;
       endif
     endif
     if (__close_fid)
       fclose(__fid);
     endif
     return;
   else
     ## Add a dummy comment block to the end for ease of indexing.
@@ -261,78 +261,78 @@ function [__ret1, __ret2, __ret3, __ret4
     ## this __grabdemo mode, the demo block processor grabs all block
     ## types and skips those which aren't demo blocks.
 
     __isdemo = strcmp (__type, "demo");
     if (__grabdemo || __isdemo)
       __istest = 0;
 
       if (__grabdemo && __isdemo)
-	if (isempty(__demo_code))
-	  __demo_code = __code;
-	  __demo_idx = [1, length(__demo_code)+1];
-	else
-	  __demo_code = cstrcat(__demo_code, __code);
-	  __demo_idx = [__demo_idx, length(__demo_code)+1];
-	endif
+        if (isempty(__demo_code))
+          __demo_code = __code;
+          __demo_idx = [1, length(__demo_code)+1];
+        else
+          __demo_code = cstrcat(__demo_code, __code);
+          __demo_idx = [__demo_idx, length(__demo_code)+1];
+        endif
 
       elseif (__rundemo && __isdemo)
-      	try
-	  ## process the code in an environment without variables
-      	  eval (sprintf ("function __test__()\n%s\nendfunction", __code));
-	  __test__;
-	  input ("Press <enter> to continue: ", "s");
-      	catch
-	  __success = 0;
-	  __msg = sprintf ("%sdemo failed\n%s",  __signal_fail, __error_text__);
-      	end_try_catch
-      	clear __test__;
+        try
+          ## process the code in an environment without variables
+          eval (sprintf ("function __test__()\n%s\nendfunction", __code));
+          __test__;
+          input ("Press <enter> to continue: ", "s");
+        catch
+          __success = 0;
+          __msg = sprintf ("%sdemo failed\n%s",  __signal_fail, __error_text__);
+        end_try_catch
+        clear __test__;
 
       endif
       ## Code already processed.
       __code = "";
       
 ### SHARED
 
     elseif (strcmp (__type, "shared"))
       __istest = 0;
 
       ## Separate initialization code from variables.
       __idx = find (__code == "\n");
       if (isempty (__idx))
-	__vars = __code;
-	__code = "";
+        __vars = __code;
+        __code = "";
       else
-      	__vars = __code (1:__idx(1)-1);
-      	__code = __code (__idx(1):length(__code));
+        __vars = __code (1:__idx(1)-1);
+        __code = __code (__idx(1):length(__code));
       endif
       
       ## Strip comments off the variables.
       __idx = find (__vars == "%" | __vars == "#");
       if (! isempty (__idx))
-	__vars = __vars(1:__idx(1)-1);
+        __vars = __vars(1:__idx(1)-1);
       endif
       
       ## Assign default values to variables.
       try
-	__vars = deblank (__vars);
-	if (! isempty (__vars))
-	  eval (cstrcat (strrep (__vars, ",", "=[];"), "=[];"));
-	  __shared = __vars;
-	  __shared_r = cstrcat ("[ ", __vars, "] = ");
-      	else
-	  __shared = " ";
-	  __shared_r = " ";
-      	endif
+        __vars = deblank (__vars);
+        if (! isempty (__vars))
+          eval (cstrcat (strrep (__vars, ",", "=[];"), "=[];"));
+          __shared = __vars;
+          __shared_r = cstrcat ("[ ", __vars, "] = ");
+        else
+          __shared = " ";
+          __shared_r = " ";
+        endif
       catch
-	## Couldn't declare, so don't initialize.
-	__code = "";
-	__success = 0;
-	__msg = sprintf ("%sshared variable initialization failed\n",
-		         __signal_fail);
+        ## Couldn't declare, so don't initialize.
+        __code = "";
+        __success = 0;
+        __msg = sprintf ("%sshared variable initialization failed\n",
+                         __signal_fail);
       end_try_catch
 
       ## Clear shared function definitions.
       eval (__clear, "");
       __clear = "";
       
       ## Initialization code will be evaluated below.
     
@@ -340,27 +340,27 @@ function [__ret1, __ret2, __ret3, __ret4
 
     elseif (strcmp (__type, "function"))
       __istest = 0;
       persistent __fn = 0;
       __name_position = function_name (__block);
       if (isempty (__name_position))
         __success = 0;
         __msg = sprintf ("%stest failed: missing function name\n",
-			 __signal_fail);
+                         __signal_fail);
       else
         __name = __block(__name_position(1):__name_position(2));
         __code = __block;
         try
           eval(__code); ## Define the function
           __clear = sprintf ("%sclear %s;\n", __clear, __name);
         catch
           __success = 0;
           __msg = sprintf ("%stest failed: syntax error\n%s",
-			   __signal_fail, __error_text__);
+                           __signal_fail, __error_text__);
         end_try_catch
       endif
       __code = "";
       
 ### ASSERT/FAIL
 
     elseif (strcmp (__type, "assert") || strcmp (__type, "fail"))
       __istest = 1;
@@ -375,91 +375,91 @@ function [__ret1, __ret2, __ret3, __ret4
       __warning = strcmp (__type, "warning");
       [__pattern, __id, __code] = getpattern (__code);
       if (__id)
         __patstr = ["id=",__id];
       else
         __patstr = ["<",__pattern,">"];
       endif
       try
-      	eval (sprintf ("function __test__(%s)\n%s\nendfunction",
-		       __shared, __code));
+        eval (sprintf ("function __test__(%s)\n%s\nendfunction",
+                       __shared, __code));
       catch
-      	__success = 0;
-      	__msg = sprintf ("%stest failed: syntax error\n%s",
-			 __signal_fail, __error_text__);
+        __success = 0;
+        __msg = sprintf ("%stest failed: syntax error\n%s",
+                         __signal_fail, __error_text__);
       end_try_catch
       
       if (__success)
         __success = 0;
-	__warnstate = warning ("query", "quiet");
-	warning ("on", "quiet");
-      	try
- 	  eval (sprintf ("__test__(%s);", __shared));
+        __warnstate = warning ("query", "quiet");
+        warning ("on", "quiet");
+        try
+          eval (sprintf ("__test__(%s);", __shared));
           if (! __warning)
-       	    __msg = sprintf ("%sexpected %s but got no error\n",
- 			     __signal_fail, __patstr);
-	  else
+            __msg = sprintf ("%sexpected %s but got no error\n",
+                             __signal_fail, __patstr);
+          else
             if (! isempty (__id))
               [~, __err] = lastwarn;
               __mismatch = ! strcmp (__err, __id);
             else
               __err = trimerr (lastwarn, "warning");
               __mismatch = isempty (regexp (__err, __pattern, "once"));
             endif
             warning (__warnstate.state, "quiet");
             if (isempty (__err))
               __msg = sprintf ("%sexpected %s but got no warning\n",
-			     __signal_fail, __patstr);
+                             __signal_fail, __patstr);
             elseif (__mismatch)
               __msg = sprintf ("%sexpected %s but got %s\n",
- 			       __signal_fail, __patstr, __err);
+                               __signal_fail, __patstr, __err);
             else
               __success = 1;
             endif
-	  endif
+          endif
 
-      	catch
+        catch
           if (! isempty (__id))
             [~, __err] = lasterr;
             __mismatch = ! strcmp (__err, __id);
           else
             __err = trimerr (lasterr, "error");
             __mismatch = isempty (regexp (__err, __pattern, "once"));
           endif
           warning (__warnstate.state, "quiet");
           if (__warning)
             __msg = sprintf ("%sexpected warning %s but got error %s\n",
-			     __signal_fail, __patstr, __err);
-	  elseif (__mismatch)
+                             __signal_fail, __patstr, __err);
+          elseif (__mismatch)
             __msg = sprintf ("%sexpected %s but got %s\n",
-			     __signal_fail, __patstr, __err);
+                             __signal_fail, __patstr, __err);
           else
-	    __success = 1;
+            __success = 1;
           endif
-      	end_try_catch
-      	clear __test__;
+        end_try_catch
+        clear __test__;
       endif
       ## Code already processed.
       __code = "";
       
 ### TESTIF
 
     elseif (strcmp (__type, "testif"))
       [__e, __feat] = regexp (__code, '^\s*([^\s]+)', 'end', 'tokens');
       if (isempty (findstr (octave_config_info ("DEFS"), __feat{1}{1})))
         __xskip++;
-	__success = 0;
-	__istest = 0;
-	## Skip the code.
-	__code = "";
-	__msg = sprintf ("%sskipped test\n", __signal_skip);
+        __success = 0;
+        __istest = 0;
+        ## Skip the code.
+        __code = "";
+        __msg = sprintf ("%sskipped test\n", __signal_skip);
       else
         __istest = 1;
-	__code = __code(__e + 1 : end);
+        __code = __code(__e + 1 : end);
       endif
 
 ### TEST
 
     elseif (strcmp (__type, "test") || strcmp (__type, "xtest"))
       __istest = 1;
       ## Code will be evaluated below.
 
@@ -476,80 +476,80 @@ function [__ret1, __ret2, __ret3, __ret4
       __success = 0;
       __msg = sprintf ("%sunknown test type!\n", __signal_fail);
       __code = ""; # skip the code
     endif
 
     ## evaluate code for test, shared, and assert.
     if (! isempty(__code))
       try
-      	eval (sprintf ("function %s__test__(%s)\n%s\nendfunction",
-		       __shared_r,__shared, __code));
-	eval (sprintf ("%s__test__(%s);", __shared_r, __shared));
+        eval (sprintf ("function %s__test__(%s)\n%s\nendfunction",
+                       __shared_r,__shared, __code));
+        eval (sprintf ("%s__test__(%s);", __shared_r, __shared));
       catch
         if (strcmp (__type, "xtest"))
            __msg = sprintf ("%sknown failure\n%s", __signal_fail, __error_text__);
-	   __xfail++;
+           __xfail++;
         else
            __msg = sprintf ("%stest failed\n%s", __signal_fail, __error_text__);
-	   __success = 0;
+           __success = 0;
         endif
-	if (isempty (__error_text__))
-	  error ("empty error text, probably Ctrl-C --- aborting"); 
-	endif
+        if (isempty (__error_text__))
+          error ("empty error text, probably Ctrl-C --- aborting"); 
+        endif
       end_try_catch
       clear __test__;
     endif
     
     ## All done.  Remember if we were successful and print any messages.
     if (! isempty (__msg))
       ## Make sure the user knows what caused the error.
       if (! __verbose)
-      	fprintf (__fid, "%s%s\n", __signal_block, __block);
-	fflush (__fid);
+        fprintf (__fid, "%s%s\n", __signal_block, __block);
+        fflush (__fid);
       endif
       fputs (__fid, __msg);
       fputs (__fid, "\n");
       fflush (__fid);
       ## Show the variable context.
       if (! strcmp (__type, "error") && ! strcmp (__type, "testif")
-	  && ! all (__shared == " "))
-	fputs (__fid, "shared variables ");
-	eval (sprintf ("fdisp(__fid,bundle(%s));", __shared)); 
-	fflush (__fid);
+          && ! all (__shared == " "))
+        fputs (__fid, "shared variables ");
+        eval (sprintf ("fdisp(__fid,bundle(%s));", __shared)); 
+        fflush (__fid);
       endif
     endif
     if (__success == 0)
       __all_success = 0;
       ## Stop after one error if not in batch mode.
       if (! __batch)
-    	if (nargout > 0)
-	  __ret1 = __ret2 = 0;
-	endif
-	if (__close_fid)
-	  fclose(__fid);
-	endif
-      	return;
+        if (nargout > 0)
+          __ret1 = __ret2 = 0;
+        endif
+        if (__close_fid)
+          fclose(__fid);
+        endif
+        return;
       endif
     endif
     __tests += __istest;
     __successes += __success * __istest;
   endfor
   eval (__clear, "");
 
   if (nargout == 0)
     if (__tests || __xfail || __xskip)
       if (__xfail)
-	printf ("PASSES %d out of %d tests (%d expected failures)\n",
-		__successes, __tests, __xfail);
+        printf ("PASSES %d out of %d tests (%d expected failures)\n",
+                __successes, __tests, __xfail);
       else
-	printf ("PASSES %d out of %d tests\n", __successes, __tests);
+        printf ("PASSES %d out of %d tests\n", __successes, __tests);
       endif
       if (__xskip)
-	printf ("Skipped %d tests due to missing features\n", __xskip);
+        printf ("Skipped %d tests due to missing features\n", __xskip);
       endif
     else
       printf ("%s%s has no tests available\n", __signal_empty, __file);
     endif
   elseif (__grabdemo)
     __ret1 = __demo_code;
     __ret2 = __demo_idx;
   elseif (nargout == 1)
@@ -577,17 +577,17 @@ function pos = function_name (def)
   right = find (def == "(", 1);
   if (isempty (right))
     return;
   endif
   right = find (def(1:right-1) != " ", 1, "last");
 
   ## Find the beginning of the name.
   left = max ([find(def(1:right)==" ", 1, "last"), ...
-	       find(def(1:right)=="=", 1, "last")]);
+               find(def(1:right)=="=", 1, "last")]);
   if (isempty (left))
     return;
   endif
   left++;
 
   ## Return the end points of the name.
   pos = [left, right];
 endfunction
diff --git a/scripts/time/datestr.m b/scripts/time/datestr.m
--- a/scripts/time/datestr.m
+++ b/scripts/time/datestr.m
@@ -193,33 +193,33 @@ function retval = datestr (date, f, p)
     v = datevec (date, p);
   else
     v = [];
     if (columns (date) == 6)
       ## Make sure that the input really is a datevec.
       maxdatevec = [Inf, 12, 31, 23, 59, 60];
       for i = 1:numel (maxdatevec)
         if (any (date(:,i) > maxdatevec(i)) || 
-	    (i != 6 && any (floor (date(:, i)) != date (:, i))))
+            (i != 6 && any (floor (date(:, i)) != date (:, i))))
           v = datevec (date, p);
           break;
         endif
       endfor
     endif
     if (isempty (v))
       v = date;
     endif
   endif
 
   for i = 1:(rows (v))
 
     if (isempty (f) || f == -1)
       if (v(i,4:6) == 0)
         f = 1;
-	## elseif (v(i,1:3) == [0, 1, 1])
+        ## elseif (v(i,1:3) == [0, 1, 1])
       elseif (v(i,1:3) == [-1, 12, 31])
         f = 16;
       else
         f = 0;
       endif
     endif
 
     if (isnumeric (f))
diff --git a/scripts/time/weekday.m b/scripts/time/weekday.m
--- a/scripts/time/weekday.m
+++ b/scripts/time/weekday.m
@@ -56,17 +56,17 @@ function [d, s] = weekday (d, form)
   ## Find the offset from a known Sunday (2008-Jan-6), mod 7.
   d = floor (reshape (mod(d - 733048, 7), endsize));
   ## Make Saturdays a 7 and not a 0.
   d(!d) = 7;
 
   if (nargout > 1)
     if (strcmpi (form, "long"))
       names = {"Sunday" "Monday" "Tuesday" "Wednesday" "Thursday"
-	       "Friday" "Saturday"};
+               "Friday" "Saturday"};
     else
       names = {"Sun" "Mon" "Tue" "Wed" "Thu" "Fri" "Sat"};
     endif
     s = strvcat (names(d));
   endif
 
 endfunction
 
