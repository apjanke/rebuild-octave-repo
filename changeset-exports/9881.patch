# HG changeset patch
# User Kacper Kowalik
# Date 1259413256 -3600
#      Sat Nov 28 14:00:56 2009 +0100
# Node ID b3089dba88bfea94b2d0d40fb3aeedc30c1dce5b
# Parent  7f77e5081e8341eeafd9f41f3c5b89762b09c910
Remove HDF5 cruft for older versions of HDF5

diff --git a/doc/ChangeLog b/doc/ChangeLog
--- a/doc/ChangeLog
+++ b/doc/ChangeLog
@@ -1,8 +1,12 @@
+2009-11-27  David Bateman  <dbateman@free.fr>
+
+	* doc/interpreter/contributors.in: Add Kacper Kowalik.
+
 2009-11-27  David Bateman  <dbateman@free.fr>
 
 	* interpreter/install.txi: Document that curl libraries impact ftp
 	objects.
 	* interpreter/system.txi: Document the ftp objects
 
 2009-11-25  Rik <octave@nomad.inbox5.com>
 
diff --git a/doc/interpreter/contributors.in b/doc/interpreter/contributors.in
--- a/doc/interpreter/contributors.in
+++ b/doc/interpreter/contributors.in
@@ -100,16 +100,17 @@ Thomas Kasper
 Joel Keay
 Mumit Khan
 Paul Kienzle
 Aaron A. King
 Arno J. Klaassen
 Geoffrey Knauth
 Heine Kolltveit
 Ken Kouno
+Kacper Kowalik
 Oyvind Kristiansen
 Piotr Krzyzanowski
 Volker Kuhlmann
 Tetsuro Kurita
 Miroslaw Kwasniak
 Rafael Laboissiere
 Kai Labusch
 Claude Lacoursiere
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,69 @@
+2009-11-27  Kacper Kowalik <xarthisius.kk@gmail.com>
+
+	* ls-hdf5.cc (have_h5giterate_bug): Drop this group iteration flag
+	for buggy pre 1.2.2 versions of hdf5.
+	* ov-base-int.cc (octave_base_int_matrix<T>::load_hdf5)
+	octave_base_int_scalar<T>::load_hdf5),
+	ov-base-int.h (octave_base_int_matrix<T>::load_hdf5,
+	octave_base_int_scalar<T>::load_hdf5),
+	ov-base.cc (octave_base_value::load_hdf5),
+	ov-base.h (octave_base_value::load_hdf5),
+	ov-bool-mat.cc (octave_bool_matrix::load_hdf5),
+	ov-bool-mat.h (octave_bool_matrix::load_hdf5),
+	ov-bool-sparse.cc (octave_sparse_bool_matrix::load_hdf5),
+	ov-bool-sparse.h (octave_sparse_bool_matrix::load_hdf5),
+	ov-bool.cc (octave_bool::load_hdf5),
+	ov-bool.h (octave_bool::load_hdf5),
+	ov-cell.cc (octave_cell::load_hdf5),
+	ov-cell.h (octave_cell::load_hdf5),
+	ov-class.cc (octave_class::load_hdf5),
+	ov-class.h (octave_class::load_hdf5),
+	ov-complex.cc (octave_complex::load_hdf5),
+	ov-complex.h (octave_complex::load_hdf5),
+	ov-cx-mat.cc (octave_complex_matrix::load_hdf5),
+	ov-cx-mat.h (octave_complex_matrix::load_hdf5),
+	ov-cx-sparse.cc (octave_sparse_complex_matrix::load_hdf5),
+	ov-cx-sparse.h (octave_sparse_complex_matrix::load_hdf5),
+	ov-fcn-handle.cc (octave_fcn_handle::load_hdf5),
+	ov-fcn-handle.h (octave_fcn_handle::load_hdf5),
+	ov-fcn-inline.cc (octave_fcn_inline::load_hdf5),
+	ov-fcn-inline.h (octave_fcn_inline::load_hdf5),
+	ov-float.cc (octave_float_scalar::load_hdf5),
+	ov-float.h (octave_float_scalar::load_hdf5),
+	ov-flt-complex.cc (octave_float_complex::load_hdf5),
+	ov-flt-complex.h (octave_float_complex::load_hdf5),
+	ov-flt-cx-mat.cc (octave_float_complex_matrix::load_hdf5),
+	ov-flt-cx-mat.h (octave_float_complex_matrix::load_hdf5),
+	ov-flt-re-mat.cc (octave_float_matrix::load_hdf5),
+	ov-flt-re-mat.h (octave_float_matrix::load_hdf5),
+	ov-list.cc (octave_list::load_hdf5),
+	ov-list.h (octave_list::load_hdf5),
+	ov-range.cc (octave_range::load_hdf5),
+	ov-range.h (octave_range::load_hdf5),
+	ov-re-mat.cc (octave_matrix::load_hdf5),
+	ov-re-mat.h (octave_matrix::load_hdf5),
+	ov-re-sparse.cc (octave_sparse_matrix::load_hdf5),
+	ov-re-sparse.h (octave_sparse_matrix::load_hdf5),
+	ov-scalar.cc (octave_scalar::load_hdf5),
+	ov-scalar.h (octave_scalar::load_hdf5),
+	ov-str-mat.cc (octave_char_matrix_str::load_hdf5),
+	ov-str-mat.h (octave_char_matrix_str::load_hdf5),
+	ov-struct.cc (octave_struct::load_hdf5),
+	ov-struct.h (octave_struct::load_hdf5),
+	ov.h (octave_value::load_hdf5):
+	Remove have_hg5iterate_bug from the call to load_hdf5.
+	* ov-cell.cc (octave_bool::load_hdf5),
+	ov-class.cc (octave_class::load_hdf5),
+	ov-fcn-handle.cc (octave_fcn_handle::load_hdf5),
+	ov-list.cc (octave_list::load_hdf5),
+	ov-struct.cc (octave_struct::load_hdf5):
+	Remove HAVE_H5GGET_NUM_OBJS cruft for old hdf5 versions.
+
 2009-11-27  David Bateman  <dbateman@free.fr>
 
 	* DLD-FUNCTIONS/urlwrite.cc (curl_handle, curl_handles): Add classes
 	to manage the open curl connections.
 	(F__ftp__, F__ftp_pwd__, F__ftp_cwd__, F__ftp_dir__, F__ftp_ascii__,
 	F__ftp_binary__, F__ftp_close__, F__ftp_mode__, F__ftp_delete__,
 	F__ftp_rmdir__, F__ftp_mkdir__, F__ftp_rename__, F__ftp_mput__,
 	F__ftp_mget__): New functions.
diff --git a/src/ls-hdf5.cc b/src/ls-hdf5.cc
--- a/src/ls-hdf5.cc
+++ b/src/ls-hdf5.cc
@@ -172,21 +172,16 @@ hdf5_make_complex_type (hid_t num_type)
   hid_t type_id = H5Tcreate (H5T_COMPOUND, sizeof (double) * 2);
 
   H5Tinsert (type_id, "real", 0 * sizeof (double), num_type);
   H5Tinsert (type_id, "imag", 1 * sizeof (double), num_type);
 
   return type_id;
 }
 
-// This variable, set in read_hdf5_data(), tells whether we are using
-// a version of HDF5 with a buggy H5Giterate (i.e. which neglects to
-// increment the index parameter to the next unread item).
-static bool have_h5giterate_bug = false;
-
 // This function is designed to be passed to H5Giterate, which calls it
 // on each data item in an HDF5 file.  For the item whose name is NAME in
 // the group GROUP_ID, this function sets dv->tc to an Octave representation
 // of that item.  (dv must be a pointer to hdf5_callback_data.)  (It also
 // sets the other fields of dv).
 //
 // It returns 1 on success (in which case H5Giterate stops and returns),
 // -1 on error, and 0 to tell H5Giterate to continue on to the next item
@@ -266,18 +261,17 @@ hdf5_read_next_data (hid_t group_id, con
 		       typ) < 0)
 	    goto done;
 
 	  H5Tclose (st_id);
 	  H5Dclose (data_id);
 
 	  d->tc = octave_value_typeinfo::lookup_type (typ);
 
-	  retval = (d->tc.load_hdf5 (subgroup_id, "value", 
-		have_h5giterate_bug) ? 1 : -1);
+	  retval = (d->tc.load_hdf5 (subgroup_id, "value") ? 1 : -1);
 
 	  // check for OCTAVE_GLOBAL attribute:
 	  d->global = hdf5_check_attr (subgroup_id, "OCTAVE_GLOBAL");
 
 	  H5Gclose (subgroup_id);
 	}
       else
 	{
@@ -290,18 +284,17 @@ hdf5_read_next_data (hid_t group_id, con
 	  else
 	    d->tc = octave_value_typeinfo::lookup_type ("struct");
 	  
 	  // check for OCTAVE_GLOBAL attribute:
 	  d->global = hdf5_check_attr (subgroup_id, "OCTAVE_GLOBAL");
 
 	  H5Gclose (subgroup_id);
 
-	  retval = (d->tc.load_hdf5 (group_id, name, have_h5giterate_bug) 
-		    ? 1 : -1);
+	  retval = (d->tc.load_hdf5 (group_id, name) ? 1 : -1);
 	}
 
     }
   else if (info.type == H5G_DATASET && ident_valid)
     {
       // For backwards compatiability.
       data_id = H5Dopen (group_id, name);
 
@@ -466,18 +459,17 @@ hdf5_read_next_data (hid_t group_id, con
 	}
       
       // check for OCTAVE_GLOBAL attribute:
       d->global = hdf5_check_attr (data_id, "OCTAVE_GLOBAL");
 
       H5Tclose (type_id);
       H5Dclose (data_id);
 
-      retval = (d->tc.load_hdf5 (group_id, name, have_h5giterate_bug) 
-		? 1 : -1);
+      retval = (d->tc.load_hdf5 (group_id, name) ? 1 : -1);
     }
 
   if (!ident_valid)
     {
       // should we attempt to handle invalid identifiers by converting
       // bad characters to '_', say?
       warning ("load: skipping invalid identifier `%s' in hdf5 file",
 	       name);
@@ -523,49 +515,26 @@ read_hdf5_data (std::istream& is, const 
 {
   std::string retval;
 
   doc.resize (0);
 
   hdf5_ifstream& hs = dynamic_cast<hdf5_ifstream&> (is);
   hdf5_callback_data d;
 
-  // Versions of HDF5 prior to 1.2.2 had a bug in H5Giterate where it
-  // would return the index of the last item processed instead of the
-  // next item to be processed, forcing us to increment the index manually.
-
-  unsigned int vers_major, vers_minor, vers_release;
-
-  H5get_libversion (&vers_major, &vers_minor, &vers_release);
-
-  // FIXME -- this test looks wrong.
-  have_h5giterate_bug
-    = (vers_major < 1
-       || (vers_major == 1 && (vers_minor < 2
-			       || (vers_minor == 2 && vers_release < 2))));
-
   herr_t H5Giterate_retval = -1;
 
-#ifdef HAVE_H5GGET_NUM_OBJS
   hsize_t num_obj = 0;
   hid_t group_id = H5Gopen (hs.file_id, "/"); 
   H5Gget_num_objs (group_id, &num_obj);
   H5Gclose (group_id);
   if (hs.current_item < static_cast<int> (num_obj))
-#endif
     H5Giterate_retval = H5Giterate (hs.file_id, "/", &hs.current_item,
 				    hdf5_read_next_data, &d);
 
-  if (have_h5giterate_bug)
-    {
-      // H5Giterate sets current_item to the last item processed; we want
-      // the index of the next item (for the next call to read_hdf5_data)
-
-      hs.current_item++;
-    }
 
   if (H5Giterate_retval > 0)
     {
       global = d.global;
       tc = d.tc;
       doc = d.doc;
     }
   else
diff --git a/src/ov-base-int.cc b/src/ov-base-int.cc
--- a/src/ov-base-int.cc
+++ b/src/ov-base-int.cc
@@ -365,18 +365,17 @@ octave_base_int_matrix<T>::save_hdf5 (hi
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
 template <class T>
 bool
-octave_base_int_matrix<T>::load_hdf5 (hid_t loc_id, const char *name,
-				      bool /* have_h5giterate_bug */)
+octave_base_int_matrix<T>::load_hdf5 (hid_t loc_id, const char *name)
 {
   hid_t save_type_hid = HDF5_SAVE_TYPE;
   bool retval = false;
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     this->matrix.resize(dv);
   if (empty)
@@ -555,18 +554,17 @@ octave_base_int_scalar<T>::save_hdf5 (hi
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
 template <class T>
 bool
-octave_base_int_scalar<T>::load_hdf5 (hid_t loc_id, const char *name,
-				      bool /* have_h5giterate_bug */)
+octave_base_int_scalar<T>::load_hdf5 (hid_t loc_id, const char *name)
 {
   hid_t save_type_hid = HDF5_SAVE_TYPE;
   hid_t data_hid = H5Dopen (loc_id, name);
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
   if (rank != 0)
diff --git a/src/ov-base-int.h b/src/ov-base-int.h
--- a/src/ov-base-int.h
+++ b/src/ov-base-int.h
@@ -74,17 +74,17 @@ public:
   bool save_binary (std::ostream& os, bool& );
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format );
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool);
 
-  bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
+  bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 };
 
 // base int scalar values.
 
 template <class T>
 class
 octave_base_int_scalar : public octave_base_scalar<T>
@@ -117,17 +117,17 @@ public:
   bool save_binary (std::ostream& os, bool& );
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format );
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool );
 
-  bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
+  bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -1037,17 +1037,17 @@ bool
 octave_base_value::save_hdf5 (hid_t, const char *, bool)
 {
   gripe_wrong_type_arg ("octave_base_value::save_binary()", type_name ());
 
   return false;
 }
 
 bool 
-octave_base_value::load_hdf5 (hid_t, const char *, bool)
+octave_base_value::load_hdf5 (hid_t, const char *)
 {
   gripe_wrong_type_arg ("octave_base_value::load_binary()", type_name ());
 
   return false;
 }
 
 #endif
 
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -588,17 +588,17 @@ public:
   virtual bool load_binary (std::istream& is, bool swap, 
 			    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   virtual bool
   save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   virtual bool
-  load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
+  load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   virtual int
   write (octave_stream& os, int block_size,
 	 oct_data_conv::data_type output_type, int skip,
 	 oct_mach_info::float_format flt_fmt) const;
 
   virtual void *mex_get_data (void) const { return 0; }
diff --git a/src/ov-bool-mat.cc b/src/ov-bool-mat.cc
--- a/src/ov-bool-mat.cc
+++ b/src/ov-bool-mat.cc
@@ -453,18 +453,17 @@ octave_bool_matrix::save_hdf5 (hid_t loc
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
 bool
-octave_bool_matrix::load_hdf5 (hid_t loc_id, const char *name,
-			       bool /* have_h5giterate_bug */)
+octave_bool_matrix::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize(dv);
   if (empty)
diff --git a/src/ov-bool-mat.h b/src/ov-bool-mat.h
--- a/src/ov-bool-mat.h
+++ b/src/ov-bool-mat.h
@@ -191,17 +191,17 @@ public:
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
+  bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
 	     oct_data_conv::data_type output_type, int skip,
 	     oct_mach_info::float_format flt_fmt) const
     { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
diff --git a/src/ov-bool-sparse.cc b/src/ov-bool-sparse.cc
--- a/src/ov-bool-sparse.cc
+++ b/src/ov-bool-sparse.cc
@@ -505,18 +505,17 @@ octave_sparse_bool_matrix::save_hdf5 (hi
   H5Dclose (data_hid);
   H5Sclose (space_hid);
   H5Gclose (group_hid);
 
   return retval;
 }
 
 bool
-octave_sparse_bool_matrix::load_hdf5 (hid_t loc_id, const char *name,
-				      bool /* have_h5giterate_bug */)
+octave_sparse_bool_matrix::load_hdf5 (hid_t loc_id, const char *name)
 {
   octave_idx_type nr, nc, nz;
   hid_t group_hid, data_hid, space_hid;
   hsize_t rank;
   
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
diff --git a/src/ov-bool-sparse.h b/src/ov-bool-sparse.h
--- a/src/ov-bool-sparse.h
+++ b/src/ov-bool-sparse.h
@@ -129,17 +129,17 @@ public:
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
+  bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   mxArray *as_mxArray (void) const;
 
   // Mapper functions are converted to double for treatment
   octave_value map (unary_mapper_t umap) const
     {
       octave_sparse_matrix m (sparse_matrix_value ());
diff --git a/src/ov-bool.cc b/src/ov-bool.cc
--- a/src/ov-bool.cc
+++ b/src/ov-bool.cc
@@ -185,18 +185,17 @@ octave_bool::save_hdf5 (hid_t loc_id, co
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
 bool
-octave_bool::load_hdf5 (hid_t loc_id, const char *name,
-			bool /* have_h5giterate_bug */)
+octave_bool::load_hdf5 (hid_t loc_id, const char *name)
 {
   hid_t data_hid = H5Dopen (loc_id, name);
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
   if (rank != 0)
     { 
diff --git a/src/ov-bool.h b/src/ov-bool.h
--- a/src/ov-bool.h
+++ b/src/ov-bool.h
@@ -192,17 +192,17 @@ public:
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
+  bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
 	     oct_data_conv::data_type output_type, int skip,
 	     oct_mach_info::float_format flt_fmt) const
     {
       return os.write (bool_array_value (), block_size, output_type,
 		       skip, flt_fmt);
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -1099,18 +1099,17 @@ octave_cell::save_hdf5 (hid_t loc_id, co
     }
 
   H5Gclose (data_hid);
 
   return true;
 }
 
 bool
-octave_cell::load_hdf5 (hid_t loc_id, const char *name,
-			bool have_h5giterate_bug)
+octave_cell::load_hdf5 (hid_t loc_id, const char *name)
 {
   clear_cellstr_cache ();
 
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
@@ -1161,46 +1160,36 @@ octave_cell::load_hdf5 (hid_t loc_id, co
   hdf5_callback_data dsub;
 
   herr_t retval2 = -1;
 
   Cell m (dv);
 
   int current_item = 0;
 
-  if (have_h5giterate_bug)
-    current_item = 1;   // Skip dims items in group.
-
-#ifdef HAVE_H5GGET_NUM_OBJS
   hsize_t num_obj = 0;
   group_id = H5Gopen (loc_id, name); 
   H5Gget_num_objs (group_id, &num_obj);
   H5Gclose (group_id);
-#endif
 
   for (octave_idx_type i = 0; i < dv.numel (); i++)
     {
 
-#ifdef HAVE_H5GGET_NUM_OBJS
       if (current_item >= static_cast<int> (num_obj))
-	retval2 = -1;
+        retval2 = -1;
       else
-#endif
 	retval2 = H5Giterate (loc_id, name, &current_item,
 			      hdf5_read_next_data, &dsub);
       
       if (retval2 <= 0)
 	break;
 
       octave_value ov = dsub.tc;
       m.elem (i) = ov;
 
-      if (have_h5giterate_bug)
-	current_item++;  // H5Giterate returned the last index processed.
-
     }
 
   if (retval2 >= 0)
     {
       matrix = m;
       retval = true;
     }
   
diff --git a/src/ov-cell.h b/src/ov-cell.h
--- a/src/ov-cell.h
+++ b/src/ov-cell.h
@@ -147,17 +147,17 @@ public:
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
+  bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   octave_value map (unary_mapper_t umap) const;
 
   mxArray *as_mxArray (void) const;
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
diff --git a/src/ov-class.cc b/src/ov-class.cc
--- a/src/ov-class.cc
+++ b/src/ov-class.cc
@@ -1466,18 +1466,17 @@ octave_class::save_hdf5 (hid_t loc_id, c
 
   if (group_hid > 0)
     H5Gclose (group_hid);
 
   return true;
 }
 
 bool 
-octave_class::load_hdf5 (hid_t loc_id, const char *name,
-			  bool have_h5giterate_bug)
+octave_class::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   hid_t group_hid = -1;
   hid_t data_hid = -1;
   hid_t type_hid = -1;
   hid_t type_class_hid = -1;
   hid_t space_hid = -1;
@@ -1543,43 +1542,36 @@ octave_class::load_hdf5 (hid_t loc_id, c
       data_hid = -1;
 
       c_name = classname;
     }
   while (0);
   reconstruct_exemplar ();
 
 
-#ifdef HAVE_H5GGET_NUM_OBJS
   subgroup_hid = H5Gopen (group_hid, name); 
   H5Gget_num_objs (subgroup_hid, &num_obj);
   H5Gclose (subgroup_hid);
 
   while (current_item < static_cast<int> (num_obj)
 	 && (retval2 = H5Giterate (group_hid, name, &current_item,
 				   hdf5_read_next_data, &dsub)) > 0)
-#else
-  while ((retval2 = H5Giterate (group_hid, name, &current_item,
-				hdf5_read_next_data, &dsub)) > 0)
-#endif
     {
       octave_value t2 = dsub.tc;
 
       Cell tcell = t2.is_cell () ? t2.cell_value () : Cell (t2);
  
       if (error_state)
 	{
 	  error ("load: internal error loading class elements");
 	  return false;
 	}
 
       m.assign (dsub.name, tcell);
 
-      if (have_h5giterate_bug)
-	current_item++;  // H5Giterate returned the last index processed
     }
 
   if (retval2 >= 0)
     {
       map = m;
 
       if (!reconstruct_parents ())
 	warning ("load: unable to reconstruct object inheritance");
diff --git a/src/ov-class.h b/src/ov-class.h
--- a/src/ov-class.h
+++ b/src/ov-class.h
@@ -165,17 +165,17 @@ public:
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
+  bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   mxArray *as_mxArray (void) const;
 
 private:
 
   Octave_map map;
 
diff --git a/src/ov-complex.cc b/src/ov-complex.cc
--- a/src/ov-complex.cc
+++ b/src/ov-complex.cc
@@ -336,18 +336,17 @@ octave_complex::save_hdf5 (hid_t loc_id,
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
 bool
-octave_complex::load_hdf5 (hid_t loc_id, const char *name,
-			   bool /* have_h5giterate_bug */)
+octave_complex::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
   hid_t data_hid = H5Dopen (loc_id, name);
   hid_t type_hid = H5Dget_type (data_hid);
 
   hid_t complex_type = hdf5_make_complex_type (H5T_NATIVE_DOUBLE);
 
   if (! hdf5_types_compatible (type_hid, complex_type))
diff --git a/src/ov-complex.h b/src/ov-complex.h
--- a/src/ov-complex.h
+++ b/src/ov-complex.h
@@ -167,17 +167,17 @@ public:
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
+  bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
 	     oct_data_conv::data_type output_type, int skip,
 	     oct_mach_info::float_format flt_fmt) const
     {
       // Yes, for compatibility, we drop the imaginary part here.
       return os.write (array_value (true), block_size, output_type,
diff --git a/src/ov-cx-mat.cc b/src/ov-cx-mat.cc
--- a/src/ov-cx-mat.cc
+++ b/src/ov-cx-mat.cc
@@ -610,18 +610,17 @@ octave_complex_matrix::save_hdf5 (hid_t 
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
 bool 
-octave_complex_matrix::load_hdf5 (hid_t loc_id, const char *name,
-				  bool /* have_h5giterate_bug */)
+octave_complex_matrix::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize(dv);
   if (empty)
diff --git a/src/ov-cx-mat.h b/src/ov-cx-mat.h
--- a/src/ov-cx-mat.h
+++ b/src/ov-cx-mat.h
@@ -149,17 +149,17 @@ public:
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
+  bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
 	     oct_data_conv::data_type output_type, int skip,
 	     oct_mach_info::float_format flt_fmt) const
     {
       // Yes, for compatibility, we drop the imaginary part here.
       return os.write (matrix_value (true), block_size, output_type,
diff --git a/src/ov-cx-sparse.cc b/src/ov-cx-sparse.cc
--- a/src/ov-cx-sparse.cc
+++ b/src/ov-cx-sparse.cc
@@ -594,18 +594,17 @@ octave_sparse_complex_matrix::save_hdf5 
   H5Sclose (space_hid);
   H5Tclose (type_hid);
   H5Gclose (group_hid);
 
   return retval;
 }
 
 bool
-octave_sparse_complex_matrix::load_hdf5 (hid_t loc_id, const char *name,
-					 bool /* have_h5giterate_bug */)
+octave_sparse_complex_matrix::load_hdf5 (hid_t loc_id, const char *name)
 {
   octave_idx_type nr, nc, nz;
   hid_t group_hid, data_hid, space_hid;
   hsize_t rank;
   
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
diff --git a/src/ov-cx-sparse.h b/src/ov-cx-sparse.h
--- a/src/ov-cx-sparse.h
+++ b/src/ov-cx-sparse.h
@@ -143,17 +143,17 @@ public:
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
+  bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
 
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -834,18 +834,17 @@ octave_fcn_handle::save_hdf5 (hid_t loc_
   H5Sclose (space_hid);
   H5Tclose (type_hid);
   H5Gclose (group_hid);
 
   return retval;
 }
 
 bool
-octave_fcn_handle::load_hdf5 (hid_t loc_id, const char *name,
-			      bool have_h5giterate_bug)
+octave_fcn_handle::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool success = true;
 
   hid_t group_hid, data_hid, space_hid, type_hid, type_class_hid, st_id;
   hsize_t rank;
   int slen;
 
   group_hid = H5Gopen (loc_id, name);
@@ -1015,46 +1014,41 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
 
       symbol_table::set_scope (local_scope);
 
       octave_call_stack::push (local_scope, 0);
       unwind_protect::add_fcn (octave_call_stack::pop);
 
       if (len > 0 && success)
 	{
-#ifdef HAVE_H5GGET_NUM_OBJS
 	  hsize_t num_obj = 0;
 	  data_hid = H5Gopen (group_hid, "symbol table"); 
 	  H5Gget_num_objs (data_hid, &num_obj);
 	  H5Gclose (data_hid);
 
 	  if (num_obj != static_cast<hsize_t>(len))
 	    {
 	      error ("load: failed to load anonymous function handle");
 	      success = false;
 	    }
-#endif
 
 	  if (! error_state)
 	    {
 	      hdf5_callback_data dsub;
 	      int current_item = 0;
 	      for (octave_idx_type i = 0; i < len; i++)
 		{
 		  if (H5Giterate (group_hid, "symbol table", &current_item,
 				  hdf5_read_next_data, &dsub) <= 0)
 		    {
 		      error ("load: failed to load anonymous function handle");
 		      success = false;
 		      break;
 		    }
 
-		  if (have_h5giterate_bug)
-		    current_item++;  // H5Giterate returns last index processed
-
 		  symbol_table::varref (dsub.name, local_scope) = dsub.tc;
 		}
 	    }
 	}
 
       if (success)
 	{
 	  int parse_status;
diff --git a/src/ov-fcn-handle.h b/src/ov-fcn-handle.h
--- a/src/ov-fcn-handle.h
+++ b/src/ov-fcn-handle.h
@@ -113,17 +113,17 @@ public:
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
+  bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
 private:
 
diff --git a/src/ov-fcn-inline.cc b/src/ov-fcn-inline.cc
--- a/src/ov-fcn-inline.cc
+++ b/src/ov-fcn-inline.cc
@@ -384,18 +384,17 @@ octave_fcn_inline::save_hdf5 (hid_t loc_
   H5Sclose (space_hid);
   H5Tclose (type_hid);
   H5Gclose (group_hid);
 
   return retval;
 }
 
 bool
-octave_fcn_inline::load_hdf5 (hid_t loc_id, const char *name,
-			      bool /* have_h5giterate_bug */)
+octave_fcn_inline::load_hdf5 (hid_t loc_id, const char *name)
 {
   hid_t group_hid, data_hid, space_hid, type_hid, type_class_hid, st_id;
   hsize_t rank;
   int slen;
 
   group_hid = H5Gopen (loc_id, name);
   if (group_hid < 0 ) return false;
 
diff --git a/src/ov-fcn-inline.h b/src/ov-fcn-inline.h
--- a/src/ov-fcn-inline.h
+++ b/src/ov-fcn-inline.h
@@ -76,17 +76,17 @@ public:
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
+  bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
 private:
 
diff --git a/src/ov-float.cc b/src/ov-float.cc
--- a/src/ov-float.cc
+++ b/src/ov-float.cc
@@ -204,18 +204,17 @@ octave_float_scalar::save_hdf5 (hid_t lo
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
 bool
-octave_float_scalar::load_hdf5 (hid_t loc_id, const char *name,
-			  bool /* have_h5giterate_bug */)
+octave_float_scalar::load_hdf5 (hid_t loc_id, const char *name)
 {
   hid_t data_hid = H5Dopen (loc_id, name);
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
   if (rank != 0)
     { 
diff --git a/src/ov-float.h b/src/ov-float.h
--- a/src/ov-float.h
+++ b/src/ov-float.h
@@ -226,17 +226,17 @@ public:
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
+  bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
 	     oct_data_conv::data_type output_type, int skip,
 	     oct_mach_info::float_format flt_fmt) const
     {
       return os.write (array_value (), block_size, output_type,
 		       skip, flt_fmt);
diff --git a/src/ov-flt-complex.cc b/src/ov-flt-complex.cc
--- a/src/ov-flt-complex.cc
+++ b/src/ov-flt-complex.cc
@@ -321,18 +321,17 @@ octave_float_complex::save_hdf5 (hid_t l
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
 bool
-octave_float_complex::load_hdf5 (hid_t loc_id, const char *name,
-			   bool /* have_h5giterate_bug */)
+octave_float_complex::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
   hid_t data_hid = H5Dopen (loc_id, name);
   hid_t type_hid = H5Dget_type (data_hid);
 
   hid_t complex_type = hdf5_make_complex_type (H5T_NATIVE_FLOAT);
 
   if (! hdf5_types_compatible (type_hid, complex_type))
diff --git a/src/ov-flt-complex.h b/src/ov-flt-complex.h
--- a/src/ov-flt-complex.h
+++ b/src/ov-flt-complex.h
@@ -165,17 +165,17 @@ public:
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
+  bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
 	     oct_data_conv::data_type output_type, int skip,
 	     oct_mach_info::float_format flt_fmt) const
     {
       // Yes, for compatibility, we drop the imaginary part here.
       return os.write (array_value (true), block_size, output_type,
diff --git a/src/ov-flt-cx-mat.cc b/src/ov-flt-cx-mat.cc
--- a/src/ov-flt-cx-mat.cc
+++ b/src/ov-flt-cx-mat.cc
@@ -577,18 +577,17 @@ octave_float_complex_matrix::save_hdf5 (
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
 bool 
-octave_float_complex_matrix::load_hdf5 (hid_t loc_id, const char *name,
-				  bool /* have_h5giterate_bug */)
+octave_float_complex_matrix::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize(dv);
   if (empty)
diff --git a/src/ov-flt-cx-mat.h b/src/ov-flt-cx-mat.h
--- a/src/ov-flt-cx-mat.h
+++ b/src/ov-flt-cx-mat.h
@@ -147,17 +147,17 @@ public:
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
+  bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
 	     oct_data_conv::data_type output_type, int skip,
 	     oct_mach_info::float_format flt_fmt) const
     {
       // Yes, for compatibility, we drop the imaginary part here.
       return os.write (matrix_value (true), block_size, output_type,
diff --git a/src/ov-flt-re-mat.cc b/src/ov-flt-re-mat.cc
--- a/src/ov-flt-re-mat.cc
+++ b/src/ov-flt-re-mat.cc
@@ -590,18 +590,17 @@ octave_float_matrix::save_hdf5 (hid_t lo
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
 bool
-octave_float_matrix::load_hdf5 (hid_t loc_id, const char *name,
-			  bool /* have_h5giterate_bug */)
+octave_float_matrix::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize(dv);
   if (empty)
diff --git a/src/ov-flt-re-mat.h b/src/ov-flt-re-mat.h
--- a/src/ov-flt-re-mat.h
+++ b/src/ov-flt-re-mat.h
@@ -183,17 +183,17 @@ public:
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
+  bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
 	     oct_data_conv::data_type output_type, int skip,
 	     oct_mach_info::float_format flt_fmt) const
     { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
diff --git a/src/ov-list.cc b/src/ov-list.cc
--- a/src/ov-list.cc
+++ b/src/ov-list.cc
@@ -707,44 +707,35 @@ octave_list::save_hdf5 (hid_t loc_id, co
     }
 
   H5Gclose (data_hid);
 
   return true;
 }
 
 bool
-octave_list::load_hdf5 (hid_t loc_id,  const char *name,
-			bool have_h5giterate_bug)
+octave_list::load_hdf5 (hid_t loc_id,  const char *name)
 {
   bool retval = false;
 
   hdf5_callback_data dsub;
 
   herr_t retval2 = -1;
   octave_value_list lst;
   int current_item = 0;
-#ifdef HAVE_H5GGET_NUM_OBJS
   hsize_t num_obj = 0;
   hid_t group_id = H5Gopen (loc_id, name); 
   H5Gget_num_objs (group_id, &num_obj);
   H5Gclose (group_id);
 
   while (current_item < static_cast<int> (num_obj)
 	 && (retval2 = H5Giterate (loc_id, name, &current_item,
 				   hdf5_read_next_data, &dsub)) > 0)
-#else
-  while ((retval2 = H5Giterate (loc_id, name, &current_item,
-				hdf5_read_next_data, &dsub)) > 0)
-#endif
     {
       lst.append (dsub.tc);
-
-      if (have_h5giterate_bug)
-	current_item++;  // H5Giterate returned the last index processed
     }
 
   if (retval2 >= 0)
     {
       data = lst;
       retval = true;
     }
   
diff --git a/src/ov-list.h b/src/ov-list.h
--- a/src/ov-list.h
+++ b/src/ov-list.h
@@ -106,17 +106,17 @@ public:
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
+  bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
 protected:
 
   // The list of Octave values.
   Cell data;
 
 private:
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -483,18 +483,17 @@ octave_range::save_hdf5 (hid_t loc_id, c
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
 bool 
-octave_range::load_hdf5 (hid_t loc_id, const char *name,
-			 bool /* have_h5giterate_bug */)
+octave_range::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   hid_t data_hid = H5Dopen (loc_id, name);
   hid_t type_hid = H5Dget_type (data_hid);
 
   hid_t range_type = hdf5_make_range_type (H5T_NATIVE_DOUBLE);
 
diff --git a/src/ov-range.h b/src/ov-range.h
--- a/src/ov-range.h
+++ b/src/ov-range.h
@@ -273,17 +273,17 @@ public:
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
+  bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
 	     oct_data_conv::data_type output_type, int skip,
 	     oct_mach_info::float_format flt_fmt) const
     {
       // FIXME -- could be more memory efficient by having a
       // special case of the octave_stream::write method for ranges.
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -618,18 +618,17 @@ octave_matrix::save_hdf5 (hid_t loc_id, 
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
 bool
-octave_matrix::load_hdf5 (hid_t loc_id, const char *name,
-			  bool /* have_h5giterate_bug */)
+octave_matrix::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize(dv);
   if (empty)
diff --git a/src/ov-re-mat.h b/src/ov-re-mat.h
--- a/src/ov-re-mat.h
+++ b/src/ov-re-mat.h
@@ -197,17 +197,17 @@ public:
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
+  bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
 	     oct_data_conv::data_type output_type, int skip,
 	     oct_mach_info::float_format flt_fmt) const
     { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
diff --git a/src/ov-re-sparse.cc b/src/ov-re-sparse.cc
--- a/src/ov-re-sparse.cc
+++ b/src/ov-re-sparse.cc
@@ -592,18 +592,17 @@ octave_sparse_matrix::save_hdf5 (hid_t l
   H5Dclose (data_hid);
   H5Sclose (space_hid);
   H5Gclose (group_hid);
 
   return retval;
 }
 
 bool
-octave_sparse_matrix::load_hdf5 (hid_t loc_id, const char *name,
-				 bool /* have_h5giterate_bug */)
+octave_sparse_matrix::load_hdf5 (hid_t loc_id, const char *name)
 {
   octave_idx_type nr, nc, nz;
   hid_t group_hid, data_hid, space_hid;
   hsize_t rank;
   
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
diff --git a/src/ov-re-sparse.h b/src/ov-re-sparse.h
--- a/src/ov-re-sparse.h
+++ b/src/ov-re-sparse.h
@@ -142,17 +142,17 @@ public:
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
+  bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const;
 
 private:
   octave_value map (double (*fcn) (double)) const;
diff --git a/src/ov-scalar.cc b/src/ov-scalar.cc
--- a/src/ov-scalar.cc
+++ b/src/ov-scalar.cc
@@ -219,18 +219,17 @@ octave_scalar::save_hdf5 (hid_t loc_id, 
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
 bool
-octave_scalar::load_hdf5 (hid_t loc_id, const char *name,
-			  bool /* have_h5giterate_bug */)
+octave_scalar::load_hdf5 (hid_t loc_id, const char *name)
 {
   hid_t data_hid = H5Dopen (loc_id, name);
   hid_t space_id = H5Dget_space (data_hid);
 
   hsize_t rank = H5Sget_simple_extent_ndims (space_id);
 
   if (rank != 0)
     { 
diff --git a/src/ov-scalar.h b/src/ov-scalar.h
--- a/src/ov-scalar.h
+++ b/src/ov-scalar.h
@@ -227,17 +227,17 @@ public:
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
+  bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
 	     oct_data_conv::data_type output_type, int skip,
 	     oct_mach_info::float_format flt_fmt) const
     {
       return os.write (array_value (), block_size, output_type,
 		       skip, flt_fmt);
diff --git a/src/ov-str-mat.cc b/src/ov-str-mat.cc
--- a/src/ov-str-mat.cc
+++ b/src/ov-str-mat.cc
@@ -580,18 +580,17 @@ octave_char_matrix_str::save_hdf5 (hid_t
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
   return retval;
 }
 
 bool 
-octave_char_matrix_str::load_hdf5 (hid_t loc_id, const char *name,
-				   bool /* have_h5giterate_bug */)
+octave_char_matrix_str::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   dim_vector dv;
   int empty = load_hdf5_empty (loc_id, name, dv);
   if (empty > 0)
     matrix.resize(dv);
   if (empty)
diff --git a/src/ov-str-mat.h b/src/ov-str-mat.h
--- a/src/ov-str-mat.h
+++ b/src/ov-str-mat.h
@@ -147,17 +147,17 @@ public:
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
+  bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   int write (octave_stream& os, int block_size,
 	     oct_data_conv::data_type output_type, int skip,
 	     oct_mach_info::float_format flt_fmt) const
     { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
 protected:
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -1513,57 +1513,49 @@ octave_struct::save_hdf5 (hid_t loc_id, 
     }
 
   H5Gclose (data_hid);
 
   return true;
 }
 
 bool 
-octave_struct::load_hdf5 (hid_t loc_id, const char *name,
-			  bool have_h5giterate_bug)
+octave_struct::load_hdf5 (hid_t loc_id, const char *name)
 {
   bool retval = false;
 
   hdf5_callback_data dsub;
 
   herr_t retval2 = 0;
   Octave_map m (dim_vector (1, 1));
   int current_item = 0;
-#ifdef HAVE_H5GGET_NUM_OBJS
   hsize_t num_obj = 0;
   hid_t group_id = H5Gopen (loc_id, name); 
   H5Gget_num_objs (group_id, &num_obj);
   H5Gclose (group_id);
 
   // FIXME -- fields appear to be sorted alphabetically on loading.
   // Why is that happening?
 
   while (current_item < static_cast<int> (num_obj)
 	 && (retval2 = H5Giterate (loc_id, name, &current_item,
 				   hdf5_read_next_data, &dsub)) > 0)
-#else
-  while ((retval2 = H5Giterate (loc_id, name, &current_item,
-				hdf5_read_next_data, &dsub)) > 0)
-#endif
     {
       octave_value t2 = dsub.tc;
 
       Cell tcell = t2.is_cell () ? t2.cell_value () : Cell (t2);
  
       if (error_state)
 	{
 	  error ("load: internal error loading struct elements");
 	  return false;
 	}
 
       m.assign (dsub.name, tcell);
 
-      if (have_h5giterate_bug)
-	current_item++;  // H5Giterate returned the last index processed
     }
 
   if (retval2 >= 0)
     {
       map = m;
       retval = true;
     }
   
diff --git a/src/ov-struct.h b/src/ov-struct.h
--- a/src/ov-struct.h
+++ b/src/ov-struct.h
@@ -137,17 +137,17 @@ public:
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
-  bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
+  bool load_hdf5 (hid_t loc_id, const char *name);
 #endif
 
   mxArray *as_mxArray (void) const;
 
 protected:
 
   // The associative array used to manage the structure data.
   Octave_map map;
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -1024,19 +1024,18 @@ public:
   bool load_binary (std::istream& is, bool swap,
 			    oct_mach_info::float_format fmt)
     { return rep->load_binary (is, swap, fmt); }
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats)
     { return rep->save_hdf5 (loc_id, name, save_as_floats); }
 
-  bool load_hdf5 (hid_t loc_id, const char *name,
-			  bool have_h5giterate_bug)
-    { return rep->load_hdf5 (loc_id, name, have_h5giterate_bug); }
+  bool load_hdf5 (hid_t loc_id, const char *name)
+    { return rep->load_hdf5 (loc_id, name); }
 #endif
 
   int write (octave_stream& os, int block_size,
 		     oct_data_conv::data_type output_type, int skip,
 		     oct_mach_info::float_format flt_fmt) const;
 
   octave_base_value *internal_rep (void) const { return rep; }
 
